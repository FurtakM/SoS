// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 61 0 0
// InitMacro ;
  15: CALL 34739 0 0
// InitNature ;
  19: CALL 34563 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10946 0 0
// PrepareRussian ;
  40: CALL 6920 0 0
// PrepareLegion ;
  44: CALL 4160 0 0
// PreparePowell ;
  48: CALL 2914 0 0
// PrepareAmerican ;
  52: CALL 1686 0 0
// MC_Start ( ) ;
  56: CALL 36851 0 0
// end ;
  60: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  61: LD_INT 0
  63: PPUSH
// debug := 1 ;
  64: LD_ADDR_EXP 1
  68: PUSH
  69: LD_INT 1
  71: ST_TO_ADDR
// missionStart := false ;
  72: LD_ADDR_EXP 13
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionTime := 0 0$00 ;
  80: LD_ADDR_EXP 14
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionStage := 1 ;
  88: LD_ADDR_EXP 15
  92: PUSH
  93: LD_INT 1
  95: ST_TO_ADDR
// activeAttacks := false ;
  96: LD_ADDR_EXP 16
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// powellAnger := 0 ;
 104: LD_ADDR_EXP 17
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAngerQuery := false ;
 112: LD_ADDR_EXP 36
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAllowRetreat := true ;
 120: LD_ADDR_EXP 19
 124: PUSH
 125: LD_INT 1
 127: ST_TO_ADDR
// powellCenterCameraMode := false ;
 128: LD_ADDR_EXP 20
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 136: LD_ADDR_EXP 18
 140: PUSH
 141: EMPTY
 142: PUSH
 143: EMPTY
 144: PUSH
 145: EMPTY
 146: LIST
 147: LIST
 148: ST_TO_ADDR
// russianDestroyed := false ;
 149: LD_ADDR_EXP 21
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// legionDestroyed := false ;
 157: LD_ADDR_EXP 22
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// allianceDestroyed := false ;
 165: LD_ADDR_EXP 23
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 173: LD_ADDR_EXP 2
 177: PUSH
 178: LD_STRING 14_KappaStatus_1
 180: PPUSH
 181: LD_INT 0
 183: PPUSH
 184: CALL_OW 30
 188: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 189: LD_ADDR_EXP 3
 193: PUSH
 194: LD_STRING 06_KurtStatus_1
 196: PPUSH
 197: LD_INT 0
 199: PPUSH
 200: CALL_OW 30
 204: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 205: LD_ADDR_EXP 4
 209: PUSH
 210: LD_STRING 14_JMMVeh_1
 212: PPUSH
 213: LD_INT 0
 215: PPUSH
 216: CALL_OW 30
 220: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 221: LD_ADDR_EXP 5
 225: PUSH
 226: LD_STRING 14_JMMGirlVeh_1
 228: PPUSH
 229: LD_INT 0
 231: PPUSH
 232: CALL_OW 30
 236: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 237: LD_ADDR_EXP 7
 241: PUSH
 242: LD_STRING 14_JMMGirl_1
 244: PPUSH
 245: LD_INT 0
 247: PPUSH
 248: CALL_OW 30
 252: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 253: LD_ADDR_EXP 6
 257: PUSH
 258: LD_STRING 14_JMMGirlStatus_1
 260: PPUSH
 261: LD_INT 0
 263: PPUSH
 264: CALL_OW 30
 268: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 269: LD_ADDR_EXP 8
 273: PUSH
 274: LD_STRING 10_KhatamStatus_1
 276: PPUSH
 277: LD_INT 0
 279: PPUSH
 280: CALL_OW 30
 284: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 285: LD_ADDR_EXP 9
 289: PUSH
 290: LD_STRING 13_BurlakStatus_1
 292: PPUSH
 293: LD_INT 0
 295: PPUSH
 296: CALL_OW 30
 300: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 301: LD_ADDR_EXP 10
 305: PUSH
 306: LD_STRING 13_StevensStatus_1
 308: PPUSH
 309: LD_INT 0
 311: PPUSH
 312: CALL_OW 30
 316: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 317: LD_ADDR_EXP 11
 321: PUSH
 322: LD_STRING 14_FastEnd_1
 324: PPUSH
 325: LD_INT 0
 327: PPUSH
 328: CALL_OW 30
 332: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 333: LD_ADDR_EXP 12
 337: PUSH
 338: LD_STRING 12_MainDepositFake_1
 340: PPUSH
 341: LD_INT 0
 343: PPUSH
 344: CALL_OW 30
 348: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 349: LD_ADDR_EXP 24
 353: PUSH
 354: LD_INT 1
 356: ST_TO_ADDR
// behemothUnderConstruct := false ;
 357: LD_ADDR_EXP 26
 361: PUSH
 362: LD_INT 0
 364: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 365: LD_ADDR_EXP 27
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDone := false ;
 373: LD_ADDR_EXP 28
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// allowBehemothConstruct := false ;
 381: LD_ADDR_EXP 25
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// seeBehemoth := false ;
 389: LD_ADDR_EXP 29
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// platonovHasBomb := false ;
 397: LD_ADDR_EXP 30
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// allianceActive := false ;
 405: LD_ADDR_EXP 31
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// rothCaptured := false ;
 413: LD_ADDR_EXP 33
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// lostCounter := 0 ;
 421: LD_ADDR_EXP 32
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// capturedUnit := [ ] ;
 429: LD_ADDR_EXP 34
 433: PUSH
 434: EMPTY
 435: ST_TO_ADDR
// trueAmericans := [ ] ;
 436: LD_ADDR_EXP 35
 440: PUSH
 441: EMPTY
 442: ST_TO_ADDR
// bombExploded := false ;
 443: LD_ADDR_EXP 37
 447: PUSH
 448: LD_INT 0
 450: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 451: LD_ADDR_EXP 38
 455: PUSH
 456: EMPTY
 457: ST_TO_ADDR
// end ;
 458: LD_VAR 0 1
 462: RET
// export function CustomInitMacro ( ) ; begin
 463: LD_INT 0
 465: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 466: LD_ADDR_EXP 126
 470: PUSH
 471: LD_INT 2
 473: PUSH
 474: LD_INT 3
 476: PUSH
 477: LD_INT 6
 479: PUSH
 480: LD_INT 10
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 489: LD_ADDR_EXP 127
 493: PUSH
 494: LD_INT 1
 496: PUSH
 497: LD_INT 4
 499: PUSH
 500: LD_INT 5
 502: PUSH
 503: LD_INT 9
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 512: LD_INT 1
 514: PPUSH
 515: LD_INT 10
 517: PUSH
 518: LD_INT 11
 520: PUSH
 521: LD_INT 12
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PPUSH
 529: CALL 59128 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 533: LD_INT 1
 535: PPUSH
 536: LD_INT 17
 538: PUSH
 539: EMPTY
 540: LIST
 541: PPUSH
 542: CALL 59221 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 546: LD_INT 1
 548: PPUSH
 549: LD_INT 5
 551: PPUSH
 552: CALL 58571 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 556: LD_INT 1
 558: PPUSH
 559: LD_INT 24
 561: PUSH
 562: LD_INT 3
 564: PUSH
 565: LD_INT 3
 567: PUSH
 568: LD_INT 47
 570: PUSH
 571: EMPTY
 572: LIST
 573: LIST
 574: LIST
 575: LIST
 576: PUSH
 577: LD_INT 24
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 3
 585: PUSH
 586: LD_INT 47
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: LIST
 593: LIST
 594: PUSH
 595: LD_INT 24
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 47
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 24
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 1
 621: PUSH
 622: LD_INT 47
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 24
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 1
 639: PUSH
 640: LD_INT 47
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: LIST
 655: PPUSH
 656: CALL 58386 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 660: LD_INT 2
 662: PPUSH
 663: LD_INT 10
 665: PUSH
 666: LD_INT 11
 668: PUSH
 669: LD_INT 12
 671: PUSH
 672: LD_INT 14
 674: PUSH
 675: EMPTY
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 59128 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 685: LD_INT 2
 687: PPUSH
 688: LD_INT 16
 690: PUSH
 691: EMPTY
 692: LIST
 693: PPUSH
 694: CALL 59221 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 698: LD_INT 2
 700: PPUSH
 701: LD_INT 21
 703: PUSH
 704: LD_INT 3
 706: PUSH
 707: LD_INT 3
 709: PUSH
 710: LD_INT 51
 712: PUSH
 713: EMPTY
 714: LIST
 715: LIST
 716: LIST
 717: LIST
 718: PUSH
 719: LD_INT 22
 721: PUSH
 722: LD_INT 3
 724: PUSH
 725: LD_INT 3
 727: PUSH
 728: LD_INT 52
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: LIST
 735: LIST
 736: PUSH
 737: LD_INT 22
 739: PUSH
 740: LD_INT 3
 742: PUSH
 743: LD_INT 3
 745: PUSH
 746: LD_INT 52
 748: PUSH
 749: EMPTY
 750: LIST
 751: LIST
 752: LIST
 753: LIST
 754: PUSH
 755: LD_INT 24
 757: PUSH
 758: LD_INT 3
 760: PUSH
 761: LD_INT 3
 763: PUSH
 764: LD_INT 47
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: PUSH
 773: LD_INT 24
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 3
 781: PUSH
 782: LD_INT 47
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: LIST
 789: LIST
 790: PUSH
 791: LD_INT 24
 793: PUSH
 794: LD_INT 3
 796: PUSH
 797: LD_INT 3
 799: PUSH
 800: LD_INT 47
 802: PUSH
 803: EMPTY
 804: LIST
 805: LIST
 806: LIST
 807: LIST
 808: PUSH
 809: LD_INT 24
 811: PUSH
 812: LD_INT 3
 814: PUSH
 815: LD_INT 3
 817: PUSH
 818: LD_INT 47
 820: PUSH
 821: EMPTY
 822: LIST
 823: LIST
 824: LIST
 825: LIST
 826: PUSH
 827: LD_INT 24
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: LD_INT 3
 835: PUSH
 836: LD_INT 47
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: LIST
 843: LIST
 844: PUSH
 845: EMPTY
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: PPUSH
 855: CALL 58386 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 859: LD_INT 2
 861: PPUSH
 862: LD_INT 5
 864: PPUSH
 865: CALL 58571 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 869: LD_INT 2
 871: PPUSH
 872: LD_INT 0
 874: PPUSH
 875: CALL 59001 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 879: LD_INT 3
 881: PPUSH
 882: LD_INT 10
 884: PUSH
 885: LD_INT 12
 887: PUSH
 888: LD_INT 15
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: PUSH
 896: LD_OWVAR 67
 900: ARRAY
 901: PPUSH
 902: LD_INT 27
 904: PPUSH
 905: CALL 58068 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 909: LD_INT 3
 911: PPUSH
 912: LD_INT 10
 914: PUSH
 915: LD_INT 11
 917: PUSH
 918: LD_INT 13
 920: PUSH
 921: LD_INT 15
 923: PUSH
 924: EMPTY
 925: LIST
 926: LIST
 927: LIST
 928: LIST
 929: PPUSH
 930: CALL 59128 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 934: LD_INT 3
 936: PPUSH
 937: LD_INT 15
 939: PUSH
 940: EMPTY
 941: LIST
 942: PPUSH
 943: CALL 59221 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 947: LD_ADDR_EXP 131
 951: PUSH
 952: LD_EXP 131
 956: PPUSH
 957: LD_INT 3
 959: PPUSH
 960: LD_INT 22
 962: PUSH
 963: LD_INT 8
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: PUSH
 970: LD_INT 25
 972: PUSH
 973: LD_INT 15
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL_OW 69
 988: PPUSH
 989: CALL_OW 1
 993: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 994: LD_INT 3
 996: PPUSH
 997: LD_INT 13
 999: PUSH
1000: LD_INT 2
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 31
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 13
1017: PUSH
1018: LD_INT 2
1020: PUSH
1021: LD_INT 1
1023: PUSH
1024: LD_INT 31
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: LD_INT 13
1035: PUSH
1036: LD_INT 3
1038: PUSH
1039: LD_INT 2
1041: PUSH
1042: LD_INT 32
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: PPUSH
1056: CALL 58386 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1060: LD_INT 4
1062: PPUSH
1063: LD_INT 10
1065: PUSH
1066: LD_INT 12
1068: PUSH
1069: EMPTY
1070: LIST
1071: LIST
1072: PPUSH
1073: CALL 59128 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1077: LD_INT 4
1079: PPUSH
1080: LD_INT 9
1082: PUSH
1083: EMPTY
1084: LIST
1085: PPUSH
1086: CALL 59221 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1090: LD_INT 4
1092: PPUSH
1093: LD_INT 26
1095: PUSH
1096: LD_INT 74
1098: PUSH
1099: LD_INT 107
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: PUSH
1111: LD_INT 32
1113: PUSH
1114: LD_INT 77
1116: PUSH
1117: LD_INT 101
1119: PUSH
1120: LD_INT 4
1122: PUSH
1123: EMPTY
1124: LIST
1125: LIST
1126: LIST
1127: LIST
1128: PUSH
1129: LD_INT 32
1131: PUSH
1132: LD_INT 69
1134: PUSH
1135: LD_INT 86
1137: PUSH
1138: LD_INT 4
1140: PUSH
1141: EMPTY
1142: LIST
1143: LIST
1144: LIST
1145: LIST
1146: PUSH
1147: LD_INT 27
1149: PUSH
1150: LD_INT 77
1152: PUSH
1153: LD_INT 110
1155: PUSH
1156: LD_INT 3
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: PUSH
1165: LD_INT 27
1167: PUSH
1168: LD_INT 42
1170: PUSH
1171: LD_INT 79
1173: PUSH
1174: LD_INT 5
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 29
1185: PUSH
1186: LD_INT 86
1188: PUSH
1189: LD_INT 105
1191: PUSH
1192: LD_INT 2
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 30
1203: PUSH
1204: LD_INT 40
1206: PUSH
1207: LD_INT 75
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 32
1221: PUSH
1222: LD_INT 80
1224: PUSH
1225: LD_INT 106
1227: PUSH
1228: LD_INT 4
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 32
1239: PUSH
1240: LD_INT 75
1242: PUSH
1243: LD_INT 114
1245: PUSH
1246: LD_INT 5
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 32
1257: PUSH
1258: LD_INT 82
1260: PUSH
1261: LD_INT 110
1263: PUSH
1264: LD_INT 5
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: LD_INT 32
1275: PUSH
1276: LD_INT 62
1278: PUSH
1279: LD_INT 78
1281: PUSH
1282: LD_INT 4
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: PUSH
1291: LD_INT 4
1293: PUSH
1294: LD_INT 39
1296: PUSH
1297: LD_INT 61
1299: PUSH
1300: LD_INT 3
1302: PUSH
1303: EMPTY
1304: LIST
1305: LIST
1306: LIST
1307: LIST
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: PPUSH
1323: CALL 58278 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1327: LD_INT 4
1329: PPUSH
1330: LD_INT 5
1332: PUSH
1333: LD_INT 6
1335: PUSH
1336: LD_INT 7
1338: PUSH
1339: LD_INT 9
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: PPUSH
1348: CALL 59539 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1352: LD_INT 4
1354: PPUSH
1355: LD_INT 40
1357: PUSH
1358: LD_INT 75
1360: PUSH
1361: LD_INT 1
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: LIST
1368: PUSH
1369: LD_INT 86
1371: PUSH
1372: LD_INT 105
1374: PUSH
1375: LD_INT 0
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: PPUSH
1387: CALL 58710 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1391: LD_INT 4
1393: PPUSH
1394: LD_INT 2
1396: PPUSH
1397: CALL 59001 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1401: LD_INT 4
1403: PPUSH
1404: LD_INT 0
1406: PPUSH
1407: CALL 59001 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1411: LD_INT 4
1413: PPUSH
1414: LD_INT 54
1416: PPUSH
1417: LD_INT 85
1419: PPUSH
1420: LD_INT 2
1422: PPUSH
1423: LD_INT 19
1425: PUSH
1426: LD_INT 16
1428: PUSH
1429: LD_INT 17
1431: PUSH
1432: LD_INT 18
1434: PUSH
1435: EMPTY
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: PPUSH
1441: CALL 59333 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1445: LD_INT 4
1447: PPUSH
1448: LD_INT 3
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 1
1456: PUSH
1457: LD_INT 5
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: PUSH
1466: LD_INT 4
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 1
1474: PUSH
1475: LD_INT 6
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PUSH
1484: LD_INT 4
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 7
1495: PUSH
1496: EMPTY
1497: LIST
1498: LIST
1499: LIST
1500: LIST
1501: PUSH
1502: LD_INT 4
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 1
1510: PUSH
1511: LD_INT 6
1513: PUSH
1514: EMPTY
1515: LIST
1516: LIST
1517: LIST
1518: LIST
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: PPUSH
1526: CALL 58386 0 2
// MC_SetTame ( 4 , powellApe ) ;
1530: LD_INT 4
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: CALL 58952 0 2
// end ;
1540: LD_VAR 0 1
1544: RET
// every 0 0$1 trigger debug do var i , tmp ;
1545: LD_EXP 1
1549: IFFALSE 1656
1551: GO 1553
1553: DISABLE
1554: LD_INT 0
1556: PPUSH
1557: PPUSH
// begin enable ;
1558: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1559: LD_ADDR_VAR 0 2
1563: PUSH
1564: LD_INT 22
1566: PUSH
1567: LD_INT 1
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: PUSH
1574: LD_INT 3
1576: PUSH
1577: LD_INT 21
1579: PUSH
1580: LD_INT 3
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: PUSH
1587: EMPTY
1588: LIST
1589: LIST
1590: PUSH
1591: LD_INT 3
1593: PUSH
1594: LD_INT 24
1596: PUSH
1597: LD_INT 999
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: LIST
1612: PPUSH
1613: CALL_OW 69
1617: ST_TO_ADDR
// if not tmp then
1618: LD_VAR 0 2
1622: NOT
1623: IFFALSE 1627
// exit ;
1625: GO 1656
// for i in tmp do
1627: LD_ADDR_VAR 0 1
1631: PUSH
1632: LD_VAR 0 2
1636: PUSH
1637: FOR_IN
1638: IFFALSE 1654
// SetLives ( i , 1000 ) ;
1640: LD_VAR 0 1
1644: PPUSH
1645: LD_INT 1000
1647: PPUSH
1648: CALL_OW 234
1652: GO 1637
1654: POP
1655: POP
// end ;
1656: PPOPN 2
1658: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1659: LD_EXP 36
1663: PUSH
1664: LD_EXP 17
1668: PUSH
1669: LD_INT 2
1671: GREATEREQUAL
1672: AND
1673: IFFALSE 1685
1675: GO 1677
1677: DISABLE
// SetAchievement ( ACH_POWELL ) ; end_of_file
1678: LD_STRING ACH_POWELL
1680: PPUSH
1681: CALL_OW 543
1685: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1686: LD_INT 0
1688: PPUSH
// uc_side := 1 ;
1689: LD_ADDR_OWVAR 20
1693: PUSH
1694: LD_INT 1
1696: ST_TO_ADDR
// uc_nation := 1 ;
1697: LD_ADDR_OWVAR 21
1701: PUSH
1702: LD_INT 1
1704: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1705: LD_ADDR_EXP 39
1709: PUSH
1710: LD_STRING JMM
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 14_
1721: PPUSH
1722: CALL 64778 0 3
1726: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1727: LD_EXP 4
1731: NOT
1732: PUSH
1733: LD_EXP 4
1737: PUSH
1738: LD_INT 1
1740: ARRAY
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: NOT
1746: OR
1747: IFFALSE 1770
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1749: LD_INT 5
1751: PPUSH
1752: LD_INT 3
1754: PPUSH
1755: LD_INT 1
1757: PPUSH
1758: LD_INT 9
1760: PPUSH
1761: LD_INT 100
1763: PPUSH
1764: CALL 71893 0 5
1768: GO 1829
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1770: LD_EXP 4
1774: PUSH
1775: LD_INT 1
1777: ARRAY
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PPUSH
1783: LD_EXP 4
1787: PUSH
1788: LD_INT 2
1790: ARRAY
1791: PUSH
1792: LD_INT 1
1794: ARRAY
1795: PPUSH
1796: LD_EXP 4
1800: PUSH
1801: LD_INT 3
1803: ARRAY
1804: PUSH
1805: LD_INT 1
1807: ARRAY
1808: PPUSH
1809: LD_EXP 4
1813: PUSH
1814: LD_INT 4
1816: ARRAY
1817: PUSH
1818: LD_INT 1
1820: ARRAY
1821: PPUSH
1822: LD_INT 30
1824: PPUSH
1825: CALL 71893 0 5
// JMMNewVeh := CreateVehicle ;
1829: LD_ADDR_EXP 56
1833: PUSH
1834: CALL_OW 45
1838: ST_TO_ADDR
// if not JMMNewVeh then
1839: LD_EXP 56
1843: NOT
1844: IFFALSE 1875
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1846: LD_INT 5
1848: PPUSH
1849: LD_INT 3
1851: PPUSH
1852: LD_INT 1
1854: PPUSH
1855: LD_INT 9
1857: PPUSH
1858: LD_INT 100
1860: PPUSH
1861: CALL 71893 0 5
// JMMNewVeh := CreateVehicle ;
1865: LD_ADDR_EXP 56
1869: PUSH
1870: CALL_OW 45
1874: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1875: LD_EXP 56
1879: PPUSH
1880: LD_INT 4
1882: PPUSH
1883: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1887: LD_EXP 56
1891: PPUSH
1892: LD_INT 79
1894: PPUSH
1895: LD_INT 91
1897: PPUSH
1898: LD_INT 0
1900: PPUSH
1901: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1905: LD_EXP 39
1909: PPUSH
1910: LD_EXP 56
1914: PPUSH
1915: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1919: LD_EXP 6
1923: PUSH
1924: LD_EXP 2
1928: NOT
1929: AND
1930: IFFALSE 2188
// begin if not JMMGirlVeh then
1932: LD_EXP 5
1936: NOT
1937: IFFALSE 1960
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1939: LD_INT 3
1941: PPUSH
1942: LD_INT 3
1944: PPUSH
1945: LD_INT 1
1947: PPUSH
1948: LD_INT 9
1950: PPUSH
1951: LD_INT 100
1953: PPUSH
1954: CALL 71893 0 5
1958: GO 2019
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1960: LD_EXP 5
1964: PUSH
1965: LD_INT 1
1967: ARRAY
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PPUSH
1973: LD_EXP 5
1977: PUSH
1978: LD_INT 2
1980: ARRAY
1981: PUSH
1982: LD_INT 1
1984: ARRAY
1985: PPUSH
1986: LD_EXP 5
1990: PUSH
1991: LD_INT 3
1993: ARRAY
1994: PUSH
1995: LD_INT 1
1997: ARRAY
1998: PPUSH
1999: LD_EXP 5
2003: PUSH
2004: LD_INT 4
2006: ARRAY
2007: PUSH
2008: LD_INT 1
2010: ARRAY
2011: PPUSH
2012: LD_INT 30
2014: PPUSH
2015: CALL 71893 0 5
// GirlNewVeh := CreateVehicle ;
2019: LD_ADDR_EXP 57
2023: PUSH
2024: CALL_OW 45
2028: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2029: LD_EXP 57
2033: PPUSH
2034: LD_INT 4
2036: PPUSH
2037: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2041: LD_EXP 57
2045: PPUSH
2046: LD_INT 82
2048: PPUSH
2049: LD_INT 96
2051: PPUSH
2052: LD_INT 0
2054: PPUSH
2055: CALL_OW 48
// if JMMGirl = 1 then
2059: LD_EXP 7
2063: PUSH
2064: LD_INT 1
2066: EQUAL
2067: IFFALSE 2102
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2069: LD_ADDR_EXP 40
2073: PUSH
2074: LD_STRING Joan
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: LD_STRING 14_
2082: PPUSH
2083: CALL 64778 0 3
2087: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2088: LD_EXP 40
2092: PPUSH
2093: LD_EXP 57
2097: PPUSH
2098: CALL_OW 52
// end ; if JMMGirl = 2 then
2102: LD_EXP 7
2106: PUSH
2107: LD_INT 2
2109: EQUAL
2110: IFFALSE 2145
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2112: LD_ADDR_EXP 42
2116: PUSH
2117: LD_STRING Lisa
2119: PPUSH
2120: LD_INT 1
2122: PPUSH
2123: LD_STRING 14_
2125: PPUSH
2126: CALL 64778 0 3
2130: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2131: LD_EXP 42
2135: PPUSH
2136: LD_EXP 57
2140: PPUSH
2141: CALL_OW 52
// end ; if JMMGirl = 3 then
2145: LD_EXP 7
2149: PUSH
2150: LD_INT 3
2152: EQUAL
2153: IFFALSE 2188
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2155: LD_ADDR_EXP 54
2159: PUSH
2160: LD_STRING Connie
2162: PPUSH
2163: LD_INT 1
2165: PPUSH
2166: LD_STRING 14_
2168: PPUSH
2169: CALL 64778 0 3
2173: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2174: LD_EXP 54
2178: PPUSH
2179: LD_EXP 57
2183: PPUSH
2184: CALL_OW 52
// end ; end ; end ;
2188: LD_VAR 0 1
2192: RET
// export function PrepareStevensSquad ; var tmp ; begin
2193: LD_INT 0
2195: PPUSH
2196: PPUSH
// uc_side := 1 ;
2197: LD_ADDR_OWVAR 20
2201: PUSH
2202: LD_INT 1
2204: ST_TO_ADDR
// uc_nation := 1 ;
2205: LD_ADDR_OWVAR 21
2209: PUSH
2210: LD_INT 1
2212: ST_TO_ADDR
// tmp := [ ] ;
2213: LD_ADDR_VAR 0 2
2217: PUSH
2218: EMPTY
2219: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2220: LD_ADDR_EXP 41
2224: PUSH
2225: LD_STRING Stevens
2227: PPUSH
2228: LD_EXP 1
2232: NOT
2233: PPUSH
2234: LD_STRING 13f_
2236: PPUSH
2237: CALL 64778 0 3
2241: ST_TO_ADDR
// if not Stevens then
2242: LD_EXP 41
2246: NOT
2247: IFFALSE 2303
// begin hc_name = Baker Smith ;
2249: LD_ADDR_OWVAR 26
2253: PUSH
2254: LD_STRING Baker Smith
2256: ST_TO_ADDR
// hc_gallery =  ;
2257: LD_ADDR_OWVAR 33
2261: PUSH
2262: LD_STRING 
2264: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 10
2270: PPUSH
2271: CALL_OW 384
// Baker = CreateHuman ;
2275: LD_ADDR_EXP 55
2279: PUSH
2280: CALL_OW 44
2284: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2285: LD_ADDR_VAR 0 2
2289: PUSH
2290: LD_VAR 0 2
2294: PUSH
2295: LD_EXP 55
2299: ADD
2300: ST_TO_ADDR
// end else
2301: GO 2319
// tmp := tmp ^ Stevens ;
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 2
2312: PUSH
2313: LD_EXP 41
2317: ADD
2318: ST_TO_ADDR
// if not Lisa then
2319: LD_EXP 42
2323: NOT
2324: IFFALSE 2370
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2326: LD_ADDR_EXP 42
2330: PUSH
2331: LD_STRING Lisa
2333: PPUSH
2334: LD_EXP 1
2338: NOT
2339: PPUSH
2340: LD_STRING 13f_
2342: PPUSH
2343: CALL 64778 0 3
2347: ST_TO_ADDR
// if Lisa then
2348: LD_EXP 42
2352: IFFALSE 2370
// tmp := tmp ^ Lisa ;
2354: LD_ADDR_VAR 0 2
2358: PUSH
2359: LD_VAR 0 2
2363: PUSH
2364: LD_EXP 42
2368: ADD
2369: ST_TO_ADDR
// end ; if not Donaldson then
2370: LD_EXP 43
2374: NOT
2375: IFFALSE 2421
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2377: LD_ADDR_EXP 43
2381: PUSH
2382: LD_STRING Donaldson
2384: PPUSH
2385: LD_EXP 1
2389: NOT
2390: PPUSH
2391: LD_STRING 13f_
2393: PPUSH
2394: CALL 64778 0 3
2398: ST_TO_ADDR
// if Donaldson then
2399: LD_EXP 43
2403: IFFALSE 2421
// tmp := tmp ^ Donaldson ;
2405: LD_ADDR_VAR 0 2
2409: PUSH
2410: LD_VAR 0 2
2414: PUSH
2415: LD_EXP 43
2419: ADD
2420: ST_TO_ADDR
// end ; if not Bobby then
2421: LD_EXP 44
2425: NOT
2426: IFFALSE 2472
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2428: LD_ADDR_EXP 44
2432: PUSH
2433: LD_STRING Bobby
2435: PPUSH
2436: LD_EXP 1
2440: NOT
2441: PPUSH
2442: LD_STRING 13f_
2444: PPUSH
2445: CALL 64778 0 3
2449: ST_TO_ADDR
// if Bobby then
2450: LD_EXP 44
2454: IFFALSE 2472
// tmp := tmp ^ Bobby ;
2456: LD_ADDR_VAR 0 2
2460: PUSH
2461: LD_VAR 0 2
2465: PUSH
2466: LD_EXP 44
2470: ADD
2471: ST_TO_ADDR
// end ; if not Cyrus then
2472: LD_EXP 45
2476: NOT
2477: IFFALSE 2523
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2479: LD_ADDR_EXP 45
2483: PUSH
2484: LD_STRING Cyrus
2486: PPUSH
2487: LD_EXP 1
2491: NOT
2492: PPUSH
2493: LD_STRING 13f_
2495: PPUSH
2496: CALL 64778 0 3
2500: ST_TO_ADDR
// if Cyrus then
2501: LD_EXP 45
2505: IFFALSE 2523
// tmp := tmp ^ Cyrus ;
2507: LD_ADDR_VAR 0 2
2511: PUSH
2512: LD_VAR 0 2
2516: PUSH
2517: LD_EXP 45
2521: ADD
2522: ST_TO_ADDR
// end ; if not Brown then
2523: LD_EXP 47
2527: NOT
2528: IFFALSE 2574
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2530: LD_ADDR_EXP 47
2534: PUSH
2535: LD_STRING Brown
2537: PPUSH
2538: LD_EXP 1
2542: NOT
2543: PPUSH
2544: LD_STRING 13f_
2546: PPUSH
2547: CALL 64778 0 3
2551: ST_TO_ADDR
// if Brown then
2552: LD_EXP 47
2556: IFFALSE 2574
// tmp := tmp ^ Brown ;
2558: LD_ADDR_VAR 0 2
2562: PUSH
2563: LD_VAR 0 2
2567: PUSH
2568: LD_EXP 47
2572: ADD
2573: ST_TO_ADDR
// end ; if not Gladstone then
2574: LD_EXP 48
2578: NOT
2579: IFFALSE 2625
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2581: LD_ADDR_EXP 48
2585: PUSH
2586: LD_STRING Gladstone
2588: PPUSH
2589: LD_EXP 1
2593: NOT
2594: PPUSH
2595: LD_STRING 13f_
2597: PPUSH
2598: CALL 64778 0 3
2602: ST_TO_ADDR
// if Gladstone then
2603: LD_EXP 48
2607: IFFALSE 2625
// tmp := tmp ^ Gladstone ;
2609: LD_ADDR_VAR 0 2
2613: PUSH
2614: LD_VAR 0 2
2618: PUSH
2619: LD_EXP 48
2623: ADD
2624: ST_TO_ADDR
// end ; if not Houten then
2625: LD_EXP 49
2629: NOT
2630: IFFALSE 2676
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2632: LD_ADDR_EXP 49
2636: PUSH
2637: LD_STRING Houten
2639: PPUSH
2640: LD_EXP 1
2644: NOT
2645: PPUSH
2646: LD_STRING 13f_
2648: PPUSH
2649: CALL 64778 0 3
2653: ST_TO_ADDR
// if Houten then
2654: LD_EXP 49
2658: IFFALSE 2676
// tmp := tmp ^ Houten ;
2660: LD_ADDR_VAR 0 2
2664: PUSH
2665: LD_VAR 0 2
2669: PUSH
2670: LD_EXP 49
2674: ADD
2675: ST_TO_ADDR
// end ; if not Cornel then
2676: LD_EXP 50
2680: NOT
2681: IFFALSE 2727
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2683: LD_ADDR_EXP 50
2687: PUSH
2688: LD_STRING Cornell
2690: PPUSH
2691: LD_EXP 1
2695: NOT
2696: PPUSH
2697: LD_STRING 13f_
2699: PPUSH
2700: CALL 64778 0 3
2704: ST_TO_ADDR
// if Cornel then
2705: LD_EXP 50
2709: IFFALSE 2727
// tmp := tmp ^ Cornel ;
2711: LD_ADDR_VAR 0 2
2715: PUSH
2716: LD_VAR 0 2
2720: PUSH
2721: LD_EXP 50
2725: ADD
2726: ST_TO_ADDR
// end ; if not Gary then
2727: LD_EXP 51
2731: NOT
2732: IFFALSE 2778
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2734: LD_ADDR_EXP 51
2738: PUSH
2739: LD_STRING Gary
2741: PPUSH
2742: LD_EXP 1
2746: NOT
2747: PPUSH
2748: LD_STRING 13f_
2750: PPUSH
2751: CALL 64778 0 3
2755: ST_TO_ADDR
// if Gary then
2756: LD_EXP 51
2760: IFFALSE 2778
// tmp := tmp ^ Gary ;
2762: LD_ADDR_VAR 0 2
2766: PUSH
2767: LD_VAR 0 2
2771: PUSH
2772: LD_EXP 51
2776: ADD
2777: ST_TO_ADDR
// end ; if not Frank then
2778: LD_EXP 52
2782: NOT
2783: IFFALSE 2829
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2785: LD_ADDR_EXP 52
2789: PUSH
2790: LD_STRING Frank
2792: PPUSH
2793: LD_EXP 1
2797: NOT
2798: PPUSH
2799: LD_STRING 13f_
2801: PPUSH
2802: CALL 64778 0 3
2806: ST_TO_ADDR
// if Frank then
2807: LD_EXP 52
2811: IFFALSE 2829
// tmp := tmp ^ Frank ;
2813: LD_ADDR_VAR 0 2
2817: PUSH
2818: LD_VAR 0 2
2822: PUSH
2823: LD_EXP 52
2827: ADD
2828: ST_TO_ADDR
// end ; if not Kikuchi then
2829: LD_EXP 53
2833: NOT
2834: IFFALSE 2880
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2836: LD_ADDR_EXP 53
2840: PUSH
2841: LD_STRING Kikuchi
2843: PPUSH
2844: LD_EXP 1
2848: NOT
2849: PPUSH
2850: LD_STRING 13f_
2852: PPUSH
2853: CALL 64778 0 3
2857: ST_TO_ADDR
// if Kikuchi then
2858: LD_EXP 53
2862: IFFALSE 2880
// tmp := tmp ^ Kikuchi ;
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: LD_VAR 0 2
2873: PUSH
2874: LD_EXP 53
2878: ADD
2879: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2880: LD_ADDR_VAR 0 2
2884: PUSH
2885: LD_VAR 0 2
2889: PUSH
2890: LD_STRING 13_other_survivors
2892: PPUSH
2893: CALL_OW 31
2897: UNION
2898: ST_TO_ADDR
// result := tmp ;
2899: LD_ADDR_VAR 0 1
2903: PUSH
2904: LD_VAR 0 2
2908: ST_TO_ADDR
// end ; end_of_file
2909: LD_VAR 0 1
2913: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2914: LD_INT 0
2916: PPUSH
2917: PPUSH
2918: PPUSH
2919: PPUSH
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
// uc_side := 4 ;
2926: LD_ADDR_OWVAR 20
2930: PUSH
2931: LD_INT 4
2933: ST_TO_ADDR
// uc_nation := 1 ;
2934: LD_ADDR_OWVAR 21
2938: PUSH
2939: LD_INT 1
2941: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2942: LD_INT 387
2944: PPUSH
2945: CALL_OW 274
2949: PPUSH
2950: LD_INT 1
2952: PPUSH
2953: LD_INT 2500
2955: PPUSH
2956: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2960: LD_INT 387
2962: PPUSH
2963: CALL_OW 274
2967: PPUSH
2968: LD_INT 2
2970: PPUSH
2971: LD_INT 400
2973: PPUSH
2974: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2978: LD_INT 387
2980: PPUSH
2981: CALL_OW 274
2985: PPUSH
2986: LD_INT 3
2988: PPUSH
2989: LD_INT 10
2991: PPUSH
2992: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2996: LD_ADDR_EXP 58
3000: PUSH
3001: LD_STRING Powell
3003: PPUSH
3004: CALL_OW 25
3008: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3009: LD_EXP 58
3013: PPUSH
3014: LD_INT 57
3016: PPUSH
3017: LD_INT 94
3019: PPUSH
3020: LD_INT 0
3022: PPUSH
3023: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3027: LD_EXP 58
3031: PPUSH
3032: LD_INT 58
3034: PPUSH
3035: LD_INT 94
3037: PPUSH
3038: CALL_OW 118
// vip := [ ] ;
3042: LD_ADDR_EXP 59
3046: PUSH
3047: EMPTY
3048: ST_TO_ADDR
// tmp := [ ] ;
3049: LD_ADDR_VAR 0 6
3053: PUSH
3054: EMPTY
3055: ST_TO_ADDR
// if JMMGirl <> 2 then
3056: LD_EXP 7
3060: PUSH
3061: LD_INT 2
3063: NONEQUAL
3064: IFFALSE 3088
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3066: LD_ADDR_EXP 42
3070: PUSH
3071: LD_STRING Lisa
3073: PPUSH
3074: LD_EXP 1
3078: NOT
3079: PPUSH
3080: LD_STRING 13s_
3082: PPUSH
3083: CALL 64778 0 3
3087: ST_TO_ADDR
// if Lisa then
3088: LD_EXP 42
3092: IFFALSE 3110
// tmp := tmp ^ Lisa ;
3094: LD_ADDR_VAR 0 6
3098: PUSH
3099: LD_VAR 0 6
3103: PUSH
3104: LD_EXP 42
3108: ADD
3109: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3110: LD_ADDR_EXP 43
3114: PUSH
3115: LD_STRING Donaldson
3117: PPUSH
3118: LD_EXP 1
3122: NOT
3123: PPUSH
3124: LD_STRING 13s_
3126: PPUSH
3127: CALL 64778 0 3
3131: ST_TO_ADDR
// if Donaldson then
3132: LD_EXP 43
3136: IFFALSE 3154
// tmp := tmp ^ Donaldson ;
3138: LD_ADDR_VAR 0 6
3142: PUSH
3143: LD_VAR 0 6
3147: PUSH
3148: LD_EXP 43
3152: ADD
3153: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3154: LD_ADDR_EXP 44
3158: PUSH
3159: LD_STRING Bobby
3161: PPUSH
3162: LD_EXP 1
3166: NOT
3167: PPUSH
3168: LD_STRING 13s_
3170: PPUSH
3171: CALL 64778 0 3
3175: ST_TO_ADDR
// if Bobby then
3176: LD_EXP 44
3180: IFFALSE 3198
// tmp := tmp ^ Bobby ;
3182: LD_ADDR_VAR 0 6
3186: PUSH
3187: LD_VAR 0 6
3191: PUSH
3192: LD_EXP 44
3196: ADD
3197: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3198: LD_ADDR_EXP 45
3202: PUSH
3203: LD_STRING Cyrus
3205: PPUSH
3206: LD_EXP 1
3210: NOT
3211: PPUSH
3212: LD_STRING 13s_
3214: PPUSH
3215: CALL 64778 0 3
3219: ST_TO_ADDR
// if Cyrus then
3220: LD_EXP 45
3224: IFFALSE 3242
// tmp := tmp ^ Cyrus ;
3226: LD_ADDR_VAR 0 6
3230: PUSH
3231: LD_VAR 0 6
3235: PUSH
3236: LD_EXP 45
3240: ADD
3241: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3242: LD_ADDR_EXP 46
3246: PUSH
3247: LD_STRING Denis
3249: PPUSH
3250: LD_EXP 1
3254: NOT
3255: PPUSH
3256: LD_STRING 13s_
3258: PPUSH
3259: CALL 64778 0 3
3263: ST_TO_ADDR
// if not Denis then
3264: LD_EXP 46
3268: NOT
3269: IFFALSE 3293
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3271: LD_ADDR_EXP 46
3275: PUSH
3276: LD_STRING Denis
3278: PPUSH
3279: LD_EXP 1
3283: NOT
3284: PPUSH
3285: LD_STRING 13f_
3287: PPUSH
3288: CALL 64778 0 3
3292: ST_TO_ADDR
// if Denis then
3293: LD_EXP 46
3297: IFFALSE 3315
// tmp := tmp ^ Denis ;
3299: LD_ADDR_VAR 0 6
3303: PUSH
3304: LD_VAR 0 6
3308: PUSH
3309: LD_EXP 46
3313: ADD
3314: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3315: LD_ADDR_EXP 47
3319: PUSH
3320: LD_STRING Brown
3322: PPUSH
3323: LD_EXP 1
3327: NOT
3328: PPUSH
3329: LD_STRING 13s_
3331: PPUSH
3332: CALL 64778 0 3
3336: ST_TO_ADDR
// if Brown then
3337: LD_EXP 47
3341: IFFALSE 3359
// tmp := tmp ^ Brown ;
3343: LD_ADDR_VAR 0 6
3347: PUSH
3348: LD_VAR 0 6
3352: PUSH
3353: LD_EXP 47
3357: ADD
3358: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3359: LD_ADDR_EXP 48
3363: PUSH
3364: LD_STRING Gladstone
3366: PPUSH
3367: LD_EXP 1
3371: NOT
3372: PPUSH
3373: LD_STRING 13s_
3375: PPUSH
3376: CALL 64778 0 3
3380: ST_TO_ADDR
// if Gladstone then
3381: LD_EXP 48
3385: IFFALSE 3403
// tmp := tmp ^ Gladstone ;
3387: LD_ADDR_VAR 0 6
3391: PUSH
3392: LD_VAR 0 6
3396: PUSH
3397: LD_EXP 48
3401: ADD
3402: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3403: LD_ADDR_EXP 49
3407: PUSH
3408: LD_STRING Houten
3410: PPUSH
3411: LD_EXP 1
3415: NOT
3416: PPUSH
3417: LD_STRING 13s_
3419: PPUSH
3420: CALL 64778 0 3
3424: ST_TO_ADDR
// if Houten then
3425: LD_EXP 49
3429: IFFALSE 3447
// tmp := tmp ^ Houten ;
3431: LD_ADDR_VAR 0 6
3435: PUSH
3436: LD_VAR 0 6
3440: PUSH
3441: LD_EXP 49
3445: ADD
3446: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3447: LD_ADDR_EXP 50
3451: PUSH
3452: LD_STRING Cornel
3454: PPUSH
3455: LD_EXP 1
3459: NOT
3460: PPUSH
3461: LD_STRING 13s_
3463: PPUSH
3464: CALL 64778 0 3
3468: ST_TO_ADDR
// if Cornel then
3469: LD_EXP 50
3473: IFFALSE 3491
// tmp := tmp ^ Cornel ;
3475: LD_ADDR_VAR 0 6
3479: PUSH
3480: LD_VAR 0 6
3484: PUSH
3485: LD_EXP 50
3489: ADD
3490: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3491: LD_ADDR_EXP 51
3495: PUSH
3496: LD_STRING Gary
3498: PPUSH
3499: LD_EXP 1
3503: NOT
3504: PPUSH
3505: LD_STRING 13s_
3507: PPUSH
3508: CALL 64778 0 3
3512: ST_TO_ADDR
// if Gary then
3513: LD_EXP 51
3517: IFFALSE 3535
// tmp := tmp ^ Gary ;
3519: LD_ADDR_VAR 0 6
3523: PUSH
3524: LD_VAR 0 6
3528: PUSH
3529: LD_EXP 51
3533: ADD
3534: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3535: LD_ADDR_EXP 52
3539: PUSH
3540: LD_STRING Frank
3542: PPUSH
3543: LD_EXP 1
3547: NOT
3548: PPUSH
3549: LD_STRING 13s_
3551: PPUSH
3552: CALL 64778 0 3
3556: ST_TO_ADDR
// if Frank then
3557: LD_EXP 52
3561: IFFALSE 3579
// tmp := tmp ^ Frank ;
3563: LD_ADDR_VAR 0 6
3567: PUSH
3568: LD_VAR 0 6
3572: PUSH
3573: LD_EXP 52
3577: ADD
3578: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3579: LD_ADDR_EXP 53
3583: PUSH
3584: LD_STRING Kikuchi
3586: PPUSH
3587: LD_EXP 1
3591: NOT
3592: PPUSH
3593: LD_STRING 13s_
3595: PPUSH
3596: CALL 64778 0 3
3600: ST_TO_ADDR
// if Kikuchi then
3601: LD_EXP 53
3605: IFFALSE 3623
// tmp := tmp ^ Kikuchi ;
3607: LD_ADDR_VAR 0 6
3611: PUSH
3612: LD_VAR 0 6
3616: PUSH
3617: LD_EXP 53
3621: ADD
3622: ST_TO_ADDR
// vip := tmp ;
3623: LD_ADDR_EXP 59
3627: PUSH
3628: LD_VAR 0 6
3632: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3633: LD_ADDR_VAR 0 6
3637: PUSH
3638: LD_VAR 0 6
3642: PUSH
3643: LD_STRING 13s_others
3645: PPUSH
3646: CALL_OW 31
3650: UNION
3651: ST_TO_ADDR
// if tmp < 20 then
3652: LD_VAR 0 6
3656: PUSH
3657: LD_INT 20
3659: LESS
3660: IFFALSE 3727
// for i = 1 to 20 - tmp do
3662: LD_ADDR_VAR 0 2
3666: PUSH
3667: DOUBLE
3668: LD_INT 1
3670: DEC
3671: ST_TO_ADDR
3672: LD_INT 20
3674: PUSH
3675: LD_VAR 0 6
3679: MINUS
3680: PUSH
3681: FOR_TO
3682: IFFALSE 3725
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3684: LD_INT 1
3686: PPUSH
3687: LD_VAR 0 2
3691: PUSH
3692: LD_INT 4
3694: MOD
3695: PUSH
3696: LD_INT 1
3698: PLUS
3699: PPUSH
3700: LD_INT 5
3702: PPUSH
3703: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3707: LD_ADDR_VAR 0 6
3711: PUSH
3712: LD_VAR 0 6
3716: PUSH
3717: CALL_OW 44
3721: ADD
3722: ST_TO_ADDR
// end ;
3723: GO 3681
3725: POP
3726: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3727: LD_ADDR_VAR 0 7
3731: PUSH
3732: LD_INT 22
3734: PUSH
3735: LD_INT 4
3737: PUSH
3738: EMPTY
3739: LIST
3740: LIST
3741: PUSH
3742: LD_INT 30
3744: PUSH
3745: LD_INT 0
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PPUSH
3756: CALL_OW 69
3760: PUSH
3761: LD_INT 1
3763: ARRAY
3764: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3765: LD_ADDR_VAR 0 8
3769: PUSH
3770: LD_INT 22
3772: PUSH
3773: LD_INT 4
3775: PUSH
3776: EMPTY
3777: LIST
3778: LIST
3779: PUSH
3780: LD_INT 30
3782: PUSH
3783: LD_INT 6
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PPUSH
3794: CALL_OW 69
3798: PUSH
3799: LD_INT 1
3801: ARRAY
3802: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3803: LD_ADDR_VAR 0 9
3807: PUSH
3808: LD_INT 22
3810: PUSH
3811: LD_INT 4
3813: PUSH
3814: EMPTY
3815: LIST
3816: LIST
3817: PUSH
3818: LD_INT 30
3820: PUSH
3821: LD_INT 4
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PUSH
3828: EMPTY
3829: LIST
3830: LIST
3831: PPUSH
3832: CALL_OW 69
3836: PUSH
3837: LD_INT 1
3839: ARRAY
3840: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3841: LD_ADDR_VAR 0 10
3845: PUSH
3846: LD_INT 22
3848: PUSH
3849: LD_INT 4
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: PUSH
3856: LD_INT 30
3858: PUSH
3859: LD_INT 2
3861: PUSH
3862: EMPTY
3863: LIST
3864: LIST
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: PPUSH
3870: CALL_OW 69
3874: PUSH
3875: LD_INT 1
3877: ARRAY
3878: ST_TO_ADDR
// for i in tmp do
3879: LD_ADDR_VAR 0 2
3883: PUSH
3884: LD_VAR 0 6
3888: PUSH
3889: FOR_IN
3890: IFFALSE 4016
// begin cl := GetClass ( i ) ;
3892: LD_ADDR_VAR 0 5
3896: PUSH
3897: LD_VAR 0 2
3901: PPUSH
3902: CALL_OW 257
3906: ST_TO_ADDR
// if cl > 4 then
3907: LD_VAR 0 5
3911: PUSH
3912: LD_INT 4
3914: GREATER
3915: IFFALSE 3925
// cl := 1 ;
3917: LD_ADDR_VAR 0 5
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3925: LD_ADDR_VAR 0 3
3929: PUSH
3930: LD_VAR 0 9
3934: PUSH
3935: LD_VAR 0 7
3939: PUSH
3940: LD_VAR 0 10
3944: PUSH
3945: LD_VAR 0 8
3949: PUSH
3950: EMPTY
3951: LIST
3952: LIST
3953: LIST
3954: LIST
3955: PUSH
3956: LD_VAR 0 5
3960: ARRAY
3961: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3962: LD_VAR 0 3
3966: PPUSH
3967: CALL_OW 313
3971: PUSH
3972: LD_INT 5
3974: LESS
3975: IFFALSE 3993
// PlaceHumanInUnit ( i , b ) else
3977: LD_VAR 0 2
3981: PPUSH
3982: LD_VAR 0 3
3986: PPUSH
3987: CALL_OW 52
3991: GO 4014
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3993: LD_VAR 0 2
3997: PPUSH
3998: LD_INT 58
4000: PPUSH
4001: LD_INT 91
4003: PPUSH
4004: LD_INT 6
4006: PPUSH
4007: LD_INT 0
4009: PPUSH
4010: CALL_OW 50
// end ;
4014: GO 3889
4016: POP
4017: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4018: LD_INT 2
4020: PPUSH
4021: LD_INT 1
4023: PPUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 12
4029: PPUSH
4030: LD_INT 100
4032: PPUSH
4033: CALL 71893 0 5
// veh := CreateVehicle ;
4037: LD_ADDR_VAR 0 4
4041: PUSH
4042: CALL_OW 45
4046: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4047: LD_VAR 0 4
4051: PPUSH
4052: LD_INT 4
4054: PPUSH
4055: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4059: LD_VAR 0 4
4063: PPUSH
4064: LD_INT 49
4066: PPUSH
4067: LD_INT 88
4069: PPUSH
4070: LD_INT 0
4072: PPUSH
4073: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4077: LD_VAR 0 4
4081: PPUSH
4082: LD_INT 1
4084: PPUSH
4085: LD_INT 100
4087: PPUSH
4088: CALL_OW 290
// uc_side := 0 ;
4092: LD_ADDR_OWVAR 20
4096: PUSH
4097: LD_INT 0
4099: ST_TO_ADDR
// uc_nation := 0 ;
4100: LD_ADDR_OWVAR 21
4104: PUSH
4105: LD_INT 0
4107: ST_TO_ADDR
// for i = 1 to 4 do
4108: LD_ADDR_VAR 0 2
4112: PUSH
4113: DOUBLE
4114: LD_INT 1
4116: DEC
4117: ST_TO_ADDR
4118: LD_INT 4
4120: PUSH
4121: FOR_TO
4122: IFFALSE 4153
// begin InitHc ;
4124: CALL_OW 19
// hc_class := class_apeman ;
4128: LD_ADDR_OWVAR 28
4132: PUSH
4133: LD_INT 12
4135: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4136: CALL_OW 44
4140: PPUSH
4141: LD_INT 13
4143: PPUSH
4144: LD_INT 0
4146: PPUSH
4147: CALL_OW 49
// end ;
4151: GO 4121
4153: POP
4154: POP
// end ; end_of_file
4155: LD_VAR 0 1
4159: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4160: LD_INT 0
4162: PPUSH
4163: PPUSH
4164: PPUSH
4165: PPUSH
4166: PPUSH
// side := 8 ;
4167: LD_ADDR_VAR 0 3
4171: PUSH
4172: LD_INT 8
4174: ST_TO_ADDR
// uc_side := side ;
4175: LD_ADDR_OWVAR 20
4179: PUSH
4180: LD_VAR 0 3
4184: ST_TO_ADDR
// uc_nation := 2 ;
4185: LD_ADDR_OWVAR 21
4189: PUSH
4190: LD_INT 2
4192: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: LD_INT 22
4200: PUSH
4201: LD_VAR 0 3
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 21
4212: PUSH
4213: LD_INT 3
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PPUSH
4224: CALL_OW 69
4228: PUSH
4229: FOR_IN
4230: IFFALSE 4246
// SetBLevel ( i , 10 ) ;
4232: LD_VAR 0 2
4236: PPUSH
4237: LD_INT 10
4239: PPUSH
4240: CALL_OW 241
4244: GO 4229
4246: POP
4247: POP
// if KurtStatus then
4248: LD_EXP 3
4252: IFFALSE 4275
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4254: LD_ADDR_EXP 60
4258: PUSH
4259: LD_STRING Kurt
4261: PPUSH
4262: LD_INT 0
4264: PPUSH
4265: LD_STRING 
4267: PPUSH
4268: CALL 64778 0 3
4272: ST_TO_ADDR
4273: GO 4297
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING AltKurt
4282: PPUSH
4283: LD_EXP 1
4287: NOT
4288: PPUSH
4289: LD_STRING 
4291: PPUSH
4292: CALL 64778 0 3
4296: ST_TO_ADDR
// if not Kurt then
4297: LD_EXP 60
4301: NOT
4302: IFFALSE 4328
// begin InitHc ;
4304: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4308: LD_INT 1
4310: PPUSH
4311: LD_INT 10
4313: PPUSH
4314: CALL_OW 381
// Kurt := CreateHuman ;
4318: LD_ADDR_EXP 60
4322: PUSH
4323: CALL_OW 44
4327: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4328: LD_EXP 60
4332: PPUSH
4333: LD_INT 324
4335: PPUSH
4336: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4340: LD_ADDR_EXP 61
4344: PUSH
4345: LD_STRING Kozlov
4347: PPUSH
4348: LD_INT 0
4350: PPUSH
4351: LD_STRING 
4353: PPUSH
4354: CALL 64778 0 3
4358: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4359: LD_EXP 61
4363: PPUSH
4364: LD_INT 22
4366: PUSH
4367: LD_INT 8
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 23
4376: PUSH
4377: LD_INT 3
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: LD_INT 30
4386: PUSH
4387: LD_INT 8
4389: PUSH
4390: EMPTY
4391: LIST
4392: LIST
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: LIST
4398: PPUSH
4399: CALL_OW 69
4403: PUSH
4404: LD_INT 1
4406: ARRAY
4407: PPUSH
4408: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4412: LD_EXP 61
4416: PPUSH
4417: LD_INT 3
4419: PPUSH
4420: LD_INT 10
4422: PPUSH
4423: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4427: LD_ADDR_VAR 0 5
4431: PUSH
4432: LD_INT 22
4434: PUSH
4435: LD_VAR 0 3
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_INT 30
4446: PUSH
4447: LD_INT 32
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 58
4456: PUSH
4457: EMPTY
4458: LIST
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: LIST
4464: PPUSH
4465: CALL_OW 69
4469: ST_TO_ADDR
// for i = 1 to 10 do
4470: LD_ADDR_VAR 0 2
4474: PUSH
4475: DOUBLE
4476: LD_INT 1
4478: DEC
4479: ST_TO_ADDR
4480: LD_INT 10
4482: PUSH
4483: FOR_TO
4484: IFFALSE 4556
// begin uc_nation := nation_nature ;
4486: LD_ADDR_OWVAR 21
4490: PUSH
4491: LD_INT 0
4493: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4494: LD_ADDR_OWVAR 28
4498: PUSH
4499: LD_INT 15
4501: ST_TO_ADDR
// hc_gallery :=  ;
4502: LD_ADDR_OWVAR 33
4506: PUSH
4507: LD_STRING 
4509: ST_TO_ADDR
// hc_name :=  ;
4510: LD_ADDR_OWVAR 26
4514: PUSH
4515: LD_STRING 
4517: ST_TO_ADDR
// un := CreateHuman ;
4518: LD_ADDR_VAR 0 4
4522: PUSH
4523: CALL_OW 44
4527: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4528: LD_VAR 0 4
4532: PPUSH
4533: LD_VAR 0 5
4537: PUSH
4538: LD_VAR 0 5
4542: PUSH
4543: LD_VAR 0 2
4547: MINUS
4548: ARRAY
4549: PPUSH
4550: CALL_OW 52
// end ;
4554: GO 4483
4556: POP
4557: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4558: LD_ADDR_VAR 0 5
4562: PUSH
4563: LD_STRING 12_kurt_squad
4565: PPUSH
4566: CALL_OW 31
4570: ST_TO_ADDR
// if tmp then
4571: LD_VAR 0 5
4575: IFFALSE 4609
// for i in tmp do
4577: LD_ADDR_VAR 0 2
4581: PUSH
4582: LD_VAR 0 5
4586: PUSH
4587: FOR_IN
4588: IFFALSE 4607
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4590: LD_VAR 0 2
4594: PPUSH
4595: LD_INT 5
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 49
4605: GO 4587
4607: POP
4608: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4609: LD_INT 324
4611: PPUSH
4612: LD_INT 5
4614: PPUSH
4615: LD_STRING 
4617: PPUSH
4618: LD_INT 8
4620: PUSH
4621: LD_INT 9
4623: PUSH
4624: LD_INT 10
4626: PUSH
4627: EMPTY
4628: LIST
4629: LIST
4630: LIST
4631: PUSH
4632: LD_OWVAR 67
4636: ARRAY
4637: PPUSH
4638: LD_INT 3000
4640: PUSH
4641: LD_INT 500
4643: PUSH
4644: LD_INT 150
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: LIST
4651: PPUSH
4652: LD_INT 16
4654: PUSH
4655: LD_INT 6
4657: PUSH
4658: LD_INT 6
4660: PUSH
4661: LD_INT 8
4663: PUSH
4664: EMPTY
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: PPUSH
4670: CALL 75302 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4674: LD_ADDR_EXP 102
4678: PUSH
4679: LD_EXP 102
4683: PPUSH
4684: LD_INT 3
4686: PPUSH
4687: LD_INT 22
4689: PUSH
4690: LD_VAR 0 3
4694: PUSH
4695: EMPTY
4696: LIST
4697: LIST
4698: PUSH
4699: LD_INT 23
4701: PUSH
4702: LD_INT 2
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PUSH
4709: LD_INT 3
4711: PUSH
4712: LD_INT 21
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL_OW 69
4735: PUSH
4736: LD_EXP 60
4740: DIFF
4741: PPUSH
4742: CALL_OW 1
4746: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4747: LD_INT 1
4749: PPUSH
4750: LD_INT 7
4752: PPUSH
4753: CALL_OW 383
// Friend := CreateHuman ;
4757: LD_ADDR_EXP 62
4761: PUSH
4762: CALL_OW 44
4766: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4767: LD_INT 14
4769: PPUSH
4770: LD_INT 3
4772: PPUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 29
4778: PPUSH
4779: LD_INT 100
4781: PPUSH
4782: CALL 71893 0 5
// powellBomb := CreateVehicle ;
4786: LD_ADDR_EXP 63
4790: PUSH
4791: CALL_OW 45
4795: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4796: LD_EXP 63
4800: PPUSH
4801: LD_INT 90
4803: PPUSH
4804: LD_INT 51
4806: PPUSH
4807: LD_INT 0
4809: PPUSH
4810: CALL_OW 48
// end ;
4814: LD_VAR 0 1
4818: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4819: LD_INT 0
4821: PPUSH
4822: PPUSH
4823: PPUSH
// if IsLive ( kozlov_fac ) then
4824: LD_INT 332
4826: PPUSH
4827: CALL_OW 300
4831: IFFALSE 4835
// exit ;
4833: GO 5402
// ComExitBuilding ( Kozlov ) ;
4835: LD_EXP 61
4839: PPUSH
4840: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4844: LD_EXP 61
4848: PPUSH
4849: CALL_OW 257
4853: PUSH
4854: LD_INT 2
4856: NONEQUAL
4857: IFFALSE 4892
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4859: LD_EXP 61
4863: PPUSH
4864: LD_INT 324
4866: PPUSH
4867: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4871: LD_EXP 61
4875: PPUSH
4876: LD_INT 2
4878: PPUSH
4879: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4883: LD_EXP 61
4887: PPUSH
4888: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4892: LD_EXP 61
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: LD_INT 93
4902: PPUSH
4903: LD_INT 32
4905: PPUSH
4906: LD_INT 3
4908: PPUSH
4909: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4913: LD_INT 35
4915: PPUSH
4916: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4920: LD_INT 22
4922: PUSH
4923: LD_INT 8
4925: PUSH
4926: EMPTY
4927: LIST
4928: LIST
4929: PUSH
4930: LD_INT 30
4932: PUSH
4933: LD_INT 3
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: PUSH
4940: LD_INT 23
4942: PUSH
4943: LD_INT 3
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: PUSH
4950: LD_INT 57
4952: PUSH
4953: EMPTY
4954: LIST
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: PPUSH
4962: CALL_OW 69
4966: IFFALSE 4913
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: LD_INT 22
4975: PUSH
4976: LD_INT 8
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: PUSH
4983: LD_INT 30
4985: PUSH
4986: LD_INT 3
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 23
4995: PUSH
4996: LD_INT 3
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 57
5005: PUSH
5006: EMPTY
5007: LIST
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: PPUSH
5015: CALL_OW 69
5019: PUSH
5020: LD_INT 1
5022: ARRAY
5023: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5024: LD_INT 22
5026: PUSH
5027: LD_INT 8
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: PUSH
5034: LD_INT 23
5036: PUSH
5037: LD_INT 3
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 21
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: LIST
5058: PPUSH
5059: CALL_OW 69
5063: NOT
5064: IFFALSE 5142
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5066: LD_EXP 61
5070: PPUSH
5071: LD_INT 21
5073: PPUSH
5074: LD_INT 97
5076: PPUSH
5077: LD_INT 36
5079: PPUSH
5080: LD_INT 5
5082: PPUSH
5083: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5087: LD_INT 35
5089: PPUSH
5090: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5094: LD_INT 22
5096: PUSH
5097: LD_INT 8
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 23
5106: PUSH
5107: LD_INT 3
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 30
5116: PUSH
5117: LD_INT 21
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: LD_INT 57
5126: PUSH
5127: EMPTY
5128: LIST
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: LIST
5134: LIST
5135: PPUSH
5136: CALL_OW 69
5140: IFFALSE 5087
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5142: LD_INT 22
5144: PUSH
5145: LD_INT 8
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: LD_INT 23
5154: PUSH
5155: LD_INT 3
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: PUSH
5162: LD_INT 30
5164: PUSH
5165: LD_INT 18
5167: PUSH
5168: EMPTY
5169: LIST
5170: LIST
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: LIST
5176: PPUSH
5177: CALL_OW 69
5181: NOT
5182: IFFALSE 5260
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5184: LD_EXP 61
5188: PPUSH
5189: LD_INT 18
5191: PPUSH
5192: LD_INT 89
5194: PPUSH
5195: LD_INT 32
5197: PPUSH
5198: LD_INT 1
5200: PPUSH
5201: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5205: LD_INT 35
5207: PPUSH
5208: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5212: LD_INT 22
5214: PUSH
5215: LD_INT 8
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: PUSH
5222: LD_INT 23
5224: PUSH
5225: LD_INT 3
5227: PUSH
5228: EMPTY
5229: LIST
5230: LIST
5231: PUSH
5232: LD_INT 30
5234: PUSH
5235: LD_INT 18
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: PUSH
5242: LD_INT 57
5244: PUSH
5245: EMPTY
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL_OW 69
5258: IFFALSE 5205
// end ; lab := kozlov_lab ;
5260: LD_ADDR_VAR 0 3
5264: PUSH
5265: LD_INT 336
5267: ST_TO_ADDR
// if not lab then
5268: LD_VAR 0 3
5272: NOT
5273: IFFALSE 5277
// exit ;
5275: GO 5402
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5277: LD_EXP 61
5281: PPUSH
5282: LD_VAR 0 3
5286: PUSH
5287: LD_INT 1
5289: ARRAY
5290: PPUSH
5291: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5295: LD_EXP 61
5299: PPUSH
5300: LD_INT 4
5302: PPUSH
5303: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5307: LD_VAR 0 3
5311: PUSH
5312: LD_INT 1
5314: ARRAY
5315: PPUSH
5316: LD_INT 25
5318: PPUSH
5319: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5323: LD_INT 35
5325: PPUSH
5326: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5330: LD_INT 25
5332: PPUSH
5333: LD_INT 8
5335: PPUSH
5336: CALL_OW 321
5340: PUSH
5341: LD_INT 2
5343: EQUAL
5344: IFFALSE 5323
// ComExitBuilding ( Kozlov ) ;
5346: LD_EXP 61
5350: PPUSH
5351: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5355: LD_EXP 61
5359: PPUSH
5360: LD_VAR 0 2
5364: PPUSH
5365: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5369: LD_EXP 61
5373: PPUSH
5374: LD_INT 3
5376: PPUSH
5377: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5381: LD_VAR 0 2
5385: PPUSH
5386: LD_INT 23
5388: PPUSH
5389: LD_INT 3
5391: PPUSH
5392: LD_INT 1
5394: PPUSH
5395: LD_INT 48
5397: PPUSH
5398: CALL_OW 125
// end ;
5402: LD_VAR 0 1
5406: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5407: LD_EXP 22
5411: NOT
5412: PUSH
5413: LD_EXP 15
5417: PUSH
5418: LD_INT 6
5420: GREATEREQUAL
5421: AND
5422: IFFALSE 5503
5424: GO 5426
5426: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5427: LD_INT 3
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: CALL 58571 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5437: LD_INT 3
5439: PPUSH
5440: LD_INT 14
5442: PUSH
5443: LD_INT 1
5445: PUSH
5446: LD_INT 1
5448: PUSH
5449: LD_INT 28
5451: PUSH
5452: EMPTY
5453: LIST
5454: LIST
5455: LIST
5456: LIST
5457: PUSH
5458: LD_INT 14
5460: PUSH
5461: LD_INT 1
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: LD_INT 28
5469: PUSH
5470: EMPTY
5471: LIST
5472: LIST
5473: LIST
5474: LIST
5475: PUSH
5476: LD_INT 14
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 28
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: LIST
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: PPUSH
5499: CALL 58434 0 2
// end ;
5503: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5504: LD_EXP 22
5508: NOT
5509: PUSH
5510: LD_EXP 15
5514: PUSH
5515: LD_INT 6
5517: GREATEREQUAL
5518: AND
5519: PUSH
5520: LD_INT 3
5522: PPUSH
5523: LD_INT 1
5525: PPUSH
5526: CALL 59852 0 2
5530: NOT
5531: AND
5532: IFFALSE 6372
5534: GO 5536
5536: DISABLE
5537: LD_INT 0
5539: PPUSH
5540: PPUSH
5541: PPUSH
// begin enable ;
5542: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5543: LD_INT 22
5545: PUSH
5546: LD_INT 8
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: PUSH
5553: LD_INT 23
5555: PUSH
5556: LD_INT 2
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PUSH
5563: LD_INT 30
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: LIST
5577: PPUSH
5578: CALL_OW 69
5582: NOT
5583: IFFALSE 5587
// exit ;
5585: GO 6372
// if Prob ( 40 ) then
5587: LD_INT 40
5589: PPUSH
5590: CALL_OW 13
5594: IFFALSE 5721
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5596: LD_INT 3
5598: PPUSH
5599: LD_INT 14
5601: PUSH
5602: LD_INT 1
5604: PUSH
5605: LD_INT 2
5607: PUSH
5608: LD_INT 28
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: LIST
5615: LIST
5616: PUSH
5617: LD_INT 14
5619: PUSH
5620: LD_INT 1
5622: PUSH
5623: LD_INT 2
5625: PUSH
5626: LD_INT 28
5628: PUSH
5629: EMPTY
5630: LIST
5631: LIST
5632: LIST
5633: LIST
5634: PUSH
5635: LD_INT 14
5637: PUSH
5638: LD_INT 1
5640: PUSH
5641: LD_INT 2
5643: PUSH
5644: LD_INT 28
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: PUSH
5653: LD_INT 14
5655: PUSH
5656: LD_INT 1
5658: PUSH
5659: LD_INT 2
5661: PUSH
5662: LD_INT 28
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 14
5673: PUSH
5674: LD_INT 1
5676: PUSH
5677: LD_INT 2
5679: PUSH
5680: LD_INT 28
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 14
5691: PUSH
5692: LD_INT 1
5694: PUSH
5695: LD_INT 2
5697: PUSH
5698: LD_INT 26
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: LIST
5714: PPUSH
5715: CALL 58434 0 2
// end else
5719: GO 5912
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5721: LD_INT 3
5723: PPUSH
5724: LD_INT 14
5726: PUSH
5727: LD_INT 1
5729: PUSH
5730: LD_INT 2
5732: PUSH
5733: LD_INT 27
5735: PUSH
5736: LD_INT 26
5738: PUSH
5739: LD_INT 26
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_OWVAR 67
5751: ARRAY
5752: PUSH
5753: EMPTY
5754: LIST
5755: LIST
5756: LIST
5757: LIST
5758: PUSH
5759: LD_INT 14
5761: PUSH
5762: LD_INT 1
5764: PUSH
5765: LD_INT 2
5767: PUSH
5768: LD_INT 27
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: LD_INT 26
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: PUSH
5782: LD_OWVAR 67
5786: ARRAY
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: LIST
5793: PUSH
5794: LD_INT 14
5796: PUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 2
5802: PUSH
5803: LD_INT 26
5805: PUSH
5806: LD_INT 26
5808: PUSH
5809: LD_INT 29
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: PUSH
5817: LD_OWVAR 67
5821: ARRAY
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 13
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 2
5837: PUSH
5838: LD_INT 26
5840: PUSH
5841: LD_INT 29
5843: PUSH
5844: LD_INT 29
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_OWVAR 67
5856: ARRAY
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: PUSH
5864: LD_INT 13
5866: PUSH
5867: LD_INT 1
5869: PUSH
5870: LD_INT 2
5872: PUSH
5873: LD_INT 29
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 14
5884: PUSH
5885: LD_INT 1
5887: PUSH
5888: LD_INT 2
5890: PUSH
5891: LD_INT 26
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: PPUSH
5908: CALL 58434 0 2
// end ; repeat wait ( 0 0$1 ) ;
5912: LD_INT 35
5914: PPUSH
5915: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5919: LD_INT 3
5921: PPUSH
5922: LD_INT 1
5924: PPUSH
5925: CALL 59852 0 2
5929: PUSH
5930: LD_INT 6
5932: GREATEREQUAL
5933: IFFALSE 5912
// wait ( 0 0$30 ) ;
5935: LD_INT 1050
5937: PPUSH
5938: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5942: LD_ADDR_VAR 0 2
5946: PUSH
5947: LD_INT 3
5949: PPUSH
5950: LD_INT 1
5952: PPUSH
5953: CALL 59852 0 2
5957: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5958: LD_ADDR_EXP 121
5962: PUSH
5963: LD_EXP 121
5967: PPUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_EXP 121
5975: PUSH
5976: LD_INT 3
5978: ARRAY
5979: PUSH
5980: LD_VAR 0 2
5984: DIFF
5985: PPUSH
5986: CALL_OW 1
5990: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5991: LD_ADDR_VAR 0 3
5995: PUSH
5996: LD_INT 0
5998: PPUSH
5999: LD_INT 2
6001: PPUSH
6002: CALL_OW 12
6006: ST_TO_ADDR
// if target then
6007: LD_VAR 0 3
6011: IFFALSE 6139
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6013: LD_ADDR_VAR 0 2
6017: PUSH
6018: LD_VAR 0 2
6022: PPUSH
6023: LD_INT 24
6025: PUSH
6026: LD_INT 250
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: PPUSH
6033: CALL_OW 72
6037: ST_TO_ADDR
// for i in tmp do
6038: LD_ADDR_VAR 0 1
6042: PUSH
6043: LD_VAR 0 2
6047: PUSH
6048: FOR_IN
6049: IFFALSE 6089
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6051: LD_VAR 0 1
6055: PPUSH
6056: LD_INT 89
6058: PPUSH
6059: LD_INT 71
6061: PPUSH
6062: CALL_OW 297
6066: PUSH
6067: LD_INT 9
6069: GREATER
6070: IFFALSE 6087
// ComMoveXY ( i , 89 , 71 ) ;
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_INT 89
6079: PPUSH
6080: LD_INT 71
6082: PPUSH
6083: CALL_OW 111
6087: GO 6048
6089: POP
6090: POP
// wait ( 0 0$1 ) ;
6091: LD_INT 35
6093: PPUSH
6094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 92
6105: PUSH
6106: LD_INT 89
6108: PUSH
6109: LD_INT 71
6111: PUSH
6112: LD_INT 9
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: PPUSH
6121: CALL_OW 72
6125: PUSH
6126: LD_VAR 0 2
6130: PUSH
6131: LD_INT 1
6133: MINUS
6134: GREATEREQUAL
6135: IFFALSE 6013
// end else
6137: GO 6263
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6139: LD_ADDR_VAR 0 2
6143: PUSH
6144: LD_VAR 0 2
6148: PPUSH
6149: LD_INT 24
6151: PUSH
6152: LD_INT 250
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 72
6163: ST_TO_ADDR
// for i in tmp do
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: LD_VAR 0 2
6173: PUSH
6174: FOR_IN
6175: IFFALSE 6215
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6177: LD_VAR 0 1
6181: PPUSH
6182: LD_INT 125
6184: PPUSH
6185: LD_INT 129
6187: PPUSH
6188: CALL_OW 297
6192: PUSH
6193: LD_INT 9
6195: GREATER
6196: IFFALSE 6213
// ComMoveXY ( i , 125 , 129 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 125
6205: PPUSH
6206: LD_INT 129
6208: PPUSH
6209: CALL_OW 111
6213: GO 6174
6215: POP
6216: POP
// wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6224: LD_VAR 0 2
6228: PPUSH
6229: LD_INT 92
6231: PUSH
6232: LD_INT 125
6234: PUSH
6235: LD_INT 129
6237: PUSH
6238: LD_INT 9
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_VAR 0 2
6256: PUSH
6257: LD_INT 1
6259: MINUS
6260: GREATEREQUAL
6261: IFFALSE 6139
// end ; repeat wait ( 0 0$1 ) ;
6263: LD_INT 35
6265: PPUSH
6266: CALL_OW 67
// for i in tmp do
6270: LD_ADDR_VAR 0 1
6274: PUSH
6275: LD_VAR 0 2
6279: PUSH
6280: FOR_IN
6281: IFFALSE 6363
// begin if GetLives ( i ) > 251 then
6283: LD_VAR 0 1
6287: PPUSH
6288: CALL_OW 256
6292: PUSH
6293: LD_INT 251
6295: GREATER
6296: IFFALSE 6334
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6298: LD_VAR 0 1
6302: PPUSH
6303: LD_INT 81
6305: PUSH
6306: LD_INT 8
6308: PUSH
6309: EMPTY
6310: LIST
6311: LIST
6312: PPUSH
6313: CALL_OW 69
6317: PPUSH
6318: LD_VAR 0 1
6322: PPUSH
6323: CALL_OW 74
6327: PPUSH
6328: CALL_OW 115
6332: GO 6361
// if IsDead ( i ) then
6334: LD_VAR 0 1
6338: PPUSH
6339: CALL_OW 301
6343: IFFALSE 6361
// tmp := tmp diff i ;
6345: LD_ADDR_VAR 0 2
6349: PUSH
6350: LD_VAR 0 2
6354: PUSH
6355: LD_VAR 0 1
6359: DIFF
6360: ST_TO_ADDR
// end ;
6361: GO 6280
6363: POP
6364: POP
// until not tmp ;
6365: LD_VAR 0 2
6369: NOT
6370: IFFALSE 6263
// end ;
6372: PPOPN 3
6374: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6375: LD_EXP 22
6379: NOT
6380: PUSH
6381: LD_EXP 15
6385: PUSH
6386: LD_INT 6
6388: GREATEREQUAL
6389: AND
6390: PUSH
6391: LD_OWVAR 67
6395: PUSH
6396: LD_INT 1
6398: GREATER
6399: AND
6400: IFFALSE 6917
6402: GO 6404
6404: DISABLE
6405: LD_INT 0
6407: PPUSH
6408: PPUSH
6409: PPUSH
// begin enable ;
6410: ENABLE
// tmp := [ ] ;
6411: LD_ADDR_VAR 0 3
6415: PUSH
6416: EMPTY
6417: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6418: LD_ADDR_VAR 0 1
6422: PUSH
6423: DOUBLE
6424: LD_INT 1
6426: DEC
6427: ST_TO_ADDR
6428: LD_INT 4
6430: PUSH
6431: LD_INT 6
6433: PUSH
6434: LD_INT 7
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_OWVAR 67
6446: ARRAY
6447: PUSH
6448: FOR_TO
6449: IFFALSE 6609
// begin uc_side := 8 ;
6451: LD_ADDR_OWVAR 20
6455: PUSH
6456: LD_INT 8
6458: ST_TO_ADDR
// uc_nation := 2 ;
6459: LD_ADDR_OWVAR 21
6463: PUSH
6464: LD_INT 2
6466: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6467: LD_INT 13
6469: PUSH
6470: LD_INT 14
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: PUSH
6477: LD_INT 1
6479: PPUSH
6480: LD_INT 2
6482: PPUSH
6483: CALL_OW 12
6487: ARRAY
6488: PPUSH
6489: LD_INT 1
6491: PPUSH
6492: LD_INT 5
6494: PPUSH
6495: LD_INT 27
6497: PUSH
6498: LD_INT 28
6500: PUSH
6501: LD_INT 26
6503: PUSH
6504: LD_INT 25
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 1
6515: PPUSH
6516: LD_INT 4
6518: PPUSH
6519: CALL_OW 12
6523: ARRAY
6524: PPUSH
6525: LD_INT 88
6527: PPUSH
6528: CALL 71893 0 5
// un := CreateVehicle ;
6532: LD_ADDR_VAR 0 2
6536: PUSH
6537: CALL_OW 45
6541: ST_TO_ADDR
// tmp := tmp ^ un ;
6542: LD_ADDR_VAR 0 3
6546: PUSH
6547: LD_VAR 0 3
6551: PUSH
6552: LD_VAR 0 2
6556: ADD
6557: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6558: LD_VAR 0 2
6562: PPUSH
6563: LD_INT 3
6565: PPUSH
6566: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6570: LD_VAR 0 2
6574: PPUSH
6575: LD_INT 30
6577: PPUSH
6578: LD_INT 0
6580: PPUSH
6581: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6585: LD_VAR 0 2
6589: PPUSH
6590: LD_INT 16
6592: PPUSH
6593: LD_INT 11
6595: PPUSH
6596: CALL_OW 111
// wait ( 0 0$2 ) ;
6600: LD_INT 70
6602: PPUSH
6603: CALL_OW 67
// end ;
6607: GO 6448
6609: POP
6610: POP
// for i = 1 to Difficulty do
6611: LD_ADDR_VAR 0 1
6615: PUSH
6616: DOUBLE
6617: LD_INT 1
6619: DEC
6620: ST_TO_ADDR
6621: LD_OWVAR 67
6625: PUSH
6626: FOR_TO
6627: IFFALSE 6752
// begin uc_side := 8 ;
6629: LD_ADDR_OWVAR 20
6633: PUSH
6634: LD_INT 8
6636: ST_TO_ADDR
// uc_nation := 2 ;
6637: LD_ADDR_OWVAR 21
6641: PUSH
6642: LD_INT 2
6644: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6645: LD_INT 0
6647: PPUSH
6648: LD_INT 8
6650: PPUSH
6651: LD_INT 8
6653: PUSH
6654: LD_INT 8
6656: PUSH
6657: LD_INT 9
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: LIST
6664: PUSH
6665: LD_OWVAR 67
6669: ARRAY
6670: PPUSH
6671: CALL_OW 380
// un := CreateHuman ;
6675: LD_ADDR_VAR 0 2
6679: PUSH
6680: CALL_OW 44
6684: ST_TO_ADDR
// tmp := tmp ^ un ;
6685: LD_ADDR_VAR 0 3
6689: PUSH
6690: LD_VAR 0 3
6694: PUSH
6695: LD_VAR 0 2
6699: ADD
6700: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6701: LD_VAR 0 2
6705: PPUSH
6706: LD_INT 3
6708: PPUSH
6709: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6713: LD_VAR 0 2
6717: PPUSH
6718: LD_INT 30
6720: PPUSH
6721: LD_INT 0
6723: PPUSH
6724: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6728: LD_VAR 0 2
6732: PPUSH
6733: LD_INT 16
6735: PPUSH
6736: LD_INT 11
6738: PPUSH
6739: CALL_OW 111
// wait ( 0 0$2 ) ;
6743: LD_INT 70
6745: PPUSH
6746: CALL_OW 67
// end ;
6750: GO 6626
6752: POP
6753: POP
// repeat wait ( 0 0$1 ) ;
6754: LD_INT 35
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 1
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6908
// begin if GetLives ( i ) > 250 then
6774: LD_VAR 0 1
6778: PPUSH
6779: CALL_OW 256
6783: PUSH
6784: LD_INT 250
6786: GREATER
6787: IFFALSE 6879
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6789: LD_INT 81
6791: PUSH
6792: LD_INT 8
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: PUSH
6799: LD_INT 91
6801: PUSH
6802: LD_VAR 0 1
6806: PUSH
6807: LD_INT 10
6809: PUSH
6810: EMPTY
6811: LIST
6812: LIST
6813: LIST
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: PPUSH
6819: CALL_OW 69
6823: NOT
6824: IFFALSE 6843
// ComAgressiveMove ( i , 67 , 110 ) else
6826: LD_VAR 0 1
6830: PPUSH
6831: LD_INT 67
6833: PPUSH
6834: LD_INT 110
6836: PPUSH
6837: CALL_OW 114
6841: GO 6877
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6843: LD_VAR 0 1
6847: PPUSH
6848: LD_INT 81
6850: PUSH
6851: LD_INT 8
6853: PUSH
6854: EMPTY
6855: LIST
6856: LIST
6857: PPUSH
6858: CALL_OW 69
6862: PPUSH
6863: LD_VAR 0 1
6867: PPUSH
6868: CALL_OW 74
6872: PPUSH
6873: CALL_OW 115
// end else
6877: GO 6906
// if IsDead ( i ) then
6879: LD_VAR 0 1
6883: PPUSH
6884: CALL_OW 301
6888: IFFALSE 6906
// tmp := tmp diff i ;
6890: LD_ADDR_VAR 0 3
6894: PUSH
6895: LD_VAR 0 3
6899: PUSH
6900: LD_VAR 0 1
6904: DIFF
6905: ST_TO_ADDR
// end ;
6906: GO 6771
6908: POP
6909: POP
// until not tmp ;
6910: LD_VAR 0 3
6914: NOT
6915: IFFALSE 6754
// end ; end_of_file
6917: PPOPN 3
6919: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6920: LD_INT 0
6922: PPUSH
6923: PPUSH
6924: PPUSH
6925: PPUSH
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
// side := 3 ;
6931: LD_ADDR_VAR 0 6
6935: PUSH
6936: LD_INT 3
6938: ST_TO_ADDR
// uc_side := side ;
6939: LD_ADDR_OWVAR 20
6943: PUSH
6944: LD_VAR 0 6
6948: ST_TO_ADDR
// uc_nation := 3 ;
6949: LD_ADDR_OWVAR 21
6953: PUSH
6954: LD_INT 3
6956: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6957: LD_ADDR_VAR 0 2
6961: PUSH
6962: LD_INT 22
6964: PUSH
6965: LD_VAR 0 6
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 21
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: PUSH
6993: FOR_IN
6994: IFFALSE 7010
// SetBLevel ( i , 10 ) ;
6996: LD_VAR 0 2
7000: PPUSH
7001: LD_INT 10
7003: PPUSH
7004: CALL_OW 241
7008: GO 6993
7010: POP
7011: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7012: LD_ADDR_VAR 0 9
7016: PUSH
7017: LD_INT 22
7019: PUSH
7020: LD_VAR 0 6
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: LD_INT 30
7031: PUSH
7032: LD_INT 34
7034: PUSH
7035: EMPTY
7036: LIST
7037: LIST
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PPUSH
7043: CALL_OW 69
7047: ST_TO_ADDR
// if teleport then
7048: LD_VAR 0 9
7052: IFFALSE 7073
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7054: LD_VAR 0 9
7058: PUSH
7059: LD_INT 1
7061: ARRAY
7062: PPUSH
7063: LD_INT 123
7065: PPUSH
7066: LD_INT 122
7068: PPUSH
7069: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7073: LD_ADDR_EXP 64
7077: PUSH
7078: LD_STRING Platonov
7080: PPUSH
7081: CALL_OW 25
7085: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7086: LD_ADDR_EXP 65
7090: PUSH
7091: LD_STRING Kovalyuk
7093: PPUSH
7094: CALL_OW 25
7098: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7099: LD_ADDR_EXP 67
7103: PUSH
7104: LD_STRING Yakotich
7106: PPUSH
7107: LD_EXP 1
7111: NOT
7112: PPUSH
7113: LD_STRING 09_
7115: PPUSH
7116: CALL 64778 0 3
7120: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7121: LD_ADDR_EXP 66
7125: PUSH
7126: LD_STRING Bystrov
7128: PPUSH
7129: CALL_OW 25
7133: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7134: LD_ADDR_EXP 68
7138: PUSH
7139: LD_STRING Gleb
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7147: LD_STRING 03_Cornel
7149: PPUSH
7150: CALL_OW 28
7154: IFFALSE 7202
// begin Bierezov := NewCharacter ( Mikhail ) ;
7156: LD_ADDR_EXP 69
7160: PUSH
7161: LD_STRING Mikhail
7163: PPUSH
7164: CALL_OW 25
7168: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7169: LD_EXP 69
7173: PPUSH
7174: LD_INT 197
7176: PPUSH
7177: LD_INT 111
7179: PPUSH
7180: LD_INT 9
7182: PPUSH
7183: LD_INT 0
7185: PPUSH
7186: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7190: LD_EXP 69
7194: PPUSH
7195: LD_INT 3
7197: PPUSH
7198: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7202: LD_EXP 64
7206: PPUSH
7207: LD_INT 126
7209: PPUSH
7210: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7214: LD_EXP 65
7218: PPUSH
7219: LD_INT 134
7221: PPUSH
7222: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7226: LD_EXP 67
7230: PPUSH
7231: LD_INT 197
7233: PPUSH
7234: LD_INT 111
7236: PPUSH
7237: LD_INT 9
7239: PPUSH
7240: LD_INT 0
7242: PPUSH
7243: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7247: LD_EXP 66
7251: PPUSH
7252: LD_INT 197
7254: PPUSH
7255: LD_INT 111
7257: PPUSH
7258: LD_INT 9
7260: PPUSH
7261: LD_INT 0
7263: PPUSH
7264: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7268: LD_EXP 68
7272: PPUSH
7273: LD_INT 197
7275: PPUSH
7276: LD_INT 111
7278: PPUSH
7279: LD_INT 9
7281: PPUSH
7282: LD_INT 0
7284: PPUSH
7285: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7289: LD_ADDR_VAR 0 5
7293: PUSH
7294: LD_INT 126
7296: PPUSH
7297: LD_INT 4
7299: PPUSH
7300: LD_STRING zhukov
7302: PPUSH
7303: LD_INT 9
7305: PUSH
7306: LD_INT 10
7308: PUSH
7309: LD_INT 10
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: LIST
7316: PUSH
7317: LD_OWVAR 67
7321: ARRAY
7322: PPUSH
7323: LD_INT 90000
7325: PUSH
7326: LD_INT 1000
7328: PUSH
7329: LD_INT 300
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: LIST
7336: PPUSH
7337: LD_INT 21
7339: PUSH
7340: LD_INT 8
7342: PUSH
7343: LD_INT 13
7345: PUSH
7346: LD_INT 8
7348: PUSH
7349: EMPTY
7350: LIST
7351: LIST
7352: LIST
7353: LIST
7354: PPUSH
7355: CALL 75302 0 6
7359: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7360: LD_ADDR_VAR 0 4
7364: PUSH
7365: LD_INT 267
7367: PPUSH
7368: CALL_OW 274
7372: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7373: LD_VAR 0 4
7377: PPUSH
7378: LD_INT 1
7380: PPUSH
7381: LD_INT 5000
7383: PPUSH
7384: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7388: LD_VAR 0 4
7392: PPUSH
7393: LD_INT 2
7395: PPUSH
7396: LD_INT 200
7398: PPUSH
7399: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7403: LD_VAR 0 4
7407: PPUSH
7408: LD_INT 3
7410: PPUSH
7411: LD_INT 200
7413: PPUSH
7414: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7418: LD_ADDR_EXP 102
7422: PUSH
7423: LD_EXP 102
7427: PPUSH
7428: LD_INT 2
7430: PPUSH
7431: LD_VAR 0 5
7435: PUSH
7436: LD_INT 22
7438: PUSH
7439: LD_VAR 0 6
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 21
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PPUSH
7469: CALL_OW 69
7473: UNION
7474: PUSH
7475: LD_EXP 64
7479: DIFF
7480: PPUSH
7481: CALL_OW 1
7485: ST_TO_ADDR
// behemoths := [ ] ;
7486: LD_ADDR_EXP 72
7490: PUSH
7491: EMPTY
7492: ST_TO_ADDR
// behemothBuilders := [ ] ;
7493: LD_ADDR_EXP 73
7497: PUSH
7498: EMPTY
7499: ST_TO_ADDR
// if Kovalyuk then
7500: LD_EXP 65
7504: IFFALSE 7526
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7506: LD_ADDR_EXP 73
7510: PUSH
7511: LD_EXP 73
7515: PPUSH
7516: LD_EXP 65
7520: PPUSH
7521: CALL 107648 0 2
7525: ST_TO_ADDR
// j := 3 ;
7526: LD_ADDR_VAR 0 3
7530: PUSH
7531: LD_INT 3
7533: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7534: LD_ADDR_VAR 0 2
7538: PUSH
7539: LD_INT 22
7541: PUSH
7542: LD_INT 3
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: PUSH
7549: LD_INT 25
7551: PUSH
7552: LD_INT 3
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: PUSH
7559: EMPTY
7560: LIST
7561: LIST
7562: PPUSH
7563: CALL_OW 69
7567: PUSH
7568: LD_EXP 65
7572: DIFF
7573: PUSH
7574: FOR_IN
7575: IFFALSE 7625
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7577: LD_ADDR_EXP 73
7581: PUSH
7582: LD_EXP 73
7586: PPUSH
7587: LD_VAR 0 2
7591: PPUSH
7592: CALL 107648 0 2
7596: ST_TO_ADDR
// j := j - 1 ;
7597: LD_ADDR_VAR 0 3
7601: PUSH
7602: LD_VAR 0 3
7606: PUSH
7607: LD_INT 1
7609: MINUS
7610: ST_TO_ADDR
// if j = 0 then
7611: LD_VAR 0 3
7615: PUSH
7616: LD_INT 0
7618: EQUAL
7619: IFFALSE 7623
// break ;
7621: GO 7625
// end ;
7623: GO 7574
7625: POP
7626: POP
// end ;
7627: LD_VAR 0 1
7631: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7632: LD_INT 0
7634: PPUSH
7635: PPUSH
7636: PPUSH
7637: PPUSH
7638: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7639: LD_ADDR_VAR 0 4
7643: PUSH
7644: LD_INT 209
7646: PUSH
7647: LD_INT 149
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PUSH
7654: LD_INT 219
7656: PUSH
7657: LD_INT 154
7659: PUSH
7660: EMPTY
7661: LIST
7662: LIST
7663: PUSH
7664: LD_INT 223
7666: PUSH
7667: LD_INT 149
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 232
7676: PUSH
7677: LD_INT 155
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: LIST
7688: LIST
7689: ST_TO_ADDR
// if not behemothBuilders then
7690: LD_EXP 73
7694: NOT
7695: IFFALSE 7699
// exit ;
7697: GO 7803
// j := 1 ;
7699: LD_ADDR_VAR 0 3
7703: PUSH
7704: LD_INT 1
7706: ST_TO_ADDR
// for i in behemothBuilders do
7707: LD_ADDR_VAR 0 2
7711: PUSH
7712: LD_EXP 73
7716: PUSH
7717: FOR_IN
7718: IFFALSE 7801
// begin if IsInUnit ( i ) then
7720: LD_VAR 0 2
7724: PPUSH
7725: CALL_OW 310
7729: IFFALSE 7740
// ComExitBuilding ( i ) ;
7731: LD_VAR 0 2
7735: PPUSH
7736: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7740: LD_VAR 0 2
7744: PPUSH
7745: LD_INT 37
7747: PPUSH
7748: LD_VAR 0 4
7752: PUSH
7753: LD_VAR 0 3
7757: ARRAY
7758: PUSH
7759: LD_INT 1
7761: ARRAY
7762: PPUSH
7763: LD_VAR 0 4
7767: PUSH
7768: LD_VAR 0 3
7772: ARRAY
7773: PUSH
7774: LD_INT 2
7776: ARRAY
7777: PPUSH
7778: LD_INT 0
7780: PPUSH
7781: CALL_OW 230
// j := j + 1 ;
7785: LD_ADDR_VAR 0 3
7789: PUSH
7790: LD_VAR 0 3
7794: PUSH
7795: LD_INT 1
7797: PLUS
7798: ST_TO_ADDR
// end ;
7799: GO 7717
7801: POP
7802: POP
// end ;
7803: LD_VAR 0 1
7807: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7808: LD_INT 24
7810: PPUSH
7811: LD_INT 30
7813: PUSH
7814: LD_INT 37
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PPUSH
7821: CALL_OW 70
7825: IFFALSE 7838
7827: GO 7829
7829: DISABLE
// behemothUnderConstruct := true ;
7830: LD_ADDR_EXP 26
7834: PUSH
7835: LD_INT 1
7837: ST_TO_ADDR
7838: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7839: LD_INT 3
7841: PPUSH
7842: CALL 107696 0 1
7846: PUSH
7847: LD_INT 22
7849: PUSH
7850: LD_INT 3
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PUSH
7857: LD_INT 30
7859: PUSH
7860: LD_INT 37
7862: PUSH
7863: EMPTY
7864: LIST
7865: LIST
7866: PUSH
7867: EMPTY
7868: LIST
7869: LIST
7870: PPUSH
7871: CALL_OW 69
7875: NOT
7876: AND
7877: IFFALSE 8063
7879: GO 7881
7881: DISABLE
7882: LD_INT 0
7884: PPUSH
7885: PPUSH
// begin enable ;
7886: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7887: LD_ADDR_VAR 0 2
7891: PUSH
7892: LD_INT 3
7894: PPUSH
7895: CALL 107696 0 1
7899: ST_TO_ADDR
// for i in tmp do
7900: LD_ADDR_VAR 0 1
7904: PUSH
7905: LD_VAR 0 2
7909: PUSH
7910: FOR_IN
7911: IFFALSE 8061
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7913: LD_VAR 0 1
7917: PPUSH
7918: LD_INT 9
7920: PPUSH
7921: CALL_OW 308
7925: PUSH
7926: LD_VAR 0 1
7930: PPUSH
7931: CALL_OW 110
7935: PUSH
7936: LD_INT 2
7938: EQUAL
7939: NOT
7940: AND
7941: IFFALSE 7955
// SetTag ( i , 2 ) ;
7943: LD_VAR 0 1
7947: PPUSH
7948: LD_INT 2
7950: PPUSH
7951: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7955: LD_INT 81
7957: PUSH
7958: LD_INT 3
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: PUSH
7965: LD_INT 91
7967: PUSH
7968: LD_VAR 0 1
7972: PUSH
7973: LD_INT 12
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: LIST
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: NOT
7990: PUSH
7991: LD_VAR 0 1
7995: PPUSH
7996: CALL_OW 110
8000: PUSH
8001: LD_INT 2
8003: EQUAL
8004: NOT
8005: AND
8006: IFFALSE 8025
// ComAgressiveMove ( i , 64 , 93 ) else
8008: LD_VAR 0 1
8012: PPUSH
8013: LD_INT 64
8015: PPUSH
8016: LD_INT 93
8018: PPUSH
8019: CALL_OW 114
8023: GO 8059
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8025: LD_VAR 0 1
8029: PPUSH
8030: LD_INT 81
8032: PUSH
8033: LD_INT 3
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: PPUSH
8040: CALL_OW 69
8044: PPUSH
8045: LD_VAR 0 1
8049: PPUSH
8050: CALL_OW 74
8054: PPUSH
8055: CALL_OW 115
// end ;
8059: GO 7910
8061: POP
8062: POP
// end ;
8063: PPOPN 2
8065: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8066: LD_INT 0
8068: PPUSH
8069: PPUSH
8070: PPUSH
// result := [ ] ;
8071: LD_ADDR_VAR 0 2
8075: PUSH
8076: EMPTY
8077: ST_TO_ADDR
// uc_side := 6 ;
8078: LD_ADDR_OWVAR 20
8082: PUSH
8083: LD_INT 6
8085: ST_TO_ADDR
// uc_nation := 3 ;
8086: LD_ADDR_OWVAR 21
8090: PUSH
8091: LD_INT 3
8093: ST_TO_ADDR
// case strength of 1 :
8094: LD_VAR 0 1
8098: PUSH
8099: LD_INT 1
8101: DOUBLE
8102: EQUAL
8103: IFTRUE 8107
8105: GO 8245
8107: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8108: LD_ADDR_VAR 0 3
8112: PUSH
8113: DOUBLE
8114: LD_INT 1
8116: DEC
8117: ST_TO_ADDR
8118: LD_INT 4
8120: PUSH
8121: LD_INT 5
8123: PUSH
8124: LD_INT 6
8126: PUSH
8127: EMPTY
8128: LIST
8129: LIST
8130: LIST
8131: PUSH
8132: LD_OWVAR 67
8136: ARRAY
8137: PUSH
8138: FOR_TO
8139: IFFALSE 8241
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8141: LD_INT 22
8143: PUSH
8144: LD_INT 24
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: LD_VAR 0 3
8155: PUSH
8156: LD_INT 2
8158: MOD
8159: PUSH
8160: LD_INT 1
8162: PLUS
8163: ARRAY
8164: PPUSH
8165: LD_INT 1
8167: PUSH
8168: LD_INT 3
8170: PUSH
8171: EMPTY
8172: LIST
8173: LIST
8174: PUSH
8175: LD_INT 1
8177: PPUSH
8178: LD_INT 2
8180: PPUSH
8181: CALL_OW 12
8185: ARRAY
8186: PPUSH
8187: LD_INT 3
8189: PPUSH
8190: LD_INT 43
8192: PUSH
8193: LD_INT 44
8195: PUSH
8196: LD_INT 45
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 1
8206: PPUSH
8207: LD_INT 3
8209: PPUSH
8210: CALL_OW 12
8214: ARRAY
8215: PPUSH
8216: LD_INT 80
8218: PPUSH
8219: CALL 71893 0 5
// result := result union CreateVehicle ;
8223: LD_ADDR_VAR 0 2
8227: PUSH
8228: LD_VAR 0 2
8232: PUSH
8233: CALL_OW 45
8237: UNION
8238: ST_TO_ADDR
// end ;
8239: GO 8138
8241: POP
8242: POP
// end ; 2 :
8243: GO 9189
8245: LD_INT 2
8247: DOUBLE
8248: EQUAL
8249: IFTRUE 8253
8251: GO 8409
8253: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8254: LD_ADDR_VAR 0 3
8258: PUSH
8259: DOUBLE
8260: LD_INT 1
8262: DEC
8263: ST_TO_ADDR
8264: LD_INT 5
8266: PUSH
8267: LD_INT 6
8269: PUSH
8270: LD_INT 7
8272: PUSH
8273: EMPTY
8274: LIST
8275: LIST
8276: LIST
8277: PUSH
8278: LD_OWVAR 67
8282: ARRAY
8283: PUSH
8284: FOR_TO
8285: IFFALSE 8405
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8287: LD_INT 22
8289: PUSH
8290: LD_INT 24
8292: PUSH
8293: LD_INT 24
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: LIST
8300: PUSH
8301: LD_VAR 0 3
8305: PUSH
8306: LD_INT 3
8308: MOD
8309: PUSH
8310: LD_INT 1
8312: PLUS
8313: ARRAY
8314: PPUSH
8315: LD_INT 1
8317: PUSH
8318: LD_INT 3
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PUSH
8325: LD_INT 1
8327: PPUSH
8328: LD_INT 2
8330: PPUSH
8331: CALL_OW 12
8335: ARRAY
8336: PPUSH
8337: LD_INT 3
8339: PPUSH
8340: LD_INT 43
8342: PUSH
8343: LD_INT 44
8345: PUSH
8346: LD_INT 45
8348: PUSH
8349: LD_INT 44
8351: PUSH
8352: LD_INT 46
8354: PUSH
8355: LD_INT 46
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: PUSH
8366: LD_VAR 0 3
8370: PUSH
8371: LD_INT 6
8373: MOD
8374: PUSH
8375: LD_INT 1
8377: PLUS
8378: ARRAY
8379: PPUSH
8380: LD_INT 80
8382: PPUSH
8383: CALL 71893 0 5
// result := result union CreateVehicle ;
8387: LD_ADDR_VAR 0 2
8391: PUSH
8392: LD_VAR 0 2
8396: PUSH
8397: CALL_OW 45
8401: UNION
8402: ST_TO_ADDR
// end ;
8403: GO 8284
8405: POP
8406: POP
// end ; 3 :
8407: GO 9189
8409: LD_INT 3
8411: DOUBLE
8412: EQUAL
8413: IFTRUE 8417
8415: GO 8573
8417: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8418: LD_ADDR_VAR 0 3
8422: PUSH
8423: DOUBLE
8424: LD_INT 1
8426: DEC
8427: ST_TO_ADDR
8428: LD_INT 5
8430: PUSH
8431: LD_INT 7
8433: PUSH
8434: LD_INT 8
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: LIST
8441: PUSH
8442: LD_OWVAR 67
8446: ARRAY
8447: PUSH
8448: FOR_TO
8449: IFFALSE 8569
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8451: LD_INT 22
8453: PUSH
8454: LD_INT 24
8456: PUSH
8457: LD_INT 24
8459: PUSH
8460: EMPTY
8461: LIST
8462: LIST
8463: LIST
8464: PUSH
8465: LD_VAR 0 3
8469: PUSH
8470: LD_INT 3
8472: MOD
8473: PUSH
8474: LD_INT 1
8476: PLUS
8477: ARRAY
8478: PPUSH
8479: LD_INT 1
8481: PUSH
8482: LD_INT 3
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: PUSH
8489: LD_INT 1
8491: PPUSH
8492: LD_INT 2
8494: PPUSH
8495: CALL_OW 12
8499: ARRAY
8500: PPUSH
8501: LD_INT 3
8503: PPUSH
8504: LD_INT 43
8506: PUSH
8507: LD_INT 47
8509: PUSH
8510: LD_INT 45
8512: PUSH
8513: LD_INT 45
8515: PUSH
8516: LD_INT 46
8518: PUSH
8519: LD_INT 46
8521: PUSH
8522: EMPTY
8523: LIST
8524: LIST
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: PUSH
8530: LD_VAR 0 3
8534: PUSH
8535: LD_INT 6
8537: MOD
8538: PUSH
8539: LD_INT 1
8541: PLUS
8542: ARRAY
8543: PPUSH
8544: LD_INT 80
8546: PPUSH
8547: CALL 71893 0 5
// result := result union CreateVehicle ;
8551: LD_ADDR_VAR 0 2
8555: PUSH
8556: LD_VAR 0 2
8560: PUSH
8561: CALL_OW 45
8565: UNION
8566: ST_TO_ADDR
// end ;
8567: GO 8448
8569: POP
8570: POP
// end ; 4 :
8571: GO 9189
8573: LD_INT 4
8575: DOUBLE
8576: EQUAL
8577: IFTRUE 8581
8579: GO 9188
8581: POP
// begin uc_nation := 3 ;
8582: LD_ADDR_OWVAR 21
8586: PUSH
8587: LD_INT 3
8589: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8590: LD_ADDR_VAR 0 3
8594: PUSH
8595: DOUBLE
8596: LD_INT 1
8598: DEC
8599: ST_TO_ADDR
8600: LD_INT 6
8602: PUSH
8603: LD_INT 8
8605: PUSH
8606: LD_INT 9
8608: PUSH
8609: EMPTY
8610: LIST
8611: LIST
8612: LIST
8613: PUSH
8614: LD_OWVAR 67
8618: ARRAY
8619: PUSH
8620: FOR_TO
8621: IFFALSE 8741
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8623: LD_INT 22
8625: PUSH
8626: LD_INT 24
8628: PUSH
8629: LD_INT 24
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: LIST
8636: PUSH
8637: LD_VAR 0 3
8641: PUSH
8642: LD_INT 3
8644: MOD
8645: PUSH
8646: LD_INT 1
8648: PLUS
8649: ARRAY
8650: PPUSH
8651: LD_INT 1
8653: PUSH
8654: LD_INT 3
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: PUSH
8661: LD_INT 1
8663: PPUSH
8664: LD_INT 2
8666: PPUSH
8667: CALL_OW 12
8671: ARRAY
8672: PPUSH
8673: LD_INT 3
8675: PPUSH
8676: LD_INT 45
8678: PUSH
8679: LD_INT 47
8681: PUSH
8682: LD_INT 47
8684: PUSH
8685: LD_INT 45
8687: PUSH
8688: LD_INT 46
8690: PUSH
8691: LD_INT 46
8693: PUSH
8694: EMPTY
8695: LIST
8696: LIST
8697: LIST
8698: LIST
8699: LIST
8700: LIST
8701: PUSH
8702: LD_VAR 0 3
8706: PUSH
8707: LD_INT 6
8709: MOD
8710: PUSH
8711: LD_INT 1
8713: PLUS
8714: ARRAY
8715: PPUSH
8716: LD_INT 80
8718: PPUSH
8719: CALL 71893 0 5
// result := result union CreateVehicle ;
8723: LD_ADDR_VAR 0 2
8727: PUSH
8728: LD_VAR 0 2
8732: PUSH
8733: CALL_OW 45
8737: UNION
8738: ST_TO_ADDR
// end ;
8739: GO 8620
8741: POP
8742: POP
// if not KappaStatus then
8743: LD_EXP 2
8747: NOT
8748: IFFALSE 8983
// begin uc_nation := 1 ;
8750: LD_ADDR_OWVAR 21
8754: PUSH
8755: LD_INT 1
8757: ST_TO_ADDR
// for i = 1 to 3 do
8758: LD_ADDR_VAR 0 3
8762: PUSH
8763: DOUBLE
8764: LD_INT 1
8766: DEC
8767: ST_TO_ADDR
8768: LD_INT 3
8770: PUSH
8771: FOR_TO
8772: IFFALSE 8908
// begin j := rand ( 0 , 1 ) ;
8774: LD_ADDR_VAR 0 4
8778: PUSH
8779: LD_INT 0
8781: PPUSH
8782: LD_INT 1
8784: PPUSH
8785: CALL_OW 12
8789: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8790: LD_INT 3
8792: PUSH
8793: LD_INT 5
8795: PUSH
8796: LD_INT 5
8798: PUSH
8799: LD_INT 4
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: LIST
8806: LIST
8807: PUSH
8808: LD_VAR 0 4
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 3
8818: PPUSH
8819: CALL_OW 12
8823: PLUS
8824: ARRAY
8825: PPUSH
8826: LD_INT 1
8828: PUSH
8829: LD_INT 3
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 1
8838: PPUSH
8839: LD_INT 2
8841: PPUSH
8842: CALL_OW 12
8846: ARRAY
8847: PPUSH
8848: LD_INT 3
8850: PPUSH
8851: LD_INT 9
8853: PUSH
8854: LD_INT 7
8856: PUSH
8857: LD_INT 6
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: LIST
8864: PUSH
8865: LD_VAR 0 4
8869: PUSH
8870: LD_INT 1
8872: PPUSH
8873: LD_INT 2
8875: PPUSH
8876: CALL_OW 12
8880: PLUS
8881: ARRAY
8882: PPUSH
8883: LD_INT 85
8885: PPUSH
8886: CALL 71893 0 5
// result := result union CreateVehicle ;
8890: LD_ADDR_VAR 0 2
8894: PUSH
8895: LD_VAR 0 2
8899: PUSH
8900: CALL_OW 45
8904: UNION
8905: ST_TO_ADDR
// end ;
8906: GO 8771
8908: POP
8909: POP
// if vsevolodFirstAttack then
8910: LD_EXP 24
8914: IFFALSE 8981
// begin vsevolodFirstAttack := false ;
8916: LD_ADDR_EXP 24
8920: PUSH
8921: LD_INT 0
8923: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8924: LD_INT 5
8926: PPUSH
8927: LD_INT 3
8929: PPUSH
8930: LD_INT 1
8932: PPUSH
8933: LD_INT 6
8935: PPUSH
8936: LD_INT 100
8938: PPUSH
8939: CALL 71893 0 5
// sewiVeh := CreateVehicle ;
8943: LD_ADDR_EXP 71
8947: PUSH
8948: CALL_OW 45
8952: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8953: LD_EXP 71
8957: PPUSH
8958: LD_INT 1
8960: PPUSH
8961: CALL_OW 242
// result := result union sewiVeh ;
8965: LD_ADDR_VAR 0 2
8969: PUSH
8970: LD_VAR 0 2
8974: PUSH
8975: LD_EXP 71
8979: UNION
8980: ST_TO_ADDR
// end ; end else
8981: GO 9186
// if vsevolodFirstAttack then
8983: LD_EXP 24
8987: IFFALSE 9186
// begin vsevolodFirstAttack := false ;
8989: LD_ADDR_EXP 24
8993: PUSH
8994: LD_INT 0
8996: ST_TO_ADDR
// uc_nation := 3 ;
8997: LD_ADDR_OWVAR 21
9001: PUSH
9002: LD_INT 3
9004: ST_TO_ADDR
// for i = 1 to 3 do
9005: LD_ADDR_VAR 0 3
9009: PUSH
9010: DOUBLE
9011: LD_INT 1
9013: DEC
9014: ST_TO_ADDR
9015: LD_INT 3
9017: PUSH
9018: FOR_TO
9019: IFFALSE 9127
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9021: LD_INT 22
9023: PUSH
9024: LD_INT 24
9026: PUSH
9027: LD_INT 24
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: LIST
9034: PUSH
9035: LD_VAR 0 3
9039: PUSH
9040: LD_INT 3
9042: MOD
9043: PUSH
9044: LD_INT 1
9046: PLUS
9047: ARRAY
9048: PPUSH
9049: LD_INT 1
9051: PUSH
9052: LD_INT 3
9054: PUSH
9055: EMPTY
9056: LIST
9057: LIST
9058: PUSH
9059: LD_INT 1
9061: PPUSH
9062: LD_INT 2
9064: PPUSH
9065: CALL_OW 12
9069: ARRAY
9070: PPUSH
9071: LD_INT 3
9073: PPUSH
9074: LD_INT 45
9076: PUSH
9077: LD_INT 47
9079: PUSH
9080: LD_INT 47
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: PUSH
9088: LD_VAR 0 3
9092: PUSH
9093: LD_INT 3
9095: MOD
9096: PUSH
9097: LD_INT 1
9099: PLUS
9100: ARRAY
9101: PPUSH
9102: LD_INT 80
9104: PPUSH
9105: CALL 71893 0 5
// result := result union CreateVehicle ;
9109: LD_ADDR_VAR 0 2
9113: PUSH
9114: LD_VAR 0 2
9118: PUSH
9119: CALL_OW 45
9123: UNION
9124: ST_TO_ADDR
// end ;
9125: GO 9018
9127: POP
9128: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9129: LD_INT 24
9131: PPUSH
9132: LD_INT 3
9134: PPUSH
9135: LD_INT 1
9137: PPUSH
9138: LD_INT 47
9140: PPUSH
9141: LD_INT 100
9143: PPUSH
9144: CALL 71893 0 5
// sewiVeh := CreateVehicle ;
9148: LD_ADDR_EXP 71
9152: PUSH
9153: CALL_OW 45
9157: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9158: LD_EXP 71
9162: PPUSH
9163: LD_INT 1
9165: PPUSH
9166: CALL_OW 242
// result := result union sewiVeh ;
9170: LD_ADDR_VAR 0 2
9174: PUSH
9175: LD_VAR 0 2
9179: PUSH
9180: LD_EXP 71
9184: UNION
9185: ST_TO_ADDR
// end ; end ; end ;
9186: GO 9189
9188: POP
// end ;
9189: LD_VAR 0 2
9193: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9194: LD_EXP 16
9198: IFFALSE 9956
9200: GO 9202
9202: DISABLE
9203: LD_INT 0
9205: PPUSH
9206: PPUSH
9207: PPUSH
9208: PPUSH
9209: PPUSH
9210: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9211: LD_ADDR_VAR 0 4
9215: PUSH
9216: LD_INT 11
9218: PUSH
9219: LD_INT 12
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$40 , 4 4$10 ] [ Difficulty ] ;
9226: LD_ADDR_VAR 0 3
9230: PUSH
9231: LD_INT 11550
9233: PUSH
9234: LD_INT 9800
9236: PUSH
9237: LD_INT 8750
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: LIST
9244: PUSH
9245: LD_OWVAR 67
9249: ARRAY
9250: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9251: LD_ADDR_VAR 0 6
9255: PUSH
9256: LD_INT 70
9258: PUSH
9259: LD_INT 118
9261: PUSH
9262: EMPTY
9263: LIST
9264: LIST
9265: PUSH
9266: LD_INT 78
9268: PUSH
9269: LD_INT 31
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: ST_TO_ADDR
// repeat if missionStage = 2 then
9280: LD_EXP 15
9284: PUSH
9285: LD_INT 2
9287: EQUAL
9288: IFFALSE 9299
// wait ( 1 1$30 ) else
9290: LD_INT 3150
9292: PPUSH
9293: CALL_OW 67
9297: GO 9308
// wait ( time ) ;
9299: LD_VAR 0 3
9303: PPUSH
9304: CALL_OW 67
// if missionStage = 6 then
9308: LD_EXP 15
9312: PUSH
9313: LD_INT 6
9315: EQUAL
9316: IFFALSE 9344
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9318: LD_INT 51
9320: PPUSH
9321: LD_INT 6
9323: PPUSH
9324: LD_INT 2
9326: PPUSH
9327: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9331: LD_INT 57
9333: PPUSH
9334: LD_INT 6
9336: PPUSH
9337: LD_INT 2
9339: PPUSH
9340: CALL_OW 322
// end ; if missionStage = 8 then
9344: LD_EXP 15
9348: PUSH
9349: LD_INT 8
9351: EQUAL
9352: IFFALSE 9380
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9354: LD_INT 52
9356: PPUSH
9357: LD_INT 6
9359: PPUSH
9360: LD_INT 2
9362: PPUSH
9363: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9367: LD_INT 58
9369: PPUSH
9370: LD_INT 6
9372: PPUSH
9373: LD_INT 2
9375: PPUSH
9376: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9380: LD_EXP 15
9384: PUSH
9385: LD_INT 10
9387: EQUAL
9388: PUSH
9389: LD_OWVAR 67
9393: PUSH
9394: LD_INT 1
9396: GREATER
9397: AND
9398: IFFALSE 9426
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9400: LD_INT 53
9402: PPUSH
9403: LD_INT 6
9405: PPUSH
9406: LD_INT 2
9408: PPUSH
9409: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9413: LD_INT 59
9415: PPUSH
9416: LD_INT 6
9418: PPUSH
9419: LD_INT 2
9421: PPUSH
9422: CALL_OW 322
// end ; if activeAttacks then
9426: LD_EXP 16
9430: IFFALSE 9950
// begin if missionStage = 2 then
9432: LD_EXP 15
9436: PUSH
9437: LD_INT 2
9439: EQUAL
9440: IFFALSE 9450
// strength := 1 ;
9442: LD_ADDR_VAR 0 5
9446: PUSH
9447: LD_INT 1
9449: ST_TO_ADDR
// if missionStage > 2 then
9450: LD_EXP 15
9454: PUSH
9455: LD_INT 2
9457: GREATER
9458: IFFALSE 9468
// strength := 2 ;
9460: LD_ADDR_VAR 0 5
9464: PUSH
9465: LD_INT 2
9467: ST_TO_ADDR
// if missionStage > 6 then
9468: LD_EXP 15
9472: PUSH
9473: LD_INT 6
9475: GREATER
9476: IFFALSE 9486
// strength := 3 ;
9478: LD_ADDR_VAR 0 5
9482: PUSH
9483: LD_INT 3
9485: ST_TO_ADDR
// if missionStage > 10 then
9486: LD_EXP 15
9490: PUSH
9491: LD_INT 10
9493: GREATER
9494: IFFALSE 9504
// strength := 4 ;
9496: LD_ADDR_VAR 0 5
9500: PUSH
9501: LD_INT 4
9503: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9504: LD_ADDR_VAR 0 2
9508: PUSH
9509: LD_VAR 0 5
9513: PPUSH
9514: CALL 8066 0 1
9518: ST_TO_ADDR
// for i in tmp do
9519: LD_ADDR_VAR 0 1
9523: PUSH
9524: LD_VAR 0 2
9528: PUSH
9529: FOR_IN
9530: IFFALSE 9630
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9532: LD_VAR 0 1
9536: PPUSH
9537: LD_VAR 0 4
9541: PUSH
9542: LD_INT 1
9544: PPUSH
9545: LD_INT 2
9547: PPUSH
9548: CALL_OW 12
9552: ARRAY
9553: PPUSH
9554: LD_INT 0
9556: PPUSH
9557: CALL_OW 49
// if i = sewiVeh then
9561: LD_VAR 0 1
9565: PUSH
9566: LD_EXP 71
9570: EQUAL
9571: IFFALSE 9606
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9573: LD_ADDR_EXP 70
9577: PUSH
9578: LD_STRING Vsevolod
9580: PPUSH
9581: LD_INT 0
9583: PPUSH
9584: LD_STRING 
9586: PPUSH
9587: CALL 64778 0 3
9591: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9592: LD_EXP 70
9596: PPUSH
9597: LD_VAR 0 1
9601: PPUSH
9602: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9606: LD_VAR 0 1
9610: PPUSH
9611: LD_INT 111
9613: PPUSH
9614: LD_INT 197
9616: PPUSH
9617: CALL_OW 111
// wait ( 0 0$2 ) ;
9621: LD_INT 70
9623: PPUSH
9624: CALL_OW 67
// end ;
9628: GO 9529
9630: POP
9631: POP
// repeat wait ( 0 0$1 ) ;
9632: LD_INT 35
9634: PPUSH
9635: CALL_OW 67
// for i in tmp do
9639: LD_ADDR_VAR 0 1
9643: PUSH
9644: LD_VAR 0 2
9648: PUSH
9649: FOR_IN
9650: IFFALSE 9931
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9652: LD_INT 81
9654: PUSH
9655: LD_INT 6
9657: PUSH
9658: EMPTY
9659: LIST
9660: LIST
9661: PUSH
9662: LD_INT 91
9664: PUSH
9665: LD_VAR 0 1
9669: PUSH
9670: LD_INT 12
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: LIST
9677: PUSH
9678: EMPTY
9679: LIST
9680: LIST
9681: PPUSH
9682: CALL_OW 69
9686: IFFALSE 9744
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9688: LD_VAR 0 1
9692: PPUSH
9693: LD_INT 81
9695: PUSH
9696: LD_INT 6
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: PUSH
9703: LD_INT 91
9705: PUSH
9706: LD_VAR 0 1
9710: PUSH
9711: LD_INT 12
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: LIST
9718: PUSH
9719: EMPTY
9720: LIST
9721: LIST
9722: PPUSH
9723: CALL_OW 69
9727: PPUSH
9728: LD_VAR 0 1
9732: PPUSH
9733: CALL_OW 74
9737: PPUSH
9738: CALL_OW 115
9742: GO 9929
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9744: LD_INT 9
9746: PPUSH
9747: LD_INT 81
9749: PUSH
9750: LD_INT 6
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: PPUSH
9757: CALL_OW 70
9761: IFFALSE 9895
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9763: LD_VAR 0 1
9767: PPUSH
9768: LD_VAR 0 6
9772: PUSH
9773: LD_INT 1
9775: ARRAY
9776: PUSH
9777: LD_INT 1
9779: ARRAY
9780: PPUSH
9781: LD_VAR 0 6
9785: PUSH
9786: LD_INT 1
9788: ARRAY
9789: PUSH
9790: LD_INT 2
9792: ARRAY
9793: PPUSH
9794: CALL_OW 297
9798: PUSH
9799: LD_INT 10
9801: GREATER
9802: PUSH
9803: LD_VAR 0 1
9807: PPUSH
9808: LD_INT 9
9810: PPUSH
9811: CALL_OW 308
9815: NOT
9816: AND
9817: IFFALSE 9856
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9819: LD_VAR 0 1
9823: PPUSH
9824: LD_VAR 0 6
9828: PUSH
9829: LD_INT 1
9831: ARRAY
9832: PUSH
9833: LD_INT 1
9835: ARRAY
9836: PPUSH
9837: LD_VAR 0 6
9841: PUSH
9842: LD_INT 1
9844: ARRAY
9845: PUSH
9846: LD_INT 2
9848: ARRAY
9849: PPUSH
9850: CALL_OW 114
9854: GO 9893
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9856: LD_VAR 0 1
9860: PPUSH
9861: LD_INT 9
9863: PPUSH
9864: LD_INT 81
9866: PUSH
9867: LD_INT 6
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 70
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
// end else
9893: GO 9929
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9895: LD_VAR 0 1
9899: PPUSH
9900: LD_INT 81
9902: PUSH
9903: LD_INT 6
9905: PUSH
9906: EMPTY
9907: LIST
9908: LIST
9909: PPUSH
9910: CALL_OW 69
9914: PPUSH
9915: LD_VAR 0 1
9919: PPUSH
9920: CALL_OW 74
9924: PPUSH
9925: CALL_OW 115
// end ;
9929: GO 9649
9931: POP
9932: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9933: LD_INT 22
9935: PUSH
9936: LD_INT 6
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: PPUSH
9943: CALL_OW 69
9947: NOT
9948: IFFALSE 9632
// end ; until russianDestroyed ;
9950: LD_EXP 21
9954: IFFALSE 9280
// end ;
9956: PPOPN 6
9958: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9959: LD_EXP 21
9963: NOT
9964: PUSH
9965: LD_EXP 15
9969: PUSH
9970: LD_INT 6
9972: GREATEREQUAL
9973: AND
9974: PUSH
9975: LD_INT 2
9977: PPUSH
9978: LD_INT 1
9980: PPUSH
9981: CALL 59852 0 2
9985: NOT
9986: AND
9987: IFFALSE 10943
9989: GO 9991
9991: DISABLE
9992: LD_INT 0
9994: PPUSH
9995: PPUSH
9996: PPUSH
9997: PPUSH
// begin enable ;
9998: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9999: LD_INT 22
10001: PUSH
10002: LD_INT 3
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: PUSH
10009: LD_INT 30
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: PPUSH
10023: CALL_OW 69
10027: NOT
10028: IFFALSE 10032
// exit ;
10030: GO 10943
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10032: LD_ADDR_VAR 0 4
10036: PUSH
10037: LD_INT 22
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 30
10049: PUSH
10050: LD_INT 34
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: ST_TO_ADDR
// if Prob ( 40 ) then
10066: LD_INT 40
10068: PPUSH
10069: CALL_OW 13
10073: IFFALSE 10200
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10075: LD_INT 2
10077: PPUSH
10078: LD_INT 22
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 3
10086: PUSH
10087: LD_INT 49
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: PUSH
10096: LD_INT 22
10098: PUSH
10099: LD_INT 3
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: LD_INT 49
10107: PUSH
10108: EMPTY
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: PUSH
10114: LD_INT 22
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: LD_INT 3
10122: PUSH
10123: LD_INT 49
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: PUSH
10132: LD_INT 24
10134: PUSH
10135: LD_INT 3
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: LD_INT 46
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: PUSH
10150: LD_INT 24
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: LD_INT 3
10158: PUSH
10159: LD_INT 46
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: LIST
10167: PUSH
10168: LD_INT 24
10170: PUSH
10171: LD_INT 3
10173: PUSH
10174: LD_INT 3
10176: PUSH
10177: LD_INT 46
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: LIST
10184: LIST
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: LIST
10192: LIST
10193: PPUSH
10194: CALL 58434 0 2
// end else
10198: GO 10323
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10200: LD_INT 2
10202: PPUSH
10203: LD_INT 24
10205: PUSH
10206: LD_INT 3
10208: PUSH
10209: LD_INT 3
10211: PUSH
10212: LD_INT 47
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: LD_INT 24
10223: PUSH
10224: LD_INT 3
10226: PUSH
10227: LD_INT 3
10229: PUSH
10230: LD_INT 47
10232: PUSH
10233: EMPTY
10234: LIST
10235: LIST
10236: LIST
10237: LIST
10238: PUSH
10239: LD_INT 24
10241: PUSH
10242: LD_INT 3
10244: PUSH
10245: LD_INT 3
10247: PUSH
10248: LD_INT 47
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: LIST
10255: LIST
10256: PUSH
10257: LD_INT 24
10259: PUSH
10260: LD_INT 3
10262: PUSH
10263: LD_INT 3
10265: PUSH
10266: LD_INT 46
10268: PUSH
10269: EMPTY
10270: LIST
10271: LIST
10272: LIST
10273: LIST
10274: PUSH
10275: LD_INT 24
10277: PUSH
10278: LD_INT 3
10280: PUSH
10281: LD_INT 3
10283: PUSH
10284: LD_INT 46
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 24
10295: PUSH
10296: LD_INT 3
10298: PUSH
10299: LD_INT 3
10301: PUSH
10302: LD_INT 46
10304: PUSH
10305: EMPTY
10306: LIST
10307: LIST
10308: LIST
10309: LIST
10310: PUSH
10311: EMPTY
10312: LIST
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PPUSH
10319: CALL 58434 0 2
// end ; if Difficulty > 1 then
10323: LD_OWVAR 67
10327: PUSH
10328: LD_INT 1
10330: GREATER
10331: IFFALSE 10361
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10333: LD_INT 2
10335: PPUSH
10336: LD_INT 24
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 3
10344: PUSH
10345: LD_INT 47
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: PUSH
10354: EMPTY
10355: LIST
10356: PPUSH
10357: CALL 58434 0 2
// repeat wait ( 0 0$1 ) ;
10361: LD_INT 35
10363: PPUSH
10364: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10368: LD_INT 2
10370: PPUSH
10371: LD_INT 1
10373: PPUSH
10374: CALL 59852 0 2
10378: PUSH
10379: LD_INT 6
10381: PUSH
10382: LD_INT 7
10384: PUSH
10385: LD_INT 7
10387: PUSH
10388: EMPTY
10389: LIST
10390: LIST
10391: LIST
10392: PUSH
10393: LD_OWVAR 67
10397: ARRAY
10398: GREATEREQUAL
10399: IFFALSE 10361
// wait ( 0 0$30 ) ;
10401: LD_INT 1050
10403: PPUSH
10404: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10408: LD_ADDR_VAR 0 2
10412: PUSH
10413: LD_INT 2
10415: PPUSH
10416: LD_INT 1
10418: PPUSH
10419: CALL 59852 0 2
10423: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10424: LD_ADDR_EXP 121
10428: PUSH
10429: LD_EXP 121
10433: PPUSH
10434: LD_INT 2
10436: PPUSH
10437: LD_EXP 121
10441: PUSH
10442: LD_INT 2
10444: ARRAY
10445: PUSH
10446: LD_VAR 0 2
10450: DIFF
10451: PPUSH
10452: CALL_OW 1
10456: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10457: LD_ADDR_VAR 0 3
10461: PUSH
10462: LD_INT 0
10464: PPUSH
10465: LD_INT 1
10467: PPUSH
10468: CALL_OW 12
10472: ST_TO_ADDR
// if target then
10473: LD_VAR 0 3
10477: IFFALSE 10605
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10479: LD_ADDR_VAR 0 2
10483: PUSH
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 24
10491: PUSH
10492: LD_INT 250
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PPUSH
10499: CALL_OW 72
10503: ST_TO_ADDR
// for i in tmp do
10504: LD_ADDR_VAR 0 1
10508: PUSH
10509: LD_VAR 0 2
10513: PUSH
10514: FOR_IN
10515: IFFALSE 10555
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10517: LD_VAR 0 1
10521: PPUSH
10522: LD_INT 139
10524: PPUSH
10525: LD_INT 89
10527: PPUSH
10528: CALL_OW 297
10532: PUSH
10533: LD_INT 9
10535: GREATER
10536: IFFALSE 10553
// ComMoveXY ( i , 139 , 89 ) ;
10538: LD_VAR 0 1
10542: PPUSH
10543: LD_INT 139
10545: PPUSH
10546: LD_INT 89
10548: PPUSH
10549: CALL_OW 111
10553: GO 10514
10555: POP
10556: POP
// wait ( 0 0$1 ) ;
10557: LD_INT 35
10559: PPUSH
10560: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10564: LD_VAR 0 2
10568: PPUSH
10569: LD_INT 92
10571: PUSH
10572: LD_INT 139
10574: PUSH
10575: LD_INT 89
10577: PUSH
10578: LD_INT 9
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: PPUSH
10587: CALL_OW 72
10591: PUSH
10592: LD_VAR 0 2
10596: PUSH
10597: LD_INT 1
10599: MINUS
10600: GREATEREQUAL
10601: IFFALSE 10479
// end else
10603: GO 10747
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10605: LD_VAR 0 2
10609: PPUSH
10610: LD_VAR 0 4
10614: PUSH
10615: LD_INT 1
10617: ARRAY
10618: PPUSH
10619: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10623: LD_ADDR_VAR 0 2
10627: PUSH
10628: LD_VAR 0 2
10632: PPUSH
10633: LD_INT 24
10635: PUSH
10636: LD_INT 250
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PPUSH
10643: CALL_OW 72
10647: ST_TO_ADDR
// for i in tmp do
10648: LD_ADDR_VAR 0 1
10652: PUSH
10653: LD_VAR 0 2
10657: PUSH
10658: FOR_IN
10659: IFFALSE 10699
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10661: LD_VAR 0 1
10665: PPUSH
10666: LD_INT 124
10668: PPUSH
10669: LD_INT 139
10671: PPUSH
10672: CALL_OW 297
10676: PUSH
10677: LD_INT 9
10679: GREATER
10680: IFFALSE 10697
// ComMoveXY ( i , 124 , 139 ) ;
10682: LD_VAR 0 1
10686: PPUSH
10687: LD_INT 124
10689: PPUSH
10690: LD_INT 139
10692: PPUSH
10693: CALL_OW 111
10697: GO 10658
10699: POP
10700: POP
// wait ( 0 0$1 ) ;
10701: LD_INT 35
10703: PPUSH
10704: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10708: LD_VAR 0 2
10712: PPUSH
10713: LD_INT 92
10715: PUSH
10716: LD_INT 124
10718: PUSH
10719: LD_INT 139
10721: PUSH
10722: LD_INT 9
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: PPUSH
10731: CALL_OW 72
10735: PUSH
10736: LD_VAR 0 2
10740: PUSH
10741: LD_INT 1
10743: MINUS
10744: GREATEREQUAL
10745: IFFALSE 10623
// end ; repeat wait ( 0 0$1 ) ;
10747: LD_INT 35
10749: PPUSH
10750: CALL_OW 67
// for i in tmp do
10754: LD_ADDR_VAR 0 1
10758: PUSH
10759: LD_VAR 0 2
10763: PUSH
10764: FOR_IN
10765: IFFALSE 10934
// begin if GetLives ( i ) > 251 then
10767: LD_VAR 0 1
10771: PPUSH
10772: CALL_OW 256
10776: PUSH
10777: LD_INT 251
10779: GREATER
10780: IFFALSE 10905
// begin if GetWeapon ( i ) = ru_time_lapser then
10782: LD_VAR 0 1
10786: PPUSH
10787: CALL_OW 264
10791: PUSH
10792: LD_INT 49
10794: EQUAL
10795: IFFALSE 10851
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10797: LD_VAR 0 1
10801: PPUSH
10802: LD_INT 2
10804: PUSH
10805: LD_INT 22
10807: PUSH
10808: LD_INT 1
10810: PUSH
10811: EMPTY
10812: LIST
10813: LIST
10814: PUSH
10815: LD_INT 22
10817: PUSH
10818: LD_INT 8
10820: PUSH
10821: EMPTY
10822: LIST
10823: LIST
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: LIST
10829: PPUSH
10830: CALL_OW 69
10834: PPUSH
10835: LD_VAR 0 1
10839: PPUSH
10840: CALL_OW 74
10844: PPUSH
10845: CALL_OW 112
10849: GO 10903
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10851: LD_VAR 0 1
10855: PPUSH
10856: LD_INT 2
10858: PUSH
10859: LD_INT 22
10861: PUSH
10862: LD_INT 1
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 22
10871: PUSH
10872: LD_INT 8
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: LIST
10883: PPUSH
10884: CALL_OW 69
10888: PPUSH
10889: LD_VAR 0 1
10893: PPUSH
10894: CALL_OW 74
10898: PPUSH
10899: CALL_OW 115
// end else
10903: GO 10932
// if IsDead ( i ) then
10905: LD_VAR 0 1
10909: PPUSH
10910: CALL_OW 301
10914: IFFALSE 10932
// tmp := tmp diff i ;
10916: LD_ADDR_VAR 0 2
10920: PUSH
10921: LD_VAR 0 2
10925: PUSH
10926: LD_VAR 0 1
10930: DIFF
10931: ST_TO_ADDR
// end ;
10932: GO 10764
10934: POP
10935: POP
// until not tmp ;
10936: LD_VAR 0 2
10940: NOT
10941: IFFALSE 10747
// end ; end_of_file
10943: PPOPN 4
10945: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10946: LD_INT 0
10948: PPUSH
10949: PPUSH
10950: PPUSH
10951: PPUSH
10952: PPUSH
10953: PPUSH
// side := 7 ;
10954: LD_ADDR_VAR 0 5
10958: PUSH
10959: LD_INT 7
10961: ST_TO_ADDR
// uc_side := side ;
10962: LD_ADDR_OWVAR 20
10966: PUSH
10967: LD_VAR 0 5
10971: ST_TO_ADDR
// uc_nation := 1 ;
10972: LD_ADDR_OWVAR 21
10976: PUSH
10977: LD_INT 1
10979: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10980: LD_ADDR_VAR 0 2
10984: PUSH
10985: LD_INT 22
10987: PUSH
10988: LD_VAR 0 5
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: PUSH
10997: LD_INT 21
10999: PUSH
11000: LD_INT 3
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: PPUSH
11011: CALL_OW 69
11015: PUSH
11016: FOR_IN
11017: IFFALSE 11033
// SetBLevel ( i , 10 ) ;
11019: LD_VAR 0 2
11023: PPUSH
11024: LD_INT 10
11026: PPUSH
11027: CALL_OW 241
11031: GO 11016
11033: POP
11034: POP
// base := GetBase ( al_depot ) ;
11035: LD_ADDR_VAR 0 4
11039: PUSH
11040: LD_INT 2
11042: PPUSH
11043: CALL_OW 274
11047: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11048: LD_ADDR_VAR 0 6
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_VAR 0 5
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: PUSH
11065: LD_INT 30
11067: PUSH
11068: LD_INT 34
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: PPUSH
11079: CALL_OW 69
11083: ST_TO_ADDR
// if teleport then
11084: LD_VAR 0 6
11088: IFFALSE 11109
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11090: LD_VAR 0 6
11094: PUSH
11095: LD_INT 1
11097: ARRAY
11098: PPUSH
11099: LD_INT 262
11101: PPUSH
11102: LD_INT 119
11104: PPUSH
11105: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11109: LD_VAR 0 4
11113: PPUSH
11114: LD_INT 1
11116: PPUSH
11117: LD_INT 19500
11119: PPUSH
11120: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11124: LD_VAR 0 4
11128: PPUSH
11129: LD_INT 2
11131: PPUSH
11132: LD_INT 200
11134: PPUSH
11135: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11139: LD_VAR 0 4
11143: PPUSH
11144: LD_INT 3
11146: PPUSH
11147: LD_INT 650
11149: PPUSH
11150: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11154: LD_ADDR_EXP 74
11158: PUSH
11159: LD_STRING Roth
11161: PPUSH
11162: CALL_OW 25
11166: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11167: LD_ADDR_EXP 75
11171: PUSH
11172: LD_STRING Simms
11174: PPUSH
11175: LD_EXP 1
11179: NOT
11180: PPUSH
11181: LD_STRING 10c_
11183: PPUSH
11184: CALL 64778 0 3
11188: ST_TO_ADDR
// if not Simms then
11189: LD_EXP 75
11193: NOT
11194: IFFALSE 11224
// begin uc_nation := 1 ;
11196: LD_ADDR_OWVAR 21
11200: PUSH
11201: LD_INT 1
11203: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11204: LD_INT 2
11206: PPUSH
11207: LD_INT 10
11209: PPUSH
11210: CALL_OW 384
// Simms := CreateHuman ;
11214: LD_ADDR_EXP 75
11218: PUSH
11219: CALL_OW 44
11223: ST_TO_ADDR
// end ; uc_nation := 3 ;
11224: LD_ADDR_OWVAR 21
11228: PUSH
11229: LD_INT 3
11231: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11232: LD_ADDR_EXP 76
11236: PUSH
11237: LD_STRING Kirilenkova
11239: PPUSH
11240: CALL_OW 25
11244: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11245: LD_ADDR_EXP 90
11249: PUSH
11250: LD_STRING Oblukov
11252: PPUSH
11253: CALL_OW 25
11257: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11258: LD_ADDR_EXP 77
11262: PUSH
11263: LD_STRING Dolgov
11265: PPUSH
11266: CALL_OW 25
11270: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11271: LD_ADDR_EXP 78
11275: PUSH
11276: LD_STRING Petrosyan
11278: PPUSH
11279: CALL_OW 25
11283: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11284: LD_ADDR_EXP 89
11288: PUSH
11289: LD_STRING Scholtze
11291: PPUSH
11292: CALL_OW 25
11296: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11297: LD_ADDR_EXP 88
11301: PUSH
11302: LD_STRING Kapitsova
11304: PPUSH
11305: CALL_OW 25
11309: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11310: LD_ADDR_EXP 79
11314: PUSH
11315: LD_STRING Petrovova
11317: PPUSH
11318: CALL_OW 25
11322: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11323: LD_ADDR_EXP 80
11327: PUSH
11328: LD_STRING Kuzmov
11330: PPUSH
11331: CALL_OW 25
11335: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11336: LD_ADDR_EXP 87
11340: PUSH
11341: LD_STRING Karamazov
11343: PPUSH
11344: CALL_OW 25
11348: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11349: LD_STRING 13_Lipshchin_1
11351: PPUSH
11352: LD_INT 0
11354: PPUSH
11355: CALL_OW 30
11359: IFFALSE 11374
// Lipshchin := NewCharacter ( Lipshchin ) ;
11361: LD_ADDR_EXP 81
11365: PUSH
11366: LD_STRING Lipshchin
11368: PPUSH
11369: CALL_OW 25
11373: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11374: LD_STRING 13_Titov_1
11376: PPUSH
11377: LD_INT 0
11379: PPUSH
11380: CALL_OW 30
11384: IFFALSE 11399
// Titov := NewCharacter ( Titov ) ;
11386: LD_ADDR_EXP 83
11390: PUSH
11391: LD_STRING Titov
11393: PPUSH
11394: CALL_OW 25
11398: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11399: LD_STRING 13_Gnyevko_1
11401: PPUSH
11402: LD_INT 0
11404: PPUSH
11405: CALL_OW 30
11409: IFFALSE 11424
// Gnyevko := NewCharacter ( Gnyevko ) ;
11411: LD_ADDR_EXP 82
11415: PUSH
11416: LD_STRING Gnyevko
11418: PPUSH
11419: CALL_OW 25
11423: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11424: LD_STRING 13_Xavier_1
11426: PPUSH
11427: LD_INT 0
11429: PPUSH
11430: CALL_OW 30
11434: IFFALSE 11449
// Xavier := NewCharacter ( Xavier2 ) ;
11436: LD_ADDR_EXP 84
11440: PUSH
11441: LD_STRING Xavier2
11443: PPUSH
11444: CALL_OW 25
11448: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11449: LD_STRING 13_Belkov_1
11451: PPUSH
11452: LD_INT 0
11454: PPUSH
11455: CALL_OW 30
11459: IFFALSE 11474
// Belkov := NewCharacter ( Belkov ) ;
11461: LD_ADDR_EXP 85
11465: PUSH
11466: LD_STRING Belkov
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// if not BurlakStatus then
11474: LD_EXP 9
11478: NOT
11479: IFFALSE 11494
// Burlak = NewCharacter ( Burlak ) ;
11481: LD_ADDR_EXP 86
11485: PUSH
11486: LD_STRING Burlak
11488: PPUSH
11489: CALL_OW 25
11493: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11494: LD_ADDR_VAR 0 3
11498: PUSH
11499: LD_EXP 74
11503: PUSH
11504: LD_EXP 76
11508: PUSH
11509: LD_EXP 90
11513: PUSH
11514: LD_EXP 77
11518: PUSH
11519: LD_EXP 78
11523: PUSH
11524: LD_EXP 89
11528: PUSH
11529: LD_EXP 88
11533: PUSH
11534: LD_EXP 79
11538: PUSH
11539: LD_EXP 80
11543: PUSH
11544: LD_EXP 87
11548: PUSH
11549: EMPTY
11550: LIST
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: LIST
11556: LIST
11557: LIST
11558: LIST
11559: LIST
11560: ST_TO_ADDR
// if Simms then
11561: LD_EXP 75
11565: IFFALSE 11583
// tmp := tmp ^ Simms ;
11567: LD_ADDR_VAR 0 3
11571: PUSH
11572: LD_VAR 0 3
11576: PUSH
11577: LD_EXP 75
11581: ADD
11582: ST_TO_ADDR
// if Titov then
11583: LD_EXP 83
11587: IFFALSE 11605
// tmp := tmp ^ Titov ;
11589: LD_ADDR_VAR 0 3
11593: PUSH
11594: LD_VAR 0 3
11598: PUSH
11599: LD_EXP 83
11603: ADD
11604: ST_TO_ADDR
// if Lipshchin then
11605: LD_EXP 81
11609: IFFALSE 11627
// tmp := tmp ^ Lipshchin ;
11611: LD_ADDR_VAR 0 3
11615: PUSH
11616: LD_VAR 0 3
11620: PUSH
11621: LD_EXP 81
11625: ADD
11626: ST_TO_ADDR
// if Gnyevko then
11627: LD_EXP 82
11631: IFFALSE 11649
// tmp := tmp ^ Gnyevko ;
11633: LD_ADDR_VAR 0 3
11637: PUSH
11638: LD_VAR 0 3
11642: PUSH
11643: LD_EXP 82
11647: ADD
11648: ST_TO_ADDR
// if Xavier then
11649: LD_EXP 84
11653: IFFALSE 11671
// tmp := tmp ^ Xavier ;
11655: LD_ADDR_VAR 0 3
11659: PUSH
11660: LD_VAR 0 3
11664: PUSH
11665: LD_EXP 84
11669: ADD
11670: ST_TO_ADDR
// if Belkov then
11671: LD_EXP 85
11675: IFFALSE 11693
// tmp := tmp ^ Belkov ;
11677: LD_ADDR_VAR 0 3
11681: PUSH
11682: LD_VAR 0 3
11686: PUSH
11687: LD_EXP 85
11691: ADD
11692: ST_TO_ADDR
// if Burlak then
11693: LD_EXP 86
11697: IFFALSE 11715
// tmp := tmp ^ Burlak ;
11699: LD_ADDR_VAR 0 3
11703: PUSH
11704: LD_VAR 0 3
11708: PUSH
11709: LD_EXP 86
11713: ADD
11714: ST_TO_ADDR
// for i = 1 to 11 do
11715: LD_ADDR_VAR 0 2
11719: PUSH
11720: DOUBLE
11721: LD_INT 1
11723: DEC
11724: ST_TO_ADDR
11725: LD_INT 11
11727: PUSH
11728: FOR_TO
11729: IFFALSE 11795
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11731: LD_ADDR_OWVAR 21
11735: PUSH
11736: LD_INT 1
11738: PUSH
11739: LD_INT 3
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: PUSH
11746: LD_INT 1
11748: PPUSH
11749: LD_INT 2
11751: PPUSH
11752: CALL_OW 12
11756: ARRAY
11757: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11758: LD_INT 0
11760: PPUSH
11761: LD_VAR 0 2
11765: PUSH
11766: LD_INT 2
11768: DIV
11769: PPUSH
11770: LD_INT 10
11772: PPUSH
11773: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11777: LD_ADDR_VAR 0 3
11781: PUSH
11782: LD_VAR 0 3
11786: PUSH
11787: CALL_OW 44
11791: ADD
11792: ST_TO_ADDR
// end ;
11793: GO 11728
11795: POP
11796: POP
// for i in tmp do
11797: LD_ADDR_VAR 0 2
11801: PUSH
11802: LD_VAR 0 3
11806: PUSH
11807: FOR_IN
11808: IFFALSE 11833
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11810: LD_VAR 0 2
11814: PPUSH
11815: LD_INT 260
11817: PPUSH
11818: LD_INT 235
11820: PPUSH
11821: LD_INT 8
11823: PPUSH
11824: LD_INT 0
11826: PPUSH
11827: CALL_OW 50
11831: GO 11807
11833: POP
11834: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11835: LD_ADDR_EXP 102
11839: PUSH
11840: LD_EXP 102
11844: PPUSH
11845: LD_INT 1
11847: PPUSH
11848: LD_INT 22
11850: PUSH
11851: LD_VAR 0 5
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 3
11862: PUSH
11863: LD_INT 21
11865: PUSH
11866: LD_INT 2
11868: PUSH
11869: EMPTY
11870: LIST
11871: LIST
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: PPUSH
11881: CALL_OW 69
11885: PUSH
11886: LD_EXP 74
11890: PUSH
11891: LD_EXP 75
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: DIFF
11900: PPUSH
11901: CALL_OW 1
11905: ST_TO_ADDR
// uc_side := 0 ;
11906: LD_ADDR_OWVAR 20
11910: PUSH
11911: LD_INT 0
11913: ST_TO_ADDR
// uc_nation := 0 ;
11914: LD_ADDR_OWVAR 21
11918: PUSH
11919: LD_INT 0
11921: ST_TO_ADDR
// for i = 1 to 5 do
11922: LD_ADDR_VAR 0 2
11926: PUSH
11927: DOUBLE
11928: LD_INT 1
11930: DEC
11931: ST_TO_ADDR
11932: LD_INT 5
11934: PUSH
11935: FOR_TO
11936: IFFALSE 11973
// begin InitHc ;
11938: CALL_OW 19
// hc_class := class_apeman ;
11942: LD_ADDR_OWVAR 28
11946: PUSH
11947: LD_INT 12
11949: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11950: CALL_OW 44
11954: PPUSH
11955: LD_INT 299
11957: PPUSH
11958: LD_INT 229
11960: PPUSH
11961: LD_INT 10
11963: PPUSH
11964: LD_INT 0
11966: PPUSH
11967: CALL_OW 50
// end ;
11971: GO 11935
11973: POP
11974: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11975: LD_EXP 74
11979: PPUSH
11980: LD_INT 259
11982: PPUSH
11983: LD_INT 235
11985: PPUSH
11986: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11990: LD_EXP 74
11994: PPUSH
11995: LD_INT 262
11997: PPUSH
11998: LD_INT 235
12000: PPUSH
12001: CALL_OW 178
// if Simms then
12005: LD_EXP 75
12009: IFFALSE 12040
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12011: LD_EXP 75
12015: PPUSH
12016: LD_INT 262
12018: PPUSH
12019: LD_INT 235
12021: PPUSH
12022: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12026: LD_EXP 75
12030: PPUSH
12031: LD_EXP 74
12035: PPUSH
12036: CALL_OW 179
// end ; end ;
12040: LD_VAR 0 1
12044: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12045: LD_EXP 31
12049: PUSH
12050: LD_EXP 23
12054: NOT
12055: AND
12056: IFFALSE 12232
12058: GO 12060
12060: DISABLE
12061: LD_INT 0
12063: PPUSH
12064: PPUSH
12065: PPUSH
// begin enable ;
12066: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12067: LD_ADDR_VAR 0 2
12071: PUSH
12072: LD_INT 81
12074: PUSH
12075: LD_INT 7
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: LD_INT 2
12084: PUSH
12085: LD_INT 32
12087: PUSH
12088: LD_INT 3
12090: PUSH
12091: EMPTY
12092: LIST
12093: LIST
12094: PUSH
12095: LD_INT 30
12097: PUSH
12098: LD_INT 30
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: LD_INT 30
12107: PUSH
12108: LD_INT 28
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: PUSH
12115: LD_INT 34
12117: PUSH
12118: LD_INT 49
12120: PUSH
12121: EMPTY
12122: LIST
12123: LIST
12124: PUSH
12125: LD_INT 34
12127: PUSH
12128: LD_INT 10
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: PUSH
12135: LD_INT 34
12137: PUSH
12138: LD_INT 8
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: PUSH
12145: EMPTY
12146: LIST
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: LIST
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: PPUSH
12158: CALL_OW 69
12162: ST_TO_ADDR
// if not tmp then
12163: LD_VAR 0 2
12167: NOT
12168: IFFALSE 12172
// exit ;
12170: GO 12232
// target := tmp [ rand ( 1 , tmp ) ] ;
12172: LD_ADDR_VAR 0 3
12176: PUSH
12177: LD_VAR 0 2
12181: PUSH
12182: LD_INT 1
12184: PPUSH
12185: LD_VAR 0 2
12189: PPUSH
12190: CALL_OW 12
12194: ARRAY
12195: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12196: LD_VAR 0 3
12200: PPUSH
12201: CALL_OW 255
12205: PUSH
12206: LD_INT 1
12208: EQUAL
12209: IFFALSE 12220
// CenterNowOnUnits ( target ) ;
12211: LD_VAR 0 3
12215: PPUSH
12216: CALL_OW 87
// SetLives ( target , 0 ) ;
12220: LD_VAR 0 3
12224: PPUSH
12225: LD_INT 0
12227: PPUSH
12228: CALL_OW 234
// end ;
12232: PPOPN 3
12234: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12235: LD_EXP 23
12239: NOT
12240: PUSH
12241: LD_EXP 31
12245: AND
12246: IFFALSE 12768
12248: GO 12250
12250: DISABLE
12251: LD_INT 0
12253: PPUSH
12254: PPUSH
12255: PPUSH
// begin uc_side := 7 ;
12256: LD_ADDR_OWVAR 20
12260: PUSH
12261: LD_INT 7
12263: ST_TO_ADDR
// uc_nation := 1 ;
12264: LD_ADDR_OWVAR 21
12268: PUSH
12269: LD_INT 1
12271: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12272: LD_ADDR_VAR 0 3
12276: PUSH
12277: LD_INT 125
12279: PUSH
12280: LD_INT 163
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: LD_INT 185
12289: PUSH
12290: LD_INT 168
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: PUSH
12297: LD_INT 111
12299: PUSH
12300: LD_INT 97
12302: PUSH
12303: EMPTY
12304: LIST
12305: LIST
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: LIST
12311: PPUSH
12312: CALL 107740 0 1
12316: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12317: LD_ADDR_EXP 91
12321: PUSH
12322: EMPTY
12323: ST_TO_ADDR
// for i = 1 to Difficulty do
12324: LD_ADDR_VAR 0 1
12328: PUSH
12329: DOUBLE
12330: LD_INT 1
12332: DEC
12333: ST_TO_ADDR
12334: LD_OWVAR 67
12338: PUSH
12339: FOR_TO
12340: IFFALSE 12498
// begin InitHc ;
12342: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12346: LD_INT 0
12348: PPUSH
12349: LD_INT 8
12351: PPUSH
12352: CALL_OW 381
// un := CreateHuman ;
12356: LD_ADDR_VAR 0 2
12360: PUSH
12361: CALL_OW 44
12365: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12366: LD_VAR 0 2
12370: PPUSH
12371: LD_INT 258
12373: PPUSH
12374: LD_INT 267
12376: PPUSH
12377: LD_INT 4
12379: PPUSH
12380: LD_INT 0
12382: PPUSH
12383: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12387: LD_ADDR_EXP 91
12391: PUSH
12392: LD_EXP 91
12396: PUSH
12397: LD_VAR 0 2
12401: UNION
12402: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12403: LD_VAR 0 2
12407: PPUSH
12408: LD_VAR 0 3
12412: PUSH
12413: LD_VAR 0 1
12417: ARRAY
12418: PUSH
12419: LD_INT 1
12421: ARRAY
12422: PPUSH
12423: LD_VAR 0 3
12427: PUSH
12428: LD_VAR 0 1
12432: ARRAY
12433: PUSH
12434: LD_INT 2
12436: ARRAY
12437: PPUSH
12438: LD_INT 4
12440: PPUSH
12441: LD_INT 1
12443: PPUSH
12444: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12448: LD_VAR 0 2
12452: PPUSH
12453: LD_VAR 0 3
12457: PUSH
12458: LD_VAR 0 1
12462: ARRAY
12463: PUSH
12464: LD_INT 1
12466: ARRAY
12467: PPUSH
12468: LD_VAR 0 3
12472: PUSH
12473: LD_VAR 0 1
12477: ARRAY
12478: PUSH
12479: LD_INT 2
12481: ARRAY
12482: PPUSH
12483: CALL_OW 171
// AddComInvisible ( un ) ;
12487: LD_VAR 0 2
12491: PPUSH
12492: CALL_OW 212
// end ;
12496: GO 12339
12498: POP
12499: POP
// repeat wait ( 0 0$20 ) ;
12500: LD_INT 700
12502: PPUSH
12503: CALL_OW 67
// for i in allianceSpecialForce do
12507: LD_ADDR_VAR 0 1
12511: PUSH
12512: LD_EXP 91
12516: PUSH
12517: FOR_IN
12518: IFFALSE 12753
// begin if IsInvisible ( i ) then
12520: LD_VAR 0 1
12524: PPUSH
12525: CALL_OW 571
12529: IFFALSE 12722
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12531: LD_ADDR_VAR 0 3
12535: PUSH
12536: LD_INT 22
12538: PUSH
12539: LD_INT 1
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PUSH
12546: LD_INT 50
12548: PUSH
12549: EMPTY
12550: LIST
12551: PUSH
12552: LD_INT 56
12554: PUSH
12555: EMPTY
12556: LIST
12557: PUSH
12558: LD_INT 91
12560: PUSH
12561: LD_VAR 0 1
12565: PUSH
12566: LD_INT 25
12568: PUSH
12569: LD_INT 30
12571: PUSH
12572: LD_INT 35
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: LIST
12579: PUSH
12580: LD_OWVAR 67
12584: ARRAY
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: LIST
12590: PUSH
12591: LD_INT 2
12593: PUSH
12594: LD_INT 25
12596: PUSH
12597: LD_INT 1
12599: PUSH
12600: EMPTY
12601: LIST
12602: LIST
12603: PUSH
12604: LD_INT 25
12606: PUSH
12607: LD_INT 2
12609: PUSH
12610: EMPTY
12611: LIST
12612: LIST
12613: PUSH
12614: LD_INT 25
12616: PUSH
12617: LD_INT 3
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PUSH
12624: LD_INT 25
12626: PUSH
12627: LD_INT 4
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PUSH
12634: LD_INT 25
12636: PUSH
12637: LD_INT 5
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: LD_INT 25
12646: PUSH
12647: LD_INT 8
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: LIST
12661: LIST
12662: PUSH
12663: EMPTY
12664: LIST
12665: LIST
12666: LIST
12667: LIST
12668: LIST
12669: PPUSH
12670: CALL_OW 69
12674: ST_TO_ADDR
// if not tmp then
12675: LD_VAR 0 3
12679: NOT
12680: IFFALSE 12684
// continue ;
12682: GO 12517
// if Prob ( 30 * Difficulty ) then
12684: LD_INT 30
12686: PUSH
12687: LD_OWVAR 67
12691: MUL
12692: PPUSH
12693: CALL_OW 13
12697: IFFALSE 12722
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12699: LD_VAR 0 3
12703: PUSH
12704: LD_INT 1
12706: PPUSH
12707: LD_VAR 0 3
12711: PPUSH
12712: CALL_OW 12
12716: ARRAY
12717: PPUSH
12718: CALL 30884 0 1
// end ; if IsDead ( i ) then
12722: LD_VAR 0 1
12726: PPUSH
12727: CALL_OW 301
12731: IFFALSE 12751
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12733: LD_ADDR_EXP 91
12737: PUSH
12738: LD_EXP 91
12742: PUSH
12743: LD_VAR 0 1
12747: DIFF
12748: ST_TO_ADDR
// continue ;
12749: GO 12517
// end ; end ;
12751: GO 12517
12753: POP
12754: POP
// until allianceDestroyed or not allianceSpecialForce ;
12755: LD_EXP 23
12759: PUSH
12760: LD_EXP 91
12764: NOT
12765: OR
12766: IFFALSE 12500
// end ;
12768: PPOPN 3
12770: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12771: LD_EXP 23
12775: NOT
12776: PUSH
12777: LD_EXP 31
12781: AND
12782: IFFALSE 13749
12784: GO 12786
12786: DISABLE
12787: LD_INT 0
12789: PPUSH
12790: PPUSH
12791: PPUSH
12792: PPUSH
// begin enable ;
12793: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12794: LD_INT 22
12796: PUSH
12797: LD_INT 7
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 30
12806: PUSH
12807: LD_INT 3
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: PPUSH
12818: CALL_OW 69
12822: NOT
12823: IFFALSE 12827
// exit ;
12825: GO 13749
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12827: LD_ADDR_VAR 0 4
12831: PUSH
12832: LD_INT 22
12834: PUSH
12835: LD_INT 7
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: PUSH
12842: LD_INT 30
12844: PUSH
12845: LD_INT 34
12847: PUSH
12848: EMPTY
12849: LIST
12850: LIST
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PPUSH
12856: CALL_OW 69
12860: ST_TO_ADDR
// if Prob ( 40 ) then
12861: LD_INT 40
12863: PPUSH
12864: CALL_OW 13
12868: IFFALSE 12995
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12870: LD_INT 1
12872: PPUSH
12873: LD_INT 5
12875: PUSH
12876: LD_INT 3
12878: PUSH
12879: LD_INT 2
12881: PUSH
12882: LD_INT 6
12884: PUSH
12885: EMPTY
12886: LIST
12887: LIST
12888: LIST
12889: LIST
12890: PUSH
12891: LD_INT 5
12893: PUSH
12894: LD_INT 3
12896: PUSH
12897: LD_INT 2
12899: PUSH
12900: LD_INT 6
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: LIST
12907: LIST
12908: PUSH
12909: LD_INT 5
12911: PUSH
12912: LD_INT 3
12914: PUSH
12915: LD_INT 2
12917: PUSH
12918: LD_INT 6
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: LIST
12925: LIST
12926: PUSH
12927: LD_INT 24
12929: PUSH
12930: LD_INT 3
12932: PUSH
12933: LD_INT 3
12935: PUSH
12936: LD_INT 45
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: LIST
12943: LIST
12944: PUSH
12945: LD_INT 24
12947: PUSH
12948: LD_INT 3
12950: PUSH
12951: LD_INT 3
12953: PUSH
12954: LD_INT 47
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: PUSH
12963: LD_INT 24
12965: PUSH
12966: LD_INT 3
12968: PUSH
12969: LD_INT 3
12971: PUSH
12972: LD_INT 45
12974: PUSH
12975: EMPTY
12976: LIST
12977: LIST
12978: LIST
12979: LIST
12980: PUSH
12981: EMPTY
12982: LIST
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: PPUSH
12989: CALL 58434 0 2
// end else
12993: GO 13118
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12995: LD_INT 1
12997: PPUSH
12998: LD_INT 24
13000: PUSH
13001: LD_INT 3
13003: PUSH
13004: LD_INT 3
13006: PUSH
13007: LD_INT 47
13009: PUSH
13010: EMPTY
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: PUSH
13016: LD_INT 24
13018: PUSH
13019: LD_INT 3
13021: PUSH
13022: LD_INT 3
13024: PUSH
13025: LD_INT 47
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: PUSH
13034: LD_INT 5
13036: PUSH
13037: LD_INT 3
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 9
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: LIST
13050: LIST
13051: PUSH
13052: LD_INT 5
13054: PUSH
13055: LD_INT 3
13057: PUSH
13058: LD_INT 2
13060: PUSH
13061: LD_INT 9
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: PUSH
13070: LD_INT 24
13072: PUSH
13073: LD_INT 1
13075: PUSH
13076: LD_INT 3
13078: PUSH
13079: LD_INT 45
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: PUSH
13088: LD_INT 24
13090: PUSH
13091: LD_INT 1
13093: PUSH
13094: LD_INT 3
13096: PUSH
13097: LD_INT 45
13099: PUSH
13100: EMPTY
13101: LIST
13102: LIST
13103: LIST
13104: LIST
13105: PUSH
13106: EMPTY
13107: LIST
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PPUSH
13114: CALL 58434 0 2
// end ; if Difficulty > 1 then
13118: LD_OWVAR 67
13122: PUSH
13123: LD_INT 1
13125: GREATER
13126: IFFALSE 13156
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13128: LD_INT 1
13130: PPUSH
13131: LD_INT 24
13133: PUSH
13134: LD_INT 3
13136: PUSH
13137: LD_INT 3
13139: PUSH
13140: LD_INT 47
13142: PUSH
13143: EMPTY
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: PUSH
13149: EMPTY
13150: LIST
13151: PPUSH
13152: CALL 58434 0 2
// repeat wait ( 0 0$1 ) ;
13156: LD_INT 35
13158: PPUSH
13159: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13163: LD_INT 1
13165: PPUSH
13166: LD_INT 1
13168: PPUSH
13169: CALL 59852 0 2
13173: PUSH
13174: LD_INT 6
13176: PUSH
13177: LD_INT 7
13179: PUSH
13180: LD_INT 7
13182: PUSH
13183: EMPTY
13184: LIST
13185: LIST
13186: LIST
13187: PUSH
13188: LD_OWVAR 67
13192: ARRAY
13193: GREATEREQUAL
13194: IFFALSE 13156
// wait ( 0 0$40 ) ;
13196: LD_INT 1400
13198: PPUSH
13199: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13203: LD_ADDR_VAR 0 2
13207: PUSH
13208: LD_INT 1
13210: PPUSH
13211: LD_INT 1
13213: PPUSH
13214: CALL 59852 0 2
13218: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13219: LD_ADDR_EXP 121
13223: PUSH
13224: LD_EXP 121
13228: PPUSH
13229: LD_INT 1
13231: PPUSH
13232: LD_EXP 121
13236: PUSH
13237: LD_INT 1
13239: ARRAY
13240: PUSH
13241: LD_VAR 0 2
13245: DIFF
13246: PPUSH
13247: CALL_OW 1
13251: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13252: LD_ADDR_VAR 0 3
13256: PUSH
13257: LD_INT 0
13259: PPUSH
13260: LD_INT 1
13262: PPUSH
13263: CALL_OW 12
13267: ST_TO_ADDR
// if target then
13268: LD_VAR 0 3
13272: IFFALSE 13438
// begin for i in tmp do
13274: LD_ADDR_VAR 0 1
13278: PUSH
13279: LD_VAR 0 2
13283: PUSH
13284: FOR_IN
13285: IFFALSE 13310
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13287: LD_VAR 0 1
13291: PPUSH
13292: LD_INT 179
13294: PPUSH
13295: LD_INT 209
13297: PPUSH
13298: LD_INT 8
13300: PPUSH
13301: LD_INT 1
13303: PPUSH
13304: CALL_OW 483
13308: GO 13284
13310: POP
13311: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13312: LD_ADDR_VAR 0 2
13316: PUSH
13317: LD_VAR 0 2
13321: PPUSH
13322: LD_INT 24
13324: PUSH
13325: LD_INT 250
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PPUSH
13332: CALL_OW 72
13336: ST_TO_ADDR
// for i in tmp do
13337: LD_ADDR_VAR 0 1
13341: PUSH
13342: LD_VAR 0 2
13346: PUSH
13347: FOR_IN
13348: IFFALSE 13388
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13350: LD_VAR 0 1
13354: PPUSH
13355: LD_INT 179
13357: PPUSH
13358: LD_INT 209
13360: PPUSH
13361: CALL_OW 297
13365: PUSH
13366: LD_INT 9
13368: GREATER
13369: IFFALSE 13386
// ComMoveXY ( i , 179 , 209 ) ;
13371: LD_VAR 0 1
13375: PPUSH
13376: LD_INT 179
13378: PPUSH
13379: LD_INT 209
13381: PPUSH
13382: CALL_OW 111
13386: GO 13347
13388: POP
13389: POP
// wait ( 0 0$1 ) ;
13390: LD_INT 35
13392: PPUSH
13393: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13397: LD_VAR 0 2
13401: PPUSH
13402: LD_INT 92
13404: PUSH
13405: LD_INT 179
13407: PUSH
13408: LD_INT 209
13410: PUSH
13411: LD_INT 9
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: PPUSH
13420: CALL_OW 72
13424: PUSH
13425: LD_VAR 0 2
13429: PUSH
13430: LD_INT 1
13432: MINUS
13433: GREATEREQUAL
13434: IFFALSE 13312
// end else
13436: GO 13600
// begin for i in tmp do
13438: LD_ADDR_VAR 0 1
13442: PUSH
13443: LD_VAR 0 2
13447: PUSH
13448: FOR_IN
13449: IFFALSE 13474
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13451: LD_VAR 0 1
13455: PPUSH
13456: LD_INT 285
13458: PPUSH
13459: LD_INT 163
13461: PPUSH
13462: LD_INT 8
13464: PPUSH
13465: LD_INT 1
13467: PPUSH
13468: CALL_OW 483
13472: GO 13448
13474: POP
13475: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13476: LD_ADDR_VAR 0 2
13480: PUSH
13481: LD_VAR 0 2
13485: PPUSH
13486: LD_INT 24
13488: PUSH
13489: LD_INT 250
13491: PUSH
13492: EMPTY
13493: LIST
13494: LIST
13495: PPUSH
13496: CALL_OW 72
13500: ST_TO_ADDR
// for i in tmp do
13501: LD_ADDR_VAR 0 1
13505: PUSH
13506: LD_VAR 0 2
13510: PUSH
13511: FOR_IN
13512: IFFALSE 13552
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13514: LD_VAR 0 1
13518: PPUSH
13519: LD_INT 285
13521: PPUSH
13522: LD_INT 163
13524: PPUSH
13525: CALL_OW 297
13529: PUSH
13530: LD_INT 9
13532: GREATER
13533: IFFALSE 13550
// ComMoveXY ( i , 285 , 163 ) ;
13535: LD_VAR 0 1
13539: PPUSH
13540: LD_INT 285
13542: PPUSH
13543: LD_INT 163
13545: PPUSH
13546: CALL_OW 111
13550: GO 13511
13552: POP
13553: POP
// wait ( 0 0$1 ) ;
13554: LD_INT 35
13556: PPUSH
13557: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13561: LD_VAR 0 2
13565: PPUSH
13566: LD_INT 92
13568: PUSH
13569: LD_INT 285
13571: PUSH
13572: LD_INT 163
13574: PUSH
13575: LD_INT 9
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: PPUSH
13584: CALL_OW 72
13588: PUSH
13589: LD_VAR 0 2
13593: PUSH
13594: LD_INT 1
13596: MINUS
13597: GREATEREQUAL
13598: IFFALSE 13476
// end ; repeat wait ( 0 0$1 ) ;
13600: LD_INT 35
13602: PPUSH
13603: CALL_OW 67
// for i in tmp do
13607: LD_ADDR_VAR 0 1
13611: PUSH
13612: LD_VAR 0 2
13616: PUSH
13617: FOR_IN
13618: IFFALSE 13740
// if GetLives ( i ) > 251 then
13620: LD_VAR 0 1
13624: PPUSH
13625: CALL_OW 256
13629: PUSH
13630: LD_INT 251
13632: GREATER
13633: IFFALSE 13722
// begin if GetWeapon ( i ) = ru_time_lapser then
13635: LD_VAR 0 1
13639: PPUSH
13640: CALL_OW 264
13644: PUSH
13645: LD_INT 49
13647: EQUAL
13648: IFFALSE 13686
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13650: LD_VAR 0 1
13654: PPUSH
13655: LD_INT 81
13657: PUSH
13658: LD_INT 7
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: PPUSH
13665: CALL_OW 69
13669: PPUSH
13670: LD_VAR 0 1
13674: PPUSH
13675: CALL_OW 74
13679: PPUSH
13680: CALL_OW 112
13684: GO 13720
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 81
13693: PUSH
13694: LD_INT 7
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: PPUSH
13701: CALL_OW 69
13705: PPUSH
13706: LD_VAR 0 1
13710: PPUSH
13711: CALL_OW 74
13715: PPUSH
13716: CALL_OW 115
// end else
13720: GO 13738
// tmp := tmp diff i ;
13722: LD_ADDR_VAR 0 2
13726: PUSH
13727: LD_VAR 0 2
13731: PUSH
13732: LD_VAR 0 1
13736: DIFF
13737: ST_TO_ADDR
13738: GO 13617
13740: POP
13741: POP
// until not tmp ;
13742: LD_VAR 0 2
13746: NOT
13747: IFFALSE 13600
// end ; end_of_file
13749: PPOPN 4
13751: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13752: LD_INT 0
13754: PPUSH
13755: PPUSH
13756: PPUSH
13757: PPUSH
// missionStage := 13 ;
13758: LD_ADDR_EXP 15
13762: PUSH
13763: LD_INT 13
13765: ST_TO_ADDR
// uc_side := 2 ;
13766: LD_ADDR_OWVAR 20
13770: PUSH
13771: LD_INT 2
13773: ST_TO_ADDR
// uc_nation := 2 ;
13774: LD_ADDR_OWVAR 21
13778: PUSH
13779: LD_INT 2
13781: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13782: LD_ADDR_EXP 92
13786: PUSH
13787: LD_STRING Omar
13789: PPUSH
13790: CALL_OW 25
13794: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13795: LD_EXP 92
13799: PPUSH
13800: LD_INT 4
13802: PPUSH
13803: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13807: LD_EXP 92
13811: PPUSH
13812: LD_INT 242
13814: PPUSH
13815: LD_INT 75
13817: PPUSH
13818: LD_INT 0
13820: PPUSH
13821: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13825: LD_ADDR_EXP 93
13829: PUSH
13830: LD_STRING Heike
13832: PPUSH
13833: CALL_OW 25
13837: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13838: LD_INT 14
13840: PPUSH
13841: LD_INT 3
13843: PPUSH
13844: LD_INT 1
13846: PPUSH
13847: LD_INT 27
13849: PPUSH
13850: LD_INT 100
13852: PPUSH
13853: CALL 71893 0 5
// veh := CreateVehicle ;
13857: LD_ADDR_VAR 0 3
13861: PUSH
13862: CALL_OW 45
13866: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13867: LD_VAR 0 3
13871: PPUSH
13872: LD_INT 1
13874: PPUSH
13875: CALL_OW 242
// SetDir ( veh , 4 ) ;
13879: LD_VAR 0 3
13883: PPUSH
13884: LD_INT 4
13886: PPUSH
13887: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13891: LD_VAR 0 3
13895: PPUSH
13896: LD_INT 241
13898: PPUSH
13899: LD_INT 72
13901: PPUSH
13902: LD_INT 0
13904: PPUSH
13905: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13909: LD_EXP 93
13913: PPUSH
13914: LD_VAR 0 3
13918: PPUSH
13919: CALL_OW 52
// if KhatamStatus then
13923: LD_EXP 8
13927: IFFALSE 13978
// begin Khatam := NewCharacter ( Khatam ) ;
13929: LD_ADDR_EXP 94
13933: PUSH
13934: LD_STRING Khatam
13936: PPUSH
13937: CALL_OW 25
13941: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13942: LD_EXP 94
13946: PPUSH
13947: LD_INT 245
13949: PPUSH
13950: LD_INT 78
13952: PPUSH
13953: LD_INT 3
13955: PPUSH
13956: LD_INT 0
13958: PPUSH
13959: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13963: LD_EXP 94
13967: PPUSH
13968: LD_INT 4
13970: PPUSH
13971: LD_INT 10
13973: PPUSH
13974: CALL_OW 237
// end ; for i = 1 to Difficulty do
13978: LD_ADDR_VAR 0 2
13982: PUSH
13983: DOUBLE
13984: LD_INT 1
13986: DEC
13987: ST_TO_ADDR
13988: LD_OWVAR 67
13992: PUSH
13993: FOR_TO
13994: IFFALSE 14060
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13996: LD_INT 0
13998: PPUSH
13999: LD_INT 7
14001: PUSH
14002: LD_OWVAR 67
14006: PLUS
14007: PPUSH
14008: CALL_OW 384
// un := CreateHuman ;
14012: LD_ADDR_VAR 0 4
14016: PUSH
14017: CALL_OW 44
14021: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14022: LD_VAR 0 4
14026: PPUSH
14027: LD_INT 28
14029: PUSH
14030: LD_INT 29
14032: PUSH
14033: EMPTY
14034: LIST
14035: LIST
14036: PUSH
14037: LD_VAR 0 2
14041: PUSH
14042: LD_INT 2
14044: MOD
14045: PUSH
14046: LD_INT 1
14048: PLUS
14049: ARRAY
14050: PPUSH
14051: LD_INT 0
14053: PPUSH
14054: CALL_OW 49
// end ;
14058: GO 13993
14060: POP
14061: POP
// for i = 1 to 6 do
14062: LD_ADDR_VAR 0 2
14066: PUSH
14067: DOUBLE
14068: LD_INT 1
14070: DEC
14071: ST_TO_ADDR
14072: LD_INT 6
14074: PUSH
14075: FOR_TO
14076: IFFALSE 14121
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14078: LD_INT 0
14080: PPUSH
14081: LD_INT 7
14083: PUSH
14084: LD_OWVAR 67
14088: PLUS
14089: PPUSH
14090: CALL_OW 381
// un := CreateHuman ;
14094: LD_ADDR_VAR 0 4
14098: PUSH
14099: CALL_OW 44
14103: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14104: LD_VAR 0 4
14108: PPUSH
14109: LD_INT 28
14111: PPUSH
14112: LD_INT 0
14114: PPUSH
14115: CALL_OW 49
// end ;
14119: GO 14075
14121: POP
14122: POP
// for i = 1 to 3 do
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: DOUBLE
14129: LD_INT 1
14131: DEC
14132: ST_TO_ADDR
14133: LD_INT 3
14135: PUSH
14136: FOR_TO
14137: IFFALSE 14185
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14139: LD_INT 0
14141: PPUSH
14142: LD_INT 8
14144: PPUSH
14145: LD_INT 7
14147: PUSH
14148: LD_OWVAR 67
14152: PLUS
14153: PPUSH
14154: CALL_OW 380
// un := CreateHuman ;
14158: LD_ADDR_VAR 0 4
14162: PUSH
14163: CALL_OW 44
14167: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14168: LD_VAR 0 4
14172: PPUSH
14173: LD_INT 28
14175: PPUSH
14176: LD_INT 0
14178: PPUSH
14179: CALL_OW 49
// end ;
14183: GO 14136
14185: POP
14186: POP
// for i = 1 to 3 do
14187: LD_ADDR_VAR 0 2
14191: PUSH
14192: DOUBLE
14193: LD_INT 1
14195: DEC
14196: ST_TO_ADDR
14197: LD_INT 3
14199: PUSH
14200: FOR_TO
14201: IFFALSE 14291
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14203: LD_INT 14
14205: PPUSH
14206: LD_INT 2
14208: PPUSH
14209: LD_INT 1
14211: PPUSH
14212: LD_INT 28
14214: PPUSH
14215: LD_INT 80
14217: PPUSH
14218: CALL 71893 0 5
// veh := CreateVehicle ;
14222: LD_ADDR_VAR 0 3
14226: PUSH
14227: CALL_OW 45
14231: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14232: LD_VAR 0 3
14236: PPUSH
14237: LD_INT 3
14239: PPUSH
14240: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14244: LD_VAR 0 3
14248: PPUSH
14249: LD_INT 29
14251: PPUSH
14252: LD_INT 0
14254: PPUSH
14255: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14259: LD_INT 0
14261: PPUSH
14262: LD_INT 7
14264: PUSH
14265: LD_OWVAR 67
14269: PLUS
14270: PPUSH
14271: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14275: CALL_OW 44
14279: PPUSH
14280: LD_VAR 0 3
14284: PPUSH
14285: CALL_OW 52
// end ;
14289: GO 14200
14291: POP
14292: POP
// for i = 1 to 5 + Difficulty do
14293: LD_ADDR_VAR 0 2
14297: PUSH
14298: DOUBLE
14299: LD_INT 1
14301: DEC
14302: ST_TO_ADDR
14303: LD_INT 5
14305: PUSH
14306: LD_OWVAR 67
14310: PLUS
14311: PUSH
14312: FOR_TO
14313: IFFALSE 14440
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14315: LD_INT 14
14317: PPUSH
14318: LD_INT 1
14320: PPUSH
14321: LD_INT 3
14323: PPUSH
14324: CALL_OW 12
14328: PPUSH
14329: LD_INT 1
14331: PPUSH
14332: LD_INT 28
14334: PUSH
14335: LD_INT 26
14337: PUSH
14338: LD_INT 27
14340: PUSH
14341: LD_INT 25
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: PUSH
14350: LD_VAR 0 2
14354: PUSH
14355: LD_INT 4
14357: MOD
14358: PUSH
14359: LD_INT 1
14361: PLUS
14362: ARRAY
14363: PPUSH
14364: LD_INT 80
14366: PPUSH
14367: CALL 71893 0 5
// veh := CreateVehicle ;
14371: LD_ADDR_VAR 0 3
14375: PUSH
14376: CALL_OW 45
14380: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14381: LD_VAR 0 3
14385: PPUSH
14386: LD_INT 4
14388: PPUSH
14389: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14393: LD_VAR 0 3
14397: PPUSH
14398: LD_INT 28
14400: PPUSH
14401: LD_INT 0
14403: PPUSH
14404: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14408: LD_INT 0
14410: PPUSH
14411: LD_INT 7
14413: PUSH
14414: LD_OWVAR 67
14418: PLUS
14419: PPUSH
14420: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14424: CALL_OW 44
14428: PPUSH
14429: LD_VAR 0 3
14433: PPUSH
14434: CALL_OW 52
// end ;
14438: GO 14312
14440: POP
14441: POP
// for i = 1 to 3 do
14442: LD_ADDR_VAR 0 2
14446: PUSH
14447: DOUBLE
14448: LD_INT 1
14450: DEC
14451: ST_TO_ADDR
14452: LD_INT 3
14454: PUSH
14455: FOR_TO
14456: IFFALSE 14516
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14458: LD_INT 14
14460: PPUSH
14461: LD_INT 3
14463: PPUSH
14464: LD_INT 5
14466: PPUSH
14467: LD_INT 29
14469: PPUSH
14470: LD_INT 80
14472: PPUSH
14473: CALL 71893 0 5
// veh := CreateVehicle ;
14477: LD_ADDR_VAR 0 3
14481: PUSH
14482: CALL_OW 45
14486: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14487: LD_VAR 0 3
14491: PPUSH
14492: LD_INT 4
14494: PPUSH
14495: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14499: LD_VAR 0 3
14503: PPUSH
14504: LD_INT 28
14506: PPUSH
14507: LD_INT 0
14509: PPUSH
14510: CALL_OW 49
// end ;
14514: GO 14455
14516: POP
14517: POP
// end ;
14518: LD_VAR 0 1
14522: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14523: LD_INT 22
14525: PUSH
14526: LD_INT 2
14528: PUSH
14529: EMPTY
14530: LIST
14531: LIST
14532: PPUSH
14533: CALL_OW 69
14537: IFFALSE 14837
14539: GO 14541
14541: DISABLE
14542: LD_INT 0
14544: PPUSH
14545: PPUSH
14546: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14547: LD_ADDR_VAR 0 3
14551: PUSH
14552: LD_INT 22
14554: PUSH
14555: LD_INT 2
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 25
14564: PUSH
14565: LD_INT 4
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: EMPTY
14573: LIST
14574: LIST
14575: PPUSH
14576: CALL_OW 69
14580: PUSH
14581: LD_EXP 94
14585: DIFF
14586: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14587: LD_ADDR_VAR 0 2
14591: PUSH
14592: LD_INT 22
14594: PUSH
14595: LD_INT 2
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: PPUSH
14602: CALL_OW 69
14606: PUSH
14607: LD_EXP 94
14611: PUSH
14612: LD_VAR 0 3
14616: UNION
14617: DIFF
14618: ST_TO_ADDR
// if Khatam then
14619: LD_EXP 94
14623: IFFALSE 14640
// ComMoveXY ( Khatam , 211 , 92 ) ;
14625: LD_EXP 94
14629: PPUSH
14630: LD_INT 211
14632: PPUSH
14633: LD_INT 92
14635: PPUSH
14636: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14640: LD_INT 197
14642: PPUSH
14643: LD_INT 80
14645: PPUSH
14646: LD_INT 2
14648: PPUSH
14649: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14653: LD_INT 213
14655: PPUSH
14656: LD_INT 90
14658: PPUSH
14659: LD_INT 2
14661: PPUSH
14662: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14666: LD_INT 215
14668: PPUSH
14669: LD_INT 129
14671: PPUSH
14672: LD_INT 2
14674: PPUSH
14675: CALL_OW 441
// if sci then
14679: LD_VAR 0 3
14683: IFFALSE 14704
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14685: LD_VAR 0 3
14689: PUSH
14690: LD_INT 1
14692: ARRAY
14693: PPUSH
14694: LD_INT 197
14696: PPUSH
14697: LD_INT 80
14699: PPUSH
14700: CALL_OW 158
// if sci > 1 then
14704: LD_VAR 0 3
14708: PUSH
14709: LD_INT 1
14711: GREATER
14712: IFFALSE 14733
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14714: LD_VAR 0 3
14718: PUSH
14719: LD_INT 2
14721: ARRAY
14722: PPUSH
14723: LD_INT 213
14725: PPUSH
14726: LD_INT 90
14728: PPUSH
14729: CALL_OW 158
// if sci > 2 then
14733: LD_VAR 0 3
14737: PUSH
14738: LD_INT 2
14740: GREATER
14741: IFFALSE 14762
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14743: LD_VAR 0 3
14747: PUSH
14748: LD_INT 3
14750: ARRAY
14751: PPUSH
14752: LD_INT 215
14754: PPUSH
14755: LD_INT 129
14757: PPUSH
14758: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14762: LD_INT 35
14764: PPUSH
14765: CALL_OW 67
// for i in tmp do
14769: LD_ADDR_VAR 0 1
14773: PUSH
14774: LD_VAR 0 2
14778: PUSH
14779: FOR_IN
14780: IFFALSE 14818
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14782: LD_VAR 0 1
14786: PPUSH
14787: LD_INT 81
14789: PUSH
14790: LD_INT 2
14792: PUSH
14793: EMPTY
14794: LIST
14795: LIST
14796: PPUSH
14797: CALL_OW 69
14801: PPUSH
14802: LD_VAR 0 1
14806: PPUSH
14807: CALL_OW 74
14811: PPUSH
14812: CALL_OW 115
14816: GO 14779
14818: POP
14819: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14820: LD_INT 22
14822: PUSH
14823: LD_INT 2
14825: PUSH
14826: EMPTY
14827: LIST
14828: LIST
14829: PPUSH
14830: CALL_OW 69
14834: NOT
14835: IFFALSE 14762
// end ; end_of_file
14837: PPOPN 3
14839: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14840: LD_INT 0
14842: PPUSH
14843: PPUSH
14844: PPUSH
14845: PPUSH
14846: PPUSH
14847: PPUSH
14848: PPUSH
14849: PPUSH
14850: PPUSH
// Video ( true ) ;
14851: LD_INT 1
14853: PPUSH
14854: CALL 107620 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14858: LD_ADDR_VAR 0 5
14862: PUSH
14863: LD_INT 7
14865: PPUSH
14866: LD_INT 0
14868: PPUSH
14869: CALL_OW 517
14873: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14874: LD_ADDR_VAR 0 2
14878: PUSH
14879: DOUBLE
14880: LD_INT 1
14882: DEC
14883: ST_TO_ADDR
14884: LD_VAR 0 5
14888: PUSH
14889: LD_INT 1
14891: ARRAY
14892: PUSH
14893: FOR_TO
14894: IFFALSE 14939
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14896: LD_VAR 0 5
14900: PUSH
14901: LD_INT 1
14903: ARRAY
14904: PUSH
14905: LD_VAR 0 2
14909: ARRAY
14910: PPUSH
14911: LD_VAR 0 5
14915: PUSH
14916: LD_INT 2
14918: ARRAY
14919: PUSH
14920: LD_VAR 0 2
14924: ARRAY
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: LD_INT 15
14931: NEG
14932: PPUSH
14933: CALL 107534 0 4
14937: GO 14893
14939: POP
14940: POP
// CenterNowOnUnits ( Powell ) ;
14941: LD_EXP 58
14945: PPUSH
14946: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14950: LD_ADDR_VAR 0 5
14954: PUSH
14955: LD_EXP 56
14959: PUSH
14960: EMPTY
14961: LIST
14962: ST_TO_ADDR
// if GirlNewVeh then
14963: LD_EXP 57
14967: IFFALSE 14985
// tmp := tmp ^ GirlNewVeh ;
14969: LD_ADDR_VAR 0 5
14973: PUSH
14974: LD_VAR 0 5
14978: PUSH
14979: LD_EXP 57
14983: ADD
14984: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14985: LD_VAR 0 5
14989: PPUSH
14990: LD_INT 60
14992: PPUSH
14993: LD_INT 109
14995: PPUSH
14996: CALL_OW 111
// if KappaStatus then
15000: LD_EXP 2
15004: IFFALSE 15056
// begin Say ( JMM , D1nT-JMM-1 ) ;
15006: LD_EXP 39
15010: PPUSH
15011: LD_STRING D1nT-JMM-1
15013: PPUSH
15014: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15018: LD_EXP 58
15022: PPUSH
15023: LD_STRING D1T-Pow-1
15025: PPUSH
15026: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15030: LD_EXP 39
15034: PPUSH
15035: LD_STRING D1T-JMM-2
15037: PPUSH
15038: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15042: LD_EXP 58
15046: PPUSH
15047: LD_STRING D1T-Pow-2
15049: PPUSH
15050: CALL_OW 88
// end else
15054: GO 15262
// if JMMGirlStatus then
15056: LD_EXP 6
15060: IFFALSE 15205
// begin Say ( JMM , D1T-JMM-1 ) ;
15062: LD_EXP 39
15066: PPUSH
15067: LD_STRING D1T-JMM-1
15069: PPUSH
15070: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15074: LD_EXP 58
15078: PPUSH
15079: LD_STRING D1T-Pow-1
15081: PPUSH
15082: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15086: LD_EXP 39
15090: PPUSH
15091: LD_STRING D1T-JMM-3
15093: PPUSH
15094: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15098: LD_EXP 58
15102: PPUSH
15103: LD_STRING D1T-Pow-3
15105: PPUSH
15106: CALL_OW 88
// if JMMGirl then
15110: LD_EXP 7
15114: IFFALSE 15203
// begin case JMMGirl of 1 :
15116: LD_EXP 7
15120: PUSH
15121: LD_INT 1
15123: DOUBLE
15124: EQUAL
15125: IFTRUE 15129
15127: GO 15144
15129: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15130: LD_EXP 40
15134: PPUSH
15135: LD_STRING D1T-Joan-3
15137: PPUSH
15138: CALL_OW 88
15142: GO 15191
15144: LD_INT 2
15146: DOUBLE
15147: EQUAL
15148: IFTRUE 15152
15150: GO 15167
15152: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15153: LD_EXP 42
15157: PPUSH
15158: LD_STRING D1T-Lisa-3
15160: PPUSH
15161: CALL_OW 88
15165: GO 15191
15167: LD_INT 3
15169: DOUBLE
15170: EQUAL
15171: IFTRUE 15175
15173: GO 15190
15175: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15176: LD_EXP 54
15180: PPUSH
15181: LD_STRING D1T-Con-3
15183: PPUSH
15184: CALL_OW 88
15188: GO 15191
15190: POP
// Say ( Powell , D1T-Pow-4 ) ;
15191: LD_EXP 58
15195: PPUSH
15196: LD_STRING D1T-Pow-4
15198: PPUSH
15199: CALL_OW 88
// end ; end else
15203: GO 15262
// if not FastEnd then
15205: LD_EXP 11
15209: NOT
15210: IFFALSE 15238
// begin Say ( JMM , D1T-JMM-4 ) ;
15212: LD_EXP 39
15216: PPUSH
15217: LD_STRING D1T-JMM-4
15219: PPUSH
15220: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15224: LD_EXP 58
15228: PPUSH
15229: LD_STRING D1T-Pow-5
15231: PPUSH
15232: CALL_OW 88
// end else
15236: GO 15262
// begin Say ( JMM , D1nT-JMM-1 ) ;
15238: LD_EXP 39
15242: PPUSH
15243: LD_STRING D1nT-JMM-1
15245: PPUSH
15246: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15250: LD_EXP 58
15254: PPUSH
15255: LD_STRING D1nT-Pow-1
15257: PPUSH
15258: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15262: LD_INT 35
15264: PPUSH
15265: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15269: LD_EXP 56
15273: PPUSH
15274: CALL_OW 314
15278: NOT
15279: IFFALSE 15262
// ComExitVehicle ( JMM ) ;
15281: LD_EXP 39
15285: PPUSH
15286: CALL_OW 121
// wait ( 3 ) ;
15290: LD_INT 3
15292: PPUSH
15293: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15297: LD_EXP 39
15301: PPUSH
15302: LD_INT 60
15304: PPUSH
15305: LD_INT 94
15307: PPUSH
15308: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15312: LD_EXP 39
15316: PPUSH
15317: LD_EXP 58
15321: PPUSH
15322: CALL_OW 179
// if Joan then
15326: LD_EXP 40
15330: IFFALSE 15384
// begin ComExitVehicle ( Joan ) ;
15332: LD_EXP 40
15336: PPUSH
15337: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15341: LD_EXP 40
15345: PPUSH
15346: LD_INT 35
15348: PPUSH
15349: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15353: LD_EXP 40
15357: PPUSH
15358: LD_INT 65
15360: PPUSH
15361: LD_INT 104
15363: PPUSH
15364: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15368: LD_EXP 40
15372: PPUSH
15373: LD_EXP 39
15377: PPUSH
15378: CALL_OW 179
// end else
15382: GO 15518
// if Lisa and JMMGirl = 2 then
15384: LD_EXP 42
15388: PUSH
15389: LD_EXP 7
15393: PUSH
15394: LD_INT 2
15396: EQUAL
15397: AND
15398: IFFALSE 15452
// begin ComExitVehicle ( Lisa ) ;
15400: LD_EXP 42
15404: PPUSH
15405: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15409: LD_EXP 42
15413: PPUSH
15414: LD_INT 35
15416: PPUSH
15417: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15421: LD_EXP 42
15425: PPUSH
15426: LD_INT 65
15428: PPUSH
15429: LD_INT 104
15431: PPUSH
15432: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15436: LD_EXP 42
15440: PPUSH
15441: LD_EXP 39
15445: PPUSH
15446: CALL_OW 179
// end else
15450: GO 15518
// if Connie and JMMGirl = 3 then
15452: LD_EXP 54
15456: PUSH
15457: LD_EXP 7
15461: PUSH
15462: LD_INT 3
15464: EQUAL
15465: AND
15466: IFFALSE 15518
// begin ComExitVehicle ( Connie ) ;
15468: LD_EXP 54
15472: PPUSH
15473: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15477: LD_EXP 54
15481: PPUSH
15482: LD_INT 35
15484: PPUSH
15485: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15489: LD_EXP 54
15493: PPUSH
15494: LD_INT 65
15496: PPUSH
15497: LD_INT 104
15499: PPUSH
15500: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15504: LD_EXP 54
15508: PPUSH
15509: LD_EXP 39
15513: PPUSH
15514: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15518: LD_INT 35
15520: PPUSH
15521: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15525: LD_EXP 39
15529: PPUSH
15530: LD_EXP 58
15534: PPUSH
15535: CALL_OW 296
15539: PUSH
15540: LD_INT 6
15542: LESS
15543: IFFALSE 15518
// wait ( 0 0$0.5 ) ;
15545: LD_INT 18
15547: PPUSH
15548: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15552: LD_EXP 39
15556: PPUSH
15557: LD_STRING D1-JMM-1
15559: PPUSH
15560: CALL_OW 88
// async ;
15564: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15565: LD_EXP 58
15569: PPUSH
15570: LD_STRING D1-Pow-1
15572: PPUSH
15573: CALL_OW 88
// if not dialogue_skipped then
15577: LD_OWVAR 59
15581: NOT
15582: IFFALSE 15591
// wait ( 0 0$2 ) ;
15584: LD_INT 70
15586: PPUSH
15587: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15591: LD_INT 170
15593: PPUSH
15594: LD_INT 99
15596: PPUSH
15597: LD_INT 1
15599: PPUSH
15600: LD_INT 6
15602: NEG
15603: PPUSH
15604: CALL 107534 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15608: LD_INT 174
15610: PPUSH
15611: LD_INT 115
15613: PPUSH
15614: LD_INT 1
15616: PPUSH
15617: LD_INT 6
15619: NEG
15620: PPUSH
15621: CALL 107534 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15625: LD_INT 169
15627: PPUSH
15628: LD_INT 71
15630: PPUSH
15631: LD_INT 1
15633: PPUSH
15634: LD_INT 6
15636: NEG
15637: PPUSH
15638: CALL 107534 0 4
// if not dialogue_skipped then
15642: LD_OWVAR 59
15646: NOT
15647: IFFALSE 15666
// begin CenterOnXY ( 170 , 99 ) ;
15649: LD_INT 170
15651: PPUSH
15652: LD_INT 99
15654: PPUSH
15655: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15659: LD_INT 80
15661: PPUSH
15662: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15666: LD_INT 75
15668: PPUSH
15669: LD_INT 53
15671: PPUSH
15672: LD_INT 1
15674: PPUSH
15675: LD_INT 9
15677: NEG
15678: PPUSH
15679: CALL 107534 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15683: LD_INT 54
15685: PPUSH
15686: LD_INT 42
15688: PPUSH
15689: LD_INT 1
15691: PPUSH
15692: LD_INT 9
15694: NEG
15695: PPUSH
15696: CALL 107534 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15700: LD_INT 62
15702: PPUSH
15703: LD_INT 51
15705: PPUSH
15706: LD_INT 1
15708: PPUSH
15709: LD_INT 9
15711: NEG
15712: PPUSH
15713: CALL 107534 0 4
// if not dialogue_skipped then
15717: LD_OWVAR 59
15721: NOT
15722: IFFALSE 15741
// begin CenterOnXY ( 75 , 53 ) ;
15724: LD_INT 75
15726: PPUSH
15727: LD_INT 53
15729: PPUSH
15730: CALL_OW 84
// wait ( 0 0$4 ) ;
15734: LD_INT 140
15736: PPUSH
15737: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15741: LD_EXP 58
15745: PPUSH
15746: CALL_OW 87
// if not dialogue_skipped then
15750: LD_OWVAR 59
15754: NOT
15755: IFFALSE 15764
// wait ( 0 0$2 ) ;
15757: LD_INT 70
15759: PPUSH
15760: CALL_OW 67
// sync ;
15764: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15765: LD_EXP 39
15769: PPUSH
15770: LD_STRING D1-JMM-2
15772: PPUSH
15773: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15777: LD_EXP 58
15781: PPUSH
15782: LD_STRING D1-Pow-2
15784: PPUSH
15785: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15789: LD_EXP 39
15793: PPUSH
15794: LD_STRING D1-JMM-3
15796: PPUSH
15797: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15801: LD_EXP 58
15805: PPUSH
15806: LD_STRING D1-Pow-3
15808: PPUSH
15809: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15813: LD_EXP 39
15817: PPUSH
15818: LD_STRING D1-JMM-4
15820: PPUSH
15821: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15825: LD_EXP 58
15829: PPUSH
15830: LD_STRING D1-Pow-4
15832: PPUSH
15833: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15837: LD_EXP 39
15841: PPUSH
15842: LD_STRING D1-JMM-5
15844: PPUSH
15845: CALL_OW 88
// async ;
15849: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15850: LD_EXP 58
15854: PPUSH
15855: LD_STRING D1-Pow-5
15857: PPUSH
15858: CALL_OW 88
// if not dialogue_skipped then
15862: LD_OWVAR 59
15866: NOT
15867: IFFALSE 15876
// wait ( 0 0$3.6 ) ;
15869: LD_INT 126
15871: PPUSH
15872: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15876: LD_INT 134
15878: PPUSH
15879: LD_INT 210
15881: PPUSH
15882: LD_INT 1
15884: PPUSH
15885: LD_INT 11
15887: NEG
15888: PPUSH
15889: CALL 107534 0 4
// if not dialogue_skipped then
15893: LD_OWVAR 59
15897: NOT
15898: IFFALSE 15917
// begin CenterOnXY ( 134 , 210 ) ;
15900: LD_INT 134
15902: PPUSH
15903: LD_INT 210
15905: PPUSH
15906: CALL_OW 84
// wait ( 0 0$2 ) ;
15910: LD_INT 70
15912: PPUSH
15913: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15917: LD_INT 101
15919: PPUSH
15920: LD_INT 159
15922: PPUSH
15923: LD_INT 1
15925: PPUSH
15926: LD_INT 10
15928: NEG
15929: PPUSH
15930: CALL 107534 0 4
// if not dialogue_skipped then
15934: LD_OWVAR 59
15938: NOT
15939: IFFALSE 15958
// begin CenterOnXY ( 101 , 159 ) ;
15941: LD_INT 101
15943: PPUSH
15944: LD_INT 159
15946: PPUSH
15947: CALL_OW 84
// wait ( 0 0$2 ) ;
15951: LD_INT 70
15953: PPUSH
15954: CALL_OW 67
// end ; sync ;
15958: SYNC
// CenterNowOnUnits ( Powell ) ;
15959: LD_EXP 58
15963: PPUSH
15964: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15968: LD_ADDR_VAR 0 6
15972: PUSH
15973: LD_INT 1
15975: PUSH
15976: LD_INT 2
15978: PUSH
15979: LD_INT 3
15981: PUSH
15982: LD_INT 4
15984: PUSH
15985: LD_INT 5
15987: PUSH
15988: LD_INT 6
15990: PUSH
15991: EMPTY
15992: LIST
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: ST_TO_ADDR
// if not dialogue_skipped then
15999: LD_OWVAR 59
16003: NOT
16004: IFFALSE 16173
// begin game_speed := 4 ;
16006: LD_ADDR_OWVAR 65
16010: PUSH
16011: LD_INT 4
16013: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16014: LD_INT 210
16016: PPUSH
16017: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16021: LD_ADDR_VAR 0 7
16025: PUSH
16026: LD_STRING Q1
16028: PPUSH
16029: LD_VAR 0 6
16033: PPUSH
16034: CALL_OW 98
16038: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16039: LD_ADDR_VAR 0 7
16043: PUSH
16044: LD_STRING Q1
16046: PPUSH
16047: LD_VAR 0 6
16051: PPUSH
16052: CALL_OW 98
16056: ST_TO_ADDR
// options = options diff dec ;
16057: LD_ADDR_VAR 0 6
16061: PUSH
16062: LD_VAR 0 6
16066: PUSH
16067: LD_VAR 0 7
16071: DIFF
16072: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16073: LD_VAR 0 7
16077: PPUSH
16078: LD_VAR 0 6
16082: PPUSH
16083: CALL 17645 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16087: LD_VAR 0 7
16091: PUSH
16092: LD_INT 5
16094: PUSH
16095: LD_INT 6
16097: PUSH
16098: EMPTY
16099: LIST
16100: LIST
16101: IN
16102: PUSH
16103: LD_VAR 0 6
16107: PUSH
16108: LD_INT 2
16110: EQUAL
16111: OR
16112: IFFALSE 16039
// if not ( dec in [ 5 , 6 ] ) then
16114: LD_VAR 0 7
16118: PUSH
16119: LD_INT 5
16121: PUSH
16122: LD_INT 6
16124: PUSH
16125: EMPTY
16126: LIST
16127: LIST
16128: IN
16129: NOT
16130: IFFALSE 16173
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16132: LD_ADDR_VAR 0 7
16136: PUSH
16137: LD_STRING Q1a
16139: PPUSH
16140: LD_INT 1
16142: PUSH
16143: LD_INT 2
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: PPUSH
16150: CALL_OW 98
16154: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16155: LD_VAR 0 7
16159: PUSH
16160: LD_INT 4
16162: PLUS
16163: PPUSH
16164: LD_VAR 0 6
16168: PPUSH
16169: CALL 17645 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16173: LD_INT 81
16175: PPUSH
16176: LD_INT 127
16178: PPUSH
16179: CALL_OW 84
// amount := 5 ;
16183: LD_ADDR_VAR 0 8
16187: PUSH
16188: LD_INT 5
16190: ST_TO_ADDR
// macmilan_squad := [ ] ;
16191: LD_ADDR_VAR 0 9
16195: PUSH
16196: EMPTY
16197: ST_TO_ADDR
// if vip < amount then
16198: LD_EXP 59
16202: PUSH
16203: LD_VAR 0 8
16207: LESS
16208: IFFALSE 16252
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16210: LD_ADDR_VAR 0 5
16214: PUSH
16215: LD_EXP 59
16219: PUSH
16220: LD_INT 22
16222: PUSH
16223: LD_INT 4
16225: PUSH
16226: EMPTY
16227: LIST
16228: LIST
16229: PUSH
16230: LD_INT 21
16232: PUSH
16233: LD_INT 1
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: PUSH
16240: EMPTY
16241: LIST
16242: LIST
16243: PPUSH
16244: CALL_OW 69
16248: UNION
16249: ST_TO_ADDR
16250: GO 16262
// tmp := vip ;
16252: LD_ADDR_VAR 0 5
16256: PUSH
16257: LD_EXP 59
16261: ST_TO_ADDR
// tmp := tmp diff Powell ;
16262: LD_ADDR_VAR 0 5
16266: PUSH
16267: LD_VAR 0 5
16271: PUSH
16272: LD_EXP 58
16276: DIFF
16277: ST_TO_ADDR
// if tmp < amount then
16278: LD_VAR 0 5
16282: PUSH
16283: LD_VAR 0 8
16287: LESS
16288: IFFALSE 16300
// amount := tmp ;
16290: LD_ADDR_VAR 0 8
16294: PUSH
16295: LD_VAR 0 5
16299: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16300: LD_VAR 0 5
16304: PUSH
16305: LD_INT 1
16307: ARRAY
16308: PPUSH
16309: CALL_OW 257
16313: PUSH
16314: LD_INT 2
16316: NONEQUAL
16317: IFFALSE 16379
// begin if IsInUnit ( tmp [ 1 ] ) then
16319: LD_VAR 0 5
16323: PUSH
16324: LD_INT 1
16326: ARRAY
16327: PPUSH
16328: CALL_OW 310
16332: IFFALSE 16347
// ComExitBuilding ( tmp [ 1 ] ) ;
16334: LD_VAR 0 5
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: PPUSH
16343: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16347: LD_VAR 0 5
16351: PUSH
16352: LD_INT 1
16354: ARRAY
16355: PPUSH
16356: LD_INT 387
16358: PPUSH
16359: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16363: LD_VAR 0 5
16367: PUSH
16368: LD_INT 1
16370: ARRAY
16371: PPUSH
16372: LD_INT 2
16374: PPUSH
16375: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16379: LD_EXP 39
16383: PPUSH
16384: LD_INT 82
16386: PPUSH
16387: LD_INT 129
16389: PPUSH
16390: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16394: LD_EXP 39
16398: PPUSH
16399: LD_EXP 58
16403: PPUSH
16404: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16408: LD_INT 22
16410: PUSH
16411: LD_INT 1
16413: PUSH
16414: EMPTY
16415: LIST
16416: LIST
16417: PPUSH
16418: CALL_OW 69
16422: PUSH
16423: LD_EXP 39
16427: DIFF
16428: PPUSH
16429: LD_INT 84
16431: PPUSH
16432: LD_INT 128
16434: PPUSH
16435: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16439: LD_INT 22
16441: PUSH
16442: LD_INT 1
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: PPUSH
16449: CALL_OW 69
16453: PUSH
16454: LD_EXP 39
16458: DIFF
16459: PPUSH
16460: LD_EXP 39
16464: PPUSH
16465: CALL_OW 179
// for i = 1 to amount do
16469: LD_ADDR_VAR 0 2
16473: PUSH
16474: DOUBLE
16475: LD_INT 1
16477: DEC
16478: ST_TO_ADDR
16479: LD_VAR 0 8
16483: PUSH
16484: FOR_TO
16485: IFFALSE 16653
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16487: LD_ADDR_VAR 0 9
16491: PUSH
16492: LD_VAR 0 9
16496: PUSH
16497: LD_VAR 0 5
16501: PUSH
16502: LD_VAR 0 2
16506: ARRAY
16507: ADD
16508: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16509: LD_VAR 0 5
16513: PUSH
16514: LD_VAR 0 2
16518: ARRAY
16519: PPUSH
16520: CALL_OW 310
16524: IFFALSE 16541
// AddComExitBuilding ( tmp [ i ] ) ;
16526: LD_VAR 0 5
16530: PUSH
16531: LD_VAR 0 2
16535: ARRAY
16536: PPUSH
16537: CALL_OW 182
// if i = 2 and JMMNewVeh then
16541: LD_VAR 0 2
16545: PUSH
16546: LD_INT 2
16548: EQUAL
16549: PUSH
16550: LD_EXP 56
16554: AND
16555: IFFALSE 16613
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16557: LD_VAR 0 5
16561: PUSH
16562: LD_VAR 0 2
16566: ARRAY
16567: PPUSH
16568: LD_EXP 56
16572: PPUSH
16573: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16577: LD_VAR 0 5
16581: PUSH
16582: LD_VAR 0 2
16586: ARRAY
16587: PPUSH
16588: LD_INT 86
16590: PPUSH
16591: LD_INT 133
16593: PPUSH
16594: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16598: LD_VAR 0 5
16602: PUSH
16603: LD_VAR 0 2
16607: ARRAY
16608: PPUSH
16609: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16613: LD_VAR 0 5
16617: PUSH
16618: LD_VAR 0 2
16622: ARRAY
16623: PPUSH
16624: LD_INT 8
16626: PPUSH
16627: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16631: LD_VAR 0 5
16635: PUSH
16636: LD_VAR 0 2
16640: ARRAY
16641: PPUSH
16642: LD_EXP 39
16646: PPUSH
16647: CALL_OW 179
// end ;
16651: GO 16484
16653: POP
16654: POP
// if GirlNewVeh then
16655: LD_EXP 57
16659: IFFALSE 16673
// SetSide ( GirlNewVeh , 4 ) ;
16661: LD_EXP 57
16665: PPUSH
16666: LD_INT 4
16668: PPUSH
16669: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16673: LD_INT 35
16675: PPUSH
16676: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16680: LD_VAR 0 9
16684: PPUSH
16685: LD_INT 95
16687: PUSH
16688: LD_INT 9
16690: PUSH
16691: EMPTY
16692: LIST
16693: LIST
16694: PPUSH
16695: CALL_OW 72
16699: PUSH
16700: LD_INT 0
16702: EQUAL
16703: PUSH
16704: LD_EXP 39
16708: PPUSH
16709: LD_INT 9
16711: PPUSH
16712: CALL_OW 308
16716: NOT
16717: AND
16718: IFFALSE 16673
// wait ( 0 0$2 ) ;
16720: LD_INT 70
16722: PPUSH
16723: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16727: LD_VAR 0 9
16731: PPUSH
16732: LD_INT 1
16734: PPUSH
16735: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16739: LD_INT 21
16741: PUSH
16742: LD_INT 2
16744: PUSH
16745: EMPTY
16746: LIST
16747: LIST
16748: PUSH
16749: LD_INT 92
16751: PUSH
16752: LD_INT 83
16754: PUSH
16755: LD_INT 130
16757: PUSH
16758: LD_INT 10
16760: PUSH
16761: EMPTY
16762: LIST
16763: LIST
16764: LIST
16765: LIST
16766: PUSH
16767: EMPTY
16768: LIST
16769: LIST
16770: PPUSH
16771: CALL_OW 69
16775: PPUSH
16776: LD_INT 1
16778: PPUSH
16779: CALL_OW 235
// Video ( false ) ;
16783: LD_INT 0
16785: PPUSH
16786: CALL 107620 0 1
// ChangeMissionObjectives ( M1 ) ;
16790: LD_STRING M1
16792: PPUSH
16793: CALL_OW 337
// SaveForQuickRestart ;
16797: CALL_OW 22
// missionStart := true ;
16801: LD_ADDR_EXP 13
16805: PUSH
16806: LD_INT 1
16808: ST_TO_ADDR
// missionStage := 2 ;
16809: LD_ADDR_EXP 15
16813: PUSH
16814: LD_INT 2
16816: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16817: LD_INT 105
16819: PPUSH
16820: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16824: LD_ADDR_VAR 0 5
16828: PUSH
16829: LD_INT 22
16831: PUSH
16832: LD_INT 4
16834: PUSH
16835: EMPTY
16836: LIST
16837: LIST
16838: PUSH
16839: LD_INT 21
16841: PUSH
16842: LD_INT 1
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PPUSH
16853: CALL_OW 69
16857: PUSH
16858: LD_EXP 58
16862: DIFF
16863: ST_TO_ADDR
// if not tmp then
16864: LD_VAR 0 5
16868: NOT
16869: IFFALSE 16884
// tmp := [ Powell ] ;
16871: LD_ADDR_VAR 0 5
16875: PUSH
16876: LD_EXP 58
16880: PUSH
16881: EMPTY
16882: LIST
16883: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16884: LD_ADDR_EXP 102
16888: PUSH
16889: LD_EXP 102
16893: PPUSH
16894: LD_INT 4
16896: PPUSH
16897: LD_INT 22
16899: PUSH
16900: LD_INT 4
16902: PUSH
16903: EMPTY
16904: LIST
16905: LIST
16906: PUSH
16907: LD_INT 23
16909: PUSH
16910: LD_INT 1
16912: PUSH
16913: EMPTY
16914: LIST
16915: LIST
16916: PUSH
16917: LD_INT 3
16919: PUSH
16920: LD_INT 21
16922: PUSH
16923: LD_INT 2
16925: PUSH
16926: EMPTY
16927: LIST
16928: LIST
16929: PUSH
16930: EMPTY
16931: LIST
16932: LIST
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: LIST
16938: PPUSH
16939: CALL_OW 69
16943: PUSH
16944: LD_EXP 58
16948: DIFF
16949: PPUSH
16950: CALL_OW 1
16954: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16955: LD_ADDR_VAR 0 4
16959: PUSH
16960: LD_INT 22
16962: PUSH
16963: LD_INT 4
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: PUSH
16970: LD_INT 34
16972: PUSH
16973: LD_INT 12
16975: PUSH
16976: EMPTY
16977: LIST
16978: LIST
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: PPUSH
16984: CALL_OW 69
16988: PUSH
16989: LD_INT 1
16991: ARRAY
16992: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16993: LD_VAR 0 5
16997: PUSH
16998: LD_INT 1
17000: ARRAY
17001: PPUSH
17002: CALL_OW 310
17006: IFFALSE 17021
// ComExitBuilding ( tmp [ 1 ] ) ;
17008: LD_VAR 0 5
17012: PUSH
17013: LD_INT 1
17015: ARRAY
17016: PPUSH
17017: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17021: LD_VAR 0 5
17025: PUSH
17026: LD_INT 1
17028: ARRAY
17029: PPUSH
17030: LD_VAR 0 4
17034: PPUSH
17035: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17039: LD_VAR 0 5
17043: PUSH
17044: LD_INT 1
17046: ARRAY
17047: PPUSH
17048: LD_INT 80
17050: PPUSH
17051: LD_INT 136
17053: PPUSH
17054: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17058: LD_VAR 0 5
17062: PUSH
17063: LD_INT 1
17065: ARRAY
17066: PPUSH
17067: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17071: LD_VAR 0 5
17075: PUSH
17076: LD_INT 1
17078: ARRAY
17079: PPUSH
17080: LD_INT 59
17082: PPUSH
17083: LD_INT 112
17085: PPUSH
17086: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17090: LD_VAR 0 5
17094: PUSH
17095: LD_INT 1
17097: ARRAY
17098: PPUSH
17099: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17103: LD_EXP 40
17107: PUSH
17108: LD_EXP 40
17112: PPUSH
17113: CALL_OW 255
17117: PUSH
17118: LD_INT 1
17120: EQUAL
17121: AND
17122: IFFALSE 17148
// begin Say ( Joan , D3W-Joan-1 ) ;
17124: LD_EXP 40
17128: PPUSH
17129: LD_STRING D3W-Joan-1
17131: PPUSH
17132: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17136: LD_EXP 39
17140: PPUSH
17141: LD_STRING D3W-JMM-1
17143: PPUSH
17144: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17148: LD_EXP 42
17152: PUSH
17153: LD_EXP 42
17157: PPUSH
17158: CALL_OW 255
17162: PUSH
17163: LD_INT 1
17165: EQUAL
17166: AND
17167: PUSH
17168: LD_EXP 42
17172: PUSH
17173: LD_EXP 59
17177: IN
17178: NOT
17179: AND
17180: IFFALSE 17206
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17182: LD_EXP 42
17186: PPUSH
17187: LD_STRING D3W-Lisa-1
17189: PPUSH
17190: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17194: LD_EXP 39
17198: PPUSH
17199: LD_STRING D3W-JMM-1
17201: PPUSH
17202: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17206: LD_EXP 54
17210: PUSH
17211: LD_EXP 54
17215: PPUSH
17216: CALL_OW 255
17220: PUSH
17221: LD_INT 1
17223: EQUAL
17224: AND
17225: IFFALSE 17251
// begin Say ( Connie , D3W-Con-1 ) ;
17227: LD_EXP 54
17231: PPUSH
17232: LD_STRING D3W-Con-1
17234: PPUSH
17235: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17239: LD_EXP 39
17243: PPUSH
17244: LD_STRING D3W-JMM-1
17246: PPUSH
17247: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17251: LD_EXP 42
17255: PUSH
17256: LD_EXP 59
17260: IN
17261: PUSH
17262: LD_EXP 42
17266: PPUSH
17267: CALL_OW 255
17271: PUSH
17272: LD_INT 1
17274: EQUAL
17275: AND
17276: IFFALSE 17292
// Say ( Lisa , D3nW-Lisa-1 ) else
17278: LD_EXP 42
17282: PPUSH
17283: LD_STRING D3nW-Lisa-1
17285: PPUSH
17286: CALL_OW 88
17290: GO 17536
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17292: LD_EXP 45
17296: PUSH
17297: LD_EXP 59
17301: IN
17302: PUSH
17303: LD_EXP 45
17307: PPUSH
17308: CALL_OW 255
17312: PUSH
17313: LD_INT 1
17315: EQUAL
17316: AND
17317: IFFALSE 17333
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17319: LD_EXP 45
17323: PPUSH
17324: LD_STRING D3nW-Cyrus-1
17326: PPUSH
17327: CALL_OW 88
17331: GO 17536
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17333: LD_EXP 44
17337: PUSH
17338: LD_EXP 59
17342: IN
17343: PUSH
17344: LD_EXP 44
17348: PPUSH
17349: CALL_OW 255
17353: PUSH
17354: LD_INT 1
17356: EQUAL
17357: AND
17358: IFFALSE 17374
// Say ( Bobby , D3nW-Bobby-1 ) else
17360: LD_EXP 44
17364: PPUSH
17365: LD_STRING D3nW-Bobby-1
17367: PPUSH
17368: CALL_OW 88
17372: GO 17536
// if Gary in vip and GetSide ( Gary ) = 1 then
17374: LD_EXP 51
17378: PUSH
17379: LD_EXP 59
17383: IN
17384: PUSH
17385: LD_EXP 51
17389: PPUSH
17390: CALL_OW 255
17394: PUSH
17395: LD_INT 1
17397: EQUAL
17398: AND
17399: IFFALSE 17415
// Say ( Gary , D3nW-Gary-1 ) else
17401: LD_EXP 51
17405: PPUSH
17406: LD_STRING D3nW-Gary-1
17408: PPUSH
17409: CALL_OW 88
17413: GO 17536
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17415: LD_EXP 43
17419: PUSH
17420: LD_EXP 59
17424: IN
17425: PUSH
17426: LD_EXP 43
17430: PPUSH
17431: CALL_OW 255
17435: PUSH
17436: LD_INT 1
17438: EQUAL
17439: AND
17440: IFFALSE 17456
// Say ( Donaldson , D3nW-Don-1 ) else
17442: LD_EXP 43
17446: PPUSH
17447: LD_STRING D3nW-Don-1
17449: PPUSH
17450: CALL_OW 88
17454: GO 17536
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17456: LD_EXP 50
17460: PUSH
17461: LD_EXP 59
17465: IN
17466: PUSH
17467: LD_EXP 50
17471: PPUSH
17472: CALL_OW 255
17476: PUSH
17477: LD_INT 1
17479: EQUAL
17480: AND
17481: IFFALSE 17497
// Say ( Cornel , D3nW-Corn-1 ) else
17483: LD_EXP 50
17487: PPUSH
17488: LD_STRING D3nW-Corn-1
17490: PPUSH
17491: CALL_OW 88
17495: GO 17536
// if Frank in vip and GetSide ( Frank ) = 1 then
17497: LD_EXP 52
17501: PUSH
17502: LD_EXP 59
17506: IN
17507: PUSH
17508: LD_EXP 52
17512: PPUSH
17513: CALL_OW 255
17517: PUSH
17518: LD_INT 1
17520: EQUAL
17521: AND
17522: IFFALSE 17536
// Say ( Frank , D3nW-Frank-1 ) ;
17524: LD_EXP 52
17528: PPUSH
17529: LD_STRING D3nW-Frank-1
17531: PPUSH
17532: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17536: LD_EXP 59
17540: PPUSH
17541: LD_INT 22
17543: PUSH
17544: LD_INT 1
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: PPUSH
17551: CALL_OW 72
17555: IFFALSE 17581
// begin Say ( JMM , D3nW-JMM-1 ) ;
17557: LD_EXP 39
17561: PPUSH
17562: LD_STRING D3nW-JMM-1
17564: PPUSH
17565: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17569: LD_EXP 39
17573: PPUSH
17574: LD_STRING D3nW-JMM-1a
17576: PPUSH
17577: CALL_OW 88
// end ; t := 0 0$00 ;
17581: LD_ADDR_VAR 0 3
17585: PUSH
17586: LD_INT 0
17588: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17589: LD_INT 35
17591: PPUSH
17592: CALL_OW 67
// t := t + 0 0$1 ;
17596: LD_ADDR_VAR 0 3
17600: PUSH
17601: LD_VAR 0 3
17605: PUSH
17606: LD_INT 35
17608: PLUS
17609: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17610: LD_INT 59
17612: PPUSH
17613: LD_INT 112
17615: PPUSH
17616: CALL_OW 428
17620: PUSH
17621: LD_VAR 0 3
17625: PUSH
17626: LD_INT 2100
17628: GREATER
17629: OR
17630: IFFALSE 17589
// activeAttacks := true ;
17632: LD_ADDR_EXP 16
17636: PUSH
17637: LD_INT 1
17639: ST_TO_ADDR
// end ;
17640: LD_VAR 0 1
17644: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17645: LD_INT 0
17647: PPUSH
// case question of 1 :
17648: LD_VAR 0 1
17652: PUSH
17653: LD_INT 1
17655: DOUBLE
17656: EQUAL
17657: IFTRUE 17661
17659: GO 17712
17661: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17662: LD_EXP 39
17666: PPUSH
17667: LD_STRING D2Mot-JMM-1
17669: PPUSH
17670: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17674: LD_EXP 58
17678: PPUSH
17679: LD_STRING D2Mot-Pow-1
17681: PPUSH
17682: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17686: LD_EXP 39
17690: PPUSH
17691: LD_STRING D2Mot-JMM-2
17693: PPUSH
17694: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17698: LD_EXP 58
17702: PPUSH
17703: LD_STRING D2Mot-Pow-2
17705: PPUSH
17706: CALL_OW 88
// end ; 2 :
17710: GO 18063
17712: LD_INT 2
17714: DOUBLE
17715: EQUAL
17716: IFTRUE 17720
17718: GO 17796
17720: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17721: LD_EXP 39
17725: PPUSH
17726: LD_STRING D2Rus-JMM-1
17728: PPUSH
17729: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17733: LD_EXP 58
17737: PPUSH
17738: LD_STRING D2Rus-Pow-1
17740: PPUSH
17741: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17745: LD_EXP 39
17749: PPUSH
17750: LD_STRING D2Rus-JMM-2
17752: PPUSH
17753: CALL_OW 88
// if not ( 3 in list_of_q ) then
17757: LD_INT 3
17759: PUSH
17760: LD_VAR 0 2
17764: IN
17765: NOT
17766: IFFALSE 17782
// Say ( Powell , D2Rus-Pow-2 ) else
17768: LD_EXP 58
17772: PPUSH
17773: LD_STRING D2Rus-Pow-2
17775: PPUSH
17776: CALL_OW 88
17780: GO 17794
// Say ( Powell , D2Rus-Pow-2a ) ;
17782: LD_EXP 58
17786: PPUSH
17787: LD_STRING D2Rus-Pow-2a
17789: PPUSH
17790: CALL_OW 88
// end ; 3 :
17794: GO 18063
17796: LD_INT 3
17798: DOUBLE
17799: EQUAL
17800: IFTRUE 17804
17802: GO 17889
17804: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17805: LD_EXP 39
17809: PPUSH
17810: LD_STRING D2Leg-JMM-1
17812: PPUSH
17813: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17817: LD_EXP 58
17821: PPUSH
17822: LD_STRING D2Leg-Pow-1
17824: PPUSH
17825: CALL_OW 88
// if 2 in list_of_q then
17829: LD_INT 2
17831: PUSH
17832: LD_VAR 0 2
17836: IN
17837: IFFALSE 17863
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17839: LD_EXP 39
17843: PPUSH
17844: LD_STRING D2Leg-JMM-2
17846: PPUSH
17847: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17851: LD_EXP 58
17855: PPUSH
17856: LD_STRING D2Leg-Pow-2
17858: PPUSH
17859: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17863: LD_EXP 39
17867: PPUSH
17868: LD_STRING D2Leg-JMM-3
17870: PPUSH
17871: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17875: LD_EXP 58
17879: PPUSH
17880: LD_STRING D2Leg-Pow-3
17882: PPUSH
17883: CALL_OW 88
// end ; 4 :
17887: GO 18063
17889: LD_INT 4
17891: DOUBLE
17892: EQUAL
17893: IFTRUE 17897
17895: GO 17972
17897: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17898: LD_EXP 39
17902: PPUSH
17903: LD_STRING D2Ar-JMM-1
17905: PPUSH
17906: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17910: LD_EXP 58
17914: PPUSH
17915: LD_STRING D2Ar-Pow-1
17917: PPUSH
17918: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17922: LD_EXP 39
17926: PPUSH
17927: LD_STRING D2Ar-JMM-2
17929: PPUSH
17930: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17934: LD_EXP 58
17938: PPUSH
17939: LD_STRING D2Ar-Pow-2
17941: PPUSH
17942: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17946: LD_EXP 39
17950: PPUSH
17951: LD_STRING D2Ar-JMM-3
17953: PPUSH
17954: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17958: LD_EXP 58
17962: PPUSH
17963: LD_STRING D2Ar-Pow-3
17965: PPUSH
17966: CALL_OW 88
// end ; 5 :
17970: GO 18063
17972: LD_INT 5
17974: DOUBLE
17975: EQUAL
17976: IFTRUE 17980
17978: GO 17995
17980: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17981: LD_EXP 39
17985: PPUSH
17986: LD_STRING D2Conf-JMM-1
17988: PPUSH
17989: CALL_OW 88
17993: GO 18063
17995: LD_INT 6
17997: DOUBLE
17998: EQUAL
17999: IFTRUE 18003
18001: GO 18062
18003: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18004: LD_EXP 39
18008: PPUSH
18009: LD_STRING D2Com-JMM-1
18011: PPUSH
18012: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18016: LD_EXP 58
18020: PPUSH
18021: LD_STRING D2Com-Pow-1
18023: PPUSH
18024: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18028: LD_EXP 39
18032: PPUSH
18033: LD_STRING D2Com-JMM-2
18035: PPUSH
18036: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18040: LD_EXP 58
18044: PPUSH
18045: LD_STRING D2Com-Pow-2
18047: PPUSH
18048: CALL_OW 88
// powellAngerQuery := true ;
18052: LD_ADDR_EXP 36
18056: PUSH
18057: LD_INT 1
18059: ST_TO_ADDR
// end ; end ;
18060: GO 18063
18062: POP
// end ;
18063: LD_VAR 0 3
18067: RET
// every 0 0$5 trigger missionStart do var tmp ;
18068: LD_EXP 13
18072: IFFALSE 18355
18074: GO 18076
18076: DISABLE
18077: LD_INT 0
18079: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18080: LD_INT 35
18082: PPUSH
18083: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18087: LD_INT 14
18089: PPUSH
18090: LD_INT 22
18092: PUSH
18093: LD_INT 1
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: PPUSH
18100: CALL_OW 70
18104: PUSH
18105: LD_EXP 15
18109: PUSH
18110: LD_INT 2
18112: PUSH
18113: LD_INT 3
18115: PUSH
18116: LD_INT 4
18118: PUSH
18119: LD_INT 5
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: LIST
18126: LIST
18127: IN
18128: AND
18129: IFFALSE 18345
// begin powellAnger := powellAnger + 1 ;
18131: LD_ADDR_EXP 17
18135: PUSH
18136: LD_EXP 17
18140: PUSH
18141: LD_INT 1
18143: PLUS
18144: ST_TO_ADDR
// Video ( true ) ;
18145: LD_INT 1
18147: PPUSH
18148: CALL 107620 0 1
// CenterNowOnUnits ( tmp ) ;
18152: LD_VAR 0 1
18156: PPUSH
18157: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18161: LD_INT 14
18163: PPUSH
18164: LD_INT 22
18166: PUSH
18167: LD_INT 1
18169: PUSH
18170: EMPTY
18171: LIST
18172: LIST
18173: PPUSH
18174: CALL_OW 70
18178: PPUSH
18179: LD_INT 86
18181: PPUSH
18182: LD_INT 133
18184: PPUSH
18185: CALL_OW 111
// async ;
18189: ASYNC
// case powellAnger of 1 :
18190: LD_EXP 17
18194: PUSH
18195: LD_INT 1
18197: DOUBLE
18198: EQUAL
18199: IFTRUE 18203
18201: GO 18218
18203: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18204: LD_EXP 58
18208: PPUSH
18209: LD_STRING DBack1-Pow-1
18211: PPUSH
18212: CALL_OW 88
18216: GO 18265
18218: LD_INT 2
18220: DOUBLE
18221: EQUAL
18222: IFTRUE 18226
18224: GO 18241
18226: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18227: LD_EXP 58
18231: PPUSH
18232: LD_STRING DBack2-Pow-1
18234: PPUSH
18235: CALL_OW 88
18239: GO 18265
18241: LD_INT 3
18243: DOUBLE
18244: EQUAL
18245: IFTRUE 18249
18247: GO 18264
18249: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18250: LD_EXP 58
18254: PPUSH
18255: LD_STRING DBack3-Pow-1
18257: PPUSH
18258: CALL_OW 88
18262: GO 18265
18264: POP
// sync ;
18265: SYNC
// repeat wait ( 0 0$1 ) ;
18266: LD_INT 35
18268: PPUSH
18269: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18273: LD_INT 14
18275: PPUSH
18276: LD_INT 22
18278: PUSH
18279: LD_INT 1
18281: PUSH
18282: EMPTY
18283: LIST
18284: LIST
18285: PPUSH
18286: CALL_OW 70
18290: PPUSH
18291: LD_INT 86
18293: PPUSH
18294: LD_INT 133
18296: PPUSH
18297: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18301: LD_INT 14
18303: PPUSH
18304: LD_INT 22
18306: PUSH
18307: LD_INT 1
18309: PUSH
18310: EMPTY
18311: LIST
18312: LIST
18313: PPUSH
18314: CALL_OW 70
18318: NOT
18319: IFFALSE 18266
// if powellAnger >= 3 then
18321: LD_EXP 17
18325: PUSH
18326: LD_INT 3
18328: GREATEREQUAL
18329: IFFALSE 18338
// YouLost ( Dismissed ) ;
18331: LD_STRING Dismissed
18333: PPUSH
18334: CALL_OW 104
// Video ( false ) ;
18338: LD_INT 0
18340: PPUSH
18341: CALL 107620 0 1
// end ; until missionStage > 5 ;
18345: LD_EXP 15
18349: PUSH
18350: LD_INT 5
18352: GREATER
18353: IFFALSE 18080
// end ;
18355: PPOPN 1
18357: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18358: LD_EXP 13
18362: PUSH
18363: LD_INT 22
18365: PUSH
18366: LD_INT 4
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PUSH
18373: LD_INT 21
18375: PUSH
18376: LD_INT 2
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: EMPTY
18384: LIST
18385: LIST
18386: PPUSH
18387: CALL_OW 69
18391: PUSH
18392: LD_INT 4
18394: GREATEREQUAL
18395: AND
18396: PUSH
18397: LD_EXP 15
18401: PUSH
18402: LD_INT 2
18404: EQUAL
18405: AND
18406: IFFALSE 20229
18408: GO 18410
18410: DISABLE
18411: LD_INT 0
18413: PPUSH
18414: PPUSH
18415: PPUSH
18416: PPUSH
18417: PPUSH
18418: PPUSH
18419: PPUSH
18420: PPUSH
// begin missionStage := 3 ;
18421: LD_ADDR_EXP 15
18425: PUSH
18426: LD_INT 3
18428: ST_TO_ADDR
// retreat := false ;
18429: LD_ADDR_VAR 0 4
18433: PUSH
18434: LD_INT 0
18436: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18437: LD_ADDR_VAR 0 5
18441: PUSH
18442: LD_INT 22
18444: PUSH
18445: LD_INT 4
18447: PUSH
18448: EMPTY
18449: LIST
18450: LIST
18451: PUSH
18452: LD_INT 30
18454: PUSH
18455: LD_INT 4
18457: PUSH
18458: EMPTY
18459: LIST
18460: LIST
18461: PUSH
18462: EMPTY
18463: LIST
18464: LIST
18465: PPUSH
18466: CALL_OW 69
18470: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18471: LD_ADDR_VAR 0 6
18475: PUSH
18476: LD_INT 22
18478: PUSH
18479: LD_INT 4
18481: PUSH
18482: EMPTY
18483: LIST
18484: LIST
18485: PUSH
18486: LD_INT 30
18488: PUSH
18489: LD_INT 5
18491: PUSH
18492: EMPTY
18493: LIST
18494: LIST
18495: PUSH
18496: EMPTY
18497: LIST
18498: LIST
18499: PPUSH
18500: CALL_OW 69
18504: ST_TO_ADDR
// if not bar then
18505: LD_VAR 0 6
18509: NOT
18510: IFFALSE 18563
// begin repeat wait ( 0 0$1 ) ;
18512: LD_INT 35
18514: PPUSH
18515: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18519: LD_INT 22
18521: PUSH
18522: LD_INT 4
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: PUSH
18529: LD_INT 3
18531: PUSH
18532: LD_INT 57
18534: PUSH
18535: EMPTY
18536: LIST
18537: PUSH
18538: EMPTY
18539: LIST
18540: LIST
18541: PUSH
18542: LD_INT 30
18544: PUSH
18545: LD_INT 5
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: PUSH
18552: EMPTY
18553: LIST
18554: LIST
18555: LIST
18556: PPUSH
18557: CALL_OW 69
18561: IFFALSE 18512
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18563: LD_ADDR_VAR 0 6
18567: PUSH
18568: LD_INT 22
18570: PUSH
18571: LD_INT 4
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: LD_INT 30
18580: PUSH
18581: LD_INT 5
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PPUSH
18592: CALL_OW 69
18596: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18597: LD_INT 35
18599: PPUSH
18600: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18604: LD_EXP 121
18608: PUSH
18609: LD_INT 4
18611: ARRAY
18612: PUSH
18613: LD_INT 4
18615: GREATEREQUAL
18616: IFFALSE 18597
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18618: LD_ADDR_VAR 0 2
18622: PUSH
18623: LD_INT 22
18625: PUSH
18626: LD_INT 4
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PUSH
18633: LD_INT 2
18635: PUSH
18636: LD_INT 25
18638: PUSH
18639: LD_INT 1
18641: PUSH
18642: EMPTY
18643: LIST
18644: LIST
18645: PUSH
18646: LD_INT 25
18648: PUSH
18649: LD_INT 2
18651: PUSH
18652: EMPTY
18653: LIST
18654: LIST
18655: PUSH
18656: LD_INT 25
18658: PUSH
18659: LD_INT 3
18661: PUSH
18662: EMPTY
18663: LIST
18664: LIST
18665: PUSH
18666: LD_INT 25
18668: PUSH
18669: LD_INT 4
18671: PUSH
18672: EMPTY
18673: LIST
18674: LIST
18675: PUSH
18676: LD_INT 25
18678: PUSH
18679: LD_INT 5
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: PUSH
18694: EMPTY
18695: LIST
18696: LIST
18697: PPUSH
18698: CALL_OW 69
18702: PUSH
18703: LD_EXP 58
18707: PUSH
18708: LD_EXP 59
18712: ADD
18713: DIFF
18714: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18715: LD_ADDR_VAR 0 3
18719: PUSH
18720: LD_VAR 0 2
18724: PPUSH
18725: LD_INT 26
18727: PUSH
18728: LD_INT 1
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PPUSH
18735: CALL_OW 72
18739: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18740: LD_ADDR_VAR 0 2
18744: PUSH
18745: LD_VAR 0 2
18749: PUSH
18750: LD_VAR 0 3
18754: DIFF
18755: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18756: LD_ADDR_VAR 0 2
18760: PUSH
18761: LD_VAR 0 2
18765: PPUSH
18766: LD_INT 1
18768: PPUSH
18769: CALL 106273 0 2
18773: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18774: LD_ADDR_VAR 0 3
18778: PUSH
18779: LD_VAR 0 3
18783: PPUSH
18784: LD_INT 1
18786: PPUSH
18787: CALL 106273 0 2
18791: ST_TO_ADDR
// for i = 1 to 4 do
18792: LD_ADDR_VAR 0 1
18796: PUSH
18797: DOUBLE
18798: LD_INT 1
18800: DEC
18801: ST_TO_ADDR
18802: LD_INT 4
18804: PUSH
18805: FOR_TO
18806: IFFALSE 18972
// begin if tmp2 then
18808: LD_VAR 0 3
18812: IFFALSE 18893
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18814: LD_ADDR_EXP 18
18818: PUSH
18819: LD_EXP 18
18823: PPUSH
18824: LD_INT 1
18826: PPUSH
18827: LD_EXP 18
18831: PUSH
18832: LD_INT 1
18834: ARRAY
18835: PUSH
18836: LD_VAR 0 3
18840: PUSH
18841: LD_VAR 0 3
18845: ARRAY
18846: ADD
18847: PPUSH
18848: CALL_OW 1
18852: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18853: LD_VAR 0 3
18857: PUSH
18858: LD_VAR 0 3
18862: ARRAY
18863: PPUSH
18864: LD_INT 1
18866: PPUSH
18867: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18871: LD_ADDR_VAR 0 3
18875: PUSH
18876: LD_VAR 0 3
18880: PPUSH
18881: LD_VAR 0 3
18885: PPUSH
18886: CALL_OW 3
18890: ST_TO_ADDR
// end else
18891: GO 18970
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18893: LD_ADDR_EXP 18
18897: PUSH
18898: LD_EXP 18
18902: PPUSH
18903: LD_INT 1
18905: PPUSH
18906: LD_EXP 18
18910: PUSH
18911: LD_INT 1
18913: ARRAY
18914: PUSH
18915: LD_VAR 0 2
18919: PUSH
18920: LD_VAR 0 2
18924: ARRAY
18925: ADD
18926: PPUSH
18927: CALL_OW 1
18931: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18932: LD_VAR 0 2
18936: PUSH
18937: LD_VAR 0 2
18941: ARRAY
18942: PPUSH
18943: LD_INT 1
18945: PPUSH
18946: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18950: LD_ADDR_VAR 0 2
18954: PUSH
18955: LD_VAR 0 2
18959: PPUSH
18960: LD_VAR 0 2
18964: PPUSH
18965: CALL_OW 3
18969: ST_TO_ADDR
// end ; end ;
18970: GO 18805
18972: POP
18973: POP
// if tmp2 then
18974: LD_VAR 0 3
18978: IFFALSE 18996
// tmp := tmp union tmp2 ;
18980: LD_ADDR_VAR 0 2
18984: PUSH
18985: LD_VAR 0 2
18989: PUSH
18990: LD_VAR 0 3
18994: UNION
18995: ST_TO_ADDR
// for i = 1 to 4 do
18996: LD_ADDR_VAR 0 1
19000: PUSH
19001: DOUBLE
19002: LD_INT 1
19004: DEC
19005: ST_TO_ADDR
19006: LD_INT 4
19008: PUSH
19009: FOR_TO
19010: IFFALSE 19059
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19012: LD_ADDR_EXP 18
19016: PUSH
19017: LD_EXP 18
19021: PPUSH
19022: LD_INT 2
19024: PPUSH
19025: LD_EXP 18
19029: PUSH
19030: LD_INT 2
19032: ARRAY
19033: PUSH
19034: LD_VAR 0 2
19038: PUSH
19039: LD_VAR 0 2
19043: PUSH
19044: LD_VAR 0 1
19048: MINUS
19049: ARRAY
19050: ADD
19051: PPUSH
19052: CALL_OW 1
19056: ST_TO_ADDR
19057: GO 19009
19059: POP
19060: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19061: LD_ADDR_EXP 102
19065: PUSH
19066: LD_EXP 102
19070: PPUSH
19071: LD_INT 4
19073: PPUSH
19074: LD_EXP 102
19078: PUSH
19079: LD_INT 4
19081: ARRAY
19082: PUSH
19083: LD_EXP 18
19087: PUSH
19088: LD_INT 1
19090: ARRAY
19091: DIFF
19092: PPUSH
19093: CALL_OW 1
19097: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19098: LD_VAR 0 5
19102: PUSH
19103: LD_INT 1
19105: ARRAY
19106: PPUSH
19107: CALL_OW 313
19111: IFFALSE 19166
// begin for i in UnitsInside ( arm [ 1 ] ) do
19113: LD_ADDR_VAR 0 1
19117: PUSH
19118: LD_VAR 0 5
19122: PUSH
19123: LD_INT 1
19125: ARRAY
19126: PPUSH
19127: CALL_OW 313
19131: PUSH
19132: FOR_IN
19133: IFFALSE 19164
// begin ComExitBuilding ( i ) ;
19135: LD_VAR 0 1
19139: PPUSH
19140: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19144: LD_VAR 0 1
19148: PPUSH
19149: LD_VAR 0 6
19153: PUSH
19154: LD_INT 1
19156: ARRAY
19157: PPUSH
19158: CALL_OW 180
// end ;
19162: GO 19132
19164: POP
19165: POP
// end ; wait ( 0 0$3 ) ;
19166: LD_INT 105
19168: PPUSH
19169: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19173: LD_ADDR_VAR 0 1
19177: PUSH
19178: LD_EXP 18
19182: PUSH
19183: LD_INT 1
19185: ARRAY
19186: PUSH
19187: FOR_IN
19188: IFFALSE 19295
// begin if IsInUnit ( i ) then
19190: LD_VAR 0 1
19194: PPUSH
19195: CALL_OW 310
19199: IFFALSE 19210
// ComExitBuilding ( i ) ;
19201: LD_VAR 0 1
19205: PPUSH
19206: CALL_OW 122
// if GetClass ( i ) <> 1 then
19210: LD_VAR 0 1
19214: PPUSH
19215: CALL_OW 257
19219: PUSH
19220: LD_INT 1
19222: NONEQUAL
19223: IFFALSE 19264
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19225: LD_VAR 0 1
19229: PPUSH
19230: LD_VAR 0 5
19234: PUSH
19235: LD_INT 1
19237: ARRAY
19238: PPUSH
19239: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19243: LD_VAR 0 1
19247: PPUSH
19248: LD_INT 1
19250: PPUSH
19251: CALL_OW 183
// AddComExitBuilding ( i ) ;
19255: LD_VAR 0 1
19259: PPUSH
19260: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19264: LD_VAR 0 1
19268: PPUSH
19269: LD_INT 60
19271: PPUSH
19272: LD_INT 94
19274: PPUSH
19275: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19279: LD_VAR 0 1
19283: PPUSH
19284: LD_EXP 58
19288: PPUSH
19289: CALL_OW 179
// end ;
19293: GO 19187
19295: POP
19296: POP
// wait ( 0 0$15 ) ;
19297: LD_INT 525
19299: PPUSH
19300: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19304: LD_EXP 58
19308: PPUSH
19309: LD_STRING D4-Pow-1
19311: PPUSH
19312: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19316: LD_ADDR_VAR 0 2
19320: PUSH
19321: LD_EXP 18
19325: PUSH
19326: LD_INT 1
19328: ARRAY
19329: PPUSH
19330: LD_INT 26
19332: PUSH
19333: LD_INT 1
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PPUSH
19340: CALL_OW 72
19344: ST_TO_ADDR
// if tmp then
19345: LD_VAR 0 2
19349: IFFALSE 19367
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19351: LD_VAR 0 2
19355: PUSH
19356: LD_INT 1
19358: ARRAY
19359: PPUSH
19360: LD_STRING D4-Sol1-1
19362: PPUSH
19363: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19367: LD_EXP 58
19371: PPUSH
19372: LD_STRING D4-Pow-2
19374: PPUSH
19375: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19379: LD_ADDR_VAR 0 1
19383: PUSH
19384: DOUBLE
19385: LD_INT 1
19387: DEC
19388: ST_TO_ADDR
19389: LD_EXP 18
19393: PUSH
19394: LD_INT 1
19396: ARRAY
19397: PUSH
19398: FOR_TO
19399: IFFALSE 19492
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19401: LD_EXP 18
19405: PUSH
19406: LD_INT 1
19408: ARRAY
19409: PUSH
19410: LD_VAR 0 1
19414: ARRAY
19415: PPUSH
19416: LD_EXP 121
19420: PUSH
19421: LD_INT 4
19423: ARRAY
19424: PUSH
19425: LD_INT 1
19427: ARRAY
19428: PPUSH
19429: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19433: LD_ADDR_EXP 121
19437: PUSH
19438: LD_EXP 121
19442: PPUSH
19443: LD_INT 4
19445: PPUSH
19446: LD_EXP 121
19450: PUSH
19451: LD_INT 4
19453: ARRAY
19454: PPUSH
19455: LD_INT 1
19457: PPUSH
19458: CALL_OW 3
19462: PPUSH
19463: CALL_OW 1
19467: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19468: LD_INT 8
19470: PPUSH
19471: LD_EXP 18
19475: PUSH
19476: LD_INT 1
19478: ARRAY
19479: PUSH
19480: LD_VAR 0 1
19484: ARRAY
19485: PPUSH
19486: CALL_OW 471
// end ;
19490: GO 19398
19492: POP
19493: POP
// repeat wait ( 0 0$1 ) ;
19494: LD_INT 35
19496: PPUSH
19497: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19501: LD_EXP 18
19505: PUSH
19506: LD_INT 1
19508: ARRAY
19509: PPUSH
19510: LD_INT 55
19512: PUSH
19513: EMPTY
19514: LIST
19515: PPUSH
19516: CALL_OW 72
19520: PUSH
19521: LD_INT 4
19523: GREATEREQUAL
19524: IFFALSE 19494
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19526: LD_EXP 18
19530: PUSH
19531: LD_INT 1
19533: ARRAY
19534: PPUSH
19535: LD_INT 69
19537: PPUSH
19538: LD_INT 94
19540: PPUSH
19541: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19545: LD_EXP 18
19549: PUSH
19550: LD_INT 1
19552: ARRAY
19553: PPUSH
19554: LD_INT 82
19556: PPUSH
19557: LD_INT 83
19559: PPUSH
19560: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19564: LD_EXP 18
19568: PUSH
19569: LD_INT 1
19571: ARRAY
19572: PPUSH
19573: LD_INT 77
19575: PPUSH
19576: LD_INT 69
19578: PPUSH
19579: CALL_OW 174
// repeat wait ( 3 ) ;
19583: LD_INT 3
19585: PPUSH
19586: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19590: LD_ADDR_VAR 0 1
19594: PUSH
19595: LD_EXP 18
19599: PUSH
19600: LD_INT 1
19602: ARRAY
19603: PUSH
19604: FOR_IN
19605: IFFALSE 19741
// begin if GetLives ( i ) < 990 then
19607: LD_VAR 0 1
19611: PPUSH
19612: CALL_OW 256
19616: PUSH
19617: LD_INT 990
19619: LESS
19620: IFFALSE 19634
// SetLives ( i , 1000 ) ;
19622: LD_VAR 0 1
19626: PPUSH
19627: LD_INT 1000
19629: PPUSH
19630: CALL_OW 234
// if not IsInUnit ( i ) then
19634: LD_VAR 0 1
19638: PPUSH
19639: CALL_OW 310
19643: NOT
19644: IFFALSE 19739
// begin if not HasTask ( i ) then
19646: LD_VAR 0 1
19650: PPUSH
19651: CALL_OW 314
19655: NOT
19656: IFFALSE 19673
// ComMoveXY ( i , 64 , 93 ) ;
19658: LD_VAR 0 1
19662: PPUSH
19663: LD_INT 64
19665: PPUSH
19666: LD_INT 93
19668: PPUSH
19669: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19673: LD_VAR 0 4
19677: NOT
19678: PUSH
19679: LD_VAR 0 1
19683: PPUSH
19684: CALL_OW 258
19688: PUSH
19689: LD_INT 1
19691: EQUAL
19692: AND
19693: IFFALSE 19739
// begin retreat := true ;
19695: LD_ADDR_VAR 0 4
19699: PUSH
19700: LD_INT 1
19702: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19703: LD_VAR 0 1
19707: PPUSH
19708: LD_INT 2
19710: PPUSH
19711: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19715: LD_VAR 0 1
19719: PPUSH
19720: LD_STRING D4a-Sol1-1
19722: PPUSH
19723: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19727: LD_EXP 58
19731: PPUSH
19732: LD_STRING D4a-Pow-1
19734: PPUSH
19735: CALL_OW 88
// end ; end ; end ;
19739: GO 19604
19741: POP
19742: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19743: LD_EXP 18
19747: PUSH
19748: LD_INT 1
19750: ARRAY
19751: PPUSH
19752: LD_INT 95
19754: PUSH
19755: LD_INT 9
19757: PUSH
19758: EMPTY
19759: LIST
19760: LIST
19761: PUSH
19762: LD_INT 3
19764: PUSH
19765: LD_INT 55
19767: PUSH
19768: EMPTY
19769: LIST
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PPUSH
19779: CALL_OW 72
19783: PUSH
19784: LD_INT 4
19786: GREATEREQUAL
19787: IFFALSE 19583
// for i in powellSquadAttack [ 1 ] do
19789: LD_ADDR_VAR 0 1
19793: PUSH
19794: LD_EXP 18
19798: PUSH
19799: LD_INT 1
19801: ARRAY
19802: PUSH
19803: FOR_IN
19804: IFFALSE 19940
// begin if GetTag ( i ) = 2 then
19806: LD_VAR 0 1
19810: PPUSH
19811: CALL_OW 110
19815: PUSH
19816: LD_INT 2
19818: EQUAL
19819: IFFALSE 19881
// begin ComMoveXY ( i , 60 , 94 ) ;
19821: LD_VAR 0 1
19825: PPUSH
19826: LD_INT 60
19828: PPUSH
19829: LD_INT 94
19831: PPUSH
19832: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19836: LD_VAR 0 1
19840: PPUSH
19841: LD_EXP 58
19845: PPUSH
19846: CALL_OW 179
// wait ( 0 0$3 ) ;
19850: LD_INT 105
19852: PPUSH
19853: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19857: LD_VAR 0 1
19861: PPUSH
19862: LD_STRING D4a-Sol1-2
19864: PPUSH
19865: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19869: LD_EXP 58
19873: PPUSH
19874: LD_STRING D4a-Pow-2
19876: PPUSH
19877: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19881: LD_VAR 0 1
19885: PPUSH
19886: LD_INT 0
19888: PPUSH
19889: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19893: LD_ADDR_EXP 102
19897: PUSH
19898: LD_EXP 102
19902: PPUSH
19903: LD_INT 4
19905: PPUSH
19906: LD_EXP 102
19910: PUSH
19911: LD_INT 4
19913: ARRAY
19914: PUSH
19915: LD_VAR 0 1
19919: UNION
19920: PPUSH
19921: CALL_OW 1
19925: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19926: LD_INT 8
19928: PPUSH
19929: LD_VAR 0 1
19933: PPUSH
19934: CALL_OW 472
// end ;
19938: GO 19803
19940: POP
19941: POP
// wait ( 4 4$00 ) ;
19942: LD_INT 8400
19944: PPUSH
19945: CALL_OW 67
// uc_side := 6 ;
19949: LD_ADDR_OWVAR 20
19953: PUSH
19954: LD_INT 6
19956: ST_TO_ADDR
// uc_nation := 3 ;
19957: LD_ADDR_OWVAR 21
19961: PUSH
19962: LD_INT 3
19964: ST_TO_ADDR
// ru := [ ] ;
19965: LD_ADDR_VAR 0 7
19969: PUSH
19970: EMPTY
19971: ST_TO_ADDR
// for i = 1 to 4 do
19972: LD_ADDR_VAR 0 1
19976: PUSH
19977: DOUBLE
19978: LD_INT 1
19980: DEC
19981: ST_TO_ADDR
19982: LD_INT 4
19984: PUSH
19985: FOR_TO
19986: IFFALSE 20087
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19988: LD_INT 22
19990: PPUSH
19991: LD_INT 1
19993: PPUSH
19994: LD_INT 3
19996: PPUSH
19997: LD_INT 43
19999: PUSH
20000: LD_INT 44
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: PUSH
20007: LD_INT 1
20009: PPUSH
20010: LD_INT 2
20012: PPUSH
20013: CALL_OW 12
20017: ARRAY
20018: PPUSH
20019: LD_INT 89
20021: PPUSH
20022: CALL 71893 0 5
// un := CreateVehicle ;
20026: LD_ADDR_VAR 0 8
20030: PUSH
20031: CALL_OW 45
20035: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20036: LD_VAR 0 8
20040: PPUSH
20041: LD_INT 4
20043: PPUSH
20044: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20048: LD_VAR 0 8
20052: PPUSH
20053: LD_INT 136
20055: PPUSH
20056: LD_INT 90
20058: PPUSH
20059: LD_INT 8
20061: PPUSH
20062: LD_INT 0
20064: PPUSH
20065: CALL_OW 50
// ru := ru ^ un ;
20069: LD_ADDR_VAR 0 7
20073: PUSH
20074: LD_VAR 0 7
20078: PUSH
20079: LD_VAR 0 8
20083: ADD
20084: ST_TO_ADDR
// end ;
20085: GO 19985
20087: POP
20088: POP
// if ru then
20089: LD_VAR 0 7
20093: IFFALSE 20110
// ComAgressiveMove ( ru , 80 , 92 ) ;
20095: LD_VAR 0 7
20099: PPUSH
20100: LD_INT 80
20102: PPUSH
20103: LD_INT 92
20105: PPUSH
20106: CALL_OW 114
// wait ( 8 8$00 ) ;
20110: LD_INT 16800
20112: PPUSH
20113: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20117: LD_INT 4
20119: PPUSH
20120: LD_INT 3
20122: PUSH
20123: LD_INT 1
20125: PUSH
20126: LD_INT 1
20128: PUSH
20129: LD_INT 5
20131: PUSH
20132: EMPTY
20133: LIST
20134: LIST
20135: LIST
20136: LIST
20137: PUSH
20138: LD_INT 4
20140: PUSH
20141: LD_INT 1
20143: PUSH
20144: LD_INT 1
20146: PUSH
20147: LD_INT 6
20149: PUSH
20150: EMPTY
20151: LIST
20152: LIST
20153: LIST
20154: LIST
20155: PUSH
20156: LD_INT 4
20158: PUSH
20159: LD_INT 1
20161: PUSH
20162: LD_INT 1
20164: PUSH
20165: LD_INT 7
20167: PUSH
20168: EMPTY
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: PUSH
20174: LD_INT 3
20176: PUSH
20177: LD_INT 1
20179: PUSH
20180: LD_INT 1
20182: PUSH
20183: LD_INT 7
20185: PUSH
20186: EMPTY
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: PUSH
20192: LD_INT 3
20194: PUSH
20195: LD_INT 1
20197: PUSH
20198: LD_INT 1
20200: PUSH
20201: LD_INT 5
20203: PUSH
20204: EMPTY
20205: LIST
20206: LIST
20207: LIST
20208: LIST
20209: PUSH
20210: EMPTY
20211: LIST
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: PPUSH
20217: CALL 58386 0 2
// missionStage := 4 ;
20221: LD_ADDR_EXP 15
20225: PUSH
20226: LD_INT 4
20228: ST_TO_ADDR
// end ;
20229: PPOPN 8
20231: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20232: LD_EXP 15
20236: PUSH
20237: LD_INT 4
20239: EQUAL
20240: PUSH
20241: LD_INT 22
20243: PUSH
20244: LD_INT 4
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PUSH
20251: LD_INT 21
20253: PUSH
20254: LD_INT 2
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: PPUSH
20265: CALL_OW 69
20269: PUSH
20270: LD_INT 5
20272: GREATEREQUAL
20273: AND
20274: IFFALSE 24379
20276: GO 20278
20278: DISABLE
20279: LD_INT 0
20281: PPUSH
20282: PPUSH
20283: PPUSH
20284: PPUSH
20285: PPUSH
20286: PPUSH
20287: PPUSH
20288: PPUSH
20289: PPUSH
20290: PPUSH
20291: PPUSH
20292: PPUSH
20293: PPUSH
// begin missionStage := 5 ;
20294: LD_ADDR_EXP 15
20298: PUSH
20299: LD_INT 5
20301: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20302: LD_ADDR_VAR 0 10
20306: PUSH
20307: LD_INT 22
20309: PUSH
20310: LD_INT 4
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: PUSH
20317: LD_INT 2
20319: PUSH
20320: LD_INT 30
20322: PUSH
20323: LD_INT 4
20325: PUSH
20326: EMPTY
20327: LIST
20328: LIST
20329: PUSH
20330: LD_INT 30
20332: PUSH
20333: LD_INT 5
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: PUSH
20340: EMPTY
20341: LIST
20342: LIST
20343: LIST
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: PPUSH
20349: CALL_OW 69
20353: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20354: LD_ADDR_VAR 0 6
20358: PUSH
20359: LD_INT 22
20361: PUSH
20362: LD_INT 4
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: PUSH
20369: LD_INT 21
20371: PUSH
20372: LD_INT 1
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: PUSH
20379: LD_INT 3
20381: PUSH
20382: LD_INT 25
20384: PUSH
20385: LD_INT 16
20387: PUSH
20388: EMPTY
20389: LIST
20390: LIST
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: LD_INT 3
20398: PUSH
20399: LD_INT 25
20401: PUSH
20402: LD_INT 12
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: LIST
20417: LIST
20418: PPUSH
20419: CALL_OW 69
20423: PUSH
20424: LD_EXP 58
20428: DIFF
20429: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20430: LD_ADDR_VAR 0 9
20434: PUSH
20435: LD_INT 22
20437: PUSH
20438: LD_INT 4
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: PUSH
20445: LD_INT 30
20447: PUSH
20448: LD_INT 3
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: PUSH
20455: EMPTY
20456: LIST
20457: LIST
20458: PPUSH
20459: CALL_OW 69
20463: PUSH
20464: LD_INT 1
20466: ARRAY
20467: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20468: LD_INT 35
20470: PPUSH
20471: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20475: LD_EXP 121
20479: PUSH
20480: LD_INT 4
20482: ARRAY
20483: PUSH
20484: LD_INT 5
20486: GREATEREQUAL
20487: PUSH
20488: LD_EXP 121
20492: PUSH
20493: LD_INT 4
20495: ARRAY
20496: PPUSH
20497: LD_INT 58
20499: PUSH
20500: EMPTY
20501: LIST
20502: PPUSH
20503: CALL_OW 72
20507: PUSH
20508: LD_INT 5
20510: GREATEREQUAL
20511: AND
20512: IFFALSE 20468
// powellAllowRetreat := false ;
20514: LD_ADDR_EXP 19
20518: PUSH
20519: LD_INT 0
20521: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20522: LD_INT 700
20524: PPUSH
20525: CALL_OW 67
// activeAttacks := false ;
20529: LD_ADDR_EXP 16
20533: PUSH
20534: LD_INT 0
20536: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20537: LD_INT 35
20539: PPUSH
20540: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20544: LD_INT 22
20546: PUSH
20547: LD_INT 6
20549: PUSH
20550: EMPTY
20551: LIST
20552: LIST
20553: PPUSH
20554: CALL_OW 69
20558: PUSH
20559: LD_INT 0
20561: EQUAL
20562: IFFALSE 20537
// tmp := mc_vehicles [ 4 ] ;
20564: LD_ADDR_VAR 0 3
20568: PUSH
20569: LD_EXP 121
20573: PUSH
20574: LD_INT 4
20576: ARRAY
20577: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20578: LD_ADDR_VAR 0 1
20582: PUSH
20583: DOUBLE
20584: LD_INT 1
20586: DEC
20587: ST_TO_ADDR
20588: LD_EXP 18
20592: PUSH
20593: FOR_TO
20594: IFFALSE 20855
// begin for j in powellSquadAttack [ i ] do
20596: LD_ADDR_VAR 0 2
20600: PUSH
20601: LD_EXP 18
20605: PUSH
20606: LD_VAR 0 1
20610: ARRAY
20611: PUSH
20612: FOR_IN
20613: IFFALSE 20851
// begin forces := forces diff j ;
20615: LD_ADDR_VAR 0 6
20619: PUSH
20620: LD_VAR 0 6
20624: PUSH
20625: LD_VAR 0 2
20629: DIFF
20630: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20631: LD_VAR 0 2
20635: PPUSH
20636: LD_INT 1
20638: PPUSH
20639: CALL_OW 109
// wait ( 0 0$2 ) ;
20643: LD_INT 70
20645: PPUSH
20646: CALL_OW 67
// if IsInUnit ( j ) then
20650: LD_VAR 0 2
20654: PPUSH
20655: CALL_OW 310
20659: IFFALSE 20670
// ComExitBuilding ( j ) ;
20661: LD_VAR 0 2
20665: PPUSH
20666: CALL_OW 122
// if GetClass ( j ) <> 1 then
20670: LD_VAR 0 2
20674: PPUSH
20675: CALL_OW 257
20679: PUSH
20680: LD_INT 1
20682: NONEQUAL
20683: IFFALSE 20763
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20685: LD_VAR 0 10
20689: PUSH
20690: LD_INT 1
20692: ARRAY
20693: PPUSH
20694: CALL_OW 313
20698: PUSH
20699: LD_INT 5
20701: GREATEREQUAL
20702: IFFALSE 20724
// AddComEnterUnit ( j , arm [ 2 ] ) else
20704: LD_VAR 0 2
20708: PPUSH
20709: LD_VAR 0 10
20713: PUSH
20714: LD_INT 2
20716: ARRAY
20717: PPUSH
20718: CALL_OW 180
20722: GO 20742
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20724: LD_VAR 0 2
20728: PPUSH
20729: LD_VAR 0 10
20733: PUSH
20734: LD_INT 1
20736: ARRAY
20737: PPUSH
20738: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20742: LD_VAR 0 2
20746: PPUSH
20747: LD_INT 1
20749: PPUSH
20750: CALL_OW 183
// AddComExitBuilding ( j ) ;
20754: LD_VAR 0 2
20758: PPUSH
20759: CALL_OW 182
// end ; if i = 2 then
20763: LD_VAR 0 1
20767: PUSH
20768: LD_INT 2
20770: EQUAL
20771: IFFALSE 20788
// AddComMoveXY ( j , 61 , 93 ) ;
20773: LD_VAR 0 2
20777: PPUSH
20778: LD_INT 61
20780: PPUSH
20781: LD_INT 93
20783: PPUSH
20784: CALL_OW 171
// if i = 1 then
20788: LD_VAR 0 1
20792: PUSH
20793: LD_INT 1
20795: EQUAL
20796: IFFALSE 20849
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20798: LD_VAR 0 2
20802: PPUSH
20803: LD_VAR 0 3
20807: PUSH
20808: LD_INT 1
20810: ARRAY
20811: PPUSH
20812: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20816: LD_ADDR_VAR 0 3
20820: PUSH
20821: LD_VAR 0 3
20825: PPUSH
20826: LD_INT 1
20828: PPUSH
20829: CALL_OW 3
20833: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20834: LD_VAR 0 2
20838: PPUSH
20839: LD_INT 69
20841: PPUSH
20842: LD_INT 94
20844: PPUSH
20845: CALL_OW 171
// end ; end ;
20849: GO 20612
20851: POP
20852: POP
// end ;
20853: GO 20593
20855: POP
20856: POP
// wait ( 0 0$55 ) ;
20857: LD_INT 1925
20859: PPUSH
20860: CALL_OW 67
// MC_Kill ( 4 ) ;
20864: LD_INT 4
20866: PPUSH
20867: CALL 34974 0 1
// tmp := UnitsInside ( fac ) ;
20871: LD_ADDR_VAR 0 3
20875: PUSH
20876: LD_VAR 0 9
20880: PPUSH
20881: CALL_OW 313
20885: ST_TO_ADDR
// if tmp then
20886: LD_VAR 0 3
20890: IFFALSE 21011
// for i in tmp do
20892: LD_ADDR_VAR 0 1
20896: PUSH
20897: LD_VAR 0 3
20901: PUSH
20902: FOR_IN
20903: IFFALSE 21009
// begin ComExitBuilding ( i ) ;
20905: LD_VAR 0 1
20909: PPUSH
20910: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20914: LD_VAR 0 10
20918: PUSH
20919: LD_INT 2
20921: ARRAY
20922: PPUSH
20923: CALL_OW 313
20927: PUSH
20928: LD_INT 6
20930: LESS
20931: IFFALSE 20953
// AddComEnterUnit ( i , arm [ 2 ] ) else
20933: LD_VAR 0 1
20937: PPUSH
20938: LD_VAR 0 10
20942: PUSH
20943: LD_INT 2
20945: ARRAY
20946: PPUSH
20947: CALL_OW 180
20951: GO 21007
// if UnitsInside ( arm [ 1 ] ) < 6 then
20953: LD_VAR 0 10
20957: PUSH
20958: LD_INT 1
20960: ARRAY
20961: PPUSH
20962: CALL_OW 313
20966: PUSH
20967: LD_INT 6
20969: LESS
20970: IFFALSE 20992
// AddComEnterUnit ( i , arm [ 1 ] ) else
20972: LD_VAR 0 1
20976: PPUSH
20977: LD_VAR 0 10
20981: PUSH
20982: LD_INT 1
20984: ARRAY
20985: PPUSH
20986: CALL_OW 180
20990: GO 21007
// AddComMoveXY ( i , 37 , 68 ) ;
20992: LD_VAR 0 1
20996: PPUSH
20997: LD_INT 37
20999: PPUSH
21000: LD_INT 68
21002: PPUSH
21003: CALL_OW 171
// end ;
21007: GO 20902
21009: POP
21010: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21011: LD_ADDR_VAR 0 11
21015: PUSH
21016: LD_VAR 0 6
21020: PPUSH
21021: LD_INT 26
21023: PUSH
21024: LD_INT 1
21026: PUSH
21027: EMPTY
21028: LIST
21029: LIST
21030: PPUSH
21031: CALL_OW 72
21035: PUSH
21036: LD_EXP 59
21040: DIFF
21041: ST_TO_ADDR
// if not speaker then
21042: LD_VAR 0 11
21046: NOT
21047: IFFALSE 21074
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21049: LD_ADDR_VAR 0 11
21053: PUSH
21054: LD_VAR 0 6
21058: PPUSH
21059: LD_INT 26
21061: PUSH
21062: LD_INT 1
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: PPUSH
21069: CALL_OW 72
21073: ST_TO_ADDR
// if speaker then
21074: LD_VAR 0 11
21078: IFFALSE 21094
// speaker := speaker [ 1 ] ;
21080: LD_ADDR_VAR 0 11
21084: PUSH
21085: LD_VAR 0 11
21089: PUSH
21090: LD_INT 1
21092: ARRAY
21093: ST_TO_ADDR
// Video ( true ) ;
21094: LD_INT 1
21096: PPUSH
21097: CALL 107620 0 1
// CenterNowOnUnits ( Powell ) ;
21101: LD_EXP 58
21105: PPUSH
21106: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21110: LD_ADDR_VAR 0 3
21114: PUSH
21115: LD_VAR 0 6
21119: PPUSH
21120: LD_INT 3
21122: PUSH
21123: LD_INT 25
21125: PUSH
21126: LD_INT 1
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: PUSH
21133: EMPTY
21134: LIST
21135: LIST
21136: PPUSH
21137: CALL_OW 72
21141: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21142: LD_ADDR_VAR 0 12
21146: PUSH
21147: LD_INT 22
21149: PUSH
21150: LD_INT 4
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: PUSH
21157: LD_INT 30
21159: PUSH
21160: LD_INT 32
21162: PUSH
21163: EMPTY
21164: LIST
21165: LIST
21166: PUSH
21167: LD_INT 58
21169: PUSH
21170: EMPTY
21171: LIST
21172: PUSH
21173: EMPTY
21174: LIST
21175: LIST
21176: LIST
21177: PPUSH
21178: CALL_OW 69
21182: ST_TO_ADDR
// for i = 1 to 6 do
21183: LD_ADDR_VAR 0 1
21187: PUSH
21188: DOUBLE
21189: LD_INT 1
21191: DEC
21192: ST_TO_ADDR
21193: LD_INT 6
21195: PUSH
21196: FOR_TO
21197: IFFALSE 21338
// begin if IsInUnit ( tmp [ i ] ) then
21199: LD_VAR 0 3
21203: PUSH
21204: LD_VAR 0 1
21208: ARRAY
21209: PPUSH
21210: CALL_OW 310
21214: IFFALSE 21231
// ComExitBuilding ( tmp [ i ] ) ;
21216: LD_VAR 0 3
21220: PUSH
21221: LD_VAR 0 1
21225: ARRAY
21226: PPUSH
21227: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21231: LD_VAR 0 3
21235: PUSH
21236: LD_VAR 0 1
21240: ARRAY
21241: PPUSH
21242: LD_VAR 0 10
21246: PUSH
21247: LD_INT 1
21249: ARRAY
21250: PPUSH
21251: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21255: LD_VAR 0 3
21259: PUSH
21260: LD_VAR 0 1
21264: ARRAY
21265: PPUSH
21266: LD_INT 1
21268: PPUSH
21269: CALL_OW 183
// if emp_towers then
21273: LD_VAR 0 12
21277: IFFALSE 21336
// begin AddComExitBuilding ( tmp [ i ] ) ;
21279: LD_VAR 0 3
21283: PUSH
21284: LD_VAR 0 1
21288: ARRAY
21289: PPUSH
21290: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21294: LD_VAR 0 3
21298: PUSH
21299: LD_VAR 0 1
21303: ARRAY
21304: PPUSH
21305: LD_VAR 0 12
21309: PUSH
21310: LD_INT 1
21312: ARRAY
21313: PPUSH
21314: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21318: LD_ADDR_VAR 0 12
21322: PUSH
21323: LD_VAR 0 12
21327: PPUSH
21328: LD_INT 1
21330: PPUSH
21331: CALL_OW 3
21335: ST_TO_ADDR
// end ; end ;
21336: GO 21196
21338: POP
21339: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21340: LD_ADDR_VAR 0 3
21344: PUSH
21345: LD_EXP 18
21349: PUSH
21350: LD_INT 1
21352: ARRAY
21353: PUSH
21354: LD_EXP 18
21358: PUSH
21359: LD_INT 2
21361: ARRAY
21362: ADD
21363: PPUSH
21364: LD_INT 26
21366: PUSH
21367: LD_INT 1
21369: PUSH
21370: EMPTY
21371: LIST
21372: LIST
21373: PPUSH
21374: CALL_OW 72
21378: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21379: LD_ADDR_VAR 0 1
21383: PUSH
21384: LD_EXP 18
21388: PUSH
21389: LD_INT 2
21391: ARRAY
21392: PUSH
21393: FOR_IN
21394: IFFALSE 21412
// ComTurnUnit ( i , Powell ) ;
21396: LD_VAR 0 1
21400: PPUSH
21401: LD_EXP 58
21405: PPUSH
21406: CALL_OW 119
21410: GO 21393
21412: POP
21413: POP
// Say ( Powell , D5-Pow-1 ) ;
21414: LD_EXP 58
21418: PPUSH
21419: LD_STRING D5-Pow-1
21421: PPUSH
21422: CALL_OW 88
// if tmp then
21426: LD_VAR 0 3
21430: IFFALSE 21448
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21432: LD_VAR 0 3
21436: PUSH
21437: LD_INT 1
21439: ARRAY
21440: PPUSH
21441: LD_STRING D5-Sol2-1
21443: PPUSH
21444: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21448: LD_EXP 58
21452: PPUSH
21453: LD_STRING D5-Pow-2
21455: PPUSH
21456: CALL_OW 88
// if tmp > 1 then
21460: LD_VAR 0 3
21464: PUSH
21465: LD_INT 1
21467: GREATER
21468: IFFALSE 21486
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21470: LD_VAR 0 3
21474: PUSH
21475: LD_INT 2
21477: ARRAY
21478: PPUSH
21479: LD_STRING D5-Sol2-2
21481: PPUSH
21482: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21486: LD_EXP 58
21490: PPUSH
21491: LD_STRING D5-Pow-3
21493: PPUSH
21494: CALL_OW 88
// wait ( 0 0$1 ) ;
21498: LD_INT 35
21500: PPUSH
21501: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21505: LD_ADDR_VAR 0 3
21509: PUSH
21510: LD_EXP 18
21514: PUSH
21515: LD_INT 1
21517: ARRAY
21518: PUSH
21519: LD_EXP 18
21523: PUSH
21524: LD_INT 2
21526: ARRAY
21527: UNION
21528: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21529: LD_VAR 0 3
21533: PPUSH
21534: LD_INT 80
21536: PPUSH
21537: LD_INT 67
21539: PPUSH
21540: CALL_OW 114
// wait ( 0 0$2 ) ;
21544: LD_INT 70
21546: PPUSH
21547: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21551: LD_INT 79
21553: PPUSH
21554: LD_INT 72
21556: PPUSH
21557: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21561: LD_INT 35
21563: PPUSH
21564: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21568: LD_VAR 0 3
21572: PPUSH
21573: LD_INT 3
21575: PUSH
21576: LD_INT 24
21578: PUSH
21579: LD_INT 1000
21581: PUSH
21582: EMPTY
21583: LIST
21584: LIST
21585: PUSH
21586: EMPTY
21587: LIST
21588: LIST
21589: PPUSH
21590: CALL_OW 72
21594: IFFALSE 21561
// Say ( Powell , D5a-Pow-1 ) ;
21596: LD_EXP 58
21600: PPUSH
21601: LD_STRING D5a-Pow-1
21603: PPUSH
21604: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21608: LD_EXP 58
21612: PPUSH
21613: LD_STRING D5a-Pow-1a
21615: PPUSH
21616: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21620: LD_INT 10
21622: PPUSH
21623: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21627: LD_EXP 58
21631: PPUSH
21632: LD_STRING D5a-Pow-1b
21634: PPUSH
21635: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21639: LD_EXP 58
21643: PPUSH
21644: LD_STRING D5a-Pow-1c
21646: PPUSH
21647: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21651: LD_EXP 58
21655: PPUSH
21656: LD_STRING D5a-Pow-1d
21658: PPUSH
21659: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21663: LD_INT 35
21665: PPUSH
21666: CALL_OW 67
// if not HasTask ( tmp ) then
21670: LD_VAR 0 3
21674: PPUSH
21675: CALL_OW 314
21679: NOT
21680: IFFALSE 21697
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21682: LD_VAR 0 3
21686: PPUSH
21687: LD_INT 80
21689: PPUSH
21690: LD_INT 67
21692: PPUSH
21693: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21697: LD_VAR 0 3
21701: PPUSH
21702: LD_INT 24
21704: PUSH
21705: LD_INT 1
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PPUSH
21712: CALL_OW 72
21716: NOT
21717: IFFALSE 21663
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21719: LD_ADDR_VAR 0 3
21723: PUSH
21724: LD_INT 22
21726: PUSH
21727: LD_INT 4
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: PUSH
21734: LD_INT 92
21736: PUSH
21737: LD_INT 60
21739: PUSH
21740: LD_INT 93
21742: PUSH
21743: LD_INT 10
21745: PUSH
21746: EMPTY
21747: LIST
21748: LIST
21749: LIST
21750: LIST
21751: PUSH
21752: LD_INT 3
21754: PUSH
21755: LD_INT 54
21757: PUSH
21758: EMPTY
21759: LIST
21760: PUSH
21761: EMPTY
21762: LIST
21763: LIST
21764: PUSH
21765: EMPTY
21766: LIST
21767: LIST
21768: LIST
21769: PPUSH
21770: CALL_OW 69
21774: PUSH
21775: LD_EXP 58
21779: DIFF
21780: ST_TO_ADDR
// if tmp then
21781: LD_VAR 0 3
21785: IFFALSE 21819
// for i in tmp do
21787: LD_ADDR_VAR 0 1
21791: PUSH
21792: LD_VAR 0 3
21796: PUSH
21797: FOR_IN
21798: IFFALSE 21817
// ComMoveXY ( i , 36 , 67 ) ;
21800: LD_VAR 0 1
21804: PPUSH
21805: LD_INT 36
21807: PPUSH
21808: LD_INT 67
21810: PPUSH
21811: CALL_OW 111
21815: GO 21797
21817: POP
21818: POP
// wait ( 0 0$3 ) ;
21819: LD_INT 105
21821: PPUSH
21822: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21826: LD_VAR 0 11
21830: PPUSH
21831: LD_STRING D6-Sol3-1
21833: PPUSH
21834: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21838: LD_EXP 58
21842: PPUSH
21843: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21847: LD_EXP 58
21851: PPUSH
21852: LD_STRING D6-Pow-1
21854: PPUSH
21855: CALL_OW 88
// tmp := [ ] ;
21859: LD_ADDR_VAR 0 3
21863: PUSH
21864: EMPTY
21865: ST_TO_ADDR
// for i = 1 to 2 do
21866: LD_ADDR_VAR 0 1
21870: PUSH
21871: DOUBLE
21872: LD_INT 1
21874: DEC
21875: ST_TO_ADDR
21876: LD_INT 2
21878: PUSH
21879: FOR_TO
21880: IFFALSE 21994
// begin uc_side := 8 ;
21882: LD_ADDR_OWVAR 20
21886: PUSH
21887: LD_INT 8
21889: ST_TO_ADDR
// uc_nation := 2 ;
21890: LD_ADDR_OWVAR 21
21894: PUSH
21895: LD_INT 2
21897: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21898: LD_INT 14
21900: PPUSH
21901: LD_INT 3
21903: PPUSH
21904: LD_INT 2
21906: PPUSH
21907: LD_INT 29
21909: PPUSH
21910: LD_INT 100
21912: PPUSH
21913: CALL 71893 0 5
// veh := CreateVehicle ;
21917: LD_ADDR_VAR 0 13
21921: PUSH
21922: CALL_OW 45
21926: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21927: LD_VAR 0 13
21931: PPUSH
21932: LD_INT 4
21934: PPUSH
21935: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21939: LD_VAR 0 13
21943: PPUSH
21944: LD_INT 99
21946: PPUSH
21947: LD_INT 83
21949: PPUSH
21950: LD_INT 6
21952: PPUSH
21953: LD_INT 0
21955: PPUSH
21956: CALL_OW 50
// wait ( 3 ) ;
21960: LD_INT 3
21962: PPUSH
21963: CALL_OW 67
// Connect ( veh ) ;
21967: LD_VAR 0 13
21971: PPUSH
21972: CALL 74948 0 1
// tmp := tmp ^ veh ;
21976: LD_ADDR_VAR 0 3
21980: PUSH
21981: LD_VAR 0 3
21985: PUSH
21986: LD_VAR 0 13
21990: ADD
21991: ST_TO_ADDR
// end ;
21992: GO 21879
21994: POP
21995: POP
// wait ( 0 0$1 ) ;
21996: LD_INT 35
21998: PPUSH
21999: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22003: LD_INT 99
22005: PPUSH
22006: LD_INT 83
22008: PPUSH
22009: LD_INT 1
22011: PPUSH
22012: LD_INT 10
22014: PPUSH
22015: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22019: LD_INT 99
22021: PPUSH
22022: LD_INT 83
22024: PPUSH
22025: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22029: LD_VAR 0 11
22033: PPUSH
22034: LD_STRING D6-Sol3-2
22036: PPUSH
22037: CALL_OW 88
// async ;
22041: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22042: LD_EXP 58
22046: PPUSH
22047: LD_STRING D6-Pow-2
22049: PPUSH
22050: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22054: LD_VAR 0 3
22058: PUSH
22059: LD_INT 1
22061: ARRAY
22062: PPUSH
22063: LD_VAR 0 9
22067: PPUSH
22068: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22072: LD_VAR 0 3
22076: PUSH
22077: LD_INT 2
22079: ARRAY
22080: PPUSH
22081: LD_INT 22
22083: PUSH
22084: LD_INT 4
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 21
22093: PUSH
22094: LD_INT 3
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: PPUSH
22105: CALL_OW 69
22109: PPUSH
22110: LD_VAR 0 3
22114: PUSH
22115: LD_INT 2
22117: ARRAY
22118: PPUSH
22119: CALL_OW 74
22123: PPUSH
22124: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22128: LD_EXP 58
22132: PPUSH
22133: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22137: LD_INT 99
22139: PPUSH
22140: LD_INT 83
22142: PPUSH
22143: LD_INT 1
22145: PPUSH
22146: CALL_OW 331
// repeat wait ( 4 ) ;
22150: LD_INT 4
22152: PPUSH
22153: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22157: LD_VAR 0 3
22161: PUSH
22162: LD_INT 1
22164: ARRAY
22165: PPUSH
22166: CALL_OW 256
22170: PUSH
22171: LD_INT 1000
22173: LESS
22174: IFFALSE 22192
// SetLives ( tmp [ 1 ] , 1000 ) ;
22176: LD_VAR 0 3
22180: PUSH
22181: LD_INT 1
22183: ARRAY
22184: PPUSH
22185: LD_INT 1000
22187: PPUSH
22188: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22192: LD_INT 22
22194: PUSH
22195: LD_INT 4
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: PUSH
22202: LD_INT 30
22204: PUSH
22205: LD_INT 3
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PPUSH
22216: CALL_OW 69
22220: PUSH
22221: LD_INT 0
22223: EQUAL
22224: IFFALSE 22150
// sync ;
22226: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22227: LD_EXP 58
22231: PPUSH
22232: LD_STRING D6a-Pow-1
22234: PPUSH
22235: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22239: LD_VAR 0 11
22243: PPUSH
22244: LD_STRING D6a-Sol3-1
22246: PPUSH
22247: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22251: LD_EXP 58
22255: PPUSH
22256: LD_STRING D6a-Pow-2
22258: PPUSH
22259: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22263: LD_VAR 0 11
22267: PPUSH
22268: LD_STRING D6a-Sol3-2
22270: PPUSH
22271: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22275: LD_EXP 58
22279: PPUSH
22280: LD_STRING D6a-Pow-3
22282: PPUSH
22283: CALL_OW 88
// powellCenterCameraMode := true ;
22287: LD_ADDR_EXP 20
22291: PUSH
22292: LD_INT 1
22294: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22295: LD_ADDR_VAR 0 1
22299: PUSH
22300: LD_INT 22
22302: PUSH
22303: LD_INT 8
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: PUSH
22310: LD_INT 25
22312: PUSH
22313: LD_INT 2
22315: PUSH
22316: EMPTY
22317: LIST
22318: LIST
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PPUSH
22324: CALL_OW 69
22328: PUSH
22329: FOR_IN
22330: IFFALSE 22385
// begin SetTag ( i , 1 ) ;
22332: LD_VAR 0 1
22336: PPUSH
22337: LD_INT 1
22339: PPUSH
22340: CALL_OW 109
// ComExitBuilding ( i ) ;
22344: LD_VAR 0 1
22348: PPUSH
22349: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22353: LD_VAR 0 1
22357: PPUSH
22358: LD_INT 35
22360: PPUSH
22361: LD_INT 6
22363: PPUSH
22364: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22368: LD_VAR 0 1
22372: PPUSH
22373: LD_INT 53
22375: PPUSH
22376: LD_INT 4
22378: PPUSH
22379: CALL_OW 171
// end ;
22383: GO 22329
22385: POP
22386: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22387: LD_ADDR_VAR 0 3
22391: PUSH
22392: LD_INT 22
22394: PUSH
22395: LD_INT 4
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PUSH
22402: LD_INT 21
22404: PUSH
22405: LD_INT 2
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: PUSH
22412: LD_INT 3
22414: PUSH
22415: LD_INT 34
22417: PUSH
22418: LD_INT 12
22420: PUSH
22421: EMPTY
22422: LIST
22423: LIST
22424: PUSH
22425: EMPTY
22426: LIST
22427: LIST
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: LIST
22433: PPUSH
22434: CALL_OW 69
22438: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22439: LD_EXP 58
22443: PPUSH
22444: LD_VAR 0 3
22448: PPUSH
22449: LD_EXP 58
22453: PPUSH
22454: CALL_OW 74
22458: PPUSH
22459: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22463: LD_EXP 58
22467: PPUSH
22468: LD_INT 100
22470: PPUSH
22471: LD_INT 88
22473: PPUSH
22474: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22478: LD_EXP 58
22482: PPUSH
22483: LD_INT 100
22485: PPUSH
22486: LD_INT 75
22488: PPUSH
22489: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22493: LD_EXP 58
22497: PPUSH
22498: LD_INT 88
22500: PPUSH
22501: LD_INT 53
22503: PPUSH
22504: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22508: LD_INT 8
22510: PPUSH
22511: LD_EXP 58
22515: PPUSH
22516: CALL_OW 471
// repeat wait ( 3 ) ;
22520: LD_INT 3
22522: PPUSH
22523: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22527: LD_INT 22
22529: PUSH
22530: LD_INT 4
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PUSH
22537: LD_INT 92
22539: PUSH
22540: LD_INT 100
22542: PUSH
22543: LD_INT 75
22545: PUSH
22546: LD_INT 6
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: PPUSH
22559: CALL_OW 69
22563: IFFALSE 22520
// async ;
22565: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22566: LD_EXP 58
22570: PPUSH
22571: LD_STRING D6b-Pow-1
22573: PPUSH
22574: CALL_OW 88
// repeat wait ( 3 ) ;
22578: LD_INT 3
22580: PPUSH
22581: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22585: LD_EXP 58
22589: PPUSH
22590: CALL_OW 310
22594: PPUSH
22595: CALL_OW 256
22599: PUSH
22600: LD_INT 1000
22602: LESS
22603: IFFALSE 22622
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22605: LD_EXP 58
22609: PPUSH
22610: CALL_OW 310
22614: PPUSH
22615: LD_INT 1000
22617: PPUSH
22618: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22622: LD_EXP 58
22626: PPUSH
22627: CALL_OW 256
22631: PUSH
22632: LD_INT 1000
22634: LESS
22635: IFFALSE 22649
// SetLives ( Powell , 1000 ) ;
22637: LD_EXP 58
22641: PPUSH
22642: LD_INT 1000
22644: PPUSH
22645: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22649: LD_EXP 58
22653: PPUSH
22654: LD_EXP 63
22658: PPUSH
22659: CALL_OW 296
22663: PUSH
22664: LD_INT 5
22666: LESS
22667: PUSH
22668: LD_EXP 58
22672: PPUSH
22673: CALL_OW 310
22677: PPUSH
22678: LD_EXP 63
22682: PPUSH
22683: CALL_OW 296
22687: PUSH
22688: LD_INT 5
22690: LESS
22691: OR
22692: IFFALSE 22711
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22694: LD_EXP 58
22698: PPUSH
22699: CALL_OW 310
22703: PPUSH
22704: LD_INT 100
22706: PPUSH
22707: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22711: LD_EXP 58
22715: PPUSH
22716: CALL_OW 310
22720: NOT
22721: IFFALSE 22578
// DoNotAttack ( 8 , powellBomb ) ;
22723: LD_INT 8
22725: PPUSH
22726: LD_EXP 63
22730: PPUSH
22731: CALL_OW 471
// game_speed := 4 ;
22735: LD_ADDR_OWVAR 65
22739: PUSH
22740: LD_INT 4
22742: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22743: LD_EXP 58
22747: PPUSH
22748: LD_STRING D6b-Pow-1a
22750: PPUSH
22751: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22755: LD_EXP 58
22759: PPUSH
22760: LD_EXP 63
22764: PPUSH
22765: CALL_OW 180
// sync ;
22769: SYNC
// repeat wait ( 0 0$1 ) ;
22770: LD_INT 35
22772: PPUSH
22773: CALL_OW 67
// until IsInUnit ( Powell ) ;
22777: LD_EXP 58
22781: PPUSH
22782: CALL_OW 310
22786: IFFALSE 22770
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22788: LD_INT 8
22790: PPUSH
22791: LD_EXP 58
22795: PPUSH
22796: CALL_OW 310
22800: PPUSH
22801: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: LD_INT 91
22812: PPUSH
22813: LD_INT 44
22815: PPUSH
22816: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22820: LD_EXP 58
22824: PPUSH
22825: LD_INT 96
22827: PPUSH
22828: LD_INT 44
22830: PPUSH
22831: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22835: LD_EXP 58
22839: PPUSH
22840: LD_INT 96
22842: PPUSH
22843: LD_INT 41
22845: PPUSH
22846: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22850: LD_EXP 58
22854: PPUSH
22855: LD_INT 92
22857: PPUSH
22858: LD_INT 39
22860: PPUSH
22861: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22865: LD_EXP 58
22869: PPUSH
22870: LD_INT 88
22872: PPUSH
22873: LD_INT 41
22875: PPUSH
22876: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22880: LD_EXP 58
22884: PPUSH
22885: LD_INT 91
22887: PPUSH
22888: LD_INT 44
22890: PPUSH
22891: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22895: LD_EXP 58
22899: PPUSH
22900: LD_INT 96
22902: PPUSH
22903: LD_INT 44
22905: PPUSH
22906: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22910: LD_EXP 58
22914: PPUSH
22915: LD_INT 96
22917: PPUSH
22918: LD_INT 41
22920: PPUSH
22921: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22925: LD_EXP 58
22929: PPUSH
22930: LD_INT 92
22932: PPUSH
22933: LD_INT 39
22935: PPUSH
22936: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22940: LD_EXP 58
22944: PPUSH
22945: LD_INT 88
22947: PPUSH
22948: LD_INT 41
22950: PPUSH
22951: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22955: LD_EXP 58
22959: PPUSH
22960: LD_INT 91
22962: PPUSH
22963: LD_INT 44
22965: PPUSH
22966: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22970: LD_EXP 58
22974: PPUSH
22975: LD_INT 93
22977: PPUSH
22978: LD_INT 39
22980: PPUSH
22981: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22985: LD_EXP 58
22989: PPUSH
22990: LD_INT 93
22992: PPUSH
22993: LD_INT 36
22995: PPUSH
22996: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23000: LD_INT 122
23002: PPUSH
23003: CALL_OW 67
// game_speed := 4 ;
23007: LD_ADDR_OWVAR 65
23011: PUSH
23012: LD_INT 4
23014: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23015: LD_EXP 58
23019: PPUSH
23020: LD_STRING D6b-Pow-1b
23022: PPUSH
23023: CALL_OW 88
// tmp := [ ] ;
23027: LD_ADDR_VAR 0 3
23031: PUSH
23032: EMPTY
23033: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23034: LD_ADDR_VAR 0 5
23038: PUSH
23039: LD_INT 78
23041: PUSH
23042: LD_INT 47
23044: PUSH
23045: EMPTY
23046: LIST
23047: LIST
23048: PUSH
23049: LD_INT 106
23051: PUSH
23052: LD_INT 53
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: PUSH
23059: EMPTY
23060: LIST
23061: LIST
23062: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23063: LD_ADDR_VAR 0 1
23067: PUSH
23068: LD_INT 22
23070: PUSH
23071: LD_INT 8
23073: PUSH
23074: EMPTY
23075: LIST
23076: LIST
23077: PUSH
23078: LD_INT 21
23080: PUSH
23081: LD_INT 3
23083: PUSH
23084: EMPTY
23085: LIST
23086: LIST
23087: PUSH
23088: LD_INT 92
23090: PUSH
23091: LD_INT 90
23093: PUSH
23094: LD_INT 52
23096: PUSH
23097: LD_INT 12
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: LIST
23104: LIST
23105: PUSH
23106: EMPTY
23107: LIST
23108: LIST
23109: LIST
23110: PPUSH
23111: CALL_OW 69
23115: PUSH
23116: FOR_IN
23117: IFFALSE 23142
// tmp := tmp ^ UnitsInside ( i ) ;
23119: LD_ADDR_VAR 0 3
23123: PUSH
23124: LD_VAR 0 3
23128: PUSH
23129: LD_VAR 0 1
23133: PPUSH
23134: CALL_OW 313
23138: ADD
23139: ST_TO_ADDR
23140: GO 23116
23142: POP
23143: POP
// for i in tmp do
23144: LD_ADDR_VAR 0 1
23148: PUSH
23149: LD_VAR 0 3
23153: PUSH
23154: FOR_IN
23155: IFFALSE 23317
// begin dist := 9999 ;
23157: LD_ADDR_VAR 0 8
23161: PUSH
23162: LD_INT 9999
23164: ST_TO_ADDR
// _xy := [ ] ;
23165: LD_ADDR_VAR 0 7
23169: PUSH
23170: EMPTY
23171: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23172: LD_VAR 0 1
23176: PPUSH
23177: LD_INT 1
23179: PPUSH
23180: CALL_OW 109
// ComExitBuilding ( i ) ;
23184: LD_VAR 0 1
23188: PPUSH
23189: CALL_OW 122
// for j in xy do
23193: LD_ADDR_VAR 0 2
23197: PUSH
23198: LD_VAR 0 5
23202: PUSH
23203: FOR_IN
23204: IFFALSE 23286
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23206: LD_VAR 0 1
23210: PPUSH
23211: LD_VAR 0 2
23215: PUSH
23216: LD_INT 1
23218: ARRAY
23219: PPUSH
23220: LD_VAR 0 2
23224: PUSH
23225: LD_INT 2
23227: ARRAY
23228: PPUSH
23229: CALL_OW 297
23233: PUSH
23234: LD_VAR 0 8
23238: LESS
23239: IFFALSE 23284
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23241: LD_ADDR_VAR 0 8
23245: PUSH
23246: LD_VAR 0 1
23250: PPUSH
23251: LD_VAR 0 2
23255: PUSH
23256: LD_INT 1
23258: ARRAY
23259: PPUSH
23260: LD_VAR 0 2
23264: PUSH
23265: LD_INT 2
23267: ARRAY
23268: PPUSH
23269: CALL_OW 297
23273: ST_TO_ADDR
// _xy := j ;
23274: LD_ADDR_VAR 0 7
23278: PUSH
23279: LD_VAR 0 2
23283: ST_TO_ADDR
// end ;
23284: GO 23203
23286: POP
23287: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23288: LD_VAR 0 1
23292: PPUSH
23293: LD_VAR 0 7
23297: PUSH
23298: LD_INT 1
23300: ARRAY
23301: PPUSH
23302: LD_VAR 0 7
23306: PUSH
23307: LD_INT 2
23309: ARRAY
23310: PPUSH
23311: CALL_OW 171
// end ;
23315: GO 23154
23317: POP
23318: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23319: LD_ADDR_VAR 0 4
23323: PUSH
23324: LD_VAR 0 3
23328: PPUSH
23329: LD_INT 26
23331: PUSH
23332: LD_INT 1
23334: PUSH
23335: EMPTY
23336: LIST
23337: LIST
23338: PUSH
23339: LD_INT 25
23341: PUSH
23342: LD_INT 1
23344: PUSH
23345: EMPTY
23346: LIST
23347: LIST
23348: PUSH
23349: EMPTY
23350: LIST
23351: LIST
23352: PPUSH
23353: CALL_OW 72
23357: ST_TO_ADDR
// if tmp2 < 2 then
23358: LD_VAR 0 4
23362: PUSH
23363: LD_INT 2
23365: LESS
23366: IFFALSE 23435
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23368: LD_ADDR_VAR 0 4
23372: PUSH
23373: LD_INT 22
23375: PUSH
23376: LD_INT 8
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: PUSH
23383: LD_INT 26
23385: PUSH
23386: LD_INT 1
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: PUSH
23393: LD_INT 3
23395: PUSH
23396: LD_INT 25
23398: PUSH
23399: LD_INT 15
23401: PUSH
23402: EMPTY
23403: LIST
23404: LIST
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: PUSH
23410: EMPTY
23411: LIST
23412: LIST
23413: LIST
23414: PPUSH
23415: CALL_OW 69
23419: PUSH
23420: LD_EXP 60
23424: PUSH
23425: LD_EXP 61
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: DIFF
23434: ST_TO_ADDR
// if tmp2 then
23435: LD_VAR 0 4
23439: IFFALSE 23457
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23441: LD_VAR 0 4
23445: PUSH
23446: LD_INT 1
23448: ARRAY
23449: PPUSH
23450: LD_STRING D6b-ArSol1-1
23452: PPUSH
23453: CALL_OW 88
// async ;
23457: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23458: LD_EXP 58
23462: PPUSH
23463: LD_STRING D6b-Pow-2
23465: PPUSH
23466: CALL_OW 88
// wait ( 0 0$1 ) ;
23470: LD_INT 35
23472: PPUSH
23473: CALL_OW 67
// if tmp2 > 1 then
23477: LD_VAR 0 4
23481: PUSH
23482: LD_INT 1
23484: GREATER
23485: IFFALSE 23503
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23487: LD_VAR 0 4
23491: PUSH
23492: LD_INT 2
23494: ARRAY
23495: PPUSH
23496: LD_STRING D6b-ArSol2-1
23498: PPUSH
23499: CALL_OW 88
// sync ;
23503: SYNC
// repeat wait ( 5 ) ;
23504: LD_INT 5
23506: PPUSH
23507: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23511: LD_INT 93
23513: PPUSH
23514: LD_INT 36
23516: PPUSH
23517: CALL_OW 428
23521: PPUSH
23522: CALL_OW 255
23526: PUSH
23527: LD_INT 4
23529: EQUAL
23530: IFFALSE 23504
// DialogueOn ;
23532: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23536: LD_INT 10
23538: PPUSH
23539: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23543: LD_EXP 58
23547: PPUSH
23548: LD_STRING D6b-Pow-2a
23550: PPUSH
23551: CALL_OW 88
// DialogueOff ;
23555: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23559: LD_EXP 58
23563: PPUSH
23564: CALL_OW 310
23568: PPUSH
23569: LD_INT 332
23571: PPUSH
23572: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23576: LD_INT 93
23578: PPUSH
23579: LD_INT 35
23581: PPUSH
23582: LD_INT 1
23584: PPUSH
23585: LD_INT 6
23587: NEG
23588: PPUSH
23589: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23593: LD_INT 35
23595: PPUSH
23596: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23600: LD_INT 332
23602: PPUSH
23603: CALL_OW 256
23607: PUSH
23608: LD_INT 1000
23610: LESS
23611: PUSH
23612: LD_INT 332
23614: PPUSH
23615: CALL_OW 300
23619: AND
23620: IFFALSE 23632
// SetLives ( kozlov_fac , 0 ) ;
23622: LD_INT 332
23624: PPUSH
23625: LD_INT 0
23627: PPUSH
23628: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23632: LD_INT 332
23634: PPUSH
23635: CALL_OW 301
23639: PUSH
23640: LD_EXP 58
23644: PPUSH
23645: CALL_OW 301
23649: OR
23650: IFFALSE 23593
// game_speed := 4 ;
23652: LD_ADDR_OWVAR 65
23656: PUSH
23657: LD_INT 4
23659: ST_TO_ADDR
// powellCenterCameraMode := false ;
23660: LD_ADDR_EXP 20
23664: PUSH
23665: LD_INT 0
23667: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23668: LD_ADDR_VAR 0 1
23672: PUSH
23673: LD_VAR 0 3
23677: PUSH
23678: LD_INT 22
23680: PUSH
23681: LD_INT 8
23683: PUSH
23684: EMPTY
23685: LIST
23686: LIST
23687: PUSH
23688: LD_INT 25
23690: PUSH
23691: LD_INT 2
23693: PUSH
23694: EMPTY
23695: LIST
23696: LIST
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PPUSH
23702: CALL_OW 69
23706: UNION
23707: PUSH
23708: FOR_IN
23709: IFFALSE 23725
// SetTag ( i , 0 ) ;
23711: LD_VAR 0 1
23715: PPUSH
23716: LD_INT 0
23718: PPUSH
23719: CALL_OW 109
23723: GO 23708
23725: POP
23726: POP
// wait ( 0 0$3 ) ;
23727: LD_INT 105
23729: PPUSH
23730: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23734: LD_INT 93
23736: PPUSH
23737: LD_INT 35
23739: PPUSH
23740: LD_INT 1
23742: PPUSH
23743: CALL_OW 331
// DialogueOn ;
23747: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23751: LD_VAR 0 11
23755: PPUSH
23756: LD_STRING D6c-Sol3-1
23758: PPUSH
23759: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23763: LD_INT 10
23765: PPUSH
23766: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23770: LD_EXP 39
23774: PPUSH
23775: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23779: LD_EXP 39
23783: PPUSH
23784: LD_STRING D6c-JMM-1
23786: PPUSH
23787: CALL_OW 88
// if Cyrus then
23791: LD_EXP 45
23795: IFFALSE 23809
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23797: LD_EXP 45
23801: PPUSH
23802: LD_STRING D6c-Cyrus-1
23804: PPUSH
23805: CALL_OW 88
// if Bobby then
23809: LD_EXP 44
23813: IFFALSE 23827
// Say ( Bobby , D6c-Bobby-1 ) ;
23815: LD_EXP 44
23819: PPUSH
23820: LD_STRING D6c-Bobby-1
23822: PPUSH
23823: CALL_OW 88
// if Cornel then
23827: LD_EXP 50
23831: IFFALSE 23845
// Say ( Cornel , D6c-Corn-1 ) ;
23833: LD_EXP 50
23837: PPUSH
23838: LD_STRING D6c-Corn-1
23840: PPUSH
23841: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23845: LD_ADDR_VAR 0 4
23849: PUSH
23850: LD_INT 2
23852: PUSH
23853: LD_INT 22
23855: PUSH
23856: LD_INT 1
23858: PUSH
23859: EMPTY
23860: LIST
23861: LIST
23862: PUSH
23863: LD_INT 22
23865: PUSH
23866: LD_INT 4
23868: PUSH
23869: EMPTY
23870: LIST
23871: LIST
23872: PUSH
23873: EMPTY
23874: LIST
23875: LIST
23876: LIST
23877: PUSH
23878: LD_INT 26
23880: PUSH
23881: LD_INT 1
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: PUSH
23888: LD_INT 3
23890: PUSH
23891: LD_INT 25
23893: PUSH
23894: LD_INT 16
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: PUSH
23901: LD_INT 25
23903: PUSH
23904: LD_INT 12
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: PUSH
23911: EMPTY
23912: LIST
23913: LIST
23914: LIST
23915: PUSH
23916: EMPTY
23917: LIST
23918: LIST
23919: LIST
23920: PPUSH
23921: CALL_OW 69
23925: PUSH
23926: LD_VAR 0 11
23930: PUSH
23931: LD_EXP 39
23935: UNION
23936: PUSH
23937: LD_EXP 59
23941: UNION
23942: PUSH
23943: EMPTY
23944: LIST
23945: DIFF
23946: ST_TO_ADDR
// if tmp2 then
23947: LD_VAR 0 4
23951: IFFALSE 23969
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23953: LD_VAR 0 4
23957: PUSH
23958: LD_INT 1
23960: ARRAY
23961: PPUSH
23962: LD_STRING D6c-Sol1-1
23964: PPUSH
23965: CALL_OW 88
// if Lisa then
23969: LD_EXP 42
23973: IFFALSE 23987
// Say ( Lisa , D6c-Lisa-1 ) ;
23975: LD_EXP 42
23979: PPUSH
23980: LD_STRING D6c-Lisa-1
23982: PPUSH
23983: CALL_OW 88
// if Gary then
23987: LD_EXP 51
23991: IFFALSE 24005
// Say ( Gary , D6c-Gary-1 ) ;
23993: LD_EXP 51
23997: PPUSH
23998: LD_STRING D6c-Gary-1
24000: PPUSH
24001: CALL_OW 88
// if Donaldson then
24005: LD_EXP 43
24009: IFFALSE 24023
// Say ( Donaldson , D6c-Don-1 ) ;
24011: LD_EXP 43
24015: PPUSH
24016: LD_STRING D6c-Don-1
24018: PPUSH
24019: CALL_OW 88
// if tmp2 > 1 then
24023: LD_VAR 0 4
24027: PUSH
24028: LD_INT 1
24030: GREATER
24031: IFFALSE 24049
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24033: LD_VAR 0 4
24037: PUSH
24038: LD_INT 2
24040: ARRAY
24041: PPUSH
24042: LD_STRING D6c-Sol2-1
24044: PPUSH
24045: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24049: LD_VAR 0 11
24053: PPUSH
24054: LD_STRING D6c-Sol3-2
24056: PPUSH
24057: CALL_OW 88
// dwait ( 0 0$1 ) ;
24061: LD_INT 35
24063: PPUSH
24064: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24068: LD_EXP 39
24072: PPUSH
24073: LD_STRING D6c-JMM-2
24075: PPUSH
24076: CALL_OW 88
// DialogueOff ;
24080: CALL_OW 7
// Video ( false ) ;
24084: LD_INT 0
24086: PPUSH
24087: CALL 107620 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24091: LD_INT 22
24093: PUSH
24094: LD_INT 4
24096: PUSH
24097: EMPTY
24098: LIST
24099: LIST
24100: PPUSH
24101: CALL_OW 69
24105: PPUSH
24106: LD_INT 1
24108: PPUSH
24109: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24113: LD_INT 4
24115: PPUSH
24116: LD_INT 4
24118: PPUSH
24119: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24123: LD_ADDR_VAR 0 1
24127: PUSH
24128: LD_INT 4
24130: PPUSH
24131: LD_INT 1
24133: PPUSH
24134: LD_INT 2
24136: PPUSH
24137: CALL 64841 0 3
24141: PUSH
24142: FOR_IN
24143: IFFALSE 24180
// if GetTech ( i , 1 ) <> state_researched then
24145: LD_VAR 0 1
24149: PPUSH
24150: LD_INT 1
24152: PPUSH
24153: CALL_OW 321
24157: PUSH
24158: LD_INT 2
24160: NONEQUAL
24161: IFFALSE 24178
// SetTech ( i , 1 , state_researched ) ;
24163: LD_VAR 0 1
24167: PPUSH
24168: LD_INT 1
24170: PPUSH
24171: LD_INT 2
24173: PPUSH
24174: CALL_OW 322
24178: GO 24142
24180: POP
24181: POP
// missionStage := 6 ;
24182: LD_ADDR_EXP 15
24186: PUSH
24187: LD_INT 6
24189: ST_TO_ADDR
// activeAttacks := true ;
24190: LD_ADDR_EXP 16
24194: PUSH
24195: LD_INT 1
24197: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24198: LD_STRING M2
24200: PPUSH
24201: CALL_OW 337
// SaveForQuickRestart ;
24205: CALL_OW 22
// wait ( 0 0$40 ) ;
24209: LD_INT 1400
24211: PPUSH
24212: CALL_OW 67
// DialogueOn ;
24216: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24220: LD_EXP 62
24224: PPUSH
24225: LD_STRING D7-Friend-1
24227: PPUSH
24228: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24232: LD_EXP 39
24236: PPUSH
24237: LD_STRING D7-JMM-1
24239: PPUSH
24240: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24244: LD_EXP 62
24248: PPUSH
24249: LD_STRING D7-Friend-2
24251: PPUSH
24252: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24256: LD_EXP 39
24260: PPUSH
24261: LD_STRING D7-JMM-2
24263: PPUSH
24264: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24268: LD_EXP 62
24272: PPUSH
24273: LD_STRING D7-Friend-3
24275: PPUSH
24276: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24280: LD_EXP 39
24284: PPUSH
24285: LD_STRING D7-JMM-3
24287: PPUSH
24288: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24292: LD_EXP 62
24296: PPUSH
24297: LD_STRING D7-Friend-4
24299: PPUSH
24300: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24304: LD_EXP 39
24308: PPUSH
24309: LD_STRING D7-JMM-4
24311: PPUSH
24312: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24316: LD_EXP 62
24320: PPUSH
24321: LD_STRING D7-Friend-5
24323: PPUSH
24324: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24328: LD_EXP 39
24332: PPUSH
24333: LD_STRING D7-JMM-5
24335: PPUSH
24336: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24340: LD_EXP 62
24344: PPUSH
24345: LD_STRING D7-Friend-6
24347: PPUSH
24348: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24352: LD_EXP 39
24356: PPUSH
24357: LD_STRING D7-JMM-6
24359: PPUSH
24360: CALL_OW 88
// DialogueOff ;
24364: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24368: LD_STRING Mlegion
24370: PPUSH
24371: CALL_OW 337
// RebuildKozlovFactory ;
24375: CALL 4819 0 0
// end ;
24379: PPOPN 13
24381: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24382: LD_EXP 20
24386: PUSH
24387: LD_EXP 58
24391: PPUSH
24392: CALL_OW 300
24396: AND
24397: IFFALSE 24439
24399: GO 24401
24401: DISABLE
// begin enable ;
24402: ENABLE
// if IsInUnit ( Powell ) then
24403: LD_EXP 58
24407: PPUSH
24408: CALL_OW 310
24412: IFFALSE 24430
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24414: LD_EXP 58
24418: PPUSH
24419: CALL_OW 310
24423: PPUSH
24424: CALL_OW 85
24428: GO 24439
// CenterOnUnits ( Powell ) ;
24430: LD_EXP 58
24434: PPUSH
24435: CALL_OW 85
// end ;
24439: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24440: LD_INT 22
24442: PUSH
24443: LD_INT 8
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: PUSH
24450: LD_INT 34
24452: PUSH
24453: LD_INT 48
24455: PUSH
24456: EMPTY
24457: LIST
24458: LIST
24459: PUSH
24460: EMPTY
24461: LIST
24462: LIST
24463: PPUSH
24464: CALL_OW 69
24468: IFFALSE 24742
24470: GO 24472
24472: DISABLE
24473: LD_INT 0
24475: PPUSH
24476: PPUSH
// begin if missionStage < 9 then
24477: LD_EXP 15
24481: PUSH
24482: LD_INT 9
24484: LESS
24485: IFFALSE 24495
// missionStage := 9 ;
24487: LD_ADDR_EXP 15
24491: PUSH
24492: LD_INT 9
24494: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24495: LD_ADDR_VAR 0 1
24499: PUSH
24500: LD_INT 22
24502: PUSH
24503: LD_INT 8
24505: PUSH
24506: EMPTY
24507: LIST
24508: LIST
24509: PUSH
24510: LD_INT 34
24512: PUSH
24513: LD_INT 48
24515: PUSH
24516: EMPTY
24517: LIST
24518: LIST
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PPUSH
24524: CALL_OW 69
24528: PUSH
24529: LD_INT 1
24531: ARRAY
24532: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24533: LD_INT 175
24535: PPUSH
24536: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24540: LD_EXP 12
24544: PUSH
24545: LD_EXP 3
24549: PUSH
24550: LD_INT 0
24552: PUSH
24553: LD_INT 2
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: IN
24560: OR
24561: IFFALSE 24584
// target := [ 68 , 108 , 1 ] else
24563: LD_ADDR_VAR 0 2
24567: PUSH
24568: LD_INT 68
24570: PUSH
24571: LD_INT 108
24573: PUSH
24574: LD_INT 1
24576: PUSH
24577: EMPTY
24578: LIST
24579: LIST
24580: LIST
24581: ST_TO_ADDR
24582: GO 24603
// target := [ 181 , 88 , 2 ] ;
24584: LD_ADDR_VAR 0 2
24588: PUSH
24589: LD_INT 181
24591: PUSH
24592: LD_INT 88
24594: PUSH
24595: LD_INT 2
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: LIST
24602: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24603: LD_VAR 0 1
24607: PPUSH
24608: LD_VAR 0 2
24612: PUSH
24613: LD_INT 1
24615: ARRAY
24616: PPUSH
24617: LD_VAR 0 2
24621: PUSH
24622: LD_INT 2
24624: ARRAY
24625: PPUSH
24626: CALL_OW 176
// if target [ 3 ] = 1 then
24630: LD_VAR 0 2
24634: PUSH
24635: LD_INT 3
24637: ARRAY
24638: PUSH
24639: LD_INT 1
24641: EQUAL
24642: IFFALSE 24658
// SayRadio ( Kurt , D12-Kurt-1 ) else
24644: LD_EXP 60
24648: PPUSH
24649: LD_STRING D12-Kurt-1
24651: PPUSH
24652: CALL_OW 94
24656: GO 24682
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24658: LD_EXP 60
24662: PPUSH
24663: LD_STRING D12a-Kurt-1
24665: PPUSH
24666: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24670: LD_EXP 74
24674: PPUSH
24675: LD_STRING D12a-Roth-1
24677: PPUSH
24678: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24682: LD_INT 350
24684: PPUSH
24685: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24689: LD_VAR 0 1
24693: PPUSH
24694: LD_INT 22
24696: PUSH
24697: LD_INT 8
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: PUSH
24704: LD_INT 23
24706: PUSH
24707: LD_INT 2
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: PUSH
24714: LD_INT 30
24716: PUSH
24717: LD_INT 3
24719: PUSH
24720: EMPTY
24721: LIST
24722: LIST
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: LIST
24728: PPUSH
24729: CALL_OW 69
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PPUSH
24738: CALL_OW 228
// end ;
24742: PPOPN 2
24744: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24745: LD_EXP 60
24749: PPUSH
24750: CALL_OW 256
24754: PUSH
24755: LD_INT 999
24757: LESS
24758: PUSH
24759: LD_INT 22
24761: PUSH
24762: LD_INT 8
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: PUSH
24769: LD_INT 21
24771: PUSH
24772: LD_INT 1
24774: PUSH
24775: EMPTY
24776: LIST
24777: LIST
24778: PUSH
24779: LD_INT 23
24781: PUSH
24782: LD_INT 2
24784: PUSH
24785: EMPTY
24786: LIST
24787: LIST
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: LIST
24793: PPUSH
24794: CALL_OW 69
24798: PUSH
24799: LD_INT 9
24801: PUSH
24802: LD_INT 8
24804: PUSH
24805: LD_INT 7
24807: PUSH
24808: EMPTY
24809: LIST
24810: LIST
24811: LIST
24812: PUSH
24813: LD_OWVAR 67
24817: ARRAY
24818: LESSEQUAL
24819: OR
24820: PUSH
24821: LD_INT 22
24823: PUSH
24824: LD_INT 8
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: PUSH
24831: LD_INT 34
24833: PUSH
24834: LD_INT 48
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: PPUSH
24845: CALL_OW 69
24849: NOT
24850: AND
24851: PUSH
24852: LD_EXP 60
24856: PPUSH
24857: CALL_OW 302
24861: AND
24862: PUSH
24863: LD_INT 5
24865: PPUSH
24866: LD_INT 22
24868: PUSH
24869: LD_INT 1
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: PPUSH
24876: CALL_OW 70
24880: AND
24881: IFFALSE 25550
24883: GO 24885
24885: DISABLE
24886: LD_INT 0
24888: PPUSH
24889: PPUSH
24890: PPUSH
// begin DialogueOn ;
24891: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24895: LD_EXP 39
24899: PPUSH
24900: LD_STRING D13-JMM-1
24902: PPUSH
24903: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24907: LD_EXP 60
24911: PPUSH
24912: LD_STRING D13-Kurt-1
24914: PPUSH
24915: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24919: LD_EXP 39
24923: PPUSH
24924: LD_STRING D13-JMM-2
24926: PPUSH
24927: CALL_OW 88
// if FakeInfo then
24931: LD_EXP 12
24935: IFFALSE 24955
// begin Say ( Kurt , D13-Kurt-2 ) ;
24937: LD_EXP 60
24941: PPUSH
24942: LD_STRING D13-Kurt-2
24944: PPUSH
24945: CALL_OW 88
// DialogueOff ;
24949: CALL_OW 7
// exit ;
24953: GO 25550
// end ; if not KurtStatus then
24955: LD_EXP 3
24959: NOT
24960: IFFALSE 24976
// Say ( Kurt , D13-Kurt-2b ) else
24962: LD_EXP 60
24966: PPUSH
24967: LD_STRING D13-Kurt-2b
24969: PPUSH
24970: CALL_OW 88
24974: GO 24988
// Say ( Kurt , D13-Kurt-2a ) ;
24976: LD_EXP 60
24980: PPUSH
24981: LD_STRING D13-Kurt-2a
24983: PPUSH
24984: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24988: LD_EXP 39
24992: PPUSH
24993: LD_STRING D13-JMM-3
24995: PPUSH
24996: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25000: LD_EXP 60
25004: PPUSH
25005: LD_STRING D13-Kurt-3
25007: PPUSH
25008: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25012: LD_EXP 39
25016: PPUSH
25017: LD_STRING D13-JMM-4
25019: PPUSH
25020: CALL_OW 88
// DialogueOff ;
25024: CALL_OW 7
// MC_Kill ( 3 ) ;
25028: LD_INT 3
25030: PPUSH
25031: CALL 34974 0 1
// KillUnit ( Kozlov ) ;
25035: LD_EXP 61
25039: PPUSH
25040: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
25044: LD_INT 22
25046: PUSH
25047: LD_INT 8
25049: PUSH
25050: EMPTY
25051: LIST
25052: LIST
25053: PUSH
25054: LD_INT 21
25056: PUSH
25057: LD_INT 3
25059: PUSH
25060: EMPTY
25061: LIST
25062: LIST
25063: PUSH
25064: LD_INT 23
25066: PUSH
25067: LD_INT 3
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: LD_INT 30
25076: PUSH
25077: LD_INT 3
25079: PUSH
25080: EMPTY
25081: LIST
25082: LIST
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: LIST
25088: LIST
25089: PPUSH
25090: CALL_OW 69
25094: PUSH
25095: LD_INT 1
25097: ARRAY
25098: PPUSH
25099: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
25103: LD_INT 8
25105: PPUSH
25106: LD_INT 1
25108: PPUSH
25109: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25113: LD_ADDR_VAR 0 2
25117: PUSH
25118: LD_INT 22
25120: PUSH
25121: LD_INT 8
25123: PUSH
25124: EMPTY
25125: LIST
25126: LIST
25127: PUSH
25128: LD_INT 21
25130: PUSH
25131: LD_INT 1
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PUSH
25138: EMPTY
25139: LIST
25140: LIST
25141: PPUSH
25142: CALL_OW 69
25146: PUSH
25147: LD_EXP 61
25151: PUSH
25152: LD_EXP 60
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: DIFF
25161: ST_TO_ADDR
// if tmp >= [ 9 , 8 , 7 ] [ Difficulty ] then
25162: LD_VAR 0 2
25166: PUSH
25167: LD_INT 9
25169: PUSH
25170: LD_INT 8
25172: PUSH
25173: LD_INT 7
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: LIST
25180: PUSH
25181: LD_OWVAR 67
25185: ARRAY
25186: GREATEREQUAL
25187: IFFALSE 25349
// begin x := [ 9 , 8 , 7 ] [ Difficulty ] ;
25189: LD_ADDR_VAR 0 3
25193: PUSH
25194: LD_INT 9
25196: PUSH
25197: LD_INT 8
25199: PUSH
25200: LD_INT 7
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: LIST
25207: PUSH
25208: LD_OWVAR 67
25212: ARRAY
25213: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25214: LD_ADDR_VAR 0 1
25218: PUSH
25219: DOUBLE
25220: LD_VAR 0 2
25224: PUSH
25225: LD_VAR 0 3
25229: PUSH
25230: LD_INT 1
25232: PLUS
25233: MINUS
25234: INC
25235: ST_TO_ADDR
25236: LD_INT 1
25238: PUSH
25239: FOR_DOWNTO
25240: IFFALSE 25345
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25242: LD_ADDR_EXP 38
25246: PUSH
25247: LD_EXP 38
25251: PUSH
25252: LD_VAR 0 2
25256: PUSH
25257: LD_VAR 0 1
25261: ARRAY
25262: ADD
25263: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25264: LD_VAR 0 2
25268: PUSH
25269: LD_VAR 0 1
25273: ARRAY
25274: PPUSH
25275: CALL_OW 310
25279: IFFALSE 25296
// ComExitBuilding ( tmp [ i ] ) ;
25281: LD_VAR 0 2
25285: PUSH
25286: LD_VAR 0 1
25290: ARRAY
25291: PPUSH
25292: CALL_OW 122
// if IsInUnit ( i ) then
25296: LD_VAR 0 1
25300: PPUSH
25301: CALL_OW 310
25305: IFFALSE 25322
// ComExitVehicle ( tmp [ i ] ) ;
25307: LD_VAR 0 2
25311: PUSH
25312: LD_VAR 0 1
25316: ARRAY
25317: PPUSH
25318: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 37 , 1 ) ;
25322: LD_VAR 0 2
25326: PUSH
25327: LD_VAR 0 1
25331: ARRAY
25332: PPUSH
25333: LD_INT 37
25335: PPUSH
25336: LD_INT 1
25338: PPUSH
25339: CALL_OW 171
// end ;
25343: GO 25239
25345: POP
25346: POP
// end else
25347: GO 25359
// x := tmp ;
25349: LD_ADDR_VAR 0 3
25353: PUSH
25354: LD_VAR 0 2
25358: ST_TO_ADDR
// for i := tmp downto tmp - x do
25359: LD_ADDR_VAR 0 1
25363: PUSH
25364: DOUBLE
25365: LD_VAR 0 2
25369: INC
25370: ST_TO_ADDR
25371: LD_VAR 0 2
25375: PUSH
25376: LD_VAR 0 3
25380: MINUS
25381: PUSH
25382: FOR_DOWNTO
25383: IFFALSE 25437
// begin if IsInUnit ( tmp [ i ] ) then
25385: LD_VAR 0 2
25389: PUSH
25390: LD_VAR 0 1
25394: ARRAY
25395: PPUSH
25396: CALL_OW 310
25400: IFFALSE 25417
// ComExitVehicle ( tmp [ i ] ) ;
25402: LD_VAR 0 2
25406: PUSH
25407: LD_VAR 0 1
25411: ARRAY
25412: PPUSH
25413: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25417: LD_VAR 0 2
25421: PUSH
25422: LD_VAR 0 1
25426: ARRAY
25427: PPUSH
25428: LD_INT 1
25430: PPUSH
25431: CALL_OW 235
// end ;
25435: GO 25382
25437: POP
25438: POP
// SetSide ( Kurt , 1 ) ;
25439: LD_EXP 60
25443: PPUSH
25444: LD_INT 1
25446: PPUSH
25447: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25451: LD_INT 22
25453: PUSH
25454: LD_INT 8
25456: PUSH
25457: EMPTY
25458: LIST
25459: LIST
25460: PUSH
25461: LD_INT 21
25463: PUSH
25464: LD_INT 3
25466: PUSH
25467: EMPTY
25468: LIST
25469: LIST
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: PPUSH
25475: CALL_OW 69
25479: PPUSH
25480: LD_INT 1
25482: PPUSH
25483: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25487: LD_INT 8
25489: PPUSH
25490: LD_INT 1
25492: PPUSH
25493: LD_INT 1
25495: PPUSH
25496: LD_INT 1
25498: PPUSH
25499: CALL_OW 80
// wait ( 0 0$40 ) ;
25503: LD_INT 1400
25505: PPUSH
25506: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25510: LD_EXP 62
25514: PPUSH
25515: LD_INT 37
25517: PPUSH
25518: LD_INT 1
25520: PPUSH
25521: LD_INT 0
25523: PPUSH
25524: CALL_OW 48
// wait ( 0 0$1 ) ;
25528: LD_INT 35
25530: PPUSH
25531: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25535: LD_EXP 62
25539: PPUSH
25540: LD_INT 60
25542: PPUSH
25543: LD_INT 95
25545: PPUSH
25546: CALL_OW 111
// end ;
25550: PPOPN 3
25552: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25553: LD_EXP 38
25557: IFFALSE 25632
25559: GO 25561
25561: DISABLE
25562: LD_INT 0
25564: PPUSH
// begin enable ;
25565: ENABLE
// for i in legionEscapeUnits do
25566: LD_ADDR_VAR 0 1
25570: PUSH
25571: LD_EXP 38
25575: PUSH
25576: FOR_IN
25577: IFFALSE 25630
// begin if IsInArea ( i , legionEscapeArea ) then
25579: LD_VAR 0 1
25583: PPUSH
25584: LD_INT 31
25586: PPUSH
25587: CALL_OW 308
25591: IFFALSE 25604
// RemoveUnit ( i ) else
25593: LD_VAR 0 1
25597: PPUSH
25598: CALL_OW 64
25602: GO 25628
// if not HasTask ( i ) then
25604: LD_VAR 0 1
25608: PPUSH
25609: CALL_OW 314
25613: NOT
25614: IFFALSE 25628
// ComMoveToArea ( i , legionEscapeArea ) ;
25616: LD_VAR 0 1
25620: PPUSH
25621: LD_INT 31
25623: PPUSH
25624: CALL_OW 113
// end ;
25628: GO 25576
25630: POP
25631: POP
// end ;
25632: PPOPN 1
25634: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25635: LD_INT 22
25637: PUSH
25638: LD_INT 8
25640: PUSH
25641: EMPTY
25642: LIST
25643: LIST
25644: PUSH
25645: LD_INT 21
25647: PUSH
25648: LD_INT 1
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PUSH
25655: EMPTY
25656: LIST
25657: LIST
25658: PPUSH
25659: CALL_OW 69
25663: PUSH
25664: LD_INT 0
25666: EQUAL
25667: IFFALSE 25687
25669: GO 25671
25671: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25672: LD_STRING MlegionOut
25674: PPUSH
25675: CALL_OW 337
// legionDestroyed := true ;
25679: LD_ADDR_EXP 22
25683: PUSH
25684: LD_INT 1
25686: ST_TO_ADDR
// end ;
25687: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25688: LD_INT 1
25690: PPUSH
25691: LD_EXP 62
25695: PPUSH
25696: CALL_OW 292
25700: IFFALSE 26014
25702: GO 25704
25704: DISABLE
25705: LD_INT 0
25707: PPUSH
// begin wait ( 0 0$2 ) ;
25708: LD_INT 70
25710: PPUSH
25711: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25715: LD_EXP 62
25719: PPUSH
25720: CALL_OW 87
// DialogueOn ;
25724: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25728: LD_EXP 39
25732: PPUSH
25733: LD_STRING D14-JMM-1
25735: PPUSH
25736: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25740: LD_EXP 62
25744: PPUSH
25745: LD_STRING D14-Friend-1
25747: PPUSH
25748: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25752: LD_EXP 39
25756: PPUSH
25757: LD_STRING D14-JMM-2
25759: PPUSH
25760: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25764: LD_EXP 62
25768: PPUSH
25769: LD_STRING D14-Friend-2
25771: PPUSH
25772: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25776: LD_EXP 39
25780: PPUSH
25781: LD_STRING D14-JMM-3
25783: PPUSH
25784: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25788: LD_EXP 62
25792: PPUSH
25793: LD_STRING D14-Friend-3
25795: PPUSH
25796: CALL_OW 88
// DialogueOff ;
25800: CALL_OW 7
// dec = Query ( Q14 ) ;
25804: LD_ADDR_VAR 0 1
25808: PUSH
25809: LD_STRING Q14
25811: PPUSH
25812: CALL_OW 97
25816: ST_TO_ADDR
// if dec = 1 then
25817: LD_VAR 0 1
25821: PUSH
25822: LD_INT 1
25824: EQUAL
25825: IFFALSE 25859
// begin DialogueOn ;
25827: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25831: LD_EXP 39
25835: PPUSH
25836: LD_STRING D14a-JMM-1
25838: PPUSH
25839: CALL_OW 88
// DialogueOff ;
25843: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25847: LD_EXP 62
25851: PPUSH
25852: LD_INT 1
25854: PPUSH
25855: CALL_OW 235
// end ; if dec = 2 then
25859: LD_VAR 0 1
25863: PUSH
25864: LD_INT 2
25866: EQUAL
25867: IFFALSE 25920
// begin DialogueOn ;
25869: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25873: LD_EXP 39
25877: PPUSH
25878: LD_STRING D14b-JMM-1
25880: PPUSH
25881: CALL_OW 88
// DialogueOff ;
25885: CALL_OW 7
// wait ( 0 0$1 ) ;
25889: LD_INT 35
25891: PPUSH
25892: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
25896: LD_EXP 62
25900: PPUSH
25901: LD_INT 9
25903: PPUSH
25904: LD_INT 2
25906: PPUSH
25907: CALL_OW 111
// AddComHold ( Friend ) ;
25911: LD_EXP 62
25915: PPUSH
25916: CALL_OW 200
// end ; if dec = 3 then
25920: LD_VAR 0 1
25924: PUSH
25925: LD_INT 3
25927: EQUAL
25928: IFFALSE 26014
// begin DialogueOn ;
25930: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25934: LD_EXP 39
25938: PPUSH
25939: LD_STRING D14c-JMM-1
25941: PPUSH
25942: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25946: LD_EXP 62
25950: PPUSH
25951: LD_STRING D14c-Friend-1
25953: PPUSH
25954: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25958: LD_EXP 39
25962: PPUSH
25963: LD_STRING D14c-JMM-2
25965: PPUSH
25966: CALL_OW 88
// DialogueOff ;
25970: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25974: LD_INT 8
25976: PPUSH
25977: LD_INT 1
25979: PPUSH
25980: LD_INT 2
25982: PPUSH
25983: LD_INT 1
25985: PPUSH
25986: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25990: LD_EXP 62
25994: PPUSH
25995: LD_INT 9
25997: PPUSH
25998: LD_INT 2
26000: PPUSH
26001: CALL_OW 111
// AddComHold ( Friend ) ;
26005: LD_EXP 62
26009: PPUSH
26010: CALL_OW 200
// end ; end ;
26014: PPOPN 1
26016: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26017: LD_INT 9
26019: PPUSH
26020: LD_INT 2
26022: PPUSH
26023: CALL_OW 428
26027: PUSH
26028: LD_EXP 62
26032: EQUAL
26033: PUSH
26034: LD_EXP 62
26038: PPUSH
26039: CALL_OW 255
26043: PUSH
26044: LD_INT 8
26046: EQUAL
26047: AND
26048: IFFALSE 26062
26050: GO 26052
26052: DISABLE
// RemoveUnit ( Friend ) ;
26053: LD_EXP 62
26057: PPUSH
26058: CALL_OW 64
26062: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26063: LD_EXP 14
26067: PUSH
26068: LD_INT 31500
26070: GREATEREQUAL
26071: PUSH
26072: LD_EXP 7
26076: AND
26077: PUSH
26078: LD_EXP 2
26082: AND
26083: IFFALSE 26513
26085: GO 26087
26087: DISABLE
26088: LD_INT 0
26090: PPUSH
26091: PPUSH
26092: PPUSH
// begin missionStage := 7 ;
26093: LD_ADDR_EXP 15
26097: PUSH
26098: LD_INT 7
26100: ST_TO_ADDR
// uc_side = 1 ;
26101: LD_ADDR_OWVAR 20
26105: PUSH
26106: LD_INT 1
26108: ST_TO_ADDR
// uc_nation = 1 ;
26109: LD_ADDR_OWVAR 21
26113: PUSH
26114: LD_INT 1
26116: ST_TO_ADDR
// for i = 1 to 5 do
26117: LD_ADDR_VAR 0 1
26121: PUSH
26122: DOUBLE
26123: LD_INT 1
26125: DEC
26126: ST_TO_ADDR
26127: LD_INT 5
26129: PUSH
26130: FOR_TO
26131: IFFALSE 26227
// begin vc_engine = 3 ;
26133: LD_ADDR_OWVAR 39
26137: PUSH
26138: LD_INT 3
26140: ST_TO_ADDR
// vc_control = 3 ;
26141: LD_ADDR_OWVAR 38
26145: PUSH
26146: LD_INT 3
26148: ST_TO_ADDR
// vc_chassis = 3 ;
26149: LD_ADDR_OWVAR 37
26153: PUSH
26154: LD_INT 3
26156: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26157: LD_ADDR_OWVAR 40
26161: PUSH
26162: LD_INT 5
26164: PUSH
26165: LD_INT 9
26167: PUSH
26168: LD_INT 7
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 1
26178: PPUSH
26179: LD_INT 3
26181: PPUSH
26182: CALL_OW 12
26186: ARRAY
26187: ST_TO_ADDR
// veh = CreateVehicle ;
26188: LD_ADDR_VAR 0 2
26192: PUSH
26193: CALL_OW 45
26197: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26198: LD_VAR 0 2
26202: PPUSH
26203: LD_INT 1
26205: PPUSH
26206: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26210: LD_VAR 0 2
26214: PPUSH
26215: LD_INT 19
26217: PPUSH
26218: LD_INT 0
26220: PPUSH
26221: CALL_OW 49
// end ;
26225: GO 26130
26227: POP
26228: POP
// vc_engine = 3 ;
26229: LD_ADDR_OWVAR 39
26233: PUSH
26234: LD_INT 3
26236: ST_TO_ADDR
// vc_control = 1 ;
26237: LD_ADDR_OWVAR 38
26241: PUSH
26242: LD_INT 1
26244: ST_TO_ADDR
// vc_chassis = 3 ;
26245: LD_ADDR_OWVAR 37
26249: PUSH
26250: LD_INT 3
26252: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26253: LD_ADDR_OWVAR 40
26257: PUSH
26258: LD_INT 5
26260: PUSH
26261: LD_INT 9
26263: PUSH
26264: LD_INT 7
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: LIST
26271: PUSH
26272: LD_INT 1
26274: PPUSH
26275: LD_INT 3
26277: PPUSH
26278: CALL_OW 12
26282: ARRAY
26283: ST_TO_ADDR
// vehG = CreateVehicle ;
26284: LD_ADDR_VAR 0 3
26288: PUSH
26289: CALL_OW 45
26293: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26294: LD_VAR 0 3
26298: PPUSH
26299: LD_INT 1
26301: PPUSH
26302: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26306: LD_VAR 0 3
26310: PPUSH
26311: LD_INT 19
26313: PPUSH
26314: LD_INT 0
26316: PPUSH
26317: CALL_OW 49
// if JMMGirl = 1 then
26321: LD_EXP 7
26325: PUSH
26326: LD_INT 1
26328: EQUAL
26329: IFFALSE 26385
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26331: LD_ADDR_EXP 40
26335: PUSH
26336: LD_STRING Joan
26338: PPUSH
26339: LD_INT 1
26341: PPUSH
26342: LD_STRING 14_
26344: PPUSH
26345: CALL 64778 0 3
26349: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26350: LD_EXP 40
26354: PPUSH
26355: LD_VAR 0 3
26359: PPUSH
26360: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26364: LD_VAR 0 3
26368: PPUSH
26369: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26373: LD_EXP 40
26377: PPUSH
26378: LD_STRING D10BW-Joan-1
26380: PPUSH
26381: CALL_OW 94
// end ; if JMMGirl = 2 then
26385: LD_EXP 7
26389: PUSH
26390: LD_INT 2
26392: EQUAL
26393: IFFALSE 26449
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26395: LD_ADDR_EXP 42
26399: PUSH
26400: LD_STRING Lisa
26402: PPUSH
26403: LD_INT 1
26405: PPUSH
26406: LD_STRING 14_
26408: PPUSH
26409: CALL 64778 0 3
26413: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26414: LD_EXP 42
26418: PPUSH
26419: LD_VAR 0 3
26423: PPUSH
26424: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26428: LD_VAR 0 3
26432: PPUSH
26433: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26437: LD_EXP 42
26441: PPUSH
26442: LD_STRING D10BW-Lisa-1
26444: PPUSH
26445: CALL_OW 94
// end ; if JMMGirl = 3 then
26449: LD_EXP 7
26453: PUSH
26454: LD_INT 3
26456: EQUAL
26457: IFFALSE 26513
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26459: LD_ADDR_EXP 54
26463: PUSH
26464: LD_STRING Connie
26466: PPUSH
26467: LD_INT 1
26469: PPUSH
26470: LD_STRING 14_
26472: PPUSH
26473: CALL 64778 0 3
26477: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26478: LD_EXP 54
26482: PPUSH
26483: LD_VAR 0 3
26487: PPUSH
26488: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26492: LD_VAR 0 3
26496: PPUSH
26497: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26501: LD_EXP 54
26505: PPUSH
26506: LD_STRING D10BW-Con-1
26508: PPUSH
26509: CALL_OW 94
// end ; end ;
26513: PPOPN 3
26515: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26516: LD_EXP 14
26520: PUSH
26521: LD_INT 94500
26523: GREATEREQUAL
26524: IFFALSE 26936
26526: GO 26528
26528: DISABLE
26529: LD_INT 0
26531: PPUSH
26532: PPUSH
26533: PPUSH
// begin tmp := PrepareStevensSquad ;
26534: LD_ADDR_VAR 0 3
26538: PUSH
26539: CALL 2193 0 0
26543: ST_TO_ADDR
// if not tmp then
26544: LD_VAR 0 3
26548: NOT
26549: IFFALSE 26553
// exit ;
26551: GO 26936
// uc_side := 1 ;
26553: LD_ADDR_OWVAR 20
26557: PUSH
26558: LD_INT 1
26560: ST_TO_ADDR
// uc_nation := 1 ;
26561: LD_ADDR_OWVAR 21
26565: PUSH
26566: LD_INT 1
26568: ST_TO_ADDR
// for i in tmp do
26569: LD_ADDR_VAR 0 1
26573: PUSH
26574: LD_VAR 0 3
26578: PUSH
26579: FOR_IN
26580: IFFALSE 26677
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26582: LD_INT 3
26584: PPUSH
26585: LD_INT 3
26587: PPUSH
26588: LD_INT 1
26590: PPUSH
26591: LD_INT 5
26593: PUSH
26594: LD_INT 9
26596: PUSH
26597: LD_INT 7
26599: PUSH
26600: EMPTY
26601: LIST
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 1
26607: PPUSH
26608: LD_INT 3
26610: PPUSH
26611: CALL_OW 12
26615: ARRAY
26616: PPUSH
26617: LD_INT 40
26619: PPUSH
26620: CALL 71893 0 5
// veh := CreateVehicle ;
26624: LD_ADDR_VAR 0 2
26628: PUSH
26629: CALL_OW 45
26633: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26634: LD_VAR 0 2
26638: PPUSH
26639: LD_INT 1
26641: PPUSH
26642: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26646: LD_VAR 0 2
26650: PPUSH
26651: LD_INT 19
26653: PPUSH
26654: LD_INT 0
26656: PPUSH
26657: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26661: LD_VAR 0 1
26665: PPUSH
26666: LD_VAR 0 2
26670: PPUSH
26671: CALL_OW 52
// end ;
26675: GO 26579
26677: POP
26678: POP
// missionStage := 8 ;
26679: LD_ADDR_EXP 15
26683: PUSH
26684: LD_INT 8
26686: ST_TO_ADDR
// DialogueOn ;
26687: CALL_OW 6
// if Stevens then
26691: LD_EXP 41
26695: IFFALSE 26809
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26697: LD_EXP 41
26701: PPUSH
26702: CALL_OW 310
26706: PPUSH
26707: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26711: LD_EXP 41
26715: PPUSH
26716: LD_STRING D8-Huck-1
26718: PPUSH
26719: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26723: LD_EXP 39
26727: PPUSH
26728: LD_STRING D8-JMM-1
26730: PPUSH
26731: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26735: LD_EXP 41
26739: PPUSH
26740: LD_STRING D8-Huck-2
26742: PPUSH
26743: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26747: LD_EXP 39
26751: PPUSH
26752: LD_STRING D8-JMM-2
26754: PPUSH
26755: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26759: LD_EXP 41
26763: PPUSH
26764: LD_STRING D8-Huck-3
26766: PPUSH
26767: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26771: LD_EXP 39
26775: PPUSH
26776: LD_STRING D8-JMM-3
26778: PPUSH
26779: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26783: LD_EXP 41
26787: PPUSH
26788: LD_STRING D8-Huck-4
26790: PPUSH
26791: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26795: LD_EXP 39
26799: PPUSH
26800: LD_STRING D8-JMM-4
26802: PPUSH
26803: CALL_OW 88
// end else
26807: GO 26919
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26809: LD_EXP 55
26813: PPUSH
26814: CALL_OW 310
26818: PPUSH
26819: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26823: LD_EXP 55
26827: PPUSH
26828: LD_STRING D8-Huck-1
26830: PPUSH
26831: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26835: LD_EXP 39
26839: PPUSH
26840: LD_STRING D8-JMM-1a
26842: PPUSH
26843: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26847: LD_EXP 55
26851: PPUSH
26852: LD_STRING D8-Huck-2
26854: PPUSH
26855: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26859: LD_EXP 39
26863: PPUSH
26864: LD_STRING D8-JMM-2
26866: PPUSH
26867: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26871: LD_EXP 55
26875: PPUSH
26876: LD_STRING D8-Huck-3
26878: PPUSH
26879: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26883: LD_EXP 39
26887: PPUSH
26888: LD_STRING D8-JMM-3
26890: PPUSH
26891: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26895: LD_EXP 55
26899: PPUSH
26900: LD_STRING D8-Huck-4
26902: PPUSH
26903: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26907: LD_EXP 39
26911: PPUSH
26912: LD_STRING D8-JMM-4
26914: PPUSH
26915: CALL_OW 88
// end ; DialogueOff ;
26919: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26923: LD_INT 25
26925: PPUSH
26926: LD_INT 1
26928: PPUSH
26929: LD_INT 1
26931: PPUSH
26932: CALL_OW 322
// end ;
26936: PPOPN 3
26938: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26939: LD_INT 1
26941: PPUSH
26942: LD_EXP 71
26946: PPUSH
26947: CALL_OW 292
26951: IFFALSE 27202
26953: GO 26955
26955: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26956: LD_EXP 71
26960: PPUSH
26961: CALL_OW 87
// DialogueOn ;
26965: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26969: LD_EXP 39
26973: PPUSH
26974: LD_STRING D10nB-JMM-1
26976: PPUSH
26977: CALL_OW 88
// if BurlakStatus = 1 then
26981: LD_EXP 9
26985: PUSH
26986: LD_INT 1
26988: EQUAL
26989: IFFALSE 27003
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26991: LD_EXP 70
26995: PPUSH
26996: LD_STRING D10nB-Vse-1a
26998: PPUSH
26999: CALL_OW 94
// end ; if BurlakStatus = 0 then
27003: LD_EXP 9
27007: PUSH
27008: LD_INT 0
27010: EQUAL
27011: IFFALSE 27025
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27013: LD_EXP 70
27017: PPUSH
27018: LD_STRING D10nB-Vse-1
27020: PPUSH
27021: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27025: LD_EXP 39
27029: PPUSH
27030: LD_STRING D10nB-JMM-2
27032: PPUSH
27033: CALL_OW 88
// if KappaStatus then
27037: LD_EXP 2
27041: IFFALSE 27055
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27043: LD_EXP 70
27047: PPUSH
27048: LD_STRING D10nB-Vse-5a
27050: PPUSH
27051: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27055: LD_EXP 2
27059: NOT
27060: PUSH
27061: LD_EXP 6
27065: PUSH
27066: LD_INT 0
27068: EQUAL
27069: AND
27070: IFFALSE 27198
// begin if JMMGirl = 1 then
27072: LD_EXP 7
27076: PUSH
27077: LD_INT 1
27079: EQUAL
27080: IFFALSE 27130
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27082: LD_EXP 70
27086: PPUSH
27087: LD_STRING D10nB-Vse-2
27089: PPUSH
27090: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27094: LD_EXP 39
27098: PPUSH
27099: LD_STRING D10nB-JMM-3
27101: PPUSH
27102: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27106: LD_EXP 70
27110: PPUSH
27111: LD_STRING D10nB-Vse-3
27113: PPUSH
27114: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27118: LD_EXP 39
27122: PPUSH
27123: LD_STRING D10nB-JMM-4
27125: PPUSH
27126: CALL_OW 88
// end ; if JMMGirl = 2 then
27130: LD_EXP 7
27134: PUSH
27135: LD_INT 2
27137: EQUAL
27138: IFFALSE 27164
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27140: LD_EXP 70
27144: PPUSH
27145: LD_STRING D10nB-Vse-4
27147: PPUSH
27148: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27152: LD_EXP 39
27156: PPUSH
27157: LD_STRING D10nB-JMM-5
27159: PPUSH
27160: CALL_OW 88
// end ; if JMMGirl = 3 then
27164: LD_EXP 7
27168: PUSH
27169: LD_INT 3
27171: EQUAL
27172: IFFALSE 27198
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27174: LD_EXP 70
27178: PPUSH
27179: LD_STRING D10nB-Vse-5
27181: PPUSH
27182: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27186: LD_EXP 39
27190: PPUSH
27191: LD_STRING D10nB-JMM-6
27193: PPUSH
27194: CALL_OW 88
// end ; end ; DialogueOff ;
27198: CALL_OW 7
// end ;
27202: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27203: LD_EXP 14
27207: PUSH
27208: LD_INT 115500
27210: GREATEREQUAL
27211: IFFALSE 27587
27213: GO 27215
27215: DISABLE
27216: LD_INT 0
27218: PPUSH
// begin missionStage := 10 ;
27219: LD_ADDR_EXP 15
27223: PUSH
27224: LD_INT 10
27226: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27227: LD_ADDR_VAR 0 1
27231: PUSH
27232: LD_INT 22
27234: PUSH
27235: LD_INT 1
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: LD_INT 23
27244: PUSH
27245: LD_INT 1
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 26
27254: PUSH
27255: LD_INT 1
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: PUSH
27262: LD_INT 3
27264: PUSH
27265: LD_INT 25
27267: PUSH
27268: LD_INT 12
27270: PUSH
27271: EMPTY
27272: LIST
27273: LIST
27274: PUSH
27275: EMPTY
27276: LIST
27277: LIST
27278: PUSH
27279: LD_INT 3
27281: PUSH
27282: LD_INT 25
27284: PUSH
27285: LD_INT 16
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: LIST
27300: LIST
27301: LIST
27302: PPUSH
27303: CALL_OW 69
27307: PUSH
27308: LD_EXP 39
27312: PUSH
27313: LD_EXP 60
27317: PUSH
27318: LD_EXP 41
27322: PUSH
27323: LD_EXP 55
27327: PUSH
27328: LD_EXP 42
27332: PUSH
27333: LD_EXP 43
27337: PUSH
27338: LD_EXP 44
27342: PUSH
27343: LD_EXP 45
27347: PUSH
27348: LD_EXP 46
27352: PUSH
27353: LD_EXP 47
27357: PUSH
27358: LD_EXP 48
27362: PUSH
27363: LD_EXP 49
27367: PUSH
27368: LD_EXP 50
27372: PUSH
27373: LD_EXP 51
27377: PUSH
27378: LD_EXP 52
27382: PUSH
27383: LD_EXP 53
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: LIST
27402: LIST
27403: LIST
27404: LIST
27405: DIFF
27406: ST_TO_ADDR
// if not tmp and Brown then
27407: LD_VAR 0 1
27411: NOT
27412: PUSH
27413: LD_EXP 47
27417: AND
27418: IFFALSE 27433
// tmp := [ Brown ] ;
27420: LD_ADDR_VAR 0 1
27424: PUSH
27425: LD_EXP 47
27429: PUSH
27430: EMPTY
27431: LIST
27432: ST_TO_ADDR
// DialogueOn ;
27433: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27437: LD_VAR 0 1
27441: PUSH
27442: LD_INT 1
27444: ARRAY
27445: PPUSH
27446: LD_STRING D11-Sol1-1
27448: PPUSH
27449: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27453: LD_EXP 64
27457: PPUSH
27458: LD_STRING D11-Pla-1
27460: PPUSH
27461: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27465: LD_EXP 65
27469: PPUSH
27470: LD_STRING D11-Kov-1
27472: PPUSH
27473: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27477: LD_EXP 64
27481: PPUSH
27482: LD_STRING D11-Pla-2
27484: PPUSH
27485: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27489: LD_VAR 0 1
27493: PUSH
27494: LD_INT 1
27496: ARRAY
27497: PPUSH
27498: LD_STRING D11-Sol1-2
27500: PPUSH
27501: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27505: LD_EXP 39
27509: PPUSH
27510: LD_STRING D11-JMM-2
27512: PPUSH
27513: CALL_OW 88
// DialogueOff ;
27517: CALL_OW 7
// allowBehemothConstruct := true ;
27521: LD_ADDR_EXP 25
27525: PUSH
27526: LD_INT 1
27528: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27529: LD_STRING M4
27531: PPUSH
27532: CALL_OW 337
// BuildBehemoths ;
27536: CALL 7632 0 0
// repeat wait ( 15 15$00 ) ;
27540: LD_INT 31500
27542: PPUSH
27543: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27547: LD_EXP 27
27551: IFFALSE 27555
// break ;
27553: GO 27587
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27555: LD_INT 267
27557: PPUSH
27558: CALL_OW 274
27562: PPUSH
27563: LD_INT 1
27565: PPUSH
27566: CALL_OW 275
27570: PUSH
27571: LD_INT 1000
27573: GREATEREQUAL
27574: IFFALSE 27580
// BuildBehemoths ;
27576: CALL 7632 0 0
// until not behemothBuilders ;
27580: LD_EXP 73
27584: NOT
27585: IFFALSE 27540
// end ;
27587: PPOPN 1
27589: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27590: LD_EXP 73
27594: NOT
27595: PUSH
27596: LD_EXP 28
27600: NOT
27601: AND
27602: PUSH
27603: LD_EXP 25
27607: AND
27608: IFFALSE 27628
27610: GO 27612
27612: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27613: LD_STRING M4a
27615: PPUSH
27616: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27620: LD_ADDR_EXP 27
27624: PUSH
27625: LD_INT 1
27627: ST_TO_ADDR
// end ;
27628: END
// every 0 0$1 trigger behemothDone do
27629: LD_EXP 28
27633: IFFALSE 27645
27635: GO 27637
27637: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27638: LD_STRING M4b
27640: PPUSH
27641: CALL_OW 337
27645: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27646: LD_EXP 29
27650: NOT
27651: IFFALSE 27847
27653: GO 27655
27655: DISABLE
27656: LD_INT 0
27658: PPUSH
27659: PPUSH
// begin enable ;
27660: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27661: LD_ADDR_VAR 0 1
27665: PUSH
27666: LD_INT 3
27668: PPUSH
27669: CALL 107696 0 1
27673: ST_TO_ADDR
// if not tmp and not behemothDone then
27674: LD_VAR 0 1
27678: NOT
27679: PUSH
27680: LD_EXP 28
27684: NOT
27685: AND
27686: IFFALSE 27722
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27688: LD_ADDR_VAR 0 1
27692: PUSH
27693: LD_INT 22
27695: PUSH
27696: LD_INT 3
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: LD_INT 30
27705: PUSH
27706: LD_INT 37
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PPUSH
27717: CALL_OW 69
27721: ST_TO_ADDR
// if not tmp then
27722: LD_VAR 0 1
27726: NOT
27727: IFFALSE 27731
// exit ;
27729: GO 27847
// for i in tmp do
27731: LD_ADDR_VAR 0 2
27735: PUSH
27736: LD_VAR 0 1
27740: PUSH
27741: FOR_IN
27742: IFFALSE 27845
// if See ( 1 , i ) then
27744: LD_INT 1
27746: PPUSH
27747: LD_VAR 0 2
27751: PPUSH
27752: CALL_OW 292
27756: IFFALSE 27843
// begin if GetType ( i ) = unit_building then
27758: LD_VAR 0 2
27762: PPUSH
27763: CALL_OW 247
27767: PUSH
27768: LD_INT 3
27770: EQUAL
27771: IFFALSE 27809
// begin CenterNowOnUnits ( i ) ;
27773: LD_VAR 0 2
27777: PPUSH
27778: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27782: LD_EXP 39
27786: PPUSH
27787: LD_STRING D17a-JMM-1
27789: PPUSH
27790: CALL_OW 88
// seeBehemoth := true ;
27794: LD_ADDR_EXP 29
27798: PUSH
27799: LD_INT 1
27801: ST_TO_ADDR
// disable ;
27802: DISABLE
// exit ;
27803: POP
27804: POP
27805: GO 27847
// end else
27807: GO 27843
// begin CenterNowOnUnits ( i ) ;
27809: LD_VAR 0 2
27813: PPUSH
27814: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27818: LD_EXP 39
27822: PPUSH
27823: LD_STRING D17b-JMM-1
27825: PPUSH
27826: CALL_OW 88
// seeBehemoth := true ;
27830: LD_ADDR_EXP 29
27834: PUSH
27835: LD_INT 1
27837: ST_TO_ADDR
// disable ;
27838: DISABLE
// exit ;
27839: POP
27840: POP
27841: GO 27847
// end ; end ;
27843: GO 27741
27845: POP
27846: POP
// end ;
27847: PPOPN 2
27849: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27850: LD_EXP 14
27854: PUSH
27855: LD_INT 116550
27857: GREATEREQUAL
27858: IFFALSE 29034
27860: GO 27862
27862: DISABLE
27863: LD_INT 0
27865: PPUSH
27866: PPUSH
27867: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27868: LD_INT 2
27870: PPUSH
27871: LD_INT 23
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: LD_INT 3
27879: PUSH
27880: LD_INT 48
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: LIST
27887: LIST
27888: PUSH
27889: EMPTY
27890: LIST
27891: PPUSH
27892: CALL 58434 0 2
// repeat wait ( 0 0$1 ) ;
27896: LD_INT 35
27898: PPUSH
27899: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27903: LD_INT 22
27905: PUSH
27906: LD_INT 3
27908: PUSH
27909: EMPTY
27910: LIST
27911: LIST
27912: PUSH
27913: LD_INT 34
27915: PUSH
27916: LD_INT 48
27918: PUSH
27919: EMPTY
27920: LIST
27921: LIST
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PPUSH
27927: CALL_OW 69
27931: IFFALSE 27896
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27933: LD_ADDR_VAR 0 1
27937: PUSH
27938: LD_INT 22
27940: PUSH
27941: LD_INT 3
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: LD_INT 34
27950: PUSH
27951: LD_INT 48
27953: PUSH
27954: EMPTY
27955: LIST
27956: LIST
27957: PUSH
27958: EMPTY
27959: LIST
27960: LIST
27961: PPUSH
27962: CALL_OW 69
27966: PUSH
27967: LD_INT 1
27969: ARRAY
27970: ST_TO_ADDR
// missionStage := 12 ;
27971: LD_ADDR_EXP 15
27975: PUSH
27976: LD_INT 12
27978: ST_TO_ADDR
// platonovHasBomb := true ;
27979: LD_ADDR_EXP 30
27983: PUSH
27984: LD_INT 1
27986: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27987: LD_VAR 0 1
27991: PPUSH
27992: LD_INT 181
27994: PPUSH
27995: LD_INT 86
27997: PPUSH
27998: CALL_OW 171
// AddComHold ( bomb ) ;
28002: LD_VAR 0 1
28006: PPUSH
28007: CALL_OW 200
// wait ( 0 0$10 ) ;
28011: LD_INT 350
28013: PPUSH
28014: CALL_OW 67
// DialogueOn ;
28018: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28022: LD_EXP 64
28026: PPUSH
28027: LD_STRING D15-Pla-1
28029: PPUSH
28030: CALL_OW 94
// dec = Query ( Q15a ) ;
28034: LD_ADDR_VAR 0 2
28038: PUSH
28039: LD_STRING Q15a
28041: PPUSH
28042: CALL_OW 97
28046: ST_TO_ADDR
// if dec = 1 then
28047: LD_VAR 0 2
28051: PUSH
28052: LD_INT 1
28054: EQUAL
28055: IFFALSE 28078
// begin Say ( JMM , D15a-JMM-1 ) ;
28057: LD_EXP 39
28061: PPUSH
28062: LD_STRING D15a-JMM-1
28064: PPUSH
28065: CALL_OW 88
// YouLost ( Surrender ) ;
28069: LD_STRING Surrender
28071: PPUSH
28072: CALL_OW 104
// exit ;
28076: GO 29034
// end ; if dec = 2 then
28078: LD_VAR 0 2
28082: PUSH
28083: LD_INT 2
28085: EQUAL
28086: IFFALSE 28155
// begin Say ( JMM , D15b-JMM-1 ) ;
28088: LD_EXP 39
28092: PPUSH
28093: LD_STRING D15b-JMM-1
28095: PPUSH
28096: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28100: LD_EXP 64
28104: PPUSH
28105: LD_STRING D15b-Pla-1
28107: PPUSH
28108: CALL_OW 94
// DialogueOff ;
28112: CALL_OW 7
// wait ( 3 3$00 ) ;
28116: LD_INT 6300
28118: PPUSH
28119: CALL_OW 67
// DialogueOn ;
28123: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28127: LD_EXP 39
28131: PPUSH
28132: LD_STRING D15d-JMM-1a
28134: PPUSH
28135: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28139: LD_EXP 64
28143: PPUSH
28144: LD_STRING D15d-Pla-1
28146: PPUSH
28147: CALL_OW 94
// DialogueOff ;
28151: CALL_OW 7
// end ; if dec = 3 then
28155: LD_VAR 0 2
28159: PUSH
28160: LD_INT 3
28162: EQUAL
28163: IFFALSE 28217
// begin Say ( JMM , D15c-JMM-1 ) ;
28165: LD_EXP 39
28169: PPUSH
28170: LD_STRING D15c-JMM-1
28172: PPUSH
28173: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28177: LD_EXP 64
28181: PPUSH
28182: LD_STRING D15c-Pla-1
28184: PPUSH
28185: CALL_OW 94
// DialogueOff ;
28189: CALL_OW 7
// wait ( 0 0$15 ) ;
28193: LD_INT 525
28195: PPUSH
28196: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28200: LD_VAR 0 1
28204: PPUSH
28205: LD_INT 60
28207: PPUSH
28208: LD_INT 95
28210: PPUSH
28211: CALL_OW 116
// exit ;
28215: GO 29034
// end ; if dec = 4 then
28217: LD_VAR 0 2
28221: PUSH
28222: LD_INT 4
28224: EQUAL
28225: IFFALSE 28255
// begin Say ( JMM , D15d-JMM-1 ) ;
28227: LD_EXP 39
28231: PPUSH
28232: LD_STRING D15d-JMM-1
28234: PPUSH
28235: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28239: LD_EXP 64
28243: PPUSH
28244: LD_STRING D15d-Pla-1
28246: PPUSH
28247: CALL_OW 94
// DialogueOff ;
28251: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28255: LD_EXP 62
28259: PPUSH
28260: CALL_OW 302
28264: PUSH
28265: LD_EXP 62
28269: PPUSH
28270: CALL_OW 255
28274: PUSH
28275: LD_INT 1
28277: EQUAL
28278: AND
28279: PUSH
28280: LD_INT 22
28282: PUSH
28283: LD_INT 1
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 34
28292: PUSH
28293: LD_INT 8
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PPUSH
28304: CALL_OW 69
28308: NOT
28309: AND
28310: IFFALSE 28935
// begin SetSide ( Friend , 8 ) ;
28312: LD_EXP 62
28316: PPUSH
28317: LD_INT 8
28319: PPUSH
28320: CALL_OW 235
// if IsInUnit ( Friend ) then
28324: LD_EXP 62
28328: PPUSH
28329: CALL_OW 310
28333: IFFALSE 28344
// ComExitBuilding ( Friend ) ;
28335: LD_EXP 62
28339: PPUSH
28340: CALL_OW 122
// if IsDriver ( Friend ) then
28344: LD_EXP 62
28348: PPUSH
28349: CALL 105373 0 1
28353: IFFALSE 28364
// ComExitVehicle ( Friend ) ;
28355: LD_EXP 62
28359: PPUSH
28360: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28364: LD_EXP 62
28368: PPUSH
28369: LD_INT 9
28371: PPUSH
28372: LD_INT 2
28374: PPUSH
28375: CALL_OW 171
// wait ( 0 0$05 ) ;
28379: LD_INT 175
28381: PPUSH
28382: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28386: LD_EXP 62
28390: PPUSH
28391: CALL_OW 87
// DialogueOn ;
28395: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28399: LD_EXP 39
28403: PPUSH
28404: LD_STRING D16-JMM-1
28406: PPUSH
28407: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28411: LD_EXP 62
28415: PPUSH
28416: LD_STRING D16-Friend-1
28418: PPUSH
28419: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28423: LD_EXP 39
28427: PPUSH
28428: LD_STRING D16-JMM-2
28430: PPUSH
28431: CALL_OW 88
// DialogueOff ;
28435: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28439: LD_EXP 62
28443: PPUSH
28444: LD_INT 1
28446: PPUSH
28447: CALL_OW 235
// ComHold ( Friend ) ;
28451: LD_EXP 62
28455: PPUSH
28456: CALL_OW 140
// wait ( 0 0$20 ) ;
28460: LD_INT 700
28462: PPUSH
28463: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28467: LD_EXP 62
28471: PPUSH
28472: LD_INT 9
28474: PPUSH
28475: LD_INT 2
28477: PPUSH
28478: CALL_OW 297
28482: PUSH
28483: LD_INT 30
28485: LESS
28486: IFFALSE 28555
// begin SetSide ( Friend , 8 ) ;
28488: LD_EXP 62
28492: PPUSH
28493: LD_INT 8
28495: PPUSH
28496: CALL_OW 235
// if IsInUnit ( Friend ) then
28500: LD_EXP 62
28504: PPUSH
28505: CALL_OW 310
28509: IFFALSE 28520
// ComExitBuilding ( Friend ) ;
28511: LD_EXP 62
28515: PPUSH
28516: CALL_OW 122
// if IsDriver ( Friend ) then
28520: LD_EXP 62
28524: PPUSH
28525: CALL 105373 0 1
28529: IFFALSE 28540
// ComExitVehicle ( Friend ) ;
28531: LD_EXP 62
28535: PPUSH
28536: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28540: LD_EXP 62
28544: PPUSH
28545: LD_INT 9
28547: PPUSH
28548: LD_INT 2
28550: PPUSH
28551: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28555: LD_INT 1050
28557: PPUSH
28558: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28562: LD_INT 22
28564: PUSH
28565: LD_INT 1
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: LD_INT 34
28574: PUSH
28575: LD_INT 8
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PPUSH
28586: CALL_OW 69
28590: NOT
28591: IFFALSE 28913
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28593: LD_ADDR_VAR 0 3
28597: PUSH
28598: LD_INT 22
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: LD_INT 26
28610: PUSH
28611: LD_INT 1
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: LD_INT 3
28620: PUSH
28621: LD_INT 25
28623: PUSH
28624: LD_INT 12
28626: PUSH
28627: EMPTY
28628: LIST
28629: LIST
28630: PUSH
28631: LD_INT 25
28633: PUSH
28634: LD_INT 16
28636: PUSH
28637: EMPTY
28638: LIST
28639: LIST
28640: PUSH
28641: EMPTY
28642: LIST
28643: LIST
28644: LIST
28645: PUSH
28646: EMPTY
28647: LIST
28648: LIST
28649: LIST
28650: PPUSH
28651: CALL_OW 69
28655: PUSH
28656: LD_EXP 39
28660: PUSH
28661: LD_EXP 41
28665: PUSH
28666: LD_EXP 55
28670: PUSH
28671: LD_EXP 42
28675: PUSH
28676: LD_EXP 43
28680: PUSH
28681: LD_EXP 44
28685: PUSH
28686: LD_EXP 45
28690: PUSH
28691: LD_EXP 46
28695: PUSH
28696: LD_EXP 47
28700: PUSH
28701: LD_EXP 48
28705: PUSH
28706: LD_EXP 49
28710: PUSH
28711: LD_EXP 50
28715: PUSH
28716: LD_EXP 51
28720: PUSH
28721: LD_EXP 52
28725: PUSH
28726: LD_EXP 53
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: LIST
28735: LIST
28736: LIST
28737: LIST
28738: LIST
28739: LIST
28740: LIST
28741: LIST
28742: LIST
28743: LIST
28744: LIST
28745: LIST
28746: LIST
28747: DIFF
28748: ST_TO_ADDR
// DialogueOn ;
28749: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28753: LD_EXP 64
28757: PPUSH
28758: LD_STRING D16a-Pla-1
28760: PPUSH
28761: CALL_OW 94
// if Stevens then
28765: LD_EXP 41
28769: IFFALSE 28785
// Say ( Stevens , D16a-Huck-1 ) else
28771: LD_EXP 41
28775: PPUSH
28776: LD_STRING D16a-Huck-1
28778: PPUSH
28779: CALL_OW 88
28783: GO 28827
// if Baker then
28785: LD_EXP 55
28789: IFFALSE 28805
// Say ( Baker , D16a-Huck-1 ) else
28791: LD_EXP 55
28795: PPUSH
28796: LD_STRING D16a-Huck-1
28798: PPUSH
28799: CALL_OW 88
28803: GO 28827
// if tmp then
28805: LD_VAR 0 3
28809: IFFALSE 28827
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28811: LD_VAR 0 3
28815: PUSH
28816: LD_INT 1
28818: ARRAY
28819: PPUSH
28820: LD_STRING D16a-Sol1-1
28822: PPUSH
28823: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28827: LD_EXP 62
28831: PPUSH
28832: CALL_OW 255
28836: PUSH
28837: LD_INT 8
28839: EQUAL
28840: IFFALSE 28856
// Say ( JMM , D16a-JMM-1 ) else
28842: LD_EXP 39
28846: PPUSH
28847: LD_STRING D16a-JMM-1
28849: PPUSH
28850: CALL_OW 88
28854: GO 28892
// begin Say ( JMM , D16a-JMM-1a ) ;
28856: LD_EXP 39
28860: PPUSH
28861: LD_STRING D16a-JMM-1a
28863: PPUSH
28864: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28868: LD_EXP 62
28872: PPUSH
28873: LD_STRING D16a-Friend-1
28875: PPUSH
28876: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28880: LD_EXP 62
28884: PPUSH
28885: LD_INT 3
28887: PPUSH
28888: CALL_OW 235
// end ; DialogueOff ;
28892: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28896: LD_VAR 0 1
28900: PPUSH
28901: LD_INT 60
28903: PPUSH
28904: LD_INT 95
28906: PPUSH
28907: CALL_OW 116
// end else
28911: GO 28933
// begin DialogueOn ;
28913: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28917: LD_EXP 64
28921: PPUSH
28922: LD_STRING D16c-Pla-
28924: PPUSH
28925: CALL_OW 94
// DialogueOff ;
28929: CALL_OW 7
// end ; end else
28933: GO 29034
// begin wait ( 3 3$00 ) ;
28935: LD_INT 6300
28937: PPUSH
28938: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28942: LD_INT 22
28944: PUSH
28945: LD_INT 1
28947: PUSH
28948: EMPTY
28949: LIST
28950: LIST
28951: PUSH
28952: LD_INT 34
28954: PUSH
28955: LD_INT 8
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PPUSH
28966: CALL_OW 69
28970: NOT
28971: IFFALSE 29014
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28973: LD_EXP 64
28977: PPUSH
28978: LD_STRING D16b-Pla-1
28980: PPUSH
28981: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28985: LD_EXP 39
28989: PPUSH
28990: LD_STRING D16b-JMM-
28992: PPUSH
28993: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28997: LD_VAR 0 1
29001: PPUSH
29002: LD_INT 60
29004: PPUSH
29005: LD_INT 95
29007: PPUSH
29008: CALL_OW 116
// end else
29012: GO 29034
// begin DialogueOn ;
29014: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29018: LD_EXP 64
29022: PPUSH
29023: LD_STRING D16c-Pla-
29025: PPUSH
29026: CALL_OW 94
// DialogueOff ;
29030: CALL_OW 7
// end ; end ; end ;
29034: PPOPN 3
29036: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29037: LD_EXP 14
29041: PUSH
29042: LD_INT 126000
29044: GREATEREQUAL
29045: PUSH
29046: LD_EXP 23
29050: NOT
29051: AND
29052: PUSH
29053: LD_EXP 74
29057: PPUSH
29058: CALL_OW 302
29062: AND
29063: IFFALSE 29421
29065: GO 29067
29067: DISABLE
29068: LD_INT 0
29070: PPUSH
// begin missionStage = 11 ;
29071: LD_ADDR_EXP 15
29075: PUSH
29076: LD_INT 11
29078: ST_TO_ADDR
// DialogueOn ;
29079: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29083: LD_EXP 74
29087: PPUSH
29088: LD_STRING D9-Roth-1
29090: PPUSH
29091: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29095: LD_EXP 39
29099: PPUSH
29100: LD_STRING D9-JMM-1
29102: PPUSH
29103: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29107: LD_EXP 74
29111: PPUSH
29112: LD_STRING D9-Roth-2
29114: PPUSH
29115: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29119: LD_EXP 74
29123: PPUSH
29124: LD_STRING D9-Roth-2a
29126: PPUSH
29127: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29131: LD_EXP 64
29135: PPUSH
29136: LD_STRING D9-Pla-2
29138: PPUSH
29139: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29143: LD_EXP 74
29147: PPUSH
29148: LD_STRING D9-Roth-3
29150: PPUSH
29151: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29155: LD_EXP 64
29159: PPUSH
29160: LD_STRING D9-Pla-3
29162: PPUSH
29163: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29167: LD_EXP 74
29171: PPUSH
29172: LD_STRING D9-Roth-4
29174: PPUSH
29175: CALL_OW 94
// dec = Query ( Q9 ) ;
29179: LD_ADDR_VAR 0 1
29183: PUSH
29184: LD_STRING Q9
29186: PPUSH
29187: CALL_OW 97
29191: ST_TO_ADDR
// if dec = 1 then
29192: LD_VAR 0 1
29196: PUSH
29197: LD_INT 1
29199: EQUAL
29200: IFFALSE 29214
// SayRadio ( Roth , D9a-Roth-1 ) ;
29202: LD_EXP 74
29206: PPUSH
29207: LD_STRING D9a-Roth-1
29209: PPUSH
29210: CALL_OW 94
// if dec = 2 then
29214: LD_VAR 0 1
29218: PUSH
29219: LD_INT 2
29221: EQUAL
29222: IFFALSE 29248
// begin Say ( JMM , D9b-JMM-1 ) ;
29224: LD_EXP 39
29228: PPUSH
29229: LD_STRING D9b-JMM-1
29231: PPUSH
29232: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29236: LD_EXP 74
29240: PPUSH
29241: LD_STRING D9b-Roth-1
29243: PPUSH
29244: CALL_OW 94
// end ; if dec = 3 then
29248: LD_VAR 0 1
29252: PUSH
29253: LD_INT 3
29255: EQUAL
29256: IFFALSE 29318
// begin Say ( JMM , D9c-JMM-1 ) ;
29258: LD_EXP 39
29262: PPUSH
29263: LD_STRING D9c-JMM-1
29265: PPUSH
29266: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29270: LD_EXP 74
29274: PPUSH
29275: LD_STRING D9c-Roth-1
29277: PPUSH
29278: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29282: LD_EXP 39
29286: PPUSH
29287: LD_STRING D9c-JMM-2
29289: PPUSH
29290: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29294: LD_EXP 74
29298: PPUSH
29299: LD_STRING D9c-Roth-2
29301: PPUSH
29302: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29306: LD_EXP 39
29310: PPUSH
29311: LD_STRING D9c-JMM-3
29313: PPUSH
29314: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29318: LD_EXP 74
29322: PPUSH
29323: LD_STRING D9c-Roth-3
29325: PPUSH
29326: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29330: LD_EXP 74
29334: PPUSH
29335: LD_STRING D9cont-Roth-1
29337: PPUSH
29338: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29342: LD_EXP 39
29346: PPUSH
29347: LD_STRING D9cont-JMM-1
29349: PPUSH
29350: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29354: LD_EXP 74
29358: PPUSH
29359: LD_STRING D9cont-Roth-2
29361: PPUSH
29362: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29366: LD_EXP 39
29370: PPUSH
29371: LD_STRING D9cont-JMM-2
29373: PPUSH
29374: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29378: LD_EXP 74
29382: PPUSH
29383: LD_STRING D9cont-Roth-3
29385: PPUSH
29386: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29390: LD_EXP 39
29394: PPUSH
29395: LD_STRING D9cont-JMM-3
29397: PPUSH
29398: CALL_OW 88
// DialogueOff ;
29402: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29406: LD_STRING M3
29408: PPUSH
29409: CALL_OW 337
// allianceActive := true ;
29413: LD_ADDR_EXP 31
29417: PUSH
29418: LD_INT 1
29420: ST_TO_ADDR
// end ;
29421: PPOPN 1
29423: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29424: LD_EXP 64
29428: PPUSH
29429: CALL_OW 301
29433: PUSH
29434: LD_EXP 67
29438: PPUSH
29439: CALL_OW 301
29443: AND
29444: PUSH
29445: LD_INT 22
29447: PUSH
29448: LD_INT 3
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: PUSH
29455: LD_INT 21
29457: PUSH
29458: LD_INT 1
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PUSH
29465: LD_INT 50
29467: PUSH
29468: EMPTY
29469: LIST
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: LIST
29475: PPUSH
29476: CALL_OW 69
29480: PUSH
29481: LD_INT 7
29483: PUSH
29484: LD_INT 8
29486: PUSH
29487: LD_INT 9
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: LIST
29494: PUSH
29495: LD_OWVAR 67
29499: ARRAY
29500: LESS
29501: AND
29502: IFFALSE 30273
29504: GO 29506
29506: DISABLE
29507: LD_INT 0
29509: PPUSH
29510: PPUSH
29511: PPUSH
29512: PPUSH
// begin MC_Kill ( 1 ) ;
29513: LD_INT 1
29515: PPUSH
29516: CALL 34974 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29520: LD_INT 1
29522: PPUSH
29523: LD_INT 3
29525: PPUSH
29526: LD_INT 1
29528: PPUSH
29529: LD_INT 1
29531: PPUSH
29532: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29536: LD_ADDR_VAR 0 1
29540: PUSH
29541: LD_INT 22
29543: PUSH
29544: LD_INT 3
29546: PUSH
29547: EMPTY
29548: LIST
29549: LIST
29550: PUSH
29551: LD_INT 21
29553: PUSH
29554: LD_INT 1
29556: PUSH
29557: EMPTY
29558: LIST
29559: LIST
29560: PUSH
29561: LD_INT 24
29563: PUSH
29564: LD_INT 900
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: LIST
29575: PPUSH
29576: CALL_OW 69
29580: PUSH
29581: FOR_IN
29582: IFFALSE 29613
// if GetSex ( i ) = sex_male then
29584: LD_VAR 0 1
29588: PPUSH
29589: CALL_OW 258
29593: PUSH
29594: LD_INT 1
29596: EQUAL
29597: IFFALSE 29611
// begin tmp = i ;
29599: LD_ADDR_VAR 0 2
29603: PUSH
29604: LD_VAR 0 1
29608: ST_TO_ADDR
// break ;
29609: GO 29613
// end ;
29611: GO 29581
29613: POP
29614: POP
// if tmp = 0 then
29615: LD_VAR 0 2
29619: PUSH
29620: LD_INT 0
29622: EQUAL
29623: IFFALSE 29677
// begin uc_side = 3 ;
29625: LD_ADDR_OWVAR 20
29629: PUSH
29630: LD_INT 3
29632: ST_TO_ADDR
// uc_nation = 3 ;
29633: LD_ADDR_OWVAR 21
29637: PUSH
29638: LD_INT 3
29640: ST_TO_ADDR
// hc_name =  ;
29641: LD_ADDR_OWVAR 26
29645: PUSH
29646: LD_STRING 
29648: ST_TO_ADDR
// hc_gallery =  ;
29649: LD_ADDR_OWVAR 33
29653: PUSH
29654: LD_STRING 
29656: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29657: LD_INT 1
29659: PPUSH
29660: LD_INT 10
29662: PPUSH
29663: CALL_OW 381
// tmp = CreateHuman ;
29667: LD_ADDR_VAR 0 2
29671: PUSH
29672: CALL_OW 44
29676: ST_TO_ADDR
// end ; DialogueOn ;
29677: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29681: LD_VAR 0 2
29685: PPUSH
29686: LD_STRING DSurrenderRussians-RSol1-1a
29688: PPUSH
29689: CALL_OW 94
// DialogueOff ;
29693: CALL_OW 7
// russianDestroyed := true ;
29697: LD_ADDR_EXP 21
29701: PUSH
29702: LD_INT 1
29704: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29705: LD_INT 22
29707: PUSH
29708: LD_INT 3
29710: PUSH
29711: EMPTY
29712: LIST
29713: LIST
29714: PUSH
29715: LD_INT 21
29717: PUSH
29718: LD_INT 1
29720: PUSH
29721: EMPTY
29722: LIST
29723: LIST
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PPUSH
29729: CALL_OW 69
29733: PPUSH
29734: CALL_OW 122
// wait ( 0 0$1 ) ;
29738: LD_INT 35
29740: PPUSH
29741: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29745: LD_INT 22
29747: PUSH
29748: LD_INT 3
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: LD_INT 21
29757: PUSH
29758: LD_INT 1
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PPUSH
29769: CALL_OW 69
29773: PPUSH
29774: LD_INT 25
29776: PPUSH
29777: CALL_OW 173
// wait ( 0 0$10 ) ;
29781: LD_INT 350
29783: PPUSH
29784: CALL_OW 67
// PrepareOmarInvasion ;
29788: CALL 13752 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29792: LD_ADDR_VAR 0 2
29796: PUSH
29797: LD_EXP 92
29801: PPUSH
29802: CALL_OW 250
29806: PUSH
29807: LD_EXP 92
29811: PPUSH
29812: CALL_OW 251
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29821: LD_VAR 0 2
29825: PUSH
29826: LD_INT 1
29828: ARRAY
29829: PPUSH
29830: LD_VAR 0 2
29834: PUSH
29835: LD_INT 2
29837: ARRAY
29838: PPUSH
29839: LD_INT 1
29841: PPUSH
29842: LD_INT 8
29844: NEG
29845: PPUSH
29846: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29850: LD_EXP 92
29854: PPUSH
29855: CALL_OW 87
// DialogueOn ;
29859: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29863: LD_EXP 39
29867: PPUSH
29868: LD_STRING D19-JMM-1
29870: PPUSH
29871: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29875: LD_ADDR_VAR 0 3
29879: PUSH
29880: LD_INT 22
29882: PUSH
29883: LD_INT 1
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: PUSH
29890: LD_INT 26
29892: PUSH
29893: LD_INT 1
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: PUSH
29900: LD_INT 2
29902: PUSH
29903: LD_INT 25
29905: PUSH
29906: LD_INT 1
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 25
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 25
29925: PUSH
29926: LD_INT 3
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 25
29935: PUSH
29936: LD_INT 4
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 25
29945: PUSH
29946: LD_INT 5
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 25
29955: PUSH
29956: LD_INT 8
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: LIST
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: LIST
29976: PPUSH
29977: CALL_OW 69
29981: PUSH
29982: LD_EXP 39
29986: PUSH
29987: LD_EXP 40
29991: PUSH
29992: LD_EXP 41
29996: PUSH
29997: LD_EXP 42
30001: PUSH
30002: LD_EXP 43
30006: PUSH
30007: LD_EXP 44
30011: PUSH
30012: LD_EXP 45
30016: PUSH
30017: LD_EXP 46
30021: PUSH
30022: LD_EXP 47
30026: PUSH
30027: LD_EXP 48
30031: PUSH
30032: LD_EXP 49
30036: PUSH
30037: LD_EXP 50
30041: PUSH
30042: LD_EXP 51
30046: PUSH
30047: LD_EXP 52
30051: PUSH
30052: LD_EXP 53
30056: PUSH
30057: LD_EXP 54
30061: PUSH
30062: LD_EXP 55
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: LIST
30071: LIST
30072: LIST
30073: LIST
30074: LIST
30075: LIST
30076: LIST
30077: LIST
30078: LIST
30079: LIST
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: LIST
30085: DIFF
30086: ST_TO_ADDR
// if tmp2 then
30087: LD_VAR 0 3
30091: IFFALSE 30109
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30093: LD_VAR 0 3
30097: PUSH
30098: LD_INT 1
30100: ARRAY
30101: PPUSH
30102: LD_STRING D19-Sol1-1
30104: PPUSH
30105: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30109: LD_EXP 39
30113: PPUSH
30114: LD_STRING D19-JMM-2
30116: PPUSH
30117: CALL_OW 88
// DialogueOff ;
30121: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30125: LD_VAR 0 2
30129: PUSH
30130: LD_INT 1
30132: ARRAY
30133: PPUSH
30134: LD_VAR 0 2
30138: PUSH
30139: LD_INT 2
30141: ARRAY
30142: PPUSH
30143: LD_INT 1
30145: PPUSH
30146: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30150: LD_STRING M5
30152: PPUSH
30153: CALL_OW 337
// omarOnMotherLode := false ;
30157: LD_ADDR_VAR 0 4
30161: PUSH
30162: LD_INT 0
30164: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30165: LD_INT 35
30167: PPUSH
30168: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30172: LD_EXP 92
30176: PPUSH
30177: LD_INT 215
30179: PPUSH
30180: LD_INT 100
30182: PPUSH
30183: CALL_OW 297
30187: PUSH
30188: LD_INT 10
30190: LESS
30191: PUSH
30192: LD_VAR 0 4
30196: NOT
30197: AND
30198: IFFALSE 30232
// begin omarOnMotherLode := true ;
30200: LD_ADDR_VAR 0 4
30204: PUSH
30205: LD_INT 1
30207: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30208: LD_EXP 39
30212: PPUSH
30213: LD_STRING D19b-JMM-1
30215: PPUSH
30216: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30220: LD_EXP 92
30224: PPUSH
30225: LD_STRING DOmarContam-Omar-1
30227: PPUSH
30228: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30232: LD_EXP 92
30236: PPUSH
30237: CALL_OW 301
30241: IFFALSE 30165
// Say ( JMM , D19a-JMM-1 ) ;
30243: LD_EXP 39
30247: PPUSH
30248: LD_STRING D19a-JMM-1
30250: PPUSH
30251: CALL_OW 88
// if Heike then
30255: LD_EXP 93
30259: IFFALSE 30273
// Say ( Heike , D19a-Hke-1 ) ;
30261: LD_EXP 93
30265: PPUSH
30266: LD_STRING D19a-Hke-1
30268: PPUSH
30269: CALL_OW 88
// end ;
30273: PPOPN 4
30275: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30276: LD_INT 22
30278: PUSH
30279: LD_INT 3
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 21
30288: PUSH
30289: LD_INT 1
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PPUSH
30300: CALL_OW 69
30304: PUSH
30305: LD_EXP 21
30309: AND
30310: IFFALSE 30378
30312: GO 30314
30314: DISABLE
30315: LD_INT 0
30317: PPUSH
30318: PPUSH
// begin enable ;
30319: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30320: LD_ADDR_VAR 0 2
30324: PUSH
30325: LD_INT 25
30327: PPUSH
30328: LD_INT 22
30330: PUSH
30331: LD_INT 3
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: PPUSH
30338: CALL_OW 70
30342: ST_TO_ADDR
// if not tmp then
30343: LD_VAR 0 2
30347: NOT
30348: IFFALSE 30352
// exit ;
30350: GO 30378
// for i in tmp do
30352: LD_ADDR_VAR 0 1
30356: PUSH
30357: LD_VAR 0 2
30361: PUSH
30362: FOR_IN
30363: IFFALSE 30376
// RemoveUnit ( i ) ;
30365: LD_VAR 0 1
30369: PPUSH
30370: CALL_OW 64
30374: GO 30362
30376: POP
30377: POP
// end ;
30378: PPOPN 2
30380: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30381: LD_INT 22
30383: PUSH
30384: LD_INT 7
30386: PUSH
30387: EMPTY
30388: LIST
30389: LIST
30390: PUSH
30391: LD_INT 21
30393: PUSH
30394: LD_INT 1
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: EMPTY
30402: LIST
30403: LIST
30404: PPUSH
30405: CALL_OW 69
30409: PUSH
30410: LD_INT 6
30412: LESS
30413: IFFALSE 30881
30415: GO 30417
30417: DISABLE
30418: LD_INT 0
30420: PPUSH
30421: PPUSH
// begin MC_Kill ( 1 ) ;
30422: LD_INT 1
30424: PPUSH
30425: CALL 34974 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30429: LD_INT 7
30431: PPUSH
30432: LD_INT 1
30434: PPUSH
30435: LD_INT 1
30437: PPUSH
30438: LD_INT 1
30440: PPUSH
30441: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30445: LD_ADDR_VAR 0 1
30449: PUSH
30450: LD_INT 22
30452: PUSH
30453: LD_INT 7
30455: PUSH
30456: EMPTY
30457: LIST
30458: LIST
30459: PUSH
30460: LD_INT 26
30462: PUSH
30463: LD_INT 1
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: PPUSH
30474: CALL_OW 69
30478: PUSH
30479: LD_EXP 74
30483: DIFF
30484: ST_TO_ADDR
// if tmp then
30485: LD_VAR 0 1
30489: IFFALSE 30507
// tmp := tmp [ 1 ] else
30491: LD_ADDR_VAR 0 1
30495: PUSH
30496: LD_VAR 0 1
30500: PUSH
30501: LD_INT 1
30503: ARRAY
30504: ST_TO_ADDR
30505: GO 30543
// begin uc_side := 7 ;
30507: LD_ADDR_OWVAR 20
30511: PUSH
30512: LD_INT 7
30514: ST_TO_ADDR
// uc_nation := 1 ;
30515: LD_ADDR_OWVAR 21
30519: PUSH
30520: LD_INT 1
30522: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30523: LD_INT 1
30525: PPUSH
30526: LD_INT 8
30528: PPUSH
30529: CALL_OW 384
// tmp := CreateHuman ;
30533: LD_ADDR_VAR 0 1
30537: PUSH
30538: CALL_OW 44
30542: ST_TO_ADDR
// end ; DialogueOn ;
30543: CALL_OW 6
// if IsOK ( Roth ) then
30547: LD_EXP 74
30551: PPUSH
30552: CALL_OW 302
30556: IFFALSE 30570
// Say ( JMM , DAb-JMM-1 ) ;
30558: LD_EXP 39
30562: PPUSH
30563: LD_STRING DAb-JMM-1
30565: PPUSH
30566: CALL_OW 88
// if IsOK ( Roth ) then
30570: LD_EXP 74
30574: PPUSH
30575: CALL_OW 302
30579: IFFALSE 30603
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30581: LD_EXP 74
30585: PPUSH
30586: LD_STRING DSurrenderAlliance-Roth-1
30588: PPUSH
30589: CALL_OW 88
// RothCaptured := true ;
30593: LD_ADDR_EXP 33
30597: PUSH
30598: LD_INT 1
30600: ST_TO_ADDR
// end else
30601: GO 30615
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30603: LD_VAR 0 1
30607: PPUSH
30608: LD_STRING DSurrenderAlliance-Sci1-1
30610: PPUSH
30611: CALL_OW 88
// DialogueOff ;
30615: CALL_OW 7
// allianceDestroyed := true ;
30619: LD_ADDR_EXP 23
30623: PUSH
30624: LD_INT 1
30626: ST_TO_ADDR
// if capturedUnit = 0 then
30627: LD_EXP 34
30631: PUSH
30632: LD_INT 0
30634: EQUAL
30635: IFFALSE 30644
// SetAchievement ( ACH_ALLIANCE ) ;
30637: LD_STRING ACH_ALLIANCE
30639: PPUSH
30640: CALL_OW 543
// if trueAmericans then
30644: LD_EXP 35
30648: IFFALSE 30724
// begin if trueAmericans = 1 then
30650: LD_EXP 35
30654: PUSH
30655: LD_INT 1
30657: EQUAL
30658: IFFALSE 30674
// Say ( JMM , DAb-JMM-1a ) else
30660: LD_EXP 39
30664: PPUSH
30665: LD_STRING DAb-JMM-1a
30667: PPUSH
30668: CALL_OW 88
30672: GO 30686
// Say ( JMM , DAb-JMM-1b ) ;
30674: LD_EXP 39
30678: PPUSH
30679: LD_STRING DAb-JMM-1b
30681: PPUSH
30682: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30686: LD_EXP 35
30690: PPUSH
30691: CALL_OW 87
// for i in trueAmericans do
30695: LD_ADDR_VAR 0 2
30699: PUSH
30700: LD_EXP 35
30704: PUSH
30705: FOR_IN
30706: IFFALSE 30722
// SetSide ( i , 1 ) ;
30708: LD_VAR 0 2
30712: PPUSH
30713: LD_INT 1
30715: PPUSH
30716: CALL_OW 235
30720: GO 30705
30722: POP
30723: POP
// end ; repeat wait ( 0 0$1 ) ;
30724: LD_INT 35
30726: PPUSH
30727: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30731: LD_ADDR_VAR 0 2
30735: PUSH
30736: LD_INT 22
30738: PUSH
30739: LD_INT 7
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 21
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PPUSH
30760: CALL_OW 69
30764: PUSH
30765: FOR_IN
30766: IFFALSE 30848
// begin if IsInUnit ( i ) then
30768: LD_VAR 0 2
30772: PPUSH
30773: CALL_OW 310
30777: IFFALSE 30788
// ComExitBuilding ( i ) ;
30779: LD_VAR 0 2
30783: PPUSH
30784: CALL_OW 122
// if IsDriver ( i ) then
30788: LD_VAR 0 2
30792: PPUSH
30793: CALL 105373 0 1
30797: IFFALSE 30808
// ComExitVehicle ( i ) ;
30799: LD_VAR 0 2
30803: PPUSH
30804: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30808: LD_VAR 0 2
30812: PPUSH
30813: LD_INT 26
30815: PPUSH
30816: CALL_OW 308
30820: NOT
30821: IFFALSE 30837
// AddComMoveToArea ( i , allianceEscapeArea ) else
30823: LD_VAR 0 2
30827: PPUSH
30828: LD_INT 26
30830: PPUSH
30831: CALL_OW 173
30835: GO 30846
// RemoveUnit ( i ) ;
30837: LD_VAR 0 2
30841: PPUSH
30842: CALL_OW 64
// end ;
30846: GO 30765
30848: POP
30849: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30850: LD_INT 22
30852: PUSH
30853: LD_INT 7
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 21
30862: PUSH
30863: LD_INT 1
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PPUSH
30874: CALL_OW 69
30878: NOT
30879: IFFALSE 30724
// end ;
30881: PPOPN 2
30883: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30884: LD_INT 0
30886: PPUSH
30887: PPUSH
// if not unit then
30888: LD_VAR 0 1
30892: NOT
30893: IFFALSE 30897
// exit ;
30895: GO 32395
// DoNotAttack ( 7 , unit ) ;
30897: LD_INT 7
30899: PPUSH
30900: LD_VAR 0 1
30904: PPUSH
30905: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30909: LD_VAR 0 1
30913: PPUSH
30914: LD_INT 260
30916: PPUSH
30917: LD_INT 235
30919: PPUSH
30920: LD_INT 3
30922: PPUSH
30923: LD_INT 1
30925: PPUSH
30926: CALL_OW 483
// SetSide ( unit , 4 ) ;
30930: LD_VAR 0 1
30934: PPUSH
30935: LD_INT 4
30937: PPUSH
30938: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30942: LD_ADDR_EXP 34
30946: PUSH
30947: LD_EXP 34
30951: PUSH
30952: LD_INT 1
30954: PLUS
30955: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30956: LD_INT 70
30958: PPUSH
30959: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30963: LD_INT 260
30965: PPUSH
30966: LD_INT 235
30968: PPUSH
30969: LD_INT 1
30971: PPUSH
30972: LD_INT 8
30974: NEG
30975: PPUSH
30976: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30980: LD_VAR 0 1
30984: PPUSH
30985: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30989: LD_VAR 0 1
30993: PPUSH
30994: LD_EXP 74
30998: PPUSH
30999: CALL_OW 119
// DialogueOn ;
31003: CALL_OW 6
// case unit of JMM :
31007: LD_VAR 0 1
31011: PUSH
31012: LD_EXP 39
31016: DOUBLE
31017: EQUAL
31018: IFTRUE 31022
31020: GO 31037
31022: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31023: LD_EXP 39
31027: PPUSH
31028: LD_STRING DA1-JMM-1
31030: PPUSH
31031: CALL_OW 91
31035: GO 31479
31037: LD_EXP 40
31041: DOUBLE
31042: EQUAL
31043: IFTRUE 31047
31045: GO 31062
31047: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31048: LD_EXP 40
31052: PPUSH
31053: LD_STRING DA1-Joan-1
31055: PPUSH
31056: CALL_OW 91
31060: GO 31479
31062: LD_EXP 42
31066: DOUBLE
31067: EQUAL
31068: IFTRUE 31072
31070: GO 31087
31072: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31073: LD_EXP 42
31077: PPUSH
31078: LD_STRING DA1-Lisa-1
31080: PPUSH
31081: CALL_OW 91
31085: GO 31479
31087: LD_EXP 43
31091: DOUBLE
31092: EQUAL
31093: IFTRUE 31097
31095: GO 31112
31097: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31098: LD_EXP 43
31102: PPUSH
31103: LD_STRING DA1-Don-1
31105: PPUSH
31106: CALL_OW 91
31110: GO 31479
31112: LD_EXP 50
31116: DOUBLE
31117: EQUAL
31118: IFTRUE 31122
31120: GO 31137
31122: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31123: LD_EXP 50
31127: PPUSH
31128: LD_STRING DA1-Corn-1
31130: PPUSH
31131: CALL_OW 91
31135: GO 31479
31137: LD_EXP 46
31141: DOUBLE
31142: EQUAL
31143: IFTRUE 31147
31145: GO 31162
31147: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31148: LD_EXP 46
31152: PPUSH
31153: LD_STRING DA1-Den-1
31155: PPUSH
31156: CALL_OW 91
31160: GO 31479
31162: LD_EXP 44
31166: DOUBLE
31167: EQUAL
31168: IFTRUE 31172
31170: GO 31187
31172: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31173: LD_EXP 44
31177: PPUSH
31178: LD_STRING DA1-Bobby-1
31180: PPUSH
31181: CALL_OW 91
31185: GO 31479
31187: LD_EXP 48
31191: DOUBLE
31192: EQUAL
31193: IFTRUE 31197
31195: GO 31212
31197: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31198: LD_EXP 48
31202: PPUSH
31203: LD_STRING DA1-Glad-1
31205: PPUSH
31206: CALL_OW 91
31210: GO 31479
31212: LD_EXP 45
31216: DOUBLE
31217: EQUAL
31218: IFTRUE 31222
31220: GO 31237
31222: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31223: LD_EXP 45
31227: PPUSH
31228: LD_STRING DA1-Cyrus-1
31230: PPUSH
31231: CALL_OW 91
31235: GO 31479
31237: LD_EXP 41
31241: DOUBLE
31242: EQUAL
31243: IFTRUE 31247
31245: GO 31262
31247: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31248: LD_EXP 41
31252: PPUSH
31253: LD_STRING DA1-Huck-1
31255: PPUSH
31256: CALL_OW 91
31260: GO 31479
31262: LD_EXP 55
31266: DOUBLE
31267: EQUAL
31268: IFTRUE 31272
31270: GO 31287
31272: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31273: LD_EXP 55
31277: PPUSH
31278: LD_STRING DA1-Huck-1
31280: PPUSH
31281: CALL_OW 91
31285: GO 31479
31287: LD_EXP 47
31291: DOUBLE
31292: EQUAL
31293: IFTRUE 31297
31295: GO 31312
31297: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31298: LD_EXP 47
31302: PPUSH
31303: LD_STRING DA1-Brown-1
31305: PPUSH
31306: CALL_OW 91
31310: GO 31479
31312: LD_EXP 51
31316: DOUBLE
31317: EQUAL
31318: IFTRUE 31322
31320: GO 31337
31322: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31323: LD_EXP 51
31327: PPUSH
31328: LD_STRING DA1-Gary-1
31330: PPUSH
31331: CALL_OW 91
31335: GO 31479
31337: LD_EXP 54
31341: DOUBLE
31342: EQUAL
31343: IFTRUE 31347
31345: GO 31362
31347: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31348: LD_EXP 54
31352: PPUSH
31353: LD_STRING DA1-Con-1
31355: PPUSH
31356: CALL_OW 91
31360: GO 31479
31362: LD_EXP 60
31366: DOUBLE
31367: EQUAL
31368: IFTRUE 31372
31370: GO 31387
31372: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31373: LD_EXP 60
31377: PPUSH
31378: LD_STRING DA1-Kurt-1
31380: PPUSH
31381: CALL_OW 91
31385: GO 31479
31387: LD_EXP 53
31391: DOUBLE
31392: EQUAL
31393: IFTRUE 31397
31395: GO 31412
31397: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31398: LD_EXP 53
31402: PPUSH
31403: LD_STRING DA1-Yam-1
31405: PPUSH
31406: CALL_OW 91
31410: GO 31479
31412: LD_EXP 52
31416: DOUBLE
31417: EQUAL
31418: IFTRUE 31422
31420: GO 31437
31422: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31423: LD_EXP 52
31427: PPUSH
31428: LD_STRING DA1-Frank-1
31430: PPUSH
31431: CALL_OW 91
31435: GO 31479
31437: POP
// begin if GetSex ( unit ) = sex_male then
31438: LD_VAR 0 1
31442: PPUSH
31443: CALL_OW 258
31447: PUSH
31448: LD_INT 1
31450: EQUAL
31451: IFFALSE 31467
// ForceSay ( unit , DA1-Sol1-1 ) else
31453: LD_VAR 0 1
31457: PPUSH
31458: LD_STRING DA1-Sol1-1
31460: PPUSH
31461: CALL_OW 91
31465: GO 31479
// ForceSay ( unit , DA1-FSol1-1 ) ;
31467: LD_VAR 0 1
31471: PPUSH
31472: LD_STRING DA1-FSol1-1
31474: PPUSH
31475: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31479: LD_EXP 74
31483: PPUSH
31484: LD_STRING DA-Roth-1
31486: PPUSH
31487: CALL_OW 88
// if capturedUnit = 1 then
31491: LD_EXP 34
31495: PUSH
31496: LD_INT 1
31498: EQUAL
31499: IFFALSE 31527
// begin Say ( Simms , DA-Sim-1 ) ;
31501: LD_EXP 75
31505: PPUSH
31506: LD_STRING DA-Sim-1
31508: PPUSH
31509: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31513: LD_EXP 74
31517: PPUSH
31518: LD_STRING DA-Roth-2
31520: PPUSH
31521: CALL_OW 88
// end else
31525: GO 31539
// Say ( Simms , DA-Sim-2 ) ;
31527: LD_EXP 75
31531: PPUSH
31532: LD_STRING DA-Sim-2
31534: PPUSH
31535: CALL_OW 88
// case unit of JMM :
31539: LD_VAR 0 1
31543: PUSH
31544: LD_EXP 39
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31555: LD_EXP 39
31559: PPUSH
31560: LD_STRING DA1-JMM-1a
31562: PPUSH
31563: CALL_OW 91
31567: GO 32076
31569: LD_EXP 40
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31580: LD_EXP 40
31584: PPUSH
31585: LD_STRING DA1-Joan-1a
31587: PPUSH
31588: CALL_OW 91
31592: GO 32076
31594: LD_EXP 42
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31605: LD_EXP 42
31609: PPUSH
31610: LD_STRING DA1-Lisa-1a
31612: PPUSH
31613: CALL_OW 91
31617: GO 32076
31619: LD_EXP 43
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31630: LD_EXP 43
31634: PPUSH
31635: LD_STRING DA1-Don-1a
31637: PPUSH
31638: CALL_OW 91
31642: GO 32076
31644: LD_EXP 50
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31655: LD_EXP 50
31659: PPUSH
31660: LD_STRING DA1-Corn-1a
31662: PPUSH
31663: CALL_OW 91
31667: GO 32076
31669: LD_EXP 46
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31680: LD_EXP 46
31684: PPUSH
31685: LD_STRING DA1-Den-1a
31687: PPUSH
31688: CALL_OW 91
31692: GO 32076
31694: LD_EXP 44
31698: DOUBLE
31699: EQUAL
31700: IFTRUE 31704
31702: GO 31719
31704: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31705: LD_EXP 44
31709: PPUSH
31710: LD_STRING DA1-Bobby-1a
31712: PPUSH
31713: CALL_OW 91
31717: GO 32076
31719: LD_EXP 48
31723: DOUBLE
31724: EQUAL
31725: IFTRUE 31729
31727: GO 31744
31729: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31730: LD_EXP 48
31734: PPUSH
31735: LD_STRING DA1-Glad-1a
31737: PPUSH
31738: CALL_OW 91
31742: GO 32076
31744: LD_EXP 45
31748: DOUBLE
31749: EQUAL
31750: IFTRUE 31754
31752: GO 31769
31754: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31755: LD_EXP 45
31759: PPUSH
31760: LD_STRING DA1-Cyrus-1a
31762: PPUSH
31763: CALL_OW 91
31767: GO 32076
31769: LD_EXP 41
31773: DOUBLE
31774: EQUAL
31775: IFTRUE 31779
31777: GO 31794
31779: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31780: LD_EXP 41
31784: PPUSH
31785: LD_STRING DA1-Huck-1a
31787: PPUSH
31788: CALL_OW 91
31792: GO 32076
31794: LD_EXP 55
31798: DOUBLE
31799: EQUAL
31800: IFTRUE 31804
31802: GO 31819
31804: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31805: LD_EXP 55
31809: PPUSH
31810: LD_STRING DA1-Huck-1a
31812: PPUSH
31813: CALL_OW 91
31817: GO 32076
31819: LD_EXP 47
31823: DOUBLE
31824: EQUAL
31825: IFTRUE 31829
31827: GO 31844
31829: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31830: LD_EXP 47
31834: PPUSH
31835: LD_STRING DA1-Brown-1a
31837: PPUSH
31838: CALL_OW 91
31842: GO 32076
31844: LD_EXP 51
31848: DOUBLE
31849: EQUAL
31850: IFTRUE 31854
31852: GO 31869
31854: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31855: LD_EXP 51
31859: PPUSH
31860: LD_STRING DA1-Gary-1a
31862: PPUSH
31863: CALL_OW 91
31867: GO 32076
31869: LD_EXP 54
31873: DOUBLE
31874: EQUAL
31875: IFTRUE 31879
31877: GO 31894
31879: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31880: LD_EXP 54
31884: PPUSH
31885: LD_STRING DA1-Con-1a
31887: PPUSH
31888: CALL_OW 91
31892: GO 32076
31894: LD_EXP 60
31898: DOUBLE
31899: EQUAL
31900: IFTRUE 31904
31902: GO 31919
31904: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31905: LD_EXP 60
31909: PPUSH
31910: LD_STRING DA1-Kurt-1a
31912: PPUSH
31913: CALL_OW 91
31917: GO 32076
31919: LD_EXP 53
31923: DOUBLE
31924: EQUAL
31925: IFTRUE 31929
31927: GO 31944
31929: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31930: LD_EXP 53
31934: PPUSH
31935: LD_STRING DA1-Yam-1a
31937: PPUSH
31938: CALL_OW 91
31942: GO 32076
31944: LD_EXP 52
31948: DOUBLE
31949: EQUAL
31950: IFTRUE 31954
31952: GO 31969
31954: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31955: LD_EXP 52
31959: PPUSH
31960: LD_STRING DA1-Frank-1a
31962: PPUSH
31963: CALL_OW 91
31967: GO 32076
31969: POP
// begin join := rand ( 0 , 1 ) ;
31970: LD_ADDR_VAR 0 3
31974: PUSH
31975: LD_INT 0
31977: PPUSH
31978: LD_INT 1
31980: PPUSH
31981: CALL_OW 12
31985: ST_TO_ADDR
// if join then
31986: LD_VAR 0 3
31990: IFFALSE 32035
// begin if GetSex ( unit ) = sex_male then
31992: LD_VAR 0 1
31996: PPUSH
31997: CALL_OW 258
32001: PUSH
32002: LD_INT 1
32004: EQUAL
32005: IFFALSE 32021
// ForceSay ( unit , DA1-Sol1-1b ) else
32007: LD_VAR 0 1
32011: PPUSH
32012: LD_STRING DA1-Sol1-1b
32014: PPUSH
32015: CALL_OW 91
32019: GO 32033
// ForceSay ( unit , DA1-FSol1-1b ) ;
32021: LD_VAR 0 1
32025: PPUSH
32026: LD_STRING DA1-FSol1-1b
32028: PPUSH
32029: CALL_OW 91
// end else
32033: GO 32076
// begin if GetSex ( unit ) = sex_male then
32035: LD_VAR 0 1
32039: PPUSH
32040: CALL_OW 258
32044: PUSH
32045: LD_INT 1
32047: EQUAL
32048: IFFALSE 32064
// ForceSay ( unit , DA1-Sol1-1a ) else
32050: LD_VAR 0 1
32054: PPUSH
32055: LD_STRING DA1-Sol1-1a
32057: PPUSH
32058: CALL_OW 91
32062: GO 32076
// ForceSay ( unit , DA1-FSol1-1a ) ;
32064: LD_VAR 0 1
32068: PPUSH
32069: LD_STRING DA1-FSol1-1a
32071: PPUSH
32072: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32076: LD_VAR 0 1
32080: PUSH
32081: LD_EXP 39
32085: EQUAL
32086: IFFALSE 32097
// begin YouLost ( JMMCaptured ) ;
32088: LD_STRING JMMCaptured
32090: PPUSH
32091: CALL_OW 104
// exit ;
32095: GO 32395
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32097: LD_VAR 0 1
32101: PUSH
32102: LD_EXP 43
32106: PUSH
32107: LD_EXP 46
32111: PUSH
32112: LD_EXP 44
32116: PUSH
32117: LD_EXP 41
32121: PUSH
32122: LD_EXP 55
32126: PUSH
32127: LD_EXP 47
32131: PUSH
32132: LD_EXP 53
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: LIST
32141: LIST
32142: LIST
32143: LIST
32144: LIST
32145: IN
32146: PUSH
32147: LD_VAR 0 3
32151: OR
32152: IFFALSE 32251
// begin Say ( Roth , DA-Roth-3 ) ;
32154: LD_EXP 74
32158: PPUSH
32159: LD_STRING DA-Roth-3
32161: PPUSH
32162: CALL_OW 88
// SetSide ( unit , 7 ) ;
32166: LD_VAR 0 1
32170: PPUSH
32171: LD_INT 7
32173: PPUSH
32174: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32178: LD_ADDR_EXP 102
32182: PUSH
32183: LD_EXP 102
32187: PPUSH
32188: LD_INT 1
32190: PPUSH
32191: LD_EXP 102
32195: PUSH
32196: LD_INT 1
32198: ARRAY
32199: PUSH
32200: LD_VAR 0 1
32204: ADD
32205: PPUSH
32206: CALL_OW 1
32210: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32211: LD_INT 260
32213: PPUSH
32214: LD_INT 235
32216: PPUSH
32217: LD_INT 1
32219: PPUSH
32220: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32224: LD_VAR 0 1
32228: PPUSH
32229: LD_INT 1000
32231: PPUSH
32232: CALL_OW 234
// DialogueOff ;
32236: CALL_OW 7
// ComFree ( unit ) ;
32240: LD_VAR 0 1
32244: PPUSH
32245: CALL_OW 139
// end else
32249: GO 32332
// begin Say ( Roth , DA-Roth-3a ) ;
32251: LD_EXP 74
32255: PPUSH
32256: LD_STRING DA-Roth-3a
32258: PPUSH
32259: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32263: LD_ADDR_EXP 35
32267: PUSH
32268: LD_EXP 35
32272: PUSH
32273: LD_VAR 0 1
32277: ADD
32278: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32279: LD_INT 260
32281: PPUSH
32282: LD_INT 235
32284: PPUSH
32285: LD_INT 1
32287: PPUSH
32288: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32292: LD_VAR 0 1
32296: PPUSH
32297: LD_INT 1000
32299: PPUSH
32300: CALL_OW 234
// DialogueOff ;
32304: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32308: LD_VAR 0 1
32312: PPUSH
32313: LD_INT 272
32315: PPUSH
32316: LD_INT 254
32318: PPUSH
32319: CALL_OW 111
// AddComHold ( unit ) ;
32323: LD_VAR 0 1
32327: PPUSH
32328: CALL_OW 200
// end ; if capturedUnit = 1 then
32332: LD_EXP 34
32336: PUSH
32337: LD_INT 1
32339: EQUAL
32340: IFFALSE 32395
// begin DialogueOn ;
32342: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32346: LD_EXP 39
32350: PPUSH
32351: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32355: LD_EXP 39
32359: PPUSH
32360: LD_STRING DAa-JMM-1
32362: PPUSH
32363: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32367: LD_EXP 39
32371: PPUSH
32372: LD_STRING DAa-JMM-1a
32374: PPUSH
32375: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32379: LD_EXP 39
32383: PPUSH
32384: LD_STRING DAa-JMM-1b
32386: PPUSH
32387: CALL_OW 88
// DialogueOff ;
32391: CALL_OW 7
// end ; end ;
32395: LD_VAR 0 2
32399: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32400: LD_EXP 15
32404: PUSH
32405: LD_INT 13
32407: GREATEREQUAL
32408: PUSH
32409: LD_INT 22
32411: PUSH
32412: LD_INT 2
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 21
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PPUSH
32433: CALL_OW 69
32437: PUSH
32438: LD_INT 0
32440: EQUAL
32441: AND
32442: PUSH
32443: LD_INT 22
32445: PUSH
32446: LD_INT 2
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 21
32455: PUSH
32456: LD_INT 2
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 50
32465: PUSH
32466: EMPTY
32467: LIST
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: LIST
32473: PPUSH
32474: CALL_OW 69
32478: PUSH
32479: LD_INT 0
32481: EQUAL
32482: AND
32483: PUSH
32484: LD_EXP 21
32488: AND
32489: PUSH
32490: LD_EXP 22
32494: AND
32495: PUSH
32496: LD_EXP 23
32500: AND
32501: IFFALSE 33143
32503: GO 32505
32505: DISABLE
32506: LD_INT 0
32508: PPUSH
32509: PPUSH
32510: PPUSH
// begin m1 := false ;
32511: LD_ADDR_VAR 0 1
32515: PUSH
32516: LD_INT 0
32518: ST_TO_ADDR
// m2 := false ;
32519: LD_ADDR_VAR 0 2
32523: PUSH
32524: LD_INT 0
32526: ST_TO_ADDR
// m3 := false ;
32527: LD_ADDR_VAR 0 3
32531: PUSH
32532: LD_INT 0
32534: ST_TO_ADDR
// if not bombExploded then
32535: LD_EXP 37
32539: NOT
32540: IFFALSE 32549
// SetAchievement ( ACH_SIBROCKET ) ;
32542: LD_STRING ACH_SIBROCKET
32544: PPUSH
32545: CALL_OW 543
// if tick <= 120 120$00 then
32549: LD_OWVAR 1
32553: PUSH
32554: LD_INT 252000
32556: LESSEQUAL
32557: IFFALSE 32573
// begin wait ( 3 ) ;
32559: LD_INT 3
32561: PPUSH
32562: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32566: LD_STRING ACH_ASPEED_15
32568: PPUSH
32569: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32573: LD_EXP 39
32577: PPUSH
32578: CALL_OW 87
// music_class := 5 ;
32582: LD_ADDR_OWVAR 72
32586: PUSH
32587: LD_INT 5
32589: ST_TO_ADDR
// music_nat := 5 ;
32590: LD_ADDR_OWVAR 71
32594: PUSH
32595: LD_INT 5
32597: ST_TO_ADDR
// DialogueOn ;
32598: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32602: LD_EXP 39
32606: PPUSH
32607: LD_STRING D20-JMM-1
32609: PPUSH
32610: CALL_OW 88
// if IsOK ( Joan ) then
32614: LD_EXP 40
32618: PPUSH
32619: CALL_OW 302
32623: IFFALSE 32637
// Say ( Joan , D20-Joan-1 ) ;
32625: LD_EXP 40
32629: PPUSH
32630: LD_STRING D20-Joan-1
32632: PPUSH
32633: CALL_OW 88
// if IsOk ( Lisa ) then
32637: LD_EXP 42
32641: PPUSH
32642: CALL_OW 302
32646: IFFALSE 32660
// Say ( Lisa , D20-Lisa-1 ) ;
32648: LD_EXP 42
32652: PPUSH
32653: LD_STRING D20-Lisa-1
32655: PPUSH
32656: CALL_OW 88
// if IsOk ( Donaldson ) then
32660: LD_EXP 43
32664: PPUSH
32665: CALL_OW 302
32669: IFFALSE 32683
// Say ( Donaldson , D20-Don-1 ) ;
32671: LD_EXP 43
32675: PPUSH
32676: LD_STRING D20-Don-1
32678: PPUSH
32679: CALL_OW 88
// if IsOK ( Cornel ) then
32683: LD_EXP 50
32687: PPUSH
32688: CALL_OW 302
32692: IFFALSE 32706
// Say ( Cornel , D20-Corn-1 ) ;
32694: LD_EXP 50
32698: PPUSH
32699: LD_STRING D20-Corn-1
32701: PPUSH
32702: CALL_OW 88
// if IsOk ( Denis ) then
32706: LD_EXP 46
32710: PPUSH
32711: CALL_OW 302
32715: IFFALSE 32729
// Say ( Denis , D20-Den-1 ) ;
32717: LD_EXP 46
32721: PPUSH
32722: LD_STRING D20-Den-1
32724: PPUSH
32725: CALL_OW 88
// if IsOk ( Bobby ) then
32729: LD_EXP 44
32733: PPUSH
32734: CALL_OW 302
32738: IFFALSE 32752
// Say ( Bobby , D20-Bobby-1 ) ;
32740: LD_EXP 44
32744: PPUSH
32745: LD_STRING D20-Bobby-1
32747: PPUSH
32748: CALL_OW 88
// if IsOk ( Gladstone ) then
32752: LD_EXP 48
32756: PPUSH
32757: CALL_OW 302
32761: IFFALSE 32775
// Say ( Gladstone , D20-Glad-1 ) ;
32763: LD_EXP 48
32767: PPUSH
32768: LD_STRING D20-Glad-1
32770: PPUSH
32771: CALL_OW 88
// if IsOk ( Cyrus ) then
32775: LD_EXP 45
32779: PPUSH
32780: CALL_OW 302
32784: IFFALSE 32798
// Say ( Cyrus , D20-Cyrus-1 ) ;
32786: LD_EXP 45
32790: PPUSH
32791: LD_STRING D20-Cyrus-1
32793: PPUSH
32794: CALL_OW 88
// if IsOk ( Stevens ) then
32798: LD_EXP 41
32802: PPUSH
32803: CALL_OW 302
32807: IFFALSE 32821
// Say ( Stevens , D20-Huck-1 ) ;
32809: LD_EXP 41
32813: PPUSH
32814: LD_STRING D20-Huck-1
32816: PPUSH
32817: CALL_OW 88
// if IsOk ( Brown ) then
32821: LD_EXP 47
32825: PPUSH
32826: CALL_OW 302
32830: IFFALSE 32844
// Say ( Brown , D20-Brown-1 ) ;
32832: LD_EXP 47
32836: PPUSH
32837: LD_STRING D20-Brown-1
32839: PPUSH
32840: CALL_OW 88
// if IsOk ( Gary ) then
32844: LD_EXP 51
32848: PPUSH
32849: CALL_OW 302
32853: IFFALSE 32867
// Say ( Gary , D20-Gary-1 ) ;
32855: LD_EXP 51
32859: PPUSH
32860: LD_STRING D20-Gary-1
32862: PPUSH
32863: CALL_OW 88
// if IsOk ( Connie ) then
32867: LD_EXP 54
32871: PPUSH
32872: CALL_OW 302
32876: IFFALSE 32890
// Say ( Connie , D20-Con-1 ) ;
32878: LD_EXP 54
32882: PPUSH
32883: LD_STRING D20-Con-1
32885: PPUSH
32886: CALL_OW 88
// if IsOk ( Kurt ) then
32890: LD_EXP 60
32894: PPUSH
32895: CALL_OW 302
32899: IFFALSE 32913
// Say ( Kurt , D20-Kurt-1 ) ;
32901: LD_EXP 60
32905: PPUSH
32906: LD_STRING D20-Kurt-1
32908: PPUSH
32909: CALL_OW 88
// if IsOk ( Kikuchi ) then
32913: LD_EXP 53
32917: PPUSH
32918: CALL_OW 302
32922: IFFALSE 32936
// Say ( Kikuchi , D20-Yam-1 ) ;
32924: LD_EXP 53
32928: PPUSH
32929: LD_STRING D20-Yam-1
32931: PPUSH
32932: CALL_OW 88
// if IsOk ( Frank ) then
32936: LD_EXP 52
32940: PPUSH
32941: CALL_OW 302
32945: IFFALSE 32959
// Say ( Frank , D20-Frank-1 ) ;
32947: LD_EXP 52
32951: PPUSH
32952: LD_STRING D20-Frank-1
32954: PPUSH
32955: CALL_OW 88
// DialogueOff ;
32959: CALL_OW 7
// if RothCaptured then
32963: LD_EXP 33
32967: IFFALSE 32989
// begin m1 := true ;
32969: LD_ADDR_VAR 0 1
32973: PUSH
32974: LD_INT 1
32976: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32977: LD_STRING Roth
32979: PPUSH
32980: LD_INT 1
32982: PPUSH
32983: CALL_OW 101
// end else
32987: GO 33000
// AddMedal ( Roth , - 1 ) ;
32989: LD_STRING Roth
32991: PPUSH
32992: LD_INT 1
32994: NEG
32995: PPUSH
32996: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33000: LD_EXP 27
33004: IFFALSE 33026
// begin m2 := true ;
33006: LD_ADDR_VAR 0 2
33010: PUSH
33011: LD_INT 1
33013: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33014: LD_STRING Project
33016: PPUSH
33017: LD_INT 1
33019: PPUSH
33020: CALL_OW 101
// end else
33024: GO 33037
// AddMedal ( Project , - 1 ) ;
33026: LD_STRING Project
33028: PPUSH
33029: LD_INT 1
33031: NEG
33032: PPUSH
33033: CALL_OW 101
// if lostCounter = 0 then
33037: LD_EXP 32
33041: PUSH
33042: LD_INT 0
33044: EQUAL
33045: IFFALSE 33067
// begin m3 := true ;
33047: LD_ADDR_VAR 0 3
33051: PUSH
33052: LD_INT 1
33054: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33055: LD_STRING NoLosses
33057: PPUSH
33058: LD_INT 1
33060: PPUSH
33061: CALL_OW 101
// end else
33065: GO 33078
// AddMedal ( NoLosses , - 1 ) ;
33067: LD_STRING NoLosses
33069: PPUSH
33070: LD_INT 1
33072: NEG
33073: PPUSH
33074: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33078: LD_VAR 0 1
33082: PUSH
33083: LD_VAR 0 2
33087: AND
33088: PUSH
33089: LD_VAR 0 3
33093: AND
33094: PUSH
33095: LD_OWVAR 67
33099: PUSH
33100: LD_INT 3
33102: EQUAL
33103: AND
33104: IFFALSE 33116
// SetAchievementEX ( ACH_AMER , 15 ) ;
33106: LD_STRING ACH_AMER
33108: PPUSH
33109: LD_INT 15
33111: PPUSH
33112: CALL_OW 564
// GiveMedals ( MAIN ) ;
33116: LD_STRING MAIN
33118: PPUSH
33119: CALL_OW 102
// music_class := 4 ;
33123: LD_ADDR_OWVAR 72
33127: PUSH
33128: LD_INT 4
33130: ST_TO_ADDR
// music_nat := 1 ;
33131: LD_ADDR_OWVAR 71
33135: PUSH
33136: LD_INT 1
33138: ST_TO_ADDR
// YouWin ;
33139: CALL_OW 103
// end ; end_of_file
33143: PPOPN 3
33145: END
// export function CustomEvent ( event ) ; begin
33146: LD_INT 0
33148: PPUSH
// end ;
33149: LD_VAR 0 2
33153: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33154: LD_VAR 0 1
33158: PUSH
33159: LD_INT 1
33161: EQUAL
33162: PUSH
33163: LD_VAR 0 2
33167: PUSH
33168: LD_INT 4
33170: EQUAL
33171: AND
33172: PUSH
33173: LD_EXP 58
33177: PPUSH
33178: CALL_OW 300
33182: AND
33183: IFFALSE 33199
// begin wait ( 0 0$2 ) ;
33185: LD_INT 70
33187: PPUSH
33188: CALL_OW 67
// YouLost ( Dismissed ) ;
33192: LD_STRING Dismissed
33194: PPUSH
33195: CALL_OW 104
// end ; end ;
33199: PPOPN 2
33201: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33202: LD_VAR 0 2
33206: PPUSH
33207: LD_VAR 0 3
33211: PPUSH
33212: LD_INT 18
33214: PPUSH
33215: CALL_OW 309
33219: IFFALSE 33228
// YouLost ( Motherlode3 ) ;
33221: LD_STRING Motherlode3
33223: PPUSH
33224: CALL_OW 104
// end ;
33228: PPOPN 3
33230: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33231: LD_EXP 27
33235: NOT
33236: IFFALSE 33246
// behemothDone := true ;
33238: LD_ADDR_EXP 28
33242: PUSH
33243: LD_INT 1
33245: ST_TO_ADDR
// end ;
33246: PPOPN 1
33248: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33249: LD_VAR 0 1
33253: PPUSH
33254: CALL_OW 255
33258: PUSH
33259: LD_INT 1
33261: EQUAL
33262: IFFALSE 33272
// bombExploded := true ;
33264: LD_ADDR_EXP 37
33268: PUSH
33269: LD_INT 1
33271: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33272: LD_VAR 0 1
33276: PPUSH
33277: CALL_OW 255
33281: PUSH
33282: LD_INT 1
33284: EQUAL
33285: PUSH
33286: LD_EXP 30
33290: AND
33291: PUSH
33292: LD_INT 22
33294: PUSH
33295: LD_INT 3
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 34
33304: PUSH
33305: LD_INT 48
33307: PUSH
33308: EMPTY
33309: LIST
33310: LIST
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PPUSH
33316: CALL_OW 69
33320: AND
33321: PUSH
33322: LD_INT 22
33324: PUSH
33325: LD_INT 1
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 34
33334: PUSH
33335: LD_INT 8
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: EMPTY
33343: LIST
33344: LIST
33345: PPUSH
33346: CALL_OW 69
33350: NOT
33351: AND
33352: IFFALSE 33404
// begin wait ( 0 0$5 ) ;
33354: LD_INT 175
33356: PPUSH
33357: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33361: LD_INT 22
33363: PUSH
33364: LD_INT 3
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 34
33373: PUSH
33374: LD_INT 48
33376: PUSH
33377: EMPTY
33378: LIST
33379: LIST
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PPUSH
33385: CALL_OW 69
33389: PUSH
33390: LD_INT 1
33392: ARRAY
33393: PPUSH
33394: LD_INT 60
33396: PPUSH
33397: LD_INT 95
33399: PPUSH
33400: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33404: LD_VAR 0 2
33408: PPUSH
33409: LD_VAR 0 3
33413: PPUSH
33414: LD_INT 18
33416: PPUSH
33417: CALL_OW 309
33421: IFFALSE 33481
// begin if GetSide ( unit ) = 1 then
33423: LD_VAR 0 1
33427: PPUSH
33428: CALL_OW 255
33432: PUSH
33433: LD_INT 1
33435: EQUAL
33436: IFFALSE 33452
// begin wait ( 0 0$6 ) ;
33438: LD_INT 210
33440: PPUSH
33441: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33445: LD_STRING Motherlode2
33447: PPUSH
33448: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33452: LD_VAR 0 1
33456: PPUSH
33457: CALL_OW 255
33461: PUSH
33462: LD_INT 8
33464: EQUAL
33465: IFFALSE 33481
// begin wait ( 0 0$6 ) ;
33467: LD_INT 210
33469: PPUSH
33470: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33474: LD_STRING Motherlode1
33476: PPUSH
33477: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33481: LD_VAR 0 1
33485: PPUSH
33486: CALL_OW 255
33490: PUSH
33491: LD_INT 3
33493: EQUAL
33494: IFFALSE 33515
// begin wait ( 0 0$5 ) ;
33496: LD_INT 175
33498: PPUSH
33499: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33503: LD_EXP 64
33507: PPUSH
33508: LD_STRING D18-Pla-1
33510: PPUSH
33511: CALL_OW 94
// end ; end ;
33515: PPOPN 3
33517: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33518: LD_VAR 0 1
33522: PUSH
33523: LD_EXP 73
33527: IN
33528: IFFALSE 33548
// begin behemothBuilders := behemothBuilders diff un ;
33530: LD_ADDR_EXP 73
33534: PUSH
33535: LD_EXP 73
33539: PUSH
33540: LD_VAR 0 1
33544: DIFF
33545: ST_TO_ADDR
// exit ;
33546: GO 33646
// end ; if un = JMM then
33548: LD_VAR 0 1
33552: PUSH
33553: LD_EXP 39
33557: EQUAL
33558: IFFALSE 33569
// begin YouLost ( JMM ) ;
33560: LD_STRING JMM
33562: PPUSH
33563: CALL_OW 104
// exit ;
33567: GO 33646
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33569: LD_VAR 0 1
33573: PUSH
33574: LD_INT 22
33576: PUSH
33577: LD_INT 1
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: LD_INT 3
33586: PUSH
33587: LD_INT 25
33589: PUSH
33590: LD_INT 16
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 25
33599: PUSH
33600: LD_INT 12
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: LIST
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PPUSH
33616: CALL_OW 69
33620: IN
33621: IFFALSE 33637
// lostCounter := lostCounter + 1 ;
33623: LD_ADDR_EXP 32
33627: PUSH
33628: LD_EXP 32
33632: PUSH
33633: LD_INT 1
33635: PLUS
33636: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33637: LD_VAR 0 1
33641: PPUSH
33642: CALL 61826 0 1
// end ;
33646: PPOPN 1
33648: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33649: LD_VAR 0 1
33653: PPUSH
33654: LD_VAR 0 2
33658: PPUSH
33659: CALL 64160 0 2
// end ;
33663: PPOPN 2
33665: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33666: LD_VAR 0 1
33670: PPUSH
33671: CALL 63228 0 1
// end ;
33675: PPOPN 1
33677: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33678: LD_VAR 0 1
33682: PUSH
33683: LD_INT 22
33685: PUSH
33686: LD_INT 8
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 30
33695: PUSH
33696: LD_INT 2
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 23
33705: PUSH
33706: LD_INT 3
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: LIST
33717: PPUSH
33718: CALL_OW 69
33722: IN
33723: IFFALSE 33750
// begin ComUpgrade ( building ) ;
33725: LD_VAR 0 1
33729: PPUSH
33730: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33734: LD_EXP 61
33738: PPUSH
33739: LD_VAR 0 1
33743: PPUSH
33744: CALL 74866 0 2
// exit ;
33748: GO 33759
// end ; MCE_BuildingComplete ( building ) ;
33750: LD_VAR 0 1
33754: PPUSH
33755: CALL 63469 0 1
// end ;
33759: PPOPN 1
33761: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33762: LD_VAR 0 1
33766: PPUSH
33767: LD_VAR 0 2
33771: PPUSH
33772: CALL 61522 0 2
// end ;
33776: PPOPN 2
33778: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33779: LD_VAR 0 1
33783: PPUSH
33784: LD_VAR 0 2
33788: PPUSH
33789: LD_VAR 0 3
33793: PPUSH
33794: LD_VAR 0 4
33798: PPUSH
33799: LD_VAR 0 5
33803: PPUSH
33804: CALL 61142 0 5
// end ;
33808: PPOPN 5
33810: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33811: LD_VAR 0 1
33815: PPUSH
33816: LD_VAR 0 2
33820: PPUSH
33821: CALL 60738 0 2
// end ;
33825: PPOPN 2
33827: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33828: LD_VAR 0 1
33832: PPUSH
33833: LD_VAR 0 2
33837: PPUSH
33838: LD_VAR 0 3
33842: PPUSH
33843: LD_VAR 0 4
33847: PPUSH
33848: CALL 60576 0 4
// end ;
33852: PPOPN 4
33854: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33855: LD_VAR 0 1
33859: PPUSH
33860: LD_VAR 0 2
33864: PPUSH
33865: LD_VAR 0 3
33869: PPUSH
33870: CALL 60351 0 3
// end ;
33874: PPOPN 3
33876: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33877: LD_VAR 0 1
33881: PPUSH
33882: LD_VAR 0 2
33886: PPUSH
33887: CALL 60236 0 2
// end ;
33891: PPOPN 2
33893: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33894: LD_VAR 0 1
33898: PPUSH
33899: LD_VAR 0 2
33903: PPUSH
33904: CALL 64421 0 2
// end ;
33908: PPOPN 2
33910: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33911: LD_VAR 0 1
33915: PPUSH
33916: CALL_OW 255
33920: PUSH
33921: LD_INT 4
33923: EQUAL
33924: PUSH
33925: LD_VAR 0 1
33929: PUSH
33930: LD_EXP 18
33934: PUSH
33935: LD_INT 1
33937: ARRAY
33938: IN
33939: AND
33940: PUSH
33941: LD_EXP 19
33945: AND
33946: IFFALSE 33965
// begin ComMoveXY ( driver , 61 , 93 ) ;
33948: LD_VAR 0 1
33952: PPUSH
33953: LD_INT 61
33955: PPUSH
33956: LD_INT 93
33958: PPUSH
33959: CALL_OW 111
// exit ;
33963: GO 33989
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33965: LD_VAR 0 1
33969: PPUSH
33970: LD_VAR 0 2
33974: PPUSH
33975: LD_VAR 0 3
33979: PPUSH
33980: LD_VAR 0 4
33984: PPUSH
33985: CALL 64637 0 4
// end ;
33989: PPOPN 4
33991: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33992: LD_VAR 0 1
33996: PPUSH
33997: LD_VAR 0 2
34001: PPUSH
34002: CALL 60045 0 2
// end ;
34006: PPOPN 2
34008: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34009: LD_VAR 0 1
34013: PPUSH
34014: CALL 108048 0 1
// end ; end_of_file
34018: PPOPN 1
34020: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34021: LD_EXP 15
34025: PUSH
34026: LD_INT 2
34028: EQUAL
34029: IFFALSE 34508
34031: GO 34033
34033: DISABLE
34034: LD_INT 0
34036: PPUSH
// begin time := 0 0$40 ;
34037: LD_ADDR_VAR 0 1
34041: PUSH
34042: LD_INT 1400
34044: ST_TO_ADDR
// repeat wait ( time ) ;
34045: LD_VAR 0 1
34049: PPUSH
34050: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34054: LD_INT 1
34056: PPUSH
34057: LD_INT 5
34059: PPUSH
34060: CALL_OW 12
34064: PPUSH
34065: LD_INT 106
34067: PPUSH
34068: LD_INT 150
34070: PPUSH
34071: LD_INT 19
34073: PPUSH
34074: LD_INT 1
34076: PPUSH
34077: CALL_OW 56
// time := time + 0 0$9 ;
34081: LD_ADDR_VAR 0 1
34085: PUSH
34086: LD_VAR 0 1
34090: PUSH
34091: LD_INT 315
34093: PLUS
34094: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34095: LD_INT 455
34097: PPUSH
34098: LD_INT 840
34100: PPUSH
34101: CALL_OW 12
34105: PPUSH
34106: CALL_OW 67
// if Prob ( 50 ) then
34110: LD_INT 50
34112: PPUSH
34113: CALL_OW 13
34117: IFFALSE 34146
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34119: LD_INT 1
34121: PPUSH
34122: LD_INT 5
34124: PPUSH
34125: CALL_OW 12
34129: PPUSH
34130: LD_INT 62
34132: PPUSH
34133: LD_INT 108
34135: PPUSH
34136: LD_INT 10
34138: PPUSH
34139: LD_INT 1
34141: PPUSH
34142: CALL_OW 56
// until missionStage > 4 ;
34146: LD_EXP 15
34150: PUSH
34151: LD_INT 4
34153: GREATER
34154: IFFALSE 34045
// repeat wait ( 0 0$1 ) ;
34156: LD_INT 35
34158: PPUSH
34159: CALL_OW 67
// until missionStage = 6 ;
34163: LD_EXP 15
34167: PUSH
34168: LD_INT 6
34170: EQUAL
34171: IFFALSE 34156
// time := 0 0$50 ;
34173: LD_ADDR_VAR 0 1
34177: PUSH
34178: LD_INT 1750
34180: ST_TO_ADDR
// repeat wait ( time ) ;
34181: LD_VAR 0 1
34185: PPUSH
34186: CALL_OW 67
// if Prob ( 50 ) then
34190: LD_INT 50
34192: PPUSH
34193: CALL_OW 13
34197: IFFALSE 34226
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34199: LD_INT 1
34201: PPUSH
34202: LD_INT 5
34204: PPUSH
34205: CALL_OW 12
34209: PPUSH
34210: LD_INT 106
34212: PPUSH
34213: LD_INT 89
34215: PPUSH
34216: LD_INT 45
34218: PPUSH
34219: LD_INT 1
34221: PPUSH
34222: CALL_OW 56
// time := time + 0 0$3 ;
34226: LD_ADDR_VAR 0 1
34230: PUSH
34231: LD_VAR 0 1
34235: PUSH
34236: LD_INT 105
34238: PLUS
34239: ST_TO_ADDR
// if Prob ( 30 ) then
34240: LD_INT 30
34242: PPUSH
34243: CALL_OW 13
34247: IFFALSE 34293
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
34249: LD_INT 525
34251: PPUSH
34252: LD_INT 735
34254: PPUSH
34255: CALL_OW 12
34259: PPUSH
34260: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34264: LD_INT 1
34266: PPUSH
34267: LD_INT 5
34269: PPUSH
34270: CALL_OW 12
34274: PPUSH
34275: LD_INT 21
34277: PPUSH
34278: LD_INT 26
34280: PPUSH
34281: LD_INT 12
34283: PPUSH
34284: LD_INT 1
34286: PPUSH
34287: CALL_OW 56
// end else
34291: GO 34329
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34293: LD_INT 700
34295: PPUSH
34296: LD_INT 1225
34298: PPUSH
34299: CALL_OW 12
34303: PPUSH
34304: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34308: LD_INT 1
34310: PPUSH
34311: LD_INT 5
34313: PPUSH
34314: CALL_OW 12
34318: PPUSH
34319: LD_INT 16
34321: PPUSH
34322: LD_INT 1
34324: PPUSH
34325: CALL_OW 55
// end ; if Prob ( 50 ) then
34329: LD_INT 50
34331: PPUSH
34332: CALL_OW 13
34336: IFFALSE 34382
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34338: LD_INT 700
34340: PPUSH
34341: LD_INT 1050
34343: PPUSH
34344: CALL_OW 12
34348: PPUSH
34349: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34353: LD_INT 1
34355: PPUSH
34356: LD_INT 5
34358: PPUSH
34359: CALL_OW 12
34363: PPUSH
34364: LD_INT 181
34366: PPUSH
34367: LD_INT 218
34369: PPUSH
34370: LD_INT 16
34372: PPUSH
34373: LD_INT 1
34375: PPUSH
34376: CALL_OW 56
// end else
34380: GO 34418
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34382: LD_INT 350
34384: PPUSH
34385: LD_INT 525
34387: PPUSH
34388: CALL_OW 12
34392: PPUSH
34393: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34397: LD_INT 1
34399: PPUSH
34400: LD_INT 5
34402: PPUSH
34403: CALL_OW 12
34407: PPUSH
34408: LD_INT 15
34410: PPUSH
34411: LD_INT 1
34413: PPUSH
34414: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34418: LD_INT 45
34420: PUSH
34421: LD_INT 32
34423: PUSH
34424: LD_INT 25
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: LIST
34431: PUSH
34432: LD_OWVAR 67
34436: ARRAY
34437: PPUSH
34438: CALL_OW 13
34442: IFFALSE 34486
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
34444: LD_INT 525
34446: PPUSH
34447: LD_INT 875
34449: PPUSH
34450: CALL_OW 12
34454: PPUSH
34455: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34459: LD_INT 1
34461: PPUSH
34462: LD_INT 5
34464: PPUSH
34465: CALL_OW 12
34469: PPUSH
34470: LD_INT 103
34472: PPUSH
34473: LD_INT 140
34475: PPUSH
34476: LD_INT 20
34478: PPUSH
34479: LD_INT 1
34481: PPUSH
34482: CALL_OW 56
// end ; if time > 1 1$40 then
34486: LD_VAR 0 1
34490: PUSH
34491: LD_INT 3500
34493: GREATER
34494: IFFALSE 34504
// time := 0 0$50 ;
34496: LD_ADDR_VAR 0 1
34500: PUSH
34501: LD_INT 1750
34503: ST_TO_ADDR
// until false ;
34504: LD_INT 0
34506: IFFALSE 34181
// end ; end_of_file
34508: PPOPN 1
34510: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34511: LD_EXP 13
34515: PUSH
34516: LD_EXP 15
34520: PUSH
34521: LD_INT 6
34523: GREATEREQUAL
34524: AND
34525: IFFALSE 34562
34527: GO 34529
34529: DISABLE
// begin enable ;
34530: ENABLE
// missionTime := missionTime + 0 0$1 ;
34531: LD_ADDR_EXP 14
34535: PUSH
34536: LD_EXP 14
34540: PUSH
34541: LD_INT 35
34543: PLUS
34544: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34545: LD_ADDR_OWVAR 47
34549: PUSH
34550: LD_STRING #Am15-1
34552: PUSH
34553: LD_EXP 14
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: ST_TO_ADDR
// end ; end_of_file
34562: END
// export function InitNature ; begin
34563: LD_INT 0
34565: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34566: LD_INT 3
34568: PPUSH
34569: LD_INT 3
34571: PPUSH
34572: LD_INT 2
34574: PPUSH
34575: LD_INT 1
34577: PPUSH
34578: LD_INT 1
34580: PPUSH
34581: LD_INT 0
34583: PPUSH
34584: LD_INT 0
34586: PPUSH
34587: LD_INT 20
34589: PPUSH
34590: LD_INT 0
34592: PPUSH
34593: CALL 99684 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34597: LD_INT 2
34599: PPUSH
34600: LD_INT 1
34602: PPUSH
34603: LD_INT 1
34605: PPUSH
34606: LD_INT 1
34608: PPUSH
34609: LD_INT 1
34611: PPUSH
34612: LD_INT 0
34614: PPUSH
34615: LD_INT 0
34617: PPUSH
34618: LD_INT 21
34620: PPUSH
34621: LD_INT 0
34623: PPUSH
34624: CALL 99684 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34628: LD_INT 4
34630: PPUSH
34631: LD_INT 1
34633: PPUSH
34634: LD_INT 2
34636: PPUSH
34637: LD_INT 4
34639: PPUSH
34640: LD_INT 2
34642: PPUSH
34643: LD_INT 1
34645: PPUSH
34646: LD_INT 0
34648: PPUSH
34649: LD_INT 22
34651: PPUSH
34652: LD_INT 0
34654: PPUSH
34655: CALL 99684 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34659: LD_INT 0
34661: PPUSH
34662: LD_INT 0
34664: PPUSH
34665: LD_INT 0
34667: PPUSH
34668: LD_INT 0
34670: PPUSH
34671: LD_INT 0
34673: PPUSH
34674: LD_INT 0
34676: PPUSH
34677: LD_INT 9
34679: PPUSH
34680: LD_INT 0
34682: PPUSH
34683: LD_INT 23
34685: PPUSH
34686: CALL 99684 0 9
// end ; end_of_file
34690: LD_VAR 0 1
34694: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34695: GO 34697
34697: DISABLE
// begin ru_radar := 98 ;
34698: LD_ADDR_EXP 95
34702: PUSH
34703: LD_INT 98
34705: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34706: LD_ADDR_EXP 96
34710: PUSH
34711: LD_INT 89
34713: ST_TO_ADDR
// us_hack := 99 ;
34714: LD_ADDR_EXP 97
34718: PUSH
34719: LD_INT 99
34721: ST_TO_ADDR
// us_artillery := 97 ;
34722: LD_ADDR_EXP 98
34726: PUSH
34727: LD_INT 97
34729: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34730: LD_ADDR_EXP 99
34734: PUSH
34735: LD_INT 91
34737: ST_TO_ADDR
// end ; end_of_file
34738: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34739: LD_INT 0
34741: PPUSH
34742: PPUSH
// skirmish := false ;
34743: LD_ADDR_EXP 100
34747: PUSH
34748: LD_INT 0
34750: ST_TO_ADDR
// debug_mc := false ;
34751: LD_ADDR_EXP 101
34755: PUSH
34756: LD_INT 0
34758: ST_TO_ADDR
// mc_bases := [ ] ;
34759: LD_ADDR_EXP 102
34763: PUSH
34764: EMPTY
34765: ST_TO_ADDR
// mc_sides := [ ] ;
34766: LD_ADDR_EXP 128
34770: PUSH
34771: EMPTY
34772: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34773: LD_ADDR_EXP 103
34777: PUSH
34778: EMPTY
34779: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34780: LD_ADDR_EXP 104
34784: PUSH
34785: EMPTY
34786: ST_TO_ADDR
// mc_need_heal := [ ] ;
34787: LD_ADDR_EXP 105
34791: PUSH
34792: EMPTY
34793: ST_TO_ADDR
// mc_healers := [ ] ;
34794: LD_ADDR_EXP 106
34798: PUSH
34799: EMPTY
34800: ST_TO_ADDR
// mc_build_list := [ ] ;
34801: LD_ADDR_EXP 107
34805: PUSH
34806: EMPTY
34807: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34808: LD_ADDR_EXP 134
34812: PUSH
34813: EMPTY
34814: ST_TO_ADDR
// mc_builders := [ ] ;
34815: LD_ADDR_EXP 108
34819: PUSH
34820: EMPTY
34821: ST_TO_ADDR
// mc_construct_list := [ ] ;
34822: LD_ADDR_EXP 109
34826: PUSH
34827: EMPTY
34828: ST_TO_ADDR
// mc_turret_list := [ ] ;
34829: LD_ADDR_EXP 110
34833: PUSH
34834: EMPTY
34835: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34836: LD_ADDR_EXP 111
34840: PUSH
34841: EMPTY
34842: ST_TO_ADDR
// mc_miners := [ ] ;
34843: LD_ADDR_EXP 116
34847: PUSH
34848: EMPTY
34849: ST_TO_ADDR
// mc_mines := [ ] ;
34850: LD_ADDR_EXP 115
34854: PUSH
34855: EMPTY
34856: ST_TO_ADDR
// mc_minefields := [ ] ;
34857: LD_ADDR_EXP 117
34861: PUSH
34862: EMPTY
34863: ST_TO_ADDR
// mc_crates := [ ] ;
34864: LD_ADDR_EXP 118
34868: PUSH
34869: EMPTY
34870: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34871: LD_ADDR_EXP 119
34875: PUSH
34876: EMPTY
34877: ST_TO_ADDR
// mc_crates_area := [ ] ;
34878: LD_ADDR_EXP 120
34882: PUSH
34883: EMPTY
34884: ST_TO_ADDR
// mc_vehicles := [ ] ;
34885: LD_ADDR_EXP 121
34889: PUSH
34890: EMPTY
34891: ST_TO_ADDR
// mc_attack := [ ] ;
34892: LD_ADDR_EXP 122
34896: PUSH
34897: EMPTY
34898: ST_TO_ADDR
// mc_produce := [ ] ;
34899: LD_ADDR_EXP 123
34903: PUSH
34904: EMPTY
34905: ST_TO_ADDR
// mc_defender := [ ] ;
34906: LD_ADDR_EXP 124
34910: PUSH
34911: EMPTY
34912: ST_TO_ADDR
// mc_parking := [ ] ;
34913: LD_ADDR_EXP 126
34917: PUSH
34918: EMPTY
34919: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34920: LD_ADDR_EXP 112
34924: PUSH
34925: EMPTY
34926: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34927: LD_ADDR_EXP 114
34931: PUSH
34932: EMPTY
34933: ST_TO_ADDR
// mc_scan := [ ] ;
34934: LD_ADDR_EXP 125
34938: PUSH
34939: EMPTY
34940: ST_TO_ADDR
// mc_scan_area := [ ] ;
34941: LD_ADDR_EXP 127
34945: PUSH
34946: EMPTY
34947: ST_TO_ADDR
// mc_tech := [ ] ;
34948: LD_ADDR_EXP 129
34952: PUSH
34953: EMPTY
34954: ST_TO_ADDR
// mc_class := [ ] ;
34955: LD_ADDR_EXP 143
34959: PUSH
34960: EMPTY
34961: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34962: LD_ADDR_EXP 144
34966: PUSH
34967: EMPTY
34968: ST_TO_ADDR
// end ;
34969: LD_VAR 0 1
34973: RET
// export function MC_Kill ( base ) ; begin
34974: LD_INT 0
34976: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34977: LD_ADDR_EXP 102
34981: PUSH
34982: LD_EXP 102
34986: PPUSH
34987: LD_VAR 0 1
34991: PPUSH
34992: EMPTY
34993: PPUSH
34994: CALL_OW 1
34998: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34999: LD_ADDR_EXP 103
35003: PUSH
35004: LD_EXP 103
35008: PPUSH
35009: LD_VAR 0 1
35013: PPUSH
35014: EMPTY
35015: PPUSH
35016: CALL_OW 1
35020: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35021: LD_ADDR_EXP 104
35025: PUSH
35026: LD_EXP 104
35030: PPUSH
35031: LD_VAR 0 1
35035: PPUSH
35036: EMPTY
35037: PPUSH
35038: CALL_OW 1
35042: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35043: LD_ADDR_EXP 105
35047: PUSH
35048: LD_EXP 105
35052: PPUSH
35053: LD_VAR 0 1
35057: PPUSH
35058: EMPTY
35059: PPUSH
35060: CALL_OW 1
35064: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35065: LD_ADDR_EXP 106
35069: PUSH
35070: LD_EXP 106
35074: PPUSH
35075: LD_VAR 0 1
35079: PPUSH
35080: EMPTY
35081: PPUSH
35082: CALL_OW 1
35086: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35087: LD_ADDR_EXP 107
35091: PUSH
35092: LD_EXP 107
35096: PPUSH
35097: LD_VAR 0 1
35101: PPUSH
35102: EMPTY
35103: PPUSH
35104: CALL_OW 1
35108: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35109: LD_ADDR_EXP 108
35113: PUSH
35114: LD_EXP 108
35118: PPUSH
35119: LD_VAR 0 1
35123: PPUSH
35124: EMPTY
35125: PPUSH
35126: CALL_OW 1
35130: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35131: LD_ADDR_EXP 109
35135: PUSH
35136: LD_EXP 109
35140: PPUSH
35141: LD_VAR 0 1
35145: PPUSH
35146: EMPTY
35147: PPUSH
35148: CALL_OW 1
35152: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35153: LD_ADDR_EXP 110
35157: PUSH
35158: LD_EXP 110
35162: PPUSH
35163: LD_VAR 0 1
35167: PPUSH
35168: EMPTY
35169: PPUSH
35170: CALL_OW 1
35174: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35175: LD_ADDR_EXP 111
35179: PUSH
35180: LD_EXP 111
35184: PPUSH
35185: LD_VAR 0 1
35189: PPUSH
35190: EMPTY
35191: PPUSH
35192: CALL_OW 1
35196: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35197: LD_ADDR_EXP 112
35201: PUSH
35202: LD_EXP 112
35206: PPUSH
35207: LD_VAR 0 1
35211: PPUSH
35212: EMPTY
35213: PPUSH
35214: CALL_OW 1
35218: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35219: LD_ADDR_EXP 113
35223: PUSH
35224: LD_EXP 113
35228: PPUSH
35229: LD_VAR 0 1
35233: PPUSH
35234: LD_INT 0
35236: PPUSH
35237: CALL_OW 1
35241: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35242: LD_ADDR_EXP 114
35246: PUSH
35247: LD_EXP 114
35251: PPUSH
35252: LD_VAR 0 1
35256: PPUSH
35257: EMPTY
35258: PPUSH
35259: CALL_OW 1
35263: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35264: LD_ADDR_EXP 115
35268: PUSH
35269: LD_EXP 115
35273: PPUSH
35274: LD_VAR 0 1
35278: PPUSH
35279: EMPTY
35280: PPUSH
35281: CALL_OW 1
35285: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35286: LD_ADDR_EXP 116
35290: PUSH
35291: LD_EXP 116
35295: PPUSH
35296: LD_VAR 0 1
35300: PPUSH
35301: EMPTY
35302: PPUSH
35303: CALL_OW 1
35307: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35308: LD_ADDR_EXP 117
35312: PUSH
35313: LD_EXP 117
35317: PPUSH
35318: LD_VAR 0 1
35322: PPUSH
35323: EMPTY
35324: PPUSH
35325: CALL_OW 1
35329: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35330: LD_ADDR_EXP 118
35334: PUSH
35335: LD_EXP 118
35339: PPUSH
35340: LD_VAR 0 1
35344: PPUSH
35345: EMPTY
35346: PPUSH
35347: CALL_OW 1
35351: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35352: LD_ADDR_EXP 119
35356: PUSH
35357: LD_EXP 119
35361: PPUSH
35362: LD_VAR 0 1
35366: PPUSH
35367: EMPTY
35368: PPUSH
35369: CALL_OW 1
35373: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35374: LD_ADDR_EXP 120
35378: PUSH
35379: LD_EXP 120
35383: PPUSH
35384: LD_VAR 0 1
35388: PPUSH
35389: EMPTY
35390: PPUSH
35391: CALL_OW 1
35395: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35396: LD_ADDR_EXP 121
35400: PUSH
35401: LD_EXP 121
35405: PPUSH
35406: LD_VAR 0 1
35410: PPUSH
35411: EMPTY
35412: PPUSH
35413: CALL_OW 1
35417: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35418: LD_ADDR_EXP 122
35422: PUSH
35423: LD_EXP 122
35427: PPUSH
35428: LD_VAR 0 1
35432: PPUSH
35433: EMPTY
35434: PPUSH
35435: CALL_OW 1
35439: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35440: LD_ADDR_EXP 123
35444: PUSH
35445: LD_EXP 123
35449: PPUSH
35450: LD_VAR 0 1
35454: PPUSH
35455: EMPTY
35456: PPUSH
35457: CALL_OW 1
35461: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35462: LD_ADDR_EXP 124
35466: PUSH
35467: LD_EXP 124
35471: PPUSH
35472: LD_VAR 0 1
35476: PPUSH
35477: EMPTY
35478: PPUSH
35479: CALL_OW 1
35483: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35484: LD_ADDR_EXP 125
35488: PUSH
35489: LD_EXP 125
35493: PPUSH
35494: LD_VAR 0 1
35498: PPUSH
35499: EMPTY
35500: PPUSH
35501: CALL_OW 1
35505: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35506: LD_ADDR_EXP 126
35510: PUSH
35511: LD_EXP 126
35515: PPUSH
35516: LD_VAR 0 1
35520: PPUSH
35521: EMPTY
35522: PPUSH
35523: CALL_OW 1
35527: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35528: LD_ADDR_EXP 127
35532: PUSH
35533: LD_EXP 127
35537: PPUSH
35538: LD_VAR 0 1
35542: PPUSH
35543: EMPTY
35544: PPUSH
35545: CALL_OW 1
35549: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35550: LD_ADDR_EXP 129
35554: PUSH
35555: LD_EXP 129
35559: PPUSH
35560: LD_VAR 0 1
35564: PPUSH
35565: EMPTY
35566: PPUSH
35567: CALL_OW 1
35571: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35572: LD_ADDR_EXP 131
35576: PUSH
35577: LD_EXP 131
35581: PPUSH
35582: LD_VAR 0 1
35586: PPUSH
35587: EMPTY
35588: PPUSH
35589: CALL_OW 1
35593: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35594: LD_ADDR_EXP 132
35598: PUSH
35599: LD_EXP 132
35603: PPUSH
35604: LD_VAR 0 1
35608: PPUSH
35609: EMPTY
35610: PPUSH
35611: CALL_OW 1
35615: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35616: LD_ADDR_EXP 133
35620: PUSH
35621: LD_EXP 133
35625: PPUSH
35626: LD_VAR 0 1
35630: PPUSH
35631: EMPTY
35632: PPUSH
35633: CALL_OW 1
35637: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35638: LD_ADDR_EXP 134
35642: PUSH
35643: LD_EXP 134
35647: PPUSH
35648: LD_VAR 0 1
35652: PPUSH
35653: EMPTY
35654: PPUSH
35655: CALL_OW 1
35659: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35660: LD_ADDR_EXP 135
35664: PUSH
35665: LD_EXP 135
35669: PPUSH
35670: LD_VAR 0 1
35674: PPUSH
35675: EMPTY
35676: PPUSH
35677: CALL_OW 1
35681: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35682: LD_ADDR_EXP 136
35686: PUSH
35687: LD_EXP 136
35691: PPUSH
35692: LD_VAR 0 1
35696: PPUSH
35697: EMPTY
35698: PPUSH
35699: CALL_OW 1
35703: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35704: LD_ADDR_EXP 137
35708: PUSH
35709: LD_EXP 137
35713: PPUSH
35714: LD_VAR 0 1
35718: PPUSH
35719: EMPTY
35720: PPUSH
35721: CALL_OW 1
35725: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35726: LD_ADDR_EXP 138
35730: PUSH
35731: LD_EXP 138
35735: PPUSH
35736: LD_VAR 0 1
35740: PPUSH
35741: EMPTY
35742: PPUSH
35743: CALL_OW 1
35747: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35748: LD_ADDR_EXP 139
35752: PUSH
35753: LD_EXP 139
35757: PPUSH
35758: LD_VAR 0 1
35762: PPUSH
35763: EMPTY
35764: PPUSH
35765: CALL_OW 1
35769: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35770: LD_ADDR_EXP 140
35774: PUSH
35775: LD_EXP 140
35779: PPUSH
35780: LD_VAR 0 1
35784: PPUSH
35785: EMPTY
35786: PPUSH
35787: CALL_OW 1
35791: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35792: LD_ADDR_EXP 141
35796: PUSH
35797: LD_EXP 141
35801: PPUSH
35802: LD_VAR 0 1
35806: PPUSH
35807: EMPTY
35808: PPUSH
35809: CALL_OW 1
35813: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35814: LD_ADDR_EXP 142
35818: PUSH
35819: LD_EXP 142
35823: PPUSH
35824: LD_VAR 0 1
35828: PPUSH
35829: EMPTY
35830: PPUSH
35831: CALL_OW 1
35835: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35836: LD_ADDR_EXP 143
35840: PUSH
35841: LD_EXP 143
35845: PPUSH
35846: LD_VAR 0 1
35850: PPUSH
35851: EMPTY
35852: PPUSH
35853: CALL_OW 1
35857: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35858: LD_ADDR_EXP 144
35862: PUSH
35863: LD_EXP 144
35867: PPUSH
35868: LD_VAR 0 1
35872: PPUSH
35873: LD_INT 0
35875: PPUSH
35876: CALL_OW 1
35880: ST_TO_ADDR
// end ;
35881: LD_VAR 0 2
35885: RET
// export function MC_Add ( side , units ) ; var base ; begin
35886: LD_INT 0
35888: PPUSH
35889: PPUSH
// base := mc_bases + 1 ;
35890: LD_ADDR_VAR 0 4
35894: PUSH
35895: LD_EXP 102
35899: PUSH
35900: LD_INT 1
35902: PLUS
35903: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35904: LD_ADDR_EXP 128
35908: PUSH
35909: LD_EXP 128
35913: PPUSH
35914: LD_VAR 0 4
35918: PPUSH
35919: LD_VAR 0 1
35923: PPUSH
35924: CALL_OW 1
35928: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35929: LD_ADDR_EXP 102
35933: PUSH
35934: LD_EXP 102
35938: PPUSH
35939: LD_VAR 0 4
35943: PPUSH
35944: LD_VAR 0 2
35948: PPUSH
35949: CALL_OW 1
35953: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35954: LD_ADDR_EXP 103
35958: PUSH
35959: LD_EXP 103
35963: PPUSH
35964: LD_VAR 0 4
35968: PPUSH
35969: EMPTY
35970: PPUSH
35971: CALL_OW 1
35975: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35976: LD_ADDR_EXP 104
35980: PUSH
35981: LD_EXP 104
35985: PPUSH
35986: LD_VAR 0 4
35990: PPUSH
35991: EMPTY
35992: PPUSH
35993: CALL_OW 1
35997: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35998: LD_ADDR_EXP 105
36002: PUSH
36003: LD_EXP 105
36007: PPUSH
36008: LD_VAR 0 4
36012: PPUSH
36013: EMPTY
36014: PPUSH
36015: CALL_OW 1
36019: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36020: LD_ADDR_EXP 106
36024: PUSH
36025: LD_EXP 106
36029: PPUSH
36030: LD_VAR 0 4
36034: PPUSH
36035: EMPTY
36036: PPUSH
36037: CALL_OW 1
36041: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36042: LD_ADDR_EXP 107
36046: PUSH
36047: LD_EXP 107
36051: PPUSH
36052: LD_VAR 0 4
36056: PPUSH
36057: EMPTY
36058: PPUSH
36059: CALL_OW 1
36063: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36064: LD_ADDR_EXP 108
36068: PUSH
36069: LD_EXP 108
36073: PPUSH
36074: LD_VAR 0 4
36078: PPUSH
36079: EMPTY
36080: PPUSH
36081: CALL_OW 1
36085: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36086: LD_ADDR_EXP 109
36090: PUSH
36091: LD_EXP 109
36095: PPUSH
36096: LD_VAR 0 4
36100: PPUSH
36101: EMPTY
36102: PPUSH
36103: CALL_OW 1
36107: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36108: LD_ADDR_EXP 110
36112: PUSH
36113: LD_EXP 110
36117: PPUSH
36118: LD_VAR 0 4
36122: PPUSH
36123: EMPTY
36124: PPUSH
36125: CALL_OW 1
36129: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36130: LD_ADDR_EXP 111
36134: PUSH
36135: LD_EXP 111
36139: PPUSH
36140: LD_VAR 0 4
36144: PPUSH
36145: EMPTY
36146: PPUSH
36147: CALL_OW 1
36151: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36152: LD_ADDR_EXP 112
36156: PUSH
36157: LD_EXP 112
36161: PPUSH
36162: LD_VAR 0 4
36166: PPUSH
36167: EMPTY
36168: PPUSH
36169: CALL_OW 1
36173: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36174: LD_ADDR_EXP 113
36178: PUSH
36179: LD_EXP 113
36183: PPUSH
36184: LD_VAR 0 4
36188: PPUSH
36189: LD_INT 0
36191: PPUSH
36192: CALL_OW 1
36196: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36197: LD_ADDR_EXP 114
36201: PUSH
36202: LD_EXP 114
36206: PPUSH
36207: LD_VAR 0 4
36211: PPUSH
36212: EMPTY
36213: PPUSH
36214: CALL_OW 1
36218: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36219: LD_ADDR_EXP 115
36223: PUSH
36224: LD_EXP 115
36228: PPUSH
36229: LD_VAR 0 4
36233: PPUSH
36234: EMPTY
36235: PPUSH
36236: CALL_OW 1
36240: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36241: LD_ADDR_EXP 116
36245: PUSH
36246: LD_EXP 116
36250: PPUSH
36251: LD_VAR 0 4
36255: PPUSH
36256: EMPTY
36257: PPUSH
36258: CALL_OW 1
36262: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36263: LD_ADDR_EXP 117
36267: PUSH
36268: LD_EXP 117
36272: PPUSH
36273: LD_VAR 0 4
36277: PPUSH
36278: EMPTY
36279: PPUSH
36280: CALL_OW 1
36284: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36285: LD_ADDR_EXP 118
36289: PUSH
36290: LD_EXP 118
36294: PPUSH
36295: LD_VAR 0 4
36299: PPUSH
36300: EMPTY
36301: PPUSH
36302: CALL_OW 1
36306: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36307: LD_ADDR_EXP 119
36311: PUSH
36312: LD_EXP 119
36316: PPUSH
36317: LD_VAR 0 4
36321: PPUSH
36322: EMPTY
36323: PPUSH
36324: CALL_OW 1
36328: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36329: LD_ADDR_EXP 120
36333: PUSH
36334: LD_EXP 120
36338: PPUSH
36339: LD_VAR 0 4
36343: PPUSH
36344: EMPTY
36345: PPUSH
36346: CALL_OW 1
36350: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36351: LD_ADDR_EXP 121
36355: PUSH
36356: LD_EXP 121
36360: PPUSH
36361: LD_VAR 0 4
36365: PPUSH
36366: EMPTY
36367: PPUSH
36368: CALL_OW 1
36372: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36373: LD_ADDR_EXP 122
36377: PUSH
36378: LD_EXP 122
36382: PPUSH
36383: LD_VAR 0 4
36387: PPUSH
36388: EMPTY
36389: PPUSH
36390: CALL_OW 1
36394: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36395: LD_ADDR_EXP 123
36399: PUSH
36400: LD_EXP 123
36404: PPUSH
36405: LD_VAR 0 4
36409: PPUSH
36410: EMPTY
36411: PPUSH
36412: CALL_OW 1
36416: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36417: LD_ADDR_EXP 124
36421: PUSH
36422: LD_EXP 124
36426: PPUSH
36427: LD_VAR 0 4
36431: PPUSH
36432: EMPTY
36433: PPUSH
36434: CALL_OW 1
36438: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36439: LD_ADDR_EXP 125
36443: PUSH
36444: LD_EXP 125
36448: PPUSH
36449: LD_VAR 0 4
36453: PPUSH
36454: EMPTY
36455: PPUSH
36456: CALL_OW 1
36460: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36461: LD_ADDR_EXP 126
36465: PUSH
36466: LD_EXP 126
36470: PPUSH
36471: LD_VAR 0 4
36475: PPUSH
36476: EMPTY
36477: PPUSH
36478: CALL_OW 1
36482: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36483: LD_ADDR_EXP 127
36487: PUSH
36488: LD_EXP 127
36492: PPUSH
36493: LD_VAR 0 4
36497: PPUSH
36498: EMPTY
36499: PPUSH
36500: CALL_OW 1
36504: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36505: LD_ADDR_EXP 129
36509: PUSH
36510: LD_EXP 129
36514: PPUSH
36515: LD_VAR 0 4
36519: PPUSH
36520: EMPTY
36521: PPUSH
36522: CALL_OW 1
36526: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36527: LD_ADDR_EXP 131
36531: PUSH
36532: LD_EXP 131
36536: PPUSH
36537: LD_VAR 0 4
36541: PPUSH
36542: EMPTY
36543: PPUSH
36544: CALL_OW 1
36548: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36549: LD_ADDR_EXP 132
36553: PUSH
36554: LD_EXP 132
36558: PPUSH
36559: LD_VAR 0 4
36563: PPUSH
36564: EMPTY
36565: PPUSH
36566: CALL_OW 1
36570: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36571: LD_ADDR_EXP 133
36575: PUSH
36576: LD_EXP 133
36580: PPUSH
36581: LD_VAR 0 4
36585: PPUSH
36586: EMPTY
36587: PPUSH
36588: CALL_OW 1
36592: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36593: LD_ADDR_EXP 134
36597: PUSH
36598: LD_EXP 134
36602: PPUSH
36603: LD_VAR 0 4
36607: PPUSH
36608: EMPTY
36609: PPUSH
36610: CALL_OW 1
36614: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36615: LD_ADDR_EXP 135
36619: PUSH
36620: LD_EXP 135
36624: PPUSH
36625: LD_VAR 0 4
36629: PPUSH
36630: EMPTY
36631: PPUSH
36632: CALL_OW 1
36636: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36637: LD_ADDR_EXP 136
36641: PUSH
36642: LD_EXP 136
36646: PPUSH
36647: LD_VAR 0 4
36651: PPUSH
36652: EMPTY
36653: PPUSH
36654: CALL_OW 1
36658: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36659: LD_ADDR_EXP 137
36663: PUSH
36664: LD_EXP 137
36668: PPUSH
36669: LD_VAR 0 4
36673: PPUSH
36674: EMPTY
36675: PPUSH
36676: CALL_OW 1
36680: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36681: LD_ADDR_EXP 138
36685: PUSH
36686: LD_EXP 138
36690: PPUSH
36691: LD_VAR 0 4
36695: PPUSH
36696: EMPTY
36697: PPUSH
36698: CALL_OW 1
36702: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36703: LD_ADDR_EXP 139
36707: PUSH
36708: LD_EXP 139
36712: PPUSH
36713: LD_VAR 0 4
36717: PPUSH
36718: EMPTY
36719: PPUSH
36720: CALL_OW 1
36724: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36725: LD_ADDR_EXP 140
36729: PUSH
36730: LD_EXP 140
36734: PPUSH
36735: LD_VAR 0 4
36739: PPUSH
36740: EMPTY
36741: PPUSH
36742: CALL_OW 1
36746: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36747: LD_ADDR_EXP 141
36751: PUSH
36752: LD_EXP 141
36756: PPUSH
36757: LD_VAR 0 4
36761: PPUSH
36762: EMPTY
36763: PPUSH
36764: CALL_OW 1
36768: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36769: LD_ADDR_EXP 142
36773: PUSH
36774: LD_EXP 142
36778: PPUSH
36779: LD_VAR 0 4
36783: PPUSH
36784: EMPTY
36785: PPUSH
36786: CALL_OW 1
36790: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36791: LD_ADDR_EXP 143
36795: PUSH
36796: LD_EXP 143
36800: PPUSH
36801: LD_VAR 0 4
36805: PPUSH
36806: EMPTY
36807: PPUSH
36808: CALL_OW 1
36812: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36813: LD_ADDR_EXP 144
36817: PUSH
36818: LD_EXP 144
36822: PPUSH
36823: LD_VAR 0 4
36827: PPUSH
36828: LD_INT 0
36830: PPUSH
36831: CALL_OW 1
36835: ST_TO_ADDR
// result := base ;
36836: LD_ADDR_VAR 0 3
36840: PUSH
36841: LD_VAR 0 4
36845: ST_TO_ADDR
// end ;
36846: LD_VAR 0 3
36850: RET
// export function MC_Start ( ) ; var i ; begin
36851: LD_INT 0
36853: PPUSH
36854: PPUSH
// for i = 1 to mc_bases do
36855: LD_ADDR_VAR 0 2
36859: PUSH
36860: DOUBLE
36861: LD_INT 1
36863: DEC
36864: ST_TO_ADDR
36865: LD_EXP 102
36869: PUSH
36870: FOR_TO
36871: IFFALSE 37948
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36873: LD_ADDR_EXP 102
36877: PUSH
36878: LD_EXP 102
36882: PPUSH
36883: LD_VAR 0 2
36887: PPUSH
36888: LD_EXP 102
36892: PUSH
36893: LD_VAR 0 2
36897: ARRAY
36898: PUSH
36899: LD_INT 0
36901: DIFF
36902: PPUSH
36903: CALL_OW 1
36907: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36908: LD_ADDR_EXP 103
36912: PUSH
36913: LD_EXP 103
36917: PPUSH
36918: LD_VAR 0 2
36922: PPUSH
36923: EMPTY
36924: PPUSH
36925: CALL_OW 1
36929: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36930: LD_ADDR_EXP 104
36934: PUSH
36935: LD_EXP 104
36939: PPUSH
36940: LD_VAR 0 2
36944: PPUSH
36945: EMPTY
36946: PPUSH
36947: CALL_OW 1
36951: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36952: LD_ADDR_EXP 105
36956: PUSH
36957: LD_EXP 105
36961: PPUSH
36962: LD_VAR 0 2
36966: PPUSH
36967: EMPTY
36968: PPUSH
36969: CALL_OW 1
36973: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36974: LD_ADDR_EXP 106
36978: PUSH
36979: LD_EXP 106
36983: PPUSH
36984: LD_VAR 0 2
36988: PPUSH
36989: EMPTY
36990: PUSH
36991: EMPTY
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PPUSH
36997: CALL_OW 1
37001: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37002: LD_ADDR_EXP 107
37006: PUSH
37007: LD_EXP 107
37011: PPUSH
37012: LD_VAR 0 2
37016: PPUSH
37017: EMPTY
37018: PPUSH
37019: CALL_OW 1
37023: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37024: LD_ADDR_EXP 134
37028: PUSH
37029: LD_EXP 134
37033: PPUSH
37034: LD_VAR 0 2
37038: PPUSH
37039: EMPTY
37040: PPUSH
37041: CALL_OW 1
37045: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37046: LD_ADDR_EXP 108
37050: PUSH
37051: LD_EXP 108
37055: PPUSH
37056: LD_VAR 0 2
37060: PPUSH
37061: EMPTY
37062: PPUSH
37063: CALL_OW 1
37067: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37068: LD_ADDR_EXP 109
37072: PUSH
37073: LD_EXP 109
37077: PPUSH
37078: LD_VAR 0 2
37082: PPUSH
37083: EMPTY
37084: PPUSH
37085: CALL_OW 1
37089: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37090: LD_ADDR_EXP 110
37094: PUSH
37095: LD_EXP 110
37099: PPUSH
37100: LD_VAR 0 2
37104: PPUSH
37105: LD_EXP 102
37109: PUSH
37110: LD_VAR 0 2
37114: ARRAY
37115: PPUSH
37116: LD_INT 2
37118: PUSH
37119: LD_INT 30
37121: PUSH
37122: LD_INT 32
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 30
37131: PUSH
37132: LD_INT 33
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: LIST
37143: PPUSH
37144: CALL_OW 72
37148: PPUSH
37149: CALL_OW 1
37153: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37154: LD_ADDR_EXP 111
37158: PUSH
37159: LD_EXP 111
37163: PPUSH
37164: LD_VAR 0 2
37168: PPUSH
37169: LD_EXP 102
37173: PUSH
37174: LD_VAR 0 2
37178: ARRAY
37179: PPUSH
37180: LD_INT 2
37182: PUSH
37183: LD_INT 30
37185: PUSH
37186: LD_INT 32
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 30
37195: PUSH
37196: LD_INT 31
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: LIST
37207: PUSH
37208: LD_INT 58
37210: PUSH
37211: EMPTY
37212: LIST
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PPUSH
37218: CALL_OW 72
37222: PPUSH
37223: CALL_OW 1
37227: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37228: LD_ADDR_EXP 112
37232: PUSH
37233: LD_EXP 112
37237: PPUSH
37238: LD_VAR 0 2
37242: PPUSH
37243: EMPTY
37244: PPUSH
37245: CALL_OW 1
37249: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37250: LD_ADDR_EXP 116
37254: PUSH
37255: LD_EXP 116
37259: PPUSH
37260: LD_VAR 0 2
37264: PPUSH
37265: EMPTY
37266: PPUSH
37267: CALL_OW 1
37271: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37272: LD_ADDR_EXP 115
37276: PUSH
37277: LD_EXP 115
37281: PPUSH
37282: LD_VAR 0 2
37286: PPUSH
37287: EMPTY
37288: PPUSH
37289: CALL_OW 1
37293: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37294: LD_ADDR_EXP 117
37298: PUSH
37299: LD_EXP 117
37303: PPUSH
37304: LD_VAR 0 2
37308: PPUSH
37309: EMPTY
37310: PPUSH
37311: CALL_OW 1
37315: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37316: LD_ADDR_EXP 118
37320: PUSH
37321: LD_EXP 118
37325: PPUSH
37326: LD_VAR 0 2
37330: PPUSH
37331: EMPTY
37332: PPUSH
37333: CALL_OW 1
37337: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37338: LD_ADDR_EXP 119
37342: PUSH
37343: LD_EXP 119
37347: PPUSH
37348: LD_VAR 0 2
37352: PPUSH
37353: EMPTY
37354: PPUSH
37355: CALL_OW 1
37359: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37360: LD_ADDR_EXP 120
37364: PUSH
37365: LD_EXP 120
37369: PPUSH
37370: LD_VAR 0 2
37374: PPUSH
37375: EMPTY
37376: PPUSH
37377: CALL_OW 1
37381: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37382: LD_ADDR_EXP 121
37386: PUSH
37387: LD_EXP 121
37391: PPUSH
37392: LD_VAR 0 2
37396: PPUSH
37397: EMPTY
37398: PPUSH
37399: CALL_OW 1
37403: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37404: LD_ADDR_EXP 122
37408: PUSH
37409: LD_EXP 122
37413: PPUSH
37414: LD_VAR 0 2
37418: PPUSH
37419: EMPTY
37420: PPUSH
37421: CALL_OW 1
37425: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37426: LD_ADDR_EXP 123
37430: PUSH
37431: LD_EXP 123
37435: PPUSH
37436: LD_VAR 0 2
37440: PPUSH
37441: EMPTY
37442: PPUSH
37443: CALL_OW 1
37447: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37448: LD_ADDR_EXP 124
37452: PUSH
37453: LD_EXP 124
37457: PPUSH
37458: LD_VAR 0 2
37462: PPUSH
37463: EMPTY
37464: PPUSH
37465: CALL_OW 1
37469: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37470: LD_ADDR_EXP 113
37474: PUSH
37475: LD_EXP 113
37479: PPUSH
37480: LD_VAR 0 2
37484: PPUSH
37485: LD_INT 0
37487: PPUSH
37488: CALL_OW 1
37492: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37493: LD_ADDR_EXP 126
37497: PUSH
37498: LD_EXP 126
37502: PPUSH
37503: LD_VAR 0 2
37507: PPUSH
37508: LD_INT 0
37510: PPUSH
37511: CALL_OW 1
37515: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37516: LD_ADDR_EXP 114
37520: PUSH
37521: LD_EXP 114
37525: PPUSH
37526: LD_VAR 0 2
37530: PPUSH
37531: EMPTY
37532: PPUSH
37533: CALL_OW 1
37537: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37538: LD_ADDR_EXP 125
37542: PUSH
37543: LD_EXP 125
37547: PPUSH
37548: LD_VAR 0 2
37552: PPUSH
37553: LD_INT 0
37555: PPUSH
37556: CALL_OW 1
37560: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37561: LD_ADDR_EXP 127
37565: PUSH
37566: LD_EXP 127
37570: PPUSH
37571: LD_VAR 0 2
37575: PPUSH
37576: EMPTY
37577: PPUSH
37578: CALL_OW 1
37582: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37583: LD_ADDR_EXP 130
37587: PUSH
37588: LD_EXP 130
37592: PPUSH
37593: LD_VAR 0 2
37597: PPUSH
37598: LD_INT 0
37600: PPUSH
37601: CALL_OW 1
37605: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37606: LD_ADDR_EXP 131
37610: PUSH
37611: LD_EXP 131
37615: PPUSH
37616: LD_VAR 0 2
37620: PPUSH
37621: EMPTY
37622: PPUSH
37623: CALL_OW 1
37627: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37628: LD_ADDR_EXP 132
37632: PUSH
37633: LD_EXP 132
37637: PPUSH
37638: LD_VAR 0 2
37642: PPUSH
37643: EMPTY
37644: PPUSH
37645: CALL_OW 1
37649: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37650: LD_ADDR_EXP 133
37654: PUSH
37655: LD_EXP 133
37659: PPUSH
37660: LD_VAR 0 2
37664: PPUSH
37665: EMPTY
37666: PPUSH
37667: CALL_OW 1
37671: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37672: LD_ADDR_EXP 135
37676: PUSH
37677: LD_EXP 135
37681: PPUSH
37682: LD_VAR 0 2
37686: PPUSH
37687: LD_EXP 102
37691: PUSH
37692: LD_VAR 0 2
37696: ARRAY
37697: PPUSH
37698: LD_INT 2
37700: PUSH
37701: LD_INT 30
37703: PUSH
37704: LD_INT 6
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 30
37713: PUSH
37714: LD_INT 7
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: LD_INT 30
37723: PUSH
37724: LD_INT 8
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: LIST
37735: LIST
37736: PPUSH
37737: CALL_OW 72
37741: PPUSH
37742: CALL_OW 1
37746: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37747: LD_ADDR_EXP 136
37751: PUSH
37752: LD_EXP 136
37756: PPUSH
37757: LD_VAR 0 2
37761: PPUSH
37762: EMPTY
37763: PPUSH
37764: CALL_OW 1
37768: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37769: LD_ADDR_EXP 137
37773: PUSH
37774: LD_EXP 137
37778: PPUSH
37779: LD_VAR 0 2
37783: PPUSH
37784: EMPTY
37785: PPUSH
37786: CALL_OW 1
37790: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37791: LD_ADDR_EXP 138
37795: PUSH
37796: LD_EXP 138
37800: PPUSH
37801: LD_VAR 0 2
37805: PPUSH
37806: EMPTY
37807: PPUSH
37808: CALL_OW 1
37812: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37813: LD_ADDR_EXP 139
37817: PUSH
37818: LD_EXP 139
37822: PPUSH
37823: LD_VAR 0 2
37827: PPUSH
37828: EMPTY
37829: PPUSH
37830: CALL_OW 1
37834: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37835: LD_ADDR_EXP 140
37839: PUSH
37840: LD_EXP 140
37844: PPUSH
37845: LD_VAR 0 2
37849: PPUSH
37850: EMPTY
37851: PPUSH
37852: CALL_OW 1
37856: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37857: LD_ADDR_EXP 141
37861: PUSH
37862: LD_EXP 141
37866: PPUSH
37867: LD_VAR 0 2
37871: PPUSH
37872: EMPTY
37873: PPUSH
37874: CALL_OW 1
37878: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37879: LD_ADDR_EXP 142
37883: PUSH
37884: LD_EXP 142
37888: PPUSH
37889: LD_VAR 0 2
37893: PPUSH
37894: EMPTY
37895: PPUSH
37896: CALL_OW 1
37900: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37901: LD_ADDR_EXP 143
37905: PUSH
37906: LD_EXP 143
37910: PPUSH
37911: LD_VAR 0 2
37915: PPUSH
37916: EMPTY
37917: PPUSH
37918: CALL_OW 1
37922: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37923: LD_ADDR_EXP 144
37927: PUSH
37928: LD_EXP 144
37932: PPUSH
37933: LD_VAR 0 2
37937: PPUSH
37938: LD_INT 0
37940: PPUSH
37941: CALL_OW 1
37945: ST_TO_ADDR
// end ;
37946: GO 36870
37948: POP
37949: POP
// MC_InitSides ( ) ;
37950: CALL 38236 0 0
// MC_InitResearch ( ) ;
37954: CALL 37975 0 0
// CustomInitMacro ( ) ;
37958: CALL 463 0 0
// skirmish := true ;
37962: LD_ADDR_EXP 100
37966: PUSH
37967: LD_INT 1
37969: ST_TO_ADDR
// end ;
37970: LD_VAR 0 1
37974: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37975: LD_INT 0
37977: PPUSH
37978: PPUSH
37979: PPUSH
37980: PPUSH
37981: PPUSH
37982: PPUSH
// if not mc_bases then
37983: LD_EXP 102
37987: NOT
37988: IFFALSE 37992
// exit ;
37990: GO 38231
// for i = 1 to 8 do
37992: LD_ADDR_VAR 0 2
37996: PUSH
37997: DOUBLE
37998: LD_INT 1
38000: DEC
38001: ST_TO_ADDR
38002: LD_INT 8
38004: PUSH
38005: FOR_TO
38006: IFFALSE 38032
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38008: LD_ADDR_EXP 129
38012: PUSH
38013: LD_EXP 129
38017: PPUSH
38018: LD_VAR 0 2
38022: PPUSH
38023: EMPTY
38024: PPUSH
38025: CALL_OW 1
38029: ST_TO_ADDR
38030: GO 38005
38032: POP
38033: POP
// tmp := [ ] ;
38034: LD_ADDR_VAR 0 5
38038: PUSH
38039: EMPTY
38040: ST_TO_ADDR
// for i = 1 to mc_sides do
38041: LD_ADDR_VAR 0 2
38045: PUSH
38046: DOUBLE
38047: LD_INT 1
38049: DEC
38050: ST_TO_ADDR
38051: LD_EXP 128
38055: PUSH
38056: FOR_TO
38057: IFFALSE 38115
// if not mc_sides [ i ] in tmp then
38059: LD_EXP 128
38063: PUSH
38064: LD_VAR 0 2
38068: ARRAY
38069: PUSH
38070: LD_VAR 0 5
38074: IN
38075: NOT
38076: IFFALSE 38113
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38078: LD_ADDR_VAR 0 5
38082: PUSH
38083: LD_VAR 0 5
38087: PPUSH
38088: LD_VAR 0 5
38092: PUSH
38093: LD_INT 1
38095: PLUS
38096: PPUSH
38097: LD_EXP 128
38101: PUSH
38102: LD_VAR 0 2
38106: ARRAY
38107: PPUSH
38108: CALL_OW 2
38112: ST_TO_ADDR
38113: GO 38056
38115: POP
38116: POP
// if not tmp then
38117: LD_VAR 0 5
38121: NOT
38122: IFFALSE 38126
// exit ;
38124: GO 38231
// for j in tmp do
38126: LD_ADDR_VAR 0 3
38130: PUSH
38131: LD_VAR 0 5
38135: PUSH
38136: FOR_IN
38137: IFFALSE 38229
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38139: LD_ADDR_VAR 0 6
38143: PUSH
38144: LD_INT 22
38146: PUSH
38147: LD_VAR 0 3
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: PPUSH
38156: CALL_OW 69
38160: ST_TO_ADDR
// if not un then
38161: LD_VAR 0 6
38165: NOT
38166: IFFALSE 38170
// continue ;
38168: GO 38136
// nation := GetNation ( un [ 1 ] ) ;
38170: LD_ADDR_VAR 0 4
38174: PUSH
38175: LD_VAR 0 6
38179: PUSH
38180: LD_INT 1
38182: ARRAY
38183: PPUSH
38184: CALL_OW 248
38188: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38189: LD_ADDR_EXP 129
38193: PUSH
38194: LD_EXP 129
38198: PPUSH
38199: LD_VAR 0 3
38203: PPUSH
38204: LD_VAR 0 3
38208: PPUSH
38209: LD_VAR 0 4
38213: PPUSH
38214: LD_INT 1
38216: PPUSH
38217: CALL 64841 0 3
38221: PPUSH
38222: CALL_OW 1
38226: ST_TO_ADDR
// end ;
38227: GO 38136
38229: POP
38230: POP
// end ;
38231: LD_VAR 0 1
38235: RET
// export function MC_InitSides ( ) ; var i ; begin
38236: LD_INT 0
38238: PPUSH
38239: PPUSH
// if not mc_bases then
38240: LD_EXP 102
38244: NOT
38245: IFFALSE 38249
// exit ;
38247: GO 38323
// for i = 1 to mc_bases do
38249: LD_ADDR_VAR 0 2
38253: PUSH
38254: DOUBLE
38255: LD_INT 1
38257: DEC
38258: ST_TO_ADDR
38259: LD_EXP 102
38263: PUSH
38264: FOR_TO
38265: IFFALSE 38321
// if mc_bases [ i ] then
38267: LD_EXP 102
38271: PUSH
38272: LD_VAR 0 2
38276: ARRAY
38277: IFFALSE 38319
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38279: LD_ADDR_EXP 128
38283: PUSH
38284: LD_EXP 128
38288: PPUSH
38289: LD_VAR 0 2
38293: PPUSH
38294: LD_EXP 102
38298: PUSH
38299: LD_VAR 0 2
38303: ARRAY
38304: PUSH
38305: LD_INT 1
38307: ARRAY
38308: PPUSH
38309: CALL_OW 255
38313: PPUSH
38314: CALL_OW 1
38318: ST_TO_ADDR
38319: GO 38264
38321: POP
38322: POP
// end ;
38323: LD_VAR 0 1
38327: RET
// every 0 0$01 trigger skirmish do
38328: LD_EXP 100
38332: IFFALSE 38486
38334: GO 38336
38336: DISABLE
// begin enable ;
38337: ENABLE
// MC_CheckBuildings ( ) ;
38338: CALL 42984 0 0
// MC_CheckPeopleLife ( ) ;
38342: CALL 43109 0 0
// RaiseSailEvent ( 100 ) ;
38346: LD_INT 100
38348: PPUSH
38349: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38353: LD_INT 103
38355: PPUSH
38356: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38360: LD_INT 104
38362: PPUSH
38363: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38367: LD_INT 105
38369: PPUSH
38370: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38374: LD_INT 106
38376: PPUSH
38377: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38381: LD_INT 107
38383: PPUSH
38384: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38388: LD_INT 108
38390: PPUSH
38391: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38395: LD_INT 109
38397: PPUSH
38398: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38402: LD_INT 110
38404: PPUSH
38405: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38409: LD_INT 111
38411: PPUSH
38412: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38416: LD_INT 112
38418: PPUSH
38419: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38423: LD_INT 113
38425: PPUSH
38426: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38430: LD_INT 120
38432: PPUSH
38433: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38437: LD_INT 121
38439: PPUSH
38440: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38444: LD_INT 122
38446: PPUSH
38447: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38451: LD_INT 123
38453: PPUSH
38454: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38458: LD_INT 124
38460: PPUSH
38461: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38465: LD_INT 125
38467: PPUSH
38468: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38472: LD_INT 126
38474: PPUSH
38475: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38479: LD_INT 200
38481: PPUSH
38482: CALL_OW 427
// end ;
38486: END
// on SailEvent ( event ) do begin if event < 100 then
38487: LD_VAR 0 1
38491: PUSH
38492: LD_INT 100
38494: LESS
38495: IFFALSE 38506
// CustomEvent ( event ) ;
38497: LD_VAR 0 1
38501: PPUSH
38502: CALL 33146 0 1
// if event = 100 then
38506: LD_VAR 0 1
38510: PUSH
38511: LD_INT 100
38513: EQUAL
38514: IFFALSE 38520
// MC_ClassManager ( ) ;
38516: CALL 38912 0 0
// if event = 101 then
38520: LD_VAR 0 1
38524: PUSH
38525: LD_INT 101
38527: EQUAL
38528: IFFALSE 38534
// MC_RepairBuildings ( ) ;
38530: CALL 43705 0 0
// if event = 102 then
38534: LD_VAR 0 1
38538: PUSH
38539: LD_INT 102
38541: EQUAL
38542: IFFALSE 38548
// MC_Heal ( ) ;
38544: CALL 44569 0 0
// if event = 103 then
38548: LD_VAR 0 1
38552: PUSH
38553: LD_INT 103
38555: EQUAL
38556: IFFALSE 38562
// MC_Build ( ) ;
38558: CALL 44991 0 0
// if event = 104 then
38562: LD_VAR 0 1
38566: PUSH
38567: LD_INT 104
38569: EQUAL
38570: IFFALSE 38576
// MC_TurretWeapon ( ) ;
38572: CALL 46604 0 0
// if event = 105 then
38576: LD_VAR 0 1
38580: PUSH
38581: LD_INT 105
38583: EQUAL
38584: IFFALSE 38590
// MC_BuildUpgrade ( ) ;
38586: CALL 46155 0 0
// if event = 106 then
38590: LD_VAR 0 1
38594: PUSH
38595: LD_INT 106
38597: EQUAL
38598: IFFALSE 38604
// MC_PlantMines ( ) ;
38600: CALL 47034 0 0
// if event = 107 then
38604: LD_VAR 0 1
38608: PUSH
38609: LD_INT 107
38611: EQUAL
38612: IFFALSE 38618
// MC_CollectCrates ( ) ;
38614: CALL 47832 0 0
// if event = 108 then
38618: LD_VAR 0 1
38622: PUSH
38623: LD_INT 108
38625: EQUAL
38626: IFFALSE 38632
// MC_LinkRemoteControl ( ) ;
38628: CALL 49608 0 0
// if event = 109 then
38632: LD_VAR 0 1
38636: PUSH
38637: LD_INT 109
38639: EQUAL
38640: IFFALSE 38646
// MC_ProduceVehicle ( ) ;
38642: CALL 49789 0 0
// if event = 110 then
38646: LD_VAR 0 1
38650: PUSH
38651: LD_INT 110
38653: EQUAL
38654: IFFALSE 38660
// MC_SendAttack ( ) ;
38656: CALL 50255 0 0
// if event = 111 then
38660: LD_VAR 0 1
38664: PUSH
38665: LD_INT 111
38667: EQUAL
38668: IFFALSE 38674
// MC_Defend ( ) ;
38670: CALL 50363 0 0
// if event = 112 then
38674: LD_VAR 0 1
38678: PUSH
38679: LD_INT 112
38681: EQUAL
38682: IFFALSE 38688
// MC_Research ( ) ;
38684: CALL 50968 0 0
// if event = 113 then
38688: LD_VAR 0 1
38692: PUSH
38693: LD_INT 113
38695: EQUAL
38696: IFFALSE 38702
// MC_MinesTrigger ( ) ;
38698: CALL 52082 0 0
// if event = 120 then
38702: LD_VAR 0 1
38706: PUSH
38707: LD_INT 120
38709: EQUAL
38710: IFFALSE 38716
// MC_RepairVehicle ( ) ;
38712: CALL 52181 0 0
// if event = 121 then
38716: LD_VAR 0 1
38720: PUSH
38721: LD_INT 121
38723: EQUAL
38724: IFFALSE 38730
// MC_TameApe ( ) ;
38726: CALL 52911 0 0
// if event = 122 then
38730: LD_VAR 0 1
38734: PUSH
38735: LD_INT 122
38737: EQUAL
38738: IFFALSE 38744
// MC_ChangeApeClass ( ) ;
38740: CALL 53740 0 0
// if event = 123 then
38744: LD_VAR 0 1
38748: PUSH
38749: LD_INT 123
38751: EQUAL
38752: IFFALSE 38758
// MC_Bazooka ( ) ;
38754: CALL 54390 0 0
// if event = 124 then
38758: LD_VAR 0 1
38762: PUSH
38763: LD_INT 124
38765: EQUAL
38766: IFFALSE 38772
// MC_TeleportExit ( ) ;
38768: CALL 54588 0 0
// if event = 125 then
38772: LD_VAR 0 1
38776: PUSH
38777: LD_INT 125
38779: EQUAL
38780: IFFALSE 38786
// MC_Deposits ( ) ;
38782: CALL 55235 0 0
// if event = 126 then
38786: LD_VAR 0 1
38790: PUSH
38791: LD_INT 126
38793: EQUAL
38794: IFFALSE 38800
// MC_RemoteDriver ( ) ;
38796: CALL 55860 0 0
// if event = 200 then
38800: LD_VAR 0 1
38804: PUSH
38805: LD_INT 200
38807: EQUAL
38808: IFFALSE 38814
// MC_Idle ( ) ;
38810: CALL 57809 0 0
// end ;
38814: PPOPN 1
38816: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38817: LD_INT 0
38819: PPUSH
38820: PPUSH
// if not mc_bases [ base ] or not tag then
38821: LD_EXP 102
38825: PUSH
38826: LD_VAR 0 1
38830: ARRAY
38831: NOT
38832: PUSH
38833: LD_VAR 0 2
38837: NOT
38838: OR
38839: IFFALSE 38843
// exit ;
38841: GO 38907
// for i in mc_bases [ base ] union mc_ape [ base ] do
38843: LD_ADDR_VAR 0 4
38847: PUSH
38848: LD_EXP 102
38852: PUSH
38853: LD_VAR 0 1
38857: ARRAY
38858: PUSH
38859: LD_EXP 131
38863: PUSH
38864: LD_VAR 0 1
38868: ARRAY
38869: UNION
38870: PUSH
38871: FOR_IN
38872: IFFALSE 38905
// if GetTag ( i ) = tag then
38874: LD_VAR 0 4
38878: PPUSH
38879: CALL_OW 110
38883: PUSH
38884: LD_VAR 0 2
38888: EQUAL
38889: IFFALSE 38903
// SetTag ( i , 0 ) ;
38891: LD_VAR 0 4
38895: PPUSH
38896: LD_INT 0
38898: PPUSH
38899: CALL_OW 109
38903: GO 38871
38905: POP
38906: POP
// end ;
38907: LD_VAR 0 3
38911: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38912: LD_INT 0
38914: PPUSH
38915: PPUSH
38916: PPUSH
38917: PPUSH
38918: PPUSH
38919: PPUSH
38920: PPUSH
38921: PPUSH
// if not mc_bases then
38922: LD_EXP 102
38926: NOT
38927: IFFALSE 38931
// exit ;
38929: GO 39389
// for i = 1 to mc_bases do
38931: LD_ADDR_VAR 0 2
38935: PUSH
38936: DOUBLE
38937: LD_INT 1
38939: DEC
38940: ST_TO_ADDR
38941: LD_EXP 102
38945: PUSH
38946: FOR_TO
38947: IFFALSE 39387
// begin tmp := MC_ClassCheckReq ( i ) ;
38949: LD_ADDR_VAR 0 4
38953: PUSH
38954: LD_VAR 0 2
38958: PPUSH
38959: CALL 39394 0 1
38963: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38964: LD_ADDR_EXP 143
38968: PUSH
38969: LD_EXP 143
38973: PPUSH
38974: LD_VAR 0 2
38978: PPUSH
38979: LD_VAR 0 4
38983: PPUSH
38984: CALL_OW 1
38988: ST_TO_ADDR
// if not tmp then
38989: LD_VAR 0 4
38993: NOT
38994: IFFALSE 38998
// continue ;
38996: GO 38946
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38998: LD_ADDR_VAR 0 6
39002: PUSH
39003: LD_EXP 102
39007: PUSH
39008: LD_VAR 0 2
39012: ARRAY
39013: PPUSH
39014: LD_INT 2
39016: PUSH
39017: LD_INT 30
39019: PUSH
39020: LD_INT 4
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 30
39029: PUSH
39030: LD_INT 5
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PUSH
39037: EMPTY
39038: LIST
39039: LIST
39040: LIST
39041: PPUSH
39042: CALL_OW 72
39046: PUSH
39047: LD_EXP 102
39051: PUSH
39052: LD_VAR 0 2
39056: ARRAY
39057: PPUSH
39058: LD_INT 2
39060: PUSH
39061: LD_INT 30
39063: PUSH
39064: LD_INT 0
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 30
39073: PUSH
39074: LD_INT 1
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: EMPTY
39082: LIST
39083: LIST
39084: LIST
39085: PPUSH
39086: CALL_OW 72
39090: PUSH
39091: LD_EXP 102
39095: PUSH
39096: LD_VAR 0 2
39100: ARRAY
39101: PPUSH
39102: LD_INT 30
39104: PUSH
39105: LD_INT 3
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PPUSH
39112: CALL_OW 72
39116: PUSH
39117: LD_EXP 102
39121: PUSH
39122: LD_VAR 0 2
39126: ARRAY
39127: PPUSH
39128: LD_INT 2
39130: PUSH
39131: LD_INT 30
39133: PUSH
39134: LD_INT 6
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PUSH
39141: LD_INT 30
39143: PUSH
39144: LD_INT 7
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: PUSH
39151: LD_INT 30
39153: PUSH
39154: LD_INT 8
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: LIST
39165: LIST
39166: PPUSH
39167: CALL_OW 72
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: LIST
39176: LIST
39177: ST_TO_ADDR
// for j = 1 to 4 do
39178: LD_ADDR_VAR 0 3
39182: PUSH
39183: DOUBLE
39184: LD_INT 1
39186: DEC
39187: ST_TO_ADDR
39188: LD_INT 4
39190: PUSH
39191: FOR_TO
39192: IFFALSE 39383
// begin if not tmp [ j ] then
39194: LD_VAR 0 4
39198: PUSH
39199: LD_VAR 0 3
39203: ARRAY
39204: NOT
39205: IFFALSE 39209
// continue ;
39207: GO 39191
// for p in tmp [ j ] do
39209: LD_ADDR_VAR 0 5
39213: PUSH
39214: LD_VAR 0 4
39218: PUSH
39219: LD_VAR 0 3
39223: ARRAY
39224: PUSH
39225: FOR_IN
39226: IFFALSE 39379
// begin if not b [ j ] then
39228: LD_VAR 0 6
39232: PUSH
39233: LD_VAR 0 3
39237: ARRAY
39238: NOT
39239: IFFALSE 39243
// break ;
39241: GO 39379
// e := 0 ;
39243: LD_ADDR_VAR 0 7
39247: PUSH
39248: LD_INT 0
39250: ST_TO_ADDR
// for k in b [ j ] do
39251: LD_ADDR_VAR 0 8
39255: PUSH
39256: LD_VAR 0 6
39260: PUSH
39261: LD_VAR 0 3
39265: ARRAY
39266: PUSH
39267: FOR_IN
39268: IFFALSE 39295
// if IsNotFull ( k ) then
39270: LD_VAR 0 8
39274: PPUSH
39275: CALL 69281 0 1
39279: IFFALSE 39293
// begin e := k ;
39281: LD_ADDR_VAR 0 7
39285: PUSH
39286: LD_VAR 0 8
39290: ST_TO_ADDR
// break ;
39291: GO 39295
// end ;
39293: GO 39267
39295: POP
39296: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39297: LD_VAR 0 7
39301: PUSH
39302: LD_VAR 0 5
39306: PPUSH
39307: LD_VAR 0 7
39311: PPUSH
39312: CALL 106410 0 2
39316: NOT
39317: AND
39318: IFFALSE 39377
// begin if IsInUnit ( p ) then
39320: LD_VAR 0 5
39324: PPUSH
39325: CALL_OW 310
39329: IFFALSE 39340
// ComExitBuilding ( p ) ;
39331: LD_VAR 0 5
39335: PPUSH
39336: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39340: LD_VAR 0 5
39344: PPUSH
39345: LD_VAR 0 7
39349: PPUSH
39350: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39354: LD_VAR 0 5
39358: PPUSH
39359: LD_VAR 0 3
39363: PPUSH
39364: CALL_OW 183
// AddComExitBuilding ( p ) ;
39368: LD_VAR 0 5
39372: PPUSH
39373: CALL_OW 182
// end ; end ;
39377: GO 39225
39379: POP
39380: POP
// end ;
39381: GO 39191
39383: POP
39384: POP
// end ;
39385: GO 38946
39387: POP
39388: POP
// end ;
39389: LD_VAR 0 1
39393: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39394: LD_INT 0
39396: PPUSH
39397: PPUSH
39398: PPUSH
39399: PPUSH
39400: PPUSH
39401: PPUSH
39402: PPUSH
39403: PPUSH
39404: PPUSH
39405: PPUSH
39406: PPUSH
39407: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39408: LD_VAR 0 1
39412: NOT
39413: PUSH
39414: LD_EXP 102
39418: PUSH
39419: LD_VAR 0 1
39423: ARRAY
39424: NOT
39425: OR
39426: PUSH
39427: LD_EXP 102
39431: PUSH
39432: LD_VAR 0 1
39436: ARRAY
39437: PPUSH
39438: LD_INT 2
39440: PUSH
39441: LD_INT 30
39443: PUSH
39444: LD_INT 0
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 30
39453: PUSH
39454: LD_INT 1
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: EMPTY
39462: LIST
39463: LIST
39464: LIST
39465: PPUSH
39466: CALL_OW 72
39470: NOT
39471: OR
39472: IFFALSE 39476
// exit ;
39474: GO 42979
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39476: LD_ADDR_VAR 0 4
39480: PUSH
39481: LD_EXP 102
39485: PUSH
39486: LD_VAR 0 1
39490: ARRAY
39491: PPUSH
39492: LD_INT 2
39494: PUSH
39495: LD_INT 25
39497: PUSH
39498: LD_INT 1
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 25
39507: PUSH
39508: LD_INT 2
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 25
39517: PUSH
39518: LD_INT 3
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 25
39527: PUSH
39528: LD_INT 4
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 25
39537: PUSH
39538: LD_INT 5
39540: PUSH
39541: EMPTY
39542: LIST
39543: LIST
39544: PUSH
39545: LD_INT 25
39547: PUSH
39548: LD_INT 8
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 25
39557: PUSH
39558: LD_INT 9
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: LIST
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: PPUSH
39575: CALL_OW 72
39579: ST_TO_ADDR
// if not tmp then
39580: LD_VAR 0 4
39584: NOT
39585: IFFALSE 39589
// exit ;
39587: GO 42979
// for i in tmp do
39589: LD_ADDR_VAR 0 3
39593: PUSH
39594: LD_VAR 0 4
39598: PUSH
39599: FOR_IN
39600: IFFALSE 39631
// if GetTag ( i ) then
39602: LD_VAR 0 3
39606: PPUSH
39607: CALL_OW 110
39611: IFFALSE 39629
// tmp := tmp diff i ;
39613: LD_ADDR_VAR 0 4
39617: PUSH
39618: LD_VAR 0 4
39622: PUSH
39623: LD_VAR 0 3
39627: DIFF
39628: ST_TO_ADDR
39629: GO 39599
39631: POP
39632: POP
// if not tmp then
39633: LD_VAR 0 4
39637: NOT
39638: IFFALSE 39642
// exit ;
39640: GO 42979
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39642: LD_ADDR_VAR 0 5
39646: PUSH
39647: LD_EXP 102
39651: PUSH
39652: LD_VAR 0 1
39656: ARRAY
39657: PPUSH
39658: LD_INT 2
39660: PUSH
39661: LD_INT 25
39663: PUSH
39664: LD_INT 1
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 25
39673: PUSH
39674: LD_INT 5
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 25
39683: PUSH
39684: LD_INT 8
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 25
39693: PUSH
39694: LD_INT 9
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: LIST
39705: LIST
39706: LIST
39707: PPUSH
39708: CALL_OW 72
39712: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39713: LD_ADDR_VAR 0 6
39717: PUSH
39718: LD_EXP 102
39722: PUSH
39723: LD_VAR 0 1
39727: ARRAY
39728: PPUSH
39729: LD_INT 25
39731: PUSH
39732: LD_INT 2
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PPUSH
39739: CALL_OW 72
39743: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39744: LD_ADDR_VAR 0 7
39748: PUSH
39749: LD_EXP 102
39753: PUSH
39754: LD_VAR 0 1
39758: ARRAY
39759: PPUSH
39760: LD_INT 25
39762: PUSH
39763: LD_INT 3
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PPUSH
39770: CALL_OW 72
39774: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39775: LD_ADDR_VAR 0 8
39779: PUSH
39780: LD_EXP 102
39784: PUSH
39785: LD_VAR 0 1
39789: ARRAY
39790: PPUSH
39791: LD_INT 25
39793: PUSH
39794: LD_INT 4
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 24
39803: PUSH
39804: LD_INT 251
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PPUSH
39815: CALL_OW 72
39819: ST_TO_ADDR
// if mc_scan [ base ] then
39820: LD_EXP 125
39824: PUSH
39825: LD_VAR 0 1
39829: ARRAY
39830: IFFALSE 40291
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39832: LD_ADDR_EXP 144
39836: PUSH
39837: LD_EXP 144
39841: PPUSH
39842: LD_VAR 0 1
39846: PPUSH
39847: LD_INT 4
39849: PPUSH
39850: CALL_OW 1
39854: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39855: LD_ADDR_VAR 0 12
39859: PUSH
39860: LD_EXP 102
39864: PUSH
39865: LD_VAR 0 1
39869: ARRAY
39870: PPUSH
39871: LD_INT 2
39873: PUSH
39874: LD_INT 30
39876: PUSH
39877: LD_INT 4
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 30
39886: PUSH
39887: LD_INT 5
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: LIST
39898: PPUSH
39899: CALL_OW 72
39903: ST_TO_ADDR
// if not b then
39904: LD_VAR 0 12
39908: NOT
39909: IFFALSE 39913
// exit ;
39911: GO 42979
// p := [ ] ;
39913: LD_ADDR_VAR 0 11
39917: PUSH
39918: EMPTY
39919: ST_TO_ADDR
// if sci >= 2 then
39920: LD_VAR 0 8
39924: PUSH
39925: LD_INT 2
39927: GREATEREQUAL
39928: IFFALSE 39959
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39930: LD_ADDR_VAR 0 8
39934: PUSH
39935: LD_VAR 0 8
39939: PUSH
39940: LD_INT 1
39942: ARRAY
39943: PUSH
39944: LD_VAR 0 8
39948: PUSH
39949: LD_INT 2
39951: ARRAY
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: ST_TO_ADDR
39957: GO 40020
// if sci = 1 then
39959: LD_VAR 0 8
39963: PUSH
39964: LD_INT 1
39966: EQUAL
39967: IFFALSE 39988
// sci := [ sci [ 1 ] ] else
39969: LD_ADDR_VAR 0 8
39973: PUSH
39974: LD_VAR 0 8
39978: PUSH
39979: LD_INT 1
39981: ARRAY
39982: PUSH
39983: EMPTY
39984: LIST
39985: ST_TO_ADDR
39986: GO 40020
// if sci = 0 then
39988: LD_VAR 0 8
39992: PUSH
39993: LD_INT 0
39995: EQUAL
39996: IFFALSE 40020
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39998: LD_ADDR_VAR 0 11
40002: PUSH
40003: LD_VAR 0 4
40007: PPUSH
40008: LD_INT 4
40010: PPUSH
40011: CALL 106273 0 2
40015: PUSH
40016: LD_INT 1
40018: ARRAY
40019: ST_TO_ADDR
// if eng > 4 then
40020: LD_VAR 0 6
40024: PUSH
40025: LD_INT 4
40027: GREATER
40028: IFFALSE 40074
// for i = eng downto 4 do
40030: LD_ADDR_VAR 0 3
40034: PUSH
40035: DOUBLE
40036: LD_VAR 0 6
40040: INC
40041: ST_TO_ADDR
40042: LD_INT 4
40044: PUSH
40045: FOR_DOWNTO
40046: IFFALSE 40072
// eng := eng diff eng [ i ] ;
40048: LD_ADDR_VAR 0 6
40052: PUSH
40053: LD_VAR 0 6
40057: PUSH
40058: LD_VAR 0 6
40062: PUSH
40063: LD_VAR 0 3
40067: ARRAY
40068: DIFF
40069: ST_TO_ADDR
40070: GO 40045
40072: POP
40073: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40074: LD_ADDR_VAR 0 4
40078: PUSH
40079: LD_VAR 0 4
40083: PUSH
40084: LD_VAR 0 5
40088: PUSH
40089: LD_VAR 0 6
40093: UNION
40094: PUSH
40095: LD_VAR 0 7
40099: UNION
40100: PUSH
40101: LD_VAR 0 8
40105: UNION
40106: DIFF
40107: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40108: LD_ADDR_VAR 0 13
40112: PUSH
40113: LD_EXP 102
40117: PUSH
40118: LD_VAR 0 1
40122: ARRAY
40123: PPUSH
40124: LD_INT 2
40126: PUSH
40127: LD_INT 30
40129: PUSH
40130: LD_INT 32
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 30
40139: PUSH
40140: LD_INT 31
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: LIST
40151: PPUSH
40152: CALL_OW 72
40156: PUSH
40157: LD_EXP 102
40161: PUSH
40162: LD_VAR 0 1
40166: ARRAY
40167: PPUSH
40168: LD_INT 2
40170: PUSH
40171: LD_INT 30
40173: PUSH
40174: LD_INT 4
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 30
40183: PUSH
40184: LD_INT 5
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: LIST
40195: PPUSH
40196: CALL_OW 72
40200: PUSH
40201: LD_INT 6
40203: MUL
40204: PLUS
40205: ST_TO_ADDR
// if bcount < tmp then
40206: LD_VAR 0 13
40210: PUSH
40211: LD_VAR 0 4
40215: LESS
40216: IFFALSE 40262
// for i = tmp downto bcount do
40218: LD_ADDR_VAR 0 3
40222: PUSH
40223: DOUBLE
40224: LD_VAR 0 4
40228: INC
40229: ST_TO_ADDR
40230: LD_VAR 0 13
40234: PUSH
40235: FOR_DOWNTO
40236: IFFALSE 40260
// tmp := Delete ( tmp , tmp ) ;
40238: LD_ADDR_VAR 0 4
40242: PUSH
40243: LD_VAR 0 4
40247: PPUSH
40248: LD_VAR 0 4
40252: PPUSH
40253: CALL_OW 3
40257: ST_TO_ADDR
40258: GO 40235
40260: POP
40261: POP
// result := [ tmp , 0 , 0 , p ] ;
40262: LD_ADDR_VAR 0 2
40266: PUSH
40267: LD_VAR 0 4
40271: PUSH
40272: LD_INT 0
40274: PUSH
40275: LD_INT 0
40277: PUSH
40278: LD_VAR 0 11
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: LIST
40287: LIST
40288: ST_TO_ADDR
// exit ;
40289: GO 42979
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40291: LD_EXP 102
40295: PUSH
40296: LD_VAR 0 1
40300: ARRAY
40301: PPUSH
40302: LD_INT 2
40304: PUSH
40305: LD_INT 30
40307: PUSH
40308: LD_INT 6
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 30
40317: PUSH
40318: LD_INT 7
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 30
40327: PUSH
40328: LD_INT 8
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: LIST
40339: LIST
40340: PPUSH
40341: CALL_OW 72
40345: NOT
40346: PUSH
40347: LD_EXP 102
40351: PUSH
40352: LD_VAR 0 1
40356: ARRAY
40357: PPUSH
40358: LD_INT 30
40360: PUSH
40361: LD_INT 3
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PPUSH
40368: CALL_OW 72
40372: NOT
40373: AND
40374: IFFALSE 40446
// begin if eng = tmp then
40376: LD_VAR 0 6
40380: PUSH
40381: LD_VAR 0 4
40385: EQUAL
40386: IFFALSE 40390
// exit ;
40388: GO 42979
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40390: LD_ADDR_EXP 144
40394: PUSH
40395: LD_EXP 144
40399: PPUSH
40400: LD_VAR 0 1
40404: PPUSH
40405: LD_INT 1
40407: PPUSH
40408: CALL_OW 1
40412: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40413: LD_ADDR_VAR 0 2
40417: PUSH
40418: LD_INT 0
40420: PUSH
40421: LD_VAR 0 4
40425: PUSH
40426: LD_VAR 0 6
40430: DIFF
40431: PUSH
40432: LD_INT 0
40434: PUSH
40435: LD_INT 0
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: ST_TO_ADDR
// exit ;
40444: GO 42979
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40446: LD_EXP 129
40450: PUSH
40451: LD_EXP 128
40455: PUSH
40456: LD_VAR 0 1
40460: ARRAY
40461: ARRAY
40462: PUSH
40463: LD_EXP 102
40467: PUSH
40468: LD_VAR 0 1
40472: ARRAY
40473: PPUSH
40474: LD_INT 2
40476: PUSH
40477: LD_INT 30
40479: PUSH
40480: LD_INT 6
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 30
40489: PUSH
40490: LD_INT 7
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 30
40499: PUSH
40500: LD_INT 8
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: PPUSH
40513: CALL_OW 72
40517: AND
40518: PUSH
40519: LD_EXP 102
40523: PUSH
40524: LD_VAR 0 1
40528: ARRAY
40529: PPUSH
40530: LD_INT 30
40532: PUSH
40533: LD_INT 3
40535: PUSH
40536: EMPTY
40537: LIST
40538: LIST
40539: PPUSH
40540: CALL_OW 72
40544: NOT
40545: AND
40546: IFFALSE 40760
// begin if sci >= 6 then
40548: LD_VAR 0 8
40552: PUSH
40553: LD_INT 6
40555: GREATEREQUAL
40556: IFFALSE 40560
// exit ;
40558: GO 42979
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40560: LD_ADDR_EXP 144
40564: PUSH
40565: LD_EXP 144
40569: PPUSH
40570: LD_VAR 0 1
40574: PPUSH
40575: LD_INT 2
40577: PPUSH
40578: CALL_OW 1
40582: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40583: LD_ADDR_VAR 0 9
40587: PUSH
40588: LD_VAR 0 4
40592: PUSH
40593: LD_VAR 0 8
40597: DIFF
40598: PPUSH
40599: LD_INT 4
40601: PPUSH
40602: CALL 106273 0 2
40606: ST_TO_ADDR
// p := [ ] ;
40607: LD_ADDR_VAR 0 11
40611: PUSH
40612: EMPTY
40613: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40614: LD_VAR 0 8
40618: PUSH
40619: LD_INT 6
40621: LESS
40622: PUSH
40623: LD_VAR 0 9
40627: PUSH
40628: LD_INT 6
40630: GREATER
40631: AND
40632: IFFALSE 40713
// begin for i = 1 to 6 - sci do
40634: LD_ADDR_VAR 0 3
40638: PUSH
40639: DOUBLE
40640: LD_INT 1
40642: DEC
40643: ST_TO_ADDR
40644: LD_INT 6
40646: PUSH
40647: LD_VAR 0 8
40651: MINUS
40652: PUSH
40653: FOR_TO
40654: IFFALSE 40709
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40656: LD_ADDR_VAR 0 11
40660: PUSH
40661: LD_VAR 0 11
40665: PPUSH
40666: LD_VAR 0 11
40670: PUSH
40671: LD_INT 1
40673: PLUS
40674: PPUSH
40675: LD_VAR 0 9
40679: PUSH
40680: LD_INT 1
40682: ARRAY
40683: PPUSH
40684: CALL_OW 2
40688: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40689: LD_ADDR_VAR 0 9
40693: PUSH
40694: LD_VAR 0 9
40698: PPUSH
40699: LD_INT 1
40701: PPUSH
40702: CALL_OW 3
40706: ST_TO_ADDR
// end ;
40707: GO 40653
40709: POP
40710: POP
// end else
40711: GO 40733
// if sort then
40713: LD_VAR 0 9
40717: IFFALSE 40733
// p := sort [ 1 ] ;
40719: LD_ADDR_VAR 0 11
40723: PUSH
40724: LD_VAR 0 9
40728: PUSH
40729: LD_INT 1
40731: ARRAY
40732: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40733: LD_ADDR_VAR 0 2
40737: PUSH
40738: LD_INT 0
40740: PUSH
40741: LD_INT 0
40743: PUSH
40744: LD_INT 0
40746: PUSH
40747: LD_VAR 0 11
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: ST_TO_ADDR
// exit ;
40758: GO 42979
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40760: LD_EXP 129
40764: PUSH
40765: LD_EXP 128
40769: PUSH
40770: LD_VAR 0 1
40774: ARRAY
40775: ARRAY
40776: PUSH
40777: LD_EXP 102
40781: PUSH
40782: LD_VAR 0 1
40786: ARRAY
40787: PPUSH
40788: LD_INT 2
40790: PUSH
40791: LD_INT 30
40793: PUSH
40794: LD_INT 6
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 30
40803: PUSH
40804: LD_INT 7
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 30
40813: PUSH
40814: LD_INT 8
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: LIST
40825: LIST
40826: PPUSH
40827: CALL_OW 72
40831: AND
40832: PUSH
40833: LD_EXP 102
40837: PUSH
40838: LD_VAR 0 1
40842: ARRAY
40843: PPUSH
40844: LD_INT 30
40846: PUSH
40847: LD_INT 3
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PPUSH
40854: CALL_OW 72
40858: AND
40859: IFFALSE 41593
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40861: LD_ADDR_EXP 144
40865: PUSH
40866: LD_EXP 144
40870: PPUSH
40871: LD_VAR 0 1
40875: PPUSH
40876: LD_INT 3
40878: PPUSH
40879: CALL_OW 1
40883: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40884: LD_ADDR_VAR 0 2
40888: PUSH
40889: LD_INT 0
40891: PUSH
40892: LD_INT 0
40894: PUSH
40895: LD_INT 0
40897: PUSH
40898: LD_INT 0
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: ST_TO_ADDR
// if not eng then
40907: LD_VAR 0 6
40911: NOT
40912: IFFALSE 40975
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40914: LD_ADDR_VAR 0 11
40918: PUSH
40919: LD_VAR 0 4
40923: PPUSH
40924: LD_INT 2
40926: PPUSH
40927: CALL 106273 0 2
40931: PUSH
40932: LD_INT 1
40934: ARRAY
40935: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40936: LD_ADDR_VAR 0 2
40940: PUSH
40941: LD_VAR 0 2
40945: PPUSH
40946: LD_INT 2
40948: PPUSH
40949: LD_VAR 0 11
40953: PPUSH
40954: CALL_OW 1
40958: ST_TO_ADDR
// tmp := tmp diff p ;
40959: LD_ADDR_VAR 0 4
40963: PUSH
40964: LD_VAR 0 4
40968: PUSH
40969: LD_VAR 0 11
40973: DIFF
40974: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40975: LD_VAR 0 4
40979: PUSH
40980: LD_VAR 0 8
40984: PUSH
40985: LD_INT 6
40987: LESS
40988: AND
40989: IFFALSE 41177
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40991: LD_ADDR_VAR 0 9
40995: PUSH
40996: LD_VAR 0 4
41000: PUSH
41001: LD_VAR 0 8
41005: PUSH
41006: LD_VAR 0 7
41010: UNION
41011: DIFF
41012: PPUSH
41013: LD_INT 4
41015: PPUSH
41016: CALL 106273 0 2
41020: ST_TO_ADDR
// p := [ ] ;
41021: LD_ADDR_VAR 0 11
41025: PUSH
41026: EMPTY
41027: ST_TO_ADDR
// if sort then
41028: LD_VAR 0 9
41032: IFFALSE 41148
// for i = 1 to 6 - sci do
41034: LD_ADDR_VAR 0 3
41038: PUSH
41039: DOUBLE
41040: LD_INT 1
41042: DEC
41043: ST_TO_ADDR
41044: LD_INT 6
41046: PUSH
41047: LD_VAR 0 8
41051: MINUS
41052: PUSH
41053: FOR_TO
41054: IFFALSE 41146
// begin if i = sort then
41056: LD_VAR 0 3
41060: PUSH
41061: LD_VAR 0 9
41065: EQUAL
41066: IFFALSE 41070
// break ;
41068: GO 41146
// if GetClass ( i ) = 4 then
41070: LD_VAR 0 3
41074: PPUSH
41075: CALL_OW 257
41079: PUSH
41080: LD_INT 4
41082: EQUAL
41083: IFFALSE 41087
// continue ;
41085: GO 41053
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41087: LD_ADDR_VAR 0 11
41091: PUSH
41092: LD_VAR 0 11
41096: PPUSH
41097: LD_VAR 0 11
41101: PUSH
41102: LD_INT 1
41104: PLUS
41105: PPUSH
41106: LD_VAR 0 9
41110: PUSH
41111: LD_VAR 0 3
41115: ARRAY
41116: PPUSH
41117: CALL_OW 2
41121: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41122: LD_ADDR_VAR 0 4
41126: PUSH
41127: LD_VAR 0 4
41131: PUSH
41132: LD_VAR 0 9
41136: PUSH
41137: LD_VAR 0 3
41141: ARRAY
41142: DIFF
41143: ST_TO_ADDR
// end ;
41144: GO 41053
41146: POP
41147: POP
// if p then
41148: LD_VAR 0 11
41152: IFFALSE 41177
// result := Replace ( result , 4 , p ) ;
41154: LD_ADDR_VAR 0 2
41158: PUSH
41159: LD_VAR 0 2
41163: PPUSH
41164: LD_INT 4
41166: PPUSH
41167: LD_VAR 0 11
41171: PPUSH
41172: CALL_OW 1
41176: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41177: LD_VAR 0 4
41181: PUSH
41182: LD_VAR 0 7
41186: PUSH
41187: LD_INT 6
41189: LESS
41190: AND
41191: IFFALSE 41379
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41193: LD_ADDR_VAR 0 9
41197: PUSH
41198: LD_VAR 0 4
41202: PUSH
41203: LD_VAR 0 8
41207: PUSH
41208: LD_VAR 0 7
41212: UNION
41213: DIFF
41214: PPUSH
41215: LD_INT 3
41217: PPUSH
41218: CALL 106273 0 2
41222: ST_TO_ADDR
// p := [ ] ;
41223: LD_ADDR_VAR 0 11
41227: PUSH
41228: EMPTY
41229: ST_TO_ADDR
// if sort then
41230: LD_VAR 0 9
41234: IFFALSE 41350
// for i = 1 to 6 - mech do
41236: LD_ADDR_VAR 0 3
41240: PUSH
41241: DOUBLE
41242: LD_INT 1
41244: DEC
41245: ST_TO_ADDR
41246: LD_INT 6
41248: PUSH
41249: LD_VAR 0 7
41253: MINUS
41254: PUSH
41255: FOR_TO
41256: IFFALSE 41348
// begin if i = sort then
41258: LD_VAR 0 3
41262: PUSH
41263: LD_VAR 0 9
41267: EQUAL
41268: IFFALSE 41272
// break ;
41270: GO 41348
// if GetClass ( i ) = 3 then
41272: LD_VAR 0 3
41276: PPUSH
41277: CALL_OW 257
41281: PUSH
41282: LD_INT 3
41284: EQUAL
41285: IFFALSE 41289
// continue ;
41287: GO 41255
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41289: LD_ADDR_VAR 0 11
41293: PUSH
41294: LD_VAR 0 11
41298: PPUSH
41299: LD_VAR 0 11
41303: PUSH
41304: LD_INT 1
41306: PLUS
41307: PPUSH
41308: LD_VAR 0 9
41312: PUSH
41313: LD_VAR 0 3
41317: ARRAY
41318: PPUSH
41319: CALL_OW 2
41323: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41324: LD_ADDR_VAR 0 4
41328: PUSH
41329: LD_VAR 0 4
41333: PUSH
41334: LD_VAR 0 9
41338: PUSH
41339: LD_VAR 0 3
41343: ARRAY
41344: DIFF
41345: ST_TO_ADDR
// end ;
41346: GO 41255
41348: POP
41349: POP
// if p then
41350: LD_VAR 0 11
41354: IFFALSE 41379
// result := Replace ( result , 3 , p ) ;
41356: LD_ADDR_VAR 0 2
41360: PUSH
41361: LD_VAR 0 2
41365: PPUSH
41366: LD_INT 3
41368: PPUSH
41369: LD_VAR 0 11
41373: PPUSH
41374: CALL_OW 1
41378: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41379: LD_VAR 0 4
41383: PUSH
41384: LD_INT 6
41386: GREATER
41387: PUSH
41388: LD_VAR 0 6
41392: PUSH
41393: LD_INT 6
41395: LESS
41396: AND
41397: IFFALSE 41591
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41399: LD_ADDR_VAR 0 9
41403: PUSH
41404: LD_VAR 0 4
41408: PUSH
41409: LD_VAR 0 8
41413: PUSH
41414: LD_VAR 0 7
41418: UNION
41419: PUSH
41420: LD_VAR 0 6
41424: UNION
41425: DIFF
41426: PPUSH
41427: LD_INT 2
41429: PPUSH
41430: CALL 106273 0 2
41434: ST_TO_ADDR
// p := [ ] ;
41435: LD_ADDR_VAR 0 11
41439: PUSH
41440: EMPTY
41441: ST_TO_ADDR
// if sort then
41442: LD_VAR 0 9
41446: IFFALSE 41562
// for i = 1 to 6 - eng do
41448: LD_ADDR_VAR 0 3
41452: PUSH
41453: DOUBLE
41454: LD_INT 1
41456: DEC
41457: ST_TO_ADDR
41458: LD_INT 6
41460: PUSH
41461: LD_VAR 0 6
41465: MINUS
41466: PUSH
41467: FOR_TO
41468: IFFALSE 41560
// begin if i = sort then
41470: LD_VAR 0 3
41474: PUSH
41475: LD_VAR 0 9
41479: EQUAL
41480: IFFALSE 41484
// break ;
41482: GO 41560
// if GetClass ( i ) = 2 then
41484: LD_VAR 0 3
41488: PPUSH
41489: CALL_OW 257
41493: PUSH
41494: LD_INT 2
41496: EQUAL
41497: IFFALSE 41501
// continue ;
41499: GO 41467
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41501: LD_ADDR_VAR 0 11
41505: PUSH
41506: LD_VAR 0 11
41510: PPUSH
41511: LD_VAR 0 11
41515: PUSH
41516: LD_INT 1
41518: PLUS
41519: PPUSH
41520: LD_VAR 0 9
41524: PUSH
41525: LD_VAR 0 3
41529: ARRAY
41530: PPUSH
41531: CALL_OW 2
41535: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41536: LD_ADDR_VAR 0 4
41540: PUSH
41541: LD_VAR 0 4
41545: PUSH
41546: LD_VAR 0 9
41550: PUSH
41551: LD_VAR 0 3
41555: ARRAY
41556: DIFF
41557: ST_TO_ADDR
// end ;
41558: GO 41467
41560: POP
41561: POP
// if p then
41562: LD_VAR 0 11
41566: IFFALSE 41591
// result := Replace ( result , 2 , p ) ;
41568: LD_ADDR_VAR 0 2
41572: PUSH
41573: LD_VAR 0 2
41577: PPUSH
41578: LD_INT 2
41580: PPUSH
41581: LD_VAR 0 11
41585: PPUSH
41586: CALL_OW 1
41590: ST_TO_ADDR
// end ; exit ;
41591: GO 42979
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41593: LD_EXP 129
41597: PUSH
41598: LD_EXP 128
41602: PUSH
41603: LD_VAR 0 1
41607: ARRAY
41608: ARRAY
41609: NOT
41610: PUSH
41611: LD_EXP 102
41615: PUSH
41616: LD_VAR 0 1
41620: ARRAY
41621: PPUSH
41622: LD_INT 30
41624: PUSH
41625: LD_INT 3
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PPUSH
41632: CALL_OW 72
41636: AND
41637: PUSH
41638: LD_EXP 107
41642: PUSH
41643: LD_VAR 0 1
41647: ARRAY
41648: AND
41649: IFFALSE 42257
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41651: LD_ADDR_EXP 144
41655: PUSH
41656: LD_EXP 144
41660: PPUSH
41661: LD_VAR 0 1
41665: PPUSH
41666: LD_INT 5
41668: PPUSH
41669: CALL_OW 1
41673: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41674: LD_ADDR_VAR 0 2
41678: PUSH
41679: LD_INT 0
41681: PUSH
41682: LD_INT 0
41684: PUSH
41685: LD_INT 0
41687: PUSH
41688: LD_INT 0
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: ST_TO_ADDR
// if sci > 1 then
41697: LD_VAR 0 8
41701: PUSH
41702: LD_INT 1
41704: GREATER
41705: IFFALSE 41733
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41707: LD_ADDR_VAR 0 4
41711: PUSH
41712: LD_VAR 0 4
41716: PUSH
41717: LD_VAR 0 8
41721: PUSH
41722: LD_VAR 0 8
41726: PUSH
41727: LD_INT 1
41729: ARRAY
41730: DIFF
41731: DIFF
41732: ST_TO_ADDR
// if tmp and not sci then
41733: LD_VAR 0 4
41737: PUSH
41738: LD_VAR 0 8
41742: NOT
41743: AND
41744: IFFALSE 41813
// begin sort := SortBySkill ( tmp , 4 ) ;
41746: LD_ADDR_VAR 0 9
41750: PUSH
41751: LD_VAR 0 4
41755: PPUSH
41756: LD_INT 4
41758: PPUSH
41759: CALL 106273 0 2
41763: ST_TO_ADDR
// if sort then
41764: LD_VAR 0 9
41768: IFFALSE 41784
// p := sort [ 1 ] ;
41770: LD_ADDR_VAR 0 11
41774: PUSH
41775: LD_VAR 0 9
41779: PUSH
41780: LD_INT 1
41782: ARRAY
41783: ST_TO_ADDR
// if p then
41784: LD_VAR 0 11
41788: IFFALSE 41813
// result := Replace ( result , 4 , p ) ;
41790: LD_ADDR_VAR 0 2
41794: PUSH
41795: LD_VAR 0 2
41799: PPUSH
41800: LD_INT 4
41802: PPUSH
41803: LD_VAR 0 11
41807: PPUSH
41808: CALL_OW 1
41812: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41813: LD_ADDR_VAR 0 4
41817: PUSH
41818: LD_VAR 0 4
41822: PUSH
41823: LD_VAR 0 7
41827: DIFF
41828: ST_TO_ADDR
// if tmp and mech < 6 then
41829: LD_VAR 0 4
41833: PUSH
41834: LD_VAR 0 7
41838: PUSH
41839: LD_INT 6
41841: LESS
41842: AND
41843: IFFALSE 42031
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41845: LD_ADDR_VAR 0 9
41849: PUSH
41850: LD_VAR 0 4
41854: PUSH
41855: LD_VAR 0 8
41859: PUSH
41860: LD_VAR 0 7
41864: UNION
41865: DIFF
41866: PPUSH
41867: LD_INT 3
41869: PPUSH
41870: CALL 106273 0 2
41874: ST_TO_ADDR
// p := [ ] ;
41875: LD_ADDR_VAR 0 11
41879: PUSH
41880: EMPTY
41881: ST_TO_ADDR
// if sort then
41882: LD_VAR 0 9
41886: IFFALSE 42002
// for i = 1 to 6 - mech do
41888: LD_ADDR_VAR 0 3
41892: PUSH
41893: DOUBLE
41894: LD_INT 1
41896: DEC
41897: ST_TO_ADDR
41898: LD_INT 6
41900: PUSH
41901: LD_VAR 0 7
41905: MINUS
41906: PUSH
41907: FOR_TO
41908: IFFALSE 42000
// begin if i = sort then
41910: LD_VAR 0 3
41914: PUSH
41915: LD_VAR 0 9
41919: EQUAL
41920: IFFALSE 41924
// break ;
41922: GO 42000
// if GetClass ( i ) = 3 then
41924: LD_VAR 0 3
41928: PPUSH
41929: CALL_OW 257
41933: PUSH
41934: LD_INT 3
41936: EQUAL
41937: IFFALSE 41941
// continue ;
41939: GO 41907
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41941: LD_ADDR_VAR 0 11
41945: PUSH
41946: LD_VAR 0 11
41950: PPUSH
41951: LD_VAR 0 11
41955: PUSH
41956: LD_INT 1
41958: PLUS
41959: PPUSH
41960: LD_VAR 0 9
41964: PUSH
41965: LD_VAR 0 3
41969: ARRAY
41970: PPUSH
41971: CALL_OW 2
41975: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41976: LD_ADDR_VAR 0 4
41980: PUSH
41981: LD_VAR 0 4
41985: PUSH
41986: LD_VAR 0 9
41990: PUSH
41991: LD_VAR 0 3
41995: ARRAY
41996: DIFF
41997: ST_TO_ADDR
// end ;
41998: GO 41907
42000: POP
42001: POP
// if p then
42002: LD_VAR 0 11
42006: IFFALSE 42031
// result := Replace ( result , 3 , p ) ;
42008: LD_ADDR_VAR 0 2
42012: PUSH
42013: LD_VAR 0 2
42017: PPUSH
42018: LD_INT 3
42020: PPUSH
42021: LD_VAR 0 11
42025: PPUSH
42026: CALL_OW 1
42030: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42031: LD_ADDR_VAR 0 4
42035: PUSH
42036: LD_VAR 0 4
42040: PUSH
42041: LD_VAR 0 6
42045: DIFF
42046: ST_TO_ADDR
// if tmp and eng < 6 then
42047: LD_VAR 0 4
42051: PUSH
42052: LD_VAR 0 6
42056: PUSH
42057: LD_INT 6
42059: LESS
42060: AND
42061: IFFALSE 42255
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42063: LD_ADDR_VAR 0 9
42067: PUSH
42068: LD_VAR 0 4
42072: PUSH
42073: LD_VAR 0 8
42077: PUSH
42078: LD_VAR 0 7
42082: UNION
42083: PUSH
42084: LD_VAR 0 6
42088: UNION
42089: DIFF
42090: PPUSH
42091: LD_INT 2
42093: PPUSH
42094: CALL 106273 0 2
42098: ST_TO_ADDR
// p := [ ] ;
42099: LD_ADDR_VAR 0 11
42103: PUSH
42104: EMPTY
42105: ST_TO_ADDR
// if sort then
42106: LD_VAR 0 9
42110: IFFALSE 42226
// for i = 1 to 6 - eng do
42112: LD_ADDR_VAR 0 3
42116: PUSH
42117: DOUBLE
42118: LD_INT 1
42120: DEC
42121: ST_TO_ADDR
42122: LD_INT 6
42124: PUSH
42125: LD_VAR 0 6
42129: MINUS
42130: PUSH
42131: FOR_TO
42132: IFFALSE 42224
// begin if i = sort then
42134: LD_VAR 0 3
42138: PUSH
42139: LD_VAR 0 9
42143: EQUAL
42144: IFFALSE 42148
// break ;
42146: GO 42224
// if GetClass ( i ) = 2 then
42148: LD_VAR 0 3
42152: PPUSH
42153: CALL_OW 257
42157: PUSH
42158: LD_INT 2
42160: EQUAL
42161: IFFALSE 42165
// continue ;
42163: GO 42131
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42165: LD_ADDR_VAR 0 11
42169: PUSH
42170: LD_VAR 0 11
42174: PPUSH
42175: LD_VAR 0 11
42179: PUSH
42180: LD_INT 1
42182: PLUS
42183: PPUSH
42184: LD_VAR 0 9
42188: PUSH
42189: LD_VAR 0 3
42193: ARRAY
42194: PPUSH
42195: CALL_OW 2
42199: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42200: LD_ADDR_VAR 0 4
42204: PUSH
42205: LD_VAR 0 4
42209: PUSH
42210: LD_VAR 0 9
42214: PUSH
42215: LD_VAR 0 3
42219: ARRAY
42220: DIFF
42221: ST_TO_ADDR
// end ;
42222: GO 42131
42224: POP
42225: POP
// if p then
42226: LD_VAR 0 11
42230: IFFALSE 42255
// result := Replace ( result , 2 , p ) ;
42232: LD_ADDR_VAR 0 2
42236: PUSH
42237: LD_VAR 0 2
42241: PPUSH
42242: LD_INT 2
42244: PPUSH
42245: LD_VAR 0 11
42249: PPUSH
42250: CALL_OW 1
42254: ST_TO_ADDR
// end ; exit ;
42255: GO 42979
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42257: LD_EXP 129
42261: PUSH
42262: LD_EXP 128
42266: PUSH
42267: LD_VAR 0 1
42271: ARRAY
42272: ARRAY
42273: NOT
42274: PUSH
42275: LD_EXP 102
42279: PUSH
42280: LD_VAR 0 1
42284: ARRAY
42285: PPUSH
42286: LD_INT 30
42288: PUSH
42289: LD_INT 3
42291: PUSH
42292: EMPTY
42293: LIST
42294: LIST
42295: PPUSH
42296: CALL_OW 72
42300: AND
42301: PUSH
42302: LD_EXP 107
42306: PUSH
42307: LD_VAR 0 1
42311: ARRAY
42312: NOT
42313: AND
42314: IFFALSE 42979
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42316: LD_ADDR_EXP 144
42320: PUSH
42321: LD_EXP 144
42325: PPUSH
42326: LD_VAR 0 1
42330: PPUSH
42331: LD_INT 6
42333: PPUSH
42334: CALL_OW 1
42338: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42339: LD_ADDR_VAR 0 2
42343: PUSH
42344: LD_INT 0
42346: PUSH
42347: LD_INT 0
42349: PUSH
42350: LD_INT 0
42352: PUSH
42353: LD_INT 0
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: LIST
42360: LIST
42361: ST_TO_ADDR
// if sci >= 1 then
42362: LD_VAR 0 8
42366: PUSH
42367: LD_INT 1
42369: GREATEREQUAL
42370: IFFALSE 42392
// tmp := tmp diff sci [ 1 ] ;
42372: LD_ADDR_VAR 0 4
42376: PUSH
42377: LD_VAR 0 4
42381: PUSH
42382: LD_VAR 0 8
42386: PUSH
42387: LD_INT 1
42389: ARRAY
42390: DIFF
42391: ST_TO_ADDR
// if tmp and not sci then
42392: LD_VAR 0 4
42396: PUSH
42397: LD_VAR 0 8
42401: NOT
42402: AND
42403: IFFALSE 42472
// begin sort := SortBySkill ( tmp , 4 ) ;
42405: LD_ADDR_VAR 0 9
42409: PUSH
42410: LD_VAR 0 4
42414: PPUSH
42415: LD_INT 4
42417: PPUSH
42418: CALL 106273 0 2
42422: ST_TO_ADDR
// if sort then
42423: LD_VAR 0 9
42427: IFFALSE 42443
// p := sort [ 1 ] ;
42429: LD_ADDR_VAR 0 11
42433: PUSH
42434: LD_VAR 0 9
42438: PUSH
42439: LD_INT 1
42441: ARRAY
42442: ST_TO_ADDR
// if p then
42443: LD_VAR 0 11
42447: IFFALSE 42472
// result := Replace ( result , 4 , p ) ;
42449: LD_ADDR_VAR 0 2
42453: PUSH
42454: LD_VAR 0 2
42458: PPUSH
42459: LD_INT 4
42461: PPUSH
42462: LD_VAR 0 11
42466: PPUSH
42467: CALL_OW 1
42471: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42472: LD_ADDR_VAR 0 4
42476: PUSH
42477: LD_VAR 0 4
42481: PUSH
42482: LD_VAR 0 7
42486: DIFF
42487: ST_TO_ADDR
// if tmp and mech < 6 then
42488: LD_VAR 0 4
42492: PUSH
42493: LD_VAR 0 7
42497: PUSH
42498: LD_INT 6
42500: LESS
42501: AND
42502: IFFALSE 42684
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42504: LD_ADDR_VAR 0 9
42508: PUSH
42509: LD_VAR 0 4
42513: PUSH
42514: LD_VAR 0 7
42518: DIFF
42519: PPUSH
42520: LD_INT 3
42522: PPUSH
42523: CALL 106273 0 2
42527: ST_TO_ADDR
// p := [ ] ;
42528: LD_ADDR_VAR 0 11
42532: PUSH
42533: EMPTY
42534: ST_TO_ADDR
// if sort then
42535: LD_VAR 0 9
42539: IFFALSE 42655
// for i = 1 to 6 - mech do
42541: LD_ADDR_VAR 0 3
42545: PUSH
42546: DOUBLE
42547: LD_INT 1
42549: DEC
42550: ST_TO_ADDR
42551: LD_INT 6
42553: PUSH
42554: LD_VAR 0 7
42558: MINUS
42559: PUSH
42560: FOR_TO
42561: IFFALSE 42653
// begin if i = sort then
42563: LD_VAR 0 3
42567: PUSH
42568: LD_VAR 0 9
42572: EQUAL
42573: IFFALSE 42577
// break ;
42575: GO 42653
// if GetClass ( i ) = 3 then
42577: LD_VAR 0 3
42581: PPUSH
42582: CALL_OW 257
42586: PUSH
42587: LD_INT 3
42589: EQUAL
42590: IFFALSE 42594
// continue ;
42592: GO 42560
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42594: LD_ADDR_VAR 0 11
42598: PUSH
42599: LD_VAR 0 11
42603: PPUSH
42604: LD_VAR 0 11
42608: PUSH
42609: LD_INT 1
42611: PLUS
42612: PPUSH
42613: LD_VAR 0 9
42617: PUSH
42618: LD_VAR 0 3
42622: ARRAY
42623: PPUSH
42624: CALL_OW 2
42628: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42629: LD_ADDR_VAR 0 4
42633: PUSH
42634: LD_VAR 0 4
42638: PUSH
42639: LD_VAR 0 9
42643: PUSH
42644: LD_VAR 0 3
42648: ARRAY
42649: DIFF
42650: ST_TO_ADDR
// end ;
42651: GO 42560
42653: POP
42654: POP
// if p then
42655: LD_VAR 0 11
42659: IFFALSE 42684
// result := Replace ( result , 3 , p ) ;
42661: LD_ADDR_VAR 0 2
42665: PUSH
42666: LD_VAR 0 2
42670: PPUSH
42671: LD_INT 3
42673: PPUSH
42674: LD_VAR 0 11
42678: PPUSH
42679: CALL_OW 1
42683: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42684: LD_ADDR_VAR 0 4
42688: PUSH
42689: LD_VAR 0 4
42693: PUSH
42694: LD_VAR 0 6
42698: DIFF
42699: ST_TO_ADDR
// if tmp and eng < 4 then
42700: LD_VAR 0 4
42704: PUSH
42705: LD_VAR 0 6
42709: PUSH
42710: LD_INT 4
42712: LESS
42713: AND
42714: IFFALSE 42904
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42716: LD_ADDR_VAR 0 9
42720: PUSH
42721: LD_VAR 0 4
42725: PUSH
42726: LD_VAR 0 7
42730: PUSH
42731: LD_VAR 0 6
42735: UNION
42736: DIFF
42737: PPUSH
42738: LD_INT 2
42740: PPUSH
42741: CALL 106273 0 2
42745: ST_TO_ADDR
// p := [ ] ;
42746: LD_ADDR_VAR 0 11
42750: PUSH
42751: EMPTY
42752: ST_TO_ADDR
// if sort then
42753: LD_VAR 0 9
42757: IFFALSE 42873
// for i = 1 to 4 - eng do
42759: LD_ADDR_VAR 0 3
42763: PUSH
42764: DOUBLE
42765: LD_INT 1
42767: DEC
42768: ST_TO_ADDR
42769: LD_INT 4
42771: PUSH
42772: LD_VAR 0 6
42776: MINUS
42777: PUSH
42778: FOR_TO
42779: IFFALSE 42871
// begin if i = sort then
42781: LD_VAR 0 3
42785: PUSH
42786: LD_VAR 0 9
42790: EQUAL
42791: IFFALSE 42795
// break ;
42793: GO 42871
// if GetClass ( i ) = 2 then
42795: LD_VAR 0 3
42799: PPUSH
42800: CALL_OW 257
42804: PUSH
42805: LD_INT 2
42807: EQUAL
42808: IFFALSE 42812
// continue ;
42810: GO 42778
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42812: LD_ADDR_VAR 0 11
42816: PUSH
42817: LD_VAR 0 11
42821: PPUSH
42822: LD_VAR 0 11
42826: PUSH
42827: LD_INT 1
42829: PLUS
42830: PPUSH
42831: LD_VAR 0 9
42835: PUSH
42836: LD_VAR 0 3
42840: ARRAY
42841: PPUSH
42842: CALL_OW 2
42846: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42847: LD_ADDR_VAR 0 4
42851: PUSH
42852: LD_VAR 0 4
42856: PUSH
42857: LD_VAR 0 9
42861: PUSH
42862: LD_VAR 0 3
42866: ARRAY
42867: DIFF
42868: ST_TO_ADDR
// end ;
42869: GO 42778
42871: POP
42872: POP
// if p then
42873: LD_VAR 0 11
42877: IFFALSE 42902
// result := Replace ( result , 2 , p ) ;
42879: LD_ADDR_VAR 0 2
42883: PUSH
42884: LD_VAR 0 2
42888: PPUSH
42889: LD_INT 2
42891: PPUSH
42892: LD_VAR 0 11
42896: PPUSH
42897: CALL_OW 1
42901: ST_TO_ADDR
// end else
42902: GO 42948
// for i = eng downto 5 do
42904: LD_ADDR_VAR 0 3
42908: PUSH
42909: DOUBLE
42910: LD_VAR 0 6
42914: INC
42915: ST_TO_ADDR
42916: LD_INT 5
42918: PUSH
42919: FOR_DOWNTO
42920: IFFALSE 42946
// tmp := tmp union eng [ i ] ;
42922: LD_ADDR_VAR 0 4
42926: PUSH
42927: LD_VAR 0 4
42931: PUSH
42932: LD_VAR 0 6
42936: PUSH
42937: LD_VAR 0 3
42941: ARRAY
42942: UNION
42943: ST_TO_ADDR
42944: GO 42919
42946: POP
42947: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42948: LD_ADDR_VAR 0 2
42952: PUSH
42953: LD_VAR 0 2
42957: PPUSH
42958: LD_INT 1
42960: PPUSH
42961: LD_VAR 0 4
42965: PUSH
42966: LD_VAR 0 5
42970: DIFF
42971: PPUSH
42972: CALL_OW 1
42976: ST_TO_ADDR
// exit ;
42977: GO 42979
// end ; end ;
42979: LD_VAR 0 2
42983: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42984: LD_INT 0
42986: PPUSH
42987: PPUSH
42988: PPUSH
// if not mc_bases then
42989: LD_EXP 102
42993: NOT
42994: IFFALSE 42998
// exit ;
42996: GO 43104
// for i = 1 to mc_bases do
42998: LD_ADDR_VAR 0 2
43002: PUSH
43003: DOUBLE
43004: LD_INT 1
43006: DEC
43007: ST_TO_ADDR
43008: LD_EXP 102
43012: PUSH
43013: FOR_TO
43014: IFFALSE 43095
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43016: LD_ADDR_VAR 0 3
43020: PUSH
43021: LD_EXP 102
43025: PUSH
43026: LD_VAR 0 2
43030: ARRAY
43031: PPUSH
43032: LD_INT 21
43034: PUSH
43035: LD_INT 3
43037: PUSH
43038: EMPTY
43039: LIST
43040: LIST
43041: PUSH
43042: LD_INT 3
43044: PUSH
43045: LD_INT 24
43047: PUSH
43048: LD_INT 1000
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PPUSH
43063: CALL_OW 72
43067: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43068: LD_ADDR_EXP 103
43072: PUSH
43073: LD_EXP 103
43077: PPUSH
43078: LD_VAR 0 2
43082: PPUSH
43083: LD_VAR 0 3
43087: PPUSH
43088: CALL_OW 1
43092: ST_TO_ADDR
// end ;
43093: GO 43013
43095: POP
43096: POP
// RaiseSailEvent ( 101 ) ;
43097: LD_INT 101
43099: PPUSH
43100: CALL_OW 427
// end ;
43104: LD_VAR 0 1
43108: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43109: LD_INT 0
43111: PPUSH
43112: PPUSH
43113: PPUSH
43114: PPUSH
43115: PPUSH
43116: PPUSH
43117: PPUSH
// if not mc_bases then
43118: LD_EXP 102
43122: NOT
43123: IFFALSE 43127
// exit ;
43125: GO 43700
// for i = 1 to mc_bases do
43127: LD_ADDR_VAR 0 2
43131: PUSH
43132: DOUBLE
43133: LD_INT 1
43135: DEC
43136: ST_TO_ADDR
43137: LD_EXP 102
43141: PUSH
43142: FOR_TO
43143: IFFALSE 43691
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43145: LD_ADDR_VAR 0 5
43149: PUSH
43150: LD_EXP 102
43154: PUSH
43155: LD_VAR 0 2
43159: ARRAY
43160: PUSH
43161: LD_EXP 131
43165: PUSH
43166: LD_VAR 0 2
43170: ARRAY
43171: UNION
43172: PPUSH
43173: LD_INT 21
43175: PUSH
43176: LD_INT 1
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: PUSH
43183: LD_INT 1
43185: PUSH
43186: LD_INT 3
43188: PUSH
43189: LD_INT 54
43191: PUSH
43192: EMPTY
43193: LIST
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 3
43201: PUSH
43202: LD_INT 24
43204: PUSH
43205: LD_INT 800
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PUSH
43216: EMPTY
43217: LIST
43218: LIST
43219: LIST
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PPUSH
43225: CALL_OW 72
43229: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43230: LD_ADDR_VAR 0 6
43234: PUSH
43235: LD_EXP 102
43239: PUSH
43240: LD_VAR 0 2
43244: ARRAY
43245: PPUSH
43246: LD_INT 21
43248: PUSH
43249: LD_INT 1
43251: PUSH
43252: EMPTY
43253: LIST
43254: LIST
43255: PUSH
43256: LD_INT 1
43258: PUSH
43259: LD_INT 3
43261: PUSH
43262: LD_INT 54
43264: PUSH
43265: EMPTY
43266: LIST
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: LD_INT 3
43274: PUSH
43275: LD_INT 24
43277: PUSH
43278: LD_INT 250
43280: PUSH
43281: EMPTY
43282: LIST
43283: LIST
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: EMPTY
43290: LIST
43291: LIST
43292: LIST
43293: PUSH
43294: EMPTY
43295: LIST
43296: LIST
43297: PPUSH
43298: CALL_OW 72
43302: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43303: LD_ADDR_VAR 0 7
43307: PUSH
43308: LD_VAR 0 5
43312: PUSH
43313: LD_VAR 0 6
43317: DIFF
43318: ST_TO_ADDR
// if not need_heal_1 then
43319: LD_VAR 0 6
43323: NOT
43324: IFFALSE 43357
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43326: LD_ADDR_EXP 105
43330: PUSH
43331: LD_EXP 105
43335: PPUSH
43336: LD_VAR 0 2
43340: PUSH
43341: LD_INT 1
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PPUSH
43348: EMPTY
43349: PPUSH
43350: CALL 72015 0 3
43354: ST_TO_ADDR
43355: GO 43427
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43357: LD_ADDR_EXP 105
43361: PUSH
43362: LD_EXP 105
43366: PPUSH
43367: LD_VAR 0 2
43371: PUSH
43372: LD_INT 1
43374: PUSH
43375: EMPTY
43376: LIST
43377: LIST
43378: PPUSH
43379: LD_EXP 105
43383: PUSH
43384: LD_VAR 0 2
43388: ARRAY
43389: PUSH
43390: LD_INT 1
43392: ARRAY
43393: PPUSH
43394: LD_INT 3
43396: PUSH
43397: LD_INT 24
43399: PUSH
43400: LD_INT 1000
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: EMPTY
43408: LIST
43409: LIST
43410: PPUSH
43411: CALL_OW 72
43415: PUSH
43416: LD_VAR 0 6
43420: UNION
43421: PPUSH
43422: CALL 72015 0 3
43426: ST_TO_ADDR
// if not need_heal_2 then
43427: LD_VAR 0 7
43431: NOT
43432: IFFALSE 43465
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43434: LD_ADDR_EXP 105
43438: PUSH
43439: LD_EXP 105
43443: PPUSH
43444: LD_VAR 0 2
43448: PUSH
43449: LD_INT 2
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PPUSH
43456: EMPTY
43457: PPUSH
43458: CALL 72015 0 3
43462: ST_TO_ADDR
43463: GO 43497
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43465: LD_ADDR_EXP 105
43469: PUSH
43470: LD_EXP 105
43474: PPUSH
43475: LD_VAR 0 2
43479: PUSH
43480: LD_INT 2
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PPUSH
43487: LD_VAR 0 7
43491: PPUSH
43492: CALL 72015 0 3
43496: ST_TO_ADDR
// if need_heal_2 then
43497: LD_VAR 0 7
43501: IFFALSE 43673
// for j in need_heal_2 do
43503: LD_ADDR_VAR 0 3
43507: PUSH
43508: LD_VAR 0 7
43512: PUSH
43513: FOR_IN
43514: IFFALSE 43671
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43516: LD_ADDR_VAR 0 5
43520: PUSH
43521: LD_EXP 102
43525: PUSH
43526: LD_VAR 0 2
43530: ARRAY
43531: PPUSH
43532: LD_INT 2
43534: PUSH
43535: LD_INT 30
43537: PUSH
43538: LD_INT 6
43540: PUSH
43541: EMPTY
43542: LIST
43543: LIST
43544: PUSH
43545: LD_INT 30
43547: PUSH
43548: LD_INT 7
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: LD_INT 30
43557: PUSH
43558: LD_INT 8
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: LD_INT 30
43567: PUSH
43568: LD_INT 0
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 30
43577: PUSH
43578: LD_INT 1
43580: PUSH
43581: EMPTY
43582: LIST
43583: LIST
43584: PUSH
43585: LD_INT 25
43587: PUSH
43588: LD_INT 4
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: LIST
43603: PPUSH
43604: CALL_OW 72
43608: ST_TO_ADDR
// if tmp then
43609: LD_VAR 0 5
43613: IFFALSE 43669
// begin k := NearestUnitToUnit ( tmp , j ) ;
43615: LD_ADDR_VAR 0 4
43619: PUSH
43620: LD_VAR 0 5
43624: PPUSH
43625: LD_VAR 0 3
43629: PPUSH
43630: CALL_OW 74
43634: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43635: LD_VAR 0 3
43639: PPUSH
43640: LD_VAR 0 4
43644: PPUSH
43645: CALL_OW 296
43649: PUSH
43650: LD_INT 7
43652: GREATER
43653: IFFALSE 43669
// ComMoveUnit ( j , k ) ;
43655: LD_VAR 0 3
43659: PPUSH
43660: LD_VAR 0 4
43664: PPUSH
43665: CALL_OW 112
// end ; end ;
43669: GO 43513
43671: POP
43672: POP
// if not need_heal_1 and not need_heal_2 then
43673: LD_VAR 0 6
43677: NOT
43678: PUSH
43679: LD_VAR 0 7
43683: NOT
43684: AND
43685: IFFALSE 43689
// continue ;
43687: GO 43142
// end ;
43689: GO 43142
43691: POP
43692: POP
// RaiseSailEvent ( 102 ) ;
43693: LD_INT 102
43695: PPUSH
43696: CALL_OW 427
// end ;
43700: LD_VAR 0 1
43704: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43705: LD_INT 0
43707: PPUSH
43708: PPUSH
43709: PPUSH
43710: PPUSH
43711: PPUSH
43712: PPUSH
43713: PPUSH
43714: PPUSH
// if not mc_bases then
43715: LD_EXP 102
43719: NOT
43720: IFFALSE 43724
// exit ;
43722: GO 44564
// for i = 1 to mc_bases do
43724: LD_ADDR_VAR 0 2
43728: PUSH
43729: DOUBLE
43730: LD_INT 1
43732: DEC
43733: ST_TO_ADDR
43734: LD_EXP 102
43738: PUSH
43739: FOR_TO
43740: IFFALSE 44562
// begin if not mc_building_need_repair [ i ] then
43742: LD_EXP 103
43746: PUSH
43747: LD_VAR 0 2
43751: ARRAY
43752: NOT
43753: IFFALSE 43927
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43755: LD_ADDR_VAR 0 6
43759: PUSH
43760: LD_EXP 121
43764: PUSH
43765: LD_VAR 0 2
43769: ARRAY
43770: PPUSH
43771: LD_INT 3
43773: PUSH
43774: LD_INT 24
43776: PUSH
43777: LD_INT 1000
43779: PUSH
43780: EMPTY
43781: LIST
43782: LIST
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: LD_INT 2
43790: PUSH
43791: LD_INT 34
43793: PUSH
43794: LD_INT 13
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 34
43803: PUSH
43804: LD_INT 52
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: LIST
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PPUSH
43820: CALL_OW 72
43824: ST_TO_ADDR
// if cranes then
43825: LD_VAR 0 6
43829: IFFALSE 43891
// for j in cranes do
43831: LD_ADDR_VAR 0 3
43835: PUSH
43836: LD_VAR 0 6
43840: PUSH
43841: FOR_IN
43842: IFFALSE 43889
// if not IsInArea ( j , mc_parking [ i ] ) then
43844: LD_VAR 0 3
43848: PPUSH
43849: LD_EXP 126
43853: PUSH
43854: LD_VAR 0 2
43858: ARRAY
43859: PPUSH
43860: CALL_OW 308
43864: NOT
43865: IFFALSE 43887
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43867: LD_VAR 0 3
43871: PPUSH
43872: LD_EXP 126
43876: PUSH
43877: LD_VAR 0 2
43881: ARRAY
43882: PPUSH
43883: CALL_OW 113
43887: GO 43841
43889: POP
43890: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43891: LD_ADDR_EXP 104
43895: PUSH
43896: LD_EXP 104
43900: PPUSH
43901: LD_VAR 0 2
43905: PPUSH
43906: EMPTY
43907: PPUSH
43908: CALL_OW 1
43912: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43913: LD_VAR 0 2
43917: PPUSH
43918: LD_INT 101
43920: PPUSH
43921: CALL 38817 0 2
// continue ;
43925: GO 43739
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43927: LD_ADDR_EXP 108
43931: PUSH
43932: LD_EXP 108
43936: PPUSH
43937: LD_VAR 0 2
43941: PPUSH
43942: EMPTY
43943: PPUSH
43944: CALL_OW 1
43948: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43949: LD_VAR 0 2
43953: PPUSH
43954: LD_INT 103
43956: PPUSH
43957: CALL 38817 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43961: LD_ADDR_VAR 0 5
43965: PUSH
43966: LD_EXP 102
43970: PUSH
43971: LD_VAR 0 2
43975: ARRAY
43976: PUSH
43977: LD_EXP 131
43981: PUSH
43982: LD_VAR 0 2
43986: ARRAY
43987: UNION
43988: PPUSH
43989: LD_INT 2
43991: PUSH
43992: LD_INT 25
43994: PUSH
43995: LD_INT 2
43997: PUSH
43998: EMPTY
43999: LIST
44000: LIST
44001: PUSH
44002: LD_INT 25
44004: PUSH
44005: LD_INT 16
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: LIST
44016: PUSH
44017: EMPTY
44018: LIST
44019: PPUSH
44020: CALL_OW 72
44024: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44025: LD_ADDR_VAR 0 6
44029: PUSH
44030: LD_EXP 121
44034: PUSH
44035: LD_VAR 0 2
44039: ARRAY
44040: PPUSH
44041: LD_INT 2
44043: PUSH
44044: LD_INT 34
44046: PUSH
44047: LD_INT 13
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: PUSH
44054: LD_INT 34
44056: PUSH
44057: LD_INT 52
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: LIST
44068: PPUSH
44069: CALL_OW 72
44073: ST_TO_ADDR
// if cranes then
44074: LD_VAR 0 6
44078: IFFALSE 44214
// begin for j in cranes do
44080: LD_ADDR_VAR 0 3
44084: PUSH
44085: LD_VAR 0 6
44089: PUSH
44090: FOR_IN
44091: IFFALSE 44212
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44093: LD_VAR 0 3
44097: PPUSH
44098: CALL_OW 256
44102: PUSH
44103: LD_INT 500
44105: GREATEREQUAL
44106: PUSH
44107: LD_VAR 0 3
44111: PPUSH
44112: CALL_OW 314
44116: NOT
44117: AND
44118: IFFALSE 44152
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44120: LD_VAR 0 3
44124: PPUSH
44125: LD_EXP 103
44129: PUSH
44130: LD_VAR 0 2
44134: ARRAY
44135: PPUSH
44136: LD_VAR 0 3
44140: PPUSH
44141: CALL_OW 74
44145: PPUSH
44146: CALL_OW 130
44150: GO 44210
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44152: LD_VAR 0 3
44156: PPUSH
44157: CALL_OW 256
44161: PUSH
44162: LD_INT 500
44164: LESS
44165: PUSH
44166: LD_VAR 0 3
44170: PPUSH
44171: LD_EXP 126
44175: PUSH
44176: LD_VAR 0 2
44180: ARRAY
44181: PPUSH
44182: CALL_OW 308
44186: NOT
44187: AND
44188: IFFALSE 44210
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44190: LD_VAR 0 3
44194: PPUSH
44195: LD_EXP 126
44199: PUSH
44200: LD_VAR 0 2
44204: ARRAY
44205: PPUSH
44206: CALL_OW 113
44210: GO 44090
44212: POP
44213: POP
// end ; if not tmp then
44214: LD_VAR 0 5
44218: NOT
44219: IFFALSE 44223
// continue ;
44221: GO 43739
// for j in tmp do
44223: LD_ADDR_VAR 0 3
44227: PUSH
44228: LD_VAR 0 5
44232: PUSH
44233: FOR_IN
44234: IFFALSE 44558
// begin if mc_need_heal [ i ] then
44236: LD_EXP 105
44240: PUSH
44241: LD_VAR 0 2
44245: ARRAY
44246: IFFALSE 44294
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
44248: LD_VAR 0 3
44252: PUSH
44253: LD_EXP 105
44257: PUSH
44258: LD_VAR 0 2
44262: ARRAY
44263: PUSH
44264: LD_INT 1
44266: ARRAY
44267: IN
44268: PUSH
44269: LD_VAR 0 3
44273: PUSH
44274: LD_EXP 105
44278: PUSH
44279: LD_VAR 0 2
44283: ARRAY
44284: PUSH
44285: LD_INT 2
44287: ARRAY
44288: IN
44289: OR
44290: IFFALSE 44294
// continue ;
44292: GO 44233
// if IsInUnit ( j ) then
44294: LD_VAR 0 3
44298: PPUSH
44299: CALL_OW 310
44303: IFFALSE 44314
// ComExitBuilding ( j ) ;
44305: LD_VAR 0 3
44309: PPUSH
44310: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44314: LD_VAR 0 3
44318: PUSH
44319: LD_EXP 104
44323: PUSH
44324: LD_VAR 0 2
44328: ARRAY
44329: IN
44330: NOT
44331: IFFALSE 44389
// begin SetTag ( j , 101 ) ;
44333: LD_VAR 0 3
44337: PPUSH
44338: LD_INT 101
44340: PPUSH
44341: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44345: LD_ADDR_EXP 104
44349: PUSH
44350: LD_EXP 104
44354: PPUSH
44355: LD_VAR 0 2
44359: PUSH
44360: LD_EXP 104
44364: PUSH
44365: LD_VAR 0 2
44369: ARRAY
44370: PUSH
44371: LD_INT 1
44373: PLUS
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PPUSH
44379: LD_VAR 0 3
44383: PPUSH
44384: CALL 72015 0 3
44388: ST_TO_ADDR
// end ; wait ( 1 ) ;
44389: LD_INT 1
44391: PPUSH
44392: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44396: LD_ADDR_VAR 0 7
44400: PUSH
44401: LD_EXP 103
44405: PUSH
44406: LD_VAR 0 2
44410: ARRAY
44411: ST_TO_ADDR
// if mc_scan [ i ] then
44412: LD_EXP 125
44416: PUSH
44417: LD_VAR 0 2
44421: ARRAY
44422: IFFALSE 44491
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
44424: LD_ADDR_VAR 0 7
44428: PUSH
44429: LD_EXP 103
44433: PUSH
44434: LD_VAR 0 2
44438: ARRAY
44439: PPUSH
44440: LD_INT 3
44442: PUSH
44443: LD_INT 2
44445: PUSH
44446: LD_INT 30
44448: PUSH
44449: LD_INT 32
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: PUSH
44456: LD_INT 30
44458: PUSH
44459: LD_INT 33
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: LD_INT 30
44468: PUSH
44469: LD_INT 31
44471: PUSH
44472: EMPTY
44473: LIST
44474: LIST
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: LIST
44480: LIST
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: PPUSH
44486: CALL_OW 72
44490: ST_TO_ADDR
// if not to_repair_tmp then
44491: LD_VAR 0 7
44495: NOT
44496: IFFALSE 44500
// continue ;
44498: GO 44233
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44500: LD_ADDR_VAR 0 8
44504: PUSH
44505: LD_VAR 0 7
44509: PPUSH
44510: LD_VAR 0 3
44514: PPUSH
44515: CALL_OW 74
44519: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44520: LD_VAR 0 8
44524: PPUSH
44525: LD_INT 14
44527: PPUSH
44528: CALL 74608 0 2
44532: PUSH
44533: LD_INT 4
44535: ARRAY
44536: PUSH
44537: LD_INT 5
44539: LESS
44540: IFFALSE 44556
// ComRepairBuilding ( j , to_repair ) ;
44542: LD_VAR 0 3
44546: PPUSH
44547: LD_VAR 0 8
44551: PPUSH
44552: CALL_OW 130
// end ;
44556: GO 44233
44558: POP
44559: POP
// end ;
44560: GO 43739
44562: POP
44563: POP
// end ;
44564: LD_VAR 0 1
44568: RET
// export function MC_Heal ; var i , j , tmp ; begin
44569: LD_INT 0
44571: PPUSH
44572: PPUSH
44573: PPUSH
44574: PPUSH
// if not mc_bases then
44575: LD_EXP 102
44579: NOT
44580: IFFALSE 44584
// exit ;
44582: GO 44986
// for i = 1 to mc_bases do
44584: LD_ADDR_VAR 0 2
44588: PUSH
44589: DOUBLE
44590: LD_INT 1
44592: DEC
44593: ST_TO_ADDR
44594: LD_EXP 102
44598: PUSH
44599: FOR_TO
44600: IFFALSE 44984
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44602: LD_EXP 105
44606: PUSH
44607: LD_VAR 0 2
44611: ARRAY
44612: PUSH
44613: LD_INT 1
44615: ARRAY
44616: NOT
44617: PUSH
44618: LD_EXP 105
44622: PUSH
44623: LD_VAR 0 2
44627: ARRAY
44628: PUSH
44629: LD_INT 2
44631: ARRAY
44632: NOT
44633: AND
44634: IFFALSE 44672
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44636: LD_ADDR_EXP 106
44640: PUSH
44641: LD_EXP 106
44645: PPUSH
44646: LD_VAR 0 2
44650: PPUSH
44651: EMPTY
44652: PPUSH
44653: CALL_OW 1
44657: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44658: LD_VAR 0 2
44662: PPUSH
44663: LD_INT 102
44665: PPUSH
44666: CALL 38817 0 2
// continue ;
44670: GO 44599
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44672: LD_ADDR_VAR 0 4
44676: PUSH
44677: LD_EXP 102
44681: PUSH
44682: LD_VAR 0 2
44686: ARRAY
44687: PPUSH
44688: LD_INT 25
44690: PUSH
44691: LD_INT 4
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: PPUSH
44698: CALL_OW 72
44702: ST_TO_ADDR
// if not tmp then
44703: LD_VAR 0 4
44707: NOT
44708: IFFALSE 44712
// continue ;
44710: GO 44599
// if mc_taming [ i ] then
44712: LD_EXP 133
44716: PUSH
44717: LD_VAR 0 2
44721: ARRAY
44722: IFFALSE 44746
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44724: LD_ADDR_EXP 133
44728: PUSH
44729: LD_EXP 133
44733: PPUSH
44734: LD_VAR 0 2
44738: PPUSH
44739: EMPTY
44740: PPUSH
44741: CALL_OW 1
44745: ST_TO_ADDR
// for j in tmp do
44746: LD_ADDR_VAR 0 3
44750: PUSH
44751: LD_VAR 0 4
44755: PUSH
44756: FOR_IN
44757: IFFALSE 44980
// begin if IsInUnit ( j ) then
44759: LD_VAR 0 3
44763: PPUSH
44764: CALL_OW 310
44768: IFFALSE 44779
// ComExitBuilding ( j ) ;
44770: LD_VAR 0 3
44774: PPUSH
44775: CALL_OW 122
// if not j in mc_healers [ i ] then
44779: LD_VAR 0 3
44783: PUSH
44784: LD_EXP 106
44788: PUSH
44789: LD_VAR 0 2
44793: ARRAY
44794: IN
44795: NOT
44796: IFFALSE 44842
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44798: LD_ADDR_EXP 106
44802: PUSH
44803: LD_EXP 106
44807: PPUSH
44808: LD_VAR 0 2
44812: PUSH
44813: LD_EXP 106
44817: PUSH
44818: LD_VAR 0 2
44822: ARRAY
44823: PUSH
44824: LD_INT 1
44826: PLUS
44827: PUSH
44828: EMPTY
44829: LIST
44830: LIST
44831: PPUSH
44832: LD_VAR 0 3
44836: PPUSH
44837: CALL 72015 0 3
44841: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44842: LD_VAR 0 3
44846: PPUSH
44847: CALL_OW 110
44851: PUSH
44852: LD_INT 102
44854: NONEQUAL
44855: IFFALSE 44869
// SetTag ( j , 102 ) ;
44857: LD_VAR 0 3
44861: PPUSH
44862: LD_INT 102
44864: PPUSH
44865: CALL_OW 109
// Wait ( 3 ) ;
44869: LD_INT 3
44871: PPUSH
44872: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44876: LD_EXP 105
44880: PUSH
44881: LD_VAR 0 2
44885: ARRAY
44886: PUSH
44887: LD_INT 1
44889: ARRAY
44890: IFFALSE 44922
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44892: LD_VAR 0 3
44896: PPUSH
44897: LD_EXP 105
44901: PUSH
44902: LD_VAR 0 2
44906: ARRAY
44907: PUSH
44908: LD_INT 1
44910: ARRAY
44911: PUSH
44912: LD_INT 1
44914: ARRAY
44915: PPUSH
44916: CALL_OW 128
44920: GO 44978
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44922: LD_VAR 0 3
44926: PPUSH
44927: CALL_OW 314
44931: NOT
44932: PUSH
44933: LD_EXP 105
44937: PUSH
44938: LD_VAR 0 2
44942: ARRAY
44943: PUSH
44944: LD_INT 2
44946: ARRAY
44947: AND
44948: IFFALSE 44978
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44950: LD_VAR 0 3
44954: PPUSH
44955: LD_EXP 105
44959: PUSH
44960: LD_VAR 0 2
44964: ARRAY
44965: PUSH
44966: LD_INT 2
44968: ARRAY
44969: PUSH
44970: LD_INT 1
44972: ARRAY
44973: PPUSH
44974: CALL_OW 128
// end ;
44978: GO 44756
44980: POP
44981: POP
// end ;
44982: GO 44599
44984: POP
44985: POP
// end ;
44986: LD_VAR 0 1
44990: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44991: LD_INT 0
44993: PPUSH
44994: PPUSH
44995: PPUSH
44996: PPUSH
44997: PPUSH
// if not mc_bases then
44998: LD_EXP 102
45002: NOT
45003: IFFALSE 45007
// exit ;
45005: GO 46150
// for i = 1 to mc_bases do
45007: LD_ADDR_VAR 0 2
45011: PUSH
45012: DOUBLE
45013: LD_INT 1
45015: DEC
45016: ST_TO_ADDR
45017: LD_EXP 102
45021: PUSH
45022: FOR_TO
45023: IFFALSE 46148
// begin if mc_scan [ i ] then
45025: LD_EXP 125
45029: PUSH
45030: LD_VAR 0 2
45034: ARRAY
45035: IFFALSE 45039
// continue ;
45037: GO 45022
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45039: LD_EXP 107
45043: PUSH
45044: LD_VAR 0 2
45048: ARRAY
45049: NOT
45050: PUSH
45051: LD_EXP 109
45055: PUSH
45056: LD_VAR 0 2
45060: ARRAY
45061: NOT
45062: AND
45063: PUSH
45064: LD_EXP 108
45068: PUSH
45069: LD_VAR 0 2
45073: ARRAY
45074: AND
45075: IFFALSE 45113
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45077: LD_ADDR_EXP 108
45081: PUSH
45082: LD_EXP 108
45086: PPUSH
45087: LD_VAR 0 2
45091: PPUSH
45092: EMPTY
45093: PPUSH
45094: CALL_OW 1
45098: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45099: LD_VAR 0 2
45103: PPUSH
45104: LD_INT 103
45106: PPUSH
45107: CALL 38817 0 2
// continue ;
45111: GO 45022
// end ; if mc_construct_list [ i ] then
45113: LD_EXP 109
45117: PUSH
45118: LD_VAR 0 2
45122: ARRAY
45123: IFFALSE 45343
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45125: LD_ADDR_VAR 0 4
45129: PUSH
45130: LD_EXP 102
45134: PUSH
45135: LD_VAR 0 2
45139: ARRAY
45140: PPUSH
45141: LD_INT 25
45143: PUSH
45144: LD_INT 2
45146: PUSH
45147: EMPTY
45148: LIST
45149: LIST
45150: PPUSH
45151: CALL_OW 72
45155: PUSH
45156: LD_EXP 104
45160: PUSH
45161: LD_VAR 0 2
45165: ARRAY
45166: DIFF
45167: ST_TO_ADDR
// if not tmp then
45168: LD_VAR 0 4
45172: NOT
45173: IFFALSE 45177
// continue ;
45175: GO 45022
// for j in tmp do
45177: LD_ADDR_VAR 0 3
45181: PUSH
45182: LD_VAR 0 4
45186: PUSH
45187: FOR_IN
45188: IFFALSE 45339
// begin if not mc_builders [ i ] then
45190: LD_EXP 108
45194: PUSH
45195: LD_VAR 0 2
45199: ARRAY
45200: NOT
45201: IFFALSE 45259
// begin SetTag ( j , 103 ) ;
45203: LD_VAR 0 3
45207: PPUSH
45208: LD_INT 103
45210: PPUSH
45211: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45215: LD_ADDR_EXP 108
45219: PUSH
45220: LD_EXP 108
45224: PPUSH
45225: LD_VAR 0 2
45229: PUSH
45230: LD_EXP 108
45234: PUSH
45235: LD_VAR 0 2
45239: ARRAY
45240: PUSH
45241: LD_INT 1
45243: PLUS
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PPUSH
45249: LD_VAR 0 3
45253: PPUSH
45254: CALL 72015 0 3
45258: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45259: LD_VAR 0 3
45263: PPUSH
45264: CALL_OW 310
45268: IFFALSE 45279
// ComExitBuilding ( j ) ;
45270: LD_VAR 0 3
45274: PPUSH
45275: CALL_OW 122
// wait ( 3 ) ;
45279: LD_INT 3
45281: PPUSH
45282: CALL_OW 67
// if not mc_construct_list [ i ] then
45286: LD_EXP 109
45290: PUSH
45291: LD_VAR 0 2
45295: ARRAY
45296: NOT
45297: IFFALSE 45301
// break ;
45299: GO 45339
// if not HasTask ( j ) then
45301: LD_VAR 0 3
45305: PPUSH
45306: CALL_OW 314
45310: NOT
45311: IFFALSE 45337
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45313: LD_VAR 0 3
45317: PPUSH
45318: LD_EXP 109
45322: PUSH
45323: LD_VAR 0 2
45327: ARRAY
45328: PUSH
45329: LD_INT 1
45331: ARRAY
45332: PPUSH
45333: CALL 74866 0 2
// end ;
45337: GO 45187
45339: POP
45340: POP
// end else
45341: GO 46146
// if mc_build_list [ i ] then
45343: LD_EXP 107
45347: PUSH
45348: LD_VAR 0 2
45352: ARRAY
45353: IFFALSE 46146
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45355: LD_ADDR_VAR 0 5
45359: PUSH
45360: LD_EXP 102
45364: PUSH
45365: LD_VAR 0 2
45369: ARRAY
45370: PPUSH
45371: LD_INT 2
45373: PUSH
45374: LD_INT 30
45376: PUSH
45377: LD_INT 0
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: PUSH
45384: LD_INT 30
45386: PUSH
45387: LD_INT 1
45389: PUSH
45390: EMPTY
45391: LIST
45392: LIST
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: LIST
45398: PPUSH
45399: CALL_OW 72
45403: ST_TO_ADDR
// if depot then
45404: LD_VAR 0 5
45408: IFFALSE 45426
// depot := depot [ 1 ] else
45410: LD_ADDR_VAR 0 5
45414: PUSH
45415: LD_VAR 0 5
45419: PUSH
45420: LD_INT 1
45422: ARRAY
45423: ST_TO_ADDR
45424: GO 45434
// depot := 0 ;
45426: LD_ADDR_VAR 0 5
45430: PUSH
45431: LD_INT 0
45433: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45434: LD_EXP 107
45438: PUSH
45439: LD_VAR 0 2
45443: ARRAY
45444: PUSH
45445: LD_INT 1
45447: ARRAY
45448: PUSH
45449: LD_INT 1
45451: ARRAY
45452: PPUSH
45453: CALL 74696 0 1
45457: PUSH
45458: LD_EXP 102
45462: PUSH
45463: LD_VAR 0 2
45467: ARRAY
45468: PPUSH
45469: LD_INT 2
45471: PUSH
45472: LD_INT 30
45474: PUSH
45475: LD_INT 2
45477: PUSH
45478: EMPTY
45479: LIST
45480: LIST
45481: PUSH
45482: LD_INT 30
45484: PUSH
45485: LD_INT 3
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: LIST
45496: PPUSH
45497: CALL_OW 72
45501: NOT
45502: AND
45503: IFFALSE 45608
// begin for j = 1 to mc_build_list [ i ] do
45505: LD_ADDR_VAR 0 3
45509: PUSH
45510: DOUBLE
45511: LD_INT 1
45513: DEC
45514: ST_TO_ADDR
45515: LD_EXP 107
45519: PUSH
45520: LD_VAR 0 2
45524: ARRAY
45525: PUSH
45526: FOR_TO
45527: IFFALSE 45606
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45529: LD_EXP 107
45533: PUSH
45534: LD_VAR 0 2
45538: ARRAY
45539: PUSH
45540: LD_VAR 0 3
45544: ARRAY
45545: PUSH
45546: LD_INT 1
45548: ARRAY
45549: PUSH
45550: LD_INT 2
45552: EQUAL
45553: IFFALSE 45604
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45555: LD_ADDR_EXP 107
45559: PUSH
45560: LD_EXP 107
45564: PPUSH
45565: LD_VAR 0 2
45569: PPUSH
45570: LD_EXP 107
45574: PUSH
45575: LD_VAR 0 2
45579: ARRAY
45580: PPUSH
45581: LD_VAR 0 3
45585: PPUSH
45586: LD_INT 1
45588: PPUSH
45589: LD_INT 0
45591: PPUSH
45592: CALL 71433 0 4
45596: PPUSH
45597: CALL_OW 1
45601: ST_TO_ADDR
// break ;
45602: GO 45606
// end ;
45604: GO 45526
45606: POP
45607: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45608: LD_EXP 107
45612: PUSH
45613: LD_VAR 0 2
45617: ARRAY
45618: PUSH
45619: LD_INT 1
45621: ARRAY
45622: PUSH
45623: LD_INT 1
45625: ARRAY
45626: PUSH
45627: LD_INT 0
45629: EQUAL
45630: PUSH
45631: LD_VAR 0 5
45635: PUSH
45636: LD_VAR 0 5
45640: PPUSH
45641: LD_EXP 107
45645: PUSH
45646: LD_VAR 0 2
45650: ARRAY
45651: PUSH
45652: LD_INT 1
45654: ARRAY
45655: PUSH
45656: LD_INT 1
45658: ARRAY
45659: PPUSH
45660: LD_EXP 107
45664: PUSH
45665: LD_VAR 0 2
45669: ARRAY
45670: PUSH
45671: LD_INT 1
45673: ARRAY
45674: PUSH
45675: LD_INT 2
45677: ARRAY
45678: PPUSH
45679: LD_EXP 107
45683: PUSH
45684: LD_VAR 0 2
45688: ARRAY
45689: PUSH
45690: LD_INT 1
45692: ARRAY
45693: PUSH
45694: LD_INT 3
45696: ARRAY
45697: PPUSH
45698: LD_EXP 107
45702: PUSH
45703: LD_VAR 0 2
45707: ARRAY
45708: PUSH
45709: LD_INT 1
45711: ARRAY
45712: PUSH
45713: LD_INT 4
45715: ARRAY
45716: PPUSH
45717: CALL 79430 0 5
45721: AND
45722: OR
45723: IFFALSE 46004
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45725: LD_ADDR_VAR 0 4
45729: PUSH
45730: LD_EXP 102
45734: PUSH
45735: LD_VAR 0 2
45739: ARRAY
45740: PPUSH
45741: LD_INT 25
45743: PUSH
45744: LD_INT 2
45746: PUSH
45747: EMPTY
45748: LIST
45749: LIST
45750: PPUSH
45751: CALL_OW 72
45755: PUSH
45756: LD_EXP 104
45760: PUSH
45761: LD_VAR 0 2
45765: ARRAY
45766: DIFF
45767: ST_TO_ADDR
// if not tmp then
45768: LD_VAR 0 4
45772: NOT
45773: IFFALSE 45777
// continue ;
45775: GO 45022
// for j in tmp do
45777: LD_ADDR_VAR 0 3
45781: PUSH
45782: LD_VAR 0 4
45786: PUSH
45787: FOR_IN
45788: IFFALSE 46000
// begin if not mc_builders [ i ] then
45790: LD_EXP 108
45794: PUSH
45795: LD_VAR 0 2
45799: ARRAY
45800: NOT
45801: IFFALSE 45859
// begin SetTag ( j , 103 ) ;
45803: LD_VAR 0 3
45807: PPUSH
45808: LD_INT 103
45810: PPUSH
45811: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45815: LD_ADDR_EXP 108
45819: PUSH
45820: LD_EXP 108
45824: PPUSH
45825: LD_VAR 0 2
45829: PUSH
45830: LD_EXP 108
45834: PUSH
45835: LD_VAR 0 2
45839: ARRAY
45840: PUSH
45841: LD_INT 1
45843: PLUS
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PPUSH
45849: LD_VAR 0 3
45853: PPUSH
45854: CALL 72015 0 3
45858: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45859: LD_VAR 0 3
45863: PPUSH
45864: CALL_OW 310
45868: IFFALSE 45879
// ComExitBuilding ( j ) ;
45870: LD_VAR 0 3
45874: PPUSH
45875: CALL_OW 122
// wait ( 3 ) ;
45879: LD_INT 3
45881: PPUSH
45882: CALL_OW 67
// if not mc_build_list [ i ] then
45886: LD_EXP 107
45890: PUSH
45891: LD_VAR 0 2
45895: ARRAY
45896: NOT
45897: IFFALSE 45901
// break ;
45899: GO 46000
// if not HasTask ( j ) then
45901: LD_VAR 0 3
45905: PPUSH
45906: CALL_OW 314
45910: NOT
45911: IFFALSE 45998
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45913: LD_VAR 0 3
45917: PPUSH
45918: LD_EXP 107
45922: PUSH
45923: LD_VAR 0 2
45927: ARRAY
45928: PUSH
45929: LD_INT 1
45931: ARRAY
45932: PUSH
45933: LD_INT 1
45935: ARRAY
45936: PPUSH
45937: LD_EXP 107
45941: PUSH
45942: LD_VAR 0 2
45946: ARRAY
45947: PUSH
45948: LD_INT 1
45950: ARRAY
45951: PUSH
45952: LD_INT 2
45954: ARRAY
45955: PPUSH
45956: LD_EXP 107
45960: PUSH
45961: LD_VAR 0 2
45965: ARRAY
45966: PUSH
45967: LD_INT 1
45969: ARRAY
45970: PUSH
45971: LD_INT 3
45973: ARRAY
45974: PPUSH
45975: LD_EXP 107
45979: PUSH
45980: LD_VAR 0 2
45984: ARRAY
45985: PUSH
45986: LD_INT 1
45988: ARRAY
45989: PUSH
45990: LD_INT 4
45992: ARRAY
45993: PPUSH
45994: CALL_OW 145
// end ;
45998: GO 45787
46000: POP
46001: POP
// end else
46002: GO 46146
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46004: LD_EXP 102
46008: PUSH
46009: LD_VAR 0 2
46013: ARRAY
46014: PPUSH
46015: LD_EXP 107
46019: PUSH
46020: LD_VAR 0 2
46024: ARRAY
46025: PUSH
46026: LD_INT 1
46028: ARRAY
46029: PUSH
46030: LD_INT 1
46032: ARRAY
46033: PPUSH
46034: LD_EXP 107
46038: PUSH
46039: LD_VAR 0 2
46043: ARRAY
46044: PUSH
46045: LD_INT 1
46047: ARRAY
46048: PUSH
46049: LD_INT 2
46051: ARRAY
46052: PPUSH
46053: LD_EXP 107
46057: PUSH
46058: LD_VAR 0 2
46062: ARRAY
46063: PUSH
46064: LD_INT 1
46066: ARRAY
46067: PUSH
46068: LD_INT 3
46070: ARRAY
46071: PPUSH
46072: LD_EXP 107
46076: PUSH
46077: LD_VAR 0 2
46081: ARRAY
46082: PUSH
46083: LD_INT 1
46085: ARRAY
46086: PUSH
46087: LD_INT 4
46089: ARRAY
46090: PPUSH
46091: CALL 78766 0 5
46095: NOT
46096: IFFALSE 46146
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46098: LD_ADDR_EXP 107
46102: PUSH
46103: LD_EXP 107
46107: PPUSH
46108: LD_VAR 0 2
46112: PPUSH
46113: LD_EXP 107
46117: PUSH
46118: LD_VAR 0 2
46122: ARRAY
46123: PPUSH
46124: LD_INT 1
46126: PPUSH
46127: LD_INT 1
46129: NEG
46130: PPUSH
46131: LD_INT 0
46133: PPUSH
46134: CALL 71433 0 4
46138: PPUSH
46139: CALL_OW 1
46143: ST_TO_ADDR
// continue ;
46144: GO 45022
// end ; end ; end ;
46146: GO 45022
46148: POP
46149: POP
// end ;
46150: LD_VAR 0 1
46154: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46155: LD_INT 0
46157: PPUSH
46158: PPUSH
46159: PPUSH
46160: PPUSH
46161: PPUSH
46162: PPUSH
// if not mc_bases then
46163: LD_EXP 102
46167: NOT
46168: IFFALSE 46172
// exit ;
46170: GO 46599
// for i = 1 to mc_bases do
46172: LD_ADDR_VAR 0 2
46176: PUSH
46177: DOUBLE
46178: LD_INT 1
46180: DEC
46181: ST_TO_ADDR
46182: LD_EXP 102
46186: PUSH
46187: FOR_TO
46188: IFFALSE 46597
// begin tmp := mc_build_upgrade [ i ] ;
46190: LD_ADDR_VAR 0 4
46194: PUSH
46195: LD_EXP 134
46199: PUSH
46200: LD_VAR 0 2
46204: ARRAY
46205: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46206: LD_ADDR_VAR 0 6
46210: PUSH
46211: LD_EXP 135
46215: PUSH
46216: LD_VAR 0 2
46220: ARRAY
46221: PPUSH
46222: LD_INT 2
46224: PUSH
46225: LD_INT 30
46227: PUSH
46228: LD_INT 6
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PUSH
46235: LD_INT 30
46237: PUSH
46238: LD_INT 7
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: LIST
46249: PPUSH
46250: CALL_OW 72
46254: ST_TO_ADDR
// if not tmp and not lab then
46255: LD_VAR 0 4
46259: NOT
46260: PUSH
46261: LD_VAR 0 6
46265: NOT
46266: AND
46267: IFFALSE 46271
// continue ;
46269: GO 46187
// if tmp then
46271: LD_VAR 0 4
46275: IFFALSE 46395
// for j in tmp do
46277: LD_ADDR_VAR 0 3
46281: PUSH
46282: LD_VAR 0 4
46286: PUSH
46287: FOR_IN
46288: IFFALSE 46393
// begin if UpgradeCost ( j ) then
46290: LD_VAR 0 3
46294: PPUSH
46295: CALL 78426 0 1
46299: IFFALSE 46391
// begin ComUpgrade ( j ) ;
46301: LD_VAR 0 3
46305: PPUSH
46306: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46310: LD_ADDR_EXP 134
46314: PUSH
46315: LD_EXP 134
46319: PPUSH
46320: LD_VAR 0 2
46324: PPUSH
46325: LD_EXP 134
46329: PUSH
46330: LD_VAR 0 2
46334: ARRAY
46335: PUSH
46336: LD_VAR 0 3
46340: DIFF
46341: PPUSH
46342: CALL_OW 1
46346: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46347: LD_ADDR_EXP 109
46351: PUSH
46352: LD_EXP 109
46356: PPUSH
46357: LD_VAR 0 2
46361: PUSH
46362: LD_EXP 109
46366: PUSH
46367: LD_VAR 0 2
46371: ARRAY
46372: PUSH
46373: LD_INT 1
46375: PLUS
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PPUSH
46381: LD_VAR 0 3
46385: PPUSH
46386: CALL 72015 0 3
46390: ST_TO_ADDR
// end ; end ;
46391: GO 46287
46393: POP
46394: POP
// if not lab or not mc_lab_upgrade [ i ] then
46395: LD_VAR 0 6
46399: NOT
46400: PUSH
46401: LD_EXP 136
46405: PUSH
46406: LD_VAR 0 2
46410: ARRAY
46411: NOT
46412: OR
46413: IFFALSE 46417
// continue ;
46415: GO 46187
// for j in lab do
46417: LD_ADDR_VAR 0 3
46421: PUSH
46422: LD_VAR 0 6
46426: PUSH
46427: FOR_IN
46428: IFFALSE 46593
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46430: LD_VAR 0 3
46434: PPUSH
46435: CALL_OW 266
46439: PUSH
46440: LD_INT 6
46442: PUSH
46443: LD_INT 7
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: IN
46450: PUSH
46451: LD_VAR 0 3
46455: PPUSH
46456: CALL_OW 461
46460: PUSH
46461: LD_INT 1
46463: NONEQUAL
46464: AND
46465: IFFALSE 46591
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46467: LD_VAR 0 3
46471: PPUSH
46472: LD_EXP 136
46476: PUSH
46477: LD_VAR 0 2
46481: ARRAY
46482: PUSH
46483: LD_INT 1
46485: ARRAY
46486: PPUSH
46487: CALL 78631 0 2
46491: IFFALSE 46591
// begin ComCancel ( j ) ;
46493: LD_VAR 0 3
46497: PPUSH
46498: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46502: LD_VAR 0 3
46506: PPUSH
46507: LD_EXP 136
46511: PUSH
46512: LD_VAR 0 2
46516: ARRAY
46517: PUSH
46518: LD_INT 1
46520: ARRAY
46521: PPUSH
46522: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46526: LD_VAR 0 3
46530: PUSH
46531: LD_EXP 109
46535: PUSH
46536: LD_VAR 0 2
46540: ARRAY
46541: IN
46542: NOT
46543: IFFALSE 46589
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46545: LD_ADDR_EXP 109
46549: PUSH
46550: LD_EXP 109
46554: PPUSH
46555: LD_VAR 0 2
46559: PUSH
46560: LD_EXP 109
46564: PUSH
46565: LD_VAR 0 2
46569: ARRAY
46570: PUSH
46571: LD_INT 1
46573: PLUS
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: PPUSH
46579: LD_VAR 0 3
46583: PPUSH
46584: CALL 72015 0 3
46588: ST_TO_ADDR
// break ;
46589: GO 46593
// end ; end ; end ;
46591: GO 46427
46593: POP
46594: POP
// end ;
46595: GO 46187
46597: POP
46598: POP
// end ;
46599: LD_VAR 0 1
46603: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46604: LD_INT 0
46606: PPUSH
46607: PPUSH
46608: PPUSH
46609: PPUSH
46610: PPUSH
46611: PPUSH
46612: PPUSH
46613: PPUSH
46614: PPUSH
// if not mc_bases then
46615: LD_EXP 102
46619: NOT
46620: IFFALSE 46624
// exit ;
46622: GO 47029
// for i = 1 to mc_bases do
46624: LD_ADDR_VAR 0 2
46628: PUSH
46629: DOUBLE
46630: LD_INT 1
46632: DEC
46633: ST_TO_ADDR
46634: LD_EXP 102
46638: PUSH
46639: FOR_TO
46640: IFFALSE 47027
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46642: LD_EXP 110
46646: PUSH
46647: LD_VAR 0 2
46651: ARRAY
46652: NOT
46653: PUSH
46654: LD_EXP 102
46658: PUSH
46659: LD_VAR 0 2
46663: ARRAY
46664: PPUSH
46665: LD_INT 30
46667: PUSH
46668: LD_INT 3
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: PPUSH
46675: CALL_OW 72
46679: NOT
46680: OR
46681: IFFALSE 46685
// continue ;
46683: GO 46639
// busy := false ;
46685: LD_ADDR_VAR 0 8
46689: PUSH
46690: LD_INT 0
46692: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46693: LD_ADDR_VAR 0 4
46697: PUSH
46698: LD_EXP 102
46702: PUSH
46703: LD_VAR 0 2
46707: ARRAY
46708: PPUSH
46709: LD_INT 30
46711: PUSH
46712: LD_INT 3
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PPUSH
46719: CALL_OW 72
46723: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46724: LD_ADDR_VAR 0 6
46728: PUSH
46729: LD_EXP 110
46733: PUSH
46734: LD_VAR 0 2
46738: ARRAY
46739: PPUSH
46740: LD_INT 2
46742: PUSH
46743: LD_INT 30
46745: PUSH
46746: LD_INT 32
46748: PUSH
46749: EMPTY
46750: LIST
46751: LIST
46752: PUSH
46753: LD_INT 30
46755: PUSH
46756: LD_INT 33
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: PUSH
46763: EMPTY
46764: LIST
46765: LIST
46766: LIST
46767: PPUSH
46768: CALL_OW 72
46772: ST_TO_ADDR
// if not t then
46773: LD_VAR 0 6
46777: NOT
46778: IFFALSE 46782
// continue ;
46780: GO 46639
// for j in tmp do
46782: LD_ADDR_VAR 0 3
46786: PUSH
46787: LD_VAR 0 4
46791: PUSH
46792: FOR_IN
46793: IFFALSE 46823
// if not BuildingStatus ( j ) = bs_idle then
46795: LD_VAR 0 3
46799: PPUSH
46800: CALL_OW 461
46804: PUSH
46805: LD_INT 2
46807: EQUAL
46808: NOT
46809: IFFALSE 46821
// begin busy := true ;
46811: LD_ADDR_VAR 0 8
46815: PUSH
46816: LD_INT 1
46818: ST_TO_ADDR
// break ;
46819: GO 46823
// end ;
46821: GO 46792
46823: POP
46824: POP
// if busy then
46825: LD_VAR 0 8
46829: IFFALSE 46833
// continue ;
46831: GO 46639
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46833: LD_ADDR_VAR 0 7
46837: PUSH
46838: LD_VAR 0 6
46842: PPUSH
46843: LD_INT 35
46845: PUSH
46846: LD_INT 0
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PPUSH
46853: CALL_OW 72
46857: ST_TO_ADDR
// if tw then
46858: LD_VAR 0 7
46862: IFFALSE 46939
// begin tw := tw [ 1 ] ;
46864: LD_ADDR_VAR 0 7
46868: PUSH
46869: LD_VAR 0 7
46873: PUSH
46874: LD_INT 1
46876: ARRAY
46877: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46878: LD_ADDR_VAR 0 9
46882: PUSH
46883: LD_VAR 0 7
46887: PPUSH
46888: LD_EXP 127
46892: PUSH
46893: LD_VAR 0 2
46897: ARRAY
46898: PPUSH
46899: CALL 76985 0 2
46903: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46904: LD_EXP 141
46908: PUSH
46909: LD_VAR 0 2
46913: ARRAY
46914: IFFALSE 46937
// if not weapon in mc_allowed_tower_weapons [ i ] then
46916: LD_VAR 0 9
46920: PUSH
46921: LD_EXP 141
46925: PUSH
46926: LD_VAR 0 2
46930: ARRAY
46931: IN
46932: NOT
46933: IFFALSE 46937
// continue ;
46935: GO 46639
// end else
46937: GO 47002
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46939: LD_ADDR_VAR 0 5
46943: PUSH
46944: LD_EXP 110
46948: PUSH
46949: LD_VAR 0 2
46953: ARRAY
46954: PPUSH
46955: LD_VAR 0 4
46959: PPUSH
46960: CALL 107196 0 2
46964: ST_TO_ADDR
// if not tmp2 then
46965: LD_VAR 0 5
46969: NOT
46970: IFFALSE 46974
// continue ;
46972: GO 46639
// tw := tmp2 [ 1 ] ;
46974: LD_ADDR_VAR 0 7
46978: PUSH
46979: LD_VAR 0 5
46983: PUSH
46984: LD_INT 1
46986: ARRAY
46987: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46988: LD_ADDR_VAR 0 9
46992: PUSH
46993: LD_VAR 0 5
46997: PUSH
46998: LD_INT 2
47000: ARRAY
47001: ST_TO_ADDR
// end ; if not weapon then
47002: LD_VAR 0 9
47006: NOT
47007: IFFALSE 47011
// continue ;
47009: GO 46639
// ComPlaceWeapon ( tw , weapon ) ;
47011: LD_VAR 0 7
47015: PPUSH
47016: LD_VAR 0 9
47020: PPUSH
47021: CALL_OW 148
// end ;
47025: GO 46639
47027: POP
47028: POP
// end ;
47029: LD_VAR 0 1
47033: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47034: LD_INT 0
47036: PPUSH
47037: PPUSH
47038: PPUSH
47039: PPUSH
47040: PPUSH
47041: PPUSH
// if not mc_bases then
47042: LD_EXP 102
47046: NOT
47047: IFFALSE 47051
// exit ;
47049: GO 47827
// for i = 1 to mc_bases do
47051: LD_ADDR_VAR 0 2
47055: PUSH
47056: DOUBLE
47057: LD_INT 1
47059: DEC
47060: ST_TO_ADDR
47061: LD_EXP 102
47065: PUSH
47066: FOR_TO
47067: IFFALSE 47825
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47069: LD_EXP 115
47073: PUSH
47074: LD_VAR 0 2
47078: ARRAY
47079: NOT
47080: PUSH
47081: LD_EXP 115
47085: PUSH
47086: LD_VAR 0 2
47090: ARRAY
47091: PUSH
47092: LD_EXP 116
47096: PUSH
47097: LD_VAR 0 2
47101: ARRAY
47102: EQUAL
47103: OR
47104: PUSH
47105: LD_EXP 125
47109: PUSH
47110: LD_VAR 0 2
47114: ARRAY
47115: OR
47116: IFFALSE 47120
// continue ;
47118: GO 47066
// if mc_miners [ i ] then
47120: LD_EXP 116
47124: PUSH
47125: LD_VAR 0 2
47129: ARRAY
47130: IFFALSE 47512
// begin for j = mc_miners [ i ] downto 1 do
47132: LD_ADDR_VAR 0 3
47136: PUSH
47137: DOUBLE
47138: LD_EXP 116
47142: PUSH
47143: LD_VAR 0 2
47147: ARRAY
47148: INC
47149: ST_TO_ADDR
47150: LD_INT 1
47152: PUSH
47153: FOR_DOWNTO
47154: IFFALSE 47510
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47156: LD_EXP 116
47160: PUSH
47161: LD_VAR 0 2
47165: ARRAY
47166: PUSH
47167: LD_VAR 0 3
47171: ARRAY
47172: PPUSH
47173: CALL_OW 301
47177: PUSH
47178: LD_EXP 116
47182: PUSH
47183: LD_VAR 0 2
47187: ARRAY
47188: PUSH
47189: LD_VAR 0 3
47193: ARRAY
47194: PPUSH
47195: CALL_OW 257
47199: PUSH
47200: LD_INT 1
47202: NONEQUAL
47203: OR
47204: IFFALSE 47267
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47206: LD_ADDR_VAR 0 5
47210: PUSH
47211: LD_EXP 116
47215: PUSH
47216: LD_VAR 0 2
47220: ARRAY
47221: PUSH
47222: LD_EXP 116
47226: PUSH
47227: LD_VAR 0 2
47231: ARRAY
47232: PUSH
47233: LD_VAR 0 3
47237: ARRAY
47238: DIFF
47239: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47240: LD_ADDR_EXP 116
47244: PUSH
47245: LD_EXP 116
47249: PPUSH
47250: LD_VAR 0 2
47254: PPUSH
47255: LD_VAR 0 5
47259: PPUSH
47260: CALL_OW 1
47264: ST_TO_ADDR
// continue ;
47265: GO 47153
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47267: LD_EXP 116
47271: PUSH
47272: LD_VAR 0 2
47276: ARRAY
47277: PUSH
47278: LD_VAR 0 3
47282: ARRAY
47283: PPUSH
47284: CALL_OW 257
47288: PUSH
47289: LD_INT 1
47291: EQUAL
47292: PUSH
47293: LD_EXP 116
47297: PUSH
47298: LD_VAR 0 2
47302: ARRAY
47303: PUSH
47304: LD_VAR 0 3
47308: ARRAY
47309: PPUSH
47310: CALL_OW 459
47314: NOT
47315: AND
47316: PUSH
47317: LD_EXP 116
47321: PUSH
47322: LD_VAR 0 2
47326: ARRAY
47327: PUSH
47328: LD_VAR 0 3
47332: ARRAY
47333: PPUSH
47334: CALL_OW 314
47338: NOT
47339: AND
47340: IFFALSE 47508
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47342: LD_EXP 116
47346: PUSH
47347: LD_VAR 0 2
47351: ARRAY
47352: PUSH
47353: LD_VAR 0 3
47357: ARRAY
47358: PPUSH
47359: CALL_OW 310
47363: IFFALSE 47386
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47365: LD_EXP 116
47369: PUSH
47370: LD_VAR 0 2
47374: ARRAY
47375: PUSH
47376: LD_VAR 0 3
47380: ARRAY
47381: PPUSH
47382: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47386: LD_EXP 116
47390: PUSH
47391: LD_VAR 0 2
47395: ARRAY
47396: PUSH
47397: LD_VAR 0 3
47401: ARRAY
47402: PPUSH
47403: CALL_OW 314
47407: NOT
47408: IFFALSE 47508
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47410: LD_EXP 116
47414: PUSH
47415: LD_VAR 0 2
47419: ARRAY
47420: PUSH
47421: LD_VAR 0 3
47425: ARRAY
47426: PPUSH
47427: LD_EXP 115
47431: PUSH
47432: LD_VAR 0 2
47436: ARRAY
47437: PUSH
47438: LD_VAR 0 3
47442: PUSH
47443: LD_EXP 115
47447: PUSH
47448: LD_VAR 0 2
47452: ARRAY
47453: MOD
47454: PUSH
47455: LD_INT 1
47457: PLUS
47458: ARRAY
47459: PUSH
47460: LD_INT 1
47462: ARRAY
47463: PPUSH
47464: LD_EXP 115
47468: PUSH
47469: LD_VAR 0 2
47473: ARRAY
47474: PUSH
47475: LD_VAR 0 3
47479: PUSH
47480: LD_EXP 115
47484: PUSH
47485: LD_VAR 0 2
47489: ARRAY
47490: MOD
47491: PUSH
47492: LD_INT 1
47494: PLUS
47495: ARRAY
47496: PUSH
47497: LD_INT 2
47499: ARRAY
47500: PPUSH
47501: LD_INT 0
47503: PPUSH
47504: CALL_OW 193
// end ; end ;
47508: GO 47153
47510: POP
47511: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47512: LD_ADDR_VAR 0 5
47516: PUSH
47517: LD_EXP 102
47521: PUSH
47522: LD_VAR 0 2
47526: ARRAY
47527: PPUSH
47528: LD_INT 2
47530: PUSH
47531: LD_INT 30
47533: PUSH
47534: LD_INT 4
47536: PUSH
47537: EMPTY
47538: LIST
47539: LIST
47540: PUSH
47541: LD_INT 30
47543: PUSH
47544: LD_INT 5
47546: PUSH
47547: EMPTY
47548: LIST
47549: LIST
47550: PUSH
47551: LD_INT 30
47553: PUSH
47554: LD_INT 32
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: PUSH
47561: EMPTY
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: PPUSH
47567: CALL_OW 72
47571: ST_TO_ADDR
// if not tmp then
47572: LD_VAR 0 5
47576: NOT
47577: IFFALSE 47581
// continue ;
47579: GO 47066
// list := [ ] ;
47581: LD_ADDR_VAR 0 6
47585: PUSH
47586: EMPTY
47587: ST_TO_ADDR
// for j in tmp do
47588: LD_ADDR_VAR 0 3
47592: PUSH
47593: LD_VAR 0 5
47597: PUSH
47598: FOR_IN
47599: IFFALSE 47668
// begin for k in UnitsInside ( j ) do
47601: LD_ADDR_VAR 0 4
47605: PUSH
47606: LD_VAR 0 3
47610: PPUSH
47611: CALL_OW 313
47615: PUSH
47616: FOR_IN
47617: IFFALSE 47664
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47619: LD_VAR 0 4
47623: PPUSH
47624: CALL_OW 257
47628: PUSH
47629: LD_INT 1
47631: EQUAL
47632: PUSH
47633: LD_VAR 0 4
47637: PPUSH
47638: CALL_OW 459
47642: NOT
47643: AND
47644: IFFALSE 47662
// list := list ^ k ;
47646: LD_ADDR_VAR 0 6
47650: PUSH
47651: LD_VAR 0 6
47655: PUSH
47656: LD_VAR 0 4
47660: ADD
47661: ST_TO_ADDR
47662: GO 47616
47664: POP
47665: POP
// end ;
47666: GO 47598
47668: POP
47669: POP
// list := list diff mc_miners [ i ] ;
47670: LD_ADDR_VAR 0 6
47674: PUSH
47675: LD_VAR 0 6
47679: PUSH
47680: LD_EXP 116
47684: PUSH
47685: LD_VAR 0 2
47689: ARRAY
47690: DIFF
47691: ST_TO_ADDR
// if not list then
47692: LD_VAR 0 6
47696: NOT
47697: IFFALSE 47701
// continue ;
47699: GO 47066
// k := mc_mines [ i ] - mc_miners [ i ] ;
47701: LD_ADDR_VAR 0 4
47705: PUSH
47706: LD_EXP 115
47710: PUSH
47711: LD_VAR 0 2
47715: ARRAY
47716: PUSH
47717: LD_EXP 116
47721: PUSH
47722: LD_VAR 0 2
47726: ARRAY
47727: MINUS
47728: ST_TO_ADDR
// if k > list then
47729: LD_VAR 0 4
47733: PUSH
47734: LD_VAR 0 6
47738: GREATER
47739: IFFALSE 47751
// k := list ;
47741: LD_ADDR_VAR 0 4
47745: PUSH
47746: LD_VAR 0 6
47750: ST_TO_ADDR
// for j = 1 to k do
47751: LD_ADDR_VAR 0 3
47755: PUSH
47756: DOUBLE
47757: LD_INT 1
47759: DEC
47760: ST_TO_ADDR
47761: LD_VAR 0 4
47765: PUSH
47766: FOR_TO
47767: IFFALSE 47821
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47769: LD_ADDR_EXP 116
47773: PUSH
47774: LD_EXP 116
47778: PPUSH
47779: LD_VAR 0 2
47783: PUSH
47784: LD_EXP 116
47788: PUSH
47789: LD_VAR 0 2
47793: ARRAY
47794: PUSH
47795: LD_INT 1
47797: PLUS
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PPUSH
47803: LD_VAR 0 6
47807: PUSH
47808: LD_VAR 0 3
47812: ARRAY
47813: PPUSH
47814: CALL 72015 0 3
47818: ST_TO_ADDR
47819: GO 47766
47821: POP
47822: POP
// end ;
47823: GO 47066
47825: POP
47826: POP
// end ;
47827: LD_VAR 0 1
47831: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47832: LD_INT 0
47834: PPUSH
47835: PPUSH
47836: PPUSH
47837: PPUSH
47838: PPUSH
47839: PPUSH
47840: PPUSH
47841: PPUSH
47842: PPUSH
47843: PPUSH
// if not mc_bases then
47844: LD_EXP 102
47848: NOT
47849: IFFALSE 47853
// exit ;
47851: GO 49603
// for i = 1 to mc_bases do
47853: LD_ADDR_VAR 0 2
47857: PUSH
47858: DOUBLE
47859: LD_INT 1
47861: DEC
47862: ST_TO_ADDR
47863: LD_EXP 102
47867: PUSH
47868: FOR_TO
47869: IFFALSE 49601
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47871: LD_EXP 102
47875: PUSH
47876: LD_VAR 0 2
47880: ARRAY
47881: NOT
47882: PUSH
47883: LD_EXP 109
47887: PUSH
47888: LD_VAR 0 2
47892: ARRAY
47893: OR
47894: IFFALSE 47898
// continue ;
47896: GO 47868
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47898: LD_EXP 118
47902: PUSH
47903: LD_VAR 0 2
47907: ARRAY
47908: NOT
47909: PUSH
47910: LD_EXP 119
47914: PUSH
47915: LD_VAR 0 2
47919: ARRAY
47920: AND
47921: IFFALSE 47959
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47923: LD_ADDR_EXP 119
47927: PUSH
47928: LD_EXP 119
47932: PPUSH
47933: LD_VAR 0 2
47937: PPUSH
47938: EMPTY
47939: PPUSH
47940: CALL_OW 1
47944: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47945: LD_VAR 0 2
47949: PPUSH
47950: LD_INT 107
47952: PPUSH
47953: CALL 38817 0 2
// continue ;
47957: GO 47868
// end ; target := [ ] ;
47959: LD_ADDR_VAR 0 6
47963: PUSH
47964: EMPTY
47965: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47966: LD_ADDR_VAR 0 3
47970: PUSH
47971: DOUBLE
47972: LD_EXP 118
47976: PUSH
47977: LD_VAR 0 2
47981: ARRAY
47982: INC
47983: ST_TO_ADDR
47984: LD_INT 1
47986: PUSH
47987: FOR_DOWNTO
47988: IFFALSE 48248
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47990: LD_EXP 118
47994: PUSH
47995: LD_VAR 0 2
47999: ARRAY
48000: PUSH
48001: LD_VAR 0 3
48005: ARRAY
48006: PUSH
48007: LD_INT 2
48009: ARRAY
48010: PPUSH
48011: LD_EXP 118
48015: PUSH
48016: LD_VAR 0 2
48020: ARRAY
48021: PUSH
48022: LD_VAR 0 3
48026: ARRAY
48027: PUSH
48028: LD_INT 3
48030: ARRAY
48031: PPUSH
48032: CALL_OW 488
48036: PUSH
48037: LD_EXP 118
48041: PUSH
48042: LD_VAR 0 2
48046: ARRAY
48047: PUSH
48048: LD_VAR 0 3
48052: ARRAY
48053: PUSH
48054: LD_INT 2
48056: ARRAY
48057: PPUSH
48058: LD_EXP 118
48062: PUSH
48063: LD_VAR 0 2
48067: ARRAY
48068: PUSH
48069: LD_VAR 0 3
48073: ARRAY
48074: PUSH
48075: LD_INT 3
48077: ARRAY
48078: PPUSH
48079: CALL_OW 284
48083: PUSH
48084: LD_INT 0
48086: EQUAL
48087: AND
48088: IFFALSE 48143
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48090: LD_ADDR_VAR 0 5
48094: PUSH
48095: LD_EXP 118
48099: PUSH
48100: LD_VAR 0 2
48104: ARRAY
48105: PPUSH
48106: LD_VAR 0 3
48110: PPUSH
48111: CALL_OW 3
48115: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48116: LD_ADDR_EXP 118
48120: PUSH
48121: LD_EXP 118
48125: PPUSH
48126: LD_VAR 0 2
48130: PPUSH
48131: LD_VAR 0 5
48135: PPUSH
48136: CALL_OW 1
48140: ST_TO_ADDR
// continue ;
48141: GO 47987
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48143: LD_EXP 102
48147: PUSH
48148: LD_VAR 0 2
48152: ARRAY
48153: PUSH
48154: LD_INT 1
48156: ARRAY
48157: PPUSH
48158: CALL_OW 255
48162: PPUSH
48163: LD_EXP 118
48167: PUSH
48168: LD_VAR 0 2
48172: ARRAY
48173: PUSH
48174: LD_VAR 0 3
48178: ARRAY
48179: PUSH
48180: LD_INT 2
48182: ARRAY
48183: PPUSH
48184: LD_EXP 118
48188: PUSH
48189: LD_VAR 0 2
48193: ARRAY
48194: PUSH
48195: LD_VAR 0 3
48199: ARRAY
48200: PUSH
48201: LD_INT 3
48203: ARRAY
48204: PPUSH
48205: LD_INT 30
48207: PPUSH
48208: CALL 72911 0 4
48212: PUSH
48213: LD_INT 4
48215: ARRAY
48216: PUSH
48217: LD_INT 0
48219: EQUAL
48220: IFFALSE 48246
// begin target := mc_crates [ i ] [ j ] ;
48222: LD_ADDR_VAR 0 6
48226: PUSH
48227: LD_EXP 118
48231: PUSH
48232: LD_VAR 0 2
48236: ARRAY
48237: PUSH
48238: LD_VAR 0 3
48242: ARRAY
48243: ST_TO_ADDR
// break ;
48244: GO 48248
// end ; end ;
48246: GO 47987
48248: POP
48249: POP
// if not target then
48250: LD_VAR 0 6
48254: NOT
48255: IFFALSE 48259
// continue ;
48257: GO 47868
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48259: LD_ADDR_VAR 0 7
48263: PUSH
48264: LD_EXP 121
48268: PUSH
48269: LD_VAR 0 2
48273: ARRAY
48274: PPUSH
48275: LD_INT 2
48277: PUSH
48278: LD_INT 3
48280: PUSH
48281: LD_INT 58
48283: PUSH
48284: EMPTY
48285: LIST
48286: PUSH
48287: EMPTY
48288: LIST
48289: LIST
48290: PUSH
48291: LD_INT 61
48293: PUSH
48294: EMPTY
48295: LIST
48296: PUSH
48297: LD_INT 33
48299: PUSH
48300: LD_INT 5
48302: PUSH
48303: EMPTY
48304: LIST
48305: LIST
48306: PUSH
48307: LD_INT 33
48309: PUSH
48310: LD_INT 3
48312: PUSH
48313: EMPTY
48314: LIST
48315: LIST
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: LIST
48321: LIST
48322: LIST
48323: PUSH
48324: LD_INT 2
48326: PUSH
48327: LD_INT 34
48329: PUSH
48330: LD_INT 32
48332: PUSH
48333: EMPTY
48334: LIST
48335: LIST
48336: PUSH
48337: LD_INT 34
48339: PUSH
48340: LD_INT 51
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PUSH
48347: LD_INT 34
48349: PUSH
48350: LD_INT 12
48352: PUSH
48353: EMPTY
48354: LIST
48355: LIST
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: LIST
48361: LIST
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: PPUSH
48367: CALL_OW 72
48371: ST_TO_ADDR
// if not cargo then
48372: LD_VAR 0 7
48376: NOT
48377: IFFALSE 49020
// begin if mc_crates_collector [ i ] < 5 then
48379: LD_EXP 119
48383: PUSH
48384: LD_VAR 0 2
48388: ARRAY
48389: PUSH
48390: LD_INT 5
48392: LESS
48393: IFFALSE 48759
// begin if mc_ape [ i ] then
48395: LD_EXP 131
48399: PUSH
48400: LD_VAR 0 2
48404: ARRAY
48405: IFFALSE 48452
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48407: LD_ADDR_VAR 0 5
48411: PUSH
48412: LD_EXP 131
48416: PUSH
48417: LD_VAR 0 2
48421: ARRAY
48422: PPUSH
48423: LD_INT 25
48425: PUSH
48426: LD_INT 16
48428: PUSH
48429: EMPTY
48430: LIST
48431: LIST
48432: PUSH
48433: LD_INT 24
48435: PUSH
48436: LD_INT 750
48438: PUSH
48439: EMPTY
48440: LIST
48441: LIST
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PPUSH
48447: CALL_OW 72
48451: ST_TO_ADDR
// if not tmp then
48452: LD_VAR 0 5
48456: NOT
48457: IFFALSE 48504
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48459: LD_ADDR_VAR 0 5
48463: PUSH
48464: LD_EXP 102
48468: PUSH
48469: LD_VAR 0 2
48473: ARRAY
48474: PPUSH
48475: LD_INT 25
48477: PUSH
48478: LD_INT 2
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: PUSH
48485: LD_INT 24
48487: PUSH
48488: LD_INT 750
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: EMPTY
48496: LIST
48497: LIST
48498: PPUSH
48499: CALL_OW 72
48503: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48504: LD_EXP 131
48508: PUSH
48509: LD_VAR 0 2
48513: ARRAY
48514: PUSH
48515: LD_EXP 102
48519: PUSH
48520: LD_VAR 0 2
48524: ARRAY
48525: PPUSH
48526: LD_INT 25
48528: PUSH
48529: LD_INT 2
48531: PUSH
48532: EMPTY
48533: LIST
48534: LIST
48535: PUSH
48536: LD_INT 24
48538: PUSH
48539: LD_INT 750
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PPUSH
48550: CALL_OW 72
48554: AND
48555: PUSH
48556: LD_VAR 0 5
48560: PUSH
48561: LD_INT 5
48563: LESS
48564: AND
48565: IFFALSE 48647
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48567: LD_ADDR_VAR 0 3
48571: PUSH
48572: LD_EXP 102
48576: PUSH
48577: LD_VAR 0 2
48581: ARRAY
48582: PPUSH
48583: LD_INT 25
48585: PUSH
48586: LD_INT 2
48588: PUSH
48589: EMPTY
48590: LIST
48591: LIST
48592: PUSH
48593: LD_INT 24
48595: PUSH
48596: LD_INT 750
48598: PUSH
48599: EMPTY
48600: LIST
48601: LIST
48602: PUSH
48603: EMPTY
48604: LIST
48605: LIST
48606: PPUSH
48607: CALL_OW 72
48611: PUSH
48612: FOR_IN
48613: IFFALSE 48645
// begin tmp := tmp union j ;
48615: LD_ADDR_VAR 0 5
48619: PUSH
48620: LD_VAR 0 5
48624: PUSH
48625: LD_VAR 0 3
48629: UNION
48630: ST_TO_ADDR
// if tmp >= 5 then
48631: LD_VAR 0 5
48635: PUSH
48636: LD_INT 5
48638: GREATEREQUAL
48639: IFFALSE 48643
// break ;
48641: GO 48645
// end ;
48643: GO 48612
48645: POP
48646: POP
// end ; if not tmp then
48647: LD_VAR 0 5
48651: NOT
48652: IFFALSE 48656
// continue ;
48654: GO 47868
// for j in tmp do
48656: LD_ADDR_VAR 0 3
48660: PUSH
48661: LD_VAR 0 5
48665: PUSH
48666: FOR_IN
48667: IFFALSE 48757
// if not GetTag ( j ) then
48669: LD_VAR 0 3
48673: PPUSH
48674: CALL_OW 110
48678: NOT
48679: IFFALSE 48755
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48681: LD_ADDR_EXP 119
48685: PUSH
48686: LD_EXP 119
48690: PPUSH
48691: LD_VAR 0 2
48695: PUSH
48696: LD_EXP 119
48700: PUSH
48701: LD_VAR 0 2
48705: ARRAY
48706: PUSH
48707: LD_INT 1
48709: PLUS
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PPUSH
48715: LD_VAR 0 3
48719: PPUSH
48720: CALL 72015 0 3
48724: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48725: LD_VAR 0 3
48729: PPUSH
48730: LD_INT 107
48732: PPUSH
48733: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48737: LD_EXP 119
48741: PUSH
48742: LD_VAR 0 2
48746: ARRAY
48747: PUSH
48748: LD_INT 5
48750: GREATEREQUAL
48751: IFFALSE 48755
// break ;
48753: GO 48757
// end ;
48755: GO 48666
48757: POP
48758: POP
// end ; if mc_crates_collector [ i ] and target then
48759: LD_EXP 119
48763: PUSH
48764: LD_VAR 0 2
48768: ARRAY
48769: PUSH
48770: LD_VAR 0 6
48774: AND
48775: IFFALSE 49018
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48777: LD_EXP 119
48781: PUSH
48782: LD_VAR 0 2
48786: ARRAY
48787: PUSH
48788: LD_VAR 0 6
48792: PUSH
48793: LD_INT 1
48795: ARRAY
48796: LESS
48797: IFFALSE 48817
// tmp := mc_crates_collector [ i ] else
48799: LD_ADDR_VAR 0 5
48803: PUSH
48804: LD_EXP 119
48808: PUSH
48809: LD_VAR 0 2
48813: ARRAY
48814: ST_TO_ADDR
48815: GO 48831
// tmp := target [ 1 ] ;
48817: LD_ADDR_VAR 0 5
48821: PUSH
48822: LD_VAR 0 6
48826: PUSH
48827: LD_INT 1
48829: ARRAY
48830: ST_TO_ADDR
// k := 0 ;
48831: LD_ADDR_VAR 0 4
48835: PUSH
48836: LD_INT 0
48838: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48839: LD_ADDR_VAR 0 3
48843: PUSH
48844: LD_EXP 119
48848: PUSH
48849: LD_VAR 0 2
48853: ARRAY
48854: PUSH
48855: FOR_IN
48856: IFFALSE 49016
// begin k := k + 1 ;
48858: LD_ADDR_VAR 0 4
48862: PUSH
48863: LD_VAR 0 4
48867: PUSH
48868: LD_INT 1
48870: PLUS
48871: ST_TO_ADDR
// if k > tmp then
48872: LD_VAR 0 4
48876: PUSH
48877: LD_VAR 0 5
48881: GREATER
48882: IFFALSE 48886
// break ;
48884: GO 49016
// if not GetClass ( j ) in [ 2 , 16 ] then
48886: LD_VAR 0 3
48890: PPUSH
48891: CALL_OW 257
48895: PUSH
48896: LD_INT 2
48898: PUSH
48899: LD_INT 16
48901: PUSH
48902: EMPTY
48903: LIST
48904: LIST
48905: IN
48906: NOT
48907: IFFALSE 48960
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48909: LD_ADDR_EXP 119
48913: PUSH
48914: LD_EXP 119
48918: PPUSH
48919: LD_VAR 0 2
48923: PPUSH
48924: LD_EXP 119
48928: PUSH
48929: LD_VAR 0 2
48933: ARRAY
48934: PUSH
48935: LD_VAR 0 3
48939: DIFF
48940: PPUSH
48941: CALL_OW 1
48945: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48946: LD_VAR 0 3
48950: PPUSH
48951: LD_INT 0
48953: PPUSH
48954: CALL_OW 109
// continue ;
48958: GO 48855
// end ; if IsInUnit ( j ) then
48960: LD_VAR 0 3
48964: PPUSH
48965: CALL_OW 310
48969: IFFALSE 48980
// ComExitBuilding ( j ) ;
48971: LD_VAR 0 3
48975: PPUSH
48976: CALL_OW 122
// wait ( 3 ) ;
48980: LD_INT 3
48982: PPUSH
48983: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48987: LD_VAR 0 3
48991: PPUSH
48992: LD_VAR 0 6
48996: PUSH
48997: LD_INT 2
48999: ARRAY
49000: PPUSH
49001: LD_VAR 0 6
49005: PUSH
49006: LD_INT 3
49008: ARRAY
49009: PPUSH
49010: CALL_OW 117
// end ;
49014: GO 48855
49016: POP
49017: POP
// end ; end else
49018: GO 49599
// begin for j in cargo do
49020: LD_ADDR_VAR 0 3
49024: PUSH
49025: LD_VAR 0 7
49029: PUSH
49030: FOR_IN
49031: IFFALSE 49597
// begin if GetTag ( j ) <> 0 then
49033: LD_VAR 0 3
49037: PPUSH
49038: CALL_OW 110
49042: PUSH
49043: LD_INT 0
49045: NONEQUAL
49046: IFFALSE 49050
// continue ;
49048: GO 49030
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49050: LD_VAR 0 3
49054: PPUSH
49055: CALL_OW 256
49059: PUSH
49060: LD_INT 1000
49062: LESS
49063: PUSH
49064: LD_VAR 0 3
49068: PPUSH
49069: LD_EXP 126
49073: PUSH
49074: LD_VAR 0 2
49078: ARRAY
49079: PPUSH
49080: CALL_OW 308
49084: NOT
49085: AND
49086: IFFALSE 49108
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49088: LD_VAR 0 3
49092: PPUSH
49093: LD_EXP 126
49097: PUSH
49098: LD_VAR 0 2
49102: ARRAY
49103: PPUSH
49104: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49108: LD_VAR 0 3
49112: PPUSH
49113: CALL_OW 256
49117: PUSH
49118: LD_INT 1000
49120: LESS
49121: PUSH
49122: LD_VAR 0 3
49126: PPUSH
49127: LD_EXP 126
49131: PUSH
49132: LD_VAR 0 2
49136: ARRAY
49137: PPUSH
49138: CALL_OW 308
49142: AND
49143: IFFALSE 49147
// continue ;
49145: GO 49030
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49147: LD_VAR 0 3
49151: PPUSH
49152: CALL_OW 262
49156: PUSH
49157: LD_INT 2
49159: EQUAL
49160: PUSH
49161: LD_VAR 0 3
49165: PPUSH
49166: CALL_OW 261
49170: PUSH
49171: LD_INT 15
49173: LESS
49174: AND
49175: IFFALSE 49179
// continue ;
49177: GO 49030
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49179: LD_VAR 0 3
49183: PPUSH
49184: CALL_OW 262
49188: PUSH
49189: LD_INT 1
49191: EQUAL
49192: PUSH
49193: LD_VAR 0 3
49197: PPUSH
49198: CALL_OW 261
49202: PUSH
49203: LD_INT 10
49205: LESS
49206: AND
49207: IFFALSE 49536
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49209: LD_ADDR_VAR 0 8
49213: PUSH
49214: LD_EXP 102
49218: PUSH
49219: LD_VAR 0 2
49223: ARRAY
49224: PPUSH
49225: LD_INT 2
49227: PUSH
49228: LD_INT 30
49230: PUSH
49231: LD_INT 0
49233: PUSH
49234: EMPTY
49235: LIST
49236: LIST
49237: PUSH
49238: LD_INT 30
49240: PUSH
49241: LD_INT 1
49243: PUSH
49244: EMPTY
49245: LIST
49246: LIST
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: LIST
49252: PPUSH
49253: CALL_OW 72
49257: ST_TO_ADDR
// if not depot then
49258: LD_VAR 0 8
49262: NOT
49263: IFFALSE 49267
// continue ;
49265: GO 49030
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49267: LD_VAR 0 3
49271: PPUSH
49272: LD_VAR 0 8
49276: PPUSH
49277: LD_VAR 0 3
49281: PPUSH
49282: CALL_OW 74
49286: PPUSH
49287: CALL_OW 296
49291: PUSH
49292: LD_INT 6
49294: LESS
49295: IFFALSE 49311
// SetFuel ( j , 100 ) else
49297: LD_VAR 0 3
49301: PPUSH
49302: LD_INT 100
49304: PPUSH
49305: CALL_OW 240
49309: GO 49536
// if GetFuel ( j ) = 0 then
49311: LD_VAR 0 3
49315: PPUSH
49316: CALL_OW 261
49320: PUSH
49321: LD_INT 0
49323: EQUAL
49324: IFFALSE 49536
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49326: LD_ADDR_EXP 121
49330: PUSH
49331: LD_EXP 121
49335: PPUSH
49336: LD_VAR 0 2
49340: PPUSH
49341: LD_EXP 121
49345: PUSH
49346: LD_VAR 0 2
49350: ARRAY
49351: PUSH
49352: LD_VAR 0 3
49356: DIFF
49357: PPUSH
49358: CALL_OW 1
49362: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49363: LD_VAR 0 3
49367: PPUSH
49368: CALL_OW 263
49372: PUSH
49373: LD_INT 1
49375: EQUAL
49376: IFFALSE 49392
// ComExitVehicle ( IsInUnit ( j ) ) ;
49378: LD_VAR 0 3
49382: PPUSH
49383: CALL_OW 310
49387: PPUSH
49388: CALL_OW 121
// if GetControl ( j ) = control_remote then
49392: LD_VAR 0 3
49396: PPUSH
49397: CALL_OW 263
49401: PUSH
49402: LD_INT 2
49404: EQUAL
49405: IFFALSE 49416
// ComUnlink ( j ) ;
49407: LD_VAR 0 3
49411: PPUSH
49412: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49416: LD_ADDR_VAR 0 9
49420: PUSH
49421: LD_VAR 0 2
49425: PPUSH
49426: LD_INT 3
49428: PPUSH
49429: CALL 58889 0 2
49433: ST_TO_ADDR
// if fac then
49434: LD_VAR 0 9
49438: IFFALSE 49534
// begin for k in fac do
49440: LD_ADDR_VAR 0 4
49444: PUSH
49445: LD_VAR 0 9
49449: PUSH
49450: FOR_IN
49451: IFFALSE 49532
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49453: LD_ADDR_VAR 0 10
49457: PUSH
49458: LD_VAR 0 9
49462: PPUSH
49463: LD_VAR 0 3
49467: PPUSH
49468: CALL_OW 265
49472: PPUSH
49473: LD_VAR 0 3
49477: PPUSH
49478: CALL_OW 262
49482: PPUSH
49483: LD_VAR 0 3
49487: PPUSH
49488: CALL_OW 263
49492: PPUSH
49493: LD_VAR 0 3
49497: PPUSH
49498: CALL_OW 264
49502: PPUSH
49503: CALL 69547 0 5
49507: ST_TO_ADDR
// if components then
49508: LD_VAR 0 10
49512: IFFALSE 49530
// begin MC_InsertProduceList ( i , components ) ;
49514: LD_VAR 0 2
49518: PPUSH
49519: LD_VAR 0 10
49523: PPUSH
49524: CALL 58434 0 2
// break ;
49528: GO 49532
// end ; end ;
49530: GO 49450
49532: POP
49533: POP
// end ; continue ;
49534: GO 49030
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49536: LD_VAR 0 3
49540: PPUSH
49541: LD_INT 1
49543: PPUSH
49544: CALL_OW 289
49548: PUSH
49549: LD_INT 100
49551: LESS
49552: PUSH
49553: LD_VAR 0 3
49557: PPUSH
49558: CALL_OW 314
49562: NOT
49563: AND
49564: IFFALSE 49593
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49566: LD_VAR 0 3
49570: PPUSH
49571: LD_VAR 0 6
49575: PUSH
49576: LD_INT 2
49578: ARRAY
49579: PPUSH
49580: LD_VAR 0 6
49584: PUSH
49585: LD_INT 3
49587: ARRAY
49588: PPUSH
49589: CALL_OW 117
// break ;
49593: GO 49597
// end ;
49595: GO 49030
49597: POP
49598: POP
// end ; end ;
49599: GO 47868
49601: POP
49602: POP
// end ;
49603: LD_VAR 0 1
49607: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49608: LD_INT 0
49610: PPUSH
49611: PPUSH
49612: PPUSH
49613: PPUSH
// if not mc_bases then
49614: LD_EXP 102
49618: NOT
49619: IFFALSE 49623
// exit ;
49621: GO 49784
// for i = 1 to mc_bases do
49623: LD_ADDR_VAR 0 2
49627: PUSH
49628: DOUBLE
49629: LD_INT 1
49631: DEC
49632: ST_TO_ADDR
49633: LD_EXP 102
49637: PUSH
49638: FOR_TO
49639: IFFALSE 49782
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49641: LD_ADDR_VAR 0 4
49645: PUSH
49646: LD_EXP 121
49650: PUSH
49651: LD_VAR 0 2
49655: ARRAY
49656: PUSH
49657: LD_EXP 124
49661: PUSH
49662: LD_VAR 0 2
49666: ARRAY
49667: UNION
49668: PPUSH
49669: LD_INT 33
49671: PUSH
49672: LD_INT 2
49674: PUSH
49675: EMPTY
49676: LIST
49677: LIST
49678: PPUSH
49679: CALL_OW 72
49683: ST_TO_ADDR
// if tmp then
49684: LD_VAR 0 4
49688: IFFALSE 49780
// for j in tmp do
49690: LD_ADDR_VAR 0 3
49694: PUSH
49695: LD_VAR 0 4
49699: PUSH
49700: FOR_IN
49701: IFFALSE 49778
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49703: LD_VAR 0 3
49707: PPUSH
49708: CALL_OW 312
49712: NOT
49713: PUSH
49714: LD_VAR 0 3
49718: PPUSH
49719: CALL_OW 256
49723: PUSH
49724: LD_INT 250
49726: GREATEREQUAL
49727: AND
49728: IFFALSE 49741
// Connect ( j ) else
49730: LD_VAR 0 3
49734: PPUSH
49735: CALL 74948 0 1
49739: GO 49776
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49741: LD_VAR 0 3
49745: PPUSH
49746: CALL_OW 256
49750: PUSH
49751: LD_INT 250
49753: LESS
49754: PUSH
49755: LD_VAR 0 3
49759: PPUSH
49760: CALL_OW 312
49764: AND
49765: IFFALSE 49776
// ComUnlink ( j ) ;
49767: LD_VAR 0 3
49771: PPUSH
49772: CALL_OW 136
49776: GO 49700
49778: POP
49779: POP
// end ;
49780: GO 49638
49782: POP
49783: POP
// end ;
49784: LD_VAR 0 1
49788: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49789: LD_INT 0
49791: PPUSH
49792: PPUSH
49793: PPUSH
49794: PPUSH
49795: PPUSH
// if not mc_bases then
49796: LD_EXP 102
49800: NOT
49801: IFFALSE 49805
// exit ;
49803: GO 50250
// for i = 1 to mc_bases do
49805: LD_ADDR_VAR 0 2
49809: PUSH
49810: DOUBLE
49811: LD_INT 1
49813: DEC
49814: ST_TO_ADDR
49815: LD_EXP 102
49819: PUSH
49820: FOR_TO
49821: IFFALSE 50248
// begin if not mc_produce [ i ] then
49823: LD_EXP 123
49827: PUSH
49828: LD_VAR 0 2
49832: ARRAY
49833: NOT
49834: IFFALSE 49838
// continue ;
49836: GO 49820
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49838: LD_ADDR_VAR 0 5
49842: PUSH
49843: LD_EXP 102
49847: PUSH
49848: LD_VAR 0 2
49852: ARRAY
49853: PPUSH
49854: LD_INT 30
49856: PUSH
49857: LD_INT 3
49859: PUSH
49860: EMPTY
49861: LIST
49862: LIST
49863: PPUSH
49864: CALL_OW 72
49868: ST_TO_ADDR
// if not fac then
49869: LD_VAR 0 5
49873: NOT
49874: IFFALSE 49878
// continue ;
49876: GO 49820
// for j in fac do
49878: LD_ADDR_VAR 0 3
49882: PUSH
49883: LD_VAR 0 5
49887: PUSH
49888: FOR_IN
49889: IFFALSE 50244
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49891: LD_VAR 0 3
49895: PPUSH
49896: CALL_OW 461
49900: PUSH
49901: LD_INT 2
49903: NONEQUAL
49904: PUSH
49905: LD_VAR 0 3
49909: PPUSH
49910: LD_INT 15
49912: PPUSH
49913: CALL 74608 0 2
49917: PUSH
49918: LD_INT 4
49920: ARRAY
49921: OR
49922: IFFALSE 49926
// continue ;
49924: GO 49888
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49926: LD_VAR 0 3
49930: PPUSH
49931: LD_EXP 123
49935: PUSH
49936: LD_VAR 0 2
49940: ARRAY
49941: PUSH
49942: LD_INT 1
49944: ARRAY
49945: PUSH
49946: LD_INT 1
49948: ARRAY
49949: PPUSH
49950: LD_EXP 123
49954: PUSH
49955: LD_VAR 0 2
49959: ARRAY
49960: PUSH
49961: LD_INT 1
49963: ARRAY
49964: PUSH
49965: LD_INT 2
49967: ARRAY
49968: PPUSH
49969: LD_EXP 123
49973: PUSH
49974: LD_VAR 0 2
49978: ARRAY
49979: PUSH
49980: LD_INT 1
49982: ARRAY
49983: PUSH
49984: LD_INT 3
49986: ARRAY
49987: PPUSH
49988: LD_EXP 123
49992: PUSH
49993: LD_VAR 0 2
49997: ARRAY
49998: PUSH
49999: LD_INT 1
50001: ARRAY
50002: PUSH
50003: LD_INT 4
50005: ARRAY
50006: PPUSH
50007: CALL_OW 448
50011: PUSH
50012: LD_VAR 0 3
50016: PPUSH
50017: LD_EXP 123
50021: PUSH
50022: LD_VAR 0 2
50026: ARRAY
50027: PUSH
50028: LD_INT 1
50030: ARRAY
50031: PUSH
50032: LD_INT 1
50034: ARRAY
50035: PUSH
50036: LD_EXP 123
50040: PUSH
50041: LD_VAR 0 2
50045: ARRAY
50046: PUSH
50047: LD_INT 1
50049: ARRAY
50050: PUSH
50051: LD_INT 2
50053: ARRAY
50054: PUSH
50055: LD_EXP 123
50059: PUSH
50060: LD_VAR 0 2
50064: ARRAY
50065: PUSH
50066: LD_INT 1
50068: ARRAY
50069: PUSH
50070: LD_INT 3
50072: ARRAY
50073: PUSH
50074: LD_EXP 123
50078: PUSH
50079: LD_VAR 0 2
50083: ARRAY
50084: PUSH
50085: LD_INT 1
50087: ARRAY
50088: PUSH
50089: LD_INT 4
50091: ARRAY
50092: PUSH
50093: EMPTY
50094: LIST
50095: LIST
50096: LIST
50097: LIST
50098: PPUSH
50099: CALL 78279 0 2
50103: AND
50104: IFFALSE 50242
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50106: LD_VAR 0 3
50110: PPUSH
50111: LD_EXP 123
50115: PUSH
50116: LD_VAR 0 2
50120: ARRAY
50121: PUSH
50122: LD_INT 1
50124: ARRAY
50125: PUSH
50126: LD_INT 1
50128: ARRAY
50129: PPUSH
50130: LD_EXP 123
50134: PUSH
50135: LD_VAR 0 2
50139: ARRAY
50140: PUSH
50141: LD_INT 1
50143: ARRAY
50144: PUSH
50145: LD_INT 2
50147: ARRAY
50148: PPUSH
50149: LD_EXP 123
50153: PUSH
50154: LD_VAR 0 2
50158: ARRAY
50159: PUSH
50160: LD_INT 1
50162: ARRAY
50163: PUSH
50164: LD_INT 3
50166: ARRAY
50167: PPUSH
50168: LD_EXP 123
50172: PUSH
50173: LD_VAR 0 2
50177: ARRAY
50178: PUSH
50179: LD_INT 1
50181: ARRAY
50182: PUSH
50183: LD_INT 4
50185: ARRAY
50186: PPUSH
50187: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50191: LD_ADDR_VAR 0 4
50195: PUSH
50196: LD_EXP 123
50200: PUSH
50201: LD_VAR 0 2
50205: ARRAY
50206: PPUSH
50207: LD_INT 1
50209: PPUSH
50210: CALL_OW 3
50214: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50215: LD_ADDR_EXP 123
50219: PUSH
50220: LD_EXP 123
50224: PPUSH
50225: LD_VAR 0 2
50229: PPUSH
50230: LD_VAR 0 4
50234: PPUSH
50235: CALL_OW 1
50239: ST_TO_ADDR
// break ;
50240: GO 50244
// end ; end ;
50242: GO 49888
50244: POP
50245: POP
// end ;
50246: GO 49820
50248: POP
50249: POP
// end ;
50250: LD_VAR 0 1
50254: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50255: LD_INT 0
50257: PPUSH
50258: PPUSH
50259: PPUSH
// if not mc_bases then
50260: LD_EXP 102
50264: NOT
50265: IFFALSE 50269
// exit ;
50267: GO 50358
// for i = 1 to mc_bases do
50269: LD_ADDR_VAR 0 2
50273: PUSH
50274: DOUBLE
50275: LD_INT 1
50277: DEC
50278: ST_TO_ADDR
50279: LD_EXP 102
50283: PUSH
50284: FOR_TO
50285: IFFALSE 50356
// begin if mc_attack [ i ] then
50287: LD_EXP 122
50291: PUSH
50292: LD_VAR 0 2
50296: ARRAY
50297: IFFALSE 50354
// begin tmp := mc_attack [ i ] [ 1 ] ;
50299: LD_ADDR_VAR 0 3
50303: PUSH
50304: LD_EXP 122
50308: PUSH
50309: LD_VAR 0 2
50313: ARRAY
50314: PUSH
50315: LD_INT 1
50317: ARRAY
50318: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50319: LD_ADDR_EXP 122
50323: PUSH
50324: LD_EXP 122
50328: PPUSH
50329: LD_VAR 0 2
50333: PPUSH
50334: EMPTY
50335: PPUSH
50336: CALL_OW 1
50340: ST_TO_ADDR
// Attack ( tmp ) ;
50341: LD_VAR 0 3
50345: PPUSH
50346: CALL 100469 0 1
// exit ;
50350: POP
50351: POP
50352: GO 50358
// end ; end ;
50354: GO 50284
50356: POP
50357: POP
// end ;
50358: LD_VAR 0 1
50362: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50363: LD_INT 0
50365: PPUSH
50366: PPUSH
50367: PPUSH
50368: PPUSH
50369: PPUSH
50370: PPUSH
50371: PPUSH
// if not mc_bases then
50372: LD_EXP 102
50376: NOT
50377: IFFALSE 50381
// exit ;
50379: GO 50963
// for i = 1 to mc_bases do
50381: LD_ADDR_VAR 0 2
50385: PUSH
50386: DOUBLE
50387: LD_INT 1
50389: DEC
50390: ST_TO_ADDR
50391: LD_EXP 102
50395: PUSH
50396: FOR_TO
50397: IFFALSE 50961
// begin if not mc_bases [ i ] then
50399: LD_EXP 102
50403: PUSH
50404: LD_VAR 0 2
50408: ARRAY
50409: NOT
50410: IFFALSE 50414
// continue ;
50412: GO 50396
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50414: LD_ADDR_VAR 0 7
50418: PUSH
50419: LD_EXP 102
50423: PUSH
50424: LD_VAR 0 2
50428: ARRAY
50429: PUSH
50430: LD_INT 1
50432: ARRAY
50433: PPUSH
50434: CALL 68851 0 1
50438: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50439: LD_ADDR_EXP 125
50443: PUSH
50444: LD_EXP 125
50448: PPUSH
50449: LD_VAR 0 2
50453: PPUSH
50454: LD_EXP 102
50458: PUSH
50459: LD_VAR 0 2
50463: ARRAY
50464: PUSH
50465: LD_INT 1
50467: ARRAY
50468: PPUSH
50469: CALL_OW 255
50473: PPUSH
50474: LD_EXP 127
50478: PUSH
50479: LD_VAR 0 2
50483: ARRAY
50484: PPUSH
50485: CALL 66405 0 2
50489: PPUSH
50490: CALL_OW 1
50494: ST_TO_ADDR
// if not mc_scan [ i ] then
50495: LD_EXP 125
50499: PUSH
50500: LD_VAR 0 2
50504: ARRAY
50505: NOT
50506: IFFALSE 50661
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50508: LD_ADDR_VAR 0 4
50512: PUSH
50513: LD_EXP 102
50517: PUSH
50518: LD_VAR 0 2
50522: ARRAY
50523: PPUSH
50524: LD_INT 2
50526: PUSH
50527: LD_INT 25
50529: PUSH
50530: LD_INT 5
50532: PUSH
50533: EMPTY
50534: LIST
50535: LIST
50536: PUSH
50537: LD_INT 25
50539: PUSH
50540: LD_INT 8
50542: PUSH
50543: EMPTY
50544: LIST
50545: LIST
50546: PUSH
50547: LD_INT 25
50549: PUSH
50550: LD_INT 9
50552: PUSH
50553: EMPTY
50554: LIST
50555: LIST
50556: PUSH
50557: EMPTY
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: PPUSH
50563: CALL_OW 72
50567: ST_TO_ADDR
// if not tmp then
50568: LD_VAR 0 4
50572: NOT
50573: IFFALSE 50577
// continue ;
50575: GO 50396
// for j in tmp do
50577: LD_ADDR_VAR 0 3
50581: PUSH
50582: LD_VAR 0 4
50586: PUSH
50587: FOR_IN
50588: IFFALSE 50659
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50590: LD_VAR 0 3
50594: PPUSH
50595: CALL_OW 310
50599: PPUSH
50600: CALL_OW 266
50604: PUSH
50605: LD_INT 5
50607: EQUAL
50608: PUSH
50609: LD_VAR 0 3
50613: PPUSH
50614: CALL_OW 257
50618: PUSH
50619: LD_INT 1
50621: EQUAL
50622: AND
50623: PUSH
50624: LD_VAR 0 3
50628: PPUSH
50629: CALL_OW 459
50633: NOT
50634: AND
50635: PUSH
50636: LD_VAR 0 7
50640: AND
50641: IFFALSE 50657
// ComChangeProfession ( j , class ) ;
50643: LD_VAR 0 3
50647: PPUSH
50648: LD_VAR 0 7
50652: PPUSH
50653: CALL_OW 123
50657: GO 50587
50659: POP
50660: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50661: LD_EXP 125
50665: PUSH
50666: LD_VAR 0 2
50670: ARRAY
50671: PUSH
50672: LD_EXP 124
50676: PUSH
50677: LD_VAR 0 2
50681: ARRAY
50682: NOT
50683: AND
50684: PUSH
50685: LD_EXP 102
50689: PUSH
50690: LD_VAR 0 2
50694: ARRAY
50695: PPUSH
50696: LD_INT 30
50698: PUSH
50699: LD_INT 32
50701: PUSH
50702: EMPTY
50703: LIST
50704: LIST
50705: PPUSH
50706: CALL_OW 72
50710: NOT
50711: AND
50712: PUSH
50713: LD_EXP 102
50717: PUSH
50718: LD_VAR 0 2
50722: ARRAY
50723: PPUSH
50724: LD_INT 2
50726: PUSH
50727: LD_INT 30
50729: PUSH
50730: LD_INT 4
50732: PUSH
50733: EMPTY
50734: LIST
50735: LIST
50736: PUSH
50737: LD_INT 30
50739: PUSH
50740: LD_INT 5
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: LIST
50751: PPUSH
50752: CALL_OW 72
50756: NOT
50757: AND
50758: IFFALSE 50890
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50760: LD_ADDR_VAR 0 4
50764: PUSH
50765: LD_EXP 102
50769: PUSH
50770: LD_VAR 0 2
50774: ARRAY
50775: PPUSH
50776: LD_INT 2
50778: PUSH
50779: LD_INT 25
50781: PUSH
50782: LD_INT 1
50784: PUSH
50785: EMPTY
50786: LIST
50787: LIST
50788: PUSH
50789: LD_INT 25
50791: PUSH
50792: LD_INT 5
50794: PUSH
50795: EMPTY
50796: LIST
50797: LIST
50798: PUSH
50799: LD_INT 25
50801: PUSH
50802: LD_INT 8
50804: PUSH
50805: EMPTY
50806: LIST
50807: LIST
50808: PUSH
50809: LD_INT 25
50811: PUSH
50812: LD_INT 9
50814: PUSH
50815: EMPTY
50816: LIST
50817: LIST
50818: PUSH
50819: EMPTY
50820: LIST
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: PPUSH
50826: CALL_OW 72
50830: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50831: LD_ADDR_VAR 0 4
50835: PUSH
50836: LD_VAR 0 4
50840: PUSH
50841: LD_VAR 0 4
50845: PPUSH
50846: LD_INT 18
50848: PPUSH
50849: CALL 105285 0 2
50853: DIFF
50854: ST_TO_ADDR
// if tmp then
50855: LD_VAR 0 4
50859: IFFALSE 50890
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50861: LD_VAR 0 2
50865: PPUSH
50866: LD_VAR 0 4
50870: PPUSH
50871: LD_EXP 127
50875: PUSH
50876: LD_VAR 0 2
50880: ARRAY
50881: PPUSH
50882: CALL 66440 0 3
// exit ;
50886: POP
50887: POP
50888: GO 50963
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50890: LD_EXP 125
50894: PUSH
50895: LD_VAR 0 2
50899: ARRAY
50900: PUSH
50901: LD_EXP 124
50905: PUSH
50906: LD_VAR 0 2
50910: ARRAY
50911: AND
50912: IFFALSE 50959
// begin tmp := mc_defender [ i ] ;
50914: LD_ADDR_VAR 0 4
50918: PUSH
50919: LD_EXP 124
50923: PUSH
50924: LD_VAR 0 2
50928: ARRAY
50929: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50930: LD_VAR 0 2
50934: PPUSH
50935: LD_VAR 0 4
50939: PPUSH
50940: LD_EXP 125
50944: PUSH
50945: LD_VAR 0 2
50949: ARRAY
50950: PPUSH
50951: CALL 67001 0 3
// exit ;
50955: POP
50956: POP
50957: GO 50963
// end ; end ;
50959: GO 50396
50961: POP
50962: POP
// end ;
50963: LD_VAR 0 1
50967: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50968: LD_INT 0
50970: PPUSH
50971: PPUSH
50972: PPUSH
50973: PPUSH
50974: PPUSH
50975: PPUSH
50976: PPUSH
50977: PPUSH
50978: PPUSH
50979: PPUSH
50980: PPUSH
// if not mc_bases then
50981: LD_EXP 102
50985: NOT
50986: IFFALSE 50990
// exit ;
50988: GO 52077
// for i = 1 to mc_bases do
50990: LD_ADDR_VAR 0 2
50994: PUSH
50995: DOUBLE
50996: LD_INT 1
50998: DEC
50999: ST_TO_ADDR
51000: LD_EXP 102
51004: PUSH
51005: FOR_TO
51006: IFFALSE 52075
// begin tmp := mc_lab [ i ] ;
51008: LD_ADDR_VAR 0 6
51012: PUSH
51013: LD_EXP 135
51017: PUSH
51018: LD_VAR 0 2
51022: ARRAY
51023: ST_TO_ADDR
// if not tmp then
51024: LD_VAR 0 6
51028: NOT
51029: IFFALSE 51033
// continue ;
51031: GO 51005
// idle_lab := 0 ;
51033: LD_ADDR_VAR 0 11
51037: PUSH
51038: LD_INT 0
51040: ST_TO_ADDR
// for j in tmp do
51041: LD_ADDR_VAR 0 3
51045: PUSH
51046: LD_VAR 0 6
51050: PUSH
51051: FOR_IN
51052: IFFALSE 52071
// begin researching := false ;
51054: LD_ADDR_VAR 0 10
51058: PUSH
51059: LD_INT 0
51061: ST_TO_ADDR
// side := GetSide ( j ) ;
51062: LD_ADDR_VAR 0 4
51066: PUSH
51067: LD_VAR 0 3
51071: PPUSH
51072: CALL_OW 255
51076: ST_TO_ADDR
// if not mc_tech [ side ] then
51077: LD_EXP 129
51081: PUSH
51082: LD_VAR 0 4
51086: ARRAY
51087: NOT
51088: IFFALSE 51092
// continue ;
51090: GO 51051
// if BuildingStatus ( j ) = bs_idle then
51092: LD_VAR 0 3
51096: PPUSH
51097: CALL_OW 461
51101: PUSH
51102: LD_INT 2
51104: EQUAL
51105: IFFALSE 51293
// begin if idle_lab and UnitsInside ( j ) < 6 then
51107: LD_VAR 0 11
51111: PUSH
51112: LD_VAR 0 3
51116: PPUSH
51117: CALL_OW 313
51121: PUSH
51122: LD_INT 6
51124: LESS
51125: AND
51126: IFFALSE 51197
// begin tmp2 := UnitsInside ( idle_lab ) ;
51128: LD_ADDR_VAR 0 9
51132: PUSH
51133: LD_VAR 0 11
51137: PPUSH
51138: CALL_OW 313
51142: ST_TO_ADDR
// if tmp2 then
51143: LD_VAR 0 9
51147: IFFALSE 51189
// for x in tmp2 do
51149: LD_ADDR_VAR 0 7
51153: PUSH
51154: LD_VAR 0 9
51158: PUSH
51159: FOR_IN
51160: IFFALSE 51187
// begin ComExitBuilding ( x ) ;
51162: LD_VAR 0 7
51166: PPUSH
51167: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51171: LD_VAR 0 7
51175: PPUSH
51176: LD_VAR 0 3
51180: PPUSH
51181: CALL_OW 180
// end ;
51185: GO 51159
51187: POP
51188: POP
// idle_lab := 0 ;
51189: LD_ADDR_VAR 0 11
51193: PUSH
51194: LD_INT 0
51196: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51197: LD_ADDR_VAR 0 5
51201: PUSH
51202: LD_EXP 129
51206: PUSH
51207: LD_VAR 0 4
51211: ARRAY
51212: PUSH
51213: FOR_IN
51214: IFFALSE 51274
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51216: LD_VAR 0 3
51220: PPUSH
51221: LD_VAR 0 5
51225: PPUSH
51226: CALL_OW 430
51230: PUSH
51231: LD_VAR 0 4
51235: PPUSH
51236: LD_VAR 0 5
51240: PPUSH
51241: CALL 65510 0 2
51245: AND
51246: IFFALSE 51272
// begin researching := true ;
51248: LD_ADDR_VAR 0 10
51252: PUSH
51253: LD_INT 1
51255: ST_TO_ADDR
// ComResearch ( j , t ) ;
51256: LD_VAR 0 3
51260: PPUSH
51261: LD_VAR 0 5
51265: PPUSH
51266: CALL_OW 124
// break ;
51270: GO 51274
// end ;
51272: GO 51213
51274: POP
51275: POP
// if not researching then
51276: LD_VAR 0 10
51280: NOT
51281: IFFALSE 51293
// idle_lab := j ;
51283: LD_ADDR_VAR 0 11
51287: PUSH
51288: LD_VAR 0 3
51292: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51293: LD_VAR 0 3
51297: PPUSH
51298: CALL_OW 461
51302: PUSH
51303: LD_INT 10
51305: EQUAL
51306: IFFALSE 51894
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51308: LD_EXP 131
51312: PUSH
51313: LD_VAR 0 2
51317: ARRAY
51318: NOT
51319: PUSH
51320: LD_EXP 132
51324: PUSH
51325: LD_VAR 0 2
51329: ARRAY
51330: NOT
51331: AND
51332: PUSH
51333: LD_EXP 129
51337: PUSH
51338: LD_VAR 0 4
51342: ARRAY
51343: PUSH
51344: LD_INT 1
51346: GREATER
51347: AND
51348: IFFALSE 51479
// begin ComCancel ( j ) ;
51350: LD_VAR 0 3
51354: PPUSH
51355: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51359: LD_ADDR_EXP 129
51363: PUSH
51364: LD_EXP 129
51368: PPUSH
51369: LD_VAR 0 4
51373: PPUSH
51374: LD_EXP 129
51378: PUSH
51379: LD_VAR 0 4
51383: ARRAY
51384: PPUSH
51385: LD_EXP 129
51389: PUSH
51390: LD_VAR 0 4
51394: ARRAY
51395: PUSH
51396: LD_INT 1
51398: MINUS
51399: PPUSH
51400: LD_EXP 129
51404: PUSH
51405: LD_VAR 0 4
51409: ARRAY
51410: PPUSH
51411: LD_INT 0
51413: PPUSH
51414: CALL 71433 0 4
51418: PPUSH
51419: CALL_OW 1
51423: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51424: LD_ADDR_EXP 129
51428: PUSH
51429: LD_EXP 129
51433: PPUSH
51434: LD_VAR 0 4
51438: PPUSH
51439: LD_EXP 129
51443: PUSH
51444: LD_VAR 0 4
51448: ARRAY
51449: PPUSH
51450: LD_EXP 129
51454: PUSH
51455: LD_VAR 0 4
51459: ARRAY
51460: PPUSH
51461: LD_INT 1
51463: PPUSH
51464: LD_INT 0
51466: PPUSH
51467: CALL 71433 0 4
51471: PPUSH
51472: CALL_OW 1
51476: ST_TO_ADDR
// continue ;
51477: GO 51051
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51479: LD_EXP 131
51483: PUSH
51484: LD_VAR 0 2
51488: ARRAY
51489: PUSH
51490: LD_EXP 132
51494: PUSH
51495: LD_VAR 0 2
51499: ARRAY
51500: NOT
51501: AND
51502: IFFALSE 51629
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51504: LD_ADDR_EXP 132
51508: PUSH
51509: LD_EXP 132
51513: PPUSH
51514: LD_VAR 0 2
51518: PUSH
51519: LD_EXP 132
51523: PUSH
51524: LD_VAR 0 2
51528: ARRAY
51529: PUSH
51530: LD_INT 1
51532: PLUS
51533: PUSH
51534: EMPTY
51535: LIST
51536: LIST
51537: PPUSH
51538: LD_EXP 131
51542: PUSH
51543: LD_VAR 0 2
51547: ARRAY
51548: PUSH
51549: LD_INT 1
51551: ARRAY
51552: PPUSH
51553: CALL 72015 0 3
51557: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51558: LD_EXP 131
51562: PUSH
51563: LD_VAR 0 2
51567: ARRAY
51568: PUSH
51569: LD_INT 1
51571: ARRAY
51572: PPUSH
51573: LD_INT 112
51575: PPUSH
51576: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51580: LD_ADDR_VAR 0 9
51584: PUSH
51585: LD_EXP 131
51589: PUSH
51590: LD_VAR 0 2
51594: ARRAY
51595: PPUSH
51596: LD_INT 1
51598: PPUSH
51599: CALL_OW 3
51603: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51604: LD_ADDR_EXP 131
51608: PUSH
51609: LD_EXP 131
51613: PPUSH
51614: LD_VAR 0 2
51618: PPUSH
51619: LD_VAR 0 9
51623: PPUSH
51624: CALL_OW 1
51628: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51629: LD_EXP 131
51633: PUSH
51634: LD_VAR 0 2
51638: ARRAY
51639: PUSH
51640: LD_EXP 132
51644: PUSH
51645: LD_VAR 0 2
51649: ARRAY
51650: AND
51651: PUSH
51652: LD_EXP 132
51656: PUSH
51657: LD_VAR 0 2
51661: ARRAY
51662: PUSH
51663: LD_INT 1
51665: ARRAY
51666: PPUSH
51667: CALL_OW 310
51671: NOT
51672: AND
51673: PUSH
51674: LD_VAR 0 3
51678: PPUSH
51679: CALL_OW 313
51683: PUSH
51684: LD_INT 6
51686: EQUAL
51687: AND
51688: IFFALSE 51744
// begin tmp2 := UnitsInside ( j ) ;
51690: LD_ADDR_VAR 0 9
51694: PUSH
51695: LD_VAR 0 3
51699: PPUSH
51700: CALL_OW 313
51704: ST_TO_ADDR
// if tmp2 = 6 then
51705: LD_VAR 0 9
51709: PUSH
51710: LD_INT 6
51712: EQUAL
51713: IFFALSE 51744
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51715: LD_VAR 0 9
51719: PUSH
51720: LD_INT 1
51722: ARRAY
51723: PPUSH
51724: LD_INT 112
51726: PPUSH
51727: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51731: LD_VAR 0 9
51735: PUSH
51736: LD_INT 1
51738: ARRAY
51739: PPUSH
51740: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51744: LD_EXP 132
51748: PUSH
51749: LD_VAR 0 2
51753: ARRAY
51754: PUSH
51755: LD_EXP 132
51759: PUSH
51760: LD_VAR 0 2
51764: ARRAY
51765: PUSH
51766: LD_INT 1
51768: ARRAY
51769: PPUSH
51770: CALL_OW 314
51774: NOT
51775: AND
51776: PUSH
51777: LD_EXP 132
51781: PUSH
51782: LD_VAR 0 2
51786: ARRAY
51787: PUSH
51788: LD_INT 1
51790: ARRAY
51791: PPUSH
51792: CALL_OW 310
51796: NOT
51797: AND
51798: IFFALSE 51824
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51800: LD_EXP 132
51804: PUSH
51805: LD_VAR 0 2
51809: ARRAY
51810: PUSH
51811: LD_INT 1
51813: ARRAY
51814: PPUSH
51815: LD_VAR 0 3
51819: PPUSH
51820: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51824: LD_EXP 132
51828: PUSH
51829: LD_VAR 0 2
51833: ARRAY
51834: PUSH
51835: LD_INT 1
51837: ARRAY
51838: PPUSH
51839: CALL_OW 310
51843: PUSH
51844: LD_EXP 132
51848: PUSH
51849: LD_VAR 0 2
51853: ARRAY
51854: PUSH
51855: LD_INT 1
51857: ARRAY
51858: PPUSH
51859: CALL_OW 310
51863: PPUSH
51864: CALL_OW 461
51868: PUSH
51869: LD_INT 3
51871: NONEQUAL
51872: AND
51873: IFFALSE 51894
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51875: LD_EXP 132
51879: PUSH
51880: LD_VAR 0 2
51884: ARRAY
51885: PUSH
51886: LD_INT 1
51888: ARRAY
51889: PPUSH
51890: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51894: LD_VAR 0 3
51898: PPUSH
51899: CALL_OW 461
51903: PUSH
51904: LD_INT 6
51906: EQUAL
51907: PUSH
51908: LD_VAR 0 6
51912: PUSH
51913: LD_INT 1
51915: GREATER
51916: AND
51917: IFFALSE 52069
// begin sci := [ ] ;
51919: LD_ADDR_VAR 0 8
51923: PUSH
51924: EMPTY
51925: ST_TO_ADDR
// for x in ( tmp diff j ) do
51926: LD_ADDR_VAR 0 7
51930: PUSH
51931: LD_VAR 0 6
51935: PUSH
51936: LD_VAR 0 3
51940: DIFF
51941: PUSH
51942: FOR_IN
51943: IFFALSE 51995
// begin if sci = 6 then
51945: LD_VAR 0 8
51949: PUSH
51950: LD_INT 6
51952: EQUAL
51953: IFFALSE 51957
// break ;
51955: GO 51995
// if BuildingStatus ( x ) = bs_idle then
51957: LD_VAR 0 7
51961: PPUSH
51962: CALL_OW 461
51966: PUSH
51967: LD_INT 2
51969: EQUAL
51970: IFFALSE 51993
// sci := sci ^ UnitsInside ( x ) ;
51972: LD_ADDR_VAR 0 8
51976: PUSH
51977: LD_VAR 0 8
51981: PUSH
51982: LD_VAR 0 7
51986: PPUSH
51987: CALL_OW 313
51991: ADD
51992: ST_TO_ADDR
// end ;
51993: GO 51942
51995: POP
51996: POP
// if not sci then
51997: LD_VAR 0 8
52001: NOT
52002: IFFALSE 52006
// continue ;
52004: GO 51051
// for x in sci do
52006: LD_ADDR_VAR 0 7
52010: PUSH
52011: LD_VAR 0 8
52015: PUSH
52016: FOR_IN
52017: IFFALSE 52067
// if IsInUnit ( x ) and not HasTask ( x ) then
52019: LD_VAR 0 7
52023: PPUSH
52024: CALL_OW 310
52028: PUSH
52029: LD_VAR 0 7
52033: PPUSH
52034: CALL_OW 314
52038: NOT
52039: AND
52040: IFFALSE 52065
// begin ComExitBuilding ( x ) ;
52042: LD_VAR 0 7
52046: PPUSH
52047: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52051: LD_VAR 0 7
52055: PPUSH
52056: LD_VAR 0 3
52060: PPUSH
52061: CALL_OW 180
// end ;
52065: GO 52016
52067: POP
52068: POP
// end ; end ;
52069: GO 51051
52071: POP
52072: POP
// end ;
52073: GO 51005
52075: POP
52076: POP
// end ;
52077: LD_VAR 0 1
52081: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52082: LD_INT 0
52084: PPUSH
52085: PPUSH
// if not mc_bases then
52086: LD_EXP 102
52090: NOT
52091: IFFALSE 52095
// exit ;
52093: GO 52176
// for i = 1 to mc_bases do
52095: LD_ADDR_VAR 0 2
52099: PUSH
52100: DOUBLE
52101: LD_INT 1
52103: DEC
52104: ST_TO_ADDR
52105: LD_EXP 102
52109: PUSH
52110: FOR_TO
52111: IFFALSE 52174
// if mc_mines [ i ] and mc_miners [ i ] then
52113: LD_EXP 115
52117: PUSH
52118: LD_VAR 0 2
52122: ARRAY
52123: PUSH
52124: LD_EXP 116
52128: PUSH
52129: LD_VAR 0 2
52133: ARRAY
52134: AND
52135: IFFALSE 52172
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52137: LD_EXP 116
52141: PUSH
52142: LD_VAR 0 2
52146: ARRAY
52147: PUSH
52148: LD_INT 1
52150: ARRAY
52151: PPUSH
52152: CALL_OW 255
52156: PPUSH
52157: LD_EXP 115
52161: PUSH
52162: LD_VAR 0 2
52166: ARRAY
52167: PPUSH
52168: CALL 69004 0 2
52172: GO 52110
52174: POP
52175: POP
// end ;
52176: LD_VAR 0 1
52180: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52181: LD_INT 0
52183: PPUSH
52184: PPUSH
52185: PPUSH
52186: PPUSH
52187: PPUSH
52188: PPUSH
52189: PPUSH
52190: PPUSH
// if not mc_bases or not mc_parking then
52191: LD_EXP 102
52195: NOT
52196: PUSH
52197: LD_EXP 126
52201: NOT
52202: OR
52203: IFFALSE 52207
// exit ;
52205: GO 52906
// for i = 1 to mc_bases do
52207: LD_ADDR_VAR 0 2
52211: PUSH
52212: DOUBLE
52213: LD_INT 1
52215: DEC
52216: ST_TO_ADDR
52217: LD_EXP 102
52221: PUSH
52222: FOR_TO
52223: IFFALSE 52904
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52225: LD_EXP 102
52229: PUSH
52230: LD_VAR 0 2
52234: ARRAY
52235: NOT
52236: PUSH
52237: LD_EXP 126
52241: PUSH
52242: LD_VAR 0 2
52246: ARRAY
52247: NOT
52248: OR
52249: IFFALSE 52253
// continue ;
52251: GO 52222
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52253: LD_ADDR_VAR 0 5
52257: PUSH
52258: LD_EXP 102
52262: PUSH
52263: LD_VAR 0 2
52267: ARRAY
52268: PUSH
52269: LD_INT 1
52271: ARRAY
52272: PPUSH
52273: CALL_OW 255
52277: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52278: LD_ADDR_VAR 0 6
52282: PUSH
52283: LD_EXP 102
52287: PUSH
52288: LD_VAR 0 2
52292: ARRAY
52293: PPUSH
52294: LD_INT 30
52296: PUSH
52297: LD_INT 3
52299: PUSH
52300: EMPTY
52301: LIST
52302: LIST
52303: PPUSH
52304: CALL_OW 72
52308: ST_TO_ADDR
// if not fac then
52309: LD_VAR 0 6
52313: NOT
52314: IFFALSE 52365
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52316: LD_ADDR_VAR 0 6
52320: PUSH
52321: LD_EXP 102
52325: PUSH
52326: LD_VAR 0 2
52330: ARRAY
52331: PPUSH
52332: LD_INT 2
52334: PUSH
52335: LD_INT 30
52337: PUSH
52338: LD_INT 0
52340: PUSH
52341: EMPTY
52342: LIST
52343: LIST
52344: PUSH
52345: LD_INT 30
52347: PUSH
52348: LD_INT 1
52350: PUSH
52351: EMPTY
52352: LIST
52353: LIST
52354: PUSH
52355: EMPTY
52356: LIST
52357: LIST
52358: LIST
52359: PPUSH
52360: CALL_OW 72
52364: ST_TO_ADDR
// if not fac then
52365: LD_VAR 0 6
52369: NOT
52370: IFFALSE 52374
// continue ;
52372: GO 52222
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52374: LD_ADDR_VAR 0 7
52378: PUSH
52379: LD_EXP 126
52383: PUSH
52384: LD_VAR 0 2
52388: ARRAY
52389: PPUSH
52390: LD_INT 22
52392: PUSH
52393: LD_VAR 0 5
52397: PUSH
52398: EMPTY
52399: LIST
52400: LIST
52401: PUSH
52402: LD_INT 21
52404: PUSH
52405: LD_INT 2
52407: PUSH
52408: EMPTY
52409: LIST
52410: LIST
52411: PUSH
52412: LD_INT 3
52414: PUSH
52415: LD_INT 24
52417: PUSH
52418: LD_INT 1000
52420: PUSH
52421: EMPTY
52422: LIST
52423: LIST
52424: PUSH
52425: EMPTY
52426: LIST
52427: LIST
52428: PUSH
52429: EMPTY
52430: LIST
52431: LIST
52432: LIST
52433: PPUSH
52434: CALL_OW 70
52438: ST_TO_ADDR
// for j in fac do
52439: LD_ADDR_VAR 0 3
52443: PUSH
52444: LD_VAR 0 6
52448: PUSH
52449: FOR_IN
52450: IFFALSE 52531
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52452: LD_ADDR_VAR 0 7
52456: PUSH
52457: LD_VAR 0 7
52461: PUSH
52462: LD_INT 22
52464: PUSH
52465: LD_VAR 0 5
52469: PUSH
52470: EMPTY
52471: LIST
52472: LIST
52473: PUSH
52474: LD_INT 91
52476: PUSH
52477: LD_VAR 0 3
52481: PUSH
52482: LD_INT 15
52484: PUSH
52485: EMPTY
52486: LIST
52487: LIST
52488: LIST
52489: PUSH
52490: LD_INT 21
52492: PUSH
52493: LD_INT 2
52495: PUSH
52496: EMPTY
52497: LIST
52498: LIST
52499: PUSH
52500: LD_INT 3
52502: PUSH
52503: LD_INT 24
52505: PUSH
52506: LD_INT 1000
52508: PUSH
52509: EMPTY
52510: LIST
52511: LIST
52512: PUSH
52513: EMPTY
52514: LIST
52515: LIST
52516: PUSH
52517: EMPTY
52518: LIST
52519: LIST
52520: LIST
52521: LIST
52522: PPUSH
52523: CALL_OW 69
52527: UNION
52528: ST_TO_ADDR
52529: GO 52449
52531: POP
52532: POP
// if not vehs then
52533: LD_VAR 0 7
52537: NOT
52538: IFFALSE 52564
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52540: LD_ADDR_EXP 114
52544: PUSH
52545: LD_EXP 114
52549: PPUSH
52550: LD_VAR 0 2
52554: PPUSH
52555: EMPTY
52556: PPUSH
52557: CALL_OW 1
52561: ST_TO_ADDR
// continue ;
52562: GO 52222
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52564: LD_ADDR_VAR 0 8
52568: PUSH
52569: LD_EXP 102
52573: PUSH
52574: LD_VAR 0 2
52578: ARRAY
52579: PPUSH
52580: LD_INT 30
52582: PUSH
52583: LD_INT 3
52585: PUSH
52586: EMPTY
52587: LIST
52588: LIST
52589: PPUSH
52590: CALL_OW 72
52594: ST_TO_ADDR
// if tmp then
52595: LD_VAR 0 8
52599: IFFALSE 52702
// begin for j in tmp do
52601: LD_ADDR_VAR 0 3
52605: PUSH
52606: LD_VAR 0 8
52610: PUSH
52611: FOR_IN
52612: IFFALSE 52700
// for k in UnitsInside ( j ) do
52614: LD_ADDR_VAR 0 4
52618: PUSH
52619: LD_VAR 0 3
52623: PPUSH
52624: CALL_OW 313
52628: PUSH
52629: FOR_IN
52630: IFFALSE 52696
// if k then
52632: LD_VAR 0 4
52636: IFFALSE 52694
// if not k in mc_repair_vehicle [ i ] then
52638: LD_VAR 0 4
52642: PUSH
52643: LD_EXP 114
52647: PUSH
52648: LD_VAR 0 2
52652: ARRAY
52653: IN
52654: NOT
52655: IFFALSE 52694
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52657: LD_ADDR_EXP 114
52661: PUSH
52662: LD_EXP 114
52666: PPUSH
52667: LD_VAR 0 2
52671: PPUSH
52672: LD_EXP 114
52676: PUSH
52677: LD_VAR 0 2
52681: ARRAY
52682: PUSH
52683: LD_VAR 0 4
52687: UNION
52688: PPUSH
52689: CALL_OW 1
52693: ST_TO_ADDR
52694: GO 52629
52696: POP
52697: POP
52698: GO 52611
52700: POP
52701: POP
// end ; if not mc_repair_vehicle [ i ] then
52702: LD_EXP 114
52706: PUSH
52707: LD_VAR 0 2
52711: ARRAY
52712: NOT
52713: IFFALSE 52717
// continue ;
52715: GO 52222
// for j in mc_repair_vehicle [ i ] do
52717: LD_ADDR_VAR 0 3
52721: PUSH
52722: LD_EXP 114
52726: PUSH
52727: LD_VAR 0 2
52731: ARRAY
52732: PUSH
52733: FOR_IN
52734: IFFALSE 52900
// begin if GetClass ( j ) <> 3 then
52736: LD_VAR 0 3
52740: PPUSH
52741: CALL_OW 257
52745: PUSH
52746: LD_INT 3
52748: NONEQUAL
52749: IFFALSE 52790
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52751: LD_ADDR_EXP 114
52755: PUSH
52756: LD_EXP 114
52760: PPUSH
52761: LD_VAR 0 2
52765: PPUSH
52766: LD_EXP 114
52770: PUSH
52771: LD_VAR 0 2
52775: ARRAY
52776: PUSH
52777: LD_VAR 0 3
52781: DIFF
52782: PPUSH
52783: CALL_OW 1
52787: ST_TO_ADDR
// continue ;
52788: GO 52733
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52790: LD_VAR 0 3
52794: PPUSH
52795: CALL_OW 311
52799: NOT
52800: PUSH
52801: LD_VAR 0 3
52805: PUSH
52806: LD_EXP 105
52810: PUSH
52811: LD_VAR 0 2
52815: ARRAY
52816: PUSH
52817: LD_INT 1
52819: ARRAY
52820: IN
52821: NOT
52822: AND
52823: PUSH
52824: LD_VAR 0 3
52828: PUSH
52829: LD_EXP 105
52833: PUSH
52834: LD_VAR 0 2
52838: ARRAY
52839: PUSH
52840: LD_INT 2
52842: ARRAY
52843: IN
52844: NOT
52845: AND
52846: IFFALSE 52898
// begin if IsInUnit ( j ) then
52848: LD_VAR 0 3
52852: PPUSH
52853: CALL_OW 310
52857: IFFALSE 52868
// ComExitBuilding ( j ) ;
52859: LD_VAR 0 3
52863: PPUSH
52864: CALL_OW 122
// if not HasTask ( j ) then
52868: LD_VAR 0 3
52872: PPUSH
52873: CALL_OW 314
52877: NOT
52878: IFFALSE 52898
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52880: LD_VAR 0 3
52884: PPUSH
52885: LD_VAR 0 7
52889: PUSH
52890: LD_INT 1
52892: ARRAY
52893: PPUSH
52894: CALL_OW 189
// end ; end ;
52898: GO 52733
52900: POP
52901: POP
// end ;
52902: GO 52222
52904: POP
52905: POP
// end ;
52906: LD_VAR 0 1
52910: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52911: LD_INT 0
52913: PPUSH
52914: PPUSH
52915: PPUSH
52916: PPUSH
52917: PPUSH
52918: PPUSH
52919: PPUSH
52920: PPUSH
52921: PPUSH
52922: PPUSH
52923: PPUSH
// if not mc_bases then
52924: LD_EXP 102
52928: NOT
52929: IFFALSE 52933
// exit ;
52931: GO 53735
// for i = 1 to mc_bases do
52933: LD_ADDR_VAR 0 2
52937: PUSH
52938: DOUBLE
52939: LD_INT 1
52941: DEC
52942: ST_TO_ADDR
52943: LD_EXP 102
52947: PUSH
52948: FOR_TO
52949: IFFALSE 53733
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52951: LD_EXP 130
52955: PUSH
52956: LD_VAR 0 2
52960: ARRAY
52961: NOT
52962: PUSH
52963: LD_EXP 105
52967: PUSH
52968: LD_VAR 0 2
52972: ARRAY
52973: PUSH
52974: LD_INT 1
52976: ARRAY
52977: OR
52978: PUSH
52979: LD_EXP 105
52983: PUSH
52984: LD_VAR 0 2
52988: ARRAY
52989: PUSH
52990: LD_INT 2
52992: ARRAY
52993: OR
52994: PUSH
52995: LD_EXP 128
52999: PUSH
53000: LD_VAR 0 2
53004: ARRAY
53005: PPUSH
53006: LD_INT 1
53008: PPUSH
53009: CALL_OW 325
53013: NOT
53014: OR
53015: PUSH
53016: LD_EXP 125
53020: PUSH
53021: LD_VAR 0 2
53025: ARRAY
53026: OR
53027: IFFALSE 53031
// continue ;
53029: GO 52948
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53031: LD_ADDR_VAR 0 8
53035: PUSH
53036: LD_EXP 102
53040: PUSH
53041: LD_VAR 0 2
53045: ARRAY
53046: PPUSH
53047: LD_INT 25
53049: PUSH
53050: LD_INT 4
53052: PUSH
53053: EMPTY
53054: LIST
53055: LIST
53056: PUSH
53057: LD_INT 50
53059: PUSH
53060: EMPTY
53061: LIST
53062: PUSH
53063: LD_INT 3
53065: PUSH
53066: LD_INT 60
53068: PUSH
53069: EMPTY
53070: LIST
53071: PUSH
53072: EMPTY
53073: LIST
53074: LIST
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: LIST
53080: PPUSH
53081: CALL_OW 72
53085: PUSH
53086: LD_EXP 106
53090: PUSH
53091: LD_VAR 0 2
53095: ARRAY
53096: DIFF
53097: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53098: LD_ADDR_VAR 0 9
53102: PUSH
53103: LD_EXP 102
53107: PUSH
53108: LD_VAR 0 2
53112: ARRAY
53113: PPUSH
53114: LD_INT 2
53116: PUSH
53117: LD_INT 30
53119: PUSH
53120: LD_INT 0
53122: PUSH
53123: EMPTY
53124: LIST
53125: LIST
53126: PUSH
53127: LD_INT 30
53129: PUSH
53130: LD_INT 1
53132: PUSH
53133: EMPTY
53134: LIST
53135: LIST
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: LIST
53141: PPUSH
53142: CALL_OW 72
53146: ST_TO_ADDR
// if not tmp or not dep then
53147: LD_VAR 0 8
53151: NOT
53152: PUSH
53153: LD_VAR 0 9
53157: NOT
53158: OR
53159: IFFALSE 53163
// continue ;
53161: GO 52948
// side := GetSide ( tmp [ 1 ] ) ;
53163: LD_ADDR_VAR 0 11
53167: PUSH
53168: LD_VAR 0 8
53172: PUSH
53173: LD_INT 1
53175: ARRAY
53176: PPUSH
53177: CALL_OW 255
53181: ST_TO_ADDR
// dep := dep [ 1 ] ;
53182: LD_ADDR_VAR 0 9
53186: PUSH
53187: LD_VAR 0 9
53191: PUSH
53192: LD_INT 1
53194: ARRAY
53195: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53196: LD_ADDR_VAR 0 7
53200: PUSH
53201: LD_EXP 130
53205: PUSH
53206: LD_VAR 0 2
53210: ARRAY
53211: PPUSH
53212: LD_INT 22
53214: PUSH
53215: LD_INT 0
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: PUSH
53222: LD_INT 25
53224: PUSH
53225: LD_INT 12
53227: PUSH
53228: EMPTY
53229: LIST
53230: LIST
53231: PUSH
53232: EMPTY
53233: LIST
53234: LIST
53235: PPUSH
53236: CALL_OW 70
53240: PUSH
53241: LD_INT 22
53243: PUSH
53244: LD_INT 0
53246: PUSH
53247: EMPTY
53248: LIST
53249: LIST
53250: PUSH
53251: LD_INT 25
53253: PUSH
53254: LD_INT 12
53256: PUSH
53257: EMPTY
53258: LIST
53259: LIST
53260: PUSH
53261: LD_INT 91
53263: PUSH
53264: LD_VAR 0 9
53268: PUSH
53269: LD_INT 20
53271: PUSH
53272: EMPTY
53273: LIST
53274: LIST
53275: LIST
53276: PUSH
53277: EMPTY
53278: LIST
53279: LIST
53280: LIST
53281: PPUSH
53282: CALL_OW 69
53286: UNION
53287: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53288: LD_ADDR_VAR 0 10
53292: PUSH
53293: LD_EXP 130
53297: PUSH
53298: LD_VAR 0 2
53302: ARRAY
53303: PPUSH
53304: LD_INT 81
53306: PUSH
53307: LD_VAR 0 11
53311: PUSH
53312: EMPTY
53313: LIST
53314: LIST
53315: PPUSH
53316: CALL_OW 70
53320: ST_TO_ADDR
// if not apes or danger_at_area then
53321: LD_VAR 0 7
53325: NOT
53326: PUSH
53327: LD_VAR 0 10
53331: OR
53332: IFFALSE 53382
// begin if mc_taming [ i ] then
53334: LD_EXP 133
53338: PUSH
53339: LD_VAR 0 2
53343: ARRAY
53344: IFFALSE 53380
// begin MC_Reset ( i , 121 ) ;
53346: LD_VAR 0 2
53350: PPUSH
53351: LD_INT 121
53353: PPUSH
53354: CALL 38817 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53358: LD_ADDR_EXP 133
53362: PUSH
53363: LD_EXP 133
53367: PPUSH
53368: LD_VAR 0 2
53372: PPUSH
53373: EMPTY
53374: PPUSH
53375: CALL_OW 1
53379: ST_TO_ADDR
// end ; continue ;
53380: GO 52948
// end ; for j in tmp do
53382: LD_ADDR_VAR 0 3
53386: PUSH
53387: LD_VAR 0 8
53391: PUSH
53392: FOR_IN
53393: IFFALSE 53729
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53395: LD_VAR 0 3
53399: PUSH
53400: LD_EXP 133
53404: PUSH
53405: LD_VAR 0 2
53409: ARRAY
53410: IN
53411: NOT
53412: PUSH
53413: LD_EXP 133
53417: PUSH
53418: LD_VAR 0 2
53422: ARRAY
53423: PUSH
53424: LD_INT 3
53426: LESS
53427: AND
53428: IFFALSE 53486
// begin SetTag ( j , 121 ) ;
53430: LD_VAR 0 3
53434: PPUSH
53435: LD_INT 121
53437: PPUSH
53438: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53442: LD_ADDR_EXP 133
53446: PUSH
53447: LD_EXP 133
53451: PPUSH
53452: LD_VAR 0 2
53456: PUSH
53457: LD_EXP 133
53461: PUSH
53462: LD_VAR 0 2
53466: ARRAY
53467: PUSH
53468: LD_INT 1
53470: PLUS
53471: PUSH
53472: EMPTY
53473: LIST
53474: LIST
53475: PPUSH
53476: LD_VAR 0 3
53480: PPUSH
53481: CALL 72015 0 3
53485: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53486: LD_VAR 0 3
53490: PUSH
53491: LD_EXP 133
53495: PUSH
53496: LD_VAR 0 2
53500: ARRAY
53501: IN
53502: IFFALSE 53727
// begin if GetClass ( j ) <> 4 then
53504: LD_VAR 0 3
53508: PPUSH
53509: CALL_OW 257
53513: PUSH
53514: LD_INT 4
53516: NONEQUAL
53517: IFFALSE 53570
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53519: LD_ADDR_EXP 133
53523: PUSH
53524: LD_EXP 133
53528: PPUSH
53529: LD_VAR 0 2
53533: PPUSH
53534: LD_EXP 133
53538: PUSH
53539: LD_VAR 0 2
53543: ARRAY
53544: PUSH
53545: LD_VAR 0 3
53549: DIFF
53550: PPUSH
53551: CALL_OW 1
53555: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53556: LD_VAR 0 3
53560: PPUSH
53561: LD_INT 0
53563: PPUSH
53564: CALL_OW 109
// continue ;
53568: GO 53392
// end ; if IsInUnit ( j ) then
53570: LD_VAR 0 3
53574: PPUSH
53575: CALL_OW 310
53579: IFFALSE 53590
// ComExitBuilding ( j ) ;
53581: LD_VAR 0 3
53585: PPUSH
53586: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53590: LD_ADDR_VAR 0 6
53594: PUSH
53595: LD_VAR 0 7
53599: PPUSH
53600: LD_VAR 0 3
53604: PPUSH
53605: CALL_OW 74
53609: ST_TO_ADDR
// if not ape then
53610: LD_VAR 0 6
53614: NOT
53615: IFFALSE 53619
// break ;
53617: GO 53729
// x := GetX ( ape ) ;
53619: LD_ADDR_VAR 0 4
53623: PUSH
53624: LD_VAR 0 6
53628: PPUSH
53629: CALL_OW 250
53633: ST_TO_ADDR
// y := GetY ( ape ) ;
53634: LD_ADDR_VAR 0 5
53638: PUSH
53639: LD_VAR 0 6
53643: PPUSH
53644: CALL_OW 251
53648: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53649: LD_VAR 0 4
53653: PPUSH
53654: LD_VAR 0 5
53658: PPUSH
53659: CALL_OW 488
53663: NOT
53664: PUSH
53665: LD_VAR 0 11
53669: PPUSH
53670: LD_VAR 0 4
53674: PPUSH
53675: LD_VAR 0 5
53679: PPUSH
53680: LD_INT 20
53682: PPUSH
53683: CALL 72911 0 4
53687: PUSH
53688: LD_INT 4
53690: ARRAY
53691: OR
53692: IFFALSE 53696
// break ;
53694: GO 53729
// if not HasTask ( j ) then
53696: LD_VAR 0 3
53700: PPUSH
53701: CALL_OW 314
53705: NOT
53706: IFFALSE 53727
// ComTameXY ( j , x , y ) ;
53708: LD_VAR 0 3
53712: PPUSH
53713: LD_VAR 0 4
53717: PPUSH
53718: LD_VAR 0 5
53722: PPUSH
53723: CALL_OW 131
// end ; end ;
53727: GO 53392
53729: POP
53730: POP
// end ;
53731: GO 52948
53733: POP
53734: POP
// end ;
53735: LD_VAR 0 1
53739: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53740: LD_INT 0
53742: PPUSH
53743: PPUSH
53744: PPUSH
53745: PPUSH
53746: PPUSH
53747: PPUSH
53748: PPUSH
53749: PPUSH
// if not mc_bases then
53750: LD_EXP 102
53754: NOT
53755: IFFALSE 53759
// exit ;
53757: GO 54385
// for i = 1 to mc_bases do
53759: LD_ADDR_VAR 0 2
53763: PUSH
53764: DOUBLE
53765: LD_INT 1
53767: DEC
53768: ST_TO_ADDR
53769: LD_EXP 102
53773: PUSH
53774: FOR_TO
53775: IFFALSE 54383
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53777: LD_EXP 131
53781: PUSH
53782: LD_VAR 0 2
53786: ARRAY
53787: NOT
53788: PUSH
53789: LD_EXP 131
53793: PUSH
53794: LD_VAR 0 2
53798: ARRAY
53799: PPUSH
53800: LD_INT 25
53802: PUSH
53803: LD_INT 12
53805: PUSH
53806: EMPTY
53807: LIST
53808: LIST
53809: PPUSH
53810: CALL_OW 72
53814: NOT
53815: OR
53816: IFFALSE 53820
// continue ;
53818: GO 53774
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53820: LD_ADDR_VAR 0 5
53824: PUSH
53825: LD_EXP 131
53829: PUSH
53830: LD_VAR 0 2
53834: ARRAY
53835: PUSH
53836: LD_INT 1
53838: ARRAY
53839: PPUSH
53840: CALL_OW 255
53844: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53845: LD_VAR 0 5
53849: PPUSH
53850: LD_INT 2
53852: PPUSH
53853: CALL_OW 325
53857: IFFALSE 54110
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53859: LD_ADDR_VAR 0 4
53863: PUSH
53864: LD_EXP 131
53868: PUSH
53869: LD_VAR 0 2
53873: ARRAY
53874: PPUSH
53875: LD_INT 25
53877: PUSH
53878: LD_INT 16
53880: PUSH
53881: EMPTY
53882: LIST
53883: LIST
53884: PPUSH
53885: CALL_OW 72
53889: ST_TO_ADDR
// if tmp < 6 then
53890: LD_VAR 0 4
53894: PUSH
53895: LD_INT 6
53897: LESS
53898: IFFALSE 54110
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53900: LD_ADDR_VAR 0 6
53904: PUSH
53905: LD_EXP 102
53909: PUSH
53910: LD_VAR 0 2
53914: ARRAY
53915: PPUSH
53916: LD_INT 2
53918: PUSH
53919: LD_INT 30
53921: PUSH
53922: LD_INT 0
53924: PUSH
53925: EMPTY
53926: LIST
53927: LIST
53928: PUSH
53929: LD_INT 30
53931: PUSH
53932: LD_INT 1
53934: PUSH
53935: EMPTY
53936: LIST
53937: LIST
53938: PUSH
53939: EMPTY
53940: LIST
53941: LIST
53942: LIST
53943: PPUSH
53944: CALL_OW 72
53948: ST_TO_ADDR
// if depot then
53949: LD_VAR 0 6
53953: IFFALSE 54110
// begin selected := 0 ;
53955: LD_ADDR_VAR 0 7
53959: PUSH
53960: LD_INT 0
53962: ST_TO_ADDR
// for j in depot do
53963: LD_ADDR_VAR 0 3
53967: PUSH
53968: LD_VAR 0 6
53972: PUSH
53973: FOR_IN
53974: IFFALSE 54005
// begin if UnitsInside ( j ) < 6 then
53976: LD_VAR 0 3
53980: PPUSH
53981: CALL_OW 313
53985: PUSH
53986: LD_INT 6
53988: LESS
53989: IFFALSE 54003
// begin selected := j ;
53991: LD_ADDR_VAR 0 7
53995: PUSH
53996: LD_VAR 0 3
54000: ST_TO_ADDR
// break ;
54001: GO 54005
// end ; end ;
54003: GO 53973
54005: POP
54006: POP
// if selected then
54007: LD_VAR 0 7
54011: IFFALSE 54110
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54013: LD_ADDR_VAR 0 3
54017: PUSH
54018: LD_EXP 131
54022: PUSH
54023: LD_VAR 0 2
54027: ARRAY
54028: PPUSH
54029: LD_INT 25
54031: PUSH
54032: LD_INT 12
54034: PUSH
54035: EMPTY
54036: LIST
54037: LIST
54038: PPUSH
54039: CALL_OW 72
54043: PUSH
54044: FOR_IN
54045: IFFALSE 54108
// if not HasTask ( j ) then
54047: LD_VAR 0 3
54051: PPUSH
54052: CALL_OW 314
54056: NOT
54057: IFFALSE 54106
// begin if not IsInUnit ( j ) then
54059: LD_VAR 0 3
54063: PPUSH
54064: CALL_OW 310
54068: NOT
54069: IFFALSE 54085
// ComEnterUnit ( j , selected ) ;
54071: LD_VAR 0 3
54075: PPUSH
54076: LD_VAR 0 7
54080: PPUSH
54081: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54085: LD_VAR 0 3
54089: PPUSH
54090: LD_INT 16
54092: PPUSH
54093: CALL_OW 183
// AddComExitBuilding ( j ) ;
54097: LD_VAR 0 3
54101: PPUSH
54102: CALL_OW 182
// end ;
54106: GO 54044
54108: POP
54109: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54110: LD_VAR 0 5
54114: PPUSH
54115: LD_INT 11
54117: PPUSH
54118: CALL_OW 325
54122: IFFALSE 54381
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54124: LD_ADDR_VAR 0 4
54128: PUSH
54129: LD_EXP 131
54133: PUSH
54134: LD_VAR 0 2
54138: ARRAY
54139: PPUSH
54140: LD_INT 25
54142: PUSH
54143: LD_INT 16
54145: PUSH
54146: EMPTY
54147: LIST
54148: LIST
54149: PPUSH
54150: CALL_OW 72
54154: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54155: LD_VAR 0 4
54159: PUSH
54160: LD_INT 6
54162: GREATEREQUAL
54163: PUSH
54164: LD_VAR 0 5
54168: PPUSH
54169: LD_INT 2
54171: PPUSH
54172: CALL_OW 325
54176: NOT
54177: OR
54178: IFFALSE 54381
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54180: LD_ADDR_VAR 0 8
54184: PUSH
54185: LD_EXP 102
54189: PUSH
54190: LD_VAR 0 2
54194: ARRAY
54195: PPUSH
54196: LD_INT 2
54198: PUSH
54199: LD_INT 30
54201: PUSH
54202: LD_INT 4
54204: PUSH
54205: EMPTY
54206: LIST
54207: LIST
54208: PUSH
54209: LD_INT 30
54211: PUSH
54212: LD_INT 5
54214: PUSH
54215: EMPTY
54216: LIST
54217: LIST
54218: PUSH
54219: EMPTY
54220: LIST
54221: LIST
54222: LIST
54223: PPUSH
54224: CALL_OW 72
54228: ST_TO_ADDR
// if barracks then
54229: LD_VAR 0 8
54233: IFFALSE 54381
// begin selected := 0 ;
54235: LD_ADDR_VAR 0 7
54239: PUSH
54240: LD_INT 0
54242: ST_TO_ADDR
// for j in barracks do
54243: LD_ADDR_VAR 0 3
54247: PUSH
54248: LD_VAR 0 8
54252: PUSH
54253: FOR_IN
54254: IFFALSE 54285
// begin if UnitsInside ( j ) < 6 then
54256: LD_VAR 0 3
54260: PPUSH
54261: CALL_OW 313
54265: PUSH
54266: LD_INT 6
54268: LESS
54269: IFFALSE 54283
// begin selected := j ;
54271: LD_ADDR_VAR 0 7
54275: PUSH
54276: LD_VAR 0 3
54280: ST_TO_ADDR
// break ;
54281: GO 54285
// end ; end ;
54283: GO 54253
54285: POP
54286: POP
// if selected then
54287: LD_VAR 0 7
54291: IFFALSE 54381
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54293: LD_ADDR_VAR 0 3
54297: PUSH
54298: LD_EXP 131
54302: PUSH
54303: LD_VAR 0 2
54307: ARRAY
54308: PPUSH
54309: LD_INT 25
54311: PUSH
54312: LD_INT 12
54314: PUSH
54315: EMPTY
54316: LIST
54317: LIST
54318: PPUSH
54319: CALL_OW 72
54323: PUSH
54324: FOR_IN
54325: IFFALSE 54379
// if not IsInUnit ( j ) and not HasTask ( j ) then
54327: LD_VAR 0 3
54331: PPUSH
54332: CALL_OW 310
54336: NOT
54337: PUSH
54338: LD_VAR 0 3
54342: PPUSH
54343: CALL_OW 314
54347: NOT
54348: AND
54349: IFFALSE 54377
// begin ComEnterUnit ( j , selected ) ;
54351: LD_VAR 0 3
54355: PPUSH
54356: LD_VAR 0 7
54360: PPUSH
54361: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54365: LD_VAR 0 3
54369: PPUSH
54370: LD_INT 15
54372: PPUSH
54373: CALL_OW 183
// end ;
54377: GO 54324
54379: POP
54380: POP
// end ; end ; end ; end ; end ;
54381: GO 53774
54383: POP
54384: POP
// end ;
54385: LD_VAR 0 1
54389: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54390: LD_INT 0
54392: PPUSH
54393: PPUSH
54394: PPUSH
54395: PPUSH
// if not mc_bases then
54396: LD_EXP 102
54400: NOT
54401: IFFALSE 54405
// exit ;
54403: GO 54583
// for i = 1 to mc_bases do
54405: LD_ADDR_VAR 0 2
54409: PUSH
54410: DOUBLE
54411: LD_INT 1
54413: DEC
54414: ST_TO_ADDR
54415: LD_EXP 102
54419: PUSH
54420: FOR_TO
54421: IFFALSE 54581
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54423: LD_ADDR_VAR 0 4
54427: PUSH
54428: LD_EXP 102
54432: PUSH
54433: LD_VAR 0 2
54437: ARRAY
54438: PPUSH
54439: LD_INT 25
54441: PUSH
54442: LD_INT 9
54444: PUSH
54445: EMPTY
54446: LIST
54447: LIST
54448: PPUSH
54449: CALL_OW 72
54453: ST_TO_ADDR
// if not tmp then
54454: LD_VAR 0 4
54458: NOT
54459: IFFALSE 54463
// continue ;
54461: GO 54420
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54463: LD_EXP 128
54467: PUSH
54468: LD_VAR 0 2
54472: ARRAY
54473: PPUSH
54474: LD_INT 29
54476: PPUSH
54477: CALL_OW 325
54481: NOT
54482: PUSH
54483: LD_EXP 128
54487: PUSH
54488: LD_VAR 0 2
54492: ARRAY
54493: PPUSH
54494: LD_INT 28
54496: PPUSH
54497: CALL_OW 325
54501: NOT
54502: AND
54503: IFFALSE 54507
// continue ;
54505: GO 54420
// for j in tmp do
54507: LD_ADDR_VAR 0 3
54511: PUSH
54512: LD_VAR 0 4
54516: PUSH
54517: FOR_IN
54518: IFFALSE 54577
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54520: LD_VAR 0 3
54524: PUSH
54525: LD_EXP 105
54529: PUSH
54530: LD_VAR 0 2
54534: ARRAY
54535: PUSH
54536: LD_INT 1
54538: ARRAY
54539: IN
54540: NOT
54541: PUSH
54542: LD_VAR 0 3
54546: PUSH
54547: LD_EXP 105
54551: PUSH
54552: LD_VAR 0 2
54556: ARRAY
54557: PUSH
54558: LD_INT 2
54560: ARRAY
54561: IN
54562: NOT
54563: AND
54564: IFFALSE 54575
// ComSpaceTimeShoot ( j ) ;
54566: LD_VAR 0 3
54570: PPUSH
54571: CALL 65601 0 1
54575: GO 54517
54577: POP
54578: POP
// end ;
54579: GO 54420
54581: POP
54582: POP
// end ;
54583: LD_VAR 0 1
54587: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54588: LD_INT 0
54590: PPUSH
54591: PPUSH
54592: PPUSH
54593: PPUSH
54594: PPUSH
54595: PPUSH
54596: PPUSH
54597: PPUSH
54598: PPUSH
// if not mc_bases then
54599: LD_EXP 102
54603: NOT
54604: IFFALSE 54608
// exit ;
54606: GO 55230
// for i = 1 to mc_bases do
54608: LD_ADDR_VAR 0 2
54612: PUSH
54613: DOUBLE
54614: LD_INT 1
54616: DEC
54617: ST_TO_ADDR
54618: LD_EXP 102
54622: PUSH
54623: FOR_TO
54624: IFFALSE 55228
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54626: LD_EXP 137
54630: PUSH
54631: LD_VAR 0 2
54635: ARRAY
54636: NOT
54637: PUSH
54638: LD_INT 38
54640: PPUSH
54641: LD_EXP 128
54645: PUSH
54646: LD_VAR 0 2
54650: ARRAY
54651: PPUSH
54652: CALL_OW 321
54656: PUSH
54657: LD_INT 2
54659: NONEQUAL
54660: OR
54661: IFFALSE 54665
// continue ;
54663: GO 54623
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54665: LD_ADDR_VAR 0 8
54669: PUSH
54670: LD_EXP 102
54674: PUSH
54675: LD_VAR 0 2
54679: ARRAY
54680: PPUSH
54681: LD_INT 30
54683: PUSH
54684: LD_INT 34
54686: PUSH
54687: EMPTY
54688: LIST
54689: LIST
54690: PPUSH
54691: CALL_OW 72
54695: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54696: LD_ADDR_VAR 0 9
54700: PUSH
54701: LD_EXP 102
54705: PUSH
54706: LD_VAR 0 2
54710: ARRAY
54711: PPUSH
54712: LD_INT 25
54714: PUSH
54715: LD_INT 4
54717: PUSH
54718: EMPTY
54719: LIST
54720: LIST
54721: PPUSH
54722: CALL_OW 72
54726: PPUSH
54727: LD_INT 0
54729: PPUSH
54730: CALL 105285 0 2
54734: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54735: LD_VAR 0 9
54739: NOT
54740: PUSH
54741: LD_VAR 0 8
54745: NOT
54746: OR
54747: PUSH
54748: LD_EXP 102
54752: PUSH
54753: LD_VAR 0 2
54757: ARRAY
54758: PPUSH
54759: LD_INT 124
54761: PPUSH
54762: CALL 105285 0 2
54766: OR
54767: IFFALSE 54771
// continue ;
54769: GO 54623
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54771: LD_EXP 138
54775: PUSH
54776: LD_VAR 0 2
54780: ARRAY
54781: PUSH
54782: LD_EXP 137
54786: PUSH
54787: LD_VAR 0 2
54791: ARRAY
54792: LESS
54793: PUSH
54794: LD_EXP 138
54798: PUSH
54799: LD_VAR 0 2
54803: ARRAY
54804: PUSH
54805: LD_VAR 0 8
54809: LESS
54810: AND
54811: IFFALSE 55226
// begin tmp := sci [ 1 ] ;
54813: LD_ADDR_VAR 0 7
54817: PUSH
54818: LD_VAR 0 9
54822: PUSH
54823: LD_INT 1
54825: ARRAY
54826: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54827: LD_VAR 0 7
54831: PPUSH
54832: LD_INT 124
54834: PPUSH
54835: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54839: LD_ADDR_VAR 0 3
54843: PUSH
54844: DOUBLE
54845: LD_EXP 137
54849: PUSH
54850: LD_VAR 0 2
54854: ARRAY
54855: INC
54856: ST_TO_ADDR
54857: LD_EXP 137
54861: PUSH
54862: LD_VAR 0 2
54866: ARRAY
54867: PUSH
54868: FOR_DOWNTO
54869: IFFALSE 55212
// begin if IsInUnit ( tmp ) then
54871: LD_VAR 0 7
54875: PPUSH
54876: CALL_OW 310
54880: IFFALSE 54891
// ComExitBuilding ( tmp ) ;
54882: LD_VAR 0 7
54886: PPUSH
54887: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54891: LD_INT 35
54893: PPUSH
54894: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54898: LD_VAR 0 7
54902: PPUSH
54903: CALL_OW 310
54907: NOT
54908: PUSH
54909: LD_VAR 0 7
54913: PPUSH
54914: CALL_OW 314
54918: NOT
54919: AND
54920: IFFALSE 54891
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54922: LD_ADDR_VAR 0 6
54926: PUSH
54927: LD_VAR 0 7
54931: PPUSH
54932: CALL_OW 250
54936: PUSH
54937: LD_VAR 0 7
54941: PPUSH
54942: CALL_OW 251
54946: PUSH
54947: EMPTY
54948: LIST
54949: LIST
54950: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54951: LD_INT 35
54953: PPUSH
54954: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54958: LD_ADDR_VAR 0 4
54962: PUSH
54963: LD_EXP 137
54967: PUSH
54968: LD_VAR 0 2
54972: ARRAY
54973: PUSH
54974: LD_VAR 0 3
54978: ARRAY
54979: PUSH
54980: LD_INT 1
54982: ARRAY
54983: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54984: LD_ADDR_VAR 0 5
54988: PUSH
54989: LD_EXP 137
54993: PUSH
54994: LD_VAR 0 2
54998: ARRAY
54999: PUSH
55000: LD_VAR 0 3
55004: ARRAY
55005: PUSH
55006: LD_INT 2
55008: ARRAY
55009: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55010: LD_VAR 0 7
55014: PPUSH
55015: LD_INT 10
55017: PPUSH
55018: CALL 74608 0 2
55022: PUSH
55023: LD_INT 4
55025: ARRAY
55026: IFFALSE 55064
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55028: LD_VAR 0 7
55032: PPUSH
55033: LD_VAR 0 6
55037: PUSH
55038: LD_INT 1
55040: ARRAY
55041: PPUSH
55042: LD_VAR 0 6
55046: PUSH
55047: LD_INT 2
55049: ARRAY
55050: PPUSH
55051: CALL_OW 111
// wait ( 0 0$10 ) ;
55055: LD_INT 350
55057: PPUSH
55058: CALL_OW 67
// end else
55062: GO 55090
// begin ComMoveXY ( tmp , x , y ) ;
55064: LD_VAR 0 7
55068: PPUSH
55069: LD_VAR 0 4
55073: PPUSH
55074: LD_VAR 0 5
55078: PPUSH
55079: CALL_OW 111
// wait ( 0 0$3 ) ;
55083: LD_INT 105
55085: PPUSH
55086: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55090: LD_VAR 0 7
55094: PPUSH
55095: LD_VAR 0 4
55099: PPUSH
55100: LD_VAR 0 5
55104: PPUSH
55105: CALL_OW 307
55109: IFFALSE 54951
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55111: LD_VAR 0 7
55115: PPUSH
55116: LD_VAR 0 4
55120: PPUSH
55121: LD_VAR 0 5
55125: PPUSH
55126: LD_VAR 0 8
55130: PUSH
55131: LD_VAR 0 3
55135: ARRAY
55136: PPUSH
55137: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55141: LD_INT 35
55143: PPUSH
55144: CALL_OW 67
// until not HasTask ( tmp ) ;
55148: LD_VAR 0 7
55152: PPUSH
55153: CALL_OW 314
55157: NOT
55158: IFFALSE 55141
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55160: LD_ADDR_EXP 138
55164: PUSH
55165: LD_EXP 138
55169: PPUSH
55170: LD_VAR 0 2
55174: PUSH
55175: LD_EXP 138
55179: PUSH
55180: LD_VAR 0 2
55184: ARRAY
55185: PUSH
55186: LD_INT 1
55188: PLUS
55189: PUSH
55190: EMPTY
55191: LIST
55192: LIST
55193: PPUSH
55194: LD_VAR 0 8
55198: PUSH
55199: LD_VAR 0 3
55203: ARRAY
55204: PPUSH
55205: CALL 72015 0 3
55209: ST_TO_ADDR
// end ;
55210: GO 54868
55212: POP
55213: POP
// MC_Reset ( i , 124 ) ;
55214: LD_VAR 0 2
55218: PPUSH
55219: LD_INT 124
55221: PPUSH
55222: CALL 38817 0 2
// end ; end ;
55226: GO 54623
55228: POP
55229: POP
// end ;
55230: LD_VAR 0 1
55234: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55235: LD_INT 0
55237: PPUSH
55238: PPUSH
55239: PPUSH
// if not mc_bases then
55240: LD_EXP 102
55244: NOT
55245: IFFALSE 55249
// exit ;
55247: GO 55855
// for i = 1 to mc_bases do
55249: LD_ADDR_VAR 0 2
55253: PUSH
55254: DOUBLE
55255: LD_INT 1
55257: DEC
55258: ST_TO_ADDR
55259: LD_EXP 102
55263: PUSH
55264: FOR_TO
55265: IFFALSE 55853
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55267: LD_ADDR_VAR 0 3
55271: PUSH
55272: LD_EXP 102
55276: PUSH
55277: LD_VAR 0 2
55281: ARRAY
55282: PPUSH
55283: LD_INT 25
55285: PUSH
55286: LD_INT 4
55288: PUSH
55289: EMPTY
55290: LIST
55291: LIST
55292: PPUSH
55293: CALL_OW 72
55297: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55298: LD_VAR 0 3
55302: NOT
55303: PUSH
55304: LD_EXP 139
55308: PUSH
55309: LD_VAR 0 2
55313: ARRAY
55314: NOT
55315: OR
55316: PUSH
55317: LD_EXP 102
55321: PUSH
55322: LD_VAR 0 2
55326: ARRAY
55327: PPUSH
55328: LD_INT 2
55330: PUSH
55331: LD_INT 30
55333: PUSH
55334: LD_INT 0
55336: PUSH
55337: EMPTY
55338: LIST
55339: LIST
55340: PUSH
55341: LD_INT 30
55343: PUSH
55344: LD_INT 1
55346: PUSH
55347: EMPTY
55348: LIST
55349: LIST
55350: PUSH
55351: EMPTY
55352: LIST
55353: LIST
55354: LIST
55355: PPUSH
55356: CALL_OW 72
55360: NOT
55361: OR
55362: IFFALSE 55412
// begin if mc_deposits_finder [ i ] then
55364: LD_EXP 140
55368: PUSH
55369: LD_VAR 0 2
55373: ARRAY
55374: IFFALSE 55410
// begin MC_Reset ( i , 125 ) ;
55376: LD_VAR 0 2
55380: PPUSH
55381: LD_INT 125
55383: PPUSH
55384: CALL 38817 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55388: LD_ADDR_EXP 140
55392: PUSH
55393: LD_EXP 140
55397: PPUSH
55398: LD_VAR 0 2
55402: PPUSH
55403: EMPTY
55404: PPUSH
55405: CALL_OW 1
55409: ST_TO_ADDR
// end ; continue ;
55410: GO 55264
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55412: LD_EXP 139
55416: PUSH
55417: LD_VAR 0 2
55421: ARRAY
55422: PUSH
55423: LD_INT 1
55425: ARRAY
55426: PUSH
55427: LD_INT 3
55429: ARRAY
55430: PUSH
55431: LD_INT 1
55433: EQUAL
55434: PUSH
55435: LD_INT 20
55437: PPUSH
55438: LD_EXP 128
55442: PUSH
55443: LD_VAR 0 2
55447: ARRAY
55448: PPUSH
55449: CALL_OW 321
55453: PUSH
55454: LD_INT 2
55456: NONEQUAL
55457: AND
55458: IFFALSE 55508
// begin if mc_deposits_finder [ i ] then
55460: LD_EXP 140
55464: PUSH
55465: LD_VAR 0 2
55469: ARRAY
55470: IFFALSE 55506
// begin MC_Reset ( i , 125 ) ;
55472: LD_VAR 0 2
55476: PPUSH
55477: LD_INT 125
55479: PPUSH
55480: CALL 38817 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55484: LD_ADDR_EXP 140
55488: PUSH
55489: LD_EXP 140
55493: PPUSH
55494: LD_VAR 0 2
55498: PPUSH
55499: EMPTY
55500: PPUSH
55501: CALL_OW 1
55505: ST_TO_ADDR
// end ; continue ;
55506: GO 55264
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55508: LD_EXP 139
55512: PUSH
55513: LD_VAR 0 2
55517: ARRAY
55518: PUSH
55519: LD_INT 1
55521: ARRAY
55522: PUSH
55523: LD_INT 1
55525: ARRAY
55526: PPUSH
55527: LD_EXP 139
55531: PUSH
55532: LD_VAR 0 2
55536: ARRAY
55537: PUSH
55538: LD_INT 1
55540: ARRAY
55541: PUSH
55542: LD_INT 2
55544: ARRAY
55545: PPUSH
55546: LD_EXP 128
55550: PUSH
55551: LD_VAR 0 2
55555: ARRAY
55556: PPUSH
55557: CALL_OW 440
55561: IFFALSE 55604
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55563: LD_ADDR_EXP 139
55567: PUSH
55568: LD_EXP 139
55572: PPUSH
55573: LD_VAR 0 2
55577: PPUSH
55578: LD_EXP 139
55582: PUSH
55583: LD_VAR 0 2
55587: ARRAY
55588: PPUSH
55589: LD_INT 1
55591: PPUSH
55592: CALL_OW 3
55596: PPUSH
55597: CALL_OW 1
55601: ST_TO_ADDR
55602: GO 55851
// begin if not mc_deposits_finder [ i ] then
55604: LD_EXP 140
55608: PUSH
55609: LD_VAR 0 2
55613: ARRAY
55614: NOT
55615: IFFALSE 55667
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55617: LD_ADDR_EXP 140
55621: PUSH
55622: LD_EXP 140
55626: PPUSH
55627: LD_VAR 0 2
55631: PPUSH
55632: LD_VAR 0 3
55636: PUSH
55637: LD_INT 1
55639: ARRAY
55640: PUSH
55641: EMPTY
55642: LIST
55643: PPUSH
55644: CALL_OW 1
55648: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55649: LD_VAR 0 3
55653: PUSH
55654: LD_INT 1
55656: ARRAY
55657: PPUSH
55658: LD_INT 125
55660: PPUSH
55661: CALL_OW 109
// end else
55665: GO 55851
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55667: LD_EXP 140
55671: PUSH
55672: LD_VAR 0 2
55676: ARRAY
55677: PUSH
55678: LD_INT 1
55680: ARRAY
55681: PPUSH
55682: CALL_OW 310
55686: IFFALSE 55709
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55688: LD_EXP 140
55692: PUSH
55693: LD_VAR 0 2
55697: ARRAY
55698: PUSH
55699: LD_INT 1
55701: ARRAY
55702: PPUSH
55703: CALL_OW 122
55707: GO 55851
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55709: LD_EXP 140
55713: PUSH
55714: LD_VAR 0 2
55718: ARRAY
55719: PUSH
55720: LD_INT 1
55722: ARRAY
55723: PPUSH
55724: CALL_OW 314
55728: NOT
55729: PUSH
55730: LD_EXP 140
55734: PUSH
55735: LD_VAR 0 2
55739: ARRAY
55740: PUSH
55741: LD_INT 1
55743: ARRAY
55744: PPUSH
55745: LD_EXP 139
55749: PUSH
55750: LD_VAR 0 2
55754: ARRAY
55755: PUSH
55756: LD_INT 1
55758: ARRAY
55759: PUSH
55760: LD_INT 1
55762: ARRAY
55763: PPUSH
55764: LD_EXP 139
55768: PUSH
55769: LD_VAR 0 2
55773: ARRAY
55774: PUSH
55775: LD_INT 1
55777: ARRAY
55778: PUSH
55779: LD_INT 2
55781: ARRAY
55782: PPUSH
55783: CALL_OW 297
55787: PUSH
55788: LD_INT 6
55790: GREATER
55791: AND
55792: IFFALSE 55851
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55794: LD_EXP 140
55798: PUSH
55799: LD_VAR 0 2
55803: ARRAY
55804: PUSH
55805: LD_INT 1
55807: ARRAY
55808: PPUSH
55809: LD_EXP 139
55813: PUSH
55814: LD_VAR 0 2
55818: ARRAY
55819: PUSH
55820: LD_INT 1
55822: ARRAY
55823: PUSH
55824: LD_INT 1
55826: ARRAY
55827: PPUSH
55828: LD_EXP 139
55832: PUSH
55833: LD_VAR 0 2
55837: ARRAY
55838: PUSH
55839: LD_INT 1
55841: ARRAY
55842: PUSH
55843: LD_INT 2
55845: ARRAY
55846: PPUSH
55847: CALL_OW 111
// end ; end ; end ;
55851: GO 55264
55853: POP
55854: POP
// end ;
55855: LD_VAR 0 1
55859: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55860: LD_INT 0
55862: PPUSH
55863: PPUSH
55864: PPUSH
55865: PPUSH
55866: PPUSH
55867: PPUSH
55868: PPUSH
55869: PPUSH
55870: PPUSH
55871: PPUSH
55872: PPUSH
// if not mc_bases then
55873: LD_EXP 102
55877: NOT
55878: IFFALSE 55882
// exit ;
55880: GO 56822
// for i = 1 to mc_bases do
55882: LD_ADDR_VAR 0 2
55886: PUSH
55887: DOUBLE
55888: LD_INT 1
55890: DEC
55891: ST_TO_ADDR
55892: LD_EXP 102
55896: PUSH
55897: FOR_TO
55898: IFFALSE 56820
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55900: LD_EXP 102
55904: PUSH
55905: LD_VAR 0 2
55909: ARRAY
55910: NOT
55911: PUSH
55912: LD_EXP 125
55916: PUSH
55917: LD_VAR 0 2
55921: ARRAY
55922: OR
55923: IFFALSE 55927
// continue ;
55925: GO 55897
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55927: LD_ADDR_VAR 0 7
55931: PUSH
55932: LD_EXP 102
55936: PUSH
55937: LD_VAR 0 2
55941: ARRAY
55942: PUSH
55943: LD_INT 1
55945: ARRAY
55946: PPUSH
55947: CALL_OW 248
55951: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55952: LD_VAR 0 7
55956: PUSH
55957: LD_INT 3
55959: EQUAL
55960: PUSH
55961: LD_EXP 121
55965: PUSH
55966: LD_VAR 0 2
55970: ARRAY
55971: PUSH
55972: LD_EXP 124
55976: PUSH
55977: LD_VAR 0 2
55981: ARRAY
55982: UNION
55983: PPUSH
55984: LD_INT 33
55986: PUSH
55987: LD_INT 2
55989: PUSH
55990: EMPTY
55991: LIST
55992: LIST
55993: PPUSH
55994: CALL_OW 72
55998: NOT
55999: OR
56000: IFFALSE 56004
// continue ;
56002: GO 55897
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56004: LD_ADDR_VAR 0 9
56008: PUSH
56009: LD_EXP 102
56013: PUSH
56014: LD_VAR 0 2
56018: ARRAY
56019: PPUSH
56020: LD_INT 30
56022: PUSH
56023: LD_INT 36
56025: PUSH
56026: EMPTY
56027: LIST
56028: LIST
56029: PPUSH
56030: CALL_OW 72
56034: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56035: LD_ADDR_VAR 0 10
56039: PUSH
56040: LD_EXP 121
56044: PUSH
56045: LD_VAR 0 2
56049: ARRAY
56050: PPUSH
56051: LD_INT 34
56053: PUSH
56054: LD_INT 31
56056: PUSH
56057: EMPTY
56058: LIST
56059: LIST
56060: PPUSH
56061: CALL_OW 72
56065: ST_TO_ADDR
// if not cts and not mcts then
56066: LD_VAR 0 9
56070: NOT
56071: PUSH
56072: LD_VAR 0 10
56076: NOT
56077: AND
56078: IFFALSE 56082
// continue ;
56080: GO 55897
// x := cts ;
56082: LD_ADDR_VAR 0 11
56086: PUSH
56087: LD_VAR 0 9
56091: ST_TO_ADDR
// if not x then
56092: LD_VAR 0 11
56096: NOT
56097: IFFALSE 56109
// x := mcts ;
56099: LD_ADDR_VAR 0 11
56103: PUSH
56104: LD_VAR 0 10
56108: ST_TO_ADDR
// if not x then
56109: LD_VAR 0 11
56113: NOT
56114: IFFALSE 56118
// continue ;
56116: GO 55897
// if mc_remote_driver [ i ] then
56118: LD_EXP 142
56122: PUSH
56123: LD_VAR 0 2
56127: ARRAY
56128: IFFALSE 56515
// for j in mc_remote_driver [ i ] do
56130: LD_ADDR_VAR 0 3
56134: PUSH
56135: LD_EXP 142
56139: PUSH
56140: LD_VAR 0 2
56144: ARRAY
56145: PUSH
56146: FOR_IN
56147: IFFALSE 56513
// begin if GetClass ( j ) <> 3 then
56149: LD_VAR 0 3
56153: PPUSH
56154: CALL_OW 257
56158: PUSH
56159: LD_INT 3
56161: NONEQUAL
56162: IFFALSE 56215
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56164: LD_ADDR_EXP 142
56168: PUSH
56169: LD_EXP 142
56173: PPUSH
56174: LD_VAR 0 2
56178: PPUSH
56179: LD_EXP 142
56183: PUSH
56184: LD_VAR 0 2
56188: ARRAY
56189: PUSH
56190: LD_VAR 0 3
56194: DIFF
56195: PPUSH
56196: CALL_OW 1
56200: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56201: LD_VAR 0 3
56205: PPUSH
56206: LD_INT 0
56208: PPUSH
56209: CALL_OW 109
// continue ;
56213: GO 56146
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56215: LD_EXP 121
56219: PUSH
56220: LD_VAR 0 2
56224: ARRAY
56225: PPUSH
56226: LD_INT 34
56228: PUSH
56229: LD_INT 31
56231: PUSH
56232: EMPTY
56233: LIST
56234: LIST
56235: PUSH
56236: LD_INT 58
56238: PUSH
56239: EMPTY
56240: LIST
56241: PUSH
56242: EMPTY
56243: LIST
56244: LIST
56245: PPUSH
56246: CALL_OW 72
56250: PUSH
56251: LD_VAR 0 3
56255: PPUSH
56256: CALL 105373 0 1
56260: NOT
56261: AND
56262: IFFALSE 56333
// begin if IsInUnit ( j ) then
56264: LD_VAR 0 3
56268: PPUSH
56269: CALL_OW 310
56273: IFFALSE 56284
// ComExitBuilding ( j ) ;
56275: LD_VAR 0 3
56279: PPUSH
56280: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56284: LD_VAR 0 3
56288: PPUSH
56289: LD_EXP 121
56293: PUSH
56294: LD_VAR 0 2
56298: ARRAY
56299: PPUSH
56300: LD_INT 34
56302: PUSH
56303: LD_INT 31
56305: PUSH
56306: EMPTY
56307: LIST
56308: LIST
56309: PUSH
56310: LD_INT 58
56312: PUSH
56313: EMPTY
56314: LIST
56315: PUSH
56316: EMPTY
56317: LIST
56318: LIST
56319: PPUSH
56320: CALL_OW 72
56324: PUSH
56325: LD_INT 1
56327: ARRAY
56328: PPUSH
56329: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56333: LD_VAR 0 3
56337: PPUSH
56338: CALL_OW 310
56342: NOT
56343: PUSH
56344: LD_VAR 0 3
56348: PPUSH
56349: CALL_OW 310
56353: PPUSH
56354: CALL_OW 266
56358: PUSH
56359: LD_INT 36
56361: NONEQUAL
56362: PUSH
56363: LD_VAR 0 3
56367: PPUSH
56368: CALL 105373 0 1
56372: NOT
56373: AND
56374: OR
56375: IFFALSE 56511
// begin if IsInUnit ( j ) then
56377: LD_VAR 0 3
56381: PPUSH
56382: CALL_OW 310
56386: IFFALSE 56397
// ComExitBuilding ( j ) ;
56388: LD_VAR 0 3
56392: PPUSH
56393: CALL_OW 122
// ct := 0 ;
56397: LD_ADDR_VAR 0 8
56401: PUSH
56402: LD_INT 0
56404: ST_TO_ADDR
// for k in x do
56405: LD_ADDR_VAR 0 4
56409: PUSH
56410: LD_VAR 0 11
56414: PUSH
56415: FOR_IN
56416: IFFALSE 56489
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56418: LD_VAR 0 4
56422: PPUSH
56423: CALL_OW 264
56427: PUSH
56428: LD_INT 31
56430: EQUAL
56431: PUSH
56432: LD_VAR 0 4
56436: PPUSH
56437: CALL_OW 311
56441: NOT
56442: AND
56443: PUSH
56444: LD_VAR 0 4
56448: PPUSH
56449: CALL_OW 266
56453: PUSH
56454: LD_INT 36
56456: EQUAL
56457: PUSH
56458: LD_VAR 0 4
56462: PPUSH
56463: CALL_OW 313
56467: PUSH
56468: LD_INT 3
56470: LESS
56471: AND
56472: OR
56473: IFFALSE 56487
// begin ct := k ;
56475: LD_ADDR_VAR 0 8
56479: PUSH
56480: LD_VAR 0 4
56484: ST_TO_ADDR
// break ;
56485: GO 56489
// end ;
56487: GO 56415
56489: POP
56490: POP
// if ct then
56491: LD_VAR 0 8
56495: IFFALSE 56511
// ComEnterUnit ( j , ct ) ;
56497: LD_VAR 0 3
56501: PPUSH
56502: LD_VAR 0 8
56506: PPUSH
56507: CALL_OW 120
// end ; end ;
56511: GO 56146
56513: POP
56514: POP
// places := 0 ;
56515: LD_ADDR_VAR 0 5
56519: PUSH
56520: LD_INT 0
56522: ST_TO_ADDR
// for j = 1 to x do
56523: LD_ADDR_VAR 0 3
56527: PUSH
56528: DOUBLE
56529: LD_INT 1
56531: DEC
56532: ST_TO_ADDR
56533: LD_VAR 0 11
56537: PUSH
56538: FOR_TO
56539: IFFALSE 56615
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56541: LD_VAR 0 11
56545: PUSH
56546: LD_VAR 0 3
56550: ARRAY
56551: PPUSH
56552: CALL_OW 264
56556: PUSH
56557: LD_INT 31
56559: EQUAL
56560: IFFALSE 56578
// places := places + 1 else
56562: LD_ADDR_VAR 0 5
56566: PUSH
56567: LD_VAR 0 5
56571: PUSH
56572: LD_INT 1
56574: PLUS
56575: ST_TO_ADDR
56576: GO 56613
// if GetBType ( x [ j ] ) = b_control_tower then
56578: LD_VAR 0 11
56582: PUSH
56583: LD_VAR 0 3
56587: ARRAY
56588: PPUSH
56589: CALL_OW 266
56593: PUSH
56594: LD_INT 36
56596: EQUAL
56597: IFFALSE 56613
// places := places + 3 ;
56599: LD_ADDR_VAR 0 5
56603: PUSH
56604: LD_VAR 0 5
56608: PUSH
56609: LD_INT 3
56611: PLUS
56612: ST_TO_ADDR
56613: GO 56538
56615: POP
56616: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56617: LD_VAR 0 5
56621: PUSH
56622: LD_INT 0
56624: EQUAL
56625: PUSH
56626: LD_VAR 0 5
56630: PUSH
56631: LD_EXP 142
56635: PUSH
56636: LD_VAR 0 2
56640: ARRAY
56641: LESSEQUAL
56642: OR
56643: IFFALSE 56647
// continue ;
56645: GO 55897
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56647: LD_ADDR_VAR 0 6
56651: PUSH
56652: LD_EXP 102
56656: PUSH
56657: LD_VAR 0 2
56661: ARRAY
56662: PPUSH
56663: LD_INT 25
56665: PUSH
56666: LD_INT 3
56668: PUSH
56669: EMPTY
56670: LIST
56671: LIST
56672: PPUSH
56673: CALL_OW 72
56677: PUSH
56678: LD_EXP 142
56682: PUSH
56683: LD_VAR 0 2
56687: ARRAY
56688: DIFF
56689: PPUSH
56690: LD_INT 3
56692: PPUSH
56693: CALL 106273 0 2
56697: ST_TO_ADDR
// for j in tmp do
56698: LD_ADDR_VAR 0 3
56702: PUSH
56703: LD_VAR 0 6
56707: PUSH
56708: FOR_IN
56709: IFFALSE 56744
// if GetTag ( j ) > 0 then
56711: LD_VAR 0 3
56715: PPUSH
56716: CALL_OW 110
56720: PUSH
56721: LD_INT 0
56723: GREATER
56724: IFFALSE 56742
// tmp := tmp diff j ;
56726: LD_ADDR_VAR 0 6
56730: PUSH
56731: LD_VAR 0 6
56735: PUSH
56736: LD_VAR 0 3
56740: DIFF
56741: ST_TO_ADDR
56742: GO 56708
56744: POP
56745: POP
// if not tmp then
56746: LD_VAR 0 6
56750: NOT
56751: IFFALSE 56755
// continue ;
56753: GO 55897
// if places then
56755: LD_VAR 0 5
56759: IFFALSE 56818
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56761: LD_ADDR_EXP 142
56765: PUSH
56766: LD_EXP 142
56770: PPUSH
56771: LD_VAR 0 2
56775: PPUSH
56776: LD_EXP 142
56780: PUSH
56781: LD_VAR 0 2
56785: ARRAY
56786: PUSH
56787: LD_VAR 0 6
56791: PUSH
56792: LD_INT 1
56794: ARRAY
56795: UNION
56796: PPUSH
56797: CALL_OW 1
56801: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56802: LD_VAR 0 6
56806: PUSH
56807: LD_INT 1
56809: ARRAY
56810: PPUSH
56811: LD_INT 126
56813: PPUSH
56814: CALL_OW 109
// end ; end ;
56818: GO 55897
56820: POP
56821: POP
// end ;
56822: LD_VAR 0 1
56826: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56827: LD_INT 0
56829: PPUSH
56830: PPUSH
56831: PPUSH
56832: PPUSH
56833: PPUSH
56834: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56835: LD_VAR 0 1
56839: NOT
56840: PUSH
56841: LD_VAR 0 2
56845: NOT
56846: OR
56847: PUSH
56848: LD_VAR 0 3
56852: NOT
56853: OR
56854: PUSH
56855: LD_VAR 0 4
56859: PUSH
56860: LD_INT 1
56862: PUSH
56863: LD_INT 2
56865: PUSH
56866: LD_INT 3
56868: PUSH
56869: LD_INT 4
56871: PUSH
56872: LD_INT 5
56874: PUSH
56875: LD_INT 8
56877: PUSH
56878: LD_INT 9
56880: PUSH
56881: LD_INT 15
56883: PUSH
56884: LD_INT 16
56886: PUSH
56887: EMPTY
56888: LIST
56889: LIST
56890: LIST
56891: LIST
56892: LIST
56893: LIST
56894: LIST
56895: LIST
56896: LIST
56897: IN
56898: NOT
56899: OR
56900: IFFALSE 56904
// exit ;
56902: GO 57804
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56904: LD_ADDR_VAR 0 2
56908: PUSH
56909: LD_VAR 0 2
56913: PPUSH
56914: LD_INT 21
56916: PUSH
56917: LD_INT 3
56919: PUSH
56920: EMPTY
56921: LIST
56922: LIST
56923: PUSH
56924: LD_INT 24
56926: PUSH
56927: LD_INT 250
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: PUSH
56934: EMPTY
56935: LIST
56936: LIST
56937: PPUSH
56938: CALL_OW 72
56942: ST_TO_ADDR
// case class of 1 , 15 :
56943: LD_VAR 0 4
56947: PUSH
56948: LD_INT 1
56950: DOUBLE
56951: EQUAL
56952: IFTRUE 56962
56954: LD_INT 15
56956: DOUBLE
56957: EQUAL
56958: IFTRUE 56962
56960: GO 57047
56962: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56963: LD_ADDR_VAR 0 8
56967: PUSH
56968: LD_VAR 0 2
56972: PPUSH
56973: LD_INT 2
56975: PUSH
56976: LD_INT 30
56978: PUSH
56979: LD_INT 32
56981: PUSH
56982: EMPTY
56983: LIST
56984: LIST
56985: PUSH
56986: LD_INT 30
56988: PUSH
56989: LD_INT 31
56991: PUSH
56992: EMPTY
56993: LIST
56994: LIST
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: LIST
57000: PPUSH
57001: CALL_OW 72
57005: PUSH
57006: LD_VAR 0 2
57010: PPUSH
57011: LD_INT 2
57013: PUSH
57014: LD_INT 30
57016: PUSH
57017: LD_INT 4
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: PUSH
57024: LD_INT 30
57026: PUSH
57027: LD_INT 5
57029: PUSH
57030: EMPTY
57031: LIST
57032: LIST
57033: PUSH
57034: EMPTY
57035: LIST
57036: LIST
57037: LIST
57038: PPUSH
57039: CALL_OW 72
57043: ADD
57044: ST_TO_ADDR
57045: GO 57293
57047: LD_INT 2
57049: DOUBLE
57050: EQUAL
57051: IFTRUE 57061
57053: LD_INT 16
57055: DOUBLE
57056: EQUAL
57057: IFTRUE 57061
57059: GO 57107
57061: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57062: LD_ADDR_VAR 0 8
57066: PUSH
57067: LD_VAR 0 2
57071: PPUSH
57072: LD_INT 2
57074: PUSH
57075: LD_INT 30
57077: PUSH
57078: LD_INT 0
57080: PUSH
57081: EMPTY
57082: LIST
57083: LIST
57084: PUSH
57085: LD_INT 30
57087: PUSH
57088: LD_INT 1
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: PUSH
57095: EMPTY
57096: LIST
57097: LIST
57098: LIST
57099: PPUSH
57100: CALL_OW 72
57104: ST_TO_ADDR
57105: GO 57293
57107: LD_INT 3
57109: DOUBLE
57110: EQUAL
57111: IFTRUE 57115
57113: GO 57161
57115: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57116: LD_ADDR_VAR 0 8
57120: PUSH
57121: LD_VAR 0 2
57125: PPUSH
57126: LD_INT 2
57128: PUSH
57129: LD_INT 30
57131: PUSH
57132: LD_INT 2
57134: PUSH
57135: EMPTY
57136: LIST
57137: LIST
57138: PUSH
57139: LD_INT 30
57141: PUSH
57142: LD_INT 3
57144: PUSH
57145: EMPTY
57146: LIST
57147: LIST
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: LIST
57153: PPUSH
57154: CALL_OW 72
57158: ST_TO_ADDR
57159: GO 57293
57161: LD_INT 4
57163: DOUBLE
57164: EQUAL
57165: IFTRUE 57169
57167: GO 57226
57169: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57170: LD_ADDR_VAR 0 8
57174: PUSH
57175: LD_VAR 0 2
57179: PPUSH
57180: LD_INT 2
57182: PUSH
57183: LD_INT 30
57185: PUSH
57186: LD_INT 6
57188: PUSH
57189: EMPTY
57190: LIST
57191: LIST
57192: PUSH
57193: LD_INT 30
57195: PUSH
57196: LD_INT 7
57198: PUSH
57199: EMPTY
57200: LIST
57201: LIST
57202: PUSH
57203: LD_INT 30
57205: PUSH
57206: LD_INT 8
57208: PUSH
57209: EMPTY
57210: LIST
57211: LIST
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: LIST
57217: LIST
57218: PPUSH
57219: CALL_OW 72
57223: ST_TO_ADDR
57224: GO 57293
57226: LD_INT 5
57228: DOUBLE
57229: EQUAL
57230: IFTRUE 57246
57232: LD_INT 8
57234: DOUBLE
57235: EQUAL
57236: IFTRUE 57246
57238: LD_INT 9
57240: DOUBLE
57241: EQUAL
57242: IFTRUE 57246
57244: GO 57292
57246: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57247: LD_ADDR_VAR 0 8
57251: PUSH
57252: LD_VAR 0 2
57256: PPUSH
57257: LD_INT 2
57259: PUSH
57260: LD_INT 30
57262: PUSH
57263: LD_INT 4
57265: PUSH
57266: EMPTY
57267: LIST
57268: LIST
57269: PUSH
57270: LD_INT 30
57272: PUSH
57273: LD_INT 5
57275: PUSH
57276: EMPTY
57277: LIST
57278: LIST
57279: PUSH
57280: EMPTY
57281: LIST
57282: LIST
57283: LIST
57284: PPUSH
57285: CALL_OW 72
57289: ST_TO_ADDR
57290: GO 57293
57292: POP
// if not tmp then
57293: LD_VAR 0 8
57297: NOT
57298: IFFALSE 57302
// exit ;
57300: GO 57804
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57302: LD_VAR 0 4
57306: PUSH
57307: LD_INT 1
57309: PUSH
57310: LD_INT 15
57312: PUSH
57313: EMPTY
57314: LIST
57315: LIST
57316: IN
57317: PUSH
57318: LD_EXP 111
57322: PUSH
57323: LD_VAR 0 1
57327: ARRAY
57328: AND
57329: IFFALSE 57485
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57331: LD_ADDR_VAR 0 9
57335: PUSH
57336: LD_EXP 111
57340: PUSH
57341: LD_VAR 0 1
57345: ARRAY
57346: PUSH
57347: LD_INT 1
57349: ARRAY
57350: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57351: LD_VAR 0 9
57355: PUSH
57356: LD_EXP 112
57360: PUSH
57361: LD_VAR 0 1
57365: ARRAY
57366: IN
57367: NOT
57368: IFFALSE 57483
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57370: LD_ADDR_EXP 112
57374: PUSH
57375: LD_EXP 112
57379: PPUSH
57380: LD_VAR 0 1
57384: PUSH
57385: LD_EXP 112
57389: PUSH
57390: LD_VAR 0 1
57394: ARRAY
57395: PUSH
57396: LD_INT 1
57398: PLUS
57399: PUSH
57400: EMPTY
57401: LIST
57402: LIST
57403: PPUSH
57404: LD_VAR 0 9
57408: PPUSH
57409: CALL 72015 0 3
57413: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57414: LD_ADDR_EXP 111
57418: PUSH
57419: LD_EXP 111
57423: PPUSH
57424: LD_VAR 0 1
57428: PPUSH
57429: LD_EXP 111
57433: PUSH
57434: LD_VAR 0 1
57438: ARRAY
57439: PUSH
57440: LD_VAR 0 9
57444: DIFF
57445: PPUSH
57446: CALL_OW 1
57450: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57451: LD_VAR 0 3
57455: PPUSH
57456: LD_EXP 112
57460: PUSH
57461: LD_VAR 0 1
57465: ARRAY
57466: PUSH
57467: LD_EXP 112
57471: PUSH
57472: LD_VAR 0 1
57476: ARRAY
57477: ARRAY
57478: PPUSH
57479: CALL_OW 120
// end ; exit ;
57483: GO 57804
// end ; if tmp > 1 then
57485: LD_VAR 0 8
57489: PUSH
57490: LD_INT 1
57492: GREATER
57493: IFFALSE 57597
// for i = 2 to tmp do
57495: LD_ADDR_VAR 0 6
57499: PUSH
57500: DOUBLE
57501: LD_INT 2
57503: DEC
57504: ST_TO_ADDR
57505: LD_VAR 0 8
57509: PUSH
57510: FOR_TO
57511: IFFALSE 57595
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57513: LD_VAR 0 8
57517: PUSH
57518: LD_VAR 0 6
57522: ARRAY
57523: PPUSH
57524: CALL_OW 461
57528: PUSH
57529: LD_INT 6
57531: EQUAL
57532: IFFALSE 57593
// begin x := tmp [ i ] ;
57534: LD_ADDR_VAR 0 9
57538: PUSH
57539: LD_VAR 0 8
57543: PUSH
57544: LD_VAR 0 6
57548: ARRAY
57549: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57550: LD_ADDR_VAR 0 8
57554: PUSH
57555: LD_VAR 0 8
57559: PPUSH
57560: LD_VAR 0 6
57564: PPUSH
57565: CALL_OW 3
57569: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57570: LD_ADDR_VAR 0 8
57574: PUSH
57575: LD_VAR 0 8
57579: PPUSH
57580: LD_INT 1
57582: PPUSH
57583: LD_VAR 0 9
57587: PPUSH
57588: CALL_OW 2
57592: ST_TO_ADDR
// end ;
57593: GO 57510
57595: POP
57596: POP
// for i in tmp do
57597: LD_ADDR_VAR 0 6
57601: PUSH
57602: LD_VAR 0 8
57606: PUSH
57607: FOR_IN
57608: IFFALSE 57677
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57610: LD_VAR 0 6
57614: PPUSH
57615: CALL_OW 313
57619: PUSH
57620: LD_INT 6
57622: LESS
57623: PUSH
57624: LD_VAR 0 6
57628: PPUSH
57629: CALL_OW 266
57633: PUSH
57634: LD_INT 31
57636: PUSH
57637: LD_INT 32
57639: PUSH
57640: EMPTY
57641: LIST
57642: LIST
57643: IN
57644: NOT
57645: AND
57646: PUSH
57647: LD_VAR 0 6
57651: PPUSH
57652: CALL_OW 313
57656: PUSH
57657: LD_INT 0
57659: EQUAL
57660: OR
57661: IFFALSE 57675
// begin j := i ;
57663: LD_ADDR_VAR 0 7
57667: PUSH
57668: LD_VAR 0 6
57672: ST_TO_ADDR
// break ;
57673: GO 57677
// end ; end ;
57675: GO 57607
57677: POP
57678: POP
// if j then
57679: LD_VAR 0 7
57683: IFFALSE 57701
// ComEnterUnit ( unit , j ) else
57685: LD_VAR 0 3
57689: PPUSH
57690: LD_VAR 0 7
57694: PPUSH
57695: CALL_OW 120
57699: GO 57804
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57701: LD_ADDR_VAR 0 10
57705: PUSH
57706: LD_VAR 0 2
57710: PPUSH
57711: LD_INT 2
57713: PUSH
57714: LD_INT 30
57716: PUSH
57717: LD_INT 0
57719: PUSH
57720: EMPTY
57721: LIST
57722: LIST
57723: PUSH
57724: LD_INT 30
57726: PUSH
57727: LD_INT 1
57729: PUSH
57730: EMPTY
57731: LIST
57732: LIST
57733: PUSH
57734: EMPTY
57735: LIST
57736: LIST
57737: LIST
57738: PPUSH
57739: CALL_OW 72
57743: ST_TO_ADDR
// if depot then
57744: LD_VAR 0 10
57748: IFFALSE 57804
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57750: LD_ADDR_VAR 0 10
57754: PUSH
57755: LD_VAR 0 10
57759: PPUSH
57760: LD_VAR 0 3
57764: PPUSH
57765: CALL_OW 74
57769: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57770: LD_VAR 0 3
57774: PPUSH
57775: LD_VAR 0 10
57779: PPUSH
57780: CALL_OW 296
57784: PUSH
57785: LD_INT 10
57787: GREATER
57788: IFFALSE 57804
// ComStandNearbyBuilding ( unit , depot ) ;
57790: LD_VAR 0 3
57794: PPUSH
57795: LD_VAR 0 10
57799: PPUSH
57800: CALL 66218 0 2
// end ; end ; end ;
57804: LD_VAR 0 5
57808: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57809: LD_INT 0
57811: PPUSH
57812: PPUSH
57813: PPUSH
57814: PPUSH
// if not mc_bases then
57815: LD_EXP 102
57819: NOT
57820: IFFALSE 57824
// exit ;
57822: GO 58063
// for i = 1 to mc_bases do
57824: LD_ADDR_VAR 0 2
57828: PUSH
57829: DOUBLE
57830: LD_INT 1
57832: DEC
57833: ST_TO_ADDR
57834: LD_EXP 102
57838: PUSH
57839: FOR_TO
57840: IFFALSE 58061
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57842: LD_ADDR_VAR 0 4
57846: PUSH
57847: LD_EXP 102
57851: PUSH
57852: LD_VAR 0 2
57856: ARRAY
57857: PPUSH
57858: LD_INT 21
57860: PUSH
57861: LD_INT 1
57863: PUSH
57864: EMPTY
57865: LIST
57866: LIST
57867: PPUSH
57868: CALL_OW 72
57872: PUSH
57873: LD_EXP 131
57877: PUSH
57878: LD_VAR 0 2
57882: ARRAY
57883: UNION
57884: ST_TO_ADDR
// if not tmp then
57885: LD_VAR 0 4
57889: NOT
57890: IFFALSE 57894
// continue ;
57892: GO 57839
// for j in tmp do
57894: LD_ADDR_VAR 0 3
57898: PUSH
57899: LD_VAR 0 4
57903: PUSH
57904: FOR_IN
57905: IFFALSE 58057
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57907: LD_VAR 0 3
57911: PPUSH
57912: CALL_OW 110
57916: NOT
57917: PUSH
57918: LD_VAR 0 3
57922: PPUSH
57923: CALL_OW 314
57927: NOT
57928: AND
57929: PUSH
57930: LD_VAR 0 3
57934: PPUSH
57935: CALL_OW 311
57939: NOT
57940: AND
57941: PUSH
57942: LD_VAR 0 3
57946: PPUSH
57947: CALL_OW 310
57951: NOT
57952: AND
57953: PUSH
57954: LD_VAR 0 3
57958: PUSH
57959: LD_EXP 105
57963: PUSH
57964: LD_VAR 0 2
57968: ARRAY
57969: PUSH
57970: LD_INT 1
57972: ARRAY
57973: IN
57974: NOT
57975: AND
57976: PUSH
57977: LD_VAR 0 3
57981: PUSH
57982: LD_EXP 105
57986: PUSH
57987: LD_VAR 0 2
57991: ARRAY
57992: PUSH
57993: LD_INT 2
57995: ARRAY
57996: IN
57997: NOT
57998: AND
57999: PUSH
58000: LD_VAR 0 3
58004: PUSH
58005: LD_EXP 114
58009: PUSH
58010: LD_VAR 0 2
58014: ARRAY
58015: IN
58016: NOT
58017: AND
58018: IFFALSE 58055
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58020: LD_VAR 0 2
58024: PPUSH
58025: LD_EXP 102
58029: PUSH
58030: LD_VAR 0 2
58034: ARRAY
58035: PPUSH
58036: LD_VAR 0 3
58040: PPUSH
58041: LD_VAR 0 3
58045: PPUSH
58046: CALL_OW 257
58050: PPUSH
58051: CALL 56827 0 4
// end ;
58055: GO 57904
58057: POP
58058: POP
// end ;
58059: GO 57839
58061: POP
58062: POP
// end ;
58063: LD_VAR 0 1
58067: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58068: LD_INT 0
58070: PPUSH
58071: PPUSH
58072: PPUSH
58073: PPUSH
58074: PPUSH
58075: PPUSH
// if not mc_bases [ base ] then
58076: LD_EXP 102
58080: PUSH
58081: LD_VAR 0 1
58085: ARRAY
58086: NOT
58087: IFFALSE 58091
// exit ;
58089: GO 58273
// tmp := [ ] ;
58091: LD_ADDR_VAR 0 6
58095: PUSH
58096: EMPTY
58097: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58098: LD_ADDR_VAR 0 7
58102: PUSH
58103: LD_VAR 0 3
58107: PPUSH
58108: LD_INT 0
58110: PPUSH
58111: CALL_OW 517
58115: ST_TO_ADDR
// if not list then
58116: LD_VAR 0 7
58120: NOT
58121: IFFALSE 58125
// exit ;
58123: GO 58273
// for i = 1 to amount do
58125: LD_ADDR_VAR 0 5
58129: PUSH
58130: DOUBLE
58131: LD_INT 1
58133: DEC
58134: ST_TO_ADDR
58135: LD_VAR 0 2
58139: PUSH
58140: FOR_TO
58141: IFFALSE 58221
// begin x := rand ( 1 , list [ 1 ] ) ;
58143: LD_ADDR_VAR 0 8
58147: PUSH
58148: LD_INT 1
58150: PPUSH
58151: LD_VAR 0 7
58155: PUSH
58156: LD_INT 1
58158: ARRAY
58159: PPUSH
58160: CALL_OW 12
58164: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58165: LD_ADDR_VAR 0 6
58169: PUSH
58170: LD_VAR 0 6
58174: PPUSH
58175: LD_VAR 0 5
58179: PPUSH
58180: LD_VAR 0 7
58184: PUSH
58185: LD_INT 1
58187: ARRAY
58188: PUSH
58189: LD_VAR 0 8
58193: ARRAY
58194: PUSH
58195: LD_VAR 0 7
58199: PUSH
58200: LD_INT 2
58202: ARRAY
58203: PUSH
58204: LD_VAR 0 8
58208: ARRAY
58209: PUSH
58210: EMPTY
58211: LIST
58212: LIST
58213: PPUSH
58214: CALL_OW 1
58218: ST_TO_ADDR
// end ;
58219: GO 58140
58221: POP
58222: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58223: LD_ADDR_EXP 115
58227: PUSH
58228: LD_EXP 115
58232: PPUSH
58233: LD_VAR 0 1
58237: PPUSH
58238: LD_VAR 0 6
58242: PPUSH
58243: CALL_OW 1
58247: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58248: LD_ADDR_EXP 117
58252: PUSH
58253: LD_EXP 117
58257: PPUSH
58258: LD_VAR 0 1
58262: PPUSH
58263: LD_VAR 0 3
58267: PPUSH
58268: CALL_OW 1
58272: ST_TO_ADDR
// end ;
58273: LD_VAR 0 4
58277: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58278: LD_INT 0
58280: PPUSH
// if not mc_bases [ base ] then
58281: LD_EXP 102
58285: PUSH
58286: LD_VAR 0 1
58290: ARRAY
58291: NOT
58292: IFFALSE 58296
// exit ;
58294: GO 58321
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58296: LD_ADDR_EXP 107
58300: PUSH
58301: LD_EXP 107
58305: PPUSH
58306: LD_VAR 0 1
58310: PPUSH
58311: LD_VAR 0 2
58315: PPUSH
58316: CALL_OW 1
58320: ST_TO_ADDR
// end ;
58321: LD_VAR 0 3
58325: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58326: LD_INT 0
58328: PPUSH
// if not mc_bases [ base ] then
58329: LD_EXP 102
58333: PUSH
58334: LD_VAR 0 1
58338: ARRAY
58339: NOT
58340: IFFALSE 58344
// exit ;
58342: GO 58381
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58344: LD_ADDR_EXP 107
58348: PUSH
58349: LD_EXP 107
58353: PPUSH
58354: LD_VAR 0 1
58358: PPUSH
58359: LD_EXP 107
58363: PUSH
58364: LD_VAR 0 1
58368: ARRAY
58369: PUSH
58370: LD_VAR 0 2
58374: UNION
58375: PPUSH
58376: CALL_OW 1
58380: ST_TO_ADDR
// end ;
58381: LD_VAR 0 3
58385: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58386: LD_INT 0
58388: PPUSH
// if not mc_bases [ base ] then
58389: LD_EXP 102
58393: PUSH
58394: LD_VAR 0 1
58398: ARRAY
58399: NOT
58400: IFFALSE 58404
// exit ;
58402: GO 58429
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58404: LD_ADDR_EXP 123
58408: PUSH
58409: LD_EXP 123
58413: PPUSH
58414: LD_VAR 0 1
58418: PPUSH
58419: LD_VAR 0 2
58423: PPUSH
58424: CALL_OW 1
58428: ST_TO_ADDR
// end ;
58429: LD_VAR 0 3
58433: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58434: LD_INT 0
58436: PPUSH
// if not mc_bases [ base ] then
58437: LD_EXP 102
58441: PUSH
58442: LD_VAR 0 1
58446: ARRAY
58447: NOT
58448: IFFALSE 58452
// exit ;
58450: GO 58489
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58452: LD_ADDR_EXP 123
58456: PUSH
58457: LD_EXP 123
58461: PPUSH
58462: LD_VAR 0 1
58466: PPUSH
58467: LD_EXP 123
58471: PUSH
58472: LD_VAR 0 1
58476: ARRAY
58477: PUSH
58478: LD_VAR 0 2
58482: ADD
58483: PPUSH
58484: CALL_OW 1
58488: ST_TO_ADDR
// end ;
58489: LD_VAR 0 3
58493: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58494: LD_INT 0
58496: PPUSH
// if not mc_bases [ base ] then
58497: LD_EXP 102
58501: PUSH
58502: LD_VAR 0 1
58506: ARRAY
58507: NOT
58508: IFFALSE 58512
// exit ;
58510: GO 58566
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58512: LD_ADDR_EXP 124
58516: PUSH
58517: LD_EXP 124
58521: PPUSH
58522: LD_VAR 0 1
58526: PPUSH
58527: LD_VAR 0 2
58531: PPUSH
58532: CALL_OW 1
58536: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58537: LD_ADDR_EXP 113
58541: PUSH
58542: LD_EXP 113
58546: PPUSH
58547: LD_VAR 0 1
58551: PPUSH
58552: LD_VAR 0 2
58556: PUSH
58557: LD_INT 0
58559: PLUS
58560: PPUSH
58561: CALL_OW 1
58565: ST_TO_ADDR
// end ;
58566: LD_VAR 0 3
58570: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58571: LD_INT 0
58573: PPUSH
// if not mc_bases [ base ] then
58574: LD_EXP 102
58578: PUSH
58579: LD_VAR 0 1
58583: ARRAY
58584: NOT
58585: IFFALSE 58589
// exit ;
58587: GO 58614
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58589: LD_ADDR_EXP 113
58593: PUSH
58594: LD_EXP 113
58598: PPUSH
58599: LD_VAR 0 1
58603: PPUSH
58604: LD_VAR 0 2
58608: PPUSH
58609: CALL_OW 1
58613: ST_TO_ADDR
// end ;
58614: LD_VAR 0 3
58618: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58619: LD_INT 0
58621: PPUSH
58622: PPUSH
58623: PPUSH
58624: PPUSH
// if not mc_bases [ base ] then
58625: LD_EXP 102
58629: PUSH
58630: LD_VAR 0 1
58634: ARRAY
58635: NOT
58636: IFFALSE 58640
// exit ;
58638: GO 58705
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58640: LD_ADDR_EXP 122
58644: PUSH
58645: LD_EXP 122
58649: PPUSH
58650: LD_VAR 0 1
58654: PUSH
58655: LD_EXP 122
58659: PUSH
58660: LD_VAR 0 1
58664: ARRAY
58665: PUSH
58666: LD_INT 1
58668: PLUS
58669: PUSH
58670: EMPTY
58671: LIST
58672: LIST
58673: PPUSH
58674: LD_VAR 0 1
58678: PUSH
58679: LD_VAR 0 2
58683: PUSH
58684: LD_VAR 0 3
58688: PUSH
58689: LD_VAR 0 4
58693: PUSH
58694: EMPTY
58695: LIST
58696: LIST
58697: LIST
58698: LIST
58699: PPUSH
58700: CALL 72015 0 3
58704: ST_TO_ADDR
// end ;
58705: LD_VAR 0 5
58709: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58710: LD_INT 0
58712: PPUSH
// if not mc_bases [ base ] then
58713: LD_EXP 102
58717: PUSH
58718: LD_VAR 0 1
58722: ARRAY
58723: NOT
58724: IFFALSE 58728
// exit ;
58726: GO 58753
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58728: LD_ADDR_EXP 139
58732: PUSH
58733: LD_EXP 139
58737: PPUSH
58738: LD_VAR 0 1
58742: PPUSH
58743: LD_VAR 0 2
58747: PPUSH
58748: CALL_OW 1
58752: ST_TO_ADDR
// end ;
58753: LD_VAR 0 3
58757: RET
// export function MC_GetMinesField ( base ) ; begin
58758: LD_INT 0
58760: PPUSH
// result := mc_mines [ base ] ;
58761: LD_ADDR_VAR 0 2
58765: PUSH
58766: LD_EXP 115
58770: PUSH
58771: LD_VAR 0 1
58775: ARRAY
58776: ST_TO_ADDR
// end ;
58777: LD_VAR 0 2
58781: RET
// export function MC_GetProduceList ( base ) ; begin
58782: LD_INT 0
58784: PPUSH
// result := mc_produce [ base ] ;
58785: LD_ADDR_VAR 0 2
58789: PUSH
58790: LD_EXP 123
58794: PUSH
58795: LD_VAR 0 1
58799: ARRAY
58800: ST_TO_ADDR
// end ;
58801: LD_VAR 0 2
58805: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58806: LD_INT 0
58808: PPUSH
58809: PPUSH
// if not mc_bases then
58810: LD_EXP 102
58814: NOT
58815: IFFALSE 58819
// exit ;
58817: GO 58884
// if mc_bases [ base ] then
58819: LD_EXP 102
58823: PUSH
58824: LD_VAR 0 1
58828: ARRAY
58829: IFFALSE 58884
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58831: LD_ADDR_VAR 0 3
58835: PUSH
58836: LD_EXP 102
58840: PUSH
58841: LD_VAR 0 1
58845: ARRAY
58846: PPUSH
58847: LD_INT 30
58849: PUSH
58850: LD_VAR 0 2
58854: PUSH
58855: EMPTY
58856: LIST
58857: LIST
58858: PPUSH
58859: CALL_OW 72
58863: ST_TO_ADDR
// if result then
58864: LD_VAR 0 3
58868: IFFALSE 58884
// result := result [ 1 ] ;
58870: LD_ADDR_VAR 0 3
58874: PUSH
58875: LD_VAR 0 3
58879: PUSH
58880: LD_INT 1
58882: ARRAY
58883: ST_TO_ADDR
// end ; end ;
58884: LD_VAR 0 3
58888: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58889: LD_INT 0
58891: PPUSH
58892: PPUSH
// if not mc_bases then
58893: LD_EXP 102
58897: NOT
58898: IFFALSE 58902
// exit ;
58900: GO 58947
// if mc_bases [ base ] then
58902: LD_EXP 102
58906: PUSH
58907: LD_VAR 0 1
58911: ARRAY
58912: IFFALSE 58947
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58914: LD_ADDR_VAR 0 3
58918: PUSH
58919: LD_EXP 102
58923: PUSH
58924: LD_VAR 0 1
58928: ARRAY
58929: PPUSH
58930: LD_INT 30
58932: PUSH
58933: LD_VAR 0 2
58937: PUSH
58938: EMPTY
58939: LIST
58940: LIST
58941: PPUSH
58942: CALL_OW 72
58946: ST_TO_ADDR
// end ;
58947: LD_VAR 0 3
58951: RET
// export function MC_SetTame ( base , area ) ; begin
58952: LD_INT 0
58954: PPUSH
// if not mc_bases or not base then
58955: LD_EXP 102
58959: NOT
58960: PUSH
58961: LD_VAR 0 1
58965: NOT
58966: OR
58967: IFFALSE 58971
// exit ;
58969: GO 58996
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58971: LD_ADDR_EXP 130
58975: PUSH
58976: LD_EXP 130
58980: PPUSH
58981: LD_VAR 0 1
58985: PPUSH
58986: LD_VAR 0 2
58990: PPUSH
58991: CALL_OW 1
58995: ST_TO_ADDR
// end ;
58996: LD_VAR 0 3
59000: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59001: LD_INT 0
59003: PPUSH
59004: PPUSH
// if not mc_bases or not base then
59005: LD_EXP 102
59009: NOT
59010: PUSH
59011: LD_VAR 0 1
59015: NOT
59016: OR
59017: IFFALSE 59021
// exit ;
59019: GO 59123
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59021: LD_ADDR_VAR 0 4
59025: PUSH
59026: LD_EXP 102
59030: PUSH
59031: LD_VAR 0 1
59035: ARRAY
59036: PPUSH
59037: LD_INT 30
59039: PUSH
59040: LD_VAR 0 2
59044: PUSH
59045: EMPTY
59046: LIST
59047: LIST
59048: PPUSH
59049: CALL_OW 72
59053: ST_TO_ADDR
// if not tmp then
59054: LD_VAR 0 4
59058: NOT
59059: IFFALSE 59063
// exit ;
59061: GO 59123
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59063: LD_ADDR_EXP 134
59067: PUSH
59068: LD_EXP 134
59072: PPUSH
59073: LD_VAR 0 1
59077: PPUSH
59078: LD_EXP 134
59082: PUSH
59083: LD_VAR 0 1
59087: ARRAY
59088: PPUSH
59089: LD_EXP 134
59093: PUSH
59094: LD_VAR 0 1
59098: ARRAY
59099: PUSH
59100: LD_INT 1
59102: PLUS
59103: PPUSH
59104: LD_VAR 0 4
59108: PUSH
59109: LD_INT 1
59111: ARRAY
59112: PPUSH
59113: CALL_OW 2
59117: PPUSH
59118: CALL_OW 1
59122: ST_TO_ADDR
// end ;
59123: LD_VAR 0 3
59127: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59128: LD_INT 0
59130: PPUSH
59131: PPUSH
// if not mc_bases or not base or not kinds then
59132: LD_EXP 102
59136: NOT
59137: PUSH
59138: LD_VAR 0 1
59142: NOT
59143: OR
59144: PUSH
59145: LD_VAR 0 2
59149: NOT
59150: OR
59151: IFFALSE 59155
// exit ;
59153: GO 59216
// for i in kinds do
59155: LD_ADDR_VAR 0 4
59159: PUSH
59160: LD_VAR 0 2
59164: PUSH
59165: FOR_IN
59166: IFFALSE 59214
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59168: LD_ADDR_EXP 136
59172: PUSH
59173: LD_EXP 136
59177: PPUSH
59178: LD_VAR 0 1
59182: PUSH
59183: LD_EXP 136
59187: PUSH
59188: LD_VAR 0 1
59192: ARRAY
59193: PUSH
59194: LD_INT 1
59196: PLUS
59197: PUSH
59198: EMPTY
59199: LIST
59200: LIST
59201: PPUSH
59202: LD_VAR 0 4
59206: PPUSH
59207: CALL 72015 0 3
59211: ST_TO_ADDR
59212: GO 59165
59214: POP
59215: POP
// end ;
59216: LD_VAR 0 3
59220: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59221: LD_INT 0
59223: PPUSH
// if not mc_bases or not base or not areas then
59224: LD_EXP 102
59228: NOT
59229: PUSH
59230: LD_VAR 0 1
59234: NOT
59235: OR
59236: PUSH
59237: LD_VAR 0 2
59241: NOT
59242: OR
59243: IFFALSE 59247
// exit ;
59245: GO 59272
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59247: LD_ADDR_EXP 120
59251: PUSH
59252: LD_EXP 120
59256: PPUSH
59257: LD_VAR 0 1
59261: PPUSH
59262: LD_VAR 0 2
59266: PPUSH
59267: CALL_OW 1
59271: ST_TO_ADDR
// end ;
59272: LD_VAR 0 3
59276: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59277: LD_INT 0
59279: PPUSH
// if not mc_bases or not base or not teleports_exit then
59280: LD_EXP 102
59284: NOT
59285: PUSH
59286: LD_VAR 0 1
59290: NOT
59291: OR
59292: PUSH
59293: LD_VAR 0 2
59297: NOT
59298: OR
59299: IFFALSE 59303
// exit ;
59301: GO 59328
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59303: LD_ADDR_EXP 137
59307: PUSH
59308: LD_EXP 137
59312: PPUSH
59313: LD_VAR 0 1
59317: PPUSH
59318: LD_VAR 0 2
59322: PPUSH
59323: CALL_OW 1
59327: ST_TO_ADDR
// end ;
59328: LD_VAR 0 3
59332: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59333: LD_INT 0
59335: PPUSH
59336: PPUSH
59337: PPUSH
// if not mc_bases or not base or not ext_list then
59338: LD_EXP 102
59342: NOT
59343: PUSH
59344: LD_VAR 0 1
59348: NOT
59349: OR
59350: PUSH
59351: LD_VAR 0 5
59355: NOT
59356: OR
59357: IFFALSE 59361
// exit ;
59359: GO 59534
// tmp := GetFacExtXYD ( x , y , d ) ;
59361: LD_ADDR_VAR 0 8
59365: PUSH
59366: LD_VAR 0 2
59370: PPUSH
59371: LD_VAR 0 3
59375: PPUSH
59376: LD_VAR 0 4
59380: PPUSH
59381: CALL 105403 0 3
59385: ST_TO_ADDR
// if not tmp then
59386: LD_VAR 0 8
59390: NOT
59391: IFFALSE 59395
// exit ;
59393: GO 59534
// for i in tmp do
59395: LD_ADDR_VAR 0 7
59399: PUSH
59400: LD_VAR 0 8
59404: PUSH
59405: FOR_IN
59406: IFFALSE 59532
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59408: LD_ADDR_EXP 107
59412: PUSH
59413: LD_EXP 107
59417: PPUSH
59418: LD_VAR 0 1
59422: PPUSH
59423: LD_EXP 107
59427: PUSH
59428: LD_VAR 0 1
59432: ARRAY
59433: PPUSH
59434: LD_EXP 107
59438: PUSH
59439: LD_VAR 0 1
59443: ARRAY
59444: PUSH
59445: LD_INT 1
59447: PLUS
59448: PPUSH
59449: LD_VAR 0 5
59453: PUSH
59454: LD_INT 1
59456: ARRAY
59457: PUSH
59458: LD_VAR 0 7
59462: PUSH
59463: LD_INT 1
59465: ARRAY
59466: PUSH
59467: LD_VAR 0 7
59471: PUSH
59472: LD_INT 2
59474: ARRAY
59475: PUSH
59476: LD_VAR 0 7
59480: PUSH
59481: LD_INT 3
59483: ARRAY
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: LIST
59489: LIST
59490: PPUSH
59491: CALL_OW 2
59495: PPUSH
59496: CALL_OW 1
59500: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59501: LD_ADDR_VAR 0 5
59505: PUSH
59506: LD_VAR 0 5
59510: PPUSH
59511: LD_INT 1
59513: PPUSH
59514: CALL_OW 3
59518: ST_TO_ADDR
// if not ext_list then
59519: LD_VAR 0 5
59523: NOT
59524: IFFALSE 59530
// exit ;
59526: POP
59527: POP
59528: GO 59534
// end ;
59530: GO 59405
59532: POP
59533: POP
// end ;
59534: LD_VAR 0 6
59538: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59539: LD_INT 0
59541: PPUSH
// if not mc_bases or not base or not weapon_list then
59542: LD_EXP 102
59546: NOT
59547: PUSH
59548: LD_VAR 0 1
59552: NOT
59553: OR
59554: PUSH
59555: LD_VAR 0 2
59559: NOT
59560: OR
59561: IFFALSE 59565
// exit ;
59563: GO 59590
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59565: LD_ADDR_EXP 141
59569: PUSH
59570: LD_EXP 141
59574: PPUSH
59575: LD_VAR 0 1
59579: PPUSH
59580: LD_VAR 0 2
59584: PPUSH
59585: CALL_OW 1
59589: ST_TO_ADDR
// end ;
59590: LD_VAR 0 3
59594: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59595: LD_INT 0
59597: PPUSH
// if not mc_bases or not base or not tech_list then
59598: LD_EXP 102
59602: NOT
59603: PUSH
59604: LD_VAR 0 1
59608: NOT
59609: OR
59610: PUSH
59611: LD_VAR 0 2
59615: NOT
59616: OR
59617: IFFALSE 59621
// exit ;
59619: GO 59646
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59621: LD_ADDR_EXP 129
59625: PUSH
59626: LD_EXP 129
59630: PPUSH
59631: LD_VAR 0 1
59635: PPUSH
59636: LD_VAR 0 2
59640: PPUSH
59641: CALL_OW 1
59645: ST_TO_ADDR
// end ;
59646: LD_VAR 0 3
59650: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59651: LD_INT 0
59653: PPUSH
// if not mc_bases or not parking_area or not base then
59654: LD_EXP 102
59658: NOT
59659: PUSH
59660: LD_VAR 0 2
59664: NOT
59665: OR
59666: PUSH
59667: LD_VAR 0 1
59671: NOT
59672: OR
59673: IFFALSE 59677
// exit ;
59675: GO 59702
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59677: LD_ADDR_EXP 126
59681: PUSH
59682: LD_EXP 126
59686: PPUSH
59687: LD_VAR 0 1
59691: PPUSH
59692: LD_VAR 0 2
59696: PPUSH
59697: CALL_OW 1
59701: ST_TO_ADDR
// end ;
59702: LD_VAR 0 3
59706: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59707: LD_INT 0
59709: PPUSH
// if not mc_bases or not base or not scan_area then
59710: LD_EXP 102
59714: NOT
59715: PUSH
59716: LD_VAR 0 1
59720: NOT
59721: OR
59722: PUSH
59723: LD_VAR 0 2
59727: NOT
59728: OR
59729: IFFALSE 59733
// exit ;
59731: GO 59758
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59733: LD_ADDR_EXP 127
59737: PUSH
59738: LD_EXP 127
59742: PPUSH
59743: LD_VAR 0 1
59747: PPUSH
59748: LD_VAR 0 2
59752: PPUSH
59753: CALL_OW 1
59757: ST_TO_ADDR
// end ;
59758: LD_VAR 0 3
59762: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59763: LD_INT 0
59765: PPUSH
59766: PPUSH
// if not mc_bases or not base then
59767: LD_EXP 102
59771: NOT
59772: PUSH
59773: LD_VAR 0 1
59777: NOT
59778: OR
59779: IFFALSE 59783
// exit ;
59781: GO 59847
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59783: LD_ADDR_VAR 0 3
59787: PUSH
59788: LD_INT 1
59790: PUSH
59791: LD_INT 2
59793: PUSH
59794: LD_INT 3
59796: PUSH
59797: LD_INT 4
59799: PUSH
59800: LD_INT 11
59802: PUSH
59803: EMPTY
59804: LIST
59805: LIST
59806: LIST
59807: LIST
59808: LIST
59809: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59810: LD_ADDR_EXP 129
59814: PUSH
59815: LD_EXP 129
59819: PPUSH
59820: LD_VAR 0 1
59824: PPUSH
59825: LD_EXP 129
59829: PUSH
59830: LD_VAR 0 1
59834: ARRAY
59835: PUSH
59836: LD_VAR 0 3
59840: DIFF
59841: PPUSH
59842: CALL_OW 1
59846: ST_TO_ADDR
// end ;
59847: LD_VAR 0 2
59851: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59852: LD_INT 0
59854: PPUSH
// result := mc_vehicles [ base ] ;
59855: LD_ADDR_VAR 0 3
59859: PUSH
59860: LD_EXP 121
59864: PUSH
59865: LD_VAR 0 1
59869: ARRAY
59870: ST_TO_ADDR
// if onlyCombat then
59871: LD_VAR 0 2
59875: IFFALSE 60040
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59877: LD_ADDR_VAR 0 3
59881: PUSH
59882: LD_VAR 0 3
59886: PUSH
59887: LD_VAR 0 3
59891: PPUSH
59892: LD_INT 2
59894: PUSH
59895: LD_INT 34
59897: PUSH
59898: LD_INT 12
59900: PUSH
59901: EMPTY
59902: LIST
59903: LIST
59904: PUSH
59905: LD_INT 34
59907: PUSH
59908: LD_INT 51
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: PUSH
59915: LD_INT 34
59917: PUSH
59918: LD_EXP 96
59922: PUSH
59923: EMPTY
59924: LIST
59925: LIST
59926: PUSH
59927: LD_INT 34
59929: PUSH
59930: LD_INT 32
59932: PUSH
59933: EMPTY
59934: LIST
59935: LIST
59936: PUSH
59937: LD_INT 34
59939: PUSH
59940: LD_INT 13
59942: PUSH
59943: EMPTY
59944: LIST
59945: LIST
59946: PUSH
59947: LD_INT 34
59949: PUSH
59950: LD_INT 52
59952: PUSH
59953: EMPTY
59954: LIST
59955: LIST
59956: PUSH
59957: LD_INT 34
59959: PUSH
59960: LD_INT 14
59962: PUSH
59963: EMPTY
59964: LIST
59965: LIST
59966: PUSH
59967: LD_INT 34
59969: PUSH
59970: LD_INT 53
59972: PUSH
59973: EMPTY
59974: LIST
59975: LIST
59976: PUSH
59977: LD_INT 34
59979: PUSH
59980: LD_EXP 95
59984: PUSH
59985: EMPTY
59986: LIST
59987: LIST
59988: PUSH
59989: LD_INT 34
59991: PUSH
59992: LD_INT 31
59994: PUSH
59995: EMPTY
59996: LIST
59997: LIST
59998: PUSH
59999: LD_INT 34
60001: PUSH
60002: LD_INT 48
60004: PUSH
60005: EMPTY
60006: LIST
60007: LIST
60008: PUSH
60009: LD_INT 34
60011: PUSH
60012: LD_INT 8
60014: PUSH
60015: EMPTY
60016: LIST
60017: LIST
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: LIST
60023: LIST
60024: LIST
60025: LIST
60026: LIST
60027: LIST
60028: LIST
60029: LIST
60030: LIST
60031: LIST
60032: LIST
60033: PPUSH
60034: CALL_OW 72
60038: DIFF
60039: ST_TO_ADDR
// end ; end_of_file
60040: LD_VAR 0 3
60044: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60045: LD_INT 0
60047: PPUSH
60048: PPUSH
60049: PPUSH
// if not mc_bases or not skirmish then
60050: LD_EXP 102
60054: NOT
60055: PUSH
60056: LD_EXP 100
60060: NOT
60061: OR
60062: IFFALSE 60066
// exit ;
60064: GO 60231
// for i = 1 to mc_bases do
60066: LD_ADDR_VAR 0 4
60070: PUSH
60071: DOUBLE
60072: LD_INT 1
60074: DEC
60075: ST_TO_ADDR
60076: LD_EXP 102
60080: PUSH
60081: FOR_TO
60082: IFFALSE 60229
// begin if sci in mc_bases [ i ] then
60084: LD_VAR 0 2
60088: PUSH
60089: LD_EXP 102
60093: PUSH
60094: LD_VAR 0 4
60098: ARRAY
60099: IN
60100: IFFALSE 60227
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60102: LD_ADDR_EXP 131
60106: PUSH
60107: LD_EXP 131
60111: PPUSH
60112: LD_VAR 0 4
60116: PUSH
60117: LD_EXP 131
60121: PUSH
60122: LD_VAR 0 4
60126: ARRAY
60127: PUSH
60128: LD_INT 1
60130: PLUS
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PPUSH
60136: LD_VAR 0 1
60140: PPUSH
60141: CALL 72015 0 3
60145: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60146: LD_ADDR_VAR 0 5
60150: PUSH
60151: LD_EXP 102
60155: PUSH
60156: LD_VAR 0 4
60160: ARRAY
60161: PPUSH
60162: LD_INT 2
60164: PUSH
60165: LD_INT 30
60167: PUSH
60168: LD_INT 0
60170: PUSH
60171: EMPTY
60172: LIST
60173: LIST
60174: PUSH
60175: LD_INT 30
60177: PUSH
60178: LD_INT 1
60180: PUSH
60181: EMPTY
60182: LIST
60183: LIST
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: LIST
60189: PPUSH
60190: CALL_OW 72
60194: PPUSH
60195: LD_VAR 0 1
60199: PPUSH
60200: CALL_OW 74
60204: ST_TO_ADDR
// if tmp then
60205: LD_VAR 0 5
60209: IFFALSE 60225
// ComStandNearbyBuilding ( ape , tmp ) ;
60211: LD_VAR 0 1
60215: PPUSH
60216: LD_VAR 0 5
60220: PPUSH
60221: CALL 66218 0 2
// break ;
60225: GO 60229
// end ; end ;
60227: GO 60081
60229: POP
60230: POP
// end ;
60231: LD_VAR 0 3
60235: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60236: LD_INT 0
60238: PPUSH
60239: PPUSH
60240: PPUSH
// if not mc_bases or not skirmish then
60241: LD_EXP 102
60245: NOT
60246: PUSH
60247: LD_EXP 100
60251: NOT
60252: OR
60253: IFFALSE 60257
// exit ;
60255: GO 60346
// for i = 1 to mc_bases do
60257: LD_ADDR_VAR 0 4
60261: PUSH
60262: DOUBLE
60263: LD_INT 1
60265: DEC
60266: ST_TO_ADDR
60267: LD_EXP 102
60271: PUSH
60272: FOR_TO
60273: IFFALSE 60344
// begin if building in mc_busy_turret_list [ i ] then
60275: LD_VAR 0 1
60279: PUSH
60280: LD_EXP 112
60284: PUSH
60285: LD_VAR 0 4
60289: ARRAY
60290: IN
60291: IFFALSE 60342
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60293: LD_ADDR_VAR 0 5
60297: PUSH
60298: LD_EXP 112
60302: PUSH
60303: LD_VAR 0 4
60307: ARRAY
60308: PUSH
60309: LD_VAR 0 1
60313: DIFF
60314: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60315: LD_ADDR_EXP 112
60319: PUSH
60320: LD_EXP 112
60324: PPUSH
60325: LD_VAR 0 4
60329: PPUSH
60330: LD_VAR 0 5
60334: PPUSH
60335: CALL_OW 1
60339: ST_TO_ADDR
// break ;
60340: GO 60344
// end ; end ;
60342: GO 60272
60344: POP
60345: POP
// end ;
60346: LD_VAR 0 3
60350: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60351: LD_INT 0
60353: PPUSH
60354: PPUSH
60355: PPUSH
// if not mc_bases or not skirmish then
60356: LD_EXP 102
60360: NOT
60361: PUSH
60362: LD_EXP 100
60366: NOT
60367: OR
60368: IFFALSE 60372
// exit ;
60370: GO 60571
// for i = 1 to mc_bases do
60372: LD_ADDR_VAR 0 5
60376: PUSH
60377: DOUBLE
60378: LD_INT 1
60380: DEC
60381: ST_TO_ADDR
60382: LD_EXP 102
60386: PUSH
60387: FOR_TO
60388: IFFALSE 60569
// if building in mc_bases [ i ] then
60390: LD_VAR 0 1
60394: PUSH
60395: LD_EXP 102
60399: PUSH
60400: LD_VAR 0 5
60404: ARRAY
60405: IN
60406: IFFALSE 60567
// begin tmp := mc_bases [ i ] diff building ;
60408: LD_ADDR_VAR 0 6
60412: PUSH
60413: LD_EXP 102
60417: PUSH
60418: LD_VAR 0 5
60422: ARRAY
60423: PUSH
60424: LD_VAR 0 1
60428: DIFF
60429: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60430: LD_ADDR_EXP 102
60434: PUSH
60435: LD_EXP 102
60439: PPUSH
60440: LD_VAR 0 5
60444: PPUSH
60445: LD_VAR 0 6
60449: PPUSH
60450: CALL_OW 1
60454: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60455: LD_VAR 0 1
60459: PUSH
60460: LD_EXP 110
60464: PUSH
60465: LD_VAR 0 5
60469: ARRAY
60470: IN
60471: IFFALSE 60510
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60473: LD_ADDR_EXP 110
60477: PUSH
60478: LD_EXP 110
60482: PPUSH
60483: LD_VAR 0 5
60487: PPUSH
60488: LD_EXP 110
60492: PUSH
60493: LD_VAR 0 5
60497: ARRAY
60498: PUSH
60499: LD_VAR 0 1
60503: DIFF
60504: PPUSH
60505: CALL_OW 1
60509: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60510: LD_VAR 0 1
60514: PUSH
60515: LD_EXP 111
60519: PUSH
60520: LD_VAR 0 5
60524: ARRAY
60525: IN
60526: IFFALSE 60565
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60528: LD_ADDR_EXP 111
60532: PUSH
60533: LD_EXP 111
60537: PPUSH
60538: LD_VAR 0 5
60542: PPUSH
60543: LD_EXP 111
60547: PUSH
60548: LD_VAR 0 5
60552: ARRAY
60553: PUSH
60554: LD_VAR 0 1
60558: DIFF
60559: PPUSH
60560: CALL_OW 1
60564: ST_TO_ADDR
// break ;
60565: GO 60569
// end ;
60567: GO 60387
60569: POP
60570: POP
// end ;
60571: LD_VAR 0 4
60575: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60576: LD_INT 0
60578: PPUSH
60579: PPUSH
60580: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60581: LD_EXP 102
60585: NOT
60586: PUSH
60587: LD_EXP 100
60591: NOT
60592: OR
60593: PUSH
60594: LD_VAR 0 3
60598: PUSH
60599: LD_EXP 128
60603: IN
60604: NOT
60605: OR
60606: IFFALSE 60610
// exit ;
60608: GO 60733
// for i = 1 to mc_vehicles do
60610: LD_ADDR_VAR 0 6
60614: PUSH
60615: DOUBLE
60616: LD_INT 1
60618: DEC
60619: ST_TO_ADDR
60620: LD_EXP 121
60624: PUSH
60625: FOR_TO
60626: IFFALSE 60731
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60628: LD_VAR 0 2
60632: PUSH
60633: LD_EXP 121
60637: PUSH
60638: LD_VAR 0 6
60642: ARRAY
60643: IN
60644: PUSH
60645: LD_VAR 0 1
60649: PUSH
60650: LD_EXP 121
60654: PUSH
60655: LD_VAR 0 6
60659: ARRAY
60660: IN
60661: OR
60662: IFFALSE 60729
// begin tmp := mc_vehicles [ i ] diff old ;
60664: LD_ADDR_VAR 0 7
60668: PUSH
60669: LD_EXP 121
60673: PUSH
60674: LD_VAR 0 6
60678: ARRAY
60679: PUSH
60680: LD_VAR 0 2
60684: DIFF
60685: ST_TO_ADDR
// tmp := tmp diff new ;
60686: LD_ADDR_VAR 0 7
60690: PUSH
60691: LD_VAR 0 7
60695: PUSH
60696: LD_VAR 0 1
60700: DIFF
60701: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60702: LD_ADDR_EXP 121
60706: PUSH
60707: LD_EXP 121
60711: PPUSH
60712: LD_VAR 0 6
60716: PPUSH
60717: LD_VAR 0 7
60721: PPUSH
60722: CALL_OW 1
60726: ST_TO_ADDR
// break ;
60727: GO 60731
// end ;
60729: GO 60625
60731: POP
60732: POP
// end ;
60733: LD_VAR 0 5
60737: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60738: LD_INT 0
60740: PPUSH
60741: PPUSH
60742: PPUSH
60743: PPUSH
// if not mc_bases or not skirmish then
60744: LD_EXP 102
60748: NOT
60749: PUSH
60750: LD_EXP 100
60754: NOT
60755: OR
60756: IFFALSE 60760
// exit ;
60758: GO 61137
// side := GetSide ( vehicle ) ;
60760: LD_ADDR_VAR 0 5
60764: PUSH
60765: LD_VAR 0 1
60769: PPUSH
60770: CALL_OW 255
60774: ST_TO_ADDR
// for i = 1 to mc_bases do
60775: LD_ADDR_VAR 0 4
60779: PUSH
60780: DOUBLE
60781: LD_INT 1
60783: DEC
60784: ST_TO_ADDR
60785: LD_EXP 102
60789: PUSH
60790: FOR_TO
60791: IFFALSE 61135
// begin if factory in mc_bases [ i ] then
60793: LD_VAR 0 2
60797: PUSH
60798: LD_EXP 102
60802: PUSH
60803: LD_VAR 0 4
60807: ARRAY
60808: IN
60809: IFFALSE 61133
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60811: LD_EXP 124
60815: PUSH
60816: LD_VAR 0 4
60820: ARRAY
60821: PUSH
60822: LD_EXP 113
60826: PUSH
60827: LD_VAR 0 4
60831: ARRAY
60832: LESS
60833: PUSH
60834: LD_VAR 0 1
60838: PPUSH
60839: CALL_OW 264
60843: PUSH
60844: LD_INT 31
60846: PUSH
60847: LD_INT 32
60849: PUSH
60850: LD_INT 51
60852: PUSH
60853: LD_EXP 96
60857: PUSH
60858: LD_INT 12
60860: PUSH
60861: LD_INT 30
60863: PUSH
60864: LD_EXP 95
60868: PUSH
60869: LD_INT 11
60871: PUSH
60872: LD_INT 53
60874: PUSH
60875: LD_INT 14
60877: PUSH
60878: LD_EXP 99
60882: PUSH
60883: LD_INT 29
60885: PUSH
60886: LD_EXP 97
60890: PUSH
60891: LD_INT 13
60893: PUSH
60894: LD_INT 52
60896: PUSH
60897: LD_INT 48
60899: PUSH
60900: LD_INT 8
60902: PUSH
60903: EMPTY
60904: LIST
60905: LIST
60906: LIST
60907: LIST
60908: LIST
60909: LIST
60910: LIST
60911: LIST
60912: LIST
60913: LIST
60914: LIST
60915: LIST
60916: LIST
60917: LIST
60918: LIST
60919: LIST
60920: LIST
60921: IN
60922: NOT
60923: AND
60924: IFFALSE 60972
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60926: LD_ADDR_EXP 124
60930: PUSH
60931: LD_EXP 124
60935: PPUSH
60936: LD_VAR 0 4
60940: PUSH
60941: LD_EXP 124
60945: PUSH
60946: LD_VAR 0 4
60950: ARRAY
60951: PUSH
60952: LD_INT 1
60954: PLUS
60955: PUSH
60956: EMPTY
60957: LIST
60958: LIST
60959: PPUSH
60960: LD_VAR 0 1
60964: PPUSH
60965: CALL 72015 0 3
60969: ST_TO_ADDR
60970: GO 61016
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60972: LD_ADDR_EXP 121
60976: PUSH
60977: LD_EXP 121
60981: PPUSH
60982: LD_VAR 0 4
60986: PUSH
60987: LD_EXP 121
60991: PUSH
60992: LD_VAR 0 4
60996: ARRAY
60997: PUSH
60998: LD_INT 1
61000: PLUS
61001: PUSH
61002: EMPTY
61003: LIST
61004: LIST
61005: PPUSH
61006: LD_VAR 0 1
61010: PPUSH
61011: CALL 72015 0 3
61015: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61016: LD_VAR 0 1
61020: PPUSH
61021: CALL_OW 263
61025: PUSH
61026: LD_INT 2
61028: EQUAL
61029: IFFALSE 61049
// begin repeat wait ( 0 0$1 ) ;
61031: LD_INT 35
61033: PPUSH
61034: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61038: LD_VAR 0 1
61042: PPUSH
61043: CALL_OW 312
61047: IFFALSE 61031
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61049: LD_VAR 0 1
61053: PPUSH
61054: LD_EXP 126
61058: PUSH
61059: LD_VAR 0 4
61063: ARRAY
61064: PPUSH
61065: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61069: LD_VAR 0 1
61073: PPUSH
61074: CALL_OW 263
61078: PUSH
61079: LD_INT 1
61081: NONEQUAL
61082: IFFALSE 61086
// break ;
61084: GO 61135
// repeat wait ( 0 0$1 ) ;
61086: LD_INT 35
61088: PPUSH
61089: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61093: LD_VAR 0 1
61097: PPUSH
61098: LD_EXP 126
61102: PUSH
61103: LD_VAR 0 4
61107: ARRAY
61108: PPUSH
61109: CALL_OW 308
61113: IFFALSE 61086
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61115: LD_VAR 0 1
61119: PPUSH
61120: CALL_OW 311
61124: PPUSH
61125: CALL_OW 121
// exit ;
61129: POP
61130: POP
61131: GO 61137
// end ; end ;
61133: GO 60790
61135: POP
61136: POP
// end ;
61137: LD_VAR 0 3
61141: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61142: LD_INT 0
61144: PPUSH
61145: PPUSH
61146: PPUSH
61147: PPUSH
// if not mc_bases or not skirmish then
61148: LD_EXP 102
61152: NOT
61153: PUSH
61154: LD_EXP 100
61158: NOT
61159: OR
61160: IFFALSE 61164
// exit ;
61162: GO 61517
// repeat wait ( 0 0$1 ) ;
61164: LD_INT 35
61166: PPUSH
61167: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61171: LD_VAR 0 2
61175: PPUSH
61176: LD_VAR 0 3
61180: PPUSH
61181: CALL_OW 284
61185: IFFALSE 61164
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61187: LD_VAR 0 2
61191: PPUSH
61192: LD_VAR 0 3
61196: PPUSH
61197: CALL_OW 283
61201: PUSH
61202: LD_INT 4
61204: EQUAL
61205: IFFALSE 61209
// exit ;
61207: GO 61517
// for i = 1 to mc_bases do
61209: LD_ADDR_VAR 0 7
61213: PUSH
61214: DOUBLE
61215: LD_INT 1
61217: DEC
61218: ST_TO_ADDR
61219: LD_EXP 102
61223: PUSH
61224: FOR_TO
61225: IFFALSE 61515
// begin if mc_crates_area [ i ] then
61227: LD_EXP 120
61231: PUSH
61232: LD_VAR 0 7
61236: ARRAY
61237: IFFALSE 61348
// for j in mc_crates_area [ i ] do
61239: LD_ADDR_VAR 0 8
61243: PUSH
61244: LD_EXP 120
61248: PUSH
61249: LD_VAR 0 7
61253: ARRAY
61254: PUSH
61255: FOR_IN
61256: IFFALSE 61346
// if InArea ( x , y , j ) then
61258: LD_VAR 0 2
61262: PPUSH
61263: LD_VAR 0 3
61267: PPUSH
61268: LD_VAR 0 8
61272: PPUSH
61273: CALL_OW 309
61277: IFFALSE 61344
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61279: LD_ADDR_EXP 118
61283: PUSH
61284: LD_EXP 118
61288: PPUSH
61289: LD_VAR 0 7
61293: PUSH
61294: LD_EXP 118
61298: PUSH
61299: LD_VAR 0 7
61303: ARRAY
61304: PUSH
61305: LD_INT 1
61307: PLUS
61308: PUSH
61309: EMPTY
61310: LIST
61311: LIST
61312: PPUSH
61313: LD_VAR 0 4
61317: PUSH
61318: LD_VAR 0 2
61322: PUSH
61323: LD_VAR 0 3
61327: PUSH
61328: EMPTY
61329: LIST
61330: LIST
61331: LIST
61332: PPUSH
61333: CALL 72015 0 3
61337: ST_TO_ADDR
// exit ;
61338: POP
61339: POP
61340: POP
61341: POP
61342: GO 61517
// end ;
61344: GO 61255
61346: POP
61347: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61348: LD_ADDR_VAR 0 9
61352: PUSH
61353: LD_EXP 102
61357: PUSH
61358: LD_VAR 0 7
61362: ARRAY
61363: PPUSH
61364: LD_INT 2
61366: PUSH
61367: LD_INT 30
61369: PUSH
61370: LD_INT 0
61372: PUSH
61373: EMPTY
61374: LIST
61375: LIST
61376: PUSH
61377: LD_INT 30
61379: PUSH
61380: LD_INT 1
61382: PUSH
61383: EMPTY
61384: LIST
61385: LIST
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: LIST
61391: PPUSH
61392: CALL_OW 72
61396: ST_TO_ADDR
// if not depot then
61397: LD_VAR 0 9
61401: NOT
61402: IFFALSE 61406
// continue ;
61404: GO 61224
// for j in depot do
61406: LD_ADDR_VAR 0 8
61410: PUSH
61411: LD_VAR 0 9
61415: PUSH
61416: FOR_IN
61417: IFFALSE 61511
// if GetDistUnitXY ( j , x , y ) < 30 then
61419: LD_VAR 0 8
61423: PPUSH
61424: LD_VAR 0 2
61428: PPUSH
61429: LD_VAR 0 3
61433: PPUSH
61434: CALL_OW 297
61438: PUSH
61439: LD_INT 30
61441: LESS
61442: IFFALSE 61509
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61444: LD_ADDR_EXP 118
61448: PUSH
61449: LD_EXP 118
61453: PPUSH
61454: LD_VAR 0 7
61458: PUSH
61459: LD_EXP 118
61463: PUSH
61464: LD_VAR 0 7
61468: ARRAY
61469: PUSH
61470: LD_INT 1
61472: PLUS
61473: PUSH
61474: EMPTY
61475: LIST
61476: LIST
61477: PPUSH
61478: LD_VAR 0 4
61482: PUSH
61483: LD_VAR 0 2
61487: PUSH
61488: LD_VAR 0 3
61492: PUSH
61493: EMPTY
61494: LIST
61495: LIST
61496: LIST
61497: PPUSH
61498: CALL 72015 0 3
61502: ST_TO_ADDR
// exit ;
61503: POP
61504: POP
61505: POP
61506: POP
61507: GO 61517
// end ;
61509: GO 61416
61511: POP
61512: POP
// end ;
61513: GO 61224
61515: POP
61516: POP
// end ;
61517: LD_VAR 0 6
61521: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61522: LD_INT 0
61524: PPUSH
61525: PPUSH
61526: PPUSH
61527: PPUSH
// if not mc_bases or not skirmish then
61528: LD_EXP 102
61532: NOT
61533: PUSH
61534: LD_EXP 100
61538: NOT
61539: OR
61540: IFFALSE 61544
// exit ;
61542: GO 61821
// side := GetSide ( lab ) ;
61544: LD_ADDR_VAR 0 4
61548: PUSH
61549: LD_VAR 0 2
61553: PPUSH
61554: CALL_OW 255
61558: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61559: LD_VAR 0 4
61563: PUSH
61564: LD_EXP 128
61568: IN
61569: NOT
61570: PUSH
61571: LD_EXP 129
61575: NOT
61576: OR
61577: PUSH
61578: LD_EXP 102
61582: NOT
61583: OR
61584: IFFALSE 61588
// exit ;
61586: GO 61821
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61588: LD_ADDR_EXP 129
61592: PUSH
61593: LD_EXP 129
61597: PPUSH
61598: LD_VAR 0 4
61602: PPUSH
61603: LD_EXP 129
61607: PUSH
61608: LD_VAR 0 4
61612: ARRAY
61613: PUSH
61614: LD_VAR 0 1
61618: DIFF
61619: PPUSH
61620: CALL_OW 1
61624: ST_TO_ADDR
// for i = 1 to mc_bases do
61625: LD_ADDR_VAR 0 5
61629: PUSH
61630: DOUBLE
61631: LD_INT 1
61633: DEC
61634: ST_TO_ADDR
61635: LD_EXP 102
61639: PUSH
61640: FOR_TO
61641: IFFALSE 61819
// begin if lab in mc_bases [ i ] then
61643: LD_VAR 0 2
61647: PUSH
61648: LD_EXP 102
61652: PUSH
61653: LD_VAR 0 5
61657: ARRAY
61658: IN
61659: IFFALSE 61817
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61661: LD_VAR 0 1
61665: PUSH
61666: LD_INT 11
61668: PUSH
61669: LD_INT 4
61671: PUSH
61672: LD_INT 3
61674: PUSH
61675: LD_INT 2
61677: PUSH
61678: EMPTY
61679: LIST
61680: LIST
61681: LIST
61682: LIST
61683: IN
61684: PUSH
61685: LD_EXP 132
61689: PUSH
61690: LD_VAR 0 5
61694: ARRAY
61695: AND
61696: IFFALSE 61817
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61698: LD_ADDR_VAR 0 6
61702: PUSH
61703: LD_EXP 132
61707: PUSH
61708: LD_VAR 0 5
61712: ARRAY
61713: PUSH
61714: LD_INT 1
61716: ARRAY
61717: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61718: LD_ADDR_EXP 132
61722: PUSH
61723: LD_EXP 132
61727: PPUSH
61728: LD_VAR 0 5
61732: PPUSH
61733: EMPTY
61734: PPUSH
61735: CALL_OW 1
61739: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61740: LD_VAR 0 6
61744: PPUSH
61745: LD_INT 0
61747: PPUSH
61748: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61752: LD_VAR 0 6
61756: PPUSH
61757: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61761: LD_ADDR_EXP 131
61765: PUSH
61766: LD_EXP 131
61770: PPUSH
61771: LD_VAR 0 5
61775: PPUSH
61776: LD_EXP 131
61780: PUSH
61781: LD_VAR 0 5
61785: ARRAY
61786: PPUSH
61787: LD_INT 1
61789: PPUSH
61790: LD_VAR 0 6
61794: PPUSH
61795: CALL_OW 2
61799: PPUSH
61800: CALL_OW 1
61804: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61805: LD_VAR 0 5
61809: PPUSH
61810: LD_INT 112
61812: PPUSH
61813: CALL 38817 0 2
// end ; end ; end ;
61817: GO 61640
61819: POP
61820: POP
// end ;
61821: LD_VAR 0 3
61825: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61826: LD_INT 0
61828: PPUSH
61829: PPUSH
61830: PPUSH
61831: PPUSH
61832: PPUSH
61833: PPUSH
61834: PPUSH
61835: PPUSH
// if not mc_bases or not skirmish then
61836: LD_EXP 102
61840: NOT
61841: PUSH
61842: LD_EXP 100
61846: NOT
61847: OR
61848: IFFALSE 61852
// exit ;
61850: GO 63223
// for i = 1 to mc_bases do
61852: LD_ADDR_VAR 0 3
61856: PUSH
61857: DOUBLE
61858: LD_INT 1
61860: DEC
61861: ST_TO_ADDR
61862: LD_EXP 102
61866: PUSH
61867: FOR_TO
61868: IFFALSE 63221
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61870: LD_VAR 0 1
61874: PUSH
61875: LD_EXP 102
61879: PUSH
61880: LD_VAR 0 3
61884: ARRAY
61885: IN
61886: PUSH
61887: LD_VAR 0 1
61891: PUSH
61892: LD_EXP 109
61896: PUSH
61897: LD_VAR 0 3
61901: ARRAY
61902: IN
61903: OR
61904: PUSH
61905: LD_VAR 0 1
61909: PUSH
61910: LD_EXP 124
61914: PUSH
61915: LD_VAR 0 3
61919: ARRAY
61920: IN
61921: OR
61922: PUSH
61923: LD_VAR 0 1
61927: PUSH
61928: LD_EXP 121
61932: PUSH
61933: LD_VAR 0 3
61937: ARRAY
61938: IN
61939: OR
61940: PUSH
61941: LD_VAR 0 1
61945: PUSH
61946: LD_EXP 131
61950: PUSH
61951: LD_VAR 0 3
61955: ARRAY
61956: IN
61957: OR
61958: PUSH
61959: LD_VAR 0 1
61963: PUSH
61964: LD_EXP 132
61968: PUSH
61969: LD_VAR 0 3
61973: ARRAY
61974: IN
61975: OR
61976: IFFALSE 63219
// begin if un in mc_ape [ i ] then
61978: LD_VAR 0 1
61982: PUSH
61983: LD_EXP 131
61987: PUSH
61988: LD_VAR 0 3
61992: ARRAY
61993: IN
61994: IFFALSE 62033
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61996: LD_ADDR_EXP 131
62000: PUSH
62001: LD_EXP 131
62005: PPUSH
62006: LD_VAR 0 3
62010: PPUSH
62011: LD_EXP 131
62015: PUSH
62016: LD_VAR 0 3
62020: ARRAY
62021: PUSH
62022: LD_VAR 0 1
62026: DIFF
62027: PPUSH
62028: CALL_OW 1
62032: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62033: LD_VAR 0 1
62037: PUSH
62038: LD_EXP 132
62042: PUSH
62043: LD_VAR 0 3
62047: ARRAY
62048: IN
62049: IFFALSE 62073
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62051: LD_ADDR_EXP 132
62055: PUSH
62056: LD_EXP 132
62060: PPUSH
62061: LD_VAR 0 3
62065: PPUSH
62066: EMPTY
62067: PPUSH
62068: CALL_OW 1
62072: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62073: LD_VAR 0 1
62077: PPUSH
62078: CALL_OW 247
62082: PUSH
62083: LD_INT 2
62085: EQUAL
62086: PUSH
62087: LD_VAR 0 1
62091: PPUSH
62092: CALL_OW 110
62096: PUSH
62097: LD_INT 20
62099: EQUAL
62100: PUSH
62101: LD_VAR 0 1
62105: PUSH
62106: LD_EXP 124
62110: PUSH
62111: LD_VAR 0 3
62115: ARRAY
62116: IN
62117: OR
62118: PUSH
62119: LD_VAR 0 1
62123: PPUSH
62124: CALL_OW 264
62128: PUSH
62129: LD_INT 12
62131: PUSH
62132: LD_INT 51
62134: PUSH
62135: LD_EXP 96
62139: PUSH
62140: LD_INT 32
62142: PUSH
62143: LD_INT 13
62145: PUSH
62146: LD_INT 52
62148: PUSH
62149: LD_INT 31
62151: PUSH
62152: EMPTY
62153: LIST
62154: LIST
62155: LIST
62156: LIST
62157: LIST
62158: LIST
62159: LIST
62160: IN
62161: OR
62162: AND
62163: IFFALSE 62471
// begin if un in mc_defender [ i ] then
62165: LD_VAR 0 1
62169: PUSH
62170: LD_EXP 124
62174: PUSH
62175: LD_VAR 0 3
62179: ARRAY
62180: IN
62181: IFFALSE 62220
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62183: LD_ADDR_EXP 124
62187: PUSH
62188: LD_EXP 124
62192: PPUSH
62193: LD_VAR 0 3
62197: PPUSH
62198: LD_EXP 124
62202: PUSH
62203: LD_VAR 0 3
62207: ARRAY
62208: PUSH
62209: LD_VAR 0 1
62213: DIFF
62214: PPUSH
62215: CALL_OW 1
62219: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62220: LD_ADDR_VAR 0 8
62224: PUSH
62225: LD_VAR 0 3
62229: PPUSH
62230: LD_INT 3
62232: PPUSH
62233: CALL 58889 0 2
62237: ST_TO_ADDR
// if fac then
62238: LD_VAR 0 8
62242: IFFALSE 62471
// begin for j in fac do
62244: LD_ADDR_VAR 0 4
62248: PUSH
62249: LD_VAR 0 8
62253: PUSH
62254: FOR_IN
62255: IFFALSE 62469
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62257: LD_ADDR_VAR 0 9
62261: PUSH
62262: LD_VAR 0 8
62266: PPUSH
62267: LD_VAR 0 1
62271: PPUSH
62272: CALL_OW 265
62276: PPUSH
62277: LD_VAR 0 1
62281: PPUSH
62282: CALL_OW 262
62286: PPUSH
62287: LD_VAR 0 1
62291: PPUSH
62292: CALL_OW 263
62296: PPUSH
62297: LD_VAR 0 1
62301: PPUSH
62302: CALL_OW 264
62306: PPUSH
62307: CALL 69547 0 5
62311: ST_TO_ADDR
// if components then
62312: LD_VAR 0 9
62316: IFFALSE 62467
// begin if GetWeapon ( un ) = ar_control_tower then
62318: LD_VAR 0 1
62322: PPUSH
62323: CALL_OW 264
62327: PUSH
62328: LD_INT 31
62330: EQUAL
62331: IFFALSE 62448
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62333: LD_VAR 0 1
62337: PPUSH
62338: CALL_OW 311
62342: PPUSH
62343: LD_INT 0
62345: PPUSH
62346: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62350: LD_ADDR_EXP 142
62354: PUSH
62355: LD_EXP 142
62359: PPUSH
62360: LD_VAR 0 3
62364: PPUSH
62365: LD_EXP 142
62369: PUSH
62370: LD_VAR 0 3
62374: ARRAY
62375: PUSH
62376: LD_VAR 0 1
62380: PPUSH
62381: CALL_OW 311
62385: DIFF
62386: PPUSH
62387: CALL_OW 1
62391: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62392: LD_ADDR_VAR 0 7
62396: PUSH
62397: LD_EXP 123
62401: PUSH
62402: LD_VAR 0 3
62406: ARRAY
62407: PPUSH
62408: LD_INT 1
62410: PPUSH
62411: LD_VAR 0 9
62415: PPUSH
62416: CALL_OW 2
62420: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62421: LD_ADDR_EXP 123
62425: PUSH
62426: LD_EXP 123
62430: PPUSH
62431: LD_VAR 0 3
62435: PPUSH
62436: LD_VAR 0 7
62440: PPUSH
62441: CALL_OW 1
62445: ST_TO_ADDR
// end else
62446: GO 62465
// MC_InsertProduceList ( i , [ components ] ) ;
62448: LD_VAR 0 3
62452: PPUSH
62453: LD_VAR 0 9
62457: PUSH
62458: EMPTY
62459: LIST
62460: PPUSH
62461: CALL 58434 0 2
// break ;
62465: GO 62469
// end ; end ;
62467: GO 62254
62469: POP
62470: POP
// end ; end ; if GetType ( un ) = unit_building then
62471: LD_VAR 0 1
62475: PPUSH
62476: CALL_OW 247
62480: PUSH
62481: LD_INT 3
62483: EQUAL
62484: IFFALSE 62887
// begin btype := GetBType ( un ) ;
62486: LD_ADDR_VAR 0 5
62490: PUSH
62491: LD_VAR 0 1
62495: PPUSH
62496: CALL_OW 266
62500: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62501: LD_VAR 0 5
62505: PUSH
62506: LD_INT 29
62508: PUSH
62509: LD_INT 30
62511: PUSH
62512: EMPTY
62513: LIST
62514: LIST
62515: IN
62516: IFFALSE 62589
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62518: LD_VAR 0 1
62522: PPUSH
62523: CALL_OW 250
62527: PPUSH
62528: LD_VAR 0 1
62532: PPUSH
62533: CALL_OW 251
62537: PPUSH
62538: LD_VAR 0 1
62542: PPUSH
62543: CALL_OW 255
62547: PPUSH
62548: CALL_OW 440
62552: NOT
62553: IFFALSE 62589
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62555: LD_VAR 0 1
62559: PPUSH
62560: CALL_OW 250
62564: PPUSH
62565: LD_VAR 0 1
62569: PPUSH
62570: CALL_OW 251
62574: PPUSH
62575: LD_VAR 0 1
62579: PPUSH
62580: CALL_OW 255
62584: PPUSH
62585: CALL_OW 441
// end ; if btype = b_warehouse then
62589: LD_VAR 0 5
62593: PUSH
62594: LD_INT 1
62596: EQUAL
62597: IFFALSE 62615
// begin btype := b_depot ;
62599: LD_ADDR_VAR 0 5
62603: PUSH
62604: LD_INT 0
62606: ST_TO_ADDR
// pos := 1 ;
62607: LD_ADDR_VAR 0 6
62611: PUSH
62612: LD_INT 1
62614: ST_TO_ADDR
// end ; if btype = b_factory then
62615: LD_VAR 0 5
62619: PUSH
62620: LD_INT 3
62622: EQUAL
62623: IFFALSE 62641
// begin btype := b_workshop ;
62625: LD_ADDR_VAR 0 5
62629: PUSH
62630: LD_INT 2
62632: ST_TO_ADDR
// pos := 1 ;
62633: LD_ADDR_VAR 0 6
62637: PUSH
62638: LD_INT 1
62640: ST_TO_ADDR
// end ; if btype = b_barracks then
62641: LD_VAR 0 5
62645: PUSH
62646: LD_INT 5
62648: EQUAL
62649: IFFALSE 62659
// btype := b_armoury ;
62651: LD_ADDR_VAR 0 5
62655: PUSH
62656: LD_INT 4
62658: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62659: LD_VAR 0 5
62663: PUSH
62664: LD_INT 7
62666: PUSH
62667: LD_INT 8
62669: PUSH
62670: EMPTY
62671: LIST
62672: LIST
62673: IN
62674: IFFALSE 62684
// btype := b_lab ;
62676: LD_ADDR_VAR 0 5
62680: PUSH
62681: LD_INT 6
62683: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62684: LD_ADDR_EXP 107
62688: PUSH
62689: LD_EXP 107
62693: PPUSH
62694: LD_VAR 0 3
62698: PUSH
62699: LD_EXP 107
62703: PUSH
62704: LD_VAR 0 3
62708: ARRAY
62709: PUSH
62710: LD_INT 1
62712: PLUS
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: PPUSH
62718: LD_VAR 0 5
62722: PUSH
62723: LD_VAR 0 1
62727: PPUSH
62728: CALL_OW 250
62732: PUSH
62733: LD_VAR 0 1
62737: PPUSH
62738: CALL_OW 251
62742: PUSH
62743: LD_VAR 0 1
62747: PPUSH
62748: CALL_OW 254
62752: PUSH
62753: EMPTY
62754: LIST
62755: LIST
62756: LIST
62757: LIST
62758: PPUSH
62759: CALL 72015 0 3
62763: ST_TO_ADDR
// if pos = 1 then
62764: LD_VAR 0 6
62768: PUSH
62769: LD_INT 1
62771: EQUAL
62772: IFFALSE 62887
// begin tmp := mc_build_list [ i ] ;
62774: LD_ADDR_VAR 0 7
62778: PUSH
62779: LD_EXP 107
62783: PUSH
62784: LD_VAR 0 3
62788: ARRAY
62789: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62790: LD_VAR 0 7
62794: PPUSH
62795: LD_INT 2
62797: PUSH
62798: LD_INT 30
62800: PUSH
62801: LD_INT 0
62803: PUSH
62804: EMPTY
62805: LIST
62806: LIST
62807: PUSH
62808: LD_INT 30
62810: PUSH
62811: LD_INT 1
62813: PUSH
62814: EMPTY
62815: LIST
62816: LIST
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: LIST
62822: PPUSH
62823: CALL_OW 72
62827: IFFALSE 62837
// pos := 2 ;
62829: LD_ADDR_VAR 0 6
62833: PUSH
62834: LD_INT 2
62836: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62837: LD_ADDR_VAR 0 7
62841: PUSH
62842: LD_VAR 0 7
62846: PPUSH
62847: LD_VAR 0 6
62851: PPUSH
62852: LD_VAR 0 7
62856: PPUSH
62857: CALL 72341 0 3
62861: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62862: LD_ADDR_EXP 107
62866: PUSH
62867: LD_EXP 107
62871: PPUSH
62872: LD_VAR 0 3
62876: PPUSH
62877: LD_VAR 0 7
62881: PPUSH
62882: CALL_OW 1
62886: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62887: LD_VAR 0 1
62891: PUSH
62892: LD_EXP 102
62896: PUSH
62897: LD_VAR 0 3
62901: ARRAY
62902: IN
62903: IFFALSE 62942
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62905: LD_ADDR_EXP 102
62909: PUSH
62910: LD_EXP 102
62914: PPUSH
62915: LD_VAR 0 3
62919: PPUSH
62920: LD_EXP 102
62924: PUSH
62925: LD_VAR 0 3
62929: ARRAY
62930: PUSH
62931: LD_VAR 0 1
62935: DIFF
62936: PPUSH
62937: CALL_OW 1
62941: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62942: LD_VAR 0 1
62946: PUSH
62947: LD_EXP 109
62951: PUSH
62952: LD_VAR 0 3
62956: ARRAY
62957: IN
62958: IFFALSE 62997
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62960: LD_ADDR_EXP 109
62964: PUSH
62965: LD_EXP 109
62969: PPUSH
62970: LD_VAR 0 3
62974: PPUSH
62975: LD_EXP 109
62979: PUSH
62980: LD_VAR 0 3
62984: ARRAY
62985: PUSH
62986: LD_VAR 0 1
62990: DIFF
62991: PPUSH
62992: CALL_OW 1
62996: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62997: LD_VAR 0 1
63001: PUSH
63002: LD_EXP 121
63006: PUSH
63007: LD_VAR 0 3
63011: ARRAY
63012: IN
63013: IFFALSE 63052
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63015: LD_ADDR_EXP 121
63019: PUSH
63020: LD_EXP 121
63024: PPUSH
63025: LD_VAR 0 3
63029: PPUSH
63030: LD_EXP 121
63034: PUSH
63035: LD_VAR 0 3
63039: ARRAY
63040: PUSH
63041: LD_VAR 0 1
63045: DIFF
63046: PPUSH
63047: CALL_OW 1
63051: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63052: LD_VAR 0 1
63056: PUSH
63057: LD_EXP 124
63061: PUSH
63062: LD_VAR 0 3
63066: ARRAY
63067: IN
63068: IFFALSE 63107
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63070: LD_ADDR_EXP 124
63074: PUSH
63075: LD_EXP 124
63079: PPUSH
63080: LD_VAR 0 3
63084: PPUSH
63085: LD_EXP 124
63089: PUSH
63090: LD_VAR 0 3
63094: ARRAY
63095: PUSH
63096: LD_VAR 0 1
63100: DIFF
63101: PPUSH
63102: CALL_OW 1
63106: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63107: LD_VAR 0 1
63111: PUSH
63112: LD_EXP 111
63116: PUSH
63117: LD_VAR 0 3
63121: ARRAY
63122: IN
63123: IFFALSE 63162
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63125: LD_ADDR_EXP 111
63129: PUSH
63130: LD_EXP 111
63134: PPUSH
63135: LD_VAR 0 3
63139: PPUSH
63140: LD_EXP 111
63144: PUSH
63145: LD_VAR 0 3
63149: ARRAY
63150: PUSH
63151: LD_VAR 0 1
63155: DIFF
63156: PPUSH
63157: CALL_OW 1
63161: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63162: LD_VAR 0 1
63166: PUSH
63167: LD_EXP 110
63171: PUSH
63172: LD_VAR 0 3
63176: ARRAY
63177: IN
63178: IFFALSE 63217
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63180: LD_ADDR_EXP 110
63184: PUSH
63185: LD_EXP 110
63189: PPUSH
63190: LD_VAR 0 3
63194: PPUSH
63195: LD_EXP 110
63199: PUSH
63200: LD_VAR 0 3
63204: ARRAY
63205: PUSH
63206: LD_VAR 0 1
63210: DIFF
63211: PPUSH
63212: CALL_OW 1
63216: ST_TO_ADDR
// end ; break ;
63217: GO 63221
// end ;
63219: GO 61867
63221: POP
63222: POP
// end ;
63223: LD_VAR 0 2
63227: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63228: LD_INT 0
63230: PPUSH
63231: PPUSH
63232: PPUSH
// if not mc_bases or not skirmish then
63233: LD_EXP 102
63237: NOT
63238: PUSH
63239: LD_EXP 100
63243: NOT
63244: OR
63245: IFFALSE 63249
// exit ;
63247: GO 63464
// for i = 1 to mc_bases do
63249: LD_ADDR_VAR 0 3
63253: PUSH
63254: DOUBLE
63255: LD_INT 1
63257: DEC
63258: ST_TO_ADDR
63259: LD_EXP 102
63263: PUSH
63264: FOR_TO
63265: IFFALSE 63462
// begin if building in mc_construct_list [ i ] then
63267: LD_VAR 0 1
63271: PUSH
63272: LD_EXP 109
63276: PUSH
63277: LD_VAR 0 3
63281: ARRAY
63282: IN
63283: IFFALSE 63460
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63285: LD_ADDR_EXP 109
63289: PUSH
63290: LD_EXP 109
63294: PPUSH
63295: LD_VAR 0 3
63299: PPUSH
63300: LD_EXP 109
63304: PUSH
63305: LD_VAR 0 3
63309: ARRAY
63310: PUSH
63311: LD_VAR 0 1
63315: DIFF
63316: PPUSH
63317: CALL_OW 1
63321: ST_TO_ADDR
// if building in mc_lab [ i ] then
63322: LD_VAR 0 1
63326: PUSH
63327: LD_EXP 135
63331: PUSH
63332: LD_VAR 0 3
63336: ARRAY
63337: IN
63338: IFFALSE 63393
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63340: LD_ADDR_EXP 136
63344: PUSH
63345: LD_EXP 136
63349: PPUSH
63350: LD_VAR 0 3
63354: PPUSH
63355: LD_EXP 136
63359: PUSH
63360: LD_VAR 0 3
63364: ARRAY
63365: PPUSH
63366: LD_INT 1
63368: PPUSH
63369: LD_EXP 136
63373: PUSH
63374: LD_VAR 0 3
63378: ARRAY
63379: PPUSH
63380: LD_INT 0
63382: PPUSH
63383: CALL 71433 0 4
63387: PPUSH
63388: CALL_OW 1
63392: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63393: LD_VAR 0 1
63397: PUSH
63398: LD_EXP 102
63402: PUSH
63403: LD_VAR 0 3
63407: ARRAY
63408: IN
63409: NOT
63410: IFFALSE 63456
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63412: LD_ADDR_EXP 102
63416: PUSH
63417: LD_EXP 102
63421: PPUSH
63422: LD_VAR 0 3
63426: PUSH
63427: LD_EXP 102
63431: PUSH
63432: LD_VAR 0 3
63436: ARRAY
63437: PUSH
63438: LD_INT 1
63440: PLUS
63441: PUSH
63442: EMPTY
63443: LIST
63444: LIST
63445: PPUSH
63446: LD_VAR 0 1
63450: PPUSH
63451: CALL 72015 0 3
63455: ST_TO_ADDR
// exit ;
63456: POP
63457: POP
63458: GO 63464
// end ; end ;
63460: GO 63264
63462: POP
63463: POP
// end ;
63464: LD_VAR 0 2
63468: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63469: LD_INT 0
63471: PPUSH
63472: PPUSH
63473: PPUSH
63474: PPUSH
63475: PPUSH
63476: PPUSH
63477: PPUSH
// if not mc_bases or not skirmish then
63478: LD_EXP 102
63482: NOT
63483: PUSH
63484: LD_EXP 100
63488: NOT
63489: OR
63490: IFFALSE 63494
// exit ;
63492: GO 64155
// for i = 1 to mc_bases do
63494: LD_ADDR_VAR 0 3
63498: PUSH
63499: DOUBLE
63500: LD_INT 1
63502: DEC
63503: ST_TO_ADDR
63504: LD_EXP 102
63508: PUSH
63509: FOR_TO
63510: IFFALSE 64153
// begin if building in mc_construct_list [ i ] then
63512: LD_VAR 0 1
63516: PUSH
63517: LD_EXP 109
63521: PUSH
63522: LD_VAR 0 3
63526: ARRAY
63527: IN
63528: IFFALSE 64151
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63530: LD_ADDR_EXP 109
63534: PUSH
63535: LD_EXP 109
63539: PPUSH
63540: LD_VAR 0 3
63544: PPUSH
63545: LD_EXP 109
63549: PUSH
63550: LD_VAR 0 3
63554: ARRAY
63555: PUSH
63556: LD_VAR 0 1
63560: DIFF
63561: PPUSH
63562: CALL_OW 1
63566: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63567: LD_ADDR_EXP 102
63571: PUSH
63572: LD_EXP 102
63576: PPUSH
63577: LD_VAR 0 3
63581: PUSH
63582: LD_EXP 102
63586: PUSH
63587: LD_VAR 0 3
63591: ARRAY
63592: PUSH
63593: LD_INT 1
63595: PLUS
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: PPUSH
63601: LD_VAR 0 1
63605: PPUSH
63606: CALL 72015 0 3
63610: ST_TO_ADDR
// btype := GetBType ( building ) ;
63611: LD_ADDR_VAR 0 5
63615: PUSH
63616: LD_VAR 0 1
63620: PPUSH
63621: CALL_OW 266
63625: ST_TO_ADDR
// side := GetSide ( building ) ;
63626: LD_ADDR_VAR 0 8
63630: PUSH
63631: LD_VAR 0 1
63635: PPUSH
63636: CALL_OW 255
63640: ST_TO_ADDR
// if btype = b_lab then
63641: LD_VAR 0 5
63645: PUSH
63646: LD_INT 6
63648: EQUAL
63649: IFFALSE 63699
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63651: LD_ADDR_EXP 135
63655: PUSH
63656: LD_EXP 135
63660: PPUSH
63661: LD_VAR 0 3
63665: PUSH
63666: LD_EXP 135
63670: PUSH
63671: LD_VAR 0 3
63675: ARRAY
63676: PUSH
63677: LD_INT 1
63679: PLUS
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: PPUSH
63685: LD_VAR 0 1
63689: PPUSH
63690: CALL 72015 0 3
63694: ST_TO_ADDR
// exit ;
63695: POP
63696: POP
63697: GO 64155
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63699: LD_VAR 0 5
63703: PUSH
63704: LD_INT 0
63706: PUSH
63707: LD_INT 2
63709: PUSH
63710: LD_INT 4
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: LIST
63717: IN
63718: IFFALSE 63842
// begin if btype = b_armoury then
63720: LD_VAR 0 5
63724: PUSH
63725: LD_INT 4
63727: EQUAL
63728: IFFALSE 63738
// btype := b_barracks ;
63730: LD_ADDR_VAR 0 5
63734: PUSH
63735: LD_INT 5
63737: ST_TO_ADDR
// if btype = b_depot then
63738: LD_VAR 0 5
63742: PUSH
63743: LD_INT 0
63745: EQUAL
63746: IFFALSE 63756
// btype := b_warehouse ;
63748: LD_ADDR_VAR 0 5
63752: PUSH
63753: LD_INT 1
63755: ST_TO_ADDR
// if btype = b_workshop then
63756: LD_VAR 0 5
63760: PUSH
63761: LD_INT 2
63763: EQUAL
63764: IFFALSE 63774
// btype := b_factory ;
63766: LD_ADDR_VAR 0 5
63770: PUSH
63771: LD_INT 3
63773: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63774: LD_VAR 0 5
63778: PPUSH
63779: LD_VAR 0 8
63783: PPUSH
63784: CALL_OW 323
63788: PUSH
63789: LD_INT 1
63791: EQUAL
63792: IFFALSE 63838
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63794: LD_ADDR_EXP 134
63798: PUSH
63799: LD_EXP 134
63803: PPUSH
63804: LD_VAR 0 3
63808: PUSH
63809: LD_EXP 134
63813: PUSH
63814: LD_VAR 0 3
63818: ARRAY
63819: PUSH
63820: LD_INT 1
63822: PLUS
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PPUSH
63828: LD_VAR 0 1
63832: PPUSH
63833: CALL 72015 0 3
63837: ST_TO_ADDR
// exit ;
63838: POP
63839: POP
63840: GO 64155
// end ; if btype in [ b_bunker , b_turret ] then
63842: LD_VAR 0 5
63846: PUSH
63847: LD_INT 32
63849: PUSH
63850: LD_INT 33
63852: PUSH
63853: EMPTY
63854: LIST
63855: LIST
63856: IN
63857: IFFALSE 64147
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63859: LD_ADDR_EXP 110
63863: PUSH
63864: LD_EXP 110
63868: PPUSH
63869: LD_VAR 0 3
63873: PUSH
63874: LD_EXP 110
63878: PUSH
63879: LD_VAR 0 3
63883: ARRAY
63884: PUSH
63885: LD_INT 1
63887: PLUS
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PPUSH
63893: LD_VAR 0 1
63897: PPUSH
63898: CALL 72015 0 3
63902: ST_TO_ADDR
// if btype = b_bunker then
63903: LD_VAR 0 5
63907: PUSH
63908: LD_INT 32
63910: EQUAL
63911: IFFALSE 64147
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63913: LD_ADDR_EXP 111
63917: PUSH
63918: LD_EXP 111
63922: PPUSH
63923: LD_VAR 0 3
63927: PUSH
63928: LD_EXP 111
63932: PUSH
63933: LD_VAR 0 3
63937: ARRAY
63938: PUSH
63939: LD_INT 1
63941: PLUS
63942: PUSH
63943: EMPTY
63944: LIST
63945: LIST
63946: PPUSH
63947: LD_VAR 0 1
63951: PPUSH
63952: CALL 72015 0 3
63956: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63957: LD_ADDR_VAR 0 6
63961: PUSH
63962: LD_EXP 102
63966: PUSH
63967: LD_VAR 0 3
63971: ARRAY
63972: PPUSH
63973: LD_INT 25
63975: PUSH
63976: LD_INT 1
63978: PUSH
63979: EMPTY
63980: LIST
63981: LIST
63982: PUSH
63983: LD_INT 3
63985: PUSH
63986: LD_INT 54
63988: PUSH
63989: EMPTY
63990: LIST
63991: PUSH
63992: EMPTY
63993: LIST
63994: LIST
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: PPUSH
64000: CALL_OW 72
64004: ST_TO_ADDR
// if tmp then
64005: LD_VAR 0 6
64009: IFFALSE 64015
// exit ;
64011: POP
64012: POP
64013: GO 64155
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64015: LD_ADDR_VAR 0 6
64019: PUSH
64020: LD_EXP 102
64024: PUSH
64025: LD_VAR 0 3
64029: ARRAY
64030: PPUSH
64031: LD_INT 2
64033: PUSH
64034: LD_INT 30
64036: PUSH
64037: LD_INT 4
64039: PUSH
64040: EMPTY
64041: LIST
64042: LIST
64043: PUSH
64044: LD_INT 30
64046: PUSH
64047: LD_INT 5
64049: PUSH
64050: EMPTY
64051: LIST
64052: LIST
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: LIST
64058: PPUSH
64059: CALL_OW 72
64063: ST_TO_ADDR
// if not tmp then
64064: LD_VAR 0 6
64068: NOT
64069: IFFALSE 64075
// exit ;
64071: POP
64072: POP
64073: GO 64155
// for j in tmp do
64075: LD_ADDR_VAR 0 4
64079: PUSH
64080: LD_VAR 0 6
64084: PUSH
64085: FOR_IN
64086: IFFALSE 64145
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64088: LD_ADDR_VAR 0 7
64092: PUSH
64093: LD_VAR 0 4
64097: PPUSH
64098: CALL_OW 313
64102: PPUSH
64103: LD_INT 25
64105: PUSH
64106: LD_INT 1
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PPUSH
64113: CALL_OW 72
64117: ST_TO_ADDR
// if units then
64118: LD_VAR 0 7
64122: IFFALSE 64143
// begin ComExitBuilding ( units [ 1 ] ) ;
64124: LD_VAR 0 7
64128: PUSH
64129: LD_INT 1
64131: ARRAY
64132: PPUSH
64133: CALL_OW 122
// exit ;
64137: POP
64138: POP
64139: POP
64140: POP
64141: GO 64155
// end ; end ;
64143: GO 64085
64145: POP
64146: POP
// end ; end ; exit ;
64147: POP
64148: POP
64149: GO 64155
// end ; end ;
64151: GO 63509
64153: POP
64154: POP
// end ;
64155: LD_VAR 0 2
64159: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64160: LD_INT 0
64162: PPUSH
64163: PPUSH
64164: PPUSH
64165: PPUSH
64166: PPUSH
64167: PPUSH
64168: PPUSH
// if not mc_bases or not skirmish then
64169: LD_EXP 102
64173: NOT
64174: PUSH
64175: LD_EXP 100
64179: NOT
64180: OR
64181: IFFALSE 64185
// exit ;
64183: GO 64416
// btype := GetBType ( building ) ;
64185: LD_ADDR_VAR 0 6
64189: PUSH
64190: LD_VAR 0 1
64194: PPUSH
64195: CALL_OW 266
64199: ST_TO_ADDR
// x := GetX ( building ) ;
64200: LD_ADDR_VAR 0 7
64204: PUSH
64205: LD_VAR 0 1
64209: PPUSH
64210: CALL_OW 250
64214: ST_TO_ADDR
// y := GetY ( building ) ;
64215: LD_ADDR_VAR 0 8
64219: PUSH
64220: LD_VAR 0 1
64224: PPUSH
64225: CALL_OW 251
64229: ST_TO_ADDR
// d := GetDir ( building ) ;
64230: LD_ADDR_VAR 0 9
64234: PUSH
64235: LD_VAR 0 1
64239: PPUSH
64240: CALL_OW 254
64244: ST_TO_ADDR
// for i = 1 to mc_bases do
64245: LD_ADDR_VAR 0 4
64249: PUSH
64250: DOUBLE
64251: LD_INT 1
64253: DEC
64254: ST_TO_ADDR
64255: LD_EXP 102
64259: PUSH
64260: FOR_TO
64261: IFFALSE 64414
// begin if not mc_build_list [ i ] then
64263: LD_EXP 107
64267: PUSH
64268: LD_VAR 0 4
64272: ARRAY
64273: NOT
64274: IFFALSE 64278
// continue ;
64276: GO 64260
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64278: LD_VAR 0 6
64282: PUSH
64283: LD_VAR 0 7
64287: PUSH
64288: LD_VAR 0 8
64292: PUSH
64293: LD_VAR 0 9
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: PPUSH
64304: LD_EXP 107
64308: PUSH
64309: LD_VAR 0 4
64313: ARRAY
64314: PUSH
64315: LD_INT 1
64317: ARRAY
64318: PPUSH
64319: CALL 78184 0 2
64323: IFFALSE 64412
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64325: LD_ADDR_EXP 107
64329: PUSH
64330: LD_EXP 107
64334: PPUSH
64335: LD_VAR 0 4
64339: PPUSH
64340: LD_EXP 107
64344: PUSH
64345: LD_VAR 0 4
64349: ARRAY
64350: PPUSH
64351: LD_INT 1
64353: PPUSH
64354: CALL_OW 3
64358: PPUSH
64359: CALL_OW 1
64363: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64364: LD_ADDR_EXP 109
64368: PUSH
64369: LD_EXP 109
64373: PPUSH
64374: LD_VAR 0 4
64378: PUSH
64379: LD_EXP 109
64383: PUSH
64384: LD_VAR 0 4
64388: ARRAY
64389: PUSH
64390: LD_INT 1
64392: PLUS
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: PPUSH
64398: LD_VAR 0 1
64402: PPUSH
64403: CALL 72015 0 3
64407: ST_TO_ADDR
// exit ;
64408: POP
64409: POP
64410: GO 64416
// end ; end ;
64412: GO 64260
64414: POP
64415: POP
// end ;
64416: LD_VAR 0 3
64420: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64421: LD_INT 0
64423: PPUSH
64424: PPUSH
64425: PPUSH
// if not mc_bases or not skirmish then
64426: LD_EXP 102
64430: NOT
64431: PUSH
64432: LD_EXP 100
64436: NOT
64437: OR
64438: IFFALSE 64442
// exit ;
64440: GO 64632
// for i = 1 to mc_bases do
64442: LD_ADDR_VAR 0 4
64446: PUSH
64447: DOUBLE
64448: LD_INT 1
64450: DEC
64451: ST_TO_ADDR
64452: LD_EXP 102
64456: PUSH
64457: FOR_TO
64458: IFFALSE 64545
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64460: LD_VAR 0 1
64464: PUSH
64465: LD_EXP 110
64469: PUSH
64470: LD_VAR 0 4
64474: ARRAY
64475: IN
64476: PUSH
64477: LD_VAR 0 1
64481: PUSH
64482: LD_EXP 111
64486: PUSH
64487: LD_VAR 0 4
64491: ARRAY
64492: IN
64493: NOT
64494: AND
64495: IFFALSE 64543
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64497: LD_ADDR_EXP 111
64501: PUSH
64502: LD_EXP 111
64506: PPUSH
64507: LD_VAR 0 4
64511: PUSH
64512: LD_EXP 111
64516: PUSH
64517: LD_VAR 0 4
64521: ARRAY
64522: PUSH
64523: LD_INT 1
64525: PLUS
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: PPUSH
64531: LD_VAR 0 1
64535: PPUSH
64536: CALL 72015 0 3
64540: ST_TO_ADDR
// break ;
64541: GO 64545
// end ; end ;
64543: GO 64457
64545: POP
64546: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64547: LD_VAR 0 1
64551: PPUSH
64552: CALL_OW 257
64556: PUSH
64557: LD_EXP 128
64561: IN
64562: PUSH
64563: LD_VAR 0 1
64567: PPUSH
64568: CALL_OW 266
64572: PUSH
64573: LD_INT 5
64575: EQUAL
64576: AND
64577: PUSH
64578: LD_VAR 0 2
64582: PPUSH
64583: CALL_OW 110
64587: PUSH
64588: LD_INT 18
64590: NONEQUAL
64591: AND
64592: IFFALSE 64632
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64594: LD_VAR 0 2
64598: PPUSH
64599: CALL_OW 257
64603: PUSH
64604: LD_INT 5
64606: PUSH
64607: LD_INT 8
64609: PUSH
64610: LD_INT 9
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: LIST
64617: IN
64618: IFFALSE 64632
// SetClass ( unit , 1 ) ;
64620: LD_VAR 0 2
64624: PPUSH
64625: LD_INT 1
64627: PPUSH
64628: CALL_OW 336
// end ;
64632: LD_VAR 0 3
64636: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64637: LD_INT 0
64639: PPUSH
64640: PPUSH
// if not mc_bases or not skirmish then
64641: LD_EXP 102
64645: NOT
64646: PUSH
64647: LD_EXP 100
64651: NOT
64652: OR
64653: IFFALSE 64657
// exit ;
64655: GO 64773
// if GetLives ( abandoned_vehicle ) > 250 then
64657: LD_VAR 0 2
64661: PPUSH
64662: CALL_OW 256
64666: PUSH
64667: LD_INT 250
64669: GREATER
64670: IFFALSE 64674
// exit ;
64672: GO 64773
// for i = 1 to mc_bases do
64674: LD_ADDR_VAR 0 6
64678: PUSH
64679: DOUBLE
64680: LD_INT 1
64682: DEC
64683: ST_TO_ADDR
64684: LD_EXP 102
64688: PUSH
64689: FOR_TO
64690: IFFALSE 64771
// begin if driver in mc_bases [ i ] then
64692: LD_VAR 0 1
64696: PUSH
64697: LD_EXP 102
64701: PUSH
64702: LD_VAR 0 6
64706: ARRAY
64707: IN
64708: IFFALSE 64769
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64710: LD_VAR 0 1
64714: PPUSH
64715: LD_EXP 102
64719: PUSH
64720: LD_VAR 0 6
64724: ARRAY
64725: PPUSH
64726: LD_INT 2
64728: PUSH
64729: LD_INT 30
64731: PUSH
64732: LD_INT 0
64734: PUSH
64735: EMPTY
64736: LIST
64737: LIST
64738: PUSH
64739: LD_INT 30
64741: PUSH
64742: LD_INT 1
64744: PUSH
64745: EMPTY
64746: LIST
64747: LIST
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: LIST
64753: PPUSH
64754: CALL_OW 72
64758: PUSH
64759: LD_INT 1
64761: ARRAY
64762: PPUSH
64763: CALL_OW 112
// break ;
64767: GO 64771
// end ; end ;
64769: GO 64689
64771: POP
64772: POP
// end ; end_of_file
64773: LD_VAR 0 5
64777: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64778: LD_INT 0
64780: PPUSH
64781: PPUSH
// if exist_mode then
64782: LD_VAR 0 2
64786: IFFALSE 64811
// unit := CreateCharacter ( prefix & ident ) else
64788: LD_ADDR_VAR 0 5
64792: PUSH
64793: LD_VAR 0 3
64797: PUSH
64798: LD_VAR 0 1
64802: STR
64803: PPUSH
64804: CALL_OW 34
64808: ST_TO_ADDR
64809: GO 64826
// unit := NewCharacter ( ident ) ;
64811: LD_ADDR_VAR 0 5
64815: PUSH
64816: LD_VAR 0 1
64820: PPUSH
64821: CALL_OW 25
64825: ST_TO_ADDR
// result := unit ;
64826: LD_ADDR_VAR 0 4
64830: PUSH
64831: LD_VAR 0 5
64835: ST_TO_ADDR
// end ;
64836: LD_VAR 0 4
64840: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64841: LD_INT 0
64843: PPUSH
64844: PPUSH
// if not side or not nation then
64845: LD_VAR 0 1
64849: NOT
64850: PUSH
64851: LD_VAR 0 2
64855: NOT
64856: OR
64857: IFFALSE 64861
// exit ;
64859: GO 65505
// case nation of nation_american :
64861: LD_VAR 0 2
64865: PUSH
64866: LD_INT 1
64868: DOUBLE
64869: EQUAL
64870: IFTRUE 64874
64872: GO 65048
64874: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64875: LD_ADDR_VAR 0 4
64879: PUSH
64880: LD_INT 35
64882: PUSH
64883: LD_INT 45
64885: PUSH
64886: LD_INT 46
64888: PUSH
64889: LD_INT 47
64891: PUSH
64892: LD_INT 1
64894: PUSH
64895: LD_INT 2
64897: PUSH
64898: LD_INT 6
64900: PUSH
64901: LD_INT 15
64903: PUSH
64904: LD_INT 16
64906: PUSH
64907: LD_INT 7
64909: PUSH
64910: LD_INT 12
64912: PUSH
64913: LD_INT 13
64915: PUSH
64916: LD_INT 10
64918: PUSH
64919: LD_INT 14
64921: PUSH
64922: LD_INT 20
64924: PUSH
64925: LD_INT 21
64927: PUSH
64928: LD_INT 22
64930: PUSH
64931: LD_INT 25
64933: PUSH
64934: LD_INT 32
64936: PUSH
64937: LD_INT 27
64939: PUSH
64940: LD_INT 36
64942: PUSH
64943: LD_INT 69
64945: PUSH
64946: LD_INT 39
64948: PUSH
64949: LD_INT 34
64951: PUSH
64952: LD_INT 40
64954: PUSH
64955: LD_INT 48
64957: PUSH
64958: LD_INT 49
64960: PUSH
64961: LD_INT 50
64963: PUSH
64964: LD_INT 51
64966: PUSH
64967: LD_INT 52
64969: PUSH
64970: LD_INT 53
64972: PUSH
64973: LD_INT 54
64975: PUSH
64976: LD_INT 55
64978: PUSH
64979: LD_INT 56
64981: PUSH
64982: LD_INT 57
64984: PUSH
64985: LD_INT 58
64987: PUSH
64988: LD_INT 59
64990: PUSH
64991: LD_INT 60
64993: PUSH
64994: LD_INT 61
64996: PUSH
64997: LD_INT 62
64999: PUSH
65000: LD_INT 80
65002: PUSH
65003: EMPTY
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: LIST
65016: LIST
65017: LIST
65018: LIST
65019: LIST
65020: LIST
65021: LIST
65022: LIST
65023: LIST
65024: LIST
65025: LIST
65026: LIST
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: LIST
65033: LIST
65034: LIST
65035: LIST
65036: LIST
65037: LIST
65038: LIST
65039: LIST
65040: LIST
65041: LIST
65042: LIST
65043: LIST
65044: LIST
65045: ST_TO_ADDR
65046: GO 65429
65048: LD_INT 2
65050: DOUBLE
65051: EQUAL
65052: IFTRUE 65056
65054: GO 65238
65056: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
65057: LD_ADDR_VAR 0 4
65061: PUSH
65062: LD_INT 35
65064: PUSH
65065: LD_INT 45
65067: PUSH
65068: LD_INT 46
65070: PUSH
65071: LD_INT 47
65073: PUSH
65074: LD_INT 70
65076: PUSH
65077: LD_INT 1
65079: PUSH
65080: LD_INT 11
65082: PUSH
65083: LD_INT 3
65085: PUSH
65086: LD_INT 4
65088: PUSH
65089: LD_INT 5
65091: PUSH
65092: LD_INT 6
65094: PUSH
65095: LD_INT 15
65097: PUSH
65098: LD_INT 18
65100: PUSH
65101: LD_INT 7
65103: PUSH
65104: LD_INT 17
65106: PUSH
65107: LD_INT 8
65109: PUSH
65110: LD_INT 20
65112: PUSH
65113: LD_INT 21
65115: PUSH
65116: LD_INT 22
65118: PUSH
65119: LD_INT 72
65121: PUSH
65122: LD_INT 26
65124: PUSH
65125: LD_INT 69
65127: PUSH
65128: LD_INT 39
65130: PUSH
65131: LD_INT 40
65133: PUSH
65134: LD_INT 41
65136: PUSH
65137: LD_INT 42
65139: PUSH
65140: LD_INT 43
65142: PUSH
65143: LD_INT 48
65145: PUSH
65146: LD_INT 49
65148: PUSH
65149: LD_INT 50
65151: PUSH
65152: LD_INT 51
65154: PUSH
65155: LD_INT 52
65157: PUSH
65158: LD_INT 53
65160: PUSH
65161: LD_INT 54
65163: PUSH
65164: LD_INT 55
65166: PUSH
65167: LD_INT 56
65169: PUSH
65170: LD_INT 60
65172: PUSH
65173: LD_INT 61
65175: PUSH
65176: LD_INT 62
65178: PUSH
65179: LD_INT 66
65181: PUSH
65182: LD_INT 67
65184: PUSH
65185: LD_INT 68
65187: PUSH
65188: LD_INT 81
65190: PUSH
65191: EMPTY
65192: LIST
65193: LIST
65194: LIST
65195: LIST
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: LIST
65203: LIST
65204: LIST
65205: LIST
65206: LIST
65207: LIST
65208: LIST
65209: LIST
65210: LIST
65211: LIST
65212: LIST
65213: LIST
65214: LIST
65215: LIST
65216: LIST
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: LIST
65222: LIST
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: LIST
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: ST_TO_ADDR
65236: GO 65429
65238: LD_INT 3
65240: DOUBLE
65241: EQUAL
65242: IFTRUE 65246
65244: GO 65428
65246: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
65247: LD_ADDR_VAR 0 4
65251: PUSH
65252: LD_INT 46
65254: PUSH
65255: LD_INT 47
65257: PUSH
65258: LD_INT 1
65260: PUSH
65261: LD_INT 2
65263: PUSH
65264: LD_INT 11
65266: PUSH
65267: LD_INT 9
65269: PUSH
65270: LD_INT 20
65272: PUSH
65273: LD_INT 19
65275: PUSH
65276: LD_INT 21
65278: PUSH
65279: LD_INT 24
65281: PUSH
65282: LD_INT 22
65284: PUSH
65285: LD_INT 25
65287: PUSH
65288: LD_INT 28
65290: PUSH
65291: LD_INT 29
65293: PUSH
65294: LD_INT 30
65296: PUSH
65297: LD_INT 31
65299: PUSH
65300: LD_INT 37
65302: PUSH
65303: LD_INT 38
65305: PUSH
65306: LD_INT 32
65308: PUSH
65309: LD_INT 27
65311: PUSH
65312: LD_INT 33
65314: PUSH
65315: LD_INT 69
65317: PUSH
65318: LD_INT 39
65320: PUSH
65321: LD_INT 34
65323: PUSH
65324: LD_INT 40
65326: PUSH
65327: LD_INT 71
65329: PUSH
65330: LD_INT 23
65332: PUSH
65333: LD_INT 44
65335: PUSH
65336: LD_INT 48
65338: PUSH
65339: LD_INT 49
65341: PUSH
65342: LD_INT 50
65344: PUSH
65345: LD_INT 51
65347: PUSH
65348: LD_INT 52
65350: PUSH
65351: LD_INT 53
65353: PUSH
65354: LD_INT 54
65356: PUSH
65357: LD_INT 55
65359: PUSH
65360: LD_INT 56
65362: PUSH
65363: LD_INT 57
65365: PUSH
65366: LD_INT 58
65368: PUSH
65369: LD_INT 59
65371: PUSH
65372: LD_INT 63
65374: PUSH
65375: LD_INT 64
65377: PUSH
65378: LD_INT 65
65380: PUSH
65381: EMPTY
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: LIST
65411: LIST
65412: LIST
65413: LIST
65414: LIST
65415: LIST
65416: LIST
65417: LIST
65418: LIST
65419: LIST
65420: LIST
65421: LIST
65422: LIST
65423: LIST
65424: LIST
65425: ST_TO_ADDR
65426: GO 65429
65428: POP
// if state > - 1 and state < 3 then
65429: LD_VAR 0 3
65433: PUSH
65434: LD_INT 1
65436: NEG
65437: GREATER
65438: PUSH
65439: LD_VAR 0 3
65443: PUSH
65444: LD_INT 3
65446: LESS
65447: AND
65448: IFFALSE 65505
// for i in result do
65450: LD_ADDR_VAR 0 5
65454: PUSH
65455: LD_VAR 0 4
65459: PUSH
65460: FOR_IN
65461: IFFALSE 65503
// if GetTech ( i , side ) <> state then
65463: LD_VAR 0 5
65467: PPUSH
65468: LD_VAR 0 1
65472: PPUSH
65473: CALL_OW 321
65477: PUSH
65478: LD_VAR 0 3
65482: NONEQUAL
65483: IFFALSE 65501
// result := result diff i ;
65485: LD_ADDR_VAR 0 4
65489: PUSH
65490: LD_VAR 0 4
65494: PUSH
65495: LD_VAR 0 5
65499: DIFF
65500: ST_TO_ADDR
65501: GO 65460
65503: POP
65504: POP
// end ;
65505: LD_VAR 0 4
65509: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65510: LD_INT 0
65512: PPUSH
65513: PPUSH
65514: PPUSH
// result := true ;
65515: LD_ADDR_VAR 0 3
65519: PUSH
65520: LD_INT 1
65522: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65523: LD_ADDR_VAR 0 5
65527: PUSH
65528: LD_VAR 0 2
65532: PPUSH
65533: CALL_OW 480
65537: ST_TO_ADDR
// if not tmp then
65538: LD_VAR 0 5
65542: NOT
65543: IFFALSE 65547
// exit ;
65545: GO 65596
// for i in tmp do
65547: LD_ADDR_VAR 0 4
65551: PUSH
65552: LD_VAR 0 5
65556: PUSH
65557: FOR_IN
65558: IFFALSE 65594
// if GetTech ( i , side ) <> state_researched then
65560: LD_VAR 0 4
65564: PPUSH
65565: LD_VAR 0 1
65569: PPUSH
65570: CALL_OW 321
65574: PUSH
65575: LD_INT 2
65577: NONEQUAL
65578: IFFALSE 65592
// begin result := false ;
65580: LD_ADDR_VAR 0 3
65584: PUSH
65585: LD_INT 0
65587: ST_TO_ADDR
// exit ;
65588: POP
65589: POP
65590: GO 65596
// end ;
65592: GO 65557
65594: POP
65595: POP
// end ;
65596: LD_VAR 0 3
65600: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65601: LD_INT 0
65603: PPUSH
65604: PPUSH
65605: PPUSH
65606: PPUSH
65607: PPUSH
65608: PPUSH
65609: PPUSH
65610: PPUSH
65611: PPUSH
65612: PPUSH
65613: PPUSH
65614: PPUSH
65615: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65616: LD_VAR 0 1
65620: NOT
65621: PUSH
65622: LD_VAR 0 1
65626: PPUSH
65627: CALL_OW 257
65631: PUSH
65632: LD_INT 9
65634: NONEQUAL
65635: OR
65636: IFFALSE 65640
// exit ;
65638: GO 66213
// side := GetSide ( unit ) ;
65640: LD_ADDR_VAR 0 9
65644: PUSH
65645: LD_VAR 0 1
65649: PPUSH
65650: CALL_OW 255
65654: ST_TO_ADDR
// tech_space := tech_spacanom ;
65655: LD_ADDR_VAR 0 12
65659: PUSH
65660: LD_INT 29
65662: ST_TO_ADDR
// tech_time := tech_taurad ;
65663: LD_ADDR_VAR 0 13
65667: PUSH
65668: LD_INT 28
65670: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65671: LD_ADDR_VAR 0 11
65675: PUSH
65676: LD_VAR 0 1
65680: PPUSH
65681: CALL_OW 310
65685: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65686: LD_VAR 0 11
65690: PPUSH
65691: CALL_OW 247
65695: PUSH
65696: LD_INT 2
65698: EQUAL
65699: IFFALSE 65703
// exit ;
65701: GO 66213
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65703: LD_ADDR_VAR 0 8
65707: PUSH
65708: LD_INT 81
65710: PUSH
65711: LD_VAR 0 9
65715: PUSH
65716: EMPTY
65717: LIST
65718: LIST
65719: PUSH
65720: LD_INT 3
65722: PUSH
65723: LD_INT 21
65725: PUSH
65726: LD_INT 3
65728: PUSH
65729: EMPTY
65730: LIST
65731: LIST
65732: PUSH
65733: EMPTY
65734: LIST
65735: LIST
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: PPUSH
65741: CALL_OW 69
65745: ST_TO_ADDR
// if not tmp then
65746: LD_VAR 0 8
65750: NOT
65751: IFFALSE 65755
// exit ;
65753: GO 66213
// if in_unit then
65755: LD_VAR 0 11
65759: IFFALSE 65783
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65761: LD_ADDR_VAR 0 10
65765: PUSH
65766: LD_VAR 0 8
65770: PPUSH
65771: LD_VAR 0 11
65775: PPUSH
65776: CALL_OW 74
65780: ST_TO_ADDR
65781: GO 65803
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65783: LD_ADDR_VAR 0 10
65787: PUSH
65788: LD_VAR 0 8
65792: PPUSH
65793: LD_VAR 0 1
65797: PPUSH
65798: CALL_OW 74
65802: ST_TO_ADDR
// if not enemy then
65803: LD_VAR 0 10
65807: NOT
65808: IFFALSE 65812
// exit ;
65810: GO 66213
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65812: LD_VAR 0 11
65816: PUSH
65817: LD_VAR 0 11
65821: PPUSH
65822: LD_VAR 0 10
65826: PPUSH
65827: CALL_OW 296
65831: PUSH
65832: LD_INT 13
65834: GREATER
65835: AND
65836: PUSH
65837: LD_VAR 0 1
65841: PPUSH
65842: LD_VAR 0 10
65846: PPUSH
65847: CALL_OW 296
65851: PUSH
65852: LD_INT 12
65854: GREATER
65855: OR
65856: IFFALSE 65860
// exit ;
65858: GO 66213
// missile := [ 1 ] ;
65860: LD_ADDR_VAR 0 14
65864: PUSH
65865: LD_INT 1
65867: PUSH
65868: EMPTY
65869: LIST
65870: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65871: LD_VAR 0 9
65875: PPUSH
65876: LD_VAR 0 12
65880: PPUSH
65881: CALL_OW 325
65885: IFFALSE 65914
// missile := Insert ( missile , missile + 1 , 2 ) ;
65887: LD_ADDR_VAR 0 14
65891: PUSH
65892: LD_VAR 0 14
65896: PPUSH
65897: LD_VAR 0 14
65901: PUSH
65902: LD_INT 1
65904: PLUS
65905: PPUSH
65906: LD_INT 2
65908: PPUSH
65909: CALL_OW 2
65913: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65914: LD_VAR 0 9
65918: PPUSH
65919: LD_VAR 0 13
65923: PPUSH
65924: CALL_OW 325
65928: PUSH
65929: LD_VAR 0 10
65933: PPUSH
65934: CALL_OW 255
65938: PPUSH
65939: LD_VAR 0 13
65943: PPUSH
65944: CALL_OW 325
65948: NOT
65949: AND
65950: IFFALSE 65979
// missile := Insert ( missile , missile + 1 , 3 ) ;
65952: LD_ADDR_VAR 0 14
65956: PUSH
65957: LD_VAR 0 14
65961: PPUSH
65962: LD_VAR 0 14
65966: PUSH
65967: LD_INT 1
65969: PLUS
65970: PPUSH
65971: LD_INT 3
65973: PPUSH
65974: CALL_OW 2
65978: ST_TO_ADDR
// if missile < 2 then
65979: LD_VAR 0 14
65983: PUSH
65984: LD_INT 2
65986: LESS
65987: IFFALSE 65991
// exit ;
65989: GO 66213
// x := GetX ( enemy ) ;
65991: LD_ADDR_VAR 0 4
65995: PUSH
65996: LD_VAR 0 10
66000: PPUSH
66001: CALL_OW 250
66005: ST_TO_ADDR
// y := GetY ( enemy ) ;
66006: LD_ADDR_VAR 0 5
66010: PUSH
66011: LD_VAR 0 10
66015: PPUSH
66016: CALL_OW 251
66020: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66021: LD_ADDR_VAR 0 6
66025: PUSH
66026: LD_VAR 0 4
66030: PUSH
66031: LD_INT 1
66033: NEG
66034: PPUSH
66035: LD_INT 1
66037: PPUSH
66038: CALL_OW 12
66042: PLUS
66043: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66044: LD_ADDR_VAR 0 7
66048: PUSH
66049: LD_VAR 0 5
66053: PUSH
66054: LD_INT 1
66056: NEG
66057: PPUSH
66058: LD_INT 1
66060: PPUSH
66061: CALL_OW 12
66065: PLUS
66066: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66067: LD_VAR 0 6
66071: PPUSH
66072: LD_VAR 0 7
66076: PPUSH
66077: CALL_OW 488
66081: NOT
66082: IFFALSE 66104
// begin _x := x ;
66084: LD_ADDR_VAR 0 6
66088: PUSH
66089: LD_VAR 0 4
66093: ST_TO_ADDR
// _y := y ;
66094: LD_ADDR_VAR 0 7
66098: PUSH
66099: LD_VAR 0 5
66103: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66104: LD_ADDR_VAR 0 3
66108: PUSH
66109: LD_INT 1
66111: PPUSH
66112: LD_VAR 0 14
66116: PPUSH
66117: CALL_OW 12
66121: ST_TO_ADDR
// case i of 1 :
66122: LD_VAR 0 3
66126: PUSH
66127: LD_INT 1
66129: DOUBLE
66130: EQUAL
66131: IFTRUE 66135
66133: GO 66152
66135: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66136: LD_VAR 0 1
66140: PPUSH
66141: LD_VAR 0 10
66145: PPUSH
66146: CALL_OW 115
66150: GO 66213
66152: LD_INT 2
66154: DOUBLE
66155: EQUAL
66156: IFTRUE 66160
66158: GO 66182
66160: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66161: LD_VAR 0 1
66165: PPUSH
66166: LD_VAR 0 6
66170: PPUSH
66171: LD_VAR 0 7
66175: PPUSH
66176: CALL_OW 153
66180: GO 66213
66182: LD_INT 3
66184: DOUBLE
66185: EQUAL
66186: IFTRUE 66190
66188: GO 66212
66190: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66191: LD_VAR 0 1
66195: PPUSH
66196: LD_VAR 0 6
66200: PPUSH
66201: LD_VAR 0 7
66205: PPUSH
66206: CALL_OW 154
66210: GO 66213
66212: POP
// end ;
66213: LD_VAR 0 2
66217: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66218: LD_INT 0
66220: PPUSH
66221: PPUSH
66222: PPUSH
66223: PPUSH
66224: PPUSH
66225: PPUSH
// if not unit or not building then
66226: LD_VAR 0 1
66230: NOT
66231: PUSH
66232: LD_VAR 0 2
66236: NOT
66237: OR
66238: IFFALSE 66242
// exit ;
66240: GO 66400
// x := GetX ( building ) ;
66242: LD_ADDR_VAR 0 5
66246: PUSH
66247: LD_VAR 0 2
66251: PPUSH
66252: CALL_OW 250
66256: ST_TO_ADDR
// y := GetY ( building ) ;
66257: LD_ADDR_VAR 0 6
66261: PUSH
66262: LD_VAR 0 2
66266: PPUSH
66267: CALL_OW 251
66271: ST_TO_ADDR
// for i = 0 to 5 do
66272: LD_ADDR_VAR 0 4
66276: PUSH
66277: DOUBLE
66278: LD_INT 0
66280: DEC
66281: ST_TO_ADDR
66282: LD_INT 5
66284: PUSH
66285: FOR_TO
66286: IFFALSE 66398
// begin _x := ShiftX ( x , i , 3 ) ;
66288: LD_ADDR_VAR 0 7
66292: PUSH
66293: LD_VAR 0 5
66297: PPUSH
66298: LD_VAR 0 4
66302: PPUSH
66303: LD_INT 3
66305: PPUSH
66306: CALL_OW 272
66310: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66311: LD_ADDR_VAR 0 8
66315: PUSH
66316: LD_VAR 0 6
66320: PPUSH
66321: LD_VAR 0 4
66325: PPUSH
66326: LD_INT 3
66328: PPUSH
66329: CALL_OW 273
66333: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66334: LD_VAR 0 7
66338: PPUSH
66339: LD_VAR 0 8
66343: PPUSH
66344: CALL_OW 488
66348: NOT
66349: IFFALSE 66353
// continue ;
66351: GO 66285
// if HexInfo ( _x , _y ) = 0 then
66353: LD_VAR 0 7
66357: PPUSH
66358: LD_VAR 0 8
66362: PPUSH
66363: CALL_OW 428
66367: PUSH
66368: LD_INT 0
66370: EQUAL
66371: IFFALSE 66396
// begin ComMoveXY ( unit , _x , _y ) ;
66373: LD_VAR 0 1
66377: PPUSH
66378: LD_VAR 0 7
66382: PPUSH
66383: LD_VAR 0 8
66387: PPUSH
66388: CALL_OW 111
// exit ;
66392: POP
66393: POP
66394: GO 66400
// end ; end ;
66396: GO 66285
66398: POP
66399: POP
// end ;
66400: LD_VAR 0 3
66404: RET
// export function ScanBase ( side , base_area ) ; begin
66405: LD_INT 0
66407: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66408: LD_ADDR_VAR 0 3
66412: PUSH
66413: LD_VAR 0 2
66417: PPUSH
66418: LD_INT 81
66420: PUSH
66421: LD_VAR 0 1
66425: PUSH
66426: EMPTY
66427: LIST
66428: LIST
66429: PPUSH
66430: CALL_OW 70
66434: ST_TO_ADDR
// end ;
66435: LD_VAR 0 3
66439: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66440: LD_INT 0
66442: PPUSH
66443: PPUSH
66444: PPUSH
66445: PPUSH
66446: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66447: LD_VAR 0 1
66451: NOT
66452: PUSH
66453: LD_EXP 102
66457: PUSH
66458: LD_VAR 0 1
66462: ARRAY
66463: NOT
66464: OR
66465: PUSH
66466: LD_VAR 0 2
66470: NOT
66471: OR
66472: PUSH
66473: LD_VAR 0 3
66477: NOT
66478: OR
66479: IFFALSE 66483
// exit ;
66481: GO 66996
// side := mc_sides [ base ] ;
66483: LD_ADDR_VAR 0 6
66487: PUSH
66488: LD_EXP 128
66492: PUSH
66493: LD_VAR 0 1
66497: ARRAY
66498: ST_TO_ADDR
// if not side then
66499: LD_VAR 0 6
66503: NOT
66504: IFFALSE 66508
// exit ;
66506: GO 66996
// for i in solds do
66508: LD_ADDR_VAR 0 7
66512: PUSH
66513: LD_VAR 0 2
66517: PUSH
66518: FOR_IN
66519: IFFALSE 66580
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66521: LD_VAR 0 7
66525: PPUSH
66526: CALL_OW 310
66530: PPUSH
66531: CALL_OW 266
66535: PUSH
66536: LD_INT 32
66538: PUSH
66539: LD_INT 31
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: IN
66546: IFFALSE 66566
// solds := solds diff i else
66548: LD_ADDR_VAR 0 2
66552: PUSH
66553: LD_VAR 0 2
66557: PUSH
66558: LD_VAR 0 7
66562: DIFF
66563: ST_TO_ADDR
66564: GO 66578
// SetTag ( i , 18 ) ;
66566: LD_VAR 0 7
66570: PPUSH
66571: LD_INT 18
66573: PPUSH
66574: CALL_OW 109
66578: GO 66518
66580: POP
66581: POP
// if not solds then
66582: LD_VAR 0 2
66586: NOT
66587: IFFALSE 66591
// exit ;
66589: GO 66996
// repeat wait ( 0 0$1 ) ;
66591: LD_INT 35
66593: PPUSH
66594: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66598: LD_ADDR_VAR 0 5
66602: PUSH
66603: LD_VAR 0 6
66607: PPUSH
66608: LD_VAR 0 3
66612: PPUSH
66613: CALL 66405 0 2
66617: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66618: LD_EXP 102
66622: PUSH
66623: LD_VAR 0 1
66627: ARRAY
66628: NOT
66629: PUSH
66630: LD_EXP 102
66634: PUSH
66635: LD_VAR 0 1
66639: ARRAY
66640: PUSH
66641: EMPTY
66642: EQUAL
66643: OR
66644: IFFALSE 66681
// begin for i in solds do
66646: LD_ADDR_VAR 0 7
66650: PUSH
66651: LD_VAR 0 2
66655: PUSH
66656: FOR_IN
66657: IFFALSE 66670
// ComStop ( i ) ;
66659: LD_VAR 0 7
66663: PPUSH
66664: CALL_OW 141
66668: GO 66656
66670: POP
66671: POP
// solds := [ ] ;
66672: LD_ADDR_VAR 0 2
66676: PUSH
66677: EMPTY
66678: ST_TO_ADDR
// exit ;
66679: GO 66996
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66681: LD_VAR 0 5
66685: NOT
66686: PUSH
66687: LD_VAR 0 5
66691: PUSH
66692: LD_INT 3
66694: GREATER
66695: OR
66696: PUSH
66697: LD_EXP 124
66701: PUSH
66702: LD_VAR 0 1
66706: ARRAY
66707: OR
66708: IFFALSE 66749
// begin for i in solds do
66710: LD_ADDR_VAR 0 7
66714: PUSH
66715: LD_VAR 0 2
66719: PUSH
66720: FOR_IN
66721: IFFALSE 66745
// if HasTask ( i ) then
66723: LD_VAR 0 7
66727: PPUSH
66728: CALL_OW 314
66732: IFFALSE 66743
// ComStop ( i ) ;
66734: LD_VAR 0 7
66738: PPUSH
66739: CALL_OW 141
66743: GO 66720
66745: POP
66746: POP
// break ;
66747: GO 66984
// end ; for i in solds do
66749: LD_ADDR_VAR 0 7
66753: PUSH
66754: LD_VAR 0 2
66758: PUSH
66759: FOR_IN
66760: IFFALSE 66976
// begin if IsInUnit ( i ) then
66762: LD_VAR 0 7
66766: PPUSH
66767: CALL_OW 310
66771: IFFALSE 66782
// ComExitBuilding ( i ) ;
66773: LD_VAR 0 7
66777: PPUSH
66778: CALL_OW 122
// if GetLives ( i ) > 333 then
66782: LD_VAR 0 7
66786: PPUSH
66787: CALL_OW 256
66791: PUSH
66792: LD_INT 333
66794: GREATER
66795: IFFALSE 66823
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66797: LD_VAR 0 7
66801: PPUSH
66802: LD_VAR 0 5
66806: PPUSH
66807: LD_VAR 0 7
66811: PPUSH
66812: CALL_OW 74
66816: PPUSH
66817: CALL_OW 115
66821: GO 66974
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66823: LD_ADDR_VAR 0 8
66827: PUSH
66828: LD_EXP 102
66832: PUSH
66833: LD_VAR 0 1
66837: ARRAY
66838: PPUSH
66839: LD_INT 2
66841: PUSH
66842: LD_INT 30
66844: PUSH
66845: LD_INT 0
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: PUSH
66852: LD_INT 30
66854: PUSH
66855: LD_INT 1
66857: PUSH
66858: EMPTY
66859: LIST
66860: LIST
66861: PUSH
66862: LD_INT 30
66864: PUSH
66865: LD_INT 6
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: LIST
66876: LIST
66877: PPUSH
66878: CALL_OW 72
66882: PPUSH
66883: LD_VAR 0 7
66887: PPUSH
66888: CALL_OW 74
66892: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66893: LD_VAR 0 7
66897: PPUSH
66898: LD_VAR 0 8
66902: PPUSH
66903: CALL_OW 250
66907: PPUSH
66908: LD_INT 3
66910: PPUSH
66911: LD_INT 5
66913: PPUSH
66914: CALL_OW 272
66918: PPUSH
66919: LD_VAR 0 8
66923: PPUSH
66924: CALL_OW 251
66928: PPUSH
66929: LD_INT 3
66931: PPUSH
66932: LD_INT 5
66934: PPUSH
66935: CALL_OW 273
66939: PPUSH
66940: CALL_OW 111
// SetTag ( i , 0 ) ;
66944: LD_VAR 0 7
66948: PPUSH
66949: LD_INT 0
66951: PPUSH
66952: CALL_OW 109
// solds := solds diff i ;
66956: LD_ADDR_VAR 0 2
66960: PUSH
66961: LD_VAR 0 2
66965: PUSH
66966: LD_VAR 0 7
66970: DIFF
66971: ST_TO_ADDR
// continue ;
66972: GO 66759
// end ; end ;
66974: GO 66759
66976: POP
66977: POP
// until solds ;
66978: LD_VAR 0 2
66982: IFFALSE 66591
// MC_Reset ( base , 18 ) ;
66984: LD_VAR 0 1
66988: PPUSH
66989: LD_INT 18
66991: PPUSH
66992: CALL 38817 0 2
// end ;
66996: LD_VAR 0 4
67000: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
67001: LD_INT 0
67003: PPUSH
67004: PPUSH
67005: PPUSH
67006: PPUSH
67007: PPUSH
67008: PPUSH
67009: PPUSH
67010: PPUSH
67011: PPUSH
67012: PPUSH
67013: PPUSH
67014: PPUSH
67015: PPUSH
67016: PPUSH
67017: PPUSH
67018: PPUSH
67019: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
67020: LD_ADDR_VAR 0 13
67024: PUSH
67025: LD_EXP 102
67029: PUSH
67030: LD_VAR 0 1
67034: ARRAY
67035: PPUSH
67036: LD_INT 25
67038: PUSH
67039: LD_INT 3
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PPUSH
67046: CALL_OW 72
67050: ST_TO_ADDR
// if mc_remote_driver [ base ] then
67051: LD_EXP 142
67055: PUSH
67056: LD_VAR 0 1
67060: ARRAY
67061: IFFALSE 67085
// mechs := mechs diff mc_remote_driver [ base ] ;
67063: LD_ADDR_VAR 0 13
67067: PUSH
67068: LD_VAR 0 13
67072: PUSH
67073: LD_EXP 142
67077: PUSH
67078: LD_VAR 0 1
67082: ARRAY
67083: DIFF
67084: ST_TO_ADDR
// for i in mechs do
67085: LD_ADDR_VAR 0 5
67089: PUSH
67090: LD_VAR 0 13
67094: PUSH
67095: FOR_IN
67096: IFFALSE 67131
// if GetTag ( i ) > 0 then
67098: LD_VAR 0 5
67102: PPUSH
67103: CALL_OW 110
67107: PUSH
67108: LD_INT 0
67110: GREATER
67111: IFFALSE 67129
// mechs := mechs diff i ;
67113: LD_ADDR_VAR 0 13
67117: PUSH
67118: LD_VAR 0 13
67122: PUSH
67123: LD_VAR 0 5
67127: DIFF
67128: ST_TO_ADDR
67129: GO 67095
67131: POP
67132: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67133: LD_ADDR_VAR 0 9
67137: PUSH
67138: LD_EXP 102
67142: PUSH
67143: LD_VAR 0 1
67147: ARRAY
67148: PPUSH
67149: LD_INT 2
67151: PUSH
67152: LD_INT 25
67154: PUSH
67155: LD_INT 1
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: LD_INT 25
67164: PUSH
67165: LD_INT 5
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: LD_INT 25
67174: PUSH
67175: LD_INT 8
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 25
67184: PUSH
67185: LD_INT 9
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: LIST
67196: LIST
67197: LIST
67198: PPUSH
67199: CALL_OW 72
67203: ST_TO_ADDR
// if not defenders and not solds then
67204: LD_VAR 0 2
67208: NOT
67209: PUSH
67210: LD_VAR 0 9
67214: NOT
67215: AND
67216: IFFALSE 67220
// exit ;
67218: GO 68846
// depot_under_attack := false ;
67220: LD_ADDR_VAR 0 17
67224: PUSH
67225: LD_INT 0
67227: ST_TO_ADDR
// sold_defenders := [ ] ;
67228: LD_ADDR_VAR 0 18
67232: PUSH
67233: EMPTY
67234: ST_TO_ADDR
// if mechs then
67235: LD_VAR 0 13
67239: IFFALSE 67368
// for i in defenders do
67241: LD_ADDR_VAR 0 5
67245: PUSH
67246: LD_VAR 0 2
67250: PUSH
67251: FOR_IN
67252: IFFALSE 67366
// begin SetTag ( i , 20 ) ;
67254: LD_VAR 0 5
67258: PPUSH
67259: LD_INT 20
67261: PPUSH
67262: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
67266: LD_VAR 0 5
67270: PPUSH
67271: CALL_OW 263
67275: PUSH
67276: LD_INT 1
67278: EQUAL
67279: PUSH
67280: LD_VAR 0 5
67284: PPUSH
67285: CALL_OW 311
67289: NOT
67290: AND
67291: PUSH
67292: LD_VAR 0 13
67296: AND
67297: IFFALSE 67364
// begin un := mechs [ 1 ] ;
67299: LD_ADDR_VAR 0 11
67303: PUSH
67304: LD_VAR 0 13
67308: PUSH
67309: LD_INT 1
67311: ARRAY
67312: ST_TO_ADDR
// ComExitBuilding ( un ) ;
67313: LD_VAR 0 11
67317: PPUSH
67318: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
67322: LD_VAR 0 11
67326: PPUSH
67327: LD_VAR 0 5
67331: PPUSH
67332: CALL_OW 180
// SetTag ( un , 19 ) ;
67336: LD_VAR 0 11
67340: PPUSH
67341: LD_INT 19
67343: PPUSH
67344: CALL_OW 109
// mechs := mechs diff un ;
67348: LD_ADDR_VAR 0 13
67352: PUSH
67353: LD_VAR 0 13
67357: PUSH
67358: LD_VAR 0 11
67362: DIFF
67363: ST_TO_ADDR
// end ; end ;
67364: GO 67251
67366: POP
67367: POP
// if solds then
67368: LD_VAR 0 9
67372: IFFALSE 67431
// for i in solds do
67374: LD_ADDR_VAR 0 5
67378: PUSH
67379: LD_VAR 0 9
67383: PUSH
67384: FOR_IN
67385: IFFALSE 67429
// if not GetTag ( i ) then
67387: LD_VAR 0 5
67391: PPUSH
67392: CALL_OW 110
67396: NOT
67397: IFFALSE 67427
// begin defenders := defenders union i ;
67399: LD_ADDR_VAR 0 2
67403: PUSH
67404: LD_VAR 0 2
67408: PUSH
67409: LD_VAR 0 5
67413: UNION
67414: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67415: LD_VAR 0 5
67419: PPUSH
67420: LD_INT 18
67422: PPUSH
67423: CALL_OW 109
// end ;
67427: GO 67384
67429: POP
67430: POP
// repeat wait ( 0 0$1 ) ;
67431: LD_INT 35
67433: PPUSH
67434: CALL_OW 67
// enemy := mc_scan [ base ] ;
67438: LD_ADDR_VAR 0 3
67442: PUSH
67443: LD_EXP 125
67447: PUSH
67448: LD_VAR 0 1
67452: ARRAY
67453: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67454: LD_EXP 102
67458: PUSH
67459: LD_VAR 0 1
67463: ARRAY
67464: NOT
67465: PUSH
67466: LD_EXP 102
67470: PUSH
67471: LD_VAR 0 1
67475: ARRAY
67476: PUSH
67477: EMPTY
67478: EQUAL
67479: OR
67480: IFFALSE 67517
// begin for i in defenders do
67482: LD_ADDR_VAR 0 5
67486: PUSH
67487: LD_VAR 0 2
67491: PUSH
67492: FOR_IN
67493: IFFALSE 67506
// ComStop ( i ) ;
67495: LD_VAR 0 5
67499: PPUSH
67500: CALL_OW 141
67504: GO 67492
67506: POP
67507: POP
// defenders := [ ] ;
67508: LD_ADDR_VAR 0 2
67512: PUSH
67513: EMPTY
67514: ST_TO_ADDR
// exit ;
67515: GO 68846
// end ; for i in defenders do
67517: LD_ADDR_VAR 0 5
67521: PUSH
67522: LD_VAR 0 2
67526: PUSH
67527: FOR_IN
67528: IFFALSE 68346
// begin e := NearestUnitToUnit ( enemy , i ) ;
67530: LD_ADDR_VAR 0 14
67534: PUSH
67535: LD_VAR 0 3
67539: PPUSH
67540: LD_VAR 0 5
67544: PPUSH
67545: CALL_OW 74
67549: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67550: LD_ADDR_VAR 0 8
67554: PUSH
67555: LD_EXP 102
67559: PUSH
67560: LD_VAR 0 1
67564: ARRAY
67565: PPUSH
67566: LD_INT 2
67568: PUSH
67569: LD_INT 30
67571: PUSH
67572: LD_INT 0
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: PUSH
67579: LD_INT 30
67581: PUSH
67582: LD_INT 1
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: LIST
67593: PPUSH
67594: CALL_OW 72
67598: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67599: LD_ADDR_VAR 0 17
67603: PUSH
67604: LD_VAR 0 8
67608: NOT
67609: PUSH
67610: LD_VAR 0 8
67614: PPUSH
67615: LD_INT 3
67617: PUSH
67618: LD_INT 24
67620: PUSH
67621: LD_INT 600
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: EMPTY
67629: LIST
67630: LIST
67631: PPUSH
67632: CALL_OW 72
67636: OR
67637: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67638: LD_VAR 0 5
67642: PPUSH
67643: CALL_OW 247
67647: PUSH
67648: LD_INT 2
67650: DOUBLE
67651: EQUAL
67652: IFTRUE 67656
67654: GO 68052
67656: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67657: LD_VAR 0 5
67661: PPUSH
67662: CALL_OW 256
67666: PUSH
67667: LD_INT 650
67669: GREATER
67670: PUSH
67671: LD_VAR 0 5
67675: PPUSH
67676: LD_VAR 0 14
67680: PPUSH
67681: CALL_OW 296
67685: PUSH
67686: LD_INT 40
67688: LESS
67689: PUSH
67690: LD_VAR 0 14
67694: PPUSH
67695: LD_EXP 127
67699: PUSH
67700: LD_VAR 0 1
67704: ARRAY
67705: PPUSH
67706: CALL_OW 308
67710: OR
67711: AND
67712: IFFALSE 67834
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67714: LD_VAR 0 5
67718: PPUSH
67719: CALL_OW 262
67723: PUSH
67724: LD_INT 1
67726: EQUAL
67727: PUSH
67728: LD_VAR 0 5
67732: PPUSH
67733: CALL_OW 261
67737: PUSH
67738: LD_INT 30
67740: LESS
67741: AND
67742: PUSH
67743: LD_VAR 0 8
67747: AND
67748: IFFALSE 67818
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67750: LD_VAR 0 5
67754: PPUSH
67755: LD_VAR 0 8
67759: PPUSH
67760: LD_VAR 0 5
67764: PPUSH
67765: CALL_OW 74
67769: PPUSH
67770: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67774: LD_VAR 0 5
67778: PPUSH
67779: LD_VAR 0 8
67783: PPUSH
67784: LD_VAR 0 5
67788: PPUSH
67789: CALL_OW 74
67793: PPUSH
67794: CALL_OW 296
67798: PUSH
67799: LD_INT 6
67801: LESS
67802: IFFALSE 67816
// SetFuel ( i , 100 ) ;
67804: LD_VAR 0 5
67808: PPUSH
67809: LD_INT 100
67811: PPUSH
67812: CALL_OW 240
// end else
67816: GO 67832
// ComAttackUnit ( i , e ) ;
67818: LD_VAR 0 5
67822: PPUSH
67823: LD_VAR 0 14
67827: PPUSH
67828: CALL_OW 115
// end else
67832: GO 67935
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67834: LD_VAR 0 14
67838: PPUSH
67839: LD_EXP 127
67843: PUSH
67844: LD_VAR 0 1
67848: ARRAY
67849: PPUSH
67850: CALL_OW 308
67854: NOT
67855: PUSH
67856: LD_VAR 0 5
67860: PPUSH
67861: LD_VAR 0 14
67865: PPUSH
67866: CALL_OW 296
67870: PUSH
67871: LD_INT 40
67873: GREATEREQUAL
67874: AND
67875: PUSH
67876: LD_VAR 0 5
67880: PPUSH
67881: CALL_OW 256
67885: PUSH
67886: LD_INT 650
67888: LESSEQUAL
67889: OR
67890: PUSH
67891: LD_VAR 0 5
67895: PPUSH
67896: LD_EXP 126
67900: PUSH
67901: LD_VAR 0 1
67905: ARRAY
67906: PPUSH
67907: CALL_OW 308
67911: NOT
67912: AND
67913: IFFALSE 67935
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67915: LD_VAR 0 5
67919: PPUSH
67920: LD_EXP 126
67924: PUSH
67925: LD_VAR 0 1
67929: ARRAY
67930: PPUSH
67931: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67935: LD_VAR 0 5
67939: PPUSH
67940: CALL_OW 256
67944: PUSH
67945: LD_INT 998
67947: LESS
67948: PUSH
67949: LD_VAR 0 5
67953: PPUSH
67954: CALL_OW 263
67958: PUSH
67959: LD_INT 1
67961: EQUAL
67962: AND
67963: PUSH
67964: LD_VAR 0 5
67968: PPUSH
67969: CALL_OW 311
67973: AND
67974: PUSH
67975: LD_VAR 0 5
67979: PPUSH
67980: LD_EXP 126
67984: PUSH
67985: LD_VAR 0 1
67989: ARRAY
67990: PPUSH
67991: CALL_OW 308
67995: AND
67996: IFFALSE 68050
// begin mech := IsDrivenBy ( i ) ;
67998: LD_ADDR_VAR 0 10
68002: PUSH
68003: LD_VAR 0 5
68007: PPUSH
68008: CALL_OW 311
68012: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
68013: LD_VAR 0 10
68017: PPUSH
68018: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
68022: LD_VAR 0 10
68026: PPUSH
68027: LD_VAR 0 5
68031: PPUSH
68032: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
68036: LD_VAR 0 10
68040: PPUSH
68041: LD_VAR 0 5
68045: PPUSH
68046: CALL_OW 180
// end ; end ; unit_human :
68050: GO 68317
68052: LD_INT 1
68054: DOUBLE
68055: EQUAL
68056: IFTRUE 68060
68058: GO 68316
68060: POP
// begin b := IsInUnit ( i ) ;
68061: LD_ADDR_VAR 0 19
68065: PUSH
68066: LD_VAR 0 5
68070: PPUSH
68071: CALL_OW 310
68075: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
68076: LD_ADDR_VAR 0 20
68080: PUSH
68081: LD_VAR 0 19
68085: NOT
68086: PUSH
68087: LD_VAR 0 19
68091: PPUSH
68092: CALL_OW 266
68096: PUSH
68097: LD_INT 32
68099: PUSH
68100: LD_INT 31
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: IN
68107: OR
68108: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
68109: LD_VAR 0 17
68113: PUSH
68114: LD_VAR 0 2
68118: PPUSH
68119: LD_INT 21
68121: PUSH
68122: LD_INT 2
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PPUSH
68129: CALL_OW 72
68133: PUSH
68134: LD_INT 1
68136: LESSEQUAL
68137: OR
68138: PUSH
68139: LD_VAR 0 20
68143: AND
68144: PUSH
68145: LD_VAR 0 5
68149: PUSH
68150: LD_VAR 0 18
68154: IN
68155: NOT
68156: AND
68157: IFFALSE 68250
// begin if b then
68159: LD_VAR 0 19
68163: IFFALSE 68212
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
68165: LD_VAR 0 19
68169: PPUSH
68170: LD_VAR 0 3
68174: PPUSH
68175: LD_VAR 0 19
68179: PPUSH
68180: CALL_OW 74
68184: PPUSH
68185: CALL_OW 296
68189: PUSH
68190: LD_INT 10
68192: LESS
68193: PUSH
68194: LD_VAR 0 19
68198: PPUSH
68199: CALL_OW 461
68203: PUSH
68204: LD_INT 7
68206: NONEQUAL
68207: AND
68208: IFFALSE 68212
// continue ;
68210: GO 67527
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
68212: LD_ADDR_VAR 0 18
68216: PUSH
68217: LD_VAR 0 18
68221: PPUSH
68222: LD_VAR 0 18
68226: PUSH
68227: LD_INT 1
68229: PLUS
68230: PPUSH
68231: LD_VAR 0 5
68235: PPUSH
68236: CALL_OW 1
68240: ST_TO_ADDR
// ComExitBuilding ( i ) ;
68241: LD_VAR 0 5
68245: PPUSH
68246: CALL_OW 122
// end ; if sold_defenders then
68250: LD_VAR 0 18
68254: IFFALSE 68314
// if i in sold_defenders then
68256: LD_VAR 0 5
68260: PUSH
68261: LD_VAR 0 18
68265: IN
68266: IFFALSE 68314
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
68268: LD_VAR 0 5
68272: PPUSH
68273: CALL_OW 314
68277: NOT
68278: PUSH
68279: LD_VAR 0 5
68283: PPUSH
68284: LD_VAR 0 14
68288: PPUSH
68289: CALL_OW 296
68293: PUSH
68294: LD_INT 30
68296: LESS
68297: AND
68298: IFFALSE 68314
// ComAttackUnit ( i , e ) ;
68300: LD_VAR 0 5
68304: PPUSH
68305: LD_VAR 0 14
68309: PPUSH
68310: CALL_OW 115
// end ; end ; end ;
68314: GO 68317
68316: POP
// if IsDead ( i ) then
68317: LD_VAR 0 5
68321: PPUSH
68322: CALL_OW 301
68326: IFFALSE 68344
// defenders := defenders diff i ;
68328: LD_ADDR_VAR 0 2
68332: PUSH
68333: LD_VAR 0 2
68337: PUSH
68338: LD_VAR 0 5
68342: DIFF
68343: ST_TO_ADDR
// end ;
68344: GO 67527
68346: POP
68347: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
68348: LD_VAR 0 3
68352: NOT
68353: PUSH
68354: LD_VAR 0 2
68358: NOT
68359: OR
68360: PUSH
68361: LD_EXP 102
68365: PUSH
68366: LD_VAR 0 1
68370: ARRAY
68371: NOT
68372: OR
68373: IFFALSE 67431
// MC_Reset ( base , 18 ) ;
68375: LD_VAR 0 1
68379: PPUSH
68380: LD_INT 18
68382: PPUSH
68383: CALL 38817 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68387: LD_ADDR_VAR 0 2
68391: PUSH
68392: LD_VAR 0 2
68396: PUSH
68397: LD_VAR 0 2
68401: PPUSH
68402: LD_INT 2
68404: PUSH
68405: LD_INT 25
68407: PUSH
68408: LD_INT 1
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: PUSH
68415: LD_INT 25
68417: PUSH
68418: LD_INT 5
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PUSH
68425: LD_INT 25
68427: PUSH
68428: LD_INT 8
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 25
68437: PUSH
68438: LD_INT 9
68440: PUSH
68441: EMPTY
68442: LIST
68443: LIST
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: PPUSH
68452: CALL_OW 72
68456: DIFF
68457: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68458: LD_VAR 0 3
68462: NOT
68463: PUSH
68464: LD_VAR 0 2
68468: PPUSH
68469: LD_INT 21
68471: PUSH
68472: LD_INT 2
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PPUSH
68479: CALL_OW 72
68483: AND
68484: IFFALSE 68822
// begin tmp := FilterByTag ( defenders , 19 ) ;
68486: LD_ADDR_VAR 0 12
68490: PUSH
68491: LD_VAR 0 2
68495: PPUSH
68496: LD_INT 19
68498: PPUSH
68499: CALL 105285 0 2
68503: ST_TO_ADDR
// if tmp then
68504: LD_VAR 0 12
68508: IFFALSE 68578
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68510: LD_ADDR_VAR 0 12
68514: PUSH
68515: LD_VAR 0 12
68519: PPUSH
68520: LD_INT 25
68522: PUSH
68523: LD_INT 3
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: PPUSH
68530: CALL_OW 72
68534: ST_TO_ADDR
// if tmp then
68535: LD_VAR 0 12
68539: IFFALSE 68578
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68541: LD_ADDR_EXP 114
68545: PUSH
68546: LD_EXP 114
68550: PPUSH
68551: LD_VAR 0 1
68555: PPUSH
68556: LD_EXP 114
68560: PUSH
68561: LD_VAR 0 1
68565: ARRAY
68566: PUSH
68567: LD_VAR 0 12
68571: UNION
68572: PPUSH
68573: CALL_OW 1
68577: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68578: LD_VAR 0 1
68582: PPUSH
68583: LD_INT 19
68585: PPUSH
68586: CALL 38817 0 2
// repeat wait ( 0 0$1 ) ;
68590: LD_INT 35
68592: PPUSH
68593: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68597: LD_EXP 102
68601: PUSH
68602: LD_VAR 0 1
68606: ARRAY
68607: NOT
68608: PUSH
68609: LD_EXP 102
68613: PUSH
68614: LD_VAR 0 1
68618: ARRAY
68619: PUSH
68620: EMPTY
68621: EQUAL
68622: OR
68623: IFFALSE 68660
// begin for i in defenders do
68625: LD_ADDR_VAR 0 5
68629: PUSH
68630: LD_VAR 0 2
68634: PUSH
68635: FOR_IN
68636: IFFALSE 68649
// ComStop ( i ) ;
68638: LD_VAR 0 5
68642: PPUSH
68643: CALL_OW 141
68647: GO 68635
68649: POP
68650: POP
// defenders := [ ] ;
68651: LD_ADDR_VAR 0 2
68655: PUSH
68656: EMPTY
68657: ST_TO_ADDR
// exit ;
68658: GO 68846
// end ; for i in defenders do
68660: LD_ADDR_VAR 0 5
68664: PUSH
68665: LD_VAR 0 2
68669: PUSH
68670: FOR_IN
68671: IFFALSE 68760
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68673: LD_VAR 0 5
68677: PPUSH
68678: LD_EXP 126
68682: PUSH
68683: LD_VAR 0 1
68687: ARRAY
68688: PPUSH
68689: CALL_OW 308
68693: NOT
68694: IFFALSE 68718
// ComMoveToArea ( i , mc_parking [ base ] ) else
68696: LD_VAR 0 5
68700: PPUSH
68701: LD_EXP 126
68705: PUSH
68706: LD_VAR 0 1
68710: ARRAY
68711: PPUSH
68712: CALL_OW 113
68716: GO 68758
// if GetControl ( i ) = control_manual then
68718: LD_VAR 0 5
68722: PPUSH
68723: CALL_OW 263
68727: PUSH
68728: LD_INT 1
68730: EQUAL
68731: IFFALSE 68758
// if IsDrivenBy ( i ) then
68733: LD_VAR 0 5
68737: PPUSH
68738: CALL_OW 311
68742: IFFALSE 68758
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68744: LD_VAR 0 5
68748: PPUSH
68749: CALL_OW 311
68753: PPUSH
68754: CALL_OW 121
// end ;
68758: GO 68670
68760: POP
68761: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68762: LD_VAR 0 2
68766: PPUSH
68767: LD_INT 95
68769: PUSH
68770: LD_EXP 126
68774: PUSH
68775: LD_VAR 0 1
68779: ARRAY
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PPUSH
68785: CALL_OW 72
68789: PUSH
68790: LD_VAR 0 2
68794: EQUAL
68795: PUSH
68796: LD_EXP 125
68800: PUSH
68801: LD_VAR 0 1
68805: ARRAY
68806: OR
68807: PUSH
68808: LD_EXP 102
68812: PUSH
68813: LD_VAR 0 1
68817: ARRAY
68818: NOT
68819: OR
68820: IFFALSE 68590
// end ; MC_Reset ( base , 19 ) ;
68822: LD_VAR 0 1
68826: PPUSH
68827: LD_INT 19
68829: PPUSH
68830: CALL 38817 0 2
// MC_Reset ( base , 20 ) ;
68834: LD_VAR 0 1
68838: PPUSH
68839: LD_INT 20
68841: PPUSH
68842: CALL 38817 0 2
// end ;
68846: LD_VAR 0 4
68850: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68851: LD_INT 0
68853: PPUSH
68854: PPUSH
68855: PPUSH
68856: PPUSH
// result := false ;
68857: LD_ADDR_VAR 0 2
68861: PUSH
68862: LD_INT 0
68864: ST_TO_ADDR
// side := GetSide ( unit ) ;
68865: LD_ADDR_VAR 0 3
68869: PUSH
68870: LD_VAR 0 1
68874: PPUSH
68875: CALL_OW 255
68879: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68880: LD_ADDR_VAR 0 4
68884: PUSH
68885: LD_VAR 0 1
68889: PPUSH
68890: CALL_OW 248
68894: ST_TO_ADDR
// case nat of 1 :
68895: LD_VAR 0 4
68899: PUSH
68900: LD_INT 1
68902: DOUBLE
68903: EQUAL
68904: IFTRUE 68908
68906: GO 68919
68908: POP
// tech := tech_lassight ; 2 :
68909: LD_ADDR_VAR 0 5
68913: PUSH
68914: LD_INT 12
68916: ST_TO_ADDR
68917: GO 68958
68919: LD_INT 2
68921: DOUBLE
68922: EQUAL
68923: IFTRUE 68927
68925: GO 68938
68927: POP
// tech := tech_mortar ; 3 :
68928: LD_ADDR_VAR 0 5
68932: PUSH
68933: LD_INT 41
68935: ST_TO_ADDR
68936: GO 68958
68938: LD_INT 3
68940: DOUBLE
68941: EQUAL
68942: IFTRUE 68946
68944: GO 68957
68946: POP
// tech := tech_bazooka ; end ;
68947: LD_ADDR_VAR 0 5
68951: PUSH
68952: LD_INT 44
68954: ST_TO_ADDR
68955: GO 68958
68957: POP
// if Researched ( side , tech ) then
68958: LD_VAR 0 3
68962: PPUSH
68963: LD_VAR 0 5
68967: PPUSH
68968: CALL_OW 325
68972: IFFALSE 68999
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68974: LD_ADDR_VAR 0 2
68978: PUSH
68979: LD_INT 5
68981: PUSH
68982: LD_INT 8
68984: PUSH
68985: LD_INT 9
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: LIST
68992: PUSH
68993: LD_VAR 0 4
68997: ARRAY
68998: ST_TO_ADDR
// end ;
68999: LD_VAR 0 2
69003: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69004: LD_INT 0
69006: PPUSH
69007: PPUSH
69008: PPUSH
// if not mines then
69009: LD_VAR 0 2
69013: NOT
69014: IFFALSE 69018
// exit ;
69016: GO 69162
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69018: LD_ADDR_VAR 0 5
69022: PUSH
69023: LD_INT 81
69025: PUSH
69026: LD_VAR 0 1
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 3
69037: PUSH
69038: LD_INT 21
69040: PUSH
69041: LD_INT 3
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PPUSH
69056: CALL_OW 69
69060: ST_TO_ADDR
// for i in mines do
69061: LD_ADDR_VAR 0 4
69065: PUSH
69066: LD_VAR 0 2
69070: PUSH
69071: FOR_IN
69072: IFFALSE 69160
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69074: LD_VAR 0 4
69078: PUSH
69079: LD_INT 1
69081: ARRAY
69082: PPUSH
69083: LD_VAR 0 4
69087: PUSH
69088: LD_INT 2
69090: ARRAY
69091: PPUSH
69092: CALL_OW 458
69096: NOT
69097: IFFALSE 69101
// continue ;
69099: GO 69071
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69101: LD_VAR 0 4
69105: PUSH
69106: LD_INT 1
69108: ARRAY
69109: PPUSH
69110: LD_VAR 0 4
69114: PUSH
69115: LD_INT 2
69117: ARRAY
69118: PPUSH
69119: CALL_OW 428
69123: PUSH
69124: LD_VAR 0 5
69128: IN
69129: IFFALSE 69158
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69131: LD_VAR 0 4
69135: PUSH
69136: LD_INT 1
69138: ARRAY
69139: PPUSH
69140: LD_VAR 0 4
69144: PUSH
69145: LD_INT 2
69147: ARRAY
69148: PPUSH
69149: LD_VAR 0 1
69153: PPUSH
69154: CALL_OW 456
// end ;
69158: GO 69071
69160: POP
69161: POP
// end ;
69162: LD_VAR 0 3
69166: RET
// export function Count ( array ) ; var i ; begin
69167: LD_INT 0
69169: PPUSH
69170: PPUSH
// result := 0 ;
69171: LD_ADDR_VAR 0 2
69175: PUSH
69176: LD_INT 0
69178: ST_TO_ADDR
// for i in array do
69179: LD_ADDR_VAR 0 3
69183: PUSH
69184: LD_VAR 0 1
69188: PUSH
69189: FOR_IN
69190: IFFALSE 69214
// if i then
69192: LD_VAR 0 3
69196: IFFALSE 69212
// result := result + 1 ;
69198: LD_ADDR_VAR 0 2
69202: PUSH
69203: LD_VAR 0 2
69207: PUSH
69208: LD_INT 1
69210: PLUS
69211: ST_TO_ADDR
69212: GO 69189
69214: POP
69215: POP
// end ;
69216: LD_VAR 0 2
69220: RET
// export function IsEmpty ( building ) ; begin
69221: LD_INT 0
69223: PPUSH
// if not building then
69224: LD_VAR 0 1
69228: NOT
69229: IFFALSE 69233
// exit ;
69231: GO 69276
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69233: LD_ADDR_VAR 0 2
69237: PUSH
69238: LD_VAR 0 1
69242: PUSH
69243: LD_INT 22
69245: PUSH
69246: LD_VAR 0 1
69250: PPUSH
69251: CALL_OW 255
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 58
69262: PUSH
69263: EMPTY
69264: LIST
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PPUSH
69270: CALL_OW 69
69274: IN
69275: ST_TO_ADDR
// end ;
69276: LD_VAR 0 2
69280: RET
// export function IsNotFull ( building ) ; begin
69281: LD_INT 0
69283: PPUSH
// if not building then
69284: LD_VAR 0 1
69288: NOT
69289: IFFALSE 69293
// exit ;
69291: GO 69312
// result := UnitsInside ( building ) < 6 ;
69293: LD_ADDR_VAR 0 2
69297: PUSH
69298: LD_VAR 0 1
69302: PPUSH
69303: CALL_OW 313
69307: PUSH
69308: LD_INT 6
69310: LESS
69311: ST_TO_ADDR
// end ;
69312: LD_VAR 0 2
69316: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69317: LD_INT 0
69319: PPUSH
69320: PPUSH
69321: PPUSH
69322: PPUSH
// tmp := [ ] ;
69323: LD_ADDR_VAR 0 3
69327: PUSH
69328: EMPTY
69329: ST_TO_ADDR
// list := [ ] ;
69330: LD_ADDR_VAR 0 5
69334: PUSH
69335: EMPTY
69336: ST_TO_ADDR
// for i = 16 to 25 do
69337: LD_ADDR_VAR 0 4
69341: PUSH
69342: DOUBLE
69343: LD_INT 16
69345: DEC
69346: ST_TO_ADDR
69347: LD_INT 25
69349: PUSH
69350: FOR_TO
69351: IFFALSE 69424
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69353: LD_ADDR_VAR 0 3
69357: PUSH
69358: LD_VAR 0 3
69362: PUSH
69363: LD_INT 22
69365: PUSH
69366: LD_VAR 0 1
69370: PPUSH
69371: CALL_OW 255
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: PUSH
69380: LD_INT 91
69382: PUSH
69383: LD_VAR 0 1
69387: PUSH
69388: LD_INT 6
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: LIST
69395: PUSH
69396: LD_INT 30
69398: PUSH
69399: LD_VAR 0 4
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: LIST
69412: PUSH
69413: EMPTY
69414: LIST
69415: PPUSH
69416: CALL_OW 69
69420: ADD
69421: ST_TO_ADDR
69422: GO 69350
69424: POP
69425: POP
// for i = 1 to tmp do
69426: LD_ADDR_VAR 0 4
69430: PUSH
69431: DOUBLE
69432: LD_INT 1
69434: DEC
69435: ST_TO_ADDR
69436: LD_VAR 0 3
69440: PUSH
69441: FOR_TO
69442: IFFALSE 69530
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69444: LD_ADDR_VAR 0 5
69448: PUSH
69449: LD_VAR 0 5
69453: PUSH
69454: LD_VAR 0 3
69458: PUSH
69459: LD_VAR 0 4
69463: ARRAY
69464: PPUSH
69465: CALL_OW 266
69469: PUSH
69470: LD_VAR 0 3
69474: PUSH
69475: LD_VAR 0 4
69479: ARRAY
69480: PPUSH
69481: CALL_OW 250
69485: PUSH
69486: LD_VAR 0 3
69490: PUSH
69491: LD_VAR 0 4
69495: ARRAY
69496: PPUSH
69497: CALL_OW 251
69501: PUSH
69502: LD_VAR 0 3
69506: PUSH
69507: LD_VAR 0 4
69511: ARRAY
69512: PPUSH
69513: CALL_OW 254
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: PUSH
69524: EMPTY
69525: LIST
69526: ADD
69527: ST_TO_ADDR
69528: GO 69441
69530: POP
69531: POP
// result := list ;
69532: LD_ADDR_VAR 0 2
69536: PUSH
69537: LD_VAR 0 5
69541: ST_TO_ADDR
// end ;
69542: LD_VAR 0 2
69546: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69547: LD_INT 0
69549: PPUSH
69550: PPUSH
69551: PPUSH
69552: PPUSH
69553: PPUSH
69554: PPUSH
69555: PPUSH
// if not factory then
69556: LD_VAR 0 1
69560: NOT
69561: IFFALSE 69565
// exit ;
69563: GO 70158
// if control = control_apeman then
69565: LD_VAR 0 4
69569: PUSH
69570: LD_INT 5
69572: EQUAL
69573: IFFALSE 69682
// begin tmp := UnitsInside ( factory ) ;
69575: LD_ADDR_VAR 0 8
69579: PUSH
69580: LD_VAR 0 1
69584: PPUSH
69585: CALL_OW 313
69589: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69590: LD_VAR 0 8
69594: PPUSH
69595: LD_INT 25
69597: PUSH
69598: LD_INT 12
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PPUSH
69605: CALL_OW 72
69609: NOT
69610: IFFALSE 69620
// control := control_manual ;
69612: LD_ADDR_VAR 0 4
69616: PUSH
69617: LD_INT 1
69619: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69620: LD_ADDR_VAR 0 8
69624: PUSH
69625: LD_VAR 0 1
69629: PPUSH
69630: CALL 69317 0 1
69634: ST_TO_ADDR
// if tmp then
69635: LD_VAR 0 8
69639: IFFALSE 69682
// begin for i in tmp do
69641: LD_ADDR_VAR 0 7
69645: PUSH
69646: LD_VAR 0 8
69650: PUSH
69651: FOR_IN
69652: IFFALSE 69680
// if i [ 1 ] = b_ext_radio then
69654: LD_VAR 0 7
69658: PUSH
69659: LD_INT 1
69661: ARRAY
69662: PUSH
69663: LD_INT 22
69665: EQUAL
69666: IFFALSE 69678
// begin control := control_remote ;
69668: LD_ADDR_VAR 0 4
69672: PUSH
69673: LD_INT 2
69675: ST_TO_ADDR
// break ;
69676: GO 69680
// end ;
69678: GO 69651
69680: POP
69681: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69682: LD_VAR 0 1
69686: PPUSH
69687: LD_VAR 0 2
69691: PPUSH
69692: LD_VAR 0 3
69696: PPUSH
69697: LD_VAR 0 4
69701: PPUSH
69702: LD_VAR 0 5
69706: PPUSH
69707: CALL_OW 448
69711: IFFALSE 69746
// begin result := [ chassis , engine , control , weapon ] ;
69713: LD_ADDR_VAR 0 6
69717: PUSH
69718: LD_VAR 0 2
69722: PUSH
69723: LD_VAR 0 3
69727: PUSH
69728: LD_VAR 0 4
69732: PUSH
69733: LD_VAR 0 5
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: ST_TO_ADDR
// exit ;
69744: GO 70158
// end ; _chassis := AvailableChassisList ( factory ) ;
69746: LD_ADDR_VAR 0 9
69750: PUSH
69751: LD_VAR 0 1
69755: PPUSH
69756: CALL_OW 475
69760: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69761: LD_ADDR_VAR 0 11
69765: PUSH
69766: LD_VAR 0 1
69770: PPUSH
69771: CALL_OW 476
69775: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69776: LD_ADDR_VAR 0 12
69780: PUSH
69781: LD_VAR 0 1
69785: PPUSH
69786: CALL_OW 477
69790: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69791: LD_ADDR_VAR 0 10
69795: PUSH
69796: LD_VAR 0 1
69800: PPUSH
69801: CALL_OW 478
69805: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69806: LD_VAR 0 9
69810: NOT
69811: PUSH
69812: LD_VAR 0 11
69816: NOT
69817: OR
69818: PUSH
69819: LD_VAR 0 12
69823: NOT
69824: OR
69825: PUSH
69826: LD_VAR 0 10
69830: NOT
69831: OR
69832: IFFALSE 69867
// begin result := [ chassis , engine , control , weapon ] ;
69834: LD_ADDR_VAR 0 6
69838: PUSH
69839: LD_VAR 0 2
69843: PUSH
69844: LD_VAR 0 3
69848: PUSH
69849: LD_VAR 0 4
69853: PUSH
69854: LD_VAR 0 5
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: ST_TO_ADDR
// exit ;
69865: GO 70158
// end ; if not chassis in _chassis then
69867: LD_VAR 0 2
69871: PUSH
69872: LD_VAR 0 9
69876: IN
69877: NOT
69878: IFFALSE 69904
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69880: LD_ADDR_VAR 0 2
69884: PUSH
69885: LD_VAR 0 9
69889: PUSH
69890: LD_INT 1
69892: PPUSH
69893: LD_VAR 0 9
69897: PPUSH
69898: CALL_OW 12
69902: ARRAY
69903: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69904: LD_VAR 0 2
69908: PPUSH
69909: LD_VAR 0 3
69913: PPUSH
69914: CALL 70163 0 2
69918: NOT
69919: IFFALSE 69978
// repeat engine := _engine [ 1 ] ;
69921: LD_ADDR_VAR 0 3
69925: PUSH
69926: LD_VAR 0 11
69930: PUSH
69931: LD_INT 1
69933: ARRAY
69934: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69935: LD_ADDR_VAR 0 11
69939: PUSH
69940: LD_VAR 0 11
69944: PPUSH
69945: LD_INT 1
69947: PPUSH
69948: CALL_OW 3
69952: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69953: LD_VAR 0 2
69957: PPUSH
69958: LD_VAR 0 3
69962: PPUSH
69963: CALL 70163 0 2
69967: PUSH
69968: LD_VAR 0 11
69972: PUSH
69973: EMPTY
69974: EQUAL
69975: OR
69976: IFFALSE 69921
// if not control in _control then
69978: LD_VAR 0 4
69982: PUSH
69983: LD_VAR 0 12
69987: IN
69988: NOT
69989: IFFALSE 70015
// control := _control [ rand ( 1 , _control ) ] ;
69991: LD_ADDR_VAR 0 4
69995: PUSH
69996: LD_VAR 0 12
70000: PUSH
70001: LD_INT 1
70003: PPUSH
70004: LD_VAR 0 12
70008: PPUSH
70009: CALL_OW 12
70013: ARRAY
70014: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70015: LD_VAR 0 2
70019: PPUSH
70020: LD_VAR 0 5
70024: PPUSH
70025: CALL 70383 0 2
70029: NOT
70030: IFFALSE 70089
// repeat weapon := _weapon [ 1 ] ;
70032: LD_ADDR_VAR 0 5
70036: PUSH
70037: LD_VAR 0 10
70041: PUSH
70042: LD_INT 1
70044: ARRAY
70045: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70046: LD_ADDR_VAR 0 10
70050: PUSH
70051: LD_VAR 0 10
70055: PPUSH
70056: LD_INT 1
70058: PPUSH
70059: CALL_OW 3
70063: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70064: LD_VAR 0 2
70068: PPUSH
70069: LD_VAR 0 5
70073: PPUSH
70074: CALL 70383 0 2
70078: PUSH
70079: LD_VAR 0 10
70083: PUSH
70084: EMPTY
70085: EQUAL
70086: OR
70087: IFFALSE 70032
// result := [ ] ;
70089: LD_ADDR_VAR 0 6
70093: PUSH
70094: EMPTY
70095: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70096: LD_VAR 0 1
70100: PPUSH
70101: LD_VAR 0 2
70105: PPUSH
70106: LD_VAR 0 3
70110: PPUSH
70111: LD_VAR 0 4
70115: PPUSH
70116: LD_VAR 0 5
70120: PPUSH
70121: CALL_OW 448
70125: IFFALSE 70158
// result := [ chassis , engine , control , weapon ] ;
70127: LD_ADDR_VAR 0 6
70131: PUSH
70132: LD_VAR 0 2
70136: PUSH
70137: LD_VAR 0 3
70141: PUSH
70142: LD_VAR 0 4
70146: PUSH
70147: LD_VAR 0 5
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: LIST
70156: LIST
70157: ST_TO_ADDR
// end ;
70158: LD_VAR 0 6
70162: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70163: LD_INT 0
70165: PPUSH
// if not chassis or not engine then
70166: LD_VAR 0 1
70170: NOT
70171: PUSH
70172: LD_VAR 0 2
70176: NOT
70177: OR
70178: IFFALSE 70182
// exit ;
70180: GO 70378
// case engine of engine_solar :
70182: LD_VAR 0 2
70186: PUSH
70187: LD_INT 2
70189: DOUBLE
70190: EQUAL
70191: IFTRUE 70195
70193: GO 70233
70195: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70196: LD_ADDR_VAR 0 3
70200: PUSH
70201: LD_INT 11
70203: PUSH
70204: LD_INT 12
70206: PUSH
70207: LD_INT 13
70209: PUSH
70210: LD_INT 14
70212: PUSH
70213: LD_INT 1
70215: PUSH
70216: LD_INT 2
70218: PUSH
70219: LD_INT 3
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: ST_TO_ADDR
70231: GO 70362
70233: LD_INT 1
70235: DOUBLE
70236: EQUAL
70237: IFTRUE 70241
70239: GO 70303
70241: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70242: LD_ADDR_VAR 0 3
70246: PUSH
70247: LD_INT 11
70249: PUSH
70250: LD_INT 12
70252: PUSH
70253: LD_INT 13
70255: PUSH
70256: LD_INT 14
70258: PUSH
70259: LD_INT 1
70261: PUSH
70262: LD_INT 2
70264: PUSH
70265: LD_INT 3
70267: PUSH
70268: LD_INT 4
70270: PUSH
70271: LD_INT 5
70273: PUSH
70274: LD_INT 21
70276: PUSH
70277: LD_INT 23
70279: PUSH
70280: LD_INT 22
70282: PUSH
70283: LD_INT 24
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: ST_TO_ADDR
70301: GO 70362
70303: LD_INT 3
70305: DOUBLE
70306: EQUAL
70307: IFTRUE 70311
70309: GO 70361
70311: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70312: LD_ADDR_VAR 0 3
70316: PUSH
70317: LD_INT 13
70319: PUSH
70320: LD_INT 14
70322: PUSH
70323: LD_INT 2
70325: PUSH
70326: LD_INT 3
70328: PUSH
70329: LD_INT 4
70331: PUSH
70332: LD_INT 5
70334: PUSH
70335: LD_INT 21
70337: PUSH
70338: LD_INT 22
70340: PUSH
70341: LD_INT 23
70343: PUSH
70344: LD_INT 24
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: LIST
70351: LIST
70352: LIST
70353: LIST
70354: LIST
70355: LIST
70356: LIST
70357: LIST
70358: ST_TO_ADDR
70359: GO 70362
70361: POP
// result := ( chassis in result ) ;
70362: LD_ADDR_VAR 0 3
70366: PUSH
70367: LD_VAR 0 1
70371: PUSH
70372: LD_VAR 0 3
70376: IN
70377: ST_TO_ADDR
// end ;
70378: LD_VAR 0 3
70382: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70383: LD_INT 0
70385: PPUSH
// if not chassis or not weapon then
70386: LD_VAR 0 1
70390: NOT
70391: PUSH
70392: LD_VAR 0 2
70396: NOT
70397: OR
70398: IFFALSE 70402
// exit ;
70400: GO 71428
// case weapon of us_machine_gun :
70402: LD_VAR 0 2
70406: PUSH
70407: LD_INT 2
70409: DOUBLE
70410: EQUAL
70411: IFTRUE 70415
70413: GO 70445
70415: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70416: LD_ADDR_VAR 0 3
70420: PUSH
70421: LD_INT 1
70423: PUSH
70424: LD_INT 2
70426: PUSH
70427: LD_INT 3
70429: PUSH
70430: LD_INT 4
70432: PUSH
70433: LD_INT 5
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: ST_TO_ADDR
70443: GO 71412
70445: LD_INT 3
70447: DOUBLE
70448: EQUAL
70449: IFTRUE 70453
70451: GO 70483
70453: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70454: LD_ADDR_VAR 0 3
70458: PUSH
70459: LD_INT 1
70461: PUSH
70462: LD_INT 2
70464: PUSH
70465: LD_INT 3
70467: PUSH
70468: LD_INT 4
70470: PUSH
70471: LD_INT 5
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: ST_TO_ADDR
70481: GO 71412
70483: LD_INT 11
70485: DOUBLE
70486: EQUAL
70487: IFTRUE 70491
70489: GO 70521
70491: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70492: LD_ADDR_VAR 0 3
70496: PUSH
70497: LD_INT 1
70499: PUSH
70500: LD_INT 2
70502: PUSH
70503: LD_INT 3
70505: PUSH
70506: LD_INT 4
70508: PUSH
70509: LD_INT 5
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: LIST
70516: LIST
70517: LIST
70518: ST_TO_ADDR
70519: GO 71412
70521: LD_INT 4
70523: DOUBLE
70524: EQUAL
70525: IFTRUE 70529
70527: GO 70555
70529: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70530: LD_ADDR_VAR 0 3
70534: PUSH
70535: LD_INT 2
70537: PUSH
70538: LD_INT 3
70540: PUSH
70541: LD_INT 4
70543: PUSH
70544: LD_INT 5
70546: PUSH
70547: EMPTY
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: ST_TO_ADDR
70553: GO 71412
70555: LD_INT 5
70557: DOUBLE
70558: EQUAL
70559: IFTRUE 70563
70561: GO 70589
70563: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70564: LD_ADDR_VAR 0 3
70568: PUSH
70569: LD_INT 2
70571: PUSH
70572: LD_INT 3
70574: PUSH
70575: LD_INT 4
70577: PUSH
70578: LD_INT 5
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: ST_TO_ADDR
70587: GO 71412
70589: LD_INT 9
70591: DOUBLE
70592: EQUAL
70593: IFTRUE 70597
70595: GO 70623
70597: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70598: LD_ADDR_VAR 0 3
70602: PUSH
70603: LD_INT 2
70605: PUSH
70606: LD_INT 3
70608: PUSH
70609: LD_INT 4
70611: PUSH
70612: LD_INT 5
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: ST_TO_ADDR
70621: GO 71412
70623: LD_INT 7
70625: DOUBLE
70626: EQUAL
70627: IFTRUE 70631
70629: GO 70657
70631: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70632: LD_ADDR_VAR 0 3
70636: PUSH
70637: LD_INT 2
70639: PUSH
70640: LD_INT 3
70642: PUSH
70643: LD_INT 4
70645: PUSH
70646: LD_INT 5
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: LIST
70653: LIST
70654: ST_TO_ADDR
70655: GO 71412
70657: LD_INT 12
70659: DOUBLE
70660: EQUAL
70661: IFTRUE 70665
70663: GO 70691
70665: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70666: LD_ADDR_VAR 0 3
70670: PUSH
70671: LD_INT 2
70673: PUSH
70674: LD_INT 3
70676: PUSH
70677: LD_INT 4
70679: PUSH
70680: LD_INT 5
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: ST_TO_ADDR
70689: GO 71412
70691: LD_INT 13
70693: DOUBLE
70694: EQUAL
70695: IFTRUE 70699
70697: GO 70725
70699: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70700: LD_ADDR_VAR 0 3
70704: PUSH
70705: LD_INT 2
70707: PUSH
70708: LD_INT 3
70710: PUSH
70711: LD_INT 4
70713: PUSH
70714: LD_INT 5
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: ST_TO_ADDR
70723: GO 71412
70725: LD_INT 14
70727: DOUBLE
70728: EQUAL
70729: IFTRUE 70733
70731: GO 70751
70733: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70734: LD_ADDR_VAR 0 3
70738: PUSH
70739: LD_INT 4
70741: PUSH
70742: LD_INT 5
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: ST_TO_ADDR
70749: GO 71412
70751: LD_INT 6
70753: DOUBLE
70754: EQUAL
70755: IFTRUE 70759
70757: GO 70777
70759: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70760: LD_ADDR_VAR 0 3
70764: PUSH
70765: LD_INT 4
70767: PUSH
70768: LD_INT 5
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: ST_TO_ADDR
70775: GO 71412
70777: LD_INT 10
70779: DOUBLE
70780: EQUAL
70781: IFTRUE 70785
70783: GO 70803
70785: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70786: LD_ADDR_VAR 0 3
70790: PUSH
70791: LD_INT 4
70793: PUSH
70794: LD_INT 5
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: ST_TO_ADDR
70801: GO 71412
70803: LD_INT 22
70805: DOUBLE
70806: EQUAL
70807: IFTRUE 70811
70809: GO 70837
70811: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70812: LD_ADDR_VAR 0 3
70816: PUSH
70817: LD_INT 11
70819: PUSH
70820: LD_INT 12
70822: PUSH
70823: LD_INT 13
70825: PUSH
70826: LD_INT 14
70828: PUSH
70829: EMPTY
70830: LIST
70831: LIST
70832: LIST
70833: LIST
70834: ST_TO_ADDR
70835: GO 71412
70837: LD_INT 23
70839: DOUBLE
70840: EQUAL
70841: IFTRUE 70845
70843: GO 70871
70845: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70846: LD_ADDR_VAR 0 3
70850: PUSH
70851: LD_INT 11
70853: PUSH
70854: LD_INT 12
70856: PUSH
70857: LD_INT 13
70859: PUSH
70860: LD_INT 14
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: LIST
70867: LIST
70868: ST_TO_ADDR
70869: GO 71412
70871: LD_INT 24
70873: DOUBLE
70874: EQUAL
70875: IFTRUE 70879
70877: GO 70905
70879: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70880: LD_ADDR_VAR 0 3
70884: PUSH
70885: LD_INT 11
70887: PUSH
70888: LD_INT 12
70890: PUSH
70891: LD_INT 13
70893: PUSH
70894: LD_INT 14
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: ST_TO_ADDR
70903: GO 71412
70905: LD_INT 30
70907: DOUBLE
70908: EQUAL
70909: IFTRUE 70913
70911: GO 70939
70913: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70914: LD_ADDR_VAR 0 3
70918: PUSH
70919: LD_INT 11
70921: PUSH
70922: LD_INT 12
70924: PUSH
70925: LD_INT 13
70927: PUSH
70928: LD_INT 14
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: ST_TO_ADDR
70937: GO 71412
70939: LD_INT 25
70941: DOUBLE
70942: EQUAL
70943: IFTRUE 70947
70945: GO 70965
70947: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70948: LD_ADDR_VAR 0 3
70952: PUSH
70953: LD_INT 13
70955: PUSH
70956: LD_INT 14
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: ST_TO_ADDR
70963: GO 71412
70965: LD_INT 27
70967: DOUBLE
70968: EQUAL
70969: IFTRUE 70973
70971: GO 70991
70973: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70974: LD_ADDR_VAR 0 3
70978: PUSH
70979: LD_INT 13
70981: PUSH
70982: LD_INT 14
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: ST_TO_ADDR
70989: GO 71412
70991: LD_INT 28
70993: DOUBLE
70994: EQUAL
70995: IFTRUE 70999
70997: GO 71017
70999: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71000: LD_ADDR_VAR 0 3
71004: PUSH
71005: LD_INT 13
71007: PUSH
71008: LD_INT 14
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: ST_TO_ADDR
71015: GO 71412
71017: LD_INT 29
71019: DOUBLE
71020: EQUAL
71021: IFTRUE 71025
71023: GO 71043
71025: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71026: LD_ADDR_VAR 0 3
71030: PUSH
71031: LD_INT 13
71033: PUSH
71034: LD_INT 14
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: ST_TO_ADDR
71041: GO 71412
71043: LD_INT 31
71045: DOUBLE
71046: EQUAL
71047: IFTRUE 71051
71049: GO 71069
71051: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71052: LD_ADDR_VAR 0 3
71056: PUSH
71057: LD_INT 13
71059: PUSH
71060: LD_INT 14
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: ST_TO_ADDR
71067: GO 71412
71069: LD_INT 26
71071: DOUBLE
71072: EQUAL
71073: IFTRUE 71077
71075: GO 71095
71077: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71078: LD_ADDR_VAR 0 3
71082: PUSH
71083: LD_INT 13
71085: PUSH
71086: LD_INT 14
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: ST_TO_ADDR
71093: GO 71412
71095: LD_INT 42
71097: DOUBLE
71098: EQUAL
71099: IFTRUE 71103
71101: GO 71129
71103: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71104: LD_ADDR_VAR 0 3
71108: PUSH
71109: LD_INT 21
71111: PUSH
71112: LD_INT 22
71114: PUSH
71115: LD_INT 23
71117: PUSH
71118: LD_INT 24
71120: PUSH
71121: EMPTY
71122: LIST
71123: LIST
71124: LIST
71125: LIST
71126: ST_TO_ADDR
71127: GO 71412
71129: LD_INT 43
71131: DOUBLE
71132: EQUAL
71133: IFTRUE 71137
71135: GO 71163
71137: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71138: LD_ADDR_VAR 0 3
71142: PUSH
71143: LD_INT 21
71145: PUSH
71146: LD_INT 22
71148: PUSH
71149: LD_INT 23
71151: PUSH
71152: LD_INT 24
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: ST_TO_ADDR
71161: GO 71412
71163: LD_INT 44
71165: DOUBLE
71166: EQUAL
71167: IFTRUE 71171
71169: GO 71197
71171: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71172: LD_ADDR_VAR 0 3
71176: PUSH
71177: LD_INT 21
71179: PUSH
71180: LD_INT 22
71182: PUSH
71183: LD_INT 23
71185: PUSH
71186: LD_INT 24
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: LIST
71193: LIST
71194: ST_TO_ADDR
71195: GO 71412
71197: LD_INT 45
71199: DOUBLE
71200: EQUAL
71201: IFTRUE 71205
71203: GO 71231
71205: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71206: LD_ADDR_VAR 0 3
71210: PUSH
71211: LD_INT 21
71213: PUSH
71214: LD_INT 22
71216: PUSH
71217: LD_INT 23
71219: PUSH
71220: LD_INT 24
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: LIST
71227: LIST
71228: ST_TO_ADDR
71229: GO 71412
71231: LD_INT 49
71233: DOUBLE
71234: EQUAL
71235: IFTRUE 71239
71237: GO 71265
71239: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71240: LD_ADDR_VAR 0 3
71244: PUSH
71245: LD_INT 21
71247: PUSH
71248: LD_INT 22
71250: PUSH
71251: LD_INT 23
71253: PUSH
71254: LD_INT 24
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: ST_TO_ADDR
71263: GO 71412
71265: LD_INT 51
71267: DOUBLE
71268: EQUAL
71269: IFTRUE 71273
71271: GO 71299
71273: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71274: LD_ADDR_VAR 0 3
71278: PUSH
71279: LD_INT 21
71281: PUSH
71282: LD_INT 22
71284: PUSH
71285: LD_INT 23
71287: PUSH
71288: LD_INT 24
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: ST_TO_ADDR
71297: GO 71412
71299: LD_INT 52
71301: DOUBLE
71302: EQUAL
71303: IFTRUE 71307
71305: GO 71333
71307: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71308: LD_ADDR_VAR 0 3
71312: PUSH
71313: LD_INT 21
71315: PUSH
71316: LD_INT 22
71318: PUSH
71319: LD_INT 23
71321: PUSH
71322: LD_INT 24
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: ST_TO_ADDR
71331: GO 71412
71333: LD_INT 53
71335: DOUBLE
71336: EQUAL
71337: IFTRUE 71341
71339: GO 71359
71341: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71342: LD_ADDR_VAR 0 3
71346: PUSH
71347: LD_INT 23
71349: PUSH
71350: LD_INT 24
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: ST_TO_ADDR
71357: GO 71412
71359: LD_INT 46
71361: DOUBLE
71362: EQUAL
71363: IFTRUE 71367
71365: GO 71385
71367: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71368: LD_ADDR_VAR 0 3
71372: PUSH
71373: LD_INT 23
71375: PUSH
71376: LD_INT 24
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: ST_TO_ADDR
71383: GO 71412
71385: LD_INT 47
71387: DOUBLE
71388: EQUAL
71389: IFTRUE 71393
71391: GO 71411
71393: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71394: LD_ADDR_VAR 0 3
71398: PUSH
71399: LD_INT 23
71401: PUSH
71402: LD_INT 24
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: ST_TO_ADDR
71409: GO 71412
71411: POP
// result := ( chassis in result ) ;
71412: LD_ADDR_VAR 0 3
71416: PUSH
71417: LD_VAR 0 1
71421: PUSH
71422: LD_VAR 0 3
71426: IN
71427: ST_TO_ADDR
// end ;
71428: LD_VAR 0 3
71432: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71433: LD_INT 0
71435: PPUSH
71436: PPUSH
71437: PPUSH
71438: PPUSH
71439: PPUSH
71440: PPUSH
71441: PPUSH
// result := array ;
71442: LD_ADDR_VAR 0 5
71446: PUSH
71447: LD_VAR 0 1
71451: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71452: LD_VAR 0 1
71456: NOT
71457: PUSH
71458: LD_VAR 0 2
71462: NOT
71463: OR
71464: PUSH
71465: LD_VAR 0 3
71469: NOT
71470: OR
71471: PUSH
71472: LD_VAR 0 2
71476: PUSH
71477: LD_VAR 0 1
71481: GREATER
71482: OR
71483: PUSH
71484: LD_VAR 0 3
71488: PUSH
71489: LD_VAR 0 1
71493: GREATER
71494: OR
71495: IFFALSE 71499
// exit ;
71497: GO 71795
// if direction then
71499: LD_VAR 0 4
71503: IFFALSE 71567
// begin d := 1 ;
71505: LD_ADDR_VAR 0 9
71509: PUSH
71510: LD_INT 1
71512: ST_TO_ADDR
// if i_from > i_to then
71513: LD_VAR 0 2
71517: PUSH
71518: LD_VAR 0 3
71522: GREATER
71523: IFFALSE 71549
// length := ( array - i_from ) + i_to else
71525: LD_ADDR_VAR 0 11
71529: PUSH
71530: LD_VAR 0 1
71534: PUSH
71535: LD_VAR 0 2
71539: MINUS
71540: PUSH
71541: LD_VAR 0 3
71545: PLUS
71546: ST_TO_ADDR
71547: GO 71565
// length := i_to - i_from ;
71549: LD_ADDR_VAR 0 11
71553: PUSH
71554: LD_VAR 0 3
71558: PUSH
71559: LD_VAR 0 2
71563: MINUS
71564: ST_TO_ADDR
// end else
71565: GO 71628
// begin d := - 1 ;
71567: LD_ADDR_VAR 0 9
71571: PUSH
71572: LD_INT 1
71574: NEG
71575: ST_TO_ADDR
// if i_from > i_to then
71576: LD_VAR 0 2
71580: PUSH
71581: LD_VAR 0 3
71585: GREATER
71586: IFFALSE 71606
// length := i_from - i_to else
71588: LD_ADDR_VAR 0 11
71592: PUSH
71593: LD_VAR 0 2
71597: PUSH
71598: LD_VAR 0 3
71602: MINUS
71603: ST_TO_ADDR
71604: GO 71628
// length := ( array - i_to ) + i_from ;
71606: LD_ADDR_VAR 0 11
71610: PUSH
71611: LD_VAR 0 1
71615: PUSH
71616: LD_VAR 0 3
71620: MINUS
71621: PUSH
71622: LD_VAR 0 2
71626: PLUS
71627: ST_TO_ADDR
// end ; if not length then
71628: LD_VAR 0 11
71632: NOT
71633: IFFALSE 71637
// exit ;
71635: GO 71795
// tmp := array ;
71637: LD_ADDR_VAR 0 10
71641: PUSH
71642: LD_VAR 0 1
71646: ST_TO_ADDR
// for i = 1 to length do
71647: LD_ADDR_VAR 0 6
71651: PUSH
71652: DOUBLE
71653: LD_INT 1
71655: DEC
71656: ST_TO_ADDR
71657: LD_VAR 0 11
71661: PUSH
71662: FOR_TO
71663: IFFALSE 71783
// begin for j = 1 to array do
71665: LD_ADDR_VAR 0 7
71669: PUSH
71670: DOUBLE
71671: LD_INT 1
71673: DEC
71674: ST_TO_ADDR
71675: LD_VAR 0 1
71679: PUSH
71680: FOR_TO
71681: IFFALSE 71769
// begin k := j + d ;
71683: LD_ADDR_VAR 0 8
71687: PUSH
71688: LD_VAR 0 7
71692: PUSH
71693: LD_VAR 0 9
71697: PLUS
71698: ST_TO_ADDR
// if k > array then
71699: LD_VAR 0 8
71703: PUSH
71704: LD_VAR 0 1
71708: GREATER
71709: IFFALSE 71719
// k := 1 ;
71711: LD_ADDR_VAR 0 8
71715: PUSH
71716: LD_INT 1
71718: ST_TO_ADDR
// if not k then
71719: LD_VAR 0 8
71723: NOT
71724: IFFALSE 71736
// k := array ;
71726: LD_ADDR_VAR 0 8
71730: PUSH
71731: LD_VAR 0 1
71735: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71736: LD_ADDR_VAR 0 10
71740: PUSH
71741: LD_VAR 0 10
71745: PPUSH
71746: LD_VAR 0 8
71750: PPUSH
71751: LD_VAR 0 1
71755: PUSH
71756: LD_VAR 0 7
71760: ARRAY
71761: PPUSH
71762: CALL_OW 1
71766: ST_TO_ADDR
// end ;
71767: GO 71680
71769: POP
71770: POP
// array := tmp ;
71771: LD_ADDR_VAR 0 1
71775: PUSH
71776: LD_VAR 0 10
71780: ST_TO_ADDR
// end ;
71781: GO 71662
71783: POP
71784: POP
// result := array ;
71785: LD_ADDR_VAR 0 5
71789: PUSH
71790: LD_VAR 0 1
71794: ST_TO_ADDR
// end ;
71795: LD_VAR 0 5
71799: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71800: LD_INT 0
71802: PPUSH
71803: PPUSH
// result := 0 ;
71804: LD_ADDR_VAR 0 3
71808: PUSH
71809: LD_INT 0
71811: ST_TO_ADDR
// if not array or not value in array then
71812: LD_VAR 0 1
71816: NOT
71817: PUSH
71818: LD_VAR 0 2
71822: PUSH
71823: LD_VAR 0 1
71827: IN
71828: NOT
71829: OR
71830: IFFALSE 71834
// exit ;
71832: GO 71888
// for i = 1 to array do
71834: LD_ADDR_VAR 0 4
71838: PUSH
71839: DOUBLE
71840: LD_INT 1
71842: DEC
71843: ST_TO_ADDR
71844: LD_VAR 0 1
71848: PUSH
71849: FOR_TO
71850: IFFALSE 71886
// if value = array [ i ] then
71852: LD_VAR 0 2
71856: PUSH
71857: LD_VAR 0 1
71861: PUSH
71862: LD_VAR 0 4
71866: ARRAY
71867: EQUAL
71868: IFFALSE 71884
// begin result := i ;
71870: LD_ADDR_VAR 0 3
71874: PUSH
71875: LD_VAR 0 4
71879: ST_TO_ADDR
// exit ;
71880: POP
71881: POP
71882: GO 71888
// end ;
71884: GO 71849
71886: POP
71887: POP
// end ;
71888: LD_VAR 0 3
71892: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71893: LD_INT 0
71895: PPUSH
// vc_chassis := chassis ;
71896: LD_ADDR_OWVAR 37
71900: PUSH
71901: LD_VAR 0 1
71905: ST_TO_ADDR
// vc_engine := engine ;
71906: LD_ADDR_OWVAR 39
71910: PUSH
71911: LD_VAR 0 2
71915: ST_TO_ADDR
// vc_control := control ;
71916: LD_ADDR_OWVAR 38
71920: PUSH
71921: LD_VAR 0 3
71925: ST_TO_ADDR
// vc_weapon := weapon ;
71926: LD_ADDR_OWVAR 40
71930: PUSH
71931: LD_VAR 0 4
71935: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71936: LD_ADDR_OWVAR 41
71940: PUSH
71941: LD_VAR 0 5
71945: ST_TO_ADDR
// end ;
71946: LD_VAR 0 6
71950: RET
// export function WantPlant ( unit ) ; var task ; begin
71951: LD_INT 0
71953: PPUSH
71954: PPUSH
// result := false ;
71955: LD_ADDR_VAR 0 2
71959: PUSH
71960: LD_INT 0
71962: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71963: LD_ADDR_VAR 0 3
71967: PUSH
71968: LD_VAR 0 1
71972: PPUSH
71973: CALL_OW 437
71977: ST_TO_ADDR
// if task then
71978: LD_VAR 0 3
71982: IFFALSE 72010
// if task [ 1 ] [ 1 ] = p then
71984: LD_VAR 0 3
71988: PUSH
71989: LD_INT 1
71991: ARRAY
71992: PUSH
71993: LD_INT 1
71995: ARRAY
71996: PUSH
71997: LD_STRING p
71999: EQUAL
72000: IFFALSE 72010
// result := true ;
72002: LD_ADDR_VAR 0 2
72006: PUSH
72007: LD_INT 1
72009: ST_TO_ADDR
// end ;
72010: LD_VAR 0 2
72014: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72015: LD_INT 0
72017: PPUSH
72018: PPUSH
72019: PPUSH
72020: PPUSH
// if pos < 1 then
72021: LD_VAR 0 2
72025: PUSH
72026: LD_INT 1
72028: LESS
72029: IFFALSE 72033
// exit ;
72031: GO 72336
// if pos = 1 then
72033: LD_VAR 0 2
72037: PUSH
72038: LD_INT 1
72040: EQUAL
72041: IFFALSE 72074
// result := Replace ( arr , pos [ 1 ] , value ) else
72043: LD_ADDR_VAR 0 4
72047: PUSH
72048: LD_VAR 0 1
72052: PPUSH
72053: LD_VAR 0 2
72057: PUSH
72058: LD_INT 1
72060: ARRAY
72061: PPUSH
72062: LD_VAR 0 3
72066: PPUSH
72067: CALL_OW 1
72071: ST_TO_ADDR
72072: GO 72336
// begin tmp := arr ;
72074: LD_ADDR_VAR 0 6
72078: PUSH
72079: LD_VAR 0 1
72083: ST_TO_ADDR
// s_arr := [ tmp ] ;
72084: LD_ADDR_VAR 0 7
72088: PUSH
72089: LD_VAR 0 6
72093: PUSH
72094: EMPTY
72095: LIST
72096: ST_TO_ADDR
// for i = 1 to pos - 1 do
72097: LD_ADDR_VAR 0 5
72101: PUSH
72102: DOUBLE
72103: LD_INT 1
72105: DEC
72106: ST_TO_ADDR
72107: LD_VAR 0 2
72111: PUSH
72112: LD_INT 1
72114: MINUS
72115: PUSH
72116: FOR_TO
72117: IFFALSE 72162
// begin tmp := tmp [ pos [ i ] ] ;
72119: LD_ADDR_VAR 0 6
72123: PUSH
72124: LD_VAR 0 6
72128: PUSH
72129: LD_VAR 0 2
72133: PUSH
72134: LD_VAR 0 5
72138: ARRAY
72139: ARRAY
72140: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72141: LD_ADDR_VAR 0 7
72145: PUSH
72146: LD_VAR 0 7
72150: PUSH
72151: LD_VAR 0 6
72155: PUSH
72156: EMPTY
72157: LIST
72158: ADD
72159: ST_TO_ADDR
// end ;
72160: GO 72116
72162: POP
72163: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72164: LD_ADDR_VAR 0 6
72168: PUSH
72169: LD_VAR 0 6
72173: PPUSH
72174: LD_VAR 0 2
72178: PUSH
72179: LD_VAR 0 2
72183: ARRAY
72184: PPUSH
72185: LD_VAR 0 3
72189: PPUSH
72190: CALL_OW 1
72194: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72195: LD_ADDR_VAR 0 7
72199: PUSH
72200: LD_VAR 0 7
72204: PPUSH
72205: LD_VAR 0 7
72209: PPUSH
72210: LD_VAR 0 6
72214: PPUSH
72215: CALL_OW 1
72219: ST_TO_ADDR
// for i = s_arr downto 2 do
72220: LD_ADDR_VAR 0 5
72224: PUSH
72225: DOUBLE
72226: LD_VAR 0 7
72230: INC
72231: ST_TO_ADDR
72232: LD_INT 2
72234: PUSH
72235: FOR_DOWNTO
72236: IFFALSE 72320
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72238: LD_ADDR_VAR 0 6
72242: PUSH
72243: LD_VAR 0 7
72247: PUSH
72248: LD_VAR 0 5
72252: PUSH
72253: LD_INT 1
72255: MINUS
72256: ARRAY
72257: PPUSH
72258: LD_VAR 0 2
72262: PUSH
72263: LD_VAR 0 5
72267: PUSH
72268: LD_INT 1
72270: MINUS
72271: ARRAY
72272: PPUSH
72273: LD_VAR 0 7
72277: PUSH
72278: LD_VAR 0 5
72282: ARRAY
72283: PPUSH
72284: CALL_OW 1
72288: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72289: LD_ADDR_VAR 0 7
72293: PUSH
72294: LD_VAR 0 7
72298: PPUSH
72299: LD_VAR 0 5
72303: PUSH
72304: LD_INT 1
72306: MINUS
72307: PPUSH
72308: LD_VAR 0 6
72312: PPUSH
72313: CALL_OW 1
72317: ST_TO_ADDR
// end ;
72318: GO 72235
72320: POP
72321: POP
// result := s_arr [ 1 ] ;
72322: LD_ADDR_VAR 0 4
72326: PUSH
72327: LD_VAR 0 7
72331: PUSH
72332: LD_INT 1
72334: ARRAY
72335: ST_TO_ADDR
// end ; end ;
72336: LD_VAR 0 4
72340: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72341: LD_INT 0
72343: PPUSH
72344: PPUSH
// if not list then
72345: LD_VAR 0 1
72349: NOT
72350: IFFALSE 72354
// exit ;
72352: GO 72445
// i := list [ pos1 ] ;
72354: LD_ADDR_VAR 0 5
72358: PUSH
72359: LD_VAR 0 1
72363: PUSH
72364: LD_VAR 0 2
72368: ARRAY
72369: ST_TO_ADDR
// if not i then
72370: LD_VAR 0 5
72374: NOT
72375: IFFALSE 72379
// exit ;
72377: GO 72445
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72379: LD_ADDR_VAR 0 1
72383: PUSH
72384: LD_VAR 0 1
72388: PPUSH
72389: LD_VAR 0 2
72393: PPUSH
72394: LD_VAR 0 1
72398: PUSH
72399: LD_VAR 0 3
72403: ARRAY
72404: PPUSH
72405: CALL_OW 1
72409: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72410: LD_ADDR_VAR 0 1
72414: PUSH
72415: LD_VAR 0 1
72419: PPUSH
72420: LD_VAR 0 3
72424: PPUSH
72425: LD_VAR 0 5
72429: PPUSH
72430: CALL_OW 1
72434: ST_TO_ADDR
// result := list ;
72435: LD_ADDR_VAR 0 4
72439: PUSH
72440: LD_VAR 0 1
72444: ST_TO_ADDR
// end ;
72445: LD_VAR 0 4
72449: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72450: LD_INT 0
72452: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72453: LD_ADDR_VAR 0 5
72457: PUSH
72458: LD_VAR 0 1
72462: PPUSH
72463: CALL_OW 250
72467: PPUSH
72468: LD_VAR 0 1
72472: PPUSH
72473: CALL_OW 251
72477: PPUSH
72478: LD_VAR 0 2
72482: PPUSH
72483: LD_VAR 0 3
72487: PPUSH
72488: LD_VAR 0 4
72492: PPUSH
72493: CALL 72503 0 5
72497: ST_TO_ADDR
// end ;
72498: LD_VAR 0 5
72502: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72503: LD_INT 0
72505: PPUSH
72506: PPUSH
72507: PPUSH
72508: PPUSH
// if not list then
72509: LD_VAR 0 3
72513: NOT
72514: IFFALSE 72518
// exit ;
72516: GO 72906
// result := [ ] ;
72518: LD_ADDR_VAR 0 6
72522: PUSH
72523: EMPTY
72524: ST_TO_ADDR
// for i in list do
72525: LD_ADDR_VAR 0 7
72529: PUSH
72530: LD_VAR 0 3
72534: PUSH
72535: FOR_IN
72536: IFFALSE 72738
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72538: LD_ADDR_VAR 0 9
72542: PUSH
72543: LD_VAR 0 7
72547: PPUSH
72548: LD_VAR 0 1
72552: PPUSH
72553: LD_VAR 0 2
72557: PPUSH
72558: CALL_OW 297
72562: ST_TO_ADDR
// if not result then
72563: LD_VAR 0 6
72567: NOT
72568: IFFALSE 72594
// result := [ [ i , tmp ] ] else
72570: LD_ADDR_VAR 0 6
72574: PUSH
72575: LD_VAR 0 7
72579: PUSH
72580: LD_VAR 0 9
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: EMPTY
72590: LIST
72591: ST_TO_ADDR
72592: GO 72736
// begin if result [ result ] [ 2 ] < tmp then
72594: LD_VAR 0 6
72598: PUSH
72599: LD_VAR 0 6
72603: ARRAY
72604: PUSH
72605: LD_INT 2
72607: ARRAY
72608: PUSH
72609: LD_VAR 0 9
72613: LESS
72614: IFFALSE 72656
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72616: LD_ADDR_VAR 0 6
72620: PUSH
72621: LD_VAR 0 6
72625: PPUSH
72626: LD_VAR 0 6
72630: PUSH
72631: LD_INT 1
72633: PLUS
72634: PPUSH
72635: LD_VAR 0 7
72639: PUSH
72640: LD_VAR 0 9
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PPUSH
72649: CALL_OW 2
72653: ST_TO_ADDR
72654: GO 72736
// for j = 1 to result do
72656: LD_ADDR_VAR 0 8
72660: PUSH
72661: DOUBLE
72662: LD_INT 1
72664: DEC
72665: ST_TO_ADDR
72666: LD_VAR 0 6
72670: PUSH
72671: FOR_TO
72672: IFFALSE 72734
// begin if tmp < result [ j ] [ 2 ] then
72674: LD_VAR 0 9
72678: PUSH
72679: LD_VAR 0 6
72683: PUSH
72684: LD_VAR 0 8
72688: ARRAY
72689: PUSH
72690: LD_INT 2
72692: ARRAY
72693: LESS
72694: IFFALSE 72732
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72696: LD_ADDR_VAR 0 6
72700: PUSH
72701: LD_VAR 0 6
72705: PPUSH
72706: LD_VAR 0 8
72710: PPUSH
72711: LD_VAR 0 7
72715: PUSH
72716: LD_VAR 0 9
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PPUSH
72725: CALL_OW 2
72729: ST_TO_ADDR
// break ;
72730: GO 72734
// end ; end ;
72732: GO 72671
72734: POP
72735: POP
// end ; end ;
72736: GO 72535
72738: POP
72739: POP
// if result and not asc then
72740: LD_VAR 0 6
72744: PUSH
72745: LD_VAR 0 4
72749: NOT
72750: AND
72751: IFFALSE 72826
// begin tmp := result ;
72753: LD_ADDR_VAR 0 9
72757: PUSH
72758: LD_VAR 0 6
72762: ST_TO_ADDR
// for i = tmp downto 1 do
72763: LD_ADDR_VAR 0 7
72767: PUSH
72768: DOUBLE
72769: LD_VAR 0 9
72773: INC
72774: ST_TO_ADDR
72775: LD_INT 1
72777: PUSH
72778: FOR_DOWNTO
72779: IFFALSE 72824
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72781: LD_ADDR_VAR 0 6
72785: PUSH
72786: LD_VAR 0 6
72790: PPUSH
72791: LD_VAR 0 9
72795: PUSH
72796: LD_VAR 0 7
72800: MINUS
72801: PUSH
72802: LD_INT 1
72804: PLUS
72805: PPUSH
72806: LD_VAR 0 9
72810: PUSH
72811: LD_VAR 0 7
72815: ARRAY
72816: PPUSH
72817: CALL_OW 1
72821: ST_TO_ADDR
72822: GO 72778
72824: POP
72825: POP
// end ; tmp := [ ] ;
72826: LD_ADDR_VAR 0 9
72830: PUSH
72831: EMPTY
72832: ST_TO_ADDR
// if mode then
72833: LD_VAR 0 5
72837: IFFALSE 72906
// begin for i = 1 to result do
72839: LD_ADDR_VAR 0 7
72843: PUSH
72844: DOUBLE
72845: LD_INT 1
72847: DEC
72848: ST_TO_ADDR
72849: LD_VAR 0 6
72853: PUSH
72854: FOR_TO
72855: IFFALSE 72894
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72857: LD_ADDR_VAR 0 9
72861: PUSH
72862: LD_VAR 0 9
72866: PPUSH
72867: LD_VAR 0 7
72871: PPUSH
72872: LD_VAR 0 6
72876: PUSH
72877: LD_VAR 0 7
72881: ARRAY
72882: PUSH
72883: LD_INT 1
72885: ARRAY
72886: PPUSH
72887: CALL_OW 1
72891: ST_TO_ADDR
72892: GO 72854
72894: POP
72895: POP
// result := tmp ;
72896: LD_ADDR_VAR 0 6
72900: PUSH
72901: LD_VAR 0 9
72905: ST_TO_ADDR
// end ; end ;
72906: LD_VAR 0 6
72910: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72911: LD_INT 0
72913: PPUSH
72914: PPUSH
72915: PPUSH
72916: PPUSH
72917: PPUSH
72918: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72919: LD_ADDR_VAR 0 5
72923: PUSH
72924: LD_INT 0
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: LD_INT 0
72932: PUSH
72933: EMPTY
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: ST_TO_ADDR
// if not x or not y then
72941: LD_VAR 0 2
72945: NOT
72946: PUSH
72947: LD_VAR 0 3
72951: NOT
72952: OR
72953: IFFALSE 72957
// exit ;
72955: GO 74603
// if not range then
72957: LD_VAR 0 4
72961: NOT
72962: IFFALSE 72972
// range := 10 ;
72964: LD_ADDR_VAR 0 4
72968: PUSH
72969: LD_INT 10
72971: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72972: LD_ADDR_VAR 0 8
72976: PUSH
72977: LD_INT 81
72979: PUSH
72980: LD_VAR 0 1
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 92
72991: PUSH
72992: LD_VAR 0 2
72996: PUSH
72997: LD_VAR 0 3
73001: PUSH
73002: LD_VAR 0 4
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 3
73015: PUSH
73016: LD_INT 21
73018: PUSH
73019: LD_INT 3
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: LIST
73034: PPUSH
73035: CALL_OW 69
73039: ST_TO_ADDR
// if not tmp then
73040: LD_VAR 0 8
73044: NOT
73045: IFFALSE 73049
// exit ;
73047: GO 74603
// for i in tmp do
73049: LD_ADDR_VAR 0 6
73053: PUSH
73054: LD_VAR 0 8
73058: PUSH
73059: FOR_IN
73060: IFFALSE 74578
// begin points := [ 0 , 0 , 0 ] ;
73062: LD_ADDR_VAR 0 9
73066: PUSH
73067: LD_INT 0
73069: PUSH
73070: LD_INT 0
73072: PUSH
73073: LD_INT 0
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: LIST
73080: ST_TO_ADDR
// bpoints := 1 ;
73081: LD_ADDR_VAR 0 10
73085: PUSH
73086: LD_INT 1
73088: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73089: LD_VAR 0 6
73093: PPUSH
73094: CALL_OW 247
73098: PUSH
73099: LD_INT 1
73101: DOUBLE
73102: EQUAL
73103: IFTRUE 73107
73105: GO 73685
73107: POP
// begin if GetClass ( i ) = 1 then
73108: LD_VAR 0 6
73112: PPUSH
73113: CALL_OW 257
73117: PUSH
73118: LD_INT 1
73120: EQUAL
73121: IFFALSE 73142
// points := [ 10 , 5 , 3 ] ;
73123: LD_ADDR_VAR 0 9
73127: PUSH
73128: LD_INT 10
73130: PUSH
73131: LD_INT 5
73133: PUSH
73134: LD_INT 3
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: LIST
73141: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73142: LD_VAR 0 6
73146: PPUSH
73147: CALL_OW 257
73151: PUSH
73152: LD_INT 2
73154: PUSH
73155: LD_INT 3
73157: PUSH
73158: LD_INT 4
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: LIST
73165: IN
73166: IFFALSE 73187
// points := [ 3 , 2 , 1 ] ;
73168: LD_ADDR_VAR 0 9
73172: PUSH
73173: LD_INT 3
73175: PUSH
73176: LD_INT 2
73178: PUSH
73179: LD_INT 1
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: LIST
73186: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73187: LD_VAR 0 6
73191: PPUSH
73192: CALL_OW 257
73196: PUSH
73197: LD_INT 5
73199: EQUAL
73200: IFFALSE 73221
// points := [ 130 , 5 , 2 ] ;
73202: LD_ADDR_VAR 0 9
73206: PUSH
73207: LD_INT 130
73209: PUSH
73210: LD_INT 5
73212: PUSH
73213: LD_INT 2
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: LIST
73220: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73221: LD_VAR 0 6
73225: PPUSH
73226: CALL_OW 257
73230: PUSH
73231: LD_INT 8
73233: EQUAL
73234: IFFALSE 73255
// points := [ 35 , 35 , 30 ] ;
73236: LD_ADDR_VAR 0 9
73240: PUSH
73241: LD_INT 35
73243: PUSH
73244: LD_INT 35
73246: PUSH
73247: LD_INT 30
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: LIST
73254: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73255: LD_VAR 0 6
73259: PPUSH
73260: CALL_OW 257
73264: PUSH
73265: LD_INT 9
73267: EQUAL
73268: IFFALSE 73289
// points := [ 20 , 55 , 40 ] ;
73270: LD_ADDR_VAR 0 9
73274: PUSH
73275: LD_INT 20
73277: PUSH
73278: LD_INT 55
73280: PUSH
73281: LD_INT 40
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: LIST
73288: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73289: LD_VAR 0 6
73293: PPUSH
73294: CALL_OW 257
73298: PUSH
73299: LD_INT 12
73301: PUSH
73302: LD_INT 16
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: IN
73309: IFFALSE 73330
// points := [ 5 , 3 , 2 ] ;
73311: LD_ADDR_VAR 0 9
73315: PUSH
73316: LD_INT 5
73318: PUSH
73319: LD_INT 3
73321: PUSH
73322: LD_INT 2
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: LIST
73329: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73330: LD_VAR 0 6
73334: PPUSH
73335: CALL_OW 257
73339: PUSH
73340: LD_INT 17
73342: EQUAL
73343: IFFALSE 73364
// points := [ 100 , 50 , 75 ] ;
73345: LD_ADDR_VAR 0 9
73349: PUSH
73350: LD_INT 100
73352: PUSH
73353: LD_INT 50
73355: PUSH
73356: LD_INT 75
73358: PUSH
73359: EMPTY
73360: LIST
73361: LIST
73362: LIST
73363: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73364: LD_VAR 0 6
73368: PPUSH
73369: CALL_OW 257
73373: PUSH
73374: LD_INT 15
73376: EQUAL
73377: IFFALSE 73398
// points := [ 10 , 5 , 3 ] ;
73379: LD_ADDR_VAR 0 9
73383: PUSH
73384: LD_INT 10
73386: PUSH
73387: LD_INT 5
73389: PUSH
73390: LD_INT 3
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: LIST
73397: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73398: LD_VAR 0 6
73402: PPUSH
73403: CALL_OW 257
73407: PUSH
73408: LD_INT 14
73410: EQUAL
73411: IFFALSE 73432
// points := [ 10 , 0 , 0 ] ;
73413: LD_ADDR_VAR 0 9
73417: PUSH
73418: LD_INT 10
73420: PUSH
73421: LD_INT 0
73423: PUSH
73424: LD_INT 0
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: LIST
73431: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73432: LD_VAR 0 6
73436: PPUSH
73437: CALL_OW 257
73441: PUSH
73442: LD_INT 11
73444: EQUAL
73445: IFFALSE 73466
// points := [ 30 , 10 , 5 ] ;
73447: LD_ADDR_VAR 0 9
73451: PUSH
73452: LD_INT 30
73454: PUSH
73455: LD_INT 10
73457: PUSH
73458: LD_INT 5
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: LIST
73465: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73466: LD_VAR 0 1
73470: PPUSH
73471: LD_INT 5
73473: PPUSH
73474: CALL_OW 321
73478: PUSH
73479: LD_INT 2
73481: EQUAL
73482: IFFALSE 73499
// bpoints := bpoints * 1.8 ;
73484: LD_ADDR_VAR 0 10
73488: PUSH
73489: LD_VAR 0 10
73493: PUSH
73494: LD_REAL  1.80000000000000E+0000
73497: MUL
73498: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73499: LD_VAR 0 6
73503: PPUSH
73504: CALL_OW 257
73508: PUSH
73509: LD_INT 1
73511: PUSH
73512: LD_INT 2
73514: PUSH
73515: LD_INT 3
73517: PUSH
73518: LD_INT 4
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: IN
73527: PUSH
73528: LD_VAR 0 1
73532: PPUSH
73533: LD_INT 51
73535: PPUSH
73536: CALL_OW 321
73540: PUSH
73541: LD_INT 2
73543: EQUAL
73544: AND
73545: IFFALSE 73562
// bpoints := bpoints * 1.2 ;
73547: LD_ADDR_VAR 0 10
73551: PUSH
73552: LD_VAR 0 10
73556: PUSH
73557: LD_REAL  1.20000000000000E+0000
73560: MUL
73561: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73562: LD_VAR 0 6
73566: PPUSH
73567: CALL_OW 257
73571: PUSH
73572: LD_INT 5
73574: PUSH
73575: LD_INT 7
73577: PUSH
73578: LD_INT 9
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: LIST
73585: IN
73586: PUSH
73587: LD_VAR 0 1
73591: PPUSH
73592: LD_INT 52
73594: PPUSH
73595: CALL_OW 321
73599: PUSH
73600: LD_INT 2
73602: EQUAL
73603: AND
73604: IFFALSE 73621
// bpoints := bpoints * 1.5 ;
73606: LD_ADDR_VAR 0 10
73610: PUSH
73611: LD_VAR 0 10
73615: PUSH
73616: LD_REAL  1.50000000000000E+0000
73619: MUL
73620: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73621: LD_VAR 0 1
73625: PPUSH
73626: LD_INT 66
73628: PPUSH
73629: CALL_OW 321
73633: PUSH
73634: LD_INT 2
73636: EQUAL
73637: IFFALSE 73654
// bpoints := bpoints * 1.1 ;
73639: LD_ADDR_VAR 0 10
73643: PUSH
73644: LD_VAR 0 10
73648: PUSH
73649: LD_REAL  1.10000000000000E+0000
73652: MUL
73653: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73654: LD_ADDR_VAR 0 10
73658: PUSH
73659: LD_VAR 0 10
73663: PUSH
73664: LD_VAR 0 6
73668: PPUSH
73669: LD_INT 1
73671: PPUSH
73672: CALL_OW 259
73676: PUSH
73677: LD_REAL  1.15000000000000E+0000
73680: MUL
73681: MUL
73682: ST_TO_ADDR
// end ; unit_vehicle :
73683: GO 74507
73685: LD_INT 2
73687: DOUBLE
73688: EQUAL
73689: IFTRUE 73693
73691: GO 74495
73693: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73694: LD_VAR 0 6
73698: PPUSH
73699: CALL_OW 264
73703: PUSH
73704: LD_INT 2
73706: PUSH
73707: LD_INT 42
73709: PUSH
73710: LD_INT 24
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: LIST
73717: IN
73718: IFFALSE 73739
// points := [ 25 , 5 , 3 ] ;
73720: LD_ADDR_VAR 0 9
73724: PUSH
73725: LD_INT 25
73727: PUSH
73728: LD_INT 5
73730: PUSH
73731: LD_INT 3
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: LIST
73738: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73739: LD_VAR 0 6
73743: PPUSH
73744: CALL_OW 264
73748: PUSH
73749: LD_INT 4
73751: PUSH
73752: LD_INT 43
73754: PUSH
73755: LD_INT 25
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: LIST
73762: IN
73763: IFFALSE 73784
// points := [ 40 , 15 , 5 ] ;
73765: LD_ADDR_VAR 0 9
73769: PUSH
73770: LD_INT 40
73772: PUSH
73773: LD_INT 15
73775: PUSH
73776: LD_INT 5
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: LIST
73783: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73784: LD_VAR 0 6
73788: PPUSH
73789: CALL_OW 264
73793: PUSH
73794: LD_INT 3
73796: PUSH
73797: LD_INT 23
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: IN
73804: IFFALSE 73825
// points := [ 7 , 25 , 8 ] ;
73806: LD_ADDR_VAR 0 9
73810: PUSH
73811: LD_INT 7
73813: PUSH
73814: LD_INT 25
73816: PUSH
73817: LD_INT 8
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: LIST
73824: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73825: LD_VAR 0 6
73829: PPUSH
73830: CALL_OW 264
73834: PUSH
73835: LD_INT 5
73837: PUSH
73838: LD_INT 27
73840: PUSH
73841: LD_INT 44
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: LIST
73848: IN
73849: IFFALSE 73870
// points := [ 14 , 50 , 16 ] ;
73851: LD_ADDR_VAR 0 9
73855: PUSH
73856: LD_INT 14
73858: PUSH
73859: LD_INT 50
73861: PUSH
73862: LD_INT 16
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: LIST
73869: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73870: LD_VAR 0 6
73874: PPUSH
73875: CALL_OW 264
73879: PUSH
73880: LD_INT 6
73882: PUSH
73883: LD_INT 46
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: IN
73890: IFFALSE 73911
// points := [ 32 , 120 , 70 ] ;
73892: LD_ADDR_VAR 0 9
73896: PUSH
73897: LD_INT 32
73899: PUSH
73900: LD_INT 120
73902: PUSH
73903: LD_INT 70
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: LIST
73910: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73911: LD_VAR 0 6
73915: PPUSH
73916: CALL_OW 264
73920: PUSH
73921: LD_INT 7
73923: PUSH
73924: LD_INT 28
73926: PUSH
73927: LD_INT 45
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: LIST
73934: IN
73935: IFFALSE 73956
// points := [ 35 , 20 , 45 ] ;
73937: LD_ADDR_VAR 0 9
73941: PUSH
73942: LD_INT 35
73944: PUSH
73945: LD_INT 20
73947: PUSH
73948: LD_INT 45
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: LIST
73955: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73956: LD_VAR 0 6
73960: PPUSH
73961: CALL_OW 264
73965: PUSH
73966: LD_INT 47
73968: PUSH
73969: EMPTY
73970: LIST
73971: IN
73972: IFFALSE 73993
// points := [ 67 , 45 , 75 ] ;
73974: LD_ADDR_VAR 0 9
73978: PUSH
73979: LD_INT 67
73981: PUSH
73982: LD_INT 45
73984: PUSH
73985: LD_INT 75
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: LIST
73992: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73993: LD_VAR 0 6
73997: PPUSH
73998: CALL_OW 264
74002: PUSH
74003: LD_INT 26
74005: PUSH
74006: EMPTY
74007: LIST
74008: IN
74009: IFFALSE 74030
// points := [ 120 , 30 , 80 ] ;
74011: LD_ADDR_VAR 0 9
74015: PUSH
74016: LD_INT 120
74018: PUSH
74019: LD_INT 30
74021: PUSH
74022: LD_INT 80
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: LIST
74029: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74030: LD_VAR 0 6
74034: PPUSH
74035: CALL_OW 264
74039: PUSH
74040: LD_INT 22
74042: PUSH
74043: EMPTY
74044: LIST
74045: IN
74046: IFFALSE 74067
// points := [ 40 , 1 , 1 ] ;
74048: LD_ADDR_VAR 0 9
74052: PUSH
74053: LD_INT 40
74055: PUSH
74056: LD_INT 1
74058: PUSH
74059: LD_INT 1
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: LIST
74066: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74067: LD_VAR 0 6
74071: PPUSH
74072: CALL_OW 264
74076: PUSH
74077: LD_INT 29
74079: PUSH
74080: EMPTY
74081: LIST
74082: IN
74083: IFFALSE 74104
// points := [ 70 , 200 , 400 ] ;
74085: LD_ADDR_VAR 0 9
74089: PUSH
74090: LD_INT 70
74092: PUSH
74093: LD_INT 200
74095: PUSH
74096: LD_INT 400
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: LIST
74103: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74104: LD_VAR 0 6
74108: PPUSH
74109: CALL_OW 264
74113: PUSH
74114: LD_INT 14
74116: PUSH
74117: LD_INT 53
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: IN
74124: IFFALSE 74145
// points := [ 40 , 10 , 20 ] ;
74126: LD_ADDR_VAR 0 9
74130: PUSH
74131: LD_INT 40
74133: PUSH
74134: LD_INT 10
74136: PUSH
74137: LD_INT 20
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: LIST
74144: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74145: LD_VAR 0 6
74149: PPUSH
74150: CALL_OW 264
74154: PUSH
74155: LD_INT 9
74157: PUSH
74158: EMPTY
74159: LIST
74160: IN
74161: IFFALSE 74182
// points := [ 5 , 70 , 20 ] ;
74163: LD_ADDR_VAR 0 9
74167: PUSH
74168: LD_INT 5
74170: PUSH
74171: LD_INT 70
74173: PUSH
74174: LD_INT 20
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: LIST
74181: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74182: LD_VAR 0 6
74186: PPUSH
74187: CALL_OW 264
74191: PUSH
74192: LD_INT 10
74194: PUSH
74195: EMPTY
74196: LIST
74197: IN
74198: IFFALSE 74219
// points := [ 35 , 110 , 70 ] ;
74200: LD_ADDR_VAR 0 9
74204: PUSH
74205: LD_INT 35
74207: PUSH
74208: LD_INT 110
74210: PUSH
74211: LD_INT 70
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: LIST
74218: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74219: LD_VAR 0 6
74223: PPUSH
74224: CALL_OW 265
74228: PUSH
74229: LD_INT 25
74231: EQUAL
74232: IFFALSE 74253
// points := [ 80 , 65 , 100 ] ;
74234: LD_ADDR_VAR 0 9
74238: PUSH
74239: LD_INT 80
74241: PUSH
74242: LD_INT 65
74244: PUSH
74245: LD_INT 100
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: LIST
74252: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74253: LD_VAR 0 6
74257: PPUSH
74258: CALL_OW 263
74262: PUSH
74263: LD_INT 1
74265: EQUAL
74266: IFFALSE 74301
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74268: LD_ADDR_VAR 0 10
74272: PUSH
74273: LD_VAR 0 10
74277: PUSH
74278: LD_VAR 0 6
74282: PPUSH
74283: CALL_OW 311
74287: PPUSH
74288: LD_INT 3
74290: PPUSH
74291: CALL_OW 259
74295: PUSH
74296: LD_INT 4
74298: MUL
74299: MUL
74300: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74301: LD_VAR 0 6
74305: PPUSH
74306: CALL_OW 263
74310: PUSH
74311: LD_INT 2
74313: EQUAL
74314: IFFALSE 74365
// begin j := IsControledBy ( i ) ;
74316: LD_ADDR_VAR 0 7
74320: PUSH
74321: LD_VAR 0 6
74325: PPUSH
74326: CALL_OW 312
74330: ST_TO_ADDR
// if j then
74331: LD_VAR 0 7
74335: IFFALSE 74365
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74337: LD_ADDR_VAR 0 10
74341: PUSH
74342: LD_VAR 0 10
74346: PUSH
74347: LD_VAR 0 7
74351: PPUSH
74352: LD_INT 3
74354: PPUSH
74355: CALL_OW 259
74359: PUSH
74360: LD_INT 3
74362: MUL
74363: MUL
74364: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74365: LD_VAR 0 6
74369: PPUSH
74370: CALL_OW 264
74374: PUSH
74375: LD_INT 5
74377: PUSH
74378: LD_INT 6
74380: PUSH
74381: LD_INT 46
74383: PUSH
74384: LD_INT 44
74386: PUSH
74387: LD_INT 47
74389: PUSH
74390: LD_INT 45
74392: PUSH
74393: LD_INT 28
74395: PUSH
74396: LD_INT 7
74398: PUSH
74399: LD_INT 27
74401: PUSH
74402: LD_INT 29
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: IN
74417: PUSH
74418: LD_VAR 0 1
74422: PPUSH
74423: LD_INT 52
74425: PPUSH
74426: CALL_OW 321
74430: PUSH
74431: LD_INT 2
74433: EQUAL
74434: AND
74435: IFFALSE 74452
// bpoints := bpoints * 1.2 ;
74437: LD_ADDR_VAR 0 10
74441: PUSH
74442: LD_VAR 0 10
74446: PUSH
74447: LD_REAL  1.20000000000000E+0000
74450: MUL
74451: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74452: LD_VAR 0 6
74456: PPUSH
74457: CALL_OW 264
74461: PUSH
74462: LD_INT 6
74464: PUSH
74465: LD_INT 46
74467: PUSH
74468: LD_INT 47
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: LIST
74475: IN
74476: IFFALSE 74493
// bpoints := bpoints * 1.2 ;
74478: LD_ADDR_VAR 0 10
74482: PUSH
74483: LD_VAR 0 10
74487: PUSH
74488: LD_REAL  1.20000000000000E+0000
74491: MUL
74492: ST_TO_ADDR
// end ; unit_building :
74493: GO 74507
74495: LD_INT 3
74497: DOUBLE
74498: EQUAL
74499: IFTRUE 74503
74501: GO 74506
74503: POP
// ; end ;
74504: GO 74507
74506: POP
// for j = 1 to 3 do
74507: LD_ADDR_VAR 0 7
74511: PUSH
74512: DOUBLE
74513: LD_INT 1
74515: DEC
74516: ST_TO_ADDR
74517: LD_INT 3
74519: PUSH
74520: FOR_TO
74521: IFFALSE 74574
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74523: LD_ADDR_VAR 0 5
74527: PUSH
74528: LD_VAR 0 5
74532: PPUSH
74533: LD_VAR 0 7
74537: PPUSH
74538: LD_VAR 0 5
74542: PUSH
74543: LD_VAR 0 7
74547: ARRAY
74548: PUSH
74549: LD_VAR 0 9
74553: PUSH
74554: LD_VAR 0 7
74558: ARRAY
74559: PUSH
74560: LD_VAR 0 10
74564: MUL
74565: PLUS
74566: PPUSH
74567: CALL_OW 1
74571: ST_TO_ADDR
74572: GO 74520
74574: POP
74575: POP
// end ;
74576: GO 73059
74578: POP
74579: POP
// result := Replace ( result , 4 , tmp ) ;
74580: LD_ADDR_VAR 0 5
74584: PUSH
74585: LD_VAR 0 5
74589: PPUSH
74590: LD_INT 4
74592: PPUSH
74593: LD_VAR 0 8
74597: PPUSH
74598: CALL_OW 1
74602: ST_TO_ADDR
// end ;
74603: LD_VAR 0 5
74607: RET
// export function DangerAtRange ( unit , range ) ; begin
74608: LD_INT 0
74610: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74611: LD_ADDR_VAR 0 3
74615: PUSH
74616: LD_VAR 0 1
74620: PPUSH
74621: CALL_OW 255
74625: PPUSH
74626: LD_VAR 0 1
74630: PPUSH
74631: CALL_OW 250
74635: PPUSH
74636: LD_VAR 0 1
74640: PPUSH
74641: CALL_OW 251
74645: PPUSH
74646: LD_VAR 0 2
74650: PPUSH
74651: CALL 72911 0 4
74655: ST_TO_ADDR
// end ;
74656: LD_VAR 0 3
74660: RET
// export function DangerInArea ( side , area ) ; begin
74661: LD_INT 0
74663: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74664: LD_ADDR_VAR 0 3
74668: PUSH
74669: LD_VAR 0 2
74673: PPUSH
74674: LD_INT 81
74676: PUSH
74677: LD_VAR 0 1
74681: PUSH
74682: EMPTY
74683: LIST
74684: LIST
74685: PPUSH
74686: CALL_OW 70
74690: ST_TO_ADDR
// end ;
74691: LD_VAR 0 3
74695: RET
// export function IsExtension ( b ) ; begin
74696: LD_INT 0
74698: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74699: LD_ADDR_VAR 0 2
74703: PUSH
74704: LD_VAR 0 1
74708: PUSH
74709: LD_INT 23
74711: PUSH
74712: LD_INT 20
74714: PUSH
74715: LD_INT 22
74717: PUSH
74718: LD_INT 17
74720: PUSH
74721: LD_INT 24
74723: PUSH
74724: LD_INT 21
74726: PUSH
74727: LD_INT 19
74729: PUSH
74730: LD_INT 16
74732: PUSH
74733: LD_INT 25
74735: PUSH
74736: LD_INT 18
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: IN
74751: ST_TO_ADDR
// end ;
74752: LD_VAR 0 2
74756: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74757: LD_INT 0
74759: PPUSH
74760: PPUSH
74761: PPUSH
// result := [ ] ;
74762: LD_ADDR_VAR 0 3
74766: PUSH
74767: EMPTY
74768: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74769: LD_ADDR_VAR 0 4
74773: PUSH
74774: LD_VAR 0 2
74778: PPUSH
74779: LD_INT 21
74781: PUSH
74782: LD_INT 3
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: PPUSH
74789: CALL_OW 70
74793: ST_TO_ADDR
// if not tmp then
74794: LD_VAR 0 4
74798: NOT
74799: IFFALSE 74803
// exit ;
74801: GO 74861
// for i in tmp do
74803: LD_ADDR_VAR 0 5
74807: PUSH
74808: LD_VAR 0 4
74812: PUSH
74813: FOR_IN
74814: IFFALSE 74849
// if GetBase ( i ) <> base then
74816: LD_VAR 0 5
74820: PPUSH
74821: CALL_OW 274
74825: PUSH
74826: LD_VAR 0 1
74830: NONEQUAL
74831: IFFALSE 74847
// ComLinkToBase ( base , i ) ;
74833: LD_VAR 0 1
74837: PPUSH
74838: LD_VAR 0 5
74842: PPUSH
74843: CALL_OW 169
74847: GO 74813
74849: POP
74850: POP
// result := tmp ;
74851: LD_ADDR_VAR 0 3
74855: PUSH
74856: LD_VAR 0 4
74860: ST_TO_ADDR
// end ;
74861: LD_VAR 0 3
74865: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74866: LD_INT 0
74868: PPUSH
74869: PPUSH
// if BuildingStatus ( b ) = bs_build then
74870: LD_VAR 0 2
74874: PPUSH
74875: CALL_OW 461
74879: PUSH
74880: LD_INT 1
74882: EQUAL
74883: IFFALSE 74943
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74885: LD_VAR 0 1
74889: PPUSH
74890: LD_STRING h
74892: PUSH
74893: LD_VAR 0 2
74897: PPUSH
74898: CALL_OW 250
74902: PUSH
74903: LD_VAR 0 2
74907: PPUSH
74908: CALL_OW 251
74912: PUSH
74913: LD_VAR 0 2
74917: PUSH
74918: LD_INT 0
74920: PUSH
74921: LD_INT 0
74923: PUSH
74924: LD_INT 0
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: LIST
74931: LIST
74932: LIST
74933: LIST
74934: LIST
74935: PUSH
74936: EMPTY
74937: LIST
74938: PPUSH
74939: CALL_OW 446
// end ;
74943: LD_VAR 0 3
74947: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74948: LD_INT 0
74950: PPUSH
74951: PPUSH
74952: PPUSH
74953: PPUSH
74954: PPUSH
74955: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74956: LD_VAR 0 1
74960: NOT
74961: PUSH
74962: LD_VAR 0 1
74966: PPUSH
74967: CALL_OW 263
74971: PUSH
74972: LD_INT 2
74974: EQUAL
74975: NOT
74976: OR
74977: IFFALSE 74981
// exit ;
74979: GO 75297
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74981: LD_ADDR_VAR 0 6
74985: PUSH
74986: LD_INT 22
74988: PUSH
74989: LD_VAR 0 1
74993: PPUSH
74994: CALL_OW 255
74998: PUSH
74999: EMPTY
75000: LIST
75001: LIST
75002: PUSH
75003: LD_INT 2
75005: PUSH
75006: LD_INT 30
75008: PUSH
75009: LD_INT 36
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: LD_INT 34
75018: PUSH
75019: LD_INT 31
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: LIST
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PPUSH
75035: CALL_OW 69
75039: ST_TO_ADDR
// if not tmp then
75040: LD_VAR 0 6
75044: NOT
75045: IFFALSE 75049
// exit ;
75047: GO 75297
// result := [ ] ;
75049: LD_ADDR_VAR 0 2
75053: PUSH
75054: EMPTY
75055: ST_TO_ADDR
// for i in tmp do
75056: LD_ADDR_VAR 0 3
75060: PUSH
75061: LD_VAR 0 6
75065: PUSH
75066: FOR_IN
75067: IFFALSE 75138
// begin t := UnitsInside ( i ) ;
75069: LD_ADDR_VAR 0 4
75073: PUSH
75074: LD_VAR 0 3
75078: PPUSH
75079: CALL_OW 313
75083: ST_TO_ADDR
// if t then
75084: LD_VAR 0 4
75088: IFFALSE 75136
// for j in t do
75090: LD_ADDR_VAR 0 7
75094: PUSH
75095: LD_VAR 0 4
75099: PUSH
75100: FOR_IN
75101: IFFALSE 75134
// result := Insert ( result , result + 1 , j ) ;
75103: LD_ADDR_VAR 0 2
75107: PUSH
75108: LD_VAR 0 2
75112: PPUSH
75113: LD_VAR 0 2
75117: PUSH
75118: LD_INT 1
75120: PLUS
75121: PPUSH
75122: LD_VAR 0 7
75126: PPUSH
75127: CALL_OW 2
75131: ST_TO_ADDR
75132: GO 75100
75134: POP
75135: POP
// end ;
75136: GO 75066
75138: POP
75139: POP
// if not result then
75140: LD_VAR 0 2
75144: NOT
75145: IFFALSE 75149
// exit ;
75147: GO 75297
// mech := result [ 1 ] ;
75149: LD_ADDR_VAR 0 5
75153: PUSH
75154: LD_VAR 0 2
75158: PUSH
75159: LD_INT 1
75161: ARRAY
75162: ST_TO_ADDR
// if result > 1 then
75163: LD_VAR 0 2
75167: PUSH
75168: LD_INT 1
75170: GREATER
75171: IFFALSE 75283
// for i = 2 to result do
75173: LD_ADDR_VAR 0 3
75177: PUSH
75178: DOUBLE
75179: LD_INT 2
75181: DEC
75182: ST_TO_ADDR
75183: LD_VAR 0 2
75187: PUSH
75188: FOR_TO
75189: IFFALSE 75281
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75191: LD_ADDR_VAR 0 4
75195: PUSH
75196: LD_VAR 0 2
75200: PUSH
75201: LD_VAR 0 3
75205: ARRAY
75206: PPUSH
75207: LD_INT 3
75209: PPUSH
75210: CALL_OW 259
75214: PUSH
75215: LD_VAR 0 2
75219: PUSH
75220: LD_VAR 0 3
75224: ARRAY
75225: PPUSH
75226: CALL_OW 432
75230: MINUS
75231: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75232: LD_VAR 0 4
75236: PUSH
75237: LD_VAR 0 5
75241: PPUSH
75242: LD_INT 3
75244: PPUSH
75245: CALL_OW 259
75249: PUSH
75250: LD_VAR 0 5
75254: PPUSH
75255: CALL_OW 432
75259: MINUS
75260: GREATEREQUAL
75261: IFFALSE 75279
// mech := result [ i ] ;
75263: LD_ADDR_VAR 0 5
75267: PUSH
75268: LD_VAR 0 2
75272: PUSH
75273: LD_VAR 0 3
75277: ARRAY
75278: ST_TO_ADDR
// end ;
75279: GO 75188
75281: POP
75282: POP
// ComLinkTo ( vehicle , mech ) ;
75283: LD_VAR 0 1
75287: PPUSH
75288: LD_VAR 0 5
75292: PPUSH
75293: CALL_OW 135
// end ;
75297: LD_VAR 0 2
75301: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75302: LD_INT 0
75304: PPUSH
75305: PPUSH
75306: PPUSH
75307: PPUSH
75308: PPUSH
75309: PPUSH
75310: PPUSH
75311: PPUSH
75312: PPUSH
75313: PPUSH
75314: PPUSH
75315: PPUSH
75316: PPUSH
// result := [ ] ;
75317: LD_ADDR_VAR 0 7
75321: PUSH
75322: EMPTY
75323: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75324: LD_VAR 0 1
75328: PPUSH
75329: CALL_OW 266
75333: PUSH
75334: LD_INT 0
75336: PUSH
75337: LD_INT 1
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: IN
75344: NOT
75345: IFFALSE 75349
// exit ;
75347: GO 76980
// if name then
75349: LD_VAR 0 3
75353: IFFALSE 75369
// SetBName ( base_dep , name ) ;
75355: LD_VAR 0 1
75359: PPUSH
75360: LD_VAR 0 3
75364: PPUSH
75365: CALL_OW 500
// base := GetBase ( base_dep ) ;
75369: LD_ADDR_VAR 0 15
75373: PUSH
75374: LD_VAR 0 1
75378: PPUSH
75379: CALL_OW 274
75383: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75384: LD_ADDR_VAR 0 16
75388: PUSH
75389: LD_VAR 0 1
75393: PPUSH
75394: CALL_OW 255
75398: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75399: LD_ADDR_VAR 0 17
75403: PUSH
75404: LD_VAR 0 1
75408: PPUSH
75409: CALL_OW 248
75413: ST_TO_ADDR
// if sources then
75414: LD_VAR 0 5
75418: IFFALSE 75465
// for i = 1 to 3 do
75420: LD_ADDR_VAR 0 8
75424: PUSH
75425: DOUBLE
75426: LD_INT 1
75428: DEC
75429: ST_TO_ADDR
75430: LD_INT 3
75432: PUSH
75433: FOR_TO
75434: IFFALSE 75463
// AddResourceType ( base , i , sources [ i ] ) ;
75436: LD_VAR 0 15
75440: PPUSH
75441: LD_VAR 0 8
75445: PPUSH
75446: LD_VAR 0 5
75450: PUSH
75451: LD_VAR 0 8
75455: ARRAY
75456: PPUSH
75457: CALL_OW 276
75461: GO 75433
75463: POP
75464: POP
// buildings := GetBaseBuildings ( base , area ) ;
75465: LD_ADDR_VAR 0 18
75469: PUSH
75470: LD_VAR 0 15
75474: PPUSH
75475: LD_VAR 0 2
75479: PPUSH
75480: CALL 74757 0 2
75484: ST_TO_ADDR
// InitHc ;
75485: CALL_OW 19
// InitUc ;
75489: CALL_OW 18
// uc_side := side ;
75493: LD_ADDR_OWVAR 20
75497: PUSH
75498: LD_VAR 0 16
75502: ST_TO_ADDR
// uc_nation := nation ;
75503: LD_ADDR_OWVAR 21
75507: PUSH
75508: LD_VAR 0 17
75512: ST_TO_ADDR
// if buildings then
75513: LD_VAR 0 18
75517: IFFALSE 76839
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75519: LD_ADDR_VAR 0 19
75523: PUSH
75524: LD_VAR 0 18
75528: PPUSH
75529: LD_INT 2
75531: PUSH
75532: LD_INT 30
75534: PUSH
75535: LD_INT 29
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 30
75544: PUSH
75545: LD_INT 30
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: EMPTY
75553: LIST
75554: LIST
75555: LIST
75556: PPUSH
75557: CALL_OW 72
75561: ST_TO_ADDR
// if tmp then
75562: LD_VAR 0 19
75566: IFFALSE 75614
// for i in tmp do
75568: LD_ADDR_VAR 0 8
75572: PUSH
75573: LD_VAR 0 19
75577: PUSH
75578: FOR_IN
75579: IFFALSE 75612
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75581: LD_VAR 0 8
75585: PPUSH
75586: CALL_OW 250
75590: PPUSH
75591: LD_VAR 0 8
75595: PPUSH
75596: CALL_OW 251
75600: PPUSH
75601: LD_VAR 0 16
75605: PPUSH
75606: CALL_OW 441
75610: GO 75578
75612: POP
75613: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75614: LD_VAR 0 18
75618: PPUSH
75619: LD_INT 2
75621: PUSH
75622: LD_INT 30
75624: PUSH
75625: LD_INT 32
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 30
75634: PUSH
75635: LD_INT 33
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: LIST
75646: PPUSH
75647: CALL_OW 72
75651: IFFALSE 75739
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75653: LD_ADDR_VAR 0 8
75657: PUSH
75658: LD_VAR 0 18
75662: PPUSH
75663: LD_INT 2
75665: PUSH
75666: LD_INT 30
75668: PUSH
75669: LD_INT 32
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: PUSH
75676: LD_INT 30
75678: PUSH
75679: LD_INT 33
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: LIST
75690: PPUSH
75691: CALL_OW 72
75695: PUSH
75696: FOR_IN
75697: IFFALSE 75737
// begin if not GetBWeapon ( i ) then
75699: LD_VAR 0 8
75703: PPUSH
75704: CALL_OW 269
75708: NOT
75709: IFFALSE 75735
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75711: LD_VAR 0 8
75715: PPUSH
75716: LD_VAR 0 8
75720: PPUSH
75721: LD_VAR 0 2
75725: PPUSH
75726: CALL 76985 0 2
75730: PPUSH
75731: CALL_OW 431
// end ;
75735: GO 75696
75737: POP
75738: POP
// end ; for i = 1 to personel do
75739: LD_ADDR_VAR 0 8
75743: PUSH
75744: DOUBLE
75745: LD_INT 1
75747: DEC
75748: ST_TO_ADDR
75749: LD_VAR 0 6
75753: PUSH
75754: FOR_TO
75755: IFFALSE 76819
// begin if i > 4 then
75757: LD_VAR 0 8
75761: PUSH
75762: LD_INT 4
75764: GREATER
75765: IFFALSE 75769
// break ;
75767: GO 76819
// case i of 1 :
75769: LD_VAR 0 8
75773: PUSH
75774: LD_INT 1
75776: DOUBLE
75777: EQUAL
75778: IFTRUE 75782
75780: GO 75862
75782: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75783: LD_ADDR_VAR 0 12
75787: PUSH
75788: LD_VAR 0 18
75792: PPUSH
75793: LD_INT 22
75795: PUSH
75796: LD_VAR 0 16
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 58
75807: PUSH
75808: EMPTY
75809: LIST
75810: PUSH
75811: LD_INT 2
75813: PUSH
75814: LD_INT 30
75816: PUSH
75817: LD_INT 32
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 30
75826: PUSH
75827: LD_INT 4
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 30
75836: PUSH
75837: LD_INT 5
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: LIST
75848: LIST
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: LIST
75854: PPUSH
75855: CALL_OW 72
75859: ST_TO_ADDR
75860: GO 76084
75862: LD_INT 2
75864: DOUBLE
75865: EQUAL
75866: IFTRUE 75870
75868: GO 75932
75870: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75871: LD_ADDR_VAR 0 12
75875: PUSH
75876: LD_VAR 0 18
75880: PPUSH
75881: LD_INT 22
75883: PUSH
75884: LD_VAR 0 16
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 2
75895: PUSH
75896: LD_INT 30
75898: PUSH
75899: LD_INT 0
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: LD_INT 30
75908: PUSH
75909: LD_INT 1
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: LIST
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: PPUSH
75925: CALL_OW 72
75929: ST_TO_ADDR
75930: GO 76084
75932: LD_INT 3
75934: DOUBLE
75935: EQUAL
75936: IFTRUE 75940
75938: GO 76002
75940: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75941: LD_ADDR_VAR 0 12
75945: PUSH
75946: LD_VAR 0 18
75950: PPUSH
75951: LD_INT 22
75953: PUSH
75954: LD_VAR 0 16
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 2
75965: PUSH
75966: LD_INT 30
75968: PUSH
75969: LD_INT 2
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 30
75978: PUSH
75979: LD_INT 3
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: LIST
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PPUSH
75995: CALL_OW 72
75999: ST_TO_ADDR
76000: GO 76084
76002: LD_INT 4
76004: DOUBLE
76005: EQUAL
76006: IFTRUE 76010
76008: GO 76083
76010: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76011: LD_ADDR_VAR 0 12
76015: PUSH
76016: LD_VAR 0 18
76020: PPUSH
76021: LD_INT 22
76023: PUSH
76024: LD_VAR 0 16
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 2
76035: PUSH
76036: LD_INT 30
76038: PUSH
76039: LD_INT 6
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: PUSH
76046: LD_INT 30
76048: PUSH
76049: LD_INT 7
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 30
76058: PUSH
76059: LD_INT 8
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PPUSH
76076: CALL_OW 72
76080: ST_TO_ADDR
76081: GO 76084
76083: POP
// if i = 1 then
76084: LD_VAR 0 8
76088: PUSH
76089: LD_INT 1
76091: EQUAL
76092: IFFALSE 76203
// begin tmp := [ ] ;
76094: LD_ADDR_VAR 0 19
76098: PUSH
76099: EMPTY
76100: ST_TO_ADDR
// for j in f do
76101: LD_ADDR_VAR 0 9
76105: PUSH
76106: LD_VAR 0 12
76110: PUSH
76111: FOR_IN
76112: IFFALSE 76185
// if GetBType ( j ) = b_bunker then
76114: LD_VAR 0 9
76118: PPUSH
76119: CALL_OW 266
76123: PUSH
76124: LD_INT 32
76126: EQUAL
76127: IFFALSE 76154
// tmp := Insert ( tmp , 1 , j ) else
76129: LD_ADDR_VAR 0 19
76133: PUSH
76134: LD_VAR 0 19
76138: PPUSH
76139: LD_INT 1
76141: PPUSH
76142: LD_VAR 0 9
76146: PPUSH
76147: CALL_OW 2
76151: ST_TO_ADDR
76152: GO 76183
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76154: LD_ADDR_VAR 0 19
76158: PUSH
76159: LD_VAR 0 19
76163: PPUSH
76164: LD_VAR 0 19
76168: PUSH
76169: LD_INT 1
76171: PLUS
76172: PPUSH
76173: LD_VAR 0 9
76177: PPUSH
76178: CALL_OW 2
76182: ST_TO_ADDR
76183: GO 76111
76185: POP
76186: POP
// if tmp then
76187: LD_VAR 0 19
76191: IFFALSE 76203
// f := tmp ;
76193: LD_ADDR_VAR 0 12
76197: PUSH
76198: LD_VAR 0 19
76202: ST_TO_ADDR
// end ; x := personel [ i ] ;
76203: LD_ADDR_VAR 0 13
76207: PUSH
76208: LD_VAR 0 6
76212: PUSH
76213: LD_VAR 0 8
76217: ARRAY
76218: ST_TO_ADDR
// if x = - 1 then
76219: LD_VAR 0 13
76223: PUSH
76224: LD_INT 1
76226: NEG
76227: EQUAL
76228: IFFALSE 76437
// begin for j in f do
76230: LD_ADDR_VAR 0 9
76234: PUSH
76235: LD_VAR 0 12
76239: PUSH
76240: FOR_IN
76241: IFFALSE 76433
// repeat InitHc ;
76243: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76247: LD_VAR 0 9
76251: PPUSH
76252: CALL_OW 266
76256: PUSH
76257: LD_INT 5
76259: EQUAL
76260: IFFALSE 76330
// begin if UnitsInside ( j ) < 3 then
76262: LD_VAR 0 9
76266: PPUSH
76267: CALL_OW 313
76271: PUSH
76272: LD_INT 3
76274: LESS
76275: IFFALSE 76311
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76277: LD_INT 0
76279: PPUSH
76280: LD_INT 5
76282: PUSH
76283: LD_INT 8
76285: PUSH
76286: LD_INT 9
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: LIST
76293: PUSH
76294: LD_VAR 0 17
76298: ARRAY
76299: PPUSH
76300: LD_VAR 0 4
76304: PPUSH
76305: CALL_OW 380
76309: GO 76328
// PrepareHuman ( false , i , skill ) ;
76311: LD_INT 0
76313: PPUSH
76314: LD_VAR 0 8
76318: PPUSH
76319: LD_VAR 0 4
76323: PPUSH
76324: CALL_OW 380
// end else
76328: GO 76347
// PrepareHuman ( false , i , skill ) ;
76330: LD_INT 0
76332: PPUSH
76333: LD_VAR 0 8
76337: PPUSH
76338: LD_VAR 0 4
76342: PPUSH
76343: CALL_OW 380
// un := CreateHuman ;
76347: LD_ADDR_VAR 0 14
76351: PUSH
76352: CALL_OW 44
76356: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76357: LD_ADDR_VAR 0 7
76361: PUSH
76362: LD_VAR 0 7
76366: PPUSH
76367: LD_INT 1
76369: PPUSH
76370: LD_VAR 0 14
76374: PPUSH
76375: CALL_OW 2
76379: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76380: LD_VAR 0 14
76384: PPUSH
76385: LD_VAR 0 9
76389: PPUSH
76390: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76394: LD_VAR 0 9
76398: PPUSH
76399: CALL_OW 313
76403: PUSH
76404: LD_INT 6
76406: EQUAL
76407: PUSH
76408: LD_VAR 0 9
76412: PPUSH
76413: CALL_OW 266
76417: PUSH
76418: LD_INT 32
76420: PUSH
76421: LD_INT 31
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: IN
76428: OR
76429: IFFALSE 76243
76431: GO 76240
76433: POP
76434: POP
// end else
76435: GO 76817
// for j = 1 to x do
76437: LD_ADDR_VAR 0 9
76441: PUSH
76442: DOUBLE
76443: LD_INT 1
76445: DEC
76446: ST_TO_ADDR
76447: LD_VAR 0 13
76451: PUSH
76452: FOR_TO
76453: IFFALSE 76815
// begin InitHc ;
76455: CALL_OW 19
// if not f then
76459: LD_VAR 0 12
76463: NOT
76464: IFFALSE 76553
// begin PrepareHuman ( false , i , skill ) ;
76466: LD_INT 0
76468: PPUSH
76469: LD_VAR 0 8
76473: PPUSH
76474: LD_VAR 0 4
76478: PPUSH
76479: CALL_OW 380
// un := CreateHuman ;
76483: LD_ADDR_VAR 0 14
76487: PUSH
76488: CALL_OW 44
76492: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76493: LD_ADDR_VAR 0 7
76497: PUSH
76498: LD_VAR 0 7
76502: PPUSH
76503: LD_INT 1
76505: PPUSH
76506: LD_VAR 0 14
76510: PPUSH
76511: CALL_OW 2
76515: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76516: LD_VAR 0 14
76520: PPUSH
76521: LD_VAR 0 1
76525: PPUSH
76526: CALL_OW 250
76530: PPUSH
76531: LD_VAR 0 1
76535: PPUSH
76536: CALL_OW 251
76540: PPUSH
76541: LD_INT 10
76543: PPUSH
76544: LD_INT 0
76546: PPUSH
76547: CALL_OW 50
// continue ;
76551: GO 76452
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76553: LD_VAR 0 12
76557: PUSH
76558: LD_INT 1
76560: ARRAY
76561: PPUSH
76562: CALL_OW 313
76566: PUSH
76567: LD_VAR 0 12
76571: PUSH
76572: LD_INT 1
76574: ARRAY
76575: PPUSH
76576: CALL_OW 266
76580: PUSH
76581: LD_INT 32
76583: PUSH
76584: LD_INT 31
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: IN
76591: AND
76592: PUSH
76593: LD_VAR 0 12
76597: PUSH
76598: LD_INT 1
76600: ARRAY
76601: PPUSH
76602: CALL_OW 313
76606: PUSH
76607: LD_INT 6
76609: EQUAL
76610: OR
76611: IFFALSE 76631
// f := Delete ( f , 1 ) ;
76613: LD_ADDR_VAR 0 12
76617: PUSH
76618: LD_VAR 0 12
76622: PPUSH
76623: LD_INT 1
76625: PPUSH
76626: CALL_OW 3
76630: ST_TO_ADDR
// if not f then
76631: LD_VAR 0 12
76635: NOT
76636: IFFALSE 76654
// begin x := x + 2 ;
76638: LD_ADDR_VAR 0 13
76642: PUSH
76643: LD_VAR 0 13
76647: PUSH
76648: LD_INT 2
76650: PLUS
76651: ST_TO_ADDR
// continue ;
76652: GO 76452
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76654: LD_VAR 0 12
76658: PUSH
76659: LD_INT 1
76661: ARRAY
76662: PPUSH
76663: CALL_OW 266
76667: PUSH
76668: LD_INT 5
76670: EQUAL
76671: IFFALSE 76745
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76673: LD_VAR 0 12
76677: PUSH
76678: LD_INT 1
76680: ARRAY
76681: PPUSH
76682: CALL_OW 313
76686: PUSH
76687: LD_INT 3
76689: LESS
76690: IFFALSE 76726
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76692: LD_INT 0
76694: PPUSH
76695: LD_INT 5
76697: PUSH
76698: LD_INT 8
76700: PUSH
76701: LD_INT 9
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: LIST
76708: PUSH
76709: LD_VAR 0 17
76713: ARRAY
76714: PPUSH
76715: LD_VAR 0 4
76719: PPUSH
76720: CALL_OW 380
76724: GO 76743
// PrepareHuman ( false , i , skill ) ;
76726: LD_INT 0
76728: PPUSH
76729: LD_VAR 0 8
76733: PPUSH
76734: LD_VAR 0 4
76738: PPUSH
76739: CALL_OW 380
// end else
76743: GO 76762
// PrepareHuman ( false , i , skill ) ;
76745: LD_INT 0
76747: PPUSH
76748: LD_VAR 0 8
76752: PPUSH
76753: LD_VAR 0 4
76757: PPUSH
76758: CALL_OW 380
// un := CreateHuman ;
76762: LD_ADDR_VAR 0 14
76766: PUSH
76767: CALL_OW 44
76771: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76772: LD_ADDR_VAR 0 7
76776: PUSH
76777: LD_VAR 0 7
76781: PPUSH
76782: LD_INT 1
76784: PPUSH
76785: LD_VAR 0 14
76789: PPUSH
76790: CALL_OW 2
76794: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76795: LD_VAR 0 14
76799: PPUSH
76800: LD_VAR 0 12
76804: PUSH
76805: LD_INT 1
76807: ARRAY
76808: PPUSH
76809: CALL_OW 52
// end ;
76813: GO 76452
76815: POP
76816: POP
// end ;
76817: GO 75754
76819: POP
76820: POP
// result := result ^ buildings ;
76821: LD_ADDR_VAR 0 7
76825: PUSH
76826: LD_VAR 0 7
76830: PUSH
76831: LD_VAR 0 18
76835: ADD
76836: ST_TO_ADDR
// end else
76837: GO 76980
// begin for i = 1 to personel do
76839: LD_ADDR_VAR 0 8
76843: PUSH
76844: DOUBLE
76845: LD_INT 1
76847: DEC
76848: ST_TO_ADDR
76849: LD_VAR 0 6
76853: PUSH
76854: FOR_TO
76855: IFFALSE 76978
// begin if i > 4 then
76857: LD_VAR 0 8
76861: PUSH
76862: LD_INT 4
76864: GREATER
76865: IFFALSE 76869
// break ;
76867: GO 76978
// x := personel [ i ] ;
76869: LD_ADDR_VAR 0 13
76873: PUSH
76874: LD_VAR 0 6
76878: PUSH
76879: LD_VAR 0 8
76883: ARRAY
76884: ST_TO_ADDR
// if x = - 1 then
76885: LD_VAR 0 13
76889: PUSH
76890: LD_INT 1
76892: NEG
76893: EQUAL
76894: IFFALSE 76898
// continue ;
76896: GO 76854
// PrepareHuman ( false , i , skill ) ;
76898: LD_INT 0
76900: PPUSH
76901: LD_VAR 0 8
76905: PPUSH
76906: LD_VAR 0 4
76910: PPUSH
76911: CALL_OW 380
// un := CreateHuman ;
76915: LD_ADDR_VAR 0 14
76919: PUSH
76920: CALL_OW 44
76924: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76925: LD_VAR 0 14
76929: PPUSH
76930: LD_VAR 0 1
76934: PPUSH
76935: CALL_OW 250
76939: PPUSH
76940: LD_VAR 0 1
76944: PPUSH
76945: CALL_OW 251
76949: PPUSH
76950: LD_INT 10
76952: PPUSH
76953: LD_INT 0
76955: PPUSH
76956: CALL_OW 50
// result := result ^ un ;
76960: LD_ADDR_VAR 0 7
76964: PUSH
76965: LD_VAR 0 7
76969: PUSH
76970: LD_VAR 0 14
76974: ADD
76975: ST_TO_ADDR
// end ;
76976: GO 76854
76978: POP
76979: POP
// end ; end ;
76980: LD_VAR 0 7
76984: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76985: LD_INT 0
76987: PPUSH
76988: PPUSH
76989: PPUSH
76990: PPUSH
76991: PPUSH
76992: PPUSH
76993: PPUSH
76994: PPUSH
76995: PPUSH
76996: PPUSH
76997: PPUSH
76998: PPUSH
76999: PPUSH
77000: PPUSH
77001: PPUSH
77002: PPUSH
// result := false ;
77003: LD_ADDR_VAR 0 3
77007: PUSH
77008: LD_INT 0
77010: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77011: LD_VAR 0 1
77015: NOT
77016: PUSH
77017: LD_VAR 0 1
77021: PPUSH
77022: CALL_OW 266
77026: PUSH
77027: LD_INT 32
77029: PUSH
77030: LD_INT 33
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: IN
77037: NOT
77038: OR
77039: IFFALSE 77043
// exit ;
77041: GO 78179
// nat := GetNation ( tower ) ;
77043: LD_ADDR_VAR 0 12
77047: PUSH
77048: LD_VAR 0 1
77052: PPUSH
77053: CALL_OW 248
77057: ST_TO_ADDR
// side := GetSide ( tower ) ;
77058: LD_ADDR_VAR 0 16
77062: PUSH
77063: LD_VAR 0 1
77067: PPUSH
77068: CALL_OW 255
77072: ST_TO_ADDR
// x := GetX ( tower ) ;
77073: LD_ADDR_VAR 0 10
77077: PUSH
77078: LD_VAR 0 1
77082: PPUSH
77083: CALL_OW 250
77087: ST_TO_ADDR
// y := GetY ( tower ) ;
77088: LD_ADDR_VAR 0 11
77092: PUSH
77093: LD_VAR 0 1
77097: PPUSH
77098: CALL_OW 251
77102: ST_TO_ADDR
// if not x or not y then
77103: LD_VAR 0 10
77107: NOT
77108: PUSH
77109: LD_VAR 0 11
77113: NOT
77114: OR
77115: IFFALSE 77119
// exit ;
77117: GO 78179
// weapon := 0 ;
77119: LD_ADDR_VAR 0 18
77123: PUSH
77124: LD_INT 0
77126: ST_TO_ADDR
// fac_list := [ ] ;
77127: LD_ADDR_VAR 0 17
77131: PUSH
77132: EMPTY
77133: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
77134: LD_ADDR_VAR 0 6
77138: PUSH
77139: LD_VAR 0 1
77143: PPUSH
77144: CALL_OW 274
77148: PPUSH
77149: LD_VAR 0 2
77153: PPUSH
77154: CALL 74757 0 2
77158: PPUSH
77159: LD_INT 30
77161: PUSH
77162: LD_INT 3
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PPUSH
77169: CALL_OW 72
77173: ST_TO_ADDR
// if not factories then
77174: LD_VAR 0 6
77178: NOT
77179: IFFALSE 77183
// exit ;
77181: GO 78179
// for i in factories do
77183: LD_ADDR_VAR 0 8
77187: PUSH
77188: LD_VAR 0 6
77192: PUSH
77193: FOR_IN
77194: IFFALSE 77219
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77196: LD_ADDR_VAR 0 17
77200: PUSH
77201: LD_VAR 0 17
77205: PUSH
77206: LD_VAR 0 8
77210: PPUSH
77211: CALL_OW 478
77215: UNION
77216: ST_TO_ADDR
77217: GO 77193
77219: POP
77220: POP
// if not fac_list then
77221: LD_VAR 0 17
77225: NOT
77226: IFFALSE 77230
// exit ;
77228: GO 78179
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77230: LD_ADDR_VAR 0 5
77234: PUSH
77235: LD_INT 4
77237: PUSH
77238: LD_INT 5
77240: PUSH
77241: LD_INT 9
77243: PUSH
77244: LD_INT 10
77246: PUSH
77247: LD_INT 6
77249: PUSH
77250: LD_INT 7
77252: PUSH
77253: LD_INT 11
77255: PUSH
77256: EMPTY
77257: LIST
77258: LIST
77259: LIST
77260: LIST
77261: LIST
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 27
77267: PUSH
77268: LD_INT 28
77270: PUSH
77271: LD_INT 26
77273: PUSH
77274: LD_INT 30
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: PUSH
77283: LD_INT 43
77285: PUSH
77286: LD_INT 44
77288: PUSH
77289: LD_INT 46
77291: PUSH
77292: LD_INT 45
77294: PUSH
77295: LD_INT 47
77297: PUSH
77298: LD_INT 49
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: LIST
77305: LIST
77306: LIST
77307: LIST
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: LIST
77313: PUSH
77314: LD_VAR 0 12
77318: ARRAY
77319: ST_TO_ADDR
// for i in list do
77320: LD_ADDR_VAR 0 8
77324: PUSH
77325: LD_VAR 0 5
77329: PUSH
77330: FOR_IN
77331: IFFALSE 77364
// if not i in fac_list then
77333: LD_VAR 0 8
77337: PUSH
77338: LD_VAR 0 17
77342: IN
77343: NOT
77344: IFFALSE 77362
// list := list diff i ;
77346: LD_ADDR_VAR 0 5
77350: PUSH
77351: LD_VAR 0 5
77355: PUSH
77356: LD_VAR 0 8
77360: DIFF
77361: ST_TO_ADDR
77362: GO 77330
77364: POP
77365: POP
// if not list then
77366: LD_VAR 0 5
77370: NOT
77371: IFFALSE 77375
// exit ;
77373: GO 78179
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77375: LD_VAR 0 12
77379: PUSH
77380: LD_INT 3
77382: EQUAL
77383: PUSH
77384: LD_INT 49
77386: PUSH
77387: LD_VAR 0 5
77391: IN
77392: AND
77393: PUSH
77394: LD_INT 31
77396: PPUSH
77397: LD_VAR 0 16
77401: PPUSH
77402: CALL_OW 321
77406: PUSH
77407: LD_INT 2
77409: EQUAL
77410: AND
77411: IFFALSE 77471
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77413: LD_INT 22
77415: PUSH
77416: LD_VAR 0 16
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 35
77427: PUSH
77428: LD_INT 49
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 91
77437: PUSH
77438: LD_VAR 0 1
77442: PUSH
77443: LD_INT 10
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: LIST
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: LIST
77455: PPUSH
77456: CALL_OW 69
77460: NOT
77461: IFFALSE 77471
// weapon := ru_time_lapser ;
77463: LD_ADDR_VAR 0 18
77467: PUSH
77468: LD_INT 49
77470: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77471: LD_VAR 0 12
77475: PUSH
77476: LD_INT 1
77478: PUSH
77479: LD_INT 2
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: IN
77486: PUSH
77487: LD_INT 11
77489: PUSH
77490: LD_VAR 0 5
77494: IN
77495: PUSH
77496: LD_INT 30
77498: PUSH
77499: LD_VAR 0 5
77503: IN
77504: OR
77505: AND
77506: PUSH
77507: LD_INT 6
77509: PPUSH
77510: LD_VAR 0 16
77514: PPUSH
77515: CALL_OW 321
77519: PUSH
77520: LD_INT 2
77522: EQUAL
77523: AND
77524: IFFALSE 77689
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77526: LD_INT 22
77528: PUSH
77529: LD_VAR 0 16
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 2
77540: PUSH
77541: LD_INT 35
77543: PUSH
77544: LD_INT 11
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 35
77553: PUSH
77554: LD_INT 30
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: LIST
77565: PUSH
77566: LD_INT 91
77568: PUSH
77569: LD_VAR 0 1
77573: PUSH
77574: LD_INT 18
77576: PUSH
77577: EMPTY
77578: LIST
77579: LIST
77580: LIST
77581: PUSH
77582: EMPTY
77583: LIST
77584: LIST
77585: LIST
77586: PPUSH
77587: CALL_OW 69
77591: NOT
77592: PUSH
77593: LD_INT 22
77595: PUSH
77596: LD_VAR 0 16
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 2
77607: PUSH
77608: LD_INT 30
77610: PUSH
77611: LD_INT 32
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: LD_INT 30
77620: PUSH
77621: LD_INT 33
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PUSH
77628: EMPTY
77629: LIST
77630: LIST
77631: LIST
77632: PUSH
77633: LD_INT 91
77635: PUSH
77636: LD_VAR 0 1
77640: PUSH
77641: LD_INT 12
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: LIST
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: LIST
77653: PUSH
77654: EMPTY
77655: LIST
77656: PPUSH
77657: CALL_OW 69
77661: PUSH
77662: LD_INT 2
77664: GREATER
77665: AND
77666: IFFALSE 77689
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77668: LD_ADDR_VAR 0 18
77672: PUSH
77673: LD_INT 11
77675: PUSH
77676: LD_INT 30
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_VAR 0 12
77687: ARRAY
77688: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77689: LD_VAR 0 18
77693: NOT
77694: PUSH
77695: LD_INT 40
77697: PPUSH
77698: LD_VAR 0 16
77702: PPUSH
77703: CALL_OW 321
77707: PUSH
77708: LD_INT 2
77710: EQUAL
77711: AND
77712: PUSH
77713: LD_INT 7
77715: PUSH
77716: LD_VAR 0 5
77720: IN
77721: PUSH
77722: LD_INT 28
77724: PUSH
77725: LD_VAR 0 5
77729: IN
77730: OR
77731: PUSH
77732: LD_INT 45
77734: PUSH
77735: LD_VAR 0 5
77739: IN
77740: OR
77741: AND
77742: IFFALSE 77996
// begin hex := GetHexInfo ( x , y ) ;
77744: LD_ADDR_VAR 0 4
77748: PUSH
77749: LD_VAR 0 10
77753: PPUSH
77754: LD_VAR 0 11
77758: PPUSH
77759: CALL_OW 546
77763: ST_TO_ADDR
// if hex [ 1 ] then
77764: LD_VAR 0 4
77768: PUSH
77769: LD_INT 1
77771: ARRAY
77772: IFFALSE 77776
// exit ;
77774: GO 78179
// height := hex [ 2 ] ;
77776: LD_ADDR_VAR 0 15
77780: PUSH
77781: LD_VAR 0 4
77785: PUSH
77786: LD_INT 2
77788: ARRAY
77789: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77790: LD_ADDR_VAR 0 14
77794: PUSH
77795: LD_INT 0
77797: PUSH
77798: LD_INT 2
77800: PUSH
77801: LD_INT 3
77803: PUSH
77804: LD_INT 5
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: LIST
77811: LIST
77812: ST_TO_ADDR
// for i in tmp do
77813: LD_ADDR_VAR 0 8
77817: PUSH
77818: LD_VAR 0 14
77822: PUSH
77823: FOR_IN
77824: IFFALSE 77994
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77826: LD_ADDR_VAR 0 9
77830: PUSH
77831: LD_VAR 0 10
77835: PPUSH
77836: LD_VAR 0 8
77840: PPUSH
77841: LD_INT 5
77843: PPUSH
77844: CALL_OW 272
77848: PUSH
77849: LD_VAR 0 11
77853: PPUSH
77854: LD_VAR 0 8
77858: PPUSH
77859: LD_INT 5
77861: PPUSH
77862: CALL_OW 273
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77871: LD_VAR 0 9
77875: PUSH
77876: LD_INT 1
77878: ARRAY
77879: PPUSH
77880: LD_VAR 0 9
77884: PUSH
77885: LD_INT 2
77887: ARRAY
77888: PPUSH
77889: CALL_OW 488
77893: IFFALSE 77992
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77895: LD_ADDR_VAR 0 4
77899: PUSH
77900: LD_VAR 0 9
77904: PUSH
77905: LD_INT 1
77907: ARRAY
77908: PPUSH
77909: LD_VAR 0 9
77913: PUSH
77914: LD_INT 2
77916: ARRAY
77917: PPUSH
77918: CALL_OW 546
77922: ST_TO_ADDR
// if hex [ 1 ] then
77923: LD_VAR 0 4
77927: PUSH
77928: LD_INT 1
77930: ARRAY
77931: IFFALSE 77935
// continue ;
77933: GO 77823
// h := hex [ 2 ] ;
77935: LD_ADDR_VAR 0 13
77939: PUSH
77940: LD_VAR 0 4
77944: PUSH
77945: LD_INT 2
77947: ARRAY
77948: ST_TO_ADDR
// if h + 7 < height then
77949: LD_VAR 0 13
77953: PUSH
77954: LD_INT 7
77956: PLUS
77957: PUSH
77958: LD_VAR 0 15
77962: LESS
77963: IFFALSE 77992
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77965: LD_ADDR_VAR 0 18
77969: PUSH
77970: LD_INT 7
77972: PUSH
77973: LD_INT 28
77975: PUSH
77976: LD_INT 45
77978: PUSH
77979: EMPTY
77980: LIST
77981: LIST
77982: LIST
77983: PUSH
77984: LD_VAR 0 12
77988: ARRAY
77989: ST_TO_ADDR
// break ;
77990: GO 77994
// end ; end ; end ;
77992: GO 77823
77994: POP
77995: POP
// end ; if not weapon then
77996: LD_VAR 0 18
78000: NOT
78001: IFFALSE 78061
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78003: LD_ADDR_VAR 0 5
78007: PUSH
78008: LD_VAR 0 5
78012: PUSH
78013: LD_INT 11
78015: PUSH
78016: LD_INT 30
78018: PUSH
78019: LD_INT 49
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: LIST
78026: DIFF
78027: ST_TO_ADDR
// if not list then
78028: LD_VAR 0 5
78032: NOT
78033: IFFALSE 78037
// exit ;
78035: GO 78179
// weapon := list [ rand ( 1 , list ) ] ;
78037: LD_ADDR_VAR 0 18
78041: PUSH
78042: LD_VAR 0 5
78046: PUSH
78047: LD_INT 1
78049: PPUSH
78050: LD_VAR 0 5
78054: PPUSH
78055: CALL_OW 12
78059: ARRAY
78060: ST_TO_ADDR
// end ; if weapon then
78061: LD_VAR 0 18
78065: IFFALSE 78179
// begin tmp := CostOfWeapon ( weapon ) ;
78067: LD_ADDR_VAR 0 14
78071: PUSH
78072: LD_VAR 0 18
78076: PPUSH
78077: CALL_OW 451
78081: ST_TO_ADDR
// j := GetBase ( tower ) ;
78082: LD_ADDR_VAR 0 9
78086: PUSH
78087: LD_VAR 0 1
78091: PPUSH
78092: CALL_OW 274
78096: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78097: LD_VAR 0 9
78101: PPUSH
78102: LD_INT 1
78104: PPUSH
78105: CALL_OW 275
78109: PUSH
78110: LD_VAR 0 14
78114: PUSH
78115: LD_INT 1
78117: ARRAY
78118: GREATEREQUAL
78119: PUSH
78120: LD_VAR 0 9
78124: PPUSH
78125: LD_INT 2
78127: PPUSH
78128: CALL_OW 275
78132: PUSH
78133: LD_VAR 0 14
78137: PUSH
78138: LD_INT 2
78140: ARRAY
78141: GREATEREQUAL
78142: AND
78143: PUSH
78144: LD_VAR 0 9
78148: PPUSH
78149: LD_INT 3
78151: PPUSH
78152: CALL_OW 275
78156: PUSH
78157: LD_VAR 0 14
78161: PUSH
78162: LD_INT 3
78164: ARRAY
78165: GREATEREQUAL
78166: AND
78167: IFFALSE 78179
// result := weapon ;
78169: LD_ADDR_VAR 0 3
78173: PUSH
78174: LD_VAR 0 18
78178: ST_TO_ADDR
// end ; end ;
78179: LD_VAR 0 3
78183: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78184: LD_INT 0
78186: PPUSH
78187: PPUSH
// result := true ;
78188: LD_ADDR_VAR 0 3
78192: PUSH
78193: LD_INT 1
78195: ST_TO_ADDR
// if array1 = array2 then
78196: LD_VAR 0 1
78200: PUSH
78201: LD_VAR 0 2
78205: EQUAL
78206: IFFALSE 78266
// begin for i = 1 to array1 do
78208: LD_ADDR_VAR 0 4
78212: PUSH
78213: DOUBLE
78214: LD_INT 1
78216: DEC
78217: ST_TO_ADDR
78218: LD_VAR 0 1
78222: PUSH
78223: FOR_TO
78224: IFFALSE 78262
// if array1 [ i ] <> array2 [ i ] then
78226: LD_VAR 0 1
78230: PUSH
78231: LD_VAR 0 4
78235: ARRAY
78236: PUSH
78237: LD_VAR 0 2
78241: PUSH
78242: LD_VAR 0 4
78246: ARRAY
78247: NONEQUAL
78248: IFFALSE 78260
// begin result := false ;
78250: LD_ADDR_VAR 0 3
78254: PUSH
78255: LD_INT 0
78257: ST_TO_ADDR
// break ;
78258: GO 78262
// end ;
78260: GO 78223
78262: POP
78263: POP
// end else
78264: GO 78274
// result := false ;
78266: LD_ADDR_VAR 0 3
78270: PUSH
78271: LD_INT 0
78273: ST_TO_ADDR
// end ;
78274: LD_VAR 0 3
78278: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78279: LD_INT 0
78281: PPUSH
78282: PPUSH
78283: PPUSH
// pom := GetBase ( fac ) ;
78284: LD_ADDR_VAR 0 5
78288: PUSH
78289: LD_VAR 0 1
78293: PPUSH
78294: CALL_OW 274
78298: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78299: LD_ADDR_VAR 0 4
78303: PUSH
78304: LD_VAR 0 2
78308: PUSH
78309: LD_INT 1
78311: ARRAY
78312: PPUSH
78313: LD_VAR 0 2
78317: PUSH
78318: LD_INT 2
78320: ARRAY
78321: PPUSH
78322: LD_VAR 0 2
78326: PUSH
78327: LD_INT 3
78329: ARRAY
78330: PPUSH
78331: LD_VAR 0 2
78335: PUSH
78336: LD_INT 4
78338: ARRAY
78339: PPUSH
78340: CALL_OW 449
78344: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78345: LD_ADDR_VAR 0 3
78349: PUSH
78350: LD_VAR 0 5
78354: PPUSH
78355: LD_INT 1
78357: PPUSH
78358: CALL_OW 275
78362: PUSH
78363: LD_VAR 0 4
78367: PUSH
78368: LD_INT 1
78370: ARRAY
78371: GREATEREQUAL
78372: PUSH
78373: LD_VAR 0 5
78377: PPUSH
78378: LD_INT 2
78380: PPUSH
78381: CALL_OW 275
78385: PUSH
78386: LD_VAR 0 4
78390: PUSH
78391: LD_INT 2
78393: ARRAY
78394: GREATEREQUAL
78395: AND
78396: PUSH
78397: LD_VAR 0 5
78401: PPUSH
78402: LD_INT 3
78404: PPUSH
78405: CALL_OW 275
78409: PUSH
78410: LD_VAR 0 4
78414: PUSH
78415: LD_INT 3
78417: ARRAY
78418: GREATEREQUAL
78419: AND
78420: ST_TO_ADDR
// end ;
78421: LD_VAR 0 3
78425: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78426: LD_INT 0
78428: PPUSH
78429: PPUSH
78430: PPUSH
78431: PPUSH
// pom := GetBase ( building ) ;
78432: LD_ADDR_VAR 0 3
78436: PUSH
78437: LD_VAR 0 1
78441: PPUSH
78442: CALL_OW 274
78446: ST_TO_ADDR
// if not pom then
78447: LD_VAR 0 3
78451: NOT
78452: IFFALSE 78456
// exit ;
78454: GO 78626
// btype := GetBType ( building ) ;
78456: LD_ADDR_VAR 0 5
78460: PUSH
78461: LD_VAR 0 1
78465: PPUSH
78466: CALL_OW 266
78470: ST_TO_ADDR
// if btype = b_armoury then
78471: LD_VAR 0 5
78475: PUSH
78476: LD_INT 4
78478: EQUAL
78479: IFFALSE 78489
// btype := b_barracks ;
78481: LD_ADDR_VAR 0 5
78485: PUSH
78486: LD_INT 5
78488: ST_TO_ADDR
// if btype = b_depot then
78489: LD_VAR 0 5
78493: PUSH
78494: LD_INT 0
78496: EQUAL
78497: IFFALSE 78507
// btype := b_warehouse ;
78499: LD_ADDR_VAR 0 5
78503: PUSH
78504: LD_INT 1
78506: ST_TO_ADDR
// if btype = b_workshop then
78507: LD_VAR 0 5
78511: PUSH
78512: LD_INT 2
78514: EQUAL
78515: IFFALSE 78525
// btype := b_factory ;
78517: LD_ADDR_VAR 0 5
78521: PUSH
78522: LD_INT 3
78524: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78525: LD_ADDR_VAR 0 4
78529: PUSH
78530: LD_VAR 0 5
78534: PPUSH
78535: LD_VAR 0 1
78539: PPUSH
78540: CALL_OW 248
78544: PPUSH
78545: CALL_OW 450
78549: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78550: LD_ADDR_VAR 0 2
78554: PUSH
78555: LD_VAR 0 3
78559: PPUSH
78560: LD_INT 1
78562: PPUSH
78563: CALL_OW 275
78567: PUSH
78568: LD_VAR 0 4
78572: PUSH
78573: LD_INT 1
78575: ARRAY
78576: GREATEREQUAL
78577: PUSH
78578: LD_VAR 0 3
78582: PPUSH
78583: LD_INT 2
78585: PPUSH
78586: CALL_OW 275
78590: PUSH
78591: LD_VAR 0 4
78595: PUSH
78596: LD_INT 2
78598: ARRAY
78599: GREATEREQUAL
78600: AND
78601: PUSH
78602: LD_VAR 0 3
78606: PPUSH
78607: LD_INT 3
78609: PPUSH
78610: CALL_OW 275
78614: PUSH
78615: LD_VAR 0 4
78619: PUSH
78620: LD_INT 3
78622: ARRAY
78623: GREATEREQUAL
78624: AND
78625: ST_TO_ADDR
// end ;
78626: LD_VAR 0 2
78630: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78631: LD_INT 0
78633: PPUSH
78634: PPUSH
78635: PPUSH
// pom := GetBase ( building ) ;
78636: LD_ADDR_VAR 0 4
78640: PUSH
78641: LD_VAR 0 1
78645: PPUSH
78646: CALL_OW 274
78650: ST_TO_ADDR
// if not pom then
78651: LD_VAR 0 4
78655: NOT
78656: IFFALSE 78660
// exit ;
78658: GO 78761
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78660: LD_ADDR_VAR 0 5
78664: PUSH
78665: LD_VAR 0 2
78669: PPUSH
78670: LD_VAR 0 1
78674: PPUSH
78675: CALL_OW 248
78679: PPUSH
78680: CALL_OW 450
78684: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78685: LD_ADDR_VAR 0 3
78689: PUSH
78690: LD_VAR 0 4
78694: PPUSH
78695: LD_INT 1
78697: PPUSH
78698: CALL_OW 275
78702: PUSH
78703: LD_VAR 0 5
78707: PUSH
78708: LD_INT 1
78710: ARRAY
78711: GREATEREQUAL
78712: PUSH
78713: LD_VAR 0 4
78717: PPUSH
78718: LD_INT 2
78720: PPUSH
78721: CALL_OW 275
78725: PUSH
78726: LD_VAR 0 5
78730: PUSH
78731: LD_INT 2
78733: ARRAY
78734: GREATEREQUAL
78735: AND
78736: PUSH
78737: LD_VAR 0 4
78741: PPUSH
78742: LD_INT 3
78744: PPUSH
78745: CALL_OW 275
78749: PUSH
78750: LD_VAR 0 5
78754: PUSH
78755: LD_INT 3
78757: ARRAY
78758: GREATEREQUAL
78759: AND
78760: ST_TO_ADDR
// end ;
78761: LD_VAR 0 3
78765: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78766: LD_INT 0
78768: PPUSH
78769: PPUSH
78770: PPUSH
78771: PPUSH
78772: PPUSH
78773: PPUSH
78774: PPUSH
78775: PPUSH
78776: PPUSH
78777: PPUSH
// result := false ;
78778: LD_ADDR_VAR 0 6
78782: PUSH
78783: LD_INT 0
78785: ST_TO_ADDR
// if not base or not btype or not x or not y then
78786: LD_VAR 0 1
78790: NOT
78791: PUSH
78792: LD_VAR 0 2
78796: NOT
78797: OR
78798: PUSH
78799: LD_VAR 0 3
78803: NOT
78804: OR
78805: PUSH
78806: LD_VAR 0 4
78810: NOT
78811: OR
78812: IFFALSE 78816
// exit ;
78814: GO 79425
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78816: LD_ADDR_VAR 0 12
78820: PUSH
78821: LD_VAR 0 2
78825: PPUSH
78826: LD_VAR 0 3
78830: PPUSH
78831: LD_VAR 0 4
78835: PPUSH
78836: LD_VAR 0 5
78840: PPUSH
78841: LD_VAR 0 1
78845: PUSH
78846: LD_INT 1
78848: ARRAY
78849: PPUSH
78850: CALL_OW 248
78854: PPUSH
78855: LD_INT 0
78857: PPUSH
78858: CALL 80262 0 6
78862: ST_TO_ADDR
// if not hexes then
78863: LD_VAR 0 12
78867: NOT
78868: IFFALSE 78872
// exit ;
78870: GO 79425
// for i = 1 to hexes do
78872: LD_ADDR_VAR 0 7
78876: PUSH
78877: DOUBLE
78878: LD_INT 1
78880: DEC
78881: ST_TO_ADDR
78882: LD_VAR 0 12
78886: PUSH
78887: FOR_TO
78888: IFFALSE 79423
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78890: LD_ADDR_VAR 0 11
78894: PUSH
78895: LD_VAR 0 12
78899: PUSH
78900: LD_VAR 0 7
78904: ARRAY
78905: PUSH
78906: LD_INT 1
78908: ARRAY
78909: PPUSH
78910: LD_VAR 0 12
78914: PUSH
78915: LD_VAR 0 7
78919: ARRAY
78920: PUSH
78921: LD_INT 2
78923: ARRAY
78924: PPUSH
78925: CALL_OW 428
78929: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78930: LD_VAR 0 12
78934: PUSH
78935: LD_VAR 0 7
78939: ARRAY
78940: PUSH
78941: LD_INT 1
78943: ARRAY
78944: PPUSH
78945: LD_VAR 0 12
78949: PUSH
78950: LD_VAR 0 7
78954: ARRAY
78955: PUSH
78956: LD_INT 2
78958: ARRAY
78959: PPUSH
78960: CALL_OW 351
78964: PUSH
78965: LD_VAR 0 12
78969: PUSH
78970: LD_VAR 0 7
78974: ARRAY
78975: PUSH
78976: LD_INT 1
78978: ARRAY
78979: PPUSH
78980: LD_VAR 0 12
78984: PUSH
78985: LD_VAR 0 7
78989: ARRAY
78990: PUSH
78991: LD_INT 2
78993: ARRAY
78994: PPUSH
78995: CALL_OW 488
78999: NOT
79000: OR
79001: PUSH
79002: LD_VAR 0 11
79006: PPUSH
79007: CALL_OW 247
79011: PUSH
79012: LD_INT 3
79014: EQUAL
79015: OR
79016: IFFALSE 79022
// exit ;
79018: POP
79019: POP
79020: GO 79425
// if not tmp or not tmp in base then
79022: LD_VAR 0 11
79026: NOT
79027: PUSH
79028: LD_VAR 0 11
79032: PUSH
79033: LD_VAR 0 1
79037: IN
79038: NOT
79039: OR
79040: IFFALSE 79044
// continue ;
79042: GO 78887
// result := true ;
79044: LD_ADDR_VAR 0 6
79048: PUSH
79049: LD_INT 1
79051: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79052: LD_ADDR_VAR 0 15
79056: PUSH
79057: LD_VAR 0 1
79061: PPUSH
79062: LD_INT 22
79064: PUSH
79065: LD_VAR 0 11
79069: PPUSH
79070: CALL_OW 255
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 2
79081: PUSH
79082: LD_INT 30
79084: PUSH
79085: LD_INT 0
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 30
79094: PUSH
79095: LD_INT 1
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: LIST
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PPUSH
79111: CALL_OW 72
79115: ST_TO_ADDR
// if dep then
79116: LD_VAR 0 15
79120: IFFALSE 79256
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79122: LD_ADDR_VAR 0 14
79126: PUSH
79127: LD_VAR 0 15
79131: PUSH
79132: LD_INT 1
79134: ARRAY
79135: PPUSH
79136: CALL_OW 250
79140: PPUSH
79141: LD_VAR 0 15
79145: PUSH
79146: LD_INT 1
79148: ARRAY
79149: PPUSH
79150: CALL_OW 254
79154: PPUSH
79155: LD_INT 5
79157: PPUSH
79158: CALL_OW 272
79162: PUSH
79163: LD_VAR 0 15
79167: PUSH
79168: LD_INT 1
79170: ARRAY
79171: PPUSH
79172: CALL_OW 251
79176: PPUSH
79177: LD_VAR 0 15
79181: PUSH
79182: LD_INT 1
79184: ARRAY
79185: PPUSH
79186: CALL_OW 254
79190: PPUSH
79191: LD_INT 5
79193: PPUSH
79194: CALL_OW 273
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79203: LD_VAR 0 14
79207: PUSH
79208: LD_INT 1
79210: ARRAY
79211: PPUSH
79212: LD_VAR 0 14
79216: PUSH
79217: LD_INT 2
79219: ARRAY
79220: PPUSH
79221: CALL_OW 488
79225: IFFALSE 79256
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79227: LD_VAR 0 11
79231: PPUSH
79232: LD_VAR 0 14
79236: PUSH
79237: LD_INT 1
79239: ARRAY
79240: PPUSH
79241: LD_VAR 0 14
79245: PUSH
79246: LD_INT 2
79248: ARRAY
79249: PPUSH
79250: CALL_OW 111
// continue ;
79254: GO 78887
// end ; end ; r := GetDir ( tmp ) ;
79256: LD_ADDR_VAR 0 13
79260: PUSH
79261: LD_VAR 0 11
79265: PPUSH
79266: CALL_OW 254
79270: ST_TO_ADDR
// if r = 5 then
79271: LD_VAR 0 13
79275: PUSH
79276: LD_INT 5
79278: EQUAL
79279: IFFALSE 79289
// r := 0 ;
79281: LD_ADDR_VAR 0 13
79285: PUSH
79286: LD_INT 0
79288: ST_TO_ADDR
// for j = r to 5 do
79289: LD_ADDR_VAR 0 8
79293: PUSH
79294: DOUBLE
79295: LD_VAR 0 13
79299: DEC
79300: ST_TO_ADDR
79301: LD_INT 5
79303: PUSH
79304: FOR_TO
79305: IFFALSE 79419
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79307: LD_ADDR_VAR 0 9
79311: PUSH
79312: LD_VAR 0 11
79316: PPUSH
79317: CALL_OW 250
79321: PPUSH
79322: LD_VAR 0 8
79326: PPUSH
79327: LD_INT 2
79329: PPUSH
79330: CALL_OW 272
79334: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79335: LD_ADDR_VAR 0 10
79339: PUSH
79340: LD_VAR 0 11
79344: PPUSH
79345: CALL_OW 251
79349: PPUSH
79350: LD_VAR 0 8
79354: PPUSH
79355: LD_INT 2
79357: PPUSH
79358: CALL_OW 273
79362: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
79363: LD_VAR 0 9
79367: PPUSH
79368: LD_VAR 0 10
79372: PPUSH
79373: CALL_OW 488
79377: PUSH
79378: LD_VAR 0 9
79382: PPUSH
79383: LD_VAR 0 10
79387: PPUSH
79388: CALL_OW 428
79392: NOT
79393: AND
79394: IFFALSE 79417
// begin ComMoveXY ( tmp , _x , _y ) ;
79396: LD_VAR 0 11
79400: PPUSH
79401: LD_VAR 0 9
79405: PPUSH
79406: LD_VAR 0 10
79410: PPUSH
79411: CALL_OW 111
// break ;
79415: GO 79419
// end ; end ;
79417: GO 79304
79419: POP
79420: POP
// end ;
79421: GO 78887
79423: POP
79424: POP
// end ;
79425: LD_VAR 0 6
79429: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79430: LD_INT 0
79432: PPUSH
79433: PPUSH
79434: PPUSH
79435: PPUSH
79436: PPUSH
79437: PPUSH
79438: PPUSH
79439: PPUSH
79440: PPUSH
79441: PPUSH
// result := false ;
79442: LD_ADDR_VAR 0 6
79446: PUSH
79447: LD_INT 0
79449: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79450: LD_VAR 0 1
79454: NOT
79455: PUSH
79456: LD_VAR 0 1
79460: PPUSH
79461: CALL_OW 266
79465: PUSH
79466: LD_INT 0
79468: PUSH
79469: LD_INT 1
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: IN
79476: NOT
79477: OR
79478: PUSH
79479: LD_VAR 0 2
79483: NOT
79484: OR
79485: PUSH
79486: LD_VAR 0 5
79490: PUSH
79491: LD_INT 0
79493: PUSH
79494: LD_INT 1
79496: PUSH
79497: LD_INT 2
79499: PUSH
79500: LD_INT 3
79502: PUSH
79503: LD_INT 4
79505: PUSH
79506: LD_INT 5
79508: PUSH
79509: EMPTY
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: IN
79517: NOT
79518: OR
79519: PUSH
79520: LD_VAR 0 3
79524: PPUSH
79525: LD_VAR 0 4
79529: PPUSH
79530: CALL_OW 488
79534: NOT
79535: OR
79536: IFFALSE 79540
// exit ;
79538: GO 80257
// pom := GetBase ( depot ) ;
79540: LD_ADDR_VAR 0 10
79544: PUSH
79545: LD_VAR 0 1
79549: PPUSH
79550: CALL_OW 274
79554: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79555: LD_ADDR_VAR 0 11
79559: PUSH
79560: LD_VAR 0 2
79564: PPUSH
79565: LD_VAR 0 1
79569: PPUSH
79570: CALL_OW 248
79574: PPUSH
79575: CALL_OW 450
79579: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79580: LD_VAR 0 10
79584: PPUSH
79585: LD_INT 1
79587: PPUSH
79588: CALL_OW 275
79592: PUSH
79593: LD_VAR 0 11
79597: PUSH
79598: LD_INT 1
79600: ARRAY
79601: GREATEREQUAL
79602: PUSH
79603: LD_VAR 0 10
79607: PPUSH
79608: LD_INT 2
79610: PPUSH
79611: CALL_OW 275
79615: PUSH
79616: LD_VAR 0 11
79620: PUSH
79621: LD_INT 2
79623: ARRAY
79624: GREATEREQUAL
79625: AND
79626: PUSH
79627: LD_VAR 0 10
79631: PPUSH
79632: LD_INT 3
79634: PPUSH
79635: CALL_OW 275
79639: PUSH
79640: LD_VAR 0 11
79644: PUSH
79645: LD_INT 3
79647: ARRAY
79648: GREATEREQUAL
79649: AND
79650: NOT
79651: IFFALSE 79655
// exit ;
79653: GO 80257
// if GetBType ( depot ) = b_depot then
79655: LD_VAR 0 1
79659: PPUSH
79660: CALL_OW 266
79664: PUSH
79665: LD_INT 0
79667: EQUAL
79668: IFFALSE 79680
// dist := 28 else
79670: LD_ADDR_VAR 0 14
79674: PUSH
79675: LD_INT 28
79677: ST_TO_ADDR
79678: GO 79688
// dist := 36 ;
79680: LD_ADDR_VAR 0 14
79684: PUSH
79685: LD_INT 36
79687: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79688: LD_VAR 0 1
79692: PPUSH
79693: LD_VAR 0 3
79697: PPUSH
79698: LD_VAR 0 4
79702: PPUSH
79703: CALL_OW 297
79707: PUSH
79708: LD_VAR 0 14
79712: GREATER
79713: IFFALSE 79717
// exit ;
79715: GO 80257
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79717: LD_ADDR_VAR 0 12
79721: PUSH
79722: LD_VAR 0 2
79726: PPUSH
79727: LD_VAR 0 3
79731: PPUSH
79732: LD_VAR 0 4
79736: PPUSH
79737: LD_VAR 0 5
79741: PPUSH
79742: LD_VAR 0 1
79746: PPUSH
79747: CALL_OW 248
79751: PPUSH
79752: LD_INT 0
79754: PPUSH
79755: CALL 80262 0 6
79759: ST_TO_ADDR
// if not hexes then
79760: LD_VAR 0 12
79764: NOT
79765: IFFALSE 79769
// exit ;
79767: GO 80257
// hex := GetHexInfo ( x , y ) ;
79769: LD_ADDR_VAR 0 15
79773: PUSH
79774: LD_VAR 0 3
79778: PPUSH
79779: LD_VAR 0 4
79783: PPUSH
79784: CALL_OW 546
79788: ST_TO_ADDR
// if hex [ 1 ] then
79789: LD_VAR 0 15
79793: PUSH
79794: LD_INT 1
79796: ARRAY
79797: IFFALSE 79801
// exit ;
79799: GO 80257
// height := hex [ 2 ] ;
79801: LD_ADDR_VAR 0 13
79805: PUSH
79806: LD_VAR 0 15
79810: PUSH
79811: LD_INT 2
79813: ARRAY
79814: ST_TO_ADDR
// for i = 1 to hexes do
79815: LD_ADDR_VAR 0 7
79819: PUSH
79820: DOUBLE
79821: LD_INT 1
79823: DEC
79824: ST_TO_ADDR
79825: LD_VAR 0 12
79829: PUSH
79830: FOR_TO
79831: IFFALSE 80161
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79833: LD_VAR 0 12
79837: PUSH
79838: LD_VAR 0 7
79842: ARRAY
79843: PUSH
79844: LD_INT 1
79846: ARRAY
79847: PPUSH
79848: LD_VAR 0 12
79852: PUSH
79853: LD_VAR 0 7
79857: ARRAY
79858: PUSH
79859: LD_INT 2
79861: ARRAY
79862: PPUSH
79863: CALL_OW 488
79867: NOT
79868: PUSH
79869: LD_VAR 0 12
79873: PUSH
79874: LD_VAR 0 7
79878: ARRAY
79879: PUSH
79880: LD_INT 1
79882: ARRAY
79883: PPUSH
79884: LD_VAR 0 12
79888: PUSH
79889: LD_VAR 0 7
79893: ARRAY
79894: PUSH
79895: LD_INT 2
79897: ARRAY
79898: PPUSH
79899: CALL_OW 428
79903: PUSH
79904: LD_INT 0
79906: GREATER
79907: OR
79908: PUSH
79909: LD_VAR 0 12
79913: PUSH
79914: LD_VAR 0 7
79918: ARRAY
79919: PUSH
79920: LD_INT 1
79922: ARRAY
79923: PPUSH
79924: LD_VAR 0 12
79928: PUSH
79929: LD_VAR 0 7
79933: ARRAY
79934: PUSH
79935: LD_INT 2
79937: ARRAY
79938: PPUSH
79939: CALL_OW 351
79943: OR
79944: IFFALSE 79950
// exit ;
79946: POP
79947: POP
79948: GO 80257
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79950: LD_ADDR_VAR 0 8
79954: PUSH
79955: LD_VAR 0 12
79959: PUSH
79960: LD_VAR 0 7
79964: ARRAY
79965: PUSH
79966: LD_INT 1
79968: ARRAY
79969: PPUSH
79970: LD_VAR 0 12
79974: PUSH
79975: LD_VAR 0 7
79979: ARRAY
79980: PUSH
79981: LD_INT 2
79983: ARRAY
79984: PPUSH
79985: CALL_OW 546
79989: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79990: LD_VAR 0 8
79994: PUSH
79995: LD_INT 1
79997: ARRAY
79998: PUSH
79999: LD_VAR 0 8
80003: PUSH
80004: LD_INT 2
80006: ARRAY
80007: PUSH
80008: LD_VAR 0 13
80012: PUSH
80013: LD_INT 2
80015: PLUS
80016: GREATER
80017: OR
80018: PUSH
80019: LD_VAR 0 8
80023: PUSH
80024: LD_INT 2
80026: ARRAY
80027: PUSH
80028: LD_VAR 0 13
80032: PUSH
80033: LD_INT 2
80035: MINUS
80036: LESS
80037: OR
80038: PUSH
80039: LD_VAR 0 8
80043: PUSH
80044: LD_INT 3
80046: ARRAY
80047: PUSH
80048: LD_INT 0
80050: PUSH
80051: LD_INT 8
80053: PUSH
80054: LD_INT 9
80056: PUSH
80057: LD_INT 10
80059: PUSH
80060: LD_INT 11
80062: PUSH
80063: LD_INT 12
80065: PUSH
80066: LD_INT 13
80068: PUSH
80069: LD_INT 16
80071: PUSH
80072: LD_INT 17
80074: PUSH
80075: LD_INT 18
80077: PUSH
80078: LD_INT 19
80080: PUSH
80081: LD_INT 20
80083: PUSH
80084: LD_INT 21
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: IN
80102: NOT
80103: OR
80104: PUSH
80105: LD_VAR 0 8
80109: PUSH
80110: LD_INT 5
80112: ARRAY
80113: NOT
80114: OR
80115: PUSH
80116: LD_VAR 0 8
80120: PUSH
80121: LD_INT 6
80123: ARRAY
80124: PUSH
80125: LD_INT 1
80127: PUSH
80128: LD_INT 2
80130: PUSH
80131: LD_INT 7
80133: PUSH
80134: LD_INT 9
80136: PUSH
80137: LD_INT 10
80139: PUSH
80140: LD_INT 11
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: LIST
80150: IN
80151: NOT
80152: OR
80153: IFFALSE 80159
// exit ;
80155: POP
80156: POP
80157: GO 80257
// end ;
80159: GO 79830
80161: POP
80162: POP
// side := GetSide ( depot ) ;
80163: LD_ADDR_VAR 0 9
80167: PUSH
80168: LD_VAR 0 1
80172: PPUSH
80173: CALL_OW 255
80177: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80178: LD_VAR 0 9
80182: PPUSH
80183: LD_VAR 0 3
80187: PPUSH
80188: LD_VAR 0 4
80192: PPUSH
80193: LD_INT 20
80195: PPUSH
80196: CALL 72911 0 4
80200: PUSH
80201: LD_INT 4
80203: ARRAY
80204: IFFALSE 80208
// exit ;
80206: GO 80257
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
80208: LD_VAR 0 2
80212: PUSH
80213: LD_INT 29
80215: PUSH
80216: LD_INT 30
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: IN
80223: PUSH
80224: LD_VAR 0 3
80228: PPUSH
80229: LD_VAR 0 4
80233: PPUSH
80234: LD_VAR 0 9
80238: PPUSH
80239: CALL_OW 440
80243: NOT
80244: AND
80245: IFFALSE 80249
// exit ;
80247: GO 80257
// result := true ;
80249: LD_ADDR_VAR 0 6
80253: PUSH
80254: LD_INT 1
80256: ST_TO_ADDR
// end ;
80257: LD_VAR 0 6
80261: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
80262: LD_INT 0
80264: PPUSH
80265: PPUSH
80266: PPUSH
80267: PPUSH
80268: PPUSH
80269: PPUSH
80270: PPUSH
80271: PPUSH
80272: PPUSH
80273: PPUSH
80274: PPUSH
80275: PPUSH
80276: PPUSH
80277: PPUSH
80278: PPUSH
80279: PPUSH
80280: PPUSH
80281: PPUSH
80282: PPUSH
80283: PPUSH
80284: PPUSH
80285: PPUSH
80286: PPUSH
80287: PPUSH
80288: PPUSH
80289: PPUSH
80290: PPUSH
80291: PPUSH
80292: PPUSH
80293: PPUSH
80294: PPUSH
80295: PPUSH
80296: PPUSH
80297: PPUSH
80298: PPUSH
80299: PPUSH
80300: PPUSH
80301: PPUSH
80302: PPUSH
80303: PPUSH
80304: PPUSH
80305: PPUSH
80306: PPUSH
80307: PPUSH
80308: PPUSH
80309: PPUSH
80310: PPUSH
80311: PPUSH
80312: PPUSH
80313: PPUSH
80314: PPUSH
80315: PPUSH
80316: PPUSH
80317: PPUSH
80318: PPUSH
80319: PPUSH
80320: PPUSH
80321: PPUSH
// result = [ ] ;
80322: LD_ADDR_VAR 0 7
80326: PUSH
80327: EMPTY
80328: ST_TO_ADDR
// temp_list = [ ] ;
80329: LD_ADDR_VAR 0 9
80333: PUSH
80334: EMPTY
80335: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80336: LD_VAR 0 4
80340: PUSH
80341: LD_INT 0
80343: PUSH
80344: LD_INT 1
80346: PUSH
80347: LD_INT 2
80349: PUSH
80350: LD_INT 3
80352: PUSH
80353: LD_INT 4
80355: PUSH
80356: LD_INT 5
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: IN
80367: NOT
80368: PUSH
80369: LD_VAR 0 1
80373: PUSH
80374: LD_INT 0
80376: PUSH
80377: LD_INT 1
80379: PUSH
80380: EMPTY
80381: LIST
80382: LIST
80383: IN
80384: PUSH
80385: LD_VAR 0 5
80389: PUSH
80390: LD_INT 1
80392: PUSH
80393: LD_INT 2
80395: PUSH
80396: LD_INT 3
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: LIST
80403: IN
80404: NOT
80405: AND
80406: OR
80407: IFFALSE 80411
// exit ;
80409: GO 98802
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80411: LD_VAR 0 1
80415: PUSH
80416: LD_INT 6
80418: PUSH
80419: LD_INT 7
80421: PUSH
80422: LD_INT 8
80424: PUSH
80425: LD_INT 13
80427: PUSH
80428: LD_INT 12
80430: PUSH
80431: LD_INT 15
80433: PUSH
80434: LD_INT 11
80436: PUSH
80437: LD_INT 14
80439: PUSH
80440: LD_INT 10
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: IN
80454: IFFALSE 80464
// btype = b_lab ;
80456: LD_ADDR_VAR 0 1
80460: PUSH
80461: LD_INT 6
80463: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80464: LD_VAR 0 6
80468: PUSH
80469: LD_INT 0
80471: PUSH
80472: LD_INT 1
80474: PUSH
80475: LD_INT 2
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: LIST
80482: IN
80483: NOT
80484: PUSH
80485: LD_VAR 0 1
80489: PUSH
80490: LD_INT 0
80492: PUSH
80493: LD_INT 1
80495: PUSH
80496: LD_INT 2
80498: PUSH
80499: LD_INT 3
80501: PUSH
80502: LD_INT 6
80504: PUSH
80505: LD_INT 36
80507: PUSH
80508: LD_INT 4
80510: PUSH
80511: LD_INT 5
80513: PUSH
80514: LD_INT 31
80516: PUSH
80517: LD_INT 32
80519: PUSH
80520: LD_INT 33
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: IN
80536: NOT
80537: PUSH
80538: LD_VAR 0 6
80542: PUSH
80543: LD_INT 1
80545: EQUAL
80546: AND
80547: OR
80548: PUSH
80549: LD_VAR 0 1
80553: PUSH
80554: LD_INT 2
80556: PUSH
80557: LD_INT 3
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: IN
80564: NOT
80565: PUSH
80566: LD_VAR 0 6
80570: PUSH
80571: LD_INT 2
80573: EQUAL
80574: AND
80575: OR
80576: IFFALSE 80586
// mode = 0 ;
80578: LD_ADDR_VAR 0 6
80582: PUSH
80583: LD_INT 0
80585: ST_TO_ADDR
// case mode of 0 :
80586: LD_VAR 0 6
80590: PUSH
80591: LD_INT 0
80593: DOUBLE
80594: EQUAL
80595: IFTRUE 80599
80597: GO 92052
80599: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80600: LD_ADDR_VAR 0 11
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: LD_INT 0
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 0
80617: PUSH
80618: LD_INT 1
80620: NEG
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 1
80628: PUSH
80629: LD_INT 0
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 1
80638: PUSH
80639: LD_INT 1
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 0
80648: PUSH
80649: LD_INT 1
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 1
80658: NEG
80659: PUSH
80660: LD_INT 0
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 1
80669: NEG
80670: PUSH
80671: LD_INT 1
80673: NEG
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: PUSH
80679: LD_INT 1
80681: NEG
80682: PUSH
80683: LD_INT 2
80685: NEG
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 0
80693: PUSH
80694: LD_INT 2
80696: NEG
80697: PUSH
80698: EMPTY
80699: LIST
80700: LIST
80701: PUSH
80702: LD_INT 1
80704: PUSH
80705: LD_INT 1
80707: NEG
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PUSH
80713: LD_INT 1
80715: PUSH
80716: LD_INT 2
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 0
80725: PUSH
80726: LD_INT 2
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: PUSH
80733: LD_INT 1
80735: NEG
80736: PUSH
80737: LD_INT 1
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 1
80746: PUSH
80747: LD_INT 3
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PUSH
80754: LD_INT 0
80756: PUSH
80757: LD_INT 3
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 1
80766: NEG
80767: PUSH
80768: LD_INT 2
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: LIST
80783: LIST
80784: LIST
80785: LIST
80786: LIST
80787: LIST
80788: LIST
80789: LIST
80790: LIST
80791: LIST
80792: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80793: LD_ADDR_VAR 0 12
80797: PUSH
80798: LD_INT 0
80800: PUSH
80801: LD_INT 0
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 0
80810: PUSH
80811: LD_INT 1
80813: NEG
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 1
80821: PUSH
80822: LD_INT 0
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 1
80831: PUSH
80832: LD_INT 1
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: LD_INT 1
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 1
80851: NEG
80852: PUSH
80853: LD_INT 0
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: PUSH
80860: LD_INT 1
80862: NEG
80863: PUSH
80864: LD_INT 1
80866: NEG
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: LD_INT 1
80874: PUSH
80875: LD_INT 1
80877: NEG
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: LD_INT 2
80885: PUSH
80886: LD_INT 0
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 2
80895: PUSH
80896: LD_INT 1
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: NEG
80906: PUSH
80907: LD_INT 1
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 2
80916: NEG
80917: PUSH
80918: LD_INT 0
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 2
80927: NEG
80928: PUSH
80929: LD_INT 1
80931: NEG
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 2
80939: NEG
80940: PUSH
80941: LD_INT 1
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 3
80950: NEG
80951: PUSH
80952: LD_INT 0
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 3
80961: NEG
80962: PUSH
80963: LD_INT 1
80965: NEG
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80989: LD_ADDR_VAR 0 13
80993: PUSH
80994: LD_INT 0
80996: PUSH
80997: LD_INT 0
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 0
81006: PUSH
81007: LD_INT 1
81009: NEG
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 1
81017: PUSH
81018: LD_INT 0
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: LD_INT 1
81027: PUSH
81028: LD_INT 1
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PUSH
81035: LD_INT 0
81037: PUSH
81038: LD_INT 1
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 1
81047: NEG
81048: PUSH
81049: LD_INT 0
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 1
81058: NEG
81059: PUSH
81060: LD_INT 1
81062: NEG
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 1
81070: NEG
81071: PUSH
81072: LD_INT 2
81074: NEG
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 2
81082: PUSH
81083: LD_INT 1
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 2
81092: PUSH
81093: LD_INT 2
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 1
81102: PUSH
81103: LD_INT 2
81105: PUSH
81106: EMPTY
81107: LIST
81108: LIST
81109: PUSH
81110: LD_INT 2
81112: NEG
81113: PUSH
81114: LD_INT 1
81116: NEG
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: PUSH
81122: LD_INT 2
81124: NEG
81125: PUSH
81126: LD_INT 2
81128: NEG
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 2
81136: NEG
81137: PUSH
81138: LD_INT 3
81140: NEG
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 3
81148: NEG
81149: PUSH
81150: LD_INT 2
81152: NEG
81153: PUSH
81154: EMPTY
81155: LIST
81156: LIST
81157: PUSH
81158: LD_INT 3
81160: NEG
81161: PUSH
81162: LD_INT 3
81164: NEG
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: PUSH
81170: EMPTY
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81188: LD_ADDR_VAR 0 14
81192: PUSH
81193: LD_INT 0
81195: PUSH
81196: LD_INT 0
81198: PUSH
81199: EMPTY
81200: LIST
81201: LIST
81202: PUSH
81203: LD_INT 0
81205: PUSH
81206: LD_INT 1
81208: NEG
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 1
81216: PUSH
81217: LD_INT 0
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 1
81226: PUSH
81227: LD_INT 1
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 0
81236: PUSH
81237: LD_INT 1
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 1
81246: NEG
81247: PUSH
81248: LD_INT 0
81250: PUSH
81251: EMPTY
81252: LIST
81253: LIST
81254: PUSH
81255: LD_INT 1
81257: NEG
81258: PUSH
81259: LD_INT 1
81261: NEG
81262: PUSH
81263: EMPTY
81264: LIST
81265: LIST
81266: PUSH
81267: LD_INT 1
81269: NEG
81270: PUSH
81271: LD_INT 2
81273: NEG
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 0
81281: PUSH
81282: LD_INT 2
81284: NEG
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 1
81292: PUSH
81293: LD_INT 1
81295: NEG
81296: PUSH
81297: EMPTY
81298: LIST
81299: LIST
81300: PUSH
81301: LD_INT 1
81303: PUSH
81304: LD_INT 2
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_INT 0
81313: PUSH
81314: LD_INT 2
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 1
81323: NEG
81324: PUSH
81325: LD_INT 1
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: PUSH
81332: LD_INT 1
81334: NEG
81335: PUSH
81336: LD_INT 3
81338: NEG
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 0
81346: PUSH
81347: LD_INT 3
81349: NEG
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 1
81357: PUSH
81358: LD_INT 2
81360: NEG
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81384: LD_ADDR_VAR 0 15
81388: PUSH
81389: LD_INT 0
81391: PUSH
81392: LD_INT 0
81394: PUSH
81395: EMPTY
81396: LIST
81397: LIST
81398: PUSH
81399: LD_INT 0
81401: PUSH
81402: LD_INT 1
81404: NEG
81405: PUSH
81406: EMPTY
81407: LIST
81408: LIST
81409: PUSH
81410: LD_INT 1
81412: PUSH
81413: LD_INT 0
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 1
81422: PUSH
81423: LD_INT 1
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 0
81432: PUSH
81433: LD_INT 1
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: LD_INT 1
81442: NEG
81443: PUSH
81444: LD_INT 0
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 1
81453: NEG
81454: PUSH
81455: LD_INT 1
81457: NEG
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 1
81465: PUSH
81466: LD_INT 1
81468: NEG
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 2
81476: PUSH
81477: LD_INT 0
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 2
81486: PUSH
81487: LD_INT 1
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 1
81496: NEG
81497: PUSH
81498: LD_INT 1
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: PUSH
81505: LD_INT 2
81507: NEG
81508: PUSH
81509: LD_INT 0
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: LD_INT 2
81518: NEG
81519: PUSH
81520: LD_INT 1
81522: NEG
81523: PUSH
81524: EMPTY
81525: LIST
81526: LIST
81527: PUSH
81528: LD_INT 2
81530: PUSH
81531: LD_INT 1
81533: NEG
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: PUSH
81539: LD_INT 3
81541: PUSH
81542: LD_INT 0
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: PUSH
81549: LD_INT 3
81551: PUSH
81552: LD_INT 1
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: LIST
81563: LIST
81564: LIST
81565: LIST
81566: LIST
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: LIST
81572: LIST
81573: LIST
81574: LIST
81575: LIST
81576: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81577: LD_ADDR_VAR 0 16
81581: PUSH
81582: LD_INT 0
81584: PUSH
81585: LD_INT 0
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 0
81594: PUSH
81595: LD_INT 1
81597: NEG
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 1
81605: PUSH
81606: LD_INT 0
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 1
81615: PUSH
81616: LD_INT 1
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 0
81625: PUSH
81626: LD_INT 1
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 1
81635: NEG
81636: PUSH
81637: LD_INT 0
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 1
81646: NEG
81647: PUSH
81648: LD_INT 1
81650: NEG
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 1
81658: NEG
81659: PUSH
81660: LD_INT 2
81662: NEG
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 2
81670: PUSH
81671: LD_INT 1
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 2
81680: PUSH
81681: LD_INT 2
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: LD_INT 1
81690: PUSH
81691: LD_INT 2
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 2
81700: NEG
81701: PUSH
81702: LD_INT 1
81704: NEG
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 2
81712: NEG
81713: PUSH
81714: LD_INT 2
81716: NEG
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: PUSH
81722: LD_INT 3
81724: PUSH
81725: LD_INT 2
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: PUSH
81732: LD_INT 3
81734: PUSH
81735: LD_INT 3
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 2
81744: PUSH
81745: LD_INT 3
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81770: LD_ADDR_VAR 0 17
81774: PUSH
81775: LD_INT 0
81777: PUSH
81778: LD_INT 0
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 0
81787: PUSH
81788: LD_INT 1
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 1
81798: PUSH
81799: LD_INT 0
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 1
81808: PUSH
81809: LD_INT 1
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 0
81818: PUSH
81819: LD_INT 1
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 1
81828: NEG
81829: PUSH
81830: LD_INT 0
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: PUSH
81837: LD_INT 1
81839: NEG
81840: PUSH
81841: LD_INT 1
81843: NEG
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: LD_INT 1
81851: NEG
81852: PUSH
81853: LD_INT 2
81855: NEG
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 0
81863: PUSH
81864: LD_INT 2
81866: NEG
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 1
81874: PUSH
81875: LD_INT 1
81877: NEG
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 2
81885: PUSH
81886: LD_INT 0
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_INT 2
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 2
81905: PUSH
81906: LD_INT 2
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 1
81915: PUSH
81916: LD_INT 2
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 0
81925: PUSH
81926: LD_INT 2
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 1
81935: NEG
81936: PUSH
81937: LD_INT 1
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: LD_INT 2
81946: NEG
81947: PUSH
81948: LD_INT 0
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 2
81957: NEG
81958: PUSH
81959: LD_INT 1
81961: NEG
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: LD_INT 2
81969: NEG
81970: PUSH
81971: LD_INT 2
81973: NEG
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82000: LD_ADDR_VAR 0 18
82004: PUSH
82005: LD_INT 0
82007: PUSH
82008: LD_INT 0
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 0
82017: PUSH
82018: LD_INT 1
82020: NEG
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: LD_INT 1
82028: PUSH
82029: LD_INT 0
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 1
82038: PUSH
82039: LD_INT 1
82041: PUSH
82042: EMPTY
82043: LIST
82044: LIST
82045: PUSH
82046: LD_INT 0
82048: PUSH
82049: LD_INT 1
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: PUSH
82056: LD_INT 1
82058: NEG
82059: PUSH
82060: LD_INT 0
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 1
82069: NEG
82070: PUSH
82071: LD_INT 1
82073: NEG
82074: PUSH
82075: EMPTY
82076: LIST
82077: LIST
82078: PUSH
82079: LD_INT 1
82081: NEG
82082: PUSH
82083: LD_INT 2
82085: NEG
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 0
82093: PUSH
82094: LD_INT 2
82096: NEG
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 1
82104: PUSH
82105: LD_INT 1
82107: NEG
82108: PUSH
82109: EMPTY
82110: LIST
82111: LIST
82112: PUSH
82113: LD_INT 2
82115: PUSH
82116: LD_INT 0
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 2
82125: PUSH
82126: LD_INT 1
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 2
82135: PUSH
82136: LD_INT 2
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: PUSH
82143: LD_INT 1
82145: PUSH
82146: LD_INT 2
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 0
82155: PUSH
82156: LD_INT 2
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 1
82165: NEG
82166: PUSH
82167: LD_INT 1
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 2
82176: NEG
82177: PUSH
82178: LD_INT 0
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 2
82187: NEG
82188: PUSH
82189: LD_INT 1
82191: NEG
82192: PUSH
82193: EMPTY
82194: LIST
82195: LIST
82196: PUSH
82197: LD_INT 2
82199: NEG
82200: PUSH
82201: LD_INT 2
82203: NEG
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82230: LD_ADDR_VAR 0 19
82234: PUSH
82235: LD_INT 0
82237: PUSH
82238: LD_INT 0
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: PUSH
82245: LD_INT 0
82247: PUSH
82248: LD_INT 1
82250: NEG
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PUSH
82256: LD_INT 1
82258: PUSH
82259: LD_INT 0
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 1
82268: PUSH
82269: LD_INT 1
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PUSH
82276: LD_INT 0
82278: PUSH
82279: LD_INT 1
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 1
82288: NEG
82289: PUSH
82290: LD_INT 0
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 1
82299: NEG
82300: PUSH
82301: LD_INT 1
82303: NEG
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: LD_INT 1
82311: NEG
82312: PUSH
82313: LD_INT 2
82315: NEG
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 0
82323: PUSH
82324: LD_INT 2
82326: NEG
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 1
82334: PUSH
82335: LD_INT 1
82337: NEG
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 2
82345: PUSH
82346: LD_INT 0
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 2
82355: PUSH
82356: LD_INT 1
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: LD_INT 2
82365: PUSH
82366: LD_INT 2
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: PUSH
82373: LD_INT 1
82375: PUSH
82376: LD_INT 2
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 0
82385: PUSH
82386: LD_INT 2
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 1
82395: NEG
82396: PUSH
82397: LD_INT 1
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 2
82406: NEG
82407: PUSH
82408: LD_INT 0
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 2
82417: NEG
82418: PUSH
82419: LD_INT 1
82421: NEG
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 2
82429: NEG
82430: PUSH
82431: LD_INT 2
82433: NEG
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: LIST
82443: LIST
82444: LIST
82445: LIST
82446: LIST
82447: LIST
82448: LIST
82449: LIST
82450: LIST
82451: LIST
82452: LIST
82453: LIST
82454: LIST
82455: LIST
82456: LIST
82457: LIST
82458: LIST
82459: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82460: LD_ADDR_VAR 0 20
82464: PUSH
82465: LD_INT 0
82467: PUSH
82468: LD_INT 0
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: PUSH
82475: LD_INT 0
82477: PUSH
82478: LD_INT 1
82480: NEG
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 1
82488: PUSH
82489: LD_INT 0
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 1
82498: PUSH
82499: LD_INT 1
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 0
82508: PUSH
82509: LD_INT 1
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: LD_INT 1
82518: NEG
82519: PUSH
82520: LD_INT 0
82522: PUSH
82523: EMPTY
82524: LIST
82525: LIST
82526: PUSH
82527: LD_INT 1
82529: NEG
82530: PUSH
82531: LD_INT 1
82533: NEG
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: PUSH
82539: LD_INT 1
82541: NEG
82542: PUSH
82543: LD_INT 2
82545: NEG
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: LD_INT 2
82556: NEG
82557: PUSH
82558: EMPTY
82559: LIST
82560: LIST
82561: PUSH
82562: LD_INT 1
82564: PUSH
82565: LD_INT 1
82567: NEG
82568: PUSH
82569: EMPTY
82570: LIST
82571: LIST
82572: PUSH
82573: LD_INT 2
82575: PUSH
82576: LD_INT 0
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 2
82585: PUSH
82586: LD_INT 1
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 2
82595: PUSH
82596: LD_INT 2
82598: PUSH
82599: EMPTY
82600: LIST
82601: LIST
82602: PUSH
82603: LD_INT 1
82605: PUSH
82606: LD_INT 2
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 0
82615: PUSH
82616: LD_INT 2
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 1
82625: NEG
82626: PUSH
82627: LD_INT 1
82629: PUSH
82630: EMPTY
82631: LIST
82632: LIST
82633: PUSH
82634: LD_INT 2
82636: NEG
82637: PUSH
82638: LD_INT 0
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 2
82647: NEG
82648: PUSH
82649: LD_INT 1
82651: NEG
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: LD_INT 2
82659: NEG
82660: PUSH
82661: LD_INT 2
82663: NEG
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: LIST
82689: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82690: LD_ADDR_VAR 0 21
82694: PUSH
82695: LD_INT 0
82697: PUSH
82698: LD_INT 0
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 0
82707: PUSH
82708: LD_INT 1
82710: NEG
82711: PUSH
82712: EMPTY
82713: LIST
82714: LIST
82715: PUSH
82716: LD_INT 1
82718: PUSH
82719: LD_INT 0
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: LD_INT 1
82728: PUSH
82729: LD_INT 1
82731: PUSH
82732: EMPTY
82733: LIST
82734: LIST
82735: PUSH
82736: LD_INT 0
82738: PUSH
82739: LD_INT 1
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PUSH
82746: LD_INT 1
82748: NEG
82749: PUSH
82750: LD_INT 0
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: LD_INT 1
82759: NEG
82760: PUSH
82761: LD_INT 1
82763: NEG
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 1
82771: NEG
82772: PUSH
82773: LD_INT 2
82775: NEG
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 0
82783: PUSH
82784: LD_INT 2
82786: NEG
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 1
82794: PUSH
82795: LD_INT 1
82797: NEG
82798: PUSH
82799: EMPTY
82800: LIST
82801: LIST
82802: PUSH
82803: LD_INT 2
82805: PUSH
82806: LD_INT 0
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 2
82815: PUSH
82816: LD_INT 1
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 2
82825: PUSH
82826: LD_INT 2
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 1
82835: PUSH
82836: LD_INT 2
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 0
82845: PUSH
82846: LD_INT 2
82848: PUSH
82849: EMPTY
82850: LIST
82851: LIST
82852: PUSH
82853: LD_INT 1
82855: NEG
82856: PUSH
82857: LD_INT 1
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: LD_INT 2
82866: NEG
82867: PUSH
82868: LD_INT 0
82870: PUSH
82871: EMPTY
82872: LIST
82873: LIST
82874: PUSH
82875: LD_INT 2
82877: NEG
82878: PUSH
82879: LD_INT 1
82881: NEG
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 2
82889: NEG
82890: PUSH
82891: LD_INT 2
82893: NEG
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82920: LD_ADDR_VAR 0 22
82924: PUSH
82925: LD_INT 0
82927: PUSH
82928: LD_INT 0
82930: PUSH
82931: EMPTY
82932: LIST
82933: LIST
82934: PUSH
82935: LD_INT 0
82937: PUSH
82938: LD_INT 1
82940: NEG
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 1
82948: PUSH
82949: LD_INT 0
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 1
82958: PUSH
82959: LD_INT 1
82961: PUSH
82962: EMPTY
82963: LIST
82964: LIST
82965: PUSH
82966: LD_INT 0
82968: PUSH
82969: LD_INT 1
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: PUSH
82976: LD_INT 1
82978: NEG
82979: PUSH
82980: LD_INT 0
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 1
82989: NEG
82990: PUSH
82991: LD_INT 1
82993: NEG
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 1
83001: NEG
83002: PUSH
83003: LD_INT 2
83005: NEG
83006: PUSH
83007: EMPTY
83008: LIST
83009: LIST
83010: PUSH
83011: LD_INT 0
83013: PUSH
83014: LD_INT 2
83016: NEG
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 1
83024: PUSH
83025: LD_INT 1
83027: NEG
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 2
83035: PUSH
83036: LD_INT 0
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 2
83045: PUSH
83046: LD_INT 1
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 2
83055: PUSH
83056: LD_INT 2
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 1
83065: PUSH
83066: LD_INT 2
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 0
83075: PUSH
83076: LD_INT 2
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: PUSH
83083: LD_INT 1
83085: NEG
83086: PUSH
83087: LD_INT 1
83089: PUSH
83090: EMPTY
83091: LIST
83092: LIST
83093: PUSH
83094: LD_INT 2
83096: NEG
83097: PUSH
83098: LD_INT 0
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: PUSH
83105: LD_INT 2
83107: NEG
83108: PUSH
83109: LD_INT 1
83111: NEG
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 2
83119: NEG
83120: PUSH
83121: LD_INT 2
83123: NEG
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
83150: LD_ADDR_VAR 0 23
83154: PUSH
83155: LD_INT 0
83157: PUSH
83158: LD_INT 0
83160: PUSH
83161: EMPTY
83162: LIST
83163: LIST
83164: PUSH
83165: LD_INT 0
83167: PUSH
83168: LD_INT 1
83170: NEG
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: LD_INT 1
83178: PUSH
83179: LD_INT 0
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PUSH
83186: LD_INT 1
83188: PUSH
83189: LD_INT 1
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 0
83198: PUSH
83199: LD_INT 1
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 1
83208: NEG
83209: PUSH
83210: LD_INT 0
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 1
83219: NEG
83220: PUSH
83221: LD_INT 1
83223: NEG
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 1
83231: NEG
83232: PUSH
83233: LD_INT 2
83235: NEG
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 0
83243: PUSH
83244: LD_INT 2
83246: NEG
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PUSH
83252: LD_INT 1
83254: PUSH
83255: LD_INT 1
83257: NEG
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 2
83265: PUSH
83266: LD_INT 0
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 2
83275: PUSH
83276: LD_INT 1
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: LD_INT 2
83285: PUSH
83286: LD_INT 2
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 1
83295: PUSH
83296: LD_INT 2
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 0
83305: PUSH
83306: LD_INT 2
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 1
83315: NEG
83316: PUSH
83317: LD_INT 1
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: LD_INT 2
83326: NEG
83327: PUSH
83328: LD_INT 0
83330: PUSH
83331: EMPTY
83332: LIST
83333: LIST
83334: PUSH
83335: LD_INT 2
83337: NEG
83338: PUSH
83339: LD_INT 1
83341: NEG
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 2
83349: NEG
83350: PUSH
83351: LD_INT 2
83353: NEG
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: PUSH
83359: LD_INT 2
83361: NEG
83362: PUSH
83363: LD_INT 3
83365: NEG
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 1
83373: NEG
83374: PUSH
83375: LD_INT 3
83377: NEG
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 1
83385: PUSH
83386: LD_INT 2
83388: NEG
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: PUSH
83394: LD_INT 2
83396: PUSH
83397: LD_INT 1
83399: NEG
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: LIST
83416: LIST
83417: LIST
83418: LIST
83419: LIST
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83430: LD_ADDR_VAR 0 24
83434: PUSH
83435: LD_INT 0
83437: PUSH
83438: LD_INT 0
83440: PUSH
83441: EMPTY
83442: LIST
83443: LIST
83444: PUSH
83445: LD_INT 0
83447: PUSH
83448: LD_INT 1
83450: NEG
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 1
83458: PUSH
83459: LD_INT 0
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 1
83468: PUSH
83469: LD_INT 1
83471: PUSH
83472: EMPTY
83473: LIST
83474: LIST
83475: PUSH
83476: LD_INT 0
83478: PUSH
83479: LD_INT 1
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 1
83488: NEG
83489: PUSH
83490: LD_INT 0
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 1
83499: NEG
83500: PUSH
83501: LD_INT 1
83503: NEG
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 1
83511: NEG
83512: PUSH
83513: LD_INT 2
83515: NEG
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 0
83523: PUSH
83524: LD_INT 2
83526: NEG
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 1
83534: PUSH
83535: LD_INT 1
83537: NEG
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_INT 2
83545: PUSH
83546: LD_INT 0
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 2
83555: PUSH
83556: LD_INT 1
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 2
83565: PUSH
83566: LD_INT 2
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 1
83575: PUSH
83576: LD_INT 2
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 0
83585: PUSH
83586: LD_INT 2
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 1
83595: NEG
83596: PUSH
83597: LD_INT 1
83599: PUSH
83600: EMPTY
83601: LIST
83602: LIST
83603: PUSH
83604: LD_INT 2
83606: NEG
83607: PUSH
83608: LD_INT 0
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 2
83617: NEG
83618: PUSH
83619: LD_INT 1
83621: NEG
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: PUSH
83627: LD_INT 2
83629: NEG
83630: PUSH
83631: LD_INT 2
83633: NEG
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 1
83641: PUSH
83642: LD_INT 2
83644: NEG
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: LD_INT 2
83652: PUSH
83653: LD_INT 1
83655: NEG
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 3
83663: PUSH
83664: LD_INT 1
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: LD_INT 3
83673: PUSH
83674: LD_INT 2
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: LIST
83685: LIST
83686: LIST
83687: LIST
83688: LIST
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83706: LD_ADDR_VAR 0 25
83710: PUSH
83711: LD_INT 0
83713: PUSH
83714: LD_INT 0
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: PUSH
83721: LD_INT 0
83723: PUSH
83724: LD_INT 1
83726: NEG
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 1
83734: PUSH
83735: LD_INT 0
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: LD_INT 1
83744: PUSH
83745: LD_INT 1
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: PUSH
83752: LD_INT 0
83754: PUSH
83755: LD_INT 1
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 1
83764: NEG
83765: PUSH
83766: LD_INT 0
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 1
83775: NEG
83776: PUSH
83777: LD_INT 1
83779: NEG
83780: PUSH
83781: EMPTY
83782: LIST
83783: LIST
83784: PUSH
83785: LD_INT 1
83787: NEG
83788: PUSH
83789: LD_INT 2
83791: NEG
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PUSH
83797: LD_INT 0
83799: PUSH
83800: LD_INT 2
83802: NEG
83803: PUSH
83804: EMPTY
83805: LIST
83806: LIST
83807: PUSH
83808: LD_INT 1
83810: PUSH
83811: LD_INT 1
83813: NEG
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 2
83821: PUSH
83822: LD_INT 0
83824: PUSH
83825: EMPTY
83826: LIST
83827: LIST
83828: PUSH
83829: LD_INT 2
83831: PUSH
83832: LD_INT 1
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: PUSH
83839: LD_INT 2
83841: PUSH
83842: LD_INT 2
83844: PUSH
83845: EMPTY
83846: LIST
83847: LIST
83848: PUSH
83849: LD_INT 1
83851: PUSH
83852: LD_INT 2
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 0
83861: PUSH
83862: LD_INT 2
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 1
83871: NEG
83872: PUSH
83873: LD_INT 1
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PUSH
83880: LD_INT 2
83882: NEG
83883: PUSH
83884: LD_INT 0
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 2
83893: NEG
83894: PUSH
83895: LD_INT 1
83897: NEG
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 2
83905: NEG
83906: PUSH
83907: LD_INT 2
83909: NEG
83910: PUSH
83911: EMPTY
83912: LIST
83913: LIST
83914: PUSH
83915: LD_INT 3
83917: PUSH
83918: LD_INT 1
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PUSH
83925: LD_INT 3
83927: PUSH
83928: LD_INT 2
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PUSH
83935: LD_INT 2
83937: PUSH
83938: LD_INT 3
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 1
83947: PUSH
83948: LD_INT 3
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: LIST
83975: LIST
83976: LIST
83977: LIST
83978: LIST
83979: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83980: LD_ADDR_VAR 0 26
83984: PUSH
83985: LD_INT 0
83987: PUSH
83988: LD_INT 0
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PUSH
83995: LD_INT 0
83997: PUSH
83998: LD_INT 1
84000: NEG
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 1
84008: PUSH
84009: LD_INT 0
84011: PUSH
84012: EMPTY
84013: LIST
84014: LIST
84015: PUSH
84016: LD_INT 1
84018: PUSH
84019: LD_INT 1
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: PUSH
84026: LD_INT 0
84028: PUSH
84029: LD_INT 1
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: PUSH
84036: LD_INT 1
84038: NEG
84039: PUSH
84040: LD_INT 0
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: PUSH
84047: LD_INT 1
84049: NEG
84050: PUSH
84051: LD_INT 1
84053: NEG
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: LD_INT 1
84061: NEG
84062: PUSH
84063: LD_INT 2
84065: NEG
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: PUSH
84071: LD_INT 0
84073: PUSH
84074: LD_INT 2
84076: NEG
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: LD_INT 1
84084: PUSH
84085: LD_INT 1
84087: NEG
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PUSH
84093: LD_INT 2
84095: PUSH
84096: LD_INT 0
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 2
84105: PUSH
84106: LD_INT 1
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: LD_INT 2
84115: PUSH
84116: LD_INT 2
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: PUSH
84123: LD_INT 1
84125: PUSH
84126: LD_INT 2
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 0
84135: PUSH
84136: LD_INT 2
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: PUSH
84143: LD_INT 1
84145: NEG
84146: PUSH
84147: LD_INT 1
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: PUSH
84154: LD_INT 2
84156: NEG
84157: PUSH
84158: LD_INT 0
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: PUSH
84165: LD_INT 2
84167: NEG
84168: PUSH
84169: LD_INT 1
84171: NEG
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 2
84179: NEG
84180: PUSH
84181: LD_INT 2
84183: NEG
84184: PUSH
84185: EMPTY
84186: LIST
84187: LIST
84188: PUSH
84189: LD_INT 2
84191: PUSH
84192: LD_INT 3
84194: PUSH
84195: EMPTY
84196: LIST
84197: LIST
84198: PUSH
84199: LD_INT 1
84201: PUSH
84202: LD_INT 3
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 1
84211: NEG
84212: PUSH
84213: LD_INT 2
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: PUSH
84220: LD_INT 2
84222: NEG
84223: PUSH
84224: LD_INT 1
84226: PUSH
84227: EMPTY
84228: LIST
84229: LIST
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: LIST
84249: LIST
84250: LIST
84251: LIST
84252: LIST
84253: LIST
84254: LIST
84255: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84256: LD_ADDR_VAR 0 27
84260: PUSH
84261: LD_INT 0
84263: PUSH
84264: LD_INT 0
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 0
84273: PUSH
84274: LD_INT 1
84276: NEG
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 1
84284: PUSH
84285: LD_INT 0
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 1
84294: PUSH
84295: LD_INT 1
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: PUSH
84302: LD_INT 0
84304: PUSH
84305: LD_INT 1
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PUSH
84312: LD_INT 1
84314: NEG
84315: PUSH
84316: LD_INT 0
84318: PUSH
84319: EMPTY
84320: LIST
84321: LIST
84322: PUSH
84323: LD_INT 1
84325: NEG
84326: PUSH
84327: LD_INT 1
84329: NEG
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: PUSH
84335: LD_INT 1
84337: NEG
84338: PUSH
84339: LD_INT 2
84341: NEG
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 0
84349: PUSH
84350: LD_INT 2
84352: NEG
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 1
84360: PUSH
84361: LD_INT 1
84363: NEG
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 2
84371: PUSH
84372: LD_INT 0
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 2
84381: PUSH
84382: LD_INT 1
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PUSH
84389: LD_INT 2
84391: PUSH
84392: LD_INT 2
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PUSH
84399: LD_INT 1
84401: PUSH
84402: LD_INT 2
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 0
84411: PUSH
84412: LD_INT 2
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 1
84421: NEG
84422: PUSH
84423: LD_INT 1
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 2
84432: NEG
84433: PUSH
84434: LD_INT 0
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PUSH
84441: LD_INT 2
84443: NEG
84444: PUSH
84445: LD_INT 1
84447: NEG
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 2
84455: NEG
84456: PUSH
84457: LD_INT 2
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 1
84467: NEG
84468: PUSH
84469: LD_INT 2
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 2
84478: NEG
84479: PUSH
84480: LD_INT 1
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 3
84489: NEG
84490: PUSH
84491: LD_INT 1
84493: NEG
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 3
84501: NEG
84502: PUSH
84503: LD_INT 2
84505: NEG
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84536: LD_ADDR_VAR 0 28
84540: PUSH
84541: LD_INT 0
84543: PUSH
84544: LD_INT 0
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 0
84553: PUSH
84554: LD_INT 1
84556: NEG
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 1
84564: PUSH
84565: LD_INT 0
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: PUSH
84572: LD_INT 1
84574: PUSH
84575: LD_INT 1
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: PUSH
84582: LD_INT 0
84584: PUSH
84585: LD_INT 1
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 1
84594: NEG
84595: PUSH
84596: LD_INT 0
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: PUSH
84603: LD_INT 1
84605: NEG
84606: PUSH
84607: LD_INT 1
84609: NEG
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: PUSH
84615: LD_INT 1
84617: NEG
84618: PUSH
84619: LD_INT 2
84621: NEG
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: LD_INT 0
84629: PUSH
84630: LD_INT 2
84632: NEG
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: PUSH
84638: LD_INT 1
84640: PUSH
84641: LD_INT 1
84643: NEG
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 2
84651: PUSH
84652: LD_INT 0
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: LD_INT 2
84661: PUSH
84662: LD_INT 1
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: LD_INT 2
84671: PUSH
84672: LD_INT 2
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 1
84681: PUSH
84682: LD_INT 2
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 0
84691: PUSH
84692: LD_INT 2
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 1
84701: NEG
84702: PUSH
84703: LD_INT 1
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 2
84712: NEG
84713: PUSH
84714: LD_INT 0
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 2
84723: NEG
84724: PUSH
84725: LD_INT 1
84727: NEG
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 2
84735: NEG
84736: PUSH
84737: LD_INT 2
84739: NEG
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PUSH
84745: LD_INT 2
84747: NEG
84748: PUSH
84749: LD_INT 3
84751: NEG
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: PUSH
84757: LD_INT 1
84759: NEG
84760: PUSH
84761: LD_INT 3
84763: NEG
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: PUSH
84769: LD_INT 3
84771: NEG
84772: PUSH
84773: LD_INT 1
84775: NEG
84776: PUSH
84777: EMPTY
84778: LIST
84779: LIST
84780: PUSH
84781: LD_INT 3
84783: NEG
84784: PUSH
84785: LD_INT 2
84787: NEG
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: LIST
84797: LIST
84798: LIST
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: LIST
84805: LIST
84806: LIST
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84818: LD_ADDR_VAR 0 29
84822: PUSH
84823: LD_INT 0
84825: PUSH
84826: LD_INT 0
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: LD_INT 0
84835: PUSH
84836: LD_INT 1
84838: NEG
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: LD_INT 1
84846: PUSH
84847: LD_INT 0
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: PUSH
84854: LD_INT 1
84856: PUSH
84857: LD_INT 1
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 1
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 1
84876: NEG
84877: PUSH
84878: LD_INT 0
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 1
84887: NEG
84888: PUSH
84889: LD_INT 1
84891: NEG
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 1
84899: NEG
84900: PUSH
84901: LD_INT 2
84903: NEG
84904: PUSH
84905: EMPTY
84906: LIST
84907: LIST
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: LD_INT 2
84914: NEG
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 1
84922: PUSH
84923: LD_INT 1
84925: NEG
84926: PUSH
84927: EMPTY
84928: LIST
84929: LIST
84930: PUSH
84931: LD_INT 2
84933: PUSH
84934: LD_INT 0
84936: PUSH
84937: EMPTY
84938: LIST
84939: LIST
84940: PUSH
84941: LD_INT 2
84943: PUSH
84944: LD_INT 1
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: PUSH
84951: LD_INT 1
84953: PUSH
84954: LD_INT 2
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 0
84963: PUSH
84964: LD_INT 2
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: PUSH
84971: LD_INT 1
84973: NEG
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 2
84984: NEG
84985: PUSH
84986: LD_INT 1
84988: NEG
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: PUSH
84994: LD_INT 2
84996: NEG
84997: PUSH
84998: LD_INT 2
85000: NEG
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 2
85008: NEG
85009: PUSH
85010: LD_INT 3
85012: NEG
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 2
85020: PUSH
85021: LD_INT 1
85023: NEG
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 3
85031: PUSH
85032: LD_INT 1
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: LD_INT 1
85041: PUSH
85042: LD_INT 3
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: LD_INT 1
85051: NEG
85052: PUSH
85053: LD_INT 2
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: PUSH
85060: LD_INT 3
85062: NEG
85063: PUSH
85064: LD_INT 2
85066: NEG
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: EMPTY
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85097: LD_ADDR_VAR 0 30
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: LD_INT 0
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: LD_INT 0
85114: PUSH
85115: LD_INT 1
85117: NEG
85118: PUSH
85119: EMPTY
85120: LIST
85121: LIST
85122: PUSH
85123: LD_INT 1
85125: PUSH
85126: LD_INT 0
85128: PUSH
85129: EMPTY
85130: LIST
85131: LIST
85132: PUSH
85133: LD_INT 1
85135: PUSH
85136: LD_INT 1
85138: PUSH
85139: EMPTY
85140: LIST
85141: LIST
85142: PUSH
85143: LD_INT 0
85145: PUSH
85146: LD_INT 1
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: PUSH
85153: LD_INT 1
85155: NEG
85156: PUSH
85157: LD_INT 0
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: PUSH
85164: LD_INT 1
85166: NEG
85167: PUSH
85168: LD_INT 1
85170: NEG
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 1
85178: NEG
85179: PUSH
85180: LD_INT 2
85182: NEG
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: PUSH
85188: LD_INT 0
85190: PUSH
85191: LD_INT 2
85193: NEG
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: PUSH
85199: LD_INT 1
85201: PUSH
85202: LD_INT 1
85204: NEG
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: LD_INT 2
85212: PUSH
85213: LD_INT 0
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: PUSH
85220: LD_INT 2
85222: PUSH
85223: LD_INT 1
85225: PUSH
85226: EMPTY
85227: LIST
85228: LIST
85229: PUSH
85230: LD_INT 2
85232: PUSH
85233: LD_INT 2
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PUSH
85240: LD_INT 1
85242: PUSH
85243: LD_INT 2
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: PUSH
85250: LD_INT 1
85252: NEG
85253: PUSH
85254: LD_INT 1
85256: PUSH
85257: EMPTY
85258: LIST
85259: LIST
85260: PUSH
85261: LD_INT 2
85263: NEG
85264: PUSH
85265: LD_INT 0
85267: PUSH
85268: EMPTY
85269: LIST
85270: LIST
85271: PUSH
85272: LD_INT 2
85274: NEG
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 1
85286: NEG
85287: PUSH
85288: LD_INT 3
85290: NEG
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 1
85298: PUSH
85299: LD_INT 2
85301: NEG
85302: PUSH
85303: EMPTY
85304: LIST
85305: LIST
85306: PUSH
85307: LD_INT 3
85309: PUSH
85310: LD_INT 2
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: PUSH
85317: LD_INT 2
85319: PUSH
85320: LD_INT 3
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: PUSH
85327: LD_INT 2
85329: NEG
85330: PUSH
85331: LD_INT 1
85333: PUSH
85334: EMPTY
85335: LIST
85336: LIST
85337: PUSH
85338: LD_INT 3
85340: NEG
85341: PUSH
85342: LD_INT 1
85344: NEG
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: LIST
85363: LIST
85364: LIST
85365: LIST
85366: LIST
85367: LIST
85368: LIST
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85375: LD_ADDR_VAR 0 31
85379: PUSH
85380: LD_INT 0
85382: PUSH
85383: LD_INT 0
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 0
85392: PUSH
85393: LD_INT 1
85395: NEG
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_INT 1
85403: PUSH
85404: LD_INT 0
85406: PUSH
85407: EMPTY
85408: LIST
85409: LIST
85410: PUSH
85411: LD_INT 1
85413: PUSH
85414: LD_INT 1
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PUSH
85421: LD_INT 0
85423: PUSH
85424: LD_INT 1
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 1
85433: NEG
85434: PUSH
85435: LD_INT 0
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: NEG
85445: PUSH
85446: LD_INT 1
85448: NEG
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: PUSH
85454: LD_INT 1
85456: NEG
85457: PUSH
85458: LD_INT 2
85460: NEG
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: PUSH
85466: LD_INT 1
85468: PUSH
85469: LD_INT 1
85471: NEG
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 2
85479: PUSH
85480: LD_INT 0
85482: PUSH
85483: EMPTY
85484: LIST
85485: LIST
85486: PUSH
85487: LD_INT 2
85489: PUSH
85490: LD_INT 1
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: LD_INT 2
85499: PUSH
85500: LD_INT 2
85502: PUSH
85503: EMPTY
85504: LIST
85505: LIST
85506: PUSH
85507: LD_INT 1
85509: PUSH
85510: LD_INT 2
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: LD_INT 0
85519: PUSH
85520: LD_INT 2
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PUSH
85527: LD_INT 1
85529: NEG
85530: PUSH
85531: LD_INT 1
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 2
85540: NEG
85541: PUSH
85542: LD_INT 1
85544: NEG
85545: PUSH
85546: EMPTY
85547: LIST
85548: LIST
85549: PUSH
85550: LD_INT 2
85552: NEG
85553: PUSH
85554: LD_INT 2
85556: NEG
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 2
85564: NEG
85565: PUSH
85566: LD_INT 3
85568: NEG
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 2
85576: PUSH
85577: LD_INT 1
85579: NEG
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: LD_INT 3
85587: PUSH
85588: LD_INT 1
85590: PUSH
85591: EMPTY
85592: LIST
85593: LIST
85594: PUSH
85595: LD_INT 1
85597: PUSH
85598: LD_INT 3
85600: PUSH
85601: EMPTY
85602: LIST
85603: LIST
85604: PUSH
85605: LD_INT 1
85607: NEG
85608: PUSH
85609: LD_INT 2
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: LD_INT 3
85618: NEG
85619: PUSH
85620: LD_INT 2
85622: NEG
85623: PUSH
85624: EMPTY
85625: LIST
85626: LIST
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: LIST
85635: LIST
85636: LIST
85637: LIST
85638: LIST
85639: LIST
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: LIST
85647: LIST
85648: LIST
85649: LIST
85650: LIST
85651: LIST
85652: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85653: LD_ADDR_VAR 0 32
85657: PUSH
85658: LD_INT 0
85660: PUSH
85661: LD_INT 0
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 0
85670: PUSH
85671: LD_INT 1
85673: NEG
85674: PUSH
85675: EMPTY
85676: LIST
85677: LIST
85678: PUSH
85679: LD_INT 1
85681: PUSH
85682: LD_INT 0
85684: PUSH
85685: EMPTY
85686: LIST
85687: LIST
85688: PUSH
85689: LD_INT 1
85691: PUSH
85692: LD_INT 1
85694: PUSH
85695: EMPTY
85696: LIST
85697: LIST
85698: PUSH
85699: LD_INT 0
85701: PUSH
85702: LD_INT 1
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: PUSH
85709: LD_INT 1
85711: NEG
85712: PUSH
85713: LD_INT 0
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: PUSH
85720: LD_INT 1
85722: NEG
85723: PUSH
85724: LD_INT 1
85726: NEG
85727: PUSH
85728: EMPTY
85729: LIST
85730: LIST
85731: PUSH
85732: LD_INT 1
85734: NEG
85735: PUSH
85736: LD_INT 2
85738: NEG
85739: PUSH
85740: EMPTY
85741: LIST
85742: LIST
85743: PUSH
85744: LD_INT 0
85746: PUSH
85747: LD_INT 2
85749: NEG
85750: PUSH
85751: EMPTY
85752: LIST
85753: LIST
85754: PUSH
85755: LD_INT 1
85757: PUSH
85758: LD_INT 1
85760: NEG
85761: PUSH
85762: EMPTY
85763: LIST
85764: LIST
85765: PUSH
85766: LD_INT 2
85768: PUSH
85769: LD_INT 1
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 2
85778: PUSH
85779: LD_INT 2
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: PUSH
85786: LD_INT 1
85788: PUSH
85789: LD_INT 2
85791: PUSH
85792: EMPTY
85793: LIST
85794: LIST
85795: PUSH
85796: LD_INT 0
85798: PUSH
85799: LD_INT 2
85801: PUSH
85802: EMPTY
85803: LIST
85804: LIST
85805: PUSH
85806: LD_INT 1
85808: NEG
85809: PUSH
85810: LD_INT 1
85812: PUSH
85813: EMPTY
85814: LIST
85815: LIST
85816: PUSH
85817: LD_INT 2
85819: NEG
85820: PUSH
85821: LD_INT 0
85823: PUSH
85824: EMPTY
85825: LIST
85826: LIST
85827: PUSH
85828: LD_INT 2
85830: NEG
85831: PUSH
85832: LD_INT 1
85834: NEG
85835: PUSH
85836: EMPTY
85837: LIST
85838: LIST
85839: PUSH
85840: LD_INT 1
85842: NEG
85843: PUSH
85844: LD_INT 3
85846: NEG
85847: PUSH
85848: EMPTY
85849: LIST
85850: LIST
85851: PUSH
85852: LD_INT 1
85854: PUSH
85855: LD_INT 2
85857: NEG
85858: PUSH
85859: EMPTY
85860: LIST
85861: LIST
85862: PUSH
85863: LD_INT 3
85865: PUSH
85866: LD_INT 2
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: PUSH
85873: LD_INT 2
85875: PUSH
85876: LD_INT 3
85878: PUSH
85879: EMPTY
85880: LIST
85881: LIST
85882: PUSH
85883: LD_INT 2
85885: NEG
85886: PUSH
85887: LD_INT 1
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 3
85896: NEG
85897: PUSH
85898: LD_INT 1
85900: NEG
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: LIST
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85931: LD_ADDR_VAR 0 33
85935: PUSH
85936: LD_INT 0
85938: PUSH
85939: LD_INT 0
85941: PUSH
85942: EMPTY
85943: LIST
85944: LIST
85945: PUSH
85946: LD_INT 0
85948: PUSH
85949: LD_INT 1
85951: NEG
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: PUSH
85957: LD_INT 1
85959: PUSH
85960: LD_INT 0
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: LD_INT 1
85969: PUSH
85970: LD_INT 1
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: PUSH
85977: LD_INT 0
85979: PUSH
85980: LD_INT 1
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 1
85989: NEG
85990: PUSH
85991: LD_INT 0
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 1
86000: NEG
86001: PUSH
86002: LD_INT 1
86004: NEG
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 1
86012: NEG
86013: PUSH
86014: LD_INT 2
86016: NEG
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 1
86024: PUSH
86025: LD_INT 1
86027: NEG
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 2
86035: PUSH
86036: LD_INT 0
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 2
86045: PUSH
86046: LD_INT 1
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 1
86055: PUSH
86056: LD_INT 2
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 0
86065: PUSH
86066: LD_INT 2
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 1
86075: NEG
86076: PUSH
86077: LD_INT 1
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 2
86086: NEG
86087: PUSH
86088: LD_INT 0
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 2
86097: NEG
86098: PUSH
86099: LD_INT 1
86101: NEG
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 2
86109: NEG
86110: PUSH
86111: LD_INT 2
86113: NEG
86114: PUSH
86115: EMPTY
86116: LIST
86117: LIST
86118: PUSH
86119: LD_INT 2
86121: NEG
86122: PUSH
86123: LD_INT 3
86125: NEG
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 2
86133: PUSH
86134: LD_INT 1
86136: NEG
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 3
86144: PUSH
86145: LD_INT 1
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 1
86154: PUSH
86155: LD_INT 3
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PUSH
86162: LD_INT 1
86164: NEG
86165: PUSH
86166: LD_INT 2
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: PUSH
86173: LD_INT 3
86175: NEG
86176: PUSH
86177: LD_INT 2
86179: NEG
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86210: LD_ADDR_VAR 0 34
86214: PUSH
86215: LD_INT 0
86217: PUSH
86218: LD_INT 0
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PUSH
86225: LD_INT 0
86227: PUSH
86228: LD_INT 1
86230: NEG
86231: PUSH
86232: EMPTY
86233: LIST
86234: LIST
86235: PUSH
86236: LD_INT 1
86238: PUSH
86239: LD_INT 0
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: PUSH
86246: LD_INT 1
86248: PUSH
86249: LD_INT 1
86251: PUSH
86252: EMPTY
86253: LIST
86254: LIST
86255: PUSH
86256: LD_INT 0
86258: PUSH
86259: LD_INT 1
86261: PUSH
86262: EMPTY
86263: LIST
86264: LIST
86265: PUSH
86266: LD_INT 1
86268: NEG
86269: PUSH
86270: LD_INT 0
86272: PUSH
86273: EMPTY
86274: LIST
86275: LIST
86276: PUSH
86277: LD_INT 1
86279: NEG
86280: PUSH
86281: LD_INT 1
86283: NEG
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 1
86291: NEG
86292: PUSH
86293: LD_INT 2
86295: NEG
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 0
86303: PUSH
86304: LD_INT 2
86306: NEG
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 1
86314: PUSH
86315: LD_INT 1
86317: NEG
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: LD_INT 2
86325: PUSH
86326: LD_INT 1
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 2
86335: PUSH
86336: LD_INT 2
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: LD_INT 1
86345: PUSH
86346: LD_INT 2
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: PUSH
86353: LD_INT 1
86355: NEG
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: EMPTY
86361: LIST
86362: LIST
86363: PUSH
86364: LD_INT 2
86366: NEG
86367: PUSH
86368: LD_INT 0
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 2
86377: NEG
86378: PUSH
86379: LD_INT 1
86381: NEG
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 2
86389: NEG
86390: PUSH
86391: LD_INT 2
86393: NEG
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: LD_INT 1
86401: NEG
86402: PUSH
86403: LD_INT 3
86405: NEG
86406: PUSH
86407: EMPTY
86408: LIST
86409: LIST
86410: PUSH
86411: LD_INT 1
86413: PUSH
86414: LD_INT 2
86416: NEG
86417: PUSH
86418: EMPTY
86419: LIST
86420: LIST
86421: PUSH
86422: LD_INT 3
86424: PUSH
86425: LD_INT 2
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: PUSH
86432: LD_INT 2
86434: PUSH
86435: LD_INT 3
86437: PUSH
86438: EMPTY
86439: LIST
86440: LIST
86441: PUSH
86442: LD_INT 2
86444: NEG
86445: PUSH
86446: LD_INT 1
86448: PUSH
86449: EMPTY
86450: LIST
86451: LIST
86452: PUSH
86453: LD_INT 3
86455: NEG
86456: PUSH
86457: LD_INT 1
86459: NEG
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: LIST
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86490: LD_ADDR_VAR 0 35
86494: PUSH
86495: LD_INT 0
86497: PUSH
86498: LD_INT 0
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: PUSH
86505: LD_INT 0
86507: PUSH
86508: LD_INT 1
86510: NEG
86511: PUSH
86512: EMPTY
86513: LIST
86514: LIST
86515: PUSH
86516: LD_INT 1
86518: PUSH
86519: LD_INT 0
86521: PUSH
86522: EMPTY
86523: LIST
86524: LIST
86525: PUSH
86526: LD_INT 1
86528: PUSH
86529: LD_INT 1
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: LD_INT 0
86538: PUSH
86539: LD_INT 1
86541: PUSH
86542: EMPTY
86543: LIST
86544: LIST
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: LD_INT 0
86552: PUSH
86553: EMPTY
86554: LIST
86555: LIST
86556: PUSH
86557: LD_INT 1
86559: NEG
86560: PUSH
86561: LD_INT 1
86563: NEG
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 2
86571: PUSH
86572: LD_INT 1
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: PUSH
86579: LD_INT 2
86581: NEG
86582: PUSH
86583: LD_INT 1
86585: NEG
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: LIST
86595: LIST
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86602: LD_ADDR_VAR 0 36
86606: PUSH
86607: LD_INT 0
86609: PUSH
86610: LD_INT 0
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 0
86619: PUSH
86620: LD_INT 1
86622: NEG
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PUSH
86628: LD_INT 1
86630: PUSH
86631: LD_INT 0
86633: PUSH
86634: EMPTY
86635: LIST
86636: LIST
86637: PUSH
86638: LD_INT 1
86640: PUSH
86641: LD_INT 1
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: PUSH
86648: LD_INT 0
86650: PUSH
86651: LD_INT 1
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: PUSH
86658: LD_INT 1
86660: NEG
86661: PUSH
86662: LD_INT 0
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: PUSH
86669: LD_INT 1
86671: NEG
86672: PUSH
86673: LD_INT 1
86675: NEG
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 1
86683: NEG
86684: PUSH
86685: LD_INT 2
86687: NEG
86688: PUSH
86689: EMPTY
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 1
86695: PUSH
86696: LD_INT 2
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86714: LD_ADDR_VAR 0 37
86718: PUSH
86719: LD_INT 0
86721: PUSH
86722: LD_INT 0
86724: PUSH
86725: EMPTY
86726: LIST
86727: LIST
86728: PUSH
86729: LD_INT 0
86731: PUSH
86732: LD_INT 1
86734: NEG
86735: PUSH
86736: EMPTY
86737: LIST
86738: LIST
86739: PUSH
86740: LD_INT 1
86742: PUSH
86743: LD_INT 0
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: PUSH
86750: LD_INT 1
86752: PUSH
86753: LD_INT 1
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: PUSH
86760: LD_INT 0
86762: PUSH
86763: LD_INT 1
86765: PUSH
86766: EMPTY
86767: LIST
86768: LIST
86769: PUSH
86770: LD_INT 1
86772: NEG
86773: PUSH
86774: LD_INT 0
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: NEG
86784: PUSH
86785: LD_INT 1
86787: NEG
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 1
86795: PUSH
86796: LD_INT 1
86798: NEG
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: PUSH
86804: LD_INT 1
86806: NEG
86807: PUSH
86808: LD_INT 1
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: LIST
86819: LIST
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86826: LD_ADDR_VAR 0 38
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: LD_INT 0
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 0
86843: PUSH
86844: LD_INT 1
86846: NEG
86847: PUSH
86848: EMPTY
86849: LIST
86850: LIST
86851: PUSH
86852: LD_INT 1
86854: PUSH
86855: LD_INT 0
86857: PUSH
86858: EMPTY
86859: LIST
86860: LIST
86861: PUSH
86862: LD_INT 1
86864: PUSH
86865: LD_INT 1
86867: PUSH
86868: EMPTY
86869: LIST
86870: LIST
86871: PUSH
86872: LD_INT 0
86874: PUSH
86875: LD_INT 1
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 1
86884: NEG
86885: PUSH
86886: LD_INT 0
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: PUSH
86893: LD_INT 1
86895: NEG
86896: PUSH
86897: LD_INT 1
86899: NEG
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: PUSH
86905: LD_INT 2
86907: PUSH
86908: LD_INT 1
86910: PUSH
86911: EMPTY
86912: LIST
86913: LIST
86914: PUSH
86915: LD_INT 2
86917: NEG
86918: PUSH
86919: LD_INT 1
86921: NEG
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86938: LD_ADDR_VAR 0 39
86942: PUSH
86943: LD_INT 0
86945: PUSH
86946: LD_INT 0
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 0
86955: PUSH
86956: LD_INT 1
86958: NEG
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: PUSH
86964: LD_INT 1
86966: PUSH
86967: LD_INT 0
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: PUSH
86974: LD_INT 1
86976: PUSH
86977: LD_INT 1
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 0
86986: PUSH
86987: LD_INT 1
86989: PUSH
86990: EMPTY
86991: LIST
86992: LIST
86993: PUSH
86994: LD_INT 1
86996: NEG
86997: PUSH
86998: LD_INT 0
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 1
87007: NEG
87008: PUSH
87009: LD_INT 1
87011: NEG
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PUSH
87017: LD_INT 1
87019: NEG
87020: PUSH
87021: LD_INT 2
87023: NEG
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 1
87031: PUSH
87032: LD_INT 2
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87050: LD_ADDR_VAR 0 40
87054: PUSH
87055: LD_INT 0
87057: PUSH
87058: LD_INT 0
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: PUSH
87065: LD_INT 0
87067: PUSH
87068: LD_INT 1
87070: NEG
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 1
87078: PUSH
87079: LD_INT 0
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: PUSH
87086: LD_INT 1
87088: PUSH
87089: LD_INT 1
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 0
87098: PUSH
87099: LD_INT 1
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: PUSH
87106: LD_INT 1
87108: NEG
87109: PUSH
87110: LD_INT 0
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: PUSH
87117: LD_INT 1
87119: NEG
87120: PUSH
87121: LD_INT 1
87123: NEG
87124: PUSH
87125: EMPTY
87126: LIST
87127: LIST
87128: PUSH
87129: LD_INT 1
87131: PUSH
87132: LD_INT 1
87134: NEG
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 1
87142: NEG
87143: PUSH
87144: LD_INT 1
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87162: LD_ADDR_VAR 0 41
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: LD_INT 0
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 0
87179: PUSH
87180: LD_INT 1
87182: NEG
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PUSH
87188: LD_INT 1
87190: PUSH
87191: LD_INT 0
87193: PUSH
87194: EMPTY
87195: LIST
87196: LIST
87197: PUSH
87198: LD_INT 1
87200: PUSH
87201: LD_INT 1
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 0
87210: PUSH
87211: LD_INT 1
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: PUSH
87218: LD_INT 1
87220: NEG
87221: PUSH
87222: LD_INT 0
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: PUSH
87229: LD_INT 1
87231: NEG
87232: PUSH
87233: LD_INT 1
87235: NEG
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PUSH
87241: LD_INT 1
87243: NEG
87244: PUSH
87245: LD_INT 2
87247: NEG
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: PUSH
87253: LD_INT 1
87255: PUSH
87256: LD_INT 1
87258: NEG
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 2
87266: PUSH
87267: LD_INT 0
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: LD_INT 2
87276: PUSH
87277: LD_INT 1
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 2
87286: PUSH
87287: LD_INT 2
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 1
87296: PUSH
87297: LD_INT 2
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: NEG
87307: PUSH
87308: LD_INT 1
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PUSH
87315: LD_INT 2
87317: NEG
87318: PUSH
87319: LD_INT 0
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 2
87328: NEG
87329: PUSH
87330: LD_INT 1
87332: NEG
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: LD_INT 2
87340: NEG
87341: PUSH
87342: LD_INT 2
87344: NEG
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 2
87352: NEG
87353: PUSH
87354: LD_INT 3
87356: NEG
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 2
87364: PUSH
87365: LD_INT 1
87367: NEG
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: PUSH
87373: LD_INT 3
87375: PUSH
87376: LD_INT 0
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 3
87385: PUSH
87386: LD_INT 1
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 3
87395: PUSH
87396: LD_INT 2
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: LD_INT 3
87405: PUSH
87406: LD_INT 3
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 2
87415: PUSH
87416: LD_INT 3
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PUSH
87423: LD_INT 2
87425: NEG
87426: PUSH
87427: LD_INT 1
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: PUSH
87434: LD_INT 3
87436: NEG
87437: PUSH
87438: LD_INT 0
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: LD_INT 3
87447: NEG
87448: PUSH
87449: LD_INT 1
87451: NEG
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: LD_INT 3
87459: NEG
87460: PUSH
87461: LD_INT 2
87463: NEG
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: PUSH
87469: LD_INT 3
87471: NEG
87472: PUSH
87473: LD_INT 3
87475: NEG
87476: PUSH
87477: EMPTY
87478: LIST
87479: LIST
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: LIST
87485: LIST
87486: LIST
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: LIST
87494: LIST
87495: LIST
87496: LIST
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: LIST
87503: LIST
87504: LIST
87505: LIST
87506: LIST
87507: LIST
87508: LIST
87509: LIST
87510: LIST
87511: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87512: LD_ADDR_VAR 0 42
87516: PUSH
87517: LD_INT 0
87519: PUSH
87520: LD_INT 0
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: PUSH
87527: LD_INT 0
87529: PUSH
87530: LD_INT 1
87532: NEG
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 1
87540: PUSH
87541: LD_INT 0
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 1
87550: PUSH
87551: LD_INT 1
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: LD_INT 0
87560: PUSH
87561: LD_INT 1
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 1
87570: NEG
87571: PUSH
87572: LD_INT 0
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 1
87581: NEG
87582: PUSH
87583: LD_INT 1
87585: NEG
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 1
87593: NEG
87594: PUSH
87595: LD_INT 2
87597: NEG
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 0
87605: PUSH
87606: LD_INT 2
87608: NEG
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: PUSH
87614: LD_INT 1
87616: PUSH
87617: LD_INT 1
87619: NEG
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 2
87627: PUSH
87628: LD_INT 1
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 2
87637: PUSH
87638: LD_INT 2
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 1
87647: PUSH
87648: LD_INT 2
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 0
87657: PUSH
87658: LD_INT 2
87660: PUSH
87661: EMPTY
87662: LIST
87663: LIST
87664: PUSH
87665: LD_INT 1
87667: NEG
87668: PUSH
87669: LD_INT 1
87671: PUSH
87672: EMPTY
87673: LIST
87674: LIST
87675: PUSH
87676: LD_INT 2
87678: NEG
87679: PUSH
87680: LD_INT 1
87682: NEG
87683: PUSH
87684: EMPTY
87685: LIST
87686: LIST
87687: PUSH
87688: LD_INT 2
87690: NEG
87691: PUSH
87692: LD_INT 2
87694: NEG
87695: PUSH
87696: EMPTY
87697: LIST
87698: LIST
87699: PUSH
87700: LD_INT 2
87702: NEG
87703: PUSH
87704: LD_INT 3
87706: NEG
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: LD_INT 1
87714: NEG
87715: PUSH
87716: LD_INT 3
87718: NEG
87719: PUSH
87720: EMPTY
87721: LIST
87722: LIST
87723: PUSH
87724: LD_INT 0
87726: PUSH
87727: LD_INT 3
87729: NEG
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 1
87737: PUSH
87738: LD_INT 2
87740: NEG
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: PUSH
87746: LD_INT 3
87748: PUSH
87749: LD_INT 2
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 3
87758: PUSH
87759: LD_INT 3
87761: PUSH
87762: EMPTY
87763: LIST
87764: LIST
87765: PUSH
87766: LD_INT 2
87768: PUSH
87769: LD_INT 3
87771: PUSH
87772: EMPTY
87773: LIST
87774: LIST
87775: PUSH
87776: LD_INT 1
87778: PUSH
87779: LD_INT 3
87781: PUSH
87782: EMPTY
87783: LIST
87784: LIST
87785: PUSH
87786: LD_INT 0
87788: PUSH
87789: LD_INT 3
87791: PUSH
87792: EMPTY
87793: LIST
87794: LIST
87795: PUSH
87796: LD_INT 1
87798: NEG
87799: PUSH
87800: LD_INT 2
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: PUSH
87807: LD_INT 3
87809: NEG
87810: PUSH
87811: LD_INT 2
87813: NEG
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: PUSH
87819: LD_INT 3
87821: NEG
87822: PUSH
87823: LD_INT 3
87825: NEG
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87862: LD_ADDR_VAR 0 43
87866: PUSH
87867: LD_INT 0
87869: PUSH
87870: LD_INT 0
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: LD_INT 0
87879: PUSH
87880: LD_INT 1
87882: NEG
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 1
87890: PUSH
87891: LD_INT 0
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 1
87900: PUSH
87901: LD_INT 1
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: LD_INT 0
87910: PUSH
87911: LD_INT 1
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 1
87920: NEG
87921: PUSH
87922: LD_INT 0
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 1
87931: NEG
87932: PUSH
87933: LD_INT 1
87935: NEG
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: LD_INT 1
87943: NEG
87944: PUSH
87945: LD_INT 2
87947: NEG
87948: PUSH
87949: EMPTY
87950: LIST
87951: LIST
87952: PUSH
87953: LD_INT 0
87955: PUSH
87956: LD_INT 2
87958: NEG
87959: PUSH
87960: EMPTY
87961: LIST
87962: LIST
87963: PUSH
87964: LD_INT 1
87966: PUSH
87967: LD_INT 1
87969: NEG
87970: PUSH
87971: EMPTY
87972: LIST
87973: LIST
87974: PUSH
87975: LD_INT 2
87977: PUSH
87978: LD_INT 0
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: PUSH
87985: LD_INT 2
87987: PUSH
87988: LD_INT 1
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: PUSH
87995: LD_INT 1
87997: PUSH
87998: LD_INT 2
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 0
88007: PUSH
88008: LD_INT 2
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 1
88017: NEG
88018: PUSH
88019: LD_INT 1
88021: PUSH
88022: EMPTY
88023: LIST
88024: LIST
88025: PUSH
88026: LD_INT 2
88028: NEG
88029: PUSH
88030: LD_INT 0
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: LD_INT 2
88039: NEG
88040: PUSH
88041: LD_INT 1
88043: NEG
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 1
88051: NEG
88052: PUSH
88053: LD_INT 3
88055: NEG
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 0
88063: PUSH
88064: LD_INT 3
88066: NEG
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: PUSH
88072: LD_INT 1
88074: PUSH
88075: LD_INT 2
88077: NEG
88078: PUSH
88079: EMPTY
88080: LIST
88081: LIST
88082: PUSH
88083: LD_INT 2
88085: PUSH
88086: LD_INT 1
88088: NEG
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 3
88096: PUSH
88097: LD_INT 0
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 3
88106: PUSH
88107: LD_INT 1
88109: PUSH
88110: EMPTY
88111: LIST
88112: LIST
88113: PUSH
88114: LD_INT 1
88116: PUSH
88117: LD_INT 3
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 0
88126: PUSH
88127: LD_INT 3
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PUSH
88134: LD_INT 1
88136: NEG
88137: PUSH
88138: LD_INT 2
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 2
88147: NEG
88148: PUSH
88149: LD_INT 1
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PUSH
88156: LD_INT 3
88158: NEG
88159: PUSH
88160: LD_INT 0
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: PUSH
88167: LD_INT 3
88169: NEG
88170: PUSH
88171: LD_INT 1
88173: NEG
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: LIST
88191: LIST
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88210: LD_ADDR_VAR 0 44
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: LD_INT 0
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: PUSH
88225: LD_INT 0
88227: PUSH
88228: LD_INT 1
88230: NEG
88231: PUSH
88232: EMPTY
88233: LIST
88234: LIST
88235: PUSH
88236: LD_INT 1
88238: PUSH
88239: LD_INT 0
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: PUSH
88246: LD_INT 1
88248: PUSH
88249: LD_INT 1
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: PUSH
88256: LD_INT 0
88258: PUSH
88259: LD_INT 1
88261: PUSH
88262: EMPTY
88263: LIST
88264: LIST
88265: PUSH
88266: LD_INT 1
88268: NEG
88269: PUSH
88270: LD_INT 0
88272: PUSH
88273: EMPTY
88274: LIST
88275: LIST
88276: PUSH
88277: LD_INT 1
88279: NEG
88280: PUSH
88281: LD_INT 1
88283: NEG
88284: PUSH
88285: EMPTY
88286: LIST
88287: LIST
88288: PUSH
88289: LD_INT 1
88291: NEG
88292: PUSH
88293: LD_INT 2
88295: NEG
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 1
88303: PUSH
88304: LD_INT 1
88306: NEG
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 2
88314: PUSH
88315: LD_INT 0
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: LD_INT 2
88324: PUSH
88325: LD_INT 1
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: PUSH
88332: LD_INT 2
88334: PUSH
88335: LD_INT 2
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 1
88344: PUSH
88345: LD_INT 2
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 1
88354: NEG
88355: PUSH
88356: LD_INT 1
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 2
88365: NEG
88366: PUSH
88367: LD_INT 0
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: LD_INT 2
88376: NEG
88377: PUSH
88378: LD_INT 1
88380: NEG
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 2
88388: NEG
88389: PUSH
88390: LD_INT 2
88392: NEG
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 2
88400: NEG
88401: PUSH
88402: LD_INT 3
88404: NEG
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 2
88412: PUSH
88413: LD_INT 1
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 3
88423: PUSH
88424: LD_INT 0
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 3
88433: PUSH
88434: LD_INT 1
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 3
88443: PUSH
88444: LD_INT 2
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 3
88453: PUSH
88454: LD_INT 3
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 2
88463: PUSH
88464: LD_INT 3
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: PUSH
88471: LD_INT 2
88473: NEG
88474: PUSH
88475: LD_INT 1
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 3
88484: NEG
88485: PUSH
88486: LD_INT 0
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: LD_INT 3
88495: NEG
88496: PUSH
88497: LD_INT 1
88499: NEG
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 3
88507: NEG
88508: PUSH
88509: LD_INT 2
88511: NEG
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: PUSH
88517: LD_INT 3
88519: NEG
88520: PUSH
88521: LD_INT 3
88523: NEG
88524: PUSH
88525: EMPTY
88526: LIST
88527: LIST
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: LIST
88533: LIST
88534: LIST
88535: LIST
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88560: LD_ADDR_VAR 0 45
88564: PUSH
88565: LD_INT 0
88567: PUSH
88568: LD_INT 0
88570: PUSH
88571: EMPTY
88572: LIST
88573: LIST
88574: PUSH
88575: LD_INT 0
88577: PUSH
88578: LD_INT 1
88580: NEG
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 1
88588: PUSH
88589: LD_INT 0
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 1
88598: PUSH
88599: LD_INT 1
88601: PUSH
88602: EMPTY
88603: LIST
88604: LIST
88605: PUSH
88606: LD_INT 0
88608: PUSH
88609: LD_INT 1
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 1
88618: NEG
88619: PUSH
88620: LD_INT 0
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 1
88629: NEG
88630: PUSH
88631: LD_INT 1
88633: NEG
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 1
88641: NEG
88642: PUSH
88643: LD_INT 2
88645: NEG
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 0
88653: PUSH
88654: LD_INT 2
88656: NEG
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: PUSH
88662: LD_INT 1
88664: PUSH
88665: LD_INT 1
88667: NEG
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: PUSH
88673: LD_INT 2
88675: PUSH
88676: LD_INT 1
88678: PUSH
88679: EMPTY
88680: LIST
88681: LIST
88682: PUSH
88683: LD_INT 2
88685: PUSH
88686: LD_INT 2
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: PUSH
88693: LD_INT 1
88695: PUSH
88696: LD_INT 2
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: LD_INT 2
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: PUSH
88713: LD_INT 1
88715: NEG
88716: PUSH
88717: LD_INT 1
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: PUSH
88724: LD_INT 2
88726: NEG
88727: PUSH
88728: LD_INT 1
88730: NEG
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: PUSH
88736: LD_INT 2
88738: NEG
88739: PUSH
88740: LD_INT 2
88742: NEG
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: PUSH
88748: LD_INT 2
88750: NEG
88751: PUSH
88752: LD_INT 3
88754: NEG
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 1
88762: NEG
88763: PUSH
88764: LD_INT 3
88766: NEG
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 0
88774: PUSH
88775: LD_INT 3
88777: NEG
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 1
88785: PUSH
88786: LD_INT 2
88788: NEG
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 3
88796: PUSH
88797: LD_INT 2
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 3
88806: PUSH
88807: LD_INT 3
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 2
88816: PUSH
88817: LD_INT 3
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: LD_INT 1
88826: PUSH
88827: LD_INT 3
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: LD_INT 0
88836: PUSH
88837: LD_INT 3
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 1
88846: NEG
88847: PUSH
88848: LD_INT 2
88850: PUSH
88851: EMPTY
88852: LIST
88853: LIST
88854: PUSH
88855: LD_INT 3
88857: NEG
88858: PUSH
88859: LD_INT 2
88861: NEG
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: PUSH
88867: LD_INT 3
88869: NEG
88870: PUSH
88871: LD_INT 3
88873: NEG
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: EMPTY
88880: LIST
88881: LIST
88882: LIST
88883: LIST
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: LIST
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88910: LD_ADDR_VAR 0 46
88914: PUSH
88915: LD_INT 0
88917: PUSH
88918: LD_INT 0
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 0
88927: PUSH
88928: LD_INT 1
88930: NEG
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: PUSH
88936: LD_INT 1
88938: PUSH
88939: LD_INT 0
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 1
88948: PUSH
88949: LD_INT 1
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 0
88958: PUSH
88959: LD_INT 1
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 1
88968: NEG
88969: PUSH
88970: LD_INT 0
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 1
88979: NEG
88980: PUSH
88981: LD_INT 1
88983: NEG
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: LD_INT 1
88991: NEG
88992: PUSH
88993: LD_INT 2
88995: NEG
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: PUSH
89001: LD_INT 0
89003: PUSH
89004: LD_INT 2
89006: NEG
89007: PUSH
89008: EMPTY
89009: LIST
89010: LIST
89011: PUSH
89012: LD_INT 1
89014: PUSH
89015: LD_INT 1
89017: NEG
89018: PUSH
89019: EMPTY
89020: LIST
89021: LIST
89022: PUSH
89023: LD_INT 2
89025: PUSH
89026: LD_INT 0
89028: PUSH
89029: EMPTY
89030: LIST
89031: LIST
89032: PUSH
89033: LD_INT 2
89035: PUSH
89036: LD_INT 1
89038: PUSH
89039: EMPTY
89040: LIST
89041: LIST
89042: PUSH
89043: LD_INT 1
89045: PUSH
89046: LD_INT 2
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 0
89055: PUSH
89056: LD_INT 2
89058: PUSH
89059: EMPTY
89060: LIST
89061: LIST
89062: PUSH
89063: LD_INT 1
89065: NEG
89066: PUSH
89067: LD_INT 1
89069: PUSH
89070: EMPTY
89071: LIST
89072: LIST
89073: PUSH
89074: LD_INT 2
89076: NEG
89077: PUSH
89078: LD_INT 0
89080: PUSH
89081: EMPTY
89082: LIST
89083: LIST
89084: PUSH
89085: LD_INT 2
89087: NEG
89088: PUSH
89089: LD_INT 1
89091: NEG
89092: PUSH
89093: EMPTY
89094: LIST
89095: LIST
89096: PUSH
89097: LD_INT 1
89099: NEG
89100: PUSH
89101: LD_INT 3
89103: NEG
89104: PUSH
89105: EMPTY
89106: LIST
89107: LIST
89108: PUSH
89109: LD_INT 0
89111: PUSH
89112: LD_INT 3
89114: NEG
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 1
89122: PUSH
89123: LD_INT 2
89125: NEG
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 2
89133: PUSH
89134: LD_INT 1
89136: NEG
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: LD_INT 3
89144: PUSH
89145: LD_INT 0
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 3
89154: PUSH
89155: LD_INT 1
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: PUSH
89162: LD_INT 1
89164: PUSH
89165: LD_INT 3
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 0
89174: PUSH
89175: LD_INT 3
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 1
89184: NEG
89185: PUSH
89186: LD_INT 2
89188: PUSH
89189: EMPTY
89190: LIST
89191: LIST
89192: PUSH
89193: LD_INT 2
89195: NEG
89196: PUSH
89197: LD_INT 1
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: LD_INT 3
89206: NEG
89207: PUSH
89208: LD_INT 0
89210: PUSH
89211: EMPTY
89212: LIST
89213: LIST
89214: PUSH
89215: LD_INT 3
89217: NEG
89218: PUSH
89219: LD_INT 1
89221: NEG
89222: PUSH
89223: EMPTY
89224: LIST
89225: LIST
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89258: LD_ADDR_VAR 0 47
89262: PUSH
89263: LD_INT 0
89265: PUSH
89266: LD_INT 0
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: PUSH
89273: LD_INT 0
89275: PUSH
89276: LD_INT 1
89278: NEG
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: PUSH
89284: LD_INT 1
89286: PUSH
89287: LD_INT 0
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: LD_INT 1
89296: PUSH
89297: LD_INT 1
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: PUSH
89304: LD_INT 0
89306: PUSH
89307: LD_INT 1
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: LD_INT 1
89316: NEG
89317: PUSH
89318: LD_INT 0
89320: PUSH
89321: EMPTY
89322: LIST
89323: LIST
89324: PUSH
89325: LD_INT 1
89327: NEG
89328: PUSH
89329: LD_INT 1
89331: NEG
89332: PUSH
89333: EMPTY
89334: LIST
89335: LIST
89336: PUSH
89337: LD_INT 1
89339: NEG
89340: PUSH
89341: LD_INT 2
89343: NEG
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: PUSH
89349: LD_INT 0
89351: PUSH
89352: LD_INT 2
89354: NEG
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 1
89362: PUSH
89363: LD_INT 1
89365: NEG
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 2
89373: NEG
89374: PUSH
89375: LD_INT 1
89377: NEG
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 2
89385: NEG
89386: PUSH
89387: LD_INT 2
89389: NEG
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89409: LD_ADDR_VAR 0 48
89413: PUSH
89414: LD_INT 0
89416: PUSH
89417: LD_INT 0
89419: PUSH
89420: EMPTY
89421: LIST
89422: LIST
89423: PUSH
89424: LD_INT 0
89426: PUSH
89427: LD_INT 1
89429: NEG
89430: PUSH
89431: EMPTY
89432: LIST
89433: LIST
89434: PUSH
89435: LD_INT 1
89437: PUSH
89438: LD_INT 0
89440: PUSH
89441: EMPTY
89442: LIST
89443: LIST
89444: PUSH
89445: LD_INT 1
89447: PUSH
89448: LD_INT 1
89450: PUSH
89451: EMPTY
89452: LIST
89453: LIST
89454: PUSH
89455: LD_INT 0
89457: PUSH
89458: LD_INT 1
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 1
89467: NEG
89468: PUSH
89469: LD_INT 0
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: PUSH
89476: LD_INT 1
89478: NEG
89479: PUSH
89480: LD_INT 1
89482: NEG
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: PUSH
89488: LD_INT 1
89490: NEG
89491: PUSH
89492: LD_INT 2
89494: NEG
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 0
89502: PUSH
89503: LD_INT 2
89505: NEG
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: LD_INT 1
89516: NEG
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 2
89524: PUSH
89525: LD_INT 0
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: LD_INT 2
89534: PUSH
89535: LD_INT 1
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89556: LD_ADDR_VAR 0 49
89560: PUSH
89561: LD_INT 0
89563: PUSH
89564: LD_INT 0
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: LD_INT 0
89573: PUSH
89574: LD_INT 1
89576: NEG
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: LD_INT 1
89584: PUSH
89585: LD_INT 0
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: PUSH
89592: LD_INT 1
89594: PUSH
89595: LD_INT 1
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: PUSH
89602: LD_INT 0
89604: PUSH
89605: LD_INT 1
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 1
89614: NEG
89615: PUSH
89616: LD_INT 0
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: PUSH
89623: LD_INT 1
89625: NEG
89626: PUSH
89627: LD_INT 1
89629: NEG
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 1
89637: PUSH
89638: LD_INT 1
89640: NEG
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 2
89648: PUSH
89649: LD_INT 0
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 2
89658: PUSH
89659: LD_INT 1
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 2
89668: PUSH
89669: LD_INT 2
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 1
89678: PUSH
89679: LD_INT 2
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: EMPTY
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89700: LD_ADDR_VAR 0 50
89704: PUSH
89705: LD_INT 0
89707: PUSH
89708: LD_INT 0
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: PUSH
89715: LD_INT 0
89717: PUSH
89718: LD_INT 1
89720: NEG
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: PUSH
89726: LD_INT 1
89728: PUSH
89729: LD_INT 0
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: PUSH
89736: LD_INT 1
89738: PUSH
89739: LD_INT 1
89741: PUSH
89742: EMPTY
89743: LIST
89744: LIST
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: LD_INT 1
89751: PUSH
89752: EMPTY
89753: LIST
89754: LIST
89755: PUSH
89756: LD_INT 1
89758: NEG
89759: PUSH
89760: LD_INT 0
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 1
89769: NEG
89770: PUSH
89771: LD_INT 1
89773: NEG
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 2
89781: PUSH
89782: LD_INT 1
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 2
89791: PUSH
89792: LD_INT 2
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 1
89801: PUSH
89802: LD_INT 2
89804: PUSH
89805: EMPTY
89806: LIST
89807: LIST
89808: PUSH
89809: LD_INT 0
89811: PUSH
89812: LD_INT 2
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: PUSH
89819: LD_INT 1
89821: NEG
89822: PUSH
89823: LD_INT 1
89825: PUSH
89826: EMPTY
89827: LIST
89828: LIST
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: LIST
89834: LIST
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89844: LD_ADDR_VAR 0 51
89848: PUSH
89849: LD_INT 0
89851: PUSH
89852: LD_INT 0
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 0
89861: PUSH
89862: LD_INT 1
89864: NEG
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: PUSH
89870: LD_INT 1
89872: PUSH
89873: LD_INT 0
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 1
89882: PUSH
89883: LD_INT 1
89885: PUSH
89886: EMPTY
89887: LIST
89888: LIST
89889: PUSH
89890: LD_INT 0
89892: PUSH
89893: LD_INT 1
89895: PUSH
89896: EMPTY
89897: LIST
89898: LIST
89899: PUSH
89900: LD_INT 1
89902: NEG
89903: PUSH
89904: LD_INT 0
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: PUSH
89911: LD_INT 1
89913: NEG
89914: PUSH
89915: LD_INT 1
89917: NEG
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: PUSH
89923: LD_INT 1
89925: PUSH
89926: LD_INT 2
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: PUSH
89933: LD_INT 0
89935: PUSH
89936: LD_INT 2
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 1
89945: NEG
89946: PUSH
89947: LD_INT 1
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PUSH
89954: LD_INT 2
89956: NEG
89957: PUSH
89958: LD_INT 0
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: PUSH
89965: LD_INT 2
89967: NEG
89968: PUSH
89969: LD_INT 1
89971: NEG
89972: PUSH
89973: EMPTY
89974: LIST
89975: LIST
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89991: LD_ADDR_VAR 0 52
89995: PUSH
89996: LD_INT 0
89998: PUSH
89999: LD_INT 0
90001: PUSH
90002: EMPTY
90003: LIST
90004: LIST
90005: PUSH
90006: LD_INT 0
90008: PUSH
90009: LD_INT 1
90011: NEG
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: LD_INT 1
90019: PUSH
90020: LD_INT 0
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 1
90029: PUSH
90030: LD_INT 1
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: PUSH
90037: LD_INT 0
90039: PUSH
90040: LD_INT 1
90042: PUSH
90043: EMPTY
90044: LIST
90045: LIST
90046: PUSH
90047: LD_INT 1
90049: NEG
90050: PUSH
90051: LD_INT 0
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: PUSH
90058: LD_INT 1
90060: NEG
90061: PUSH
90062: LD_INT 1
90064: NEG
90065: PUSH
90066: EMPTY
90067: LIST
90068: LIST
90069: PUSH
90070: LD_INT 1
90072: NEG
90073: PUSH
90074: LD_INT 2
90076: NEG
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 1
90084: NEG
90085: PUSH
90086: LD_INT 1
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: LD_INT 2
90095: NEG
90096: PUSH
90097: LD_INT 0
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: PUSH
90104: LD_INT 2
90106: NEG
90107: PUSH
90108: LD_INT 1
90110: NEG
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: PUSH
90116: LD_INT 2
90118: NEG
90119: PUSH
90120: LD_INT 2
90122: NEG
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: LIST
90135: LIST
90136: LIST
90137: LIST
90138: LIST
90139: LIST
90140: LIST
90141: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90142: LD_ADDR_VAR 0 53
90146: PUSH
90147: LD_INT 0
90149: PUSH
90150: LD_INT 0
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: PUSH
90157: LD_INT 0
90159: PUSH
90160: LD_INT 1
90162: NEG
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 1
90170: PUSH
90171: LD_INT 0
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 1
90180: PUSH
90181: LD_INT 1
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 0
90190: PUSH
90191: LD_INT 1
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: LD_INT 1
90200: NEG
90201: PUSH
90202: LD_INT 0
90204: PUSH
90205: EMPTY
90206: LIST
90207: LIST
90208: PUSH
90209: LD_INT 1
90211: NEG
90212: PUSH
90213: LD_INT 1
90215: NEG
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: PUSH
90221: LD_INT 1
90223: NEG
90224: PUSH
90225: LD_INT 2
90227: NEG
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 0
90235: PUSH
90236: LD_INT 2
90238: NEG
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: LD_INT 1
90246: PUSH
90247: LD_INT 1
90249: NEG
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PUSH
90255: LD_INT 2
90257: PUSH
90258: LD_INT 0
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 2
90267: PUSH
90268: LD_INT 1
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: LD_INT 2
90277: PUSH
90278: LD_INT 2
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 1
90287: PUSH
90288: LD_INT 2
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 0
90297: PUSH
90298: LD_INT 2
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: LD_INT 1
90307: NEG
90308: PUSH
90309: LD_INT 1
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 2
90318: NEG
90319: PUSH
90320: LD_INT 0
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PUSH
90327: LD_INT 2
90329: NEG
90330: PUSH
90331: LD_INT 1
90333: NEG
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: PUSH
90339: LD_INT 2
90341: NEG
90342: PUSH
90343: LD_INT 2
90345: NEG
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90372: LD_ADDR_VAR 0 54
90376: PUSH
90377: LD_INT 0
90379: PUSH
90380: LD_INT 0
90382: PUSH
90383: EMPTY
90384: LIST
90385: LIST
90386: PUSH
90387: LD_INT 0
90389: PUSH
90390: LD_INT 1
90392: NEG
90393: PUSH
90394: EMPTY
90395: LIST
90396: LIST
90397: PUSH
90398: LD_INT 1
90400: PUSH
90401: LD_INT 0
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 1
90410: PUSH
90411: LD_INT 1
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 0
90420: PUSH
90421: LD_INT 1
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: LD_INT 1
90430: NEG
90431: PUSH
90432: LD_INT 0
90434: PUSH
90435: EMPTY
90436: LIST
90437: LIST
90438: PUSH
90439: LD_INT 1
90441: NEG
90442: PUSH
90443: LD_INT 1
90445: NEG
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 1
90453: NEG
90454: PUSH
90455: LD_INT 2
90457: NEG
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 0
90465: PUSH
90466: LD_INT 2
90468: NEG
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: PUSH
90474: LD_INT 1
90476: PUSH
90477: LD_INT 1
90479: NEG
90480: PUSH
90481: EMPTY
90482: LIST
90483: LIST
90484: PUSH
90485: LD_INT 2
90487: PUSH
90488: LD_INT 0
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: PUSH
90495: LD_INT 2
90497: PUSH
90498: LD_INT 1
90500: PUSH
90501: EMPTY
90502: LIST
90503: LIST
90504: PUSH
90505: LD_INT 2
90507: PUSH
90508: LD_INT 2
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PUSH
90515: LD_INT 1
90517: PUSH
90518: LD_INT 2
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 0
90527: PUSH
90528: LD_INT 2
90530: PUSH
90531: EMPTY
90532: LIST
90533: LIST
90534: PUSH
90535: LD_INT 1
90537: NEG
90538: PUSH
90539: LD_INT 1
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: LD_INT 2
90548: NEG
90549: PUSH
90550: LD_INT 0
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: LD_INT 2
90559: NEG
90560: PUSH
90561: LD_INT 1
90563: NEG
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: PUSH
90569: LD_INT 2
90571: NEG
90572: PUSH
90573: LD_INT 2
90575: NEG
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90602: LD_ADDR_VAR 0 55
90606: PUSH
90607: LD_INT 0
90609: PUSH
90610: LD_INT 0
90612: PUSH
90613: EMPTY
90614: LIST
90615: LIST
90616: PUSH
90617: LD_INT 0
90619: PUSH
90620: LD_INT 1
90622: NEG
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: PUSH
90628: LD_INT 1
90630: PUSH
90631: LD_INT 0
90633: PUSH
90634: EMPTY
90635: LIST
90636: LIST
90637: PUSH
90638: LD_INT 1
90640: PUSH
90641: LD_INT 1
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PUSH
90648: LD_INT 0
90650: PUSH
90651: LD_INT 1
90653: PUSH
90654: EMPTY
90655: LIST
90656: LIST
90657: PUSH
90658: LD_INT 1
90660: NEG
90661: PUSH
90662: LD_INT 0
90664: PUSH
90665: EMPTY
90666: LIST
90667: LIST
90668: PUSH
90669: LD_INT 1
90671: NEG
90672: PUSH
90673: LD_INT 1
90675: NEG
90676: PUSH
90677: EMPTY
90678: LIST
90679: LIST
90680: PUSH
90681: LD_INT 1
90683: NEG
90684: PUSH
90685: LD_INT 2
90687: NEG
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 0
90695: PUSH
90696: LD_INT 2
90698: NEG
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 1
90706: PUSH
90707: LD_INT 1
90709: NEG
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 2
90717: PUSH
90718: LD_INT 0
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: PUSH
90725: LD_INT 2
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: LD_INT 2
90737: PUSH
90738: LD_INT 2
90740: PUSH
90741: EMPTY
90742: LIST
90743: LIST
90744: PUSH
90745: LD_INT 1
90747: PUSH
90748: LD_INT 2
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 0
90757: PUSH
90758: LD_INT 2
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: PUSH
90765: LD_INT 1
90767: NEG
90768: PUSH
90769: LD_INT 1
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: PUSH
90776: LD_INT 2
90778: NEG
90779: PUSH
90780: LD_INT 0
90782: PUSH
90783: EMPTY
90784: LIST
90785: LIST
90786: PUSH
90787: LD_INT 2
90789: NEG
90790: PUSH
90791: LD_INT 1
90793: NEG
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: LD_INT 2
90801: NEG
90802: PUSH
90803: LD_INT 2
90805: NEG
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: LIST
90829: LIST
90830: LIST
90831: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90832: LD_ADDR_VAR 0 56
90836: PUSH
90837: LD_INT 0
90839: PUSH
90840: LD_INT 0
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: LD_INT 0
90849: PUSH
90850: LD_INT 1
90852: NEG
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: PUSH
90858: LD_INT 1
90860: PUSH
90861: LD_INT 0
90863: PUSH
90864: EMPTY
90865: LIST
90866: LIST
90867: PUSH
90868: LD_INT 1
90870: PUSH
90871: LD_INT 1
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: PUSH
90878: LD_INT 0
90880: PUSH
90881: LD_INT 1
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PUSH
90888: LD_INT 1
90890: NEG
90891: PUSH
90892: LD_INT 0
90894: PUSH
90895: EMPTY
90896: LIST
90897: LIST
90898: PUSH
90899: LD_INT 1
90901: NEG
90902: PUSH
90903: LD_INT 1
90905: NEG
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 1
90913: NEG
90914: PUSH
90915: LD_INT 2
90917: NEG
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 0
90925: PUSH
90926: LD_INT 2
90928: NEG
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: PUSH
90934: LD_INT 1
90936: PUSH
90937: LD_INT 1
90939: NEG
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 2
90947: PUSH
90948: LD_INT 0
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 2
90957: PUSH
90958: LD_INT 1
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: PUSH
90965: LD_INT 2
90967: PUSH
90968: LD_INT 2
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PUSH
90975: LD_INT 1
90977: PUSH
90978: LD_INT 2
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 0
90987: PUSH
90988: LD_INT 2
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: PUSH
90995: LD_INT 1
90997: NEG
90998: PUSH
90999: LD_INT 1
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 2
91008: NEG
91009: PUSH
91010: LD_INT 0
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: LD_INT 2
91019: NEG
91020: PUSH
91021: LD_INT 1
91023: NEG
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 2
91031: NEG
91032: PUSH
91033: LD_INT 2
91035: NEG
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91062: LD_ADDR_VAR 0 57
91066: PUSH
91067: LD_INT 0
91069: PUSH
91070: LD_INT 0
91072: PUSH
91073: EMPTY
91074: LIST
91075: LIST
91076: PUSH
91077: LD_INT 0
91079: PUSH
91080: LD_INT 1
91082: NEG
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: LD_INT 1
91090: PUSH
91091: LD_INT 0
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PUSH
91098: LD_INT 1
91100: PUSH
91101: LD_INT 1
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: LD_INT 0
91110: PUSH
91111: LD_INT 1
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: LD_INT 1
91120: NEG
91121: PUSH
91122: LD_INT 0
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: LD_INT 1
91131: NEG
91132: PUSH
91133: LD_INT 1
91135: NEG
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 1
91143: NEG
91144: PUSH
91145: LD_INT 2
91147: NEG
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 0
91155: PUSH
91156: LD_INT 2
91158: NEG
91159: PUSH
91160: EMPTY
91161: LIST
91162: LIST
91163: PUSH
91164: LD_INT 1
91166: PUSH
91167: LD_INT 1
91169: NEG
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 2
91177: PUSH
91178: LD_INT 0
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 2
91187: PUSH
91188: LD_INT 1
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 2
91197: PUSH
91198: LD_INT 2
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: LD_INT 2
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 0
91217: PUSH
91218: LD_INT 2
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 1
91227: NEG
91228: PUSH
91229: LD_INT 1
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: LD_INT 2
91238: NEG
91239: PUSH
91240: LD_INT 0
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: LD_INT 2
91249: NEG
91250: PUSH
91251: LD_INT 1
91253: NEG
91254: PUSH
91255: EMPTY
91256: LIST
91257: LIST
91258: PUSH
91259: LD_INT 2
91261: NEG
91262: PUSH
91263: LD_INT 2
91265: NEG
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91292: LD_ADDR_VAR 0 58
91296: PUSH
91297: LD_INT 0
91299: PUSH
91300: LD_INT 0
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 0
91309: PUSH
91310: LD_INT 1
91312: NEG
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: PUSH
91318: LD_INT 1
91320: PUSH
91321: LD_INT 0
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: PUSH
91328: LD_INT 1
91330: PUSH
91331: LD_INT 1
91333: PUSH
91334: EMPTY
91335: LIST
91336: LIST
91337: PUSH
91338: LD_INT 0
91340: PUSH
91341: LD_INT 1
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: LD_INT 1
91350: NEG
91351: PUSH
91352: LD_INT 0
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: PUSH
91359: LD_INT 1
91361: NEG
91362: PUSH
91363: LD_INT 1
91365: NEG
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 1
91373: NEG
91374: PUSH
91375: LD_INT 2
91377: NEG
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: LD_INT 0
91385: PUSH
91386: LD_INT 2
91388: NEG
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: LD_INT 1
91396: PUSH
91397: LD_INT 1
91399: NEG
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: PUSH
91405: LD_INT 2
91407: PUSH
91408: LD_INT 0
91410: PUSH
91411: EMPTY
91412: LIST
91413: LIST
91414: PUSH
91415: LD_INT 2
91417: PUSH
91418: LD_INT 1
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: PUSH
91425: LD_INT 2
91427: PUSH
91428: LD_INT 2
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: PUSH
91435: LD_INT 1
91437: PUSH
91438: LD_INT 2
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 0
91447: PUSH
91448: LD_INT 2
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PUSH
91455: LD_INT 1
91457: NEG
91458: PUSH
91459: LD_INT 1
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 2
91468: NEG
91469: PUSH
91470: LD_INT 0
91472: PUSH
91473: EMPTY
91474: LIST
91475: LIST
91476: PUSH
91477: LD_INT 2
91479: NEG
91480: PUSH
91481: LD_INT 1
91483: NEG
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 2
91491: NEG
91492: PUSH
91493: LD_INT 2
91495: NEG
91496: PUSH
91497: EMPTY
91498: LIST
91499: LIST
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: LIST
91505: LIST
91506: LIST
91507: LIST
91508: LIST
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: LIST
91520: LIST
91521: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91522: LD_ADDR_VAR 0 59
91526: PUSH
91527: LD_INT 0
91529: PUSH
91530: LD_INT 0
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PUSH
91537: LD_INT 0
91539: PUSH
91540: LD_INT 1
91542: NEG
91543: PUSH
91544: EMPTY
91545: LIST
91546: LIST
91547: PUSH
91548: LD_INT 1
91550: PUSH
91551: LD_INT 0
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: PUSH
91558: LD_INT 1
91560: PUSH
91561: LD_INT 1
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: PUSH
91568: LD_INT 0
91570: PUSH
91571: LD_INT 1
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: LD_INT 1
91580: NEG
91581: PUSH
91582: LD_INT 0
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: LD_INT 1
91591: NEG
91592: PUSH
91593: LD_INT 1
91595: NEG
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91610: LD_ADDR_VAR 0 60
91614: PUSH
91615: LD_INT 0
91617: PUSH
91618: LD_INT 0
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: PUSH
91625: LD_INT 0
91627: PUSH
91628: LD_INT 1
91630: NEG
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: LD_INT 1
91638: PUSH
91639: LD_INT 0
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: PUSH
91646: LD_INT 1
91648: PUSH
91649: LD_INT 1
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: LD_INT 0
91658: PUSH
91659: LD_INT 1
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: PUSH
91666: LD_INT 1
91668: NEG
91669: PUSH
91670: LD_INT 0
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: PUSH
91677: LD_INT 1
91679: NEG
91680: PUSH
91681: LD_INT 1
91683: NEG
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91698: LD_ADDR_VAR 0 61
91702: PUSH
91703: LD_INT 0
91705: PUSH
91706: LD_INT 0
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: PUSH
91713: LD_INT 0
91715: PUSH
91716: LD_INT 1
91718: NEG
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: PUSH
91724: LD_INT 1
91726: PUSH
91727: LD_INT 0
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: PUSH
91734: LD_INT 1
91736: PUSH
91737: LD_INT 1
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: PUSH
91744: LD_INT 0
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: LD_INT 1
91756: NEG
91757: PUSH
91758: LD_INT 0
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 1
91767: NEG
91768: PUSH
91769: LD_INT 1
91771: NEG
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91786: LD_ADDR_VAR 0 62
91790: PUSH
91791: LD_INT 0
91793: PUSH
91794: LD_INT 0
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: LD_INT 0
91803: PUSH
91804: LD_INT 1
91806: NEG
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: LD_INT 1
91814: PUSH
91815: LD_INT 0
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 1
91824: PUSH
91825: LD_INT 1
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: PUSH
91832: LD_INT 0
91834: PUSH
91835: LD_INT 1
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 1
91844: NEG
91845: PUSH
91846: LD_INT 0
91848: PUSH
91849: EMPTY
91850: LIST
91851: LIST
91852: PUSH
91853: LD_INT 1
91855: NEG
91856: PUSH
91857: LD_INT 1
91859: NEG
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91874: LD_ADDR_VAR 0 63
91878: PUSH
91879: LD_INT 0
91881: PUSH
91882: LD_INT 0
91884: PUSH
91885: EMPTY
91886: LIST
91887: LIST
91888: PUSH
91889: LD_INT 0
91891: PUSH
91892: LD_INT 1
91894: NEG
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: PUSH
91900: LD_INT 1
91902: PUSH
91903: LD_INT 0
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: PUSH
91910: LD_INT 1
91912: PUSH
91913: LD_INT 1
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: LD_INT 0
91922: PUSH
91923: LD_INT 1
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: PUSH
91930: LD_INT 1
91932: NEG
91933: PUSH
91934: LD_INT 0
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 1
91943: NEG
91944: PUSH
91945: LD_INT 1
91947: NEG
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91962: LD_ADDR_VAR 0 64
91966: PUSH
91967: LD_INT 0
91969: PUSH
91970: LD_INT 0
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: PUSH
91977: LD_INT 0
91979: PUSH
91980: LD_INT 1
91982: NEG
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: PUSH
91988: LD_INT 1
91990: PUSH
91991: LD_INT 0
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: PUSH
91998: LD_INT 1
92000: PUSH
92001: LD_INT 1
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: LD_INT 0
92010: PUSH
92011: LD_INT 1
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 1
92020: NEG
92021: PUSH
92022: LD_INT 0
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PUSH
92029: LD_INT 1
92031: NEG
92032: PUSH
92033: LD_INT 1
92035: NEG
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: EMPTY
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: ST_TO_ADDR
// end ; 1 :
92050: GO 97947
92052: LD_INT 1
92054: DOUBLE
92055: EQUAL
92056: IFTRUE 92060
92058: GO 94683
92060: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92061: LD_ADDR_VAR 0 11
92065: PUSH
92066: LD_INT 1
92068: NEG
92069: PUSH
92070: LD_INT 3
92072: NEG
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: PUSH
92078: LD_INT 0
92080: PUSH
92081: LD_INT 3
92083: NEG
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 1
92091: PUSH
92092: LD_INT 2
92094: NEG
92095: PUSH
92096: EMPTY
92097: LIST
92098: LIST
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: LIST
92104: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92105: LD_ADDR_VAR 0 12
92109: PUSH
92110: LD_INT 2
92112: PUSH
92113: LD_INT 1
92115: NEG
92116: PUSH
92117: EMPTY
92118: LIST
92119: LIST
92120: PUSH
92121: LD_INT 3
92123: PUSH
92124: LD_INT 0
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: PUSH
92131: LD_INT 3
92133: PUSH
92134: LD_INT 1
92136: PUSH
92137: EMPTY
92138: LIST
92139: LIST
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: LIST
92145: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92146: LD_ADDR_VAR 0 13
92150: PUSH
92151: LD_INT 3
92153: PUSH
92154: LD_INT 2
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PUSH
92161: LD_INT 3
92163: PUSH
92164: LD_INT 3
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: PUSH
92171: LD_INT 2
92173: PUSH
92174: LD_INT 3
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: LIST
92185: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92186: LD_ADDR_VAR 0 14
92190: PUSH
92191: LD_INT 1
92193: PUSH
92194: LD_INT 3
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: LD_INT 0
92203: PUSH
92204: LD_INT 3
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 1
92213: NEG
92214: PUSH
92215: LD_INT 2
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: LIST
92226: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92227: LD_ADDR_VAR 0 15
92231: PUSH
92232: LD_INT 2
92234: NEG
92235: PUSH
92236: LD_INT 1
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PUSH
92243: LD_INT 3
92245: NEG
92246: PUSH
92247: LD_INT 0
92249: PUSH
92250: EMPTY
92251: LIST
92252: LIST
92253: PUSH
92254: LD_INT 3
92256: NEG
92257: PUSH
92258: LD_INT 1
92260: NEG
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: EMPTY
92267: LIST
92268: LIST
92269: LIST
92270: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92271: LD_ADDR_VAR 0 16
92275: PUSH
92276: LD_INT 2
92278: NEG
92279: PUSH
92280: LD_INT 3
92282: NEG
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 3
92290: NEG
92291: PUSH
92292: LD_INT 2
92294: NEG
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: LD_INT 3
92302: NEG
92303: PUSH
92304: LD_INT 3
92306: NEG
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: LIST
92316: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92317: LD_ADDR_VAR 0 17
92321: PUSH
92322: LD_INT 1
92324: NEG
92325: PUSH
92326: LD_INT 3
92328: NEG
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 0
92336: PUSH
92337: LD_INT 3
92339: NEG
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 1
92347: PUSH
92348: LD_INT 2
92350: NEG
92351: PUSH
92352: EMPTY
92353: LIST
92354: LIST
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: LIST
92360: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92361: LD_ADDR_VAR 0 18
92365: PUSH
92366: LD_INT 2
92368: PUSH
92369: LD_INT 1
92371: NEG
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: LD_INT 3
92379: PUSH
92380: LD_INT 0
92382: PUSH
92383: EMPTY
92384: LIST
92385: LIST
92386: PUSH
92387: LD_INT 3
92389: PUSH
92390: LD_INT 1
92392: PUSH
92393: EMPTY
92394: LIST
92395: LIST
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: LIST
92401: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92402: LD_ADDR_VAR 0 19
92406: PUSH
92407: LD_INT 3
92409: PUSH
92410: LD_INT 2
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PUSH
92417: LD_INT 3
92419: PUSH
92420: LD_INT 3
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: PUSH
92427: LD_INT 2
92429: PUSH
92430: LD_INT 3
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: LIST
92441: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92442: LD_ADDR_VAR 0 20
92446: PUSH
92447: LD_INT 1
92449: PUSH
92450: LD_INT 3
92452: PUSH
92453: EMPTY
92454: LIST
92455: LIST
92456: PUSH
92457: LD_INT 0
92459: PUSH
92460: LD_INT 3
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: LD_INT 1
92469: NEG
92470: PUSH
92471: LD_INT 2
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: LIST
92482: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92483: LD_ADDR_VAR 0 21
92487: PUSH
92488: LD_INT 2
92490: NEG
92491: PUSH
92492: LD_INT 1
92494: PUSH
92495: EMPTY
92496: LIST
92497: LIST
92498: PUSH
92499: LD_INT 3
92501: NEG
92502: PUSH
92503: LD_INT 0
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: PUSH
92510: LD_INT 3
92512: NEG
92513: PUSH
92514: LD_INT 1
92516: NEG
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: LIST
92526: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92527: LD_ADDR_VAR 0 22
92531: PUSH
92532: LD_INT 2
92534: NEG
92535: PUSH
92536: LD_INT 3
92538: NEG
92539: PUSH
92540: EMPTY
92541: LIST
92542: LIST
92543: PUSH
92544: LD_INT 3
92546: NEG
92547: PUSH
92548: LD_INT 2
92550: NEG
92551: PUSH
92552: EMPTY
92553: LIST
92554: LIST
92555: PUSH
92556: LD_INT 3
92558: NEG
92559: PUSH
92560: LD_INT 3
92562: NEG
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: EMPTY
92569: LIST
92570: LIST
92571: LIST
92572: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92573: LD_ADDR_VAR 0 23
92577: PUSH
92578: LD_INT 0
92580: PUSH
92581: LD_INT 3
92583: NEG
92584: PUSH
92585: EMPTY
92586: LIST
92587: LIST
92588: PUSH
92589: LD_INT 1
92591: NEG
92592: PUSH
92593: LD_INT 4
92595: NEG
92596: PUSH
92597: EMPTY
92598: LIST
92599: LIST
92600: PUSH
92601: LD_INT 1
92603: PUSH
92604: LD_INT 3
92606: NEG
92607: PUSH
92608: EMPTY
92609: LIST
92610: LIST
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: LIST
92616: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92617: LD_ADDR_VAR 0 24
92621: PUSH
92622: LD_INT 3
92624: PUSH
92625: LD_INT 0
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 3
92634: PUSH
92635: LD_INT 1
92637: NEG
92638: PUSH
92639: EMPTY
92640: LIST
92641: LIST
92642: PUSH
92643: LD_INT 4
92645: PUSH
92646: LD_INT 1
92648: PUSH
92649: EMPTY
92650: LIST
92651: LIST
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: LIST
92657: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92658: LD_ADDR_VAR 0 25
92662: PUSH
92663: LD_INT 3
92665: PUSH
92666: LD_INT 3
92668: PUSH
92669: EMPTY
92670: LIST
92671: LIST
92672: PUSH
92673: LD_INT 4
92675: PUSH
92676: LD_INT 3
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: PUSH
92683: LD_INT 3
92685: PUSH
92686: LD_INT 4
92688: PUSH
92689: EMPTY
92690: LIST
92691: LIST
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: LIST
92697: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92698: LD_ADDR_VAR 0 26
92702: PUSH
92703: LD_INT 0
92705: PUSH
92706: LD_INT 3
92708: PUSH
92709: EMPTY
92710: LIST
92711: LIST
92712: PUSH
92713: LD_INT 1
92715: PUSH
92716: LD_INT 4
92718: PUSH
92719: EMPTY
92720: LIST
92721: LIST
92722: PUSH
92723: LD_INT 1
92725: NEG
92726: PUSH
92727: LD_INT 3
92729: PUSH
92730: EMPTY
92731: LIST
92732: LIST
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: LIST
92738: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92739: LD_ADDR_VAR 0 27
92743: PUSH
92744: LD_INT 3
92746: NEG
92747: PUSH
92748: LD_INT 0
92750: PUSH
92751: EMPTY
92752: LIST
92753: LIST
92754: PUSH
92755: LD_INT 3
92757: NEG
92758: PUSH
92759: LD_INT 1
92761: PUSH
92762: EMPTY
92763: LIST
92764: LIST
92765: PUSH
92766: LD_INT 4
92768: NEG
92769: PUSH
92770: LD_INT 1
92772: NEG
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: EMPTY
92779: LIST
92780: LIST
92781: LIST
92782: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92783: LD_ADDR_VAR 0 28
92787: PUSH
92788: LD_INT 3
92790: NEG
92791: PUSH
92792: LD_INT 3
92794: NEG
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: PUSH
92800: LD_INT 3
92802: NEG
92803: PUSH
92804: LD_INT 4
92806: NEG
92807: PUSH
92808: EMPTY
92809: LIST
92810: LIST
92811: PUSH
92812: LD_INT 4
92814: NEG
92815: PUSH
92816: LD_INT 3
92818: NEG
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: LIST
92828: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92829: LD_ADDR_VAR 0 29
92833: PUSH
92834: LD_INT 1
92836: NEG
92837: PUSH
92838: LD_INT 3
92840: NEG
92841: PUSH
92842: EMPTY
92843: LIST
92844: LIST
92845: PUSH
92846: LD_INT 0
92848: PUSH
92849: LD_INT 3
92851: NEG
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: LD_INT 1
92859: PUSH
92860: LD_INT 2
92862: NEG
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 1
92870: NEG
92871: PUSH
92872: LD_INT 4
92874: NEG
92875: PUSH
92876: EMPTY
92877: LIST
92878: LIST
92879: PUSH
92880: LD_INT 0
92882: PUSH
92883: LD_INT 4
92885: NEG
92886: PUSH
92887: EMPTY
92888: LIST
92889: LIST
92890: PUSH
92891: LD_INT 1
92893: PUSH
92894: LD_INT 3
92896: NEG
92897: PUSH
92898: EMPTY
92899: LIST
92900: LIST
92901: PUSH
92902: LD_INT 1
92904: NEG
92905: PUSH
92906: LD_INT 5
92908: NEG
92909: PUSH
92910: EMPTY
92911: LIST
92912: LIST
92913: PUSH
92914: LD_INT 0
92916: PUSH
92917: LD_INT 5
92919: NEG
92920: PUSH
92921: EMPTY
92922: LIST
92923: LIST
92924: PUSH
92925: LD_INT 1
92927: PUSH
92928: LD_INT 4
92930: NEG
92931: PUSH
92932: EMPTY
92933: LIST
92934: LIST
92935: PUSH
92936: LD_INT 1
92938: NEG
92939: PUSH
92940: LD_INT 6
92942: NEG
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: PUSH
92948: LD_INT 0
92950: PUSH
92951: LD_INT 6
92953: NEG
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: LD_INT 1
92961: PUSH
92962: LD_INT 5
92964: NEG
92965: PUSH
92966: EMPTY
92967: LIST
92968: LIST
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92984: LD_ADDR_VAR 0 30
92988: PUSH
92989: LD_INT 2
92991: PUSH
92992: LD_INT 1
92994: NEG
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: PUSH
93000: LD_INT 3
93002: PUSH
93003: LD_INT 0
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 3
93012: PUSH
93013: LD_INT 1
93015: PUSH
93016: EMPTY
93017: LIST
93018: LIST
93019: PUSH
93020: LD_INT 3
93022: PUSH
93023: LD_INT 1
93025: NEG
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 4
93033: PUSH
93034: LD_INT 0
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 4
93043: PUSH
93044: LD_INT 1
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: PUSH
93051: LD_INT 4
93053: PUSH
93054: LD_INT 1
93056: NEG
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: PUSH
93062: LD_INT 5
93064: PUSH
93065: LD_INT 0
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 5
93074: PUSH
93075: LD_INT 1
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 5
93084: PUSH
93085: LD_INT 1
93087: NEG
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: PUSH
93093: LD_INT 6
93095: PUSH
93096: LD_INT 0
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PUSH
93103: LD_INT 6
93105: PUSH
93106: LD_INT 1
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: EMPTY
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
93127: LD_ADDR_VAR 0 31
93131: PUSH
93132: LD_INT 3
93134: PUSH
93135: LD_INT 2
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 3
93144: PUSH
93145: LD_INT 3
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: PUSH
93152: LD_INT 2
93154: PUSH
93155: LD_INT 3
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: LD_INT 4
93164: PUSH
93165: LD_INT 3
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PUSH
93172: LD_INT 4
93174: PUSH
93175: LD_INT 4
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 3
93184: PUSH
93185: LD_INT 4
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: PUSH
93192: LD_INT 5
93194: PUSH
93195: LD_INT 4
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 5
93204: PUSH
93205: LD_INT 5
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PUSH
93212: LD_INT 4
93214: PUSH
93215: LD_INT 5
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 6
93224: PUSH
93225: LD_INT 5
93227: PUSH
93228: EMPTY
93229: LIST
93230: LIST
93231: PUSH
93232: LD_INT 6
93234: PUSH
93235: LD_INT 6
93237: PUSH
93238: EMPTY
93239: LIST
93240: LIST
93241: PUSH
93242: LD_INT 5
93244: PUSH
93245: LD_INT 6
93247: PUSH
93248: EMPTY
93249: LIST
93250: LIST
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93266: LD_ADDR_VAR 0 32
93270: PUSH
93271: LD_INT 1
93273: PUSH
93274: LD_INT 3
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: LD_INT 0
93283: PUSH
93284: LD_INT 3
93286: PUSH
93287: EMPTY
93288: LIST
93289: LIST
93290: PUSH
93291: LD_INT 1
93293: NEG
93294: PUSH
93295: LD_INT 2
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 1
93304: PUSH
93305: LD_INT 4
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PUSH
93312: LD_INT 0
93314: PUSH
93315: LD_INT 4
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: LD_INT 1
93324: NEG
93325: PUSH
93326: LD_INT 3
93328: PUSH
93329: EMPTY
93330: LIST
93331: LIST
93332: PUSH
93333: LD_INT 1
93335: PUSH
93336: LD_INT 5
93338: PUSH
93339: EMPTY
93340: LIST
93341: LIST
93342: PUSH
93343: LD_INT 0
93345: PUSH
93346: LD_INT 5
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: LD_INT 1
93355: NEG
93356: PUSH
93357: LD_INT 4
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: LD_INT 1
93366: PUSH
93367: LD_INT 6
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 0
93376: PUSH
93377: LD_INT 6
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: PUSH
93384: LD_INT 1
93386: NEG
93387: PUSH
93388: LD_INT 5
93390: PUSH
93391: EMPTY
93392: LIST
93393: LIST
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93409: LD_ADDR_VAR 0 33
93413: PUSH
93414: LD_INT 2
93416: NEG
93417: PUSH
93418: LD_INT 1
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 3
93427: NEG
93428: PUSH
93429: LD_INT 0
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: LD_INT 3
93438: NEG
93439: PUSH
93440: LD_INT 1
93442: NEG
93443: PUSH
93444: EMPTY
93445: LIST
93446: LIST
93447: PUSH
93448: LD_INT 3
93450: NEG
93451: PUSH
93452: LD_INT 1
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: PUSH
93459: LD_INT 4
93461: NEG
93462: PUSH
93463: LD_INT 0
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: LD_INT 4
93472: NEG
93473: PUSH
93474: LD_INT 1
93476: NEG
93477: PUSH
93478: EMPTY
93479: LIST
93480: LIST
93481: PUSH
93482: LD_INT 4
93484: NEG
93485: PUSH
93486: LD_INT 1
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: PUSH
93493: LD_INT 5
93495: NEG
93496: PUSH
93497: LD_INT 0
93499: PUSH
93500: EMPTY
93501: LIST
93502: LIST
93503: PUSH
93504: LD_INT 5
93506: NEG
93507: PUSH
93508: LD_INT 1
93510: NEG
93511: PUSH
93512: EMPTY
93513: LIST
93514: LIST
93515: PUSH
93516: LD_INT 5
93518: NEG
93519: PUSH
93520: LD_INT 1
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 6
93529: NEG
93530: PUSH
93531: LD_INT 0
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: PUSH
93538: LD_INT 6
93540: NEG
93541: PUSH
93542: LD_INT 1
93544: NEG
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93564: LD_ADDR_VAR 0 34
93568: PUSH
93569: LD_INT 2
93571: NEG
93572: PUSH
93573: LD_INT 3
93575: NEG
93576: PUSH
93577: EMPTY
93578: LIST
93579: LIST
93580: PUSH
93581: LD_INT 3
93583: NEG
93584: PUSH
93585: LD_INT 2
93587: NEG
93588: PUSH
93589: EMPTY
93590: LIST
93591: LIST
93592: PUSH
93593: LD_INT 3
93595: NEG
93596: PUSH
93597: LD_INT 3
93599: NEG
93600: PUSH
93601: EMPTY
93602: LIST
93603: LIST
93604: PUSH
93605: LD_INT 3
93607: NEG
93608: PUSH
93609: LD_INT 4
93611: NEG
93612: PUSH
93613: EMPTY
93614: LIST
93615: LIST
93616: PUSH
93617: LD_INT 4
93619: NEG
93620: PUSH
93621: LD_INT 3
93623: NEG
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 4
93631: NEG
93632: PUSH
93633: LD_INT 4
93635: NEG
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 4
93643: NEG
93644: PUSH
93645: LD_INT 5
93647: NEG
93648: PUSH
93649: EMPTY
93650: LIST
93651: LIST
93652: PUSH
93653: LD_INT 5
93655: NEG
93656: PUSH
93657: LD_INT 4
93659: NEG
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: LD_INT 5
93667: NEG
93668: PUSH
93669: LD_INT 5
93671: NEG
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 5
93679: NEG
93680: PUSH
93681: LD_INT 6
93683: NEG
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: PUSH
93689: LD_INT 6
93691: NEG
93692: PUSH
93693: LD_INT 5
93695: NEG
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 6
93703: NEG
93704: PUSH
93705: LD_INT 6
93707: NEG
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93727: LD_ADDR_VAR 0 41
93731: PUSH
93732: LD_INT 0
93734: PUSH
93735: LD_INT 2
93737: NEG
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 1
93745: NEG
93746: PUSH
93747: LD_INT 3
93749: NEG
93750: PUSH
93751: EMPTY
93752: LIST
93753: LIST
93754: PUSH
93755: LD_INT 1
93757: PUSH
93758: LD_INT 2
93760: NEG
93761: PUSH
93762: EMPTY
93763: LIST
93764: LIST
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: LIST
93770: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93771: LD_ADDR_VAR 0 42
93775: PUSH
93776: LD_INT 2
93778: PUSH
93779: LD_INT 0
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: LD_INT 2
93788: PUSH
93789: LD_INT 1
93791: NEG
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: LD_INT 3
93799: PUSH
93800: LD_INT 1
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: PUSH
93807: EMPTY
93808: LIST
93809: LIST
93810: LIST
93811: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93812: LD_ADDR_VAR 0 43
93816: PUSH
93817: LD_INT 2
93819: PUSH
93820: LD_INT 2
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 3
93829: PUSH
93830: LD_INT 2
93832: PUSH
93833: EMPTY
93834: LIST
93835: LIST
93836: PUSH
93837: LD_INT 2
93839: PUSH
93840: LD_INT 3
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: LIST
93851: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93852: LD_ADDR_VAR 0 44
93856: PUSH
93857: LD_INT 0
93859: PUSH
93860: LD_INT 2
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: PUSH
93867: LD_INT 1
93869: PUSH
93870: LD_INT 3
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 1
93879: NEG
93880: PUSH
93881: LD_INT 2
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: LIST
93892: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93893: LD_ADDR_VAR 0 45
93897: PUSH
93898: LD_INT 2
93900: NEG
93901: PUSH
93902: LD_INT 0
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: PUSH
93909: LD_INT 2
93911: NEG
93912: PUSH
93913: LD_INT 1
93915: PUSH
93916: EMPTY
93917: LIST
93918: LIST
93919: PUSH
93920: LD_INT 3
93922: NEG
93923: PUSH
93924: LD_INT 1
93926: NEG
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: EMPTY
93933: LIST
93934: LIST
93935: LIST
93936: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93937: LD_ADDR_VAR 0 46
93941: PUSH
93942: LD_INT 2
93944: NEG
93945: PUSH
93946: LD_INT 2
93948: NEG
93949: PUSH
93950: EMPTY
93951: LIST
93952: LIST
93953: PUSH
93954: LD_INT 2
93956: NEG
93957: PUSH
93958: LD_INT 3
93960: NEG
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: PUSH
93966: LD_INT 3
93968: NEG
93969: PUSH
93970: LD_INT 2
93972: NEG
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: PUSH
93978: EMPTY
93979: LIST
93980: LIST
93981: LIST
93982: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93983: LD_ADDR_VAR 0 47
93987: PUSH
93988: LD_INT 2
93990: NEG
93991: PUSH
93992: LD_INT 3
93994: NEG
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 1
94002: NEG
94003: PUSH
94004: LD_INT 3
94006: NEG
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
94016: LD_ADDR_VAR 0 48
94020: PUSH
94021: LD_INT 1
94023: PUSH
94024: LD_INT 2
94026: NEG
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: PUSH
94032: LD_INT 2
94034: PUSH
94035: LD_INT 1
94037: NEG
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
94047: LD_ADDR_VAR 0 49
94051: PUSH
94052: LD_INT 3
94054: PUSH
94055: LD_INT 1
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: PUSH
94062: LD_INT 3
94064: PUSH
94065: LD_INT 2
94067: PUSH
94068: EMPTY
94069: LIST
94070: LIST
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
94076: LD_ADDR_VAR 0 50
94080: PUSH
94081: LD_INT 2
94083: PUSH
94084: LD_INT 3
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PUSH
94091: LD_INT 1
94093: PUSH
94094: LD_INT 3
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
94105: LD_ADDR_VAR 0 51
94109: PUSH
94110: LD_INT 1
94112: NEG
94113: PUSH
94114: LD_INT 2
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 2
94123: NEG
94124: PUSH
94125: LD_INT 1
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
94136: LD_ADDR_VAR 0 52
94140: PUSH
94141: LD_INT 3
94143: NEG
94144: PUSH
94145: LD_INT 1
94147: NEG
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: PUSH
94153: LD_INT 3
94155: NEG
94156: PUSH
94157: LD_INT 2
94159: NEG
94160: PUSH
94161: EMPTY
94162: LIST
94163: LIST
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94169: LD_ADDR_VAR 0 53
94173: PUSH
94174: LD_INT 1
94176: NEG
94177: PUSH
94178: LD_INT 3
94180: NEG
94181: PUSH
94182: EMPTY
94183: LIST
94184: LIST
94185: PUSH
94186: LD_INT 0
94188: PUSH
94189: LD_INT 3
94191: NEG
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: PUSH
94197: LD_INT 1
94199: PUSH
94200: LD_INT 2
94202: NEG
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: LIST
94212: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94213: LD_ADDR_VAR 0 54
94217: PUSH
94218: LD_INT 2
94220: PUSH
94221: LD_INT 1
94223: NEG
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: PUSH
94229: LD_INT 3
94231: PUSH
94232: LD_INT 0
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PUSH
94239: LD_INT 3
94241: PUSH
94242: LD_INT 1
94244: PUSH
94245: EMPTY
94246: LIST
94247: LIST
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: LIST
94253: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94254: LD_ADDR_VAR 0 55
94258: PUSH
94259: LD_INT 3
94261: PUSH
94262: LD_INT 2
94264: PUSH
94265: EMPTY
94266: LIST
94267: LIST
94268: PUSH
94269: LD_INT 3
94271: PUSH
94272: LD_INT 3
94274: PUSH
94275: EMPTY
94276: LIST
94277: LIST
94278: PUSH
94279: LD_INT 2
94281: PUSH
94282: LD_INT 3
94284: PUSH
94285: EMPTY
94286: LIST
94287: LIST
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: LIST
94293: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94294: LD_ADDR_VAR 0 56
94298: PUSH
94299: LD_INT 1
94301: PUSH
94302: LD_INT 3
94304: PUSH
94305: EMPTY
94306: LIST
94307: LIST
94308: PUSH
94309: LD_INT 0
94311: PUSH
94312: LD_INT 3
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 1
94321: NEG
94322: PUSH
94323: LD_INT 2
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: LIST
94334: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94335: LD_ADDR_VAR 0 57
94339: PUSH
94340: LD_INT 2
94342: NEG
94343: PUSH
94344: LD_INT 1
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PUSH
94351: LD_INT 3
94353: NEG
94354: PUSH
94355: LD_INT 0
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 3
94364: NEG
94365: PUSH
94366: LD_INT 1
94368: NEG
94369: PUSH
94370: EMPTY
94371: LIST
94372: LIST
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: LIST
94378: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94379: LD_ADDR_VAR 0 58
94383: PUSH
94384: LD_INT 2
94386: NEG
94387: PUSH
94388: LD_INT 3
94390: NEG
94391: PUSH
94392: EMPTY
94393: LIST
94394: LIST
94395: PUSH
94396: LD_INT 3
94398: NEG
94399: PUSH
94400: LD_INT 2
94402: NEG
94403: PUSH
94404: EMPTY
94405: LIST
94406: LIST
94407: PUSH
94408: LD_INT 3
94410: NEG
94411: PUSH
94412: LD_INT 3
94414: NEG
94415: PUSH
94416: EMPTY
94417: LIST
94418: LIST
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: LIST
94424: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94425: LD_ADDR_VAR 0 59
94429: PUSH
94430: LD_INT 1
94432: NEG
94433: PUSH
94434: LD_INT 2
94436: NEG
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 0
94444: PUSH
94445: LD_INT 2
94447: NEG
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 1
94455: PUSH
94456: LD_INT 1
94458: NEG
94459: PUSH
94460: EMPTY
94461: LIST
94462: LIST
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: LIST
94468: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94469: LD_ADDR_VAR 0 60
94473: PUSH
94474: LD_INT 1
94476: PUSH
94477: LD_INT 1
94479: NEG
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: LD_INT 2
94487: PUSH
94488: LD_INT 0
94490: PUSH
94491: EMPTY
94492: LIST
94493: LIST
94494: PUSH
94495: LD_INT 2
94497: PUSH
94498: LD_INT 1
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: LIST
94509: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94510: LD_ADDR_VAR 0 61
94514: PUSH
94515: LD_INT 2
94517: PUSH
94518: LD_INT 1
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 2
94527: PUSH
94528: LD_INT 2
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: PUSH
94535: LD_INT 1
94537: PUSH
94538: LD_INT 2
94540: PUSH
94541: EMPTY
94542: LIST
94543: LIST
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: LIST
94549: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94550: LD_ADDR_VAR 0 62
94554: PUSH
94555: LD_INT 1
94557: PUSH
94558: LD_INT 2
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 0
94567: PUSH
94568: LD_INT 2
94570: PUSH
94571: EMPTY
94572: LIST
94573: LIST
94574: PUSH
94575: LD_INT 1
94577: NEG
94578: PUSH
94579: LD_INT 1
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: LIST
94590: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94591: LD_ADDR_VAR 0 63
94595: PUSH
94596: LD_INT 1
94598: NEG
94599: PUSH
94600: LD_INT 1
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: PUSH
94607: LD_INT 2
94609: NEG
94610: PUSH
94611: LD_INT 0
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: PUSH
94618: LD_INT 2
94620: NEG
94621: PUSH
94622: LD_INT 1
94624: NEG
94625: PUSH
94626: EMPTY
94627: LIST
94628: LIST
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: LIST
94634: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94635: LD_ADDR_VAR 0 64
94639: PUSH
94640: LD_INT 1
94642: NEG
94643: PUSH
94644: LD_INT 2
94646: NEG
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: PUSH
94652: LD_INT 2
94654: NEG
94655: PUSH
94656: LD_INT 1
94658: NEG
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PUSH
94664: LD_INT 2
94666: NEG
94667: PUSH
94668: LD_INT 2
94670: NEG
94671: PUSH
94672: EMPTY
94673: LIST
94674: LIST
94675: PUSH
94676: EMPTY
94677: LIST
94678: LIST
94679: LIST
94680: ST_TO_ADDR
// end ; 2 :
94681: GO 97947
94683: LD_INT 2
94685: DOUBLE
94686: EQUAL
94687: IFTRUE 94691
94689: GO 97946
94691: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94692: LD_ADDR_VAR 0 29
94696: PUSH
94697: LD_INT 4
94699: PUSH
94700: LD_INT 0
94702: PUSH
94703: EMPTY
94704: LIST
94705: LIST
94706: PUSH
94707: LD_INT 4
94709: PUSH
94710: LD_INT 1
94712: NEG
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 5
94720: PUSH
94721: LD_INT 0
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 5
94730: PUSH
94731: LD_INT 1
94733: PUSH
94734: EMPTY
94735: LIST
94736: LIST
94737: PUSH
94738: LD_INT 4
94740: PUSH
94741: LD_INT 1
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: PUSH
94748: LD_INT 3
94750: PUSH
94751: LD_INT 0
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: PUSH
94758: LD_INT 3
94760: PUSH
94761: LD_INT 1
94763: NEG
94764: PUSH
94765: EMPTY
94766: LIST
94767: LIST
94768: PUSH
94769: LD_INT 3
94771: PUSH
94772: LD_INT 2
94774: NEG
94775: PUSH
94776: EMPTY
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 5
94782: PUSH
94783: LD_INT 2
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 3
94792: PUSH
94793: LD_INT 3
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 3
94802: PUSH
94803: LD_INT 2
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 4
94812: PUSH
94813: LD_INT 3
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: LD_INT 4
94822: PUSH
94823: LD_INT 4
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 3
94832: PUSH
94833: LD_INT 4
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 2
94842: PUSH
94843: LD_INT 3
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 2
94852: PUSH
94853: LD_INT 2
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 4
94862: PUSH
94863: LD_INT 2
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: LD_INT 2
94872: PUSH
94873: LD_INT 4
94875: PUSH
94876: EMPTY
94877: LIST
94878: LIST
94879: PUSH
94880: LD_INT 0
94882: PUSH
94883: LD_INT 4
94885: PUSH
94886: EMPTY
94887: LIST
94888: LIST
94889: PUSH
94890: LD_INT 0
94892: PUSH
94893: LD_INT 3
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: PUSH
94900: LD_INT 1
94902: PUSH
94903: LD_INT 4
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: LD_INT 1
94912: PUSH
94913: LD_INT 5
94915: PUSH
94916: EMPTY
94917: LIST
94918: LIST
94919: PUSH
94920: LD_INT 0
94922: PUSH
94923: LD_INT 5
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: PUSH
94930: LD_INT 1
94932: NEG
94933: PUSH
94934: LD_INT 4
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: PUSH
94941: LD_INT 1
94943: NEG
94944: PUSH
94945: LD_INT 3
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: PUSH
94952: LD_INT 2
94954: PUSH
94955: LD_INT 5
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: LD_INT 2
94964: NEG
94965: PUSH
94966: LD_INT 3
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: PUSH
94973: LD_INT 3
94975: NEG
94976: PUSH
94977: LD_INT 0
94979: PUSH
94980: EMPTY
94981: LIST
94982: LIST
94983: PUSH
94984: LD_INT 3
94986: NEG
94987: PUSH
94988: LD_INT 1
94990: NEG
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 2
94998: NEG
94999: PUSH
95000: LD_INT 0
95002: PUSH
95003: EMPTY
95004: LIST
95005: LIST
95006: PUSH
95007: LD_INT 2
95009: NEG
95010: PUSH
95011: LD_INT 1
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 3
95020: NEG
95021: PUSH
95022: LD_INT 1
95024: PUSH
95025: EMPTY
95026: LIST
95027: LIST
95028: PUSH
95029: LD_INT 4
95031: NEG
95032: PUSH
95033: LD_INT 0
95035: PUSH
95036: EMPTY
95037: LIST
95038: LIST
95039: PUSH
95040: LD_INT 4
95042: NEG
95043: PUSH
95044: LD_INT 1
95046: NEG
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 4
95054: NEG
95055: PUSH
95056: LD_INT 2
95058: NEG
95059: PUSH
95060: EMPTY
95061: LIST
95062: LIST
95063: PUSH
95064: LD_INT 2
95066: NEG
95067: PUSH
95068: LD_INT 2
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: PUSH
95075: LD_INT 4
95077: NEG
95078: PUSH
95079: LD_INT 4
95081: NEG
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PUSH
95087: LD_INT 4
95089: NEG
95090: PUSH
95091: LD_INT 5
95093: NEG
95094: PUSH
95095: EMPTY
95096: LIST
95097: LIST
95098: PUSH
95099: LD_INT 3
95101: NEG
95102: PUSH
95103: LD_INT 4
95105: NEG
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: PUSH
95111: LD_INT 3
95113: NEG
95114: PUSH
95115: LD_INT 3
95117: NEG
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: PUSH
95123: LD_INT 4
95125: NEG
95126: PUSH
95127: LD_INT 3
95129: NEG
95130: PUSH
95131: EMPTY
95132: LIST
95133: LIST
95134: PUSH
95135: LD_INT 5
95137: NEG
95138: PUSH
95139: LD_INT 4
95141: NEG
95142: PUSH
95143: EMPTY
95144: LIST
95145: LIST
95146: PUSH
95147: LD_INT 5
95149: NEG
95150: PUSH
95151: LD_INT 5
95153: NEG
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PUSH
95159: LD_INT 3
95161: NEG
95162: PUSH
95163: LD_INT 5
95165: NEG
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: PUSH
95171: LD_INT 5
95173: NEG
95174: PUSH
95175: LD_INT 3
95177: NEG
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
95230: LD_ADDR_VAR 0 30
95234: PUSH
95235: LD_INT 4
95237: PUSH
95238: LD_INT 4
95240: PUSH
95241: EMPTY
95242: LIST
95243: LIST
95244: PUSH
95245: LD_INT 4
95247: PUSH
95248: LD_INT 3
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 5
95257: PUSH
95258: LD_INT 4
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: LD_INT 5
95267: PUSH
95268: LD_INT 5
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 4
95277: PUSH
95278: LD_INT 5
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: LD_INT 3
95287: PUSH
95288: LD_INT 4
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: PUSH
95295: LD_INT 3
95297: PUSH
95298: LD_INT 3
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 5
95307: PUSH
95308: LD_INT 3
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 3
95317: PUSH
95318: LD_INT 5
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: LD_INT 0
95327: PUSH
95328: LD_INT 3
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 0
95337: PUSH
95338: LD_INT 2
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 1
95347: PUSH
95348: LD_INT 3
95350: PUSH
95351: EMPTY
95352: LIST
95353: LIST
95354: PUSH
95355: LD_INT 1
95357: PUSH
95358: LD_INT 4
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: PUSH
95365: LD_INT 0
95367: PUSH
95368: LD_INT 4
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: PUSH
95375: LD_INT 1
95377: NEG
95378: PUSH
95379: LD_INT 3
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PUSH
95386: LD_INT 1
95388: NEG
95389: PUSH
95390: LD_INT 2
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 2
95399: PUSH
95400: LD_INT 4
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 2
95409: NEG
95410: PUSH
95411: LD_INT 2
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 4
95420: NEG
95421: PUSH
95422: LD_INT 0
95424: PUSH
95425: EMPTY
95426: LIST
95427: LIST
95428: PUSH
95429: LD_INT 4
95431: NEG
95432: PUSH
95433: LD_INT 1
95435: NEG
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: LD_INT 3
95443: NEG
95444: PUSH
95445: LD_INT 0
95447: PUSH
95448: EMPTY
95449: LIST
95450: LIST
95451: PUSH
95452: LD_INT 3
95454: NEG
95455: PUSH
95456: LD_INT 1
95458: PUSH
95459: EMPTY
95460: LIST
95461: LIST
95462: PUSH
95463: LD_INT 4
95465: NEG
95466: PUSH
95467: LD_INT 1
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: PUSH
95474: LD_INT 5
95476: NEG
95477: PUSH
95478: LD_INT 0
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: PUSH
95485: LD_INT 5
95487: NEG
95488: PUSH
95489: LD_INT 1
95491: NEG
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: PUSH
95497: LD_INT 5
95499: NEG
95500: PUSH
95501: LD_INT 2
95503: NEG
95504: PUSH
95505: EMPTY
95506: LIST
95507: LIST
95508: PUSH
95509: LD_INT 3
95511: NEG
95512: PUSH
95513: LD_INT 2
95515: PUSH
95516: EMPTY
95517: LIST
95518: LIST
95519: PUSH
95520: LD_INT 3
95522: NEG
95523: PUSH
95524: LD_INT 3
95526: NEG
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: PUSH
95532: LD_INT 3
95534: NEG
95535: PUSH
95536: LD_INT 4
95538: NEG
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: LD_INT 2
95546: NEG
95547: PUSH
95548: LD_INT 3
95550: NEG
95551: PUSH
95552: EMPTY
95553: LIST
95554: LIST
95555: PUSH
95556: LD_INT 2
95558: NEG
95559: PUSH
95560: LD_INT 2
95562: NEG
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 3
95570: NEG
95571: PUSH
95572: LD_INT 2
95574: NEG
95575: PUSH
95576: EMPTY
95577: LIST
95578: LIST
95579: PUSH
95580: LD_INT 4
95582: NEG
95583: PUSH
95584: LD_INT 3
95586: NEG
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 4
95594: NEG
95595: PUSH
95596: LD_INT 4
95598: NEG
95599: PUSH
95600: EMPTY
95601: LIST
95602: LIST
95603: PUSH
95604: LD_INT 2
95606: NEG
95607: PUSH
95608: LD_INT 4
95610: NEG
95611: PUSH
95612: EMPTY
95613: LIST
95614: LIST
95615: PUSH
95616: LD_INT 4
95618: NEG
95619: PUSH
95620: LD_INT 2
95622: NEG
95623: PUSH
95624: EMPTY
95625: LIST
95626: LIST
95627: PUSH
95628: LD_INT 0
95630: PUSH
95631: LD_INT 4
95633: NEG
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 0
95641: PUSH
95642: LD_INT 5
95644: NEG
95645: PUSH
95646: EMPTY
95647: LIST
95648: LIST
95649: PUSH
95650: LD_INT 1
95652: PUSH
95653: LD_INT 4
95655: NEG
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: PUSH
95661: LD_INT 1
95663: PUSH
95664: LD_INT 3
95666: NEG
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: PUSH
95672: LD_INT 0
95674: PUSH
95675: LD_INT 3
95677: NEG
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 1
95685: NEG
95686: PUSH
95687: LD_INT 4
95689: NEG
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 1
95697: NEG
95698: PUSH
95699: LD_INT 5
95701: NEG
95702: PUSH
95703: EMPTY
95704: LIST
95705: LIST
95706: PUSH
95707: LD_INT 2
95709: PUSH
95710: LD_INT 3
95712: NEG
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: PUSH
95718: LD_INT 2
95720: NEG
95721: PUSH
95722: LD_INT 5
95724: NEG
95725: PUSH
95726: EMPTY
95727: LIST
95728: LIST
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95777: LD_ADDR_VAR 0 31
95781: PUSH
95782: LD_INT 0
95784: PUSH
95785: LD_INT 4
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 0
95794: PUSH
95795: LD_INT 3
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 1
95804: PUSH
95805: LD_INT 4
95807: PUSH
95808: EMPTY
95809: LIST
95810: LIST
95811: PUSH
95812: LD_INT 1
95814: PUSH
95815: LD_INT 5
95817: PUSH
95818: EMPTY
95819: LIST
95820: LIST
95821: PUSH
95822: LD_INT 0
95824: PUSH
95825: LD_INT 5
95827: PUSH
95828: EMPTY
95829: LIST
95830: LIST
95831: PUSH
95832: LD_INT 1
95834: NEG
95835: PUSH
95836: LD_INT 4
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: PUSH
95843: LD_INT 1
95845: NEG
95846: PUSH
95847: LD_INT 3
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 2
95856: PUSH
95857: LD_INT 5
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: LD_INT 2
95866: NEG
95867: PUSH
95868: LD_INT 3
95870: PUSH
95871: EMPTY
95872: LIST
95873: LIST
95874: PUSH
95875: LD_INT 3
95877: NEG
95878: PUSH
95879: LD_INT 0
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 3
95888: NEG
95889: PUSH
95890: LD_INT 1
95892: NEG
95893: PUSH
95894: EMPTY
95895: LIST
95896: LIST
95897: PUSH
95898: LD_INT 2
95900: NEG
95901: PUSH
95902: LD_INT 0
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 2
95911: NEG
95912: PUSH
95913: LD_INT 1
95915: PUSH
95916: EMPTY
95917: LIST
95918: LIST
95919: PUSH
95920: LD_INT 3
95922: NEG
95923: PUSH
95924: LD_INT 1
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: LD_INT 4
95933: NEG
95934: PUSH
95935: LD_INT 0
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PUSH
95942: LD_INT 4
95944: NEG
95945: PUSH
95946: LD_INT 1
95948: NEG
95949: PUSH
95950: EMPTY
95951: LIST
95952: LIST
95953: PUSH
95954: LD_INT 4
95956: NEG
95957: PUSH
95958: LD_INT 2
95960: NEG
95961: PUSH
95962: EMPTY
95963: LIST
95964: LIST
95965: PUSH
95966: LD_INT 2
95968: NEG
95969: PUSH
95970: LD_INT 2
95972: PUSH
95973: EMPTY
95974: LIST
95975: LIST
95976: PUSH
95977: LD_INT 4
95979: NEG
95980: PUSH
95981: LD_INT 4
95983: NEG
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: PUSH
95989: LD_INT 4
95991: NEG
95992: PUSH
95993: LD_INT 5
95995: NEG
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: PUSH
96001: LD_INT 3
96003: NEG
96004: PUSH
96005: LD_INT 4
96007: NEG
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PUSH
96013: LD_INT 3
96015: NEG
96016: PUSH
96017: LD_INT 3
96019: NEG
96020: PUSH
96021: EMPTY
96022: LIST
96023: LIST
96024: PUSH
96025: LD_INT 4
96027: NEG
96028: PUSH
96029: LD_INT 3
96031: NEG
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: PUSH
96037: LD_INT 5
96039: NEG
96040: PUSH
96041: LD_INT 4
96043: NEG
96044: PUSH
96045: EMPTY
96046: LIST
96047: LIST
96048: PUSH
96049: LD_INT 5
96051: NEG
96052: PUSH
96053: LD_INT 5
96055: NEG
96056: PUSH
96057: EMPTY
96058: LIST
96059: LIST
96060: PUSH
96061: LD_INT 3
96063: NEG
96064: PUSH
96065: LD_INT 5
96067: NEG
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: PUSH
96073: LD_INT 5
96075: NEG
96076: PUSH
96077: LD_INT 3
96079: NEG
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PUSH
96085: LD_INT 0
96087: PUSH
96088: LD_INT 3
96090: NEG
96091: PUSH
96092: EMPTY
96093: LIST
96094: LIST
96095: PUSH
96096: LD_INT 0
96098: PUSH
96099: LD_INT 4
96101: NEG
96102: PUSH
96103: EMPTY
96104: LIST
96105: LIST
96106: PUSH
96107: LD_INT 1
96109: PUSH
96110: LD_INT 3
96112: NEG
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 1
96120: PUSH
96121: LD_INT 2
96123: NEG
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 0
96131: PUSH
96132: LD_INT 2
96134: NEG
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 1
96142: NEG
96143: PUSH
96144: LD_INT 3
96146: NEG
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 1
96154: NEG
96155: PUSH
96156: LD_INT 4
96158: NEG
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PUSH
96164: LD_INT 2
96166: PUSH
96167: LD_INT 2
96169: NEG
96170: PUSH
96171: EMPTY
96172: LIST
96173: LIST
96174: PUSH
96175: LD_INT 2
96177: NEG
96178: PUSH
96179: LD_INT 4
96181: NEG
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: PUSH
96187: LD_INT 4
96189: PUSH
96190: LD_INT 0
96192: PUSH
96193: EMPTY
96194: LIST
96195: LIST
96196: PUSH
96197: LD_INT 4
96199: PUSH
96200: LD_INT 1
96202: NEG
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 5
96210: PUSH
96211: LD_INT 0
96213: PUSH
96214: EMPTY
96215: LIST
96216: LIST
96217: PUSH
96218: LD_INT 5
96220: PUSH
96221: LD_INT 1
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 4
96230: PUSH
96231: LD_INT 1
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 3
96240: PUSH
96241: LD_INT 0
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 3
96250: PUSH
96251: LD_INT 1
96253: NEG
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 3
96261: PUSH
96262: LD_INT 2
96264: NEG
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 5
96272: PUSH
96273: LD_INT 2
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: EMPTY
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: LIST
96314: LIST
96315: LIST
96316: LIST
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96327: LD_ADDR_VAR 0 32
96331: PUSH
96332: LD_INT 4
96334: NEG
96335: PUSH
96336: LD_INT 0
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: LD_INT 4
96345: NEG
96346: PUSH
96347: LD_INT 1
96349: NEG
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: PUSH
96355: LD_INT 3
96357: NEG
96358: PUSH
96359: LD_INT 0
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: PUSH
96366: LD_INT 3
96368: NEG
96369: PUSH
96370: LD_INT 1
96372: PUSH
96373: EMPTY
96374: LIST
96375: LIST
96376: PUSH
96377: LD_INT 4
96379: NEG
96380: PUSH
96381: LD_INT 1
96383: PUSH
96384: EMPTY
96385: LIST
96386: LIST
96387: PUSH
96388: LD_INT 5
96390: NEG
96391: PUSH
96392: LD_INT 0
96394: PUSH
96395: EMPTY
96396: LIST
96397: LIST
96398: PUSH
96399: LD_INT 5
96401: NEG
96402: PUSH
96403: LD_INT 1
96405: NEG
96406: PUSH
96407: EMPTY
96408: LIST
96409: LIST
96410: PUSH
96411: LD_INT 5
96413: NEG
96414: PUSH
96415: LD_INT 2
96417: NEG
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: PUSH
96423: LD_INT 3
96425: NEG
96426: PUSH
96427: LD_INT 2
96429: PUSH
96430: EMPTY
96431: LIST
96432: LIST
96433: PUSH
96434: LD_INT 3
96436: NEG
96437: PUSH
96438: LD_INT 3
96440: NEG
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: PUSH
96446: LD_INT 3
96448: NEG
96449: PUSH
96450: LD_INT 4
96452: NEG
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: LD_INT 2
96460: NEG
96461: PUSH
96462: LD_INT 3
96464: NEG
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PUSH
96470: LD_INT 2
96472: NEG
96473: PUSH
96474: LD_INT 2
96476: NEG
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: LD_INT 3
96484: NEG
96485: PUSH
96486: LD_INT 2
96488: NEG
96489: PUSH
96490: EMPTY
96491: LIST
96492: LIST
96493: PUSH
96494: LD_INT 4
96496: NEG
96497: PUSH
96498: LD_INT 3
96500: NEG
96501: PUSH
96502: EMPTY
96503: LIST
96504: LIST
96505: PUSH
96506: LD_INT 4
96508: NEG
96509: PUSH
96510: LD_INT 4
96512: NEG
96513: PUSH
96514: EMPTY
96515: LIST
96516: LIST
96517: PUSH
96518: LD_INT 2
96520: NEG
96521: PUSH
96522: LD_INT 4
96524: NEG
96525: PUSH
96526: EMPTY
96527: LIST
96528: LIST
96529: PUSH
96530: LD_INT 4
96532: NEG
96533: PUSH
96534: LD_INT 2
96536: NEG
96537: PUSH
96538: EMPTY
96539: LIST
96540: LIST
96541: PUSH
96542: LD_INT 0
96544: PUSH
96545: LD_INT 4
96547: NEG
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: PUSH
96553: LD_INT 0
96555: PUSH
96556: LD_INT 5
96558: NEG
96559: PUSH
96560: EMPTY
96561: LIST
96562: LIST
96563: PUSH
96564: LD_INT 1
96566: PUSH
96567: LD_INT 4
96569: NEG
96570: PUSH
96571: EMPTY
96572: LIST
96573: LIST
96574: PUSH
96575: LD_INT 1
96577: PUSH
96578: LD_INT 3
96580: NEG
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: PUSH
96586: LD_INT 0
96588: PUSH
96589: LD_INT 3
96591: NEG
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: PUSH
96597: LD_INT 1
96599: NEG
96600: PUSH
96601: LD_INT 4
96603: NEG
96604: PUSH
96605: EMPTY
96606: LIST
96607: LIST
96608: PUSH
96609: LD_INT 1
96611: NEG
96612: PUSH
96613: LD_INT 5
96615: NEG
96616: PUSH
96617: EMPTY
96618: LIST
96619: LIST
96620: PUSH
96621: LD_INT 2
96623: PUSH
96624: LD_INT 3
96626: NEG
96627: PUSH
96628: EMPTY
96629: LIST
96630: LIST
96631: PUSH
96632: LD_INT 2
96634: NEG
96635: PUSH
96636: LD_INT 5
96638: NEG
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PUSH
96644: LD_INT 3
96646: PUSH
96647: LD_INT 0
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: PUSH
96654: LD_INT 3
96656: PUSH
96657: LD_INT 1
96659: NEG
96660: PUSH
96661: EMPTY
96662: LIST
96663: LIST
96664: PUSH
96665: LD_INT 4
96667: PUSH
96668: LD_INT 0
96670: PUSH
96671: EMPTY
96672: LIST
96673: LIST
96674: PUSH
96675: LD_INT 4
96677: PUSH
96678: LD_INT 1
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: PUSH
96685: LD_INT 3
96687: PUSH
96688: LD_INT 1
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: LD_INT 2
96697: PUSH
96698: LD_INT 0
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 2
96707: PUSH
96708: LD_INT 1
96710: NEG
96711: PUSH
96712: EMPTY
96713: LIST
96714: LIST
96715: PUSH
96716: LD_INT 2
96718: PUSH
96719: LD_INT 2
96721: NEG
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: PUSH
96727: LD_INT 4
96729: PUSH
96730: LD_INT 2
96732: PUSH
96733: EMPTY
96734: LIST
96735: LIST
96736: PUSH
96737: LD_INT 4
96739: PUSH
96740: LD_INT 4
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: PUSH
96747: LD_INT 4
96749: PUSH
96750: LD_INT 3
96752: PUSH
96753: EMPTY
96754: LIST
96755: LIST
96756: PUSH
96757: LD_INT 5
96759: PUSH
96760: LD_INT 4
96762: PUSH
96763: EMPTY
96764: LIST
96765: LIST
96766: PUSH
96767: LD_INT 5
96769: PUSH
96770: LD_INT 5
96772: PUSH
96773: EMPTY
96774: LIST
96775: LIST
96776: PUSH
96777: LD_INT 4
96779: PUSH
96780: LD_INT 5
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PUSH
96787: LD_INT 3
96789: PUSH
96790: LD_INT 4
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 3
96799: PUSH
96800: LD_INT 3
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: PUSH
96807: LD_INT 5
96809: PUSH
96810: LD_INT 3
96812: PUSH
96813: EMPTY
96814: LIST
96815: LIST
96816: PUSH
96817: LD_INT 3
96819: PUSH
96820: LD_INT 5
96822: PUSH
96823: EMPTY
96824: LIST
96825: LIST
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96874: LD_ADDR_VAR 0 33
96878: PUSH
96879: LD_INT 4
96881: NEG
96882: PUSH
96883: LD_INT 4
96885: NEG
96886: PUSH
96887: EMPTY
96888: LIST
96889: LIST
96890: PUSH
96891: LD_INT 4
96893: NEG
96894: PUSH
96895: LD_INT 5
96897: NEG
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: PUSH
96903: LD_INT 3
96905: NEG
96906: PUSH
96907: LD_INT 4
96909: NEG
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: PUSH
96915: LD_INT 3
96917: NEG
96918: PUSH
96919: LD_INT 3
96921: NEG
96922: PUSH
96923: EMPTY
96924: LIST
96925: LIST
96926: PUSH
96927: LD_INT 4
96929: NEG
96930: PUSH
96931: LD_INT 3
96933: NEG
96934: PUSH
96935: EMPTY
96936: LIST
96937: LIST
96938: PUSH
96939: LD_INT 5
96941: NEG
96942: PUSH
96943: LD_INT 4
96945: NEG
96946: PUSH
96947: EMPTY
96948: LIST
96949: LIST
96950: PUSH
96951: LD_INT 5
96953: NEG
96954: PUSH
96955: LD_INT 5
96957: NEG
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: LD_INT 3
96965: NEG
96966: PUSH
96967: LD_INT 5
96969: NEG
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: LD_INT 5
96977: NEG
96978: PUSH
96979: LD_INT 3
96981: NEG
96982: PUSH
96983: EMPTY
96984: LIST
96985: LIST
96986: PUSH
96987: LD_INT 0
96989: PUSH
96990: LD_INT 3
96992: NEG
96993: PUSH
96994: EMPTY
96995: LIST
96996: LIST
96997: PUSH
96998: LD_INT 0
97000: PUSH
97001: LD_INT 4
97003: NEG
97004: PUSH
97005: EMPTY
97006: LIST
97007: LIST
97008: PUSH
97009: LD_INT 1
97011: PUSH
97012: LD_INT 3
97014: NEG
97015: PUSH
97016: EMPTY
97017: LIST
97018: LIST
97019: PUSH
97020: LD_INT 1
97022: PUSH
97023: LD_INT 2
97025: NEG
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: PUSH
97031: LD_INT 0
97033: PUSH
97034: LD_INT 2
97036: NEG
97037: PUSH
97038: EMPTY
97039: LIST
97040: LIST
97041: PUSH
97042: LD_INT 1
97044: NEG
97045: PUSH
97046: LD_INT 3
97048: NEG
97049: PUSH
97050: EMPTY
97051: LIST
97052: LIST
97053: PUSH
97054: LD_INT 1
97056: NEG
97057: PUSH
97058: LD_INT 4
97060: NEG
97061: PUSH
97062: EMPTY
97063: LIST
97064: LIST
97065: PUSH
97066: LD_INT 2
97068: PUSH
97069: LD_INT 2
97071: NEG
97072: PUSH
97073: EMPTY
97074: LIST
97075: LIST
97076: PUSH
97077: LD_INT 2
97079: NEG
97080: PUSH
97081: LD_INT 4
97083: NEG
97084: PUSH
97085: EMPTY
97086: LIST
97087: LIST
97088: PUSH
97089: LD_INT 4
97091: PUSH
97092: LD_INT 0
97094: PUSH
97095: EMPTY
97096: LIST
97097: LIST
97098: PUSH
97099: LD_INT 4
97101: PUSH
97102: LD_INT 1
97104: NEG
97105: PUSH
97106: EMPTY
97107: LIST
97108: LIST
97109: PUSH
97110: LD_INT 5
97112: PUSH
97113: LD_INT 0
97115: PUSH
97116: EMPTY
97117: LIST
97118: LIST
97119: PUSH
97120: LD_INT 5
97122: PUSH
97123: LD_INT 1
97125: PUSH
97126: EMPTY
97127: LIST
97128: LIST
97129: PUSH
97130: LD_INT 4
97132: PUSH
97133: LD_INT 1
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: PUSH
97140: LD_INT 3
97142: PUSH
97143: LD_INT 0
97145: PUSH
97146: EMPTY
97147: LIST
97148: LIST
97149: PUSH
97150: LD_INT 3
97152: PUSH
97153: LD_INT 1
97155: NEG
97156: PUSH
97157: EMPTY
97158: LIST
97159: LIST
97160: PUSH
97161: LD_INT 3
97163: PUSH
97164: LD_INT 2
97166: NEG
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: PUSH
97172: LD_INT 5
97174: PUSH
97175: LD_INT 2
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: PUSH
97182: LD_INT 3
97184: PUSH
97185: LD_INT 3
97187: PUSH
97188: EMPTY
97189: LIST
97190: LIST
97191: PUSH
97192: LD_INT 3
97194: PUSH
97195: LD_INT 2
97197: PUSH
97198: EMPTY
97199: LIST
97200: LIST
97201: PUSH
97202: LD_INT 4
97204: PUSH
97205: LD_INT 3
97207: PUSH
97208: EMPTY
97209: LIST
97210: LIST
97211: PUSH
97212: LD_INT 4
97214: PUSH
97215: LD_INT 4
97217: PUSH
97218: EMPTY
97219: LIST
97220: LIST
97221: PUSH
97222: LD_INT 3
97224: PUSH
97225: LD_INT 4
97227: PUSH
97228: EMPTY
97229: LIST
97230: LIST
97231: PUSH
97232: LD_INT 2
97234: PUSH
97235: LD_INT 3
97237: PUSH
97238: EMPTY
97239: LIST
97240: LIST
97241: PUSH
97242: LD_INT 2
97244: PUSH
97245: LD_INT 2
97247: PUSH
97248: EMPTY
97249: LIST
97250: LIST
97251: PUSH
97252: LD_INT 4
97254: PUSH
97255: LD_INT 2
97257: PUSH
97258: EMPTY
97259: LIST
97260: LIST
97261: PUSH
97262: LD_INT 2
97264: PUSH
97265: LD_INT 4
97267: PUSH
97268: EMPTY
97269: LIST
97270: LIST
97271: PUSH
97272: LD_INT 0
97274: PUSH
97275: LD_INT 4
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: PUSH
97282: LD_INT 0
97284: PUSH
97285: LD_INT 3
97287: PUSH
97288: EMPTY
97289: LIST
97290: LIST
97291: PUSH
97292: LD_INT 1
97294: PUSH
97295: LD_INT 4
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: PUSH
97302: LD_INT 1
97304: PUSH
97305: LD_INT 5
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: PUSH
97312: LD_INT 0
97314: PUSH
97315: LD_INT 5
97317: PUSH
97318: EMPTY
97319: LIST
97320: LIST
97321: PUSH
97322: LD_INT 1
97324: NEG
97325: PUSH
97326: LD_INT 4
97328: PUSH
97329: EMPTY
97330: LIST
97331: LIST
97332: PUSH
97333: LD_INT 1
97335: NEG
97336: PUSH
97337: LD_INT 3
97339: PUSH
97340: EMPTY
97341: LIST
97342: LIST
97343: PUSH
97344: LD_INT 2
97346: PUSH
97347: LD_INT 5
97349: PUSH
97350: EMPTY
97351: LIST
97352: LIST
97353: PUSH
97354: LD_INT 2
97356: NEG
97357: PUSH
97358: LD_INT 3
97360: PUSH
97361: EMPTY
97362: LIST
97363: LIST
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: LIST
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97412: LD_ADDR_VAR 0 34
97416: PUSH
97417: LD_INT 0
97419: PUSH
97420: LD_INT 4
97422: NEG
97423: PUSH
97424: EMPTY
97425: LIST
97426: LIST
97427: PUSH
97428: LD_INT 0
97430: PUSH
97431: LD_INT 5
97433: NEG
97434: PUSH
97435: EMPTY
97436: LIST
97437: LIST
97438: PUSH
97439: LD_INT 1
97441: PUSH
97442: LD_INT 4
97444: NEG
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: PUSH
97450: LD_INT 1
97452: PUSH
97453: LD_INT 3
97455: NEG
97456: PUSH
97457: EMPTY
97458: LIST
97459: LIST
97460: PUSH
97461: LD_INT 0
97463: PUSH
97464: LD_INT 3
97466: NEG
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: PUSH
97472: LD_INT 1
97474: NEG
97475: PUSH
97476: LD_INT 4
97478: NEG
97479: PUSH
97480: EMPTY
97481: LIST
97482: LIST
97483: PUSH
97484: LD_INT 1
97486: NEG
97487: PUSH
97488: LD_INT 5
97490: NEG
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: PUSH
97496: LD_INT 2
97498: PUSH
97499: LD_INT 3
97501: NEG
97502: PUSH
97503: EMPTY
97504: LIST
97505: LIST
97506: PUSH
97507: LD_INT 2
97509: NEG
97510: PUSH
97511: LD_INT 5
97513: NEG
97514: PUSH
97515: EMPTY
97516: LIST
97517: LIST
97518: PUSH
97519: LD_INT 3
97521: PUSH
97522: LD_INT 0
97524: PUSH
97525: EMPTY
97526: LIST
97527: LIST
97528: PUSH
97529: LD_INT 3
97531: PUSH
97532: LD_INT 1
97534: NEG
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: PUSH
97540: LD_INT 4
97542: PUSH
97543: LD_INT 0
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PUSH
97550: LD_INT 4
97552: PUSH
97553: LD_INT 1
97555: PUSH
97556: EMPTY
97557: LIST
97558: LIST
97559: PUSH
97560: LD_INT 3
97562: PUSH
97563: LD_INT 1
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: PUSH
97570: LD_INT 2
97572: PUSH
97573: LD_INT 0
97575: PUSH
97576: EMPTY
97577: LIST
97578: LIST
97579: PUSH
97580: LD_INT 2
97582: PUSH
97583: LD_INT 1
97585: NEG
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: PUSH
97591: LD_INT 2
97593: PUSH
97594: LD_INT 2
97596: NEG
97597: PUSH
97598: EMPTY
97599: LIST
97600: LIST
97601: PUSH
97602: LD_INT 4
97604: PUSH
97605: LD_INT 2
97607: PUSH
97608: EMPTY
97609: LIST
97610: LIST
97611: PUSH
97612: LD_INT 4
97614: PUSH
97615: LD_INT 4
97617: PUSH
97618: EMPTY
97619: LIST
97620: LIST
97621: PUSH
97622: LD_INT 4
97624: PUSH
97625: LD_INT 3
97627: PUSH
97628: EMPTY
97629: LIST
97630: LIST
97631: PUSH
97632: LD_INT 5
97634: PUSH
97635: LD_INT 4
97637: PUSH
97638: EMPTY
97639: LIST
97640: LIST
97641: PUSH
97642: LD_INT 5
97644: PUSH
97645: LD_INT 5
97647: PUSH
97648: EMPTY
97649: LIST
97650: LIST
97651: PUSH
97652: LD_INT 4
97654: PUSH
97655: LD_INT 5
97657: PUSH
97658: EMPTY
97659: LIST
97660: LIST
97661: PUSH
97662: LD_INT 3
97664: PUSH
97665: LD_INT 4
97667: PUSH
97668: EMPTY
97669: LIST
97670: LIST
97671: PUSH
97672: LD_INT 3
97674: PUSH
97675: LD_INT 3
97677: PUSH
97678: EMPTY
97679: LIST
97680: LIST
97681: PUSH
97682: LD_INT 5
97684: PUSH
97685: LD_INT 3
97687: PUSH
97688: EMPTY
97689: LIST
97690: LIST
97691: PUSH
97692: LD_INT 3
97694: PUSH
97695: LD_INT 5
97697: PUSH
97698: EMPTY
97699: LIST
97700: LIST
97701: PUSH
97702: LD_INT 0
97704: PUSH
97705: LD_INT 3
97707: PUSH
97708: EMPTY
97709: LIST
97710: LIST
97711: PUSH
97712: LD_INT 0
97714: PUSH
97715: LD_INT 2
97717: PUSH
97718: EMPTY
97719: LIST
97720: LIST
97721: PUSH
97722: LD_INT 1
97724: PUSH
97725: LD_INT 3
97727: PUSH
97728: EMPTY
97729: LIST
97730: LIST
97731: PUSH
97732: LD_INT 1
97734: PUSH
97735: LD_INT 4
97737: PUSH
97738: EMPTY
97739: LIST
97740: LIST
97741: PUSH
97742: LD_INT 0
97744: PUSH
97745: LD_INT 4
97747: PUSH
97748: EMPTY
97749: LIST
97750: LIST
97751: PUSH
97752: LD_INT 1
97754: NEG
97755: PUSH
97756: LD_INT 3
97758: PUSH
97759: EMPTY
97760: LIST
97761: LIST
97762: PUSH
97763: LD_INT 1
97765: NEG
97766: PUSH
97767: LD_INT 2
97769: PUSH
97770: EMPTY
97771: LIST
97772: LIST
97773: PUSH
97774: LD_INT 2
97776: PUSH
97777: LD_INT 4
97779: PUSH
97780: EMPTY
97781: LIST
97782: LIST
97783: PUSH
97784: LD_INT 2
97786: NEG
97787: PUSH
97788: LD_INT 2
97790: PUSH
97791: EMPTY
97792: LIST
97793: LIST
97794: PUSH
97795: LD_INT 4
97797: NEG
97798: PUSH
97799: LD_INT 0
97801: PUSH
97802: EMPTY
97803: LIST
97804: LIST
97805: PUSH
97806: LD_INT 4
97808: NEG
97809: PUSH
97810: LD_INT 1
97812: NEG
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 3
97820: NEG
97821: PUSH
97822: LD_INT 0
97824: PUSH
97825: EMPTY
97826: LIST
97827: LIST
97828: PUSH
97829: LD_INT 3
97831: NEG
97832: PUSH
97833: LD_INT 1
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: PUSH
97840: LD_INT 4
97842: NEG
97843: PUSH
97844: LD_INT 1
97846: PUSH
97847: EMPTY
97848: LIST
97849: LIST
97850: PUSH
97851: LD_INT 5
97853: NEG
97854: PUSH
97855: LD_INT 0
97857: PUSH
97858: EMPTY
97859: LIST
97860: LIST
97861: PUSH
97862: LD_INT 5
97864: NEG
97865: PUSH
97866: LD_INT 1
97868: NEG
97869: PUSH
97870: EMPTY
97871: LIST
97872: LIST
97873: PUSH
97874: LD_INT 5
97876: NEG
97877: PUSH
97878: LD_INT 2
97880: NEG
97881: PUSH
97882: EMPTY
97883: LIST
97884: LIST
97885: PUSH
97886: LD_INT 3
97888: NEG
97889: PUSH
97890: LD_INT 2
97892: PUSH
97893: EMPTY
97894: LIST
97895: LIST
97896: PUSH
97897: EMPTY
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: ST_TO_ADDR
// end ; end ;
97944: GO 97947
97946: POP
// case btype of b_depot , b_warehouse :
97947: LD_VAR 0 1
97951: PUSH
97952: LD_INT 0
97954: DOUBLE
97955: EQUAL
97956: IFTRUE 97966
97958: LD_INT 1
97960: DOUBLE
97961: EQUAL
97962: IFTRUE 97966
97964: GO 98167
97966: POP
// case nation of nation_american :
97967: LD_VAR 0 5
97971: PUSH
97972: LD_INT 1
97974: DOUBLE
97975: EQUAL
97976: IFTRUE 97980
97978: GO 98036
97980: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97981: LD_ADDR_VAR 0 9
97985: PUSH
97986: LD_VAR 0 11
97990: PUSH
97991: LD_VAR 0 12
97995: PUSH
97996: LD_VAR 0 13
98000: PUSH
98001: LD_VAR 0 14
98005: PUSH
98006: LD_VAR 0 15
98010: PUSH
98011: LD_VAR 0 16
98015: PUSH
98016: EMPTY
98017: LIST
98018: LIST
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: PUSH
98024: LD_VAR 0 4
98028: PUSH
98029: LD_INT 1
98031: PLUS
98032: ARRAY
98033: ST_TO_ADDR
98034: GO 98165
98036: LD_INT 2
98038: DOUBLE
98039: EQUAL
98040: IFTRUE 98044
98042: GO 98100
98044: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
98045: LD_ADDR_VAR 0 9
98049: PUSH
98050: LD_VAR 0 17
98054: PUSH
98055: LD_VAR 0 18
98059: PUSH
98060: LD_VAR 0 19
98064: PUSH
98065: LD_VAR 0 20
98069: PUSH
98070: LD_VAR 0 21
98074: PUSH
98075: LD_VAR 0 22
98079: PUSH
98080: EMPTY
98081: LIST
98082: LIST
98083: LIST
98084: LIST
98085: LIST
98086: LIST
98087: PUSH
98088: LD_VAR 0 4
98092: PUSH
98093: LD_INT 1
98095: PLUS
98096: ARRAY
98097: ST_TO_ADDR
98098: GO 98165
98100: LD_INT 3
98102: DOUBLE
98103: EQUAL
98104: IFTRUE 98108
98106: GO 98164
98108: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
98109: LD_ADDR_VAR 0 9
98113: PUSH
98114: LD_VAR 0 23
98118: PUSH
98119: LD_VAR 0 24
98123: PUSH
98124: LD_VAR 0 25
98128: PUSH
98129: LD_VAR 0 26
98133: PUSH
98134: LD_VAR 0 27
98138: PUSH
98139: LD_VAR 0 28
98143: PUSH
98144: EMPTY
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: LIST
98151: PUSH
98152: LD_VAR 0 4
98156: PUSH
98157: LD_INT 1
98159: PLUS
98160: ARRAY
98161: ST_TO_ADDR
98162: GO 98165
98164: POP
98165: GO 98720
98167: LD_INT 2
98169: DOUBLE
98170: EQUAL
98171: IFTRUE 98181
98173: LD_INT 3
98175: DOUBLE
98176: EQUAL
98177: IFTRUE 98181
98179: GO 98237
98181: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
98182: LD_ADDR_VAR 0 9
98186: PUSH
98187: LD_VAR 0 29
98191: PUSH
98192: LD_VAR 0 30
98196: PUSH
98197: LD_VAR 0 31
98201: PUSH
98202: LD_VAR 0 32
98206: PUSH
98207: LD_VAR 0 33
98211: PUSH
98212: LD_VAR 0 34
98216: PUSH
98217: EMPTY
98218: LIST
98219: LIST
98220: LIST
98221: LIST
98222: LIST
98223: LIST
98224: PUSH
98225: LD_VAR 0 4
98229: PUSH
98230: LD_INT 1
98232: PLUS
98233: ARRAY
98234: ST_TO_ADDR
98235: GO 98720
98237: LD_INT 16
98239: DOUBLE
98240: EQUAL
98241: IFTRUE 98299
98243: LD_INT 17
98245: DOUBLE
98246: EQUAL
98247: IFTRUE 98299
98249: LD_INT 18
98251: DOUBLE
98252: EQUAL
98253: IFTRUE 98299
98255: LD_INT 19
98257: DOUBLE
98258: EQUAL
98259: IFTRUE 98299
98261: LD_INT 22
98263: DOUBLE
98264: EQUAL
98265: IFTRUE 98299
98267: LD_INT 20
98269: DOUBLE
98270: EQUAL
98271: IFTRUE 98299
98273: LD_INT 21
98275: DOUBLE
98276: EQUAL
98277: IFTRUE 98299
98279: LD_INT 23
98281: DOUBLE
98282: EQUAL
98283: IFTRUE 98299
98285: LD_INT 24
98287: DOUBLE
98288: EQUAL
98289: IFTRUE 98299
98291: LD_INT 25
98293: DOUBLE
98294: EQUAL
98295: IFTRUE 98299
98297: GO 98355
98299: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98300: LD_ADDR_VAR 0 9
98304: PUSH
98305: LD_VAR 0 35
98309: PUSH
98310: LD_VAR 0 36
98314: PUSH
98315: LD_VAR 0 37
98319: PUSH
98320: LD_VAR 0 38
98324: PUSH
98325: LD_VAR 0 39
98329: PUSH
98330: LD_VAR 0 40
98334: PUSH
98335: EMPTY
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: PUSH
98343: LD_VAR 0 4
98347: PUSH
98348: LD_INT 1
98350: PLUS
98351: ARRAY
98352: ST_TO_ADDR
98353: GO 98720
98355: LD_INT 6
98357: DOUBLE
98358: EQUAL
98359: IFTRUE 98411
98361: LD_INT 7
98363: DOUBLE
98364: EQUAL
98365: IFTRUE 98411
98367: LD_INT 8
98369: DOUBLE
98370: EQUAL
98371: IFTRUE 98411
98373: LD_INT 13
98375: DOUBLE
98376: EQUAL
98377: IFTRUE 98411
98379: LD_INT 12
98381: DOUBLE
98382: EQUAL
98383: IFTRUE 98411
98385: LD_INT 15
98387: DOUBLE
98388: EQUAL
98389: IFTRUE 98411
98391: LD_INT 11
98393: DOUBLE
98394: EQUAL
98395: IFTRUE 98411
98397: LD_INT 14
98399: DOUBLE
98400: EQUAL
98401: IFTRUE 98411
98403: LD_INT 10
98405: DOUBLE
98406: EQUAL
98407: IFTRUE 98411
98409: GO 98467
98411: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
98412: LD_ADDR_VAR 0 9
98416: PUSH
98417: LD_VAR 0 41
98421: PUSH
98422: LD_VAR 0 42
98426: PUSH
98427: LD_VAR 0 43
98431: PUSH
98432: LD_VAR 0 44
98436: PUSH
98437: LD_VAR 0 45
98441: PUSH
98442: LD_VAR 0 46
98446: PUSH
98447: EMPTY
98448: LIST
98449: LIST
98450: LIST
98451: LIST
98452: LIST
98453: LIST
98454: PUSH
98455: LD_VAR 0 4
98459: PUSH
98460: LD_INT 1
98462: PLUS
98463: ARRAY
98464: ST_TO_ADDR
98465: GO 98720
98467: LD_INT 36
98469: DOUBLE
98470: EQUAL
98471: IFTRUE 98475
98473: GO 98531
98475: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98476: LD_ADDR_VAR 0 9
98480: PUSH
98481: LD_VAR 0 47
98485: PUSH
98486: LD_VAR 0 48
98490: PUSH
98491: LD_VAR 0 49
98495: PUSH
98496: LD_VAR 0 50
98500: PUSH
98501: LD_VAR 0 51
98505: PUSH
98506: LD_VAR 0 52
98510: PUSH
98511: EMPTY
98512: LIST
98513: LIST
98514: LIST
98515: LIST
98516: LIST
98517: LIST
98518: PUSH
98519: LD_VAR 0 4
98523: PUSH
98524: LD_INT 1
98526: PLUS
98527: ARRAY
98528: ST_TO_ADDR
98529: GO 98720
98531: LD_INT 4
98533: DOUBLE
98534: EQUAL
98535: IFTRUE 98557
98537: LD_INT 5
98539: DOUBLE
98540: EQUAL
98541: IFTRUE 98557
98543: LD_INT 34
98545: DOUBLE
98546: EQUAL
98547: IFTRUE 98557
98549: LD_INT 37
98551: DOUBLE
98552: EQUAL
98553: IFTRUE 98557
98555: GO 98613
98557: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98558: LD_ADDR_VAR 0 9
98562: PUSH
98563: LD_VAR 0 53
98567: PUSH
98568: LD_VAR 0 54
98572: PUSH
98573: LD_VAR 0 55
98577: PUSH
98578: LD_VAR 0 56
98582: PUSH
98583: LD_VAR 0 57
98587: PUSH
98588: LD_VAR 0 58
98592: PUSH
98593: EMPTY
98594: LIST
98595: LIST
98596: LIST
98597: LIST
98598: LIST
98599: LIST
98600: PUSH
98601: LD_VAR 0 4
98605: PUSH
98606: LD_INT 1
98608: PLUS
98609: ARRAY
98610: ST_TO_ADDR
98611: GO 98720
98613: LD_INT 31
98615: DOUBLE
98616: EQUAL
98617: IFTRUE 98663
98619: LD_INT 32
98621: DOUBLE
98622: EQUAL
98623: IFTRUE 98663
98625: LD_INT 33
98627: DOUBLE
98628: EQUAL
98629: IFTRUE 98663
98631: LD_INT 27
98633: DOUBLE
98634: EQUAL
98635: IFTRUE 98663
98637: LD_INT 26
98639: DOUBLE
98640: EQUAL
98641: IFTRUE 98663
98643: LD_INT 28
98645: DOUBLE
98646: EQUAL
98647: IFTRUE 98663
98649: LD_INT 29
98651: DOUBLE
98652: EQUAL
98653: IFTRUE 98663
98655: LD_INT 30
98657: DOUBLE
98658: EQUAL
98659: IFTRUE 98663
98661: GO 98719
98663: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98664: LD_ADDR_VAR 0 9
98668: PUSH
98669: LD_VAR 0 59
98673: PUSH
98674: LD_VAR 0 60
98678: PUSH
98679: LD_VAR 0 61
98683: PUSH
98684: LD_VAR 0 62
98688: PUSH
98689: LD_VAR 0 63
98693: PUSH
98694: LD_VAR 0 64
98698: PUSH
98699: EMPTY
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: PUSH
98707: LD_VAR 0 4
98711: PUSH
98712: LD_INT 1
98714: PLUS
98715: ARRAY
98716: ST_TO_ADDR
98717: GO 98720
98719: POP
// temp_list2 = [ ] ;
98720: LD_ADDR_VAR 0 10
98724: PUSH
98725: EMPTY
98726: ST_TO_ADDR
// for i in temp_list do
98727: LD_ADDR_VAR 0 8
98731: PUSH
98732: LD_VAR 0 9
98736: PUSH
98737: FOR_IN
98738: IFFALSE 98790
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98740: LD_ADDR_VAR 0 10
98744: PUSH
98745: LD_VAR 0 10
98749: PUSH
98750: LD_VAR 0 8
98754: PUSH
98755: LD_INT 1
98757: ARRAY
98758: PUSH
98759: LD_VAR 0 2
98763: PLUS
98764: PUSH
98765: LD_VAR 0 8
98769: PUSH
98770: LD_INT 2
98772: ARRAY
98773: PUSH
98774: LD_VAR 0 3
98778: PLUS
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: PUSH
98784: EMPTY
98785: LIST
98786: ADD
98787: ST_TO_ADDR
98788: GO 98737
98790: POP
98791: POP
// result = temp_list2 ;
98792: LD_ADDR_VAR 0 7
98796: PUSH
98797: LD_VAR 0 10
98801: ST_TO_ADDR
// end ;
98802: LD_VAR 0 7
98806: RET
// export function EnemyInRange ( unit , dist ) ; begin
98807: LD_INT 0
98809: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98810: LD_ADDR_VAR 0 3
98814: PUSH
98815: LD_VAR 0 1
98819: PPUSH
98820: CALL_OW 255
98824: PPUSH
98825: LD_VAR 0 1
98829: PPUSH
98830: CALL_OW 250
98834: PPUSH
98835: LD_VAR 0 1
98839: PPUSH
98840: CALL_OW 251
98844: PPUSH
98845: LD_VAR 0 2
98849: PPUSH
98850: CALL 72911 0 4
98854: PUSH
98855: LD_INT 4
98857: ARRAY
98858: ST_TO_ADDR
// end ;
98859: LD_VAR 0 3
98863: RET
// export function PlayerSeeMe ( unit ) ; begin
98864: LD_INT 0
98866: PPUSH
// result := See ( your_side , unit ) ;
98867: LD_ADDR_VAR 0 2
98871: PUSH
98872: LD_OWVAR 2
98876: PPUSH
98877: LD_VAR 0 1
98881: PPUSH
98882: CALL_OW 292
98886: ST_TO_ADDR
// end ;
98887: LD_VAR 0 2
98891: RET
// export function ReverseDir ( unit ) ; begin
98892: LD_INT 0
98894: PPUSH
// if not unit then
98895: LD_VAR 0 1
98899: NOT
98900: IFFALSE 98904
// exit ;
98902: GO 98927
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98904: LD_ADDR_VAR 0 2
98908: PUSH
98909: LD_VAR 0 1
98913: PPUSH
98914: CALL_OW 254
98918: PUSH
98919: LD_INT 3
98921: PLUS
98922: PUSH
98923: LD_INT 6
98925: MOD
98926: ST_TO_ADDR
// end ;
98927: LD_VAR 0 2
98931: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98932: LD_INT 0
98934: PPUSH
98935: PPUSH
98936: PPUSH
98937: PPUSH
98938: PPUSH
// if not hexes then
98939: LD_VAR 0 2
98943: NOT
98944: IFFALSE 98948
// exit ;
98946: GO 99096
// dist := 9999 ;
98948: LD_ADDR_VAR 0 5
98952: PUSH
98953: LD_INT 9999
98955: ST_TO_ADDR
// for i = 1 to hexes do
98956: LD_ADDR_VAR 0 4
98960: PUSH
98961: DOUBLE
98962: LD_INT 1
98964: DEC
98965: ST_TO_ADDR
98966: LD_VAR 0 2
98970: PUSH
98971: FOR_TO
98972: IFFALSE 99084
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98974: LD_VAR 0 1
98978: PPUSH
98979: LD_VAR 0 2
98983: PUSH
98984: LD_VAR 0 4
98988: ARRAY
98989: PUSH
98990: LD_INT 1
98992: ARRAY
98993: PPUSH
98994: LD_VAR 0 2
98998: PUSH
98999: LD_VAR 0 4
99003: ARRAY
99004: PUSH
99005: LD_INT 2
99007: ARRAY
99008: PPUSH
99009: CALL_OW 297
99013: PUSH
99014: LD_VAR 0 5
99018: LESS
99019: IFFALSE 99082
// begin hex := hexes [ i ] ;
99021: LD_ADDR_VAR 0 7
99025: PUSH
99026: LD_VAR 0 2
99030: PUSH
99031: LD_VAR 0 4
99035: ARRAY
99036: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
99037: LD_ADDR_VAR 0 5
99041: PUSH
99042: LD_VAR 0 1
99046: PPUSH
99047: LD_VAR 0 2
99051: PUSH
99052: LD_VAR 0 4
99056: ARRAY
99057: PUSH
99058: LD_INT 1
99060: ARRAY
99061: PPUSH
99062: LD_VAR 0 2
99066: PUSH
99067: LD_VAR 0 4
99071: ARRAY
99072: PUSH
99073: LD_INT 2
99075: ARRAY
99076: PPUSH
99077: CALL_OW 297
99081: ST_TO_ADDR
// end ; end ;
99082: GO 98971
99084: POP
99085: POP
// result := hex ;
99086: LD_ADDR_VAR 0 3
99090: PUSH
99091: LD_VAR 0 7
99095: ST_TO_ADDR
// end ;
99096: LD_VAR 0 3
99100: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
99101: LD_INT 0
99103: PPUSH
99104: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99105: LD_VAR 0 1
99109: NOT
99110: PUSH
99111: LD_VAR 0 1
99115: PUSH
99116: LD_INT 21
99118: PUSH
99119: LD_INT 2
99121: PUSH
99122: EMPTY
99123: LIST
99124: LIST
99125: PUSH
99126: LD_INT 23
99128: PUSH
99129: LD_INT 2
99131: PUSH
99132: EMPTY
99133: LIST
99134: LIST
99135: PUSH
99136: EMPTY
99137: LIST
99138: LIST
99139: PPUSH
99140: CALL_OW 69
99144: IN
99145: NOT
99146: OR
99147: IFFALSE 99151
// exit ;
99149: GO 99198
// for i = 1 to 3 do
99151: LD_ADDR_VAR 0 3
99155: PUSH
99156: DOUBLE
99157: LD_INT 1
99159: DEC
99160: ST_TO_ADDR
99161: LD_INT 3
99163: PUSH
99164: FOR_TO
99165: IFFALSE 99196
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
99167: LD_VAR 0 1
99171: PPUSH
99172: CALL_OW 250
99176: PPUSH
99177: LD_VAR 0 1
99181: PPUSH
99182: CALL_OW 251
99186: PPUSH
99187: LD_INT 1
99189: PPUSH
99190: CALL_OW 453
99194: GO 99164
99196: POP
99197: POP
// end ;
99198: LD_VAR 0 2
99202: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
99203: LD_INT 0
99205: PPUSH
99206: PPUSH
99207: PPUSH
99208: PPUSH
99209: PPUSH
99210: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
99211: LD_VAR 0 1
99215: NOT
99216: PUSH
99217: LD_VAR 0 2
99221: NOT
99222: OR
99223: PUSH
99224: LD_VAR 0 1
99228: PPUSH
99229: CALL_OW 314
99233: OR
99234: IFFALSE 99238
// exit ;
99236: GO 99679
// x := GetX ( enemy_unit ) ;
99238: LD_ADDR_VAR 0 7
99242: PUSH
99243: LD_VAR 0 2
99247: PPUSH
99248: CALL_OW 250
99252: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99253: LD_ADDR_VAR 0 8
99257: PUSH
99258: LD_VAR 0 2
99262: PPUSH
99263: CALL_OW 251
99267: ST_TO_ADDR
// if not x or not y then
99268: LD_VAR 0 7
99272: NOT
99273: PUSH
99274: LD_VAR 0 8
99278: NOT
99279: OR
99280: IFFALSE 99284
// exit ;
99282: GO 99679
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99284: LD_ADDR_VAR 0 6
99288: PUSH
99289: LD_VAR 0 7
99293: PPUSH
99294: LD_INT 0
99296: PPUSH
99297: LD_INT 4
99299: PPUSH
99300: CALL_OW 272
99304: PUSH
99305: LD_VAR 0 8
99309: PPUSH
99310: LD_INT 0
99312: PPUSH
99313: LD_INT 4
99315: PPUSH
99316: CALL_OW 273
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: PUSH
99325: LD_VAR 0 7
99329: PPUSH
99330: LD_INT 1
99332: PPUSH
99333: LD_INT 4
99335: PPUSH
99336: CALL_OW 272
99340: PUSH
99341: LD_VAR 0 8
99345: PPUSH
99346: LD_INT 1
99348: PPUSH
99349: LD_INT 4
99351: PPUSH
99352: CALL_OW 273
99356: PUSH
99357: EMPTY
99358: LIST
99359: LIST
99360: PUSH
99361: LD_VAR 0 7
99365: PPUSH
99366: LD_INT 2
99368: PPUSH
99369: LD_INT 4
99371: PPUSH
99372: CALL_OW 272
99376: PUSH
99377: LD_VAR 0 8
99381: PPUSH
99382: LD_INT 2
99384: PPUSH
99385: LD_INT 4
99387: PPUSH
99388: CALL_OW 273
99392: PUSH
99393: EMPTY
99394: LIST
99395: LIST
99396: PUSH
99397: LD_VAR 0 7
99401: PPUSH
99402: LD_INT 3
99404: PPUSH
99405: LD_INT 4
99407: PPUSH
99408: CALL_OW 272
99412: PUSH
99413: LD_VAR 0 8
99417: PPUSH
99418: LD_INT 3
99420: PPUSH
99421: LD_INT 4
99423: PPUSH
99424: CALL_OW 273
99428: PUSH
99429: EMPTY
99430: LIST
99431: LIST
99432: PUSH
99433: LD_VAR 0 7
99437: PPUSH
99438: LD_INT 4
99440: PPUSH
99441: LD_INT 4
99443: PPUSH
99444: CALL_OW 272
99448: PUSH
99449: LD_VAR 0 8
99453: PPUSH
99454: LD_INT 4
99456: PPUSH
99457: LD_INT 4
99459: PPUSH
99460: CALL_OW 273
99464: PUSH
99465: EMPTY
99466: LIST
99467: LIST
99468: PUSH
99469: LD_VAR 0 7
99473: PPUSH
99474: LD_INT 5
99476: PPUSH
99477: LD_INT 4
99479: PPUSH
99480: CALL_OW 272
99484: PUSH
99485: LD_VAR 0 8
99489: PPUSH
99490: LD_INT 5
99492: PPUSH
99493: LD_INT 4
99495: PPUSH
99496: CALL_OW 273
99500: PUSH
99501: EMPTY
99502: LIST
99503: LIST
99504: PUSH
99505: EMPTY
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: LIST
99512: ST_TO_ADDR
// for i = tmp downto 1 do
99513: LD_ADDR_VAR 0 4
99517: PUSH
99518: DOUBLE
99519: LD_VAR 0 6
99523: INC
99524: ST_TO_ADDR
99525: LD_INT 1
99527: PUSH
99528: FOR_DOWNTO
99529: IFFALSE 99630
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99531: LD_VAR 0 6
99535: PUSH
99536: LD_VAR 0 4
99540: ARRAY
99541: PUSH
99542: LD_INT 1
99544: ARRAY
99545: PPUSH
99546: LD_VAR 0 6
99550: PUSH
99551: LD_VAR 0 4
99555: ARRAY
99556: PUSH
99557: LD_INT 2
99559: ARRAY
99560: PPUSH
99561: CALL_OW 488
99565: NOT
99566: PUSH
99567: LD_VAR 0 6
99571: PUSH
99572: LD_VAR 0 4
99576: ARRAY
99577: PUSH
99578: LD_INT 1
99580: ARRAY
99581: PPUSH
99582: LD_VAR 0 6
99586: PUSH
99587: LD_VAR 0 4
99591: ARRAY
99592: PUSH
99593: LD_INT 2
99595: ARRAY
99596: PPUSH
99597: CALL_OW 428
99601: PUSH
99602: LD_INT 0
99604: NONEQUAL
99605: OR
99606: IFFALSE 99628
// tmp := Delete ( tmp , i ) ;
99608: LD_ADDR_VAR 0 6
99612: PUSH
99613: LD_VAR 0 6
99617: PPUSH
99618: LD_VAR 0 4
99622: PPUSH
99623: CALL_OW 3
99627: ST_TO_ADDR
99628: GO 99528
99630: POP
99631: POP
// j := GetClosestHex ( unit , tmp ) ;
99632: LD_ADDR_VAR 0 5
99636: PUSH
99637: LD_VAR 0 1
99641: PPUSH
99642: LD_VAR 0 6
99646: PPUSH
99647: CALL 98932 0 2
99651: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99652: LD_VAR 0 1
99656: PPUSH
99657: LD_VAR 0 5
99661: PUSH
99662: LD_INT 1
99664: ARRAY
99665: PPUSH
99666: LD_VAR 0 5
99670: PUSH
99671: LD_INT 2
99673: ARRAY
99674: PPUSH
99675: CALL_OW 111
// end ;
99679: LD_VAR 0 3
99683: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99684: LD_INT 0
99686: PPUSH
99687: PPUSH
99688: PPUSH
// uc_side = 0 ;
99689: LD_ADDR_OWVAR 20
99693: PUSH
99694: LD_INT 0
99696: ST_TO_ADDR
// uc_nation = 0 ;
99697: LD_ADDR_OWVAR 21
99701: PUSH
99702: LD_INT 0
99704: ST_TO_ADDR
// InitHc ;
99705: CALL_OW 19
// InitVc ;
99709: CALL_OW 20
// if mastodonts then
99713: LD_VAR 0 6
99717: IFFALSE 99784
// for i = 1 to mastodonts do
99719: LD_ADDR_VAR 0 11
99723: PUSH
99724: DOUBLE
99725: LD_INT 1
99727: DEC
99728: ST_TO_ADDR
99729: LD_VAR 0 6
99733: PUSH
99734: FOR_TO
99735: IFFALSE 99782
// begin vc_chassis := 31 ;
99737: LD_ADDR_OWVAR 37
99741: PUSH
99742: LD_INT 31
99744: ST_TO_ADDR
// vc_control := control_rider ;
99745: LD_ADDR_OWVAR 38
99749: PUSH
99750: LD_INT 4
99752: ST_TO_ADDR
// animal := CreateVehicle ;
99753: LD_ADDR_VAR 0 12
99757: PUSH
99758: CALL_OW 45
99762: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99763: LD_VAR 0 12
99767: PPUSH
99768: LD_VAR 0 8
99772: PPUSH
99773: LD_INT 0
99775: PPUSH
99776: CALL 106562 0 3
// end ;
99780: GO 99734
99782: POP
99783: POP
// if horses then
99784: LD_VAR 0 5
99788: IFFALSE 99855
// for i = 1 to horses do
99790: LD_ADDR_VAR 0 11
99794: PUSH
99795: DOUBLE
99796: LD_INT 1
99798: DEC
99799: ST_TO_ADDR
99800: LD_VAR 0 5
99804: PUSH
99805: FOR_TO
99806: IFFALSE 99853
// begin hc_class := 21 ;
99808: LD_ADDR_OWVAR 28
99812: PUSH
99813: LD_INT 21
99815: ST_TO_ADDR
// hc_gallery :=  ;
99816: LD_ADDR_OWVAR 33
99820: PUSH
99821: LD_STRING 
99823: ST_TO_ADDR
// animal := CreateHuman ;
99824: LD_ADDR_VAR 0 12
99828: PUSH
99829: CALL_OW 44
99833: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99834: LD_VAR 0 12
99838: PPUSH
99839: LD_VAR 0 8
99843: PPUSH
99844: LD_INT 0
99846: PPUSH
99847: CALL 106562 0 3
// end ;
99851: GO 99805
99853: POP
99854: POP
// if birds then
99855: LD_VAR 0 1
99859: IFFALSE 99926
// for i = 1 to birds do
99861: LD_ADDR_VAR 0 11
99865: PUSH
99866: DOUBLE
99867: LD_INT 1
99869: DEC
99870: ST_TO_ADDR
99871: LD_VAR 0 1
99875: PUSH
99876: FOR_TO
99877: IFFALSE 99924
// begin hc_class = 18 ;
99879: LD_ADDR_OWVAR 28
99883: PUSH
99884: LD_INT 18
99886: ST_TO_ADDR
// hc_gallery =  ;
99887: LD_ADDR_OWVAR 33
99891: PUSH
99892: LD_STRING 
99894: ST_TO_ADDR
// animal := CreateHuman ;
99895: LD_ADDR_VAR 0 12
99899: PUSH
99900: CALL_OW 44
99904: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99905: LD_VAR 0 12
99909: PPUSH
99910: LD_VAR 0 8
99914: PPUSH
99915: LD_INT 0
99917: PPUSH
99918: CALL 106562 0 3
// end ;
99922: GO 99876
99924: POP
99925: POP
// if tigers then
99926: LD_VAR 0 2
99930: IFFALSE 100014
// for i = 1 to tigers do
99932: LD_ADDR_VAR 0 11
99936: PUSH
99937: DOUBLE
99938: LD_INT 1
99940: DEC
99941: ST_TO_ADDR
99942: LD_VAR 0 2
99946: PUSH
99947: FOR_TO
99948: IFFALSE 100012
// begin hc_class = class_tiger ;
99950: LD_ADDR_OWVAR 28
99954: PUSH
99955: LD_INT 14
99957: ST_TO_ADDR
// hc_gallery =  ;
99958: LD_ADDR_OWVAR 33
99962: PUSH
99963: LD_STRING 
99965: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99966: LD_ADDR_OWVAR 35
99970: PUSH
99971: LD_INT 7
99973: NEG
99974: PPUSH
99975: LD_INT 7
99977: PPUSH
99978: CALL_OW 12
99982: ST_TO_ADDR
// animal := CreateHuman ;
99983: LD_ADDR_VAR 0 12
99987: PUSH
99988: CALL_OW 44
99992: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99993: LD_VAR 0 12
99997: PPUSH
99998: LD_VAR 0 8
100002: PPUSH
100003: LD_INT 0
100005: PPUSH
100006: CALL 106562 0 3
// end ;
100010: GO 99947
100012: POP
100013: POP
// if apemans then
100014: LD_VAR 0 3
100018: IFFALSE 100141
// for i = 1 to apemans do
100020: LD_ADDR_VAR 0 11
100024: PUSH
100025: DOUBLE
100026: LD_INT 1
100028: DEC
100029: ST_TO_ADDR
100030: LD_VAR 0 3
100034: PUSH
100035: FOR_TO
100036: IFFALSE 100139
// begin hc_class = class_apeman ;
100038: LD_ADDR_OWVAR 28
100042: PUSH
100043: LD_INT 12
100045: ST_TO_ADDR
// hc_gallery =  ;
100046: LD_ADDR_OWVAR 33
100050: PUSH
100051: LD_STRING 
100053: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
100054: LD_ADDR_OWVAR 35
100058: PUSH
100059: LD_INT 5
100061: NEG
100062: PPUSH
100063: LD_INT 5
100065: PPUSH
100066: CALL_OW 12
100070: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100071: LD_ADDR_OWVAR 31
100075: PUSH
100076: LD_INT 1
100078: PPUSH
100079: LD_INT 3
100081: PPUSH
100082: CALL_OW 12
100086: PUSH
100087: LD_INT 1
100089: PPUSH
100090: LD_INT 3
100092: PPUSH
100093: CALL_OW 12
100097: PUSH
100098: LD_INT 0
100100: PUSH
100101: LD_INT 0
100103: PUSH
100104: EMPTY
100105: LIST
100106: LIST
100107: LIST
100108: LIST
100109: ST_TO_ADDR
// animal := CreateHuman ;
100110: LD_ADDR_VAR 0 12
100114: PUSH
100115: CALL_OW 44
100119: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100120: LD_VAR 0 12
100124: PPUSH
100125: LD_VAR 0 8
100129: PPUSH
100130: LD_INT 0
100132: PPUSH
100133: CALL 106562 0 3
// end ;
100137: GO 100035
100139: POP
100140: POP
// if enchidnas then
100141: LD_VAR 0 4
100145: IFFALSE 100212
// for i = 1 to enchidnas do
100147: LD_ADDR_VAR 0 11
100151: PUSH
100152: DOUBLE
100153: LD_INT 1
100155: DEC
100156: ST_TO_ADDR
100157: LD_VAR 0 4
100161: PUSH
100162: FOR_TO
100163: IFFALSE 100210
// begin hc_class = 13 ;
100165: LD_ADDR_OWVAR 28
100169: PUSH
100170: LD_INT 13
100172: ST_TO_ADDR
// hc_gallery =  ;
100173: LD_ADDR_OWVAR 33
100177: PUSH
100178: LD_STRING 
100180: ST_TO_ADDR
// animal := CreateHuman ;
100181: LD_ADDR_VAR 0 12
100185: PUSH
100186: CALL_OW 44
100190: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100191: LD_VAR 0 12
100195: PPUSH
100196: LD_VAR 0 8
100200: PPUSH
100201: LD_INT 0
100203: PPUSH
100204: CALL 106562 0 3
// end ;
100208: GO 100162
100210: POP
100211: POP
// if fishes then
100212: LD_VAR 0 7
100216: IFFALSE 100283
// for i = 1 to fishes do
100218: LD_ADDR_VAR 0 11
100222: PUSH
100223: DOUBLE
100224: LD_INT 1
100226: DEC
100227: ST_TO_ADDR
100228: LD_VAR 0 7
100232: PUSH
100233: FOR_TO
100234: IFFALSE 100281
// begin hc_class = 20 ;
100236: LD_ADDR_OWVAR 28
100240: PUSH
100241: LD_INT 20
100243: ST_TO_ADDR
// hc_gallery =  ;
100244: LD_ADDR_OWVAR 33
100248: PUSH
100249: LD_STRING 
100251: ST_TO_ADDR
// animal := CreateHuman ;
100252: LD_ADDR_VAR 0 12
100256: PUSH
100257: CALL_OW 44
100261: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100262: LD_VAR 0 12
100266: PPUSH
100267: LD_VAR 0 9
100271: PPUSH
100272: LD_INT 0
100274: PPUSH
100275: CALL 106562 0 3
// end ;
100279: GO 100233
100281: POP
100282: POP
// end ;
100283: LD_VAR 0 10
100287: RET
// export function WantHeal ( sci , unit ) ; begin
100288: LD_INT 0
100290: PPUSH
// if GetTaskList ( sci ) > 0 then
100291: LD_VAR 0 1
100295: PPUSH
100296: CALL_OW 437
100300: PUSH
100301: LD_INT 0
100303: GREATER
100304: IFFALSE 100374
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100306: LD_VAR 0 1
100310: PPUSH
100311: CALL_OW 437
100315: PUSH
100316: LD_INT 1
100318: ARRAY
100319: PUSH
100320: LD_INT 1
100322: ARRAY
100323: PUSH
100324: LD_STRING l
100326: EQUAL
100327: PUSH
100328: LD_VAR 0 1
100332: PPUSH
100333: CALL_OW 437
100337: PUSH
100338: LD_INT 1
100340: ARRAY
100341: PUSH
100342: LD_INT 4
100344: ARRAY
100345: PUSH
100346: LD_VAR 0 2
100350: EQUAL
100351: AND
100352: IFFALSE 100364
// result := true else
100354: LD_ADDR_VAR 0 3
100358: PUSH
100359: LD_INT 1
100361: ST_TO_ADDR
100362: GO 100372
// result := false ;
100364: LD_ADDR_VAR 0 3
100368: PUSH
100369: LD_INT 0
100371: ST_TO_ADDR
// end else
100372: GO 100382
// result := false ;
100374: LD_ADDR_VAR 0 3
100378: PUSH
100379: LD_INT 0
100381: ST_TO_ADDR
// end ;
100382: LD_VAR 0 3
100386: RET
// export function HealTarget ( sci ) ; begin
100387: LD_INT 0
100389: PPUSH
// if not sci then
100390: LD_VAR 0 1
100394: NOT
100395: IFFALSE 100399
// exit ;
100397: GO 100464
// result := 0 ;
100399: LD_ADDR_VAR 0 2
100403: PUSH
100404: LD_INT 0
100406: ST_TO_ADDR
// if GetTaskList ( sci ) then
100407: LD_VAR 0 1
100411: PPUSH
100412: CALL_OW 437
100416: IFFALSE 100464
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100418: LD_VAR 0 1
100422: PPUSH
100423: CALL_OW 437
100427: PUSH
100428: LD_INT 1
100430: ARRAY
100431: PUSH
100432: LD_INT 1
100434: ARRAY
100435: PUSH
100436: LD_STRING l
100438: EQUAL
100439: IFFALSE 100464
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100441: LD_ADDR_VAR 0 2
100445: PUSH
100446: LD_VAR 0 1
100450: PPUSH
100451: CALL_OW 437
100455: PUSH
100456: LD_INT 1
100458: ARRAY
100459: PUSH
100460: LD_INT 4
100462: ARRAY
100463: ST_TO_ADDR
// end ;
100464: LD_VAR 0 2
100468: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100469: LD_INT 0
100471: PPUSH
100472: PPUSH
100473: PPUSH
100474: PPUSH
100475: PPUSH
100476: PPUSH
100477: PPUSH
100478: PPUSH
100479: PPUSH
100480: PPUSH
100481: PPUSH
100482: PPUSH
100483: PPUSH
100484: PPUSH
100485: PPUSH
100486: PPUSH
100487: PPUSH
100488: PPUSH
100489: PPUSH
100490: PPUSH
100491: PPUSH
100492: PPUSH
100493: PPUSH
100494: PPUSH
100495: PPUSH
100496: PPUSH
100497: PPUSH
100498: PPUSH
100499: PPUSH
100500: PPUSH
100501: PPUSH
100502: PPUSH
100503: PPUSH
100504: PPUSH
// if not list then
100505: LD_VAR 0 1
100509: NOT
100510: IFFALSE 100514
// exit ;
100512: GO 105173
// base := list [ 1 ] ;
100514: LD_ADDR_VAR 0 3
100518: PUSH
100519: LD_VAR 0 1
100523: PUSH
100524: LD_INT 1
100526: ARRAY
100527: ST_TO_ADDR
// group := list [ 2 ] ;
100528: LD_ADDR_VAR 0 4
100532: PUSH
100533: LD_VAR 0 1
100537: PUSH
100538: LD_INT 2
100540: ARRAY
100541: ST_TO_ADDR
// path := list [ 3 ] ;
100542: LD_ADDR_VAR 0 5
100546: PUSH
100547: LD_VAR 0 1
100551: PUSH
100552: LD_INT 3
100554: ARRAY
100555: ST_TO_ADDR
// flags := list [ 4 ] ;
100556: LD_ADDR_VAR 0 6
100560: PUSH
100561: LD_VAR 0 1
100565: PUSH
100566: LD_INT 4
100568: ARRAY
100569: ST_TO_ADDR
// mined := [ ] ;
100570: LD_ADDR_VAR 0 27
100574: PUSH
100575: EMPTY
100576: ST_TO_ADDR
// bombed := [ ] ;
100577: LD_ADDR_VAR 0 28
100581: PUSH
100582: EMPTY
100583: ST_TO_ADDR
// healers := [ ] ;
100584: LD_ADDR_VAR 0 31
100588: PUSH
100589: EMPTY
100590: ST_TO_ADDR
// to_heal := [ ] ;
100591: LD_ADDR_VAR 0 30
100595: PUSH
100596: EMPTY
100597: ST_TO_ADDR
// repairs := [ ] ;
100598: LD_ADDR_VAR 0 33
100602: PUSH
100603: EMPTY
100604: ST_TO_ADDR
// to_repair := [ ] ;
100605: LD_ADDR_VAR 0 32
100609: PUSH
100610: EMPTY
100611: ST_TO_ADDR
// if not group or not path then
100612: LD_VAR 0 4
100616: NOT
100617: PUSH
100618: LD_VAR 0 5
100622: NOT
100623: OR
100624: IFFALSE 100628
// exit ;
100626: GO 105173
// side := GetSide ( group [ 1 ] ) ;
100628: LD_ADDR_VAR 0 35
100632: PUSH
100633: LD_VAR 0 4
100637: PUSH
100638: LD_INT 1
100640: ARRAY
100641: PPUSH
100642: CALL_OW 255
100646: ST_TO_ADDR
// if flags then
100647: LD_VAR 0 6
100651: IFFALSE 100795
// begin f_ignore_area := flags [ 1 ] ;
100653: LD_ADDR_VAR 0 17
100657: PUSH
100658: LD_VAR 0 6
100662: PUSH
100663: LD_INT 1
100665: ARRAY
100666: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100667: LD_ADDR_VAR 0 18
100671: PUSH
100672: LD_VAR 0 6
100676: PUSH
100677: LD_INT 2
100679: ARRAY
100680: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100681: LD_ADDR_VAR 0 19
100685: PUSH
100686: LD_VAR 0 6
100690: PUSH
100691: LD_INT 3
100693: ARRAY
100694: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100695: LD_ADDR_VAR 0 20
100699: PUSH
100700: LD_VAR 0 6
100704: PUSH
100705: LD_INT 4
100707: ARRAY
100708: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100709: LD_ADDR_VAR 0 21
100713: PUSH
100714: LD_VAR 0 6
100718: PUSH
100719: LD_INT 5
100721: ARRAY
100722: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100723: LD_ADDR_VAR 0 22
100727: PUSH
100728: LD_VAR 0 6
100732: PUSH
100733: LD_INT 6
100735: ARRAY
100736: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100737: LD_ADDR_VAR 0 23
100741: PUSH
100742: LD_VAR 0 6
100746: PUSH
100747: LD_INT 7
100749: ARRAY
100750: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100751: LD_ADDR_VAR 0 24
100755: PUSH
100756: LD_VAR 0 6
100760: PUSH
100761: LD_INT 8
100763: ARRAY
100764: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100765: LD_ADDR_VAR 0 25
100769: PUSH
100770: LD_VAR 0 6
100774: PUSH
100775: LD_INT 9
100777: ARRAY
100778: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100779: LD_ADDR_VAR 0 26
100783: PUSH
100784: LD_VAR 0 6
100788: PUSH
100789: LD_INT 10
100791: ARRAY
100792: ST_TO_ADDR
// end else
100793: GO 100875
// begin f_ignore_area := false ;
100795: LD_ADDR_VAR 0 17
100799: PUSH
100800: LD_INT 0
100802: ST_TO_ADDR
// f_capture := false ;
100803: LD_ADDR_VAR 0 18
100807: PUSH
100808: LD_INT 0
100810: ST_TO_ADDR
// f_ignore_civ := false ;
100811: LD_ADDR_VAR 0 19
100815: PUSH
100816: LD_INT 0
100818: ST_TO_ADDR
// f_murder := false ;
100819: LD_ADDR_VAR 0 20
100823: PUSH
100824: LD_INT 0
100826: ST_TO_ADDR
// f_mines := false ;
100827: LD_ADDR_VAR 0 21
100831: PUSH
100832: LD_INT 0
100834: ST_TO_ADDR
// f_repair := false ;
100835: LD_ADDR_VAR 0 22
100839: PUSH
100840: LD_INT 0
100842: ST_TO_ADDR
// f_heal := false ;
100843: LD_ADDR_VAR 0 23
100847: PUSH
100848: LD_INT 0
100850: ST_TO_ADDR
// f_spacetime := false ;
100851: LD_ADDR_VAR 0 24
100855: PUSH
100856: LD_INT 0
100858: ST_TO_ADDR
// f_attack_depot := false ;
100859: LD_ADDR_VAR 0 25
100863: PUSH
100864: LD_INT 0
100866: ST_TO_ADDR
// f_crawl := false ;
100867: LD_ADDR_VAR 0 26
100871: PUSH
100872: LD_INT 0
100874: ST_TO_ADDR
// end ; if f_heal then
100875: LD_VAR 0 23
100879: IFFALSE 100906
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100881: LD_ADDR_VAR 0 31
100885: PUSH
100886: LD_VAR 0 4
100890: PPUSH
100891: LD_INT 25
100893: PUSH
100894: LD_INT 4
100896: PUSH
100897: EMPTY
100898: LIST
100899: LIST
100900: PPUSH
100901: CALL_OW 72
100905: ST_TO_ADDR
// if f_repair then
100906: LD_VAR 0 22
100910: IFFALSE 100937
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100912: LD_ADDR_VAR 0 33
100916: PUSH
100917: LD_VAR 0 4
100921: PPUSH
100922: LD_INT 25
100924: PUSH
100925: LD_INT 3
100927: PUSH
100928: EMPTY
100929: LIST
100930: LIST
100931: PPUSH
100932: CALL_OW 72
100936: ST_TO_ADDR
// units_path := [ ] ;
100937: LD_ADDR_VAR 0 16
100941: PUSH
100942: EMPTY
100943: ST_TO_ADDR
// for i = 1 to group do
100944: LD_ADDR_VAR 0 7
100948: PUSH
100949: DOUBLE
100950: LD_INT 1
100952: DEC
100953: ST_TO_ADDR
100954: LD_VAR 0 4
100958: PUSH
100959: FOR_TO
100960: IFFALSE 100989
// units_path := Replace ( units_path , i , path ) ;
100962: LD_ADDR_VAR 0 16
100966: PUSH
100967: LD_VAR 0 16
100971: PPUSH
100972: LD_VAR 0 7
100976: PPUSH
100977: LD_VAR 0 5
100981: PPUSH
100982: CALL_OW 1
100986: ST_TO_ADDR
100987: GO 100959
100989: POP
100990: POP
// repeat for i = group downto 1 do
100991: LD_ADDR_VAR 0 7
100995: PUSH
100996: DOUBLE
100997: LD_VAR 0 4
101001: INC
101002: ST_TO_ADDR
101003: LD_INT 1
101005: PUSH
101006: FOR_DOWNTO
101007: IFFALSE 105129
// begin wait ( 5 ) ;
101009: LD_INT 5
101011: PPUSH
101012: CALL_OW 67
// tmp := [ ] ;
101016: LD_ADDR_VAR 0 14
101020: PUSH
101021: EMPTY
101022: ST_TO_ADDR
// attacking := false ;
101023: LD_ADDR_VAR 0 29
101027: PUSH
101028: LD_INT 0
101030: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
101031: LD_VAR 0 4
101035: PUSH
101036: LD_VAR 0 7
101040: ARRAY
101041: PPUSH
101042: CALL_OW 301
101046: PUSH
101047: LD_VAR 0 4
101051: PUSH
101052: LD_VAR 0 7
101056: ARRAY
101057: NOT
101058: OR
101059: IFFALSE 101168
// begin if GetType ( group [ i ] ) = unit_human then
101061: LD_VAR 0 4
101065: PUSH
101066: LD_VAR 0 7
101070: ARRAY
101071: PPUSH
101072: CALL_OW 247
101076: PUSH
101077: LD_INT 1
101079: EQUAL
101080: IFFALSE 101126
// begin to_heal := to_heal diff group [ i ] ;
101082: LD_ADDR_VAR 0 30
101086: PUSH
101087: LD_VAR 0 30
101091: PUSH
101092: LD_VAR 0 4
101096: PUSH
101097: LD_VAR 0 7
101101: ARRAY
101102: DIFF
101103: ST_TO_ADDR
// healers := healers diff group [ i ] ;
101104: LD_ADDR_VAR 0 31
101108: PUSH
101109: LD_VAR 0 31
101113: PUSH
101114: LD_VAR 0 4
101118: PUSH
101119: LD_VAR 0 7
101123: ARRAY
101124: DIFF
101125: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
101126: LD_ADDR_VAR 0 4
101130: PUSH
101131: LD_VAR 0 4
101135: PPUSH
101136: LD_VAR 0 7
101140: PPUSH
101141: CALL_OW 3
101145: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
101146: LD_ADDR_VAR 0 16
101150: PUSH
101151: LD_VAR 0 16
101155: PPUSH
101156: LD_VAR 0 7
101160: PPUSH
101161: CALL_OW 3
101165: ST_TO_ADDR
// continue ;
101166: GO 101006
// end ; if f_repair then
101168: LD_VAR 0 22
101172: IFFALSE 101661
// begin if GetType ( group [ i ] ) = unit_vehicle then
101174: LD_VAR 0 4
101178: PUSH
101179: LD_VAR 0 7
101183: ARRAY
101184: PPUSH
101185: CALL_OW 247
101189: PUSH
101190: LD_INT 2
101192: EQUAL
101193: IFFALSE 101383
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
101195: LD_VAR 0 4
101199: PUSH
101200: LD_VAR 0 7
101204: ARRAY
101205: PPUSH
101206: CALL_OW 256
101210: PUSH
101211: LD_INT 700
101213: LESS
101214: PUSH
101215: LD_VAR 0 4
101219: PUSH
101220: LD_VAR 0 7
101224: ARRAY
101225: PUSH
101226: LD_VAR 0 32
101230: IN
101231: NOT
101232: AND
101233: IFFALSE 101257
// to_repair := to_repair union group [ i ] ;
101235: LD_ADDR_VAR 0 32
101239: PUSH
101240: LD_VAR 0 32
101244: PUSH
101245: LD_VAR 0 4
101249: PUSH
101250: LD_VAR 0 7
101254: ARRAY
101255: UNION
101256: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
101257: LD_VAR 0 4
101261: PUSH
101262: LD_VAR 0 7
101266: ARRAY
101267: PPUSH
101268: CALL_OW 256
101272: PUSH
101273: LD_INT 1000
101275: EQUAL
101276: PUSH
101277: LD_VAR 0 4
101281: PUSH
101282: LD_VAR 0 7
101286: ARRAY
101287: PUSH
101288: LD_VAR 0 32
101292: IN
101293: AND
101294: IFFALSE 101318
// to_repair := to_repair diff group [ i ] ;
101296: LD_ADDR_VAR 0 32
101300: PUSH
101301: LD_VAR 0 32
101305: PUSH
101306: LD_VAR 0 4
101310: PUSH
101311: LD_VAR 0 7
101315: ARRAY
101316: DIFF
101317: ST_TO_ADDR
// if group [ i ] in to_repair then
101318: LD_VAR 0 4
101322: PUSH
101323: LD_VAR 0 7
101327: ARRAY
101328: PUSH
101329: LD_VAR 0 32
101333: IN
101334: IFFALSE 101381
// begin if not IsInArea ( group [ i ] , f_repair ) then
101336: LD_VAR 0 4
101340: PUSH
101341: LD_VAR 0 7
101345: ARRAY
101346: PPUSH
101347: LD_VAR 0 22
101351: PPUSH
101352: CALL_OW 308
101356: NOT
101357: IFFALSE 101379
// ComMoveToArea ( group [ i ] , f_repair ) ;
101359: LD_VAR 0 4
101363: PUSH
101364: LD_VAR 0 7
101368: ARRAY
101369: PPUSH
101370: LD_VAR 0 22
101374: PPUSH
101375: CALL_OW 113
// continue ;
101379: GO 101006
// end ; end else
101381: GO 101661
// if group [ i ] in repairs then
101383: LD_VAR 0 4
101387: PUSH
101388: LD_VAR 0 7
101392: ARRAY
101393: PUSH
101394: LD_VAR 0 33
101398: IN
101399: IFFALSE 101661
// begin if IsInUnit ( group [ i ] ) then
101401: LD_VAR 0 4
101405: PUSH
101406: LD_VAR 0 7
101410: ARRAY
101411: PPUSH
101412: CALL_OW 310
101416: IFFALSE 101484
// begin z := IsInUnit ( group [ i ] ) ;
101418: LD_ADDR_VAR 0 13
101422: PUSH
101423: LD_VAR 0 4
101427: PUSH
101428: LD_VAR 0 7
101432: ARRAY
101433: PPUSH
101434: CALL_OW 310
101438: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101439: LD_VAR 0 13
101443: PUSH
101444: LD_VAR 0 32
101448: IN
101449: PUSH
101450: LD_VAR 0 13
101454: PPUSH
101455: LD_VAR 0 22
101459: PPUSH
101460: CALL_OW 308
101464: AND
101465: IFFALSE 101482
// ComExitVehicle ( group [ i ] ) ;
101467: LD_VAR 0 4
101471: PUSH
101472: LD_VAR 0 7
101476: ARRAY
101477: PPUSH
101478: CALL_OW 121
// end else
101482: GO 101661
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101484: LD_ADDR_VAR 0 13
101488: PUSH
101489: LD_VAR 0 4
101493: PPUSH
101494: LD_INT 95
101496: PUSH
101497: LD_VAR 0 22
101501: PUSH
101502: EMPTY
101503: LIST
101504: LIST
101505: PUSH
101506: LD_INT 58
101508: PUSH
101509: EMPTY
101510: LIST
101511: PUSH
101512: EMPTY
101513: LIST
101514: LIST
101515: PPUSH
101516: CALL_OW 72
101520: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101521: LD_VAR 0 4
101525: PUSH
101526: LD_VAR 0 7
101530: ARRAY
101531: PPUSH
101532: CALL_OW 314
101536: NOT
101537: IFFALSE 101659
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101539: LD_ADDR_VAR 0 10
101543: PUSH
101544: LD_VAR 0 13
101548: PPUSH
101549: LD_VAR 0 4
101553: PUSH
101554: LD_VAR 0 7
101558: ARRAY
101559: PPUSH
101560: CALL_OW 74
101564: ST_TO_ADDR
// if not x then
101565: LD_VAR 0 10
101569: NOT
101570: IFFALSE 101574
// continue ;
101572: GO 101006
// if GetLives ( x ) < 1000 then
101574: LD_VAR 0 10
101578: PPUSH
101579: CALL_OW 256
101583: PUSH
101584: LD_INT 1000
101586: LESS
101587: IFFALSE 101611
// ComRepairVehicle ( group [ i ] , x ) else
101589: LD_VAR 0 4
101593: PUSH
101594: LD_VAR 0 7
101598: ARRAY
101599: PPUSH
101600: LD_VAR 0 10
101604: PPUSH
101605: CALL_OW 129
101609: GO 101659
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101611: LD_VAR 0 23
101615: PUSH
101616: LD_VAR 0 4
101620: PUSH
101621: LD_VAR 0 7
101625: ARRAY
101626: PPUSH
101627: CALL_OW 256
101631: PUSH
101632: LD_INT 1000
101634: LESS
101635: AND
101636: NOT
101637: IFFALSE 101659
// ComEnterUnit ( group [ i ] , x ) ;
101639: LD_VAR 0 4
101643: PUSH
101644: LD_VAR 0 7
101648: ARRAY
101649: PPUSH
101650: LD_VAR 0 10
101654: PPUSH
101655: CALL_OW 120
// end ; continue ;
101659: GO 101006
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101661: LD_VAR 0 23
101665: PUSH
101666: LD_VAR 0 4
101670: PUSH
101671: LD_VAR 0 7
101675: ARRAY
101676: PPUSH
101677: CALL_OW 247
101681: PUSH
101682: LD_INT 1
101684: EQUAL
101685: AND
101686: IFFALSE 102164
// begin if group [ i ] in healers then
101688: LD_VAR 0 4
101692: PUSH
101693: LD_VAR 0 7
101697: ARRAY
101698: PUSH
101699: LD_VAR 0 31
101703: IN
101704: IFFALSE 101977
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101706: LD_VAR 0 4
101710: PUSH
101711: LD_VAR 0 7
101715: ARRAY
101716: PPUSH
101717: LD_VAR 0 23
101721: PPUSH
101722: CALL_OW 308
101726: NOT
101727: PUSH
101728: LD_VAR 0 4
101732: PUSH
101733: LD_VAR 0 7
101737: ARRAY
101738: PPUSH
101739: CALL_OW 314
101743: NOT
101744: AND
101745: IFFALSE 101769
// ComMoveToArea ( group [ i ] , f_heal ) else
101747: LD_VAR 0 4
101751: PUSH
101752: LD_VAR 0 7
101756: ARRAY
101757: PPUSH
101758: LD_VAR 0 23
101762: PPUSH
101763: CALL_OW 113
101767: GO 101975
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101769: LD_VAR 0 4
101773: PUSH
101774: LD_VAR 0 7
101778: ARRAY
101779: PPUSH
101780: CALL 100387 0 1
101784: PPUSH
101785: CALL_OW 256
101789: PUSH
101790: LD_INT 1000
101792: EQUAL
101793: IFFALSE 101812
// ComStop ( group [ i ] ) else
101795: LD_VAR 0 4
101799: PUSH
101800: LD_VAR 0 7
101804: ARRAY
101805: PPUSH
101806: CALL_OW 141
101810: GO 101975
// if not HasTask ( group [ i ] ) and to_heal then
101812: LD_VAR 0 4
101816: PUSH
101817: LD_VAR 0 7
101821: ARRAY
101822: PPUSH
101823: CALL_OW 314
101827: NOT
101828: PUSH
101829: LD_VAR 0 30
101833: AND
101834: IFFALSE 101975
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101836: LD_ADDR_VAR 0 13
101840: PUSH
101841: LD_VAR 0 30
101845: PPUSH
101846: LD_INT 3
101848: PUSH
101849: LD_INT 54
101851: PUSH
101852: EMPTY
101853: LIST
101854: PUSH
101855: EMPTY
101856: LIST
101857: LIST
101858: PPUSH
101859: CALL_OW 72
101863: PPUSH
101864: LD_VAR 0 4
101868: PUSH
101869: LD_VAR 0 7
101873: ARRAY
101874: PPUSH
101875: CALL_OW 74
101879: ST_TO_ADDR
// if z then
101880: LD_VAR 0 13
101884: IFFALSE 101975
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101886: LD_INT 91
101888: PUSH
101889: LD_VAR 0 13
101893: PUSH
101894: LD_INT 10
101896: PUSH
101897: EMPTY
101898: LIST
101899: LIST
101900: LIST
101901: PUSH
101902: LD_INT 81
101904: PUSH
101905: LD_VAR 0 13
101909: PPUSH
101910: CALL_OW 255
101914: PUSH
101915: EMPTY
101916: LIST
101917: LIST
101918: PUSH
101919: EMPTY
101920: LIST
101921: LIST
101922: PPUSH
101923: CALL_OW 69
101927: PUSH
101928: LD_INT 0
101930: EQUAL
101931: IFFALSE 101955
// ComHeal ( group [ i ] , z ) else
101933: LD_VAR 0 4
101937: PUSH
101938: LD_VAR 0 7
101942: ARRAY
101943: PPUSH
101944: LD_VAR 0 13
101948: PPUSH
101949: CALL_OW 128
101953: GO 101975
// ComMoveToArea ( group [ i ] , f_heal ) ;
101955: LD_VAR 0 4
101959: PUSH
101960: LD_VAR 0 7
101964: ARRAY
101965: PPUSH
101966: LD_VAR 0 23
101970: PPUSH
101971: CALL_OW 113
// end ; continue ;
101975: GO 101006
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101977: LD_VAR 0 4
101981: PUSH
101982: LD_VAR 0 7
101986: ARRAY
101987: PPUSH
101988: CALL_OW 256
101992: PUSH
101993: LD_INT 700
101995: LESS
101996: PUSH
101997: LD_VAR 0 4
102001: PUSH
102002: LD_VAR 0 7
102006: ARRAY
102007: PUSH
102008: LD_VAR 0 30
102012: IN
102013: NOT
102014: AND
102015: IFFALSE 102039
// to_heal := to_heal union group [ i ] ;
102017: LD_ADDR_VAR 0 30
102021: PUSH
102022: LD_VAR 0 30
102026: PUSH
102027: LD_VAR 0 4
102031: PUSH
102032: LD_VAR 0 7
102036: ARRAY
102037: UNION
102038: ST_TO_ADDR
// if group [ i ] in to_heal then
102039: LD_VAR 0 4
102043: PUSH
102044: LD_VAR 0 7
102048: ARRAY
102049: PUSH
102050: LD_VAR 0 30
102054: IN
102055: IFFALSE 102164
// begin if GetLives ( group [ i ] ) = 1000 then
102057: LD_VAR 0 4
102061: PUSH
102062: LD_VAR 0 7
102066: ARRAY
102067: PPUSH
102068: CALL_OW 256
102072: PUSH
102073: LD_INT 1000
102075: EQUAL
102076: IFFALSE 102102
// to_heal := to_heal diff group [ i ] else
102078: LD_ADDR_VAR 0 30
102082: PUSH
102083: LD_VAR 0 30
102087: PUSH
102088: LD_VAR 0 4
102092: PUSH
102093: LD_VAR 0 7
102097: ARRAY
102098: DIFF
102099: ST_TO_ADDR
102100: GO 102164
// begin if not IsInArea ( group [ i ] , to_heal ) then
102102: LD_VAR 0 4
102106: PUSH
102107: LD_VAR 0 7
102111: ARRAY
102112: PPUSH
102113: LD_VAR 0 30
102117: PPUSH
102118: CALL_OW 308
102122: NOT
102123: IFFALSE 102147
// ComMoveToArea ( group [ i ] , f_heal ) else
102125: LD_VAR 0 4
102129: PUSH
102130: LD_VAR 0 7
102134: ARRAY
102135: PPUSH
102136: LD_VAR 0 23
102140: PPUSH
102141: CALL_OW 113
102145: GO 102162
// ComHold ( group [ i ] ) ;
102147: LD_VAR 0 4
102151: PUSH
102152: LD_VAR 0 7
102156: ARRAY
102157: PPUSH
102158: CALL_OW 140
// continue ;
102162: GO 101006
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
102164: LD_VAR 0 4
102168: PUSH
102169: LD_VAR 0 7
102173: ARRAY
102174: PPUSH
102175: LD_INT 10
102177: PPUSH
102178: CALL 98807 0 2
102182: NOT
102183: PUSH
102184: LD_VAR 0 16
102188: PUSH
102189: LD_VAR 0 7
102193: ARRAY
102194: PUSH
102195: EMPTY
102196: EQUAL
102197: NOT
102198: AND
102199: IFFALSE 102465
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
102201: LD_VAR 0 4
102205: PUSH
102206: LD_VAR 0 7
102210: ARRAY
102211: PPUSH
102212: CALL_OW 262
102216: PUSH
102217: LD_INT 1
102219: PUSH
102220: LD_INT 2
102222: PUSH
102223: EMPTY
102224: LIST
102225: LIST
102226: IN
102227: IFFALSE 102268
// if GetFuel ( group [ i ] ) < 10 then
102229: LD_VAR 0 4
102233: PUSH
102234: LD_VAR 0 7
102238: ARRAY
102239: PPUSH
102240: CALL_OW 261
102244: PUSH
102245: LD_INT 10
102247: LESS
102248: IFFALSE 102268
// SetFuel ( group [ i ] , 12 ) ;
102250: LD_VAR 0 4
102254: PUSH
102255: LD_VAR 0 7
102259: ARRAY
102260: PPUSH
102261: LD_INT 12
102263: PPUSH
102264: CALL_OW 240
// if units_path [ i ] then
102268: LD_VAR 0 16
102272: PUSH
102273: LD_VAR 0 7
102277: ARRAY
102278: IFFALSE 102463
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
102280: LD_VAR 0 4
102284: PUSH
102285: LD_VAR 0 7
102289: ARRAY
102290: PPUSH
102291: LD_VAR 0 16
102295: PUSH
102296: LD_VAR 0 7
102300: ARRAY
102301: PUSH
102302: LD_INT 1
102304: ARRAY
102305: PUSH
102306: LD_INT 1
102308: ARRAY
102309: PPUSH
102310: LD_VAR 0 16
102314: PUSH
102315: LD_VAR 0 7
102319: ARRAY
102320: PUSH
102321: LD_INT 1
102323: ARRAY
102324: PUSH
102325: LD_INT 2
102327: ARRAY
102328: PPUSH
102329: CALL_OW 297
102333: PUSH
102334: LD_INT 6
102336: GREATER
102337: IFFALSE 102412
// begin if not HasTask ( group [ i ] ) then
102339: LD_VAR 0 4
102343: PUSH
102344: LD_VAR 0 7
102348: ARRAY
102349: PPUSH
102350: CALL_OW 314
102354: NOT
102355: IFFALSE 102410
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
102357: LD_VAR 0 4
102361: PUSH
102362: LD_VAR 0 7
102366: ARRAY
102367: PPUSH
102368: LD_VAR 0 16
102372: PUSH
102373: LD_VAR 0 7
102377: ARRAY
102378: PUSH
102379: LD_INT 1
102381: ARRAY
102382: PUSH
102383: LD_INT 1
102385: ARRAY
102386: PPUSH
102387: LD_VAR 0 16
102391: PUSH
102392: LD_VAR 0 7
102396: ARRAY
102397: PUSH
102398: LD_INT 1
102400: ARRAY
102401: PUSH
102402: LD_INT 2
102404: ARRAY
102405: PPUSH
102406: CALL_OW 114
// end else
102410: GO 102463
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102412: LD_ADDR_VAR 0 15
102416: PUSH
102417: LD_VAR 0 16
102421: PUSH
102422: LD_VAR 0 7
102426: ARRAY
102427: PPUSH
102428: LD_INT 1
102430: PPUSH
102431: CALL_OW 3
102435: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102436: LD_ADDR_VAR 0 16
102440: PUSH
102441: LD_VAR 0 16
102445: PPUSH
102446: LD_VAR 0 7
102450: PPUSH
102451: LD_VAR 0 15
102455: PPUSH
102456: CALL_OW 1
102460: ST_TO_ADDR
// continue ;
102461: GO 101006
// end ; end ; end else
102463: GO 105127
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102465: LD_ADDR_VAR 0 14
102469: PUSH
102470: LD_INT 81
102472: PUSH
102473: LD_VAR 0 4
102477: PUSH
102478: LD_VAR 0 7
102482: ARRAY
102483: PPUSH
102484: CALL_OW 255
102488: PUSH
102489: EMPTY
102490: LIST
102491: LIST
102492: PPUSH
102493: CALL_OW 69
102497: ST_TO_ADDR
// if not tmp then
102498: LD_VAR 0 14
102502: NOT
102503: IFFALSE 102507
// continue ;
102505: GO 101006
// if f_ignore_area then
102507: LD_VAR 0 17
102511: IFFALSE 102599
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102513: LD_ADDR_VAR 0 15
102517: PUSH
102518: LD_VAR 0 14
102522: PPUSH
102523: LD_INT 3
102525: PUSH
102526: LD_INT 92
102528: PUSH
102529: LD_VAR 0 17
102533: PUSH
102534: LD_INT 1
102536: ARRAY
102537: PUSH
102538: LD_VAR 0 17
102542: PUSH
102543: LD_INT 2
102545: ARRAY
102546: PUSH
102547: LD_VAR 0 17
102551: PUSH
102552: LD_INT 3
102554: ARRAY
102555: PUSH
102556: EMPTY
102557: LIST
102558: LIST
102559: LIST
102560: LIST
102561: PUSH
102562: EMPTY
102563: LIST
102564: LIST
102565: PPUSH
102566: CALL_OW 72
102570: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102571: LD_VAR 0 14
102575: PUSH
102576: LD_VAR 0 15
102580: DIFF
102581: IFFALSE 102599
// tmp := tmp diff tmp2 ;
102583: LD_ADDR_VAR 0 14
102587: PUSH
102588: LD_VAR 0 14
102592: PUSH
102593: LD_VAR 0 15
102597: DIFF
102598: ST_TO_ADDR
// end ; if not f_murder then
102599: LD_VAR 0 20
102603: NOT
102604: IFFALSE 102662
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102606: LD_ADDR_VAR 0 15
102610: PUSH
102611: LD_VAR 0 14
102615: PPUSH
102616: LD_INT 3
102618: PUSH
102619: LD_INT 50
102621: PUSH
102622: EMPTY
102623: LIST
102624: PUSH
102625: EMPTY
102626: LIST
102627: LIST
102628: PPUSH
102629: CALL_OW 72
102633: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102634: LD_VAR 0 14
102638: PUSH
102639: LD_VAR 0 15
102643: DIFF
102644: IFFALSE 102662
// tmp := tmp diff tmp2 ;
102646: LD_ADDR_VAR 0 14
102650: PUSH
102651: LD_VAR 0 14
102655: PUSH
102656: LD_VAR 0 15
102660: DIFF
102661: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102662: LD_ADDR_VAR 0 14
102666: PUSH
102667: LD_VAR 0 4
102671: PUSH
102672: LD_VAR 0 7
102676: ARRAY
102677: PPUSH
102678: LD_VAR 0 14
102682: PPUSH
102683: LD_INT 1
102685: PPUSH
102686: LD_INT 1
102688: PPUSH
102689: CALL 72450 0 4
102693: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102694: LD_VAR 0 4
102698: PUSH
102699: LD_VAR 0 7
102703: ARRAY
102704: PPUSH
102705: CALL_OW 257
102709: PUSH
102710: LD_INT 1
102712: EQUAL
102713: IFFALSE 103161
// begin if WantPlant ( group [ i ] ) then
102715: LD_VAR 0 4
102719: PUSH
102720: LD_VAR 0 7
102724: ARRAY
102725: PPUSH
102726: CALL 71951 0 1
102730: IFFALSE 102734
// continue ;
102732: GO 101006
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102734: LD_VAR 0 18
102738: PUSH
102739: LD_VAR 0 4
102743: PUSH
102744: LD_VAR 0 7
102748: ARRAY
102749: PPUSH
102750: CALL_OW 310
102754: NOT
102755: AND
102756: PUSH
102757: LD_VAR 0 14
102761: PUSH
102762: LD_INT 1
102764: ARRAY
102765: PUSH
102766: LD_VAR 0 14
102770: PPUSH
102771: LD_INT 21
102773: PUSH
102774: LD_INT 2
102776: PUSH
102777: EMPTY
102778: LIST
102779: LIST
102780: PUSH
102781: LD_INT 58
102783: PUSH
102784: EMPTY
102785: LIST
102786: PUSH
102787: EMPTY
102788: LIST
102789: LIST
102790: PPUSH
102791: CALL_OW 72
102795: IN
102796: AND
102797: IFFALSE 102833
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102799: LD_VAR 0 4
102803: PUSH
102804: LD_VAR 0 7
102808: ARRAY
102809: PPUSH
102810: LD_VAR 0 14
102814: PUSH
102815: LD_INT 1
102817: ARRAY
102818: PPUSH
102819: CALL_OW 120
// attacking := true ;
102823: LD_ADDR_VAR 0 29
102827: PUSH
102828: LD_INT 1
102830: ST_TO_ADDR
// continue ;
102831: GO 101006
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102833: LD_VAR 0 26
102837: PUSH
102838: LD_VAR 0 4
102842: PUSH
102843: LD_VAR 0 7
102847: ARRAY
102848: PPUSH
102849: CALL_OW 257
102853: PUSH
102854: LD_INT 1
102856: EQUAL
102857: AND
102858: PUSH
102859: LD_VAR 0 4
102863: PUSH
102864: LD_VAR 0 7
102868: ARRAY
102869: PPUSH
102870: CALL_OW 256
102874: PUSH
102875: LD_INT 800
102877: LESS
102878: AND
102879: PUSH
102880: LD_VAR 0 4
102884: PUSH
102885: LD_VAR 0 7
102889: ARRAY
102890: PPUSH
102891: CALL_OW 318
102895: NOT
102896: AND
102897: IFFALSE 102914
// ComCrawl ( group [ i ] ) ;
102899: LD_VAR 0 4
102903: PUSH
102904: LD_VAR 0 7
102908: ARRAY
102909: PPUSH
102910: CALL_OW 137
// if f_mines then
102914: LD_VAR 0 21
102918: IFFALSE 103161
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102920: LD_VAR 0 14
102924: PUSH
102925: LD_INT 1
102927: ARRAY
102928: PPUSH
102929: CALL_OW 247
102933: PUSH
102934: LD_INT 3
102936: EQUAL
102937: PUSH
102938: LD_VAR 0 14
102942: PUSH
102943: LD_INT 1
102945: ARRAY
102946: PUSH
102947: LD_VAR 0 27
102951: IN
102952: NOT
102953: AND
102954: IFFALSE 103161
// begin x := GetX ( tmp [ 1 ] ) ;
102956: LD_ADDR_VAR 0 10
102960: PUSH
102961: LD_VAR 0 14
102965: PUSH
102966: LD_INT 1
102968: ARRAY
102969: PPUSH
102970: CALL_OW 250
102974: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102975: LD_ADDR_VAR 0 11
102979: PUSH
102980: LD_VAR 0 14
102984: PUSH
102985: LD_INT 1
102987: ARRAY
102988: PPUSH
102989: CALL_OW 251
102993: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102994: LD_ADDR_VAR 0 12
102998: PUSH
102999: LD_VAR 0 4
103003: PUSH
103004: LD_VAR 0 7
103008: ARRAY
103009: PPUSH
103010: CALL 98892 0 1
103014: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
103015: LD_VAR 0 4
103019: PUSH
103020: LD_VAR 0 7
103024: ARRAY
103025: PPUSH
103026: LD_VAR 0 10
103030: PPUSH
103031: LD_VAR 0 11
103035: PPUSH
103036: LD_VAR 0 14
103040: PUSH
103041: LD_INT 1
103043: ARRAY
103044: PPUSH
103045: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
103049: LD_VAR 0 4
103053: PUSH
103054: LD_VAR 0 7
103058: ARRAY
103059: PPUSH
103060: LD_VAR 0 10
103064: PPUSH
103065: LD_VAR 0 12
103069: PPUSH
103070: LD_INT 7
103072: PPUSH
103073: CALL_OW 272
103077: PPUSH
103078: LD_VAR 0 11
103082: PPUSH
103083: LD_VAR 0 12
103087: PPUSH
103088: LD_INT 7
103090: PPUSH
103091: CALL_OW 273
103095: PPUSH
103096: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
103100: LD_VAR 0 4
103104: PUSH
103105: LD_VAR 0 7
103109: ARRAY
103110: PPUSH
103111: LD_INT 71
103113: PPUSH
103114: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
103118: LD_ADDR_VAR 0 27
103122: PUSH
103123: LD_VAR 0 27
103127: PPUSH
103128: LD_VAR 0 27
103132: PUSH
103133: LD_INT 1
103135: PLUS
103136: PPUSH
103137: LD_VAR 0 14
103141: PUSH
103142: LD_INT 1
103144: ARRAY
103145: PPUSH
103146: CALL_OW 1
103150: ST_TO_ADDR
// attacking := true ;
103151: LD_ADDR_VAR 0 29
103155: PUSH
103156: LD_INT 1
103158: ST_TO_ADDR
// continue ;
103159: GO 101006
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
103161: LD_VAR 0 4
103165: PUSH
103166: LD_VAR 0 7
103170: ARRAY
103171: PPUSH
103172: CALL_OW 257
103176: PUSH
103177: LD_INT 17
103179: EQUAL
103180: PUSH
103181: LD_VAR 0 4
103185: PUSH
103186: LD_VAR 0 7
103190: ARRAY
103191: PPUSH
103192: CALL_OW 110
103196: PUSH
103197: LD_INT 71
103199: EQUAL
103200: NOT
103201: AND
103202: IFFALSE 103348
// begin attacking := false ;
103204: LD_ADDR_VAR 0 29
103208: PUSH
103209: LD_INT 0
103211: ST_TO_ADDR
// k := 5 ;
103212: LD_ADDR_VAR 0 9
103216: PUSH
103217: LD_INT 5
103219: ST_TO_ADDR
// if tmp < k then
103220: LD_VAR 0 14
103224: PUSH
103225: LD_VAR 0 9
103229: LESS
103230: IFFALSE 103242
// k := tmp ;
103232: LD_ADDR_VAR 0 9
103236: PUSH
103237: LD_VAR 0 14
103241: ST_TO_ADDR
// for j = 1 to k do
103242: LD_ADDR_VAR 0 8
103246: PUSH
103247: DOUBLE
103248: LD_INT 1
103250: DEC
103251: ST_TO_ADDR
103252: LD_VAR 0 9
103256: PUSH
103257: FOR_TO
103258: IFFALSE 103346
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
103260: LD_VAR 0 14
103264: PUSH
103265: LD_VAR 0 8
103269: ARRAY
103270: PUSH
103271: LD_VAR 0 14
103275: PPUSH
103276: LD_INT 58
103278: PUSH
103279: EMPTY
103280: LIST
103281: PPUSH
103282: CALL_OW 72
103286: IN
103287: NOT
103288: IFFALSE 103344
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103290: LD_VAR 0 4
103294: PUSH
103295: LD_VAR 0 7
103299: ARRAY
103300: PPUSH
103301: LD_VAR 0 14
103305: PUSH
103306: LD_VAR 0 8
103310: ARRAY
103311: PPUSH
103312: CALL_OW 115
// attacking := true ;
103316: LD_ADDR_VAR 0 29
103320: PUSH
103321: LD_INT 1
103323: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
103324: LD_VAR 0 4
103328: PUSH
103329: LD_VAR 0 7
103333: ARRAY
103334: PPUSH
103335: LD_INT 71
103337: PPUSH
103338: CALL_OW 109
// continue ;
103342: GO 103257
// end ; end ;
103344: GO 103257
103346: POP
103347: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
103348: LD_VAR 0 4
103352: PUSH
103353: LD_VAR 0 7
103357: ARRAY
103358: PPUSH
103359: CALL_OW 257
103363: PUSH
103364: LD_INT 8
103366: EQUAL
103367: PUSH
103368: LD_VAR 0 4
103372: PUSH
103373: LD_VAR 0 7
103377: ARRAY
103378: PPUSH
103379: CALL_OW 264
103383: PUSH
103384: LD_INT 28
103386: PUSH
103387: LD_INT 45
103389: PUSH
103390: LD_INT 7
103392: PUSH
103393: LD_INT 47
103395: PUSH
103396: EMPTY
103397: LIST
103398: LIST
103399: LIST
103400: LIST
103401: IN
103402: OR
103403: IFFALSE 103659
// begin attacking := false ;
103405: LD_ADDR_VAR 0 29
103409: PUSH
103410: LD_INT 0
103412: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103413: LD_VAR 0 14
103417: PUSH
103418: LD_INT 1
103420: ARRAY
103421: PPUSH
103422: CALL_OW 266
103426: PUSH
103427: LD_INT 32
103429: PUSH
103430: LD_INT 31
103432: PUSH
103433: LD_INT 33
103435: PUSH
103436: LD_INT 4
103438: PUSH
103439: LD_INT 5
103441: PUSH
103442: EMPTY
103443: LIST
103444: LIST
103445: LIST
103446: LIST
103447: LIST
103448: IN
103449: IFFALSE 103635
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103451: LD_ADDR_VAR 0 9
103455: PUSH
103456: LD_VAR 0 14
103460: PUSH
103461: LD_INT 1
103463: ARRAY
103464: PPUSH
103465: CALL_OW 266
103469: PPUSH
103470: LD_VAR 0 14
103474: PUSH
103475: LD_INT 1
103477: ARRAY
103478: PPUSH
103479: CALL_OW 250
103483: PPUSH
103484: LD_VAR 0 14
103488: PUSH
103489: LD_INT 1
103491: ARRAY
103492: PPUSH
103493: CALL_OW 251
103497: PPUSH
103498: LD_VAR 0 14
103502: PUSH
103503: LD_INT 1
103505: ARRAY
103506: PPUSH
103507: CALL_OW 254
103511: PPUSH
103512: LD_VAR 0 14
103516: PUSH
103517: LD_INT 1
103519: ARRAY
103520: PPUSH
103521: CALL_OW 248
103525: PPUSH
103526: LD_INT 0
103528: PPUSH
103529: CALL 80262 0 6
103533: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103534: LD_ADDR_VAR 0 8
103538: PUSH
103539: LD_VAR 0 4
103543: PUSH
103544: LD_VAR 0 7
103548: ARRAY
103549: PPUSH
103550: LD_VAR 0 9
103554: PPUSH
103555: CALL 98932 0 2
103559: ST_TO_ADDR
// if j then
103560: LD_VAR 0 8
103564: IFFALSE 103633
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103566: LD_VAR 0 8
103570: PUSH
103571: LD_INT 1
103573: ARRAY
103574: PPUSH
103575: LD_VAR 0 8
103579: PUSH
103580: LD_INT 2
103582: ARRAY
103583: PPUSH
103584: CALL_OW 488
103588: IFFALSE 103633
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103590: LD_VAR 0 4
103594: PUSH
103595: LD_VAR 0 7
103599: ARRAY
103600: PPUSH
103601: LD_VAR 0 8
103605: PUSH
103606: LD_INT 1
103608: ARRAY
103609: PPUSH
103610: LD_VAR 0 8
103614: PUSH
103615: LD_INT 2
103617: ARRAY
103618: PPUSH
103619: CALL_OW 116
// attacking := true ;
103623: LD_ADDR_VAR 0 29
103627: PUSH
103628: LD_INT 1
103630: ST_TO_ADDR
// continue ;
103631: GO 101006
// end ; end else
103633: GO 103659
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103635: LD_VAR 0 4
103639: PUSH
103640: LD_VAR 0 7
103644: ARRAY
103645: PPUSH
103646: LD_VAR 0 14
103650: PUSH
103651: LD_INT 1
103653: ARRAY
103654: PPUSH
103655: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103659: LD_VAR 0 4
103663: PUSH
103664: LD_VAR 0 7
103668: ARRAY
103669: PPUSH
103670: CALL_OW 265
103674: PUSH
103675: LD_INT 11
103677: EQUAL
103678: IFFALSE 103956
// begin k := 10 ;
103680: LD_ADDR_VAR 0 9
103684: PUSH
103685: LD_INT 10
103687: ST_TO_ADDR
// x := 0 ;
103688: LD_ADDR_VAR 0 10
103692: PUSH
103693: LD_INT 0
103695: ST_TO_ADDR
// if tmp < k then
103696: LD_VAR 0 14
103700: PUSH
103701: LD_VAR 0 9
103705: LESS
103706: IFFALSE 103718
// k := tmp ;
103708: LD_ADDR_VAR 0 9
103712: PUSH
103713: LD_VAR 0 14
103717: ST_TO_ADDR
// for j = k downto 1 do
103718: LD_ADDR_VAR 0 8
103722: PUSH
103723: DOUBLE
103724: LD_VAR 0 9
103728: INC
103729: ST_TO_ADDR
103730: LD_INT 1
103732: PUSH
103733: FOR_DOWNTO
103734: IFFALSE 103809
// begin if GetType ( tmp [ j ] ) = unit_human then
103736: LD_VAR 0 14
103740: PUSH
103741: LD_VAR 0 8
103745: ARRAY
103746: PPUSH
103747: CALL_OW 247
103751: PUSH
103752: LD_INT 1
103754: EQUAL
103755: IFFALSE 103807
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103757: LD_VAR 0 4
103761: PUSH
103762: LD_VAR 0 7
103766: ARRAY
103767: PPUSH
103768: LD_VAR 0 14
103772: PUSH
103773: LD_VAR 0 8
103777: ARRAY
103778: PPUSH
103779: CALL 99203 0 2
// x := tmp [ j ] ;
103783: LD_ADDR_VAR 0 10
103787: PUSH
103788: LD_VAR 0 14
103792: PUSH
103793: LD_VAR 0 8
103797: ARRAY
103798: ST_TO_ADDR
// attacking := true ;
103799: LD_ADDR_VAR 0 29
103803: PUSH
103804: LD_INT 1
103806: ST_TO_ADDR
// end ; end ;
103807: GO 103733
103809: POP
103810: POP
// if not x then
103811: LD_VAR 0 10
103815: NOT
103816: IFFALSE 103956
// begin attacking := true ;
103818: LD_ADDR_VAR 0 29
103822: PUSH
103823: LD_INT 1
103825: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103826: LD_VAR 0 4
103830: PUSH
103831: LD_VAR 0 7
103835: ARRAY
103836: PPUSH
103837: CALL_OW 250
103841: PPUSH
103842: LD_VAR 0 4
103846: PUSH
103847: LD_VAR 0 7
103851: ARRAY
103852: PPUSH
103853: CALL_OW 251
103857: PPUSH
103858: CALL_OW 546
103862: PUSH
103863: LD_INT 2
103865: ARRAY
103866: PUSH
103867: LD_VAR 0 14
103871: PUSH
103872: LD_INT 1
103874: ARRAY
103875: PPUSH
103876: CALL_OW 250
103880: PPUSH
103881: LD_VAR 0 14
103885: PUSH
103886: LD_INT 1
103888: ARRAY
103889: PPUSH
103890: CALL_OW 251
103894: PPUSH
103895: CALL_OW 546
103899: PUSH
103900: LD_INT 2
103902: ARRAY
103903: EQUAL
103904: IFFALSE 103932
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103906: LD_VAR 0 4
103910: PUSH
103911: LD_VAR 0 7
103915: ARRAY
103916: PPUSH
103917: LD_VAR 0 14
103921: PUSH
103922: LD_INT 1
103924: ARRAY
103925: PPUSH
103926: CALL 99203 0 2
103930: GO 103956
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103932: LD_VAR 0 4
103936: PUSH
103937: LD_VAR 0 7
103941: ARRAY
103942: PPUSH
103943: LD_VAR 0 14
103947: PUSH
103948: LD_INT 1
103950: ARRAY
103951: PPUSH
103952: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103956: LD_VAR 0 4
103960: PUSH
103961: LD_VAR 0 7
103965: ARRAY
103966: PPUSH
103967: CALL_OW 264
103971: PUSH
103972: LD_INT 29
103974: EQUAL
103975: IFFALSE 104341
// begin if WantsToAttack ( group [ i ] ) in bombed then
103977: LD_VAR 0 4
103981: PUSH
103982: LD_VAR 0 7
103986: ARRAY
103987: PPUSH
103988: CALL_OW 319
103992: PUSH
103993: LD_VAR 0 28
103997: IN
103998: IFFALSE 104002
// continue ;
104000: GO 101006
// k := 8 ;
104002: LD_ADDR_VAR 0 9
104006: PUSH
104007: LD_INT 8
104009: ST_TO_ADDR
// x := 0 ;
104010: LD_ADDR_VAR 0 10
104014: PUSH
104015: LD_INT 0
104017: ST_TO_ADDR
// if tmp < k then
104018: LD_VAR 0 14
104022: PUSH
104023: LD_VAR 0 9
104027: LESS
104028: IFFALSE 104040
// k := tmp ;
104030: LD_ADDR_VAR 0 9
104034: PUSH
104035: LD_VAR 0 14
104039: ST_TO_ADDR
// for j = 1 to k do
104040: LD_ADDR_VAR 0 8
104044: PUSH
104045: DOUBLE
104046: LD_INT 1
104048: DEC
104049: ST_TO_ADDR
104050: LD_VAR 0 9
104054: PUSH
104055: FOR_TO
104056: IFFALSE 104188
// begin if GetType ( tmp [ j ] ) = unit_building then
104058: LD_VAR 0 14
104062: PUSH
104063: LD_VAR 0 8
104067: ARRAY
104068: PPUSH
104069: CALL_OW 247
104073: PUSH
104074: LD_INT 3
104076: EQUAL
104077: IFFALSE 104186
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
104079: LD_VAR 0 14
104083: PUSH
104084: LD_VAR 0 8
104088: ARRAY
104089: PUSH
104090: LD_VAR 0 28
104094: IN
104095: NOT
104096: PUSH
104097: LD_VAR 0 14
104101: PUSH
104102: LD_VAR 0 8
104106: ARRAY
104107: PPUSH
104108: CALL_OW 313
104112: AND
104113: IFFALSE 104186
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104115: LD_VAR 0 4
104119: PUSH
104120: LD_VAR 0 7
104124: ARRAY
104125: PPUSH
104126: LD_VAR 0 14
104130: PUSH
104131: LD_VAR 0 8
104135: ARRAY
104136: PPUSH
104137: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
104141: LD_ADDR_VAR 0 28
104145: PUSH
104146: LD_VAR 0 28
104150: PPUSH
104151: LD_VAR 0 28
104155: PUSH
104156: LD_INT 1
104158: PLUS
104159: PPUSH
104160: LD_VAR 0 14
104164: PUSH
104165: LD_VAR 0 8
104169: ARRAY
104170: PPUSH
104171: CALL_OW 1
104175: ST_TO_ADDR
// attacking := true ;
104176: LD_ADDR_VAR 0 29
104180: PUSH
104181: LD_INT 1
104183: ST_TO_ADDR
// break ;
104184: GO 104188
// end ; end ;
104186: GO 104055
104188: POP
104189: POP
// if not attacking and f_attack_depot then
104190: LD_VAR 0 29
104194: NOT
104195: PUSH
104196: LD_VAR 0 25
104200: AND
104201: IFFALSE 104296
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104203: LD_ADDR_VAR 0 13
104207: PUSH
104208: LD_VAR 0 14
104212: PPUSH
104213: LD_INT 2
104215: PUSH
104216: LD_INT 30
104218: PUSH
104219: LD_INT 0
104221: PUSH
104222: EMPTY
104223: LIST
104224: LIST
104225: PUSH
104226: LD_INT 30
104228: PUSH
104229: LD_INT 1
104231: PUSH
104232: EMPTY
104233: LIST
104234: LIST
104235: PUSH
104236: EMPTY
104237: LIST
104238: LIST
104239: LIST
104240: PPUSH
104241: CALL_OW 72
104245: ST_TO_ADDR
// if z then
104246: LD_VAR 0 13
104250: IFFALSE 104296
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
104252: LD_VAR 0 4
104256: PUSH
104257: LD_VAR 0 7
104261: ARRAY
104262: PPUSH
104263: LD_VAR 0 13
104267: PPUSH
104268: LD_VAR 0 4
104272: PUSH
104273: LD_VAR 0 7
104277: ARRAY
104278: PPUSH
104279: CALL_OW 74
104283: PPUSH
104284: CALL_OW 115
// attacking := true ;
104288: LD_ADDR_VAR 0 29
104292: PUSH
104293: LD_INT 1
104295: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
104296: LD_VAR 0 4
104300: PUSH
104301: LD_VAR 0 7
104305: ARRAY
104306: PPUSH
104307: CALL_OW 256
104311: PUSH
104312: LD_INT 500
104314: LESS
104315: IFFALSE 104341
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104317: LD_VAR 0 4
104321: PUSH
104322: LD_VAR 0 7
104326: ARRAY
104327: PPUSH
104328: LD_VAR 0 14
104332: PUSH
104333: LD_INT 1
104335: ARRAY
104336: PPUSH
104337: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
104341: LD_VAR 0 4
104345: PUSH
104346: LD_VAR 0 7
104350: ARRAY
104351: PPUSH
104352: CALL_OW 264
104356: PUSH
104357: LD_INT 49
104359: EQUAL
104360: IFFALSE 104481
// begin if not HasTask ( group [ i ] ) then
104362: LD_VAR 0 4
104366: PUSH
104367: LD_VAR 0 7
104371: ARRAY
104372: PPUSH
104373: CALL_OW 314
104377: NOT
104378: IFFALSE 104481
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
104380: LD_ADDR_VAR 0 9
104384: PUSH
104385: LD_INT 81
104387: PUSH
104388: LD_VAR 0 4
104392: PUSH
104393: LD_VAR 0 7
104397: ARRAY
104398: PPUSH
104399: CALL_OW 255
104403: PUSH
104404: EMPTY
104405: LIST
104406: LIST
104407: PPUSH
104408: CALL_OW 69
104412: PPUSH
104413: LD_VAR 0 4
104417: PUSH
104418: LD_VAR 0 7
104422: ARRAY
104423: PPUSH
104424: CALL_OW 74
104428: ST_TO_ADDR
// if k then
104429: LD_VAR 0 9
104433: IFFALSE 104481
// if GetDistUnits ( group [ i ] , k ) > 10 then
104435: LD_VAR 0 4
104439: PUSH
104440: LD_VAR 0 7
104444: ARRAY
104445: PPUSH
104446: LD_VAR 0 9
104450: PPUSH
104451: CALL_OW 296
104455: PUSH
104456: LD_INT 10
104458: GREATER
104459: IFFALSE 104481
// ComMoveUnit ( group [ i ] , k ) ;
104461: LD_VAR 0 4
104465: PUSH
104466: LD_VAR 0 7
104470: ARRAY
104471: PPUSH
104472: LD_VAR 0 9
104476: PPUSH
104477: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104481: LD_VAR 0 4
104485: PUSH
104486: LD_VAR 0 7
104490: ARRAY
104491: PPUSH
104492: CALL_OW 256
104496: PUSH
104497: LD_INT 250
104499: LESS
104500: PUSH
104501: LD_VAR 0 4
104505: PUSH
104506: LD_VAR 0 7
104510: ARRAY
104511: PUSH
104512: LD_INT 21
104514: PUSH
104515: LD_INT 2
104517: PUSH
104518: EMPTY
104519: LIST
104520: LIST
104521: PUSH
104522: LD_INT 23
104524: PUSH
104525: LD_INT 2
104527: PUSH
104528: EMPTY
104529: LIST
104530: LIST
104531: PUSH
104532: EMPTY
104533: LIST
104534: LIST
104535: PPUSH
104536: CALL_OW 69
104540: IN
104541: AND
104542: IFFALSE 104667
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104544: LD_ADDR_VAR 0 9
104548: PUSH
104549: LD_OWVAR 3
104553: PUSH
104554: LD_VAR 0 4
104558: PUSH
104559: LD_VAR 0 7
104563: ARRAY
104564: DIFF
104565: PPUSH
104566: LD_VAR 0 4
104570: PUSH
104571: LD_VAR 0 7
104575: ARRAY
104576: PPUSH
104577: CALL_OW 74
104581: ST_TO_ADDR
// if not k then
104582: LD_VAR 0 9
104586: NOT
104587: IFFALSE 104591
// continue ;
104589: GO 101006
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104591: LD_VAR 0 9
104595: PUSH
104596: LD_INT 81
104598: PUSH
104599: LD_VAR 0 4
104603: PUSH
104604: LD_VAR 0 7
104608: ARRAY
104609: PPUSH
104610: CALL_OW 255
104614: PUSH
104615: EMPTY
104616: LIST
104617: LIST
104618: PPUSH
104619: CALL_OW 69
104623: IN
104624: PUSH
104625: LD_VAR 0 9
104629: PPUSH
104630: LD_VAR 0 4
104634: PUSH
104635: LD_VAR 0 7
104639: ARRAY
104640: PPUSH
104641: CALL_OW 296
104645: PUSH
104646: LD_INT 5
104648: LESS
104649: AND
104650: IFFALSE 104667
// ComAutodestruct ( group [ i ] ) ;
104652: LD_VAR 0 4
104656: PUSH
104657: LD_VAR 0 7
104661: ARRAY
104662: PPUSH
104663: CALL 99101 0 1
// end ; if f_attack_depot then
104667: LD_VAR 0 25
104671: IFFALSE 104783
// begin k := 6 ;
104673: LD_ADDR_VAR 0 9
104677: PUSH
104678: LD_INT 6
104680: ST_TO_ADDR
// if tmp < k then
104681: LD_VAR 0 14
104685: PUSH
104686: LD_VAR 0 9
104690: LESS
104691: IFFALSE 104703
// k := tmp ;
104693: LD_ADDR_VAR 0 9
104697: PUSH
104698: LD_VAR 0 14
104702: ST_TO_ADDR
// for j = 1 to k do
104703: LD_ADDR_VAR 0 8
104707: PUSH
104708: DOUBLE
104709: LD_INT 1
104711: DEC
104712: ST_TO_ADDR
104713: LD_VAR 0 9
104717: PUSH
104718: FOR_TO
104719: IFFALSE 104781
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104721: LD_VAR 0 8
104725: PPUSH
104726: CALL_OW 266
104730: PUSH
104731: LD_INT 0
104733: PUSH
104734: LD_INT 1
104736: PUSH
104737: EMPTY
104738: LIST
104739: LIST
104740: IN
104741: IFFALSE 104779
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104743: LD_VAR 0 4
104747: PUSH
104748: LD_VAR 0 7
104752: ARRAY
104753: PPUSH
104754: LD_VAR 0 14
104758: PUSH
104759: LD_VAR 0 8
104763: ARRAY
104764: PPUSH
104765: CALL_OW 115
// attacking := true ;
104769: LD_ADDR_VAR 0 29
104773: PUSH
104774: LD_INT 1
104776: ST_TO_ADDR
// break ;
104777: GO 104781
// end ;
104779: GO 104718
104781: POP
104782: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104783: LD_VAR 0 4
104787: PUSH
104788: LD_VAR 0 7
104792: ARRAY
104793: PPUSH
104794: CALL_OW 302
104798: PUSH
104799: LD_VAR 0 29
104803: NOT
104804: AND
104805: IFFALSE 105127
// begin if GetTag ( group [ i ] ) = 71 then
104807: LD_VAR 0 4
104811: PUSH
104812: LD_VAR 0 7
104816: ARRAY
104817: PPUSH
104818: CALL_OW 110
104822: PUSH
104823: LD_INT 71
104825: EQUAL
104826: IFFALSE 104867
// begin if HasTask ( group [ i ] ) then
104828: LD_VAR 0 4
104832: PUSH
104833: LD_VAR 0 7
104837: ARRAY
104838: PPUSH
104839: CALL_OW 314
104843: IFFALSE 104849
// continue else
104845: GO 101006
104847: GO 104867
// SetTag ( group [ i ] , 0 ) ;
104849: LD_VAR 0 4
104853: PUSH
104854: LD_VAR 0 7
104858: ARRAY
104859: PPUSH
104860: LD_INT 0
104862: PPUSH
104863: CALL_OW 109
// end ; k := 8 ;
104867: LD_ADDR_VAR 0 9
104871: PUSH
104872: LD_INT 8
104874: ST_TO_ADDR
// x := 0 ;
104875: LD_ADDR_VAR 0 10
104879: PUSH
104880: LD_INT 0
104882: ST_TO_ADDR
// if tmp < k then
104883: LD_VAR 0 14
104887: PUSH
104888: LD_VAR 0 9
104892: LESS
104893: IFFALSE 104905
// k := tmp ;
104895: LD_ADDR_VAR 0 9
104899: PUSH
104900: LD_VAR 0 14
104904: ST_TO_ADDR
// for j = 1 to k do
104905: LD_ADDR_VAR 0 8
104909: PUSH
104910: DOUBLE
104911: LD_INT 1
104913: DEC
104914: ST_TO_ADDR
104915: LD_VAR 0 9
104919: PUSH
104920: FOR_TO
104921: IFFALSE 105019
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104923: LD_VAR 0 14
104927: PUSH
104928: LD_VAR 0 8
104932: ARRAY
104933: PPUSH
104934: CALL_OW 247
104938: PUSH
104939: LD_INT 1
104941: EQUAL
104942: PUSH
104943: LD_VAR 0 14
104947: PUSH
104948: LD_VAR 0 8
104952: ARRAY
104953: PPUSH
104954: CALL_OW 256
104958: PUSH
104959: LD_INT 250
104961: LESS
104962: PUSH
104963: LD_VAR 0 20
104967: AND
104968: PUSH
104969: LD_VAR 0 20
104973: NOT
104974: PUSH
104975: LD_VAR 0 14
104979: PUSH
104980: LD_VAR 0 8
104984: ARRAY
104985: PPUSH
104986: CALL_OW 256
104990: PUSH
104991: LD_INT 250
104993: GREATEREQUAL
104994: AND
104995: OR
104996: AND
104997: IFFALSE 105017
// begin x := tmp [ j ] ;
104999: LD_ADDR_VAR 0 10
105003: PUSH
105004: LD_VAR 0 14
105008: PUSH
105009: LD_VAR 0 8
105013: ARRAY
105014: ST_TO_ADDR
// break ;
105015: GO 105019
// end ;
105017: GO 104920
105019: POP
105020: POP
// if x then
105021: LD_VAR 0 10
105025: IFFALSE 105049
// ComAttackUnit ( group [ i ] , x ) else
105027: LD_VAR 0 4
105031: PUSH
105032: LD_VAR 0 7
105036: ARRAY
105037: PPUSH
105038: LD_VAR 0 10
105042: PPUSH
105043: CALL_OW 115
105047: GO 105073
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105049: LD_VAR 0 4
105053: PUSH
105054: LD_VAR 0 7
105058: ARRAY
105059: PPUSH
105060: LD_VAR 0 14
105064: PUSH
105065: LD_INT 1
105067: ARRAY
105068: PPUSH
105069: CALL_OW 115
// if not HasTask ( group [ i ] ) then
105073: LD_VAR 0 4
105077: PUSH
105078: LD_VAR 0 7
105082: ARRAY
105083: PPUSH
105084: CALL_OW 314
105088: NOT
105089: IFFALSE 105127
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
105091: LD_VAR 0 4
105095: PUSH
105096: LD_VAR 0 7
105100: ARRAY
105101: PPUSH
105102: LD_VAR 0 14
105106: PPUSH
105107: LD_VAR 0 4
105111: PUSH
105112: LD_VAR 0 7
105116: ARRAY
105117: PPUSH
105118: CALL_OW 74
105122: PPUSH
105123: CALL_OW 115
// end ; end ; end ;
105127: GO 101006
105129: POP
105130: POP
// wait ( 0 0$2 ) ;
105131: LD_INT 70
105133: PPUSH
105134: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
105138: LD_VAR 0 4
105142: NOT
105143: PUSH
105144: LD_VAR 0 4
105148: PUSH
105149: EMPTY
105150: EQUAL
105151: OR
105152: PUSH
105153: LD_INT 81
105155: PUSH
105156: LD_VAR 0 35
105160: PUSH
105161: EMPTY
105162: LIST
105163: LIST
105164: PPUSH
105165: CALL_OW 69
105169: NOT
105170: OR
105171: IFFALSE 100991
// end ;
105173: LD_VAR 0 2
105177: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105178: LD_INT 0
105180: PPUSH
105181: PPUSH
105182: PPUSH
105183: PPUSH
// if not base_units then
105184: LD_VAR 0 1
105188: NOT
105189: IFFALSE 105193
// exit ;
105191: GO 105280
// result := false ;
105193: LD_ADDR_VAR 0 2
105197: PUSH
105198: LD_INT 0
105200: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105201: LD_ADDR_VAR 0 5
105205: PUSH
105206: LD_VAR 0 1
105210: PPUSH
105211: LD_INT 21
105213: PUSH
105214: LD_INT 3
105216: PUSH
105217: EMPTY
105218: LIST
105219: LIST
105220: PPUSH
105221: CALL_OW 72
105225: ST_TO_ADDR
// if not tmp then
105226: LD_VAR 0 5
105230: NOT
105231: IFFALSE 105235
// exit ;
105233: GO 105280
// for i in tmp do
105235: LD_ADDR_VAR 0 3
105239: PUSH
105240: LD_VAR 0 5
105244: PUSH
105245: FOR_IN
105246: IFFALSE 105278
// begin result := EnemyInRange ( i , 22 ) ;
105248: LD_ADDR_VAR 0 2
105252: PUSH
105253: LD_VAR 0 3
105257: PPUSH
105258: LD_INT 22
105260: PPUSH
105261: CALL 98807 0 2
105265: ST_TO_ADDR
// if result then
105266: LD_VAR 0 2
105270: IFFALSE 105276
// exit ;
105272: POP
105273: POP
105274: GO 105280
// end ;
105276: GO 105245
105278: POP
105279: POP
// end ;
105280: LD_VAR 0 2
105284: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
105285: LD_INT 0
105287: PPUSH
105288: PPUSH
// if not units then
105289: LD_VAR 0 1
105293: NOT
105294: IFFALSE 105298
// exit ;
105296: GO 105368
// result := [ ] ;
105298: LD_ADDR_VAR 0 3
105302: PUSH
105303: EMPTY
105304: ST_TO_ADDR
// for i in units do
105305: LD_ADDR_VAR 0 4
105309: PUSH
105310: LD_VAR 0 1
105314: PUSH
105315: FOR_IN
105316: IFFALSE 105366
// if GetTag ( i ) = tag then
105318: LD_VAR 0 4
105322: PPUSH
105323: CALL_OW 110
105327: PUSH
105328: LD_VAR 0 2
105332: EQUAL
105333: IFFALSE 105364
// result := Insert ( result , result + 1 , i ) ;
105335: LD_ADDR_VAR 0 3
105339: PUSH
105340: LD_VAR 0 3
105344: PPUSH
105345: LD_VAR 0 3
105349: PUSH
105350: LD_INT 1
105352: PLUS
105353: PPUSH
105354: LD_VAR 0 4
105358: PPUSH
105359: CALL_OW 2
105363: ST_TO_ADDR
105364: GO 105315
105366: POP
105367: POP
// end ;
105368: LD_VAR 0 3
105372: RET
// export function IsDriver ( un ) ; begin
105373: LD_INT 0
105375: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105376: LD_ADDR_VAR 0 2
105380: PUSH
105381: LD_VAR 0 1
105385: PUSH
105386: LD_INT 55
105388: PUSH
105389: EMPTY
105390: LIST
105391: PPUSH
105392: CALL_OW 69
105396: IN
105397: ST_TO_ADDR
// end ;
105398: LD_VAR 0 2
105402: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105403: LD_INT 0
105405: PPUSH
105406: PPUSH
// list := [ ] ;
105407: LD_ADDR_VAR 0 5
105411: PUSH
105412: EMPTY
105413: ST_TO_ADDR
// case d of 0 :
105414: LD_VAR 0 3
105418: PUSH
105419: LD_INT 0
105421: DOUBLE
105422: EQUAL
105423: IFTRUE 105427
105425: GO 105560
105427: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105428: LD_ADDR_VAR 0 5
105432: PUSH
105433: LD_VAR 0 1
105437: PUSH
105438: LD_INT 4
105440: MINUS
105441: PUSH
105442: LD_VAR 0 2
105446: PUSH
105447: LD_INT 4
105449: MINUS
105450: PUSH
105451: LD_INT 2
105453: PUSH
105454: EMPTY
105455: LIST
105456: LIST
105457: LIST
105458: PUSH
105459: LD_VAR 0 1
105463: PUSH
105464: LD_INT 3
105466: MINUS
105467: PUSH
105468: LD_VAR 0 2
105472: PUSH
105473: LD_INT 1
105475: PUSH
105476: EMPTY
105477: LIST
105478: LIST
105479: LIST
105480: PUSH
105481: LD_VAR 0 1
105485: PUSH
105486: LD_INT 4
105488: PLUS
105489: PUSH
105490: LD_VAR 0 2
105494: PUSH
105495: LD_INT 4
105497: PUSH
105498: EMPTY
105499: LIST
105500: LIST
105501: LIST
105502: PUSH
105503: LD_VAR 0 1
105507: PUSH
105508: LD_INT 3
105510: PLUS
105511: PUSH
105512: LD_VAR 0 2
105516: PUSH
105517: LD_INT 3
105519: PLUS
105520: PUSH
105521: LD_INT 5
105523: PUSH
105524: EMPTY
105525: LIST
105526: LIST
105527: LIST
105528: PUSH
105529: LD_VAR 0 1
105533: PUSH
105534: LD_VAR 0 2
105538: PUSH
105539: LD_INT 4
105541: PLUS
105542: PUSH
105543: LD_INT 0
105545: PUSH
105546: EMPTY
105547: LIST
105548: LIST
105549: LIST
105550: PUSH
105551: EMPTY
105552: LIST
105553: LIST
105554: LIST
105555: LIST
105556: LIST
105557: ST_TO_ADDR
// end ; 1 :
105558: GO 106258
105560: LD_INT 1
105562: DOUBLE
105563: EQUAL
105564: IFTRUE 105568
105566: GO 105701
105568: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105569: LD_ADDR_VAR 0 5
105573: PUSH
105574: LD_VAR 0 1
105578: PUSH
105579: LD_VAR 0 2
105583: PUSH
105584: LD_INT 4
105586: MINUS
105587: PUSH
105588: LD_INT 3
105590: PUSH
105591: EMPTY
105592: LIST
105593: LIST
105594: LIST
105595: PUSH
105596: LD_VAR 0 1
105600: PUSH
105601: LD_INT 3
105603: MINUS
105604: PUSH
105605: LD_VAR 0 2
105609: PUSH
105610: LD_INT 3
105612: MINUS
105613: PUSH
105614: LD_INT 2
105616: PUSH
105617: EMPTY
105618: LIST
105619: LIST
105620: LIST
105621: PUSH
105622: LD_VAR 0 1
105626: PUSH
105627: LD_INT 4
105629: MINUS
105630: PUSH
105631: LD_VAR 0 2
105635: PUSH
105636: LD_INT 1
105638: PUSH
105639: EMPTY
105640: LIST
105641: LIST
105642: LIST
105643: PUSH
105644: LD_VAR 0 1
105648: PUSH
105649: LD_VAR 0 2
105653: PUSH
105654: LD_INT 3
105656: PLUS
105657: PUSH
105658: LD_INT 0
105660: PUSH
105661: EMPTY
105662: LIST
105663: LIST
105664: LIST
105665: PUSH
105666: LD_VAR 0 1
105670: PUSH
105671: LD_INT 4
105673: PLUS
105674: PUSH
105675: LD_VAR 0 2
105679: PUSH
105680: LD_INT 4
105682: PLUS
105683: PUSH
105684: LD_INT 5
105686: PUSH
105687: EMPTY
105688: LIST
105689: LIST
105690: LIST
105691: PUSH
105692: EMPTY
105693: LIST
105694: LIST
105695: LIST
105696: LIST
105697: LIST
105698: ST_TO_ADDR
// end ; 2 :
105699: GO 106258
105701: LD_INT 2
105703: DOUBLE
105704: EQUAL
105705: IFTRUE 105709
105707: GO 105838
105709: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105710: LD_ADDR_VAR 0 5
105714: PUSH
105715: LD_VAR 0 1
105719: PUSH
105720: LD_VAR 0 2
105724: PUSH
105725: LD_INT 3
105727: MINUS
105728: PUSH
105729: LD_INT 3
105731: PUSH
105732: EMPTY
105733: LIST
105734: LIST
105735: LIST
105736: PUSH
105737: LD_VAR 0 1
105741: PUSH
105742: LD_INT 4
105744: PLUS
105745: PUSH
105746: LD_VAR 0 2
105750: PUSH
105751: LD_INT 4
105753: PUSH
105754: EMPTY
105755: LIST
105756: LIST
105757: LIST
105758: PUSH
105759: LD_VAR 0 1
105763: PUSH
105764: LD_VAR 0 2
105768: PUSH
105769: LD_INT 4
105771: PLUS
105772: PUSH
105773: LD_INT 0
105775: PUSH
105776: EMPTY
105777: LIST
105778: LIST
105779: LIST
105780: PUSH
105781: LD_VAR 0 1
105785: PUSH
105786: LD_INT 3
105788: MINUS
105789: PUSH
105790: LD_VAR 0 2
105794: PUSH
105795: LD_INT 1
105797: PUSH
105798: EMPTY
105799: LIST
105800: LIST
105801: LIST
105802: PUSH
105803: LD_VAR 0 1
105807: PUSH
105808: LD_INT 4
105810: MINUS
105811: PUSH
105812: LD_VAR 0 2
105816: PUSH
105817: LD_INT 4
105819: MINUS
105820: PUSH
105821: LD_INT 2
105823: PUSH
105824: EMPTY
105825: LIST
105826: LIST
105827: LIST
105828: PUSH
105829: EMPTY
105830: LIST
105831: LIST
105832: LIST
105833: LIST
105834: LIST
105835: ST_TO_ADDR
// end ; 3 :
105836: GO 106258
105838: LD_INT 3
105840: DOUBLE
105841: EQUAL
105842: IFTRUE 105846
105844: GO 105979
105846: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105847: LD_ADDR_VAR 0 5
105851: PUSH
105852: LD_VAR 0 1
105856: PUSH
105857: LD_INT 3
105859: PLUS
105860: PUSH
105861: LD_VAR 0 2
105865: PUSH
105866: LD_INT 4
105868: PUSH
105869: EMPTY
105870: LIST
105871: LIST
105872: LIST
105873: PUSH
105874: LD_VAR 0 1
105878: PUSH
105879: LD_INT 4
105881: PLUS
105882: PUSH
105883: LD_VAR 0 2
105887: PUSH
105888: LD_INT 4
105890: PLUS
105891: PUSH
105892: LD_INT 5
105894: PUSH
105895: EMPTY
105896: LIST
105897: LIST
105898: LIST
105899: PUSH
105900: LD_VAR 0 1
105904: PUSH
105905: LD_INT 4
105907: MINUS
105908: PUSH
105909: LD_VAR 0 2
105913: PUSH
105914: LD_INT 1
105916: PUSH
105917: EMPTY
105918: LIST
105919: LIST
105920: LIST
105921: PUSH
105922: LD_VAR 0 1
105926: PUSH
105927: LD_VAR 0 2
105931: PUSH
105932: LD_INT 4
105934: MINUS
105935: PUSH
105936: LD_INT 3
105938: PUSH
105939: EMPTY
105940: LIST
105941: LIST
105942: LIST
105943: PUSH
105944: LD_VAR 0 1
105948: PUSH
105949: LD_INT 3
105951: MINUS
105952: PUSH
105953: LD_VAR 0 2
105957: PUSH
105958: LD_INT 3
105960: MINUS
105961: PUSH
105962: LD_INT 2
105964: PUSH
105965: EMPTY
105966: LIST
105967: LIST
105968: LIST
105969: PUSH
105970: EMPTY
105971: LIST
105972: LIST
105973: LIST
105974: LIST
105975: LIST
105976: ST_TO_ADDR
// end ; 4 :
105977: GO 106258
105979: LD_INT 4
105981: DOUBLE
105982: EQUAL
105983: IFTRUE 105987
105985: GO 106120
105987: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105988: LD_ADDR_VAR 0 5
105992: PUSH
105993: LD_VAR 0 1
105997: PUSH
105998: LD_VAR 0 2
106002: PUSH
106003: LD_INT 4
106005: PLUS
106006: PUSH
106007: LD_INT 0
106009: PUSH
106010: EMPTY
106011: LIST
106012: LIST
106013: LIST
106014: PUSH
106015: LD_VAR 0 1
106019: PUSH
106020: LD_INT 3
106022: PLUS
106023: PUSH
106024: LD_VAR 0 2
106028: PUSH
106029: LD_INT 3
106031: PLUS
106032: PUSH
106033: LD_INT 5
106035: PUSH
106036: EMPTY
106037: LIST
106038: LIST
106039: LIST
106040: PUSH
106041: LD_VAR 0 1
106045: PUSH
106046: LD_INT 4
106048: PLUS
106049: PUSH
106050: LD_VAR 0 2
106054: PUSH
106055: LD_INT 4
106057: PUSH
106058: EMPTY
106059: LIST
106060: LIST
106061: LIST
106062: PUSH
106063: LD_VAR 0 1
106067: PUSH
106068: LD_VAR 0 2
106072: PUSH
106073: LD_INT 3
106075: MINUS
106076: PUSH
106077: LD_INT 3
106079: PUSH
106080: EMPTY
106081: LIST
106082: LIST
106083: LIST
106084: PUSH
106085: LD_VAR 0 1
106089: PUSH
106090: LD_INT 4
106092: MINUS
106093: PUSH
106094: LD_VAR 0 2
106098: PUSH
106099: LD_INT 4
106101: MINUS
106102: PUSH
106103: LD_INT 2
106105: PUSH
106106: EMPTY
106107: LIST
106108: LIST
106109: LIST
106110: PUSH
106111: EMPTY
106112: LIST
106113: LIST
106114: LIST
106115: LIST
106116: LIST
106117: ST_TO_ADDR
// end ; 5 :
106118: GO 106258
106120: LD_INT 5
106122: DOUBLE
106123: EQUAL
106124: IFTRUE 106128
106126: GO 106257
106128: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106129: LD_ADDR_VAR 0 5
106133: PUSH
106134: LD_VAR 0 1
106138: PUSH
106139: LD_INT 4
106141: MINUS
106142: PUSH
106143: LD_VAR 0 2
106147: PUSH
106148: LD_INT 1
106150: PUSH
106151: EMPTY
106152: LIST
106153: LIST
106154: LIST
106155: PUSH
106156: LD_VAR 0 1
106160: PUSH
106161: LD_VAR 0 2
106165: PUSH
106166: LD_INT 4
106168: MINUS
106169: PUSH
106170: LD_INT 3
106172: PUSH
106173: EMPTY
106174: LIST
106175: LIST
106176: LIST
106177: PUSH
106178: LD_VAR 0 1
106182: PUSH
106183: LD_INT 4
106185: PLUS
106186: PUSH
106187: LD_VAR 0 2
106191: PUSH
106192: LD_INT 4
106194: PLUS
106195: PUSH
106196: LD_INT 5
106198: PUSH
106199: EMPTY
106200: LIST
106201: LIST
106202: LIST
106203: PUSH
106204: LD_VAR 0 1
106208: PUSH
106209: LD_INT 3
106211: PLUS
106212: PUSH
106213: LD_VAR 0 2
106217: PUSH
106218: LD_INT 4
106220: PUSH
106221: EMPTY
106222: LIST
106223: LIST
106224: LIST
106225: PUSH
106226: LD_VAR 0 1
106230: PUSH
106231: LD_VAR 0 2
106235: PUSH
106236: LD_INT 3
106238: PLUS
106239: PUSH
106240: LD_INT 0
106242: PUSH
106243: EMPTY
106244: LIST
106245: LIST
106246: LIST
106247: PUSH
106248: EMPTY
106249: LIST
106250: LIST
106251: LIST
106252: LIST
106253: LIST
106254: ST_TO_ADDR
// end ; end ;
106255: GO 106258
106257: POP
// result := list ;
106258: LD_ADDR_VAR 0 4
106262: PUSH
106263: LD_VAR 0 5
106267: ST_TO_ADDR
// end ;
106268: LD_VAR 0 4
106272: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106273: LD_INT 0
106275: PPUSH
106276: PPUSH
106277: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106278: LD_VAR 0 1
106282: NOT
106283: PUSH
106284: LD_VAR 0 2
106288: PUSH
106289: LD_INT 1
106291: PUSH
106292: LD_INT 2
106294: PUSH
106295: LD_INT 3
106297: PUSH
106298: LD_INT 4
106300: PUSH
106301: EMPTY
106302: LIST
106303: LIST
106304: LIST
106305: LIST
106306: IN
106307: NOT
106308: OR
106309: IFFALSE 106313
// exit ;
106311: GO 106405
// tmp := [ ] ;
106313: LD_ADDR_VAR 0 5
106317: PUSH
106318: EMPTY
106319: ST_TO_ADDR
// for i in units do
106320: LD_ADDR_VAR 0 4
106324: PUSH
106325: LD_VAR 0 1
106329: PUSH
106330: FOR_IN
106331: IFFALSE 106374
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
106333: LD_ADDR_VAR 0 5
106337: PUSH
106338: LD_VAR 0 5
106342: PPUSH
106343: LD_VAR 0 5
106347: PUSH
106348: LD_INT 1
106350: PLUS
106351: PPUSH
106352: LD_VAR 0 4
106356: PPUSH
106357: LD_VAR 0 2
106361: PPUSH
106362: CALL_OW 259
106366: PPUSH
106367: CALL_OW 2
106371: ST_TO_ADDR
106372: GO 106330
106374: POP
106375: POP
// if not tmp then
106376: LD_VAR 0 5
106380: NOT
106381: IFFALSE 106385
// exit ;
106383: GO 106405
// result := SortListByListDesc ( units , tmp ) ;
106385: LD_ADDR_VAR 0 3
106389: PUSH
106390: LD_VAR 0 1
106394: PPUSH
106395: LD_VAR 0 5
106399: PPUSH
106400: CALL_OW 77
106404: ST_TO_ADDR
// end ;
106405: LD_VAR 0 3
106409: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106410: LD_INT 0
106412: PPUSH
106413: PPUSH
106414: PPUSH
// x := GetX ( building ) ;
106415: LD_ADDR_VAR 0 4
106419: PUSH
106420: LD_VAR 0 2
106424: PPUSH
106425: CALL_OW 250
106429: ST_TO_ADDR
// y := GetY ( building ) ;
106430: LD_ADDR_VAR 0 5
106434: PUSH
106435: LD_VAR 0 2
106439: PPUSH
106440: CALL_OW 251
106444: ST_TO_ADDR
// if GetTaskList ( unit ) then
106445: LD_VAR 0 1
106449: PPUSH
106450: CALL_OW 437
106454: IFFALSE 106549
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106456: LD_STRING e
106458: PUSH
106459: LD_VAR 0 1
106463: PPUSH
106464: CALL_OW 437
106468: PUSH
106469: LD_INT 1
106471: ARRAY
106472: PUSH
106473: LD_INT 1
106475: ARRAY
106476: EQUAL
106477: PUSH
106478: LD_VAR 0 4
106482: PUSH
106483: LD_VAR 0 1
106487: PPUSH
106488: CALL_OW 437
106492: PUSH
106493: LD_INT 1
106495: ARRAY
106496: PUSH
106497: LD_INT 2
106499: ARRAY
106500: EQUAL
106501: AND
106502: PUSH
106503: LD_VAR 0 5
106507: PUSH
106508: LD_VAR 0 1
106512: PPUSH
106513: CALL_OW 437
106517: PUSH
106518: LD_INT 1
106520: ARRAY
106521: PUSH
106522: LD_INT 3
106524: ARRAY
106525: EQUAL
106526: AND
106527: IFFALSE 106539
// result := true else
106529: LD_ADDR_VAR 0 3
106533: PUSH
106534: LD_INT 1
106536: ST_TO_ADDR
106537: GO 106547
// result := false ;
106539: LD_ADDR_VAR 0 3
106543: PUSH
106544: LD_INT 0
106546: ST_TO_ADDR
// end else
106547: GO 106557
// result := false ;
106549: LD_ADDR_VAR 0 3
106553: PUSH
106554: LD_INT 0
106556: ST_TO_ADDR
// end ;
106557: LD_VAR 0 3
106561: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106562: LD_INT 0
106564: PPUSH
106565: PPUSH
106566: PPUSH
106567: PPUSH
// if not unit or not area then
106568: LD_VAR 0 1
106572: NOT
106573: PUSH
106574: LD_VAR 0 2
106578: NOT
106579: OR
106580: IFFALSE 106584
// exit ;
106582: GO 106748
// tmp := AreaToList ( area , i ) ;
106584: LD_ADDR_VAR 0 6
106588: PUSH
106589: LD_VAR 0 2
106593: PPUSH
106594: LD_VAR 0 5
106598: PPUSH
106599: CALL_OW 517
106603: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106604: LD_ADDR_VAR 0 5
106608: PUSH
106609: DOUBLE
106610: LD_INT 1
106612: DEC
106613: ST_TO_ADDR
106614: LD_VAR 0 6
106618: PUSH
106619: LD_INT 1
106621: ARRAY
106622: PUSH
106623: FOR_TO
106624: IFFALSE 106746
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106626: LD_ADDR_VAR 0 7
106630: PUSH
106631: LD_VAR 0 6
106635: PUSH
106636: LD_INT 1
106638: ARRAY
106639: PUSH
106640: LD_VAR 0 5
106644: ARRAY
106645: PUSH
106646: LD_VAR 0 6
106650: PUSH
106651: LD_INT 2
106653: ARRAY
106654: PUSH
106655: LD_VAR 0 5
106659: ARRAY
106660: PUSH
106661: EMPTY
106662: LIST
106663: LIST
106664: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106665: LD_VAR 0 7
106669: PUSH
106670: LD_INT 1
106672: ARRAY
106673: PPUSH
106674: LD_VAR 0 7
106678: PUSH
106679: LD_INT 2
106681: ARRAY
106682: PPUSH
106683: CALL_OW 428
106687: PUSH
106688: LD_INT 0
106690: EQUAL
106691: IFFALSE 106744
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106693: LD_VAR 0 1
106697: PPUSH
106698: LD_VAR 0 7
106702: PUSH
106703: LD_INT 1
106705: ARRAY
106706: PPUSH
106707: LD_VAR 0 7
106711: PUSH
106712: LD_INT 2
106714: ARRAY
106715: PPUSH
106716: LD_VAR 0 3
106720: PPUSH
106721: CALL_OW 48
// result := IsPlaced ( unit ) ;
106725: LD_ADDR_VAR 0 4
106729: PUSH
106730: LD_VAR 0 1
106734: PPUSH
106735: CALL_OW 305
106739: ST_TO_ADDR
// exit ;
106740: POP
106741: POP
106742: GO 106748
// end ; end ;
106744: GO 106623
106746: POP
106747: POP
// end ;
106748: LD_VAR 0 4
106752: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106753: LD_INT 0
106755: PPUSH
106756: PPUSH
106757: PPUSH
// if not side or side > 8 then
106758: LD_VAR 0 1
106762: NOT
106763: PUSH
106764: LD_VAR 0 1
106768: PUSH
106769: LD_INT 8
106771: GREATER
106772: OR
106773: IFFALSE 106777
// exit ;
106775: GO 106964
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106777: LD_ADDR_VAR 0 4
106781: PUSH
106782: LD_INT 22
106784: PUSH
106785: LD_VAR 0 1
106789: PUSH
106790: EMPTY
106791: LIST
106792: LIST
106793: PUSH
106794: LD_INT 21
106796: PUSH
106797: LD_INT 3
106799: PUSH
106800: EMPTY
106801: LIST
106802: LIST
106803: PUSH
106804: EMPTY
106805: LIST
106806: LIST
106807: PPUSH
106808: CALL_OW 69
106812: ST_TO_ADDR
// if not tmp then
106813: LD_VAR 0 4
106817: NOT
106818: IFFALSE 106822
// exit ;
106820: GO 106964
// enable_addtolog := true ;
106822: LD_ADDR_OWVAR 81
106826: PUSH
106827: LD_INT 1
106829: ST_TO_ADDR
// AddToLog ( [ ) ;
106830: LD_STRING [
106832: PPUSH
106833: CALL_OW 561
// for i in tmp do
106837: LD_ADDR_VAR 0 3
106841: PUSH
106842: LD_VAR 0 4
106846: PUSH
106847: FOR_IN
106848: IFFALSE 106955
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106850: LD_STRING [
106852: PUSH
106853: LD_VAR 0 3
106857: PPUSH
106858: CALL_OW 266
106862: STR
106863: PUSH
106864: LD_STRING , 
106866: STR
106867: PUSH
106868: LD_VAR 0 3
106872: PPUSH
106873: CALL_OW 250
106877: STR
106878: PUSH
106879: LD_STRING , 
106881: STR
106882: PUSH
106883: LD_VAR 0 3
106887: PPUSH
106888: CALL_OW 251
106892: STR
106893: PUSH
106894: LD_STRING , 
106896: STR
106897: PUSH
106898: LD_VAR 0 3
106902: PPUSH
106903: CALL_OW 254
106907: STR
106908: PUSH
106909: LD_STRING , 
106911: STR
106912: PUSH
106913: LD_VAR 0 3
106917: PPUSH
106918: LD_INT 1
106920: PPUSH
106921: CALL_OW 268
106925: STR
106926: PUSH
106927: LD_STRING , 
106929: STR
106930: PUSH
106931: LD_VAR 0 3
106935: PPUSH
106936: LD_INT 2
106938: PPUSH
106939: CALL_OW 268
106943: STR
106944: PUSH
106945: LD_STRING ],
106947: STR
106948: PPUSH
106949: CALL_OW 561
// end ;
106953: GO 106847
106955: POP
106956: POP
// AddToLog ( ]; ) ;
106957: LD_STRING ];
106959: PPUSH
106960: CALL_OW 561
// end ;
106964: LD_VAR 0 2
106968: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106969: LD_INT 0
106971: PPUSH
106972: PPUSH
106973: PPUSH
106974: PPUSH
106975: PPUSH
// if not area or not rate or not max then
106976: LD_VAR 0 1
106980: NOT
106981: PUSH
106982: LD_VAR 0 2
106986: NOT
106987: OR
106988: PUSH
106989: LD_VAR 0 4
106993: NOT
106994: OR
106995: IFFALSE 106999
// exit ;
106997: GO 107191
// while 1 do
106999: LD_INT 1
107001: IFFALSE 107191
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107003: LD_ADDR_VAR 0 9
107007: PUSH
107008: LD_VAR 0 1
107012: PPUSH
107013: LD_INT 1
107015: PPUSH
107016: CALL_OW 287
107020: PUSH
107021: LD_INT 10
107023: MUL
107024: ST_TO_ADDR
// r := rate / 10 ;
107025: LD_ADDR_VAR 0 7
107029: PUSH
107030: LD_VAR 0 2
107034: PUSH
107035: LD_INT 10
107037: DIVREAL
107038: ST_TO_ADDR
// time := 1 1$00 ;
107039: LD_ADDR_VAR 0 8
107043: PUSH
107044: LD_INT 2100
107046: ST_TO_ADDR
// if amount < min then
107047: LD_VAR 0 9
107051: PUSH
107052: LD_VAR 0 3
107056: LESS
107057: IFFALSE 107075
// r := r * 2 else
107059: LD_ADDR_VAR 0 7
107063: PUSH
107064: LD_VAR 0 7
107068: PUSH
107069: LD_INT 2
107071: MUL
107072: ST_TO_ADDR
107073: GO 107101
// if amount > max then
107075: LD_VAR 0 9
107079: PUSH
107080: LD_VAR 0 4
107084: GREATER
107085: IFFALSE 107101
// r := r / 2 ;
107087: LD_ADDR_VAR 0 7
107091: PUSH
107092: LD_VAR 0 7
107096: PUSH
107097: LD_INT 2
107099: DIVREAL
107100: ST_TO_ADDR
// time := time / r ;
107101: LD_ADDR_VAR 0 8
107105: PUSH
107106: LD_VAR 0 8
107110: PUSH
107111: LD_VAR 0 7
107115: DIVREAL
107116: ST_TO_ADDR
// if time < 0 then
107117: LD_VAR 0 8
107121: PUSH
107122: LD_INT 0
107124: LESS
107125: IFFALSE 107142
// time := time * - 1 ;
107127: LD_ADDR_VAR 0 8
107131: PUSH
107132: LD_VAR 0 8
107136: PUSH
107137: LD_INT 1
107139: NEG
107140: MUL
107141: ST_TO_ADDR
// wait ( time ) ;
107142: LD_VAR 0 8
107146: PPUSH
107147: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
107151: LD_INT 35
107153: PPUSH
107154: LD_INT 875
107156: PPUSH
107157: CALL_OW 12
107161: PPUSH
107162: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107166: LD_INT 1
107168: PPUSH
107169: LD_INT 5
107171: PPUSH
107172: CALL_OW 12
107176: PPUSH
107177: LD_VAR 0 1
107181: PPUSH
107182: LD_INT 1
107184: PPUSH
107185: CALL_OW 55
// end ;
107189: GO 106999
// end ;
107191: LD_VAR 0 5
107195: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107196: LD_INT 0
107198: PPUSH
107199: PPUSH
107200: PPUSH
107201: PPUSH
107202: PPUSH
107203: PPUSH
107204: PPUSH
107205: PPUSH
// if not turrets or not factories then
107206: LD_VAR 0 1
107210: NOT
107211: PUSH
107212: LD_VAR 0 2
107216: NOT
107217: OR
107218: IFFALSE 107222
// exit ;
107220: GO 107529
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107222: LD_ADDR_VAR 0 10
107226: PUSH
107227: LD_INT 5
107229: PUSH
107230: LD_INT 6
107232: PUSH
107233: EMPTY
107234: LIST
107235: LIST
107236: PUSH
107237: LD_INT 2
107239: PUSH
107240: LD_INT 4
107242: PUSH
107243: EMPTY
107244: LIST
107245: LIST
107246: PUSH
107247: LD_INT 3
107249: PUSH
107250: LD_INT 5
107252: PUSH
107253: EMPTY
107254: LIST
107255: LIST
107256: PUSH
107257: EMPTY
107258: LIST
107259: LIST
107260: LIST
107261: PUSH
107262: LD_INT 24
107264: PUSH
107265: LD_INT 25
107267: PUSH
107268: EMPTY
107269: LIST
107270: LIST
107271: PUSH
107272: LD_INT 23
107274: PUSH
107275: LD_INT 27
107277: PUSH
107278: EMPTY
107279: LIST
107280: LIST
107281: PUSH
107282: EMPTY
107283: LIST
107284: LIST
107285: PUSH
107286: LD_INT 42
107288: PUSH
107289: LD_INT 43
107291: PUSH
107292: EMPTY
107293: LIST
107294: LIST
107295: PUSH
107296: LD_INT 44
107298: PUSH
107299: LD_INT 46
107301: PUSH
107302: EMPTY
107303: LIST
107304: LIST
107305: PUSH
107306: LD_INT 45
107308: PUSH
107309: LD_INT 47
107311: PUSH
107312: EMPTY
107313: LIST
107314: LIST
107315: PUSH
107316: EMPTY
107317: LIST
107318: LIST
107319: LIST
107320: PUSH
107321: EMPTY
107322: LIST
107323: LIST
107324: LIST
107325: ST_TO_ADDR
// result := [ ] ;
107326: LD_ADDR_VAR 0 3
107330: PUSH
107331: EMPTY
107332: ST_TO_ADDR
// for i in turrets do
107333: LD_ADDR_VAR 0 4
107337: PUSH
107338: LD_VAR 0 1
107342: PUSH
107343: FOR_IN
107344: IFFALSE 107527
// begin nat := GetNation ( i ) ;
107346: LD_ADDR_VAR 0 7
107350: PUSH
107351: LD_VAR 0 4
107355: PPUSH
107356: CALL_OW 248
107360: ST_TO_ADDR
// weapon := 0 ;
107361: LD_ADDR_VAR 0 8
107365: PUSH
107366: LD_INT 0
107368: ST_TO_ADDR
// if not nat then
107369: LD_VAR 0 7
107373: NOT
107374: IFFALSE 107378
// continue ;
107376: GO 107343
// for j in list [ nat ] do
107378: LD_ADDR_VAR 0 5
107382: PUSH
107383: LD_VAR 0 10
107387: PUSH
107388: LD_VAR 0 7
107392: ARRAY
107393: PUSH
107394: FOR_IN
107395: IFFALSE 107436
// if GetBWeapon ( i ) = j [ 1 ] then
107397: LD_VAR 0 4
107401: PPUSH
107402: CALL_OW 269
107406: PUSH
107407: LD_VAR 0 5
107411: PUSH
107412: LD_INT 1
107414: ARRAY
107415: EQUAL
107416: IFFALSE 107434
// begin weapon := j [ 2 ] ;
107418: LD_ADDR_VAR 0 8
107422: PUSH
107423: LD_VAR 0 5
107427: PUSH
107428: LD_INT 2
107430: ARRAY
107431: ST_TO_ADDR
// break ;
107432: GO 107436
// end ;
107434: GO 107394
107436: POP
107437: POP
// if not weapon then
107438: LD_VAR 0 8
107442: NOT
107443: IFFALSE 107447
// continue ;
107445: GO 107343
// for k in factories do
107447: LD_ADDR_VAR 0 6
107451: PUSH
107452: LD_VAR 0 2
107456: PUSH
107457: FOR_IN
107458: IFFALSE 107523
// begin weapons := AvailableWeaponList ( k ) ;
107460: LD_ADDR_VAR 0 9
107464: PUSH
107465: LD_VAR 0 6
107469: PPUSH
107470: CALL_OW 478
107474: ST_TO_ADDR
// if not weapons then
107475: LD_VAR 0 9
107479: NOT
107480: IFFALSE 107484
// continue ;
107482: GO 107457
// if weapon in weapons then
107484: LD_VAR 0 8
107488: PUSH
107489: LD_VAR 0 9
107493: IN
107494: IFFALSE 107521
// begin result := [ i , weapon ] ;
107496: LD_ADDR_VAR 0 3
107500: PUSH
107501: LD_VAR 0 4
107505: PUSH
107506: LD_VAR 0 8
107510: PUSH
107511: EMPTY
107512: LIST
107513: LIST
107514: ST_TO_ADDR
// exit ;
107515: POP
107516: POP
107517: POP
107518: POP
107519: GO 107529
// end ; end ;
107521: GO 107457
107523: POP
107524: POP
// end ;
107525: GO 107343
107527: POP
107528: POP
// end ;
107529: LD_VAR 0 3
107533: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107534: LD_INT 0
107536: PPUSH
// if not side or side > 8 then
107537: LD_VAR 0 3
107541: NOT
107542: PUSH
107543: LD_VAR 0 3
107547: PUSH
107548: LD_INT 8
107550: GREATER
107551: OR
107552: IFFALSE 107556
// exit ;
107554: GO 107615
// if not range then
107556: LD_VAR 0 4
107560: NOT
107561: IFFALSE 107572
// range := - 12 ;
107563: LD_ADDR_VAR 0 4
107567: PUSH
107568: LD_INT 12
107570: NEG
107571: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107572: LD_VAR 0 1
107576: PPUSH
107577: LD_VAR 0 2
107581: PPUSH
107582: LD_VAR 0 3
107586: PPUSH
107587: LD_VAR 0 4
107591: PPUSH
107592: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107596: LD_VAR 0 1
107600: PPUSH
107601: LD_VAR 0 2
107605: PPUSH
107606: LD_VAR 0 3
107610: PPUSH
107611: CALL_OW 331
// end ;
107615: LD_VAR 0 5
107619: RET
// export function Video ( mode ) ; begin
107620: LD_INT 0
107622: PPUSH
// ingame_video = mode ;
107623: LD_ADDR_OWVAR 52
107627: PUSH
107628: LD_VAR 0 1
107632: ST_TO_ADDR
// interface_hidden = mode ;
107633: LD_ADDR_OWVAR 54
107637: PUSH
107638: LD_VAR 0 1
107642: ST_TO_ADDR
// end ;
107643: LD_VAR 0 2
107647: RET
// export function Join ( array , element ) ; begin
107648: LD_INT 0
107650: PPUSH
// result := array ^ element ;
107651: LD_ADDR_VAR 0 3
107655: PUSH
107656: LD_VAR 0 1
107660: PUSH
107661: LD_VAR 0 2
107665: ADD
107666: ST_TO_ADDR
// end ;
107667: LD_VAR 0 3
107671: RET
// export function JoinUnion ( array , element ) ; begin
107672: LD_INT 0
107674: PPUSH
// result := array union element ;
107675: LD_ADDR_VAR 0 3
107679: PUSH
107680: LD_VAR 0 1
107684: PUSH
107685: LD_VAR 0 2
107689: UNION
107690: ST_TO_ADDR
// end ;
107691: LD_VAR 0 3
107695: RET
// export function GetBehemoths ( side ) ; begin
107696: LD_INT 0
107698: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107699: LD_ADDR_VAR 0 2
107703: PUSH
107704: LD_INT 22
107706: PUSH
107707: LD_VAR 0 1
107711: PUSH
107712: EMPTY
107713: LIST
107714: LIST
107715: PUSH
107716: LD_INT 31
107718: PUSH
107719: LD_INT 25
107721: PUSH
107722: EMPTY
107723: LIST
107724: LIST
107725: PUSH
107726: EMPTY
107727: LIST
107728: LIST
107729: PPUSH
107730: CALL_OW 69
107734: ST_TO_ADDR
// end ;
107735: LD_VAR 0 2
107739: RET
// export function Shuffle ( array ) ; var i , index ; begin
107740: LD_INT 0
107742: PPUSH
107743: PPUSH
107744: PPUSH
// result := [ ] ;
107745: LD_ADDR_VAR 0 2
107749: PUSH
107750: EMPTY
107751: ST_TO_ADDR
// if not array then
107752: LD_VAR 0 1
107756: NOT
107757: IFFALSE 107761
// exit ;
107759: GO 107860
// Randomize ;
107761: CALL_OW 10
// for i = array downto 1 do
107765: LD_ADDR_VAR 0 3
107769: PUSH
107770: DOUBLE
107771: LD_VAR 0 1
107775: INC
107776: ST_TO_ADDR
107777: LD_INT 1
107779: PUSH
107780: FOR_DOWNTO
107781: IFFALSE 107858
// begin index := rand ( 1 , array ) ;
107783: LD_ADDR_VAR 0 4
107787: PUSH
107788: LD_INT 1
107790: PPUSH
107791: LD_VAR 0 1
107795: PPUSH
107796: CALL_OW 12
107800: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107801: LD_ADDR_VAR 0 2
107805: PUSH
107806: LD_VAR 0 2
107810: PPUSH
107811: LD_VAR 0 2
107815: PUSH
107816: LD_INT 1
107818: PLUS
107819: PPUSH
107820: LD_VAR 0 1
107824: PUSH
107825: LD_VAR 0 4
107829: ARRAY
107830: PPUSH
107831: CALL_OW 2
107835: ST_TO_ADDR
// array := Delete ( array , index ) ;
107836: LD_ADDR_VAR 0 1
107840: PUSH
107841: LD_VAR 0 1
107845: PPUSH
107846: LD_VAR 0 4
107850: PPUSH
107851: CALL_OW 3
107855: ST_TO_ADDR
// end ;
107856: GO 107780
107858: POP
107859: POP
// end ;
107860: LD_VAR 0 2
107864: RET
// export function GetBaseMaterials ( base ) ; begin
107865: LD_INT 0
107867: PPUSH
// result := [ 0 , 0 , 0 ] ;
107868: LD_ADDR_VAR 0 2
107872: PUSH
107873: LD_INT 0
107875: PUSH
107876: LD_INT 0
107878: PUSH
107879: LD_INT 0
107881: PUSH
107882: EMPTY
107883: LIST
107884: LIST
107885: LIST
107886: ST_TO_ADDR
// if not base then
107887: LD_VAR 0 1
107891: NOT
107892: IFFALSE 107896
// exit ;
107894: GO 107945
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107896: LD_ADDR_VAR 0 2
107900: PUSH
107901: LD_VAR 0 1
107905: PPUSH
107906: LD_INT 1
107908: PPUSH
107909: CALL_OW 275
107913: PUSH
107914: LD_VAR 0 1
107918: PPUSH
107919: LD_INT 2
107921: PPUSH
107922: CALL_OW 275
107926: PUSH
107927: LD_VAR 0 1
107931: PPUSH
107932: LD_INT 3
107934: PPUSH
107935: CALL_OW 275
107939: PUSH
107940: EMPTY
107941: LIST
107942: LIST
107943: LIST
107944: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107945: LD_VAR 0 2
107949: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107950: LD_INT 0
107952: PPUSH
107953: PPUSH
107954: PPUSH
107955: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107956: LD_VAR 0 1
107960: PPUSH
107961: CALL_OW 264
107965: PUSH
107966: LD_EXP 99
107970: EQUAL
107971: IFFALSE 108043
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107973: LD_INT 68
107975: PPUSH
107976: LD_VAR 0 1
107980: PPUSH
107981: CALL_OW 255
107985: PPUSH
107986: CALL_OW 321
107990: PUSH
107991: LD_INT 2
107993: EQUAL
107994: IFFALSE 108006
// eff := 70 else
107996: LD_ADDR_VAR 0 6
108000: PUSH
108001: LD_INT 70
108003: ST_TO_ADDR
108004: GO 108014
// eff := 30 ;
108006: LD_ADDR_VAR 0 6
108010: PUSH
108011: LD_INT 30
108013: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
108014: LD_VAR 0 1
108018: PPUSH
108019: CALL_OW 250
108023: PPUSH
108024: LD_VAR 0 1
108028: PPUSH
108029: CALL_OW 251
108033: PPUSH
108034: LD_VAR 0 6
108038: PPUSH
108039: CALL_OW 495
// end ; end ;
108043: LD_VAR 0 4
108047: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
108048: LD_INT 0
108050: PPUSH
108051: PPUSH
108052: PPUSH
108053: PPUSH
108054: PPUSH
108055: PPUSH
// if cmd = 124 then
108056: LD_VAR 0 1
108060: PUSH
108061: LD_INT 124
108063: EQUAL
108064: IFFALSE 108270
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
108066: LD_ADDR_VAR 0 5
108070: PUSH
108071: LD_INT 2
108073: PUSH
108074: LD_INT 34
108076: PUSH
108077: LD_INT 53
108079: PUSH
108080: EMPTY
108081: LIST
108082: LIST
108083: PUSH
108084: LD_INT 34
108086: PUSH
108087: LD_INT 14
108089: PUSH
108090: EMPTY
108091: LIST
108092: LIST
108093: PUSH
108094: EMPTY
108095: LIST
108096: LIST
108097: LIST
108098: PPUSH
108099: CALL_OW 69
108103: ST_TO_ADDR
// if not tmp then
108104: LD_VAR 0 5
108108: NOT
108109: IFFALSE 108113
// exit ;
108111: GO 108270
// for i in tmp do
108113: LD_ADDR_VAR 0 3
108117: PUSH
108118: LD_VAR 0 5
108122: PUSH
108123: FOR_IN
108124: IFFALSE 108268
// begin taskList := GetTaskList ( i ) ;
108126: LD_ADDR_VAR 0 6
108130: PUSH
108131: LD_VAR 0 3
108135: PPUSH
108136: CALL_OW 437
108140: ST_TO_ADDR
// if not taskList then
108141: LD_VAR 0 6
108145: NOT
108146: IFFALSE 108150
// continue ;
108148: GO 108123
// for j = 1 to taskList do
108150: LD_ADDR_VAR 0 4
108154: PUSH
108155: DOUBLE
108156: LD_INT 1
108158: DEC
108159: ST_TO_ADDR
108160: LD_VAR 0 6
108164: PUSH
108165: FOR_TO
108166: IFFALSE 108264
// if taskList [ j ] [ 1 ] = | then
108168: LD_VAR 0 6
108172: PUSH
108173: LD_VAR 0 4
108177: ARRAY
108178: PUSH
108179: LD_INT 1
108181: ARRAY
108182: PUSH
108183: LD_STRING |
108185: EQUAL
108186: IFFALSE 108262
// begin _taskList := Delete ( taskList , 1 ) ;
108188: LD_ADDR_VAR 0 7
108192: PUSH
108193: LD_VAR 0 6
108197: PPUSH
108198: LD_INT 1
108200: PPUSH
108201: CALL_OW 3
108205: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
108206: LD_VAR 0 3
108210: PPUSH
108211: LD_VAR 0 7
108215: PPUSH
108216: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
108220: LD_VAR 0 3
108224: PPUSH
108225: LD_VAR 0 6
108229: PUSH
108230: LD_VAR 0 4
108234: ARRAY
108235: PUSH
108236: LD_INT 2
108238: ARRAY
108239: PPUSH
108240: LD_VAR 0 6
108244: PUSH
108245: LD_VAR 0 4
108249: ARRAY
108250: PUSH
108251: LD_INT 3
108253: ARRAY
108254: PPUSH
108255: LD_INT 8
108257: PPUSH
108258: CALL 108275 0 4
// end ;
108262: GO 108165
108264: POP
108265: POP
// end ;
108266: GO 108123
108268: POP
108269: POP
// end ; end ;
108270: LD_VAR 0 2
108274: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108275: LD_INT 0
108277: PPUSH
108278: PPUSH
108279: PPUSH
108280: PPUSH
108281: PPUSH
108282: PPUSH
108283: PPUSH
108284: PPUSH
108285: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108286: LD_VAR 0 1
108290: NOT
108291: PUSH
108292: LD_VAR 0 2
108296: PPUSH
108297: LD_VAR 0 3
108301: PPUSH
108302: CALL_OW 488
108306: NOT
108307: OR
108308: PUSH
108309: LD_VAR 0 4
108313: NOT
108314: OR
108315: IFFALSE 108319
// exit ;
108317: GO 108659
// list := [ ] ;
108319: LD_ADDR_VAR 0 13
108323: PUSH
108324: EMPTY
108325: ST_TO_ADDR
// if x - r < 0 then
108326: LD_VAR 0 2
108330: PUSH
108331: LD_VAR 0 4
108335: MINUS
108336: PUSH
108337: LD_INT 0
108339: LESS
108340: IFFALSE 108352
// min_x := 0 else
108342: LD_ADDR_VAR 0 7
108346: PUSH
108347: LD_INT 0
108349: ST_TO_ADDR
108350: GO 108368
// min_x := x - r ;
108352: LD_ADDR_VAR 0 7
108356: PUSH
108357: LD_VAR 0 2
108361: PUSH
108362: LD_VAR 0 4
108366: MINUS
108367: ST_TO_ADDR
// if y - r < 0 then
108368: LD_VAR 0 3
108372: PUSH
108373: LD_VAR 0 4
108377: MINUS
108378: PUSH
108379: LD_INT 0
108381: LESS
108382: IFFALSE 108394
// min_y := 0 else
108384: LD_ADDR_VAR 0 8
108388: PUSH
108389: LD_INT 0
108391: ST_TO_ADDR
108392: GO 108410
// min_y := y - r ;
108394: LD_ADDR_VAR 0 8
108398: PUSH
108399: LD_VAR 0 3
108403: PUSH
108404: LD_VAR 0 4
108408: MINUS
108409: ST_TO_ADDR
// max_x := x + r ;
108410: LD_ADDR_VAR 0 9
108414: PUSH
108415: LD_VAR 0 2
108419: PUSH
108420: LD_VAR 0 4
108424: PLUS
108425: ST_TO_ADDR
// max_y := y + r ;
108426: LD_ADDR_VAR 0 10
108430: PUSH
108431: LD_VAR 0 3
108435: PUSH
108436: LD_VAR 0 4
108440: PLUS
108441: ST_TO_ADDR
// for _x = min_x to max_x do
108442: LD_ADDR_VAR 0 11
108446: PUSH
108447: DOUBLE
108448: LD_VAR 0 7
108452: DEC
108453: ST_TO_ADDR
108454: LD_VAR 0 9
108458: PUSH
108459: FOR_TO
108460: IFFALSE 108577
// for _y = min_y to max_y do
108462: LD_ADDR_VAR 0 12
108466: PUSH
108467: DOUBLE
108468: LD_VAR 0 8
108472: DEC
108473: ST_TO_ADDR
108474: LD_VAR 0 10
108478: PUSH
108479: FOR_TO
108480: IFFALSE 108573
// begin if not ValidHex ( _x , _y ) then
108482: LD_VAR 0 11
108486: PPUSH
108487: LD_VAR 0 12
108491: PPUSH
108492: CALL_OW 488
108496: NOT
108497: IFFALSE 108501
// continue ;
108499: GO 108479
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108501: LD_VAR 0 11
108505: PPUSH
108506: LD_VAR 0 12
108510: PPUSH
108511: CALL_OW 351
108515: PUSH
108516: LD_VAR 0 11
108520: PPUSH
108521: LD_VAR 0 12
108525: PPUSH
108526: CALL_OW 554
108530: AND
108531: IFFALSE 108571
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108533: LD_ADDR_VAR 0 13
108537: PUSH
108538: LD_VAR 0 13
108542: PPUSH
108543: LD_VAR 0 13
108547: PUSH
108548: LD_INT 1
108550: PLUS
108551: PPUSH
108552: LD_VAR 0 11
108556: PUSH
108557: LD_VAR 0 12
108561: PUSH
108562: EMPTY
108563: LIST
108564: LIST
108565: PPUSH
108566: CALL_OW 2
108570: ST_TO_ADDR
// end ;
108571: GO 108479
108573: POP
108574: POP
108575: GO 108459
108577: POP
108578: POP
// if not list then
108579: LD_VAR 0 13
108583: NOT
108584: IFFALSE 108588
// exit ;
108586: GO 108659
// for i in list do
108588: LD_ADDR_VAR 0 6
108592: PUSH
108593: LD_VAR 0 13
108597: PUSH
108598: FOR_IN
108599: IFFALSE 108657
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108601: LD_VAR 0 1
108605: PPUSH
108606: LD_STRING M
108608: PUSH
108609: LD_VAR 0 6
108613: PUSH
108614: LD_INT 1
108616: ARRAY
108617: PUSH
108618: LD_VAR 0 6
108622: PUSH
108623: LD_INT 2
108625: ARRAY
108626: PUSH
108627: LD_INT 0
108629: PUSH
108630: LD_INT 0
108632: PUSH
108633: LD_INT 0
108635: PUSH
108636: LD_INT 0
108638: PUSH
108639: EMPTY
108640: LIST
108641: LIST
108642: LIST
108643: LIST
108644: LIST
108645: LIST
108646: LIST
108647: PUSH
108648: EMPTY
108649: LIST
108650: PPUSH
108651: CALL_OW 447
108655: GO 108598
108657: POP
108658: POP
// end ;
108659: LD_VAR 0 5
108663: RET
