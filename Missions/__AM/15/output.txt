// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 35083 0 0
// InitMacro ;
  19: CALL 35251 0 0
// InitNature ;
  23: CALL 34951 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11161 0 0
// PrepareRussian ;
  44: CALL 7017 0 0
// PrepareLegion ;
  48: CALL 4214 0 0
// PreparePowell ;
  52: CALL 2947 0 0
// PrepareAmerican ;
  56: CALL 1719 0 0
// Action ;
  60: CALL 15063 0 0
// MC_Start ( ) ;
  64: CALL 37416 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 140
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 141
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 60165 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 60258 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59608 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 59423 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 60165 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 60258 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 59423 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59608 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 60038 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 14
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_OWVAR 67
 912: ARRAY
 913: PPUSH
 914: LD_INT 27
 916: PPUSH
 917: CALL 59105 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 921: LD_INT 3
 923: PPUSH
 924: LD_INT 10
 926: PUSH
 927: LD_INT 11
 929: PUSH
 930: LD_INT 13
 932: PUSH
 933: LD_INT 15
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 60165 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 15
 951: PUSH
 952: EMPTY
 953: LIST
 954: PPUSH
 955: CALL 60258 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 959: LD_ADDR_EXP 145
 963: PUSH
 964: LD_EXP 145
 968: PPUSH
 969: LD_INT 3
 971: PPUSH
 972: LD_INT 22
 974: PUSH
 975: LD_INT 8
 977: PUSH
 978: EMPTY
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 25
 984: PUSH
 985: LD_INT 15
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PPUSH
 996: CALL_OW 69
1000: PPUSH
1001: CALL_OW 1
1005: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1006: LD_INT 3
1008: PPUSH
1009: LD_INT 13
1011: PUSH
1012: LD_INT 2
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: LD_INT 31
1020: PUSH
1021: EMPTY
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: PUSH
1027: LD_INT 13
1029: PUSH
1030: LD_INT 2
1032: PUSH
1033: LD_INT 1
1035: PUSH
1036: LD_INT 31
1038: PUSH
1039: EMPTY
1040: LIST
1041: LIST
1042: LIST
1043: LIST
1044: PUSH
1045: LD_INT 13
1047: PUSH
1048: LD_INT 3
1050: PUSH
1051: LD_INT 2
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PUSH
1063: LD_INT 14
1065: PUSH
1066: LD_INT 1
1068: PUSH
1069: LD_INT 2
1071: PUSH
1072: LD_EXP 101
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PPUSH
1089: CALL 59423 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1093: LD_INT 4
1095: PPUSH
1096: LD_INT 10
1098: PUSH
1099: LD_INT 12
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: PPUSH
1106: CALL 60165 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1110: LD_INT 4
1112: PPUSH
1113: LD_INT 9
1115: PUSH
1116: EMPTY
1117: LIST
1118: PPUSH
1119: CALL 60258 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1123: LD_INT 4
1125: PPUSH
1126: LD_INT 26
1128: PUSH
1129: LD_INT 74
1131: PUSH
1132: LD_INT 107
1134: PUSH
1135: LD_INT 0
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 32
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 101
1152: PUSH
1153: LD_INT 4
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 69
1167: PUSH
1168: LD_INT 86
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 27
1182: PUSH
1183: LD_INT 77
1185: PUSH
1186: LD_INT 110
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 27
1200: PUSH
1201: LD_INT 42
1203: PUSH
1204: LD_INT 79
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 29
1218: PUSH
1219: LD_INT 86
1221: PUSH
1222: LD_INT 105
1224: PUSH
1225: LD_INT 2
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 30
1236: PUSH
1237: LD_INT 40
1239: PUSH
1240: LD_INT 75
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 80
1257: PUSH
1258: LD_INT 106
1260: PUSH
1261: LD_INT 4
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 75
1275: PUSH
1276: LD_INT 114
1278: PUSH
1279: LD_INT 5
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 32
1290: PUSH
1291: LD_INT 82
1293: PUSH
1294: LD_INT 110
1296: PUSH
1297: LD_INT 5
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: LD_INT 32
1308: PUSH
1309: LD_INT 62
1311: PUSH
1312: LD_INT 78
1314: PUSH
1315: LD_INT 4
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PUSH
1324: LD_INT 4
1326: PUSH
1327: LD_INT 39
1329: PUSH
1330: LD_INT 61
1332: PUSH
1333: LD_INT 3
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: CALL 59315 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1360: LD_INT 4
1362: PPUSH
1363: LD_INT 5
1365: PUSH
1366: LD_INT 6
1368: PUSH
1369: LD_INT 7
1371: PUSH
1372: LD_INT 9
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: PPUSH
1381: CALL 60576 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1385: LD_INT 4
1387: PPUSH
1388: LD_INT 40
1390: PUSH
1391: LD_INT 75
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: EMPTY
1398: LIST
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 86
1404: PUSH
1405: LD_INT 105
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: LIST
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: PPUSH
1420: CALL 59747 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1424: LD_INT 4
1426: PPUSH
1427: LD_INT 2
1429: PPUSH
1430: CALL 60038 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1434: LD_INT 4
1436: PPUSH
1437: LD_INT 0
1439: PPUSH
1440: CALL 60038 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1444: LD_INT 4
1446: PPUSH
1447: LD_INT 54
1449: PPUSH
1450: LD_INT 85
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 19
1458: PUSH
1459: LD_INT 16
1461: PUSH
1462: LD_INT 17
1464: PUSH
1465: LD_INT 18
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: PPUSH
1474: CALL 60370 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1478: LD_INT 4
1480: PPUSH
1481: LD_INT 3
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 5
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 4
1519: PUSH
1520: LD_INT 1
1522: PUSH
1523: LD_INT 1
1525: PUSH
1526: LD_INT 7
1528: PUSH
1529: EMPTY
1530: LIST
1531: LIST
1532: LIST
1533: LIST
1534: PUSH
1535: LD_INT 4
1537: PUSH
1538: LD_INT 1
1540: PUSH
1541: LD_INT 1
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: LIST
1557: LIST
1558: PPUSH
1559: CALL 59423 0 2
// MC_SetTame ( 4 , powellApe ) ;
1563: LD_INT 4
1565: PPUSH
1566: LD_INT 13
1568: PPUSH
1569: CALL 59989 0 2
// end ;
1573: LD_VAR 0 1
1577: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1578: LD_EXP 36
1582: PUSH
1583: LD_EXP 17
1587: PUSH
1588: LD_INT 2
1590: GREATEREQUAL
1591: AND
1592: IFFALSE 1604
1594: GO 1596
1596: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1597: LD_STRING ACH_POWELL
1599: PPUSH
1600: CALL_OW 543
1604: END
// every 0 0$1 trigger debug do var i , tmp ;
1605: LD_EXP 1
1609: IFFALSE 1716
1611: GO 1613
1613: DISABLE
1614: LD_INT 0
1616: PPUSH
1617: PPUSH
// begin enable ;
1618: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1619: LD_ADDR_VAR 0 2
1623: PUSH
1624: LD_INT 22
1626: PUSH
1627: LD_INT 1
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: PUSH
1634: LD_INT 3
1636: PUSH
1637: LD_INT 21
1639: PUSH
1640: LD_INT 3
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: PUSH
1651: LD_INT 3
1653: PUSH
1654: LD_INT 24
1656: PUSH
1657: LD_INT 999
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: LIST
1672: PPUSH
1673: CALL_OW 69
1677: ST_TO_ADDR
// if not tmp then
1678: LD_VAR 0 2
1682: NOT
1683: IFFALSE 1687
// exit ;
1685: GO 1716
// for i in tmp do
1687: LD_ADDR_VAR 0 1
1691: PUSH
1692: LD_VAR 0 2
1696: PUSH
1697: FOR_IN
1698: IFFALSE 1714
// SetLives ( i , 1000 ) ;
1700: LD_VAR 0 1
1704: PPUSH
1705: LD_INT 1000
1707: PPUSH
1708: CALL_OW 234
1712: GO 1697
1714: POP
1715: POP
// end ; end_of_file
1716: PPOPN 2
1718: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1719: LD_INT 0
1721: PPUSH
// uc_side := 1 ;
1722: LD_ADDR_OWVAR 20
1726: PUSH
1727: LD_INT 1
1729: ST_TO_ADDR
// uc_nation := 1 ;
1730: LD_ADDR_OWVAR 21
1734: PUSH
1735: LD_INT 1
1737: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1738: LD_ADDR_EXP 39
1742: PUSH
1743: LD_STRING JMM
1745: PPUSH
1746: LD_EXP 1
1750: NOT
1751: PPUSH
1752: LD_STRING 14_
1754: PPUSH
1755: CALL 65877 0 3
1759: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1760: LD_EXP 4
1764: NOT
1765: PUSH
1766: LD_EXP 4
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: PUSH
1775: LD_INT 1
1777: ARRAY
1778: NOT
1779: OR
1780: IFFALSE 1803
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1782: LD_INT 5
1784: PPUSH
1785: LD_INT 3
1787: PPUSH
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_INT 100
1796: PPUSH
1797: CALL 70741 0 5
1801: GO 1862
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1803: LD_EXP 4
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PUSH
1812: LD_INT 1
1814: ARRAY
1815: PPUSH
1816: LD_EXP 4
1820: PUSH
1821: LD_INT 2
1823: ARRAY
1824: PUSH
1825: LD_INT 1
1827: ARRAY
1828: PPUSH
1829: LD_EXP 4
1833: PUSH
1834: LD_INT 3
1836: ARRAY
1837: PUSH
1838: LD_INT 1
1840: ARRAY
1841: PPUSH
1842: LD_EXP 4
1846: PUSH
1847: LD_INT 4
1849: ARRAY
1850: PUSH
1851: LD_INT 1
1853: ARRAY
1854: PPUSH
1855: LD_INT 30
1857: PPUSH
1858: CALL 70741 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 56
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// if not JMMNewVeh then
1872: LD_EXP 56
1876: NOT
1877: IFFALSE 1908
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 70741 0 5
// JMMNewVeh := CreateVehicle ;
1898: LD_ADDR_EXP 56
1902: PUSH
1903: CALL_OW 45
1907: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1908: LD_EXP 56
1912: PPUSH
1913: LD_INT 4
1915: PPUSH
1916: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1920: LD_EXP 56
1924: PPUSH
1925: LD_INT 79
1927: PPUSH
1928: LD_INT 91
1930: PPUSH
1931: LD_INT 0
1933: PPUSH
1934: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1938: LD_EXP 39
1942: PPUSH
1943: LD_EXP 56
1947: PPUSH
1948: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1952: LD_EXP 6
1956: PUSH
1957: LD_EXP 2
1961: NOT
1962: AND
1963: IFFALSE 2221
// begin if not JMMGirlVeh then
1965: LD_EXP 5
1969: NOT
1970: IFFALSE 1993
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1972: LD_INT 3
1974: PPUSH
1975: LD_INT 3
1977: PPUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_INT 9
1983: PPUSH
1984: LD_INT 100
1986: PPUSH
1987: CALL 70741 0 5
1991: GO 2052
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1993: LD_EXP 5
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PUSH
2002: LD_INT 1
2004: ARRAY
2005: PPUSH
2006: LD_EXP 5
2010: PUSH
2011: LD_INT 2
2013: ARRAY
2014: PUSH
2015: LD_INT 1
2017: ARRAY
2018: PPUSH
2019: LD_EXP 5
2023: PUSH
2024: LD_INT 3
2026: ARRAY
2027: PUSH
2028: LD_INT 1
2030: ARRAY
2031: PPUSH
2032: LD_EXP 5
2036: PUSH
2037: LD_INT 4
2039: ARRAY
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PPUSH
2045: LD_INT 30
2047: PPUSH
2048: CALL 70741 0 5
// GirlNewVeh := CreateVehicle ;
2052: LD_ADDR_EXP 57
2056: PUSH
2057: CALL_OW 45
2061: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2062: LD_EXP 57
2066: PPUSH
2067: LD_INT 4
2069: PPUSH
2070: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2074: LD_EXP 57
2078: PPUSH
2079: LD_INT 82
2081: PPUSH
2082: LD_INT 96
2084: PPUSH
2085: LD_INT 0
2087: PPUSH
2088: CALL_OW 48
// if JMMGirl = 1 then
2092: LD_EXP 7
2096: PUSH
2097: LD_INT 1
2099: EQUAL
2100: IFFALSE 2135
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2102: LD_ADDR_EXP 40
2106: PUSH
2107: LD_STRING Joan
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_STRING 14_
2115: PPUSH
2116: CALL 65877 0 3
2120: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2121: LD_EXP 40
2125: PPUSH
2126: LD_EXP 57
2130: PPUSH
2131: CALL_OW 52
// end ; if JMMGirl = 2 then
2135: LD_EXP 7
2139: PUSH
2140: LD_INT 2
2142: EQUAL
2143: IFFALSE 2178
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2145: LD_ADDR_EXP 42
2149: PUSH
2150: LD_STRING Lisa
2152: PPUSH
2153: LD_INT 1
2155: PPUSH
2156: LD_STRING 14_
2158: PPUSH
2159: CALL 65877 0 3
2163: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2164: LD_EXP 42
2168: PPUSH
2169: LD_EXP 57
2173: PPUSH
2174: CALL_OW 52
// end ; if JMMGirl = 3 then
2178: LD_EXP 7
2182: PUSH
2183: LD_INT 3
2185: EQUAL
2186: IFFALSE 2221
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2188: LD_ADDR_EXP 54
2192: PUSH
2193: LD_STRING Connie
2195: PPUSH
2196: LD_INT 1
2198: PPUSH
2199: LD_STRING 14_
2201: PPUSH
2202: CALL 65877 0 3
2206: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2207: LD_EXP 54
2211: PPUSH
2212: LD_EXP 57
2216: PPUSH
2217: CALL_OW 52
// end ; end ; end ;
2221: LD_VAR 0 1
2225: RET
// export function PrepareStevensSquad ; var tmp ; begin
2226: LD_INT 0
2228: PPUSH
2229: PPUSH
// uc_side := 1 ;
2230: LD_ADDR_OWVAR 20
2234: PUSH
2235: LD_INT 1
2237: ST_TO_ADDR
// uc_nation := 1 ;
2238: LD_ADDR_OWVAR 21
2242: PUSH
2243: LD_INT 1
2245: ST_TO_ADDR
// tmp := [ ] ;
2246: LD_ADDR_VAR 0 2
2250: PUSH
2251: EMPTY
2252: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2253: LD_ADDR_EXP 41
2257: PUSH
2258: LD_STRING Stevens
2260: PPUSH
2261: LD_EXP 1
2265: NOT
2266: PPUSH
2267: LD_STRING 13f_
2269: PPUSH
2270: CALL 65877 0 3
2274: ST_TO_ADDR
// if not Stevens then
2275: LD_EXP 41
2279: NOT
2280: IFFALSE 2336
// begin hc_name = Baker Smith ;
2282: LD_ADDR_OWVAR 26
2286: PUSH
2287: LD_STRING Baker Smith
2289: ST_TO_ADDR
// hc_gallery =  ;
2290: LD_ADDR_OWVAR 33
2294: PUSH
2295: LD_STRING 
2297: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2298: LD_INT 1
2300: PPUSH
2301: LD_INT 10
2303: PPUSH
2304: CALL_OW 384
// Baker = CreateHuman ;
2308: LD_ADDR_EXP 55
2312: PUSH
2313: CALL_OW 44
2317: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2318: LD_ADDR_VAR 0 2
2322: PUSH
2323: LD_VAR 0 2
2327: PUSH
2328: LD_EXP 55
2332: ADD
2333: ST_TO_ADDR
// end else
2334: GO 2352
// tmp := tmp ^ Stevens ;
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_VAR 0 2
2345: PUSH
2346: LD_EXP 41
2350: ADD
2351: ST_TO_ADDR
// if not Lisa then
2352: LD_EXP 42
2356: NOT
2357: IFFALSE 2403
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2359: LD_ADDR_EXP 42
2363: PUSH
2364: LD_STRING Lisa
2366: PPUSH
2367: LD_EXP 1
2371: NOT
2372: PPUSH
2373: LD_STRING 13f_
2375: PPUSH
2376: CALL 65877 0 3
2380: ST_TO_ADDR
// if Lisa then
2381: LD_EXP 42
2385: IFFALSE 2403
// tmp := tmp ^ Lisa ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_EXP 42
2401: ADD
2402: ST_TO_ADDR
// end ; if not Donaldson then
2403: LD_EXP 43
2407: NOT
2408: IFFALSE 2454
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2410: LD_ADDR_EXP 43
2414: PUSH
2415: LD_STRING Donaldson
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13f_
2426: PPUSH
2427: CALL 65877 0 3
2431: ST_TO_ADDR
// if Donaldson then
2432: LD_EXP 43
2436: IFFALSE 2454
// tmp := tmp ^ Donaldson ;
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: LD_VAR 0 2
2447: PUSH
2448: LD_EXP 43
2452: ADD
2453: ST_TO_ADDR
// end ; if not Bobby then
2454: LD_EXP 44
2458: NOT
2459: IFFALSE 2505
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2461: LD_ADDR_EXP 44
2465: PUSH
2466: LD_STRING Bobby
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13f_
2477: PPUSH
2478: CALL 65877 0 3
2482: ST_TO_ADDR
// if Bobby then
2483: LD_EXP 44
2487: IFFALSE 2505
// tmp := tmp ^ Bobby ;
2489: LD_ADDR_VAR 0 2
2493: PUSH
2494: LD_VAR 0 2
2498: PUSH
2499: LD_EXP 44
2503: ADD
2504: ST_TO_ADDR
// end ; if not Cyrus then
2505: LD_EXP 45
2509: NOT
2510: IFFALSE 2556
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2512: LD_ADDR_EXP 45
2516: PUSH
2517: LD_STRING Cyrus
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13f_
2528: PPUSH
2529: CALL 65877 0 3
2533: ST_TO_ADDR
// if Cyrus then
2534: LD_EXP 45
2538: IFFALSE 2556
// tmp := tmp ^ Cyrus ;
2540: LD_ADDR_VAR 0 2
2544: PUSH
2545: LD_VAR 0 2
2549: PUSH
2550: LD_EXP 45
2554: ADD
2555: ST_TO_ADDR
// end ; if not Brown then
2556: LD_EXP 47
2560: NOT
2561: IFFALSE 2607
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2563: LD_ADDR_EXP 47
2567: PUSH
2568: LD_STRING Brown
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13f_
2579: PPUSH
2580: CALL 65877 0 3
2584: ST_TO_ADDR
// if Brown then
2585: LD_EXP 47
2589: IFFALSE 2607
// tmp := tmp ^ Brown ;
2591: LD_ADDR_VAR 0 2
2595: PUSH
2596: LD_VAR 0 2
2600: PUSH
2601: LD_EXP 47
2605: ADD
2606: ST_TO_ADDR
// end ; if not Gladstone then
2607: LD_EXP 48
2611: NOT
2612: IFFALSE 2658
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2614: LD_ADDR_EXP 48
2618: PUSH
2619: LD_STRING Gladstone
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13f_
2630: PPUSH
2631: CALL 65877 0 3
2635: ST_TO_ADDR
// if Gladstone then
2636: LD_EXP 48
2640: IFFALSE 2658
// tmp := tmp ^ Gladstone ;
2642: LD_ADDR_VAR 0 2
2646: PUSH
2647: LD_VAR 0 2
2651: PUSH
2652: LD_EXP 48
2656: ADD
2657: ST_TO_ADDR
// end ; if not Houten then
2658: LD_EXP 49
2662: NOT
2663: IFFALSE 2709
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2665: LD_ADDR_EXP 49
2669: PUSH
2670: LD_STRING Houten
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13f_
2681: PPUSH
2682: CALL 65877 0 3
2686: ST_TO_ADDR
// if Houten then
2687: LD_EXP 49
2691: IFFALSE 2709
// tmp := tmp ^ Houten ;
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 2
2702: PUSH
2703: LD_EXP 49
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 50
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2716: LD_ADDR_EXP 50
2720: PUSH
2721: LD_STRING Cornell
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13f_
2732: PPUSH
2733: CALL 65877 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 50
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 2
2748: PUSH
2749: LD_VAR 0 2
2753: PUSH
2754: LD_EXP 50
2758: ADD
2759: ST_TO_ADDR
// end ; if not Gary then
2760: LD_EXP 51
2764: NOT
2765: IFFALSE 2811
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2767: LD_ADDR_EXP 51
2771: PUSH
2772: LD_STRING Gary
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13f_
2783: PPUSH
2784: CALL 65877 0 3
2788: ST_TO_ADDR
// if Gary then
2789: LD_EXP 51
2793: IFFALSE 2811
// tmp := tmp ^ Gary ;
2795: LD_ADDR_VAR 0 2
2799: PUSH
2800: LD_VAR 0 2
2804: PUSH
2805: LD_EXP 51
2809: ADD
2810: ST_TO_ADDR
// end ; if not Frank then
2811: LD_EXP 52
2815: NOT
2816: IFFALSE 2862
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2818: LD_ADDR_EXP 52
2822: PUSH
2823: LD_STRING Frank
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13f_
2834: PPUSH
2835: CALL 65877 0 3
2839: ST_TO_ADDR
// if Frank then
2840: LD_EXP 52
2844: IFFALSE 2862
// tmp := tmp ^ Frank ;
2846: LD_ADDR_VAR 0 2
2850: PUSH
2851: LD_VAR 0 2
2855: PUSH
2856: LD_EXP 52
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 53
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2869: LD_ADDR_EXP 53
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13f_
2885: PPUSH
2886: CALL 65877 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 53
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 2
2901: PUSH
2902: LD_VAR 0 2
2906: PUSH
2907: LD_EXP 53
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2913: LD_ADDR_VAR 0 2
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: LD_STRING 13_other_survivors
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// result := tmp ;
2932: LD_ADDR_VAR 0 1
2936: PUSH
2937: LD_VAR 0 2
2941: ST_TO_ADDR
// end ; end_of_file
2942: LD_VAR 0 1
2946: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2947: LD_INT 0
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
2955: PPUSH
2956: PPUSH
2957: PPUSH
2958: PPUSH
// uc_side := 4 ;
2959: LD_ADDR_OWVAR 20
2963: PUSH
2964: LD_INT 4
2966: ST_TO_ADDR
// uc_nation := 1 ;
2967: LD_ADDR_OWVAR 21
2971: PUSH
2972: LD_INT 1
2974: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 1
2985: PPUSH
2986: LD_INT 3500
2988: PUSH
2989: LD_INT 3000
2991: PUSH
2992: LD_INT 2500
2994: PUSH
2995: LD_INT 2000
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: LD_OWVAR 67
3008: ARRAY
3009: PPUSH
3010: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3014: LD_INT 387
3016: PPUSH
3017: CALL_OW 274
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: LD_INT 400
3027: PPUSH
3028: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3032: LD_INT 387
3034: PPUSH
3035: CALL_OW 274
3039: PPUSH
3040: LD_INT 3
3042: PPUSH
3043: LD_INT 10
3045: PPUSH
3046: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3050: LD_ADDR_EXP 58
3054: PUSH
3055: LD_STRING Powell
3057: PPUSH
3058: CALL_OW 25
3062: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3063: LD_EXP 58
3067: PPUSH
3068: LD_INT 57
3070: PPUSH
3071: LD_INT 94
3073: PPUSH
3074: LD_INT 0
3076: PPUSH
3077: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3081: LD_EXP 58
3085: PPUSH
3086: LD_INT 58
3088: PPUSH
3089: LD_INT 94
3091: PPUSH
3092: CALL_OW 118
// vip := [ ] ;
3096: LD_ADDR_EXP 59
3100: PUSH
3101: EMPTY
3102: ST_TO_ADDR
// tmp := [ ] ;
3103: LD_ADDR_VAR 0 6
3107: PUSH
3108: EMPTY
3109: ST_TO_ADDR
// if JMMGirl <> 2 then
3110: LD_EXP 7
3114: PUSH
3115: LD_INT 2
3117: NONEQUAL
3118: IFFALSE 3142
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3120: LD_ADDR_EXP 42
3124: PUSH
3125: LD_STRING Lisa
3127: PPUSH
3128: LD_EXP 1
3132: NOT
3133: PPUSH
3134: LD_STRING 13s_
3136: PPUSH
3137: CALL 65877 0 3
3141: ST_TO_ADDR
// if Lisa then
3142: LD_EXP 42
3146: IFFALSE 3164
// tmp := tmp ^ Lisa ;
3148: LD_ADDR_VAR 0 6
3152: PUSH
3153: LD_VAR 0 6
3157: PUSH
3158: LD_EXP 42
3162: ADD
3163: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3164: LD_ADDR_EXP 43
3168: PUSH
3169: LD_STRING Donaldson
3171: PPUSH
3172: LD_EXP 1
3176: NOT
3177: PPUSH
3178: LD_STRING 13s_
3180: PPUSH
3181: CALL 65877 0 3
3185: ST_TO_ADDR
// if Donaldson then
3186: LD_EXP 43
3190: IFFALSE 3208
// tmp := tmp ^ Donaldson ;
3192: LD_ADDR_VAR 0 6
3196: PUSH
3197: LD_VAR 0 6
3201: PUSH
3202: LD_EXP 43
3206: ADD
3207: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3208: LD_ADDR_EXP 44
3212: PUSH
3213: LD_STRING Bobby
3215: PPUSH
3216: LD_EXP 1
3220: NOT
3221: PPUSH
3222: LD_STRING 13s_
3224: PPUSH
3225: CALL 65877 0 3
3229: ST_TO_ADDR
// if Bobby then
3230: LD_EXP 44
3234: IFFALSE 3252
// tmp := tmp ^ Bobby ;
3236: LD_ADDR_VAR 0 6
3240: PUSH
3241: LD_VAR 0 6
3245: PUSH
3246: LD_EXP 44
3250: ADD
3251: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3252: LD_ADDR_EXP 45
3256: PUSH
3257: LD_STRING Cyrus
3259: PPUSH
3260: LD_EXP 1
3264: NOT
3265: PPUSH
3266: LD_STRING 13s_
3268: PPUSH
3269: CALL 65877 0 3
3273: ST_TO_ADDR
// if Cyrus then
3274: LD_EXP 45
3278: IFFALSE 3296
// tmp := tmp ^ Cyrus ;
3280: LD_ADDR_VAR 0 6
3284: PUSH
3285: LD_VAR 0 6
3289: PUSH
3290: LD_EXP 45
3294: ADD
3295: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3296: LD_ADDR_EXP 46
3300: PUSH
3301: LD_STRING Denis
3303: PPUSH
3304: LD_EXP 1
3308: NOT
3309: PPUSH
3310: LD_STRING 13s_
3312: PPUSH
3313: CALL 65877 0 3
3317: ST_TO_ADDR
// if not Denis then
3318: LD_EXP 46
3322: NOT
3323: IFFALSE 3347
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3325: LD_ADDR_EXP 46
3329: PUSH
3330: LD_STRING Denis
3332: PPUSH
3333: LD_EXP 1
3337: NOT
3338: PPUSH
3339: LD_STRING 13f_
3341: PPUSH
3342: CALL 65877 0 3
3346: ST_TO_ADDR
// if Denis then
3347: LD_EXP 46
3351: IFFALSE 3369
// tmp := tmp ^ Denis ;
3353: LD_ADDR_VAR 0 6
3357: PUSH
3358: LD_VAR 0 6
3362: PUSH
3363: LD_EXP 46
3367: ADD
3368: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3369: LD_ADDR_EXP 47
3373: PUSH
3374: LD_STRING Brown
3376: PPUSH
3377: LD_EXP 1
3381: NOT
3382: PPUSH
3383: LD_STRING 13s_
3385: PPUSH
3386: CALL 65877 0 3
3390: ST_TO_ADDR
// if Brown then
3391: LD_EXP 47
3395: IFFALSE 3413
// tmp := tmp ^ Brown ;
3397: LD_ADDR_VAR 0 6
3401: PUSH
3402: LD_VAR 0 6
3406: PUSH
3407: LD_EXP 47
3411: ADD
3412: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3413: LD_ADDR_EXP 48
3417: PUSH
3418: LD_STRING Gladstone
3420: PPUSH
3421: LD_EXP 1
3425: NOT
3426: PPUSH
3427: LD_STRING 13s_
3429: PPUSH
3430: CALL 65877 0 3
3434: ST_TO_ADDR
// if Gladstone then
3435: LD_EXP 48
3439: IFFALSE 3457
// tmp := tmp ^ Gladstone ;
3441: LD_ADDR_VAR 0 6
3445: PUSH
3446: LD_VAR 0 6
3450: PUSH
3451: LD_EXP 48
3455: ADD
3456: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3457: LD_ADDR_EXP 49
3461: PUSH
3462: LD_STRING Houten
3464: PPUSH
3465: LD_EXP 1
3469: NOT
3470: PPUSH
3471: LD_STRING 13s_
3473: PPUSH
3474: CALL 65877 0 3
3478: ST_TO_ADDR
// if Houten then
3479: LD_EXP 49
3483: IFFALSE 3501
// tmp := tmp ^ Houten ;
3485: LD_ADDR_VAR 0 6
3489: PUSH
3490: LD_VAR 0 6
3494: PUSH
3495: LD_EXP 49
3499: ADD
3500: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3501: LD_ADDR_EXP 50
3505: PUSH
3506: LD_STRING Cornel
3508: PPUSH
3509: LD_EXP 1
3513: NOT
3514: PPUSH
3515: LD_STRING 13s_
3517: PPUSH
3518: CALL 65877 0 3
3522: ST_TO_ADDR
// if Cornel then
3523: LD_EXP 50
3527: IFFALSE 3545
// tmp := tmp ^ Cornel ;
3529: LD_ADDR_VAR 0 6
3533: PUSH
3534: LD_VAR 0 6
3538: PUSH
3539: LD_EXP 50
3543: ADD
3544: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3545: LD_ADDR_EXP 51
3549: PUSH
3550: LD_STRING Gary
3552: PPUSH
3553: LD_EXP 1
3557: NOT
3558: PPUSH
3559: LD_STRING 13s_
3561: PPUSH
3562: CALL 65877 0 3
3566: ST_TO_ADDR
// if Gary then
3567: LD_EXP 51
3571: IFFALSE 3589
// tmp := tmp ^ Gary ;
3573: LD_ADDR_VAR 0 6
3577: PUSH
3578: LD_VAR 0 6
3582: PUSH
3583: LD_EXP 51
3587: ADD
3588: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3589: LD_ADDR_EXP 52
3593: PUSH
3594: LD_STRING Frank
3596: PPUSH
3597: LD_EXP 1
3601: NOT
3602: PPUSH
3603: LD_STRING 13s_
3605: PPUSH
3606: CALL 65877 0 3
3610: ST_TO_ADDR
// if Frank then
3611: LD_EXP 52
3615: IFFALSE 3633
// tmp := tmp ^ Frank ;
3617: LD_ADDR_VAR 0 6
3621: PUSH
3622: LD_VAR 0 6
3626: PUSH
3627: LD_EXP 52
3631: ADD
3632: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3633: LD_ADDR_EXP 53
3637: PUSH
3638: LD_STRING Kikuchi
3640: PPUSH
3641: LD_EXP 1
3645: NOT
3646: PPUSH
3647: LD_STRING 13s_
3649: PPUSH
3650: CALL 65877 0 3
3654: ST_TO_ADDR
// if Kikuchi then
3655: LD_EXP 53
3659: IFFALSE 3677
// tmp := tmp ^ Kikuchi ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: LD_EXP 53
3675: ADD
3676: ST_TO_ADDR
// vip := tmp ;
3677: LD_ADDR_EXP 59
3681: PUSH
3682: LD_VAR 0 6
3686: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3687: LD_ADDR_VAR 0 6
3691: PUSH
3692: LD_VAR 0 6
3696: PUSH
3697: LD_STRING 13s_others
3699: PPUSH
3700: CALL_OW 31
3704: UNION
3705: ST_TO_ADDR
// if tmp < 18 then
3706: LD_VAR 0 6
3710: PUSH
3711: LD_INT 18
3713: LESS
3714: IFFALSE 3781
// for i = 1 to 18 - tmp do
3716: LD_ADDR_VAR 0 2
3720: PUSH
3721: DOUBLE
3722: LD_INT 1
3724: DEC
3725: ST_TO_ADDR
3726: LD_INT 18
3728: PUSH
3729: LD_VAR 0 6
3733: MINUS
3734: PUSH
3735: FOR_TO
3736: IFFALSE 3779
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3738: LD_INT 1
3740: PPUSH
3741: LD_VAR 0 2
3745: PUSH
3746: LD_INT 4
3748: MOD
3749: PUSH
3750: LD_INT 1
3752: PLUS
3753: PPUSH
3754: LD_INT 5
3756: PPUSH
3757: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3761: LD_ADDR_VAR 0 6
3765: PUSH
3766: LD_VAR 0 6
3770: PUSH
3771: CALL_OW 44
3775: ADD
3776: ST_TO_ADDR
// end ;
3777: GO 3735
3779: POP
3780: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3781: LD_ADDR_VAR 0 7
3785: PUSH
3786: LD_INT 22
3788: PUSH
3789: LD_INT 4
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: PUSH
3796: LD_INT 30
3798: PUSH
3799: LD_INT 0
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PPUSH
3810: CALL_OW 69
3814: PUSH
3815: LD_INT 1
3817: ARRAY
3818: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3819: LD_ADDR_VAR 0 8
3823: PUSH
3824: LD_INT 22
3826: PUSH
3827: LD_INT 4
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: PUSH
3834: LD_INT 30
3836: PUSH
3837: LD_INT 6
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PUSH
3844: EMPTY
3845: LIST
3846: LIST
3847: PPUSH
3848: CALL_OW 69
3852: PUSH
3853: LD_INT 1
3855: ARRAY
3856: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3857: LD_ADDR_VAR 0 9
3861: PUSH
3862: LD_INT 22
3864: PUSH
3865: LD_INT 4
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 30
3874: PUSH
3875: LD_INT 4
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PPUSH
3886: CALL_OW 69
3890: PUSH
3891: LD_INT 1
3893: ARRAY
3894: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3895: LD_ADDR_VAR 0 10
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 4
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 30
3912: PUSH
3913: LD_INT 2
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: PUSH
3929: LD_INT 1
3931: ARRAY
3932: ST_TO_ADDR
// for i in tmp do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: LD_VAR 0 6
3942: PUSH
3943: FOR_IN
3944: IFFALSE 4070
// begin cl := GetClass ( i ) ;
3946: LD_ADDR_VAR 0 5
3950: PUSH
3951: LD_VAR 0 2
3955: PPUSH
3956: CALL_OW 257
3960: ST_TO_ADDR
// if cl > 4 then
3961: LD_VAR 0 5
3965: PUSH
3966: LD_INT 4
3968: GREATER
3969: IFFALSE 3979
// cl := 1 ;
3971: LD_ADDR_VAR 0 5
3975: PUSH
3976: LD_INT 1
3978: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3979: LD_ADDR_VAR 0 3
3983: PUSH
3984: LD_VAR 0 9
3988: PUSH
3989: LD_VAR 0 7
3993: PUSH
3994: LD_VAR 0 10
3998: PUSH
3999: LD_VAR 0 8
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_VAR 0 5
4014: ARRAY
4015: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4016: LD_VAR 0 3
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: LESS
4029: IFFALSE 4047
// PlaceHumanInUnit ( i , b ) else
4031: LD_VAR 0 2
4035: PPUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: CALL_OW 52
4045: GO 4068
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4047: LD_VAR 0 2
4051: PPUSH
4052: LD_INT 61
4054: PPUSH
4055: LD_INT 89
4057: PPUSH
4058: LD_INT 6
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 50
// end ;
4068: GO 3943
4070: POP
4071: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4072: LD_INT 2
4074: PPUSH
4075: LD_INT 1
4077: PPUSH
4078: LD_INT 1
4080: PPUSH
4081: LD_INT 12
4083: PPUSH
4084: LD_INT 100
4086: PPUSH
4087: CALL 70741 0 5
// veh := CreateVehicle ;
4091: LD_ADDR_VAR 0 4
4095: PUSH
4096: CALL_OW 45
4100: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4101: LD_VAR 0 4
4105: PPUSH
4106: LD_INT 4
4108: PPUSH
4109: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4113: LD_VAR 0 4
4117: PPUSH
4118: LD_INT 49
4120: PPUSH
4121: LD_INT 88
4123: PPUSH
4124: LD_INT 0
4126: PPUSH
4127: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4131: LD_VAR 0 4
4135: PPUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 100
4141: PPUSH
4142: CALL_OW 290
// uc_side := 0 ;
4146: LD_ADDR_OWVAR 20
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// uc_nation := 0 ;
4154: LD_ADDR_OWVAR 21
4158: PUSH
4159: LD_INT 0
4161: ST_TO_ADDR
// for i = 1 to 4 do
4162: LD_ADDR_VAR 0 2
4166: PUSH
4167: DOUBLE
4168: LD_INT 1
4170: DEC
4171: ST_TO_ADDR
4172: LD_INT 4
4174: PUSH
4175: FOR_TO
4176: IFFALSE 4207
// begin InitHc ;
4178: CALL_OW 19
// hc_class := class_apeman ;
4182: LD_ADDR_OWVAR 28
4186: PUSH
4187: LD_INT 12
4189: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4190: CALL_OW 44
4194: PPUSH
4195: LD_INT 13
4197: PPUSH
4198: LD_INT 0
4200: PPUSH
4201: CALL_OW 49
// end ;
4205: GO 4175
4207: POP
4208: POP
// end ; end_of_file
4209: LD_VAR 0 1
4213: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4214: LD_INT 0
4216: PPUSH
4217: PPUSH
4218: PPUSH
4219: PPUSH
4220: PPUSH
// side := 8 ;
4221: LD_ADDR_VAR 0 3
4225: PUSH
4226: LD_INT 8
4228: ST_TO_ADDR
// uc_side := side ;
4229: LD_ADDR_OWVAR 20
4233: PUSH
4234: LD_VAR 0 3
4238: ST_TO_ADDR
// uc_nation := 2 ;
4239: LD_ADDR_OWVAR 21
4243: PUSH
4244: LD_INT 2
4246: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4247: LD_ADDR_VAR 0 2
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_VAR 0 3
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 21
4266: PUSH
4267: LD_INT 3
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4300
// SetBLevel ( i , 10 ) ;
4286: LD_VAR 0 2
4290: PPUSH
4291: LD_INT 10
4293: PPUSH
4294: CALL_OW 241
4298: GO 4283
4300: POP
4301: POP
// if KurtStatus then
4302: LD_EXP 3
4306: IFFALSE 4329
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4308: LD_ADDR_EXP 60
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_STRING 
4321: PPUSH
4322: CALL 65877 0 3
4326: ST_TO_ADDR
4327: GO 4351
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4329: LD_ADDR_EXP 60
4333: PUSH
4334: LD_STRING AltKurt
4336: PPUSH
4337: LD_EXP 1
4341: NOT
4342: PPUSH
4343: LD_STRING 
4345: PPUSH
4346: CALL 65877 0 3
4350: ST_TO_ADDR
// if not Kurt then
4351: LD_EXP 60
4355: NOT
4356: IFFALSE 4382
// begin InitHc ;
4358: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4362: LD_INT 1
4364: PPUSH
4365: LD_INT 10
4367: PPUSH
4368: CALL_OW 381
// Kurt := CreateHuman ;
4372: LD_ADDR_EXP 60
4376: PUSH
4377: CALL_OW 44
4381: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4382: LD_EXP 60
4386: PPUSH
4387: LD_INT 324
4389: PPUSH
4390: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4394: LD_ADDR_EXP 61
4398: PUSH
4399: LD_STRING Kozlov
4401: PPUSH
4402: LD_INT 0
4404: PPUSH
4405: LD_STRING 
4407: PPUSH
4408: CALL 65877 0 3
4412: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4413: LD_EXP 61
4417: PPUSH
4418: LD_INT 22
4420: PUSH
4421: LD_INT 8
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 23
4430: PUSH
4431: LD_INT 3
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 30
4440: PUSH
4441: LD_INT 8
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: PPUSH
4453: CALL_OW 69
4457: PUSH
4458: LD_INT 1
4460: ARRAY
4461: PPUSH
4462: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4466: LD_EXP 61
4470: PPUSH
4471: LD_INT 3
4473: PPUSH
4474: LD_INT 10
4476: PPUSH
4477: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4481: LD_EXP 61
4485: PPUSH
4486: LD_INT 4
4488: PPUSH
4489: LD_INT 10
4491: PPUSH
4492: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4496: LD_ADDR_VAR 0 5
4500: PUSH
4501: LD_INT 22
4503: PUSH
4504: LD_VAR 0 3
4508: PUSH
4509: EMPTY
4510: LIST
4511: LIST
4512: PUSH
4513: LD_INT 30
4515: PUSH
4516: LD_INT 32
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 58
4525: PUSH
4526: EMPTY
4527: LIST
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: LIST
4533: PPUSH
4534: CALL_OW 69
4538: ST_TO_ADDR
// for i = 1 to 10 do
4539: LD_ADDR_VAR 0 2
4543: PUSH
4544: DOUBLE
4545: LD_INT 1
4547: DEC
4548: ST_TO_ADDR
4549: LD_INT 10
4551: PUSH
4552: FOR_TO
4553: IFFALSE 4625
// begin uc_nation := nation_nature ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 0
4562: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4563: LD_ADDR_OWVAR 28
4567: PUSH
4568: LD_INT 15
4570: ST_TO_ADDR
// hc_gallery :=  ;
4571: LD_ADDR_OWVAR 33
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// hc_name :=  ;
4579: LD_ADDR_OWVAR 26
4583: PUSH
4584: LD_STRING 
4586: ST_TO_ADDR
// un := CreateHuman ;
4587: LD_ADDR_VAR 0 4
4591: PUSH
4592: CALL_OW 44
4596: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4597: LD_VAR 0 4
4601: PPUSH
4602: LD_VAR 0 5
4606: PUSH
4607: LD_VAR 0 5
4611: PUSH
4612: LD_VAR 0 2
4616: MINUS
4617: ARRAY
4618: PPUSH
4619: CALL_OW 52
// end ;
4623: GO 4552
4625: POP
4626: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4627: LD_ADDR_VAR 0 5
4631: PUSH
4632: LD_STRING 12_kurt_squad
4634: PPUSH
4635: CALL_OW 31
4639: ST_TO_ADDR
// if tmp then
4640: LD_VAR 0 5
4644: IFFALSE 4678
// for i in tmp do
4646: LD_ADDR_VAR 0 2
4650: PUSH
4651: LD_VAR 0 5
4655: PUSH
4656: FOR_IN
4657: IFFALSE 4676
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4659: LD_VAR 0 2
4663: PPUSH
4664: LD_INT 5
4666: PPUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 49
4674: GO 4656
4676: POP
4677: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4678: LD_INT 324
4680: PPUSH
4681: LD_INT 5
4683: PPUSH
4684: LD_STRING 
4686: PPUSH
4687: LD_INT 8
4689: PUSH
4690: LD_INT 9
4692: PUSH
4693: LD_INT 10
4695: PUSH
4696: LD_INT 10
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: PUSH
4705: LD_OWVAR 67
4709: ARRAY
4710: PPUSH
4711: LD_INT 3000
4713: PUSH
4714: LD_INT 500
4716: PUSH
4717: LD_INT 150
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: LIST
4724: PPUSH
4725: LD_INT 16
4727: PUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 6
4733: PUSH
4734: LD_INT 8
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: PPUSH
4743: CALL 74187 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4747: LD_ADDR_EXP 116
4751: PUSH
4752: LD_EXP 116
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 22
4762: PUSH
4763: LD_VAR 0 3
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: PUSH
4772: LD_INT 23
4774: PUSH
4775: LD_INT 2
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: LD_INT 21
4787: PUSH
4788: LD_INT 2
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: LIST
4803: PPUSH
4804: CALL_OW 69
4808: PUSH
4809: LD_EXP 60
4813: DIFF
4814: PPUSH
4815: CALL_OW 1
4819: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4820: LD_INT 1
4822: PPUSH
4823: LD_INT 7
4825: PPUSH
4826: CALL_OW 383
// Friend := CreateHuman ;
4830: LD_ADDR_EXP 62
4834: PUSH
4835: CALL_OW 44
4839: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4840: LD_INT 14
4842: PPUSH
4843: LD_INT 3
4845: PPUSH
4846: LD_INT 1
4848: PPUSH
4849: LD_INT 29
4851: PPUSH
4852: LD_INT 100
4854: PPUSH
4855: CALL 70741 0 5
// powellBomb := CreateVehicle ;
4859: LD_ADDR_EXP 63
4863: PUSH
4864: CALL_OW 45
4868: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4869: LD_EXP 63
4873: PPUSH
4874: LD_INT 90
4876: PPUSH
4877: LD_INT 51
4879: PPUSH
4880: LD_INT 0
4882: PPUSH
4883: CALL_OW 48
// end ;
4887: LD_VAR 0 1
4891: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
// if IsLive ( kozlov_fac ) then
4897: LD_INT 332
4899: PPUSH
4900: CALL_OW 300
4904: IFFALSE 4908
// exit ;
4906: GO 5475
// ComExitBuilding ( Kozlov ) ;
4908: LD_EXP 61
4912: PPUSH
4913: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4917: LD_EXP 61
4921: PPUSH
4922: CALL_OW 257
4926: PUSH
4927: LD_INT 2
4929: NONEQUAL
4930: IFFALSE 4965
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 324
4939: PPUSH
4940: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4944: LD_EXP 61
4948: PPUSH
4949: LD_INT 2
4951: PPUSH
4952: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4956: LD_EXP 61
4960: PPUSH
4961: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4965: LD_EXP 61
4969: PPUSH
4970: LD_INT 2
4972: PPUSH
4973: LD_INT 93
4975: PPUSH
4976: LD_INT 32
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4986: LD_INT 35
4988: PPUSH
4989: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4993: LD_INT 22
4995: PUSH
4996: LD_INT 8
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 30
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 23
5015: PUSH
5016: LD_INT 3
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: PUSH
5023: LD_INT 57
5025: PUSH
5026: EMPTY
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: PPUSH
5035: CALL_OW 69
5039: IFFALSE 4986
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5041: LD_ADDR_VAR 0 2
5045: PUSH
5046: LD_INT 22
5048: PUSH
5049: LD_INT 8
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 30
5058: PUSH
5059: LD_INT 3
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: PUSH
5066: LD_INT 23
5068: PUSH
5069: LD_INT 3
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 57
5078: PUSH
5079: EMPTY
5080: LIST
5081: PUSH
5082: EMPTY
5083: LIST
5084: LIST
5085: LIST
5086: LIST
5087: PPUSH
5088: CALL_OW 69
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5097: LD_INT 22
5099: PUSH
5100: LD_INT 8
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 23
5109: PUSH
5110: LD_INT 3
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: LD_INT 30
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: PPUSH
5132: CALL_OW 69
5136: NOT
5137: IFFALSE 5215
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5139: LD_EXP 61
5143: PPUSH
5144: LD_INT 21
5146: PPUSH
5147: LD_INT 97
5149: PPUSH
5150: LD_INT 36
5152: PPUSH
5153: LD_INT 5
5155: PPUSH
5156: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5160: LD_INT 35
5162: PPUSH
5163: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5167: LD_INT 22
5169: PUSH
5170: LD_INT 8
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 3
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 30
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: LD_INT 57
5199: PUSH
5200: EMPTY
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: PPUSH
5209: CALL_OW 69
5213: IFFALSE 5160
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5215: LD_INT 22
5217: PUSH
5218: LD_INT 8
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 23
5227: PUSH
5228: LD_INT 3
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PUSH
5235: LD_INT 30
5237: PUSH
5238: LD_INT 18
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: PPUSH
5250: CALL_OW 69
5254: NOT
5255: IFFALSE 5333
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5257: LD_EXP 61
5261: PPUSH
5262: LD_INT 18
5264: PPUSH
5265: LD_INT 89
5267: PPUSH
5268: LD_INT 32
5270: PPUSH
5271: LD_INT 1
5273: PPUSH
5274: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5278: LD_INT 35
5280: PPUSH
5281: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5285: LD_INT 22
5287: PUSH
5288: LD_INT 8
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: PUSH
5295: LD_INT 23
5297: PUSH
5298: LD_INT 3
5300: PUSH
5301: EMPTY
5302: LIST
5303: LIST
5304: PUSH
5305: LD_INT 30
5307: PUSH
5308: LD_INT 18
5310: PUSH
5311: EMPTY
5312: LIST
5313: LIST
5314: PUSH
5315: LD_INT 57
5317: PUSH
5318: EMPTY
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: LIST
5325: LIST
5326: PPUSH
5327: CALL_OW 69
5331: IFFALSE 5278
// end ; lab := kozlov_lab ;
5333: LD_ADDR_VAR 0 3
5337: PUSH
5338: LD_INT 336
5340: ST_TO_ADDR
// if not lab then
5341: LD_VAR 0 3
5345: NOT
5346: IFFALSE 5350
// exit ;
5348: GO 5475
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5350: LD_EXP 61
5354: PPUSH
5355: LD_VAR 0 3
5359: PUSH
5360: LD_INT 1
5362: ARRAY
5363: PPUSH
5364: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5368: LD_EXP 61
5372: PPUSH
5373: LD_INT 4
5375: PPUSH
5376: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5380: LD_VAR 0 3
5384: PUSH
5385: LD_INT 1
5387: ARRAY
5388: PPUSH
5389: LD_INT 25
5391: PPUSH
5392: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5396: LD_INT 35
5398: PPUSH
5399: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5403: LD_INT 25
5405: PPUSH
5406: LD_INT 8
5408: PPUSH
5409: CALL_OW 321
5413: PUSH
5414: LD_INT 2
5416: EQUAL
5417: IFFALSE 5396
// ComExitBuilding ( Kozlov ) ;
5419: LD_EXP 61
5423: PPUSH
5424: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5428: LD_EXP 61
5432: PPUSH
5433: LD_VAR 0 2
5437: PPUSH
5438: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5442: LD_EXP 61
5446: PPUSH
5447: LD_INT 3
5449: PPUSH
5450: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5454: LD_VAR 0 2
5458: PPUSH
5459: LD_INT 23
5461: PPUSH
5462: LD_INT 3
5464: PPUSH
5465: LD_INT 1
5467: PPUSH
5468: LD_INT 48
5470: PPUSH
5471: CALL_OW 125
// end ;
5475: LD_VAR 0 1
5479: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5480: LD_EXP 22
5484: NOT
5485: PUSH
5486: LD_EXP 15
5490: PUSH
5491: LD_INT 6
5493: GREATEREQUAL
5494: AND
5495: IFFALSE 5576
5497: GO 5499
5499: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5500: LD_INT 3
5502: PPUSH
5503: LD_INT 3
5505: PPUSH
5506: CALL 59608 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5510: LD_INT 3
5512: PPUSH
5513: LD_INT 14
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 28
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PUSH
5531: LD_INT 14
5533: PUSH
5534: LD_INT 1
5536: PUSH
5537: LD_INT 1
5539: PUSH
5540: LD_INT 28
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 14
5551: PUSH
5552: LD_INT 1
5554: PUSH
5555: LD_INT 1
5557: PUSH
5558: LD_INT 28
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL 59471 0 2
// end ;
5576: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5577: LD_EXP 22
5581: NOT
5582: PUSH
5583: LD_EXP 15
5587: PUSH
5588: LD_INT 6
5590: GREATEREQUAL
5591: AND
5592: PUSH
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 1
5598: PPUSH
5599: CALL 60889 0 2
5603: NOT
5604: AND
5605: IFFALSE 6461
5607: GO 5609
5609: DISABLE
5610: LD_INT 0
5612: PPUSH
5613: PPUSH
5614: PPUSH
// begin enable ;
5615: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5616: LD_INT 22
5618: PUSH
5619: LD_INT 8
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 23
5628: PUSH
5629: LD_INT 2
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: PUSH
5636: LD_INT 30
5638: PUSH
5639: LD_INT 3
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: NOT
5656: IFFALSE 5660
// exit ;
5658: GO 6461
// if Prob ( 40 ) then
5660: LD_INT 40
5662: PPUSH
5663: CALL_OW 13
5667: IFFALSE 5794
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5669: LD_INT 3
5671: PPUSH
5672: LD_INT 14
5674: PUSH
5675: LD_INT 1
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: LD_INT 28
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 14
5692: PUSH
5693: LD_INT 1
5695: PUSH
5696: LD_INT 2
5698: PUSH
5699: LD_INT 28
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 14
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: LD_INT 2
5716: PUSH
5717: LD_INT 28
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 14
5728: PUSH
5729: LD_INT 1
5731: PUSH
5732: LD_INT 2
5734: PUSH
5735: LD_INT 28
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 14
5746: PUSH
5747: LD_INT 1
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 28
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 14
5764: PUSH
5765: LD_INT 1
5767: PUSH
5768: LD_INT 2
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: PPUSH
5788: CALL 59471 0 2
// end else
5792: GO 6001
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5794: LD_INT 3
5796: PPUSH
5797: LD_INT 14
5799: PUSH
5800: LD_INT 1
5802: PUSH
5803: LD_INT 2
5805: PUSH
5806: LD_INT 27
5808: PUSH
5809: LD_INT 26
5811: PUSH
5812: LD_INT 26
5814: PUSH
5815: LD_INT 28
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: LD_OWVAR 67
5828: ARRAY
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 27
5847: PUSH
5848: LD_INT 26
5850: PUSH
5851: LD_INT 26
5853: PUSH
5854: LD_INT 26
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_OWVAR 67
5867: ARRAY
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 14
5877: PUSH
5878: LD_INT 1
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: LD_INT 26
5886: PUSH
5887: LD_INT 26
5889: PUSH
5890: LD_INT 29
5892: PUSH
5893: LD_INT 29
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: PUSH
5902: LD_OWVAR 67
5906: ARRAY
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 13
5916: PUSH
5917: LD_INT 1
5919: PUSH
5920: LD_INT 2
5922: PUSH
5923: LD_INT 26
5925: PUSH
5926: LD_INT 29
5928: PUSH
5929: LD_INT 29
5931: PUSH
5932: LD_INT 29
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_OWVAR 67
5945: ARRAY
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 13
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 29
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 14
5973: PUSH
5974: LD_INT 1
5976: PUSH
5977: LD_INT 2
5979: PUSH
5980: LD_INT 26
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PPUSH
5997: CALL 59471 0 2
// end ; repeat wait ( 0 0$1 ) ;
6001: LD_INT 35
6003: PPUSH
6004: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60889 0 2
6018: PUSH
6019: LD_INT 6
6021: GREATEREQUAL
6022: IFFALSE 6001
// wait ( 0 0$30 ) ;
6024: LD_INT 1050
6026: PPUSH
6027: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6031: LD_ADDR_VAR 0 2
6035: PUSH
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 60889 0 2
6046: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6047: LD_ADDR_EXP 135
6051: PUSH
6052: LD_EXP 135
6056: PPUSH
6057: LD_INT 3
6059: PPUSH
6060: LD_EXP 135
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PUSH
6069: LD_VAR 0 2
6073: DIFF
6074: PPUSH
6075: CALL_OW 1
6079: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6080: LD_ADDR_VAR 0 3
6084: PUSH
6085: LD_INT 0
6087: PPUSH
6088: LD_INT 2
6090: PPUSH
6091: CALL_OW 12
6095: ST_TO_ADDR
// if target then
6096: LD_VAR 0 3
6100: IFFALSE 6228
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: LD_INT 24
6114: PUSH
6115: LD_INT 250
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 72
6126: ST_TO_ADDR
// for i in tmp do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: LD_VAR 0 2
6136: PUSH
6137: FOR_IN
6138: IFFALSE 6178
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 89
6147: PPUSH
6148: LD_INT 71
6150: PPUSH
6151: CALL_OW 297
6155: PUSH
6156: LD_INT 9
6158: GREATER
6159: IFFALSE 6176
// ComMoveXY ( i , 89 , 71 ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_INT 89
6168: PPUSH
6169: LD_INT 71
6171: PPUSH
6172: CALL_OW 111
6176: GO 6137
6178: POP
6179: POP
// wait ( 0 0$1 ) ;
6180: LD_INT 35
6182: PPUSH
6183: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6187: LD_VAR 0 2
6191: PPUSH
6192: LD_INT 92
6194: PUSH
6195: LD_INT 89
6197: PUSH
6198: LD_INT 71
6200: PUSH
6201: LD_INT 9
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL_OW 72
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_INT 1
6222: MINUS
6223: GREATEREQUAL
6224: IFFALSE 6102
// end else
6226: GO 6352
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6228: LD_ADDR_VAR 0 2
6232: PUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: LD_INT 24
6240: PUSH
6241: LD_INT 250
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PPUSH
6248: CALL_OW 72
6252: ST_TO_ADDR
// for i in tmp do
6253: LD_ADDR_VAR 0 1
6257: PUSH
6258: LD_VAR 0 2
6262: PUSH
6263: FOR_IN
6264: IFFALSE 6304
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 125
6273: PPUSH
6274: LD_INT 129
6276: PPUSH
6277: CALL_OW 297
6281: PUSH
6282: LD_INT 9
6284: GREATER
6285: IFFALSE 6302
// ComMoveXY ( i , 125 , 129 ) ;
6287: LD_VAR 0 1
6291: PPUSH
6292: LD_INT 125
6294: PPUSH
6295: LD_INT 129
6297: PPUSH
6298: CALL_OW 111
6302: GO 6263
6304: POP
6305: POP
// wait ( 0 0$1 ) ;
6306: LD_INT 35
6308: PPUSH
6309: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6313: LD_VAR 0 2
6317: PPUSH
6318: LD_INT 92
6320: PUSH
6321: LD_INT 125
6323: PUSH
6324: LD_INT 129
6326: PUSH
6327: LD_INT 9
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PPUSH
6336: CALL_OW 72
6340: PUSH
6341: LD_VAR 0 2
6345: PUSH
6346: LD_INT 1
6348: MINUS
6349: GREATEREQUAL
6350: IFFALSE 6228
// end ; repeat wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// for i in tmp do
6359: LD_ADDR_VAR 0 1
6363: PUSH
6364: LD_VAR 0 2
6368: PUSH
6369: FOR_IN
6370: IFFALSE 6452
// begin if GetLives ( i ) > 251 then
6372: LD_VAR 0 1
6376: PPUSH
6377: CALL_OW 256
6381: PUSH
6382: LD_INT 251
6384: GREATER
6385: IFFALSE 6423
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6387: LD_VAR 0 1
6391: PPUSH
6392: LD_INT 81
6394: PUSH
6395: LD_INT 8
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PPUSH
6402: CALL_OW 69
6406: PPUSH
6407: LD_VAR 0 1
6411: PPUSH
6412: CALL_OW 74
6416: PPUSH
6417: CALL_OW 115
6421: GO 6450
// if IsDead ( i ) then
6423: LD_VAR 0 1
6427: PPUSH
6428: CALL_OW 301
6432: IFFALSE 6450
// tmp := tmp diff i ;
6434: LD_ADDR_VAR 0 2
6438: PUSH
6439: LD_VAR 0 2
6443: PUSH
6444: LD_VAR 0 1
6448: DIFF
6449: ST_TO_ADDR
// end ;
6450: GO 6369
6452: POP
6453: POP
// until not tmp ;
6454: LD_VAR 0 2
6458: NOT
6459: IFFALSE 6352
// end ;
6461: PPOPN 3
6463: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6464: LD_EXP 22
6468: NOT
6469: PUSH
6470: LD_EXP 15
6474: PUSH
6475: LD_INT 6
6477: GREATEREQUAL
6478: AND
6479: PUSH
6480: LD_OWVAR 67
6484: PUSH
6485: LD_INT 1
6487: GREATER
6488: AND
6489: IFFALSE 7014
6491: GO 6493
6493: DISABLE
6494: LD_INT 0
6496: PPUSH
6497: PPUSH
6498: PPUSH
// begin enable ;
6499: ENABLE
// tmp := [ ] ;
6500: LD_ADDR_VAR 0 3
6504: PUSH
6505: EMPTY
6506: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6507: LD_ADDR_VAR 0 1
6511: PUSH
6512: DOUBLE
6513: LD_INT 1
6515: DEC
6516: ST_TO_ADDR
6517: LD_INT 4
6519: PUSH
6520: LD_INT 6
6522: PUSH
6523: LD_INT 7
6525: PUSH
6526: LD_INT 8
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: LIST
6533: LIST
6534: PUSH
6535: LD_OWVAR 67
6539: ARRAY
6540: PUSH
6541: FOR_TO
6542: IFFALSE 6702
// begin uc_side := 8 ;
6544: LD_ADDR_OWVAR 20
6548: PUSH
6549: LD_INT 8
6551: ST_TO_ADDR
// uc_nation := 2 ;
6552: LD_ADDR_OWVAR 21
6556: PUSH
6557: LD_INT 2
6559: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6560: LD_INT 13
6562: PUSH
6563: LD_INT 14
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PUSH
6570: LD_INT 1
6572: PPUSH
6573: LD_INT 2
6575: PPUSH
6576: CALL_OW 12
6580: ARRAY
6581: PPUSH
6582: LD_INT 1
6584: PPUSH
6585: LD_INT 5
6587: PPUSH
6588: LD_INT 27
6590: PUSH
6591: LD_INT 28
6593: PUSH
6594: LD_INT 26
6596: PUSH
6597: LD_INT 25
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 1
6608: PPUSH
6609: LD_INT 4
6611: PPUSH
6612: CALL_OW 12
6616: ARRAY
6617: PPUSH
6618: LD_INT 88
6620: PPUSH
6621: CALL 70741 0 5
// un := CreateVehicle ;
6625: LD_ADDR_VAR 0 2
6629: PUSH
6630: CALL_OW 45
6634: ST_TO_ADDR
// tmp := tmp ^ un ;
6635: LD_ADDR_VAR 0 3
6639: PUSH
6640: LD_VAR 0 3
6644: PUSH
6645: LD_VAR 0 2
6649: ADD
6650: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6651: LD_VAR 0 2
6655: PPUSH
6656: LD_INT 3
6658: PPUSH
6659: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6663: LD_VAR 0 2
6667: PPUSH
6668: LD_INT 30
6670: PPUSH
6671: LD_INT 0
6673: PPUSH
6674: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6678: LD_VAR 0 2
6682: PPUSH
6683: LD_INT 16
6685: PPUSH
6686: LD_INT 11
6688: PPUSH
6689: CALL_OW 111
// wait ( 0 0$2 ) ;
6693: LD_INT 70
6695: PPUSH
6696: CALL_OW 67
// end ;
6700: GO 6541
6702: POP
6703: POP
// for i = 1 to Difficulty do
6704: LD_ADDR_VAR 0 1
6708: PUSH
6709: DOUBLE
6710: LD_INT 1
6712: DEC
6713: ST_TO_ADDR
6714: LD_OWVAR 67
6718: PUSH
6719: FOR_TO
6720: IFFALSE 6849
// begin uc_side := 8 ;
6722: LD_ADDR_OWVAR 20
6726: PUSH
6727: LD_INT 8
6729: ST_TO_ADDR
// uc_nation := 2 ;
6730: LD_ADDR_OWVAR 21
6734: PUSH
6735: LD_INT 2
6737: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6738: LD_INT 0
6740: PPUSH
6741: LD_INT 8
6743: PPUSH
6744: LD_INT 8
6746: PUSH
6747: LD_INT 8
6749: PUSH
6750: LD_INT 9
6752: PUSH
6753: LD_INT 10
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: PUSH
6762: LD_OWVAR 67
6766: ARRAY
6767: PPUSH
6768: CALL_OW 380
// un := CreateHuman ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: CALL_OW 44
6781: ST_TO_ADDR
// tmp := tmp ^ un ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: LD_VAR 0 2
6796: ADD
6797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6798: LD_VAR 0 2
6802: PPUSH
6803: LD_INT 3
6805: PPUSH
6806: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6810: LD_VAR 0 2
6814: PPUSH
6815: LD_INT 30
6817: PPUSH
6818: LD_INT 0
6820: PPUSH
6821: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 16
6832: PPUSH
6833: LD_INT 11
6835: PPUSH
6836: CALL_OW 111
// wait ( 0 0$2 ) ;
6840: LD_INT 70
6842: PPUSH
6843: CALL_OW 67
// end ;
6847: GO 6719
6849: POP
6850: POP
// repeat wait ( 0 0$1 ) ;
6851: LD_INT 35
6853: PPUSH
6854: CALL_OW 67
// for i in tmp do
6858: LD_ADDR_VAR 0 1
6862: PUSH
6863: LD_VAR 0 3
6867: PUSH
6868: FOR_IN
6869: IFFALSE 7005
// begin if GetLives ( i ) > 250 then
6871: LD_VAR 0 1
6875: PPUSH
6876: CALL_OW 256
6880: PUSH
6881: LD_INT 250
6883: GREATER
6884: IFFALSE 6976
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6886: LD_INT 81
6888: PUSH
6889: LD_INT 8
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 91
6898: PUSH
6899: LD_VAR 0 1
6903: PUSH
6904: LD_INT 10
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: LIST
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: PPUSH
6916: CALL_OW 69
6920: NOT
6921: IFFALSE 6940
// ComAgressiveMove ( i , 67 , 110 ) else
6923: LD_VAR 0 1
6927: PPUSH
6928: LD_INT 67
6930: PPUSH
6931: LD_INT 110
6933: PPUSH
6934: CALL_OW 114
6938: GO 6974
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6940: LD_VAR 0 1
6944: PPUSH
6945: LD_INT 81
6947: PUSH
6948: LD_INT 8
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: PPUSH
6955: CALL_OW 69
6959: PPUSH
6960: LD_VAR 0 1
6964: PPUSH
6965: CALL_OW 74
6969: PPUSH
6970: CALL_OW 115
// end else
6974: GO 7003
// if IsDead ( i ) then
6976: LD_VAR 0 1
6980: PPUSH
6981: CALL_OW 301
6985: IFFALSE 7003
// tmp := tmp diff i ;
6987: LD_ADDR_VAR 0 3
6991: PUSH
6992: LD_VAR 0 3
6996: PUSH
6997: LD_VAR 0 1
7001: DIFF
7002: ST_TO_ADDR
// end ;
7003: GO 6868
7005: POP
7006: POP
// until not tmp ;
7007: LD_VAR 0 3
7011: NOT
7012: IFFALSE 6851
// end ; end_of_file
7014: PPOPN 3
7016: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7017: LD_INT 0
7019: PPUSH
7020: PPUSH
7021: PPUSH
7022: PPUSH
7023: PPUSH
7024: PPUSH
7025: PPUSH
7026: PPUSH
7027: PPUSH
// side := 3 ;
7028: LD_ADDR_VAR 0 6
7032: PUSH
7033: LD_INT 3
7035: ST_TO_ADDR
// uc_side := side ;
7036: LD_ADDR_OWVAR 20
7040: PUSH
7041: LD_VAR 0 6
7045: ST_TO_ADDR
// uc_nation := 3 ;
7046: LD_ADDR_OWVAR 21
7050: PUSH
7051: LD_INT 3
7053: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7054: LD_ADDR_VAR 0 2
7058: PUSH
7059: LD_INT 22
7061: PUSH
7062: LD_VAR 0 6
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PUSH
7071: LD_INT 21
7073: PUSH
7074: LD_INT 3
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: PPUSH
7085: CALL_OW 69
7089: PUSH
7090: FOR_IN
7091: IFFALSE 7107
// SetBLevel ( i , 10 ) ;
7093: LD_VAR 0 2
7097: PPUSH
7098: LD_INT 10
7100: PPUSH
7101: CALL_OW 241
7105: GO 7090
7107: POP
7108: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7109: LD_ADDR_VAR 0 9
7113: PUSH
7114: LD_INT 22
7116: PUSH
7117: LD_VAR 0 6
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: PUSH
7126: LD_INT 30
7128: PUSH
7129: LD_INT 34
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: PPUSH
7140: CALL_OW 69
7144: ST_TO_ADDR
// if teleport then
7145: LD_VAR 0 9
7149: IFFALSE 7170
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7151: LD_VAR 0 9
7155: PUSH
7156: LD_INT 1
7158: ARRAY
7159: PPUSH
7160: LD_INT 123
7162: PPUSH
7163: LD_INT 122
7165: PPUSH
7166: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7170: LD_ADDR_EXP 64
7174: PUSH
7175: LD_STRING Platonov
7177: PPUSH
7178: CALL_OW 25
7182: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7183: LD_ADDR_EXP 65
7187: PUSH
7188: LD_STRING Kovalyuk
7190: PPUSH
7191: CALL_OW 25
7195: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7196: LD_ADDR_EXP 67
7200: PUSH
7201: LD_STRING Yakotich
7203: PPUSH
7204: LD_EXP 1
7208: NOT
7209: PPUSH
7210: LD_STRING 09_
7212: PPUSH
7213: CALL 65877 0 3
7217: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7218: LD_ADDR_EXP 66
7222: PUSH
7223: LD_STRING Bystrov
7225: PPUSH
7226: CALL_OW 25
7230: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7231: LD_ADDR_EXP 68
7235: PUSH
7236: LD_STRING Gleb
7238: PPUSH
7239: CALL_OW 25
7243: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7244: LD_STRING 03_Cornel
7246: PPUSH
7247: CALL_OW 28
7251: IFFALSE 7299
// begin Bierezov := NewCharacter ( Mikhail ) ;
7253: LD_ADDR_EXP 69
7257: PUSH
7258: LD_STRING Mikhail
7260: PPUSH
7261: CALL_OW 25
7265: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7266: LD_EXP 69
7270: PPUSH
7271: LD_INT 197
7273: PPUSH
7274: LD_INT 111
7276: PPUSH
7277: LD_INT 9
7279: PPUSH
7280: LD_INT 0
7282: PPUSH
7283: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7287: LD_EXP 69
7291: PPUSH
7292: LD_INT 3
7294: PPUSH
7295: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7299: LD_EXP 64
7303: PPUSH
7304: LD_INT 126
7306: PPUSH
7307: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7311: LD_EXP 65
7315: PPUSH
7316: LD_INT 134
7318: PPUSH
7319: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7323: LD_EXP 67
7327: PPUSH
7328: LD_INT 197
7330: PPUSH
7331: LD_INT 111
7333: PPUSH
7334: LD_INT 9
7336: PPUSH
7337: LD_INT 0
7339: PPUSH
7340: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7344: LD_EXP 66
7348: PPUSH
7349: LD_INT 197
7351: PPUSH
7352: LD_INT 111
7354: PPUSH
7355: LD_INT 9
7357: PPUSH
7358: LD_INT 0
7360: PPUSH
7361: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7365: LD_EXP 68
7369: PPUSH
7370: LD_INT 197
7372: PPUSH
7373: LD_INT 111
7375: PPUSH
7376: LD_INT 9
7378: PPUSH
7379: LD_INT 0
7381: PPUSH
7382: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7386: LD_ADDR_VAR 0 5
7390: PUSH
7391: LD_INT 126
7393: PPUSH
7394: LD_INT 4
7396: PPUSH
7397: LD_STRING zhukov
7399: PPUSH
7400: LD_INT 9
7402: PUSH
7403: LD_INT 10
7405: PUSH
7406: LD_INT 10
7408: PUSH
7409: LD_INT 10
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: LIST
7416: LIST
7417: PUSH
7418: LD_OWVAR 67
7422: ARRAY
7423: PPUSH
7424: LD_INT 90000
7426: PUSH
7427: LD_INT 1000
7429: PUSH
7430: LD_INT 300
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: LIST
7437: PPUSH
7438: LD_INT 18
7440: PUSH
7441: LD_INT 8
7443: PUSH
7444: LD_INT 13
7446: PUSH
7447: LD_INT 8
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: LIST
7454: LIST
7455: PPUSH
7456: CALL 74187 0 6
7460: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7461: LD_ADDR_VAR 0 4
7465: PUSH
7466: LD_INT 267
7468: PPUSH
7469: CALL_OW 274
7473: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7474: LD_VAR 0 4
7478: PPUSH
7479: LD_INT 1
7481: PPUSH
7482: LD_INT 5000
7484: PPUSH
7485: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7489: LD_VAR 0 4
7493: PPUSH
7494: LD_INT 2
7496: PPUSH
7497: LD_INT 200
7499: PPUSH
7500: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7504: LD_VAR 0 4
7508: PPUSH
7509: LD_INT 3
7511: PPUSH
7512: LD_INT 200
7514: PPUSH
7515: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7519: LD_ADDR_EXP 116
7523: PUSH
7524: LD_EXP 116
7528: PPUSH
7529: LD_INT 2
7531: PPUSH
7532: LD_VAR 0 5
7536: PUSH
7537: LD_INT 22
7539: PUSH
7540: LD_VAR 0 6
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: PUSH
7549: LD_INT 3
7551: PUSH
7552: LD_INT 21
7554: PUSH
7555: LD_INT 2
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PPUSH
7570: CALL_OW 69
7574: UNION
7575: PUSH
7576: LD_EXP 64
7580: DIFF
7581: PPUSH
7582: CALL_OW 1
7586: ST_TO_ADDR
// behemoths := [ ] ;
7587: LD_ADDR_EXP 72
7591: PUSH
7592: EMPTY
7593: ST_TO_ADDR
// behemothBuilders := [ ] ;
7594: LD_ADDR_EXP 73
7598: PUSH
7599: EMPTY
7600: ST_TO_ADDR
// if Kovalyuk then
7601: LD_EXP 65
7605: IFFALSE 7627
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7607: LD_ADDR_EXP 73
7611: PUSH
7612: LD_EXP 73
7616: PPUSH
7617: LD_EXP 65
7621: PPUSH
7622: CALL 102614 0 2
7626: ST_TO_ADDR
// j := 3 ;
7627: LD_ADDR_VAR 0 3
7631: PUSH
7632: LD_INT 3
7634: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7635: LD_ADDR_VAR 0 2
7639: PUSH
7640: LD_INT 22
7642: PUSH
7643: LD_INT 3
7645: PUSH
7646: EMPTY
7647: LIST
7648: LIST
7649: PUSH
7650: LD_INT 25
7652: PUSH
7653: LD_INT 3
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: PUSH
7660: EMPTY
7661: LIST
7662: LIST
7663: PPUSH
7664: CALL_OW 69
7668: PUSH
7669: LD_EXP 65
7673: DIFF
7674: PUSH
7675: FOR_IN
7676: IFFALSE 7726
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7678: LD_ADDR_EXP 73
7682: PUSH
7683: LD_EXP 73
7687: PPUSH
7688: LD_VAR 0 2
7692: PPUSH
7693: CALL 102614 0 2
7697: ST_TO_ADDR
// j := j - 1 ;
7698: LD_ADDR_VAR 0 3
7702: PUSH
7703: LD_VAR 0 3
7707: PUSH
7708: LD_INT 1
7710: MINUS
7711: ST_TO_ADDR
// if j = 0 then
7712: LD_VAR 0 3
7716: PUSH
7717: LD_INT 0
7719: EQUAL
7720: IFFALSE 7724
// break ;
7722: GO 7726
// end ;
7724: GO 7675
7726: POP
7727: POP
// end ;
7728: LD_VAR 0 1
7732: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7733: LD_INT 0
7735: PPUSH
7736: PPUSH
7737: PPUSH
7738: PPUSH
7739: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7740: LD_ADDR_VAR 0 4
7744: PUSH
7745: LD_INT 209
7747: PUSH
7748: LD_INT 149
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: PUSH
7755: LD_INT 219
7757: PUSH
7758: LD_INT 154
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PUSH
7765: LD_INT 223
7767: PUSH
7768: LD_INT 149
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: LD_INT 232
7777: PUSH
7778: LD_INT 155
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: LIST
7789: LIST
7790: ST_TO_ADDR
// if not behemothBuilders then
7791: LD_EXP 73
7795: NOT
7796: IFFALSE 7800
// exit ;
7798: GO 7904
// j := 1 ;
7800: LD_ADDR_VAR 0 3
7804: PUSH
7805: LD_INT 1
7807: ST_TO_ADDR
// for i in behemothBuilders do
7808: LD_ADDR_VAR 0 2
7812: PUSH
7813: LD_EXP 73
7817: PUSH
7818: FOR_IN
7819: IFFALSE 7902
// begin if IsInUnit ( i ) then
7821: LD_VAR 0 2
7825: PPUSH
7826: CALL_OW 310
7830: IFFALSE 7841
// ComExitBuilding ( i ) ;
7832: LD_VAR 0 2
7836: PPUSH
7837: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7841: LD_VAR 0 2
7845: PPUSH
7846: LD_INT 37
7848: PPUSH
7849: LD_VAR 0 4
7853: PUSH
7854: LD_VAR 0 3
7858: ARRAY
7859: PUSH
7860: LD_INT 1
7862: ARRAY
7863: PPUSH
7864: LD_VAR 0 4
7868: PUSH
7869: LD_VAR 0 3
7873: ARRAY
7874: PUSH
7875: LD_INT 2
7877: ARRAY
7878: PPUSH
7879: LD_INT 0
7881: PPUSH
7882: CALL_OW 230
// j := j + 1 ;
7886: LD_ADDR_VAR 0 3
7890: PUSH
7891: LD_VAR 0 3
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// end ;
7900: GO 7818
7902: POP
7903: POP
// end ;
7904: LD_VAR 0 1
7908: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7909: LD_INT 24
7911: PPUSH
7912: LD_INT 30
7914: PUSH
7915: LD_INT 37
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PPUSH
7922: CALL_OW 70
7926: IFFALSE 7939
7928: GO 7930
7930: DISABLE
// behemothUnderConstruct := true ;
7931: LD_ADDR_EXP 26
7935: PUSH
7936: LD_INT 1
7938: ST_TO_ADDR
7939: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7940: LD_INT 3
7942: PPUSH
7943: CALL 102675 0 1
7947: PUSH
7948: LD_INT 22
7950: PUSH
7951: LD_INT 3
7953: PUSH
7954: EMPTY
7955: LIST
7956: LIST
7957: PUSH
7958: LD_INT 30
7960: PUSH
7961: LD_INT 37
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: PUSH
7968: EMPTY
7969: LIST
7970: LIST
7971: PPUSH
7972: CALL_OW 69
7976: NOT
7977: AND
7978: IFFALSE 8164
7980: GO 7982
7982: DISABLE
7983: LD_INT 0
7985: PPUSH
7986: PPUSH
// begin enable ;
7987: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7988: LD_ADDR_VAR 0 2
7992: PUSH
7993: LD_INT 3
7995: PPUSH
7996: CALL 102675 0 1
8000: ST_TO_ADDR
// for i in tmp do
8001: LD_ADDR_VAR 0 1
8005: PUSH
8006: LD_VAR 0 2
8010: PUSH
8011: FOR_IN
8012: IFFALSE 8162
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8014: LD_VAR 0 1
8018: PPUSH
8019: LD_INT 9
8021: PPUSH
8022: CALL_OW 308
8026: PUSH
8027: LD_VAR 0 1
8031: PPUSH
8032: CALL_OW 110
8036: PUSH
8037: LD_INT 2
8039: EQUAL
8040: NOT
8041: AND
8042: IFFALSE 8056
// SetTag ( i , 2 ) ;
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_INT 2
8051: PPUSH
8052: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8056: LD_INT 81
8058: PUSH
8059: LD_INT 3
8061: PUSH
8062: EMPTY
8063: LIST
8064: LIST
8065: PUSH
8066: LD_INT 91
8068: PUSH
8069: LD_VAR 0 1
8073: PUSH
8074: LD_INT 12
8076: PUSH
8077: EMPTY
8078: LIST
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PPUSH
8086: CALL_OW 69
8090: NOT
8091: PUSH
8092: LD_VAR 0 1
8096: PPUSH
8097: CALL_OW 110
8101: PUSH
8102: LD_INT 2
8104: EQUAL
8105: NOT
8106: AND
8107: IFFALSE 8126
// ComAgressiveMove ( i , 64 , 93 ) else
8109: LD_VAR 0 1
8113: PPUSH
8114: LD_INT 64
8116: PPUSH
8117: LD_INT 93
8119: PPUSH
8120: CALL_OW 114
8124: GO 8160
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8126: LD_VAR 0 1
8130: PPUSH
8131: LD_INT 81
8133: PUSH
8134: LD_INT 3
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: PPUSH
8141: CALL_OW 69
8145: PPUSH
8146: LD_VAR 0 1
8150: PPUSH
8151: CALL_OW 74
8155: PPUSH
8156: CALL_OW 115
// end ;
8160: GO 8011
8162: POP
8163: POP
// end ;
8164: PPOPN 2
8166: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8167: LD_INT 0
8169: PPUSH
8170: PPUSH
8171: PPUSH
// result := [ ] ;
8172: LD_ADDR_VAR 0 2
8176: PUSH
8177: EMPTY
8178: ST_TO_ADDR
// uc_side := 6 ;
8179: LD_ADDR_OWVAR 20
8183: PUSH
8184: LD_INT 6
8186: ST_TO_ADDR
// uc_nation := 3 ;
8187: LD_ADDR_OWVAR 21
8191: PUSH
8192: LD_INT 3
8194: ST_TO_ADDR
// case strength of 1 :
8195: LD_VAR 0 1
8199: PUSH
8200: LD_INT 1
8202: DOUBLE
8203: EQUAL
8204: IFTRUE 8208
8206: GO 8350
8208: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8209: LD_ADDR_VAR 0 3
8213: PUSH
8214: DOUBLE
8215: LD_INT 1
8217: DEC
8218: ST_TO_ADDR
8219: LD_INT 4
8221: PUSH
8222: LD_INT 5
8224: PUSH
8225: LD_INT 6
8227: PUSH
8228: LD_INT 7
8230: PUSH
8231: EMPTY
8232: LIST
8233: LIST
8234: LIST
8235: LIST
8236: PUSH
8237: LD_OWVAR 67
8241: ARRAY
8242: PUSH
8243: FOR_TO
8244: IFFALSE 8346
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8246: LD_INT 22
8248: PUSH
8249: LD_INT 24
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: PUSH
8256: LD_VAR 0 3
8260: PUSH
8261: LD_INT 2
8263: MOD
8264: PUSH
8265: LD_INT 1
8267: PLUS
8268: ARRAY
8269: PPUSH
8270: LD_INT 1
8272: PUSH
8273: LD_INT 3
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PUSH
8280: LD_INT 1
8282: PPUSH
8283: LD_INT 2
8285: PPUSH
8286: CALL_OW 12
8290: ARRAY
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 43
8297: PUSH
8298: LD_INT 44
8300: PUSH
8301: LD_INT 45
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: LIST
8308: PUSH
8309: LD_INT 1
8311: PPUSH
8312: LD_INT 3
8314: PPUSH
8315: CALL_OW 12
8319: ARRAY
8320: PPUSH
8321: LD_INT 80
8323: PPUSH
8324: CALL 70741 0 5
// result := result union CreateVehicle ;
8328: LD_ADDR_VAR 0 2
8332: PUSH
8333: LD_VAR 0 2
8337: PUSH
8338: CALL_OW 45
8342: UNION
8343: ST_TO_ADDR
// end ;
8344: GO 8243
8346: POP
8347: POP
// end ; 2 :
8348: GO 9313
8350: LD_INT 2
8352: DOUBLE
8353: EQUAL
8354: IFTRUE 8358
8356: GO 8518
8358: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8359: LD_ADDR_VAR 0 3
8363: PUSH
8364: DOUBLE
8365: LD_INT 1
8367: DEC
8368: ST_TO_ADDR
8369: LD_INT 5
8371: PUSH
8372: LD_INT 6
8374: PUSH
8375: LD_INT 7
8377: PUSH
8378: LD_INT 8
8380: PUSH
8381: EMPTY
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_OWVAR 67
8391: ARRAY
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8514
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8396: LD_INT 22
8398: PUSH
8399: LD_INT 24
8401: PUSH
8402: LD_INT 24
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: LD_VAR 0 3
8414: PUSH
8415: LD_INT 3
8417: MOD
8418: PUSH
8419: LD_INT 1
8421: PLUS
8422: ARRAY
8423: PPUSH
8424: LD_INT 1
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 2
8439: PPUSH
8440: CALL_OW 12
8444: ARRAY
8445: PPUSH
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 43
8451: PUSH
8452: LD_INT 44
8454: PUSH
8455: LD_INT 45
8457: PUSH
8458: LD_INT 44
8460: PUSH
8461: LD_INT 46
8463: PUSH
8464: LD_INT 46
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: PUSH
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 6
8482: MOD
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: ARRAY
8488: PPUSH
8489: LD_INT 80
8491: PPUSH
8492: CALL 70741 0 5
// result := result union CreateVehicle ;
8496: LD_ADDR_VAR 0 2
8500: PUSH
8501: LD_VAR 0 2
8505: PUSH
8506: CALL_OW 45
8510: UNION
8511: ST_TO_ADDR
// end ;
8512: GO 8393
8514: POP
8515: POP
// end ; 3 :
8516: GO 9313
8518: LD_INT 3
8520: DOUBLE
8521: EQUAL
8522: IFTRUE 8526
8524: GO 8686
8526: POP
// begin for i = 1 to [ 5 , 7 , 8 , 9 ] [ Difficulty ] do
8527: LD_ADDR_VAR 0 3
8531: PUSH
8532: DOUBLE
8533: LD_INT 1
8535: DEC
8536: ST_TO_ADDR
8537: LD_INT 5
8539: PUSH
8540: LD_INT 7
8542: PUSH
8543: LD_INT 8
8545: PUSH
8546: LD_INT 9
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: LIST
8553: LIST
8554: PUSH
8555: LD_OWVAR 67
8559: ARRAY
8560: PUSH
8561: FOR_TO
8562: IFFALSE 8682
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8564: LD_INT 22
8566: PUSH
8567: LD_INT 24
8569: PUSH
8570: LD_INT 24
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: LIST
8577: PUSH
8578: LD_VAR 0 3
8582: PUSH
8583: LD_INT 3
8585: MOD
8586: PUSH
8587: LD_INT 1
8589: PLUS
8590: ARRAY
8591: PPUSH
8592: LD_INT 1
8594: PUSH
8595: LD_INT 3
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: PUSH
8602: LD_INT 1
8604: PPUSH
8605: LD_INT 2
8607: PPUSH
8608: CALL_OW 12
8612: ARRAY
8613: PPUSH
8614: LD_INT 3
8616: PPUSH
8617: LD_INT 43
8619: PUSH
8620: LD_INT 47
8622: PUSH
8623: LD_INT 45
8625: PUSH
8626: LD_INT 45
8628: PUSH
8629: LD_INT 46
8631: PUSH
8632: LD_INT 46
8634: PUSH
8635: EMPTY
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: LIST
8641: LIST
8642: PUSH
8643: LD_VAR 0 3
8647: PUSH
8648: LD_INT 6
8650: MOD
8651: PUSH
8652: LD_INT 1
8654: PLUS
8655: ARRAY
8656: PPUSH
8657: LD_INT 80
8659: PPUSH
8660: CALL 70741 0 5
// result := result union CreateVehicle ;
8664: LD_ADDR_VAR 0 2
8668: PUSH
8669: LD_VAR 0 2
8673: PUSH
8674: CALL_OW 45
8678: UNION
8679: ST_TO_ADDR
// end ;
8680: GO 8561
8682: POP
8683: POP
// end ; 4 :
8684: GO 9313
8686: LD_INT 4
8688: DOUBLE
8689: EQUAL
8690: IFTRUE 8694
8692: GO 9312
8694: POP
// begin uc_nation := 3 ;
8695: LD_ADDR_OWVAR 21
8699: PUSH
8700: LD_INT 3
8702: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8703: LD_ADDR_VAR 0 3
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 6
8715: PUSH
8716: LD_INT 8
8718: PUSH
8719: LD_INT 9
8721: PUSH
8722: LD_INT 10
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: LIST
8729: LIST
8730: PUSH
8731: LD_OWVAR 67
8735: ARRAY
8736: PUSH
8737: FOR_TO
8738: IFFALSE 8858
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8740: LD_INT 22
8742: PUSH
8743: LD_INT 24
8745: PUSH
8746: LD_INT 24
8748: PUSH
8749: EMPTY
8750: LIST
8751: LIST
8752: LIST
8753: PUSH
8754: LD_VAR 0 3
8758: PUSH
8759: LD_INT 3
8761: MOD
8762: PUSH
8763: LD_INT 1
8765: PLUS
8766: ARRAY
8767: PPUSH
8768: LD_INT 1
8770: PUSH
8771: LD_INT 3
8773: PUSH
8774: EMPTY
8775: LIST
8776: LIST
8777: PUSH
8778: LD_INT 1
8780: PPUSH
8781: LD_INT 2
8783: PPUSH
8784: CALL_OW 12
8788: ARRAY
8789: PPUSH
8790: LD_INT 3
8792: PPUSH
8793: LD_INT 45
8795: PUSH
8796: LD_INT 47
8798: PUSH
8799: LD_INT 47
8801: PUSH
8802: LD_INT 45
8804: PUSH
8805: LD_INT 46
8807: PUSH
8808: LD_INT 46
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: LIST
8816: LIST
8817: LIST
8818: PUSH
8819: LD_VAR 0 3
8823: PUSH
8824: LD_INT 6
8826: MOD
8827: PUSH
8828: LD_INT 1
8830: PLUS
8831: ARRAY
8832: PPUSH
8833: LD_INT 80
8835: PPUSH
8836: CALL 70741 0 5
// result := result union CreateVehicle ;
8840: LD_ADDR_VAR 0 2
8844: PUSH
8845: LD_VAR 0 2
8849: PUSH
8850: CALL_OW 45
8854: UNION
8855: ST_TO_ADDR
// end ;
8856: GO 8737
8858: POP
8859: POP
// if not KappaStatus then
8860: LD_EXP 2
8864: NOT
8865: IFFALSE 9100
// begin uc_nation := 1 ;
8867: LD_ADDR_OWVAR 21
8871: PUSH
8872: LD_INT 1
8874: ST_TO_ADDR
// for i = 1 to 3 do
8875: LD_ADDR_VAR 0 3
8879: PUSH
8880: DOUBLE
8881: LD_INT 1
8883: DEC
8884: ST_TO_ADDR
8885: LD_INT 3
8887: PUSH
8888: FOR_TO
8889: IFFALSE 9025
// begin j := rand ( 0 , 1 ) ;
8891: LD_ADDR_VAR 0 4
8895: PUSH
8896: LD_INT 0
8898: PPUSH
8899: LD_INT 1
8901: PPUSH
8902: CALL_OW 12
8906: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8907: LD_INT 3
8909: PUSH
8910: LD_INT 5
8912: PUSH
8913: LD_INT 5
8915: PUSH
8916: LD_INT 4
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: PUSH
8925: LD_VAR 0 4
8929: PUSH
8930: LD_INT 1
8932: PPUSH
8933: LD_INT 3
8935: PPUSH
8936: CALL_OW 12
8940: PLUS
8941: ARRAY
8942: PPUSH
8943: LD_INT 1
8945: PUSH
8946: LD_INT 3
8948: PUSH
8949: EMPTY
8950: LIST
8951: LIST
8952: PUSH
8953: LD_INT 1
8955: PPUSH
8956: LD_INT 2
8958: PPUSH
8959: CALL_OW 12
8963: ARRAY
8964: PPUSH
8965: LD_INT 3
8967: PPUSH
8968: LD_INT 9
8970: PUSH
8971: LD_INT 7
8973: PUSH
8974: LD_INT 6
8976: PUSH
8977: EMPTY
8978: LIST
8979: LIST
8980: LIST
8981: PUSH
8982: LD_VAR 0 4
8986: PUSH
8987: LD_INT 1
8989: PPUSH
8990: LD_INT 2
8992: PPUSH
8993: CALL_OW 12
8997: PLUS
8998: ARRAY
8999: PPUSH
9000: LD_INT 85
9002: PPUSH
9003: CALL 70741 0 5
// result := result union CreateVehicle ;
9007: LD_ADDR_VAR 0 2
9011: PUSH
9012: LD_VAR 0 2
9016: PUSH
9017: CALL_OW 45
9021: UNION
9022: ST_TO_ADDR
// end ;
9023: GO 8888
9025: POP
9026: POP
// if vsevolodFirstAttack then
9027: LD_EXP 24
9031: IFFALSE 9098
// begin vsevolodFirstAttack := false ;
9033: LD_ADDR_EXP 24
9037: PUSH
9038: LD_INT 0
9040: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9041: LD_INT 5
9043: PPUSH
9044: LD_INT 3
9046: PPUSH
9047: LD_INT 1
9049: PPUSH
9050: LD_INT 6
9052: PPUSH
9053: LD_INT 100
9055: PPUSH
9056: CALL 70741 0 5
// sewiVeh := CreateVehicle ;
9060: LD_ADDR_EXP 71
9064: PUSH
9065: CALL_OW 45
9069: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9070: LD_EXP 71
9074: PPUSH
9075: LD_INT 1
9077: PPUSH
9078: CALL_OW 242
// result := result union sewiVeh ;
9082: LD_ADDR_VAR 0 2
9086: PUSH
9087: LD_VAR 0 2
9091: PUSH
9092: LD_EXP 71
9096: UNION
9097: ST_TO_ADDR
// end ; end else
9098: GO 9310
// if vsevolodFirstAttack then
9100: LD_EXP 24
9104: IFFALSE 9310
// begin vsevolodFirstAttack := false ;
9106: LD_ADDR_EXP 24
9110: PUSH
9111: LD_INT 0
9113: ST_TO_ADDR
// uc_nation := 3 ;
9114: LD_ADDR_OWVAR 21
9118: PUSH
9119: LD_INT 3
9121: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9122: LD_ADDR_VAR 0 3
9126: PUSH
9127: DOUBLE
9128: LD_INT 1
9130: DEC
9131: ST_TO_ADDR
9132: LD_INT 2
9134: PUSH
9135: LD_OWVAR 67
9139: PLUS
9140: PUSH
9141: FOR_TO
9142: IFFALSE 9250
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9144: LD_INT 22
9146: PUSH
9147: LD_INT 24
9149: PUSH
9150: LD_INT 24
9152: PUSH
9153: EMPTY
9154: LIST
9155: LIST
9156: LIST
9157: PUSH
9158: LD_VAR 0 3
9162: PUSH
9163: LD_INT 3
9165: MOD
9166: PUSH
9167: LD_INT 1
9169: PLUS
9170: ARRAY
9171: PPUSH
9172: LD_INT 1
9174: PUSH
9175: LD_INT 3
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: CALL_OW 12
9192: ARRAY
9193: PPUSH
9194: LD_INT 1
9196: PPUSH
9197: LD_INT 45
9199: PUSH
9200: LD_INT 47
9202: PUSH
9203: LD_INT 47
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: LIST
9210: PUSH
9211: LD_VAR 0 3
9215: PUSH
9216: LD_INT 3
9218: MOD
9219: PUSH
9220: LD_INT 1
9222: PLUS
9223: ARRAY
9224: PPUSH
9225: LD_INT 80
9227: PPUSH
9228: CALL 70741 0 5
// result := result union CreateVehicle ;
9232: LD_ADDR_VAR 0 2
9236: PUSH
9237: LD_VAR 0 2
9241: PUSH
9242: CALL_OW 45
9246: UNION
9247: ST_TO_ADDR
// end ;
9248: GO 9141
9250: POP
9251: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9252: LD_INT 24
9254: PPUSH
9255: LD_INT 3
9257: PPUSH
9258: LD_INT 1
9260: PPUSH
9261: LD_INT 47
9263: PPUSH
9264: LD_INT 100
9266: PPUSH
9267: CALL 70741 0 5
// sewiVeh := CreateVehicle ;
9271: LD_ADDR_EXP 71
9275: PUSH
9276: CALL_OW 45
9280: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9281: LD_EXP 71
9285: PPUSH
9286: LD_INT 6
9288: NEG
9289: PPUSH
9290: CALL_OW 242
// result := result union sewiVeh ;
9294: LD_ADDR_VAR 0 2
9298: PUSH
9299: LD_VAR 0 2
9303: PUSH
9304: LD_EXP 71
9308: UNION
9309: ST_TO_ADDR
// end ; end ; end ;
9310: GO 9313
9312: POP
// end ;
9313: LD_VAR 0 2
9317: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9318: LD_EXP 16
9322: IFFALSE 10167
9324: GO 9326
9326: DISABLE
9327: LD_INT 0
9329: PPUSH
9330: PPUSH
9331: PPUSH
9332: PPUSH
9333: PPUSH
9334: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9335: LD_ADDR_VAR 0 4
9339: PUSH
9340: LD_INT 11
9342: PUSH
9343: LD_INT 12
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9350: LD_ADDR_VAR 0 3
9354: PUSH
9355: LD_INT 11550
9357: PUSH
9358: LD_INT 10150
9360: PUSH
9361: LD_INT 9800
9363: PUSH
9364: LD_INT 9450
9366: PUSH
9367: EMPTY
9368: LIST
9369: LIST
9370: LIST
9371: LIST
9372: PUSH
9373: LD_OWVAR 67
9377: ARRAY
9378: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9379: LD_ADDR_VAR 0 6
9383: PUSH
9384: LD_INT 70
9386: PUSH
9387: LD_INT 118
9389: PUSH
9390: EMPTY
9391: LIST
9392: LIST
9393: PUSH
9394: LD_INT 78
9396: PUSH
9397: LD_INT 31
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: PUSH
9404: EMPTY
9405: LIST
9406: LIST
9407: ST_TO_ADDR
// repeat if missionStage = 2 then
9408: LD_EXP 15
9412: PUSH
9413: LD_INT 2
9415: EQUAL
9416: IFFALSE 9427
// wait ( 1 1$30 ) else
9418: LD_INT 3150
9420: PPUSH
9421: CALL_OW 67
9425: GO 9436
// wait ( time ) ;
9427: LD_VAR 0 3
9431: PPUSH
9432: CALL_OW 67
// if missionStage = 6 then
9436: LD_EXP 15
9440: PUSH
9441: LD_INT 6
9443: EQUAL
9444: IFFALSE 9472
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9446: LD_INT 51
9448: PPUSH
9449: LD_INT 6
9451: PPUSH
9452: LD_INT 2
9454: PPUSH
9455: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9459: LD_INT 57
9461: PPUSH
9462: LD_INT 6
9464: PPUSH
9465: LD_INT 2
9467: PPUSH
9468: CALL_OW 322
// end ; if missionStage = 8 then
9472: LD_EXP 15
9476: PUSH
9477: LD_INT 8
9479: EQUAL
9480: IFFALSE 9508
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9482: LD_INT 52
9484: PPUSH
9485: LD_INT 6
9487: PPUSH
9488: LD_INT 2
9490: PPUSH
9491: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9495: LD_INT 58
9497: PPUSH
9498: LD_INT 6
9500: PPUSH
9501: LD_INT 2
9503: PPUSH
9504: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9508: LD_EXP 15
9512: PUSH
9513: LD_INT 10
9515: EQUAL
9516: PUSH
9517: LD_OWVAR 67
9521: PUSH
9522: LD_INT 1
9524: GREATER
9525: AND
9526: IFFALSE 9554
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9528: LD_INT 53
9530: PPUSH
9531: LD_INT 6
9533: PPUSH
9534: LD_INT 2
9536: PPUSH
9537: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9541: LD_INT 59
9543: PPUSH
9544: LD_INT 6
9546: PPUSH
9547: LD_INT 2
9549: PPUSH
9550: CALL_OW 322
// end ; if activeAttacks then
9554: LD_EXP 16
9558: IFFALSE 10161
// begin if missionStage = 2 then
9560: LD_EXP 15
9564: PUSH
9565: LD_INT 2
9567: EQUAL
9568: IFFALSE 9578
// strength := 1 ;
9570: LD_ADDR_VAR 0 5
9574: PUSH
9575: LD_INT 1
9577: ST_TO_ADDR
// if missionStage > 2 then
9578: LD_EXP 15
9582: PUSH
9583: LD_INT 2
9585: GREATER
9586: IFFALSE 9596
// strength := 2 ;
9588: LD_ADDR_VAR 0 5
9592: PUSH
9593: LD_INT 2
9595: ST_TO_ADDR
// if missionStage > 6 then
9596: LD_EXP 15
9600: PUSH
9601: LD_INT 6
9603: GREATER
9604: IFFALSE 9614
// strength := 3 ;
9606: LD_ADDR_VAR 0 5
9610: PUSH
9611: LD_INT 3
9613: ST_TO_ADDR
// if missionStage > 10 then
9614: LD_EXP 15
9618: PUSH
9619: LD_INT 10
9621: GREATER
9622: IFFALSE 9632
// strength := 4 ;
9624: LD_ADDR_VAR 0 5
9628: PUSH
9629: LD_INT 4
9631: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9632: LD_ADDR_VAR 0 2
9636: PUSH
9637: LD_VAR 0 5
9641: PPUSH
9642: CALL 8167 0 1
9646: ST_TO_ADDR
// for i in tmp do
9647: LD_ADDR_VAR 0 1
9651: PUSH
9652: LD_VAR 0 2
9656: PUSH
9657: FOR_IN
9658: IFFALSE 9841
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9660: LD_VAR 0 1
9664: PPUSH
9665: LD_VAR 0 4
9669: PUSH
9670: LD_INT 1
9672: PPUSH
9673: LD_INT 2
9675: PPUSH
9676: CALL_OW 12
9680: ARRAY
9681: PPUSH
9682: LD_INT 0
9684: PPUSH
9685: CALL_OW 49
// if i = sewiVeh then
9689: LD_VAR 0 1
9693: PUSH
9694: LD_EXP 71
9698: EQUAL
9699: IFFALSE 9736
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9701: LD_ADDR_EXP 70
9705: PUSH
9706: LD_STRING Vsevolod
9708: PPUSH
9709: LD_INT 0
9711: PPUSH
9712: LD_STRING 
9714: PPUSH
9715: CALL 65877 0 3
9719: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9720: LD_EXP 70
9724: PPUSH
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 52
// end else
9734: GO 9817
// if GetControl ( i ) = control_manual then
9736: LD_VAR 0 1
9740: PPUSH
9741: CALL_OW 263
9745: PUSH
9746: LD_INT 1
9748: EQUAL
9749: IFFALSE 9817
// begin uc_side := 6 ;
9751: LD_ADDR_OWVAR 20
9755: PUSH
9756: LD_INT 6
9758: ST_TO_ADDR
// uc_nation := 3 ;
9759: LD_ADDR_OWVAR 21
9763: PUSH
9764: LD_INT 3
9766: ST_TO_ADDR
// hc_gallery :=  ;
9767: LD_ADDR_OWVAR 33
9771: PUSH
9772: LD_STRING 
9774: ST_TO_ADDR
// hc_name :=  ;
9775: LD_ADDR_OWVAR 26
9779: PUSH
9780: LD_STRING 
9782: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9783: LD_INT 0
9785: PPUSH
9786: LD_INT 3
9788: PPUSH
9789: LD_INT 10
9791: PPUSH
9792: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9796: CALL_OW 44
9800: PPUSH
9801: LD_VAR 0 1
9805: PPUSH
9806: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9810: LD_INT 10
9812: PPUSH
9813: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9817: LD_VAR 0 1
9821: PPUSH
9822: LD_INT 111
9824: PPUSH
9825: LD_INT 197
9827: PPUSH
9828: CALL_OW 111
// wait ( 0 0$2 ) ;
9832: LD_INT 70
9834: PPUSH
9835: CALL_OW 67
// end ;
9839: GO 9657
9841: POP
9842: POP
// repeat wait ( 0 0$1 ) ;
9843: LD_INT 35
9845: PPUSH
9846: CALL_OW 67
// for i in tmp do
9850: LD_ADDR_VAR 0 1
9854: PUSH
9855: LD_VAR 0 2
9859: PUSH
9860: FOR_IN
9861: IFFALSE 10142
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9863: LD_INT 81
9865: PUSH
9866: LD_INT 6
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PUSH
9873: LD_INT 91
9875: PUSH
9876: LD_VAR 0 1
9880: PUSH
9881: LD_INT 12
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: LIST
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PPUSH
9893: CALL_OW 69
9897: IFFALSE 9955
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9899: LD_VAR 0 1
9903: PPUSH
9904: LD_INT 81
9906: PUSH
9907: LD_INT 6
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PUSH
9914: LD_INT 91
9916: PUSH
9917: LD_VAR 0 1
9921: PUSH
9922: LD_INT 12
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: LIST
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PPUSH
9934: CALL_OW 69
9938: PPUSH
9939: LD_VAR 0 1
9943: PPUSH
9944: CALL_OW 74
9948: PPUSH
9949: CALL_OW 115
9953: GO 10140
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9955: LD_INT 9
9957: PPUSH
9958: LD_INT 81
9960: PUSH
9961: LD_INT 6
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: PPUSH
9968: CALL_OW 70
9972: IFFALSE 10106
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_VAR 0 6
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PUSH
9988: LD_INT 1
9990: ARRAY
9991: PPUSH
9992: LD_VAR 0 6
9996: PUSH
9997: LD_INT 1
9999: ARRAY
10000: PUSH
10001: LD_INT 2
10003: ARRAY
10004: PPUSH
10005: CALL_OW 297
10009: PUSH
10010: LD_INT 10
10012: GREATER
10013: PUSH
10014: LD_VAR 0 1
10018: PPUSH
10019: LD_INT 9
10021: PPUSH
10022: CALL_OW 308
10026: NOT
10027: AND
10028: IFFALSE 10067
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
10030: LD_VAR 0 1
10034: PPUSH
10035: LD_VAR 0 6
10039: PUSH
10040: LD_INT 1
10042: ARRAY
10043: PUSH
10044: LD_INT 1
10046: ARRAY
10047: PPUSH
10048: LD_VAR 0 6
10052: PUSH
10053: LD_INT 1
10055: ARRAY
10056: PUSH
10057: LD_INT 2
10059: ARRAY
10060: PPUSH
10061: CALL_OW 114
10065: GO 10104
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10067: LD_VAR 0 1
10071: PPUSH
10072: LD_INT 9
10074: PPUSH
10075: LD_INT 81
10077: PUSH
10078: LD_INT 6
10080: PUSH
10081: EMPTY
10082: LIST
10083: LIST
10084: PPUSH
10085: CALL_OW 70
10089: PPUSH
10090: LD_VAR 0 1
10094: PPUSH
10095: CALL_OW 74
10099: PPUSH
10100: CALL_OW 115
// end else
10104: GO 10140
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10106: LD_VAR 0 1
10110: PPUSH
10111: LD_INT 81
10113: PUSH
10114: LD_INT 6
10116: PUSH
10117: EMPTY
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 69
10125: PPUSH
10126: LD_VAR 0 1
10130: PPUSH
10131: CALL_OW 74
10135: PPUSH
10136: CALL_OW 115
// end ;
10140: GO 9860
10142: POP
10143: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10144: LD_INT 22
10146: PUSH
10147: LD_INT 6
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: PPUSH
10154: CALL_OW 69
10158: NOT
10159: IFFALSE 9843
// end ; until russianDestroyed ;
10161: LD_EXP 21
10165: IFFALSE 9408
// end ;
10167: PPOPN 6
10169: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10170: LD_EXP 21
10174: NOT
10175: PUSH
10176: LD_EXP 15
10180: PUSH
10181: LD_INT 6
10183: GREATEREQUAL
10184: AND
10185: PUSH
10186: LD_INT 2
10188: PPUSH
10189: LD_INT 1
10191: PPUSH
10192: CALL 60889 0 2
10196: NOT
10197: AND
10198: IFFALSE 11158
10200: GO 10202
10202: DISABLE
10203: LD_INT 0
10205: PPUSH
10206: PPUSH
10207: PPUSH
10208: PPUSH
// begin enable ;
10209: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10210: LD_INT 22
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: PUSH
10220: LD_INT 30
10222: PUSH
10223: LD_INT 3
10225: PUSH
10226: EMPTY
10227: LIST
10228: LIST
10229: PUSH
10230: EMPTY
10231: LIST
10232: LIST
10233: PPUSH
10234: CALL_OW 69
10238: NOT
10239: IFFALSE 10243
// exit ;
10241: GO 11158
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10243: LD_ADDR_VAR 0 4
10247: PUSH
10248: LD_INT 22
10250: PUSH
10251: LD_INT 3
10253: PUSH
10254: EMPTY
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 30
10260: PUSH
10261: LD_INT 34
10263: PUSH
10264: EMPTY
10265: LIST
10266: LIST
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PPUSH
10272: CALL_OW 69
10276: ST_TO_ADDR
// if Prob ( 40 ) then
10277: LD_INT 40
10279: PPUSH
10280: CALL_OW 13
10284: IFFALSE 10411
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10286: LD_INT 2
10288: PPUSH
10289: LD_INT 22
10291: PUSH
10292: LD_INT 3
10294: PUSH
10295: LD_INT 3
10297: PUSH
10298: LD_INT 49
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: LD_INT 22
10309: PUSH
10310: LD_INT 3
10312: PUSH
10313: LD_INT 3
10315: PUSH
10316: LD_INT 49
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: PUSH
10325: LD_INT 22
10327: PUSH
10328: LD_INT 3
10330: PUSH
10331: LD_INT 3
10333: PUSH
10334: LD_INT 49
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: PUSH
10343: LD_INT 24
10345: PUSH
10346: LD_INT 3
10348: PUSH
10349: LD_INT 3
10351: PUSH
10352: LD_INT 46
10354: PUSH
10355: EMPTY
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: PUSH
10361: LD_INT 24
10363: PUSH
10364: LD_INT 3
10366: PUSH
10367: LD_INT 3
10369: PUSH
10370: LD_INT 46
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: PUSH
10379: LD_INT 24
10381: PUSH
10382: LD_INT 3
10384: PUSH
10385: LD_INT 3
10387: PUSH
10388: LD_INT 46
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: LIST
10395: LIST
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: PPUSH
10405: CALL 59471 0 2
// end else
10409: GO 10534
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10411: LD_INT 2
10413: PPUSH
10414: LD_INT 24
10416: PUSH
10417: LD_INT 3
10419: PUSH
10420: LD_INT 3
10422: PUSH
10423: LD_INT 47
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: LIST
10430: LIST
10431: PUSH
10432: LD_INT 24
10434: PUSH
10435: LD_INT 3
10437: PUSH
10438: LD_INT 3
10440: PUSH
10441: LD_INT 47
10443: PUSH
10444: EMPTY
10445: LIST
10446: LIST
10447: LIST
10448: LIST
10449: PUSH
10450: LD_INT 24
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: LD_INT 3
10458: PUSH
10459: LD_INT 47
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: PUSH
10468: LD_INT 24
10470: PUSH
10471: LD_INT 3
10473: PUSH
10474: LD_INT 3
10476: PUSH
10477: LD_INT 46
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: LIST
10484: LIST
10485: PUSH
10486: LD_INT 24
10488: PUSH
10489: LD_INT 3
10491: PUSH
10492: LD_INT 3
10494: PUSH
10495: LD_INT 46
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: LD_INT 24
10506: PUSH
10507: LD_INT 3
10509: PUSH
10510: LD_INT 3
10512: PUSH
10513: LD_INT 46
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: PUSH
10522: EMPTY
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PPUSH
10530: CALL 59471 0 2
// end ; if Difficulty > 1 then
10534: LD_OWVAR 67
10538: PUSH
10539: LD_INT 1
10541: GREATER
10542: IFFALSE 10572
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10544: LD_INT 2
10546: PPUSH
10547: LD_INT 24
10549: PUSH
10550: LD_INT 3
10552: PUSH
10553: LD_INT 3
10555: PUSH
10556: LD_INT 47
10558: PUSH
10559: EMPTY
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: PUSH
10565: EMPTY
10566: LIST
10567: PPUSH
10568: CALL 59471 0 2
// repeat wait ( 0 0$1 ) ;
10572: LD_INT 35
10574: PPUSH
10575: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10579: LD_INT 2
10581: PPUSH
10582: LD_INT 1
10584: PPUSH
10585: CALL 60889 0 2
10589: PUSH
10590: LD_INT 6
10592: PUSH
10593: LD_INT 7
10595: PUSH
10596: LD_INT 7
10598: PUSH
10599: LD_INT 7
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: PUSH
10608: LD_OWVAR 67
10612: ARRAY
10613: GREATEREQUAL
10614: IFFALSE 10572
// wait ( 0 0$30 ) ;
10616: LD_INT 1050
10618: PPUSH
10619: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10623: LD_ADDR_VAR 0 2
10627: PUSH
10628: LD_INT 2
10630: PPUSH
10631: LD_INT 1
10633: PPUSH
10634: CALL 60889 0 2
10638: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10639: LD_ADDR_EXP 135
10643: PUSH
10644: LD_EXP 135
10648: PPUSH
10649: LD_INT 2
10651: PPUSH
10652: LD_EXP 135
10656: PUSH
10657: LD_INT 2
10659: ARRAY
10660: PUSH
10661: LD_VAR 0 2
10665: DIFF
10666: PPUSH
10667: CALL_OW 1
10671: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10672: LD_ADDR_VAR 0 3
10676: PUSH
10677: LD_INT 0
10679: PPUSH
10680: LD_INT 1
10682: PPUSH
10683: CALL_OW 12
10687: ST_TO_ADDR
// if target then
10688: LD_VAR 0 3
10692: IFFALSE 10820
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10694: LD_ADDR_VAR 0 2
10698: PUSH
10699: LD_VAR 0 2
10703: PPUSH
10704: LD_INT 24
10706: PUSH
10707: LD_INT 250
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PPUSH
10714: CALL_OW 72
10718: ST_TO_ADDR
// for i in tmp do
10719: LD_ADDR_VAR 0 1
10723: PUSH
10724: LD_VAR 0 2
10728: PUSH
10729: FOR_IN
10730: IFFALSE 10770
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10732: LD_VAR 0 1
10736: PPUSH
10737: LD_INT 139
10739: PPUSH
10740: LD_INT 89
10742: PPUSH
10743: CALL_OW 297
10747: PUSH
10748: LD_INT 9
10750: GREATER
10751: IFFALSE 10768
// ComMoveXY ( i , 139 , 89 ) ;
10753: LD_VAR 0 1
10757: PPUSH
10758: LD_INT 139
10760: PPUSH
10761: LD_INT 89
10763: PPUSH
10764: CALL_OW 111
10768: GO 10729
10770: POP
10771: POP
// wait ( 0 0$1 ) ;
10772: LD_INT 35
10774: PPUSH
10775: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 92
10786: PUSH
10787: LD_INT 139
10789: PUSH
10790: LD_INT 89
10792: PUSH
10793: LD_INT 9
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: LIST
10800: LIST
10801: PPUSH
10802: CALL_OW 72
10806: PUSH
10807: LD_VAR 0 2
10811: PUSH
10812: LD_INT 1
10814: MINUS
10815: GREATEREQUAL
10816: IFFALSE 10694
// end else
10818: GO 10962
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10820: LD_VAR 0 2
10824: PPUSH
10825: LD_VAR 0 4
10829: PUSH
10830: LD_INT 1
10832: ARRAY
10833: PPUSH
10834: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10838: LD_ADDR_VAR 0 2
10842: PUSH
10843: LD_VAR 0 2
10847: PPUSH
10848: LD_INT 24
10850: PUSH
10851: LD_INT 250
10853: PUSH
10854: EMPTY
10855: LIST
10856: LIST
10857: PPUSH
10858: CALL_OW 72
10862: ST_TO_ADDR
// for i in tmp do
10863: LD_ADDR_VAR 0 1
10867: PUSH
10868: LD_VAR 0 2
10872: PUSH
10873: FOR_IN
10874: IFFALSE 10914
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10876: LD_VAR 0 1
10880: PPUSH
10881: LD_INT 124
10883: PPUSH
10884: LD_INT 139
10886: PPUSH
10887: CALL_OW 297
10891: PUSH
10892: LD_INT 9
10894: GREATER
10895: IFFALSE 10912
// ComMoveXY ( i , 124 , 139 ) ;
10897: LD_VAR 0 1
10901: PPUSH
10902: LD_INT 124
10904: PPUSH
10905: LD_INT 139
10907: PPUSH
10908: CALL_OW 111
10912: GO 10873
10914: POP
10915: POP
// wait ( 0 0$1 ) ;
10916: LD_INT 35
10918: PPUSH
10919: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10923: LD_VAR 0 2
10927: PPUSH
10928: LD_INT 92
10930: PUSH
10931: LD_INT 124
10933: PUSH
10934: LD_INT 139
10936: PUSH
10937: LD_INT 9
10939: PUSH
10940: EMPTY
10941: LIST
10942: LIST
10943: LIST
10944: LIST
10945: PPUSH
10946: CALL_OW 72
10950: PUSH
10951: LD_VAR 0 2
10955: PUSH
10956: LD_INT 1
10958: MINUS
10959: GREATEREQUAL
10960: IFFALSE 10838
// end ; repeat wait ( 0 0$1 ) ;
10962: LD_INT 35
10964: PPUSH
10965: CALL_OW 67
// for i in tmp do
10969: LD_ADDR_VAR 0 1
10973: PUSH
10974: LD_VAR 0 2
10978: PUSH
10979: FOR_IN
10980: IFFALSE 11149
// begin if GetLives ( i ) > 251 then
10982: LD_VAR 0 1
10986: PPUSH
10987: CALL_OW 256
10991: PUSH
10992: LD_INT 251
10994: GREATER
10995: IFFALSE 11120
// begin if GetWeapon ( i ) = ru_time_lapser then
10997: LD_VAR 0 1
11001: PPUSH
11002: CALL_OW 264
11006: PUSH
11007: LD_INT 49
11009: EQUAL
11010: IFFALSE 11066
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11012: LD_VAR 0 1
11016: PPUSH
11017: LD_INT 2
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 1
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: LD_INT 22
11032: PUSH
11033: LD_INT 8
11035: PUSH
11036: EMPTY
11037: LIST
11038: LIST
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: LIST
11044: PPUSH
11045: CALL_OW 69
11049: PPUSH
11050: LD_VAR 0 1
11054: PPUSH
11055: CALL_OW 74
11059: PPUSH
11060: CALL_OW 112
11064: GO 11118
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11066: LD_VAR 0 1
11070: PPUSH
11071: LD_INT 2
11073: PUSH
11074: LD_INT 22
11076: PUSH
11077: LD_INT 1
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 22
11086: PUSH
11087: LD_INT 8
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: EMPTY
11095: LIST
11096: LIST
11097: LIST
11098: PPUSH
11099: CALL_OW 69
11103: PPUSH
11104: LD_VAR 0 1
11108: PPUSH
11109: CALL_OW 74
11113: PPUSH
11114: CALL_OW 115
// end else
11118: GO 11147
// if IsDead ( i ) then
11120: LD_VAR 0 1
11124: PPUSH
11125: CALL_OW 301
11129: IFFALSE 11147
// tmp := tmp diff i ;
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_VAR 0 2
11140: PUSH
11141: LD_VAR 0 1
11145: DIFF
11146: ST_TO_ADDR
// end ;
11147: GO 10979
11149: POP
11150: POP
// until not tmp ;
11151: LD_VAR 0 2
11155: NOT
11156: IFFALSE 10962
// end ; end_of_file
11158: PPOPN 4
11160: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11161: LD_INT 0
11163: PPUSH
11164: PPUSH
11165: PPUSH
11166: PPUSH
11167: PPUSH
11168: PPUSH
// side := 7 ;
11169: LD_ADDR_VAR 0 5
11173: PUSH
11174: LD_INT 7
11176: ST_TO_ADDR
// uc_side := side ;
11177: LD_ADDR_OWVAR 20
11181: PUSH
11182: LD_VAR 0 5
11186: ST_TO_ADDR
// uc_nation := 1 ;
11187: LD_ADDR_OWVAR 21
11191: PUSH
11192: LD_INT 1
11194: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11195: LD_ADDR_VAR 0 2
11199: PUSH
11200: LD_INT 22
11202: PUSH
11203: LD_VAR 0 5
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: PUSH
11212: LD_INT 21
11214: PUSH
11215: LD_INT 3
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PPUSH
11226: CALL_OW 69
11230: PUSH
11231: FOR_IN
11232: IFFALSE 11248
// SetBLevel ( i , 10 ) ;
11234: LD_VAR 0 2
11238: PPUSH
11239: LD_INT 10
11241: PPUSH
11242: CALL_OW 241
11246: GO 11231
11248: POP
11249: POP
// base := GetBase ( al_depot ) ;
11250: LD_ADDR_VAR 0 4
11254: PUSH
11255: LD_INT 2
11257: PPUSH
11258: CALL_OW 274
11262: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11263: LD_ADDR_VAR 0 6
11267: PUSH
11268: LD_INT 22
11270: PUSH
11271: LD_VAR 0 5
11275: PUSH
11276: EMPTY
11277: LIST
11278: LIST
11279: PUSH
11280: LD_INT 30
11282: PUSH
11283: LD_INT 34
11285: PUSH
11286: EMPTY
11287: LIST
11288: LIST
11289: PUSH
11290: EMPTY
11291: LIST
11292: LIST
11293: PPUSH
11294: CALL_OW 69
11298: ST_TO_ADDR
// if teleport then
11299: LD_VAR 0 6
11303: IFFALSE 11324
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11305: LD_VAR 0 6
11309: PUSH
11310: LD_INT 1
11312: ARRAY
11313: PPUSH
11314: LD_INT 262
11316: PPUSH
11317: LD_INT 119
11319: PPUSH
11320: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11324: LD_VAR 0 4
11328: PPUSH
11329: LD_INT 1
11331: PPUSH
11332: LD_INT 19500
11334: PPUSH
11335: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11339: LD_VAR 0 4
11343: PPUSH
11344: LD_INT 2
11346: PPUSH
11347: LD_INT 200
11349: PPUSH
11350: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11354: LD_VAR 0 4
11358: PPUSH
11359: LD_INT 3
11361: PPUSH
11362: LD_INT 650
11364: PPUSH
11365: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11369: LD_ADDR_EXP 74
11373: PUSH
11374: LD_STRING Roth
11376: PPUSH
11377: CALL_OW 25
11381: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11382: LD_ADDR_EXP 75
11386: PUSH
11387: LD_STRING Simms
11389: PPUSH
11390: LD_EXP 1
11394: NOT
11395: PPUSH
11396: LD_STRING 10c_
11398: PPUSH
11399: CALL 65877 0 3
11403: ST_TO_ADDR
// if not Simms then
11404: LD_EXP 75
11408: NOT
11409: IFFALSE 11439
// begin uc_nation := 1 ;
11411: LD_ADDR_OWVAR 21
11415: PUSH
11416: LD_INT 1
11418: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11419: LD_INT 2
11421: PPUSH
11422: LD_INT 10
11424: PPUSH
11425: CALL_OW 384
// Simms := CreateHuman ;
11429: LD_ADDR_EXP 75
11433: PUSH
11434: CALL_OW 44
11438: ST_TO_ADDR
// end ; uc_nation := 3 ;
11439: LD_ADDR_OWVAR 21
11443: PUSH
11444: LD_INT 3
11446: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11447: LD_ADDR_EXP 76
11451: PUSH
11452: LD_STRING Kirilenkova
11454: PPUSH
11455: CALL_OW 25
11459: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11460: LD_ADDR_EXP 90
11464: PUSH
11465: LD_STRING Oblukov
11467: PPUSH
11468: CALL_OW 25
11472: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11473: LD_ADDR_EXP 77
11477: PUSH
11478: LD_STRING Dolgov
11480: PPUSH
11481: CALL_OW 25
11485: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11486: LD_ADDR_EXP 78
11490: PUSH
11491: LD_STRING Petrosyan
11493: PPUSH
11494: CALL_OW 25
11498: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11499: LD_ADDR_EXP 89
11503: PUSH
11504: LD_STRING Scholtze
11506: PPUSH
11507: CALL_OW 25
11511: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11512: LD_ADDR_EXP 88
11516: PUSH
11517: LD_STRING Kapitsova
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11525: LD_ADDR_EXP 79
11529: PUSH
11530: LD_STRING Petrovova
11532: PPUSH
11533: CALL_OW 25
11537: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11538: LD_ADDR_EXP 80
11542: PUSH
11543: LD_STRING Kuzmov
11545: PPUSH
11546: CALL_OW 25
11550: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11551: LD_ADDR_EXP 87
11555: PUSH
11556: LD_STRING Karamazov
11558: PPUSH
11559: CALL_OW 25
11563: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11564: LD_STRING 13_Lipshchin_1
11566: PPUSH
11567: LD_INT 0
11569: PPUSH
11570: CALL_OW 30
11574: IFFALSE 11589
// Lipshchin := NewCharacter ( Lipshchin ) ;
11576: LD_ADDR_EXP 81
11580: PUSH
11581: LD_STRING Lipshchin
11583: PPUSH
11584: CALL_OW 25
11588: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11589: LD_STRING 13_Titov_1
11591: PPUSH
11592: LD_INT 0
11594: PPUSH
11595: CALL_OW 30
11599: IFFALSE 11614
// Titov := NewCharacter ( Titov ) ;
11601: LD_ADDR_EXP 83
11605: PUSH
11606: LD_STRING Titov
11608: PPUSH
11609: CALL_OW 25
11613: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11614: LD_STRING 13_Gnyevko_1
11616: PPUSH
11617: LD_INT 0
11619: PPUSH
11620: CALL_OW 30
11624: IFFALSE 11639
// Gnyevko := NewCharacter ( Gnyevko ) ;
11626: LD_ADDR_EXP 82
11630: PUSH
11631: LD_STRING Gnyevko
11633: PPUSH
11634: CALL_OW 25
11638: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11639: LD_STRING 13_Xavier_1
11641: PPUSH
11642: LD_INT 0
11644: PPUSH
11645: CALL_OW 30
11649: IFFALSE 11664
// Xavier := NewCharacter ( Xavier2 ) ;
11651: LD_ADDR_EXP 84
11655: PUSH
11656: LD_STRING Xavier2
11658: PPUSH
11659: CALL_OW 25
11663: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11664: LD_STRING 13_Belkov_1
11666: PPUSH
11667: LD_INT 0
11669: PPUSH
11670: CALL_OW 30
11674: IFFALSE 11689
// Belkov := NewCharacter ( Belkov ) ;
11676: LD_ADDR_EXP 85
11680: PUSH
11681: LD_STRING Belkov
11683: PPUSH
11684: CALL_OW 25
11688: ST_TO_ADDR
// if not BurlakStatus then
11689: LD_EXP 9
11693: NOT
11694: IFFALSE 11709
// Burlak = NewCharacter ( Burlak ) ;
11696: LD_ADDR_EXP 86
11700: PUSH
11701: LD_STRING Burlak
11703: PPUSH
11704: CALL_OW 25
11708: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11709: LD_ADDR_VAR 0 3
11713: PUSH
11714: LD_EXP 74
11718: PUSH
11719: LD_EXP 76
11723: PUSH
11724: LD_EXP 90
11728: PUSH
11729: LD_EXP 77
11733: PUSH
11734: LD_EXP 78
11738: PUSH
11739: LD_EXP 89
11743: PUSH
11744: LD_EXP 88
11748: PUSH
11749: LD_EXP 79
11753: PUSH
11754: LD_EXP 80
11758: PUSH
11759: LD_EXP 87
11763: PUSH
11764: EMPTY
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: ST_TO_ADDR
// if Simms then
11776: LD_EXP 75
11780: IFFALSE 11798
// tmp := tmp ^ Simms ;
11782: LD_ADDR_VAR 0 3
11786: PUSH
11787: LD_VAR 0 3
11791: PUSH
11792: LD_EXP 75
11796: ADD
11797: ST_TO_ADDR
// if Titov then
11798: LD_EXP 83
11802: IFFALSE 11820
// tmp := tmp ^ Titov ;
11804: LD_ADDR_VAR 0 3
11808: PUSH
11809: LD_VAR 0 3
11813: PUSH
11814: LD_EXP 83
11818: ADD
11819: ST_TO_ADDR
// if Lipshchin then
11820: LD_EXP 81
11824: IFFALSE 11842
// tmp := tmp ^ Lipshchin ;
11826: LD_ADDR_VAR 0 3
11830: PUSH
11831: LD_VAR 0 3
11835: PUSH
11836: LD_EXP 81
11840: ADD
11841: ST_TO_ADDR
// if Gnyevko then
11842: LD_EXP 82
11846: IFFALSE 11864
// tmp := tmp ^ Gnyevko ;
11848: LD_ADDR_VAR 0 3
11852: PUSH
11853: LD_VAR 0 3
11857: PUSH
11858: LD_EXP 82
11862: ADD
11863: ST_TO_ADDR
// if Xavier then
11864: LD_EXP 84
11868: IFFALSE 11886
// tmp := tmp ^ Xavier ;
11870: LD_ADDR_VAR 0 3
11874: PUSH
11875: LD_VAR 0 3
11879: PUSH
11880: LD_EXP 84
11884: ADD
11885: ST_TO_ADDR
// if Belkov then
11886: LD_EXP 85
11890: IFFALSE 11908
// tmp := tmp ^ Belkov ;
11892: LD_ADDR_VAR 0 3
11896: PUSH
11897: LD_VAR 0 3
11901: PUSH
11902: LD_EXP 85
11906: ADD
11907: ST_TO_ADDR
// if Burlak then
11908: LD_EXP 86
11912: IFFALSE 11930
// tmp := tmp ^ Burlak ;
11914: LD_ADDR_VAR 0 3
11918: PUSH
11919: LD_VAR 0 3
11923: PUSH
11924: LD_EXP 86
11928: ADD
11929: ST_TO_ADDR
// for i = 1 to 11 do
11930: LD_ADDR_VAR 0 2
11934: PUSH
11935: DOUBLE
11936: LD_INT 1
11938: DEC
11939: ST_TO_ADDR
11940: LD_INT 11
11942: PUSH
11943: FOR_TO
11944: IFFALSE 12010
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11946: LD_ADDR_OWVAR 21
11950: PUSH
11951: LD_INT 1
11953: PUSH
11954: LD_INT 3
11956: PUSH
11957: EMPTY
11958: LIST
11959: LIST
11960: PUSH
11961: LD_INT 1
11963: PPUSH
11964: LD_INT 2
11966: PPUSH
11967: CALL_OW 12
11971: ARRAY
11972: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11973: LD_INT 0
11975: PPUSH
11976: LD_VAR 0 2
11980: PUSH
11981: LD_INT 2
11983: DIV
11984: PPUSH
11985: LD_INT 10
11987: PPUSH
11988: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11992: LD_ADDR_VAR 0 3
11996: PUSH
11997: LD_VAR 0 3
12001: PUSH
12002: CALL_OW 44
12006: ADD
12007: ST_TO_ADDR
// end ;
12008: GO 11943
12010: POP
12011: POP
// for i in tmp do
12012: LD_ADDR_VAR 0 2
12016: PUSH
12017: LD_VAR 0 3
12021: PUSH
12022: FOR_IN
12023: IFFALSE 12048
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12025: LD_VAR 0 2
12029: PPUSH
12030: LD_INT 260
12032: PPUSH
12033: LD_INT 235
12035: PPUSH
12036: LD_INT 8
12038: PPUSH
12039: LD_INT 0
12041: PPUSH
12042: CALL_OW 50
12046: GO 12022
12048: POP
12049: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12050: LD_ADDR_EXP 116
12054: PUSH
12055: LD_EXP 116
12059: PPUSH
12060: LD_INT 1
12062: PPUSH
12063: LD_INT 22
12065: PUSH
12066: LD_VAR 0 5
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: LD_INT 3
12077: PUSH
12078: LD_INT 21
12080: PUSH
12081: LD_INT 2
12083: PUSH
12084: EMPTY
12085: LIST
12086: LIST
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: PPUSH
12096: CALL_OW 69
12100: PUSH
12101: LD_EXP 74
12105: PUSH
12106: LD_EXP 75
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: DIFF
12115: PPUSH
12116: CALL_OW 1
12120: ST_TO_ADDR
// uc_side := 0 ;
12121: LD_ADDR_OWVAR 20
12125: PUSH
12126: LD_INT 0
12128: ST_TO_ADDR
// uc_nation := 0 ;
12129: LD_ADDR_OWVAR 21
12133: PUSH
12134: LD_INT 0
12136: ST_TO_ADDR
// for i = 1 to 5 do
12137: LD_ADDR_VAR 0 2
12141: PUSH
12142: DOUBLE
12143: LD_INT 1
12145: DEC
12146: ST_TO_ADDR
12147: LD_INT 5
12149: PUSH
12150: FOR_TO
12151: IFFALSE 12188
// begin InitHc ;
12153: CALL_OW 19
// hc_class := class_apeman ;
12157: LD_ADDR_OWVAR 28
12161: PUSH
12162: LD_INT 12
12164: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12165: CALL_OW 44
12169: PPUSH
12170: LD_INT 299
12172: PPUSH
12173: LD_INT 229
12175: PPUSH
12176: LD_INT 10
12178: PPUSH
12179: LD_INT 0
12181: PPUSH
12182: CALL_OW 50
// end ;
12186: GO 12150
12188: POP
12189: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12190: LD_EXP 74
12194: PPUSH
12195: LD_INT 259
12197: PPUSH
12198: LD_INT 235
12200: PPUSH
12201: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12205: LD_EXP 74
12209: PPUSH
12210: LD_INT 262
12212: PPUSH
12213: LD_INT 235
12215: PPUSH
12216: CALL_OW 178
// if Simms then
12220: LD_EXP 75
12224: IFFALSE 12255
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12226: LD_EXP 75
12230: PPUSH
12231: LD_INT 262
12233: PPUSH
12234: LD_INT 235
12236: PPUSH
12237: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12241: LD_EXP 75
12245: PPUSH
12246: LD_EXP 74
12250: PPUSH
12251: CALL_OW 179
// end ; end ;
12255: LD_VAR 0 1
12259: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12260: LD_EXP 31
12264: PUSH
12265: LD_EXP 23
12269: NOT
12270: AND
12271: IFFALSE 12447
12273: GO 12275
12275: DISABLE
12276: LD_INT 0
12278: PPUSH
12279: PPUSH
12280: PPUSH
// begin enable ;
12281: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12282: LD_ADDR_VAR 0 2
12286: PUSH
12287: LD_INT 81
12289: PUSH
12290: LD_INT 7
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: PUSH
12297: LD_INT 2
12299: PUSH
12300: LD_INT 32
12302: PUSH
12303: LD_INT 3
12305: PUSH
12306: EMPTY
12307: LIST
12308: LIST
12309: PUSH
12310: LD_INT 30
12312: PUSH
12313: LD_INT 30
12315: PUSH
12316: EMPTY
12317: LIST
12318: LIST
12319: PUSH
12320: LD_INT 30
12322: PUSH
12323: LD_INT 28
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PUSH
12330: LD_INT 34
12332: PUSH
12333: LD_INT 49
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PUSH
12340: LD_INT 34
12342: PUSH
12343: LD_INT 10
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 34
12352: PUSH
12353: LD_INT 8
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: LIST
12364: LIST
12365: LIST
12366: LIST
12367: LIST
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PPUSH
12373: CALL_OW 69
12377: ST_TO_ADDR
// if not tmp then
12378: LD_VAR 0 2
12382: NOT
12383: IFFALSE 12387
// exit ;
12385: GO 12447
// target := tmp [ rand ( 1 , tmp ) ] ;
12387: LD_ADDR_VAR 0 3
12391: PUSH
12392: LD_VAR 0 2
12396: PUSH
12397: LD_INT 1
12399: PPUSH
12400: LD_VAR 0 2
12404: PPUSH
12405: CALL_OW 12
12409: ARRAY
12410: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12411: LD_VAR 0 3
12415: PPUSH
12416: CALL_OW 255
12420: PUSH
12421: LD_INT 1
12423: EQUAL
12424: IFFALSE 12435
// CenterNowOnUnits ( target ) ;
12426: LD_VAR 0 3
12430: PPUSH
12431: CALL_OW 87
// SetLives ( target , 0 ) ;
12435: LD_VAR 0 3
12439: PPUSH
12440: LD_INT 0
12442: PPUSH
12443: CALL_OW 234
// end ;
12447: PPOPN 3
12449: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12450: LD_EXP 23
12454: NOT
12455: PUSH
12456: LD_EXP 31
12460: AND
12461: IFFALSE 12987
12463: GO 12465
12465: DISABLE
12466: LD_INT 0
12468: PPUSH
12469: PPUSH
12470: PPUSH
// begin uc_side := 7 ;
12471: LD_ADDR_OWVAR 20
12475: PUSH
12476: LD_INT 7
12478: ST_TO_ADDR
// uc_nation := 1 ;
12479: LD_ADDR_OWVAR 21
12483: PUSH
12484: LD_INT 1
12486: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12487: LD_ADDR_VAR 0 3
12491: PUSH
12492: LD_INT 125
12494: PUSH
12495: LD_INT 163
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: PUSH
12502: LD_INT 185
12504: PUSH
12505: LD_INT 168
12507: PUSH
12508: EMPTY
12509: LIST
12510: LIST
12511: PUSH
12512: LD_INT 111
12514: PUSH
12515: LD_INT 97
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL 102719 0 1
12531: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12532: LD_ADDR_EXP 91
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// for i = 1 to Difficulty do
12539: LD_ADDR_VAR 0 1
12543: PUSH
12544: DOUBLE
12545: LD_INT 1
12547: DEC
12548: ST_TO_ADDR
12549: LD_OWVAR 67
12553: PUSH
12554: FOR_TO
12555: IFFALSE 12713
// begin InitHc ;
12557: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12561: LD_INT 0
12563: PPUSH
12564: LD_INT 8
12566: PPUSH
12567: CALL_OW 381
// un := CreateHuman ;
12571: LD_ADDR_VAR 0 2
12575: PUSH
12576: CALL_OW 44
12580: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12581: LD_VAR 0 2
12585: PPUSH
12586: LD_INT 258
12588: PPUSH
12589: LD_INT 267
12591: PPUSH
12592: LD_INT 4
12594: PPUSH
12595: LD_INT 0
12597: PPUSH
12598: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12602: LD_ADDR_EXP 91
12606: PUSH
12607: LD_EXP 91
12611: PUSH
12612: LD_VAR 0 2
12616: UNION
12617: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12618: LD_VAR 0 2
12622: PPUSH
12623: LD_VAR 0 3
12627: PUSH
12628: LD_VAR 0 1
12632: ARRAY
12633: PUSH
12634: LD_INT 1
12636: ARRAY
12637: PPUSH
12638: LD_VAR 0 3
12642: PUSH
12643: LD_VAR 0 1
12647: ARRAY
12648: PUSH
12649: LD_INT 2
12651: ARRAY
12652: PPUSH
12653: LD_INT 4
12655: PPUSH
12656: LD_INT 1
12658: PPUSH
12659: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12663: LD_VAR 0 2
12667: PPUSH
12668: LD_VAR 0 3
12672: PUSH
12673: LD_VAR 0 1
12677: ARRAY
12678: PUSH
12679: LD_INT 1
12681: ARRAY
12682: PPUSH
12683: LD_VAR 0 3
12687: PUSH
12688: LD_VAR 0 1
12692: ARRAY
12693: PUSH
12694: LD_INT 2
12696: ARRAY
12697: PPUSH
12698: CALL_OW 171
// AddComInvisible ( un ) ;
12702: LD_VAR 0 2
12706: PPUSH
12707: CALL_OW 212
// end ;
12711: GO 12554
12713: POP
12714: POP
// repeat wait ( 0 0$20 ) ;
12715: LD_INT 700
12717: PPUSH
12718: CALL_OW 67
// for i in allianceSpecialForce do
12722: LD_ADDR_VAR 0 1
12726: PUSH
12727: LD_EXP 91
12731: PUSH
12732: FOR_IN
12733: IFFALSE 12972
// begin if IsInvisible ( i ) then
12735: LD_VAR 0 1
12739: PPUSH
12740: CALL_OW 571
12744: IFFALSE 12941
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12746: LD_ADDR_VAR 0 3
12750: PUSH
12751: LD_INT 22
12753: PUSH
12754: LD_INT 1
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: PUSH
12761: LD_INT 50
12763: PUSH
12764: EMPTY
12765: LIST
12766: PUSH
12767: LD_INT 56
12769: PUSH
12770: EMPTY
12771: LIST
12772: PUSH
12773: LD_INT 91
12775: PUSH
12776: LD_VAR 0 1
12780: PUSH
12781: LD_INT 25
12783: PUSH
12784: LD_INT 30
12786: PUSH
12787: LD_INT 35
12789: PUSH
12790: LD_INT 40
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: PUSH
12799: LD_OWVAR 67
12803: ARRAY
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 2
12812: PUSH
12813: LD_INT 25
12815: PUSH
12816: LD_INT 1
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PUSH
12823: LD_INT 25
12825: PUSH
12826: LD_INT 2
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: PUSH
12833: LD_INT 25
12835: PUSH
12836: LD_INT 3
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: PUSH
12843: LD_INT 25
12845: PUSH
12846: LD_INT 4
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PUSH
12853: LD_INT 25
12855: PUSH
12856: LD_INT 5
12858: PUSH
12859: EMPTY
12860: LIST
12861: LIST
12862: PUSH
12863: LD_INT 25
12865: PUSH
12866: LD_INT 8
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: PPUSH
12889: CALL_OW 69
12893: ST_TO_ADDR
// if not tmp then
12894: LD_VAR 0 3
12898: NOT
12899: IFFALSE 12903
// continue ;
12901: GO 12732
// if Prob ( 30 * Difficulty ) then
12903: LD_INT 30
12905: PUSH
12906: LD_OWVAR 67
12910: MUL
12911: PPUSH
12912: CALL_OW 13
12916: IFFALSE 12941
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12918: LD_VAR 0 3
12922: PUSH
12923: LD_INT 1
12925: PPUSH
12926: LD_VAR 0 3
12930: PPUSH
12931: CALL_OW 12
12935: ARRAY
12936: PPUSH
12937: CALL 31270 0 1
// end ; if IsDead ( i ) then
12941: LD_VAR 0 1
12945: PPUSH
12946: CALL_OW 301
12950: IFFALSE 12970
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12952: LD_ADDR_EXP 91
12956: PUSH
12957: LD_EXP 91
12961: PUSH
12962: LD_VAR 0 1
12966: DIFF
12967: ST_TO_ADDR
// continue ;
12968: GO 12732
// end ; end ;
12970: GO 12732
12972: POP
12973: POP
// until allianceDestroyed or not allianceSpecialForce ;
12974: LD_EXP 23
12978: PUSH
12979: LD_EXP 91
12983: NOT
12984: OR
12985: IFFALSE 12715
// end ;
12987: PPOPN 3
12989: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12990: LD_EXP 23
12994: NOT
12995: PUSH
12996: LD_EXP 31
13000: AND
13001: IFFALSE 13972
13003: GO 13005
13005: DISABLE
13006: LD_INT 0
13008: PPUSH
13009: PPUSH
13010: PPUSH
13011: PPUSH
// begin enable ;
13012: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13013: LD_INT 22
13015: PUSH
13016: LD_INT 7
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PUSH
13023: LD_INT 30
13025: PUSH
13026: LD_INT 3
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: PUSH
13033: EMPTY
13034: LIST
13035: LIST
13036: PPUSH
13037: CALL_OW 69
13041: NOT
13042: IFFALSE 13046
// exit ;
13044: GO 13972
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13046: LD_ADDR_VAR 0 4
13050: PUSH
13051: LD_INT 22
13053: PUSH
13054: LD_INT 7
13056: PUSH
13057: EMPTY
13058: LIST
13059: LIST
13060: PUSH
13061: LD_INT 30
13063: PUSH
13064: LD_INT 34
13066: PUSH
13067: EMPTY
13068: LIST
13069: LIST
13070: PUSH
13071: EMPTY
13072: LIST
13073: LIST
13074: PPUSH
13075: CALL_OW 69
13079: ST_TO_ADDR
// if Prob ( 40 ) then
13080: LD_INT 40
13082: PPUSH
13083: CALL_OW 13
13087: IFFALSE 13214
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13089: LD_INT 1
13091: PPUSH
13092: LD_INT 5
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 2
13100: PUSH
13101: LD_INT 6
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: LIST
13108: LIST
13109: PUSH
13110: LD_INT 5
13112: PUSH
13113: LD_INT 3
13115: PUSH
13116: LD_INT 2
13118: PUSH
13119: LD_INT 6
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 5
13130: PUSH
13131: LD_INT 3
13133: PUSH
13134: LD_INT 2
13136: PUSH
13137: LD_INT 6
13139: PUSH
13140: EMPTY
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: PUSH
13146: LD_INT 24
13148: PUSH
13149: LD_INT 3
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 45
13157: PUSH
13158: EMPTY
13159: LIST
13160: LIST
13161: LIST
13162: LIST
13163: PUSH
13164: LD_INT 24
13166: PUSH
13167: LD_INT 3
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 47
13175: PUSH
13176: EMPTY
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: PUSH
13182: LD_INT 24
13184: PUSH
13185: LD_INT 3
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 45
13193: PUSH
13194: EMPTY
13195: LIST
13196: LIST
13197: LIST
13198: LIST
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: PPUSH
13208: CALL 59471 0 2
// end else
13212: GO 13337
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13214: LD_INT 1
13216: PPUSH
13217: LD_INT 24
13219: PUSH
13220: LD_INT 3
13222: PUSH
13223: LD_INT 3
13225: PUSH
13226: LD_INT 47
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: PUSH
13235: LD_INT 24
13237: PUSH
13238: LD_INT 3
13240: PUSH
13241: LD_INT 3
13243: PUSH
13244: LD_INT 47
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: PUSH
13253: LD_INT 5
13255: PUSH
13256: LD_INT 3
13258: PUSH
13259: LD_INT 2
13261: PUSH
13262: LD_INT 9
13264: PUSH
13265: EMPTY
13266: LIST
13267: LIST
13268: LIST
13269: LIST
13270: PUSH
13271: LD_INT 5
13273: PUSH
13274: LD_INT 3
13276: PUSH
13277: LD_INT 2
13279: PUSH
13280: LD_INT 9
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: LIST
13287: LIST
13288: PUSH
13289: LD_INT 24
13291: PUSH
13292: LD_INT 1
13294: PUSH
13295: LD_INT 3
13297: PUSH
13298: LD_INT 45
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: LIST
13305: LIST
13306: PUSH
13307: LD_INT 24
13309: PUSH
13310: LD_INT 1
13312: PUSH
13313: LD_INT 3
13315: PUSH
13316: LD_INT 45
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: LIST
13323: LIST
13324: PUSH
13325: EMPTY
13326: LIST
13327: LIST
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL 59471 0 2
// end ; if Difficulty > 1 then
13337: LD_OWVAR 67
13341: PUSH
13342: LD_INT 1
13344: GREATER
13345: IFFALSE 13375
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13347: LD_INT 1
13349: PPUSH
13350: LD_INT 24
13352: PUSH
13353: LD_INT 3
13355: PUSH
13356: LD_INT 3
13358: PUSH
13359: LD_INT 47
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: PUSH
13368: EMPTY
13369: LIST
13370: PPUSH
13371: CALL 59471 0 2
// repeat wait ( 0 0$1 ) ;
13375: LD_INT 35
13377: PPUSH
13378: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
13382: LD_INT 1
13384: PPUSH
13385: LD_INT 1
13387: PPUSH
13388: CALL 60889 0 2
13392: PUSH
13393: LD_INT 6
13395: PUSH
13396: LD_INT 7
13398: PUSH
13399: LD_INT 7
13401: PUSH
13402: LD_INT 7
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: LIST
13409: LIST
13410: PUSH
13411: LD_OWVAR 67
13415: ARRAY
13416: GREATEREQUAL
13417: IFFALSE 13375
// wait ( 0 0$40 ) ;
13419: LD_INT 1400
13421: PPUSH
13422: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13426: LD_ADDR_VAR 0 2
13430: PUSH
13431: LD_INT 1
13433: PPUSH
13434: LD_INT 1
13436: PPUSH
13437: CALL 60889 0 2
13441: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13442: LD_ADDR_EXP 135
13446: PUSH
13447: LD_EXP 135
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: LD_EXP 135
13459: PUSH
13460: LD_INT 1
13462: ARRAY
13463: PUSH
13464: LD_VAR 0 2
13468: DIFF
13469: PPUSH
13470: CALL_OW 1
13474: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13475: LD_ADDR_VAR 0 3
13479: PUSH
13480: LD_INT 0
13482: PPUSH
13483: LD_INT 1
13485: PPUSH
13486: CALL_OW 12
13490: ST_TO_ADDR
// if target then
13491: LD_VAR 0 3
13495: IFFALSE 13661
// begin for i in tmp do
13497: LD_ADDR_VAR 0 1
13501: PUSH
13502: LD_VAR 0 2
13506: PUSH
13507: FOR_IN
13508: IFFALSE 13533
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13510: LD_VAR 0 1
13514: PPUSH
13515: LD_INT 179
13517: PPUSH
13518: LD_INT 209
13520: PPUSH
13521: LD_INT 8
13523: PPUSH
13524: LD_INT 1
13526: PPUSH
13527: CALL_OW 483
13531: GO 13507
13533: POP
13534: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13535: LD_ADDR_VAR 0 2
13539: PUSH
13540: LD_VAR 0 2
13544: PPUSH
13545: LD_INT 24
13547: PUSH
13548: LD_INT 250
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PPUSH
13555: CALL_OW 72
13559: ST_TO_ADDR
// for i in tmp do
13560: LD_ADDR_VAR 0 1
13564: PUSH
13565: LD_VAR 0 2
13569: PUSH
13570: FOR_IN
13571: IFFALSE 13611
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13573: LD_VAR 0 1
13577: PPUSH
13578: LD_INT 179
13580: PPUSH
13581: LD_INT 209
13583: PPUSH
13584: CALL_OW 297
13588: PUSH
13589: LD_INT 9
13591: GREATER
13592: IFFALSE 13609
// ComMoveXY ( i , 179 , 209 ) ;
13594: LD_VAR 0 1
13598: PPUSH
13599: LD_INT 179
13601: PPUSH
13602: LD_INT 209
13604: PPUSH
13605: CALL_OW 111
13609: GO 13570
13611: POP
13612: POP
// wait ( 0 0$1 ) ;
13613: LD_INT 35
13615: PPUSH
13616: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13620: LD_VAR 0 2
13624: PPUSH
13625: LD_INT 92
13627: PUSH
13628: LD_INT 179
13630: PUSH
13631: LD_INT 209
13633: PUSH
13634: LD_INT 9
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: LIST
13641: LIST
13642: PPUSH
13643: CALL_OW 72
13647: PUSH
13648: LD_VAR 0 2
13652: PUSH
13653: LD_INT 1
13655: MINUS
13656: GREATEREQUAL
13657: IFFALSE 13535
// end else
13659: GO 13823
// begin for i in tmp do
13661: LD_ADDR_VAR 0 1
13665: PUSH
13666: LD_VAR 0 2
13670: PUSH
13671: FOR_IN
13672: IFFALSE 13697
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13674: LD_VAR 0 1
13678: PPUSH
13679: LD_INT 285
13681: PPUSH
13682: LD_INT 163
13684: PPUSH
13685: LD_INT 8
13687: PPUSH
13688: LD_INT 1
13690: PPUSH
13691: CALL_OW 483
13695: GO 13671
13697: POP
13698: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13699: LD_ADDR_VAR 0 2
13703: PUSH
13704: LD_VAR 0 2
13708: PPUSH
13709: LD_INT 24
13711: PUSH
13712: LD_INT 250
13714: PUSH
13715: EMPTY
13716: LIST
13717: LIST
13718: PPUSH
13719: CALL_OW 72
13723: ST_TO_ADDR
// for i in tmp do
13724: LD_ADDR_VAR 0 1
13728: PUSH
13729: LD_VAR 0 2
13733: PUSH
13734: FOR_IN
13735: IFFALSE 13775
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13737: LD_VAR 0 1
13741: PPUSH
13742: LD_INT 285
13744: PPUSH
13745: LD_INT 163
13747: PPUSH
13748: CALL_OW 297
13752: PUSH
13753: LD_INT 9
13755: GREATER
13756: IFFALSE 13773
// ComMoveXY ( i , 285 , 163 ) ;
13758: LD_VAR 0 1
13762: PPUSH
13763: LD_INT 285
13765: PPUSH
13766: LD_INT 163
13768: PPUSH
13769: CALL_OW 111
13773: GO 13734
13775: POP
13776: POP
// wait ( 0 0$1 ) ;
13777: LD_INT 35
13779: PPUSH
13780: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13784: LD_VAR 0 2
13788: PPUSH
13789: LD_INT 92
13791: PUSH
13792: LD_INT 285
13794: PUSH
13795: LD_INT 163
13797: PUSH
13798: LD_INT 9
13800: PUSH
13801: EMPTY
13802: LIST
13803: LIST
13804: LIST
13805: LIST
13806: PPUSH
13807: CALL_OW 72
13811: PUSH
13812: LD_VAR 0 2
13816: PUSH
13817: LD_INT 1
13819: MINUS
13820: GREATEREQUAL
13821: IFFALSE 13699
// end ; repeat wait ( 0 0$1 ) ;
13823: LD_INT 35
13825: PPUSH
13826: CALL_OW 67
// for i in tmp do
13830: LD_ADDR_VAR 0 1
13834: PUSH
13835: LD_VAR 0 2
13839: PUSH
13840: FOR_IN
13841: IFFALSE 13963
// if GetLives ( i ) > 251 then
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 256
13852: PUSH
13853: LD_INT 251
13855: GREATER
13856: IFFALSE 13945
// begin if GetWeapon ( i ) = ru_time_lapser then
13858: LD_VAR 0 1
13862: PPUSH
13863: CALL_OW 264
13867: PUSH
13868: LD_INT 49
13870: EQUAL
13871: IFFALSE 13909
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13873: LD_VAR 0 1
13877: PPUSH
13878: LD_INT 81
13880: PUSH
13881: LD_INT 7
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PPUSH
13888: CALL_OW 69
13892: PPUSH
13893: LD_VAR 0 1
13897: PPUSH
13898: CALL_OW 74
13902: PPUSH
13903: CALL_OW 112
13907: GO 13943
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13909: LD_VAR 0 1
13913: PPUSH
13914: LD_INT 81
13916: PUSH
13917: LD_INT 7
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: PPUSH
13924: CALL_OW 69
13928: PPUSH
13929: LD_VAR 0 1
13933: PPUSH
13934: CALL_OW 74
13938: PPUSH
13939: CALL_OW 115
// end else
13943: GO 13961
// tmp := tmp diff i ;
13945: LD_ADDR_VAR 0 2
13949: PUSH
13950: LD_VAR 0 2
13954: PUSH
13955: LD_VAR 0 1
13959: DIFF
13960: ST_TO_ADDR
13961: GO 13840
13963: POP
13964: POP
// until not tmp ;
13965: LD_VAR 0 2
13969: NOT
13970: IFFALSE 13823
// end ; end_of_file
13972: PPOPN 4
13974: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13975: LD_INT 0
13977: PPUSH
13978: PPUSH
13979: PPUSH
13980: PPUSH
// missionStage := 13 ;
13981: LD_ADDR_EXP 15
13985: PUSH
13986: LD_INT 13
13988: ST_TO_ADDR
// uc_side := 2 ;
13989: LD_ADDR_OWVAR 20
13993: PUSH
13994: LD_INT 2
13996: ST_TO_ADDR
// uc_nation := 2 ;
13997: LD_ADDR_OWVAR 21
14001: PUSH
14002: LD_INT 2
14004: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14005: LD_ADDR_EXP 92
14009: PUSH
14010: LD_STRING Omar
14012: PPUSH
14013: CALL_OW 25
14017: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14018: LD_EXP 92
14022: PPUSH
14023: LD_INT 4
14025: PPUSH
14026: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14030: LD_EXP 92
14034: PPUSH
14035: LD_INT 242
14037: PPUSH
14038: LD_INT 75
14040: PPUSH
14041: LD_INT 0
14043: PPUSH
14044: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14048: LD_ADDR_EXP 93
14052: PUSH
14053: LD_STRING Heike
14055: PPUSH
14056: CALL_OW 25
14060: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14061: LD_INT 14
14063: PPUSH
14064: LD_INT 3
14066: PPUSH
14067: LD_INT 1
14069: PPUSH
14070: LD_INT 27
14072: PPUSH
14073: LD_INT 100
14075: PPUSH
14076: CALL 70741 0 5
// veh := CreateVehicle ;
14080: LD_ADDR_VAR 0 3
14084: PUSH
14085: CALL_OW 45
14089: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14090: LD_VAR 0 3
14094: PPUSH
14095: LD_INT 1
14097: PPUSH
14098: CALL_OW 242
// SetDir ( veh , 4 ) ;
14102: LD_VAR 0 3
14106: PPUSH
14107: LD_INT 4
14109: PPUSH
14110: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14114: LD_VAR 0 3
14118: PPUSH
14119: LD_INT 241
14121: PPUSH
14122: LD_INT 72
14124: PPUSH
14125: LD_INT 0
14127: PPUSH
14128: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14132: LD_EXP 93
14136: PPUSH
14137: LD_VAR 0 3
14141: PPUSH
14142: CALL_OW 52
// if KhatamStatus then
14146: LD_EXP 8
14150: IFFALSE 14201
// begin Khatam := NewCharacter ( Khatam ) ;
14152: LD_ADDR_EXP 94
14156: PUSH
14157: LD_STRING Khatam
14159: PPUSH
14160: CALL_OW 25
14164: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14165: LD_EXP 94
14169: PPUSH
14170: LD_INT 245
14172: PPUSH
14173: LD_INT 78
14175: PPUSH
14176: LD_INT 3
14178: PPUSH
14179: LD_INT 0
14181: PPUSH
14182: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14186: LD_EXP 94
14190: PPUSH
14191: LD_INT 4
14193: PPUSH
14194: LD_INT 10
14196: PPUSH
14197: CALL_OW 237
// end ; for i = 1 to Difficulty do
14201: LD_ADDR_VAR 0 2
14205: PUSH
14206: DOUBLE
14207: LD_INT 1
14209: DEC
14210: ST_TO_ADDR
14211: LD_OWVAR 67
14215: PUSH
14216: FOR_TO
14217: IFFALSE 14283
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14219: LD_INT 0
14221: PPUSH
14222: LD_INT 7
14224: PUSH
14225: LD_OWVAR 67
14229: PLUS
14230: PPUSH
14231: CALL_OW 384
// un := CreateHuman ;
14235: LD_ADDR_VAR 0 4
14239: PUSH
14240: CALL_OW 44
14244: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14245: LD_VAR 0 4
14249: PPUSH
14250: LD_INT 28
14252: PUSH
14253: LD_INT 29
14255: PUSH
14256: EMPTY
14257: LIST
14258: LIST
14259: PUSH
14260: LD_VAR 0 2
14264: PUSH
14265: LD_INT 2
14267: MOD
14268: PUSH
14269: LD_INT 1
14271: PLUS
14272: ARRAY
14273: PPUSH
14274: LD_INT 0
14276: PPUSH
14277: CALL_OW 49
// end ;
14281: GO 14216
14283: POP
14284: POP
// for i = 1 to 6 do
14285: LD_ADDR_VAR 0 2
14289: PUSH
14290: DOUBLE
14291: LD_INT 1
14293: DEC
14294: ST_TO_ADDR
14295: LD_INT 6
14297: PUSH
14298: FOR_TO
14299: IFFALSE 14344
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14301: LD_INT 0
14303: PPUSH
14304: LD_INT 7
14306: PUSH
14307: LD_OWVAR 67
14311: PLUS
14312: PPUSH
14313: CALL_OW 381
// un := CreateHuman ;
14317: LD_ADDR_VAR 0 4
14321: PUSH
14322: CALL_OW 44
14326: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14327: LD_VAR 0 4
14331: PPUSH
14332: LD_INT 28
14334: PPUSH
14335: LD_INT 0
14337: PPUSH
14338: CALL_OW 49
// end ;
14342: GO 14298
14344: POP
14345: POP
// for i = 1 to 3 do
14346: LD_ADDR_VAR 0 2
14350: PUSH
14351: DOUBLE
14352: LD_INT 1
14354: DEC
14355: ST_TO_ADDR
14356: LD_INT 3
14358: PUSH
14359: FOR_TO
14360: IFFALSE 14408
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14362: LD_INT 0
14364: PPUSH
14365: LD_INT 8
14367: PPUSH
14368: LD_INT 7
14370: PUSH
14371: LD_OWVAR 67
14375: PLUS
14376: PPUSH
14377: CALL_OW 380
// un := CreateHuman ;
14381: LD_ADDR_VAR 0 4
14385: PUSH
14386: CALL_OW 44
14390: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14391: LD_VAR 0 4
14395: PPUSH
14396: LD_INT 28
14398: PPUSH
14399: LD_INT 0
14401: PPUSH
14402: CALL_OW 49
// end ;
14406: GO 14359
14408: POP
14409: POP
// for i = 1 to 3 do
14410: LD_ADDR_VAR 0 2
14414: PUSH
14415: DOUBLE
14416: LD_INT 1
14418: DEC
14419: ST_TO_ADDR
14420: LD_INT 3
14422: PUSH
14423: FOR_TO
14424: IFFALSE 14514
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14426: LD_INT 14
14428: PPUSH
14429: LD_INT 2
14431: PPUSH
14432: LD_INT 1
14434: PPUSH
14435: LD_INT 28
14437: PPUSH
14438: LD_INT 80
14440: PPUSH
14441: CALL 70741 0 5
// veh := CreateVehicle ;
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: CALL_OW 45
14454: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14455: LD_VAR 0 3
14459: PPUSH
14460: LD_INT 3
14462: PPUSH
14463: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14467: LD_VAR 0 3
14471: PPUSH
14472: LD_INT 29
14474: PPUSH
14475: LD_INT 0
14477: PPUSH
14478: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14482: LD_INT 0
14484: PPUSH
14485: LD_INT 7
14487: PUSH
14488: LD_OWVAR 67
14492: PLUS
14493: PPUSH
14494: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14498: CALL_OW 44
14502: PPUSH
14503: LD_VAR 0 3
14507: PPUSH
14508: CALL_OW 52
// end ;
14512: GO 14423
14514: POP
14515: POP
// for i = 1 to 5 + Difficulty do
14516: LD_ADDR_VAR 0 2
14520: PUSH
14521: DOUBLE
14522: LD_INT 1
14524: DEC
14525: ST_TO_ADDR
14526: LD_INT 5
14528: PUSH
14529: LD_OWVAR 67
14533: PLUS
14534: PUSH
14535: FOR_TO
14536: IFFALSE 14663
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14538: LD_INT 14
14540: PPUSH
14541: LD_INT 1
14543: PPUSH
14544: LD_INT 3
14546: PPUSH
14547: CALL_OW 12
14551: PPUSH
14552: LD_INT 1
14554: PPUSH
14555: LD_INT 28
14557: PUSH
14558: LD_INT 26
14560: PUSH
14561: LD_INT 27
14563: PUSH
14564: LD_INT 25
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: PUSH
14573: LD_VAR 0 2
14577: PUSH
14578: LD_INT 4
14580: MOD
14581: PUSH
14582: LD_INT 1
14584: PLUS
14585: ARRAY
14586: PPUSH
14587: LD_INT 80
14589: PPUSH
14590: CALL 70741 0 5
// veh := CreateVehicle ;
14594: LD_ADDR_VAR 0 3
14598: PUSH
14599: CALL_OW 45
14603: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14604: LD_VAR 0 3
14608: PPUSH
14609: LD_INT 4
14611: PPUSH
14612: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14616: LD_VAR 0 3
14620: PPUSH
14621: LD_INT 28
14623: PPUSH
14624: LD_INT 0
14626: PPUSH
14627: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14631: LD_INT 0
14633: PPUSH
14634: LD_INT 7
14636: PUSH
14637: LD_OWVAR 67
14641: PLUS
14642: PPUSH
14643: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14647: CALL_OW 44
14651: PPUSH
14652: LD_VAR 0 3
14656: PPUSH
14657: CALL_OW 52
// end ;
14661: GO 14535
14663: POP
14664: POP
// for i = 1 to 3 do
14665: LD_ADDR_VAR 0 2
14669: PUSH
14670: DOUBLE
14671: LD_INT 1
14673: DEC
14674: ST_TO_ADDR
14675: LD_INT 3
14677: PUSH
14678: FOR_TO
14679: IFFALSE 14739
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14681: LD_INT 14
14683: PPUSH
14684: LD_INT 3
14686: PPUSH
14687: LD_INT 5
14689: PPUSH
14690: LD_INT 29
14692: PPUSH
14693: LD_INT 80
14695: PPUSH
14696: CALL 70741 0 5
// veh := CreateVehicle ;
14700: LD_ADDR_VAR 0 3
14704: PUSH
14705: CALL_OW 45
14709: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14710: LD_VAR 0 3
14714: PPUSH
14715: LD_INT 4
14717: PPUSH
14718: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14722: LD_VAR 0 3
14726: PPUSH
14727: LD_INT 28
14729: PPUSH
14730: LD_INT 0
14732: PPUSH
14733: CALL_OW 49
// end ;
14737: GO 14678
14739: POP
14740: POP
// end ;
14741: LD_VAR 0 1
14745: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14746: LD_INT 22
14748: PUSH
14749: LD_INT 2
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PPUSH
14756: CALL_OW 69
14760: IFFALSE 15060
14762: GO 14764
14764: DISABLE
14765: LD_INT 0
14767: PPUSH
14768: PPUSH
14769: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14770: LD_ADDR_VAR 0 3
14774: PUSH
14775: LD_INT 22
14777: PUSH
14778: LD_INT 2
14780: PUSH
14781: EMPTY
14782: LIST
14783: LIST
14784: PUSH
14785: LD_INT 25
14787: PUSH
14788: LD_INT 4
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: PUSH
14795: EMPTY
14796: LIST
14797: LIST
14798: PPUSH
14799: CALL_OW 69
14803: PUSH
14804: LD_EXP 94
14808: DIFF
14809: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14810: LD_ADDR_VAR 0 2
14814: PUSH
14815: LD_INT 22
14817: PUSH
14818: LD_INT 2
14820: PUSH
14821: EMPTY
14822: LIST
14823: LIST
14824: PPUSH
14825: CALL_OW 69
14829: PUSH
14830: LD_EXP 94
14834: PUSH
14835: LD_VAR 0 3
14839: UNION
14840: DIFF
14841: ST_TO_ADDR
// if Khatam then
14842: LD_EXP 94
14846: IFFALSE 14863
// ComMoveXY ( Khatam , 211 , 92 ) ;
14848: LD_EXP 94
14852: PPUSH
14853: LD_INT 211
14855: PPUSH
14856: LD_INT 92
14858: PPUSH
14859: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14863: LD_INT 197
14865: PPUSH
14866: LD_INT 80
14868: PPUSH
14869: LD_INT 2
14871: PPUSH
14872: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14876: LD_INT 213
14878: PPUSH
14879: LD_INT 90
14881: PPUSH
14882: LD_INT 2
14884: PPUSH
14885: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14889: LD_INT 215
14891: PPUSH
14892: LD_INT 129
14894: PPUSH
14895: LD_INT 2
14897: PPUSH
14898: CALL_OW 441
// if sci then
14902: LD_VAR 0 3
14906: IFFALSE 14927
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14908: LD_VAR 0 3
14912: PUSH
14913: LD_INT 1
14915: ARRAY
14916: PPUSH
14917: LD_INT 197
14919: PPUSH
14920: LD_INT 80
14922: PPUSH
14923: CALL_OW 158
// if sci > 1 then
14927: LD_VAR 0 3
14931: PUSH
14932: LD_INT 1
14934: GREATER
14935: IFFALSE 14956
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14937: LD_VAR 0 3
14941: PUSH
14942: LD_INT 2
14944: ARRAY
14945: PPUSH
14946: LD_INT 213
14948: PPUSH
14949: LD_INT 90
14951: PPUSH
14952: CALL_OW 158
// if sci > 2 then
14956: LD_VAR 0 3
14960: PUSH
14961: LD_INT 2
14963: GREATER
14964: IFFALSE 14985
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14966: LD_VAR 0 3
14970: PUSH
14971: LD_INT 3
14973: ARRAY
14974: PPUSH
14975: LD_INT 215
14977: PPUSH
14978: LD_INT 129
14980: PPUSH
14981: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14985: LD_INT 35
14987: PPUSH
14988: CALL_OW 67
// for i in tmp do
14992: LD_ADDR_VAR 0 1
14996: PUSH
14997: LD_VAR 0 2
15001: PUSH
15002: FOR_IN
15003: IFFALSE 15041
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 81
15012: PUSH
15013: LD_INT 2
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: PPUSH
15020: CALL_OW 69
15024: PPUSH
15025: LD_VAR 0 1
15029: PPUSH
15030: CALL_OW 74
15034: PPUSH
15035: CALL_OW 115
15039: GO 15002
15041: POP
15042: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
15043: LD_INT 22
15045: PUSH
15046: LD_INT 2
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PPUSH
15053: CALL_OW 69
15057: NOT
15058: IFFALSE 14985
// end ; end_of_file
15060: PPOPN 3
15062: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15063: LD_INT 0
15065: PPUSH
15066: PPUSH
15067: PPUSH
15068: PPUSH
15069: PPUSH
15070: PPUSH
15071: PPUSH
15072: PPUSH
15073: PPUSH
// Video ( true ) ;
15074: LD_INT 1
15076: PPUSH
15077: CALL 102586 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15081: LD_ADDR_VAR 0 5
15085: PUSH
15086: LD_INT 7
15088: PPUSH
15089: LD_INT 0
15091: PPUSH
15092: CALL_OW 517
15096: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15097: LD_ADDR_VAR 0 2
15101: PUSH
15102: DOUBLE
15103: LD_INT 1
15105: DEC
15106: ST_TO_ADDR
15107: LD_VAR 0 5
15111: PUSH
15112: LD_INT 1
15114: ARRAY
15115: PUSH
15116: FOR_TO
15117: IFFALSE 15162
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15119: LD_VAR 0 5
15123: PUSH
15124: LD_INT 1
15126: ARRAY
15127: PUSH
15128: LD_VAR 0 2
15132: ARRAY
15133: PPUSH
15134: LD_VAR 0 5
15138: PUSH
15139: LD_INT 2
15141: ARRAY
15142: PUSH
15143: LD_VAR 0 2
15147: ARRAY
15148: PPUSH
15149: LD_INT 1
15151: PPUSH
15152: LD_INT 15
15154: NEG
15155: PPUSH
15156: CALL 102500 0 4
15160: GO 15116
15162: POP
15163: POP
// CenterNowOnUnits ( Powell ) ;
15164: LD_EXP 58
15168: PPUSH
15169: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15173: LD_ADDR_VAR 0 5
15177: PUSH
15178: LD_EXP 56
15182: PUSH
15183: EMPTY
15184: LIST
15185: ST_TO_ADDR
// if GirlNewVeh then
15186: LD_EXP 57
15190: IFFALSE 15208
// tmp := tmp ^ GirlNewVeh ;
15192: LD_ADDR_VAR 0 5
15196: PUSH
15197: LD_VAR 0 5
15201: PUSH
15202: LD_EXP 57
15206: ADD
15207: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15208: LD_VAR 0 5
15212: PPUSH
15213: LD_INT 60
15215: PPUSH
15216: LD_INT 109
15218: PPUSH
15219: CALL_OW 111
// if KappaStatus then
15223: LD_EXP 2
15227: IFFALSE 15279
// begin Say ( JMM , D1nT-JMM-1 ) ;
15229: LD_EXP 39
15233: PPUSH
15234: LD_STRING D1nT-JMM-1
15236: PPUSH
15237: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15241: LD_EXP 58
15245: PPUSH
15246: LD_STRING D1T-Pow-1
15248: PPUSH
15249: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15253: LD_EXP 39
15257: PPUSH
15258: LD_STRING D1T-JMM-2
15260: PPUSH
15261: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15265: LD_EXP 58
15269: PPUSH
15270: LD_STRING D1T-Pow-2
15272: PPUSH
15273: CALL_OW 88
// end else
15277: GO 15485
// if JMMGirlStatus then
15279: LD_EXP 6
15283: IFFALSE 15428
// begin Say ( JMM , D1T-JMM-1 ) ;
15285: LD_EXP 39
15289: PPUSH
15290: LD_STRING D1T-JMM-1
15292: PPUSH
15293: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15297: LD_EXP 58
15301: PPUSH
15302: LD_STRING D1T-Pow-1
15304: PPUSH
15305: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15309: LD_EXP 39
15313: PPUSH
15314: LD_STRING D1T-JMM-3
15316: PPUSH
15317: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15321: LD_EXP 58
15325: PPUSH
15326: LD_STRING D1T-Pow-3
15328: PPUSH
15329: CALL_OW 88
// if JMMGirl then
15333: LD_EXP 7
15337: IFFALSE 15426
// begin case JMMGirl of 1 :
15339: LD_EXP 7
15343: PUSH
15344: LD_INT 1
15346: DOUBLE
15347: EQUAL
15348: IFTRUE 15352
15350: GO 15367
15352: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15353: LD_EXP 40
15357: PPUSH
15358: LD_STRING D1T-Joan-3
15360: PPUSH
15361: CALL_OW 88
15365: GO 15414
15367: LD_INT 2
15369: DOUBLE
15370: EQUAL
15371: IFTRUE 15375
15373: GO 15390
15375: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15376: LD_EXP 42
15380: PPUSH
15381: LD_STRING D1T-Lisa-3
15383: PPUSH
15384: CALL_OW 88
15388: GO 15414
15390: LD_INT 3
15392: DOUBLE
15393: EQUAL
15394: IFTRUE 15398
15396: GO 15413
15398: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15399: LD_EXP 54
15403: PPUSH
15404: LD_STRING D1T-Con-3
15406: PPUSH
15407: CALL_OW 88
15411: GO 15414
15413: POP
// Say ( Powell , D1T-Pow-4 ) ;
15414: LD_EXP 58
15418: PPUSH
15419: LD_STRING D1T-Pow-4
15421: PPUSH
15422: CALL_OW 88
// end ; end else
15426: GO 15485
// if not FastEnd then
15428: LD_EXP 11
15432: NOT
15433: IFFALSE 15461
// begin Say ( JMM , D1T-JMM-4 ) ;
15435: LD_EXP 39
15439: PPUSH
15440: LD_STRING D1T-JMM-4
15442: PPUSH
15443: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15447: LD_EXP 58
15451: PPUSH
15452: LD_STRING D1T-Pow-5
15454: PPUSH
15455: CALL_OW 88
// end else
15459: GO 15485
// begin Say ( JMM , D1nT-JMM-1 ) ;
15461: LD_EXP 39
15465: PPUSH
15466: LD_STRING D1nT-JMM-1
15468: PPUSH
15469: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15473: LD_EXP 58
15477: PPUSH
15478: LD_STRING D1nT-Pow-1
15480: PPUSH
15481: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15485: LD_INT 35
15487: PPUSH
15488: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15492: LD_EXP 56
15496: PPUSH
15497: CALL_OW 314
15501: NOT
15502: IFFALSE 15485
// ComExitVehicle ( JMM ) ;
15504: LD_EXP 39
15508: PPUSH
15509: CALL_OW 121
// wait ( 3 ) ;
15513: LD_INT 3
15515: PPUSH
15516: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15520: LD_EXP 39
15524: PPUSH
15525: LD_INT 60
15527: PPUSH
15528: LD_INT 94
15530: PPUSH
15531: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15535: LD_EXP 39
15539: PPUSH
15540: LD_EXP 58
15544: PPUSH
15545: CALL_OW 179
// if Joan then
15549: LD_EXP 40
15553: IFFALSE 15607
// begin ComExitVehicle ( Joan ) ;
15555: LD_EXP 40
15559: PPUSH
15560: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15564: LD_EXP 40
15568: PPUSH
15569: LD_INT 35
15571: PPUSH
15572: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15576: LD_EXP 40
15580: PPUSH
15581: LD_INT 65
15583: PPUSH
15584: LD_INT 104
15586: PPUSH
15587: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15591: LD_EXP 40
15595: PPUSH
15596: LD_EXP 39
15600: PPUSH
15601: CALL_OW 179
// end else
15605: GO 15741
// if Lisa and JMMGirl = 2 then
15607: LD_EXP 42
15611: PUSH
15612: LD_EXP 7
15616: PUSH
15617: LD_INT 2
15619: EQUAL
15620: AND
15621: IFFALSE 15675
// begin ComExitVehicle ( Lisa ) ;
15623: LD_EXP 42
15627: PPUSH
15628: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15632: LD_EXP 42
15636: PPUSH
15637: LD_INT 35
15639: PPUSH
15640: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15644: LD_EXP 42
15648: PPUSH
15649: LD_INT 65
15651: PPUSH
15652: LD_INT 104
15654: PPUSH
15655: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15659: LD_EXP 42
15663: PPUSH
15664: LD_EXP 39
15668: PPUSH
15669: CALL_OW 179
// end else
15673: GO 15741
// if Connie and JMMGirl = 3 then
15675: LD_EXP 54
15679: PUSH
15680: LD_EXP 7
15684: PUSH
15685: LD_INT 3
15687: EQUAL
15688: AND
15689: IFFALSE 15741
// begin ComExitVehicle ( Connie ) ;
15691: LD_EXP 54
15695: PPUSH
15696: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15700: LD_EXP 54
15704: PPUSH
15705: LD_INT 35
15707: PPUSH
15708: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15712: LD_EXP 54
15716: PPUSH
15717: LD_INT 65
15719: PPUSH
15720: LD_INT 104
15722: PPUSH
15723: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15727: LD_EXP 54
15731: PPUSH
15732: LD_EXP 39
15736: PPUSH
15737: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15741: LD_INT 35
15743: PPUSH
15744: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15748: LD_EXP 39
15752: PPUSH
15753: LD_EXP 58
15757: PPUSH
15758: CALL_OW 296
15762: PUSH
15763: LD_INT 6
15765: LESS
15766: IFFALSE 15741
// wait ( 0 0$0.5 ) ;
15768: LD_INT 18
15770: PPUSH
15771: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15775: LD_EXP 39
15779: PPUSH
15780: LD_STRING D1-JMM-1
15782: PPUSH
15783: CALL_OW 88
// async ;
15787: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15788: LD_EXP 58
15792: PPUSH
15793: LD_STRING D1-Pow-1
15795: PPUSH
15796: CALL_OW 88
// if not dialogue_skipped then
15800: LD_OWVAR 59
15804: NOT
15805: IFFALSE 15814
// wait ( 0 0$2 ) ;
15807: LD_INT 70
15809: PPUSH
15810: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15814: LD_INT 170
15816: PPUSH
15817: LD_INT 99
15819: PPUSH
15820: LD_INT 1
15822: PPUSH
15823: LD_INT 6
15825: NEG
15826: PPUSH
15827: CALL 102500 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15831: LD_INT 174
15833: PPUSH
15834: LD_INT 115
15836: PPUSH
15837: LD_INT 1
15839: PPUSH
15840: LD_INT 6
15842: NEG
15843: PPUSH
15844: CALL 102500 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15848: LD_INT 169
15850: PPUSH
15851: LD_INT 71
15853: PPUSH
15854: LD_INT 1
15856: PPUSH
15857: LD_INT 6
15859: NEG
15860: PPUSH
15861: CALL 102500 0 4
// if not dialogue_skipped then
15865: LD_OWVAR 59
15869: NOT
15870: IFFALSE 15889
// begin CenterOnXY ( 170 , 99 ) ;
15872: LD_INT 170
15874: PPUSH
15875: LD_INT 99
15877: PPUSH
15878: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15882: LD_INT 80
15884: PPUSH
15885: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15889: LD_INT 75
15891: PPUSH
15892: LD_INT 53
15894: PPUSH
15895: LD_INT 1
15897: PPUSH
15898: LD_INT 9
15900: NEG
15901: PPUSH
15902: CALL 102500 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15906: LD_INT 54
15908: PPUSH
15909: LD_INT 42
15911: PPUSH
15912: LD_INT 1
15914: PPUSH
15915: LD_INT 9
15917: NEG
15918: PPUSH
15919: CALL 102500 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15923: LD_INT 62
15925: PPUSH
15926: LD_INT 51
15928: PPUSH
15929: LD_INT 1
15931: PPUSH
15932: LD_INT 9
15934: NEG
15935: PPUSH
15936: CALL 102500 0 4
// if not dialogue_skipped then
15940: LD_OWVAR 59
15944: NOT
15945: IFFALSE 15964
// begin CenterOnXY ( 75 , 53 ) ;
15947: LD_INT 75
15949: PPUSH
15950: LD_INT 53
15952: PPUSH
15953: CALL_OW 84
// wait ( 0 0$4 ) ;
15957: LD_INT 140
15959: PPUSH
15960: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15964: LD_EXP 58
15968: PPUSH
15969: CALL_OW 87
// if not dialogue_skipped then
15973: LD_OWVAR 59
15977: NOT
15978: IFFALSE 15987
// wait ( 0 0$2 ) ;
15980: LD_INT 70
15982: PPUSH
15983: CALL_OW 67
// sync ;
15987: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-2
15995: PPUSH
15996: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16000: LD_EXP 58
16004: PPUSH
16005: LD_STRING D1-Pow-2
16007: PPUSH
16008: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16012: LD_EXP 39
16016: PPUSH
16017: LD_STRING D1-JMM-3
16019: PPUSH
16020: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16024: LD_EXP 58
16028: PPUSH
16029: LD_STRING D1-Pow-3
16031: PPUSH
16032: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16036: LD_EXP 39
16040: PPUSH
16041: LD_STRING D1-JMM-4
16043: PPUSH
16044: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16048: LD_EXP 58
16052: PPUSH
16053: LD_STRING D1-Pow-4
16055: PPUSH
16056: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16060: LD_EXP 39
16064: PPUSH
16065: LD_STRING D1-JMM-5
16067: PPUSH
16068: CALL_OW 88
// async ;
16072: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16073: LD_EXP 58
16077: PPUSH
16078: LD_STRING D1-Pow-5
16080: PPUSH
16081: CALL_OW 88
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16099
// wait ( 0 0$3.6 ) ;
16092: LD_INT 126
16094: PPUSH
16095: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16099: LD_INT 134
16101: PPUSH
16102: LD_INT 210
16104: PPUSH
16105: LD_INT 1
16107: PPUSH
16108: LD_INT 11
16110: NEG
16111: PPUSH
16112: CALL 102500 0 4
// if not dialogue_skipped then
16116: LD_OWVAR 59
16120: NOT
16121: IFFALSE 16140
// begin CenterOnXY ( 134 , 210 ) ;
16123: LD_INT 134
16125: PPUSH
16126: LD_INT 210
16128: PPUSH
16129: CALL_OW 84
// wait ( 0 0$2 ) ;
16133: LD_INT 70
16135: PPUSH
16136: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16140: LD_INT 101
16142: PPUSH
16143: LD_INT 159
16145: PPUSH
16146: LD_INT 1
16148: PPUSH
16149: LD_INT 10
16151: NEG
16152: PPUSH
16153: CALL 102500 0 4
// if not dialogue_skipped then
16157: LD_OWVAR 59
16161: NOT
16162: IFFALSE 16181
// begin CenterOnXY ( 101 , 159 ) ;
16164: LD_INT 101
16166: PPUSH
16167: LD_INT 159
16169: PPUSH
16170: CALL_OW 84
// wait ( 0 0$2 ) ;
16174: LD_INT 70
16176: PPUSH
16177: CALL_OW 67
// end ; sync ;
16181: SYNC
// CenterNowOnUnits ( Powell ) ;
16182: LD_EXP 58
16186: PPUSH
16187: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16191: LD_ADDR_VAR 0 6
16195: PUSH
16196: LD_INT 1
16198: PUSH
16199: LD_INT 2
16201: PUSH
16202: LD_INT 3
16204: PUSH
16205: LD_INT 4
16207: PUSH
16208: LD_INT 5
16210: PUSH
16211: LD_INT 6
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: LIST
16218: LIST
16219: LIST
16220: LIST
16221: ST_TO_ADDR
// if not dialogue_skipped then
16222: LD_OWVAR 59
16226: NOT
16227: IFFALSE 16396
// begin game_speed := 4 ;
16229: LD_ADDR_OWVAR 65
16233: PUSH
16234: LD_INT 4
16236: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16237: LD_INT 210
16239: PPUSH
16240: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16244: LD_ADDR_VAR 0 7
16248: PUSH
16249: LD_STRING Q1
16251: PPUSH
16252: LD_VAR 0 6
16256: PPUSH
16257: CALL_OW 98
16261: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16262: LD_ADDR_VAR 0 7
16266: PUSH
16267: LD_STRING Q1
16269: PPUSH
16270: LD_VAR 0 6
16274: PPUSH
16275: CALL_OW 98
16279: ST_TO_ADDR
// options = options diff dec ;
16280: LD_ADDR_VAR 0 6
16284: PUSH
16285: LD_VAR 0 6
16289: PUSH
16290: LD_VAR 0 7
16294: DIFF
16295: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16296: LD_VAR 0 7
16300: PPUSH
16301: LD_VAR 0 6
16305: PPUSH
16306: CALL 17868 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16310: LD_VAR 0 7
16314: PUSH
16315: LD_INT 5
16317: PUSH
16318: LD_INT 6
16320: PUSH
16321: EMPTY
16322: LIST
16323: LIST
16324: IN
16325: PUSH
16326: LD_VAR 0 6
16330: PUSH
16331: LD_INT 2
16333: EQUAL
16334: OR
16335: IFFALSE 16262
// if not ( dec in [ 5 , 6 ] ) then
16337: LD_VAR 0 7
16341: PUSH
16342: LD_INT 5
16344: PUSH
16345: LD_INT 6
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: IN
16352: NOT
16353: IFFALSE 16396
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16355: LD_ADDR_VAR 0 7
16359: PUSH
16360: LD_STRING Q1a
16362: PPUSH
16363: LD_INT 1
16365: PUSH
16366: LD_INT 2
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PPUSH
16373: CALL_OW 98
16377: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16378: LD_VAR 0 7
16382: PUSH
16383: LD_INT 4
16385: PLUS
16386: PPUSH
16387: LD_VAR 0 6
16391: PPUSH
16392: CALL 17868 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16396: LD_INT 81
16398: PPUSH
16399: LD_INT 127
16401: PPUSH
16402: CALL_OW 84
// amount := 5 ;
16406: LD_ADDR_VAR 0 8
16410: PUSH
16411: LD_INT 5
16413: ST_TO_ADDR
// macmilan_squad := [ ] ;
16414: LD_ADDR_VAR 0 9
16418: PUSH
16419: EMPTY
16420: ST_TO_ADDR
// if vip < amount then
16421: LD_EXP 59
16425: PUSH
16426: LD_VAR 0 8
16430: LESS
16431: IFFALSE 16475
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16433: LD_ADDR_VAR 0 5
16437: PUSH
16438: LD_EXP 59
16442: PUSH
16443: LD_INT 22
16445: PUSH
16446: LD_INT 4
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: PUSH
16453: LD_INT 21
16455: PUSH
16456: LD_INT 1
16458: PUSH
16459: EMPTY
16460: LIST
16461: LIST
16462: PUSH
16463: EMPTY
16464: LIST
16465: LIST
16466: PPUSH
16467: CALL_OW 69
16471: UNION
16472: ST_TO_ADDR
16473: GO 16485
// tmp := vip ;
16475: LD_ADDR_VAR 0 5
16479: PUSH
16480: LD_EXP 59
16484: ST_TO_ADDR
// tmp := tmp diff Powell ;
16485: LD_ADDR_VAR 0 5
16489: PUSH
16490: LD_VAR 0 5
16494: PUSH
16495: LD_EXP 58
16499: DIFF
16500: ST_TO_ADDR
// if tmp < amount then
16501: LD_VAR 0 5
16505: PUSH
16506: LD_VAR 0 8
16510: LESS
16511: IFFALSE 16523
// amount := tmp ;
16513: LD_ADDR_VAR 0 8
16517: PUSH
16518: LD_VAR 0 5
16522: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16523: LD_VAR 0 5
16527: PUSH
16528: LD_INT 1
16530: ARRAY
16531: PPUSH
16532: CALL_OW 257
16536: PUSH
16537: LD_INT 2
16539: NONEQUAL
16540: IFFALSE 16602
// begin if IsInUnit ( tmp [ 1 ] ) then
16542: LD_VAR 0 5
16546: PUSH
16547: LD_INT 1
16549: ARRAY
16550: PPUSH
16551: CALL_OW 310
16555: IFFALSE 16570
// ComExitBuilding ( tmp [ 1 ] ) ;
16557: LD_VAR 0 5
16561: PUSH
16562: LD_INT 1
16564: ARRAY
16565: PPUSH
16566: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16570: LD_VAR 0 5
16574: PUSH
16575: LD_INT 1
16577: ARRAY
16578: PPUSH
16579: LD_INT 387
16581: PPUSH
16582: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16586: LD_VAR 0 5
16590: PUSH
16591: LD_INT 1
16593: ARRAY
16594: PPUSH
16595: LD_INT 2
16597: PPUSH
16598: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16602: LD_EXP 39
16606: PPUSH
16607: LD_INT 82
16609: PPUSH
16610: LD_INT 129
16612: PPUSH
16613: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16617: LD_EXP 39
16621: PPUSH
16622: LD_EXP 58
16626: PPUSH
16627: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16631: LD_INT 22
16633: PUSH
16634: LD_INT 1
16636: PUSH
16637: EMPTY
16638: LIST
16639: LIST
16640: PPUSH
16641: CALL_OW 69
16645: PUSH
16646: LD_EXP 39
16650: DIFF
16651: PPUSH
16652: LD_INT 84
16654: PPUSH
16655: LD_INT 128
16657: PPUSH
16658: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16662: LD_INT 22
16664: PUSH
16665: LD_INT 1
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: PPUSH
16672: CALL_OW 69
16676: PUSH
16677: LD_EXP 39
16681: DIFF
16682: PPUSH
16683: LD_EXP 39
16687: PPUSH
16688: CALL_OW 179
// for i = 1 to amount do
16692: LD_ADDR_VAR 0 2
16696: PUSH
16697: DOUBLE
16698: LD_INT 1
16700: DEC
16701: ST_TO_ADDR
16702: LD_VAR 0 8
16706: PUSH
16707: FOR_TO
16708: IFFALSE 16876
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16710: LD_ADDR_VAR 0 9
16714: PUSH
16715: LD_VAR 0 9
16719: PUSH
16720: LD_VAR 0 5
16724: PUSH
16725: LD_VAR 0 2
16729: ARRAY
16730: ADD
16731: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16732: LD_VAR 0 5
16736: PUSH
16737: LD_VAR 0 2
16741: ARRAY
16742: PPUSH
16743: CALL_OW 310
16747: IFFALSE 16764
// AddComExitBuilding ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 182
// if i = 2 and JMMNewVeh then
16764: LD_VAR 0 2
16768: PUSH
16769: LD_INT 2
16771: EQUAL
16772: PUSH
16773: LD_EXP 56
16777: AND
16778: IFFALSE 16836
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16780: LD_VAR 0 5
16784: PUSH
16785: LD_VAR 0 2
16789: ARRAY
16790: PPUSH
16791: LD_EXP 56
16795: PPUSH
16796: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16800: LD_VAR 0 5
16804: PUSH
16805: LD_VAR 0 2
16809: ARRAY
16810: PPUSH
16811: LD_INT 86
16813: PPUSH
16814: LD_INT 133
16816: PPUSH
16817: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16821: LD_VAR 0 5
16825: PUSH
16826: LD_VAR 0 2
16830: ARRAY
16831: PPUSH
16832: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16836: LD_VAR 0 5
16840: PUSH
16841: LD_VAR 0 2
16845: ARRAY
16846: PPUSH
16847: LD_INT 8
16849: PPUSH
16850: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16854: LD_VAR 0 5
16858: PUSH
16859: LD_VAR 0 2
16863: ARRAY
16864: PPUSH
16865: LD_EXP 39
16869: PPUSH
16870: CALL_OW 179
// end ;
16874: GO 16707
16876: POP
16877: POP
// if GirlNewVeh then
16878: LD_EXP 57
16882: IFFALSE 16896
// SetSide ( GirlNewVeh , 4 ) ;
16884: LD_EXP 57
16888: PPUSH
16889: LD_INT 4
16891: PPUSH
16892: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16896: LD_INT 35
16898: PPUSH
16899: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16903: LD_VAR 0 9
16907: PPUSH
16908: LD_INT 95
16910: PUSH
16911: LD_INT 9
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PPUSH
16918: CALL_OW 72
16922: PUSH
16923: LD_INT 0
16925: EQUAL
16926: PUSH
16927: LD_EXP 39
16931: PPUSH
16932: LD_INT 9
16934: PPUSH
16935: CALL_OW 308
16939: NOT
16940: AND
16941: IFFALSE 16896
// wait ( 0 0$2 ) ;
16943: LD_INT 70
16945: PPUSH
16946: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16950: LD_VAR 0 9
16954: PPUSH
16955: LD_INT 1
16957: PPUSH
16958: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16962: LD_INT 21
16964: PUSH
16965: LD_INT 2
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: PUSH
16972: LD_INT 92
16974: PUSH
16975: LD_INT 83
16977: PUSH
16978: LD_INT 130
16980: PUSH
16981: LD_INT 10
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: LIST
16988: LIST
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: PPUSH
16994: CALL_OW 69
16998: PPUSH
16999: LD_INT 1
17001: PPUSH
17002: CALL_OW 235
// Video ( false ) ;
17006: LD_INT 0
17008: PPUSH
17009: CALL 102586 0 1
// ChangeMissionObjectives ( M1 ) ;
17013: LD_STRING M1
17015: PPUSH
17016: CALL_OW 337
// SaveForQuickRestart ;
17020: CALL_OW 22
// missionStart := true ;
17024: LD_ADDR_EXP 13
17028: PUSH
17029: LD_INT 1
17031: ST_TO_ADDR
// missionStage := 2 ;
17032: LD_ADDR_EXP 15
17036: PUSH
17037: LD_INT 2
17039: ST_TO_ADDR
// wait ( 0 0$3 ) ;
17040: LD_INT 105
17042: PPUSH
17043: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17047: LD_ADDR_VAR 0 5
17051: PUSH
17052: LD_INT 22
17054: PUSH
17055: LD_INT 4
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: PUSH
17062: LD_INT 21
17064: PUSH
17065: LD_INT 1
17067: PUSH
17068: EMPTY
17069: LIST
17070: LIST
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: PPUSH
17076: CALL_OW 69
17080: PUSH
17081: LD_EXP 58
17085: DIFF
17086: ST_TO_ADDR
// if not tmp then
17087: LD_VAR 0 5
17091: NOT
17092: IFFALSE 17107
// tmp := [ Powell ] ;
17094: LD_ADDR_VAR 0 5
17098: PUSH
17099: LD_EXP 58
17103: PUSH
17104: EMPTY
17105: LIST
17106: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17107: LD_ADDR_EXP 116
17111: PUSH
17112: LD_EXP 116
17116: PPUSH
17117: LD_INT 4
17119: PPUSH
17120: LD_INT 22
17122: PUSH
17123: LD_INT 4
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: PUSH
17130: LD_INT 23
17132: PUSH
17133: LD_INT 1
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: PUSH
17140: LD_INT 3
17142: PUSH
17143: LD_INT 21
17145: PUSH
17146: LD_INT 2
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: PPUSH
17162: CALL_OW 69
17166: PUSH
17167: LD_EXP 58
17171: DIFF
17172: PPUSH
17173: CALL_OW 1
17177: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17178: LD_ADDR_VAR 0 4
17182: PUSH
17183: LD_INT 22
17185: PUSH
17186: LD_INT 4
17188: PUSH
17189: EMPTY
17190: LIST
17191: LIST
17192: PUSH
17193: LD_INT 34
17195: PUSH
17196: LD_INT 12
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: PPUSH
17207: CALL_OW 69
17211: PUSH
17212: LD_INT 1
17214: ARRAY
17215: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17216: LD_VAR 0 5
17220: PUSH
17221: LD_INT 1
17223: ARRAY
17224: PPUSH
17225: CALL_OW 310
17229: IFFALSE 17244
// ComExitBuilding ( tmp [ 1 ] ) ;
17231: LD_VAR 0 5
17235: PUSH
17236: LD_INT 1
17238: ARRAY
17239: PPUSH
17240: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17244: LD_VAR 0 5
17248: PUSH
17249: LD_INT 1
17251: ARRAY
17252: PPUSH
17253: LD_VAR 0 4
17257: PPUSH
17258: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17262: LD_VAR 0 5
17266: PUSH
17267: LD_INT 1
17269: ARRAY
17270: PPUSH
17271: LD_INT 80
17273: PPUSH
17274: LD_INT 136
17276: PPUSH
17277: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17281: LD_VAR 0 5
17285: PUSH
17286: LD_INT 1
17288: ARRAY
17289: PPUSH
17290: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17294: LD_VAR 0 5
17298: PUSH
17299: LD_INT 1
17301: ARRAY
17302: PPUSH
17303: LD_INT 59
17305: PPUSH
17306: LD_INT 112
17308: PPUSH
17309: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17313: LD_VAR 0 5
17317: PUSH
17318: LD_INT 1
17320: ARRAY
17321: PPUSH
17322: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17326: LD_EXP 40
17330: PUSH
17331: LD_EXP 40
17335: PPUSH
17336: CALL_OW 255
17340: PUSH
17341: LD_INT 1
17343: EQUAL
17344: AND
17345: IFFALSE 17371
// begin Say ( Joan , D3W-Joan-1 ) ;
17347: LD_EXP 40
17351: PPUSH
17352: LD_STRING D3W-Joan-1
17354: PPUSH
17355: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17359: LD_EXP 39
17363: PPUSH
17364: LD_STRING D3W-JMM-1
17366: PPUSH
17367: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17371: LD_EXP 42
17375: PUSH
17376: LD_EXP 42
17380: PPUSH
17381: CALL_OW 255
17385: PUSH
17386: LD_INT 1
17388: EQUAL
17389: AND
17390: PUSH
17391: LD_EXP 42
17395: PUSH
17396: LD_EXP 59
17400: IN
17401: NOT
17402: AND
17403: IFFALSE 17429
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17405: LD_EXP 42
17409: PPUSH
17410: LD_STRING D3W-Lisa-1
17412: PPUSH
17413: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17417: LD_EXP 39
17421: PPUSH
17422: LD_STRING D3W-JMM-1
17424: PPUSH
17425: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17429: LD_EXP 54
17433: PUSH
17434: LD_EXP 54
17438: PPUSH
17439: CALL_OW 255
17443: PUSH
17444: LD_INT 1
17446: EQUAL
17447: AND
17448: IFFALSE 17474
// begin Say ( Connie , D3W-Con-1 ) ;
17450: LD_EXP 54
17454: PPUSH
17455: LD_STRING D3W-Con-1
17457: PPUSH
17458: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17462: LD_EXP 39
17466: PPUSH
17467: LD_STRING D3W-JMM-1
17469: PPUSH
17470: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17474: LD_EXP 42
17478: PUSH
17479: LD_EXP 59
17483: IN
17484: PUSH
17485: LD_EXP 42
17489: PPUSH
17490: CALL_OW 255
17494: PUSH
17495: LD_INT 1
17497: EQUAL
17498: AND
17499: IFFALSE 17515
// Say ( Lisa , D3nW-Lisa-1 ) else
17501: LD_EXP 42
17505: PPUSH
17506: LD_STRING D3nW-Lisa-1
17508: PPUSH
17509: CALL_OW 88
17513: GO 17759
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17515: LD_EXP 45
17519: PUSH
17520: LD_EXP 59
17524: IN
17525: PUSH
17526: LD_EXP 45
17530: PPUSH
17531: CALL_OW 255
17535: PUSH
17536: LD_INT 1
17538: EQUAL
17539: AND
17540: IFFALSE 17556
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17542: LD_EXP 45
17546: PPUSH
17547: LD_STRING D3nW-Cyrus-1
17549: PPUSH
17550: CALL_OW 88
17554: GO 17759
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17556: LD_EXP 44
17560: PUSH
17561: LD_EXP 59
17565: IN
17566: PUSH
17567: LD_EXP 44
17571: PPUSH
17572: CALL_OW 255
17576: PUSH
17577: LD_INT 1
17579: EQUAL
17580: AND
17581: IFFALSE 17597
// Say ( Bobby , D3nW-Bobby-1 ) else
17583: LD_EXP 44
17587: PPUSH
17588: LD_STRING D3nW-Bobby-1
17590: PPUSH
17591: CALL_OW 88
17595: GO 17759
// if Gary in vip and GetSide ( Gary ) = 1 then
17597: LD_EXP 51
17601: PUSH
17602: LD_EXP 59
17606: IN
17607: PUSH
17608: LD_EXP 51
17612: PPUSH
17613: CALL_OW 255
17617: PUSH
17618: LD_INT 1
17620: EQUAL
17621: AND
17622: IFFALSE 17638
// Say ( Gary , D3nW-Gary-1 ) else
17624: LD_EXP 51
17628: PPUSH
17629: LD_STRING D3nW-Gary-1
17631: PPUSH
17632: CALL_OW 88
17636: GO 17759
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17638: LD_EXP 43
17642: PUSH
17643: LD_EXP 59
17647: IN
17648: PUSH
17649: LD_EXP 43
17653: PPUSH
17654: CALL_OW 255
17658: PUSH
17659: LD_INT 1
17661: EQUAL
17662: AND
17663: IFFALSE 17679
// Say ( Donaldson , D3nW-Don-1 ) else
17665: LD_EXP 43
17669: PPUSH
17670: LD_STRING D3nW-Don-1
17672: PPUSH
17673: CALL_OW 88
17677: GO 17759
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17679: LD_EXP 50
17683: PUSH
17684: LD_EXP 59
17688: IN
17689: PUSH
17690: LD_EXP 50
17694: PPUSH
17695: CALL_OW 255
17699: PUSH
17700: LD_INT 1
17702: EQUAL
17703: AND
17704: IFFALSE 17720
// Say ( Cornel , D3nW-Corn-1 ) else
17706: LD_EXP 50
17710: PPUSH
17711: LD_STRING D3nW-Corn-1
17713: PPUSH
17714: CALL_OW 88
17718: GO 17759
// if Frank in vip and GetSide ( Frank ) = 1 then
17720: LD_EXP 52
17724: PUSH
17725: LD_EXP 59
17729: IN
17730: PUSH
17731: LD_EXP 52
17735: PPUSH
17736: CALL_OW 255
17740: PUSH
17741: LD_INT 1
17743: EQUAL
17744: AND
17745: IFFALSE 17759
// Say ( Frank , D3nW-Frank-1 ) ;
17747: LD_EXP 52
17751: PPUSH
17752: LD_STRING D3nW-Frank-1
17754: PPUSH
17755: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17759: LD_EXP 59
17763: PPUSH
17764: LD_INT 22
17766: PUSH
17767: LD_INT 1
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: PPUSH
17774: CALL_OW 72
17778: IFFALSE 17804
// begin Say ( JMM , D3nW-JMM-1 ) ;
17780: LD_EXP 39
17784: PPUSH
17785: LD_STRING D3nW-JMM-1
17787: PPUSH
17788: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17792: LD_EXP 39
17796: PPUSH
17797: LD_STRING D3nW-JMM-1a
17799: PPUSH
17800: CALL_OW 88
// end ; t := 0 0$00 ;
17804: LD_ADDR_VAR 0 3
17808: PUSH
17809: LD_INT 0
17811: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17812: LD_INT 35
17814: PPUSH
17815: CALL_OW 67
// t := t + 0 0$1 ;
17819: LD_ADDR_VAR 0 3
17823: PUSH
17824: LD_VAR 0 3
17828: PUSH
17829: LD_INT 35
17831: PLUS
17832: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17833: LD_INT 59
17835: PPUSH
17836: LD_INT 112
17838: PPUSH
17839: CALL_OW 428
17843: PUSH
17844: LD_VAR 0 3
17848: PUSH
17849: LD_INT 2100
17851: GREATER
17852: OR
17853: IFFALSE 17812
// activeAttacks := true ;
17855: LD_ADDR_EXP 16
17859: PUSH
17860: LD_INT 1
17862: ST_TO_ADDR
// end ;
17863: LD_VAR 0 1
17867: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17868: LD_INT 0
17870: PPUSH
// case question of 1 :
17871: LD_VAR 0 1
17875: PUSH
17876: LD_INT 1
17878: DOUBLE
17879: EQUAL
17880: IFTRUE 17884
17882: GO 17935
17884: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17885: LD_EXP 39
17889: PPUSH
17890: LD_STRING D2Mot-JMM-1
17892: PPUSH
17893: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17897: LD_EXP 58
17901: PPUSH
17902: LD_STRING D2Mot-Pow-1
17904: PPUSH
17905: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17909: LD_EXP 39
17913: PPUSH
17914: LD_STRING D2Mot-JMM-2
17916: PPUSH
17917: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17921: LD_EXP 58
17925: PPUSH
17926: LD_STRING D2Mot-Pow-2
17928: PPUSH
17929: CALL_OW 88
// end ; 2 :
17933: GO 18286
17935: LD_INT 2
17937: DOUBLE
17938: EQUAL
17939: IFTRUE 17943
17941: GO 18019
17943: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17944: LD_EXP 39
17948: PPUSH
17949: LD_STRING D2Rus-JMM-1
17951: PPUSH
17952: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17956: LD_EXP 58
17960: PPUSH
17961: LD_STRING D2Rus-Pow-1
17963: PPUSH
17964: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17968: LD_EXP 39
17972: PPUSH
17973: LD_STRING D2Rus-JMM-2
17975: PPUSH
17976: CALL_OW 88
// if not ( 3 in list_of_q ) then
17980: LD_INT 3
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: NOT
17989: IFFALSE 18005
// Say ( Powell , D2Rus-Pow-2 ) else
17991: LD_EXP 58
17995: PPUSH
17996: LD_STRING D2Rus-Pow-2
17998: PPUSH
17999: CALL_OW 88
18003: GO 18017
// Say ( Powell , D2Rus-Pow-2a ) ;
18005: LD_EXP 58
18009: PPUSH
18010: LD_STRING D2Rus-Pow-2a
18012: PPUSH
18013: CALL_OW 88
// end ; 3 :
18017: GO 18286
18019: LD_INT 3
18021: DOUBLE
18022: EQUAL
18023: IFTRUE 18027
18025: GO 18112
18027: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18028: LD_EXP 39
18032: PPUSH
18033: LD_STRING D2Leg-JMM-1
18035: PPUSH
18036: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18040: LD_EXP 58
18044: PPUSH
18045: LD_STRING D2Leg-Pow-1
18047: PPUSH
18048: CALL_OW 88
// if 2 in list_of_q then
18052: LD_INT 2
18054: PUSH
18055: LD_VAR 0 2
18059: IN
18060: IFFALSE 18086
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18062: LD_EXP 39
18066: PPUSH
18067: LD_STRING D2Leg-JMM-2
18069: PPUSH
18070: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18074: LD_EXP 58
18078: PPUSH
18079: LD_STRING D2Leg-Pow-2
18081: PPUSH
18082: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18086: LD_EXP 39
18090: PPUSH
18091: LD_STRING D2Leg-JMM-3
18093: PPUSH
18094: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18098: LD_EXP 58
18102: PPUSH
18103: LD_STRING D2Leg-Pow-3
18105: PPUSH
18106: CALL_OW 88
// end ; 4 :
18110: GO 18286
18112: LD_INT 4
18114: DOUBLE
18115: EQUAL
18116: IFTRUE 18120
18118: GO 18195
18120: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18121: LD_EXP 39
18125: PPUSH
18126: LD_STRING D2Ar-JMM-1
18128: PPUSH
18129: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18133: LD_EXP 58
18137: PPUSH
18138: LD_STRING D2Ar-Pow-1
18140: PPUSH
18141: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18145: LD_EXP 39
18149: PPUSH
18150: LD_STRING D2Ar-JMM-2
18152: PPUSH
18153: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18157: LD_EXP 58
18161: PPUSH
18162: LD_STRING D2Ar-Pow-2
18164: PPUSH
18165: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18169: LD_EXP 39
18173: PPUSH
18174: LD_STRING D2Ar-JMM-3
18176: PPUSH
18177: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18181: LD_EXP 58
18185: PPUSH
18186: LD_STRING D2Ar-Pow-3
18188: PPUSH
18189: CALL_OW 88
// end ; 5 :
18193: GO 18286
18195: LD_INT 5
18197: DOUBLE
18198: EQUAL
18199: IFTRUE 18203
18201: GO 18218
18203: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18204: LD_EXP 39
18208: PPUSH
18209: LD_STRING D2Conf-JMM-1
18211: PPUSH
18212: CALL_OW 88
18216: GO 18286
18218: LD_INT 6
18220: DOUBLE
18221: EQUAL
18222: IFTRUE 18226
18224: GO 18285
18226: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18227: LD_EXP 39
18231: PPUSH
18232: LD_STRING D2Com-JMM-1
18234: PPUSH
18235: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18239: LD_EXP 58
18243: PPUSH
18244: LD_STRING D2Com-Pow-1
18246: PPUSH
18247: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18251: LD_EXP 39
18255: PPUSH
18256: LD_STRING D2Com-JMM-2
18258: PPUSH
18259: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18263: LD_EXP 58
18267: PPUSH
18268: LD_STRING D2Com-Pow-2
18270: PPUSH
18271: CALL_OW 88
// powellAngerQuery := true ;
18275: LD_ADDR_EXP 36
18279: PUSH
18280: LD_INT 1
18282: ST_TO_ADDR
// end ; end ;
18283: GO 18286
18285: POP
// end ;
18286: LD_VAR 0 3
18290: RET
// every 0 0$5 trigger missionStart do var tmp ;
18291: LD_EXP 13
18295: IFFALSE 18578
18297: GO 18299
18299: DISABLE
18300: LD_INT 0
18302: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18303: LD_INT 35
18305: PPUSH
18306: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18310: LD_INT 14
18312: PPUSH
18313: LD_INT 22
18315: PUSH
18316: LD_INT 1
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PPUSH
18323: CALL_OW 70
18327: PUSH
18328: LD_EXP 15
18332: PUSH
18333: LD_INT 2
18335: PUSH
18336: LD_INT 3
18338: PUSH
18339: LD_INT 4
18341: PUSH
18342: LD_INT 5
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: LIST
18349: LIST
18350: IN
18351: AND
18352: IFFALSE 18568
// begin powellAnger := powellAnger + 1 ;
18354: LD_ADDR_EXP 17
18358: PUSH
18359: LD_EXP 17
18363: PUSH
18364: LD_INT 1
18366: PLUS
18367: ST_TO_ADDR
// Video ( true ) ;
18368: LD_INT 1
18370: PPUSH
18371: CALL 102586 0 1
// CenterNowOnUnits ( tmp ) ;
18375: LD_VAR 0 1
18379: PPUSH
18380: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18384: LD_INT 14
18386: PPUSH
18387: LD_INT 22
18389: PUSH
18390: LD_INT 1
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PPUSH
18397: CALL_OW 70
18401: PPUSH
18402: LD_INT 86
18404: PPUSH
18405: LD_INT 133
18407: PPUSH
18408: CALL_OW 111
// async ;
18412: ASYNC
// case powellAnger of 1 :
18413: LD_EXP 17
18417: PUSH
18418: LD_INT 1
18420: DOUBLE
18421: EQUAL
18422: IFTRUE 18426
18424: GO 18441
18426: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18427: LD_EXP 58
18431: PPUSH
18432: LD_STRING DBack1-Pow-1
18434: PPUSH
18435: CALL_OW 88
18439: GO 18488
18441: LD_INT 2
18443: DOUBLE
18444: EQUAL
18445: IFTRUE 18449
18447: GO 18464
18449: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18450: LD_EXP 58
18454: PPUSH
18455: LD_STRING DBack2-Pow-1
18457: PPUSH
18458: CALL_OW 88
18462: GO 18488
18464: LD_INT 3
18466: DOUBLE
18467: EQUAL
18468: IFTRUE 18472
18470: GO 18487
18472: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18473: LD_EXP 58
18477: PPUSH
18478: LD_STRING DBack3-Pow-1
18480: PPUSH
18481: CALL_OW 88
18485: GO 18488
18487: POP
// sync ;
18488: SYNC
// repeat wait ( 0 0$1 ) ;
18489: LD_INT 35
18491: PPUSH
18492: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18496: LD_INT 14
18498: PPUSH
18499: LD_INT 22
18501: PUSH
18502: LD_INT 1
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PPUSH
18509: CALL_OW 70
18513: PPUSH
18514: LD_INT 86
18516: PPUSH
18517: LD_INT 133
18519: PPUSH
18520: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18524: LD_INT 14
18526: PPUSH
18527: LD_INT 22
18529: PUSH
18530: LD_INT 1
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: PPUSH
18537: CALL_OW 70
18541: NOT
18542: IFFALSE 18489
// if powellAnger >= 3 then
18544: LD_EXP 17
18548: PUSH
18549: LD_INT 3
18551: GREATEREQUAL
18552: IFFALSE 18561
// YouLost ( Dismissed ) ;
18554: LD_STRING Dismissed
18556: PPUSH
18557: CALL_OW 104
// Video ( false ) ;
18561: LD_INT 0
18563: PPUSH
18564: CALL 102586 0 1
// end ; until missionStage > 5 ;
18568: LD_EXP 15
18572: PUSH
18573: LD_INT 5
18575: GREATER
18576: IFFALSE 18303
// end ;
18578: PPOPN 1
18580: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18581: LD_EXP 13
18585: PUSH
18586: LD_INT 22
18588: PUSH
18589: LD_INT 4
18591: PUSH
18592: EMPTY
18593: LIST
18594: LIST
18595: PUSH
18596: LD_INT 21
18598: PUSH
18599: LD_INT 2
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: PUSH
18606: EMPTY
18607: LIST
18608: LIST
18609: PPUSH
18610: CALL_OW 69
18614: PUSH
18615: LD_INT 4
18617: GREATEREQUAL
18618: AND
18619: PUSH
18620: LD_EXP 15
18624: PUSH
18625: LD_INT 2
18627: EQUAL
18628: AND
18629: IFFALSE 20452
18631: GO 18633
18633: DISABLE
18634: LD_INT 0
18636: PPUSH
18637: PPUSH
18638: PPUSH
18639: PPUSH
18640: PPUSH
18641: PPUSH
18642: PPUSH
18643: PPUSH
// begin missionStage := 3 ;
18644: LD_ADDR_EXP 15
18648: PUSH
18649: LD_INT 3
18651: ST_TO_ADDR
// retreat := false ;
18652: LD_ADDR_VAR 0 4
18656: PUSH
18657: LD_INT 0
18659: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18660: LD_ADDR_VAR 0 5
18664: PUSH
18665: LD_INT 22
18667: PUSH
18668: LD_INT 4
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: PUSH
18675: LD_INT 30
18677: PUSH
18678: LD_INT 4
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: PPUSH
18689: CALL_OW 69
18693: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18694: LD_ADDR_VAR 0 6
18698: PUSH
18699: LD_INT 22
18701: PUSH
18702: LD_INT 4
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: PUSH
18709: LD_INT 30
18711: PUSH
18712: LD_INT 5
18714: PUSH
18715: EMPTY
18716: LIST
18717: LIST
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PPUSH
18723: CALL_OW 69
18727: ST_TO_ADDR
// if not bar then
18728: LD_VAR 0 6
18732: NOT
18733: IFFALSE 18786
// begin repeat wait ( 0 0$1 ) ;
18735: LD_INT 35
18737: PPUSH
18738: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18742: LD_INT 22
18744: PUSH
18745: LD_INT 4
18747: PUSH
18748: EMPTY
18749: LIST
18750: LIST
18751: PUSH
18752: LD_INT 3
18754: PUSH
18755: LD_INT 57
18757: PUSH
18758: EMPTY
18759: LIST
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: PUSH
18765: LD_INT 30
18767: PUSH
18768: LD_INT 5
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: EMPTY
18776: LIST
18777: LIST
18778: LIST
18779: PPUSH
18780: CALL_OW 69
18784: IFFALSE 18735
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18786: LD_ADDR_VAR 0 6
18790: PUSH
18791: LD_INT 22
18793: PUSH
18794: LD_INT 4
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: PUSH
18801: LD_INT 30
18803: PUSH
18804: LD_INT 5
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: PUSH
18811: EMPTY
18812: LIST
18813: LIST
18814: PPUSH
18815: CALL_OW 69
18819: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18820: LD_INT 35
18822: PPUSH
18823: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18827: LD_EXP 135
18831: PUSH
18832: LD_INT 4
18834: ARRAY
18835: PUSH
18836: LD_INT 4
18838: GREATEREQUAL
18839: IFFALSE 18820
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18841: LD_ADDR_VAR 0 2
18845: PUSH
18846: LD_INT 22
18848: PUSH
18849: LD_INT 4
18851: PUSH
18852: EMPTY
18853: LIST
18854: LIST
18855: PUSH
18856: LD_INT 2
18858: PUSH
18859: LD_INT 25
18861: PUSH
18862: LD_INT 1
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: PUSH
18869: LD_INT 25
18871: PUSH
18872: LD_INT 2
18874: PUSH
18875: EMPTY
18876: LIST
18877: LIST
18878: PUSH
18879: LD_INT 25
18881: PUSH
18882: LD_INT 3
18884: PUSH
18885: EMPTY
18886: LIST
18887: LIST
18888: PUSH
18889: LD_INT 25
18891: PUSH
18892: LD_INT 4
18894: PUSH
18895: EMPTY
18896: LIST
18897: LIST
18898: PUSH
18899: LD_INT 25
18901: PUSH
18902: LD_INT 5
18904: PUSH
18905: EMPTY
18906: LIST
18907: LIST
18908: PUSH
18909: EMPTY
18910: LIST
18911: LIST
18912: LIST
18913: LIST
18914: LIST
18915: LIST
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: PPUSH
18921: CALL_OW 69
18925: PUSH
18926: LD_EXP 58
18930: PUSH
18931: LD_EXP 59
18935: ADD
18936: DIFF
18937: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18938: LD_ADDR_VAR 0 3
18942: PUSH
18943: LD_VAR 0 2
18947: PPUSH
18948: LD_INT 26
18950: PUSH
18951: LD_INT 1
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: PPUSH
18958: CALL_OW 72
18962: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18963: LD_ADDR_VAR 0 2
18967: PUSH
18968: LD_VAR 0 2
18972: PUSH
18973: LD_VAR 0 3
18977: DIFF
18978: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18979: LD_ADDR_VAR 0 2
18983: PUSH
18984: LD_VAR 0 2
18988: PPUSH
18989: LD_INT 1
18991: PPUSH
18992: CALL 101120 0 2
18996: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 3
19006: PPUSH
19007: LD_INT 1
19009: PPUSH
19010: CALL 101120 0 2
19014: ST_TO_ADDR
// for i = 1 to 4 do
19015: LD_ADDR_VAR 0 1
19019: PUSH
19020: DOUBLE
19021: LD_INT 1
19023: DEC
19024: ST_TO_ADDR
19025: LD_INT 4
19027: PUSH
19028: FOR_TO
19029: IFFALSE 19195
// begin if tmp2 then
19031: LD_VAR 0 3
19035: IFFALSE 19116
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19037: LD_ADDR_EXP 18
19041: PUSH
19042: LD_EXP 18
19046: PPUSH
19047: LD_INT 1
19049: PPUSH
19050: LD_EXP 18
19054: PUSH
19055: LD_INT 1
19057: ARRAY
19058: PUSH
19059: LD_VAR 0 3
19063: PUSH
19064: LD_VAR 0 3
19068: ARRAY
19069: ADD
19070: PPUSH
19071: CALL_OW 1
19075: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19076: LD_VAR 0 3
19080: PUSH
19081: LD_VAR 0 3
19085: ARRAY
19086: PPUSH
19087: LD_INT 1
19089: PPUSH
19090: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19094: LD_ADDR_VAR 0 3
19098: PUSH
19099: LD_VAR 0 3
19103: PPUSH
19104: LD_VAR 0 3
19108: PPUSH
19109: CALL_OW 3
19113: ST_TO_ADDR
// end else
19114: GO 19193
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19116: LD_ADDR_EXP 18
19120: PUSH
19121: LD_EXP 18
19125: PPUSH
19126: LD_INT 1
19128: PPUSH
19129: LD_EXP 18
19133: PUSH
19134: LD_INT 1
19136: ARRAY
19137: PUSH
19138: LD_VAR 0 2
19142: PUSH
19143: LD_VAR 0 2
19147: ARRAY
19148: ADD
19149: PPUSH
19150: CALL_OW 1
19154: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19155: LD_VAR 0 2
19159: PUSH
19160: LD_VAR 0 2
19164: ARRAY
19165: PPUSH
19166: LD_INT 1
19168: PPUSH
19169: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19173: LD_ADDR_VAR 0 2
19177: PUSH
19178: LD_VAR 0 2
19182: PPUSH
19183: LD_VAR 0 2
19187: PPUSH
19188: CALL_OW 3
19192: ST_TO_ADDR
// end ; end ;
19193: GO 19028
19195: POP
19196: POP
// if tmp2 then
19197: LD_VAR 0 3
19201: IFFALSE 19219
// tmp := tmp union tmp2 ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_VAR 0 3
19217: UNION
19218: ST_TO_ADDR
// for i = 1 to 4 do
19219: LD_ADDR_VAR 0 1
19223: PUSH
19224: DOUBLE
19225: LD_INT 1
19227: DEC
19228: ST_TO_ADDR
19229: LD_INT 4
19231: PUSH
19232: FOR_TO
19233: IFFALSE 19282
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19235: LD_ADDR_EXP 18
19239: PUSH
19240: LD_EXP 18
19244: PPUSH
19245: LD_INT 2
19247: PPUSH
19248: LD_EXP 18
19252: PUSH
19253: LD_INT 2
19255: ARRAY
19256: PUSH
19257: LD_VAR 0 2
19261: PUSH
19262: LD_VAR 0 2
19266: PUSH
19267: LD_VAR 0 1
19271: MINUS
19272: ARRAY
19273: ADD
19274: PPUSH
19275: CALL_OW 1
19279: ST_TO_ADDR
19280: GO 19232
19282: POP
19283: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19284: LD_ADDR_EXP 116
19288: PUSH
19289: LD_EXP 116
19293: PPUSH
19294: LD_INT 4
19296: PPUSH
19297: LD_EXP 116
19301: PUSH
19302: LD_INT 4
19304: ARRAY
19305: PUSH
19306: LD_EXP 18
19310: PUSH
19311: LD_INT 1
19313: ARRAY
19314: DIFF
19315: PPUSH
19316: CALL_OW 1
19320: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19321: LD_VAR 0 5
19325: PUSH
19326: LD_INT 1
19328: ARRAY
19329: PPUSH
19330: CALL_OW 313
19334: IFFALSE 19389
// begin for i in UnitsInside ( arm [ 1 ] ) do
19336: LD_ADDR_VAR 0 1
19340: PUSH
19341: LD_VAR 0 5
19345: PUSH
19346: LD_INT 1
19348: ARRAY
19349: PPUSH
19350: CALL_OW 313
19354: PUSH
19355: FOR_IN
19356: IFFALSE 19387
// begin ComExitBuilding ( i ) ;
19358: LD_VAR 0 1
19362: PPUSH
19363: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19367: LD_VAR 0 1
19371: PPUSH
19372: LD_VAR 0 6
19376: PUSH
19377: LD_INT 1
19379: ARRAY
19380: PPUSH
19381: CALL_OW 180
// end ;
19385: GO 19355
19387: POP
19388: POP
// end ; wait ( 0 0$3 ) ;
19389: LD_INT 105
19391: PPUSH
19392: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19396: LD_ADDR_VAR 0 1
19400: PUSH
19401: LD_EXP 18
19405: PUSH
19406: LD_INT 1
19408: ARRAY
19409: PUSH
19410: FOR_IN
19411: IFFALSE 19518
// begin if IsInUnit ( i ) then
19413: LD_VAR 0 1
19417: PPUSH
19418: CALL_OW 310
19422: IFFALSE 19433
// ComExitBuilding ( i ) ;
19424: LD_VAR 0 1
19428: PPUSH
19429: CALL_OW 122
// if GetClass ( i ) <> 1 then
19433: LD_VAR 0 1
19437: PPUSH
19438: CALL_OW 257
19442: PUSH
19443: LD_INT 1
19445: NONEQUAL
19446: IFFALSE 19487
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19448: LD_VAR 0 1
19452: PPUSH
19453: LD_VAR 0 5
19457: PUSH
19458: LD_INT 1
19460: ARRAY
19461: PPUSH
19462: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19466: LD_VAR 0 1
19470: PPUSH
19471: LD_INT 1
19473: PPUSH
19474: CALL_OW 183
// AddComExitBuilding ( i ) ;
19478: LD_VAR 0 1
19482: PPUSH
19483: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19487: LD_VAR 0 1
19491: PPUSH
19492: LD_INT 60
19494: PPUSH
19495: LD_INT 94
19497: PPUSH
19498: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19502: LD_VAR 0 1
19506: PPUSH
19507: LD_EXP 58
19511: PPUSH
19512: CALL_OW 179
// end ;
19516: GO 19410
19518: POP
19519: POP
// wait ( 0 0$15 ) ;
19520: LD_INT 525
19522: PPUSH
19523: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19527: LD_EXP 58
19531: PPUSH
19532: LD_STRING D4-Pow-1
19534: PPUSH
19535: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19539: LD_ADDR_VAR 0 2
19543: PUSH
19544: LD_EXP 18
19548: PUSH
19549: LD_INT 1
19551: ARRAY
19552: PPUSH
19553: LD_INT 26
19555: PUSH
19556: LD_INT 1
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: PPUSH
19563: CALL_OW 72
19567: ST_TO_ADDR
// if tmp then
19568: LD_VAR 0 2
19572: IFFALSE 19590
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19574: LD_VAR 0 2
19578: PUSH
19579: LD_INT 1
19581: ARRAY
19582: PPUSH
19583: LD_STRING D4-Sol1-1
19585: PPUSH
19586: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19590: LD_EXP 58
19594: PPUSH
19595: LD_STRING D4-Pow-2
19597: PPUSH
19598: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19602: LD_ADDR_VAR 0 1
19606: PUSH
19607: DOUBLE
19608: LD_INT 1
19610: DEC
19611: ST_TO_ADDR
19612: LD_EXP 18
19616: PUSH
19617: LD_INT 1
19619: ARRAY
19620: PUSH
19621: FOR_TO
19622: IFFALSE 19715
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19624: LD_EXP 18
19628: PUSH
19629: LD_INT 1
19631: ARRAY
19632: PUSH
19633: LD_VAR 0 1
19637: ARRAY
19638: PPUSH
19639: LD_EXP 135
19643: PUSH
19644: LD_INT 4
19646: ARRAY
19647: PUSH
19648: LD_INT 1
19650: ARRAY
19651: PPUSH
19652: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19656: LD_ADDR_EXP 135
19660: PUSH
19661: LD_EXP 135
19665: PPUSH
19666: LD_INT 4
19668: PPUSH
19669: LD_EXP 135
19673: PUSH
19674: LD_INT 4
19676: ARRAY
19677: PPUSH
19678: LD_INT 1
19680: PPUSH
19681: CALL_OW 3
19685: PPUSH
19686: CALL_OW 1
19690: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19691: LD_INT 8
19693: PPUSH
19694: LD_EXP 18
19698: PUSH
19699: LD_INT 1
19701: ARRAY
19702: PUSH
19703: LD_VAR 0 1
19707: ARRAY
19708: PPUSH
19709: CALL_OW 471
// end ;
19713: GO 19621
19715: POP
19716: POP
// repeat wait ( 0 0$1 ) ;
19717: LD_INT 35
19719: PPUSH
19720: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19724: LD_EXP 18
19728: PUSH
19729: LD_INT 1
19731: ARRAY
19732: PPUSH
19733: LD_INT 55
19735: PUSH
19736: EMPTY
19737: LIST
19738: PPUSH
19739: CALL_OW 72
19743: PUSH
19744: LD_INT 4
19746: GREATEREQUAL
19747: IFFALSE 19717
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19749: LD_EXP 18
19753: PUSH
19754: LD_INT 1
19756: ARRAY
19757: PPUSH
19758: LD_INT 69
19760: PPUSH
19761: LD_INT 94
19763: PPUSH
19764: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19768: LD_EXP 18
19772: PUSH
19773: LD_INT 1
19775: ARRAY
19776: PPUSH
19777: LD_INT 82
19779: PPUSH
19780: LD_INT 83
19782: PPUSH
19783: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19787: LD_EXP 18
19791: PUSH
19792: LD_INT 1
19794: ARRAY
19795: PPUSH
19796: LD_INT 77
19798: PPUSH
19799: LD_INT 69
19801: PPUSH
19802: CALL_OW 174
// repeat wait ( 3 ) ;
19806: LD_INT 3
19808: PPUSH
19809: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19813: LD_ADDR_VAR 0 1
19817: PUSH
19818: LD_EXP 18
19822: PUSH
19823: LD_INT 1
19825: ARRAY
19826: PUSH
19827: FOR_IN
19828: IFFALSE 19964
// begin if GetLives ( i ) < 990 then
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 256
19839: PUSH
19840: LD_INT 990
19842: LESS
19843: IFFALSE 19857
// SetLives ( i , 1000 ) ;
19845: LD_VAR 0 1
19849: PPUSH
19850: LD_INT 1000
19852: PPUSH
19853: CALL_OW 234
// if not IsInUnit ( i ) then
19857: LD_VAR 0 1
19861: PPUSH
19862: CALL_OW 310
19866: NOT
19867: IFFALSE 19962
// begin if not HasTask ( i ) then
19869: LD_VAR 0 1
19873: PPUSH
19874: CALL_OW 314
19878: NOT
19879: IFFALSE 19896
// ComMoveXY ( i , 64 , 93 ) ;
19881: LD_VAR 0 1
19885: PPUSH
19886: LD_INT 64
19888: PPUSH
19889: LD_INT 93
19891: PPUSH
19892: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19896: LD_VAR 0 4
19900: NOT
19901: PUSH
19902: LD_VAR 0 1
19906: PPUSH
19907: CALL_OW 258
19911: PUSH
19912: LD_INT 1
19914: EQUAL
19915: AND
19916: IFFALSE 19962
// begin retreat := true ;
19918: LD_ADDR_VAR 0 4
19922: PUSH
19923: LD_INT 1
19925: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19926: LD_VAR 0 1
19930: PPUSH
19931: LD_INT 2
19933: PPUSH
19934: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19938: LD_VAR 0 1
19942: PPUSH
19943: LD_STRING D4a-Sol1-1
19945: PPUSH
19946: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19950: LD_EXP 58
19954: PPUSH
19955: LD_STRING D4a-Pow-1
19957: PPUSH
19958: CALL_OW 88
// end ; end ; end ;
19962: GO 19827
19964: POP
19965: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19966: LD_EXP 18
19970: PUSH
19971: LD_INT 1
19973: ARRAY
19974: PPUSH
19975: LD_INT 95
19977: PUSH
19978: LD_INT 9
19980: PUSH
19981: EMPTY
19982: LIST
19983: LIST
19984: PUSH
19985: LD_INT 3
19987: PUSH
19988: LD_INT 55
19990: PUSH
19991: EMPTY
19992: LIST
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: PUSH
19998: EMPTY
19999: LIST
20000: LIST
20001: PPUSH
20002: CALL_OW 72
20006: PUSH
20007: LD_INT 4
20009: GREATEREQUAL
20010: IFFALSE 19806
// for i in powellSquadAttack [ 1 ] do
20012: LD_ADDR_VAR 0 1
20016: PUSH
20017: LD_EXP 18
20021: PUSH
20022: LD_INT 1
20024: ARRAY
20025: PUSH
20026: FOR_IN
20027: IFFALSE 20163
// begin if GetTag ( i ) = 2 then
20029: LD_VAR 0 1
20033: PPUSH
20034: CALL_OW 110
20038: PUSH
20039: LD_INT 2
20041: EQUAL
20042: IFFALSE 20104
// begin ComMoveXY ( i , 60 , 94 ) ;
20044: LD_VAR 0 1
20048: PPUSH
20049: LD_INT 60
20051: PPUSH
20052: LD_INT 94
20054: PPUSH
20055: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20059: LD_VAR 0 1
20063: PPUSH
20064: LD_EXP 58
20068: PPUSH
20069: CALL_OW 179
// wait ( 0 0$3 ) ;
20073: LD_INT 105
20075: PPUSH
20076: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20080: LD_VAR 0 1
20084: PPUSH
20085: LD_STRING D4a-Sol1-2
20087: PPUSH
20088: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20092: LD_EXP 58
20096: PPUSH
20097: LD_STRING D4a-Pow-2
20099: PPUSH
20100: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20104: LD_VAR 0 1
20108: PPUSH
20109: LD_INT 0
20111: PPUSH
20112: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20116: LD_ADDR_EXP 116
20120: PUSH
20121: LD_EXP 116
20125: PPUSH
20126: LD_INT 4
20128: PPUSH
20129: LD_EXP 116
20133: PUSH
20134: LD_INT 4
20136: ARRAY
20137: PUSH
20138: LD_VAR 0 1
20142: UNION
20143: PPUSH
20144: CALL_OW 1
20148: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20149: LD_INT 8
20151: PPUSH
20152: LD_VAR 0 1
20156: PPUSH
20157: CALL_OW 472
// end ;
20161: GO 20026
20163: POP
20164: POP
// wait ( 4 4$00 ) ;
20165: LD_INT 8400
20167: PPUSH
20168: CALL_OW 67
// uc_side := 6 ;
20172: LD_ADDR_OWVAR 20
20176: PUSH
20177: LD_INT 6
20179: ST_TO_ADDR
// uc_nation := 3 ;
20180: LD_ADDR_OWVAR 21
20184: PUSH
20185: LD_INT 3
20187: ST_TO_ADDR
// ru := [ ] ;
20188: LD_ADDR_VAR 0 7
20192: PUSH
20193: EMPTY
20194: ST_TO_ADDR
// for i = 1 to 4 do
20195: LD_ADDR_VAR 0 1
20199: PUSH
20200: DOUBLE
20201: LD_INT 1
20203: DEC
20204: ST_TO_ADDR
20205: LD_INT 4
20207: PUSH
20208: FOR_TO
20209: IFFALSE 20310
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20211: LD_INT 22
20213: PPUSH
20214: LD_INT 1
20216: PPUSH
20217: LD_INT 3
20219: PPUSH
20220: LD_INT 43
20222: PUSH
20223: LD_INT 44
20225: PUSH
20226: EMPTY
20227: LIST
20228: LIST
20229: PUSH
20230: LD_INT 1
20232: PPUSH
20233: LD_INT 2
20235: PPUSH
20236: CALL_OW 12
20240: ARRAY
20241: PPUSH
20242: LD_INT 89
20244: PPUSH
20245: CALL 70741 0 5
// un := CreateVehicle ;
20249: LD_ADDR_VAR 0 8
20253: PUSH
20254: CALL_OW 45
20258: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20259: LD_VAR 0 8
20263: PPUSH
20264: LD_INT 4
20266: PPUSH
20267: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20271: LD_VAR 0 8
20275: PPUSH
20276: LD_INT 136
20278: PPUSH
20279: LD_INT 90
20281: PPUSH
20282: LD_INT 8
20284: PPUSH
20285: LD_INT 0
20287: PPUSH
20288: CALL_OW 50
// ru := ru ^ un ;
20292: LD_ADDR_VAR 0 7
20296: PUSH
20297: LD_VAR 0 7
20301: PUSH
20302: LD_VAR 0 8
20306: ADD
20307: ST_TO_ADDR
// end ;
20308: GO 20208
20310: POP
20311: POP
// if ru then
20312: LD_VAR 0 7
20316: IFFALSE 20333
// ComAgressiveMove ( ru , 80 , 92 ) ;
20318: LD_VAR 0 7
20322: PPUSH
20323: LD_INT 80
20325: PPUSH
20326: LD_INT 92
20328: PPUSH
20329: CALL_OW 114
// wait ( 8 8$00 ) ;
20333: LD_INT 16800
20335: PPUSH
20336: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20340: LD_INT 4
20342: PPUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: LD_INT 4
20363: PUSH
20364: LD_INT 1
20366: PUSH
20367: LD_INT 1
20369: PUSH
20370: LD_INT 6
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: LIST
20377: LIST
20378: PUSH
20379: LD_INT 4
20381: PUSH
20382: LD_INT 1
20384: PUSH
20385: LD_INT 1
20387: PUSH
20388: LD_INT 7
20390: PUSH
20391: EMPTY
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 3
20399: PUSH
20400: LD_INT 1
20402: PUSH
20403: LD_INT 1
20405: PUSH
20406: LD_INT 7
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: LIST
20413: LIST
20414: PUSH
20415: LD_INT 3
20417: PUSH
20418: LD_INT 1
20420: PUSH
20421: LD_INT 1
20423: PUSH
20424: LD_INT 5
20426: PUSH
20427: EMPTY
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: PUSH
20433: EMPTY
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: PPUSH
20440: CALL 59423 0 2
// missionStage := 4 ;
20444: LD_ADDR_EXP 15
20448: PUSH
20449: LD_INT 4
20451: ST_TO_ADDR
// end ;
20452: PPOPN 8
20454: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20455: LD_EXP 15
20459: PUSH
20460: LD_INT 4
20462: EQUAL
20463: PUSH
20464: LD_INT 22
20466: PUSH
20467: LD_INT 4
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: PUSH
20474: LD_INT 21
20476: PUSH
20477: LD_INT 2
20479: PUSH
20480: EMPTY
20481: LIST
20482: LIST
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: PPUSH
20488: CALL_OW 69
20492: PUSH
20493: LD_INT 5
20495: GREATEREQUAL
20496: AND
20497: IFFALSE 24618
20499: GO 20501
20501: DISABLE
20502: LD_INT 0
20504: PPUSH
20505: PPUSH
20506: PPUSH
20507: PPUSH
20508: PPUSH
20509: PPUSH
20510: PPUSH
20511: PPUSH
20512: PPUSH
20513: PPUSH
20514: PPUSH
20515: PPUSH
20516: PPUSH
// begin missionStage := 5 ;
20517: LD_ADDR_EXP 15
20521: PUSH
20522: LD_INT 5
20524: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20525: LD_ADDR_VAR 0 10
20529: PUSH
20530: LD_INT 22
20532: PUSH
20533: LD_INT 4
20535: PUSH
20536: EMPTY
20537: LIST
20538: LIST
20539: PUSH
20540: LD_INT 2
20542: PUSH
20543: LD_INT 30
20545: PUSH
20546: LD_INT 4
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PUSH
20553: LD_INT 30
20555: PUSH
20556: LD_INT 5
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: PUSH
20563: EMPTY
20564: LIST
20565: LIST
20566: LIST
20567: PUSH
20568: EMPTY
20569: LIST
20570: LIST
20571: PPUSH
20572: CALL_OW 69
20576: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20577: LD_ADDR_VAR 0 6
20581: PUSH
20582: LD_INT 22
20584: PUSH
20585: LD_INT 4
20587: PUSH
20588: EMPTY
20589: LIST
20590: LIST
20591: PUSH
20592: LD_INT 21
20594: PUSH
20595: LD_INT 1
20597: PUSH
20598: EMPTY
20599: LIST
20600: LIST
20601: PUSH
20602: LD_INT 3
20604: PUSH
20605: LD_INT 25
20607: PUSH
20608: LD_INT 16
20610: PUSH
20611: EMPTY
20612: LIST
20613: LIST
20614: PUSH
20615: EMPTY
20616: LIST
20617: LIST
20618: PUSH
20619: LD_INT 3
20621: PUSH
20622: LD_INT 25
20624: PUSH
20625: LD_INT 12
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: LIST
20640: LIST
20641: PPUSH
20642: CALL_OW 69
20646: PUSH
20647: LD_EXP 58
20651: DIFF
20652: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20653: LD_ADDR_VAR 0 9
20657: PUSH
20658: LD_INT 22
20660: PUSH
20661: LD_INT 4
20663: PUSH
20664: EMPTY
20665: LIST
20666: LIST
20667: PUSH
20668: LD_INT 30
20670: PUSH
20671: LD_INT 3
20673: PUSH
20674: EMPTY
20675: LIST
20676: LIST
20677: PUSH
20678: EMPTY
20679: LIST
20680: LIST
20681: PPUSH
20682: CALL_OW 69
20686: PUSH
20687: LD_INT 1
20689: ARRAY
20690: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20691: LD_INT 35
20693: PPUSH
20694: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20698: LD_EXP 135
20702: PUSH
20703: LD_INT 4
20705: ARRAY
20706: PUSH
20707: LD_INT 5
20709: GREATEREQUAL
20710: PUSH
20711: LD_EXP 135
20715: PUSH
20716: LD_INT 4
20718: ARRAY
20719: PPUSH
20720: LD_INT 58
20722: PUSH
20723: EMPTY
20724: LIST
20725: PPUSH
20726: CALL_OW 72
20730: PUSH
20731: LD_INT 5
20733: GREATEREQUAL
20734: AND
20735: IFFALSE 20691
// powellAllowRetreat := false ;
20737: LD_ADDR_EXP 19
20741: PUSH
20742: LD_INT 0
20744: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20745: LD_INT 700
20747: PPUSH
20748: CALL_OW 67
// activeAttacks := false ;
20752: LD_ADDR_EXP 16
20756: PUSH
20757: LD_INT 0
20759: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20760: LD_INT 35
20762: PPUSH
20763: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20767: LD_INT 22
20769: PUSH
20770: LD_INT 6
20772: PUSH
20773: EMPTY
20774: LIST
20775: LIST
20776: PPUSH
20777: CALL_OW 69
20781: PUSH
20782: LD_INT 0
20784: EQUAL
20785: IFFALSE 20760
// tmp := mc_vehicles [ 4 ] ;
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: LD_EXP 135
20796: PUSH
20797: LD_INT 4
20799: ARRAY
20800: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20801: LD_ADDR_VAR 0 1
20805: PUSH
20806: DOUBLE
20807: LD_INT 1
20809: DEC
20810: ST_TO_ADDR
20811: LD_EXP 18
20815: PUSH
20816: FOR_TO
20817: IFFALSE 21078
// begin for j in powellSquadAttack [ i ] do
20819: LD_ADDR_VAR 0 2
20823: PUSH
20824: LD_EXP 18
20828: PUSH
20829: LD_VAR 0 1
20833: ARRAY
20834: PUSH
20835: FOR_IN
20836: IFFALSE 21074
// begin forces := forces diff j ;
20838: LD_ADDR_VAR 0 6
20842: PUSH
20843: LD_VAR 0 6
20847: PUSH
20848: LD_VAR 0 2
20852: DIFF
20853: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20854: LD_VAR 0 2
20858: PPUSH
20859: LD_INT 1
20861: PPUSH
20862: CALL_OW 109
// wait ( 0 0$2 ) ;
20866: LD_INT 70
20868: PPUSH
20869: CALL_OW 67
// if IsInUnit ( j ) then
20873: LD_VAR 0 2
20877: PPUSH
20878: CALL_OW 310
20882: IFFALSE 20893
// ComExitBuilding ( j ) ;
20884: LD_VAR 0 2
20888: PPUSH
20889: CALL_OW 122
// if GetClass ( j ) <> 1 then
20893: LD_VAR 0 2
20897: PPUSH
20898: CALL_OW 257
20902: PUSH
20903: LD_INT 1
20905: NONEQUAL
20906: IFFALSE 20986
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20908: LD_VAR 0 10
20912: PUSH
20913: LD_INT 1
20915: ARRAY
20916: PPUSH
20917: CALL_OW 313
20921: PUSH
20922: LD_INT 5
20924: GREATEREQUAL
20925: IFFALSE 20947
// AddComEnterUnit ( j , arm [ 2 ] ) else
20927: LD_VAR 0 2
20931: PPUSH
20932: LD_VAR 0 10
20936: PUSH
20937: LD_INT 2
20939: ARRAY
20940: PPUSH
20941: CALL_OW 180
20945: GO 20965
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20947: LD_VAR 0 2
20951: PPUSH
20952: LD_VAR 0 10
20956: PUSH
20957: LD_INT 1
20959: ARRAY
20960: PPUSH
20961: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20965: LD_VAR 0 2
20969: PPUSH
20970: LD_INT 1
20972: PPUSH
20973: CALL_OW 183
// AddComExitBuilding ( j ) ;
20977: LD_VAR 0 2
20981: PPUSH
20982: CALL_OW 182
// end ; if i = 2 then
20986: LD_VAR 0 1
20990: PUSH
20991: LD_INT 2
20993: EQUAL
20994: IFFALSE 21011
// AddComMoveXY ( j , 61 , 93 ) ;
20996: LD_VAR 0 2
21000: PPUSH
21001: LD_INT 61
21003: PPUSH
21004: LD_INT 93
21006: PPUSH
21007: CALL_OW 171
// if i = 1 then
21011: LD_VAR 0 1
21015: PUSH
21016: LD_INT 1
21018: EQUAL
21019: IFFALSE 21072
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
21021: LD_VAR 0 2
21025: PPUSH
21026: LD_VAR 0 3
21030: PUSH
21031: LD_INT 1
21033: ARRAY
21034: PPUSH
21035: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
21039: LD_ADDR_VAR 0 3
21043: PUSH
21044: LD_VAR 0 3
21048: PPUSH
21049: LD_INT 1
21051: PPUSH
21052: CALL_OW 3
21056: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
21057: LD_VAR 0 2
21061: PPUSH
21062: LD_INT 69
21064: PPUSH
21065: LD_INT 94
21067: PPUSH
21068: CALL_OW 171
// end ; end ;
21072: GO 20835
21074: POP
21075: POP
// end ;
21076: GO 20816
21078: POP
21079: POP
// wait ( 0 0$55 ) ;
21080: LD_INT 1925
21082: PPUSH
21083: CALL_OW 67
// MC_Kill ( 4 ) ;
21087: LD_INT 4
21089: PPUSH
21090: CALL 35493 0 1
// tmp := UnitsInside ( fac ) ;
21094: LD_ADDR_VAR 0 3
21098: PUSH
21099: LD_VAR 0 9
21103: PPUSH
21104: CALL_OW 313
21108: ST_TO_ADDR
// if tmp then
21109: LD_VAR 0 3
21113: IFFALSE 21234
// for i in tmp do
21115: LD_ADDR_VAR 0 1
21119: PUSH
21120: LD_VAR 0 3
21124: PUSH
21125: FOR_IN
21126: IFFALSE 21232
// begin ComExitBuilding ( i ) ;
21128: LD_VAR 0 1
21132: PPUSH
21133: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21137: LD_VAR 0 10
21141: PUSH
21142: LD_INT 2
21144: ARRAY
21145: PPUSH
21146: CALL_OW 313
21150: PUSH
21151: LD_INT 6
21153: LESS
21154: IFFALSE 21176
// AddComEnterUnit ( i , arm [ 2 ] ) else
21156: LD_VAR 0 1
21160: PPUSH
21161: LD_VAR 0 10
21165: PUSH
21166: LD_INT 2
21168: ARRAY
21169: PPUSH
21170: CALL_OW 180
21174: GO 21230
// if UnitsInside ( arm [ 1 ] ) < 6 then
21176: LD_VAR 0 10
21180: PUSH
21181: LD_INT 1
21183: ARRAY
21184: PPUSH
21185: CALL_OW 313
21189: PUSH
21190: LD_INT 6
21192: LESS
21193: IFFALSE 21215
// AddComEnterUnit ( i , arm [ 1 ] ) else
21195: LD_VAR 0 1
21199: PPUSH
21200: LD_VAR 0 10
21204: PUSH
21205: LD_INT 1
21207: ARRAY
21208: PPUSH
21209: CALL_OW 180
21213: GO 21230
// AddComMoveXY ( i , 37 , 68 ) ;
21215: LD_VAR 0 1
21219: PPUSH
21220: LD_INT 37
21222: PPUSH
21223: LD_INT 68
21225: PPUSH
21226: CALL_OW 171
// end ;
21230: GO 21125
21232: POP
21233: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21234: LD_ADDR_VAR 0 11
21238: PUSH
21239: LD_VAR 0 6
21243: PPUSH
21244: LD_INT 26
21246: PUSH
21247: LD_INT 1
21249: PUSH
21250: EMPTY
21251: LIST
21252: LIST
21253: PPUSH
21254: CALL_OW 72
21258: PUSH
21259: LD_EXP 59
21263: DIFF
21264: ST_TO_ADDR
// if not speaker then
21265: LD_VAR 0 11
21269: NOT
21270: IFFALSE 21297
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21272: LD_ADDR_VAR 0 11
21276: PUSH
21277: LD_VAR 0 6
21281: PPUSH
21282: LD_INT 26
21284: PUSH
21285: LD_INT 1
21287: PUSH
21288: EMPTY
21289: LIST
21290: LIST
21291: PPUSH
21292: CALL_OW 72
21296: ST_TO_ADDR
// if speaker then
21297: LD_VAR 0 11
21301: IFFALSE 21317
// speaker := speaker [ 1 ] ;
21303: LD_ADDR_VAR 0 11
21307: PUSH
21308: LD_VAR 0 11
21312: PUSH
21313: LD_INT 1
21315: ARRAY
21316: ST_TO_ADDR
// Video ( true ) ;
21317: LD_INT 1
21319: PPUSH
21320: CALL 102586 0 1
// CenterNowOnUnits ( Powell ) ;
21324: LD_EXP 58
21328: PPUSH
21329: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21333: LD_ADDR_VAR 0 3
21337: PUSH
21338: LD_VAR 0 6
21342: PPUSH
21343: LD_INT 3
21345: PUSH
21346: LD_INT 25
21348: PUSH
21349: LD_INT 1
21351: PUSH
21352: EMPTY
21353: LIST
21354: LIST
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: PPUSH
21360: CALL_OW 72
21364: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21365: LD_ADDR_VAR 0 12
21369: PUSH
21370: LD_INT 22
21372: PUSH
21373: LD_INT 4
21375: PUSH
21376: EMPTY
21377: LIST
21378: LIST
21379: PUSH
21380: LD_INT 30
21382: PUSH
21383: LD_INT 32
21385: PUSH
21386: EMPTY
21387: LIST
21388: LIST
21389: PUSH
21390: LD_INT 58
21392: PUSH
21393: EMPTY
21394: LIST
21395: PUSH
21396: EMPTY
21397: LIST
21398: LIST
21399: LIST
21400: PPUSH
21401: CALL_OW 69
21405: ST_TO_ADDR
// for i = 1 to 6 do
21406: LD_ADDR_VAR 0 1
21410: PUSH
21411: DOUBLE
21412: LD_INT 1
21414: DEC
21415: ST_TO_ADDR
21416: LD_INT 6
21418: PUSH
21419: FOR_TO
21420: IFFALSE 21561
// begin if IsInUnit ( tmp [ i ] ) then
21422: LD_VAR 0 3
21426: PUSH
21427: LD_VAR 0 1
21431: ARRAY
21432: PPUSH
21433: CALL_OW 310
21437: IFFALSE 21454
// ComExitBuilding ( tmp [ i ] ) ;
21439: LD_VAR 0 3
21443: PUSH
21444: LD_VAR 0 1
21448: ARRAY
21449: PPUSH
21450: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21454: LD_VAR 0 3
21458: PUSH
21459: LD_VAR 0 1
21463: ARRAY
21464: PPUSH
21465: LD_VAR 0 10
21469: PUSH
21470: LD_INT 1
21472: ARRAY
21473: PPUSH
21474: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21478: LD_VAR 0 3
21482: PUSH
21483: LD_VAR 0 1
21487: ARRAY
21488: PPUSH
21489: LD_INT 1
21491: PPUSH
21492: CALL_OW 183
// if emp_towers then
21496: LD_VAR 0 12
21500: IFFALSE 21559
// begin AddComExitBuilding ( tmp [ i ] ) ;
21502: LD_VAR 0 3
21506: PUSH
21507: LD_VAR 0 1
21511: ARRAY
21512: PPUSH
21513: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21517: LD_VAR 0 3
21521: PUSH
21522: LD_VAR 0 1
21526: ARRAY
21527: PPUSH
21528: LD_VAR 0 12
21532: PUSH
21533: LD_INT 1
21535: ARRAY
21536: PPUSH
21537: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21541: LD_ADDR_VAR 0 12
21545: PUSH
21546: LD_VAR 0 12
21550: PPUSH
21551: LD_INT 1
21553: PPUSH
21554: CALL_OW 3
21558: ST_TO_ADDR
// end ; end ;
21559: GO 21419
21561: POP
21562: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21563: LD_ADDR_VAR 0 3
21567: PUSH
21568: LD_EXP 18
21572: PUSH
21573: LD_INT 1
21575: ARRAY
21576: PUSH
21577: LD_EXP 18
21581: PUSH
21582: LD_INT 2
21584: ARRAY
21585: ADD
21586: PPUSH
21587: LD_INT 26
21589: PUSH
21590: LD_INT 1
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: PPUSH
21597: CALL_OW 72
21601: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21602: LD_ADDR_VAR 0 1
21606: PUSH
21607: LD_EXP 18
21611: PUSH
21612: LD_INT 2
21614: ARRAY
21615: PUSH
21616: FOR_IN
21617: IFFALSE 21635
// ComTurnUnit ( i , Powell ) ;
21619: LD_VAR 0 1
21623: PPUSH
21624: LD_EXP 58
21628: PPUSH
21629: CALL_OW 119
21633: GO 21616
21635: POP
21636: POP
// Say ( Powell , D5-Pow-1 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-1
21644: PPUSH
21645: CALL_OW 88
// if tmp then
21649: LD_VAR 0 3
21653: IFFALSE 21671
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21655: LD_VAR 0 3
21659: PUSH
21660: LD_INT 1
21662: ARRAY
21663: PPUSH
21664: LD_STRING D5-Sol2-1
21666: PPUSH
21667: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21671: LD_EXP 58
21675: PPUSH
21676: LD_STRING D5-Pow-2
21678: PPUSH
21679: CALL_OW 88
// if tmp > 1 then
21683: LD_VAR 0 3
21687: PUSH
21688: LD_INT 1
21690: GREATER
21691: IFFALSE 21709
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21693: LD_VAR 0 3
21697: PUSH
21698: LD_INT 2
21700: ARRAY
21701: PPUSH
21702: LD_STRING D5-Sol2-2
21704: PPUSH
21705: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21709: LD_EXP 58
21713: PPUSH
21714: LD_STRING D5-Pow-3
21716: PPUSH
21717: CALL_OW 88
// wait ( 0 0$1 ) ;
21721: LD_INT 35
21723: PPUSH
21724: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21728: LD_ADDR_VAR 0 3
21732: PUSH
21733: LD_EXP 18
21737: PUSH
21738: LD_INT 1
21740: ARRAY
21741: PUSH
21742: LD_EXP 18
21746: PUSH
21747: LD_INT 2
21749: ARRAY
21750: UNION
21751: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21752: LD_VAR 0 3
21756: PPUSH
21757: LD_INT 80
21759: PPUSH
21760: LD_INT 67
21762: PPUSH
21763: CALL_OW 114
// wait ( 0 0$2 ) ;
21767: LD_INT 70
21769: PPUSH
21770: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21774: LD_INT 79
21776: PPUSH
21777: LD_INT 72
21779: PPUSH
21780: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21784: LD_INT 35
21786: PPUSH
21787: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21791: LD_VAR 0 3
21795: PPUSH
21796: LD_INT 3
21798: PUSH
21799: LD_INT 24
21801: PUSH
21802: LD_INT 1000
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: EMPTY
21810: LIST
21811: LIST
21812: PPUSH
21813: CALL_OW 72
21817: IFFALSE 21784
// Say ( Powell , D5a-Pow-1 ) ;
21819: LD_EXP 58
21823: PPUSH
21824: LD_STRING D5a-Pow-1
21826: PPUSH
21827: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21831: LD_EXP 58
21835: PPUSH
21836: LD_STRING D5a-Pow-1a
21838: PPUSH
21839: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21843: LD_INT 10
21845: PPUSH
21846: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21850: LD_EXP 58
21854: PPUSH
21855: LD_STRING D5a-Pow-1b
21857: PPUSH
21858: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21862: LD_EXP 58
21866: PPUSH
21867: LD_STRING D5a-Pow-1c
21869: PPUSH
21870: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21874: LD_EXP 58
21878: PPUSH
21879: LD_STRING D5a-Pow-1d
21881: PPUSH
21882: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21886: LD_INT 35
21888: PPUSH
21889: CALL_OW 67
// if not HasTask ( tmp ) then
21893: LD_VAR 0 3
21897: PPUSH
21898: CALL_OW 314
21902: NOT
21903: IFFALSE 21920
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21905: LD_VAR 0 3
21909: PPUSH
21910: LD_INT 80
21912: PPUSH
21913: LD_INT 67
21915: PPUSH
21916: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21920: LD_VAR 0 3
21924: PPUSH
21925: LD_INT 24
21927: PUSH
21928: LD_INT 1
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: PPUSH
21935: CALL_OW 72
21939: NOT
21940: IFFALSE 21886
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21942: LD_ADDR_VAR 0 3
21946: PUSH
21947: LD_INT 22
21949: PUSH
21950: LD_INT 4
21952: PUSH
21953: EMPTY
21954: LIST
21955: LIST
21956: PUSH
21957: LD_INT 92
21959: PUSH
21960: LD_INT 60
21962: PUSH
21963: LD_INT 93
21965: PUSH
21966: LD_INT 10
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: LIST
21973: LIST
21974: PUSH
21975: LD_INT 3
21977: PUSH
21978: LD_INT 54
21980: PUSH
21981: EMPTY
21982: LIST
21983: PUSH
21984: EMPTY
21985: LIST
21986: LIST
21987: PUSH
21988: EMPTY
21989: LIST
21990: LIST
21991: LIST
21992: PPUSH
21993: CALL_OW 69
21997: PUSH
21998: LD_EXP 58
22002: DIFF
22003: ST_TO_ADDR
// if tmp then
22004: LD_VAR 0 3
22008: IFFALSE 22042
// for i in tmp do
22010: LD_ADDR_VAR 0 1
22014: PUSH
22015: LD_VAR 0 3
22019: PUSH
22020: FOR_IN
22021: IFFALSE 22040
// ComMoveXY ( i , 36 , 67 ) ;
22023: LD_VAR 0 1
22027: PPUSH
22028: LD_INT 36
22030: PPUSH
22031: LD_INT 67
22033: PPUSH
22034: CALL_OW 111
22038: GO 22020
22040: POP
22041: POP
// wait ( 0 0$3 ) ;
22042: LD_INT 105
22044: PPUSH
22045: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
22049: LD_VAR 0 11
22053: PPUSH
22054: LD_STRING D6-Sol3-1
22056: PPUSH
22057: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
22061: LD_EXP 58
22065: PPUSH
22066: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
22070: LD_EXP 58
22074: PPUSH
22075: LD_STRING D6-Pow-1
22077: PPUSH
22078: CALL_OW 88
// tmp := [ ] ;
22082: LD_ADDR_VAR 0 3
22086: PUSH
22087: EMPTY
22088: ST_TO_ADDR
// for i = 1 to 2 do
22089: LD_ADDR_VAR 0 1
22093: PUSH
22094: DOUBLE
22095: LD_INT 1
22097: DEC
22098: ST_TO_ADDR
22099: LD_INT 2
22101: PUSH
22102: FOR_TO
22103: IFFALSE 22217
// begin uc_side := 8 ;
22105: LD_ADDR_OWVAR 20
22109: PUSH
22110: LD_INT 8
22112: ST_TO_ADDR
// uc_nation := 2 ;
22113: LD_ADDR_OWVAR 21
22117: PUSH
22118: LD_INT 2
22120: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22121: LD_INT 14
22123: PPUSH
22124: LD_INT 3
22126: PPUSH
22127: LD_INT 2
22129: PPUSH
22130: LD_INT 29
22132: PPUSH
22133: LD_INT 100
22135: PPUSH
22136: CALL 70741 0 5
// veh := CreateVehicle ;
22140: LD_ADDR_VAR 0 13
22144: PUSH
22145: CALL_OW 45
22149: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22150: LD_VAR 0 13
22154: PPUSH
22155: LD_INT 4
22157: PPUSH
22158: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22162: LD_VAR 0 13
22166: PPUSH
22167: LD_INT 99
22169: PPUSH
22170: LD_INT 83
22172: PPUSH
22173: LD_INT 6
22175: PPUSH
22176: LD_INT 0
22178: PPUSH
22179: CALL_OW 50
// wait ( 3 ) ;
22183: LD_INT 3
22185: PPUSH
22186: CALL_OW 67
// Connect ( veh ) ;
22190: LD_VAR 0 13
22194: PPUSH
22195: CALL 73834 0 1
// tmp := tmp ^ veh ;
22199: LD_ADDR_VAR 0 3
22203: PUSH
22204: LD_VAR 0 3
22208: PUSH
22209: LD_VAR 0 13
22213: ADD
22214: ST_TO_ADDR
// end ;
22215: GO 22102
22217: POP
22218: POP
// wait ( 0 0$1 ) ;
22219: LD_INT 35
22221: PPUSH
22222: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22226: LD_INT 99
22228: PPUSH
22229: LD_INT 83
22231: PPUSH
22232: LD_INT 1
22234: PPUSH
22235: LD_INT 10
22237: PPUSH
22238: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22242: LD_INT 99
22244: PPUSH
22245: LD_INT 83
22247: PPUSH
22248: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22252: LD_VAR 0 11
22256: PPUSH
22257: LD_STRING D6-Sol3-2
22259: PPUSH
22260: CALL_OW 88
// async ;
22264: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22265: LD_EXP 58
22269: PPUSH
22270: LD_STRING D6-Pow-2
22272: PPUSH
22273: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22277: LD_VAR 0 3
22281: PUSH
22282: LD_INT 1
22284: ARRAY
22285: PPUSH
22286: LD_VAR 0 9
22290: PPUSH
22291: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22295: LD_VAR 0 3
22299: PUSH
22300: LD_INT 2
22302: ARRAY
22303: PPUSH
22304: LD_INT 22
22306: PUSH
22307: LD_INT 4
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PUSH
22314: LD_INT 21
22316: PUSH
22317: LD_INT 3
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PPUSH
22328: CALL_OW 69
22332: PPUSH
22333: LD_VAR 0 3
22337: PUSH
22338: LD_INT 2
22340: ARRAY
22341: PPUSH
22342: CALL_OW 74
22346: PPUSH
22347: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22351: LD_EXP 58
22355: PPUSH
22356: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22360: LD_INT 99
22362: PPUSH
22363: LD_INT 83
22365: PPUSH
22366: LD_INT 1
22368: PPUSH
22369: CALL_OW 331
// repeat wait ( 4 ) ;
22373: LD_INT 4
22375: PPUSH
22376: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22380: LD_VAR 0 3
22384: PUSH
22385: LD_INT 1
22387: ARRAY
22388: PPUSH
22389: CALL_OW 256
22393: PUSH
22394: LD_INT 1000
22396: LESS
22397: IFFALSE 22415
// SetLives ( tmp [ 1 ] , 1000 ) ;
22399: LD_VAR 0 3
22403: PUSH
22404: LD_INT 1
22406: ARRAY
22407: PPUSH
22408: LD_INT 1000
22410: PPUSH
22411: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22415: LD_INT 22
22417: PUSH
22418: LD_INT 4
22420: PUSH
22421: EMPTY
22422: LIST
22423: LIST
22424: PUSH
22425: LD_INT 30
22427: PUSH
22428: LD_INT 3
22430: PUSH
22431: EMPTY
22432: LIST
22433: LIST
22434: PUSH
22435: EMPTY
22436: LIST
22437: LIST
22438: PPUSH
22439: CALL_OW 69
22443: PUSH
22444: LD_INT 0
22446: EQUAL
22447: IFFALSE 22373
// skirmish := false ;
22449: LD_ADDR_EXP 114
22453: PUSH
22454: LD_INT 0
22456: ST_TO_ADDR
// sync ;
22457: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22458: LD_EXP 58
22462: PPUSH
22463: LD_STRING D6a-Pow-1
22465: PPUSH
22466: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22470: LD_VAR 0 11
22474: PPUSH
22475: LD_STRING D6a-Sol3-1
22477: PPUSH
22478: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22482: LD_EXP 58
22486: PPUSH
22487: LD_STRING D6a-Pow-2
22489: PPUSH
22490: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22494: LD_VAR 0 11
22498: PPUSH
22499: LD_STRING D6a-Sol3-2
22501: PPUSH
22502: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22506: LD_EXP 58
22510: PPUSH
22511: LD_STRING D6a-Pow-3
22513: PPUSH
22514: CALL_OW 88
// powellCenterCameraMode := true ;
22518: LD_ADDR_EXP 20
22522: PUSH
22523: LD_INT 1
22525: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22526: LD_ADDR_VAR 0 1
22530: PUSH
22531: LD_INT 22
22533: PUSH
22534: LD_INT 8
22536: PUSH
22537: EMPTY
22538: LIST
22539: LIST
22540: PUSH
22541: LD_INT 25
22543: PUSH
22544: LD_INT 2
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PPUSH
22555: CALL_OW 69
22559: PUSH
22560: FOR_IN
22561: IFFALSE 22616
// begin SetTag ( i , 1 ) ;
22563: LD_VAR 0 1
22567: PPUSH
22568: LD_INT 1
22570: PPUSH
22571: CALL_OW 109
// ComExitBuilding ( i ) ;
22575: LD_VAR 0 1
22579: PPUSH
22580: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22584: LD_VAR 0 1
22588: PPUSH
22589: LD_INT 35
22591: PPUSH
22592: LD_INT 6
22594: PPUSH
22595: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22599: LD_VAR 0 1
22603: PPUSH
22604: LD_INT 53
22606: PPUSH
22607: LD_INT 4
22609: PPUSH
22610: CALL_OW 171
// end ;
22614: GO 22560
22616: POP
22617: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22618: LD_ADDR_VAR 0 3
22622: PUSH
22623: LD_INT 22
22625: PUSH
22626: LD_INT 4
22628: PUSH
22629: EMPTY
22630: LIST
22631: LIST
22632: PUSH
22633: LD_INT 21
22635: PUSH
22636: LD_INT 2
22638: PUSH
22639: EMPTY
22640: LIST
22641: LIST
22642: PUSH
22643: LD_INT 3
22645: PUSH
22646: LD_INT 34
22648: PUSH
22649: LD_INT 12
22651: PUSH
22652: EMPTY
22653: LIST
22654: LIST
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: PPUSH
22665: CALL_OW 69
22669: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22670: LD_EXP 58
22674: PPUSH
22675: LD_VAR 0 3
22679: PPUSH
22680: LD_EXP 58
22684: PPUSH
22685: CALL_OW 74
22689: PPUSH
22690: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22694: LD_EXP 58
22698: PPUSH
22699: LD_INT 100
22701: PPUSH
22702: LD_INT 88
22704: PPUSH
22705: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22709: LD_EXP 58
22713: PPUSH
22714: LD_INT 100
22716: PPUSH
22717: LD_INT 75
22719: PPUSH
22720: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22724: LD_EXP 58
22728: PPUSH
22729: LD_INT 88
22731: PPUSH
22732: LD_INT 53
22734: PPUSH
22735: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22739: LD_INT 8
22741: PPUSH
22742: LD_EXP 58
22746: PPUSH
22747: CALL_OW 471
// repeat wait ( 3 ) ;
22751: LD_INT 3
22753: PPUSH
22754: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22758: LD_INT 22
22760: PUSH
22761: LD_INT 4
22763: PUSH
22764: EMPTY
22765: LIST
22766: LIST
22767: PUSH
22768: LD_INT 92
22770: PUSH
22771: LD_INT 100
22773: PUSH
22774: LD_INT 75
22776: PUSH
22777: LD_INT 6
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: LIST
22784: LIST
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: PPUSH
22790: CALL_OW 69
22794: IFFALSE 22751
// async ;
22796: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22797: LD_EXP 58
22801: PPUSH
22802: LD_STRING D6b-Pow-1
22804: PPUSH
22805: CALL_OW 88
// repeat wait ( 3 ) ;
22809: LD_INT 3
22811: PPUSH
22812: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22816: LD_EXP 58
22820: PPUSH
22821: CALL_OW 310
22825: PPUSH
22826: CALL_OW 256
22830: PUSH
22831: LD_INT 1000
22833: LESS
22834: IFFALSE 22853
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22836: LD_EXP 58
22840: PPUSH
22841: CALL_OW 310
22845: PPUSH
22846: LD_INT 1000
22848: PPUSH
22849: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22853: LD_EXP 58
22857: PPUSH
22858: CALL_OW 256
22862: PUSH
22863: LD_INT 1000
22865: LESS
22866: IFFALSE 22880
// SetLives ( Powell , 1000 ) ;
22868: LD_EXP 58
22872: PPUSH
22873: LD_INT 1000
22875: PPUSH
22876: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22880: LD_EXP 58
22884: PPUSH
22885: LD_EXP 63
22889: PPUSH
22890: CALL_OW 296
22894: PUSH
22895: LD_INT 5
22897: LESS
22898: PUSH
22899: LD_EXP 58
22903: PPUSH
22904: CALL_OW 310
22908: PPUSH
22909: LD_EXP 63
22913: PPUSH
22914: CALL_OW 296
22918: PUSH
22919: LD_INT 5
22921: LESS
22922: OR
22923: IFFALSE 22942
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22925: LD_EXP 58
22929: PPUSH
22930: CALL_OW 310
22934: PPUSH
22935: LD_INT 100
22937: PPUSH
22938: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22942: LD_EXP 58
22946: PPUSH
22947: CALL_OW 310
22951: NOT
22952: IFFALSE 22809
// DoNotAttack ( 8 , powellBomb ) ;
22954: LD_INT 8
22956: PPUSH
22957: LD_EXP 63
22961: PPUSH
22962: CALL_OW 471
// game_speed := 4 ;
22966: LD_ADDR_OWVAR 65
22970: PUSH
22971: LD_INT 4
22973: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22974: LD_EXP 58
22978: PPUSH
22979: LD_STRING D6b-Pow-1a
22981: PPUSH
22982: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22986: LD_EXP 58
22990: PPUSH
22991: LD_EXP 63
22995: PPUSH
22996: CALL_OW 180
// sync ;
23000: SYNC
// repeat wait ( 0 0$1 ) ;
23001: LD_INT 35
23003: PPUSH
23004: CALL_OW 67
// until IsInUnit ( Powell ) ;
23008: LD_EXP 58
23012: PPUSH
23013: CALL_OW 310
23017: IFFALSE 23001
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
23019: LD_INT 8
23021: PPUSH
23022: LD_EXP 58
23026: PPUSH
23027: CALL_OW 310
23031: PPUSH
23032: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 91
23043: PPUSH
23044: LD_INT 44
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 96
23058: PPUSH
23059: LD_INT 44
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 96
23073: PPUSH
23074: LD_INT 41
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 92
23088: PPUSH
23089: LD_INT 39
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 88
23103: PPUSH
23104: LD_INT 41
23106: PPUSH
23107: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23111: LD_EXP 58
23115: PPUSH
23116: LD_INT 91
23118: PPUSH
23119: LD_INT 44
23121: PPUSH
23122: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23126: LD_EXP 58
23130: PPUSH
23131: LD_INT 96
23133: PPUSH
23134: LD_INT 44
23136: PPUSH
23137: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23141: LD_EXP 58
23145: PPUSH
23146: LD_INT 96
23148: PPUSH
23149: LD_INT 41
23151: PPUSH
23152: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23156: LD_EXP 58
23160: PPUSH
23161: LD_INT 92
23163: PPUSH
23164: LD_INT 39
23166: PPUSH
23167: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23171: LD_EXP 58
23175: PPUSH
23176: LD_INT 88
23178: PPUSH
23179: LD_INT 41
23181: PPUSH
23182: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23186: LD_EXP 58
23190: PPUSH
23191: LD_INT 91
23193: PPUSH
23194: LD_INT 44
23196: PPUSH
23197: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23201: LD_EXP 58
23205: PPUSH
23206: LD_INT 93
23208: PPUSH
23209: LD_INT 39
23211: PPUSH
23212: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23216: LD_EXP 58
23220: PPUSH
23221: LD_INT 93
23223: PPUSH
23224: LD_INT 36
23226: PPUSH
23227: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23231: LD_INT 122
23233: PPUSH
23234: CALL_OW 67
// game_speed := 4 ;
23238: LD_ADDR_OWVAR 65
23242: PUSH
23243: LD_INT 4
23245: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23246: LD_EXP 58
23250: PPUSH
23251: LD_STRING D6b-Pow-1b
23253: PPUSH
23254: CALL_OW 88
// tmp := [ ] ;
23258: LD_ADDR_VAR 0 3
23262: PUSH
23263: EMPTY
23264: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23265: LD_ADDR_VAR 0 5
23269: PUSH
23270: LD_INT 78
23272: PUSH
23273: LD_INT 47
23275: PUSH
23276: EMPTY
23277: LIST
23278: LIST
23279: PUSH
23280: LD_INT 106
23282: PUSH
23283: LD_INT 53
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23294: LD_ADDR_VAR 0 1
23298: PUSH
23299: LD_INT 22
23301: PUSH
23302: LD_INT 8
23304: PUSH
23305: EMPTY
23306: LIST
23307: LIST
23308: PUSH
23309: LD_INT 21
23311: PUSH
23312: LD_INT 3
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: PUSH
23319: LD_INT 92
23321: PUSH
23322: LD_INT 90
23324: PUSH
23325: LD_INT 52
23327: PUSH
23328: LD_INT 12
23330: PUSH
23331: EMPTY
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: PUSH
23337: EMPTY
23338: LIST
23339: LIST
23340: LIST
23341: PPUSH
23342: CALL_OW 69
23346: PUSH
23347: FOR_IN
23348: IFFALSE 23373
// tmp := tmp ^ UnitsInside ( i ) ;
23350: LD_ADDR_VAR 0 3
23354: PUSH
23355: LD_VAR 0 3
23359: PUSH
23360: LD_VAR 0 1
23364: PPUSH
23365: CALL_OW 313
23369: ADD
23370: ST_TO_ADDR
23371: GO 23347
23373: POP
23374: POP
// for i in tmp do
23375: LD_ADDR_VAR 0 1
23379: PUSH
23380: LD_VAR 0 3
23384: PUSH
23385: FOR_IN
23386: IFFALSE 23548
// begin dist := 9999 ;
23388: LD_ADDR_VAR 0 8
23392: PUSH
23393: LD_INT 9999
23395: ST_TO_ADDR
// _xy := [ ] ;
23396: LD_ADDR_VAR 0 7
23400: PUSH
23401: EMPTY
23402: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23403: LD_VAR 0 1
23407: PPUSH
23408: LD_INT 1
23410: PPUSH
23411: CALL_OW 109
// ComExitBuilding ( i ) ;
23415: LD_VAR 0 1
23419: PPUSH
23420: CALL_OW 122
// for j in xy do
23424: LD_ADDR_VAR 0 2
23428: PUSH
23429: LD_VAR 0 5
23433: PUSH
23434: FOR_IN
23435: IFFALSE 23517
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23437: LD_VAR 0 1
23441: PPUSH
23442: LD_VAR 0 2
23446: PUSH
23447: LD_INT 1
23449: ARRAY
23450: PPUSH
23451: LD_VAR 0 2
23455: PUSH
23456: LD_INT 2
23458: ARRAY
23459: PPUSH
23460: CALL_OW 297
23464: PUSH
23465: LD_VAR 0 8
23469: LESS
23470: IFFALSE 23515
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23472: LD_ADDR_VAR 0 8
23476: PUSH
23477: LD_VAR 0 1
23481: PPUSH
23482: LD_VAR 0 2
23486: PUSH
23487: LD_INT 1
23489: ARRAY
23490: PPUSH
23491: LD_VAR 0 2
23495: PUSH
23496: LD_INT 2
23498: ARRAY
23499: PPUSH
23500: CALL_OW 297
23504: ST_TO_ADDR
// _xy := j ;
23505: LD_ADDR_VAR 0 7
23509: PUSH
23510: LD_VAR 0 2
23514: ST_TO_ADDR
// end ;
23515: GO 23434
23517: POP
23518: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23519: LD_VAR 0 1
23523: PPUSH
23524: LD_VAR 0 7
23528: PUSH
23529: LD_INT 1
23531: ARRAY
23532: PPUSH
23533: LD_VAR 0 7
23537: PUSH
23538: LD_INT 2
23540: ARRAY
23541: PPUSH
23542: CALL_OW 171
// end ;
23546: GO 23385
23548: POP
23549: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23550: LD_ADDR_VAR 0 4
23554: PUSH
23555: LD_VAR 0 3
23559: PPUSH
23560: LD_INT 26
23562: PUSH
23563: LD_INT 1
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PUSH
23570: LD_INT 25
23572: PUSH
23573: LD_INT 1
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: PUSH
23580: EMPTY
23581: LIST
23582: LIST
23583: PPUSH
23584: CALL_OW 72
23588: ST_TO_ADDR
// if tmp2 < 2 then
23589: LD_VAR 0 4
23593: PUSH
23594: LD_INT 2
23596: LESS
23597: IFFALSE 23666
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23599: LD_ADDR_VAR 0 4
23603: PUSH
23604: LD_INT 22
23606: PUSH
23607: LD_INT 8
23609: PUSH
23610: EMPTY
23611: LIST
23612: LIST
23613: PUSH
23614: LD_INT 26
23616: PUSH
23617: LD_INT 1
23619: PUSH
23620: EMPTY
23621: LIST
23622: LIST
23623: PUSH
23624: LD_INT 3
23626: PUSH
23627: LD_INT 25
23629: PUSH
23630: LD_INT 15
23632: PUSH
23633: EMPTY
23634: LIST
23635: LIST
23636: PUSH
23637: EMPTY
23638: LIST
23639: LIST
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: LIST
23645: PPUSH
23646: CALL_OW 69
23650: PUSH
23651: LD_EXP 60
23655: PUSH
23656: LD_EXP 61
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: DIFF
23665: ST_TO_ADDR
// if tmp2 then
23666: LD_VAR 0 4
23670: IFFALSE 23688
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23672: LD_VAR 0 4
23676: PUSH
23677: LD_INT 1
23679: ARRAY
23680: PPUSH
23681: LD_STRING D6b-ArSol1-1
23683: PPUSH
23684: CALL_OW 88
// async ;
23688: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23689: LD_EXP 58
23693: PPUSH
23694: LD_STRING D6b-Pow-2
23696: PPUSH
23697: CALL_OW 88
// wait ( 0 0$1 ) ;
23701: LD_INT 35
23703: PPUSH
23704: CALL_OW 67
// if tmp2 > 1 then
23708: LD_VAR 0 4
23712: PUSH
23713: LD_INT 1
23715: GREATER
23716: IFFALSE 23734
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23718: LD_VAR 0 4
23722: PUSH
23723: LD_INT 2
23725: ARRAY
23726: PPUSH
23727: LD_STRING D6b-ArSol2-1
23729: PPUSH
23730: CALL_OW 88
// sync ;
23734: SYNC
// repeat wait ( 5 ) ;
23735: LD_INT 5
23737: PPUSH
23738: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23742: LD_INT 93
23744: PPUSH
23745: LD_INT 36
23747: PPUSH
23748: CALL_OW 428
23752: PPUSH
23753: CALL_OW 255
23757: PUSH
23758: LD_INT 4
23760: EQUAL
23761: IFFALSE 23735
// DialogueOn ;
23763: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23767: LD_INT 10
23769: PPUSH
23770: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23774: LD_EXP 58
23778: PPUSH
23779: LD_STRING D6b-Pow-2a
23781: PPUSH
23782: CALL_OW 88
// DialogueOff ;
23786: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23790: LD_EXP 58
23794: PPUSH
23795: CALL_OW 310
23799: PPUSH
23800: LD_INT 332
23802: PPUSH
23803: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23807: LD_INT 93
23809: PPUSH
23810: LD_INT 35
23812: PPUSH
23813: LD_INT 1
23815: PPUSH
23816: LD_INT 6
23818: NEG
23819: PPUSH
23820: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23824: LD_INT 35
23826: PPUSH
23827: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23831: LD_INT 332
23833: PPUSH
23834: CALL_OW 256
23838: PUSH
23839: LD_INT 1000
23841: LESS
23842: PUSH
23843: LD_INT 332
23845: PPUSH
23846: CALL_OW 300
23850: AND
23851: IFFALSE 23863
// SetLives ( kozlov_fac , 0 ) ;
23853: LD_INT 332
23855: PPUSH
23856: LD_INT 0
23858: PPUSH
23859: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23863: LD_INT 332
23865: PPUSH
23866: CALL_OW 301
23870: PUSH
23871: LD_EXP 58
23875: PPUSH
23876: CALL_OW 301
23880: OR
23881: IFFALSE 23824
// game_speed := 4 ;
23883: LD_ADDR_OWVAR 65
23887: PUSH
23888: LD_INT 4
23890: ST_TO_ADDR
// powellCenterCameraMode := false ;
23891: LD_ADDR_EXP 20
23895: PUSH
23896: LD_INT 0
23898: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23899: LD_ADDR_VAR 0 1
23903: PUSH
23904: LD_VAR 0 3
23908: PUSH
23909: LD_INT 22
23911: PUSH
23912: LD_INT 8
23914: PUSH
23915: EMPTY
23916: LIST
23917: LIST
23918: PUSH
23919: LD_INT 25
23921: PUSH
23922: LD_INT 2
23924: PUSH
23925: EMPTY
23926: LIST
23927: LIST
23928: PUSH
23929: EMPTY
23930: LIST
23931: LIST
23932: PPUSH
23933: CALL_OW 69
23937: UNION
23938: PUSH
23939: FOR_IN
23940: IFFALSE 23956
// SetTag ( i , 0 ) ;
23942: LD_VAR 0 1
23946: PPUSH
23947: LD_INT 0
23949: PPUSH
23950: CALL_OW 109
23954: GO 23939
23956: POP
23957: POP
// wait ( 0 0$3 ) ;
23958: LD_INT 105
23960: PPUSH
23961: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23965: LD_INT 93
23967: PPUSH
23968: LD_INT 35
23970: PPUSH
23971: LD_INT 1
23973: PPUSH
23974: CALL_OW 331
// DialogueOn ;
23978: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23982: LD_VAR 0 11
23986: PPUSH
23987: LD_STRING D6c-Sol3-1
23989: PPUSH
23990: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23994: LD_INT 10
23996: PPUSH
23997: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
24001: LD_EXP 39
24005: PPUSH
24006: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
24010: LD_EXP 39
24014: PPUSH
24015: LD_STRING D6c-JMM-1
24017: PPUSH
24018: CALL_OW 88
// if Cyrus then
24022: LD_EXP 45
24026: IFFALSE 24040
// Say ( Cyrus , D6c-Cyrus-1 ) ;
24028: LD_EXP 45
24032: PPUSH
24033: LD_STRING D6c-Cyrus-1
24035: PPUSH
24036: CALL_OW 88
// if Bobby then
24040: LD_EXP 44
24044: IFFALSE 24058
// Say ( Bobby , D6c-Bobby-1 ) ;
24046: LD_EXP 44
24050: PPUSH
24051: LD_STRING D6c-Bobby-1
24053: PPUSH
24054: CALL_OW 88
// if Cornel then
24058: LD_EXP 50
24062: IFFALSE 24076
// Say ( Cornel , D6c-Corn-1 ) ;
24064: LD_EXP 50
24068: PPUSH
24069: LD_STRING D6c-Corn-1
24071: PPUSH
24072: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
24076: LD_ADDR_VAR 0 4
24080: PUSH
24081: LD_INT 2
24083: PUSH
24084: LD_INT 22
24086: PUSH
24087: LD_INT 1
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PUSH
24094: LD_INT 22
24096: PUSH
24097: LD_INT 4
24099: PUSH
24100: EMPTY
24101: LIST
24102: LIST
24103: PUSH
24104: EMPTY
24105: LIST
24106: LIST
24107: LIST
24108: PUSH
24109: LD_INT 26
24111: PUSH
24112: LD_INT 1
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: PUSH
24119: LD_INT 3
24121: PUSH
24122: LD_INT 25
24124: PUSH
24125: LD_INT 16
24127: PUSH
24128: EMPTY
24129: LIST
24130: LIST
24131: PUSH
24132: LD_INT 25
24134: PUSH
24135: LD_INT 12
24137: PUSH
24138: EMPTY
24139: LIST
24140: LIST
24141: PUSH
24142: EMPTY
24143: LIST
24144: LIST
24145: LIST
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: LIST
24151: PPUSH
24152: CALL_OW 69
24156: PUSH
24157: LD_VAR 0 11
24161: PUSH
24162: LD_EXP 39
24166: UNION
24167: PUSH
24168: LD_EXP 59
24172: UNION
24173: PUSH
24174: EMPTY
24175: LIST
24176: DIFF
24177: ST_TO_ADDR
// if tmp2 then
24178: LD_VAR 0 4
24182: IFFALSE 24200
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24184: LD_VAR 0 4
24188: PUSH
24189: LD_INT 1
24191: ARRAY
24192: PPUSH
24193: LD_STRING D6c-Sol1-1
24195: PPUSH
24196: CALL_OW 88
// if Lisa then
24200: LD_EXP 42
24204: IFFALSE 24218
// Say ( Lisa , D6c-Lisa-1 ) ;
24206: LD_EXP 42
24210: PPUSH
24211: LD_STRING D6c-Lisa-1
24213: PPUSH
24214: CALL_OW 88
// if Gary then
24218: LD_EXP 51
24222: IFFALSE 24236
// Say ( Gary , D6c-Gary-1 ) ;
24224: LD_EXP 51
24228: PPUSH
24229: LD_STRING D6c-Gary-1
24231: PPUSH
24232: CALL_OW 88
// if Donaldson then
24236: LD_EXP 43
24240: IFFALSE 24254
// Say ( Donaldson , D6c-Don-1 ) ;
24242: LD_EXP 43
24246: PPUSH
24247: LD_STRING D6c-Don-1
24249: PPUSH
24250: CALL_OW 88
// if tmp2 > 1 then
24254: LD_VAR 0 4
24258: PUSH
24259: LD_INT 1
24261: GREATER
24262: IFFALSE 24280
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24264: LD_VAR 0 4
24268: PUSH
24269: LD_INT 2
24271: ARRAY
24272: PPUSH
24273: LD_STRING D6c-Sol2-1
24275: PPUSH
24276: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24280: LD_VAR 0 11
24284: PPUSH
24285: LD_STRING D6c-Sol3-2
24287: PPUSH
24288: CALL_OW 88
// dwait ( 0 0$1 ) ;
24292: LD_INT 35
24294: PPUSH
24295: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24299: LD_EXP 39
24303: PPUSH
24304: LD_STRING D6c-JMM-2
24306: PPUSH
24307: CALL_OW 88
// DialogueOff ;
24311: CALL_OW 7
// Video ( false ) ;
24315: LD_INT 0
24317: PPUSH
24318: CALL 102586 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24322: LD_INT 22
24324: PUSH
24325: LD_INT 4
24327: PUSH
24328: EMPTY
24329: LIST
24330: LIST
24331: PPUSH
24332: CALL_OW 69
24336: PPUSH
24337: LD_INT 1
24339: PPUSH
24340: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24344: LD_INT 4
24346: PPUSH
24347: LD_INT 4
24349: PPUSH
24350: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24354: LD_ADDR_VAR 0 1
24358: PUSH
24359: LD_INT 4
24361: PPUSH
24362: LD_INT 1
24364: PPUSH
24365: LD_INT 2
24367: PPUSH
24368: CALL 65940 0 3
24372: PUSH
24373: FOR_IN
24374: IFFALSE 24411
// if GetTech ( i , 1 ) <> state_researched then
24376: LD_VAR 0 1
24380: PPUSH
24381: LD_INT 1
24383: PPUSH
24384: CALL_OW 321
24388: PUSH
24389: LD_INT 2
24391: NONEQUAL
24392: IFFALSE 24409
// SetTech ( i , 1 , state_researched ) ;
24394: LD_VAR 0 1
24398: PPUSH
24399: LD_INT 1
24401: PPUSH
24402: LD_INT 2
24404: PPUSH
24405: CALL_OW 322
24409: GO 24373
24411: POP
24412: POP
// missionStage := 6 ;
24413: LD_ADDR_EXP 15
24417: PUSH
24418: LD_INT 6
24420: ST_TO_ADDR
// activeAttacks := true ;
24421: LD_ADDR_EXP 16
24425: PUSH
24426: LD_INT 1
24428: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24429: LD_STRING M2
24431: PPUSH
24432: CALL_OW 337
// SaveForQuickRestart ;
24436: CALL_OW 22
// wait ( 0 0$40 ) ;
24440: LD_INT 1400
24442: PPUSH
24443: CALL_OW 67
// DialogueOn ;
24447: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24451: LD_EXP 62
24455: PPUSH
24456: LD_STRING D7-Friend-1
24458: PPUSH
24459: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24463: LD_EXP 39
24467: PPUSH
24468: LD_STRING D7-JMM-1
24470: PPUSH
24471: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24475: LD_EXP 62
24479: PPUSH
24480: LD_STRING D7-Friend-2
24482: PPUSH
24483: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24487: LD_EXP 39
24491: PPUSH
24492: LD_STRING D7-JMM-2
24494: PPUSH
24495: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24499: LD_EXP 62
24503: PPUSH
24504: LD_STRING D7-Friend-3
24506: PPUSH
24507: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24511: LD_EXP 39
24515: PPUSH
24516: LD_STRING D7-JMM-3
24518: PPUSH
24519: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24523: LD_EXP 62
24527: PPUSH
24528: LD_STRING D7-Friend-4
24530: PPUSH
24531: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24535: LD_EXP 39
24539: PPUSH
24540: LD_STRING D7-JMM-4
24542: PPUSH
24543: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24547: LD_EXP 62
24551: PPUSH
24552: LD_STRING D7-Friend-5
24554: PPUSH
24555: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24559: LD_EXP 39
24563: PPUSH
24564: LD_STRING D7-JMM-5
24566: PPUSH
24567: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24571: LD_EXP 62
24575: PPUSH
24576: LD_STRING D7-Friend-6
24578: PPUSH
24579: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24583: LD_EXP 39
24587: PPUSH
24588: LD_STRING D7-JMM-6
24590: PPUSH
24591: CALL_OW 88
// DialogueOff ;
24595: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24599: LD_STRING Mlegion
24601: PPUSH
24602: CALL_OW 337
// skirmish := true ;
24606: LD_ADDR_EXP 114
24610: PUSH
24611: LD_INT 1
24613: ST_TO_ADDR
// RebuildKozlovFactory ;
24614: CALL 4892 0 0
// end ;
24618: PPOPN 13
24620: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24621: LD_EXP 20
24625: PUSH
24626: LD_EXP 58
24630: PPUSH
24631: CALL_OW 300
24635: AND
24636: IFFALSE 24678
24638: GO 24640
24640: DISABLE
// begin enable ;
24641: ENABLE
// if IsInUnit ( Powell ) then
24642: LD_EXP 58
24646: PPUSH
24647: CALL_OW 310
24651: IFFALSE 24669
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24653: LD_EXP 58
24657: PPUSH
24658: CALL_OW 310
24662: PPUSH
24663: CALL_OW 85
24667: GO 24678
// CenterOnUnits ( Powell ) ;
24669: LD_EXP 58
24673: PPUSH
24674: CALL_OW 85
// end ;
24678: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24679: LD_INT 22
24681: PUSH
24682: LD_INT 8
24684: PUSH
24685: EMPTY
24686: LIST
24687: LIST
24688: PUSH
24689: LD_INT 34
24691: PUSH
24692: LD_INT 48
24694: PUSH
24695: EMPTY
24696: LIST
24697: LIST
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: PPUSH
24703: CALL_OW 69
24707: IFFALSE 24981
24709: GO 24711
24711: DISABLE
24712: LD_INT 0
24714: PPUSH
24715: PPUSH
// begin if missionStage < 9 then
24716: LD_EXP 15
24720: PUSH
24721: LD_INT 9
24723: LESS
24724: IFFALSE 24734
// missionStage := 9 ;
24726: LD_ADDR_EXP 15
24730: PUSH
24731: LD_INT 9
24733: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24734: LD_ADDR_VAR 0 1
24738: PUSH
24739: LD_INT 22
24741: PUSH
24742: LD_INT 8
24744: PUSH
24745: EMPTY
24746: LIST
24747: LIST
24748: PUSH
24749: LD_INT 34
24751: PUSH
24752: LD_INT 48
24754: PUSH
24755: EMPTY
24756: LIST
24757: LIST
24758: PUSH
24759: EMPTY
24760: LIST
24761: LIST
24762: PPUSH
24763: CALL_OW 69
24767: PUSH
24768: LD_INT 1
24770: ARRAY
24771: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24772: LD_INT 175
24774: PPUSH
24775: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24779: LD_EXP 12
24783: PUSH
24784: LD_EXP 3
24788: PUSH
24789: LD_INT 0
24791: PUSH
24792: LD_INT 2
24794: PUSH
24795: EMPTY
24796: LIST
24797: LIST
24798: IN
24799: OR
24800: IFFALSE 24823
// target := [ 68 , 108 , 1 ] else
24802: LD_ADDR_VAR 0 2
24806: PUSH
24807: LD_INT 68
24809: PUSH
24810: LD_INT 108
24812: PUSH
24813: LD_INT 1
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: LIST
24820: ST_TO_ADDR
24821: GO 24842
// target := [ 181 , 88 , 2 ] ;
24823: LD_ADDR_VAR 0 2
24827: PUSH
24828: LD_INT 181
24830: PUSH
24831: LD_INT 88
24833: PUSH
24834: LD_INT 2
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: LIST
24841: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24842: LD_VAR 0 1
24846: PPUSH
24847: LD_VAR 0 2
24851: PUSH
24852: LD_INT 1
24854: ARRAY
24855: PPUSH
24856: LD_VAR 0 2
24860: PUSH
24861: LD_INT 2
24863: ARRAY
24864: PPUSH
24865: CALL_OW 176
// if target [ 3 ] = 1 then
24869: LD_VAR 0 2
24873: PUSH
24874: LD_INT 3
24876: ARRAY
24877: PUSH
24878: LD_INT 1
24880: EQUAL
24881: IFFALSE 24897
// SayRadio ( Kurt , D12-Kurt-1 ) else
24883: LD_EXP 60
24887: PPUSH
24888: LD_STRING D12-Kurt-1
24890: PPUSH
24891: CALL_OW 94
24895: GO 24921
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24897: LD_EXP 60
24901: PPUSH
24902: LD_STRING D12a-Kurt-1
24904: PPUSH
24905: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24909: LD_EXP 74
24913: PPUSH
24914: LD_STRING D12a-Roth-1
24916: PPUSH
24917: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24921: LD_INT 350
24923: PPUSH
24924: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24928: LD_VAR 0 1
24932: PPUSH
24933: LD_INT 22
24935: PUSH
24936: LD_INT 8
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: PUSH
24943: LD_INT 23
24945: PUSH
24946: LD_INT 2
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: PUSH
24953: LD_INT 30
24955: PUSH
24956: LD_INT 3
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: LIST
24967: PPUSH
24968: CALL_OW 69
24972: PUSH
24973: LD_INT 1
24975: ARRAY
24976: PPUSH
24977: CALL_OW 228
// end ;
24981: PPOPN 2
24983: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24984: LD_EXP 60
24988: PPUSH
24989: CALL_OW 256
24993: PUSH
24994: LD_INT 999
24996: LESS
24997: PUSH
24998: LD_INT 22
25000: PUSH
25001: LD_INT 8
25003: PUSH
25004: EMPTY
25005: LIST
25006: LIST
25007: PUSH
25008: LD_INT 21
25010: PUSH
25011: LD_INT 1
25013: PUSH
25014: EMPTY
25015: LIST
25016: LIST
25017: PUSH
25018: LD_INT 23
25020: PUSH
25021: LD_INT 2
25023: PUSH
25024: EMPTY
25025: LIST
25026: LIST
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: LIST
25032: PPUSH
25033: CALL_OW 69
25037: PUSH
25038: LD_INT 9
25040: PUSH
25041: LD_INT 8
25043: PUSH
25044: LD_INT 7
25046: PUSH
25047: LD_INT 6
25049: PUSH
25050: EMPTY
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: PUSH
25056: LD_OWVAR 67
25060: ARRAY
25061: LESSEQUAL
25062: OR
25063: PUSH
25064: LD_INT 22
25066: PUSH
25067: LD_INT 8
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: LD_INT 34
25076: PUSH
25077: LD_INT 48
25079: PUSH
25080: EMPTY
25081: LIST
25082: LIST
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PPUSH
25088: CALL_OW 69
25092: NOT
25093: AND
25094: PUSH
25095: LD_EXP 60
25099: PPUSH
25100: CALL_OW 302
25104: AND
25105: PUSH
25106: LD_INT 5
25108: PPUSH
25109: LD_INT 22
25111: PUSH
25112: LD_INT 1
25114: PUSH
25115: EMPTY
25116: LIST
25117: LIST
25118: PPUSH
25119: CALL_OW 70
25123: AND
25124: IFFALSE 25837
25126: GO 25128
25128: DISABLE
25129: LD_INT 0
25131: PPUSH
25132: PPUSH
25133: PPUSH
// begin DialogueOn ;
25134: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25138: LD_EXP 39
25142: PPUSH
25143: LD_STRING D13-JMM-1
25145: PPUSH
25146: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25150: LD_EXP 60
25154: PPUSH
25155: LD_STRING D13-Kurt-1
25157: PPUSH
25158: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25162: LD_EXP 39
25166: PPUSH
25167: LD_STRING D13-JMM-2
25169: PPUSH
25170: CALL_OW 88
// if FakeInfo then
25174: LD_EXP 12
25178: IFFALSE 25198
// begin Say ( Kurt , D13-Kurt-2 ) ;
25180: LD_EXP 60
25184: PPUSH
25185: LD_STRING D13-Kurt-2
25187: PPUSH
25188: CALL_OW 88
// DialogueOff ;
25192: CALL_OW 7
// exit ;
25196: GO 25837
// end ; if not KurtStatus then
25198: LD_EXP 3
25202: NOT
25203: IFFALSE 25219
// Say ( Kurt , D13-Kurt-2b ) else
25205: LD_EXP 60
25209: PPUSH
25210: LD_STRING D13-Kurt-2b
25212: PPUSH
25213: CALL_OW 88
25217: GO 25231
// Say ( Kurt , D13-Kurt-2a ) ;
25219: LD_EXP 60
25223: PPUSH
25224: LD_STRING D13-Kurt-2a
25226: PPUSH
25227: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25231: LD_EXP 39
25235: PPUSH
25236: LD_STRING D13-JMM-3
25238: PPUSH
25239: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25243: LD_EXP 60
25247: PPUSH
25248: LD_STRING D13-Kurt-3
25250: PPUSH
25251: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25255: LD_EXP 39
25259: PPUSH
25260: LD_STRING D13-JMM-4
25262: PPUSH
25263: CALL_OW 88
// DialogueOff ;
25267: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25271: LD_STRING MlegionOut
25273: PPUSH
25274: CALL_OW 337
// legionDestroyed := true ;
25278: LD_ADDR_EXP 22
25282: PUSH
25283: LD_INT 1
25285: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25286: LD_INT 3
25288: PPUSH
25289: CALL 35493 0 1
// KillUnit ( Kozlov ) ;
25293: LD_EXP 61
25297: PPUSH
25298: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25302: LD_ADDR_VAR 0 1
25306: PUSH
25307: LD_INT 22
25309: PUSH
25310: LD_INT 8
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PUSH
25317: LD_INT 23
25319: PUSH
25320: LD_INT 3
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: PUSH
25327: LD_INT 3
25329: PUSH
25330: LD_INT 21
25332: PUSH
25333: LD_INT 33
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PUSH
25340: EMPTY
25341: LIST
25342: LIST
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: LIST
25348: PPUSH
25349: CALL_OW 69
25353: PUSH
25354: FOR_IN
25355: IFFALSE 25368
// KillUnit ( i ) ;
25357: LD_VAR 0 1
25361: PPUSH
25362: CALL_OW 66
25366: GO 25354
25368: POP
25369: POP
// ChangeSideFog ( 8 , 1 ) ;
25370: LD_INT 8
25372: PPUSH
25373: LD_INT 1
25375: PPUSH
25376: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25380: LD_ADDR_VAR 0 2
25384: PUSH
25385: LD_INT 22
25387: PUSH
25388: LD_INT 8
25390: PUSH
25391: EMPTY
25392: LIST
25393: LIST
25394: PUSH
25395: LD_INT 21
25397: PUSH
25398: LD_INT 1
25400: PUSH
25401: EMPTY
25402: LIST
25403: LIST
25404: PUSH
25405: EMPTY
25406: LIST
25407: LIST
25408: PPUSH
25409: CALL_OW 69
25413: PUSH
25414: LD_EXP 61
25418: PUSH
25419: LD_EXP 60
25423: PUSH
25424: EMPTY
25425: LIST
25426: LIST
25427: DIFF
25428: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
25429: LD_VAR 0 2
25433: PUSH
25434: LD_INT 6
25436: PUSH
25437: LD_INT 5
25439: PUSH
25440: LD_INT 4
25442: PUSH
25443: LD_INT 3
25445: PUSH
25446: EMPTY
25447: LIST
25448: LIST
25449: LIST
25450: LIST
25451: PUSH
25452: LD_OWVAR 67
25456: ARRAY
25457: GREATEREQUAL
25458: IFFALSE 25636
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
25460: LD_ADDR_VAR 0 3
25464: PUSH
25465: LD_INT 6
25467: PUSH
25468: LD_INT 5
25470: PUSH
25471: LD_INT 4
25473: PUSH
25474: LD_INT 3
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: LIST
25481: LIST
25482: PUSH
25483: LD_OWVAR 67
25487: ARRAY
25488: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25489: LD_ADDR_VAR 0 1
25493: PUSH
25494: DOUBLE
25495: LD_VAR 0 2
25499: PUSH
25500: LD_VAR 0 3
25504: PUSH
25505: LD_INT 1
25507: PLUS
25508: MINUS
25509: INC
25510: ST_TO_ADDR
25511: LD_INT 1
25513: PUSH
25514: FOR_DOWNTO
25515: IFFALSE 25632
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25517: LD_ADDR_EXP 38
25521: PUSH
25522: LD_EXP 38
25526: PUSH
25527: LD_VAR 0 2
25531: PUSH
25532: LD_VAR 0 1
25536: ARRAY
25537: ADD
25538: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25539: LD_VAR 0 2
25543: PUSH
25544: LD_VAR 0 1
25548: ARRAY
25549: PPUSH
25550: CALL_OW 310
25554: IFFALSE 25571
// ComExitBuilding ( tmp [ i ] ) ;
25556: LD_VAR 0 2
25560: PUSH
25561: LD_VAR 0 1
25565: ARRAY
25566: PPUSH
25567: CALL_OW 122
// if IsInUnit ( i ) then
25571: LD_VAR 0 1
25575: PPUSH
25576: CALL_OW 310
25580: IFFALSE 25597
// ComExitVehicle ( tmp [ i ] ) ;
25582: LD_VAR 0 2
25586: PUSH
25587: LD_VAR 0 1
25591: ARRAY
25592: PPUSH
25593: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25597: LD_VAR 0 2
25601: PUSH
25602: LD_VAR 0 1
25606: ARRAY
25607: PPUSH
25608: LD_INT 34
25610: PUSH
25611: LD_INT 0
25613: PPUSH
25614: LD_INT 6
25616: PPUSH
25617: CALL_OW 12
25621: PLUS
25622: PPUSH
25623: LD_INT 1
25625: PPUSH
25626: CALL_OW 171
// end ;
25630: GO 25514
25632: POP
25633: POP
// end else
25634: GO 25646
// x := tmp ;
25636: LD_ADDR_VAR 0 3
25640: PUSH
25641: LD_VAR 0 2
25645: ST_TO_ADDR
// for i := tmp downto tmp - x do
25646: LD_ADDR_VAR 0 1
25650: PUSH
25651: DOUBLE
25652: LD_VAR 0 2
25656: INC
25657: ST_TO_ADDR
25658: LD_VAR 0 2
25662: PUSH
25663: LD_VAR 0 3
25667: MINUS
25668: PUSH
25669: FOR_DOWNTO
25670: IFFALSE 25724
// begin if IsInUnit ( tmp [ i ] ) then
25672: LD_VAR 0 2
25676: PUSH
25677: LD_VAR 0 1
25681: ARRAY
25682: PPUSH
25683: CALL_OW 310
25687: IFFALSE 25704
// ComExitVehicle ( tmp [ i ] ) ;
25689: LD_VAR 0 2
25693: PUSH
25694: LD_VAR 0 1
25698: ARRAY
25699: PPUSH
25700: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25704: LD_VAR 0 2
25708: PUSH
25709: LD_VAR 0 1
25713: ARRAY
25714: PPUSH
25715: LD_INT 1
25717: PPUSH
25718: CALL_OW 235
// end ;
25722: GO 25669
25724: POP
25725: POP
// SetSide ( Kurt , 1 ) ;
25726: LD_EXP 60
25730: PPUSH
25731: LD_INT 1
25733: PPUSH
25734: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25738: LD_INT 22
25740: PUSH
25741: LD_INT 8
25743: PUSH
25744: EMPTY
25745: LIST
25746: LIST
25747: PUSH
25748: LD_INT 21
25750: PUSH
25751: LD_INT 3
25753: PUSH
25754: EMPTY
25755: LIST
25756: LIST
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PPUSH
25762: CALL_OW 69
25766: PPUSH
25767: LD_INT 1
25769: PPUSH
25770: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25774: LD_INT 8
25776: PPUSH
25777: LD_INT 1
25779: PPUSH
25780: LD_INT 1
25782: PPUSH
25783: LD_INT 1
25785: PPUSH
25786: CALL_OW 80
// wait ( 1 1$20 ) ;
25790: LD_INT 2800
25792: PPUSH
25793: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25797: LD_EXP 62
25801: PPUSH
25802: LD_INT 37
25804: PPUSH
25805: LD_INT 1
25807: PPUSH
25808: LD_INT 0
25810: PPUSH
25811: CALL_OW 48
// wait ( 0 0$1 ) ;
25815: LD_INT 35
25817: PPUSH
25818: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25822: LD_EXP 62
25826: PPUSH
25827: LD_INT 60
25829: PPUSH
25830: LD_INT 95
25832: PPUSH
25833: CALL_OW 111
// end ;
25837: PPOPN 3
25839: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25840: LD_EXP 22
25844: NOT
25845: PUSH
25846: LD_INT 22
25848: PUSH
25849: LD_INT 8
25851: PUSH
25852: EMPTY
25853: LIST
25854: LIST
25855: PUSH
25856: LD_INT 21
25858: PUSH
25859: LD_INT 1
25861: PUSH
25862: EMPTY
25863: LIST
25864: LIST
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PPUSH
25870: CALL_OW 69
25874: PUSH
25875: LD_INT 0
25877: EQUAL
25878: AND
25879: IFFALSE 25899
25881: GO 25883
25883: DISABLE
// begin legionDestroyed := true ;
25884: LD_ADDR_EXP 22
25888: PUSH
25889: LD_INT 1
25891: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25892: LD_STRING MlegionOut
25894: PPUSH
25895: CALL_OW 337
// end ;
25899: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25900: LD_EXP 38
25904: IFFALSE 25979
25906: GO 25908
25908: DISABLE
25909: LD_INT 0
25911: PPUSH
// begin enable ;
25912: ENABLE
// for i in legionEscapeUnits do
25913: LD_ADDR_VAR 0 1
25917: PUSH
25918: LD_EXP 38
25922: PUSH
25923: FOR_IN
25924: IFFALSE 25977
// begin if IsInArea ( i , legionEscapeArea ) then
25926: LD_VAR 0 1
25930: PPUSH
25931: LD_INT 31
25933: PPUSH
25934: CALL_OW 308
25938: IFFALSE 25951
// RemoveUnit ( i ) else
25940: LD_VAR 0 1
25944: PPUSH
25945: CALL_OW 64
25949: GO 25975
// if not HasTask ( i ) then
25951: LD_VAR 0 1
25955: PPUSH
25956: CALL_OW 314
25960: NOT
25961: IFFALSE 25975
// ComMoveToArea ( i , legionEscapeArea ) ;
25963: LD_VAR 0 1
25967: PPUSH
25968: LD_INT 31
25970: PPUSH
25971: CALL_OW 113
// end ;
25975: GO 25923
25977: POP
25978: POP
// end ;
25979: PPOPN 1
25981: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25982: LD_INT 1
25984: PPUSH
25985: LD_EXP 62
25989: PPUSH
25990: CALL_OW 292
25994: IFFALSE 26292
25996: GO 25998
25998: DISABLE
25999: LD_INT 0
26001: PPUSH
// begin wait ( 0 0$2 ) ;
26002: LD_INT 70
26004: PPUSH
26005: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
26009: LD_EXP 62
26013: PPUSH
26014: CALL_OW 87
// DialogueOn ;
26018: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
26022: LD_EXP 39
26026: PPUSH
26027: LD_STRING D14-JMM-1
26029: PPUSH
26030: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
26034: LD_EXP 62
26038: PPUSH
26039: LD_STRING D14-Friend-1
26041: PPUSH
26042: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
26046: LD_EXP 39
26050: PPUSH
26051: LD_STRING D14-JMM-2
26053: PPUSH
26054: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
26058: LD_EXP 62
26062: PPUSH
26063: LD_STRING D14-Friend-2
26065: PPUSH
26066: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
26070: LD_EXP 39
26074: PPUSH
26075: LD_STRING D14-JMM-3
26077: PPUSH
26078: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
26082: LD_EXP 62
26086: PPUSH
26087: LD_STRING D14-Friend-3
26089: PPUSH
26090: CALL_OW 88
// DialogueOff ;
26094: CALL_OW 7
// dec = Query ( Q14 ) ;
26098: LD_ADDR_VAR 0 1
26102: PUSH
26103: LD_STRING Q14
26105: PPUSH
26106: CALL_OW 97
26110: ST_TO_ADDR
// if dec = 1 then
26111: LD_VAR 0 1
26115: PUSH
26116: LD_INT 1
26118: EQUAL
26119: IFFALSE 26153
// begin DialogueOn ;
26121: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26125: LD_EXP 39
26129: PPUSH
26130: LD_STRING D14a-JMM-1
26132: PPUSH
26133: CALL_OW 88
// DialogueOff ;
26137: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26141: LD_EXP 62
26145: PPUSH
26146: LD_INT 1
26148: PPUSH
26149: CALL_OW 235
// end ; if dec = 2 then
26153: LD_VAR 0 1
26157: PUSH
26158: LD_INT 2
26160: EQUAL
26161: IFFALSE 26214
// begin DialogueOn ;
26163: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26167: LD_EXP 39
26171: PPUSH
26172: LD_STRING D14b-JMM-1
26174: PPUSH
26175: CALL_OW 88
// DialogueOff ;
26179: CALL_OW 7
// wait ( 0 0$1 ) ;
26183: LD_INT 35
26185: PPUSH
26186: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26190: LD_EXP 62
26194: PPUSH
26195: LD_INT 9
26197: PPUSH
26198: LD_INT 2
26200: PPUSH
26201: CALL_OW 111
// AddComHold ( Friend ) ;
26205: LD_EXP 62
26209: PPUSH
26210: CALL_OW 200
// end ; if dec = 3 then
26214: LD_VAR 0 1
26218: PUSH
26219: LD_INT 3
26221: EQUAL
26222: IFFALSE 26292
// begin DialogueOn ;
26224: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26228: LD_EXP 39
26232: PPUSH
26233: LD_STRING D14c-JMM-1
26235: PPUSH
26236: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26240: LD_EXP 62
26244: PPUSH
26245: LD_STRING D14c-Friend-1
26247: PPUSH
26248: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26252: LD_EXP 39
26256: PPUSH
26257: LD_STRING D14c-JMM-2
26259: PPUSH
26260: CALL_OW 88
// DialogueOff ;
26264: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26268: LD_EXP 62
26272: PPUSH
26273: LD_INT 9
26275: PPUSH
26276: LD_INT 2
26278: PPUSH
26279: CALL_OW 111
// AddComHold ( Friend ) ;
26283: LD_EXP 62
26287: PPUSH
26288: CALL_OW 200
// end ; end ;
26292: PPOPN 1
26294: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26295: LD_INT 9
26297: PPUSH
26298: LD_INT 2
26300: PPUSH
26301: CALL_OW 428
26305: PUSH
26306: LD_EXP 62
26310: EQUAL
26311: PUSH
26312: LD_EXP 62
26316: PPUSH
26317: CALL_OW 255
26321: PUSH
26322: LD_INT 8
26324: EQUAL
26325: AND
26326: IFFALSE 26340
26328: GO 26330
26330: DISABLE
// RemoveUnit ( Friend ) ;
26331: LD_EXP 62
26335: PPUSH
26336: CALL_OW 64
26340: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26341: LD_EXP 14
26345: PUSH
26346: LD_INT 31500
26348: GREATEREQUAL
26349: PUSH
26350: LD_EXP 7
26354: AND
26355: PUSH
26356: LD_EXP 2
26360: AND
26361: IFFALSE 26791
26363: GO 26365
26365: DISABLE
26366: LD_INT 0
26368: PPUSH
26369: PPUSH
26370: PPUSH
// begin missionStage := 7 ;
26371: LD_ADDR_EXP 15
26375: PUSH
26376: LD_INT 7
26378: ST_TO_ADDR
// uc_side = 1 ;
26379: LD_ADDR_OWVAR 20
26383: PUSH
26384: LD_INT 1
26386: ST_TO_ADDR
// uc_nation = 1 ;
26387: LD_ADDR_OWVAR 21
26391: PUSH
26392: LD_INT 1
26394: ST_TO_ADDR
// for i = 1 to 5 do
26395: LD_ADDR_VAR 0 1
26399: PUSH
26400: DOUBLE
26401: LD_INT 1
26403: DEC
26404: ST_TO_ADDR
26405: LD_INT 5
26407: PUSH
26408: FOR_TO
26409: IFFALSE 26505
// begin vc_engine = 3 ;
26411: LD_ADDR_OWVAR 39
26415: PUSH
26416: LD_INT 3
26418: ST_TO_ADDR
// vc_control = 3 ;
26419: LD_ADDR_OWVAR 38
26423: PUSH
26424: LD_INT 3
26426: ST_TO_ADDR
// vc_chassis = 3 ;
26427: LD_ADDR_OWVAR 37
26431: PUSH
26432: LD_INT 3
26434: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26435: LD_ADDR_OWVAR 40
26439: PUSH
26440: LD_INT 5
26442: PUSH
26443: LD_INT 9
26445: PUSH
26446: LD_INT 7
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: LIST
26453: PUSH
26454: LD_INT 1
26456: PPUSH
26457: LD_INT 3
26459: PPUSH
26460: CALL_OW 12
26464: ARRAY
26465: ST_TO_ADDR
// veh = CreateVehicle ;
26466: LD_ADDR_VAR 0 2
26470: PUSH
26471: CALL_OW 45
26475: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26476: LD_VAR 0 2
26480: PPUSH
26481: LD_INT 1
26483: PPUSH
26484: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26488: LD_VAR 0 2
26492: PPUSH
26493: LD_INT 19
26495: PPUSH
26496: LD_INT 0
26498: PPUSH
26499: CALL_OW 49
// end ;
26503: GO 26408
26505: POP
26506: POP
// vc_engine = 3 ;
26507: LD_ADDR_OWVAR 39
26511: PUSH
26512: LD_INT 3
26514: ST_TO_ADDR
// vc_control = 1 ;
26515: LD_ADDR_OWVAR 38
26519: PUSH
26520: LD_INT 1
26522: ST_TO_ADDR
// vc_chassis = 3 ;
26523: LD_ADDR_OWVAR 37
26527: PUSH
26528: LD_INT 3
26530: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26531: LD_ADDR_OWVAR 40
26535: PUSH
26536: LD_INT 5
26538: PUSH
26539: LD_INT 9
26541: PUSH
26542: LD_INT 7
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: LIST
26549: PUSH
26550: LD_INT 1
26552: PPUSH
26553: LD_INT 3
26555: PPUSH
26556: CALL_OW 12
26560: ARRAY
26561: ST_TO_ADDR
// vehG = CreateVehicle ;
26562: LD_ADDR_VAR 0 3
26566: PUSH
26567: CALL_OW 45
26571: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26572: LD_VAR 0 3
26576: PPUSH
26577: LD_INT 1
26579: PPUSH
26580: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26584: LD_VAR 0 3
26588: PPUSH
26589: LD_INT 19
26591: PPUSH
26592: LD_INT 0
26594: PPUSH
26595: CALL_OW 49
// if JMMGirl = 1 then
26599: LD_EXP 7
26603: PUSH
26604: LD_INT 1
26606: EQUAL
26607: IFFALSE 26663
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26609: LD_ADDR_EXP 40
26613: PUSH
26614: LD_STRING Joan
26616: PPUSH
26617: LD_INT 1
26619: PPUSH
26620: LD_STRING 14_
26622: PPUSH
26623: CALL 65877 0 3
26627: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26628: LD_EXP 40
26632: PPUSH
26633: LD_VAR 0 3
26637: PPUSH
26638: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26642: LD_VAR 0 3
26646: PPUSH
26647: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26651: LD_EXP 40
26655: PPUSH
26656: LD_STRING D10BW-Joan-1
26658: PPUSH
26659: CALL_OW 94
// end ; if JMMGirl = 2 then
26663: LD_EXP 7
26667: PUSH
26668: LD_INT 2
26670: EQUAL
26671: IFFALSE 26727
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26673: LD_ADDR_EXP 42
26677: PUSH
26678: LD_STRING Lisa
26680: PPUSH
26681: LD_INT 1
26683: PPUSH
26684: LD_STRING 14_
26686: PPUSH
26687: CALL 65877 0 3
26691: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26692: LD_EXP 42
26696: PPUSH
26697: LD_VAR 0 3
26701: PPUSH
26702: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26706: LD_VAR 0 3
26710: PPUSH
26711: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26715: LD_EXP 42
26719: PPUSH
26720: LD_STRING D10BW-Lisa-1
26722: PPUSH
26723: CALL_OW 94
// end ; if JMMGirl = 3 then
26727: LD_EXP 7
26731: PUSH
26732: LD_INT 3
26734: EQUAL
26735: IFFALSE 26791
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26737: LD_ADDR_EXP 54
26741: PUSH
26742: LD_STRING Connie
26744: PPUSH
26745: LD_INT 1
26747: PPUSH
26748: LD_STRING 14_
26750: PPUSH
26751: CALL 65877 0 3
26755: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26756: LD_EXP 54
26760: PPUSH
26761: LD_VAR 0 3
26765: PPUSH
26766: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26770: LD_VAR 0 3
26774: PPUSH
26775: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26779: LD_EXP 54
26783: PPUSH
26784: LD_STRING D10BW-Con-1
26786: PPUSH
26787: CALL_OW 94
// end ; end ;
26791: PPOPN 3
26793: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26794: LD_EXP 14
26798: PUSH
26799: LD_INT 94500
26801: GREATEREQUAL
26802: IFFALSE 27214
26804: GO 26806
26806: DISABLE
26807: LD_INT 0
26809: PPUSH
26810: PPUSH
26811: PPUSH
// begin tmp := PrepareStevensSquad ;
26812: LD_ADDR_VAR 0 3
26816: PUSH
26817: CALL 2226 0 0
26821: ST_TO_ADDR
// if not tmp then
26822: LD_VAR 0 3
26826: NOT
26827: IFFALSE 26831
// exit ;
26829: GO 27214
// uc_side := 1 ;
26831: LD_ADDR_OWVAR 20
26835: PUSH
26836: LD_INT 1
26838: ST_TO_ADDR
// uc_nation := 1 ;
26839: LD_ADDR_OWVAR 21
26843: PUSH
26844: LD_INT 1
26846: ST_TO_ADDR
// for i in tmp do
26847: LD_ADDR_VAR 0 1
26851: PUSH
26852: LD_VAR 0 3
26856: PUSH
26857: FOR_IN
26858: IFFALSE 26955
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26860: LD_INT 3
26862: PPUSH
26863: LD_INT 3
26865: PPUSH
26866: LD_INT 1
26868: PPUSH
26869: LD_INT 5
26871: PUSH
26872: LD_INT 9
26874: PUSH
26875: LD_INT 7
26877: PUSH
26878: EMPTY
26879: LIST
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 1
26885: PPUSH
26886: LD_INT 3
26888: PPUSH
26889: CALL_OW 12
26893: ARRAY
26894: PPUSH
26895: LD_INT 40
26897: PPUSH
26898: CALL 70741 0 5
// veh := CreateVehicle ;
26902: LD_ADDR_VAR 0 2
26906: PUSH
26907: CALL_OW 45
26911: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26912: LD_VAR 0 2
26916: PPUSH
26917: LD_INT 1
26919: PPUSH
26920: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26924: LD_VAR 0 2
26928: PPUSH
26929: LD_INT 19
26931: PPUSH
26932: LD_INT 0
26934: PPUSH
26935: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26939: LD_VAR 0 1
26943: PPUSH
26944: LD_VAR 0 2
26948: PPUSH
26949: CALL_OW 52
// end ;
26953: GO 26857
26955: POP
26956: POP
// missionStage := 8 ;
26957: LD_ADDR_EXP 15
26961: PUSH
26962: LD_INT 8
26964: ST_TO_ADDR
// DialogueOn ;
26965: CALL_OW 6
// if Stevens then
26969: LD_EXP 41
26973: IFFALSE 27087
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26975: LD_EXP 41
26979: PPUSH
26980: CALL_OW 310
26984: PPUSH
26985: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26989: LD_EXP 41
26993: PPUSH
26994: LD_STRING D8-Huck-1
26996: PPUSH
26997: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
27001: LD_EXP 39
27005: PPUSH
27006: LD_STRING D8-JMM-1
27008: PPUSH
27009: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
27013: LD_EXP 41
27017: PPUSH
27018: LD_STRING D8-Huck-2
27020: PPUSH
27021: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27025: LD_EXP 39
27029: PPUSH
27030: LD_STRING D8-JMM-2
27032: PPUSH
27033: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
27037: LD_EXP 41
27041: PPUSH
27042: LD_STRING D8-Huck-3
27044: PPUSH
27045: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27049: LD_EXP 39
27053: PPUSH
27054: LD_STRING D8-JMM-3
27056: PPUSH
27057: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
27061: LD_EXP 41
27065: PPUSH
27066: LD_STRING D8-Huck-4
27068: PPUSH
27069: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27073: LD_EXP 39
27077: PPUSH
27078: LD_STRING D8-JMM-4
27080: PPUSH
27081: CALL_OW 88
// end else
27085: GO 27197
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
27087: LD_EXP 55
27091: PPUSH
27092: CALL_OW 310
27096: PPUSH
27097: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27101: LD_EXP 55
27105: PPUSH
27106: LD_STRING D8-Huck-1
27108: PPUSH
27109: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27113: LD_EXP 39
27117: PPUSH
27118: LD_STRING D8-JMM-1a
27120: PPUSH
27121: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27125: LD_EXP 55
27129: PPUSH
27130: LD_STRING D8-Huck-2
27132: PPUSH
27133: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27137: LD_EXP 39
27141: PPUSH
27142: LD_STRING D8-JMM-2
27144: PPUSH
27145: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27149: LD_EXP 55
27153: PPUSH
27154: LD_STRING D8-Huck-3
27156: PPUSH
27157: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27161: LD_EXP 39
27165: PPUSH
27166: LD_STRING D8-JMM-3
27168: PPUSH
27169: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27173: LD_EXP 55
27177: PPUSH
27178: LD_STRING D8-Huck-4
27180: PPUSH
27181: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27185: LD_EXP 39
27189: PPUSH
27190: LD_STRING D8-JMM-4
27192: PPUSH
27193: CALL_OW 88
// end ; DialogueOff ;
27197: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27201: LD_INT 25
27203: PPUSH
27204: LD_INT 1
27206: PPUSH
27207: LD_INT 1
27209: PPUSH
27210: CALL_OW 322
// end ;
27214: PPOPN 3
27216: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27217: LD_INT 1
27219: PPUSH
27220: LD_EXP 71
27224: PPUSH
27225: CALL_OW 292
27229: IFFALSE 27480
27231: GO 27233
27233: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27234: LD_EXP 71
27238: PPUSH
27239: CALL_OW 87
// DialogueOn ;
27243: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27247: LD_EXP 39
27251: PPUSH
27252: LD_STRING D10nB-JMM-1
27254: PPUSH
27255: CALL_OW 88
// if BurlakStatus = 1 then
27259: LD_EXP 9
27263: PUSH
27264: LD_INT 1
27266: EQUAL
27267: IFFALSE 27281
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27269: LD_EXP 70
27273: PPUSH
27274: LD_STRING D10nB-Vse-1a
27276: PPUSH
27277: CALL_OW 94
// end ; if BurlakStatus = 0 then
27281: LD_EXP 9
27285: PUSH
27286: LD_INT 0
27288: EQUAL
27289: IFFALSE 27303
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27291: LD_EXP 70
27295: PPUSH
27296: LD_STRING D10nB-Vse-1
27298: PPUSH
27299: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27303: LD_EXP 39
27307: PPUSH
27308: LD_STRING D10nB-JMM-2
27310: PPUSH
27311: CALL_OW 88
// if KappaStatus then
27315: LD_EXP 2
27319: IFFALSE 27333
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27321: LD_EXP 70
27325: PPUSH
27326: LD_STRING D10nB-Vse-5a
27328: PPUSH
27329: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27333: LD_EXP 2
27337: NOT
27338: PUSH
27339: LD_EXP 6
27343: PUSH
27344: LD_INT 0
27346: EQUAL
27347: AND
27348: IFFALSE 27476
// begin if JMMGirl = 1 then
27350: LD_EXP 7
27354: PUSH
27355: LD_INT 1
27357: EQUAL
27358: IFFALSE 27408
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27360: LD_EXP 70
27364: PPUSH
27365: LD_STRING D10nB-Vse-2
27367: PPUSH
27368: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27372: LD_EXP 39
27376: PPUSH
27377: LD_STRING D10nB-JMM-3
27379: PPUSH
27380: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27384: LD_EXP 70
27388: PPUSH
27389: LD_STRING D10nB-Vse-3
27391: PPUSH
27392: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27396: LD_EXP 39
27400: PPUSH
27401: LD_STRING D10nB-JMM-4
27403: PPUSH
27404: CALL_OW 88
// end ; if JMMGirl = 2 then
27408: LD_EXP 7
27412: PUSH
27413: LD_INT 2
27415: EQUAL
27416: IFFALSE 27442
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27418: LD_EXP 70
27422: PPUSH
27423: LD_STRING D10nB-Vse-4
27425: PPUSH
27426: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27430: LD_EXP 39
27434: PPUSH
27435: LD_STRING D10nB-JMM-5
27437: PPUSH
27438: CALL_OW 88
// end ; if JMMGirl = 3 then
27442: LD_EXP 7
27446: PUSH
27447: LD_INT 3
27449: EQUAL
27450: IFFALSE 27476
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27452: LD_EXP 70
27456: PPUSH
27457: LD_STRING D10nB-Vse-5
27459: PPUSH
27460: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27464: LD_EXP 39
27468: PPUSH
27469: LD_STRING D10nB-JMM-6
27471: PPUSH
27472: CALL_OW 88
// end ; end ; DialogueOff ;
27476: CALL_OW 7
// end ;
27480: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27481: LD_EXP 14
27485: PUSH
27486: LD_INT 115500
27488: GREATEREQUAL
27489: IFFALSE 27865
27491: GO 27493
27493: DISABLE
27494: LD_INT 0
27496: PPUSH
// begin missionStage := 10 ;
27497: LD_ADDR_EXP 15
27501: PUSH
27502: LD_INT 10
27504: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27505: LD_ADDR_VAR 0 1
27509: PUSH
27510: LD_INT 22
27512: PUSH
27513: LD_INT 1
27515: PUSH
27516: EMPTY
27517: LIST
27518: LIST
27519: PUSH
27520: LD_INT 23
27522: PUSH
27523: LD_INT 1
27525: PUSH
27526: EMPTY
27527: LIST
27528: LIST
27529: PUSH
27530: LD_INT 26
27532: PUSH
27533: LD_INT 1
27535: PUSH
27536: EMPTY
27537: LIST
27538: LIST
27539: PUSH
27540: LD_INT 3
27542: PUSH
27543: LD_INT 25
27545: PUSH
27546: LD_INT 12
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: PUSH
27557: LD_INT 3
27559: PUSH
27560: LD_INT 25
27562: PUSH
27563: LD_INT 16
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: PUSH
27570: EMPTY
27571: LIST
27572: LIST
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: PPUSH
27581: CALL_OW 69
27585: PUSH
27586: LD_EXP 39
27590: PUSH
27591: LD_EXP 60
27595: PUSH
27596: LD_EXP 41
27600: PUSH
27601: LD_EXP 55
27605: PUSH
27606: LD_EXP 42
27610: PUSH
27611: LD_EXP 43
27615: PUSH
27616: LD_EXP 44
27620: PUSH
27621: LD_EXP 45
27625: PUSH
27626: LD_EXP 46
27630: PUSH
27631: LD_EXP 47
27635: PUSH
27636: LD_EXP 48
27640: PUSH
27641: LD_EXP 49
27645: PUSH
27646: LD_EXP 50
27650: PUSH
27651: LD_EXP 51
27655: PUSH
27656: LD_EXP 52
27660: PUSH
27661: LD_EXP 53
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: LIST
27670: LIST
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: LIST
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: LIST
27682: LIST
27683: DIFF
27684: ST_TO_ADDR
// if not tmp and Brown then
27685: LD_VAR 0 1
27689: NOT
27690: PUSH
27691: LD_EXP 47
27695: AND
27696: IFFALSE 27711
// tmp := [ Brown ] ;
27698: LD_ADDR_VAR 0 1
27702: PUSH
27703: LD_EXP 47
27707: PUSH
27708: EMPTY
27709: LIST
27710: ST_TO_ADDR
// DialogueOn ;
27711: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27715: LD_VAR 0 1
27719: PUSH
27720: LD_INT 1
27722: ARRAY
27723: PPUSH
27724: LD_STRING D11-Sol1-1
27726: PPUSH
27727: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27731: LD_EXP 64
27735: PPUSH
27736: LD_STRING D11-Pla-1
27738: PPUSH
27739: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27743: LD_EXP 65
27747: PPUSH
27748: LD_STRING D11-Kov-1
27750: PPUSH
27751: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27755: LD_EXP 64
27759: PPUSH
27760: LD_STRING D11-Pla-2
27762: PPUSH
27763: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27767: LD_VAR 0 1
27771: PUSH
27772: LD_INT 1
27774: ARRAY
27775: PPUSH
27776: LD_STRING D11-Sol1-2
27778: PPUSH
27779: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27783: LD_EXP 39
27787: PPUSH
27788: LD_STRING D11-JMM-2
27790: PPUSH
27791: CALL_OW 88
// DialogueOff ;
27795: CALL_OW 7
// allowBehemothConstruct := true ;
27799: LD_ADDR_EXP 25
27803: PUSH
27804: LD_INT 1
27806: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27807: LD_STRING M4
27809: PPUSH
27810: CALL_OW 337
// BuildBehemoths ;
27814: CALL 7733 0 0
// repeat wait ( 15 15$00 ) ;
27818: LD_INT 31500
27820: PPUSH
27821: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27825: LD_EXP 27
27829: IFFALSE 27833
// break ;
27831: GO 27865
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27833: LD_INT 267
27835: PPUSH
27836: CALL_OW 274
27840: PPUSH
27841: LD_INT 1
27843: PPUSH
27844: CALL_OW 275
27848: PUSH
27849: LD_INT 1000
27851: GREATEREQUAL
27852: IFFALSE 27858
// BuildBehemoths ;
27854: CALL 7733 0 0
// until not behemothBuilders ;
27858: LD_EXP 73
27862: NOT
27863: IFFALSE 27818
// end ;
27865: PPOPN 1
27867: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27868: LD_EXP 73
27872: NOT
27873: PUSH
27874: LD_EXP 28
27878: NOT
27879: AND
27880: PUSH
27881: LD_EXP 25
27885: AND
27886: IFFALSE 27906
27888: GO 27890
27890: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27891: LD_STRING M4a
27893: PPUSH
27894: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27898: LD_ADDR_EXP 27
27902: PUSH
27903: LD_INT 1
27905: ST_TO_ADDR
// end ;
27906: END
// every 0 0$1 trigger behemothDone do
27907: LD_EXP 28
27911: IFFALSE 27923
27913: GO 27915
27915: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27916: LD_STRING M4b
27918: PPUSH
27919: CALL_OW 337
27923: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27924: LD_EXP 29
27928: NOT
27929: IFFALSE 28125
27931: GO 27933
27933: DISABLE
27934: LD_INT 0
27936: PPUSH
27937: PPUSH
// begin enable ;
27938: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27939: LD_ADDR_VAR 0 1
27943: PUSH
27944: LD_INT 3
27946: PPUSH
27947: CALL 102675 0 1
27951: ST_TO_ADDR
// if not tmp and not behemothDone then
27952: LD_VAR 0 1
27956: NOT
27957: PUSH
27958: LD_EXP 28
27962: NOT
27963: AND
27964: IFFALSE 28000
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27966: LD_ADDR_VAR 0 1
27970: PUSH
27971: LD_INT 22
27973: PUSH
27974: LD_INT 3
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 30
27983: PUSH
27984: LD_INT 37
27986: PUSH
27987: EMPTY
27988: LIST
27989: LIST
27990: PUSH
27991: EMPTY
27992: LIST
27993: LIST
27994: PPUSH
27995: CALL_OW 69
27999: ST_TO_ADDR
// if not tmp then
28000: LD_VAR 0 1
28004: NOT
28005: IFFALSE 28009
// exit ;
28007: GO 28125
// for i in tmp do
28009: LD_ADDR_VAR 0 2
28013: PUSH
28014: LD_VAR 0 1
28018: PUSH
28019: FOR_IN
28020: IFFALSE 28123
// if See ( 1 , i ) then
28022: LD_INT 1
28024: PPUSH
28025: LD_VAR 0 2
28029: PPUSH
28030: CALL_OW 292
28034: IFFALSE 28121
// begin if GetType ( i ) = unit_building then
28036: LD_VAR 0 2
28040: PPUSH
28041: CALL_OW 247
28045: PUSH
28046: LD_INT 3
28048: EQUAL
28049: IFFALSE 28087
// begin CenterNowOnUnits ( i ) ;
28051: LD_VAR 0 2
28055: PPUSH
28056: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
28060: LD_EXP 39
28064: PPUSH
28065: LD_STRING D17a-JMM-1
28067: PPUSH
28068: CALL_OW 88
// seeBehemoth := true ;
28072: LD_ADDR_EXP 29
28076: PUSH
28077: LD_INT 1
28079: ST_TO_ADDR
// disable ;
28080: DISABLE
// exit ;
28081: POP
28082: POP
28083: GO 28125
// end else
28085: GO 28121
// begin CenterNowOnUnits ( i ) ;
28087: LD_VAR 0 2
28091: PPUSH
28092: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
28096: LD_EXP 39
28100: PPUSH
28101: LD_STRING D17b-JMM-1
28103: PPUSH
28104: CALL_OW 88
// seeBehemoth := true ;
28108: LD_ADDR_EXP 29
28112: PUSH
28113: LD_INT 1
28115: ST_TO_ADDR
// disable ;
28116: DISABLE
// exit ;
28117: POP
28118: POP
28119: GO 28125
// end ; end ;
28121: GO 28019
28123: POP
28124: POP
// end ;
28125: PPOPN 2
28127: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28128: LD_EXP 14
28132: PUSH
28133: LD_INT 123200
28135: GREATEREQUAL
28136: IFFALSE 29312
28138: GO 28140
28140: DISABLE
28141: LD_INT 0
28143: PPUSH
28144: PPUSH
28145: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28146: LD_INT 2
28148: PPUSH
28149: LD_INT 23
28151: PUSH
28152: LD_INT 3
28154: PUSH
28155: LD_INT 3
28157: PUSH
28158: LD_INT 48
28160: PUSH
28161: EMPTY
28162: LIST
28163: LIST
28164: LIST
28165: LIST
28166: PUSH
28167: EMPTY
28168: LIST
28169: PPUSH
28170: CALL 59471 0 2
// repeat wait ( 0 0$1 ) ;
28174: LD_INT 35
28176: PPUSH
28177: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28181: LD_INT 22
28183: PUSH
28184: LD_INT 3
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: PUSH
28191: LD_INT 34
28193: PUSH
28194: LD_INT 48
28196: PUSH
28197: EMPTY
28198: LIST
28199: LIST
28200: PUSH
28201: EMPTY
28202: LIST
28203: LIST
28204: PPUSH
28205: CALL_OW 69
28209: IFFALSE 28174
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28211: LD_ADDR_VAR 0 1
28215: PUSH
28216: LD_INT 22
28218: PUSH
28219: LD_INT 3
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 34
28228: PUSH
28229: LD_INT 48
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PPUSH
28240: CALL_OW 69
28244: PUSH
28245: LD_INT 1
28247: ARRAY
28248: ST_TO_ADDR
// missionStage := 12 ;
28249: LD_ADDR_EXP 15
28253: PUSH
28254: LD_INT 12
28256: ST_TO_ADDR
// platonovHasBomb := true ;
28257: LD_ADDR_EXP 30
28261: PUSH
28262: LD_INT 1
28264: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28265: LD_VAR 0 1
28269: PPUSH
28270: LD_INT 181
28272: PPUSH
28273: LD_INT 86
28275: PPUSH
28276: CALL_OW 171
// AddComHold ( bomb ) ;
28280: LD_VAR 0 1
28284: PPUSH
28285: CALL_OW 200
// wait ( 0 0$10 ) ;
28289: LD_INT 350
28291: PPUSH
28292: CALL_OW 67
// DialogueOn ;
28296: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28300: LD_EXP 64
28304: PPUSH
28305: LD_STRING D15-Pla-1
28307: PPUSH
28308: CALL_OW 94
// dec = Query ( Q15a ) ;
28312: LD_ADDR_VAR 0 2
28316: PUSH
28317: LD_STRING Q15a
28319: PPUSH
28320: CALL_OW 97
28324: ST_TO_ADDR
// if dec = 1 then
28325: LD_VAR 0 2
28329: PUSH
28330: LD_INT 1
28332: EQUAL
28333: IFFALSE 28356
// begin Say ( JMM , D15a-JMM-1 ) ;
28335: LD_EXP 39
28339: PPUSH
28340: LD_STRING D15a-JMM-1
28342: PPUSH
28343: CALL_OW 88
// YouLost ( Surrender ) ;
28347: LD_STRING Surrender
28349: PPUSH
28350: CALL_OW 104
// exit ;
28354: GO 29312
// end ; if dec = 2 then
28356: LD_VAR 0 2
28360: PUSH
28361: LD_INT 2
28363: EQUAL
28364: IFFALSE 28433
// begin Say ( JMM , D15b-JMM-1 ) ;
28366: LD_EXP 39
28370: PPUSH
28371: LD_STRING D15b-JMM-1
28373: PPUSH
28374: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28378: LD_EXP 64
28382: PPUSH
28383: LD_STRING D15b-Pla-1
28385: PPUSH
28386: CALL_OW 94
// DialogueOff ;
28390: CALL_OW 7
// wait ( 3 3$00 ) ;
28394: LD_INT 6300
28396: PPUSH
28397: CALL_OW 67
// DialogueOn ;
28401: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28405: LD_EXP 39
28409: PPUSH
28410: LD_STRING D15d-JMM-1a
28412: PPUSH
28413: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28417: LD_EXP 64
28421: PPUSH
28422: LD_STRING D15d-Pla-1
28424: PPUSH
28425: CALL_OW 94
// DialogueOff ;
28429: CALL_OW 7
// end ; if dec = 3 then
28433: LD_VAR 0 2
28437: PUSH
28438: LD_INT 3
28440: EQUAL
28441: IFFALSE 28495
// begin Say ( JMM , D15c-JMM-1 ) ;
28443: LD_EXP 39
28447: PPUSH
28448: LD_STRING D15c-JMM-1
28450: PPUSH
28451: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28455: LD_EXP 64
28459: PPUSH
28460: LD_STRING D15c-Pla-1
28462: PPUSH
28463: CALL_OW 94
// DialogueOff ;
28467: CALL_OW 7
// wait ( 0 0$15 ) ;
28471: LD_INT 525
28473: PPUSH
28474: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28478: LD_VAR 0 1
28482: PPUSH
28483: LD_INT 60
28485: PPUSH
28486: LD_INT 95
28488: PPUSH
28489: CALL_OW 116
// exit ;
28493: GO 29312
// end ; if dec = 4 then
28495: LD_VAR 0 2
28499: PUSH
28500: LD_INT 4
28502: EQUAL
28503: IFFALSE 28533
// begin Say ( JMM , D15d-JMM-1 ) ;
28505: LD_EXP 39
28509: PPUSH
28510: LD_STRING D15d-JMM-1
28512: PPUSH
28513: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28517: LD_EXP 64
28521: PPUSH
28522: LD_STRING D15d-Pla-1
28524: PPUSH
28525: CALL_OW 94
// DialogueOff ;
28529: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28533: LD_EXP 62
28537: PPUSH
28538: CALL_OW 302
28542: PUSH
28543: LD_EXP 62
28547: PPUSH
28548: CALL_OW 255
28552: PUSH
28553: LD_INT 1
28555: EQUAL
28556: AND
28557: PUSH
28558: LD_INT 22
28560: PUSH
28561: LD_INT 1
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: PUSH
28568: LD_INT 34
28570: PUSH
28571: LD_INT 8
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PPUSH
28582: CALL_OW 69
28586: NOT
28587: AND
28588: IFFALSE 29213
// begin SetSide ( Friend , 8 ) ;
28590: LD_EXP 62
28594: PPUSH
28595: LD_INT 8
28597: PPUSH
28598: CALL_OW 235
// if IsInUnit ( Friend ) then
28602: LD_EXP 62
28606: PPUSH
28607: CALL_OW 310
28611: IFFALSE 28622
// ComExitBuilding ( Friend ) ;
28613: LD_EXP 62
28617: PPUSH
28618: CALL_OW 122
// if IsDriver ( Friend ) then
28622: LD_EXP 62
28626: PPUSH
28627: CALL 100220 0 1
28631: IFFALSE 28642
// ComExitVehicle ( Friend ) ;
28633: LD_EXP 62
28637: PPUSH
28638: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28642: LD_EXP 62
28646: PPUSH
28647: LD_INT 9
28649: PPUSH
28650: LD_INT 2
28652: PPUSH
28653: CALL_OW 171
// wait ( 0 0$05 ) ;
28657: LD_INT 175
28659: PPUSH
28660: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28664: LD_EXP 62
28668: PPUSH
28669: CALL_OW 87
// DialogueOn ;
28673: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28677: LD_EXP 39
28681: PPUSH
28682: LD_STRING D16-JMM-1
28684: PPUSH
28685: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28689: LD_EXP 62
28693: PPUSH
28694: LD_STRING D16-Friend-1
28696: PPUSH
28697: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28701: LD_EXP 39
28705: PPUSH
28706: LD_STRING D16-JMM-2
28708: PPUSH
28709: CALL_OW 88
// DialogueOff ;
28713: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28717: LD_EXP 62
28721: PPUSH
28722: LD_INT 1
28724: PPUSH
28725: CALL_OW 235
// ComHold ( Friend ) ;
28729: LD_EXP 62
28733: PPUSH
28734: CALL_OW 140
// wait ( 0 0$20 ) ;
28738: LD_INT 700
28740: PPUSH
28741: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28745: LD_EXP 62
28749: PPUSH
28750: LD_INT 9
28752: PPUSH
28753: LD_INT 2
28755: PPUSH
28756: CALL_OW 297
28760: PUSH
28761: LD_INT 30
28763: LESS
28764: IFFALSE 28833
// begin SetSide ( Friend , 8 ) ;
28766: LD_EXP 62
28770: PPUSH
28771: LD_INT 8
28773: PPUSH
28774: CALL_OW 235
// if IsInUnit ( Friend ) then
28778: LD_EXP 62
28782: PPUSH
28783: CALL_OW 310
28787: IFFALSE 28798
// ComExitBuilding ( Friend ) ;
28789: LD_EXP 62
28793: PPUSH
28794: CALL_OW 122
// if IsDriver ( Friend ) then
28798: LD_EXP 62
28802: PPUSH
28803: CALL 100220 0 1
28807: IFFALSE 28818
// ComExitVehicle ( Friend ) ;
28809: LD_EXP 62
28813: PPUSH
28814: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28818: LD_EXP 62
28822: PPUSH
28823: LD_INT 9
28825: PPUSH
28826: LD_INT 2
28828: PPUSH
28829: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28833: LD_INT 1050
28835: PPUSH
28836: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28840: LD_INT 22
28842: PUSH
28843: LD_INT 1
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: PUSH
28850: LD_INT 34
28852: PUSH
28853: LD_INT 8
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PUSH
28860: EMPTY
28861: LIST
28862: LIST
28863: PPUSH
28864: CALL_OW 69
28868: NOT
28869: IFFALSE 29191
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28871: LD_ADDR_VAR 0 3
28875: PUSH
28876: LD_INT 22
28878: PUSH
28879: LD_INT 1
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 26
28888: PUSH
28889: LD_INT 1
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 3
28898: PUSH
28899: LD_INT 25
28901: PUSH
28902: LD_INT 12
28904: PUSH
28905: EMPTY
28906: LIST
28907: LIST
28908: PUSH
28909: LD_INT 25
28911: PUSH
28912: LD_INT 16
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: LIST
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: LIST
28928: PPUSH
28929: CALL_OW 69
28933: PUSH
28934: LD_EXP 39
28938: PUSH
28939: LD_EXP 41
28943: PUSH
28944: LD_EXP 55
28948: PUSH
28949: LD_EXP 42
28953: PUSH
28954: LD_EXP 43
28958: PUSH
28959: LD_EXP 44
28963: PUSH
28964: LD_EXP 45
28968: PUSH
28969: LD_EXP 46
28973: PUSH
28974: LD_EXP 47
28978: PUSH
28979: LD_EXP 48
28983: PUSH
28984: LD_EXP 49
28988: PUSH
28989: LD_EXP 50
28993: PUSH
28994: LD_EXP 51
28998: PUSH
28999: LD_EXP 52
29003: PUSH
29004: LD_EXP 53
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: LIST
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: DIFF
29026: ST_TO_ADDR
// DialogueOn ;
29027: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
29031: LD_EXP 64
29035: PPUSH
29036: LD_STRING D16a-Pla-1
29038: PPUSH
29039: CALL_OW 94
// if Stevens then
29043: LD_EXP 41
29047: IFFALSE 29063
// Say ( Stevens , D16a-Huck-1 ) else
29049: LD_EXP 41
29053: PPUSH
29054: LD_STRING D16a-Huck-1
29056: PPUSH
29057: CALL_OW 88
29061: GO 29105
// if Baker then
29063: LD_EXP 55
29067: IFFALSE 29083
// Say ( Baker , D16a-Huck-1 ) else
29069: LD_EXP 55
29073: PPUSH
29074: LD_STRING D16a-Huck-1
29076: PPUSH
29077: CALL_OW 88
29081: GO 29105
// if tmp then
29083: LD_VAR 0 3
29087: IFFALSE 29105
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
29089: LD_VAR 0 3
29093: PUSH
29094: LD_INT 1
29096: ARRAY
29097: PPUSH
29098: LD_STRING D16a-Sol1-1
29100: PPUSH
29101: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29105: LD_EXP 62
29109: PPUSH
29110: CALL_OW 255
29114: PUSH
29115: LD_INT 8
29117: EQUAL
29118: IFFALSE 29134
// Say ( JMM , D16a-JMM-1 ) else
29120: LD_EXP 39
29124: PPUSH
29125: LD_STRING D16a-JMM-1
29127: PPUSH
29128: CALL_OW 88
29132: GO 29170
// begin Say ( JMM , D16a-JMM-1a ) ;
29134: LD_EXP 39
29138: PPUSH
29139: LD_STRING D16a-JMM-1a
29141: PPUSH
29142: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29146: LD_EXP 62
29150: PPUSH
29151: LD_STRING D16a-Friend-1
29153: PPUSH
29154: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29158: LD_EXP 62
29162: PPUSH
29163: LD_INT 3
29165: PPUSH
29166: CALL_OW 235
// end ; DialogueOff ;
29170: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29174: LD_VAR 0 1
29178: PPUSH
29179: LD_INT 60
29181: PPUSH
29182: LD_INT 95
29184: PPUSH
29185: CALL_OW 116
// end else
29189: GO 29211
// begin DialogueOn ;
29191: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29195: LD_EXP 64
29199: PPUSH
29200: LD_STRING D16c-Pla-
29202: PPUSH
29203: CALL_OW 94
// DialogueOff ;
29207: CALL_OW 7
// end ; end else
29211: GO 29312
// begin wait ( 3 3$00 ) ;
29213: LD_INT 6300
29215: PPUSH
29216: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29220: LD_INT 22
29222: PUSH
29223: LD_INT 1
29225: PUSH
29226: EMPTY
29227: LIST
29228: LIST
29229: PUSH
29230: LD_INT 34
29232: PUSH
29233: LD_INT 8
29235: PUSH
29236: EMPTY
29237: LIST
29238: LIST
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: PPUSH
29244: CALL_OW 69
29248: NOT
29249: IFFALSE 29292
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29251: LD_EXP 64
29255: PPUSH
29256: LD_STRING D16b-Pla-1
29258: PPUSH
29259: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29263: LD_EXP 39
29267: PPUSH
29268: LD_STRING D16b-JMM-
29270: PPUSH
29271: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29275: LD_VAR 0 1
29279: PPUSH
29280: LD_INT 60
29282: PPUSH
29283: LD_INT 95
29285: PPUSH
29286: CALL_OW 116
// end else
29290: GO 29312
// begin DialogueOn ;
29292: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29296: LD_EXP 64
29300: PPUSH
29301: LD_STRING D16c-Pla-
29303: PPUSH
29304: CALL_OW 94
// DialogueOff ;
29308: CALL_OW 7
// end ; end ; end ;
29312: PPOPN 3
29314: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29315: LD_EXP 14
29319: PUSH
29320: LD_INT 126000
29322: GREATEREQUAL
29323: PUSH
29324: LD_EXP 23
29328: NOT
29329: AND
29330: PUSH
29331: LD_EXP 74
29335: PPUSH
29336: CALL_OW 302
29340: AND
29341: IFFALSE 29699
29343: GO 29345
29345: DISABLE
29346: LD_INT 0
29348: PPUSH
// begin missionStage = 11 ;
29349: LD_ADDR_EXP 15
29353: PUSH
29354: LD_INT 11
29356: ST_TO_ADDR
// DialogueOn ;
29357: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29361: LD_EXP 74
29365: PPUSH
29366: LD_STRING D9-Roth-1
29368: PPUSH
29369: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29373: LD_EXP 39
29377: PPUSH
29378: LD_STRING D9-JMM-1
29380: PPUSH
29381: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29385: LD_EXP 74
29389: PPUSH
29390: LD_STRING D9-Roth-2
29392: PPUSH
29393: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29397: LD_EXP 74
29401: PPUSH
29402: LD_STRING D9-Roth-2a
29404: PPUSH
29405: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29409: LD_EXP 64
29413: PPUSH
29414: LD_STRING D9-Pla-2
29416: PPUSH
29417: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29421: LD_EXP 74
29425: PPUSH
29426: LD_STRING D9-Roth-3
29428: PPUSH
29429: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29433: LD_EXP 64
29437: PPUSH
29438: LD_STRING D9-Pla-3
29440: PPUSH
29441: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29445: LD_EXP 74
29449: PPUSH
29450: LD_STRING D9-Roth-4
29452: PPUSH
29453: CALL_OW 94
// dec = Query ( Q9 ) ;
29457: LD_ADDR_VAR 0 1
29461: PUSH
29462: LD_STRING Q9
29464: PPUSH
29465: CALL_OW 97
29469: ST_TO_ADDR
// if dec = 1 then
29470: LD_VAR 0 1
29474: PUSH
29475: LD_INT 1
29477: EQUAL
29478: IFFALSE 29492
// SayRadio ( Roth , D9a-Roth-1 ) ;
29480: LD_EXP 74
29484: PPUSH
29485: LD_STRING D9a-Roth-1
29487: PPUSH
29488: CALL_OW 94
// if dec = 2 then
29492: LD_VAR 0 1
29496: PUSH
29497: LD_INT 2
29499: EQUAL
29500: IFFALSE 29526
// begin Say ( JMM , D9b-JMM-1 ) ;
29502: LD_EXP 39
29506: PPUSH
29507: LD_STRING D9b-JMM-1
29509: PPUSH
29510: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29514: LD_EXP 74
29518: PPUSH
29519: LD_STRING D9b-Roth-1
29521: PPUSH
29522: CALL_OW 94
// end ; if dec = 3 then
29526: LD_VAR 0 1
29530: PUSH
29531: LD_INT 3
29533: EQUAL
29534: IFFALSE 29596
// begin Say ( JMM , D9c-JMM-1 ) ;
29536: LD_EXP 39
29540: PPUSH
29541: LD_STRING D9c-JMM-1
29543: PPUSH
29544: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29548: LD_EXP 74
29552: PPUSH
29553: LD_STRING D9c-Roth-1
29555: PPUSH
29556: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29560: LD_EXP 39
29564: PPUSH
29565: LD_STRING D9c-JMM-2
29567: PPUSH
29568: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29572: LD_EXP 74
29576: PPUSH
29577: LD_STRING D9c-Roth-2
29579: PPUSH
29580: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29584: LD_EXP 39
29588: PPUSH
29589: LD_STRING D9c-JMM-3
29591: PPUSH
29592: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29596: LD_EXP 74
29600: PPUSH
29601: LD_STRING D9c-Roth-3
29603: PPUSH
29604: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29608: LD_EXP 74
29612: PPUSH
29613: LD_STRING D9cont-Roth-1
29615: PPUSH
29616: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29620: LD_EXP 39
29624: PPUSH
29625: LD_STRING D9cont-JMM-1
29627: PPUSH
29628: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29632: LD_EXP 74
29636: PPUSH
29637: LD_STRING D9cont-Roth-2
29639: PPUSH
29640: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29644: LD_EXP 39
29648: PPUSH
29649: LD_STRING D9cont-JMM-2
29651: PPUSH
29652: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29656: LD_EXP 74
29660: PPUSH
29661: LD_STRING D9cont-Roth-3
29663: PPUSH
29664: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29668: LD_EXP 39
29672: PPUSH
29673: LD_STRING D9cont-JMM-3
29675: PPUSH
29676: CALL_OW 88
// DialogueOff ;
29680: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29684: LD_STRING M3
29686: PPUSH
29687: CALL_OW 337
// allianceActive := true ;
29691: LD_ADDR_EXP 31
29695: PUSH
29696: LD_INT 1
29698: ST_TO_ADDR
// end ;
29699: PPOPN 1
29701: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29702: LD_INT 1
29704: PPUSH
29705: LD_INT 126
29707: PPUSH
29708: CALL_OW 292
29712: PUSH
29713: LD_EXP 64
29717: PPUSH
29718: CALL_OW 310
29722: AND
29723: IFFALSE 29803
29725: GO 29727
29727: DISABLE
29728: LD_INT 0
29730: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29731: LD_EXP 64
29735: PPUSH
29736: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29740: LD_ADDR_VAR 0 1
29744: PUSH
29745: LD_INT 4
29747: PPUSH
29748: LD_INT 22
29750: PUSH
29751: LD_INT 1
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 70
29762: PPUSH
29763: LD_EXP 64
29767: PPUSH
29768: CALL_OW 74
29772: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29773: LD_EXP 64
29777: PPUSH
29778: LD_VAR 0 1
29782: PUSH
29783: LD_INT 1
29785: ARRAY
29786: PPUSH
29787: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29791: LD_EXP 64
29795: PPUSH
29796: LD_STRING D18-Pla-1
29798: PPUSH
29799: CALL_OW 88
// end ;
29803: PPOPN 1
29805: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29806: LD_EXP 64
29810: PPUSH
29811: CALL_OW 301
29815: PUSH
29816: LD_EXP 67
29820: PPUSH
29821: CALL_OW 301
29825: AND
29826: PUSH
29827: LD_INT 22
29829: PUSH
29830: LD_INT 3
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: PUSH
29837: LD_INT 21
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 50
29849: PUSH
29850: EMPTY
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 69
29862: PUSH
29863: LD_INT 7
29865: PUSH
29866: LD_INT 8
29868: PUSH
29869: LD_INT 9
29871: PUSH
29872: LD_INT 10
29874: PUSH
29875: EMPTY
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: PUSH
29881: LD_OWVAR 67
29885: ARRAY
29886: LESS
29887: AND
29888: IFFALSE 30659
29890: GO 29892
29892: DISABLE
29893: LD_INT 0
29895: PPUSH
29896: PPUSH
29897: PPUSH
29898: PPUSH
// begin MC_Kill ( 2 ) ;
29899: LD_INT 2
29901: PPUSH
29902: CALL 35493 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29906: LD_INT 1
29908: PPUSH
29909: LD_INT 3
29911: PPUSH
29912: LD_INT 1
29914: PPUSH
29915: LD_INT 1
29917: PPUSH
29918: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29922: LD_ADDR_VAR 0 1
29926: PUSH
29927: LD_INT 22
29929: PUSH
29930: LD_INT 3
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: PUSH
29937: LD_INT 21
29939: PUSH
29940: LD_INT 1
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 24
29949: PUSH
29950: LD_INT 900
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: LIST
29961: PPUSH
29962: CALL_OW 69
29966: PUSH
29967: FOR_IN
29968: IFFALSE 29999
// if GetSex ( i ) = sex_male then
29970: LD_VAR 0 1
29974: PPUSH
29975: CALL_OW 258
29979: PUSH
29980: LD_INT 1
29982: EQUAL
29983: IFFALSE 29997
// begin tmp = i ;
29985: LD_ADDR_VAR 0 2
29989: PUSH
29990: LD_VAR 0 1
29994: ST_TO_ADDR
// break ;
29995: GO 29999
// end ;
29997: GO 29967
29999: POP
30000: POP
// if tmp = 0 then
30001: LD_VAR 0 2
30005: PUSH
30006: LD_INT 0
30008: EQUAL
30009: IFFALSE 30063
// begin uc_side = 3 ;
30011: LD_ADDR_OWVAR 20
30015: PUSH
30016: LD_INT 3
30018: ST_TO_ADDR
// uc_nation = 3 ;
30019: LD_ADDR_OWVAR 21
30023: PUSH
30024: LD_INT 3
30026: ST_TO_ADDR
// hc_name =  ;
30027: LD_ADDR_OWVAR 26
30031: PUSH
30032: LD_STRING 
30034: ST_TO_ADDR
// hc_gallery =  ;
30035: LD_ADDR_OWVAR 33
30039: PUSH
30040: LD_STRING 
30042: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
30043: LD_INT 1
30045: PPUSH
30046: LD_INT 10
30048: PPUSH
30049: CALL_OW 381
// tmp = CreateHuman ;
30053: LD_ADDR_VAR 0 2
30057: PUSH
30058: CALL_OW 44
30062: ST_TO_ADDR
// end ; DialogueOn ;
30063: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
30067: LD_VAR 0 2
30071: PPUSH
30072: LD_STRING DSurrenderRussians-RSol1-1a
30074: PPUSH
30075: CALL_OW 94
// DialogueOff ;
30079: CALL_OW 7
// russianDestroyed := true ;
30083: LD_ADDR_EXP 21
30087: PUSH
30088: LD_INT 1
30090: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
30091: LD_INT 22
30093: PUSH
30094: LD_INT 3
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: LD_INT 21
30103: PUSH
30104: LD_INT 1
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PPUSH
30115: CALL_OW 69
30119: PPUSH
30120: CALL_OW 122
// wait ( 0 0$1 ) ;
30124: LD_INT 35
30126: PPUSH
30127: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30131: LD_INT 22
30133: PUSH
30134: LD_INT 3
30136: PUSH
30137: EMPTY
30138: LIST
30139: LIST
30140: PUSH
30141: LD_INT 21
30143: PUSH
30144: LD_INT 1
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PPUSH
30155: CALL_OW 69
30159: PPUSH
30160: LD_INT 25
30162: PPUSH
30163: CALL_OW 173
// wait ( 0 0$10 ) ;
30167: LD_INT 350
30169: PPUSH
30170: CALL_OW 67
// PrepareOmarInvasion ;
30174: CALL 13975 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30178: LD_ADDR_VAR 0 2
30182: PUSH
30183: LD_EXP 92
30187: PPUSH
30188: CALL_OW 250
30192: PUSH
30193: LD_EXP 92
30197: PPUSH
30198: CALL_OW 251
30202: PUSH
30203: EMPTY
30204: LIST
30205: LIST
30206: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30207: LD_VAR 0 2
30211: PUSH
30212: LD_INT 1
30214: ARRAY
30215: PPUSH
30216: LD_VAR 0 2
30220: PUSH
30221: LD_INT 2
30223: ARRAY
30224: PPUSH
30225: LD_INT 1
30227: PPUSH
30228: LD_INT 8
30230: NEG
30231: PPUSH
30232: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30236: LD_EXP 92
30240: PPUSH
30241: CALL_OW 87
// DialogueOn ;
30245: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30249: LD_EXP 39
30253: PPUSH
30254: LD_STRING D19-JMM-1
30256: PPUSH
30257: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30261: LD_ADDR_VAR 0 3
30265: PUSH
30266: LD_INT 22
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 26
30278: PUSH
30279: LD_INT 1
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 2
30288: PUSH
30289: LD_INT 25
30291: PUSH
30292: LD_INT 1
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 25
30301: PUSH
30302: LD_INT 2
30304: PUSH
30305: EMPTY
30306: LIST
30307: LIST
30308: PUSH
30309: LD_INT 25
30311: PUSH
30312: LD_INT 3
30314: PUSH
30315: EMPTY
30316: LIST
30317: LIST
30318: PUSH
30319: LD_INT 25
30321: PUSH
30322: LD_INT 4
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 25
30331: PUSH
30332: LD_INT 5
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 25
30341: PUSH
30342: LD_INT 8
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: LIST
30362: PPUSH
30363: CALL_OW 69
30367: PUSH
30368: LD_EXP 39
30372: PUSH
30373: LD_EXP 40
30377: PUSH
30378: LD_EXP 41
30382: PUSH
30383: LD_EXP 42
30387: PUSH
30388: LD_EXP 43
30392: PUSH
30393: LD_EXP 44
30397: PUSH
30398: LD_EXP 45
30402: PUSH
30403: LD_EXP 46
30407: PUSH
30408: LD_EXP 47
30412: PUSH
30413: LD_EXP 48
30417: PUSH
30418: LD_EXP 49
30422: PUSH
30423: LD_EXP 50
30427: PUSH
30428: LD_EXP 51
30432: PUSH
30433: LD_EXP 52
30437: PUSH
30438: LD_EXP 53
30442: PUSH
30443: LD_EXP 54
30447: PUSH
30448: LD_EXP 55
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: LIST
30468: LIST
30469: LIST
30470: LIST
30471: DIFF
30472: ST_TO_ADDR
// if tmp2 then
30473: LD_VAR 0 3
30477: IFFALSE 30495
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30479: LD_VAR 0 3
30483: PUSH
30484: LD_INT 1
30486: ARRAY
30487: PPUSH
30488: LD_STRING D19-Sol1-1
30490: PPUSH
30491: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30495: LD_EXP 39
30499: PPUSH
30500: LD_STRING D19-JMM-2
30502: PPUSH
30503: CALL_OW 88
// DialogueOff ;
30507: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30511: LD_VAR 0 2
30515: PUSH
30516: LD_INT 1
30518: ARRAY
30519: PPUSH
30520: LD_VAR 0 2
30524: PUSH
30525: LD_INT 2
30527: ARRAY
30528: PPUSH
30529: LD_INT 1
30531: PPUSH
30532: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30536: LD_STRING M5
30538: PPUSH
30539: CALL_OW 337
// omarOnMotherLode := false ;
30543: LD_ADDR_VAR 0 4
30547: PUSH
30548: LD_INT 0
30550: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30551: LD_INT 35
30553: PPUSH
30554: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30558: LD_EXP 92
30562: PPUSH
30563: LD_INT 215
30565: PPUSH
30566: LD_INT 100
30568: PPUSH
30569: CALL_OW 297
30573: PUSH
30574: LD_INT 10
30576: LESS
30577: PUSH
30578: LD_VAR 0 4
30582: NOT
30583: AND
30584: IFFALSE 30618
// begin omarOnMotherLode := true ;
30586: LD_ADDR_VAR 0 4
30590: PUSH
30591: LD_INT 1
30593: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30594: LD_EXP 39
30598: PPUSH
30599: LD_STRING D19b-JMM-1
30601: PPUSH
30602: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30606: LD_EXP 92
30610: PPUSH
30611: LD_STRING DOmarContam-Omar-1
30613: PPUSH
30614: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30618: LD_EXP 92
30622: PPUSH
30623: CALL_OW 301
30627: IFFALSE 30551
// Say ( JMM , D19a-JMM-1 ) ;
30629: LD_EXP 39
30633: PPUSH
30634: LD_STRING D19a-JMM-1
30636: PPUSH
30637: CALL_OW 88
// if Heike then
30641: LD_EXP 93
30645: IFFALSE 30659
// Say ( Heike , D19a-Hke-1 ) ;
30647: LD_EXP 93
30651: PPUSH
30652: LD_STRING D19a-Hke-1
30654: PPUSH
30655: CALL_OW 88
// end ;
30659: PPOPN 4
30661: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30662: LD_INT 22
30664: PUSH
30665: LD_INT 3
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 21
30674: PUSH
30675: LD_INT 1
30677: PUSH
30678: EMPTY
30679: LIST
30680: LIST
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PPUSH
30686: CALL_OW 69
30690: PUSH
30691: LD_EXP 21
30695: AND
30696: IFFALSE 30764
30698: GO 30700
30700: DISABLE
30701: LD_INT 0
30703: PPUSH
30704: PPUSH
// begin enable ;
30705: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30706: LD_ADDR_VAR 0 2
30710: PUSH
30711: LD_INT 25
30713: PPUSH
30714: LD_INT 22
30716: PUSH
30717: LD_INT 3
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PPUSH
30724: CALL_OW 70
30728: ST_TO_ADDR
// if not tmp then
30729: LD_VAR 0 2
30733: NOT
30734: IFFALSE 30738
// exit ;
30736: GO 30764
// for i in tmp do
30738: LD_ADDR_VAR 0 1
30742: PUSH
30743: LD_VAR 0 2
30747: PUSH
30748: FOR_IN
30749: IFFALSE 30762
// RemoveUnit ( i ) ;
30751: LD_VAR 0 1
30755: PPUSH
30756: CALL_OW 64
30760: GO 30748
30762: POP
30763: POP
// end ;
30764: PPOPN 2
30766: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30767: LD_INT 22
30769: PUSH
30770: LD_INT 7
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 21
30779: PUSH
30780: LD_INT 1
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PPUSH
30791: CALL_OW 69
30795: PUSH
30796: LD_INT 6
30798: LESS
30799: IFFALSE 31267
30801: GO 30803
30803: DISABLE
30804: LD_INT 0
30806: PPUSH
30807: PPUSH
// begin MC_Kill ( 1 ) ;
30808: LD_INT 1
30810: PPUSH
30811: CALL 35493 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30815: LD_INT 7
30817: PPUSH
30818: LD_INT 1
30820: PPUSH
30821: LD_INT 1
30823: PPUSH
30824: LD_INT 1
30826: PPUSH
30827: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30831: LD_ADDR_VAR 0 1
30835: PUSH
30836: LD_INT 22
30838: PUSH
30839: LD_INT 7
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: LD_INT 26
30848: PUSH
30849: LD_INT 1
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PPUSH
30860: CALL_OW 69
30864: PUSH
30865: LD_EXP 74
30869: DIFF
30870: ST_TO_ADDR
// if tmp then
30871: LD_VAR 0 1
30875: IFFALSE 30893
// tmp := tmp [ 1 ] else
30877: LD_ADDR_VAR 0 1
30881: PUSH
30882: LD_VAR 0 1
30886: PUSH
30887: LD_INT 1
30889: ARRAY
30890: ST_TO_ADDR
30891: GO 30929
// begin uc_side := 7 ;
30893: LD_ADDR_OWVAR 20
30897: PUSH
30898: LD_INT 7
30900: ST_TO_ADDR
// uc_nation := 1 ;
30901: LD_ADDR_OWVAR 21
30905: PUSH
30906: LD_INT 1
30908: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30909: LD_INT 1
30911: PPUSH
30912: LD_INT 8
30914: PPUSH
30915: CALL_OW 384
// tmp := CreateHuman ;
30919: LD_ADDR_VAR 0 1
30923: PUSH
30924: CALL_OW 44
30928: ST_TO_ADDR
// end ; DialogueOn ;
30929: CALL_OW 6
// if IsOK ( Roth ) then
30933: LD_EXP 74
30937: PPUSH
30938: CALL_OW 302
30942: IFFALSE 30956
// Say ( JMM , DAb-JMM-1 ) ;
30944: LD_EXP 39
30948: PPUSH
30949: LD_STRING DAb-JMM-1
30951: PPUSH
30952: CALL_OW 88
// if IsOK ( Roth ) then
30956: LD_EXP 74
30960: PPUSH
30961: CALL_OW 302
30965: IFFALSE 30989
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30967: LD_EXP 74
30971: PPUSH
30972: LD_STRING DSurrenderAlliance-Roth-1
30974: PPUSH
30975: CALL_OW 88
// RothCaptured := true ;
30979: LD_ADDR_EXP 33
30983: PUSH
30984: LD_INT 1
30986: ST_TO_ADDR
// end else
30987: GO 31001
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30989: LD_VAR 0 1
30993: PPUSH
30994: LD_STRING DSurrenderAlliance-Sci1-1
30996: PPUSH
30997: CALL_OW 88
// DialogueOff ;
31001: CALL_OW 7
// allianceDestroyed := true ;
31005: LD_ADDR_EXP 23
31009: PUSH
31010: LD_INT 1
31012: ST_TO_ADDR
// if capturedUnit = 0 then
31013: LD_EXP 34
31017: PUSH
31018: LD_INT 0
31020: EQUAL
31021: IFFALSE 31030
// SetAchievement ( ACH_ALLIANCE ) ;
31023: LD_STRING ACH_ALLIANCE
31025: PPUSH
31026: CALL_OW 543
// if trueAmericans then
31030: LD_EXP 35
31034: IFFALSE 31110
// begin if trueAmericans = 1 then
31036: LD_EXP 35
31040: PUSH
31041: LD_INT 1
31043: EQUAL
31044: IFFALSE 31060
// Say ( JMM , DAb-JMM-1a ) else
31046: LD_EXP 39
31050: PPUSH
31051: LD_STRING DAb-JMM-1a
31053: PPUSH
31054: CALL_OW 88
31058: GO 31072
// Say ( JMM , DAb-JMM-1b ) ;
31060: LD_EXP 39
31064: PPUSH
31065: LD_STRING DAb-JMM-1b
31067: PPUSH
31068: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
31072: LD_EXP 35
31076: PPUSH
31077: CALL_OW 87
// for i in trueAmericans do
31081: LD_ADDR_VAR 0 2
31085: PUSH
31086: LD_EXP 35
31090: PUSH
31091: FOR_IN
31092: IFFALSE 31108
// SetSide ( i , 1 ) ;
31094: LD_VAR 0 2
31098: PPUSH
31099: LD_INT 1
31101: PPUSH
31102: CALL_OW 235
31106: GO 31091
31108: POP
31109: POP
// end ; repeat wait ( 0 0$1 ) ;
31110: LD_INT 35
31112: PPUSH
31113: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31117: LD_ADDR_VAR 0 2
31121: PUSH
31122: LD_INT 22
31124: PUSH
31125: LD_INT 7
31127: PUSH
31128: EMPTY
31129: LIST
31130: LIST
31131: PUSH
31132: LD_INT 21
31134: PUSH
31135: LD_INT 1
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PPUSH
31146: CALL_OW 69
31150: PUSH
31151: FOR_IN
31152: IFFALSE 31234
// begin if IsInUnit ( i ) then
31154: LD_VAR 0 2
31158: PPUSH
31159: CALL_OW 310
31163: IFFALSE 31174
// ComExitBuilding ( i ) ;
31165: LD_VAR 0 2
31169: PPUSH
31170: CALL_OW 122
// if IsDriver ( i ) then
31174: LD_VAR 0 2
31178: PPUSH
31179: CALL 100220 0 1
31183: IFFALSE 31194
// ComExitVehicle ( i ) ;
31185: LD_VAR 0 2
31189: PPUSH
31190: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31194: LD_VAR 0 2
31198: PPUSH
31199: LD_INT 26
31201: PPUSH
31202: CALL_OW 308
31206: NOT
31207: IFFALSE 31223
// AddComMoveToArea ( i , allianceEscapeArea ) else
31209: LD_VAR 0 2
31213: PPUSH
31214: LD_INT 26
31216: PPUSH
31217: CALL_OW 173
31221: GO 31232
// RemoveUnit ( i ) ;
31223: LD_VAR 0 2
31227: PPUSH
31228: CALL_OW 64
// end ;
31232: GO 31151
31234: POP
31235: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31236: LD_INT 22
31238: PUSH
31239: LD_INT 7
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: LD_INT 21
31248: PUSH
31249: LD_INT 1
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PPUSH
31260: CALL_OW 69
31264: NOT
31265: IFFALSE 31110
// end ;
31267: PPOPN 2
31269: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31270: LD_INT 0
31272: PPUSH
31273: PPUSH
// if not unit then
31274: LD_VAR 0 1
31278: NOT
31279: IFFALSE 31283
// exit ;
31281: GO 32781
// DoNotAttack ( 7 , unit ) ;
31283: LD_INT 7
31285: PPUSH
31286: LD_VAR 0 1
31290: PPUSH
31291: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31295: LD_VAR 0 1
31299: PPUSH
31300: LD_INT 260
31302: PPUSH
31303: LD_INT 235
31305: PPUSH
31306: LD_INT 3
31308: PPUSH
31309: LD_INT 1
31311: PPUSH
31312: CALL_OW 483
// SetSide ( unit , 4 ) ;
31316: LD_VAR 0 1
31320: PPUSH
31321: LD_INT 4
31323: PPUSH
31324: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31328: LD_ADDR_EXP 34
31332: PUSH
31333: LD_EXP 34
31337: PUSH
31338: LD_INT 1
31340: PLUS
31341: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31342: LD_INT 70
31344: PPUSH
31345: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31349: LD_INT 260
31351: PPUSH
31352: LD_INT 235
31354: PPUSH
31355: LD_INT 1
31357: PPUSH
31358: LD_INT 8
31360: NEG
31361: PPUSH
31362: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31366: LD_VAR 0 1
31370: PPUSH
31371: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31375: LD_VAR 0 1
31379: PPUSH
31380: LD_EXP 74
31384: PPUSH
31385: CALL_OW 119
// DialogueOn ;
31389: CALL_OW 6
// case unit of JMM :
31393: LD_VAR 0 1
31397: PUSH
31398: LD_EXP 39
31402: DOUBLE
31403: EQUAL
31404: IFTRUE 31408
31406: GO 31423
31408: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31409: LD_EXP 39
31413: PPUSH
31414: LD_STRING DA1-JMM-1
31416: PPUSH
31417: CALL_OW 91
31421: GO 31865
31423: LD_EXP 40
31427: DOUBLE
31428: EQUAL
31429: IFTRUE 31433
31431: GO 31448
31433: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31434: LD_EXP 40
31438: PPUSH
31439: LD_STRING DA1-Joan-1
31441: PPUSH
31442: CALL_OW 91
31446: GO 31865
31448: LD_EXP 42
31452: DOUBLE
31453: EQUAL
31454: IFTRUE 31458
31456: GO 31473
31458: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31459: LD_EXP 42
31463: PPUSH
31464: LD_STRING DA1-Lisa-1
31466: PPUSH
31467: CALL_OW 91
31471: GO 31865
31473: LD_EXP 43
31477: DOUBLE
31478: EQUAL
31479: IFTRUE 31483
31481: GO 31498
31483: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31484: LD_EXP 43
31488: PPUSH
31489: LD_STRING DA1-Don-1
31491: PPUSH
31492: CALL_OW 91
31496: GO 31865
31498: LD_EXP 50
31502: DOUBLE
31503: EQUAL
31504: IFTRUE 31508
31506: GO 31523
31508: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31509: LD_EXP 50
31513: PPUSH
31514: LD_STRING DA1-Corn-1
31516: PPUSH
31517: CALL_OW 91
31521: GO 31865
31523: LD_EXP 46
31527: DOUBLE
31528: EQUAL
31529: IFTRUE 31533
31531: GO 31548
31533: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31534: LD_EXP 46
31538: PPUSH
31539: LD_STRING DA1-Den-1
31541: PPUSH
31542: CALL_OW 91
31546: GO 31865
31548: LD_EXP 44
31552: DOUBLE
31553: EQUAL
31554: IFTRUE 31558
31556: GO 31573
31558: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31559: LD_EXP 44
31563: PPUSH
31564: LD_STRING DA1-Bobby-1
31566: PPUSH
31567: CALL_OW 91
31571: GO 31865
31573: LD_EXP 48
31577: DOUBLE
31578: EQUAL
31579: IFTRUE 31583
31581: GO 31598
31583: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31584: LD_EXP 48
31588: PPUSH
31589: LD_STRING DA1-Glad-1
31591: PPUSH
31592: CALL_OW 91
31596: GO 31865
31598: LD_EXP 45
31602: DOUBLE
31603: EQUAL
31604: IFTRUE 31608
31606: GO 31623
31608: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31609: LD_EXP 45
31613: PPUSH
31614: LD_STRING DA1-Cyrus-1
31616: PPUSH
31617: CALL_OW 91
31621: GO 31865
31623: LD_EXP 41
31627: DOUBLE
31628: EQUAL
31629: IFTRUE 31633
31631: GO 31648
31633: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31634: LD_EXP 41
31638: PPUSH
31639: LD_STRING DA1-Huck-1
31641: PPUSH
31642: CALL_OW 91
31646: GO 31865
31648: LD_EXP 55
31652: DOUBLE
31653: EQUAL
31654: IFTRUE 31658
31656: GO 31673
31658: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31659: LD_EXP 55
31663: PPUSH
31664: LD_STRING DA1-Huck-1
31666: PPUSH
31667: CALL_OW 91
31671: GO 31865
31673: LD_EXP 47
31677: DOUBLE
31678: EQUAL
31679: IFTRUE 31683
31681: GO 31698
31683: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31684: LD_EXP 47
31688: PPUSH
31689: LD_STRING DA1-Brown-1
31691: PPUSH
31692: CALL_OW 91
31696: GO 31865
31698: LD_EXP 51
31702: DOUBLE
31703: EQUAL
31704: IFTRUE 31708
31706: GO 31723
31708: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31709: LD_EXP 51
31713: PPUSH
31714: LD_STRING DA1-Gary-1
31716: PPUSH
31717: CALL_OW 91
31721: GO 31865
31723: LD_EXP 54
31727: DOUBLE
31728: EQUAL
31729: IFTRUE 31733
31731: GO 31748
31733: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31734: LD_EXP 54
31738: PPUSH
31739: LD_STRING DA1-Con-1
31741: PPUSH
31742: CALL_OW 91
31746: GO 31865
31748: LD_EXP 60
31752: DOUBLE
31753: EQUAL
31754: IFTRUE 31758
31756: GO 31773
31758: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31759: LD_EXP 60
31763: PPUSH
31764: LD_STRING DA1-Kurt-1
31766: PPUSH
31767: CALL_OW 91
31771: GO 31865
31773: LD_EXP 53
31777: DOUBLE
31778: EQUAL
31779: IFTRUE 31783
31781: GO 31798
31783: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31784: LD_EXP 53
31788: PPUSH
31789: LD_STRING DA1-Yam-1
31791: PPUSH
31792: CALL_OW 91
31796: GO 31865
31798: LD_EXP 52
31802: DOUBLE
31803: EQUAL
31804: IFTRUE 31808
31806: GO 31823
31808: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31809: LD_EXP 52
31813: PPUSH
31814: LD_STRING DA1-Frank-1
31816: PPUSH
31817: CALL_OW 91
31821: GO 31865
31823: POP
// begin if GetSex ( unit ) = sex_male then
31824: LD_VAR 0 1
31828: PPUSH
31829: CALL_OW 258
31833: PUSH
31834: LD_INT 1
31836: EQUAL
31837: IFFALSE 31853
// ForceSay ( unit , DA1-Sol1-1 ) else
31839: LD_VAR 0 1
31843: PPUSH
31844: LD_STRING DA1-Sol1-1
31846: PPUSH
31847: CALL_OW 91
31851: GO 31865
// ForceSay ( unit , DA1-FSol1-1 ) ;
31853: LD_VAR 0 1
31857: PPUSH
31858: LD_STRING DA1-FSol1-1
31860: PPUSH
31861: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31865: LD_EXP 74
31869: PPUSH
31870: LD_STRING DA-Roth-1
31872: PPUSH
31873: CALL_OW 88
// if capturedUnit = 1 then
31877: LD_EXP 34
31881: PUSH
31882: LD_INT 1
31884: EQUAL
31885: IFFALSE 31913
// begin Say ( Simms , DA-Sim-1 ) ;
31887: LD_EXP 75
31891: PPUSH
31892: LD_STRING DA-Sim-1
31894: PPUSH
31895: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31899: LD_EXP 74
31903: PPUSH
31904: LD_STRING DA-Roth-2
31906: PPUSH
31907: CALL_OW 88
// end else
31911: GO 31925
// Say ( Simms , DA-Sim-2 ) ;
31913: LD_EXP 75
31917: PPUSH
31918: LD_STRING DA-Sim-2
31920: PPUSH
31921: CALL_OW 88
// case unit of JMM :
31925: LD_VAR 0 1
31929: PUSH
31930: LD_EXP 39
31934: DOUBLE
31935: EQUAL
31936: IFTRUE 31940
31938: GO 31955
31940: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31941: LD_EXP 39
31945: PPUSH
31946: LD_STRING DA1-JMM-1a
31948: PPUSH
31949: CALL_OW 91
31953: GO 32462
31955: LD_EXP 40
31959: DOUBLE
31960: EQUAL
31961: IFTRUE 31965
31963: GO 31980
31965: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31966: LD_EXP 40
31970: PPUSH
31971: LD_STRING DA1-Joan-1a
31973: PPUSH
31974: CALL_OW 91
31978: GO 32462
31980: LD_EXP 42
31984: DOUBLE
31985: EQUAL
31986: IFTRUE 31990
31988: GO 32005
31990: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31991: LD_EXP 42
31995: PPUSH
31996: LD_STRING DA1-Lisa-1a
31998: PPUSH
31999: CALL_OW 91
32003: GO 32462
32005: LD_EXP 43
32009: DOUBLE
32010: EQUAL
32011: IFTRUE 32015
32013: GO 32030
32015: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
32016: LD_EXP 43
32020: PPUSH
32021: LD_STRING DA1-Don-1a
32023: PPUSH
32024: CALL_OW 91
32028: GO 32462
32030: LD_EXP 50
32034: DOUBLE
32035: EQUAL
32036: IFTRUE 32040
32038: GO 32055
32040: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
32041: LD_EXP 50
32045: PPUSH
32046: LD_STRING DA1-Corn-1a
32048: PPUSH
32049: CALL_OW 91
32053: GO 32462
32055: LD_EXP 46
32059: DOUBLE
32060: EQUAL
32061: IFTRUE 32065
32063: GO 32080
32065: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
32066: LD_EXP 46
32070: PPUSH
32071: LD_STRING DA1-Den-1a
32073: PPUSH
32074: CALL_OW 91
32078: GO 32462
32080: LD_EXP 44
32084: DOUBLE
32085: EQUAL
32086: IFTRUE 32090
32088: GO 32105
32090: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
32091: LD_EXP 44
32095: PPUSH
32096: LD_STRING DA1-Bobby-1a
32098: PPUSH
32099: CALL_OW 91
32103: GO 32462
32105: LD_EXP 48
32109: DOUBLE
32110: EQUAL
32111: IFTRUE 32115
32113: GO 32130
32115: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32116: LD_EXP 48
32120: PPUSH
32121: LD_STRING DA1-Glad-1a
32123: PPUSH
32124: CALL_OW 91
32128: GO 32462
32130: LD_EXP 45
32134: DOUBLE
32135: EQUAL
32136: IFTRUE 32140
32138: GO 32155
32140: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32141: LD_EXP 45
32145: PPUSH
32146: LD_STRING DA1-Cyrus-1a
32148: PPUSH
32149: CALL_OW 91
32153: GO 32462
32155: LD_EXP 41
32159: DOUBLE
32160: EQUAL
32161: IFTRUE 32165
32163: GO 32180
32165: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32166: LD_EXP 41
32170: PPUSH
32171: LD_STRING DA1-Huck-1a
32173: PPUSH
32174: CALL_OW 91
32178: GO 32462
32180: LD_EXP 55
32184: DOUBLE
32185: EQUAL
32186: IFTRUE 32190
32188: GO 32205
32190: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32191: LD_EXP 55
32195: PPUSH
32196: LD_STRING DA1-Huck-1a
32198: PPUSH
32199: CALL_OW 91
32203: GO 32462
32205: LD_EXP 47
32209: DOUBLE
32210: EQUAL
32211: IFTRUE 32215
32213: GO 32230
32215: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32216: LD_EXP 47
32220: PPUSH
32221: LD_STRING DA1-Brown-1a
32223: PPUSH
32224: CALL_OW 91
32228: GO 32462
32230: LD_EXP 51
32234: DOUBLE
32235: EQUAL
32236: IFTRUE 32240
32238: GO 32255
32240: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32241: LD_EXP 51
32245: PPUSH
32246: LD_STRING DA1-Gary-1a
32248: PPUSH
32249: CALL_OW 91
32253: GO 32462
32255: LD_EXP 54
32259: DOUBLE
32260: EQUAL
32261: IFTRUE 32265
32263: GO 32280
32265: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32266: LD_EXP 54
32270: PPUSH
32271: LD_STRING DA1-Con-1a
32273: PPUSH
32274: CALL_OW 91
32278: GO 32462
32280: LD_EXP 60
32284: DOUBLE
32285: EQUAL
32286: IFTRUE 32290
32288: GO 32305
32290: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32291: LD_EXP 60
32295: PPUSH
32296: LD_STRING DA1-Kurt-1a
32298: PPUSH
32299: CALL_OW 91
32303: GO 32462
32305: LD_EXP 53
32309: DOUBLE
32310: EQUAL
32311: IFTRUE 32315
32313: GO 32330
32315: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32316: LD_EXP 53
32320: PPUSH
32321: LD_STRING DA1-Yam-1a
32323: PPUSH
32324: CALL_OW 91
32328: GO 32462
32330: LD_EXP 52
32334: DOUBLE
32335: EQUAL
32336: IFTRUE 32340
32338: GO 32355
32340: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32341: LD_EXP 52
32345: PPUSH
32346: LD_STRING DA1-Frank-1a
32348: PPUSH
32349: CALL_OW 91
32353: GO 32462
32355: POP
// begin join := rand ( 0 , 1 ) ;
32356: LD_ADDR_VAR 0 3
32360: PUSH
32361: LD_INT 0
32363: PPUSH
32364: LD_INT 1
32366: PPUSH
32367: CALL_OW 12
32371: ST_TO_ADDR
// if join then
32372: LD_VAR 0 3
32376: IFFALSE 32421
// begin if GetSex ( unit ) = sex_male then
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 258
32387: PUSH
32388: LD_INT 1
32390: EQUAL
32391: IFFALSE 32407
// ForceSay ( unit , DA1-Sol1-1b ) else
32393: LD_VAR 0 1
32397: PPUSH
32398: LD_STRING DA1-Sol1-1b
32400: PPUSH
32401: CALL_OW 91
32405: GO 32419
// ForceSay ( unit , DA1-FSol1-1b ) ;
32407: LD_VAR 0 1
32411: PPUSH
32412: LD_STRING DA1-FSol1-1b
32414: PPUSH
32415: CALL_OW 91
// end else
32419: GO 32462
// begin if GetSex ( unit ) = sex_male then
32421: LD_VAR 0 1
32425: PPUSH
32426: CALL_OW 258
32430: PUSH
32431: LD_INT 1
32433: EQUAL
32434: IFFALSE 32450
// ForceSay ( unit , DA1-Sol1-1a ) else
32436: LD_VAR 0 1
32440: PPUSH
32441: LD_STRING DA1-Sol1-1a
32443: PPUSH
32444: CALL_OW 91
32448: GO 32462
// ForceSay ( unit , DA1-FSol1-1a ) ;
32450: LD_VAR 0 1
32454: PPUSH
32455: LD_STRING DA1-FSol1-1a
32457: PPUSH
32458: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32462: LD_VAR 0 1
32466: PUSH
32467: LD_EXP 39
32471: EQUAL
32472: IFFALSE 32483
// begin YouLost ( JMMCaptured ) ;
32474: LD_STRING JMMCaptured
32476: PPUSH
32477: CALL_OW 104
// exit ;
32481: GO 32781
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32483: LD_VAR 0 1
32487: PUSH
32488: LD_EXP 43
32492: PUSH
32493: LD_EXP 46
32497: PUSH
32498: LD_EXP 44
32502: PUSH
32503: LD_EXP 41
32507: PUSH
32508: LD_EXP 55
32512: PUSH
32513: LD_EXP 47
32517: PUSH
32518: LD_EXP 53
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: IN
32532: PUSH
32533: LD_VAR 0 3
32537: OR
32538: IFFALSE 32637
// begin Say ( Roth , DA-Roth-3 ) ;
32540: LD_EXP 74
32544: PPUSH
32545: LD_STRING DA-Roth-3
32547: PPUSH
32548: CALL_OW 88
// SetSide ( unit , 7 ) ;
32552: LD_VAR 0 1
32556: PPUSH
32557: LD_INT 7
32559: PPUSH
32560: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32564: LD_ADDR_EXP 116
32568: PUSH
32569: LD_EXP 116
32573: PPUSH
32574: LD_INT 1
32576: PPUSH
32577: LD_EXP 116
32581: PUSH
32582: LD_INT 1
32584: ARRAY
32585: PUSH
32586: LD_VAR 0 1
32590: ADD
32591: PPUSH
32592: CALL_OW 1
32596: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32597: LD_INT 260
32599: PPUSH
32600: LD_INT 235
32602: PPUSH
32603: LD_INT 1
32605: PPUSH
32606: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32610: LD_VAR 0 1
32614: PPUSH
32615: LD_INT 1000
32617: PPUSH
32618: CALL_OW 234
// DialogueOff ;
32622: CALL_OW 7
// ComFree ( unit ) ;
32626: LD_VAR 0 1
32630: PPUSH
32631: CALL_OW 139
// end else
32635: GO 32718
// begin Say ( Roth , DA-Roth-3a ) ;
32637: LD_EXP 74
32641: PPUSH
32642: LD_STRING DA-Roth-3a
32644: PPUSH
32645: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32649: LD_ADDR_EXP 35
32653: PUSH
32654: LD_EXP 35
32658: PUSH
32659: LD_VAR 0 1
32663: ADD
32664: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32665: LD_INT 260
32667: PPUSH
32668: LD_INT 235
32670: PPUSH
32671: LD_INT 1
32673: PPUSH
32674: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32678: LD_VAR 0 1
32682: PPUSH
32683: LD_INT 1000
32685: PPUSH
32686: CALL_OW 234
// DialogueOff ;
32690: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32694: LD_VAR 0 1
32698: PPUSH
32699: LD_INT 272
32701: PPUSH
32702: LD_INT 254
32704: PPUSH
32705: CALL_OW 111
// AddComHold ( unit ) ;
32709: LD_VAR 0 1
32713: PPUSH
32714: CALL_OW 200
// end ; if capturedUnit = 1 then
32718: LD_EXP 34
32722: PUSH
32723: LD_INT 1
32725: EQUAL
32726: IFFALSE 32781
// begin DialogueOn ;
32728: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32732: LD_EXP 39
32736: PPUSH
32737: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32741: LD_EXP 39
32745: PPUSH
32746: LD_STRING DAa-JMM-1
32748: PPUSH
32749: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32753: LD_EXP 39
32757: PPUSH
32758: LD_STRING DAa-JMM-1a
32760: PPUSH
32761: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32765: LD_EXP 39
32769: PPUSH
32770: LD_STRING DAa-JMM-1b
32772: PPUSH
32773: CALL_OW 88
// DialogueOff ;
32777: CALL_OW 7
// end ; end ;
32781: LD_VAR 0 2
32785: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32786: LD_EXP 15
32790: PUSH
32791: LD_INT 13
32793: GREATEREQUAL
32794: PUSH
32795: LD_INT 22
32797: PUSH
32798: LD_INT 2
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: PUSH
32805: LD_INT 21
32807: PUSH
32808: LD_INT 1
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PPUSH
32819: CALL_OW 69
32823: PUSH
32824: LD_INT 0
32826: EQUAL
32827: AND
32828: PUSH
32829: LD_INT 22
32831: PUSH
32832: LD_INT 2
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 33
32841: PUSH
32842: LD_INT 5
32844: PUSH
32845: EMPTY
32846: LIST
32847: LIST
32848: PUSH
32849: LD_INT 21
32851: PUSH
32852: LD_INT 2
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 50
32861: PUSH
32862: EMPTY
32863: LIST
32864: PUSH
32865: EMPTY
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: PPUSH
32871: CALL_OW 69
32875: PUSH
32876: LD_INT 0
32878: EQUAL
32879: AND
32880: PUSH
32881: LD_EXP 21
32885: AND
32886: PUSH
32887: LD_EXP 22
32891: AND
32892: PUSH
32893: LD_EXP 23
32897: AND
32898: IFFALSE 33547
32900: GO 32902
32902: DISABLE
32903: LD_INT 0
32905: PPUSH
32906: PPUSH
32907: PPUSH
// begin m1 := false ;
32908: LD_ADDR_VAR 0 1
32912: PUSH
32913: LD_INT 0
32915: ST_TO_ADDR
// m2 := false ;
32916: LD_ADDR_VAR 0 2
32920: PUSH
32921: LD_INT 0
32923: ST_TO_ADDR
// m3 := false ;
32924: LD_ADDR_VAR 0 3
32928: PUSH
32929: LD_INT 0
32931: ST_TO_ADDR
// if not bombExploded then
32932: LD_EXP 37
32936: NOT
32937: IFFALSE 32946
// SetAchievement ( ACH_SIBROCKET ) ;
32939: LD_STRING ACH_SIBROCKET
32941: PPUSH
32942: CALL_OW 543
// if tick <= 120 120$00 then
32946: LD_OWVAR 1
32950: PUSH
32951: LD_INT 252000
32953: LESSEQUAL
32954: IFFALSE 32970
// begin wait ( 3 ) ;
32956: LD_INT 3
32958: PPUSH
32959: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32963: LD_STRING ACH_ASPEED_15
32965: PPUSH
32966: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32970: LD_EXP 39
32974: PPUSH
32975: CALL_OW 87
// music_class := 5 ;
32979: LD_ADDR_OWVAR 72
32983: PUSH
32984: LD_INT 5
32986: ST_TO_ADDR
// music_nat := 5 ;
32987: LD_ADDR_OWVAR 71
32991: PUSH
32992: LD_INT 5
32994: ST_TO_ADDR
// DialogueOn ;
32995: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32999: LD_EXP 39
33003: PPUSH
33004: LD_STRING D20-JMM-1
33006: PPUSH
33007: CALL_OW 88
// if IsOK ( Joan ) then
33011: LD_EXP 40
33015: PPUSH
33016: CALL_OW 302
33020: IFFALSE 33034
// Say ( Joan , D20-Joan-1 ) ;
33022: LD_EXP 40
33026: PPUSH
33027: LD_STRING D20-Joan-1
33029: PPUSH
33030: CALL_OW 88
// if IsOk ( Lisa ) then
33034: LD_EXP 42
33038: PPUSH
33039: CALL_OW 302
33043: IFFALSE 33057
// Say ( Lisa , D20-Lisa-1 ) ;
33045: LD_EXP 42
33049: PPUSH
33050: LD_STRING D20-Lisa-1
33052: PPUSH
33053: CALL_OW 88
// if IsOk ( Donaldson ) then
33057: LD_EXP 43
33061: PPUSH
33062: CALL_OW 302
33066: IFFALSE 33080
// Say ( Donaldson , D20-Don-1 ) ;
33068: LD_EXP 43
33072: PPUSH
33073: LD_STRING D20-Don-1
33075: PPUSH
33076: CALL_OW 88
// if IsOK ( Cornel ) then
33080: LD_EXP 50
33084: PPUSH
33085: CALL_OW 302
33089: IFFALSE 33103
// Say ( Cornel , D20-Corn-1 ) ;
33091: LD_EXP 50
33095: PPUSH
33096: LD_STRING D20-Corn-1
33098: PPUSH
33099: CALL_OW 88
// if IsOk ( Denis ) then
33103: LD_EXP 46
33107: PPUSH
33108: CALL_OW 302
33112: IFFALSE 33126
// Say ( Denis , D20-Den-1 ) ;
33114: LD_EXP 46
33118: PPUSH
33119: LD_STRING D20-Den-1
33121: PPUSH
33122: CALL_OW 88
// if IsOk ( Bobby ) then
33126: LD_EXP 44
33130: PPUSH
33131: CALL_OW 302
33135: IFFALSE 33149
// Say ( Bobby , D20-Bobby-1 ) ;
33137: LD_EXP 44
33141: PPUSH
33142: LD_STRING D20-Bobby-1
33144: PPUSH
33145: CALL_OW 88
// if IsOk ( Gladstone ) then
33149: LD_EXP 48
33153: PPUSH
33154: CALL_OW 302
33158: IFFALSE 33172
// Say ( Gladstone , D20-Glad-1 ) ;
33160: LD_EXP 48
33164: PPUSH
33165: LD_STRING D20-Glad-1
33167: PPUSH
33168: CALL_OW 88
// if IsOk ( Cyrus ) then
33172: LD_EXP 45
33176: PPUSH
33177: CALL_OW 302
33181: IFFALSE 33195
// Say ( Cyrus , D20-Cyrus-1 ) ;
33183: LD_EXP 45
33187: PPUSH
33188: LD_STRING D20-Cyrus-1
33190: PPUSH
33191: CALL_OW 88
// if IsOk ( Stevens ) then
33195: LD_EXP 41
33199: PPUSH
33200: CALL_OW 302
33204: IFFALSE 33218
// Say ( Stevens , D20-Huck-1 ) ;
33206: LD_EXP 41
33210: PPUSH
33211: LD_STRING D20-Huck-1
33213: PPUSH
33214: CALL_OW 88
// if IsOk ( Brown ) then
33218: LD_EXP 47
33222: PPUSH
33223: CALL_OW 302
33227: IFFALSE 33241
// Say ( Brown , D20-Brown-1 ) ;
33229: LD_EXP 47
33233: PPUSH
33234: LD_STRING D20-Brown-1
33236: PPUSH
33237: CALL_OW 88
// if IsOk ( Gary ) then
33241: LD_EXP 51
33245: PPUSH
33246: CALL_OW 302
33250: IFFALSE 33264
// Say ( Gary , D20-Gary-1 ) ;
33252: LD_EXP 51
33256: PPUSH
33257: LD_STRING D20-Gary-1
33259: PPUSH
33260: CALL_OW 88
// if IsOk ( Connie ) then
33264: LD_EXP 54
33268: PPUSH
33269: CALL_OW 302
33273: IFFALSE 33287
// Say ( Connie , D20-Con-1 ) ;
33275: LD_EXP 54
33279: PPUSH
33280: LD_STRING D20-Con-1
33282: PPUSH
33283: CALL_OW 88
// if IsOk ( Kurt ) then
33287: LD_EXP 60
33291: PPUSH
33292: CALL_OW 302
33296: IFFALSE 33310
// Say ( Kurt , D20-Kurt-1 ) ;
33298: LD_EXP 60
33302: PPUSH
33303: LD_STRING D20-Kurt-1
33305: PPUSH
33306: CALL_OW 88
// if IsOk ( Kikuchi ) then
33310: LD_EXP 53
33314: PPUSH
33315: CALL_OW 302
33319: IFFALSE 33333
// Say ( Kikuchi , D20-Yam-1 ) ;
33321: LD_EXP 53
33325: PPUSH
33326: LD_STRING D20-Yam-1
33328: PPUSH
33329: CALL_OW 88
// if IsOk ( Frank ) then
33333: LD_EXP 52
33337: PPUSH
33338: CALL_OW 302
33342: IFFALSE 33356
// Say ( Frank , D20-Frank-1 ) ;
33344: LD_EXP 52
33348: PPUSH
33349: LD_STRING D20-Frank-1
33351: PPUSH
33352: CALL_OW 88
// DialogueOff ;
33356: CALL_OW 7
// if RothCaptured then
33360: LD_EXP 33
33364: IFFALSE 33386
// begin m1 := true ;
33366: LD_ADDR_VAR 0 1
33370: PUSH
33371: LD_INT 1
33373: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33374: LD_STRING Roth
33376: PPUSH
33377: LD_INT 1
33379: PPUSH
33380: CALL_OW 101
// end else
33384: GO 33397
// AddMedal ( Roth , - 1 ) ;
33386: LD_STRING Roth
33388: PPUSH
33389: LD_INT 1
33391: NEG
33392: PPUSH
33393: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33397: LD_EXP 25
33401: NOT
33402: PUSH
33403: LD_EXP 27
33407: OR
33408: IFFALSE 33430
// begin m2 := true ;
33410: LD_ADDR_VAR 0 2
33414: PUSH
33415: LD_INT 1
33417: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33418: LD_STRING Project
33420: PPUSH
33421: LD_INT 1
33423: PPUSH
33424: CALL_OW 101
// end else
33428: GO 33441
// AddMedal ( Project , - 1 ) ;
33430: LD_STRING Project
33432: PPUSH
33433: LD_INT 1
33435: NEG
33436: PPUSH
33437: CALL_OW 101
// if lostCounter = 0 then
33441: LD_EXP 32
33445: PUSH
33446: LD_INT 0
33448: EQUAL
33449: IFFALSE 33471
// begin m3 := true ;
33451: LD_ADDR_VAR 0 3
33455: PUSH
33456: LD_INT 1
33458: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33459: LD_STRING NoLosses
33461: PPUSH
33462: LD_INT 1
33464: PPUSH
33465: CALL_OW 101
// end else
33469: GO 33482
// AddMedal ( NoLosses , - 1 ) ;
33471: LD_STRING NoLosses
33473: PPUSH
33474: LD_INT 1
33476: NEG
33477: PPUSH
33478: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
33482: LD_VAR 0 1
33486: PUSH
33487: LD_VAR 0 2
33491: AND
33492: PUSH
33493: LD_VAR 0 3
33497: AND
33498: PUSH
33499: LD_OWVAR 67
33503: PUSH
33504: LD_INT 3
33506: GREATEREQUAL
33507: AND
33508: IFFALSE 33520
// SetAchievementEX ( ACH_AMER , 15 ) ;
33510: LD_STRING ACH_AMER
33512: PPUSH
33513: LD_INT 15
33515: PPUSH
33516: CALL_OW 564
// GiveMedals ( MAIN ) ;
33520: LD_STRING MAIN
33522: PPUSH
33523: CALL_OW 102
// music_class := 4 ;
33527: LD_ADDR_OWVAR 72
33531: PUSH
33532: LD_INT 4
33534: ST_TO_ADDR
// music_nat := 1 ;
33535: LD_ADDR_OWVAR 71
33539: PUSH
33540: LD_INT 1
33542: ST_TO_ADDR
// YouWin ;
33543: CALL_OW 103
// end ; end_of_file
33547: PPOPN 3
33549: END
// export function CustomEvent ( event ) ; begin
33550: LD_INT 0
33552: PPUSH
// end ;
33553: LD_VAR 0 2
33557: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33558: LD_VAR 0 1
33562: PUSH
33563: LD_INT 1
33565: EQUAL
33566: PUSH
33567: LD_VAR 0 2
33571: PUSH
33572: LD_INT 4
33574: EQUAL
33575: AND
33576: PUSH
33577: LD_EXP 58
33581: PPUSH
33582: CALL_OW 300
33586: AND
33587: IFFALSE 33603
// begin wait ( 0 0$2 ) ;
33589: LD_INT 70
33591: PPUSH
33592: CALL_OW 67
// YouLost ( Dismissed ) ;
33596: LD_STRING Dismissed
33598: PPUSH
33599: CALL_OW 104
// end ; end ;
33603: PPOPN 2
33605: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33606: LD_VAR 0 2
33610: PPUSH
33611: LD_VAR 0 3
33615: PPUSH
33616: LD_INT 18
33618: PPUSH
33619: CALL_OW 309
33623: IFFALSE 33632
// YouLost ( Motherlode3 ) ;
33625: LD_STRING Motherlode3
33627: PPUSH
33628: CALL_OW 104
// end ;
33632: PPOPN 3
33634: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33635: LD_EXP 27
33639: NOT
33640: IFFALSE 33650
// behemothDone := true ;
33642: LD_ADDR_EXP 28
33646: PUSH
33647: LD_INT 1
33649: ST_TO_ADDR
// end ;
33650: PPOPN 1
33652: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33653: LD_VAR 0 1
33657: PPUSH
33658: CALL_OW 255
33662: PUSH
33663: LD_INT 1
33665: EQUAL
33666: IFFALSE 33676
// bombExploded := true ;
33668: LD_ADDR_EXP 37
33672: PUSH
33673: LD_INT 1
33675: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33676: LD_VAR 0 1
33680: PPUSH
33681: CALL_OW 255
33685: PUSH
33686: LD_INT 1
33688: EQUAL
33689: PUSH
33690: LD_EXP 30
33694: AND
33695: PUSH
33696: LD_INT 22
33698: PUSH
33699: LD_INT 3
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 34
33708: PUSH
33709: LD_INT 48
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PPUSH
33720: CALL_OW 69
33724: AND
33725: PUSH
33726: LD_INT 22
33728: PUSH
33729: LD_INT 1
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 34
33738: PUSH
33739: LD_INT 8
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PPUSH
33750: CALL_OW 69
33754: NOT
33755: AND
33756: IFFALSE 33808
// begin wait ( 0 0$5 ) ;
33758: LD_INT 175
33760: PPUSH
33761: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33765: LD_INT 22
33767: PUSH
33768: LD_INT 3
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 34
33777: PUSH
33778: LD_INT 48
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PPUSH
33789: CALL_OW 69
33793: PUSH
33794: LD_INT 1
33796: ARRAY
33797: PPUSH
33798: LD_INT 60
33800: PPUSH
33801: LD_INT 95
33803: PPUSH
33804: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33808: LD_VAR 0 2
33812: PPUSH
33813: LD_VAR 0 3
33817: PPUSH
33818: LD_INT 18
33820: PPUSH
33821: CALL_OW 309
33825: IFFALSE 33872
// begin if GetSide ( unit ) = 1 then
33827: LD_VAR 0 1
33831: PPUSH
33832: CALL_OW 255
33836: PUSH
33837: LD_INT 1
33839: EQUAL
33840: IFFALSE 33858
// begin wait ( 0 0$6 ) ;
33842: LD_INT 210
33844: PPUSH
33845: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33849: LD_STRING Motherlode2
33851: PPUSH
33852: CALL_OW 104
// end else
33856: GO 33872
// begin wait ( 0 0$6 ) ;
33858: LD_INT 210
33860: PPUSH
33861: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33865: LD_STRING Motherlode1
33867: PPUSH
33868: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33872: LD_VAR 0 1
33876: PPUSH
33877: CALL_OW 255
33881: PUSH
33882: LD_INT 3
33884: EQUAL
33885: IFFALSE 33906
// begin wait ( 0 0$5 ) ;
33887: LD_INT 175
33889: PPUSH
33890: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33894: LD_EXP 64
33898: PPUSH
33899: LD_STRING D18-Pla-1
33901: PPUSH
33902: CALL_OW 94
// end ; end ;
33906: PPOPN 3
33908: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33909: LD_VAR 0 1
33913: PUSH
33914: LD_INT 22
33916: PUSH
33917: LD_INT 1
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 21
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: PUSH
33934: LD_INT 23
33936: PUSH
33937: LD_INT 1
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: LIST
33948: PPUSH
33949: CALL_OW 69
33953: IN
33954: IFFALSE 33970
// lostCounter := lostCounter + 1 ;
33956: LD_ADDR_EXP 32
33960: PUSH
33961: LD_EXP 32
33965: PUSH
33966: LD_INT 1
33968: PLUS
33969: ST_TO_ADDR
// if un in behemothBuilders then
33970: LD_VAR 0 1
33974: PUSH
33975: LD_EXP 73
33979: IN
33980: IFFALSE 34000
// begin behemothBuilders := behemothBuilders diff un ;
33982: LD_ADDR_EXP 73
33986: PUSH
33987: LD_EXP 73
33991: PUSH
33992: LD_VAR 0 1
33996: DIFF
33997: ST_TO_ADDR
// exit ;
33998: GO 34030
// end ; if un = JMM then
34000: LD_VAR 0 1
34004: PUSH
34005: LD_EXP 39
34009: EQUAL
34010: IFFALSE 34021
// begin YouLost ( JMM ) ;
34012: LD_STRING JMM
34014: PPUSH
34015: CALL_OW 104
// exit ;
34019: GO 34030
// end ; MCE_UnitDestroyed ( un ) ;
34021: LD_VAR 0 1
34025: PPUSH
34026: CALL 62891 0 1
// end ;
34030: PPOPN 1
34032: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
34033: LD_VAR 0 1
34037: PPUSH
34038: LD_VAR 0 2
34042: PPUSH
34043: CALL 65225 0 2
// end ;
34047: PPOPN 2
34049: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
34050: LD_VAR 0 1
34054: PPUSH
34055: CALL 64293 0 1
// end ;
34059: PPOPN 1
34061: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
34062: LD_VAR 0 1
34066: PUSH
34067: LD_INT 22
34069: PUSH
34070: LD_INT 8
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 30
34079: PUSH
34080: LD_INT 2
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 23
34089: PUSH
34090: LD_INT 3
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: LIST
34101: PPUSH
34102: CALL_OW 69
34106: IN
34107: IFFALSE 34134
// begin ComUpgrade ( building ) ;
34109: LD_VAR 0 1
34113: PPUSH
34114: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34118: LD_EXP 61
34122: PPUSH
34123: LD_VAR 0 1
34127: PPUSH
34128: CALL 73726 0 2
// exit ;
34132: GO 34143
// end ; MCE_BuildingComplete ( building ) ;
34134: LD_VAR 0 1
34138: PPUSH
34139: CALL 64534 0 1
// end ;
34143: PPOPN 1
34145: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34146: LD_VAR 0 1
34150: PPUSH
34151: LD_VAR 0 2
34155: PPUSH
34156: CALL 62587 0 2
// end ;
34160: PPOPN 2
34162: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34163: LD_VAR 0 1
34167: PPUSH
34168: LD_VAR 0 2
34172: PPUSH
34173: LD_VAR 0 3
34177: PPUSH
34178: LD_VAR 0 4
34182: PPUSH
34183: LD_VAR 0 5
34187: PPUSH
34188: CALL 62207 0 5
// end ;
34192: PPOPN 5
34194: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34195: LD_VAR 0 1
34199: PPUSH
34200: LD_VAR 0 2
34204: PPUSH
34205: CALL 61788 0 2
// end ;
34209: PPOPN 2
34211: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34212: LD_VAR 0 1
34216: PPUSH
34217: LD_VAR 0 2
34221: PPUSH
34222: LD_VAR 0 3
34226: PPUSH
34227: LD_VAR 0 4
34231: PPUSH
34232: CALL 61626 0 4
// end ;
34236: PPOPN 4
34238: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34239: LD_VAR 0 1
34243: PPUSH
34244: LD_VAR 0 2
34248: PPUSH
34249: LD_VAR 0 3
34253: PPUSH
34254: CALL 61401 0 3
// end ;
34258: PPOPN 3
34260: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34261: LD_VAR 0 1
34265: PPUSH
34266: LD_VAR 0 2
34270: PPUSH
34271: CALL 61286 0 2
// end ;
34275: PPOPN 2
34277: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34278: LD_VAR 0 1
34282: PPUSH
34283: LD_VAR 0 2
34287: PPUSH
34288: CALL 65520 0 2
// end ;
34292: PPOPN 2
34294: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34295: LD_VAR 0 1
34299: PPUSH
34300: CALL_OW 255
34304: PUSH
34305: LD_INT 4
34307: EQUAL
34308: PUSH
34309: LD_VAR 0 1
34313: PUSH
34314: LD_EXP 18
34318: PUSH
34319: LD_INT 1
34321: ARRAY
34322: IN
34323: AND
34324: PUSH
34325: LD_EXP 19
34329: AND
34330: IFFALSE 34349
// begin ComMoveXY ( driver , 61 , 93 ) ;
34332: LD_VAR 0 1
34336: PPUSH
34337: LD_INT 61
34339: PPUSH
34340: LD_INT 93
34342: PPUSH
34343: CALL_OW 111
// exit ;
34347: GO 34373
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34349: LD_VAR 0 1
34353: PPUSH
34354: LD_VAR 0 2
34358: PPUSH
34359: LD_VAR 0 3
34363: PPUSH
34364: LD_VAR 0 4
34368: PPUSH
34369: CALL 65736 0 4
// end ;
34373: PPOPN 4
34375: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34376: LD_VAR 0 1
34380: PPUSH
34381: LD_VAR 0 2
34385: PPUSH
34386: CALL 61095 0 2
// end ;
34390: PPOPN 2
34392: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34393: LD_VAR 0 1
34397: PPUSH
34398: CALL 118710 0 1
// end ; end_of_file
34402: PPOPN 1
34404: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34405: LD_EXP 15
34409: PUSH
34410: LD_INT 2
34412: EQUAL
34413: IFFALSE 34896
34415: GO 34417
34417: DISABLE
34418: LD_INT 0
34420: PPUSH
// begin time := 0 0$40 ;
34421: LD_ADDR_VAR 0 1
34425: PUSH
34426: LD_INT 1400
34428: ST_TO_ADDR
// repeat wait ( time ) ;
34429: LD_VAR 0 1
34433: PPUSH
34434: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34438: LD_INT 1
34440: PPUSH
34441: LD_INT 5
34443: PPUSH
34444: CALL_OW 12
34448: PPUSH
34449: LD_INT 106
34451: PPUSH
34452: LD_INT 150
34454: PPUSH
34455: LD_INT 19
34457: PPUSH
34458: LD_INT 1
34460: PPUSH
34461: CALL_OW 56
// time := time + 0 0$9 ;
34465: LD_ADDR_VAR 0 1
34469: PUSH
34470: LD_VAR 0 1
34474: PUSH
34475: LD_INT 315
34477: PLUS
34478: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34479: LD_INT 455
34481: PPUSH
34482: LD_INT 840
34484: PPUSH
34485: CALL_OW 12
34489: PPUSH
34490: CALL_OW 67
// if Prob ( 50 ) then
34494: LD_INT 50
34496: PPUSH
34497: CALL_OW 13
34501: IFFALSE 34530
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34503: LD_INT 1
34505: PPUSH
34506: LD_INT 5
34508: PPUSH
34509: CALL_OW 12
34513: PPUSH
34514: LD_INT 62
34516: PPUSH
34517: LD_INT 108
34519: PPUSH
34520: LD_INT 10
34522: PPUSH
34523: LD_INT 1
34525: PPUSH
34526: CALL_OW 56
// until missionStage > 4 ;
34530: LD_EXP 15
34534: PUSH
34535: LD_INT 4
34537: GREATER
34538: IFFALSE 34429
// repeat wait ( 0 0$1 ) ;
34540: LD_INT 35
34542: PPUSH
34543: CALL_OW 67
// until missionStage = 6 ;
34547: LD_EXP 15
34551: PUSH
34552: LD_INT 6
34554: EQUAL
34555: IFFALSE 34540
// time := 0 0$50 ;
34557: LD_ADDR_VAR 0 1
34561: PUSH
34562: LD_INT 1750
34564: ST_TO_ADDR
// repeat wait ( time ) ;
34565: LD_VAR 0 1
34569: PPUSH
34570: CALL_OW 67
// if Prob ( 50 ) then
34574: LD_INT 50
34576: PPUSH
34577: CALL_OW 13
34581: IFFALSE 34610
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34583: LD_INT 1
34585: PPUSH
34586: LD_INT 5
34588: PPUSH
34589: CALL_OW 12
34593: PPUSH
34594: LD_INT 106
34596: PPUSH
34597: LD_INT 89
34599: PPUSH
34600: LD_INT 45
34602: PPUSH
34603: LD_INT 1
34605: PPUSH
34606: CALL_OW 56
// time := time + 0 0$2 ;
34610: LD_ADDR_VAR 0 1
34614: PUSH
34615: LD_VAR 0 1
34619: PUSH
34620: LD_INT 70
34622: PLUS
34623: ST_TO_ADDR
// if Prob ( 30 ) then
34624: LD_INT 30
34626: PPUSH
34627: CALL_OW 13
34631: IFFALSE 34677
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34633: LD_INT 385
34635: PPUSH
34636: LD_INT 945
34638: PPUSH
34639: CALL_OW 12
34643: PPUSH
34644: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34648: LD_INT 1
34650: PPUSH
34651: LD_INT 5
34653: PPUSH
34654: CALL_OW 12
34658: PPUSH
34659: LD_INT 21
34661: PPUSH
34662: LD_INT 26
34664: PPUSH
34665: LD_INT 12
34667: PPUSH
34668: LD_INT 1
34670: PPUSH
34671: CALL_OW 56
// end else
34675: GO 34713
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34677: LD_INT 700
34679: PPUSH
34680: LD_INT 1225
34682: PPUSH
34683: CALL_OW 12
34687: PPUSH
34688: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34692: LD_INT 1
34694: PPUSH
34695: LD_INT 5
34697: PPUSH
34698: CALL_OW 12
34702: PPUSH
34703: LD_INT 16
34705: PPUSH
34706: LD_INT 1
34708: PPUSH
34709: CALL_OW 55
// end ; if Prob ( 50 ) then
34713: LD_INT 50
34715: PPUSH
34716: CALL_OW 13
34720: IFFALSE 34766
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34722: LD_INT 700
34724: PPUSH
34725: LD_INT 1050
34727: PPUSH
34728: CALL_OW 12
34732: PPUSH
34733: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34737: LD_INT 1
34739: PPUSH
34740: LD_INT 5
34742: PPUSH
34743: CALL_OW 12
34747: PPUSH
34748: LD_INT 181
34750: PPUSH
34751: LD_INT 218
34753: PPUSH
34754: LD_INT 16
34756: PPUSH
34757: LD_INT 1
34759: PPUSH
34760: CALL_OW 56
// end else
34764: GO 34802
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34766: LD_INT 350
34768: PPUSH
34769: LD_INT 525
34771: PPUSH
34772: CALL_OW 12
34776: PPUSH
34777: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34781: LD_INT 1
34783: PPUSH
34784: LD_INT 5
34786: PPUSH
34787: CALL_OW 12
34791: PPUSH
34792: LD_INT 15
34794: PPUSH
34795: LD_INT 1
34797: PPUSH
34798: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 , 22 ] [ Difficulty ] ) then
34802: LD_INT 45
34804: PUSH
34805: LD_INT 32
34807: PUSH
34808: LD_INT 25
34810: PUSH
34811: LD_INT 22
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: PUSH
34820: LD_OWVAR 67
34824: ARRAY
34825: PPUSH
34826: CALL_OW 13
34830: IFFALSE 34874
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34832: LD_INT 175
34834: PPUSH
34835: LD_INT 315
34837: PPUSH
34838: CALL_OW 12
34842: PPUSH
34843: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34847: LD_INT 1
34849: PPUSH
34850: LD_INT 5
34852: PPUSH
34853: CALL_OW 12
34857: PPUSH
34858: LD_INT 103
34860: PPUSH
34861: LD_INT 140
34863: PPUSH
34864: LD_INT 20
34866: PPUSH
34867: LD_INT 1
34869: PPUSH
34870: CALL_OW 56
// end ; if time > 1 1$20 then
34874: LD_VAR 0 1
34878: PUSH
34879: LD_INT 2800
34881: GREATER
34882: IFFALSE 34892
// time := 0 0$30 ;
34884: LD_ADDR_VAR 0 1
34888: PUSH
34889: LD_INT 1050
34891: ST_TO_ADDR
// until false ;
34892: LD_INT 0
34894: IFFALSE 34565
// end ; end_of_file
34896: PPOPN 1
34898: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34899: LD_EXP 13
34903: PUSH
34904: LD_EXP 15
34908: PUSH
34909: LD_INT 6
34911: GREATEREQUAL
34912: AND
34913: IFFALSE 34950
34915: GO 34917
34917: DISABLE
// begin enable ;
34918: ENABLE
// missionTime := missionTime + 0 0$1 ;
34919: LD_ADDR_EXP 14
34923: PUSH
34924: LD_EXP 14
34928: PUSH
34929: LD_INT 35
34931: PLUS
34932: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34933: LD_ADDR_OWVAR 47
34937: PUSH
34938: LD_STRING #Am15-1
34940: PUSH
34941: LD_EXP 14
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: ST_TO_ADDR
// end ; end_of_file
34950: END
// export function InitNature ; begin
34951: LD_INT 0
34953: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34954: LD_INT 3
34956: PPUSH
34957: LD_INT 3
34959: PPUSH
34960: LD_INT 2
34962: PPUSH
34963: LD_INT 1
34965: PPUSH
34966: LD_INT 1
34968: PPUSH
34969: LD_INT 0
34971: PPUSH
34972: LD_INT 0
34974: PPUSH
34975: LD_INT 20
34977: PPUSH
34978: LD_INT 0
34980: PPUSH
34981: CALL 99240 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34985: LD_INT 2
34987: PPUSH
34988: LD_INT 1
34990: PPUSH
34991: LD_INT 1
34993: PPUSH
34994: LD_INT 1
34996: PPUSH
34997: LD_INT 1
34999: PPUSH
35000: LD_INT 0
35002: PPUSH
35003: LD_INT 0
35005: PPUSH
35006: LD_INT 21
35008: PPUSH
35009: LD_INT 0
35011: PPUSH
35012: CALL 99240 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
35016: LD_INT 4
35018: PPUSH
35019: LD_INT 1
35021: PPUSH
35022: LD_INT 2
35024: PPUSH
35025: LD_INT 4
35027: PPUSH
35028: LD_INT 2
35030: PPUSH
35031: LD_INT 1
35033: PPUSH
35034: LD_INT 0
35036: PPUSH
35037: LD_INT 22
35039: PPUSH
35040: LD_INT 0
35042: PPUSH
35043: CALL 99240 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
35047: LD_INT 0
35049: PPUSH
35050: LD_INT 0
35052: PPUSH
35053: LD_INT 0
35055: PPUSH
35056: LD_INT 0
35058: PPUSH
35059: LD_INT 0
35061: PPUSH
35062: LD_INT 0
35064: PPUSH
35065: LD_INT 9
35067: PPUSH
35068: LD_INT 0
35070: PPUSH
35071: LD_INT 23
35073: PPUSH
35074: CALL 99240 0 9
// end ; end_of_file
35078: LD_VAR 0 1
35082: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
35083: LD_INT 0
35085: PPUSH
// ar_miner := 81 ;
35086: LD_ADDR_EXP 102
35090: PUSH
35091: LD_INT 81
35093: ST_TO_ADDR
// ar_crane := 88 ;
35094: LD_ADDR_EXP 101
35098: PUSH
35099: LD_INT 88
35101: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
35102: LD_ADDR_EXP 96
35106: PUSH
35107: LD_INT 89
35109: ST_TO_ADDR
// us_hack := 99 ;
35110: LD_ADDR_EXP 97
35114: PUSH
35115: LD_INT 99
35117: ST_TO_ADDR
// us_artillery := 97 ;
35118: LD_ADDR_EXP 98
35122: PUSH
35123: LD_INT 97
35125: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35126: LD_ADDR_EXP 99
35130: PUSH
35131: LD_INT 91
35133: ST_TO_ADDR
// ar_mortar := 92 ;
35134: LD_ADDR_EXP 100
35138: PUSH
35139: LD_INT 92
35141: ST_TO_ADDR
// ru_radar := 98 ;
35142: LD_ADDR_EXP 95
35146: PUSH
35147: LD_INT 98
35149: ST_TO_ADDR
// tech_Artillery := 80 ;
35150: LD_ADDR_EXP 103
35154: PUSH
35155: LD_INT 80
35157: ST_TO_ADDR
// tech_RadMat := 81 ;
35158: LD_ADDR_EXP 104
35162: PUSH
35163: LD_INT 81
35165: ST_TO_ADDR
// tech_BasicTools := 82 ;
35166: LD_ADDR_EXP 105
35170: PUSH
35171: LD_INT 82
35173: ST_TO_ADDR
// tech_Cargo := 83 ;
35174: LD_ADDR_EXP 106
35178: PUSH
35179: LD_INT 83
35181: ST_TO_ADDR
// tech_Track := 84 ;
35182: LD_ADDR_EXP 107
35186: PUSH
35187: LD_INT 84
35189: ST_TO_ADDR
// tech_Crane := 85 ;
35190: LD_ADDR_EXP 108
35194: PUSH
35195: LD_INT 85
35197: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35198: LD_ADDR_EXP 109
35202: PUSH
35203: LD_INT 86
35205: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35206: LD_ADDR_EXP 110
35210: PUSH
35211: LD_INT 87
35213: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
35214: LD_ADDR_EXP 111
35218: PUSH
35219: LD_INT 88
35221: ST_TO_ADDR
// class_mastodont := 31 ;
35222: LD_ADDR_EXP 112
35226: PUSH
35227: LD_INT 31
35229: ST_TO_ADDR
// class_horse := 21 ;
35230: LD_ADDR_EXP 113
35234: PUSH
35235: LD_INT 21
35237: ST_TO_ADDR
// end ;
35238: LD_VAR 0 1
35242: RET
// every 1 do
35243: GO 35245
35245: DISABLE
// InitGlobalVariables ; end_of_file
35246: CALL 35083 0 0
35250: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35251: LD_INT 0
35253: PPUSH
35254: PPUSH
// skirmish := false ;
35255: LD_ADDR_EXP 114
35259: PUSH
35260: LD_INT 0
35262: ST_TO_ADDR
// debug_mc := false ;
35263: LD_ADDR_EXP 115
35267: PUSH
35268: LD_INT 0
35270: ST_TO_ADDR
// mc_bases := [ ] ;
35271: LD_ADDR_EXP 116
35275: PUSH
35276: EMPTY
35277: ST_TO_ADDR
// mc_sides := [ ] ;
35278: LD_ADDR_EXP 142
35282: PUSH
35283: EMPTY
35284: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35285: LD_ADDR_EXP 117
35289: PUSH
35290: EMPTY
35291: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35292: LD_ADDR_EXP 118
35296: PUSH
35297: EMPTY
35298: ST_TO_ADDR
// mc_need_heal := [ ] ;
35299: LD_ADDR_EXP 119
35303: PUSH
35304: EMPTY
35305: ST_TO_ADDR
// mc_healers := [ ] ;
35306: LD_ADDR_EXP 120
35310: PUSH
35311: EMPTY
35312: ST_TO_ADDR
// mc_build_list := [ ] ;
35313: LD_ADDR_EXP 121
35317: PUSH
35318: EMPTY
35319: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35320: LD_ADDR_EXP 148
35324: PUSH
35325: EMPTY
35326: ST_TO_ADDR
// mc_builders := [ ] ;
35327: LD_ADDR_EXP 122
35331: PUSH
35332: EMPTY
35333: ST_TO_ADDR
// mc_construct_list := [ ] ;
35334: LD_ADDR_EXP 123
35338: PUSH
35339: EMPTY
35340: ST_TO_ADDR
// mc_turret_list := [ ] ;
35341: LD_ADDR_EXP 124
35345: PUSH
35346: EMPTY
35347: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35348: LD_ADDR_EXP 125
35352: PUSH
35353: EMPTY
35354: ST_TO_ADDR
// mc_miners := [ ] ;
35355: LD_ADDR_EXP 130
35359: PUSH
35360: EMPTY
35361: ST_TO_ADDR
// mc_mines := [ ] ;
35362: LD_ADDR_EXP 129
35366: PUSH
35367: EMPTY
35368: ST_TO_ADDR
// mc_minefields := [ ] ;
35369: LD_ADDR_EXP 131
35373: PUSH
35374: EMPTY
35375: ST_TO_ADDR
// mc_crates := [ ] ;
35376: LD_ADDR_EXP 132
35380: PUSH
35381: EMPTY
35382: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35383: LD_ADDR_EXP 133
35387: PUSH
35388: EMPTY
35389: ST_TO_ADDR
// mc_crates_area := [ ] ;
35390: LD_ADDR_EXP 134
35394: PUSH
35395: EMPTY
35396: ST_TO_ADDR
// mc_vehicles := [ ] ;
35397: LD_ADDR_EXP 135
35401: PUSH
35402: EMPTY
35403: ST_TO_ADDR
// mc_attack := [ ] ;
35404: LD_ADDR_EXP 136
35408: PUSH
35409: EMPTY
35410: ST_TO_ADDR
// mc_produce := [ ] ;
35411: LD_ADDR_EXP 137
35415: PUSH
35416: EMPTY
35417: ST_TO_ADDR
// mc_defender := [ ] ;
35418: LD_ADDR_EXP 138
35422: PUSH
35423: EMPTY
35424: ST_TO_ADDR
// mc_parking := [ ] ;
35425: LD_ADDR_EXP 140
35429: PUSH
35430: EMPTY
35431: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35432: LD_ADDR_EXP 126
35436: PUSH
35437: EMPTY
35438: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35439: LD_ADDR_EXP 128
35443: PUSH
35444: EMPTY
35445: ST_TO_ADDR
// mc_scan := [ ] ;
35446: LD_ADDR_EXP 139
35450: PUSH
35451: EMPTY
35452: ST_TO_ADDR
// mc_scan_area := [ ] ;
35453: LD_ADDR_EXP 141
35457: PUSH
35458: EMPTY
35459: ST_TO_ADDR
// mc_tech := [ ] ;
35460: LD_ADDR_EXP 143
35464: PUSH
35465: EMPTY
35466: ST_TO_ADDR
// mc_class := [ ] ;
35467: LD_ADDR_EXP 157
35471: PUSH
35472: EMPTY
35473: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35474: LD_ADDR_EXP 158
35478: PUSH
35479: EMPTY
35480: ST_TO_ADDR
// mc_is_defending := [ ] ;
35481: LD_ADDR_EXP 159
35485: PUSH
35486: EMPTY
35487: ST_TO_ADDR
// end ;
35488: LD_VAR 0 1
35492: RET
// export function MC_Kill ( base ) ; begin
35493: LD_INT 0
35495: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35496: LD_ADDR_EXP 116
35500: PUSH
35501: LD_EXP 116
35505: PPUSH
35506: LD_VAR 0 1
35510: PPUSH
35511: EMPTY
35512: PPUSH
35513: CALL_OW 1
35517: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35518: LD_ADDR_EXP 117
35522: PUSH
35523: LD_EXP 117
35527: PPUSH
35528: LD_VAR 0 1
35532: PPUSH
35533: EMPTY
35534: PPUSH
35535: CALL_OW 1
35539: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35540: LD_ADDR_EXP 118
35544: PUSH
35545: LD_EXP 118
35549: PPUSH
35550: LD_VAR 0 1
35554: PPUSH
35555: EMPTY
35556: PPUSH
35557: CALL_OW 1
35561: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35562: LD_ADDR_EXP 119
35566: PUSH
35567: LD_EXP 119
35571: PPUSH
35572: LD_VAR 0 1
35576: PPUSH
35577: EMPTY
35578: PPUSH
35579: CALL_OW 1
35583: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35584: LD_ADDR_EXP 120
35588: PUSH
35589: LD_EXP 120
35593: PPUSH
35594: LD_VAR 0 1
35598: PPUSH
35599: EMPTY
35600: PPUSH
35601: CALL_OW 1
35605: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35606: LD_ADDR_EXP 121
35610: PUSH
35611: LD_EXP 121
35615: PPUSH
35616: LD_VAR 0 1
35620: PPUSH
35621: EMPTY
35622: PPUSH
35623: CALL_OW 1
35627: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35628: LD_ADDR_EXP 122
35632: PUSH
35633: LD_EXP 122
35637: PPUSH
35638: LD_VAR 0 1
35642: PPUSH
35643: EMPTY
35644: PPUSH
35645: CALL_OW 1
35649: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35650: LD_ADDR_EXP 123
35654: PUSH
35655: LD_EXP 123
35659: PPUSH
35660: LD_VAR 0 1
35664: PPUSH
35665: EMPTY
35666: PPUSH
35667: CALL_OW 1
35671: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35672: LD_ADDR_EXP 124
35676: PUSH
35677: LD_EXP 124
35681: PPUSH
35682: LD_VAR 0 1
35686: PPUSH
35687: EMPTY
35688: PPUSH
35689: CALL_OW 1
35693: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35694: LD_ADDR_EXP 125
35698: PUSH
35699: LD_EXP 125
35703: PPUSH
35704: LD_VAR 0 1
35708: PPUSH
35709: EMPTY
35710: PPUSH
35711: CALL_OW 1
35715: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35716: LD_ADDR_EXP 126
35720: PUSH
35721: LD_EXP 126
35725: PPUSH
35726: LD_VAR 0 1
35730: PPUSH
35731: EMPTY
35732: PPUSH
35733: CALL_OW 1
35737: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35738: LD_ADDR_EXP 127
35742: PUSH
35743: LD_EXP 127
35747: PPUSH
35748: LD_VAR 0 1
35752: PPUSH
35753: LD_INT 0
35755: PPUSH
35756: CALL_OW 1
35760: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35761: LD_ADDR_EXP 128
35765: PUSH
35766: LD_EXP 128
35770: PPUSH
35771: LD_VAR 0 1
35775: PPUSH
35776: EMPTY
35777: PPUSH
35778: CALL_OW 1
35782: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35783: LD_ADDR_EXP 129
35787: PUSH
35788: LD_EXP 129
35792: PPUSH
35793: LD_VAR 0 1
35797: PPUSH
35798: EMPTY
35799: PPUSH
35800: CALL_OW 1
35804: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35805: LD_ADDR_EXP 130
35809: PUSH
35810: LD_EXP 130
35814: PPUSH
35815: LD_VAR 0 1
35819: PPUSH
35820: EMPTY
35821: PPUSH
35822: CALL_OW 1
35826: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35827: LD_ADDR_EXP 131
35831: PUSH
35832: LD_EXP 131
35836: PPUSH
35837: LD_VAR 0 1
35841: PPUSH
35842: EMPTY
35843: PPUSH
35844: CALL_OW 1
35848: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35849: LD_ADDR_EXP 132
35853: PUSH
35854: LD_EXP 132
35858: PPUSH
35859: LD_VAR 0 1
35863: PPUSH
35864: EMPTY
35865: PPUSH
35866: CALL_OW 1
35870: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35871: LD_ADDR_EXP 133
35875: PUSH
35876: LD_EXP 133
35880: PPUSH
35881: LD_VAR 0 1
35885: PPUSH
35886: EMPTY
35887: PPUSH
35888: CALL_OW 1
35892: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35893: LD_ADDR_EXP 134
35897: PUSH
35898: LD_EXP 134
35902: PPUSH
35903: LD_VAR 0 1
35907: PPUSH
35908: EMPTY
35909: PPUSH
35910: CALL_OW 1
35914: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35915: LD_ADDR_EXP 135
35919: PUSH
35920: LD_EXP 135
35924: PPUSH
35925: LD_VAR 0 1
35929: PPUSH
35930: EMPTY
35931: PPUSH
35932: CALL_OW 1
35936: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35937: LD_ADDR_EXP 136
35941: PUSH
35942: LD_EXP 136
35946: PPUSH
35947: LD_VAR 0 1
35951: PPUSH
35952: EMPTY
35953: PPUSH
35954: CALL_OW 1
35958: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35959: LD_ADDR_EXP 137
35963: PUSH
35964: LD_EXP 137
35968: PPUSH
35969: LD_VAR 0 1
35973: PPUSH
35974: EMPTY
35975: PPUSH
35976: CALL_OW 1
35980: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35981: LD_ADDR_EXP 138
35985: PUSH
35986: LD_EXP 138
35990: PPUSH
35991: LD_VAR 0 1
35995: PPUSH
35996: EMPTY
35997: PPUSH
35998: CALL_OW 1
36002: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36003: LD_ADDR_EXP 139
36007: PUSH
36008: LD_EXP 139
36012: PPUSH
36013: LD_VAR 0 1
36017: PPUSH
36018: EMPTY
36019: PPUSH
36020: CALL_OW 1
36024: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36025: LD_ADDR_EXP 140
36029: PUSH
36030: LD_EXP 140
36034: PPUSH
36035: LD_VAR 0 1
36039: PPUSH
36040: EMPTY
36041: PPUSH
36042: CALL_OW 1
36046: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36047: LD_ADDR_EXP 141
36051: PUSH
36052: LD_EXP 141
36056: PPUSH
36057: LD_VAR 0 1
36061: PPUSH
36062: EMPTY
36063: PPUSH
36064: CALL_OW 1
36068: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36069: LD_ADDR_EXP 143
36073: PUSH
36074: LD_EXP 143
36078: PPUSH
36079: LD_VAR 0 1
36083: PPUSH
36084: EMPTY
36085: PPUSH
36086: CALL_OW 1
36090: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36091: LD_ADDR_EXP 145
36095: PUSH
36096: LD_EXP 145
36100: PPUSH
36101: LD_VAR 0 1
36105: PPUSH
36106: EMPTY
36107: PPUSH
36108: CALL_OW 1
36112: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36113: LD_ADDR_EXP 146
36117: PUSH
36118: LD_EXP 146
36122: PPUSH
36123: LD_VAR 0 1
36127: PPUSH
36128: EMPTY
36129: PPUSH
36130: CALL_OW 1
36134: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36135: LD_ADDR_EXP 147
36139: PUSH
36140: LD_EXP 147
36144: PPUSH
36145: LD_VAR 0 1
36149: PPUSH
36150: EMPTY
36151: PPUSH
36152: CALL_OW 1
36156: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36157: LD_ADDR_EXP 148
36161: PUSH
36162: LD_EXP 148
36166: PPUSH
36167: LD_VAR 0 1
36171: PPUSH
36172: EMPTY
36173: PPUSH
36174: CALL_OW 1
36178: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36179: LD_ADDR_EXP 149
36183: PUSH
36184: LD_EXP 149
36188: PPUSH
36189: LD_VAR 0 1
36193: PPUSH
36194: EMPTY
36195: PPUSH
36196: CALL_OW 1
36200: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36201: LD_ADDR_EXP 150
36205: PUSH
36206: LD_EXP 150
36210: PPUSH
36211: LD_VAR 0 1
36215: PPUSH
36216: EMPTY
36217: PPUSH
36218: CALL_OW 1
36222: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36223: LD_ADDR_EXP 151
36227: PUSH
36228: LD_EXP 151
36232: PPUSH
36233: LD_VAR 0 1
36237: PPUSH
36238: EMPTY
36239: PPUSH
36240: CALL_OW 1
36244: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36245: LD_ADDR_EXP 152
36249: PUSH
36250: LD_EXP 152
36254: PPUSH
36255: LD_VAR 0 1
36259: PPUSH
36260: EMPTY
36261: PPUSH
36262: CALL_OW 1
36266: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36267: LD_ADDR_EXP 153
36271: PUSH
36272: LD_EXP 153
36276: PPUSH
36277: LD_VAR 0 1
36281: PPUSH
36282: EMPTY
36283: PPUSH
36284: CALL_OW 1
36288: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36289: LD_ADDR_EXP 154
36293: PUSH
36294: LD_EXP 154
36298: PPUSH
36299: LD_VAR 0 1
36303: PPUSH
36304: EMPTY
36305: PPUSH
36306: CALL_OW 1
36310: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36311: LD_ADDR_EXP 155
36315: PUSH
36316: LD_EXP 155
36320: PPUSH
36321: LD_VAR 0 1
36325: PPUSH
36326: EMPTY
36327: PPUSH
36328: CALL_OW 1
36332: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36333: LD_ADDR_EXP 156
36337: PUSH
36338: LD_EXP 156
36342: PPUSH
36343: LD_VAR 0 1
36347: PPUSH
36348: EMPTY
36349: PPUSH
36350: CALL_OW 1
36354: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36355: LD_ADDR_EXP 157
36359: PUSH
36360: LD_EXP 157
36364: PPUSH
36365: LD_VAR 0 1
36369: PPUSH
36370: EMPTY
36371: PPUSH
36372: CALL_OW 1
36376: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36377: LD_ADDR_EXP 158
36381: PUSH
36382: LD_EXP 158
36386: PPUSH
36387: LD_VAR 0 1
36391: PPUSH
36392: LD_INT 0
36394: PPUSH
36395: CALL_OW 1
36399: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36400: LD_ADDR_EXP 159
36404: PUSH
36405: LD_EXP 159
36409: PPUSH
36410: LD_VAR 0 1
36414: PPUSH
36415: LD_INT 0
36417: PPUSH
36418: CALL_OW 1
36422: ST_TO_ADDR
// end ;
36423: LD_VAR 0 2
36427: RET
// export function MC_Add ( side , units ) ; var base ; begin
36428: LD_INT 0
36430: PPUSH
36431: PPUSH
// base := mc_bases + 1 ;
36432: LD_ADDR_VAR 0 4
36436: PUSH
36437: LD_EXP 116
36441: PUSH
36442: LD_INT 1
36444: PLUS
36445: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36446: LD_ADDR_EXP 142
36450: PUSH
36451: LD_EXP 142
36455: PPUSH
36456: LD_VAR 0 4
36460: PPUSH
36461: LD_VAR 0 1
36465: PPUSH
36466: CALL_OW 1
36470: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36471: LD_ADDR_EXP 116
36475: PUSH
36476: LD_EXP 116
36480: PPUSH
36481: LD_VAR 0 4
36485: PPUSH
36486: LD_VAR 0 2
36490: PPUSH
36491: CALL_OW 1
36495: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36496: LD_ADDR_EXP 117
36500: PUSH
36501: LD_EXP 117
36505: PPUSH
36506: LD_VAR 0 4
36510: PPUSH
36511: EMPTY
36512: PPUSH
36513: CALL_OW 1
36517: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36518: LD_ADDR_EXP 118
36522: PUSH
36523: LD_EXP 118
36527: PPUSH
36528: LD_VAR 0 4
36532: PPUSH
36533: EMPTY
36534: PPUSH
36535: CALL_OW 1
36539: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36540: LD_ADDR_EXP 119
36544: PUSH
36545: LD_EXP 119
36549: PPUSH
36550: LD_VAR 0 4
36554: PPUSH
36555: EMPTY
36556: PPUSH
36557: CALL_OW 1
36561: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36562: LD_ADDR_EXP 120
36566: PUSH
36567: LD_EXP 120
36571: PPUSH
36572: LD_VAR 0 4
36576: PPUSH
36577: EMPTY
36578: PPUSH
36579: CALL_OW 1
36583: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36584: LD_ADDR_EXP 121
36588: PUSH
36589: LD_EXP 121
36593: PPUSH
36594: LD_VAR 0 4
36598: PPUSH
36599: EMPTY
36600: PPUSH
36601: CALL_OW 1
36605: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36606: LD_ADDR_EXP 122
36610: PUSH
36611: LD_EXP 122
36615: PPUSH
36616: LD_VAR 0 4
36620: PPUSH
36621: EMPTY
36622: PPUSH
36623: CALL_OW 1
36627: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36628: LD_ADDR_EXP 123
36632: PUSH
36633: LD_EXP 123
36637: PPUSH
36638: LD_VAR 0 4
36642: PPUSH
36643: EMPTY
36644: PPUSH
36645: CALL_OW 1
36649: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36650: LD_ADDR_EXP 124
36654: PUSH
36655: LD_EXP 124
36659: PPUSH
36660: LD_VAR 0 4
36664: PPUSH
36665: EMPTY
36666: PPUSH
36667: CALL_OW 1
36671: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36672: LD_ADDR_EXP 125
36676: PUSH
36677: LD_EXP 125
36681: PPUSH
36682: LD_VAR 0 4
36686: PPUSH
36687: EMPTY
36688: PPUSH
36689: CALL_OW 1
36693: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36694: LD_ADDR_EXP 126
36698: PUSH
36699: LD_EXP 126
36703: PPUSH
36704: LD_VAR 0 4
36708: PPUSH
36709: EMPTY
36710: PPUSH
36711: CALL_OW 1
36715: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36716: LD_ADDR_EXP 127
36720: PUSH
36721: LD_EXP 127
36725: PPUSH
36726: LD_VAR 0 4
36730: PPUSH
36731: LD_INT 0
36733: PPUSH
36734: CALL_OW 1
36738: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36739: LD_ADDR_EXP 128
36743: PUSH
36744: LD_EXP 128
36748: PPUSH
36749: LD_VAR 0 4
36753: PPUSH
36754: EMPTY
36755: PPUSH
36756: CALL_OW 1
36760: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36761: LD_ADDR_EXP 129
36765: PUSH
36766: LD_EXP 129
36770: PPUSH
36771: LD_VAR 0 4
36775: PPUSH
36776: EMPTY
36777: PPUSH
36778: CALL_OW 1
36782: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36783: LD_ADDR_EXP 130
36787: PUSH
36788: LD_EXP 130
36792: PPUSH
36793: LD_VAR 0 4
36797: PPUSH
36798: EMPTY
36799: PPUSH
36800: CALL_OW 1
36804: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36805: LD_ADDR_EXP 131
36809: PUSH
36810: LD_EXP 131
36814: PPUSH
36815: LD_VAR 0 4
36819: PPUSH
36820: EMPTY
36821: PPUSH
36822: CALL_OW 1
36826: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36827: LD_ADDR_EXP 132
36831: PUSH
36832: LD_EXP 132
36836: PPUSH
36837: LD_VAR 0 4
36841: PPUSH
36842: EMPTY
36843: PPUSH
36844: CALL_OW 1
36848: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36849: LD_ADDR_EXP 133
36853: PUSH
36854: LD_EXP 133
36858: PPUSH
36859: LD_VAR 0 4
36863: PPUSH
36864: EMPTY
36865: PPUSH
36866: CALL_OW 1
36870: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36871: LD_ADDR_EXP 134
36875: PUSH
36876: LD_EXP 134
36880: PPUSH
36881: LD_VAR 0 4
36885: PPUSH
36886: EMPTY
36887: PPUSH
36888: CALL_OW 1
36892: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36893: LD_ADDR_EXP 135
36897: PUSH
36898: LD_EXP 135
36902: PPUSH
36903: LD_VAR 0 4
36907: PPUSH
36908: EMPTY
36909: PPUSH
36910: CALL_OW 1
36914: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36915: LD_ADDR_EXP 136
36919: PUSH
36920: LD_EXP 136
36924: PPUSH
36925: LD_VAR 0 4
36929: PPUSH
36930: EMPTY
36931: PPUSH
36932: CALL_OW 1
36936: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36937: LD_ADDR_EXP 137
36941: PUSH
36942: LD_EXP 137
36946: PPUSH
36947: LD_VAR 0 4
36951: PPUSH
36952: EMPTY
36953: PPUSH
36954: CALL_OW 1
36958: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36959: LD_ADDR_EXP 138
36963: PUSH
36964: LD_EXP 138
36968: PPUSH
36969: LD_VAR 0 4
36973: PPUSH
36974: EMPTY
36975: PPUSH
36976: CALL_OW 1
36980: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36981: LD_ADDR_EXP 139
36985: PUSH
36986: LD_EXP 139
36990: PPUSH
36991: LD_VAR 0 4
36995: PPUSH
36996: EMPTY
36997: PPUSH
36998: CALL_OW 1
37002: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37003: LD_ADDR_EXP 140
37007: PUSH
37008: LD_EXP 140
37012: PPUSH
37013: LD_VAR 0 4
37017: PPUSH
37018: EMPTY
37019: PPUSH
37020: CALL_OW 1
37024: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37025: LD_ADDR_EXP 141
37029: PUSH
37030: LD_EXP 141
37034: PPUSH
37035: LD_VAR 0 4
37039: PPUSH
37040: EMPTY
37041: PPUSH
37042: CALL_OW 1
37046: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37047: LD_ADDR_EXP 143
37051: PUSH
37052: LD_EXP 143
37056: PPUSH
37057: LD_VAR 0 4
37061: PPUSH
37062: EMPTY
37063: PPUSH
37064: CALL_OW 1
37068: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37069: LD_ADDR_EXP 145
37073: PUSH
37074: LD_EXP 145
37078: PPUSH
37079: LD_VAR 0 4
37083: PPUSH
37084: EMPTY
37085: PPUSH
37086: CALL_OW 1
37090: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37091: LD_ADDR_EXP 146
37095: PUSH
37096: LD_EXP 146
37100: PPUSH
37101: LD_VAR 0 4
37105: PPUSH
37106: EMPTY
37107: PPUSH
37108: CALL_OW 1
37112: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37113: LD_ADDR_EXP 147
37117: PUSH
37118: LD_EXP 147
37122: PPUSH
37123: LD_VAR 0 4
37127: PPUSH
37128: EMPTY
37129: PPUSH
37130: CALL_OW 1
37134: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37135: LD_ADDR_EXP 148
37139: PUSH
37140: LD_EXP 148
37144: PPUSH
37145: LD_VAR 0 4
37149: PPUSH
37150: EMPTY
37151: PPUSH
37152: CALL_OW 1
37156: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37157: LD_ADDR_EXP 149
37161: PUSH
37162: LD_EXP 149
37166: PPUSH
37167: LD_VAR 0 4
37171: PPUSH
37172: EMPTY
37173: PPUSH
37174: CALL_OW 1
37178: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37179: LD_ADDR_EXP 150
37183: PUSH
37184: LD_EXP 150
37188: PPUSH
37189: LD_VAR 0 4
37193: PPUSH
37194: EMPTY
37195: PPUSH
37196: CALL_OW 1
37200: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37201: LD_ADDR_EXP 151
37205: PUSH
37206: LD_EXP 151
37210: PPUSH
37211: LD_VAR 0 4
37215: PPUSH
37216: EMPTY
37217: PPUSH
37218: CALL_OW 1
37222: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37223: LD_ADDR_EXP 152
37227: PUSH
37228: LD_EXP 152
37232: PPUSH
37233: LD_VAR 0 4
37237: PPUSH
37238: EMPTY
37239: PPUSH
37240: CALL_OW 1
37244: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37245: LD_ADDR_EXP 153
37249: PUSH
37250: LD_EXP 153
37254: PPUSH
37255: LD_VAR 0 4
37259: PPUSH
37260: EMPTY
37261: PPUSH
37262: CALL_OW 1
37266: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37267: LD_ADDR_EXP 154
37271: PUSH
37272: LD_EXP 154
37276: PPUSH
37277: LD_VAR 0 4
37281: PPUSH
37282: EMPTY
37283: PPUSH
37284: CALL_OW 1
37288: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37289: LD_ADDR_EXP 155
37293: PUSH
37294: LD_EXP 155
37298: PPUSH
37299: LD_VAR 0 4
37303: PPUSH
37304: EMPTY
37305: PPUSH
37306: CALL_OW 1
37310: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37311: LD_ADDR_EXP 156
37315: PUSH
37316: LD_EXP 156
37320: PPUSH
37321: LD_VAR 0 4
37325: PPUSH
37326: EMPTY
37327: PPUSH
37328: CALL_OW 1
37332: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37333: LD_ADDR_EXP 157
37337: PUSH
37338: LD_EXP 157
37342: PPUSH
37343: LD_VAR 0 4
37347: PPUSH
37348: EMPTY
37349: PPUSH
37350: CALL_OW 1
37354: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37355: LD_ADDR_EXP 158
37359: PUSH
37360: LD_EXP 158
37364: PPUSH
37365: LD_VAR 0 4
37369: PPUSH
37370: LD_INT 0
37372: PPUSH
37373: CALL_OW 1
37377: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37378: LD_ADDR_EXP 159
37382: PUSH
37383: LD_EXP 159
37387: PPUSH
37388: LD_VAR 0 4
37392: PPUSH
37393: LD_INT 0
37395: PPUSH
37396: CALL_OW 1
37400: ST_TO_ADDR
// result := base ;
37401: LD_ADDR_VAR 0 3
37405: PUSH
37406: LD_VAR 0 4
37410: ST_TO_ADDR
// end ;
37411: LD_VAR 0 3
37415: RET
// export function MC_Start ( ) ; var i ; begin
37416: LD_INT 0
37418: PPUSH
37419: PPUSH
// for i = 1 to mc_bases do
37420: LD_ADDR_VAR 0 2
37424: PUSH
37425: DOUBLE
37426: LD_INT 1
37428: DEC
37429: ST_TO_ADDR
37430: LD_EXP 116
37434: PUSH
37435: FOR_TO
37436: IFFALSE 38536
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37438: LD_ADDR_EXP 116
37442: PUSH
37443: LD_EXP 116
37447: PPUSH
37448: LD_VAR 0 2
37452: PPUSH
37453: LD_EXP 116
37457: PUSH
37458: LD_VAR 0 2
37462: ARRAY
37463: PUSH
37464: LD_INT 0
37466: DIFF
37467: PPUSH
37468: CALL_OW 1
37472: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37473: LD_ADDR_EXP 117
37477: PUSH
37478: LD_EXP 117
37482: PPUSH
37483: LD_VAR 0 2
37487: PPUSH
37488: EMPTY
37489: PPUSH
37490: CALL_OW 1
37494: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37495: LD_ADDR_EXP 118
37499: PUSH
37500: LD_EXP 118
37504: PPUSH
37505: LD_VAR 0 2
37509: PPUSH
37510: EMPTY
37511: PPUSH
37512: CALL_OW 1
37516: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37517: LD_ADDR_EXP 119
37521: PUSH
37522: LD_EXP 119
37526: PPUSH
37527: LD_VAR 0 2
37531: PPUSH
37532: EMPTY
37533: PPUSH
37534: CALL_OW 1
37538: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37539: LD_ADDR_EXP 120
37543: PUSH
37544: LD_EXP 120
37548: PPUSH
37549: LD_VAR 0 2
37553: PPUSH
37554: EMPTY
37555: PUSH
37556: EMPTY
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PPUSH
37562: CALL_OW 1
37566: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37567: LD_ADDR_EXP 121
37571: PUSH
37572: LD_EXP 121
37576: PPUSH
37577: LD_VAR 0 2
37581: PPUSH
37582: EMPTY
37583: PPUSH
37584: CALL_OW 1
37588: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37589: LD_ADDR_EXP 148
37593: PUSH
37594: LD_EXP 148
37598: PPUSH
37599: LD_VAR 0 2
37603: PPUSH
37604: EMPTY
37605: PPUSH
37606: CALL_OW 1
37610: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37611: LD_ADDR_EXP 122
37615: PUSH
37616: LD_EXP 122
37620: PPUSH
37621: LD_VAR 0 2
37625: PPUSH
37626: EMPTY
37627: PPUSH
37628: CALL_OW 1
37632: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37633: LD_ADDR_EXP 123
37637: PUSH
37638: LD_EXP 123
37642: PPUSH
37643: LD_VAR 0 2
37647: PPUSH
37648: EMPTY
37649: PPUSH
37650: CALL_OW 1
37654: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37655: LD_ADDR_EXP 124
37659: PUSH
37660: LD_EXP 124
37664: PPUSH
37665: LD_VAR 0 2
37669: PPUSH
37670: LD_EXP 116
37674: PUSH
37675: LD_VAR 0 2
37679: ARRAY
37680: PPUSH
37681: LD_INT 2
37683: PUSH
37684: LD_INT 30
37686: PUSH
37687: LD_INT 32
37689: PUSH
37690: EMPTY
37691: LIST
37692: LIST
37693: PUSH
37694: LD_INT 30
37696: PUSH
37697: LD_INT 33
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: LIST
37708: PPUSH
37709: CALL_OW 72
37713: PPUSH
37714: CALL_OW 1
37718: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37719: LD_ADDR_EXP 125
37723: PUSH
37724: LD_EXP 125
37728: PPUSH
37729: LD_VAR 0 2
37733: PPUSH
37734: LD_EXP 116
37738: PUSH
37739: LD_VAR 0 2
37743: ARRAY
37744: PPUSH
37745: LD_INT 2
37747: PUSH
37748: LD_INT 30
37750: PUSH
37751: LD_INT 32
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 30
37760: PUSH
37761: LD_INT 31
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: LIST
37772: PUSH
37773: LD_INT 58
37775: PUSH
37776: EMPTY
37777: LIST
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PPUSH
37783: CALL_OW 72
37787: PPUSH
37788: CALL_OW 1
37792: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37793: LD_ADDR_EXP 126
37797: PUSH
37798: LD_EXP 126
37802: PPUSH
37803: LD_VAR 0 2
37807: PPUSH
37808: EMPTY
37809: PPUSH
37810: CALL_OW 1
37814: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37815: LD_ADDR_EXP 130
37819: PUSH
37820: LD_EXP 130
37824: PPUSH
37825: LD_VAR 0 2
37829: PPUSH
37830: EMPTY
37831: PPUSH
37832: CALL_OW 1
37836: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37837: LD_ADDR_EXP 129
37841: PUSH
37842: LD_EXP 129
37846: PPUSH
37847: LD_VAR 0 2
37851: PPUSH
37852: EMPTY
37853: PPUSH
37854: CALL_OW 1
37858: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37859: LD_ADDR_EXP 131
37863: PUSH
37864: LD_EXP 131
37868: PPUSH
37869: LD_VAR 0 2
37873: PPUSH
37874: EMPTY
37875: PPUSH
37876: CALL_OW 1
37880: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37881: LD_ADDR_EXP 132
37885: PUSH
37886: LD_EXP 132
37890: PPUSH
37891: LD_VAR 0 2
37895: PPUSH
37896: EMPTY
37897: PPUSH
37898: CALL_OW 1
37902: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37903: LD_ADDR_EXP 133
37907: PUSH
37908: LD_EXP 133
37912: PPUSH
37913: LD_VAR 0 2
37917: PPUSH
37918: EMPTY
37919: PPUSH
37920: CALL_OW 1
37924: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37925: LD_ADDR_EXP 134
37929: PUSH
37930: LD_EXP 134
37934: PPUSH
37935: LD_VAR 0 2
37939: PPUSH
37940: EMPTY
37941: PPUSH
37942: CALL_OW 1
37946: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37947: LD_ADDR_EXP 135
37951: PUSH
37952: LD_EXP 135
37956: PPUSH
37957: LD_VAR 0 2
37961: PPUSH
37962: EMPTY
37963: PPUSH
37964: CALL_OW 1
37968: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37969: LD_ADDR_EXP 136
37973: PUSH
37974: LD_EXP 136
37978: PPUSH
37979: LD_VAR 0 2
37983: PPUSH
37984: EMPTY
37985: PPUSH
37986: CALL_OW 1
37990: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37991: LD_ADDR_EXP 137
37995: PUSH
37996: LD_EXP 137
38000: PPUSH
38001: LD_VAR 0 2
38005: PPUSH
38006: EMPTY
38007: PPUSH
38008: CALL_OW 1
38012: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38013: LD_ADDR_EXP 138
38017: PUSH
38018: LD_EXP 138
38022: PPUSH
38023: LD_VAR 0 2
38027: PPUSH
38028: EMPTY
38029: PPUSH
38030: CALL_OW 1
38034: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
38035: LD_ADDR_EXP 127
38039: PUSH
38040: LD_EXP 127
38044: PPUSH
38045: LD_VAR 0 2
38049: PPUSH
38050: LD_INT 0
38052: PPUSH
38053: CALL_OW 1
38057: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
38058: LD_ADDR_EXP 140
38062: PUSH
38063: LD_EXP 140
38067: PPUSH
38068: LD_VAR 0 2
38072: PPUSH
38073: LD_INT 0
38075: PPUSH
38076: CALL_OW 1
38080: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38081: LD_ADDR_EXP 128
38085: PUSH
38086: LD_EXP 128
38090: PPUSH
38091: LD_VAR 0 2
38095: PPUSH
38096: EMPTY
38097: PPUSH
38098: CALL_OW 1
38102: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
38103: LD_ADDR_EXP 139
38107: PUSH
38108: LD_EXP 139
38112: PPUSH
38113: LD_VAR 0 2
38117: PPUSH
38118: LD_INT 0
38120: PPUSH
38121: CALL_OW 1
38125: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38126: LD_ADDR_EXP 141
38130: PUSH
38131: LD_EXP 141
38135: PPUSH
38136: LD_VAR 0 2
38140: PPUSH
38141: EMPTY
38142: PPUSH
38143: CALL_OW 1
38147: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38148: LD_ADDR_EXP 144
38152: PUSH
38153: LD_EXP 144
38157: PPUSH
38158: LD_VAR 0 2
38162: PPUSH
38163: LD_INT 0
38165: PPUSH
38166: CALL_OW 1
38170: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38171: LD_ADDR_EXP 145
38175: PUSH
38176: LD_EXP 145
38180: PPUSH
38181: LD_VAR 0 2
38185: PPUSH
38186: EMPTY
38187: PPUSH
38188: CALL_OW 1
38192: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38193: LD_ADDR_EXP 146
38197: PUSH
38198: LD_EXP 146
38202: PPUSH
38203: LD_VAR 0 2
38207: PPUSH
38208: EMPTY
38209: PPUSH
38210: CALL_OW 1
38214: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38215: LD_ADDR_EXP 147
38219: PUSH
38220: LD_EXP 147
38224: PPUSH
38225: LD_VAR 0 2
38229: PPUSH
38230: EMPTY
38231: PPUSH
38232: CALL_OW 1
38236: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38237: LD_ADDR_EXP 149
38241: PUSH
38242: LD_EXP 149
38246: PPUSH
38247: LD_VAR 0 2
38251: PPUSH
38252: LD_EXP 116
38256: PUSH
38257: LD_VAR 0 2
38261: ARRAY
38262: PPUSH
38263: LD_INT 2
38265: PUSH
38266: LD_INT 30
38268: PUSH
38269: LD_INT 6
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 30
38278: PUSH
38279: LD_INT 7
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 30
38288: PUSH
38289: LD_INT 8
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: LIST
38300: LIST
38301: PPUSH
38302: CALL_OW 72
38306: PPUSH
38307: CALL_OW 1
38311: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38312: LD_ADDR_EXP 150
38316: PUSH
38317: LD_EXP 150
38321: PPUSH
38322: LD_VAR 0 2
38326: PPUSH
38327: EMPTY
38328: PPUSH
38329: CALL_OW 1
38333: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38334: LD_ADDR_EXP 151
38338: PUSH
38339: LD_EXP 151
38343: PPUSH
38344: LD_VAR 0 2
38348: PPUSH
38349: EMPTY
38350: PPUSH
38351: CALL_OW 1
38355: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38356: LD_ADDR_EXP 152
38360: PUSH
38361: LD_EXP 152
38365: PPUSH
38366: LD_VAR 0 2
38370: PPUSH
38371: EMPTY
38372: PPUSH
38373: CALL_OW 1
38377: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38378: LD_ADDR_EXP 153
38382: PUSH
38383: LD_EXP 153
38387: PPUSH
38388: LD_VAR 0 2
38392: PPUSH
38393: EMPTY
38394: PPUSH
38395: CALL_OW 1
38399: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38400: LD_ADDR_EXP 154
38404: PUSH
38405: LD_EXP 154
38409: PPUSH
38410: LD_VAR 0 2
38414: PPUSH
38415: EMPTY
38416: PPUSH
38417: CALL_OW 1
38421: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38422: LD_ADDR_EXP 155
38426: PUSH
38427: LD_EXP 155
38431: PPUSH
38432: LD_VAR 0 2
38436: PPUSH
38437: EMPTY
38438: PPUSH
38439: CALL_OW 1
38443: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38444: LD_ADDR_EXP 156
38448: PUSH
38449: LD_EXP 156
38453: PPUSH
38454: LD_VAR 0 2
38458: PPUSH
38459: EMPTY
38460: PPUSH
38461: CALL_OW 1
38465: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38466: LD_ADDR_EXP 157
38470: PUSH
38471: LD_EXP 157
38475: PPUSH
38476: LD_VAR 0 2
38480: PPUSH
38481: EMPTY
38482: PPUSH
38483: CALL_OW 1
38487: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38488: LD_ADDR_EXP 158
38492: PUSH
38493: LD_EXP 158
38497: PPUSH
38498: LD_VAR 0 2
38502: PPUSH
38503: LD_INT 0
38505: PPUSH
38506: CALL_OW 1
38510: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38511: LD_ADDR_EXP 159
38515: PUSH
38516: LD_EXP 159
38520: PPUSH
38521: LD_VAR 0 2
38525: PPUSH
38526: LD_INT 0
38528: PPUSH
38529: CALL_OW 1
38533: ST_TO_ADDR
// end ;
38534: GO 37435
38536: POP
38537: POP
// MC_InitSides ( ) ;
38538: CALL 38824 0 0
// MC_InitResearch ( ) ;
38542: CALL 38563 0 0
// CustomInitMacro ( ) ;
38546: CALL 471 0 0
// skirmish := true ;
38550: LD_ADDR_EXP 114
38554: PUSH
38555: LD_INT 1
38557: ST_TO_ADDR
// end ;
38558: LD_VAR 0 1
38562: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38563: LD_INT 0
38565: PPUSH
38566: PPUSH
38567: PPUSH
38568: PPUSH
38569: PPUSH
38570: PPUSH
// if not mc_bases then
38571: LD_EXP 116
38575: NOT
38576: IFFALSE 38580
// exit ;
38578: GO 38819
// for i = 1 to 8 do
38580: LD_ADDR_VAR 0 2
38584: PUSH
38585: DOUBLE
38586: LD_INT 1
38588: DEC
38589: ST_TO_ADDR
38590: LD_INT 8
38592: PUSH
38593: FOR_TO
38594: IFFALSE 38620
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38596: LD_ADDR_EXP 143
38600: PUSH
38601: LD_EXP 143
38605: PPUSH
38606: LD_VAR 0 2
38610: PPUSH
38611: EMPTY
38612: PPUSH
38613: CALL_OW 1
38617: ST_TO_ADDR
38618: GO 38593
38620: POP
38621: POP
// tmp := [ ] ;
38622: LD_ADDR_VAR 0 5
38626: PUSH
38627: EMPTY
38628: ST_TO_ADDR
// for i = 1 to mc_sides do
38629: LD_ADDR_VAR 0 2
38633: PUSH
38634: DOUBLE
38635: LD_INT 1
38637: DEC
38638: ST_TO_ADDR
38639: LD_EXP 142
38643: PUSH
38644: FOR_TO
38645: IFFALSE 38703
// if not mc_sides [ i ] in tmp then
38647: LD_EXP 142
38651: PUSH
38652: LD_VAR 0 2
38656: ARRAY
38657: PUSH
38658: LD_VAR 0 5
38662: IN
38663: NOT
38664: IFFALSE 38701
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38666: LD_ADDR_VAR 0 5
38670: PUSH
38671: LD_VAR 0 5
38675: PPUSH
38676: LD_VAR 0 5
38680: PUSH
38681: LD_INT 1
38683: PLUS
38684: PPUSH
38685: LD_EXP 142
38689: PUSH
38690: LD_VAR 0 2
38694: ARRAY
38695: PPUSH
38696: CALL_OW 2
38700: ST_TO_ADDR
38701: GO 38644
38703: POP
38704: POP
// if not tmp then
38705: LD_VAR 0 5
38709: NOT
38710: IFFALSE 38714
// exit ;
38712: GO 38819
// for j in tmp do
38714: LD_ADDR_VAR 0 3
38718: PUSH
38719: LD_VAR 0 5
38723: PUSH
38724: FOR_IN
38725: IFFALSE 38817
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38727: LD_ADDR_VAR 0 6
38731: PUSH
38732: LD_INT 22
38734: PUSH
38735: LD_VAR 0 3
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PPUSH
38744: CALL_OW 69
38748: ST_TO_ADDR
// if not un then
38749: LD_VAR 0 6
38753: NOT
38754: IFFALSE 38758
// continue ;
38756: GO 38724
// nation := GetNation ( un [ 1 ] ) ;
38758: LD_ADDR_VAR 0 4
38762: PUSH
38763: LD_VAR 0 6
38767: PUSH
38768: LD_INT 1
38770: ARRAY
38771: PPUSH
38772: CALL_OW 248
38776: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38777: LD_ADDR_EXP 143
38781: PUSH
38782: LD_EXP 143
38786: PPUSH
38787: LD_VAR 0 3
38791: PPUSH
38792: LD_VAR 0 3
38796: PPUSH
38797: LD_VAR 0 4
38801: PPUSH
38802: LD_INT 1
38804: PPUSH
38805: CALL 65940 0 3
38809: PPUSH
38810: CALL_OW 1
38814: ST_TO_ADDR
// end ;
38815: GO 38724
38817: POP
38818: POP
// end ;
38819: LD_VAR 0 1
38823: RET
// export function MC_InitSides ( ) ; var i ; begin
38824: LD_INT 0
38826: PPUSH
38827: PPUSH
// if not mc_bases then
38828: LD_EXP 116
38832: NOT
38833: IFFALSE 38837
// exit ;
38835: GO 38911
// for i = 1 to mc_bases do
38837: LD_ADDR_VAR 0 2
38841: PUSH
38842: DOUBLE
38843: LD_INT 1
38845: DEC
38846: ST_TO_ADDR
38847: LD_EXP 116
38851: PUSH
38852: FOR_TO
38853: IFFALSE 38909
// if mc_bases [ i ] then
38855: LD_EXP 116
38859: PUSH
38860: LD_VAR 0 2
38864: ARRAY
38865: IFFALSE 38907
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38867: LD_ADDR_EXP 142
38871: PUSH
38872: LD_EXP 142
38876: PPUSH
38877: LD_VAR 0 2
38881: PPUSH
38882: LD_EXP 116
38886: PUSH
38887: LD_VAR 0 2
38891: ARRAY
38892: PUSH
38893: LD_INT 1
38895: ARRAY
38896: PPUSH
38897: CALL_OW 255
38901: PPUSH
38902: CALL_OW 1
38906: ST_TO_ADDR
38907: GO 38852
38909: POP
38910: POP
// end ;
38911: LD_VAR 0 1
38915: RET
// every 0 0$03 trigger skirmish do
38916: LD_EXP 114
38920: IFFALSE 39074
38922: GO 38924
38924: DISABLE
// begin enable ;
38925: ENABLE
// MC_CheckBuildings ( ) ;
38926: CALL 43572 0 0
// MC_CheckPeopleLife ( ) ;
38930: CALL 43733 0 0
// RaiseSailEvent ( 100 ) ;
38934: LD_INT 100
38936: PPUSH
38937: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38941: LD_INT 103
38943: PPUSH
38944: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38948: LD_INT 104
38950: PPUSH
38951: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38955: LD_INT 105
38957: PPUSH
38958: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38962: LD_INT 106
38964: PPUSH
38965: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38969: LD_INT 107
38971: PPUSH
38972: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38976: LD_INT 108
38978: PPUSH
38979: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38983: LD_INT 109
38985: PPUSH
38986: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38990: LD_INT 110
38992: PPUSH
38993: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38997: LD_INT 111
38999: PPUSH
39000: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
39004: LD_INT 112
39006: PPUSH
39007: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
39011: LD_INT 113
39013: PPUSH
39014: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
39018: LD_INT 120
39020: PPUSH
39021: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
39025: LD_INT 121
39027: PPUSH
39028: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
39032: LD_INT 122
39034: PPUSH
39035: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
39039: LD_INT 123
39041: PPUSH
39042: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
39046: LD_INT 124
39048: PPUSH
39049: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
39053: LD_INT 125
39055: PPUSH
39056: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
39060: LD_INT 126
39062: PPUSH
39063: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
39067: LD_INT 200
39069: PPUSH
39070: CALL_OW 427
// end ;
39074: END
// on SailEvent ( event ) do begin if event < 100 then
39075: LD_VAR 0 1
39079: PUSH
39080: LD_INT 100
39082: LESS
39083: IFFALSE 39094
// CustomEvent ( event ) ;
39085: LD_VAR 0 1
39089: PPUSH
39090: CALL 33550 0 1
// if event = 100 then
39094: LD_VAR 0 1
39098: PUSH
39099: LD_INT 100
39101: EQUAL
39102: IFFALSE 39108
// MC_ClassManager ( ) ;
39104: CALL 39500 0 0
// if event = 101 then
39108: LD_VAR 0 1
39112: PUSH
39113: LD_INT 101
39115: EQUAL
39116: IFFALSE 39122
// MC_RepairBuildings ( ) ;
39118: CALL 44318 0 0
// if event = 102 then
39122: LD_VAR 0 1
39126: PUSH
39127: LD_INT 102
39129: EQUAL
39130: IFFALSE 39136
// MC_Heal ( ) ;
39132: CALL 45225 0 0
// if event = 103 then
39136: LD_VAR 0 1
39140: PUSH
39141: LD_INT 103
39143: EQUAL
39144: IFFALSE 39150
// MC_Build ( ) ;
39146: CALL 45647 0 0
// if event = 104 then
39150: LD_VAR 0 1
39154: PUSH
39155: LD_INT 104
39157: EQUAL
39158: IFFALSE 39164
// MC_TurretWeapon ( ) ;
39160: CALL 47288 0 0
// if event = 105 then
39164: LD_VAR 0 1
39168: PUSH
39169: LD_INT 105
39171: EQUAL
39172: IFFALSE 39178
// MC_BuildUpgrade ( ) ;
39174: CALL 46839 0 0
// if event = 106 then
39178: LD_VAR 0 1
39182: PUSH
39183: LD_INT 106
39185: EQUAL
39186: IFFALSE 39192
// MC_PlantMines ( ) ;
39188: CALL 47718 0 0
// if event = 107 then
39192: LD_VAR 0 1
39196: PUSH
39197: LD_INT 107
39199: EQUAL
39200: IFFALSE 39206
// MC_CollectCrates ( ) ;
39202: CALL 48509 0 0
// if event = 108 then
39206: LD_VAR 0 1
39210: PUSH
39211: LD_INT 108
39213: EQUAL
39214: IFFALSE 39220
// MC_LinkRemoteControl ( ) ;
39216: CALL 50359 0 0
// if event = 109 then
39220: LD_VAR 0 1
39224: PUSH
39225: LD_INT 109
39227: EQUAL
39228: IFFALSE 39234
// MC_ProduceVehicle ( ) ;
39230: CALL 50540 0 0
// if event = 110 then
39234: LD_VAR 0 1
39238: PUSH
39239: LD_INT 110
39241: EQUAL
39242: IFFALSE 39248
// MC_SendAttack ( ) ;
39244: CALL 51006 0 0
// if event = 111 then
39248: LD_VAR 0 1
39252: PUSH
39253: LD_INT 111
39255: EQUAL
39256: IFFALSE 39262
// MC_Defend ( ) ;
39258: CALL 51114 0 0
// if event = 112 then
39262: LD_VAR 0 1
39266: PUSH
39267: LD_INT 112
39269: EQUAL
39270: IFFALSE 39276
// MC_Research ( ) ;
39272: CALL 51994 0 0
// if event = 113 then
39276: LD_VAR 0 1
39280: PUSH
39281: LD_INT 113
39283: EQUAL
39284: IFFALSE 39290
// MC_MinesTrigger ( ) ;
39286: CALL 53108 0 0
// if event = 120 then
39290: LD_VAR 0 1
39294: PUSH
39295: LD_INT 120
39297: EQUAL
39298: IFFALSE 39304
// MC_RepairVehicle ( ) ;
39300: CALL 53207 0 0
// if event = 121 then
39304: LD_VAR 0 1
39308: PUSH
39309: LD_INT 121
39311: EQUAL
39312: IFFALSE 39318
// MC_TameApe ( ) ;
39314: CALL 53948 0 0
// if event = 122 then
39318: LD_VAR 0 1
39322: PUSH
39323: LD_INT 122
39325: EQUAL
39326: IFFALSE 39332
// MC_ChangeApeClass ( ) ;
39328: CALL 54777 0 0
// if event = 123 then
39332: LD_VAR 0 1
39336: PUSH
39337: LD_INT 123
39339: EQUAL
39340: IFFALSE 39346
// MC_Bazooka ( ) ;
39342: CALL 55427 0 0
// if event = 124 then
39346: LD_VAR 0 1
39350: PUSH
39351: LD_INT 124
39353: EQUAL
39354: IFFALSE 39360
// MC_TeleportExit ( ) ;
39356: CALL 55625 0 0
// if event = 125 then
39360: LD_VAR 0 1
39364: PUSH
39365: LD_INT 125
39367: EQUAL
39368: IFFALSE 39374
// MC_Deposits ( ) ;
39370: CALL 56272 0 0
// if event = 126 then
39374: LD_VAR 0 1
39378: PUSH
39379: LD_INT 126
39381: EQUAL
39382: IFFALSE 39388
// MC_RemoteDriver ( ) ;
39384: CALL 56897 0 0
// if event = 200 then
39388: LD_VAR 0 1
39392: PUSH
39393: LD_INT 200
39395: EQUAL
39396: IFFALSE 39402
// MC_Idle ( ) ;
39398: CALL 58846 0 0
// end ;
39402: PPOPN 1
39404: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39405: LD_INT 0
39407: PPUSH
39408: PPUSH
// if not mc_bases [ base ] or not tag then
39409: LD_EXP 116
39413: PUSH
39414: LD_VAR 0 1
39418: ARRAY
39419: NOT
39420: PUSH
39421: LD_VAR 0 2
39425: NOT
39426: OR
39427: IFFALSE 39431
// exit ;
39429: GO 39495
// for i in mc_bases [ base ] union mc_ape [ base ] do
39431: LD_ADDR_VAR 0 4
39435: PUSH
39436: LD_EXP 116
39440: PUSH
39441: LD_VAR 0 1
39445: ARRAY
39446: PUSH
39447: LD_EXP 145
39451: PUSH
39452: LD_VAR 0 1
39456: ARRAY
39457: UNION
39458: PUSH
39459: FOR_IN
39460: IFFALSE 39493
// if GetTag ( i ) = tag then
39462: LD_VAR 0 4
39466: PPUSH
39467: CALL_OW 110
39471: PUSH
39472: LD_VAR 0 2
39476: EQUAL
39477: IFFALSE 39491
// SetTag ( i , 0 ) ;
39479: LD_VAR 0 4
39483: PPUSH
39484: LD_INT 0
39486: PPUSH
39487: CALL_OW 109
39491: GO 39459
39493: POP
39494: POP
// end ;
39495: LD_VAR 0 3
39499: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39500: LD_INT 0
39502: PPUSH
39503: PPUSH
39504: PPUSH
39505: PPUSH
39506: PPUSH
39507: PPUSH
39508: PPUSH
39509: PPUSH
// if not mc_bases then
39510: LD_EXP 116
39514: NOT
39515: IFFALSE 39519
// exit ;
39517: GO 39977
// for i = 1 to mc_bases do
39519: LD_ADDR_VAR 0 2
39523: PUSH
39524: DOUBLE
39525: LD_INT 1
39527: DEC
39528: ST_TO_ADDR
39529: LD_EXP 116
39533: PUSH
39534: FOR_TO
39535: IFFALSE 39975
// begin tmp := MC_ClassCheckReq ( i ) ;
39537: LD_ADDR_VAR 0 4
39541: PUSH
39542: LD_VAR 0 2
39546: PPUSH
39547: CALL 39982 0 1
39551: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39552: LD_ADDR_EXP 157
39556: PUSH
39557: LD_EXP 157
39561: PPUSH
39562: LD_VAR 0 2
39566: PPUSH
39567: LD_VAR 0 4
39571: PPUSH
39572: CALL_OW 1
39576: ST_TO_ADDR
// if not tmp then
39577: LD_VAR 0 4
39581: NOT
39582: IFFALSE 39586
// continue ;
39584: GO 39534
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39586: LD_ADDR_VAR 0 6
39590: PUSH
39591: LD_EXP 116
39595: PUSH
39596: LD_VAR 0 2
39600: ARRAY
39601: PPUSH
39602: LD_INT 2
39604: PUSH
39605: LD_INT 30
39607: PUSH
39608: LD_INT 4
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 30
39617: PUSH
39618: LD_INT 5
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: LIST
39629: PPUSH
39630: CALL_OW 72
39634: PUSH
39635: LD_EXP 116
39639: PUSH
39640: LD_VAR 0 2
39644: ARRAY
39645: PPUSH
39646: LD_INT 2
39648: PUSH
39649: LD_INT 30
39651: PUSH
39652: LD_INT 0
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 30
39661: PUSH
39662: LD_INT 1
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: LIST
39673: PPUSH
39674: CALL_OW 72
39678: PUSH
39679: LD_EXP 116
39683: PUSH
39684: LD_VAR 0 2
39688: ARRAY
39689: PPUSH
39690: LD_INT 30
39692: PUSH
39693: LD_INT 3
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PPUSH
39700: CALL_OW 72
39704: PUSH
39705: LD_EXP 116
39709: PUSH
39710: LD_VAR 0 2
39714: ARRAY
39715: PPUSH
39716: LD_INT 2
39718: PUSH
39719: LD_INT 30
39721: PUSH
39722: LD_INT 6
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 30
39731: PUSH
39732: LD_INT 7
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 30
39741: PUSH
39742: LD_INT 8
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: PPUSH
39755: CALL_OW 72
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: LIST
39764: LIST
39765: ST_TO_ADDR
// for j = 1 to 4 do
39766: LD_ADDR_VAR 0 3
39770: PUSH
39771: DOUBLE
39772: LD_INT 1
39774: DEC
39775: ST_TO_ADDR
39776: LD_INT 4
39778: PUSH
39779: FOR_TO
39780: IFFALSE 39971
// begin if not tmp [ j ] then
39782: LD_VAR 0 4
39786: PUSH
39787: LD_VAR 0 3
39791: ARRAY
39792: NOT
39793: IFFALSE 39797
// continue ;
39795: GO 39779
// for p in tmp [ j ] do
39797: LD_ADDR_VAR 0 5
39801: PUSH
39802: LD_VAR 0 4
39806: PUSH
39807: LD_VAR 0 3
39811: ARRAY
39812: PUSH
39813: FOR_IN
39814: IFFALSE 39967
// begin if not b [ j ] then
39816: LD_VAR 0 6
39820: PUSH
39821: LD_VAR 0 3
39825: ARRAY
39826: NOT
39827: IFFALSE 39831
// break ;
39829: GO 39967
// e := 0 ;
39831: LD_ADDR_VAR 0 7
39835: PUSH
39836: LD_INT 0
39838: ST_TO_ADDR
// for k in b [ j ] do
39839: LD_ADDR_VAR 0 8
39843: PUSH
39844: LD_VAR 0 6
39848: PUSH
39849: LD_VAR 0 3
39853: ARRAY
39854: PUSH
39855: FOR_IN
39856: IFFALSE 39883
// if IsNotFull ( k ) then
39858: LD_VAR 0 8
39862: PPUSH
39863: CALL 68093 0 1
39867: IFFALSE 39881
// begin e := k ;
39869: LD_ADDR_VAR 0 7
39873: PUSH
39874: LD_VAR 0 8
39878: ST_TO_ADDR
// break ;
39879: GO 39883
// end ;
39881: GO 39855
39883: POP
39884: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39885: LD_VAR 0 7
39889: PUSH
39890: LD_VAR 0 5
39894: PPUSH
39895: LD_VAR 0 7
39899: PPUSH
39900: CALL 101257 0 2
39904: NOT
39905: AND
39906: IFFALSE 39965
// begin if IsInUnit ( p ) then
39908: LD_VAR 0 5
39912: PPUSH
39913: CALL_OW 310
39917: IFFALSE 39928
// ComExitBuilding ( p ) ;
39919: LD_VAR 0 5
39923: PPUSH
39924: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39928: LD_VAR 0 5
39932: PPUSH
39933: LD_VAR 0 7
39937: PPUSH
39938: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39942: LD_VAR 0 5
39946: PPUSH
39947: LD_VAR 0 3
39951: PPUSH
39952: CALL_OW 183
// AddComExitBuilding ( p ) ;
39956: LD_VAR 0 5
39960: PPUSH
39961: CALL_OW 182
// end ; end ;
39965: GO 39813
39967: POP
39968: POP
// end ;
39969: GO 39779
39971: POP
39972: POP
// end ;
39973: GO 39534
39975: POP
39976: POP
// end ;
39977: LD_VAR 0 1
39981: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39982: LD_INT 0
39984: PPUSH
39985: PPUSH
39986: PPUSH
39987: PPUSH
39988: PPUSH
39989: PPUSH
39990: PPUSH
39991: PPUSH
39992: PPUSH
39993: PPUSH
39994: PPUSH
39995: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39996: LD_VAR 0 1
40000: NOT
40001: PUSH
40002: LD_EXP 116
40006: PUSH
40007: LD_VAR 0 1
40011: ARRAY
40012: NOT
40013: OR
40014: PUSH
40015: LD_EXP 116
40019: PUSH
40020: LD_VAR 0 1
40024: ARRAY
40025: PPUSH
40026: LD_INT 2
40028: PUSH
40029: LD_INT 30
40031: PUSH
40032: LD_INT 0
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: LD_INT 30
40041: PUSH
40042: LD_INT 1
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: LIST
40053: PPUSH
40054: CALL_OW 72
40058: NOT
40059: OR
40060: IFFALSE 40064
// exit ;
40062: GO 43567
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40064: LD_ADDR_VAR 0 4
40068: PUSH
40069: LD_EXP 116
40073: PUSH
40074: LD_VAR 0 1
40078: ARRAY
40079: PPUSH
40080: LD_INT 2
40082: PUSH
40083: LD_INT 25
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 25
40095: PUSH
40096: LD_INT 2
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 25
40105: PUSH
40106: LD_INT 3
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 25
40115: PUSH
40116: LD_INT 4
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 25
40125: PUSH
40126: LD_INT 5
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: LD_INT 25
40135: PUSH
40136: LD_INT 8
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 25
40145: PUSH
40146: LD_INT 9
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: LIST
40162: PPUSH
40163: CALL_OW 72
40167: ST_TO_ADDR
// if not tmp then
40168: LD_VAR 0 4
40172: NOT
40173: IFFALSE 40177
// exit ;
40175: GO 43567
// for i in tmp do
40177: LD_ADDR_VAR 0 3
40181: PUSH
40182: LD_VAR 0 4
40186: PUSH
40187: FOR_IN
40188: IFFALSE 40219
// if GetTag ( i ) then
40190: LD_VAR 0 3
40194: PPUSH
40195: CALL_OW 110
40199: IFFALSE 40217
// tmp := tmp diff i ;
40201: LD_ADDR_VAR 0 4
40205: PUSH
40206: LD_VAR 0 4
40210: PUSH
40211: LD_VAR 0 3
40215: DIFF
40216: ST_TO_ADDR
40217: GO 40187
40219: POP
40220: POP
// if not tmp then
40221: LD_VAR 0 4
40225: NOT
40226: IFFALSE 40230
// exit ;
40228: GO 43567
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40230: LD_ADDR_VAR 0 5
40234: PUSH
40235: LD_EXP 116
40239: PUSH
40240: LD_VAR 0 1
40244: ARRAY
40245: PPUSH
40246: LD_INT 2
40248: PUSH
40249: LD_INT 25
40251: PUSH
40252: LD_INT 1
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: LD_INT 25
40261: PUSH
40262: LD_INT 5
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 25
40271: PUSH
40272: LD_INT 8
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 25
40281: PUSH
40282: LD_INT 9
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: EMPTY
40290: LIST
40291: LIST
40292: LIST
40293: LIST
40294: LIST
40295: PPUSH
40296: CALL_OW 72
40300: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40301: LD_ADDR_VAR 0 6
40305: PUSH
40306: LD_EXP 116
40310: PUSH
40311: LD_VAR 0 1
40315: ARRAY
40316: PPUSH
40317: LD_INT 25
40319: PUSH
40320: LD_INT 2
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PPUSH
40327: CALL_OW 72
40331: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40332: LD_ADDR_VAR 0 7
40336: PUSH
40337: LD_EXP 116
40341: PUSH
40342: LD_VAR 0 1
40346: ARRAY
40347: PPUSH
40348: LD_INT 25
40350: PUSH
40351: LD_INT 3
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PPUSH
40358: CALL_OW 72
40362: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40363: LD_ADDR_VAR 0 8
40367: PUSH
40368: LD_EXP 116
40372: PUSH
40373: LD_VAR 0 1
40377: ARRAY
40378: PPUSH
40379: LD_INT 25
40381: PUSH
40382: LD_INT 4
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 24
40391: PUSH
40392: LD_INT 251
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PPUSH
40403: CALL_OW 72
40407: ST_TO_ADDR
// if mc_is_defending [ base ] then
40408: LD_EXP 159
40412: PUSH
40413: LD_VAR 0 1
40417: ARRAY
40418: IFFALSE 40879
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40420: LD_ADDR_EXP 158
40424: PUSH
40425: LD_EXP 158
40429: PPUSH
40430: LD_VAR 0 1
40434: PPUSH
40435: LD_INT 4
40437: PPUSH
40438: CALL_OW 1
40442: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40443: LD_ADDR_VAR 0 12
40447: PUSH
40448: LD_EXP 116
40452: PUSH
40453: LD_VAR 0 1
40457: ARRAY
40458: PPUSH
40459: LD_INT 2
40461: PUSH
40462: LD_INT 30
40464: PUSH
40465: LD_INT 4
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: LD_INT 30
40474: PUSH
40475: LD_INT 5
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: LIST
40486: PPUSH
40487: CALL_OW 72
40491: ST_TO_ADDR
// if not b then
40492: LD_VAR 0 12
40496: NOT
40497: IFFALSE 40501
// exit ;
40499: GO 43567
// p := [ ] ;
40501: LD_ADDR_VAR 0 11
40505: PUSH
40506: EMPTY
40507: ST_TO_ADDR
// if sci >= 2 then
40508: LD_VAR 0 8
40512: PUSH
40513: LD_INT 2
40515: GREATEREQUAL
40516: IFFALSE 40547
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40518: LD_ADDR_VAR 0 8
40522: PUSH
40523: LD_VAR 0 8
40527: PUSH
40528: LD_INT 1
40530: ARRAY
40531: PUSH
40532: LD_VAR 0 8
40536: PUSH
40537: LD_INT 2
40539: ARRAY
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: ST_TO_ADDR
40545: GO 40608
// if sci = 1 then
40547: LD_VAR 0 8
40551: PUSH
40552: LD_INT 1
40554: EQUAL
40555: IFFALSE 40576
// sci := [ sci [ 1 ] ] else
40557: LD_ADDR_VAR 0 8
40561: PUSH
40562: LD_VAR 0 8
40566: PUSH
40567: LD_INT 1
40569: ARRAY
40570: PUSH
40571: EMPTY
40572: LIST
40573: ST_TO_ADDR
40574: GO 40608
// if sci = 0 then
40576: LD_VAR 0 8
40580: PUSH
40581: LD_INT 0
40583: EQUAL
40584: IFFALSE 40608
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40586: LD_ADDR_VAR 0 11
40590: PUSH
40591: LD_VAR 0 4
40595: PPUSH
40596: LD_INT 4
40598: PPUSH
40599: CALL 101120 0 2
40603: PUSH
40604: LD_INT 1
40606: ARRAY
40607: ST_TO_ADDR
// if eng > 4 then
40608: LD_VAR 0 6
40612: PUSH
40613: LD_INT 4
40615: GREATER
40616: IFFALSE 40662
// for i = eng downto 4 do
40618: LD_ADDR_VAR 0 3
40622: PUSH
40623: DOUBLE
40624: LD_VAR 0 6
40628: INC
40629: ST_TO_ADDR
40630: LD_INT 4
40632: PUSH
40633: FOR_DOWNTO
40634: IFFALSE 40660
// eng := eng diff eng [ i ] ;
40636: LD_ADDR_VAR 0 6
40640: PUSH
40641: LD_VAR 0 6
40645: PUSH
40646: LD_VAR 0 6
40650: PUSH
40651: LD_VAR 0 3
40655: ARRAY
40656: DIFF
40657: ST_TO_ADDR
40658: GO 40633
40660: POP
40661: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40662: LD_ADDR_VAR 0 4
40666: PUSH
40667: LD_VAR 0 4
40671: PUSH
40672: LD_VAR 0 5
40676: PUSH
40677: LD_VAR 0 6
40681: UNION
40682: PUSH
40683: LD_VAR 0 7
40687: UNION
40688: PUSH
40689: LD_VAR 0 8
40693: UNION
40694: DIFF
40695: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40696: LD_ADDR_VAR 0 13
40700: PUSH
40701: LD_EXP 116
40705: PUSH
40706: LD_VAR 0 1
40710: ARRAY
40711: PPUSH
40712: LD_INT 2
40714: PUSH
40715: LD_INT 30
40717: PUSH
40718: LD_INT 32
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 30
40727: PUSH
40728: LD_INT 31
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: LIST
40739: PPUSH
40740: CALL_OW 72
40744: PUSH
40745: LD_EXP 116
40749: PUSH
40750: LD_VAR 0 1
40754: ARRAY
40755: PPUSH
40756: LD_INT 2
40758: PUSH
40759: LD_INT 30
40761: PUSH
40762: LD_INT 4
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PUSH
40769: LD_INT 30
40771: PUSH
40772: LD_INT 5
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: LIST
40783: PPUSH
40784: CALL_OW 72
40788: PUSH
40789: LD_INT 6
40791: MUL
40792: PLUS
40793: ST_TO_ADDR
// if bcount < tmp then
40794: LD_VAR 0 13
40798: PUSH
40799: LD_VAR 0 4
40803: LESS
40804: IFFALSE 40850
// for i = tmp downto bcount do
40806: LD_ADDR_VAR 0 3
40810: PUSH
40811: DOUBLE
40812: LD_VAR 0 4
40816: INC
40817: ST_TO_ADDR
40818: LD_VAR 0 13
40822: PUSH
40823: FOR_DOWNTO
40824: IFFALSE 40848
// tmp := Delete ( tmp , tmp ) ;
40826: LD_ADDR_VAR 0 4
40830: PUSH
40831: LD_VAR 0 4
40835: PPUSH
40836: LD_VAR 0 4
40840: PPUSH
40841: CALL_OW 3
40845: ST_TO_ADDR
40846: GO 40823
40848: POP
40849: POP
// result := [ tmp , 0 , 0 , p ] ;
40850: LD_ADDR_VAR 0 2
40854: PUSH
40855: LD_VAR 0 4
40859: PUSH
40860: LD_INT 0
40862: PUSH
40863: LD_INT 0
40865: PUSH
40866: LD_VAR 0 11
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: LIST
40875: LIST
40876: ST_TO_ADDR
// exit ;
40877: GO 43567
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40879: LD_EXP 116
40883: PUSH
40884: LD_VAR 0 1
40888: ARRAY
40889: PPUSH
40890: LD_INT 2
40892: PUSH
40893: LD_INT 30
40895: PUSH
40896: LD_INT 6
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: LD_INT 30
40905: PUSH
40906: LD_INT 7
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 30
40915: PUSH
40916: LD_INT 8
40918: PUSH
40919: EMPTY
40920: LIST
40921: LIST
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: LIST
40927: LIST
40928: PPUSH
40929: CALL_OW 72
40933: NOT
40934: PUSH
40935: LD_EXP 116
40939: PUSH
40940: LD_VAR 0 1
40944: ARRAY
40945: PPUSH
40946: LD_INT 30
40948: PUSH
40949: LD_INT 3
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: PPUSH
40956: CALL_OW 72
40960: NOT
40961: AND
40962: IFFALSE 41034
// begin if eng = tmp then
40964: LD_VAR 0 6
40968: PUSH
40969: LD_VAR 0 4
40973: EQUAL
40974: IFFALSE 40978
// exit ;
40976: GO 43567
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40978: LD_ADDR_EXP 158
40982: PUSH
40983: LD_EXP 158
40987: PPUSH
40988: LD_VAR 0 1
40992: PPUSH
40993: LD_INT 1
40995: PPUSH
40996: CALL_OW 1
41000: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
41001: LD_ADDR_VAR 0 2
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: LD_VAR 0 4
41013: PUSH
41014: LD_VAR 0 6
41018: DIFF
41019: PUSH
41020: LD_INT 0
41022: PUSH
41023: LD_INT 0
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: ST_TO_ADDR
// exit ;
41032: GO 43567
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41034: LD_EXP 143
41038: PUSH
41039: LD_EXP 142
41043: PUSH
41044: LD_VAR 0 1
41048: ARRAY
41049: ARRAY
41050: PUSH
41051: LD_EXP 116
41055: PUSH
41056: LD_VAR 0 1
41060: ARRAY
41061: PPUSH
41062: LD_INT 2
41064: PUSH
41065: LD_INT 30
41067: PUSH
41068: LD_INT 6
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: LD_INT 30
41077: PUSH
41078: LD_INT 7
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 30
41087: PUSH
41088: LD_INT 8
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: PPUSH
41101: CALL_OW 72
41105: AND
41106: PUSH
41107: LD_EXP 116
41111: PUSH
41112: LD_VAR 0 1
41116: ARRAY
41117: PPUSH
41118: LD_INT 30
41120: PUSH
41121: LD_INT 3
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PPUSH
41128: CALL_OW 72
41132: NOT
41133: AND
41134: IFFALSE 41348
// begin if sci >= 6 then
41136: LD_VAR 0 8
41140: PUSH
41141: LD_INT 6
41143: GREATEREQUAL
41144: IFFALSE 41148
// exit ;
41146: GO 43567
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41148: LD_ADDR_EXP 158
41152: PUSH
41153: LD_EXP 158
41157: PPUSH
41158: LD_VAR 0 1
41162: PPUSH
41163: LD_INT 2
41165: PPUSH
41166: CALL_OW 1
41170: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41171: LD_ADDR_VAR 0 9
41175: PUSH
41176: LD_VAR 0 4
41180: PUSH
41181: LD_VAR 0 8
41185: DIFF
41186: PPUSH
41187: LD_INT 4
41189: PPUSH
41190: CALL 101120 0 2
41194: ST_TO_ADDR
// p := [ ] ;
41195: LD_ADDR_VAR 0 11
41199: PUSH
41200: EMPTY
41201: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41202: LD_VAR 0 8
41206: PUSH
41207: LD_INT 6
41209: LESS
41210: PUSH
41211: LD_VAR 0 9
41215: PUSH
41216: LD_INT 6
41218: GREATER
41219: AND
41220: IFFALSE 41301
// begin for i = 1 to 6 - sci do
41222: LD_ADDR_VAR 0 3
41226: PUSH
41227: DOUBLE
41228: LD_INT 1
41230: DEC
41231: ST_TO_ADDR
41232: LD_INT 6
41234: PUSH
41235: LD_VAR 0 8
41239: MINUS
41240: PUSH
41241: FOR_TO
41242: IFFALSE 41297
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41244: LD_ADDR_VAR 0 11
41248: PUSH
41249: LD_VAR 0 11
41253: PPUSH
41254: LD_VAR 0 11
41258: PUSH
41259: LD_INT 1
41261: PLUS
41262: PPUSH
41263: LD_VAR 0 9
41267: PUSH
41268: LD_INT 1
41270: ARRAY
41271: PPUSH
41272: CALL_OW 2
41276: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41277: LD_ADDR_VAR 0 9
41281: PUSH
41282: LD_VAR 0 9
41286: PPUSH
41287: LD_INT 1
41289: PPUSH
41290: CALL_OW 3
41294: ST_TO_ADDR
// end ;
41295: GO 41241
41297: POP
41298: POP
// end else
41299: GO 41321
// if sort then
41301: LD_VAR 0 9
41305: IFFALSE 41321
// p := sort [ 1 ] ;
41307: LD_ADDR_VAR 0 11
41311: PUSH
41312: LD_VAR 0 9
41316: PUSH
41317: LD_INT 1
41319: ARRAY
41320: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41321: LD_ADDR_VAR 0 2
41325: PUSH
41326: LD_INT 0
41328: PUSH
41329: LD_INT 0
41331: PUSH
41332: LD_INT 0
41334: PUSH
41335: LD_VAR 0 11
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: LIST
41344: LIST
41345: ST_TO_ADDR
// exit ;
41346: GO 43567
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41348: LD_EXP 143
41352: PUSH
41353: LD_EXP 142
41357: PUSH
41358: LD_VAR 0 1
41362: ARRAY
41363: ARRAY
41364: PUSH
41365: LD_EXP 116
41369: PUSH
41370: LD_VAR 0 1
41374: ARRAY
41375: PPUSH
41376: LD_INT 2
41378: PUSH
41379: LD_INT 30
41381: PUSH
41382: LD_INT 6
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 30
41391: PUSH
41392: LD_INT 7
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 30
41401: PUSH
41402: LD_INT 8
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: LIST
41413: LIST
41414: PPUSH
41415: CALL_OW 72
41419: AND
41420: PUSH
41421: LD_EXP 116
41425: PUSH
41426: LD_VAR 0 1
41430: ARRAY
41431: PPUSH
41432: LD_INT 30
41434: PUSH
41435: LD_INT 3
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PPUSH
41442: CALL_OW 72
41446: AND
41447: IFFALSE 42181
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41449: LD_ADDR_EXP 158
41453: PUSH
41454: LD_EXP 158
41458: PPUSH
41459: LD_VAR 0 1
41463: PPUSH
41464: LD_INT 3
41466: PPUSH
41467: CALL_OW 1
41471: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41472: LD_ADDR_VAR 0 2
41476: PUSH
41477: LD_INT 0
41479: PUSH
41480: LD_INT 0
41482: PUSH
41483: LD_INT 0
41485: PUSH
41486: LD_INT 0
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: LIST
41493: LIST
41494: ST_TO_ADDR
// if not eng then
41495: LD_VAR 0 6
41499: NOT
41500: IFFALSE 41563
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41502: LD_ADDR_VAR 0 11
41506: PUSH
41507: LD_VAR 0 4
41511: PPUSH
41512: LD_INT 2
41514: PPUSH
41515: CALL 101120 0 2
41519: PUSH
41520: LD_INT 1
41522: ARRAY
41523: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41524: LD_ADDR_VAR 0 2
41528: PUSH
41529: LD_VAR 0 2
41533: PPUSH
41534: LD_INT 2
41536: PPUSH
41537: LD_VAR 0 11
41541: PPUSH
41542: CALL_OW 1
41546: ST_TO_ADDR
// tmp := tmp diff p ;
41547: LD_ADDR_VAR 0 4
41551: PUSH
41552: LD_VAR 0 4
41556: PUSH
41557: LD_VAR 0 11
41561: DIFF
41562: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41563: LD_VAR 0 4
41567: PUSH
41568: LD_VAR 0 8
41572: PUSH
41573: LD_INT 6
41575: LESS
41576: AND
41577: IFFALSE 41765
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41579: LD_ADDR_VAR 0 9
41583: PUSH
41584: LD_VAR 0 4
41588: PUSH
41589: LD_VAR 0 8
41593: PUSH
41594: LD_VAR 0 7
41598: UNION
41599: DIFF
41600: PPUSH
41601: LD_INT 4
41603: PPUSH
41604: CALL 101120 0 2
41608: ST_TO_ADDR
// p := [ ] ;
41609: LD_ADDR_VAR 0 11
41613: PUSH
41614: EMPTY
41615: ST_TO_ADDR
// if sort then
41616: LD_VAR 0 9
41620: IFFALSE 41736
// for i = 1 to 6 - sci do
41622: LD_ADDR_VAR 0 3
41626: PUSH
41627: DOUBLE
41628: LD_INT 1
41630: DEC
41631: ST_TO_ADDR
41632: LD_INT 6
41634: PUSH
41635: LD_VAR 0 8
41639: MINUS
41640: PUSH
41641: FOR_TO
41642: IFFALSE 41734
// begin if i = sort then
41644: LD_VAR 0 3
41648: PUSH
41649: LD_VAR 0 9
41653: EQUAL
41654: IFFALSE 41658
// break ;
41656: GO 41734
// if GetClass ( i ) = 4 then
41658: LD_VAR 0 3
41662: PPUSH
41663: CALL_OW 257
41667: PUSH
41668: LD_INT 4
41670: EQUAL
41671: IFFALSE 41675
// continue ;
41673: GO 41641
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41675: LD_ADDR_VAR 0 11
41679: PUSH
41680: LD_VAR 0 11
41684: PPUSH
41685: LD_VAR 0 11
41689: PUSH
41690: LD_INT 1
41692: PLUS
41693: PPUSH
41694: LD_VAR 0 9
41698: PUSH
41699: LD_VAR 0 3
41703: ARRAY
41704: PPUSH
41705: CALL_OW 2
41709: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41710: LD_ADDR_VAR 0 4
41714: PUSH
41715: LD_VAR 0 4
41719: PUSH
41720: LD_VAR 0 9
41724: PUSH
41725: LD_VAR 0 3
41729: ARRAY
41730: DIFF
41731: ST_TO_ADDR
// end ;
41732: GO 41641
41734: POP
41735: POP
// if p then
41736: LD_VAR 0 11
41740: IFFALSE 41765
// result := Replace ( result , 4 , p ) ;
41742: LD_ADDR_VAR 0 2
41746: PUSH
41747: LD_VAR 0 2
41751: PPUSH
41752: LD_INT 4
41754: PPUSH
41755: LD_VAR 0 11
41759: PPUSH
41760: CALL_OW 1
41764: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41765: LD_VAR 0 4
41769: PUSH
41770: LD_VAR 0 7
41774: PUSH
41775: LD_INT 6
41777: LESS
41778: AND
41779: IFFALSE 41967
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41781: LD_ADDR_VAR 0 9
41785: PUSH
41786: LD_VAR 0 4
41790: PUSH
41791: LD_VAR 0 8
41795: PUSH
41796: LD_VAR 0 7
41800: UNION
41801: DIFF
41802: PPUSH
41803: LD_INT 3
41805: PPUSH
41806: CALL 101120 0 2
41810: ST_TO_ADDR
// p := [ ] ;
41811: LD_ADDR_VAR 0 11
41815: PUSH
41816: EMPTY
41817: ST_TO_ADDR
// if sort then
41818: LD_VAR 0 9
41822: IFFALSE 41938
// for i = 1 to 6 - mech do
41824: LD_ADDR_VAR 0 3
41828: PUSH
41829: DOUBLE
41830: LD_INT 1
41832: DEC
41833: ST_TO_ADDR
41834: LD_INT 6
41836: PUSH
41837: LD_VAR 0 7
41841: MINUS
41842: PUSH
41843: FOR_TO
41844: IFFALSE 41936
// begin if i = sort then
41846: LD_VAR 0 3
41850: PUSH
41851: LD_VAR 0 9
41855: EQUAL
41856: IFFALSE 41860
// break ;
41858: GO 41936
// if GetClass ( i ) = 3 then
41860: LD_VAR 0 3
41864: PPUSH
41865: CALL_OW 257
41869: PUSH
41870: LD_INT 3
41872: EQUAL
41873: IFFALSE 41877
// continue ;
41875: GO 41843
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41877: LD_ADDR_VAR 0 11
41881: PUSH
41882: LD_VAR 0 11
41886: PPUSH
41887: LD_VAR 0 11
41891: PUSH
41892: LD_INT 1
41894: PLUS
41895: PPUSH
41896: LD_VAR 0 9
41900: PUSH
41901: LD_VAR 0 3
41905: ARRAY
41906: PPUSH
41907: CALL_OW 2
41911: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41912: LD_ADDR_VAR 0 4
41916: PUSH
41917: LD_VAR 0 4
41921: PUSH
41922: LD_VAR 0 9
41926: PUSH
41927: LD_VAR 0 3
41931: ARRAY
41932: DIFF
41933: ST_TO_ADDR
// end ;
41934: GO 41843
41936: POP
41937: POP
// if p then
41938: LD_VAR 0 11
41942: IFFALSE 41967
// result := Replace ( result , 3 , p ) ;
41944: LD_ADDR_VAR 0 2
41948: PUSH
41949: LD_VAR 0 2
41953: PPUSH
41954: LD_INT 3
41956: PPUSH
41957: LD_VAR 0 11
41961: PPUSH
41962: CALL_OW 1
41966: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41967: LD_VAR 0 4
41971: PUSH
41972: LD_INT 6
41974: GREATER
41975: PUSH
41976: LD_VAR 0 6
41980: PUSH
41981: LD_INT 6
41983: LESS
41984: AND
41985: IFFALSE 42179
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41987: LD_ADDR_VAR 0 9
41991: PUSH
41992: LD_VAR 0 4
41996: PUSH
41997: LD_VAR 0 8
42001: PUSH
42002: LD_VAR 0 7
42006: UNION
42007: PUSH
42008: LD_VAR 0 6
42012: UNION
42013: DIFF
42014: PPUSH
42015: LD_INT 2
42017: PPUSH
42018: CALL 101120 0 2
42022: ST_TO_ADDR
// p := [ ] ;
42023: LD_ADDR_VAR 0 11
42027: PUSH
42028: EMPTY
42029: ST_TO_ADDR
// if sort then
42030: LD_VAR 0 9
42034: IFFALSE 42150
// for i = 1 to 6 - eng do
42036: LD_ADDR_VAR 0 3
42040: PUSH
42041: DOUBLE
42042: LD_INT 1
42044: DEC
42045: ST_TO_ADDR
42046: LD_INT 6
42048: PUSH
42049: LD_VAR 0 6
42053: MINUS
42054: PUSH
42055: FOR_TO
42056: IFFALSE 42148
// begin if i = sort then
42058: LD_VAR 0 3
42062: PUSH
42063: LD_VAR 0 9
42067: EQUAL
42068: IFFALSE 42072
// break ;
42070: GO 42148
// if GetClass ( i ) = 2 then
42072: LD_VAR 0 3
42076: PPUSH
42077: CALL_OW 257
42081: PUSH
42082: LD_INT 2
42084: EQUAL
42085: IFFALSE 42089
// continue ;
42087: GO 42055
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42089: LD_ADDR_VAR 0 11
42093: PUSH
42094: LD_VAR 0 11
42098: PPUSH
42099: LD_VAR 0 11
42103: PUSH
42104: LD_INT 1
42106: PLUS
42107: PPUSH
42108: LD_VAR 0 9
42112: PUSH
42113: LD_VAR 0 3
42117: ARRAY
42118: PPUSH
42119: CALL_OW 2
42123: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42124: LD_ADDR_VAR 0 4
42128: PUSH
42129: LD_VAR 0 4
42133: PUSH
42134: LD_VAR 0 9
42138: PUSH
42139: LD_VAR 0 3
42143: ARRAY
42144: DIFF
42145: ST_TO_ADDR
// end ;
42146: GO 42055
42148: POP
42149: POP
// if p then
42150: LD_VAR 0 11
42154: IFFALSE 42179
// result := Replace ( result , 2 , p ) ;
42156: LD_ADDR_VAR 0 2
42160: PUSH
42161: LD_VAR 0 2
42165: PPUSH
42166: LD_INT 2
42168: PPUSH
42169: LD_VAR 0 11
42173: PPUSH
42174: CALL_OW 1
42178: ST_TO_ADDR
// end ; exit ;
42179: GO 43567
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42181: LD_EXP 143
42185: PUSH
42186: LD_EXP 142
42190: PUSH
42191: LD_VAR 0 1
42195: ARRAY
42196: ARRAY
42197: NOT
42198: PUSH
42199: LD_EXP 116
42203: PUSH
42204: LD_VAR 0 1
42208: ARRAY
42209: PPUSH
42210: LD_INT 30
42212: PUSH
42213: LD_INT 3
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PPUSH
42220: CALL_OW 72
42224: AND
42225: PUSH
42226: LD_EXP 121
42230: PUSH
42231: LD_VAR 0 1
42235: ARRAY
42236: AND
42237: IFFALSE 42845
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42239: LD_ADDR_EXP 158
42243: PUSH
42244: LD_EXP 158
42248: PPUSH
42249: LD_VAR 0 1
42253: PPUSH
42254: LD_INT 5
42256: PPUSH
42257: CALL_OW 1
42261: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42262: LD_ADDR_VAR 0 2
42266: PUSH
42267: LD_INT 0
42269: PUSH
42270: LD_INT 0
42272: PUSH
42273: LD_INT 0
42275: PUSH
42276: LD_INT 0
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: LIST
42283: LIST
42284: ST_TO_ADDR
// if sci > 1 then
42285: LD_VAR 0 8
42289: PUSH
42290: LD_INT 1
42292: GREATER
42293: IFFALSE 42321
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42295: LD_ADDR_VAR 0 4
42299: PUSH
42300: LD_VAR 0 4
42304: PUSH
42305: LD_VAR 0 8
42309: PUSH
42310: LD_VAR 0 8
42314: PUSH
42315: LD_INT 1
42317: ARRAY
42318: DIFF
42319: DIFF
42320: ST_TO_ADDR
// if tmp and not sci then
42321: LD_VAR 0 4
42325: PUSH
42326: LD_VAR 0 8
42330: NOT
42331: AND
42332: IFFALSE 42401
// begin sort := SortBySkill ( tmp , 4 ) ;
42334: LD_ADDR_VAR 0 9
42338: PUSH
42339: LD_VAR 0 4
42343: PPUSH
42344: LD_INT 4
42346: PPUSH
42347: CALL 101120 0 2
42351: ST_TO_ADDR
// if sort then
42352: LD_VAR 0 9
42356: IFFALSE 42372
// p := sort [ 1 ] ;
42358: LD_ADDR_VAR 0 11
42362: PUSH
42363: LD_VAR 0 9
42367: PUSH
42368: LD_INT 1
42370: ARRAY
42371: ST_TO_ADDR
// if p then
42372: LD_VAR 0 11
42376: IFFALSE 42401
// result := Replace ( result , 4 , p ) ;
42378: LD_ADDR_VAR 0 2
42382: PUSH
42383: LD_VAR 0 2
42387: PPUSH
42388: LD_INT 4
42390: PPUSH
42391: LD_VAR 0 11
42395: PPUSH
42396: CALL_OW 1
42400: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42401: LD_ADDR_VAR 0 4
42405: PUSH
42406: LD_VAR 0 4
42410: PUSH
42411: LD_VAR 0 7
42415: DIFF
42416: ST_TO_ADDR
// if tmp and mech < 6 then
42417: LD_VAR 0 4
42421: PUSH
42422: LD_VAR 0 7
42426: PUSH
42427: LD_INT 6
42429: LESS
42430: AND
42431: IFFALSE 42619
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42433: LD_ADDR_VAR 0 9
42437: PUSH
42438: LD_VAR 0 4
42442: PUSH
42443: LD_VAR 0 8
42447: PUSH
42448: LD_VAR 0 7
42452: UNION
42453: DIFF
42454: PPUSH
42455: LD_INT 3
42457: PPUSH
42458: CALL 101120 0 2
42462: ST_TO_ADDR
// p := [ ] ;
42463: LD_ADDR_VAR 0 11
42467: PUSH
42468: EMPTY
42469: ST_TO_ADDR
// if sort then
42470: LD_VAR 0 9
42474: IFFALSE 42590
// for i = 1 to 6 - mech do
42476: LD_ADDR_VAR 0 3
42480: PUSH
42481: DOUBLE
42482: LD_INT 1
42484: DEC
42485: ST_TO_ADDR
42486: LD_INT 6
42488: PUSH
42489: LD_VAR 0 7
42493: MINUS
42494: PUSH
42495: FOR_TO
42496: IFFALSE 42588
// begin if i = sort then
42498: LD_VAR 0 3
42502: PUSH
42503: LD_VAR 0 9
42507: EQUAL
42508: IFFALSE 42512
// break ;
42510: GO 42588
// if GetClass ( i ) = 3 then
42512: LD_VAR 0 3
42516: PPUSH
42517: CALL_OW 257
42521: PUSH
42522: LD_INT 3
42524: EQUAL
42525: IFFALSE 42529
// continue ;
42527: GO 42495
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42529: LD_ADDR_VAR 0 11
42533: PUSH
42534: LD_VAR 0 11
42538: PPUSH
42539: LD_VAR 0 11
42543: PUSH
42544: LD_INT 1
42546: PLUS
42547: PPUSH
42548: LD_VAR 0 9
42552: PUSH
42553: LD_VAR 0 3
42557: ARRAY
42558: PPUSH
42559: CALL_OW 2
42563: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42564: LD_ADDR_VAR 0 4
42568: PUSH
42569: LD_VAR 0 4
42573: PUSH
42574: LD_VAR 0 9
42578: PUSH
42579: LD_VAR 0 3
42583: ARRAY
42584: DIFF
42585: ST_TO_ADDR
// end ;
42586: GO 42495
42588: POP
42589: POP
// if p then
42590: LD_VAR 0 11
42594: IFFALSE 42619
// result := Replace ( result , 3 , p ) ;
42596: LD_ADDR_VAR 0 2
42600: PUSH
42601: LD_VAR 0 2
42605: PPUSH
42606: LD_INT 3
42608: PPUSH
42609: LD_VAR 0 11
42613: PPUSH
42614: CALL_OW 1
42618: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42619: LD_ADDR_VAR 0 4
42623: PUSH
42624: LD_VAR 0 4
42628: PUSH
42629: LD_VAR 0 6
42633: DIFF
42634: ST_TO_ADDR
// if tmp and eng < 6 then
42635: LD_VAR 0 4
42639: PUSH
42640: LD_VAR 0 6
42644: PUSH
42645: LD_INT 6
42647: LESS
42648: AND
42649: IFFALSE 42843
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42651: LD_ADDR_VAR 0 9
42655: PUSH
42656: LD_VAR 0 4
42660: PUSH
42661: LD_VAR 0 8
42665: PUSH
42666: LD_VAR 0 7
42670: UNION
42671: PUSH
42672: LD_VAR 0 6
42676: UNION
42677: DIFF
42678: PPUSH
42679: LD_INT 2
42681: PPUSH
42682: CALL 101120 0 2
42686: ST_TO_ADDR
// p := [ ] ;
42687: LD_ADDR_VAR 0 11
42691: PUSH
42692: EMPTY
42693: ST_TO_ADDR
// if sort then
42694: LD_VAR 0 9
42698: IFFALSE 42814
// for i = 1 to 6 - eng do
42700: LD_ADDR_VAR 0 3
42704: PUSH
42705: DOUBLE
42706: LD_INT 1
42708: DEC
42709: ST_TO_ADDR
42710: LD_INT 6
42712: PUSH
42713: LD_VAR 0 6
42717: MINUS
42718: PUSH
42719: FOR_TO
42720: IFFALSE 42812
// begin if i = sort then
42722: LD_VAR 0 3
42726: PUSH
42727: LD_VAR 0 9
42731: EQUAL
42732: IFFALSE 42736
// break ;
42734: GO 42812
// if GetClass ( i ) = 2 then
42736: LD_VAR 0 3
42740: PPUSH
42741: CALL_OW 257
42745: PUSH
42746: LD_INT 2
42748: EQUAL
42749: IFFALSE 42753
// continue ;
42751: GO 42719
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42753: LD_ADDR_VAR 0 11
42757: PUSH
42758: LD_VAR 0 11
42762: PPUSH
42763: LD_VAR 0 11
42767: PUSH
42768: LD_INT 1
42770: PLUS
42771: PPUSH
42772: LD_VAR 0 9
42776: PUSH
42777: LD_VAR 0 3
42781: ARRAY
42782: PPUSH
42783: CALL_OW 2
42787: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42788: LD_ADDR_VAR 0 4
42792: PUSH
42793: LD_VAR 0 4
42797: PUSH
42798: LD_VAR 0 9
42802: PUSH
42803: LD_VAR 0 3
42807: ARRAY
42808: DIFF
42809: ST_TO_ADDR
// end ;
42810: GO 42719
42812: POP
42813: POP
// if p then
42814: LD_VAR 0 11
42818: IFFALSE 42843
// result := Replace ( result , 2 , p ) ;
42820: LD_ADDR_VAR 0 2
42824: PUSH
42825: LD_VAR 0 2
42829: PPUSH
42830: LD_INT 2
42832: PPUSH
42833: LD_VAR 0 11
42837: PPUSH
42838: CALL_OW 1
42842: ST_TO_ADDR
// end ; exit ;
42843: GO 43567
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42845: LD_EXP 143
42849: PUSH
42850: LD_EXP 142
42854: PUSH
42855: LD_VAR 0 1
42859: ARRAY
42860: ARRAY
42861: NOT
42862: PUSH
42863: LD_EXP 116
42867: PUSH
42868: LD_VAR 0 1
42872: ARRAY
42873: PPUSH
42874: LD_INT 30
42876: PUSH
42877: LD_INT 3
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PPUSH
42884: CALL_OW 72
42888: AND
42889: PUSH
42890: LD_EXP 121
42894: PUSH
42895: LD_VAR 0 1
42899: ARRAY
42900: NOT
42901: AND
42902: IFFALSE 43567
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42904: LD_ADDR_EXP 158
42908: PUSH
42909: LD_EXP 158
42913: PPUSH
42914: LD_VAR 0 1
42918: PPUSH
42919: LD_INT 6
42921: PPUSH
42922: CALL_OW 1
42926: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42927: LD_ADDR_VAR 0 2
42931: PUSH
42932: LD_INT 0
42934: PUSH
42935: LD_INT 0
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: LD_INT 0
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: LIST
42948: LIST
42949: ST_TO_ADDR
// if sci >= 1 then
42950: LD_VAR 0 8
42954: PUSH
42955: LD_INT 1
42957: GREATEREQUAL
42958: IFFALSE 42980
// tmp := tmp diff sci [ 1 ] ;
42960: LD_ADDR_VAR 0 4
42964: PUSH
42965: LD_VAR 0 4
42969: PUSH
42970: LD_VAR 0 8
42974: PUSH
42975: LD_INT 1
42977: ARRAY
42978: DIFF
42979: ST_TO_ADDR
// if tmp and not sci then
42980: LD_VAR 0 4
42984: PUSH
42985: LD_VAR 0 8
42989: NOT
42990: AND
42991: IFFALSE 43060
// begin sort := SortBySkill ( tmp , 4 ) ;
42993: LD_ADDR_VAR 0 9
42997: PUSH
42998: LD_VAR 0 4
43002: PPUSH
43003: LD_INT 4
43005: PPUSH
43006: CALL 101120 0 2
43010: ST_TO_ADDR
// if sort then
43011: LD_VAR 0 9
43015: IFFALSE 43031
// p := sort [ 1 ] ;
43017: LD_ADDR_VAR 0 11
43021: PUSH
43022: LD_VAR 0 9
43026: PUSH
43027: LD_INT 1
43029: ARRAY
43030: ST_TO_ADDR
// if p then
43031: LD_VAR 0 11
43035: IFFALSE 43060
// result := Replace ( result , 4 , p ) ;
43037: LD_ADDR_VAR 0 2
43041: PUSH
43042: LD_VAR 0 2
43046: PPUSH
43047: LD_INT 4
43049: PPUSH
43050: LD_VAR 0 11
43054: PPUSH
43055: CALL_OW 1
43059: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43060: LD_ADDR_VAR 0 4
43064: PUSH
43065: LD_VAR 0 4
43069: PUSH
43070: LD_VAR 0 7
43074: DIFF
43075: ST_TO_ADDR
// if tmp and mech < 6 then
43076: LD_VAR 0 4
43080: PUSH
43081: LD_VAR 0 7
43085: PUSH
43086: LD_INT 6
43088: LESS
43089: AND
43090: IFFALSE 43272
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
43092: LD_ADDR_VAR 0 9
43096: PUSH
43097: LD_VAR 0 4
43101: PUSH
43102: LD_VAR 0 7
43106: DIFF
43107: PPUSH
43108: LD_INT 3
43110: PPUSH
43111: CALL 101120 0 2
43115: ST_TO_ADDR
// p := [ ] ;
43116: LD_ADDR_VAR 0 11
43120: PUSH
43121: EMPTY
43122: ST_TO_ADDR
// if sort then
43123: LD_VAR 0 9
43127: IFFALSE 43243
// for i = 1 to 6 - mech do
43129: LD_ADDR_VAR 0 3
43133: PUSH
43134: DOUBLE
43135: LD_INT 1
43137: DEC
43138: ST_TO_ADDR
43139: LD_INT 6
43141: PUSH
43142: LD_VAR 0 7
43146: MINUS
43147: PUSH
43148: FOR_TO
43149: IFFALSE 43241
// begin if i = sort then
43151: LD_VAR 0 3
43155: PUSH
43156: LD_VAR 0 9
43160: EQUAL
43161: IFFALSE 43165
// break ;
43163: GO 43241
// if GetClass ( i ) = 3 then
43165: LD_VAR 0 3
43169: PPUSH
43170: CALL_OW 257
43174: PUSH
43175: LD_INT 3
43177: EQUAL
43178: IFFALSE 43182
// continue ;
43180: GO 43148
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43182: LD_ADDR_VAR 0 11
43186: PUSH
43187: LD_VAR 0 11
43191: PPUSH
43192: LD_VAR 0 11
43196: PUSH
43197: LD_INT 1
43199: PLUS
43200: PPUSH
43201: LD_VAR 0 9
43205: PUSH
43206: LD_VAR 0 3
43210: ARRAY
43211: PPUSH
43212: CALL_OW 2
43216: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43217: LD_ADDR_VAR 0 4
43221: PUSH
43222: LD_VAR 0 4
43226: PUSH
43227: LD_VAR 0 9
43231: PUSH
43232: LD_VAR 0 3
43236: ARRAY
43237: DIFF
43238: ST_TO_ADDR
// end ;
43239: GO 43148
43241: POP
43242: POP
// if p then
43243: LD_VAR 0 11
43247: IFFALSE 43272
// result := Replace ( result , 3 , p ) ;
43249: LD_ADDR_VAR 0 2
43253: PUSH
43254: LD_VAR 0 2
43258: PPUSH
43259: LD_INT 3
43261: PPUSH
43262: LD_VAR 0 11
43266: PPUSH
43267: CALL_OW 1
43271: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43272: LD_ADDR_VAR 0 4
43276: PUSH
43277: LD_VAR 0 4
43281: PUSH
43282: LD_VAR 0 6
43286: DIFF
43287: ST_TO_ADDR
// if tmp and eng < 4 then
43288: LD_VAR 0 4
43292: PUSH
43293: LD_VAR 0 6
43297: PUSH
43298: LD_INT 4
43300: LESS
43301: AND
43302: IFFALSE 43492
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43304: LD_ADDR_VAR 0 9
43308: PUSH
43309: LD_VAR 0 4
43313: PUSH
43314: LD_VAR 0 7
43318: PUSH
43319: LD_VAR 0 6
43323: UNION
43324: DIFF
43325: PPUSH
43326: LD_INT 2
43328: PPUSH
43329: CALL 101120 0 2
43333: ST_TO_ADDR
// p := [ ] ;
43334: LD_ADDR_VAR 0 11
43338: PUSH
43339: EMPTY
43340: ST_TO_ADDR
// if sort then
43341: LD_VAR 0 9
43345: IFFALSE 43461
// for i = 1 to 4 - eng do
43347: LD_ADDR_VAR 0 3
43351: PUSH
43352: DOUBLE
43353: LD_INT 1
43355: DEC
43356: ST_TO_ADDR
43357: LD_INT 4
43359: PUSH
43360: LD_VAR 0 6
43364: MINUS
43365: PUSH
43366: FOR_TO
43367: IFFALSE 43459
// begin if i = sort then
43369: LD_VAR 0 3
43373: PUSH
43374: LD_VAR 0 9
43378: EQUAL
43379: IFFALSE 43383
// break ;
43381: GO 43459
// if GetClass ( i ) = 2 then
43383: LD_VAR 0 3
43387: PPUSH
43388: CALL_OW 257
43392: PUSH
43393: LD_INT 2
43395: EQUAL
43396: IFFALSE 43400
// continue ;
43398: GO 43366
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43400: LD_ADDR_VAR 0 11
43404: PUSH
43405: LD_VAR 0 11
43409: PPUSH
43410: LD_VAR 0 11
43414: PUSH
43415: LD_INT 1
43417: PLUS
43418: PPUSH
43419: LD_VAR 0 9
43423: PUSH
43424: LD_VAR 0 3
43428: ARRAY
43429: PPUSH
43430: CALL_OW 2
43434: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43435: LD_ADDR_VAR 0 4
43439: PUSH
43440: LD_VAR 0 4
43444: PUSH
43445: LD_VAR 0 9
43449: PUSH
43450: LD_VAR 0 3
43454: ARRAY
43455: DIFF
43456: ST_TO_ADDR
// end ;
43457: GO 43366
43459: POP
43460: POP
// if p then
43461: LD_VAR 0 11
43465: IFFALSE 43490
// result := Replace ( result , 2 , p ) ;
43467: LD_ADDR_VAR 0 2
43471: PUSH
43472: LD_VAR 0 2
43476: PPUSH
43477: LD_INT 2
43479: PPUSH
43480: LD_VAR 0 11
43484: PPUSH
43485: CALL_OW 1
43489: ST_TO_ADDR
// end else
43490: GO 43536
// for i = eng downto 5 do
43492: LD_ADDR_VAR 0 3
43496: PUSH
43497: DOUBLE
43498: LD_VAR 0 6
43502: INC
43503: ST_TO_ADDR
43504: LD_INT 5
43506: PUSH
43507: FOR_DOWNTO
43508: IFFALSE 43534
// tmp := tmp union eng [ i ] ;
43510: LD_ADDR_VAR 0 4
43514: PUSH
43515: LD_VAR 0 4
43519: PUSH
43520: LD_VAR 0 6
43524: PUSH
43525: LD_VAR 0 3
43529: ARRAY
43530: UNION
43531: ST_TO_ADDR
43532: GO 43507
43534: POP
43535: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43536: LD_ADDR_VAR 0 2
43540: PUSH
43541: LD_VAR 0 2
43545: PPUSH
43546: LD_INT 1
43548: PPUSH
43549: LD_VAR 0 4
43553: PUSH
43554: LD_VAR 0 5
43558: DIFF
43559: PPUSH
43560: CALL_OW 1
43564: ST_TO_ADDR
// exit ;
43565: GO 43567
// end ; end ;
43567: LD_VAR 0 2
43571: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43572: LD_INT 0
43574: PPUSH
43575: PPUSH
43576: PPUSH
// if not mc_bases then
43577: LD_EXP 116
43581: NOT
43582: IFFALSE 43586
// exit ;
43584: GO 43728
// for i = 1 to mc_bases do
43586: LD_ADDR_VAR 0 2
43590: PUSH
43591: DOUBLE
43592: LD_INT 1
43594: DEC
43595: ST_TO_ADDR
43596: LD_EXP 116
43600: PUSH
43601: FOR_TO
43602: IFFALSE 43719
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43604: LD_ADDR_VAR 0 3
43608: PUSH
43609: LD_EXP 116
43613: PUSH
43614: LD_VAR 0 2
43618: ARRAY
43619: PPUSH
43620: LD_INT 21
43622: PUSH
43623: LD_INT 3
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 3
43632: PUSH
43633: LD_INT 2
43635: PUSH
43636: LD_INT 30
43638: PUSH
43639: LD_INT 29
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 30
43648: PUSH
43649: LD_INT 30
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: LIST
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: LD_INT 3
43667: PUSH
43668: LD_INT 24
43670: PUSH
43671: LD_INT 1000
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: LIST
43686: PPUSH
43687: CALL_OW 72
43691: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43692: LD_ADDR_EXP 117
43696: PUSH
43697: LD_EXP 117
43701: PPUSH
43702: LD_VAR 0 2
43706: PPUSH
43707: LD_VAR 0 3
43711: PPUSH
43712: CALL_OW 1
43716: ST_TO_ADDR
// end ;
43717: GO 43601
43719: POP
43720: POP
// RaiseSailEvent ( 101 ) ;
43721: LD_INT 101
43723: PPUSH
43724: CALL_OW 427
// end ;
43728: LD_VAR 0 1
43732: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43733: LD_INT 0
43735: PPUSH
43736: PPUSH
43737: PPUSH
43738: PPUSH
43739: PPUSH
43740: PPUSH
43741: PPUSH
// if not mc_bases then
43742: LD_EXP 116
43746: NOT
43747: IFFALSE 43751
// exit ;
43749: GO 44313
// for i = 1 to mc_bases do
43751: LD_ADDR_VAR 0 2
43755: PUSH
43756: DOUBLE
43757: LD_INT 1
43759: DEC
43760: ST_TO_ADDR
43761: LD_EXP 116
43765: PUSH
43766: FOR_TO
43767: IFFALSE 44304
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43769: LD_ADDR_VAR 0 5
43773: PUSH
43774: LD_EXP 116
43778: PUSH
43779: LD_VAR 0 2
43783: ARRAY
43784: PUSH
43785: LD_EXP 145
43789: PUSH
43790: LD_VAR 0 2
43794: ARRAY
43795: UNION
43796: PPUSH
43797: LD_INT 21
43799: PUSH
43800: LD_INT 1
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: PUSH
43807: LD_INT 1
43809: PUSH
43810: LD_INT 3
43812: PUSH
43813: LD_INT 54
43815: PUSH
43816: EMPTY
43817: LIST
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 3
43825: PUSH
43826: LD_INT 24
43828: PUSH
43829: LD_INT 1000
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: EMPTY
43837: LIST
43838: LIST
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: LIST
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PPUSH
43849: CALL_OW 72
43853: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43854: LD_ADDR_VAR 0 6
43858: PUSH
43859: LD_EXP 116
43863: PUSH
43864: LD_VAR 0 2
43868: ARRAY
43869: PPUSH
43870: LD_INT 21
43872: PUSH
43873: LD_INT 1
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 1
43882: PUSH
43883: LD_INT 3
43885: PUSH
43886: LD_INT 54
43888: PUSH
43889: EMPTY
43890: LIST
43891: PUSH
43892: EMPTY
43893: LIST
43894: LIST
43895: PUSH
43896: LD_INT 3
43898: PUSH
43899: LD_INT 24
43901: PUSH
43902: LD_INT 250
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: LIST
43917: PUSH
43918: EMPTY
43919: LIST
43920: LIST
43921: PPUSH
43922: CALL_OW 72
43926: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43927: LD_ADDR_VAR 0 7
43931: PUSH
43932: LD_VAR 0 5
43936: PUSH
43937: LD_VAR 0 6
43941: DIFF
43942: ST_TO_ADDR
// if not need_heal_1 then
43943: LD_VAR 0 6
43947: NOT
43948: IFFALSE 43981
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43950: LD_ADDR_EXP 119
43954: PUSH
43955: LD_EXP 119
43959: PPUSH
43960: LD_VAR 0 2
43964: PUSH
43965: LD_INT 1
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: PPUSH
43972: EMPTY
43973: PPUSH
43974: CALL 70863 0 3
43978: ST_TO_ADDR
43979: GO 44051
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43981: LD_ADDR_EXP 119
43985: PUSH
43986: LD_EXP 119
43990: PPUSH
43991: LD_VAR 0 2
43995: PUSH
43996: LD_INT 1
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PPUSH
44003: LD_EXP 119
44007: PUSH
44008: LD_VAR 0 2
44012: ARRAY
44013: PUSH
44014: LD_INT 1
44016: ARRAY
44017: PPUSH
44018: LD_INT 3
44020: PUSH
44021: LD_INT 24
44023: PUSH
44024: LD_INT 1000
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PPUSH
44035: CALL_OW 72
44039: PUSH
44040: LD_VAR 0 6
44044: UNION
44045: PPUSH
44046: CALL 70863 0 3
44050: ST_TO_ADDR
// if not need_heal_2 then
44051: LD_VAR 0 7
44055: NOT
44056: IFFALSE 44089
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
44058: LD_ADDR_EXP 119
44062: PUSH
44063: LD_EXP 119
44067: PPUSH
44068: LD_VAR 0 2
44072: PUSH
44073: LD_INT 2
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PPUSH
44080: EMPTY
44081: PPUSH
44082: CALL 70863 0 3
44086: ST_TO_ADDR
44087: GO 44121
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
44089: LD_ADDR_EXP 119
44093: PUSH
44094: LD_EXP 119
44098: PPUSH
44099: LD_VAR 0 2
44103: PUSH
44104: LD_INT 2
44106: PUSH
44107: EMPTY
44108: LIST
44109: LIST
44110: PPUSH
44111: LD_VAR 0 7
44115: PPUSH
44116: CALL 70863 0 3
44120: ST_TO_ADDR
// if need_heal_2 then
44121: LD_VAR 0 7
44125: IFFALSE 44286
// for j in need_heal_2 do
44127: LD_ADDR_VAR 0 3
44131: PUSH
44132: LD_VAR 0 7
44136: PUSH
44137: FOR_IN
44138: IFFALSE 44284
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44140: LD_ADDR_VAR 0 5
44144: PUSH
44145: LD_EXP 116
44149: PUSH
44150: LD_VAR 0 2
44154: ARRAY
44155: PPUSH
44156: LD_INT 2
44158: PUSH
44159: LD_INT 30
44161: PUSH
44162: LD_INT 6
44164: PUSH
44165: EMPTY
44166: LIST
44167: LIST
44168: PUSH
44169: LD_INT 30
44171: PUSH
44172: LD_INT 7
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 30
44181: PUSH
44182: LD_INT 8
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 30
44191: PUSH
44192: LD_INT 0
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 30
44201: PUSH
44202: LD_INT 1
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: LIST
44213: LIST
44214: LIST
44215: LIST
44216: PPUSH
44217: CALL_OW 72
44221: ST_TO_ADDR
// if tmp then
44222: LD_VAR 0 5
44226: IFFALSE 44282
// begin k := NearestUnitToUnit ( tmp , j ) ;
44228: LD_ADDR_VAR 0 4
44232: PUSH
44233: LD_VAR 0 5
44237: PPUSH
44238: LD_VAR 0 3
44242: PPUSH
44243: CALL_OW 74
44247: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44248: LD_VAR 0 3
44252: PPUSH
44253: LD_VAR 0 4
44257: PPUSH
44258: CALL_OW 296
44262: PUSH
44263: LD_INT 5
44265: GREATER
44266: IFFALSE 44282
// ComMoveToNearbyEntrance ( j , k ) ;
44268: LD_VAR 0 3
44272: PPUSH
44273: LD_VAR 0 4
44277: PPUSH
44278: CALL 103481 0 2
// end ; end ;
44282: GO 44137
44284: POP
44285: POP
// if not need_heal_1 and not need_heal_2 then
44286: LD_VAR 0 6
44290: NOT
44291: PUSH
44292: LD_VAR 0 7
44296: NOT
44297: AND
44298: IFFALSE 44302
// continue ;
44300: GO 43766
// end ;
44302: GO 43766
44304: POP
44305: POP
// RaiseSailEvent ( 102 ) ;
44306: LD_INT 102
44308: PPUSH
44309: CALL_OW 427
// end ;
44313: LD_VAR 0 1
44317: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44318: LD_INT 0
44320: PPUSH
44321: PPUSH
44322: PPUSH
44323: PPUSH
44324: PPUSH
44325: PPUSH
44326: PPUSH
44327: PPUSH
// if not mc_bases then
44328: LD_EXP 116
44332: NOT
44333: IFFALSE 44337
// exit ;
44335: GO 45220
// for i = 1 to mc_bases do
44337: LD_ADDR_VAR 0 2
44341: PUSH
44342: DOUBLE
44343: LD_INT 1
44345: DEC
44346: ST_TO_ADDR
44347: LD_EXP 116
44351: PUSH
44352: FOR_TO
44353: IFFALSE 45218
// begin if not mc_building_need_repair [ i ] then
44355: LD_EXP 117
44359: PUSH
44360: LD_VAR 0 2
44364: ARRAY
44365: NOT
44366: IFFALSE 44553
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44368: LD_ADDR_VAR 0 6
44372: PUSH
44373: LD_EXP 135
44377: PUSH
44378: LD_VAR 0 2
44382: ARRAY
44383: PPUSH
44384: LD_INT 3
44386: PUSH
44387: LD_INT 24
44389: PUSH
44390: LD_INT 1000
44392: PUSH
44393: EMPTY
44394: LIST
44395: LIST
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 2
44403: PUSH
44404: LD_INT 34
44406: PUSH
44407: LD_INT 13
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 34
44416: PUSH
44417: LD_INT 52
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 34
44426: PUSH
44427: LD_EXP 101
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: LIST
44440: LIST
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: PPUSH
44446: CALL_OW 72
44450: ST_TO_ADDR
// if cranes then
44451: LD_VAR 0 6
44455: IFFALSE 44517
// for j in cranes do
44457: LD_ADDR_VAR 0 3
44461: PUSH
44462: LD_VAR 0 6
44466: PUSH
44467: FOR_IN
44468: IFFALSE 44515
// if not IsInArea ( j , mc_parking [ i ] ) then
44470: LD_VAR 0 3
44474: PPUSH
44475: LD_EXP 140
44479: PUSH
44480: LD_VAR 0 2
44484: ARRAY
44485: PPUSH
44486: CALL_OW 308
44490: NOT
44491: IFFALSE 44513
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44493: LD_VAR 0 3
44497: PPUSH
44498: LD_EXP 140
44502: PUSH
44503: LD_VAR 0 2
44507: ARRAY
44508: PPUSH
44509: CALL_OW 113
44513: GO 44467
44515: POP
44516: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44517: LD_ADDR_EXP 118
44521: PUSH
44522: LD_EXP 118
44526: PPUSH
44527: LD_VAR 0 2
44531: PPUSH
44532: EMPTY
44533: PPUSH
44534: CALL_OW 1
44538: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44539: LD_VAR 0 2
44543: PPUSH
44544: LD_INT 101
44546: PPUSH
44547: CALL 39405 0 2
// continue ;
44551: GO 44352
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44553: LD_ADDR_EXP 122
44557: PUSH
44558: LD_EXP 122
44562: PPUSH
44563: LD_VAR 0 2
44567: PPUSH
44568: EMPTY
44569: PPUSH
44570: CALL_OW 1
44574: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44575: LD_VAR 0 2
44579: PPUSH
44580: LD_INT 103
44582: PPUSH
44583: CALL 39405 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44587: LD_ADDR_VAR 0 5
44591: PUSH
44592: LD_EXP 116
44596: PUSH
44597: LD_VAR 0 2
44601: ARRAY
44602: PUSH
44603: LD_EXP 145
44607: PUSH
44608: LD_VAR 0 2
44612: ARRAY
44613: UNION
44614: PPUSH
44615: LD_INT 2
44617: PUSH
44618: LD_INT 25
44620: PUSH
44621: LD_INT 2
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 25
44630: PUSH
44631: LD_INT 16
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: LIST
44642: PUSH
44643: EMPTY
44644: LIST
44645: PPUSH
44646: CALL_OW 72
44650: ST_TO_ADDR
// if mc_need_heal [ i ] then
44651: LD_EXP 119
44655: PUSH
44656: LD_VAR 0 2
44660: ARRAY
44661: IFFALSE 44705
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44663: LD_ADDR_VAR 0 5
44667: PUSH
44668: LD_VAR 0 5
44672: PUSH
44673: LD_EXP 119
44677: PUSH
44678: LD_VAR 0 2
44682: ARRAY
44683: PUSH
44684: LD_INT 1
44686: ARRAY
44687: PUSH
44688: LD_EXP 119
44692: PUSH
44693: LD_VAR 0 2
44697: ARRAY
44698: PUSH
44699: LD_INT 2
44701: ARRAY
44702: UNION
44703: DIFF
44704: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44705: LD_ADDR_VAR 0 6
44709: PUSH
44710: LD_EXP 135
44714: PUSH
44715: LD_VAR 0 2
44719: ARRAY
44720: PPUSH
44721: LD_INT 2
44723: PUSH
44724: LD_INT 34
44726: PUSH
44727: LD_INT 13
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PUSH
44734: LD_INT 34
44736: PUSH
44737: LD_INT 52
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PUSH
44744: LD_INT 34
44746: PUSH
44747: LD_EXP 101
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: LIST
44760: LIST
44761: PPUSH
44762: CALL_OW 72
44766: ST_TO_ADDR
// if cranes then
44767: LD_VAR 0 6
44771: IFFALSE 44907
// begin for j in cranes do
44773: LD_ADDR_VAR 0 3
44777: PUSH
44778: LD_VAR 0 6
44782: PUSH
44783: FOR_IN
44784: IFFALSE 44905
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44786: LD_VAR 0 3
44790: PPUSH
44791: CALL_OW 256
44795: PUSH
44796: LD_INT 1000
44798: EQUAL
44799: PUSH
44800: LD_VAR 0 3
44804: PPUSH
44805: CALL_OW 314
44809: NOT
44810: AND
44811: IFFALSE 44845
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44813: LD_VAR 0 3
44817: PPUSH
44818: LD_EXP 117
44822: PUSH
44823: LD_VAR 0 2
44827: ARRAY
44828: PPUSH
44829: LD_VAR 0 3
44833: PPUSH
44834: CALL_OW 74
44838: PPUSH
44839: CALL_OW 130
44843: GO 44903
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44845: LD_VAR 0 3
44849: PPUSH
44850: CALL_OW 256
44854: PUSH
44855: LD_INT 500
44857: LESS
44858: PUSH
44859: LD_VAR 0 3
44863: PPUSH
44864: LD_EXP 140
44868: PUSH
44869: LD_VAR 0 2
44873: ARRAY
44874: PPUSH
44875: CALL_OW 308
44879: NOT
44880: AND
44881: IFFALSE 44903
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44883: LD_VAR 0 3
44887: PPUSH
44888: LD_EXP 140
44892: PUSH
44893: LD_VAR 0 2
44897: ARRAY
44898: PPUSH
44899: CALL_OW 113
// end ;
44903: GO 44783
44905: POP
44906: POP
// end ; if tmp > 3 then
44907: LD_VAR 0 5
44911: PUSH
44912: LD_INT 3
44914: GREATER
44915: IFFALSE 44935
// tmp := ShrinkArray ( tmp , 4 ) ;
44917: LD_ADDR_VAR 0 5
44921: PUSH
44922: LD_VAR 0 5
44926: PPUSH
44927: LD_INT 4
44929: PPUSH
44930: CALL 102929 0 2
44934: ST_TO_ADDR
// if not tmp then
44935: LD_VAR 0 5
44939: NOT
44940: IFFALSE 44944
// continue ;
44942: GO 44352
// for j in tmp do
44944: LD_ADDR_VAR 0 3
44948: PUSH
44949: LD_VAR 0 5
44953: PUSH
44954: FOR_IN
44955: IFFALSE 45214
// begin if IsInUnit ( j ) then
44957: LD_VAR 0 3
44961: PPUSH
44962: CALL_OW 310
44966: IFFALSE 44977
// ComExitBuilding ( j ) ;
44968: LD_VAR 0 3
44972: PPUSH
44973: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44977: LD_VAR 0 3
44981: PUSH
44982: LD_EXP 118
44986: PUSH
44987: LD_VAR 0 2
44991: ARRAY
44992: IN
44993: NOT
44994: IFFALSE 45052
// begin SetTag ( j , 101 ) ;
44996: LD_VAR 0 3
45000: PPUSH
45001: LD_INT 101
45003: PPUSH
45004: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
45008: LD_ADDR_EXP 118
45012: PUSH
45013: LD_EXP 118
45017: PPUSH
45018: LD_VAR 0 2
45022: PUSH
45023: LD_EXP 118
45027: PUSH
45028: LD_VAR 0 2
45032: ARRAY
45033: PUSH
45034: LD_INT 1
45036: PLUS
45037: PUSH
45038: EMPTY
45039: LIST
45040: LIST
45041: PPUSH
45042: LD_VAR 0 3
45046: PPUSH
45047: CALL 70863 0 3
45051: ST_TO_ADDR
// end ; wait ( 1 ) ;
45052: LD_INT 1
45054: PPUSH
45055: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
45059: LD_ADDR_VAR 0 7
45063: PUSH
45064: LD_EXP 117
45068: PUSH
45069: LD_VAR 0 2
45073: ARRAY
45074: ST_TO_ADDR
// if mc_scan [ i ] then
45075: LD_EXP 139
45079: PUSH
45080: LD_VAR 0 2
45084: ARRAY
45085: IFFALSE 45147
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
45087: LD_ADDR_VAR 0 7
45091: PUSH
45092: LD_EXP 117
45096: PUSH
45097: LD_VAR 0 2
45101: ARRAY
45102: PPUSH
45103: LD_INT 3
45105: PUSH
45106: LD_INT 30
45108: PUSH
45109: LD_INT 32
45111: PUSH
45112: EMPTY
45113: LIST
45114: LIST
45115: PUSH
45116: LD_INT 30
45118: PUSH
45119: LD_INT 33
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 30
45128: PUSH
45129: LD_INT 31
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: PPUSH
45142: CALL_OW 72
45146: ST_TO_ADDR
// if not to_repair_tmp then
45147: LD_VAR 0 7
45151: NOT
45152: IFFALSE 45156
// continue ;
45154: GO 44954
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45156: LD_ADDR_VAR 0 8
45160: PUSH
45161: LD_VAR 0 7
45165: PPUSH
45166: LD_VAR 0 3
45170: PPUSH
45171: CALL_OW 74
45175: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45176: LD_VAR 0 8
45180: PPUSH
45181: LD_INT 16
45183: PPUSH
45184: CALL 73462 0 2
45188: PUSH
45189: LD_INT 4
45191: ARRAY
45192: PUSH
45193: LD_INT 10
45195: LESS
45196: IFFALSE 45212
// ComRepairBuilding ( j , to_repair ) ;
45198: LD_VAR 0 3
45202: PPUSH
45203: LD_VAR 0 8
45207: PPUSH
45208: CALL_OW 130
// end ;
45212: GO 44954
45214: POP
45215: POP
// end ;
45216: GO 44352
45218: POP
45219: POP
// end ;
45220: LD_VAR 0 1
45224: RET
// export function MC_Heal ; var i , j , tmp ; begin
45225: LD_INT 0
45227: PPUSH
45228: PPUSH
45229: PPUSH
45230: PPUSH
// if not mc_bases then
45231: LD_EXP 116
45235: NOT
45236: IFFALSE 45240
// exit ;
45238: GO 45642
// for i = 1 to mc_bases do
45240: LD_ADDR_VAR 0 2
45244: PUSH
45245: DOUBLE
45246: LD_INT 1
45248: DEC
45249: ST_TO_ADDR
45250: LD_EXP 116
45254: PUSH
45255: FOR_TO
45256: IFFALSE 45640
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45258: LD_EXP 119
45262: PUSH
45263: LD_VAR 0 2
45267: ARRAY
45268: PUSH
45269: LD_INT 1
45271: ARRAY
45272: NOT
45273: PUSH
45274: LD_EXP 119
45278: PUSH
45279: LD_VAR 0 2
45283: ARRAY
45284: PUSH
45285: LD_INT 2
45287: ARRAY
45288: NOT
45289: AND
45290: IFFALSE 45328
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45292: LD_ADDR_EXP 120
45296: PUSH
45297: LD_EXP 120
45301: PPUSH
45302: LD_VAR 0 2
45306: PPUSH
45307: EMPTY
45308: PPUSH
45309: CALL_OW 1
45313: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45314: LD_VAR 0 2
45318: PPUSH
45319: LD_INT 102
45321: PPUSH
45322: CALL 39405 0 2
// continue ;
45326: GO 45255
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45328: LD_ADDR_VAR 0 4
45332: PUSH
45333: LD_EXP 116
45337: PUSH
45338: LD_VAR 0 2
45342: ARRAY
45343: PPUSH
45344: LD_INT 25
45346: PUSH
45347: LD_INT 4
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PPUSH
45354: CALL_OW 72
45358: ST_TO_ADDR
// if not tmp then
45359: LD_VAR 0 4
45363: NOT
45364: IFFALSE 45368
// continue ;
45366: GO 45255
// if mc_taming [ i ] then
45368: LD_EXP 147
45372: PUSH
45373: LD_VAR 0 2
45377: ARRAY
45378: IFFALSE 45402
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45380: LD_ADDR_EXP 147
45384: PUSH
45385: LD_EXP 147
45389: PPUSH
45390: LD_VAR 0 2
45394: PPUSH
45395: EMPTY
45396: PPUSH
45397: CALL_OW 1
45401: ST_TO_ADDR
// for j in tmp do
45402: LD_ADDR_VAR 0 3
45406: PUSH
45407: LD_VAR 0 4
45411: PUSH
45412: FOR_IN
45413: IFFALSE 45636
// begin if IsInUnit ( j ) then
45415: LD_VAR 0 3
45419: PPUSH
45420: CALL_OW 310
45424: IFFALSE 45435
// ComExitBuilding ( j ) ;
45426: LD_VAR 0 3
45430: PPUSH
45431: CALL_OW 122
// if not j in mc_healers [ i ] then
45435: LD_VAR 0 3
45439: PUSH
45440: LD_EXP 120
45444: PUSH
45445: LD_VAR 0 2
45449: ARRAY
45450: IN
45451: NOT
45452: IFFALSE 45498
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45454: LD_ADDR_EXP 120
45458: PUSH
45459: LD_EXP 120
45463: PPUSH
45464: LD_VAR 0 2
45468: PUSH
45469: LD_EXP 120
45473: PUSH
45474: LD_VAR 0 2
45478: ARRAY
45479: PUSH
45480: LD_INT 1
45482: PLUS
45483: PUSH
45484: EMPTY
45485: LIST
45486: LIST
45487: PPUSH
45488: LD_VAR 0 3
45492: PPUSH
45493: CALL 70863 0 3
45497: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45498: LD_VAR 0 3
45502: PPUSH
45503: CALL_OW 110
45507: PUSH
45508: LD_INT 102
45510: NONEQUAL
45511: IFFALSE 45525
// SetTag ( j , 102 ) ;
45513: LD_VAR 0 3
45517: PPUSH
45518: LD_INT 102
45520: PPUSH
45521: CALL_OW 109
// Wait ( 3 ) ;
45525: LD_INT 3
45527: PPUSH
45528: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45532: LD_EXP 119
45536: PUSH
45537: LD_VAR 0 2
45541: ARRAY
45542: PUSH
45543: LD_INT 1
45545: ARRAY
45546: IFFALSE 45578
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45548: LD_VAR 0 3
45552: PPUSH
45553: LD_EXP 119
45557: PUSH
45558: LD_VAR 0 2
45562: ARRAY
45563: PUSH
45564: LD_INT 1
45566: ARRAY
45567: PUSH
45568: LD_INT 1
45570: ARRAY
45571: PPUSH
45572: CALL_OW 128
45576: GO 45634
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45578: LD_VAR 0 3
45582: PPUSH
45583: CALL_OW 314
45587: NOT
45588: PUSH
45589: LD_EXP 119
45593: PUSH
45594: LD_VAR 0 2
45598: ARRAY
45599: PUSH
45600: LD_INT 2
45602: ARRAY
45603: AND
45604: IFFALSE 45634
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45606: LD_VAR 0 3
45610: PPUSH
45611: LD_EXP 119
45615: PUSH
45616: LD_VAR 0 2
45620: ARRAY
45621: PUSH
45622: LD_INT 2
45624: ARRAY
45625: PUSH
45626: LD_INT 1
45628: ARRAY
45629: PPUSH
45630: CALL_OW 128
// end ;
45634: GO 45412
45636: POP
45637: POP
// end ;
45638: GO 45255
45640: POP
45641: POP
// end ;
45642: LD_VAR 0 1
45646: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45647: LD_INT 0
45649: PPUSH
45650: PPUSH
45651: PPUSH
45652: PPUSH
45653: PPUSH
// if not mc_bases then
45654: LD_EXP 116
45658: NOT
45659: IFFALSE 45663
// exit ;
45661: GO 46834
// for i = 1 to mc_bases do
45663: LD_ADDR_VAR 0 2
45667: PUSH
45668: DOUBLE
45669: LD_INT 1
45671: DEC
45672: ST_TO_ADDR
45673: LD_EXP 116
45677: PUSH
45678: FOR_TO
45679: IFFALSE 46832
// begin if mc_scan [ i ] then
45681: LD_EXP 139
45685: PUSH
45686: LD_VAR 0 2
45690: ARRAY
45691: IFFALSE 45695
// continue ;
45693: GO 45678
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45695: LD_EXP 121
45699: PUSH
45700: LD_VAR 0 2
45704: ARRAY
45705: NOT
45706: PUSH
45707: LD_EXP 123
45711: PUSH
45712: LD_VAR 0 2
45716: ARRAY
45717: NOT
45718: AND
45719: PUSH
45720: LD_EXP 122
45724: PUSH
45725: LD_VAR 0 2
45729: ARRAY
45730: AND
45731: IFFALSE 45769
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45733: LD_ADDR_EXP 122
45737: PUSH
45738: LD_EXP 122
45742: PPUSH
45743: LD_VAR 0 2
45747: PPUSH
45748: EMPTY
45749: PPUSH
45750: CALL_OW 1
45754: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45755: LD_VAR 0 2
45759: PPUSH
45760: LD_INT 103
45762: PPUSH
45763: CALL 39405 0 2
// continue ;
45767: GO 45678
// end ; if mc_construct_list [ i ] then
45769: LD_EXP 123
45773: PUSH
45774: LD_VAR 0 2
45778: ARRAY
45779: IFFALSE 45999
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45781: LD_ADDR_VAR 0 4
45785: PUSH
45786: LD_EXP 116
45790: PUSH
45791: LD_VAR 0 2
45795: ARRAY
45796: PPUSH
45797: LD_INT 25
45799: PUSH
45800: LD_INT 2
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PPUSH
45807: CALL_OW 72
45811: PUSH
45812: LD_EXP 118
45816: PUSH
45817: LD_VAR 0 2
45821: ARRAY
45822: DIFF
45823: ST_TO_ADDR
// if not tmp then
45824: LD_VAR 0 4
45828: NOT
45829: IFFALSE 45833
// continue ;
45831: GO 45678
// for j in tmp do
45833: LD_ADDR_VAR 0 3
45837: PUSH
45838: LD_VAR 0 4
45842: PUSH
45843: FOR_IN
45844: IFFALSE 45995
// begin if not mc_builders [ i ] then
45846: LD_EXP 122
45850: PUSH
45851: LD_VAR 0 2
45855: ARRAY
45856: NOT
45857: IFFALSE 45915
// begin SetTag ( j , 103 ) ;
45859: LD_VAR 0 3
45863: PPUSH
45864: LD_INT 103
45866: PPUSH
45867: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45871: LD_ADDR_EXP 122
45875: PUSH
45876: LD_EXP 122
45880: PPUSH
45881: LD_VAR 0 2
45885: PUSH
45886: LD_EXP 122
45890: PUSH
45891: LD_VAR 0 2
45895: ARRAY
45896: PUSH
45897: LD_INT 1
45899: PLUS
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PPUSH
45905: LD_VAR 0 3
45909: PPUSH
45910: CALL 70863 0 3
45914: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45915: LD_VAR 0 3
45919: PPUSH
45920: CALL_OW 310
45924: IFFALSE 45935
// ComExitBuilding ( j ) ;
45926: LD_VAR 0 3
45930: PPUSH
45931: CALL_OW 122
// wait ( 3 ) ;
45935: LD_INT 3
45937: PPUSH
45938: CALL_OW 67
// if not mc_construct_list [ i ] then
45942: LD_EXP 123
45946: PUSH
45947: LD_VAR 0 2
45951: ARRAY
45952: NOT
45953: IFFALSE 45957
// break ;
45955: GO 45995
// if not HasTask ( j ) then
45957: LD_VAR 0 3
45961: PPUSH
45962: CALL_OW 314
45966: NOT
45967: IFFALSE 45993
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45969: LD_VAR 0 3
45973: PPUSH
45974: LD_EXP 123
45978: PUSH
45979: LD_VAR 0 2
45983: ARRAY
45984: PUSH
45985: LD_INT 1
45987: ARRAY
45988: PPUSH
45989: CALL 73726 0 2
// end ;
45993: GO 45843
45995: POP
45996: POP
// end else
45997: GO 46830
// if mc_build_list [ i ] then
45999: LD_EXP 121
46003: PUSH
46004: LD_VAR 0 2
46008: ARRAY
46009: IFFALSE 46830
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46011: LD_ADDR_VAR 0 5
46015: PUSH
46016: LD_EXP 116
46020: PUSH
46021: LD_VAR 0 2
46025: ARRAY
46026: PPUSH
46027: LD_INT 2
46029: PUSH
46030: LD_INT 30
46032: PUSH
46033: LD_INT 0
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: PUSH
46040: LD_INT 30
46042: PUSH
46043: LD_INT 1
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: EMPTY
46051: LIST
46052: LIST
46053: LIST
46054: PPUSH
46055: CALL_OW 72
46059: ST_TO_ADDR
// if depot then
46060: LD_VAR 0 5
46064: IFFALSE 46082
// depot := depot [ 1 ] else
46066: LD_ADDR_VAR 0 5
46070: PUSH
46071: LD_VAR 0 5
46075: PUSH
46076: LD_INT 1
46078: ARRAY
46079: ST_TO_ADDR
46080: GO 46090
// depot := 0 ;
46082: LD_ADDR_VAR 0 5
46086: PUSH
46087: LD_INT 0
46089: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
46090: LD_EXP 121
46094: PUSH
46095: LD_VAR 0 2
46099: ARRAY
46100: PUSH
46101: LD_INT 1
46103: ARRAY
46104: PUSH
46105: LD_INT 1
46107: ARRAY
46108: PPUSH
46109: CALL 73550 0 1
46113: PUSH
46114: LD_EXP 116
46118: PUSH
46119: LD_VAR 0 2
46123: ARRAY
46124: PPUSH
46125: LD_INT 2
46127: PUSH
46128: LD_INT 30
46130: PUSH
46131: LD_INT 2
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 30
46140: PUSH
46141: LD_INT 3
46143: PUSH
46144: EMPTY
46145: LIST
46146: LIST
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: LIST
46152: PPUSH
46153: CALL_OW 72
46157: NOT
46158: AND
46159: IFFALSE 46264
// begin for j = 1 to mc_build_list [ i ] do
46161: LD_ADDR_VAR 0 3
46165: PUSH
46166: DOUBLE
46167: LD_INT 1
46169: DEC
46170: ST_TO_ADDR
46171: LD_EXP 121
46175: PUSH
46176: LD_VAR 0 2
46180: ARRAY
46181: PUSH
46182: FOR_TO
46183: IFFALSE 46262
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46185: LD_EXP 121
46189: PUSH
46190: LD_VAR 0 2
46194: ARRAY
46195: PUSH
46196: LD_VAR 0 3
46200: ARRAY
46201: PUSH
46202: LD_INT 1
46204: ARRAY
46205: PUSH
46206: LD_INT 2
46208: EQUAL
46209: IFFALSE 46260
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46211: LD_ADDR_EXP 121
46215: PUSH
46216: LD_EXP 121
46220: PPUSH
46221: LD_VAR 0 2
46225: PPUSH
46226: LD_EXP 121
46230: PUSH
46231: LD_VAR 0 2
46235: ARRAY
46236: PPUSH
46237: LD_VAR 0 3
46241: PPUSH
46242: LD_INT 1
46244: PPUSH
46245: LD_INT 0
46247: PPUSH
46248: CALL 70281 0 4
46252: PPUSH
46253: CALL_OW 1
46257: ST_TO_ADDR
// break ;
46258: GO 46262
// end ;
46260: GO 46182
46262: POP
46263: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46264: LD_EXP 121
46268: PUSH
46269: LD_VAR 0 2
46273: ARRAY
46274: PUSH
46275: LD_INT 1
46277: ARRAY
46278: PUSH
46279: LD_INT 1
46281: ARRAY
46282: PUSH
46283: LD_INT 0
46285: EQUAL
46286: PUSH
46287: LD_VAR 0 5
46291: PUSH
46292: LD_VAR 0 5
46296: PPUSH
46297: LD_EXP 121
46301: PUSH
46302: LD_VAR 0 2
46306: ARRAY
46307: PUSH
46308: LD_INT 1
46310: ARRAY
46311: PUSH
46312: LD_INT 1
46314: ARRAY
46315: PPUSH
46316: LD_EXP 121
46320: PUSH
46321: LD_VAR 0 2
46325: ARRAY
46326: PUSH
46327: LD_INT 1
46329: ARRAY
46330: PUSH
46331: LD_INT 2
46333: ARRAY
46334: PPUSH
46335: LD_EXP 121
46339: PUSH
46340: LD_VAR 0 2
46344: ARRAY
46345: PUSH
46346: LD_INT 1
46348: ARRAY
46349: PUSH
46350: LD_INT 3
46352: ARRAY
46353: PPUSH
46354: LD_EXP 121
46358: PUSH
46359: LD_VAR 0 2
46363: ARRAY
46364: PUSH
46365: LD_INT 1
46367: ARRAY
46368: PUSH
46369: LD_INT 4
46371: ARRAY
46372: PPUSH
46373: CALL 78966 0 5
46377: AND
46378: OR
46379: IFFALSE 46660
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46381: LD_ADDR_VAR 0 4
46385: PUSH
46386: LD_EXP 116
46390: PUSH
46391: LD_VAR 0 2
46395: ARRAY
46396: PPUSH
46397: LD_INT 25
46399: PUSH
46400: LD_INT 2
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PPUSH
46407: CALL_OW 72
46411: PUSH
46412: LD_EXP 118
46416: PUSH
46417: LD_VAR 0 2
46421: ARRAY
46422: DIFF
46423: ST_TO_ADDR
// if not tmp then
46424: LD_VAR 0 4
46428: NOT
46429: IFFALSE 46433
// continue ;
46431: GO 45678
// for j in tmp do
46433: LD_ADDR_VAR 0 3
46437: PUSH
46438: LD_VAR 0 4
46442: PUSH
46443: FOR_IN
46444: IFFALSE 46656
// begin if not mc_builders [ i ] then
46446: LD_EXP 122
46450: PUSH
46451: LD_VAR 0 2
46455: ARRAY
46456: NOT
46457: IFFALSE 46515
// begin SetTag ( j , 103 ) ;
46459: LD_VAR 0 3
46463: PPUSH
46464: LD_INT 103
46466: PPUSH
46467: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46471: LD_ADDR_EXP 122
46475: PUSH
46476: LD_EXP 122
46480: PPUSH
46481: LD_VAR 0 2
46485: PUSH
46486: LD_EXP 122
46490: PUSH
46491: LD_VAR 0 2
46495: ARRAY
46496: PUSH
46497: LD_INT 1
46499: PLUS
46500: PUSH
46501: EMPTY
46502: LIST
46503: LIST
46504: PPUSH
46505: LD_VAR 0 3
46509: PPUSH
46510: CALL 70863 0 3
46514: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46515: LD_VAR 0 3
46519: PPUSH
46520: CALL_OW 310
46524: IFFALSE 46535
// ComExitBuilding ( j ) ;
46526: LD_VAR 0 3
46530: PPUSH
46531: CALL_OW 122
// wait ( 3 ) ;
46535: LD_INT 3
46537: PPUSH
46538: CALL_OW 67
// if not mc_build_list [ i ] then
46542: LD_EXP 121
46546: PUSH
46547: LD_VAR 0 2
46551: ARRAY
46552: NOT
46553: IFFALSE 46557
// break ;
46555: GO 46656
// if not HasTask ( j ) then
46557: LD_VAR 0 3
46561: PPUSH
46562: CALL_OW 314
46566: NOT
46567: IFFALSE 46654
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46569: LD_VAR 0 3
46573: PPUSH
46574: LD_EXP 121
46578: PUSH
46579: LD_VAR 0 2
46583: ARRAY
46584: PUSH
46585: LD_INT 1
46587: ARRAY
46588: PUSH
46589: LD_INT 1
46591: ARRAY
46592: PPUSH
46593: LD_EXP 121
46597: PUSH
46598: LD_VAR 0 2
46602: ARRAY
46603: PUSH
46604: LD_INT 1
46606: ARRAY
46607: PUSH
46608: LD_INT 2
46610: ARRAY
46611: PPUSH
46612: LD_EXP 121
46616: PUSH
46617: LD_VAR 0 2
46621: ARRAY
46622: PUSH
46623: LD_INT 1
46625: ARRAY
46626: PUSH
46627: LD_INT 3
46629: ARRAY
46630: PPUSH
46631: LD_EXP 121
46635: PUSH
46636: LD_VAR 0 2
46640: ARRAY
46641: PUSH
46642: LD_INT 1
46644: ARRAY
46645: PUSH
46646: LD_INT 4
46648: ARRAY
46649: PPUSH
46650: CALL_OW 145
// end ;
46654: GO 46443
46656: POP
46657: POP
// end else
46658: GO 46830
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46660: LD_EXP 116
46664: PUSH
46665: LD_VAR 0 2
46669: ARRAY
46670: PPUSH
46671: LD_EXP 121
46675: PUSH
46676: LD_VAR 0 2
46680: ARRAY
46681: PUSH
46682: LD_INT 1
46684: ARRAY
46685: PUSH
46686: LD_INT 1
46688: ARRAY
46689: PPUSH
46690: LD_EXP 121
46694: PUSH
46695: LD_VAR 0 2
46699: ARRAY
46700: PUSH
46701: LD_INT 1
46703: ARRAY
46704: PUSH
46705: LD_INT 2
46707: ARRAY
46708: PPUSH
46709: LD_EXP 121
46713: PUSH
46714: LD_VAR 0 2
46718: ARRAY
46719: PUSH
46720: LD_INT 1
46722: ARRAY
46723: PUSH
46724: LD_INT 3
46726: ARRAY
46727: PPUSH
46728: LD_EXP 121
46732: PUSH
46733: LD_VAR 0 2
46737: ARRAY
46738: PUSH
46739: LD_INT 1
46741: ARRAY
46742: PUSH
46743: LD_INT 4
46745: ARRAY
46746: PPUSH
46747: LD_EXP 116
46751: PUSH
46752: LD_VAR 0 2
46756: ARRAY
46757: PPUSH
46758: LD_INT 21
46760: PUSH
46761: LD_INT 3
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: PPUSH
46768: CALL_OW 72
46772: PPUSH
46773: EMPTY
46774: PPUSH
46775: CALL 77716 0 7
46779: NOT
46780: IFFALSE 46830
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46782: LD_ADDR_EXP 121
46786: PUSH
46787: LD_EXP 121
46791: PPUSH
46792: LD_VAR 0 2
46796: PPUSH
46797: LD_EXP 121
46801: PUSH
46802: LD_VAR 0 2
46806: ARRAY
46807: PPUSH
46808: LD_INT 1
46810: PPUSH
46811: LD_INT 1
46813: NEG
46814: PPUSH
46815: LD_INT 0
46817: PPUSH
46818: CALL 70281 0 4
46822: PPUSH
46823: CALL_OW 1
46827: ST_TO_ADDR
// continue ;
46828: GO 45678
// end ; end ; end ;
46830: GO 45678
46832: POP
46833: POP
// end ;
46834: LD_VAR 0 1
46838: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46839: LD_INT 0
46841: PPUSH
46842: PPUSH
46843: PPUSH
46844: PPUSH
46845: PPUSH
46846: PPUSH
// if not mc_bases then
46847: LD_EXP 116
46851: NOT
46852: IFFALSE 46856
// exit ;
46854: GO 47283
// for i = 1 to mc_bases do
46856: LD_ADDR_VAR 0 2
46860: PUSH
46861: DOUBLE
46862: LD_INT 1
46864: DEC
46865: ST_TO_ADDR
46866: LD_EXP 116
46870: PUSH
46871: FOR_TO
46872: IFFALSE 47281
// begin tmp := mc_build_upgrade [ i ] ;
46874: LD_ADDR_VAR 0 4
46878: PUSH
46879: LD_EXP 148
46883: PUSH
46884: LD_VAR 0 2
46888: ARRAY
46889: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46890: LD_ADDR_VAR 0 6
46894: PUSH
46895: LD_EXP 149
46899: PUSH
46900: LD_VAR 0 2
46904: ARRAY
46905: PPUSH
46906: LD_INT 2
46908: PUSH
46909: LD_INT 30
46911: PUSH
46912: LD_INT 6
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: PUSH
46919: LD_INT 30
46921: PUSH
46922: LD_INT 7
46924: PUSH
46925: EMPTY
46926: LIST
46927: LIST
46928: PUSH
46929: EMPTY
46930: LIST
46931: LIST
46932: LIST
46933: PPUSH
46934: CALL_OW 72
46938: ST_TO_ADDR
// if not tmp and not lab then
46939: LD_VAR 0 4
46943: NOT
46944: PUSH
46945: LD_VAR 0 6
46949: NOT
46950: AND
46951: IFFALSE 46955
// continue ;
46953: GO 46871
// if tmp then
46955: LD_VAR 0 4
46959: IFFALSE 47079
// for j in tmp do
46961: LD_ADDR_VAR 0 3
46965: PUSH
46966: LD_VAR 0 4
46970: PUSH
46971: FOR_IN
46972: IFFALSE 47077
// begin if UpgradeCost ( j ) then
46974: LD_VAR 0 3
46978: PPUSH
46979: CALL 77376 0 1
46983: IFFALSE 47075
// begin ComUpgrade ( j ) ;
46985: LD_VAR 0 3
46989: PPUSH
46990: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46994: LD_ADDR_EXP 148
46998: PUSH
46999: LD_EXP 148
47003: PPUSH
47004: LD_VAR 0 2
47008: PPUSH
47009: LD_EXP 148
47013: PUSH
47014: LD_VAR 0 2
47018: ARRAY
47019: PUSH
47020: LD_VAR 0 3
47024: DIFF
47025: PPUSH
47026: CALL_OW 1
47030: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47031: LD_ADDR_EXP 123
47035: PUSH
47036: LD_EXP 123
47040: PPUSH
47041: LD_VAR 0 2
47045: PUSH
47046: LD_EXP 123
47050: PUSH
47051: LD_VAR 0 2
47055: ARRAY
47056: PUSH
47057: LD_INT 1
47059: PLUS
47060: PUSH
47061: EMPTY
47062: LIST
47063: LIST
47064: PPUSH
47065: LD_VAR 0 3
47069: PPUSH
47070: CALL 70863 0 3
47074: ST_TO_ADDR
// end ; end ;
47075: GO 46971
47077: POP
47078: POP
// if not lab or not mc_lab_upgrade [ i ] then
47079: LD_VAR 0 6
47083: NOT
47084: PUSH
47085: LD_EXP 150
47089: PUSH
47090: LD_VAR 0 2
47094: ARRAY
47095: NOT
47096: OR
47097: IFFALSE 47101
// continue ;
47099: GO 46871
// for j in lab do
47101: LD_ADDR_VAR 0 3
47105: PUSH
47106: LD_VAR 0 6
47110: PUSH
47111: FOR_IN
47112: IFFALSE 47277
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
47114: LD_VAR 0 3
47118: PPUSH
47119: CALL_OW 266
47123: PUSH
47124: LD_INT 6
47126: PUSH
47127: LD_INT 7
47129: PUSH
47130: EMPTY
47131: LIST
47132: LIST
47133: IN
47134: PUSH
47135: LD_VAR 0 3
47139: PPUSH
47140: CALL_OW 461
47144: PUSH
47145: LD_INT 1
47147: NONEQUAL
47148: AND
47149: IFFALSE 47275
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
47151: LD_VAR 0 3
47155: PPUSH
47156: LD_EXP 150
47160: PUSH
47161: LD_VAR 0 2
47165: ARRAY
47166: PUSH
47167: LD_INT 1
47169: ARRAY
47170: PPUSH
47171: CALL 77581 0 2
47175: IFFALSE 47275
// begin ComCancel ( j ) ;
47177: LD_VAR 0 3
47181: PPUSH
47182: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47186: LD_VAR 0 3
47190: PPUSH
47191: LD_EXP 150
47195: PUSH
47196: LD_VAR 0 2
47200: ARRAY
47201: PUSH
47202: LD_INT 1
47204: ARRAY
47205: PPUSH
47206: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47210: LD_VAR 0 3
47214: PUSH
47215: LD_EXP 123
47219: PUSH
47220: LD_VAR 0 2
47224: ARRAY
47225: IN
47226: NOT
47227: IFFALSE 47273
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47229: LD_ADDR_EXP 123
47233: PUSH
47234: LD_EXP 123
47238: PPUSH
47239: LD_VAR 0 2
47243: PUSH
47244: LD_EXP 123
47248: PUSH
47249: LD_VAR 0 2
47253: ARRAY
47254: PUSH
47255: LD_INT 1
47257: PLUS
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PPUSH
47263: LD_VAR 0 3
47267: PPUSH
47268: CALL 70863 0 3
47272: ST_TO_ADDR
// break ;
47273: GO 47277
// end ; end ; end ;
47275: GO 47111
47277: POP
47278: POP
// end ;
47279: GO 46871
47281: POP
47282: POP
// end ;
47283: LD_VAR 0 1
47287: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47288: LD_INT 0
47290: PPUSH
47291: PPUSH
47292: PPUSH
47293: PPUSH
47294: PPUSH
47295: PPUSH
47296: PPUSH
47297: PPUSH
47298: PPUSH
// if not mc_bases then
47299: LD_EXP 116
47303: NOT
47304: IFFALSE 47308
// exit ;
47306: GO 47713
// for i = 1 to mc_bases do
47308: LD_ADDR_VAR 0 2
47312: PUSH
47313: DOUBLE
47314: LD_INT 1
47316: DEC
47317: ST_TO_ADDR
47318: LD_EXP 116
47322: PUSH
47323: FOR_TO
47324: IFFALSE 47711
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47326: LD_EXP 124
47330: PUSH
47331: LD_VAR 0 2
47335: ARRAY
47336: NOT
47337: PUSH
47338: LD_EXP 116
47342: PUSH
47343: LD_VAR 0 2
47347: ARRAY
47348: PPUSH
47349: LD_INT 30
47351: PUSH
47352: LD_INT 3
47354: PUSH
47355: EMPTY
47356: LIST
47357: LIST
47358: PPUSH
47359: CALL_OW 72
47363: NOT
47364: OR
47365: IFFALSE 47369
// continue ;
47367: GO 47323
// busy := false ;
47369: LD_ADDR_VAR 0 8
47373: PUSH
47374: LD_INT 0
47376: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47377: LD_ADDR_VAR 0 4
47381: PUSH
47382: LD_EXP 116
47386: PUSH
47387: LD_VAR 0 2
47391: ARRAY
47392: PPUSH
47393: LD_INT 30
47395: PUSH
47396: LD_INT 3
47398: PUSH
47399: EMPTY
47400: LIST
47401: LIST
47402: PPUSH
47403: CALL_OW 72
47407: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47408: LD_ADDR_VAR 0 6
47412: PUSH
47413: LD_EXP 124
47417: PUSH
47418: LD_VAR 0 2
47422: ARRAY
47423: PPUSH
47424: LD_INT 2
47426: PUSH
47427: LD_INT 30
47429: PUSH
47430: LD_INT 32
47432: PUSH
47433: EMPTY
47434: LIST
47435: LIST
47436: PUSH
47437: LD_INT 30
47439: PUSH
47440: LD_INT 33
47442: PUSH
47443: EMPTY
47444: LIST
47445: LIST
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: LIST
47451: PPUSH
47452: CALL_OW 72
47456: ST_TO_ADDR
// if not t then
47457: LD_VAR 0 6
47461: NOT
47462: IFFALSE 47466
// continue ;
47464: GO 47323
// for j in tmp do
47466: LD_ADDR_VAR 0 3
47470: PUSH
47471: LD_VAR 0 4
47475: PUSH
47476: FOR_IN
47477: IFFALSE 47507
// if not BuildingStatus ( j ) = bs_idle then
47479: LD_VAR 0 3
47483: PPUSH
47484: CALL_OW 461
47488: PUSH
47489: LD_INT 2
47491: EQUAL
47492: NOT
47493: IFFALSE 47505
// begin busy := true ;
47495: LD_ADDR_VAR 0 8
47499: PUSH
47500: LD_INT 1
47502: ST_TO_ADDR
// break ;
47503: GO 47507
// end ;
47505: GO 47476
47507: POP
47508: POP
// if busy then
47509: LD_VAR 0 8
47513: IFFALSE 47517
// continue ;
47515: GO 47323
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47517: LD_ADDR_VAR 0 7
47521: PUSH
47522: LD_VAR 0 6
47526: PPUSH
47527: LD_INT 35
47529: PUSH
47530: LD_INT 0
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: PPUSH
47537: CALL_OW 72
47541: ST_TO_ADDR
// if tw then
47542: LD_VAR 0 7
47546: IFFALSE 47623
// begin tw := tw [ 1 ] ;
47548: LD_ADDR_VAR 0 7
47552: PUSH
47553: LD_VAR 0 7
47557: PUSH
47558: LD_INT 1
47560: ARRAY
47561: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47562: LD_ADDR_VAR 0 9
47566: PUSH
47567: LD_VAR 0 7
47571: PPUSH
47572: LD_EXP 141
47576: PUSH
47577: LD_VAR 0 2
47581: ARRAY
47582: PPUSH
47583: CALL 75873 0 2
47587: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47588: LD_EXP 155
47592: PUSH
47593: LD_VAR 0 2
47597: ARRAY
47598: IFFALSE 47621
// if not weapon in mc_allowed_tower_weapons [ i ] then
47600: LD_VAR 0 9
47604: PUSH
47605: LD_EXP 155
47609: PUSH
47610: LD_VAR 0 2
47614: ARRAY
47615: IN
47616: NOT
47617: IFFALSE 47621
// continue ;
47619: GO 47323
// end else
47621: GO 47686
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47623: LD_ADDR_VAR 0 5
47627: PUSH
47628: LD_EXP 124
47632: PUSH
47633: LD_VAR 0 2
47637: ARRAY
47638: PPUSH
47639: LD_VAR 0 4
47643: PPUSH
47644: CALL 102162 0 2
47648: ST_TO_ADDR
// if not tmp2 then
47649: LD_VAR 0 5
47653: NOT
47654: IFFALSE 47658
// continue ;
47656: GO 47323
// tw := tmp2 [ 1 ] ;
47658: LD_ADDR_VAR 0 7
47662: PUSH
47663: LD_VAR 0 5
47667: PUSH
47668: LD_INT 1
47670: ARRAY
47671: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47672: LD_ADDR_VAR 0 9
47676: PUSH
47677: LD_VAR 0 5
47681: PUSH
47682: LD_INT 2
47684: ARRAY
47685: ST_TO_ADDR
// end ; if not weapon then
47686: LD_VAR 0 9
47690: NOT
47691: IFFALSE 47695
// continue ;
47693: GO 47323
// ComPlaceWeapon ( tw , weapon ) ;
47695: LD_VAR 0 7
47699: PPUSH
47700: LD_VAR 0 9
47704: PPUSH
47705: CALL_OW 148
// end ;
47709: GO 47323
47711: POP
47712: POP
// end ;
47713: LD_VAR 0 1
47717: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47718: LD_INT 0
47720: PPUSH
47721: PPUSH
47722: PPUSH
47723: PPUSH
47724: PPUSH
47725: PPUSH
47726: PPUSH
// if not mc_bases then
47727: LD_EXP 116
47731: NOT
47732: IFFALSE 47736
// exit ;
47734: GO 48504
// for i = 1 to mc_bases do
47736: LD_ADDR_VAR 0 2
47740: PUSH
47741: DOUBLE
47742: LD_INT 1
47744: DEC
47745: ST_TO_ADDR
47746: LD_EXP 116
47750: PUSH
47751: FOR_TO
47752: IFFALSE 48502
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47754: LD_EXP 129
47758: PUSH
47759: LD_VAR 0 2
47763: ARRAY
47764: NOT
47765: PUSH
47766: LD_EXP 129
47770: PUSH
47771: LD_VAR 0 2
47775: ARRAY
47776: PUSH
47777: LD_EXP 130
47781: PUSH
47782: LD_VAR 0 2
47786: ARRAY
47787: EQUAL
47788: OR
47789: PUSH
47790: LD_EXP 139
47794: PUSH
47795: LD_VAR 0 2
47799: ARRAY
47800: OR
47801: IFFALSE 47805
// continue ;
47803: GO 47751
// if mc_miners [ i ] then
47805: LD_EXP 130
47809: PUSH
47810: LD_VAR 0 2
47814: ARRAY
47815: IFFALSE 48189
// begin for j = mc_miners [ i ] downto 1 do
47817: LD_ADDR_VAR 0 3
47821: PUSH
47822: DOUBLE
47823: LD_EXP 130
47827: PUSH
47828: LD_VAR 0 2
47832: ARRAY
47833: INC
47834: ST_TO_ADDR
47835: LD_INT 1
47837: PUSH
47838: FOR_DOWNTO
47839: IFFALSE 48187
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47841: LD_EXP 130
47845: PUSH
47846: LD_VAR 0 2
47850: ARRAY
47851: PUSH
47852: LD_VAR 0 3
47856: ARRAY
47857: PPUSH
47858: CALL_OW 301
47862: PUSH
47863: LD_EXP 130
47867: PUSH
47868: LD_VAR 0 2
47872: ARRAY
47873: PUSH
47874: LD_VAR 0 3
47878: ARRAY
47879: PPUSH
47880: CALL_OW 257
47884: PUSH
47885: LD_INT 1
47887: NONEQUAL
47888: OR
47889: IFFALSE 47952
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47891: LD_ADDR_VAR 0 5
47895: PUSH
47896: LD_EXP 130
47900: PUSH
47901: LD_VAR 0 2
47905: ARRAY
47906: PUSH
47907: LD_EXP 130
47911: PUSH
47912: LD_VAR 0 2
47916: ARRAY
47917: PUSH
47918: LD_VAR 0 3
47922: ARRAY
47923: DIFF
47924: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47925: LD_ADDR_EXP 130
47929: PUSH
47930: LD_EXP 130
47934: PPUSH
47935: LD_VAR 0 2
47939: PPUSH
47940: LD_VAR 0 5
47944: PPUSH
47945: CALL_OW 1
47949: ST_TO_ADDR
// continue ;
47950: GO 47838
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47952: LD_EXP 130
47956: PUSH
47957: LD_VAR 0 2
47961: ARRAY
47962: PUSH
47963: LD_VAR 0 3
47967: ARRAY
47968: PPUSH
47969: CALL_OW 257
47973: PUSH
47974: LD_INT 1
47976: EQUAL
47977: PUSH
47978: LD_EXP 130
47982: PUSH
47983: LD_VAR 0 2
47987: ARRAY
47988: PUSH
47989: LD_VAR 0 3
47993: ARRAY
47994: PPUSH
47995: CALL_OW 459
47999: NOT
48000: AND
48001: PUSH
48002: LD_EXP 130
48006: PUSH
48007: LD_VAR 0 2
48011: ARRAY
48012: PUSH
48013: LD_VAR 0 3
48017: ARRAY
48018: PPUSH
48019: CALL_OW 314
48023: NOT
48024: AND
48025: IFFALSE 48185
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
48027: LD_EXP 130
48031: PUSH
48032: LD_VAR 0 2
48036: ARRAY
48037: PUSH
48038: LD_VAR 0 3
48042: ARRAY
48043: PPUSH
48044: CALL_OW 310
48048: IFFALSE 48071
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
48050: LD_EXP 130
48054: PUSH
48055: LD_VAR 0 2
48059: ARRAY
48060: PUSH
48061: LD_VAR 0 3
48065: ARRAY
48066: PPUSH
48067: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
48071: LD_EXP 130
48075: PUSH
48076: LD_VAR 0 2
48080: ARRAY
48081: PUSH
48082: LD_VAR 0 3
48086: ARRAY
48087: PPUSH
48088: CALL_OW 314
48092: NOT
48093: IFFALSE 48185
// begin r := rand ( 1 , mc_mines [ i ] ) ;
48095: LD_ADDR_VAR 0 7
48099: PUSH
48100: LD_INT 1
48102: PPUSH
48103: LD_EXP 129
48107: PUSH
48108: LD_VAR 0 2
48112: ARRAY
48113: PPUSH
48114: CALL_OW 12
48118: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
48119: LD_EXP 130
48123: PUSH
48124: LD_VAR 0 2
48128: ARRAY
48129: PUSH
48130: LD_VAR 0 3
48134: ARRAY
48135: PPUSH
48136: LD_EXP 129
48140: PUSH
48141: LD_VAR 0 2
48145: ARRAY
48146: PUSH
48147: LD_VAR 0 7
48151: ARRAY
48152: PUSH
48153: LD_INT 1
48155: ARRAY
48156: PPUSH
48157: LD_EXP 129
48161: PUSH
48162: LD_VAR 0 2
48166: ARRAY
48167: PUSH
48168: LD_VAR 0 7
48172: ARRAY
48173: PUSH
48174: LD_INT 2
48176: ARRAY
48177: PPUSH
48178: LD_INT 0
48180: PPUSH
48181: CALL_OW 193
// end ; end ; end ;
48185: GO 47838
48187: POP
48188: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48189: LD_ADDR_VAR 0 5
48193: PUSH
48194: LD_EXP 116
48198: PUSH
48199: LD_VAR 0 2
48203: ARRAY
48204: PPUSH
48205: LD_INT 2
48207: PUSH
48208: LD_INT 30
48210: PUSH
48211: LD_INT 4
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: PUSH
48218: LD_INT 30
48220: PUSH
48221: LD_INT 5
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: PUSH
48228: LD_INT 30
48230: PUSH
48231: LD_INT 32
48233: PUSH
48234: EMPTY
48235: LIST
48236: LIST
48237: PUSH
48238: EMPTY
48239: LIST
48240: LIST
48241: LIST
48242: LIST
48243: PPUSH
48244: CALL_OW 72
48248: ST_TO_ADDR
// if not tmp then
48249: LD_VAR 0 5
48253: NOT
48254: IFFALSE 48258
// continue ;
48256: GO 47751
// list := [ ] ;
48258: LD_ADDR_VAR 0 6
48262: PUSH
48263: EMPTY
48264: ST_TO_ADDR
// for j in tmp do
48265: LD_ADDR_VAR 0 3
48269: PUSH
48270: LD_VAR 0 5
48274: PUSH
48275: FOR_IN
48276: IFFALSE 48345
// begin for k in UnitsInside ( j ) do
48278: LD_ADDR_VAR 0 4
48282: PUSH
48283: LD_VAR 0 3
48287: PPUSH
48288: CALL_OW 313
48292: PUSH
48293: FOR_IN
48294: IFFALSE 48341
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48296: LD_VAR 0 4
48300: PPUSH
48301: CALL_OW 257
48305: PUSH
48306: LD_INT 1
48308: EQUAL
48309: PUSH
48310: LD_VAR 0 4
48314: PPUSH
48315: CALL_OW 459
48319: NOT
48320: AND
48321: IFFALSE 48339
// list := list ^ k ;
48323: LD_ADDR_VAR 0 6
48327: PUSH
48328: LD_VAR 0 6
48332: PUSH
48333: LD_VAR 0 4
48337: ADD
48338: ST_TO_ADDR
48339: GO 48293
48341: POP
48342: POP
// end ;
48343: GO 48275
48345: POP
48346: POP
// list := list diff mc_miners [ i ] ;
48347: LD_ADDR_VAR 0 6
48351: PUSH
48352: LD_VAR 0 6
48356: PUSH
48357: LD_EXP 130
48361: PUSH
48362: LD_VAR 0 2
48366: ARRAY
48367: DIFF
48368: ST_TO_ADDR
// if not list then
48369: LD_VAR 0 6
48373: NOT
48374: IFFALSE 48378
// continue ;
48376: GO 47751
// k := mc_mines [ i ] - mc_miners [ i ] ;
48378: LD_ADDR_VAR 0 4
48382: PUSH
48383: LD_EXP 129
48387: PUSH
48388: LD_VAR 0 2
48392: ARRAY
48393: PUSH
48394: LD_EXP 130
48398: PUSH
48399: LD_VAR 0 2
48403: ARRAY
48404: MINUS
48405: ST_TO_ADDR
// if k > list then
48406: LD_VAR 0 4
48410: PUSH
48411: LD_VAR 0 6
48415: GREATER
48416: IFFALSE 48428
// k := list ;
48418: LD_ADDR_VAR 0 4
48422: PUSH
48423: LD_VAR 0 6
48427: ST_TO_ADDR
// for j = 1 to k do
48428: LD_ADDR_VAR 0 3
48432: PUSH
48433: DOUBLE
48434: LD_INT 1
48436: DEC
48437: ST_TO_ADDR
48438: LD_VAR 0 4
48442: PUSH
48443: FOR_TO
48444: IFFALSE 48498
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48446: LD_ADDR_EXP 130
48450: PUSH
48451: LD_EXP 130
48455: PPUSH
48456: LD_VAR 0 2
48460: PUSH
48461: LD_EXP 130
48465: PUSH
48466: LD_VAR 0 2
48470: ARRAY
48471: PUSH
48472: LD_INT 1
48474: PLUS
48475: PUSH
48476: EMPTY
48477: LIST
48478: LIST
48479: PPUSH
48480: LD_VAR 0 6
48484: PUSH
48485: LD_VAR 0 3
48489: ARRAY
48490: PPUSH
48491: CALL 70863 0 3
48495: ST_TO_ADDR
48496: GO 48443
48498: POP
48499: POP
// end ;
48500: GO 47751
48502: POP
48503: POP
// end ;
48504: LD_VAR 0 1
48508: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48509: LD_INT 0
48511: PPUSH
48512: PPUSH
48513: PPUSH
48514: PPUSH
48515: PPUSH
48516: PPUSH
48517: PPUSH
48518: PPUSH
48519: PPUSH
48520: PPUSH
48521: PPUSH
// if not mc_bases then
48522: LD_EXP 116
48526: NOT
48527: IFFALSE 48531
// exit ;
48529: GO 50354
// for i = 1 to mc_bases do
48531: LD_ADDR_VAR 0 2
48535: PUSH
48536: DOUBLE
48537: LD_INT 1
48539: DEC
48540: ST_TO_ADDR
48541: LD_EXP 116
48545: PUSH
48546: FOR_TO
48547: IFFALSE 50352
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48549: LD_EXP 116
48553: PUSH
48554: LD_VAR 0 2
48558: ARRAY
48559: NOT
48560: PUSH
48561: LD_EXP 123
48565: PUSH
48566: LD_VAR 0 2
48570: ARRAY
48571: OR
48572: IFFALSE 48576
// continue ;
48574: GO 48546
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48576: LD_EXP 132
48580: PUSH
48581: LD_VAR 0 2
48585: ARRAY
48586: NOT
48587: PUSH
48588: LD_EXP 133
48592: PUSH
48593: LD_VAR 0 2
48597: ARRAY
48598: AND
48599: IFFALSE 48637
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48601: LD_ADDR_EXP 133
48605: PUSH
48606: LD_EXP 133
48610: PPUSH
48611: LD_VAR 0 2
48615: PPUSH
48616: EMPTY
48617: PPUSH
48618: CALL_OW 1
48622: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48623: LD_VAR 0 2
48627: PPUSH
48628: LD_INT 107
48630: PPUSH
48631: CALL 39405 0 2
// continue ;
48635: GO 48546
// end ; target := [ ] ;
48637: LD_ADDR_VAR 0 7
48641: PUSH
48642: EMPTY
48643: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48644: LD_ADDR_VAR 0 6
48648: PUSH
48649: LD_EXP 116
48653: PUSH
48654: LD_VAR 0 2
48658: ARRAY
48659: PUSH
48660: LD_INT 1
48662: ARRAY
48663: PPUSH
48664: CALL_OW 255
48668: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48669: LD_ADDR_VAR 0 9
48673: PUSH
48674: LD_EXP 116
48678: PUSH
48679: LD_VAR 0 2
48683: ARRAY
48684: PPUSH
48685: LD_INT 2
48687: PUSH
48688: LD_INT 30
48690: PUSH
48691: LD_INT 0
48693: PUSH
48694: EMPTY
48695: LIST
48696: LIST
48697: PUSH
48698: LD_INT 30
48700: PUSH
48701: LD_INT 1
48703: PUSH
48704: EMPTY
48705: LIST
48706: LIST
48707: PUSH
48708: EMPTY
48709: LIST
48710: LIST
48711: LIST
48712: PPUSH
48713: CALL_OW 72
48717: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48718: LD_ADDR_VAR 0 3
48722: PUSH
48723: DOUBLE
48724: LD_EXP 132
48728: PUSH
48729: LD_VAR 0 2
48733: ARRAY
48734: INC
48735: ST_TO_ADDR
48736: LD_INT 1
48738: PUSH
48739: FOR_DOWNTO
48740: IFFALSE 48985
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48742: LD_EXP 132
48746: PUSH
48747: LD_VAR 0 2
48751: ARRAY
48752: PUSH
48753: LD_VAR 0 3
48757: ARRAY
48758: PUSH
48759: LD_INT 2
48761: ARRAY
48762: PPUSH
48763: LD_EXP 132
48767: PUSH
48768: LD_VAR 0 2
48772: ARRAY
48773: PUSH
48774: LD_VAR 0 3
48778: ARRAY
48779: PUSH
48780: LD_INT 3
48782: ARRAY
48783: PPUSH
48784: CALL_OW 488
48788: PUSH
48789: LD_EXP 132
48793: PUSH
48794: LD_VAR 0 2
48798: ARRAY
48799: PUSH
48800: LD_VAR 0 3
48804: ARRAY
48805: PUSH
48806: LD_INT 2
48808: ARRAY
48809: PPUSH
48810: LD_EXP 132
48814: PUSH
48815: LD_VAR 0 2
48819: ARRAY
48820: PUSH
48821: LD_VAR 0 3
48825: ARRAY
48826: PUSH
48827: LD_INT 3
48829: ARRAY
48830: PPUSH
48831: CALL_OW 284
48835: PUSH
48836: LD_INT 0
48838: EQUAL
48839: AND
48840: IFFALSE 48895
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48842: LD_ADDR_VAR 0 5
48846: PUSH
48847: LD_EXP 132
48851: PUSH
48852: LD_VAR 0 2
48856: ARRAY
48857: PPUSH
48858: LD_VAR 0 3
48862: PPUSH
48863: CALL_OW 3
48867: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48868: LD_ADDR_EXP 132
48872: PUSH
48873: LD_EXP 132
48877: PPUSH
48878: LD_VAR 0 2
48882: PPUSH
48883: LD_VAR 0 5
48887: PPUSH
48888: CALL_OW 1
48892: ST_TO_ADDR
// continue ;
48893: GO 48739
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48895: LD_VAR 0 6
48899: PPUSH
48900: LD_EXP 132
48904: PUSH
48905: LD_VAR 0 2
48909: ARRAY
48910: PUSH
48911: LD_VAR 0 3
48915: ARRAY
48916: PUSH
48917: LD_INT 2
48919: ARRAY
48920: PPUSH
48921: LD_EXP 132
48925: PUSH
48926: LD_VAR 0 2
48930: ARRAY
48931: PUSH
48932: LD_VAR 0 3
48936: ARRAY
48937: PUSH
48938: LD_INT 3
48940: ARRAY
48941: PPUSH
48942: LD_INT 30
48944: PPUSH
48945: CALL 71759 0 4
48949: PUSH
48950: LD_INT 4
48952: ARRAY
48953: PUSH
48954: LD_INT 0
48956: EQUAL
48957: IFFALSE 48983
// begin target := mc_crates [ i ] [ j ] ;
48959: LD_ADDR_VAR 0 7
48963: PUSH
48964: LD_EXP 132
48968: PUSH
48969: LD_VAR 0 2
48973: ARRAY
48974: PUSH
48975: LD_VAR 0 3
48979: ARRAY
48980: ST_TO_ADDR
// break ;
48981: GO 48985
// end ; end ;
48983: GO 48739
48985: POP
48986: POP
// if not target then
48987: LD_VAR 0 7
48991: NOT
48992: IFFALSE 48996
// continue ;
48994: GO 48546
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48996: LD_ADDR_VAR 0 8
49000: PUSH
49001: LD_EXP 135
49005: PUSH
49006: LD_VAR 0 2
49010: ARRAY
49011: PPUSH
49012: LD_INT 2
49014: PUSH
49015: LD_INT 3
49017: PUSH
49018: LD_INT 58
49020: PUSH
49021: EMPTY
49022: LIST
49023: PUSH
49024: EMPTY
49025: LIST
49026: LIST
49027: PUSH
49028: LD_INT 61
49030: PUSH
49031: EMPTY
49032: LIST
49033: PUSH
49034: LD_INT 33
49036: PUSH
49037: LD_INT 5
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: PUSH
49044: LD_INT 33
49046: PUSH
49047: LD_INT 3
49049: PUSH
49050: EMPTY
49051: LIST
49052: LIST
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: LIST
49060: PUSH
49061: LD_INT 2
49063: PUSH
49064: LD_INT 34
49066: PUSH
49067: LD_INT 32
49069: PUSH
49070: EMPTY
49071: LIST
49072: LIST
49073: PUSH
49074: LD_INT 34
49076: PUSH
49077: LD_INT 51
49079: PUSH
49080: EMPTY
49081: LIST
49082: LIST
49083: PUSH
49084: LD_INT 34
49086: PUSH
49087: LD_INT 12
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: EMPTY
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: PPUSH
49104: CALL_OW 72
49108: ST_TO_ADDR
// if not cargo then
49109: LD_VAR 0 8
49113: NOT
49114: IFFALSE 49820
// begin if mc_crates_collector [ i ] < 5 then
49116: LD_EXP 133
49120: PUSH
49121: LD_VAR 0 2
49125: ARRAY
49126: PUSH
49127: LD_INT 5
49129: LESS
49130: IFFALSE 49496
// begin if mc_ape [ i ] then
49132: LD_EXP 145
49136: PUSH
49137: LD_VAR 0 2
49141: ARRAY
49142: IFFALSE 49189
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
49144: LD_ADDR_VAR 0 5
49148: PUSH
49149: LD_EXP 145
49153: PUSH
49154: LD_VAR 0 2
49158: ARRAY
49159: PPUSH
49160: LD_INT 25
49162: PUSH
49163: LD_INT 16
49165: PUSH
49166: EMPTY
49167: LIST
49168: LIST
49169: PUSH
49170: LD_INT 24
49172: PUSH
49173: LD_INT 750
49175: PUSH
49176: EMPTY
49177: LIST
49178: LIST
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: PPUSH
49184: CALL_OW 72
49188: ST_TO_ADDR
// if not tmp then
49189: LD_VAR 0 5
49193: NOT
49194: IFFALSE 49241
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49196: LD_ADDR_VAR 0 5
49200: PUSH
49201: LD_EXP 116
49205: PUSH
49206: LD_VAR 0 2
49210: ARRAY
49211: PPUSH
49212: LD_INT 25
49214: PUSH
49215: LD_INT 2
49217: PUSH
49218: EMPTY
49219: LIST
49220: LIST
49221: PUSH
49222: LD_INT 24
49224: PUSH
49225: LD_INT 750
49227: PUSH
49228: EMPTY
49229: LIST
49230: LIST
49231: PUSH
49232: EMPTY
49233: LIST
49234: LIST
49235: PPUSH
49236: CALL_OW 72
49240: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49241: LD_EXP 145
49245: PUSH
49246: LD_VAR 0 2
49250: ARRAY
49251: PUSH
49252: LD_EXP 116
49256: PUSH
49257: LD_VAR 0 2
49261: ARRAY
49262: PPUSH
49263: LD_INT 25
49265: PUSH
49266: LD_INT 2
49268: PUSH
49269: EMPTY
49270: LIST
49271: LIST
49272: PUSH
49273: LD_INT 24
49275: PUSH
49276: LD_INT 750
49278: PUSH
49279: EMPTY
49280: LIST
49281: LIST
49282: PUSH
49283: EMPTY
49284: LIST
49285: LIST
49286: PPUSH
49287: CALL_OW 72
49291: AND
49292: PUSH
49293: LD_VAR 0 5
49297: PUSH
49298: LD_INT 5
49300: LESS
49301: AND
49302: IFFALSE 49384
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49304: LD_ADDR_VAR 0 3
49308: PUSH
49309: LD_EXP 116
49313: PUSH
49314: LD_VAR 0 2
49318: ARRAY
49319: PPUSH
49320: LD_INT 25
49322: PUSH
49323: LD_INT 2
49325: PUSH
49326: EMPTY
49327: LIST
49328: LIST
49329: PUSH
49330: LD_INT 24
49332: PUSH
49333: LD_INT 750
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: PUSH
49340: EMPTY
49341: LIST
49342: LIST
49343: PPUSH
49344: CALL_OW 72
49348: PUSH
49349: FOR_IN
49350: IFFALSE 49382
// begin tmp := tmp union j ;
49352: LD_ADDR_VAR 0 5
49356: PUSH
49357: LD_VAR 0 5
49361: PUSH
49362: LD_VAR 0 3
49366: UNION
49367: ST_TO_ADDR
// if tmp >= 5 then
49368: LD_VAR 0 5
49372: PUSH
49373: LD_INT 5
49375: GREATEREQUAL
49376: IFFALSE 49380
// break ;
49378: GO 49382
// end ;
49380: GO 49349
49382: POP
49383: POP
// end ; if not tmp then
49384: LD_VAR 0 5
49388: NOT
49389: IFFALSE 49393
// continue ;
49391: GO 48546
// for j in tmp do
49393: LD_ADDR_VAR 0 3
49397: PUSH
49398: LD_VAR 0 5
49402: PUSH
49403: FOR_IN
49404: IFFALSE 49494
// if not GetTag ( j ) then
49406: LD_VAR 0 3
49410: PPUSH
49411: CALL_OW 110
49415: NOT
49416: IFFALSE 49492
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49418: LD_ADDR_EXP 133
49422: PUSH
49423: LD_EXP 133
49427: PPUSH
49428: LD_VAR 0 2
49432: PUSH
49433: LD_EXP 133
49437: PUSH
49438: LD_VAR 0 2
49442: ARRAY
49443: PUSH
49444: LD_INT 1
49446: PLUS
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: PPUSH
49452: LD_VAR 0 3
49456: PPUSH
49457: CALL 70863 0 3
49461: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49462: LD_VAR 0 3
49466: PPUSH
49467: LD_INT 107
49469: PPUSH
49470: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49474: LD_EXP 133
49478: PUSH
49479: LD_VAR 0 2
49483: ARRAY
49484: PUSH
49485: LD_INT 5
49487: GREATEREQUAL
49488: IFFALSE 49492
// break ;
49490: GO 49494
// end ;
49492: GO 49403
49494: POP
49495: POP
// end ; if mc_crates_collector [ i ] and target then
49496: LD_EXP 133
49500: PUSH
49501: LD_VAR 0 2
49505: ARRAY
49506: PUSH
49507: LD_VAR 0 7
49511: AND
49512: IFFALSE 49818
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49514: LD_EXP 133
49518: PUSH
49519: LD_VAR 0 2
49523: ARRAY
49524: PUSH
49525: LD_VAR 0 7
49529: PUSH
49530: LD_INT 1
49532: ARRAY
49533: LESS
49534: IFFALSE 49554
// tmp := mc_crates_collector [ i ] else
49536: LD_ADDR_VAR 0 5
49540: PUSH
49541: LD_EXP 133
49545: PUSH
49546: LD_VAR 0 2
49550: ARRAY
49551: ST_TO_ADDR
49552: GO 49568
// tmp := target [ 1 ] ;
49554: LD_ADDR_VAR 0 5
49558: PUSH
49559: LD_VAR 0 7
49563: PUSH
49564: LD_INT 1
49566: ARRAY
49567: ST_TO_ADDR
// k := 0 ;
49568: LD_ADDR_VAR 0 4
49572: PUSH
49573: LD_INT 0
49575: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49576: LD_ADDR_VAR 0 3
49580: PUSH
49581: LD_EXP 133
49585: PUSH
49586: LD_VAR 0 2
49590: ARRAY
49591: PUSH
49592: FOR_IN
49593: IFFALSE 49816
// begin k := k + 1 ;
49595: LD_ADDR_VAR 0 4
49599: PUSH
49600: LD_VAR 0 4
49604: PUSH
49605: LD_INT 1
49607: PLUS
49608: ST_TO_ADDR
// if k > tmp then
49609: LD_VAR 0 4
49613: PUSH
49614: LD_VAR 0 5
49618: GREATER
49619: IFFALSE 49623
// break ;
49621: GO 49816
// if not GetClass ( j ) in [ 2 , 16 ] then
49623: LD_VAR 0 3
49627: PPUSH
49628: CALL_OW 257
49632: PUSH
49633: LD_INT 2
49635: PUSH
49636: LD_INT 16
49638: PUSH
49639: EMPTY
49640: LIST
49641: LIST
49642: IN
49643: NOT
49644: IFFALSE 49697
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49646: LD_ADDR_EXP 133
49650: PUSH
49651: LD_EXP 133
49655: PPUSH
49656: LD_VAR 0 2
49660: PPUSH
49661: LD_EXP 133
49665: PUSH
49666: LD_VAR 0 2
49670: ARRAY
49671: PUSH
49672: LD_VAR 0 3
49676: DIFF
49677: PPUSH
49678: CALL_OW 1
49682: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49683: LD_VAR 0 3
49687: PPUSH
49688: LD_INT 0
49690: PPUSH
49691: CALL_OW 109
// continue ;
49695: GO 49592
// end ; if IsInUnit ( j ) then
49697: LD_VAR 0 3
49701: PPUSH
49702: CALL_OW 310
49706: IFFALSE 49717
// ComExitBuilding ( j ) ;
49708: LD_VAR 0 3
49712: PPUSH
49713: CALL_OW 122
// wait ( 3 ) ;
49717: LD_INT 3
49719: PPUSH
49720: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49724: LD_VAR 0 3
49728: PPUSH
49729: CALL_OW 314
49733: PUSH
49734: LD_VAR 0 6
49738: PPUSH
49739: LD_VAR 0 7
49743: PUSH
49744: LD_INT 2
49746: ARRAY
49747: PPUSH
49748: LD_VAR 0 7
49752: PUSH
49753: LD_INT 3
49755: ARRAY
49756: PPUSH
49757: LD_INT 30
49759: PPUSH
49760: CALL 71759 0 4
49764: PUSH
49765: LD_INT 4
49767: ARRAY
49768: AND
49769: IFFALSE 49787
// ComStandNearbyBuilding ( j , depot ) else
49771: LD_VAR 0 3
49775: PPUSH
49776: LD_VAR 0 9
49780: PPUSH
49781: CALL 67441 0 2
49785: GO 49814
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49787: LD_VAR 0 3
49791: PPUSH
49792: LD_VAR 0 7
49796: PUSH
49797: LD_INT 2
49799: ARRAY
49800: PPUSH
49801: LD_VAR 0 7
49805: PUSH
49806: LD_INT 3
49808: ARRAY
49809: PPUSH
49810: CALL_OW 117
// end ;
49814: GO 49592
49816: POP
49817: POP
// end ; end else
49818: GO 50350
// begin for j in cargo do
49820: LD_ADDR_VAR 0 3
49824: PUSH
49825: LD_VAR 0 8
49829: PUSH
49830: FOR_IN
49831: IFFALSE 50348
// begin if GetTag ( j ) <> 0 then
49833: LD_VAR 0 3
49837: PPUSH
49838: CALL_OW 110
49842: PUSH
49843: LD_INT 0
49845: NONEQUAL
49846: IFFALSE 49850
// continue ;
49848: GO 49830
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49850: LD_VAR 0 3
49854: PPUSH
49855: CALL_OW 256
49859: PUSH
49860: LD_INT 1000
49862: LESS
49863: PUSH
49864: LD_VAR 0 3
49868: PPUSH
49869: LD_EXP 140
49873: PUSH
49874: LD_VAR 0 2
49878: ARRAY
49879: PPUSH
49880: CALL_OW 308
49884: NOT
49885: AND
49886: IFFALSE 49908
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49888: LD_VAR 0 3
49892: PPUSH
49893: LD_EXP 140
49897: PUSH
49898: LD_VAR 0 2
49902: ARRAY
49903: PPUSH
49904: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49908: LD_VAR 0 3
49912: PPUSH
49913: CALL_OW 256
49917: PUSH
49918: LD_INT 1000
49920: LESS
49921: PUSH
49922: LD_VAR 0 3
49926: PPUSH
49927: LD_EXP 140
49931: PUSH
49932: LD_VAR 0 2
49936: ARRAY
49937: PPUSH
49938: CALL_OW 308
49942: AND
49943: IFFALSE 49947
// continue ;
49945: GO 49830
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49947: LD_VAR 0 3
49951: PPUSH
49952: CALL_OW 262
49956: PUSH
49957: LD_INT 2
49959: EQUAL
49960: PUSH
49961: LD_VAR 0 3
49965: PPUSH
49966: CALL_OW 261
49970: PUSH
49971: LD_INT 15
49973: LESS
49974: AND
49975: IFFALSE 49979
// continue ;
49977: GO 49830
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49979: LD_VAR 0 3
49983: PPUSH
49984: CALL_OW 262
49988: PUSH
49989: LD_INT 1
49991: EQUAL
49992: PUSH
49993: LD_VAR 0 3
49997: PPUSH
49998: CALL_OW 261
50002: PUSH
50003: LD_INT 10
50005: LESS
50006: AND
50007: IFFALSE 50287
// begin if not depot then
50009: LD_VAR 0 9
50013: NOT
50014: IFFALSE 50018
// continue ;
50016: GO 49830
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
50018: LD_VAR 0 3
50022: PPUSH
50023: LD_VAR 0 9
50027: PPUSH
50028: LD_VAR 0 3
50032: PPUSH
50033: CALL_OW 74
50037: PPUSH
50038: CALL_OW 296
50042: PUSH
50043: LD_INT 6
50045: LESS
50046: IFFALSE 50062
// SetFuel ( j , 100 ) else
50048: LD_VAR 0 3
50052: PPUSH
50053: LD_INT 100
50055: PPUSH
50056: CALL_OW 240
50060: GO 50287
// if GetFuel ( j ) = 0 then
50062: LD_VAR 0 3
50066: PPUSH
50067: CALL_OW 261
50071: PUSH
50072: LD_INT 0
50074: EQUAL
50075: IFFALSE 50287
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
50077: LD_ADDR_EXP 135
50081: PUSH
50082: LD_EXP 135
50086: PPUSH
50087: LD_VAR 0 2
50091: PPUSH
50092: LD_EXP 135
50096: PUSH
50097: LD_VAR 0 2
50101: ARRAY
50102: PUSH
50103: LD_VAR 0 3
50107: DIFF
50108: PPUSH
50109: CALL_OW 1
50113: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
50114: LD_VAR 0 3
50118: PPUSH
50119: CALL_OW 263
50123: PUSH
50124: LD_INT 1
50126: EQUAL
50127: IFFALSE 50143
// ComExitVehicle ( IsInUnit ( j ) ) ;
50129: LD_VAR 0 3
50133: PPUSH
50134: CALL_OW 310
50138: PPUSH
50139: CALL_OW 121
// if GetControl ( j ) = control_remote then
50143: LD_VAR 0 3
50147: PPUSH
50148: CALL_OW 263
50152: PUSH
50153: LD_INT 2
50155: EQUAL
50156: IFFALSE 50167
// ComUnlink ( j ) ;
50158: LD_VAR 0 3
50162: PPUSH
50163: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50167: LD_ADDR_VAR 0 10
50171: PUSH
50172: LD_VAR 0 2
50176: PPUSH
50177: LD_INT 3
50179: PPUSH
50180: CALL 59926 0 2
50184: ST_TO_ADDR
// if fac then
50185: LD_VAR 0 10
50189: IFFALSE 50285
// begin for k in fac do
50191: LD_ADDR_VAR 0 4
50195: PUSH
50196: LD_VAR 0 10
50200: PUSH
50201: FOR_IN
50202: IFFALSE 50283
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50204: LD_ADDR_VAR 0 11
50208: PUSH
50209: LD_VAR 0 10
50213: PPUSH
50214: LD_VAR 0 3
50218: PPUSH
50219: CALL_OW 265
50223: PPUSH
50224: LD_VAR 0 3
50228: PPUSH
50229: CALL_OW 262
50233: PPUSH
50234: LD_VAR 0 3
50238: PPUSH
50239: CALL_OW 263
50243: PPUSH
50244: LD_VAR 0 3
50248: PPUSH
50249: CALL_OW 264
50253: PPUSH
50254: CALL 68359 0 5
50258: ST_TO_ADDR
// if components then
50259: LD_VAR 0 11
50263: IFFALSE 50281
// begin MC_InsertProduceList ( i , components ) ;
50265: LD_VAR 0 2
50269: PPUSH
50270: LD_VAR 0 11
50274: PPUSH
50275: CALL 59471 0 2
// break ;
50279: GO 50283
// end ; end ;
50281: GO 50201
50283: POP
50284: POP
// end ; continue ;
50285: GO 49830
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50287: LD_VAR 0 3
50291: PPUSH
50292: LD_INT 1
50294: PPUSH
50295: CALL_OW 289
50299: PUSH
50300: LD_INT 100
50302: LESS
50303: PUSH
50304: LD_VAR 0 3
50308: PPUSH
50309: CALL_OW 314
50313: NOT
50314: AND
50315: IFFALSE 50344
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50317: LD_VAR 0 3
50321: PPUSH
50322: LD_VAR 0 7
50326: PUSH
50327: LD_INT 2
50329: ARRAY
50330: PPUSH
50331: LD_VAR 0 7
50335: PUSH
50336: LD_INT 3
50338: ARRAY
50339: PPUSH
50340: CALL_OW 117
// break ;
50344: GO 50348
// end ;
50346: GO 49830
50348: POP
50349: POP
// end ; end ;
50350: GO 48546
50352: POP
50353: POP
// end ;
50354: LD_VAR 0 1
50358: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50359: LD_INT 0
50361: PPUSH
50362: PPUSH
50363: PPUSH
50364: PPUSH
// if not mc_bases then
50365: LD_EXP 116
50369: NOT
50370: IFFALSE 50374
// exit ;
50372: GO 50535
// for i = 1 to mc_bases do
50374: LD_ADDR_VAR 0 2
50378: PUSH
50379: DOUBLE
50380: LD_INT 1
50382: DEC
50383: ST_TO_ADDR
50384: LD_EXP 116
50388: PUSH
50389: FOR_TO
50390: IFFALSE 50533
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50392: LD_ADDR_VAR 0 4
50396: PUSH
50397: LD_EXP 135
50401: PUSH
50402: LD_VAR 0 2
50406: ARRAY
50407: PUSH
50408: LD_EXP 138
50412: PUSH
50413: LD_VAR 0 2
50417: ARRAY
50418: UNION
50419: PPUSH
50420: LD_INT 33
50422: PUSH
50423: LD_INT 2
50425: PUSH
50426: EMPTY
50427: LIST
50428: LIST
50429: PPUSH
50430: CALL_OW 72
50434: ST_TO_ADDR
// if tmp then
50435: LD_VAR 0 4
50439: IFFALSE 50531
// for j in tmp do
50441: LD_ADDR_VAR 0 3
50445: PUSH
50446: LD_VAR 0 4
50450: PUSH
50451: FOR_IN
50452: IFFALSE 50529
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50454: LD_VAR 0 3
50458: PPUSH
50459: CALL_OW 312
50463: NOT
50464: PUSH
50465: LD_VAR 0 3
50469: PPUSH
50470: CALL_OW 256
50474: PUSH
50475: LD_INT 250
50477: GREATEREQUAL
50478: AND
50479: IFFALSE 50492
// Connect ( j ) else
50481: LD_VAR 0 3
50485: PPUSH
50486: CALL 73834 0 1
50490: GO 50527
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50492: LD_VAR 0 3
50496: PPUSH
50497: CALL_OW 256
50501: PUSH
50502: LD_INT 250
50504: LESS
50505: PUSH
50506: LD_VAR 0 3
50510: PPUSH
50511: CALL_OW 312
50515: AND
50516: IFFALSE 50527
// ComUnlink ( j ) ;
50518: LD_VAR 0 3
50522: PPUSH
50523: CALL_OW 136
50527: GO 50451
50529: POP
50530: POP
// end ;
50531: GO 50389
50533: POP
50534: POP
// end ;
50535: LD_VAR 0 1
50539: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50540: LD_INT 0
50542: PPUSH
50543: PPUSH
50544: PPUSH
50545: PPUSH
50546: PPUSH
// if not mc_bases then
50547: LD_EXP 116
50551: NOT
50552: IFFALSE 50556
// exit ;
50554: GO 51001
// for i = 1 to mc_bases do
50556: LD_ADDR_VAR 0 2
50560: PUSH
50561: DOUBLE
50562: LD_INT 1
50564: DEC
50565: ST_TO_ADDR
50566: LD_EXP 116
50570: PUSH
50571: FOR_TO
50572: IFFALSE 50999
// begin if not mc_produce [ i ] then
50574: LD_EXP 137
50578: PUSH
50579: LD_VAR 0 2
50583: ARRAY
50584: NOT
50585: IFFALSE 50589
// continue ;
50587: GO 50571
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50589: LD_ADDR_VAR 0 5
50593: PUSH
50594: LD_EXP 116
50598: PUSH
50599: LD_VAR 0 2
50603: ARRAY
50604: PPUSH
50605: LD_INT 30
50607: PUSH
50608: LD_INT 3
50610: PUSH
50611: EMPTY
50612: LIST
50613: LIST
50614: PPUSH
50615: CALL_OW 72
50619: ST_TO_ADDR
// if not fac then
50620: LD_VAR 0 5
50624: NOT
50625: IFFALSE 50629
// continue ;
50627: GO 50571
// for j in fac do
50629: LD_ADDR_VAR 0 3
50633: PUSH
50634: LD_VAR 0 5
50638: PUSH
50639: FOR_IN
50640: IFFALSE 50995
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50642: LD_VAR 0 3
50646: PPUSH
50647: CALL_OW 461
50651: PUSH
50652: LD_INT 2
50654: NONEQUAL
50655: PUSH
50656: LD_VAR 0 3
50660: PPUSH
50661: LD_INT 15
50663: PPUSH
50664: CALL 73462 0 2
50668: PUSH
50669: LD_INT 4
50671: ARRAY
50672: OR
50673: IFFALSE 50677
// continue ;
50675: GO 50639
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50677: LD_VAR 0 3
50681: PPUSH
50682: LD_EXP 137
50686: PUSH
50687: LD_VAR 0 2
50691: ARRAY
50692: PUSH
50693: LD_INT 1
50695: ARRAY
50696: PUSH
50697: LD_INT 1
50699: ARRAY
50700: PPUSH
50701: LD_EXP 137
50705: PUSH
50706: LD_VAR 0 2
50710: ARRAY
50711: PUSH
50712: LD_INT 1
50714: ARRAY
50715: PUSH
50716: LD_INT 2
50718: ARRAY
50719: PPUSH
50720: LD_EXP 137
50724: PUSH
50725: LD_VAR 0 2
50729: ARRAY
50730: PUSH
50731: LD_INT 1
50733: ARRAY
50734: PUSH
50735: LD_INT 3
50737: ARRAY
50738: PPUSH
50739: LD_EXP 137
50743: PUSH
50744: LD_VAR 0 2
50748: ARRAY
50749: PUSH
50750: LD_INT 1
50752: ARRAY
50753: PUSH
50754: LD_INT 4
50756: ARRAY
50757: PPUSH
50758: CALL_OW 448
50762: PUSH
50763: LD_VAR 0 3
50767: PPUSH
50768: LD_EXP 137
50772: PUSH
50773: LD_VAR 0 2
50777: ARRAY
50778: PUSH
50779: LD_INT 1
50781: ARRAY
50782: PUSH
50783: LD_INT 1
50785: ARRAY
50786: PUSH
50787: LD_EXP 137
50791: PUSH
50792: LD_VAR 0 2
50796: ARRAY
50797: PUSH
50798: LD_INT 1
50800: ARRAY
50801: PUSH
50802: LD_INT 2
50804: ARRAY
50805: PUSH
50806: LD_EXP 137
50810: PUSH
50811: LD_VAR 0 2
50815: ARRAY
50816: PUSH
50817: LD_INT 1
50819: ARRAY
50820: PUSH
50821: LD_INT 3
50823: ARRAY
50824: PUSH
50825: LD_EXP 137
50829: PUSH
50830: LD_VAR 0 2
50834: ARRAY
50835: PUSH
50836: LD_INT 1
50838: ARRAY
50839: PUSH
50840: LD_INT 4
50842: ARRAY
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: LIST
50848: LIST
50849: PPUSH
50850: CALL 77229 0 2
50854: AND
50855: IFFALSE 50993
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50857: LD_VAR 0 3
50861: PPUSH
50862: LD_EXP 137
50866: PUSH
50867: LD_VAR 0 2
50871: ARRAY
50872: PUSH
50873: LD_INT 1
50875: ARRAY
50876: PUSH
50877: LD_INT 1
50879: ARRAY
50880: PPUSH
50881: LD_EXP 137
50885: PUSH
50886: LD_VAR 0 2
50890: ARRAY
50891: PUSH
50892: LD_INT 1
50894: ARRAY
50895: PUSH
50896: LD_INT 2
50898: ARRAY
50899: PPUSH
50900: LD_EXP 137
50904: PUSH
50905: LD_VAR 0 2
50909: ARRAY
50910: PUSH
50911: LD_INT 1
50913: ARRAY
50914: PUSH
50915: LD_INT 3
50917: ARRAY
50918: PPUSH
50919: LD_EXP 137
50923: PUSH
50924: LD_VAR 0 2
50928: ARRAY
50929: PUSH
50930: LD_INT 1
50932: ARRAY
50933: PUSH
50934: LD_INT 4
50936: ARRAY
50937: PPUSH
50938: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50942: LD_ADDR_VAR 0 4
50946: PUSH
50947: LD_EXP 137
50951: PUSH
50952: LD_VAR 0 2
50956: ARRAY
50957: PPUSH
50958: LD_INT 1
50960: PPUSH
50961: CALL_OW 3
50965: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50966: LD_ADDR_EXP 137
50970: PUSH
50971: LD_EXP 137
50975: PPUSH
50976: LD_VAR 0 2
50980: PPUSH
50981: LD_VAR 0 4
50985: PPUSH
50986: CALL_OW 1
50990: ST_TO_ADDR
// break ;
50991: GO 50995
// end ; end ;
50993: GO 50639
50995: POP
50996: POP
// end ;
50997: GO 50571
50999: POP
51000: POP
// end ;
51001: LD_VAR 0 1
51005: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
51006: LD_INT 0
51008: PPUSH
51009: PPUSH
51010: PPUSH
// if not mc_bases then
51011: LD_EXP 116
51015: NOT
51016: IFFALSE 51020
// exit ;
51018: GO 51109
// for i = 1 to mc_bases do
51020: LD_ADDR_VAR 0 2
51024: PUSH
51025: DOUBLE
51026: LD_INT 1
51028: DEC
51029: ST_TO_ADDR
51030: LD_EXP 116
51034: PUSH
51035: FOR_TO
51036: IFFALSE 51107
// begin if mc_attack [ i ] then
51038: LD_EXP 136
51042: PUSH
51043: LD_VAR 0 2
51047: ARRAY
51048: IFFALSE 51105
// begin tmp := mc_attack [ i ] [ 1 ] ;
51050: LD_ADDR_VAR 0 3
51054: PUSH
51055: LD_EXP 136
51059: PUSH
51060: LD_VAR 0 2
51064: ARRAY
51065: PUSH
51066: LD_INT 1
51068: ARRAY
51069: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
51070: LD_ADDR_EXP 136
51074: PUSH
51075: LD_EXP 136
51079: PPUSH
51080: LD_VAR 0 2
51084: PPUSH
51085: EMPTY
51086: PPUSH
51087: CALL_OW 1
51091: ST_TO_ADDR
// Attack ( tmp ) ;
51092: LD_VAR 0 3
51096: PPUSH
51097: CALL 122619 0 1
// exit ;
51101: POP
51102: POP
51103: GO 51109
// end ; end ;
51105: GO 51035
51107: POP
51108: POP
// end ;
51109: LD_VAR 0 1
51113: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
51114: LD_INT 0
51116: PPUSH
51117: PPUSH
51118: PPUSH
51119: PPUSH
51120: PPUSH
51121: PPUSH
51122: PPUSH
// if not mc_bases then
51123: LD_EXP 116
51127: NOT
51128: IFFALSE 51132
// exit ;
51130: GO 51989
// for i = 1 to mc_bases do
51132: LD_ADDR_VAR 0 2
51136: PUSH
51137: DOUBLE
51138: LD_INT 1
51140: DEC
51141: ST_TO_ADDR
51142: LD_EXP 116
51146: PUSH
51147: FOR_TO
51148: IFFALSE 51987
// begin if not mc_bases [ i ] then
51150: LD_EXP 116
51154: PUSH
51155: LD_VAR 0 2
51159: ARRAY
51160: NOT
51161: IFFALSE 51165
// continue ;
51163: GO 51147
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
51165: LD_ADDR_VAR 0 7
51169: PUSH
51170: LD_EXP 116
51174: PUSH
51175: LD_VAR 0 2
51179: ARRAY
51180: PUSH
51181: LD_INT 1
51183: ARRAY
51184: PPUSH
51185: CALL 67663 0 1
51189: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51190: LD_ADDR_EXP 139
51194: PUSH
51195: LD_EXP 139
51199: PPUSH
51200: LD_VAR 0 2
51204: PPUSH
51205: LD_EXP 116
51209: PUSH
51210: LD_VAR 0 2
51214: ARRAY
51215: PUSH
51216: LD_INT 1
51218: ARRAY
51219: PPUSH
51220: CALL_OW 255
51224: PPUSH
51225: LD_EXP 141
51229: PUSH
51230: LD_VAR 0 2
51234: ARRAY
51235: PPUSH
51236: CALL 67628 0 2
51240: PPUSH
51241: CALL_OW 1
51245: ST_TO_ADDR
// if not mc_scan [ i ] then
51246: LD_EXP 139
51250: PUSH
51251: LD_VAR 0 2
51255: ARRAY
51256: NOT
51257: IFFALSE 51435
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51259: LD_ADDR_EXP 159
51263: PUSH
51264: LD_EXP 159
51268: PPUSH
51269: LD_VAR 0 2
51273: PPUSH
51274: LD_INT 0
51276: PPUSH
51277: CALL_OW 1
51281: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51282: LD_ADDR_VAR 0 4
51286: PUSH
51287: LD_EXP 116
51291: PUSH
51292: LD_VAR 0 2
51296: ARRAY
51297: PPUSH
51298: LD_INT 2
51300: PUSH
51301: LD_INT 25
51303: PUSH
51304: LD_INT 5
51306: PUSH
51307: EMPTY
51308: LIST
51309: LIST
51310: PUSH
51311: LD_INT 25
51313: PUSH
51314: LD_INT 8
51316: PUSH
51317: EMPTY
51318: LIST
51319: LIST
51320: PUSH
51321: LD_INT 25
51323: PUSH
51324: LD_INT 9
51326: PUSH
51327: EMPTY
51328: LIST
51329: LIST
51330: PUSH
51331: EMPTY
51332: LIST
51333: LIST
51334: LIST
51335: LIST
51336: PPUSH
51337: CALL_OW 72
51341: ST_TO_ADDR
// if not tmp then
51342: LD_VAR 0 4
51346: NOT
51347: IFFALSE 51351
// continue ;
51349: GO 51147
// for j in tmp do
51351: LD_ADDR_VAR 0 3
51355: PUSH
51356: LD_VAR 0 4
51360: PUSH
51361: FOR_IN
51362: IFFALSE 51433
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51364: LD_VAR 0 3
51368: PPUSH
51369: CALL_OW 310
51373: PPUSH
51374: CALL_OW 266
51378: PUSH
51379: LD_INT 5
51381: EQUAL
51382: PUSH
51383: LD_VAR 0 3
51387: PPUSH
51388: CALL_OW 257
51392: PUSH
51393: LD_INT 1
51395: EQUAL
51396: AND
51397: PUSH
51398: LD_VAR 0 3
51402: PPUSH
51403: CALL_OW 459
51407: NOT
51408: AND
51409: PUSH
51410: LD_VAR 0 7
51414: AND
51415: IFFALSE 51431
// ComChangeProfession ( j , class ) ;
51417: LD_VAR 0 3
51421: PPUSH
51422: LD_VAR 0 7
51426: PPUSH
51427: CALL_OW 123
51431: GO 51361
51433: POP
51434: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
51435: LD_EXP 139
51439: PUSH
51440: LD_VAR 0 2
51444: ARRAY
51445: PUSH
51446: LD_EXP 159
51450: PUSH
51451: LD_VAR 0 2
51455: ARRAY
51456: NOT
51457: AND
51458: PUSH
51459: LD_EXP 138
51463: PUSH
51464: LD_VAR 0 2
51468: ARRAY
51469: NOT
51470: AND
51471: PUSH
51472: LD_EXP 116
51476: PUSH
51477: LD_VAR 0 2
51481: ARRAY
51482: PPUSH
51483: LD_INT 50
51485: PUSH
51486: EMPTY
51487: LIST
51488: PUSH
51489: LD_INT 2
51491: PUSH
51492: LD_INT 30
51494: PUSH
51495: LD_INT 32
51497: PUSH
51498: EMPTY
51499: LIST
51500: LIST
51501: PUSH
51502: LD_INT 30
51504: PUSH
51505: LD_INT 33
51507: PUSH
51508: EMPTY
51509: LIST
51510: LIST
51511: PUSH
51512: LD_INT 30
51514: PUSH
51515: LD_INT 4
51517: PUSH
51518: EMPTY
51519: LIST
51520: LIST
51521: PUSH
51522: LD_INT 30
51524: PUSH
51525: LD_INT 5
51527: PUSH
51528: EMPTY
51529: LIST
51530: LIST
51531: PUSH
51532: EMPTY
51533: LIST
51534: LIST
51535: LIST
51536: LIST
51537: LIST
51538: PUSH
51539: EMPTY
51540: LIST
51541: LIST
51542: PPUSH
51543: CALL_OW 72
51547: PUSH
51548: LD_INT 4
51550: LESS
51551: PUSH
51552: LD_EXP 116
51556: PUSH
51557: LD_VAR 0 2
51561: ARRAY
51562: PPUSH
51563: LD_INT 3
51565: PUSH
51566: LD_INT 24
51568: PUSH
51569: LD_INT 1000
51571: PUSH
51572: EMPTY
51573: LIST
51574: LIST
51575: PUSH
51576: EMPTY
51577: LIST
51578: LIST
51579: PUSH
51580: LD_INT 2
51582: PUSH
51583: LD_INT 30
51585: PUSH
51586: LD_INT 0
51588: PUSH
51589: EMPTY
51590: LIST
51591: LIST
51592: PUSH
51593: LD_INT 30
51595: PUSH
51596: LD_INT 1
51598: PUSH
51599: EMPTY
51600: LIST
51601: LIST
51602: PUSH
51603: EMPTY
51604: LIST
51605: LIST
51606: LIST
51607: PUSH
51608: EMPTY
51609: LIST
51610: LIST
51611: PPUSH
51612: CALL_OW 72
51616: OR
51617: AND
51618: IFFALSE 51869
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51620: LD_ADDR_EXP 159
51624: PUSH
51625: LD_EXP 159
51629: PPUSH
51630: LD_VAR 0 2
51634: PPUSH
51635: LD_INT 1
51637: PPUSH
51638: CALL_OW 1
51642: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51643: LD_ADDR_VAR 0 4
51647: PUSH
51648: LD_EXP 116
51652: PUSH
51653: LD_VAR 0 2
51657: ARRAY
51658: PPUSH
51659: LD_INT 2
51661: PUSH
51662: LD_INT 25
51664: PUSH
51665: LD_INT 1
51667: PUSH
51668: EMPTY
51669: LIST
51670: LIST
51671: PUSH
51672: LD_INT 25
51674: PUSH
51675: LD_INT 5
51677: PUSH
51678: EMPTY
51679: LIST
51680: LIST
51681: PUSH
51682: LD_INT 25
51684: PUSH
51685: LD_INT 8
51687: PUSH
51688: EMPTY
51689: LIST
51690: LIST
51691: PUSH
51692: LD_INT 25
51694: PUSH
51695: LD_INT 9
51697: PUSH
51698: EMPTY
51699: LIST
51700: LIST
51701: PUSH
51702: EMPTY
51703: LIST
51704: LIST
51705: LIST
51706: LIST
51707: LIST
51708: PPUSH
51709: CALL_OW 72
51713: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51714: LD_ADDR_VAR 0 4
51718: PUSH
51719: LD_VAR 0 4
51723: PUSH
51724: LD_VAR 0 4
51728: PPUSH
51729: LD_INT 18
51731: PPUSH
51732: CALL 100132 0 2
51736: DIFF
51737: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51738: LD_VAR 0 4
51742: NOT
51743: PUSH
51744: LD_EXP 116
51748: PUSH
51749: LD_VAR 0 2
51753: ARRAY
51754: PPUSH
51755: LD_INT 2
51757: PUSH
51758: LD_INT 30
51760: PUSH
51761: LD_INT 4
51763: PUSH
51764: EMPTY
51765: LIST
51766: LIST
51767: PUSH
51768: LD_INT 30
51770: PUSH
51771: LD_INT 5
51773: PUSH
51774: EMPTY
51775: LIST
51776: LIST
51777: PUSH
51778: EMPTY
51779: LIST
51780: LIST
51781: LIST
51782: PPUSH
51783: CALL_OW 72
51787: NOT
51788: AND
51789: IFFALSE 51851
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
51791: LD_ADDR_VAR 0 4
51795: PUSH
51796: LD_EXP 116
51800: PUSH
51801: LD_VAR 0 2
51805: ARRAY
51806: PPUSH
51807: LD_INT 2
51809: PUSH
51810: LD_INT 25
51812: PUSH
51813: LD_INT 2
51815: PUSH
51816: EMPTY
51817: LIST
51818: LIST
51819: PUSH
51820: LD_INT 25
51822: PUSH
51823: LD_INT 3
51825: PUSH
51826: EMPTY
51827: LIST
51828: LIST
51829: PUSH
51830: LD_INT 25
51832: PUSH
51833: LD_INT 4
51835: PUSH
51836: EMPTY
51837: LIST
51838: LIST
51839: PUSH
51840: EMPTY
51841: LIST
51842: LIST
51843: LIST
51844: LIST
51845: PPUSH
51846: CALL_OW 72
51850: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
51851: LD_VAR 0 2
51855: PPUSH
51856: LD_VAR 0 4
51860: PPUSH
51861: CALL 127328 0 2
// exit ;
51865: POP
51866: POP
51867: GO 51989
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51869: LD_EXP 139
51873: PUSH
51874: LD_VAR 0 2
51878: ARRAY
51879: PUSH
51880: LD_EXP 159
51884: PUSH
51885: LD_VAR 0 2
51889: ARRAY
51890: NOT
51891: AND
51892: PUSH
51893: LD_EXP 138
51897: PUSH
51898: LD_VAR 0 2
51902: ARRAY
51903: AND
51904: IFFALSE 51985
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51906: LD_ADDR_EXP 159
51910: PUSH
51911: LD_EXP 159
51915: PPUSH
51916: LD_VAR 0 2
51920: PPUSH
51921: LD_INT 1
51923: PPUSH
51924: CALL_OW 1
51928: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
51929: LD_ADDR_VAR 0 4
51933: PUSH
51934: LD_EXP 138
51938: PUSH
51939: LD_VAR 0 2
51943: ARRAY
51944: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51945: LD_ADDR_EXP 138
51949: PUSH
51950: LD_EXP 138
51954: PPUSH
51955: LD_VAR 0 2
51959: PPUSH
51960: EMPTY
51961: PPUSH
51962: CALL_OW 1
51966: ST_TO_ADDR
// Defend ( i , tmp ) ;
51967: LD_VAR 0 2
51971: PPUSH
51972: LD_VAR 0 4
51976: PPUSH
51977: CALL 127924 0 2
// exit ;
51981: POP
51982: POP
51983: GO 51989
// end ; end ;
51985: GO 51147
51987: POP
51988: POP
// end ;
51989: LD_VAR 0 1
51993: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51994: LD_INT 0
51996: PPUSH
51997: PPUSH
51998: PPUSH
51999: PPUSH
52000: PPUSH
52001: PPUSH
52002: PPUSH
52003: PPUSH
52004: PPUSH
52005: PPUSH
52006: PPUSH
// if not mc_bases then
52007: LD_EXP 116
52011: NOT
52012: IFFALSE 52016
// exit ;
52014: GO 53103
// for i = 1 to mc_bases do
52016: LD_ADDR_VAR 0 2
52020: PUSH
52021: DOUBLE
52022: LD_INT 1
52024: DEC
52025: ST_TO_ADDR
52026: LD_EXP 116
52030: PUSH
52031: FOR_TO
52032: IFFALSE 53101
// begin tmp := mc_lab [ i ] ;
52034: LD_ADDR_VAR 0 6
52038: PUSH
52039: LD_EXP 149
52043: PUSH
52044: LD_VAR 0 2
52048: ARRAY
52049: ST_TO_ADDR
// if not tmp then
52050: LD_VAR 0 6
52054: NOT
52055: IFFALSE 52059
// continue ;
52057: GO 52031
// idle_lab := 0 ;
52059: LD_ADDR_VAR 0 11
52063: PUSH
52064: LD_INT 0
52066: ST_TO_ADDR
// for j in tmp do
52067: LD_ADDR_VAR 0 3
52071: PUSH
52072: LD_VAR 0 6
52076: PUSH
52077: FOR_IN
52078: IFFALSE 53097
// begin researching := false ;
52080: LD_ADDR_VAR 0 10
52084: PUSH
52085: LD_INT 0
52087: ST_TO_ADDR
// side := GetSide ( j ) ;
52088: LD_ADDR_VAR 0 4
52092: PUSH
52093: LD_VAR 0 3
52097: PPUSH
52098: CALL_OW 255
52102: ST_TO_ADDR
// if not mc_tech [ side ] then
52103: LD_EXP 143
52107: PUSH
52108: LD_VAR 0 4
52112: ARRAY
52113: NOT
52114: IFFALSE 52118
// continue ;
52116: GO 52077
// if BuildingStatus ( j ) = bs_idle then
52118: LD_VAR 0 3
52122: PPUSH
52123: CALL_OW 461
52127: PUSH
52128: LD_INT 2
52130: EQUAL
52131: IFFALSE 52319
// begin if idle_lab and UnitsInside ( j ) < 6 then
52133: LD_VAR 0 11
52137: PUSH
52138: LD_VAR 0 3
52142: PPUSH
52143: CALL_OW 313
52147: PUSH
52148: LD_INT 6
52150: LESS
52151: AND
52152: IFFALSE 52223
// begin tmp2 := UnitsInside ( idle_lab ) ;
52154: LD_ADDR_VAR 0 9
52158: PUSH
52159: LD_VAR 0 11
52163: PPUSH
52164: CALL_OW 313
52168: ST_TO_ADDR
// if tmp2 then
52169: LD_VAR 0 9
52173: IFFALSE 52215
// for x in tmp2 do
52175: LD_ADDR_VAR 0 7
52179: PUSH
52180: LD_VAR 0 9
52184: PUSH
52185: FOR_IN
52186: IFFALSE 52213
// begin ComExitBuilding ( x ) ;
52188: LD_VAR 0 7
52192: PPUSH
52193: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52197: LD_VAR 0 7
52201: PPUSH
52202: LD_VAR 0 3
52206: PPUSH
52207: CALL_OW 180
// end ;
52211: GO 52185
52213: POP
52214: POP
// idle_lab := 0 ;
52215: LD_ADDR_VAR 0 11
52219: PUSH
52220: LD_INT 0
52222: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
52223: LD_ADDR_VAR 0 5
52227: PUSH
52228: LD_EXP 143
52232: PUSH
52233: LD_VAR 0 4
52237: ARRAY
52238: PUSH
52239: FOR_IN
52240: IFFALSE 52300
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
52242: LD_VAR 0 3
52246: PPUSH
52247: LD_VAR 0 5
52251: PPUSH
52252: CALL_OW 430
52256: PUSH
52257: LD_VAR 0 4
52261: PPUSH
52262: LD_VAR 0 5
52266: PPUSH
52267: CALL 66733 0 2
52271: AND
52272: IFFALSE 52298
// begin researching := true ;
52274: LD_ADDR_VAR 0 10
52278: PUSH
52279: LD_INT 1
52281: ST_TO_ADDR
// ComResearch ( j , t ) ;
52282: LD_VAR 0 3
52286: PPUSH
52287: LD_VAR 0 5
52291: PPUSH
52292: CALL_OW 124
// break ;
52296: GO 52300
// end ;
52298: GO 52239
52300: POP
52301: POP
// if not researching then
52302: LD_VAR 0 10
52306: NOT
52307: IFFALSE 52319
// idle_lab := j ;
52309: LD_ADDR_VAR 0 11
52313: PUSH
52314: LD_VAR 0 3
52318: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
52319: LD_VAR 0 3
52323: PPUSH
52324: CALL_OW 461
52328: PUSH
52329: LD_INT 10
52331: EQUAL
52332: IFFALSE 52920
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52334: LD_EXP 145
52338: PUSH
52339: LD_VAR 0 2
52343: ARRAY
52344: NOT
52345: PUSH
52346: LD_EXP 146
52350: PUSH
52351: LD_VAR 0 2
52355: ARRAY
52356: NOT
52357: AND
52358: PUSH
52359: LD_EXP 143
52363: PUSH
52364: LD_VAR 0 4
52368: ARRAY
52369: PUSH
52370: LD_INT 1
52372: GREATER
52373: AND
52374: IFFALSE 52505
// begin ComCancel ( j ) ;
52376: LD_VAR 0 3
52380: PPUSH
52381: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52385: LD_ADDR_EXP 143
52389: PUSH
52390: LD_EXP 143
52394: PPUSH
52395: LD_VAR 0 4
52399: PPUSH
52400: LD_EXP 143
52404: PUSH
52405: LD_VAR 0 4
52409: ARRAY
52410: PPUSH
52411: LD_EXP 143
52415: PUSH
52416: LD_VAR 0 4
52420: ARRAY
52421: PUSH
52422: LD_INT 1
52424: MINUS
52425: PPUSH
52426: LD_EXP 143
52430: PUSH
52431: LD_VAR 0 4
52435: ARRAY
52436: PPUSH
52437: LD_INT 0
52439: PPUSH
52440: CALL 70281 0 4
52444: PPUSH
52445: CALL_OW 1
52449: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52450: LD_ADDR_EXP 143
52454: PUSH
52455: LD_EXP 143
52459: PPUSH
52460: LD_VAR 0 4
52464: PPUSH
52465: LD_EXP 143
52469: PUSH
52470: LD_VAR 0 4
52474: ARRAY
52475: PPUSH
52476: LD_EXP 143
52480: PUSH
52481: LD_VAR 0 4
52485: ARRAY
52486: PPUSH
52487: LD_INT 1
52489: PPUSH
52490: LD_INT 0
52492: PPUSH
52493: CALL 70281 0 4
52497: PPUSH
52498: CALL_OW 1
52502: ST_TO_ADDR
// continue ;
52503: GO 52077
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52505: LD_EXP 145
52509: PUSH
52510: LD_VAR 0 2
52514: ARRAY
52515: PUSH
52516: LD_EXP 146
52520: PUSH
52521: LD_VAR 0 2
52525: ARRAY
52526: NOT
52527: AND
52528: IFFALSE 52655
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52530: LD_ADDR_EXP 146
52534: PUSH
52535: LD_EXP 146
52539: PPUSH
52540: LD_VAR 0 2
52544: PUSH
52545: LD_EXP 146
52549: PUSH
52550: LD_VAR 0 2
52554: ARRAY
52555: PUSH
52556: LD_INT 1
52558: PLUS
52559: PUSH
52560: EMPTY
52561: LIST
52562: LIST
52563: PPUSH
52564: LD_EXP 145
52568: PUSH
52569: LD_VAR 0 2
52573: ARRAY
52574: PUSH
52575: LD_INT 1
52577: ARRAY
52578: PPUSH
52579: CALL 70863 0 3
52583: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52584: LD_EXP 145
52588: PUSH
52589: LD_VAR 0 2
52593: ARRAY
52594: PUSH
52595: LD_INT 1
52597: ARRAY
52598: PPUSH
52599: LD_INT 112
52601: PPUSH
52602: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52606: LD_ADDR_VAR 0 9
52610: PUSH
52611: LD_EXP 145
52615: PUSH
52616: LD_VAR 0 2
52620: ARRAY
52621: PPUSH
52622: LD_INT 1
52624: PPUSH
52625: CALL_OW 3
52629: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52630: LD_ADDR_EXP 145
52634: PUSH
52635: LD_EXP 145
52639: PPUSH
52640: LD_VAR 0 2
52644: PPUSH
52645: LD_VAR 0 9
52649: PPUSH
52650: CALL_OW 1
52654: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52655: LD_EXP 145
52659: PUSH
52660: LD_VAR 0 2
52664: ARRAY
52665: PUSH
52666: LD_EXP 146
52670: PUSH
52671: LD_VAR 0 2
52675: ARRAY
52676: AND
52677: PUSH
52678: LD_EXP 146
52682: PUSH
52683: LD_VAR 0 2
52687: ARRAY
52688: PUSH
52689: LD_INT 1
52691: ARRAY
52692: PPUSH
52693: CALL_OW 310
52697: NOT
52698: AND
52699: PUSH
52700: LD_VAR 0 3
52704: PPUSH
52705: CALL_OW 313
52709: PUSH
52710: LD_INT 6
52712: EQUAL
52713: AND
52714: IFFALSE 52770
// begin tmp2 := UnitsInside ( j ) ;
52716: LD_ADDR_VAR 0 9
52720: PUSH
52721: LD_VAR 0 3
52725: PPUSH
52726: CALL_OW 313
52730: ST_TO_ADDR
// if tmp2 = 6 then
52731: LD_VAR 0 9
52735: PUSH
52736: LD_INT 6
52738: EQUAL
52739: IFFALSE 52770
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52741: LD_VAR 0 9
52745: PUSH
52746: LD_INT 1
52748: ARRAY
52749: PPUSH
52750: LD_INT 112
52752: PPUSH
52753: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52757: LD_VAR 0 9
52761: PUSH
52762: LD_INT 1
52764: ARRAY
52765: PPUSH
52766: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52770: LD_EXP 146
52774: PUSH
52775: LD_VAR 0 2
52779: ARRAY
52780: PUSH
52781: LD_EXP 146
52785: PUSH
52786: LD_VAR 0 2
52790: ARRAY
52791: PUSH
52792: LD_INT 1
52794: ARRAY
52795: PPUSH
52796: CALL_OW 314
52800: NOT
52801: AND
52802: PUSH
52803: LD_EXP 146
52807: PUSH
52808: LD_VAR 0 2
52812: ARRAY
52813: PUSH
52814: LD_INT 1
52816: ARRAY
52817: PPUSH
52818: CALL_OW 310
52822: NOT
52823: AND
52824: IFFALSE 52850
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52826: LD_EXP 146
52830: PUSH
52831: LD_VAR 0 2
52835: ARRAY
52836: PUSH
52837: LD_INT 1
52839: ARRAY
52840: PPUSH
52841: LD_VAR 0 3
52845: PPUSH
52846: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52850: LD_EXP 146
52854: PUSH
52855: LD_VAR 0 2
52859: ARRAY
52860: PUSH
52861: LD_INT 1
52863: ARRAY
52864: PPUSH
52865: CALL_OW 310
52869: PUSH
52870: LD_EXP 146
52874: PUSH
52875: LD_VAR 0 2
52879: ARRAY
52880: PUSH
52881: LD_INT 1
52883: ARRAY
52884: PPUSH
52885: CALL_OW 310
52889: PPUSH
52890: CALL_OW 461
52894: PUSH
52895: LD_INT 3
52897: NONEQUAL
52898: AND
52899: IFFALSE 52920
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52901: LD_EXP 146
52905: PUSH
52906: LD_VAR 0 2
52910: ARRAY
52911: PUSH
52912: LD_INT 1
52914: ARRAY
52915: PPUSH
52916: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52920: LD_VAR 0 3
52924: PPUSH
52925: CALL_OW 461
52929: PUSH
52930: LD_INT 6
52932: EQUAL
52933: PUSH
52934: LD_VAR 0 6
52938: PUSH
52939: LD_INT 1
52941: GREATER
52942: AND
52943: IFFALSE 53095
// begin sci := [ ] ;
52945: LD_ADDR_VAR 0 8
52949: PUSH
52950: EMPTY
52951: ST_TO_ADDR
// for x in ( tmp diff j ) do
52952: LD_ADDR_VAR 0 7
52956: PUSH
52957: LD_VAR 0 6
52961: PUSH
52962: LD_VAR 0 3
52966: DIFF
52967: PUSH
52968: FOR_IN
52969: IFFALSE 53021
// begin if sci = 6 then
52971: LD_VAR 0 8
52975: PUSH
52976: LD_INT 6
52978: EQUAL
52979: IFFALSE 52983
// break ;
52981: GO 53021
// if BuildingStatus ( x ) = bs_idle then
52983: LD_VAR 0 7
52987: PPUSH
52988: CALL_OW 461
52992: PUSH
52993: LD_INT 2
52995: EQUAL
52996: IFFALSE 53019
// sci := sci ^ UnitsInside ( x ) ;
52998: LD_ADDR_VAR 0 8
53002: PUSH
53003: LD_VAR 0 8
53007: PUSH
53008: LD_VAR 0 7
53012: PPUSH
53013: CALL_OW 313
53017: ADD
53018: ST_TO_ADDR
// end ;
53019: GO 52968
53021: POP
53022: POP
// if not sci then
53023: LD_VAR 0 8
53027: NOT
53028: IFFALSE 53032
// continue ;
53030: GO 52077
// for x in sci do
53032: LD_ADDR_VAR 0 7
53036: PUSH
53037: LD_VAR 0 8
53041: PUSH
53042: FOR_IN
53043: IFFALSE 53093
// if IsInUnit ( x ) and not HasTask ( x ) then
53045: LD_VAR 0 7
53049: PPUSH
53050: CALL_OW 310
53054: PUSH
53055: LD_VAR 0 7
53059: PPUSH
53060: CALL_OW 314
53064: NOT
53065: AND
53066: IFFALSE 53091
// begin ComExitBuilding ( x ) ;
53068: LD_VAR 0 7
53072: PPUSH
53073: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53077: LD_VAR 0 7
53081: PPUSH
53082: LD_VAR 0 3
53086: PPUSH
53087: CALL_OW 180
// end ;
53091: GO 53042
53093: POP
53094: POP
// end ; end ;
53095: GO 52077
53097: POP
53098: POP
// end ;
53099: GO 52031
53101: POP
53102: POP
// end ;
53103: LD_VAR 0 1
53107: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
53108: LD_INT 0
53110: PPUSH
53111: PPUSH
// if not mc_bases then
53112: LD_EXP 116
53116: NOT
53117: IFFALSE 53121
// exit ;
53119: GO 53202
// for i = 1 to mc_bases do
53121: LD_ADDR_VAR 0 2
53125: PUSH
53126: DOUBLE
53127: LD_INT 1
53129: DEC
53130: ST_TO_ADDR
53131: LD_EXP 116
53135: PUSH
53136: FOR_TO
53137: IFFALSE 53200
// if mc_mines [ i ] and mc_miners [ i ] then
53139: LD_EXP 129
53143: PUSH
53144: LD_VAR 0 2
53148: ARRAY
53149: PUSH
53150: LD_EXP 130
53154: PUSH
53155: LD_VAR 0 2
53159: ARRAY
53160: AND
53161: IFFALSE 53198
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
53163: LD_EXP 130
53167: PUSH
53168: LD_VAR 0 2
53172: ARRAY
53173: PUSH
53174: LD_INT 1
53176: ARRAY
53177: PPUSH
53178: CALL_OW 255
53182: PPUSH
53183: LD_EXP 129
53187: PUSH
53188: LD_VAR 0 2
53192: ARRAY
53193: PPUSH
53194: CALL 67816 0 2
53198: GO 53136
53200: POP
53201: POP
// end ;
53202: LD_VAR 0 1
53206: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
53207: LD_INT 0
53209: PPUSH
53210: PPUSH
53211: PPUSH
53212: PPUSH
53213: PPUSH
53214: PPUSH
53215: PPUSH
53216: PPUSH
// if not mc_bases or not mc_parking then
53217: LD_EXP 116
53221: NOT
53222: PUSH
53223: LD_EXP 140
53227: NOT
53228: OR
53229: IFFALSE 53233
// exit ;
53231: GO 53943
// for i = 1 to mc_bases do
53233: LD_ADDR_VAR 0 2
53237: PUSH
53238: DOUBLE
53239: LD_INT 1
53241: DEC
53242: ST_TO_ADDR
53243: LD_EXP 116
53247: PUSH
53248: FOR_TO
53249: IFFALSE 53941
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
53251: LD_EXP 116
53255: PUSH
53256: LD_VAR 0 2
53260: ARRAY
53261: NOT
53262: PUSH
53263: LD_EXP 140
53267: PUSH
53268: LD_VAR 0 2
53272: ARRAY
53273: NOT
53274: OR
53275: IFFALSE 53279
// continue ;
53277: GO 53248
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53279: LD_ADDR_VAR 0 5
53283: PUSH
53284: LD_EXP 116
53288: PUSH
53289: LD_VAR 0 2
53293: ARRAY
53294: PUSH
53295: LD_INT 1
53297: ARRAY
53298: PPUSH
53299: CALL_OW 255
53303: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53304: LD_ADDR_VAR 0 6
53308: PUSH
53309: LD_EXP 116
53313: PUSH
53314: LD_VAR 0 2
53318: ARRAY
53319: PPUSH
53320: LD_INT 30
53322: PUSH
53323: LD_INT 3
53325: PUSH
53326: EMPTY
53327: LIST
53328: LIST
53329: PPUSH
53330: CALL_OW 72
53334: ST_TO_ADDR
// if not fac then
53335: LD_VAR 0 6
53339: NOT
53340: IFFALSE 53391
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53342: LD_ADDR_VAR 0 6
53346: PUSH
53347: LD_EXP 116
53351: PUSH
53352: LD_VAR 0 2
53356: ARRAY
53357: PPUSH
53358: LD_INT 2
53360: PUSH
53361: LD_INT 30
53363: PUSH
53364: LD_INT 0
53366: PUSH
53367: EMPTY
53368: LIST
53369: LIST
53370: PUSH
53371: LD_INT 30
53373: PUSH
53374: LD_INT 1
53376: PUSH
53377: EMPTY
53378: LIST
53379: LIST
53380: PUSH
53381: EMPTY
53382: LIST
53383: LIST
53384: LIST
53385: PPUSH
53386: CALL_OW 72
53390: ST_TO_ADDR
// if not fac then
53391: LD_VAR 0 6
53395: NOT
53396: IFFALSE 53400
// continue ;
53398: GO 53248
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53400: LD_ADDR_VAR 0 7
53404: PUSH
53405: LD_EXP 140
53409: PUSH
53410: LD_VAR 0 2
53414: ARRAY
53415: PPUSH
53416: LD_INT 22
53418: PUSH
53419: LD_VAR 0 5
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: PUSH
53428: LD_INT 21
53430: PUSH
53431: LD_INT 2
53433: PUSH
53434: EMPTY
53435: LIST
53436: LIST
53437: PUSH
53438: LD_INT 3
53440: PUSH
53441: LD_INT 24
53443: PUSH
53444: LD_INT 1000
53446: PUSH
53447: EMPTY
53448: LIST
53449: LIST
53450: PUSH
53451: EMPTY
53452: LIST
53453: LIST
53454: PUSH
53455: EMPTY
53456: LIST
53457: LIST
53458: LIST
53459: PPUSH
53460: CALL_OW 70
53464: ST_TO_ADDR
// for j in fac do
53465: LD_ADDR_VAR 0 3
53469: PUSH
53470: LD_VAR 0 6
53474: PUSH
53475: FOR_IN
53476: IFFALSE 53557
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53478: LD_ADDR_VAR 0 7
53482: PUSH
53483: LD_VAR 0 7
53487: PUSH
53488: LD_INT 22
53490: PUSH
53491: LD_VAR 0 5
53495: PUSH
53496: EMPTY
53497: LIST
53498: LIST
53499: PUSH
53500: LD_INT 91
53502: PUSH
53503: LD_VAR 0 3
53507: PUSH
53508: LD_INT 15
53510: PUSH
53511: EMPTY
53512: LIST
53513: LIST
53514: LIST
53515: PUSH
53516: LD_INT 21
53518: PUSH
53519: LD_INT 2
53521: PUSH
53522: EMPTY
53523: LIST
53524: LIST
53525: PUSH
53526: LD_INT 3
53528: PUSH
53529: LD_INT 24
53531: PUSH
53532: LD_INT 1000
53534: PUSH
53535: EMPTY
53536: LIST
53537: LIST
53538: PUSH
53539: EMPTY
53540: LIST
53541: LIST
53542: PUSH
53543: EMPTY
53544: LIST
53545: LIST
53546: LIST
53547: LIST
53548: PPUSH
53549: CALL_OW 69
53553: UNION
53554: ST_TO_ADDR
53555: GO 53475
53557: POP
53558: POP
// if not vehs then
53559: LD_VAR 0 7
53563: NOT
53564: IFFALSE 53590
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53566: LD_ADDR_EXP 128
53570: PUSH
53571: LD_EXP 128
53575: PPUSH
53576: LD_VAR 0 2
53580: PPUSH
53581: EMPTY
53582: PPUSH
53583: CALL_OW 1
53587: ST_TO_ADDR
// continue ;
53588: GO 53248
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53590: LD_ADDR_VAR 0 8
53594: PUSH
53595: LD_EXP 116
53599: PUSH
53600: LD_VAR 0 2
53604: ARRAY
53605: PPUSH
53606: LD_INT 30
53608: PUSH
53609: LD_INT 3
53611: PUSH
53612: EMPTY
53613: LIST
53614: LIST
53615: PPUSH
53616: CALL_OW 72
53620: ST_TO_ADDR
// if tmp then
53621: LD_VAR 0 8
53625: IFFALSE 53728
// begin for j in tmp do
53627: LD_ADDR_VAR 0 3
53631: PUSH
53632: LD_VAR 0 8
53636: PUSH
53637: FOR_IN
53638: IFFALSE 53726
// for k in UnitsInside ( j ) do
53640: LD_ADDR_VAR 0 4
53644: PUSH
53645: LD_VAR 0 3
53649: PPUSH
53650: CALL_OW 313
53654: PUSH
53655: FOR_IN
53656: IFFALSE 53722
// if k then
53658: LD_VAR 0 4
53662: IFFALSE 53720
// if not k in mc_repair_vehicle [ i ] then
53664: LD_VAR 0 4
53668: PUSH
53669: LD_EXP 128
53673: PUSH
53674: LD_VAR 0 2
53678: ARRAY
53679: IN
53680: NOT
53681: IFFALSE 53720
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53683: LD_ADDR_EXP 128
53687: PUSH
53688: LD_EXP 128
53692: PPUSH
53693: LD_VAR 0 2
53697: PPUSH
53698: LD_EXP 128
53702: PUSH
53703: LD_VAR 0 2
53707: ARRAY
53708: PUSH
53709: LD_VAR 0 4
53713: UNION
53714: PPUSH
53715: CALL_OW 1
53719: ST_TO_ADDR
53720: GO 53655
53722: POP
53723: POP
53724: GO 53637
53726: POP
53727: POP
// end ; if not mc_repair_vehicle [ i ] then
53728: LD_EXP 128
53732: PUSH
53733: LD_VAR 0 2
53737: ARRAY
53738: NOT
53739: IFFALSE 53743
// continue ;
53741: GO 53248
// for j in mc_repair_vehicle [ i ] do
53743: LD_ADDR_VAR 0 3
53747: PUSH
53748: LD_EXP 128
53752: PUSH
53753: LD_VAR 0 2
53757: ARRAY
53758: PUSH
53759: FOR_IN
53760: IFFALSE 53937
// begin if GetClass ( j ) <> 3 then
53762: LD_VAR 0 3
53766: PPUSH
53767: CALL_OW 257
53771: PUSH
53772: LD_INT 3
53774: NONEQUAL
53775: IFFALSE 53816
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53777: LD_ADDR_EXP 128
53781: PUSH
53782: LD_EXP 128
53786: PPUSH
53787: LD_VAR 0 2
53791: PPUSH
53792: LD_EXP 128
53796: PUSH
53797: LD_VAR 0 2
53801: ARRAY
53802: PUSH
53803: LD_VAR 0 3
53807: DIFF
53808: PPUSH
53809: CALL_OW 1
53813: ST_TO_ADDR
// continue ;
53814: GO 53759
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53816: LD_VAR 0 3
53820: PPUSH
53821: CALL_OW 311
53825: NOT
53826: PUSH
53827: LD_VAR 0 3
53831: PUSH
53832: LD_EXP 119
53836: PUSH
53837: LD_VAR 0 2
53841: ARRAY
53842: PUSH
53843: LD_INT 1
53845: ARRAY
53846: IN
53847: NOT
53848: AND
53849: PUSH
53850: LD_VAR 0 3
53854: PUSH
53855: LD_EXP 119
53859: PUSH
53860: LD_VAR 0 2
53864: ARRAY
53865: PUSH
53866: LD_INT 2
53868: ARRAY
53869: IN
53870: NOT
53871: AND
53872: IFFALSE 53935
// begin if IsInUnit ( j ) then
53874: LD_VAR 0 3
53878: PPUSH
53879: CALL_OW 310
53883: IFFALSE 53896
// ComExitBuilding ( j ) else
53885: LD_VAR 0 3
53889: PPUSH
53890: CALL_OW 122
53894: GO 53935
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
53896: LD_VAR 0 3
53900: PPUSH
53901: LD_VAR 0 7
53905: PUSH
53906: LD_INT 1
53908: ARRAY
53909: PPUSH
53910: CALL 104470 0 2
53914: NOT
53915: IFFALSE 53935
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
53917: LD_VAR 0 3
53921: PPUSH
53922: LD_VAR 0 7
53926: PUSH
53927: LD_INT 1
53929: ARRAY
53930: PPUSH
53931: CALL_OW 129
// end ; end ;
53935: GO 53759
53937: POP
53938: POP
// end ;
53939: GO 53248
53941: POP
53942: POP
// end ;
53943: LD_VAR 0 1
53947: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53948: LD_INT 0
53950: PPUSH
53951: PPUSH
53952: PPUSH
53953: PPUSH
53954: PPUSH
53955: PPUSH
53956: PPUSH
53957: PPUSH
53958: PPUSH
53959: PPUSH
53960: PPUSH
// if not mc_bases then
53961: LD_EXP 116
53965: NOT
53966: IFFALSE 53970
// exit ;
53968: GO 54772
// for i = 1 to mc_bases do
53970: LD_ADDR_VAR 0 2
53974: PUSH
53975: DOUBLE
53976: LD_INT 1
53978: DEC
53979: ST_TO_ADDR
53980: LD_EXP 116
53984: PUSH
53985: FOR_TO
53986: IFFALSE 54770
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53988: LD_EXP 144
53992: PUSH
53993: LD_VAR 0 2
53997: ARRAY
53998: NOT
53999: PUSH
54000: LD_EXP 119
54004: PUSH
54005: LD_VAR 0 2
54009: ARRAY
54010: PUSH
54011: LD_INT 1
54013: ARRAY
54014: OR
54015: PUSH
54016: LD_EXP 119
54020: PUSH
54021: LD_VAR 0 2
54025: ARRAY
54026: PUSH
54027: LD_INT 2
54029: ARRAY
54030: OR
54031: PUSH
54032: LD_EXP 142
54036: PUSH
54037: LD_VAR 0 2
54041: ARRAY
54042: PPUSH
54043: LD_INT 1
54045: PPUSH
54046: CALL_OW 325
54050: NOT
54051: OR
54052: PUSH
54053: LD_EXP 139
54057: PUSH
54058: LD_VAR 0 2
54062: ARRAY
54063: OR
54064: IFFALSE 54068
// continue ;
54066: GO 53985
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
54068: LD_ADDR_VAR 0 8
54072: PUSH
54073: LD_EXP 116
54077: PUSH
54078: LD_VAR 0 2
54082: ARRAY
54083: PPUSH
54084: LD_INT 25
54086: PUSH
54087: LD_INT 4
54089: PUSH
54090: EMPTY
54091: LIST
54092: LIST
54093: PUSH
54094: LD_INT 50
54096: PUSH
54097: EMPTY
54098: LIST
54099: PUSH
54100: LD_INT 3
54102: PUSH
54103: LD_INT 60
54105: PUSH
54106: EMPTY
54107: LIST
54108: PUSH
54109: EMPTY
54110: LIST
54111: LIST
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: LIST
54117: PPUSH
54118: CALL_OW 72
54122: PUSH
54123: LD_EXP 120
54127: PUSH
54128: LD_VAR 0 2
54132: ARRAY
54133: DIFF
54134: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54135: LD_ADDR_VAR 0 9
54139: PUSH
54140: LD_EXP 116
54144: PUSH
54145: LD_VAR 0 2
54149: ARRAY
54150: PPUSH
54151: LD_INT 2
54153: PUSH
54154: LD_INT 30
54156: PUSH
54157: LD_INT 0
54159: PUSH
54160: EMPTY
54161: LIST
54162: LIST
54163: PUSH
54164: LD_INT 30
54166: PUSH
54167: LD_INT 1
54169: PUSH
54170: EMPTY
54171: LIST
54172: LIST
54173: PUSH
54174: EMPTY
54175: LIST
54176: LIST
54177: LIST
54178: PPUSH
54179: CALL_OW 72
54183: ST_TO_ADDR
// if not tmp or not dep then
54184: LD_VAR 0 8
54188: NOT
54189: PUSH
54190: LD_VAR 0 9
54194: NOT
54195: OR
54196: IFFALSE 54200
// continue ;
54198: GO 53985
// side := GetSide ( tmp [ 1 ] ) ;
54200: LD_ADDR_VAR 0 11
54204: PUSH
54205: LD_VAR 0 8
54209: PUSH
54210: LD_INT 1
54212: ARRAY
54213: PPUSH
54214: CALL_OW 255
54218: ST_TO_ADDR
// dep := dep [ 1 ] ;
54219: LD_ADDR_VAR 0 9
54223: PUSH
54224: LD_VAR 0 9
54228: PUSH
54229: LD_INT 1
54231: ARRAY
54232: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
54233: LD_ADDR_VAR 0 7
54237: PUSH
54238: LD_EXP 144
54242: PUSH
54243: LD_VAR 0 2
54247: ARRAY
54248: PPUSH
54249: LD_INT 22
54251: PUSH
54252: LD_INT 0
54254: PUSH
54255: EMPTY
54256: LIST
54257: LIST
54258: PUSH
54259: LD_INT 25
54261: PUSH
54262: LD_INT 12
54264: PUSH
54265: EMPTY
54266: LIST
54267: LIST
54268: PUSH
54269: EMPTY
54270: LIST
54271: LIST
54272: PPUSH
54273: CALL_OW 70
54277: PUSH
54278: LD_INT 22
54280: PUSH
54281: LD_INT 0
54283: PUSH
54284: EMPTY
54285: LIST
54286: LIST
54287: PUSH
54288: LD_INT 25
54290: PUSH
54291: LD_INT 12
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: PUSH
54298: LD_INT 91
54300: PUSH
54301: LD_VAR 0 9
54305: PUSH
54306: LD_INT 20
54308: PUSH
54309: EMPTY
54310: LIST
54311: LIST
54312: LIST
54313: PUSH
54314: EMPTY
54315: LIST
54316: LIST
54317: LIST
54318: PPUSH
54319: CALL_OW 69
54323: UNION
54324: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54325: LD_ADDR_VAR 0 10
54329: PUSH
54330: LD_EXP 144
54334: PUSH
54335: LD_VAR 0 2
54339: ARRAY
54340: PPUSH
54341: LD_INT 81
54343: PUSH
54344: LD_VAR 0 11
54348: PUSH
54349: EMPTY
54350: LIST
54351: LIST
54352: PPUSH
54353: CALL_OW 70
54357: ST_TO_ADDR
// if not apes or danger_at_area then
54358: LD_VAR 0 7
54362: NOT
54363: PUSH
54364: LD_VAR 0 10
54368: OR
54369: IFFALSE 54419
// begin if mc_taming [ i ] then
54371: LD_EXP 147
54375: PUSH
54376: LD_VAR 0 2
54380: ARRAY
54381: IFFALSE 54417
// begin MC_Reset ( i , 121 ) ;
54383: LD_VAR 0 2
54387: PPUSH
54388: LD_INT 121
54390: PPUSH
54391: CALL 39405 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54395: LD_ADDR_EXP 147
54399: PUSH
54400: LD_EXP 147
54404: PPUSH
54405: LD_VAR 0 2
54409: PPUSH
54410: EMPTY
54411: PPUSH
54412: CALL_OW 1
54416: ST_TO_ADDR
// end ; continue ;
54417: GO 53985
// end ; for j in tmp do
54419: LD_ADDR_VAR 0 3
54423: PUSH
54424: LD_VAR 0 8
54428: PUSH
54429: FOR_IN
54430: IFFALSE 54766
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54432: LD_VAR 0 3
54436: PUSH
54437: LD_EXP 147
54441: PUSH
54442: LD_VAR 0 2
54446: ARRAY
54447: IN
54448: NOT
54449: PUSH
54450: LD_EXP 147
54454: PUSH
54455: LD_VAR 0 2
54459: ARRAY
54460: PUSH
54461: LD_INT 3
54463: LESS
54464: AND
54465: IFFALSE 54523
// begin SetTag ( j , 121 ) ;
54467: LD_VAR 0 3
54471: PPUSH
54472: LD_INT 121
54474: PPUSH
54475: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54479: LD_ADDR_EXP 147
54483: PUSH
54484: LD_EXP 147
54488: PPUSH
54489: LD_VAR 0 2
54493: PUSH
54494: LD_EXP 147
54498: PUSH
54499: LD_VAR 0 2
54503: ARRAY
54504: PUSH
54505: LD_INT 1
54507: PLUS
54508: PUSH
54509: EMPTY
54510: LIST
54511: LIST
54512: PPUSH
54513: LD_VAR 0 3
54517: PPUSH
54518: CALL 70863 0 3
54522: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54523: LD_VAR 0 3
54527: PUSH
54528: LD_EXP 147
54532: PUSH
54533: LD_VAR 0 2
54537: ARRAY
54538: IN
54539: IFFALSE 54764
// begin if GetClass ( j ) <> 4 then
54541: LD_VAR 0 3
54545: PPUSH
54546: CALL_OW 257
54550: PUSH
54551: LD_INT 4
54553: NONEQUAL
54554: IFFALSE 54607
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54556: LD_ADDR_EXP 147
54560: PUSH
54561: LD_EXP 147
54565: PPUSH
54566: LD_VAR 0 2
54570: PPUSH
54571: LD_EXP 147
54575: PUSH
54576: LD_VAR 0 2
54580: ARRAY
54581: PUSH
54582: LD_VAR 0 3
54586: DIFF
54587: PPUSH
54588: CALL_OW 1
54592: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54593: LD_VAR 0 3
54597: PPUSH
54598: LD_INT 0
54600: PPUSH
54601: CALL_OW 109
// continue ;
54605: GO 54429
// end ; if IsInUnit ( j ) then
54607: LD_VAR 0 3
54611: PPUSH
54612: CALL_OW 310
54616: IFFALSE 54627
// ComExitBuilding ( j ) ;
54618: LD_VAR 0 3
54622: PPUSH
54623: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54627: LD_ADDR_VAR 0 6
54631: PUSH
54632: LD_VAR 0 7
54636: PPUSH
54637: LD_VAR 0 3
54641: PPUSH
54642: CALL_OW 74
54646: ST_TO_ADDR
// if not ape then
54647: LD_VAR 0 6
54651: NOT
54652: IFFALSE 54656
// break ;
54654: GO 54766
// x := GetX ( ape ) ;
54656: LD_ADDR_VAR 0 4
54660: PUSH
54661: LD_VAR 0 6
54665: PPUSH
54666: CALL_OW 250
54670: ST_TO_ADDR
// y := GetY ( ape ) ;
54671: LD_ADDR_VAR 0 5
54675: PUSH
54676: LD_VAR 0 6
54680: PPUSH
54681: CALL_OW 251
54685: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54686: LD_VAR 0 4
54690: PPUSH
54691: LD_VAR 0 5
54695: PPUSH
54696: CALL_OW 488
54700: NOT
54701: PUSH
54702: LD_VAR 0 11
54706: PPUSH
54707: LD_VAR 0 4
54711: PPUSH
54712: LD_VAR 0 5
54716: PPUSH
54717: LD_INT 20
54719: PPUSH
54720: CALL 71759 0 4
54724: PUSH
54725: LD_INT 4
54727: ARRAY
54728: OR
54729: IFFALSE 54733
// break ;
54731: GO 54766
// if not HasTask ( j ) then
54733: LD_VAR 0 3
54737: PPUSH
54738: CALL_OW 314
54742: NOT
54743: IFFALSE 54764
// ComTameXY ( j , x , y ) ;
54745: LD_VAR 0 3
54749: PPUSH
54750: LD_VAR 0 4
54754: PPUSH
54755: LD_VAR 0 5
54759: PPUSH
54760: CALL_OW 131
// end ; end ;
54764: GO 54429
54766: POP
54767: POP
// end ;
54768: GO 53985
54770: POP
54771: POP
// end ;
54772: LD_VAR 0 1
54776: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54777: LD_INT 0
54779: PPUSH
54780: PPUSH
54781: PPUSH
54782: PPUSH
54783: PPUSH
54784: PPUSH
54785: PPUSH
54786: PPUSH
// if not mc_bases then
54787: LD_EXP 116
54791: NOT
54792: IFFALSE 54796
// exit ;
54794: GO 55422
// for i = 1 to mc_bases do
54796: LD_ADDR_VAR 0 2
54800: PUSH
54801: DOUBLE
54802: LD_INT 1
54804: DEC
54805: ST_TO_ADDR
54806: LD_EXP 116
54810: PUSH
54811: FOR_TO
54812: IFFALSE 55420
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54814: LD_EXP 145
54818: PUSH
54819: LD_VAR 0 2
54823: ARRAY
54824: NOT
54825: PUSH
54826: LD_EXP 145
54830: PUSH
54831: LD_VAR 0 2
54835: ARRAY
54836: PPUSH
54837: LD_INT 25
54839: PUSH
54840: LD_INT 12
54842: PUSH
54843: EMPTY
54844: LIST
54845: LIST
54846: PPUSH
54847: CALL_OW 72
54851: NOT
54852: OR
54853: IFFALSE 54857
// continue ;
54855: GO 54811
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54857: LD_ADDR_VAR 0 5
54861: PUSH
54862: LD_EXP 145
54866: PUSH
54867: LD_VAR 0 2
54871: ARRAY
54872: PUSH
54873: LD_INT 1
54875: ARRAY
54876: PPUSH
54877: CALL_OW 255
54881: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54882: LD_VAR 0 5
54886: PPUSH
54887: LD_INT 2
54889: PPUSH
54890: CALL_OW 325
54894: IFFALSE 55147
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54896: LD_ADDR_VAR 0 4
54900: PUSH
54901: LD_EXP 145
54905: PUSH
54906: LD_VAR 0 2
54910: ARRAY
54911: PPUSH
54912: LD_INT 25
54914: PUSH
54915: LD_INT 16
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: PPUSH
54922: CALL_OW 72
54926: ST_TO_ADDR
// if tmp < 6 then
54927: LD_VAR 0 4
54931: PUSH
54932: LD_INT 6
54934: LESS
54935: IFFALSE 55147
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54937: LD_ADDR_VAR 0 6
54941: PUSH
54942: LD_EXP 116
54946: PUSH
54947: LD_VAR 0 2
54951: ARRAY
54952: PPUSH
54953: LD_INT 2
54955: PUSH
54956: LD_INT 30
54958: PUSH
54959: LD_INT 0
54961: PUSH
54962: EMPTY
54963: LIST
54964: LIST
54965: PUSH
54966: LD_INT 30
54968: PUSH
54969: LD_INT 1
54971: PUSH
54972: EMPTY
54973: LIST
54974: LIST
54975: PUSH
54976: EMPTY
54977: LIST
54978: LIST
54979: LIST
54980: PPUSH
54981: CALL_OW 72
54985: ST_TO_ADDR
// if depot then
54986: LD_VAR 0 6
54990: IFFALSE 55147
// begin selected := 0 ;
54992: LD_ADDR_VAR 0 7
54996: PUSH
54997: LD_INT 0
54999: ST_TO_ADDR
// for j in depot do
55000: LD_ADDR_VAR 0 3
55004: PUSH
55005: LD_VAR 0 6
55009: PUSH
55010: FOR_IN
55011: IFFALSE 55042
// begin if UnitsInside ( j ) < 6 then
55013: LD_VAR 0 3
55017: PPUSH
55018: CALL_OW 313
55022: PUSH
55023: LD_INT 6
55025: LESS
55026: IFFALSE 55040
// begin selected := j ;
55028: LD_ADDR_VAR 0 7
55032: PUSH
55033: LD_VAR 0 3
55037: ST_TO_ADDR
// break ;
55038: GO 55042
// end ; end ;
55040: GO 55010
55042: POP
55043: POP
// if selected then
55044: LD_VAR 0 7
55048: IFFALSE 55147
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55050: LD_ADDR_VAR 0 3
55054: PUSH
55055: LD_EXP 145
55059: PUSH
55060: LD_VAR 0 2
55064: ARRAY
55065: PPUSH
55066: LD_INT 25
55068: PUSH
55069: LD_INT 12
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: PPUSH
55076: CALL_OW 72
55080: PUSH
55081: FOR_IN
55082: IFFALSE 55145
// if not HasTask ( j ) then
55084: LD_VAR 0 3
55088: PPUSH
55089: CALL_OW 314
55093: NOT
55094: IFFALSE 55143
// begin if not IsInUnit ( j ) then
55096: LD_VAR 0 3
55100: PPUSH
55101: CALL_OW 310
55105: NOT
55106: IFFALSE 55122
// ComEnterUnit ( j , selected ) ;
55108: LD_VAR 0 3
55112: PPUSH
55113: LD_VAR 0 7
55117: PPUSH
55118: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
55122: LD_VAR 0 3
55126: PPUSH
55127: LD_INT 16
55129: PPUSH
55130: CALL_OW 183
// AddComExitBuilding ( j ) ;
55134: LD_VAR 0 3
55138: PPUSH
55139: CALL_OW 182
// end ;
55143: GO 55081
55145: POP
55146: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
55147: LD_VAR 0 5
55151: PPUSH
55152: LD_INT 11
55154: PPUSH
55155: CALL_OW 325
55159: IFFALSE 55418
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
55161: LD_ADDR_VAR 0 4
55165: PUSH
55166: LD_EXP 145
55170: PUSH
55171: LD_VAR 0 2
55175: ARRAY
55176: PPUSH
55177: LD_INT 25
55179: PUSH
55180: LD_INT 16
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: PPUSH
55187: CALL_OW 72
55191: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
55192: LD_VAR 0 4
55196: PUSH
55197: LD_INT 6
55199: GREATEREQUAL
55200: PUSH
55201: LD_VAR 0 5
55205: PPUSH
55206: LD_INT 2
55208: PPUSH
55209: CALL_OW 325
55213: NOT
55214: OR
55215: IFFALSE 55418
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55217: LD_ADDR_VAR 0 8
55221: PUSH
55222: LD_EXP 116
55226: PUSH
55227: LD_VAR 0 2
55231: ARRAY
55232: PPUSH
55233: LD_INT 2
55235: PUSH
55236: LD_INT 30
55238: PUSH
55239: LD_INT 4
55241: PUSH
55242: EMPTY
55243: LIST
55244: LIST
55245: PUSH
55246: LD_INT 30
55248: PUSH
55249: LD_INT 5
55251: PUSH
55252: EMPTY
55253: LIST
55254: LIST
55255: PUSH
55256: EMPTY
55257: LIST
55258: LIST
55259: LIST
55260: PPUSH
55261: CALL_OW 72
55265: ST_TO_ADDR
// if barracks then
55266: LD_VAR 0 8
55270: IFFALSE 55418
// begin selected := 0 ;
55272: LD_ADDR_VAR 0 7
55276: PUSH
55277: LD_INT 0
55279: ST_TO_ADDR
// for j in barracks do
55280: LD_ADDR_VAR 0 3
55284: PUSH
55285: LD_VAR 0 8
55289: PUSH
55290: FOR_IN
55291: IFFALSE 55322
// begin if UnitsInside ( j ) < 6 then
55293: LD_VAR 0 3
55297: PPUSH
55298: CALL_OW 313
55302: PUSH
55303: LD_INT 6
55305: LESS
55306: IFFALSE 55320
// begin selected := j ;
55308: LD_ADDR_VAR 0 7
55312: PUSH
55313: LD_VAR 0 3
55317: ST_TO_ADDR
// break ;
55318: GO 55322
// end ; end ;
55320: GO 55290
55322: POP
55323: POP
// if selected then
55324: LD_VAR 0 7
55328: IFFALSE 55418
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55330: LD_ADDR_VAR 0 3
55334: PUSH
55335: LD_EXP 145
55339: PUSH
55340: LD_VAR 0 2
55344: ARRAY
55345: PPUSH
55346: LD_INT 25
55348: PUSH
55349: LD_INT 12
55351: PUSH
55352: EMPTY
55353: LIST
55354: LIST
55355: PPUSH
55356: CALL_OW 72
55360: PUSH
55361: FOR_IN
55362: IFFALSE 55416
// if not IsInUnit ( j ) and not HasTask ( j ) then
55364: LD_VAR 0 3
55368: PPUSH
55369: CALL_OW 310
55373: NOT
55374: PUSH
55375: LD_VAR 0 3
55379: PPUSH
55380: CALL_OW 314
55384: NOT
55385: AND
55386: IFFALSE 55414
// begin ComEnterUnit ( j , selected ) ;
55388: LD_VAR 0 3
55392: PPUSH
55393: LD_VAR 0 7
55397: PPUSH
55398: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55402: LD_VAR 0 3
55406: PPUSH
55407: LD_INT 15
55409: PPUSH
55410: CALL_OW 183
// end ;
55414: GO 55361
55416: POP
55417: POP
// end ; end ; end ; end ; end ;
55418: GO 54811
55420: POP
55421: POP
// end ;
55422: LD_VAR 0 1
55426: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55427: LD_INT 0
55429: PPUSH
55430: PPUSH
55431: PPUSH
55432: PPUSH
// if not mc_bases then
55433: LD_EXP 116
55437: NOT
55438: IFFALSE 55442
// exit ;
55440: GO 55620
// for i = 1 to mc_bases do
55442: LD_ADDR_VAR 0 2
55446: PUSH
55447: DOUBLE
55448: LD_INT 1
55450: DEC
55451: ST_TO_ADDR
55452: LD_EXP 116
55456: PUSH
55457: FOR_TO
55458: IFFALSE 55618
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55460: LD_ADDR_VAR 0 4
55464: PUSH
55465: LD_EXP 116
55469: PUSH
55470: LD_VAR 0 2
55474: ARRAY
55475: PPUSH
55476: LD_INT 25
55478: PUSH
55479: LD_INT 9
55481: PUSH
55482: EMPTY
55483: LIST
55484: LIST
55485: PPUSH
55486: CALL_OW 72
55490: ST_TO_ADDR
// if not tmp then
55491: LD_VAR 0 4
55495: NOT
55496: IFFALSE 55500
// continue ;
55498: GO 55457
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55500: LD_EXP 142
55504: PUSH
55505: LD_VAR 0 2
55509: ARRAY
55510: PPUSH
55511: LD_INT 29
55513: PPUSH
55514: CALL_OW 325
55518: NOT
55519: PUSH
55520: LD_EXP 142
55524: PUSH
55525: LD_VAR 0 2
55529: ARRAY
55530: PPUSH
55531: LD_INT 28
55533: PPUSH
55534: CALL_OW 325
55538: NOT
55539: AND
55540: IFFALSE 55544
// continue ;
55542: GO 55457
// for j in tmp do
55544: LD_ADDR_VAR 0 3
55548: PUSH
55549: LD_VAR 0 4
55553: PUSH
55554: FOR_IN
55555: IFFALSE 55614
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55557: LD_VAR 0 3
55561: PUSH
55562: LD_EXP 119
55566: PUSH
55567: LD_VAR 0 2
55571: ARRAY
55572: PUSH
55573: LD_INT 1
55575: ARRAY
55576: IN
55577: NOT
55578: PUSH
55579: LD_VAR 0 3
55583: PUSH
55584: LD_EXP 119
55588: PUSH
55589: LD_VAR 0 2
55593: ARRAY
55594: PUSH
55595: LD_INT 2
55597: ARRAY
55598: IN
55599: NOT
55600: AND
55601: IFFALSE 55612
// ComSpaceTimeShoot ( j ) ;
55603: LD_VAR 0 3
55607: PPUSH
55608: CALL 66824 0 1
55612: GO 55554
55614: POP
55615: POP
// end ;
55616: GO 55457
55618: POP
55619: POP
// end ;
55620: LD_VAR 0 1
55624: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55625: LD_INT 0
55627: PPUSH
55628: PPUSH
55629: PPUSH
55630: PPUSH
55631: PPUSH
55632: PPUSH
55633: PPUSH
55634: PPUSH
55635: PPUSH
// if not mc_bases then
55636: LD_EXP 116
55640: NOT
55641: IFFALSE 55645
// exit ;
55643: GO 56267
// for i = 1 to mc_bases do
55645: LD_ADDR_VAR 0 2
55649: PUSH
55650: DOUBLE
55651: LD_INT 1
55653: DEC
55654: ST_TO_ADDR
55655: LD_EXP 116
55659: PUSH
55660: FOR_TO
55661: IFFALSE 56265
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55663: LD_EXP 151
55667: PUSH
55668: LD_VAR 0 2
55672: ARRAY
55673: NOT
55674: PUSH
55675: LD_INT 38
55677: PPUSH
55678: LD_EXP 142
55682: PUSH
55683: LD_VAR 0 2
55687: ARRAY
55688: PPUSH
55689: CALL_OW 321
55693: PUSH
55694: LD_INT 2
55696: NONEQUAL
55697: OR
55698: IFFALSE 55702
// continue ;
55700: GO 55660
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55702: LD_ADDR_VAR 0 8
55706: PUSH
55707: LD_EXP 116
55711: PUSH
55712: LD_VAR 0 2
55716: ARRAY
55717: PPUSH
55718: LD_INT 30
55720: PUSH
55721: LD_INT 34
55723: PUSH
55724: EMPTY
55725: LIST
55726: LIST
55727: PPUSH
55728: CALL_OW 72
55732: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55733: LD_ADDR_VAR 0 9
55737: PUSH
55738: LD_EXP 116
55742: PUSH
55743: LD_VAR 0 2
55747: ARRAY
55748: PPUSH
55749: LD_INT 25
55751: PUSH
55752: LD_INT 4
55754: PUSH
55755: EMPTY
55756: LIST
55757: LIST
55758: PPUSH
55759: CALL_OW 72
55763: PPUSH
55764: LD_INT 0
55766: PPUSH
55767: CALL 100132 0 2
55771: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55772: LD_VAR 0 9
55776: NOT
55777: PUSH
55778: LD_VAR 0 8
55782: NOT
55783: OR
55784: PUSH
55785: LD_EXP 116
55789: PUSH
55790: LD_VAR 0 2
55794: ARRAY
55795: PPUSH
55796: LD_INT 124
55798: PPUSH
55799: CALL 100132 0 2
55803: OR
55804: IFFALSE 55808
// continue ;
55806: GO 55660
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55808: LD_EXP 152
55812: PUSH
55813: LD_VAR 0 2
55817: ARRAY
55818: PUSH
55819: LD_EXP 151
55823: PUSH
55824: LD_VAR 0 2
55828: ARRAY
55829: LESS
55830: PUSH
55831: LD_EXP 152
55835: PUSH
55836: LD_VAR 0 2
55840: ARRAY
55841: PUSH
55842: LD_VAR 0 8
55846: LESS
55847: AND
55848: IFFALSE 56263
// begin tmp := sci [ 1 ] ;
55850: LD_ADDR_VAR 0 7
55854: PUSH
55855: LD_VAR 0 9
55859: PUSH
55860: LD_INT 1
55862: ARRAY
55863: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55864: LD_VAR 0 7
55868: PPUSH
55869: LD_INT 124
55871: PPUSH
55872: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55876: LD_ADDR_VAR 0 3
55880: PUSH
55881: DOUBLE
55882: LD_EXP 151
55886: PUSH
55887: LD_VAR 0 2
55891: ARRAY
55892: INC
55893: ST_TO_ADDR
55894: LD_EXP 151
55898: PUSH
55899: LD_VAR 0 2
55903: ARRAY
55904: PUSH
55905: FOR_DOWNTO
55906: IFFALSE 56249
// begin if IsInUnit ( tmp ) then
55908: LD_VAR 0 7
55912: PPUSH
55913: CALL_OW 310
55917: IFFALSE 55928
// ComExitBuilding ( tmp ) ;
55919: LD_VAR 0 7
55923: PPUSH
55924: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55928: LD_INT 35
55930: PPUSH
55931: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55935: LD_VAR 0 7
55939: PPUSH
55940: CALL_OW 310
55944: NOT
55945: PUSH
55946: LD_VAR 0 7
55950: PPUSH
55951: CALL_OW 314
55955: NOT
55956: AND
55957: IFFALSE 55928
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55959: LD_ADDR_VAR 0 6
55963: PUSH
55964: LD_VAR 0 7
55968: PPUSH
55969: CALL_OW 250
55973: PUSH
55974: LD_VAR 0 7
55978: PPUSH
55979: CALL_OW 251
55983: PUSH
55984: EMPTY
55985: LIST
55986: LIST
55987: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55988: LD_INT 35
55990: PPUSH
55991: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55995: LD_ADDR_VAR 0 4
55999: PUSH
56000: LD_EXP 151
56004: PUSH
56005: LD_VAR 0 2
56009: ARRAY
56010: PUSH
56011: LD_VAR 0 3
56015: ARRAY
56016: PUSH
56017: LD_INT 1
56019: ARRAY
56020: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
56021: LD_ADDR_VAR 0 5
56025: PUSH
56026: LD_EXP 151
56030: PUSH
56031: LD_VAR 0 2
56035: ARRAY
56036: PUSH
56037: LD_VAR 0 3
56041: ARRAY
56042: PUSH
56043: LD_INT 2
56045: ARRAY
56046: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
56047: LD_VAR 0 7
56051: PPUSH
56052: LD_INT 10
56054: PPUSH
56055: CALL 73462 0 2
56059: PUSH
56060: LD_INT 4
56062: ARRAY
56063: IFFALSE 56101
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
56065: LD_VAR 0 7
56069: PPUSH
56070: LD_VAR 0 6
56074: PUSH
56075: LD_INT 1
56077: ARRAY
56078: PPUSH
56079: LD_VAR 0 6
56083: PUSH
56084: LD_INT 2
56086: ARRAY
56087: PPUSH
56088: CALL_OW 111
// wait ( 0 0$10 ) ;
56092: LD_INT 350
56094: PPUSH
56095: CALL_OW 67
// end else
56099: GO 56127
// begin ComMoveXY ( tmp , x , y ) ;
56101: LD_VAR 0 7
56105: PPUSH
56106: LD_VAR 0 4
56110: PPUSH
56111: LD_VAR 0 5
56115: PPUSH
56116: CALL_OW 111
// wait ( 0 0$3 ) ;
56120: LD_INT 105
56122: PPUSH
56123: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
56127: LD_VAR 0 7
56131: PPUSH
56132: LD_VAR 0 4
56136: PPUSH
56137: LD_VAR 0 5
56141: PPUSH
56142: CALL_OW 307
56146: IFFALSE 55988
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
56148: LD_VAR 0 7
56152: PPUSH
56153: LD_VAR 0 4
56157: PPUSH
56158: LD_VAR 0 5
56162: PPUSH
56163: LD_VAR 0 8
56167: PUSH
56168: LD_VAR 0 3
56172: ARRAY
56173: PPUSH
56174: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
56178: LD_INT 35
56180: PPUSH
56181: CALL_OW 67
// until not HasTask ( tmp ) ;
56185: LD_VAR 0 7
56189: PPUSH
56190: CALL_OW 314
56194: NOT
56195: IFFALSE 56178
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
56197: LD_ADDR_EXP 152
56201: PUSH
56202: LD_EXP 152
56206: PPUSH
56207: LD_VAR 0 2
56211: PUSH
56212: LD_EXP 152
56216: PUSH
56217: LD_VAR 0 2
56221: ARRAY
56222: PUSH
56223: LD_INT 1
56225: PLUS
56226: PUSH
56227: EMPTY
56228: LIST
56229: LIST
56230: PPUSH
56231: LD_VAR 0 8
56235: PUSH
56236: LD_VAR 0 3
56240: ARRAY
56241: PPUSH
56242: CALL 70863 0 3
56246: ST_TO_ADDR
// end ;
56247: GO 55905
56249: POP
56250: POP
// MC_Reset ( i , 124 ) ;
56251: LD_VAR 0 2
56255: PPUSH
56256: LD_INT 124
56258: PPUSH
56259: CALL 39405 0 2
// end ; end ;
56263: GO 55660
56265: POP
56266: POP
// end ;
56267: LD_VAR 0 1
56271: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
56272: LD_INT 0
56274: PPUSH
56275: PPUSH
56276: PPUSH
// if not mc_bases then
56277: LD_EXP 116
56281: NOT
56282: IFFALSE 56286
// exit ;
56284: GO 56892
// for i = 1 to mc_bases do
56286: LD_ADDR_VAR 0 2
56290: PUSH
56291: DOUBLE
56292: LD_INT 1
56294: DEC
56295: ST_TO_ADDR
56296: LD_EXP 116
56300: PUSH
56301: FOR_TO
56302: IFFALSE 56890
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56304: LD_ADDR_VAR 0 3
56308: PUSH
56309: LD_EXP 116
56313: PUSH
56314: LD_VAR 0 2
56318: ARRAY
56319: PPUSH
56320: LD_INT 25
56322: PUSH
56323: LD_INT 4
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: PPUSH
56330: CALL_OW 72
56334: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56335: LD_VAR 0 3
56339: NOT
56340: PUSH
56341: LD_EXP 153
56345: PUSH
56346: LD_VAR 0 2
56350: ARRAY
56351: NOT
56352: OR
56353: PUSH
56354: LD_EXP 116
56358: PUSH
56359: LD_VAR 0 2
56363: ARRAY
56364: PPUSH
56365: LD_INT 2
56367: PUSH
56368: LD_INT 30
56370: PUSH
56371: LD_INT 0
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: PUSH
56378: LD_INT 30
56380: PUSH
56381: LD_INT 1
56383: PUSH
56384: EMPTY
56385: LIST
56386: LIST
56387: PUSH
56388: EMPTY
56389: LIST
56390: LIST
56391: LIST
56392: PPUSH
56393: CALL_OW 72
56397: NOT
56398: OR
56399: IFFALSE 56449
// begin if mc_deposits_finder [ i ] then
56401: LD_EXP 154
56405: PUSH
56406: LD_VAR 0 2
56410: ARRAY
56411: IFFALSE 56447
// begin MC_Reset ( i , 125 ) ;
56413: LD_VAR 0 2
56417: PPUSH
56418: LD_INT 125
56420: PPUSH
56421: CALL 39405 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56425: LD_ADDR_EXP 154
56429: PUSH
56430: LD_EXP 154
56434: PPUSH
56435: LD_VAR 0 2
56439: PPUSH
56440: EMPTY
56441: PPUSH
56442: CALL_OW 1
56446: ST_TO_ADDR
// end ; continue ;
56447: GO 56301
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56449: LD_EXP 153
56453: PUSH
56454: LD_VAR 0 2
56458: ARRAY
56459: PUSH
56460: LD_INT 1
56462: ARRAY
56463: PUSH
56464: LD_INT 3
56466: ARRAY
56467: PUSH
56468: LD_INT 1
56470: EQUAL
56471: PUSH
56472: LD_INT 20
56474: PPUSH
56475: LD_EXP 142
56479: PUSH
56480: LD_VAR 0 2
56484: ARRAY
56485: PPUSH
56486: CALL_OW 321
56490: PUSH
56491: LD_INT 2
56493: NONEQUAL
56494: AND
56495: IFFALSE 56545
// begin if mc_deposits_finder [ i ] then
56497: LD_EXP 154
56501: PUSH
56502: LD_VAR 0 2
56506: ARRAY
56507: IFFALSE 56543
// begin MC_Reset ( i , 125 ) ;
56509: LD_VAR 0 2
56513: PPUSH
56514: LD_INT 125
56516: PPUSH
56517: CALL 39405 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56521: LD_ADDR_EXP 154
56525: PUSH
56526: LD_EXP 154
56530: PPUSH
56531: LD_VAR 0 2
56535: PPUSH
56536: EMPTY
56537: PPUSH
56538: CALL_OW 1
56542: ST_TO_ADDR
// end ; continue ;
56543: GO 56301
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56545: LD_EXP 153
56549: PUSH
56550: LD_VAR 0 2
56554: ARRAY
56555: PUSH
56556: LD_INT 1
56558: ARRAY
56559: PUSH
56560: LD_INT 1
56562: ARRAY
56563: PPUSH
56564: LD_EXP 153
56568: PUSH
56569: LD_VAR 0 2
56573: ARRAY
56574: PUSH
56575: LD_INT 1
56577: ARRAY
56578: PUSH
56579: LD_INT 2
56581: ARRAY
56582: PPUSH
56583: LD_EXP 142
56587: PUSH
56588: LD_VAR 0 2
56592: ARRAY
56593: PPUSH
56594: CALL_OW 440
56598: IFFALSE 56641
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56600: LD_ADDR_EXP 153
56604: PUSH
56605: LD_EXP 153
56609: PPUSH
56610: LD_VAR 0 2
56614: PPUSH
56615: LD_EXP 153
56619: PUSH
56620: LD_VAR 0 2
56624: ARRAY
56625: PPUSH
56626: LD_INT 1
56628: PPUSH
56629: CALL_OW 3
56633: PPUSH
56634: CALL_OW 1
56638: ST_TO_ADDR
56639: GO 56888
// begin if not mc_deposits_finder [ i ] then
56641: LD_EXP 154
56645: PUSH
56646: LD_VAR 0 2
56650: ARRAY
56651: NOT
56652: IFFALSE 56704
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56654: LD_ADDR_EXP 154
56658: PUSH
56659: LD_EXP 154
56663: PPUSH
56664: LD_VAR 0 2
56668: PPUSH
56669: LD_VAR 0 3
56673: PUSH
56674: LD_INT 1
56676: ARRAY
56677: PUSH
56678: EMPTY
56679: LIST
56680: PPUSH
56681: CALL_OW 1
56685: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56686: LD_VAR 0 3
56690: PUSH
56691: LD_INT 1
56693: ARRAY
56694: PPUSH
56695: LD_INT 125
56697: PPUSH
56698: CALL_OW 109
// end else
56702: GO 56888
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56704: LD_EXP 154
56708: PUSH
56709: LD_VAR 0 2
56713: ARRAY
56714: PUSH
56715: LD_INT 1
56717: ARRAY
56718: PPUSH
56719: CALL_OW 310
56723: IFFALSE 56746
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56725: LD_EXP 154
56729: PUSH
56730: LD_VAR 0 2
56734: ARRAY
56735: PUSH
56736: LD_INT 1
56738: ARRAY
56739: PPUSH
56740: CALL_OW 122
56744: GO 56888
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56746: LD_EXP 154
56750: PUSH
56751: LD_VAR 0 2
56755: ARRAY
56756: PUSH
56757: LD_INT 1
56759: ARRAY
56760: PPUSH
56761: CALL_OW 314
56765: NOT
56766: PUSH
56767: LD_EXP 154
56771: PUSH
56772: LD_VAR 0 2
56776: ARRAY
56777: PUSH
56778: LD_INT 1
56780: ARRAY
56781: PPUSH
56782: LD_EXP 153
56786: PUSH
56787: LD_VAR 0 2
56791: ARRAY
56792: PUSH
56793: LD_INT 1
56795: ARRAY
56796: PUSH
56797: LD_INT 1
56799: ARRAY
56800: PPUSH
56801: LD_EXP 153
56805: PUSH
56806: LD_VAR 0 2
56810: ARRAY
56811: PUSH
56812: LD_INT 1
56814: ARRAY
56815: PUSH
56816: LD_INT 2
56818: ARRAY
56819: PPUSH
56820: CALL_OW 297
56824: PUSH
56825: LD_INT 6
56827: GREATER
56828: AND
56829: IFFALSE 56888
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56831: LD_EXP 154
56835: PUSH
56836: LD_VAR 0 2
56840: ARRAY
56841: PUSH
56842: LD_INT 1
56844: ARRAY
56845: PPUSH
56846: LD_EXP 153
56850: PUSH
56851: LD_VAR 0 2
56855: ARRAY
56856: PUSH
56857: LD_INT 1
56859: ARRAY
56860: PUSH
56861: LD_INT 1
56863: ARRAY
56864: PPUSH
56865: LD_EXP 153
56869: PUSH
56870: LD_VAR 0 2
56874: ARRAY
56875: PUSH
56876: LD_INT 1
56878: ARRAY
56879: PUSH
56880: LD_INT 2
56882: ARRAY
56883: PPUSH
56884: CALL_OW 111
// end ; end ; end ;
56888: GO 56301
56890: POP
56891: POP
// end ;
56892: LD_VAR 0 1
56896: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56897: LD_INT 0
56899: PPUSH
56900: PPUSH
56901: PPUSH
56902: PPUSH
56903: PPUSH
56904: PPUSH
56905: PPUSH
56906: PPUSH
56907: PPUSH
56908: PPUSH
56909: PPUSH
// if not mc_bases then
56910: LD_EXP 116
56914: NOT
56915: IFFALSE 56919
// exit ;
56917: GO 57859
// for i = 1 to mc_bases do
56919: LD_ADDR_VAR 0 2
56923: PUSH
56924: DOUBLE
56925: LD_INT 1
56927: DEC
56928: ST_TO_ADDR
56929: LD_EXP 116
56933: PUSH
56934: FOR_TO
56935: IFFALSE 57857
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56937: LD_EXP 116
56941: PUSH
56942: LD_VAR 0 2
56946: ARRAY
56947: NOT
56948: PUSH
56949: LD_EXP 139
56953: PUSH
56954: LD_VAR 0 2
56958: ARRAY
56959: OR
56960: IFFALSE 56964
// continue ;
56962: GO 56934
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56964: LD_ADDR_VAR 0 7
56968: PUSH
56969: LD_EXP 116
56973: PUSH
56974: LD_VAR 0 2
56978: ARRAY
56979: PUSH
56980: LD_INT 1
56982: ARRAY
56983: PPUSH
56984: CALL_OW 248
56988: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56989: LD_VAR 0 7
56993: PUSH
56994: LD_INT 3
56996: EQUAL
56997: PUSH
56998: LD_EXP 135
57002: PUSH
57003: LD_VAR 0 2
57007: ARRAY
57008: PUSH
57009: LD_EXP 138
57013: PUSH
57014: LD_VAR 0 2
57018: ARRAY
57019: UNION
57020: PPUSH
57021: LD_INT 33
57023: PUSH
57024: LD_INT 2
57026: PUSH
57027: EMPTY
57028: LIST
57029: LIST
57030: PPUSH
57031: CALL_OW 72
57035: NOT
57036: OR
57037: IFFALSE 57041
// continue ;
57039: GO 56934
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
57041: LD_ADDR_VAR 0 9
57045: PUSH
57046: LD_EXP 116
57050: PUSH
57051: LD_VAR 0 2
57055: ARRAY
57056: PPUSH
57057: LD_INT 30
57059: PUSH
57060: LD_INT 36
57062: PUSH
57063: EMPTY
57064: LIST
57065: LIST
57066: PPUSH
57067: CALL_OW 72
57071: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
57072: LD_ADDR_VAR 0 10
57076: PUSH
57077: LD_EXP 135
57081: PUSH
57082: LD_VAR 0 2
57086: ARRAY
57087: PPUSH
57088: LD_INT 34
57090: PUSH
57091: LD_INT 31
57093: PUSH
57094: EMPTY
57095: LIST
57096: LIST
57097: PPUSH
57098: CALL_OW 72
57102: ST_TO_ADDR
// if not cts and not mcts then
57103: LD_VAR 0 9
57107: NOT
57108: PUSH
57109: LD_VAR 0 10
57113: NOT
57114: AND
57115: IFFALSE 57119
// continue ;
57117: GO 56934
// x := cts ;
57119: LD_ADDR_VAR 0 11
57123: PUSH
57124: LD_VAR 0 9
57128: ST_TO_ADDR
// if not x then
57129: LD_VAR 0 11
57133: NOT
57134: IFFALSE 57146
// x := mcts ;
57136: LD_ADDR_VAR 0 11
57140: PUSH
57141: LD_VAR 0 10
57145: ST_TO_ADDR
// if not x then
57146: LD_VAR 0 11
57150: NOT
57151: IFFALSE 57155
// continue ;
57153: GO 56934
// if mc_remote_driver [ i ] then
57155: LD_EXP 156
57159: PUSH
57160: LD_VAR 0 2
57164: ARRAY
57165: IFFALSE 57552
// for j in mc_remote_driver [ i ] do
57167: LD_ADDR_VAR 0 3
57171: PUSH
57172: LD_EXP 156
57176: PUSH
57177: LD_VAR 0 2
57181: ARRAY
57182: PUSH
57183: FOR_IN
57184: IFFALSE 57550
// begin if GetClass ( j ) <> 3 then
57186: LD_VAR 0 3
57190: PPUSH
57191: CALL_OW 257
57195: PUSH
57196: LD_INT 3
57198: NONEQUAL
57199: IFFALSE 57252
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
57201: LD_ADDR_EXP 156
57205: PUSH
57206: LD_EXP 156
57210: PPUSH
57211: LD_VAR 0 2
57215: PPUSH
57216: LD_EXP 156
57220: PUSH
57221: LD_VAR 0 2
57225: ARRAY
57226: PUSH
57227: LD_VAR 0 3
57231: DIFF
57232: PPUSH
57233: CALL_OW 1
57237: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57238: LD_VAR 0 3
57242: PPUSH
57243: LD_INT 0
57245: PPUSH
57246: CALL_OW 109
// continue ;
57250: GO 57183
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
57252: LD_EXP 135
57256: PUSH
57257: LD_VAR 0 2
57261: ARRAY
57262: PPUSH
57263: LD_INT 34
57265: PUSH
57266: LD_INT 31
57268: PUSH
57269: EMPTY
57270: LIST
57271: LIST
57272: PUSH
57273: LD_INT 58
57275: PUSH
57276: EMPTY
57277: LIST
57278: PUSH
57279: EMPTY
57280: LIST
57281: LIST
57282: PPUSH
57283: CALL_OW 72
57287: PUSH
57288: LD_VAR 0 3
57292: PPUSH
57293: CALL 100220 0 1
57297: NOT
57298: AND
57299: IFFALSE 57370
// begin if IsInUnit ( j ) then
57301: LD_VAR 0 3
57305: PPUSH
57306: CALL_OW 310
57310: IFFALSE 57321
// ComExitBuilding ( j ) ;
57312: LD_VAR 0 3
57316: PPUSH
57317: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
57321: LD_VAR 0 3
57325: PPUSH
57326: LD_EXP 135
57330: PUSH
57331: LD_VAR 0 2
57335: ARRAY
57336: PPUSH
57337: LD_INT 34
57339: PUSH
57340: LD_INT 31
57342: PUSH
57343: EMPTY
57344: LIST
57345: LIST
57346: PUSH
57347: LD_INT 58
57349: PUSH
57350: EMPTY
57351: LIST
57352: PUSH
57353: EMPTY
57354: LIST
57355: LIST
57356: PPUSH
57357: CALL_OW 72
57361: PUSH
57362: LD_INT 1
57364: ARRAY
57365: PPUSH
57366: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57370: LD_VAR 0 3
57374: PPUSH
57375: CALL_OW 310
57379: NOT
57380: PUSH
57381: LD_VAR 0 3
57385: PPUSH
57386: CALL_OW 310
57390: PPUSH
57391: CALL_OW 266
57395: PUSH
57396: LD_INT 36
57398: NONEQUAL
57399: PUSH
57400: LD_VAR 0 3
57404: PPUSH
57405: CALL 100220 0 1
57409: NOT
57410: AND
57411: OR
57412: IFFALSE 57548
// begin if IsInUnit ( j ) then
57414: LD_VAR 0 3
57418: PPUSH
57419: CALL_OW 310
57423: IFFALSE 57434
// ComExitBuilding ( j ) ;
57425: LD_VAR 0 3
57429: PPUSH
57430: CALL_OW 122
// ct := 0 ;
57434: LD_ADDR_VAR 0 8
57438: PUSH
57439: LD_INT 0
57441: ST_TO_ADDR
// for k in x do
57442: LD_ADDR_VAR 0 4
57446: PUSH
57447: LD_VAR 0 11
57451: PUSH
57452: FOR_IN
57453: IFFALSE 57526
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57455: LD_VAR 0 4
57459: PPUSH
57460: CALL_OW 264
57464: PUSH
57465: LD_INT 31
57467: EQUAL
57468: PUSH
57469: LD_VAR 0 4
57473: PPUSH
57474: CALL_OW 311
57478: NOT
57479: AND
57480: PUSH
57481: LD_VAR 0 4
57485: PPUSH
57486: CALL_OW 266
57490: PUSH
57491: LD_INT 36
57493: EQUAL
57494: PUSH
57495: LD_VAR 0 4
57499: PPUSH
57500: CALL_OW 313
57504: PUSH
57505: LD_INT 3
57507: LESS
57508: AND
57509: OR
57510: IFFALSE 57524
// begin ct := k ;
57512: LD_ADDR_VAR 0 8
57516: PUSH
57517: LD_VAR 0 4
57521: ST_TO_ADDR
// break ;
57522: GO 57526
// end ;
57524: GO 57452
57526: POP
57527: POP
// if ct then
57528: LD_VAR 0 8
57532: IFFALSE 57548
// ComEnterUnit ( j , ct ) ;
57534: LD_VAR 0 3
57538: PPUSH
57539: LD_VAR 0 8
57543: PPUSH
57544: CALL_OW 120
// end ; end ;
57548: GO 57183
57550: POP
57551: POP
// places := 0 ;
57552: LD_ADDR_VAR 0 5
57556: PUSH
57557: LD_INT 0
57559: ST_TO_ADDR
// for j = 1 to x do
57560: LD_ADDR_VAR 0 3
57564: PUSH
57565: DOUBLE
57566: LD_INT 1
57568: DEC
57569: ST_TO_ADDR
57570: LD_VAR 0 11
57574: PUSH
57575: FOR_TO
57576: IFFALSE 57652
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57578: LD_VAR 0 11
57582: PUSH
57583: LD_VAR 0 3
57587: ARRAY
57588: PPUSH
57589: CALL_OW 264
57593: PUSH
57594: LD_INT 31
57596: EQUAL
57597: IFFALSE 57615
// places := places + 1 else
57599: LD_ADDR_VAR 0 5
57603: PUSH
57604: LD_VAR 0 5
57608: PUSH
57609: LD_INT 1
57611: PLUS
57612: ST_TO_ADDR
57613: GO 57650
// if GetBType ( x [ j ] ) = b_control_tower then
57615: LD_VAR 0 11
57619: PUSH
57620: LD_VAR 0 3
57624: ARRAY
57625: PPUSH
57626: CALL_OW 266
57630: PUSH
57631: LD_INT 36
57633: EQUAL
57634: IFFALSE 57650
// places := places + 3 ;
57636: LD_ADDR_VAR 0 5
57640: PUSH
57641: LD_VAR 0 5
57645: PUSH
57646: LD_INT 3
57648: PLUS
57649: ST_TO_ADDR
57650: GO 57575
57652: POP
57653: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57654: LD_VAR 0 5
57658: PUSH
57659: LD_INT 0
57661: EQUAL
57662: PUSH
57663: LD_VAR 0 5
57667: PUSH
57668: LD_EXP 156
57672: PUSH
57673: LD_VAR 0 2
57677: ARRAY
57678: LESSEQUAL
57679: OR
57680: IFFALSE 57684
// continue ;
57682: GO 56934
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57684: LD_ADDR_VAR 0 6
57688: PUSH
57689: LD_EXP 116
57693: PUSH
57694: LD_VAR 0 2
57698: ARRAY
57699: PPUSH
57700: LD_INT 25
57702: PUSH
57703: LD_INT 3
57705: PUSH
57706: EMPTY
57707: LIST
57708: LIST
57709: PPUSH
57710: CALL_OW 72
57714: PUSH
57715: LD_EXP 156
57719: PUSH
57720: LD_VAR 0 2
57724: ARRAY
57725: DIFF
57726: PPUSH
57727: LD_INT 3
57729: PPUSH
57730: CALL 101120 0 2
57734: ST_TO_ADDR
// for j in tmp do
57735: LD_ADDR_VAR 0 3
57739: PUSH
57740: LD_VAR 0 6
57744: PUSH
57745: FOR_IN
57746: IFFALSE 57781
// if GetTag ( j ) > 0 then
57748: LD_VAR 0 3
57752: PPUSH
57753: CALL_OW 110
57757: PUSH
57758: LD_INT 0
57760: GREATER
57761: IFFALSE 57779
// tmp := tmp diff j ;
57763: LD_ADDR_VAR 0 6
57767: PUSH
57768: LD_VAR 0 6
57772: PUSH
57773: LD_VAR 0 3
57777: DIFF
57778: ST_TO_ADDR
57779: GO 57745
57781: POP
57782: POP
// if not tmp then
57783: LD_VAR 0 6
57787: NOT
57788: IFFALSE 57792
// continue ;
57790: GO 56934
// if places then
57792: LD_VAR 0 5
57796: IFFALSE 57855
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57798: LD_ADDR_EXP 156
57802: PUSH
57803: LD_EXP 156
57807: PPUSH
57808: LD_VAR 0 2
57812: PPUSH
57813: LD_EXP 156
57817: PUSH
57818: LD_VAR 0 2
57822: ARRAY
57823: PUSH
57824: LD_VAR 0 6
57828: PUSH
57829: LD_INT 1
57831: ARRAY
57832: UNION
57833: PPUSH
57834: CALL_OW 1
57838: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57839: LD_VAR 0 6
57843: PUSH
57844: LD_INT 1
57846: ARRAY
57847: PPUSH
57848: LD_INT 126
57850: PPUSH
57851: CALL_OW 109
// end ; end ;
57855: GO 56934
57857: POP
57858: POP
// end ;
57859: LD_VAR 0 1
57863: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57864: LD_INT 0
57866: PPUSH
57867: PPUSH
57868: PPUSH
57869: PPUSH
57870: PPUSH
57871: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57872: LD_VAR 0 1
57876: NOT
57877: PUSH
57878: LD_VAR 0 2
57882: NOT
57883: OR
57884: PUSH
57885: LD_VAR 0 3
57889: NOT
57890: OR
57891: PUSH
57892: LD_VAR 0 4
57896: PUSH
57897: LD_INT 1
57899: PUSH
57900: LD_INT 2
57902: PUSH
57903: LD_INT 3
57905: PUSH
57906: LD_INT 4
57908: PUSH
57909: LD_INT 5
57911: PUSH
57912: LD_INT 8
57914: PUSH
57915: LD_INT 9
57917: PUSH
57918: LD_INT 15
57920: PUSH
57921: LD_INT 16
57923: PUSH
57924: EMPTY
57925: LIST
57926: LIST
57927: LIST
57928: LIST
57929: LIST
57930: LIST
57931: LIST
57932: LIST
57933: LIST
57934: IN
57935: NOT
57936: OR
57937: IFFALSE 57941
// exit ;
57939: GO 58841
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57941: LD_ADDR_VAR 0 2
57945: PUSH
57946: LD_VAR 0 2
57950: PPUSH
57951: LD_INT 21
57953: PUSH
57954: LD_INT 3
57956: PUSH
57957: EMPTY
57958: LIST
57959: LIST
57960: PUSH
57961: LD_INT 24
57963: PUSH
57964: LD_INT 250
57966: PUSH
57967: EMPTY
57968: LIST
57969: LIST
57970: PUSH
57971: EMPTY
57972: LIST
57973: LIST
57974: PPUSH
57975: CALL_OW 72
57979: ST_TO_ADDR
// case class of 1 , 15 :
57980: LD_VAR 0 4
57984: PUSH
57985: LD_INT 1
57987: DOUBLE
57988: EQUAL
57989: IFTRUE 57999
57991: LD_INT 15
57993: DOUBLE
57994: EQUAL
57995: IFTRUE 57999
57997: GO 58084
57999: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
58000: LD_ADDR_VAR 0 8
58004: PUSH
58005: LD_VAR 0 2
58009: PPUSH
58010: LD_INT 2
58012: PUSH
58013: LD_INT 30
58015: PUSH
58016: LD_INT 32
58018: PUSH
58019: EMPTY
58020: LIST
58021: LIST
58022: PUSH
58023: LD_INT 30
58025: PUSH
58026: LD_INT 31
58028: PUSH
58029: EMPTY
58030: LIST
58031: LIST
58032: PUSH
58033: EMPTY
58034: LIST
58035: LIST
58036: LIST
58037: PPUSH
58038: CALL_OW 72
58042: PUSH
58043: LD_VAR 0 2
58047: PPUSH
58048: LD_INT 2
58050: PUSH
58051: LD_INT 30
58053: PUSH
58054: LD_INT 4
58056: PUSH
58057: EMPTY
58058: LIST
58059: LIST
58060: PUSH
58061: LD_INT 30
58063: PUSH
58064: LD_INT 5
58066: PUSH
58067: EMPTY
58068: LIST
58069: LIST
58070: PUSH
58071: EMPTY
58072: LIST
58073: LIST
58074: LIST
58075: PPUSH
58076: CALL_OW 72
58080: ADD
58081: ST_TO_ADDR
58082: GO 58330
58084: LD_INT 2
58086: DOUBLE
58087: EQUAL
58088: IFTRUE 58098
58090: LD_INT 16
58092: DOUBLE
58093: EQUAL
58094: IFTRUE 58098
58096: GO 58144
58098: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
58099: LD_ADDR_VAR 0 8
58103: PUSH
58104: LD_VAR 0 2
58108: PPUSH
58109: LD_INT 2
58111: PUSH
58112: LD_INT 30
58114: PUSH
58115: LD_INT 0
58117: PUSH
58118: EMPTY
58119: LIST
58120: LIST
58121: PUSH
58122: LD_INT 30
58124: PUSH
58125: LD_INT 1
58127: PUSH
58128: EMPTY
58129: LIST
58130: LIST
58131: PUSH
58132: EMPTY
58133: LIST
58134: LIST
58135: LIST
58136: PPUSH
58137: CALL_OW 72
58141: ST_TO_ADDR
58142: GO 58330
58144: LD_INT 3
58146: DOUBLE
58147: EQUAL
58148: IFTRUE 58152
58150: GO 58198
58152: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
58153: LD_ADDR_VAR 0 8
58157: PUSH
58158: LD_VAR 0 2
58162: PPUSH
58163: LD_INT 2
58165: PUSH
58166: LD_INT 30
58168: PUSH
58169: LD_INT 2
58171: PUSH
58172: EMPTY
58173: LIST
58174: LIST
58175: PUSH
58176: LD_INT 30
58178: PUSH
58179: LD_INT 3
58181: PUSH
58182: EMPTY
58183: LIST
58184: LIST
58185: PUSH
58186: EMPTY
58187: LIST
58188: LIST
58189: LIST
58190: PPUSH
58191: CALL_OW 72
58195: ST_TO_ADDR
58196: GO 58330
58198: LD_INT 4
58200: DOUBLE
58201: EQUAL
58202: IFTRUE 58206
58204: GO 58263
58206: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
58207: LD_ADDR_VAR 0 8
58211: PUSH
58212: LD_VAR 0 2
58216: PPUSH
58217: LD_INT 2
58219: PUSH
58220: LD_INT 30
58222: PUSH
58223: LD_INT 6
58225: PUSH
58226: EMPTY
58227: LIST
58228: LIST
58229: PUSH
58230: LD_INT 30
58232: PUSH
58233: LD_INT 7
58235: PUSH
58236: EMPTY
58237: LIST
58238: LIST
58239: PUSH
58240: LD_INT 30
58242: PUSH
58243: LD_INT 8
58245: PUSH
58246: EMPTY
58247: LIST
58248: LIST
58249: PUSH
58250: EMPTY
58251: LIST
58252: LIST
58253: LIST
58254: LIST
58255: PPUSH
58256: CALL_OW 72
58260: ST_TO_ADDR
58261: GO 58330
58263: LD_INT 5
58265: DOUBLE
58266: EQUAL
58267: IFTRUE 58283
58269: LD_INT 8
58271: DOUBLE
58272: EQUAL
58273: IFTRUE 58283
58275: LD_INT 9
58277: DOUBLE
58278: EQUAL
58279: IFTRUE 58283
58281: GO 58329
58283: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
58284: LD_ADDR_VAR 0 8
58288: PUSH
58289: LD_VAR 0 2
58293: PPUSH
58294: LD_INT 2
58296: PUSH
58297: LD_INT 30
58299: PUSH
58300: LD_INT 4
58302: PUSH
58303: EMPTY
58304: LIST
58305: LIST
58306: PUSH
58307: LD_INT 30
58309: PUSH
58310: LD_INT 5
58312: PUSH
58313: EMPTY
58314: LIST
58315: LIST
58316: PUSH
58317: EMPTY
58318: LIST
58319: LIST
58320: LIST
58321: PPUSH
58322: CALL_OW 72
58326: ST_TO_ADDR
58327: GO 58330
58329: POP
// if not tmp then
58330: LD_VAR 0 8
58334: NOT
58335: IFFALSE 58339
// exit ;
58337: GO 58841
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58339: LD_VAR 0 4
58343: PUSH
58344: LD_INT 1
58346: PUSH
58347: LD_INT 15
58349: PUSH
58350: EMPTY
58351: LIST
58352: LIST
58353: IN
58354: PUSH
58355: LD_EXP 125
58359: PUSH
58360: LD_VAR 0 1
58364: ARRAY
58365: AND
58366: IFFALSE 58522
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58368: LD_ADDR_VAR 0 9
58372: PUSH
58373: LD_EXP 125
58377: PUSH
58378: LD_VAR 0 1
58382: ARRAY
58383: PUSH
58384: LD_INT 1
58386: ARRAY
58387: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58388: LD_VAR 0 9
58392: PUSH
58393: LD_EXP 126
58397: PUSH
58398: LD_VAR 0 1
58402: ARRAY
58403: IN
58404: NOT
58405: IFFALSE 58520
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58407: LD_ADDR_EXP 126
58411: PUSH
58412: LD_EXP 126
58416: PPUSH
58417: LD_VAR 0 1
58421: PUSH
58422: LD_EXP 126
58426: PUSH
58427: LD_VAR 0 1
58431: ARRAY
58432: PUSH
58433: LD_INT 1
58435: PLUS
58436: PUSH
58437: EMPTY
58438: LIST
58439: LIST
58440: PPUSH
58441: LD_VAR 0 9
58445: PPUSH
58446: CALL 70863 0 3
58450: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58451: LD_ADDR_EXP 125
58455: PUSH
58456: LD_EXP 125
58460: PPUSH
58461: LD_VAR 0 1
58465: PPUSH
58466: LD_EXP 125
58470: PUSH
58471: LD_VAR 0 1
58475: ARRAY
58476: PUSH
58477: LD_VAR 0 9
58481: DIFF
58482: PPUSH
58483: CALL_OW 1
58487: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58488: LD_VAR 0 3
58492: PPUSH
58493: LD_EXP 126
58497: PUSH
58498: LD_VAR 0 1
58502: ARRAY
58503: PUSH
58504: LD_EXP 126
58508: PUSH
58509: LD_VAR 0 1
58513: ARRAY
58514: ARRAY
58515: PPUSH
58516: CALL_OW 120
// end ; exit ;
58520: GO 58841
// end ; if tmp > 1 then
58522: LD_VAR 0 8
58526: PUSH
58527: LD_INT 1
58529: GREATER
58530: IFFALSE 58634
// for i = 2 to tmp do
58532: LD_ADDR_VAR 0 6
58536: PUSH
58537: DOUBLE
58538: LD_INT 2
58540: DEC
58541: ST_TO_ADDR
58542: LD_VAR 0 8
58546: PUSH
58547: FOR_TO
58548: IFFALSE 58632
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58550: LD_VAR 0 8
58554: PUSH
58555: LD_VAR 0 6
58559: ARRAY
58560: PPUSH
58561: CALL_OW 461
58565: PUSH
58566: LD_INT 6
58568: EQUAL
58569: IFFALSE 58630
// begin x := tmp [ i ] ;
58571: LD_ADDR_VAR 0 9
58575: PUSH
58576: LD_VAR 0 8
58580: PUSH
58581: LD_VAR 0 6
58585: ARRAY
58586: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58587: LD_ADDR_VAR 0 8
58591: PUSH
58592: LD_VAR 0 8
58596: PPUSH
58597: LD_VAR 0 6
58601: PPUSH
58602: CALL_OW 3
58606: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58607: LD_ADDR_VAR 0 8
58611: PUSH
58612: LD_VAR 0 8
58616: PPUSH
58617: LD_INT 1
58619: PPUSH
58620: LD_VAR 0 9
58624: PPUSH
58625: CALL_OW 2
58629: ST_TO_ADDR
// end ;
58630: GO 58547
58632: POP
58633: POP
// for i in tmp do
58634: LD_ADDR_VAR 0 6
58638: PUSH
58639: LD_VAR 0 8
58643: PUSH
58644: FOR_IN
58645: IFFALSE 58714
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58647: LD_VAR 0 6
58651: PPUSH
58652: CALL_OW 313
58656: PUSH
58657: LD_INT 6
58659: LESS
58660: PUSH
58661: LD_VAR 0 6
58665: PPUSH
58666: CALL_OW 266
58670: PUSH
58671: LD_INT 31
58673: PUSH
58674: LD_INT 32
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: IN
58681: NOT
58682: AND
58683: PUSH
58684: LD_VAR 0 6
58688: PPUSH
58689: CALL_OW 313
58693: PUSH
58694: LD_INT 0
58696: EQUAL
58697: OR
58698: IFFALSE 58712
// begin j := i ;
58700: LD_ADDR_VAR 0 7
58704: PUSH
58705: LD_VAR 0 6
58709: ST_TO_ADDR
// break ;
58710: GO 58714
// end ; end ;
58712: GO 58644
58714: POP
58715: POP
// if j then
58716: LD_VAR 0 7
58720: IFFALSE 58738
// ComEnterUnit ( unit , j ) else
58722: LD_VAR 0 3
58726: PPUSH
58727: LD_VAR 0 7
58731: PPUSH
58732: CALL_OW 120
58736: GO 58841
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58738: LD_ADDR_VAR 0 10
58742: PUSH
58743: LD_VAR 0 2
58747: PPUSH
58748: LD_INT 2
58750: PUSH
58751: LD_INT 30
58753: PUSH
58754: LD_INT 0
58756: PUSH
58757: EMPTY
58758: LIST
58759: LIST
58760: PUSH
58761: LD_INT 30
58763: PUSH
58764: LD_INT 1
58766: PUSH
58767: EMPTY
58768: LIST
58769: LIST
58770: PUSH
58771: EMPTY
58772: LIST
58773: LIST
58774: LIST
58775: PPUSH
58776: CALL_OW 72
58780: ST_TO_ADDR
// if depot then
58781: LD_VAR 0 10
58785: IFFALSE 58841
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58787: LD_ADDR_VAR 0 10
58791: PUSH
58792: LD_VAR 0 10
58796: PPUSH
58797: LD_VAR 0 3
58801: PPUSH
58802: CALL_OW 74
58806: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58807: LD_VAR 0 3
58811: PPUSH
58812: LD_VAR 0 10
58816: PPUSH
58817: CALL_OW 296
58821: PUSH
58822: LD_INT 10
58824: GREATER
58825: IFFALSE 58841
// ComStandNearbyBuilding ( unit , depot ) ;
58827: LD_VAR 0 3
58831: PPUSH
58832: LD_VAR 0 10
58836: PPUSH
58837: CALL 67441 0 2
// end ; end ; end ;
58841: LD_VAR 0 5
58845: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58846: LD_INT 0
58848: PPUSH
58849: PPUSH
58850: PPUSH
58851: PPUSH
// if not mc_bases then
58852: LD_EXP 116
58856: NOT
58857: IFFALSE 58861
// exit ;
58859: GO 59100
// for i = 1 to mc_bases do
58861: LD_ADDR_VAR 0 2
58865: PUSH
58866: DOUBLE
58867: LD_INT 1
58869: DEC
58870: ST_TO_ADDR
58871: LD_EXP 116
58875: PUSH
58876: FOR_TO
58877: IFFALSE 59098
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58879: LD_ADDR_VAR 0 4
58883: PUSH
58884: LD_EXP 116
58888: PUSH
58889: LD_VAR 0 2
58893: ARRAY
58894: PPUSH
58895: LD_INT 21
58897: PUSH
58898: LD_INT 1
58900: PUSH
58901: EMPTY
58902: LIST
58903: LIST
58904: PPUSH
58905: CALL_OW 72
58909: PUSH
58910: LD_EXP 145
58914: PUSH
58915: LD_VAR 0 2
58919: ARRAY
58920: UNION
58921: ST_TO_ADDR
// if not tmp then
58922: LD_VAR 0 4
58926: NOT
58927: IFFALSE 58931
// continue ;
58929: GO 58876
// for j in tmp do
58931: LD_ADDR_VAR 0 3
58935: PUSH
58936: LD_VAR 0 4
58940: PUSH
58941: FOR_IN
58942: IFFALSE 59094
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58944: LD_VAR 0 3
58948: PPUSH
58949: CALL_OW 110
58953: NOT
58954: PUSH
58955: LD_VAR 0 3
58959: PPUSH
58960: CALL_OW 314
58964: NOT
58965: AND
58966: PUSH
58967: LD_VAR 0 3
58971: PPUSH
58972: CALL_OW 311
58976: NOT
58977: AND
58978: PUSH
58979: LD_VAR 0 3
58983: PPUSH
58984: CALL_OW 310
58988: NOT
58989: AND
58990: PUSH
58991: LD_VAR 0 3
58995: PUSH
58996: LD_EXP 119
59000: PUSH
59001: LD_VAR 0 2
59005: ARRAY
59006: PUSH
59007: LD_INT 1
59009: ARRAY
59010: IN
59011: NOT
59012: AND
59013: PUSH
59014: LD_VAR 0 3
59018: PUSH
59019: LD_EXP 119
59023: PUSH
59024: LD_VAR 0 2
59028: ARRAY
59029: PUSH
59030: LD_INT 2
59032: ARRAY
59033: IN
59034: NOT
59035: AND
59036: PUSH
59037: LD_VAR 0 3
59041: PUSH
59042: LD_EXP 128
59046: PUSH
59047: LD_VAR 0 2
59051: ARRAY
59052: IN
59053: NOT
59054: AND
59055: IFFALSE 59092
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
59057: LD_VAR 0 2
59061: PPUSH
59062: LD_EXP 116
59066: PUSH
59067: LD_VAR 0 2
59071: ARRAY
59072: PPUSH
59073: LD_VAR 0 3
59077: PPUSH
59078: LD_VAR 0 3
59082: PPUSH
59083: CALL_OW 257
59087: PPUSH
59088: CALL 57864 0 4
// end ;
59092: GO 58941
59094: POP
59095: POP
// end ;
59096: GO 58876
59098: POP
59099: POP
// end ;
59100: LD_VAR 0 1
59104: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
59105: LD_INT 0
59107: PPUSH
59108: PPUSH
59109: PPUSH
59110: PPUSH
59111: PPUSH
59112: PPUSH
// if not mc_bases [ base ] then
59113: LD_EXP 116
59117: PUSH
59118: LD_VAR 0 1
59122: ARRAY
59123: NOT
59124: IFFALSE 59128
// exit ;
59126: GO 59310
// tmp := [ ] ;
59128: LD_ADDR_VAR 0 6
59132: PUSH
59133: EMPTY
59134: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
59135: LD_ADDR_VAR 0 7
59139: PUSH
59140: LD_VAR 0 3
59144: PPUSH
59145: LD_INT 0
59147: PPUSH
59148: CALL_OW 517
59152: ST_TO_ADDR
// if not list then
59153: LD_VAR 0 7
59157: NOT
59158: IFFALSE 59162
// exit ;
59160: GO 59310
// for i = 1 to amount do
59162: LD_ADDR_VAR 0 5
59166: PUSH
59167: DOUBLE
59168: LD_INT 1
59170: DEC
59171: ST_TO_ADDR
59172: LD_VAR 0 2
59176: PUSH
59177: FOR_TO
59178: IFFALSE 59258
// begin x := rand ( 1 , list [ 1 ] ) ;
59180: LD_ADDR_VAR 0 8
59184: PUSH
59185: LD_INT 1
59187: PPUSH
59188: LD_VAR 0 7
59192: PUSH
59193: LD_INT 1
59195: ARRAY
59196: PPUSH
59197: CALL_OW 12
59201: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
59202: LD_ADDR_VAR 0 6
59206: PUSH
59207: LD_VAR 0 6
59211: PPUSH
59212: LD_VAR 0 5
59216: PPUSH
59217: LD_VAR 0 7
59221: PUSH
59222: LD_INT 1
59224: ARRAY
59225: PUSH
59226: LD_VAR 0 8
59230: ARRAY
59231: PUSH
59232: LD_VAR 0 7
59236: PUSH
59237: LD_INT 2
59239: ARRAY
59240: PUSH
59241: LD_VAR 0 8
59245: ARRAY
59246: PUSH
59247: EMPTY
59248: LIST
59249: LIST
59250: PPUSH
59251: CALL_OW 1
59255: ST_TO_ADDR
// end ;
59256: GO 59177
59258: POP
59259: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
59260: LD_ADDR_EXP 129
59264: PUSH
59265: LD_EXP 129
59269: PPUSH
59270: LD_VAR 0 1
59274: PPUSH
59275: LD_VAR 0 6
59279: PPUSH
59280: CALL_OW 1
59284: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
59285: LD_ADDR_EXP 131
59289: PUSH
59290: LD_EXP 131
59294: PPUSH
59295: LD_VAR 0 1
59299: PPUSH
59300: LD_VAR 0 3
59304: PPUSH
59305: CALL_OW 1
59309: ST_TO_ADDR
// end ;
59310: LD_VAR 0 4
59314: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
59315: LD_INT 0
59317: PPUSH
// if not mc_bases [ base ] then
59318: LD_EXP 116
59322: PUSH
59323: LD_VAR 0 1
59327: ARRAY
59328: NOT
59329: IFFALSE 59333
// exit ;
59331: GO 59358
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59333: LD_ADDR_EXP 121
59337: PUSH
59338: LD_EXP 121
59342: PPUSH
59343: LD_VAR 0 1
59347: PPUSH
59348: LD_VAR 0 2
59352: PPUSH
59353: CALL_OW 1
59357: ST_TO_ADDR
// end ;
59358: LD_VAR 0 3
59362: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59363: LD_INT 0
59365: PPUSH
// if not mc_bases [ base ] then
59366: LD_EXP 116
59370: PUSH
59371: LD_VAR 0 1
59375: ARRAY
59376: NOT
59377: IFFALSE 59381
// exit ;
59379: GO 59418
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59381: LD_ADDR_EXP 121
59385: PUSH
59386: LD_EXP 121
59390: PPUSH
59391: LD_VAR 0 1
59395: PPUSH
59396: LD_EXP 121
59400: PUSH
59401: LD_VAR 0 1
59405: ARRAY
59406: PUSH
59407: LD_VAR 0 2
59411: UNION
59412: PPUSH
59413: CALL_OW 1
59417: ST_TO_ADDR
// end ;
59418: LD_VAR 0 3
59422: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59423: LD_INT 0
59425: PPUSH
// if not mc_bases [ base ] then
59426: LD_EXP 116
59430: PUSH
59431: LD_VAR 0 1
59435: ARRAY
59436: NOT
59437: IFFALSE 59441
// exit ;
59439: GO 59466
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59441: LD_ADDR_EXP 137
59445: PUSH
59446: LD_EXP 137
59450: PPUSH
59451: LD_VAR 0 1
59455: PPUSH
59456: LD_VAR 0 2
59460: PPUSH
59461: CALL_OW 1
59465: ST_TO_ADDR
// end ;
59466: LD_VAR 0 3
59470: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59471: LD_INT 0
59473: PPUSH
// if not mc_bases [ base ] then
59474: LD_EXP 116
59478: PUSH
59479: LD_VAR 0 1
59483: ARRAY
59484: NOT
59485: IFFALSE 59489
// exit ;
59487: GO 59526
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59489: LD_ADDR_EXP 137
59493: PUSH
59494: LD_EXP 137
59498: PPUSH
59499: LD_VAR 0 1
59503: PPUSH
59504: LD_EXP 137
59508: PUSH
59509: LD_VAR 0 1
59513: ARRAY
59514: PUSH
59515: LD_VAR 0 2
59519: ADD
59520: PPUSH
59521: CALL_OW 1
59525: ST_TO_ADDR
// end ;
59526: LD_VAR 0 3
59530: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59531: LD_INT 0
59533: PPUSH
// if not mc_bases [ base ] then
59534: LD_EXP 116
59538: PUSH
59539: LD_VAR 0 1
59543: ARRAY
59544: NOT
59545: IFFALSE 59549
// exit ;
59547: GO 59603
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59549: LD_ADDR_EXP 138
59553: PUSH
59554: LD_EXP 138
59558: PPUSH
59559: LD_VAR 0 1
59563: PPUSH
59564: LD_VAR 0 2
59568: PPUSH
59569: CALL_OW 1
59573: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59574: LD_ADDR_EXP 127
59578: PUSH
59579: LD_EXP 127
59583: PPUSH
59584: LD_VAR 0 1
59588: PPUSH
59589: LD_VAR 0 2
59593: PUSH
59594: LD_INT 0
59596: PLUS
59597: PPUSH
59598: CALL_OW 1
59602: ST_TO_ADDR
// end ;
59603: LD_VAR 0 3
59607: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59608: LD_INT 0
59610: PPUSH
// if not mc_bases [ base ] then
59611: LD_EXP 116
59615: PUSH
59616: LD_VAR 0 1
59620: ARRAY
59621: NOT
59622: IFFALSE 59626
// exit ;
59624: GO 59651
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59626: LD_ADDR_EXP 127
59630: PUSH
59631: LD_EXP 127
59635: PPUSH
59636: LD_VAR 0 1
59640: PPUSH
59641: LD_VAR 0 2
59645: PPUSH
59646: CALL_OW 1
59650: ST_TO_ADDR
// end ;
59651: LD_VAR 0 3
59655: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59656: LD_INT 0
59658: PPUSH
59659: PPUSH
59660: PPUSH
59661: PPUSH
// if not mc_bases [ base ] then
59662: LD_EXP 116
59666: PUSH
59667: LD_VAR 0 1
59671: ARRAY
59672: NOT
59673: IFFALSE 59677
// exit ;
59675: GO 59742
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59677: LD_ADDR_EXP 136
59681: PUSH
59682: LD_EXP 136
59686: PPUSH
59687: LD_VAR 0 1
59691: PUSH
59692: LD_EXP 136
59696: PUSH
59697: LD_VAR 0 1
59701: ARRAY
59702: PUSH
59703: LD_INT 1
59705: PLUS
59706: PUSH
59707: EMPTY
59708: LIST
59709: LIST
59710: PPUSH
59711: LD_VAR 0 1
59715: PUSH
59716: LD_VAR 0 2
59720: PUSH
59721: LD_VAR 0 3
59725: PUSH
59726: LD_VAR 0 4
59730: PUSH
59731: EMPTY
59732: LIST
59733: LIST
59734: LIST
59735: LIST
59736: PPUSH
59737: CALL 70863 0 3
59741: ST_TO_ADDR
// end ;
59742: LD_VAR 0 5
59746: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59747: LD_INT 0
59749: PPUSH
// if not mc_bases [ base ] then
59750: LD_EXP 116
59754: PUSH
59755: LD_VAR 0 1
59759: ARRAY
59760: NOT
59761: IFFALSE 59765
// exit ;
59763: GO 59790
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59765: LD_ADDR_EXP 153
59769: PUSH
59770: LD_EXP 153
59774: PPUSH
59775: LD_VAR 0 1
59779: PPUSH
59780: LD_VAR 0 2
59784: PPUSH
59785: CALL_OW 1
59789: ST_TO_ADDR
// end ;
59790: LD_VAR 0 3
59794: RET
// export function MC_GetMinesField ( base ) ; begin
59795: LD_INT 0
59797: PPUSH
// result := mc_mines [ base ] ;
59798: LD_ADDR_VAR 0 2
59802: PUSH
59803: LD_EXP 129
59807: PUSH
59808: LD_VAR 0 1
59812: ARRAY
59813: ST_TO_ADDR
// end ;
59814: LD_VAR 0 2
59818: RET
// export function MC_GetProduceList ( base ) ; begin
59819: LD_INT 0
59821: PPUSH
// result := mc_produce [ base ] ;
59822: LD_ADDR_VAR 0 2
59826: PUSH
59827: LD_EXP 137
59831: PUSH
59832: LD_VAR 0 1
59836: ARRAY
59837: ST_TO_ADDR
// end ;
59838: LD_VAR 0 2
59842: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59843: LD_INT 0
59845: PPUSH
59846: PPUSH
// if not mc_bases then
59847: LD_EXP 116
59851: NOT
59852: IFFALSE 59856
// exit ;
59854: GO 59921
// if mc_bases [ base ] then
59856: LD_EXP 116
59860: PUSH
59861: LD_VAR 0 1
59865: ARRAY
59866: IFFALSE 59921
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59868: LD_ADDR_VAR 0 3
59872: PUSH
59873: LD_EXP 116
59877: PUSH
59878: LD_VAR 0 1
59882: ARRAY
59883: PPUSH
59884: LD_INT 30
59886: PUSH
59887: LD_VAR 0 2
59891: PUSH
59892: EMPTY
59893: LIST
59894: LIST
59895: PPUSH
59896: CALL_OW 72
59900: ST_TO_ADDR
// if result then
59901: LD_VAR 0 3
59905: IFFALSE 59921
// result := result [ 1 ] ;
59907: LD_ADDR_VAR 0 3
59911: PUSH
59912: LD_VAR 0 3
59916: PUSH
59917: LD_INT 1
59919: ARRAY
59920: ST_TO_ADDR
// end ; end ;
59921: LD_VAR 0 3
59925: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59926: LD_INT 0
59928: PPUSH
59929: PPUSH
// if not mc_bases then
59930: LD_EXP 116
59934: NOT
59935: IFFALSE 59939
// exit ;
59937: GO 59984
// if mc_bases [ base ] then
59939: LD_EXP 116
59943: PUSH
59944: LD_VAR 0 1
59948: ARRAY
59949: IFFALSE 59984
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59951: LD_ADDR_VAR 0 3
59955: PUSH
59956: LD_EXP 116
59960: PUSH
59961: LD_VAR 0 1
59965: ARRAY
59966: PPUSH
59967: LD_INT 30
59969: PUSH
59970: LD_VAR 0 2
59974: PUSH
59975: EMPTY
59976: LIST
59977: LIST
59978: PPUSH
59979: CALL_OW 72
59983: ST_TO_ADDR
// end ;
59984: LD_VAR 0 3
59988: RET
// export function MC_SetTame ( base , area ) ; begin
59989: LD_INT 0
59991: PPUSH
// if not mc_bases or not base then
59992: LD_EXP 116
59996: NOT
59997: PUSH
59998: LD_VAR 0 1
60002: NOT
60003: OR
60004: IFFALSE 60008
// exit ;
60006: GO 60033
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
60008: LD_ADDR_EXP 144
60012: PUSH
60013: LD_EXP 144
60017: PPUSH
60018: LD_VAR 0 1
60022: PPUSH
60023: LD_VAR 0 2
60027: PPUSH
60028: CALL_OW 1
60032: ST_TO_ADDR
// end ;
60033: LD_VAR 0 3
60037: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
60038: LD_INT 0
60040: PPUSH
60041: PPUSH
// if not mc_bases or not base then
60042: LD_EXP 116
60046: NOT
60047: PUSH
60048: LD_VAR 0 1
60052: NOT
60053: OR
60054: IFFALSE 60058
// exit ;
60056: GO 60160
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
60058: LD_ADDR_VAR 0 4
60062: PUSH
60063: LD_EXP 116
60067: PUSH
60068: LD_VAR 0 1
60072: ARRAY
60073: PPUSH
60074: LD_INT 30
60076: PUSH
60077: LD_VAR 0 2
60081: PUSH
60082: EMPTY
60083: LIST
60084: LIST
60085: PPUSH
60086: CALL_OW 72
60090: ST_TO_ADDR
// if not tmp then
60091: LD_VAR 0 4
60095: NOT
60096: IFFALSE 60100
// exit ;
60098: GO 60160
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
60100: LD_ADDR_EXP 148
60104: PUSH
60105: LD_EXP 148
60109: PPUSH
60110: LD_VAR 0 1
60114: PPUSH
60115: LD_EXP 148
60119: PUSH
60120: LD_VAR 0 1
60124: ARRAY
60125: PPUSH
60126: LD_EXP 148
60130: PUSH
60131: LD_VAR 0 1
60135: ARRAY
60136: PUSH
60137: LD_INT 1
60139: PLUS
60140: PPUSH
60141: LD_VAR 0 4
60145: PUSH
60146: LD_INT 1
60148: ARRAY
60149: PPUSH
60150: CALL_OW 2
60154: PPUSH
60155: CALL_OW 1
60159: ST_TO_ADDR
// end ;
60160: LD_VAR 0 3
60164: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
60165: LD_INT 0
60167: PPUSH
60168: PPUSH
// if not mc_bases or not base or not kinds then
60169: LD_EXP 116
60173: NOT
60174: PUSH
60175: LD_VAR 0 1
60179: NOT
60180: OR
60181: PUSH
60182: LD_VAR 0 2
60186: NOT
60187: OR
60188: IFFALSE 60192
// exit ;
60190: GO 60253
// for i in kinds do
60192: LD_ADDR_VAR 0 4
60196: PUSH
60197: LD_VAR 0 2
60201: PUSH
60202: FOR_IN
60203: IFFALSE 60251
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
60205: LD_ADDR_EXP 150
60209: PUSH
60210: LD_EXP 150
60214: PPUSH
60215: LD_VAR 0 1
60219: PUSH
60220: LD_EXP 150
60224: PUSH
60225: LD_VAR 0 1
60229: ARRAY
60230: PUSH
60231: LD_INT 1
60233: PLUS
60234: PUSH
60235: EMPTY
60236: LIST
60237: LIST
60238: PPUSH
60239: LD_VAR 0 4
60243: PPUSH
60244: CALL 70863 0 3
60248: ST_TO_ADDR
60249: GO 60202
60251: POP
60252: POP
// end ;
60253: LD_VAR 0 3
60257: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
60258: LD_INT 0
60260: PPUSH
// if not mc_bases or not base or not areas then
60261: LD_EXP 116
60265: NOT
60266: PUSH
60267: LD_VAR 0 1
60271: NOT
60272: OR
60273: PUSH
60274: LD_VAR 0 2
60278: NOT
60279: OR
60280: IFFALSE 60284
// exit ;
60282: GO 60309
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
60284: LD_ADDR_EXP 134
60288: PUSH
60289: LD_EXP 134
60293: PPUSH
60294: LD_VAR 0 1
60298: PPUSH
60299: LD_VAR 0 2
60303: PPUSH
60304: CALL_OW 1
60308: ST_TO_ADDR
// end ;
60309: LD_VAR 0 3
60313: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
60314: LD_INT 0
60316: PPUSH
// if not mc_bases or not base or not teleports_exit then
60317: LD_EXP 116
60321: NOT
60322: PUSH
60323: LD_VAR 0 1
60327: NOT
60328: OR
60329: PUSH
60330: LD_VAR 0 2
60334: NOT
60335: OR
60336: IFFALSE 60340
// exit ;
60338: GO 60365
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60340: LD_ADDR_EXP 151
60344: PUSH
60345: LD_EXP 151
60349: PPUSH
60350: LD_VAR 0 1
60354: PPUSH
60355: LD_VAR 0 2
60359: PPUSH
60360: CALL_OW 1
60364: ST_TO_ADDR
// end ;
60365: LD_VAR 0 3
60369: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60370: LD_INT 0
60372: PPUSH
60373: PPUSH
60374: PPUSH
// if not mc_bases or not base or not ext_list then
60375: LD_EXP 116
60379: NOT
60380: PUSH
60381: LD_VAR 0 1
60385: NOT
60386: OR
60387: PUSH
60388: LD_VAR 0 5
60392: NOT
60393: OR
60394: IFFALSE 60398
// exit ;
60396: GO 60571
// tmp := GetFacExtXYD ( x , y , d ) ;
60398: LD_ADDR_VAR 0 8
60402: PUSH
60403: LD_VAR 0 2
60407: PPUSH
60408: LD_VAR 0 3
60412: PPUSH
60413: LD_VAR 0 4
60417: PPUSH
60418: CALL 100250 0 3
60422: ST_TO_ADDR
// if not tmp then
60423: LD_VAR 0 8
60427: NOT
60428: IFFALSE 60432
// exit ;
60430: GO 60571
// for i in tmp do
60432: LD_ADDR_VAR 0 7
60436: PUSH
60437: LD_VAR 0 8
60441: PUSH
60442: FOR_IN
60443: IFFALSE 60569
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60445: LD_ADDR_EXP 121
60449: PUSH
60450: LD_EXP 121
60454: PPUSH
60455: LD_VAR 0 1
60459: PPUSH
60460: LD_EXP 121
60464: PUSH
60465: LD_VAR 0 1
60469: ARRAY
60470: PPUSH
60471: LD_EXP 121
60475: PUSH
60476: LD_VAR 0 1
60480: ARRAY
60481: PUSH
60482: LD_INT 1
60484: PLUS
60485: PPUSH
60486: LD_VAR 0 5
60490: PUSH
60491: LD_INT 1
60493: ARRAY
60494: PUSH
60495: LD_VAR 0 7
60499: PUSH
60500: LD_INT 1
60502: ARRAY
60503: PUSH
60504: LD_VAR 0 7
60508: PUSH
60509: LD_INT 2
60511: ARRAY
60512: PUSH
60513: LD_VAR 0 7
60517: PUSH
60518: LD_INT 3
60520: ARRAY
60521: PUSH
60522: EMPTY
60523: LIST
60524: LIST
60525: LIST
60526: LIST
60527: PPUSH
60528: CALL_OW 2
60532: PPUSH
60533: CALL_OW 1
60537: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60538: LD_ADDR_VAR 0 5
60542: PUSH
60543: LD_VAR 0 5
60547: PPUSH
60548: LD_INT 1
60550: PPUSH
60551: CALL_OW 3
60555: ST_TO_ADDR
// if not ext_list then
60556: LD_VAR 0 5
60560: NOT
60561: IFFALSE 60567
// exit ;
60563: POP
60564: POP
60565: GO 60571
// end ;
60567: GO 60442
60569: POP
60570: POP
// end ;
60571: LD_VAR 0 6
60575: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60576: LD_INT 0
60578: PPUSH
// if not mc_bases or not base or not weapon_list then
60579: LD_EXP 116
60583: NOT
60584: PUSH
60585: LD_VAR 0 1
60589: NOT
60590: OR
60591: PUSH
60592: LD_VAR 0 2
60596: NOT
60597: OR
60598: IFFALSE 60602
// exit ;
60600: GO 60627
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60602: LD_ADDR_EXP 155
60606: PUSH
60607: LD_EXP 155
60611: PPUSH
60612: LD_VAR 0 1
60616: PPUSH
60617: LD_VAR 0 2
60621: PPUSH
60622: CALL_OW 1
60626: ST_TO_ADDR
// end ;
60627: LD_VAR 0 3
60631: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60632: LD_INT 0
60634: PPUSH
// if not mc_bases or not base or not tech_list then
60635: LD_EXP 116
60639: NOT
60640: PUSH
60641: LD_VAR 0 1
60645: NOT
60646: OR
60647: PUSH
60648: LD_VAR 0 2
60652: NOT
60653: OR
60654: IFFALSE 60658
// exit ;
60656: GO 60683
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60658: LD_ADDR_EXP 143
60662: PUSH
60663: LD_EXP 143
60667: PPUSH
60668: LD_VAR 0 1
60672: PPUSH
60673: LD_VAR 0 2
60677: PPUSH
60678: CALL_OW 1
60682: ST_TO_ADDR
// end ;
60683: LD_VAR 0 3
60687: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60688: LD_INT 0
60690: PPUSH
// if not mc_bases or not parking_area or not base then
60691: LD_EXP 116
60695: NOT
60696: PUSH
60697: LD_VAR 0 2
60701: NOT
60702: OR
60703: PUSH
60704: LD_VAR 0 1
60708: NOT
60709: OR
60710: IFFALSE 60714
// exit ;
60712: GO 60739
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60714: LD_ADDR_EXP 140
60718: PUSH
60719: LD_EXP 140
60723: PPUSH
60724: LD_VAR 0 1
60728: PPUSH
60729: LD_VAR 0 2
60733: PPUSH
60734: CALL_OW 1
60738: ST_TO_ADDR
// end ;
60739: LD_VAR 0 3
60743: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60744: LD_INT 0
60746: PPUSH
// if not mc_bases or not base or not scan_area then
60747: LD_EXP 116
60751: NOT
60752: PUSH
60753: LD_VAR 0 1
60757: NOT
60758: OR
60759: PUSH
60760: LD_VAR 0 2
60764: NOT
60765: OR
60766: IFFALSE 60770
// exit ;
60768: GO 60795
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60770: LD_ADDR_EXP 141
60774: PUSH
60775: LD_EXP 141
60779: PPUSH
60780: LD_VAR 0 1
60784: PPUSH
60785: LD_VAR 0 2
60789: PPUSH
60790: CALL_OW 1
60794: ST_TO_ADDR
// end ;
60795: LD_VAR 0 3
60799: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60800: LD_INT 0
60802: PPUSH
60803: PPUSH
// if not mc_bases or not base then
60804: LD_EXP 116
60808: NOT
60809: PUSH
60810: LD_VAR 0 1
60814: NOT
60815: OR
60816: IFFALSE 60820
// exit ;
60818: GO 60884
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60820: LD_ADDR_VAR 0 3
60824: PUSH
60825: LD_INT 1
60827: PUSH
60828: LD_INT 2
60830: PUSH
60831: LD_INT 3
60833: PUSH
60834: LD_INT 4
60836: PUSH
60837: LD_INT 11
60839: PUSH
60840: EMPTY
60841: LIST
60842: LIST
60843: LIST
60844: LIST
60845: LIST
60846: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60847: LD_ADDR_EXP 143
60851: PUSH
60852: LD_EXP 143
60856: PPUSH
60857: LD_VAR 0 1
60861: PPUSH
60862: LD_EXP 143
60866: PUSH
60867: LD_VAR 0 1
60871: ARRAY
60872: PUSH
60873: LD_VAR 0 3
60877: DIFF
60878: PPUSH
60879: CALL_OW 1
60883: ST_TO_ADDR
// end ;
60884: LD_VAR 0 2
60888: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60889: LD_INT 0
60891: PPUSH
// result := mc_vehicles [ base ] ;
60892: LD_ADDR_VAR 0 3
60896: PUSH
60897: LD_EXP 135
60901: PUSH
60902: LD_VAR 0 1
60906: ARRAY
60907: ST_TO_ADDR
// if onlyCombat then
60908: LD_VAR 0 2
60912: IFFALSE 61090
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60914: LD_ADDR_VAR 0 3
60918: PUSH
60919: LD_VAR 0 3
60923: PUSH
60924: LD_VAR 0 3
60928: PPUSH
60929: LD_INT 2
60931: PUSH
60932: LD_INT 34
60934: PUSH
60935: LD_INT 12
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: LD_INT 34
60944: PUSH
60945: LD_INT 51
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: LD_INT 34
60954: PUSH
60955: LD_EXP 96
60959: PUSH
60960: EMPTY
60961: LIST
60962: LIST
60963: PUSH
60964: LD_INT 34
60966: PUSH
60967: LD_INT 32
60969: PUSH
60970: EMPTY
60971: LIST
60972: LIST
60973: PUSH
60974: LD_INT 34
60976: PUSH
60977: LD_INT 13
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: PUSH
60984: LD_INT 34
60986: PUSH
60987: LD_INT 52
60989: PUSH
60990: EMPTY
60991: LIST
60992: LIST
60993: PUSH
60994: LD_INT 34
60996: PUSH
60997: LD_EXP 101
61001: PUSH
61002: EMPTY
61003: LIST
61004: LIST
61005: PUSH
61006: LD_INT 34
61008: PUSH
61009: LD_INT 14
61011: PUSH
61012: EMPTY
61013: LIST
61014: LIST
61015: PUSH
61016: LD_INT 34
61018: PUSH
61019: LD_INT 53
61021: PUSH
61022: EMPTY
61023: LIST
61024: LIST
61025: PUSH
61026: LD_INT 34
61028: PUSH
61029: LD_EXP 95
61033: PUSH
61034: EMPTY
61035: LIST
61036: LIST
61037: PUSH
61038: LD_INT 34
61040: PUSH
61041: LD_INT 31
61043: PUSH
61044: EMPTY
61045: LIST
61046: LIST
61047: PUSH
61048: LD_INT 34
61050: PUSH
61051: LD_INT 48
61053: PUSH
61054: EMPTY
61055: LIST
61056: LIST
61057: PUSH
61058: LD_INT 34
61060: PUSH
61061: LD_INT 8
61063: PUSH
61064: EMPTY
61065: LIST
61066: LIST
61067: PUSH
61068: EMPTY
61069: LIST
61070: LIST
61071: LIST
61072: LIST
61073: LIST
61074: LIST
61075: LIST
61076: LIST
61077: LIST
61078: LIST
61079: LIST
61080: LIST
61081: LIST
61082: LIST
61083: PPUSH
61084: CALL_OW 72
61088: DIFF
61089: ST_TO_ADDR
// end ; end_of_file
61090: LD_VAR 0 3
61094: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
61095: LD_INT 0
61097: PPUSH
61098: PPUSH
61099: PPUSH
// if not mc_bases or not skirmish then
61100: LD_EXP 116
61104: NOT
61105: PUSH
61106: LD_EXP 114
61110: NOT
61111: OR
61112: IFFALSE 61116
// exit ;
61114: GO 61281
// for i = 1 to mc_bases do
61116: LD_ADDR_VAR 0 4
61120: PUSH
61121: DOUBLE
61122: LD_INT 1
61124: DEC
61125: ST_TO_ADDR
61126: LD_EXP 116
61130: PUSH
61131: FOR_TO
61132: IFFALSE 61279
// begin if sci in mc_bases [ i ] then
61134: LD_VAR 0 2
61138: PUSH
61139: LD_EXP 116
61143: PUSH
61144: LD_VAR 0 4
61148: ARRAY
61149: IN
61150: IFFALSE 61277
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
61152: LD_ADDR_EXP 145
61156: PUSH
61157: LD_EXP 145
61161: PPUSH
61162: LD_VAR 0 4
61166: PUSH
61167: LD_EXP 145
61171: PUSH
61172: LD_VAR 0 4
61176: ARRAY
61177: PUSH
61178: LD_INT 1
61180: PLUS
61181: PUSH
61182: EMPTY
61183: LIST
61184: LIST
61185: PPUSH
61186: LD_VAR 0 1
61190: PPUSH
61191: CALL 70863 0 3
61195: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
61196: LD_ADDR_VAR 0 5
61200: PUSH
61201: LD_EXP 116
61205: PUSH
61206: LD_VAR 0 4
61210: ARRAY
61211: PPUSH
61212: LD_INT 2
61214: PUSH
61215: LD_INT 30
61217: PUSH
61218: LD_INT 0
61220: PUSH
61221: EMPTY
61222: LIST
61223: LIST
61224: PUSH
61225: LD_INT 30
61227: PUSH
61228: LD_INT 1
61230: PUSH
61231: EMPTY
61232: LIST
61233: LIST
61234: PUSH
61235: EMPTY
61236: LIST
61237: LIST
61238: LIST
61239: PPUSH
61240: CALL_OW 72
61244: PPUSH
61245: LD_VAR 0 1
61249: PPUSH
61250: CALL_OW 74
61254: ST_TO_ADDR
// if tmp then
61255: LD_VAR 0 5
61259: IFFALSE 61275
// ComStandNearbyBuilding ( ape , tmp ) ;
61261: LD_VAR 0 1
61265: PPUSH
61266: LD_VAR 0 5
61270: PPUSH
61271: CALL 67441 0 2
// break ;
61275: GO 61279
// end ; end ;
61277: GO 61131
61279: POP
61280: POP
// end ;
61281: LD_VAR 0 3
61285: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
61286: LD_INT 0
61288: PPUSH
61289: PPUSH
61290: PPUSH
// if not mc_bases or not skirmish then
61291: LD_EXP 116
61295: NOT
61296: PUSH
61297: LD_EXP 114
61301: NOT
61302: OR
61303: IFFALSE 61307
// exit ;
61305: GO 61396
// for i = 1 to mc_bases do
61307: LD_ADDR_VAR 0 4
61311: PUSH
61312: DOUBLE
61313: LD_INT 1
61315: DEC
61316: ST_TO_ADDR
61317: LD_EXP 116
61321: PUSH
61322: FOR_TO
61323: IFFALSE 61394
// begin if building in mc_busy_turret_list [ i ] then
61325: LD_VAR 0 1
61329: PUSH
61330: LD_EXP 126
61334: PUSH
61335: LD_VAR 0 4
61339: ARRAY
61340: IN
61341: IFFALSE 61392
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61343: LD_ADDR_VAR 0 5
61347: PUSH
61348: LD_EXP 126
61352: PUSH
61353: LD_VAR 0 4
61357: ARRAY
61358: PUSH
61359: LD_VAR 0 1
61363: DIFF
61364: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61365: LD_ADDR_EXP 126
61369: PUSH
61370: LD_EXP 126
61374: PPUSH
61375: LD_VAR 0 4
61379: PPUSH
61380: LD_VAR 0 5
61384: PPUSH
61385: CALL_OW 1
61389: ST_TO_ADDR
// break ;
61390: GO 61394
// end ; end ;
61392: GO 61322
61394: POP
61395: POP
// end ;
61396: LD_VAR 0 3
61400: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61401: LD_INT 0
61403: PPUSH
61404: PPUSH
61405: PPUSH
// if not mc_bases or not skirmish then
61406: LD_EXP 116
61410: NOT
61411: PUSH
61412: LD_EXP 114
61416: NOT
61417: OR
61418: IFFALSE 61422
// exit ;
61420: GO 61621
// for i = 1 to mc_bases do
61422: LD_ADDR_VAR 0 5
61426: PUSH
61427: DOUBLE
61428: LD_INT 1
61430: DEC
61431: ST_TO_ADDR
61432: LD_EXP 116
61436: PUSH
61437: FOR_TO
61438: IFFALSE 61619
// if building in mc_bases [ i ] then
61440: LD_VAR 0 1
61444: PUSH
61445: LD_EXP 116
61449: PUSH
61450: LD_VAR 0 5
61454: ARRAY
61455: IN
61456: IFFALSE 61617
// begin tmp := mc_bases [ i ] diff building ;
61458: LD_ADDR_VAR 0 6
61462: PUSH
61463: LD_EXP 116
61467: PUSH
61468: LD_VAR 0 5
61472: ARRAY
61473: PUSH
61474: LD_VAR 0 1
61478: DIFF
61479: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61480: LD_ADDR_EXP 116
61484: PUSH
61485: LD_EXP 116
61489: PPUSH
61490: LD_VAR 0 5
61494: PPUSH
61495: LD_VAR 0 6
61499: PPUSH
61500: CALL_OW 1
61504: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61505: LD_VAR 0 1
61509: PUSH
61510: LD_EXP 124
61514: PUSH
61515: LD_VAR 0 5
61519: ARRAY
61520: IN
61521: IFFALSE 61560
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61523: LD_ADDR_EXP 124
61527: PUSH
61528: LD_EXP 124
61532: PPUSH
61533: LD_VAR 0 5
61537: PPUSH
61538: LD_EXP 124
61542: PUSH
61543: LD_VAR 0 5
61547: ARRAY
61548: PUSH
61549: LD_VAR 0 1
61553: DIFF
61554: PPUSH
61555: CALL_OW 1
61559: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61560: LD_VAR 0 1
61564: PUSH
61565: LD_EXP 125
61569: PUSH
61570: LD_VAR 0 5
61574: ARRAY
61575: IN
61576: IFFALSE 61615
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61578: LD_ADDR_EXP 125
61582: PUSH
61583: LD_EXP 125
61587: PPUSH
61588: LD_VAR 0 5
61592: PPUSH
61593: LD_EXP 125
61597: PUSH
61598: LD_VAR 0 5
61602: ARRAY
61603: PUSH
61604: LD_VAR 0 1
61608: DIFF
61609: PPUSH
61610: CALL_OW 1
61614: ST_TO_ADDR
// break ;
61615: GO 61619
// end ;
61617: GO 61437
61619: POP
61620: POP
// end ;
61621: LD_VAR 0 4
61625: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61626: LD_INT 0
61628: PPUSH
61629: PPUSH
61630: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61631: LD_EXP 116
61635: NOT
61636: PUSH
61637: LD_EXP 114
61641: NOT
61642: OR
61643: PUSH
61644: LD_VAR 0 3
61648: PUSH
61649: LD_EXP 142
61653: IN
61654: NOT
61655: OR
61656: IFFALSE 61660
// exit ;
61658: GO 61783
// for i = 1 to mc_vehicles do
61660: LD_ADDR_VAR 0 6
61664: PUSH
61665: DOUBLE
61666: LD_INT 1
61668: DEC
61669: ST_TO_ADDR
61670: LD_EXP 135
61674: PUSH
61675: FOR_TO
61676: IFFALSE 61781
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61678: LD_VAR 0 2
61682: PUSH
61683: LD_EXP 135
61687: PUSH
61688: LD_VAR 0 6
61692: ARRAY
61693: IN
61694: PUSH
61695: LD_VAR 0 1
61699: PUSH
61700: LD_EXP 135
61704: PUSH
61705: LD_VAR 0 6
61709: ARRAY
61710: IN
61711: OR
61712: IFFALSE 61779
// begin tmp := mc_vehicles [ i ] diff old ;
61714: LD_ADDR_VAR 0 7
61718: PUSH
61719: LD_EXP 135
61723: PUSH
61724: LD_VAR 0 6
61728: ARRAY
61729: PUSH
61730: LD_VAR 0 2
61734: DIFF
61735: ST_TO_ADDR
// tmp := tmp diff new ;
61736: LD_ADDR_VAR 0 7
61740: PUSH
61741: LD_VAR 0 7
61745: PUSH
61746: LD_VAR 0 1
61750: DIFF
61751: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61752: LD_ADDR_EXP 135
61756: PUSH
61757: LD_EXP 135
61761: PPUSH
61762: LD_VAR 0 6
61766: PPUSH
61767: LD_VAR 0 7
61771: PPUSH
61772: CALL_OW 1
61776: ST_TO_ADDR
// break ;
61777: GO 61781
// end ;
61779: GO 61675
61781: POP
61782: POP
// end ;
61783: LD_VAR 0 5
61787: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61788: LD_INT 0
61790: PPUSH
61791: PPUSH
61792: PPUSH
61793: PPUSH
// if not mc_bases or not skirmish then
61794: LD_EXP 116
61798: NOT
61799: PUSH
61800: LD_EXP 114
61804: NOT
61805: OR
61806: IFFALSE 61810
// exit ;
61808: GO 62202
// side := GetSide ( vehicle ) ;
61810: LD_ADDR_VAR 0 5
61814: PUSH
61815: LD_VAR 0 1
61819: PPUSH
61820: CALL_OW 255
61824: ST_TO_ADDR
// for i = 1 to mc_bases do
61825: LD_ADDR_VAR 0 4
61829: PUSH
61830: DOUBLE
61831: LD_INT 1
61833: DEC
61834: ST_TO_ADDR
61835: LD_EXP 116
61839: PUSH
61840: FOR_TO
61841: IFFALSE 62200
// begin if factory in mc_bases [ i ] then
61843: LD_VAR 0 2
61847: PUSH
61848: LD_EXP 116
61852: PUSH
61853: LD_VAR 0 4
61857: ARRAY
61858: IN
61859: IFFALSE 62198
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61861: LD_EXP 138
61865: PUSH
61866: LD_VAR 0 4
61870: ARRAY
61871: PUSH
61872: LD_EXP 127
61876: PUSH
61877: LD_VAR 0 4
61881: ARRAY
61882: LESS
61883: PUSH
61884: LD_VAR 0 1
61888: PPUSH
61889: CALL_OW 264
61893: PUSH
61894: LD_INT 31
61896: PUSH
61897: LD_INT 32
61899: PUSH
61900: LD_INT 51
61902: PUSH
61903: LD_EXP 96
61907: PUSH
61908: LD_INT 12
61910: PUSH
61911: LD_INT 30
61913: PUSH
61914: LD_EXP 95
61918: PUSH
61919: LD_INT 11
61921: PUSH
61922: LD_INT 53
61924: PUSH
61925: LD_INT 14
61927: PUSH
61928: LD_EXP 99
61932: PUSH
61933: LD_INT 29
61935: PUSH
61936: LD_EXP 97
61940: PUSH
61941: LD_INT 13
61943: PUSH
61944: LD_INT 52
61946: PUSH
61947: LD_EXP 101
61951: PUSH
61952: LD_INT 48
61954: PUSH
61955: LD_INT 8
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: LIST
61962: LIST
61963: LIST
61964: LIST
61965: LIST
61966: LIST
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: LIST
61976: LIST
61977: IN
61978: NOT
61979: AND
61980: IFFALSE 62028
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61982: LD_ADDR_EXP 138
61986: PUSH
61987: LD_EXP 138
61991: PPUSH
61992: LD_VAR 0 4
61996: PUSH
61997: LD_EXP 138
62001: PUSH
62002: LD_VAR 0 4
62006: ARRAY
62007: PUSH
62008: LD_INT 1
62010: PLUS
62011: PUSH
62012: EMPTY
62013: LIST
62014: LIST
62015: PPUSH
62016: LD_VAR 0 1
62020: PPUSH
62021: CALL 70863 0 3
62025: ST_TO_ADDR
62026: GO 62072
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
62028: LD_ADDR_EXP 135
62032: PUSH
62033: LD_EXP 135
62037: PPUSH
62038: LD_VAR 0 4
62042: PUSH
62043: LD_EXP 135
62047: PUSH
62048: LD_VAR 0 4
62052: ARRAY
62053: PUSH
62054: LD_INT 1
62056: PLUS
62057: PUSH
62058: EMPTY
62059: LIST
62060: LIST
62061: PPUSH
62062: LD_VAR 0 1
62066: PPUSH
62067: CALL 70863 0 3
62071: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
62072: LD_VAR 0 1
62076: PPUSH
62077: CALL_OW 263
62081: PUSH
62082: LD_INT 2
62084: EQUAL
62085: IFFALSE 62114
// begin repeat wait ( 0 0$3 ) ;
62087: LD_INT 105
62089: PPUSH
62090: CALL_OW 67
// Connect ( vehicle ) ;
62094: LD_VAR 0 1
62098: PPUSH
62099: CALL 73834 0 1
// until IsControledBy ( vehicle ) ;
62103: LD_VAR 0 1
62107: PPUSH
62108: CALL_OW 312
62112: IFFALSE 62087
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
62114: LD_VAR 0 1
62118: PPUSH
62119: LD_EXP 140
62123: PUSH
62124: LD_VAR 0 4
62128: ARRAY
62129: PPUSH
62130: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
62134: LD_VAR 0 1
62138: PPUSH
62139: CALL_OW 263
62143: PUSH
62144: LD_INT 1
62146: NONEQUAL
62147: IFFALSE 62151
// break ;
62149: GO 62200
// repeat wait ( 0 0$1 ) ;
62151: LD_INT 35
62153: PPUSH
62154: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
62158: LD_VAR 0 1
62162: PPUSH
62163: LD_EXP 140
62167: PUSH
62168: LD_VAR 0 4
62172: ARRAY
62173: PPUSH
62174: CALL_OW 308
62178: IFFALSE 62151
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
62180: LD_VAR 0 1
62184: PPUSH
62185: CALL_OW 311
62189: PPUSH
62190: CALL_OW 121
// exit ;
62194: POP
62195: POP
62196: GO 62202
// end ; end ;
62198: GO 61840
62200: POP
62201: POP
// end ;
62202: LD_VAR 0 3
62206: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
62207: LD_INT 0
62209: PPUSH
62210: PPUSH
62211: PPUSH
62212: PPUSH
// if not mc_bases or not skirmish then
62213: LD_EXP 116
62217: NOT
62218: PUSH
62219: LD_EXP 114
62223: NOT
62224: OR
62225: IFFALSE 62229
// exit ;
62227: GO 62582
// repeat wait ( 0 0$1 ) ;
62229: LD_INT 35
62231: PPUSH
62232: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
62236: LD_VAR 0 2
62240: PPUSH
62241: LD_VAR 0 3
62245: PPUSH
62246: CALL_OW 284
62250: IFFALSE 62229
// if GetResourceTypeXY ( x , y ) = mat_artefact then
62252: LD_VAR 0 2
62256: PPUSH
62257: LD_VAR 0 3
62261: PPUSH
62262: CALL_OW 283
62266: PUSH
62267: LD_INT 4
62269: EQUAL
62270: IFFALSE 62274
// exit ;
62272: GO 62582
// for i = 1 to mc_bases do
62274: LD_ADDR_VAR 0 7
62278: PUSH
62279: DOUBLE
62280: LD_INT 1
62282: DEC
62283: ST_TO_ADDR
62284: LD_EXP 116
62288: PUSH
62289: FOR_TO
62290: IFFALSE 62580
// begin if mc_crates_area [ i ] then
62292: LD_EXP 134
62296: PUSH
62297: LD_VAR 0 7
62301: ARRAY
62302: IFFALSE 62413
// for j in mc_crates_area [ i ] do
62304: LD_ADDR_VAR 0 8
62308: PUSH
62309: LD_EXP 134
62313: PUSH
62314: LD_VAR 0 7
62318: ARRAY
62319: PUSH
62320: FOR_IN
62321: IFFALSE 62411
// if InArea ( x , y , j ) then
62323: LD_VAR 0 2
62327: PPUSH
62328: LD_VAR 0 3
62332: PPUSH
62333: LD_VAR 0 8
62337: PPUSH
62338: CALL_OW 309
62342: IFFALSE 62409
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62344: LD_ADDR_EXP 132
62348: PUSH
62349: LD_EXP 132
62353: PPUSH
62354: LD_VAR 0 7
62358: PUSH
62359: LD_EXP 132
62363: PUSH
62364: LD_VAR 0 7
62368: ARRAY
62369: PUSH
62370: LD_INT 1
62372: PLUS
62373: PUSH
62374: EMPTY
62375: LIST
62376: LIST
62377: PPUSH
62378: LD_VAR 0 4
62382: PUSH
62383: LD_VAR 0 2
62387: PUSH
62388: LD_VAR 0 3
62392: PUSH
62393: EMPTY
62394: LIST
62395: LIST
62396: LIST
62397: PPUSH
62398: CALL 70863 0 3
62402: ST_TO_ADDR
// exit ;
62403: POP
62404: POP
62405: POP
62406: POP
62407: GO 62582
// end ;
62409: GO 62320
62411: POP
62412: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62413: LD_ADDR_VAR 0 9
62417: PUSH
62418: LD_EXP 116
62422: PUSH
62423: LD_VAR 0 7
62427: ARRAY
62428: PPUSH
62429: LD_INT 2
62431: PUSH
62432: LD_INT 30
62434: PUSH
62435: LD_INT 0
62437: PUSH
62438: EMPTY
62439: LIST
62440: LIST
62441: PUSH
62442: LD_INT 30
62444: PUSH
62445: LD_INT 1
62447: PUSH
62448: EMPTY
62449: LIST
62450: LIST
62451: PUSH
62452: EMPTY
62453: LIST
62454: LIST
62455: LIST
62456: PPUSH
62457: CALL_OW 72
62461: ST_TO_ADDR
// if not depot then
62462: LD_VAR 0 9
62466: NOT
62467: IFFALSE 62471
// continue ;
62469: GO 62289
// for j in depot do
62471: LD_ADDR_VAR 0 8
62475: PUSH
62476: LD_VAR 0 9
62480: PUSH
62481: FOR_IN
62482: IFFALSE 62576
// if GetDistUnitXY ( j , x , y ) < 30 then
62484: LD_VAR 0 8
62488: PPUSH
62489: LD_VAR 0 2
62493: PPUSH
62494: LD_VAR 0 3
62498: PPUSH
62499: CALL_OW 297
62503: PUSH
62504: LD_INT 30
62506: LESS
62507: IFFALSE 62574
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62509: LD_ADDR_EXP 132
62513: PUSH
62514: LD_EXP 132
62518: PPUSH
62519: LD_VAR 0 7
62523: PUSH
62524: LD_EXP 132
62528: PUSH
62529: LD_VAR 0 7
62533: ARRAY
62534: PUSH
62535: LD_INT 1
62537: PLUS
62538: PUSH
62539: EMPTY
62540: LIST
62541: LIST
62542: PPUSH
62543: LD_VAR 0 4
62547: PUSH
62548: LD_VAR 0 2
62552: PUSH
62553: LD_VAR 0 3
62557: PUSH
62558: EMPTY
62559: LIST
62560: LIST
62561: LIST
62562: PPUSH
62563: CALL 70863 0 3
62567: ST_TO_ADDR
// exit ;
62568: POP
62569: POP
62570: POP
62571: POP
62572: GO 62582
// end ;
62574: GO 62481
62576: POP
62577: POP
// end ;
62578: GO 62289
62580: POP
62581: POP
// end ;
62582: LD_VAR 0 6
62586: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62587: LD_INT 0
62589: PPUSH
62590: PPUSH
62591: PPUSH
62592: PPUSH
// if not mc_bases or not skirmish then
62593: LD_EXP 116
62597: NOT
62598: PUSH
62599: LD_EXP 114
62603: NOT
62604: OR
62605: IFFALSE 62609
// exit ;
62607: GO 62886
// side := GetSide ( lab ) ;
62609: LD_ADDR_VAR 0 4
62613: PUSH
62614: LD_VAR 0 2
62618: PPUSH
62619: CALL_OW 255
62623: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62624: LD_VAR 0 4
62628: PUSH
62629: LD_EXP 142
62633: IN
62634: NOT
62635: PUSH
62636: LD_EXP 143
62640: NOT
62641: OR
62642: PUSH
62643: LD_EXP 116
62647: NOT
62648: OR
62649: IFFALSE 62653
// exit ;
62651: GO 62886
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62653: LD_ADDR_EXP 143
62657: PUSH
62658: LD_EXP 143
62662: PPUSH
62663: LD_VAR 0 4
62667: PPUSH
62668: LD_EXP 143
62672: PUSH
62673: LD_VAR 0 4
62677: ARRAY
62678: PUSH
62679: LD_VAR 0 1
62683: DIFF
62684: PPUSH
62685: CALL_OW 1
62689: ST_TO_ADDR
// for i = 1 to mc_bases do
62690: LD_ADDR_VAR 0 5
62694: PUSH
62695: DOUBLE
62696: LD_INT 1
62698: DEC
62699: ST_TO_ADDR
62700: LD_EXP 116
62704: PUSH
62705: FOR_TO
62706: IFFALSE 62884
// begin if lab in mc_bases [ i ] then
62708: LD_VAR 0 2
62712: PUSH
62713: LD_EXP 116
62717: PUSH
62718: LD_VAR 0 5
62722: ARRAY
62723: IN
62724: IFFALSE 62882
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62726: LD_VAR 0 1
62730: PUSH
62731: LD_INT 11
62733: PUSH
62734: LD_INT 4
62736: PUSH
62737: LD_INT 3
62739: PUSH
62740: LD_INT 2
62742: PUSH
62743: EMPTY
62744: LIST
62745: LIST
62746: LIST
62747: LIST
62748: IN
62749: PUSH
62750: LD_EXP 146
62754: PUSH
62755: LD_VAR 0 5
62759: ARRAY
62760: AND
62761: IFFALSE 62882
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62763: LD_ADDR_VAR 0 6
62767: PUSH
62768: LD_EXP 146
62772: PUSH
62773: LD_VAR 0 5
62777: ARRAY
62778: PUSH
62779: LD_INT 1
62781: ARRAY
62782: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62783: LD_ADDR_EXP 146
62787: PUSH
62788: LD_EXP 146
62792: PPUSH
62793: LD_VAR 0 5
62797: PPUSH
62798: EMPTY
62799: PPUSH
62800: CALL_OW 1
62804: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62805: LD_VAR 0 6
62809: PPUSH
62810: LD_INT 0
62812: PPUSH
62813: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62817: LD_VAR 0 6
62821: PPUSH
62822: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62826: LD_ADDR_EXP 145
62830: PUSH
62831: LD_EXP 145
62835: PPUSH
62836: LD_VAR 0 5
62840: PPUSH
62841: LD_EXP 145
62845: PUSH
62846: LD_VAR 0 5
62850: ARRAY
62851: PPUSH
62852: LD_INT 1
62854: PPUSH
62855: LD_VAR 0 6
62859: PPUSH
62860: CALL_OW 2
62864: PPUSH
62865: CALL_OW 1
62869: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62870: LD_VAR 0 5
62874: PPUSH
62875: LD_INT 112
62877: PPUSH
62878: CALL 39405 0 2
// end ; end ; end ;
62882: GO 62705
62884: POP
62885: POP
// end ;
62886: LD_VAR 0 3
62890: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62891: LD_INT 0
62893: PPUSH
62894: PPUSH
62895: PPUSH
62896: PPUSH
62897: PPUSH
62898: PPUSH
62899: PPUSH
62900: PPUSH
// if not mc_bases or not skirmish then
62901: LD_EXP 116
62905: NOT
62906: PUSH
62907: LD_EXP 114
62911: NOT
62912: OR
62913: IFFALSE 62917
// exit ;
62915: GO 64288
// for i = 1 to mc_bases do
62917: LD_ADDR_VAR 0 3
62921: PUSH
62922: DOUBLE
62923: LD_INT 1
62925: DEC
62926: ST_TO_ADDR
62927: LD_EXP 116
62931: PUSH
62932: FOR_TO
62933: IFFALSE 64286
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62935: LD_VAR 0 1
62939: PUSH
62940: LD_EXP 116
62944: PUSH
62945: LD_VAR 0 3
62949: ARRAY
62950: IN
62951: PUSH
62952: LD_VAR 0 1
62956: PUSH
62957: LD_EXP 123
62961: PUSH
62962: LD_VAR 0 3
62966: ARRAY
62967: IN
62968: OR
62969: PUSH
62970: LD_VAR 0 1
62974: PUSH
62975: LD_EXP 138
62979: PUSH
62980: LD_VAR 0 3
62984: ARRAY
62985: IN
62986: OR
62987: PUSH
62988: LD_VAR 0 1
62992: PUSH
62993: LD_EXP 135
62997: PUSH
62998: LD_VAR 0 3
63002: ARRAY
63003: IN
63004: OR
63005: PUSH
63006: LD_VAR 0 1
63010: PUSH
63011: LD_EXP 145
63015: PUSH
63016: LD_VAR 0 3
63020: ARRAY
63021: IN
63022: OR
63023: PUSH
63024: LD_VAR 0 1
63028: PUSH
63029: LD_EXP 146
63033: PUSH
63034: LD_VAR 0 3
63038: ARRAY
63039: IN
63040: OR
63041: IFFALSE 64284
// begin if un in mc_ape [ i ] then
63043: LD_VAR 0 1
63047: PUSH
63048: LD_EXP 145
63052: PUSH
63053: LD_VAR 0 3
63057: ARRAY
63058: IN
63059: IFFALSE 63098
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
63061: LD_ADDR_EXP 145
63065: PUSH
63066: LD_EXP 145
63070: PPUSH
63071: LD_VAR 0 3
63075: PPUSH
63076: LD_EXP 145
63080: PUSH
63081: LD_VAR 0 3
63085: ARRAY
63086: PUSH
63087: LD_VAR 0 1
63091: DIFF
63092: PPUSH
63093: CALL_OW 1
63097: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
63098: LD_VAR 0 1
63102: PUSH
63103: LD_EXP 146
63107: PUSH
63108: LD_VAR 0 3
63112: ARRAY
63113: IN
63114: IFFALSE 63138
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63116: LD_ADDR_EXP 146
63120: PUSH
63121: LD_EXP 146
63125: PPUSH
63126: LD_VAR 0 3
63130: PPUSH
63131: EMPTY
63132: PPUSH
63133: CALL_OW 1
63137: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
63138: LD_VAR 0 1
63142: PPUSH
63143: CALL_OW 247
63147: PUSH
63148: LD_INT 2
63150: EQUAL
63151: PUSH
63152: LD_VAR 0 1
63156: PPUSH
63157: CALL_OW 110
63161: PUSH
63162: LD_INT 20
63164: EQUAL
63165: PUSH
63166: LD_VAR 0 1
63170: PUSH
63171: LD_EXP 138
63175: PUSH
63176: LD_VAR 0 3
63180: ARRAY
63181: IN
63182: OR
63183: PUSH
63184: LD_VAR 0 1
63188: PPUSH
63189: CALL_OW 264
63193: PUSH
63194: LD_INT 12
63196: PUSH
63197: LD_INT 51
63199: PUSH
63200: LD_EXP 96
63204: PUSH
63205: LD_INT 32
63207: PUSH
63208: LD_INT 13
63210: PUSH
63211: LD_INT 52
63213: PUSH
63214: LD_INT 31
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: LIST
63224: LIST
63225: IN
63226: OR
63227: AND
63228: IFFALSE 63536
// begin if un in mc_defender [ i ] then
63230: LD_VAR 0 1
63234: PUSH
63235: LD_EXP 138
63239: PUSH
63240: LD_VAR 0 3
63244: ARRAY
63245: IN
63246: IFFALSE 63285
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63248: LD_ADDR_EXP 138
63252: PUSH
63253: LD_EXP 138
63257: PPUSH
63258: LD_VAR 0 3
63262: PPUSH
63263: LD_EXP 138
63267: PUSH
63268: LD_VAR 0 3
63272: ARRAY
63273: PUSH
63274: LD_VAR 0 1
63278: DIFF
63279: PPUSH
63280: CALL_OW 1
63284: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
63285: LD_ADDR_VAR 0 8
63289: PUSH
63290: LD_VAR 0 3
63294: PPUSH
63295: LD_INT 3
63297: PPUSH
63298: CALL 59926 0 2
63302: ST_TO_ADDR
// if fac then
63303: LD_VAR 0 8
63307: IFFALSE 63536
// begin for j in fac do
63309: LD_ADDR_VAR 0 4
63313: PUSH
63314: LD_VAR 0 8
63318: PUSH
63319: FOR_IN
63320: IFFALSE 63534
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
63322: LD_ADDR_VAR 0 9
63326: PUSH
63327: LD_VAR 0 8
63331: PPUSH
63332: LD_VAR 0 1
63336: PPUSH
63337: CALL_OW 265
63341: PPUSH
63342: LD_VAR 0 1
63346: PPUSH
63347: CALL_OW 262
63351: PPUSH
63352: LD_VAR 0 1
63356: PPUSH
63357: CALL_OW 263
63361: PPUSH
63362: LD_VAR 0 1
63366: PPUSH
63367: CALL_OW 264
63371: PPUSH
63372: CALL 68359 0 5
63376: ST_TO_ADDR
// if components then
63377: LD_VAR 0 9
63381: IFFALSE 63532
// begin if GetWeapon ( un ) = ar_control_tower then
63383: LD_VAR 0 1
63387: PPUSH
63388: CALL_OW 264
63392: PUSH
63393: LD_INT 31
63395: EQUAL
63396: IFFALSE 63513
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63398: LD_VAR 0 1
63402: PPUSH
63403: CALL_OW 311
63407: PPUSH
63408: LD_INT 0
63410: PPUSH
63411: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63415: LD_ADDR_EXP 156
63419: PUSH
63420: LD_EXP 156
63424: PPUSH
63425: LD_VAR 0 3
63429: PPUSH
63430: LD_EXP 156
63434: PUSH
63435: LD_VAR 0 3
63439: ARRAY
63440: PUSH
63441: LD_VAR 0 1
63445: PPUSH
63446: CALL_OW 311
63450: DIFF
63451: PPUSH
63452: CALL_OW 1
63456: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63457: LD_ADDR_VAR 0 7
63461: PUSH
63462: LD_EXP 137
63466: PUSH
63467: LD_VAR 0 3
63471: ARRAY
63472: PPUSH
63473: LD_INT 1
63475: PPUSH
63476: LD_VAR 0 9
63480: PPUSH
63481: CALL_OW 2
63485: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63486: LD_ADDR_EXP 137
63490: PUSH
63491: LD_EXP 137
63495: PPUSH
63496: LD_VAR 0 3
63500: PPUSH
63501: LD_VAR 0 7
63505: PPUSH
63506: CALL_OW 1
63510: ST_TO_ADDR
// end else
63511: GO 63530
// MC_InsertProduceList ( i , [ components ] ) ;
63513: LD_VAR 0 3
63517: PPUSH
63518: LD_VAR 0 9
63522: PUSH
63523: EMPTY
63524: LIST
63525: PPUSH
63526: CALL 59471 0 2
// break ;
63530: GO 63534
// end ; end ;
63532: GO 63319
63534: POP
63535: POP
// end ; end ; if GetType ( un ) = unit_building then
63536: LD_VAR 0 1
63540: PPUSH
63541: CALL_OW 247
63545: PUSH
63546: LD_INT 3
63548: EQUAL
63549: IFFALSE 63952
// begin btype := GetBType ( un ) ;
63551: LD_ADDR_VAR 0 5
63555: PUSH
63556: LD_VAR 0 1
63560: PPUSH
63561: CALL_OW 266
63565: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63566: LD_VAR 0 5
63570: PUSH
63571: LD_INT 29
63573: PUSH
63574: LD_INT 30
63576: PUSH
63577: EMPTY
63578: LIST
63579: LIST
63580: IN
63581: IFFALSE 63654
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63583: LD_VAR 0 1
63587: PPUSH
63588: CALL_OW 250
63592: PPUSH
63593: LD_VAR 0 1
63597: PPUSH
63598: CALL_OW 251
63602: PPUSH
63603: LD_VAR 0 1
63607: PPUSH
63608: CALL_OW 255
63612: PPUSH
63613: CALL_OW 440
63617: NOT
63618: IFFALSE 63654
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63620: LD_VAR 0 1
63624: PPUSH
63625: CALL_OW 250
63629: PPUSH
63630: LD_VAR 0 1
63634: PPUSH
63635: CALL_OW 251
63639: PPUSH
63640: LD_VAR 0 1
63644: PPUSH
63645: CALL_OW 255
63649: PPUSH
63650: CALL_OW 441
// end ; if btype = b_warehouse then
63654: LD_VAR 0 5
63658: PUSH
63659: LD_INT 1
63661: EQUAL
63662: IFFALSE 63680
// begin btype := b_depot ;
63664: LD_ADDR_VAR 0 5
63668: PUSH
63669: LD_INT 0
63671: ST_TO_ADDR
// pos := 1 ;
63672: LD_ADDR_VAR 0 6
63676: PUSH
63677: LD_INT 1
63679: ST_TO_ADDR
// end ; if btype = b_factory then
63680: LD_VAR 0 5
63684: PUSH
63685: LD_INT 3
63687: EQUAL
63688: IFFALSE 63706
// begin btype := b_workshop ;
63690: LD_ADDR_VAR 0 5
63694: PUSH
63695: LD_INT 2
63697: ST_TO_ADDR
// pos := 1 ;
63698: LD_ADDR_VAR 0 6
63702: PUSH
63703: LD_INT 1
63705: ST_TO_ADDR
// end ; if btype = b_barracks then
63706: LD_VAR 0 5
63710: PUSH
63711: LD_INT 5
63713: EQUAL
63714: IFFALSE 63724
// btype := b_armoury ;
63716: LD_ADDR_VAR 0 5
63720: PUSH
63721: LD_INT 4
63723: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63724: LD_VAR 0 5
63728: PUSH
63729: LD_INT 7
63731: PUSH
63732: LD_INT 8
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: IN
63739: IFFALSE 63749
// btype := b_lab ;
63741: LD_ADDR_VAR 0 5
63745: PUSH
63746: LD_INT 6
63748: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63749: LD_ADDR_EXP 121
63753: PUSH
63754: LD_EXP 121
63758: PPUSH
63759: LD_VAR 0 3
63763: PUSH
63764: LD_EXP 121
63768: PUSH
63769: LD_VAR 0 3
63773: ARRAY
63774: PUSH
63775: LD_INT 1
63777: PLUS
63778: PUSH
63779: EMPTY
63780: LIST
63781: LIST
63782: PPUSH
63783: LD_VAR 0 5
63787: PUSH
63788: LD_VAR 0 1
63792: PPUSH
63793: CALL_OW 250
63797: PUSH
63798: LD_VAR 0 1
63802: PPUSH
63803: CALL_OW 251
63807: PUSH
63808: LD_VAR 0 1
63812: PPUSH
63813: CALL_OW 254
63817: PUSH
63818: EMPTY
63819: LIST
63820: LIST
63821: LIST
63822: LIST
63823: PPUSH
63824: CALL 70863 0 3
63828: ST_TO_ADDR
// if pos = 1 then
63829: LD_VAR 0 6
63833: PUSH
63834: LD_INT 1
63836: EQUAL
63837: IFFALSE 63952
// begin tmp := mc_build_list [ i ] ;
63839: LD_ADDR_VAR 0 7
63843: PUSH
63844: LD_EXP 121
63848: PUSH
63849: LD_VAR 0 3
63853: ARRAY
63854: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63855: LD_VAR 0 7
63859: PPUSH
63860: LD_INT 2
63862: PUSH
63863: LD_INT 30
63865: PUSH
63866: LD_INT 0
63868: PUSH
63869: EMPTY
63870: LIST
63871: LIST
63872: PUSH
63873: LD_INT 30
63875: PUSH
63876: LD_INT 1
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: PUSH
63883: EMPTY
63884: LIST
63885: LIST
63886: LIST
63887: PPUSH
63888: CALL_OW 72
63892: IFFALSE 63902
// pos := 2 ;
63894: LD_ADDR_VAR 0 6
63898: PUSH
63899: LD_INT 2
63901: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63902: LD_ADDR_VAR 0 7
63906: PUSH
63907: LD_VAR 0 7
63911: PPUSH
63912: LD_VAR 0 6
63916: PPUSH
63917: LD_VAR 0 7
63921: PPUSH
63922: CALL 71189 0 3
63926: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63927: LD_ADDR_EXP 121
63931: PUSH
63932: LD_EXP 121
63936: PPUSH
63937: LD_VAR 0 3
63941: PPUSH
63942: LD_VAR 0 7
63946: PPUSH
63947: CALL_OW 1
63951: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63952: LD_VAR 0 1
63956: PUSH
63957: LD_EXP 116
63961: PUSH
63962: LD_VAR 0 3
63966: ARRAY
63967: IN
63968: IFFALSE 64007
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63970: LD_ADDR_EXP 116
63974: PUSH
63975: LD_EXP 116
63979: PPUSH
63980: LD_VAR 0 3
63984: PPUSH
63985: LD_EXP 116
63989: PUSH
63990: LD_VAR 0 3
63994: ARRAY
63995: PUSH
63996: LD_VAR 0 1
64000: DIFF
64001: PPUSH
64002: CALL_OW 1
64006: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
64007: LD_VAR 0 1
64011: PUSH
64012: LD_EXP 123
64016: PUSH
64017: LD_VAR 0 3
64021: ARRAY
64022: IN
64023: IFFALSE 64062
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
64025: LD_ADDR_EXP 123
64029: PUSH
64030: LD_EXP 123
64034: PPUSH
64035: LD_VAR 0 3
64039: PPUSH
64040: LD_EXP 123
64044: PUSH
64045: LD_VAR 0 3
64049: ARRAY
64050: PUSH
64051: LD_VAR 0 1
64055: DIFF
64056: PPUSH
64057: CALL_OW 1
64061: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
64062: LD_VAR 0 1
64066: PUSH
64067: LD_EXP 135
64071: PUSH
64072: LD_VAR 0 3
64076: ARRAY
64077: IN
64078: IFFALSE 64117
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
64080: LD_ADDR_EXP 135
64084: PUSH
64085: LD_EXP 135
64089: PPUSH
64090: LD_VAR 0 3
64094: PPUSH
64095: LD_EXP 135
64099: PUSH
64100: LD_VAR 0 3
64104: ARRAY
64105: PUSH
64106: LD_VAR 0 1
64110: DIFF
64111: PPUSH
64112: CALL_OW 1
64116: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
64117: LD_VAR 0 1
64121: PUSH
64122: LD_EXP 138
64126: PUSH
64127: LD_VAR 0 3
64131: ARRAY
64132: IN
64133: IFFALSE 64172
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64135: LD_ADDR_EXP 138
64139: PUSH
64140: LD_EXP 138
64144: PPUSH
64145: LD_VAR 0 3
64149: PPUSH
64150: LD_EXP 138
64154: PUSH
64155: LD_VAR 0 3
64159: ARRAY
64160: PUSH
64161: LD_VAR 0 1
64165: DIFF
64166: PPUSH
64167: CALL_OW 1
64171: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
64172: LD_VAR 0 1
64176: PUSH
64177: LD_EXP 125
64181: PUSH
64182: LD_VAR 0 3
64186: ARRAY
64187: IN
64188: IFFALSE 64227
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
64190: LD_ADDR_EXP 125
64194: PUSH
64195: LD_EXP 125
64199: PPUSH
64200: LD_VAR 0 3
64204: PPUSH
64205: LD_EXP 125
64209: PUSH
64210: LD_VAR 0 3
64214: ARRAY
64215: PUSH
64216: LD_VAR 0 1
64220: DIFF
64221: PPUSH
64222: CALL_OW 1
64226: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
64227: LD_VAR 0 1
64231: PUSH
64232: LD_EXP 124
64236: PUSH
64237: LD_VAR 0 3
64241: ARRAY
64242: IN
64243: IFFALSE 64282
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
64245: LD_ADDR_EXP 124
64249: PUSH
64250: LD_EXP 124
64254: PPUSH
64255: LD_VAR 0 3
64259: PPUSH
64260: LD_EXP 124
64264: PUSH
64265: LD_VAR 0 3
64269: ARRAY
64270: PUSH
64271: LD_VAR 0 1
64275: DIFF
64276: PPUSH
64277: CALL_OW 1
64281: ST_TO_ADDR
// end ; break ;
64282: GO 64286
// end ;
64284: GO 62932
64286: POP
64287: POP
// end ;
64288: LD_VAR 0 2
64292: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
64293: LD_INT 0
64295: PPUSH
64296: PPUSH
64297: PPUSH
// if not mc_bases or not skirmish then
64298: LD_EXP 116
64302: NOT
64303: PUSH
64304: LD_EXP 114
64308: NOT
64309: OR
64310: IFFALSE 64314
// exit ;
64312: GO 64529
// for i = 1 to mc_bases do
64314: LD_ADDR_VAR 0 3
64318: PUSH
64319: DOUBLE
64320: LD_INT 1
64322: DEC
64323: ST_TO_ADDR
64324: LD_EXP 116
64328: PUSH
64329: FOR_TO
64330: IFFALSE 64527
// begin if building in mc_construct_list [ i ] then
64332: LD_VAR 0 1
64336: PUSH
64337: LD_EXP 123
64341: PUSH
64342: LD_VAR 0 3
64346: ARRAY
64347: IN
64348: IFFALSE 64525
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64350: LD_ADDR_EXP 123
64354: PUSH
64355: LD_EXP 123
64359: PPUSH
64360: LD_VAR 0 3
64364: PPUSH
64365: LD_EXP 123
64369: PUSH
64370: LD_VAR 0 3
64374: ARRAY
64375: PUSH
64376: LD_VAR 0 1
64380: DIFF
64381: PPUSH
64382: CALL_OW 1
64386: ST_TO_ADDR
// if building in mc_lab [ i ] then
64387: LD_VAR 0 1
64391: PUSH
64392: LD_EXP 149
64396: PUSH
64397: LD_VAR 0 3
64401: ARRAY
64402: IN
64403: IFFALSE 64458
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64405: LD_ADDR_EXP 150
64409: PUSH
64410: LD_EXP 150
64414: PPUSH
64415: LD_VAR 0 3
64419: PPUSH
64420: LD_EXP 150
64424: PUSH
64425: LD_VAR 0 3
64429: ARRAY
64430: PPUSH
64431: LD_INT 1
64433: PPUSH
64434: LD_EXP 150
64438: PUSH
64439: LD_VAR 0 3
64443: ARRAY
64444: PPUSH
64445: LD_INT 0
64447: PPUSH
64448: CALL 70281 0 4
64452: PPUSH
64453: CALL_OW 1
64457: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64458: LD_VAR 0 1
64462: PUSH
64463: LD_EXP 116
64467: PUSH
64468: LD_VAR 0 3
64472: ARRAY
64473: IN
64474: NOT
64475: IFFALSE 64521
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64477: LD_ADDR_EXP 116
64481: PUSH
64482: LD_EXP 116
64486: PPUSH
64487: LD_VAR 0 3
64491: PUSH
64492: LD_EXP 116
64496: PUSH
64497: LD_VAR 0 3
64501: ARRAY
64502: PUSH
64503: LD_INT 1
64505: PLUS
64506: PUSH
64507: EMPTY
64508: LIST
64509: LIST
64510: PPUSH
64511: LD_VAR 0 1
64515: PPUSH
64516: CALL 70863 0 3
64520: ST_TO_ADDR
// exit ;
64521: POP
64522: POP
64523: GO 64529
// end ; end ;
64525: GO 64329
64527: POP
64528: POP
// end ;
64529: LD_VAR 0 2
64533: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64534: LD_INT 0
64536: PPUSH
64537: PPUSH
64538: PPUSH
64539: PPUSH
64540: PPUSH
64541: PPUSH
64542: PPUSH
// if not mc_bases or not skirmish then
64543: LD_EXP 116
64547: NOT
64548: PUSH
64549: LD_EXP 114
64553: NOT
64554: OR
64555: IFFALSE 64559
// exit ;
64557: GO 65220
// for i = 1 to mc_bases do
64559: LD_ADDR_VAR 0 3
64563: PUSH
64564: DOUBLE
64565: LD_INT 1
64567: DEC
64568: ST_TO_ADDR
64569: LD_EXP 116
64573: PUSH
64574: FOR_TO
64575: IFFALSE 65218
// begin if building in mc_construct_list [ i ] then
64577: LD_VAR 0 1
64581: PUSH
64582: LD_EXP 123
64586: PUSH
64587: LD_VAR 0 3
64591: ARRAY
64592: IN
64593: IFFALSE 65216
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64595: LD_ADDR_EXP 123
64599: PUSH
64600: LD_EXP 123
64604: PPUSH
64605: LD_VAR 0 3
64609: PPUSH
64610: LD_EXP 123
64614: PUSH
64615: LD_VAR 0 3
64619: ARRAY
64620: PUSH
64621: LD_VAR 0 1
64625: DIFF
64626: PPUSH
64627: CALL_OW 1
64631: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64632: LD_ADDR_EXP 116
64636: PUSH
64637: LD_EXP 116
64641: PPUSH
64642: LD_VAR 0 3
64646: PUSH
64647: LD_EXP 116
64651: PUSH
64652: LD_VAR 0 3
64656: ARRAY
64657: PUSH
64658: LD_INT 1
64660: PLUS
64661: PUSH
64662: EMPTY
64663: LIST
64664: LIST
64665: PPUSH
64666: LD_VAR 0 1
64670: PPUSH
64671: CALL 70863 0 3
64675: ST_TO_ADDR
// btype := GetBType ( building ) ;
64676: LD_ADDR_VAR 0 5
64680: PUSH
64681: LD_VAR 0 1
64685: PPUSH
64686: CALL_OW 266
64690: ST_TO_ADDR
// side := GetSide ( building ) ;
64691: LD_ADDR_VAR 0 8
64695: PUSH
64696: LD_VAR 0 1
64700: PPUSH
64701: CALL_OW 255
64705: ST_TO_ADDR
// if btype = b_lab then
64706: LD_VAR 0 5
64710: PUSH
64711: LD_INT 6
64713: EQUAL
64714: IFFALSE 64764
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64716: LD_ADDR_EXP 149
64720: PUSH
64721: LD_EXP 149
64725: PPUSH
64726: LD_VAR 0 3
64730: PUSH
64731: LD_EXP 149
64735: PUSH
64736: LD_VAR 0 3
64740: ARRAY
64741: PUSH
64742: LD_INT 1
64744: PLUS
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: PPUSH
64750: LD_VAR 0 1
64754: PPUSH
64755: CALL 70863 0 3
64759: ST_TO_ADDR
// exit ;
64760: POP
64761: POP
64762: GO 65220
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64764: LD_VAR 0 5
64768: PUSH
64769: LD_INT 0
64771: PUSH
64772: LD_INT 2
64774: PUSH
64775: LD_INT 4
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: LIST
64782: IN
64783: IFFALSE 64907
// begin if btype = b_armoury then
64785: LD_VAR 0 5
64789: PUSH
64790: LD_INT 4
64792: EQUAL
64793: IFFALSE 64803
// btype := b_barracks ;
64795: LD_ADDR_VAR 0 5
64799: PUSH
64800: LD_INT 5
64802: ST_TO_ADDR
// if btype = b_depot then
64803: LD_VAR 0 5
64807: PUSH
64808: LD_INT 0
64810: EQUAL
64811: IFFALSE 64821
// btype := b_warehouse ;
64813: LD_ADDR_VAR 0 5
64817: PUSH
64818: LD_INT 1
64820: ST_TO_ADDR
// if btype = b_workshop then
64821: LD_VAR 0 5
64825: PUSH
64826: LD_INT 2
64828: EQUAL
64829: IFFALSE 64839
// btype := b_factory ;
64831: LD_ADDR_VAR 0 5
64835: PUSH
64836: LD_INT 3
64838: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64839: LD_VAR 0 5
64843: PPUSH
64844: LD_VAR 0 8
64848: PPUSH
64849: CALL_OW 323
64853: PUSH
64854: LD_INT 1
64856: EQUAL
64857: IFFALSE 64903
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64859: LD_ADDR_EXP 148
64863: PUSH
64864: LD_EXP 148
64868: PPUSH
64869: LD_VAR 0 3
64873: PUSH
64874: LD_EXP 148
64878: PUSH
64879: LD_VAR 0 3
64883: ARRAY
64884: PUSH
64885: LD_INT 1
64887: PLUS
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: PPUSH
64893: LD_VAR 0 1
64897: PPUSH
64898: CALL 70863 0 3
64902: ST_TO_ADDR
// exit ;
64903: POP
64904: POP
64905: GO 65220
// end ; if btype in [ b_bunker , b_turret ] then
64907: LD_VAR 0 5
64911: PUSH
64912: LD_INT 32
64914: PUSH
64915: LD_INT 33
64917: PUSH
64918: EMPTY
64919: LIST
64920: LIST
64921: IN
64922: IFFALSE 65212
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64924: LD_ADDR_EXP 124
64928: PUSH
64929: LD_EXP 124
64933: PPUSH
64934: LD_VAR 0 3
64938: PUSH
64939: LD_EXP 124
64943: PUSH
64944: LD_VAR 0 3
64948: ARRAY
64949: PUSH
64950: LD_INT 1
64952: PLUS
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: PPUSH
64958: LD_VAR 0 1
64962: PPUSH
64963: CALL 70863 0 3
64967: ST_TO_ADDR
// if btype = b_bunker then
64968: LD_VAR 0 5
64972: PUSH
64973: LD_INT 32
64975: EQUAL
64976: IFFALSE 65212
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64978: LD_ADDR_EXP 125
64982: PUSH
64983: LD_EXP 125
64987: PPUSH
64988: LD_VAR 0 3
64992: PUSH
64993: LD_EXP 125
64997: PUSH
64998: LD_VAR 0 3
65002: ARRAY
65003: PUSH
65004: LD_INT 1
65006: PLUS
65007: PUSH
65008: EMPTY
65009: LIST
65010: LIST
65011: PPUSH
65012: LD_VAR 0 1
65016: PPUSH
65017: CALL 70863 0 3
65021: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
65022: LD_ADDR_VAR 0 6
65026: PUSH
65027: LD_EXP 116
65031: PUSH
65032: LD_VAR 0 3
65036: ARRAY
65037: PPUSH
65038: LD_INT 25
65040: PUSH
65041: LD_INT 1
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: LD_INT 3
65050: PUSH
65051: LD_INT 54
65053: PUSH
65054: EMPTY
65055: LIST
65056: PUSH
65057: EMPTY
65058: LIST
65059: LIST
65060: PUSH
65061: EMPTY
65062: LIST
65063: LIST
65064: PPUSH
65065: CALL_OW 72
65069: ST_TO_ADDR
// if tmp then
65070: LD_VAR 0 6
65074: IFFALSE 65080
// exit ;
65076: POP
65077: POP
65078: GO 65220
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65080: LD_ADDR_VAR 0 6
65084: PUSH
65085: LD_EXP 116
65089: PUSH
65090: LD_VAR 0 3
65094: ARRAY
65095: PPUSH
65096: LD_INT 2
65098: PUSH
65099: LD_INT 30
65101: PUSH
65102: LD_INT 4
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: LD_INT 30
65111: PUSH
65112: LD_INT 5
65114: PUSH
65115: EMPTY
65116: LIST
65117: LIST
65118: PUSH
65119: EMPTY
65120: LIST
65121: LIST
65122: LIST
65123: PPUSH
65124: CALL_OW 72
65128: ST_TO_ADDR
// if not tmp then
65129: LD_VAR 0 6
65133: NOT
65134: IFFALSE 65140
// exit ;
65136: POP
65137: POP
65138: GO 65220
// for j in tmp do
65140: LD_ADDR_VAR 0 4
65144: PUSH
65145: LD_VAR 0 6
65149: PUSH
65150: FOR_IN
65151: IFFALSE 65210
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
65153: LD_ADDR_VAR 0 7
65157: PUSH
65158: LD_VAR 0 4
65162: PPUSH
65163: CALL_OW 313
65167: PPUSH
65168: LD_INT 25
65170: PUSH
65171: LD_INT 1
65173: PUSH
65174: EMPTY
65175: LIST
65176: LIST
65177: PPUSH
65178: CALL_OW 72
65182: ST_TO_ADDR
// if units then
65183: LD_VAR 0 7
65187: IFFALSE 65208
// begin ComExitBuilding ( units [ 1 ] ) ;
65189: LD_VAR 0 7
65193: PUSH
65194: LD_INT 1
65196: ARRAY
65197: PPUSH
65198: CALL_OW 122
// exit ;
65202: POP
65203: POP
65204: POP
65205: POP
65206: GO 65220
// end ; end ;
65208: GO 65150
65210: POP
65211: POP
// end ; end ; exit ;
65212: POP
65213: POP
65214: GO 65220
// end ; end ;
65216: GO 64574
65218: POP
65219: POP
// end ;
65220: LD_VAR 0 2
65224: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
65225: LD_INT 0
65227: PPUSH
65228: PPUSH
65229: PPUSH
65230: PPUSH
65231: PPUSH
65232: PPUSH
65233: PPUSH
// if not mc_bases or not skirmish then
65234: LD_EXP 116
65238: NOT
65239: PUSH
65240: LD_EXP 114
65244: NOT
65245: OR
65246: IFFALSE 65250
// exit ;
65248: GO 65515
// btype := GetBType ( building ) ;
65250: LD_ADDR_VAR 0 6
65254: PUSH
65255: LD_VAR 0 1
65259: PPUSH
65260: CALL_OW 266
65264: ST_TO_ADDR
// x := GetX ( building ) ;
65265: LD_ADDR_VAR 0 7
65269: PUSH
65270: LD_VAR 0 1
65274: PPUSH
65275: CALL_OW 250
65279: ST_TO_ADDR
// y := GetY ( building ) ;
65280: LD_ADDR_VAR 0 8
65284: PUSH
65285: LD_VAR 0 1
65289: PPUSH
65290: CALL_OW 251
65294: ST_TO_ADDR
// d := GetDir ( building ) ;
65295: LD_ADDR_VAR 0 9
65299: PUSH
65300: LD_VAR 0 1
65304: PPUSH
65305: CALL_OW 254
65309: ST_TO_ADDR
// for i = 1 to mc_bases do
65310: LD_ADDR_VAR 0 4
65314: PUSH
65315: DOUBLE
65316: LD_INT 1
65318: DEC
65319: ST_TO_ADDR
65320: LD_EXP 116
65324: PUSH
65325: FOR_TO
65326: IFFALSE 65513
// begin if not mc_build_list [ i ] then
65328: LD_EXP 121
65332: PUSH
65333: LD_VAR 0 4
65337: ARRAY
65338: NOT
65339: IFFALSE 65343
// continue ;
65341: GO 65325
// for j := 1 to mc_build_list [ i ] do
65343: LD_ADDR_VAR 0 5
65347: PUSH
65348: DOUBLE
65349: LD_INT 1
65351: DEC
65352: ST_TO_ADDR
65353: LD_EXP 121
65357: PUSH
65358: LD_VAR 0 4
65362: ARRAY
65363: PUSH
65364: FOR_TO
65365: IFFALSE 65509
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65367: LD_VAR 0 6
65371: PUSH
65372: LD_VAR 0 7
65376: PUSH
65377: LD_VAR 0 8
65381: PUSH
65382: LD_VAR 0 9
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: PPUSH
65393: LD_EXP 121
65397: PUSH
65398: LD_VAR 0 4
65402: ARRAY
65403: PUSH
65404: LD_VAR 0 5
65408: ARRAY
65409: PPUSH
65410: CALL 77045 0 2
65414: IFFALSE 65507
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65416: LD_ADDR_EXP 121
65420: PUSH
65421: LD_EXP 121
65425: PPUSH
65426: LD_VAR 0 4
65430: PPUSH
65431: LD_EXP 121
65435: PUSH
65436: LD_VAR 0 4
65440: ARRAY
65441: PPUSH
65442: LD_VAR 0 5
65446: PPUSH
65447: CALL_OW 3
65451: PPUSH
65452: CALL_OW 1
65456: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65457: LD_ADDR_EXP 123
65461: PUSH
65462: LD_EXP 123
65466: PPUSH
65467: LD_VAR 0 4
65471: PUSH
65472: LD_EXP 123
65476: PUSH
65477: LD_VAR 0 4
65481: ARRAY
65482: PUSH
65483: LD_INT 1
65485: PLUS
65486: PUSH
65487: EMPTY
65488: LIST
65489: LIST
65490: PPUSH
65491: LD_VAR 0 1
65495: PPUSH
65496: CALL 70863 0 3
65500: ST_TO_ADDR
// exit ;
65501: POP
65502: POP
65503: POP
65504: POP
65505: GO 65515
// end ;
65507: GO 65364
65509: POP
65510: POP
// end ;
65511: GO 65325
65513: POP
65514: POP
// end ;
65515: LD_VAR 0 3
65519: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65520: LD_INT 0
65522: PPUSH
65523: PPUSH
65524: PPUSH
// if not mc_bases or not skirmish then
65525: LD_EXP 116
65529: NOT
65530: PUSH
65531: LD_EXP 114
65535: NOT
65536: OR
65537: IFFALSE 65541
// exit ;
65539: GO 65731
// for i = 1 to mc_bases do
65541: LD_ADDR_VAR 0 4
65545: PUSH
65546: DOUBLE
65547: LD_INT 1
65549: DEC
65550: ST_TO_ADDR
65551: LD_EXP 116
65555: PUSH
65556: FOR_TO
65557: IFFALSE 65644
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65559: LD_VAR 0 1
65563: PUSH
65564: LD_EXP 124
65568: PUSH
65569: LD_VAR 0 4
65573: ARRAY
65574: IN
65575: PUSH
65576: LD_VAR 0 1
65580: PUSH
65581: LD_EXP 125
65585: PUSH
65586: LD_VAR 0 4
65590: ARRAY
65591: IN
65592: NOT
65593: AND
65594: IFFALSE 65642
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65596: LD_ADDR_EXP 125
65600: PUSH
65601: LD_EXP 125
65605: PPUSH
65606: LD_VAR 0 4
65610: PUSH
65611: LD_EXP 125
65615: PUSH
65616: LD_VAR 0 4
65620: ARRAY
65621: PUSH
65622: LD_INT 1
65624: PLUS
65625: PUSH
65626: EMPTY
65627: LIST
65628: LIST
65629: PPUSH
65630: LD_VAR 0 1
65634: PPUSH
65635: CALL 70863 0 3
65639: ST_TO_ADDR
// break ;
65640: GO 65644
// end ; end ;
65642: GO 65556
65644: POP
65645: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65646: LD_VAR 0 1
65650: PPUSH
65651: CALL_OW 257
65655: PUSH
65656: LD_EXP 142
65660: IN
65661: PUSH
65662: LD_VAR 0 1
65666: PPUSH
65667: CALL_OW 266
65671: PUSH
65672: LD_INT 5
65674: EQUAL
65675: AND
65676: PUSH
65677: LD_VAR 0 2
65681: PPUSH
65682: CALL_OW 110
65686: PUSH
65687: LD_INT 18
65689: NONEQUAL
65690: AND
65691: IFFALSE 65731
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65693: LD_VAR 0 2
65697: PPUSH
65698: CALL_OW 257
65702: PUSH
65703: LD_INT 5
65705: PUSH
65706: LD_INT 8
65708: PUSH
65709: LD_INT 9
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: LIST
65716: IN
65717: IFFALSE 65731
// SetClass ( unit , 1 ) ;
65719: LD_VAR 0 2
65723: PPUSH
65724: LD_INT 1
65726: PPUSH
65727: CALL_OW 336
// end ;
65731: LD_VAR 0 3
65735: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65736: LD_INT 0
65738: PPUSH
65739: PPUSH
// if not mc_bases or not skirmish then
65740: LD_EXP 116
65744: NOT
65745: PUSH
65746: LD_EXP 114
65750: NOT
65751: OR
65752: IFFALSE 65756
// exit ;
65754: GO 65872
// if GetLives ( abandoned_vehicle ) > 250 then
65756: LD_VAR 0 2
65760: PPUSH
65761: CALL_OW 256
65765: PUSH
65766: LD_INT 250
65768: GREATER
65769: IFFALSE 65773
// exit ;
65771: GO 65872
// for i = 1 to mc_bases do
65773: LD_ADDR_VAR 0 6
65777: PUSH
65778: DOUBLE
65779: LD_INT 1
65781: DEC
65782: ST_TO_ADDR
65783: LD_EXP 116
65787: PUSH
65788: FOR_TO
65789: IFFALSE 65870
// begin if driver in mc_bases [ i ] then
65791: LD_VAR 0 1
65795: PUSH
65796: LD_EXP 116
65800: PUSH
65801: LD_VAR 0 6
65805: ARRAY
65806: IN
65807: IFFALSE 65868
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65809: LD_VAR 0 1
65813: PPUSH
65814: LD_EXP 116
65818: PUSH
65819: LD_VAR 0 6
65823: ARRAY
65824: PPUSH
65825: LD_INT 2
65827: PUSH
65828: LD_INT 30
65830: PUSH
65831: LD_INT 0
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: PUSH
65838: LD_INT 30
65840: PUSH
65841: LD_INT 1
65843: PUSH
65844: EMPTY
65845: LIST
65846: LIST
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: LIST
65852: PPUSH
65853: CALL_OW 72
65857: PUSH
65858: LD_INT 1
65860: ARRAY
65861: PPUSH
65862: CALL 103481 0 2
// break ;
65866: GO 65870
// end ; end ;
65868: GO 65788
65870: POP
65871: POP
// end ; end_of_file
65872: LD_VAR 0 5
65876: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65877: LD_INT 0
65879: PPUSH
65880: PPUSH
// if exist_mode then
65881: LD_VAR 0 2
65885: IFFALSE 65910
// unit := CreateCharacter ( prefix & ident ) else
65887: LD_ADDR_VAR 0 5
65891: PUSH
65892: LD_VAR 0 3
65896: PUSH
65897: LD_VAR 0 1
65901: STR
65902: PPUSH
65903: CALL_OW 34
65907: ST_TO_ADDR
65908: GO 65925
// unit := NewCharacter ( ident ) ;
65910: LD_ADDR_VAR 0 5
65914: PUSH
65915: LD_VAR 0 1
65919: PPUSH
65920: CALL_OW 25
65924: ST_TO_ADDR
// result := unit ;
65925: LD_ADDR_VAR 0 4
65929: PUSH
65930: LD_VAR 0 5
65934: ST_TO_ADDR
// end ;
65935: LD_VAR 0 4
65939: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65940: LD_INT 0
65942: PPUSH
65943: PPUSH
// if not side or not nation then
65944: LD_VAR 0 1
65948: NOT
65949: PUSH
65950: LD_VAR 0 2
65954: NOT
65955: OR
65956: IFFALSE 65960
// exit ;
65958: GO 66728
// case nation of nation_american :
65960: LD_VAR 0 2
65964: PUSH
65965: LD_INT 1
65967: DOUBLE
65968: EQUAL
65969: IFTRUE 65973
65971: GO 66187
65973: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65974: LD_ADDR_VAR 0 4
65978: PUSH
65979: LD_INT 35
65981: PUSH
65982: LD_INT 45
65984: PUSH
65985: LD_INT 46
65987: PUSH
65988: LD_INT 47
65990: PUSH
65991: LD_INT 82
65993: PUSH
65994: LD_INT 83
65996: PUSH
65997: LD_INT 84
65999: PUSH
66000: LD_INT 85
66002: PUSH
66003: LD_INT 86
66005: PUSH
66006: LD_INT 1
66008: PUSH
66009: LD_INT 2
66011: PUSH
66012: LD_INT 6
66014: PUSH
66015: LD_INT 15
66017: PUSH
66018: LD_INT 16
66020: PUSH
66021: LD_INT 7
66023: PUSH
66024: LD_INT 12
66026: PUSH
66027: LD_INT 13
66029: PUSH
66030: LD_INT 10
66032: PUSH
66033: LD_INT 14
66035: PUSH
66036: LD_INT 20
66038: PUSH
66039: LD_INT 21
66041: PUSH
66042: LD_INT 22
66044: PUSH
66045: LD_INT 25
66047: PUSH
66048: LD_INT 32
66050: PUSH
66051: LD_INT 27
66053: PUSH
66054: LD_INT 36
66056: PUSH
66057: LD_INT 69
66059: PUSH
66060: LD_INT 39
66062: PUSH
66063: LD_INT 34
66065: PUSH
66066: LD_INT 40
66068: PUSH
66069: LD_INT 48
66071: PUSH
66072: LD_INT 49
66074: PUSH
66075: LD_INT 50
66077: PUSH
66078: LD_INT 51
66080: PUSH
66081: LD_INT 52
66083: PUSH
66084: LD_INT 53
66086: PUSH
66087: LD_INT 54
66089: PUSH
66090: LD_INT 55
66092: PUSH
66093: LD_INT 56
66095: PUSH
66096: LD_INT 57
66098: PUSH
66099: LD_INT 58
66101: PUSH
66102: LD_INT 59
66104: PUSH
66105: LD_INT 60
66107: PUSH
66108: LD_INT 61
66110: PUSH
66111: LD_INT 62
66113: PUSH
66114: LD_INT 80
66116: PUSH
66117: LD_INT 82
66119: PUSH
66120: LD_INT 83
66122: PUSH
66123: LD_INT 84
66125: PUSH
66126: LD_INT 85
66128: PUSH
66129: LD_INT 86
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: ST_TO_ADDR
66185: GO 66652
66187: LD_INT 2
66189: DOUBLE
66190: EQUAL
66191: IFTRUE 66195
66193: GO 66421
66195: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
66196: LD_ADDR_VAR 0 4
66200: PUSH
66201: LD_INT 35
66203: PUSH
66204: LD_INT 45
66206: PUSH
66207: LD_INT 46
66209: PUSH
66210: LD_INT 47
66212: PUSH
66213: LD_INT 82
66215: PUSH
66216: LD_INT 83
66218: PUSH
66219: LD_INT 84
66221: PUSH
66222: LD_INT 85
66224: PUSH
66225: LD_INT 87
66227: PUSH
66228: LD_INT 70
66230: PUSH
66231: LD_INT 1
66233: PUSH
66234: LD_INT 11
66236: PUSH
66237: LD_INT 3
66239: PUSH
66240: LD_INT 4
66242: PUSH
66243: LD_INT 5
66245: PUSH
66246: LD_INT 6
66248: PUSH
66249: LD_INT 15
66251: PUSH
66252: LD_INT 18
66254: PUSH
66255: LD_INT 7
66257: PUSH
66258: LD_INT 17
66260: PUSH
66261: LD_INT 8
66263: PUSH
66264: LD_INT 20
66266: PUSH
66267: LD_INT 21
66269: PUSH
66270: LD_INT 22
66272: PUSH
66273: LD_INT 72
66275: PUSH
66276: LD_INT 26
66278: PUSH
66279: LD_INT 69
66281: PUSH
66282: LD_INT 39
66284: PUSH
66285: LD_INT 40
66287: PUSH
66288: LD_INT 41
66290: PUSH
66291: LD_INT 42
66293: PUSH
66294: LD_INT 43
66296: PUSH
66297: LD_INT 48
66299: PUSH
66300: LD_INT 49
66302: PUSH
66303: LD_INT 50
66305: PUSH
66306: LD_INT 51
66308: PUSH
66309: LD_INT 52
66311: PUSH
66312: LD_INT 53
66314: PUSH
66315: LD_INT 54
66317: PUSH
66318: LD_INT 55
66320: PUSH
66321: LD_INT 56
66323: PUSH
66324: LD_INT 60
66326: PUSH
66327: LD_INT 61
66329: PUSH
66330: LD_INT 62
66332: PUSH
66333: LD_INT 66
66335: PUSH
66336: LD_INT 67
66338: PUSH
66339: LD_INT 68
66341: PUSH
66342: LD_INT 81
66344: PUSH
66345: LD_INT 82
66347: PUSH
66348: LD_INT 83
66350: PUSH
66351: LD_INT 84
66353: PUSH
66354: LD_INT 85
66356: PUSH
66357: LD_INT 87
66359: PUSH
66360: LD_INT 88
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: ST_TO_ADDR
66419: GO 66652
66421: LD_INT 3
66423: DOUBLE
66424: EQUAL
66425: IFTRUE 66429
66427: GO 66651
66429: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66430: LD_ADDR_VAR 0 4
66434: PUSH
66435: LD_INT 46
66437: PUSH
66438: LD_INT 47
66440: PUSH
66441: LD_INT 1
66443: PUSH
66444: LD_INT 2
66446: PUSH
66447: LD_INT 82
66449: PUSH
66450: LD_INT 83
66452: PUSH
66453: LD_INT 84
66455: PUSH
66456: LD_INT 85
66458: PUSH
66459: LD_INT 86
66461: PUSH
66462: LD_INT 11
66464: PUSH
66465: LD_INT 9
66467: PUSH
66468: LD_INT 20
66470: PUSH
66471: LD_INT 19
66473: PUSH
66474: LD_INT 21
66476: PUSH
66477: LD_INT 24
66479: PUSH
66480: LD_INT 22
66482: PUSH
66483: LD_INT 25
66485: PUSH
66486: LD_INT 28
66488: PUSH
66489: LD_INT 29
66491: PUSH
66492: LD_INT 30
66494: PUSH
66495: LD_INT 31
66497: PUSH
66498: LD_INT 37
66500: PUSH
66501: LD_INT 38
66503: PUSH
66504: LD_INT 32
66506: PUSH
66507: LD_INT 27
66509: PUSH
66510: LD_INT 33
66512: PUSH
66513: LD_INT 69
66515: PUSH
66516: LD_INT 39
66518: PUSH
66519: LD_INT 34
66521: PUSH
66522: LD_INT 40
66524: PUSH
66525: LD_INT 71
66527: PUSH
66528: LD_INT 23
66530: PUSH
66531: LD_INT 44
66533: PUSH
66534: LD_INT 48
66536: PUSH
66537: LD_INT 49
66539: PUSH
66540: LD_INT 50
66542: PUSH
66543: LD_INT 51
66545: PUSH
66546: LD_INT 52
66548: PUSH
66549: LD_INT 53
66551: PUSH
66552: LD_INT 54
66554: PUSH
66555: LD_INT 55
66557: PUSH
66558: LD_INT 56
66560: PUSH
66561: LD_INT 57
66563: PUSH
66564: LD_INT 58
66566: PUSH
66567: LD_INT 59
66569: PUSH
66570: LD_INT 63
66572: PUSH
66573: LD_INT 64
66575: PUSH
66576: LD_INT 65
66578: PUSH
66579: LD_INT 82
66581: PUSH
66582: LD_INT 83
66584: PUSH
66585: LD_INT 84
66587: PUSH
66588: LD_INT 85
66590: PUSH
66591: LD_INT 86
66593: PUSH
66594: EMPTY
66595: LIST
66596: LIST
66597: LIST
66598: LIST
66599: LIST
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: LIST
66627: LIST
66628: LIST
66629: LIST
66630: LIST
66631: LIST
66632: LIST
66633: LIST
66634: LIST
66635: LIST
66636: LIST
66637: LIST
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: ST_TO_ADDR
66649: GO 66652
66651: POP
// if state > - 1 and state < 3 then
66652: LD_VAR 0 3
66656: PUSH
66657: LD_INT 1
66659: NEG
66660: GREATER
66661: PUSH
66662: LD_VAR 0 3
66666: PUSH
66667: LD_INT 3
66669: LESS
66670: AND
66671: IFFALSE 66728
// for i in result do
66673: LD_ADDR_VAR 0 5
66677: PUSH
66678: LD_VAR 0 4
66682: PUSH
66683: FOR_IN
66684: IFFALSE 66726
// if GetTech ( i , side ) <> state then
66686: LD_VAR 0 5
66690: PPUSH
66691: LD_VAR 0 1
66695: PPUSH
66696: CALL_OW 321
66700: PUSH
66701: LD_VAR 0 3
66705: NONEQUAL
66706: IFFALSE 66724
// result := result diff i ;
66708: LD_ADDR_VAR 0 4
66712: PUSH
66713: LD_VAR 0 4
66717: PUSH
66718: LD_VAR 0 5
66722: DIFF
66723: ST_TO_ADDR
66724: GO 66683
66726: POP
66727: POP
// end ;
66728: LD_VAR 0 4
66732: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66733: LD_INT 0
66735: PPUSH
66736: PPUSH
66737: PPUSH
// result := true ;
66738: LD_ADDR_VAR 0 3
66742: PUSH
66743: LD_INT 1
66745: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66746: LD_ADDR_VAR 0 5
66750: PUSH
66751: LD_VAR 0 2
66755: PPUSH
66756: CALL_OW 480
66760: ST_TO_ADDR
// if not tmp then
66761: LD_VAR 0 5
66765: NOT
66766: IFFALSE 66770
// exit ;
66768: GO 66819
// for i in tmp do
66770: LD_ADDR_VAR 0 4
66774: PUSH
66775: LD_VAR 0 5
66779: PUSH
66780: FOR_IN
66781: IFFALSE 66817
// if GetTech ( i , side ) <> state_researched then
66783: LD_VAR 0 4
66787: PPUSH
66788: LD_VAR 0 1
66792: PPUSH
66793: CALL_OW 321
66797: PUSH
66798: LD_INT 2
66800: NONEQUAL
66801: IFFALSE 66815
// begin result := false ;
66803: LD_ADDR_VAR 0 3
66807: PUSH
66808: LD_INT 0
66810: ST_TO_ADDR
// exit ;
66811: POP
66812: POP
66813: GO 66819
// end ;
66815: GO 66780
66817: POP
66818: POP
// end ;
66819: LD_VAR 0 3
66823: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66824: LD_INT 0
66826: PPUSH
66827: PPUSH
66828: PPUSH
66829: PPUSH
66830: PPUSH
66831: PPUSH
66832: PPUSH
66833: PPUSH
66834: PPUSH
66835: PPUSH
66836: PPUSH
66837: PPUSH
66838: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66839: LD_VAR 0 1
66843: NOT
66844: PUSH
66845: LD_VAR 0 1
66849: PPUSH
66850: CALL_OW 257
66854: PUSH
66855: LD_INT 9
66857: NONEQUAL
66858: OR
66859: IFFALSE 66863
// exit ;
66861: GO 67436
// side := GetSide ( unit ) ;
66863: LD_ADDR_VAR 0 9
66867: PUSH
66868: LD_VAR 0 1
66872: PPUSH
66873: CALL_OW 255
66877: ST_TO_ADDR
// tech_space := tech_spacanom ;
66878: LD_ADDR_VAR 0 12
66882: PUSH
66883: LD_INT 29
66885: ST_TO_ADDR
// tech_time := tech_taurad ;
66886: LD_ADDR_VAR 0 13
66890: PUSH
66891: LD_INT 28
66893: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66894: LD_ADDR_VAR 0 11
66898: PUSH
66899: LD_VAR 0 1
66903: PPUSH
66904: CALL_OW 310
66908: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66909: LD_VAR 0 11
66913: PPUSH
66914: CALL_OW 247
66918: PUSH
66919: LD_INT 2
66921: EQUAL
66922: IFFALSE 66926
// exit ;
66924: GO 67436
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66926: LD_ADDR_VAR 0 8
66930: PUSH
66931: LD_INT 81
66933: PUSH
66934: LD_VAR 0 9
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: PUSH
66943: LD_INT 3
66945: PUSH
66946: LD_INT 21
66948: PUSH
66949: LD_INT 3
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: PUSH
66956: EMPTY
66957: LIST
66958: LIST
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PPUSH
66964: CALL_OW 69
66968: ST_TO_ADDR
// if not tmp then
66969: LD_VAR 0 8
66973: NOT
66974: IFFALSE 66978
// exit ;
66976: GO 67436
// if in_unit then
66978: LD_VAR 0 11
66982: IFFALSE 67006
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66984: LD_ADDR_VAR 0 10
66988: PUSH
66989: LD_VAR 0 8
66993: PPUSH
66994: LD_VAR 0 11
66998: PPUSH
66999: CALL_OW 74
67003: ST_TO_ADDR
67004: GO 67026
// enemy := NearestUnitToUnit ( tmp , unit ) ;
67006: LD_ADDR_VAR 0 10
67010: PUSH
67011: LD_VAR 0 8
67015: PPUSH
67016: LD_VAR 0 1
67020: PPUSH
67021: CALL_OW 74
67025: ST_TO_ADDR
// if not enemy then
67026: LD_VAR 0 10
67030: NOT
67031: IFFALSE 67035
// exit ;
67033: GO 67436
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
67035: LD_VAR 0 11
67039: PUSH
67040: LD_VAR 0 11
67044: PPUSH
67045: LD_VAR 0 10
67049: PPUSH
67050: CALL_OW 296
67054: PUSH
67055: LD_INT 13
67057: GREATER
67058: AND
67059: PUSH
67060: LD_VAR 0 1
67064: PPUSH
67065: LD_VAR 0 10
67069: PPUSH
67070: CALL_OW 296
67074: PUSH
67075: LD_INT 12
67077: GREATER
67078: OR
67079: IFFALSE 67083
// exit ;
67081: GO 67436
// missile := [ 1 ] ;
67083: LD_ADDR_VAR 0 14
67087: PUSH
67088: LD_INT 1
67090: PUSH
67091: EMPTY
67092: LIST
67093: ST_TO_ADDR
// if Researched ( side , tech_space ) then
67094: LD_VAR 0 9
67098: PPUSH
67099: LD_VAR 0 12
67103: PPUSH
67104: CALL_OW 325
67108: IFFALSE 67137
// missile := Insert ( missile , missile + 1 , 2 ) ;
67110: LD_ADDR_VAR 0 14
67114: PUSH
67115: LD_VAR 0 14
67119: PPUSH
67120: LD_VAR 0 14
67124: PUSH
67125: LD_INT 1
67127: PLUS
67128: PPUSH
67129: LD_INT 2
67131: PPUSH
67132: CALL_OW 2
67136: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
67137: LD_VAR 0 9
67141: PPUSH
67142: LD_VAR 0 13
67146: PPUSH
67147: CALL_OW 325
67151: PUSH
67152: LD_VAR 0 10
67156: PPUSH
67157: CALL_OW 255
67161: PPUSH
67162: LD_VAR 0 13
67166: PPUSH
67167: CALL_OW 325
67171: NOT
67172: AND
67173: IFFALSE 67202
// missile := Insert ( missile , missile + 1 , 3 ) ;
67175: LD_ADDR_VAR 0 14
67179: PUSH
67180: LD_VAR 0 14
67184: PPUSH
67185: LD_VAR 0 14
67189: PUSH
67190: LD_INT 1
67192: PLUS
67193: PPUSH
67194: LD_INT 3
67196: PPUSH
67197: CALL_OW 2
67201: ST_TO_ADDR
// if missile < 2 then
67202: LD_VAR 0 14
67206: PUSH
67207: LD_INT 2
67209: LESS
67210: IFFALSE 67214
// exit ;
67212: GO 67436
// x := GetX ( enemy ) ;
67214: LD_ADDR_VAR 0 4
67218: PUSH
67219: LD_VAR 0 10
67223: PPUSH
67224: CALL_OW 250
67228: ST_TO_ADDR
// y := GetY ( enemy ) ;
67229: LD_ADDR_VAR 0 5
67233: PUSH
67234: LD_VAR 0 10
67238: PPUSH
67239: CALL_OW 251
67243: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
67244: LD_ADDR_VAR 0 6
67248: PUSH
67249: LD_VAR 0 4
67253: PUSH
67254: LD_INT 1
67256: NEG
67257: PPUSH
67258: LD_INT 1
67260: PPUSH
67261: CALL_OW 12
67265: PLUS
67266: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
67267: LD_ADDR_VAR 0 7
67271: PUSH
67272: LD_VAR 0 5
67276: PUSH
67277: LD_INT 1
67279: NEG
67280: PPUSH
67281: LD_INT 1
67283: PPUSH
67284: CALL_OW 12
67288: PLUS
67289: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67290: LD_VAR 0 6
67294: PPUSH
67295: LD_VAR 0 7
67299: PPUSH
67300: CALL_OW 488
67304: NOT
67305: IFFALSE 67327
// begin _x := x ;
67307: LD_ADDR_VAR 0 6
67311: PUSH
67312: LD_VAR 0 4
67316: ST_TO_ADDR
// _y := y ;
67317: LD_ADDR_VAR 0 7
67321: PUSH
67322: LD_VAR 0 5
67326: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67327: LD_ADDR_VAR 0 3
67331: PUSH
67332: LD_INT 1
67334: PPUSH
67335: LD_VAR 0 14
67339: PPUSH
67340: CALL_OW 12
67344: ST_TO_ADDR
// case i of 1 :
67345: LD_VAR 0 3
67349: PUSH
67350: LD_INT 1
67352: DOUBLE
67353: EQUAL
67354: IFTRUE 67358
67356: GO 67375
67358: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67359: LD_VAR 0 1
67363: PPUSH
67364: LD_VAR 0 10
67368: PPUSH
67369: CALL_OW 115
67373: GO 67436
67375: LD_INT 2
67377: DOUBLE
67378: EQUAL
67379: IFTRUE 67383
67381: GO 67405
67383: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67384: LD_VAR 0 1
67388: PPUSH
67389: LD_VAR 0 6
67393: PPUSH
67394: LD_VAR 0 7
67398: PPUSH
67399: CALL_OW 153
67403: GO 67436
67405: LD_INT 3
67407: DOUBLE
67408: EQUAL
67409: IFTRUE 67413
67411: GO 67435
67413: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67414: LD_VAR 0 1
67418: PPUSH
67419: LD_VAR 0 6
67423: PPUSH
67424: LD_VAR 0 7
67428: PPUSH
67429: CALL_OW 154
67433: GO 67436
67435: POP
// end ;
67436: LD_VAR 0 2
67440: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67441: LD_INT 0
67443: PPUSH
67444: PPUSH
67445: PPUSH
67446: PPUSH
67447: PPUSH
67448: PPUSH
// if not unit or not building then
67449: LD_VAR 0 1
67453: NOT
67454: PUSH
67455: LD_VAR 0 2
67459: NOT
67460: OR
67461: IFFALSE 67465
// exit ;
67463: GO 67623
// x := GetX ( building ) ;
67465: LD_ADDR_VAR 0 5
67469: PUSH
67470: LD_VAR 0 2
67474: PPUSH
67475: CALL_OW 250
67479: ST_TO_ADDR
// y := GetY ( building ) ;
67480: LD_ADDR_VAR 0 6
67484: PUSH
67485: LD_VAR 0 2
67489: PPUSH
67490: CALL_OW 251
67494: ST_TO_ADDR
// for i = 0 to 5 do
67495: LD_ADDR_VAR 0 4
67499: PUSH
67500: DOUBLE
67501: LD_INT 0
67503: DEC
67504: ST_TO_ADDR
67505: LD_INT 5
67507: PUSH
67508: FOR_TO
67509: IFFALSE 67621
// begin _x := ShiftX ( x , i , 3 ) ;
67511: LD_ADDR_VAR 0 7
67515: PUSH
67516: LD_VAR 0 5
67520: PPUSH
67521: LD_VAR 0 4
67525: PPUSH
67526: LD_INT 3
67528: PPUSH
67529: CALL_OW 272
67533: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67534: LD_ADDR_VAR 0 8
67538: PUSH
67539: LD_VAR 0 6
67543: PPUSH
67544: LD_VAR 0 4
67548: PPUSH
67549: LD_INT 3
67551: PPUSH
67552: CALL_OW 273
67556: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67557: LD_VAR 0 7
67561: PPUSH
67562: LD_VAR 0 8
67566: PPUSH
67567: CALL_OW 488
67571: NOT
67572: IFFALSE 67576
// continue ;
67574: GO 67508
// if HexInfo ( _x , _y ) = 0 then
67576: LD_VAR 0 7
67580: PPUSH
67581: LD_VAR 0 8
67585: PPUSH
67586: CALL_OW 428
67590: PUSH
67591: LD_INT 0
67593: EQUAL
67594: IFFALSE 67619
// begin ComMoveXY ( unit , _x , _y ) ;
67596: LD_VAR 0 1
67600: PPUSH
67601: LD_VAR 0 7
67605: PPUSH
67606: LD_VAR 0 8
67610: PPUSH
67611: CALL_OW 111
// exit ;
67615: POP
67616: POP
67617: GO 67623
// end ; end ;
67619: GO 67508
67621: POP
67622: POP
// end ;
67623: LD_VAR 0 3
67627: RET
// export function ScanBase ( side , base_area ) ; begin
67628: LD_INT 0
67630: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67631: LD_ADDR_VAR 0 3
67635: PUSH
67636: LD_VAR 0 2
67640: PPUSH
67641: LD_INT 81
67643: PUSH
67644: LD_VAR 0 1
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: PPUSH
67653: CALL_OW 70
67657: ST_TO_ADDR
// end ;
67658: LD_VAR 0 3
67662: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67663: LD_INT 0
67665: PPUSH
67666: PPUSH
67667: PPUSH
67668: PPUSH
// result := false ;
67669: LD_ADDR_VAR 0 2
67673: PUSH
67674: LD_INT 0
67676: ST_TO_ADDR
// side := GetSide ( unit ) ;
67677: LD_ADDR_VAR 0 3
67681: PUSH
67682: LD_VAR 0 1
67686: PPUSH
67687: CALL_OW 255
67691: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67692: LD_ADDR_VAR 0 4
67696: PUSH
67697: LD_VAR 0 1
67701: PPUSH
67702: CALL_OW 248
67706: ST_TO_ADDR
// case nat of 1 :
67707: LD_VAR 0 4
67711: PUSH
67712: LD_INT 1
67714: DOUBLE
67715: EQUAL
67716: IFTRUE 67720
67718: GO 67731
67720: POP
// tech := tech_lassight ; 2 :
67721: LD_ADDR_VAR 0 5
67725: PUSH
67726: LD_INT 12
67728: ST_TO_ADDR
67729: GO 67770
67731: LD_INT 2
67733: DOUBLE
67734: EQUAL
67735: IFTRUE 67739
67737: GO 67750
67739: POP
// tech := tech_mortar ; 3 :
67740: LD_ADDR_VAR 0 5
67744: PUSH
67745: LD_INT 41
67747: ST_TO_ADDR
67748: GO 67770
67750: LD_INT 3
67752: DOUBLE
67753: EQUAL
67754: IFTRUE 67758
67756: GO 67769
67758: POP
// tech := tech_bazooka ; end ;
67759: LD_ADDR_VAR 0 5
67763: PUSH
67764: LD_INT 44
67766: ST_TO_ADDR
67767: GO 67770
67769: POP
// if Researched ( side , tech ) then
67770: LD_VAR 0 3
67774: PPUSH
67775: LD_VAR 0 5
67779: PPUSH
67780: CALL_OW 325
67784: IFFALSE 67811
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67786: LD_ADDR_VAR 0 2
67790: PUSH
67791: LD_INT 5
67793: PUSH
67794: LD_INT 8
67796: PUSH
67797: LD_INT 9
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: LIST
67804: PUSH
67805: LD_VAR 0 4
67809: ARRAY
67810: ST_TO_ADDR
// end ;
67811: LD_VAR 0 2
67815: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67816: LD_INT 0
67818: PPUSH
67819: PPUSH
67820: PPUSH
// if not mines then
67821: LD_VAR 0 2
67825: NOT
67826: IFFALSE 67830
// exit ;
67828: GO 67974
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67830: LD_ADDR_VAR 0 5
67834: PUSH
67835: LD_INT 81
67837: PUSH
67838: LD_VAR 0 1
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: PUSH
67847: LD_INT 3
67849: PUSH
67850: LD_INT 21
67852: PUSH
67853: LD_INT 3
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PPUSH
67868: CALL_OW 69
67872: ST_TO_ADDR
// for i in mines do
67873: LD_ADDR_VAR 0 4
67877: PUSH
67878: LD_VAR 0 2
67882: PUSH
67883: FOR_IN
67884: IFFALSE 67972
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67886: LD_VAR 0 4
67890: PUSH
67891: LD_INT 1
67893: ARRAY
67894: PPUSH
67895: LD_VAR 0 4
67899: PUSH
67900: LD_INT 2
67902: ARRAY
67903: PPUSH
67904: CALL_OW 458
67908: NOT
67909: IFFALSE 67913
// continue ;
67911: GO 67883
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67913: LD_VAR 0 4
67917: PUSH
67918: LD_INT 1
67920: ARRAY
67921: PPUSH
67922: LD_VAR 0 4
67926: PUSH
67927: LD_INT 2
67929: ARRAY
67930: PPUSH
67931: CALL_OW 428
67935: PUSH
67936: LD_VAR 0 5
67940: IN
67941: IFFALSE 67970
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67943: LD_VAR 0 4
67947: PUSH
67948: LD_INT 1
67950: ARRAY
67951: PPUSH
67952: LD_VAR 0 4
67956: PUSH
67957: LD_INT 2
67959: ARRAY
67960: PPUSH
67961: LD_VAR 0 1
67965: PPUSH
67966: CALL_OW 456
// end ;
67970: GO 67883
67972: POP
67973: POP
// end ;
67974: LD_VAR 0 3
67978: RET
// export function Count ( array ) ; var i ; begin
67979: LD_INT 0
67981: PPUSH
67982: PPUSH
// result := 0 ;
67983: LD_ADDR_VAR 0 2
67987: PUSH
67988: LD_INT 0
67990: ST_TO_ADDR
// for i in array do
67991: LD_ADDR_VAR 0 3
67995: PUSH
67996: LD_VAR 0 1
68000: PUSH
68001: FOR_IN
68002: IFFALSE 68026
// if i then
68004: LD_VAR 0 3
68008: IFFALSE 68024
// result := result + 1 ;
68010: LD_ADDR_VAR 0 2
68014: PUSH
68015: LD_VAR 0 2
68019: PUSH
68020: LD_INT 1
68022: PLUS
68023: ST_TO_ADDR
68024: GO 68001
68026: POP
68027: POP
// end ;
68028: LD_VAR 0 2
68032: RET
// export function IsEmpty ( building ) ; begin
68033: LD_INT 0
68035: PPUSH
// if not building then
68036: LD_VAR 0 1
68040: NOT
68041: IFFALSE 68045
// exit ;
68043: GO 68088
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68045: LD_ADDR_VAR 0 2
68049: PUSH
68050: LD_VAR 0 1
68054: PUSH
68055: LD_INT 22
68057: PUSH
68058: LD_VAR 0 1
68062: PPUSH
68063: CALL_OW 255
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: PUSH
68072: LD_INT 58
68074: PUSH
68075: EMPTY
68076: LIST
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PPUSH
68082: CALL_OW 69
68086: IN
68087: ST_TO_ADDR
// end ;
68088: LD_VAR 0 2
68092: RET
// export function IsNotFull ( building ) ; begin
68093: LD_INT 0
68095: PPUSH
// if not building then
68096: LD_VAR 0 1
68100: NOT
68101: IFFALSE 68105
// exit ;
68103: GO 68124
// result := UnitsInside ( building ) < 6 ;
68105: LD_ADDR_VAR 0 2
68109: PUSH
68110: LD_VAR 0 1
68114: PPUSH
68115: CALL_OW 313
68119: PUSH
68120: LD_INT 6
68122: LESS
68123: ST_TO_ADDR
// end ;
68124: LD_VAR 0 2
68128: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68129: LD_INT 0
68131: PPUSH
68132: PPUSH
68133: PPUSH
68134: PPUSH
// tmp := [ ] ;
68135: LD_ADDR_VAR 0 3
68139: PUSH
68140: EMPTY
68141: ST_TO_ADDR
// list := [ ] ;
68142: LD_ADDR_VAR 0 5
68146: PUSH
68147: EMPTY
68148: ST_TO_ADDR
// for i = 16 to 25 do
68149: LD_ADDR_VAR 0 4
68153: PUSH
68154: DOUBLE
68155: LD_INT 16
68157: DEC
68158: ST_TO_ADDR
68159: LD_INT 25
68161: PUSH
68162: FOR_TO
68163: IFFALSE 68236
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68165: LD_ADDR_VAR 0 3
68169: PUSH
68170: LD_VAR 0 3
68174: PUSH
68175: LD_INT 22
68177: PUSH
68178: LD_VAR 0 1
68182: PPUSH
68183: CALL_OW 255
68187: PUSH
68188: EMPTY
68189: LIST
68190: LIST
68191: PUSH
68192: LD_INT 91
68194: PUSH
68195: LD_VAR 0 1
68199: PUSH
68200: LD_INT 6
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 30
68210: PUSH
68211: LD_VAR 0 4
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: LIST
68224: PUSH
68225: EMPTY
68226: LIST
68227: PPUSH
68228: CALL_OW 69
68232: ADD
68233: ST_TO_ADDR
68234: GO 68162
68236: POP
68237: POP
// for i = 1 to tmp do
68238: LD_ADDR_VAR 0 4
68242: PUSH
68243: DOUBLE
68244: LD_INT 1
68246: DEC
68247: ST_TO_ADDR
68248: LD_VAR 0 3
68252: PUSH
68253: FOR_TO
68254: IFFALSE 68342
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68256: LD_ADDR_VAR 0 5
68260: PUSH
68261: LD_VAR 0 5
68265: PUSH
68266: LD_VAR 0 3
68270: PUSH
68271: LD_VAR 0 4
68275: ARRAY
68276: PPUSH
68277: CALL_OW 266
68281: PUSH
68282: LD_VAR 0 3
68286: PUSH
68287: LD_VAR 0 4
68291: ARRAY
68292: PPUSH
68293: CALL_OW 250
68297: PUSH
68298: LD_VAR 0 3
68302: PUSH
68303: LD_VAR 0 4
68307: ARRAY
68308: PPUSH
68309: CALL_OW 251
68313: PUSH
68314: LD_VAR 0 3
68318: PUSH
68319: LD_VAR 0 4
68323: ARRAY
68324: PPUSH
68325: CALL_OW 254
68329: PUSH
68330: EMPTY
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: PUSH
68336: EMPTY
68337: LIST
68338: ADD
68339: ST_TO_ADDR
68340: GO 68253
68342: POP
68343: POP
// result := list ;
68344: LD_ADDR_VAR 0 2
68348: PUSH
68349: LD_VAR 0 5
68353: ST_TO_ADDR
// end ;
68354: LD_VAR 0 2
68358: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68359: LD_INT 0
68361: PPUSH
68362: PPUSH
68363: PPUSH
68364: PPUSH
68365: PPUSH
68366: PPUSH
68367: PPUSH
// if not factory then
68368: LD_VAR 0 1
68372: NOT
68373: IFFALSE 68377
// exit ;
68375: GO 68970
// if control = control_apeman then
68377: LD_VAR 0 4
68381: PUSH
68382: LD_INT 5
68384: EQUAL
68385: IFFALSE 68494
// begin tmp := UnitsInside ( factory ) ;
68387: LD_ADDR_VAR 0 8
68391: PUSH
68392: LD_VAR 0 1
68396: PPUSH
68397: CALL_OW 313
68401: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68402: LD_VAR 0 8
68406: PPUSH
68407: LD_INT 25
68409: PUSH
68410: LD_INT 12
68412: PUSH
68413: EMPTY
68414: LIST
68415: LIST
68416: PPUSH
68417: CALL_OW 72
68421: NOT
68422: IFFALSE 68432
// control := control_manual ;
68424: LD_ADDR_VAR 0 4
68428: PUSH
68429: LD_INT 1
68431: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68432: LD_ADDR_VAR 0 8
68436: PUSH
68437: LD_VAR 0 1
68441: PPUSH
68442: CALL 68129 0 1
68446: ST_TO_ADDR
// if tmp then
68447: LD_VAR 0 8
68451: IFFALSE 68494
// begin for i in tmp do
68453: LD_ADDR_VAR 0 7
68457: PUSH
68458: LD_VAR 0 8
68462: PUSH
68463: FOR_IN
68464: IFFALSE 68492
// if i [ 1 ] = b_ext_radio then
68466: LD_VAR 0 7
68470: PUSH
68471: LD_INT 1
68473: ARRAY
68474: PUSH
68475: LD_INT 22
68477: EQUAL
68478: IFFALSE 68490
// begin control := control_remote ;
68480: LD_ADDR_VAR 0 4
68484: PUSH
68485: LD_INT 2
68487: ST_TO_ADDR
// break ;
68488: GO 68492
// end ;
68490: GO 68463
68492: POP
68493: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68494: LD_VAR 0 1
68498: PPUSH
68499: LD_VAR 0 2
68503: PPUSH
68504: LD_VAR 0 3
68508: PPUSH
68509: LD_VAR 0 4
68513: PPUSH
68514: LD_VAR 0 5
68518: PPUSH
68519: CALL_OW 448
68523: IFFALSE 68558
// begin result := [ chassis , engine , control , weapon ] ;
68525: LD_ADDR_VAR 0 6
68529: PUSH
68530: LD_VAR 0 2
68534: PUSH
68535: LD_VAR 0 3
68539: PUSH
68540: LD_VAR 0 4
68544: PUSH
68545: LD_VAR 0 5
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: ST_TO_ADDR
// exit ;
68556: GO 68970
// end ; _chassis := AvailableChassisList ( factory ) ;
68558: LD_ADDR_VAR 0 9
68562: PUSH
68563: LD_VAR 0 1
68567: PPUSH
68568: CALL_OW 475
68572: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68573: LD_ADDR_VAR 0 11
68577: PUSH
68578: LD_VAR 0 1
68582: PPUSH
68583: CALL_OW 476
68587: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68588: LD_ADDR_VAR 0 12
68592: PUSH
68593: LD_VAR 0 1
68597: PPUSH
68598: CALL_OW 477
68602: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68603: LD_ADDR_VAR 0 10
68607: PUSH
68608: LD_VAR 0 1
68612: PPUSH
68613: CALL_OW 478
68617: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68618: LD_VAR 0 9
68622: NOT
68623: PUSH
68624: LD_VAR 0 11
68628: NOT
68629: OR
68630: PUSH
68631: LD_VAR 0 12
68635: NOT
68636: OR
68637: PUSH
68638: LD_VAR 0 10
68642: NOT
68643: OR
68644: IFFALSE 68679
// begin result := [ chassis , engine , control , weapon ] ;
68646: LD_ADDR_VAR 0 6
68650: PUSH
68651: LD_VAR 0 2
68655: PUSH
68656: LD_VAR 0 3
68660: PUSH
68661: LD_VAR 0 4
68665: PUSH
68666: LD_VAR 0 5
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: ST_TO_ADDR
// exit ;
68677: GO 68970
// end ; if not chassis in _chassis then
68679: LD_VAR 0 2
68683: PUSH
68684: LD_VAR 0 9
68688: IN
68689: NOT
68690: IFFALSE 68716
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68692: LD_ADDR_VAR 0 2
68696: PUSH
68697: LD_VAR 0 9
68701: PUSH
68702: LD_INT 1
68704: PPUSH
68705: LD_VAR 0 9
68709: PPUSH
68710: CALL_OW 12
68714: ARRAY
68715: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68716: LD_VAR 0 2
68720: PPUSH
68721: LD_VAR 0 3
68725: PPUSH
68726: CALL 68975 0 2
68730: NOT
68731: IFFALSE 68790
// repeat engine := _engine [ 1 ] ;
68733: LD_ADDR_VAR 0 3
68737: PUSH
68738: LD_VAR 0 11
68742: PUSH
68743: LD_INT 1
68745: ARRAY
68746: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68747: LD_ADDR_VAR 0 11
68751: PUSH
68752: LD_VAR 0 11
68756: PPUSH
68757: LD_INT 1
68759: PPUSH
68760: CALL_OW 3
68764: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68765: LD_VAR 0 2
68769: PPUSH
68770: LD_VAR 0 3
68774: PPUSH
68775: CALL 68975 0 2
68779: PUSH
68780: LD_VAR 0 11
68784: PUSH
68785: EMPTY
68786: EQUAL
68787: OR
68788: IFFALSE 68733
// if not control in _control then
68790: LD_VAR 0 4
68794: PUSH
68795: LD_VAR 0 12
68799: IN
68800: NOT
68801: IFFALSE 68827
// control := _control [ rand ( 1 , _control ) ] ;
68803: LD_ADDR_VAR 0 4
68807: PUSH
68808: LD_VAR 0 12
68812: PUSH
68813: LD_INT 1
68815: PPUSH
68816: LD_VAR 0 12
68820: PPUSH
68821: CALL_OW 12
68825: ARRAY
68826: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68827: LD_VAR 0 2
68831: PPUSH
68832: LD_VAR 0 5
68836: PPUSH
68837: CALL 69195 0 2
68841: NOT
68842: IFFALSE 68901
// repeat weapon := _weapon [ 1 ] ;
68844: LD_ADDR_VAR 0 5
68848: PUSH
68849: LD_VAR 0 10
68853: PUSH
68854: LD_INT 1
68856: ARRAY
68857: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68858: LD_ADDR_VAR 0 10
68862: PUSH
68863: LD_VAR 0 10
68867: PPUSH
68868: LD_INT 1
68870: PPUSH
68871: CALL_OW 3
68875: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68876: LD_VAR 0 2
68880: PPUSH
68881: LD_VAR 0 5
68885: PPUSH
68886: CALL 69195 0 2
68890: PUSH
68891: LD_VAR 0 10
68895: PUSH
68896: EMPTY
68897: EQUAL
68898: OR
68899: IFFALSE 68844
// result := [ ] ;
68901: LD_ADDR_VAR 0 6
68905: PUSH
68906: EMPTY
68907: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68908: LD_VAR 0 1
68912: PPUSH
68913: LD_VAR 0 2
68917: PPUSH
68918: LD_VAR 0 3
68922: PPUSH
68923: LD_VAR 0 4
68927: PPUSH
68928: LD_VAR 0 5
68932: PPUSH
68933: CALL_OW 448
68937: IFFALSE 68970
// result := [ chassis , engine , control , weapon ] ;
68939: LD_ADDR_VAR 0 6
68943: PUSH
68944: LD_VAR 0 2
68948: PUSH
68949: LD_VAR 0 3
68953: PUSH
68954: LD_VAR 0 4
68958: PUSH
68959: LD_VAR 0 5
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: ST_TO_ADDR
// end ;
68970: LD_VAR 0 6
68974: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68975: LD_INT 0
68977: PPUSH
// if not chassis or not engine then
68978: LD_VAR 0 1
68982: NOT
68983: PUSH
68984: LD_VAR 0 2
68988: NOT
68989: OR
68990: IFFALSE 68994
// exit ;
68992: GO 69190
// case engine of engine_solar :
68994: LD_VAR 0 2
68998: PUSH
68999: LD_INT 2
69001: DOUBLE
69002: EQUAL
69003: IFTRUE 69007
69005: GO 69045
69007: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69008: LD_ADDR_VAR 0 3
69012: PUSH
69013: LD_INT 11
69015: PUSH
69016: LD_INT 12
69018: PUSH
69019: LD_INT 13
69021: PUSH
69022: LD_INT 14
69024: PUSH
69025: LD_INT 1
69027: PUSH
69028: LD_INT 2
69030: PUSH
69031: LD_INT 3
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: ST_TO_ADDR
69043: GO 69174
69045: LD_INT 1
69047: DOUBLE
69048: EQUAL
69049: IFTRUE 69053
69051: GO 69115
69053: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69054: LD_ADDR_VAR 0 3
69058: PUSH
69059: LD_INT 11
69061: PUSH
69062: LD_INT 12
69064: PUSH
69065: LD_INT 13
69067: PUSH
69068: LD_INT 14
69070: PUSH
69071: LD_INT 1
69073: PUSH
69074: LD_INT 2
69076: PUSH
69077: LD_INT 3
69079: PUSH
69080: LD_INT 4
69082: PUSH
69083: LD_INT 5
69085: PUSH
69086: LD_INT 21
69088: PUSH
69089: LD_INT 23
69091: PUSH
69092: LD_INT 22
69094: PUSH
69095: LD_INT 24
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: LIST
69102: LIST
69103: LIST
69104: LIST
69105: LIST
69106: LIST
69107: LIST
69108: LIST
69109: LIST
69110: LIST
69111: LIST
69112: ST_TO_ADDR
69113: GO 69174
69115: LD_INT 3
69117: DOUBLE
69118: EQUAL
69119: IFTRUE 69123
69121: GO 69173
69123: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69124: LD_ADDR_VAR 0 3
69128: PUSH
69129: LD_INT 13
69131: PUSH
69132: LD_INT 14
69134: PUSH
69135: LD_INT 2
69137: PUSH
69138: LD_INT 3
69140: PUSH
69141: LD_INT 4
69143: PUSH
69144: LD_INT 5
69146: PUSH
69147: LD_INT 21
69149: PUSH
69150: LD_INT 22
69152: PUSH
69153: LD_INT 23
69155: PUSH
69156: LD_INT 24
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: ST_TO_ADDR
69171: GO 69174
69173: POP
// result := ( chassis in result ) ;
69174: LD_ADDR_VAR 0 3
69178: PUSH
69179: LD_VAR 0 1
69183: PUSH
69184: LD_VAR 0 3
69188: IN
69189: ST_TO_ADDR
// end ;
69190: LD_VAR 0 3
69194: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69195: LD_INT 0
69197: PPUSH
// if not chassis or not weapon then
69198: LD_VAR 0 1
69202: NOT
69203: PUSH
69204: LD_VAR 0 2
69208: NOT
69209: OR
69210: IFFALSE 69214
// exit ;
69212: GO 70276
// case weapon of us_machine_gun :
69214: LD_VAR 0 2
69218: PUSH
69219: LD_INT 2
69221: DOUBLE
69222: EQUAL
69223: IFTRUE 69227
69225: GO 69257
69227: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69228: LD_ADDR_VAR 0 3
69232: PUSH
69233: LD_INT 1
69235: PUSH
69236: LD_INT 2
69238: PUSH
69239: LD_INT 3
69241: PUSH
69242: LD_INT 4
69244: PUSH
69245: LD_INT 5
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: LIST
69254: ST_TO_ADDR
69255: GO 70260
69257: LD_INT 3
69259: DOUBLE
69260: EQUAL
69261: IFTRUE 69265
69263: GO 69295
69265: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69266: LD_ADDR_VAR 0 3
69270: PUSH
69271: LD_INT 1
69273: PUSH
69274: LD_INT 2
69276: PUSH
69277: LD_INT 3
69279: PUSH
69280: LD_INT 4
69282: PUSH
69283: LD_INT 5
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: ST_TO_ADDR
69293: GO 70260
69295: LD_INT 11
69297: DOUBLE
69298: EQUAL
69299: IFTRUE 69303
69301: GO 69333
69303: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69304: LD_ADDR_VAR 0 3
69308: PUSH
69309: LD_INT 1
69311: PUSH
69312: LD_INT 2
69314: PUSH
69315: LD_INT 3
69317: PUSH
69318: LD_INT 4
69320: PUSH
69321: LD_INT 5
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: ST_TO_ADDR
69331: GO 70260
69333: LD_INT 4
69335: DOUBLE
69336: EQUAL
69337: IFTRUE 69341
69339: GO 69367
69341: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69342: LD_ADDR_VAR 0 3
69346: PUSH
69347: LD_INT 2
69349: PUSH
69350: LD_INT 3
69352: PUSH
69353: LD_INT 4
69355: PUSH
69356: LD_INT 5
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: ST_TO_ADDR
69365: GO 70260
69367: LD_INT 5
69369: DOUBLE
69370: EQUAL
69371: IFTRUE 69375
69373: GO 69401
69375: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69376: LD_ADDR_VAR 0 3
69380: PUSH
69381: LD_INT 2
69383: PUSH
69384: LD_INT 3
69386: PUSH
69387: LD_INT 4
69389: PUSH
69390: LD_INT 5
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: LIST
69397: LIST
69398: ST_TO_ADDR
69399: GO 70260
69401: LD_INT 9
69403: DOUBLE
69404: EQUAL
69405: IFTRUE 69409
69407: GO 69435
69409: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69410: LD_ADDR_VAR 0 3
69414: PUSH
69415: LD_INT 2
69417: PUSH
69418: LD_INT 3
69420: PUSH
69421: LD_INT 4
69423: PUSH
69424: LD_INT 5
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: ST_TO_ADDR
69433: GO 70260
69435: LD_INT 7
69437: DOUBLE
69438: EQUAL
69439: IFTRUE 69443
69441: GO 69469
69443: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69444: LD_ADDR_VAR 0 3
69448: PUSH
69449: LD_INT 2
69451: PUSH
69452: LD_INT 3
69454: PUSH
69455: LD_INT 4
69457: PUSH
69458: LD_INT 5
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: ST_TO_ADDR
69467: GO 70260
69469: LD_INT 12
69471: DOUBLE
69472: EQUAL
69473: IFTRUE 69477
69475: GO 69503
69477: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69478: LD_ADDR_VAR 0 3
69482: PUSH
69483: LD_INT 2
69485: PUSH
69486: LD_INT 3
69488: PUSH
69489: LD_INT 4
69491: PUSH
69492: LD_INT 5
69494: PUSH
69495: EMPTY
69496: LIST
69497: LIST
69498: LIST
69499: LIST
69500: ST_TO_ADDR
69501: GO 70260
69503: LD_INT 13
69505: DOUBLE
69506: EQUAL
69507: IFTRUE 69511
69509: GO 69537
69511: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69512: LD_ADDR_VAR 0 3
69516: PUSH
69517: LD_INT 2
69519: PUSH
69520: LD_INT 3
69522: PUSH
69523: LD_INT 4
69525: PUSH
69526: LD_INT 5
69528: PUSH
69529: EMPTY
69530: LIST
69531: LIST
69532: LIST
69533: LIST
69534: ST_TO_ADDR
69535: GO 70260
69537: LD_INT 14
69539: DOUBLE
69540: EQUAL
69541: IFTRUE 69545
69543: GO 69563
69545: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69546: LD_ADDR_VAR 0 3
69550: PUSH
69551: LD_INT 4
69553: PUSH
69554: LD_INT 5
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: ST_TO_ADDR
69561: GO 70260
69563: LD_INT 6
69565: DOUBLE
69566: EQUAL
69567: IFTRUE 69571
69569: GO 69589
69571: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69572: LD_ADDR_VAR 0 3
69576: PUSH
69577: LD_INT 4
69579: PUSH
69580: LD_INT 5
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: ST_TO_ADDR
69587: GO 70260
69589: LD_INT 10
69591: DOUBLE
69592: EQUAL
69593: IFTRUE 69597
69595: GO 69615
69597: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69598: LD_ADDR_VAR 0 3
69602: PUSH
69603: LD_INT 4
69605: PUSH
69606: LD_INT 5
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: ST_TO_ADDR
69613: GO 70260
69615: LD_INT 22
69617: DOUBLE
69618: EQUAL
69619: IFTRUE 69623
69621: GO 69649
69623: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69624: LD_ADDR_VAR 0 3
69628: PUSH
69629: LD_INT 11
69631: PUSH
69632: LD_INT 12
69634: PUSH
69635: LD_INT 13
69637: PUSH
69638: LD_INT 14
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: ST_TO_ADDR
69647: GO 70260
69649: LD_INT 23
69651: DOUBLE
69652: EQUAL
69653: IFTRUE 69657
69655: GO 69683
69657: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69658: LD_ADDR_VAR 0 3
69662: PUSH
69663: LD_INT 11
69665: PUSH
69666: LD_INT 12
69668: PUSH
69669: LD_INT 13
69671: PUSH
69672: LD_INT 14
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: ST_TO_ADDR
69681: GO 70260
69683: LD_INT 24
69685: DOUBLE
69686: EQUAL
69687: IFTRUE 69691
69689: GO 69717
69691: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69692: LD_ADDR_VAR 0 3
69696: PUSH
69697: LD_INT 11
69699: PUSH
69700: LD_INT 12
69702: PUSH
69703: LD_INT 13
69705: PUSH
69706: LD_INT 14
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: ST_TO_ADDR
69715: GO 70260
69717: LD_INT 30
69719: DOUBLE
69720: EQUAL
69721: IFTRUE 69725
69723: GO 69751
69725: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69726: LD_ADDR_VAR 0 3
69730: PUSH
69731: LD_INT 11
69733: PUSH
69734: LD_INT 12
69736: PUSH
69737: LD_INT 13
69739: PUSH
69740: LD_INT 14
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: ST_TO_ADDR
69749: GO 70260
69751: LD_INT 25
69753: DOUBLE
69754: EQUAL
69755: IFTRUE 69759
69757: GO 69777
69759: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69760: LD_ADDR_VAR 0 3
69764: PUSH
69765: LD_INT 13
69767: PUSH
69768: LD_INT 14
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: ST_TO_ADDR
69775: GO 70260
69777: LD_INT 27
69779: DOUBLE
69780: EQUAL
69781: IFTRUE 69785
69783: GO 69803
69785: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69786: LD_ADDR_VAR 0 3
69790: PUSH
69791: LD_INT 13
69793: PUSH
69794: LD_INT 14
69796: PUSH
69797: EMPTY
69798: LIST
69799: LIST
69800: ST_TO_ADDR
69801: GO 70260
69803: LD_EXP 100
69807: DOUBLE
69808: EQUAL
69809: IFTRUE 69813
69811: GO 69839
69813: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69814: LD_ADDR_VAR 0 3
69818: PUSH
69819: LD_INT 11
69821: PUSH
69822: LD_INT 12
69824: PUSH
69825: LD_INT 13
69827: PUSH
69828: LD_INT 14
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: LIST
69835: LIST
69836: ST_TO_ADDR
69837: GO 70260
69839: LD_INT 28
69841: DOUBLE
69842: EQUAL
69843: IFTRUE 69847
69845: GO 69865
69847: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69848: LD_ADDR_VAR 0 3
69852: PUSH
69853: LD_INT 13
69855: PUSH
69856: LD_INT 14
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: ST_TO_ADDR
69863: GO 70260
69865: LD_INT 29
69867: DOUBLE
69868: EQUAL
69869: IFTRUE 69873
69871: GO 69891
69873: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69874: LD_ADDR_VAR 0 3
69878: PUSH
69879: LD_INT 13
69881: PUSH
69882: LD_INT 14
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: ST_TO_ADDR
69889: GO 70260
69891: LD_INT 31
69893: DOUBLE
69894: EQUAL
69895: IFTRUE 69899
69897: GO 69917
69899: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69900: LD_ADDR_VAR 0 3
69904: PUSH
69905: LD_INT 13
69907: PUSH
69908: LD_INT 14
69910: PUSH
69911: EMPTY
69912: LIST
69913: LIST
69914: ST_TO_ADDR
69915: GO 70260
69917: LD_INT 26
69919: DOUBLE
69920: EQUAL
69921: IFTRUE 69925
69923: GO 69943
69925: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69926: LD_ADDR_VAR 0 3
69930: PUSH
69931: LD_INT 13
69933: PUSH
69934: LD_INT 14
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: ST_TO_ADDR
69941: GO 70260
69943: LD_INT 42
69945: DOUBLE
69946: EQUAL
69947: IFTRUE 69951
69949: GO 69977
69951: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69952: LD_ADDR_VAR 0 3
69956: PUSH
69957: LD_INT 21
69959: PUSH
69960: LD_INT 22
69962: PUSH
69963: LD_INT 23
69965: PUSH
69966: LD_INT 24
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: ST_TO_ADDR
69975: GO 70260
69977: LD_INT 43
69979: DOUBLE
69980: EQUAL
69981: IFTRUE 69985
69983: GO 70011
69985: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69986: LD_ADDR_VAR 0 3
69990: PUSH
69991: LD_INT 21
69993: PUSH
69994: LD_INT 22
69996: PUSH
69997: LD_INT 23
69999: PUSH
70000: LD_INT 24
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: ST_TO_ADDR
70009: GO 70260
70011: LD_INT 44
70013: DOUBLE
70014: EQUAL
70015: IFTRUE 70019
70017: GO 70045
70019: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70020: LD_ADDR_VAR 0 3
70024: PUSH
70025: LD_INT 21
70027: PUSH
70028: LD_INT 22
70030: PUSH
70031: LD_INT 23
70033: PUSH
70034: LD_INT 24
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: ST_TO_ADDR
70043: GO 70260
70045: LD_INT 45
70047: DOUBLE
70048: EQUAL
70049: IFTRUE 70053
70051: GO 70079
70053: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70054: LD_ADDR_VAR 0 3
70058: PUSH
70059: LD_INT 21
70061: PUSH
70062: LD_INT 22
70064: PUSH
70065: LD_INT 23
70067: PUSH
70068: LD_INT 24
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: ST_TO_ADDR
70077: GO 70260
70079: LD_INT 49
70081: DOUBLE
70082: EQUAL
70083: IFTRUE 70087
70085: GO 70113
70087: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70088: LD_ADDR_VAR 0 3
70092: PUSH
70093: LD_INT 21
70095: PUSH
70096: LD_INT 22
70098: PUSH
70099: LD_INT 23
70101: PUSH
70102: LD_INT 24
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: ST_TO_ADDR
70111: GO 70260
70113: LD_INT 51
70115: DOUBLE
70116: EQUAL
70117: IFTRUE 70121
70119: GO 70147
70121: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70122: LD_ADDR_VAR 0 3
70126: PUSH
70127: LD_INT 21
70129: PUSH
70130: LD_INT 22
70132: PUSH
70133: LD_INT 23
70135: PUSH
70136: LD_INT 24
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: LIST
70143: LIST
70144: ST_TO_ADDR
70145: GO 70260
70147: LD_INT 52
70149: DOUBLE
70150: EQUAL
70151: IFTRUE 70155
70153: GO 70181
70155: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70156: LD_ADDR_VAR 0 3
70160: PUSH
70161: LD_INT 21
70163: PUSH
70164: LD_INT 22
70166: PUSH
70167: LD_INT 23
70169: PUSH
70170: LD_INT 24
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: LIST
70177: LIST
70178: ST_TO_ADDR
70179: GO 70260
70181: LD_INT 53
70183: DOUBLE
70184: EQUAL
70185: IFTRUE 70189
70187: GO 70207
70189: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70190: LD_ADDR_VAR 0 3
70194: PUSH
70195: LD_INT 23
70197: PUSH
70198: LD_INT 24
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: ST_TO_ADDR
70205: GO 70260
70207: LD_INT 46
70209: DOUBLE
70210: EQUAL
70211: IFTRUE 70215
70213: GO 70233
70215: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70216: LD_ADDR_VAR 0 3
70220: PUSH
70221: LD_INT 23
70223: PUSH
70224: LD_INT 24
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: ST_TO_ADDR
70231: GO 70260
70233: LD_INT 47
70235: DOUBLE
70236: EQUAL
70237: IFTRUE 70241
70239: GO 70259
70241: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70242: LD_ADDR_VAR 0 3
70246: PUSH
70247: LD_INT 23
70249: PUSH
70250: LD_INT 24
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: ST_TO_ADDR
70257: GO 70260
70259: POP
// result := ( chassis in result ) ;
70260: LD_ADDR_VAR 0 3
70264: PUSH
70265: LD_VAR 0 1
70269: PUSH
70270: LD_VAR 0 3
70274: IN
70275: ST_TO_ADDR
// end ;
70276: LD_VAR 0 3
70280: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70281: LD_INT 0
70283: PPUSH
70284: PPUSH
70285: PPUSH
70286: PPUSH
70287: PPUSH
70288: PPUSH
70289: PPUSH
// result := array ;
70290: LD_ADDR_VAR 0 5
70294: PUSH
70295: LD_VAR 0 1
70299: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70300: LD_VAR 0 1
70304: NOT
70305: PUSH
70306: LD_VAR 0 2
70310: NOT
70311: OR
70312: PUSH
70313: LD_VAR 0 3
70317: NOT
70318: OR
70319: PUSH
70320: LD_VAR 0 2
70324: PUSH
70325: LD_VAR 0 1
70329: GREATER
70330: OR
70331: PUSH
70332: LD_VAR 0 3
70336: PUSH
70337: LD_VAR 0 1
70341: GREATER
70342: OR
70343: IFFALSE 70347
// exit ;
70345: GO 70643
// if direction then
70347: LD_VAR 0 4
70351: IFFALSE 70415
// begin d := 1 ;
70353: LD_ADDR_VAR 0 9
70357: PUSH
70358: LD_INT 1
70360: ST_TO_ADDR
// if i_from > i_to then
70361: LD_VAR 0 2
70365: PUSH
70366: LD_VAR 0 3
70370: GREATER
70371: IFFALSE 70397
// length := ( array - i_from ) + i_to else
70373: LD_ADDR_VAR 0 11
70377: PUSH
70378: LD_VAR 0 1
70382: PUSH
70383: LD_VAR 0 2
70387: MINUS
70388: PUSH
70389: LD_VAR 0 3
70393: PLUS
70394: ST_TO_ADDR
70395: GO 70413
// length := i_to - i_from ;
70397: LD_ADDR_VAR 0 11
70401: PUSH
70402: LD_VAR 0 3
70406: PUSH
70407: LD_VAR 0 2
70411: MINUS
70412: ST_TO_ADDR
// end else
70413: GO 70476
// begin d := - 1 ;
70415: LD_ADDR_VAR 0 9
70419: PUSH
70420: LD_INT 1
70422: NEG
70423: ST_TO_ADDR
// if i_from > i_to then
70424: LD_VAR 0 2
70428: PUSH
70429: LD_VAR 0 3
70433: GREATER
70434: IFFALSE 70454
// length := i_from - i_to else
70436: LD_ADDR_VAR 0 11
70440: PUSH
70441: LD_VAR 0 2
70445: PUSH
70446: LD_VAR 0 3
70450: MINUS
70451: ST_TO_ADDR
70452: GO 70476
// length := ( array - i_to ) + i_from ;
70454: LD_ADDR_VAR 0 11
70458: PUSH
70459: LD_VAR 0 1
70463: PUSH
70464: LD_VAR 0 3
70468: MINUS
70469: PUSH
70470: LD_VAR 0 2
70474: PLUS
70475: ST_TO_ADDR
// end ; if not length then
70476: LD_VAR 0 11
70480: NOT
70481: IFFALSE 70485
// exit ;
70483: GO 70643
// tmp := array ;
70485: LD_ADDR_VAR 0 10
70489: PUSH
70490: LD_VAR 0 1
70494: ST_TO_ADDR
// for i = 1 to length do
70495: LD_ADDR_VAR 0 6
70499: PUSH
70500: DOUBLE
70501: LD_INT 1
70503: DEC
70504: ST_TO_ADDR
70505: LD_VAR 0 11
70509: PUSH
70510: FOR_TO
70511: IFFALSE 70631
// begin for j = 1 to array do
70513: LD_ADDR_VAR 0 7
70517: PUSH
70518: DOUBLE
70519: LD_INT 1
70521: DEC
70522: ST_TO_ADDR
70523: LD_VAR 0 1
70527: PUSH
70528: FOR_TO
70529: IFFALSE 70617
// begin k := j + d ;
70531: LD_ADDR_VAR 0 8
70535: PUSH
70536: LD_VAR 0 7
70540: PUSH
70541: LD_VAR 0 9
70545: PLUS
70546: ST_TO_ADDR
// if k > array then
70547: LD_VAR 0 8
70551: PUSH
70552: LD_VAR 0 1
70556: GREATER
70557: IFFALSE 70567
// k := 1 ;
70559: LD_ADDR_VAR 0 8
70563: PUSH
70564: LD_INT 1
70566: ST_TO_ADDR
// if not k then
70567: LD_VAR 0 8
70571: NOT
70572: IFFALSE 70584
// k := array ;
70574: LD_ADDR_VAR 0 8
70578: PUSH
70579: LD_VAR 0 1
70583: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70584: LD_ADDR_VAR 0 10
70588: PUSH
70589: LD_VAR 0 10
70593: PPUSH
70594: LD_VAR 0 8
70598: PPUSH
70599: LD_VAR 0 1
70603: PUSH
70604: LD_VAR 0 7
70608: ARRAY
70609: PPUSH
70610: CALL_OW 1
70614: ST_TO_ADDR
// end ;
70615: GO 70528
70617: POP
70618: POP
// array := tmp ;
70619: LD_ADDR_VAR 0 1
70623: PUSH
70624: LD_VAR 0 10
70628: ST_TO_ADDR
// end ;
70629: GO 70510
70631: POP
70632: POP
// result := array ;
70633: LD_ADDR_VAR 0 5
70637: PUSH
70638: LD_VAR 0 1
70642: ST_TO_ADDR
// end ;
70643: LD_VAR 0 5
70647: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70648: LD_INT 0
70650: PPUSH
70651: PPUSH
// result := 0 ;
70652: LD_ADDR_VAR 0 3
70656: PUSH
70657: LD_INT 0
70659: ST_TO_ADDR
// if not array or not value in array then
70660: LD_VAR 0 1
70664: NOT
70665: PUSH
70666: LD_VAR 0 2
70670: PUSH
70671: LD_VAR 0 1
70675: IN
70676: NOT
70677: OR
70678: IFFALSE 70682
// exit ;
70680: GO 70736
// for i = 1 to array do
70682: LD_ADDR_VAR 0 4
70686: PUSH
70687: DOUBLE
70688: LD_INT 1
70690: DEC
70691: ST_TO_ADDR
70692: LD_VAR 0 1
70696: PUSH
70697: FOR_TO
70698: IFFALSE 70734
// if value = array [ i ] then
70700: LD_VAR 0 2
70704: PUSH
70705: LD_VAR 0 1
70709: PUSH
70710: LD_VAR 0 4
70714: ARRAY
70715: EQUAL
70716: IFFALSE 70732
// begin result := i ;
70718: LD_ADDR_VAR 0 3
70722: PUSH
70723: LD_VAR 0 4
70727: ST_TO_ADDR
// exit ;
70728: POP
70729: POP
70730: GO 70736
// end ;
70732: GO 70697
70734: POP
70735: POP
// end ;
70736: LD_VAR 0 3
70740: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70741: LD_INT 0
70743: PPUSH
// vc_chassis := chassis ;
70744: LD_ADDR_OWVAR 37
70748: PUSH
70749: LD_VAR 0 1
70753: ST_TO_ADDR
// vc_engine := engine ;
70754: LD_ADDR_OWVAR 39
70758: PUSH
70759: LD_VAR 0 2
70763: ST_TO_ADDR
// vc_control := control ;
70764: LD_ADDR_OWVAR 38
70768: PUSH
70769: LD_VAR 0 3
70773: ST_TO_ADDR
// vc_weapon := weapon ;
70774: LD_ADDR_OWVAR 40
70778: PUSH
70779: LD_VAR 0 4
70783: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70784: LD_ADDR_OWVAR 41
70788: PUSH
70789: LD_VAR 0 5
70793: ST_TO_ADDR
// end ;
70794: LD_VAR 0 6
70798: RET
// export function WantPlant ( unit ) ; var task ; begin
70799: LD_INT 0
70801: PPUSH
70802: PPUSH
// result := false ;
70803: LD_ADDR_VAR 0 2
70807: PUSH
70808: LD_INT 0
70810: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70811: LD_ADDR_VAR 0 3
70815: PUSH
70816: LD_VAR 0 1
70820: PPUSH
70821: CALL_OW 437
70825: ST_TO_ADDR
// if task then
70826: LD_VAR 0 3
70830: IFFALSE 70858
// if task [ 1 ] [ 1 ] = p then
70832: LD_VAR 0 3
70836: PUSH
70837: LD_INT 1
70839: ARRAY
70840: PUSH
70841: LD_INT 1
70843: ARRAY
70844: PUSH
70845: LD_STRING p
70847: EQUAL
70848: IFFALSE 70858
// result := true ;
70850: LD_ADDR_VAR 0 2
70854: PUSH
70855: LD_INT 1
70857: ST_TO_ADDR
// end ;
70858: LD_VAR 0 2
70862: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70863: LD_INT 0
70865: PPUSH
70866: PPUSH
70867: PPUSH
70868: PPUSH
// if pos < 1 then
70869: LD_VAR 0 2
70873: PUSH
70874: LD_INT 1
70876: LESS
70877: IFFALSE 70881
// exit ;
70879: GO 71184
// if pos = 1 then
70881: LD_VAR 0 2
70885: PUSH
70886: LD_INT 1
70888: EQUAL
70889: IFFALSE 70922
// result := Replace ( arr , pos [ 1 ] , value ) else
70891: LD_ADDR_VAR 0 4
70895: PUSH
70896: LD_VAR 0 1
70900: PPUSH
70901: LD_VAR 0 2
70905: PUSH
70906: LD_INT 1
70908: ARRAY
70909: PPUSH
70910: LD_VAR 0 3
70914: PPUSH
70915: CALL_OW 1
70919: ST_TO_ADDR
70920: GO 71184
// begin tmp := arr ;
70922: LD_ADDR_VAR 0 6
70926: PUSH
70927: LD_VAR 0 1
70931: ST_TO_ADDR
// s_arr := [ tmp ] ;
70932: LD_ADDR_VAR 0 7
70936: PUSH
70937: LD_VAR 0 6
70941: PUSH
70942: EMPTY
70943: LIST
70944: ST_TO_ADDR
// for i = 1 to pos - 1 do
70945: LD_ADDR_VAR 0 5
70949: PUSH
70950: DOUBLE
70951: LD_INT 1
70953: DEC
70954: ST_TO_ADDR
70955: LD_VAR 0 2
70959: PUSH
70960: LD_INT 1
70962: MINUS
70963: PUSH
70964: FOR_TO
70965: IFFALSE 71010
// begin tmp := tmp [ pos [ i ] ] ;
70967: LD_ADDR_VAR 0 6
70971: PUSH
70972: LD_VAR 0 6
70976: PUSH
70977: LD_VAR 0 2
70981: PUSH
70982: LD_VAR 0 5
70986: ARRAY
70987: ARRAY
70988: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70989: LD_ADDR_VAR 0 7
70993: PUSH
70994: LD_VAR 0 7
70998: PUSH
70999: LD_VAR 0 6
71003: PUSH
71004: EMPTY
71005: LIST
71006: ADD
71007: ST_TO_ADDR
// end ;
71008: GO 70964
71010: POP
71011: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71012: LD_ADDR_VAR 0 6
71016: PUSH
71017: LD_VAR 0 6
71021: PPUSH
71022: LD_VAR 0 2
71026: PUSH
71027: LD_VAR 0 2
71031: ARRAY
71032: PPUSH
71033: LD_VAR 0 3
71037: PPUSH
71038: CALL_OW 1
71042: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71043: LD_ADDR_VAR 0 7
71047: PUSH
71048: LD_VAR 0 7
71052: PPUSH
71053: LD_VAR 0 7
71057: PPUSH
71058: LD_VAR 0 6
71062: PPUSH
71063: CALL_OW 1
71067: ST_TO_ADDR
// for i = s_arr downto 2 do
71068: LD_ADDR_VAR 0 5
71072: PUSH
71073: DOUBLE
71074: LD_VAR 0 7
71078: INC
71079: ST_TO_ADDR
71080: LD_INT 2
71082: PUSH
71083: FOR_DOWNTO
71084: IFFALSE 71168
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71086: LD_ADDR_VAR 0 6
71090: PUSH
71091: LD_VAR 0 7
71095: PUSH
71096: LD_VAR 0 5
71100: PUSH
71101: LD_INT 1
71103: MINUS
71104: ARRAY
71105: PPUSH
71106: LD_VAR 0 2
71110: PUSH
71111: LD_VAR 0 5
71115: PUSH
71116: LD_INT 1
71118: MINUS
71119: ARRAY
71120: PPUSH
71121: LD_VAR 0 7
71125: PUSH
71126: LD_VAR 0 5
71130: ARRAY
71131: PPUSH
71132: CALL_OW 1
71136: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71137: LD_ADDR_VAR 0 7
71141: PUSH
71142: LD_VAR 0 7
71146: PPUSH
71147: LD_VAR 0 5
71151: PUSH
71152: LD_INT 1
71154: MINUS
71155: PPUSH
71156: LD_VAR 0 6
71160: PPUSH
71161: CALL_OW 1
71165: ST_TO_ADDR
// end ;
71166: GO 71083
71168: POP
71169: POP
// result := s_arr [ 1 ] ;
71170: LD_ADDR_VAR 0 4
71174: PUSH
71175: LD_VAR 0 7
71179: PUSH
71180: LD_INT 1
71182: ARRAY
71183: ST_TO_ADDR
// end ; end ;
71184: LD_VAR 0 4
71188: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71189: LD_INT 0
71191: PPUSH
71192: PPUSH
// if not list then
71193: LD_VAR 0 1
71197: NOT
71198: IFFALSE 71202
// exit ;
71200: GO 71293
// i := list [ pos1 ] ;
71202: LD_ADDR_VAR 0 5
71206: PUSH
71207: LD_VAR 0 1
71211: PUSH
71212: LD_VAR 0 2
71216: ARRAY
71217: ST_TO_ADDR
// if not i then
71218: LD_VAR 0 5
71222: NOT
71223: IFFALSE 71227
// exit ;
71225: GO 71293
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71227: LD_ADDR_VAR 0 1
71231: PUSH
71232: LD_VAR 0 1
71236: PPUSH
71237: LD_VAR 0 2
71241: PPUSH
71242: LD_VAR 0 1
71246: PUSH
71247: LD_VAR 0 3
71251: ARRAY
71252: PPUSH
71253: CALL_OW 1
71257: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71258: LD_ADDR_VAR 0 1
71262: PUSH
71263: LD_VAR 0 1
71267: PPUSH
71268: LD_VAR 0 3
71272: PPUSH
71273: LD_VAR 0 5
71277: PPUSH
71278: CALL_OW 1
71282: ST_TO_ADDR
// result := list ;
71283: LD_ADDR_VAR 0 4
71287: PUSH
71288: LD_VAR 0 1
71292: ST_TO_ADDR
// end ;
71293: LD_VAR 0 4
71297: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71298: LD_INT 0
71300: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71301: LD_ADDR_VAR 0 5
71305: PUSH
71306: LD_VAR 0 1
71310: PPUSH
71311: CALL_OW 250
71315: PPUSH
71316: LD_VAR 0 1
71320: PPUSH
71321: CALL_OW 251
71325: PPUSH
71326: LD_VAR 0 2
71330: PPUSH
71331: LD_VAR 0 3
71335: PPUSH
71336: LD_VAR 0 4
71340: PPUSH
71341: CALL 71351 0 5
71345: ST_TO_ADDR
// end ;
71346: LD_VAR 0 5
71350: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71351: LD_INT 0
71353: PPUSH
71354: PPUSH
71355: PPUSH
71356: PPUSH
// if not list then
71357: LD_VAR 0 3
71361: NOT
71362: IFFALSE 71366
// exit ;
71364: GO 71754
// result := [ ] ;
71366: LD_ADDR_VAR 0 6
71370: PUSH
71371: EMPTY
71372: ST_TO_ADDR
// for i in list do
71373: LD_ADDR_VAR 0 7
71377: PUSH
71378: LD_VAR 0 3
71382: PUSH
71383: FOR_IN
71384: IFFALSE 71586
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71386: LD_ADDR_VAR 0 9
71390: PUSH
71391: LD_VAR 0 7
71395: PPUSH
71396: LD_VAR 0 1
71400: PPUSH
71401: LD_VAR 0 2
71405: PPUSH
71406: CALL_OW 297
71410: ST_TO_ADDR
// if not result then
71411: LD_VAR 0 6
71415: NOT
71416: IFFALSE 71442
// result := [ [ i , tmp ] ] else
71418: LD_ADDR_VAR 0 6
71422: PUSH
71423: LD_VAR 0 7
71427: PUSH
71428: LD_VAR 0 9
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: PUSH
71437: EMPTY
71438: LIST
71439: ST_TO_ADDR
71440: GO 71584
// begin if result [ result ] [ 2 ] < tmp then
71442: LD_VAR 0 6
71446: PUSH
71447: LD_VAR 0 6
71451: ARRAY
71452: PUSH
71453: LD_INT 2
71455: ARRAY
71456: PUSH
71457: LD_VAR 0 9
71461: LESS
71462: IFFALSE 71504
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71464: LD_ADDR_VAR 0 6
71468: PUSH
71469: LD_VAR 0 6
71473: PPUSH
71474: LD_VAR 0 6
71478: PUSH
71479: LD_INT 1
71481: PLUS
71482: PPUSH
71483: LD_VAR 0 7
71487: PUSH
71488: LD_VAR 0 9
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: PPUSH
71497: CALL_OW 2
71501: ST_TO_ADDR
71502: GO 71584
// for j = 1 to result do
71504: LD_ADDR_VAR 0 8
71508: PUSH
71509: DOUBLE
71510: LD_INT 1
71512: DEC
71513: ST_TO_ADDR
71514: LD_VAR 0 6
71518: PUSH
71519: FOR_TO
71520: IFFALSE 71582
// begin if tmp < result [ j ] [ 2 ] then
71522: LD_VAR 0 9
71526: PUSH
71527: LD_VAR 0 6
71531: PUSH
71532: LD_VAR 0 8
71536: ARRAY
71537: PUSH
71538: LD_INT 2
71540: ARRAY
71541: LESS
71542: IFFALSE 71580
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71544: LD_ADDR_VAR 0 6
71548: PUSH
71549: LD_VAR 0 6
71553: PPUSH
71554: LD_VAR 0 8
71558: PPUSH
71559: LD_VAR 0 7
71563: PUSH
71564: LD_VAR 0 9
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PPUSH
71573: CALL_OW 2
71577: ST_TO_ADDR
// break ;
71578: GO 71582
// end ; end ;
71580: GO 71519
71582: POP
71583: POP
// end ; end ;
71584: GO 71383
71586: POP
71587: POP
// if result and not asc then
71588: LD_VAR 0 6
71592: PUSH
71593: LD_VAR 0 4
71597: NOT
71598: AND
71599: IFFALSE 71674
// begin tmp := result ;
71601: LD_ADDR_VAR 0 9
71605: PUSH
71606: LD_VAR 0 6
71610: ST_TO_ADDR
// for i = tmp downto 1 do
71611: LD_ADDR_VAR 0 7
71615: PUSH
71616: DOUBLE
71617: LD_VAR 0 9
71621: INC
71622: ST_TO_ADDR
71623: LD_INT 1
71625: PUSH
71626: FOR_DOWNTO
71627: IFFALSE 71672
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71629: LD_ADDR_VAR 0 6
71633: PUSH
71634: LD_VAR 0 6
71638: PPUSH
71639: LD_VAR 0 9
71643: PUSH
71644: LD_VAR 0 7
71648: MINUS
71649: PUSH
71650: LD_INT 1
71652: PLUS
71653: PPUSH
71654: LD_VAR 0 9
71658: PUSH
71659: LD_VAR 0 7
71663: ARRAY
71664: PPUSH
71665: CALL_OW 1
71669: ST_TO_ADDR
71670: GO 71626
71672: POP
71673: POP
// end ; tmp := [ ] ;
71674: LD_ADDR_VAR 0 9
71678: PUSH
71679: EMPTY
71680: ST_TO_ADDR
// if mode then
71681: LD_VAR 0 5
71685: IFFALSE 71754
// begin for i = 1 to result do
71687: LD_ADDR_VAR 0 7
71691: PUSH
71692: DOUBLE
71693: LD_INT 1
71695: DEC
71696: ST_TO_ADDR
71697: LD_VAR 0 6
71701: PUSH
71702: FOR_TO
71703: IFFALSE 71742
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71705: LD_ADDR_VAR 0 9
71709: PUSH
71710: LD_VAR 0 9
71714: PPUSH
71715: LD_VAR 0 7
71719: PPUSH
71720: LD_VAR 0 6
71724: PUSH
71725: LD_VAR 0 7
71729: ARRAY
71730: PUSH
71731: LD_INT 1
71733: ARRAY
71734: PPUSH
71735: CALL_OW 1
71739: ST_TO_ADDR
71740: GO 71702
71742: POP
71743: POP
// result := tmp ;
71744: LD_ADDR_VAR 0 6
71748: PUSH
71749: LD_VAR 0 9
71753: ST_TO_ADDR
// end ; end ;
71754: LD_VAR 0 6
71758: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71759: LD_INT 0
71761: PPUSH
71762: PPUSH
71763: PPUSH
71764: PPUSH
71765: PPUSH
71766: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71767: LD_ADDR_VAR 0 5
71771: PUSH
71772: LD_INT 0
71774: PUSH
71775: LD_INT 0
71777: PUSH
71778: LD_INT 0
71780: PUSH
71781: EMPTY
71782: PUSH
71783: EMPTY
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: ST_TO_ADDR
// if not x or not y then
71789: LD_VAR 0 2
71793: NOT
71794: PUSH
71795: LD_VAR 0 3
71799: NOT
71800: OR
71801: IFFALSE 71805
// exit ;
71803: GO 73457
// if not range then
71805: LD_VAR 0 4
71809: NOT
71810: IFFALSE 71820
// range := 10 ;
71812: LD_ADDR_VAR 0 4
71816: PUSH
71817: LD_INT 10
71819: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71820: LD_ADDR_VAR 0 8
71824: PUSH
71825: LD_INT 81
71827: PUSH
71828: LD_VAR 0 1
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: LD_INT 92
71839: PUSH
71840: LD_VAR 0 2
71844: PUSH
71845: LD_VAR 0 3
71849: PUSH
71850: LD_VAR 0 4
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: PUSH
71861: LD_INT 3
71863: PUSH
71864: LD_INT 21
71866: PUSH
71867: LD_INT 3
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: LIST
71882: PPUSH
71883: CALL_OW 69
71887: ST_TO_ADDR
// if not tmp then
71888: LD_VAR 0 8
71892: NOT
71893: IFFALSE 71897
// exit ;
71895: GO 73457
// for i in tmp do
71897: LD_ADDR_VAR 0 6
71901: PUSH
71902: LD_VAR 0 8
71906: PUSH
71907: FOR_IN
71908: IFFALSE 73432
// begin points := [ 0 , 0 , 0 ] ;
71910: LD_ADDR_VAR 0 9
71914: PUSH
71915: LD_INT 0
71917: PUSH
71918: LD_INT 0
71920: PUSH
71921: LD_INT 0
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: LIST
71928: ST_TO_ADDR
// bpoints := 1 ;
71929: LD_ADDR_VAR 0 10
71933: PUSH
71934: LD_INT 1
71936: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71937: LD_VAR 0 6
71941: PPUSH
71942: CALL_OW 247
71946: PUSH
71947: LD_INT 1
71949: DOUBLE
71950: EQUAL
71951: IFTRUE 71955
71953: GO 72533
71955: POP
// begin if GetClass ( i ) = 1 then
71956: LD_VAR 0 6
71960: PPUSH
71961: CALL_OW 257
71965: PUSH
71966: LD_INT 1
71968: EQUAL
71969: IFFALSE 71990
// points := [ 10 , 5 , 3 ] ;
71971: LD_ADDR_VAR 0 9
71975: PUSH
71976: LD_INT 10
71978: PUSH
71979: LD_INT 5
71981: PUSH
71982: LD_INT 3
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: LIST
71989: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71990: LD_VAR 0 6
71994: PPUSH
71995: CALL_OW 257
71999: PUSH
72000: LD_INT 2
72002: PUSH
72003: LD_INT 3
72005: PUSH
72006: LD_INT 4
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: LIST
72013: IN
72014: IFFALSE 72035
// points := [ 3 , 2 , 1 ] ;
72016: LD_ADDR_VAR 0 9
72020: PUSH
72021: LD_INT 3
72023: PUSH
72024: LD_INT 2
72026: PUSH
72027: LD_INT 1
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: LIST
72034: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72035: LD_VAR 0 6
72039: PPUSH
72040: CALL_OW 257
72044: PUSH
72045: LD_INT 5
72047: EQUAL
72048: IFFALSE 72069
// points := [ 130 , 5 , 2 ] ;
72050: LD_ADDR_VAR 0 9
72054: PUSH
72055: LD_INT 130
72057: PUSH
72058: LD_INT 5
72060: PUSH
72061: LD_INT 2
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: LIST
72068: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72069: LD_VAR 0 6
72073: PPUSH
72074: CALL_OW 257
72078: PUSH
72079: LD_INT 8
72081: EQUAL
72082: IFFALSE 72103
// points := [ 35 , 35 , 30 ] ;
72084: LD_ADDR_VAR 0 9
72088: PUSH
72089: LD_INT 35
72091: PUSH
72092: LD_INT 35
72094: PUSH
72095: LD_INT 30
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: LIST
72102: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72103: LD_VAR 0 6
72107: PPUSH
72108: CALL_OW 257
72112: PUSH
72113: LD_INT 9
72115: EQUAL
72116: IFFALSE 72137
// points := [ 20 , 55 , 40 ] ;
72118: LD_ADDR_VAR 0 9
72122: PUSH
72123: LD_INT 20
72125: PUSH
72126: LD_INT 55
72128: PUSH
72129: LD_INT 40
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: LIST
72136: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72137: LD_VAR 0 6
72141: PPUSH
72142: CALL_OW 257
72146: PUSH
72147: LD_INT 12
72149: PUSH
72150: LD_INT 16
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: IN
72157: IFFALSE 72178
// points := [ 5 , 3 , 2 ] ;
72159: LD_ADDR_VAR 0 9
72163: PUSH
72164: LD_INT 5
72166: PUSH
72167: LD_INT 3
72169: PUSH
72170: LD_INT 2
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: LIST
72177: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72178: LD_VAR 0 6
72182: PPUSH
72183: CALL_OW 257
72187: PUSH
72188: LD_INT 17
72190: EQUAL
72191: IFFALSE 72212
// points := [ 100 , 50 , 75 ] ;
72193: LD_ADDR_VAR 0 9
72197: PUSH
72198: LD_INT 100
72200: PUSH
72201: LD_INT 50
72203: PUSH
72204: LD_INT 75
72206: PUSH
72207: EMPTY
72208: LIST
72209: LIST
72210: LIST
72211: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72212: LD_VAR 0 6
72216: PPUSH
72217: CALL_OW 257
72221: PUSH
72222: LD_INT 15
72224: EQUAL
72225: IFFALSE 72246
// points := [ 10 , 5 , 3 ] ;
72227: LD_ADDR_VAR 0 9
72231: PUSH
72232: LD_INT 10
72234: PUSH
72235: LD_INT 5
72237: PUSH
72238: LD_INT 3
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: LIST
72245: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72246: LD_VAR 0 6
72250: PPUSH
72251: CALL_OW 257
72255: PUSH
72256: LD_INT 14
72258: EQUAL
72259: IFFALSE 72280
// points := [ 10 , 0 , 0 ] ;
72261: LD_ADDR_VAR 0 9
72265: PUSH
72266: LD_INT 10
72268: PUSH
72269: LD_INT 0
72271: PUSH
72272: LD_INT 0
72274: PUSH
72275: EMPTY
72276: LIST
72277: LIST
72278: LIST
72279: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72280: LD_VAR 0 6
72284: PPUSH
72285: CALL_OW 257
72289: PUSH
72290: LD_INT 11
72292: EQUAL
72293: IFFALSE 72314
// points := [ 30 , 10 , 5 ] ;
72295: LD_ADDR_VAR 0 9
72299: PUSH
72300: LD_INT 30
72302: PUSH
72303: LD_INT 10
72305: PUSH
72306: LD_INT 5
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: LIST
72313: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72314: LD_VAR 0 1
72318: PPUSH
72319: LD_INT 5
72321: PPUSH
72322: CALL_OW 321
72326: PUSH
72327: LD_INT 2
72329: EQUAL
72330: IFFALSE 72347
// bpoints := bpoints * 1.8 ;
72332: LD_ADDR_VAR 0 10
72336: PUSH
72337: LD_VAR 0 10
72341: PUSH
72342: LD_REAL  1.80000000000000E+0000
72345: MUL
72346: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72347: LD_VAR 0 6
72351: PPUSH
72352: CALL_OW 257
72356: PUSH
72357: LD_INT 1
72359: PUSH
72360: LD_INT 2
72362: PUSH
72363: LD_INT 3
72365: PUSH
72366: LD_INT 4
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: IN
72375: PUSH
72376: LD_VAR 0 1
72380: PPUSH
72381: LD_INT 51
72383: PPUSH
72384: CALL_OW 321
72388: PUSH
72389: LD_INT 2
72391: EQUAL
72392: AND
72393: IFFALSE 72410
// bpoints := bpoints * 1.2 ;
72395: LD_ADDR_VAR 0 10
72399: PUSH
72400: LD_VAR 0 10
72404: PUSH
72405: LD_REAL  1.20000000000000E+0000
72408: MUL
72409: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72410: LD_VAR 0 6
72414: PPUSH
72415: CALL_OW 257
72419: PUSH
72420: LD_INT 5
72422: PUSH
72423: LD_INT 7
72425: PUSH
72426: LD_INT 9
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: LIST
72433: IN
72434: PUSH
72435: LD_VAR 0 1
72439: PPUSH
72440: LD_INT 52
72442: PPUSH
72443: CALL_OW 321
72447: PUSH
72448: LD_INT 2
72450: EQUAL
72451: AND
72452: IFFALSE 72469
// bpoints := bpoints * 1.5 ;
72454: LD_ADDR_VAR 0 10
72458: PUSH
72459: LD_VAR 0 10
72463: PUSH
72464: LD_REAL  1.50000000000000E+0000
72467: MUL
72468: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72469: LD_VAR 0 1
72473: PPUSH
72474: LD_INT 66
72476: PPUSH
72477: CALL_OW 321
72481: PUSH
72482: LD_INT 2
72484: EQUAL
72485: IFFALSE 72502
// bpoints := bpoints * 1.1 ;
72487: LD_ADDR_VAR 0 10
72491: PUSH
72492: LD_VAR 0 10
72496: PUSH
72497: LD_REAL  1.10000000000000E+0000
72500: MUL
72501: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72502: LD_ADDR_VAR 0 10
72506: PUSH
72507: LD_VAR 0 10
72511: PUSH
72512: LD_VAR 0 6
72516: PPUSH
72517: LD_INT 1
72519: PPUSH
72520: CALL_OW 259
72524: PUSH
72525: LD_REAL  1.15000000000000E+0000
72528: MUL
72529: MUL
72530: ST_TO_ADDR
// end ; unit_vehicle :
72531: GO 73361
72533: LD_INT 2
72535: DOUBLE
72536: EQUAL
72537: IFTRUE 72541
72539: GO 73349
72541: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72542: LD_VAR 0 6
72546: PPUSH
72547: CALL_OW 264
72551: PUSH
72552: LD_INT 2
72554: PUSH
72555: LD_INT 42
72557: PUSH
72558: LD_INT 24
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: LIST
72565: IN
72566: IFFALSE 72587
// points := [ 25 , 5 , 3 ] ;
72568: LD_ADDR_VAR 0 9
72572: PUSH
72573: LD_INT 25
72575: PUSH
72576: LD_INT 5
72578: PUSH
72579: LD_INT 3
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: LIST
72586: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72587: LD_VAR 0 6
72591: PPUSH
72592: CALL_OW 264
72596: PUSH
72597: LD_INT 4
72599: PUSH
72600: LD_INT 43
72602: PUSH
72603: LD_INT 25
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: LIST
72610: IN
72611: IFFALSE 72632
// points := [ 40 , 15 , 5 ] ;
72613: LD_ADDR_VAR 0 9
72617: PUSH
72618: LD_INT 40
72620: PUSH
72621: LD_INT 15
72623: PUSH
72624: LD_INT 5
72626: PUSH
72627: EMPTY
72628: LIST
72629: LIST
72630: LIST
72631: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72632: LD_VAR 0 6
72636: PPUSH
72637: CALL_OW 264
72641: PUSH
72642: LD_INT 3
72644: PUSH
72645: LD_INT 23
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: IN
72652: IFFALSE 72673
// points := [ 7 , 25 , 8 ] ;
72654: LD_ADDR_VAR 0 9
72658: PUSH
72659: LD_INT 7
72661: PUSH
72662: LD_INT 25
72664: PUSH
72665: LD_INT 8
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: LIST
72672: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72673: LD_VAR 0 6
72677: PPUSH
72678: CALL_OW 264
72682: PUSH
72683: LD_INT 5
72685: PUSH
72686: LD_INT 27
72688: PUSH
72689: LD_INT 44
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: LIST
72696: IN
72697: IFFALSE 72718
// points := [ 14 , 50 , 16 ] ;
72699: LD_ADDR_VAR 0 9
72703: PUSH
72704: LD_INT 14
72706: PUSH
72707: LD_INT 50
72709: PUSH
72710: LD_INT 16
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: LIST
72717: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72718: LD_VAR 0 6
72722: PPUSH
72723: CALL_OW 264
72727: PUSH
72728: LD_INT 6
72730: PUSH
72731: LD_INT 46
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: IN
72738: IFFALSE 72759
// points := [ 32 , 120 , 70 ] ;
72740: LD_ADDR_VAR 0 9
72744: PUSH
72745: LD_INT 32
72747: PUSH
72748: LD_INT 120
72750: PUSH
72751: LD_INT 70
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: LIST
72758: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72759: LD_VAR 0 6
72763: PPUSH
72764: CALL_OW 264
72768: PUSH
72769: LD_INT 7
72771: PUSH
72772: LD_INT 28
72774: PUSH
72775: LD_INT 45
72777: PUSH
72778: LD_EXP 100
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: LIST
72787: LIST
72788: IN
72789: IFFALSE 72810
// points := [ 35 , 20 , 45 ] ;
72791: LD_ADDR_VAR 0 9
72795: PUSH
72796: LD_INT 35
72798: PUSH
72799: LD_INT 20
72801: PUSH
72802: LD_INT 45
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: LIST
72809: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72810: LD_VAR 0 6
72814: PPUSH
72815: CALL_OW 264
72819: PUSH
72820: LD_INT 47
72822: PUSH
72823: EMPTY
72824: LIST
72825: IN
72826: IFFALSE 72847
// points := [ 67 , 45 , 75 ] ;
72828: LD_ADDR_VAR 0 9
72832: PUSH
72833: LD_INT 67
72835: PUSH
72836: LD_INT 45
72838: PUSH
72839: LD_INT 75
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: LIST
72846: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72847: LD_VAR 0 6
72851: PPUSH
72852: CALL_OW 264
72856: PUSH
72857: LD_INT 26
72859: PUSH
72860: EMPTY
72861: LIST
72862: IN
72863: IFFALSE 72884
// points := [ 120 , 30 , 80 ] ;
72865: LD_ADDR_VAR 0 9
72869: PUSH
72870: LD_INT 120
72872: PUSH
72873: LD_INT 30
72875: PUSH
72876: LD_INT 80
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: LIST
72883: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72884: LD_VAR 0 6
72888: PPUSH
72889: CALL_OW 264
72893: PUSH
72894: LD_INT 22
72896: PUSH
72897: EMPTY
72898: LIST
72899: IN
72900: IFFALSE 72921
// points := [ 40 , 1 , 1 ] ;
72902: LD_ADDR_VAR 0 9
72906: PUSH
72907: LD_INT 40
72909: PUSH
72910: LD_INT 1
72912: PUSH
72913: LD_INT 1
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: LIST
72920: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72921: LD_VAR 0 6
72925: PPUSH
72926: CALL_OW 264
72930: PUSH
72931: LD_INT 29
72933: PUSH
72934: EMPTY
72935: LIST
72936: IN
72937: IFFALSE 72958
// points := [ 70 , 200 , 400 ] ;
72939: LD_ADDR_VAR 0 9
72943: PUSH
72944: LD_INT 70
72946: PUSH
72947: LD_INT 200
72949: PUSH
72950: LD_INT 400
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: LIST
72957: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72958: LD_VAR 0 6
72962: PPUSH
72963: CALL_OW 264
72967: PUSH
72968: LD_INT 14
72970: PUSH
72971: LD_INT 53
72973: PUSH
72974: EMPTY
72975: LIST
72976: LIST
72977: IN
72978: IFFALSE 72999
// points := [ 40 , 10 , 20 ] ;
72980: LD_ADDR_VAR 0 9
72984: PUSH
72985: LD_INT 40
72987: PUSH
72988: LD_INT 10
72990: PUSH
72991: LD_INT 20
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: LIST
72998: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72999: LD_VAR 0 6
73003: PPUSH
73004: CALL_OW 264
73008: PUSH
73009: LD_INT 9
73011: PUSH
73012: EMPTY
73013: LIST
73014: IN
73015: IFFALSE 73036
// points := [ 5 , 70 , 20 ] ;
73017: LD_ADDR_VAR 0 9
73021: PUSH
73022: LD_INT 5
73024: PUSH
73025: LD_INT 70
73027: PUSH
73028: LD_INT 20
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: LIST
73035: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73036: LD_VAR 0 6
73040: PPUSH
73041: CALL_OW 264
73045: PUSH
73046: LD_INT 10
73048: PUSH
73049: EMPTY
73050: LIST
73051: IN
73052: IFFALSE 73073
// points := [ 35 , 110 , 70 ] ;
73054: LD_ADDR_VAR 0 9
73058: PUSH
73059: LD_INT 35
73061: PUSH
73062: LD_INT 110
73064: PUSH
73065: LD_INT 70
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: LIST
73072: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73073: LD_VAR 0 6
73077: PPUSH
73078: CALL_OW 265
73082: PUSH
73083: LD_INT 25
73085: EQUAL
73086: IFFALSE 73107
// points := [ 80 , 65 , 100 ] ;
73088: LD_ADDR_VAR 0 9
73092: PUSH
73093: LD_INT 80
73095: PUSH
73096: LD_INT 65
73098: PUSH
73099: LD_INT 100
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: LIST
73106: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73107: LD_VAR 0 6
73111: PPUSH
73112: CALL_OW 263
73116: PUSH
73117: LD_INT 1
73119: EQUAL
73120: IFFALSE 73155
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73122: LD_ADDR_VAR 0 10
73126: PUSH
73127: LD_VAR 0 10
73131: PUSH
73132: LD_VAR 0 6
73136: PPUSH
73137: CALL_OW 311
73141: PPUSH
73142: LD_INT 3
73144: PPUSH
73145: CALL_OW 259
73149: PUSH
73150: LD_INT 4
73152: MUL
73153: MUL
73154: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73155: LD_VAR 0 6
73159: PPUSH
73160: CALL_OW 263
73164: PUSH
73165: LD_INT 2
73167: EQUAL
73168: IFFALSE 73219
// begin j := IsControledBy ( i ) ;
73170: LD_ADDR_VAR 0 7
73174: PUSH
73175: LD_VAR 0 6
73179: PPUSH
73180: CALL_OW 312
73184: ST_TO_ADDR
// if j then
73185: LD_VAR 0 7
73189: IFFALSE 73219
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73191: LD_ADDR_VAR 0 10
73195: PUSH
73196: LD_VAR 0 10
73200: PUSH
73201: LD_VAR 0 7
73205: PPUSH
73206: LD_INT 3
73208: PPUSH
73209: CALL_OW 259
73213: PUSH
73214: LD_INT 3
73216: MUL
73217: MUL
73218: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73219: LD_VAR 0 6
73223: PPUSH
73224: CALL_OW 264
73228: PUSH
73229: LD_INT 5
73231: PUSH
73232: LD_INT 6
73234: PUSH
73235: LD_INT 46
73237: PUSH
73238: LD_INT 44
73240: PUSH
73241: LD_INT 47
73243: PUSH
73244: LD_INT 45
73246: PUSH
73247: LD_INT 28
73249: PUSH
73250: LD_INT 7
73252: PUSH
73253: LD_INT 27
73255: PUSH
73256: LD_INT 29
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: LIST
73263: LIST
73264: LIST
73265: LIST
73266: LIST
73267: LIST
73268: LIST
73269: LIST
73270: IN
73271: PUSH
73272: LD_VAR 0 1
73276: PPUSH
73277: LD_INT 52
73279: PPUSH
73280: CALL_OW 321
73284: PUSH
73285: LD_INT 2
73287: EQUAL
73288: AND
73289: IFFALSE 73306
// bpoints := bpoints * 1.2 ;
73291: LD_ADDR_VAR 0 10
73295: PUSH
73296: LD_VAR 0 10
73300: PUSH
73301: LD_REAL  1.20000000000000E+0000
73304: MUL
73305: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73306: LD_VAR 0 6
73310: PPUSH
73311: CALL_OW 264
73315: PUSH
73316: LD_INT 6
73318: PUSH
73319: LD_INT 46
73321: PUSH
73322: LD_INT 47
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: LIST
73329: IN
73330: IFFALSE 73347
// bpoints := bpoints * 1.2 ;
73332: LD_ADDR_VAR 0 10
73336: PUSH
73337: LD_VAR 0 10
73341: PUSH
73342: LD_REAL  1.20000000000000E+0000
73345: MUL
73346: ST_TO_ADDR
// end ; unit_building :
73347: GO 73361
73349: LD_INT 3
73351: DOUBLE
73352: EQUAL
73353: IFTRUE 73357
73355: GO 73360
73357: POP
// ; end ;
73358: GO 73361
73360: POP
// for j = 1 to 3 do
73361: LD_ADDR_VAR 0 7
73365: PUSH
73366: DOUBLE
73367: LD_INT 1
73369: DEC
73370: ST_TO_ADDR
73371: LD_INT 3
73373: PUSH
73374: FOR_TO
73375: IFFALSE 73428
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73377: LD_ADDR_VAR 0 5
73381: PUSH
73382: LD_VAR 0 5
73386: PPUSH
73387: LD_VAR 0 7
73391: PPUSH
73392: LD_VAR 0 5
73396: PUSH
73397: LD_VAR 0 7
73401: ARRAY
73402: PUSH
73403: LD_VAR 0 9
73407: PUSH
73408: LD_VAR 0 7
73412: ARRAY
73413: PUSH
73414: LD_VAR 0 10
73418: MUL
73419: PLUS
73420: PPUSH
73421: CALL_OW 1
73425: ST_TO_ADDR
73426: GO 73374
73428: POP
73429: POP
// end ;
73430: GO 71907
73432: POP
73433: POP
// result := Replace ( result , 4 , tmp ) ;
73434: LD_ADDR_VAR 0 5
73438: PUSH
73439: LD_VAR 0 5
73443: PPUSH
73444: LD_INT 4
73446: PPUSH
73447: LD_VAR 0 8
73451: PPUSH
73452: CALL_OW 1
73456: ST_TO_ADDR
// end ;
73457: LD_VAR 0 5
73461: RET
// export function DangerAtRange ( unit , range ) ; begin
73462: LD_INT 0
73464: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73465: LD_ADDR_VAR 0 3
73469: PUSH
73470: LD_VAR 0 1
73474: PPUSH
73475: CALL_OW 255
73479: PPUSH
73480: LD_VAR 0 1
73484: PPUSH
73485: CALL_OW 250
73489: PPUSH
73490: LD_VAR 0 1
73494: PPUSH
73495: CALL_OW 251
73499: PPUSH
73500: LD_VAR 0 2
73504: PPUSH
73505: CALL 71759 0 4
73509: ST_TO_ADDR
// end ;
73510: LD_VAR 0 3
73514: RET
// export function DangerInArea ( side , area ) ; begin
73515: LD_INT 0
73517: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73518: LD_ADDR_VAR 0 3
73522: PUSH
73523: LD_VAR 0 2
73527: PPUSH
73528: LD_INT 81
73530: PUSH
73531: LD_VAR 0 1
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: PPUSH
73540: CALL_OW 70
73544: ST_TO_ADDR
// end ;
73545: LD_VAR 0 3
73549: RET
// export function IsExtension ( b ) ; begin
73550: LD_INT 0
73552: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73553: LD_ADDR_VAR 0 2
73557: PUSH
73558: LD_VAR 0 1
73562: PUSH
73563: LD_INT 23
73565: PUSH
73566: LD_INT 20
73568: PUSH
73569: LD_INT 22
73571: PUSH
73572: LD_INT 17
73574: PUSH
73575: LD_INT 24
73577: PUSH
73578: LD_INT 21
73580: PUSH
73581: LD_INT 19
73583: PUSH
73584: LD_INT 16
73586: PUSH
73587: LD_INT 25
73589: PUSH
73590: LD_INT 18
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: IN
73605: ST_TO_ADDR
// end ;
73606: LD_VAR 0 2
73610: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73611: LD_INT 0
73613: PPUSH
73614: PPUSH
73615: PPUSH
// result := [ ] ;
73616: LD_ADDR_VAR 0 4
73620: PUSH
73621: EMPTY
73622: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73623: LD_ADDR_VAR 0 5
73627: PUSH
73628: LD_VAR 0 2
73632: PPUSH
73633: LD_INT 21
73635: PUSH
73636: LD_INT 3
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PPUSH
73643: CALL_OW 70
73647: ST_TO_ADDR
// if not tmp then
73648: LD_VAR 0 5
73652: NOT
73653: IFFALSE 73657
// exit ;
73655: GO 73721
// if checkLink then
73657: LD_VAR 0 3
73661: IFFALSE 73711
// begin for i in tmp do
73663: LD_ADDR_VAR 0 6
73667: PUSH
73668: LD_VAR 0 5
73672: PUSH
73673: FOR_IN
73674: IFFALSE 73709
// if GetBase ( i ) <> base then
73676: LD_VAR 0 6
73680: PPUSH
73681: CALL_OW 274
73685: PUSH
73686: LD_VAR 0 1
73690: NONEQUAL
73691: IFFALSE 73707
// ComLinkToBase ( base , i ) ;
73693: LD_VAR 0 1
73697: PPUSH
73698: LD_VAR 0 6
73702: PPUSH
73703: CALL_OW 169
73707: GO 73673
73709: POP
73710: POP
// end ; result := tmp ;
73711: LD_ADDR_VAR 0 4
73715: PUSH
73716: LD_VAR 0 5
73720: ST_TO_ADDR
// end ;
73721: LD_VAR 0 4
73725: RET
// export function ComComplete ( units , b ) ; var i ; begin
73726: LD_INT 0
73728: PPUSH
73729: PPUSH
// if not units then
73730: LD_VAR 0 1
73734: NOT
73735: IFFALSE 73739
// exit ;
73737: GO 73829
// for i in units do
73739: LD_ADDR_VAR 0 4
73743: PUSH
73744: LD_VAR 0 1
73748: PUSH
73749: FOR_IN
73750: IFFALSE 73827
// if BuildingStatus ( b ) = bs_build then
73752: LD_VAR 0 2
73756: PPUSH
73757: CALL_OW 461
73761: PUSH
73762: LD_INT 1
73764: EQUAL
73765: IFFALSE 73825
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73767: LD_VAR 0 4
73771: PPUSH
73772: LD_STRING h
73774: PUSH
73775: LD_VAR 0 2
73779: PPUSH
73780: CALL_OW 250
73784: PUSH
73785: LD_VAR 0 2
73789: PPUSH
73790: CALL_OW 251
73794: PUSH
73795: LD_VAR 0 2
73799: PUSH
73800: LD_INT 0
73802: PUSH
73803: LD_INT 0
73805: PUSH
73806: LD_INT 0
73808: PUSH
73809: EMPTY
73810: LIST
73811: LIST
73812: LIST
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: PUSH
73818: EMPTY
73819: LIST
73820: PPUSH
73821: CALL_OW 446
73825: GO 73749
73827: POP
73828: POP
// end ;
73829: LD_VAR 0 3
73833: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73834: LD_INT 0
73836: PPUSH
73837: PPUSH
73838: PPUSH
73839: PPUSH
73840: PPUSH
73841: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
73842: LD_VAR 0 1
73846: NOT
73847: PUSH
73848: LD_VAR 0 1
73852: PPUSH
73853: CALL_OW 263
73857: PUSH
73858: LD_INT 2
73860: NONEQUAL
73861: OR
73862: IFFALSE 73866
// exit ;
73864: GO 74182
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73866: LD_ADDR_VAR 0 6
73870: PUSH
73871: LD_INT 22
73873: PUSH
73874: LD_VAR 0 1
73878: PPUSH
73879: CALL_OW 255
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 2
73890: PUSH
73891: LD_INT 30
73893: PUSH
73894: LD_INT 36
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 34
73903: PUSH
73904: LD_INT 31
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: LIST
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PPUSH
73920: CALL_OW 69
73924: ST_TO_ADDR
// if not tmp then
73925: LD_VAR 0 6
73929: NOT
73930: IFFALSE 73934
// exit ;
73932: GO 74182
// result := [ ] ;
73934: LD_ADDR_VAR 0 2
73938: PUSH
73939: EMPTY
73940: ST_TO_ADDR
// for i in tmp do
73941: LD_ADDR_VAR 0 3
73945: PUSH
73946: LD_VAR 0 6
73950: PUSH
73951: FOR_IN
73952: IFFALSE 74023
// begin t := UnitsInside ( i ) ;
73954: LD_ADDR_VAR 0 4
73958: PUSH
73959: LD_VAR 0 3
73963: PPUSH
73964: CALL_OW 313
73968: ST_TO_ADDR
// if t then
73969: LD_VAR 0 4
73973: IFFALSE 74021
// for j in t do
73975: LD_ADDR_VAR 0 7
73979: PUSH
73980: LD_VAR 0 4
73984: PUSH
73985: FOR_IN
73986: IFFALSE 74019
// result := Replace ( result , result + 1 , j ) ;
73988: LD_ADDR_VAR 0 2
73992: PUSH
73993: LD_VAR 0 2
73997: PPUSH
73998: LD_VAR 0 2
74002: PUSH
74003: LD_INT 1
74005: PLUS
74006: PPUSH
74007: LD_VAR 0 7
74011: PPUSH
74012: CALL_OW 1
74016: ST_TO_ADDR
74017: GO 73985
74019: POP
74020: POP
// end ;
74021: GO 73951
74023: POP
74024: POP
// if not result then
74025: LD_VAR 0 2
74029: NOT
74030: IFFALSE 74034
// exit ;
74032: GO 74182
// mech := result [ 1 ] ;
74034: LD_ADDR_VAR 0 5
74038: PUSH
74039: LD_VAR 0 2
74043: PUSH
74044: LD_INT 1
74046: ARRAY
74047: ST_TO_ADDR
// if result > 1 then
74048: LD_VAR 0 2
74052: PUSH
74053: LD_INT 1
74055: GREATER
74056: IFFALSE 74168
// begin for i = 2 to result do
74058: LD_ADDR_VAR 0 3
74062: PUSH
74063: DOUBLE
74064: LD_INT 2
74066: DEC
74067: ST_TO_ADDR
74068: LD_VAR 0 2
74072: PUSH
74073: FOR_TO
74074: IFFALSE 74166
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74076: LD_ADDR_VAR 0 4
74080: PUSH
74081: LD_VAR 0 2
74085: PUSH
74086: LD_VAR 0 3
74090: ARRAY
74091: PPUSH
74092: LD_INT 3
74094: PPUSH
74095: CALL_OW 259
74099: PUSH
74100: LD_VAR 0 2
74104: PUSH
74105: LD_VAR 0 3
74109: ARRAY
74110: PPUSH
74111: CALL_OW 432
74115: MINUS
74116: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74117: LD_VAR 0 4
74121: PUSH
74122: LD_VAR 0 5
74126: PPUSH
74127: LD_INT 3
74129: PPUSH
74130: CALL_OW 259
74134: PUSH
74135: LD_VAR 0 5
74139: PPUSH
74140: CALL_OW 432
74144: MINUS
74145: GREATEREQUAL
74146: IFFALSE 74164
// mech := result [ i ] ;
74148: LD_ADDR_VAR 0 5
74152: PUSH
74153: LD_VAR 0 2
74157: PUSH
74158: LD_VAR 0 3
74162: ARRAY
74163: ST_TO_ADDR
// end ;
74164: GO 74073
74166: POP
74167: POP
// end ; ComLinkTo ( vehicle , mech ) ;
74168: LD_VAR 0 1
74172: PPUSH
74173: LD_VAR 0 5
74177: PPUSH
74178: CALL_OW 135
// end ;
74182: LD_VAR 0 2
74186: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74187: LD_INT 0
74189: PPUSH
74190: PPUSH
74191: PPUSH
74192: PPUSH
74193: PPUSH
74194: PPUSH
74195: PPUSH
74196: PPUSH
74197: PPUSH
74198: PPUSH
74199: PPUSH
74200: PPUSH
74201: PPUSH
// result := [ ] ;
74202: LD_ADDR_VAR 0 7
74206: PUSH
74207: EMPTY
74208: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74209: LD_VAR 0 1
74213: PPUSH
74214: CALL_OW 266
74218: PUSH
74219: LD_INT 0
74221: PUSH
74222: LD_INT 1
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: IN
74229: NOT
74230: IFFALSE 74234
// exit ;
74232: GO 75868
// if name then
74234: LD_VAR 0 3
74238: IFFALSE 74254
// SetBName ( base_dep , name ) ;
74240: LD_VAR 0 1
74244: PPUSH
74245: LD_VAR 0 3
74249: PPUSH
74250: CALL_OW 500
// base := GetBase ( base_dep ) ;
74254: LD_ADDR_VAR 0 15
74258: PUSH
74259: LD_VAR 0 1
74263: PPUSH
74264: CALL_OW 274
74268: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74269: LD_ADDR_VAR 0 16
74273: PUSH
74274: LD_VAR 0 1
74278: PPUSH
74279: CALL_OW 255
74283: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74284: LD_ADDR_VAR 0 17
74288: PUSH
74289: LD_VAR 0 1
74293: PPUSH
74294: CALL_OW 248
74298: ST_TO_ADDR
// if sources then
74299: LD_VAR 0 5
74303: IFFALSE 74350
// for i = 1 to 3 do
74305: LD_ADDR_VAR 0 8
74309: PUSH
74310: DOUBLE
74311: LD_INT 1
74313: DEC
74314: ST_TO_ADDR
74315: LD_INT 3
74317: PUSH
74318: FOR_TO
74319: IFFALSE 74348
// AddResourceType ( base , i , sources [ i ] ) ;
74321: LD_VAR 0 15
74325: PPUSH
74326: LD_VAR 0 8
74330: PPUSH
74331: LD_VAR 0 5
74335: PUSH
74336: LD_VAR 0 8
74340: ARRAY
74341: PPUSH
74342: CALL_OW 276
74346: GO 74318
74348: POP
74349: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74350: LD_ADDR_VAR 0 18
74354: PUSH
74355: LD_VAR 0 15
74359: PPUSH
74360: LD_VAR 0 2
74364: PPUSH
74365: LD_INT 1
74367: PPUSH
74368: CALL 73611 0 3
74372: ST_TO_ADDR
// InitHc ;
74373: CALL_OW 19
// InitUc ;
74377: CALL_OW 18
// uc_side := side ;
74381: LD_ADDR_OWVAR 20
74385: PUSH
74386: LD_VAR 0 16
74390: ST_TO_ADDR
// uc_nation := nation ;
74391: LD_ADDR_OWVAR 21
74395: PUSH
74396: LD_VAR 0 17
74400: ST_TO_ADDR
// if buildings then
74401: LD_VAR 0 18
74405: IFFALSE 75727
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74407: LD_ADDR_VAR 0 19
74411: PUSH
74412: LD_VAR 0 18
74416: PPUSH
74417: LD_INT 2
74419: PUSH
74420: LD_INT 30
74422: PUSH
74423: LD_INT 29
74425: PUSH
74426: EMPTY
74427: LIST
74428: LIST
74429: PUSH
74430: LD_INT 30
74432: PUSH
74433: LD_INT 30
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: LIST
74444: PPUSH
74445: CALL_OW 72
74449: ST_TO_ADDR
// if tmp then
74450: LD_VAR 0 19
74454: IFFALSE 74502
// for i in tmp do
74456: LD_ADDR_VAR 0 8
74460: PUSH
74461: LD_VAR 0 19
74465: PUSH
74466: FOR_IN
74467: IFFALSE 74500
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74469: LD_VAR 0 8
74473: PPUSH
74474: CALL_OW 250
74478: PPUSH
74479: LD_VAR 0 8
74483: PPUSH
74484: CALL_OW 251
74488: PPUSH
74489: LD_VAR 0 16
74493: PPUSH
74494: CALL_OW 441
74498: GO 74466
74500: POP
74501: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74502: LD_VAR 0 18
74506: PPUSH
74507: LD_INT 2
74509: PUSH
74510: LD_INT 30
74512: PUSH
74513: LD_INT 32
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: LD_INT 30
74522: PUSH
74523: LD_INT 33
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: LIST
74534: PPUSH
74535: CALL_OW 72
74539: IFFALSE 74627
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74541: LD_ADDR_VAR 0 8
74545: PUSH
74546: LD_VAR 0 18
74550: PPUSH
74551: LD_INT 2
74553: PUSH
74554: LD_INT 30
74556: PUSH
74557: LD_INT 32
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: PUSH
74564: LD_INT 30
74566: PUSH
74567: LD_INT 33
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: LIST
74578: PPUSH
74579: CALL_OW 72
74583: PUSH
74584: FOR_IN
74585: IFFALSE 74625
// begin if not GetBWeapon ( i ) then
74587: LD_VAR 0 8
74591: PPUSH
74592: CALL_OW 269
74596: NOT
74597: IFFALSE 74623
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74599: LD_VAR 0 8
74603: PPUSH
74604: LD_VAR 0 8
74608: PPUSH
74609: LD_VAR 0 2
74613: PPUSH
74614: CALL 75873 0 2
74618: PPUSH
74619: CALL_OW 431
// end ;
74623: GO 74584
74625: POP
74626: POP
// end ; for i = 1 to personel do
74627: LD_ADDR_VAR 0 8
74631: PUSH
74632: DOUBLE
74633: LD_INT 1
74635: DEC
74636: ST_TO_ADDR
74637: LD_VAR 0 6
74641: PUSH
74642: FOR_TO
74643: IFFALSE 75707
// begin if i > 4 then
74645: LD_VAR 0 8
74649: PUSH
74650: LD_INT 4
74652: GREATER
74653: IFFALSE 74657
// break ;
74655: GO 75707
// case i of 1 :
74657: LD_VAR 0 8
74661: PUSH
74662: LD_INT 1
74664: DOUBLE
74665: EQUAL
74666: IFTRUE 74670
74668: GO 74750
74670: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74671: LD_ADDR_VAR 0 12
74675: PUSH
74676: LD_VAR 0 18
74680: PPUSH
74681: LD_INT 22
74683: PUSH
74684: LD_VAR 0 16
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PUSH
74693: LD_INT 58
74695: PUSH
74696: EMPTY
74697: LIST
74698: PUSH
74699: LD_INT 2
74701: PUSH
74702: LD_INT 30
74704: PUSH
74705: LD_INT 32
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: LD_INT 30
74714: PUSH
74715: LD_INT 4
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 30
74724: PUSH
74725: LD_INT 5
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: LIST
74736: LIST
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: LIST
74742: PPUSH
74743: CALL_OW 72
74747: ST_TO_ADDR
74748: GO 74972
74750: LD_INT 2
74752: DOUBLE
74753: EQUAL
74754: IFTRUE 74758
74756: GO 74820
74758: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74759: LD_ADDR_VAR 0 12
74763: PUSH
74764: LD_VAR 0 18
74768: PPUSH
74769: LD_INT 22
74771: PUSH
74772: LD_VAR 0 16
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 2
74783: PUSH
74784: LD_INT 30
74786: PUSH
74787: LD_INT 0
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: PUSH
74794: LD_INT 30
74796: PUSH
74797: LD_INT 1
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: LIST
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PPUSH
74813: CALL_OW 72
74817: ST_TO_ADDR
74818: GO 74972
74820: LD_INT 3
74822: DOUBLE
74823: EQUAL
74824: IFTRUE 74828
74826: GO 74890
74828: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74829: LD_ADDR_VAR 0 12
74833: PUSH
74834: LD_VAR 0 18
74838: PPUSH
74839: LD_INT 22
74841: PUSH
74842: LD_VAR 0 16
74846: PUSH
74847: EMPTY
74848: LIST
74849: LIST
74850: PUSH
74851: LD_INT 2
74853: PUSH
74854: LD_INT 30
74856: PUSH
74857: LD_INT 2
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 30
74866: PUSH
74867: LD_INT 3
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: LIST
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PPUSH
74883: CALL_OW 72
74887: ST_TO_ADDR
74888: GO 74972
74890: LD_INT 4
74892: DOUBLE
74893: EQUAL
74894: IFTRUE 74898
74896: GO 74971
74898: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74899: LD_ADDR_VAR 0 12
74903: PUSH
74904: LD_VAR 0 18
74908: PPUSH
74909: LD_INT 22
74911: PUSH
74912: LD_VAR 0 16
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: PUSH
74921: LD_INT 2
74923: PUSH
74924: LD_INT 30
74926: PUSH
74927: LD_INT 6
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 30
74936: PUSH
74937: LD_INT 7
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 30
74946: PUSH
74947: LD_INT 8
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: LIST
74958: LIST
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PPUSH
74964: CALL_OW 72
74968: ST_TO_ADDR
74969: GO 74972
74971: POP
// if i = 1 then
74972: LD_VAR 0 8
74976: PUSH
74977: LD_INT 1
74979: EQUAL
74980: IFFALSE 75091
// begin tmp := [ ] ;
74982: LD_ADDR_VAR 0 19
74986: PUSH
74987: EMPTY
74988: ST_TO_ADDR
// for j in f do
74989: LD_ADDR_VAR 0 9
74993: PUSH
74994: LD_VAR 0 12
74998: PUSH
74999: FOR_IN
75000: IFFALSE 75073
// if GetBType ( j ) = b_bunker then
75002: LD_VAR 0 9
75006: PPUSH
75007: CALL_OW 266
75011: PUSH
75012: LD_INT 32
75014: EQUAL
75015: IFFALSE 75042
// tmp := Insert ( tmp , 1 , j ) else
75017: LD_ADDR_VAR 0 19
75021: PUSH
75022: LD_VAR 0 19
75026: PPUSH
75027: LD_INT 1
75029: PPUSH
75030: LD_VAR 0 9
75034: PPUSH
75035: CALL_OW 2
75039: ST_TO_ADDR
75040: GO 75071
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75042: LD_ADDR_VAR 0 19
75046: PUSH
75047: LD_VAR 0 19
75051: PPUSH
75052: LD_VAR 0 19
75056: PUSH
75057: LD_INT 1
75059: PLUS
75060: PPUSH
75061: LD_VAR 0 9
75065: PPUSH
75066: CALL_OW 2
75070: ST_TO_ADDR
75071: GO 74999
75073: POP
75074: POP
// if tmp then
75075: LD_VAR 0 19
75079: IFFALSE 75091
// f := tmp ;
75081: LD_ADDR_VAR 0 12
75085: PUSH
75086: LD_VAR 0 19
75090: ST_TO_ADDR
// end ; x := personel [ i ] ;
75091: LD_ADDR_VAR 0 13
75095: PUSH
75096: LD_VAR 0 6
75100: PUSH
75101: LD_VAR 0 8
75105: ARRAY
75106: ST_TO_ADDR
// if x = - 1 then
75107: LD_VAR 0 13
75111: PUSH
75112: LD_INT 1
75114: NEG
75115: EQUAL
75116: IFFALSE 75325
// begin for j in f do
75118: LD_ADDR_VAR 0 9
75122: PUSH
75123: LD_VAR 0 12
75127: PUSH
75128: FOR_IN
75129: IFFALSE 75321
// repeat InitHc ;
75131: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75135: LD_VAR 0 9
75139: PPUSH
75140: CALL_OW 266
75144: PUSH
75145: LD_INT 5
75147: EQUAL
75148: IFFALSE 75218
// begin if UnitsInside ( j ) < 3 then
75150: LD_VAR 0 9
75154: PPUSH
75155: CALL_OW 313
75159: PUSH
75160: LD_INT 3
75162: LESS
75163: IFFALSE 75199
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75165: LD_INT 0
75167: PPUSH
75168: LD_INT 5
75170: PUSH
75171: LD_INT 8
75173: PUSH
75174: LD_INT 9
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: LIST
75181: PUSH
75182: LD_VAR 0 17
75186: ARRAY
75187: PPUSH
75188: LD_VAR 0 4
75192: PPUSH
75193: CALL_OW 380
75197: GO 75216
// PrepareHuman ( false , i , skill ) ;
75199: LD_INT 0
75201: PPUSH
75202: LD_VAR 0 8
75206: PPUSH
75207: LD_VAR 0 4
75211: PPUSH
75212: CALL_OW 380
// end else
75216: GO 75235
// PrepareHuman ( false , i , skill ) ;
75218: LD_INT 0
75220: PPUSH
75221: LD_VAR 0 8
75225: PPUSH
75226: LD_VAR 0 4
75230: PPUSH
75231: CALL_OW 380
// un := CreateHuman ;
75235: LD_ADDR_VAR 0 14
75239: PUSH
75240: CALL_OW 44
75244: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75245: LD_ADDR_VAR 0 7
75249: PUSH
75250: LD_VAR 0 7
75254: PPUSH
75255: LD_INT 1
75257: PPUSH
75258: LD_VAR 0 14
75262: PPUSH
75263: CALL_OW 2
75267: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75268: LD_VAR 0 14
75272: PPUSH
75273: LD_VAR 0 9
75277: PPUSH
75278: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75282: LD_VAR 0 9
75286: PPUSH
75287: CALL_OW 313
75291: PUSH
75292: LD_INT 6
75294: EQUAL
75295: PUSH
75296: LD_VAR 0 9
75300: PPUSH
75301: CALL_OW 266
75305: PUSH
75306: LD_INT 32
75308: PUSH
75309: LD_INT 31
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: IN
75316: OR
75317: IFFALSE 75131
75319: GO 75128
75321: POP
75322: POP
// end else
75323: GO 75705
// for j = 1 to x do
75325: LD_ADDR_VAR 0 9
75329: PUSH
75330: DOUBLE
75331: LD_INT 1
75333: DEC
75334: ST_TO_ADDR
75335: LD_VAR 0 13
75339: PUSH
75340: FOR_TO
75341: IFFALSE 75703
// begin InitHc ;
75343: CALL_OW 19
// if not f then
75347: LD_VAR 0 12
75351: NOT
75352: IFFALSE 75441
// begin PrepareHuman ( false , i , skill ) ;
75354: LD_INT 0
75356: PPUSH
75357: LD_VAR 0 8
75361: PPUSH
75362: LD_VAR 0 4
75366: PPUSH
75367: CALL_OW 380
// un := CreateHuman ;
75371: LD_ADDR_VAR 0 14
75375: PUSH
75376: CALL_OW 44
75380: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75381: LD_ADDR_VAR 0 7
75385: PUSH
75386: LD_VAR 0 7
75390: PPUSH
75391: LD_INT 1
75393: PPUSH
75394: LD_VAR 0 14
75398: PPUSH
75399: CALL_OW 2
75403: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75404: LD_VAR 0 14
75408: PPUSH
75409: LD_VAR 0 1
75413: PPUSH
75414: CALL_OW 250
75418: PPUSH
75419: LD_VAR 0 1
75423: PPUSH
75424: CALL_OW 251
75428: PPUSH
75429: LD_INT 10
75431: PPUSH
75432: LD_INT 0
75434: PPUSH
75435: CALL_OW 50
// continue ;
75439: GO 75340
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75441: LD_VAR 0 12
75445: PUSH
75446: LD_INT 1
75448: ARRAY
75449: PPUSH
75450: CALL_OW 313
75454: PUSH
75455: LD_VAR 0 12
75459: PUSH
75460: LD_INT 1
75462: ARRAY
75463: PPUSH
75464: CALL_OW 266
75468: PUSH
75469: LD_INT 32
75471: PUSH
75472: LD_INT 31
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: IN
75479: AND
75480: PUSH
75481: LD_VAR 0 12
75485: PUSH
75486: LD_INT 1
75488: ARRAY
75489: PPUSH
75490: CALL_OW 313
75494: PUSH
75495: LD_INT 6
75497: EQUAL
75498: OR
75499: IFFALSE 75519
// f := Delete ( f , 1 ) ;
75501: LD_ADDR_VAR 0 12
75505: PUSH
75506: LD_VAR 0 12
75510: PPUSH
75511: LD_INT 1
75513: PPUSH
75514: CALL_OW 3
75518: ST_TO_ADDR
// if not f then
75519: LD_VAR 0 12
75523: NOT
75524: IFFALSE 75542
// begin x := x + 2 ;
75526: LD_ADDR_VAR 0 13
75530: PUSH
75531: LD_VAR 0 13
75535: PUSH
75536: LD_INT 2
75538: PLUS
75539: ST_TO_ADDR
// continue ;
75540: GO 75340
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75542: LD_VAR 0 12
75546: PUSH
75547: LD_INT 1
75549: ARRAY
75550: PPUSH
75551: CALL_OW 266
75555: PUSH
75556: LD_INT 5
75558: EQUAL
75559: IFFALSE 75633
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75561: LD_VAR 0 12
75565: PUSH
75566: LD_INT 1
75568: ARRAY
75569: PPUSH
75570: CALL_OW 313
75574: PUSH
75575: LD_INT 3
75577: LESS
75578: IFFALSE 75614
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75580: LD_INT 0
75582: PPUSH
75583: LD_INT 5
75585: PUSH
75586: LD_INT 8
75588: PUSH
75589: LD_INT 9
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: LIST
75596: PUSH
75597: LD_VAR 0 17
75601: ARRAY
75602: PPUSH
75603: LD_VAR 0 4
75607: PPUSH
75608: CALL_OW 380
75612: GO 75631
// PrepareHuman ( false , i , skill ) ;
75614: LD_INT 0
75616: PPUSH
75617: LD_VAR 0 8
75621: PPUSH
75622: LD_VAR 0 4
75626: PPUSH
75627: CALL_OW 380
// end else
75631: GO 75650
// PrepareHuman ( false , i , skill ) ;
75633: LD_INT 0
75635: PPUSH
75636: LD_VAR 0 8
75640: PPUSH
75641: LD_VAR 0 4
75645: PPUSH
75646: CALL_OW 380
// un := CreateHuman ;
75650: LD_ADDR_VAR 0 14
75654: PUSH
75655: CALL_OW 44
75659: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75660: LD_ADDR_VAR 0 7
75664: PUSH
75665: LD_VAR 0 7
75669: PPUSH
75670: LD_INT 1
75672: PPUSH
75673: LD_VAR 0 14
75677: PPUSH
75678: CALL_OW 2
75682: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75683: LD_VAR 0 14
75687: PPUSH
75688: LD_VAR 0 12
75692: PUSH
75693: LD_INT 1
75695: ARRAY
75696: PPUSH
75697: CALL_OW 52
// end ;
75701: GO 75340
75703: POP
75704: POP
// end ;
75705: GO 74642
75707: POP
75708: POP
// result := result ^ buildings ;
75709: LD_ADDR_VAR 0 7
75713: PUSH
75714: LD_VAR 0 7
75718: PUSH
75719: LD_VAR 0 18
75723: ADD
75724: ST_TO_ADDR
// end else
75725: GO 75868
// begin for i = 1 to personel do
75727: LD_ADDR_VAR 0 8
75731: PUSH
75732: DOUBLE
75733: LD_INT 1
75735: DEC
75736: ST_TO_ADDR
75737: LD_VAR 0 6
75741: PUSH
75742: FOR_TO
75743: IFFALSE 75866
// begin if i > 4 then
75745: LD_VAR 0 8
75749: PUSH
75750: LD_INT 4
75752: GREATER
75753: IFFALSE 75757
// break ;
75755: GO 75866
// x := personel [ i ] ;
75757: LD_ADDR_VAR 0 13
75761: PUSH
75762: LD_VAR 0 6
75766: PUSH
75767: LD_VAR 0 8
75771: ARRAY
75772: ST_TO_ADDR
// if x = - 1 then
75773: LD_VAR 0 13
75777: PUSH
75778: LD_INT 1
75780: NEG
75781: EQUAL
75782: IFFALSE 75786
// continue ;
75784: GO 75742
// PrepareHuman ( false , i , skill ) ;
75786: LD_INT 0
75788: PPUSH
75789: LD_VAR 0 8
75793: PPUSH
75794: LD_VAR 0 4
75798: PPUSH
75799: CALL_OW 380
// un := CreateHuman ;
75803: LD_ADDR_VAR 0 14
75807: PUSH
75808: CALL_OW 44
75812: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75813: LD_VAR 0 14
75817: PPUSH
75818: LD_VAR 0 1
75822: PPUSH
75823: CALL_OW 250
75827: PPUSH
75828: LD_VAR 0 1
75832: PPUSH
75833: CALL_OW 251
75837: PPUSH
75838: LD_INT 10
75840: PPUSH
75841: LD_INT 0
75843: PPUSH
75844: CALL_OW 50
// result := result ^ un ;
75848: LD_ADDR_VAR 0 7
75852: PUSH
75853: LD_VAR 0 7
75857: PUSH
75858: LD_VAR 0 14
75862: ADD
75863: ST_TO_ADDR
// end ;
75864: GO 75742
75866: POP
75867: POP
// end ; end ;
75868: LD_VAR 0 7
75872: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75873: LD_INT 0
75875: PPUSH
75876: PPUSH
75877: PPUSH
75878: PPUSH
75879: PPUSH
75880: PPUSH
75881: PPUSH
75882: PPUSH
75883: PPUSH
75884: PPUSH
75885: PPUSH
75886: PPUSH
75887: PPUSH
75888: PPUSH
75889: PPUSH
75890: PPUSH
// result := false ;
75891: LD_ADDR_VAR 0 3
75895: PUSH
75896: LD_INT 0
75898: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75899: LD_VAR 0 1
75903: NOT
75904: PUSH
75905: LD_VAR 0 1
75909: PPUSH
75910: CALL_OW 266
75914: PUSH
75915: LD_INT 32
75917: PUSH
75918: LD_INT 33
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: IN
75925: NOT
75926: OR
75927: IFFALSE 75931
// exit ;
75929: GO 77040
// nat := GetNation ( tower ) ;
75931: LD_ADDR_VAR 0 12
75935: PUSH
75936: LD_VAR 0 1
75940: PPUSH
75941: CALL_OW 248
75945: ST_TO_ADDR
// side := GetSide ( tower ) ;
75946: LD_ADDR_VAR 0 16
75950: PUSH
75951: LD_VAR 0 1
75955: PPUSH
75956: CALL_OW 255
75960: ST_TO_ADDR
// x := GetX ( tower ) ;
75961: LD_ADDR_VAR 0 10
75965: PUSH
75966: LD_VAR 0 1
75970: PPUSH
75971: CALL_OW 250
75975: ST_TO_ADDR
// y := GetY ( tower ) ;
75976: LD_ADDR_VAR 0 11
75980: PUSH
75981: LD_VAR 0 1
75985: PPUSH
75986: CALL_OW 251
75990: ST_TO_ADDR
// if not x or not y then
75991: LD_VAR 0 10
75995: NOT
75996: PUSH
75997: LD_VAR 0 11
76001: NOT
76002: OR
76003: IFFALSE 76007
// exit ;
76005: GO 77040
// weapon := 0 ;
76007: LD_ADDR_VAR 0 18
76011: PUSH
76012: LD_INT 0
76014: ST_TO_ADDR
// fac_list := [ ] ;
76015: LD_ADDR_VAR 0 17
76019: PUSH
76020: EMPTY
76021: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
76022: LD_ADDR_VAR 0 6
76026: PUSH
76027: LD_VAR 0 1
76031: PPUSH
76032: CALL_OW 274
76036: PPUSH
76037: LD_VAR 0 2
76041: PPUSH
76042: LD_INT 0
76044: PPUSH
76045: CALL 73611 0 3
76049: PPUSH
76050: LD_INT 30
76052: PUSH
76053: LD_INT 3
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: PPUSH
76060: CALL_OW 72
76064: ST_TO_ADDR
// if not factories then
76065: LD_VAR 0 6
76069: NOT
76070: IFFALSE 76074
// exit ;
76072: GO 77040
// for i in factories do
76074: LD_ADDR_VAR 0 8
76078: PUSH
76079: LD_VAR 0 6
76083: PUSH
76084: FOR_IN
76085: IFFALSE 76110
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76087: LD_ADDR_VAR 0 17
76091: PUSH
76092: LD_VAR 0 17
76096: PUSH
76097: LD_VAR 0 8
76101: PPUSH
76102: CALL_OW 478
76106: UNION
76107: ST_TO_ADDR
76108: GO 76084
76110: POP
76111: POP
// if not fac_list then
76112: LD_VAR 0 17
76116: NOT
76117: IFFALSE 76121
// exit ;
76119: GO 77040
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76121: LD_ADDR_VAR 0 5
76125: PUSH
76126: LD_INT 4
76128: PUSH
76129: LD_INT 5
76131: PUSH
76132: LD_INT 9
76134: PUSH
76135: LD_INT 10
76137: PUSH
76138: LD_INT 6
76140: PUSH
76141: LD_INT 7
76143: PUSH
76144: LD_INT 11
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: LIST
76151: LIST
76152: LIST
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 27
76158: PUSH
76159: LD_INT 28
76161: PUSH
76162: LD_INT 26
76164: PUSH
76165: LD_INT 30
76167: PUSH
76168: EMPTY
76169: LIST
76170: LIST
76171: LIST
76172: LIST
76173: PUSH
76174: LD_INT 43
76176: PUSH
76177: LD_INT 44
76179: PUSH
76180: LD_INT 46
76182: PUSH
76183: LD_INT 45
76185: PUSH
76186: LD_INT 47
76188: PUSH
76189: LD_INT 49
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: LIST
76204: PUSH
76205: LD_VAR 0 12
76209: ARRAY
76210: ST_TO_ADDR
// list := list isect fac_list ;
76211: LD_ADDR_VAR 0 5
76215: PUSH
76216: LD_VAR 0 5
76220: PUSH
76221: LD_VAR 0 17
76225: ISECT
76226: ST_TO_ADDR
// if not list then
76227: LD_VAR 0 5
76231: NOT
76232: IFFALSE 76236
// exit ;
76234: GO 77040
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76236: LD_VAR 0 12
76240: PUSH
76241: LD_INT 3
76243: EQUAL
76244: PUSH
76245: LD_INT 49
76247: PUSH
76248: LD_VAR 0 5
76252: IN
76253: AND
76254: PUSH
76255: LD_INT 31
76257: PPUSH
76258: LD_VAR 0 16
76262: PPUSH
76263: CALL_OW 321
76267: PUSH
76268: LD_INT 2
76270: EQUAL
76271: AND
76272: IFFALSE 76332
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76274: LD_INT 22
76276: PUSH
76277: LD_VAR 0 16
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: LD_INT 35
76288: PUSH
76289: LD_INT 49
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 91
76298: PUSH
76299: LD_VAR 0 1
76303: PUSH
76304: LD_INT 10
76306: PUSH
76307: EMPTY
76308: LIST
76309: LIST
76310: LIST
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: LIST
76316: PPUSH
76317: CALL_OW 69
76321: NOT
76322: IFFALSE 76332
// weapon := ru_time_lapser ;
76324: LD_ADDR_VAR 0 18
76328: PUSH
76329: LD_INT 49
76331: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76332: LD_VAR 0 12
76336: PUSH
76337: LD_INT 1
76339: PUSH
76340: LD_INT 2
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: IN
76347: PUSH
76348: LD_INT 11
76350: PUSH
76351: LD_VAR 0 5
76355: IN
76356: PUSH
76357: LD_INT 30
76359: PUSH
76360: LD_VAR 0 5
76364: IN
76365: OR
76366: AND
76367: PUSH
76368: LD_INT 6
76370: PPUSH
76371: LD_VAR 0 16
76375: PPUSH
76376: CALL_OW 321
76380: PUSH
76381: LD_INT 2
76383: EQUAL
76384: AND
76385: IFFALSE 76550
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76387: LD_INT 22
76389: PUSH
76390: LD_VAR 0 16
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 2
76401: PUSH
76402: LD_INT 35
76404: PUSH
76405: LD_INT 11
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 35
76414: PUSH
76415: LD_INT 30
76417: PUSH
76418: EMPTY
76419: LIST
76420: LIST
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 91
76429: PUSH
76430: LD_VAR 0 1
76434: PUSH
76435: LD_INT 18
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: LIST
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: LIST
76447: PPUSH
76448: CALL_OW 69
76452: NOT
76453: PUSH
76454: LD_INT 22
76456: PUSH
76457: LD_VAR 0 16
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 2
76468: PUSH
76469: LD_INT 30
76471: PUSH
76472: LD_INT 32
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: LD_INT 30
76481: PUSH
76482: LD_INT 33
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 91
76496: PUSH
76497: LD_VAR 0 1
76501: PUSH
76502: LD_INT 12
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: LIST
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: LIST
76514: PUSH
76515: EMPTY
76516: LIST
76517: PPUSH
76518: CALL_OW 69
76522: PUSH
76523: LD_INT 2
76525: GREATER
76526: AND
76527: IFFALSE 76550
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76529: LD_ADDR_VAR 0 18
76533: PUSH
76534: LD_INT 11
76536: PUSH
76537: LD_INT 30
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: PUSH
76544: LD_VAR 0 12
76548: ARRAY
76549: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76550: LD_VAR 0 18
76554: NOT
76555: PUSH
76556: LD_INT 40
76558: PPUSH
76559: LD_VAR 0 16
76563: PPUSH
76564: CALL_OW 321
76568: PUSH
76569: LD_INT 2
76571: EQUAL
76572: AND
76573: PUSH
76574: LD_INT 7
76576: PUSH
76577: LD_VAR 0 5
76581: IN
76582: PUSH
76583: LD_INT 28
76585: PUSH
76586: LD_VAR 0 5
76590: IN
76591: OR
76592: PUSH
76593: LD_INT 45
76595: PUSH
76596: LD_VAR 0 5
76600: IN
76601: OR
76602: AND
76603: IFFALSE 76857
// begin hex := GetHexInfo ( x , y ) ;
76605: LD_ADDR_VAR 0 4
76609: PUSH
76610: LD_VAR 0 10
76614: PPUSH
76615: LD_VAR 0 11
76619: PPUSH
76620: CALL_OW 546
76624: ST_TO_ADDR
// if hex [ 1 ] then
76625: LD_VAR 0 4
76629: PUSH
76630: LD_INT 1
76632: ARRAY
76633: IFFALSE 76637
// exit ;
76635: GO 77040
// height := hex [ 2 ] ;
76637: LD_ADDR_VAR 0 15
76641: PUSH
76642: LD_VAR 0 4
76646: PUSH
76647: LD_INT 2
76649: ARRAY
76650: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76651: LD_ADDR_VAR 0 14
76655: PUSH
76656: LD_INT 0
76658: PUSH
76659: LD_INT 2
76661: PUSH
76662: LD_INT 3
76664: PUSH
76665: LD_INT 5
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: ST_TO_ADDR
// for i in tmp do
76674: LD_ADDR_VAR 0 8
76678: PUSH
76679: LD_VAR 0 14
76683: PUSH
76684: FOR_IN
76685: IFFALSE 76855
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76687: LD_ADDR_VAR 0 9
76691: PUSH
76692: LD_VAR 0 10
76696: PPUSH
76697: LD_VAR 0 8
76701: PPUSH
76702: LD_INT 5
76704: PPUSH
76705: CALL_OW 272
76709: PUSH
76710: LD_VAR 0 11
76714: PPUSH
76715: LD_VAR 0 8
76719: PPUSH
76720: LD_INT 5
76722: PPUSH
76723: CALL_OW 273
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76732: LD_VAR 0 9
76736: PUSH
76737: LD_INT 1
76739: ARRAY
76740: PPUSH
76741: LD_VAR 0 9
76745: PUSH
76746: LD_INT 2
76748: ARRAY
76749: PPUSH
76750: CALL_OW 488
76754: IFFALSE 76853
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76756: LD_ADDR_VAR 0 4
76760: PUSH
76761: LD_VAR 0 9
76765: PUSH
76766: LD_INT 1
76768: ARRAY
76769: PPUSH
76770: LD_VAR 0 9
76774: PUSH
76775: LD_INT 2
76777: ARRAY
76778: PPUSH
76779: CALL_OW 546
76783: ST_TO_ADDR
// if hex [ 1 ] then
76784: LD_VAR 0 4
76788: PUSH
76789: LD_INT 1
76791: ARRAY
76792: IFFALSE 76796
// continue ;
76794: GO 76684
// h := hex [ 2 ] ;
76796: LD_ADDR_VAR 0 13
76800: PUSH
76801: LD_VAR 0 4
76805: PUSH
76806: LD_INT 2
76808: ARRAY
76809: ST_TO_ADDR
// if h + 7 < height then
76810: LD_VAR 0 13
76814: PUSH
76815: LD_INT 7
76817: PLUS
76818: PUSH
76819: LD_VAR 0 15
76823: LESS
76824: IFFALSE 76853
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76826: LD_ADDR_VAR 0 18
76830: PUSH
76831: LD_INT 7
76833: PUSH
76834: LD_INT 28
76836: PUSH
76837: LD_INT 45
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: LIST
76844: PUSH
76845: LD_VAR 0 12
76849: ARRAY
76850: ST_TO_ADDR
// break ;
76851: GO 76855
// end ; end ; end ;
76853: GO 76684
76855: POP
76856: POP
// end ; if not weapon then
76857: LD_VAR 0 18
76861: NOT
76862: IFFALSE 76922
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76864: LD_ADDR_VAR 0 5
76868: PUSH
76869: LD_VAR 0 5
76873: PUSH
76874: LD_INT 11
76876: PUSH
76877: LD_INT 30
76879: PUSH
76880: LD_INT 49
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: LIST
76887: DIFF
76888: ST_TO_ADDR
// if not list then
76889: LD_VAR 0 5
76893: NOT
76894: IFFALSE 76898
// exit ;
76896: GO 77040
// weapon := list [ rand ( 1 , list ) ] ;
76898: LD_ADDR_VAR 0 18
76902: PUSH
76903: LD_VAR 0 5
76907: PUSH
76908: LD_INT 1
76910: PPUSH
76911: LD_VAR 0 5
76915: PPUSH
76916: CALL_OW 12
76920: ARRAY
76921: ST_TO_ADDR
// end ; if weapon then
76922: LD_VAR 0 18
76926: IFFALSE 77040
// begin tmp := CostOfWeapon ( weapon ) ;
76928: LD_ADDR_VAR 0 14
76932: PUSH
76933: LD_VAR 0 18
76937: PPUSH
76938: CALL_OW 451
76942: ST_TO_ADDR
// j := GetBase ( tower ) ;
76943: LD_ADDR_VAR 0 9
76947: PUSH
76948: LD_VAR 0 1
76952: PPUSH
76953: CALL_OW 274
76957: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76958: LD_VAR 0 9
76962: PPUSH
76963: LD_INT 1
76965: PPUSH
76966: CALL_OW 275
76970: PUSH
76971: LD_VAR 0 14
76975: PUSH
76976: LD_INT 1
76978: ARRAY
76979: GREATEREQUAL
76980: PUSH
76981: LD_VAR 0 9
76985: PPUSH
76986: LD_INT 2
76988: PPUSH
76989: CALL_OW 275
76993: PUSH
76994: LD_VAR 0 14
76998: PUSH
76999: LD_INT 2
77001: ARRAY
77002: GREATEREQUAL
77003: AND
77004: PUSH
77005: LD_VAR 0 9
77009: PPUSH
77010: LD_INT 3
77012: PPUSH
77013: CALL_OW 275
77017: PUSH
77018: LD_VAR 0 14
77022: PUSH
77023: LD_INT 3
77025: ARRAY
77026: GREATEREQUAL
77027: AND
77028: IFFALSE 77040
// result := weapon ;
77030: LD_ADDR_VAR 0 3
77034: PUSH
77035: LD_VAR 0 18
77039: ST_TO_ADDR
// end ; end ;
77040: LD_VAR 0 3
77044: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77045: LD_INT 0
77047: PPUSH
77048: PPUSH
// result := true ;
77049: LD_ADDR_VAR 0 3
77053: PUSH
77054: LD_INT 1
77056: ST_TO_ADDR
// if array1 = array2 then
77057: LD_VAR 0 1
77061: PUSH
77062: LD_VAR 0 2
77066: EQUAL
77067: IFFALSE 77127
// begin for i = 1 to array1 do
77069: LD_ADDR_VAR 0 4
77073: PUSH
77074: DOUBLE
77075: LD_INT 1
77077: DEC
77078: ST_TO_ADDR
77079: LD_VAR 0 1
77083: PUSH
77084: FOR_TO
77085: IFFALSE 77123
// if array1 [ i ] <> array2 [ i ] then
77087: LD_VAR 0 1
77091: PUSH
77092: LD_VAR 0 4
77096: ARRAY
77097: PUSH
77098: LD_VAR 0 2
77102: PUSH
77103: LD_VAR 0 4
77107: ARRAY
77108: NONEQUAL
77109: IFFALSE 77121
// begin result := false ;
77111: LD_ADDR_VAR 0 3
77115: PUSH
77116: LD_INT 0
77118: ST_TO_ADDR
// break ;
77119: GO 77123
// end ;
77121: GO 77084
77123: POP
77124: POP
// end else
77125: GO 77135
// result := false ;
77127: LD_ADDR_VAR 0 3
77131: PUSH
77132: LD_INT 0
77134: ST_TO_ADDR
// end ;
77135: LD_VAR 0 3
77139: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
77140: LD_INT 0
77142: PPUSH
77143: PPUSH
// if not array1 or not array2 then
77144: LD_VAR 0 1
77148: NOT
77149: PUSH
77150: LD_VAR 0 2
77154: NOT
77155: OR
77156: IFFALSE 77160
// exit ;
77158: GO 77224
// result := true ;
77160: LD_ADDR_VAR 0 3
77164: PUSH
77165: LD_INT 1
77167: ST_TO_ADDR
// for i = 1 to array1 do
77168: LD_ADDR_VAR 0 4
77172: PUSH
77173: DOUBLE
77174: LD_INT 1
77176: DEC
77177: ST_TO_ADDR
77178: LD_VAR 0 1
77182: PUSH
77183: FOR_TO
77184: IFFALSE 77222
// if array1 [ i ] <> array2 [ i ] then
77186: LD_VAR 0 1
77190: PUSH
77191: LD_VAR 0 4
77195: ARRAY
77196: PUSH
77197: LD_VAR 0 2
77201: PUSH
77202: LD_VAR 0 4
77206: ARRAY
77207: NONEQUAL
77208: IFFALSE 77220
// begin result := false ;
77210: LD_ADDR_VAR 0 3
77214: PUSH
77215: LD_INT 0
77217: ST_TO_ADDR
// break ;
77218: GO 77222
// end ;
77220: GO 77183
77222: POP
77223: POP
// end ;
77224: LD_VAR 0 3
77228: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77229: LD_INT 0
77231: PPUSH
77232: PPUSH
77233: PPUSH
// pom := GetBase ( fac ) ;
77234: LD_ADDR_VAR 0 5
77238: PUSH
77239: LD_VAR 0 1
77243: PPUSH
77244: CALL_OW 274
77248: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77249: LD_ADDR_VAR 0 4
77253: PUSH
77254: LD_VAR 0 2
77258: PUSH
77259: LD_INT 1
77261: ARRAY
77262: PPUSH
77263: LD_VAR 0 2
77267: PUSH
77268: LD_INT 2
77270: ARRAY
77271: PPUSH
77272: LD_VAR 0 2
77276: PUSH
77277: LD_INT 3
77279: ARRAY
77280: PPUSH
77281: LD_VAR 0 2
77285: PUSH
77286: LD_INT 4
77288: ARRAY
77289: PPUSH
77290: CALL_OW 449
77294: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77295: LD_ADDR_VAR 0 3
77299: PUSH
77300: LD_VAR 0 5
77304: PPUSH
77305: LD_INT 1
77307: PPUSH
77308: CALL_OW 275
77312: PUSH
77313: LD_VAR 0 4
77317: PUSH
77318: LD_INT 1
77320: ARRAY
77321: GREATEREQUAL
77322: PUSH
77323: LD_VAR 0 5
77327: PPUSH
77328: LD_INT 2
77330: PPUSH
77331: CALL_OW 275
77335: PUSH
77336: LD_VAR 0 4
77340: PUSH
77341: LD_INT 2
77343: ARRAY
77344: GREATEREQUAL
77345: AND
77346: PUSH
77347: LD_VAR 0 5
77351: PPUSH
77352: LD_INT 3
77354: PPUSH
77355: CALL_OW 275
77359: PUSH
77360: LD_VAR 0 4
77364: PUSH
77365: LD_INT 3
77367: ARRAY
77368: GREATEREQUAL
77369: AND
77370: ST_TO_ADDR
// end ;
77371: LD_VAR 0 3
77375: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77376: LD_INT 0
77378: PPUSH
77379: PPUSH
77380: PPUSH
77381: PPUSH
// pom := GetBase ( building ) ;
77382: LD_ADDR_VAR 0 3
77386: PUSH
77387: LD_VAR 0 1
77391: PPUSH
77392: CALL_OW 274
77396: ST_TO_ADDR
// if not pom then
77397: LD_VAR 0 3
77401: NOT
77402: IFFALSE 77406
// exit ;
77404: GO 77576
// btype := GetBType ( building ) ;
77406: LD_ADDR_VAR 0 5
77410: PUSH
77411: LD_VAR 0 1
77415: PPUSH
77416: CALL_OW 266
77420: ST_TO_ADDR
// if btype = b_armoury then
77421: LD_VAR 0 5
77425: PUSH
77426: LD_INT 4
77428: EQUAL
77429: IFFALSE 77439
// btype := b_barracks ;
77431: LD_ADDR_VAR 0 5
77435: PUSH
77436: LD_INT 5
77438: ST_TO_ADDR
// if btype = b_depot then
77439: LD_VAR 0 5
77443: PUSH
77444: LD_INT 0
77446: EQUAL
77447: IFFALSE 77457
// btype := b_warehouse ;
77449: LD_ADDR_VAR 0 5
77453: PUSH
77454: LD_INT 1
77456: ST_TO_ADDR
// if btype = b_workshop then
77457: LD_VAR 0 5
77461: PUSH
77462: LD_INT 2
77464: EQUAL
77465: IFFALSE 77475
// btype := b_factory ;
77467: LD_ADDR_VAR 0 5
77471: PUSH
77472: LD_INT 3
77474: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77475: LD_ADDR_VAR 0 4
77479: PUSH
77480: LD_VAR 0 5
77484: PPUSH
77485: LD_VAR 0 1
77489: PPUSH
77490: CALL_OW 248
77494: PPUSH
77495: CALL_OW 450
77499: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77500: LD_ADDR_VAR 0 2
77504: PUSH
77505: LD_VAR 0 3
77509: PPUSH
77510: LD_INT 1
77512: PPUSH
77513: CALL_OW 275
77517: PUSH
77518: LD_VAR 0 4
77522: PUSH
77523: LD_INT 1
77525: ARRAY
77526: GREATEREQUAL
77527: PUSH
77528: LD_VAR 0 3
77532: PPUSH
77533: LD_INT 2
77535: PPUSH
77536: CALL_OW 275
77540: PUSH
77541: LD_VAR 0 4
77545: PUSH
77546: LD_INT 2
77548: ARRAY
77549: GREATEREQUAL
77550: AND
77551: PUSH
77552: LD_VAR 0 3
77556: PPUSH
77557: LD_INT 3
77559: PPUSH
77560: CALL_OW 275
77564: PUSH
77565: LD_VAR 0 4
77569: PUSH
77570: LD_INT 3
77572: ARRAY
77573: GREATEREQUAL
77574: AND
77575: ST_TO_ADDR
// end ;
77576: LD_VAR 0 2
77580: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77581: LD_INT 0
77583: PPUSH
77584: PPUSH
77585: PPUSH
// pom := GetBase ( building ) ;
77586: LD_ADDR_VAR 0 4
77590: PUSH
77591: LD_VAR 0 1
77595: PPUSH
77596: CALL_OW 274
77600: ST_TO_ADDR
// if not pom then
77601: LD_VAR 0 4
77605: NOT
77606: IFFALSE 77610
// exit ;
77608: GO 77711
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77610: LD_ADDR_VAR 0 5
77614: PUSH
77615: LD_VAR 0 2
77619: PPUSH
77620: LD_VAR 0 1
77624: PPUSH
77625: CALL_OW 248
77629: PPUSH
77630: CALL_OW 450
77634: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77635: LD_ADDR_VAR 0 3
77639: PUSH
77640: LD_VAR 0 4
77644: PPUSH
77645: LD_INT 1
77647: PPUSH
77648: CALL_OW 275
77652: PUSH
77653: LD_VAR 0 5
77657: PUSH
77658: LD_INT 1
77660: ARRAY
77661: GREATEREQUAL
77662: PUSH
77663: LD_VAR 0 4
77667: PPUSH
77668: LD_INT 2
77670: PPUSH
77671: CALL_OW 275
77675: PUSH
77676: LD_VAR 0 5
77680: PUSH
77681: LD_INT 2
77683: ARRAY
77684: GREATEREQUAL
77685: AND
77686: PUSH
77687: LD_VAR 0 4
77691: PPUSH
77692: LD_INT 3
77694: PPUSH
77695: CALL_OW 275
77699: PUSH
77700: LD_VAR 0 5
77704: PUSH
77705: LD_INT 3
77707: ARRAY
77708: GREATEREQUAL
77709: AND
77710: ST_TO_ADDR
// end ;
77711: LD_VAR 0 3
77715: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77716: LD_INT 0
77718: PPUSH
77719: PPUSH
77720: PPUSH
77721: PPUSH
77722: PPUSH
77723: PPUSH
77724: PPUSH
77725: PPUSH
77726: PPUSH
77727: PPUSH
77728: PPUSH
// result := false ;
77729: LD_ADDR_VAR 0 8
77733: PUSH
77734: LD_INT 0
77736: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77737: LD_VAR 0 5
77741: NOT
77742: PUSH
77743: LD_VAR 0 1
77747: NOT
77748: OR
77749: PUSH
77750: LD_VAR 0 2
77754: NOT
77755: OR
77756: PUSH
77757: LD_VAR 0 3
77761: NOT
77762: OR
77763: IFFALSE 77767
// exit ;
77765: GO 78581
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77767: LD_ADDR_VAR 0 14
77771: PUSH
77772: LD_VAR 0 1
77776: PPUSH
77777: LD_VAR 0 2
77781: PPUSH
77782: LD_VAR 0 3
77786: PPUSH
77787: LD_VAR 0 4
77791: PPUSH
77792: LD_VAR 0 5
77796: PUSH
77797: LD_INT 1
77799: ARRAY
77800: PPUSH
77801: CALL_OW 248
77805: PPUSH
77806: LD_INT 0
77808: PPUSH
77809: CALL 79818 0 6
77813: ST_TO_ADDR
// if not hexes then
77814: LD_VAR 0 14
77818: NOT
77819: IFFALSE 77823
// exit ;
77821: GO 78581
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77823: LD_ADDR_VAR 0 17
77827: PUSH
77828: LD_VAR 0 5
77832: PPUSH
77833: LD_INT 22
77835: PUSH
77836: LD_VAR 0 13
77840: PPUSH
77841: CALL_OW 255
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 2
77852: PUSH
77853: LD_INT 30
77855: PUSH
77856: LD_INT 0
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 30
77865: PUSH
77866: LD_INT 1
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: EMPTY
77874: LIST
77875: LIST
77876: LIST
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PPUSH
77882: CALL_OW 72
77886: ST_TO_ADDR
// for i = 1 to hexes do
77887: LD_ADDR_VAR 0 9
77891: PUSH
77892: DOUBLE
77893: LD_INT 1
77895: DEC
77896: ST_TO_ADDR
77897: LD_VAR 0 14
77901: PUSH
77902: FOR_TO
77903: IFFALSE 78579
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77905: LD_ADDR_VAR 0 13
77909: PUSH
77910: LD_VAR 0 14
77914: PUSH
77915: LD_VAR 0 9
77919: ARRAY
77920: PUSH
77921: LD_INT 1
77923: ARRAY
77924: PPUSH
77925: LD_VAR 0 14
77929: PUSH
77930: LD_VAR 0 9
77934: ARRAY
77935: PUSH
77936: LD_INT 2
77938: ARRAY
77939: PPUSH
77940: CALL_OW 428
77944: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77945: LD_VAR 0 14
77949: PUSH
77950: LD_VAR 0 9
77954: ARRAY
77955: PUSH
77956: LD_INT 1
77958: ARRAY
77959: PPUSH
77960: LD_VAR 0 14
77964: PUSH
77965: LD_VAR 0 9
77969: ARRAY
77970: PUSH
77971: LD_INT 2
77973: ARRAY
77974: PPUSH
77975: CALL_OW 351
77979: PUSH
77980: LD_VAR 0 14
77984: PUSH
77985: LD_VAR 0 9
77989: ARRAY
77990: PUSH
77991: LD_INT 1
77993: ARRAY
77994: PPUSH
77995: LD_VAR 0 14
77999: PUSH
78000: LD_VAR 0 9
78004: ARRAY
78005: PUSH
78006: LD_INT 2
78008: ARRAY
78009: PPUSH
78010: CALL_OW 488
78014: NOT
78015: OR
78016: PUSH
78017: LD_VAR 0 13
78021: PPUSH
78022: CALL_OW 247
78026: PUSH
78027: LD_INT 3
78029: EQUAL
78030: OR
78031: IFFALSE 78037
// exit ;
78033: POP
78034: POP
78035: GO 78581
// if not tmp then
78037: LD_VAR 0 13
78041: NOT
78042: IFFALSE 78046
// continue ;
78044: GO 77902
// result := true ;
78046: LD_ADDR_VAR 0 8
78050: PUSH
78051: LD_INT 1
78053: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
78054: LD_VAR 0 6
78058: PUSH
78059: LD_VAR 0 13
78063: PPUSH
78064: CALL_OW 247
78068: PUSH
78069: LD_INT 2
78071: EQUAL
78072: AND
78073: PUSH
78074: LD_VAR 0 13
78078: PPUSH
78079: CALL_OW 263
78083: PUSH
78084: LD_INT 1
78086: EQUAL
78087: AND
78088: IFFALSE 78252
// begin if IsDrivenBy ( tmp ) then
78090: LD_VAR 0 13
78094: PPUSH
78095: CALL_OW 311
78099: IFFALSE 78103
// continue ;
78101: GO 77902
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
78103: LD_VAR 0 6
78107: PPUSH
78108: LD_INT 3
78110: PUSH
78111: LD_INT 60
78113: PUSH
78114: EMPTY
78115: LIST
78116: PUSH
78117: EMPTY
78118: LIST
78119: LIST
78120: PUSH
78121: LD_INT 3
78123: PUSH
78124: LD_INT 55
78126: PUSH
78127: EMPTY
78128: LIST
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PPUSH
78138: CALL_OW 72
78142: IFFALSE 78250
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
78144: LD_ADDR_VAR 0 18
78148: PUSH
78149: LD_VAR 0 6
78153: PPUSH
78154: LD_INT 3
78156: PUSH
78157: LD_INT 60
78159: PUSH
78160: EMPTY
78161: LIST
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 3
78169: PUSH
78170: LD_INT 55
78172: PUSH
78173: EMPTY
78174: LIST
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: PPUSH
78184: CALL_OW 72
78188: PUSH
78189: LD_INT 1
78191: ARRAY
78192: ST_TO_ADDR
// if IsInUnit ( driver ) then
78193: LD_VAR 0 18
78197: PPUSH
78198: CALL_OW 310
78202: IFFALSE 78213
// ComExit ( driver ) ;
78204: LD_VAR 0 18
78208: PPUSH
78209: CALL 103002 0 1
// AddComEnterUnit ( driver , tmp ) ;
78213: LD_VAR 0 18
78217: PPUSH
78218: LD_VAR 0 13
78222: PPUSH
78223: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
78227: LD_VAR 0 18
78231: PPUSH
78232: LD_VAR 0 7
78236: PPUSH
78237: CALL_OW 173
// AddComExitVehicle ( driver ) ;
78241: LD_VAR 0 18
78245: PPUSH
78246: CALL_OW 181
// end ; continue ;
78250: GO 77902
// end ; if not cleaners or not tmp in cleaners then
78252: LD_VAR 0 6
78256: NOT
78257: PUSH
78258: LD_VAR 0 13
78262: PUSH
78263: LD_VAR 0 6
78267: IN
78268: NOT
78269: OR
78270: IFFALSE 78577
// begin if dep then
78272: LD_VAR 0 17
78276: IFFALSE 78412
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78278: LD_ADDR_VAR 0 16
78282: PUSH
78283: LD_VAR 0 17
78287: PUSH
78288: LD_INT 1
78290: ARRAY
78291: PPUSH
78292: CALL_OW 250
78296: PPUSH
78297: LD_VAR 0 17
78301: PUSH
78302: LD_INT 1
78304: ARRAY
78305: PPUSH
78306: CALL_OW 254
78310: PPUSH
78311: LD_INT 5
78313: PPUSH
78314: CALL_OW 272
78318: PUSH
78319: LD_VAR 0 17
78323: PUSH
78324: LD_INT 1
78326: ARRAY
78327: PPUSH
78328: CALL_OW 251
78332: PPUSH
78333: LD_VAR 0 17
78337: PUSH
78338: LD_INT 1
78340: ARRAY
78341: PPUSH
78342: CALL_OW 254
78346: PPUSH
78347: LD_INT 5
78349: PPUSH
78350: CALL_OW 273
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78359: LD_VAR 0 16
78363: PUSH
78364: LD_INT 1
78366: ARRAY
78367: PPUSH
78368: LD_VAR 0 16
78372: PUSH
78373: LD_INT 2
78375: ARRAY
78376: PPUSH
78377: CALL_OW 488
78381: IFFALSE 78412
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78383: LD_VAR 0 13
78387: PPUSH
78388: LD_VAR 0 16
78392: PUSH
78393: LD_INT 1
78395: ARRAY
78396: PPUSH
78397: LD_VAR 0 16
78401: PUSH
78402: LD_INT 2
78404: ARRAY
78405: PPUSH
78406: CALL_OW 111
// continue ;
78410: GO 77902
// end ; end ; r := GetDir ( tmp ) ;
78412: LD_ADDR_VAR 0 15
78416: PUSH
78417: LD_VAR 0 13
78421: PPUSH
78422: CALL_OW 254
78426: ST_TO_ADDR
// if r = 5 then
78427: LD_VAR 0 15
78431: PUSH
78432: LD_INT 5
78434: EQUAL
78435: IFFALSE 78445
// r := 0 ;
78437: LD_ADDR_VAR 0 15
78441: PUSH
78442: LD_INT 0
78444: ST_TO_ADDR
// for j = r to 5 do
78445: LD_ADDR_VAR 0 10
78449: PUSH
78450: DOUBLE
78451: LD_VAR 0 15
78455: DEC
78456: ST_TO_ADDR
78457: LD_INT 5
78459: PUSH
78460: FOR_TO
78461: IFFALSE 78575
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78463: LD_ADDR_VAR 0 11
78467: PUSH
78468: LD_VAR 0 13
78472: PPUSH
78473: CALL_OW 250
78477: PPUSH
78478: LD_VAR 0 10
78482: PPUSH
78483: LD_INT 2
78485: PPUSH
78486: CALL_OW 272
78490: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78491: LD_ADDR_VAR 0 12
78495: PUSH
78496: LD_VAR 0 13
78500: PPUSH
78501: CALL_OW 251
78505: PPUSH
78506: LD_VAR 0 10
78510: PPUSH
78511: LD_INT 2
78513: PPUSH
78514: CALL_OW 273
78518: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78519: LD_VAR 0 11
78523: PPUSH
78524: LD_VAR 0 12
78528: PPUSH
78529: CALL_OW 488
78533: PUSH
78534: LD_VAR 0 11
78538: PPUSH
78539: LD_VAR 0 12
78543: PPUSH
78544: CALL_OW 428
78548: NOT
78549: AND
78550: IFFALSE 78573
// begin ComMoveXY ( tmp , _x , _y ) ;
78552: LD_VAR 0 13
78556: PPUSH
78557: LD_VAR 0 11
78561: PPUSH
78562: LD_VAR 0 12
78566: PPUSH
78567: CALL_OW 111
// break ;
78571: GO 78575
// end ; end ;
78573: GO 78460
78575: POP
78576: POP
// end ; end ;
78577: GO 77902
78579: POP
78580: POP
// end ;
78581: LD_VAR 0 8
78585: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78586: LD_INT 0
78588: PPUSH
// result := true ;
78589: LD_ADDR_VAR 0 3
78593: PUSH
78594: LD_INT 1
78596: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78597: LD_VAR 0 2
78601: PUSH
78602: LD_INT 24
78604: DOUBLE
78605: EQUAL
78606: IFTRUE 78616
78608: LD_INT 33
78610: DOUBLE
78611: EQUAL
78612: IFTRUE 78616
78614: GO 78641
78616: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78617: LD_ADDR_VAR 0 3
78621: PUSH
78622: LD_INT 32
78624: PPUSH
78625: LD_VAR 0 1
78629: PPUSH
78630: CALL_OW 321
78634: PUSH
78635: LD_INT 2
78637: EQUAL
78638: ST_TO_ADDR
78639: GO 78961
78641: LD_INT 20
78643: DOUBLE
78644: EQUAL
78645: IFTRUE 78649
78647: GO 78674
78649: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78650: LD_ADDR_VAR 0 3
78654: PUSH
78655: LD_INT 6
78657: PPUSH
78658: LD_VAR 0 1
78662: PPUSH
78663: CALL_OW 321
78667: PUSH
78668: LD_INT 2
78670: EQUAL
78671: ST_TO_ADDR
78672: GO 78961
78674: LD_INT 22
78676: DOUBLE
78677: EQUAL
78678: IFTRUE 78688
78680: LD_INT 36
78682: DOUBLE
78683: EQUAL
78684: IFTRUE 78688
78686: GO 78713
78688: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78689: LD_ADDR_VAR 0 3
78693: PUSH
78694: LD_INT 15
78696: PPUSH
78697: LD_VAR 0 1
78701: PPUSH
78702: CALL_OW 321
78706: PUSH
78707: LD_INT 2
78709: EQUAL
78710: ST_TO_ADDR
78711: GO 78961
78713: LD_INT 30
78715: DOUBLE
78716: EQUAL
78717: IFTRUE 78721
78719: GO 78746
78721: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78722: LD_ADDR_VAR 0 3
78726: PUSH
78727: LD_INT 20
78729: PPUSH
78730: LD_VAR 0 1
78734: PPUSH
78735: CALL_OW 321
78739: PUSH
78740: LD_INT 2
78742: EQUAL
78743: ST_TO_ADDR
78744: GO 78961
78746: LD_INT 28
78748: DOUBLE
78749: EQUAL
78750: IFTRUE 78760
78752: LD_INT 21
78754: DOUBLE
78755: EQUAL
78756: IFTRUE 78760
78758: GO 78785
78760: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78761: LD_ADDR_VAR 0 3
78765: PUSH
78766: LD_INT 21
78768: PPUSH
78769: LD_VAR 0 1
78773: PPUSH
78774: CALL_OW 321
78778: PUSH
78779: LD_INT 2
78781: EQUAL
78782: ST_TO_ADDR
78783: GO 78961
78785: LD_INT 16
78787: DOUBLE
78788: EQUAL
78789: IFTRUE 78793
78791: GO 78820
78793: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78794: LD_ADDR_VAR 0 3
78798: PUSH
78799: LD_EXP 107
78803: PPUSH
78804: LD_VAR 0 1
78808: PPUSH
78809: CALL_OW 321
78813: PUSH
78814: LD_INT 2
78816: EQUAL
78817: ST_TO_ADDR
78818: GO 78961
78820: LD_INT 19
78822: DOUBLE
78823: EQUAL
78824: IFTRUE 78834
78826: LD_INT 23
78828: DOUBLE
78829: EQUAL
78830: IFTRUE 78834
78832: GO 78861
78834: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
78835: LD_ADDR_VAR 0 3
78839: PUSH
78840: LD_EXP 106
78844: PPUSH
78845: LD_VAR 0 1
78849: PPUSH
78850: CALL_OW 321
78854: PUSH
78855: LD_INT 2
78857: EQUAL
78858: ST_TO_ADDR
78859: GO 78961
78861: LD_INT 17
78863: DOUBLE
78864: EQUAL
78865: IFTRUE 78869
78867: GO 78894
78869: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
78870: LD_ADDR_VAR 0 3
78874: PUSH
78875: LD_INT 39
78877: PPUSH
78878: LD_VAR 0 1
78882: PPUSH
78883: CALL_OW 321
78887: PUSH
78888: LD_INT 2
78890: EQUAL
78891: ST_TO_ADDR
78892: GO 78961
78894: LD_INT 18
78896: DOUBLE
78897: EQUAL
78898: IFTRUE 78902
78900: GO 78927
78902: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
78903: LD_ADDR_VAR 0 3
78907: PUSH
78908: LD_INT 40
78910: PPUSH
78911: LD_VAR 0 1
78915: PPUSH
78916: CALL_OW 321
78920: PUSH
78921: LD_INT 2
78923: EQUAL
78924: ST_TO_ADDR
78925: GO 78961
78927: LD_INT 27
78929: DOUBLE
78930: EQUAL
78931: IFTRUE 78935
78933: GO 78960
78935: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
78936: LD_ADDR_VAR 0 3
78940: PUSH
78941: LD_INT 35
78943: PPUSH
78944: LD_VAR 0 1
78948: PPUSH
78949: CALL_OW 321
78953: PUSH
78954: LD_INT 2
78956: EQUAL
78957: ST_TO_ADDR
78958: GO 78961
78960: POP
// end ;
78961: LD_VAR 0 3
78965: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
78966: LD_INT 0
78968: PPUSH
78969: PPUSH
78970: PPUSH
78971: PPUSH
78972: PPUSH
78973: PPUSH
78974: PPUSH
78975: PPUSH
78976: PPUSH
78977: PPUSH
78978: PPUSH
// result := false ;
78979: LD_ADDR_VAR 0 6
78983: PUSH
78984: LD_INT 0
78986: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78987: LD_VAR 0 1
78991: NOT
78992: PUSH
78993: LD_VAR 0 1
78997: PPUSH
78998: CALL_OW 266
79002: PUSH
79003: LD_INT 0
79005: PUSH
79006: LD_INT 1
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: IN
79013: NOT
79014: OR
79015: PUSH
79016: LD_VAR 0 2
79020: NOT
79021: OR
79022: PUSH
79023: LD_VAR 0 5
79027: PUSH
79028: LD_INT 0
79030: PUSH
79031: LD_INT 1
79033: PUSH
79034: LD_INT 2
79036: PUSH
79037: LD_INT 3
79039: PUSH
79040: LD_INT 4
79042: PUSH
79043: LD_INT 5
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: LIST
79050: LIST
79051: LIST
79052: LIST
79053: IN
79054: NOT
79055: OR
79056: PUSH
79057: LD_VAR 0 3
79061: PPUSH
79062: LD_VAR 0 4
79066: PPUSH
79067: CALL_OW 488
79071: NOT
79072: OR
79073: IFFALSE 79077
// exit ;
79075: GO 79813
// side := GetSide ( depot ) ;
79077: LD_ADDR_VAR 0 9
79081: PUSH
79082: LD_VAR 0 1
79086: PPUSH
79087: CALL_OW 255
79091: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
79092: LD_VAR 0 9
79096: PPUSH
79097: LD_VAR 0 2
79101: PPUSH
79102: CALL 78586 0 2
79106: NOT
79107: IFFALSE 79111
// exit ;
79109: GO 79813
// pom := GetBase ( depot ) ;
79111: LD_ADDR_VAR 0 10
79115: PUSH
79116: LD_VAR 0 1
79120: PPUSH
79121: CALL_OW 274
79125: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79126: LD_ADDR_VAR 0 11
79130: PUSH
79131: LD_VAR 0 2
79135: PPUSH
79136: LD_VAR 0 1
79140: PPUSH
79141: CALL_OW 248
79145: PPUSH
79146: CALL_OW 450
79150: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79151: LD_VAR 0 10
79155: PPUSH
79156: LD_INT 1
79158: PPUSH
79159: CALL_OW 275
79163: PUSH
79164: LD_VAR 0 11
79168: PUSH
79169: LD_INT 1
79171: ARRAY
79172: GREATEREQUAL
79173: PUSH
79174: LD_VAR 0 10
79178: PPUSH
79179: LD_INT 2
79181: PPUSH
79182: CALL_OW 275
79186: PUSH
79187: LD_VAR 0 11
79191: PUSH
79192: LD_INT 2
79194: ARRAY
79195: GREATEREQUAL
79196: AND
79197: PUSH
79198: LD_VAR 0 10
79202: PPUSH
79203: LD_INT 3
79205: PPUSH
79206: CALL_OW 275
79210: PUSH
79211: LD_VAR 0 11
79215: PUSH
79216: LD_INT 3
79218: ARRAY
79219: GREATEREQUAL
79220: AND
79221: NOT
79222: IFFALSE 79226
// exit ;
79224: GO 79813
// if GetBType ( depot ) = b_depot then
79226: LD_VAR 0 1
79230: PPUSH
79231: CALL_OW 266
79235: PUSH
79236: LD_INT 0
79238: EQUAL
79239: IFFALSE 79251
// dist := 28 else
79241: LD_ADDR_VAR 0 14
79245: PUSH
79246: LD_INT 28
79248: ST_TO_ADDR
79249: GO 79259
// dist := 36 ;
79251: LD_ADDR_VAR 0 14
79255: PUSH
79256: LD_INT 36
79258: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79259: LD_VAR 0 1
79263: PPUSH
79264: LD_VAR 0 3
79268: PPUSH
79269: LD_VAR 0 4
79273: PPUSH
79274: CALL_OW 297
79278: PUSH
79279: LD_VAR 0 14
79283: GREATER
79284: IFFALSE 79288
// exit ;
79286: GO 79813
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79288: LD_ADDR_VAR 0 12
79292: PUSH
79293: LD_VAR 0 2
79297: PPUSH
79298: LD_VAR 0 3
79302: PPUSH
79303: LD_VAR 0 4
79307: PPUSH
79308: LD_VAR 0 5
79312: PPUSH
79313: LD_VAR 0 1
79317: PPUSH
79318: CALL_OW 248
79322: PPUSH
79323: LD_INT 0
79325: PPUSH
79326: CALL 79818 0 6
79330: ST_TO_ADDR
// if not hexes then
79331: LD_VAR 0 12
79335: NOT
79336: IFFALSE 79340
// exit ;
79338: GO 79813
// hex := GetHexInfo ( x , y ) ;
79340: LD_ADDR_VAR 0 15
79344: PUSH
79345: LD_VAR 0 3
79349: PPUSH
79350: LD_VAR 0 4
79354: PPUSH
79355: CALL_OW 546
79359: ST_TO_ADDR
// if hex [ 1 ] then
79360: LD_VAR 0 15
79364: PUSH
79365: LD_INT 1
79367: ARRAY
79368: IFFALSE 79372
// exit ;
79370: GO 79813
// height := hex [ 2 ] ;
79372: LD_ADDR_VAR 0 13
79376: PUSH
79377: LD_VAR 0 15
79381: PUSH
79382: LD_INT 2
79384: ARRAY
79385: ST_TO_ADDR
// for i = 1 to hexes do
79386: LD_ADDR_VAR 0 7
79390: PUSH
79391: DOUBLE
79392: LD_INT 1
79394: DEC
79395: ST_TO_ADDR
79396: LD_VAR 0 12
79400: PUSH
79401: FOR_TO
79402: IFFALSE 79732
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79404: LD_VAR 0 12
79408: PUSH
79409: LD_VAR 0 7
79413: ARRAY
79414: PUSH
79415: LD_INT 1
79417: ARRAY
79418: PPUSH
79419: LD_VAR 0 12
79423: PUSH
79424: LD_VAR 0 7
79428: ARRAY
79429: PUSH
79430: LD_INT 2
79432: ARRAY
79433: PPUSH
79434: CALL_OW 488
79438: NOT
79439: PUSH
79440: LD_VAR 0 12
79444: PUSH
79445: LD_VAR 0 7
79449: ARRAY
79450: PUSH
79451: LD_INT 1
79453: ARRAY
79454: PPUSH
79455: LD_VAR 0 12
79459: PUSH
79460: LD_VAR 0 7
79464: ARRAY
79465: PUSH
79466: LD_INT 2
79468: ARRAY
79469: PPUSH
79470: CALL_OW 428
79474: PUSH
79475: LD_INT 0
79477: GREATER
79478: OR
79479: PUSH
79480: LD_VAR 0 12
79484: PUSH
79485: LD_VAR 0 7
79489: ARRAY
79490: PUSH
79491: LD_INT 1
79493: ARRAY
79494: PPUSH
79495: LD_VAR 0 12
79499: PUSH
79500: LD_VAR 0 7
79504: ARRAY
79505: PUSH
79506: LD_INT 2
79508: ARRAY
79509: PPUSH
79510: CALL_OW 351
79514: OR
79515: IFFALSE 79521
// exit ;
79517: POP
79518: POP
79519: GO 79813
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79521: LD_ADDR_VAR 0 8
79525: PUSH
79526: LD_VAR 0 12
79530: PUSH
79531: LD_VAR 0 7
79535: ARRAY
79536: PUSH
79537: LD_INT 1
79539: ARRAY
79540: PPUSH
79541: LD_VAR 0 12
79545: PUSH
79546: LD_VAR 0 7
79550: ARRAY
79551: PUSH
79552: LD_INT 2
79554: ARRAY
79555: PPUSH
79556: CALL_OW 546
79560: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79561: LD_VAR 0 8
79565: PUSH
79566: LD_INT 1
79568: ARRAY
79569: PUSH
79570: LD_VAR 0 8
79574: PUSH
79575: LD_INT 2
79577: ARRAY
79578: PUSH
79579: LD_VAR 0 13
79583: PUSH
79584: LD_INT 2
79586: PLUS
79587: GREATER
79588: OR
79589: PUSH
79590: LD_VAR 0 8
79594: PUSH
79595: LD_INT 2
79597: ARRAY
79598: PUSH
79599: LD_VAR 0 13
79603: PUSH
79604: LD_INT 2
79606: MINUS
79607: LESS
79608: OR
79609: PUSH
79610: LD_VAR 0 8
79614: PUSH
79615: LD_INT 3
79617: ARRAY
79618: PUSH
79619: LD_INT 0
79621: PUSH
79622: LD_INT 8
79624: PUSH
79625: LD_INT 9
79627: PUSH
79628: LD_INT 10
79630: PUSH
79631: LD_INT 11
79633: PUSH
79634: LD_INT 12
79636: PUSH
79637: LD_INT 13
79639: PUSH
79640: LD_INT 16
79642: PUSH
79643: LD_INT 17
79645: PUSH
79646: LD_INT 18
79648: PUSH
79649: LD_INT 19
79651: PUSH
79652: LD_INT 20
79654: PUSH
79655: LD_INT 21
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: LIST
79662: LIST
79663: LIST
79664: LIST
79665: LIST
79666: LIST
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: IN
79673: NOT
79674: OR
79675: PUSH
79676: LD_VAR 0 8
79680: PUSH
79681: LD_INT 5
79683: ARRAY
79684: NOT
79685: OR
79686: PUSH
79687: LD_VAR 0 8
79691: PUSH
79692: LD_INT 6
79694: ARRAY
79695: PUSH
79696: LD_INT 1
79698: PUSH
79699: LD_INT 2
79701: PUSH
79702: LD_INT 7
79704: PUSH
79705: LD_INT 9
79707: PUSH
79708: LD_INT 10
79710: PUSH
79711: LD_INT 11
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: LIST
79720: LIST
79721: IN
79722: NOT
79723: OR
79724: IFFALSE 79730
// exit ;
79726: POP
79727: POP
79728: GO 79813
// end ;
79730: GO 79401
79732: POP
79733: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79734: LD_VAR 0 9
79738: PPUSH
79739: LD_VAR 0 3
79743: PPUSH
79744: LD_VAR 0 4
79748: PPUSH
79749: LD_INT 20
79751: PPUSH
79752: CALL 71759 0 4
79756: PUSH
79757: LD_INT 4
79759: ARRAY
79760: IFFALSE 79764
// exit ;
79762: GO 79813
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79764: LD_VAR 0 2
79768: PUSH
79769: LD_INT 29
79771: PUSH
79772: LD_INT 30
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: IN
79779: PUSH
79780: LD_VAR 0 3
79784: PPUSH
79785: LD_VAR 0 4
79789: PPUSH
79790: LD_VAR 0 9
79794: PPUSH
79795: CALL_OW 440
79799: NOT
79800: AND
79801: IFFALSE 79805
// exit ;
79803: GO 79813
// result := true ;
79805: LD_ADDR_VAR 0 6
79809: PUSH
79810: LD_INT 1
79812: ST_TO_ADDR
// end ;
79813: LD_VAR 0 6
79817: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
79818: LD_INT 0
79820: PPUSH
79821: PPUSH
79822: PPUSH
79823: PPUSH
79824: PPUSH
79825: PPUSH
79826: PPUSH
79827: PPUSH
79828: PPUSH
79829: PPUSH
79830: PPUSH
79831: PPUSH
79832: PPUSH
79833: PPUSH
79834: PPUSH
79835: PPUSH
79836: PPUSH
79837: PPUSH
79838: PPUSH
79839: PPUSH
79840: PPUSH
79841: PPUSH
79842: PPUSH
79843: PPUSH
79844: PPUSH
79845: PPUSH
79846: PPUSH
79847: PPUSH
79848: PPUSH
79849: PPUSH
79850: PPUSH
79851: PPUSH
79852: PPUSH
79853: PPUSH
79854: PPUSH
79855: PPUSH
79856: PPUSH
79857: PPUSH
79858: PPUSH
79859: PPUSH
79860: PPUSH
79861: PPUSH
79862: PPUSH
79863: PPUSH
79864: PPUSH
79865: PPUSH
79866: PPUSH
79867: PPUSH
79868: PPUSH
79869: PPUSH
79870: PPUSH
79871: PPUSH
79872: PPUSH
79873: PPUSH
79874: PPUSH
79875: PPUSH
79876: PPUSH
79877: PPUSH
// result = [ ] ;
79878: LD_ADDR_VAR 0 7
79882: PUSH
79883: EMPTY
79884: ST_TO_ADDR
// temp_list = [ ] ;
79885: LD_ADDR_VAR 0 9
79889: PUSH
79890: EMPTY
79891: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79892: LD_VAR 0 4
79896: PUSH
79897: LD_INT 0
79899: PUSH
79900: LD_INT 1
79902: PUSH
79903: LD_INT 2
79905: PUSH
79906: LD_INT 3
79908: PUSH
79909: LD_INT 4
79911: PUSH
79912: LD_INT 5
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: IN
79923: NOT
79924: PUSH
79925: LD_VAR 0 1
79929: PUSH
79930: LD_INT 0
79932: PUSH
79933: LD_INT 1
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: IN
79940: PUSH
79941: LD_VAR 0 5
79945: PUSH
79946: LD_INT 1
79948: PUSH
79949: LD_INT 2
79951: PUSH
79952: LD_INT 3
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: LIST
79959: IN
79960: NOT
79961: AND
79962: OR
79963: IFFALSE 79967
// exit ;
79965: GO 98358
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79967: LD_VAR 0 1
79971: PUSH
79972: LD_INT 6
79974: PUSH
79975: LD_INT 7
79977: PUSH
79978: LD_INT 8
79980: PUSH
79981: LD_INT 13
79983: PUSH
79984: LD_INT 12
79986: PUSH
79987: LD_INT 15
79989: PUSH
79990: LD_INT 11
79992: PUSH
79993: LD_INT 14
79995: PUSH
79996: LD_INT 10
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: IN
80010: IFFALSE 80020
// btype = b_lab ;
80012: LD_ADDR_VAR 0 1
80016: PUSH
80017: LD_INT 6
80019: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80020: LD_VAR 0 6
80024: PUSH
80025: LD_INT 0
80027: PUSH
80028: LD_INT 1
80030: PUSH
80031: LD_INT 2
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: LIST
80038: IN
80039: NOT
80040: PUSH
80041: LD_VAR 0 1
80045: PUSH
80046: LD_INT 0
80048: PUSH
80049: LD_INT 1
80051: PUSH
80052: LD_INT 2
80054: PUSH
80055: LD_INT 3
80057: PUSH
80058: LD_INT 6
80060: PUSH
80061: LD_INT 36
80063: PUSH
80064: LD_INT 4
80066: PUSH
80067: LD_INT 5
80069: PUSH
80070: LD_INT 31
80072: PUSH
80073: LD_INT 32
80075: PUSH
80076: LD_INT 33
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: IN
80092: NOT
80093: PUSH
80094: LD_VAR 0 6
80098: PUSH
80099: LD_INT 1
80101: EQUAL
80102: AND
80103: OR
80104: PUSH
80105: LD_VAR 0 1
80109: PUSH
80110: LD_INT 2
80112: PUSH
80113: LD_INT 3
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: IN
80120: NOT
80121: PUSH
80122: LD_VAR 0 6
80126: PUSH
80127: LD_INT 2
80129: EQUAL
80130: AND
80131: OR
80132: IFFALSE 80142
// mode = 0 ;
80134: LD_ADDR_VAR 0 6
80138: PUSH
80139: LD_INT 0
80141: ST_TO_ADDR
// case mode of 0 :
80142: LD_VAR 0 6
80146: PUSH
80147: LD_INT 0
80149: DOUBLE
80150: EQUAL
80151: IFTRUE 80155
80153: GO 91608
80155: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80156: LD_ADDR_VAR 0 11
80160: PUSH
80161: LD_INT 0
80163: PUSH
80164: LD_INT 0
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 0
80173: PUSH
80174: LD_INT 1
80176: NEG
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 1
80184: PUSH
80185: LD_INT 0
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 1
80194: PUSH
80195: LD_INT 1
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 0
80204: PUSH
80205: LD_INT 1
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 1
80214: NEG
80215: PUSH
80216: LD_INT 0
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 1
80225: NEG
80226: PUSH
80227: LD_INT 1
80229: NEG
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 1
80237: NEG
80238: PUSH
80239: LD_INT 2
80241: NEG
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 0
80249: PUSH
80250: LD_INT 2
80252: NEG
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 1
80260: PUSH
80261: LD_INT 1
80263: NEG
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 1
80271: PUSH
80272: LD_INT 2
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 0
80281: PUSH
80282: LD_INT 2
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 1
80291: NEG
80292: PUSH
80293: LD_INT 1
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: PUSH
80300: LD_INT 1
80302: PUSH
80303: LD_INT 3
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 0
80312: PUSH
80313: LD_INT 3
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 1
80322: NEG
80323: PUSH
80324: LD_INT 2
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80349: LD_ADDR_VAR 0 12
80353: PUSH
80354: LD_INT 0
80356: PUSH
80357: LD_INT 0
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: LD_INT 0
80366: PUSH
80367: LD_INT 1
80369: NEG
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: LD_INT 1
80377: PUSH
80378: LD_INT 0
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 1
80387: PUSH
80388: LD_INT 1
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 0
80397: PUSH
80398: LD_INT 1
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 1
80407: NEG
80408: PUSH
80409: LD_INT 0
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PUSH
80416: LD_INT 1
80418: NEG
80419: PUSH
80420: LD_INT 1
80422: NEG
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 1
80430: PUSH
80431: LD_INT 1
80433: NEG
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 2
80441: PUSH
80442: LD_INT 0
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 2
80451: PUSH
80452: LD_INT 1
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 1
80461: NEG
80462: PUSH
80463: LD_INT 1
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 2
80472: NEG
80473: PUSH
80474: LD_INT 0
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 2
80483: NEG
80484: PUSH
80485: LD_INT 1
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 2
80495: NEG
80496: PUSH
80497: LD_INT 1
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 3
80506: NEG
80507: PUSH
80508: LD_INT 0
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 3
80517: NEG
80518: PUSH
80519: LD_INT 1
80521: NEG
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80545: LD_ADDR_VAR 0 13
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: LD_INT 0
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: PUSH
80560: LD_INT 0
80562: PUSH
80563: LD_INT 1
80565: NEG
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 1
80573: PUSH
80574: LD_INT 0
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 1
80583: PUSH
80584: LD_INT 1
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: LD_INT 1
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 1
80603: NEG
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 1
80614: NEG
80615: PUSH
80616: LD_INT 1
80618: NEG
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 1
80626: NEG
80627: PUSH
80628: LD_INT 2
80630: NEG
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 2
80638: PUSH
80639: LD_INT 1
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 2
80648: PUSH
80649: LD_INT 2
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 1
80658: PUSH
80659: LD_INT 2
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 2
80668: NEG
80669: PUSH
80670: LD_INT 1
80672: NEG
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 2
80680: NEG
80681: PUSH
80682: LD_INT 2
80684: NEG
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 2
80692: NEG
80693: PUSH
80694: LD_INT 3
80696: NEG
80697: PUSH
80698: EMPTY
80699: LIST
80700: LIST
80701: PUSH
80702: LD_INT 3
80704: NEG
80705: PUSH
80706: LD_INT 2
80708: NEG
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 3
80716: NEG
80717: PUSH
80718: LD_INT 3
80720: NEG
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80744: LD_ADDR_VAR 0 14
80748: PUSH
80749: LD_INT 0
80751: PUSH
80752: LD_INT 0
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 0
80761: PUSH
80762: LD_INT 1
80764: NEG
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PUSH
80770: LD_INT 1
80772: PUSH
80773: LD_INT 0
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 1
80782: PUSH
80783: LD_INT 1
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 0
80792: PUSH
80793: LD_INT 1
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 1
80802: NEG
80803: PUSH
80804: LD_INT 0
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 1
80813: NEG
80814: PUSH
80815: LD_INT 1
80817: NEG
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 1
80825: NEG
80826: PUSH
80827: LD_INT 2
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 0
80837: PUSH
80838: LD_INT 2
80840: NEG
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 1
80848: PUSH
80849: LD_INT 1
80851: NEG
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 1
80859: PUSH
80860: LD_INT 2
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 0
80869: PUSH
80870: LD_INT 2
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 1
80879: NEG
80880: PUSH
80881: LD_INT 1
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 1
80890: NEG
80891: PUSH
80892: LD_INT 3
80894: NEG
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: PUSH
80900: LD_INT 0
80902: PUSH
80903: LD_INT 3
80905: NEG
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: LD_INT 1
80913: PUSH
80914: LD_INT 2
80916: NEG
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80940: LD_ADDR_VAR 0 15
80944: PUSH
80945: LD_INT 0
80947: PUSH
80948: LD_INT 0
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 0
80957: PUSH
80958: LD_INT 1
80960: NEG
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 1
80968: PUSH
80969: LD_INT 0
80971: PUSH
80972: EMPTY
80973: LIST
80974: LIST
80975: PUSH
80976: LD_INT 1
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 0
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 1
80998: NEG
80999: PUSH
81000: LD_INT 0
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 1
81009: NEG
81010: PUSH
81011: LD_INT 1
81013: NEG
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: PUSH
81022: LD_INT 1
81024: NEG
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 2
81032: PUSH
81033: LD_INT 0
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 2
81042: PUSH
81043: LD_INT 1
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 1
81052: NEG
81053: PUSH
81054: LD_INT 1
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 2
81063: NEG
81064: PUSH
81065: LD_INT 0
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: LD_INT 2
81074: NEG
81075: PUSH
81076: LD_INT 1
81078: NEG
81079: PUSH
81080: EMPTY
81081: LIST
81082: LIST
81083: PUSH
81084: LD_INT 2
81086: PUSH
81087: LD_INT 1
81089: NEG
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PUSH
81095: LD_INT 3
81097: PUSH
81098: LD_INT 0
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 3
81107: PUSH
81108: LD_INT 1
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: LIST
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81133: LD_ADDR_VAR 0 16
81137: PUSH
81138: LD_INT 0
81140: PUSH
81141: LD_INT 0
81143: PUSH
81144: EMPTY
81145: LIST
81146: LIST
81147: PUSH
81148: LD_INT 0
81150: PUSH
81151: LD_INT 1
81153: NEG
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 1
81161: PUSH
81162: LD_INT 0
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 1
81171: PUSH
81172: LD_INT 1
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 0
81181: PUSH
81182: LD_INT 1
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 1
81191: NEG
81192: PUSH
81193: LD_INT 0
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 1
81202: NEG
81203: PUSH
81204: LD_INT 1
81206: NEG
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: LD_INT 1
81214: NEG
81215: PUSH
81216: LD_INT 2
81218: NEG
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 2
81226: PUSH
81227: LD_INT 1
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 2
81236: PUSH
81237: LD_INT 2
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 1
81246: PUSH
81247: LD_INT 2
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 2
81256: NEG
81257: PUSH
81258: LD_INT 1
81260: NEG
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 2
81268: NEG
81269: PUSH
81270: LD_INT 2
81272: NEG
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 3
81280: PUSH
81281: LD_INT 2
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 3
81290: PUSH
81291: LD_INT 3
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 2
81300: PUSH
81301: LD_INT 3
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: LIST
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: LIST
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81326: LD_ADDR_VAR 0 17
81330: PUSH
81331: LD_INT 0
81333: PUSH
81334: LD_INT 0
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: PUSH
81341: LD_INT 0
81343: PUSH
81344: LD_INT 1
81346: NEG
81347: PUSH
81348: EMPTY
81349: LIST
81350: LIST
81351: PUSH
81352: LD_INT 1
81354: PUSH
81355: LD_INT 0
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 1
81364: PUSH
81365: LD_INT 1
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 0
81374: PUSH
81375: LD_INT 1
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 1
81384: NEG
81385: PUSH
81386: LD_INT 0
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 1
81395: NEG
81396: PUSH
81397: LD_INT 1
81399: NEG
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 1
81407: NEG
81408: PUSH
81409: LD_INT 2
81411: NEG
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 0
81419: PUSH
81420: LD_INT 2
81422: NEG
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 1
81430: PUSH
81431: LD_INT 1
81433: NEG
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 2
81441: PUSH
81442: LD_INT 0
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 2
81451: PUSH
81452: LD_INT 1
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 2
81461: PUSH
81462: LD_INT 2
81464: PUSH
81465: EMPTY
81466: LIST
81467: LIST
81468: PUSH
81469: LD_INT 1
81471: PUSH
81472: LD_INT 2
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 0
81481: PUSH
81482: LD_INT 2
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 1
81491: NEG
81492: PUSH
81493: LD_INT 1
81495: PUSH
81496: EMPTY
81497: LIST
81498: LIST
81499: PUSH
81500: LD_INT 2
81502: NEG
81503: PUSH
81504: LD_INT 0
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 2
81513: NEG
81514: PUSH
81515: LD_INT 1
81517: NEG
81518: PUSH
81519: EMPTY
81520: LIST
81521: LIST
81522: PUSH
81523: LD_INT 2
81525: NEG
81526: PUSH
81527: LD_INT 2
81529: NEG
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81556: LD_ADDR_VAR 0 18
81560: PUSH
81561: LD_INT 0
81563: PUSH
81564: LD_INT 0
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: PUSH
81571: LD_INT 0
81573: PUSH
81574: LD_INT 1
81576: NEG
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: PUSH
81582: LD_INT 1
81584: PUSH
81585: LD_INT 0
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 1
81594: PUSH
81595: LD_INT 1
81597: PUSH
81598: EMPTY
81599: LIST
81600: LIST
81601: PUSH
81602: LD_INT 0
81604: PUSH
81605: LD_INT 1
81607: PUSH
81608: EMPTY
81609: LIST
81610: LIST
81611: PUSH
81612: LD_INT 1
81614: NEG
81615: PUSH
81616: LD_INT 0
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 1
81625: NEG
81626: PUSH
81627: LD_INT 1
81629: NEG
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: LD_INT 2
81641: NEG
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 0
81649: PUSH
81650: LD_INT 2
81652: NEG
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 1
81660: PUSH
81661: LD_INT 1
81663: NEG
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 2
81671: PUSH
81672: LD_INT 0
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PUSH
81679: LD_INT 2
81681: PUSH
81682: LD_INT 1
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 2
81691: PUSH
81692: LD_INT 2
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 1
81701: PUSH
81702: LD_INT 2
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 0
81711: PUSH
81712: LD_INT 2
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: LD_INT 1
81721: NEG
81722: PUSH
81723: LD_INT 1
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 2
81732: NEG
81733: PUSH
81734: LD_INT 0
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: PUSH
81741: LD_INT 2
81743: NEG
81744: PUSH
81745: LD_INT 1
81747: NEG
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 2
81755: NEG
81756: PUSH
81757: LD_INT 2
81759: NEG
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: LIST
81773: LIST
81774: LIST
81775: LIST
81776: LIST
81777: LIST
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81786: LD_ADDR_VAR 0 19
81790: PUSH
81791: LD_INT 0
81793: PUSH
81794: LD_INT 0
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 0
81803: PUSH
81804: LD_INT 1
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 1
81814: PUSH
81815: LD_INT 0
81817: PUSH
81818: EMPTY
81819: LIST
81820: LIST
81821: PUSH
81822: LD_INT 1
81824: PUSH
81825: LD_INT 1
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 0
81834: PUSH
81835: LD_INT 1
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 1
81844: NEG
81845: PUSH
81846: LD_INT 0
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: LD_INT 1
81855: NEG
81856: PUSH
81857: LD_INT 1
81859: NEG
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 1
81867: NEG
81868: PUSH
81869: LD_INT 2
81871: NEG
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 0
81879: PUSH
81880: LD_INT 2
81882: NEG
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_INT 1
81890: PUSH
81891: LD_INT 1
81893: NEG
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 2
81901: PUSH
81902: LD_INT 0
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 2
81911: PUSH
81912: LD_INT 1
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: PUSH
81919: LD_INT 2
81921: PUSH
81922: LD_INT 2
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 1
81931: PUSH
81932: LD_INT 2
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: LD_INT 2
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 1
81951: NEG
81952: PUSH
81953: LD_INT 1
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 2
81962: NEG
81963: PUSH
81964: LD_INT 0
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 2
81973: NEG
81974: PUSH
81975: LD_INT 1
81977: NEG
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 2
81985: NEG
81986: PUSH
81987: LD_INT 2
81989: NEG
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82016: LD_ADDR_VAR 0 20
82020: PUSH
82021: LD_INT 0
82023: PUSH
82024: LD_INT 0
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 0
82033: PUSH
82034: LD_INT 1
82036: NEG
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 1
82044: PUSH
82045: LD_INT 0
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 1
82054: PUSH
82055: LD_INT 1
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 0
82064: PUSH
82065: LD_INT 1
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: PUSH
82072: LD_INT 1
82074: NEG
82075: PUSH
82076: LD_INT 0
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 1
82085: NEG
82086: PUSH
82087: LD_INT 1
82089: NEG
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: PUSH
82095: LD_INT 1
82097: NEG
82098: PUSH
82099: LD_INT 2
82101: NEG
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: LD_INT 0
82109: PUSH
82110: LD_INT 2
82112: NEG
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 1
82120: PUSH
82121: LD_INT 1
82123: NEG
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 2
82131: PUSH
82132: LD_INT 0
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 2
82141: PUSH
82142: LD_INT 1
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 2
82151: PUSH
82152: LD_INT 2
82154: PUSH
82155: EMPTY
82156: LIST
82157: LIST
82158: PUSH
82159: LD_INT 1
82161: PUSH
82162: LD_INT 2
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 0
82171: PUSH
82172: LD_INT 2
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 1
82181: NEG
82182: PUSH
82183: LD_INT 1
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 2
82192: NEG
82193: PUSH
82194: LD_INT 0
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: PUSH
82201: LD_INT 2
82203: NEG
82204: PUSH
82205: LD_INT 1
82207: NEG
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 2
82215: NEG
82216: PUSH
82217: LD_INT 2
82219: NEG
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82246: LD_ADDR_VAR 0 21
82250: PUSH
82251: LD_INT 0
82253: PUSH
82254: LD_INT 0
82256: PUSH
82257: EMPTY
82258: LIST
82259: LIST
82260: PUSH
82261: LD_INT 0
82263: PUSH
82264: LD_INT 1
82266: NEG
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 1
82274: PUSH
82275: LD_INT 0
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 1
82284: PUSH
82285: LD_INT 1
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: LD_INT 1
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: PUSH
82302: LD_INT 1
82304: NEG
82305: PUSH
82306: LD_INT 0
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: LD_INT 1
82315: NEG
82316: PUSH
82317: LD_INT 1
82319: NEG
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 1
82327: NEG
82328: PUSH
82329: LD_INT 2
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 0
82339: PUSH
82340: LD_INT 2
82342: NEG
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 1
82350: PUSH
82351: LD_INT 1
82353: NEG
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 2
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 2
82371: PUSH
82372: LD_INT 1
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 2
82381: PUSH
82382: LD_INT 2
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PUSH
82389: LD_INT 1
82391: PUSH
82392: LD_INT 2
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 0
82401: PUSH
82402: LD_INT 2
82404: PUSH
82405: EMPTY
82406: LIST
82407: LIST
82408: PUSH
82409: LD_INT 1
82411: NEG
82412: PUSH
82413: LD_INT 1
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: LD_INT 2
82422: NEG
82423: PUSH
82424: LD_INT 0
82426: PUSH
82427: EMPTY
82428: LIST
82429: LIST
82430: PUSH
82431: LD_INT 2
82433: NEG
82434: PUSH
82435: LD_INT 1
82437: NEG
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 2
82445: NEG
82446: PUSH
82447: LD_INT 2
82449: NEG
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: LIST
82459: LIST
82460: LIST
82461: LIST
82462: LIST
82463: LIST
82464: LIST
82465: LIST
82466: LIST
82467: LIST
82468: LIST
82469: LIST
82470: LIST
82471: LIST
82472: LIST
82473: LIST
82474: LIST
82475: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82476: LD_ADDR_VAR 0 22
82480: PUSH
82481: LD_INT 0
82483: PUSH
82484: LD_INT 0
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: PUSH
82491: LD_INT 0
82493: PUSH
82494: LD_INT 1
82496: NEG
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 1
82504: PUSH
82505: LD_INT 0
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 1
82514: PUSH
82515: LD_INT 1
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 0
82524: PUSH
82525: LD_INT 1
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: LD_INT 1
82534: NEG
82535: PUSH
82536: LD_INT 0
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 1
82545: NEG
82546: PUSH
82547: LD_INT 1
82549: NEG
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 1
82557: NEG
82558: PUSH
82559: LD_INT 2
82561: NEG
82562: PUSH
82563: EMPTY
82564: LIST
82565: LIST
82566: PUSH
82567: LD_INT 0
82569: PUSH
82570: LD_INT 2
82572: NEG
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 1
82580: PUSH
82581: LD_INT 1
82583: NEG
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 2
82591: PUSH
82592: LD_INT 0
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 2
82601: PUSH
82602: LD_INT 1
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: PUSH
82609: LD_INT 2
82611: PUSH
82612: LD_INT 2
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: LD_INT 1
82621: PUSH
82622: LD_INT 2
82624: PUSH
82625: EMPTY
82626: LIST
82627: LIST
82628: PUSH
82629: LD_INT 0
82631: PUSH
82632: LD_INT 2
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 1
82641: NEG
82642: PUSH
82643: LD_INT 1
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 2
82652: NEG
82653: PUSH
82654: LD_INT 0
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 2
82663: NEG
82664: PUSH
82665: LD_INT 1
82667: NEG
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 2
82675: NEG
82676: PUSH
82677: LD_INT 2
82679: NEG
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: LIST
82694: LIST
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82706: LD_ADDR_VAR 0 23
82710: PUSH
82711: LD_INT 0
82713: PUSH
82714: LD_INT 0
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 0
82723: PUSH
82724: LD_INT 1
82726: NEG
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 1
82734: PUSH
82735: LD_INT 0
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 1
82744: PUSH
82745: LD_INT 1
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 0
82754: PUSH
82755: LD_INT 1
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 1
82764: NEG
82765: PUSH
82766: LD_INT 0
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 1
82775: NEG
82776: PUSH
82777: LD_INT 1
82779: NEG
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: PUSH
82785: LD_INT 1
82787: NEG
82788: PUSH
82789: LD_INT 2
82791: NEG
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PUSH
82797: LD_INT 0
82799: PUSH
82800: LD_INT 2
82802: NEG
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: LD_INT 1
82810: PUSH
82811: LD_INT 1
82813: NEG
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 2
82821: PUSH
82822: LD_INT 0
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 2
82831: PUSH
82832: LD_INT 1
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 2
82841: PUSH
82842: LD_INT 2
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 1
82851: PUSH
82852: LD_INT 2
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 0
82861: PUSH
82862: LD_INT 2
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 1
82871: NEG
82872: PUSH
82873: LD_INT 1
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 2
82882: NEG
82883: PUSH
82884: LD_INT 0
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 2
82893: NEG
82894: PUSH
82895: LD_INT 1
82897: NEG
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 2
82905: NEG
82906: PUSH
82907: LD_INT 2
82909: NEG
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 2
82917: NEG
82918: PUSH
82919: LD_INT 3
82921: NEG
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 1
82929: NEG
82930: PUSH
82931: LD_INT 3
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 1
82941: PUSH
82942: LD_INT 2
82944: NEG
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 2
82952: PUSH
82953: LD_INT 1
82955: NEG
82956: PUSH
82957: EMPTY
82958: LIST
82959: LIST
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: LIST
82965: LIST
82966: LIST
82967: LIST
82968: LIST
82969: LIST
82970: LIST
82971: LIST
82972: LIST
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82986: LD_ADDR_VAR 0 24
82990: PUSH
82991: LD_INT 0
82993: PUSH
82994: LD_INT 0
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 0
83003: PUSH
83004: LD_INT 1
83006: NEG
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 1
83014: PUSH
83015: LD_INT 0
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 1
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 0
83034: PUSH
83035: LD_INT 1
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PUSH
83042: LD_INT 1
83044: NEG
83045: PUSH
83046: LD_INT 0
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 1
83055: NEG
83056: PUSH
83057: LD_INT 1
83059: NEG
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 1
83067: NEG
83068: PUSH
83069: LD_INT 2
83071: NEG
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: PUSH
83077: LD_INT 0
83079: PUSH
83080: LD_INT 2
83082: NEG
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 1
83090: PUSH
83091: LD_INT 1
83093: NEG
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 2
83101: PUSH
83102: LD_INT 0
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 2
83111: PUSH
83112: LD_INT 1
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 2
83121: PUSH
83122: LD_INT 2
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 1
83131: PUSH
83132: LD_INT 2
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 0
83141: PUSH
83142: LD_INT 2
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: LD_INT 1
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 2
83162: NEG
83163: PUSH
83164: LD_INT 0
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 2
83173: NEG
83174: PUSH
83175: LD_INT 1
83177: NEG
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 2
83185: NEG
83186: PUSH
83187: LD_INT 2
83189: NEG
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 1
83197: PUSH
83198: LD_INT 2
83200: NEG
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 2
83208: PUSH
83209: LD_INT 1
83211: NEG
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 3
83219: PUSH
83220: LD_INT 1
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 3
83229: PUSH
83230: LD_INT 2
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83262: LD_ADDR_VAR 0 25
83266: PUSH
83267: LD_INT 0
83269: PUSH
83270: LD_INT 0
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 0
83279: PUSH
83280: LD_INT 1
83282: NEG
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 1
83290: PUSH
83291: LD_INT 0
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 1
83300: PUSH
83301: LD_INT 1
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 0
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 1
83320: NEG
83321: PUSH
83322: LD_INT 0
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 1
83331: NEG
83332: PUSH
83333: LD_INT 1
83335: NEG
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 1
83343: NEG
83344: PUSH
83345: LD_INT 2
83347: NEG
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: LD_INT 0
83355: PUSH
83356: LD_INT 2
83358: NEG
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 1
83366: PUSH
83367: LD_INT 1
83369: NEG
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 2
83377: PUSH
83378: LD_INT 0
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 2
83387: PUSH
83388: LD_INT 1
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 2
83397: PUSH
83398: LD_INT 2
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 1
83407: PUSH
83408: LD_INT 2
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 0
83417: PUSH
83418: LD_INT 2
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 1
83427: NEG
83428: PUSH
83429: LD_INT 1
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 2
83438: NEG
83439: PUSH
83440: LD_INT 0
83442: PUSH
83443: EMPTY
83444: LIST
83445: LIST
83446: PUSH
83447: LD_INT 2
83449: NEG
83450: PUSH
83451: LD_INT 1
83453: NEG
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 2
83461: NEG
83462: PUSH
83463: LD_INT 2
83465: NEG
83466: PUSH
83467: EMPTY
83468: LIST
83469: LIST
83470: PUSH
83471: LD_INT 3
83473: PUSH
83474: LD_INT 1
83476: PUSH
83477: EMPTY
83478: LIST
83479: LIST
83480: PUSH
83481: LD_INT 3
83483: PUSH
83484: LD_INT 2
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 2
83493: PUSH
83494: LD_INT 3
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 1
83503: PUSH
83504: LD_INT 3
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: LIST
83515: LIST
83516: LIST
83517: LIST
83518: LIST
83519: LIST
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83536: LD_ADDR_VAR 0 26
83540: PUSH
83541: LD_INT 0
83543: PUSH
83544: LD_INT 0
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 0
83553: PUSH
83554: LD_INT 1
83556: NEG
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: LD_INT 1
83564: PUSH
83565: LD_INT 0
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 1
83574: PUSH
83575: LD_INT 1
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 0
83584: PUSH
83585: LD_INT 1
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 1
83594: NEG
83595: PUSH
83596: LD_INT 0
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 1
83605: NEG
83606: PUSH
83607: LD_INT 1
83609: NEG
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 1
83617: NEG
83618: PUSH
83619: LD_INT 2
83621: NEG
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: PUSH
83627: LD_INT 0
83629: PUSH
83630: LD_INT 2
83632: NEG
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 1
83640: PUSH
83641: LD_INT 1
83643: NEG
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 2
83651: PUSH
83652: LD_INT 0
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 2
83661: PUSH
83662: LD_INT 1
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 2
83671: PUSH
83672: LD_INT 2
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_INT 1
83681: PUSH
83682: LD_INT 2
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: PUSH
83689: LD_INT 0
83691: PUSH
83692: LD_INT 2
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 1
83701: NEG
83702: PUSH
83703: LD_INT 1
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: PUSH
83710: LD_INT 2
83712: NEG
83713: PUSH
83714: LD_INT 0
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: PUSH
83721: LD_INT 2
83723: NEG
83724: PUSH
83725: LD_INT 1
83727: NEG
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: PUSH
83733: LD_INT 2
83735: NEG
83736: PUSH
83737: LD_INT 2
83739: NEG
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: LD_INT 2
83747: PUSH
83748: LD_INT 3
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 1
83757: PUSH
83758: LD_INT 3
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 1
83767: NEG
83768: PUSH
83769: LD_INT 2
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 2
83778: NEG
83779: PUSH
83780: LD_INT 1
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83812: LD_ADDR_VAR 0 27
83816: PUSH
83817: LD_INT 0
83819: PUSH
83820: LD_INT 0
83822: PUSH
83823: EMPTY
83824: LIST
83825: LIST
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: LD_INT 1
83832: NEG
83833: PUSH
83834: EMPTY
83835: LIST
83836: LIST
83837: PUSH
83838: LD_INT 1
83840: PUSH
83841: LD_INT 0
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 1
83850: PUSH
83851: LD_INT 1
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: LD_INT 1
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: NEG
83871: PUSH
83872: LD_INT 0
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 1
83881: NEG
83882: PUSH
83883: LD_INT 1
83885: NEG
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 1
83893: NEG
83894: PUSH
83895: LD_INT 2
83897: NEG
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 0
83905: PUSH
83906: LD_INT 2
83908: NEG
83909: PUSH
83910: EMPTY
83911: LIST
83912: LIST
83913: PUSH
83914: LD_INT 1
83916: PUSH
83917: LD_INT 1
83919: NEG
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PUSH
83925: LD_INT 2
83927: PUSH
83928: LD_INT 0
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PUSH
83935: LD_INT 2
83937: PUSH
83938: LD_INT 1
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 2
83947: PUSH
83948: LD_INT 2
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 1
83957: PUSH
83958: LD_INT 2
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 0
83967: PUSH
83968: LD_INT 2
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: LD_INT 1
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 2
83988: NEG
83989: PUSH
83990: LD_INT 0
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 2
83999: NEG
84000: PUSH
84001: LD_INT 1
84003: NEG
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 2
84011: NEG
84012: PUSH
84013: LD_INT 2
84015: NEG
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 1
84023: NEG
84024: PUSH
84025: LD_INT 2
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: PUSH
84032: LD_INT 2
84034: NEG
84035: PUSH
84036: LD_INT 1
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 3
84045: NEG
84046: PUSH
84047: LD_INT 1
84049: NEG
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 3
84057: NEG
84058: PUSH
84059: LD_INT 2
84061: NEG
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: LIST
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84092: LD_ADDR_VAR 0 28
84096: PUSH
84097: LD_INT 0
84099: PUSH
84100: LD_INT 0
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 0
84109: PUSH
84110: LD_INT 1
84112: NEG
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 1
84120: PUSH
84121: LD_INT 0
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: PUSH
84128: LD_INT 1
84130: PUSH
84131: LD_INT 1
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 0
84140: PUSH
84141: LD_INT 1
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: LD_INT 1
84150: NEG
84151: PUSH
84152: LD_INT 0
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: PUSH
84159: LD_INT 1
84161: NEG
84162: PUSH
84163: LD_INT 1
84165: NEG
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 1
84173: NEG
84174: PUSH
84175: LD_INT 2
84177: NEG
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: LD_INT 0
84185: PUSH
84186: LD_INT 2
84188: NEG
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 1
84196: PUSH
84197: LD_INT 1
84199: NEG
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 2
84207: PUSH
84208: LD_INT 0
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 2
84217: PUSH
84218: LD_INT 1
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: LD_INT 2
84227: PUSH
84228: LD_INT 2
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 1
84237: PUSH
84238: LD_INT 2
84240: PUSH
84241: EMPTY
84242: LIST
84243: LIST
84244: PUSH
84245: LD_INT 0
84247: PUSH
84248: LD_INT 2
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 1
84257: NEG
84258: PUSH
84259: LD_INT 1
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 2
84268: NEG
84269: PUSH
84270: LD_INT 0
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: LD_INT 2
84279: NEG
84280: PUSH
84281: LD_INT 1
84283: NEG
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_INT 2
84291: NEG
84292: PUSH
84293: LD_INT 2
84295: NEG
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: LD_INT 2
84303: NEG
84304: PUSH
84305: LD_INT 3
84307: NEG
84308: PUSH
84309: EMPTY
84310: LIST
84311: LIST
84312: PUSH
84313: LD_INT 1
84315: NEG
84316: PUSH
84317: LD_INT 3
84319: NEG
84320: PUSH
84321: EMPTY
84322: LIST
84323: LIST
84324: PUSH
84325: LD_INT 3
84327: NEG
84328: PUSH
84329: LD_INT 1
84331: NEG
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 3
84339: NEG
84340: PUSH
84341: LD_INT 2
84343: NEG
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: EMPTY
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: LIST
84356: LIST
84357: LIST
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84374: LD_ADDR_VAR 0 29
84378: PUSH
84379: LD_INT 0
84381: PUSH
84382: LD_INT 0
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PUSH
84389: LD_INT 0
84391: PUSH
84392: LD_INT 1
84394: NEG
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: PUSH
84400: LD_INT 1
84402: PUSH
84403: LD_INT 0
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: PUSH
84410: LD_INT 1
84412: PUSH
84413: LD_INT 1
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PUSH
84420: LD_INT 0
84422: PUSH
84423: LD_INT 1
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 1
84432: NEG
84433: PUSH
84434: LD_INT 0
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PUSH
84441: LD_INT 1
84443: NEG
84444: PUSH
84445: LD_INT 1
84447: NEG
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 1
84455: NEG
84456: PUSH
84457: LD_INT 2
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 0
84467: PUSH
84468: LD_INT 2
84470: NEG
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 1
84478: PUSH
84479: LD_INT 1
84481: NEG
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 2
84489: PUSH
84490: LD_INT 0
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: LD_INT 2
84499: PUSH
84500: LD_INT 1
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: PUSH
84507: LD_INT 1
84509: PUSH
84510: LD_INT 2
84512: PUSH
84513: EMPTY
84514: LIST
84515: LIST
84516: PUSH
84517: LD_INT 0
84519: PUSH
84520: LD_INT 2
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 1
84529: NEG
84530: PUSH
84531: LD_INT 1
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 2
84540: NEG
84541: PUSH
84542: LD_INT 1
84544: NEG
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 2
84552: NEG
84553: PUSH
84554: LD_INT 2
84556: NEG
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 2
84564: NEG
84565: PUSH
84566: LD_INT 3
84568: NEG
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: PUSH
84574: LD_INT 2
84576: PUSH
84577: LD_INT 1
84579: NEG
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: LD_INT 3
84587: PUSH
84588: LD_INT 1
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 1
84597: PUSH
84598: LD_INT 3
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: LD_INT 1
84607: NEG
84608: PUSH
84609: LD_INT 2
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 3
84618: NEG
84619: PUSH
84620: LD_INT 2
84622: NEG
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: EMPTY
84629: LIST
84630: LIST
84631: LIST
84632: LIST
84633: LIST
84634: LIST
84635: LIST
84636: LIST
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84653: LD_ADDR_VAR 0 30
84657: PUSH
84658: LD_INT 0
84660: PUSH
84661: LD_INT 0
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: PUSH
84668: LD_INT 0
84670: PUSH
84671: LD_INT 1
84673: NEG
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 1
84681: PUSH
84682: LD_INT 0
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 1
84691: PUSH
84692: LD_INT 1
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 0
84701: PUSH
84702: LD_INT 1
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: LD_INT 1
84711: NEG
84712: PUSH
84713: LD_INT 0
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 1
84722: NEG
84723: PUSH
84724: LD_INT 1
84726: NEG
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 1
84734: NEG
84735: PUSH
84736: LD_INT 2
84738: NEG
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 0
84746: PUSH
84747: LD_INT 2
84749: NEG
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 1
84757: PUSH
84758: LD_INT 1
84760: NEG
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: PUSH
84766: LD_INT 2
84768: PUSH
84769: LD_INT 0
84771: PUSH
84772: EMPTY
84773: LIST
84774: LIST
84775: PUSH
84776: LD_INT 2
84778: PUSH
84779: LD_INT 1
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: PUSH
84786: LD_INT 2
84788: PUSH
84789: LD_INT 2
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 1
84798: PUSH
84799: LD_INT 2
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 1
84808: NEG
84809: PUSH
84810: LD_INT 1
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: PUSH
84817: LD_INT 2
84819: NEG
84820: PUSH
84821: LD_INT 0
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 2
84830: NEG
84831: PUSH
84832: LD_INT 1
84834: NEG
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: LD_INT 3
84846: NEG
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: PUSH
84852: LD_INT 1
84854: PUSH
84855: LD_INT 2
84857: NEG
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 3
84865: PUSH
84866: LD_INT 2
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 2
84875: PUSH
84876: LD_INT 3
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 2
84885: NEG
84886: PUSH
84887: LD_INT 1
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 3
84896: NEG
84897: PUSH
84898: LD_INT 1
84900: NEG
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: LIST
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84931: LD_ADDR_VAR 0 31
84935: PUSH
84936: LD_INT 0
84938: PUSH
84939: LD_INT 0
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 0
84948: PUSH
84949: LD_INT 1
84951: NEG
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 1
84959: PUSH
84960: LD_INT 0
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 1
84969: PUSH
84970: LD_INT 1
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 0
84979: PUSH
84980: LD_INT 1
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 1
84989: NEG
84990: PUSH
84991: LD_INT 0
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 1
85000: NEG
85001: PUSH
85002: LD_INT 1
85004: NEG
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: LD_INT 2
85016: NEG
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 1
85024: PUSH
85025: LD_INT 1
85027: NEG
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 2
85035: PUSH
85036: LD_INT 0
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: PUSH
85043: LD_INT 2
85045: PUSH
85046: LD_INT 1
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 2
85055: PUSH
85056: LD_INT 2
85058: PUSH
85059: EMPTY
85060: LIST
85061: LIST
85062: PUSH
85063: LD_INT 1
85065: PUSH
85066: LD_INT 2
85068: PUSH
85069: EMPTY
85070: LIST
85071: LIST
85072: PUSH
85073: LD_INT 0
85075: PUSH
85076: LD_INT 2
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: LD_INT 1
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 2
85096: NEG
85097: PUSH
85098: LD_INT 1
85100: NEG
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 2
85108: NEG
85109: PUSH
85110: LD_INT 2
85112: NEG
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: PUSH
85118: LD_INT 2
85120: NEG
85121: PUSH
85122: LD_INT 3
85124: NEG
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 2
85132: PUSH
85133: LD_INT 1
85135: NEG
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 3
85143: PUSH
85144: LD_INT 1
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 1
85153: PUSH
85154: LD_INT 3
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 1
85163: NEG
85164: PUSH
85165: LD_INT 2
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: LD_INT 3
85174: NEG
85175: PUSH
85176: LD_INT 2
85178: NEG
85179: PUSH
85180: EMPTY
85181: LIST
85182: LIST
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85209: LD_ADDR_VAR 0 32
85213: PUSH
85214: LD_INT 0
85216: PUSH
85217: LD_INT 0
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 0
85226: PUSH
85227: LD_INT 1
85229: NEG
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 1
85237: PUSH
85238: LD_INT 0
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: PUSH
85245: LD_INT 1
85247: PUSH
85248: LD_INT 1
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 0
85257: PUSH
85258: LD_INT 1
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 1
85267: NEG
85268: PUSH
85269: LD_INT 0
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: LD_INT 1
85282: NEG
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 1
85290: NEG
85291: PUSH
85292: LD_INT 2
85294: NEG
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 0
85302: PUSH
85303: LD_INT 2
85305: NEG
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 1
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 2
85324: PUSH
85325: LD_INT 1
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: PUSH
85332: LD_INT 2
85334: PUSH
85335: LD_INT 2
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 1
85344: PUSH
85345: LD_INT 2
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: PUSH
85352: LD_INT 0
85354: PUSH
85355: LD_INT 2
85357: PUSH
85358: EMPTY
85359: LIST
85360: LIST
85361: PUSH
85362: LD_INT 1
85364: NEG
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 2
85375: NEG
85376: PUSH
85377: LD_INT 0
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PUSH
85384: LD_INT 2
85386: NEG
85387: PUSH
85388: LD_INT 1
85390: NEG
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: LD_INT 3
85402: NEG
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 1
85410: PUSH
85411: LD_INT 2
85413: NEG
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 3
85421: PUSH
85422: LD_INT 2
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 2
85431: PUSH
85432: LD_INT 3
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 2
85441: NEG
85442: PUSH
85443: LD_INT 1
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 3
85452: NEG
85453: PUSH
85454: LD_INT 1
85456: NEG
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85487: LD_ADDR_VAR 0 33
85491: PUSH
85492: LD_INT 0
85494: PUSH
85495: LD_INT 0
85497: PUSH
85498: EMPTY
85499: LIST
85500: LIST
85501: PUSH
85502: LD_INT 0
85504: PUSH
85505: LD_INT 1
85507: NEG
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: PUSH
85513: LD_INT 1
85515: PUSH
85516: LD_INT 0
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 1
85525: PUSH
85526: LD_INT 1
85528: PUSH
85529: EMPTY
85530: LIST
85531: LIST
85532: PUSH
85533: LD_INT 0
85535: PUSH
85536: LD_INT 1
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PUSH
85543: LD_INT 1
85545: NEG
85546: PUSH
85547: LD_INT 0
85549: PUSH
85550: EMPTY
85551: LIST
85552: LIST
85553: PUSH
85554: LD_INT 1
85556: NEG
85557: PUSH
85558: LD_INT 1
85560: NEG
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 1
85568: NEG
85569: PUSH
85570: LD_INT 2
85572: NEG
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 1
85580: PUSH
85581: LD_INT 1
85583: NEG
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PUSH
85589: LD_INT 2
85591: PUSH
85592: LD_INT 0
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 2
85601: PUSH
85602: LD_INT 1
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 1
85611: PUSH
85612: LD_INT 2
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 0
85621: PUSH
85622: LD_INT 2
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: NEG
85632: PUSH
85633: LD_INT 1
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 2
85642: NEG
85643: PUSH
85644: LD_INT 0
85646: PUSH
85647: EMPTY
85648: LIST
85649: LIST
85650: PUSH
85651: LD_INT 2
85653: NEG
85654: PUSH
85655: LD_INT 1
85657: NEG
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: PUSH
85663: LD_INT 2
85665: NEG
85666: PUSH
85667: LD_INT 2
85669: NEG
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: PUSH
85675: LD_INT 2
85677: NEG
85678: PUSH
85679: LD_INT 3
85681: NEG
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 2
85689: PUSH
85690: LD_INT 1
85692: NEG
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 3
85700: PUSH
85701: LD_INT 1
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 1
85710: PUSH
85711: LD_INT 3
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 1
85720: NEG
85721: PUSH
85722: LD_INT 2
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 3
85731: NEG
85732: PUSH
85733: LD_INT 2
85735: NEG
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: PUSH
85741: EMPTY
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85766: LD_ADDR_VAR 0 34
85770: PUSH
85771: LD_INT 0
85773: PUSH
85774: LD_INT 0
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 0
85783: PUSH
85784: LD_INT 1
85786: NEG
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 1
85794: PUSH
85795: LD_INT 0
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 1
85804: PUSH
85805: LD_INT 1
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 0
85814: PUSH
85815: LD_INT 1
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 1
85824: NEG
85825: PUSH
85826: LD_INT 0
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 1
85835: NEG
85836: PUSH
85837: LD_INT 1
85839: NEG
85840: PUSH
85841: EMPTY
85842: LIST
85843: LIST
85844: PUSH
85845: LD_INT 1
85847: NEG
85848: PUSH
85849: LD_INT 2
85851: NEG
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 0
85859: PUSH
85860: LD_INT 2
85862: NEG
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_INT 1
85870: PUSH
85871: LD_INT 1
85873: NEG
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 2
85881: PUSH
85882: LD_INT 1
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 2
85891: PUSH
85892: LD_INT 2
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 1
85901: PUSH
85902: LD_INT 2
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 1
85911: NEG
85912: PUSH
85913: LD_INT 1
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 2
85922: NEG
85923: PUSH
85924: LD_INT 0
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 2
85933: NEG
85934: PUSH
85935: LD_INT 1
85937: NEG
85938: PUSH
85939: EMPTY
85940: LIST
85941: LIST
85942: PUSH
85943: LD_INT 2
85945: NEG
85946: PUSH
85947: LD_INT 2
85949: NEG
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PUSH
85955: LD_INT 1
85957: NEG
85958: PUSH
85959: LD_INT 3
85961: NEG
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: LD_INT 1
85969: PUSH
85970: LD_INT 2
85972: NEG
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 3
85980: PUSH
85981: LD_INT 2
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 2
85990: PUSH
85991: LD_INT 3
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 2
86000: NEG
86001: PUSH
86002: LD_INT 1
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 3
86011: NEG
86012: PUSH
86013: LD_INT 1
86015: NEG
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86046: LD_ADDR_VAR 0 35
86050: PUSH
86051: LD_INT 0
86053: PUSH
86054: LD_INT 0
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 0
86063: PUSH
86064: LD_INT 1
86066: NEG
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: PUSH
86072: LD_INT 1
86074: PUSH
86075: LD_INT 0
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: PUSH
86082: LD_INT 1
86084: PUSH
86085: LD_INT 1
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 0
86094: PUSH
86095: LD_INT 1
86097: PUSH
86098: EMPTY
86099: LIST
86100: LIST
86101: PUSH
86102: LD_INT 1
86104: NEG
86105: PUSH
86106: LD_INT 0
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: NEG
86116: PUSH
86117: LD_INT 1
86119: NEG
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: PUSH
86125: LD_INT 2
86127: PUSH
86128: LD_INT 1
86130: PUSH
86131: EMPTY
86132: LIST
86133: LIST
86134: PUSH
86135: LD_INT 2
86137: NEG
86138: PUSH
86139: LD_INT 1
86141: NEG
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86158: LD_ADDR_VAR 0 36
86162: PUSH
86163: LD_INT 0
86165: PUSH
86166: LD_INT 0
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: PUSH
86173: LD_INT 0
86175: PUSH
86176: LD_INT 1
86178: NEG
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PUSH
86184: LD_INT 1
86186: PUSH
86187: LD_INT 0
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 1
86196: PUSH
86197: LD_INT 1
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: LD_INT 1
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 1
86216: NEG
86217: PUSH
86218: LD_INT 0
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PUSH
86225: LD_INT 1
86227: NEG
86228: PUSH
86229: LD_INT 1
86231: NEG
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: PUSH
86237: LD_INT 1
86239: NEG
86240: PUSH
86241: LD_INT 2
86243: NEG
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 1
86251: PUSH
86252: LD_INT 2
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86270: LD_ADDR_VAR 0 37
86274: PUSH
86275: LD_INT 0
86277: PUSH
86278: LD_INT 0
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 0
86287: PUSH
86288: LD_INT 1
86290: NEG
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 1
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 1
86308: PUSH
86309: LD_INT 1
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 0
86318: PUSH
86319: LD_INT 1
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 1
86328: NEG
86329: PUSH
86330: LD_INT 0
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 1
86339: NEG
86340: PUSH
86341: LD_INT 1
86343: NEG
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 1
86351: PUSH
86352: LD_INT 1
86354: NEG
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 1
86362: NEG
86363: PUSH
86364: LD_INT 1
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: LIST
86377: LIST
86378: LIST
86379: LIST
86380: LIST
86381: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86382: LD_ADDR_VAR 0 38
86386: PUSH
86387: LD_INT 0
86389: PUSH
86390: LD_INT 0
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 0
86399: PUSH
86400: LD_INT 1
86402: NEG
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: PUSH
86408: LD_INT 1
86410: PUSH
86411: LD_INT 0
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: LD_INT 1
86420: PUSH
86421: LD_INT 1
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 0
86430: PUSH
86431: LD_INT 1
86433: PUSH
86434: EMPTY
86435: LIST
86436: LIST
86437: PUSH
86438: LD_INT 1
86440: NEG
86441: PUSH
86442: LD_INT 0
86444: PUSH
86445: EMPTY
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 1
86451: NEG
86452: PUSH
86453: LD_INT 1
86455: NEG
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: LD_INT 2
86463: PUSH
86464: LD_INT 1
86466: PUSH
86467: EMPTY
86468: LIST
86469: LIST
86470: PUSH
86471: LD_INT 2
86473: NEG
86474: PUSH
86475: LD_INT 1
86477: NEG
86478: PUSH
86479: EMPTY
86480: LIST
86481: LIST
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: LIST
86490: LIST
86491: LIST
86492: LIST
86493: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86494: LD_ADDR_VAR 0 39
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: LD_INT 0
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 0
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 1
86522: PUSH
86523: LD_INT 0
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: PUSH
86533: LD_INT 1
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: LD_INT 1
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: LD_INT 0
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 1
86563: NEG
86564: PUSH
86565: LD_INT 1
86567: NEG
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 1
86575: NEG
86576: PUSH
86577: LD_INT 2
86579: NEG
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: LD_INT 1
86587: PUSH
86588: LD_INT 2
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86606: LD_ADDR_VAR 0 40
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: LD_INT 0
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 0
86623: PUSH
86624: LD_INT 1
86626: NEG
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: LD_INT 1
86634: PUSH
86635: LD_INT 0
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: LD_INT 1
86644: PUSH
86645: LD_INT 1
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 0
86654: PUSH
86655: LD_INT 1
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 1
86664: NEG
86665: PUSH
86666: LD_INT 0
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: PUSH
86673: LD_INT 1
86675: NEG
86676: PUSH
86677: LD_INT 1
86679: NEG
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 1
86687: PUSH
86688: LD_INT 1
86690: NEG
86691: PUSH
86692: EMPTY
86693: LIST
86694: LIST
86695: PUSH
86696: LD_INT 1
86698: NEG
86699: PUSH
86700: LD_INT 1
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86718: LD_ADDR_VAR 0 41
86722: PUSH
86723: LD_INT 0
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 0
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 1
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 1
86756: PUSH
86757: LD_INT 1
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: LD_INT 1
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: LD_INT 0
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 1
86787: NEG
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 1
86799: NEG
86800: PUSH
86801: LD_INT 2
86803: NEG
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 1
86811: PUSH
86812: LD_INT 1
86814: NEG
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PUSH
86820: LD_INT 2
86822: PUSH
86823: LD_INT 0
86825: PUSH
86826: EMPTY
86827: LIST
86828: LIST
86829: PUSH
86830: LD_INT 2
86832: PUSH
86833: LD_INT 1
86835: PUSH
86836: EMPTY
86837: LIST
86838: LIST
86839: PUSH
86840: LD_INT 2
86842: PUSH
86843: LD_INT 2
86845: PUSH
86846: EMPTY
86847: LIST
86848: LIST
86849: PUSH
86850: LD_INT 1
86852: PUSH
86853: LD_INT 2
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: PUSH
86860: LD_INT 1
86862: NEG
86863: PUSH
86864: LD_INT 1
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: LD_INT 2
86873: NEG
86874: PUSH
86875: LD_INT 0
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 2
86884: NEG
86885: PUSH
86886: LD_INT 1
86888: NEG
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: LD_INT 2
86896: NEG
86897: PUSH
86898: LD_INT 2
86900: NEG
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 2
86908: NEG
86909: PUSH
86910: LD_INT 3
86912: NEG
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 2
86920: PUSH
86921: LD_INT 1
86923: NEG
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 3
86931: PUSH
86932: LD_INT 0
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 3
86941: PUSH
86942: LD_INT 1
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 3
86951: PUSH
86952: LD_INT 2
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 3
86961: PUSH
86962: LD_INT 3
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 2
86971: PUSH
86972: LD_INT 3
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 2
86981: NEG
86982: PUSH
86983: LD_INT 1
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 3
86992: NEG
86993: PUSH
86994: LD_INT 0
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 3
87003: NEG
87004: PUSH
87005: LD_INT 1
87007: NEG
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 3
87015: NEG
87016: PUSH
87017: LD_INT 2
87019: NEG
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 3
87027: NEG
87028: PUSH
87029: LD_INT 3
87031: NEG
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87068: LD_ADDR_VAR 0 42
87072: PUSH
87073: LD_INT 0
87075: PUSH
87076: LD_INT 0
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 0
87085: PUSH
87086: LD_INT 1
87088: NEG
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: PUSH
87094: LD_INT 1
87096: PUSH
87097: LD_INT 0
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 1
87106: PUSH
87107: LD_INT 1
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: LD_INT 1
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 1
87126: NEG
87127: PUSH
87128: LD_INT 0
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 1
87137: NEG
87138: PUSH
87139: LD_INT 1
87141: NEG
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 1
87149: NEG
87150: PUSH
87151: LD_INT 2
87153: NEG
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 0
87161: PUSH
87162: LD_INT 2
87164: NEG
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 1
87172: PUSH
87173: LD_INT 1
87175: NEG
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 2
87183: PUSH
87184: LD_INT 1
87186: PUSH
87187: EMPTY
87188: LIST
87189: LIST
87190: PUSH
87191: LD_INT 2
87193: PUSH
87194: LD_INT 2
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 1
87203: PUSH
87204: LD_INT 2
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: LD_INT 2
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 1
87223: NEG
87224: PUSH
87225: LD_INT 1
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 2
87234: NEG
87235: PUSH
87236: LD_INT 1
87238: NEG
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: LD_INT 2
87246: NEG
87247: PUSH
87248: LD_INT 2
87250: NEG
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: PUSH
87256: LD_INT 2
87258: NEG
87259: PUSH
87260: LD_INT 3
87262: NEG
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: PUSH
87268: LD_INT 1
87270: NEG
87271: PUSH
87272: LD_INT 3
87274: NEG
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 0
87282: PUSH
87283: LD_INT 3
87285: NEG
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 1
87293: PUSH
87294: LD_INT 2
87296: NEG
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: LD_INT 3
87304: PUSH
87305: LD_INT 2
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: PUSH
87312: LD_INT 3
87314: PUSH
87315: LD_INT 3
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: LD_INT 2
87324: PUSH
87325: LD_INT 3
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 1
87334: PUSH
87335: LD_INT 3
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 0
87344: PUSH
87345: LD_INT 3
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 1
87354: NEG
87355: PUSH
87356: LD_INT 2
87358: PUSH
87359: EMPTY
87360: LIST
87361: LIST
87362: PUSH
87363: LD_INT 3
87365: NEG
87366: PUSH
87367: LD_INT 2
87369: NEG
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: PUSH
87375: LD_INT 3
87377: NEG
87378: PUSH
87379: LD_INT 3
87381: NEG
87382: PUSH
87383: EMPTY
87384: LIST
87385: LIST
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87418: LD_ADDR_VAR 0 43
87422: PUSH
87423: LD_INT 0
87425: PUSH
87426: LD_INT 0
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 0
87435: PUSH
87436: LD_INT 1
87438: NEG
87439: PUSH
87440: EMPTY
87441: LIST
87442: LIST
87443: PUSH
87444: LD_INT 1
87446: PUSH
87447: LD_INT 0
87449: PUSH
87450: EMPTY
87451: LIST
87452: LIST
87453: PUSH
87454: LD_INT 1
87456: PUSH
87457: LD_INT 1
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: PUSH
87464: LD_INT 0
87466: PUSH
87467: LD_INT 1
87469: PUSH
87470: EMPTY
87471: LIST
87472: LIST
87473: PUSH
87474: LD_INT 1
87476: NEG
87477: PUSH
87478: LD_INT 0
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 1
87487: NEG
87488: PUSH
87489: LD_INT 1
87491: NEG
87492: PUSH
87493: EMPTY
87494: LIST
87495: LIST
87496: PUSH
87497: LD_INT 1
87499: NEG
87500: PUSH
87501: LD_INT 2
87503: NEG
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: PUSH
87509: LD_INT 0
87511: PUSH
87512: LD_INT 2
87514: NEG
87515: PUSH
87516: EMPTY
87517: LIST
87518: LIST
87519: PUSH
87520: LD_INT 1
87522: PUSH
87523: LD_INT 1
87525: NEG
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 2
87533: PUSH
87534: LD_INT 0
87536: PUSH
87537: EMPTY
87538: LIST
87539: LIST
87540: PUSH
87541: LD_INT 2
87543: PUSH
87544: LD_INT 1
87546: PUSH
87547: EMPTY
87548: LIST
87549: LIST
87550: PUSH
87551: LD_INT 1
87553: PUSH
87554: LD_INT 2
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 0
87563: PUSH
87564: LD_INT 2
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: PUSH
87571: LD_INT 1
87573: NEG
87574: PUSH
87575: LD_INT 1
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 2
87584: NEG
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 2
87595: NEG
87596: PUSH
87597: LD_INT 1
87599: NEG
87600: PUSH
87601: EMPTY
87602: LIST
87603: LIST
87604: PUSH
87605: LD_INT 1
87607: NEG
87608: PUSH
87609: LD_INT 3
87611: NEG
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 0
87619: PUSH
87620: LD_INT 3
87622: NEG
87623: PUSH
87624: EMPTY
87625: LIST
87626: LIST
87627: PUSH
87628: LD_INT 1
87630: PUSH
87631: LD_INT 2
87633: NEG
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 2
87641: PUSH
87642: LD_INT 1
87644: NEG
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 3
87652: PUSH
87653: LD_INT 0
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PUSH
87660: LD_INT 3
87662: PUSH
87663: LD_INT 1
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 1
87672: PUSH
87673: LD_INT 3
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 0
87682: PUSH
87683: LD_INT 3
87685: PUSH
87686: EMPTY
87687: LIST
87688: LIST
87689: PUSH
87690: LD_INT 1
87692: NEG
87693: PUSH
87694: LD_INT 2
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 2
87703: NEG
87704: PUSH
87705: LD_INT 1
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: LD_INT 3
87714: NEG
87715: PUSH
87716: LD_INT 0
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: LD_INT 3
87725: NEG
87726: PUSH
87727: LD_INT 1
87729: NEG
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87766: LD_ADDR_VAR 0 44
87770: PUSH
87771: LD_INT 0
87773: PUSH
87774: LD_INT 0
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 0
87783: PUSH
87784: LD_INT 1
87786: NEG
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PUSH
87792: LD_INT 1
87794: PUSH
87795: LD_INT 0
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 1
87804: PUSH
87805: LD_INT 1
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 0
87814: PUSH
87815: LD_INT 1
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: NEG
87825: PUSH
87826: LD_INT 0
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: LD_INT 1
87835: NEG
87836: PUSH
87837: LD_INT 1
87839: NEG
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 1
87847: NEG
87848: PUSH
87849: LD_INT 2
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 1
87859: PUSH
87860: LD_INT 1
87862: NEG
87863: PUSH
87864: EMPTY
87865: LIST
87866: LIST
87867: PUSH
87868: LD_INT 2
87870: PUSH
87871: LD_INT 0
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: LD_INT 2
87880: PUSH
87881: LD_INT 1
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 2
87890: PUSH
87891: LD_INT 2
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 1
87900: PUSH
87901: LD_INT 2
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: LD_INT 1
87910: NEG
87911: PUSH
87912: LD_INT 1
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 2
87921: NEG
87922: PUSH
87923: LD_INT 0
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 2
87932: NEG
87933: PUSH
87934: LD_INT 1
87936: NEG
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 2
87944: NEG
87945: PUSH
87946: LD_INT 2
87948: NEG
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 2
87956: NEG
87957: PUSH
87958: LD_INT 3
87960: NEG
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 2
87968: PUSH
87969: LD_INT 1
87971: NEG
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 3
87979: PUSH
87980: LD_INT 0
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: LD_INT 3
87989: PUSH
87990: LD_INT 1
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: PUSH
87997: LD_INT 3
87999: PUSH
88000: LD_INT 2
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: PUSH
88007: LD_INT 3
88009: PUSH
88010: LD_INT 3
88012: PUSH
88013: EMPTY
88014: LIST
88015: LIST
88016: PUSH
88017: LD_INT 2
88019: PUSH
88020: LD_INT 3
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 2
88029: NEG
88030: PUSH
88031: LD_INT 1
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: PUSH
88038: LD_INT 3
88040: NEG
88041: PUSH
88042: LD_INT 0
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 3
88051: NEG
88052: PUSH
88053: LD_INT 1
88055: NEG
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 3
88063: NEG
88064: PUSH
88065: LD_INT 2
88067: NEG
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 3
88075: NEG
88076: PUSH
88077: LD_INT 3
88079: NEG
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88116: LD_ADDR_VAR 0 45
88120: PUSH
88121: LD_INT 0
88123: PUSH
88124: LD_INT 0
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: PUSH
88131: LD_INT 0
88133: PUSH
88134: LD_INT 1
88136: NEG
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: PUSH
88142: LD_INT 1
88144: PUSH
88145: LD_INT 0
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 1
88154: PUSH
88155: LD_INT 1
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 0
88164: PUSH
88165: LD_INT 1
88167: PUSH
88168: EMPTY
88169: LIST
88170: LIST
88171: PUSH
88172: LD_INT 1
88174: NEG
88175: PUSH
88176: LD_INT 0
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: LD_INT 1
88189: NEG
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: LD_INT 2
88201: NEG
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: PUSH
88207: LD_INT 0
88209: PUSH
88210: LD_INT 2
88212: NEG
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 1
88220: PUSH
88221: LD_INT 1
88223: NEG
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 2
88231: PUSH
88232: LD_INT 1
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 2
88241: PUSH
88242: LD_INT 2
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 1
88251: PUSH
88252: LD_INT 2
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 0
88261: PUSH
88262: LD_INT 2
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 1
88271: NEG
88272: PUSH
88273: LD_INT 1
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 2
88282: NEG
88283: PUSH
88284: LD_INT 1
88286: NEG
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 2
88294: NEG
88295: PUSH
88296: LD_INT 2
88298: NEG
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: LD_INT 2
88306: NEG
88307: PUSH
88308: LD_INT 3
88310: NEG
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: LD_INT 1
88318: NEG
88319: PUSH
88320: LD_INT 3
88322: NEG
88323: PUSH
88324: EMPTY
88325: LIST
88326: LIST
88327: PUSH
88328: LD_INT 0
88330: PUSH
88331: LD_INT 3
88333: NEG
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: LD_INT 1
88341: PUSH
88342: LD_INT 2
88344: NEG
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 3
88352: PUSH
88353: LD_INT 2
88355: PUSH
88356: EMPTY
88357: LIST
88358: LIST
88359: PUSH
88360: LD_INT 3
88362: PUSH
88363: LD_INT 3
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 2
88372: PUSH
88373: LD_INT 3
88375: PUSH
88376: EMPTY
88377: LIST
88378: LIST
88379: PUSH
88380: LD_INT 1
88382: PUSH
88383: LD_INT 3
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 0
88392: PUSH
88393: LD_INT 3
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: PUSH
88400: LD_INT 1
88402: NEG
88403: PUSH
88404: LD_INT 2
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 3
88413: NEG
88414: PUSH
88415: LD_INT 2
88417: NEG
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 3
88425: NEG
88426: PUSH
88427: LD_INT 3
88429: NEG
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88466: LD_ADDR_VAR 0 46
88470: PUSH
88471: LD_INT 0
88473: PUSH
88474: LD_INT 0
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 0
88483: PUSH
88484: LD_INT 1
88486: NEG
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 1
88494: PUSH
88495: LD_INT 0
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 1
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: LD_INT 1
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 1
88524: NEG
88525: PUSH
88526: LD_INT 0
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 1
88535: NEG
88536: PUSH
88537: LD_INT 1
88539: NEG
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 1
88547: NEG
88548: PUSH
88549: LD_INT 2
88551: NEG
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: LD_INT 0
88559: PUSH
88560: LD_INT 2
88562: NEG
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 1
88570: PUSH
88571: LD_INT 1
88573: NEG
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: LD_INT 2
88581: PUSH
88582: LD_INT 0
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: LD_INT 2
88591: PUSH
88592: LD_INT 1
88594: PUSH
88595: EMPTY
88596: LIST
88597: LIST
88598: PUSH
88599: LD_INT 1
88601: PUSH
88602: LD_INT 2
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: LD_INT 0
88611: PUSH
88612: LD_INT 2
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 1
88621: NEG
88622: PUSH
88623: LD_INT 1
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 2
88632: NEG
88633: PUSH
88634: LD_INT 0
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 2
88643: NEG
88644: PUSH
88645: LD_INT 1
88647: NEG
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: PUSH
88653: LD_INT 1
88655: NEG
88656: PUSH
88657: LD_INT 3
88659: NEG
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PUSH
88665: LD_INT 0
88667: PUSH
88668: LD_INT 3
88670: NEG
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 1
88678: PUSH
88679: LD_INT 2
88681: NEG
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 2
88689: PUSH
88690: LD_INT 1
88692: NEG
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 3
88700: PUSH
88701: LD_INT 0
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 3
88710: PUSH
88711: LD_INT 1
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 1
88720: PUSH
88721: LD_INT 3
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 0
88730: PUSH
88731: LD_INT 3
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 1
88740: NEG
88741: PUSH
88742: LD_INT 2
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: PUSH
88749: LD_INT 2
88751: NEG
88752: PUSH
88753: LD_INT 1
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 3
88762: NEG
88763: PUSH
88764: LD_INT 0
88766: PUSH
88767: EMPTY
88768: LIST
88769: LIST
88770: PUSH
88771: LD_INT 3
88773: NEG
88774: PUSH
88775: LD_INT 1
88777: NEG
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88814: LD_ADDR_VAR 0 47
88818: PUSH
88819: LD_INT 0
88821: PUSH
88822: LD_INT 0
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 0
88831: PUSH
88832: LD_INT 1
88834: NEG
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 1
88842: PUSH
88843: LD_INT 0
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: LD_INT 1
88852: PUSH
88853: LD_INT 1
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: LD_INT 1
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 1
88872: NEG
88873: PUSH
88874: LD_INT 0
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 1
88883: NEG
88884: PUSH
88885: LD_INT 1
88887: NEG
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 1
88895: NEG
88896: PUSH
88897: LD_INT 2
88899: NEG
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: LD_INT 0
88907: PUSH
88908: LD_INT 2
88910: NEG
88911: PUSH
88912: EMPTY
88913: LIST
88914: LIST
88915: PUSH
88916: LD_INT 1
88918: PUSH
88919: LD_INT 1
88921: NEG
88922: PUSH
88923: EMPTY
88924: LIST
88925: LIST
88926: PUSH
88927: LD_INT 2
88929: NEG
88930: PUSH
88931: LD_INT 1
88933: NEG
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: PUSH
88939: LD_INT 2
88941: NEG
88942: PUSH
88943: LD_INT 2
88945: NEG
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88965: LD_ADDR_VAR 0 48
88969: PUSH
88970: LD_INT 0
88972: PUSH
88973: LD_INT 0
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PUSH
88980: LD_INT 0
88982: PUSH
88983: LD_INT 1
88985: NEG
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: PUSH
88991: LD_INT 1
88993: PUSH
88994: LD_INT 0
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: PUSH
89001: LD_INT 1
89003: PUSH
89004: LD_INT 1
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 0
89013: PUSH
89014: LD_INT 1
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: LD_INT 1
89023: NEG
89024: PUSH
89025: LD_INT 0
89027: PUSH
89028: EMPTY
89029: LIST
89030: LIST
89031: PUSH
89032: LD_INT 1
89034: NEG
89035: PUSH
89036: LD_INT 1
89038: NEG
89039: PUSH
89040: EMPTY
89041: LIST
89042: LIST
89043: PUSH
89044: LD_INT 1
89046: NEG
89047: PUSH
89048: LD_INT 2
89050: NEG
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: LD_INT 0
89058: PUSH
89059: LD_INT 2
89061: NEG
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: LD_INT 1
89069: PUSH
89070: LD_INT 1
89072: NEG
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 2
89080: PUSH
89081: LD_INT 0
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 2
89090: PUSH
89091: LD_INT 1
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89112: LD_ADDR_VAR 0 49
89116: PUSH
89117: LD_INT 0
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: PUSH
89127: LD_INT 0
89129: PUSH
89130: LD_INT 1
89132: NEG
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: LD_INT 1
89140: PUSH
89141: LD_INT 0
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: LD_INT 1
89150: PUSH
89151: LD_INT 1
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PUSH
89158: LD_INT 0
89160: PUSH
89161: LD_INT 1
89163: PUSH
89164: EMPTY
89165: LIST
89166: LIST
89167: PUSH
89168: LD_INT 1
89170: NEG
89171: PUSH
89172: LD_INT 0
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 1
89181: NEG
89182: PUSH
89183: LD_INT 1
89185: NEG
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: PUSH
89191: LD_INT 1
89193: PUSH
89194: LD_INT 1
89196: NEG
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 2
89204: PUSH
89205: LD_INT 0
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 2
89214: PUSH
89215: LD_INT 1
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 2
89224: PUSH
89225: LD_INT 2
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 1
89234: PUSH
89235: LD_INT 2
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: EMPTY
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89256: LD_ADDR_VAR 0 50
89260: PUSH
89261: LD_INT 0
89263: PUSH
89264: LD_INT 0
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 0
89273: PUSH
89274: LD_INT 1
89276: NEG
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 1
89284: PUSH
89285: LD_INT 0
89287: PUSH
89288: EMPTY
89289: LIST
89290: LIST
89291: PUSH
89292: LD_INT 1
89294: PUSH
89295: LD_INT 1
89297: PUSH
89298: EMPTY
89299: LIST
89300: LIST
89301: PUSH
89302: LD_INT 0
89304: PUSH
89305: LD_INT 1
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: LD_INT 1
89314: NEG
89315: PUSH
89316: LD_INT 0
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: NEG
89326: PUSH
89327: LD_INT 1
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 2
89337: PUSH
89338: LD_INT 1
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: LD_INT 2
89347: PUSH
89348: LD_INT 2
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: LD_INT 1
89357: PUSH
89358: LD_INT 2
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: LD_INT 0
89367: PUSH
89368: LD_INT 2
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 1
89377: NEG
89378: PUSH
89379: LD_INT 1
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89400: LD_ADDR_VAR 0 51
89404: PUSH
89405: LD_INT 0
89407: PUSH
89408: LD_INT 0
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 0
89417: PUSH
89418: LD_INT 1
89420: NEG
89421: PUSH
89422: EMPTY
89423: LIST
89424: LIST
89425: PUSH
89426: LD_INT 1
89428: PUSH
89429: LD_INT 0
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 1
89438: PUSH
89439: LD_INT 1
89441: PUSH
89442: EMPTY
89443: LIST
89444: LIST
89445: PUSH
89446: LD_INT 0
89448: PUSH
89449: LD_INT 1
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: PUSH
89456: LD_INT 1
89458: NEG
89459: PUSH
89460: LD_INT 0
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: LD_INT 1
89469: NEG
89470: PUSH
89471: LD_INT 1
89473: NEG
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 1
89481: PUSH
89482: LD_INT 2
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 0
89491: PUSH
89492: LD_INT 2
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 1
89501: NEG
89502: PUSH
89503: LD_INT 1
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 2
89512: NEG
89513: PUSH
89514: LD_INT 0
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 2
89523: NEG
89524: PUSH
89525: LD_INT 1
89527: NEG
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89547: LD_ADDR_VAR 0 52
89551: PUSH
89552: LD_INT 0
89554: PUSH
89555: LD_INT 0
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: PUSH
89562: LD_INT 0
89564: PUSH
89565: LD_INT 1
89567: NEG
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PUSH
89573: LD_INT 1
89575: PUSH
89576: LD_INT 0
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: PUSH
89583: LD_INT 1
89585: PUSH
89586: LD_INT 1
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 0
89595: PUSH
89596: LD_INT 1
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 1
89605: NEG
89606: PUSH
89607: LD_INT 0
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: PUSH
89618: LD_INT 1
89620: NEG
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 1
89628: NEG
89629: PUSH
89630: LD_INT 2
89632: NEG
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: PUSH
89638: LD_INT 1
89640: NEG
89641: PUSH
89642: LD_INT 1
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: LD_INT 2
89651: NEG
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: PUSH
89660: LD_INT 2
89662: NEG
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 2
89674: NEG
89675: PUSH
89676: LD_INT 2
89678: NEG
89679: PUSH
89680: EMPTY
89681: LIST
89682: LIST
89683: PUSH
89684: EMPTY
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89698: LD_ADDR_VAR 0 53
89702: PUSH
89703: LD_INT 0
89705: PUSH
89706: LD_INT 0
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: PUSH
89713: LD_INT 0
89715: PUSH
89716: LD_INT 1
89718: NEG
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: LD_INT 1
89726: PUSH
89727: LD_INT 0
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: LD_INT 1
89736: PUSH
89737: LD_INT 1
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: LD_INT 0
89746: PUSH
89747: LD_INT 1
89749: PUSH
89750: EMPTY
89751: LIST
89752: LIST
89753: PUSH
89754: LD_INT 1
89756: NEG
89757: PUSH
89758: LD_INT 0
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 1
89767: NEG
89768: PUSH
89769: LD_INT 1
89771: NEG
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 1
89779: NEG
89780: PUSH
89781: LD_INT 2
89783: NEG
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 0
89791: PUSH
89792: LD_INT 2
89794: NEG
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 1
89802: PUSH
89803: LD_INT 1
89805: NEG
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 2
89813: PUSH
89814: LD_INT 0
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 2
89823: PUSH
89824: LD_INT 1
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 2
89833: PUSH
89834: LD_INT 2
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: PUSH
89841: LD_INT 1
89843: PUSH
89844: LD_INT 2
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: PUSH
89851: LD_INT 0
89853: PUSH
89854: LD_INT 2
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: PUSH
89861: LD_INT 1
89863: NEG
89864: PUSH
89865: LD_INT 1
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 2
89874: NEG
89875: PUSH
89876: LD_INT 0
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 2
89885: NEG
89886: PUSH
89887: LD_INT 1
89889: NEG
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: PUSH
89895: LD_INT 2
89897: NEG
89898: PUSH
89899: LD_INT 2
89901: NEG
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89928: LD_ADDR_VAR 0 54
89932: PUSH
89933: LD_INT 0
89935: PUSH
89936: LD_INT 0
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 0
89945: PUSH
89946: LD_INT 1
89948: NEG
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PUSH
89954: LD_INT 1
89956: PUSH
89957: LD_INT 0
89959: PUSH
89960: EMPTY
89961: LIST
89962: LIST
89963: PUSH
89964: LD_INT 1
89966: PUSH
89967: LD_INT 1
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: LD_INT 1
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: LD_INT 1
89986: NEG
89987: PUSH
89988: LD_INT 0
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: LD_INT 1
89997: NEG
89998: PUSH
89999: LD_INT 1
90001: NEG
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: LD_INT 1
90009: NEG
90010: PUSH
90011: LD_INT 2
90013: NEG
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: PUSH
90019: LD_INT 0
90021: PUSH
90022: LD_INT 2
90024: NEG
90025: PUSH
90026: EMPTY
90027: LIST
90028: LIST
90029: PUSH
90030: LD_INT 1
90032: PUSH
90033: LD_INT 1
90035: NEG
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 2
90043: PUSH
90044: LD_INT 0
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 2
90053: PUSH
90054: LD_INT 1
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: PUSH
90061: LD_INT 2
90063: PUSH
90064: LD_INT 2
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: PUSH
90071: LD_INT 1
90073: PUSH
90074: LD_INT 2
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: PUSH
90081: LD_INT 0
90083: PUSH
90084: LD_INT 2
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 1
90093: NEG
90094: PUSH
90095: LD_INT 1
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PUSH
90102: LD_INT 2
90104: NEG
90105: PUSH
90106: LD_INT 0
90108: PUSH
90109: EMPTY
90110: LIST
90111: LIST
90112: PUSH
90113: LD_INT 2
90115: NEG
90116: PUSH
90117: LD_INT 1
90119: NEG
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PUSH
90125: LD_INT 2
90127: NEG
90128: PUSH
90129: LD_INT 2
90131: NEG
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: LIST
90141: LIST
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90158: LD_ADDR_VAR 0 55
90162: PUSH
90163: LD_INT 0
90165: PUSH
90166: LD_INT 0
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: LD_INT 0
90175: PUSH
90176: LD_INT 1
90178: NEG
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 1
90186: PUSH
90187: LD_INT 0
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 1
90196: PUSH
90197: LD_INT 1
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 0
90206: PUSH
90207: LD_INT 1
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: LD_INT 1
90216: NEG
90217: PUSH
90218: LD_INT 0
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PUSH
90225: LD_INT 1
90227: NEG
90228: PUSH
90229: LD_INT 1
90231: NEG
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: PUSH
90237: LD_INT 1
90239: NEG
90240: PUSH
90241: LD_INT 2
90243: NEG
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: PUSH
90249: LD_INT 0
90251: PUSH
90252: LD_INT 2
90254: NEG
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PUSH
90260: LD_INT 1
90262: PUSH
90263: LD_INT 1
90265: NEG
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: PUSH
90271: LD_INT 2
90273: PUSH
90274: LD_INT 0
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 2
90283: PUSH
90284: LD_INT 1
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PUSH
90291: LD_INT 2
90293: PUSH
90294: LD_INT 2
90296: PUSH
90297: EMPTY
90298: LIST
90299: LIST
90300: PUSH
90301: LD_INT 1
90303: PUSH
90304: LD_INT 2
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: PUSH
90311: LD_INT 0
90313: PUSH
90314: LD_INT 2
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 1
90323: NEG
90324: PUSH
90325: LD_INT 1
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 2
90334: NEG
90335: PUSH
90336: LD_INT 0
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: PUSH
90343: LD_INT 2
90345: NEG
90346: PUSH
90347: LD_INT 1
90349: NEG
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: LD_INT 2
90357: NEG
90358: PUSH
90359: LD_INT 2
90361: NEG
90362: PUSH
90363: EMPTY
90364: LIST
90365: LIST
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: LIST
90373: LIST
90374: LIST
90375: LIST
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90388: LD_ADDR_VAR 0 56
90392: PUSH
90393: LD_INT 0
90395: PUSH
90396: LD_INT 0
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: PUSH
90403: LD_INT 0
90405: PUSH
90406: LD_INT 1
90408: NEG
90409: PUSH
90410: EMPTY
90411: LIST
90412: LIST
90413: PUSH
90414: LD_INT 1
90416: PUSH
90417: LD_INT 0
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: PUSH
90424: LD_INT 1
90426: PUSH
90427: LD_INT 1
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 0
90436: PUSH
90437: LD_INT 1
90439: PUSH
90440: EMPTY
90441: LIST
90442: LIST
90443: PUSH
90444: LD_INT 1
90446: NEG
90447: PUSH
90448: LD_INT 0
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: PUSH
90455: LD_INT 1
90457: NEG
90458: PUSH
90459: LD_INT 1
90461: NEG
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 1
90469: NEG
90470: PUSH
90471: LD_INT 2
90473: NEG
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: LD_INT 0
90481: PUSH
90482: LD_INT 2
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: PUSH
90493: LD_INT 1
90495: NEG
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: LD_INT 2
90503: PUSH
90504: LD_INT 0
90506: PUSH
90507: EMPTY
90508: LIST
90509: LIST
90510: PUSH
90511: LD_INT 2
90513: PUSH
90514: LD_INT 1
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: PUSH
90521: LD_INT 2
90523: PUSH
90524: LD_INT 2
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: PUSH
90531: LD_INT 1
90533: PUSH
90534: LD_INT 2
90536: PUSH
90537: EMPTY
90538: LIST
90539: LIST
90540: PUSH
90541: LD_INT 0
90543: PUSH
90544: LD_INT 2
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PUSH
90551: LD_INT 1
90553: NEG
90554: PUSH
90555: LD_INT 1
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: PUSH
90562: LD_INT 2
90564: NEG
90565: PUSH
90566: LD_INT 0
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 2
90575: NEG
90576: PUSH
90577: LD_INT 1
90579: NEG
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: LD_INT 2
90587: NEG
90588: PUSH
90589: LD_INT 2
90591: NEG
90592: PUSH
90593: EMPTY
90594: LIST
90595: LIST
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90618: LD_ADDR_VAR 0 57
90622: PUSH
90623: LD_INT 0
90625: PUSH
90626: LD_INT 0
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: PUSH
90633: LD_INT 0
90635: PUSH
90636: LD_INT 1
90638: NEG
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: PUSH
90644: LD_INT 1
90646: PUSH
90647: LD_INT 0
90649: PUSH
90650: EMPTY
90651: LIST
90652: LIST
90653: PUSH
90654: LD_INT 1
90656: PUSH
90657: LD_INT 1
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: LD_INT 1
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 1
90676: NEG
90677: PUSH
90678: LD_INT 0
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 1
90687: NEG
90688: PUSH
90689: LD_INT 1
90691: NEG
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: LD_INT 2
90703: NEG
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 0
90711: PUSH
90712: LD_INT 2
90714: NEG
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: PUSH
90723: LD_INT 1
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 2
90733: PUSH
90734: LD_INT 0
90736: PUSH
90737: EMPTY
90738: LIST
90739: LIST
90740: PUSH
90741: LD_INT 2
90743: PUSH
90744: LD_INT 1
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 2
90753: PUSH
90754: LD_INT 2
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PUSH
90761: LD_INT 1
90763: PUSH
90764: LD_INT 2
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: LD_INT 0
90773: PUSH
90774: LD_INT 2
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 1
90783: NEG
90784: PUSH
90785: LD_INT 1
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 2
90794: NEG
90795: PUSH
90796: LD_INT 0
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 2
90805: NEG
90806: PUSH
90807: LD_INT 1
90809: NEG
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 2
90817: NEG
90818: PUSH
90819: LD_INT 2
90821: NEG
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: LIST
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: LIST
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90848: LD_ADDR_VAR 0 58
90852: PUSH
90853: LD_INT 0
90855: PUSH
90856: LD_INT 0
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: PUSH
90863: LD_INT 0
90865: PUSH
90866: LD_INT 1
90868: NEG
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: LD_INT 1
90876: PUSH
90877: LD_INT 0
90879: PUSH
90880: EMPTY
90881: LIST
90882: LIST
90883: PUSH
90884: LD_INT 1
90886: PUSH
90887: LD_INT 1
90889: PUSH
90890: EMPTY
90891: LIST
90892: LIST
90893: PUSH
90894: LD_INT 0
90896: PUSH
90897: LD_INT 1
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PUSH
90904: LD_INT 1
90906: NEG
90907: PUSH
90908: LD_INT 0
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 1
90917: NEG
90918: PUSH
90919: LD_INT 1
90921: NEG
90922: PUSH
90923: EMPTY
90924: LIST
90925: LIST
90926: PUSH
90927: LD_INT 1
90929: NEG
90930: PUSH
90931: LD_INT 2
90933: NEG
90934: PUSH
90935: EMPTY
90936: LIST
90937: LIST
90938: PUSH
90939: LD_INT 0
90941: PUSH
90942: LD_INT 2
90944: NEG
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PUSH
90950: LD_INT 1
90952: PUSH
90953: LD_INT 1
90955: NEG
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: LD_INT 2
90963: PUSH
90964: LD_INT 0
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 2
90973: PUSH
90974: LD_INT 1
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: LD_INT 2
90983: PUSH
90984: LD_INT 2
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: PUSH
90991: LD_INT 1
90993: PUSH
90994: LD_INT 2
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: PUSH
91001: LD_INT 0
91003: PUSH
91004: LD_INT 2
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: PUSH
91011: LD_INT 1
91013: NEG
91014: PUSH
91015: LD_INT 1
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: PUSH
91022: LD_INT 2
91024: NEG
91025: PUSH
91026: LD_INT 0
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 2
91035: NEG
91036: PUSH
91037: LD_INT 1
91039: NEG
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 2
91047: NEG
91048: PUSH
91049: LD_INT 2
91051: NEG
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: LIST
91065: LIST
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91078: LD_ADDR_VAR 0 59
91082: PUSH
91083: LD_INT 0
91085: PUSH
91086: LD_INT 0
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 0
91095: PUSH
91096: LD_INT 1
91098: NEG
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 1
91106: PUSH
91107: LD_INT 0
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: PUSH
91114: LD_INT 1
91116: PUSH
91117: LD_INT 1
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: PUSH
91124: LD_INT 0
91126: PUSH
91127: LD_INT 1
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PUSH
91134: LD_INT 1
91136: NEG
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 1
91147: NEG
91148: PUSH
91149: LD_INT 1
91151: NEG
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91166: LD_ADDR_VAR 0 60
91170: PUSH
91171: LD_INT 0
91173: PUSH
91174: LD_INT 0
91176: PUSH
91177: EMPTY
91178: LIST
91179: LIST
91180: PUSH
91181: LD_INT 0
91183: PUSH
91184: LD_INT 1
91186: NEG
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: PUSH
91192: LD_INT 1
91194: PUSH
91195: LD_INT 0
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: LD_INT 1
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: PUSH
91212: LD_INT 0
91214: PUSH
91215: LD_INT 1
91217: PUSH
91218: EMPTY
91219: LIST
91220: LIST
91221: PUSH
91222: LD_INT 1
91224: NEG
91225: PUSH
91226: LD_INT 0
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 1
91235: NEG
91236: PUSH
91237: LD_INT 1
91239: NEG
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91254: LD_ADDR_VAR 0 61
91258: PUSH
91259: LD_INT 0
91261: PUSH
91262: LD_INT 0
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 0
91271: PUSH
91272: LD_INT 1
91274: NEG
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: PUSH
91280: LD_INT 1
91282: PUSH
91283: LD_INT 0
91285: PUSH
91286: EMPTY
91287: LIST
91288: LIST
91289: PUSH
91290: LD_INT 1
91292: PUSH
91293: LD_INT 1
91295: PUSH
91296: EMPTY
91297: LIST
91298: LIST
91299: PUSH
91300: LD_INT 0
91302: PUSH
91303: LD_INT 1
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PUSH
91310: LD_INT 1
91312: NEG
91313: PUSH
91314: LD_INT 0
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 1
91323: NEG
91324: PUSH
91325: LD_INT 1
91327: NEG
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91342: LD_ADDR_VAR 0 62
91346: PUSH
91347: LD_INT 0
91349: PUSH
91350: LD_INT 0
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 0
91359: PUSH
91360: LD_INT 1
91362: NEG
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 1
91370: PUSH
91371: LD_INT 0
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 1
91380: PUSH
91381: LD_INT 1
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 0
91390: PUSH
91391: LD_INT 1
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: PUSH
91398: LD_INT 1
91400: NEG
91401: PUSH
91402: LD_INT 0
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 1
91411: NEG
91412: PUSH
91413: LD_INT 1
91415: NEG
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91430: LD_ADDR_VAR 0 63
91434: PUSH
91435: LD_INT 0
91437: PUSH
91438: LD_INT 0
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 0
91447: PUSH
91448: LD_INT 1
91450: NEG
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 1
91458: PUSH
91459: LD_INT 0
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 1
91468: PUSH
91469: LD_INT 1
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 0
91478: PUSH
91479: LD_INT 1
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 1
91488: NEG
91489: PUSH
91490: LD_INT 0
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 1
91499: NEG
91500: PUSH
91501: LD_INT 1
91503: NEG
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91518: LD_ADDR_VAR 0 64
91522: PUSH
91523: LD_INT 0
91525: PUSH
91526: LD_INT 0
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PUSH
91533: LD_INT 0
91535: PUSH
91536: LD_INT 1
91538: NEG
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: PUSH
91544: LD_INT 1
91546: PUSH
91547: LD_INT 0
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: LD_INT 1
91556: PUSH
91557: LD_INT 1
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 0
91566: PUSH
91567: LD_INT 1
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: LD_INT 1
91576: NEG
91577: PUSH
91578: LD_INT 0
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: PUSH
91585: LD_INT 1
91587: NEG
91588: PUSH
91589: LD_INT 1
91591: NEG
91592: PUSH
91593: EMPTY
91594: LIST
91595: LIST
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: ST_TO_ADDR
// end ; 1 :
91606: GO 97503
91608: LD_INT 1
91610: DOUBLE
91611: EQUAL
91612: IFTRUE 91616
91614: GO 94239
91616: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91617: LD_ADDR_VAR 0 11
91621: PUSH
91622: LD_INT 1
91624: NEG
91625: PUSH
91626: LD_INT 3
91628: NEG
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 0
91636: PUSH
91637: LD_INT 3
91639: NEG
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: LD_INT 1
91647: PUSH
91648: LD_INT 2
91650: NEG
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: LIST
91660: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91661: LD_ADDR_VAR 0 12
91665: PUSH
91666: LD_INT 2
91668: PUSH
91669: LD_INT 1
91671: NEG
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: PUSH
91677: LD_INT 3
91679: PUSH
91680: LD_INT 0
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: LD_INT 3
91689: PUSH
91690: LD_INT 1
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: PUSH
91697: EMPTY
91698: LIST
91699: LIST
91700: LIST
91701: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91702: LD_ADDR_VAR 0 13
91706: PUSH
91707: LD_INT 3
91709: PUSH
91710: LD_INT 2
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: LD_INT 3
91719: PUSH
91720: LD_INT 3
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: PUSH
91727: LD_INT 2
91729: PUSH
91730: LD_INT 3
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: LIST
91741: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91742: LD_ADDR_VAR 0 14
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: LD_INT 3
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PUSH
91757: LD_INT 0
91759: PUSH
91760: LD_INT 3
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: PUSH
91767: LD_INT 1
91769: NEG
91770: PUSH
91771: LD_INT 2
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: EMPTY
91779: LIST
91780: LIST
91781: LIST
91782: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91783: LD_ADDR_VAR 0 15
91787: PUSH
91788: LD_INT 2
91790: NEG
91791: PUSH
91792: LD_INT 1
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 3
91801: NEG
91802: PUSH
91803: LD_INT 0
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PUSH
91810: LD_INT 3
91812: NEG
91813: PUSH
91814: LD_INT 1
91816: NEG
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: LIST
91826: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91827: LD_ADDR_VAR 0 16
91831: PUSH
91832: LD_INT 2
91834: NEG
91835: PUSH
91836: LD_INT 3
91838: NEG
91839: PUSH
91840: EMPTY
91841: LIST
91842: LIST
91843: PUSH
91844: LD_INT 3
91846: NEG
91847: PUSH
91848: LD_INT 2
91850: NEG
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 3
91858: NEG
91859: PUSH
91860: LD_INT 3
91862: NEG
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: LIST
91872: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91873: LD_ADDR_VAR 0 17
91877: PUSH
91878: LD_INT 1
91880: NEG
91881: PUSH
91882: LD_INT 3
91884: NEG
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 0
91892: PUSH
91893: LD_INT 3
91895: NEG
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: LD_INT 1
91903: PUSH
91904: LD_INT 2
91906: NEG
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: LIST
91916: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91917: LD_ADDR_VAR 0 18
91921: PUSH
91922: LD_INT 2
91924: PUSH
91925: LD_INT 1
91927: NEG
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: PUSH
91933: LD_INT 3
91935: PUSH
91936: LD_INT 0
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 3
91945: PUSH
91946: LD_INT 1
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: LIST
91957: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91958: LD_ADDR_VAR 0 19
91962: PUSH
91963: LD_INT 3
91965: PUSH
91966: LD_INT 2
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 3
91975: PUSH
91976: LD_INT 3
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: LD_INT 2
91985: PUSH
91986: LD_INT 3
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: LIST
91997: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91998: LD_ADDR_VAR 0 20
92002: PUSH
92003: LD_INT 1
92005: PUSH
92006: LD_INT 3
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: PUSH
92013: LD_INT 0
92015: PUSH
92016: LD_INT 3
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 1
92025: NEG
92026: PUSH
92027: LD_INT 2
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: PUSH
92034: EMPTY
92035: LIST
92036: LIST
92037: LIST
92038: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92039: LD_ADDR_VAR 0 21
92043: PUSH
92044: LD_INT 2
92046: NEG
92047: PUSH
92048: LD_INT 1
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 3
92057: NEG
92058: PUSH
92059: LD_INT 0
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: LD_INT 3
92068: NEG
92069: PUSH
92070: LD_INT 1
92072: NEG
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: LIST
92082: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92083: LD_ADDR_VAR 0 22
92087: PUSH
92088: LD_INT 2
92090: NEG
92091: PUSH
92092: LD_INT 3
92094: NEG
92095: PUSH
92096: EMPTY
92097: LIST
92098: LIST
92099: PUSH
92100: LD_INT 3
92102: NEG
92103: PUSH
92104: LD_INT 2
92106: NEG
92107: PUSH
92108: EMPTY
92109: LIST
92110: LIST
92111: PUSH
92112: LD_INT 3
92114: NEG
92115: PUSH
92116: LD_INT 3
92118: NEG
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: LIST
92128: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92129: LD_ADDR_VAR 0 23
92133: PUSH
92134: LD_INT 0
92136: PUSH
92137: LD_INT 3
92139: NEG
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: PUSH
92145: LD_INT 1
92147: NEG
92148: PUSH
92149: LD_INT 4
92151: NEG
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 1
92159: PUSH
92160: LD_INT 3
92162: NEG
92163: PUSH
92164: EMPTY
92165: LIST
92166: LIST
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: LIST
92172: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92173: LD_ADDR_VAR 0 24
92177: PUSH
92178: LD_INT 3
92180: PUSH
92181: LD_INT 0
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: LD_INT 3
92190: PUSH
92191: LD_INT 1
92193: NEG
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: PUSH
92199: LD_INT 4
92201: PUSH
92202: LD_INT 1
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: LIST
92213: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92214: LD_ADDR_VAR 0 25
92218: PUSH
92219: LD_INT 3
92221: PUSH
92222: LD_INT 3
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: PUSH
92229: LD_INT 4
92231: PUSH
92232: LD_INT 3
92234: PUSH
92235: EMPTY
92236: LIST
92237: LIST
92238: PUSH
92239: LD_INT 3
92241: PUSH
92242: LD_INT 4
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: LIST
92253: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92254: LD_ADDR_VAR 0 26
92258: PUSH
92259: LD_INT 0
92261: PUSH
92262: LD_INT 3
92264: PUSH
92265: EMPTY
92266: LIST
92267: LIST
92268: PUSH
92269: LD_INT 1
92271: PUSH
92272: LD_INT 4
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: PUSH
92279: LD_INT 1
92281: NEG
92282: PUSH
92283: LD_INT 3
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: LIST
92294: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92295: LD_ADDR_VAR 0 27
92299: PUSH
92300: LD_INT 3
92302: NEG
92303: PUSH
92304: LD_INT 0
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: PUSH
92311: LD_INT 3
92313: NEG
92314: PUSH
92315: LD_INT 1
92317: PUSH
92318: EMPTY
92319: LIST
92320: LIST
92321: PUSH
92322: LD_INT 4
92324: NEG
92325: PUSH
92326: LD_INT 1
92328: NEG
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: LIST
92338: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92339: LD_ADDR_VAR 0 28
92343: PUSH
92344: LD_INT 3
92346: NEG
92347: PUSH
92348: LD_INT 3
92350: NEG
92351: PUSH
92352: EMPTY
92353: LIST
92354: LIST
92355: PUSH
92356: LD_INT 3
92358: NEG
92359: PUSH
92360: LD_INT 4
92362: NEG
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: PUSH
92368: LD_INT 4
92370: NEG
92371: PUSH
92372: LD_INT 3
92374: NEG
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: LIST
92384: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92385: LD_ADDR_VAR 0 29
92389: PUSH
92390: LD_INT 1
92392: NEG
92393: PUSH
92394: LD_INT 3
92396: NEG
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: PUSH
92402: LD_INT 0
92404: PUSH
92405: LD_INT 3
92407: NEG
92408: PUSH
92409: EMPTY
92410: LIST
92411: LIST
92412: PUSH
92413: LD_INT 1
92415: PUSH
92416: LD_INT 2
92418: NEG
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: LD_INT 1
92426: NEG
92427: PUSH
92428: LD_INT 4
92430: NEG
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: LD_INT 0
92438: PUSH
92439: LD_INT 4
92441: NEG
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: PUSH
92447: LD_INT 1
92449: PUSH
92450: LD_INT 3
92452: NEG
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 1
92460: NEG
92461: PUSH
92462: LD_INT 5
92464: NEG
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: LD_INT 0
92472: PUSH
92473: LD_INT 5
92475: NEG
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 1
92483: PUSH
92484: LD_INT 4
92486: NEG
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: PUSH
92492: LD_INT 1
92494: NEG
92495: PUSH
92496: LD_INT 6
92498: NEG
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 0
92506: PUSH
92507: LD_INT 6
92509: NEG
92510: PUSH
92511: EMPTY
92512: LIST
92513: LIST
92514: PUSH
92515: LD_INT 1
92517: PUSH
92518: LD_INT 5
92520: NEG
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92540: LD_ADDR_VAR 0 30
92544: PUSH
92545: LD_INT 2
92547: PUSH
92548: LD_INT 1
92550: NEG
92551: PUSH
92552: EMPTY
92553: LIST
92554: LIST
92555: PUSH
92556: LD_INT 3
92558: PUSH
92559: LD_INT 0
92561: PUSH
92562: EMPTY
92563: LIST
92564: LIST
92565: PUSH
92566: LD_INT 3
92568: PUSH
92569: LD_INT 1
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 3
92578: PUSH
92579: LD_INT 1
92581: NEG
92582: PUSH
92583: EMPTY
92584: LIST
92585: LIST
92586: PUSH
92587: LD_INT 4
92589: PUSH
92590: LD_INT 0
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: PUSH
92597: LD_INT 4
92599: PUSH
92600: LD_INT 1
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 4
92609: PUSH
92610: LD_INT 1
92612: NEG
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 5
92620: PUSH
92621: LD_INT 0
92623: PUSH
92624: EMPTY
92625: LIST
92626: LIST
92627: PUSH
92628: LD_INT 5
92630: PUSH
92631: LD_INT 1
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: PUSH
92638: LD_INT 5
92640: PUSH
92641: LD_INT 1
92643: NEG
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: PUSH
92649: LD_INT 6
92651: PUSH
92652: LD_INT 0
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: PUSH
92659: LD_INT 6
92661: PUSH
92662: LD_INT 1
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: PUSH
92669: EMPTY
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92683: LD_ADDR_VAR 0 31
92687: PUSH
92688: LD_INT 3
92690: PUSH
92691: LD_INT 2
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 3
92700: PUSH
92701: LD_INT 3
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: LD_INT 2
92710: PUSH
92711: LD_INT 3
92713: PUSH
92714: EMPTY
92715: LIST
92716: LIST
92717: PUSH
92718: LD_INT 4
92720: PUSH
92721: LD_INT 3
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: LD_INT 4
92730: PUSH
92731: LD_INT 4
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: PUSH
92738: LD_INT 3
92740: PUSH
92741: LD_INT 4
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: PUSH
92748: LD_INT 5
92750: PUSH
92751: LD_INT 4
92753: PUSH
92754: EMPTY
92755: LIST
92756: LIST
92757: PUSH
92758: LD_INT 5
92760: PUSH
92761: LD_INT 5
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 4
92770: PUSH
92771: LD_INT 5
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: LD_INT 6
92780: PUSH
92781: LD_INT 5
92783: PUSH
92784: EMPTY
92785: LIST
92786: LIST
92787: PUSH
92788: LD_INT 6
92790: PUSH
92791: LD_INT 6
92793: PUSH
92794: EMPTY
92795: LIST
92796: LIST
92797: PUSH
92798: LD_INT 5
92800: PUSH
92801: LD_INT 6
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: PUSH
92808: EMPTY
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92822: LD_ADDR_VAR 0 32
92826: PUSH
92827: LD_INT 1
92829: PUSH
92830: LD_INT 3
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 0
92839: PUSH
92840: LD_INT 3
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 1
92849: NEG
92850: PUSH
92851: LD_INT 2
92853: PUSH
92854: EMPTY
92855: LIST
92856: LIST
92857: PUSH
92858: LD_INT 1
92860: PUSH
92861: LD_INT 4
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 0
92870: PUSH
92871: LD_INT 4
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 1
92880: NEG
92881: PUSH
92882: LD_INT 3
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: PUSH
92889: LD_INT 1
92891: PUSH
92892: LD_INT 5
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: PUSH
92899: LD_INT 0
92901: PUSH
92902: LD_INT 5
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PUSH
92909: LD_INT 1
92911: NEG
92912: PUSH
92913: LD_INT 4
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PUSH
92920: LD_INT 1
92922: PUSH
92923: LD_INT 6
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: LD_INT 0
92932: PUSH
92933: LD_INT 6
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 1
92942: NEG
92943: PUSH
92944: LD_INT 5
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92965: LD_ADDR_VAR 0 33
92969: PUSH
92970: LD_INT 2
92972: NEG
92973: PUSH
92974: LD_INT 1
92976: PUSH
92977: EMPTY
92978: LIST
92979: LIST
92980: PUSH
92981: LD_INT 3
92983: NEG
92984: PUSH
92985: LD_INT 0
92987: PUSH
92988: EMPTY
92989: LIST
92990: LIST
92991: PUSH
92992: LD_INT 3
92994: NEG
92995: PUSH
92996: LD_INT 1
92998: NEG
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: PUSH
93004: LD_INT 3
93006: NEG
93007: PUSH
93008: LD_INT 1
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 4
93017: NEG
93018: PUSH
93019: LD_INT 0
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PUSH
93026: LD_INT 4
93028: NEG
93029: PUSH
93030: LD_INT 1
93032: NEG
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: PUSH
93038: LD_INT 4
93040: NEG
93041: PUSH
93042: LD_INT 1
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: LD_INT 5
93051: NEG
93052: PUSH
93053: LD_INT 0
93055: PUSH
93056: EMPTY
93057: LIST
93058: LIST
93059: PUSH
93060: LD_INT 5
93062: NEG
93063: PUSH
93064: LD_INT 1
93066: NEG
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 5
93074: NEG
93075: PUSH
93076: LD_INT 1
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 6
93085: NEG
93086: PUSH
93087: LD_INT 0
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 6
93096: NEG
93097: PUSH
93098: LD_INT 1
93100: NEG
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93120: LD_ADDR_VAR 0 34
93124: PUSH
93125: LD_INT 2
93127: NEG
93128: PUSH
93129: LD_INT 3
93131: NEG
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: LD_INT 3
93139: NEG
93140: PUSH
93141: LD_INT 2
93143: NEG
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PUSH
93149: LD_INT 3
93151: NEG
93152: PUSH
93153: LD_INT 3
93155: NEG
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 3
93163: NEG
93164: PUSH
93165: LD_INT 4
93167: NEG
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: LD_INT 4
93175: NEG
93176: PUSH
93177: LD_INT 3
93179: NEG
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PUSH
93185: LD_INT 4
93187: NEG
93188: PUSH
93189: LD_INT 4
93191: NEG
93192: PUSH
93193: EMPTY
93194: LIST
93195: LIST
93196: PUSH
93197: LD_INT 4
93199: NEG
93200: PUSH
93201: LD_INT 5
93203: NEG
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_INT 5
93211: NEG
93212: PUSH
93213: LD_INT 4
93215: NEG
93216: PUSH
93217: EMPTY
93218: LIST
93219: LIST
93220: PUSH
93221: LD_INT 5
93223: NEG
93224: PUSH
93225: LD_INT 5
93227: NEG
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: PUSH
93233: LD_INT 5
93235: NEG
93236: PUSH
93237: LD_INT 6
93239: NEG
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: LD_INT 6
93247: NEG
93248: PUSH
93249: LD_INT 5
93251: NEG
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: PUSH
93257: LD_INT 6
93259: NEG
93260: PUSH
93261: LD_INT 6
93263: NEG
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: LIST
93273: LIST
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93283: LD_ADDR_VAR 0 41
93287: PUSH
93288: LD_INT 0
93290: PUSH
93291: LD_INT 2
93293: NEG
93294: PUSH
93295: EMPTY
93296: LIST
93297: LIST
93298: PUSH
93299: LD_INT 1
93301: NEG
93302: PUSH
93303: LD_INT 3
93305: NEG
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PUSH
93311: LD_INT 1
93313: PUSH
93314: LD_INT 2
93316: NEG
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: EMPTY
93323: LIST
93324: LIST
93325: LIST
93326: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93327: LD_ADDR_VAR 0 42
93331: PUSH
93332: LD_INT 2
93334: PUSH
93335: LD_INT 0
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 2
93344: PUSH
93345: LD_INT 1
93347: NEG
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: LD_INT 3
93355: PUSH
93356: LD_INT 1
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: LIST
93367: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93368: LD_ADDR_VAR 0 43
93372: PUSH
93373: LD_INT 2
93375: PUSH
93376: LD_INT 2
93378: PUSH
93379: EMPTY
93380: LIST
93381: LIST
93382: PUSH
93383: LD_INT 3
93385: PUSH
93386: LD_INT 2
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 2
93395: PUSH
93396: LD_INT 3
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: LIST
93407: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93408: LD_ADDR_VAR 0 44
93412: PUSH
93413: LD_INT 0
93415: PUSH
93416: LD_INT 2
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: PUSH
93423: LD_INT 1
93425: PUSH
93426: LD_INT 3
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: LD_INT 1
93435: NEG
93436: PUSH
93437: LD_INT 2
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: EMPTY
93445: LIST
93446: LIST
93447: LIST
93448: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93449: LD_ADDR_VAR 0 45
93453: PUSH
93454: LD_INT 2
93456: NEG
93457: PUSH
93458: LD_INT 0
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 2
93467: NEG
93468: PUSH
93469: LD_INT 1
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 3
93478: NEG
93479: PUSH
93480: LD_INT 1
93482: NEG
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: LIST
93492: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93493: LD_ADDR_VAR 0 46
93497: PUSH
93498: LD_INT 2
93500: NEG
93501: PUSH
93502: LD_INT 2
93504: NEG
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 2
93512: NEG
93513: PUSH
93514: LD_INT 3
93516: NEG
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: PUSH
93522: LD_INT 3
93524: NEG
93525: PUSH
93526: LD_INT 2
93528: NEG
93529: PUSH
93530: EMPTY
93531: LIST
93532: LIST
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: LIST
93538: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93539: LD_ADDR_VAR 0 47
93543: PUSH
93544: LD_INT 2
93546: NEG
93547: PUSH
93548: LD_INT 3
93550: NEG
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: LD_INT 1
93558: NEG
93559: PUSH
93560: LD_INT 3
93562: NEG
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93572: LD_ADDR_VAR 0 48
93576: PUSH
93577: LD_INT 1
93579: PUSH
93580: LD_INT 2
93582: NEG
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 2
93590: PUSH
93591: LD_INT 1
93593: NEG
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93603: LD_ADDR_VAR 0 49
93607: PUSH
93608: LD_INT 3
93610: PUSH
93611: LD_INT 1
93613: PUSH
93614: EMPTY
93615: LIST
93616: LIST
93617: PUSH
93618: LD_INT 3
93620: PUSH
93621: LD_INT 2
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93632: LD_ADDR_VAR 0 50
93636: PUSH
93637: LD_INT 2
93639: PUSH
93640: LD_INT 3
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 1
93649: PUSH
93650: LD_INT 3
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93661: LD_ADDR_VAR 0 51
93665: PUSH
93666: LD_INT 1
93668: NEG
93669: PUSH
93670: LD_INT 2
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 2
93679: NEG
93680: PUSH
93681: LD_INT 1
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93692: LD_ADDR_VAR 0 52
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: LD_INT 1
93703: NEG
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: LD_INT 3
93711: NEG
93712: PUSH
93713: LD_INT 2
93715: NEG
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: EMPTY
93722: LIST
93723: LIST
93724: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93725: LD_ADDR_VAR 0 53
93729: PUSH
93730: LD_INT 1
93732: NEG
93733: PUSH
93734: LD_INT 3
93736: NEG
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 0
93744: PUSH
93745: LD_INT 3
93747: NEG
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 1
93755: PUSH
93756: LD_INT 2
93758: NEG
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: LIST
93768: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93769: LD_ADDR_VAR 0 54
93773: PUSH
93774: LD_INT 2
93776: PUSH
93777: LD_INT 1
93779: NEG
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 3
93787: PUSH
93788: LD_INT 0
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: PUSH
93795: LD_INT 3
93797: PUSH
93798: LD_INT 1
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: LIST
93809: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93810: LD_ADDR_VAR 0 55
93814: PUSH
93815: LD_INT 3
93817: PUSH
93818: LD_INT 2
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: LD_INT 3
93827: PUSH
93828: LD_INT 3
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 2
93837: PUSH
93838: LD_INT 3
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: LIST
93849: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93850: LD_ADDR_VAR 0 56
93854: PUSH
93855: LD_INT 1
93857: PUSH
93858: LD_INT 3
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 0
93867: PUSH
93868: LD_INT 3
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 1
93877: NEG
93878: PUSH
93879: LD_INT 2
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: LIST
93890: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93891: LD_ADDR_VAR 0 57
93895: PUSH
93896: LD_INT 2
93898: NEG
93899: PUSH
93900: LD_INT 1
93902: PUSH
93903: EMPTY
93904: LIST
93905: LIST
93906: PUSH
93907: LD_INT 3
93909: NEG
93910: PUSH
93911: LD_INT 0
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 3
93920: NEG
93921: PUSH
93922: LD_INT 1
93924: NEG
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: EMPTY
93931: LIST
93932: LIST
93933: LIST
93934: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93935: LD_ADDR_VAR 0 58
93939: PUSH
93940: LD_INT 2
93942: NEG
93943: PUSH
93944: LD_INT 3
93946: NEG
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 3
93954: NEG
93955: PUSH
93956: LD_INT 2
93958: NEG
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PUSH
93964: LD_INT 3
93966: NEG
93967: PUSH
93968: LD_INT 3
93970: NEG
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: PUSH
93976: EMPTY
93977: LIST
93978: LIST
93979: LIST
93980: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93981: LD_ADDR_VAR 0 59
93985: PUSH
93986: LD_INT 1
93988: NEG
93989: PUSH
93990: LD_INT 2
93992: NEG
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: PUSH
93998: LD_INT 0
94000: PUSH
94001: LD_INT 2
94003: NEG
94004: PUSH
94005: EMPTY
94006: LIST
94007: LIST
94008: PUSH
94009: LD_INT 1
94011: PUSH
94012: LD_INT 1
94014: NEG
94015: PUSH
94016: EMPTY
94017: LIST
94018: LIST
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: LIST
94024: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94025: LD_ADDR_VAR 0 60
94029: PUSH
94030: LD_INT 1
94032: PUSH
94033: LD_INT 1
94035: NEG
94036: PUSH
94037: EMPTY
94038: LIST
94039: LIST
94040: PUSH
94041: LD_INT 2
94043: PUSH
94044: LD_INT 0
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: PUSH
94051: LD_INT 2
94053: PUSH
94054: LD_INT 1
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: LIST
94065: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94066: LD_ADDR_VAR 0 61
94070: PUSH
94071: LD_INT 2
94073: PUSH
94074: LD_INT 1
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: LD_INT 2
94083: PUSH
94084: LD_INT 2
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PUSH
94091: LD_INT 1
94093: PUSH
94094: LD_INT 2
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: LIST
94105: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94106: LD_ADDR_VAR 0 62
94110: PUSH
94111: LD_INT 1
94113: PUSH
94114: LD_INT 2
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 0
94123: PUSH
94124: LD_INT 2
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: LD_INT 1
94133: NEG
94134: PUSH
94135: LD_INT 1
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: LIST
94146: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94147: LD_ADDR_VAR 0 63
94151: PUSH
94152: LD_INT 1
94154: NEG
94155: PUSH
94156: LD_INT 1
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 2
94165: NEG
94166: PUSH
94167: LD_INT 0
94169: PUSH
94170: EMPTY
94171: LIST
94172: LIST
94173: PUSH
94174: LD_INT 2
94176: NEG
94177: PUSH
94178: LD_INT 1
94180: NEG
94181: PUSH
94182: EMPTY
94183: LIST
94184: LIST
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: LIST
94190: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94191: LD_ADDR_VAR 0 64
94195: PUSH
94196: LD_INT 1
94198: NEG
94199: PUSH
94200: LD_INT 2
94202: NEG
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 2
94210: NEG
94211: PUSH
94212: LD_INT 1
94214: NEG
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: PUSH
94220: LD_INT 2
94222: NEG
94223: PUSH
94224: LD_INT 2
94226: NEG
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: LIST
94236: ST_TO_ADDR
// end ; 2 :
94237: GO 97503
94239: LD_INT 2
94241: DOUBLE
94242: EQUAL
94243: IFTRUE 94247
94245: GO 97502
94247: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94248: LD_ADDR_VAR 0 29
94252: PUSH
94253: LD_INT 4
94255: PUSH
94256: LD_INT 0
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 4
94265: PUSH
94266: LD_INT 1
94268: NEG
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 5
94276: PUSH
94277: LD_INT 0
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: LD_INT 5
94286: PUSH
94287: LD_INT 1
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: LD_INT 4
94296: PUSH
94297: LD_INT 1
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: PUSH
94304: LD_INT 3
94306: PUSH
94307: LD_INT 0
94309: PUSH
94310: EMPTY
94311: LIST
94312: LIST
94313: PUSH
94314: LD_INT 3
94316: PUSH
94317: LD_INT 1
94319: NEG
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: LD_INT 3
94327: PUSH
94328: LD_INT 2
94330: NEG
94331: PUSH
94332: EMPTY
94333: LIST
94334: LIST
94335: PUSH
94336: LD_INT 5
94338: PUSH
94339: LD_INT 2
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PUSH
94346: LD_INT 3
94348: PUSH
94349: LD_INT 3
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PUSH
94356: LD_INT 3
94358: PUSH
94359: LD_INT 2
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 4
94368: PUSH
94369: LD_INT 3
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 4
94378: PUSH
94379: LD_INT 4
94381: PUSH
94382: EMPTY
94383: LIST
94384: LIST
94385: PUSH
94386: LD_INT 3
94388: PUSH
94389: LD_INT 4
94391: PUSH
94392: EMPTY
94393: LIST
94394: LIST
94395: PUSH
94396: LD_INT 2
94398: PUSH
94399: LD_INT 3
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: PUSH
94406: LD_INT 2
94408: PUSH
94409: LD_INT 2
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: LD_INT 4
94418: PUSH
94419: LD_INT 2
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: PUSH
94426: LD_INT 2
94428: PUSH
94429: LD_INT 4
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 0
94438: PUSH
94439: LD_INT 4
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: LD_INT 0
94448: PUSH
94449: LD_INT 3
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: LD_INT 1
94458: PUSH
94459: LD_INT 4
94461: PUSH
94462: EMPTY
94463: LIST
94464: LIST
94465: PUSH
94466: LD_INT 1
94468: PUSH
94469: LD_INT 5
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: PUSH
94476: LD_INT 0
94478: PUSH
94479: LD_INT 5
94481: PUSH
94482: EMPTY
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 1
94488: NEG
94489: PUSH
94490: LD_INT 4
94492: PUSH
94493: EMPTY
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 1
94499: NEG
94500: PUSH
94501: LD_INT 3
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: LD_INT 2
94510: PUSH
94511: LD_INT 5
94513: PUSH
94514: EMPTY
94515: LIST
94516: LIST
94517: PUSH
94518: LD_INT 2
94520: NEG
94521: PUSH
94522: LD_INT 3
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 3
94531: NEG
94532: PUSH
94533: LD_INT 0
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: PUSH
94540: LD_INT 3
94542: NEG
94543: PUSH
94544: LD_INT 1
94546: NEG
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PUSH
94552: LD_INT 2
94554: NEG
94555: PUSH
94556: LD_INT 0
94558: PUSH
94559: EMPTY
94560: LIST
94561: LIST
94562: PUSH
94563: LD_INT 2
94565: NEG
94566: PUSH
94567: LD_INT 1
94569: PUSH
94570: EMPTY
94571: LIST
94572: LIST
94573: PUSH
94574: LD_INT 3
94576: NEG
94577: PUSH
94578: LD_INT 1
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 4
94587: NEG
94588: PUSH
94589: LD_INT 0
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 4
94598: NEG
94599: PUSH
94600: LD_INT 1
94602: NEG
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: PUSH
94608: LD_INT 4
94610: NEG
94611: PUSH
94612: LD_INT 2
94614: NEG
94615: PUSH
94616: EMPTY
94617: LIST
94618: LIST
94619: PUSH
94620: LD_INT 2
94622: NEG
94623: PUSH
94624: LD_INT 2
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: PUSH
94631: LD_INT 4
94633: NEG
94634: PUSH
94635: LD_INT 4
94637: NEG
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 4
94645: NEG
94646: PUSH
94647: LD_INT 5
94649: NEG
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 3
94657: NEG
94658: PUSH
94659: LD_INT 4
94661: NEG
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 3
94669: NEG
94670: PUSH
94671: LD_INT 3
94673: NEG
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: PUSH
94679: LD_INT 4
94681: NEG
94682: PUSH
94683: LD_INT 3
94685: NEG
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 5
94693: NEG
94694: PUSH
94695: LD_INT 4
94697: NEG
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: LD_INT 5
94705: NEG
94706: PUSH
94707: LD_INT 5
94709: NEG
94710: PUSH
94711: EMPTY
94712: LIST
94713: LIST
94714: PUSH
94715: LD_INT 3
94717: NEG
94718: PUSH
94719: LD_INT 5
94721: NEG
94722: PUSH
94723: EMPTY
94724: LIST
94725: LIST
94726: PUSH
94727: LD_INT 5
94729: NEG
94730: PUSH
94731: LD_INT 3
94733: NEG
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: PUSH
94739: EMPTY
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94786: LD_ADDR_VAR 0 30
94790: PUSH
94791: LD_INT 4
94793: PUSH
94794: LD_INT 4
94796: PUSH
94797: EMPTY
94798: LIST
94799: LIST
94800: PUSH
94801: LD_INT 4
94803: PUSH
94804: LD_INT 3
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: PUSH
94811: LD_INT 5
94813: PUSH
94814: LD_INT 4
94816: PUSH
94817: EMPTY
94818: LIST
94819: LIST
94820: PUSH
94821: LD_INT 5
94823: PUSH
94824: LD_INT 5
94826: PUSH
94827: EMPTY
94828: LIST
94829: LIST
94830: PUSH
94831: LD_INT 4
94833: PUSH
94834: LD_INT 5
94836: PUSH
94837: EMPTY
94838: LIST
94839: LIST
94840: PUSH
94841: LD_INT 3
94843: PUSH
94844: LD_INT 4
94846: PUSH
94847: EMPTY
94848: LIST
94849: LIST
94850: PUSH
94851: LD_INT 3
94853: PUSH
94854: LD_INT 3
94856: PUSH
94857: EMPTY
94858: LIST
94859: LIST
94860: PUSH
94861: LD_INT 5
94863: PUSH
94864: LD_INT 3
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PUSH
94871: LD_INT 3
94873: PUSH
94874: LD_INT 5
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: LD_INT 0
94883: PUSH
94884: LD_INT 3
94886: PUSH
94887: EMPTY
94888: LIST
94889: LIST
94890: PUSH
94891: LD_INT 0
94893: PUSH
94894: LD_INT 2
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: PUSH
94901: LD_INT 1
94903: PUSH
94904: LD_INT 3
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: PUSH
94911: LD_INT 1
94913: PUSH
94914: LD_INT 4
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: PUSH
94921: LD_INT 0
94923: PUSH
94924: LD_INT 4
94926: PUSH
94927: EMPTY
94928: LIST
94929: LIST
94930: PUSH
94931: LD_INT 1
94933: NEG
94934: PUSH
94935: LD_INT 3
94937: PUSH
94938: EMPTY
94939: LIST
94940: LIST
94941: PUSH
94942: LD_INT 1
94944: NEG
94945: PUSH
94946: LD_INT 2
94948: PUSH
94949: EMPTY
94950: LIST
94951: LIST
94952: PUSH
94953: LD_INT 2
94955: PUSH
94956: LD_INT 4
94958: PUSH
94959: EMPTY
94960: LIST
94961: LIST
94962: PUSH
94963: LD_INT 2
94965: NEG
94966: PUSH
94967: LD_INT 2
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 4
94976: NEG
94977: PUSH
94978: LD_INT 0
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 4
94987: NEG
94988: PUSH
94989: LD_INT 1
94991: NEG
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: LD_INT 3
94999: NEG
95000: PUSH
95001: LD_INT 0
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 3
95010: NEG
95011: PUSH
95012: LD_INT 1
95014: PUSH
95015: EMPTY
95016: LIST
95017: LIST
95018: PUSH
95019: LD_INT 4
95021: NEG
95022: PUSH
95023: LD_INT 1
95025: PUSH
95026: EMPTY
95027: LIST
95028: LIST
95029: PUSH
95030: LD_INT 5
95032: NEG
95033: PUSH
95034: LD_INT 0
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: PUSH
95041: LD_INT 5
95043: NEG
95044: PUSH
95045: LD_INT 1
95047: NEG
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: PUSH
95053: LD_INT 5
95055: NEG
95056: PUSH
95057: LD_INT 2
95059: NEG
95060: PUSH
95061: EMPTY
95062: LIST
95063: LIST
95064: PUSH
95065: LD_INT 3
95067: NEG
95068: PUSH
95069: LD_INT 2
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: PUSH
95076: LD_INT 3
95078: NEG
95079: PUSH
95080: LD_INT 3
95082: NEG
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: LD_INT 3
95090: NEG
95091: PUSH
95092: LD_INT 4
95094: NEG
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PUSH
95100: LD_INT 2
95102: NEG
95103: PUSH
95104: LD_INT 3
95106: NEG
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 2
95114: NEG
95115: PUSH
95116: LD_INT 2
95118: NEG
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: PUSH
95124: LD_INT 3
95126: NEG
95127: PUSH
95128: LD_INT 2
95130: NEG
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 4
95138: NEG
95139: PUSH
95140: LD_INT 3
95142: NEG
95143: PUSH
95144: EMPTY
95145: LIST
95146: LIST
95147: PUSH
95148: LD_INT 4
95150: NEG
95151: PUSH
95152: LD_INT 4
95154: NEG
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: PUSH
95160: LD_INT 2
95162: NEG
95163: PUSH
95164: LD_INT 4
95166: NEG
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 4
95174: NEG
95175: PUSH
95176: LD_INT 2
95178: NEG
95179: PUSH
95180: EMPTY
95181: LIST
95182: LIST
95183: PUSH
95184: LD_INT 0
95186: PUSH
95187: LD_INT 4
95189: NEG
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: PUSH
95195: LD_INT 0
95197: PUSH
95198: LD_INT 5
95200: NEG
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: PUSH
95206: LD_INT 1
95208: PUSH
95209: LD_INT 4
95211: NEG
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: PUSH
95217: LD_INT 1
95219: PUSH
95220: LD_INT 3
95222: NEG
95223: PUSH
95224: EMPTY
95225: LIST
95226: LIST
95227: PUSH
95228: LD_INT 0
95230: PUSH
95231: LD_INT 3
95233: NEG
95234: PUSH
95235: EMPTY
95236: LIST
95237: LIST
95238: PUSH
95239: LD_INT 1
95241: NEG
95242: PUSH
95243: LD_INT 4
95245: NEG
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: PUSH
95251: LD_INT 1
95253: NEG
95254: PUSH
95255: LD_INT 5
95257: NEG
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 2
95265: PUSH
95266: LD_INT 3
95268: NEG
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: PUSH
95274: LD_INT 2
95276: NEG
95277: PUSH
95278: LD_INT 5
95280: NEG
95281: PUSH
95282: EMPTY
95283: LIST
95284: LIST
95285: PUSH
95286: EMPTY
95287: LIST
95288: LIST
95289: LIST
95290: LIST
95291: LIST
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95333: LD_ADDR_VAR 0 31
95337: PUSH
95338: LD_INT 0
95340: PUSH
95341: LD_INT 4
95343: PUSH
95344: EMPTY
95345: LIST
95346: LIST
95347: PUSH
95348: LD_INT 0
95350: PUSH
95351: LD_INT 3
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: LD_INT 1
95360: PUSH
95361: LD_INT 4
95363: PUSH
95364: EMPTY
95365: LIST
95366: LIST
95367: PUSH
95368: LD_INT 1
95370: PUSH
95371: LD_INT 5
95373: PUSH
95374: EMPTY
95375: LIST
95376: LIST
95377: PUSH
95378: LD_INT 0
95380: PUSH
95381: LD_INT 5
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: LD_INT 1
95390: NEG
95391: PUSH
95392: LD_INT 4
95394: PUSH
95395: EMPTY
95396: LIST
95397: LIST
95398: PUSH
95399: LD_INT 1
95401: NEG
95402: PUSH
95403: LD_INT 3
95405: PUSH
95406: EMPTY
95407: LIST
95408: LIST
95409: PUSH
95410: LD_INT 2
95412: PUSH
95413: LD_INT 5
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 2
95422: NEG
95423: PUSH
95424: LD_INT 3
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: LD_INT 3
95433: NEG
95434: PUSH
95435: LD_INT 0
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: PUSH
95442: LD_INT 3
95444: NEG
95445: PUSH
95446: LD_INT 1
95448: NEG
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PUSH
95454: LD_INT 2
95456: NEG
95457: PUSH
95458: LD_INT 0
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 2
95467: NEG
95468: PUSH
95469: LD_INT 1
95471: PUSH
95472: EMPTY
95473: LIST
95474: LIST
95475: PUSH
95476: LD_INT 3
95478: NEG
95479: PUSH
95480: LD_INT 1
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: PUSH
95487: LD_INT 4
95489: NEG
95490: PUSH
95491: LD_INT 0
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: PUSH
95498: LD_INT 4
95500: NEG
95501: PUSH
95502: LD_INT 1
95504: NEG
95505: PUSH
95506: EMPTY
95507: LIST
95508: LIST
95509: PUSH
95510: LD_INT 4
95512: NEG
95513: PUSH
95514: LD_INT 2
95516: NEG
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: LD_INT 2
95524: NEG
95525: PUSH
95526: LD_INT 2
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 4
95535: NEG
95536: PUSH
95537: LD_INT 4
95539: NEG
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: PUSH
95545: LD_INT 4
95547: NEG
95548: PUSH
95549: LD_INT 5
95551: NEG
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 3
95559: NEG
95560: PUSH
95561: LD_INT 4
95563: NEG
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: PUSH
95569: LD_INT 3
95571: NEG
95572: PUSH
95573: LD_INT 3
95575: NEG
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PUSH
95581: LD_INT 4
95583: NEG
95584: PUSH
95585: LD_INT 3
95587: NEG
95588: PUSH
95589: EMPTY
95590: LIST
95591: LIST
95592: PUSH
95593: LD_INT 5
95595: NEG
95596: PUSH
95597: LD_INT 4
95599: NEG
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 5
95607: NEG
95608: PUSH
95609: LD_INT 5
95611: NEG
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: LD_INT 3
95619: NEG
95620: PUSH
95621: LD_INT 5
95623: NEG
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: LD_INT 5
95631: NEG
95632: PUSH
95633: LD_INT 3
95635: NEG
95636: PUSH
95637: EMPTY
95638: LIST
95639: LIST
95640: PUSH
95641: LD_INT 0
95643: PUSH
95644: LD_INT 3
95646: NEG
95647: PUSH
95648: EMPTY
95649: LIST
95650: LIST
95651: PUSH
95652: LD_INT 0
95654: PUSH
95655: LD_INT 4
95657: NEG
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: PUSH
95663: LD_INT 1
95665: PUSH
95666: LD_INT 3
95668: NEG
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: PUSH
95674: LD_INT 1
95676: PUSH
95677: LD_INT 2
95679: NEG
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 0
95687: PUSH
95688: LD_INT 2
95690: NEG
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: PUSH
95696: LD_INT 1
95698: NEG
95699: PUSH
95700: LD_INT 3
95702: NEG
95703: PUSH
95704: EMPTY
95705: LIST
95706: LIST
95707: PUSH
95708: LD_INT 1
95710: NEG
95711: PUSH
95712: LD_INT 4
95714: NEG
95715: PUSH
95716: EMPTY
95717: LIST
95718: LIST
95719: PUSH
95720: LD_INT 2
95722: PUSH
95723: LD_INT 2
95725: NEG
95726: PUSH
95727: EMPTY
95728: LIST
95729: LIST
95730: PUSH
95731: LD_INT 2
95733: NEG
95734: PUSH
95735: LD_INT 4
95737: NEG
95738: PUSH
95739: EMPTY
95740: LIST
95741: LIST
95742: PUSH
95743: LD_INT 4
95745: PUSH
95746: LD_INT 0
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: PUSH
95753: LD_INT 4
95755: PUSH
95756: LD_INT 1
95758: NEG
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PUSH
95764: LD_INT 5
95766: PUSH
95767: LD_INT 0
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 5
95776: PUSH
95777: LD_INT 1
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 4
95786: PUSH
95787: LD_INT 1
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: PUSH
95794: LD_INT 3
95796: PUSH
95797: LD_INT 0
95799: PUSH
95800: EMPTY
95801: LIST
95802: LIST
95803: PUSH
95804: LD_INT 3
95806: PUSH
95807: LD_INT 1
95809: NEG
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: PUSH
95815: LD_INT 3
95817: PUSH
95818: LD_INT 2
95820: NEG
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: LD_INT 5
95828: PUSH
95829: LD_INT 2
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95883: LD_ADDR_VAR 0 32
95887: PUSH
95888: LD_INT 4
95890: NEG
95891: PUSH
95892: LD_INT 0
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 4
95901: NEG
95902: PUSH
95903: LD_INT 1
95905: NEG
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 3
95913: NEG
95914: PUSH
95915: LD_INT 0
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: LD_INT 3
95924: NEG
95925: PUSH
95926: LD_INT 1
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: PUSH
95933: LD_INT 4
95935: NEG
95936: PUSH
95937: LD_INT 1
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: PUSH
95944: LD_INT 5
95946: NEG
95947: PUSH
95948: LD_INT 0
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: PUSH
95955: LD_INT 5
95957: NEG
95958: PUSH
95959: LD_INT 1
95961: NEG
95962: PUSH
95963: EMPTY
95964: LIST
95965: LIST
95966: PUSH
95967: LD_INT 5
95969: NEG
95970: PUSH
95971: LD_INT 2
95973: NEG
95974: PUSH
95975: EMPTY
95976: LIST
95977: LIST
95978: PUSH
95979: LD_INT 3
95981: NEG
95982: PUSH
95983: LD_INT 2
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: LD_INT 3
95992: NEG
95993: PUSH
95994: LD_INT 3
95996: NEG
95997: PUSH
95998: EMPTY
95999: LIST
96000: LIST
96001: PUSH
96002: LD_INT 3
96004: NEG
96005: PUSH
96006: LD_INT 4
96008: NEG
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PUSH
96014: LD_INT 2
96016: NEG
96017: PUSH
96018: LD_INT 3
96020: NEG
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: PUSH
96026: LD_INT 2
96028: NEG
96029: PUSH
96030: LD_INT 2
96032: NEG
96033: PUSH
96034: EMPTY
96035: LIST
96036: LIST
96037: PUSH
96038: LD_INT 3
96040: NEG
96041: PUSH
96042: LD_INT 2
96044: NEG
96045: PUSH
96046: EMPTY
96047: LIST
96048: LIST
96049: PUSH
96050: LD_INT 4
96052: NEG
96053: PUSH
96054: LD_INT 3
96056: NEG
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 4
96064: NEG
96065: PUSH
96066: LD_INT 4
96068: NEG
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PUSH
96074: LD_INT 2
96076: NEG
96077: PUSH
96078: LD_INT 4
96080: NEG
96081: PUSH
96082: EMPTY
96083: LIST
96084: LIST
96085: PUSH
96086: LD_INT 4
96088: NEG
96089: PUSH
96090: LD_INT 2
96092: NEG
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: LD_INT 0
96100: PUSH
96101: LD_INT 4
96103: NEG
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: LD_INT 0
96111: PUSH
96112: LD_INT 5
96114: NEG
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 1
96122: PUSH
96123: LD_INT 4
96125: NEG
96126: PUSH
96127: EMPTY
96128: LIST
96129: LIST
96130: PUSH
96131: LD_INT 1
96133: PUSH
96134: LD_INT 3
96136: NEG
96137: PUSH
96138: EMPTY
96139: LIST
96140: LIST
96141: PUSH
96142: LD_INT 0
96144: PUSH
96145: LD_INT 3
96147: NEG
96148: PUSH
96149: EMPTY
96150: LIST
96151: LIST
96152: PUSH
96153: LD_INT 1
96155: NEG
96156: PUSH
96157: LD_INT 4
96159: NEG
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: PUSH
96165: LD_INT 1
96167: NEG
96168: PUSH
96169: LD_INT 5
96171: NEG
96172: PUSH
96173: EMPTY
96174: LIST
96175: LIST
96176: PUSH
96177: LD_INT 2
96179: PUSH
96180: LD_INT 3
96182: NEG
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: PUSH
96188: LD_INT 2
96190: NEG
96191: PUSH
96192: LD_INT 5
96194: NEG
96195: PUSH
96196: EMPTY
96197: LIST
96198: LIST
96199: PUSH
96200: LD_INT 3
96202: PUSH
96203: LD_INT 0
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: LD_INT 3
96212: PUSH
96213: LD_INT 1
96215: NEG
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PUSH
96221: LD_INT 4
96223: PUSH
96224: LD_INT 0
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: LD_INT 4
96233: PUSH
96234: LD_INT 1
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: LD_INT 3
96243: PUSH
96244: LD_INT 1
96246: PUSH
96247: EMPTY
96248: LIST
96249: LIST
96250: PUSH
96251: LD_INT 2
96253: PUSH
96254: LD_INT 0
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: PUSH
96261: LD_INT 2
96263: PUSH
96264: LD_INT 1
96266: NEG
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 2
96274: PUSH
96275: LD_INT 2
96277: NEG
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: PUSH
96283: LD_INT 4
96285: PUSH
96286: LD_INT 2
96288: PUSH
96289: EMPTY
96290: LIST
96291: LIST
96292: PUSH
96293: LD_INT 4
96295: PUSH
96296: LD_INT 4
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: PUSH
96303: LD_INT 4
96305: PUSH
96306: LD_INT 3
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: PUSH
96313: LD_INT 5
96315: PUSH
96316: LD_INT 4
96318: PUSH
96319: EMPTY
96320: LIST
96321: LIST
96322: PUSH
96323: LD_INT 5
96325: PUSH
96326: LD_INT 5
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 4
96335: PUSH
96336: LD_INT 5
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: LD_INT 3
96345: PUSH
96346: LD_INT 4
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PUSH
96353: LD_INT 3
96355: PUSH
96356: LD_INT 3
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: PUSH
96363: LD_INT 5
96365: PUSH
96366: LD_INT 3
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: PUSH
96373: LD_INT 3
96375: PUSH
96376: LD_INT 5
96378: PUSH
96379: EMPTY
96380: LIST
96381: LIST
96382: PUSH
96383: EMPTY
96384: LIST
96385: LIST
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96430: LD_ADDR_VAR 0 33
96434: PUSH
96435: LD_INT 4
96437: NEG
96438: PUSH
96439: LD_INT 4
96441: NEG
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 4
96449: NEG
96450: PUSH
96451: LD_INT 5
96453: NEG
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: LD_INT 3
96461: NEG
96462: PUSH
96463: LD_INT 4
96465: NEG
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: LD_INT 3
96477: NEG
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: LD_INT 4
96485: NEG
96486: PUSH
96487: LD_INT 3
96489: NEG
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: PUSH
96495: LD_INT 5
96497: NEG
96498: PUSH
96499: LD_INT 4
96501: NEG
96502: PUSH
96503: EMPTY
96504: LIST
96505: LIST
96506: PUSH
96507: LD_INT 5
96509: NEG
96510: PUSH
96511: LD_INT 5
96513: NEG
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 3
96521: NEG
96522: PUSH
96523: LD_INT 5
96525: NEG
96526: PUSH
96527: EMPTY
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 5
96533: NEG
96534: PUSH
96535: LD_INT 3
96537: NEG
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: PUSH
96543: LD_INT 0
96545: PUSH
96546: LD_INT 3
96548: NEG
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: PUSH
96554: LD_INT 0
96556: PUSH
96557: LD_INT 4
96559: NEG
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 1
96567: PUSH
96568: LD_INT 3
96570: NEG
96571: PUSH
96572: EMPTY
96573: LIST
96574: LIST
96575: PUSH
96576: LD_INT 1
96578: PUSH
96579: LD_INT 2
96581: NEG
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: PUSH
96587: LD_INT 0
96589: PUSH
96590: LD_INT 2
96592: NEG
96593: PUSH
96594: EMPTY
96595: LIST
96596: LIST
96597: PUSH
96598: LD_INT 1
96600: NEG
96601: PUSH
96602: LD_INT 3
96604: NEG
96605: PUSH
96606: EMPTY
96607: LIST
96608: LIST
96609: PUSH
96610: LD_INT 1
96612: NEG
96613: PUSH
96614: LD_INT 4
96616: NEG
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 2
96624: PUSH
96625: LD_INT 2
96627: NEG
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: PUSH
96633: LD_INT 2
96635: NEG
96636: PUSH
96637: LD_INT 4
96639: NEG
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 4
96647: PUSH
96648: LD_INT 0
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 4
96657: PUSH
96658: LD_INT 1
96660: NEG
96661: PUSH
96662: EMPTY
96663: LIST
96664: LIST
96665: PUSH
96666: LD_INT 5
96668: PUSH
96669: LD_INT 0
96671: PUSH
96672: EMPTY
96673: LIST
96674: LIST
96675: PUSH
96676: LD_INT 5
96678: PUSH
96679: LD_INT 1
96681: PUSH
96682: EMPTY
96683: LIST
96684: LIST
96685: PUSH
96686: LD_INT 4
96688: PUSH
96689: LD_INT 1
96691: PUSH
96692: EMPTY
96693: LIST
96694: LIST
96695: PUSH
96696: LD_INT 3
96698: PUSH
96699: LD_INT 0
96701: PUSH
96702: EMPTY
96703: LIST
96704: LIST
96705: PUSH
96706: LD_INT 3
96708: PUSH
96709: LD_INT 1
96711: NEG
96712: PUSH
96713: EMPTY
96714: LIST
96715: LIST
96716: PUSH
96717: LD_INT 3
96719: PUSH
96720: LD_INT 2
96722: NEG
96723: PUSH
96724: EMPTY
96725: LIST
96726: LIST
96727: PUSH
96728: LD_INT 5
96730: PUSH
96731: LD_INT 2
96733: PUSH
96734: EMPTY
96735: LIST
96736: LIST
96737: PUSH
96738: LD_INT 3
96740: PUSH
96741: LD_INT 3
96743: PUSH
96744: EMPTY
96745: LIST
96746: LIST
96747: PUSH
96748: LD_INT 3
96750: PUSH
96751: LD_INT 2
96753: PUSH
96754: EMPTY
96755: LIST
96756: LIST
96757: PUSH
96758: LD_INT 4
96760: PUSH
96761: LD_INT 3
96763: PUSH
96764: EMPTY
96765: LIST
96766: LIST
96767: PUSH
96768: LD_INT 4
96770: PUSH
96771: LD_INT 4
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PUSH
96778: LD_INT 3
96780: PUSH
96781: LD_INT 4
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: PUSH
96788: LD_INT 2
96790: PUSH
96791: LD_INT 3
96793: PUSH
96794: EMPTY
96795: LIST
96796: LIST
96797: PUSH
96798: LD_INT 2
96800: PUSH
96801: LD_INT 2
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: PUSH
96808: LD_INT 4
96810: PUSH
96811: LD_INT 2
96813: PUSH
96814: EMPTY
96815: LIST
96816: LIST
96817: PUSH
96818: LD_INT 2
96820: PUSH
96821: LD_INT 4
96823: PUSH
96824: EMPTY
96825: LIST
96826: LIST
96827: PUSH
96828: LD_INT 0
96830: PUSH
96831: LD_INT 4
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: PUSH
96838: LD_INT 0
96840: PUSH
96841: LD_INT 3
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PUSH
96848: LD_INT 1
96850: PUSH
96851: LD_INT 4
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: PUSH
96858: LD_INT 1
96860: PUSH
96861: LD_INT 5
96863: PUSH
96864: EMPTY
96865: LIST
96866: LIST
96867: PUSH
96868: LD_INT 0
96870: PUSH
96871: LD_INT 5
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 1
96880: NEG
96881: PUSH
96882: LD_INT 4
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PUSH
96889: LD_INT 1
96891: NEG
96892: PUSH
96893: LD_INT 3
96895: PUSH
96896: EMPTY
96897: LIST
96898: LIST
96899: PUSH
96900: LD_INT 2
96902: PUSH
96903: LD_INT 5
96905: PUSH
96906: EMPTY
96907: LIST
96908: LIST
96909: PUSH
96910: LD_INT 2
96912: NEG
96913: PUSH
96914: LD_INT 3
96916: PUSH
96917: EMPTY
96918: LIST
96919: LIST
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96968: LD_ADDR_VAR 0 34
96972: PUSH
96973: LD_INT 0
96975: PUSH
96976: LD_INT 4
96978: NEG
96979: PUSH
96980: EMPTY
96981: LIST
96982: LIST
96983: PUSH
96984: LD_INT 0
96986: PUSH
96987: LD_INT 5
96989: NEG
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: PUSH
96995: LD_INT 1
96997: PUSH
96998: LD_INT 4
97000: NEG
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: PUSH
97006: LD_INT 1
97008: PUSH
97009: LD_INT 3
97011: NEG
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 0
97019: PUSH
97020: LD_INT 3
97022: NEG
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: PUSH
97028: LD_INT 1
97030: NEG
97031: PUSH
97032: LD_INT 4
97034: NEG
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: PUSH
97040: LD_INT 1
97042: NEG
97043: PUSH
97044: LD_INT 5
97046: NEG
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: LD_INT 2
97054: PUSH
97055: LD_INT 3
97057: NEG
97058: PUSH
97059: EMPTY
97060: LIST
97061: LIST
97062: PUSH
97063: LD_INT 2
97065: NEG
97066: PUSH
97067: LD_INT 5
97069: NEG
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: PUSH
97075: LD_INT 3
97077: PUSH
97078: LD_INT 0
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: PUSH
97085: LD_INT 3
97087: PUSH
97088: LD_INT 1
97090: NEG
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: LD_INT 4
97098: PUSH
97099: LD_INT 0
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PUSH
97106: LD_INT 4
97108: PUSH
97109: LD_INT 1
97111: PUSH
97112: EMPTY
97113: LIST
97114: LIST
97115: PUSH
97116: LD_INT 3
97118: PUSH
97119: LD_INT 1
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: PUSH
97126: LD_INT 2
97128: PUSH
97129: LD_INT 0
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: LD_INT 2
97138: PUSH
97139: LD_INT 1
97141: NEG
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 2
97149: PUSH
97150: LD_INT 2
97152: NEG
97153: PUSH
97154: EMPTY
97155: LIST
97156: LIST
97157: PUSH
97158: LD_INT 4
97160: PUSH
97161: LD_INT 2
97163: PUSH
97164: EMPTY
97165: LIST
97166: LIST
97167: PUSH
97168: LD_INT 4
97170: PUSH
97171: LD_INT 4
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: PUSH
97178: LD_INT 4
97180: PUSH
97181: LD_INT 3
97183: PUSH
97184: EMPTY
97185: LIST
97186: LIST
97187: PUSH
97188: LD_INT 5
97190: PUSH
97191: LD_INT 4
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PUSH
97198: LD_INT 5
97200: PUSH
97201: LD_INT 5
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: PUSH
97208: LD_INT 4
97210: PUSH
97211: LD_INT 5
97213: PUSH
97214: EMPTY
97215: LIST
97216: LIST
97217: PUSH
97218: LD_INT 3
97220: PUSH
97221: LD_INT 4
97223: PUSH
97224: EMPTY
97225: LIST
97226: LIST
97227: PUSH
97228: LD_INT 3
97230: PUSH
97231: LD_INT 3
97233: PUSH
97234: EMPTY
97235: LIST
97236: LIST
97237: PUSH
97238: LD_INT 5
97240: PUSH
97241: LD_INT 3
97243: PUSH
97244: EMPTY
97245: LIST
97246: LIST
97247: PUSH
97248: LD_INT 3
97250: PUSH
97251: LD_INT 5
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PUSH
97258: LD_INT 0
97260: PUSH
97261: LD_INT 3
97263: PUSH
97264: EMPTY
97265: LIST
97266: LIST
97267: PUSH
97268: LD_INT 0
97270: PUSH
97271: LD_INT 2
97273: PUSH
97274: EMPTY
97275: LIST
97276: LIST
97277: PUSH
97278: LD_INT 1
97280: PUSH
97281: LD_INT 3
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: PUSH
97288: LD_INT 1
97290: PUSH
97291: LD_INT 4
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: PUSH
97298: LD_INT 0
97300: PUSH
97301: LD_INT 4
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: PUSH
97308: LD_INT 1
97310: NEG
97311: PUSH
97312: LD_INT 3
97314: PUSH
97315: EMPTY
97316: LIST
97317: LIST
97318: PUSH
97319: LD_INT 1
97321: NEG
97322: PUSH
97323: LD_INT 2
97325: PUSH
97326: EMPTY
97327: LIST
97328: LIST
97329: PUSH
97330: LD_INT 2
97332: PUSH
97333: LD_INT 4
97335: PUSH
97336: EMPTY
97337: LIST
97338: LIST
97339: PUSH
97340: LD_INT 2
97342: NEG
97343: PUSH
97344: LD_INT 2
97346: PUSH
97347: EMPTY
97348: LIST
97349: LIST
97350: PUSH
97351: LD_INT 4
97353: NEG
97354: PUSH
97355: LD_INT 0
97357: PUSH
97358: EMPTY
97359: LIST
97360: LIST
97361: PUSH
97362: LD_INT 4
97364: NEG
97365: PUSH
97366: LD_INT 1
97368: NEG
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: LD_INT 3
97376: NEG
97377: PUSH
97378: LD_INT 0
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: PUSH
97385: LD_INT 3
97387: NEG
97388: PUSH
97389: LD_INT 1
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: LD_INT 4
97398: NEG
97399: PUSH
97400: LD_INT 1
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 5
97409: NEG
97410: PUSH
97411: LD_INT 0
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 5
97420: NEG
97421: PUSH
97422: LD_INT 1
97424: NEG
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: PUSH
97430: LD_INT 5
97432: NEG
97433: PUSH
97434: LD_INT 2
97436: NEG
97437: PUSH
97438: EMPTY
97439: LIST
97440: LIST
97441: PUSH
97442: LD_INT 3
97444: NEG
97445: PUSH
97446: LD_INT 2
97448: PUSH
97449: EMPTY
97450: LIST
97451: LIST
97452: PUSH
97453: EMPTY
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: ST_TO_ADDR
// end ; end ;
97500: GO 97503
97502: POP
// case btype of b_depot , b_warehouse :
97503: LD_VAR 0 1
97507: PUSH
97508: LD_INT 0
97510: DOUBLE
97511: EQUAL
97512: IFTRUE 97522
97514: LD_INT 1
97516: DOUBLE
97517: EQUAL
97518: IFTRUE 97522
97520: GO 97723
97522: POP
// case nation of nation_american :
97523: LD_VAR 0 5
97527: PUSH
97528: LD_INT 1
97530: DOUBLE
97531: EQUAL
97532: IFTRUE 97536
97534: GO 97592
97536: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97537: LD_ADDR_VAR 0 9
97541: PUSH
97542: LD_VAR 0 11
97546: PUSH
97547: LD_VAR 0 12
97551: PUSH
97552: LD_VAR 0 13
97556: PUSH
97557: LD_VAR 0 14
97561: PUSH
97562: LD_VAR 0 15
97566: PUSH
97567: LD_VAR 0 16
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: PUSH
97580: LD_VAR 0 4
97584: PUSH
97585: LD_INT 1
97587: PLUS
97588: ARRAY
97589: ST_TO_ADDR
97590: GO 97721
97592: LD_INT 2
97594: DOUBLE
97595: EQUAL
97596: IFTRUE 97600
97598: GO 97656
97600: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97601: LD_ADDR_VAR 0 9
97605: PUSH
97606: LD_VAR 0 17
97610: PUSH
97611: LD_VAR 0 18
97615: PUSH
97616: LD_VAR 0 19
97620: PUSH
97621: LD_VAR 0 20
97625: PUSH
97626: LD_VAR 0 21
97630: PUSH
97631: LD_VAR 0 22
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: PUSH
97644: LD_VAR 0 4
97648: PUSH
97649: LD_INT 1
97651: PLUS
97652: ARRAY
97653: ST_TO_ADDR
97654: GO 97721
97656: LD_INT 3
97658: DOUBLE
97659: EQUAL
97660: IFTRUE 97664
97662: GO 97720
97664: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97665: LD_ADDR_VAR 0 9
97669: PUSH
97670: LD_VAR 0 23
97674: PUSH
97675: LD_VAR 0 24
97679: PUSH
97680: LD_VAR 0 25
97684: PUSH
97685: LD_VAR 0 26
97689: PUSH
97690: LD_VAR 0 27
97694: PUSH
97695: LD_VAR 0 28
97699: PUSH
97700: EMPTY
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: PUSH
97708: LD_VAR 0 4
97712: PUSH
97713: LD_INT 1
97715: PLUS
97716: ARRAY
97717: ST_TO_ADDR
97718: GO 97721
97720: POP
97721: GO 98276
97723: LD_INT 2
97725: DOUBLE
97726: EQUAL
97727: IFTRUE 97737
97729: LD_INT 3
97731: DOUBLE
97732: EQUAL
97733: IFTRUE 97737
97735: GO 97793
97737: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97738: LD_ADDR_VAR 0 9
97742: PUSH
97743: LD_VAR 0 29
97747: PUSH
97748: LD_VAR 0 30
97752: PUSH
97753: LD_VAR 0 31
97757: PUSH
97758: LD_VAR 0 32
97762: PUSH
97763: LD_VAR 0 33
97767: PUSH
97768: LD_VAR 0 34
97772: PUSH
97773: EMPTY
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: PUSH
97781: LD_VAR 0 4
97785: PUSH
97786: LD_INT 1
97788: PLUS
97789: ARRAY
97790: ST_TO_ADDR
97791: GO 98276
97793: LD_INT 16
97795: DOUBLE
97796: EQUAL
97797: IFTRUE 97855
97799: LD_INT 17
97801: DOUBLE
97802: EQUAL
97803: IFTRUE 97855
97805: LD_INT 18
97807: DOUBLE
97808: EQUAL
97809: IFTRUE 97855
97811: LD_INT 19
97813: DOUBLE
97814: EQUAL
97815: IFTRUE 97855
97817: LD_INT 22
97819: DOUBLE
97820: EQUAL
97821: IFTRUE 97855
97823: LD_INT 20
97825: DOUBLE
97826: EQUAL
97827: IFTRUE 97855
97829: LD_INT 21
97831: DOUBLE
97832: EQUAL
97833: IFTRUE 97855
97835: LD_INT 23
97837: DOUBLE
97838: EQUAL
97839: IFTRUE 97855
97841: LD_INT 24
97843: DOUBLE
97844: EQUAL
97845: IFTRUE 97855
97847: LD_INT 25
97849: DOUBLE
97850: EQUAL
97851: IFTRUE 97855
97853: GO 97911
97855: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97856: LD_ADDR_VAR 0 9
97860: PUSH
97861: LD_VAR 0 35
97865: PUSH
97866: LD_VAR 0 36
97870: PUSH
97871: LD_VAR 0 37
97875: PUSH
97876: LD_VAR 0 38
97880: PUSH
97881: LD_VAR 0 39
97885: PUSH
97886: LD_VAR 0 40
97890: PUSH
97891: EMPTY
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: PUSH
97899: LD_VAR 0 4
97903: PUSH
97904: LD_INT 1
97906: PLUS
97907: ARRAY
97908: ST_TO_ADDR
97909: GO 98276
97911: LD_INT 6
97913: DOUBLE
97914: EQUAL
97915: IFTRUE 97967
97917: LD_INT 7
97919: DOUBLE
97920: EQUAL
97921: IFTRUE 97967
97923: LD_INT 8
97925: DOUBLE
97926: EQUAL
97927: IFTRUE 97967
97929: LD_INT 13
97931: DOUBLE
97932: EQUAL
97933: IFTRUE 97967
97935: LD_INT 12
97937: DOUBLE
97938: EQUAL
97939: IFTRUE 97967
97941: LD_INT 15
97943: DOUBLE
97944: EQUAL
97945: IFTRUE 97967
97947: LD_INT 11
97949: DOUBLE
97950: EQUAL
97951: IFTRUE 97967
97953: LD_INT 14
97955: DOUBLE
97956: EQUAL
97957: IFTRUE 97967
97959: LD_INT 10
97961: DOUBLE
97962: EQUAL
97963: IFTRUE 97967
97965: GO 98023
97967: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
97968: LD_ADDR_VAR 0 9
97972: PUSH
97973: LD_VAR 0 41
97977: PUSH
97978: LD_VAR 0 42
97982: PUSH
97983: LD_VAR 0 43
97987: PUSH
97988: LD_VAR 0 44
97992: PUSH
97993: LD_VAR 0 45
97997: PUSH
97998: LD_VAR 0 46
98002: PUSH
98003: EMPTY
98004: LIST
98005: LIST
98006: LIST
98007: LIST
98008: LIST
98009: LIST
98010: PUSH
98011: LD_VAR 0 4
98015: PUSH
98016: LD_INT 1
98018: PLUS
98019: ARRAY
98020: ST_TO_ADDR
98021: GO 98276
98023: LD_INT 36
98025: DOUBLE
98026: EQUAL
98027: IFTRUE 98031
98029: GO 98087
98031: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98032: LD_ADDR_VAR 0 9
98036: PUSH
98037: LD_VAR 0 47
98041: PUSH
98042: LD_VAR 0 48
98046: PUSH
98047: LD_VAR 0 49
98051: PUSH
98052: LD_VAR 0 50
98056: PUSH
98057: LD_VAR 0 51
98061: PUSH
98062: LD_VAR 0 52
98066: PUSH
98067: EMPTY
98068: LIST
98069: LIST
98070: LIST
98071: LIST
98072: LIST
98073: LIST
98074: PUSH
98075: LD_VAR 0 4
98079: PUSH
98080: LD_INT 1
98082: PLUS
98083: ARRAY
98084: ST_TO_ADDR
98085: GO 98276
98087: LD_INT 4
98089: DOUBLE
98090: EQUAL
98091: IFTRUE 98113
98093: LD_INT 5
98095: DOUBLE
98096: EQUAL
98097: IFTRUE 98113
98099: LD_INT 34
98101: DOUBLE
98102: EQUAL
98103: IFTRUE 98113
98105: LD_INT 37
98107: DOUBLE
98108: EQUAL
98109: IFTRUE 98113
98111: GO 98169
98113: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98114: LD_ADDR_VAR 0 9
98118: PUSH
98119: LD_VAR 0 53
98123: PUSH
98124: LD_VAR 0 54
98128: PUSH
98129: LD_VAR 0 55
98133: PUSH
98134: LD_VAR 0 56
98138: PUSH
98139: LD_VAR 0 57
98143: PUSH
98144: LD_VAR 0 58
98148: PUSH
98149: EMPTY
98150: LIST
98151: LIST
98152: LIST
98153: LIST
98154: LIST
98155: LIST
98156: PUSH
98157: LD_VAR 0 4
98161: PUSH
98162: LD_INT 1
98164: PLUS
98165: ARRAY
98166: ST_TO_ADDR
98167: GO 98276
98169: LD_INT 31
98171: DOUBLE
98172: EQUAL
98173: IFTRUE 98219
98175: LD_INT 32
98177: DOUBLE
98178: EQUAL
98179: IFTRUE 98219
98181: LD_INT 33
98183: DOUBLE
98184: EQUAL
98185: IFTRUE 98219
98187: LD_INT 27
98189: DOUBLE
98190: EQUAL
98191: IFTRUE 98219
98193: LD_INT 26
98195: DOUBLE
98196: EQUAL
98197: IFTRUE 98219
98199: LD_INT 28
98201: DOUBLE
98202: EQUAL
98203: IFTRUE 98219
98205: LD_INT 29
98207: DOUBLE
98208: EQUAL
98209: IFTRUE 98219
98211: LD_INT 30
98213: DOUBLE
98214: EQUAL
98215: IFTRUE 98219
98217: GO 98275
98219: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
98220: LD_ADDR_VAR 0 9
98224: PUSH
98225: LD_VAR 0 59
98229: PUSH
98230: LD_VAR 0 60
98234: PUSH
98235: LD_VAR 0 61
98239: PUSH
98240: LD_VAR 0 62
98244: PUSH
98245: LD_VAR 0 63
98249: PUSH
98250: LD_VAR 0 64
98254: PUSH
98255: EMPTY
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: PUSH
98263: LD_VAR 0 4
98267: PUSH
98268: LD_INT 1
98270: PLUS
98271: ARRAY
98272: ST_TO_ADDR
98273: GO 98276
98275: POP
// temp_list2 = [ ] ;
98276: LD_ADDR_VAR 0 10
98280: PUSH
98281: EMPTY
98282: ST_TO_ADDR
// for i in temp_list do
98283: LD_ADDR_VAR 0 8
98287: PUSH
98288: LD_VAR 0 9
98292: PUSH
98293: FOR_IN
98294: IFFALSE 98346
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98296: LD_ADDR_VAR 0 10
98300: PUSH
98301: LD_VAR 0 10
98305: PUSH
98306: LD_VAR 0 8
98310: PUSH
98311: LD_INT 1
98313: ARRAY
98314: PUSH
98315: LD_VAR 0 2
98319: PLUS
98320: PUSH
98321: LD_VAR 0 8
98325: PUSH
98326: LD_INT 2
98328: ARRAY
98329: PUSH
98330: LD_VAR 0 3
98334: PLUS
98335: PUSH
98336: EMPTY
98337: LIST
98338: LIST
98339: PUSH
98340: EMPTY
98341: LIST
98342: ADD
98343: ST_TO_ADDR
98344: GO 98293
98346: POP
98347: POP
// result = temp_list2 ;
98348: LD_ADDR_VAR 0 7
98352: PUSH
98353: LD_VAR 0 10
98357: ST_TO_ADDR
// end ;
98358: LD_VAR 0 7
98362: RET
// export function EnemyInRange ( unit , dist ) ; begin
98363: LD_INT 0
98365: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98366: LD_ADDR_VAR 0 3
98370: PUSH
98371: LD_VAR 0 1
98375: PPUSH
98376: CALL_OW 255
98380: PPUSH
98381: LD_VAR 0 1
98385: PPUSH
98386: CALL_OW 250
98390: PPUSH
98391: LD_VAR 0 1
98395: PPUSH
98396: CALL_OW 251
98400: PPUSH
98401: LD_VAR 0 2
98405: PPUSH
98406: CALL 71759 0 4
98410: PUSH
98411: LD_INT 4
98413: ARRAY
98414: ST_TO_ADDR
// end ;
98415: LD_VAR 0 3
98419: RET
// export function PlayerSeeMe ( unit ) ; begin
98420: LD_INT 0
98422: PPUSH
// result := See ( your_side , unit ) ;
98423: LD_ADDR_VAR 0 2
98427: PUSH
98428: LD_OWVAR 2
98432: PPUSH
98433: LD_VAR 0 1
98437: PPUSH
98438: CALL_OW 292
98442: ST_TO_ADDR
// end ;
98443: LD_VAR 0 2
98447: RET
// export function ReverseDir ( unit ) ; begin
98448: LD_INT 0
98450: PPUSH
// if not unit then
98451: LD_VAR 0 1
98455: NOT
98456: IFFALSE 98460
// exit ;
98458: GO 98483
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98460: LD_ADDR_VAR 0 2
98464: PUSH
98465: LD_VAR 0 1
98469: PPUSH
98470: CALL_OW 254
98474: PUSH
98475: LD_INT 3
98477: PLUS
98478: PUSH
98479: LD_INT 6
98481: MOD
98482: ST_TO_ADDR
// end ;
98483: LD_VAR 0 2
98487: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98488: LD_INT 0
98490: PPUSH
98491: PPUSH
98492: PPUSH
98493: PPUSH
98494: PPUSH
// if not hexes then
98495: LD_VAR 0 2
98499: NOT
98500: IFFALSE 98504
// exit ;
98502: GO 98652
// dist := 9999 ;
98504: LD_ADDR_VAR 0 5
98508: PUSH
98509: LD_INT 9999
98511: ST_TO_ADDR
// for i = 1 to hexes do
98512: LD_ADDR_VAR 0 4
98516: PUSH
98517: DOUBLE
98518: LD_INT 1
98520: DEC
98521: ST_TO_ADDR
98522: LD_VAR 0 2
98526: PUSH
98527: FOR_TO
98528: IFFALSE 98640
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98530: LD_VAR 0 1
98534: PPUSH
98535: LD_VAR 0 2
98539: PUSH
98540: LD_VAR 0 4
98544: ARRAY
98545: PUSH
98546: LD_INT 1
98548: ARRAY
98549: PPUSH
98550: LD_VAR 0 2
98554: PUSH
98555: LD_VAR 0 4
98559: ARRAY
98560: PUSH
98561: LD_INT 2
98563: ARRAY
98564: PPUSH
98565: CALL_OW 297
98569: PUSH
98570: LD_VAR 0 5
98574: LESS
98575: IFFALSE 98638
// begin hex := hexes [ i ] ;
98577: LD_ADDR_VAR 0 7
98581: PUSH
98582: LD_VAR 0 2
98586: PUSH
98587: LD_VAR 0 4
98591: ARRAY
98592: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98593: LD_ADDR_VAR 0 5
98597: PUSH
98598: LD_VAR 0 1
98602: PPUSH
98603: LD_VAR 0 2
98607: PUSH
98608: LD_VAR 0 4
98612: ARRAY
98613: PUSH
98614: LD_INT 1
98616: ARRAY
98617: PPUSH
98618: LD_VAR 0 2
98622: PUSH
98623: LD_VAR 0 4
98627: ARRAY
98628: PUSH
98629: LD_INT 2
98631: ARRAY
98632: PPUSH
98633: CALL_OW 297
98637: ST_TO_ADDR
// end ; end ;
98638: GO 98527
98640: POP
98641: POP
// result := hex ;
98642: LD_ADDR_VAR 0 3
98646: PUSH
98647: LD_VAR 0 7
98651: ST_TO_ADDR
// end ;
98652: LD_VAR 0 3
98656: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98657: LD_INT 0
98659: PPUSH
98660: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98661: LD_VAR 0 1
98665: NOT
98666: PUSH
98667: LD_VAR 0 1
98671: PUSH
98672: LD_INT 21
98674: PUSH
98675: LD_INT 2
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: PUSH
98682: LD_INT 23
98684: PUSH
98685: LD_INT 2
98687: PUSH
98688: EMPTY
98689: LIST
98690: LIST
98691: PUSH
98692: EMPTY
98693: LIST
98694: LIST
98695: PPUSH
98696: CALL_OW 69
98700: IN
98701: NOT
98702: OR
98703: IFFALSE 98707
// exit ;
98705: GO 98754
// for i = 1 to 3 do
98707: LD_ADDR_VAR 0 3
98711: PUSH
98712: DOUBLE
98713: LD_INT 1
98715: DEC
98716: ST_TO_ADDR
98717: LD_INT 3
98719: PUSH
98720: FOR_TO
98721: IFFALSE 98752
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98723: LD_VAR 0 1
98727: PPUSH
98728: CALL_OW 250
98732: PPUSH
98733: LD_VAR 0 1
98737: PPUSH
98738: CALL_OW 251
98742: PPUSH
98743: LD_INT 1
98745: PPUSH
98746: CALL_OW 453
98750: GO 98720
98752: POP
98753: POP
// end ;
98754: LD_VAR 0 2
98758: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98759: LD_INT 0
98761: PPUSH
98762: PPUSH
98763: PPUSH
98764: PPUSH
98765: PPUSH
98766: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98767: LD_VAR 0 1
98771: NOT
98772: PUSH
98773: LD_VAR 0 2
98777: NOT
98778: OR
98779: PUSH
98780: LD_VAR 0 1
98784: PPUSH
98785: CALL_OW 314
98789: OR
98790: IFFALSE 98794
// exit ;
98792: GO 99235
// x := GetX ( enemy_unit ) ;
98794: LD_ADDR_VAR 0 7
98798: PUSH
98799: LD_VAR 0 2
98803: PPUSH
98804: CALL_OW 250
98808: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98809: LD_ADDR_VAR 0 8
98813: PUSH
98814: LD_VAR 0 2
98818: PPUSH
98819: CALL_OW 251
98823: ST_TO_ADDR
// if not x or not y then
98824: LD_VAR 0 7
98828: NOT
98829: PUSH
98830: LD_VAR 0 8
98834: NOT
98835: OR
98836: IFFALSE 98840
// exit ;
98838: GO 99235
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98840: LD_ADDR_VAR 0 6
98844: PUSH
98845: LD_VAR 0 7
98849: PPUSH
98850: LD_INT 0
98852: PPUSH
98853: LD_INT 4
98855: PPUSH
98856: CALL_OW 272
98860: PUSH
98861: LD_VAR 0 8
98865: PPUSH
98866: LD_INT 0
98868: PPUSH
98869: LD_INT 4
98871: PPUSH
98872: CALL_OW 273
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: PUSH
98881: LD_VAR 0 7
98885: PPUSH
98886: LD_INT 1
98888: PPUSH
98889: LD_INT 4
98891: PPUSH
98892: CALL_OW 272
98896: PUSH
98897: LD_VAR 0 8
98901: PPUSH
98902: LD_INT 1
98904: PPUSH
98905: LD_INT 4
98907: PPUSH
98908: CALL_OW 273
98912: PUSH
98913: EMPTY
98914: LIST
98915: LIST
98916: PUSH
98917: LD_VAR 0 7
98921: PPUSH
98922: LD_INT 2
98924: PPUSH
98925: LD_INT 4
98927: PPUSH
98928: CALL_OW 272
98932: PUSH
98933: LD_VAR 0 8
98937: PPUSH
98938: LD_INT 2
98940: PPUSH
98941: LD_INT 4
98943: PPUSH
98944: CALL_OW 273
98948: PUSH
98949: EMPTY
98950: LIST
98951: LIST
98952: PUSH
98953: LD_VAR 0 7
98957: PPUSH
98958: LD_INT 3
98960: PPUSH
98961: LD_INT 4
98963: PPUSH
98964: CALL_OW 272
98968: PUSH
98969: LD_VAR 0 8
98973: PPUSH
98974: LD_INT 3
98976: PPUSH
98977: LD_INT 4
98979: PPUSH
98980: CALL_OW 273
98984: PUSH
98985: EMPTY
98986: LIST
98987: LIST
98988: PUSH
98989: LD_VAR 0 7
98993: PPUSH
98994: LD_INT 4
98996: PPUSH
98997: LD_INT 4
98999: PPUSH
99000: CALL_OW 272
99004: PUSH
99005: LD_VAR 0 8
99009: PPUSH
99010: LD_INT 4
99012: PPUSH
99013: LD_INT 4
99015: PPUSH
99016: CALL_OW 273
99020: PUSH
99021: EMPTY
99022: LIST
99023: LIST
99024: PUSH
99025: LD_VAR 0 7
99029: PPUSH
99030: LD_INT 5
99032: PPUSH
99033: LD_INT 4
99035: PPUSH
99036: CALL_OW 272
99040: PUSH
99041: LD_VAR 0 8
99045: PPUSH
99046: LD_INT 5
99048: PPUSH
99049: LD_INT 4
99051: PPUSH
99052: CALL_OW 273
99056: PUSH
99057: EMPTY
99058: LIST
99059: LIST
99060: PUSH
99061: EMPTY
99062: LIST
99063: LIST
99064: LIST
99065: LIST
99066: LIST
99067: LIST
99068: ST_TO_ADDR
// for i = tmp downto 1 do
99069: LD_ADDR_VAR 0 4
99073: PUSH
99074: DOUBLE
99075: LD_VAR 0 6
99079: INC
99080: ST_TO_ADDR
99081: LD_INT 1
99083: PUSH
99084: FOR_DOWNTO
99085: IFFALSE 99186
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99087: LD_VAR 0 6
99091: PUSH
99092: LD_VAR 0 4
99096: ARRAY
99097: PUSH
99098: LD_INT 1
99100: ARRAY
99101: PPUSH
99102: LD_VAR 0 6
99106: PUSH
99107: LD_VAR 0 4
99111: ARRAY
99112: PUSH
99113: LD_INT 2
99115: ARRAY
99116: PPUSH
99117: CALL_OW 488
99121: NOT
99122: PUSH
99123: LD_VAR 0 6
99127: PUSH
99128: LD_VAR 0 4
99132: ARRAY
99133: PUSH
99134: LD_INT 1
99136: ARRAY
99137: PPUSH
99138: LD_VAR 0 6
99142: PUSH
99143: LD_VAR 0 4
99147: ARRAY
99148: PUSH
99149: LD_INT 2
99151: ARRAY
99152: PPUSH
99153: CALL_OW 428
99157: PUSH
99158: LD_INT 0
99160: NONEQUAL
99161: OR
99162: IFFALSE 99184
// tmp := Delete ( tmp , i ) ;
99164: LD_ADDR_VAR 0 6
99168: PUSH
99169: LD_VAR 0 6
99173: PPUSH
99174: LD_VAR 0 4
99178: PPUSH
99179: CALL_OW 3
99183: ST_TO_ADDR
99184: GO 99084
99186: POP
99187: POP
// j := GetClosestHex ( unit , tmp ) ;
99188: LD_ADDR_VAR 0 5
99192: PUSH
99193: LD_VAR 0 1
99197: PPUSH
99198: LD_VAR 0 6
99202: PPUSH
99203: CALL 98488 0 2
99207: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99208: LD_VAR 0 1
99212: PPUSH
99213: LD_VAR 0 5
99217: PUSH
99218: LD_INT 1
99220: ARRAY
99221: PPUSH
99222: LD_VAR 0 5
99226: PUSH
99227: LD_INT 2
99229: ARRAY
99230: PPUSH
99231: CALL_OW 111
// end ;
99235: LD_VAR 0 3
99239: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99240: LD_INT 0
99242: PPUSH
99243: PPUSH
99244: PPUSH
// uc_side = 0 ;
99245: LD_ADDR_OWVAR 20
99249: PUSH
99250: LD_INT 0
99252: ST_TO_ADDR
// uc_nation = 0 ;
99253: LD_ADDR_OWVAR 21
99257: PUSH
99258: LD_INT 0
99260: ST_TO_ADDR
// InitHc_All ( ) ;
99261: CALL_OW 584
// InitVc ;
99265: CALL_OW 20
// if mastodonts then
99269: LD_VAR 0 6
99273: IFFALSE 99340
// for i = 1 to mastodonts do
99275: LD_ADDR_VAR 0 11
99279: PUSH
99280: DOUBLE
99281: LD_INT 1
99283: DEC
99284: ST_TO_ADDR
99285: LD_VAR 0 6
99289: PUSH
99290: FOR_TO
99291: IFFALSE 99338
// begin vc_chassis := 31 ;
99293: LD_ADDR_OWVAR 37
99297: PUSH
99298: LD_INT 31
99300: ST_TO_ADDR
// vc_control := control_rider ;
99301: LD_ADDR_OWVAR 38
99305: PUSH
99306: LD_INT 4
99308: ST_TO_ADDR
// animal := CreateVehicle ;
99309: LD_ADDR_VAR 0 12
99313: PUSH
99314: CALL_OW 45
99318: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99319: LD_VAR 0 12
99323: PPUSH
99324: LD_VAR 0 8
99328: PPUSH
99329: LD_INT 0
99331: PPUSH
99332: CALL 101528 0 3
// end ;
99336: GO 99290
99338: POP
99339: POP
// if horses then
99340: LD_VAR 0 5
99344: IFFALSE 99411
// for i = 1 to horses do
99346: LD_ADDR_VAR 0 11
99350: PUSH
99351: DOUBLE
99352: LD_INT 1
99354: DEC
99355: ST_TO_ADDR
99356: LD_VAR 0 5
99360: PUSH
99361: FOR_TO
99362: IFFALSE 99409
// begin hc_class := 21 ;
99364: LD_ADDR_OWVAR 28
99368: PUSH
99369: LD_INT 21
99371: ST_TO_ADDR
// hc_gallery :=  ;
99372: LD_ADDR_OWVAR 33
99376: PUSH
99377: LD_STRING 
99379: ST_TO_ADDR
// animal := CreateHuman ;
99380: LD_ADDR_VAR 0 12
99384: PUSH
99385: CALL_OW 44
99389: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99390: LD_VAR 0 12
99394: PPUSH
99395: LD_VAR 0 8
99399: PPUSH
99400: LD_INT 0
99402: PPUSH
99403: CALL 101528 0 3
// end ;
99407: GO 99361
99409: POP
99410: POP
// if birds then
99411: LD_VAR 0 1
99415: IFFALSE 99482
// for i = 1 to birds do
99417: LD_ADDR_VAR 0 11
99421: PUSH
99422: DOUBLE
99423: LD_INT 1
99425: DEC
99426: ST_TO_ADDR
99427: LD_VAR 0 1
99431: PUSH
99432: FOR_TO
99433: IFFALSE 99480
// begin hc_class = 18 ;
99435: LD_ADDR_OWVAR 28
99439: PUSH
99440: LD_INT 18
99442: ST_TO_ADDR
// hc_gallery =  ;
99443: LD_ADDR_OWVAR 33
99447: PUSH
99448: LD_STRING 
99450: ST_TO_ADDR
// animal := CreateHuman ;
99451: LD_ADDR_VAR 0 12
99455: PUSH
99456: CALL_OW 44
99460: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99461: LD_VAR 0 12
99465: PPUSH
99466: LD_VAR 0 8
99470: PPUSH
99471: LD_INT 0
99473: PPUSH
99474: CALL 101528 0 3
// end ;
99478: GO 99432
99480: POP
99481: POP
// if tigers then
99482: LD_VAR 0 2
99486: IFFALSE 99570
// for i = 1 to tigers do
99488: LD_ADDR_VAR 0 11
99492: PUSH
99493: DOUBLE
99494: LD_INT 1
99496: DEC
99497: ST_TO_ADDR
99498: LD_VAR 0 2
99502: PUSH
99503: FOR_TO
99504: IFFALSE 99568
// begin hc_class = class_tiger ;
99506: LD_ADDR_OWVAR 28
99510: PUSH
99511: LD_INT 14
99513: ST_TO_ADDR
// hc_gallery =  ;
99514: LD_ADDR_OWVAR 33
99518: PUSH
99519: LD_STRING 
99521: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99522: LD_ADDR_OWVAR 35
99526: PUSH
99527: LD_INT 7
99529: NEG
99530: PPUSH
99531: LD_INT 7
99533: PPUSH
99534: CALL_OW 12
99538: ST_TO_ADDR
// animal := CreateHuman ;
99539: LD_ADDR_VAR 0 12
99543: PUSH
99544: CALL_OW 44
99548: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99549: LD_VAR 0 12
99553: PPUSH
99554: LD_VAR 0 8
99558: PPUSH
99559: LD_INT 0
99561: PPUSH
99562: CALL 101528 0 3
// end ;
99566: GO 99503
99568: POP
99569: POP
// if apemans then
99570: LD_VAR 0 3
99574: IFFALSE 99697
// for i = 1 to apemans do
99576: LD_ADDR_VAR 0 11
99580: PUSH
99581: DOUBLE
99582: LD_INT 1
99584: DEC
99585: ST_TO_ADDR
99586: LD_VAR 0 3
99590: PUSH
99591: FOR_TO
99592: IFFALSE 99695
// begin hc_class = class_apeman ;
99594: LD_ADDR_OWVAR 28
99598: PUSH
99599: LD_INT 12
99601: ST_TO_ADDR
// hc_gallery =  ;
99602: LD_ADDR_OWVAR 33
99606: PUSH
99607: LD_STRING 
99609: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
99610: LD_ADDR_OWVAR 35
99614: PUSH
99615: LD_INT 2
99617: NEG
99618: PPUSH
99619: LD_INT 2
99621: PPUSH
99622: CALL_OW 12
99626: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99627: LD_ADDR_OWVAR 31
99631: PUSH
99632: LD_INT 1
99634: PPUSH
99635: LD_INT 3
99637: PPUSH
99638: CALL_OW 12
99642: PUSH
99643: LD_INT 1
99645: PPUSH
99646: LD_INT 3
99648: PPUSH
99649: CALL_OW 12
99653: PUSH
99654: LD_INT 0
99656: PUSH
99657: LD_INT 0
99659: PUSH
99660: EMPTY
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: ST_TO_ADDR
// animal := CreateHuman ;
99666: LD_ADDR_VAR 0 12
99670: PUSH
99671: CALL_OW 44
99675: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99676: LD_VAR 0 12
99680: PPUSH
99681: LD_VAR 0 8
99685: PPUSH
99686: LD_INT 0
99688: PPUSH
99689: CALL 101528 0 3
// end ;
99693: GO 99591
99695: POP
99696: POP
// if enchidnas then
99697: LD_VAR 0 4
99701: IFFALSE 99768
// for i = 1 to enchidnas do
99703: LD_ADDR_VAR 0 11
99707: PUSH
99708: DOUBLE
99709: LD_INT 1
99711: DEC
99712: ST_TO_ADDR
99713: LD_VAR 0 4
99717: PUSH
99718: FOR_TO
99719: IFFALSE 99766
// begin hc_class = 13 ;
99721: LD_ADDR_OWVAR 28
99725: PUSH
99726: LD_INT 13
99728: ST_TO_ADDR
// hc_gallery =  ;
99729: LD_ADDR_OWVAR 33
99733: PUSH
99734: LD_STRING 
99736: ST_TO_ADDR
// animal := CreateHuman ;
99737: LD_ADDR_VAR 0 12
99741: PUSH
99742: CALL_OW 44
99746: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99747: LD_VAR 0 12
99751: PPUSH
99752: LD_VAR 0 8
99756: PPUSH
99757: LD_INT 0
99759: PPUSH
99760: CALL 101528 0 3
// end ;
99764: GO 99718
99766: POP
99767: POP
// if fishes then
99768: LD_VAR 0 7
99772: IFFALSE 99839
// for i = 1 to fishes do
99774: LD_ADDR_VAR 0 11
99778: PUSH
99779: DOUBLE
99780: LD_INT 1
99782: DEC
99783: ST_TO_ADDR
99784: LD_VAR 0 7
99788: PUSH
99789: FOR_TO
99790: IFFALSE 99837
// begin hc_class = 20 ;
99792: LD_ADDR_OWVAR 28
99796: PUSH
99797: LD_INT 20
99799: ST_TO_ADDR
// hc_gallery =  ;
99800: LD_ADDR_OWVAR 33
99804: PUSH
99805: LD_STRING 
99807: ST_TO_ADDR
// animal := CreateHuman ;
99808: LD_ADDR_VAR 0 12
99812: PUSH
99813: CALL_OW 44
99817: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99818: LD_VAR 0 12
99822: PPUSH
99823: LD_VAR 0 9
99827: PPUSH
99828: LD_INT 0
99830: PPUSH
99831: CALL 101528 0 3
// end ;
99835: GO 99789
99837: POP
99838: POP
// end ;
99839: LD_VAR 0 10
99843: RET
// export function WantHeal ( sci , unit ) ; begin
99844: LD_INT 0
99846: PPUSH
// if GetTaskList ( sci ) > 0 then
99847: LD_VAR 0 1
99851: PPUSH
99852: CALL_OW 437
99856: PUSH
99857: LD_INT 0
99859: GREATER
99860: IFFALSE 99930
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99862: LD_VAR 0 1
99866: PPUSH
99867: CALL_OW 437
99871: PUSH
99872: LD_INT 1
99874: ARRAY
99875: PUSH
99876: LD_INT 1
99878: ARRAY
99879: PUSH
99880: LD_STRING l
99882: EQUAL
99883: PUSH
99884: LD_VAR 0 1
99888: PPUSH
99889: CALL_OW 437
99893: PUSH
99894: LD_INT 1
99896: ARRAY
99897: PUSH
99898: LD_INT 4
99900: ARRAY
99901: PUSH
99902: LD_VAR 0 2
99906: EQUAL
99907: AND
99908: IFFALSE 99920
// result := true else
99910: LD_ADDR_VAR 0 3
99914: PUSH
99915: LD_INT 1
99917: ST_TO_ADDR
99918: GO 99928
// result := false ;
99920: LD_ADDR_VAR 0 3
99924: PUSH
99925: LD_INT 0
99927: ST_TO_ADDR
// end else
99928: GO 99938
// result := false ;
99930: LD_ADDR_VAR 0 3
99934: PUSH
99935: LD_INT 0
99937: ST_TO_ADDR
// end ;
99938: LD_VAR 0 3
99942: RET
// export function HealTarget ( sci ) ; begin
99943: LD_INT 0
99945: PPUSH
// if not sci then
99946: LD_VAR 0 1
99950: NOT
99951: IFFALSE 99955
// exit ;
99953: GO 100020
// result := 0 ;
99955: LD_ADDR_VAR 0 2
99959: PUSH
99960: LD_INT 0
99962: ST_TO_ADDR
// if GetTaskList ( sci ) then
99963: LD_VAR 0 1
99967: PPUSH
99968: CALL_OW 437
99972: IFFALSE 100020
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99974: LD_VAR 0 1
99978: PPUSH
99979: CALL_OW 437
99983: PUSH
99984: LD_INT 1
99986: ARRAY
99987: PUSH
99988: LD_INT 1
99990: ARRAY
99991: PUSH
99992: LD_STRING l
99994: EQUAL
99995: IFFALSE 100020
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99997: LD_ADDR_VAR 0 2
100001: PUSH
100002: LD_VAR 0 1
100006: PPUSH
100007: CALL_OW 437
100011: PUSH
100012: LD_INT 1
100014: ARRAY
100015: PUSH
100016: LD_INT 4
100018: ARRAY
100019: ST_TO_ADDR
// end ;
100020: LD_VAR 0 2
100024: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
100025: LD_INT 0
100027: PPUSH
100028: PPUSH
100029: PPUSH
100030: PPUSH
// if not base_units then
100031: LD_VAR 0 1
100035: NOT
100036: IFFALSE 100040
// exit ;
100038: GO 100127
// result := false ;
100040: LD_ADDR_VAR 0 2
100044: PUSH
100045: LD_INT 0
100047: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
100048: LD_ADDR_VAR 0 5
100052: PUSH
100053: LD_VAR 0 1
100057: PPUSH
100058: LD_INT 21
100060: PUSH
100061: LD_INT 3
100063: PUSH
100064: EMPTY
100065: LIST
100066: LIST
100067: PPUSH
100068: CALL_OW 72
100072: ST_TO_ADDR
// if not tmp then
100073: LD_VAR 0 5
100077: NOT
100078: IFFALSE 100082
// exit ;
100080: GO 100127
// for i in tmp do
100082: LD_ADDR_VAR 0 3
100086: PUSH
100087: LD_VAR 0 5
100091: PUSH
100092: FOR_IN
100093: IFFALSE 100125
// begin result := EnemyInRange ( i , 22 ) ;
100095: LD_ADDR_VAR 0 2
100099: PUSH
100100: LD_VAR 0 3
100104: PPUSH
100105: LD_INT 22
100107: PPUSH
100108: CALL 98363 0 2
100112: ST_TO_ADDR
// if result then
100113: LD_VAR 0 2
100117: IFFALSE 100123
// exit ;
100119: POP
100120: POP
100121: GO 100127
// end ;
100123: GO 100092
100125: POP
100126: POP
// end ;
100127: LD_VAR 0 2
100131: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
100132: LD_INT 0
100134: PPUSH
100135: PPUSH
// if not units then
100136: LD_VAR 0 1
100140: NOT
100141: IFFALSE 100145
// exit ;
100143: GO 100215
// result := [ ] ;
100145: LD_ADDR_VAR 0 3
100149: PUSH
100150: EMPTY
100151: ST_TO_ADDR
// for i in units do
100152: LD_ADDR_VAR 0 4
100156: PUSH
100157: LD_VAR 0 1
100161: PUSH
100162: FOR_IN
100163: IFFALSE 100213
// if GetTag ( i ) = tag then
100165: LD_VAR 0 4
100169: PPUSH
100170: CALL_OW 110
100174: PUSH
100175: LD_VAR 0 2
100179: EQUAL
100180: IFFALSE 100211
// result := Replace ( result , result + 1 , i ) ;
100182: LD_ADDR_VAR 0 3
100186: PUSH
100187: LD_VAR 0 3
100191: PPUSH
100192: LD_VAR 0 3
100196: PUSH
100197: LD_INT 1
100199: PLUS
100200: PPUSH
100201: LD_VAR 0 4
100205: PPUSH
100206: CALL_OW 1
100210: ST_TO_ADDR
100211: GO 100162
100213: POP
100214: POP
// end ;
100215: LD_VAR 0 3
100219: RET
// export function IsDriver ( un ) ; begin
100220: LD_INT 0
100222: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
100223: LD_ADDR_VAR 0 2
100227: PUSH
100228: LD_VAR 0 1
100232: PUSH
100233: LD_INT 55
100235: PUSH
100236: EMPTY
100237: LIST
100238: PPUSH
100239: CALL_OW 69
100243: IN
100244: ST_TO_ADDR
// end ;
100245: LD_VAR 0 2
100249: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
100250: LD_INT 0
100252: PPUSH
100253: PPUSH
// list := [ ] ;
100254: LD_ADDR_VAR 0 5
100258: PUSH
100259: EMPTY
100260: ST_TO_ADDR
// case d of 0 :
100261: LD_VAR 0 3
100265: PUSH
100266: LD_INT 0
100268: DOUBLE
100269: EQUAL
100270: IFTRUE 100274
100272: GO 100407
100274: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
100275: LD_ADDR_VAR 0 5
100279: PUSH
100280: LD_VAR 0 1
100284: PUSH
100285: LD_INT 4
100287: MINUS
100288: PUSH
100289: LD_VAR 0 2
100293: PUSH
100294: LD_INT 4
100296: MINUS
100297: PUSH
100298: LD_INT 2
100300: PUSH
100301: EMPTY
100302: LIST
100303: LIST
100304: LIST
100305: PUSH
100306: LD_VAR 0 1
100310: PUSH
100311: LD_INT 3
100313: MINUS
100314: PUSH
100315: LD_VAR 0 2
100319: PUSH
100320: LD_INT 1
100322: PUSH
100323: EMPTY
100324: LIST
100325: LIST
100326: LIST
100327: PUSH
100328: LD_VAR 0 1
100332: PUSH
100333: LD_INT 4
100335: PLUS
100336: PUSH
100337: LD_VAR 0 2
100341: PUSH
100342: LD_INT 4
100344: PUSH
100345: EMPTY
100346: LIST
100347: LIST
100348: LIST
100349: PUSH
100350: LD_VAR 0 1
100354: PUSH
100355: LD_INT 3
100357: PLUS
100358: PUSH
100359: LD_VAR 0 2
100363: PUSH
100364: LD_INT 3
100366: PLUS
100367: PUSH
100368: LD_INT 5
100370: PUSH
100371: EMPTY
100372: LIST
100373: LIST
100374: LIST
100375: PUSH
100376: LD_VAR 0 1
100380: PUSH
100381: LD_VAR 0 2
100385: PUSH
100386: LD_INT 4
100388: PLUS
100389: PUSH
100390: LD_INT 0
100392: PUSH
100393: EMPTY
100394: LIST
100395: LIST
100396: LIST
100397: PUSH
100398: EMPTY
100399: LIST
100400: LIST
100401: LIST
100402: LIST
100403: LIST
100404: ST_TO_ADDR
// end ; 1 :
100405: GO 101105
100407: LD_INT 1
100409: DOUBLE
100410: EQUAL
100411: IFTRUE 100415
100413: GO 100548
100415: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
100416: LD_ADDR_VAR 0 5
100420: PUSH
100421: LD_VAR 0 1
100425: PUSH
100426: LD_VAR 0 2
100430: PUSH
100431: LD_INT 4
100433: MINUS
100434: PUSH
100435: LD_INT 3
100437: PUSH
100438: EMPTY
100439: LIST
100440: LIST
100441: LIST
100442: PUSH
100443: LD_VAR 0 1
100447: PUSH
100448: LD_INT 3
100450: MINUS
100451: PUSH
100452: LD_VAR 0 2
100456: PUSH
100457: LD_INT 3
100459: MINUS
100460: PUSH
100461: LD_INT 2
100463: PUSH
100464: EMPTY
100465: LIST
100466: LIST
100467: LIST
100468: PUSH
100469: LD_VAR 0 1
100473: PUSH
100474: LD_INT 4
100476: MINUS
100477: PUSH
100478: LD_VAR 0 2
100482: PUSH
100483: LD_INT 1
100485: PUSH
100486: EMPTY
100487: LIST
100488: LIST
100489: LIST
100490: PUSH
100491: LD_VAR 0 1
100495: PUSH
100496: LD_VAR 0 2
100500: PUSH
100501: LD_INT 3
100503: PLUS
100504: PUSH
100505: LD_INT 0
100507: PUSH
100508: EMPTY
100509: LIST
100510: LIST
100511: LIST
100512: PUSH
100513: LD_VAR 0 1
100517: PUSH
100518: LD_INT 4
100520: PLUS
100521: PUSH
100522: LD_VAR 0 2
100526: PUSH
100527: LD_INT 4
100529: PLUS
100530: PUSH
100531: LD_INT 5
100533: PUSH
100534: EMPTY
100535: LIST
100536: LIST
100537: LIST
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: LIST
100543: LIST
100544: LIST
100545: ST_TO_ADDR
// end ; 2 :
100546: GO 101105
100548: LD_INT 2
100550: DOUBLE
100551: EQUAL
100552: IFTRUE 100556
100554: GO 100685
100556: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
100557: LD_ADDR_VAR 0 5
100561: PUSH
100562: LD_VAR 0 1
100566: PUSH
100567: LD_VAR 0 2
100571: PUSH
100572: LD_INT 3
100574: MINUS
100575: PUSH
100576: LD_INT 3
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: LIST
100583: PUSH
100584: LD_VAR 0 1
100588: PUSH
100589: LD_INT 4
100591: PLUS
100592: PUSH
100593: LD_VAR 0 2
100597: PUSH
100598: LD_INT 4
100600: PUSH
100601: EMPTY
100602: LIST
100603: LIST
100604: LIST
100605: PUSH
100606: LD_VAR 0 1
100610: PUSH
100611: LD_VAR 0 2
100615: PUSH
100616: LD_INT 4
100618: PLUS
100619: PUSH
100620: LD_INT 0
100622: PUSH
100623: EMPTY
100624: LIST
100625: LIST
100626: LIST
100627: PUSH
100628: LD_VAR 0 1
100632: PUSH
100633: LD_INT 3
100635: MINUS
100636: PUSH
100637: LD_VAR 0 2
100641: PUSH
100642: LD_INT 1
100644: PUSH
100645: EMPTY
100646: LIST
100647: LIST
100648: LIST
100649: PUSH
100650: LD_VAR 0 1
100654: PUSH
100655: LD_INT 4
100657: MINUS
100658: PUSH
100659: LD_VAR 0 2
100663: PUSH
100664: LD_INT 4
100666: MINUS
100667: PUSH
100668: LD_INT 2
100670: PUSH
100671: EMPTY
100672: LIST
100673: LIST
100674: LIST
100675: PUSH
100676: EMPTY
100677: LIST
100678: LIST
100679: LIST
100680: LIST
100681: LIST
100682: ST_TO_ADDR
// end ; 3 :
100683: GO 101105
100685: LD_INT 3
100687: DOUBLE
100688: EQUAL
100689: IFTRUE 100693
100691: GO 100826
100693: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
100694: LD_ADDR_VAR 0 5
100698: PUSH
100699: LD_VAR 0 1
100703: PUSH
100704: LD_INT 3
100706: PLUS
100707: PUSH
100708: LD_VAR 0 2
100712: PUSH
100713: LD_INT 4
100715: PUSH
100716: EMPTY
100717: LIST
100718: LIST
100719: LIST
100720: PUSH
100721: LD_VAR 0 1
100725: PUSH
100726: LD_INT 4
100728: PLUS
100729: PUSH
100730: LD_VAR 0 2
100734: PUSH
100735: LD_INT 4
100737: PLUS
100738: PUSH
100739: LD_INT 5
100741: PUSH
100742: EMPTY
100743: LIST
100744: LIST
100745: LIST
100746: PUSH
100747: LD_VAR 0 1
100751: PUSH
100752: LD_INT 4
100754: MINUS
100755: PUSH
100756: LD_VAR 0 2
100760: PUSH
100761: LD_INT 1
100763: PUSH
100764: EMPTY
100765: LIST
100766: LIST
100767: LIST
100768: PUSH
100769: LD_VAR 0 1
100773: PUSH
100774: LD_VAR 0 2
100778: PUSH
100779: LD_INT 4
100781: MINUS
100782: PUSH
100783: LD_INT 3
100785: PUSH
100786: EMPTY
100787: LIST
100788: LIST
100789: LIST
100790: PUSH
100791: LD_VAR 0 1
100795: PUSH
100796: LD_INT 3
100798: MINUS
100799: PUSH
100800: LD_VAR 0 2
100804: PUSH
100805: LD_INT 3
100807: MINUS
100808: PUSH
100809: LD_INT 2
100811: PUSH
100812: EMPTY
100813: LIST
100814: LIST
100815: LIST
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: LIST
100821: LIST
100822: LIST
100823: ST_TO_ADDR
// end ; 4 :
100824: GO 101105
100826: LD_INT 4
100828: DOUBLE
100829: EQUAL
100830: IFTRUE 100834
100832: GO 100967
100834: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
100835: LD_ADDR_VAR 0 5
100839: PUSH
100840: LD_VAR 0 1
100844: PUSH
100845: LD_VAR 0 2
100849: PUSH
100850: LD_INT 4
100852: PLUS
100853: PUSH
100854: LD_INT 0
100856: PUSH
100857: EMPTY
100858: LIST
100859: LIST
100860: LIST
100861: PUSH
100862: LD_VAR 0 1
100866: PUSH
100867: LD_INT 3
100869: PLUS
100870: PUSH
100871: LD_VAR 0 2
100875: PUSH
100876: LD_INT 3
100878: PLUS
100879: PUSH
100880: LD_INT 5
100882: PUSH
100883: EMPTY
100884: LIST
100885: LIST
100886: LIST
100887: PUSH
100888: LD_VAR 0 1
100892: PUSH
100893: LD_INT 4
100895: PLUS
100896: PUSH
100897: LD_VAR 0 2
100901: PUSH
100902: LD_INT 4
100904: PUSH
100905: EMPTY
100906: LIST
100907: LIST
100908: LIST
100909: PUSH
100910: LD_VAR 0 1
100914: PUSH
100915: LD_VAR 0 2
100919: PUSH
100920: LD_INT 3
100922: MINUS
100923: PUSH
100924: LD_INT 3
100926: PUSH
100927: EMPTY
100928: LIST
100929: LIST
100930: LIST
100931: PUSH
100932: LD_VAR 0 1
100936: PUSH
100937: LD_INT 4
100939: MINUS
100940: PUSH
100941: LD_VAR 0 2
100945: PUSH
100946: LD_INT 4
100948: MINUS
100949: PUSH
100950: LD_INT 2
100952: PUSH
100953: EMPTY
100954: LIST
100955: LIST
100956: LIST
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: LIST
100962: LIST
100963: LIST
100964: ST_TO_ADDR
// end ; 5 :
100965: GO 101105
100967: LD_INT 5
100969: DOUBLE
100970: EQUAL
100971: IFTRUE 100975
100973: GO 101104
100975: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100976: LD_ADDR_VAR 0 5
100980: PUSH
100981: LD_VAR 0 1
100985: PUSH
100986: LD_INT 4
100988: MINUS
100989: PUSH
100990: LD_VAR 0 2
100994: PUSH
100995: LD_INT 1
100997: PUSH
100998: EMPTY
100999: LIST
101000: LIST
101001: LIST
101002: PUSH
101003: LD_VAR 0 1
101007: PUSH
101008: LD_VAR 0 2
101012: PUSH
101013: LD_INT 4
101015: MINUS
101016: PUSH
101017: LD_INT 3
101019: PUSH
101020: EMPTY
101021: LIST
101022: LIST
101023: LIST
101024: PUSH
101025: LD_VAR 0 1
101029: PUSH
101030: LD_INT 4
101032: PLUS
101033: PUSH
101034: LD_VAR 0 2
101038: PUSH
101039: LD_INT 4
101041: PLUS
101042: PUSH
101043: LD_INT 5
101045: PUSH
101046: EMPTY
101047: LIST
101048: LIST
101049: LIST
101050: PUSH
101051: LD_VAR 0 1
101055: PUSH
101056: LD_INT 3
101058: PLUS
101059: PUSH
101060: LD_VAR 0 2
101064: PUSH
101065: LD_INT 4
101067: PUSH
101068: EMPTY
101069: LIST
101070: LIST
101071: LIST
101072: PUSH
101073: LD_VAR 0 1
101077: PUSH
101078: LD_VAR 0 2
101082: PUSH
101083: LD_INT 3
101085: PLUS
101086: PUSH
101087: LD_INT 0
101089: PUSH
101090: EMPTY
101091: LIST
101092: LIST
101093: LIST
101094: PUSH
101095: EMPTY
101096: LIST
101097: LIST
101098: LIST
101099: LIST
101100: LIST
101101: ST_TO_ADDR
// end ; end ;
101102: GO 101105
101104: POP
// result := list ;
101105: LD_ADDR_VAR 0 4
101109: PUSH
101110: LD_VAR 0 5
101114: ST_TO_ADDR
// end ;
101115: LD_VAR 0 4
101119: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
101120: LD_INT 0
101122: PPUSH
101123: PPUSH
101124: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
101125: LD_VAR 0 1
101129: NOT
101130: PUSH
101131: LD_VAR 0 2
101135: PUSH
101136: LD_INT 1
101138: PUSH
101139: LD_INT 2
101141: PUSH
101142: LD_INT 3
101144: PUSH
101145: LD_INT 4
101147: PUSH
101148: EMPTY
101149: LIST
101150: LIST
101151: LIST
101152: LIST
101153: IN
101154: NOT
101155: OR
101156: IFFALSE 101160
// exit ;
101158: GO 101252
// tmp := [ ] ;
101160: LD_ADDR_VAR 0 5
101164: PUSH
101165: EMPTY
101166: ST_TO_ADDR
// for i in units do
101167: LD_ADDR_VAR 0 4
101171: PUSH
101172: LD_VAR 0 1
101176: PUSH
101177: FOR_IN
101178: IFFALSE 101221
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
101180: LD_ADDR_VAR 0 5
101184: PUSH
101185: LD_VAR 0 5
101189: PPUSH
101190: LD_VAR 0 5
101194: PUSH
101195: LD_INT 1
101197: PLUS
101198: PPUSH
101199: LD_VAR 0 4
101203: PPUSH
101204: LD_VAR 0 2
101208: PPUSH
101209: CALL_OW 259
101213: PPUSH
101214: CALL_OW 2
101218: ST_TO_ADDR
101219: GO 101177
101221: POP
101222: POP
// if not tmp then
101223: LD_VAR 0 5
101227: NOT
101228: IFFALSE 101232
// exit ;
101230: GO 101252
// result := SortListByListDesc ( units , tmp ) ;
101232: LD_ADDR_VAR 0 3
101236: PUSH
101237: LD_VAR 0 1
101241: PPUSH
101242: LD_VAR 0 5
101246: PPUSH
101247: CALL_OW 77
101251: ST_TO_ADDR
// end ;
101252: LD_VAR 0 3
101256: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
101257: LD_INT 0
101259: PPUSH
101260: PPUSH
101261: PPUSH
// result := false ;
101262: LD_ADDR_VAR 0 3
101266: PUSH
101267: LD_INT 0
101269: ST_TO_ADDR
// x := GetX ( building ) ;
101270: LD_ADDR_VAR 0 4
101274: PUSH
101275: LD_VAR 0 2
101279: PPUSH
101280: CALL_OW 250
101284: ST_TO_ADDR
// y := GetY ( building ) ;
101285: LD_ADDR_VAR 0 5
101289: PUSH
101290: LD_VAR 0 2
101294: PPUSH
101295: CALL_OW 251
101299: ST_TO_ADDR
// if not building or not x or not y then
101300: LD_VAR 0 2
101304: NOT
101305: PUSH
101306: LD_VAR 0 4
101310: NOT
101311: OR
101312: PUSH
101313: LD_VAR 0 5
101317: NOT
101318: OR
101319: IFFALSE 101323
// exit ;
101321: GO 101415
// if GetTaskList ( unit ) then
101323: LD_VAR 0 1
101327: PPUSH
101328: CALL_OW 437
101332: IFFALSE 101415
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101334: LD_STRING e
101336: PUSH
101337: LD_VAR 0 1
101341: PPUSH
101342: CALL_OW 437
101346: PUSH
101347: LD_INT 1
101349: ARRAY
101350: PUSH
101351: LD_INT 1
101353: ARRAY
101354: EQUAL
101355: PUSH
101356: LD_VAR 0 4
101360: PUSH
101361: LD_VAR 0 1
101365: PPUSH
101366: CALL_OW 437
101370: PUSH
101371: LD_INT 1
101373: ARRAY
101374: PUSH
101375: LD_INT 2
101377: ARRAY
101378: EQUAL
101379: AND
101380: PUSH
101381: LD_VAR 0 5
101385: PUSH
101386: LD_VAR 0 1
101390: PPUSH
101391: CALL_OW 437
101395: PUSH
101396: LD_INT 1
101398: ARRAY
101399: PUSH
101400: LD_INT 3
101402: ARRAY
101403: EQUAL
101404: AND
101405: IFFALSE 101415
// result := true end ;
101407: LD_ADDR_VAR 0 3
101411: PUSH
101412: LD_INT 1
101414: ST_TO_ADDR
// end ;
101415: LD_VAR 0 3
101419: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
101420: LD_INT 0
101422: PPUSH
// result := false ;
101423: LD_ADDR_VAR 0 4
101427: PUSH
101428: LD_INT 0
101430: ST_TO_ADDR
// if GetTaskList ( unit ) then
101431: LD_VAR 0 1
101435: PPUSH
101436: CALL_OW 437
101440: IFFALSE 101523
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101442: LD_STRING M
101444: PUSH
101445: LD_VAR 0 1
101449: PPUSH
101450: CALL_OW 437
101454: PUSH
101455: LD_INT 1
101457: ARRAY
101458: PUSH
101459: LD_INT 1
101461: ARRAY
101462: EQUAL
101463: PUSH
101464: LD_VAR 0 2
101468: PUSH
101469: LD_VAR 0 1
101473: PPUSH
101474: CALL_OW 437
101478: PUSH
101479: LD_INT 1
101481: ARRAY
101482: PUSH
101483: LD_INT 2
101485: ARRAY
101486: EQUAL
101487: AND
101488: PUSH
101489: LD_VAR 0 3
101493: PUSH
101494: LD_VAR 0 1
101498: PPUSH
101499: CALL_OW 437
101503: PUSH
101504: LD_INT 1
101506: ARRAY
101507: PUSH
101508: LD_INT 3
101510: ARRAY
101511: EQUAL
101512: AND
101513: IFFALSE 101523
// result := true ;
101515: LD_ADDR_VAR 0 4
101519: PUSH
101520: LD_INT 1
101522: ST_TO_ADDR
// end ; end ;
101523: LD_VAR 0 4
101527: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
101528: LD_INT 0
101530: PPUSH
101531: PPUSH
101532: PPUSH
101533: PPUSH
// if not unit or not area then
101534: LD_VAR 0 1
101538: NOT
101539: PUSH
101540: LD_VAR 0 2
101544: NOT
101545: OR
101546: IFFALSE 101550
// exit ;
101548: GO 101714
// tmp := AreaToList ( area , i ) ;
101550: LD_ADDR_VAR 0 6
101554: PUSH
101555: LD_VAR 0 2
101559: PPUSH
101560: LD_VAR 0 5
101564: PPUSH
101565: CALL_OW 517
101569: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
101570: LD_ADDR_VAR 0 5
101574: PUSH
101575: DOUBLE
101576: LD_INT 1
101578: DEC
101579: ST_TO_ADDR
101580: LD_VAR 0 6
101584: PUSH
101585: LD_INT 1
101587: ARRAY
101588: PUSH
101589: FOR_TO
101590: IFFALSE 101712
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
101592: LD_ADDR_VAR 0 7
101596: PUSH
101597: LD_VAR 0 6
101601: PUSH
101602: LD_INT 1
101604: ARRAY
101605: PUSH
101606: LD_VAR 0 5
101610: ARRAY
101611: PUSH
101612: LD_VAR 0 6
101616: PUSH
101617: LD_INT 2
101619: ARRAY
101620: PUSH
101621: LD_VAR 0 5
101625: ARRAY
101626: PUSH
101627: EMPTY
101628: LIST
101629: LIST
101630: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
101631: LD_VAR 0 7
101635: PUSH
101636: LD_INT 1
101638: ARRAY
101639: PPUSH
101640: LD_VAR 0 7
101644: PUSH
101645: LD_INT 2
101647: ARRAY
101648: PPUSH
101649: CALL_OW 428
101653: PUSH
101654: LD_INT 0
101656: EQUAL
101657: IFFALSE 101710
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
101659: LD_VAR 0 1
101663: PPUSH
101664: LD_VAR 0 7
101668: PUSH
101669: LD_INT 1
101671: ARRAY
101672: PPUSH
101673: LD_VAR 0 7
101677: PUSH
101678: LD_INT 2
101680: ARRAY
101681: PPUSH
101682: LD_VAR 0 3
101686: PPUSH
101687: CALL_OW 48
// result := IsPlaced ( unit ) ;
101691: LD_ADDR_VAR 0 4
101695: PUSH
101696: LD_VAR 0 1
101700: PPUSH
101701: CALL_OW 305
101705: ST_TO_ADDR
// exit ;
101706: POP
101707: POP
101708: GO 101714
// end ; end ;
101710: GO 101589
101712: POP
101713: POP
// end ;
101714: LD_VAR 0 4
101718: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
101719: LD_INT 0
101721: PPUSH
101722: PPUSH
101723: PPUSH
// if not side or side > 8 then
101724: LD_VAR 0 1
101728: NOT
101729: PUSH
101730: LD_VAR 0 1
101734: PUSH
101735: LD_INT 8
101737: GREATER
101738: OR
101739: IFFALSE 101743
// exit ;
101741: GO 101930
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
101743: LD_ADDR_VAR 0 4
101747: PUSH
101748: LD_INT 22
101750: PUSH
101751: LD_VAR 0 1
101755: PUSH
101756: EMPTY
101757: LIST
101758: LIST
101759: PUSH
101760: LD_INT 21
101762: PUSH
101763: LD_INT 3
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: PUSH
101770: EMPTY
101771: LIST
101772: LIST
101773: PPUSH
101774: CALL_OW 69
101778: ST_TO_ADDR
// if not tmp then
101779: LD_VAR 0 4
101783: NOT
101784: IFFALSE 101788
// exit ;
101786: GO 101930
// enable_addtolog := true ;
101788: LD_ADDR_OWVAR 81
101792: PUSH
101793: LD_INT 1
101795: ST_TO_ADDR
// AddToLog ( [ ) ;
101796: LD_STRING [
101798: PPUSH
101799: CALL_OW 561
// for i in tmp do
101803: LD_ADDR_VAR 0 3
101807: PUSH
101808: LD_VAR 0 4
101812: PUSH
101813: FOR_IN
101814: IFFALSE 101921
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
101816: LD_STRING [
101818: PUSH
101819: LD_VAR 0 3
101823: PPUSH
101824: CALL_OW 266
101828: STR
101829: PUSH
101830: LD_STRING , 
101832: STR
101833: PUSH
101834: LD_VAR 0 3
101838: PPUSH
101839: CALL_OW 250
101843: STR
101844: PUSH
101845: LD_STRING , 
101847: STR
101848: PUSH
101849: LD_VAR 0 3
101853: PPUSH
101854: CALL_OW 251
101858: STR
101859: PUSH
101860: LD_STRING , 
101862: STR
101863: PUSH
101864: LD_VAR 0 3
101868: PPUSH
101869: CALL_OW 254
101873: STR
101874: PUSH
101875: LD_STRING , 
101877: STR
101878: PUSH
101879: LD_VAR 0 3
101883: PPUSH
101884: LD_INT 1
101886: PPUSH
101887: CALL_OW 268
101891: STR
101892: PUSH
101893: LD_STRING , 
101895: STR
101896: PUSH
101897: LD_VAR 0 3
101901: PPUSH
101902: LD_INT 2
101904: PPUSH
101905: CALL_OW 268
101909: STR
101910: PUSH
101911: LD_STRING ],
101913: STR
101914: PPUSH
101915: CALL_OW 561
// end ;
101919: GO 101813
101921: POP
101922: POP
// AddToLog ( ]; ) ;
101923: LD_STRING ];
101925: PPUSH
101926: CALL_OW 561
// end ;
101930: LD_VAR 0 2
101934: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101935: LD_INT 0
101937: PPUSH
101938: PPUSH
101939: PPUSH
101940: PPUSH
101941: PPUSH
// if not area or not rate or not max then
101942: LD_VAR 0 1
101946: NOT
101947: PUSH
101948: LD_VAR 0 2
101952: NOT
101953: OR
101954: PUSH
101955: LD_VAR 0 4
101959: NOT
101960: OR
101961: IFFALSE 101965
// exit ;
101963: GO 102157
// while 1 do
101965: LD_INT 1
101967: IFFALSE 102157
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101969: LD_ADDR_VAR 0 9
101973: PUSH
101974: LD_VAR 0 1
101978: PPUSH
101979: LD_INT 1
101981: PPUSH
101982: CALL_OW 287
101986: PUSH
101987: LD_INT 10
101989: MUL
101990: ST_TO_ADDR
// r := rate / 10 ;
101991: LD_ADDR_VAR 0 7
101995: PUSH
101996: LD_VAR 0 2
102000: PUSH
102001: LD_INT 10
102003: DIVREAL
102004: ST_TO_ADDR
// time := 1 1$00 ;
102005: LD_ADDR_VAR 0 8
102009: PUSH
102010: LD_INT 2100
102012: ST_TO_ADDR
// if amount < min then
102013: LD_VAR 0 9
102017: PUSH
102018: LD_VAR 0 3
102022: LESS
102023: IFFALSE 102041
// r := r * 2 else
102025: LD_ADDR_VAR 0 7
102029: PUSH
102030: LD_VAR 0 7
102034: PUSH
102035: LD_INT 2
102037: MUL
102038: ST_TO_ADDR
102039: GO 102067
// if amount > max then
102041: LD_VAR 0 9
102045: PUSH
102046: LD_VAR 0 4
102050: GREATER
102051: IFFALSE 102067
// r := r / 2 ;
102053: LD_ADDR_VAR 0 7
102057: PUSH
102058: LD_VAR 0 7
102062: PUSH
102063: LD_INT 2
102065: DIVREAL
102066: ST_TO_ADDR
// time := time / r ;
102067: LD_ADDR_VAR 0 8
102071: PUSH
102072: LD_VAR 0 8
102076: PUSH
102077: LD_VAR 0 7
102081: DIVREAL
102082: ST_TO_ADDR
// if time < 0 then
102083: LD_VAR 0 8
102087: PUSH
102088: LD_INT 0
102090: LESS
102091: IFFALSE 102108
// time := time * - 1 ;
102093: LD_ADDR_VAR 0 8
102097: PUSH
102098: LD_VAR 0 8
102102: PUSH
102103: LD_INT 1
102105: NEG
102106: MUL
102107: ST_TO_ADDR
// wait ( time ) ;
102108: LD_VAR 0 8
102112: PPUSH
102113: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
102117: LD_INT 35
102119: PPUSH
102120: LD_INT 875
102122: PPUSH
102123: CALL_OW 12
102127: PPUSH
102128: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
102132: LD_INT 1
102134: PPUSH
102135: LD_INT 5
102137: PPUSH
102138: CALL_OW 12
102142: PPUSH
102143: LD_VAR 0 1
102147: PPUSH
102148: LD_INT 1
102150: PPUSH
102151: CALL_OW 55
// end ;
102155: GO 101965
// end ;
102157: LD_VAR 0 5
102161: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
102162: LD_INT 0
102164: PPUSH
102165: PPUSH
102166: PPUSH
102167: PPUSH
102168: PPUSH
102169: PPUSH
102170: PPUSH
102171: PPUSH
// if not turrets or not factories then
102172: LD_VAR 0 1
102176: NOT
102177: PUSH
102178: LD_VAR 0 2
102182: NOT
102183: OR
102184: IFFALSE 102188
// exit ;
102186: GO 102495
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
102188: LD_ADDR_VAR 0 10
102192: PUSH
102193: LD_INT 5
102195: PUSH
102196: LD_INT 6
102198: PUSH
102199: EMPTY
102200: LIST
102201: LIST
102202: PUSH
102203: LD_INT 2
102205: PUSH
102206: LD_INT 4
102208: PUSH
102209: EMPTY
102210: LIST
102211: LIST
102212: PUSH
102213: LD_INT 3
102215: PUSH
102216: LD_INT 5
102218: PUSH
102219: EMPTY
102220: LIST
102221: LIST
102222: PUSH
102223: EMPTY
102224: LIST
102225: LIST
102226: LIST
102227: PUSH
102228: LD_INT 24
102230: PUSH
102231: LD_INT 25
102233: PUSH
102234: EMPTY
102235: LIST
102236: LIST
102237: PUSH
102238: LD_INT 23
102240: PUSH
102241: LD_INT 27
102243: PUSH
102244: EMPTY
102245: LIST
102246: LIST
102247: PUSH
102248: EMPTY
102249: LIST
102250: LIST
102251: PUSH
102252: LD_INT 42
102254: PUSH
102255: LD_INT 43
102257: PUSH
102258: EMPTY
102259: LIST
102260: LIST
102261: PUSH
102262: LD_INT 44
102264: PUSH
102265: LD_INT 46
102267: PUSH
102268: EMPTY
102269: LIST
102270: LIST
102271: PUSH
102272: LD_INT 45
102274: PUSH
102275: LD_INT 47
102277: PUSH
102278: EMPTY
102279: LIST
102280: LIST
102281: PUSH
102282: EMPTY
102283: LIST
102284: LIST
102285: LIST
102286: PUSH
102287: EMPTY
102288: LIST
102289: LIST
102290: LIST
102291: ST_TO_ADDR
// result := [ ] ;
102292: LD_ADDR_VAR 0 3
102296: PUSH
102297: EMPTY
102298: ST_TO_ADDR
// for i in turrets do
102299: LD_ADDR_VAR 0 4
102303: PUSH
102304: LD_VAR 0 1
102308: PUSH
102309: FOR_IN
102310: IFFALSE 102493
// begin nat := GetNation ( i ) ;
102312: LD_ADDR_VAR 0 7
102316: PUSH
102317: LD_VAR 0 4
102321: PPUSH
102322: CALL_OW 248
102326: ST_TO_ADDR
// weapon := 0 ;
102327: LD_ADDR_VAR 0 8
102331: PUSH
102332: LD_INT 0
102334: ST_TO_ADDR
// if not nat then
102335: LD_VAR 0 7
102339: NOT
102340: IFFALSE 102344
// continue ;
102342: GO 102309
// for j in list [ nat ] do
102344: LD_ADDR_VAR 0 5
102348: PUSH
102349: LD_VAR 0 10
102353: PUSH
102354: LD_VAR 0 7
102358: ARRAY
102359: PUSH
102360: FOR_IN
102361: IFFALSE 102402
// if GetBWeapon ( i ) = j [ 1 ] then
102363: LD_VAR 0 4
102367: PPUSH
102368: CALL_OW 269
102372: PUSH
102373: LD_VAR 0 5
102377: PUSH
102378: LD_INT 1
102380: ARRAY
102381: EQUAL
102382: IFFALSE 102400
// begin weapon := j [ 2 ] ;
102384: LD_ADDR_VAR 0 8
102388: PUSH
102389: LD_VAR 0 5
102393: PUSH
102394: LD_INT 2
102396: ARRAY
102397: ST_TO_ADDR
// break ;
102398: GO 102402
// end ;
102400: GO 102360
102402: POP
102403: POP
// if not weapon then
102404: LD_VAR 0 8
102408: NOT
102409: IFFALSE 102413
// continue ;
102411: GO 102309
// for k in factories do
102413: LD_ADDR_VAR 0 6
102417: PUSH
102418: LD_VAR 0 2
102422: PUSH
102423: FOR_IN
102424: IFFALSE 102489
// begin weapons := AvailableWeaponList ( k ) ;
102426: LD_ADDR_VAR 0 9
102430: PUSH
102431: LD_VAR 0 6
102435: PPUSH
102436: CALL_OW 478
102440: ST_TO_ADDR
// if not weapons then
102441: LD_VAR 0 9
102445: NOT
102446: IFFALSE 102450
// continue ;
102448: GO 102423
// if weapon in weapons then
102450: LD_VAR 0 8
102454: PUSH
102455: LD_VAR 0 9
102459: IN
102460: IFFALSE 102487
// begin result := [ i , weapon ] ;
102462: LD_ADDR_VAR 0 3
102466: PUSH
102467: LD_VAR 0 4
102471: PUSH
102472: LD_VAR 0 8
102476: PUSH
102477: EMPTY
102478: LIST
102479: LIST
102480: ST_TO_ADDR
// exit ;
102481: POP
102482: POP
102483: POP
102484: POP
102485: GO 102495
// end ; end ;
102487: GO 102423
102489: POP
102490: POP
// end ;
102491: GO 102309
102493: POP
102494: POP
// end ;
102495: LD_VAR 0 3
102499: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
102500: LD_INT 0
102502: PPUSH
// if not side or side > 8 then
102503: LD_VAR 0 3
102507: NOT
102508: PUSH
102509: LD_VAR 0 3
102513: PUSH
102514: LD_INT 8
102516: GREATER
102517: OR
102518: IFFALSE 102522
// exit ;
102520: GO 102581
// if not range then
102522: LD_VAR 0 4
102526: NOT
102527: IFFALSE 102538
// range := - 12 ;
102529: LD_ADDR_VAR 0 4
102533: PUSH
102534: LD_INT 12
102536: NEG
102537: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
102538: LD_VAR 0 1
102542: PPUSH
102543: LD_VAR 0 2
102547: PPUSH
102548: LD_VAR 0 3
102552: PPUSH
102553: LD_VAR 0 4
102557: PPUSH
102558: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
102562: LD_VAR 0 1
102566: PPUSH
102567: LD_VAR 0 2
102571: PPUSH
102572: LD_VAR 0 3
102576: PPUSH
102577: CALL_OW 331
// end ;
102581: LD_VAR 0 5
102585: RET
// export function Video ( mode ) ; begin
102586: LD_INT 0
102588: PPUSH
// ingame_video = mode ;
102589: LD_ADDR_OWVAR 52
102593: PUSH
102594: LD_VAR 0 1
102598: ST_TO_ADDR
// interface_hidden = mode ;
102599: LD_ADDR_OWVAR 54
102603: PUSH
102604: LD_VAR 0 1
102608: ST_TO_ADDR
// end ;
102609: LD_VAR 0 2
102613: RET
// export function Join ( array , element ) ; begin
102614: LD_INT 0
102616: PPUSH
// result := Replace ( array , array + 1 , element ) ;
102617: LD_ADDR_VAR 0 3
102621: PUSH
102622: LD_VAR 0 1
102626: PPUSH
102627: LD_VAR 0 1
102631: PUSH
102632: LD_INT 1
102634: PLUS
102635: PPUSH
102636: LD_VAR 0 2
102640: PPUSH
102641: CALL_OW 1
102645: ST_TO_ADDR
// end ;
102646: LD_VAR 0 3
102650: RET
// export function JoinUnion ( array , element ) ; begin
102651: LD_INT 0
102653: PPUSH
// result := array union element ;
102654: LD_ADDR_VAR 0 3
102658: PUSH
102659: LD_VAR 0 1
102663: PUSH
102664: LD_VAR 0 2
102668: UNION
102669: ST_TO_ADDR
// end ;
102670: LD_VAR 0 3
102674: RET
// export function GetBehemoths ( side ) ; begin
102675: LD_INT 0
102677: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
102678: LD_ADDR_VAR 0 2
102682: PUSH
102683: LD_INT 22
102685: PUSH
102686: LD_VAR 0 1
102690: PUSH
102691: EMPTY
102692: LIST
102693: LIST
102694: PUSH
102695: LD_INT 31
102697: PUSH
102698: LD_INT 25
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: PUSH
102705: EMPTY
102706: LIST
102707: LIST
102708: PPUSH
102709: CALL_OW 69
102713: ST_TO_ADDR
// end ;
102714: LD_VAR 0 2
102718: RET
// export function Shuffle ( array ) ; var i , index ; begin
102719: LD_INT 0
102721: PPUSH
102722: PPUSH
102723: PPUSH
// result := [ ] ;
102724: LD_ADDR_VAR 0 2
102728: PUSH
102729: EMPTY
102730: ST_TO_ADDR
// if not array then
102731: LD_VAR 0 1
102735: NOT
102736: IFFALSE 102740
// exit ;
102738: GO 102839
// Randomize ;
102740: CALL_OW 10
// for i = array downto 1 do
102744: LD_ADDR_VAR 0 3
102748: PUSH
102749: DOUBLE
102750: LD_VAR 0 1
102754: INC
102755: ST_TO_ADDR
102756: LD_INT 1
102758: PUSH
102759: FOR_DOWNTO
102760: IFFALSE 102837
// begin index := rand ( 1 , array ) ;
102762: LD_ADDR_VAR 0 4
102766: PUSH
102767: LD_INT 1
102769: PPUSH
102770: LD_VAR 0 1
102774: PPUSH
102775: CALL_OW 12
102779: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
102780: LD_ADDR_VAR 0 2
102784: PUSH
102785: LD_VAR 0 2
102789: PPUSH
102790: LD_VAR 0 2
102794: PUSH
102795: LD_INT 1
102797: PLUS
102798: PPUSH
102799: LD_VAR 0 1
102803: PUSH
102804: LD_VAR 0 4
102808: ARRAY
102809: PPUSH
102810: CALL_OW 2
102814: ST_TO_ADDR
// array := Delete ( array , index ) ;
102815: LD_ADDR_VAR 0 1
102819: PUSH
102820: LD_VAR 0 1
102824: PPUSH
102825: LD_VAR 0 4
102829: PPUSH
102830: CALL_OW 3
102834: ST_TO_ADDR
// end ;
102835: GO 102759
102837: POP
102838: POP
// end ;
102839: LD_VAR 0 2
102843: RET
// export function GetBaseMaterials ( base ) ; begin
102844: LD_INT 0
102846: PPUSH
// result := [ 0 , 0 , 0 ] ;
102847: LD_ADDR_VAR 0 2
102851: PUSH
102852: LD_INT 0
102854: PUSH
102855: LD_INT 0
102857: PUSH
102858: LD_INT 0
102860: PUSH
102861: EMPTY
102862: LIST
102863: LIST
102864: LIST
102865: ST_TO_ADDR
// if not base then
102866: LD_VAR 0 1
102870: NOT
102871: IFFALSE 102875
// exit ;
102873: GO 102924
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
102875: LD_ADDR_VAR 0 2
102879: PUSH
102880: LD_VAR 0 1
102884: PPUSH
102885: LD_INT 1
102887: PPUSH
102888: CALL_OW 275
102892: PUSH
102893: LD_VAR 0 1
102897: PPUSH
102898: LD_INT 2
102900: PPUSH
102901: CALL_OW 275
102905: PUSH
102906: LD_VAR 0 1
102910: PPUSH
102911: LD_INT 3
102913: PPUSH
102914: CALL_OW 275
102918: PUSH
102919: EMPTY
102920: LIST
102921: LIST
102922: LIST
102923: ST_TO_ADDR
// end ;
102924: LD_VAR 0 2
102928: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
102929: LD_INT 0
102931: PPUSH
102932: PPUSH
// result := array ;
102933: LD_ADDR_VAR 0 3
102937: PUSH
102938: LD_VAR 0 1
102942: ST_TO_ADDR
// if size > 0 then
102943: LD_VAR 0 2
102947: PUSH
102948: LD_INT 0
102950: GREATER
102951: IFFALSE 102997
// for i := array downto size do
102953: LD_ADDR_VAR 0 4
102957: PUSH
102958: DOUBLE
102959: LD_VAR 0 1
102963: INC
102964: ST_TO_ADDR
102965: LD_VAR 0 2
102969: PUSH
102970: FOR_DOWNTO
102971: IFFALSE 102995
// result := Delete ( result , result ) ;
102973: LD_ADDR_VAR 0 3
102977: PUSH
102978: LD_VAR 0 3
102982: PPUSH
102983: LD_VAR 0 3
102987: PPUSH
102988: CALL_OW 3
102992: ST_TO_ADDR
102993: GO 102970
102995: POP
102996: POP
// end ;
102997: LD_VAR 0 3
103001: RET
// export function ComExit ( unit ) ; var tmp ; begin
103002: LD_INT 0
103004: PPUSH
103005: PPUSH
// if not IsInUnit ( unit ) then
103006: LD_VAR 0 1
103010: PPUSH
103011: CALL_OW 310
103015: NOT
103016: IFFALSE 103020
// exit ;
103018: GO 103080
// tmp := IsInUnit ( unit ) ;
103020: LD_ADDR_VAR 0 3
103024: PUSH
103025: LD_VAR 0 1
103029: PPUSH
103030: CALL_OW 310
103034: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
103035: LD_VAR 0 3
103039: PPUSH
103040: CALL_OW 247
103044: PUSH
103045: LD_INT 2
103047: EQUAL
103048: IFFALSE 103061
// ComExitVehicle ( unit ) else
103050: LD_VAR 0 1
103054: PPUSH
103055: CALL_OW 121
103059: GO 103070
// ComExitBuilding ( unit ) ;
103061: LD_VAR 0 1
103065: PPUSH
103066: CALL_OW 122
// result := tmp ;
103070: LD_ADDR_VAR 0 2
103074: PUSH
103075: LD_VAR 0 3
103079: ST_TO_ADDR
// end ;
103080: LD_VAR 0 2
103084: RET
// export function ComExitAll ( units ) ; var i ; begin
103085: LD_INT 0
103087: PPUSH
103088: PPUSH
// if not units then
103089: LD_VAR 0 1
103093: NOT
103094: IFFALSE 103098
// exit ;
103096: GO 103124
// for i in units do
103098: LD_ADDR_VAR 0 3
103102: PUSH
103103: LD_VAR 0 1
103107: PUSH
103108: FOR_IN
103109: IFFALSE 103122
// ComExit ( i ) ;
103111: LD_VAR 0 3
103115: PPUSH
103116: CALL 103002 0 1
103120: GO 103108
103122: POP
103123: POP
// end ;
103124: LD_VAR 0 2
103128: RET
// export function ResetHc ; begin
103129: LD_INT 0
103131: PPUSH
// InitHc ;
103132: CALL_OW 19
// hc_importance := 0 ;
103136: LD_ADDR_OWVAR 32
103140: PUSH
103141: LD_INT 0
103143: ST_TO_ADDR
// end ;
103144: LD_VAR 0 1
103148: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
103149: LD_INT 0
103151: PPUSH
103152: PPUSH
103153: PPUSH
// _x := ( x1 + x2 ) div 2 ;
103154: LD_ADDR_VAR 0 6
103158: PUSH
103159: LD_VAR 0 1
103163: PUSH
103164: LD_VAR 0 3
103168: PLUS
103169: PUSH
103170: LD_INT 2
103172: DIV
103173: ST_TO_ADDR
// if _x < 0 then
103174: LD_VAR 0 6
103178: PUSH
103179: LD_INT 0
103181: LESS
103182: IFFALSE 103199
// _x := _x * - 1 ;
103184: LD_ADDR_VAR 0 6
103188: PUSH
103189: LD_VAR 0 6
103193: PUSH
103194: LD_INT 1
103196: NEG
103197: MUL
103198: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
103199: LD_ADDR_VAR 0 7
103203: PUSH
103204: LD_VAR 0 2
103208: PUSH
103209: LD_VAR 0 4
103213: PLUS
103214: PUSH
103215: LD_INT 2
103217: DIV
103218: ST_TO_ADDR
// if _y < 0 then
103219: LD_VAR 0 7
103223: PUSH
103224: LD_INT 0
103226: LESS
103227: IFFALSE 103244
// _y := _y * - 1 ;
103229: LD_ADDR_VAR 0 7
103233: PUSH
103234: LD_VAR 0 7
103238: PUSH
103239: LD_INT 1
103241: NEG
103242: MUL
103243: ST_TO_ADDR
// result := [ _x , _y ] ;
103244: LD_ADDR_VAR 0 5
103248: PUSH
103249: LD_VAR 0 6
103253: PUSH
103254: LD_VAR 0 7
103258: PUSH
103259: EMPTY
103260: LIST
103261: LIST
103262: ST_TO_ADDR
// end ;
103263: LD_VAR 0 5
103267: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
103268: LD_INT 0
103270: PPUSH
103271: PPUSH
103272: PPUSH
103273: PPUSH
// task := GetTaskList ( unit ) ;
103274: LD_ADDR_VAR 0 7
103278: PUSH
103279: LD_VAR 0 1
103283: PPUSH
103284: CALL_OW 437
103288: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
103289: LD_VAR 0 7
103293: NOT
103294: PUSH
103295: LD_VAR 0 1
103299: PPUSH
103300: LD_VAR 0 2
103304: PPUSH
103305: CALL_OW 308
103309: NOT
103310: AND
103311: IFFALSE 103315
// exit ;
103313: GO 103433
// if IsInArea ( unit , area ) then
103315: LD_VAR 0 1
103319: PPUSH
103320: LD_VAR 0 2
103324: PPUSH
103325: CALL_OW 308
103329: IFFALSE 103347
// begin ComMoveToArea ( unit , goAway ) ;
103331: LD_VAR 0 1
103335: PPUSH
103336: LD_VAR 0 3
103340: PPUSH
103341: CALL_OW 113
// exit ;
103345: GO 103433
// end ; if task [ 1 ] [ 1 ] <> M then
103347: LD_VAR 0 7
103351: PUSH
103352: LD_INT 1
103354: ARRAY
103355: PUSH
103356: LD_INT 1
103358: ARRAY
103359: PUSH
103360: LD_STRING M
103362: NONEQUAL
103363: IFFALSE 103367
// exit ;
103365: GO 103433
// x := task [ 1 ] [ 2 ] ;
103367: LD_ADDR_VAR 0 5
103371: PUSH
103372: LD_VAR 0 7
103376: PUSH
103377: LD_INT 1
103379: ARRAY
103380: PUSH
103381: LD_INT 2
103383: ARRAY
103384: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
103385: LD_ADDR_VAR 0 6
103389: PUSH
103390: LD_VAR 0 7
103394: PUSH
103395: LD_INT 1
103397: ARRAY
103398: PUSH
103399: LD_INT 3
103401: ARRAY
103402: ST_TO_ADDR
// if InArea ( x , y , area ) then
103403: LD_VAR 0 5
103407: PPUSH
103408: LD_VAR 0 6
103412: PPUSH
103413: LD_VAR 0 2
103417: PPUSH
103418: CALL_OW 309
103422: IFFALSE 103433
// ComStop ( unit ) ;
103424: LD_VAR 0 1
103428: PPUSH
103429: CALL_OW 141
// end ;
103433: LD_VAR 0 4
103437: RET
// export function Abs ( value ) ; begin
103438: LD_INT 0
103440: PPUSH
// result := value ;
103441: LD_ADDR_VAR 0 2
103445: PUSH
103446: LD_VAR 0 1
103450: ST_TO_ADDR
// if value < 0 then
103451: LD_VAR 0 1
103455: PUSH
103456: LD_INT 0
103458: LESS
103459: IFFALSE 103476
// result := value * - 1 ;
103461: LD_ADDR_VAR 0 2
103465: PUSH
103466: LD_VAR 0 1
103470: PUSH
103471: LD_INT 1
103473: NEG
103474: MUL
103475: ST_TO_ADDR
// end ;
103476: LD_VAR 0 2
103480: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
103481: LD_INT 0
103483: PPUSH
103484: PPUSH
103485: PPUSH
103486: PPUSH
103487: PPUSH
103488: PPUSH
103489: PPUSH
103490: PPUSH
// if not unit or not building then
103491: LD_VAR 0 1
103495: NOT
103496: PUSH
103497: LD_VAR 0 2
103501: NOT
103502: OR
103503: IFFALSE 103507
// exit ;
103505: GO 103733
// x := GetX ( building ) ;
103507: LD_ADDR_VAR 0 4
103511: PUSH
103512: LD_VAR 0 2
103516: PPUSH
103517: CALL_OW 250
103521: ST_TO_ADDR
// y := GetY ( building ) ;
103522: LD_ADDR_VAR 0 6
103526: PUSH
103527: LD_VAR 0 2
103531: PPUSH
103532: CALL_OW 251
103536: ST_TO_ADDR
// d := GetDir ( building ) ;
103537: LD_ADDR_VAR 0 8
103541: PUSH
103542: LD_VAR 0 2
103546: PPUSH
103547: CALL_OW 254
103551: ST_TO_ADDR
// r := 4 ;
103552: LD_ADDR_VAR 0 9
103556: PUSH
103557: LD_INT 4
103559: ST_TO_ADDR
// for i := 1 to 5 do
103560: LD_ADDR_VAR 0 10
103564: PUSH
103565: DOUBLE
103566: LD_INT 1
103568: DEC
103569: ST_TO_ADDR
103570: LD_INT 5
103572: PUSH
103573: FOR_TO
103574: IFFALSE 103731
// begin _x := ShiftX ( x , d , r + i ) ;
103576: LD_ADDR_VAR 0 5
103580: PUSH
103581: LD_VAR 0 4
103585: PPUSH
103586: LD_VAR 0 8
103590: PPUSH
103591: LD_VAR 0 9
103595: PUSH
103596: LD_VAR 0 10
103600: PLUS
103601: PPUSH
103602: CALL_OW 272
103606: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
103607: LD_ADDR_VAR 0 7
103611: PUSH
103612: LD_VAR 0 6
103616: PPUSH
103617: LD_VAR 0 8
103621: PPUSH
103622: LD_VAR 0 9
103626: PUSH
103627: LD_VAR 0 10
103631: PLUS
103632: PPUSH
103633: CALL_OW 273
103637: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
103638: LD_VAR 0 5
103642: PPUSH
103643: LD_VAR 0 7
103647: PPUSH
103648: CALL_OW 488
103652: PUSH
103653: LD_VAR 0 5
103657: PPUSH
103658: LD_VAR 0 7
103662: PPUSH
103663: CALL_OW 428
103667: PPUSH
103668: CALL_OW 247
103672: PUSH
103673: LD_INT 3
103675: PUSH
103676: LD_INT 2
103678: PUSH
103679: EMPTY
103680: LIST
103681: LIST
103682: IN
103683: NOT
103684: AND
103685: IFFALSE 103729
// begin ComMoveXY ( unit , _x , _y ) ;
103687: LD_VAR 0 1
103691: PPUSH
103692: LD_VAR 0 5
103696: PPUSH
103697: LD_VAR 0 7
103701: PPUSH
103702: CALL_OW 111
// result := [ _x , _y ] ;
103706: LD_ADDR_VAR 0 3
103710: PUSH
103711: LD_VAR 0 5
103715: PUSH
103716: LD_VAR 0 7
103720: PUSH
103721: EMPTY
103722: LIST
103723: LIST
103724: ST_TO_ADDR
// exit ;
103725: POP
103726: POP
103727: GO 103733
// end ; end ;
103729: GO 103573
103731: POP
103732: POP
// end ;
103733: LD_VAR 0 3
103737: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
103738: LD_INT 0
103740: PPUSH
103741: PPUSH
103742: PPUSH
// result := 0 ;
103743: LD_ADDR_VAR 0 3
103747: PUSH
103748: LD_INT 0
103750: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
103751: LD_VAR 0 1
103755: PUSH
103756: LD_INT 0
103758: LESS
103759: PUSH
103760: LD_VAR 0 1
103764: PUSH
103765: LD_INT 8
103767: GREATER
103768: OR
103769: PUSH
103770: LD_VAR 0 2
103774: PUSH
103775: LD_INT 0
103777: LESS
103778: OR
103779: PUSH
103780: LD_VAR 0 2
103784: PUSH
103785: LD_INT 8
103787: GREATER
103788: OR
103789: IFFALSE 103793
// exit ;
103791: GO 103868
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
103793: LD_ADDR_VAR 0 4
103797: PUSH
103798: LD_INT 22
103800: PUSH
103801: LD_VAR 0 2
103805: PUSH
103806: EMPTY
103807: LIST
103808: LIST
103809: PPUSH
103810: CALL_OW 69
103814: PUSH
103815: FOR_IN
103816: IFFALSE 103866
// begin un := UnitShoot ( i ) ;
103818: LD_ADDR_VAR 0 5
103822: PUSH
103823: LD_VAR 0 4
103827: PPUSH
103828: CALL_OW 504
103832: ST_TO_ADDR
// if GetSide ( un ) = side1 then
103833: LD_VAR 0 5
103837: PPUSH
103838: CALL_OW 255
103842: PUSH
103843: LD_VAR 0 1
103847: EQUAL
103848: IFFALSE 103864
// begin result := un ;
103850: LD_ADDR_VAR 0 3
103854: PUSH
103855: LD_VAR 0 5
103859: ST_TO_ADDR
// exit ;
103860: POP
103861: POP
103862: GO 103868
// end ; end ;
103864: GO 103815
103866: POP
103867: POP
// end ;
103868: LD_VAR 0 3
103872: RET
// export function GetCargoBay ( units ) ; begin
103873: LD_INT 0
103875: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
103876: LD_ADDR_VAR 0 2
103880: PUSH
103881: LD_VAR 0 1
103885: PPUSH
103886: LD_INT 2
103888: PUSH
103889: LD_INT 34
103891: PUSH
103892: LD_INT 12
103894: PUSH
103895: EMPTY
103896: LIST
103897: LIST
103898: PUSH
103899: LD_INT 34
103901: PUSH
103902: LD_INT 51
103904: PUSH
103905: EMPTY
103906: LIST
103907: LIST
103908: PUSH
103909: LD_INT 34
103911: PUSH
103912: LD_INT 32
103914: PUSH
103915: EMPTY
103916: LIST
103917: LIST
103918: PUSH
103919: LD_INT 34
103921: PUSH
103922: LD_EXP 96
103926: PUSH
103927: EMPTY
103928: LIST
103929: LIST
103930: PUSH
103931: EMPTY
103932: LIST
103933: LIST
103934: LIST
103935: LIST
103936: LIST
103937: PPUSH
103938: CALL_OW 72
103942: ST_TO_ADDR
// end ;
103943: LD_VAR 0 2
103947: RET
// export function Negate ( value ) ; begin
103948: LD_INT 0
103950: PPUSH
// result := not value ;
103951: LD_ADDR_VAR 0 2
103955: PUSH
103956: LD_VAR 0 1
103960: NOT
103961: ST_TO_ADDR
// end ;
103962: LD_VAR 0 2
103966: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
103967: LD_INT 0
103969: PPUSH
// if x1 = x2 then
103970: LD_VAR 0 1
103974: PUSH
103975: LD_VAR 0 3
103979: EQUAL
103980: IFFALSE 104014
// begin if y1 > y2 then
103982: LD_VAR 0 2
103986: PUSH
103987: LD_VAR 0 4
103991: GREATER
103992: IFFALSE 104004
// result := 0 else
103994: LD_ADDR_VAR 0 5
103998: PUSH
103999: LD_INT 0
104001: ST_TO_ADDR
104002: GO 104012
// result := 3 ;
104004: LD_ADDR_VAR 0 5
104008: PUSH
104009: LD_INT 3
104011: ST_TO_ADDR
// exit ;
104012: GO 104100
// end ; if y1 = y2 then
104014: LD_VAR 0 2
104018: PUSH
104019: LD_VAR 0 4
104023: EQUAL
104024: IFFALSE 104058
// begin if x1 > x2 then
104026: LD_VAR 0 1
104030: PUSH
104031: LD_VAR 0 3
104035: GREATER
104036: IFFALSE 104048
// result := 1 else
104038: LD_ADDR_VAR 0 5
104042: PUSH
104043: LD_INT 1
104045: ST_TO_ADDR
104046: GO 104056
// result := 4 ;
104048: LD_ADDR_VAR 0 5
104052: PUSH
104053: LD_INT 4
104055: ST_TO_ADDR
// exit ;
104056: GO 104100
// end ; if x1 > x2 and y1 > y2 then
104058: LD_VAR 0 1
104062: PUSH
104063: LD_VAR 0 3
104067: GREATER
104068: PUSH
104069: LD_VAR 0 2
104073: PUSH
104074: LD_VAR 0 4
104078: GREATER
104079: AND
104080: IFFALSE 104092
// result := 2 else
104082: LD_ADDR_VAR 0 5
104086: PUSH
104087: LD_INT 2
104089: ST_TO_ADDR
104090: GO 104100
// result := 5 ;
104092: LD_ADDR_VAR 0 5
104096: PUSH
104097: LD_INT 5
104099: ST_TO_ADDR
// end ;
104100: LD_VAR 0 5
104104: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104105: LD_INT 0
104107: PPUSH
104108: PPUSH
// if not driver or not IsInUnit ( driver ) then
104109: LD_VAR 0 1
104113: NOT
104114: PUSH
104115: LD_VAR 0 1
104119: PPUSH
104120: CALL_OW 310
104124: NOT
104125: OR
104126: IFFALSE 104130
// exit ;
104128: GO 104220
// vehicle := IsInUnit ( driver ) ;
104130: LD_ADDR_VAR 0 3
104134: PUSH
104135: LD_VAR 0 1
104139: PPUSH
104140: CALL_OW 310
104144: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104145: LD_VAR 0 1
104149: PPUSH
104150: LD_STRING \
104152: PUSH
104153: LD_INT 0
104155: PUSH
104156: LD_INT 0
104158: PUSH
104159: LD_INT 0
104161: PUSH
104162: LD_INT 0
104164: PUSH
104165: LD_INT 0
104167: PUSH
104168: LD_INT 0
104170: PUSH
104171: EMPTY
104172: LIST
104173: LIST
104174: LIST
104175: LIST
104176: LIST
104177: LIST
104178: LIST
104179: PUSH
104180: LD_STRING E
104182: PUSH
104183: LD_INT 0
104185: PUSH
104186: LD_INT 0
104188: PUSH
104189: LD_VAR 0 3
104193: PUSH
104194: LD_INT 0
104196: PUSH
104197: LD_INT 0
104199: PUSH
104200: LD_INT 0
104202: PUSH
104203: EMPTY
104204: LIST
104205: LIST
104206: LIST
104207: LIST
104208: LIST
104209: LIST
104210: LIST
104211: PUSH
104212: EMPTY
104213: LIST
104214: LIST
104215: PPUSH
104216: CALL_OW 446
// end ;
104220: LD_VAR 0 2
104224: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104225: LD_INT 0
104227: PPUSH
104228: PPUSH
// if not driver or not IsInUnit ( driver ) then
104229: LD_VAR 0 1
104233: NOT
104234: PUSH
104235: LD_VAR 0 1
104239: PPUSH
104240: CALL_OW 310
104244: NOT
104245: OR
104246: IFFALSE 104250
// exit ;
104248: GO 104340
// vehicle := IsInUnit ( driver ) ;
104250: LD_ADDR_VAR 0 3
104254: PUSH
104255: LD_VAR 0 1
104259: PPUSH
104260: CALL_OW 310
104264: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104265: LD_VAR 0 1
104269: PPUSH
104270: LD_STRING \
104272: PUSH
104273: LD_INT 0
104275: PUSH
104276: LD_INT 0
104278: PUSH
104279: LD_INT 0
104281: PUSH
104282: LD_INT 0
104284: PUSH
104285: LD_INT 0
104287: PUSH
104288: LD_INT 0
104290: PUSH
104291: EMPTY
104292: LIST
104293: LIST
104294: LIST
104295: LIST
104296: LIST
104297: LIST
104298: LIST
104299: PUSH
104300: LD_STRING E
104302: PUSH
104303: LD_INT 0
104305: PUSH
104306: LD_INT 0
104308: PUSH
104309: LD_VAR 0 3
104313: PUSH
104314: LD_INT 0
104316: PUSH
104317: LD_INT 0
104319: PUSH
104320: LD_INT 0
104322: PUSH
104323: EMPTY
104324: LIST
104325: LIST
104326: LIST
104327: LIST
104328: LIST
104329: LIST
104330: LIST
104331: PUSH
104332: EMPTY
104333: LIST
104334: LIST
104335: PPUSH
104336: CALL_OW 447
// end ;
104340: LD_VAR 0 2
104344: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
104345: LD_INT 0
104347: PPUSH
104348: PPUSH
104349: PPUSH
// tmp := [ ] ;
104350: LD_ADDR_VAR 0 5
104354: PUSH
104355: EMPTY
104356: ST_TO_ADDR
// for i in units do
104357: LD_ADDR_VAR 0 4
104361: PUSH
104362: LD_VAR 0 1
104366: PUSH
104367: FOR_IN
104368: IFFALSE 104406
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
104370: LD_ADDR_VAR 0 5
104374: PUSH
104375: LD_VAR 0 5
104379: PPUSH
104380: LD_VAR 0 5
104384: PUSH
104385: LD_INT 1
104387: PLUS
104388: PPUSH
104389: LD_VAR 0 4
104393: PPUSH
104394: CALL_OW 256
104398: PPUSH
104399: CALL_OW 2
104403: ST_TO_ADDR
104404: GO 104367
104406: POP
104407: POP
// if not tmp then
104408: LD_VAR 0 5
104412: NOT
104413: IFFALSE 104417
// exit ;
104415: GO 104465
// if asc then
104417: LD_VAR 0 2
104421: IFFALSE 104445
// result := SortListByListAsc ( units , tmp ) else
104423: LD_ADDR_VAR 0 3
104427: PUSH
104428: LD_VAR 0 1
104432: PPUSH
104433: LD_VAR 0 5
104437: PPUSH
104438: CALL_OW 76
104442: ST_TO_ADDR
104443: GO 104465
// result := SortListByListDesc ( units , tmp ) ;
104445: LD_ADDR_VAR 0 3
104449: PUSH
104450: LD_VAR 0 1
104454: PPUSH
104455: LD_VAR 0 5
104459: PPUSH
104460: CALL_OW 77
104464: ST_TO_ADDR
// end ;
104465: LD_VAR 0 3
104469: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
104470: LD_INT 0
104472: PPUSH
104473: PPUSH
// task := GetTaskList ( mech ) ;
104474: LD_ADDR_VAR 0 4
104478: PUSH
104479: LD_VAR 0 1
104483: PPUSH
104484: CALL_OW 437
104488: ST_TO_ADDR
// if not task then
104489: LD_VAR 0 4
104493: NOT
104494: IFFALSE 104498
// exit ;
104496: GO 104540
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
104498: LD_ADDR_VAR 0 3
104502: PUSH
104503: LD_VAR 0 4
104507: PUSH
104508: LD_INT 1
104510: ARRAY
104511: PUSH
104512: LD_INT 1
104514: ARRAY
104515: PUSH
104516: LD_STRING r
104518: EQUAL
104519: PUSH
104520: LD_VAR 0 4
104524: PUSH
104525: LD_INT 1
104527: ARRAY
104528: PUSH
104529: LD_INT 4
104531: ARRAY
104532: PUSH
104533: LD_VAR 0 2
104537: EQUAL
104538: AND
104539: ST_TO_ADDR
// end ;
104540: LD_VAR 0 3
104544: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
104545: LD_INT 0
104547: PPUSH
// SetDir ( unit , d ) ;
104548: LD_VAR 0 1
104552: PPUSH
104553: LD_VAR 0 4
104557: PPUSH
104558: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
104562: LD_VAR 0 1
104566: PPUSH
104567: LD_VAR 0 2
104571: PPUSH
104572: LD_VAR 0 3
104576: PPUSH
104577: LD_VAR 0 5
104581: PPUSH
104582: CALL_OW 48
// end ;
104586: LD_VAR 0 6
104590: RET
// export function ToNaturalNumber ( number ) ; begin
104591: LD_INT 0
104593: PPUSH
// result := number div 1 ;
104594: LD_ADDR_VAR 0 2
104598: PUSH
104599: LD_VAR 0 1
104603: PUSH
104604: LD_INT 1
104606: DIV
104607: ST_TO_ADDR
// if number < 0 then
104608: LD_VAR 0 1
104612: PUSH
104613: LD_INT 0
104615: LESS
104616: IFFALSE 104626
// result := 0 ;
104618: LD_ADDR_VAR 0 2
104622: PUSH
104623: LD_INT 0
104625: ST_TO_ADDR
// end ;
104626: LD_VAR 0 2
104630: RET
// export function SortByClass ( units , class ) ; var un ; begin
104631: LD_INT 0
104633: PPUSH
104634: PPUSH
// if not units or not class then
104635: LD_VAR 0 1
104639: NOT
104640: PUSH
104641: LD_VAR 0 2
104645: NOT
104646: OR
104647: IFFALSE 104651
// exit ;
104649: GO 104746
// result := [ ] ;
104651: LD_ADDR_VAR 0 3
104655: PUSH
104656: EMPTY
104657: ST_TO_ADDR
// for un in units do
104658: LD_ADDR_VAR 0 4
104662: PUSH
104663: LD_VAR 0 1
104667: PUSH
104668: FOR_IN
104669: IFFALSE 104744
// if GetClass ( un ) = class then
104671: LD_VAR 0 4
104675: PPUSH
104676: CALL_OW 257
104680: PUSH
104681: LD_VAR 0 2
104685: EQUAL
104686: IFFALSE 104713
// result := Insert ( result , 1 , un ) else
104688: LD_ADDR_VAR 0 3
104692: PUSH
104693: LD_VAR 0 3
104697: PPUSH
104698: LD_INT 1
104700: PPUSH
104701: LD_VAR 0 4
104705: PPUSH
104706: CALL_OW 2
104710: ST_TO_ADDR
104711: GO 104742
// result := Replace ( result , result + 1 , un ) ;
104713: LD_ADDR_VAR 0 3
104717: PUSH
104718: LD_VAR 0 3
104722: PPUSH
104723: LD_VAR 0 3
104727: PUSH
104728: LD_INT 1
104730: PLUS
104731: PPUSH
104732: LD_VAR 0 4
104736: PPUSH
104737: CALL_OW 1
104741: ST_TO_ADDR
104742: GO 104668
104744: POP
104745: POP
// end ;
104746: LD_VAR 0 3
104750: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
104751: LD_INT 0
104753: PPUSH
104754: PPUSH
104755: PPUSH
104756: PPUSH
104757: PPUSH
104758: PPUSH
104759: PPUSH
// result := [ ] ;
104760: LD_ADDR_VAR 0 4
104764: PUSH
104765: EMPTY
104766: ST_TO_ADDR
// if x - r < 0 then
104767: LD_VAR 0 1
104771: PUSH
104772: LD_VAR 0 3
104776: MINUS
104777: PUSH
104778: LD_INT 0
104780: LESS
104781: IFFALSE 104793
// min_x := 0 else
104783: LD_ADDR_VAR 0 8
104787: PUSH
104788: LD_INT 0
104790: ST_TO_ADDR
104791: GO 104809
// min_x := x - r ;
104793: LD_ADDR_VAR 0 8
104797: PUSH
104798: LD_VAR 0 1
104802: PUSH
104803: LD_VAR 0 3
104807: MINUS
104808: ST_TO_ADDR
// if y - r < 0 then
104809: LD_VAR 0 2
104813: PUSH
104814: LD_VAR 0 3
104818: MINUS
104819: PUSH
104820: LD_INT 0
104822: LESS
104823: IFFALSE 104835
// min_y := 0 else
104825: LD_ADDR_VAR 0 7
104829: PUSH
104830: LD_INT 0
104832: ST_TO_ADDR
104833: GO 104851
// min_y := y - r ;
104835: LD_ADDR_VAR 0 7
104839: PUSH
104840: LD_VAR 0 2
104844: PUSH
104845: LD_VAR 0 3
104849: MINUS
104850: ST_TO_ADDR
// max_x := x + r ;
104851: LD_ADDR_VAR 0 9
104855: PUSH
104856: LD_VAR 0 1
104860: PUSH
104861: LD_VAR 0 3
104865: PLUS
104866: ST_TO_ADDR
// max_y := y + r ;
104867: LD_ADDR_VAR 0 10
104871: PUSH
104872: LD_VAR 0 2
104876: PUSH
104877: LD_VAR 0 3
104881: PLUS
104882: ST_TO_ADDR
// for _x = min_x to max_x do
104883: LD_ADDR_VAR 0 5
104887: PUSH
104888: DOUBLE
104889: LD_VAR 0 8
104893: DEC
104894: ST_TO_ADDR
104895: LD_VAR 0 9
104899: PUSH
104900: FOR_TO
104901: IFFALSE 105002
// for _y = min_y to max_y do
104903: LD_ADDR_VAR 0 6
104907: PUSH
104908: DOUBLE
104909: LD_VAR 0 7
104913: DEC
104914: ST_TO_ADDR
104915: LD_VAR 0 10
104919: PUSH
104920: FOR_TO
104921: IFFALSE 104998
// begin if not ValidHex ( _x , _y ) then
104923: LD_VAR 0 5
104927: PPUSH
104928: LD_VAR 0 6
104932: PPUSH
104933: CALL_OW 488
104937: NOT
104938: IFFALSE 104942
// continue ;
104940: GO 104920
// if GetResourceTypeXY ( _x , _y ) then
104942: LD_VAR 0 5
104946: PPUSH
104947: LD_VAR 0 6
104951: PPUSH
104952: CALL_OW 283
104956: IFFALSE 104996
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
104958: LD_ADDR_VAR 0 4
104962: PUSH
104963: LD_VAR 0 4
104967: PPUSH
104968: LD_VAR 0 4
104972: PUSH
104973: LD_INT 1
104975: PLUS
104976: PPUSH
104977: LD_VAR 0 5
104981: PUSH
104982: LD_VAR 0 6
104986: PUSH
104987: EMPTY
104988: LIST
104989: LIST
104990: PPUSH
104991: CALL_OW 1
104995: ST_TO_ADDR
// end ;
104996: GO 104920
104998: POP
104999: POP
105000: GO 104900
105002: POP
105003: POP
// end ;
105004: LD_VAR 0 4
105008: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
105009: LD_INT 0
105011: PPUSH
105012: PPUSH
105013: PPUSH
105014: PPUSH
105015: PPUSH
105016: PPUSH
// if not units then
105017: LD_VAR 0 1
105021: NOT
105022: IFFALSE 105026
// exit ;
105024: GO 105427
// result := UnitFilter ( units , [ f_ok ] ) ;
105026: LD_ADDR_VAR 0 3
105030: PUSH
105031: LD_VAR 0 1
105035: PPUSH
105036: LD_INT 50
105038: PUSH
105039: EMPTY
105040: LIST
105041: PPUSH
105042: CALL_OW 72
105046: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
105047: LD_ADDR_VAR 0 7
105051: PUSH
105052: LD_VAR 0 1
105056: PUSH
105057: LD_INT 1
105059: ARRAY
105060: PPUSH
105061: CALL_OW 255
105065: ST_TO_ADDR
// if not result then
105066: LD_VAR 0 3
105070: NOT
105071: IFFALSE 105075
// exit ;
105073: GO 105427
// for i in result do
105075: LD_ADDR_VAR 0 4
105079: PUSH
105080: LD_VAR 0 3
105084: PUSH
105085: FOR_IN
105086: IFFALSE 105425
// begin tag := GetTag ( i ) + 1 ;
105088: LD_ADDR_VAR 0 8
105092: PUSH
105093: LD_VAR 0 4
105097: PPUSH
105098: CALL_OW 110
105102: PUSH
105103: LD_INT 1
105105: PLUS
105106: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
105107: LD_ADDR_VAR 0 6
105111: PUSH
105112: LD_VAR 0 4
105116: PPUSH
105117: CALL_OW 250
105121: PPUSH
105122: LD_VAR 0 4
105126: PPUSH
105127: CALL_OW 251
105131: PPUSH
105132: LD_INT 6
105134: PPUSH
105135: CALL 104751 0 3
105139: ST_TO_ADDR
// if cr then
105140: LD_VAR 0 6
105144: IFFALSE 105183
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
105146: LD_VAR 0 4
105150: PPUSH
105151: LD_VAR 0 6
105155: PUSH
105156: LD_INT 1
105158: ARRAY
105159: PUSH
105160: LD_INT 1
105162: ARRAY
105163: PPUSH
105164: LD_VAR 0 6
105168: PUSH
105169: LD_INT 1
105171: ARRAY
105172: PUSH
105173: LD_INT 2
105175: ARRAY
105176: PPUSH
105177: CALL_OW 116
105181: GO 105423
// if path > tag then
105183: LD_VAR 0 2
105187: PUSH
105188: LD_VAR 0 8
105192: GREATER
105193: IFFALSE 105371
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
105195: LD_ADDR_VAR 0 5
105199: PUSH
105200: LD_INT 81
105202: PUSH
105203: LD_VAR 0 7
105207: PUSH
105208: EMPTY
105209: LIST
105210: LIST
105211: PUSH
105212: LD_INT 91
105214: PUSH
105215: LD_VAR 0 4
105219: PUSH
105220: LD_INT 12
105222: PUSH
105223: EMPTY
105224: LIST
105225: LIST
105226: LIST
105227: PUSH
105228: EMPTY
105229: LIST
105230: LIST
105231: PPUSH
105232: CALL_OW 69
105236: ST_TO_ADDR
// if enemy then
105237: LD_VAR 0 5
105241: IFFALSE 105269
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
105243: LD_VAR 0 4
105247: PPUSH
105248: LD_VAR 0 5
105252: PPUSH
105253: LD_VAR 0 4
105257: PPUSH
105258: CALL_OW 74
105262: PPUSH
105263: CALL_OW 115
105267: GO 105369
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
105269: LD_VAR 0 4
105273: PPUSH
105274: LD_VAR 0 2
105278: PUSH
105279: LD_VAR 0 8
105283: ARRAY
105284: PUSH
105285: LD_INT 1
105287: ARRAY
105288: PPUSH
105289: LD_VAR 0 2
105293: PUSH
105294: LD_VAR 0 8
105298: ARRAY
105299: PUSH
105300: LD_INT 2
105302: ARRAY
105303: PPUSH
105304: CALL_OW 297
105308: PUSH
105309: LD_INT 6
105311: GREATER
105312: IFFALSE 105355
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
105314: LD_VAR 0 4
105318: PPUSH
105319: LD_VAR 0 2
105323: PUSH
105324: LD_VAR 0 8
105328: ARRAY
105329: PUSH
105330: LD_INT 1
105332: ARRAY
105333: PPUSH
105334: LD_VAR 0 2
105338: PUSH
105339: LD_VAR 0 8
105343: ARRAY
105344: PUSH
105345: LD_INT 2
105347: ARRAY
105348: PPUSH
105349: CALL_OW 114
105353: GO 105369
// SetTag ( i , tag ) ;
105355: LD_VAR 0 4
105359: PPUSH
105360: LD_VAR 0 8
105364: PPUSH
105365: CALL_OW 109
// end else
105369: GO 105423
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
105371: LD_ADDR_VAR 0 5
105375: PUSH
105376: LD_INT 81
105378: PUSH
105379: LD_VAR 0 7
105383: PUSH
105384: EMPTY
105385: LIST
105386: LIST
105387: PPUSH
105388: CALL_OW 69
105392: ST_TO_ADDR
// if enemy then
105393: LD_VAR 0 5
105397: IFFALSE 105423
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
105399: LD_VAR 0 4
105403: PPUSH
105404: LD_VAR 0 5
105408: PPUSH
105409: LD_VAR 0 4
105413: PPUSH
105414: CALL_OW 74
105418: PPUSH
105419: CALL_OW 115
// end ; end ;
105423: GO 105085
105425: POP
105426: POP
// end ; end_of_file end_of_file
105427: LD_VAR 0 3
105431: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105432: LD_INT 0
105434: PPUSH
// if p2 = 100 then
105435: LD_VAR 0 2
105439: PUSH
105440: LD_INT 100
105442: EQUAL
105443: IFFALSE 106392
// begin if not StreamModeActive then
105445: LD_EXP 160
105449: NOT
105450: IFFALSE 105460
// StreamModeActive := true ;
105452: LD_ADDR_EXP 160
105456: PUSH
105457: LD_INT 1
105459: ST_TO_ADDR
// if p3 = 0 then
105460: LD_VAR 0 3
105464: PUSH
105465: LD_INT 0
105467: EQUAL
105468: IFFALSE 105474
// InitStreamMode ;
105470: CALL 106552 0 0
// if p3 = 1 then
105474: LD_VAR 0 3
105478: PUSH
105479: LD_INT 1
105481: EQUAL
105482: IFFALSE 105492
// sRocket := true ;
105484: LD_ADDR_EXP 165
105488: PUSH
105489: LD_INT 1
105491: ST_TO_ADDR
// if p3 = 2 then
105492: LD_VAR 0 3
105496: PUSH
105497: LD_INT 2
105499: EQUAL
105500: IFFALSE 105510
// sSpeed := true ;
105502: LD_ADDR_EXP 164
105506: PUSH
105507: LD_INT 1
105509: ST_TO_ADDR
// if p3 = 3 then
105510: LD_VAR 0 3
105514: PUSH
105515: LD_INT 3
105517: EQUAL
105518: IFFALSE 105528
// sEngine := true ;
105520: LD_ADDR_EXP 166
105524: PUSH
105525: LD_INT 1
105527: ST_TO_ADDR
// if p3 = 4 then
105528: LD_VAR 0 3
105532: PUSH
105533: LD_INT 4
105535: EQUAL
105536: IFFALSE 105546
// sSpec := true ;
105538: LD_ADDR_EXP 163
105542: PUSH
105543: LD_INT 1
105545: ST_TO_ADDR
// if p3 = 5 then
105546: LD_VAR 0 3
105550: PUSH
105551: LD_INT 5
105553: EQUAL
105554: IFFALSE 105564
// sLevel := true ;
105556: LD_ADDR_EXP 167
105560: PUSH
105561: LD_INT 1
105563: ST_TO_ADDR
// if p3 = 6 then
105564: LD_VAR 0 3
105568: PUSH
105569: LD_INT 6
105571: EQUAL
105572: IFFALSE 105582
// sArmoury := true ;
105574: LD_ADDR_EXP 168
105578: PUSH
105579: LD_INT 1
105581: ST_TO_ADDR
// if p3 = 7 then
105582: LD_VAR 0 3
105586: PUSH
105587: LD_INT 7
105589: EQUAL
105590: IFFALSE 105600
// sRadar := true ;
105592: LD_ADDR_EXP 169
105596: PUSH
105597: LD_INT 1
105599: ST_TO_ADDR
// if p3 = 8 then
105600: LD_VAR 0 3
105604: PUSH
105605: LD_INT 8
105607: EQUAL
105608: IFFALSE 105618
// sBunker := true ;
105610: LD_ADDR_EXP 170
105614: PUSH
105615: LD_INT 1
105617: ST_TO_ADDR
// if p3 = 9 then
105618: LD_VAR 0 3
105622: PUSH
105623: LD_INT 9
105625: EQUAL
105626: IFFALSE 105636
// sHack := true ;
105628: LD_ADDR_EXP 171
105632: PUSH
105633: LD_INT 1
105635: ST_TO_ADDR
// if p3 = 10 then
105636: LD_VAR 0 3
105640: PUSH
105641: LD_INT 10
105643: EQUAL
105644: IFFALSE 105654
// sFire := true ;
105646: LD_ADDR_EXP 172
105650: PUSH
105651: LD_INT 1
105653: ST_TO_ADDR
// if p3 = 11 then
105654: LD_VAR 0 3
105658: PUSH
105659: LD_INT 11
105661: EQUAL
105662: IFFALSE 105672
// sRefresh := true ;
105664: LD_ADDR_EXP 173
105668: PUSH
105669: LD_INT 1
105671: ST_TO_ADDR
// if p3 = 12 then
105672: LD_VAR 0 3
105676: PUSH
105677: LD_INT 12
105679: EQUAL
105680: IFFALSE 105690
// sExp := true ;
105682: LD_ADDR_EXP 174
105686: PUSH
105687: LD_INT 1
105689: ST_TO_ADDR
// if p3 = 13 then
105690: LD_VAR 0 3
105694: PUSH
105695: LD_INT 13
105697: EQUAL
105698: IFFALSE 105708
// sDepot := true ;
105700: LD_ADDR_EXP 175
105704: PUSH
105705: LD_INT 1
105707: ST_TO_ADDR
// if p3 = 14 then
105708: LD_VAR 0 3
105712: PUSH
105713: LD_INT 14
105715: EQUAL
105716: IFFALSE 105726
// sFlag := true ;
105718: LD_ADDR_EXP 176
105722: PUSH
105723: LD_INT 1
105725: ST_TO_ADDR
// if p3 = 15 then
105726: LD_VAR 0 3
105730: PUSH
105731: LD_INT 15
105733: EQUAL
105734: IFFALSE 105744
// sKamikadze := true ;
105736: LD_ADDR_EXP 184
105740: PUSH
105741: LD_INT 1
105743: ST_TO_ADDR
// if p3 = 16 then
105744: LD_VAR 0 3
105748: PUSH
105749: LD_INT 16
105751: EQUAL
105752: IFFALSE 105762
// sTroll := true ;
105754: LD_ADDR_EXP 185
105758: PUSH
105759: LD_INT 1
105761: ST_TO_ADDR
// if p3 = 17 then
105762: LD_VAR 0 3
105766: PUSH
105767: LD_INT 17
105769: EQUAL
105770: IFFALSE 105780
// sSlow := true ;
105772: LD_ADDR_EXP 186
105776: PUSH
105777: LD_INT 1
105779: ST_TO_ADDR
// if p3 = 18 then
105780: LD_VAR 0 3
105784: PUSH
105785: LD_INT 18
105787: EQUAL
105788: IFFALSE 105798
// sLack := true ;
105790: LD_ADDR_EXP 187
105794: PUSH
105795: LD_INT 1
105797: ST_TO_ADDR
// if p3 = 19 then
105798: LD_VAR 0 3
105802: PUSH
105803: LD_INT 19
105805: EQUAL
105806: IFFALSE 105816
// sTank := true ;
105808: LD_ADDR_EXP 189
105812: PUSH
105813: LD_INT 1
105815: ST_TO_ADDR
// if p3 = 20 then
105816: LD_VAR 0 3
105820: PUSH
105821: LD_INT 20
105823: EQUAL
105824: IFFALSE 105834
// sRemote := true ;
105826: LD_ADDR_EXP 190
105830: PUSH
105831: LD_INT 1
105833: ST_TO_ADDR
// if p3 = 21 then
105834: LD_VAR 0 3
105838: PUSH
105839: LD_INT 21
105841: EQUAL
105842: IFFALSE 105852
// sPowell := true ;
105844: LD_ADDR_EXP 191
105848: PUSH
105849: LD_INT 1
105851: ST_TO_ADDR
// if p3 = 22 then
105852: LD_VAR 0 3
105856: PUSH
105857: LD_INT 22
105859: EQUAL
105860: IFFALSE 105870
// sTeleport := true ;
105862: LD_ADDR_EXP 194
105866: PUSH
105867: LD_INT 1
105869: ST_TO_ADDR
// if p3 = 23 then
105870: LD_VAR 0 3
105874: PUSH
105875: LD_INT 23
105877: EQUAL
105878: IFFALSE 105888
// sOilTower := true ;
105880: LD_ADDR_EXP 196
105884: PUSH
105885: LD_INT 1
105887: ST_TO_ADDR
// if p3 = 24 then
105888: LD_VAR 0 3
105892: PUSH
105893: LD_INT 24
105895: EQUAL
105896: IFFALSE 105906
// sShovel := true ;
105898: LD_ADDR_EXP 197
105902: PUSH
105903: LD_INT 1
105905: ST_TO_ADDR
// if p3 = 25 then
105906: LD_VAR 0 3
105910: PUSH
105911: LD_INT 25
105913: EQUAL
105914: IFFALSE 105924
// sSheik := true ;
105916: LD_ADDR_EXP 198
105920: PUSH
105921: LD_INT 1
105923: ST_TO_ADDR
// if p3 = 26 then
105924: LD_VAR 0 3
105928: PUSH
105929: LD_INT 26
105931: EQUAL
105932: IFFALSE 105942
// sEarthquake := true ;
105934: LD_ADDR_EXP 200
105938: PUSH
105939: LD_INT 1
105941: ST_TO_ADDR
// if p3 = 27 then
105942: LD_VAR 0 3
105946: PUSH
105947: LD_INT 27
105949: EQUAL
105950: IFFALSE 105960
// sAI := true ;
105952: LD_ADDR_EXP 201
105956: PUSH
105957: LD_INT 1
105959: ST_TO_ADDR
// if p3 = 28 then
105960: LD_VAR 0 3
105964: PUSH
105965: LD_INT 28
105967: EQUAL
105968: IFFALSE 105978
// sCargo := true ;
105970: LD_ADDR_EXP 204
105974: PUSH
105975: LD_INT 1
105977: ST_TO_ADDR
// if p3 = 29 then
105978: LD_VAR 0 3
105982: PUSH
105983: LD_INT 29
105985: EQUAL
105986: IFFALSE 105996
// sDLaser := true ;
105988: LD_ADDR_EXP 205
105992: PUSH
105993: LD_INT 1
105995: ST_TO_ADDR
// if p3 = 30 then
105996: LD_VAR 0 3
106000: PUSH
106001: LD_INT 30
106003: EQUAL
106004: IFFALSE 106014
// sExchange := true ;
106006: LD_ADDR_EXP 206
106010: PUSH
106011: LD_INT 1
106013: ST_TO_ADDR
// if p3 = 31 then
106014: LD_VAR 0 3
106018: PUSH
106019: LD_INT 31
106021: EQUAL
106022: IFFALSE 106032
// sFac := true ;
106024: LD_ADDR_EXP 207
106028: PUSH
106029: LD_INT 1
106031: ST_TO_ADDR
// if p3 = 32 then
106032: LD_VAR 0 3
106036: PUSH
106037: LD_INT 32
106039: EQUAL
106040: IFFALSE 106050
// sPower := true ;
106042: LD_ADDR_EXP 208
106046: PUSH
106047: LD_INT 1
106049: ST_TO_ADDR
// if p3 = 33 then
106050: LD_VAR 0 3
106054: PUSH
106055: LD_INT 33
106057: EQUAL
106058: IFFALSE 106068
// sRandom := true ;
106060: LD_ADDR_EXP 209
106064: PUSH
106065: LD_INT 1
106067: ST_TO_ADDR
// if p3 = 34 then
106068: LD_VAR 0 3
106072: PUSH
106073: LD_INT 34
106075: EQUAL
106076: IFFALSE 106086
// sShield := true ;
106078: LD_ADDR_EXP 210
106082: PUSH
106083: LD_INT 1
106085: ST_TO_ADDR
// if p3 = 35 then
106086: LD_VAR 0 3
106090: PUSH
106091: LD_INT 35
106093: EQUAL
106094: IFFALSE 106104
// sTime := true ;
106096: LD_ADDR_EXP 211
106100: PUSH
106101: LD_INT 1
106103: ST_TO_ADDR
// if p3 = 36 then
106104: LD_VAR 0 3
106108: PUSH
106109: LD_INT 36
106111: EQUAL
106112: IFFALSE 106122
// sTools := true ;
106114: LD_ADDR_EXP 212
106118: PUSH
106119: LD_INT 1
106121: ST_TO_ADDR
// if p3 = 101 then
106122: LD_VAR 0 3
106126: PUSH
106127: LD_INT 101
106129: EQUAL
106130: IFFALSE 106140
// sSold := true ;
106132: LD_ADDR_EXP 177
106136: PUSH
106137: LD_INT 1
106139: ST_TO_ADDR
// if p3 = 102 then
106140: LD_VAR 0 3
106144: PUSH
106145: LD_INT 102
106147: EQUAL
106148: IFFALSE 106158
// sDiff := true ;
106150: LD_ADDR_EXP 178
106154: PUSH
106155: LD_INT 1
106157: ST_TO_ADDR
// if p3 = 103 then
106158: LD_VAR 0 3
106162: PUSH
106163: LD_INT 103
106165: EQUAL
106166: IFFALSE 106176
// sFog := true ;
106168: LD_ADDR_EXP 181
106172: PUSH
106173: LD_INT 1
106175: ST_TO_ADDR
// if p3 = 104 then
106176: LD_VAR 0 3
106180: PUSH
106181: LD_INT 104
106183: EQUAL
106184: IFFALSE 106194
// sReset := true ;
106186: LD_ADDR_EXP 182
106190: PUSH
106191: LD_INT 1
106193: ST_TO_ADDR
// if p3 = 105 then
106194: LD_VAR 0 3
106198: PUSH
106199: LD_INT 105
106201: EQUAL
106202: IFFALSE 106212
// sSun := true ;
106204: LD_ADDR_EXP 183
106208: PUSH
106209: LD_INT 1
106211: ST_TO_ADDR
// if p3 = 106 then
106212: LD_VAR 0 3
106216: PUSH
106217: LD_INT 106
106219: EQUAL
106220: IFFALSE 106230
// sTiger := true ;
106222: LD_ADDR_EXP 179
106226: PUSH
106227: LD_INT 1
106229: ST_TO_ADDR
// if p3 = 107 then
106230: LD_VAR 0 3
106234: PUSH
106235: LD_INT 107
106237: EQUAL
106238: IFFALSE 106248
// sBomb := true ;
106240: LD_ADDR_EXP 180
106244: PUSH
106245: LD_INT 1
106247: ST_TO_ADDR
// if p3 = 108 then
106248: LD_VAR 0 3
106252: PUSH
106253: LD_INT 108
106255: EQUAL
106256: IFFALSE 106266
// sWound := true ;
106258: LD_ADDR_EXP 188
106262: PUSH
106263: LD_INT 1
106265: ST_TO_ADDR
// if p3 = 109 then
106266: LD_VAR 0 3
106270: PUSH
106271: LD_INT 109
106273: EQUAL
106274: IFFALSE 106284
// sBetray := true ;
106276: LD_ADDR_EXP 192
106280: PUSH
106281: LD_INT 1
106283: ST_TO_ADDR
// if p3 = 110 then
106284: LD_VAR 0 3
106288: PUSH
106289: LD_INT 110
106291: EQUAL
106292: IFFALSE 106302
// sContamin := true ;
106294: LD_ADDR_EXP 193
106298: PUSH
106299: LD_INT 1
106301: ST_TO_ADDR
// if p3 = 111 then
106302: LD_VAR 0 3
106306: PUSH
106307: LD_INT 111
106309: EQUAL
106310: IFFALSE 106320
// sOil := true ;
106312: LD_ADDR_EXP 195
106316: PUSH
106317: LD_INT 1
106319: ST_TO_ADDR
// if p3 = 112 then
106320: LD_VAR 0 3
106324: PUSH
106325: LD_INT 112
106327: EQUAL
106328: IFFALSE 106338
// sStu := true ;
106330: LD_ADDR_EXP 199
106334: PUSH
106335: LD_INT 1
106337: ST_TO_ADDR
// if p3 = 113 then
106338: LD_VAR 0 3
106342: PUSH
106343: LD_INT 113
106345: EQUAL
106346: IFFALSE 106356
// sBazooka := true ;
106348: LD_ADDR_EXP 202
106352: PUSH
106353: LD_INT 1
106355: ST_TO_ADDR
// if p3 = 114 then
106356: LD_VAR 0 3
106360: PUSH
106361: LD_INT 114
106363: EQUAL
106364: IFFALSE 106374
// sMortar := true ;
106366: LD_ADDR_EXP 203
106370: PUSH
106371: LD_INT 1
106373: ST_TO_ADDR
// if p3 = 115 then
106374: LD_VAR 0 3
106378: PUSH
106379: LD_INT 115
106381: EQUAL
106382: IFFALSE 106392
// sRanger := true ;
106384: LD_ADDR_EXP 213
106388: PUSH
106389: LD_INT 1
106391: ST_TO_ADDR
// end ; if p2 = 101 then
106392: LD_VAR 0 2
106396: PUSH
106397: LD_INT 101
106399: EQUAL
106400: IFFALSE 106528
// begin case p3 of 1 :
106402: LD_VAR 0 3
106406: PUSH
106407: LD_INT 1
106409: DOUBLE
106410: EQUAL
106411: IFTRUE 106415
106413: GO 106422
106415: POP
// hHackUnlimitedResources ; 2 :
106416: CALL 117565 0 0
106420: GO 106528
106422: LD_INT 2
106424: DOUBLE
106425: EQUAL
106426: IFTRUE 106430
106428: GO 106437
106430: POP
// hHackSetLevel10 ; 3 :
106431: CALL 117698 0 0
106435: GO 106528
106437: LD_INT 3
106439: DOUBLE
106440: EQUAL
106441: IFTRUE 106445
106443: GO 106452
106445: POP
// hHackSetLevel10YourUnits ; 4 :
106446: CALL 117783 0 0
106450: GO 106528
106452: LD_INT 4
106454: DOUBLE
106455: EQUAL
106456: IFTRUE 106460
106458: GO 106467
106460: POP
// hHackInvincible ; 5 :
106461: CALL 118231 0 0
106465: GO 106528
106467: LD_INT 5
106469: DOUBLE
106470: EQUAL
106471: IFTRUE 106475
106473: GO 106482
106475: POP
// hHackInvisible ; 6 :
106476: CALL 118342 0 0
106480: GO 106528
106482: LD_INT 6
106484: DOUBLE
106485: EQUAL
106486: IFTRUE 106490
106488: GO 106497
106490: POP
// hHackChangeYourSide ; 7 :
106491: CALL 118399 0 0
106495: GO 106528
106497: LD_INT 7
106499: DOUBLE
106500: EQUAL
106501: IFTRUE 106505
106503: GO 106512
106505: POP
// hHackChangeUnitSide ; 8 :
106506: CALL 118441 0 0
106510: GO 106528
106512: LD_INT 8
106514: DOUBLE
106515: EQUAL
106516: IFTRUE 106520
106518: GO 106527
106520: POP
// hHackFog ; end ;
106521: CALL 118542 0 0
106525: GO 106528
106527: POP
// end ; end ;
106528: LD_VAR 0 7
106532: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
106533: GO 106535
106535: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
106536: LD_STRING initStreamRollete();
106538: PPUSH
106539: CALL_OW 559
// InitStreamMode ;
106543: CALL 106552 0 0
// DefineStreamItems ( ) ;
106547: CALL 106992 0 0
// end ;
106551: END
// function InitStreamMode ; begin
106552: LD_INT 0
106554: PPUSH
// streamModeActive := false ;
106555: LD_ADDR_EXP 160
106559: PUSH
106560: LD_INT 0
106562: ST_TO_ADDR
// normalCounter := 36 ;
106563: LD_ADDR_EXP 161
106567: PUSH
106568: LD_INT 36
106570: ST_TO_ADDR
// hardcoreCounter := 16 ;
106571: LD_ADDR_EXP 162
106575: PUSH
106576: LD_INT 16
106578: ST_TO_ADDR
// sRocket := false ;
106579: LD_ADDR_EXP 165
106583: PUSH
106584: LD_INT 0
106586: ST_TO_ADDR
// sSpeed := false ;
106587: LD_ADDR_EXP 164
106591: PUSH
106592: LD_INT 0
106594: ST_TO_ADDR
// sEngine := false ;
106595: LD_ADDR_EXP 166
106599: PUSH
106600: LD_INT 0
106602: ST_TO_ADDR
// sSpec := false ;
106603: LD_ADDR_EXP 163
106607: PUSH
106608: LD_INT 0
106610: ST_TO_ADDR
// sLevel := false ;
106611: LD_ADDR_EXP 167
106615: PUSH
106616: LD_INT 0
106618: ST_TO_ADDR
// sArmoury := false ;
106619: LD_ADDR_EXP 168
106623: PUSH
106624: LD_INT 0
106626: ST_TO_ADDR
// sRadar := false ;
106627: LD_ADDR_EXP 169
106631: PUSH
106632: LD_INT 0
106634: ST_TO_ADDR
// sBunker := false ;
106635: LD_ADDR_EXP 170
106639: PUSH
106640: LD_INT 0
106642: ST_TO_ADDR
// sHack := false ;
106643: LD_ADDR_EXP 171
106647: PUSH
106648: LD_INT 0
106650: ST_TO_ADDR
// sFire := false ;
106651: LD_ADDR_EXP 172
106655: PUSH
106656: LD_INT 0
106658: ST_TO_ADDR
// sRefresh := false ;
106659: LD_ADDR_EXP 173
106663: PUSH
106664: LD_INT 0
106666: ST_TO_ADDR
// sExp := false ;
106667: LD_ADDR_EXP 174
106671: PUSH
106672: LD_INT 0
106674: ST_TO_ADDR
// sDepot := false ;
106675: LD_ADDR_EXP 175
106679: PUSH
106680: LD_INT 0
106682: ST_TO_ADDR
// sFlag := false ;
106683: LD_ADDR_EXP 176
106687: PUSH
106688: LD_INT 0
106690: ST_TO_ADDR
// sKamikadze := false ;
106691: LD_ADDR_EXP 184
106695: PUSH
106696: LD_INT 0
106698: ST_TO_ADDR
// sTroll := false ;
106699: LD_ADDR_EXP 185
106703: PUSH
106704: LD_INT 0
106706: ST_TO_ADDR
// sSlow := false ;
106707: LD_ADDR_EXP 186
106711: PUSH
106712: LD_INT 0
106714: ST_TO_ADDR
// sLack := false ;
106715: LD_ADDR_EXP 187
106719: PUSH
106720: LD_INT 0
106722: ST_TO_ADDR
// sTank := false ;
106723: LD_ADDR_EXP 189
106727: PUSH
106728: LD_INT 0
106730: ST_TO_ADDR
// sRemote := false ;
106731: LD_ADDR_EXP 190
106735: PUSH
106736: LD_INT 0
106738: ST_TO_ADDR
// sPowell := false ;
106739: LD_ADDR_EXP 191
106743: PUSH
106744: LD_INT 0
106746: ST_TO_ADDR
// sTeleport := false ;
106747: LD_ADDR_EXP 194
106751: PUSH
106752: LD_INT 0
106754: ST_TO_ADDR
// sOilTower := false ;
106755: LD_ADDR_EXP 196
106759: PUSH
106760: LD_INT 0
106762: ST_TO_ADDR
// sShovel := false ;
106763: LD_ADDR_EXP 197
106767: PUSH
106768: LD_INT 0
106770: ST_TO_ADDR
// sSheik := false ;
106771: LD_ADDR_EXP 198
106775: PUSH
106776: LD_INT 0
106778: ST_TO_ADDR
// sEarthquake := false ;
106779: LD_ADDR_EXP 200
106783: PUSH
106784: LD_INT 0
106786: ST_TO_ADDR
// sAI := false ;
106787: LD_ADDR_EXP 201
106791: PUSH
106792: LD_INT 0
106794: ST_TO_ADDR
// sCargo := false ;
106795: LD_ADDR_EXP 204
106799: PUSH
106800: LD_INT 0
106802: ST_TO_ADDR
// sDLaser := false ;
106803: LD_ADDR_EXP 205
106807: PUSH
106808: LD_INT 0
106810: ST_TO_ADDR
// sExchange := false ;
106811: LD_ADDR_EXP 206
106815: PUSH
106816: LD_INT 0
106818: ST_TO_ADDR
// sFac := false ;
106819: LD_ADDR_EXP 207
106823: PUSH
106824: LD_INT 0
106826: ST_TO_ADDR
// sPower := false ;
106827: LD_ADDR_EXP 208
106831: PUSH
106832: LD_INT 0
106834: ST_TO_ADDR
// sRandom := false ;
106835: LD_ADDR_EXP 209
106839: PUSH
106840: LD_INT 0
106842: ST_TO_ADDR
// sShield := false ;
106843: LD_ADDR_EXP 210
106847: PUSH
106848: LD_INT 0
106850: ST_TO_ADDR
// sTime := false ;
106851: LD_ADDR_EXP 211
106855: PUSH
106856: LD_INT 0
106858: ST_TO_ADDR
// sTools := false ;
106859: LD_ADDR_EXP 212
106863: PUSH
106864: LD_INT 0
106866: ST_TO_ADDR
// sSold := false ;
106867: LD_ADDR_EXP 177
106871: PUSH
106872: LD_INT 0
106874: ST_TO_ADDR
// sDiff := false ;
106875: LD_ADDR_EXP 178
106879: PUSH
106880: LD_INT 0
106882: ST_TO_ADDR
// sFog := false ;
106883: LD_ADDR_EXP 181
106887: PUSH
106888: LD_INT 0
106890: ST_TO_ADDR
// sReset := false ;
106891: LD_ADDR_EXP 182
106895: PUSH
106896: LD_INT 0
106898: ST_TO_ADDR
// sSun := false ;
106899: LD_ADDR_EXP 183
106903: PUSH
106904: LD_INT 0
106906: ST_TO_ADDR
// sTiger := false ;
106907: LD_ADDR_EXP 179
106911: PUSH
106912: LD_INT 0
106914: ST_TO_ADDR
// sBomb := false ;
106915: LD_ADDR_EXP 180
106919: PUSH
106920: LD_INT 0
106922: ST_TO_ADDR
// sWound := false ;
106923: LD_ADDR_EXP 188
106927: PUSH
106928: LD_INT 0
106930: ST_TO_ADDR
// sBetray := false ;
106931: LD_ADDR_EXP 192
106935: PUSH
106936: LD_INT 0
106938: ST_TO_ADDR
// sContamin := false ;
106939: LD_ADDR_EXP 193
106943: PUSH
106944: LD_INT 0
106946: ST_TO_ADDR
// sOil := false ;
106947: LD_ADDR_EXP 195
106951: PUSH
106952: LD_INT 0
106954: ST_TO_ADDR
// sStu := false ;
106955: LD_ADDR_EXP 199
106959: PUSH
106960: LD_INT 0
106962: ST_TO_ADDR
// sBazooka := false ;
106963: LD_ADDR_EXP 202
106967: PUSH
106968: LD_INT 0
106970: ST_TO_ADDR
// sMortar := false ;
106971: LD_ADDR_EXP 203
106975: PUSH
106976: LD_INT 0
106978: ST_TO_ADDR
// sRanger := false ;
106979: LD_ADDR_EXP 213
106983: PUSH
106984: LD_INT 0
106986: ST_TO_ADDR
// end ;
106987: LD_VAR 0 1
106991: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
106992: LD_INT 0
106994: PPUSH
106995: PPUSH
106996: PPUSH
106997: PPUSH
106998: PPUSH
// result := [ ] ;
106999: LD_ADDR_VAR 0 1
107003: PUSH
107004: EMPTY
107005: ST_TO_ADDR
// if campaign_id = 1 then
107006: LD_OWVAR 69
107010: PUSH
107011: LD_INT 1
107013: EQUAL
107014: IFFALSE 109952
// begin case mission_number of 1 :
107016: LD_OWVAR 70
107020: PUSH
107021: LD_INT 1
107023: DOUBLE
107024: EQUAL
107025: IFTRUE 107029
107027: GO 107093
107029: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
107030: LD_ADDR_VAR 0 1
107034: PUSH
107035: LD_INT 2
107037: PUSH
107038: LD_INT 4
107040: PUSH
107041: LD_INT 11
107043: PUSH
107044: LD_INT 12
107046: PUSH
107047: LD_INT 15
107049: PUSH
107050: LD_INT 16
107052: PUSH
107053: LD_INT 22
107055: PUSH
107056: LD_INT 23
107058: PUSH
107059: LD_INT 26
107061: PUSH
107062: EMPTY
107063: LIST
107064: LIST
107065: LIST
107066: LIST
107067: LIST
107068: LIST
107069: LIST
107070: LIST
107071: LIST
107072: PUSH
107073: LD_INT 101
107075: PUSH
107076: LD_INT 102
107078: PUSH
107079: LD_INT 106
107081: PUSH
107082: EMPTY
107083: LIST
107084: LIST
107085: LIST
107086: PUSH
107087: EMPTY
107088: LIST
107089: LIST
107090: ST_TO_ADDR
107091: GO 109950
107093: LD_INT 2
107095: DOUBLE
107096: EQUAL
107097: IFTRUE 107101
107099: GO 107173
107101: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
107102: LD_ADDR_VAR 0 1
107106: PUSH
107107: LD_INT 2
107109: PUSH
107110: LD_INT 4
107112: PUSH
107113: LD_INT 11
107115: PUSH
107116: LD_INT 12
107118: PUSH
107119: LD_INT 15
107121: PUSH
107122: LD_INT 16
107124: PUSH
107125: LD_INT 22
107127: PUSH
107128: LD_INT 23
107130: PUSH
107131: LD_INT 26
107133: PUSH
107134: EMPTY
107135: LIST
107136: LIST
107137: LIST
107138: LIST
107139: LIST
107140: LIST
107141: LIST
107142: LIST
107143: LIST
107144: PUSH
107145: LD_INT 101
107147: PUSH
107148: LD_INT 102
107150: PUSH
107151: LD_INT 105
107153: PUSH
107154: LD_INT 106
107156: PUSH
107157: LD_INT 108
107159: PUSH
107160: EMPTY
107161: LIST
107162: LIST
107163: LIST
107164: LIST
107165: LIST
107166: PUSH
107167: EMPTY
107168: LIST
107169: LIST
107170: ST_TO_ADDR
107171: GO 109950
107173: LD_INT 3
107175: DOUBLE
107176: EQUAL
107177: IFTRUE 107181
107179: GO 107257
107181: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
107182: LD_ADDR_VAR 0 1
107186: PUSH
107187: LD_INT 2
107189: PUSH
107190: LD_INT 4
107192: PUSH
107193: LD_INT 5
107195: PUSH
107196: LD_INT 11
107198: PUSH
107199: LD_INT 12
107201: PUSH
107202: LD_INT 15
107204: PUSH
107205: LD_INT 16
107207: PUSH
107208: LD_INT 22
107210: PUSH
107211: LD_INT 26
107213: PUSH
107214: LD_INT 36
107216: PUSH
107217: EMPTY
107218: LIST
107219: LIST
107220: LIST
107221: LIST
107222: LIST
107223: LIST
107224: LIST
107225: LIST
107226: LIST
107227: LIST
107228: PUSH
107229: LD_INT 101
107231: PUSH
107232: LD_INT 102
107234: PUSH
107235: LD_INT 105
107237: PUSH
107238: LD_INT 106
107240: PUSH
107241: LD_INT 108
107243: PUSH
107244: EMPTY
107245: LIST
107246: LIST
107247: LIST
107248: LIST
107249: LIST
107250: PUSH
107251: EMPTY
107252: LIST
107253: LIST
107254: ST_TO_ADDR
107255: GO 109950
107257: LD_INT 4
107259: DOUBLE
107260: EQUAL
107261: IFTRUE 107265
107263: GO 107349
107265: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
107266: LD_ADDR_VAR 0 1
107270: PUSH
107271: LD_INT 2
107273: PUSH
107274: LD_INT 4
107276: PUSH
107277: LD_INT 5
107279: PUSH
107280: LD_INT 8
107282: PUSH
107283: LD_INT 11
107285: PUSH
107286: LD_INT 12
107288: PUSH
107289: LD_INT 15
107291: PUSH
107292: LD_INT 16
107294: PUSH
107295: LD_INT 22
107297: PUSH
107298: LD_INT 23
107300: PUSH
107301: LD_INT 26
107303: PUSH
107304: LD_INT 36
107306: PUSH
107307: EMPTY
107308: LIST
107309: LIST
107310: LIST
107311: LIST
107312: LIST
107313: LIST
107314: LIST
107315: LIST
107316: LIST
107317: LIST
107318: LIST
107319: LIST
107320: PUSH
107321: LD_INT 101
107323: PUSH
107324: LD_INT 102
107326: PUSH
107327: LD_INT 105
107329: PUSH
107330: LD_INT 106
107332: PUSH
107333: LD_INT 108
107335: PUSH
107336: EMPTY
107337: LIST
107338: LIST
107339: LIST
107340: LIST
107341: LIST
107342: PUSH
107343: EMPTY
107344: LIST
107345: LIST
107346: ST_TO_ADDR
107347: GO 109950
107349: LD_INT 5
107351: DOUBLE
107352: EQUAL
107353: IFTRUE 107357
107355: GO 107457
107357: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
107358: LD_ADDR_VAR 0 1
107362: PUSH
107363: LD_INT 2
107365: PUSH
107366: LD_INT 4
107368: PUSH
107369: LD_INT 5
107371: PUSH
107372: LD_INT 6
107374: PUSH
107375: LD_INT 8
107377: PUSH
107378: LD_INT 11
107380: PUSH
107381: LD_INT 12
107383: PUSH
107384: LD_INT 15
107386: PUSH
107387: LD_INT 16
107389: PUSH
107390: LD_INT 22
107392: PUSH
107393: LD_INT 23
107395: PUSH
107396: LD_INT 25
107398: PUSH
107399: LD_INT 26
107401: PUSH
107402: LD_INT 36
107404: PUSH
107405: EMPTY
107406: LIST
107407: LIST
107408: LIST
107409: LIST
107410: LIST
107411: LIST
107412: LIST
107413: LIST
107414: LIST
107415: LIST
107416: LIST
107417: LIST
107418: LIST
107419: LIST
107420: PUSH
107421: LD_INT 101
107423: PUSH
107424: LD_INT 102
107426: PUSH
107427: LD_INT 105
107429: PUSH
107430: LD_INT 106
107432: PUSH
107433: LD_INT 108
107435: PUSH
107436: LD_INT 109
107438: PUSH
107439: LD_INT 112
107441: PUSH
107442: EMPTY
107443: LIST
107444: LIST
107445: LIST
107446: LIST
107447: LIST
107448: LIST
107449: LIST
107450: PUSH
107451: EMPTY
107452: LIST
107453: LIST
107454: ST_TO_ADDR
107455: GO 109950
107457: LD_INT 6
107459: DOUBLE
107460: EQUAL
107461: IFTRUE 107465
107463: GO 107585
107465: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
107466: LD_ADDR_VAR 0 1
107470: PUSH
107471: LD_INT 2
107473: PUSH
107474: LD_INT 4
107476: PUSH
107477: LD_INT 5
107479: PUSH
107480: LD_INT 6
107482: PUSH
107483: LD_INT 8
107485: PUSH
107486: LD_INT 11
107488: PUSH
107489: LD_INT 12
107491: PUSH
107492: LD_INT 15
107494: PUSH
107495: LD_INT 16
107497: PUSH
107498: LD_INT 20
107500: PUSH
107501: LD_INT 21
107503: PUSH
107504: LD_INT 22
107506: PUSH
107507: LD_INT 23
107509: PUSH
107510: LD_INT 25
107512: PUSH
107513: LD_INT 26
107515: PUSH
107516: LD_INT 30
107518: PUSH
107519: LD_INT 31
107521: PUSH
107522: LD_INT 32
107524: PUSH
107525: LD_INT 36
107527: PUSH
107528: EMPTY
107529: LIST
107530: LIST
107531: LIST
107532: LIST
107533: LIST
107534: LIST
107535: LIST
107536: LIST
107537: LIST
107538: LIST
107539: LIST
107540: LIST
107541: LIST
107542: LIST
107543: LIST
107544: LIST
107545: LIST
107546: LIST
107547: LIST
107548: PUSH
107549: LD_INT 101
107551: PUSH
107552: LD_INT 102
107554: PUSH
107555: LD_INT 105
107557: PUSH
107558: LD_INT 106
107560: PUSH
107561: LD_INT 108
107563: PUSH
107564: LD_INT 109
107566: PUSH
107567: LD_INT 112
107569: PUSH
107570: EMPTY
107571: LIST
107572: LIST
107573: LIST
107574: LIST
107575: LIST
107576: LIST
107577: LIST
107578: PUSH
107579: EMPTY
107580: LIST
107581: LIST
107582: ST_TO_ADDR
107583: GO 109950
107585: LD_INT 7
107587: DOUBLE
107588: EQUAL
107589: IFTRUE 107593
107591: GO 107693
107593: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
107594: LD_ADDR_VAR 0 1
107598: PUSH
107599: LD_INT 2
107601: PUSH
107602: LD_INT 4
107604: PUSH
107605: LD_INT 5
107607: PUSH
107608: LD_INT 7
107610: PUSH
107611: LD_INT 11
107613: PUSH
107614: LD_INT 12
107616: PUSH
107617: LD_INT 15
107619: PUSH
107620: LD_INT 16
107622: PUSH
107623: LD_INT 20
107625: PUSH
107626: LD_INT 21
107628: PUSH
107629: LD_INT 22
107631: PUSH
107632: LD_INT 23
107634: PUSH
107635: LD_INT 25
107637: PUSH
107638: LD_INT 26
107640: PUSH
107641: EMPTY
107642: LIST
107643: LIST
107644: LIST
107645: LIST
107646: LIST
107647: LIST
107648: LIST
107649: LIST
107650: LIST
107651: LIST
107652: LIST
107653: LIST
107654: LIST
107655: LIST
107656: PUSH
107657: LD_INT 101
107659: PUSH
107660: LD_INT 102
107662: PUSH
107663: LD_INT 103
107665: PUSH
107666: LD_INT 105
107668: PUSH
107669: LD_INT 106
107671: PUSH
107672: LD_INT 108
107674: PUSH
107675: LD_INT 112
107677: PUSH
107678: EMPTY
107679: LIST
107680: LIST
107681: LIST
107682: LIST
107683: LIST
107684: LIST
107685: LIST
107686: PUSH
107687: EMPTY
107688: LIST
107689: LIST
107690: ST_TO_ADDR
107691: GO 109950
107693: LD_INT 8
107695: DOUBLE
107696: EQUAL
107697: IFTRUE 107701
107699: GO 107829
107701: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
107702: LD_ADDR_VAR 0 1
107706: PUSH
107707: LD_INT 2
107709: PUSH
107710: LD_INT 4
107712: PUSH
107713: LD_INT 5
107715: PUSH
107716: LD_INT 6
107718: PUSH
107719: LD_INT 7
107721: PUSH
107722: LD_INT 8
107724: PUSH
107725: LD_INT 11
107727: PUSH
107728: LD_INT 12
107730: PUSH
107731: LD_INT 15
107733: PUSH
107734: LD_INT 16
107736: PUSH
107737: LD_INT 20
107739: PUSH
107740: LD_INT 21
107742: PUSH
107743: LD_INT 22
107745: PUSH
107746: LD_INT 23
107748: PUSH
107749: LD_INT 25
107751: PUSH
107752: LD_INT 26
107754: PUSH
107755: LD_INT 30
107757: PUSH
107758: LD_INT 31
107760: PUSH
107761: LD_INT 32
107763: PUSH
107764: LD_INT 36
107766: PUSH
107767: EMPTY
107768: LIST
107769: LIST
107770: LIST
107771: LIST
107772: LIST
107773: LIST
107774: LIST
107775: LIST
107776: LIST
107777: LIST
107778: LIST
107779: LIST
107780: LIST
107781: LIST
107782: LIST
107783: LIST
107784: LIST
107785: LIST
107786: LIST
107787: LIST
107788: PUSH
107789: LD_INT 101
107791: PUSH
107792: LD_INT 102
107794: PUSH
107795: LD_INT 103
107797: PUSH
107798: LD_INT 105
107800: PUSH
107801: LD_INT 106
107803: PUSH
107804: LD_INT 108
107806: PUSH
107807: LD_INT 109
107809: PUSH
107810: LD_INT 112
107812: PUSH
107813: EMPTY
107814: LIST
107815: LIST
107816: LIST
107817: LIST
107818: LIST
107819: LIST
107820: LIST
107821: LIST
107822: PUSH
107823: EMPTY
107824: LIST
107825: LIST
107826: ST_TO_ADDR
107827: GO 109950
107829: LD_INT 9
107831: DOUBLE
107832: EQUAL
107833: IFTRUE 107837
107835: GO 107973
107837: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
107838: LD_ADDR_VAR 0 1
107842: PUSH
107843: LD_INT 2
107845: PUSH
107846: LD_INT 4
107848: PUSH
107849: LD_INT 5
107851: PUSH
107852: LD_INT 6
107854: PUSH
107855: LD_INT 7
107857: PUSH
107858: LD_INT 8
107860: PUSH
107861: LD_INT 11
107863: PUSH
107864: LD_INT 12
107866: PUSH
107867: LD_INT 15
107869: PUSH
107870: LD_INT 16
107872: PUSH
107873: LD_INT 20
107875: PUSH
107876: LD_INT 21
107878: PUSH
107879: LD_INT 22
107881: PUSH
107882: LD_INT 23
107884: PUSH
107885: LD_INT 25
107887: PUSH
107888: LD_INT 26
107890: PUSH
107891: LD_INT 28
107893: PUSH
107894: LD_INT 30
107896: PUSH
107897: LD_INT 31
107899: PUSH
107900: LD_INT 32
107902: PUSH
107903: LD_INT 36
107905: PUSH
107906: EMPTY
107907: LIST
107908: LIST
107909: LIST
107910: LIST
107911: LIST
107912: LIST
107913: LIST
107914: LIST
107915: LIST
107916: LIST
107917: LIST
107918: LIST
107919: LIST
107920: LIST
107921: LIST
107922: LIST
107923: LIST
107924: LIST
107925: LIST
107926: LIST
107927: LIST
107928: PUSH
107929: LD_INT 101
107931: PUSH
107932: LD_INT 102
107934: PUSH
107935: LD_INT 103
107937: PUSH
107938: LD_INT 105
107940: PUSH
107941: LD_INT 106
107943: PUSH
107944: LD_INT 108
107946: PUSH
107947: LD_INT 109
107949: PUSH
107950: LD_INT 112
107952: PUSH
107953: LD_INT 114
107955: PUSH
107956: EMPTY
107957: LIST
107958: LIST
107959: LIST
107960: LIST
107961: LIST
107962: LIST
107963: LIST
107964: LIST
107965: LIST
107966: PUSH
107967: EMPTY
107968: LIST
107969: LIST
107970: ST_TO_ADDR
107971: GO 109950
107973: LD_INT 10
107975: DOUBLE
107976: EQUAL
107977: IFTRUE 107981
107979: GO 108165
107981: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
107982: LD_ADDR_VAR 0 1
107986: PUSH
107987: LD_INT 2
107989: PUSH
107990: LD_INT 4
107992: PUSH
107993: LD_INT 5
107995: PUSH
107996: LD_INT 6
107998: PUSH
107999: LD_INT 7
108001: PUSH
108002: LD_INT 8
108004: PUSH
108005: LD_INT 9
108007: PUSH
108008: LD_INT 10
108010: PUSH
108011: LD_INT 11
108013: PUSH
108014: LD_INT 12
108016: PUSH
108017: LD_INT 13
108019: PUSH
108020: LD_INT 14
108022: PUSH
108023: LD_INT 15
108025: PUSH
108026: LD_INT 16
108028: PUSH
108029: LD_INT 17
108031: PUSH
108032: LD_INT 18
108034: PUSH
108035: LD_INT 19
108037: PUSH
108038: LD_INT 20
108040: PUSH
108041: LD_INT 21
108043: PUSH
108044: LD_INT 22
108046: PUSH
108047: LD_INT 23
108049: PUSH
108050: LD_INT 24
108052: PUSH
108053: LD_INT 25
108055: PUSH
108056: LD_INT 26
108058: PUSH
108059: LD_INT 28
108061: PUSH
108062: LD_INT 30
108064: PUSH
108065: LD_INT 31
108067: PUSH
108068: LD_INT 32
108070: PUSH
108071: LD_INT 36
108073: PUSH
108074: EMPTY
108075: LIST
108076: LIST
108077: LIST
108078: LIST
108079: LIST
108080: LIST
108081: LIST
108082: LIST
108083: LIST
108084: LIST
108085: LIST
108086: LIST
108087: LIST
108088: LIST
108089: LIST
108090: LIST
108091: LIST
108092: LIST
108093: LIST
108094: LIST
108095: LIST
108096: LIST
108097: LIST
108098: LIST
108099: LIST
108100: LIST
108101: LIST
108102: LIST
108103: LIST
108104: PUSH
108105: LD_INT 101
108107: PUSH
108108: LD_INT 102
108110: PUSH
108111: LD_INT 103
108113: PUSH
108114: LD_INT 104
108116: PUSH
108117: LD_INT 105
108119: PUSH
108120: LD_INT 106
108122: PUSH
108123: LD_INT 107
108125: PUSH
108126: LD_INT 108
108128: PUSH
108129: LD_INT 109
108131: PUSH
108132: LD_INT 110
108134: PUSH
108135: LD_INT 111
108137: PUSH
108138: LD_INT 112
108140: PUSH
108141: LD_INT 114
108143: PUSH
108144: EMPTY
108145: LIST
108146: LIST
108147: LIST
108148: LIST
108149: LIST
108150: LIST
108151: LIST
108152: LIST
108153: LIST
108154: LIST
108155: LIST
108156: LIST
108157: LIST
108158: PUSH
108159: EMPTY
108160: LIST
108161: LIST
108162: ST_TO_ADDR
108163: GO 109950
108165: LD_INT 11
108167: DOUBLE
108168: EQUAL
108169: IFTRUE 108173
108171: GO 108365
108173: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
108174: LD_ADDR_VAR 0 1
108178: PUSH
108179: LD_INT 2
108181: PUSH
108182: LD_INT 3
108184: PUSH
108185: LD_INT 4
108187: PUSH
108188: LD_INT 5
108190: PUSH
108191: LD_INT 6
108193: PUSH
108194: LD_INT 7
108196: PUSH
108197: LD_INT 8
108199: PUSH
108200: LD_INT 9
108202: PUSH
108203: LD_INT 10
108205: PUSH
108206: LD_INT 11
108208: PUSH
108209: LD_INT 12
108211: PUSH
108212: LD_INT 13
108214: PUSH
108215: LD_INT 14
108217: PUSH
108218: LD_INT 15
108220: PUSH
108221: LD_INT 16
108223: PUSH
108224: LD_INT 17
108226: PUSH
108227: LD_INT 18
108229: PUSH
108230: LD_INT 19
108232: PUSH
108233: LD_INT 20
108235: PUSH
108236: LD_INT 21
108238: PUSH
108239: LD_INT 22
108241: PUSH
108242: LD_INT 23
108244: PUSH
108245: LD_INT 24
108247: PUSH
108248: LD_INT 25
108250: PUSH
108251: LD_INT 26
108253: PUSH
108254: LD_INT 28
108256: PUSH
108257: LD_INT 30
108259: PUSH
108260: LD_INT 31
108262: PUSH
108263: LD_INT 32
108265: PUSH
108266: LD_INT 34
108268: PUSH
108269: LD_INT 36
108271: PUSH
108272: EMPTY
108273: LIST
108274: LIST
108275: LIST
108276: LIST
108277: LIST
108278: LIST
108279: LIST
108280: LIST
108281: LIST
108282: LIST
108283: LIST
108284: LIST
108285: LIST
108286: LIST
108287: LIST
108288: LIST
108289: LIST
108290: LIST
108291: LIST
108292: LIST
108293: LIST
108294: LIST
108295: LIST
108296: LIST
108297: LIST
108298: LIST
108299: LIST
108300: LIST
108301: LIST
108302: LIST
108303: LIST
108304: PUSH
108305: LD_INT 101
108307: PUSH
108308: LD_INT 102
108310: PUSH
108311: LD_INT 103
108313: PUSH
108314: LD_INT 104
108316: PUSH
108317: LD_INT 105
108319: PUSH
108320: LD_INT 106
108322: PUSH
108323: LD_INT 107
108325: PUSH
108326: LD_INT 108
108328: PUSH
108329: LD_INT 109
108331: PUSH
108332: LD_INT 110
108334: PUSH
108335: LD_INT 111
108337: PUSH
108338: LD_INT 112
108340: PUSH
108341: LD_INT 114
108343: PUSH
108344: EMPTY
108345: LIST
108346: LIST
108347: LIST
108348: LIST
108349: LIST
108350: LIST
108351: LIST
108352: LIST
108353: LIST
108354: LIST
108355: LIST
108356: LIST
108357: LIST
108358: PUSH
108359: EMPTY
108360: LIST
108361: LIST
108362: ST_TO_ADDR
108363: GO 109950
108365: LD_INT 12
108367: DOUBLE
108368: EQUAL
108369: IFTRUE 108373
108371: GO 108581
108373: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
108374: LD_ADDR_VAR 0 1
108378: PUSH
108379: LD_INT 1
108381: PUSH
108382: LD_INT 2
108384: PUSH
108385: LD_INT 3
108387: PUSH
108388: LD_INT 4
108390: PUSH
108391: LD_INT 5
108393: PUSH
108394: LD_INT 6
108396: PUSH
108397: LD_INT 7
108399: PUSH
108400: LD_INT 8
108402: PUSH
108403: LD_INT 9
108405: PUSH
108406: LD_INT 10
108408: PUSH
108409: LD_INT 11
108411: PUSH
108412: LD_INT 12
108414: PUSH
108415: LD_INT 13
108417: PUSH
108418: LD_INT 14
108420: PUSH
108421: LD_INT 15
108423: PUSH
108424: LD_INT 16
108426: PUSH
108427: LD_INT 17
108429: PUSH
108430: LD_INT 18
108432: PUSH
108433: LD_INT 19
108435: PUSH
108436: LD_INT 20
108438: PUSH
108439: LD_INT 21
108441: PUSH
108442: LD_INT 22
108444: PUSH
108445: LD_INT 23
108447: PUSH
108448: LD_INT 24
108450: PUSH
108451: LD_INT 25
108453: PUSH
108454: LD_INT 26
108456: PUSH
108457: LD_INT 27
108459: PUSH
108460: LD_INT 28
108462: PUSH
108463: LD_INT 30
108465: PUSH
108466: LD_INT 31
108468: PUSH
108469: LD_INT 32
108471: PUSH
108472: LD_INT 33
108474: PUSH
108475: LD_INT 34
108477: PUSH
108478: LD_INT 36
108480: PUSH
108481: EMPTY
108482: LIST
108483: LIST
108484: LIST
108485: LIST
108486: LIST
108487: LIST
108488: LIST
108489: LIST
108490: LIST
108491: LIST
108492: LIST
108493: LIST
108494: LIST
108495: LIST
108496: LIST
108497: LIST
108498: LIST
108499: LIST
108500: LIST
108501: LIST
108502: LIST
108503: LIST
108504: LIST
108505: LIST
108506: LIST
108507: LIST
108508: LIST
108509: LIST
108510: LIST
108511: LIST
108512: LIST
108513: LIST
108514: LIST
108515: LIST
108516: PUSH
108517: LD_INT 101
108519: PUSH
108520: LD_INT 102
108522: PUSH
108523: LD_INT 103
108525: PUSH
108526: LD_INT 104
108528: PUSH
108529: LD_INT 105
108531: PUSH
108532: LD_INT 106
108534: PUSH
108535: LD_INT 107
108537: PUSH
108538: LD_INT 108
108540: PUSH
108541: LD_INT 109
108543: PUSH
108544: LD_INT 110
108546: PUSH
108547: LD_INT 111
108549: PUSH
108550: LD_INT 112
108552: PUSH
108553: LD_INT 113
108555: PUSH
108556: LD_INT 114
108558: PUSH
108559: EMPTY
108560: LIST
108561: LIST
108562: LIST
108563: LIST
108564: LIST
108565: LIST
108566: LIST
108567: LIST
108568: LIST
108569: LIST
108570: LIST
108571: LIST
108572: LIST
108573: LIST
108574: PUSH
108575: EMPTY
108576: LIST
108577: LIST
108578: ST_TO_ADDR
108579: GO 109950
108581: LD_INT 13
108583: DOUBLE
108584: EQUAL
108585: IFTRUE 108589
108587: GO 108785
108589: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
108590: LD_ADDR_VAR 0 1
108594: PUSH
108595: LD_INT 1
108597: PUSH
108598: LD_INT 2
108600: PUSH
108601: LD_INT 3
108603: PUSH
108604: LD_INT 4
108606: PUSH
108607: LD_INT 5
108609: PUSH
108610: LD_INT 8
108612: PUSH
108613: LD_INT 9
108615: PUSH
108616: LD_INT 10
108618: PUSH
108619: LD_INT 11
108621: PUSH
108622: LD_INT 12
108624: PUSH
108625: LD_INT 14
108627: PUSH
108628: LD_INT 15
108630: PUSH
108631: LD_INT 16
108633: PUSH
108634: LD_INT 17
108636: PUSH
108637: LD_INT 18
108639: PUSH
108640: LD_INT 19
108642: PUSH
108643: LD_INT 20
108645: PUSH
108646: LD_INT 21
108648: PUSH
108649: LD_INT 22
108651: PUSH
108652: LD_INT 23
108654: PUSH
108655: LD_INT 24
108657: PUSH
108658: LD_INT 25
108660: PUSH
108661: LD_INT 26
108663: PUSH
108664: LD_INT 27
108666: PUSH
108667: LD_INT 28
108669: PUSH
108670: LD_INT 30
108672: PUSH
108673: LD_INT 31
108675: PUSH
108676: LD_INT 32
108678: PUSH
108679: LD_INT 33
108681: PUSH
108682: LD_INT 34
108684: PUSH
108685: LD_INT 36
108687: PUSH
108688: EMPTY
108689: LIST
108690: LIST
108691: LIST
108692: LIST
108693: LIST
108694: LIST
108695: LIST
108696: LIST
108697: LIST
108698: LIST
108699: LIST
108700: LIST
108701: LIST
108702: LIST
108703: LIST
108704: LIST
108705: LIST
108706: LIST
108707: LIST
108708: LIST
108709: LIST
108710: LIST
108711: LIST
108712: LIST
108713: LIST
108714: LIST
108715: LIST
108716: LIST
108717: LIST
108718: LIST
108719: LIST
108720: PUSH
108721: LD_INT 101
108723: PUSH
108724: LD_INT 102
108726: PUSH
108727: LD_INT 103
108729: PUSH
108730: LD_INT 104
108732: PUSH
108733: LD_INT 105
108735: PUSH
108736: LD_INT 106
108738: PUSH
108739: LD_INT 107
108741: PUSH
108742: LD_INT 108
108744: PUSH
108745: LD_INT 109
108747: PUSH
108748: LD_INT 110
108750: PUSH
108751: LD_INT 111
108753: PUSH
108754: LD_INT 112
108756: PUSH
108757: LD_INT 113
108759: PUSH
108760: LD_INT 114
108762: PUSH
108763: EMPTY
108764: LIST
108765: LIST
108766: LIST
108767: LIST
108768: LIST
108769: LIST
108770: LIST
108771: LIST
108772: LIST
108773: LIST
108774: LIST
108775: LIST
108776: LIST
108777: LIST
108778: PUSH
108779: EMPTY
108780: LIST
108781: LIST
108782: ST_TO_ADDR
108783: GO 109950
108785: LD_INT 14
108787: DOUBLE
108788: EQUAL
108789: IFTRUE 108793
108791: GO 109005
108793: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
108794: LD_ADDR_VAR 0 1
108798: PUSH
108799: LD_INT 1
108801: PUSH
108802: LD_INT 2
108804: PUSH
108805: LD_INT 3
108807: PUSH
108808: LD_INT 4
108810: PUSH
108811: LD_INT 5
108813: PUSH
108814: LD_INT 6
108816: PUSH
108817: LD_INT 7
108819: PUSH
108820: LD_INT 8
108822: PUSH
108823: LD_INT 9
108825: PUSH
108826: LD_INT 10
108828: PUSH
108829: LD_INT 11
108831: PUSH
108832: LD_INT 12
108834: PUSH
108835: LD_INT 13
108837: PUSH
108838: LD_INT 14
108840: PUSH
108841: LD_INT 15
108843: PUSH
108844: LD_INT 16
108846: PUSH
108847: LD_INT 17
108849: PUSH
108850: LD_INT 18
108852: PUSH
108853: LD_INT 19
108855: PUSH
108856: LD_INT 20
108858: PUSH
108859: LD_INT 21
108861: PUSH
108862: LD_INT 22
108864: PUSH
108865: LD_INT 23
108867: PUSH
108868: LD_INT 24
108870: PUSH
108871: LD_INT 25
108873: PUSH
108874: LD_INT 26
108876: PUSH
108877: LD_INT 27
108879: PUSH
108880: LD_INT 28
108882: PUSH
108883: LD_INT 29
108885: PUSH
108886: LD_INT 30
108888: PUSH
108889: LD_INT 31
108891: PUSH
108892: LD_INT 32
108894: PUSH
108895: LD_INT 33
108897: PUSH
108898: LD_INT 34
108900: PUSH
108901: LD_INT 36
108903: PUSH
108904: EMPTY
108905: LIST
108906: LIST
108907: LIST
108908: LIST
108909: LIST
108910: LIST
108911: LIST
108912: LIST
108913: LIST
108914: LIST
108915: LIST
108916: LIST
108917: LIST
108918: LIST
108919: LIST
108920: LIST
108921: LIST
108922: LIST
108923: LIST
108924: LIST
108925: LIST
108926: LIST
108927: LIST
108928: LIST
108929: LIST
108930: LIST
108931: LIST
108932: LIST
108933: LIST
108934: LIST
108935: LIST
108936: LIST
108937: LIST
108938: LIST
108939: LIST
108940: PUSH
108941: LD_INT 101
108943: PUSH
108944: LD_INT 102
108946: PUSH
108947: LD_INT 103
108949: PUSH
108950: LD_INT 104
108952: PUSH
108953: LD_INT 105
108955: PUSH
108956: LD_INT 106
108958: PUSH
108959: LD_INT 107
108961: PUSH
108962: LD_INT 108
108964: PUSH
108965: LD_INT 109
108967: PUSH
108968: LD_INT 110
108970: PUSH
108971: LD_INT 111
108973: PUSH
108974: LD_INT 112
108976: PUSH
108977: LD_INT 113
108979: PUSH
108980: LD_INT 114
108982: PUSH
108983: EMPTY
108984: LIST
108985: LIST
108986: LIST
108987: LIST
108988: LIST
108989: LIST
108990: LIST
108991: LIST
108992: LIST
108993: LIST
108994: LIST
108995: LIST
108996: LIST
108997: LIST
108998: PUSH
108999: EMPTY
109000: LIST
109001: LIST
109002: ST_TO_ADDR
109003: GO 109950
109005: LD_INT 15
109007: DOUBLE
109008: EQUAL
109009: IFTRUE 109013
109011: GO 109225
109013: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
109014: LD_ADDR_VAR 0 1
109018: PUSH
109019: LD_INT 1
109021: PUSH
109022: LD_INT 2
109024: PUSH
109025: LD_INT 3
109027: PUSH
109028: LD_INT 4
109030: PUSH
109031: LD_INT 5
109033: PUSH
109034: LD_INT 6
109036: PUSH
109037: LD_INT 7
109039: PUSH
109040: LD_INT 8
109042: PUSH
109043: LD_INT 9
109045: PUSH
109046: LD_INT 10
109048: PUSH
109049: LD_INT 11
109051: PUSH
109052: LD_INT 12
109054: PUSH
109055: LD_INT 13
109057: PUSH
109058: LD_INT 14
109060: PUSH
109061: LD_INT 15
109063: PUSH
109064: LD_INT 16
109066: PUSH
109067: LD_INT 17
109069: PUSH
109070: LD_INT 18
109072: PUSH
109073: LD_INT 19
109075: PUSH
109076: LD_INT 20
109078: PUSH
109079: LD_INT 21
109081: PUSH
109082: LD_INT 22
109084: PUSH
109085: LD_INT 23
109087: PUSH
109088: LD_INT 24
109090: PUSH
109091: LD_INT 25
109093: PUSH
109094: LD_INT 26
109096: PUSH
109097: LD_INT 27
109099: PUSH
109100: LD_INT 28
109102: PUSH
109103: LD_INT 29
109105: PUSH
109106: LD_INT 30
109108: PUSH
109109: LD_INT 31
109111: PUSH
109112: LD_INT 32
109114: PUSH
109115: LD_INT 33
109117: PUSH
109118: LD_INT 34
109120: PUSH
109121: LD_INT 36
109123: PUSH
109124: EMPTY
109125: LIST
109126: LIST
109127: LIST
109128: LIST
109129: LIST
109130: LIST
109131: LIST
109132: LIST
109133: LIST
109134: LIST
109135: LIST
109136: LIST
109137: LIST
109138: LIST
109139: LIST
109140: LIST
109141: LIST
109142: LIST
109143: LIST
109144: LIST
109145: LIST
109146: LIST
109147: LIST
109148: LIST
109149: LIST
109150: LIST
109151: LIST
109152: LIST
109153: LIST
109154: LIST
109155: LIST
109156: LIST
109157: LIST
109158: LIST
109159: LIST
109160: PUSH
109161: LD_INT 101
109163: PUSH
109164: LD_INT 102
109166: PUSH
109167: LD_INT 103
109169: PUSH
109170: LD_INT 104
109172: PUSH
109173: LD_INT 105
109175: PUSH
109176: LD_INT 106
109178: PUSH
109179: LD_INT 107
109181: PUSH
109182: LD_INT 108
109184: PUSH
109185: LD_INT 109
109187: PUSH
109188: LD_INT 110
109190: PUSH
109191: LD_INT 111
109193: PUSH
109194: LD_INT 112
109196: PUSH
109197: LD_INT 113
109199: PUSH
109200: LD_INT 114
109202: PUSH
109203: EMPTY
109204: LIST
109205: LIST
109206: LIST
109207: LIST
109208: LIST
109209: LIST
109210: LIST
109211: LIST
109212: LIST
109213: LIST
109214: LIST
109215: LIST
109216: LIST
109217: LIST
109218: PUSH
109219: EMPTY
109220: LIST
109221: LIST
109222: ST_TO_ADDR
109223: GO 109950
109225: LD_INT 16
109227: DOUBLE
109228: EQUAL
109229: IFTRUE 109233
109231: GO 109357
109233: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
109234: LD_ADDR_VAR 0 1
109238: PUSH
109239: LD_INT 2
109241: PUSH
109242: LD_INT 4
109244: PUSH
109245: LD_INT 5
109247: PUSH
109248: LD_INT 7
109250: PUSH
109251: LD_INT 11
109253: PUSH
109254: LD_INT 12
109256: PUSH
109257: LD_INT 15
109259: PUSH
109260: LD_INT 16
109262: PUSH
109263: LD_INT 20
109265: PUSH
109266: LD_INT 21
109268: PUSH
109269: LD_INT 22
109271: PUSH
109272: LD_INT 23
109274: PUSH
109275: LD_INT 25
109277: PUSH
109278: LD_INT 26
109280: PUSH
109281: LD_INT 30
109283: PUSH
109284: LD_INT 31
109286: PUSH
109287: LD_INT 32
109289: PUSH
109290: LD_INT 33
109292: PUSH
109293: LD_INT 34
109295: PUSH
109296: EMPTY
109297: LIST
109298: LIST
109299: LIST
109300: LIST
109301: LIST
109302: LIST
109303: LIST
109304: LIST
109305: LIST
109306: LIST
109307: LIST
109308: LIST
109309: LIST
109310: LIST
109311: LIST
109312: LIST
109313: LIST
109314: LIST
109315: LIST
109316: PUSH
109317: LD_INT 101
109319: PUSH
109320: LD_INT 102
109322: PUSH
109323: LD_INT 103
109325: PUSH
109326: LD_INT 106
109328: PUSH
109329: LD_INT 108
109331: PUSH
109332: LD_INT 112
109334: PUSH
109335: LD_INT 113
109337: PUSH
109338: LD_INT 114
109340: PUSH
109341: EMPTY
109342: LIST
109343: LIST
109344: LIST
109345: LIST
109346: LIST
109347: LIST
109348: LIST
109349: LIST
109350: PUSH
109351: EMPTY
109352: LIST
109353: LIST
109354: ST_TO_ADDR
109355: GO 109950
109357: LD_INT 17
109359: DOUBLE
109360: EQUAL
109361: IFTRUE 109365
109363: GO 109577
109365: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
109366: LD_ADDR_VAR 0 1
109370: PUSH
109371: LD_INT 1
109373: PUSH
109374: LD_INT 2
109376: PUSH
109377: LD_INT 3
109379: PUSH
109380: LD_INT 4
109382: PUSH
109383: LD_INT 5
109385: PUSH
109386: LD_INT 6
109388: PUSH
109389: LD_INT 7
109391: PUSH
109392: LD_INT 8
109394: PUSH
109395: LD_INT 9
109397: PUSH
109398: LD_INT 10
109400: PUSH
109401: LD_INT 11
109403: PUSH
109404: LD_INT 12
109406: PUSH
109407: LD_INT 13
109409: PUSH
109410: LD_INT 14
109412: PUSH
109413: LD_INT 15
109415: PUSH
109416: LD_INT 16
109418: PUSH
109419: LD_INT 17
109421: PUSH
109422: LD_INT 18
109424: PUSH
109425: LD_INT 19
109427: PUSH
109428: LD_INT 20
109430: PUSH
109431: LD_INT 21
109433: PUSH
109434: LD_INT 22
109436: PUSH
109437: LD_INT 23
109439: PUSH
109440: LD_INT 24
109442: PUSH
109443: LD_INT 25
109445: PUSH
109446: LD_INT 26
109448: PUSH
109449: LD_INT 27
109451: PUSH
109452: LD_INT 28
109454: PUSH
109455: LD_INT 29
109457: PUSH
109458: LD_INT 30
109460: PUSH
109461: LD_INT 31
109463: PUSH
109464: LD_INT 32
109466: PUSH
109467: LD_INT 33
109469: PUSH
109470: LD_INT 34
109472: PUSH
109473: LD_INT 36
109475: PUSH
109476: EMPTY
109477: LIST
109478: LIST
109479: LIST
109480: LIST
109481: LIST
109482: LIST
109483: LIST
109484: LIST
109485: LIST
109486: LIST
109487: LIST
109488: LIST
109489: LIST
109490: LIST
109491: LIST
109492: LIST
109493: LIST
109494: LIST
109495: LIST
109496: LIST
109497: LIST
109498: LIST
109499: LIST
109500: LIST
109501: LIST
109502: LIST
109503: LIST
109504: LIST
109505: LIST
109506: LIST
109507: LIST
109508: LIST
109509: LIST
109510: LIST
109511: LIST
109512: PUSH
109513: LD_INT 101
109515: PUSH
109516: LD_INT 102
109518: PUSH
109519: LD_INT 103
109521: PUSH
109522: LD_INT 104
109524: PUSH
109525: LD_INT 105
109527: PUSH
109528: LD_INT 106
109530: PUSH
109531: LD_INT 107
109533: PUSH
109534: LD_INT 108
109536: PUSH
109537: LD_INT 109
109539: PUSH
109540: LD_INT 110
109542: PUSH
109543: LD_INT 111
109545: PUSH
109546: LD_INT 112
109548: PUSH
109549: LD_INT 113
109551: PUSH
109552: LD_INT 114
109554: PUSH
109555: EMPTY
109556: LIST
109557: LIST
109558: LIST
109559: LIST
109560: LIST
109561: LIST
109562: LIST
109563: LIST
109564: LIST
109565: LIST
109566: LIST
109567: LIST
109568: LIST
109569: LIST
109570: PUSH
109571: EMPTY
109572: LIST
109573: LIST
109574: ST_TO_ADDR
109575: GO 109950
109577: LD_INT 18
109579: DOUBLE
109580: EQUAL
109581: IFTRUE 109585
109583: GO 109721
109585: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
109586: LD_ADDR_VAR 0 1
109590: PUSH
109591: LD_INT 2
109593: PUSH
109594: LD_INT 4
109596: PUSH
109597: LD_INT 5
109599: PUSH
109600: LD_INT 7
109602: PUSH
109603: LD_INT 11
109605: PUSH
109606: LD_INT 12
109608: PUSH
109609: LD_INT 15
109611: PUSH
109612: LD_INT 16
109614: PUSH
109615: LD_INT 20
109617: PUSH
109618: LD_INT 21
109620: PUSH
109621: LD_INT 22
109623: PUSH
109624: LD_INT 23
109626: PUSH
109627: LD_INT 25
109629: PUSH
109630: LD_INT 26
109632: PUSH
109633: LD_INT 30
109635: PUSH
109636: LD_INT 31
109638: PUSH
109639: LD_INT 32
109641: PUSH
109642: LD_INT 33
109644: PUSH
109645: LD_INT 34
109647: PUSH
109648: LD_INT 35
109650: PUSH
109651: LD_INT 36
109653: PUSH
109654: EMPTY
109655: LIST
109656: LIST
109657: LIST
109658: LIST
109659: LIST
109660: LIST
109661: LIST
109662: LIST
109663: LIST
109664: LIST
109665: LIST
109666: LIST
109667: LIST
109668: LIST
109669: LIST
109670: LIST
109671: LIST
109672: LIST
109673: LIST
109674: LIST
109675: LIST
109676: PUSH
109677: LD_INT 101
109679: PUSH
109680: LD_INT 102
109682: PUSH
109683: LD_INT 103
109685: PUSH
109686: LD_INT 106
109688: PUSH
109689: LD_INT 108
109691: PUSH
109692: LD_INT 112
109694: PUSH
109695: LD_INT 113
109697: PUSH
109698: LD_INT 114
109700: PUSH
109701: LD_INT 115
109703: PUSH
109704: EMPTY
109705: LIST
109706: LIST
109707: LIST
109708: LIST
109709: LIST
109710: LIST
109711: LIST
109712: LIST
109713: LIST
109714: PUSH
109715: EMPTY
109716: LIST
109717: LIST
109718: ST_TO_ADDR
109719: GO 109950
109721: LD_INT 19
109723: DOUBLE
109724: EQUAL
109725: IFTRUE 109729
109727: GO 109949
109729: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
109730: LD_ADDR_VAR 0 1
109734: PUSH
109735: LD_INT 1
109737: PUSH
109738: LD_INT 2
109740: PUSH
109741: LD_INT 3
109743: PUSH
109744: LD_INT 4
109746: PUSH
109747: LD_INT 5
109749: PUSH
109750: LD_INT 6
109752: PUSH
109753: LD_INT 7
109755: PUSH
109756: LD_INT 8
109758: PUSH
109759: LD_INT 9
109761: PUSH
109762: LD_INT 10
109764: PUSH
109765: LD_INT 11
109767: PUSH
109768: LD_INT 12
109770: PUSH
109771: LD_INT 13
109773: PUSH
109774: LD_INT 14
109776: PUSH
109777: LD_INT 15
109779: PUSH
109780: LD_INT 16
109782: PUSH
109783: LD_INT 17
109785: PUSH
109786: LD_INT 18
109788: PUSH
109789: LD_INT 19
109791: PUSH
109792: LD_INT 20
109794: PUSH
109795: LD_INT 21
109797: PUSH
109798: LD_INT 22
109800: PUSH
109801: LD_INT 23
109803: PUSH
109804: LD_INT 24
109806: PUSH
109807: LD_INT 25
109809: PUSH
109810: LD_INT 26
109812: PUSH
109813: LD_INT 27
109815: PUSH
109816: LD_INT 28
109818: PUSH
109819: LD_INT 29
109821: PUSH
109822: LD_INT 30
109824: PUSH
109825: LD_INT 31
109827: PUSH
109828: LD_INT 32
109830: PUSH
109831: LD_INT 33
109833: PUSH
109834: LD_INT 34
109836: PUSH
109837: LD_INT 35
109839: PUSH
109840: LD_INT 36
109842: PUSH
109843: EMPTY
109844: LIST
109845: LIST
109846: LIST
109847: LIST
109848: LIST
109849: LIST
109850: LIST
109851: LIST
109852: LIST
109853: LIST
109854: LIST
109855: LIST
109856: LIST
109857: LIST
109858: LIST
109859: LIST
109860: LIST
109861: LIST
109862: LIST
109863: LIST
109864: LIST
109865: LIST
109866: LIST
109867: LIST
109868: LIST
109869: LIST
109870: LIST
109871: LIST
109872: LIST
109873: LIST
109874: LIST
109875: LIST
109876: LIST
109877: LIST
109878: LIST
109879: LIST
109880: PUSH
109881: LD_INT 101
109883: PUSH
109884: LD_INT 102
109886: PUSH
109887: LD_INT 103
109889: PUSH
109890: LD_INT 104
109892: PUSH
109893: LD_INT 105
109895: PUSH
109896: LD_INT 106
109898: PUSH
109899: LD_INT 107
109901: PUSH
109902: LD_INT 108
109904: PUSH
109905: LD_INT 109
109907: PUSH
109908: LD_INT 110
109910: PUSH
109911: LD_INT 111
109913: PUSH
109914: LD_INT 112
109916: PUSH
109917: LD_INT 113
109919: PUSH
109920: LD_INT 114
109922: PUSH
109923: LD_INT 115
109925: PUSH
109926: EMPTY
109927: LIST
109928: LIST
109929: LIST
109930: LIST
109931: LIST
109932: LIST
109933: LIST
109934: LIST
109935: LIST
109936: LIST
109937: LIST
109938: LIST
109939: LIST
109940: LIST
109941: LIST
109942: PUSH
109943: EMPTY
109944: LIST
109945: LIST
109946: ST_TO_ADDR
109947: GO 109950
109949: POP
// end else
109950: GO 110169
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
109952: LD_ADDR_VAR 0 1
109956: PUSH
109957: LD_INT 1
109959: PUSH
109960: LD_INT 2
109962: PUSH
109963: LD_INT 3
109965: PUSH
109966: LD_INT 4
109968: PUSH
109969: LD_INT 5
109971: PUSH
109972: LD_INT 6
109974: PUSH
109975: LD_INT 7
109977: PUSH
109978: LD_INT 8
109980: PUSH
109981: LD_INT 9
109983: PUSH
109984: LD_INT 10
109986: PUSH
109987: LD_INT 11
109989: PUSH
109990: LD_INT 12
109992: PUSH
109993: LD_INT 13
109995: PUSH
109996: LD_INT 14
109998: PUSH
109999: LD_INT 15
110001: PUSH
110002: LD_INT 16
110004: PUSH
110005: LD_INT 17
110007: PUSH
110008: LD_INT 18
110010: PUSH
110011: LD_INT 19
110013: PUSH
110014: LD_INT 20
110016: PUSH
110017: LD_INT 21
110019: PUSH
110020: LD_INT 22
110022: PUSH
110023: LD_INT 23
110025: PUSH
110026: LD_INT 24
110028: PUSH
110029: LD_INT 25
110031: PUSH
110032: LD_INT 26
110034: PUSH
110035: LD_INT 27
110037: PUSH
110038: LD_INT 28
110040: PUSH
110041: LD_INT 29
110043: PUSH
110044: LD_INT 30
110046: PUSH
110047: LD_INT 31
110049: PUSH
110050: LD_INT 32
110052: PUSH
110053: LD_INT 33
110055: PUSH
110056: LD_INT 34
110058: PUSH
110059: LD_INT 35
110061: PUSH
110062: LD_INT 36
110064: PUSH
110065: EMPTY
110066: LIST
110067: LIST
110068: LIST
110069: LIST
110070: LIST
110071: LIST
110072: LIST
110073: LIST
110074: LIST
110075: LIST
110076: LIST
110077: LIST
110078: LIST
110079: LIST
110080: LIST
110081: LIST
110082: LIST
110083: LIST
110084: LIST
110085: LIST
110086: LIST
110087: LIST
110088: LIST
110089: LIST
110090: LIST
110091: LIST
110092: LIST
110093: LIST
110094: LIST
110095: LIST
110096: LIST
110097: LIST
110098: LIST
110099: LIST
110100: LIST
110101: LIST
110102: PUSH
110103: LD_INT 101
110105: PUSH
110106: LD_INT 102
110108: PUSH
110109: LD_INT 103
110111: PUSH
110112: LD_INT 104
110114: PUSH
110115: LD_INT 105
110117: PUSH
110118: LD_INT 106
110120: PUSH
110121: LD_INT 107
110123: PUSH
110124: LD_INT 108
110126: PUSH
110127: LD_INT 109
110129: PUSH
110130: LD_INT 110
110132: PUSH
110133: LD_INT 111
110135: PUSH
110136: LD_INT 112
110138: PUSH
110139: LD_INT 113
110141: PUSH
110142: LD_INT 114
110144: PUSH
110145: LD_INT 115
110147: PUSH
110148: EMPTY
110149: LIST
110150: LIST
110151: LIST
110152: LIST
110153: LIST
110154: LIST
110155: LIST
110156: LIST
110157: LIST
110158: LIST
110159: LIST
110160: LIST
110161: LIST
110162: LIST
110163: LIST
110164: PUSH
110165: EMPTY
110166: LIST
110167: LIST
110168: ST_TO_ADDR
// if result then
110169: LD_VAR 0 1
110173: IFFALSE 110462
// begin normal :=  ;
110175: LD_ADDR_VAR 0 3
110179: PUSH
110180: LD_STRING 
110182: ST_TO_ADDR
// hardcore :=  ;
110183: LD_ADDR_VAR 0 4
110187: PUSH
110188: LD_STRING 
110190: ST_TO_ADDR
// for i = 1 to normalCounter do
110191: LD_ADDR_VAR 0 5
110195: PUSH
110196: DOUBLE
110197: LD_INT 1
110199: DEC
110200: ST_TO_ADDR
110201: LD_EXP 161
110205: PUSH
110206: FOR_TO
110207: IFFALSE 110308
// begin tmp := 0 ;
110209: LD_ADDR_VAR 0 2
110213: PUSH
110214: LD_STRING 0
110216: ST_TO_ADDR
// if result [ 1 ] then
110217: LD_VAR 0 1
110221: PUSH
110222: LD_INT 1
110224: ARRAY
110225: IFFALSE 110290
// if result [ 1 ] [ 1 ] = i then
110227: LD_VAR 0 1
110231: PUSH
110232: LD_INT 1
110234: ARRAY
110235: PUSH
110236: LD_INT 1
110238: ARRAY
110239: PUSH
110240: LD_VAR 0 5
110244: EQUAL
110245: IFFALSE 110290
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
110247: LD_ADDR_VAR 0 1
110251: PUSH
110252: LD_VAR 0 1
110256: PPUSH
110257: LD_INT 1
110259: PPUSH
110260: LD_VAR 0 1
110264: PUSH
110265: LD_INT 1
110267: ARRAY
110268: PPUSH
110269: LD_INT 1
110271: PPUSH
110272: CALL_OW 3
110276: PPUSH
110277: CALL_OW 1
110281: ST_TO_ADDR
// tmp := 1 ;
110282: LD_ADDR_VAR 0 2
110286: PUSH
110287: LD_STRING 1
110289: ST_TO_ADDR
// end ; normal := normal & tmp ;
110290: LD_ADDR_VAR 0 3
110294: PUSH
110295: LD_VAR 0 3
110299: PUSH
110300: LD_VAR 0 2
110304: STR
110305: ST_TO_ADDR
// end ;
110306: GO 110206
110308: POP
110309: POP
// for i = 1 to hardcoreCounter do
110310: LD_ADDR_VAR 0 5
110314: PUSH
110315: DOUBLE
110316: LD_INT 1
110318: DEC
110319: ST_TO_ADDR
110320: LD_EXP 162
110324: PUSH
110325: FOR_TO
110326: IFFALSE 110431
// begin tmp := 0 ;
110328: LD_ADDR_VAR 0 2
110332: PUSH
110333: LD_STRING 0
110335: ST_TO_ADDR
// if result [ 2 ] then
110336: LD_VAR 0 1
110340: PUSH
110341: LD_INT 2
110343: ARRAY
110344: IFFALSE 110413
// if result [ 2 ] [ 1 ] = 100 + i then
110346: LD_VAR 0 1
110350: PUSH
110351: LD_INT 2
110353: ARRAY
110354: PUSH
110355: LD_INT 1
110357: ARRAY
110358: PUSH
110359: LD_INT 100
110361: PUSH
110362: LD_VAR 0 5
110366: PLUS
110367: EQUAL
110368: IFFALSE 110413
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
110370: LD_ADDR_VAR 0 1
110374: PUSH
110375: LD_VAR 0 1
110379: PPUSH
110380: LD_INT 2
110382: PPUSH
110383: LD_VAR 0 1
110387: PUSH
110388: LD_INT 2
110390: ARRAY
110391: PPUSH
110392: LD_INT 1
110394: PPUSH
110395: CALL_OW 3
110399: PPUSH
110400: CALL_OW 1
110404: ST_TO_ADDR
// tmp := 1 ;
110405: LD_ADDR_VAR 0 2
110409: PUSH
110410: LD_STRING 1
110412: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
110413: LD_ADDR_VAR 0 4
110417: PUSH
110418: LD_VAR 0 4
110422: PUSH
110423: LD_VAR 0 2
110427: STR
110428: ST_TO_ADDR
// end ;
110429: GO 110325
110431: POP
110432: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
110433: LD_STRING getStreamItemsFromMission("
110435: PUSH
110436: LD_VAR 0 3
110440: STR
110441: PUSH
110442: LD_STRING ","
110444: STR
110445: PUSH
110446: LD_VAR 0 4
110450: STR
110451: PUSH
110452: LD_STRING ")
110454: STR
110455: PPUSH
110456: CALL_OW 559
// end else
110460: GO 110469
// ToLua ( getStreamItemsFromMission("","") ) ;
110462: LD_STRING getStreamItemsFromMission("","")
110464: PPUSH
110465: CALL_OW 559
// end ;
110469: LD_VAR 0 1
110473: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
110474: LD_EXP 160
110478: PUSH
110479: LD_EXP 165
110483: AND
110484: IFFALSE 110608
110486: GO 110488
110488: DISABLE
110489: LD_INT 0
110491: PPUSH
110492: PPUSH
// begin enable ;
110493: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
110494: LD_ADDR_VAR 0 2
110498: PUSH
110499: LD_INT 22
110501: PUSH
110502: LD_OWVAR 2
110506: PUSH
110507: EMPTY
110508: LIST
110509: LIST
110510: PUSH
110511: LD_INT 2
110513: PUSH
110514: LD_INT 34
110516: PUSH
110517: LD_INT 7
110519: PUSH
110520: EMPTY
110521: LIST
110522: LIST
110523: PUSH
110524: LD_INT 34
110526: PUSH
110527: LD_INT 45
110529: PUSH
110530: EMPTY
110531: LIST
110532: LIST
110533: PUSH
110534: LD_INT 34
110536: PUSH
110537: LD_INT 28
110539: PUSH
110540: EMPTY
110541: LIST
110542: LIST
110543: PUSH
110544: LD_INT 34
110546: PUSH
110547: LD_INT 47
110549: PUSH
110550: EMPTY
110551: LIST
110552: LIST
110553: PUSH
110554: EMPTY
110555: LIST
110556: LIST
110557: LIST
110558: LIST
110559: LIST
110560: PUSH
110561: EMPTY
110562: LIST
110563: LIST
110564: PPUSH
110565: CALL_OW 69
110569: ST_TO_ADDR
// if not tmp then
110570: LD_VAR 0 2
110574: NOT
110575: IFFALSE 110579
// exit ;
110577: GO 110608
// for i in tmp do
110579: LD_ADDR_VAR 0 1
110583: PUSH
110584: LD_VAR 0 2
110588: PUSH
110589: FOR_IN
110590: IFFALSE 110606
// begin SetLives ( i , 0 ) ;
110592: LD_VAR 0 1
110596: PPUSH
110597: LD_INT 0
110599: PPUSH
110600: CALL_OW 234
// end ;
110604: GO 110589
110606: POP
110607: POP
// end ;
110608: PPOPN 2
110610: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
110611: LD_EXP 160
110615: PUSH
110616: LD_EXP 166
110620: AND
110621: IFFALSE 110705
110623: GO 110625
110625: DISABLE
110626: LD_INT 0
110628: PPUSH
110629: PPUSH
// begin enable ;
110630: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
110631: LD_ADDR_VAR 0 2
110635: PUSH
110636: LD_INT 22
110638: PUSH
110639: LD_OWVAR 2
110643: PUSH
110644: EMPTY
110645: LIST
110646: LIST
110647: PUSH
110648: LD_INT 32
110650: PUSH
110651: LD_INT 3
110653: PUSH
110654: EMPTY
110655: LIST
110656: LIST
110657: PUSH
110658: EMPTY
110659: LIST
110660: LIST
110661: PPUSH
110662: CALL_OW 69
110666: ST_TO_ADDR
// if not tmp then
110667: LD_VAR 0 2
110671: NOT
110672: IFFALSE 110676
// exit ;
110674: GO 110705
// for i in tmp do
110676: LD_ADDR_VAR 0 1
110680: PUSH
110681: LD_VAR 0 2
110685: PUSH
110686: FOR_IN
110687: IFFALSE 110703
// begin SetLives ( i , 0 ) ;
110689: LD_VAR 0 1
110693: PPUSH
110694: LD_INT 0
110696: PPUSH
110697: CALL_OW 234
// end ;
110701: GO 110686
110703: POP
110704: POP
// end ;
110705: PPOPN 2
110707: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
110708: LD_EXP 160
110712: PUSH
110713: LD_EXP 163
110717: AND
110718: IFFALSE 110811
110720: GO 110722
110722: DISABLE
110723: LD_INT 0
110725: PPUSH
// begin enable ;
110726: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
110727: LD_ADDR_VAR 0 1
110731: PUSH
110732: LD_INT 22
110734: PUSH
110735: LD_OWVAR 2
110739: PUSH
110740: EMPTY
110741: LIST
110742: LIST
110743: PUSH
110744: LD_INT 2
110746: PUSH
110747: LD_INT 25
110749: PUSH
110750: LD_INT 5
110752: PUSH
110753: EMPTY
110754: LIST
110755: LIST
110756: PUSH
110757: LD_INT 25
110759: PUSH
110760: LD_INT 9
110762: PUSH
110763: EMPTY
110764: LIST
110765: LIST
110766: PUSH
110767: LD_INT 25
110769: PUSH
110770: LD_INT 8
110772: PUSH
110773: EMPTY
110774: LIST
110775: LIST
110776: PUSH
110777: EMPTY
110778: LIST
110779: LIST
110780: LIST
110781: LIST
110782: PUSH
110783: EMPTY
110784: LIST
110785: LIST
110786: PPUSH
110787: CALL_OW 69
110791: PUSH
110792: FOR_IN
110793: IFFALSE 110809
// begin SetClass ( i , 1 ) ;
110795: LD_VAR 0 1
110799: PPUSH
110800: LD_INT 1
110802: PPUSH
110803: CALL_OW 336
// end ;
110807: GO 110792
110809: POP
110810: POP
// end ;
110811: PPOPN 1
110813: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
110814: LD_EXP 160
110818: PUSH
110819: LD_EXP 164
110823: AND
110824: PUSH
110825: LD_OWVAR 65
110829: PUSH
110830: LD_INT 7
110832: LESS
110833: AND
110834: IFFALSE 110848
110836: GO 110838
110838: DISABLE
// begin enable ;
110839: ENABLE
// game_speed := 7 ;
110840: LD_ADDR_OWVAR 65
110844: PUSH
110845: LD_INT 7
110847: ST_TO_ADDR
// end ;
110848: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
110849: LD_EXP 160
110853: PUSH
110854: LD_EXP 167
110858: AND
110859: IFFALSE 111061
110861: GO 110863
110863: DISABLE
110864: LD_INT 0
110866: PPUSH
110867: PPUSH
110868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
110869: LD_ADDR_VAR 0 3
110873: PUSH
110874: LD_INT 81
110876: PUSH
110877: LD_OWVAR 2
110881: PUSH
110882: EMPTY
110883: LIST
110884: LIST
110885: PUSH
110886: LD_INT 21
110888: PUSH
110889: LD_INT 1
110891: PUSH
110892: EMPTY
110893: LIST
110894: LIST
110895: PUSH
110896: EMPTY
110897: LIST
110898: LIST
110899: PPUSH
110900: CALL_OW 69
110904: ST_TO_ADDR
// if not tmp then
110905: LD_VAR 0 3
110909: NOT
110910: IFFALSE 110914
// exit ;
110912: GO 111061
// if tmp > 5 then
110914: LD_VAR 0 3
110918: PUSH
110919: LD_INT 5
110921: GREATER
110922: IFFALSE 110934
// k := 5 else
110924: LD_ADDR_VAR 0 2
110928: PUSH
110929: LD_INT 5
110931: ST_TO_ADDR
110932: GO 110944
// k := tmp ;
110934: LD_ADDR_VAR 0 2
110938: PUSH
110939: LD_VAR 0 3
110943: ST_TO_ADDR
// for i := 1 to k do
110944: LD_ADDR_VAR 0 1
110948: PUSH
110949: DOUBLE
110950: LD_INT 1
110952: DEC
110953: ST_TO_ADDR
110954: LD_VAR 0 2
110958: PUSH
110959: FOR_TO
110960: IFFALSE 111059
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
110962: LD_VAR 0 3
110966: PUSH
110967: LD_VAR 0 1
110971: ARRAY
110972: PPUSH
110973: LD_VAR 0 1
110977: PUSH
110978: LD_INT 4
110980: MOD
110981: PUSH
110982: LD_INT 1
110984: PLUS
110985: PPUSH
110986: CALL_OW 259
110990: PUSH
110991: LD_INT 10
110993: LESS
110994: IFFALSE 111057
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
110996: LD_VAR 0 3
111000: PUSH
111001: LD_VAR 0 1
111005: ARRAY
111006: PPUSH
111007: LD_VAR 0 1
111011: PUSH
111012: LD_INT 4
111014: MOD
111015: PUSH
111016: LD_INT 1
111018: PLUS
111019: PPUSH
111020: LD_VAR 0 3
111024: PUSH
111025: LD_VAR 0 1
111029: ARRAY
111030: PPUSH
111031: LD_VAR 0 1
111035: PUSH
111036: LD_INT 4
111038: MOD
111039: PUSH
111040: LD_INT 1
111042: PLUS
111043: PPUSH
111044: CALL_OW 259
111048: PUSH
111049: LD_INT 1
111051: PLUS
111052: PPUSH
111053: CALL_OW 237
111057: GO 110959
111059: POP
111060: POP
// end ;
111061: PPOPN 3
111063: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
111064: LD_EXP 160
111068: PUSH
111069: LD_EXP 168
111073: AND
111074: IFFALSE 111094
111076: GO 111078
111078: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
111079: LD_INT 4
111081: PPUSH
111082: LD_OWVAR 2
111086: PPUSH
111087: LD_INT 0
111089: PPUSH
111090: CALL_OW 324
111094: END
// every 0 0$1 trigger StreamModeActive and sShovel do
111095: LD_EXP 160
111099: PUSH
111100: LD_EXP 197
111104: AND
111105: IFFALSE 111125
111107: GO 111109
111109: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
111110: LD_INT 19
111112: PPUSH
111113: LD_OWVAR 2
111117: PPUSH
111118: LD_INT 0
111120: PPUSH
111121: CALL_OW 324
111125: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
111126: LD_EXP 160
111130: PUSH
111131: LD_EXP 169
111135: AND
111136: IFFALSE 111238
111138: GO 111140
111140: DISABLE
111141: LD_INT 0
111143: PPUSH
111144: PPUSH
// begin enable ;
111145: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
111146: LD_ADDR_VAR 0 2
111150: PUSH
111151: LD_INT 22
111153: PUSH
111154: LD_OWVAR 2
111158: PUSH
111159: EMPTY
111160: LIST
111161: LIST
111162: PUSH
111163: LD_INT 2
111165: PUSH
111166: LD_INT 34
111168: PUSH
111169: LD_INT 11
111171: PUSH
111172: EMPTY
111173: LIST
111174: LIST
111175: PUSH
111176: LD_INT 34
111178: PUSH
111179: LD_INT 30
111181: PUSH
111182: EMPTY
111183: LIST
111184: LIST
111185: PUSH
111186: EMPTY
111187: LIST
111188: LIST
111189: LIST
111190: PUSH
111191: EMPTY
111192: LIST
111193: LIST
111194: PPUSH
111195: CALL_OW 69
111199: ST_TO_ADDR
// if not tmp then
111200: LD_VAR 0 2
111204: NOT
111205: IFFALSE 111209
// exit ;
111207: GO 111238
// for i in tmp do
111209: LD_ADDR_VAR 0 1
111213: PUSH
111214: LD_VAR 0 2
111218: PUSH
111219: FOR_IN
111220: IFFALSE 111236
// begin SetLives ( i , 0 ) ;
111222: LD_VAR 0 1
111226: PPUSH
111227: LD_INT 0
111229: PPUSH
111230: CALL_OW 234
// end ;
111234: GO 111219
111236: POP
111237: POP
// end ;
111238: PPOPN 2
111240: END
// every 0 0$1 trigger StreamModeActive and sBunker do
111241: LD_EXP 160
111245: PUSH
111246: LD_EXP 170
111250: AND
111251: IFFALSE 111271
111253: GO 111255
111255: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
111256: LD_INT 32
111258: PPUSH
111259: LD_OWVAR 2
111263: PPUSH
111264: LD_INT 0
111266: PPUSH
111267: CALL_OW 324
111271: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
111272: LD_EXP 160
111276: PUSH
111277: LD_EXP 171
111281: AND
111282: IFFALSE 111463
111284: GO 111286
111286: DISABLE
111287: LD_INT 0
111289: PPUSH
111290: PPUSH
111291: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
111292: LD_ADDR_VAR 0 2
111296: PUSH
111297: LD_INT 22
111299: PUSH
111300: LD_OWVAR 2
111304: PUSH
111305: EMPTY
111306: LIST
111307: LIST
111308: PUSH
111309: LD_INT 33
111311: PUSH
111312: LD_INT 3
111314: PUSH
111315: EMPTY
111316: LIST
111317: LIST
111318: PUSH
111319: EMPTY
111320: LIST
111321: LIST
111322: PPUSH
111323: CALL_OW 69
111327: ST_TO_ADDR
// if not tmp then
111328: LD_VAR 0 2
111332: NOT
111333: IFFALSE 111337
// exit ;
111335: GO 111463
// side := 0 ;
111337: LD_ADDR_VAR 0 3
111341: PUSH
111342: LD_INT 0
111344: ST_TO_ADDR
// for i := 1 to 8 do
111345: LD_ADDR_VAR 0 1
111349: PUSH
111350: DOUBLE
111351: LD_INT 1
111353: DEC
111354: ST_TO_ADDR
111355: LD_INT 8
111357: PUSH
111358: FOR_TO
111359: IFFALSE 111407
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
111361: LD_OWVAR 2
111365: PUSH
111366: LD_VAR 0 1
111370: NONEQUAL
111371: PUSH
111372: LD_OWVAR 2
111376: PPUSH
111377: LD_VAR 0 1
111381: PPUSH
111382: CALL_OW 81
111386: PUSH
111387: LD_INT 2
111389: EQUAL
111390: AND
111391: IFFALSE 111405
// begin side := i ;
111393: LD_ADDR_VAR 0 3
111397: PUSH
111398: LD_VAR 0 1
111402: ST_TO_ADDR
// break ;
111403: GO 111407
// end ;
111405: GO 111358
111407: POP
111408: POP
// if not side then
111409: LD_VAR 0 3
111413: NOT
111414: IFFALSE 111418
// exit ;
111416: GO 111463
// for i := 1 to tmp do
111418: LD_ADDR_VAR 0 1
111422: PUSH
111423: DOUBLE
111424: LD_INT 1
111426: DEC
111427: ST_TO_ADDR
111428: LD_VAR 0 2
111432: PUSH
111433: FOR_TO
111434: IFFALSE 111461
// if Prob ( 60 ) then
111436: LD_INT 60
111438: PPUSH
111439: CALL_OW 13
111443: IFFALSE 111459
// SetSide ( i , side ) ;
111445: LD_VAR 0 1
111449: PPUSH
111450: LD_VAR 0 3
111454: PPUSH
111455: CALL_OW 235
111459: GO 111433
111461: POP
111462: POP
// end ;
111463: PPOPN 3
111465: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
111466: LD_EXP 160
111470: PUSH
111471: LD_EXP 173
111475: AND
111476: IFFALSE 111595
111478: GO 111480
111480: DISABLE
111481: LD_INT 0
111483: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
111484: LD_ADDR_VAR 0 1
111488: PUSH
111489: LD_INT 22
111491: PUSH
111492: LD_OWVAR 2
111496: PUSH
111497: EMPTY
111498: LIST
111499: LIST
111500: PUSH
111501: LD_INT 21
111503: PUSH
111504: LD_INT 1
111506: PUSH
111507: EMPTY
111508: LIST
111509: LIST
111510: PUSH
111511: LD_INT 3
111513: PUSH
111514: LD_INT 23
111516: PUSH
111517: LD_INT 0
111519: PUSH
111520: EMPTY
111521: LIST
111522: LIST
111523: PUSH
111524: EMPTY
111525: LIST
111526: LIST
111527: PUSH
111528: EMPTY
111529: LIST
111530: LIST
111531: LIST
111532: PPUSH
111533: CALL_OW 69
111537: PUSH
111538: FOR_IN
111539: IFFALSE 111593
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
111541: LD_VAR 0 1
111545: PPUSH
111546: CALL_OW 257
111550: PUSH
111551: LD_INT 1
111553: PUSH
111554: LD_INT 2
111556: PUSH
111557: LD_INT 3
111559: PUSH
111560: LD_INT 4
111562: PUSH
111563: EMPTY
111564: LIST
111565: LIST
111566: LIST
111567: LIST
111568: IN
111569: IFFALSE 111591
// SetClass ( un , rand ( 1 , 4 ) ) ;
111571: LD_VAR 0 1
111575: PPUSH
111576: LD_INT 1
111578: PPUSH
111579: LD_INT 4
111581: PPUSH
111582: CALL_OW 12
111586: PPUSH
111587: CALL_OW 336
111591: GO 111538
111593: POP
111594: POP
// end ;
111595: PPOPN 1
111597: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
111598: LD_EXP 160
111602: PUSH
111603: LD_EXP 172
111607: AND
111608: IFFALSE 111687
111610: GO 111612
111612: DISABLE
111613: LD_INT 0
111615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
111616: LD_ADDR_VAR 0 1
111620: PUSH
111621: LD_INT 22
111623: PUSH
111624: LD_OWVAR 2
111628: PUSH
111629: EMPTY
111630: LIST
111631: LIST
111632: PUSH
111633: LD_INT 21
111635: PUSH
111636: LD_INT 3
111638: PUSH
111639: EMPTY
111640: LIST
111641: LIST
111642: PUSH
111643: EMPTY
111644: LIST
111645: LIST
111646: PPUSH
111647: CALL_OW 69
111651: ST_TO_ADDR
// if not tmp then
111652: LD_VAR 0 1
111656: NOT
111657: IFFALSE 111661
// exit ;
111659: GO 111687
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
111661: LD_VAR 0 1
111665: PUSH
111666: LD_INT 1
111668: PPUSH
111669: LD_VAR 0 1
111673: PPUSH
111674: CALL_OW 12
111678: ARRAY
111679: PPUSH
111680: LD_INT 100
111682: PPUSH
111683: CALL_OW 234
// end ;
111687: PPOPN 1
111689: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
111690: LD_EXP 160
111694: PUSH
111695: LD_EXP 174
111699: AND
111700: IFFALSE 111798
111702: GO 111704
111704: DISABLE
111705: LD_INT 0
111707: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
111708: LD_ADDR_VAR 0 1
111712: PUSH
111713: LD_INT 22
111715: PUSH
111716: LD_OWVAR 2
111720: PUSH
111721: EMPTY
111722: LIST
111723: LIST
111724: PUSH
111725: LD_INT 21
111727: PUSH
111728: LD_INT 1
111730: PUSH
111731: EMPTY
111732: LIST
111733: LIST
111734: PUSH
111735: EMPTY
111736: LIST
111737: LIST
111738: PPUSH
111739: CALL_OW 69
111743: ST_TO_ADDR
// if not tmp then
111744: LD_VAR 0 1
111748: NOT
111749: IFFALSE 111753
// exit ;
111751: GO 111798
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
111753: LD_VAR 0 1
111757: PUSH
111758: LD_INT 1
111760: PPUSH
111761: LD_VAR 0 1
111765: PPUSH
111766: CALL_OW 12
111770: ARRAY
111771: PPUSH
111772: LD_INT 1
111774: PPUSH
111775: LD_INT 4
111777: PPUSH
111778: CALL_OW 12
111782: PPUSH
111783: LD_INT 3000
111785: PPUSH
111786: LD_INT 9000
111788: PPUSH
111789: CALL_OW 12
111793: PPUSH
111794: CALL_OW 492
// end ;
111798: PPOPN 1
111800: END
// every 0 0$1 trigger StreamModeActive and sDepot do
111801: LD_EXP 160
111805: PUSH
111806: LD_EXP 175
111810: AND
111811: IFFALSE 111831
111813: GO 111815
111815: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
111816: LD_INT 1
111818: PPUSH
111819: LD_OWVAR 2
111823: PPUSH
111824: LD_INT 0
111826: PPUSH
111827: CALL_OW 324
111831: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
111832: LD_EXP 160
111836: PUSH
111837: LD_EXP 176
111841: AND
111842: IFFALSE 111925
111844: GO 111846
111846: DISABLE
111847: LD_INT 0
111849: PPUSH
111850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
111851: LD_ADDR_VAR 0 2
111855: PUSH
111856: LD_INT 22
111858: PUSH
111859: LD_OWVAR 2
111863: PUSH
111864: EMPTY
111865: LIST
111866: LIST
111867: PUSH
111868: LD_INT 21
111870: PUSH
111871: LD_INT 3
111873: PUSH
111874: EMPTY
111875: LIST
111876: LIST
111877: PUSH
111878: EMPTY
111879: LIST
111880: LIST
111881: PPUSH
111882: CALL_OW 69
111886: ST_TO_ADDR
// if not tmp then
111887: LD_VAR 0 2
111891: NOT
111892: IFFALSE 111896
// exit ;
111894: GO 111925
// for i in tmp do
111896: LD_ADDR_VAR 0 1
111900: PUSH
111901: LD_VAR 0 2
111905: PUSH
111906: FOR_IN
111907: IFFALSE 111923
// SetBLevel ( i , 10 ) ;
111909: LD_VAR 0 1
111913: PPUSH
111914: LD_INT 10
111916: PPUSH
111917: CALL_OW 241
111921: GO 111906
111923: POP
111924: POP
// end ;
111925: PPOPN 2
111927: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
111928: LD_EXP 160
111932: PUSH
111933: LD_EXP 177
111937: AND
111938: IFFALSE 112049
111940: GO 111942
111942: DISABLE
111943: LD_INT 0
111945: PPUSH
111946: PPUSH
111947: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111948: LD_ADDR_VAR 0 3
111952: PUSH
111953: LD_INT 22
111955: PUSH
111956: LD_OWVAR 2
111960: PUSH
111961: EMPTY
111962: LIST
111963: LIST
111964: PUSH
111965: LD_INT 25
111967: PUSH
111968: LD_INT 1
111970: PUSH
111971: EMPTY
111972: LIST
111973: LIST
111974: PUSH
111975: EMPTY
111976: LIST
111977: LIST
111978: PPUSH
111979: CALL_OW 69
111983: ST_TO_ADDR
// if not tmp then
111984: LD_VAR 0 3
111988: NOT
111989: IFFALSE 111993
// exit ;
111991: GO 112049
// un := tmp [ rand ( 1 , tmp ) ] ;
111993: LD_ADDR_VAR 0 2
111997: PUSH
111998: LD_VAR 0 3
112002: PUSH
112003: LD_INT 1
112005: PPUSH
112006: LD_VAR 0 3
112010: PPUSH
112011: CALL_OW 12
112015: ARRAY
112016: ST_TO_ADDR
// if Crawls ( un ) then
112017: LD_VAR 0 2
112021: PPUSH
112022: CALL_OW 318
112026: IFFALSE 112037
// ComWalk ( un ) ;
112028: LD_VAR 0 2
112032: PPUSH
112033: CALL_OW 138
// SetClass ( un , class_sniper ) ;
112037: LD_VAR 0 2
112041: PPUSH
112042: LD_INT 5
112044: PPUSH
112045: CALL_OW 336
// end ;
112049: PPOPN 3
112051: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
112052: LD_EXP 160
112056: PUSH
112057: LD_EXP 178
112061: AND
112062: PUSH
112063: LD_OWVAR 67
112067: PUSH
112068: LD_INT 4
112070: LESS
112071: AND
112072: IFFALSE 112091
112074: GO 112076
112076: DISABLE
// begin Difficulty := Difficulty + 1 ;
112077: LD_ADDR_OWVAR 67
112081: PUSH
112082: LD_OWVAR 67
112086: PUSH
112087: LD_INT 1
112089: PLUS
112090: ST_TO_ADDR
// end ;
112091: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
112092: LD_EXP 160
112096: PUSH
112097: LD_EXP 179
112101: AND
112102: IFFALSE 112205
112104: GO 112106
112106: DISABLE
112107: LD_INT 0
112109: PPUSH
// begin for i := 1 to 5 do
112110: LD_ADDR_VAR 0 1
112114: PUSH
112115: DOUBLE
112116: LD_INT 1
112118: DEC
112119: ST_TO_ADDR
112120: LD_INT 5
112122: PUSH
112123: FOR_TO
112124: IFFALSE 112203
// begin uc_nation := nation_nature ;
112126: LD_ADDR_OWVAR 21
112130: PUSH
112131: LD_INT 0
112133: ST_TO_ADDR
// uc_side := 0 ;
112134: LD_ADDR_OWVAR 20
112138: PUSH
112139: LD_INT 0
112141: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
112142: LD_ADDR_OWVAR 29
112146: PUSH
112147: LD_INT 12
112149: PUSH
112150: LD_INT 12
112152: PUSH
112153: EMPTY
112154: LIST
112155: LIST
112156: ST_TO_ADDR
// hc_agressivity := 20 ;
112157: LD_ADDR_OWVAR 35
112161: PUSH
112162: LD_INT 20
112164: ST_TO_ADDR
// hc_class := class_tiger ;
112165: LD_ADDR_OWVAR 28
112169: PUSH
112170: LD_INT 14
112172: ST_TO_ADDR
// hc_gallery :=  ;
112173: LD_ADDR_OWVAR 33
112177: PUSH
112178: LD_STRING 
112180: ST_TO_ADDR
// hc_name :=  ;
112181: LD_ADDR_OWVAR 26
112185: PUSH
112186: LD_STRING 
112188: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
112189: CALL_OW 44
112193: PPUSH
112194: LD_INT 0
112196: PPUSH
112197: CALL_OW 51
// end ;
112201: GO 112123
112203: POP
112204: POP
// end ;
112205: PPOPN 1
112207: END
// every 0 0$1 trigger StreamModeActive and sBomb do
112208: LD_EXP 160
112212: PUSH
112213: LD_EXP 180
112217: AND
112218: IFFALSE 112227
112220: GO 112222
112222: DISABLE
// StreamSibBomb ;
112223: CALL 112228 0 0
112227: END
// export function StreamSibBomb ; var i , x , y ; begin
112228: LD_INT 0
112230: PPUSH
112231: PPUSH
112232: PPUSH
112233: PPUSH
// result := false ;
112234: LD_ADDR_VAR 0 1
112238: PUSH
112239: LD_INT 0
112241: ST_TO_ADDR
// for i := 1 to 16 do
112242: LD_ADDR_VAR 0 2
112246: PUSH
112247: DOUBLE
112248: LD_INT 1
112250: DEC
112251: ST_TO_ADDR
112252: LD_INT 16
112254: PUSH
112255: FOR_TO
112256: IFFALSE 112455
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
112258: LD_ADDR_VAR 0 3
112262: PUSH
112263: LD_INT 10
112265: PUSH
112266: LD_INT 20
112268: PUSH
112269: LD_INT 30
112271: PUSH
112272: LD_INT 40
112274: PUSH
112275: LD_INT 50
112277: PUSH
112278: LD_INT 60
112280: PUSH
112281: LD_INT 70
112283: PUSH
112284: LD_INT 80
112286: PUSH
112287: LD_INT 90
112289: PUSH
112290: LD_INT 100
112292: PUSH
112293: LD_INT 110
112295: PUSH
112296: LD_INT 120
112298: PUSH
112299: LD_INT 130
112301: PUSH
112302: LD_INT 140
112304: PUSH
112305: LD_INT 150
112307: PUSH
112308: EMPTY
112309: LIST
112310: LIST
112311: LIST
112312: LIST
112313: LIST
112314: LIST
112315: LIST
112316: LIST
112317: LIST
112318: LIST
112319: LIST
112320: LIST
112321: LIST
112322: LIST
112323: LIST
112324: PUSH
112325: LD_INT 1
112327: PPUSH
112328: LD_INT 15
112330: PPUSH
112331: CALL_OW 12
112335: ARRAY
112336: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
112337: LD_ADDR_VAR 0 4
112341: PUSH
112342: LD_INT 10
112344: PUSH
112345: LD_INT 20
112347: PUSH
112348: LD_INT 30
112350: PUSH
112351: LD_INT 40
112353: PUSH
112354: LD_INT 50
112356: PUSH
112357: LD_INT 60
112359: PUSH
112360: LD_INT 70
112362: PUSH
112363: LD_INT 80
112365: PUSH
112366: LD_INT 90
112368: PUSH
112369: LD_INT 100
112371: PUSH
112372: LD_INT 110
112374: PUSH
112375: LD_INT 120
112377: PUSH
112378: LD_INT 130
112380: PUSH
112381: LD_INT 140
112383: PUSH
112384: LD_INT 150
112386: PUSH
112387: EMPTY
112388: LIST
112389: LIST
112390: LIST
112391: LIST
112392: LIST
112393: LIST
112394: LIST
112395: LIST
112396: LIST
112397: LIST
112398: LIST
112399: LIST
112400: LIST
112401: LIST
112402: LIST
112403: PUSH
112404: LD_INT 1
112406: PPUSH
112407: LD_INT 15
112409: PPUSH
112410: CALL_OW 12
112414: ARRAY
112415: ST_TO_ADDR
// if ValidHex ( x , y ) then
112416: LD_VAR 0 3
112420: PPUSH
112421: LD_VAR 0 4
112425: PPUSH
112426: CALL_OW 488
112430: IFFALSE 112453
// begin result := [ x , y ] ;
112432: LD_ADDR_VAR 0 1
112436: PUSH
112437: LD_VAR 0 3
112441: PUSH
112442: LD_VAR 0 4
112446: PUSH
112447: EMPTY
112448: LIST
112449: LIST
112450: ST_TO_ADDR
// break ;
112451: GO 112455
// end ; end ;
112453: GO 112255
112455: POP
112456: POP
// if result then
112457: LD_VAR 0 1
112461: IFFALSE 112521
// begin ToLua ( playSibBomb() ) ;
112463: LD_STRING playSibBomb()
112465: PPUSH
112466: CALL_OW 559
// wait ( 0 0$14 ) ;
112470: LD_INT 490
112472: PPUSH
112473: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
112477: LD_VAR 0 1
112481: PUSH
112482: LD_INT 1
112484: ARRAY
112485: PPUSH
112486: LD_VAR 0 1
112490: PUSH
112491: LD_INT 2
112493: ARRAY
112494: PPUSH
112495: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
112499: LD_VAR 0 1
112503: PUSH
112504: LD_INT 1
112506: ARRAY
112507: PPUSH
112508: LD_VAR 0 1
112512: PUSH
112513: LD_INT 2
112515: ARRAY
112516: PPUSH
112517: CALL_OW 429
// end ; end ;
112521: LD_VAR 0 1
112525: RET
// every 0 0$1 trigger StreamModeActive and sReset do
112526: LD_EXP 160
112530: PUSH
112531: LD_EXP 182
112535: AND
112536: IFFALSE 112548
112538: GO 112540
112540: DISABLE
// YouLost (  ) ;
112541: LD_STRING 
112543: PPUSH
112544: CALL_OW 104
112548: END
// every 0 0$1 trigger StreamModeActive and sFog do
112549: LD_EXP 160
112553: PUSH
112554: LD_EXP 181
112558: AND
112559: IFFALSE 112573
112561: GO 112563
112563: DISABLE
// FogOff ( your_side ) ;
112564: LD_OWVAR 2
112568: PPUSH
112569: CALL_OW 344
112573: END
// every 0 0$1 trigger StreamModeActive and sSun do
112574: LD_EXP 160
112578: PUSH
112579: LD_EXP 183
112583: AND
112584: IFFALSE 112612
112586: GO 112588
112588: DISABLE
// begin solar_recharge_percent := 0 ;
112589: LD_ADDR_OWVAR 79
112593: PUSH
112594: LD_INT 0
112596: ST_TO_ADDR
// wait ( 5 5$00 ) ;
112597: LD_INT 10500
112599: PPUSH
112600: CALL_OW 67
// solar_recharge_percent := 100 ;
112604: LD_ADDR_OWVAR 79
112608: PUSH
112609: LD_INT 100
112611: ST_TO_ADDR
// end ;
112612: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
112613: LD_EXP 160
112617: PUSH
112618: LD_EXP 184
112622: AND
112623: IFFALSE 112862
112625: GO 112627
112627: DISABLE
112628: LD_INT 0
112630: PPUSH
112631: PPUSH
112632: PPUSH
// begin tmp := [ ] ;
112633: LD_ADDR_VAR 0 3
112637: PUSH
112638: EMPTY
112639: ST_TO_ADDR
// for i := 1 to 6 do
112640: LD_ADDR_VAR 0 1
112644: PUSH
112645: DOUBLE
112646: LD_INT 1
112648: DEC
112649: ST_TO_ADDR
112650: LD_INT 6
112652: PUSH
112653: FOR_TO
112654: IFFALSE 112759
// begin uc_nation := nation_nature ;
112656: LD_ADDR_OWVAR 21
112660: PUSH
112661: LD_INT 0
112663: ST_TO_ADDR
// uc_side := 0 ;
112664: LD_ADDR_OWVAR 20
112668: PUSH
112669: LD_INT 0
112671: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
112672: LD_ADDR_OWVAR 29
112676: PUSH
112677: LD_INT 12
112679: PUSH
112680: LD_INT 12
112682: PUSH
112683: EMPTY
112684: LIST
112685: LIST
112686: ST_TO_ADDR
// hc_agressivity := 20 ;
112687: LD_ADDR_OWVAR 35
112691: PUSH
112692: LD_INT 20
112694: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
112695: LD_ADDR_OWVAR 28
112699: PUSH
112700: LD_INT 17
112702: ST_TO_ADDR
// hc_gallery :=  ;
112703: LD_ADDR_OWVAR 33
112707: PUSH
112708: LD_STRING 
112710: ST_TO_ADDR
// hc_name :=  ;
112711: LD_ADDR_OWVAR 26
112715: PUSH
112716: LD_STRING 
112718: ST_TO_ADDR
// un := CreateHuman ;
112719: LD_ADDR_VAR 0 2
112723: PUSH
112724: CALL_OW 44
112728: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
112729: LD_VAR 0 2
112733: PPUSH
112734: LD_INT 1
112736: PPUSH
112737: CALL_OW 51
// tmp := tmp ^ un ;
112741: LD_ADDR_VAR 0 3
112745: PUSH
112746: LD_VAR 0 3
112750: PUSH
112751: LD_VAR 0 2
112755: ADD
112756: ST_TO_ADDR
// end ;
112757: GO 112653
112759: POP
112760: POP
// repeat wait ( 0 0$1 ) ;
112761: LD_INT 35
112763: PPUSH
112764: CALL_OW 67
// for un in tmp do
112768: LD_ADDR_VAR 0 2
112772: PUSH
112773: LD_VAR 0 3
112777: PUSH
112778: FOR_IN
112779: IFFALSE 112853
// begin if IsDead ( un ) then
112781: LD_VAR 0 2
112785: PPUSH
112786: CALL_OW 301
112790: IFFALSE 112810
// begin tmp := tmp diff un ;
112792: LD_ADDR_VAR 0 3
112796: PUSH
112797: LD_VAR 0 3
112801: PUSH
112802: LD_VAR 0 2
112806: DIFF
112807: ST_TO_ADDR
// continue ;
112808: GO 112778
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
112810: LD_VAR 0 2
112814: PPUSH
112815: LD_INT 3
112817: PUSH
112818: LD_INT 22
112820: PUSH
112821: LD_INT 0
112823: PUSH
112824: EMPTY
112825: LIST
112826: LIST
112827: PUSH
112828: EMPTY
112829: LIST
112830: LIST
112831: PPUSH
112832: CALL_OW 69
112836: PPUSH
112837: LD_VAR 0 2
112841: PPUSH
112842: CALL_OW 74
112846: PPUSH
112847: CALL_OW 115
// end ;
112851: GO 112778
112853: POP
112854: POP
// until not tmp ;
112855: LD_VAR 0 3
112859: NOT
112860: IFFALSE 112761
// end ;
112862: PPOPN 3
112864: END
// every 0 0$1 trigger StreamModeActive and sTroll do
112865: LD_EXP 160
112869: PUSH
112870: LD_EXP 185
112874: AND
112875: IFFALSE 112929
112877: GO 112879
112879: DISABLE
// begin ToLua ( displayTroll(); ) ;
112880: LD_STRING displayTroll();
112882: PPUSH
112883: CALL_OW 559
// wait ( 3 3$00 ) ;
112887: LD_INT 6300
112889: PPUSH
112890: CALL_OW 67
// ToLua ( hideTroll(); ) ;
112894: LD_STRING hideTroll();
112896: PPUSH
112897: CALL_OW 559
// wait ( 1 1$00 ) ;
112901: LD_INT 2100
112903: PPUSH
112904: CALL_OW 67
// ToLua ( displayTroll(); ) ;
112908: LD_STRING displayTroll();
112910: PPUSH
112911: CALL_OW 559
// wait ( 1 1$00 ) ;
112915: LD_INT 2100
112917: PPUSH
112918: CALL_OW 67
// ToLua ( hideTroll(); ) ;
112922: LD_STRING hideTroll();
112924: PPUSH
112925: CALL_OW 559
// end ;
112929: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
112930: LD_EXP 160
112934: PUSH
112935: LD_EXP 186
112939: AND
112940: IFFALSE 113003
112942: GO 112944
112944: DISABLE
112945: LD_INT 0
112947: PPUSH
// begin p := 0 ;
112948: LD_ADDR_VAR 0 1
112952: PUSH
112953: LD_INT 0
112955: ST_TO_ADDR
// repeat game_speed := 1 ;
112956: LD_ADDR_OWVAR 65
112960: PUSH
112961: LD_INT 1
112963: ST_TO_ADDR
// wait ( 0 0$1 ) ;
112964: LD_INT 35
112966: PPUSH
112967: CALL_OW 67
// p := p + 1 ;
112971: LD_ADDR_VAR 0 1
112975: PUSH
112976: LD_VAR 0 1
112980: PUSH
112981: LD_INT 1
112983: PLUS
112984: ST_TO_ADDR
// until p >= 60 ;
112985: LD_VAR 0 1
112989: PUSH
112990: LD_INT 60
112992: GREATEREQUAL
112993: IFFALSE 112956
// game_speed := 4 ;
112995: LD_ADDR_OWVAR 65
112999: PUSH
113000: LD_INT 4
113002: ST_TO_ADDR
// end ;
113003: PPOPN 1
113005: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
113006: LD_EXP 160
113010: PUSH
113011: LD_EXP 187
113015: AND
113016: IFFALSE 113162
113018: GO 113020
113020: DISABLE
113021: LD_INT 0
113023: PPUSH
113024: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
113025: LD_ADDR_VAR 0 1
113029: PUSH
113030: LD_INT 22
113032: PUSH
113033: LD_OWVAR 2
113037: PUSH
113038: EMPTY
113039: LIST
113040: LIST
113041: PUSH
113042: LD_INT 2
113044: PUSH
113045: LD_INT 30
113047: PUSH
113048: LD_INT 0
113050: PUSH
113051: EMPTY
113052: LIST
113053: LIST
113054: PUSH
113055: LD_INT 30
113057: PUSH
113058: LD_INT 1
113060: PUSH
113061: EMPTY
113062: LIST
113063: LIST
113064: PUSH
113065: EMPTY
113066: LIST
113067: LIST
113068: LIST
113069: PUSH
113070: EMPTY
113071: LIST
113072: LIST
113073: PPUSH
113074: CALL_OW 69
113078: ST_TO_ADDR
// if not depot then
113079: LD_VAR 0 1
113083: NOT
113084: IFFALSE 113088
// exit ;
113086: GO 113162
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
113088: LD_ADDR_VAR 0 2
113092: PUSH
113093: LD_VAR 0 1
113097: PUSH
113098: LD_INT 1
113100: PPUSH
113101: LD_VAR 0 1
113105: PPUSH
113106: CALL_OW 12
113110: ARRAY
113111: PPUSH
113112: CALL_OW 274
113116: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
113117: LD_VAR 0 2
113121: PPUSH
113122: LD_INT 1
113124: PPUSH
113125: LD_INT 0
113127: PPUSH
113128: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
113132: LD_VAR 0 2
113136: PPUSH
113137: LD_INT 2
113139: PPUSH
113140: LD_INT 0
113142: PPUSH
113143: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
113147: LD_VAR 0 2
113151: PPUSH
113152: LD_INT 3
113154: PPUSH
113155: LD_INT 0
113157: PPUSH
113158: CALL_OW 277
// end ;
113162: PPOPN 2
113164: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
113165: LD_EXP 160
113169: PUSH
113170: LD_EXP 188
113174: AND
113175: IFFALSE 113272
113177: GO 113179
113179: DISABLE
113180: LD_INT 0
113182: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
113183: LD_ADDR_VAR 0 1
113187: PUSH
113188: LD_INT 22
113190: PUSH
113191: LD_OWVAR 2
113195: PUSH
113196: EMPTY
113197: LIST
113198: LIST
113199: PUSH
113200: LD_INT 21
113202: PUSH
113203: LD_INT 1
113205: PUSH
113206: EMPTY
113207: LIST
113208: LIST
113209: PUSH
113210: LD_INT 3
113212: PUSH
113213: LD_INT 23
113215: PUSH
113216: LD_INT 0
113218: PUSH
113219: EMPTY
113220: LIST
113221: LIST
113222: PUSH
113223: EMPTY
113224: LIST
113225: LIST
113226: PUSH
113227: EMPTY
113228: LIST
113229: LIST
113230: LIST
113231: PPUSH
113232: CALL_OW 69
113236: ST_TO_ADDR
// if not tmp then
113237: LD_VAR 0 1
113241: NOT
113242: IFFALSE 113246
// exit ;
113244: GO 113272
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
113246: LD_VAR 0 1
113250: PUSH
113251: LD_INT 1
113253: PPUSH
113254: LD_VAR 0 1
113258: PPUSH
113259: CALL_OW 12
113263: ARRAY
113264: PPUSH
113265: LD_INT 200
113267: PPUSH
113268: CALL_OW 234
// end ;
113272: PPOPN 1
113274: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
113275: LD_EXP 160
113279: PUSH
113280: LD_EXP 189
113284: AND
113285: IFFALSE 113364
113287: GO 113289
113289: DISABLE
113290: LD_INT 0
113292: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
113293: LD_ADDR_VAR 0 1
113297: PUSH
113298: LD_INT 22
113300: PUSH
113301: LD_OWVAR 2
113305: PUSH
113306: EMPTY
113307: LIST
113308: LIST
113309: PUSH
113310: LD_INT 21
113312: PUSH
113313: LD_INT 2
113315: PUSH
113316: EMPTY
113317: LIST
113318: LIST
113319: PUSH
113320: EMPTY
113321: LIST
113322: LIST
113323: PPUSH
113324: CALL_OW 69
113328: ST_TO_ADDR
// if not tmp then
113329: LD_VAR 0 1
113333: NOT
113334: IFFALSE 113338
// exit ;
113336: GO 113364
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
113338: LD_VAR 0 1
113342: PUSH
113343: LD_INT 1
113345: PPUSH
113346: LD_VAR 0 1
113350: PPUSH
113351: CALL_OW 12
113355: ARRAY
113356: PPUSH
113357: LD_INT 60
113359: PPUSH
113360: CALL_OW 234
// end ;
113364: PPOPN 1
113366: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
113367: LD_EXP 160
113371: PUSH
113372: LD_EXP 190
113376: AND
113377: IFFALSE 113476
113379: GO 113381
113381: DISABLE
113382: LD_INT 0
113384: PPUSH
113385: PPUSH
// begin enable ;
113386: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
113387: LD_ADDR_VAR 0 1
113391: PUSH
113392: LD_INT 22
113394: PUSH
113395: LD_OWVAR 2
113399: PUSH
113400: EMPTY
113401: LIST
113402: LIST
113403: PUSH
113404: LD_INT 61
113406: PUSH
113407: EMPTY
113408: LIST
113409: PUSH
113410: LD_INT 33
113412: PUSH
113413: LD_INT 2
113415: PUSH
113416: EMPTY
113417: LIST
113418: LIST
113419: PUSH
113420: EMPTY
113421: LIST
113422: LIST
113423: LIST
113424: PPUSH
113425: CALL_OW 69
113429: ST_TO_ADDR
// if not tmp then
113430: LD_VAR 0 1
113434: NOT
113435: IFFALSE 113439
// exit ;
113437: GO 113476
// for i in tmp do
113439: LD_ADDR_VAR 0 2
113443: PUSH
113444: LD_VAR 0 1
113448: PUSH
113449: FOR_IN
113450: IFFALSE 113474
// if IsControledBy ( i ) then
113452: LD_VAR 0 2
113456: PPUSH
113457: CALL_OW 312
113461: IFFALSE 113472
// ComUnlink ( i ) ;
113463: LD_VAR 0 2
113467: PPUSH
113468: CALL_OW 136
113472: GO 113449
113474: POP
113475: POP
// end ;
113476: PPOPN 2
113478: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
113479: LD_EXP 160
113483: PUSH
113484: LD_EXP 191
113488: AND
113489: IFFALSE 113629
113491: GO 113493
113493: DISABLE
113494: LD_INT 0
113496: PPUSH
113497: PPUSH
// begin ToLua ( displayPowell(); ) ;
113498: LD_STRING displayPowell();
113500: PPUSH
113501: CALL_OW 559
// uc_side := 0 ;
113505: LD_ADDR_OWVAR 20
113509: PUSH
113510: LD_INT 0
113512: ST_TO_ADDR
// uc_nation := 2 ;
113513: LD_ADDR_OWVAR 21
113517: PUSH
113518: LD_INT 2
113520: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
113521: LD_ADDR_OWVAR 37
113525: PUSH
113526: LD_INT 14
113528: ST_TO_ADDR
// vc_engine := engine_siberite ;
113529: LD_ADDR_OWVAR 39
113533: PUSH
113534: LD_INT 3
113536: ST_TO_ADDR
// vc_control := control_apeman ;
113537: LD_ADDR_OWVAR 38
113541: PUSH
113542: LD_INT 5
113544: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
113545: LD_ADDR_OWVAR 40
113549: PUSH
113550: LD_INT 29
113552: ST_TO_ADDR
// un := CreateVehicle ;
113553: LD_ADDR_VAR 0 2
113557: PUSH
113558: CALL_OW 45
113562: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
113563: LD_VAR 0 2
113567: PPUSH
113568: LD_INT 1
113570: PPUSH
113571: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
113575: LD_INT 35
113577: PPUSH
113578: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
113582: LD_VAR 0 2
113586: PPUSH
113587: LD_INT 22
113589: PUSH
113590: LD_OWVAR 2
113594: PUSH
113595: EMPTY
113596: LIST
113597: LIST
113598: PPUSH
113599: CALL_OW 69
113603: PPUSH
113604: LD_VAR 0 2
113608: PPUSH
113609: CALL_OW 74
113613: PPUSH
113614: CALL_OW 115
// until IsDead ( un ) ;
113618: LD_VAR 0 2
113622: PPUSH
113623: CALL_OW 301
113627: IFFALSE 113575
// end ;
113629: PPOPN 2
113631: END
// every 0 0$1 trigger StreamModeActive and sStu do
113632: LD_EXP 160
113636: PUSH
113637: LD_EXP 199
113641: AND
113642: IFFALSE 113658
113644: GO 113646
113646: DISABLE
// begin ToLua ( displayStucuk(); ) ;
113647: LD_STRING displayStucuk();
113649: PPUSH
113650: CALL_OW 559
// ResetFog ;
113654: CALL_OW 335
// end ;
113658: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
113659: LD_EXP 160
113663: PUSH
113664: LD_EXP 192
113668: AND
113669: IFFALSE 113810
113671: GO 113673
113673: DISABLE
113674: LD_INT 0
113676: PPUSH
113677: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
113678: LD_ADDR_VAR 0 2
113682: PUSH
113683: LD_INT 22
113685: PUSH
113686: LD_OWVAR 2
113690: PUSH
113691: EMPTY
113692: LIST
113693: LIST
113694: PUSH
113695: LD_INT 21
113697: PUSH
113698: LD_INT 1
113700: PUSH
113701: EMPTY
113702: LIST
113703: LIST
113704: PUSH
113705: EMPTY
113706: LIST
113707: LIST
113708: PPUSH
113709: CALL_OW 69
113713: ST_TO_ADDR
// if not tmp then
113714: LD_VAR 0 2
113718: NOT
113719: IFFALSE 113723
// exit ;
113721: GO 113810
// un := tmp [ rand ( 1 , tmp ) ] ;
113723: LD_ADDR_VAR 0 1
113727: PUSH
113728: LD_VAR 0 2
113732: PUSH
113733: LD_INT 1
113735: PPUSH
113736: LD_VAR 0 2
113740: PPUSH
113741: CALL_OW 12
113745: ARRAY
113746: ST_TO_ADDR
// SetSide ( un , 0 ) ;
113747: LD_VAR 0 1
113751: PPUSH
113752: LD_INT 0
113754: PPUSH
113755: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
113759: LD_VAR 0 1
113763: PPUSH
113764: LD_OWVAR 3
113768: PUSH
113769: LD_VAR 0 1
113773: DIFF
113774: PPUSH
113775: LD_VAR 0 1
113779: PPUSH
113780: CALL_OW 74
113784: PPUSH
113785: CALL_OW 115
// wait ( 0 0$20 ) ;
113789: LD_INT 700
113791: PPUSH
113792: CALL_OW 67
// SetSide ( un , your_side ) ;
113796: LD_VAR 0 1
113800: PPUSH
113801: LD_OWVAR 2
113805: PPUSH
113806: CALL_OW 235
// end ;
113810: PPOPN 2
113812: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
113813: LD_EXP 160
113817: PUSH
113818: LD_EXP 193
113822: AND
113823: IFFALSE 113929
113825: GO 113827
113827: DISABLE
113828: LD_INT 0
113830: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
113831: LD_ADDR_VAR 0 1
113835: PUSH
113836: LD_INT 22
113838: PUSH
113839: LD_OWVAR 2
113843: PUSH
113844: EMPTY
113845: LIST
113846: LIST
113847: PUSH
113848: LD_INT 2
113850: PUSH
113851: LD_INT 30
113853: PUSH
113854: LD_INT 0
113856: PUSH
113857: EMPTY
113858: LIST
113859: LIST
113860: PUSH
113861: LD_INT 30
113863: PUSH
113864: LD_INT 1
113866: PUSH
113867: EMPTY
113868: LIST
113869: LIST
113870: PUSH
113871: EMPTY
113872: LIST
113873: LIST
113874: LIST
113875: PUSH
113876: EMPTY
113877: LIST
113878: LIST
113879: PPUSH
113880: CALL_OW 69
113884: ST_TO_ADDR
// if not depot then
113885: LD_VAR 0 1
113889: NOT
113890: IFFALSE 113894
// exit ;
113892: GO 113929
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
113894: LD_VAR 0 1
113898: PUSH
113899: LD_INT 1
113901: ARRAY
113902: PPUSH
113903: CALL_OW 250
113907: PPUSH
113908: LD_VAR 0 1
113912: PUSH
113913: LD_INT 1
113915: ARRAY
113916: PPUSH
113917: CALL_OW 251
113921: PPUSH
113922: LD_INT 70
113924: PPUSH
113925: CALL_OW 495
// end ;
113929: PPOPN 1
113931: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
113932: LD_EXP 160
113936: PUSH
113937: LD_EXP 194
113941: AND
113942: IFFALSE 114153
113944: GO 113946
113946: DISABLE
113947: LD_INT 0
113949: PPUSH
113950: PPUSH
113951: PPUSH
113952: PPUSH
113953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
113954: LD_ADDR_VAR 0 5
113958: PUSH
113959: LD_INT 22
113961: PUSH
113962: LD_OWVAR 2
113966: PUSH
113967: EMPTY
113968: LIST
113969: LIST
113970: PUSH
113971: LD_INT 21
113973: PUSH
113974: LD_INT 1
113976: PUSH
113977: EMPTY
113978: LIST
113979: LIST
113980: PUSH
113981: EMPTY
113982: LIST
113983: LIST
113984: PPUSH
113985: CALL_OW 69
113989: ST_TO_ADDR
// if not tmp then
113990: LD_VAR 0 5
113994: NOT
113995: IFFALSE 113999
// exit ;
113997: GO 114153
// for i in tmp do
113999: LD_ADDR_VAR 0 1
114003: PUSH
114004: LD_VAR 0 5
114008: PUSH
114009: FOR_IN
114010: IFFALSE 114151
// begin d := rand ( 0 , 5 ) ;
114012: LD_ADDR_VAR 0 4
114016: PUSH
114017: LD_INT 0
114019: PPUSH
114020: LD_INT 5
114022: PPUSH
114023: CALL_OW 12
114027: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
114028: LD_ADDR_VAR 0 2
114032: PUSH
114033: LD_VAR 0 1
114037: PPUSH
114038: CALL_OW 250
114042: PPUSH
114043: LD_VAR 0 4
114047: PPUSH
114048: LD_INT 3
114050: PPUSH
114051: LD_INT 12
114053: PPUSH
114054: CALL_OW 12
114058: PPUSH
114059: CALL_OW 272
114063: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
114064: LD_ADDR_VAR 0 3
114068: PUSH
114069: LD_VAR 0 1
114073: PPUSH
114074: CALL_OW 251
114078: PPUSH
114079: LD_VAR 0 4
114083: PPUSH
114084: LD_INT 3
114086: PPUSH
114087: LD_INT 12
114089: PPUSH
114090: CALL_OW 12
114094: PPUSH
114095: CALL_OW 273
114099: ST_TO_ADDR
// if ValidHex ( x , y ) then
114100: LD_VAR 0 2
114104: PPUSH
114105: LD_VAR 0 3
114109: PPUSH
114110: CALL_OW 488
114114: IFFALSE 114149
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
114116: LD_VAR 0 1
114120: PPUSH
114121: LD_VAR 0 2
114125: PPUSH
114126: LD_VAR 0 3
114130: PPUSH
114131: LD_INT 3
114133: PPUSH
114134: LD_INT 6
114136: PPUSH
114137: CALL_OW 12
114141: PPUSH
114142: LD_INT 1
114144: PPUSH
114145: CALL_OW 483
// end ;
114149: GO 114009
114151: POP
114152: POP
// end ;
114153: PPOPN 5
114155: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
114156: LD_EXP 160
114160: PUSH
114161: LD_EXP 195
114165: AND
114166: IFFALSE 114260
114168: GO 114170
114170: DISABLE
114171: LD_INT 0
114173: PPUSH
114174: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
114175: LD_ADDR_VAR 0 2
114179: PUSH
114180: LD_INT 22
114182: PUSH
114183: LD_OWVAR 2
114187: PUSH
114188: EMPTY
114189: LIST
114190: LIST
114191: PUSH
114192: LD_INT 32
114194: PUSH
114195: LD_INT 1
114197: PUSH
114198: EMPTY
114199: LIST
114200: LIST
114201: PUSH
114202: LD_INT 21
114204: PUSH
114205: LD_INT 2
114207: PUSH
114208: EMPTY
114209: LIST
114210: LIST
114211: PUSH
114212: EMPTY
114213: LIST
114214: LIST
114215: LIST
114216: PPUSH
114217: CALL_OW 69
114221: ST_TO_ADDR
// if not tmp then
114222: LD_VAR 0 2
114226: NOT
114227: IFFALSE 114231
// exit ;
114229: GO 114260
// for i in tmp do
114231: LD_ADDR_VAR 0 1
114235: PUSH
114236: LD_VAR 0 2
114240: PUSH
114241: FOR_IN
114242: IFFALSE 114258
// SetFuel ( i , 0 ) ;
114244: LD_VAR 0 1
114248: PPUSH
114249: LD_INT 0
114251: PPUSH
114252: CALL_OW 240
114256: GO 114241
114258: POP
114259: POP
// end ;
114260: PPOPN 2
114262: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
114263: LD_EXP 160
114267: PUSH
114268: LD_EXP 196
114272: AND
114273: IFFALSE 114339
114275: GO 114277
114277: DISABLE
114278: LD_INT 0
114280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
114281: LD_ADDR_VAR 0 1
114285: PUSH
114286: LD_INT 22
114288: PUSH
114289: LD_OWVAR 2
114293: PUSH
114294: EMPTY
114295: LIST
114296: LIST
114297: PUSH
114298: LD_INT 30
114300: PUSH
114301: LD_INT 29
114303: PUSH
114304: EMPTY
114305: LIST
114306: LIST
114307: PUSH
114308: EMPTY
114309: LIST
114310: LIST
114311: PPUSH
114312: CALL_OW 69
114316: ST_TO_ADDR
// if not tmp then
114317: LD_VAR 0 1
114321: NOT
114322: IFFALSE 114326
// exit ;
114324: GO 114339
// DestroyUnit ( tmp [ 1 ] ) ;
114326: LD_VAR 0 1
114330: PUSH
114331: LD_INT 1
114333: ARRAY
114334: PPUSH
114335: CALL_OW 65
// end ;
114339: PPOPN 1
114341: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
114342: LD_EXP 160
114346: PUSH
114347: LD_EXP 198
114351: AND
114352: IFFALSE 114481
114354: GO 114356
114356: DISABLE
114357: LD_INT 0
114359: PPUSH
// begin uc_side := 0 ;
114360: LD_ADDR_OWVAR 20
114364: PUSH
114365: LD_INT 0
114367: ST_TO_ADDR
// uc_nation := nation_arabian ;
114368: LD_ADDR_OWVAR 21
114372: PUSH
114373: LD_INT 2
114375: ST_TO_ADDR
// hc_gallery :=  ;
114376: LD_ADDR_OWVAR 33
114380: PUSH
114381: LD_STRING 
114383: ST_TO_ADDR
// hc_name :=  ;
114384: LD_ADDR_OWVAR 26
114388: PUSH
114389: LD_STRING 
114391: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
114392: LD_INT 1
114394: PPUSH
114395: LD_INT 11
114397: PPUSH
114398: LD_INT 10
114400: PPUSH
114401: CALL_OW 380
// un := CreateHuman ;
114405: LD_ADDR_VAR 0 1
114409: PUSH
114410: CALL_OW 44
114414: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
114415: LD_VAR 0 1
114419: PPUSH
114420: LD_INT 1
114422: PPUSH
114423: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
114427: LD_INT 35
114429: PPUSH
114430: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
114434: LD_VAR 0 1
114438: PPUSH
114439: LD_INT 22
114441: PUSH
114442: LD_OWVAR 2
114446: PUSH
114447: EMPTY
114448: LIST
114449: LIST
114450: PPUSH
114451: CALL_OW 69
114455: PPUSH
114456: LD_VAR 0 1
114460: PPUSH
114461: CALL_OW 74
114465: PPUSH
114466: CALL_OW 115
// until IsDead ( un ) ;
114470: LD_VAR 0 1
114474: PPUSH
114475: CALL_OW 301
114479: IFFALSE 114427
// end ;
114481: PPOPN 1
114483: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
114484: LD_EXP 160
114488: PUSH
114489: LD_EXP 200
114493: AND
114494: IFFALSE 114506
114496: GO 114498
114498: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
114499: LD_STRING earthquake(getX(game), 0, 32)
114501: PPUSH
114502: CALL_OW 559
114506: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
114507: LD_EXP 160
114511: PUSH
114512: LD_EXP 201
114516: AND
114517: IFFALSE 114608
114519: GO 114521
114521: DISABLE
114522: LD_INT 0
114524: PPUSH
// begin enable ;
114525: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
114526: LD_ADDR_VAR 0 1
114530: PUSH
114531: LD_INT 22
114533: PUSH
114534: LD_OWVAR 2
114538: PUSH
114539: EMPTY
114540: LIST
114541: LIST
114542: PUSH
114543: LD_INT 21
114545: PUSH
114546: LD_INT 2
114548: PUSH
114549: EMPTY
114550: LIST
114551: LIST
114552: PUSH
114553: LD_INT 33
114555: PUSH
114556: LD_INT 3
114558: PUSH
114559: EMPTY
114560: LIST
114561: LIST
114562: PUSH
114563: EMPTY
114564: LIST
114565: LIST
114566: LIST
114567: PPUSH
114568: CALL_OW 69
114572: ST_TO_ADDR
// if not tmp then
114573: LD_VAR 0 1
114577: NOT
114578: IFFALSE 114582
// exit ;
114580: GO 114608
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
114582: LD_VAR 0 1
114586: PUSH
114587: LD_INT 1
114589: PPUSH
114590: LD_VAR 0 1
114594: PPUSH
114595: CALL_OW 12
114599: ARRAY
114600: PPUSH
114601: LD_INT 1
114603: PPUSH
114604: CALL_OW 234
// end ;
114608: PPOPN 1
114610: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
114611: LD_EXP 160
114615: PUSH
114616: LD_EXP 202
114620: AND
114621: IFFALSE 114762
114623: GO 114625
114625: DISABLE
114626: LD_INT 0
114628: PPUSH
114629: PPUSH
114630: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114631: LD_ADDR_VAR 0 3
114635: PUSH
114636: LD_INT 22
114638: PUSH
114639: LD_OWVAR 2
114643: PUSH
114644: EMPTY
114645: LIST
114646: LIST
114647: PUSH
114648: LD_INT 25
114650: PUSH
114651: LD_INT 1
114653: PUSH
114654: EMPTY
114655: LIST
114656: LIST
114657: PUSH
114658: EMPTY
114659: LIST
114660: LIST
114661: PPUSH
114662: CALL_OW 69
114666: ST_TO_ADDR
// if not tmp then
114667: LD_VAR 0 3
114671: NOT
114672: IFFALSE 114676
// exit ;
114674: GO 114762
// un := tmp [ rand ( 1 , tmp ) ] ;
114676: LD_ADDR_VAR 0 2
114680: PUSH
114681: LD_VAR 0 3
114685: PUSH
114686: LD_INT 1
114688: PPUSH
114689: LD_VAR 0 3
114693: PPUSH
114694: CALL_OW 12
114698: ARRAY
114699: ST_TO_ADDR
// if Crawls ( un ) then
114700: LD_VAR 0 2
114704: PPUSH
114705: CALL_OW 318
114709: IFFALSE 114720
// ComWalk ( un ) ;
114711: LD_VAR 0 2
114715: PPUSH
114716: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
114720: LD_VAR 0 2
114724: PPUSH
114725: LD_INT 9
114727: PPUSH
114728: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
114732: LD_INT 28
114734: PPUSH
114735: LD_OWVAR 2
114739: PPUSH
114740: LD_INT 2
114742: PPUSH
114743: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
114747: LD_INT 29
114749: PPUSH
114750: LD_OWVAR 2
114754: PPUSH
114755: LD_INT 2
114757: PPUSH
114758: CALL_OW 322
// end ;
114762: PPOPN 3
114764: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
114765: LD_EXP 160
114769: PUSH
114770: LD_EXP 203
114774: AND
114775: IFFALSE 114886
114777: GO 114779
114779: DISABLE
114780: LD_INT 0
114782: PPUSH
114783: PPUSH
114784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114785: LD_ADDR_VAR 0 3
114789: PUSH
114790: LD_INT 22
114792: PUSH
114793: LD_OWVAR 2
114797: PUSH
114798: EMPTY
114799: LIST
114800: LIST
114801: PUSH
114802: LD_INT 25
114804: PUSH
114805: LD_INT 1
114807: PUSH
114808: EMPTY
114809: LIST
114810: LIST
114811: PUSH
114812: EMPTY
114813: LIST
114814: LIST
114815: PPUSH
114816: CALL_OW 69
114820: ST_TO_ADDR
// if not tmp then
114821: LD_VAR 0 3
114825: NOT
114826: IFFALSE 114830
// exit ;
114828: GO 114886
// un := tmp [ rand ( 1 , tmp ) ] ;
114830: LD_ADDR_VAR 0 2
114834: PUSH
114835: LD_VAR 0 3
114839: PUSH
114840: LD_INT 1
114842: PPUSH
114843: LD_VAR 0 3
114847: PPUSH
114848: CALL_OW 12
114852: ARRAY
114853: ST_TO_ADDR
// if Crawls ( un ) then
114854: LD_VAR 0 2
114858: PPUSH
114859: CALL_OW 318
114863: IFFALSE 114874
// ComWalk ( un ) ;
114865: LD_VAR 0 2
114869: PPUSH
114870: CALL_OW 138
// SetClass ( un , class_mortar ) ;
114874: LD_VAR 0 2
114878: PPUSH
114879: LD_INT 8
114881: PPUSH
114882: CALL_OW 336
// end ;
114886: PPOPN 3
114888: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
114889: LD_EXP 160
114893: PUSH
114894: LD_EXP 204
114898: AND
114899: IFFALSE 115043
114901: GO 114903
114903: DISABLE
114904: LD_INT 0
114906: PPUSH
114907: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
114908: LD_ADDR_VAR 0 2
114912: PUSH
114913: LD_INT 22
114915: PUSH
114916: LD_OWVAR 2
114920: PUSH
114921: EMPTY
114922: LIST
114923: LIST
114924: PUSH
114925: LD_INT 21
114927: PUSH
114928: LD_INT 2
114930: PUSH
114931: EMPTY
114932: LIST
114933: LIST
114934: PUSH
114935: LD_INT 2
114937: PUSH
114938: LD_INT 34
114940: PUSH
114941: LD_INT 12
114943: PUSH
114944: EMPTY
114945: LIST
114946: LIST
114947: PUSH
114948: LD_INT 34
114950: PUSH
114951: LD_INT 51
114953: PUSH
114954: EMPTY
114955: LIST
114956: LIST
114957: PUSH
114958: LD_INT 34
114960: PUSH
114961: LD_INT 32
114963: PUSH
114964: EMPTY
114965: LIST
114966: LIST
114967: PUSH
114968: EMPTY
114969: LIST
114970: LIST
114971: LIST
114972: LIST
114973: PUSH
114974: EMPTY
114975: LIST
114976: LIST
114977: LIST
114978: PPUSH
114979: CALL_OW 69
114983: ST_TO_ADDR
// if not tmp then
114984: LD_VAR 0 2
114988: NOT
114989: IFFALSE 114993
// exit ;
114991: GO 115043
// for i in tmp do
114993: LD_ADDR_VAR 0 1
114997: PUSH
114998: LD_VAR 0 2
115002: PUSH
115003: FOR_IN
115004: IFFALSE 115041
// if GetCargo ( i , mat_artifact ) = 0 then
115006: LD_VAR 0 1
115010: PPUSH
115011: LD_INT 4
115013: PPUSH
115014: CALL_OW 289
115018: PUSH
115019: LD_INT 0
115021: EQUAL
115022: IFFALSE 115039
// SetCargo ( i , mat_siberit , 100 ) ;
115024: LD_VAR 0 1
115028: PPUSH
115029: LD_INT 3
115031: PPUSH
115032: LD_INT 100
115034: PPUSH
115035: CALL_OW 290
115039: GO 115003
115041: POP
115042: POP
// end ;
115043: PPOPN 2
115045: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
115046: LD_EXP 160
115050: PUSH
115051: LD_EXP 205
115055: AND
115056: IFFALSE 115239
115058: GO 115060
115060: DISABLE
115061: LD_INT 0
115063: PPUSH
115064: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
115065: LD_ADDR_VAR 0 2
115069: PUSH
115070: LD_INT 22
115072: PUSH
115073: LD_OWVAR 2
115077: PUSH
115078: EMPTY
115079: LIST
115080: LIST
115081: PPUSH
115082: CALL_OW 69
115086: ST_TO_ADDR
// if not tmp then
115087: LD_VAR 0 2
115091: NOT
115092: IFFALSE 115096
// exit ;
115094: GO 115239
// for i := 1 to 2 do
115096: LD_ADDR_VAR 0 1
115100: PUSH
115101: DOUBLE
115102: LD_INT 1
115104: DEC
115105: ST_TO_ADDR
115106: LD_INT 2
115108: PUSH
115109: FOR_TO
115110: IFFALSE 115237
// begin uc_side := your_side ;
115112: LD_ADDR_OWVAR 20
115116: PUSH
115117: LD_OWVAR 2
115121: ST_TO_ADDR
// uc_nation := nation_american ;
115122: LD_ADDR_OWVAR 21
115126: PUSH
115127: LD_INT 1
115129: ST_TO_ADDR
// vc_chassis := us_morphling ;
115130: LD_ADDR_OWVAR 37
115134: PUSH
115135: LD_INT 5
115137: ST_TO_ADDR
// vc_engine := engine_siberite ;
115138: LD_ADDR_OWVAR 39
115142: PUSH
115143: LD_INT 3
115145: ST_TO_ADDR
// vc_control := control_computer ;
115146: LD_ADDR_OWVAR 38
115150: PUSH
115151: LD_INT 3
115153: ST_TO_ADDR
// vc_weapon := us_double_laser ;
115154: LD_ADDR_OWVAR 40
115158: PUSH
115159: LD_INT 10
115161: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
115162: LD_VAR 0 2
115166: PUSH
115167: LD_INT 1
115169: ARRAY
115170: PPUSH
115171: CALL_OW 310
115175: NOT
115176: IFFALSE 115223
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
115178: CALL_OW 45
115182: PPUSH
115183: LD_VAR 0 2
115187: PUSH
115188: LD_INT 1
115190: ARRAY
115191: PPUSH
115192: CALL_OW 250
115196: PPUSH
115197: LD_VAR 0 2
115201: PUSH
115202: LD_INT 1
115204: ARRAY
115205: PPUSH
115206: CALL_OW 251
115210: PPUSH
115211: LD_INT 12
115213: PPUSH
115214: LD_INT 1
115216: PPUSH
115217: CALL_OW 50
115221: GO 115235
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
115223: CALL_OW 45
115227: PPUSH
115228: LD_INT 1
115230: PPUSH
115231: CALL_OW 51
// end ;
115235: GO 115109
115237: POP
115238: POP
// end ;
115239: PPOPN 2
115241: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
115242: LD_EXP 160
115246: PUSH
115247: LD_EXP 206
115251: AND
115252: IFFALSE 115474
115254: GO 115256
115256: DISABLE
115257: LD_INT 0
115259: PPUSH
115260: PPUSH
115261: PPUSH
115262: PPUSH
115263: PPUSH
115264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115265: LD_ADDR_VAR 0 6
115269: PUSH
115270: LD_INT 22
115272: PUSH
115273: LD_OWVAR 2
115277: PUSH
115278: EMPTY
115279: LIST
115280: LIST
115281: PUSH
115282: LD_INT 21
115284: PUSH
115285: LD_INT 1
115287: PUSH
115288: EMPTY
115289: LIST
115290: LIST
115291: PUSH
115292: LD_INT 3
115294: PUSH
115295: LD_INT 23
115297: PUSH
115298: LD_INT 0
115300: PUSH
115301: EMPTY
115302: LIST
115303: LIST
115304: PUSH
115305: EMPTY
115306: LIST
115307: LIST
115308: PUSH
115309: EMPTY
115310: LIST
115311: LIST
115312: LIST
115313: PPUSH
115314: CALL_OW 69
115318: ST_TO_ADDR
// if not tmp then
115319: LD_VAR 0 6
115323: NOT
115324: IFFALSE 115328
// exit ;
115326: GO 115474
// s1 := rand ( 1 , 4 ) ;
115328: LD_ADDR_VAR 0 2
115332: PUSH
115333: LD_INT 1
115335: PPUSH
115336: LD_INT 4
115338: PPUSH
115339: CALL_OW 12
115343: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
115344: LD_ADDR_VAR 0 4
115348: PUSH
115349: LD_VAR 0 6
115353: PUSH
115354: LD_INT 1
115356: ARRAY
115357: PPUSH
115358: LD_VAR 0 2
115362: PPUSH
115363: CALL_OW 259
115367: ST_TO_ADDR
// if s1 = 1 then
115368: LD_VAR 0 2
115372: PUSH
115373: LD_INT 1
115375: EQUAL
115376: IFFALSE 115396
// s2 := rand ( 2 , 4 ) else
115378: LD_ADDR_VAR 0 3
115382: PUSH
115383: LD_INT 2
115385: PPUSH
115386: LD_INT 4
115388: PPUSH
115389: CALL_OW 12
115393: ST_TO_ADDR
115394: GO 115404
// s2 := 1 ;
115396: LD_ADDR_VAR 0 3
115400: PUSH
115401: LD_INT 1
115403: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
115404: LD_ADDR_VAR 0 5
115408: PUSH
115409: LD_VAR 0 6
115413: PUSH
115414: LD_INT 1
115416: ARRAY
115417: PPUSH
115418: LD_VAR 0 3
115422: PPUSH
115423: CALL_OW 259
115427: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
115428: LD_VAR 0 6
115432: PUSH
115433: LD_INT 1
115435: ARRAY
115436: PPUSH
115437: LD_VAR 0 2
115441: PPUSH
115442: LD_VAR 0 5
115446: PPUSH
115447: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
115451: LD_VAR 0 6
115455: PUSH
115456: LD_INT 1
115458: ARRAY
115459: PPUSH
115460: LD_VAR 0 3
115464: PPUSH
115465: LD_VAR 0 4
115469: PPUSH
115470: CALL_OW 237
// end ;
115474: PPOPN 6
115476: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
115477: LD_EXP 160
115481: PUSH
115482: LD_EXP 207
115486: AND
115487: IFFALSE 115566
115489: GO 115491
115491: DISABLE
115492: LD_INT 0
115494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
115495: LD_ADDR_VAR 0 1
115499: PUSH
115500: LD_INT 22
115502: PUSH
115503: LD_OWVAR 2
115507: PUSH
115508: EMPTY
115509: LIST
115510: LIST
115511: PUSH
115512: LD_INT 30
115514: PUSH
115515: LD_INT 3
115517: PUSH
115518: EMPTY
115519: LIST
115520: LIST
115521: PUSH
115522: EMPTY
115523: LIST
115524: LIST
115525: PPUSH
115526: CALL_OW 69
115530: ST_TO_ADDR
// if not tmp then
115531: LD_VAR 0 1
115535: NOT
115536: IFFALSE 115540
// exit ;
115538: GO 115566
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
115540: LD_VAR 0 1
115544: PUSH
115545: LD_INT 1
115547: PPUSH
115548: LD_VAR 0 1
115552: PPUSH
115553: CALL_OW 12
115557: ARRAY
115558: PPUSH
115559: LD_INT 1
115561: PPUSH
115562: CALL_OW 234
// end ;
115566: PPOPN 1
115568: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
115569: LD_EXP 160
115573: PUSH
115574: LD_EXP 208
115578: AND
115579: IFFALSE 115691
115581: GO 115583
115583: DISABLE
115584: LD_INT 0
115586: PPUSH
115587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
115588: LD_ADDR_VAR 0 2
115592: PUSH
115593: LD_INT 22
115595: PUSH
115596: LD_OWVAR 2
115600: PUSH
115601: EMPTY
115602: LIST
115603: LIST
115604: PUSH
115605: LD_INT 2
115607: PUSH
115608: LD_INT 30
115610: PUSH
115611: LD_INT 27
115613: PUSH
115614: EMPTY
115615: LIST
115616: LIST
115617: PUSH
115618: LD_INT 30
115620: PUSH
115621: LD_INT 26
115623: PUSH
115624: EMPTY
115625: LIST
115626: LIST
115627: PUSH
115628: LD_INT 30
115630: PUSH
115631: LD_INT 28
115633: PUSH
115634: EMPTY
115635: LIST
115636: LIST
115637: PUSH
115638: EMPTY
115639: LIST
115640: LIST
115641: LIST
115642: LIST
115643: PUSH
115644: EMPTY
115645: LIST
115646: LIST
115647: PPUSH
115648: CALL_OW 69
115652: ST_TO_ADDR
// if not tmp then
115653: LD_VAR 0 2
115657: NOT
115658: IFFALSE 115662
// exit ;
115660: GO 115691
// for i in tmp do
115662: LD_ADDR_VAR 0 1
115666: PUSH
115667: LD_VAR 0 2
115671: PUSH
115672: FOR_IN
115673: IFFALSE 115689
// SetLives ( i , 1 ) ;
115675: LD_VAR 0 1
115679: PPUSH
115680: LD_INT 1
115682: PPUSH
115683: CALL_OW 234
115687: GO 115672
115689: POP
115690: POP
// end ;
115691: PPOPN 2
115693: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
115694: LD_EXP 160
115698: PUSH
115699: LD_EXP 209
115703: AND
115704: IFFALSE 115978
115706: GO 115708
115708: DISABLE
115709: LD_INT 0
115711: PPUSH
115712: PPUSH
115713: PPUSH
// begin i := rand ( 1 , 7 ) ;
115714: LD_ADDR_VAR 0 1
115718: PUSH
115719: LD_INT 1
115721: PPUSH
115722: LD_INT 7
115724: PPUSH
115725: CALL_OW 12
115729: ST_TO_ADDR
// case i of 1 :
115730: LD_VAR 0 1
115734: PUSH
115735: LD_INT 1
115737: DOUBLE
115738: EQUAL
115739: IFTRUE 115743
115741: GO 115753
115743: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
115744: LD_STRING earthquake(getX(game), 0, 32)
115746: PPUSH
115747: CALL_OW 559
115751: GO 115978
115753: LD_INT 2
115755: DOUBLE
115756: EQUAL
115757: IFTRUE 115761
115759: GO 115775
115761: POP
// begin ToLua ( displayStucuk(); ) ;
115762: LD_STRING displayStucuk();
115764: PPUSH
115765: CALL_OW 559
// ResetFog ;
115769: CALL_OW 335
// end ; 3 :
115773: GO 115978
115775: LD_INT 3
115777: DOUBLE
115778: EQUAL
115779: IFTRUE 115783
115781: GO 115887
115783: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
115784: LD_ADDR_VAR 0 2
115788: PUSH
115789: LD_INT 22
115791: PUSH
115792: LD_OWVAR 2
115796: PUSH
115797: EMPTY
115798: LIST
115799: LIST
115800: PUSH
115801: LD_INT 25
115803: PUSH
115804: LD_INT 1
115806: PUSH
115807: EMPTY
115808: LIST
115809: LIST
115810: PUSH
115811: EMPTY
115812: LIST
115813: LIST
115814: PPUSH
115815: CALL_OW 69
115819: ST_TO_ADDR
// if not tmp then
115820: LD_VAR 0 2
115824: NOT
115825: IFFALSE 115829
// exit ;
115827: GO 115978
// un := tmp [ rand ( 1 , tmp ) ] ;
115829: LD_ADDR_VAR 0 3
115833: PUSH
115834: LD_VAR 0 2
115838: PUSH
115839: LD_INT 1
115841: PPUSH
115842: LD_VAR 0 2
115846: PPUSH
115847: CALL_OW 12
115851: ARRAY
115852: ST_TO_ADDR
// if Crawls ( un ) then
115853: LD_VAR 0 3
115857: PPUSH
115858: CALL_OW 318
115862: IFFALSE 115873
// ComWalk ( un ) ;
115864: LD_VAR 0 3
115868: PPUSH
115869: CALL_OW 138
// SetClass ( un , class_mortar ) ;
115873: LD_VAR 0 3
115877: PPUSH
115878: LD_INT 8
115880: PPUSH
115881: CALL_OW 336
// end ; 4 :
115885: GO 115978
115887: LD_INT 4
115889: DOUBLE
115890: EQUAL
115891: IFTRUE 115895
115893: GO 115956
115895: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
115896: LD_ADDR_VAR 0 2
115900: PUSH
115901: LD_INT 22
115903: PUSH
115904: LD_OWVAR 2
115908: PUSH
115909: EMPTY
115910: LIST
115911: LIST
115912: PUSH
115913: LD_INT 30
115915: PUSH
115916: LD_INT 29
115918: PUSH
115919: EMPTY
115920: LIST
115921: LIST
115922: PUSH
115923: EMPTY
115924: LIST
115925: LIST
115926: PPUSH
115927: CALL_OW 69
115931: ST_TO_ADDR
// if not tmp then
115932: LD_VAR 0 2
115936: NOT
115937: IFFALSE 115941
// exit ;
115939: GO 115978
// DestroyUnit ( tmp [ 1 ] ) ;
115941: LD_VAR 0 2
115945: PUSH
115946: LD_INT 1
115948: ARRAY
115949: PPUSH
115950: CALL_OW 65
// end ; 5 .. 7 :
115954: GO 115978
115956: LD_INT 5
115958: DOUBLE
115959: GREATEREQUAL
115960: IFFALSE 115968
115962: LD_INT 7
115964: DOUBLE
115965: LESSEQUAL
115966: IFTRUE 115970
115968: GO 115977
115970: POP
// StreamSibBomb ; end ;
115971: CALL 112228 0 0
115975: GO 115978
115977: POP
// end ;
115978: PPOPN 3
115980: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
115981: LD_EXP 160
115985: PUSH
115986: LD_EXP 210
115990: AND
115991: IFFALSE 116147
115993: GO 115995
115995: DISABLE
115996: LD_INT 0
115998: PPUSH
115999: PPUSH
116000: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
116001: LD_ADDR_VAR 0 2
116005: PUSH
116006: LD_INT 81
116008: PUSH
116009: LD_OWVAR 2
116013: PUSH
116014: EMPTY
116015: LIST
116016: LIST
116017: PUSH
116018: LD_INT 2
116020: PUSH
116021: LD_INT 21
116023: PUSH
116024: LD_INT 1
116026: PUSH
116027: EMPTY
116028: LIST
116029: LIST
116030: PUSH
116031: LD_INT 21
116033: PUSH
116034: LD_INT 2
116036: PUSH
116037: EMPTY
116038: LIST
116039: LIST
116040: PUSH
116041: EMPTY
116042: LIST
116043: LIST
116044: LIST
116045: PUSH
116046: EMPTY
116047: LIST
116048: LIST
116049: PPUSH
116050: CALL_OW 69
116054: ST_TO_ADDR
// if not tmp then
116055: LD_VAR 0 2
116059: NOT
116060: IFFALSE 116064
// exit ;
116062: GO 116147
// p := 0 ;
116064: LD_ADDR_VAR 0 3
116068: PUSH
116069: LD_INT 0
116071: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
116072: LD_INT 35
116074: PPUSH
116075: CALL_OW 67
// p := p + 1 ;
116079: LD_ADDR_VAR 0 3
116083: PUSH
116084: LD_VAR 0 3
116088: PUSH
116089: LD_INT 1
116091: PLUS
116092: ST_TO_ADDR
// for i in tmp do
116093: LD_ADDR_VAR 0 1
116097: PUSH
116098: LD_VAR 0 2
116102: PUSH
116103: FOR_IN
116104: IFFALSE 116135
// if GetLives ( i ) < 1000 then
116106: LD_VAR 0 1
116110: PPUSH
116111: CALL_OW 256
116115: PUSH
116116: LD_INT 1000
116118: LESS
116119: IFFALSE 116133
// SetLives ( i , 1000 ) ;
116121: LD_VAR 0 1
116125: PPUSH
116126: LD_INT 1000
116128: PPUSH
116129: CALL_OW 234
116133: GO 116103
116135: POP
116136: POP
// until p > 20 ;
116137: LD_VAR 0 3
116141: PUSH
116142: LD_INT 20
116144: GREATER
116145: IFFALSE 116072
// end ;
116147: PPOPN 3
116149: END
// every 0 0$1 trigger StreamModeActive and sTime do
116150: LD_EXP 160
116154: PUSH
116155: LD_EXP 211
116159: AND
116160: IFFALSE 116195
116162: GO 116164
116164: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
116165: LD_INT 28
116167: PPUSH
116168: LD_OWVAR 2
116172: PPUSH
116173: LD_INT 2
116175: PPUSH
116176: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
116180: LD_INT 30
116182: PPUSH
116183: LD_OWVAR 2
116187: PPUSH
116188: LD_INT 2
116190: PPUSH
116191: CALL_OW 322
// end ;
116195: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
116196: LD_EXP 160
116200: PUSH
116201: LD_EXP 212
116205: AND
116206: IFFALSE 116327
116208: GO 116210
116210: DISABLE
116211: LD_INT 0
116213: PPUSH
116214: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
116215: LD_ADDR_VAR 0 2
116219: PUSH
116220: LD_INT 22
116222: PUSH
116223: LD_OWVAR 2
116227: PUSH
116228: EMPTY
116229: LIST
116230: LIST
116231: PUSH
116232: LD_INT 21
116234: PUSH
116235: LD_INT 1
116237: PUSH
116238: EMPTY
116239: LIST
116240: LIST
116241: PUSH
116242: LD_INT 3
116244: PUSH
116245: LD_INT 23
116247: PUSH
116248: LD_INT 0
116250: PUSH
116251: EMPTY
116252: LIST
116253: LIST
116254: PUSH
116255: EMPTY
116256: LIST
116257: LIST
116258: PUSH
116259: EMPTY
116260: LIST
116261: LIST
116262: LIST
116263: PPUSH
116264: CALL_OW 69
116268: ST_TO_ADDR
// if not tmp then
116269: LD_VAR 0 2
116273: NOT
116274: IFFALSE 116278
// exit ;
116276: GO 116327
// for i in tmp do
116278: LD_ADDR_VAR 0 1
116282: PUSH
116283: LD_VAR 0 2
116287: PUSH
116288: FOR_IN
116289: IFFALSE 116325
// begin if Crawls ( i ) then
116291: LD_VAR 0 1
116295: PPUSH
116296: CALL_OW 318
116300: IFFALSE 116311
// ComWalk ( i ) ;
116302: LD_VAR 0 1
116306: PPUSH
116307: CALL_OW 138
// SetClass ( i , 2 ) ;
116311: LD_VAR 0 1
116315: PPUSH
116316: LD_INT 2
116318: PPUSH
116319: CALL_OW 336
// end ;
116323: GO 116288
116325: POP
116326: POP
// end ;
116327: PPOPN 2
116329: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
116330: LD_EXP 160
116334: PUSH
116335: LD_EXP 213
116339: AND
116340: IFFALSE 116621
116342: GO 116344
116344: DISABLE
116345: LD_INT 0
116347: PPUSH
116348: PPUSH
116349: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
116350: LD_OWVAR 2
116354: PPUSH
116355: LD_INT 9
116357: PPUSH
116358: LD_INT 1
116360: PPUSH
116361: LD_INT 1
116363: PPUSH
116364: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
116368: LD_INT 9
116370: PPUSH
116371: LD_OWVAR 2
116375: PPUSH
116376: CALL_OW 343
// uc_side := 9 ;
116380: LD_ADDR_OWVAR 20
116384: PUSH
116385: LD_INT 9
116387: ST_TO_ADDR
// uc_nation := 2 ;
116388: LD_ADDR_OWVAR 21
116392: PUSH
116393: LD_INT 2
116395: ST_TO_ADDR
// hc_name := Dark Warrior ;
116396: LD_ADDR_OWVAR 26
116400: PUSH
116401: LD_STRING Dark Warrior
116403: ST_TO_ADDR
// hc_gallery :=  ;
116404: LD_ADDR_OWVAR 33
116408: PUSH
116409: LD_STRING 
116411: ST_TO_ADDR
// hc_noskilllimit := true ;
116412: LD_ADDR_OWVAR 76
116416: PUSH
116417: LD_INT 1
116419: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
116420: LD_ADDR_OWVAR 31
116424: PUSH
116425: LD_INT 30
116427: PUSH
116428: LD_INT 30
116430: PUSH
116431: LD_INT 30
116433: PUSH
116434: LD_INT 30
116436: PUSH
116437: EMPTY
116438: LIST
116439: LIST
116440: LIST
116441: LIST
116442: ST_TO_ADDR
// un := CreateHuman ;
116443: LD_ADDR_VAR 0 3
116447: PUSH
116448: CALL_OW 44
116452: ST_TO_ADDR
// hc_noskilllimit := false ;
116453: LD_ADDR_OWVAR 76
116457: PUSH
116458: LD_INT 0
116460: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116461: LD_VAR 0 3
116465: PPUSH
116466: LD_INT 1
116468: PPUSH
116469: CALL_OW 51
// p := 0 ;
116473: LD_ADDR_VAR 0 2
116477: PUSH
116478: LD_INT 0
116480: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
116481: LD_INT 35
116483: PPUSH
116484: CALL_OW 67
// p := p + 1 ;
116488: LD_ADDR_VAR 0 2
116492: PUSH
116493: LD_VAR 0 2
116497: PUSH
116498: LD_INT 1
116500: PLUS
116501: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
116502: LD_VAR 0 3
116506: PPUSH
116507: CALL_OW 256
116511: PUSH
116512: LD_INT 1000
116514: LESS
116515: IFFALSE 116529
// SetLives ( un , 1000 ) ;
116517: LD_VAR 0 3
116521: PPUSH
116522: LD_INT 1000
116524: PPUSH
116525: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
116529: LD_VAR 0 3
116533: PPUSH
116534: LD_INT 81
116536: PUSH
116537: LD_OWVAR 2
116541: PUSH
116542: EMPTY
116543: LIST
116544: LIST
116545: PUSH
116546: LD_INT 91
116548: PUSH
116549: LD_VAR 0 3
116553: PUSH
116554: LD_INT 30
116556: PUSH
116557: EMPTY
116558: LIST
116559: LIST
116560: LIST
116561: PUSH
116562: EMPTY
116563: LIST
116564: LIST
116565: PPUSH
116566: CALL_OW 69
116570: PPUSH
116571: LD_VAR 0 3
116575: PPUSH
116576: CALL_OW 74
116580: PPUSH
116581: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
116585: LD_VAR 0 2
116589: PUSH
116590: LD_INT 60
116592: GREATER
116593: PUSH
116594: LD_VAR 0 3
116598: PPUSH
116599: CALL_OW 301
116603: OR
116604: IFFALSE 116481
// if un then
116606: LD_VAR 0 3
116610: IFFALSE 116621
// RemoveUnit ( un ) ;
116612: LD_VAR 0 3
116616: PPUSH
116617: CALL_OW 64
// end ;
116621: PPOPN 3
116623: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
116624: LD_INT 0
116626: PPUSH
// case cmd of 301 :
116627: LD_VAR 0 1
116631: PUSH
116632: LD_INT 301
116634: DOUBLE
116635: EQUAL
116636: IFTRUE 116640
116638: GO 116672
116640: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
116641: LD_VAR 0 6
116645: PPUSH
116646: LD_VAR 0 7
116650: PPUSH
116651: LD_VAR 0 8
116655: PPUSH
116656: LD_VAR 0 4
116660: PPUSH
116661: LD_VAR 0 5
116665: PPUSH
116666: CALL 117873 0 5
116670: GO 116793
116672: LD_INT 302
116674: DOUBLE
116675: EQUAL
116676: IFTRUE 116680
116678: GO 116717
116680: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
116681: LD_VAR 0 6
116685: PPUSH
116686: LD_VAR 0 7
116690: PPUSH
116691: LD_VAR 0 8
116695: PPUSH
116696: LD_VAR 0 9
116700: PPUSH
116701: LD_VAR 0 4
116705: PPUSH
116706: LD_VAR 0 5
116710: PPUSH
116711: CALL 117964 0 6
116715: GO 116793
116717: LD_INT 303
116719: DOUBLE
116720: EQUAL
116721: IFTRUE 116725
116723: GO 116762
116725: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
116726: LD_VAR 0 6
116730: PPUSH
116731: LD_VAR 0 7
116735: PPUSH
116736: LD_VAR 0 8
116740: PPUSH
116741: LD_VAR 0 9
116745: PPUSH
116746: LD_VAR 0 4
116750: PPUSH
116751: LD_VAR 0 5
116755: PPUSH
116756: CALL 116798 0 6
116760: GO 116793
116762: LD_INT 304
116764: DOUBLE
116765: EQUAL
116766: IFTRUE 116770
116768: GO 116792
116770: POP
// hHackTeleport ( unit , x , y ) ; end ;
116771: LD_VAR 0 2
116775: PPUSH
116776: LD_VAR 0 4
116780: PPUSH
116781: LD_VAR 0 5
116785: PPUSH
116786: CALL 118557 0 3
116790: GO 116793
116792: POP
// end ;
116793: LD_VAR 0 12
116797: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
116798: LD_INT 0
116800: PPUSH
116801: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
116802: LD_VAR 0 1
116806: PUSH
116807: LD_INT 1
116809: LESS
116810: PUSH
116811: LD_VAR 0 1
116815: PUSH
116816: LD_INT 3
116818: GREATER
116819: OR
116820: PUSH
116821: LD_VAR 0 5
116825: PPUSH
116826: LD_VAR 0 6
116830: PPUSH
116831: CALL_OW 428
116835: OR
116836: IFFALSE 116840
// exit ;
116838: GO 117560
// uc_side := your_side ;
116840: LD_ADDR_OWVAR 20
116844: PUSH
116845: LD_OWVAR 2
116849: ST_TO_ADDR
// uc_nation := nation ;
116850: LD_ADDR_OWVAR 21
116854: PUSH
116855: LD_VAR 0 1
116859: ST_TO_ADDR
// bc_level = 1 ;
116860: LD_ADDR_OWVAR 43
116864: PUSH
116865: LD_INT 1
116867: ST_TO_ADDR
// case btype of 1 :
116868: LD_VAR 0 2
116872: PUSH
116873: LD_INT 1
116875: DOUBLE
116876: EQUAL
116877: IFTRUE 116881
116879: GO 116892
116881: POP
// bc_type := b_depot ; 2 :
116882: LD_ADDR_OWVAR 42
116886: PUSH
116887: LD_INT 0
116889: ST_TO_ADDR
116890: GO 117504
116892: LD_INT 2
116894: DOUBLE
116895: EQUAL
116896: IFTRUE 116900
116898: GO 116911
116900: POP
// bc_type := b_warehouse ; 3 :
116901: LD_ADDR_OWVAR 42
116905: PUSH
116906: LD_INT 1
116908: ST_TO_ADDR
116909: GO 117504
116911: LD_INT 3
116913: DOUBLE
116914: EQUAL
116915: IFTRUE 116919
116917: GO 116930
116919: POP
// bc_type := b_lab ; 4 .. 9 :
116920: LD_ADDR_OWVAR 42
116924: PUSH
116925: LD_INT 6
116927: ST_TO_ADDR
116928: GO 117504
116930: LD_INT 4
116932: DOUBLE
116933: GREATEREQUAL
116934: IFFALSE 116942
116936: LD_INT 9
116938: DOUBLE
116939: LESSEQUAL
116940: IFTRUE 116944
116942: GO 116996
116944: POP
// begin bc_type := b_lab_half ;
116945: LD_ADDR_OWVAR 42
116949: PUSH
116950: LD_INT 7
116952: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
116953: LD_ADDR_OWVAR 44
116957: PUSH
116958: LD_INT 10
116960: PUSH
116961: LD_INT 11
116963: PUSH
116964: LD_INT 12
116966: PUSH
116967: LD_INT 15
116969: PUSH
116970: LD_INT 14
116972: PUSH
116973: LD_INT 13
116975: PUSH
116976: EMPTY
116977: LIST
116978: LIST
116979: LIST
116980: LIST
116981: LIST
116982: LIST
116983: PUSH
116984: LD_VAR 0 2
116988: PUSH
116989: LD_INT 3
116991: MINUS
116992: ARRAY
116993: ST_TO_ADDR
// end ; 10 .. 13 :
116994: GO 117504
116996: LD_INT 10
116998: DOUBLE
116999: GREATEREQUAL
117000: IFFALSE 117008
117002: LD_INT 13
117004: DOUBLE
117005: LESSEQUAL
117006: IFTRUE 117010
117008: GO 117087
117010: POP
// begin bc_type := b_lab_full ;
117011: LD_ADDR_OWVAR 42
117015: PUSH
117016: LD_INT 8
117018: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
117019: LD_ADDR_OWVAR 44
117023: PUSH
117024: LD_INT 10
117026: PUSH
117027: LD_INT 12
117029: PUSH
117030: LD_INT 14
117032: PUSH
117033: LD_INT 13
117035: PUSH
117036: EMPTY
117037: LIST
117038: LIST
117039: LIST
117040: LIST
117041: PUSH
117042: LD_VAR 0 2
117046: PUSH
117047: LD_INT 9
117049: MINUS
117050: ARRAY
117051: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
117052: LD_ADDR_OWVAR 45
117056: PUSH
117057: LD_INT 11
117059: PUSH
117060: LD_INT 15
117062: PUSH
117063: LD_INT 12
117065: PUSH
117066: LD_INT 15
117068: PUSH
117069: EMPTY
117070: LIST
117071: LIST
117072: LIST
117073: LIST
117074: PUSH
117075: LD_VAR 0 2
117079: PUSH
117080: LD_INT 9
117082: MINUS
117083: ARRAY
117084: ST_TO_ADDR
// end ; 14 :
117085: GO 117504
117087: LD_INT 14
117089: DOUBLE
117090: EQUAL
117091: IFTRUE 117095
117093: GO 117106
117095: POP
// bc_type := b_workshop ; 15 :
117096: LD_ADDR_OWVAR 42
117100: PUSH
117101: LD_INT 2
117103: ST_TO_ADDR
117104: GO 117504
117106: LD_INT 15
117108: DOUBLE
117109: EQUAL
117110: IFTRUE 117114
117112: GO 117125
117114: POP
// bc_type := b_factory ; 16 :
117115: LD_ADDR_OWVAR 42
117119: PUSH
117120: LD_INT 3
117122: ST_TO_ADDR
117123: GO 117504
117125: LD_INT 16
117127: DOUBLE
117128: EQUAL
117129: IFTRUE 117133
117131: GO 117144
117133: POP
// bc_type := b_ext_gun ; 17 :
117134: LD_ADDR_OWVAR 42
117138: PUSH
117139: LD_INT 17
117141: ST_TO_ADDR
117142: GO 117504
117144: LD_INT 17
117146: DOUBLE
117147: EQUAL
117148: IFTRUE 117152
117150: GO 117180
117152: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
117153: LD_ADDR_OWVAR 42
117157: PUSH
117158: LD_INT 19
117160: PUSH
117161: LD_INT 23
117163: PUSH
117164: LD_INT 19
117166: PUSH
117167: EMPTY
117168: LIST
117169: LIST
117170: LIST
117171: PUSH
117172: LD_VAR 0 1
117176: ARRAY
117177: ST_TO_ADDR
117178: GO 117504
117180: LD_INT 18
117182: DOUBLE
117183: EQUAL
117184: IFTRUE 117188
117186: GO 117199
117188: POP
// bc_type := b_ext_radar ; 19 :
117189: LD_ADDR_OWVAR 42
117193: PUSH
117194: LD_INT 20
117196: ST_TO_ADDR
117197: GO 117504
117199: LD_INT 19
117201: DOUBLE
117202: EQUAL
117203: IFTRUE 117207
117205: GO 117218
117207: POP
// bc_type := b_ext_radio ; 20 :
117208: LD_ADDR_OWVAR 42
117212: PUSH
117213: LD_INT 22
117215: ST_TO_ADDR
117216: GO 117504
117218: LD_INT 20
117220: DOUBLE
117221: EQUAL
117222: IFTRUE 117226
117224: GO 117237
117226: POP
// bc_type := b_ext_siberium ; 21 :
117227: LD_ADDR_OWVAR 42
117231: PUSH
117232: LD_INT 21
117234: ST_TO_ADDR
117235: GO 117504
117237: LD_INT 21
117239: DOUBLE
117240: EQUAL
117241: IFTRUE 117245
117243: GO 117256
117245: POP
// bc_type := b_ext_computer ; 22 :
117246: LD_ADDR_OWVAR 42
117250: PUSH
117251: LD_INT 24
117253: ST_TO_ADDR
117254: GO 117504
117256: LD_INT 22
117258: DOUBLE
117259: EQUAL
117260: IFTRUE 117264
117262: GO 117275
117264: POP
// bc_type := b_ext_track ; 23 :
117265: LD_ADDR_OWVAR 42
117269: PUSH
117270: LD_INT 16
117272: ST_TO_ADDR
117273: GO 117504
117275: LD_INT 23
117277: DOUBLE
117278: EQUAL
117279: IFTRUE 117283
117281: GO 117294
117283: POP
// bc_type := b_ext_laser ; 24 :
117284: LD_ADDR_OWVAR 42
117288: PUSH
117289: LD_INT 25
117291: ST_TO_ADDR
117292: GO 117504
117294: LD_INT 24
117296: DOUBLE
117297: EQUAL
117298: IFTRUE 117302
117300: GO 117313
117302: POP
// bc_type := b_control_tower ; 25 :
117303: LD_ADDR_OWVAR 42
117307: PUSH
117308: LD_INT 36
117310: ST_TO_ADDR
117311: GO 117504
117313: LD_INT 25
117315: DOUBLE
117316: EQUAL
117317: IFTRUE 117321
117319: GO 117332
117321: POP
// bc_type := b_breastwork ; 26 :
117322: LD_ADDR_OWVAR 42
117326: PUSH
117327: LD_INT 31
117329: ST_TO_ADDR
117330: GO 117504
117332: LD_INT 26
117334: DOUBLE
117335: EQUAL
117336: IFTRUE 117340
117338: GO 117351
117340: POP
// bc_type := b_bunker ; 27 :
117341: LD_ADDR_OWVAR 42
117345: PUSH
117346: LD_INT 32
117348: ST_TO_ADDR
117349: GO 117504
117351: LD_INT 27
117353: DOUBLE
117354: EQUAL
117355: IFTRUE 117359
117357: GO 117370
117359: POP
// bc_type := b_turret ; 28 :
117360: LD_ADDR_OWVAR 42
117364: PUSH
117365: LD_INT 33
117367: ST_TO_ADDR
117368: GO 117504
117370: LD_INT 28
117372: DOUBLE
117373: EQUAL
117374: IFTRUE 117378
117376: GO 117389
117378: POP
// bc_type := b_armoury ; 29 :
117379: LD_ADDR_OWVAR 42
117383: PUSH
117384: LD_INT 4
117386: ST_TO_ADDR
117387: GO 117504
117389: LD_INT 29
117391: DOUBLE
117392: EQUAL
117393: IFTRUE 117397
117395: GO 117408
117397: POP
// bc_type := b_barracks ; 30 :
117398: LD_ADDR_OWVAR 42
117402: PUSH
117403: LD_INT 5
117405: ST_TO_ADDR
117406: GO 117504
117408: LD_INT 30
117410: DOUBLE
117411: EQUAL
117412: IFTRUE 117416
117414: GO 117427
117416: POP
// bc_type := b_solar_power ; 31 :
117417: LD_ADDR_OWVAR 42
117421: PUSH
117422: LD_INT 27
117424: ST_TO_ADDR
117425: GO 117504
117427: LD_INT 31
117429: DOUBLE
117430: EQUAL
117431: IFTRUE 117435
117433: GO 117446
117435: POP
// bc_type := b_oil_power ; 32 :
117436: LD_ADDR_OWVAR 42
117440: PUSH
117441: LD_INT 26
117443: ST_TO_ADDR
117444: GO 117504
117446: LD_INT 32
117448: DOUBLE
117449: EQUAL
117450: IFTRUE 117454
117452: GO 117465
117454: POP
// bc_type := b_siberite_power ; 33 :
117455: LD_ADDR_OWVAR 42
117459: PUSH
117460: LD_INT 28
117462: ST_TO_ADDR
117463: GO 117504
117465: LD_INT 33
117467: DOUBLE
117468: EQUAL
117469: IFTRUE 117473
117471: GO 117484
117473: POP
// bc_type := b_oil_mine ; 34 :
117474: LD_ADDR_OWVAR 42
117478: PUSH
117479: LD_INT 29
117481: ST_TO_ADDR
117482: GO 117504
117484: LD_INT 34
117486: DOUBLE
117487: EQUAL
117488: IFTRUE 117492
117490: GO 117503
117492: POP
// bc_type := b_siberite_mine ; end ;
117493: LD_ADDR_OWVAR 42
117497: PUSH
117498: LD_INT 30
117500: ST_TO_ADDR
117501: GO 117504
117503: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
117504: LD_ADDR_VAR 0 8
117508: PUSH
117509: LD_VAR 0 5
117513: PPUSH
117514: LD_VAR 0 6
117518: PPUSH
117519: LD_VAR 0 3
117523: PPUSH
117524: CALL_OW 47
117528: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
117529: LD_OWVAR 42
117533: PUSH
117534: LD_INT 32
117536: PUSH
117537: LD_INT 33
117539: PUSH
117540: EMPTY
117541: LIST
117542: LIST
117543: IN
117544: IFFALSE 117560
// PlaceWeaponTurret ( b , weapon ) ;
117546: LD_VAR 0 8
117550: PPUSH
117551: LD_VAR 0 4
117555: PPUSH
117556: CALL_OW 431
// end ;
117560: LD_VAR 0 7
117564: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
117565: LD_INT 0
117567: PPUSH
117568: PPUSH
117569: PPUSH
117570: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117571: LD_ADDR_VAR 0 4
117575: PUSH
117576: LD_INT 22
117578: PUSH
117579: LD_OWVAR 2
117583: PUSH
117584: EMPTY
117585: LIST
117586: LIST
117587: PUSH
117588: LD_INT 2
117590: PUSH
117591: LD_INT 30
117593: PUSH
117594: LD_INT 0
117596: PUSH
117597: EMPTY
117598: LIST
117599: LIST
117600: PUSH
117601: LD_INT 30
117603: PUSH
117604: LD_INT 1
117606: PUSH
117607: EMPTY
117608: LIST
117609: LIST
117610: PUSH
117611: EMPTY
117612: LIST
117613: LIST
117614: LIST
117615: PUSH
117616: EMPTY
117617: LIST
117618: LIST
117619: PPUSH
117620: CALL_OW 69
117624: ST_TO_ADDR
// if not tmp then
117625: LD_VAR 0 4
117629: NOT
117630: IFFALSE 117634
// exit ;
117632: GO 117693
// for i in tmp do
117634: LD_ADDR_VAR 0 2
117638: PUSH
117639: LD_VAR 0 4
117643: PUSH
117644: FOR_IN
117645: IFFALSE 117691
// for j = 1 to 3 do
117647: LD_ADDR_VAR 0 3
117651: PUSH
117652: DOUBLE
117653: LD_INT 1
117655: DEC
117656: ST_TO_ADDR
117657: LD_INT 3
117659: PUSH
117660: FOR_TO
117661: IFFALSE 117687
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
117663: LD_VAR 0 2
117667: PPUSH
117668: CALL_OW 274
117672: PPUSH
117673: LD_VAR 0 3
117677: PPUSH
117678: LD_INT 99999
117680: PPUSH
117681: CALL_OW 277
117685: GO 117660
117687: POP
117688: POP
117689: GO 117644
117691: POP
117692: POP
// end ;
117693: LD_VAR 0 1
117697: RET
// export function hHackSetLevel10 ; var i , j ; begin
117698: LD_INT 0
117700: PPUSH
117701: PPUSH
117702: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
117703: LD_ADDR_VAR 0 2
117707: PUSH
117708: LD_INT 21
117710: PUSH
117711: LD_INT 1
117713: PUSH
117714: EMPTY
117715: LIST
117716: LIST
117717: PPUSH
117718: CALL_OW 69
117722: PUSH
117723: FOR_IN
117724: IFFALSE 117776
// if IsSelected ( i ) then
117726: LD_VAR 0 2
117730: PPUSH
117731: CALL_OW 306
117735: IFFALSE 117774
// begin for j := 1 to 4 do
117737: LD_ADDR_VAR 0 3
117741: PUSH
117742: DOUBLE
117743: LD_INT 1
117745: DEC
117746: ST_TO_ADDR
117747: LD_INT 4
117749: PUSH
117750: FOR_TO
117751: IFFALSE 117772
// SetSkill ( i , j , 10 ) ;
117753: LD_VAR 0 2
117757: PPUSH
117758: LD_VAR 0 3
117762: PPUSH
117763: LD_INT 10
117765: PPUSH
117766: CALL_OW 237
117770: GO 117750
117772: POP
117773: POP
// end ;
117774: GO 117723
117776: POP
117777: POP
// end ;
117778: LD_VAR 0 1
117782: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
117783: LD_INT 0
117785: PPUSH
117786: PPUSH
117787: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
117788: LD_ADDR_VAR 0 2
117792: PUSH
117793: LD_INT 22
117795: PUSH
117796: LD_OWVAR 2
117800: PUSH
117801: EMPTY
117802: LIST
117803: LIST
117804: PUSH
117805: LD_INT 21
117807: PUSH
117808: LD_INT 1
117810: PUSH
117811: EMPTY
117812: LIST
117813: LIST
117814: PUSH
117815: EMPTY
117816: LIST
117817: LIST
117818: PPUSH
117819: CALL_OW 69
117823: PUSH
117824: FOR_IN
117825: IFFALSE 117866
// begin for j := 1 to 4 do
117827: LD_ADDR_VAR 0 3
117831: PUSH
117832: DOUBLE
117833: LD_INT 1
117835: DEC
117836: ST_TO_ADDR
117837: LD_INT 4
117839: PUSH
117840: FOR_TO
117841: IFFALSE 117862
// SetSkill ( i , j , 10 ) ;
117843: LD_VAR 0 2
117847: PPUSH
117848: LD_VAR 0 3
117852: PPUSH
117853: LD_INT 10
117855: PPUSH
117856: CALL_OW 237
117860: GO 117840
117862: POP
117863: POP
// end ;
117864: GO 117824
117866: POP
117867: POP
// end ;
117868: LD_VAR 0 1
117872: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
117873: LD_INT 0
117875: PPUSH
// uc_side := your_side ;
117876: LD_ADDR_OWVAR 20
117880: PUSH
117881: LD_OWVAR 2
117885: ST_TO_ADDR
// uc_nation := nation ;
117886: LD_ADDR_OWVAR 21
117890: PUSH
117891: LD_VAR 0 1
117895: ST_TO_ADDR
// InitHc ;
117896: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
117900: LD_INT 0
117902: PPUSH
117903: LD_VAR 0 2
117907: PPUSH
117908: LD_VAR 0 3
117912: PPUSH
117913: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
117917: LD_VAR 0 4
117921: PPUSH
117922: LD_VAR 0 5
117926: PPUSH
117927: CALL_OW 428
117931: PUSH
117932: LD_INT 0
117934: EQUAL
117935: IFFALSE 117959
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
117937: CALL_OW 44
117941: PPUSH
117942: LD_VAR 0 4
117946: PPUSH
117947: LD_VAR 0 5
117951: PPUSH
117952: LD_INT 1
117954: PPUSH
117955: CALL_OW 48
// end ;
117959: LD_VAR 0 6
117963: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
117964: LD_INT 0
117966: PPUSH
117967: PPUSH
// uc_side := your_side ;
117968: LD_ADDR_OWVAR 20
117972: PUSH
117973: LD_OWVAR 2
117977: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
117978: LD_VAR 0 1
117982: PUSH
117983: LD_INT 1
117985: PUSH
117986: LD_INT 2
117988: PUSH
117989: LD_INT 3
117991: PUSH
117992: LD_INT 4
117994: PUSH
117995: LD_INT 5
117997: PUSH
117998: EMPTY
117999: LIST
118000: LIST
118001: LIST
118002: LIST
118003: LIST
118004: IN
118005: IFFALSE 118017
// uc_nation := nation_american else
118007: LD_ADDR_OWVAR 21
118011: PUSH
118012: LD_INT 1
118014: ST_TO_ADDR
118015: GO 118060
// if chassis in [ 11 , 12 , 13 , 14 ] then
118017: LD_VAR 0 1
118021: PUSH
118022: LD_INT 11
118024: PUSH
118025: LD_INT 12
118027: PUSH
118028: LD_INT 13
118030: PUSH
118031: LD_INT 14
118033: PUSH
118034: EMPTY
118035: LIST
118036: LIST
118037: LIST
118038: LIST
118039: IN
118040: IFFALSE 118052
// uc_nation := nation_arabian else
118042: LD_ADDR_OWVAR 21
118046: PUSH
118047: LD_INT 2
118049: ST_TO_ADDR
118050: GO 118060
// uc_nation := nation_russian ;
118052: LD_ADDR_OWVAR 21
118056: PUSH
118057: LD_INT 3
118059: ST_TO_ADDR
// vc_chassis := chassis ;
118060: LD_ADDR_OWVAR 37
118064: PUSH
118065: LD_VAR 0 1
118069: ST_TO_ADDR
// vc_engine := engine ;
118070: LD_ADDR_OWVAR 39
118074: PUSH
118075: LD_VAR 0 2
118079: ST_TO_ADDR
// vc_control := control ;
118080: LD_ADDR_OWVAR 38
118084: PUSH
118085: LD_VAR 0 3
118089: ST_TO_ADDR
// vc_weapon := weapon ;
118090: LD_ADDR_OWVAR 40
118094: PUSH
118095: LD_VAR 0 4
118099: ST_TO_ADDR
// un := CreateVehicle ;
118100: LD_ADDR_VAR 0 8
118104: PUSH
118105: CALL_OW 45
118109: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
118110: LD_VAR 0 8
118114: PPUSH
118115: LD_INT 0
118117: PPUSH
118118: LD_INT 5
118120: PPUSH
118121: CALL_OW 12
118125: PPUSH
118126: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
118130: LD_VAR 0 8
118134: PPUSH
118135: LD_VAR 0 5
118139: PPUSH
118140: LD_VAR 0 6
118144: PPUSH
118145: LD_INT 1
118147: PPUSH
118148: CALL_OW 48
// end ;
118152: LD_VAR 0 7
118156: RET
// export hInvincible ; every 1 do
118157: GO 118159
118159: DISABLE
// hInvincible := [ ] ;
118160: LD_ADDR_EXP 214
118164: PUSH
118165: EMPTY
118166: ST_TO_ADDR
118167: END
// every 10 do var i ;
118168: GO 118170
118170: DISABLE
118171: LD_INT 0
118173: PPUSH
// begin enable ;
118174: ENABLE
// if not hInvincible then
118175: LD_EXP 214
118179: NOT
118180: IFFALSE 118184
// exit ;
118182: GO 118228
// for i in hInvincible do
118184: LD_ADDR_VAR 0 1
118188: PUSH
118189: LD_EXP 214
118193: PUSH
118194: FOR_IN
118195: IFFALSE 118226
// if GetLives ( i ) < 1000 then
118197: LD_VAR 0 1
118201: PPUSH
118202: CALL_OW 256
118206: PUSH
118207: LD_INT 1000
118209: LESS
118210: IFFALSE 118224
// SetLives ( i , 1000 ) ;
118212: LD_VAR 0 1
118216: PPUSH
118217: LD_INT 1000
118219: PPUSH
118220: CALL_OW 234
118224: GO 118194
118226: POP
118227: POP
// end ;
118228: PPOPN 1
118230: END
// export function hHackInvincible ; var i ; begin
118231: LD_INT 0
118233: PPUSH
118234: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
118235: LD_ADDR_VAR 0 2
118239: PUSH
118240: LD_INT 2
118242: PUSH
118243: LD_INT 21
118245: PUSH
118246: LD_INT 1
118248: PUSH
118249: EMPTY
118250: LIST
118251: LIST
118252: PUSH
118253: LD_INT 21
118255: PUSH
118256: LD_INT 2
118258: PUSH
118259: EMPTY
118260: LIST
118261: LIST
118262: PUSH
118263: EMPTY
118264: LIST
118265: LIST
118266: LIST
118267: PPUSH
118268: CALL_OW 69
118272: PUSH
118273: FOR_IN
118274: IFFALSE 118335
// if IsSelected ( i ) then
118276: LD_VAR 0 2
118280: PPUSH
118281: CALL_OW 306
118285: IFFALSE 118333
// begin if i in hInvincible then
118287: LD_VAR 0 2
118291: PUSH
118292: LD_EXP 214
118296: IN
118297: IFFALSE 118317
// hInvincible := hInvincible diff i else
118299: LD_ADDR_EXP 214
118303: PUSH
118304: LD_EXP 214
118308: PUSH
118309: LD_VAR 0 2
118313: DIFF
118314: ST_TO_ADDR
118315: GO 118333
// hInvincible := hInvincible union i ;
118317: LD_ADDR_EXP 214
118321: PUSH
118322: LD_EXP 214
118326: PUSH
118327: LD_VAR 0 2
118331: UNION
118332: ST_TO_ADDR
// end ;
118333: GO 118273
118335: POP
118336: POP
// end ;
118337: LD_VAR 0 1
118341: RET
// export function hHackInvisible ; var i , j ; begin
118342: LD_INT 0
118344: PPUSH
118345: PPUSH
118346: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
118347: LD_ADDR_VAR 0 2
118351: PUSH
118352: LD_INT 21
118354: PUSH
118355: LD_INT 1
118357: PUSH
118358: EMPTY
118359: LIST
118360: LIST
118361: PPUSH
118362: CALL_OW 69
118366: PUSH
118367: FOR_IN
118368: IFFALSE 118392
// if IsSelected ( i ) then
118370: LD_VAR 0 2
118374: PPUSH
118375: CALL_OW 306
118379: IFFALSE 118390
// ComForceInvisible ( i ) ;
118381: LD_VAR 0 2
118385: PPUSH
118386: CALL_OW 496
118390: GO 118367
118392: POP
118393: POP
// end ;
118394: LD_VAR 0 1
118398: RET
// export function hHackChangeYourSide ; begin
118399: LD_INT 0
118401: PPUSH
// if your_side = 8 then
118402: LD_OWVAR 2
118406: PUSH
118407: LD_INT 8
118409: EQUAL
118410: IFFALSE 118422
// your_side := 0 else
118412: LD_ADDR_OWVAR 2
118416: PUSH
118417: LD_INT 0
118419: ST_TO_ADDR
118420: GO 118436
// your_side := your_side + 1 ;
118422: LD_ADDR_OWVAR 2
118426: PUSH
118427: LD_OWVAR 2
118431: PUSH
118432: LD_INT 1
118434: PLUS
118435: ST_TO_ADDR
// end ;
118436: LD_VAR 0 1
118440: RET
// export function hHackChangeUnitSide ; var i , j ; begin
118441: LD_INT 0
118443: PPUSH
118444: PPUSH
118445: PPUSH
// for i in all_units do
118446: LD_ADDR_VAR 0 2
118450: PUSH
118451: LD_OWVAR 3
118455: PUSH
118456: FOR_IN
118457: IFFALSE 118535
// if IsSelected ( i ) then
118459: LD_VAR 0 2
118463: PPUSH
118464: CALL_OW 306
118468: IFFALSE 118533
// begin j := GetSide ( i ) ;
118470: LD_ADDR_VAR 0 3
118474: PUSH
118475: LD_VAR 0 2
118479: PPUSH
118480: CALL_OW 255
118484: ST_TO_ADDR
// if j = 8 then
118485: LD_VAR 0 3
118489: PUSH
118490: LD_INT 8
118492: EQUAL
118493: IFFALSE 118505
// j := 0 else
118495: LD_ADDR_VAR 0 3
118499: PUSH
118500: LD_INT 0
118502: ST_TO_ADDR
118503: GO 118519
// j := j + 1 ;
118505: LD_ADDR_VAR 0 3
118509: PUSH
118510: LD_VAR 0 3
118514: PUSH
118515: LD_INT 1
118517: PLUS
118518: ST_TO_ADDR
// SetSide ( i , j ) ;
118519: LD_VAR 0 2
118523: PPUSH
118524: LD_VAR 0 3
118528: PPUSH
118529: CALL_OW 235
// end ;
118533: GO 118456
118535: POP
118536: POP
// end ;
118537: LD_VAR 0 1
118541: RET
// export function hHackFog ; begin
118542: LD_INT 0
118544: PPUSH
// FogOff ( true ) ;
118545: LD_INT 1
118547: PPUSH
118548: CALL_OW 344
// end ;
118552: LD_VAR 0 1
118556: RET
// export function hHackTeleport ( unit , x , y ) ; begin
118557: LD_INT 0
118559: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
118560: LD_VAR 0 1
118564: PPUSH
118565: LD_VAR 0 2
118569: PPUSH
118570: LD_VAR 0 3
118574: PPUSH
118575: LD_INT 1
118577: PPUSH
118578: LD_INT 1
118580: PPUSH
118581: CALL_OW 483
// CenterOnXY ( x , y ) ;
118585: LD_VAR 0 2
118589: PPUSH
118590: LD_VAR 0 3
118594: PPUSH
118595: CALL_OW 84
// end ; end_of_file
118599: LD_VAR 0 4
118603: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
118604: LD_INT 0
118606: PPUSH
118607: PPUSH
118608: PPUSH
118609: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
118610: LD_VAR 0 1
118614: PPUSH
118615: CALL_OW 264
118619: PUSH
118620: LD_EXP 99
118624: EQUAL
118625: IFFALSE 118697
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
118627: LD_INT 68
118629: PPUSH
118630: LD_VAR 0 1
118634: PPUSH
118635: CALL_OW 255
118639: PPUSH
118640: CALL_OW 321
118644: PUSH
118645: LD_INT 2
118647: EQUAL
118648: IFFALSE 118660
// eff := 70 else
118650: LD_ADDR_VAR 0 4
118654: PUSH
118655: LD_INT 70
118657: ST_TO_ADDR
118658: GO 118668
// eff := 30 ;
118660: LD_ADDR_VAR 0 4
118664: PUSH
118665: LD_INT 30
118667: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
118668: LD_VAR 0 1
118672: PPUSH
118673: CALL_OW 250
118677: PPUSH
118678: LD_VAR 0 1
118682: PPUSH
118683: CALL_OW 251
118687: PPUSH
118688: LD_VAR 0 4
118692: PPUSH
118693: CALL_OW 495
// end ; end ;
118697: LD_VAR 0 2
118701: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
118702: LD_INT 0
118704: PPUSH
// end ;
118705: LD_VAR 0 4
118709: RET
// export function SOS_Command ( cmd ) ; begin
118710: LD_INT 0
118712: PPUSH
// end ;
118713: LD_VAR 0 2
118717: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
118718: LD_INT 0
118720: PPUSH
// if cmd = 121 then
118721: LD_VAR 0 1
118725: PUSH
118726: LD_INT 121
118728: EQUAL
118729: IFFALSE 118731
// end ;
118731: LD_VAR 0 6
118735: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
118736: LD_INT 0
118738: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
118739: LD_VAR 0 1
118743: PUSH
118744: LD_INT 250
118746: EQUAL
118747: PUSH
118748: LD_VAR 0 2
118752: PPUSH
118753: CALL_OW 264
118757: PUSH
118758: LD_EXP 102
118762: EQUAL
118763: AND
118764: IFFALSE 118785
// MinerPlaceMine ( unit , x , y ) ;
118766: LD_VAR 0 2
118770: PPUSH
118771: LD_VAR 0 4
118775: PPUSH
118776: LD_VAR 0 5
118780: PPUSH
118781: CALL 121134 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
118785: LD_VAR 0 1
118789: PUSH
118790: LD_INT 251
118792: EQUAL
118793: PUSH
118794: LD_VAR 0 2
118798: PPUSH
118799: CALL_OW 264
118803: PUSH
118804: LD_EXP 102
118808: EQUAL
118809: AND
118810: IFFALSE 118831
// MinerDetonateMine ( unit , x , y ) ;
118812: LD_VAR 0 2
118816: PPUSH
118817: LD_VAR 0 4
118821: PPUSH
118822: LD_VAR 0 5
118826: PPUSH
118827: CALL 121411 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
118831: LD_VAR 0 1
118835: PUSH
118836: LD_INT 252
118838: EQUAL
118839: PUSH
118840: LD_VAR 0 2
118844: PPUSH
118845: CALL_OW 264
118849: PUSH
118850: LD_EXP 102
118854: EQUAL
118855: AND
118856: IFFALSE 118877
// MinerCreateMinefield ( unit , x , y ) ;
118858: LD_VAR 0 2
118862: PPUSH
118863: LD_VAR 0 4
118867: PPUSH
118868: LD_VAR 0 5
118872: PPUSH
118873: CALL 121828 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
118877: LD_VAR 0 1
118881: PUSH
118882: LD_INT 253
118884: EQUAL
118885: PUSH
118886: LD_VAR 0 2
118890: PPUSH
118891: CALL_OW 257
118895: PUSH
118896: LD_INT 5
118898: EQUAL
118899: AND
118900: IFFALSE 118921
// ComBinocular ( unit , x , y ) ;
118902: LD_VAR 0 2
118906: PPUSH
118907: LD_VAR 0 4
118911: PPUSH
118912: LD_VAR 0 5
118916: PPUSH
118917: CALL 122199 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
118921: LD_VAR 0 1
118925: PUSH
118926: LD_INT 254
118928: EQUAL
118929: PUSH
118930: LD_VAR 0 2
118934: PPUSH
118935: CALL_OW 264
118939: PUSH
118940: LD_EXP 97
118944: EQUAL
118945: AND
118946: PUSH
118947: LD_VAR 0 3
118951: PPUSH
118952: CALL_OW 263
118956: PUSH
118957: LD_INT 3
118959: EQUAL
118960: AND
118961: IFFALSE 118977
// HackDestroyVehicle ( unit , selectedUnit ) ;
118963: LD_VAR 0 2
118967: PPUSH
118968: LD_VAR 0 3
118972: PPUSH
118973: CALL 120494 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
118977: LD_VAR 0 1
118981: PUSH
118982: LD_INT 255
118984: EQUAL
118985: PUSH
118986: LD_VAR 0 2
118990: PPUSH
118991: CALL_OW 264
118995: PUSH
118996: LD_INT 14
118998: PUSH
118999: LD_INT 53
119001: PUSH
119002: EMPTY
119003: LIST
119004: LIST
119005: IN
119006: AND
119007: PUSH
119008: LD_VAR 0 4
119012: PPUSH
119013: LD_VAR 0 5
119017: PPUSH
119018: CALL_OW 488
119022: AND
119023: IFFALSE 119047
// CutTreeXYR ( unit , x , y , 12 ) ;
119025: LD_VAR 0 2
119029: PPUSH
119030: LD_VAR 0 4
119034: PPUSH
119035: LD_VAR 0 5
119039: PPUSH
119040: LD_INT 12
119042: PPUSH
119043: CALL 119060 0 4
// end ;
119047: LD_VAR 0 6
119051: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
119052: LD_INT 0
119054: PPUSH
// end ;
119055: LD_VAR 0 4
119059: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
119060: LD_INT 0
119062: PPUSH
119063: PPUSH
119064: PPUSH
119065: PPUSH
119066: PPUSH
119067: PPUSH
119068: PPUSH
119069: PPUSH
119070: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
119071: LD_VAR 0 1
119075: NOT
119076: PUSH
119077: LD_VAR 0 2
119081: PPUSH
119082: LD_VAR 0 3
119086: PPUSH
119087: CALL_OW 488
119091: NOT
119092: OR
119093: PUSH
119094: LD_VAR 0 4
119098: NOT
119099: OR
119100: IFFALSE 119104
// exit ;
119102: GO 119444
// list := [ ] ;
119104: LD_ADDR_VAR 0 13
119108: PUSH
119109: EMPTY
119110: ST_TO_ADDR
// if x - r < 0 then
119111: LD_VAR 0 2
119115: PUSH
119116: LD_VAR 0 4
119120: MINUS
119121: PUSH
119122: LD_INT 0
119124: LESS
119125: IFFALSE 119137
// min_x := 0 else
119127: LD_ADDR_VAR 0 7
119131: PUSH
119132: LD_INT 0
119134: ST_TO_ADDR
119135: GO 119153
// min_x := x - r ;
119137: LD_ADDR_VAR 0 7
119141: PUSH
119142: LD_VAR 0 2
119146: PUSH
119147: LD_VAR 0 4
119151: MINUS
119152: ST_TO_ADDR
// if y - r < 0 then
119153: LD_VAR 0 3
119157: PUSH
119158: LD_VAR 0 4
119162: MINUS
119163: PUSH
119164: LD_INT 0
119166: LESS
119167: IFFALSE 119179
// min_y := 0 else
119169: LD_ADDR_VAR 0 8
119173: PUSH
119174: LD_INT 0
119176: ST_TO_ADDR
119177: GO 119195
// min_y := y - r ;
119179: LD_ADDR_VAR 0 8
119183: PUSH
119184: LD_VAR 0 3
119188: PUSH
119189: LD_VAR 0 4
119193: MINUS
119194: ST_TO_ADDR
// max_x := x + r ;
119195: LD_ADDR_VAR 0 9
119199: PUSH
119200: LD_VAR 0 2
119204: PUSH
119205: LD_VAR 0 4
119209: PLUS
119210: ST_TO_ADDR
// max_y := y + r ;
119211: LD_ADDR_VAR 0 10
119215: PUSH
119216: LD_VAR 0 3
119220: PUSH
119221: LD_VAR 0 4
119225: PLUS
119226: ST_TO_ADDR
// for _x = min_x to max_x do
119227: LD_ADDR_VAR 0 11
119231: PUSH
119232: DOUBLE
119233: LD_VAR 0 7
119237: DEC
119238: ST_TO_ADDR
119239: LD_VAR 0 9
119243: PUSH
119244: FOR_TO
119245: IFFALSE 119362
// for _y = min_y to max_y do
119247: LD_ADDR_VAR 0 12
119251: PUSH
119252: DOUBLE
119253: LD_VAR 0 8
119257: DEC
119258: ST_TO_ADDR
119259: LD_VAR 0 10
119263: PUSH
119264: FOR_TO
119265: IFFALSE 119358
// begin if not ValidHex ( _x , _y ) then
119267: LD_VAR 0 11
119271: PPUSH
119272: LD_VAR 0 12
119276: PPUSH
119277: CALL_OW 488
119281: NOT
119282: IFFALSE 119286
// continue ;
119284: GO 119264
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
119286: LD_VAR 0 11
119290: PPUSH
119291: LD_VAR 0 12
119295: PPUSH
119296: CALL_OW 351
119300: PUSH
119301: LD_VAR 0 11
119305: PPUSH
119306: LD_VAR 0 12
119310: PPUSH
119311: CALL_OW 554
119315: AND
119316: IFFALSE 119356
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
119318: LD_ADDR_VAR 0 13
119322: PUSH
119323: LD_VAR 0 13
119327: PPUSH
119328: LD_VAR 0 13
119332: PUSH
119333: LD_INT 1
119335: PLUS
119336: PPUSH
119337: LD_VAR 0 11
119341: PUSH
119342: LD_VAR 0 12
119346: PUSH
119347: EMPTY
119348: LIST
119349: LIST
119350: PPUSH
119351: CALL_OW 2
119355: ST_TO_ADDR
// end ;
119356: GO 119264
119358: POP
119359: POP
119360: GO 119244
119362: POP
119363: POP
// if not list then
119364: LD_VAR 0 13
119368: NOT
119369: IFFALSE 119373
// exit ;
119371: GO 119444
// for i in list do
119373: LD_ADDR_VAR 0 6
119377: PUSH
119378: LD_VAR 0 13
119382: PUSH
119383: FOR_IN
119384: IFFALSE 119442
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
119386: LD_VAR 0 1
119390: PPUSH
119391: LD_STRING M
119393: PUSH
119394: LD_VAR 0 6
119398: PUSH
119399: LD_INT 1
119401: ARRAY
119402: PUSH
119403: LD_VAR 0 6
119407: PUSH
119408: LD_INT 2
119410: ARRAY
119411: PUSH
119412: LD_INT 0
119414: PUSH
119415: LD_INT 0
119417: PUSH
119418: LD_INT 0
119420: PUSH
119421: LD_INT 0
119423: PUSH
119424: EMPTY
119425: LIST
119426: LIST
119427: LIST
119428: LIST
119429: LIST
119430: LIST
119431: LIST
119432: PUSH
119433: EMPTY
119434: LIST
119435: PPUSH
119436: CALL_OW 447
119440: GO 119383
119442: POP
119443: POP
// end ;
119444: LD_VAR 0 5
119448: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
119449: LD_EXP 217
119453: NOT
119454: IFFALSE 119504
119456: GO 119458
119458: DISABLE
// begin initHack := true ;
119459: LD_ADDR_EXP 217
119463: PUSH
119464: LD_INT 1
119466: ST_TO_ADDR
// hackTanks := [ ] ;
119467: LD_ADDR_EXP 218
119471: PUSH
119472: EMPTY
119473: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
119474: LD_ADDR_EXP 219
119478: PUSH
119479: EMPTY
119480: ST_TO_ADDR
// hackLimit := 3 ;
119481: LD_ADDR_EXP 220
119485: PUSH
119486: LD_INT 3
119488: ST_TO_ADDR
// hackDist := 12 ;
119489: LD_ADDR_EXP 221
119493: PUSH
119494: LD_INT 12
119496: ST_TO_ADDR
// hackCounter := [ ] ;
119497: LD_ADDR_EXP 222
119501: PUSH
119502: EMPTY
119503: ST_TO_ADDR
// end ;
119504: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
119505: LD_EXP 217
119509: PUSH
119510: LD_INT 34
119512: PUSH
119513: LD_EXP 97
119517: PUSH
119518: EMPTY
119519: LIST
119520: LIST
119521: PPUSH
119522: CALL_OW 69
119526: AND
119527: IFFALSE 119782
119529: GO 119531
119531: DISABLE
119532: LD_INT 0
119534: PPUSH
119535: PPUSH
// begin enable ;
119536: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
119537: LD_ADDR_VAR 0 1
119541: PUSH
119542: LD_INT 34
119544: PUSH
119545: LD_EXP 97
119549: PUSH
119550: EMPTY
119551: LIST
119552: LIST
119553: PPUSH
119554: CALL_OW 69
119558: PUSH
119559: FOR_IN
119560: IFFALSE 119780
// begin if not i in hackTanks then
119562: LD_VAR 0 1
119566: PUSH
119567: LD_EXP 218
119571: IN
119572: NOT
119573: IFFALSE 119656
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
119575: LD_ADDR_EXP 218
119579: PUSH
119580: LD_EXP 218
119584: PPUSH
119585: LD_EXP 218
119589: PUSH
119590: LD_INT 1
119592: PLUS
119593: PPUSH
119594: LD_VAR 0 1
119598: PPUSH
119599: CALL_OW 1
119603: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
119604: LD_ADDR_EXP 219
119608: PUSH
119609: LD_EXP 219
119613: PPUSH
119614: LD_EXP 219
119618: PUSH
119619: LD_INT 1
119621: PLUS
119622: PPUSH
119623: EMPTY
119624: PPUSH
119625: CALL_OW 1
119629: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
119630: LD_ADDR_EXP 222
119634: PUSH
119635: LD_EXP 222
119639: PPUSH
119640: LD_EXP 222
119644: PUSH
119645: LD_INT 1
119647: PLUS
119648: PPUSH
119649: EMPTY
119650: PPUSH
119651: CALL_OW 1
119655: ST_TO_ADDR
// end ; if not IsOk ( i ) then
119656: LD_VAR 0 1
119660: PPUSH
119661: CALL_OW 302
119665: NOT
119666: IFFALSE 119679
// begin HackUnlinkAll ( i ) ;
119668: LD_VAR 0 1
119672: PPUSH
119673: CALL 119785 0 1
// continue ;
119677: GO 119559
// end ; HackCheckCapturedStatus ( i ) ;
119679: LD_VAR 0 1
119683: PPUSH
119684: CALL 120228 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
119688: LD_ADDR_VAR 0 2
119692: PUSH
119693: LD_INT 81
119695: PUSH
119696: LD_VAR 0 1
119700: PPUSH
119701: CALL_OW 255
119705: PUSH
119706: EMPTY
119707: LIST
119708: LIST
119709: PUSH
119710: LD_INT 33
119712: PUSH
119713: LD_INT 3
119715: PUSH
119716: EMPTY
119717: LIST
119718: LIST
119719: PUSH
119720: LD_INT 91
119722: PUSH
119723: LD_VAR 0 1
119727: PUSH
119728: LD_EXP 221
119732: PUSH
119733: EMPTY
119734: LIST
119735: LIST
119736: LIST
119737: PUSH
119738: LD_INT 50
119740: PUSH
119741: EMPTY
119742: LIST
119743: PUSH
119744: EMPTY
119745: LIST
119746: LIST
119747: LIST
119748: LIST
119749: PPUSH
119750: CALL_OW 69
119754: ST_TO_ADDR
// if not tmp then
119755: LD_VAR 0 2
119759: NOT
119760: IFFALSE 119764
// continue ;
119762: GO 119559
// HackLink ( i , tmp ) ;
119764: LD_VAR 0 1
119768: PPUSH
119769: LD_VAR 0 2
119773: PPUSH
119774: CALL 119921 0 2
// end ;
119778: GO 119559
119780: POP
119781: POP
// end ;
119782: PPOPN 2
119784: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
119785: LD_INT 0
119787: PPUSH
119788: PPUSH
119789: PPUSH
// if not hack in hackTanks then
119790: LD_VAR 0 1
119794: PUSH
119795: LD_EXP 218
119799: IN
119800: NOT
119801: IFFALSE 119805
// exit ;
119803: GO 119916
// index := GetElementIndex ( hackTanks , hack ) ;
119805: LD_ADDR_VAR 0 4
119809: PUSH
119810: LD_EXP 218
119814: PPUSH
119815: LD_VAR 0 1
119819: PPUSH
119820: CALL 70648 0 2
119824: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
119825: LD_EXP 219
119829: PUSH
119830: LD_VAR 0 4
119834: ARRAY
119835: IFFALSE 119916
// begin for i in hackTanksCaptured [ index ] do
119837: LD_ADDR_VAR 0 3
119841: PUSH
119842: LD_EXP 219
119846: PUSH
119847: LD_VAR 0 4
119851: ARRAY
119852: PUSH
119853: FOR_IN
119854: IFFALSE 119880
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
119856: LD_VAR 0 3
119860: PUSH
119861: LD_INT 1
119863: ARRAY
119864: PPUSH
119865: LD_VAR 0 3
119869: PUSH
119870: LD_INT 2
119872: ARRAY
119873: PPUSH
119874: CALL_OW 235
119878: GO 119853
119880: POP
119881: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
119882: LD_ADDR_EXP 219
119886: PUSH
119887: LD_EXP 219
119891: PPUSH
119892: LD_VAR 0 4
119896: PPUSH
119897: EMPTY
119898: PPUSH
119899: CALL_OW 1
119903: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
119904: LD_VAR 0 1
119908: PPUSH
119909: LD_INT 0
119911: PPUSH
119912: CALL_OW 505
// end ; end ;
119916: LD_VAR 0 2
119920: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
119921: LD_INT 0
119923: PPUSH
119924: PPUSH
119925: PPUSH
// if not hack in hackTanks or not vehicles then
119926: LD_VAR 0 1
119930: PUSH
119931: LD_EXP 218
119935: IN
119936: NOT
119937: PUSH
119938: LD_VAR 0 2
119942: NOT
119943: OR
119944: IFFALSE 119948
// exit ;
119946: GO 120223
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
119948: LD_ADDR_VAR 0 2
119952: PUSH
119953: LD_VAR 0 1
119957: PPUSH
119958: LD_VAR 0 2
119962: PPUSH
119963: LD_INT 1
119965: PPUSH
119966: LD_INT 1
119968: PPUSH
119969: CALL 71298 0 4
119973: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
119974: LD_ADDR_VAR 0 5
119978: PUSH
119979: LD_EXP 218
119983: PPUSH
119984: LD_VAR 0 1
119988: PPUSH
119989: CALL 70648 0 2
119993: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
119994: LD_EXP 219
119998: PUSH
119999: LD_VAR 0 5
120003: ARRAY
120004: PUSH
120005: LD_EXP 220
120009: LESS
120010: IFFALSE 120199
// begin for i := 1 to vehicles do
120012: LD_ADDR_VAR 0 4
120016: PUSH
120017: DOUBLE
120018: LD_INT 1
120020: DEC
120021: ST_TO_ADDR
120022: LD_VAR 0 2
120026: PUSH
120027: FOR_TO
120028: IFFALSE 120197
// begin if hackTanksCaptured [ index ] = hackLimit then
120030: LD_EXP 219
120034: PUSH
120035: LD_VAR 0 5
120039: ARRAY
120040: PUSH
120041: LD_EXP 220
120045: EQUAL
120046: IFFALSE 120050
// break ;
120048: GO 120197
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
120050: LD_ADDR_EXP 222
120054: PUSH
120055: LD_EXP 222
120059: PPUSH
120060: LD_VAR 0 5
120064: PPUSH
120065: LD_EXP 222
120069: PUSH
120070: LD_VAR 0 5
120074: ARRAY
120075: PUSH
120076: LD_INT 1
120078: PLUS
120079: PPUSH
120080: CALL_OW 1
120084: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
120085: LD_ADDR_EXP 219
120089: PUSH
120090: LD_EXP 219
120094: PPUSH
120095: LD_VAR 0 5
120099: PUSH
120100: LD_EXP 219
120104: PUSH
120105: LD_VAR 0 5
120109: ARRAY
120110: PUSH
120111: LD_INT 1
120113: PLUS
120114: PUSH
120115: EMPTY
120116: LIST
120117: LIST
120118: PPUSH
120119: LD_VAR 0 2
120123: PUSH
120124: LD_VAR 0 4
120128: ARRAY
120129: PUSH
120130: LD_VAR 0 2
120134: PUSH
120135: LD_VAR 0 4
120139: ARRAY
120140: PPUSH
120141: CALL_OW 255
120145: PUSH
120146: EMPTY
120147: LIST
120148: LIST
120149: PPUSH
120150: CALL 70863 0 3
120154: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
120155: LD_VAR 0 2
120159: PUSH
120160: LD_VAR 0 4
120164: ARRAY
120165: PPUSH
120166: LD_VAR 0 1
120170: PPUSH
120171: CALL_OW 255
120175: PPUSH
120176: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
120180: LD_VAR 0 2
120184: PUSH
120185: LD_VAR 0 4
120189: ARRAY
120190: PPUSH
120191: CALL_OW 141
// end ;
120195: GO 120027
120197: POP
120198: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
120199: LD_VAR 0 1
120203: PPUSH
120204: LD_EXP 219
120208: PUSH
120209: LD_VAR 0 5
120213: ARRAY
120214: PUSH
120215: LD_INT 0
120217: PLUS
120218: PPUSH
120219: CALL_OW 505
// end ;
120223: LD_VAR 0 3
120227: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
120228: LD_INT 0
120230: PPUSH
120231: PPUSH
120232: PPUSH
120233: PPUSH
// if not hack in hackTanks then
120234: LD_VAR 0 1
120238: PUSH
120239: LD_EXP 218
120243: IN
120244: NOT
120245: IFFALSE 120249
// exit ;
120247: GO 120489
// index := GetElementIndex ( hackTanks , hack ) ;
120249: LD_ADDR_VAR 0 4
120253: PUSH
120254: LD_EXP 218
120258: PPUSH
120259: LD_VAR 0 1
120263: PPUSH
120264: CALL 70648 0 2
120268: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
120269: LD_ADDR_VAR 0 3
120273: PUSH
120274: DOUBLE
120275: LD_EXP 219
120279: PUSH
120280: LD_VAR 0 4
120284: ARRAY
120285: INC
120286: ST_TO_ADDR
120287: LD_INT 1
120289: PUSH
120290: FOR_DOWNTO
120291: IFFALSE 120463
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
120293: LD_ADDR_VAR 0 5
120297: PUSH
120298: LD_EXP 219
120302: PUSH
120303: LD_VAR 0 4
120307: ARRAY
120308: PUSH
120309: LD_VAR 0 3
120313: ARRAY
120314: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
120315: LD_VAR 0 5
120319: PUSH
120320: LD_INT 1
120322: ARRAY
120323: PPUSH
120324: CALL_OW 302
120328: NOT
120329: PUSH
120330: LD_VAR 0 5
120334: PUSH
120335: LD_INT 1
120337: ARRAY
120338: PPUSH
120339: CALL_OW 255
120343: PUSH
120344: LD_VAR 0 1
120348: PPUSH
120349: CALL_OW 255
120353: NONEQUAL
120354: OR
120355: IFFALSE 120461
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
120357: LD_VAR 0 5
120361: PUSH
120362: LD_INT 1
120364: ARRAY
120365: PPUSH
120366: CALL_OW 305
120370: PUSH
120371: LD_VAR 0 5
120375: PUSH
120376: LD_INT 1
120378: ARRAY
120379: PPUSH
120380: CALL_OW 255
120384: PUSH
120385: LD_VAR 0 1
120389: PPUSH
120390: CALL_OW 255
120394: EQUAL
120395: AND
120396: IFFALSE 120420
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
120398: LD_VAR 0 5
120402: PUSH
120403: LD_INT 1
120405: ARRAY
120406: PPUSH
120407: LD_VAR 0 5
120411: PUSH
120412: LD_INT 2
120414: ARRAY
120415: PPUSH
120416: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
120420: LD_ADDR_EXP 219
120424: PUSH
120425: LD_EXP 219
120429: PPUSH
120430: LD_VAR 0 4
120434: PPUSH
120435: LD_EXP 219
120439: PUSH
120440: LD_VAR 0 4
120444: ARRAY
120445: PPUSH
120446: LD_VAR 0 3
120450: PPUSH
120451: CALL_OW 3
120455: PPUSH
120456: CALL_OW 1
120460: ST_TO_ADDR
// end ; end ;
120461: GO 120290
120463: POP
120464: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
120465: LD_VAR 0 1
120469: PPUSH
120470: LD_EXP 219
120474: PUSH
120475: LD_VAR 0 4
120479: ARRAY
120480: PUSH
120481: LD_INT 0
120483: PLUS
120484: PPUSH
120485: CALL_OW 505
// end ;
120489: LD_VAR 0 2
120493: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
120494: LD_INT 0
120496: PPUSH
120497: PPUSH
120498: PPUSH
120499: PPUSH
// if not hack in hackTanks then
120500: LD_VAR 0 1
120504: PUSH
120505: LD_EXP 218
120509: IN
120510: NOT
120511: IFFALSE 120515
// exit ;
120513: GO 120600
// index := GetElementIndex ( hackTanks , hack ) ;
120515: LD_ADDR_VAR 0 5
120519: PUSH
120520: LD_EXP 218
120524: PPUSH
120525: LD_VAR 0 1
120529: PPUSH
120530: CALL 70648 0 2
120534: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
120535: LD_ADDR_VAR 0 4
120539: PUSH
120540: DOUBLE
120541: LD_INT 1
120543: DEC
120544: ST_TO_ADDR
120545: LD_EXP 219
120549: PUSH
120550: LD_VAR 0 5
120554: ARRAY
120555: PUSH
120556: FOR_TO
120557: IFFALSE 120598
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
120559: LD_EXP 219
120563: PUSH
120564: LD_VAR 0 5
120568: ARRAY
120569: PUSH
120570: LD_VAR 0 4
120574: ARRAY
120575: PUSH
120576: LD_INT 1
120578: ARRAY
120579: PUSH
120580: LD_VAR 0 2
120584: EQUAL
120585: IFFALSE 120596
// KillUnit ( vehicle ) ;
120587: LD_VAR 0 2
120591: PPUSH
120592: CALL_OW 66
120596: GO 120556
120598: POP
120599: POP
// end ;
120600: LD_VAR 0 3
120604: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
120605: LD_EXP 223
120609: NOT
120610: IFFALSE 120645
120612: GO 120614
120614: DISABLE
// begin initMiner := true ;
120615: LD_ADDR_EXP 223
120619: PUSH
120620: LD_INT 1
120622: ST_TO_ADDR
// minersList := [ ] ;
120623: LD_ADDR_EXP 224
120627: PUSH
120628: EMPTY
120629: ST_TO_ADDR
// minerMinesList := [ ] ;
120630: LD_ADDR_EXP 225
120634: PUSH
120635: EMPTY
120636: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
120637: LD_ADDR_EXP 226
120641: PUSH
120642: LD_INT 5
120644: ST_TO_ADDR
// end ;
120645: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
120646: LD_EXP 223
120650: PUSH
120651: LD_INT 34
120653: PUSH
120654: LD_EXP 102
120658: PUSH
120659: EMPTY
120660: LIST
120661: LIST
120662: PPUSH
120663: CALL_OW 69
120667: AND
120668: IFFALSE 121131
120670: GO 120672
120672: DISABLE
120673: LD_INT 0
120675: PPUSH
120676: PPUSH
120677: PPUSH
120678: PPUSH
// begin enable ;
120679: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
120680: LD_ADDR_VAR 0 1
120684: PUSH
120685: LD_INT 34
120687: PUSH
120688: LD_EXP 102
120692: PUSH
120693: EMPTY
120694: LIST
120695: LIST
120696: PPUSH
120697: CALL_OW 69
120701: PUSH
120702: FOR_IN
120703: IFFALSE 120775
// begin if not i in minersList then
120705: LD_VAR 0 1
120709: PUSH
120710: LD_EXP 224
120714: IN
120715: NOT
120716: IFFALSE 120773
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
120718: LD_ADDR_EXP 224
120722: PUSH
120723: LD_EXP 224
120727: PPUSH
120728: LD_EXP 224
120732: PUSH
120733: LD_INT 1
120735: PLUS
120736: PPUSH
120737: LD_VAR 0 1
120741: PPUSH
120742: CALL_OW 1
120746: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
120747: LD_ADDR_EXP 225
120751: PUSH
120752: LD_EXP 225
120756: PPUSH
120757: LD_EXP 225
120761: PUSH
120762: LD_INT 1
120764: PLUS
120765: PPUSH
120766: EMPTY
120767: PPUSH
120768: CALL_OW 1
120772: ST_TO_ADDR
// end end ;
120773: GO 120702
120775: POP
120776: POP
// for i := minerMinesList downto 1 do
120777: LD_ADDR_VAR 0 1
120781: PUSH
120782: DOUBLE
120783: LD_EXP 225
120787: INC
120788: ST_TO_ADDR
120789: LD_INT 1
120791: PUSH
120792: FOR_DOWNTO
120793: IFFALSE 121129
// begin if IsLive ( minersList [ i ] ) then
120795: LD_EXP 224
120799: PUSH
120800: LD_VAR 0 1
120804: ARRAY
120805: PPUSH
120806: CALL_OW 300
120810: IFFALSE 120838
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
120812: LD_EXP 224
120816: PUSH
120817: LD_VAR 0 1
120821: ARRAY
120822: PPUSH
120823: LD_EXP 225
120827: PUSH
120828: LD_VAR 0 1
120832: ARRAY
120833: PPUSH
120834: CALL_OW 505
// if not minerMinesList [ i ] then
120838: LD_EXP 225
120842: PUSH
120843: LD_VAR 0 1
120847: ARRAY
120848: NOT
120849: IFFALSE 120853
// continue ;
120851: GO 120792
// for j := minerMinesList [ i ] downto 1 do
120853: LD_ADDR_VAR 0 2
120857: PUSH
120858: DOUBLE
120859: LD_EXP 225
120863: PUSH
120864: LD_VAR 0 1
120868: ARRAY
120869: INC
120870: ST_TO_ADDR
120871: LD_INT 1
120873: PUSH
120874: FOR_DOWNTO
120875: IFFALSE 121125
// begin side := GetSide ( minersList [ i ] ) ;
120877: LD_ADDR_VAR 0 3
120881: PUSH
120882: LD_EXP 224
120886: PUSH
120887: LD_VAR 0 1
120891: ARRAY
120892: PPUSH
120893: CALL_OW 255
120897: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
120898: LD_ADDR_VAR 0 4
120902: PUSH
120903: LD_EXP 225
120907: PUSH
120908: LD_VAR 0 1
120912: ARRAY
120913: PUSH
120914: LD_VAR 0 2
120918: ARRAY
120919: PUSH
120920: LD_INT 1
120922: ARRAY
120923: PPUSH
120924: LD_EXP 225
120928: PUSH
120929: LD_VAR 0 1
120933: ARRAY
120934: PUSH
120935: LD_VAR 0 2
120939: ARRAY
120940: PUSH
120941: LD_INT 2
120943: ARRAY
120944: PPUSH
120945: CALL_OW 428
120949: ST_TO_ADDR
// if not tmp then
120950: LD_VAR 0 4
120954: NOT
120955: IFFALSE 120959
// continue ;
120957: GO 120874
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
120959: LD_VAR 0 4
120963: PUSH
120964: LD_INT 81
120966: PUSH
120967: LD_VAR 0 3
120971: PUSH
120972: EMPTY
120973: LIST
120974: LIST
120975: PPUSH
120976: CALL_OW 69
120980: IN
120981: PUSH
120982: LD_EXP 225
120986: PUSH
120987: LD_VAR 0 1
120991: ARRAY
120992: PUSH
120993: LD_VAR 0 2
120997: ARRAY
120998: PUSH
120999: LD_INT 1
121001: ARRAY
121002: PPUSH
121003: LD_EXP 225
121007: PUSH
121008: LD_VAR 0 1
121012: ARRAY
121013: PUSH
121014: LD_VAR 0 2
121018: ARRAY
121019: PUSH
121020: LD_INT 2
121022: ARRAY
121023: PPUSH
121024: CALL_OW 458
121028: AND
121029: IFFALSE 121123
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
121031: LD_EXP 225
121035: PUSH
121036: LD_VAR 0 1
121040: ARRAY
121041: PUSH
121042: LD_VAR 0 2
121046: ARRAY
121047: PUSH
121048: LD_INT 1
121050: ARRAY
121051: PPUSH
121052: LD_EXP 225
121056: PUSH
121057: LD_VAR 0 1
121061: ARRAY
121062: PUSH
121063: LD_VAR 0 2
121067: ARRAY
121068: PUSH
121069: LD_INT 2
121071: ARRAY
121072: PPUSH
121073: LD_VAR 0 3
121077: PPUSH
121078: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
121082: LD_ADDR_EXP 225
121086: PUSH
121087: LD_EXP 225
121091: PPUSH
121092: LD_VAR 0 1
121096: PPUSH
121097: LD_EXP 225
121101: PUSH
121102: LD_VAR 0 1
121106: ARRAY
121107: PPUSH
121108: LD_VAR 0 2
121112: PPUSH
121113: CALL_OW 3
121117: PPUSH
121118: CALL_OW 1
121122: ST_TO_ADDR
// end ; end ;
121123: GO 120874
121125: POP
121126: POP
// end ;
121127: GO 120792
121129: POP
121130: POP
// end ;
121131: PPOPN 4
121133: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
121134: LD_INT 0
121136: PPUSH
121137: PPUSH
// result := false ;
121138: LD_ADDR_VAR 0 4
121142: PUSH
121143: LD_INT 0
121145: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
121146: LD_VAR 0 1
121150: PPUSH
121151: CALL_OW 264
121155: PUSH
121156: LD_EXP 102
121160: EQUAL
121161: NOT
121162: IFFALSE 121166
// exit ;
121164: GO 121406
// index := GetElementIndex ( minersList , unit ) ;
121166: LD_ADDR_VAR 0 5
121170: PUSH
121171: LD_EXP 224
121175: PPUSH
121176: LD_VAR 0 1
121180: PPUSH
121181: CALL 70648 0 2
121185: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
121186: LD_EXP 225
121190: PUSH
121191: LD_VAR 0 5
121195: ARRAY
121196: PUSH
121197: LD_EXP 226
121201: GREATEREQUAL
121202: IFFALSE 121206
// exit ;
121204: GO 121406
// ComMoveXY ( unit , x , y ) ;
121206: LD_VAR 0 1
121210: PPUSH
121211: LD_VAR 0 2
121215: PPUSH
121216: LD_VAR 0 3
121220: PPUSH
121221: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
121225: LD_INT 35
121227: PPUSH
121228: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
121232: LD_VAR 0 1
121236: PPUSH
121237: LD_VAR 0 2
121241: PPUSH
121242: LD_VAR 0 3
121246: PPUSH
121247: CALL 101420 0 3
121251: NOT
121252: PUSH
121253: LD_VAR 0 1
121257: PPUSH
121258: CALL_OW 314
121262: AND
121263: IFFALSE 121267
// exit ;
121265: GO 121406
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
121267: LD_VAR 0 2
121271: PPUSH
121272: LD_VAR 0 3
121276: PPUSH
121277: CALL_OW 428
121281: PUSH
121282: LD_VAR 0 1
121286: EQUAL
121287: PUSH
121288: LD_VAR 0 1
121292: PPUSH
121293: CALL_OW 314
121297: NOT
121298: AND
121299: IFFALSE 121225
// PlaySoundXY ( x , y , PlantMine ) ;
121301: LD_VAR 0 2
121305: PPUSH
121306: LD_VAR 0 3
121310: PPUSH
121311: LD_STRING PlantMine
121313: PPUSH
121314: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
121318: LD_VAR 0 2
121322: PPUSH
121323: LD_VAR 0 3
121327: PPUSH
121328: LD_VAR 0 1
121332: PPUSH
121333: CALL_OW 255
121337: PPUSH
121338: LD_INT 0
121340: PPUSH
121341: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
121345: LD_ADDR_EXP 225
121349: PUSH
121350: LD_EXP 225
121354: PPUSH
121355: LD_VAR 0 5
121359: PUSH
121360: LD_EXP 225
121364: PUSH
121365: LD_VAR 0 5
121369: ARRAY
121370: PUSH
121371: LD_INT 1
121373: PLUS
121374: PUSH
121375: EMPTY
121376: LIST
121377: LIST
121378: PPUSH
121379: LD_VAR 0 2
121383: PUSH
121384: LD_VAR 0 3
121388: PUSH
121389: EMPTY
121390: LIST
121391: LIST
121392: PPUSH
121393: CALL 70863 0 3
121397: ST_TO_ADDR
// result := true ;
121398: LD_ADDR_VAR 0 4
121402: PUSH
121403: LD_INT 1
121405: ST_TO_ADDR
// end ;
121406: LD_VAR 0 4
121410: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
121411: LD_INT 0
121413: PPUSH
121414: PPUSH
121415: PPUSH
// if not unit in minersList then
121416: LD_VAR 0 1
121420: PUSH
121421: LD_EXP 224
121425: IN
121426: NOT
121427: IFFALSE 121431
// exit ;
121429: GO 121823
// index := GetElementIndex ( minersList , unit ) ;
121431: LD_ADDR_VAR 0 6
121435: PUSH
121436: LD_EXP 224
121440: PPUSH
121441: LD_VAR 0 1
121445: PPUSH
121446: CALL 70648 0 2
121450: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
121451: LD_ADDR_VAR 0 5
121455: PUSH
121456: DOUBLE
121457: LD_EXP 225
121461: PUSH
121462: LD_VAR 0 6
121466: ARRAY
121467: INC
121468: ST_TO_ADDR
121469: LD_INT 1
121471: PUSH
121472: FOR_DOWNTO
121473: IFFALSE 121634
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
121475: LD_EXP 225
121479: PUSH
121480: LD_VAR 0 6
121484: ARRAY
121485: PUSH
121486: LD_VAR 0 5
121490: ARRAY
121491: PUSH
121492: LD_INT 1
121494: ARRAY
121495: PUSH
121496: LD_VAR 0 2
121500: EQUAL
121501: PUSH
121502: LD_EXP 225
121506: PUSH
121507: LD_VAR 0 6
121511: ARRAY
121512: PUSH
121513: LD_VAR 0 5
121517: ARRAY
121518: PUSH
121519: LD_INT 2
121521: ARRAY
121522: PUSH
121523: LD_VAR 0 3
121527: EQUAL
121528: AND
121529: IFFALSE 121632
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
121531: LD_EXP 225
121535: PUSH
121536: LD_VAR 0 6
121540: ARRAY
121541: PUSH
121542: LD_VAR 0 5
121546: ARRAY
121547: PUSH
121548: LD_INT 1
121550: ARRAY
121551: PPUSH
121552: LD_EXP 225
121556: PUSH
121557: LD_VAR 0 6
121561: ARRAY
121562: PUSH
121563: LD_VAR 0 5
121567: ARRAY
121568: PUSH
121569: LD_INT 2
121571: ARRAY
121572: PPUSH
121573: LD_VAR 0 1
121577: PPUSH
121578: CALL_OW 255
121582: PPUSH
121583: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
121587: LD_ADDR_EXP 225
121591: PUSH
121592: LD_EXP 225
121596: PPUSH
121597: LD_VAR 0 6
121601: PPUSH
121602: LD_EXP 225
121606: PUSH
121607: LD_VAR 0 6
121611: ARRAY
121612: PPUSH
121613: LD_VAR 0 5
121617: PPUSH
121618: CALL_OW 3
121622: PPUSH
121623: CALL_OW 1
121627: ST_TO_ADDR
// exit ;
121628: POP
121629: POP
121630: GO 121823
// end ; end ;
121632: GO 121472
121634: POP
121635: POP
// for i := minerMinesList [ index ] downto 1 do
121636: LD_ADDR_VAR 0 5
121640: PUSH
121641: DOUBLE
121642: LD_EXP 225
121646: PUSH
121647: LD_VAR 0 6
121651: ARRAY
121652: INC
121653: ST_TO_ADDR
121654: LD_INT 1
121656: PUSH
121657: FOR_DOWNTO
121658: IFFALSE 121821
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
121660: LD_EXP 225
121664: PUSH
121665: LD_VAR 0 6
121669: ARRAY
121670: PUSH
121671: LD_VAR 0 5
121675: ARRAY
121676: PUSH
121677: LD_INT 1
121679: ARRAY
121680: PPUSH
121681: LD_EXP 225
121685: PUSH
121686: LD_VAR 0 6
121690: ARRAY
121691: PUSH
121692: LD_VAR 0 5
121696: ARRAY
121697: PUSH
121698: LD_INT 2
121700: ARRAY
121701: PPUSH
121702: LD_VAR 0 2
121706: PPUSH
121707: LD_VAR 0 3
121711: PPUSH
121712: CALL_OW 298
121716: PUSH
121717: LD_INT 6
121719: LESS
121720: IFFALSE 121819
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
121722: LD_EXP 225
121726: PUSH
121727: LD_VAR 0 6
121731: ARRAY
121732: PUSH
121733: LD_VAR 0 5
121737: ARRAY
121738: PUSH
121739: LD_INT 1
121741: ARRAY
121742: PPUSH
121743: LD_EXP 225
121747: PUSH
121748: LD_VAR 0 6
121752: ARRAY
121753: PUSH
121754: LD_VAR 0 5
121758: ARRAY
121759: PUSH
121760: LD_INT 2
121762: ARRAY
121763: PPUSH
121764: LD_VAR 0 1
121768: PPUSH
121769: CALL_OW 255
121773: PPUSH
121774: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
121778: LD_ADDR_EXP 225
121782: PUSH
121783: LD_EXP 225
121787: PPUSH
121788: LD_VAR 0 6
121792: PPUSH
121793: LD_EXP 225
121797: PUSH
121798: LD_VAR 0 6
121802: ARRAY
121803: PPUSH
121804: LD_VAR 0 5
121808: PPUSH
121809: CALL_OW 3
121813: PPUSH
121814: CALL_OW 1
121818: ST_TO_ADDR
// end ; end ;
121819: GO 121657
121821: POP
121822: POP
// end ;
121823: LD_VAR 0 4
121827: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
121828: LD_INT 0
121830: PPUSH
121831: PPUSH
121832: PPUSH
121833: PPUSH
121834: PPUSH
121835: PPUSH
121836: PPUSH
121837: PPUSH
121838: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
121839: LD_VAR 0 1
121843: PPUSH
121844: CALL_OW 264
121848: PUSH
121849: LD_EXP 102
121853: EQUAL
121854: NOT
121855: PUSH
121856: LD_VAR 0 1
121860: PUSH
121861: LD_EXP 224
121865: IN
121866: NOT
121867: OR
121868: IFFALSE 121872
// exit ;
121870: GO 122194
// index := GetElementIndex ( minersList , unit ) ;
121872: LD_ADDR_VAR 0 6
121876: PUSH
121877: LD_EXP 224
121881: PPUSH
121882: LD_VAR 0 1
121886: PPUSH
121887: CALL 70648 0 2
121891: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
121892: LD_ADDR_VAR 0 8
121896: PUSH
121897: LD_EXP 226
121901: PUSH
121902: LD_EXP 225
121906: PUSH
121907: LD_VAR 0 6
121911: ARRAY
121912: MINUS
121913: ST_TO_ADDR
// if not minesFreeAmount then
121914: LD_VAR 0 8
121918: NOT
121919: IFFALSE 121923
// exit ;
121921: GO 122194
// tmp := [ ] ;
121923: LD_ADDR_VAR 0 7
121927: PUSH
121928: EMPTY
121929: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
121930: LD_ADDR_VAR 0 5
121934: PUSH
121935: DOUBLE
121936: LD_INT 1
121938: DEC
121939: ST_TO_ADDR
121940: LD_VAR 0 8
121944: PUSH
121945: FOR_TO
121946: IFFALSE 122141
// begin _d := rand ( 0 , 5 ) ;
121948: LD_ADDR_VAR 0 11
121952: PUSH
121953: LD_INT 0
121955: PPUSH
121956: LD_INT 5
121958: PPUSH
121959: CALL_OW 12
121963: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
121964: LD_ADDR_VAR 0 12
121968: PUSH
121969: LD_INT 2
121971: PPUSH
121972: LD_INT 6
121974: PPUSH
121975: CALL_OW 12
121979: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
121980: LD_ADDR_VAR 0 9
121984: PUSH
121985: LD_VAR 0 2
121989: PPUSH
121990: LD_VAR 0 11
121994: PPUSH
121995: LD_VAR 0 12
121999: PPUSH
122000: CALL_OW 272
122004: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
122005: LD_ADDR_VAR 0 10
122009: PUSH
122010: LD_VAR 0 3
122014: PPUSH
122015: LD_VAR 0 11
122019: PPUSH
122020: LD_VAR 0 12
122024: PPUSH
122025: CALL_OW 273
122029: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
122030: LD_VAR 0 9
122034: PPUSH
122035: LD_VAR 0 10
122039: PPUSH
122040: CALL_OW 488
122044: PUSH
122045: LD_VAR 0 9
122049: PUSH
122050: LD_VAR 0 10
122054: PUSH
122055: EMPTY
122056: LIST
122057: LIST
122058: PUSH
122059: LD_VAR 0 7
122063: IN
122064: NOT
122065: AND
122066: PUSH
122067: LD_VAR 0 9
122071: PPUSH
122072: LD_VAR 0 10
122076: PPUSH
122077: CALL_OW 458
122081: NOT
122082: AND
122083: IFFALSE 122125
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
122085: LD_ADDR_VAR 0 7
122089: PUSH
122090: LD_VAR 0 7
122094: PPUSH
122095: LD_VAR 0 7
122099: PUSH
122100: LD_INT 1
122102: PLUS
122103: PPUSH
122104: LD_VAR 0 9
122108: PUSH
122109: LD_VAR 0 10
122113: PUSH
122114: EMPTY
122115: LIST
122116: LIST
122117: PPUSH
122118: CALL_OW 1
122122: ST_TO_ADDR
122123: GO 122139
// i := i - 1 ;
122125: LD_ADDR_VAR 0 5
122129: PUSH
122130: LD_VAR 0 5
122134: PUSH
122135: LD_INT 1
122137: MINUS
122138: ST_TO_ADDR
// end ;
122139: GO 121945
122141: POP
122142: POP
// for i in tmp do
122143: LD_ADDR_VAR 0 5
122147: PUSH
122148: LD_VAR 0 7
122152: PUSH
122153: FOR_IN
122154: IFFALSE 122192
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
122156: LD_VAR 0 1
122160: PPUSH
122161: LD_VAR 0 5
122165: PUSH
122166: LD_INT 1
122168: ARRAY
122169: PPUSH
122170: LD_VAR 0 5
122174: PUSH
122175: LD_INT 2
122177: ARRAY
122178: PPUSH
122179: CALL 121134 0 3
122183: NOT
122184: IFFALSE 122190
// exit ;
122186: POP
122187: POP
122188: GO 122194
122190: GO 122153
122192: POP
122193: POP
// end ;
122194: LD_VAR 0 4
122198: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
122199: LD_INT 0
122201: PPUSH
122202: PPUSH
122203: PPUSH
122204: PPUSH
122205: PPUSH
122206: PPUSH
122207: PPUSH
// if not GetClass ( unit ) = class_sniper then
122208: LD_VAR 0 1
122212: PPUSH
122213: CALL_OW 257
122217: PUSH
122218: LD_INT 5
122220: EQUAL
122221: NOT
122222: IFFALSE 122226
// exit ;
122224: GO 122614
// dist := 8 ;
122226: LD_ADDR_VAR 0 5
122230: PUSH
122231: LD_INT 8
122233: ST_TO_ADDR
// viewRange := 12 ;
122234: LD_ADDR_VAR 0 7
122238: PUSH
122239: LD_INT 12
122241: ST_TO_ADDR
// side := GetSide ( unit ) ;
122242: LD_ADDR_VAR 0 6
122246: PUSH
122247: LD_VAR 0 1
122251: PPUSH
122252: CALL_OW 255
122256: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
122257: LD_INT 61
122259: PPUSH
122260: LD_VAR 0 6
122264: PPUSH
122265: CALL_OW 321
122269: PUSH
122270: LD_INT 2
122272: EQUAL
122273: IFFALSE 122283
// viewRange := 16 ;
122275: LD_ADDR_VAR 0 7
122279: PUSH
122280: LD_INT 16
122282: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
122283: LD_VAR 0 1
122287: PPUSH
122288: LD_VAR 0 2
122292: PPUSH
122293: LD_VAR 0 3
122297: PPUSH
122298: CALL_OW 297
122302: PUSH
122303: LD_VAR 0 5
122307: GREATER
122308: IFFALSE 122387
// begin ComMoveXY ( unit , x , y ) ;
122310: LD_VAR 0 1
122314: PPUSH
122315: LD_VAR 0 2
122319: PPUSH
122320: LD_VAR 0 3
122324: PPUSH
122325: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
122329: LD_INT 35
122331: PPUSH
122332: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
122336: LD_VAR 0 1
122340: PPUSH
122341: LD_VAR 0 2
122345: PPUSH
122346: LD_VAR 0 3
122350: PPUSH
122351: CALL 101420 0 3
122355: NOT
122356: IFFALSE 122360
// exit ;
122358: GO 122614
// until GetDistUnitXY ( unit , x , y ) < dist ;
122360: LD_VAR 0 1
122364: PPUSH
122365: LD_VAR 0 2
122369: PPUSH
122370: LD_VAR 0 3
122374: PPUSH
122375: CALL_OW 297
122379: PUSH
122380: LD_VAR 0 5
122384: LESS
122385: IFFALSE 122329
// end ; ComTurnXY ( unit , x , y ) ;
122387: LD_VAR 0 1
122391: PPUSH
122392: LD_VAR 0 2
122396: PPUSH
122397: LD_VAR 0 3
122401: PPUSH
122402: CALL_OW 118
// wait ( 5 ) ;
122406: LD_INT 5
122408: PPUSH
122409: CALL_OW 67
// _d := GetDir ( unit ) ;
122413: LD_ADDR_VAR 0 10
122417: PUSH
122418: LD_VAR 0 1
122422: PPUSH
122423: CALL_OW 254
122427: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
122428: LD_ADDR_VAR 0 8
122432: PUSH
122433: LD_VAR 0 1
122437: PPUSH
122438: CALL_OW 250
122442: PPUSH
122443: LD_VAR 0 10
122447: PPUSH
122448: LD_VAR 0 5
122452: PPUSH
122453: CALL_OW 272
122457: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
122458: LD_ADDR_VAR 0 9
122462: PUSH
122463: LD_VAR 0 1
122467: PPUSH
122468: CALL_OW 251
122472: PPUSH
122473: LD_VAR 0 10
122477: PPUSH
122478: LD_VAR 0 5
122482: PPUSH
122483: CALL_OW 273
122487: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
122488: LD_VAR 0 8
122492: PPUSH
122493: LD_VAR 0 9
122497: PPUSH
122498: CALL_OW 488
122502: NOT
122503: IFFALSE 122507
// exit ;
122505: GO 122614
// ComAnimCustom ( unit , 1 ) ;
122507: LD_VAR 0 1
122511: PPUSH
122512: LD_INT 1
122514: PPUSH
122515: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
122519: LD_VAR 0 8
122523: PPUSH
122524: LD_VAR 0 9
122528: PPUSH
122529: LD_VAR 0 6
122533: PPUSH
122534: LD_VAR 0 7
122538: PPUSH
122539: CALL_OW 330
// repeat wait ( 1 ) ;
122543: LD_INT 1
122545: PPUSH
122546: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
122550: LD_VAR 0 1
122554: PPUSH
122555: CALL_OW 316
122559: PUSH
122560: LD_VAR 0 1
122564: PPUSH
122565: CALL_OW 314
122569: OR
122570: PUSH
122571: LD_VAR 0 1
122575: PPUSH
122576: CALL_OW 302
122580: NOT
122581: OR
122582: PUSH
122583: LD_VAR 0 1
122587: PPUSH
122588: CALL_OW 301
122592: OR
122593: IFFALSE 122543
// RemoveSeeing ( _x , _y , side ) ;
122595: LD_VAR 0 8
122599: PPUSH
122600: LD_VAR 0 9
122604: PPUSH
122605: LD_VAR 0 6
122609: PPUSH
122610: CALL_OW 331
// end ; end_of_file
122614: LD_VAR 0 4
122618: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
122619: LD_INT 0
122621: PPUSH
122622: PPUSH
122623: PPUSH
122624: PPUSH
122625: PPUSH
122626: PPUSH
122627: PPUSH
122628: PPUSH
122629: PPUSH
122630: PPUSH
122631: PPUSH
122632: PPUSH
122633: PPUSH
122634: PPUSH
122635: PPUSH
122636: PPUSH
122637: PPUSH
122638: PPUSH
122639: PPUSH
122640: PPUSH
122641: PPUSH
122642: PPUSH
122643: PPUSH
122644: PPUSH
122645: PPUSH
122646: PPUSH
122647: PPUSH
122648: PPUSH
122649: PPUSH
122650: PPUSH
122651: PPUSH
122652: PPUSH
122653: PPUSH
122654: PPUSH
// if not list then
122655: LD_VAR 0 1
122659: NOT
122660: IFFALSE 122664
// exit ;
122662: GO 127323
// base := list [ 1 ] ;
122664: LD_ADDR_VAR 0 3
122668: PUSH
122669: LD_VAR 0 1
122673: PUSH
122674: LD_INT 1
122676: ARRAY
122677: ST_TO_ADDR
// group := list [ 2 ] ;
122678: LD_ADDR_VAR 0 4
122682: PUSH
122683: LD_VAR 0 1
122687: PUSH
122688: LD_INT 2
122690: ARRAY
122691: ST_TO_ADDR
// path := list [ 3 ] ;
122692: LD_ADDR_VAR 0 5
122696: PUSH
122697: LD_VAR 0 1
122701: PUSH
122702: LD_INT 3
122704: ARRAY
122705: ST_TO_ADDR
// flags := list [ 4 ] ;
122706: LD_ADDR_VAR 0 6
122710: PUSH
122711: LD_VAR 0 1
122715: PUSH
122716: LD_INT 4
122718: ARRAY
122719: ST_TO_ADDR
// mined := [ ] ;
122720: LD_ADDR_VAR 0 27
122724: PUSH
122725: EMPTY
122726: ST_TO_ADDR
// bombed := [ ] ;
122727: LD_ADDR_VAR 0 28
122731: PUSH
122732: EMPTY
122733: ST_TO_ADDR
// healers := [ ] ;
122734: LD_ADDR_VAR 0 31
122738: PUSH
122739: EMPTY
122740: ST_TO_ADDR
// to_heal := [ ] ;
122741: LD_ADDR_VAR 0 30
122745: PUSH
122746: EMPTY
122747: ST_TO_ADDR
// repairs := [ ] ;
122748: LD_ADDR_VAR 0 33
122752: PUSH
122753: EMPTY
122754: ST_TO_ADDR
// to_repair := [ ] ;
122755: LD_ADDR_VAR 0 32
122759: PUSH
122760: EMPTY
122761: ST_TO_ADDR
// if not group or not path then
122762: LD_VAR 0 4
122766: NOT
122767: PUSH
122768: LD_VAR 0 5
122772: NOT
122773: OR
122774: IFFALSE 122778
// exit ;
122776: GO 127323
// side := GetSide ( group [ 1 ] ) ;
122778: LD_ADDR_VAR 0 35
122782: PUSH
122783: LD_VAR 0 4
122787: PUSH
122788: LD_INT 1
122790: ARRAY
122791: PPUSH
122792: CALL_OW 255
122796: ST_TO_ADDR
// if flags then
122797: LD_VAR 0 6
122801: IFFALSE 122945
// begin f_ignore_area := flags [ 1 ] ;
122803: LD_ADDR_VAR 0 17
122807: PUSH
122808: LD_VAR 0 6
122812: PUSH
122813: LD_INT 1
122815: ARRAY
122816: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
122817: LD_ADDR_VAR 0 18
122821: PUSH
122822: LD_VAR 0 6
122826: PUSH
122827: LD_INT 2
122829: ARRAY
122830: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
122831: LD_ADDR_VAR 0 19
122835: PUSH
122836: LD_VAR 0 6
122840: PUSH
122841: LD_INT 3
122843: ARRAY
122844: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
122845: LD_ADDR_VAR 0 20
122849: PUSH
122850: LD_VAR 0 6
122854: PUSH
122855: LD_INT 4
122857: ARRAY
122858: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
122859: LD_ADDR_VAR 0 21
122863: PUSH
122864: LD_VAR 0 6
122868: PUSH
122869: LD_INT 5
122871: ARRAY
122872: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
122873: LD_ADDR_VAR 0 22
122877: PUSH
122878: LD_VAR 0 6
122882: PUSH
122883: LD_INT 6
122885: ARRAY
122886: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
122887: LD_ADDR_VAR 0 23
122891: PUSH
122892: LD_VAR 0 6
122896: PUSH
122897: LD_INT 7
122899: ARRAY
122900: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
122901: LD_ADDR_VAR 0 24
122905: PUSH
122906: LD_VAR 0 6
122910: PUSH
122911: LD_INT 8
122913: ARRAY
122914: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
122915: LD_ADDR_VAR 0 25
122919: PUSH
122920: LD_VAR 0 6
122924: PUSH
122925: LD_INT 9
122927: ARRAY
122928: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
122929: LD_ADDR_VAR 0 26
122933: PUSH
122934: LD_VAR 0 6
122938: PUSH
122939: LD_INT 10
122941: ARRAY
122942: ST_TO_ADDR
// end else
122943: GO 123025
// begin f_ignore_area := false ;
122945: LD_ADDR_VAR 0 17
122949: PUSH
122950: LD_INT 0
122952: ST_TO_ADDR
// f_capture := false ;
122953: LD_ADDR_VAR 0 18
122957: PUSH
122958: LD_INT 0
122960: ST_TO_ADDR
// f_ignore_civ := false ;
122961: LD_ADDR_VAR 0 19
122965: PUSH
122966: LD_INT 0
122968: ST_TO_ADDR
// f_murder := false ;
122969: LD_ADDR_VAR 0 20
122973: PUSH
122974: LD_INT 0
122976: ST_TO_ADDR
// f_mines := false ;
122977: LD_ADDR_VAR 0 21
122981: PUSH
122982: LD_INT 0
122984: ST_TO_ADDR
// f_repair := false ;
122985: LD_ADDR_VAR 0 22
122989: PUSH
122990: LD_INT 0
122992: ST_TO_ADDR
// f_heal := false ;
122993: LD_ADDR_VAR 0 23
122997: PUSH
122998: LD_INT 0
123000: ST_TO_ADDR
// f_spacetime := false ;
123001: LD_ADDR_VAR 0 24
123005: PUSH
123006: LD_INT 0
123008: ST_TO_ADDR
// f_attack_depot := false ;
123009: LD_ADDR_VAR 0 25
123013: PUSH
123014: LD_INT 0
123016: ST_TO_ADDR
// f_crawl := false ;
123017: LD_ADDR_VAR 0 26
123021: PUSH
123022: LD_INT 0
123024: ST_TO_ADDR
// end ; if f_heal then
123025: LD_VAR 0 23
123029: IFFALSE 123056
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
123031: LD_ADDR_VAR 0 31
123035: PUSH
123036: LD_VAR 0 4
123040: PPUSH
123041: LD_INT 25
123043: PUSH
123044: LD_INT 4
123046: PUSH
123047: EMPTY
123048: LIST
123049: LIST
123050: PPUSH
123051: CALL_OW 72
123055: ST_TO_ADDR
// if f_repair then
123056: LD_VAR 0 22
123060: IFFALSE 123087
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
123062: LD_ADDR_VAR 0 33
123066: PUSH
123067: LD_VAR 0 4
123071: PPUSH
123072: LD_INT 25
123074: PUSH
123075: LD_INT 3
123077: PUSH
123078: EMPTY
123079: LIST
123080: LIST
123081: PPUSH
123082: CALL_OW 72
123086: ST_TO_ADDR
// units_path := [ ] ;
123087: LD_ADDR_VAR 0 16
123091: PUSH
123092: EMPTY
123093: ST_TO_ADDR
// for i = 1 to group do
123094: LD_ADDR_VAR 0 7
123098: PUSH
123099: DOUBLE
123100: LD_INT 1
123102: DEC
123103: ST_TO_ADDR
123104: LD_VAR 0 4
123108: PUSH
123109: FOR_TO
123110: IFFALSE 123139
// units_path := Replace ( units_path , i , path ) ;
123112: LD_ADDR_VAR 0 16
123116: PUSH
123117: LD_VAR 0 16
123121: PPUSH
123122: LD_VAR 0 7
123126: PPUSH
123127: LD_VAR 0 5
123131: PPUSH
123132: CALL_OW 1
123136: ST_TO_ADDR
123137: GO 123109
123139: POP
123140: POP
// repeat for i = group downto 1 do
123141: LD_ADDR_VAR 0 7
123145: PUSH
123146: DOUBLE
123147: LD_VAR 0 4
123151: INC
123152: ST_TO_ADDR
123153: LD_INT 1
123155: PUSH
123156: FOR_DOWNTO
123157: IFFALSE 127279
// begin wait ( 5 ) ;
123159: LD_INT 5
123161: PPUSH
123162: CALL_OW 67
// tmp := [ ] ;
123166: LD_ADDR_VAR 0 14
123170: PUSH
123171: EMPTY
123172: ST_TO_ADDR
// attacking := false ;
123173: LD_ADDR_VAR 0 29
123177: PUSH
123178: LD_INT 0
123180: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
123181: LD_VAR 0 4
123185: PUSH
123186: LD_VAR 0 7
123190: ARRAY
123191: PPUSH
123192: CALL_OW 301
123196: PUSH
123197: LD_VAR 0 4
123201: PUSH
123202: LD_VAR 0 7
123206: ARRAY
123207: NOT
123208: OR
123209: IFFALSE 123318
// begin if GetType ( group [ i ] ) = unit_human then
123211: LD_VAR 0 4
123215: PUSH
123216: LD_VAR 0 7
123220: ARRAY
123221: PPUSH
123222: CALL_OW 247
123226: PUSH
123227: LD_INT 1
123229: EQUAL
123230: IFFALSE 123276
// begin to_heal := to_heal diff group [ i ] ;
123232: LD_ADDR_VAR 0 30
123236: PUSH
123237: LD_VAR 0 30
123241: PUSH
123242: LD_VAR 0 4
123246: PUSH
123247: LD_VAR 0 7
123251: ARRAY
123252: DIFF
123253: ST_TO_ADDR
// healers := healers diff group [ i ] ;
123254: LD_ADDR_VAR 0 31
123258: PUSH
123259: LD_VAR 0 31
123263: PUSH
123264: LD_VAR 0 4
123268: PUSH
123269: LD_VAR 0 7
123273: ARRAY
123274: DIFF
123275: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
123276: LD_ADDR_VAR 0 4
123280: PUSH
123281: LD_VAR 0 4
123285: PPUSH
123286: LD_VAR 0 7
123290: PPUSH
123291: CALL_OW 3
123295: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
123296: LD_ADDR_VAR 0 16
123300: PUSH
123301: LD_VAR 0 16
123305: PPUSH
123306: LD_VAR 0 7
123310: PPUSH
123311: CALL_OW 3
123315: ST_TO_ADDR
// continue ;
123316: GO 123156
// end ; if f_repair then
123318: LD_VAR 0 22
123322: IFFALSE 123811
// begin if GetType ( group [ i ] ) = unit_vehicle then
123324: LD_VAR 0 4
123328: PUSH
123329: LD_VAR 0 7
123333: ARRAY
123334: PPUSH
123335: CALL_OW 247
123339: PUSH
123340: LD_INT 2
123342: EQUAL
123343: IFFALSE 123533
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
123345: LD_VAR 0 4
123349: PUSH
123350: LD_VAR 0 7
123354: ARRAY
123355: PPUSH
123356: CALL_OW 256
123360: PUSH
123361: LD_INT 700
123363: LESS
123364: PUSH
123365: LD_VAR 0 4
123369: PUSH
123370: LD_VAR 0 7
123374: ARRAY
123375: PUSH
123376: LD_VAR 0 32
123380: IN
123381: NOT
123382: AND
123383: IFFALSE 123407
// to_repair := to_repair union group [ i ] ;
123385: LD_ADDR_VAR 0 32
123389: PUSH
123390: LD_VAR 0 32
123394: PUSH
123395: LD_VAR 0 4
123399: PUSH
123400: LD_VAR 0 7
123404: ARRAY
123405: UNION
123406: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
123407: LD_VAR 0 4
123411: PUSH
123412: LD_VAR 0 7
123416: ARRAY
123417: PPUSH
123418: CALL_OW 256
123422: PUSH
123423: LD_INT 1000
123425: EQUAL
123426: PUSH
123427: LD_VAR 0 4
123431: PUSH
123432: LD_VAR 0 7
123436: ARRAY
123437: PUSH
123438: LD_VAR 0 32
123442: IN
123443: AND
123444: IFFALSE 123468
// to_repair := to_repair diff group [ i ] ;
123446: LD_ADDR_VAR 0 32
123450: PUSH
123451: LD_VAR 0 32
123455: PUSH
123456: LD_VAR 0 4
123460: PUSH
123461: LD_VAR 0 7
123465: ARRAY
123466: DIFF
123467: ST_TO_ADDR
// if group [ i ] in to_repair then
123468: LD_VAR 0 4
123472: PUSH
123473: LD_VAR 0 7
123477: ARRAY
123478: PUSH
123479: LD_VAR 0 32
123483: IN
123484: IFFALSE 123531
// begin if not IsInArea ( group [ i ] , f_repair ) then
123486: LD_VAR 0 4
123490: PUSH
123491: LD_VAR 0 7
123495: ARRAY
123496: PPUSH
123497: LD_VAR 0 22
123501: PPUSH
123502: CALL_OW 308
123506: NOT
123507: IFFALSE 123529
// ComMoveToArea ( group [ i ] , f_repair ) ;
123509: LD_VAR 0 4
123513: PUSH
123514: LD_VAR 0 7
123518: ARRAY
123519: PPUSH
123520: LD_VAR 0 22
123524: PPUSH
123525: CALL_OW 113
// continue ;
123529: GO 123156
// end ; end else
123531: GO 123811
// if group [ i ] in repairs then
123533: LD_VAR 0 4
123537: PUSH
123538: LD_VAR 0 7
123542: ARRAY
123543: PUSH
123544: LD_VAR 0 33
123548: IN
123549: IFFALSE 123811
// begin if IsInUnit ( group [ i ] ) then
123551: LD_VAR 0 4
123555: PUSH
123556: LD_VAR 0 7
123560: ARRAY
123561: PPUSH
123562: CALL_OW 310
123566: IFFALSE 123634
// begin z := IsInUnit ( group [ i ] ) ;
123568: LD_ADDR_VAR 0 13
123572: PUSH
123573: LD_VAR 0 4
123577: PUSH
123578: LD_VAR 0 7
123582: ARRAY
123583: PPUSH
123584: CALL_OW 310
123588: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
123589: LD_VAR 0 13
123593: PUSH
123594: LD_VAR 0 32
123598: IN
123599: PUSH
123600: LD_VAR 0 13
123604: PPUSH
123605: LD_VAR 0 22
123609: PPUSH
123610: CALL_OW 308
123614: AND
123615: IFFALSE 123632
// ComExitVehicle ( group [ i ] ) ;
123617: LD_VAR 0 4
123621: PUSH
123622: LD_VAR 0 7
123626: ARRAY
123627: PPUSH
123628: CALL_OW 121
// end else
123632: GO 123811
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
123634: LD_ADDR_VAR 0 13
123638: PUSH
123639: LD_VAR 0 4
123643: PPUSH
123644: LD_INT 95
123646: PUSH
123647: LD_VAR 0 22
123651: PUSH
123652: EMPTY
123653: LIST
123654: LIST
123655: PUSH
123656: LD_INT 58
123658: PUSH
123659: EMPTY
123660: LIST
123661: PUSH
123662: EMPTY
123663: LIST
123664: LIST
123665: PPUSH
123666: CALL_OW 72
123670: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
123671: LD_VAR 0 4
123675: PUSH
123676: LD_VAR 0 7
123680: ARRAY
123681: PPUSH
123682: CALL_OW 314
123686: NOT
123687: IFFALSE 123809
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
123689: LD_ADDR_VAR 0 10
123693: PUSH
123694: LD_VAR 0 13
123698: PPUSH
123699: LD_VAR 0 4
123703: PUSH
123704: LD_VAR 0 7
123708: ARRAY
123709: PPUSH
123710: CALL_OW 74
123714: ST_TO_ADDR
// if not x then
123715: LD_VAR 0 10
123719: NOT
123720: IFFALSE 123724
// continue ;
123722: GO 123156
// if GetLives ( x ) < 1000 then
123724: LD_VAR 0 10
123728: PPUSH
123729: CALL_OW 256
123733: PUSH
123734: LD_INT 1000
123736: LESS
123737: IFFALSE 123761
// ComRepairVehicle ( group [ i ] , x ) else
123739: LD_VAR 0 4
123743: PUSH
123744: LD_VAR 0 7
123748: ARRAY
123749: PPUSH
123750: LD_VAR 0 10
123754: PPUSH
123755: CALL_OW 129
123759: GO 123809
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
123761: LD_VAR 0 23
123765: PUSH
123766: LD_VAR 0 4
123770: PUSH
123771: LD_VAR 0 7
123775: ARRAY
123776: PPUSH
123777: CALL_OW 256
123781: PUSH
123782: LD_INT 1000
123784: LESS
123785: AND
123786: NOT
123787: IFFALSE 123809
// ComEnterUnit ( group [ i ] , x ) ;
123789: LD_VAR 0 4
123793: PUSH
123794: LD_VAR 0 7
123798: ARRAY
123799: PPUSH
123800: LD_VAR 0 10
123804: PPUSH
123805: CALL_OW 120
// end ; continue ;
123809: GO 123156
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
123811: LD_VAR 0 23
123815: PUSH
123816: LD_VAR 0 4
123820: PUSH
123821: LD_VAR 0 7
123825: ARRAY
123826: PPUSH
123827: CALL_OW 247
123831: PUSH
123832: LD_INT 1
123834: EQUAL
123835: AND
123836: IFFALSE 124314
// begin if group [ i ] in healers then
123838: LD_VAR 0 4
123842: PUSH
123843: LD_VAR 0 7
123847: ARRAY
123848: PUSH
123849: LD_VAR 0 31
123853: IN
123854: IFFALSE 124127
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
123856: LD_VAR 0 4
123860: PUSH
123861: LD_VAR 0 7
123865: ARRAY
123866: PPUSH
123867: LD_VAR 0 23
123871: PPUSH
123872: CALL_OW 308
123876: NOT
123877: PUSH
123878: LD_VAR 0 4
123882: PUSH
123883: LD_VAR 0 7
123887: ARRAY
123888: PPUSH
123889: CALL_OW 314
123893: NOT
123894: AND
123895: IFFALSE 123919
// ComMoveToArea ( group [ i ] , f_heal ) else
123897: LD_VAR 0 4
123901: PUSH
123902: LD_VAR 0 7
123906: ARRAY
123907: PPUSH
123908: LD_VAR 0 23
123912: PPUSH
123913: CALL_OW 113
123917: GO 124125
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
123919: LD_VAR 0 4
123923: PUSH
123924: LD_VAR 0 7
123928: ARRAY
123929: PPUSH
123930: CALL 99943 0 1
123934: PPUSH
123935: CALL_OW 256
123939: PUSH
123940: LD_INT 1000
123942: EQUAL
123943: IFFALSE 123962
// ComStop ( group [ i ] ) else
123945: LD_VAR 0 4
123949: PUSH
123950: LD_VAR 0 7
123954: ARRAY
123955: PPUSH
123956: CALL_OW 141
123960: GO 124125
// if not HasTask ( group [ i ] ) and to_heal then
123962: LD_VAR 0 4
123966: PUSH
123967: LD_VAR 0 7
123971: ARRAY
123972: PPUSH
123973: CALL_OW 314
123977: NOT
123978: PUSH
123979: LD_VAR 0 30
123983: AND
123984: IFFALSE 124125
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
123986: LD_ADDR_VAR 0 13
123990: PUSH
123991: LD_VAR 0 30
123995: PPUSH
123996: LD_INT 3
123998: PUSH
123999: LD_INT 54
124001: PUSH
124002: EMPTY
124003: LIST
124004: PUSH
124005: EMPTY
124006: LIST
124007: LIST
124008: PPUSH
124009: CALL_OW 72
124013: PPUSH
124014: LD_VAR 0 4
124018: PUSH
124019: LD_VAR 0 7
124023: ARRAY
124024: PPUSH
124025: CALL_OW 74
124029: ST_TO_ADDR
// if z then
124030: LD_VAR 0 13
124034: IFFALSE 124125
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
124036: LD_INT 91
124038: PUSH
124039: LD_VAR 0 13
124043: PUSH
124044: LD_INT 10
124046: PUSH
124047: EMPTY
124048: LIST
124049: LIST
124050: LIST
124051: PUSH
124052: LD_INT 81
124054: PUSH
124055: LD_VAR 0 13
124059: PPUSH
124060: CALL_OW 255
124064: PUSH
124065: EMPTY
124066: LIST
124067: LIST
124068: PUSH
124069: EMPTY
124070: LIST
124071: LIST
124072: PPUSH
124073: CALL_OW 69
124077: PUSH
124078: LD_INT 0
124080: EQUAL
124081: IFFALSE 124105
// ComHeal ( group [ i ] , z ) else
124083: LD_VAR 0 4
124087: PUSH
124088: LD_VAR 0 7
124092: ARRAY
124093: PPUSH
124094: LD_VAR 0 13
124098: PPUSH
124099: CALL_OW 128
124103: GO 124125
// ComMoveToArea ( group [ i ] , f_heal ) ;
124105: LD_VAR 0 4
124109: PUSH
124110: LD_VAR 0 7
124114: ARRAY
124115: PPUSH
124116: LD_VAR 0 23
124120: PPUSH
124121: CALL_OW 113
// end ; continue ;
124125: GO 123156
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
124127: LD_VAR 0 4
124131: PUSH
124132: LD_VAR 0 7
124136: ARRAY
124137: PPUSH
124138: CALL_OW 256
124142: PUSH
124143: LD_INT 700
124145: LESS
124146: PUSH
124147: LD_VAR 0 4
124151: PUSH
124152: LD_VAR 0 7
124156: ARRAY
124157: PUSH
124158: LD_VAR 0 30
124162: IN
124163: NOT
124164: AND
124165: IFFALSE 124189
// to_heal := to_heal union group [ i ] ;
124167: LD_ADDR_VAR 0 30
124171: PUSH
124172: LD_VAR 0 30
124176: PUSH
124177: LD_VAR 0 4
124181: PUSH
124182: LD_VAR 0 7
124186: ARRAY
124187: UNION
124188: ST_TO_ADDR
// if group [ i ] in to_heal then
124189: LD_VAR 0 4
124193: PUSH
124194: LD_VAR 0 7
124198: ARRAY
124199: PUSH
124200: LD_VAR 0 30
124204: IN
124205: IFFALSE 124314
// begin if GetLives ( group [ i ] ) = 1000 then
124207: LD_VAR 0 4
124211: PUSH
124212: LD_VAR 0 7
124216: ARRAY
124217: PPUSH
124218: CALL_OW 256
124222: PUSH
124223: LD_INT 1000
124225: EQUAL
124226: IFFALSE 124252
// to_heal := to_heal diff group [ i ] else
124228: LD_ADDR_VAR 0 30
124232: PUSH
124233: LD_VAR 0 30
124237: PUSH
124238: LD_VAR 0 4
124242: PUSH
124243: LD_VAR 0 7
124247: ARRAY
124248: DIFF
124249: ST_TO_ADDR
124250: GO 124314
// begin if not IsInArea ( group [ i ] , to_heal ) then
124252: LD_VAR 0 4
124256: PUSH
124257: LD_VAR 0 7
124261: ARRAY
124262: PPUSH
124263: LD_VAR 0 30
124267: PPUSH
124268: CALL_OW 308
124272: NOT
124273: IFFALSE 124297
// ComMoveToArea ( group [ i ] , f_heal ) else
124275: LD_VAR 0 4
124279: PUSH
124280: LD_VAR 0 7
124284: ARRAY
124285: PPUSH
124286: LD_VAR 0 23
124290: PPUSH
124291: CALL_OW 113
124295: GO 124312
// ComHold ( group [ i ] ) ;
124297: LD_VAR 0 4
124301: PUSH
124302: LD_VAR 0 7
124306: ARRAY
124307: PPUSH
124308: CALL_OW 140
// continue ;
124312: GO 123156
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
124314: LD_VAR 0 4
124318: PUSH
124319: LD_VAR 0 7
124323: ARRAY
124324: PPUSH
124325: LD_INT 10
124327: PPUSH
124328: CALL 98363 0 2
124332: NOT
124333: PUSH
124334: LD_VAR 0 16
124338: PUSH
124339: LD_VAR 0 7
124343: ARRAY
124344: PUSH
124345: EMPTY
124346: EQUAL
124347: NOT
124348: AND
124349: IFFALSE 124615
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
124351: LD_VAR 0 4
124355: PUSH
124356: LD_VAR 0 7
124360: ARRAY
124361: PPUSH
124362: CALL_OW 262
124366: PUSH
124367: LD_INT 1
124369: PUSH
124370: LD_INT 2
124372: PUSH
124373: EMPTY
124374: LIST
124375: LIST
124376: IN
124377: IFFALSE 124418
// if GetFuel ( group [ i ] ) < 10 then
124379: LD_VAR 0 4
124383: PUSH
124384: LD_VAR 0 7
124388: ARRAY
124389: PPUSH
124390: CALL_OW 261
124394: PUSH
124395: LD_INT 10
124397: LESS
124398: IFFALSE 124418
// SetFuel ( group [ i ] , 12 ) ;
124400: LD_VAR 0 4
124404: PUSH
124405: LD_VAR 0 7
124409: ARRAY
124410: PPUSH
124411: LD_INT 12
124413: PPUSH
124414: CALL_OW 240
// if units_path [ i ] then
124418: LD_VAR 0 16
124422: PUSH
124423: LD_VAR 0 7
124427: ARRAY
124428: IFFALSE 124613
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
124430: LD_VAR 0 4
124434: PUSH
124435: LD_VAR 0 7
124439: ARRAY
124440: PPUSH
124441: LD_VAR 0 16
124445: PUSH
124446: LD_VAR 0 7
124450: ARRAY
124451: PUSH
124452: LD_INT 1
124454: ARRAY
124455: PUSH
124456: LD_INT 1
124458: ARRAY
124459: PPUSH
124460: LD_VAR 0 16
124464: PUSH
124465: LD_VAR 0 7
124469: ARRAY
124470: PUSH
124471: LD_INT 1
124473: ARRAY
124474: PUSH
124475: LD_INT 2
124477: ARRAY
124478: PPUSH
124479: CALL_OW 297
124483: PUSH
124484: LD_INT 6
124486: GREATER
124487: IFFALSE 124562
// begin if not HasTask ( group [ i ] ) then
124489: LD_VAR 0 4
124493: PUSH
124494: LD_VAR 0 7
124498: ARRAY
124499: PPUSH
124500: CALL_OW 314
124504: NOT
124505: IFFALSE 124560
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
124507: LD_VAR 0 4
124511: PUSH
124512: LD_VAR 0 7
124516: ARRAY
124517: PPUSH
124518: LD_VAR 0 16
124522: PUSH
124523: LD_VAR 0 7
124527: ARRAY
124528: PUSH
124529: LD_INT 1
124531: ARRAY
124532: PUSH
124533: LD_INT 1
124535: ARRAY
124536: PPUSH
124537: LD_VAR 0 16
124541: PUSH
124542: LD_VAR 0 7
124546: ARRAY
124547: PUSH
124548: LD_INT 1
124550: ARRAY
124551: PUSH
124552: LD_INT 2
124554: ARRAY
124555: PPUSH
124556: CALL_OW 114
// end else
124560: GO 124613
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
124562: LD_ADDR_VAR 0 15
124566: PUSH
124567: LD_VAR 0 16
124571: PUSH
124572: LD_VAR 0 7
124576: ARRAY
124577: PPUSH
124578: LD_INT 1
124580: PPUSH
124581: CALL_OW 3
124585: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
124586: LD_ADDR_VAR 0 16
124590: PUSH
124591: LD_VAR 0 16
124595: PPUSH
124596: LD_VAR 0 7
124600: PPUSH
124601: LD_VAR 0 15
124605: PPUSH
124606: CALL_OW 1
124610: ST_TO_ADDR
// continue ;
124611: GO 123156
// end ; end ; end else
124613: GO 127277
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
124615: LD_ADDR_VAR 0 14
124619: PUSH
124620: LD_INT 81
124622: PUSH
124623: LD_VAR 0 4
124627: PUSH
124628: LD_VAR 0 7
124632: ARRAY
124633: PPUSH
124634: CALL_OW 255
124638: PUSH
124639: EMPTY
124640: LIST
124641: LIST
124642: PPUSH
124643: CALL_OW 69
124647: ST_TO_ADDR
// if not tmp then
124648: LD_VAR 0 14
124652: NOT
124653: IFFALSE 124657
// continue ;
124655: GO 123156
// if f_ignore_area then
124657: LD_VAR 0 17
124661: IFFALSE 124749
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
124663: LD_ADDR_VAR 0 15
124667: PUSH
124668: LD_VAR 0 14
124672: PPUSH
124673: LD_INT 3
124675: PUSH
124676: LD_INT 92
124678: PUSH
124679: LD_VAR 0 17
124683: PUSH
124684: LD_INT 1
124686: ARRAY
124687: PUSH
124688: LD_VAR 0 17
124692: PUSH
124693: LD_INT 2
124695: ARRAY
124696: PUSH
124697: LD_VAR 0 17
124701: PUSH
124702: LD_INT 3
124704: ARRAY
124705: PUSH
124706: EMPTY
124707: LIST
124708: LIST
124709: LIST
124710: LIST
124711: PUSH
124712: EMPTY
124713: LIST
124714: LIST
124715: PPUSH
124716: CALL_OW 72
124720: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
124721: LD_VAR 0 14
124725: PUSH
124726: LD_VAR 0 15
124730: DIFF
124731: IFFALSE 124749
// tmp := tmp diff tmp2 ;
124733: LD_ADDR_VAR 0 14
124737: PUSH
124738: LD_VAR 0 14
124742: PUSH
124743: LD_VAR 0 15
124747: DIFF
124748: ST_TO_ADDR
// end ; if not f_murder then
124749: LD_VAR 0 20
124753: NOT
124754: IFFALSE 124812
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
124756: LD_ADDR_VAR 0 15
124760: PUSH
124761: LD_VAR 0 14
124765: PPUSH
124766: LD_INT 3
124768: PUSH
124769: LD_INT 50
124771: PUSH
124772: EMPTY
124773: LIST
124774: PUSH
124775: EMPTY
124776: LIST
124777: LIST
124778: PPUSH
124779: CALL_OW 72
124783: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
124784: LD_VAR 0 14
124788: PUSH
124789: LD_VAR 0 15
124793: DIFF
124794: IFFALSE 124812
// tmp := tmp diff tmp2 ;
124796: LD_ADDR_VAR 0 14
124800: PUSH
124801: LD_VAR 0 14
124805: PUSH
124806: LD_VAR 0 15
124810: DIFF
124811: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
124812: LD_ADDR_VAR 0 14
124816: PUSH
124817: LD_VAR 0 4
124821: PUSH
124822: LD_VAR 0 7
124826: ARRAY
124827: PPUSH
124828: LD_VAR 0 14
124832: PPUSH
124833: LD_INT 1
124835: PPUSH
124836: LD_INT 1
124838: PPUSH
124839: CALL 71298 0 4
124843: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
124844: LD_VAR 0 4
124848: PUSH
124849: LD_VAR 0 7
124853: ARRAY
124854: PPUSH
124855: CALL_OW 257
124859: PUSH
124860: LD_INT 1
124862: EQUAL
124863: IFFALSE 125311
// begin if WantPlant ( group [ i ] ) then
124865: LD_VAR 0 4
124869: PUSH
124870: LD_VAR 0 7
124874: ARRAY
124875: PPUSH
124876: CALL 70799 0 1
124880: IFFALSE 124884
// continue ;
124882: GO 123156
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
124884: LD_VAR 0 18
124888: PUSH
124889: LD_VAR 0 4
124893: PUSH
124894: LD_VAR 0 7
124898: ARRAY
124899: PPUSH
124900: CALL_OW 310
124904: NOT
124905: AND
124906: PUSH
124907: LD_VAR 0 14
124911: PUSH
124912: LD_INT 1
124914: ARRAY
124915: PUSH
124916: LD_VAR 0 14
124920: PPUSH
124921: LD_INT 21
124923: PUSH
124924: LD_INT 2
124926: PUSH
124927: EMPTY
124928: LIST
124929: LIST
124930: PUSH
124931: LD_INT 58
124933: PUSH
124934: EMPTY
124935: LIST
124936: PUSH
124937: EMPTY
124938: LIST
124939: LIST
124940: PPUSH
124941: CALL_OW 72
124945: IN
124946: AND
124947: IFFALSE 124983
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
124949: LD_VAR 0 4
124953: PUSH
124954: LD_VAR 0 7
124958: ARRAY
124959: PPUSH
124960: LD_VAR 0 14
124964: PUSH
124965: LD_INT 1
124967: ARRAY
124968: PPUSH
124969: CALL_OW 120
// attacking := true ;
124973: LD_ADDR_VAR 0 29
124977: PUSH
124978: LD_INT 1
124980: ST_TO_ADDR
// continue ;
124981: GO 123156
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
124983: LD_VAR 0 26
124987: PUSH
124988: LD_VAR 0 4
124992: PUSH
124993: LD_VAR 0 7
124997: ARRAY
124998: PPUSH
124999: CALL_OW 257
125003: PUSH
125004: LD_INT 1
125006: EQUAL
125007: AND
125008: PUSH
125009: LD_VAR 0 4
125013: PUSH
125014: LD_VAR 0 7
125018: ARRAY
125019: PPUSH
125020: CALL_OW 256
125024: PUSH
125025: LD_INT 800
125027: LESS
125028: AND
125029: PUSH
125030: LD_VAR 0 4
125034: PUSH
125035: LD_VAR 0 7
125039: ARRAY
125040: PPUSH
125041: CALL_OW 318
125045: NOT
125046: AND
125047: IFFALSE 125064
// ComCrawl ( group [ i ] ) ;
125049: LD_VAR 0 4
125053: PUSH
125054: LD_VAR 0 7
125058: ARRAY
125059: PPUSH
125060: CALL_OW 137
// if f_mines then
125064: LD_VAR 0 21
125068: IFFALSE 125311
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
125070: LD_VAR 0 14
125074: PUSH
125075: LD_INT 1
125077: ARRAY
125078: PPUSH
125079: CALL_OW 247
125083: PUSH
125084: LD_INT 3
125086: EQUAL
125087: PUSH
125088: LD_VAR 0 14
125092: PUSH
125093: LD_INT 1
125095: ARRAY
125096: PUSH
125097: LD_VAR 0 27
125101: IN
125102: NOT
125103: AND
125104: IFFALSE 125311
// begin x := GetX ( tmp [ 1 ] ) ;
125106: LD_ADDR_VAR 0 10
125110: PUSH
125111: LD_VAR 0 14
125115: PUSH
125116: LD_INT 1
125118: ARRAY
125119: PPUSH
125120: CALL_OW 250
125124: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
125125: LD_ADDR_VAR 0 11
125129: PUSH
125130: LD_VAR 0 14
125134: PUSH
125135: LD_INT 1
125137: ARRAY
125138: PPUSH
125139: CALL_OW 251
125143: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
125144: LD_ADDR_VAR 0 12
125148: PUSH
125149: LD_VAR 0 4
125153: PUSH
125154: LD_VAR 0 7
125158: ARRAY
125159: PPUSH
125160: CALL 98448 0 1
125164: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
125165: LD_VAR 0 4
125169: PUSH
125170: LD_VAR 0 7
125174: ARRAY
125175: PPUSH
125176: LD_VAR 0 10
125180: PPUSH
125181: LD_VAR 0 11
125185: PPUSH
125186: LD_VAR 0 14
125190: PUSH
125191: LD_INT 1
125193: ARRAY
125194: PPUSH
125195: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
125199: LD_VAR 0 4
125203: PUSH
125204: LD_VAR 0 7
125208: ARRAY
125209: PPUSH
125210: LD_VAR 0 10
125214: PPUSH
125215: LD_VAR 0 12
125219: PPUSH
125220: LD_INT 7
125222: PPUSH
125223: CALL_OW 272
125227: PPUSH
125228: LD_VAR 0 11
125232: PPUSH
125233: LD_VAR 0 12
125237: PPUSH
125238: LD_INT 7
125240: PPUSH
125241: CALL_OW 273
125245: PPUSH
125246: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
125250: LD_VAR 0 4
125254: PUSH
125255: LD_VAR 0 7
125259: ARRAY
125260: PPUSH
125261: LD_INT 71
125263: PPUSH
125264: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
125268: LD_ADDR_VAR 0 27
125272: PUSH
125273: LD_VAR 0 27
125277: PPUSH
125278: LD_VAR 0 27
125282: PUSH
125283: LD_INT 1
125285: PLUS
125286: PPUSH
125287: LD_VAR 0 14
125291: PUSH
125292: LD_INT 1
125294: ARRAY
125295: PPUSH
125296: CALL_OW 1
125300: ST_TO_ADDR
// attacking := true ;
125301: LD_ADDR_VAR 0 29
125305: PUSH
125306: LD_INT 1
125308: ST_TO_ADDR
// continue ;
125309: GO 123156
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
125311: LD_VAR 0 4
125315: PUSH
125316: LD_VAR 0 7
125320: ARRAY
125321: PPUSH
125322: CALL_OW 257
125326: PUSH
125327: LD_INT 17
125329: EQUAL
125330: PUSH
125331: LD_VAR 0 4
125335: PUSH
125336: LD_VAR 0 7
125340: ARRAY
125341: PPUSH
125342: CALL_OW 110
125346: PUSH
125347: LD_INT 71
125349: EQUAL
125350: NOT
125351: AND
125352: IFFALSE 125498
// begin attacking := false ;
125354: LD_ADDR_VAR 0 29
125358: PUSH
125359: LD_INT 0
125361: ST_TO_ADDR
// k := 5 ;
125362: LD_ADDR_VAR 0 9
125366: PUSH
125367: LD_INT 5
125369: ST_TO_ADDR
// if tmp < k then
125370: LD_VAR 0 14
125374: PUSH
125375: LD_VAR 0 9
125379: LESS
125380: IFFALSE 125392
// k := tmp ;
125382: LD_ADDR_VAR 0 9
125386: PUSH
125387: LD_VAR 0 14
125391: ST_TO_ADDR
// for j = 1 to k do
125392: LD_ADDR_VAR 0 8
125396: PUSH
125397: DOUBLE
125398: LD_INT 1
125400: DEC
125401: ST_TO_ADDR
125402: LD_VAR 0 9
125406: PUSH
125407: FOR_TO
125408: IFFALSE 125496
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
125410: LD_VAR 0 14
125414: PUSH
125415: LD_VAR 0 8
125419: ARRAY
125420: PUSH
125421: LD_VAR 0 14
125425: PPUSH
125426: LD_INT 58
125428: PUSH
125429: EMPTY
125430: LIST
125431: PPUSH
125432: CALL_OW 72
125436: IN
125437: NOT
125438: IFFALSE 125494
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
125440: LD_VAR 0 4
125444: PUSH
125445: LD_VAR 0 7
125449: ARRAY
125450: PPUSH
125451: LD_VAR 0 14
125455: PUSH
125456: LD_VAR 0 8
125460: ARRAY
125461: PPUSH
125462: CALL_OW 115
// attacking := true ;
125466: LD_ADDR_VAR 0 29
125470: PUSH
125471: LD_INT 1
125473: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
125474: LD_VAR 0 4
125478: PUSH
125479: LD_VAR 0 7
125483: ARRAY
125484: PPUSH
125485: LD_INT 71
125487: PPUSH
125488: CALL_OW 109
// continue ;
125492: GO 125407
// end ; end ;
125494: GO 125407
125496: POP
125497: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
125498: LD_VAR 0 4
125502: PUSH
125503: LD_VAR 0 7
125507: ARRAY
125508: PPUSH
125509: CALL_OW 257
125513: PUSH
125514: LD_INT 8
125516: EQUAL
125517: PUSH
125518: LD_VAR 0 4
125522: PUSH
125523: LD_VAR 0 7
125527: ARRAY
125528: PPUSH
125529: CALL_OW 264
125533: PUSH
125534: LD_INT 28
125536: PUSH
125537: LD_INT 45
125539: PUSH
125540: LD_INT 7
125542: PUSH
125543: LD_INT 47
125545: PUSH
125546: EMPTY
125547: LIST
125548: LIST
125549: LIST
125550: LIST
125551: IN
125552: OR
125553: IFFALSE 125809
// begin attacking := false ;
125555: LD_ADDR_VAR 0 29
125559: PUSH
125560: LD_INT 0
125562: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
125563: LD_VAR 0 14
125567: PUSH
125568: LD_INT 1
125570: ARRAY
125571: PPUSH
125572: CALL_OW 266
125576: PUSH
125577: LD_INT 32
125579: PUSH
125580: LD_INT 31
125582: PUSH
125583: LD_INT 33
125585: PUSH
125586: LD_INT 4
125588: PUSH
125589: LD_INT 5
125591: PUSH
125592: EMPTY
125593: LIST
125594: LIST
125595: LIST
125596: LIST
125597: LIST
125598: IN
125599: IFFALSE 125785
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
125601: LD_ADDR_VAR 0 9
125605: PUSH
125606: LD_VAR 0 14
125610: PUSH
125611: LD_INT 1
125613: ARRAY
125614: PPUSH
125615: CALL_OW 266
125619: PPUSH
125620: LD_VAR 0 14
125624: PUSH
125625: LD_INT 1
125627: ARRAY
125628: PPUSH
125629: CALL_OW 250
125633: PPUSH
125634: LD_VAR 0 14
125638: PUSH
125639: LD_INT 1
125641: ARRAY
125642: PPUSH
125643: CALL_OW 251
125647: PPUSH
125648: LD_VAR 0 14
125652: PUSH
125653: LD_INT 1
125655: ARRAY
125656: PPUSH
125657: CALL_OW 254
125661: PPUSH
125662: LD_VAR 0 14
125666: PUSH
125667: LD_INT 1
125669: ARRAY
125670: PPUSH
125671: CALL_OW 248
125675: PPUSH
125676: LD_INT 0
125678: PPUSH
125679: CALL 79818 0 6
125683: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
125684: LD_ADDR_VAR 0 8
125688: PUSH
125689: LD_VAR 0 4
125693: PUSH
125694: LD_VAR 0 7
125698: ARRAY
125699: PPUSH
125700: LD_VAR 0 9
125704: PPUSH
125705: CALL 98488 0 2
125709: ST_TO_ADDR
// if j then
125710: LD_VAR 0 8
125714: IFFALSE 125783
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
125716: LD_VAR 0 8
125720: PUSH
125721: LD_INT 1
125723: ARRAY
125724: PPUSH
125725: LD_VAR 0 8
125729: PUSH
125730: LD_INT 2
125732: ARRAY
125733: PPUSH
125734: CALL_OW 488
125738: IFFALSE 125783
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
125740: LD_VAR 0 4
125744: PUSH
125745: LD_VAR 0 7
125749: ARRAY
125750: PPUSH
125751: LD_VAR 0 8
125755: PUSH
125756: LD_INT 1
125758: ARRAY
125759: PPUSH
125760: LD_VAR 0 8
125764: PUSH
125765: LD_INT 2
125767: ARRAY
125768: PPUSH
125769: CALL_OW 116
// attacking := true ;
125773: LD_ADDR_VAR 0 29
125777: PUSH
125778: LD_INT 1
125780: ST_TO_ADDR
// continue ;
125781: GO 123156
// end ; end else
125783: GO 125809
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125785: LD_VAR 0 4
125789: PUSH
125790: LD_VAR 0 7
125794: ARRAY
125795: PPUSH
125796: LD_VAR 0 14
125800: PUSH
125801: LD_INT 1
125803: ARRAY
125804: PPUSH
125805: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
125809: LD_VAR 0 4
125813: PUSH
125814: LD_VAR 0 7
125818: ARRAY
125819: PPUSH
125820: CALL_OW 265
125824: PUSH
125825: LD_INT 11
125827: EQUAL
125828: IFFALSE 126106
// begin k := 10 ;
125830: LD_ADDR_VAR 0 9
125834: PUSH
125835: LD_INT 10
125837: ST_TO_ADDR
// x := 0 ;
125838: LD_ADDR_VAR 0 10
125842: PUSH
125843: LD_INT 0
125845: ST_TO_ADDR
// if tmp < k then
125846: LD_VAR 0 14
125850: PUSH
125851: LD_VAR 0 9
125855: LESS
125856: IFFALSE 125868
// k := tmp ;
125858: LD_ADDR_VAR 0 9
125862: PUSH
125863: LD_VAR 0 14
125867: ST_TO_ADDR
// for j = k downto 1 do
125868: LD_ADDR_VAR 0 8
125872: PUSH
125873: DOUBLE
125874: LD_VAR 0 9
125878: INC
125879: ST_TO_ADDR
125880: LD_INT 1
125882: PUSH
125883: FOR_DOWNTO
125884: IFFALSE 125959
// begin if GetType ( tmp [ j ] ) = unit_human then
125886: LD_VAR 0 14
125890: PUSH
125891: LD_VAR 0 8
125895: ARRAY
125896: PPUSH
125897: CALL_OW 247
125901: PUSH
125902: LD_INT 1
125904: EQUAL
125905: IFFALSE 125957
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
125907: LD_VAR 0 4
125911: PUSH
125912: LD_VAR 0 7
125916: ARRAY
125917: PPUSH
125918: LD_VAR 0 14
125922: PUSH
125923: LD_VAR 0 8
125927: ARRAY
125928: PPUSH
125929: CALL 98759 0 2
// x := tmp [ j ] ;
125933: LD_ADDR_VAR 0 10
125937: PUSH
125938: LD_VAR 0 14
125942: PUSH
125943: LD_VAR 0 8
125947: ARRAY
125948: ST_TO_ADDR
// attacking := true ;
125949: LD_ADDR_VAR 0 29
125953: PUSH
125954: LD_INT 1
125956: ST_TO_ADDR
// end ; end ;
125957: GO 125883
125959: POP
125960: POP
// if not x then
125961: LD_VAR 0 10
125965: NOT
125966: IFFALSE 126106
// begin attacking := true ;
125968: LD_ADDR_VAR 0 29
125972: PUSH
125973: LD_INT 1
125975: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
125976: LD_VAR 0 4
125980: PUSH
125981: LD_VAR 0 7
125985: ARRAY
125986: PPUSH
125987: CALL_OW 250
125991: PPUSH
125992: LD_VAR 0 4
125996: PUSH
125997: LD_VAR 0 7
126001: ARRAY
126002: PPUSH
126003: CALL_OW 251
126007: PPUSH
126008: CALL_OW 546
126012: PUSH
126013: LD_INT 2
126015: ARRAY
126016: PUSH
126017: LD_VAR 0 14
126021: PUSH
126022: LD_INT 1
126024: ARRAY
126025: PPUSH
126026: CALL_OW 250
126030: PPUSH
126031: LD_VAR 0 14
126035: PUSH
126036: LD_INT 1
126038: ARRAY
126039: PPUSH
126040: CALL_OW 251
126044: PPUSH
126045: CALL_OW 546
126049: PUSH
126050: LD_INT 2
126052: ARRAY
126053: EQUAL
126054: IFFALSE 126082
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
126056: LD_VAR 0 4
126060: PUSH
126061: LD_VAR 0 7
126065: ARRAY
126066: PPUSH
126067: LD_VAR 0 14
126071: PUSH
126072: LD_INT 1
126074: ARRAY
126075: PPUSH
126076: CALL 98759 0 2
126080: GO 126106
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
126082: LD_VAR 0 4
126086: PUSH
126087: LD_VAR 0 7
126091: ARRAY
126092: PPUSH
126093: LD_VAR 0 14
126097: PUSH
126098: LD_INT 1
126100: ARRAY
126101: PPUSH
126102: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
126106: LD_VAR 0 4
126110: PUSH
126111: LD_VAR 0 7
126115: ARRAY
126116: PPUSH
126117: CALL_OW 264
126121: PUSH
126122: LD_INT 29
126124: EQUAL
126125: IFFALSE 126491
// begin if WantsToAttack ( group [ i ] ) in bombed then
126127: LD_VAR 0 4
126131: PUSH
126132: LD_VAR 0 7
126136: ARRAY
126137: PPUSH
126138: CALL_OW 319
126142: PUSH
126143: LD_VAR 0 28
126147: IN
126148: IFFALSE 126152
// continue ;
126150: GO 123156
// k := 8 ;
126152: LD_ADDR_VAR 0 9
126156: PUSH
126157: LD_INT 8
126159: ST_TO_ADDR
// x := 0 ;
126160: LD_ADDR_VAR 0 10
126164: PUSH
126165: LD_INT 0
126167: ST_TO_ADDR
// if tmp < k then
126168: LD_VAR 0 14
126172: PUSH
126173: LD_VAR 0 9
126177: LESS
126178: IFFALSE 126190
// k := tmp ;
126180: LD_ADDR_VAR 0 9
126184: PUSH
126185: LD_VAR 0 14
126189: ST_TO_ADDR
// for j = 1 to k do
126190: LD_ADDR_VAR 0 8
126194: PUSH
126195: DOUBLE
126196: LD_INT 1
126198: DEC
126199: ST_TO_ADDR
126200: LD_VAR 0 9
126204: PUSH
126205: FOR_TO
126206: IFFALSE 126338
// begin if GetType ( tmp [ j ] ) = unit_building then
126208: LD_VAR 0 14
126212: PUSH
126213: LD_VAR 0 8
126217: ARRAY
126218: PPUSH
126219: CALL_OW 247
126223: PUSH
126224: LD_INT 3
126226: EQUAL
126227: IFFALSE 126336
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
126229: LD_VAR 0 14
126233: PUSH
126234: LD_VAR 0 8
126238: ARRAY
126239: PUSH
126240: LD_VAR 0 28
126244: IN
126245: NOT
126246: PUSH
126247: LD_VAR 0 14
126251: PUSH
126252: LD_VAR 0 8
126256: ARRAY
126257: PPUSH
126258: CALL_OW 313
126262: AND
126263: IFFALSE 126336
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
126265: LD_VAR 0 4
126269: PUSH
126270: LD_VAR 0 7
126274: ARRAY
126275: PPUSH
126276: LD_VAR 0 14
126280: PUSH
126281: LD_VAR 0 8
126285: ARRAY
126286: PPUSH
126287: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
126291: LD_ADDR_VAR 0 28
126295: PUSH
126296: LD_VAR 0 28
126300: PPUSH
126301: LD_VAR 0 28
126305: PUSH
126306: LD_INT 1
126308: PLUS
126309: PPUSH
126310: LD_VAR 0 14
126314: PUSH
126315: LD_VAR 0 8
126319: ARRAY
126320: PPUSH
126321: CALL_OW 1
126325: ST_TO_ADDR
// attacking := true ;
126326: LD_ADDR_VAR 0 29
126330: PUSH
126331: LD_INT 1
126333: ST_TO_ADDR
// break ;
126334: GO 126338
// end ; end ;
126336: GO 126205
126338: POP
126339: POP
// if not attacking and f_attack_depot then
126340: LD_VAR 0 29
126344: NOT
126345: PUSH
126346: LD_VAR 0 25
126350: AND
126351: IFFALSE 126446
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
126353: LD_ADDR_VAR 0 13
126357: PUSH
126358: LD_VAR 0 14
126362: PPUSH
126363: LD_INT 2
126365: PUSH
126366: LD_INT 30
126368: PUSH
126369: LD_INT 0
126371: PUSH
126372: EMPTY
126373: LIST
126374: LIST
126375: PUSH
126376: LD_INT 30
126378: PUSH
126379: LD_INT 1
126381: PUSH
126382: EMPTY
126383: LIST
126384: LIST
126385: PUSH
126386: EMPTY
126387: LIST
126388: LIST
126389: LIST
126390: PPUSH
126391: CALL_OW 72
126395: ST_TO_ADDR
// if z then
126396: LD_VAR 0 13
126400: IFFALSE 126446
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
126402: LD_VAR 0 4
126406: PUSH
126407: LD_VAR 0 7
126411: ARRAY
126412: PPUSH
126413: LD_VAR 0 13
126417: PPUSH
126418: LD_VAR 0 4
126422: PUSH
126423: LD_VAR 0 7
126427: ARRAY
126428: PPUSH
126429: CALL_OW 74
126433: PPUSH
126434: CALL_OW 115
// attacking := true ;
126438: LD_ADDR_VAR 0 29
126442: PUSH
126443: LD_INT 1
126445: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
126446: LD_VAR 0 4
126450: PUSH
126451: LD_VAR 0 7
126455: ARRAY
126456: PPUSH
126457: CALL_OW 256
126461: PUSH
126462: LD_INT 500
126464: LESS
126465: IFFALSE 126491
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
126467: LD_VAR 0 4
126471: PUSH
126472: LD_VAR 0 7
126476: ARRAY
126477: PPUSH
126478: LD_VAR 0 14
126482: PUSH
126483: LD_INT 1
126485: ARRAY
126486: PPUSH
126487: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
126491: LD_VAR 0 4
126495: PUSH
126496: LD_VAR 0 7
126500: ARRAY
126501: PPUSH
126502: CALL_OW 264
126506: PUSH
126507: LD_INT 49
126509: EQUAL
126510: IFFALSE 126631
// begin if not HasTask ( group [ i ] ) then
126512: LD_VAR 0 4
126516: PUSH
126517: LD_VAR 0 7
126521: ARRAY
126522: PPUSH
126523: CALL_OW 314
126527: NOT
126528: IFFALSE 126631
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
126530: LD_ADDR_VAR 0 9
126534: PUSH
126535: LD_INT 81
126537: PUSH
126538: LD_VAR 0 4
126542: PUSH
126543: LD_VAR 0 7
126547: ARRAY
126548: PPUSH
126549: CALL_OW 255
126553: PUSH
126554: EMPTY
126555: LIST
126556: LIST
126557: PPUSH
126558: CALL_OW 69
126562: PPUSH
126563: LD_VAR 0 4
126567: PUSH
126568: LD_VAR 0 7
126572: ARRAY
126573: PPUSH
126574: CALL_OW 74
126578: ST_TO_ADDR
// if k then
126579: LD_VAR 0 9
126583: IFFALSE 126631
// if GetDistUnits ( group [ i ] , k ) > 10 then
126585: LD_VAR 0 4
126589: PUSH
126590: LD_VAR 0 7
126594: ARRAY
126595: PPUSH
126596: LD_VAR 0 9
126600: PPUSH
126601: CALL_OW 296
126605: PUSH
126606: LD_INT 10
126608: GREATER
126609: IFFALSE 126631
// ComMoveUnit ( group [ i ] , k ) ;
126611: LD_VAR 0 4
126615: PUSH
126616: LD_VAR 0 7
126620: ARRAY
126621: PPUSH
126622: LD_VAR 0 9
126626: PPUSH
126627: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
126631: LD_VAR 0 4
126635: PUSH
126636: LD_VAR 0 7
126640: ARRAY
126641: PPUSH
126642: CALL_OW 256
126646: PUSH
126647: LD_INT 250
126649: LESS
126650: PUSH
126651: LD_VAR 0 4
126655: PUSH
126656: LD_VAR 0 7
126660: ARRAY
126661: PUSH
126662: LD_INT 21
126664: PUSH
126665: LD_INT 2
126667: PUSH
126668: EMPTY
126669: LIST
126670: LIST
126671: PUSH
126672: LD_INT 23
126674: PUSH
126675: LD_INT 2
126677: PUSH
126678: EMPTY
126679: LIST
126680: LIST
126681: PUSH
126682: EMPTY
126683: LIST
126684: LIST
126685: PPUSH
126686: CALL_OW 69
126690: IN
126691: AND
126692: IFFALSE 126817
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
126694: LD_ADDR_VAR 0 9
126698: PUSH
126699: LD_OWVAR 3
126703: PUSH
126704: LD_VAR 0 4
126708: PUSH
126709: LD_VAR 0 7
126713: ARRAY
126714: DIFF
126715: PPUSH
126716: LD_VAR 0 4
126720: PUSH
126721: LD_VAR 0 7
126725: ARRAY
126726: PPUSH
126727: CALL_OW 74
126731: ST_TO_ADDR
// if not k then
126732: LD_VAR 0 9
126736: NOT
126737: IFFALSE 126741
// continue ;
126739: GO 123156
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
126741: LD_VAR 0 9
126745: PUSH
126746: LD_INT 81
126748: PUSH
126749: LD_VAR 0 4
126753: PUSH
126754: LD_VAR 0 7
126758: ARRAY
126759: PPUSH
126760: CALL_OW 255
126764: PUSH
126765: EMPTY
126766: LIST
126767: LIST
126768: PPUSH
126769: CALL_OW 69
126773: IN
126774: PUSH
126775: LD_VAR 0 9
126779: PPUSH
126780: LD_VAR 0 4
126784: PUSH
126785: LD_VAR 0 7
126789: ARRAY
126790: PPUSH
126791: CALL_OW 296
126795: PUSH
126796: LD_INT 5
126798: LESS
126799: AND
126800: IFFALSE 126817
// ComAutodestruct ( group [ i ] ) ;
126802: LD_VAR 0 4
126806: PUSH
126807: LD_VAR 0 7
126811: ARRAY
126812: PPUSH
126813: CALL 98657 0 1
// end ; if f_attack_depot then
126817: LD_VAR 0 25
126821: IFFALSE 126933
// begin k := 6 ;
126823: LD_ADDR_VAR 0 9
126827: PUSH
126828: LD_INT 6
126830: ST_TO_ADDR
// if tmp < k then
126831: LD_VAR 0 14
126835: PUSH
126836: LD_VAR 0 9
126840: LESS
126841: IFFALSE 126853
// k := tmp ;
126843: LD_ADDR_VAR 0 9
126847: PUSH
126848: LD_VAR 0 14
126852: ST_TO_ADDR
// for j = 1 to k do
126853: LD_ADDR_VAR 0 8
126857: PUSH
126858: DOUBLE
126859: LD_INT 1
126861: DEC
126862: ST_TO_ADDR
126863: LD_VAR 0 9
126867: PUSH
126868: FOR_TO
126869: IFFALSE 126931
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
126871: LD_VAR 0 8
126875: PPUSH
126876: CALL_OW 266
126880: PUSH
126881: LD_INT 0
126883: PUSH
126884: LD_INT 1
126886: PUSH
126887: EMPTY
126888: LIST
126889: LIST
126890: IN
126891: IFFALSE 126929
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
126893: LD_VAR 0 4
126897: PUSH
126898: LD_VAR 0 7
126902: ARRAY
126903: PPUSH
126904: LD_VAR 0 14
126908: PUSH
126909: LD_VAR 0 8
126913: ARRAY
126914: PPUSH
126915: CALL_OW 115
// attacking := true ;
126919: LD_ADDR_VAR 0 29
126923: PUSH
126924: LD_INT 1
126926: ST_TO_ADDR
// break ;
126927: GO 126931
// end ;
126929: GO 126868
126931: POP
126932: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
126933: LD_VAR 0 4
126937: PUSH
126938: LD_VAR 0 7
126942: ARRAY
126943: PPUSH
126944: CALL_OW 302
126948: PUSH
126949: LD_VAR 0 29
126953: NOT
126954: AND
126955: IFFALSE 127277
// begin if GetTag ( group [ i ] ) = 71 then
126957: LD_VAR 0 4
126961: PUSH
126962: LD_VAR 0 7
126966: ARRAY
126967: PPUSH
126968: CALL_OW 110
126972: PUSH
126973: LD_INT 71
126975: EQUAL
126976: IFFALSE 127017
// begin if HasTask ( group [ i ] ) then
126978: LD_VAR 0 4
126982: PUSH
126983: LD_VAR 0 7
126987: ARRAY
126988: PPUSH
126989: CALL_OW 314
126993: IFFALSE 126999
// continue else
126995: GO 123156
126997: GO 127017
// SetTag ( group [ i ] , 0 ) ;
126999: LD_VAR 0 4
127003: PUSH
127004: LD_VAR 0 7
127008: ARRAY
127009: PPUSH
127010: LD_INT 0
127012: PPUSH
127013: CALL_OW 109
// end ; k := 8 ;
127017: LD_ADDR_VAR 0 9
127021: PUSH
127022: LD_INT 8
127024: ST_TO_ADDR
// x := 0 ;
127025: LD_ADDR_VAR 0 10
127029: PUSH
127030: LD_INT 0
127032: ST_TO_ADDR
// if tmp < k then
127033: LD_VAR 0 14
127037: PUSH
127038: LD_VAR 0 9
127042: LESS
127043: IFFALSE 127055
// k := tmp ;
127045: LD_ADDR_VAR 0 9
127049: PUSH
127050: LD_VAR 0 14
127054: ST_TO_ADDR
// for j = 1 to k do
127055: LD_ADDR_VAR 0 8
127059: PUSH
127060: DOUBLE
127061: LD_INT 1
127063: DEC
127064: ST_TO_ADDR
127065: LD_VAR 0 9
127069: PUSH
127070: FOR_TO
127071: IFFALSE 127169
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
127073: LD_VAR 0 14
127077: PUSH
127078: LD_VAR 0 8
127082: ARRAY
127083: PPUSH
127084: CALL_OW 247
127088: PUSH
127089: LD_INT 1
127091: EQUAL
127092: PUSH
127093: LD_VAR 0 14
127097: PUSH
127098: LD_VAR 0 8
127102: ARRAY
127103: PPUSH
127104: CALL_OW 256
127108: PUSH
127109: LD_INT 250
127111: LESS
127112: PUSH
127113: LD_VAR 0 20
127117: AND
127118: PUSH
127119: LD_VAR 0 20
127123: NOT
127124: PUSH
127125: LD_VAR 0 14
127129: PUSH
127130: LD_VAR 0 8
127134: ARRAY
127135: PPUSH
127136: CALL_OW 256
127140: PUSH
127141: LD_INT 250
127143: GREATEREQUAL
127144: AND
127145: OR
127146: AND
127147: IFFALSE 127167
// begin x := tmp [ j ] ;
127149: LD_ADDR_VAR 0 10
127153: PUSH
127154: LD_VAR 0 14
127158: PUSH
127159: LD_VAR 0 8
127163: ARRAY
127164: ST_TO_ADDR
// break ;
127165: GO 127169
// end ;
127167: GO 127070
127169: POP
127170: POP
// if x then
127171: LD_VAR 0 10
127175: IFFALSE 127199
// ComAttackUnit ( group [ i ] , x ) else
127177: LD_VAR 0 4
127181: PUSH
127182: LD_VAR 0 7
127186: ARRAY
127187: PPUSH
127188: LD_VAR 0 10
127192: PPUSH
127193: CALL_OW 115
127197: GO 127223
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
127199: LD_VAR 0 4
127203: PUSH
127204: LD_VAR 0 7
127208: ARRAY
127209: PPUSH
127210: LD_VAR 0 14
127214: PUSH
127215: LD_INT 1
127217: ARRAY
127218: PPUSH
127219: CALL_OW 115
// if not HasTask ( group [ i ] ) then
127223: LD_VAR 0 4
127227: PUSH
127228: LD_VAR 0 7
127232: ARRAY
127233: PPUSH
127234: CALL_OW 314
127238: NOT
127239: IFFALSE 127277
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
127241: LD_VAR 0 4
127245: PUSH
127246: LD_VAR 0 7
127250: ARRAY
127251: PPUSH
127252: LD_VAR 0 14
127256: PPUSH
127257: LD_VAR 0 4
127261: PUSH
127262: LD_VAR 0 7
127266: ARRAY
127267: PPUSH
127268: CALL_OW 74
127272: PPUSH
127273: CALL_OW 115
// end ; end ; end ;
127277: GO 123156
127279: POP
127280: POP
// wait ( 0 0$2 ) ;
127281: LD_INT 70
127283: PPUSH
127284: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
127288: LD_VAR 0 4
127292: NOT
127293: PUSH
127294: LD_VAR 0 4
127298: PUSH
127299: EMPTY
127300: EQUAL
127301: OR
127302: PUSH
127303: LD_INT 81
127305: PUSH
127306: LD_VAR 0 35
127310: PUSH
127311: EMPTY
127312: LIST
127313: LIST
127314: PPUSH
127315: CALL_OW 69
127319: NOT
127320: OR
127321: IFFALSE 123141
// end ;
127323: LD_VAR 0 2
127327: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
127328: LD_INT 0
127330: PPUSH
127331: PPUSH
127332: PPUSH
127333: PPUSH
127334: PPUSH
127335: PPUSH
// if not base or not mc_bases [ base ] or not solds then
127336: LD_VAR 0 1
127340: NOT
127341: PUSH
127342: LD_EXP 116
127346: PUSH
127347: LD_VAR 0 1
127351: ARRAY
127352: NOT
127353: OR
127354: PUSH
127355: LD_VAR 0 2
127359: NOT
127360: OR
127361: IFFALSE 127365
// exit ;
127363: GO 127919
// side := mc_sides [ base ] ;
127365: LD_ADDR_VAR 0 6
127369: PUSH
127370: LD_EXP 142
127374: PUSH
127375: LD_VAR 0 1
127379: ARRAY
127380: ST_TO_ADDR
// if not side then
127381: LD_VAR 0 6
127385: NOT
127386: IFFALSE 127390
// exit ;
127388: GO 127919
// for i in solds do
127390: LD_ADDR_VAR 0 7
127394: PUSH
127395: LD_VAR 0 2
127399: PUSH
127400: FOR_IN
127401: IFFALSE 127462
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
127403: LD_VAR 0 7
127407: PPUSH
127408: CALL_OW 310
127412: PPUSH
127413: CALL_OW 266
127417: PUSH
127418: LD_INT 32
127420: PUSH
127421: LD_INT 31
127423: PUSH
127424: EMPTY
127425: LIST
127426: LIST
127427: IN
127428: IFFALSE 127448
// solds := solds diff i else
127430: LD_ADDR_VAR 0 2
127434: PUSH
127435: LD_VAR 0 2
127439: PUSH
127440: LD_VAR 0 7
127444: DIFF
127445: ST_TO_ADDR
127446: GO 127460
// SetTag ( i , 18 ) ;
127448: LD_VAR 0 7
127452: PPUSH
127453: LD_INT 18
127455: PPUSH
127456: CALL_OW 109
127460: GO 127400
127462: POP
127463: POP
// if not solds then
127464: LD_VAR 0 2
127468: NOT
127469: IFFALSE 127473
// exit ;
127471: GO 127919
// repeat wait ( 0 0$2 ) ;
127473: LD_INT 70
127475: PPUSH
127476: CALL_OW 67
// enemy := mc_scan [ base ] ;
127480: LD_ADDR_VAR 0 4
127484: PUSH
127485: LD_EXP 139
127489: PUSH
127490: LD_VAR 0 1
127494: ARRAY
127495: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
127496: LD_EXP 116
127500: PUSH
127501: LD_VAR 0 1
127505: ARRAY
127506: NOT
127507: PUSH
127508: LD_EXP 116
127512: PUSH
127513: LD_VAR 0 1
127517: ARRAY
127518: PUSH
127519: EMPTY
127520: EQUAL
127521: OR
127522: IFFALSE 127559
// begin for i in solds do
127524: LD_ADDR_VAR 0 7
127528: PUSH
127529: LD_VAR 0 2
127533: PUSH
127534: FOR_IN
127535: IFFALSE 127548
// ComStop ( i ) ;
127537: LD_VAR 0 7
127541: PPUSH
127542: CALL_OW 141
127546: GO 127534
127548: POP
127549: POP
// solds := [ ] ;
127550: LD_ADDR_VAR 0 2
127554: PUSH
127555: EMPTY
127556: ST_TO_ADDR
// exit ;
127557: GO 127919
// end ; for i in solds do
127559: LD_ADDR_VAR 0 7
127563: PUSH
127564: LD_VAR 0 2
127568: PUSH
127569: FOR_IN
127570: IFFALSE 127891
// begin if IsInUnit ( i ) then
127572: LD_VAR 0 7
127576: PPUSH
127577: CALL_OW 310
127581: IFFALSE 127592
// ComExitBuilding ( i ) ;
127583: LD_VAR 0 7
127587: PPUSH
127588: CALL_OW 122
// if GetLives ( i ) > 500 then
127592: LD_VAR 0 7
127596: PPUSH
127597: CALL_OW 256
127601: PUSH
127602: LD_INT 500
127604: GREATER
127605: IFFALSE 127658
// begin e := NearestUnitToUnit ( enemy , i ) ;
127607: LD_ADDR_VAR 0 5
127611: PUSH
127612: LD_VAR 0 4
127616: PPUSH
127617: LD_VAR 0 7
127621: PPUSH
127622: CALL_OW 74
127626: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
127627: LD_VAR 0 7
127631: PPUSH
127632: LD_VAR 0 5
127636: PPUSH
127637: CALL_OW 250
127641: PPUSH
127642: LD_VAR 0 5
127646: PPUSH
127647: CALL_OW 251
127651: PPUSH
127652: CALL_OW 114
// end else
127656: GO 127889
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
127658: LD_VAR 0 7
127662: PPUSH
127663: LD_EXP 116
127667: PUSH
127668: LD_VAR 0 1
127672: ARRAY
127673: PPUSH
127674: LD_INT 2
127676: PUSH
127677: LD_INT 30
127679: PUSH
127680: LD_INT 0
127682: PUSH
127683: EMPTY
127684: LIST
127685: LIST
127686: PUSH
127687: LD_INT 30
127689: PUSH
127690: LD_INT 1
127692: PUSH
127693: EMPTY
127694: LIST
127695: LIST
127696: PUSH
127697: LD_INT 30
127699: PUSH
127700: LD_INT 6
127702: PUSH
127703: EMPTY
127704: LIST
127705: LIST
127706: PUSH
127707: EMPTY
127708: LIST
127709: LIST
127710: LIST
127711: LIST
127712: PPUSH
127713: CALL_OW 72
127717: PPUSH
127718: LD_VAR 0 7
127722: PPUSH
127723: CALL_OW 74
127727: PPUSH
127728: CALL_OW 296
127732: PUSH
127733: LD_INT 10
127735: GREATER
127736: IFFALSE 127889
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
127738: LD_ADDR_VAR 0 8
127742: PUSH
127743: LD_EXP 116
127747: PUSH
127748: LD_VAR 0 1
127752: ARRAY
127753: PPUSH
127754: LD_INT 2
127756: PUSH
127757: LD_INT 30
127759: PUSH
127760: LD_INT 0
127762: PUSH
127763: EMPTY
127764: LIST
127765: LIST
127766: PUSH
127767: LD_INT 30
127769: PUSH
127770: LD_INT 1
127772: PUSH
127773: EMPTY
127774: LIST
127775: LIST
127776: PUSH
127777: LD_INT 30
127779: PUSH
127780: LD_INT 6
127782: PUSH
127783: EMPTY
127784: LIST
127785: LIST
127786: PUSH
127787: EMPTY
127788: LIST
127789: LIST
127790: LIST
127791: LIST
127792: PPUSH
127793: CALL_OW 72
127797: PPUSH
127798: LD_VAR 0 7
127802: PPUSH
127803: CALL_OW 74
127807: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
127808: LD_VAR 0 7
127812: PPUSH
127813: LD_VAR 0 8
127817: PPUSH
127818: CALL_OW 250
127822: PPUSH
127823: LD_INT 3
127825: PPUSH
127826: LD_INT 5
127828: PPUSH
127829: CALL_OW 272
127833: PPUSH
127834: LD_VAR 0 8
127838: PPUSH
127839: CALL_OW 251
127843: PPUSH
127844: LD_INT 3
127846: PPUSH
127847: LD_INT 5
127849: PPUSH
127850: CALL_OW 273
127854: PPUSH
127855: CALL_OW 111
// SetTag ( i , 0 ) ;
127859: LD_VAR 0 7
127863: PPUSH
127864: LD_INT 0
127866: PPUSH
127867: CALL_OW 109
// solds := solds diff i ;
127871: LD_ADDR_VAR 0 2
127875: PUSH
127876: LD_VAR 0 2
127880: PUSH
127881: LD_VAR 0 7
127885: DIFF
127886: ST_TO_ADDR
// continue ;
127887: GO 127569
// end ; end ;
127889: GO 127569
127891: POP
127892: POP
// until not solds or not enemy ;
127893: LD_VAR 0 2
127897: NOT
127898: PUSH
127899: LD_VAR 0 4
127903: NOT
127904: OR
127905: IFFALSE 127473
// MC_Reset ( base , 18 ) ;
127907: LD_VAR 0 1
127911: PPUSH
127912: LD_INT 18
127914: PPUSH
127915: CALL 39405 0 2
// end ;
127919: LD_VAR 0 3
127923: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
127924: LD_INT 0
127926: PPUSH
127927: PPUSH
127928: PPUSH
127929: PPUSH
127930: PPUSH
127931: PPUSH
127932: PPUSH
127933: PPUSH
127934: PPUSH
127935: PPUSH
127936: PPUSH
127937: PPUSH
127938: PPUSH
127939: PPUSH
127940: PPUSH
127941: PPUSH
127942: PPUSH
127943: PPUSH
127944: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
127945: LD_ADDR_VAR 0 12
127949: PUSH
127950: LD_EXP 116
127954: PUSH
127955: LD_VAR 0 1
127959: ARRAY
127960: PPUSH
127961: LD_INT 25
127963: PUSH
127964: LD_INT 3
127966: PUSH
127967: EMPTY
127968: LIST
127969: LIST
127970: PPUSH
127971: CALL_OW 72
127975: ST_TO_ADDR
// if mc_remote_driver [ base ] then
127976: LD_EXP 156
127980: PUSH
127981: LD_VAR 0 1
127985: ARRAY
127986: IFFALSE 128010
// mechs := mechs diff mc_remote_driver [ base ] ;
127988: LD_ADDR_VAR 0 12
127992: PUSH
127993: LD_VAR 0 12
127997: PUSH
127998: LD_EXP 156
128002: PUSH
128003: LD_VAR 0 1
128007: ARRAY
128008: DIFF
128009: ST_TO_ADDR
// for i in mechs do
128010: LD_ADDR_VAR 0 4
128014: PUSH
128015: LD_VAR 0 12
128019: PUSH
128020: FOR_IN
128021: IFFALSE 128056
// if GetTag ( i ) > 0 then
128023: LD_VAR 0 4
128027: PPUSH
128028: CALL_OW 110
128032: PUSH
128033: LD_INT 0
128035: GREATER
128036: IFFALSE 128054
// mechs := mechs diff i ;
128038: LD_ADDR_VAR 0 12
128042: PUSH
128043: LD_VAR 0 12
128047: PUSH
128048: LD_VAR 0 4
128052: DIFF
128053: ST_TO_ADDR
128054: GO 128020
128056: POP
128057: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
128058: LD_ADDR_VAR 0 8
128062: PUSH
128063: LD_EXP 116
128067: PUSH
128068: LD_VAR 0 1
128072: ARRAY
128073: PPUSH
128074: LD_INT 2
128076: PUSH
128077: LD_INT 25
128079: PUSH
128080: LD_INT 1
128082: PUSH
128083: EMPTY
128084: LIST
128085: LIST
128086: PUSH
128087: LD_INT 25
128089: PUSH
128090: LD_INT 5
128092: PUSH
128093: EMPTY
128094: LIST
128095: LIST
128096: PUSH
128097: LD_INT 25
128099: PUSH
128100: LD_INT 8
128102: PUSH
128103: EMPTY
128104: LIST
128105: LIST
128106: PUSH
128107: LD_INT 25
128109: PUSH
128110: LD_INT 9
128112: PUSH
128113: EMPTY
128114: LIST
128115: LIST
128116: PUSH
128117: EMPTY
128118: LIST
128119: LIST
128120: LIST
128121: LIST
128122: LIST
128123: PPUSH
128124: CALL_OW 72
128128: ST_TO_ADDR
// if not defenders and not solds then
128129: LD_VAR 0 2
128133: NOT
128134: PUSH
128135: LD_VAR 0 8
128139: NOT
128140: AND
128141: IFFALSE 128145
// exit ;
128143: GO 129915
// depot_under_attack := false ;
128145: LD_ADDR_VAR 0 16
128149: PUSH
128150: LD_INT 0
128152: ST_TO_ADDR
// sold_defenders := [ ] ;
128153: LD_ADDR_VAR 0 17
128157: PUSH
128158: EMPTY
128159: ST_TO_ADDR
// if mechs then
128160: LD_VAR 0 12
128164: IFFALSE 128317
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
128166: LD_ADDR_VAR 0 4
128170: PUSH
128171: LD_VAR 0 2
128175: PPUSH
128176: LD_INT 21
128178: PUSH
128179: LD_INT 2
128181: PUSH
128182: EMPTY
128183: LIST
128184: LIST
128185: PPUSH
128186: CALL_OW 72
128190: PUSH
128191: FOR_IN
128192: IFFALSE 128315
// begin if GetTag ( i ) <> 20 then
128194: LD_VAR 0 4
128198: PPUSH
128199: CALL_OW 110
128203: PUSH
128204: LD_INT 20
128206: NONEQUAL
128207: IFFALSE 128221
// SetTag ( i , 20 ) ;
128209: LD_VAR 0 4
128213: PPUSH
128214: LD_INT 20
128216: PPUSH
128217: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
128221: LD_VAR 0 4
128225: PPUSH
128226: CALL_OW 263
128230: PUSH
128231: LD_INT 1
128233: EQUAL
128234: PUSH
128235: LD_VAR 0 4
128239: PPUSH
128240: CALL_OW 311
128244: NOT
128245: AND
128246: IFFALSE 128313
// begin un := mechs [ 1 ] ;
128248: LD_ADDR_VAR 0 10
128252: PUSH
128253: LD_VAR 0 12
128257: PUSH
128258: LD_INT 1
128260: ARRAY
128261: ST_TO_ADDR
// ComExit ( un ) ;
128262: LD_VAR 0 10
128266: PPUSH
128267: CALL 103002 0 1
// AddComEnterUnit ( un , i ) ;
128271: LD_VAR 0 10
128275: PPUSH
128276: LD_VAR 0 4
128280: PPUSH
128281: CALL_OW 180
// SetTag ( un , 19 ) ;
128285: LD_VAR 0 10
128289: PPUSH
128290: LD_INT 19
128292: PPUSH
128293: CALL_OW 109
// mechs := mechs diff un ;
128297: LD_ADDR_VAR 0 12
128301: PUSH
128302: LD_VAR 0 12
128306: PUSH
128307: LD_VAR 0 10
128311: DIFF
128312: ST_TO_ADDR
// end ; end ;
128313: GO 128191
128315: POP
128316: POP
// if solds then
128317: LD_VAR 0 8
128321: IFFALSE 128380
// for i in solds do
128323: LD_ADDR_VAR 0 4
128327: PUSH
128328: LD_VAR 0 8
128332: PUSH
128333: FOR_IN
128334: IFFALSE 128378
// if not GetTag ( i ) then
128336: LD_VAR 0 4
128340: PPUSH
128341: CALL_OW 110
128345: NOT
128346: IFFALSE 128376
// begin defenders := defenders union i ;
128348: LD_ADDR_VAR 0 2
128352: PUSH
128353: LD_VAR 0 2
128357: PUSH
128358: LD_VAR 0 4
128362: UNION
128363: ST_TO_ADDR
// SetTag ( i , 18 ) ;
128364: LD_VAR 0 4
128368: PPUSH
128369: LD_INT 18
128371: PPUSH
128372: CALL_OW 109
// end ;
128376: GO 128333
128378: POP
128379: POP
// repeat wait ( 0 0$2 ) ;
128380: LD_INT 70
128382: PPUSH
128383: CALL_OW 67
// enemy := mc_scan [ base ] ;
128387: LD_ADDR_VAR 0 21
128391: PUSH
128392: LD_EXP 139
128396: PUSH
128397: LD_VAR 0 1
128401: ARRAY
128402: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
128403: LD_EXP 116
128407: PUSH
128408: LD_VAR 0 1
128412: ARRAY
128413: NOT
128414: PUSH
128415: LD_EXP 116
128419: PUSH
128420: LD_VAR 0 1
128424: ARRAY
128425: PUSH
128426: EMPTY
128427: EQUAL
128428: OR
128429: IFFALSE 128466
// begin for i in defenders do
128431: LD_ADDR_VAR 0 4
128435: PUSH
128436: LD_VAR 0 2
128440: PUSH
128441: FOR_IN
128442: IFFALSE 128455
// ComStop ( i ) ;
128444: LD_VAR 0 4
128448: PPUSH
128449: CALL_OW 141
128453: GO 128441
128455: POP
128456: POP
// defenders := [ ] ;
128457: LD_ADDR_VAR 0 2
128461: PUSH
128462: EMPTY
128463: ST_TO_ADDR
// exit ;
128464: GO 129915
// end ; for i in defenders do
128466: LD_ADDR_VAR 0 4
128470: PUSH
128471: LD_VAR 0 2
128475: PUSH
128476: FOR_IN
128477: IFFALSE 129375
// begin e := NearestUnitToUnit ( enemy , i ) ;
128479: LD_ADDR_VAR 0 13
128483: PUSH
128484: LD_VAR 0 21
128488: PPUSH
128489: LD_VAR 0 4
128493: PPUSH
128494: CALL_OW 74
128498: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
128499: LD_ADDR_VAR 0 7
128503: PUSH
128504: LD_EXP 116
128508: PUSH
128509: LD_VAR 0 1
128513: ARRAY
128514: PPUSH
128515: LD_INT 2
128517: PUSH
128518: LD_INT 30
128520: PUSH
128521: LD_INT 0
128523: PUSH
128524: EMPTY
128525: LIST
128526: LIST
128527: PUSH
128528: LD_INT 30
128530: PUSH
128531: LD_INT 1
128533: PUSH
128534: EMPTY
128535: LIST
128536: LIST
128537: PUSH
128538: EMPTY
128539: LIST
128540: LIST
128541: LIST
128542: PPUSH
128543: CALL_OW 72
128547: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
128548: LD_ADDR_VAR 0 16
128552: PUSH
128553: LD_VAR 0 7
128557: NOT
128558: PUSH
128559: LD_VAR 0 7
128563: PPUSH
128564: LD_INT 3
128566: PUSH
128567: LD_INT 24
128569: PUSH
128570: LD_INT 600
128572: PUSH
128573: EMPTY
128574: LIST
128575: LIST
128576: PUSH
128577: EMPTY
128578: LIST
128579: LIST
128580: PPUSH
128581: CALL_OW 72
128585: OR
128586: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
128587: LD_VAR 0 4
128591: PPUSH
128592: CALL_OW 247
128596: PUSH
128597: LD_INT 2
128599: DOUBLE
128600: EQUAL
128601: IFTRUE 128605
128603: GO 129001
128605: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
128606: LD_VAR 0 4
128610: PPUSH
128611: CALL_OW 256
128615: PUSH
128616: LD_INT 1000
128618: EQUAL
128619: PUSH
128620: LD_VAR 0 4
128624: PPUSH
128625: LD_VAR 0 13
128629: PPUSH
128630: CALL_OW 296
128634: PUSH
128635: LD_INT 40
128637: LESS
128638: PUSH
128639: LD_VAR 0 13
128643: PPUSH
128644: LD_EXP 141
128648: PUSH
128649: LD_VAR 0 1
128653: ARRAY
128654: PPUSH
128655: CALL_OW 308
128659: OR
128660: AND
128661: IFFALSE 128783
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
128663: LD_VAR 0 4
128667: PPUSH
128668: CALL_OW 262
128672: PUSH
128673: LD_INT 1
128675: EQUAL
128676: PUSH
128677: LD_VAR 0 4
128681: PPUSH
128682: CALL_OW 261
128686: PUSH
128687: LD_INT 30
128689: LESS
128690: AND
128691: PUSH
128692: LD_VAR 0 7
128696: AND
128697: IFFALSE 128767
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
128699: LD_VAR 0 4
128703: PPUSH
128704: LD_VAR 0 7
128708: PPUSH
128709: LD_VAR 0 4
128713: PPUSH
128714: CALL_OW 74
128718: PPUSH
128719: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
128723: LD_VAR 0 4
128727: PPUSH
128728: LD_VAR 0 7
128732: PPUSH
128733: LD_VAR 0 4
128737: PPUSH
128738: CALL_OW 74
128742: PPUSH
128743: CALL_OW 296
128747: PUSH
128748: LD_INT 6
128750: LESS
128751: IFFALSE 128765
// SetFuel ( i , 100 ) ;
128753: LD_VAR 0 4
128757: PPUSH
128758: LD_INT 100
128760: PPUSH
128761: CALL_OW 240
// end else
128765: GO 128781
// ComAttackUnit ( i , e ) ;
128767: LD_VAR 0 4
128771: PPUSH
128772: LD_VAR 0 13
128776: PPUSH
128777: CALL_OW 115
// end else
128781: GO 128884
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
128783: LD_VAR 0 13
128787: PPUSH
128788: LD_EXP 141
128792: PUSH
128793: LD_VAR 0 1
128797: ARRAY
128798: PPUSH
128799: CALL_OW 308
128803: NOT
128804: PUSH
128805: LD_VAR 0 4
128809: PPUSH
128810: LD_VAR 0 13
128814: PPUSH
128815: CALL_OW 296
128819: PUSH
128820: LD_INT 40
128822: GREATEREQUAL
128823: AND
128824: PUSH
128825: LD_VAR 0 4
128829: PPUSH
128830: CALL_OW 256
128834: PUSH
128835: LD_INT 650
128837: LESSEQUAL
128838: OR
128839: PUSH
128840: LD_VAR 0 4
128844: PPUSH
128845: LD_EXP 140
128849: PUSH
128850: LD_VAR 0 1
128854: ARRAY
128855: PPUSH
128856: CALL_OW 308
128860: NOT
128861: AND
128862: IFFALSE 128884
// ComMoveToArea ( i , mc_parking [ base ] ) ;
128864: LD_VAR 0 4
128868: PPUSH
128869: LD_EXP 140
128873: PUSH
128874: LD_VAR 0 1
128878: ARRAY
128879: PPUSH
128880: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
128884: LD_VAR 0 4
128888: PPUSH
128889: CALL_OW 256
128893: PUSH
128894: LD_INT 1000
128896: LESS
128897: PUSH
128898: LD_VAR 0 4
128902: PPUSH
128903: CALL_OW 263
128907: PUSH
128908: LD_INT 1
128910: EQUAL
128911: AND
128912: PUSH
128913: LD_VAR 0 4
128917: PPUSH
128918: CALL_OW 311
128922: AND
128923: PUSH
128924: LD_VAR 0 4
128928: PPUSH
128929: LD_EXP 140
128933: PUSH
128934: LD_VAR 0 1
128938: ARRAY
128939: PPUSH
128940: CALL_OW 308
128944: AND
128945: IFFALSE 128999
// begin mech := IsDrivenBy ( i ) ;
128947: LD_ADDR_VAR 0 9
128951: PUSH
128952: LD_VAR 0 4
128956: PPUSH
128957: CALL_OW 311
128961: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
128962: LD_VAR 0 9
128966: PPUSH
128967: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
128971: LD_VAR 0 9
128975: PPUSH
128976: LD_VAR 0 4
128980: PPUSH
128981: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
128985: LD_VAR 0 9
128989: PPUSH
128990: LD_VAR 0 4
128994: PPUSH
128995: CALL_OW 180
// end ; end ; unit_human :
128999: GO 129346
129001: LD_INT 1
129003: DOUBLE
129004: EQUAL
129005: IFTRUE 129009
129007: GO 129345
129009: POP
// begin b := IsInUnit ( i ) ;
129010: LD_ADDR_VAR 0 18
129014: PUSH
129015: LD_VAR 0 4
129019: PPUSH
129020: CALL_OW 310
129024: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
129025: LD_ADDR_VAR 0 19
129029: PUSH
129030: LD_VAR 0 18
129034: NOT
129035: PUSH
129036: LD_VAR 0 18
129040: PPUSH
129041: CALL_OW 266
129045: PUSH
129046: LD_INT 32
129048: PUSH
129049: LD_INT 31
129051: PUSH
129052: EMPTY
129053: LIST
129054: LIST
129055: IN
129056: OR
129057: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
129058: LD_VAR 0 18
129062: PPUSH
129063: CALL_OW 266
129067: PUSH
129068: LD_INT 5
129070: EQUAL
129071: PUSH
129072: LD_VAR 0 4
129076: PPUSH
129077: CALL_OW 257
129081: PUSH
129082: LD_INT 1
129084: PUSH
129085: LD_INT 2
129087: PUSH
129088: LD_INT 3
129090: PUSH
129091: LD_INT 4
129093: PUSH
129094: EMPTY
129095: LIST
129096: LIST
129097: LIST
129098: LIST
129099: IN
129100: AND
129101: IFFALSE 129138
// begin class := AllowSpecClass ( i ) ;
129103: LD_ADDR_VAR 0 20
129107: PUSH
129108: LD_VAR 0 4
129112: PPUSH
129113: CALL 67663 0 1
129117: ST_TO_ADDR
// if class then
129118: LD_VAR 0 20
129122: IFFALSE 129138
// ComChangeProfession ( i , class ) ;
129124: LD_VAR 0 4
129128: PPUSH
129129: LD_VAR 0 20
129133: PPUSH
129134: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
129138: LD_VAR 0 16
129142: PUSH
129143: LD_VAR 0 2
129147: PPUSH
129148: LD_INT 21
129150: PUSH
129151: LD_INT 2
129153: PUSH
129154: EMPTY
129155: LIST
129156: LIST
129157: PPUSH
129158: CALL_OW 72
129162: PUSH
129163: LD_INT 1
129165: LESSEQUAL
129166: OR
129167: PUSH
129168: LD_VAR 0 19
129172: AND
129173: PUSH
129174: LD_VAR 0 4
129178: PUSH
129179: LD_VAR 0 17
129183: IN
129184: NOT
129185: AND
129186: IFFALSE 129279
// begin if b then
129188: LD_VAR 0 18
129192: IFFALSE 129241
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
129194: LD_VAR 0 18
129198: PPUSH
129199: LD_VAR 0 21
129203: PPUSH
129204: LD_VAR 0 18
129208: PPUSH
129209: CALL_OW 74
129213: PPUSH
129214: CALL_OW 296
129218: PUSH
129219: LD_INT 10
129221: LESS
129222: PUSH
129223: LD_VAR 0 18
129227: PPUSH
129228: CALL_OW 461
129232: PUSH
129233: LD_INT 7
129235: NONEQUAL
129236: AND
129237: IFFALSE 129241
// continue ;
129239: GO 128476
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
129241: LD_ADDR_VAR 0 17
129245: PUSH
129246: LD_VAR 0 17
129250: PPUSH
129251: LD_VAR 0 17
129255: PUSH
129256: LD_INT 1
129258: PLUS
129259: PPUSH
129260: LD_VAR 0 4
129264: PPUSH
129265: CALL_OW 1
129269: ST_TO_ADDR
// ComExitBuilding ( i ) ;
129270: LD_VAR 0 4
129274: PPUSH
129275: CALL_OW 122
// end ; if sold_defenders then
129279: LD_VAR 0 17
129283: IFFALSE 129343
// if i in sold_defenders then
129285: LD_VAR 0 4
129289: PUSH
129290: LD_VAR 0 17
129294: IN
129295: IFFALSE 129343
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
129297: LD_VAR 0 4
129301: PPUSH
129302: CALL_OW 314
129306: NOT
129307: PUSH
129308: LD_VAR 0 4
129312: PPUSH
129313: LD_VAR 0 13
129317: PPUSH
129318: CALL_OW 296
129322: PUSH
129323: LD_INT 30
129325: LESS
129326: AND
129327: IFFALSE 129343
// ComAttackUnit ( i , e ) ;
129329: LD_VAR 0 4
129333: PPUSH
129334: LD_VAR 0 13
129338: PPUSH
129339: CALL_OW 115
// end ; end ; end ;
129343: GO 129346
129345: POP
// if IsDead ( i ) then
129346: LD_VAR 0 4
129350: PPUSH
129351: CALL_OW 301
129355: IFFALSE 129373
// defenders := defenders diff i ;
129357: LD_ADDR_VAR 0 2
129361: PUSH
129362: LD_VAR 0 2
129366: PUSH
129367: LD_VAR 0 4
129371: DIFF
129372: ST_TO_ADDR
// end ;
129373: GO 128476
129375: POP
129376: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
129377: LD_VAR 0 21
129381: NOT
129382: PUSH
129383: LD_VAR 0 2
129387: NOT
129388: OR
129389: PUSH
129390: LD_EXP 116
129394: PUSH
129395: LD_VAR 0 1
129399: ARRAY
129400: NOT
129401: OR
129402: IFFALSE 128380
// MC_Reset ( base , 18 ) ;
129404: LD_VAR 0 1
129408: PPUSH
129409: LD_INT 18
129411: PPUSH
129412: CALL 39405 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
129416: LD_ADDR_VAR 0 2
129420: PUSH
129421: LD_VAR 0 2
129425: PUSH
129426: LD_VAR 0 2
129430: PPUSH
129431: LD_INT 2
129433: PUSH
129434: LD_INT 25
129436: PUSH
129437: LD_INT 1
129439: PUSH
129440: EMPTY
129441: LIST
129442: LIST
129443: PUSH
129444: LD_INT 25
129446: PUSH
129447: LD_INT 5
129449: PUSH
129450: EMPTY
129451: LIST
129452: LIST
129453: PUSH
129454: LD_INT 25
129456: PUSH
129457: LD_INT 8
129459: PUSH
129460: EMPTY
129461: LIST
129462: LIST
129463: PUSH
129464: LD_INT 25
129466: PUSH
129467: LD_INT 9
129469: PUSH
129470: EMPTY
129471: LIST
129472: LIST
129473: PUSH
129474: EMPTY
129475: LIST
129476: LIST
129477: LIST
129478: LIST
129479: LIST
129480: PPUSH
129481: CALL_OW 72
129485: DIFF
129486: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
129487: LD_VAR 0 21
129491: NOT
129492: PUSH
129493: LD_VAR 0 2
129497: PPUSH
129498: LD_INT 21
129500: PUSH
129501: LD_INT 2
129503: PUSH
129504: EMPTY
129505: LIST
129506: LIST
129507: PPUSH
129508: CALL_OW 72
129512: AND
129513: IFFALSE 129851
// begin tmp := FilterByTag ( defenders , 19 ) ;
129515: LD_ADDR_VAR 0 11
129519: PUSH
129520: LD_VAR 0 2
129524: PPUSH
129525: LD_INT 19
129527: PPUSH
129528: CALL 100132 0 2
129532: ST_TO_ADDR
// if tmp then
129533: LD_VAR 0 11
129537: IFFALSE 129607
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
129539: LD_ADDR_VAR 0 11
129543: PUSH
129544: LD_VAR 0 11
129548: PPUSH
129549: LD_INT 25
129551: PUSH
129552: LD_INT 3
129554: PUSH
129555: EMPTY
129556: LIST
129557: LIST
129558: PPUSH
129559: CALL_OW 72
129563: ST_TO_ADDR
// if tmp then
129564: LD_VAR 0 11
129568: IFFALSE 129607
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
129570: LD_ADDR_EXP 128
129574: PUSH
129575: LD_EXP 128
129579: PPUSH
129580: LD_VAR 0 1
129584: PPUSH
129585: LD_EXP 128
129589: PUSH
129590: LD_VAR 0 1
129594: ARRAY
129595: PUSH
129596: LD_VAR 0 11
129600: UNION
129601: PPUSH
129602: CALL_OW 1
129606: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
129607: LD_VAR 0 1
129611: PPUSH
129612: LD_INT 19
129614: PPUSH
129615: CALL 39405 0 2
// repeat wait ( 0 0$1 ) ;
129619: LD_INT 35
129621: PPUSH
129622: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
129626: LD_EXP 116
129630: PUSH
129631: LD_VAR 0 1
129635: ARRAY
129636: NOT
129637: PUSH
129638: LD_EXP 116
129642: PUSH
129643: LD_VAR 0 1
129647: ARRAY
129648: PUSH
129649: EMPTY
129650: EQUAL
129651: OR
129652: IFFALSE 129689
// begin for i in defenders do
129654: LD_ADDR_VAR 0 4
129658: PUSH
129659: LD_VAR 0 2
129663: PUSH
129664: FOR_IN
129665: IFFALSE 129678
// ComStop ( i ) ;
129667: LD_VAR 0 4
129671: PPUSH
129672: CALL_OW 141
129676: GO 129664
129678: POP
129679: POP
// defenders := [ ] ;
129680: LD_ADDR_VAR 0 2
129684: PUSH
129685: EMPTY
129686: ST_TO_ADDR
// exit ;
129687: GO 129915
// end ; for i in defenders do
129689: LD_ADDR_VAR 0 4
129693: PUSH
129694: LD_VAR 0 2
129698: PUSH
129699: FOR_IN
129700: IFFALSE 129789
// begin if not IsInArea ( i , mc_parking [ base ] ) then
129702: LD_VAR 0 4
129706: PPUSH
129707: LD_EXP 140
129711: PUSH
129712: LD_VAR 0 1
129716: ARRAY
129717: PPUSH
129718: CALL_OW 308
129722: NOT
129723: IFFALSE 129747
// ComMoveToArea ( i , mc_parking [ base ] ) else
129725: LD_VAR 0 4
129729: PPUSH
129730: LD_EXP 140
129734: PUSH
129735: LD_VAR 0 1
129739: ARRAY
129740: PPUSH
129741: CALL_OW 113
129745: GO 129787
// if GetControl ( i ) = control_manual then
129747: LD_VAR 0 4
129751: PPUSH
129752: CALL_OW 263
129756: PUSH
129757: LD_INT 1
129759: EQUAL
129760: IFFALSE 129787
// if IsDrivenBy ( i ) then
129762: LD_VAR 0 4
129766: PPUSH
129767: CALL_OW 311
129771: IFFALSE 129787
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
129773: LD_VAR 0 4
129777: PPUSH
129778: CALL_OW 311
129782: PPUSH
129783: CALL_OW 121
// end ;
129787: GO 129699
129789: POP
129790: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
129791: LD_VAR 0 2
129795: PPUSH
129796: LD_INT 95
129798: PUSH
129799: LD_EXP 140
129803: PUSH
129804: LD_VAR 0 1
129808: ARRAY
129809: PUSH
129810: EMPTY
129811: LIST
129812: LIST
129813: PPUSH
129814: CALL_OW 72
129818: PUSH
129819: LD_VAR 0 2
129823: EQUAL
129824: PUSH
129825: LD_EXP 139
129829: PUSH
129830: LD_VAR 0 1
129834: ARRAY
129835: OR
129836: PUSH
129837: LD_EXP 116
129841: PUSH
129842: LD_VAR 0 1
129846: ARRAY
129847: NOT
129848: OR
129849: IFFALSE 129619
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
129851: LD_ADDR_EXP 138
129855: PUSH
129856: LD_EXP 138
129860: PPUSH
129861: LD_VAR 0 1
129865: PPUSH
129866: LD_VAR 0 2
129870: PPUSH
129871: LD_INT 21
129873: PUSH
129874: LD_INT 2
129876: PUSH
129877: EMPTY
129878: LIST
129879: LIST
129880: PPUSH
129881: CALL_OW 72
129885: PPUSH
129886: CALL_OW 1
129890: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
129891: LD_VAR 0 1
129895: PPUSH
129896: LD_INT 19
129898: PPUSH
129899: CALL 39405 0 2
// MC_Reset ( base , 20 ) ;
129903: LD_VAR 0 1
129907: PPUSH
129908: LD_INT 20
129910: PPUSH
129911: CALL 39405 0 2
// end ; end_of_file
129915: LD_VAR 0 3
129919: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
129920: LD_VAR 0 1
129924: PUSH
129925: LD_INT 200
129927: DOUBLE
129928: GREATEREQUAL
129929: IFFALSE 129937
129931: LD_INT 299
129933: DOUBLE
129934: LESSEQUAL
129935: IFTRUE 129939
129937: GO 129971
129939: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
129940: LD_VAR 0 1
129944: PPUSH
129945: LD_VAR 0 2
129949: PPUSH
129950: LD_VAR 0 3
129954: PPUSH
129955: LD_VAR 0 4
129959: PPUSH
129960: LD_VAR 0 5
129964: PPUSH
129965: CALL 118736 0 5
129969: GO 130048
129971: LD_INT 300
129973: DOUBLE
129974: GREATEREQUAL
129975: IFFALSE 129983
129977: LD_INT 399
129979: DOUBLE
129980: LESSEQUAL
129981: IFTRUE 129985
129983: GO 130047
129985: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
129986: LD_VAR 0 1
129990: PPUSH
129991: LD_VAR 0 2
129995: PPUSH
129996: LD_VAR 0 3
130000: PPUSH
130001: LD_VAR 0 4
130005: PPUSH
130006: LD_VAR 0 5
130010: PPUSH
130011: LD_VAR 0 6
130015: PPUSH
130016: LD_VAR 0 7
130020: PPUSH
130021: LD_VAR 0 8
130025: PPUSH
130026: LD_VAR 0 9
130030: PPUSH
130031: LD_VAR 0 10
130035: PPUSH
130036: LD_VAR 0 11
130040: PPUSH
130041: CALL 116624 0 11
130045: GO 130048
130047: POP
// end ;
130048: PPOPN 11
130050: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
130051: LD_VAR 0 1
130055: PPUSH
130056: LD_VAR 0 2
130060: PPUSH
130061: LD_VAR 0 3
130065: PPUSH
130066: LD_VAR 0 4
130070: PPUSH
130071: LD_VAR 0 5
130075: PPUSH
130076: CALL 118718 0 5
// end ; end_of_file
130080: PPOPN 5
130082: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
130083: LD_VAR 0 1
130087: PPUSH
130088: LD_VAR 0 2
130092: PPUSH
130093: LD_VAR 0 3
130097: PPUSH
130098: LD_VAR 0 4
130102: PPUSH
130103: LD_VAR 0 5
130107: PPUSH
130108: LD_VAR 0 6
130112: PPUSH
130113: CALL 105432 0 6
// end ;
130117: PPOPN 6
130119: END
