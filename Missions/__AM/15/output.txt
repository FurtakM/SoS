// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34222 0 0
// InitNature ;
  19: CALL 34046 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10934 0 0
// PrepareRussian ;
  40: CALL 6917 0 0
// PrepareLegion ;
  44: CALL 4157 0 0
// PreparePowell ;
  48: CALL 2911 0 0
// PrepareAmerican ;
  52: CALL 1683 0 0
// Action ;
  56: CALL 14841 0 0
// MC_Start ( ) ;
  60: CALL 36334 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// end ;
 455: LD_VAR 0 1
 459: RET
// export function CustomInitMacro ( ) ; begin
 460: LD_INT 0
 462: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 463: LD_ADDR_EXP 125
 467: PUSH
 468: LD_INT 2
 470: PUSH
 471: LD_INT 3
 473: PUSH
 474: LD_INT 6
 476: PUSH
 477: LD_INT 10
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 486: LD_ADDR_EXP 126
 490: PUSH
 491: LD_INT 1
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: LD_INT 5
 499: PUSH
 500: LD_INT 9
 502: PUSH
 503: EMPTY
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 509: LD_INT 1
 511: PPUSH
 512: LD_INT 10
 514: PUSH
 515: LD_INT 11
 517: PUSH
 518: LD_INT 12
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: LIST
 525: PPUSH
 526: CALL 58611 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 530: LD_INT 1
 532: PPUSH
 533: LD_INT 17
 535: PUSH
 536: EMPTY
 537: LIST
 538: PPUSH
 539: CALL 58704 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 5
 548: PPUSH
 549: CALL 58054 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 553: LD_INT 1
 555: PPUSH
 556: LD_INT 24
 558: PUSH
 559: LD_INT 3
 561: PUSH
 562: LD_INT 3
 564: PUSH
 565: LD_INT 47
 567: PUSH
 568: EMPTY
 569: LIST
 570: LIST
 571: LIST
 572: LIST
 573: PUSH
 574: LD_INT 24
 576: PUSH
 577: LD_INT 3
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 47
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: PUSH
 592: LD_INT 24
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 47
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: PUSH
 610: LD_INT 24
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 47
 621: PUSH
 622: EMPTY
 623: LIST
 624: LIST
 625: LIST
 626: LIST
 627: PUSH
 628: LD_INT 24
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 1
 636: PUSH
 637: LD_INT 47
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: LIST
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PPUSH
 653: CALL 57869 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 657: LD_INT 2
 659: PPUSH
 660: LD_INT 10
 662: PUSH
 663: LD_INT 11
 665: PUSH
 666: LD_INT 12
 668: PUSH
 669: LD_INT 14
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: PPUSH
 678: CALL 58611 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 682: LD_INT 2
 684: PPUSH
 685: LD_INT 16
 687: PUSH
 688: EMPTY
 689: LIST
 690: PPUSH
 691: CALL 58704 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 21
 700: PUSH
 701: LD_INT 3
 703: PUSH
 704: LD_INT 3
 706: PUSH
 707: LD_INT 51
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: LIST
 715: PUSH
 716: LD_INT 22
 718: PUSH
 719: LD_INT 3
 721: PUSH
 722: LD_INT 3
 724: PUSH
 725: LD_INT 52
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 22
 736: PUSH
 737: LD_INT 3
 739: PUSH
 740: LD_INT 3
 742: PUSH
 743: LD_INT 52
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 24
 754: PUSH
 755: LD_INT 3
 757: PUSH
 758: LD_INT 3
 760: PUSH
 761: LD_INT 47
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 24
 772: PUSH
 773: LD_INT 3
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 47
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 24
 790: PUSH
 791: LD_INT 3
 793: PUSH
 794: LD_INT 3
 796: PUSH
 797: LD_INT 47
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 24
 808: PUSH
 809: LD_INT 3
 811: PUSH
 812: LD_INT 3
 814: PUSH
 815: LD_INT 47
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 24
 826: PUSH
 827: LD_INT 3
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: LD_INT 47
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: PPUSH
 852: CALL 57869 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 856: LD_INT 2
 858: PPUSH
 859: LD_INT 5
 861: PPUSH
 862: CALL 58054 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 866: LD_INT 2
 868: PPUSH
 869: LD_INT 0
 871: PPUSH
 872: CALL 58484 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 876: LD_INT 3
 878: PPUSH
 879: LD_INT 10
 881: PUSH
 882: LD_INT 12
 884: PUSH
 885: LD_INT 15
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: LIST
 892: PUSH
 893: LD_OWVAR 67
 897: ARRAY
 898: PPUSH
 899: LD_INT 27
 901: PPUSH
 902: CALL 57551 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 906: LD_INT 3
 908: PPUSH
 909: LD_INT 10
 911: PUSH
 912: LD_INT 11
 914: PUSH
 915: LD_INT 13
 917: PUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL 58611 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 931: LD_INT 3
 933: PPUSH
 934: LD_INT 15
 936: PUSH
 937: EMPTY
 938: LIST
 939: PPUSH
 940: CALL 58704 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 944: LD_ADDR_EXP 130
 948: PUSH
 949: LD_EXP 130
 953: PPUSH
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 22
 959: PUSH
 960: LD_INT 8
 962: PUSH
 963: EMPTY
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 25
 969: PUSH
 970: LD_INT 15
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: PPUSH
 981: CALL_OW 69
 985: PPUSH
 986: CALL_OW 1
 990: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 991: LD_INT 3
 993: PPUSH
 994: LD_INT 13
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 31
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: PUSH
1012: LD_INT 13
1014: PUSH
1015: LD_INT 2
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 31
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: LIST
1028: LIST
1029: PUSH
1030: LD_INT 13
1032: PUSH
1033: LD_INT 3
1035: PUSH
1036: LD_INT 2
1038: PUSH
1039: LD_INT 32
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PPUSH
1053: CALL 57869 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: PPUSH
1070: CALL 58611 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1074: LD_INT 4
1076: PPUSH
1077: LD_INT 9
1079: PUSH
1080: EMPTY
1081: LIST
1082: PPUSH
1083: CALL 58704 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1087: LD_INT 4
1089: PPUSH
1090: LD_INT 26
1092: PUSH
1093: LD_INT 74
1095: PUSH
1096: LD_INT 107
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 32
1110: PUSH
1111: LD_INT 77
1113: PUSH
1114: LD_INT 101
1116: PUSH
1117: LD_INT 4
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 32
1128: PUSH
1129: LD_INT 69
1131: PUSH
1132: LD_INT 86
1134: PUSH
1135: LD_INT 4
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 27
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 110
1152: PUSH
1153: LD_INT 3
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 42
1167: PUSH
1168: LD_INT 79
1170: PUSH
1171: LD_INT 5
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 29
1182: PUSH
1183: LD_INT 86
1185: PUSH
1186: LD_INT 105
1188: PUSH
1189: LD_INT 2
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 40
1203: PUSH
1204: LD_INT 75
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 80
1221: PUSH
1222: LD_INT 106
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 32
1236: PUSH
1237: LD_INT 75
1239: PUSH
1240: LD_INT 114
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 82
1257: PUSH
1258: LD_INT 110
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 62
1275: PUSH
1276: LD_INT 78
1278: PUSH
1279: LD_INT 4
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 4
1290: PUSH
1291: LD_INT 39
1293: PUSH
1294: LD_INT 61
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL 57761 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1324: LD_INT 4
1326: PPUSH
1327: LD_INT 5
1329: PUSH
1330: LD_INT 6
1332: PUSH
1333: LD_INT 7
1335: PUSH
1336: LD_INT 9
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 59022 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 58193 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 58484 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 58484 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 58816 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 57869 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 58435 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$1 trigger debug do var i , tmp ;
1542: LD_EXP 1
1546: IFFALSE 1653
1548: GO 1550
1550: DISABLE
1551: LD_INT 0
1553: PPUSH
1554: PPUSH
// begin enable ;
1555: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1556: LD_ADDR_VAR 0 2
1560: PUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: LD_INT 3
1573: PUSH
1574: LD_INT 21
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: PUSH
1588: LD_INT 3
1590: PUSH
1591: LD_INT 24
1593: PUSH
1594: LD_INT 999
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: LIST
1609: PPUSH
1610: CALL_OW 69
1614: ST_TO_ADDR
// if not tmp then
1615: LD_VAR 0 2
1619: NOT
1620: IFFALSE 1624
// exit ;
1622: GO 1653
// for i in tmp do
1624: LD_ADDR_VAR 0 1
1628: PUSH
1629: LD_VAR 0 2
1633: PUSH
1634: FOR_IN
1635: IFFALSE 1651
// SetLives ( i , 1000 ) ;
1637: LD_VAR 0 1
1641: PPUSH
1642: LD_INT 1000
1644: PPUSH
1645: CALL_OW 234
1649: GO 1634
1651: POP
1652: POP
// end ;
1653: PPOPN 2
1655: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1656: LD_EXP 36
1660: PUSH
1661: LD_EXP 17
1665: PUSH
1666: LD_INT 2
1668: GREATEREQUAL
1669: AND
1670: IFFALSE 1682
1672: GO 1674
1674: DISABLE
// SetAchievement ( ACH_POWELL ) ; end_of_file
1675: LD_STRING ACH_POWELL
1677: PPUSH
1678: CALL_OW 543
1682: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1683: LD_INT 0
1685: PPUSH
// uc_side := 1 ;
1686: LD_ADDR_OWVAR 20
1690: PUSH
1691: LD_INT 1
1693: ST_TO_ADDR
// uc_nation := 1 ;
1694: LD_ADDR_OWVAR 21
1698: PUSH
1699: LD_INT 1
1701: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1702: LD_ADDR_EXP 38
1706: PUSH
1707: LD_STRING JMM
1709: PPUSH
1710: LD_EXP 1
1714: NOT
1715: PPUSH
1716: LD_STRING 14_
1718: PPUSH
1719: CALL 64261 0 3
1723: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1724: LD_EXP 4
1728: NOT
1729: PUSH
1730: LD_EXP 4
1734: PUSH
1735: LD_INT 1
1737: ARRAY
1738: PUSH
1739: LD_INT 1
1741: ARRAY
1742: NOT
1743: OR
1744: IFFALSE 1767
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1746: LD_INT 3
1748: PPUSH
1749: LD_INT 3
1751: PPUSH
1752: LD_INT 1
1754: PPUSH
1755: LD_INT 5
1757: PPUSH
1758: LD_INT 100
1760: PPUSH
1761: CALL 71376 0 5
1765: GO 1826
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1767: LD_EXP 4
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PUSH
1776: LD_INT 1
1778: ARRAY
1779: PPUSH
1780: LD_EXP 4
1784: PUSH
1785: LD_INT 2
1787: ARRAY
1788: PUSH
1789: LD_INT 1
1791: ARRAY
1792: PPUSH
1793: LD_EXP 4
1797: PUSH
1798: LD_INT 3
1800: ARRAY
1801: PUSH
1802: LD_INT 1
1804: ARRAY
1805: PPUSH
1806: LD_EXP 4
1810: PUSH
1811: LD_INT 4
1813: ARRAY
1814: PUSH
1815: LD_INT 1
1817: ARRAY
1818: PPUSH
1819: LD_INT 30
1821: PPUSH
1822: CALL 71376 0 5
// JMMNewVeh := CreateVehicle ;
1826: LD_ADDR_EXP 55
1830: PUSH
1831: CALL_OW 45
1835: ST_TO_ADDR
// if not JMMNewVeh then
1836: LD_EXP 55
1840: NOT
1841: IFFALSE 1872
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1843: LD_INT 3
1845: PPUSH
1846: LD_INT 3
1848: PPUSH
1849: LD_INT 1
1851: PPUSH
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 100
1857: PPUSH
1858: CALL 71376 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 55
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1872: LD_EXP 55
1876: PPUSH
1877: LD_INT 4
1879: PPUSH
1880: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1884: LD_EXP 55
1888: PPUSH
1889: LD_INT 79
1891: PPUSH
1892: LD_INT 91
1894: PPUSH
1895: LD_INT 0
1897: PPUSH
1898: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1902: LD_EXP 38
1906: PPUSH
1907: LD_EXP 55
1911: PPUSH
1912: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1916: LD_EXP 6
1920: PUSH
1921: LD_EXP 2
1925: NOT
1926: AND
1927: IFFALSE 2185
// begin if not JMMGirlVeh then
1929: LD_EXP 5
1933: NOT
1934: IFFALSE 1957
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1936: LD_INT 3
1938: PPUSH
1939: LD_INT 3
1941: PPUSH
1942: LD_INT 1
1944: PPUSH
1945: LD_INT 9
1947: PPUSH
1948: LD_INT 100
1950: PPUSH
1951: CALL 71376 0 5
1955: GO 2016
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1957: LD_EXP 5
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PUSH
1966: LD_INT 1
1968: ARRAY
1969: PPUSH
1970: LD_EXP 5
1974: PUSH
1975: LD_INT 2
1977: ARRAY
1978: PUSH
1979: LD_INT 1
1981: ARRAY
1982: PPUSH
1983: LD_EXP 5
1987: PUSH
1988: LD_INT 3
1990: ARRAY
1991: PUSH
1992: LD_INT 1
1994: ARRAY
1995: PPUSH
1996: LD_EXP 5
2000: PUSH
2001: LD_INT 4
2003: ARRAY
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PPUSH
2009: LD_INT 30
2011: PPUSH
2012: CALL 71376 0 5
// GirlNewVeh := CreateVehicle ;
2016: LD_ADDR_EXP 56
2020: PUSH
2021: CALL_OW 45
2025: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2026: LD_EXP 56
2030: PPUSH
2031: LD_INT 4
2033: PPUSH
2034: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2038: LD_EXP 56
2042: PPUSH
2043: LD_INT 82
2045: PPUSH
2046: LD_INT 96
2048: PPUSH
2049: LD_INT 0
2051: PPUSH
2052: CALL_OW 48
// if JMMGirl = 1 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 1
2063: EQUAL
2064: IFFALSE 2099
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Joan
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 64261 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 56
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 2 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 2
2106: EQUAL
2107: IFFALSE 2142
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2109: LD_ADDR_EXP 41
2113: PUSH
2114: LD_STRING Lisa
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 64261 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2128: LD_EXP 41
2132: PPUSH
2133: LD_EXP 56
2137: PPUSH
2138: CALL_OW 52
// end ; if JMMGirl = 3 then
2142: LD_EXP 7
2146: PUSH
2147: LD_INT 3
2149: EQUAL
2150: IFFALSE 2185
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2152: LD_ADDR_EXP 53
2156: PUSH
2157: LD_STRING Connie
2159: PPUSH
2160: LD_INT 1
2162: PPUSH
2163: LD_STRING 14_
2165: PPUSH
2166: CALL 64261 0 3
2170: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2171: LD_EXP 53
2175: PPUSH
2176: LD_EXP 56
2180: PPUSH
2181: CALL_OW 52
// end ; end ; end ;
2185: LD_VAR 0 1
2189: RET
// export function PrepareStevensSquad ; var tmp ; begin
2190: LD_INT 0
2192: PPUSH
2193: PPUSH
// uc_side := 1 ;
2194: LD_ADDR_OWVAR 20
2198: PUSH
2199: LD_INT 1
2201: ST_TO_ADDR
// uc_nation := 1 ;
2202: LD_ADDR_OWVAR 21
2206: PUSH
2207: LD_INT 1
2209: ST_TO_ADDR
// tmp := [ ] ;
2210: LD_ADDR_VAR 0 2
2214: PUSH
2215: EMPTY
2216: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2217: LD_ADDR_EXP 40
2221: PUSH
2222: LD_STRING Stevens
2224: PPUSH
2225: LD_EXP 1
2229: NOT
2230: PPUSH
2231: LD_STRING 13f_
2233: PPUSH
2234: CALL 64261 0 3
2238: ST_TO_ADDR
// if not Stevens then
2239: LD_EXP 40
2243: NOT
2244: IFFALSE 2300
// begin hc_name = Baker Smith ;
2246: LD_ADDR_OWVAR 26
2250: PUSH
2251: LD_STRING Baker Smith
2253: ST_TO_ADDR
// hc_gallery =  ;
2254: LD_ADDR_OWVAR 33
2258: PUSH
2259: LD_STRING 
2261: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 10
2267: PPUSH
2268: CALL_OW 384
// Baker = CreateHuman ;
2272: LD_ADDR_EXP 54
2276: PUSH
2277: CALL_OW 44
2281: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2282: LD_ADDR_VAR 0 2
2286: PUSH
2287: LD_VAR 0 2
2291: PUSH
2292: LD_EXP 54
2296: ADD
2297: ST_TO_ADDR
// end else
2298: GO 2316
// tmp := tmp ^ Stevens ;
2300: LD_ADDR_VAR 0 2
2304: PUSH
2305: LD_VAR 0 2
2309: PUSH
2310: LD_EXP 40
2314: ADD
2315: ST_TO_ADDR
// if not Lisa then
2316: LD_EXP 41
2320: NOT
2321: IFFALSE 2367
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2323: LD_ADDR_EXP 41
2327: PUSH
2328: LD_STRING Lisa
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13f_
2339: PPUSH
2340: CALL 64261 0 3
2344: ST_TO_ADDR
// if Lisa then
2345: LD_EXP 41
2349: IFFALSE 2367
// tmp := tmp ^ Lisa ;
2351: LD_ADDR_VAR 0 2
2355: PUSH
2356: LD_VAR 0 2
2360: PUSH
2361: LD_EXP 41
2365: ADD
2366: ST_TO_ADDR
// end ; if not Donaldson then
2367: LD_EXP 42
2371: NOT
2372: IFFALSE 2418
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2374: LD_ADDR_EXP 42
2378: PUSH
2379: LD_STRING Donaldson
2381: PPUSH
2382: LD_EXP 1
2386: NOT
2387: PPUSH
2388: LD_STRING 13f_
2390: PPUSH
2391: CALL 64261 0 3
2395: ST_TO_ADDR
// if Donaldson then
2396: LD_EXP 42
2400: IFFALSE 2418
// tmp := tmp ^ Donaldson ;
2402: LD_ADDR_VAR 0 2
2406: PUSH
2407: LD_VAR 0 2
2411: PUSH
2412: LD_EXP 42
2416: ADD
2417: ST_TO_ADDR
// end ; if not Bobby then
2418: LD_EXP 43
2422: NOT
2423: IFFALSE 2469
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2425: LD_ADDR_EXP 43
2429: PUSH
2430: LD_STRING Bobby
2432: PPUSH
2433: LD_EXP 1
2437: NOT
2438: PPUSH
2439: LD_STRING 13f_
2441: PPUSH
2442: CALL 64261 0 3
2446: ST_TO_ADDR
// if Bobby then
2447: LD_EXP 43
2451: IFFALSE 2469
// tmp := tmp ^ Bobby ;
2453: LD_ADDR_VAR 0 2
2457: PUSH
2458: LD_VAR 0 2
2462: PUSH
2463: LD_EXP 43
2467: ADD
2468: ST_TO_ADDR
// end ; if not Cyrus then
2469: LD_EXP 44
2473: NOT
2474: IFFALSE 2520
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2476: LD_ADDR_EXP 44
2480: PUSH
2481: LD_STRING Cyrus
2483: PPUSH
2484: LD_EXP 1
2488: NOT
2489: PPUSH
2490: LD_STRING 13f_
2492: PPUSH
2493: CALL 64261 0 3
2497: ST_TO_ADDR
// if Cyrus then
2498: LD_EXP 44
2502: IFFALSE 2520
// tmp := tmp ^ Cyrus ;
2504: LD_ADDR_VAR 0 2
2508: PUSH
2509: LD_VAR 0 2
2513: PUSH
2514: LD_EXP 44
2518: ADD
2519: ST_TO_ADDR
// end ; if not Brown then
2520: LD_EXP 46
2524: NOT
2525: IFFALSE 2571
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2527: LD_ADDR_EXP 46
2531: PUSH
2532: LD_STRING Brown
2534: PPUSH
2535: LD_EXP 1
2539: NOT
2540: PPUSH
2541: LD_STRING 13f_
2543: PPUSH
2544: CALL 64261 0 3
2548: ST_TO_ADDR
// if Brown then
2549: LD_EXP 46
2553: IFFALSE 2571
// tmp := tmp ^ Brown ;
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: LD_VAR 0 2
2564: PUSH
2565: LD_EXP 46
2569: ADD
2570: ST_TO_ADDR
// end ; if not Gladstone then
2571: LD_EXP 47
2575: NOT
2576: IFFALSE 2622
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2578: LD_ADDR_EXP 47
2582: PUSH
2583: LD_STRING Gladstone
2585: PPUSH
2586: LD_EXP 1
2590: NOT
2591: PPUSH
2592: LD_STRING 13f_
2594: PPUSH
2595: CALL 64261 0 3
2599: ST_TO_ADDR
// if Gladstone then
2600: LD_EXP 47
2604: IFFALSE 2622
// tmp := tmp ^ Gladstone ;
2606: LD_ADDR_VAR 0 2
2610: PUSH
2611: LD_VAR 0 2
2615: PUSH
2616: LD_EXP 47
2620: ADD
2621: ST_TO_ADDR
// end ; if not Houten then
2622: LD_EXP 48
2626: NOT
2627: IFFALSE 2673
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2629: LD_ADDR_EXP 48
2633: PUSH
2634: LD_STRING Houten
2636: PPUSH
2637: LD_EXP 1
2641: NOT
2642: PPUSH
2643: LD_STRING 13f_
2645: PPUSH
2646: CALL 64261 0 3
2650: ST_TO_ADDR
// if Houten then
2651: LD_EXP 48
2655: IFFALSE 2673
// tmp := tmp ^ Houten ;
2657: LD_ADDR_VAR 0 2
2661: PUSH
2662: LD_VAR 0 2
2666: PUSH
2667: LD_EXP 48
2671: ADD
2672: ST_TO_ADDR
// end ; if not Cornel then
2673: LD_EXP 49
2677: NOT
2678: IFFALSE 2724
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2680: LD_ADDR_EXP 49
2684: PUSH
2685: LD_STRING Cornel
2687: PPUSH
2688: LD_EXP 1
2692: NOT
2693: PPUSH
2694: LD_STRING 13f_
2696: PPUSH
2697: CALL 64261 0 3
2701: ST_TO_ADDR
// if Cornel then
2702: LD_EXP 49
2706: IFFALSE 2724
// tmp := tmp ^ Cornel ;
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: LD_VAR 0 2
2717: PUSH
2718: LD_EXP 49
2722: ADD
2723: ST_TO_ADDR
// end ; if not Gary then
2724: LD_EXP 50
2728: NOT
2729: IFFALSE 2775
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2731: LD_ADDR_EXP 50
2735: PUSH
2736: LD_STRING Gary
2738: PPUSH
2739: LD_EXP 1
2743: NOT
2744: PPUSH
2745: LD_STRING 13f_
2747: PPUSH
2748: CALL 64261 0 3
2752: ST_TO_ADDR
// if Gary then
2753: LD_EXP 50
2757: IFFALSE 2775
// tmp := tmp ^ Gary ;
2759: LD_ADDR_VAR 0 2
2763: PUSH
2764: LD_VAR 0 2
2768: PUSH
2769: LD_EXP 50
2773: ADD
2774: ST_TO_ADDR
// end ; if not Frank then
2775: LD_EXP 51
2779: NOT
2780: IFFALSE 2826
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2782: LD_ADDR_EXP 51
2786: PUSH
2787: LD_STRING Frank
2789: PPUSH
2790: LD_EXP 1
2794: NOT
2795: PPUSH
2796: LD_STRING 13f_
2798: PPUSH
2799: CALL 64261 0 3
2803: ST_TO_ADDR
// if Frank then
2804: LD_EXP 51
2808: IFFALSE 2826
// tmp := tmp ^ Frank ;
2810: LD_ADDR_VAR 0 2
2814: PUSH
2815: LD_VAR 0 2
2819: PUSH
2820: LD_EXP 51
2824: ADD
2825: ST_TO_ADDR
// end ; if not Kikuchi then
2826: LD_EXP 52
2830: NOT
2831: IFFALSE 2877
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2833: LD_ADDR_EXP 52
2837: PUSH
2838: LD_STRING Kikuchi
2840: PPUSH
2841: LD_EXP 1
2845: NOT
2846: PPUSH
2847: LD_STRING 13f_
2849: PPUSH
2850: CALL 64261 0 3
2854: ST_TO_ADDR
// if Kikuchi then
2855: LD_EXP 52
2859: IFFALSE 2877
// tmp := tmp ^ Kikuchi ;
2861: LD_ADDR_VAR 0 2
2865: PUSH
2866: LD_VAR 0 2
2870: PUSH
2871: LD_EXP 52
2875: ADD
2876: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2877: LD_ADDR_VAR 0 2
2881: PUSH
2882: LD_VAR 0 2
2886: PUSH
2887: LD_STRING 13_other_survivors
2889: PPUSH
2890: CALL_OW 31
2894: UNION
2895: ST_TO_ADDR
// result := tmp ;
2896: LD_ADDR_VAR 0 1
2900: PUSH
2901: LD_VAR 0 2
2905: ST_TO_ADDR
// end ; end_of_file
2906: LD_VAR 0 1
2910: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
2918: PPUSH
2919: PPUSH
2920: PPUSH
2921: PPUSH
2922: PPUSH
// uc_side := 4 ;
2923: LD_ADDR_OWVAR 20
2927: PUSH
2928: LD_INT 4
2930: ST_TO_ADDR
// uc_nation := 1 ;
2931: LD_ADDR_OWVAR 21
2935: PUSH
2936: LD_INT 1
2938: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2939: LD_INT 387
2941: PPUSH
2942: CALL_OW 274
2946: PPUSH
2947: LD_INT 1
2949: PPUSH
2950: LD_INT 2500
2952: PPUSH
2953: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2957: LD_INT 387
2959: PPUSH
2960: CALL_OW 274
2964: PPUSH
2965: LD_INT 2
2967: PPUSH
2968: LD_INT 400
2970: PPUSH
2971: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 3
2985: PPUSH
2986: LD_INT 10
2988: PPUSH
2989: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2993: LD_ADDR_EXP 57
2997: PUSH
2998: LD_STRING Powell
3000: PPUSH
3001: CALL_OW 25
3005: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3006: LD_EXP 57
3010: PPUSH
3011: LD_INT 57
3013: PPUSH
3014: LD_INT 94
3016: PPUSH
3017: LD_INT 0
3019: PPUSH
3020: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3024: LD_EXP 57
3028: PPUSH
3029: LD_INT 58
3031: PPUSH
3032: LD_INT 94
3034: PPUSH
3035: CALL_OW 118
// vip := [ ] ;
3039: LD_ADDR_EXP 58
3043: PUSH
3044: EMPTY
3045: ST_TO_ADDR
// tmp := [ ] ;
3046: LD_ADDR_VAR 0 6
3050: PUSH
3051: EMPTY
3052: ST_TO_ADDR
// if JMMGirl <> 2 then
3053: LD_EXP 7
3057: PUSH
3058: LD_INT 2
3060: NONEQUAL
3061: IFFALSE 3085
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3063: LD_ADDR_EXP 41
3067: PUSH
3068: LD_STRING Lisa
3070: PPUSH
3071: LD_EXP 1
3075: NOT
3076: PPUSH
3077: LD_STRING 13s_
3079: PPUSH
3080: CALL 64261 0 3
3084: ST_TO_ADDR
// if Lisa then
3085: LD_EXP 41
3089: IFFALSE 3107
// tmp := tmp ^ Lisa ;
3091: LD_ADDR_VAR 0 6
3095: PUSH
3096: LD_VAR 0 6
3100: PUSH
3101: LD_EXP 41
3105: ADD
3106: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3107: LD_ADDR_EXP 42
3111: PUSH
3112: LD_STRING Donaldson
3114: PPUSH
3115: LD_EXP 1
3119: NOT
3120: PPUSH
3121: LD_STRING 13s_
3123: PPUSH
3124: CALL 64261 0 3
3128: ST_TO_ADDR
// if Donaldson then
3129: LD_EXP 42
3133: IFFALSE 3151
// tmp := tmp ^ Donaldson ;
3135: LD_ADDR_VAR 0 6
3139: PUSH
3140: LD_VAR 0 6
3144: PUSH
3145: LD_EXP 42
3149: ADD
3150: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3151: LD_ADDR_EXP 43
3155: PUSH
3156: LD_STRING Bobby
3158: PPUSH
3159: LD_EXP 1
3163: NOT
3164: PPUSH
3165: LD_STRING 13s_
3167: PPUSH
3168: CALL 64261 0 3
3172: ST_TO_ADDR
// if Bobby then
3173: LD_EXP 43
3177: IFFALSE 3195
// tmp := tmp ^ Bobby ;
3179: LD_ADDR_VAR 0 6
3183: PUSH
3184: LD_VAR 0 6
3188: PUSH
3189: LD_EXP 43
3193: ADD
3194: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3195: LD_ADDR_EXP 44
3199: PUSH
3200: LD_STRING Cyrus
3202: PPUSH
3203: LD_EXP 1
3207: NOT
3208: PPUSH
3209: LD_STRING 13s_
3211: PPUSH
3212: CALL 64261 0 3
3216: ST_TO_ADDR
// if Cyrus then
3217: LD_EXP 44
3221: IFFALSE 3239
// tmp := tmp ^ Cyrus ;
3223: LD_ADDR_VAR 0 6
3227: PUSH
3228: LD_VAR 0 6
3232: PUSH
3233: LD_EXP 44
3237: ADD
3238: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3239: LD_ADDR_EXP 45
3243: PUSH
3244: LD_STRING Denis
3246: PPUSH
3247: LD_EXP 1
3251: NOT
3252: PPUSH
3253: LD_STRING 13s_
3255: PPUSH
3256: CALL 64261 0 3
3260: ST_TO_ADDR
// if not Denis then
3261: LD_EXP 45
3265: NOT
3266: IFFALSE 3290
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3268: LD_ADDR_EXP 45
3272: PUSH
3273: LD_STRING Denis
3275: PPUSH
3276: LD_EXP 1
3280: NOT
3281: PPUSH
3282: LD_STRING 13f_
3284: PPUSH
3285: CALL 64261 0 3
3289: ST_TO_ADDR
// if Denis then
3290: LD_EXP 45
3294: IFFALSE 3312
// tmp := tmp ^ Denis ;
3296: LD_ADDR_VAR 0 6
3300: PUSH
3301: LD_VAR 0 6
3305: PUSH
3306: LD_EXP 45
3310: ADD
3311: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 46
3316: PUSH
3317: LD_STRING Brown
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 64261 0 3
3333: ST_TO_ADDR
// if Brown then
3334: LD_EXP 46
3338: IFFALSE 3356
// tmp := tmp ^ Brown ;
3340: LD_ADDR_VAR 0 6
3344: PUSH
3345: LD_VAR 0 6
3349: PUSH
3350: LD_EXP 46
3354: ADD
3355: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 47
3360: PUSH
3361: LD_STRING Gladstone
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 64261 0 3
3377: ST_TO_ADDR
// if Gladstone then
3378: LD_EXP 47
3382: IFFALSE 3400
// tmp := tmp ^ Gladstone ;
3384: LD_ADDR_VAR 0 6
3388: PUSH
3389: LD_VAR 0 6
3393: PUSH
3394: LD_EXP 47
3398: ADD
3399: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 48
3404: PUSH
3405: LD_STRING Houten
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 64261 0 3
3421: ST_TO_ADDR
// if Houten then
3422: LD_EXP 48
3426: IFFALSE 3444
// tmp := tmp ^ Houten ;
3428: LD_ADDR_VAR 0 6
3432: PUSH
3433: LD_VAR 0 6
3437: PUSH
3438: LD_EXP 48
3442: ADD
3443: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 49
3448: PUSH
3449: LD_STRING Cornel
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 64261 0 3
3465: ST_TO_ADDR
// if Cornel then
3466: LD_EXP 49
3470: IFFALSE 3488
// tmp := tmp ^ Cornel ;
3472: LD_ADDR_VAR 0 6
3476: PUSH
3477: LD_VAR 0 6
3481: PUSH
3482: LD_EXP 49
3486: ADD
3487: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3488: LD_ADDR_EXP 50
3492: PUSH
3493: LD_STRING Gary
3495: PPUSH
3496: LD_EXP 1
3500: NOT
3501: PPUSH
3502: LD_STRING 13s_
3504: PPUSH
3505: CALL 64261 0 3
3509: ST_TO_ADDR
// if Gary then
3510: LD_EXP 50
3514: IFFALSE 3532
// tmp := tmp ^ Gary ;
3516: LD_ADDR_VAR 0 6
3520: PUSH
3521: LD_VAR 0 6
3525: PUSH
3526: LD_EXP 50
3530: ADD
3531: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3532: LD_ADDR_EXP 51
3536: PUSH
3537: LD_STRING Frank
3539: PPUSH
3540: LD_EXP 1
3544: NOT
3545: PPUSH
3546: LD_STRING 13s_
3548: PPUSH
3549: CALL 64261 0 3
3553: ST_TO_ADDR
// if Frank then
3554: LD_EXP 51
3558: IFFALSE 3576
// tmp := tmp ^ Frank ;
3560: LD_ADDR_VAR 0 6
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: LD_EXP 51
3574: ADD
3575: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3576: LD_ADDR_EXP 52
3580: PUSH
3581: LD_STRING Kikuchi
3583: PPUSH
3584: LD_EXP 1
3588: NOT
3589: PPUSH
3590: LD_STRING 13s_
3592: PPUSH
3593: CALL 64261 0 3
3597: ST_TO_ADDR
// if Kikuchi then
3598: LD_EXP 52
3602: IFFALSE 3620
// tmp := tmp ^ Kikuchi ;
3604: LD_ADDR_VAR 0 6
3608: PUSH
3609: LD_VAR 0 6
3613: PUSH
3614: LD_EXP 52
3618: ADD
3619: ST_TO_ADDR
// vip := tmp ;
3620: LD_ADDR_EXP 58
3624: PUSH
3625: LD_VAR 0 6
3629: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3630: LD_ADDR_VAR 0 6
3634: PUSH
3635: LD_VAR 0 6
3639: PUSH
3640: LD_STRING 13s_others
3642: PPUSH
3643: CALL_OW 31
3647: UNION
3648: ST_TO_ADDR
// if tmp < 20 then
3649: LD_VAR 0 6
3653: PUSH
3654: LD_INT 20
3656: LESS
3657: IFFALSE 3724
// for i = 1 to 20 - tmp do
3659: LD_ADDR_VAR 0 2
3663: PUSH
3664: DOUBLE
3665: LD_INT 1
3667: DEC
3668: ST_TO_ADDR
3669: LD_INT 20
3671: PUSH
3672: LD_VAR 0 6
3676: MINUS
3677: PUSH
3678: FOR_TO
3679: IFFALSE 3722
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3681: LD_INT 1
3683: PPUSH
3684: LD_VAR 0 2
3688: PUSH
3689: LD_INT 4
3691: MOD
3692: PUSH
3693: LD_INT 1
3695: PLUS
3696: PPUSH
3697: LD_INT 5
3699: PPUSH
3700: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3704: LD_ADDR_VAR 0 6
3708: PUSH
3709: LD_VAR 0 6
3713: PUSH
3714: CALL_OW 44
3718: ADD
3719: ST_TO_ADDR
// end ;
3720: GO 3678
3722: POP
3723: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3724: LD_ADDR_VAR 0 7
3728: PUSH
3729: LD_INT 22
3731: PUSH
3732: LD_INT 4
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PUSH
3739: LD_INT 30
3741: PUSH
3742: LD_INT 0
3744: PUSH
3745: EMPTY
3746: LIST
3747: LIST
3748: PUSH
3749: EMPTY
3750: LIST
3751: LIST
3752: PPUSH
3753: CALL_OW 69
3757: PUSH
3758: LD_INT 1
3760: ARRAY
3761: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3762: LD_ADDR_VAR 0 8
3766: PUSH
3767: LD_INT 22
3769: PUSH
3770: LD_INT 4
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 30
3779: PUSH
3780: LD_INT 6
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PPUSH
3791: CALL_OW 69
3795: PUSH
3796: LD_INT 1
3798: ARRAY
3799: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3800: LD_ADDR_VAR 0 9
3804: PUSH
3805: LD_INT 22
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PUSH
3815: LD_INT 30
3817: PUSH
3818: LD_INT 4
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PUSH
3825: EMPTY
3826: LIST
3827: LIST
3828: PPUSH
3829: CALL_OW 69
3833: PUSH
3834: LD_INT 1
3836: ARRAY
3837: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3838: LD_ADDR_VAR 0 10
3842: PUSH
3843: LD_INT 22
3845: PUSH
3846: LD_INT 4
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PUSH
3853: LD_INT 30
3855: PUSH
3856: LD_INT 2
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: PPUSH
3867: CALL_OW 69
3871: PUSH
3872: LD_INT 1
3874: ARRAY
3875: ST_TO_ADDR
// for i in tmp do
3876: LD_ADDR_VAR 0 2
3880: PUSH
3881: LD_VAR 0 6
3885: PUSH
3886: FOR_IN
3887: IFFALSE 4013
// begin cl := GetClass ( i ) ;
3889: LD_ADDR_VAR 0 5
3893: PUSH
3894: LD_VAR 0 2
3898: PPUSH
3899: CALL_OW 257
3903: ST_TO_ADDR
// if cl > 4 then
3904: LD_VAR 0 5
3908: PUSH
3909: LD_INT 4
3911: GREATER
3912: IFFALSE 3922
// cl := 1 ;
3914: LD_ADDR_VAR 0 5
3918: PUSH
3919: LD_INT 1
3921: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3922: LD_ADDR_VAR 0 3
3926: PUSH
3927: LD_VAR 0 9
3931: PUSH
3932: LD_VAR 0 7
3936: PUSH
3937: LD_VAR 0 10
3941: PUSH
3942: LD_VAR 0 8
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: PUSH
3953: LD_VAR 0 5
3957: ARRAY
3958: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3959: LD_VAR 0 3
3963: PPUSH
3964: CALL_OW 313
3968: PUSH
3969: LD_INT 5
3971: LESS
3972: IFFALSE 3990
// PlaceHumanInUnit ( i , b ) else
3974: LD_VAR 0 2
3978: PPUSH
3979: LD_VAR 0 3
3983: PPUSH
3984: CALL_OW 52
3988: GO 4011
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3990: LD_VAR 0 2
3994: PPUSH
3995: LD_INT 58
3997: PPUSH
3998: LD_INT 91
4000: PPUSH
4001: LD_INT 6
4003: PPUSH
4004: LD_INT 0
4006: PPUSH
4007: CALL_OW 50
// end ;
4011: GO 3886
4013: POP
4014: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4015: LD_INT 2
4017: PPUSH
4018: LD_INT 1
4020: PPUSH
4021: LD_INT 1
4023: PPUSH
4024: LD_INT 12
4026: PPUSH
4027: LD_INT 100
4029: PPUSH
4030: CALL 71376 0 5
// veh := CreateVehicle ;
4034: LD_ADDR_VAR 0 4
4038: PUSH
4039: CALL_OW 45
4043: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4044: LD_VAR 0 4
4048: PPUSH
4049: LD_INT 4
4051: PPUSH
4052: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 49
4063: PPUSH
4064: LD_INT 88
4066: PPUSH
4067: LD_INT 0
4069: PPUSH
4070: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4074: LD_VAR 0 4
4078: PPUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 100
4084: PPUSH
4085: CALL_OW 290
// uc_side := 0 ;
4089: LD_ADDR_OWVAR 20
4093: PUSH
4094: LD_INT 0
4096: ST_TO_ADDR
// uc_nation := 0 ;
4097: LD_ADDR_OWVAR 21
4101: PUSH
4102: LD_INT 0
4104: ST_TO_ADDR
// for i = 1 to 4 do
4105: LD_ADDR_VAR 0 2
4109: PUSH
4110: DOUBLE
4111: LD_INT 1
4113: DEC
4114: ST_TO_ADDR
4115: LD_INT 4
4117: PUSH
4118: FOR_TO
4119: IFFALSE 4150
// begin InitHc ;
4121: CALL_OW 19
// hc_class := class_apeman ;
4125: LD_ADDR_OWVAR 28
4129: PUSH
4130: LD_INT 12
4132: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4133: CALL_OW 44
4137: PPUSH
4138: LD_INT 13
4140: PPUSH
4141: LD_INT 0
4143: PPUSH
4144: CALL_OW 49
// end ;
4148: GO 4118
4150: POP
4151: POP
// end ; end_of_file
4152: LD_VAR 0 1
4156: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4157: LD_INT 0
4159: PPUSH
4160: PPUSH
4161: PPUSH
4162: PPUSH
4163: PPUSH
// side := 8 ;
4164: LD_ADDR_VAR 0 3
4168: PUSH
4169: LD_INT 8
4171: ST_TO_ADDR
// uc_side := side ;
4172: LD_ADDR_OWVAR 20
4176: PUSH
4177: LD_VAR 0 3
4181: ST_TO_ADDR
// uc_nation := 2 ;
4182: LD_ADDR_OWVAR 21
4186: PUSH
4187: LD_INT 2
4189: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: LD_INT 22
4197: PUSH
4198: LD_VAR 0 3
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 21
4209: PUSH
4210: LD_INT 3
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PPUSH
4221: CALL_OW 69
4225: PUSH
4226: FOR_IN
4227: IFFALSE 4243
// SetBLevel ( i , 10 ) ;
4229: LD_VAR 0 2
4233: PPUSH
4234: LD_INT 10
4236: PPUSH
4237: CALL_OW 241
4241: GO 4226
4243: POP
4244: POP
// if KurtStatus then
4245: LD_EXP 3
4249: IFFALSE 4272
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4251: LD_ADDR_EXP 59
4255: PUSH
4256: LD_STRING Kurt
4258: PPUSH
4259: LD_INT 0
4261: PPUSH
4262: LD_STRING 
4264: PPUSH
4265: CALL 64261 0 3
4269: ST_TO_ADDR
4270: GO 4294
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4272: LD_ADDR_EXP 59
4276: PUSH
4277: LD_STRING AltKurt
4279: PPUSH
4280: LD_EXP 1
4284: NOT
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64261 0 3
4293: ST_TO_ADDR
// if not Kurt then
4294: LD_EXP 59
4298: NOT
4299: IFFALSE 4325
// begin InitHc ;
4301: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4305: LD_INT 1
4307: PPUSH
4308: LD_INT 10
4310: PPUSH
4311: CALL_OW 381
// Kurt := CreateHuman ;
4315: LD_ADDR_EXP 59
4319: PUSH
4320: CALL_OW 44
4324: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4325: LD_EXP 59
4329: PPUSH
4330: LD_INT 324
4332: PPUSH
4333: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4337: LD_ADDR_EXP 60
4341: PUSH
4342: LD_STRING Kozlov
4344: PPUSH
4345: LD_INT 0
4347: PPUSH
4348: LD_STRING 
4350: PPUSH
4351: CALL 64261 0 3
4355: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4356: LD_EXP 60
4360: PPUSH
4361: LD_INT 22
4363: PUSH
4364: LD_INT 8
4366: PUSH
4367: EMPTY
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 23
4373: PUSH
4374: LD_INT 3
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PUSH
4381: LD_INT 30
4383: PUSH
4384: LD_INT 8
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: PPUSH
4396: CALL_OW 69
4400: PUSH
4401: LD_INT 1
4403: ARRAY
4404: PPUSH
4405: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4409: LD_EXP 60
4413: PPUSH
4414: LD_INT 3
4416: PPUSH
4417: LD_INT 10
4419: PPUSH
4420: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4424: LD_ADDR_VAR 0 5
4428: PUSH
4429: LD_INT 22
4431: PUSH
4432: LD_VAR 0 3
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: LD_INT 30
4443: PUSH
4444: LD_INT 32
4446: PUSH
4447: EMPTY
4448: LIST
4449: LIST
4450: PUSH
4451: LD_INT 58
4453: PUSH
4454: EMPTY
4455: LIST
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: LIST
4461: PPUSH
4462: CALL_OW 69
4466: ST_TO_ADDR
// for i = 1 to 10 do
4467: LD_ADDR_VAR 0 2
4471: PUSH
4472: DOUBLE
4473: LD_INT 1
4475: DEC
4476: ST_TO_ADDR
4477: LD_INT 10
4479: PUSH
4480: FOR_TO
4481: IFFALSE 4553
// begin uc_nation := nation_nature ;
4483: LD_ADDR_OWVAR 21
4487: PUSH
4488: LD_INT 0
4490: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4491: LD_ADDR_OWVAR 28
4495: PUSH
4496: LD_INT 15
4498: ST_TO_ADDR
// hc_gallery :=  ;
4499: LD_ADDR_OWVAR 33
4503: PUSH
4504: LD_STRING 
4506: ST_TO_ADDR
// hc_name :=  ;
4507: LD_ADDR_OWVAR 26
4511: PUSH
4512: LD_STRING 
4514: ST_TO_ADDR
// un := CreateHuman ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: CALL_OW 44
4524: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4525: LD_VAR 0 4
4529: PPUSH
4530: LD_VAR 0 5
4534: PUSH
4535: LD_VAR 0 5
4539: PUSH
4540: LD_VAR 0 2
4544: MINUS
4545: ARRAY
4546: PPUSH
4547: CALL_OW 52
// end ;
4551: GO 4480
4553: POP
4554: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4555: LD_ADDR_VAR 0 5
4559: PUSH
4560: LD_STRING 12_kurt_squad
4562: PPUSH
4563: CALL_OW 31
4567: ST_TO_ADDR
// if tmp then
4568: LD_VAR 0 5
4572: IFFALSE 4606
// for i in tmp do
4574: LD_ADDR_VAR 0 2
4578: PUSH
4579: LD_VAR 0 5
4583: PUSH
4584: FOR_IN
4585: IFFALSE 4604
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4587: LD_VAR 0 2
4591: PPUSH
4592: LD_INT 5
4594: PPUSH
4595: LD_INT 0
4597: PPUSH
4598: CALL_OW 49
4602: GO 4584
4604: POP
4605: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4606: LD_INT 324
4608: PPUSH
4609: LD_INT 5
4611: PPUSH
4612: LD_STRING 
4614: PPUSH
4615: LD_INT 8
4617: PUSH
4618: LD_INT 9
4620: PUSH
4621: LD_INT 10
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: LIST
4628: PUSH
4629: LD_OWVAR 67
4633: ARRAY
4634: PPUSH
4635: LD_INT 3000
4637: PUSH
4638: LD_INT 500
4640: PUSH
4641: LD_INT 150
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: LIST
4648: PPUSH
4649: LD_INT 16
4651: PUSH
4652: LD_INT 6
4654: PUSH
4655: LD_INT 6
4657: PUSH
4658: LD_INT 8
4660: PUSH
4661: EMPTY
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: PPUSH
4667: CALL 74785 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4671: LD_ADDR_EXP 101
4675: PUSH
4676: LD_EXP 101
4680: PPUSH
4681: LD_INT 3
4683: PPUSH
4684: LD_INT 22
4686: PUSH
4687: LD_VAR 0 3
4691: PUSH
4692: EMPTY
4693: LIST
4694: LIST
4695: PUSH
4696: LD_INT 23
4698: PUSH
4699: LD_INT 2
4701: PUSH
4702: EMPTY
4703: LIST
4704: LIST
4705: PUSH
4706: LD_INT 3
4708: PUSH
4709: LD_INT 21
4711: PUSH
4712: LD_INT 2
4714: PUSH
4715: EMPTY
4716: LIST
4717: LIST
4718: PUSH
4719: EMPTY
4720: LIST
4721: LIST
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: LIST
4727: PPUSH
4728: CALL_OW 69
4732: PUSH
4733: LD_EXP 59
4737: DIFF
4738: PPUSH
4739: CALL_OW 1
4743: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4744: LD_INT 1
4746: PPUSH
4747: LD_INT 7
4749: PPUSH
4750: CALL_OW 383
// Friend := CreateHuman ;
4754: LD_ADDR_EXP 61
4758: PUSH
4759: CALL_OW 44
4763: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4764: LD_INT 14
4766: PPUSH
4767: LD_INT 3
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 29
4775: PPUSH
4776: LD_INT 100
4778: PPUSH
4779: CALL 71376 0 5
// powellBomb := CreateVehicle ;
4783: LD_ADDR_EXP 62
4787: PUSH
4788: CALL_OW 45
4792: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4793: LD_EXP 62
4797: PPUSH
4798: LD_INT 90
4800: PPUSH
4801: LD_INT 51
4803: PPUSH
4804: LD_INT 0
4806: PPUSH
4807: CALL_OW 48
// end ;
4811: LD_VAR 0 1
4815: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4816: LD_INT 0
4818: PPUSH
4819: PPUSH
4820: PPUSH
// if IsLive ( kozlov_fac ) then
4821: LD_INT 332
4823: PPUSH
4824: CALL_OW 300
4828: IFFALSE 4832
// exit ;
4830: GO 5399
// ComExitBuilding ( Kozlov ) ;
4832: LD_EXP 60
4836: PPUSH
4837: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4841: LD_EXP 60
4845: PPUSH
4846: CALL_OW 257
4850: PUSH
4851: LD_INT 2
4853: NONEQUAL
4854: IFFALSE 4889
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4856: LD_EXP 60
4860: PPUSH
4861: LD_INT 324
4863: PPUSH
4864: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4868: LD_EXP 60
4872: PPUSH
4873: LD_INT 2
4875: PPUSH
4876: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4880: LD_EXP 60
4884: PPUSH
4885: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4889: LD_EXP 60
4893: PPUSH
4894: LD_INT 2
4896: PPUSH
4897: LD_INT 93
4899: PPUSH
4900: LD_INT 32
4902: PPUSH
4903: LD_INT 3
4905: PPUSH
4906: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4910: LD_INT 35
4912: PPUSH
4913: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4917: LD_INT 22
4919: PUSH
4920: LD_INT 8
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PUSH
4927: LD_INT 30
4929: PUSH
4930: LD_INT 3
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 23
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 57
4949: PUSH
4950: EMPTY
4951: LIST
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: LIST
4957: LIST
4958: PPUSH
4959: CALL_OW 69
4963: IFFALSE 4910
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4965: LD_ADDR_VAR 0 2
4969: PUSH
4970: LD_INT 22
4972: PUSH
4973: LD_INT 8
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: PUSH
4980: LD_INT 30
4982: PUSH
4983: LD_INT 3
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: PUSH
4990: LD_INT 23
4992: PUSH
4993: LD_INT 3
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: PUSH
5000: LD_INT 57
5002: PUSH
5003: EMPTY
5004: LIST
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: PPUSH
5012: CALL_OW 69
5016: PUSH
5017: LD_INT 1
5019: ARRAY
5020: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5021: LD_INT 22
5023: PUSH
5024: LD_INT 8
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 23
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 30
5043: PUSH
5044: LD_INT 21
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: LIST
5055: PPUSH
5056: CALL_OW 69
5060: NOT
5061: IFFALSE 5139
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5063: LD_EXP 60
5067: PPUSH
5068: LD_INT 21
5070: PPUSH
5071: LD_INT 97
5073: PPUSH
5074: LD_INT 36
5076: PPUSH
5077: LD_INT 5
5079: PPUSH
5080: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5091: LD_INT 22
5093: PUSH
5094: LD_INT 8
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: LD_INT 23
5103: PUSH
5104: LD_INT 3
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 30
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: PUSH
5121: LD_INT 57
5123: PUSH
5124: EMPTY
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: LIST
5132: PPUSH
5133: CALL_OW 69
5137: IFFALSE 5084
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5139: LD_INT 22
5141: PUSH
5142: LD_INT 8
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PUSH
5149: LD_INT 23
5151: PUSH
5152: LD_INT 3
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 30
5161: PUSH
5162: LD_INT 18
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: NOT
5179: IFFALSE 5257
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5181: LD_EXP 60
5185: PPUSH
5186: LD_INT 18
5188: PPUSH
5189: LD_INT 89
5191: PPUSH
5192: LD_INT 32
5194: PPUSH
5195: LD_INT 1
5197: PPUSH
5198: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5202: LD_INT 35
5204: PPUSH
5205: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5209: LD_INT 22
5211: PUSH
5212: LD_INT 8
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: PUSH
5219: LD_INT 23
5221: PUSH
5222: LD_INT 3
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: PUSH
5229: LD_INT 30
5231: PUSH
5232: LD_INT 18
5234: PUSH
5235: EMPTY
5236: LIST
5237: LIST
5238: PUSH
5239: LD_INT 57
5241: PUSH
5242: EMPTY
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: PPUSH
5251: CALL_OW 69
5255: IFFALSE 5202
// end ; lab := kozlov_lab ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: LD_INT 336
5264: ST_TO_ADDR
// if not lab then
5265: LD_VAR 0 3
5269: NOT
5270: IFFALSE 5274
// exit ;
5272: GO 5399
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5274: LD_EXP 60
5278: PPUSH
5279: LD_VAR 0 3
5283: PUSH
5284: LD_INT 1
5286: ARRAY
5287: PPUSH
5288: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5292: LD_EXP 60
5296: PPUSH
5297: LD_INT 4
5299: PPUSH
5300: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5304: LD_VAR 0 3
5308: PUSH
5309: LD_INT 1
5311: ARRAY
5312: PPUSH
5313: LD_INT 25
5315: PPUSH
5316: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5320: LD_INT 35
5322: PPUSH
5323: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5327: LD_INT 25
5329: PPUSH
5330: LD_INT 8
5332: PPUSH
5333: CALL_OW 321
5337: PUSH
5338: LD_INT 2
5340: EQUAL
5341: IFFALSE 5320
// ComExitBuilding ( Kozlov ) ;
5343: LD_EXP 60
5347: PPUSH
5348: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5352: LD_EXP 60
5356: PPUSH
5357: LD_VAR 0 2
5361: PPUSH
5362: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5366: LD_EXP 60
5370: PPUSH
5371: LD_INT 3
5373: PPUSH
5374: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5378: LD_VAR 0 2
5382: PPUSH
5383: LD_INT 23
5385: PPUSH
5386: LD_INT 3
5388: PPUSH
5389: LD_INT 1
5391: PPUSH
5392: LD_INT 48
5394: PPUSH
5395: CALL_OW 125
// end ;
5399: LD_VAR 0 1
5403: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5404: LD_EXP 22
5408: NOT
5409: PUSH
5410: LD_EXP 15
5414: PUSH
5415: LD_INT 6
5417: GREATEREQUAL
5418: AND
5419: IFFALSE 5500
5421: GO 5423
5423: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5424: LD_INT 3
5426: PPUSH
5427: LD_INT 3
5429: PPUSH
5430: CALL 58054 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5434: LD_INT 3
5436: PPUSH
5437: LD_INT 14
5439: PUSH
5440: LD_INT 1
5442: PUSH
5443: LD_INT 1
5445: PUSH
5446: LD_INT 28
5448: PUSH
5449: EMPTY
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 14
5457: PUSH
5458: LD_INT 1
5460: PUSH
5461: LD_INT 1
5463: PUSH
5464: LD_INT 28
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_INT 14
5475: PUSH
5476: LD_INT 1
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 28
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PPUSH
5496: CALL 57917 0 2
// end ;
5500: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5501: LD_EXP 22
5505: NOT
5506: PUSH
5507: LD_EXP 15
5511: PUSH
5512: LD_INT 6
5514: GREATEREQUAL
5515: AND
5516: PUSH
5517: LD_INT 3
5519: PPUSH
5520: LD_INT 1
5522: PPUSH
5523: CALL 59335 0 2
5527: NOT
5528: AND
5529: IFFALSE 6369
5531: GO 5533
5533: DISABLE
5534: LD_INT 0
5536: PPUSH
5537: PPUSH
5538: PPUSH
// begin enable ;
5539: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5540: LD_INT 22
5542: PUSH
5543: LD_INT 8
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 23
5552: PUSH
5553: LD_INT 2
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: LD_INT 30
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: PPUSH
5575: CALL_OW 69
5579: NOT
5580: IFFALSE 5584
// exit ;
5582: GO 6369
// if Prob ( 40 ) then
5584: LD_INT 40
5586: PPUSH
5587: CALL_OW 13
5591: IFFALSE 5718
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 14
5598: PUSH
5599: LD_INT 1
5601: PUSH
5602: LD_INT 2
5604: PUSH
5605: LD_INT 28
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 14
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 28
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 14
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 28
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 14
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 28
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 14
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 28
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 14
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 26
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: LIST
5711: PPUSH
5712: CALL 57917 0 2
// end else
5716: GO 5909
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5718: LD_INT 3
5720: PPUSH
5721: LD_INT 14
5723: PUSH
5724: LD_INT 1
5726: PUSH
5727: LD_INT 2
5729: PUSH
5730: LD_INT 27
5732: PUSH
5733: LD_INT 26
5735: PUSH
5736: LD_INT 26
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: PUSH
5750: EMPTY
5751: LIST
5752: LIST
5753: LIST
5754: LIST
5755: PUSH
5756: LD_INT 14
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: LD_INT 2
5764: PUSH
5765: LD_INT 27
5767: PUSH
5768: LD_INT 26
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: PUSH
5779: LD_OWVAR 67
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 14
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: LD_INT 26
5805: PUSH
5806: LD_INT 29
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: PUSH
5814: LD_OWVAR 67
5818: ARRAY
5819: PUSH
5820: EMPTY
5821: LIST
5822: LIST
5823: LIST
5824: LIST
5825: PUSH
5826: LD_INT 13
5828: PUSH
5829: LD_INT 1
5831: PUSH
5832: LD_INT 2
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: LD_INT 29
5840: PUSH
5841: LD_INT 29
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_OWVAR 67
5853: ARRAY
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 13
5863: PUSH
5864: LD_INT 1
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 14
5881: PUSH
5882: LD_INT 1
5884: PUSH
5885: LD_INT 2
5887: PUSH
5888: LD_INT 26
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PPUSH
5905: CALL 57917 0 2
// end ; repeat wait ( 0 0$1 ) ;
5909: LD_INT 35
5911: PPUSH
5912: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5916: LD_INT 3
5918: PPUSH
5919: LD_INT 1
5921: PPUSH
5922: CALL 59335 0 2
5926: PUSH
5927: LD_INT 6
5929: GREATEREQUAL
5930: IFFALSE 5909
// wait ( 0 0$30 ) ;
5932: LD_INT 1050
5934: PPUSH
5935: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5939: LD_ADDR_VAR 0 2
5943: PUSH
5944: LD_INT 3
5946: PPUSH
5947: LD_INT 1
5949: PPUSH
5950: CALL 59335 0 2
5954: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5955: LD_ADDR_EXP 120
5959: PUSH
5960: LD_EXP 120
5964: PPUSH
5965: LD_INT 3
5967: PPUSH
5968: LD_EXP 120
5972: PUSH
5973: LD_INT 3
5975: ARRAY
5976: PUSH
5977: LD_VAR 0 2
5981: DIFF
5982: PPUSH
5983: CALL_OW 1
5987: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5988: LD_ADDR_VAR 0 3
5992: PUSH
5993: LD_INT 0
5995: PPUSH
5996: LD_INT 2
5998: PPUSH
5999: CALL_OW 12
6003: ST_TO_ADDR
// if target then
6004: LD_VAR 0 3
6008: IFFALSE 6136
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6010: LD_ADDR_VAR 0 2
6014: PUSH
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_INT 24
6022: PUSH
6023: LD_INT 250
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PPUSH
6030: CALL_OW 72
6034: ST_TO_ADDR
// for i in tmp do
6035: LD_ADDR_VAR 0 1
6039: PUSH
6040: LD_VAR 0 2
6044: PUSH
6045: FOR_IN
6046: IFFALSE 6086
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6048: LD_VAR 0 1
6052: PPUSH
6053: LD_INT 89
6055: PPUSH
6056: LD_INT 71
6058: PPUSH
6059: CALL_OW 297
6063: PUSH
6064: LD_INT 9
6066: GREATER
6067: IFFALSE 6084
// ComMoveXY ( i , 89 , 71 ) ;
6069: LD_VAR 0 1
6073: PPUSH
6074: LD_INT 89
6076: PPUSH
6077: LD_INT 71
6079: PPUSH
6080: CALL_OW 111
6084: GO 6045
6086: POP
6087: POP
// wait ( 0 0$1 ) ;
6088: LD_INT 35
6090: PPUSH
6091: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6095: LD_VAR 0 2
6099: PPUSH
6100: LD_INT 92
6102: PUSH
6103: LD_INT 89
6105: PUSH
6106: LD_INT 71
6108: PUSH
6109: LD_INT 9
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: PPUSH
6118: CALL_OW 72
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: LD_INT 1
6130: MINUS
6131: GREATEREQUAL
6132: IFFALSE 6010
// end else
6134: GO 6260
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6136: LD_ADDR_VAR 0 2
6140: PUSH
6141: LD_VAR 0 2
6145: PPUSH
6146: LD_INT 24
6148: PUSH
6149: LD_INT 250
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: PPUSH
6156: CALL_OW 72
6160: ST_TO_ADDR
// for i in tmp do
6161: LD_ADDR_VAR 0 1
6165: PUSH
6166: LD_VAR 0 2
6170: PUSH
6171: FOR_IN
6172: IFFALSE 6212
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 125
6181: PPUSH
6182: LD_INT 129
6184: PPUSH
6185: CALL_OW 297
6189: PUSH
6190: LD_INT 9
6192: GREATER
6193: IFFALSE 6210
// ComMoveXY ( i , 125 , 129 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 125
6202: PPUSH
6203: LD_INT 129
6205: PPUSH
6206: CALL_OW 111
6210: GO 6171
6212: POP
6213: POP
// wait ( 0 0$1 ) ;
6214: LD_INT 35
6216: PPUSH
6217: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6221: LD_VAR 0 2
6225: PPUSH
6226: LD_INT 92
6228: PUSH
6229: LD_INT 125
6231: PUSH
6232: LD_INT 129
6234: PUSH
6235: LD_INT 9
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: PPUSH
6244: CALL_OW 72
6248: PUSH
6249: LD_VAR 0 2
6253: PUSH
6254: LD_INT 1
6256: MINUS
6257: GREATEREQUAL
6258: IFFALSE 6136
// end ; repeat wait ( 0 0$1 ) ;
6260: LD_INT 35
6262: PPUSH
6263: CALL_OW 67
// for i in tmp do
6267: LD_ADDR_VAR 0 1
6271: PUSH
6272: LD_VAR 0 2
6276: PUSH
6277: FOR_IN
6278: IFFALSE 6360
// begin if GetLives ( i ) > 251 then
6280: LD_VAR 0 1
6284: PPUSH
6285: CALL_OW 256
6289: PUSH
6290: LD_INT 251
6292: GREATER
6293: IFFALSE 6331
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6295: LD_VAR 0 1
6299: PPUSH
6300: LD_INT 81
6302: PUSH
6303: LD_INT 8
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: PPUSH
6310: CALL_OW 69
6314: PPUSH
6315: LD_VAR 0 1
6319: PPUSH
6320: CALL_OW 74
6324: PPUSH
6325: CALL_OW 115
6329: GO 6358
// if IsDead ( i ) then
6331: LD_VAR 0 1
6335: PPUSH
6336: CALL_OW 301
6340: IFFALSE 6358
// tmp := tmp diff i ;
6342: LD_ADDR_VAR 0 2
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: LD_VAR 0 1
6356: DIFF
6357: ST_TO_ADDR
// end ;
6358: GO 6277
6360: POP
6361: POP
// until not tmp ;
6362: LD_VAR 0 2
6366: NOT
6367: IFFALSE 6260
// end ;
6369: PPOPN 3
6371: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6372: LD_EXP 22
6376: NOT
6377: PUSH
6378: LD_EXP 15
6382: PUSH
6383: LD_INT 6
6385: GREATEREQUAL
6386: AND
6387: PUSH
6388: LD_OWVAR 67
6392: PUSH
6393: LD_INT 1
6395: GREATER
6396: AND
6397: IFFALSE 6914
6399: GO 6401
6401: DISABLE
6402: LD_INT 0
6404: PPUSH
6405: PPUSH
6406: PPUSH
// begin enable ;
6407: ENABLE
// tmp := [ ] ;
6408: LD_ADDR_VAR 0 3
6412: PUSH
6413: EMPTY
6414: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: DOUBLE
6421: LD_INT 1
6423: DEC
6424: ST_TO_ADDR
6425: LD_INT 4
6427: PUSH
6428: LD_INT 6
6430: PUSH
6431: LD_INT 7
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: LIST
6438: PUSH
6439: LD_OWVAR 67
6443: ARRAY
6444: PUSH
6445: FOR_TO
6446: IFFALSE 6606
// begin uc_side := 8 ;
6448: LD_ADDR_OWVAR 20
6452: PUSH
6453: LD_INT 8
6455: ST_TO_ADDR
// uc_nation := 2 ;
6456: LD_ADDR_OWVAR 21
6460: PUSH
6461: LD_INT 2
6463: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6464: LD_INT 13
6466: PUSH
6467: LD_INT 14
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 1
6476: PPUSH
6477: LD_INT 2
6479: PPUSH
6480: CALL_OW 12
6484: ARRAY
6485: PPUSH
6486: LD_INT 1
6488: PPUSH
6489: LD_INT 5
6491: PPUSH
6492: LD_INT 27
6494: PUSH
6495: LD_INT 28
6497: PUSH
6498: LD_INT 26
6500: PUSH
6501: LD_INT 25
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 4
6515: PPUSH
6516: CALL_OW 12
6520: ARRAY
6521: PPUSH
6522: LD_INT 88
6524: PPUSH
6525: CALL 71376 0 5
// un := CreateVehicle ;
6529: LD_ADDR_VAR 0 2
6533: PUSH
6534: CALL_OW 45
6538: ST_TO_ADDR
// tmp := tmp ^ un ;
6539: LD_ADDR_VAR 0 3
6543: PUSH
6544: LD_VAR 0 3
6548: PUSH
6549: LD_VAR 0 2
6553: ADD
6554: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6555: LD_VAR 0 2
6559: PPUSH
6560: LD_INT 3
6562: PPUSH
6563: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6567: LD_VAR 0 2
6571: PPUSH
6572: LD_INT 30
6574: PPUSH
6575: LD_INT 0
6577: PPUSH
6578: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6582: LD_VAR 0 2
6586: PPUSH
6587: LD_INT 16
6589: PPUSH
6590: LD_INT 11
6592: PPUSH
6593: CALL_OW 111
// wait ( 0 0$2 ) ;
6597: LD_INT 70
6599: PPUSH
6600: CALL_OW 67
// end ;
6604: GO 6445
6606: POP
6607: POP
// for i = 1 to Difficulty do
6608: LD_ADDR_VAR 0 1
6612: PUSH
6613: DOUBLE
6614: LD_INT 1
6616: DEC
6617: ST_TO_ADDR
6618: LD_OWVAR 67
6622: PUSH
6623: FOR_TO
6624: IFFALSE 6749
// begin uc_side := 8 ;
6626: LD_ADDR_OWVAR 20
6630: PUSH
6631: LD_INT 8
6633: ST_TO_ADDR
// uc_nation := 2 ;
6634: LD_ADDR_OWVAR 21
6638: PUSH
6639: LD_INT 2
6641: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6642: LD_INT 0
6644: PPUSH
6645: LD_INT 8
6647: PPUSH
6648: LD_INT 8
6650: PUSH
6651: LD_INT 8
6653: PUSH
6654: LD_INT 9
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: PUSH
6662: LD_OWVAR 67
6666: ARRAY
6667: PPUSH
6668: CALL_OW 380
// un := CreateHuman ;
6672: LD_ADDR_VAR 0 2
6676: PUSH
6677: CALL_OW 44
6681: ST_TO_ADDR
// tmp := tmp ^ un ;
6682: LD_ADDR_VAR 0 3
6686: PUSH
6687: LD_VAR 0 3
6691: PUSH
6692: LD_VAR 0 2
6696: ADD
6697: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6698: LD_VAR 0 2
6702: PPUSH
6703: LD_INT 3
6705: PPUSH
6706: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6710: LD_VAR 0 2
6714: PPUSH
6715: LD_INT 30
6717: PPUSH
6718: LD_INT 0
6720: PPUSH
6721: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6725: LD_VAR 0 2
6729: PPUSH
6730: LD_INT 16
6732: PPUSH
6733: LD_INT 11
6735: PPUSH
6736: CALL_OW 111
// wait ( 0 0$2 ) ;
6740: LD_INT 70
6742: PPUSH
6743: CALL_OW 67
// end ;
6747: GO 6623
6749: POP
6750: POP
// repeat wait ( 0 0$1 ) ;
6751: LD_INT 35
6753: PPUSH
6754: CALL_OW 67
// for i in tmp do
6758: LD_ADDR_VAR 0 1
6762: PUSH
6763: LD_VAR 0 3
6767: PUSH
6768: FOR_IN
6769: IFFALSE 6905
// begin if GetLives ( i ) > 250 then
6771: LD_VAR 0 1
6775: PPUSH
6776: CALL_OW 256
6780: PUSH
6781: LD_INT 250
6783: GREATER
6784: IFFALSE 6876
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6786: LD_INT 81
6788: PUSH
6789: LD_INT 8
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 91
6798: PUSH
6799: LD_VAR 0 1
6803: PUSH
6804: LD_INT 10
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: NOT
6821: IFFALSE 6840
// ComAgressiveMove ( i , 67 , 110 ) else
6823: LD_VAR 0 1
6827: PPUSH
6828: LD_INT 67
6830: PPUSH
6831: LD_INT 110
6833: PPUSH
6834: CALL_OW 114
6838: GO 6874
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6840: LD_VAR 0 1
6844: PPUSH
6845: LD_INT 81
6847: PUSH
6848: LD_INT 8
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 69
6859: PPUSH
6860: LD_VAR 0 1
6864: PPUSH
6865: CALL_OW 74
6869: PPUSH
6870: CALL_OW 115
// end else
6874: GO 6903
// if IsDead ( i ) then
6876: LD_VAR 0 1
6880: PPUSH
6881: CALL_OW 301
6885: IFFALSE 6903
// tmp := tmp diff i ;
6887: LD_ADDR_VAR 0 3
6891: PUSH
6892: LD_VAR 0 3
6896: PUSH
6897: LD_VAR 0 1
6901: DIFF
6902: ST_TO_ADDR
// end ;
6903: GO 6768
6905: POP
6906: POP
// until not tmp ;
6907: LD_VAR 0 3
6911: NOT
6912: IFFALSE 6751
// end ; end_of_file
6914: PPOPN 3
6916: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6917: LD_INT 0
6919: PPUSH
6920: PPUSH
6921: PPUSH
6922: PPUSH
6923: PPUSH
6924: PPUSH
6925: PPUSH
6926: PPUSH
6927: PPUSH
// side := 3 ;
6928: LD_ADDR_VAR 0 6
6932: PUSH
6933: LD_INT 3
6935: ST_TO_ADDR
// uc_side := side ;
6936: LD_ADDR_OWVAR 20
6940: PUSH
6941: LD_VAR 0 6
6945: ST_TO_ADDR
// uc_nation := 3 ;
6946: LD_ADDR_OWVAR 21
6950: PUSH
6951: LD_INT 3
6953: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_INT 22
6961: PUSH
6962: LD_VAR 0 6
6966: PUSH
6967: EMPTY
6968: LIST
6969: LIST
6970: PUSH
6971: LD_INT 21
6973: PUSH
6974: LD_INT 3
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: FOR_IN
6991: IFFALSE 7007
// SetBLevel ( i , 10 ) ;
6993: LD_VAR 0 2
6997: PPUSH
6998: LD_INT 10
7000: PPUSH
7001: CALL_OW 241
7005: GO 6990
7007: POP
7008: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7009: LD_ADDR_VAR 0 9
7013: PUSH
7014: LD_INT 22
7016: PUSH
7017: LD_VAR 0 6
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 30
7028: PUSH
7029: LD_INT 34
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PPUSH
7040: CALL_OW 69
7044: ST_TO_ADDR
// if teleport then
7045: LD_VAR 0 9
7049: IFFALSE 7070
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7051: LD_VAR 0 9
7055: PUSH
7056: LD_INT 1
7058: ARRAY
7059: PPUSH
7060: LD_INT 123
7062: PPUSH
7063: LD_INT 122
7065: PPUSH
7066: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7070: LD_ADDR_EXP 63
7074: PUSH
7075: LD_STRING Platonov
7077: PPUSH
7078: CALL_OW 25
7082: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7083: LD_ADDR_EXP 64
7087: PUSH
7088: LD_STRING Kovalyuk
7090: PPUSH
7091: CALL_OW 25
7095: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7096: LD_ADDR_EXP 66
7100: PUSH
7101: LD_STRING Yakotich
7103: PPUSH
7104: CALL_OW 25
7108: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7109: LD_ADDR_EXP 65
7113: PUSH
7114: LD_STRING Bystrov
7116: PPUSH
7117: CALL_OW 25
7121: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7122: LD_ADDR_EXP 67
7126: PUSH
7127: LD_STRING Gleb
7129: PPUSH
7130: CALL_OW 25
7134: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7135: LD_STRING 03_Cornel
7137: PPUSH
7138: CALL_OW 28
7142: IFFALSE 7190
// begin Bierezov := NewCharacter ( Mikhail ) ;
7144: LD_ADDR_EXP 68
7148: PUSH
7149: LD_STRING Mikhail
7151: PPUSH
7152: CALL_OW 25
7156: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7157: LD_EXP 68
7161: PPUSH
7162: LD_INT 197
7164: PPUSH
7165: LD_INT 111
7167: PPUSH
7168: LD_INT 9
7170: PPUSH
7171: LD_INT 0
7173: PPUSH
7174: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7178: LD_EXP 68
7182: PPUSH
7183: LD_INT 3
7185: PPUSH
7186: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7190: LD_EXP 63
7194: PPUSH
7195: LD_INT 126
7197: PPUSH
7198: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7202: LD_EXP 64
7206: PPUSH
7207: LD_INT 134
7209: PPUSH
7210: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7214: LD_EXP 66
7218: PPUSH
7219: LD_INT 197
7221: PPUSH
7222: LD_INT 111
7224: PPUSH
7225: LD_INT 9
7227: PPUSH
7228: LD_INT 0
7230: PPUSH
7231: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7235: LD_EXP 65
7239: PPUSH
7240: LD_INT 197
7242: PPUSH
7243: LD_INT 111
7245: PPUSH
7246: LD_INT 9
7248: PPUSH
7249: LD_INT 0
7251: PPUSH
7252: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7256: LD_EXP 67
7260: PPUSH
7261: LD_INT 197
7263: PPUSH
7264: LD_INT 111
7266: PPUSH
7267: LD_INT 9
7269: PPUSH
7270: LD_INT 0
7272: PPUSH
7273: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7277: LD_ADDR_VAR 0 5
7281: PUSH
7282: LD_INT 126
7284: PPUSH
7285: LD_INT 4
7287: PPUSH
7288: LD_STRING zhukov
7290: PPUSH
7291: LD_INT 9
7293: PUSH
7294: LD_INT 10
7296: PUSH
7297: LD_INT 10
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: LIST
7304: PUSH
7305: LD_OWVAR 67
7309: ARRAY
7310: PPUSH
7311: LD_INT 90000
7313: PUSH
7314: LD_INT 1000
7316: PUSH
7317: LD_INT 300
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: PPUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 8
7330: PUSH
7331: LD_INT 13
7333: PUSH
7334: LD_INT 8
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL 74785 0 6
7347: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7348: LD_ADDR_VAR 0 4
7352: PUSH
7353: LD_INT 267
7355: PPUSH
7356: CALL_OW 274
7360: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7361: LD_VAR 0 4
7365: PPUSH
7366: LD_INT 1
7368: PPUSH
7369: LD_INT 5000
7371: PPUSH
7372: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7376: LD_VAR 0 4
7380: PPUSH
7381: LD_INT 2
7383: PPUSH
7384: LD_INT 200
7386: PPUSH
7387: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7391: LD_VAR 0 4
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 200
7401: PPUSH
7402: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7406: LD_ADDR_EXP 101
7410: PUSH
7411: LD_EXP 101
7415: PPUSH
7416: LD_INT 2
7418: PPUSH
7419: LD_VAR 0 5
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_VAR 0 6
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PUSH
7436: LD_INT 3
7438: PUSH
7439: LD_INT 21
7441: PUSH
7442: LD_INT 2
7444: PUSH
7445: EMPTY
7446: LIST
7447: LIST
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PPUSH
7457: CALL_OW 69
7461: UNION
7462: PUSH
7463: LD_EXP 63
7467: DIFF
7468: PPUSH
7469: CALL_OW 1
7473: ST_TO_ADDR
// behemoths := [ ] ;
7474: LD_ADDR_EXP 71
7478: PUSH
7479: EMPTY
7480: ST_TO_ADDR
// behemothBuilders := [ ] ;
7481: LD_ADDR_EXP 72
7485: PUSH
7486: EMPTY
7487: ST_TO_ADDR
// if Kovalyuk then
7488: LD_EXP 64
7492: IFFALSE 7514
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7494: LD_ADDR_EXP 72
7498: PUSH
7499: LD_EXP 72
7503: PPUSH
7504: LD_EXP 64
7508: PPUSH
7509: CALL 107147 0 2
7513: ST_TO_ADDR
// j := 3 ;
7514: LD_ADDR_VAR 0 3
7518: PUSH
7519: LD_INT 3
7521: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_INT 22
7529: PUSH
7530: LD_INT 3
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 25
7539: PUSH
7540: LD_INT 3
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PPUSH
7551: CALL_OW 69
7555: PUSH
7556: LD_EXP 64
7560: DIFF
7561: PUSH
7562: FOR_IN
7563: IFFALSE 7613
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7565: LD_ADDR_EXP 72
7569: PUSH
7570: LD_EXP 72
7574: PPUSH
7575: LD_VAR 0 2
7579: PPUSH
7580: CALL 107147 0 2
7584: ST_TO_ADDR
// j := j - 1 ;
7585: LD_ADDR_VAR 0 3
7589: PUSH
7590: LD_VAR 0 3
7594: PUSH
7595: LD_INT 1
7597: MINUS
7598: ST_TO_ADDR
// if j = 0 then
7599: LD_VAR 0 3
7603: PUSH
7604: LD_INT 0
7606: EQUAL
7607: IFFALSE 7611
// break ;
7609: GO 7613
// end ;
7611: GO 7562
7613: POP
7614: POP
// end ;
7615: LD_VAR 0 1
7619: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7620: LD_INT 0
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
7626: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7627: LD_ADDR_VAR 0 4
7631: PUSH
7632: LD_INT 209
7634: PUSH
7635: LD_INT 149
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PUSH
7642: LD_INT 219
7644: PUSH
7645: LD_INT 154
7647: PUSH
7648: EMPTY
7649: LIST
7650: LIST
7651: PUSH
7652: LD_INT 223
7654: PUSH
7655: LD_INT 149
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 232
7664: PUSH
7665: LD_INT 155
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: ST_TO_ADDR
// if not behemothBuilders then
7678: LD_EXP 72
7682: NOT
7683: IFFALSE 7687
// exit ;
7685: GO 7791
// j := 1 ;
7687: LD_ADDR_VAR 0 3
7691: PUSH
7692: LD_INT 1
7694: ST_TO_ADDR
// for i in behemothBuilders do
7695: LD_ADDR_VAR 0 2
7699: PUSH
7700: LD_EXP 72
7704: PUSH
7705: FOR_IN
7706: IFFALSE 7789
// begin if IsInUnit ( i ) then
7708: LD_VAR 0 2
7712: PPUSH
7713: CALL_OW 310
7717: IFFALSE 7728
// ComExitBuilding ( i ) ;
7719: LD_VAR 0 2
7723: PPUSH
7724: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7728: LD_VAR 0 2
7732: PPUSH
7733: LD_INT 37
7735: PPUSH
7736: LD_VAR 0 4
7740: PUSH
7741: LD_VAR 0 3
7745: ARRAY
7746: PUSH
7747: LD_INT 1
7749: ARRAY
7750: PPUSH
7751: LD_VAR 0 4
7755: PUSH
7756: LD_VAR 0 3
7760: ARRAY
7761: PUSH
7762: LD_INT 2
7764: ARRAY
7765: PPUSH
7766: LD_INT 0
7768: PPUSH
7769: CALL_OW 230
// j := j + 1 ;
7773: LD_ADDR_VAR 0 3
7777: PUSH
7778: LD_VAR 0 3
7782: PUSH
7783: LD_INT 1
7785: PLUS
7786: ST_TO_ADDR
// end ;
7787: GO 7705
7789: POP
7790: POP
// end ;
7791: LD_VAR 0 1
7795: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7796: LD_INT 24
7798: PPUSH
7799: LD_INT 30
7801: PUSH
7802: LD_INT 37
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PPUSH
7809: CALL_OW 70
7813: IFFALSE 7826
7815: GO 7817
7817: DISABLE
// behemothUnderConstruct := true ;
7818: LD_ADDR_EXP 26
7822: PUSH
7823: LD_INT 1
7825: ST_TO_ADDR
7826: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7827: LD_INT 3
7829: PPUSH
7830: CALL 107195 0 1
7834: PUSH
7835: LD_INT 22
7837: PUSH
7838: LD_INT 3
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: LD_INT 30
7847: PUSH
7848: LD_INT 37
7850: PUSH
7851: EMPTY
7852: LIST
7853: LIST
7854: PUSH
7855: EMPTY
7856: LIST
7857: LIST
7858: PPUSH
7859: CALL_OW 69
7863: NOT
7864: AND
7865: IFFALSE 8051
7867: GO 7869
7869: DISABLE
7870: LD_INT 0
7872: PPUSH
7873: PPUSH
// begin enable ;
7874: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7875: LD_ADDR_VAR 0 2
7879: PUSH
7880: LD_INT 3
7882: PPUSH
7883: CALL 107195 0 1
7887: ST_TO_ADDR
// for i in tmp do
7888: LD_ADDR_VAR 0 1
7892: PUSH
7893: LD_VAR 0 2
7897: PUSH
7898: FOR_IN
7899: IFFALSE 8049
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7901: LD_VAR 0 1
7905: PPUSH
7906: LD_INT 9
7908: PPUSH
7909: CALL_OW 308
7913: PUSH
7914: LD_VAR 0 1
7918: PPUSH
7919: CALL_OW 110
7923: PUSH
7924: LD_INT 2
7926: EQUAL
7927: NOT
7928: AND
7929: IFFALSE 7943
// SetTag ( i , 2 ) ;
7931: LD_VAR 0 1
7935: PPUSH
7936: LD_INT 2
7938: PPUSH
7939: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7943: LD_INT 81
7945: PUSH
7946: LD_INT 3
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PUSH
7953: LD_INT 91
7955: PUSH
7956: LD_VAR 0 1
7960: PUSH
7961: LD_INT 12
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: LIST
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PPUSH
7973: CALL_OW 69
7977: NOT
7978: PUSH
7979: LD_VAR 0 1
7983: PPUSH
7984: CALL_OW 110
7988: PUSH
7989: LD_INT 2
7991: EQUAL
7992: NOT
7993: AND
7994: IFFALSE 8013
// ComAgressiveMove ( i , 64 , 93 ) else
7996: LD_VAR 0 1
8000: PPUSH
8001: LD_INT 64
8003: PPUSH
8004: LD_INT 93
8006: PPUSH
8007: CALL_OW 114
8011: GO 8047
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8013: LD_VAR 0 1
8017: PPUSH
8018: LD_INT 81
8020: PUSH
8021: LD_INT 3
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PPUSH
8028: CALL_OW 69
8032: PPUSH
8033: LD_VAR 0 1
8037: PPUSH
8038: CALL_OW 74
8042: PPUSH
8043: CALL_OW 115
// end ;
8047: GO 7898
8049: POP
8050: POP
// end ;
8051: PPOPN 2
8053: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8054: LD_INT 0
8056: PPUSH
8057: PPUSH
8058: PPUSH
// result := [ ] ;
8059: LD_ADDR_VAR 0 2
8063: PUSH
8064: EMPTY
8065: ST_TO_ADDR
// uc_side := 6 ;
8066: LD_ADDR_OWVAR 20
8070: PUSH
8071: LD_INT 6
8073: ST_TO_ADDR
// uc_nation := 3 ;
8074: LD_ADDR_OWVAR 21
8078: PUSH
8079: LD_INT 3
8081: ST_TO_ADDR
// case strength of 1 :
8082: LD_VAR 0 1
8086: PUSH
8087: LD_INT 1
8089: DOUBLE
8090: EQUAL
8091: IFTRUE 8095
8093: GO 8233
8095: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8096: LD_ADDR_VAR 0 3
8100: PUSH
8101: DOUBLE
8102: LD_INT 1
8104: DEC
8105: ST_TO_ADDR
8106: LD_INT 4
8108: PUSH
8109: LD_INT 5
8111: PUSH
8112: LD_INT 6
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PUSH
8126: FOR_TO
8127: IFFALSE 8229
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8129: LD_INT 22
8131: PUSH
8132: LD_INT 24
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: PUSH
8139: LD_VAR 0 3
8143: PUSH
8144: LD_INT 2
8146: MOD
8147: PUSH
8148: LD_INT 1
8150: PLUS
8151: ARRAY
8152: PPUSH
8153: LD_INT 1
8155: PUSH
8156: LD_INT 3
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PUSH
8163: LD_INT 1
8165: PPUSH
8166: LD_INT 2
8168: PPUSH
8169: CALL_OW 12
8173: ARRAY
8174: PPUSH
8175: LD_INT 3
8177: PPUSH
8178: LD_INT 43
8180: PUSH
8181: LD_INT 44
8183: PUSH
8184: LD_INT 45
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: LIST
8191: PUSH
8192: LD_INT 1
8194: PPUSH
8195: LD_INT 3
8197: PPUSH
8198: CALL_OW 12
8202: ARRAY
8203: PPUSH
8204: LD_INT 80
8206: PPUSH
8207: CALL 71376 0 5
// result := result union CreateVehicle ;
8211: LD_ADDR_VAR 0 2
8215: PUSH
8216: LD_VAR 0 2
8220: PUSH
8221: CALL_OW 45
8225: UNION
8226: ST_TO_ADDR
// end ;
8227: GO 8126
8229: POP
8230: POP
// end ; 2 :
8231: GO 9177
8233: LD_INT 2
8235: DOUBLE
8236: EQUAL
8237: IFTRUE 8241
8239: GO 8397
8241: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8242: LD_ADDR_VAR 0 3
8246: PUSH
8247: DOUBLE
8248: LD_INT 1
8250: DEC
8251: ST_TO_ADDR
8252: LD_INT 5
8254: PUSH
8255: LD_INT 6
8257: PUSH
8258: LD_INT 7
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: LIST
8265: PUSH
8266: LD_OWVAR 67
8270: ARRAY
8271: PUSH
8272: FOR_TO
8273: IFFALSE 8393
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8275: LD_INT 22
8277: PUSH
8278: LD_INT 24
8280: PUSH
8281: LD_INT 24
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: LIST
8288: PUSH
8289: LD_VAR 0 3
8293: PUSH
8294: LD_INT 3
8296: MOD
8297: PUSH
8298: LD_INT 1
8300: PLUS
8301: ARRAY
8302: PPUSH
8303: LD_INT 1
8305: PUSH
8306: LD_INT 3
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: PUSH
8313: LD_INT 1
8315: PPUSH
8316: LD_INT 2
8318: PPUSH
8319: CALL_OW 12
8323: ARRAY
8324: PPUSH
8325: LD_INT 3
8327: PPUSH
8328: LD_INT 43
8330: PUSH
8331: LD_INT 44
8333: PUSH
8334: LD_INT 45
8336: PUSH
8337: LD_INT 44
8339: PUSH
8340: LD_INT 46
8342: PUSH
8343: LD_INT 46
8345: PUSH
8346: EMPTY
8347: LIST
8348: LIST
8349: LIST
8350: LIST
8351: LIST
8352: LIST
8353: PUSH
8354: LD_VAR 0 3
8358: PUSH
8359: LD_INT 6
8361: MOD
8362: PUSH
8363: LD_INT 1
8365: PLUS
8366: ARRAY
8367: PPUSH
8368: LD_INT 80
8370: PPUSH
8371: CALL 71376 0 5
// result := result union CreateVehicle ;
8375: LD_ADDR_VAR 0 2
8379: PUSH
8380: LD_VAR 0 2
8384: PUSH
8385: CALL_OW 45
8389: UNION
8390: ST_TO_ADDR
// end ;
8391: GO 8272
8393: POP
8394: POP
// end ; 3 :
8395: GO 9177
8397: LD_INT 3
8399: DOUBLE
8400: EQUAL
8401: IFTRUE 8405
8403: GO 8561
8405: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8406: LD_ADDR_VAR 0 3
8410: PUSH
8411: DOUBLE
8412: LD_INT 1
8414: DEC
8415: ST_TO_ADDR
8416: LD_INT 5
8418: PUSH
8419: LD_INT 7
8421: PUSH
8422: LD_INT 8
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: LIST
8429: PUSH
8430: LD_OWVAR 67
8434: ARRAY
8435: PUSH
8436: FOR_TO
8437: IFFALSE 8557
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8439: LD_INT 22
8441: PUSH
8442: LD_INT 24
8444: PUSH
8445: LD_INT 24
8447: PUSH
8448: EMPTY
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_VAR 0 3
8457: PUSH
8458: LD_INT 3
8460: MOD
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: ARRAY
8466: PPUSH
8467: LD_INT 1
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 1
8479: PPUSH
8480: LD_INT 2
8482: PPUSH
8483: CALL_OW 12
8487: ARRAY
8488: PPUSH
8489: LD_INT 3
8491: PPUSH
8492: LD_INT 43
8494: PUSH
8495: LD_INT 47
8497: PUSH
8498: LD_INT 45
8500: PUSH
8501: LD_INT 45
8503: PUSH
8504: LD_INT 46
8506: PUSH
8507: LD_INT 46
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: LIST
8514: LIST
8515: LIST
8516: LIST
8517: PUSH
8518: LD_VAR 0 3
8522: PUSH
8523: LD_INT 6
8525: MOD
8526: PUSH
8527: LD_INT 1
8529: PLUS
8530: ARRAY
8531: PPUSH
8532: LD_INT 80
8534: PPUSH
8535: CALL 71376 0 5
// result := result union CreateVehicle ;
8539: LD_ADDR_VAR 0 2
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: CALL_OW 45
8553: UNION
8554: ST_TO_ADDR
// end ;
8555: GO 8436
8557: POP
8558: POP
// end ; 4 :
8559: GO 9177
8561: LD_INT 4
8563: DOUBLE
8564: EQUAL
8565: IFTRUE 8569
8567: GO 9176
8569: POP
// begin uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8578: LD_ADDR_VAR 0 3
8582: PUSH
8583: DOUBLE
8584: LD_INT 1
8586: DEC
8587: ST_TO_ADDR
8588: LD_INT 6
8590: PUSH
8591: LD_INT 8
8593: PUSH
8594: LD_INT 9
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: LIST
8601: PUSH
8602: LD_OWVAR 67
8606: ARRAY
8607: PUSH
8608: FOR_TO
8609: IFFALSE 8729
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8611: LD_INT 22
8613: PUSH
8614: LD_INT 24
8616: PUSH
8617: LD_INT 24
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: LIST
8624: PUSH
8625: LD_VAR 0 3
8629: PUSH
8630: LD_INT 3
8632: MOD
8633: PUSH
8634: LD_INT 1
8636: PLUS
8637: ARRAY
8638: PPUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PUSH
8649: LD_INT 1
8651: PPUSH
8652: LD_INT 2
8654: PPUSH
8655: CALL_OW 12
8659: ARRAY
8660: PPUSH
8661: LD_INT 3
8663: PPUSH
8664: LD_INT 45
8666: PUSH
8667: LD_INT 47
8669: PUSH
8670: LD_INT 47
8672: PUSH
8673: LD_INT 45
8675: PUSH
8676: LD_INT 46
8678: PUSH
8679: LD_INT 46
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_VAR 0 3
8694: PUSH
8695: LD_INT 6
8697: MOD
8698: PUSH
8699: LD_INT 1
8701: PLUS
8702: ARRAY
8703: PPUSH
8704: LD_INT 80
8706: PPUSH
8707: CALL 71376 0 5
// result := result union CreateVehicle ;
8711: LD_ADDR_VAR 0 2
8715: PUSH
8716: LD_VAR 0 2
8720: PUSH
8721: CALL_OW 45
8725: UNION
8726: ST_TO_ADDR
// end ;
8727: GO 8608
8729: POP
8730: POP
// if not KappaStatus then
8731: LD_EXP 2
8735: NOT
8736: IFFALSE 8971
// begin uc_nation := 1 ;
8738: LD_ADDR_OWVAR 21
8742: PUSH
8743: LD_INT 1
8745: ST_TO_ADDR
// for i = 1 to 3 do
8746: LD_ADDR_VAR 0 3
8750: PUSH
8751: DOUBLE
8752: LD_INT 1
8754: DEC
8755: ST_TO_ADDR
8756: LD_INT 3
8758: PUSH
8759: FOR_TO
8760: IFFALSE 8896
// begin j := rand ( 0 , 1 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 0
8769: PPUSH
8770: LD_INT 1
8772: PPUSH
8773: CALL_OW 12
8777: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8778: LD_INT 3
8780: PUSH
8781: LD_INT 5
8783: PUSH
8784: LD_INT 5
8786: PUSH
8787: LD_INT 4
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: LIST
8794: LIST
8795: PUSH
8796: LD_VAR 0 4
8800: PUSH
8801: LD_INT 1
8803: PPUSH
8804: LD_INT 3
8806: PPUSH
8807: CALL_OW 12
8811: PLUS
8812: ARRAY
8813: PPUSH
8814: LD_INT 1
8816: PUSH
8817: LD_INT 3
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: LD_INT 1
8826: PPUSH
8827: LD_INT 2
8829: PPUSH
8830: CALL_OW 12
8834: ARRAY
8835: PPUSH
8836: LD_INT 3
8838: PPUSH
8839: LD_INT 9
8841: PUSH
8842: LD_INT 7
8844: PUSH
8845: LD_INT 6
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: LD_VAR 0 4
8857: PUSH
8858: LD_INT 1
8860: PPUSH
8861: LD_INT 2
8863: PPUSH
8864: CALL_OW 12
8868: PLUS
8869: ARRAY
8870: PPUSH
8871: LD_INT 85
8873: PPUSH
8874: CALL 71376 0 5
// result := result union CreateVehicle ;
8878: LD_ADDR_VAR 0 2
8882: PUSH
8883: LD_VAR 0 2
8887: PUSH
8888: CALL_OW 45
8892: UNION
8893: ST_TO_ADDR
// end ;
8894: GO 8759
8896: POP
8897: POP
// if vsevolodFirstAttack then
8898: LD_EXP 24
8902: IFFALSE 8969
// begin vsevolodFirstAttack := false ;
8904: LD_ADDR_EXP 24
8908: PUSH
8909: LD_INT 0
8911: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8912: LD_INT 5
8914: PPUSH
8915: LD_INT 3
8917: PPUSH
8918: LD_INT 1
8920: PPUSH
8921: LD_INT 6
8923: PPUSH
8924: LD_INT 100
8926: PPUSH
8927: CALL 71376 0 5
// sewiVeh := CreateVehicle ;
8931: LD_ADDR_EXP 70
8935: PUSH
8936: CALL_OW 45
8940: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8941: LD_EXP 70
8945: PPUSH
8946: LD_INT 1
8948: PPUSH
8949: CALL_OW 242
// result := result union sewiVeh ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_VAR 0 2
8962: PUSH
8963: LD_EXP 70
8967: UNION
8968: ST_TO_ADDR
// end ; end else
8969: GO 9174
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9174
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// uc_nation := 3 ;
8985: LD_ADDR_OWVAR 21
8989: PUSH
8990: LD_INT 3
8992: ST_TO_ADDR
// for i = 1 to 3 do
8993: LD_ADDR_VAR 0 3
8997: PUSH
8998: DOUBLE
8999: LD_INT 1
9001: DEC
9002: ST_TO_ADDR
9003: LD_INT 3
9005: PUSH
9006: FOR_TO
9007: IFFALSE 9115
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9009: LD_INT 22
9011: PUSH
9012: LD_INT 24
9014: PUSH
9015: LD_INT 24
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: LIST
9022: PUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 3
9030: MOD
9031: PUSH
9032: LD_INT 1
9034: PLUS
9035: ARRAY
9036: PPUSH
9037: LD_INT 1
9039: PUSH
9040: LD_INT 3
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: LD_INT 1
9049: PPUSH
9050: LD_INT 2
9052: PPUSH
9053: CALL_OW 12
9057: ARRAY
9058: PPUSH
9059: LD_INT 3
9061: PPUSH
9062: LD_INT 45
9064: PUSH
9065: LD_INT 47
9067: PUSH
9068: LD_INT 47
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: LIST
9075: PUSH
9076: LD_VAR 0 3
9080: PUSH
9081: LD_INT 3
9083: MOD
9084: PUSH
9085: LD_INT 1
9087: PLUS
9088: ARRAY
9089: PPUSH
9090: LD_INT 80
9092: PPUSH
9093: CALL 71376 0 5
// result := result union CreateVehicle ;
9097: LD_ADDR_VAR 0 2
9101: PUSH
9102: LD_VAR 0 2
9106: PUSH
9107: CALL_OW 45
9111: UNION
9112: ST_TO_ADDR
// end ;
9113: GO 9006
9115: POP
9116: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9117: LD_INT 24
9119: PPUSH
9120: LD_INT 3
9122: PPUSH
9123: LD_INT 1
9125: PPUSH
9126: LD_INT 47
9128: PPUSH
9129: LD_INT 100
9131: PPUSH
9132: CALL 71376 0 5
// sewiVeh := CreateVehicle ;
9136: LD_ADDR_EXP 70
9140: PUSH
9141: CALL_OW 45
9145: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9146: LD_EXP 70
9150: PPUSH
9151: LD_INT 1
9153: PPUSH
9154: CALL_OW 242
// result := result union sewiVeh ;
9158: LD_ADDR_VAR 0 2
9162: PUSH
9163: LD_VAR 0 2
9167: PUSH
9168: LD_EXP 70
9172: UNION
9173: ST_TO_ADDR
// end ; end ; end ;
9174: GO 9177
9176: POP
// end ;
9177: LD_VAR 0 2
9181: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9182: LD_EXP 16
9186: IFFALSE 9944
9188: GO 9190
9190: DISABLE
9191: LD_INT 0
9193: PPUSH
9194: PPUSH
9195: PPUSH
9196: PPUSH
9197: PPUSH
9198: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9199: LD_ADDR_VAR 0 4
9203: PUSH
9204: LD_INT 11
9206: PUSH
9207: LD_INT 12
9209: PUSH
9210: EMPTY
9211: LIST
9212: LIST
9213: ST_TO_ADDR
// time := [ 4 4$20 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9214: LD_ADDR_VAR 0 3
9218: PUSH
9219: LD_INT 9100
9221: PUSH
9222: LD_INT 7350
9224: PUSH
9225: LD_INT 6650
9227: PUSH
9228: EMPTY
9229: LIST
9230: LIST
9231: LIST
9232: PUSH
9233: LD_OWVAR 67
9237: ARRAY
9238: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9239: LD_ADDR_VAR 0 6
9243: PUSH
9244: LD_INT 70
9246: PUSH
9247: LD_INT 118
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: LD_INT 78
9256: PUSH
9257: LD_INT 31
9259: PUSH
9260: EMPTY
9261: LIST
9262: LIST
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: ST_TO_ADDR
// repeat if missionStage = 2 then
9268: LD_EXP 15
9272: PUSH
9273: LD_INT 2
9275: EQUAL
9276: IFFALSE 9287
// wait ( 1 1$30 ) else
9278: LD_INT 3150
9280: PPUSH
9281: CALL_OW 67
9285: GO 9296
// wait ( time ) ;
9287: LD_VAR 0 3
9291: PPUSH
9292: CALL_OW 67
// if missionStage = 6 then
9296: LD_EXP 15
9300: PUSH
9301: LD_INT 6
9303: EQUAL
9304: IFFALSE 9332
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9306: LD_INT 51
9308: PPUSH
9309: LD_INT 6
9311: PPUSH
9312: LD_INT 2
9314: PPUSH
9315: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9319: LD_INT 57
9321: PPUSH
9322: LD_INT 6
9324: PPUSH
9325: LD_INT 2
9327: PPUSH
9328: CALL_OW 322
// end ; if missionStage = 8 then
9332: LD_EXP 15
9336: PUSH
9337: LD_INT 8
9339: EQUAL
9340: IFFALSE 9368
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9342: LD_INT 52
9344: PPUSH
9345: LD_INT 6
9347: PPUSH
9348: LD_INT 2
9350: PPUSH
9351: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9355: LD_INT 58
9357: PPUSH
9358: LD_INT 6
9360: PPUSH
9361: LD_INT 2
9363: PPUSH
9364: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9368: LD_EXP 15
9372: PUSH
9373: LD_INT 10
9375: EQUAL
9376: PUSH
9377: LD_OWVAR 67
9381: PUSH
9382: LD_INT 1
9384: GREATER
9385: AND
9386: IFFALSE 9414
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9388: LD_INT 53
9390: PPUSH
9391: LD_INT 6
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9401: LD_INT 59
9403: PPUSH
9404: LD_INT 6
9406: PPUSH
9407: LD_INT 2
9409: PPUSH
9410: CALL_OW 322
// end ; if activeAttacks then
9414: LD_EXP 16
9418: IFFALSE 9938
// begin if missionStage = 2 then
9420: LD_EXP 15
9424: PUSH
9425: LD_INT 2
9427: EQUAL
9428: IFFALSE 9438
// strength := 1 ;
9430: LD_ADDR_VAR 0 5
9434: PUSH
9435: LD_INT 1
9437: ST_TO_ADDR
// if missionStage > 2 then
9438: LD_EXP 15
9442: PUSH
9443: LD_INT 2
9445: GREATER
9446: IFFALSE 9456
// strength := 2 ;
9448: LD_ADDR_VAR 0 5
9452: PUSH
9453: LD_INT 2
9455: ST_TO_ADDR
// if missionStage > 6 then
9456: LD_EXP 15
9460: PUSH
9461: LD_INT 6
9463: GREATER
9464: IFFALSE 9474
// strength := 3 ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 3
9473: ST_TO_ADDR
// if missionStage > 10 then
9474: LD_EXP 15
9478: PUSH
9479: LD_INT 10
9481: GREATER
9482: IFFALSE 9492
// strength := 4 ;
9484: LD_ADDR_VAR 0 5
9488: PUSH
9489: LD_INT 4
9491: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9492: LD_ADDR_VAR 0 2
9496: PUSH
9497: LD_VAR 0 5
9501: PPUSH
9502: CALL 8054 0 1
9506: ST_TO_ADDR
// for i in tmp do
9507: LD_ADDR_VAR 0 1
9511: PUSH
9512: LD_VAR 0 2
9516: PUSH
9517: FOR_IN
9518: IFFALSE 9618
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9520: LD_VAR 0 1
9524: PPUSH
9525: LD_VAR 0 4
9529: PUSH
9530: LD_INT 1
9532: PPUSH
9533: LD_INT 2
9535: PPUSH
9536: CALL_OW 12
9540: ARRAY
9541: PPUSH
9542: LD_INT 0
9544: PPUSH
9545: CALL_OW 49
// if i = sewiVeh then
9549: LD_VAR 0 1
9553: PUSH
9554: LD_EXP 70
9558: EQUAL
9559: IFFALSE 9594
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9561: LD_ADDR_EXP 69
9565: PUSH
9566: LD_STRING Vsevolod
9568: PPUSH
9569: LD_INT 0
9571: PPUSH
9572: LD_STRING 
9574: PPUSH
9575: CALL 64261 0 3
9579: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9580: LD_EXP 69
9584: PPUSH
9585: LD_VAR 0 1
9589: PPUSH
9590: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9594: LD_VAR 0 1
9598: PPUSH
9599: LD_INT 111
9601: PPUSH
9602: LD_INT 197
9604: PPUSH
9605: CALL_OW 111
// wait ( 0 0$2 ) ;
9609: LD_INT 70
9611: PPUSH
9612: CALL_OW 67
// end ;
9616: GO 9517
9618: POP
9619: POP
// repeat wait ( 0 0$1 ) ;
9620: LD_INT 35
9622: PPUSH
9623: CALL_OW 67
// for i in tmp do
9627: LD_ADDR_VAR 0 1
9631: PUSH
9632: LD_VAR 0 2
9636: PUSH
9637: FOR_IN
9638: IFFALSE 9919
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9640: LD_INT 81
9642: PUSH
9643: LD_INT 6
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 91
9652: PUSH
9653: LD_VAR 0 1
9657: PUSH
9658: LD_INT 12
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: LIST
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PPUSH
9670: CALL_OW 69
9674: IFFALSE 9732
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9676: LD_VAR 0 1
9680: PPUSH
9681: LD_INT 81
9683: PUSH
9684: LD_INT 6
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PUSH
9691: LD_INT 91
9693: PUSH
9694: LD_VAR 0 1
9698: PUSH
9699: LD_INT 12
9701: PUSH
9702: EMPTY
9703: LIST
9704: LIST
9705: LIST
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PPUSH
9711: CALL_OW 69
9715: PPUSH
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 74
9725: PPUSH
9726: CALL_OW 115
9730: GO 9917
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9732: LD_INT 9
9734: PPUSH
9735: LD_INT 81
9737: PUSH
9738: LD_INT 6
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: PPUSH
9745: CALL_OW 70
9749: IFFALSE 9883
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9751: LD_VAR 0 1
9755: PPUSH
9756: LD_VAR 0 6
9760: PUSH
9761: LD_INT 1
9763: ARRAY
9764: PUSH
9765: LD_INT 1
9767: ARRAY
9768: PPUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 1
9776: ARRAY
9777: PUSH
9778: LD_INT 2
9780: ARRAY
9781: PPUSH
9782: CALL_OW 297
9786: PUSH
9787: LD_INT 10
9789: GREATER
9790: PUSH
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_INT 9
9798: PPUSH
9799: CALL_OW 308
9803: NOT
9804: AND
9805: IFFALSE 9844
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9807: LD_VAR 0 1
9811: PPUSH
9812: LD_VAR 0 6
9816: PUSH
9817: LD_INT 1
9819: ARRAY
9820: PUSH
9821: LD_INT 1
9823: ARRAY
9824: PPUSH
9825: LD_VAR 0 6
9829: PUSH
9830: LD_INT 1
9832: ARRAY
9833: PUSH
9834: LD_INT 2
9836: ARRAY
9837: PPUSH
9838: CALL_OW 114
9842: GO 9881
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9844: LD_VAR 0 1
9848: PPUSH
9849: LD_INT 9
9851: PPUSH
9852: LD_INT 81
9854: PUSH
9855: LD_INT 6
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: PPUSH
9862: CALL_OW 70
9866: PPUSH
9867: LD_VAR 0 1
9871: PPUSH
9872: CALL_OW 74
9876: PPUSH
9877: CALL_OW 115
// end else
9881: GO 9917
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9883: LD_VAR 0 1
9887: PPUSH
9888: LD_INT 81
9890: PUSH
9891: LD_INT 6
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PPUSH
9898: CALL_OW 69
9902: PPUSH
9903: LD_VAR 0 1
9907: PPUSH
9908: CALL_OW 74
9912: PPUSH
9913: CALL_OW 115
// end ;
9917: GO 9637
9919: POP
9920: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9921: LD_INT 22
9923: PUSH
9924: LD_INT 6
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: PPUSH
9931: CALL_OW 69
9935: NOT
9936: IFFALSE 9620
// end ; until russianDestroyed ;
9938: LD_EXP 21
9942: IFFALSE 9268
// end ;
9944: PPOPN 6
9946: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9947: LD_EXP 21
9951: NOT
9952: PUSH
9953: LD_EXP 15
9957: PUSH
9958: LD_INT 6
9960: GREATEREQUAL
9961: AND
9962: PUSH
9963: LD_INT 2
9965: PPUSH
9966: LD_INT 1
9968: PPUSH
9969: CALL 59335 0 2
9973: NOT
9974: AND
9975: IFFALSE 10931
9977: GO 9979
9979: DISABLE
9980: LD_INT 0
9982: PPUSH
9983: PPUSH
9984: PPUSH
9985: PPUSH
// begin enable ;
9986: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9987: LD_INT 22
9989: PUSH
9990: LD_INT 3
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PUSH
9997: LD_INT 30
9999: PUSH
10000: LD_INT 3
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PPUSH
10011: CALL_OW 69
10015: NOT
10016: IFFALSE 10020
// exit ;
10018: GO 10931
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10020: LD_ADDR_VAR 0 4
10024: PUSH
10025: LD_INT 22
10027: PUSH
10028: LD_INT 3
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 30
10037: PUSH
10038: LD_INT 34
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: PPUSH
10049: CALL_OW 69
10053: ST_TO_ADDR
// if Prob ( 40 ) then
10054: LD_INT 40
10056: PPUSH
10057: CALL_OW 13
10061: IFFALSE 10188
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10063: LD_INT 2
10065: PPUSH
10066: LD_INT 22
10068: PUSH
10069: LD_INT 3
10071: PUSH
10072: LD_INT 3
10074: PUSH
10075: LD_INT 49
10077: PUSH
10078: EMPTY
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 22
10086: PUSH
10087: LD_INT 3
10089: PUSH
10090: LD_INT 3
10092: PUSH
10093: LD_INT 49
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: PUSH
10102: LD_INT 22
10104: PUSH
10105: LD_INT 3
10107: PUSH
10108: LD_INT 3
10110: PUSH
10111: LD_INT 49
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 24
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: LD_INT 3
10128: PUSH
10129: LD_INT 46
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 46
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 46
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: PPUSH
10182: CALL 57917 0 2
// end else
10186: GO 10311
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10188: LD_INT 2
10190: PPUSH
10191: LD_INT 24
10193: PUSH
10194: LD_INT 3
10196: PUSH
10197: LD_INT 3
10199: PUSH
10200: LD_INT 47
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: PUSH
10209: LD_INT 24
10211: PUSH
10212: LD_INT 3
10214: PUSH
10215: LD_INT 3
10217: PUSH
10218: LD_INT 47
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: PUSH
10227: LD_INT 24
10229: PUSH
10230: LD_INT 3
10232: PUSH
10233: LD_INT 3
10235: PUSH
10236: LD_INT 47
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 24
10247: PUSH
10248: LD_INT 3
10250: PUSH
10251: LD_INT 3
10253: PUSH
10254: LD_INT 46
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: PUSH
10263: LD_INT 24
10265: PUSH
10266: LD_INT 3
10268: PUSH
10269: LD_INT 3
10271: PUSH
10272: LD_INT 46
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: PUSH
10281: LD_INT 24
10283: PUSH
10284: LD_INT 3
10286: PUSH
10287: LD_INT 3
10289: PUSH
10290: LD_INT 46
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PPUSH
10307: CALL 57917 0 2
// end ; if Difficulty > 1 then
10311: LD_OWVAR 67
10315: PUSH
10316: LD_INT 1
10318: GREATER
10319: IFFALSE 10349
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10321: LD_INT 2
10323: PPUSH
10324: LD_INT 24
10326: PUSH
10327: LD_INT 3
10329: PUSH
10330: LD_INT 3
10332: PUSH
10333: LD_INT 47
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: EMPTY
10343: LIST
10344: PPUSH
10345: CALL 57917 0 2
// repeat wait ( 0 0$1 ) ;
10349: LD_INT 35
10351: PPUSH
10352: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10356: LD_INT 2
10358: PPUSH
10359: LD_INT 1
10361: PPUSH
10362: CALL 59335 0 2
10366: PUSH
10367: LD_INT 6
10369: PUSH
10370: LD_INT 7
10372: PUSH
10373: LD_INT 7
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: LIST
10380: PUSH
10381: LD_OWVAR 67
10385: ARRAY
10386: GREATEREQUAL
10387: IFFALSE 10349
// wait ( 0 0$30 ) ;
10389: LD_INT 1050
10391: PPUSH
10392: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10396: LD_ADDR_VAR 0 2
10400: PUSH
10401: LD_INT 2
10403: PPUSH
10404: LD_INT 1
10406: PPUSH
10407: CALL 59335 0 2
10411: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10412: LD_ADDR_EXP 120
10416: PUSH
10417: LD_EXP 120
10421: PPUSH
10422: LD_INT 2
10424: PPUSH
10425: LD_EXP 120
10429: PUSH
10430: LD_INT 2
10432: ARRAY
10433: PUSH
10434: LD_VAR 0 2
10438: DIFF
10439: PPUSH
10440: CALL_OW 1
10444: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10445: LD_ADDR_VAR 0 3
10449: PUSH
10450: LD_INT 0
10452: PPUSH
10453: LD_INT 1
10455: PPUSH
10456: CALL_OW 12
10460: ST_TO_ADDR
// if target then
10461: LD_VAR 0 3
10465: IFFALSE 10593
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10467: LD_ADDR_VAR 0 2
10471: PUSH
10472: LD_VAR 0 2
10476: PPUSH
10477: LD_INT 24
10479: PUSH
10480: LD_INT 250
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: PPUSH
10487: CALL_OW 72
10491: ST_TO_ADDR
// for i in tmp do
10492: LD_ADDR_VAR 0 1
10496: PUSH
10497: LD_VAR 0 2
10501: PUSH
10502: FOR_IN
10503: IFFALSE 10543
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10505: LD_VAR 0 1
10509: PPUSH
10510: LD_INT 139
10512: PPUSH
10513: LD_INT 89
10515: PPUSH
10516: CALL_OW 297
10520: PUSH
10521: LD_INT 9
10523: GREATER
10524: IFFALSE 10541
// ComMoveXY ( i , 139 , 89 ) ;
10526: LD_VAR 0 1
10530: PPUSH
10531: LD_INT 139
10533: PPUSH
10534: LD_INT 89
10536: PPUSH
10537: CALL_OW 111
10541: GO 10502
10543: POP
10544: POP
// wait ( 0 0$1 ) ;
10545: LD_INT 35
10547: PPUSH
10548: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10552: LD_VAR 0 2
10556: PPUSH
10557: LD_INT 92
10559: PUSH
10560: LD_INT 139
10562: PUSH
10563: LD_INT 89
10565: PUSH
10566: LD_INT 9
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: PPUSH
10575: CALL_OW 72
10579: PUSH
10580: LD_VAR 0 2
10584: PUSH
10585: LD_INT 1
10587: MINUS
10588: GREATEREQUAL
10589: IFFALSE 10467
// end else
10591: GO 10735
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10593: LD_VAR 0 2
10597: PPUSH
10598: LD_VAR 0 4
10602: PUSH
10603: LD_INT 1
10605: ARRAY
10606: PPUSH
10607: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10611: LD_ADDR_VAR 0 2
10615: PUSH
10616: LD_VAR 0 2
10620: PPUSH
10621: LD_INT 24
10623: PUSH
10624: LD_INT 250
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PPUSH
10631: CALL_OW 72
10635: ST_TO_ADDR
// for i in tmp do
10636: LD_ADDR_VAR 0 1
10640: PUSH
10641: LD_VAR 0 2
10645: PUSH
10646: FOR_IN
10647: IFFALSE 10687
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 124
10656: PPUSH
10657: LD_INT 139
10659: PPUSH
10660: CALL_OW 297
10664: PUSH
10665: LD_INT 9
10667: GREATER
10668: IFFALSE 10685
// ComMoveXY ( i , 124 , 139 ) ;
10670: LD_VAR 0 1
10674: PPUSH
10675: LD_INT 124
10677: PPUSH
10678: LD_INT 139
10680: PPUSH
10681: CALL_OW 111
10685: GO 10646
10687: POP
10688: POP
// wait ( 0 0$1 ) ;
10689: LD_INT 35
10691: PPUSH
10692: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10696: LD_VAR 0 2
10700: PPUSH
10701: LD_INT 92
10703: PUSH
10704: LD_INT 124
10706: PUSH
10707: LD_INT 139
10709: PUSH
10710: LD_INT 9
10712: PUSH
10713: EMPTY
10714: LIST
10715: LIST
10716: LIST
10717: LIST
10718: PPUSH
10719: CALL_OW 72
10723: PUSH
10724: LD_VAR 0 2
10728: PUSH
10729: LD_INT 1
10731: MINUS
10732: GREATEREQUAL
10733: IFFALSE 10611
// end ; repeat wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// for i in tmp do
10742: LD_ADDR_VAR 0 1
10746: PUSH
10747: LD_VAR 0 2
10751: PUSH
10752: FOR_IN
10753: IFFALSE 10922
// begin if GetLives ( i ) > 251 then
10755: LD_VAR 0 1
10759: PPUSH
10760: CALL_OW 256
10764: PUSH
10765: LD_INT 251
10767: GREATER
10768: IFFALSE 10893
// begin if GetWeapon ( i ) = ru_time_lapser then
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL_OW 264
10779: PUSH
10780: LD_INT 49
10782: EQUAL
10783: IFFALSE 10839
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_INT 2
10792: PUSH
10793: LD_INT 22
10795: PUSH
10796: LD_INT 1
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PUSH
10803: LD_INT 22
10805: PUSH
10806: LD_INT 8
10808: PUSH
10809: EMPTY
10810: LIST
10811: LIST
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 69
10822: PPUSH
10823: LD_VAR 0 1
10827: PPUSH
10828: CALL_OW 74
10832: PPUSH
10833: CALL_OW 112
10837: GO 10891
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10839: LD_VAR 0 1
10843: PPUSH
10844: LD_INT 2
10846: PUSH
10847: LD_INT 22
10849: PUSH
10850: LD_INT 1
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PUSH
10857: LD_INT 22
10859: PUSH
10860: LD_INT 8
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: LIST
10871: PPUSH
10872: CALL_OW 69
10876: PPUSH
10877: LD_VAR 0 1
10881: PPUSH
10882: CALL_OW 74
10886: PPUSH
10887: CALL_OW 115
// end else
10891: GO 10920
// if IsDead ( i ) then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 301
10902: IFFALSE 10920
// tmp := tmp diff i ;
10904: LD_ADDR_VAR 0 2
10908: PUSH
10909: LD_VAR 0 2
10913: PUSH
10914: LD_VAR 0 1
10918: DIFF
10919: ST_TO_ADDR
// end ;
10920: GO 10752
10922: POP
10923: POP
// until not tmp ;
10924: LD_VAR 0 2
10928: NOT
10929: IFFALSE 10735
// end ; end_of_file
10931: PPOPN 4
10933: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10934: LD_INT 0
10936: PPUSH
10937: PPUSH
10938: PPUSH
10939: PPUSH
10940: PPUSH
10941: PPUSH
// side := 7 ;
10942: LD_ADDR_VAR 0 5
10946: PUSH
10947: LD_INT 7
10949: ST_TO_ADDR
// uc_side := side ;
10950: LD_ADDR_OWVAR 20
10954: PUSH
10955: LD_VAR 0 5
10959: ST_TO_ADDR
// uc_nation := 1 ;
10960: LD_ADDR_OWVAR 21
10964: PUSH
10965: LD_INT 1
10967: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10968: LD_ADDR_VAR 0 2
10972: PUSH
10973: LD_INT 22
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 21
10987: PUSH
10988: LD_INT 3
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: PPUSH
10999: CALL_OW 69
11003: PUSH
11004: FOR_IN
11005: IFFALSE 11021
// SetBLevel ( i , 10 ) ;
11007: LD_VAR 0 2
11011: PPUSH
11012: LD_INT 10
11014: PPUSH
11015: CALL_OW 241
11019: GO 11004
11021: POP
11022: POP
// base := GetBase ( al_depot ) ;
11023: LD_ADDR_VAR 0 4
11027: PUSH
11028: LD_INT 2
11030: PPUSH
11031: CALL_OW 274
11035: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11036: LD_ADDR_VAR 0 6
11040: PUSH
11041: LD_INT 22
11043: PUSH
11044: LD_VAR 0 5
11048: PUSH
11049: EMPTY
11050: LIST
11051: LIST
11052: PUSH
11053: LD_INT 30
11055: PUSH
11056: LD_INT 34
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PPUSH
11067: CALL_OW 69
11071: ST_TO_ADDR
// if teleport then
11072: LD_VAR 0 6
11076: IFFALSE 11097
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11078: LD_VAR 0 6
11082: PUSH
11083: LD_INT 1
11085: ARRAY
11086: PPUSH
11087: LD_INT 262
11089: PPUSH
11090: LD_INT 119
11092: PPUSH
11093: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11097: LD_VAR 0 4
11101: PPUSH
11102: LD_INT 1
11104: PPUSH
11105: LD_INT 19500
11107: PPUSH
11108: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11112: LD_VAR 0 4
11116: PPUSH
11117: LD_INT 2
11119: PPUSH
11120: LD_INT 200
11122: PPUSH
11123: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11127: LD_VAR 0 4
11131: PPUSH
11132: LD_INT 3
11134: PPUSH
11135: LD_INT 650
11137: PPUSH
11138: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11142: LD_ADDR_EXP 73
11146: PUSH
11147: LD_STRING Roth
11149: PPUSH
11150: CALL_OW 25
11154: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11155: LD_ADDR_EXP 74
11159: PUSH
11160: LD_STRING Simms
11162: PPUSH
11163: LD_EXP 1
11167: NOT
11168: PPUSH
11169: LD_STRING 10c_
11171: PPUSH
11172: CALL 64261 0 3
11176: ST_TO_ADDR
// if not Simms then
11177: LD_EXP 74
11181: NOT
11182: IFFALSE 11212
// begin uc_nation := 1 ;
11184: LD_ADDR_OWVAR 21
11188: PUSH
11189: LD_INT 1
11191: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11192: LD_INT 2
11194: PPUSH
11195: LD_INT 10
11197: PPUSH
11198: CALL_OW 384
// Simms := CreateHuman ;
11202: LD_ADDR_EXP 74
11206: PUSH
11207: CALL_OW 44
11211: ST_TO_ADDR
// end ; uc_nation := 3 ;
11212: LD_ADDR_OWVAR 21
11216: PUSH
11217: LD_INT 3
11219: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11220: LD_ADDR_EXP 75
11224: PUSH
11225: LD_STRING Kirilenkova
11227: PPUSH
11228: CALL_OW 25
11232: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11233: LD_ADDR_EXP 89
11237: PUSH
11238: LD_STRING Oblukov
11240: PPUSH
11241: CALL_OW 25
11245: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11246: LD_ADDR_EXP 76
11250: PUSH
11251: LD_STRING Dolgov
11253: PPUSH
11254: CALL_OW 25
11258: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11259: LD_ADDR_EXP 77
11263: PUSH
11264: LD_STRING Petrosyan
11266: PPUSH
11267: CALL_OW 25
11271: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11272: LD_ADDR_EXP 88
11276: PUSH
11277: LD_STRING Scholtze
11279: PPUSH
11280: CALL_OW 25
11284: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11285: LD_ADDR_EXP 87
11289: PUSH
11290: LD_STRING Kapitsova
11292: PPUSH
11293: CALL_OW 25
11297: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11298: LD_ADDR_EXP 78
11302: PUSH
11303: LD_STRING Petrovova
11305: PPUSH
11306: CALL_OW 25
11310: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11311: LD_ADDR_EXP 79
11315: PUSH
11316: LD_STRING Kuzmov
11318: PPUSH
11319: CALL_OW 25
11323: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11324: LD_ADDR_EXP 86
11328: PUSH
11329: LD_STRING Karamazov
11331: PPUSH
11332: CALL_OW 25
11336: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11337: LD_STRING 13_Lipshchin_1
11339: PPUSH
11340: LD_INT 0
11342: PPUSH
11343: CALL_OW 30
11347: IFFALSE 11362
// Lipshchin := NewCharacter ( Lipshchin ) ;
11349: LD_ADDR_EXP 80
11353: PUSH
11354: LD_STRING Lipshchin
11356: PPUSH
11357: CALL_OW 25
11361: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11362: LD_STRING 13_Titov_1
11364: PPUSH
11365: LD_INT 0
11367: PPUSH
11368: CALL_OW 30
11372: IFFALSE 11387
// Titov := NewCharacter ( Titov ) ;
11374: LD_ADDR_EXP 82
11378: PUSH
11379: LD_STRING Titov
11381: PPUSH
11382: CALL_OW 25
11386: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11387: LD_STRING 13_Gnyevko_1
11389: PPUSH
11390: LD_INT 0
11392: PPUSH
11393: CALL_OW 30
11397: IFFALSE 11412
// Gnyevko := NewCharacter ( Gnyevko ) ;
11399: LD_ADDR_EXP 81
11403: PUSH
11404: LD_STRING Gnyevko
11406: PPUSH
11407: CALL_OW 25
11411: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11412: LD_STRING 13_Xavier_1
11414: PPUSH
11415: LD_INT 0
11417: PPUSH
11418: CALL_OW 30
11422: IFFALSE 11437
// Xavier := NewCharacter ( Xavier2 ) ;
11424: LD_ADDR_EXP 83
11428: PUSH
11429: LD_STRING Xavier2
11431: PPUSH
11432: CALL_OW 25
11436: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11437: LD_STRING 13_Belkov_1
11439: PPUSH
11440: LD_INT 0
11442: PPUSH
11443: CALL_OW 30
11447: IFFALSE 11462
// Belkov := NewCharacter ( Belkov ) ;
11449: LD_ADDR_EXP 84
11453: PUSH
11454: LD_STRING Belkov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// if not BurlakStatus then
11462: LD_EXP 9
11466: NOT
11467: IFFALSE 11482
// Burlak = NewCharacter ( Burlak ) ;
11469: LD_ADDR_EXP 85
11473: PUSH
11474: LD_STRING Burlak
11476: PPUSH
11477: CALL_OW 25
11481: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11482: LD_ADDR_VAR 0 3
11486: PUSH
11487: LD_EXP 73
11491: PUSH
11492: LD_EXP 75
11496: PUSH
11497: LD_EXP 89
11501: PUSH
11502: LD_EXP 76
11506: PUSH
11507: LD_EXP 77
11511: PUSH
11512: LD_EXP 88
11516: PUSH
11517: LD_EXP 87
11521: PUSH
11522: LD_EXP 78
11526: PUSH
11527: LD_EXP 79
11531: PUSH
11532: LD_EXP 86
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: ST_TO_ADDR
// if Simms then
11549: LD_EXP 74
11553: IFFALSE 11571
// tmp := tmp ^ Simms ;
11555: LD_ADDR_VAR 0 3
11559: PUSH
11560: LD_VAR 0 3
11564: PUSH
11565: LD_EXP 74
11569: ADD
11570: ST_TO_ADDR
// if Titov then
11571: LD_EXP 82
11575: IFFALSE 11593
// tmp := tmp ^ Titov ;
11577: LD_ADDR_VAR 0 3
11581: PUSH
11582: LD_VAR 0 3
11586: PUSH
11587: LD_EXP 82
11591: ADD
11592: ST_TO_ADDR
// if Lipshchin then
11593: LD_EXP 80
11597: IFFALSE 11615
// tmp := tmp ^ Lipshchin ;
11599: LD_ADDR_VAR 0 3
11603: PUSH
11604: LD_VAR 0 3
11608: PUSH
11609: LD_EXP 80
11613: ADD
11614: ST_TO_ADDR
// if Gnyevko then
11615: LD_EXP 81
11619: IFFALSE 11637
// tmp := tmp ^ Gnyevko ;
11621: LD_ADDR_VAR 0 3
11625: PUSH
11626: LD_VAR 0 3
11630: PUSH
11631: LD_EXP 81
11635: ADD
11636: ST_TO_ADDR
// if Xavier then
11637: LD_EXP 83
11641: IFFALSE 11659
// tmp := tmp ^ Xavier ;
11643: LD_ADDR_VAR 0 3
11647: PUSH
11648: LD_VAR 0 3
11652: PUSH
11653: LD_EXP 83
11657: ADD
11658: ST_TO_ADDR
// if Belkov then
11659: LD_EXP 84
11663: IFFALSE 11681
// tmp := tmp ^ Belkov ;
11665: LD_ADDR_VAR 0 3
11669: PUSH
11670: LD_VAR 0 3
11674: PUSH
11675: LD_EXP 84
11679: ADD
11680: ST_TO_ADDR
// if Burlak then
11681: LD_EXP 85
11685: IFFALSE 11703
// tmp := tmp ^ Burlak ;
11687: LD_ADDR_VAR 0 3
11691: PUSH
11692: LD_VAR 0 3
11696: PUSH
11697: LD_EXP 85
11701: ADD
11702: ST_TO_ADDR
// for i = 1 to 8 do
11703: LD_ADDR_VAR 0 2
11707: PUSH
11708: DOUBLE
11709: LD_INT 1
11711: DEC
11712: ST_TO_ADDR
11713: LD_INT 8
11715: PUSH
11716: FOR_TO
11717: IFFALSE 11783
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11719: LD_ADDR_OWVAR 21
11723: PUSH
11724: LD_INT 1
11726: PUSH
11727: LD_INT 3
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 1
11736: PPUSH
11737: LD_INT 2
11739: PPUSH
11740: CALL_OW 12
11744: ARRAY
11745: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11746: LD_INT 0
11748: PPUSH
11749: LD_VAR 0 2
11753: PUSH
11754: LD_INT 2
11756: DIV
11757: PPUSH
11758: LD_INT 10
11760: PPUSH
11761: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11765: LD_ADDR_VAR 0 3
11769: PUSH
11770: LD_VAR 0 3
11774: PUSH
11775: CALL_OW 44
11779: ADD
11780: ST_TO_ADDR
// end ;
11781: GO 11716
11783: POP
11784: POP
// for i in tmp do
11785: LD_ADDR_VAR 0 2
11789: PUSH
11790: LD_VAR 0 3
11794: PUSH
11795: FOR_IN
11796: IFFALSE 11821
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11798: LD_VAR 0 2
11802: PPUSH
11803: LD_INT 260
11805: PPUSH
11806: LD_INT 235
11808: PPUSH
11809: LD_INT 8
11811: PPUSH
11812: LD_INT 0
11814: PPUSH
11815: CALL_OW 50
11819: GO 11795
11821: POP
11822: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11823: LD_ADDR_EXP 101
11827: PUSH
11828: LD_EXP 101
11832: PPUSH
11833: LD_INT 1
11835: PPUSH
11836: LD_INT 22
11838: PUSH
11839: LD_VAR 0 5
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: LD_INT 21
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: EMPTY
11858: LIST
11859: LIST
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: PPUSH
11869: CALL_OW 69
11873: PUSH
11874: LD_EXP 73
11878: PUSH
11879: LD_EXP 74
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: DIFF
11888: PPUSH
11889: CALL_OW 1
11893: ST_TO_ADDR
// uc_side := 0 ;
11894: LD_ADDR_OWVAR 20
11898: PUSH
11899: LD_INT 0
11901: ST_TO_ADDR
// uc_nation := 0 ;
11902: LD_ADDR_OWVAR 21
11906: PUSH
11907: LD_INT 0
11909: ST_TO_ADDR
// for i = 1 to 5 do
11910: LD_ADDR_VAR 0 2
11914: PUSH
11915: DOUBLE
11916: LD_INT 1
11918: DEC
11919: ST_TO_ADDR
11920: LD_INT 5
11922: PUSH
11923: FOR_TO
11924: IFFALSE 11961
// begin InitHc ;
11926: CALL_OW 19
// hc_class := class_apeman ;
11930: LD_ADDR_OWVAR 28
11934: PUSH
11935: LD_INT 12
11937: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11938: CALL_OW 44
11942: PPUSH
11943: LD_INT 299
11945: PPUSH
11946: LD_INT 229
11948: PPUSH
11949: LD_INT 10
11951: PPUSH
11952: LD_INT 0
11954: PPUSH
11955: CALL_OW 50
// end ;
11959: GO 11923
11961: POP
11962: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11963: LD_EXP 73
11967: PPUSH
11968: LD_INT 259
11970: PPUSH
11971: LD_INT 235
11973: PPUSH
11974: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11978: LD_EXP 73
11982: PPUSH
11983: LD_INT 262
11985: PPUSH
11986: LD_INT 235
11988: PPUSH
11989: CALL_OW 178
// if Simms then
11993: LD_EXP 74
11997: IFFALSE 12028
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11999: LD_EXP 74
12003: PPUSH
12004: LD_INT 262
12006: PPUSH
12007: LD_INT 235
12009: PPUSH
12010: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12014: LD_EXP 74
12018: PPUSH
12019: LD_EXP 73
12023: PPUSH
12024: CALL_OW 179
// end ; end ;
12028: LD_VAR 0 1
12032: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12033: LD_EXP 31
12037: PUSH
12038: LD_EXP 23
12042: NOT
12043: AND
12044: IFFALSE 12220
12046: GO 12048
12048: DISABLE
12049: LD_INT 0
12051: PPUSH
12052: PPUSH
12053: PPUSH
// begin enable ;
12054: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12055: LD_ADDR_VAR 0 2
12059: PUSH
12060: LD_INT 81
12062: PUSH
12063: LD_INT 7
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 2
12072: PUSH
12073: LD_INT 32
12075: PUSH
12076: LD_INT 3
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 30
12085: PUSH
12086: LD_INT 30
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 30
12095: PUSH
12096: LD_INT 28
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 34
12105: PUSH
12106: LD_INT 49
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 34
12115: PUSH
12116: LD_INT 10
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 34
12125: PUSH
12126: LD_INT 8
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: LIST
12139: LIST
12140: LIST
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: PPUSH
12146: CALL_OW 69
12150: ST_TO_ADDR
// if not tmp then
12151: LD_VAR 0 2
12155: NOT
12156: IFFALSE 12160
// exit ;
12158: GO 12220
// target := tmp [ rand ( 1 , tmp ) ] ;
12160: LD_ADDR_VAR 0 3
12164: PUSH
12165: LD_VAR 0 2
12169: PUSH
12170: LD_INT 1
12172: PPUSH
12173: LD_VAR 0 2
12177: PPUSH
12178: CALL_OW 12
12182: ARRAY
12183: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12184: LD_VAR 0 3
12188: PPUSH
12189: CALL_OW 255
12193: PUSH
12194: LD_INT 1
12196: EQUAL
12197: IFFALSE 12208
// CenterNowOnUnits ( target ) ;
12199: LD_VAR 0 3
12203: PPUSH
12204: CALL_OW 87
// SetLives ( target , 0 ) ;
12208: LD_VAR 0 3
12212: PPUSH
12213: LD_INT 0
12215: PPUSH
12216: CALL_OW 234
// end ;
12220: PPOPN 3
12222: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12223: LD_EXP 23
12227: NOT
12228: PUSH
12229: LD_EXP 31
12233: AND
12234: IFFALSE 12756
12236: GO 12238
12238: DISABLE
12239: LD_INT 0
12241: PPUSH
12242: PPUSH
12243: PPUSH
// begin uc_side := 7 ;
12244: LD_ADDR_OWVAR 20
12248: PUSH
12249: LD_INT 7
12251: ST_TO_ADDR
// uc_nation := 1 ;
12252: LD_ADDR_OWVAR 21
12256: PUSH
12257: LD_INT 1
12259: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12260: LD_ADDR_VAR 0 3
12264: PUSH
12265: LD_INT 125
12267: PUSH
12268: LD_INT 163
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 185
12277: PUSH
12278: LD_INT 168
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 111
12287: PUSH
12288: LD_INT 97
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: LIST
12299: PPUSH
12300: CALL 107239 0 1
12304: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12305: LD_ADDR_EXP 90
12309: PUSH
12310: EMPTY
12311: ST_TO_ADDR
// for i = 1 to Difficulty do
12312: LD_ADDR_VAR 0 1
12316: PUSH
12317: DOUBLE
12318: LD_INT 1
12320: DEC
12321: ST_TO_ADDR
12322: LD_OWVAR 67
12326: PUSH
12327: FOR_TO
12328: IFFALSE 12486
// begin InitHc ;
12330: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12334: LD_INT 0
12336: PPUSH
12337: LD_INT 8
12339: PPUSH
12340: CALL_OW 381
// un := CreateHuman ;
12344: LD_ADDR_VAR 0 2
12348: PUSH
12349: CALL_OW 44
12353: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12354: LD_VAR 0 2
12358: PPUSH
12359: LD_INT 258
12361: PPUSH
12362: LD_INT 267
12364: PPUSH
12365: LD_INT 4
12367: PPUSH
12368: LD_INT 0
12370: PPUSH
12371: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12375: LD_ADDR_EXP 90
12379: PUSH
12380: LD_EXP 90
12384: PUSH
12385: LD_VAR 0 2
12389: UNION
12390: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12391: LD_VAR 0 2
12395: PPUSH
12396: LD_VAR 0 3
12400: PUSH
12401: LD_VAR 0 1
12405: ARRAY
12406: PUSH
12407: LD_INT 1
12409: ARRAY
12410: PPUSH
12411: LD_VAR 0 3
12415: PUSH
12416: LD_VAR 0 1
12420: ARRAY
12421: PUSH
12422: LD_INT 2
12424: ARRAY
12425: PPUSH
12426: LD_INT 4
12428: PPUSH
12429: LD_INT 1
12431: PPUSH
12432: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12436: LD_VAR 0 2
12440: PPUSH
12441: LD_VAR 0 3
12445: PUSH
12446: LD_VAR 0 1
12450: ARRAY
12451: PUSH
12452: LD_INT 1
12454: ARRAY
12455: PPUSH
12456: LD_VAR 0 3
12460: PUSH
12461: LD_VAR 0 1
12465: ARRAY
12466: PUSH
12467: LD_INT 2
12469: ARRAY
12470: PPUSH
12471: CALL_OW 171
// AddComInvisible ( un ) ;
12475: LD_VAR 0 2
12479: PPUSH
12480: CALL_OW 212
// end ;
12484: GO 12327
12486: POP
12487: POP
// repeat wait ( 0 0$20 ) ;
12488: LD_INT 700
12490: PPUSH
12491: CALL_OW 67
// for i in allianceSpecialForce do
12495: LD_ADDR_VAR 0 1
12499: PUSH
12500: LD_EXP 90
12504: PUSH
12505: FOR_IN
12506: IFFALSE 12741
// begin if IsInvisible ( i ) then
12508: LD_VAR 0 1
12512: PPUSH
12513: CALL_OW 571
12517: IFFALSE 12710
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12519: LD_ADDR_VAR 0 3
12523: PUSH
12524: LD_INT 22
12526: PUSH
12527: LD_INT 1
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: PUSH
12534: LD_INT 50
12536: PUSH
12537: EMPTY
12538: LIST
12539: PUSH
12540: LD_INT 56
12542: PUSH
12543: EMPTY
12544: LIST
12545: PUSH
12546: LD_INT 91
12548: PUSH
12549: LD_VAR 0 1
12553: PUSH
12554: LD_INT 25
12556: PUSH
12557: LD_INT 30
12559: PUSH
12560: LD_INT 35
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: LIST
12567: PUSH
12568: LD_OWVAR 67
12572: ARRAY
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 2
12581: PUSH
12582: LD_INT 25
12584: PUSH
12585: LD_INT 1
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 25
12594: PUSH
12595: LD_INT 2
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 25
12604: PUSH
12605: LD_INT 3
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: LD_INT 25
12614: PUSH
12615: LD_INT 4
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 25
12624: PUSH
12625: LD_INT 5
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 25
12634: PUSH
12635: LD_INT 8
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: LIST
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: PUSH
12651: EMPTY
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: PPUSH
12658: CALL_OW 69
12662: ST_TO_ADDR
// if not tmp then
12663: LD_VAR 0 3
12667: NOT
12668: IFFALSE 12672
// continue ;
12670: GO 12505
// if Prob ( 30 * Difficulty ) then
12672: LD_INT 30
12674: PUSH
12675: LD_OWVAR 67
12679: MUL
12680: PPUSH
12681: CALL_OW 13
12685: IFFALSE 12710
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12687: LD_VAR 0 3
12691: PUSH
12692: LD_INT 1
12694: PPUSH
12695: LD_VAR 0 3
12699: PPUSH
12700: CALL_OW 12
12704: ARRAY
12705: PPUSH
12706: CALL 30367 0 1
// end ; if IsDead ( i ) then
12710: LD_VAR 0 1
12714: PPUSH
12715: CALL_OW 301
12719: IFFALSE 12739
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12721: LD_ADDR_EXP 90
12725: PUSH
12726: LD_EXP 90
12730: PUSH
12731: LD_VAR 0 1
12735: DIFF
12736: ST_TO_ADDR
// continue ;
12737: GO 12505
// end ; end ;
12739: GO 12505
12741: POP
12742: POP
// until allianceDestroyed or not allianceSpecialForce ;
12743: LD_EXP 23
12747: PUSH
12748: LD_EXP 90
12752: NOT
12753: OR
12754: IFFALSE 12488
// end ;
12756: PPOPN 3
12758: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12759: LD_EXP 23
12763: NOT
12764: PUSH
12765: LD_EXP 31
12769: AND
12770: PUSH
12771: LD_INT 1
12773: PPUSH
12774: LD_INT 1
12776: PPUSH
12777: CALL 59335 0 2
12781: NOT
12782: AND
12783: IFFALSE 13750
12785: GO 12787
12787: DISABLE
12788: LD_INT 0
12790: PPUSH
12791: PPUSH
12792: PPUSH
12793: PPUSH
// begin enable ;
12794: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12795: LD_INT 22
12797: PUSH
12798: LD_INT 7
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: LD_INT 30
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PPUSH
12819: CALL_OW 69
12823: NOT
12824: IFFALSE 12828
// exit ;
12826: GO 13750
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12828: LD_ADDR_VAR 0 4
12832: PUSH
12833: LD_INT 22
12835: PUSH
12836: LD_INT 7
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: PUSH
12843: LD_INT 30
12845: PUSH
12846: LD_INT 34
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PUSH
12853: EMPTY
12854: LIST
12855: LIST
12856: PPUSH
12857: CALL_OW 69
12861: ST_TO_ADDR
// if Prob ( 40 ) then
12862: LD_INT 40
12864: PPUSH
12865: CALL_OW 13
12869: IFFALSE 12996
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 5
12876: PUSH
12877: LD_INT 3
12879: PUSH
12880: LD_INT 2
12882: PUSH
12883: LD_INT 6
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 5
12894: PUSH
12895: LD_INT 3
12897: PUSH
12898: LD_INT 2
12900: PUSH
12901: LD_INT 6
12903: PUSH
12904: EMPTY
12905: LIST
12906: LIST
12907: LIST
12908: LIST
12909: PUSH
12910: LD_INT 5
12912: PUSH
12913: LD_INT 3
12915: PUSH
12916: LD_INT 2
12918: PUSH
12919: LD_INT 6
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: PUSH
12928: LD_INT 24
12930: PUSH
12931: LD_INT 3
12933: PUSH
12934: LD_INT 3
12936: PUSH
12937: LD_INT 45
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 24
12948: PUSH
12949: LD_INT 3
12951: PUSH
12952: LD_INT 3
12954: PUSH
12955: LD_INT 47
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 24
12966: PUSH
12967: LD_INT 3
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: LD_INT 45
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: PPUSH
12990: CALL 57917 0 2
// end else
12994: GO 13119
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12996: LD_INT 1
12998: PPUSH
12999: LD_INT 24
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: LD_INT 47
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: PUSH
13017: LD_INT 24
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: LD_INT 47
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: PUSH
13035: LD_INT 5
13037: PUSH
13038: LD_INT 3
13040: PUSH
13041: LD_INT 2
13043: PUSH
13044: LD_INT 9
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 5
13055: PUSH
13056: LD_INT 3
13058: PUSH
13059: LD_INT 2
13061: PUSH
13062: LD_INT 9
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 24
13073: PUSH
13074: LD_INT 1
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 45
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 1
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 45
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PPUSH
13115: CALL 57917 0 2
// end ; if Difficulty > 1 then
13119: LD_OWVAR 67
13123: PUSH
13124: LD_INT 1
13126: GREATER
13127: IFFALSE 13157
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13129: LD_INT 1
13131: PPUSH
13132: LD_INT 24
13134: PUSH
13135: LD_INT 3
13137: PUSH
13138: LD_INT 3
13140: PUSH
13141: LD_INT 47
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: LIST
13148: LIST
13149: PUSH
13150: EMPTY
13151: LIST
13152: PPUSH
13153: CALL 57917 0 2
// repeat wait ( 0 0$1 ) ;
13157: LD_INT 35
13159: PPUSH
13160: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13164: LD_INT 1
13166: PPUSH
13167: LD_INT 1
13169: PPUSH
13170: CALL 59335 0 2
13174: PUSH
13175: LD_INT 6
13177: PUSH
13178: LD_INT 7
13180: PUSH
13181: LD_INT 7
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: PUSH
13189: LD_OWVAR 67
13193: ARRAY
13194: GREATEREQUAL
13195: IFFALSE 13157
// wait ( 0 0$40 ) ;
13197: LD_INT 1400
13199: PPUSH
13200: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13204: LD_ADDR_VAR 0 2
13208: PUSH
13209: LD_INT 1
13211: PPUSH
13212: LD_INT 1
13214: PPUSH
13215: CALL 59335 0 2
13219: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13220: LD_ADDR_EXP 120
13224: PUSH
13225: LD_EXP 120
13229: PPUSH
13230: LD_INT 1
13232: PPUSH
13233: LD_EXP 120
13237: PUSH
13238: LD_INT 1
13240: ARRAY
13241: PUSH
13242: LD_VAR 0 2
13246: DIFF
13247: PPUSH
13248: CALL_OW 1
13252: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13253: LD_ADDR_VAR 0 3
13257: PUSH
13258: LD_INT 0
13260: PPUSH
13261: LD_INT 1
13263: PPUSH
13264: CALL_OW 12
13268: ST_TO_ADDR
// if target then
13269: LD_VAR 0 3
13273: IFFALSE 13439
// begin for i in tmp do
13275: LD_ADDR_VAR 0 1
13279: PUSH
13280: LD_VAR 0 2
13284: PUSH
13285: FOR_IN
13286: IFFALSE 13311
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13288: LD_VAR 0 1
13292: PPUSH
13293: LD_INT 179
13295: PPUSH
13296: LD_INT 209
13298: PPUSH
13299: LD_INT 8
13301: PPUSH
13302: LD_INT 1
13304: PPUSH
13305: CALL_OW 483
13309: GO 13285
13311: POP
13312: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13313: LD_ADDR_VAR 0 2
13317: PUSH
13318: LD_VAR 0 2
13322: PPUSH
13323: LD_INT 24
13325: PUSH
13326: LD_INT 250
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL_OW 72
13337: ST_TO_ADDR
// for i in tmp do
13338: LD_ADDR_VAR 0 1
13342: PUSH
13343: LD_VAR 0 2
13347: PUSH
13348: FOR_IN
13349: IFFALSE 13389
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13351: LD_VAR 0 1
13355: PPUSH
13356: LD_INT 179
13358: PPUSH
13359: LD_INT 209
13361: PPUSH
13362: CALL_OW 297
13366: PUSH
13367: LD_INT 9
13369: GREATER
13370: IFFALSE 13387
// ComMoveXY ( i , 179 , 209 ) ;
13372: LD_VAR 0 1
13376: PPUSH
13377: LD_INT 179
13379: PPUSH
13380: LD_INT 209
13382: PPUSH
13383: CALL_OW 111
13387: GO 13348
13389: POP
13390: POP
// wait ( 0 0$1 ) ;
13391: LD_INT 35
13393: PPUSH
13394: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13398: LD_VAR 0 2
13402: PPUSH
13403: LD_INT 92
13405: PUSH
13406: LD_INT 179
13408: PUSH
13409: LD_INT 209
13411: PUSH
13412: LD_INT 9
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: PPUSH
13421: CALL_OW 72
13425: PUSH
13426: LD_VAR 0 2
13430: PUSH
13431: LD_INT 1
13433: MINUS
13434: GREATEREQUAL
13435: IFFALSE 13313
// end else
13437: GO 13601
// begin for i in tmp do
13439: LD_ADDR_VAR 0 1
13443: PUSH
13444: LD_VAR 0 2
13448: PUSH
13449: FOR_IN
13450: IFFALSE 13475
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13452: LD_VAR 0 1
13456: PPUSH
13457: LD_INT 285
13459: PPUSH
13460: LD_INT 163
13462: PPUSH
13463: LD_INT 8
13465: PPUSH
13466: LD_INT 1
13468: PPUSH
13469: CALL_OW 483
13473: GO 13449
13475: POP
13476: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13477: LD_ADDR_VAR 0 2
13481: PUSH
13482: LD_VAR 0 2
13486: PPUSH
13487: LD_INT 24
13489: PUSH
13490: LD_INT 250
13492: PUSH
13493: EMPTY
13494: LIST
13495: LIST
13496: PPUSH
13497: CALL_OW 72
13501: ST_TO_ADDR
// for i in tmp do
13502: LD_ADDR_VAR 0 1
13506: PUSH
13507: LD_VAR 0 2
13511: PUSH
13512: FOR_IN
13513: IFFALSE 13553
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13515: LD_VAR 0 1
13519: PPUSH
13520: LD_INT 285
13522: PPUSH
13523: LD_INT 163
13525: PPUSH
13526: CALL_OW 297
13530: PUSH
13531: LD_INT 9
13533: GREATER
13534: IFFALSE 13551
// ComMoveXY ( i , 285 , 163 ) ;
13536: LD_VAR 0 1
13540: PPUSH
13541: LD_INT 285
13543: PPUSH
13544: LD_INT 163
13546: PPUSH
13547: CALL_OW 111
13551: GO 13512
13553: POP
13554: POP
// wait ( 0 0$1 ) ;
13555: LD_INT 35
13557: PPUSH
13558: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13562: LD_VAR 0 2
13566: PPUSH
13567: LD_INT 92
13569: PUSH
13570: LD_INT 285
13572: PUSH
13573: LD_INT 163
13575: PUSH
13576: LD_INT 9
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: PPUSH
13585: CALL_OW 72
13589: PUSH
13590: LD_VAR 0 2
13594: PUSH
13595: LD_INT 1
13597: MINUS
13598: GREATEREQUAL
13599: IFFALSE 13477
// end ; repeat wait ( 0 0$1 ) ;
13601: LD_INT 35
13603: PPUSH
13604: CALL_OW 67
// for i in tmp do
13608: LD_ADDR_VAR 0 1
13612: PUSH
13613: LD_VAR 0 2
13617: PUSH
13618: FOR_IN
13619: IFFALSE 13741
// if GetLives ( i ) > 251 then
13621: LD_VAR 0 1
13625: PPUSH
13626: CALL_OW 256
13630: PUSH
13631: LD_INT 251
13633: GREATER
13634: IFFALSE 13723
// begin if GetWeapon ( i ) = ru_time_lapser then
13636: LD_VAR 0 1
13640: PPUSH
13641: CALL_OW 264
13645: PUSH
13646: LD_INT 49
13648: EQUAL
13649: IFFALSE 13687
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13651: LD_VAR 0 1
13655: PPUSH
13656: LD_INT 81
13658: PUSH
13659: LD_INT 7
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 69
13670: PPUSH
13671: LD_VAR 0 1
13675: PPUSH
13676: CALL_OW 74
13680: PPUSH
13681: CALL_OW 112
13685: GO 13721
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_INT 81
13694: PUSH
13695: LD_INT 7
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PPUSH
13702: CALL_OW 69
13706: PPUSH
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 74
13716: PPUSH
13717: CALL_OW 115
// end else
13721: GO 13739
// tmp := tmp diff i ;
13723: LD_ADDR_VAR 0 2
13727: PUSH
13728: LD_VAR 0 2
13732: PUSH
13733: LD_VAR 0 1
13737: DIFF
13738: ST_TO_ADDR
13739: GO 13618
13741: POP
13742: POP
// until not tmp ;
13743: LD_VAR 0 2
13747: NOT
13748: IFFALSE 13601
// end ; end_of_file
13750: PPOPN 4
13752: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13753: LD_INT 0
13755: PPUSH
13756: PPUSH
13757: PPUSH
13758: PPUSH
// missionStage := 13 ;
13759: LD_ADDR_EXP 15
13763: PUSH
13764: LD_INT 13
13766: ST_TO_ADDR
// uc_side := 2 ;
13767: LD_ADDR_OWVAR 20
13771: PUSH
13772: LD_INT 2
13774: ST_TO_ADDR
// uc_nation := 2 ;
13775: LD_ADDR_OWVAR 21
13779: PUSH
13780: LD_INT 2
13782: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13783: LD_ADDR_EXP 91
13787: PUSH
13788: LD_STRING Omar
13790: PPUSH
13791: CALL_OW 25
13795: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13796: LD_EXP 91
13800: PPUSH
13801: LD_INT 4
13803: PPUSH
13804: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13808: LD_EXP 91
13812: PPUSH
13813: LD_INT 242
13815: PPUSH
13816: LD_INT 75
13818: PPUSH
13819: LD_INT 0
13821: PPUSH
13822: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13826: LD_ADDR_EXP 92
13830: PUSH
13831: LD_STRING Heike
13833: PPUSH
13834: CALL_OW 25
13838: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13839: LD_INT 14
13841: PPUSH
13842: LD_INT 3
13844: PPUSH
13845: LD_INT 1
13847: PPUSH
13848: LD_INT 27
13850: PPUSH
13851: LD_INT 100
13853: PPUSH
13854: CALL 71376 0 5
// veh := CreateVehicle ;
13858: LD_ADDR_VAR 0 3
13862: PUSH
13863: CALL_OW 45
13867: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13868: LD_VAR 0 3
13872: PPUSH
13873: LD_INT 1
13875: PPUSH
13876: CALL_OW 242
// SetDir ( veh , 4 ) ;
13880: LD_VAR 0 3
13884: PPUSH
13885: LD_INT 4
13887: PPUSH
13888: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13892: LD_VAR 0 3
13896: PPUSH
13897: LD_INT 241
13899: PPUSH
13900: LD_INT 72
13902: PPUSH
13903: LD_INT 0
13905: PPUSH
13906: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13910: LD_EXP 92
13914: PPUSH
13915: LD_VAR 0 3
13919: PPUSH
13920: CALL_OW 52
// if KhatamStatus then
13924: LD_EXP 8
13928: IFFALSE 13979
// begin Khatam := NewCharacter ( Khatam ) ;
13930: LD_ADDR_EXP 93
13934: PUSH
13935: LD_STRING Khatam
13937: PPUSH
13938: CALL_OW 25
13942: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13943: LD_EXP 93
13947: PPUSH
13948: LD_INT 245
13950: PPUSH
13951: LD_INT 78
13953: PPUSH
13954: LD_INT 3
13956: PPUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13964: LD_EXP 93
13968: PPUSH
13969: LD_INT 4
13971: PPUSH
13972: LD_INT 10
13974: PPUSH
13975: CALL_OW 237
// end ; for i = 1 to Difficulty do
13979: LD_ADDR_VAR 0 2
13983: PUSH
13984: DOUBLE
13985: LD_INT 1
13987: DEC
13988: ST_TO_ADDR
13989: LD_OWVAR 67
13993: PUSH
13994: FOR_TO
13995: IFFALSE 14061
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13997: LD_INT 0
13999: PPUSH
14000: LD_INT 7
14002: PUSH
14003: LD_OWVAR 67
14007: PLUS
14008: PPUSH
14009: CALL_OW 384
// un := CreateHuman ;
14013: LD_ADDR_VAR 0 4
14017: PUSH
14018: CALL_OW 44
14022: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14023: LD_VAR 0 4
14027: PPUSH
14028: LD_INT 28
14030: PUSH
14031: LD_INT 29
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: PUSH
14038: LD_VAR 0 2
14042: PUSH
14043: LD_INT 2
14045: MOD
14046: PUSH
14047: LD_INT 1
14049: PLUS
14050: ARRAY
14051: PPUSH
14052: LD_INT 0
14054: PPUSH
14055: CALL_OW 49
// end ;
14059: GO 13994
14061: POP
14062: POP
// for i = 1 to 6 do
14063: LD_ADDR_VAR 0 2
14067: PUSH
14068: DOUBLE
14069: LD_INT 1
14071: DEC
14072: ST_TO_ADDR
14073: LD_INT 6
14075: PUSH
14076: FOR_TO
14077: IFFALSE 14122
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14079: LD_INT 0
14081: PPUSH
14082: LD_INT 7
14084: PUSH
14085: LD_OWVAR 67
14089: PLUS
14090: PPUSH
14091: CALL_OW 381
// un := CreateHuman ;
14095: LD_ADDR_VAR 0 4
14099: PUSH
14100: CALL_OW 44
14104: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14105: LD_VAR 0 4
14109: PPUSH
14110: LD_INT 28
14112: PPUSH
14113: LD_INT 0
14115: PPUSH
14116: CALL_OW 49
// end ;
14120: GO 14076
14122: POP
14123: POP
// for i = 1 to 3 do
14124: LD_ADDR_VAR 0 2
14128: PUSH
14129: DOUBLE
14130: LD_INT 1
14132: DEC
14133: ST_TO_ADDR
14134: LD_INT 3
14136: PUSH
14137: FOR_TO
14138: IFFALSE 14186
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14140: LD_INT 0
14142: PPUSH
14143: LD_INT 8
14145: PPUSH
14146: LD_INT 7
14148: PUSH
14149: LD_OWVAR 67
14153: PLUS
14154: PPUSH
14155: CALL_OW 380
// un := CreateHuman ;
14159: LD_ADDR_VAR 0 4
14163: PUSH
14164: CALL_OW 44
14168: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14169: LD_VAR 0 4
14173: PPUSH
14174: LD_INT 28
14176: PPUSH
14177: LD_INT 0
14179: PPUSH
14180: CALL_OW 49
// end ;
14184: GO 14137
14186: POP
14187: POP
// for i = 1 to 3 do
14188: LD_ADDR_VAR 0 2
14192: PUSH
14193: DOUBLE
14194: LD_INT 1
14196: DEC
14197: ST_TO_ADDR
14198: LD_INT 3
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14292
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14204: LD_INT 14
14206: PPUSH
14207: LD_INT 2
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: LD_INT 28
14215: PPUSH
14216: LD_INT 80
14218: PPUSH
14219: CALL 71376 0 5
// veh := CreateVehicle ;
14223: LD_ADDR_VAR 0 3
14227: PUSH
14228: CALL_OW 45
14232: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14233: LD_VAR 0 3
14237: PPUSH
14238: LD_INT 3
14240: PPUSH
14241: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14245: LD_VAR 0 3
14249: PPUSH
14250: LD_INT 29
14252: PPUSH
14253: LD_INT 0
14255: PPUSH
14256: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14260: LD_INT 0
14262: PPUSH
14263: LD_INT 7
14265: PUSH
14266: LD_OWVAR 67
14270: PLUS
14271: PPUSH
14272: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14276: CALL_OW 44
14280: PPUSH
14281: LD_VAR 0 3
14285: PPUSH
14286: CALL_OW 52
// end ;
14290: GO 14201
14292: POP
14293: POP
// for i = 1 to 5 + Difficulty do
14294: LD_ADDR_VAR 0 2
14298: PUSH
14299: DOUBLE
14300: LD_INT 1
14302: DEC
14303: ST_TO_ADDR
14304: LD_INT 5
14306: PUSH
14307: LD_OWVAR 67
14311: PLUS
14312: PUSH
14313: FOR_TO
14314: IFFALSE 14441
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14316: LD_INT 14
14318: PPUSH
14319: LD_INT 1
14321: PPUSH
14322: LD_INT 3
14324: PPUSH
14325: CALL_OW 12
14329: PPUSH
14330: LD_INT 1
14332: PPUSH
14333: LD_INT 28
14335: PUSH
14336: LD_INT 26
14338: PUSH
14339: LD_INT 27
14341: PUSH
14342: LD_INT 25
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: PUSH
14351: LD_VAR 0 2
14355: PUSH
14356: LD_INT 4
14358: MOD
14359: PUSH
14360: LD_INT 1
14362: PLUS
14363: ARRAY
14364: PPUSH
14365: LD_INT 80
14367: PPUSH
14368: CALL 71376 0 5
// veh := CreateVehicle ;
14372: LD_ADDR_VAR 0 3
14376: PUSH
14377: CALL_OW 45
14381: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14382: LD_VAR 0 3
14386: PPUSH
14387: LD_INT 4
14389: PPUSH
14390: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14394: LD_VAR 0 3
14398: PPUSH
14399: LD_INT 28
14401: PPUSH
14402: LD_INT 0
14404: PPUSH
14405: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14409: LD_INT 0
14411: PPUSH
14412: LD_INT 7
14414: PUSH
14415: LD_OWVAR 67
14419: PLUS
14420: PPUSH
14421: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14425: CALL_OW 44
14429: PPUSH
14430: LD_VAR 0 3
14434: PPUSH
14435: CALL_OW 52
// end ;
14439: GO 14313
14441: POP
14442: POP
// for i = 1 to 3 do
14443: LD_ADDR_VAR 0 2
14447: PUSH
14448: DOUBLE
14449: LD_INT 1
14451: DEC
14452: ST_TO_ADDR
14453: LD_INT 3
14455: PUSH
14456: FOR_TO
14457: IFFALSE 14517
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14459: LD_INT 14
14461: PPUSH
14462: LD_INT 3
14464: PPUSH
14465: LD_INT 5
14467: PPUSH
14468: LD_INT 29
14470: PPUSH
14471: LD_INT 80
14473: PPUSH
14474: CALL 71376 0 5
// veh := CreateVehicle ;
14478: LD_ADDR_VAR 0 3
14482: PUSH
14483: CALL_OW 45
14487: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14488: LD_VAR 0 3
14492: PPUSH
14493: LD_INT 4
14495: PPUSH
14496: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14500: LD_VAR 0 3
14504: PPUSH
14505: LD_INT 28
14507: PPUSH
14508: LD_INT 0
14510: PPUSH
14511: CALL_OW 49
// end ;
14515: GO 14456
14517: POP
14518: POP
// end ;
14519: LD_VAR 0 1
14523: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14524: LD_INT 22
14526: PUSH
14527: LD_INT 2
14529: PUSH
14530: EMPTY
14531: LIST
14532: LIST
14533: PPUSH
14534: CALL_OW 69
14538: IFFALSE 14838
14540: GO 14542
14542: DISABLE
14543: LD_INT 0
14545: PPUSH
14546: PPUSH
14547: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14548: LD_ADDR_VAR 0 3
14552: PUSH
14553: LD_INT 22
14555: PUSH
14556: LD_INT 2
14558: PUSH
14559: EMPTY
14560: LIST
14561: LIST
14562: PUSH
14563: LD_INT 25
14565: PUSH
14566: LD_INT 4
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PPUSH
14577: CALL_OW 69
14581: PUSH
14582: LD_EXP 93
14586: DIFF
14587: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14588: LD_ADDR_VAR 0 2
14592: PUSH
14593: LD_INT 22
14595: PUSH
14596: LD_INT 2
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PPUSH
14603: CALL_OW 69
14607: PUSH
14608: LD_EXP 93
14612: PUSH
14613: LD_VAR 0 3
14617: UNION
14618: DIFF
14619: ST_TO_ADDR
// if Khatam then
14620: LD_EXP 93
14624: IFFALSE 14641
// ComMoveXY ( Khatam , 211 , 92 ) ;
14626: LD_EXP 93
14630: PPUSH
14631: LD_INT 211
14633: PPUSH
14634: LD_INT 92
14636: PPUSH
14637: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14641: LD_INT 197
14643: PPUSH
14644: LD_INT 80
14646: PPUSH
14647: LD_INT 2
14649: PPUSH
14650: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14654: LD_INT 213
14656: PPUSH
14657: LD_INT 90
14659: PPUSH
14660: LD_INT 2
14662: PPUSH
14663: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14667: LD_INT 215
14669: PPUSH
14670: LD_INT 129
14672: PPUSH
14673: LD_INT 2
14675: PPUSH
14676: CALL_OW 441
// if sci then
14680: LD_VAR 0 3
14684: IFFALSE 14705
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14686: LD_VAR 0 3
14690: PUSH
14691: LD_INT 1
14693: ARRAY
14694: PPUSH
14695: LD_INT 197
14697: PPUSH
14698: LD_INT 80
14700: PPUSH
14701: CALL_OW 158
// if sci > 1 then
14705: LD_VAR 0 3
14709: PUSH
14710: LD_INT 1
14712: GREATER
14713: IFFALSE 14734
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14715: LD_VAR 0 3
14719: PUSH
14720: LD_INT 2
14722: ARRAY
14723: PPUSH
14724: LD_INT 213
14726: PPUSH
14727: LD_INT 90
14729: PPUSH
14730: CALL_OW 158
// if sci > 2 then
14734: LD_VAR 0 3
14738: PUSH
14739: LD_INT 2
14741: GREATER
14742: IFFALSE 14763
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14744: LD_VAR 0 3
14748: PUSH
14749: LD_INT 3
14751: ARRAY
14752: PPUSH
14753: LD_INT 215
14755: PPUSH
14756: LD_INT 129
14758: PPUSH
14759: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14763: LD_INT 35
14765: PPUSH
14766: CALL_OW 67
// for i in tmp do
14770: LD_ADDR_VAR 0 1
14774: PUSH
14775: LD_VAR 0 2
14779: PUSH
14780: FOR_IN
14781: IFFALSE 14819
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14783: LD_VAR 0 1
14787: PPUSH
14788: LD_INT 81
14790: PUSH
14791: LD_INT 2
14793: PUSH
14794: EMPTY
14795: LIST
14796: LIST
14797: PPUSH
14798: CALL_OW 69
14802: PPUSH
14803: LD_VAR 0 1
14807: PPUSH
14808: CALL_OW 74
14812: PPUSH
14813: CALL_OW 115
14817: GO 14780
14819: POP
14820: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14821: LD_INT 22
14823: PUSH
14824: LD_INT 2
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PPUSH
14831: CALL_OW 69
14835: NOT
14836: IFFALSE 14763
// end ; end_of_file
14838: PPOPN 3
14840: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14841: LD_INT 0
14843: PPUSH
14844: PPUSH
14845: PPUSH
14846: PPUSH
14847: PPUSH
14848: PPUSH
14849: PPUSH
14850: PPUSH
14851: PPUSH
// Video ( true ) ;
14852: LD_INT 1
14854: PPUSH
14855: CALL 107119 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14859: LD_ADDR_VAR 0 5
14863: PUSH
14864: LD_INT 7
14866: PPUSH
14867: LD_INT 0
14869: PPUSH
14870: CALL_OW 517
14874: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14875: LD_ADDR_VAR 0 2
14879: PUSH
14880: DOUBLE
14881: LD_INT 1
14883: DEC
14884: ST_TO_ADDR
14885: LD_VAR 0 5
14889: PUSH
14890: LD_INT 1
14892: ARRAY
14893: PUSH
14894: FOR_TO
14895: IFFALSE 14940
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14897: LD_VAR 0 5
14901: PUSH
14902: LD_INT 1
14904: ARRAY
14905: PUSH
14906: LD_VAR 0 2
14910: ARRAY
14911: PPUSH
14912: LD_VAR 0 5
14916: PUSH
14917: LD_INT 2
14919: ARRAY
14920: PUSH
14921: LD_VAR 0 2
14925: ARRAY
14926: PPUSH
14927: LD_INT 1
14929: PPUSH
14930: LD_INT 15
14932: NEG
14933: PPUSH
14934: CALL 107033 0 4
14938: GO 14894
14940: POP
14941: POP
// CenterNowOnUnits ( Powell ) ;
14942: LD_EXP 57
14946: PPUSH
14947: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14951: LD_ADDR_VAR 0 5
14955: PUSH
14956: LD_EXP 55
14960: PUSH
14961: EMPTY
14962: LIST
14963: ST_TO_ADDR
// if GirlNewVeh then
14964: LD_EXP 56
14968: IFFALSE 14986
// tmp := tmp ^ GirlNewVeh ;
14970: LD_ADDR_VAR 0 5
14974: PUSH
14975: LD_VAR 0 5
14979: PUSH
14980: LD_EXP 56
14984: ADD
14985: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14986: LD_VAR 0 5
14990: PPUSH
14991: LD_INT 60
14993: PPUSH
14994: LD_INT 109
14996: PPUSH
14997: CALL_OW 111
// if KappaStatus then
15001: LD_EXP 2
15005: IFFALSE 15057
// begin Say ( JMM , D1nT-JMM-1 ) ;
15007: LD_EXP 38
15011: PPUSH
15012: LD_STRING D1nT-JMM-1
15014: PPUSH
15015: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15019: LD_EXP 57
15023: PPUSH
15024: LD_STRING D1T-Pow-1
15026: PPUSH
15027: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15031: LD_EXP 38
15035: PPUSH
15036: LD_STRING D1T-JMM-2
15038: PPUSH
15039: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15043: LD_EXP 57
15047: PPUSH
15048: LD_STRING D1T-Pow-2
15050: PPUSH
15051: CALL_OW 88
// end else
15055: GO 15263
// if JMMGirlStatus then
15057: LD_EXP 6
15061: IFFALSE 15206
// begin Say ( JMM , D1T-JMM-1 ) ;
15063: LD_EXP 38
15067: PPUSH
15068: LD_STRING D1T-JMM-1
15070: PPUSH
15071: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15075: LD_EXP 57
15079: PPUSH
15080: LD_STRING D1T-Pow-1
15082: PPUSH
15083: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15087: LD_EXP 38
15091: PPUSH
15092: LD_STRING D1T-JMM-3
15094: PPUSH
15095: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15099: LD_EXP 57
15103: PPUSH
15104: LD_STRING D1T-Pow-3
15106: PPUSH
15107: CALL_OW 88
// if JMMGirl then
15111: LD_EXP 7
15115: IFFALSE 15204
// begin case JMMGirl of 1 :
15117: LD_EXP 7
15121: PUSH
15122: LD_INT 1
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15145
15130: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15131: LD_EXP 39
15135: PPUSH
15136: LD_STRING D1T-Joan-3
15138: PPUSH
15139: CALL_OW 88
15143: GO 15192
15145: LD_INT 2
15147: DOUBLE
15148: EQUAL
15149: IFTRUE 15153
15151: GO 15168
15153: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15154: LD_EXP 41
15158: PPUSH
15159: LD_STRING D1T-Lisa-3
15161: PPUSH
15162: CALL_OW 88
15166: GO 15192
15168: LD_INT 3
15170: DOUBLE
15171: EQUAL
15172: IFTRUE 15176
15174: GO 15191
15176: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15177: LD_EXP 53
15181: PPUSH
15182: LD_STRING D1T-Con-3
15184: PPUSH
15185: CALL_OW 88
15189: GO 15192
15191: POP
// Say ( Powell , D1T-Pow-4 ) ;
15192: LD_EXP 57
15196: PPUSH
15197: LD_STRING D1T-Pow-4
15199: PPUSH
15200: CALL_OW 88
// end ; end else
15204: GO 15263
// if not FastEnd then
15206: LD_EXP 11
15210: NOT
15211: IFFALSE 15239
// begin Say ( JMM , D1T-JMM-4 ) ;
15213: LD_EXP 38
15217: PPUSH
15218: LD_STRING D1T-JMM-4
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15225: LD_EXP 57
15229: PPUSH
15230: LD_STRING D1T-Pow-5
15232: PPUSH
15233: CALL_OW 88
// end else
15237: GO 15263
// begin Say ( JMM , D1nT-JMM-1 ) ;
15239: LD_EXP 38
15243: PPUSH
15244: LD_STRING D1nT-JMM-1
15246: PPUSH
15247: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15251: LD_EXP 57
15255: PPUSH
15256: LD_STRING D1nT-Pow-1
15258: PPUSH
15259: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15263: LD_INT 35
15265: PPUSH
15266: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15270: LD_EXP 55
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: IFFALSE 15263
// ComExitVehicle ( JMM ) ;
15282: LD_EXP 38
15286: PPUSH
15287: CALL_OW 121
// wait ( 3 ) ;
15291: LD_INT 3
15293: PPUSH
15294: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15298: LD_EXP 38
15302: PPUSH
15303: LD_INT 60
15305: PPUSH
15306: LD_INT 94
15308: PPUSH
15309: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15313: LD_EXP 38
15317: PPUSH
15318: LD_EXP 57
15322: PPUSH
15323: CALL_OW 179
// if Joan then
15327: LD_EXP 39
15331: IFFALSE 15385
// begin ComExitVehicle ( Joan ) ;
15333: LD_EXP 39
15337: PPUSH
15338: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15342: LD_EXP 39
15346: PPUSH
15347: LD_INT 35
15349: PPUSH
15350: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15354: LD_EXP 39
15358: PPUSH
15359: LD_INT 65
15361: PPUSH
15362: LD_INT 104
15364: PPUSH
15365: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15369: LD_EXP 39
15373: PPUSH
15374: LD_EXP 38
15378: PPUSH
15379: CALL_OW 179
// end else
15383: GO 15519
// if Lisa and JMMGirl = 2 then
15385: LD_EXP 41
15389: PUSH
15390: LD_EXP 7
15394: PUSH
15395: LD_INT 2
15397: EQUAL
15398: AND
15399: IFFALSE 15453
// begin ComExitVehicle ( Lisa ) ;
15401: LD_EXP 41
15405: PPUSH
15406: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15410: LD_EXP 41
15414: PPUSH
15415: LD_INT 35
15417: PPUSH
15418: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15422: LD_EXP 41
15426: PPUSH
15427: LD_INT 65
15429: PPUSH
15430: LD_INT 104
15432: PPUSH
15433: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15437: LD_EXP 41
15441: PPUSH
15442: LD_EXP 38
15446: PPUSH
15447: CALL_OW 179
// end else
15451: GO 15519
// if Connie and JMMGirl = 3 then
15453: LD_EXP 53
15457: PUSH
15458: LD_EXP 7
15462: PUSH
15463: LD_INT 3
15465: EQUAL
15466: AND
15467: IFFALSE 15519
// begin ComExitVehicle ( Connie ) ;
15469: LD_EXP 53
15473: PPUSH
15474: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15478: LD_EXP 53
15482: PPUSH
15483: LD_INT 35
15485: PPUSH
15486: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15490: LD_EXP 53
15494: PPUSH
15495: LD_INT 65
15497: PPUSH
15498: LD_INT 104
15500: PPUSH
15501: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15505: LD_EXP 53
15509: PPUSH
15510: LD_EXP 38
15514: PPUSH
15515: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15519: LD_INT 35
15521: PPUSH
15522: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15526: LD_EXP 38
15530: PPUSH
15531: LD_EXP 57
15535: PPUSH
15536: CALL_OW 296
15540: PUSH
15541: LD_INT 6
15543: LESS
15544: IFFALSE 15519
// wait ( 0 0$0.5 ) ;
15546: LD_INT 18
15548: PPUSH
15549: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15553: LD_EXP 38
15557: PPUSH
15558: LD_STRING D1-JMM-1
15560: PPUSH
15561: CALL_OW 88
// async ;
15565: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15566: LD_EXP 57
15570: PPUSH
15571: LD_STRING D1-Pow-1
15573: PPUSH
15574: CALL_OW 88
// if not dialogue_skipped then
15578: LD_OWVAR 59
15582: NOT
15583: IFFALSE 15592
// wait ( 0 0$2 ) ;
15585: LD_INT 70
15587: PPUSH
15588: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15592: LD_INT 170
15594: PPUSH
15595: LD_INT 99
15597: PPUSH
15598: LD_INT 1
15600: PPUSH
15601: LD_INT 6
15603: NEG
15604: PPUSH
15605: CALL 107033 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15609: LD_INT 174
15611: PPUSH
15612: LD_INT 115
15614: PPUSH
15615: LD_INT 1
15617: PPUSH
15618: LD_INT 6
15620: NEG
15621: PPUSH
15622: CALL 107033 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15626: LD_INT 169
15628: PPUSH
15629: LD_INT 71
15631: PPUSH
15632: LD_INT 1
15634: PPUSH
15635: LD_INT 6
15637: NEG
15638: PPUSH
15639: CALL 107033 0 4
// if not dialogue_skipped then
15643: LD_OWVAR 59
15647: NOT
15648: IFFALSE 15667
// begin CenterOnXY ( 170 , 99 ) ;
15650: LD_INT 170
15652: PPUSH
15653: LD_INT 99
15655: PPUSH
15656: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15660: LD_INT 80
15662: PPUSH
15663: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15667: LD_INT 75
15669: PPUSH
15670: LD_INT 53
15672: PPUSH
15673: LD_INT 1
15675: PPUSH
15676: LD_INT 9
15678: NEG
15679: PPUSH
15680: CALL 107033 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15684: LD_INT 54
15686: PPUSH
15687: LD_INT 42
15689: PPUSH
15690: LD_INT 1
15692: PPUSH
15693: LD_INT 9
15695: NEG
15696: PPUSH
15697: CALL 107033 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15701: LD_INT 62
15703: PPUSH
15704: LD_INT 51
15706: PPUSH
15707: LD_INT 1
15709: PPUSH
15710: LD_INT 9
15712: NEG
15713: PPUSH
15714: CALL 107033 0 4
// if not dialogue_skipped then
15718: LD_OWVAR 59
15722: NOT
15723: IFFALSE 15742
// begin CenterOnXY ( 75 , 53 ) ;
15725: LD_INT 75
15727: PPUSH
15728: LD_INT 53
15730: PPUSH
15731: CALL_OW 84
// wait ( 0 0$4 ) ;
15735: LD_INT 140
15737: PPUSH
15738: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15742: LD_EXP 57
15746: PPUSH
15747: CALL_OW 87
// if not dialogue_skipped then
15751: LD_OWVAR 59
15755: NOT
15756: IFFALSE 15765
// wait ( 0 0$2 ) ;
15758: LD_INT 70
15760: PPUSH
15761: CALL_OW 67
// sync ;
15765: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15766: LD_EXP 38
15770: PPUSH
15771: LD_STRING D1-JMM-2
15773: PPUSH
15774: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15778: LD_EXP 57
15782: PPUSH
15783: LD_STRING D1-Pow-2
15785: PPUSH
15786: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15790: LD_EXP 38
15794: PPUSH
15795: LD_STRING D1-JMM-3
15797: PPUSH
15798: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15802: LD_EXP 57
15806: PPUSH
15807: LD_STRING D1-Pow-3
15809: PPUSH
15810: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15814: LD_EXP 38
15818: PPUSH
15819: LD_STRING D1-JMM-4
15821: PPUSH
15822: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15826: LD_EXP 57
15830: PPUSH
15831: LD_STRING D1-Pow-4
15833: PPUSH
15834: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15838: LD_EXP 38
15842: PPUSH
15843: LD_STRING D1-JMM-5
15845: PPUSH
15846: CALL_OW 88
// async ;
15850: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15851: LD_EXP 57
15855: PPUSH
15856: LD_STRING D1-Pow-5
15858: PPUSH
15859: CALL_OW 88
// if not dialogue_skipped then
15863: LD_OWVAR 59
15867: NOT
15868: IFFALSE 15877
// wait ( 0 0$3.6 ) ;
15870: LD_INT 126
15872: PPUSH
15873: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15877: LD_INT 134
15879: PPUSH
15880: LD_INT 210
15882: PPUSH
15883: LD_INT 1
15885: PPUSH
15886: LD_INT 11
15888: NEG
15889: PPUSH
15890: CALL 107033 0 4
// if not dialogue_skipped then
15894: LD_OWVAR 59
15898: NOT
15899: IFFALSE 15918
// begin CenterOnXY ( 134 , 210 ) ;
15901: LD_INT 134
15903: PPUSH
15904: LD_INT 210
15906: PPUSH
15907: CALL_OW 84
// wait ( 0 0$2 ) ;
15911: LD_INT 70
15913: PPUSH
15914: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15918: LD_INT 101
15920: PPUSH
15921: LD_INT 159
15923: PPUSH
15924: LD_INT 1
15926: PPUSH
15927: LD_INT 10
15929: NEG
15930: PPUSH
15931: CALL 107033 0 4
// if not dialogue_skipped then
15935: LD_OWVAR 59
15939: NOT
15940: IFFALSE 15959
// begin CenterOnXY ( 101 , 159 ) ;
15942: LD_INT 101
15944: PPUSH
15945: LD_INT 159
15947: PPUSH
15948: CALL_OW 84
// wait ( 0 0$2 ) ;
15952: LD_INT 70
15954: PPUSH
15955: CALL_OW 67
// end ; sync ;
15959: SYNC
// CenterNowOnUnits ( Powell ) ;
15960: LD_EXP 57
15964: PPUSH
15965: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15969: LD_ADDR_VAR 0 6
15973: PUSH
15974: LD_INT 1
15976: PUSH
15977: LD_INT 2
15979: PUSH
15980: LD_INT 3
15982: PUSH
15983: LD_INT 4
15985: PUSH
15986: LD_INT 5
15988: PUSH
15989: LD_INT 6
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: LIST
15999: ST_TO_ADDR
// if not dialogue_skipped then
16000: LD_OWVAR 59
16004: NOT
16005: IFFALSE 16174
// begin game_speed := 4 ;
16007: LD_ADDR_OWVAR 65
16011: PUSH
16012: LD_INT 4
16014: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16015: LD_INT 210
16017: PPUSH
16018: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16022: LD_ADDR_VAR 0 7
16026: PUSH
16027: LD_STRING Q1
16029: PPUSH
16030: LD_VAR 0 6
16034: PPUSH
16035: CALL_OW 98
16039: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16040: LD_ADDR_VAR 0 7
16044: PUSH
16045: LD_STRING Q1
16047: PPUSH
16048: LD_VAR 0 6
16052: PPUSH
16053: CALL_OW 98
16057: ST_TO_ADDR
// options = options diff dec ;
16058: LD_ADDR_VAR 0 6
16062: PUSH
16063: LD_VAR 0 6
16067: PUSH
16068: LD_VAR 0 7
16072: DIFF
16073: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16074: LD_VAR 0 7
16078: PPUSH
16079: LD_VAR 0 6
16083: PPUSH
16084: CALL 17646 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16088: LD_VAR 0 7
16092: PUSH
16093: LD_INT 5
16095: PUSH
16096: LD_INT 6
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: IN
16103: PUSH
16104: LD_VAR 0 6
16108: PUSH
16109: LD_INT 2
16111: EQUAL
16112: OR
16113: IFFALSE 16040
// if not ( dec in [ 5 , 6 ] ) then
16115: LD_VAR 0 7
16119: PUSH
16120: LD_INT 5
16122: PUSH
16123: LD_INT 6
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: IN
16130: NOT
16131: IFFALSE 16174
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16133: LD_ADDR_VAR 0 7
16137: PUSH
16138: LD_STRING Q1a
16140: PPUSH
16141: LD_INT 1
16143: PUSH
16144: LD_INT 2
16146: PUSH
16147: EMPTY
16148: LIST
16149: LIST
16150: PPUSH
16151: CALL_OW 98
16155: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16156: LD_VAR 0 7
16160: PUSH
16161: LD_INT 4
16163: PLUS
16164: PPUSH
16165: LD_VAR 0 6
16169: PPUSH
16170: CALL 17646 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16174: LD_INT 81
16176: PPUSH
16177: LD_INT 127
16179: PPUSH
16180: CALL_OW 84
// amount := 5 ;
16184: LD_ADDR_VAR 0 8
16188: PUSH
16189: LD_INT 5
16191: ST_TO_ADDR
// macmilan_squad := [ ] ;
16192: LD_ADDR_VAR 0 9
16196: PUSH
16197: EMPTY
16198: ST_TO_ADDR
// if vip < amount then
16199: LD_EXP 58
16203: PUSH
16204: LD_VAR 0 8
16208: LESS
16209: IFFALSE 16253
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16211: LD_ADDR_VAR 0 5
16215: PUSH
16216: LD_EXP 58
16220: PUSH
16221: LD_INT 22
16223: PUSH
16224: LD_INT 4
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: PUSH
16231: LD_INT 21
16233: PUSH
16234: LD_INT 1
16236: PUSH
16237: EMPTY
16238: LIST
16239: LIST
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: PPUSH
16245: CALL_OW 69
16249: UNION
16250: ST_TO_ADDR
16251: GO 16263
// tmp := vip ;
16253: LD_ADDR_VAR 0 5
16257: PUSH
16258: LD_EXP 58
16262: ST_TO_ADDR
// tmp := tmp diff Powell ;
16263: LD_ADDR_VAR 0 5
16267: PUSH
16268: LD_VAR 0 5
16272: PUSH
16273: LD_EXP 57
16277: DIFF
16278: ST_TO_ADDR
// if tmp < amount then
16279: LD_VAR 0 5
16283: PUSH
16284: LD_VAR 0 8
16288: LESS
16289: IFFALSE 16301
// amount := tmp ;
16291: LD_ADDR_VAR 0 8
16295: PUSH
16296: LD_VAR 0 5
16300: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16301: LD_VAR 0 5
16305: PUSH
16306: LD_INT 1
16308: ARRAY
16309: PPUSH
16310: CALL_OW 257
16314: PUSH
16315: LD_INT 2
16317: NONEQUAL
16318: IFFALSE 16380
// begin if IsInUnit ( tmp [ 1 ] ) then
16320: LD_VAR 0 5
16324: PUSH
16325: LD_INT 1
16327: ARRAY
16328: PPUSH
16329: CALL_OW 310
16333: IFFALSE 16348
// ComExitBuilding ( tmp [ 1 ] ) ;
16335: LD_VAR 0 5
16339: PUSH
16340: LD_INT 1
16342: ARRAY
16343: PPUSH
16344: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16348: LD_VAR 0 5
16352: PUSH
16353: LD_INT 1
16355: ARRAY
16356: PPUSH
16357: LD_INT 387
16359: PPUSH
16360: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16364: LD_VAR 0 5
16368: PUSH
16369: LD_INT 1
16371: ARRAY
16372: PPUSH
16373: LD_INT 2
16375: PPUSH
16376: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16380: LD_EXP 38
16384: PPUSH
16385: LD_INT 82
16387: PPUSH
16388: LD_INT 129
16390: PPUSH
16391: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16395: LD_EXP 38
16399: PPUSH
16400: LD_EXP 57
16404: PPUSH
16405: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16409: LD_INT 22
16411: PUSH
16412: LD_INT 1
16414: PUSH
16415: EMPTY
16416: LIST
16417: LIST
16418: PPUSH
16419: CALL_OW 69
16423: PUSH
16424: LD_EXP 38
16428: DIFF
16429: PPUSH
16430: LD_INT 84
16432: PPUSH
16433: LD_INT 128
16435: PPUSH
16436: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16440: LD_INT 22
16442: PUSH
16443: LD_INT 1
16445: PUSH
16446: EMPTY
16447: LIST
16448: LIST
16449: PPUSH
16450: CALL_OW 69
16454: PUSH
16455: LD_EXP 38
16459: DIFF
16460: PPUSH
16461: LD_EXP 38
16465: PPUSH
16466: CALL_OW 179
// for i = 1 to amount do
16470: LD_ADDR_VAR 0 2
16474: PUSH
16475: DOUBLE
16476: LD_INT 1
16478: DEC
16479: ST_TO_ADDR
16480: LD_VAR 0 8
16484: PUSH
16485: FOR_TO
16486: IFFALSE 16654
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16488: LD_ADDR_VAR 0 9
16492: PUSH
16493: LD_VAR 0 9
16497: PUSH
16498: LD_VAR 0 5
16502: PUSH
16503: LD_VAR 0 2
16507: ARRAY
16508: ADD
16509: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16510: LD_VAR 0 5
16514: PUSH
16515: LD_VAR 0 2
16519: ARRAY
16520: PPUSH
16521: CALL_OW 310
16525: IFFALSE 16542
// AddComExitBuilding ( tmp [ i ] ) ;
16527: LD_VAR 0 5
16531: PUSH
16532: LD_VAR 0 2
16536: ARRAY
16537: PPUSH
16538: CALL_OW 182
// if i = 2 and JMMNewVeh then
16542: LD_VAR 0 2
16546: PUSH
16547: LD_INT 2
16549: EQUAL
16550: PUSH
16551: LD_EXP 55
16555: AND
16556: IFFALSE 16614
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16558: LD_VAR 0 5
16562: PUSH
16563: LD_VAR 0 2
16567: ARRAY
16568: PPUSH
16569: LD_EXP 55
16573: PPUSH
16574: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16578: LD_VAR 0 5
16582: PUSH
16583: LD_VAR 0 2
16587: ARRAY
16588: PPUSH
16589: LD_INT 86
16591: PPUSH
16592: LD_INT 133
16594: PPUSH
16595: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16599: LD_VAR 0 5
16603: PUSH
16604: LD_VAR 0 2
16608: ARRAY
16609: PPUSH
16610: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16614: LD_VAR 0 5
16618: PUSH
16619: LD_VAR 0 2
16623: ARRAY
16624: PPUSH
16625: LD_INT 8
16627: PPUSH
16628: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16632: LD_VAR 0 5
16636: PUSH
16637: LD_VAR 0 2
16641: ARRAY
16642: PPUSH
16643: LD_EXP 38
16647: PPUSH
16648: CALL_OW 179
// end ;
16652: GO 16485
16654: POP
16655: POP
// if GirlNewVeh then
16656: LD_EXP 56
16660: IFFALSE 16674
// SetSide ( GirlNewVeh , 4 ) ;
16662: LD_EXP 56
16666: PPUSH
16667: LD_INT 4
16669: PPUSH
16670: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16674: LD_INT 35
16676: PPUSH
16677: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16681: LD_VAR 0 9
16685: PPUSH
16686: LD_INT 95
16688: PUSH
16689: LD_INT 9
16691: PUSH
16692: EMPTY
16693: LIST
16694: LIST
16695: PPUSH
16696: CALL_OW 72
16700: PUSH
16701: LD_INT 0
16703: EQUAL
16704: PUSH
16705: LD_EXP 38
16709: PPUSH
16710: LD_INT 9
16712: PPUSH
16713: CALL_OW 308
16717: NOT
16718: AND
16719: IFFALSE 16674
// wait ( 0 0$2 ) ;
16721: LD_INT 70
16723: PPUSH
16724: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16728: LD_VAR 0 9
16732: PPUSH
16733: LD_INT 1
16735: PPUSH
16736: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16740: LD_INT 21
16742: PUSH
16743: LD_INT 2
16745: PUSH
16746: EMPTY
16747: LIST
16748: LIST
16749: PUSH
16750: LD_INT 92
16752: PUSH
16753: LD_INT 83
16755: PUSH
16756: LD_INT 130
16758: PUSH
16759: LD_INT 10
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: LIST
16766: LIST
16767: PUSH
16768: EMPTY
16769: LIST
16770: LIST
16771: PPUSH
16772: CALL_OW 69
16776: PPUSH
16777: LD_INT 1
16779: PPUSH
16780: CALL_OW 235
// Video ( false ) ;
16784: LD_INT 0
16786: PPUSH
16787: CALL 107119 0 1
// ChangeMissionObjectives ( M1 ) ;
16791: LD_STRING M1
16793: PPUSH
16794: CALL_OW 337
// SaveForQuickRestart ;
16798: CALL_OW 22
// missionStart := true ;
16802: LD_ADDR_EXP 13
16806: PUSH
16807: LD_INT 1
16809: ST_TO_ADDR
// missionStage := 2 ;
16810: LD_ADDR_EXP 15
16814: PUSH
16815: LD_INT 2
16817: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16818: LD_INT 105
16820: PPUSH
16821: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16825: LD_ADDR_VAR 0 5
16829: PUSH
16830: LD_INT 22
16832: PUSH
16833: LD_INT 4
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: LD_INT 21
16842: PUSH
16843: LD_INT 1
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: PPUSH
16854: CALL_OW 69
16858: PUSH
16859: LD_EXP 57
16863: DIFF
16864: ST_TO_ADDR
// if not tmp then
16865: LD_VAR 0 5
16869: NOT
16870: IFFALSE 16885
// tmp := [ Powell ] ;
16872: LD_ADDR_VAR 0 5
16876: PUSH
16877: LD_EXP 57
16881: PUSH
16882: EMPTY
16883: LIST
16884: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16885: LD_ADDR_EXP 101
16889: PUSH
16890: LD_EXP 101
16894: PPUSH
16895: LD_INT 4
16897: PPUSH
16898: LD_INT 22
16900: PUSH
16901: LD_INT 4
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PUSH
16908: LD_INT 23
16910: PUSH
16911: LD_INT 1
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: LD_INT 3
16920: PUSH
16921: LD_INT 21
16923: PUSH
16924: LD_INT 2
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: LIST
16939: PPUSH
16940: CALL_OW 69
16944: PUSH
16945: LD_EXP 57
16949: DIFF
16950: PPUSH
16951: CALL_OW 1
16955: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16956: LD_ADDR_VAR 0 4
16960: PUSH
16961: LD_INT 22
16963: PUSH
16964: LD_INT 4
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_INT 34
16973: PUSH
16974: LD_INT 12
16976: PUSH
16977: EMPTY
16978: LIST
16979: LIST
16980: PUSH
16981: EMPTY
16982: LIST
16983: LIST
16984: PPUSH
16985: CALL_OW 69
16989: PUSH
16990: LD_INT 1
16992: ARRAY
16993: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16994: LD_VAR 0 5
16998: PUSH
16999: LD_INT 1
17001: ARRAY
17002: PPUSH
17003: CALL_OW 310
17007: IFFALSE 17022
// ComExitBuilding ( tmp [ 1 ] ) ;
17009: LD_VAR 0 5
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: PPUSH
17018: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17022: LD_VAR 0 5
17026: PUSH
17027: LD_INT 1
17029: ARRAY
17030: PPUSH
17031: LD_VAR 0 4
17035: PPUSH
17036: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17040: LD_VAR 0 5
17044: PUSH
17045: LD_INT 1
17047: ARRAY
17048: PPUSH
17049: LD_INT 80
17051: PPUSH
17052: LD_INT 136
17054: PPUSH
17055: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17059: LD_VAR 0 5
17063: PUSH
17064: LD_INT 1
17066: ARRAY
17067: PPUSH
17068: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17072: LD_VAR 0 5
17076: PUSH
17077: LD_INT 1
17079: ARRAY
17080: PPUSH
17081: LD_INT 59
17083: PPUSH
17084: LD_INT 112
17086: PPUSH
17087: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17091: LD_VAR 0 5
17095: PUSH
17096: LD_INT 1
17098: ARRAY
17099: PPUSH
17100: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17104: LD_EXP 39
17108: PUSH
17109: LD_EXP 39
17113: PPUSH
17114: CALL_OW 255
17118: PUSH
17119: LD_INT 1
17121: EQUAL
17122: AND
17123: IFFALSE 17149
// begin Say ( Joan , D3W-Joan-1 ) ;
17125: LD_EXP 39
17129: PPUSH
17130: LD_STRING D3W-Joan-1
17132: PPUSH
17133: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17137: LD_EXP 38
17141: PPUSH
17142: LD_STRING D3W-JMM-1
17144: PPUSH
17145: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17149: LD_EXP 41
17153: PUSH
17154: LD_EXP 41
17158: PPUSH
17159: CALL_OW 255
17163: PUSH
17164: LD_INT 1
17166: EQUAL
17167: AND
17168: PUSH
17169: LD_EXP 41
17173: PUSH
17174: LD_EXP 58
17178: IN
17179: NOT
17180: AND
17181: IFFALSE 17207
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17183: LD_EXP 41
17187: PPUSH
17188: LD_STRING D3W-Lisa-1
17190: PPUSH
17191: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17195: LD_EXP 38
17199: PPUSH
17200: LD_STRING D3W-JMM-1
17202: PPUSH
17203: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17207: LD_EXP 53
17211: PUSH
17212: LD_EXP 53
17216: PPUSH
17217: CALL_OW 255
17221: PUSH
17222: LD_INT 1
17224: EQUAL
17225: AND
17226: IFFALSE 17252
// begin Say ( Connie , D3W-Con-1 ) ;
17228: LD_EXP 53
17232: PPUSH
17233: LD_STRING D3W-Con-1
17235: PPUSH
17236: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17240: LD_EXP 38
17244: PPUSH
17245: LD_STRING D3W-JMM-1
17247: PPUSH
17248: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17252: LD_EXP 41
17256: PUSH
17257: LD_EXP 58
17261: IN
17262: PUSH
17263: LD_EXP 41
17267: PPUSH
17268: CALL_OW 255
17272: PUSH
17273: LD_INT 1
17275: EQUAL
17276: AND
17277: IFFALSE 17293
// Say ( Lisa , D3nW-Lisa-1 ) else
17279: LD_EXP 41
17283: PPUSH
17284: LD_STRING D3nW-Lisa-1
17286: PPUSH
17287: CALL_OW 88
17291: GO 17537
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17293: LD_EXP 44
17297: PUSH
17298: LD_EXP 58
17302: IN
17303: PUSH
17304: LD_EXP 44
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: IFFALSE 17334
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17320: LD_EXP 44
17324: PPUSH
17325: LD_STRING D3nW-Cyrus-1
17327: PPUSH
17328: CALL_OW 88
17332: GO 17537
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17334: LD_EXP 43
17338: PUSH
17339: LD_EXP 58
17343: IN
17344: PUSH
17345: LD_EXP 43
17349: PPUSH
17350: CALL_OW 255
17354: PUSH
17355: LD_INT 1
17357: EQUAL
17358: AND
17359: IFFALSE 17375
// Say ( Bobby , D3nW-Bobby-1 ) else
17361: LD_EXP 43
17365: PPUSH
17366: LD_STRING D3nW-Bobby-1
17368: PPUSH
17369: CALL_OW 88
17373: GO 17537
// if Gary in vip and GetSide ( Gary ) = 1 then
17375: LD_EXP 50
17379: PUSH
17380: LD_EXP 58
17384: IN
17385: PUSH
17386: LD_EXP 50
17390: PPUSH
17391: CALL_OW 255
17395: PUSH
17396: LD_INT 1
17398: EQUAL
17399: AND
17400: IFFALSE 17416
// Say ( Gary , D3nW-Gary-1 ) else
17402: LD_EXP 50
17406: PPUSH
17407: LD_STRING D3nW-Gary-1
17409: PPUSH
17410: CALL_OW 88
17414: GO 17537
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17416: LD_EXP 42
17420: PUSH
17421: LD_EXP 58
17425: IN
17426: PUSH
17427: LD_EXP 42
17431: PPUSH
17432: CALL_OW 255
17436: PUSH
17437: LD_INT 1
17439: EQUAL
17440: AND
17441: IFFALSE 17457
// Say ( Donaldson , D3nW-Don-1 ) else
17443: LD_EXP 42
17447: PPUSH
17448: LD_STRING D3nW-Don-1
17450: PPUSH
17451: CALL_OW 88
17455: GO 17537
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17457: LD_EXP 49
17461: PUSH
17462: LD_EXP 58
17466: IN
17467: PUSH
17468: LD_EXP 49
17472: PPUSH
17473: CALL_OW 255
17477: PUSH
17478: LD_INT 1
17480: EQUAL
17481: AND
17482: IFFALSE 17498
// Say ( Cornel , D3nW-Corn-1 ) else
17484: LD_EXP 49
17488: PPUSH
17489: LD_STRING D3nW-Corn-1
17491: PPUSH
17492: CALL_OW 88
17496: GO 17537
// if Frank in vip and GetSide ( Frank ) = 1 then
17498: LD_EXP 51
17502: PUSH
17503: LD_EXP 58
17507: IN
17508: PUSH
17509: LD_EXP 51
17513: PPUSH
17514: CALL_OW 255
17518: PUSH
17519: LD_INT 1
17521: EQUAL
17522: AND
17523: IFFALSE 17537
// Say ( Frank , D3nW-Frank-1 ) ;
17525: LD_EXP 51
17529: PPUSH
17530: LD_STRING D3nW-Frank-1
17532: PPUSH
17533: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17537: LD_EXP 58
17541: PPUSH
17542: LD_INT 22
17544: PUSH
17545: LD_INT 1
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: PPUSH
17552: CALL_OW 72
17556: IFFALSE 17582
// begin Say ( JMM , D3nW-JMM-1 ) ;
17558: LD_EXP 38
17562: PPUSH
17563: LD_STRING D3nW-JMM-1
17565: PPUSH
17566: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17570: LD_EXP 38
17574: PPUSH
17575: LD_STRING D3nW-JMM-1a
17577: PPUSH
17578: CALL_OW 88
// end ; t := 0 0$00 ;
17582: LD_ADDR_VAR 0 3
17586: PUSH
17587: LD_INT 0
17589: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17590: LD_INT 35
17592: PPUSH
17593: CALL_OW 67
// t := t + 0 0$1 ;
17597: LD_ADDR_VAR 0 3
17601: PUSH
17602: LD_VAR 0 3
17606: PUSH
17607: LD_INT 35
17609: PLUS
17610: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17611: LD_INT 59
17613: PPUSH
17614: LD_INT 112
17616: PPUSH
17617: CALL_OW 428
17621: PUSH
17622: LD_VAR 0 3
17626: PUSH
17627: LD_INT 2100
17629: GREATER
17630: OR
17631: IFFALSE 17590
// activeAttacks := true ;
17633: LD_ADDR_EXP 16
17637: PUSH
17638: LD_INT 1
17640: ST_TO_ADDR
// end ;
17641: LD_VAR 0 1
17645: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17646: LD_INT 0
17648: PPUSH
// case question of 1 :
17649: LD_VAR 0 1
17653: PUSH
17654: LD_INT 1
17656: DOUBLE
17657: EQUAL
17658: IFTRUE 17662
17660: GO 17713
17662: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17663: LD_EXP 38
17667: PPUSH
17668: LD_STRING D2Mot-JMM-1
17670: PPUSH
17671: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17675: LD_EXP 57
17679: PPUSH
17680: LD_STRING D2Mot-Pow-1
17682: PPUSH
17683: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17687: LD_EXP 38
17691: PPUSH
17692: LD_STRING D2Mot-JMM-2
17694: PPUSH
17695: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17699: LD_EXP 57
17703: PPUSH
17704: LD_STRING D2Mot-Pow-2
17706: PPUSH
17707: CALL_OW 88
// end ; 2 :
17711: GO 18064
17713: LD_INT 2
17715: DOUBLE
17716: EQUAL
17717: IFTRUE 17721
17719: GO 17797
17721: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17722: LD_EXP 38
17726: PPUSH
17727: LD_STRING D2Rus-JMM-1
17729: PPUSH
17730: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17734: LD_EXP 57
17738: PPUSH
17739: LD_STRING D2Rus-Pow-1
17741: PPUSH
17742: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17746: LD_EXP 38
17750: PPUSH
17751: LD_STRING D2Rus-JMM-2
17753: PPUSH
17754: CALL_OW 88
// if not ( 3 in list_of_q ) then
17758: LD_INT 3
17760: PUSH
17761: LD_VAR 0 2
17765: IN
17766: NOT
17767: IFFALSE 17783
// Say ( Powell , D2Rus-Pow-2 ) else
17769: LD_EXP 57
17773: PPUSH
17774: LD_STRING D2Rus-Pow-2
17776: PPUSH
17777: CALL_OW 88
17781: GO 17795
// Say ( Powell , D2Rus-Pow-2a ) ;
17783: LD_EXP 57
17787: PPUSH
17788: LD_STRING D2Rus-Pow-2a
17790: PPUSH
17791: CALL_OW 88
// end ; 3 :
17795: GO 18064
17797: LD_INT 3
17799: DOUBLE
17800: EQUAL
17801: IFTRUE 17805
17803: GO 17890
17805: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17806: LD_EXP 38
17810: PPUSH
17811: LD_STRING D2Leg-JMM-1
17813: PPUSH
17814: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17818: LD_EXP 57
17822: PPUSH
17823: LD_STRING D2Leg-Pow-1
17825: PPUSH
17826: CALL_OW 88
// if 2 in list_of_q then
17830: LD_INT 2
17832: PUSH
17833: LD_VAR 0 2
17837: IN
17838: IFFALSE 17864
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17840: LD_EXP 38
17844: PPUSH
17845: LD_STRING D2Leg-JMM-2
17847: PPUSH
17848: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17852: LD_EXP 57
17856: PPUSH
17857: LD_STRING D2Leg-Pow-2
17859: PPUSH
17860: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17864: LD_EXP 38
17868: PPUSH
17869: LD_STRING D2Leg-JMM-3
17871: PPUSH
17872: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17876: LD_EXP 57
17880: PPUSH
17881: LD_STRING D2Leg-Pow-3
17883: PPUSH
17884: CALL_OW 88
// end ; 4 :
17888: GO 18064
17890: LD_INT 4
17892: DOUBLE
17893: EQUAL
17894: IFTRUE 17898
17896: GO 17973
17898: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17899: LD_EXP 38
17903: PPUSH
17904: LD_STRING D2Ar-JMM-1
17906: PPUSH
17907: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17911: LD_EXP 57
17915: PPUSH
17916: LD_STRING D2Ar-Pow-1
17918: PPUSH
17919: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17923: LD_EXP 38
17927: PPUSH
17928: LD_STRING D2Ar-JMM-2
17930: PPUSH
17931: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17935: LD_EXP 57
17939: PPUSH
17940: LD_STRING D2Ar-Pow-2
17942: PPUSH
17943: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17947: LD_EXP 38
17951: PPUSH
17952: LD_STRING D2Ar-JMM-3
17954: PPUSH
17955: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17959: LD_EXP 57
17963: PPUSH
17964: LD_STRING D2Ar-Pow-3
17966: PPUSH
17967: CALL_OW 88
// end ; 5 :
17971: GO 18064
17973: LD_INT 5
17975: DOUBLE
17976: EQUAL
17977: IFTRUE 17981
17979: GO 17996
17981: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17982: LD_EXP 38
17986: PPUSH
17987: LD_STRING D2Conf-JMM-1
17989: PPUSH
17990: CALL_OW 88
17994: GO 18064
17996: LD_INT 6
17998: DOUBLE
17999: EQUAL
18000: IFTRUE 18004
18002: GO 18063
18004: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18005: LD_EXP 38
18009: PPUSH
18010: LD_STRING D2Com-JMM-1
18012: PPUSH
18013: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18017: LD_EXP 57
18021: PPUSH
18022: LD_STRING D2Com-Pow-1
18024: PPUSH
18025: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18029: LD_EXP 38
18033: PPUSH
18034: LD_STRING D2Com-JMM-2
18036: PPUSH
18037: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18041: LD_EXP 57
18045: PPUSH
18046: LD_STRING D2Com-Pow-2
18048: PPUSH
18049: CALL_OW 88
// powellAngerQuery := true ;
18053: LD_ADDR_EXP 36
18057: PUSH
18058: LD_INT 1
18060: ST_TO_ADDR
// end ; end ;
18061: GO 18064
18063: POP
// end ;
18064: LD_VAR 0 3
18068: RET
// every 0 0$5 trigger missionStart do var tmp ;
18069: LD_EXP 13
18073: IFFALSE 18356
18075: GO 18077
18077: DISABLE
18078: LD_INT 0
18080: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18081: LD_INT 35
18083: PPUSH
18084: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18088: LD_INT 14
18090: PPUSH
18091: LD_INT 22
18093: PUSH
18094: LD_INT 1
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: PPUSH
18101: CALL_OW 70
18105: PUSH
18106: LD_EXP 15
18110: PUSH
18111: LD_INT 2
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 4
18119: PUSH
18120: LD_INT 5
18122: PUSH
18123: EMPTY
18124: LIST
18125: LIST
18126: LIST
18127: LIST
18128: IN
18129: AND
18130: IFFALSE 18346
// begin powellAnger := powellAnger + 1 ;
18132: LD_ADDR_EXP 17
18136: PUSH
18137: LD_EXP 17
18141: PUSH
18142: LD_INT 1
18144: PLUS
18145: ST_TO_ADDR
// Video ( true ) ;
18146: LD_INT 1
18148: PPUSH
18149: CALL 107119 0 1
// CenterNowOnUnits ( tmp ) ;
18153: LD_VAR 0 1
18157: PPUSH
18158: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18162: LD_INT 14
18164: PPUSH
18165: LD_INT 22
18167: PUSH
18168: LD_INT 1
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: PPUSH
18175: CALL_OW 70
18179: PPUSH
18180: LD_INT 86
18182: PPUSH
18183: LD_INT 133
18185: PPUSH
18186: CALL_OW 111
// async ;
18190: ASYNC
// case powellAnger of 1 :
18191: LD_EXP 17
18195: PUSH
18196: LD_INT 1
18198: DOUBLE
18199: EQUAL
18200: IFTRUE 18204
18202: GO 18219
18204: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18205: LD_EXP 57
18209: PPUSH
18210: LD_STRING DBack1-Pow-1
18212: PPUSH
18213: CALL_OW 88
18217: GO 18266
18219: LD_INT 2
18221: DOUBLE
18222: EQUAL
18223: IFTRUE 18227
18225: GO 18242
18227: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18228: LD_EXP 57
18232: PPUSH
18233: LD_STRING DBack2-Pow-1
18235: PPUSH
18236: CALL_OW 88
18240: GO 18266
18242: LD_INT 3
18244: DOUBLE
18245: EQUAL
18246: IFTRUE 18250
18248: GO 18265
18250: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18251: LD_EXP 57
18255: PPUSH
18256: LD_STRING DBack3-Pow-1
18258: PPUSH
18259: CALL_OW 88
18263: GO 18266
18265: POP
// sync ;
18266: SYNC
// repeat wait ( 0 0$1 ) ;
18267: LD_INT 35
18269: PPUSH
18270: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18274: LD_INT 14
18276: PPUSH
18277: LD_INT 22
18279: PUSH
18280: LD_INT 1
18282: PUSH
18283: EMPTY
18284: LIST
18285: LIST
18286: PPUSH
18287: CALL_OW 70
18291: PPUSH
18292: LD_INT 86
18294: PPUSH
18295: LD_INT 133
18297: PPUSH
18298: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18302: LD_INT 14
18304: PPUSH
18305: LD_INT 22
18307: PUSH
18308: LD_INT 1
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: PPUSH
18315: CALL_OW 70
18319: NOT
18320: IFFALSE 18267
// if powellAnger >= 3 then
18322: LD_EXP 17
18326: PUSH
18327: LD_INT 3
18329: GREATEREQUAL
18330: IFFALSE 18339
// YouLost ( Dismissed ) ;
18332: LD_STRING Dismissed
18334: PPUSH
18335: CALL_OW 104
// Video ( false ) ;
18339: LD_INT 0
18341: PPUSH
18342: CALL 107119 0 1
// end ; until missionStage > 5 ;
18346: LD_EXP 15
18350: PUSH
18351: LD_INT 5
18353: GREATER
18354: IFFALSE 18081
// end ;
18356: PPOPN 1
18358: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18359: LD_EXP 13
18363: PUSH
18364: LD_INT 22
18366: PUSH
18367: LD_INT 4
18369: PUSH
18370: EMPTY
18371: LIST
18372: LIST
18373: PUSH
18374: LD_INT 21
18376: PUSH
18377: LD_INT 2
18379: PUSH
18380: EMPTY
18381: LIST
18382: LIST
18383: PUSH
18384: EMPTY
18385: LIST
18386: LIST
18387: PPUSH
18388: CALL_OW 69
18392: PUSH
18393: LD_INT 4
18395: GREATEREQUAL
18396: AND
18397: PUSH
18398: LD_EXP 15
18402: PUSH
18403: LD_INT 2
18405: EQUAL
18406: AND
18407: IFFALSE 20230
18409: GO 18411
18411: DISABLE
18412: LD_INT 0
18414: PPUSH
18415: PPUSH
18416: PPUSH
18417: PPUSH
18418: PPUSH
18419: PPUSH
18420: PPUSH
18421: PPUSH
// begin missionStage := 3 ;
18422: LD_ADDR_EXP 15
18426: PUSH
18427: LD_INT 3
18429: ST_TO_ADDR
// retreat := false ;
18430: LD_ADDR_VAR 0 4
18434: PUSH
18435: LD_INT 0
18437: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18438: LD_ADDR_VAR 0 5
18442: PUSH
18443: LD_INT 22
18445: PUSH
18446: LD_INT 4
18448: PUSH
18449: EMPTY
18450: LIST
18451: LIST
18452: PUSH
18453: LD_INT 30
18455: PUSH
18456: LD_INT 4
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: PPUSH
18467: CALL_OW 69
18471: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18472: LD_ADDR_VAR 0 6
18476: PUSH
18477: LD_INT 22
18479: PUSH
18480: LD_INT 4
18482: PUSH
18483: EMPTY
18484: LIST
18485: LIST
18486: PUSH
18487: LD_INT 30
18489: PUSH
18490: LD_INT 5
18492: PUSH
18493: EMPTY
18494: LIST
18495: LIST
18496: PUSH
18497: EMPTY
18498: LIST
18499: LIST
18500: PPUSH
18501: CALL_OW 69
18505: ST_TO_ADDR
// if not bar then
18506: LD_VAR 0 6
18510: NOT
18511: IFFALSE 18564
// begin repeat wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18520: LD_INT 22
18522: PUSH
18523: LD_INT 4
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PUSH
18530: LD_INT 3
18532: PUSH
18533: LD_INT 57
18535: PUSH
18536: EMPTY
18537: LIST
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: PUSH
18543: LD_INT 30
18545: PUSH
18546: LD_INT 5
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: PUSH
18553: EMPTY
18554: LIST
18555: LIST
18556: LIST
18557: PPUSH
18558: CALL_OW 69
18562: IFFALSE 18513
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18564: LD_ADDR_VAR 0 6
18568: PUSH
18569: LD_INT 22
18571: PUSH
18572: LD_INT 4
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 30
18581: PUSH
18582: LD_INT 5
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PPUSH
18593: CALL_OW 69
18597: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18598: LD_INT 35
18600: PPUSH
18601: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18605: LD_EXP 120
18609: PUSH
18610: LD_INT 4
18612: ARRAY
18613: PUSH
18614: LD_INT 4
18616: GREATEREQUAL
18617: IFFALSE 18598
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18619: LD_ADDR_VAR 0 2
18623: PUSH
18624: LD_INT 22
18626: PUSH
18627: LD_INT 4
18629: PUSH
18630: EMPTY
18631: LIST
18632: LIST
18633: PUSH
18634: LD_INT 2
18636: PUSH
18637: LD_INT 25
18639: PUSH
18640: LD_INT 1
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: LD_INT 25
18649: PUSH
18650: LD_INT 2
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: PUSH
18657: LD_INT 25
18659: PUSH
18660: LD_INT 3
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 25
18669: PUSH
18670: LD_INT 4
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 25
18679: PUSH
18680: LD_INT 5
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PPUSH
18699: CALL_OW 69
18703: PUSH
18704: LD_EXP 57
18708: PUSH
18709: LD_EXP 58
18713: ADD
18714: DIFF
18715: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18716: LD_ADDR_VAR 0 3
18720: PUSH
18721: LD_VAR 0 2
18725: PPUSH
18726: LD_INT 26
18728: PUSH
18729: LD_INT 1
18731: PUSH
18732: EMPTY
18733: LIST
18734: LIST
18735: PPUSH
18736: CALL_OW 72
18740: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18741: LD_ADDR_VAR 0 2
18745: PUSH
18746: LD_VAR 0 2
18750: PUSH
18751: LD_VAR 0 3
18755: DIFF
18756: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18757: LD_ADDR_VAR 0 2
18761: PUSH
18762: LD_VAR 0 2
18766: PPUSH
18767: LD_INT 1
18769: PPUSH
18770: CALL 105772 0 2
18774: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18775: LD_ADDR_VAR 0 3
18779: PUSH
18780: LD_VAR 0 3
18784: PPUSH
18785: LD_INT 1
18787: PPUSH
18788: CALL 105772 0 2
18792: ST_TO_ADDR
// for i = 1 to 4 do
18793: LD_ADDR_VAR 0 1
18797: PUSH
18798: DOUBLE
18799: LD_INT 1
18801: DEC
18802: ST_TO_ADDR
18803: LD_INT 4
18805: PUSH
18806: FOR_TO
18807: IFFALSE 18973
// begin if tmp2 then
18809: LD_VAR 0 3
18813: IFFALSE 18894
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18815: LD_ADDR_EXP 18
18819: PUSH
18820: LD_EXP 18
18824: PPUSH
18825: LD_INT 1
18827: PPUSH
18828: LD_EXP 18
18832: PUSH
18833: LD_INT 1
18835: ARRAY
18836: PUSH
18837: LD_VAR 0 3
18841: PUSH
18842: LD_VAR 0 3
18846: ARRAY
18847: ADD
18848: PPUSH
18849: CALL_OW 1
18853: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18854: LD_VAR 0 3
18858: PUSH
18859: LD_VAR 0 3
18863: ARRAY
18864: PPUSH
18865: LD_INT 1
18867: PPUSH
18868: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18872: LD_ADDR_VAR 0 3
18876: PUSH
18877: LD_VAR 0 3
18881: PPUSH
18882: LD_VAR 0 3
18886: PPUSH
18887: CALL_OW 3
18891: ST_TO_ADDR
// end else
18892: GO 18971
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18894: LD_ADDR_EXP 18
18898: PUSH
18899: LD_EXP 18
18903: PPUSH
18904: LD_INT 1
18906: PPUSH
18907: LD_EXP 18
18911: PUSH
18912: LD_INT 1
18914: ARRAY
18915: PUSH
18916: LD_VAR 0 2
18920: PUSH
18921: LD_VAR 0 2
18925: ARRAY
18926: ADD
18927: PPUSH
18928: CALL_OW 1
18932: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18933: LD_VAR 0 2
18937: PUSH
18938: LD_VAR 0 2
18942: ARRAY
18943: PPUSH
18944: LD_INT 1
18946: PPUSH
18947: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18951: LD_ADDR_VAR 0 2
18955: PUSH
18956: LD_VAR 0 2
18960: PPUSH
18961: LD_VAR 0 2
18965: PPUSH
18966: CALL_OW 3
18970: ST_TO_ADDR
// end ; end ;
18971: GO 18806
18973: POP
18974: POP
// if tmp2 then
18975: LD_VAR 0 3
18979: IFFALSE 18997
// tmp := tmp union tmp2 ;
18981: LD_ADDR_VAR 0 2
18985: PUSH
18986: LD_VAR 0 2
18990: PUSH
18991: LD_VAR 0 3
18995: UNION
18996: ST_TO_ADDR
// for i = 1 to 4 do
18997: LD_ADDR_VAR 0 1
19001: PUSH
19002: DOUBLE
19003: LD_INT 1
19005: DEC
19006: ST_TO_ADDR
19007: LD_INT 4
19009: PUSH
19010: FOR_TO
19011: IFFALSE 19060
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19013: LD_ADDR_EXP 18
19017: PUSH
19018: LD_EXP 18
19022: PPUSH
19023: LD_INT 2
19025: PPUSH
19026: LD_EXP 18
19030: PUSH
19031: LD_INT 2
19033: ARRAY
19034: PUSH
19035: LD_VAR 0 2
19039: PUSH
19040: LD_VAR 0 2
19044: PUSH
19045: LD_VAR 0 1
19049: MINUS
19050: ARRAY
19051: ADD
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
19058: GO 19010
19060: POP
19061: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19062: LD_ADDR_EXP 101
19066: PUSH
19067: LD_EXP 101
19071: PPUSH
19072: LD_INT 4
19074: PPUSH
19075: LD_EXP 101
19079: PUSH
19080: LD_INT 4
19082: ARRAY
19083: PUSH
19084: LD_EXP 18
19088: PUSH
19089: LD_INT 1
19091: ARRAY
19092: DIFF
19093: PPUSH
19094: CALL_OW 1
19098: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19099: LD_VAR 0 5
19103: PUSH
19104: LD_INT 1
19106: ARRAY
19107: PPUSH
19108: CALL_OW 313
19112: IFFALSE 19167
// begin for i in UnitsInside ( arm [ 1 ] ) do
19114: LD_ADDR_VAR 0 1
19118: PUSH
19119: LD_VAR 0 5
19123: PUSH
19124: LD_INT 1
19126: ARRAY
19127: PPUSH
19128: CALL_OW 313
19132: PUSH
19133: FOR_IN
19134: IFFALSE 19165
// begin ComExitBuilding ( i ) ;
19136: LD_VAR 0 1
19140: PPUSH
19141: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19145: LD_VAR 0 1
19149: PPUSH
19150: LD_VAR 0 6
19154: PUSH
19155: LD_INT 1
19157: ARRAY
19158: PPUSH
19159: CALL_OW 180
// end ;
19163: GO 19133
19165: POP
19166: POP
// end ; wait ( 0 0$3 ) ;
19167: LD_INT 105
19169: PPUSH
19170: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_EXP 18
19183: PUSH
19184: LD_INT 1
19186: ARRAY
19187: PUSH
19188: FOR_IN
19189: IFFALSE 19296
// begin if IsInUnit ( i ) then
19191: LD_VAR 0 1
19195: PPUSH
19196: CALL_OW 310
19200: IFFALSE 19211
// ComExitBuilding ( i ) ;
19202: LD_VAR 0 1
19206: PPUSH
19207: CALL_OW 122
// if GetClass ( i ) <> 1 then
19211: LD_VAR 0 1
19215: PPUSH
19216: CALL_OW 257
19220: PUSH
19221: LD_INT 1
19223: NONEQUAL
19224: IFFALSE 19265
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19226: LD_VAR 0 1
19230: PPUSH
19231: LD_VAR 0 5
19235: PUSH
19236: LD_INT 1
19238: ARRAY
19239: PPUSH
19240: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19244: LD_VAR 0 1
19248: PPUSH
19249: LD_INT 1
19251: PPUSH
19252: CALL_OW 183
// AddComExitBuilding ( i ) ;
19256: LD_VAR 0 1
19260: PPUSH
19261: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19265: LD_VAR 0 1
19269: PPUSH
19270: LD_INT 60
19272: PPUSH
19273: LD_INT 94
19275: PPUSH
19276: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19280: LD_VAR 0 1
19284: PPUSH
19285: LD_EXP 57
19289: PPUSH
19290: CALL_OW 179
// end ;
19294: GO 19188
19296: POP
19297: POP
// wait ( 0 0$15 ) ;
19298: LD_INT 525
19300: PPUSH
19301: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19305: LD_EXP 57
19309: PPUSH
19310: LD_STRING D4-Pow-1
19312: PPUSH
19313: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19317: LD_ADDR_VAR 0 2
19321: PUSH
19322: LD_EXP 18
19326: PUSH
19327: LD_INT 1
19329: ARRAY
19330: PPUSH
19331: LD_INT 26
19333: PUSH
19334: LD_INT 1
19336: PUSH
19337: EMPTY
19338: LIST
19339: LIST
19340: PPUSH
19341: CALL_OW 72
19345: ST_TO_ADDR
// if tmp then
19346: LD_VAR 0 2
19350: IFFALSE 19368
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19352: LD_VAR 0 2
19356: PUSH
19357: LD_INT 1
19359: ARRAY
19360: PPUSH
19361: LD_STRING D4-Sol1-1
19363: PPUSH
19364: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19368: LD_EXP 57
19372: PPUSH
19373: LD_STRING D4-Pow-2
19375: PPUSH
19376: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19380: LD_ADDR_VAR 0 1
19384: PUSH
19385: DOUBLE
19386: LD_INT 1
19388: DEC
19389: ST_TO_ADDR
19390: LD_EXP 18
19394: PUSH
19395: LD_INT 1
19397: ARRAY
19398: PUSH
19399: FOR_TO
19400: IFFALSE 19493
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19402: LD_EXP 18
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_VAR 0 1
19415: ARRAY
19416: PPUSH
19417: LD_EXP 120
19421: PUSH
19422: LD_INT 4
19424: ARRAY
19425: PUSH
19426: LD_INT 1
19428: ARRAY
19429: PPUSH
19430: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19434: LD_ADDR_EXP 120
19438: PUSH
19439: LD_EXP 120
19443: PPUSH
19444: LD_INT 4
19446: PPUSH
19447: LD_EXP 120
19451: PUSH
19452: LD_INT 4
19454: ARRAY
19455: PPUSH
19456: LD_INT 1
19458: PPUSH
19459: CALL_OW 3
19463: PPUSH
19464: CALL_OW 1
19468: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19469: LD_INT 8
19471: PPUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PUSH
19481: LD_VAR 0 1
19485: ARRAY
19486: PPUSH
19487: CALL_OW 471
// end ;
19491: GO 19399
19493: POP
19494: POP
// repeat wait ( 0 0$1 ) ;
19495: LD_INT 35
19497: PPUSH
19498: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19502: LD_EXP 18
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_INT 55
19513: PUSH
19514: EMPTY
19515: LIST
19516: PPUSH
19517: CALL_OW 72
19521: PUSH
19522: LD_INT 4
19524: GREATEREQUAL
19525: IFFALSE 19495
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19527: LD_EXP 18
19531: PUSH
19532: LD_INT 1
19534: ARRAY
19535: PPUSH
19536: LD_INT 69
19538: PPUSH
19539: LD_INT 94
19541: PPUSH
19542: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19546: LD_EXP 18
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PPUSH
19555: LD_INT 82
19557: PPUSH
19558: LD_INT 83
19560: PPUSH
19561: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19565: LD_EXP 18
19569: PUSH
19570: LD_INT 1
19572: ARRAY
19573: PPUSH
19574: LD_INT 77
19576: PPUSH
19577: LD_INT 69
19579: PPUSH
19580: CALL_OW 174
// repeat wait ( 3 ) ;
19584: LD_INT 3
19586: PPUSH
19587: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19591: LD_ADDR_VAR 0 1
19595: PUSH
19596: LD_EXP 18
19600: PUSH
19601: LD_INT 1
19603: ARRAY
19604: PUSH
19605: FOR_IN
19606: IFFALSE 19742
// begin if GetLives ( i ) < 990 then
19608: LD_VAR 0 1
19612: PPUSH
19613: CALL_OW 256
19617: PUSH
19618: LD_INT 990
19620: LESS
19621: IFFALSE 19635
// SetLives ( i , 1000 ) ;
19623: LD_VAR 0 1
19627: PPUSH
19628: LD_INT 1000
19630: PPUSH
19631: CALL_OW 234
// if not IsInUnit ( i ) then
19635: LD_VAR 0 1
19639: PPUSH
19640: CALL_OW 310
19644: NOT
19645: IFFALSE 19740
// begin if not HasTask ( i ) then
19647: LD_VAR 0 1
19651: PPUSH
19652: CALL_OW 314
19656: NOT
19657: IFFALSE 19674
// ComMoveXY ( i , 64 , 93 ) ;
19659: LD_VAR 0 1
19663: PPUSH
19664: LD_INT 64
19666: PPUSH
19667: LD_INT 93
19669: PPUSH
19670: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19674: LD_VAR 0 4
19678: NOT
19679: PUSH
19680: LD_VAR 0 1
19684: PPUSH
19685: CALL_OW 258
19689: PUSH
19690: LD_INT 1
19692: EQUAL
19693: AND
19694: IFFALSE 19740
// begin retreat := true ;
19696: LD_ADDR_VAR 0 4
19700: PUSH
19701: LD_INT 1
19703: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19704: LD_VAR 0 1
19708: PPUSH
19709: LD_INT 2
19711: PPUSH
19712: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19716: LD_VAR 0 1
19720: PPUSH
19721: LD_STRING D4a-Sol1-1
19723: PPUSH
19724: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19728: LD_EXP 57
19732: PPUSH
19733: LD_STRING D4a-Pow-1
19735: PPUSH
19736: CALL_OW 88
// end ; end ; end ;
19740: GO 19605
19742: POP
19743: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19744: LD_EXP 18
19748: PUSH
19749: LD_INT 1
19751: ARRAY
19752: PPUSH
19753: LD_INT 95
19755: PUSH
19756: LD_INT 9
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: LD_INT 3
19765: PUSH
19766: LD_INT 55
19768: PUSH
19769: EMPTY
19770: LIST
19771: PUSH
19772: EMPTY
19773: LIST
19774: LIST
19775: PUSH
19776: EMPTY
19777: LIST
19778: LIST
19779: PPUSH
19780: CALL_OW 72
19784: PUSH
19785: LD_INT 4
19787: GREATEREQUAL
19788: IFFALSE 19584
// for i in powellSquadAttack [ 1 ] do
19790: LD_ADDR_VAR 0 1
19794: PUSH
19795: LD_EXP 18
19799: PUSH
19800: LD_INT 1
19802: ARRAY
19803: PUSH
19804: FOR_IN
19805: IFFALSE 19941
// begin if GetTag ( i ) = 2 then
19807: LD_VAR 0 1
19811: PPUSH
19812: CALL_OW 110
19816: PUSH
19817: LD_INT 2
19819: EQUAL
19820: IFFALSE 19882
// begin ComMoveXY ( i , 60 , 94 ) ;
19822: LD_VAR 0 1
19826: PPUSH
19827: LD_INT 60
19829: PPUSH
19830: LD_INT 94
19832: PPUSH
19833: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19837: LD_VAR 0 1
19841: PPUSH
19842: LD_EXP 57
19846: PPUSH
19847: CALL_OW 179
// wait ( 0 0$3 ) ;
19851: LD_INT 105
19853: PPUSH
19854: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19858: LD_VAR 0 1
19862: PPUSH
19863: LD_STRING D4a-Sol1-2
19865: PPUSH
19866: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19870: LD_EXP 57
19874: PPUSH
19875: LD_STRING D4a-Pow-2
19877: PPUSH
19878: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19882: LD_VAR 0 1
19886: PPUSH
19887: LD_INT 0
19889: PPUSH
19890: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19894: LD_ADDR_EXP 101
19898: PUSH
19899: LD_EXP 101
19903: PPUSH
19904: LD_INT 4
19906: PPUSH
19907: LD_EXP 101
19911: PUSH
19912: LD_INT 4
19914: ARRAY
19915: PUSH
19916: LD_VAR 0 1
19920: UNION
19921: PPUSH
19922: CALL_OW 1
19926: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19927: LD_INT 8
19929: PPUSH
19930: LD_VAR 0 1
19934: PPUSH
19935: CALL_OW 472
// end ;
19939: GO 19804
19941: POP
19942: POP
// wait ( 4 4$00 ) ;
19943: LD_INT 8400
19945: PPUSH
19946: CALL_OW 67
// uc_side := 6 ;
19950: LD_ADDR_OWVAR 20
19954: PUSH
19955: LD_INT 6
19957: ST_TO_ADDR
// uc_nation := 3 ;
19958: LD_ADDR_OWVAR 21
19962: PUSH
19963: LD_INT 3
19965: ST_TO_ADDR
// ru := [ ] ;
19966: LD_ADDR_VAR 0 7
19970: PUSH
19971: EMPTY
19972: ST_TO_ADDR
// for i = 1 to 4 do
19973: LD_ADDR_VAR 0 1
19977: PUSH
19978: DOUBLE
19979: LD_INT 1
19981: DEC
19982: ST_TO_ADDR
19983: LD_INT 4
19985: PUSH
19986: FOR_TO
19987: IFFALSE 20088
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19989: LD_INT 22
19991: PPUSH
19992: LD_INT 1
19994: PPUSH
19995: LD_INT 3
19997: PPUSH
19998: LD_INT 43
20000: PUSH
20001: LD_INT 44
20003: PUSH
20004: EMPTY
20005: LIST
20006: LIST
20007: PUSH
20008: LD_INT 1
20010: PPUSH
20011: LD_INT 2
20013: PPUSH
20014: CALL_OW 12
20018: ARRAY
20019: PPUSH
20020: LD_INT 89
20022: PPUSH
20023: CALL 71376 0 5
// un := CreateVehicle ;
20027: LD_ADDR_VAR 0 8
20031: PUSH
20032: CALL_OW 45
20036: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20037: LD_VAR 0 8
20041: PPUSH
20042: LD_INT 4
20044: PPUSH
20045: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20049: LD_VAR 0 8
20053: PPUSH
20054: LD_INT 136
20056: PPUSH
20057: LD_INT 90
20059: PPUSH
20060: LD_INT 8
20062: PPUSH
20063: LD_INT 0
20065: PPUSH
20066: CALL_OW 50
// ru := ru ^ un ;
20070: LD_ADDR_VAR 0 7
20074: PUSH
20075: LD_VAR 0 7
20079: PUSH
20080: LD_VAR 0 8
20084: ADD
20085: ST_TO_ADDR
// end ;
20086: GO 19986
20088: POP
20089: POP
// if ru then
20090: LD_VAR 0 7
20094: IFFALSE 20111
// ComAgressiveMove ( ru , 80 , 92 ) ;
20096: LD_VAR 0 7
20100: PPUSH
20101: LD_INT 80
20103: PPUSH
20104: LD_INT 92
20106: PPUSH
20107: CALL_OW 114
// wait ( 8 8$00 ) ;
20111: LD_INT 16800
20113: PPUSH
20114: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20118: LD_INT 4
20120: PPUSH
20121: LD_INT 3
20123: PUSH
20124: LD_INT 1
20126: PUSH
20127: LD_INT 1
20129: PUSH
20130: LD_INT 5
20132: PUSH
20133: EMPTY
20134: LIST
20135: LIST
20136: LIST
20137: LIST
20138: PUSH
20139: LD_INT 4
20141: PUSH
20142: LD_INT 1
20144: PUSH
20145: LD_INT 1
20147: PUSH
20148: LD_INT 6
20150: PUSH
20151: EMPTY
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: PUSH
20157: LD_INT 4
20159: PUSH
20160: LD_INT 1
20162: PUSH
20163: LD_INT 1
20165: PUSH
20166: LD_INT 7
20168: PUSH
20169: EMPTY
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: PUSH
20175: LD_INT 3
20177: PUSH
20178: LD_INT 1
20180: PUSH
20181: LD_INT 1
20183: PUSH
20184: LD_INT 7
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: PUSH
20193: LD_INT 3
20195: PUSH
20196: LD_INT 1
20198: PUSH
20199: LD_INT 1
20201: PUSH
20202: LD_INT 5
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: LIST
20217: PPUSH
20218: CALL 57869 0 2
// missionStage := 4 ;
20222: LD_ADDR_EXP 15
20226: PUSH
20227: LD_INT 4
20229: ST_TO_ADDR
// end ;
20230: PPOPN 8
20232: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20233: LD_EXP 15
20237: PUSH
20238: LD_INT 4
20240: EQUAL
20241: PUSH
20242: LD_INT 22
20244: PUSH
20245: LD_INT 4
20247: PUSH
20248: EMPTY
20249: LIST
20250: LIST
20251: PUSH
20252: LD_INT 21
20254: PUSH
20255: LD_INT 2
20257: PUSH
20258: EMPTY
20259: LIST
20260: LIST
20261: PUSH
20262: EMPTY
20263: LIST
20264: LIST
20265: PPUSH
20266: CALL_OW 69
20270: PUSH
20271: LD_INT 5
20273: GREATEREQUAL
20274: AND
20275: IFFALSE 24380
20277: GO 20279
20279: DISABLE
20280: LD_INT 0
20282: PPUSH
20283: PPUSH
20284: PPUSH
20285: PPUSH
20286: PPUSH
20287: PPUSH
20288: PPUSH
20289: PPUSH
20290: PPUSH
20291: PPUSH
20292: PPUSH
20293: PPUSH
20294: PPUSH
// begin missionStage := 5 ;
20295: LD_ADDR_EXP 15
20299: PUSH
20300: LD_INT 5
20302: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20303: LD_ADDR_VAR 0 10
20307: PUSH
20308: LD_INT 22
20310: PUSH
20311: LD_INT 4
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 2
20320: PUSH
20321: LD_INT 30
20323: PUSH
20324: LD_INT 4
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: PUSH
20331: LD_INT 30
20333: PUSH
20334: LD_INT 5
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: LIST
20345: PUSH
20346: EMPTY
20347: LIST
20348: LIST
20349: PPUSH
20350: CALL_OW 69
20354: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20355: LD_ADDR_VAR 0 6
20359: PUSH
20360: LD_INT 22
20362: PUSH
20363: LD_INT 4
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: PUSH
20370: LD_INT 21
20372: PUSH
20373: LD_INT 1
20375: PUSH
20376: EMPTY
20377: LIST
20378: LIST
20379: PUSH
20380: LD_INT 3
20382: PUSH
20383: LD_INT 25
20385: PUSH
20386: LD_INT 16
20388: PUSH
20389: EMPTY
20390: LIST
20391: LIST
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 3
20399: PUSH
20400: LD_INT 25
20402: PUSH
20403: LD_INT 12
20405: PUSH
20406: EMPTY
20407: LIST
20408: LIST
20409: PUSH
20410: EMPTY
20411: LIST
20412: LIST
20413: PUSH
20414: EMPTY
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: PPUSH
20420: CALL_OW 69
20424: PUSH
20425: LD_EXP 57
20429: DIFF
20430: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20431: LD_ADDR_VAR 0 9
20435: PUSH
20436: LD_INT 22
20438: PUSH
20439: LD_INT 4
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: PUSH
20446: LD_INT 30
20448: PUSH
20449: LD_INT 3
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: PUSH
20465: LD_INT 1
20467: ARRAY
20468: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20469: LD_INT 35
20471: PPUSH
20472: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20476: LD_EXP 120
20480: PUSH
20481: LD_INT 4
20483: ARRAY
20484: PUSH
20485: LD_INT 5
20487: GREATEREQUAL
20488: PUSH
20489: LD_EXP 120
20493: PUSH
20494: LD_INT 4
20496: ARRAY
20497: PPUSH
20498: LD_INT 58
20500: PUSH
20501: EMPTY
20502: LIST
20503: PPUSH
20504: CALL_OW 72
20508: PUSH
20509: LD_INT 5
20511: GREATEREQUAL
20512: AND
20513: IFFALSE 20469
// powellAllowRetreat := false ;
20515: LD_ADDR_EXP 19
20519: PUSH
20520: LD_INT 0
20522: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20523: LD_INT 700
20525: PPUSH
20526: CALL_OW 67
// activeAttacks := false ;
20530: LD_ADDR_EXP 16
20534: PUSH
20535: LD_INT 0
20537: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20538: LD_INT 35
20540: PPUSH
20541: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20545: LD_INT 22
20547: PUSH
20548: LD_INT 6
20550: PUSH
20551: EMPTY
20552: LIST
20553: LIST
20554: PPUSH
20555: CALL_OW 69
20559: PUSH
20560: LD_INT 0
20562: EQUAL
20563: IFFALSE 20538
// tmp := mc_vehicles [ 4 ] ;
20565: LD_ADDR_VAR 0 3
20569: PUSH
20570: LD_EXP 120
20574: PUSH
20575: LD_INT 4
20577: ARRAY
20578: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20579: LD_ADDR_VAR 0 1
20583: PUSH
20584: DOUBLE
20585: LD_INT 1
20587: DEC
20588: ST_TO_ADDR
20589: LD_EXP 18
20593: PUSH
20594: FOR_TO
20595: IFFALSE 20856
// begin for j in powellSquadAttack [ i ] do
20597: LD_ADDR_VAR 0 2
20601: PUSH
20602: LD_EXP 18
20606: PUSH
20607: LD_VAR 0 1
20611: ARRAY
20612: PUSH
20613: FOR_IN
20614: IFFALSE 20852
// begin forces := forces diff j ;
20616: LD_ADDR_VAR 0 6
20620: PUSH
20621: LD_VAR 0 6
20625: PUSH
20626: LD_VAR 0 2
20630: DIFF
20631: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20632: LD_VAR 0 2
20636: PPUSH
20637: LD_INT 1
20639: PPUSH
20640: CALL_OW 109
// wait ( 0 0$2 ) ;
20644: LD_INT 70
20646: PPUSH
20647: CALL_OW 67
// if IsInUnit ( j ) then
20651: LD_VAR 0 2
20655: PPUSH
20656: CALL_OW 310
20660: IFFALSE 20671
// ComExitBuilding ( j ) ;
20662: LD_VAR 0 2
20666: PPUSH
20667: CALL_OW 122
// if GetClass ( j ) <> 1 then
20671: LD_VAR 0 2
20675: PPUSH
20676: CALL_OW 257
20680: PUSH
20681: LD_INT 1
20683: NONEQUAL
20684: IFFALSE 20764
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20686: LD_VAR 0 10
20690: PUSH
20691: LD_INT 1
20693: ARRAY
20694: PPUSH
20695: CALL_OW 313
20699: PUSH
20700: LD_INT 5
20702: GREATEREQUAL
20703: IFFALSE 20725
// AddComEnterUnit ( j , arm [ 2 ] ) else
20705: LD_VAR 0 2
20709: PPUSH
20710: LD_VAR 0 10
20714: PUSH
20715: LD_INT 2
20717: ARRAY
20718: PPUSH
20719: CALL_OW 180
20723: GO 20743
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20725: LD_VAR 0 2
20729: PPUSH
20730: LD_VAR 0 10
20734: PUSH
20735: LD_INT 1
20737: ARRAY
20738: PPUSH
20739: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20743: LD_VAR 0 2
20747: PPUSH
20748: LD_INT 1
20750: PPUSH
20751: CALL_OW 183
// AddComExitBuilding ( j ) ;
20755: LD_VAR 0 2
20759: PPUSH
20760: CALL_OW 182
// end ; if i = 2 then
20764: LD_VAR 0 1
20768: PUSH
20769: LD_INT 2
20771: EQUAL
20772: IFFALSE 20789
// AddComMoveXY ( j , 61 , 93 ) ;
20774: LD_VAR 0 2
20778: PPUSH
20779: LD_INT 61
20781: PPUSH
20782: LD_INT 93
20784: PPUSH
20785: CALL_OW 171
// if i = 1 then
20789: LD_VAR 0 1
20793: PUSH
20794: LD_INT 1
20796: EQUAL
20797: IFFALSE 20850
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20799: LD_VAR 0 2
20803: PPUSH
20804: LD_VAR 0 3
20808: PUSH
20809: LD_INT 1
20811: ARRAY
20812: PPUSH
20813: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20817: LD_ADDR_VAR 0 3
20821: PUSH
20822: LD_VAR 0 3
20826: PPUSH
20827: LD_INT 1
20829: PPUSH
20830: CALL_OW 3
20834: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20835: LD_VAR 0 2
20839: PPUSH
20840: LD_INT 69
20842: PPUSH
20843: LD_INT 94
20845: PPUSH
20846: CALL_OW 171
// end ; end ;
20850: GO 20613
20852: POP
20853: POP
// end ;
20854: GO 20594
20856: POP
20857: POP
// wait ( 0 0$55 ) ;
20858: LD_INT 1925
20860: PPUSH
20861: CALL_OW 67
// MC_Kill ( 4 ) ;
20865: LD_INT 4
20867: PPUSH
20868: CALL 34457 0 1
// tmp := UnitsInside ( fac ) ;
20872: LD_ADDR_VAR 0 3
20876: PUSH
20877: LD_VAR 0 9
20881: PPUSH
20882: CALL_OW 313
20886: ST_TO_ADDR
// if tmp then
20887: LD_VAR 0 3
20891: IFFALSE 21012
// for i in tmp do
20893: LD_ADDR_VAR 0 1
20897: PUSH
20898: LD_VAR 0 3
20902: PUSH
20903: FOR_IN
20904: IFFALSE 21010
// begin ComExitBuilding ( i ) ;
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20915: LD_VAR 0 10
20919: PUSH
20920: LD_INT 2
20922: ARRAY
20923: PPUSH
20924: CALL_OW 313
20928: PUSH
20929: LD_INT 6
20931: LESS
20932: IFFALSE 20954
// AddComEnterUnit ( i , arm [ 2 ] ) else
20934: LD_VAR 0 1
20938: PPUSH
20939: LD_VAR 0 10
20943: PUSH
20944: LD_INT 2
20946: ARRAY
20947: PPUSH
20948: CALL_OW 180
20952: GO 21008
// if UnitsInside ( arm [ 1 ] ) < 6 then
20954: LD_VAR 0 10
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 313
20967: PUSH
20968: LD_INT 6
20970: LESS
20971: IFFALSE 20993
// AddComEnterUnit ( i , arm [ 1 ] ) else
20973: LD_VAR 0 1
20977: PPUSH
20978: LD_VAR 0 10
20982: PUSH
20983: LD_INT 1
20985: ARRAY
20986: PPUSH
20987: CALL_OW 180
20991: GO 21008
// AddComMoveXY ( i , 37 , 68 ) ;
20993: LD_VAR 0 1
20997: PPUSH
20998: LD_INT 37
21000: PPUSH
21001: LD_INT 68
21003: PPUSH
21004: CALL_OW 171
// end ;
21008: GO 20903
21010: POP
21011: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21012: LD_ADDR_VAR 0 11
21016: PUSH
21017: LD_VAR 0 6
21021: PPUSH
21022: LD_INT 26
21024: PUSH
21025: LD_INT 1
21027: PUSH
21028: EMPTY
21029: LIST
21030: LIST
21031: PPUSH
21032: CALL_OW 72
21036: PUSH
21037: LD_EXP 58
21041: DIFF
21042: ST_TO_ADDR
// if not speaker then
21043: LD_VAR 0 11
21047: NOT
21048: IFFALSE 21075
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21050: LD_ADDR_VAR 0 11
21054: PUSH
21055: LD_VAR 0 6
21059: PPUSH
21060: LD_INT 26
21062: PUSH
21063: LD_INT 1
21065: PUSH
21066: EMPTY
21067: LIST
21068: LIST
21069: PPUSH
21070: CALL_OW 72
21074: ST_TO_ADDR
// if speaker then
21075: LD_VAR 0 11
21079: IFFALSE 21095
// speaker := speaker [ 1 ] ;
21081: LD_ADDR_VAR 0 11
21085: PUSH
21086: LD_VAR 0 11
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: ST_TO_ADDR
// Video ( true ) ;
21095: LD_INT 1
21097: PPUSH
21098: CALL 107119 0 1
// CenterNowOnUnits ( Powell ) ;
21102: LD_EXP 57
21106: PPUSH
21107: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21111: LD_ADDR_VAR 0 3
21115: PUSH
21116: LD_VAR 0 6
21120: PPUSH
21121: LD_INT 3
21123: PUSH
21124: LD_INT 25
21126: PUSH
21127: LD_INT 1
21129: PUSH
21130: EMPTY
21131: LIST
21132: LIST
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: PPUSH
21138: CALL_OW 72
21142: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21143: LD_ADDR_VAR 0 12
21147: PUSH
21148: LD_INT 22
21150: PUSH
21151: LD_INT 4
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: PUSH
21158: LD_INT 30
21160: PUSH
21161: LD_INT 32
21163: PUSH
21164: EMPTY
21165: LIST
21166: LIST
21167: PUSH
21168: LD_INT 58
21170: PUSH
21171: EMPTY
21172: LIST
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: LIST
21178: PPUSH
21179: CALL_OW 69
21183: ST_TO_ADDR
// for i = 1 to 6 do
21184: LD_ADDR_VAR 0 1
21188: PUSH
21189: DOUBLE
21190: LD_INT 1
21192: DEC
21193: ST_TO_ADDR
21194: LD_INT 6
21196: PUSH
21197: FOR_TO
21198: IFFALSE 21339
// begin if IsInUnit ( tmp [ i ] ) then
21200: LD_VAR 0 3
21204: PUSH
21205: LD_VAR 0 1
21209: ARRAY
21210: PPUSH
21211: CALL_OW 310
21215: IFFALSE 21232
// ComExitBuilding ( tmp [ i ] ) ;
21217: LD_VAR 0 3
21221: PUSH
21222: LD_VAR 0 1
21226: ARRAY
21227: PPUSH
21228: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21232: LD_VAR 0 3
21236: PUSH
21237: LD_VAR 0 1
21241: ARRAY
21242: PPUSH
21243: LD_VAR 0 10
21247: PUSH
21248: LD_INT 1
21250: ARRAY
21251: PPUSH
21252: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21256: LD_VAR 0 3
21260: PUSH
21261: LD_VAR 0 1
21265: ARRAY
21266: PPUSH
21267: LD_INT 1
21269: PPUSH
21270: CALL_OW 183
// if emp_towers then
21274: LD_VAR 0 12
21278: IFFALSE 21337
// begin AddComExitBuilding ( tmp [ i ] ) ;
21280: LD_VAR 0 3
21284: PUSH
21285: LD_VAR 0 1
21289: ARRAY
21290: PPUSH
21291: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21295: LD_VAR 0 3
21299: PUSH
21300: LD_VAR 0 1
21304: ARRAY
21305: PPUSH
21306: LD_VAR 0 12
21310: PUSH
21311: LD_INT 1
21313: ARRAY
21314: PPUSH
21315: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21319: LD_ADDR_VAR 0 12
21323: PUSH
21324: LD_VAR 0 12
21328: PPUSH
21329: LD_INT 1
21331: PPUSH
21332: CALL_OW 3
21336: ST_TO_ADDR
// end ; end ;
21337: GO 21197
21339: POP
21340: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21341: LD_ADDR_VAR 0 3
21345: PUSH
21346: LD_EXP 18
21350: PUSH
21351: LD_INT 1
21353: ARRAY
21354: PUSH
21355: LD_EXP 18
21359: PUSH
21360: LD_INT 2
21362: ARRAY
21363: ADD
21364: PPUSH
21365: LD_INT 26
21367: PUSH
21368: LD_INT 1
21370: PUSH
21371: EMPTY
21372: LIST
21373: LIST
21374: PPUSH
21375: CALL_OW 72
21379: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21380: LD_ADDR_VAR 0 1
21384: PUSH
21385: LD_EXP 18
21389: PUSH
21390: LD_INT 2
21392: ARRAY
21393: PUSH
21394: FOR_IN
21395: IFFALSE 21413
// ComTurnUnit ( i , Powell ) ;
21397: LD_VAR 0 1
21401: PPUSH
21402: LD_EXP 57
21406: PPUSH
21407: CALL_OW 119
21411: GO 21394
21413: POP
21414: POP
// Say ( Powell , D5-Pow-1 ) ;
21415: LD_EXP 57
21419: PPUSH
21420: LD_STRING D5-Pow-1
21422: PPUSH
21423: CALL_OW 88
// if tmp then
21427: LD_VAR 0 3
21431: IFFALSE 21449
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21433: LD_VAR 0 3
21437: PUSH
21438: LD_INT 1
21440: ARRAY
21441: PPUSH
21442: LD_STRING D5-Sol2-1
21444: PPUSH
21445: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21449: LD_EXP 57
21453: PPUSH
21454: LD_STRING D5-Pow-2
21456: PPUSH
21457: CALL_OW 88
// if tmp > 1 then
21461: LD_VAR 0 3
21465: PUSH
21466: LD_INT 1
21468: GREATER
21469: IFFALSE 21487
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21471: LD_VAR 0 3
21475: PUSH
21476: LD_INT 2
21478: ARRAY
21479: PPUSH
21480: LD_STRING D5-Sol2-2
21482: PPUSH
21483: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21487: LD_EXP 57
21491: PPUSH
21492: LD_STRING D5-Pow-3
21494: PPUSH
21495: CALL_OW 88
// wait ( 0 0$1 ) ;
21499: LD_INT 35
21501: PPUSH
21502: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21506: LD_ADDR_VAR 0 3
21510: PUSH
21511: LD_EXP 18
21515: PUSH
21516: LD_INT 1
21518: ARRAY
21519: PUSH
21520: LD_EXP 18
21524: PUSH
21525: LD_INT 2
21527: ARRAY
21528: UNION
21529: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21530: LD_VAR 0 3
21534: PPUSH
21535: LD_INT 80
21537: PPUSH
21538: LD_INT 67
21540: PPUSH
21541: CALL_OW 114
// wait ( 0 0$2 ) ;
21545: LD_INT 70
21547: PPUSH
21548: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21552: LD_INT 79
21554: PPUSH
21555: LD_INT 72
21557: PPUSH
21558: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21562: LD_INT 35
21564: PPUSH
21565: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21569: LD_VAR 0 3
21573: PPUSH
21574: LD_INT 3
21576: PUSH
21577: LD_INT 24
21579: PUSH
21580: LD_INT 1000
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: PUSH
21587: EMPTY
21588: LIST
21589: LIST
21590: PPUSH
21591: CALL_OW 72
21595: IFFALSE 21562
// Say ( Powell , D5a-Pow-1 ) ;
21597: LD_EXP 57
21601: PPUSH
21602: LD_STRING D5a-Pow-1
21604: PPUSH
21605: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21609: LD_EXP 57
21613: PPUSH
21614: LD_STRING D5a-Pow-1a
21616: PPUSH
21617: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21621: LD_INT 10
21623: PPUSH
21624: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21628: LD_EXP 57
21632: PPUSH
21633: LD_STRING D5a-Pow-1b
21635: PPUSH
21636: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21640: LD_EXP 57
21644: PPUSH
21645: LD_STRING D5a-Pow-1c
21647: PPUSH
21648: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21652: LD_EXP 57
21656: PPUSH
21657: LD_STRING D5a-Pow-1d
21659: PPUSH
21660: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21664: LD_INT 35
21666: PPUSH
21667: CALL_OW 67
// if not HasTask ( tmp ) then
21671: LD_VAR 0 3
21675: PPUSH
21676: CALL_OW 314
21680: NOT
21681: IFFALSE 21698
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21683: LD_VAR 0 3
21687: PPUSH
21688: LD_INT 80
21690: PPUSH
21691: LD_INT 67
21693: PPUSH
21694: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21698: LD_VAR 0 3
21702: PPUSH
21703: LD_INT 24
21705: PUSH
21706: LD_INT 1
21708: PUSH
21709: EMPTY
21710: LIST
21711: LIST
21712: PPUSH
21713: CALL_OW 72
21717: NOT
21718: IFFALSE 21664
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21720: LD_ADDR_VAR 0 3
21724: PUSH
21725: LD_INT 22
21727: PUSH
21728: LD_INT 4
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PUSH
21735: LD_INT 92
21737: PUSH
21738: LD_INT 60
21740: PUSH
21741: LD_INT 93
21743: PUSH
21744: LD_INT 10
21746: PUSH
21747: EMPTY
21748: LIST
21749: LIST
21750: LIST
21751: LIST
21752: PUSH
21753: LD_INT 3
21755: PUSH
21756: LD_INT 54
21758: PUSH
21759: EMPTY
21760: LIST
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: EMPTY
21767: LIST
21768: LIST
21769: LIST
21770: PPUSH
21771: CALL_OW 69
21775: PUSH
21776: LD_EXP 57
21780: DIFF
21781: ST_TO_ADDR
// if tmp then
21782: LD_VAR 0 3
21786: IFFALSE 21820
// for i in tmp do
21788: LD_ADDR_VAR 0 1
21792: PUSH
21793: LD_VAR 0 3
21797: PUSH
21798: FOR_IN
21799: IFFALSE 21818
// ComMoveXY ( i , 36 , 67 ) ;
21801: LD_VAR 0 1
21805: PPUSH
21806: LD_INT 36
21808: PPUSH
21809: LD_INT 67
21811: PPUSH
21812: CALL_OW 111
21816: GO 21798
21818: POP
21819: POP
// wait ( 0 0$3 ) ;
21820: LD_INT 105
21822: PPUSH
21823: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21827: LD_VAR 0 11
21831: PPUSH
21832: LD_STRING D6-Sol3-1
21834: PPUSH
21835: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21839: LD_EXP 57
21843: PPUSH
21844: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21848: LD_EXP 57
21852: PPUSH
21853: LD_STRING D6-Pow-1
21855: PPUSH
21856: CALL_OW 88
// tmp := [ ] ;
21860: LD_ADDR_VAR 0 3
21864: PUSH
21865: EMPTY
21866: ST_TO_ADDR
// for i = 1 to 2 do
21867: LD_ADDR_VAR 0 1
21871: PUSH
21872: DOUBLE
21873: LD_INT 1
21875: DEC
21876: ST_TO_ADDR
21877: LD_INT 2
21879: PUSH
21880: FOR_TO
21881: IFFALSE 21995
// begin uc_side := 8 ;
21883: LD_ADDR_OWVAR 20
21887: PUSH
21888: LD_INT 8
21890: ST_TO_ADDR
// uc_nation := 2 ;
21891: LD_ADDR_OWVAR 21
21895: PUSH
21896: LD_INT 2
21898: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21899: LD_INT 14
21901: PPUSH
21902: LD_INT 3
21904: PPUSH
21905: LD_INT 2
21907: PPUSH
21908: LD_INT 29
21910: PPUSH
21911: LD_INT 100
21913: PPUSH
21914: CALL 71376 0 5
// veh := CreateVehicle ;
21918: LD_ADDR_VAR 0 13
21922: PUSH
21923: CALL_OW 45
21927: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21928: LD_VAR 0 13
21932: PPUSH
21933: LD_INT 4
21935: PPUSH
21936: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21940: LD_VAR 0 13
21944: PPUSH
21945: LD_INT 99
21947: PPUSH
21948: LD_INT 83
21950: PPUSH
21951: LD_INT 6
21953: PPUSH
21954: LD_INT 0
21956: PPUSH
21957: CALL_OW 50
// wait ( 3 ) ;
21961: LD_INT 3
21963: PPUSH
21964: CALL_OW 67
// Connect ( veh ) ;
21968: LD_VAR 0 13
21972: PPUSH
21973: CALL 74431 0 1
// tmp := tmp ^ veh ;
21977: LD_ADDR_VAR 0 3
21981: PUSH
21982: LD_VAR 0 3
21986: PUSH
21987: LD_VAR 0 13
21991: ADD
21992: ST_TO_ADDR
// end ;
21993: GO 21880
21995: POP
21996: POP
// wait ( 0 0$1 ) ;
21997: LD_INT 35
21999: PPUSH
22000: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22004: LD_INT 99
22006: PPUSH
22007: LD_INT 83
22009: PPUSH
22010: LD_INT 1
22012: PPUSH
22013: LD_INT 10
22015: PPUSH
22016: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22020: LD_INT 99
22022: PPUSH
22023: LD_INT 83
22025: PPUSH
22026: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22030: LD_VAR 0 11
22034: PPUSH
22035: LD_STRING D6-Sol3-2
22037: PPUSH
22038: CALL_OW 88
// async ;
22042: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22043: LD_EXP 57
22047: PPUSH
22048: LD_STRING D6-Pow-2
22050: PPUSH
22051: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22055: LD_VAR 0 3
22059: PUSH
22060: LD_INT 1
22062: ARRAY
22063: PPUSH
22064: LD_VAR 0 9
22068: PPUSH
22069: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22073: LD_VAR 0 3
22077: PUSH
22078: LD_INT 2
22080: ARRAY
22081: PPUSH
22082: LD_INT 22
22084: PUSH
22085: LD_INT 4
22087: PUSH
22088: EMPTY
22089: LIST
22090: LIST
22091: PUSH
22092: LD_INT 21
22094: PUSH
22095: LD_INT 3
22097: PUSH
22098: EMPTY
22099: LIST
22100: LIST
22101: PUSH
22102: EMPTY
22103: LIST
22104: LIST
22105: PPUSH
22106: CALL_OW 69
22110: PPUSH
22111: LD_VAR 0 3
22115: PUSH
22116: LD_INT 2
22118: ARRAY
22119: PPUSH
22120: CALL_OW 74
22124: PPUSH
22125: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22129: LD_EXP 57
22133: PPUSH
22134: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22138: LD_INT 99
22140: PPUSH
22141: LD_INT 83
22143: PPUSH
22144: LD_INT 1
22146: PPUSH
22147: CALL_OW 331
// repeat wait ( 4 ) ;
22151: LD_INT 4
22153: PPUSH
22154: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22158: LD_VAR 0 3
22162: PUSH
22163: LD_INT 1
22165: ARRAY
22166: PPUSH
22167: CALL_OW 256
22171: PUSH
22172: LD_INT 1000
22174: LESS
22175: IFFALSE 22193
// SetLives ( tmp [ 1 ] , 1000 ) ;
22177: LD_VAR 0 3
22181: PUSH
22182: LD_INT 1
22184: ARRAY
22185: PPUSH
22186: LD_INT 1000
22188: PPUSH
22189: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22193: LD_INT 22
22195: PUSH
22196: LD_INT 4
22198: PUSH
22199: EMPTY
22200: LIST
22201: LIST
22202: PUSH
22203: LD_INT 30
22205: PUSH
22206: LD_INT 3
22208: PUSH
22209: EMPTY
22210: LIST
22211: LIST
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PPUSH
22217: CALL_OW 69
22221: PUSH
22222: LD_INT 0
22224: EQUAL
22225: IFFALSE 22151
// sync ;
22227: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22228: LD_EXP 57
22232: PPUSH
22233: LD_STRING D6a-Pow-1
22235: PPUSH
22236: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22240: LD_VAR 0 11
22244: PPUSH
22245: LD_STRING D6a-Sol3-1
22247: PPUSH
22248: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22252: LD_EXP 57
22256: PPUSH
22257: LD_STRING D6a-Pow-2
22259: PPUSH
22260: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22264: LD_VAR 0 11
22268: PPUSH
22269: LD_STRING D6a-Sol3-2
22271: PPUSH
22272: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22276: LD_EXP 57
22280: PPUSH
22281: LD_STRING D6a-Pow-3
22283: PPUSH
22284: CALL_OW 88
// powellCenterCameraMode := true ;
22288: LD_ADDR_EXP 20
22292: PUSH
22293: LD_INT 1
22295: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22296: LD_ADDR_VAR 0 1
22300: PUSH
22301: LD_INT 22
22303: PUSH
22304: LD_INT 8
22306: PUSH
22307: EMPTY
22308: LIST
22309: LIST
22310: PUSH
22311: LD_INT 25
22313: PUSH
22314: LD_INT 2
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: PUSH
22321: EMPTY
22322: LIST
22323: LIST
22324: PPUSH
22325: CALL_OW 69
22329: PUSH
22330: FOR_IN
22331: IFFALSE 22386
// begin SetTag ( i , 1 ) ;
22333: LD_VAR 0 1
22337: PPUSH
22338: LD_INT 1
22340: PPUSH
22341: CALL_OW 109
// ComExitBuilding ( i ) ;
22345: LD_VAR 0 1
22349: PPUSH
22350: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22354: LD_VAR 0 1
22358: PPUSH
22359: LD_INT 35
22361: PPUSH
22362: LD_INT 6
22364: PPUSH
22365: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22369: LD_VAR 0 1
22373: PPUSH
22374: LD_INT 53
22376: PPUSH
22377: LD_INT 4
22379: PPUSH
22380: CALL_OW 171
// end ;
22384: GO 22330
22386: POP
22387: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22388: LD_ADDR_VAR 0 3
22392: PUSH
22393: LD_INT 22
22395: PUSH
22396: LD_INT 4
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PUSH
22403: LD_INT 21
22405: PUSH
22406: LD_INT 2
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PUSH
22413: LD_INT 3
22415: PUSH
22416: LD_INT 34
22418: PUSH
22419: LD_INT 12
22421: PUSH
22422: EMPTY
22423: LIST
22424: LIST
22425: PUSH
22426: EMPTY
22427: LIST
22428: LIST
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: LIST
22434: PPUSH
22435: CALL_OW 69
22439: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22440: LD_EXP 57
22444: PPUSH
22445: LD_VAR 0 3
22449: PPUSH
22450: LD_EXP 57
22454: PPUSH
22455: CALL_OW 74
22459: PPUSH
22460: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22464: LD_EXP 57
22468: PPUSH
22469: LD_INT 100
22471: PPUSH
22472: LD_INT 88
22474: PPUSH
22475: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22479: LD_EXP 57
22483: PPUSH
22484: LD_INT 100
22486: PPUSH
22487: LD_INT 75
22489: PPUSH
22490: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22494: LD_EXP 57
22498: PPUSH
22499: LD_INT 88
22501: PPUSH
22502: LD_INT 53
22504: PPUSH
22505: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22509: LD_INT 8
22511: PPUSH
22512: LD_EXP 57
22516: PPUSH
22517: CALL_OW 471
// repeat wait ( 3 ) ;
22521: LD_INT 3
22523: PPUSH
22524: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22528: LD_INT 22
22530: PUSH
22531: LD_INT 4
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 92
22540: PUSH
22541: LD_INT 100
22543: PUSH
22544: LD_INT 75
22546: PUSH
22547: LD_INT 6
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: LIST
22554: LIST
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: PPUSH
22560: CALL_OW 69
22564: IFFALSE 22521
// async ;
22566: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22567: LD_EXP 57
22571: PPUSH
22572: LD_STRING D6b-Pow-1
22574: PPUSH
22575: CALL_OW 88
// repeat wait ( 3 ) ;
22579: LD_INT 3
22581: PPUSH
22582: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22586: LD_EXP 57
22590: PPUSH
22591: CALL_OW 310
22595: PPUSH
22596: CALL_OW 256
22600: PUSH
22601: LD_INT 1000
22603: LESS
22604: IFFALSE 22623
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22606: LD_EXP 57
22610: PPUSH
22611: CALL_OW 310
22615: PPUSH
22616: LD_INT 1000
22618: PPUSH
22619: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22623: LD_EXP 57
22627: PPUSH
22628: CALL_OW 256
22632: PUSH
22633: LD_INT 1000
22635: LESS
22636: IFFALSE 22650
// SetLives ( Powell , 1000 ) ;
22638: LD_EXP 57
22642: PPUSH
22643: LD_INT 1000
22645: PPUSH
22646: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22650: LD_EXP 57
22654: PPUSH
22655: LD_EXP 62
22659: PPUSH
22660: CALL_OW 296
22664: PUSH
22665: LD_INT 5
22667: LESS
22668: PUSH
22669: LD_EXP 57
22673: PPUSH
22674: CALL_OW 310
22678: PPUSH
22679: LD_EXP 62
22683: PPUSH
22684: CALL_OW 296
22688: PUSH
22689: LD_INT 5
22691: LESS
22692: OR
22693: IFFALSE 22712
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22695: LD_EXP 57
22699: PPUSH
22700: CALL_OW 310
22704: PPUSH
22705: LD_INT 100
22707: PPUSH
22708: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22712: LD_EXP 57
22716: PPUSH
22717: CALL_OW 310
22721: NOT
22722: IFFALSE 22579
// DoNotAttack ( 8 , powellBomb ) ;
22724: LD_INT 8
22726: PPUSH
22727: LD_EXP 62
22731: PPUSH
22732: CALL_OW 471
// game_speed := 4 ;
22736: LD_ADDR_OWVAR 65
22740: PUSH
22741: LD_INT 4
22743: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22744: LD_EXP 57
22748: PPUSH
22749: LD_STRING D6b-Pow-1a
22751: PPUSH
22752: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22756: LD_EXP 57
22760: PPUSH
22761: LD_EXP 62
22765: PPUSH
22766: CALL_OW 180
// sync ;
22770: SYNC
// repeat wait ( 0 0$1 ) ;
22771: LD_INT 35
22773: PPUSH
22774: CALL_OW 67
// until IsInUnit ( Powell ) ;
22778: LD_EXP 57
22782: PPUSH
22783: CALL_OW 310
22787: IFFALSE 22771
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22789: LD_INT 8
22791: PPUSH
22792: LD_EXP 57
22796: PPUSH
22797: CALL_OW 310
22801: PPUSH
22802: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22806: LD_EXP 57
22810: PPUSH
22811: LD_INT 91
22813: PPUSH
22814: LD_INT 44
22816: PPUSH
22817: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22821: LD_EXP 57
22825: PPUSH
22826: LD_INT 96
22828: PPUSH
22829: LD_INT 44
22831: PPUSH
22832: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22836: LD_EXP 57
22840: PPUSH
22841: LD_INT 96
22843: PPUSH
22844: LD_INT 41
22846: PPUSH
22847: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22851: LD_EXP 57
22855: PPUSH
22856: LD_INT 92
22858: PPUSH
22859: LD_INT 39
22861: PPUSH
22862: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22866: LD_EXP 57
22870: PPUSH
22871: LD_INT 88
22873: PPUSH
22874: LD_INT 41
22876: PPUSH
22877: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22881: LD_EXP 57
22885: PPUSH
22886: LD_INT 91
22888: PPUSH
22889: LD_INT 44
22891: PPUSH
22892: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22896: LD_EXP 57
22900: PPUSH
22901: LD_INT 96
22903: PPUSH
22904: LD_INT 44
22906: PPUSH
22907: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22911: LD_EXP 57
22915: PPUSH
22916: LD_INT 96
22918: PPUSH
22919: LD_INT 41
22921: PPUSH
22922: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22926: LD_EXP 57
22930: PPUSH
22931: LD_INT 92
22933: PPUSH
22934: LD_INT 39
22936: PPUSH
22937: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22941: LD_EXP 57
22945: PPUSH
22946: LD_INT 88
22948: PPUSH
22949: LD_INT 41
22951: PPUSH
22952: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 57
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22971: LD_EXP 57
22975: PPUSH
22976: LD_INT 93
22978: PPUSH
22979: LD_INT 39
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22986: LD_EXP 57
22990: PPUSH
22991: LD_INT 93
22993: PPUSH
22994: LD_INT 36
22996: PPUSH
22997: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23001: LD_INT 122
23003: PPUSH
23004: CALL_OW 67
// game_speed := 4 ;
23008: LD_ADDR_OWVAR 65
23012: PUSH
23013: LD_INT 4
23015: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23016: LD_EXP 57
23020: PPUSH
23021: LD_STRING D6b-Pow-1b
23023: PPUSH
23024: CALL_OW 88
// tmp := [ ] ;
23028: LD_ADDR_VAR 0 3
23032: PUSH
23033: EMPTY
23034: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23035: LD_ADDR_VAR 0 5
23039: PUSH
23040: LD_INT 78
23042: PUSH
23043: LD_INT 47
23045: PUSH
23046: EMPTY
23047: LIST
23048: LIST
23049: PUSH
23050: LD_INT 106
23052: PUSH
23053: LD_INT 53
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PUSH
23060: EMPTY
23061: LIST
23062: LIST
23063: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23064: LD_ADDR_VAR 0 1
23068: PUSH
23069: LD_INT 22
23071: PUSH
23072: LD_INT 8
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: PUSH
23079: LD_INT 21
23081: PUSH
23082: LD_INT 3
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PUSH
23089: LD_INT 92
23091: PUSH
23092: LD_INT 90
23094: PUSH
23095: LD_INT 52
23097: PUSH
23098: LD_INT 12
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: LIST
23111: PPUSH
23112: CALL_OW 69
23116: PUSH
23117: FOR_IN
23118: IFFALSE 23143
// tmp := tmp ^ UnitsInside ( i ) ;
23120: LD_ADDR_VAR 0 3
23124: PUSH
23125: LD_VAR 0 3
23129: PUSH
23130: LD_VAR 0 1
23134: PPUSH
23135: CALL_OW 313
23139: ADD
23140: ST_TO_ADDR
23141: GO 23117
23143: POP
23144: POP
// for i in tmp do
23145: LD_ADDR_VAR 0 1
23149: PUSH
23150: LD_VAR 0 3
23154: PUSH
23155: FOR_IN
23156: IFFALSE 23318
// begin dist := 9999 ;
23158: LD_ADDR_VAR 0 8
23162: PUSH
23163: LD_INT 9999
23165: ST_TO_ADDR
// _xy := [ ] ;
23166: LD_ADDR_VAR 0 7
23170: PUSH
23171: EMPTY
23172: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23173: LD_VAR 0 1
23177: PPUSH
23178: LD_INT 1
23180: PPUSH
23181: CALL_OW 109
// ComExitBuilding ( i ) ;
23185: LD_VAR 0 1
23189: PPUSH
23190: CALL_OW 122
// for j in xy do
23194: LD_ADDR_VAR 0 2
23198: PUSH
23199: LD_VAR 0 5
23203: PUSH
23204: FOR_IN
23205: IFFALSE 23287
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23207: LD_VAR 0 1
23211: PPUSH
23212: LD_VAR 0 2
23216: PUSH
23217: LD_INT 1
23219: ARRAY
23220: PPUSH
23221: LD_VAR 0 2
23225: PUSH
23226: LD_INT 2
23228: ARRAY
23229: PPUSH
23230: CALL_OW 297
23234: PUSH
23235: LD_VAR 0 8
23239: LESS
23240: IFFALSE 23285
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23242: LD_ADDR_VAR 0 8
23246: PUSH
23247: LD_VAR 0 1
23251: PPUSH
23252: LD_VAR 0 2
23256: PUSH
23257: LD_INT 1
23259: ARRAY
23260: PPUSH
23261: LD_VAR 0 2
23265: PUSH
23266: LD_INT 2
23268: ARRAY
23269: PPUSH
23270: CALL_OW 297
23274: ST_TO_ADDR
// _xy := j ;
23275: LD_ADDR_VAR 0 7
23279: PUSH
23280: LD_VAR 0 2
23284: ST_TO_ADDR
// end ;
23285: GO 23204
23287: POP
23288: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23289: LD_VAR 0 1
23293: PPUSH
23294: LD_VAR 0 7
23298: PUSH
23299: LD_INT 1
23301: ARRAY
23302: PPUSH
23303: LD_VAR 0 7
23307: PUSH
23308: LD_INT 2
23310: ARRAY
23311: PPUSH
23312: CALL_OW 171
// end ;
23316: GO 23155
23318: POP
23319: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23320: LD_ADDR_VAR 0 4
23324: PUSH
23325: LD_VAR 0 3
23329: PPUSH
23330: LD_INT 26
23332: PUSH
23333: LD_INT 1
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: PUSH
23340: LD_INT 25
23342: PUSH
23343: LD_INT 1
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: PPUSH
23354: CALL_OW 72
23358: ST_TO_ADDR
// if tmp2 < 2 then
23359: LD_VAR 0 4
23363: PUSH
23364: LD_INT 2
23366: LESS
23367: IFFALSE 23436
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23369: LD_ADDR_VAR 0 4
23373: PUSH
23374: LD_INT 22
23376: PUSH
23377: LD_INT 8
23379: PUSH
23380: EMPTY
23381: LIST
23382: LIST
23383: PUSH
23384: LD_INT 26
23386: PUSH
23387: LD_INT 1
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PUSH
23394: LD_INT 3
23396: PUSH
23397: LD_INT 25
23399: PUSH
23400: LD_INT 15
23402: PUSH
23403: EMPTY
23404: LIST
23405: LIST
23406: PUSH
23407: EMPTY
23408: LIST
23409: LIST
23410: PUSH
23411: EMPTY
23412: LIST
23413: LIST
23414: LIST
23415: PPUSH
23416: CALL_OW 69
23420: PUSH
23421: LD_EXP 59
23425: PUSH
23426: LD_EXP 60
23430: PUSH
23431: EMPTY
23432: LIST
23433: LIST
23434: DIFF
23435: ST_TO_ADDR
// if tmp2 then
23436: LD_VAR 0 4
23440: IFFALSE 23458
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23442: LD_VAR 0 4
23446: PUSH
23447: LD_INT 1
23449: ARRAY
23450: PPUSH
23451: LD_STRING D6b-ArSol1-1
23453: PPUSH
23454: CALL_OW 88
// async ;
23458: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23459: LD_EXP 57
23463: PPUSH
23464: LD_STRING D6b-Pow-2
23466: PPUSH
23467: CALL_OW 88
// wait ( 0 0$1 ) ;
23471: LD_INT 35
23473: PPUSH
23474: CALL_OW 67
// if tmp2 > 1 then
23478: LD_VAR 0 4
23482: PUSH
23483: LD_INT 1
23485: GREATER
23486: IFFALSE 23504
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23488: LD_VAR 0 4
23492: PUSH
23493: LD_INT 2
23495: ARRAY
23496: PPUSH
23497: LD_STRING D6b-ArSol2-1
23499: PPUSH
23500: CALL_OW 88
// sync ;
23504: SYNC
// repeat wait ( 5 ) ;
23505: LD_INT 5
23507: PPUSH
23508: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23512: LD_INT 93
23514: PPUSH
23515: LD_INT 36
23517: PPUSH
23518: CALL_OW 428
23522: PPUSH
23523: CALL_OW 255
23527: PUSH
23528: LD_INT 4
23530: EQUAL
23531: IFFALSE 23505
// DialogueOn ;
23533: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23537: LD_INT 10
23539: PPUSH
23540: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23544: LD_EXP 57
23548: PPUSH
23549: LD_STRING D6b-Pow-2a
23551: PPUSH
23552: CALL_OW 88
// DialogueOff ;
23556: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23560: LD_EXP 57
23564: PPUSH
23565: CALL_OW 310
23569: PPUSH
23570: LD_INT 332
23572: PPUSH
23573: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23577: LD_INT 93
23579: PPUSH
23580: LD_INT 35
23582: PPUSH
23583: LD_INT 1
23585: PPUSH
23586: LD_INT 6
23588: NEG
23589: PPUSH
23590: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23594: LD_INT 35
23596: PPUSH
23597: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23601: LD_INT 332
23603: PPUSH
23604: CALL_OW 256
23608: PUSH
23609: LD_INT 1000
23611: LESS
23612: PUSH
23613: LD_INT 332
23615: PPUSH
23616: CALL_OW 300
23620: AND
23621: IFFALSE 23633
// SetLives ( kozlov_fac , 0 ) ;
23623: LD_INT 332
23625: PPUSH
23626: LD_INT 0
23628: PPUSH
23629: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23633: LD_INT 332
23635: PPUSH
23636: CALL_OW 301
23640: PUSH
23641: LD_EXP 57
23645: PPUSH
23646: CALL_OW 301
23650: OR
23651: IFFALSE 23594
// game_speed := 4 ;
23653: LD_ADDR_OWVAR 65
23657: PUSH
23658: LD_INT 4
23660: ST_TO_ADDR
// powellCenterCameraMode := false ;
23661: LD_ADDR_EXP 20
23665: PUSH
23666: LD_INT 0
23668: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23669: LD_ADDR_VAR 0 1
23673: PUSH
23674: LD_VAR 0 3
23678: PUSH
23679: LD_INT 22
23681: PUSH
23682: LD_INT 8
23684: PUSH
23685: EMPTY
23686: LIST
23687: LIST
23688: PUSH
23689: LD_INT 25
23691: PUSH
23692: LD_INT 2
23694: PUSH
23695: EMPTY
23696: LIST
23697: LIST
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: PPUSH
23703: CALL_OW 69
23707: UNION
23708: PUSH
23709: FOR_IN
23710: IFFALSE 23726
// SetTag ( i , 0 ) ;
23712: LD_VAR 0 1
23716: PPUSH
23717: LD_INT 0
23719: PPUSH
23720: CALL_OW 109
23724: GO 23709
23726: POP
23727: POP
// wait ( 0 0$3 ) ;
23728: LD_INT 105
23730: PPUSH
23731: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23735: LD_INT 93
23737: PPUSH
23738: LD_INT 35
23740: PPUSH
23741: LD_INT 1
23743: PPUSH
23744: CALL_OW 331
// DialogueOn ;
23748: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23752: LD_VAR 0 11
23756: PPUSH
23757: LD_STRING D6c-Sol3-1
23759: PPUSH
23760: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23764: LD_INT 10
23766: PPUSH
23767: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23771: LD_EXP 38
23775: PPUSH
23776: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23780: LD_EXP 38
23784: PPUSH
23785: LD_STRING D6c-JMM-1
23787: PPUSH
23788: CALL_OW 88
// if Cyrus then
23792: LD_EXP 44
23796: IFFALSE 23810
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23798: LD_EXP 44
23802: PPUSH
23803: LD_STRING D6c-Cyrus-1
23805: PPUSH
23806: CALL_OW 88
// if Bobby then
23810: LD_EXP 43
23814: IFFALSE 23828
// Say ( Bobby , D6c-Bobby-1 ) ;
23816: LD_EXP 43
23820: PPUSH
23821: LD_STRING D6c-Bobby-1
23823: PPUSH
23824: CALL_OW 88
// if Cornel then
23828: LD_EXP 49
23832: IFFALSE 23846
// Say ( Cornel , D6c-Corn-1 ) ;
23834: LD_EXP 49
23838: PPUSH
23839: LD_STRING D6c-Corn-1
23841: PPUSH
23842: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23846: LD_ADDR_VAR 0 4
23850: PUSH
23851: LD_INT 2
23853: PUSH
23854: LD_INT 22
23856: PUSH
23857: LD_INT 1
23859: PUSH
23860: EMPTY
23861: LIST
23862: LIST
23863: PUSH
23864: LD_INT 22
23866: PUSH
23867: LD_INT 4
23869: PUSH
23870: EMPTY
23871: LIST
23872: LIST
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: LIST
23878: PUSH
23879: LD_INT 26
23881: PUSH
23882: LD_INT 1
23884: PUSH
23885: EMPTY
23886: LIST
23887: LIST
23888: PUSH
23889: LD_INT 3
23891: PUSH
23892: LD_INT 25
23894: PUSH
23895: LD_INT 16
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: PUSH
23902: LD_INT 25
23904: PUSH
23905: LD_INT 12
23907: PUSH
23908: EMPTY
23909: LIST
23910: LIST
23911: PUSH
23912: EMPTY
23913: LIST
23914: LIST
23915: LIST
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: PPUSH
23922: CALL_OW 69
23926: PUSH
23927: LD_VAR 0 11
23931: PUSH
23932: LD_EXP 38
23936: UNION
23937: PUSH
23938: LD_EXP 58
23942: UNION
23943: PUSH
23944: EMPTY
23945: LIST
23946: DIFF
23947: ST_TO_ADDR
// if tmp2 then
23948: LD_VAR 0 4
23952: IFFALSE 23970
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23954: LD_VAR 0 4
23958: PUSH
23959: LD_INT 1
23961: ARRAY
23962: PPUSH
23963: LD_STRING D6c-Sol1-1
23965: PPUSH
23966: CALL_OW 88
// if Lisa then
23970: LD_EXP 41
23974: IFFALSE 23988
// Say ( Lisa , D6c-Lisa-1 ) ;
23976: LD_EXP 41
23980: PPUSH
23981: LD_STRING D6c-Lisa-1
23983: PPUSH
23984: CALL_OW 88
// if Gary then
23988: LD_EXP 50
23992: IFFALSE 24006
// Say ( Gary , D6c-Gary-1 ) ;
23994: LD_EXP 50
23998: PPUSH
23999: LD_STRING D6c-Gary-1
24001: PPUSH
24002: CALL_OW 88
// if Donaldson then
24006: LD_EXP 42
24010: IFFALSE 24024
// Say ( Donaldson , D6c-Don-1 ) ;
24012: LD_EXP 42
24016: PPUSH
24017: LD_STRING D6c-Don-1
24019: PPUSH
24020: CALL_OW 88
// if tmp2 > 1 then
24024: LD_VAR 0 4
24028: PUSH
24029: LD_INT 1
24031: GREATER
24032: IFFALSE 24050
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24034: LD_VAR 0 4
24038: PUSH
24039: LD_INT 2
24041: ARRAY
24042: PPUSH
24043: LD_STRING D6c-Sol2-1
24045: PPUSH
24046: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24050: LD_VAR 0 11
24054: PPUSH
24055: LD_STRING D6c-Sol3-2
24057: PPUSH
24058: CALL_OW 88
// dwait ( 0 0$1 ) ;
24062: LD_INT 35
24064: PPUSH
24065: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24069: LD_EXP 38
24073: PPUSH
24074: LD_STRING D6c-JMM-2
24076: PPUSH
24077: CALL_OW 88
// DialogueOff ;
24081: CALL_OW 7
// Video ( false ) ;
24085: LD_INT 0
24087: PPUSH
24088: CALL 107119 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24092: LD_INT 22
24094: PUSH
24095: LD_INT 4
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PPUSH
24102: CALL_OW 69
24106: PPUSH
24107: LD_INT 1
24109: PPUSH
24110: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24114: LD_INT 4
24116: PPUSH
24117: LD_INT 4
24119: PPUSH
24120: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24124: LD_ADDR_VAR 0 1
24128: PUSH
24129: LD_INT 4
24131: PPUSH
24132: LD_INT 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: CALL 64324 0 3
24142: PUSH
24143: FOR_IN
24144: IFFALSE 24181
// if GetTech ( i , 1 ) <> state_researched then
24146: LD_VAR 0 1
24150: PPUSH
24151: LD_INT 1
24153: PPUSH
24154: CALL_OW 321
24158: PUSH
24159: LD_INT 2
24161: NONEQUAL
24162: IFFALSE 24179
// SetTech ( i , 1 , state_researched ) ;
24164: LD_VAR 0 1
24168: PPUSH
24169: LD_INT 1
24171: PPUSH
24172: LD_INT 2
24174: PPUSH
24175: CALL_OW 322
24179: GO 24143
24181: POP
24182: POP
// missionStage := 6 ;
24183: LD_ADDR_EXP 15
24187: PUSH
24188: LD_INT 6
24190: ST_TO_ADDR
// activeAttacks := true ;
24191: LD_ADDR_EXP 16
24195: PUSH
24196: LD_INT 1
24198: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24199: LD_STRING M2
24201: PPUSH
24202: CALL_OW 337
// SaveForQuickRestart ;
24206: CALL_OW 22
// wait ( 0 0$40 ) ;
24210: LD_INT 1400
24212: PPUSH
24213: CALL_OW 67
// DialogueOn ;
24217: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24221: LD_EXP 61
24225: PPUSH
24226: LD_STRING D7-Friend-1
24228: PPUSH
24229: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24233: LD_EXP 38
24237: PPUSH
24238: LD_STRING D7-JMM-1
24240: PPUSH
24241: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24245: LD_EXP 61
24249: PPUSH
24250: LD_STRING D7-Friend-2
24252: PPUSH
24253: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24257: LD_EXP 38
24261: PPUSH
24262: LD_STRING D7-JMM-2
24264: PPUSH
24265: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24269: LD_EXP 61
24273: PPUSH
24274: LD_STRING D7-Friend-3
24276: PPUSH
24277: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24281: LD_EXP 38
24285: PPUSH
24286: LD_STRING D7-JMM-3
24288: PPUSH
24289: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24293: LD_EXP 61
24297: PPUSH
24298: LD_STRING D7-Friend-4
24300: PPUSH
24301: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24305: LD_EXP 38
24309: PPUSH
24310: LD_STRING D7-JMM-4
24312: PPUSH
24313: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24317: LD_EXP 61
24321: PPUSH
24322: LD_STRING D7-Friend-5
24324: PPUSH
24325: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24329: LD_EXP 38
24333: PPUSH
24334: LD_STRING D7-JMM-5
24336: PPUSH
24337: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24341: LD_EXP 61
24345: PPUSH
24346: LD_STRING D7-Friend-6
24348: PPUSH
24349: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24353: LD_EXP 38
24357: PPUSH
24358: LD_STRING D7-JMM-6
24360: PPUSH
24361: CALL_OW 88
// DialogueOff ;
24365: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24369: LD_STRING Mlegion
24371: PPUSH
24372: CALL_OW 337
// RebuildKozlovFactory ;
24376: CALL 4816 0 0
// end ;
24380: PPOPN 13
24382: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24383: LD_EXP 20
24387: PUSH
24388: LD_EXP 57
24392: PPUSH
24393: CALL_OW 300
24397: AND
24398: IFFALSE 24440
24400: GO 24402
24402: DISABLE
// begin enable ;
24403: ENABLE
// if IsInUnit ( Powell ) then
24404: LD_EXP 57
24408: PPUSH
24409: CALL_OW 310
24413: IFFALSE 24431
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24415: LD_EXP 57
24419: PPUSH
24420: CALL_OW 310
24424: PPUSH
24425: CALL_OW 85
24429: GO 24440
// CenterOnUnits ( Powell ) ;
24431: LD_EXP 57
24435: PPUSH
24436: CALL_OW 85
// end ;
24440: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24441: LD_INT 22
24443: PUSH
24444: LD_INT 8
24446: PUSH
24447: EMPTY
24448: LIST
24449: LIST
24450: PUSH
24451: LD_INT 34
24453: PUSH
24454: LD_INT 48
24456: PUSH
24457: EMPTY
24458: LIST
24459: LIST
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: PPUSH
24465: CALL_OW 69
24469: IFFALSE 24732
24471: GO 24473
24473: DISABLE
24474: LD_INT 0
24476: PPUSH
24477: PPUSH
// begin if missionStage < 9 then
24478: LD_EXP 15
24482: PUSH
24483: LD_INT 9
24485: LESS
24486: IFFALSE 24496
// missionStage := 9 ;
24488: LD_ADDR_EXP 15
24492: PUSH
24493: LD_INT 9
24495: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24496: LD_ADDR_VAR 0 1
24500: PUSH
24501: LD_INT 22
24503: PUSH
24504: LD_INT 8
24506: PUSH
24507: EMPTY
24508: LIST
24509: LIST
24510: PUSH
24511: LD_INT 34
24513: PUSH
24514: LD_INT 48
24516: PUSH
24517: EMPTY
24518: LIST
24519: LIST
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PPUSH
24525: CALL_OW 69
24529: PUSH
24530: LD_INT 1
24532: ARRAY
24533: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24534: LD_INT 175
24536: PPUSH
24537: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24541: LD_EXP 12
24545: PUSH
24546: LD_EXP 3
24550: PUSH
24551: LD_INT 0
24553: PUSH
24554: LD_INT 2
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: IN
24561: OR
24562: IFFALSE 24585
// target := [ 68 , 108 , 1 ] else
24564: LD_ADDR_VAR 0 2
24568: PUSH
24569: LD_INT 68
24571: PUSH
24572: LD_INT 108
24574: PUSH
24575: LD_INT 1
24577: PUSH
24578: EMPTY
24579: LIST
24580: LIST
24581: LIST
24582: ST_TO_ADDR
24583: GO 24604
// target := [ 181 , 88 , 2 ] ;
24585: LD_ADDR_VAR 0 2
24589: PUSH
24590: LD_INT 181
24592: PUSH
24593: LD_INT 88
24595: PUSH
24596: LD_INT 2
24598: PUSH
24599: EMPTY
24600: LIST
24601: LIST
24602: LIST
24603: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24604: LD_VAR 0 1
24608: PPUSH
24609: LD_VAR 0 2
24613: PUSH
24614: LD_INT 1
24616: ARRAY
24617: PPUSH
24618: LD_VAR 0 2
24622: PUSH
24623: LD_INT 2
24625: ARRAY
24626: PPUSH
24627: CALL_OW 176
// if target [ 3 ] = 1 then
24631: LD_VAR 0 2
24635: PUSH
24636: LD_INT 3
24638: ARRAY
24639: PUSH
24640: LD_INT 1
24642: EQUAL
24643: IFFALSE 24659
// SayRadio ( Kurt , D12-Kurt-1 ) else
24645: LD_EXP 59
24649: PPUSH
24650: LD_STRING D12-Kurt-1
24652: PPUSH
24653: CALL_OW 94
24657: GO 24683
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24659: LD_EXP 59
24663: PPUSH
24664: LD_STRING D12a-Kurt-1
24666: PPUSH
24667: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24671: LD_EXP 73
24675: PPUSH
24676: LD_STRING D12a-Roth-1
24678: PPUSH
24679: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24683: LD_INT 350
24685: PPUSH
24686: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24690: LD_VAR 0 1
24694: PPUSH
24695: LD_INT 22
24697: PUSH
24698: LD_INT 8
24700: PUSH
24701: EMPTY
24702: LIST
24703: LIST
24704: PUSH
24705: LD_INT 30
24707: PUSH
24708: LD_INT 3
24710: PUSH
24711: EMPTY
24712: LIST
24713: LIST
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PPUSH
24719: CALL_OW 69
24723: PUSH
24724: LD_INT 1
24726: ARRAY
24727: PPUSH
24728: CALL_OW 228
// end ;
24732: PPOPN 2
24734: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24735: LD_INT 22
24737: PUSH
24738: LD_INT 8
24740: PUSH
24741: EMPTY
24742: LIST
24743: LIST
24744: PUSH
24745: LD_INT 21
24747: PUSH
24748: LD_INT 1
24750: PUSH
24751: EMPTY
24752: LIST
24753: LIST
24754: PUSH
24755: LD_INT 23
24757: PUSH
24758: LD_INT 2
24760: PUSH
24761: EMPTY
24762: LIST
24763: LIST
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: LIST
24769: PPUSH
24770: CALL_OW 69
24774: PUSH
24775: LD_INT 9
24777: PUSH
24778: LD_INT 8
24780: PUSH
24781: LD_INT 7
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_OWVAR 67
24793: ARRAY
24794: LESSEQUAL
24795: PUSH
24796: LD_INT 22
24798: PUSH
24799: LD_INT 8
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: PUSH
24806: LD_INT 34
24808: PUSH
24809: LD_INT 48
24811: PUSH
24812: EMPTY
24813: LIST
24814: LIST
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PPUSH
24820: CALL_OW 69
24824: NOT
24825: AND
24826: PUSH
24827: LD_EXP 59
24831: PPUSH
24832: CALL_OW 302
24836: AND
24837: IFFALSE 25142
24839: GO 24841
24841: DISABLE
// begin DialogueOn ;
24842: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24846: LD_EXP 38
24850: PPUSH
24851: LD_STRING D13-JMM-1
24853: PPUSH
24854: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24858: LD_EXP 59
24862: PPUSH
24863: LD_STRING D13-Kurt-1
24865: PPUSH
24866: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24870: LD_EXP 38
24874: PPUSH
24875: LD_STRING D13-JMM-2
24877: PPUSH
24878: CALL_OW 88
// if FakeInfo then
24882: LD_EXP 12
24886: IFFALSE 24906
// begin Say ( Kurt , D13-Kurt-2 ) ;
24888: LD_EXP 59
24892: PPUSH
24893: LD_STRING D13-Kurt-2
24895: PPUSH
24896: CALL_OW 88
// DialogueOff ;
24900: CALL_OW 7
// exit ;
24904: GO 25142
// end ; if not KurtStatus then
24906: LD_EXP 3
24910: NOT
24911: IFFALSE 24927
// Say ( Kurt , D13-Kurt-2b ) else
24913: LD_EXP 59
24917: PPUSH
24918: LD_STRING D13-Kurt-2b
24920: PPUSH
24921: CALL_OW 88
24925: GO 24939
// Say ( Kurt , D13-Kurt-2a ) ;
24927: LD_EXP 59
24931: PPUSH
24932: LD_STRING D13-Kurt-2a
24934: PPUSH
24935: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24939: LD_EXP 38
24943: PPUSH
24944: LD_STRING D13-JMM-3
24946: PPUSH
24947: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24951: LD_EXP 59
24955: PPUSH
24956: LD_STRING D13-Kurt-3
24958: PPUSH
24959: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24963: LD_EXP 38
24967: PPUSH
24968: LD_STRING D13-JMM-4
24970: PPUSH
24971: CALL_OW 88
// DialogueOff ;
24975: CALL_OW 7
// MC_Kill ( 3 ) ;
24979: LD_INT 3
24981: PPUSH
24982: CALL 34457 0 1
// KillUnit ( Kozlov ) ;
24986: LD_EXP 60
24990: PPUSH
24991: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24995: LD_INT 22
24997: PUSH
24998: LD_INT 8
25000: PUSH
25001: EMPTY
25002: LIST
25003: LIST
25004: PUSH
25005: LD_INT 21
25007: PUSH
25008: LD_INT 3
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 23
25017: PUSH
25018: LD_INT 3
25020: PUSH
25021: EMPTY
25022: LIST
25023: LIST
25024: PUSH
25025: LD_INT 30
25027: PUSH
25028: LD_INT 3
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: LIST
25039: LIST
25040: PPUSH
25041: CALL_OW 69
25045: PUSH
25046: LD_INT 1
25048: ARRAY
25049: PPUSH
25050: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
25054: LD_INT 8
25056: PPUSH
25057: LD_INT 1
25059: PPUSH
25060: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
25064: LD_INT 22
25066: PUSH
25067: LD_INT 8
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PPUSH
25074: CALL_OW 69
25078: PPUSH
25079: LD_INT 1
25081: PPUSH
25082: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25086: LD_INT 8
25088: PPUSH
25089: LD_INT 1
25091: PPUSH
25092: LD_INT 1
25094: PPUSH
25095: LD_INT 1
25097: PPUSH
25098: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25102: LD_EXP 61
25106: PPUSH
25107: LD_INT 37
25109: PPUSH
25110: LD_INT 1
25112: PPUSH
25113: LD_INT 0
25115: PPUSH
25116: CALL_OW 48
// wait ( 0 0$1 ) ;
25120: LD_INT 35
25122: PPUSH
25123: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25127: LD_EXP 61
25131: PPUSH
25132: LD_INT 60
25134: PPUSH
25135: LD_INT 95
25137: PPUSH
25138: CALL_OW 111
// end ;
25142: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25143: LD_INT 22
25145: PUSH
25146: LD_INT 8
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: PUSH
25153: LD_INT 21
25155: PUSH
25156: LD_INT 1
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: PPUSH
25167: CALL_OW 69
25171: PUSH
25172: LD_INT 0
25174: EQUAL
25175: IFFALSE 25195
25177: GO 25179
25179: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25180: LD_STRING MlegionOut
25182: PPUSH
25183: CALL_OW 337
// legionDestroyed := true ;
25187: LD_ADDR_EXP 22
25191: PUSH
25192: LD_INT 1
25194: ST_TO_ADDR
// end ;
25195: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25196: LD_INT 1
25198: PPUSH
25199: LD_EXP 61
25203: PPUSH
25204: CALL_OW 292
25208: IFFALSE 25508
25210: GO 25212
25212: DISABLE
25213: LD_INT 0
25215: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
25216: LD_EXP 61
25220: PPUSH
25221: CALL_OW 87
// DialogueOn ;
25225: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25229: LD_EXP 38
25233: PPUSH
25234: LD_STRING D14-JMM-1
25236: PPUSH
25237: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25241: LD_EXP 61
25245: PPUSH
25246: LD_STRING D14-Friend-1
25248: PPUSH
25249: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25253: LD_EXP 38
25257: PPUSH
25258: LD_STRING D14-JMM-2
25260: PPUSH
25261: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25265: LD_EXP 61
25269: PPUSH
25270: LD_STRING D14-Friend-2
25272: PPUSH
25273: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25277: LD_EXP 38
25281: PPUSH
25282: LD_STRING D14-JMM-3
25284: PPUSH
25285: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25289: LD_EXP 61
25293: PPUSH
25294: LD_STRING D14-Friend-3
25296: PPUSH
25297: CALL_OW 88
// DialogueOff ;
25301: CALL_OW 7
// dec = Query ( Q14 ) ;
25305: LD_ADDR_VAR 0 1
25309: PUSH
25310: LD_STRING Q14
25312: PPUSH
25313: CALL_OW 97
25317: ST_TO_ADDR
// if dec = 1 then
25318: LD_VAR 0 1
25322: PUSH
25323: LD_INT 1
25325: EQUAL
25326: IFFALSE 25360
// begin DialogueOn ;
25328: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25332: LD_EXP 38
25336: PPUSH
25337: LD_STRING D14a-JMM-1
25339: PPUSH
25340: CALL_OW 88
// DialogueOff ;
25344: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25348: LD_EXP 61
25352: PPUSH
25353: LD_INT 1
25355: PPUSH
25356: CALL_OW 235
// end ; if dec = 2 then
25360: LD_VAR 0 1
25364: PUSH
25365: LD_INT 2
25367: EQUAL
25368: IFFALSE 25414
// begin DialogueOn ;
25370: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25374: LD_EXP 38
25378: PPUSH
25379: LD_STRING D14b-JMM-1
25381: PPUSH
25382: CALL_OW 88
// DialogueOff ;
25386: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25390: LD_EXP 61
25394: PPUSH
25395: LD_INT 9
25397: PPUSH
25398: LD_INT 2
25400: PPUSH
25401: CALL_OW 111
// AddComHold ( Friend ) ;
25405: LD_EXP 61
25409: PPUSH
25410: CALL_OW 200
// end ; if dec = 3 then
25414: LD_VAR 0 1
25418: PUSH
25419: LD_INT 3
25421: EQUAL
25422: IFFALSE 25508
// begin DialogueOn ;
25424: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25428: LD_EXP 38
25432: PPUSH
25433: LD_STRING D14c-JMM-1
25435: PPUSH
25436: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25440: LD_EXP 61
25444: PPUSH
25445: LD_STRING D14c-Friend-1
25447: PPUSH
25448: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25452: LD_EXP 38
25456: PPUSH
25457: LD_STRING D14c-JMM-2
25459: PPUSH
25460: CALL_OW 88
// DialogueOff ;
25464: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25468: LD_INT 8
25470: PPUSH
25471: LD_INT 1
25473: PPUSH
25474: LD_INT 2
25476: PPUSH
25477: LD_INT 1
25479: PPUSH
25480: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25484: LD_EXP 61
25488: PPUSH
25489: LD_INT 9
25491: PPUSH
25492: LD_INT 2
25494: PPUSH
25495: CALL_OW 111
// AddComHold ( Friend ) ;
25499: LD_EXP 61
25503: PPUSH
25504: CALL_OW 200
// end ; end ;
25508: PPOPN 1
25510: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25511: LD_INT 9
25513: PPUSH
25514: LD_INT 2
25516: PPUSH
25517: CALL_OW 428
25521: PUSH
25522: LD_EXP 61
25526: EQUAL
25527: PUSH
25528: LD_EXP 61
25532: PPUSH
25533: CALL_OW 255
25537: PUSH
25538: LD_INT 8
25540: EQUAL
25541: AND
25542: IFFALSE 25556
25544: GO 25546
25546: DISABLE
// RemoveUnit ( Friend ) ;
25547: LD_EXP 61
25551: PPUSH
25552: CALL_OW 64
25556: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25557: LD_EXP 14
25561: PUSH
25562: LD_INT 31500
25564: GREATEREQUAL
25565: PUSH
25566: LD_EXP 7
25570: AND
25571: PUSH
25572: LD_EXP 2
25576: AND
25577: IFFALSE 26007
25579: GO 25581
25581: DISABLE
25582: LD_INT 0
25584: PPUSH
25585: PPUSH
25586: PPUSH
// begin missionStage := 7 ;
25587: LD_ADDR_EXP 15
25591: PUSH
25592: LD_INT 7
25594: ST_TO_ADDR
// uc_side = 1 ;
25595: LD_ADDR_OWVAR 20
25599: PUSH
25600: LD_INT 1
25602: ST_TO_ADDR
// uc_nation = 1 ;
25603: LD_ADDR_OWVAR 21
25607: PUSH
25608: LD_INT 1
25610: ST_TO_ADDR
// for i = 1 to 5 do
25611: LD_ADDR_VAR 0 1
25615: PUSH
25616: DOUBLE
25617: LD_INT 1
25619: DEC
25620: ST_TO_ADDR
25621: LD_INT 5
25623: PUSH
25624: FOR_TO
25625: IFFALSE 25721
// begin vc_engine = 3 ;
25627: LD_ADDR_OWVAR 39
25631: PUSH
25632: LD_INT 3
25634: ST_TO_ADDR
// vc_control = 3 ;
25635: LD_ADDR_OWVAR 38
25639: PUSH
25640: LD_INT 3
25642: ST_TO_ADDR
// vc_chassis = 3 ;
25643: LD_ADDR_OWVAR 37
25647: PUSH
25648: LD_INT 3
25650: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25651: LD_ADDR_OWVAR 40
25655: PUSH
25656: LD_INT 5
25658: PUSH
25659: LD_INT 9
25661: PUSH
25662: LD_INT 7
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: LIST
25669: PUSH
25670: LD_INT 1
25672: PPUSH
25673: LD_INT 3
25675: PPUSH
25676: CALL_OW 12
25680: ARRAY
25681: ST_TO_ADDR
// veh = CreateVehicle ;
25682: LD_ADDR_VAR 0 2
25686: PUSH
25687: CALL_OW 45
25691: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25692: LD_VAR 0 2
25696: PPUSH
25697: LD_INT 1
25699: PPUSH
25700: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25704: LD_VAR 0 2
25708: PPUSH
25709: LD_INT 19
25711: PPUSH
25712: LD_INT 0
25714: PPUSH
25715: CALL_OW 49
// end ;
25719: GO 25624
25721: POP
25722: POP
// vc_engine = 3 ;
25723: LD_ADDR_OWVAR 39
25727: PUSH
25728: LD_INT 3
25730: ST_TO_ADDR
// vc_control = 1 ;
25731: LD_ADDR_OWVAR 38
25735: PUSH
25736: LD_INT 1
25738: ST_TO_ADDR
// vc_chassis = 3 ;
25739: LD_ADDR_OWVAR 37
25743: PUSH
25744: LD_INT 3
25746: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25747: LD_ADDR_OWVAR 40
25751: PUSH
25752: LD_INT 5
25754: PUSH
25755: LD_INT 9
25757: PUSH
25758: LD_INT 7
25760: PUSH
25761: EMPTY
25762: LIST
25763: LIST
25764: LIST
25765: PUSH
25766: LD_INT 1
25768: PPUSH
25769: LD_INT 3
25771: PPUSH
25772: CALL_OW 12
25776: ARRAY
25777: ST_TO_ADDR
// vehG = CreateVehicle ;
25778: LD_ADDR_VAR 0 3
25782: PUSH
25783: CALL_OW 45
25787: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25788: LD_VAR 0 3
25792: PPUSH
25793: LD_INT 1
25795: PPUSH
25796: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25800: LD_VAR 0 3
25804: PPUSH
25805: LD_INT 19
25807: PPUSH
25808: LD_INT 0
25810: PPUSH
25811: CALL_OW 49
// if JMMGirl = 1 then
25815: LD_EXP 7
25819: PUSH
25820: LD_INT 1
25822: EQUAL
25823: IFFALSE 25879
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25825: LD_ADDR_EXP 39
25829: PUSH
25830: LD_STRING Joan
25832: PPUSH
25833: LD_INT 1
25835: PPUSH
25836: LD_STRING 14_
25838: PPUSH
25839: CALL 64261 0 3
25843: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25844: LD_EXP 39
25848: PPUSH
25849: LD_VAR 0 3
25853: PPUSH
25854: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25858: LD_VAR 0 3
25862: PPUSH
25863: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25867: LD_EXP 39
25871: PPUSH
25872: LD_STRING D10BW-Joan-1
25874: PPUSH
25875: CALL_OW 94
// end ; if JMMGirl = 2 then
25879: LD_EXP 7
25883: PUSH
25884: LD_INT 2
25886: EQUAL
25887: IFFALSE 25943
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25889: LD_ADDR_EXP 41
25893: PUSH
25894: LD_STRING Lisa
25896: PPUSH
25897: LD_INT 1
25899: PPUSH
25900: LD_STRING 14_
25902: PPUSH
25903: CALL 64261 0 3
25907: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25908: LD_EXP 41
25912: PPUSH
25913: LD_VAR 0 3
25917: PPUSH
25918: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25922: LD_VAR 0 3
25926: PPUSH
25927: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25931: LD_EXP 41
25935: PPUSH
25936: LD_STRING D10BW-Lisa-1
25938: PPUSH
25939: CALL_OW 94
// end ; if JMMGirl = 3 then
25943: LD_EXP 7
25947: PUSH
25948: LD_INT 3
25950: EQUAL
25951: IFFALSE 26007
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25953: LD_ADDR_EXP 53
25957: PUSH
25958: LD_STRING Connie
25960: PPUSH
25961: LD_INT 1
25963: PPUSH
25964: LD_STRING 14_
25966: PPUSH
25967: CALL 64261 0 3
25971: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25972: LD_EXP 53
25976: PPUSH
25977: LD_VAR 0 3
25981: PPUSH
25982: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25986: LD_VAR 0 3
25990: PPUSH
25991: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
25995: LD_EXP 53
25999: PPUSH
26000: LD_STRING D10BW-Con-1
26002: PPUSH
26003: CALL_OW 94
// end ; end ;
26007: PPOPN 3
26009: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26010: LD_EXP 14
26014: PUSH
26015: LD_INT 94500
26017: GREATEREQUAL
26018: IFFALSE 26430
26020: GO 26022
26022: DISABLE
26023: LD_INT 0
26025: PPUSH
26026: PPUSH
26027: PPUSH
// begin tmp := PrepareStevensSquad ;
26028: LD_ADDR_VAR 0 3
26032: PUSH
26033: CALL 2190 0 0
26037: ST_TO_ADDR
// if not tmp then
26038: LD_VAR 0 3
26042: NOT
26043: IFFALSE 26047
// exit ;
26045: GO 26430
// uc_side := 1 ;
26047: LD_ADDR_OWVAR 20
26051: PUSH
26052: LD_INT 1
26054: ST_TO_ADDR
// uc_nation := 1 ;
26055: LD_ADDR_OWVAR 21
26059: PUSH
26060: LD_INT 1
26062: ST_TO_ADDR
// for i in tmp do
26063: LD_ADDR_VAR 0 1
26067: PUSH
26068: LD_VAR 0 3
26072: PUSH
26073: FOR_IN
26074: IFFALSE 26171
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26076: LD_INT 3
26078: PPUSH
26079: LD_INT 3
26081: PPUSH
26082: LD_INT 1
26084: PPUSH
26085: LD_INT 5
26087: PUSH
26088: LD_INT 9
26090: PUSH
26091: LD_INT 7
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: LIST
26098: PUSH
26099: LD_INT 1
26101: PPUSH
26102: LD_INT 3
26104: PPUSH
26105: CALL_OW 12
26109: ARRAY
26110: PPUSH
26111: LD_INT 40
26113: PPUSH
26114: CALL 71376 0 5
// veh := CreateVehicle ;
26118: LD_ADDR_VAR 0 2
26122: PUSH
26123: CALL_OW 45
26127: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26128: LD_VAR 0 2
26132: PPUSH
26133: LD_INT 1
26135: PPUSH
26136: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26140: LD_VAR 0 2
26144: PPUSH
26145: LD_INT 19
26147: PPUSH
26148: LD_INT 0
26150: PPUSH
26151: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26155: LD_VAR 0 1
26159: PPUSH
26160: LD_VAR 0 2
26164: PPUSH
26165: CALL_OW 52
// end ;
26169: GO 26073
26171: POP
26172: POP
// missionStage := 8 ;
26173: LD_ADDR_EXP 15
26177: PUSH
26178: LD_INT 8
26180: ST_TO_ADDR
// DialogueOn ;
26181: CALL_OW 6
// if Stevens then
26185: LD_EXP 40
26189: IFFALSE 26303
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26191: LD_EXP 40
26195: PPUSH
26196: CALL_OW 310
26200: PPUSH
26201: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26205: LD_EXP 40
26209: PPUSH
26210: LD_STRING D8-Huck-1
26212: PPUSH
26213: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26217: LD_EXP 38
26221: PPUSH
26222: LD_STRING D8-JMM-1
26224: PPUSH
26225: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26229: LD_EXP 40
26233: PPUSH
26234: LD_STRING D8-Huck-2
26236: PPUSH
26237: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26241: LD_EXP 38
26245: PPUSH
26246: LD_STRING D8-JMM-2
26248: PPUSH
26249: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26253: LD_EXP 40
26257: PPUSH
26258: LD_STRING D8-Huck-3
26260: PPUSH
26261: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26265: LD_EXP 38
26269: PPUSH
26270: LD_STRING D8-JMM-3
26272: PPUSH
26273: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26277: LD_EXP 40
26281: PPUSH
26282: LD_STRING D8-Huck-4
26284: PPUSH
26285: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26289: LD_EXP 38
26293: PPUSH
26294: LD_STRING D8-JMM-4
26296: PPUSH
26297: CALL_OW 88
// end else
26301: GO 26413
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26303: LD_EXP 54
26307: PPUSH
26308: CALL_OW 310
26312: PPUSH
26313: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26317: LD_EXP 54
26321: PPUSH
26322: LD_STRING D8-Huck-1
26324: PPUSH
26325: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26329: LD_EXP 38
26333: PPUSH
26334: LD_STRING D8-JMM-1a
26336: PPUSH
26337: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26341: LD_EXP 54
26345: PPUSH
26346: LD_STRING D8-Huck-2
26348: PPUSH
26349: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26353: LD_EXP 38
26357: PPUSH
26358: LD_STRING D8-JMM-2
26360: PPUSH
26361: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26365: LD_EXP 54
26369: PPUSH
26370: LD_STRING D8-Huck-3
26372: PPUSH
26373: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26377: LD_EXP 38
26381: PPUSH
26382: LD_STRING D8-JMM-3
26384: PPUSH
26385: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26389: LD_EXP 54
26393: PPUSH
26394: LD_STRING D8-Huck-4
26396: PPUSH
26397: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26401: LD_EXP 38
26405: PPUSH
26406: LD_STRING D8-JMM-4
26408: PPUSH
26409: CALL_OW 88
// end ; DialogueOff ;
26413: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26417: LD_INT 25
26419: PPUSH
26420: LD_INT 1
26422: PPUSH
26423: LD_INT 1
26425: PPUSH
26426: CALL_OW 322
// end ;
26430: PPOPN 3
26432: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26433: LD_INT 1
26435: PPUSH
26436: LD_EXP 70
26440: PPUSH
26441: CALL_OW 292
26445: IFFALSE 26696
26447: GO 26449
26449: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26450: LD_EXP 70
26454: PPUSH
26455: CALL_OW 87
// DialogueOn ;
26459: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26463: LD_EXP 38
26467: PPUSH
26468: LD_STRING D10nB-JMM-1
26470: PPUSH
26471: CALL_OW 88
// if BurlakStatus = 1 then
26475: LD_EXP 9
26479: PUSH
26480: LD_INT 1
26482: EQUAL
26483: IFFALSE 26497
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26485: LD_EXP 69
26489: PPUSH
26490: LD_STRING D10nB-Vse-1a
26492: PPUSH
26493: CALL_OW 94
// end ; if BurlakStatus = 0 then
26497: LD_EXP 9
26501: PUSH
26502: LD_INT 0
26504: EQUAL
26505: IFFALSE 26519
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26507: LD_EXP 69
26511: PPUSH
26512: LD_STRING D10nB-Vse-1
26514: PPUSH
26515: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26519: LD_EXP 38
26523: PPUSH
26524: LD_STRING D10nB-JMM-2
26526: PPUSH
26527: CALL_OW 88
// if KappaStatus then
26531: LD_EXP 2
26535: IFFALSE 26549
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26537: LD_EXP 69
26541: PPUSH
26542: LD_STRING D10nB-Vse-5a
26544: PPUSH
26545: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26549: LD_EXP 2
26553: NOT
26554: PUSH
26555: LD_EXP 6
26559: PUSH
26560: LD_INT 0
26562: EQUAL
26563: AND
26564: IFFALSE 26692
// begin if JMMGirl = 1 then
26566: LD_EXP 7
26570: PUSH
26571: LD_INT 1
26573: EQUAL
26574: IFFALSE 26624
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26576: LD_EXP 69
26580: PPUSH
26581: LD_STRING D10nB-Vse-2
26583: PPUSH
26584: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26588: LD_EXP 38
26592: PPUSH
26593: LD_STRING D10nB-JMM-3
26595: PPUSH
26596: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26600: LD_EXP 69
26604: PPUSH
26605: LD_STRING D10nB-Vse-3
26607: PPUSH
26608: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26612: LD_EXP 38
26616: PPUSH
26617: LD_STRING D10nB-JMM-4
26619: PPUSH
26620: CALL_OW 88
// end ; if JMMGirl = 2 then
26624: LD_EXP 7
26628: PUSH
26629: LD_INT 2
26631: EQUAL
26632: IFFALSE 26658
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26634: LD_EXP 69
26638: PPUSH
26639: LD_STRING D10nB-Vse-4
26641: PPUSH
26642: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26646: LD_EXP 38
26650: PPUSH
26651: LD_STRING D10nB-JMM-5
26653: PPUSH
26654: CALL_OW 88
// end ; if JMMGirl = 3 then
26658: LD_EXP 7
26662: PUSH
26663: LD_INT 3
26665: EQUAL
26666: IFFALSE 26692
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26668: LD_EXP 69
26672: PPUSH
26673: LD_STRING D10nB-Vse-5
26675: PPUSH
26676: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26680: LD_EXP 38
26684: PPUSH
26685: LD_STRING D10nB-JMM-6
26687: PPUSH
26688: CALL_OW 88
// end ; end ; DialogueOff ;
26692: CALL_OW 7
// end ;
26696: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26697: LD_EXP 14
26701: PUSH
26702: LD_INT 115500
26704: GREATEREQUAL
26705: IFFALSE 27070
26707: GO 26709
26709: DISABLE
26710: LD_INT 0
26712: PPUSH
// begin missionStage := 10 ;
26713: LD_ADDR_EXP 15
26717: PUSH
26718: LD_INT 10
26720: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26721: LD_ADDR_VAR 0 1
26725: PUSH
26726: LD_INT 22
26728: PUSH
26729: LD_INT 1
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 26
26738: PUSH
26739: LD_INT 1
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: LD_INT 3
26748: PUSH
26749: LD_INT 25
26751: PUSH
26752: LD_INT 12
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: PUSH
26763: LD_INT 3
26765: PUSH
26766: LD_INT 25
26768: PUSH
26769: LD_INT 16
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: PUSH
26780: EMPTY
26781: LIST
26782: LIST
26783: LIST
26784: LIST
26785: PPUSH
26786: CALL_OW 69
26790: PUSH
26791: LD_EXP 38
26795: PUSH
26796: LD_EXP 59
26800: PUSH
26801: LD_EXP 40
26805: PUSH
26806: LD_EXP 54
26810: PUSH
26811: LD_EXP 41
26815: PUSH
26816: LD_EXP 42
26820: PUSH
26821: LD_EXP 43
26825: PUSH
26826: LD_EXP 44
26830: PUSH
26831: LD_EXP 45
26835: PUSH
26836: LD_EXP 46
26840: PUSH
26841: LD_EXP 47
26845: PUSH
26846: LD_EXP 48
26850: PUSH
26851: LD_EXP 49
26855: PUSH
26856: LD_EXP 50
26860: PUSH
26861: LD_EXP 51
26865: PUSH
26866: LD_EXP 52
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: LIST
26875: LIST
26876: LIST
26877: LIST
26878: LIST
26879: LIST
26880: LIST
26881: LIST
26882: LIST
26883: LIST
26884: LIST
26885: LIST
26886: LIST
26887: LIST
26888: DIFF
26889: ST_TO_ADDR
// if not tmp and Brown then
26890: LD_VAR 0 1
26894: NOT
26895: PUSH
26896: LD_EXP 46
26900: AND
26901: IFFALSE 26916
// tmp := [ Brown ] ;
26903: LD_ADDR_VAR 0 1
26907: PUSH
26908: LD_EXP 46
26912: PUSH
26913: EMPTY
26914: LIST
26915: ST_TO_ADDR
// DialogueOn ;
26916: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26920: LD_VAR 0 1
26924: PUSH
26925: LD_INT 1
26927: ARRAY
26928: PPUSH
26929: LD_STRING D11-Sol1-1
26931: PPUSH
26932: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26936: LD_EXP 63
26940: PPUSH
26941: LD_STRING D11-Pla-1
26943: PPUSH
26944: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26948: LD_EXP 64
26952: PPUSH
26953: LD_STRING D11-Kov-1
26955: PPUSH
26956: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26960: LD_EXP 63
26964: PPUSH
26965: LD_STRING D11-Pla-2
26967: PPUSH
26968: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26972: LD_VAR 0 1
26976: PUSH
26977: LD_INT 1
26979: ARRAY
26980: PPUSH
26981: LD_STRING D11-Sol1-2
26983: PPUSH
26984: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26988: LD_EXP 38
26992: PPUSH
26993: LD_STRING D11-JMM-2
26995: PPUSH
26996: CALL_OW 88
// DialogueOff ;
27000: CALL_OW 7
// allowBehemothConstruct := true ;
27004: LD_ADDR_EXP 25
27008: PUSH
27009: LD_INT 1
27011: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27012: LD_STRING M4
27014: PPUSH
27015: CALL_OW 337
// BuildBehemoths ;
27019: CALL 7620 0 0
// repeat wait ( 15 15$00 ) ;
27023: LD_INT 31500
27025: PPUSH
27026: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27030: LD_EXP 27
27034: IFFALSE 27038
// break ;
27036: GO 27070
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27038: LD_INT 267
27040: PPUSH
27041: CALL_OW 274
27045: PPUSH
27046: LD_INT 1
27048: PPUSH
27049: CALL_OW 275
27053: PUSH
27054: LD_INT 1000
27056: GREATEREQUAL
27057: IFFALSE 27063
// BuildBehemoths ;
27059: CALL 7620 0 0
// until not behemothBuilders ;
27063: LD_EXP 72
27067: NOT
27068: IFFALSE 27023
// end ;
27070: PPOPN 1
27072: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27073: LD_EXP 72
27077: NOT
27078: PUSH
27079: LD_EXP 28
27083: NOT
27084: AND
27085: PUSH
27086: LD_EXP 25
27090: AND
27091: IFFALSE 27111
27093: GO 27095
27095: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27096: LD_STRING M4a
27098: PPUSH
27099: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27103: LD_ADDR_EXP 27
27107: PUSH
27108: LD_INT 1
27110: ST_TO_ADDR
// end ;
27111: END
// every 0 0$1 trigger behemothDone do
27112: LD_EXP 28
27116: IFFALSE 27128
27118: GO 27120
27120: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27121: LD_STRING M4b
27123: PPUSH
27124: CALL_OW 337
27128: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27129: LD_EXP 29
27133: NOT
27134: IFFALSE 27330
27136: GO 27138
27138: DISABLE
27139: LD_INT 0
27141: PPUSH
27142: PPUSH
// begin enable ;
27143: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27144: LD_ADDR_VAR 0 1
27148: PUSH
27149: LD_INT 3
27151: PPUSH
27152: CALL 107195 0 1
27156: ST_TO_ADDR
// if not tmp and not behemothDone then
27157: LD_VAR 0 1
27161: NOT
27162: PUSH
27163: LD_EXP 28
27167: NOT
27168: AND
27169: IFFALSE 27205
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27171: LD_ADDR_VAR 0 1
27175: PUSH
27176: LD_INT 22
27178: PUSH
27179: LD_INT 3
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: LD_INT 30
27188: PUSH
27189: LD_INT 37
27191: PUSH
27192: EMPTY
27193: LIST
27194: LIST
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PPUSH
27200: CALL_OW 69
27204: ST_TO_ADDR
// if not tmp then
27205: LD_VAR 0 1
27209: NOT
27210: IFFALSE 27214
// exit ;
27212: GO 27330
// for i in tmp do
27214: LD_ADDR_VAR 0 2
27218: PUSH
27219: LD_VAR 0 1
27223: PUSH
27224: FOR_IN
27225: IFFALSE 27328
// if See ( 1 , i ) then
27227: LD_INT 1
27229: PPUSH
27230: LD_VAR 0 2
27234: PPUSH
27235: CALL_OW 292
27239: IFFALSE 27326
// begin if GetType ( i ) = unit_building then
27241: LD_VAR 0 2
27245: PPUSH
27246: CALL_OW 247
27250: PUSH
27251: LD_INT 3
27253: EQUAL
27254: IFFALSE 27292
// begin CenterNowOnUnits ( i ) ;
27256: LD_VAR 0 2
27260: PPUSH
27261: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27265: LD_EXP 38
27269: PPUSH
27270: LD_STRING D17a-JMM-1
27272: PPUSH
27273: CALL_OW 88
// seeBehemoth := true ;
27277: LD_ADDR_EXP 29
27281: PUSH
27282: LD_INT 1
27284: ST_TO_ADDR
// disable ;
27285: DISABLE
// exit ;
27286: POP
27287: POP
27288: GO 27330
// end else
27290: GO 27326
// begin CenterNowOnUnits ( i ) ;
27292: LD_VAR 0 2
27296: PPUSH
27297: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27301: LD_EXP 38
27305: PPUSH
27306: LD_STRING D17b-JMM-1
27308: PPUSH
27309: CALL_OW 88
// seeBehemoth := true ;
27313: LD_ADDR_EXP 29
27317: PUSH
27318: LD_INT 1
27320: ST_TO_ADDR
// disable ;
27321: DISABLE
// exit ;
27322: POP
27323: POP
27324: GO 27330
// end ; end ;
27326: GO 27224
27328: POP
27329: POP
// end ;
27330: PPOPN 2
27332: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27333: LD_EXP 14
27337: PUSH
27338: LD_INT 116550
27340: GREATEREQUAL
27341: IFFALSE 28517
27343: GO 27345
27345: DISABLE
27346: LD_INT 0
27348: PPUSH
27349: PPUSH
27350: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27351: LD_INT 2
27353: PPUSH
27354: LD_INT 23
27356: PUSH
27357: LD_INT 3
27359: PUSH
27360: LD_INT 3
27362: PUSH
27363: LD_INT 48
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: PUSH
27372: EMPTY
27373: LIST
27374: PPUSH
27375: CALL 57917 0 2
// repeat wait ( 0 0$1 ) ;
27379: LD_INT 35
27381: PPUSH
27382: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27386: LD_INT 22
27388: PUSH
27389: LD_INT 3
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: PUSH
27396: LD_INT 34
27398: PUSH
27399: LD_INT 48
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PPUSH
27410: CALL_OW 69
27414: IFFALSE 27379
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27416: LD_ADDR_VAR 0 1
27420: PUSH
27421: LD_INT 22
27423: PUSH
27424: LD_INT 3
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: LD_INT 34
27433: PUSH
27434: LD_INT 48
27436: PUSH
27437: EMPTY
27438: LIST
27439: LIST
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PPUSH
27445: CALL_OW 69
27449: PUSH
27450: LD_INT 1
27452: ARRAY
27453: ST_TO_ADDR
// missionStage := 12 ;
27454: LD_ADDR_EXP 15
27458: PUSH
27459: LD_INT 12
27461: ST_TO_ADDR
// platonovHasBomb := true ;
27462: LD_ADDR_EXP 30
27466: PUSH
27467: LD_INT 1
27469: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27470: LD_VAR 0 1
27474: PPUSH
27475: LD_INT 181
27477: PPUSH
27478: LD_INT 86
27480: PPUSH
27481: CALL_OW 171
// AddComHold ( bomb ) ;
27485: LD_VAR 0 1
27489: PPUSH
27490: CALL_OW 200
// wait ( 0 0$10 ) ;
27494: LD_INT 350
27496: PPUSH
27497: CALL_OW 67
// DialogueOn ;
27501: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27505: LD_EXP 63
27509: PPUSH
27510: LD_STRING D15-Pla-1
27512: PPUSH
27513: CALL_OW 94
// dec = Query ( Q15a ) ;
27517: LD_ADDR_VAR 0 2
27521: PUSH
27522: LD_STRING Q15a
27524: PPUSH
27525: CALL_OW 97
27529: ST_TO_ADDR
// if dec = 1 then
27530: LD_VAR 0 2
27534: PUSH
27535: LD_INT 1
27537: EQUAL
27538: IFFALSE 27561
// begin Say ( JMM , D15a-JMM-1 ) ;
27540: LD_EXP 38
27544: PPUSH
27545: LD_STRING D15a-JMM-1
27547: PPUSH
27548: CALL_OW 88
// YouLost ( Surrender ) ;
27552: LD_STRING Surrender
27554: PPUSH
27555: CALL_OW 104
// exit ;
27559: GO 28517
// end ; if dec = 2 then
27561: LD_VAR 0 2
27565: PUSH
27566: LD_INT 2
27568: EQUAL
27569: IFFALSE 27638
// begin Say ( JMM , D15b-JMM-1 ) ;
27571: LD_EXP 38
27575: PPUSH
27576: LD_STRING D15b-JMM-1
27578: PPUSH
27579: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27583: LD_EXP 63
27587: PPUSH
27588: LD_STRING D15b-Pla-1
27590: PPUSH
27591: CALL_OW 94
// DialogueOff ;
27595: CALL_OW 7
// wait ( 3 3$00 ) ;
27599: LD_INT 6300
27601: PPUSH
27602: CALL_OW 67
// DialogueOn ;
27606: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27610: LD_EXP 38
27614: PPUSH
27615: LD_STRING D15d-JMM-1a
27617: PPUSH
27618: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27622: LD_EXP 63
27626: PPUSH
27627: LD_STRING D15d-Pla-1
27629: PPUSH
27630: CALL_OW 94
// DialogueOff ;
27634: CALL_OW 7
// end ; if dec = 3 then
27638: LD_VAR 0 2
27642: PUSH
27643: LD_INT 3
27645: EQUAL
27646: IFFALSE 27700
// begin Say ( JMM , D15c-JMM-1 ) ;
27648: LD_EXP 38
27652: PPUSH
27653: LD_STRING D15c-JMM-1
27655: PPUSH
27656: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27660: LD_EXP 63
27664: PPUSH
27665: LD_STRING D15c-Pla-1
27667: PPUSH
27668: CALL_OW 94
// DialogueOff ;
27672: CALL_OW 7
// wait ( 0 0$15 ) ;
27676: LD_INT 525
27678: PPUSH
27679: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27683: LD_VAR 0 1
27687: PPUSH
27688: LD_INT 60
27690: PPUSH
27691: LD_INT 95
27693: PPUSH
27694: CALL_OW 116
// exit ;
27698: GO 28517
// end ; if dec = 4 then
27700: LD_VAR 0 2
27704: PUSH
27705: LD_INT 4
27707: EQUAL
27708: IFFALSE 27738
// begin Say ( JMM , D15d-JMM-1 ) ;
27710: LD_EXP 38
27714: PPUSH
27715: LD_STRING D15d-JMM-1
27717: PPUSH
27718: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27722: LD_EXP 63
27726: PPUSH
27727: LD_STRING D15d-Pla-1
27729: PPUSH
27730: CALL_OW 94
// DialogueOff ;
27734: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27738: LD_EXP 61
27742: PPUSH
27743: CALL_OW 302
27747: PUSH
27748: LD_EXP 61
27752: PPUSH
27753: CALL_OW 255
27757: PUSH
27758: LD_INT 1
27760: EQUAL
27761: AND
27762: PUSH
27763: LD_INT 22
27765: PUSH
27766: LD_INT 1
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 34
27775: PUSH
27776: LD_INT 8
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PPUSH
27787: CALL_OW 69
27791: NOT
27792: AND
27793: IFFALSE 28418
// begin SetSide ( Friend , 8 ) ;
27795: LD_EXP 61
27799: PPUSH
27800: LD_INT 8
27802: PPUSH
27803: CALL_OW 235
// if IsInUnit ( Friend ) then
27807: LD_EXP 61
27811: PPUSH
27812: CALL_OW 310
27816: IFFALSE 27827
// ComExitBuilding ( Friend ) ;
27818: LD_EXP 61
27822: PPUSH
27823: CALL_OW 122
// if IsDriver ( Friend ) then
27827: LD_EXP 61
27831: PPUSH
27832: CALL 104872 0 1
27836: IFFALSE 27847
// ComExitVehicle ( Friend ) ;
27838: LD_EXP 61
27842: PPUSH
27843: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27847: LD_EXP 61
27851: PPUSH
27852: LD_INT 9
27854: PPUSH
27855: LD_INT 2
27857: PPUSH
27858: CALL_OW 171
// wait ( 0 0$05 ) ;
27862: LD_INT 175
27864: PPUSH
27865: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27869: LD_EXP 61
27873: PPUSH
27874: CALL_OW 87
// DialogueOn ;
27878: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27882: LD_EXP 38
27886: PPUSH
27887: LD_STRING D16-JMM-1
27889: PPUSH
27890: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27894: LD_EXP 61
27898: PPUSH
27899: LD_STRING D16-Friend-1
27901: PPUSH
27902: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27906: LD_EXP 38
27910: PPUSH
27911: LD_STRING D16-JMM-2
27913: PPUSH
27914: CALL_OW 88
// DialogueOff ;
27918: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27922: LD_EXP 61
27926: PPUSH
27927: LD_INT 1
27929: PPUSH
27930: CALL_OW 235
// ComHold ( Friend ) ;
27934: LD_EXP 61
27938: PPUSH
27939: CALL_OW 140
// wait ( 0 0$20 ) ;
27943: LD_INT 700
27945: PPUSH
27946: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27950: LD_EXP 61
27954: PPUSH
27955: LD_INT 9
27957: PPUSH
27958: LD_INT 2
27960: PPUSH
27961: CALL_OW 297
27965: PUSH
27966: LD_INT 30
27968: LESS
27969: IFFALSE 28038
// begin SetSide ( Friend , 8 ) ;
27971: LD_EXP 61
27975: PPUSH
27976: LD_INT 8
27978: PPUSH
27979: CALL_OW 235
// if IsInUnit ( Friend ) then
27983: LD_EXP 61
27987: PPUSH
27988: CALL_OW 310
27992: IFFALSE 28003
// ComExitBuilding ( Friend ) ;
27994: LD_EXP 61
27998: PPUSH
27999: CALL_OW 122
// if IsDriver ( Friend ) then
28003: LD_EXP 61
28007: PPUSH
28008: CALL 104872 0 1
28012: IFFALSE 28023
// ComExitVehicle ( Friend ) ;
28014: LD_EXP 61
28018: PPUSH
28019: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28023: LD_EXP 61
28027: PPUSH
28028: LD_INT 9
28030: PPUSH
28031: LD_INT 2
28033: PPUSH
28034: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28038: LD_INT 1050
28040: PPUSH
28041: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28045: LD_INT 22
28047: PUSH
28048: LD_INT 1
28050: PUSH
28051: EMPTY
28052: LIST
28053: LIST
28054: PUSH
28055: LD_INT 34
28057: PUSH
28058: LD_INT 8
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PPUSH
28069: CALL_OW 69
28073: NOT
28074: IFFALSE 28396
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28076: LD_ADDR_VAR 0 3
28080: PUSH
28081: LD_INT 22
28083: PUSH
28084: LD_INT 1
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 26
28093: PUSH
28094: LD_INT 1
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 3
28103: PUSH
28104: LD_INT 25
28106: PUSH
28107: LD_INT 12
28109: PUSH
28110: EMPTY
28111: LIST
28112: LIST
28113: PUSH
28114: LD_INT 25
28116: PUSH
28117: LD_INT 16
28119: PUSH
28120: EMPTY
28121: LIST
28122: LIST
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: LIST
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: LIST
28133: PPUSH
28134: CALL_OW 69
28138: PUSH
28139: LD_EXP 38
28143: PUSH
28144: LD_EXP 40
28148: PUSH
28149: LD_EXP 54
28153: PUSH
28154: LD_EXP 41
28158: PUSH
28159: LD_EXP 42
28163: PUSH
28164: LD_EXP 43
28168: PUSH
28169: LD_EXP 44
28173: PUSH
28174: LD_EXP 45
28178: PUSH
28179: LD_EXP 46
28183: PUSH
28184: LD_EXP 47
28188: PUSH
28189: LD_EXP 48
28193: PUSH
28194: LD_EXP 49
28198: PUSH
28199: LD_EXP 50
28203: PUSH
28204: LD_EXP 51
28208: PUSH
28209: LD_EXP 52
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: LIST
28218: LIST
28219: LIST
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: DIFF
28231: ST_TO_ADDR
// DialogueOn ;
28232: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28236: LD_EXP 63
28240: PPUSH
28241: LD_STRING D16a-Pla-1
28243: PPUSH
28244: CALL_OW 94
// if Stevens then
28248: LD_EXP 40
28252: IFFALSE 28268
// Say ( Stevens , D16a-Huck-1 ) else
28254: LD_EXP 40
28258: PPUSH
28259: LD_STRING D16a-Huck-1
28261: PPUSH
28262: CALL_OW 88
28266: GO 28310
// if Baker then
28268: LD_EXP 54
28272: IFFALSE 28288
// Say ( Baker , D16a-Huck-1 ) else
28274: LD_EXP 54
28278: PPUSH
28279: LD_STRING D16a-Huck-1
28281: PPUSH
28282: CALL_OW 88
28286: GO 28310
// if tmp then
28288: LD_VAR 0 3
28292: IFFALSE 28310
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28294: LD_VAR 0 3
28298: PUSH
28299: LD_INT 1
28301: ARRAY
28302: PPUSH
28303: LD_STRING D16a-Sol1-1
28305: PPUSH
28306: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28310: LD_EXP 61
28314: PPUSH
28315: CALL_OW 255
28319: PUSH
28320: LD_INT 8
28322: EQUAL
28323: IFFALSE 28339
// Say ( JMM , D16a-JMM-1 ) else
28325: LD_EXP 38
28329: PPUSH
28330: LD_STRING D16a-JMM-1
28332: PPUSH
28333: CALL_OW 88
28337: GO 28375
// begin Say ( JMM , D16a-JMM-1a ) ;
28339: LD_EXP 38
28343: PPUSH
28344: LD_STRING D16a-JMM-1a
28346: PPUSH
28347: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28351: LD_EXP 61
28355: PPUSH
28356: LD_STRING D16a-Friend-1
28358: PPUSH
28359: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28363: LD_EXP 61
28367: PPUSH
28368: LD_INT 3
28370: PPUSH
28371: CALL_OW 235
// end ; DialogueOff ;
28375: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28379: LD_VAR 0 1
28383: PPUSH
28384: LD_INT 60
28386: PPUSH
28387: LD_INT 95
28389: PPUSH
28390: CALL_OW 116
// end else
28394: GO 28416
// begin DialogueOn ;
28396: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28400: LD_EXP 63
28404: PPUSH
28405: LD_STRING D16c-Pla-
28407: PPUSH
28408: CALL_OW 94
// DialogueOff ;
28412: CALL_OW 7
// end ; end else
28416: GO 28517
// begin wait ( 3 3$00 ) ;
28418: LD_INT 6300
28420: PPUSH
28421: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28425: LD_INT 22
28427: PUSH
28428: LD_INT 1
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PUSH
28435: LD_INT 34
28437: PUSH
28438: LD_INT 8
28440: PUSH
28441: EMPTY
28442: LIST
28443: LIST
28444: PUSH
28445: EMPTY
28446: LIST
28447: LIST
28448: PPUSH
28449: CALL_OW 69
28453: NOT
28454: IFFALSE 28497
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28456: LD_EXP 63
28460: PPUSH
28461: LD_STRING D16b-Pla-1
28463: PPUSH
28464: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28468: LD_EXP 38
28472: PPUSH
28473: LD_STRING D16b-JMM-
28475: PPUSH
28476: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28480: LD_VAR 0 1
28484: PPUSH
28485: LD_INT 60
28487: PPUSH
28488: LD_INT 95
28490: PPUSH
28491: CALL_OW 116
// end else
28495: GO 28517
// begin DialogueOn ;
28497: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28501: LD_EXP 63
28505: PPUSH
28506: LD_STRING D16c-Pla-
28508: PPUSH
28509: CALL_OW 94
// DialogueOff ;
28513: CALL_OW 7
// end ; end ; end ;
28517: PPOPN 3
28519: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28520: LD_EXP 14
28524: PUSH
28525: LD_INT 126000
28527: GREATEREQUAL
28528: PUSH
28529: LD_EXP 23
28533: NOT
28534: AND
28535: PUSH
28536: LD_EXP 73
28540: PPUSH
28541: CALL_OW 302
28545: AND
28546: IFFALSE 28904
28548: GO 28550
28550: DISABLE
28551: LD_INT 0
28553: PPUSH
// begin missionStage = 11 ;
28554: LD_ADDR_EXP 15
28558: PUSH
28559: LD_INT 11
28561: ST_TO_ADDR
// DialogueOn ;
28562: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28566: LD_EXP 73
28570: PPUSH
28571: LD_STRING D9-Roth-1
28573: PPUSH
28574: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28578: LD_EXP 38
28582: PPUSH
28583: LD_STRING D9-JMM-1
28585: PPUSH
28586: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28590: LD_EXP 73
28594: PPUSH
28595: LD_STRING D9-Roth-2
28597: PPUSH
28598: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28602: LD_EXP 73
28606: PPUSH
28607: LD_STRING D9-Roth-2a
28609: PPUSH
28610: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28614: LD_EXP 63
28618: PPUSH
28619: LD_STRING D9-Pla-2
28621: PPUSH
28622: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28626: LD_EXP 73
28630: PPUSH
28631: LD_STRING D9-Roth-3
28633: PPUSH
28634: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28638: LD_EXP 63
28642: PPUSH
28643: LD_STRING D9-Pla-3
28645: PPUSH
28646: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28650: LD_EXP 73
28654: PPUSH
28655: LD_STRING D9-Roth-4
28657: PPUSH
28658: CALL_OW 94
// dec = Query ( Q9 ) ;
28662: LD_ADDR_VAR 0 1
28666: PUSH
28667: LD_STRING Q9
28669: PPUSH
28670: CALL_OW 97
28674: ST_TO_ADDR
// if dec = 1 then
28675: LD_VAR 0 1
28679: PUSH
28680: LD_INT 1
28682: EQUAL
28683: IFFALSE 28697
// SayRadio ( Roth , D9a-Roth-1 ) ;
28685: LD_EXP 73
28689: PPUSH
28690: LD_STRING D9a-Roth-1
28692: PPUSH
28693: CALL_OW 94
// if dec = 2 then
28697: LD_VAR 0 1
28701: PUSH
28702: LD_INT 2
28704: EQUAL
28705: IFFALSE 28731
// begin Say ( JMM , D9b-JMM-1 ) ;
28707: LD_EXP 38
28711: PPUSH
28712: LD_STRING D9b-JMM-1
28714: PPUSH
28715: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28719: LD_EXP 73
28723: PPUSH
28724: LD_STRING D9b-Roth-1
28726: PPUSH
28727: CALL_OW 94
// end ; if dec = 3 then
28731: LD_VAR 0 1
28735: PUSH
28736: LD_INT 3
28738: EQUAL
28739: IFFALSE 28801
// begin Say ( JMM , D9c-JMM-1 ) ;
28741: LD_EXP 38
28745: PPUSH
28746: LD_STRING D9c-JMM-1
28748: PPUSH
28749: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28753: LD_EXP 73
28757: PPUSH
28758: LD_STRING D9c-Roth-1
28760: PPUSH
28761: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28765: LD_EXP 38
28769: PPUSH
28770: LD_STRING D9c-JMM-2
28772: PPUSH
28773: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28777: LD_EXP 73
28781: PPUSH
28782: LD_STRING D9c-Roth-2
28784: PPUSH
28785: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28789: LD_EXP 38
28793: PPUSH
28794: LD_STRING D9c-JMM-3
28796: PPUSH
28797: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28801: LD_EXP 73
28805: PPUSH
28806: LD_STRING D9c-Roth-3
28808: PPUSH
28809: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28813: LD_EXP 73
28817: PPUSH
28818: LD_STRING D9cont-Roth-1
28820: PPUSH
28821: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28825: LD_EXP 38
28829: PPUSH
28830: LD_STRING D9cont-JMM-1
28832: PPUSH
28833: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28837: LD_EXP 73
28841: PPUSH
28842: LD_STRING D9cont-Roth-2
28844: PPUSH
28845: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28849: LD_EXP 38
28853: PPUSH
28854: LD_STRING D9cont-JMM-2
28856: PPUSH
28857: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28861: LD_EXP 73
28865: PPUSH
28866: LD_STRING D9cont-Roth-3
28868: PPUSH
28869: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28873: LD_EXP 38
28877: PPUSH
28878: LD_STRING D9cont-JMM-3
28880: PPUSH
28881: CALL_OW 88
// DialogueOff ;
28885: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28889: LD_STRING M3
28891: PPUSH
28892: CALL_OW 337
// allianceActive := true ;
28896: LD_ADDR_EXP 31
28900: PUSH
28901: LD_INT 1
28903: ST_TO_ADDR
// end ;
28904: PPOPN 1
28906: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28907: LD_EXP 63
28911: PPUSH
28912: CALL_OW 301
28916: PUSH
28917: LD_EXP 66
28921: PPUSH
28922: CALL_OW 301
28926: AND
28927: PUSH
28928: LD_INT 22
28930: PUSH
28931: LD_INT 3
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: PUSH
28938: LD_INT 21
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 50
28950: PUSH
28951: EMPTY
28952: LIST
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: LIST
28958: PPUSH
28959: CALL_OW 69
28963: PUSH
28964: LD_INT 7
28966: PUSH
28967: LD_INT 8
28969: PUSH
28970: LD_INT 9
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: LIST
28977: PUSH
28978: LD_OWVAR 67
28982: ARRAY
28983: LESS
28984: AND
28985: IFFALSE 29756
28987: GO 28989
28989: DISABLE
28990: LD_INT 0
28992: PPUSH
28993: PPUSH
28994: PPUSH
28995: PPUSH
// begin MC_Kill ( 1 ) ;
28996: LD_INT 1
28998: PPUSH
28999: CALL 34457 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29003: LD_INT 1
29005: PPUSH
29006: LD_INT 3
29008: PPUSH
29009: LD_INT 1
29011: PPUSH
29012: LD_INT 1
29014: PPUSH
29015: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29019: LD_ADDR_VAR 0 1
29023: PUSH
29024: LD_INT 22
29026: PUSH
29027: LD_INT 3
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 21
29036: PUSH
29037: LD_INT 1
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: LD_INT 24
29046: PUSH
29047: LD_INT 900
29049: PUSH
29050: EMPTY
29051: LIST
29052: LIST
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: LIST
29058: PPUSH
29059: CALL_OW 69
29063: PUSH
29064: FOR_IN
29065: IFFALSE 29096
// if GetSex ( i ) = sex_male then
29067: LD_VAR 0 1
29071: PPUSH
29072: CALL_OW 258
29076: PUSH
29077: LD_INT 1
29079: EQUAL
29080: IFFALSE 29094
// begin tmp = i ;
29082: LD_ADDR_VAR 0 2
29086: PUSH
29087: LD_VAR 0 1
29091: ST_TO_ADDR
// break ;
29092: GO 29096
// end ;
29094: GO 29064
29096: POP
29097: POP
// if tmp = 0 then
29098: LD_VAR 0 2
29102: PUSH
29103: LD_INT 0
29105: EQUAL
29106: IFFALSE 29160
// begin uc_side = 3 ;
29108: LD_ADDR_OWVAR 20
29112: PUSH
29113: LD_INT 3
29115: ST_TO_ADDR
// uc_nation = 3 ;
29116: LD_ADDR_OWVAR 21
29120: PUSH
29121: LD_INT 3
29123: ST_TO_ADDR
// hc_name =  ;
29124: LD_ADDR_OWVAR 26
29128: PUSH
29129: LD_STRING 
29131: ST_TO_ADDR
// hc_gallery =  ;
29132: LD_ADDR_OWVAR 33
29136: PUSH
29137: LD_STRING 
29139: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29140: LD_INT 1
29142: PPUSH
29143: LD_INT 10
29145: PPUSH
29146: CALL_OW 381
// tmp = CreateHuman ;
29150: LD_ADDR_VAR 0 2
29154: PUSH
29155: CALL_OW 44
29159: ST_TO_ADDR
// end ; DialogueOn ;
29160: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29164: LD_VAR 0 2
29168: PPUSH
29169: LD_STRING DSurrenderRussians-RSol1-1a
29171: PPUSH
29172: CALL_OW 94
// DialogueOff ;
29176: CALL_OW 7
// russianDestroyed := true ;
29180: LD_ADDR_EXP 21
29184: PUSH
29185: LD_INT 1
29187: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29188: LD_INT 22
29190: PUSH
29191: LD_INT 3
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 21
29200: PUSH
29201: LD_INT 1
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: PPUSH
29212: CALL_OW 69
29216: PPUSH
29217: CALL_OW 122
// wait ( 0 0$1 ) ;
29221: LD_INT 35
29223: PPUSH
29224: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29228: LD_INT 22
29230: PUSH
29231: LD_INT 3
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 21
29240: PUSH
29241: LD_INT 1
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PPUSH
29252: CALL_OW 69
29256: PPUSH
29257: LD_INT 25
29259: PPUSH
29260: CALL_OW 173
// wait ( 0 0$10 ) ;
29264: LD_INT 350
29266: PPUSH
29267: CALL_OW 67
// PrepareOmarInvasion ;
29271: CALL 13753 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29275: LD_ADDR_VAR 0 2
29279: PUSH
29280: LD_EXP 91
29284: PPUSH
29285: CALL_OW 250
29289: PUSH
29290: LD_EXP 91
29294: PPUSH
29295: CALL_OW 251
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29304: LD_VAR 0 2
29308: PUSH
29309: LD_INT 1
29311: ARRAY
29312: PPUSH
29313: LD_VAR 0 2
29317: PUSH
29318: LD_INT 2
29320: ARRAY
29321: PPUSH
29322: LD_INT 1
29324: PPUSH
29325: LD_INT 8
29327: NEG
29328: PPUSH
29329: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29333: LD_EXP 91
29337: PPUSH
29338: CALL_OW 87
// DialogueOn ;
29342: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29346: LD_EXP 38
29350: PPUSH
29351: LD_STRING D19-JMM-1
29353: PPUSH
29354: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29358: LD_ADDR_VAR 0 3
29362: PUSH
29363: LD_INT 22
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: LD_INT 26
29375: PUSH
29376: LD_INT 1
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 2
29385: PUSH
29386: LD_INT 25
29388: PUSH
29389: LD_INT 1
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 25
29398: PUSH
29399: LD_INT 2
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PUSH
29406: LD_INT 25
29408: PUSH
29409: LD_INT 3
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 25
29418: PUSH
29419: LD_INT 4
29421: PUSH
29422: EMPTY
29423: LIST
29424: LIST
29425: PUSH
29426: LD_INT 25
29428: PUSH
29429: LD_INT 5
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: LD_INT 25
29438: PUSH
29439: LD_INT 8
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: LIST
29453: LIST
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: LIST
29459: PPUSH
29460: CALL_OW 69
29464: PUSH
29465: LD_EXP 38
29469: PUSH
29470: LD_EXP 39
29474: PUSH
29475: LD_EXP 40
29479: PUSH
29480: LD_EXP 41
29484: PUSH
29485: LD_EXP 42
29489: PUSH
29490: LD_EXP 43
29494: PUSH
29495: LD_EXP 44
29499: PUSH
29500: LD_EXP 45
29504: PUSH
29505: LD_EXP 46
29509: PUSH
29510: LD_EXP 47
29514: PUSH
29515: LD_EXP 48
29519: PUSH
29520: LD_EXP 49
29524: PUSH
29525: LD_EXP 50
29529: PUSH
29530: LD_EXP 51
29534: PUSH
29535: LD_EXP 52
29539: PUSH
29540: LD_EXP 53
29544: PUSH
29545: LD_EXP 54
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: LIST
29554: LIST
29555: LIST
29556: LIST
29557: LIST
29558: LIST
29559: LIST
29560: LIST
29561: LIST
29562: LIST
29563: LIST
29564: LIST
29565: LIST
29566: LIST
29567: LIST
29568: DIFF
29569: ST_TO_ADDR
// if tmp2 then
29570: LD_VAR 0 3
29574: IFFALSE 29592
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29576: LD_VAR 0 3
29580: PUSH
29581: LD_INT 1
29583: ARRAY
29584: PPUSH
29585: LD_STRING D19-Sol1-1
29587: PPUSH
29588: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29592: LD_EXP 38
29596: PPUSH
29597: LD_STRING D19-JMM-2
29599: PPUSH
29600: CALL_OW 88
// DialogueOff ;
29604: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29608: LD_VAR 0 2
29612: PUSH
29613: LD_INT 1
29615: ARRAY
29616: PPUSH
29617: LD_VAR 0 2
29621: PUSH
29622: LD_INT 2
29624: ARRAY
29625: PPUSH
29626: LD_INT 1
29628: PPUSH
29629: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29633: LD_STRING M5
29635: PPUSH
29636: CALL_OW 337
// omarOnMotherLode := false ;
29640: LD_ADDR_VAR 0 4
29644: PUSH
29645: LD_INT 0
29647: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29648: LD_INT 35
29650: PPUSH
29651: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29655: LD_EXP 91
29659: PPUSH
29660: LD_INT 215
29662: PPUSH
29663: LD_INT 100
29665: PPUSH
29666: CALL_OW 297
29670: PUSH
29671: LD_INT 10
29673: LESS
29674: PUSH
29675: LD_VAR 0 4
29679: NOT
29680: AND
29681: IFFALSE 29715
// begin omarOnMotherLode := true ;
29683: LD_ADDR_VAR 0 4
29687: PUSH
29688: LD_INT 1
29690: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29691: LD_EXP 38
29695: PPUSH
29696: LD_STRING D19b-JMM-1
29698: PPUSH
29699: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29703: LD_EXP 91
29707: PPUSH
29708: LD_STRING DOmarContam-Omar-1
29710: PPUSH
29711: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29715: LD_EXP 91
29719: PPUSH
29720: CALL_OW 301
29724: IFFALSE 29648
// Say ( JMM , D19a-JMM-1 ) ;
29726: LD_EXP 38
29730: PPUSH
29731: LD_STRING D19a-JMM-1
29733: PPUSH
29734: CALL_OW 88
// if Heike then
29738: LD_EXP 92
29742: IFFALSE 29756
// Say ( Heike , D19a-Hke-1 ) ;
29744: LD_EXP 92
29748: PPUSH
29749: LD_STRING D19a-Hke-1
29751: PPUSH
29752: CALL_OW 88
// end ;
29756: PPOPN 4
29758: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29759: LD_INT 22
29761: PUSH
29762: LD_INT 3
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PUSH
29769: LD_INT 21
29771: PUSH
29772: LD_INT 1
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PPUSH
29783: CALL_OW 69
29787: PUSH
29788: LD_EXP 21
29792: AND
29793: IFFALSE 29861
29795: GO 29797
29797: DISABLE
29798: LD_INT 0
29800: PPUSH
29801: PPUSH
// begin enable ;
29802: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29803: LD_ADDR_VAR 0 2
29807: PUSH
29808: LD_INT 25
29810: PPUSH
29811: LD_INT 22
29813: PUSH
29814: LD_INT 3
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PPUSH
29821: CALL_OW 70
29825: ST_TO_ADDR
// if not tmp then
29826: LD_VAR 0 2
29830: NOT
29831: IFFALSE 29835
// exit ;
29833: GO 29861
// for i in tmp do
29835: LD_ADDR_VAR 0 1
29839: PUSH
29840: LD_VAR 0 2
29844: PUSH
29845: FOR_IN
29846: IFFALSE 29859
// RemoveUnit ( i ) ;
29848: LD_VAR 0 1
29852: PPUSH
29853: CALL_OW 64
29857: GO 29845
29859: POP
29860: POP
// end ;
29861: PPOPN 2
29863: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29864: LD_INT 22
29866: PUSH
29867: LD_INT 7
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 21
29876: PUSH
29877: LD_INT 1
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PPUSH
29888: CALL_OW 69
29892: PUSH
29893: LD_INT 6
29895: LESS
29896: IFFALSE 30364
29898: GO 29900
29900: DISABLE
29901: LD_INT 0
29903: PPUSH
29904: PPUSH
// begin MC_Kill ( 1 ) ;
29905: LD_INT 1
29907: PPUSH
29908: CALL 34457 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29912: LD_INT 7
29914: PPUSH
29915: LD_INT 1
29917: PPUSH
29918: LD_INT 1
29920: PPUSH
29921: LD_INT 1
29923: PPUSH
29924: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29928: LD_ADDR_VAR 0 1
29932: PUSH
29933: LD_INT 22
29935: PUSH
29936: LD_INT 7
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 26
29945: PUSH
29946: LD_INT 1
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PPUSH
29957: CALL_OW 69
29961: PUSH
29962: LD_EXP 73
29966: DIFF
29967: ST_TO_ADDR
// if tmp then
29968: LD_VAR 0 1
29972: IFFALSE 29990
// tmp := tmp [ 1 ] else
29974: LD_ADDR_VAR 0 1
29978: PUSH
29979: LD_VAR 0 1
29983: PUSH
29984: LD_INT 1
29986: ARRAY
29987: ST_TO_ADDR
29988: GO 30026
// begin uc_side := 7 ;
29990: LD_ADDR_OWVAR 20
29994: PUSH
29995: LD_INT 7
29997: ST_TO_ADDR
// uc_nation := 1 ;
29998: LD_ADDR_OWVAR 21
30002: PUSH
30003: LD_INT 1
30005: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30006: LD_INT 1
30008: PPUSH
30009: LD_INT 8
30011: PPUSH
30012: CALL_OW 384
// tmp := CreateHuman ;
30016: LD_ADDR_VAR 0 1
30020: PUSH
30021: CALL_OW 44
30025: ST_TO_ADDR
// end ; DialogueOn ;
30026: CALL_OW 6
// if IsOK ( Roth ) then
30030: LD_EXP 73
30034: PPUSH
30035: CALL_OW 302
30039: IFFALSE 30053
// Say ( JMM , DAb-JMM-1 ) ;
30041: LD_EXP 38
30045: PPUSH
30046: LD_STRING DAb-JMM-1
30048: PPUSH
30049: CALL_OW 88
// if IsOK ( Roth ) then
30053: LD_EXP 73
30057: PPUSH
30058: CALL_OW 302
30062: IFFALSE 30086
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30064: LD_EXP 73
30068: PPUSH
30069: LD_STRING DSurrenderAlliance-Roth-1
30071: PPUSH
30072: CALL_OW 88
// RothCaptured := true ;
30076: LD_ADDR_EXP 33
30080: PUSH
30081: LD_INT 1
30083: ST_TO_ADDR
// end else
30084: GO 30098
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30086: LD_VAR 0 1
30090: PPUSH
30091: LD_STRING DSurrenderAlliance-Sci1-1
30093: PPUSH
30094: CALL_OW 88
// DialogueOff ;
30098: CALL_OW 7
// allianceDestroyed := true ;
30102: LD_ADDR_EXP 23
30106: PUSH
30107: LD_INT 1
30109: ST_TO_ADDR
// if capturedUnit = 0 then
30110: LD_EXP 34
30114: PUSH
30115: LD_INT 0
30117: EQUAL
30118: IFFALSE 30127
// SetAchievement ( ACH_ALLIANCE ) ;
30120: LD_STRING ACH_ALLIANCE
30122: PPUSH
30123: CALL_OW 543
// if trueAmericans then
30127: LD_EXP 35
30131: IFFALSE 30207
// begin if trueAmericans = 1 then
30133: LD_EXP 35
30137: PUSH
30138: LD_INT 1
30140: EQUAL
30141: IFFALSE 30157
// Say ( JMM , DAb-JMM-1a ) else
30143: LD_EXP 38
30147: PPUSH
30148: LD_STRING DAb-JMM-1a
30150: PPUSH
30151: CALL_OW 88
30155: GO 30169
// Say ( JMM , DAb-JMM-1b ) ;
30157: LD_EXP 38
30161: PPUSH
30162: LD_STRING DAb-JMM-1b
30164: PPUSH
30165: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30169: LD_EXP 35
30173: PPUSH
30174: CALL_OW 87
// for i in trueAmericans do
30178: LD_ADDR_VAR 0 2
30182: PUSH
30183: LD_EXP 35
30187: PUSH
30188: FOR_IN
30189: IFFALSE 30205
// SetSide ( i , 1 ) ;
30191: LD_VAR 0 2
30195: PPUSH
30196: LD_INT 1
30198: PPUSH
30199: CALL_OW 235
30203: GO 30188
30205: POP
30206: POP
// end ; repeat wait ( 0 0$1 ) ;
30207: LD_INT 35
30209: PPUSH
30210: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30214: LD_ADDR_VAR 0 2
30218: PUSH
30219: LD_INT 22
30221: PUSH
30222: LD_INT 7
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PUSH
30229: LD_INT 21
30231: PUSH
30232: LD_INT 1
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: PPUSH
30243: CALL_OW 69
30247: PUSH
30248: FOR_IN
30249: IFFALSE 30331
// begin if IsInUnit ( i ) then
30251: LD_VAR 0 2
30255: PPUSH
30256: CALL_OW 310
30260: IFFALSE 30271
// ComExitBuilding ( i ) ;
30262: LD_VAR 0 2
30266: PPUSH
30267: CALL_OW 122
// if IsDriver ( i ) then
30271: LD_VAR 0 2
30275: PPUSH
30276: CALL 104872 0 1
30280: IFFALSE 30291
// ComExitVehicle ( i ) ;
30282: LD_VAR 0 2
30286: PPUSH
30287: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30291: LD_VAR 0 2
30295: PPUSH
30296: LD_INT 26
30298: PPUSH
30299: CALL_OW 308
30303: NOT
30304: IFFALSE 30320
// AddComMoveToArea ( i , allianceEscapeArea ) else
30306: LD_VAR 0 2
30310: PPUSH
30311: LD_INT 26
30313: PPUSH
30314: CALL_OW 173
30318: GO 30329
// RemoveUnit ( i ) ;
30320: LD_VAR 0 2
30324: PPUSH
30325: CALL_OW 64
// end ;
30329: GO 30248
30331: POP
30332: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30333: LD_INT 22
30335: PUSH
30336: LD_INT 7
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 21
30345: PUSH
30346: LD_INT 1
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PPUSH
30357: CALL_OW 69
30361: NOT
30362: IFFALSE 30207
// end ;
30364: PPOPN 2
30366: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30367: LD_INT 0
30369: PPUSH
30370: PPUSH
// if not unit then
30371: LD_VAR 0 1
30375: NOT
30376: IFFALSE 30380
// exit ;
30378: GO 31878
// DoNotAttack ( 7 , unit ) ;
30380: LD_INT 7
30382: PPUSH
30383: LD_VAR 0 1
30387: PPUSH
30388: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30392: LD_VAR 0 1
30396: PPUSH
30397: LD_INT 260
30399: PPUSH
30400: LD_INT 235
30402: PPUSH
30403: LD_INT 3
30405: PPUSH
30406: LD_INT 1
30408: PPUSH
30409: CALL_OW 483
// SetSide ( unit , 4 ) ;
30413: LD_VAR 0 1
30417: PPUSH
30418: LD_INT 4
30420: PPUSH
30421: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30425: LD_ADDR_EXP 34
30429: PUSH
30430: LD_EXP 34
30434: PUSH
30435: LD_INT 1
30437: PLUS
30438: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30439: LD_INT 70
30441: PPUSH
30442: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30446: LD_INT 260
30448: PPUSH
30449: LD_INT 235
30451: PPUSH
30452: LD_INT 1
30454: PPUSH
30455: LD_INT 8
30457: NEG
30458: PPUSH
30459: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30463: LD_VAR 0 1
30467: PPUSH
30468: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30472: LD_VAR 0 1
30476: PPUSH
30477: LD_EXP 73
30481: PPUSH
30482: CALL_OW 119
// DialogueOn ;
30486: CALL_OW 6
// case unit of JMM :
30490: LD_VAR 0 1
30494: PUSH
30495: LD_EXP 38
30499: DOUBLE
30500: EQUAL
30501: IFTRUE 30505
30503: GO 30520
30505: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30506: LD_EXP 38
30510: PPUSH
30511: LD_STRING DA1-JMM-1
30513: PPUSH
30514: CALL_OW 91
30518: GO 30962
30520: LD_EXP 39
30524: DOUBLE
30525: EQUAL
30526: IFTRUE 30530
30528: GO 30545
30530: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30531: LD_EXP 39
30535: PPUSH
30536: LD_STRING DA1-Joan-1
30538: PPUSH
30539: CALL_OW 91
30543: GO 30962
30545: LD_EXP 41
30549: DOUBLE
30550: EQUAL
30551: IFTRUE 30555
30553: GO 30570
30555: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30556: LD_EXP 41
30560: PPUSH
30561: LD_STRING DA1-Lisa-1
30563: PPUSH
30564: CALL_OW 91
30568: GO 30962
30570: LD_EXP 42
30574: DOUBLE
30575: EQUAL
30576: IFTRUE 30580
30578: GO 30595
30580: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30581: LD_EXP 42
30585: PPUSH
30586: LD_STRING DA1-Don-1
30588: PPUSH
30589: CALL_OW 91
30593: GO 30962
30595: LD_EXP 49
30599: DOUBLE
30600: EQUAL
30601: IFTRUE 30605
30603: GO 30620
30605: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30606: LD_EXP 49
30610: PPUSH
30611: LD_STRING DA1-Corn-1
30613: PPUSH
30614: CALL_OW 91
30618: GO 30962
30620: LD_EXP 45
30624: DOUBLE
30625: EQUAL
30626: IFTRUE 30630
30628: GO 30645
30630: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30631: LD_EXP 45
30635: PPUSH
30636: LD_STRING DA1-Den-1
30638: PPUSH
30639: CALL_OW 91
30643: GO 30962
30645: LD_EXP 43
30649: DOUBLE
30650: EQUAL
30651: IFTRUE 30655
30653: GO 30670
30655: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30656: LD_EXP 43
30660: PPUSH
30661: LD_STRING DA1-Bobby-1
30663: PPUSH
30664: CALL_OW 91
30668: GO 30962
30670: LD_EXP 47
30674: DOUBLE
30675: EQUAL
30676: IFTRUE 30680
30678: GO 30695
30680: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30681: LD_EXP 47
30685: PPUSH
30686: LD_STRING DA1-Glad-1
30688: PPUSH
30689: CALL_OW 91
30693: GO 30962
30695: LD_EXP 44
30699: DOUBLE
30700: EQUAL
30701: IFTRUE 30705
30703: GO 30720
30705: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30706: LD_EXP 44
30710: PPUSH
30711: LD_STRING DA1-Cyrus-1
30713: PPUSH
30714: CALL_OW 91
30718: GO 30962
30720: LD_EXP 40
30724: DOUBLE
30725: EQUAL
30726: IFTRUE 30730
30728: GO 30745
30730: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30731: LD_EXP 40
30735: PPUSH
30736: LD_STRING DA1-Huck-1
30738: PPUSH
30739: CALL_OW 91
30743: GO 30962
30745: LD_EXP 54
30749: DOUBLE
30750: EQUAL
30751: IFTRUE 30755
30753: GO 30770
30755: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30756: LD_EXP 54
30760: PPUSH
30761: LD_STRING DA1-Huck-1
30763: PPUSH
30764: CALL_OW 91
30768: GO 30962
30770: LD_EXP 46
30774: DOUBLE
30775: EQUAL
30776: IFTRUE 30780
30778: GO 30795
30780: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30781: LD_EXP 46
30785: PPUSH
30786: LD_STRING DA1-Brown-1
30788: PPUSH
30789: CALL_OW 91
30793: GO 30962
30795: LD_EXP 50
30799: DOUBLE
30800: EQUAL
30801: IFTRUE 30805
30803: GO 30820
30805: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30806: LD_EXP 50
30810: PPUSH
30811: LD_STRING DA1-Gary-1
30813: PPUSH
30814: CALL_OW 91
30818: GO 30962
30820: LD_EXP 53
30824: DOUBLE
30825: EQUAL
30826: IFTRUE 30830
30828: GO 30845
30830: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30831: LD_EXP 53
30835: PPUSH
30836: LD_STRING DA1-Con-1
30838: PPUSH
30839: CALL_OW 91
30843: GO 30962
30845: LD_EXP 59
30849: DOUBLE
30850: EQUAL
30851: IFTRUE 30855
30853: GO 30870
30855: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30856: LD_EXP 59
30860: PPUSH
30861: LD_STRING DA1-Kurt-1
30863: PPUSH
30864: CALL_OW 91
30868: GO 30962
30870: LD_EXP 52
30874: DOUBLE
30875: EQUAL
30876: IFTRUE 30880
30878: GO 30895
30880: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30881: LD_EXP 52
30885: PPUSH
30886: LD_STRING DA1-Yam-1
30888: PPUSH
30889: CALL_OW 91
30893: GO 30962
30895: LD_EXP 51
30899: DOUBLE
30900: EQUAL
30901: IFTRUE 30905
30903: GO 30920
30905: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30906: LD_EXP 51
30910: PPUSH
30911: LD_STRING DA1-Frank-1
30913: PPUSH
30914: CALL_OW 91
30918: GO 30962
30920: POP
// begin if GetSex ( unit ) = sex_male then
30921: LD_VAR 0 1
30925: PPUSH
30926: CALL_OW 258
30930: PUSH
30931: LD_INT 1
30933: EQUAL
30934: IFFALSE 30950
// ForceSay ( unit , DA1-Sol1-1 ) else
30936: LD_VAR 0 1
30940: PPUSH
30941: LD_STRING DA1-Sol1-1
30943: PPUSH
30944: CALL_OW 91
30948: GO 30962
// ForceSay ( unit , DA1-FSol1-1 ) ;
30950: LD_VAR 0 1
30954: PPUSH
30955: LD_STRING DA1-FSol1-1
30957: PPUSH
30958: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30962: LD_EXP 73
30966: PPUSH
30967: LD_STRING DA-Roth-1
30969: PPUSH
30970: CALL_OW 88
// if capturedUnit = 1 then
30974: LD_EXP 34
30978: PUSH
30979: LD_INT 1
30981: EQUAL
30982: IFFALSE 31010
// begin Say ( Simms , DA-Sim-1 ) ;
30984: LD_EXP 74
30988: PPUSH
30989: LD_STRING DA-Sim-1
30991: PPUSH
30992: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30996: LD_EXP 73
31000: PPUSH
31001: LD_STRING DA-Roth-2
31003: PPUSH
31004: CALL_OW 88
// end else
31008: GO 31022
// Say ( Simms , DA-Sim-2 ) ;
31010: LD_EXP 74
31014: PPUSH
31015: LD_STRING DA-Sim-2
31017: PPUSH
31018: CALL_OW 88
// case unit of JMM :
31022: LD_VAR 0 1
31026: PUSH
31027: LD_EXP 38
31031: DOUBLE
31032: EQUAL
31033: IFTRUE 31037
31035: GO 31052
31037: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31038: LD_EXP 38
31042: PPUSH
31043: LD_STRING DA1-JMM-1a
31045: PPUSH
31046: CALL_OW 91
31050: GO 31559
31052: LD_EXP 39
31056: DOUBLE
31057: EQUAL
31058: IFTRUE 31062
31060: GO 31077
31062: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31063: LD_EXP 39
31067: PPUSH
31068: LD_STRING DA1-Joan-1a
31070: PPUSH
31071: CALL_OW 91
31075: GO 31559
31077: LD_EXP 41
31081: DOUBLE
31082: EQUAL
31083: IFTRUE 31087
31085: GO 31102
31087: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31088: LD_EXP 41
31092: PPUSH
31093: LD_STRING DA1-Lisa-1a
31095: PPUSH
31096: CALL_OW 91
31100: GO 31559
31102: LD_EXP 42
31106: DOUBLE
31107: EQUAL
31108: IFTRUE 31112
31110: GO 31127
31112: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31113: LD_EXP 42
31117: PPUSH
31118: LD_STRING DA1-Don-1a
31120: PPUSH
31121: CALL_OW 91
31125: GO 31559
31127: LD_EXP 49
31131: DOUBLE
31132: EQUAL
31133: IFTRUE 31137
31135: GO 31152
31137: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31138: LD_EXP 49
31142: PPUSH
31143: LD_STRING DA1-Corn-1a
31145: PPUSH
31146: CALL_OW 91
31150: GO 31559
31152: LD_EXP 45
31156: DOUBLE
31157: EQUAL
31158: IFTRUE 31162
31160: GO 31177
31162: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31163: LD_EXP 45
31167: PPUSH
31168: LD_STRING DA1-Den-1a
31170: PPUSH
31171: CALL_OW 91
31175: GO 31559
31177: LD_EXP 43
31181: DOUBLE
31182: EQUAL
31183: IFTRUE 31187
31185: GO 31202
31187: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31188: LD_EXP 43
31192: PPUSH
31193: LD_STRING DA1-Bobby-1a
31195: PPUSH
31196: CALL_OW 91
31200: GO 31559
31202: LD_EXP 47
31206: DOUBLE
31207: EQUAL
31208: IFTRUE 31212
31210: GO 31227
31212: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31213: LD_EXP 47
31217: PPUSH
31218: LD_STRING DA1-Glad-1a
31220: PPUSH
31221: CALL_OW 91
31225: GO 31559
31227: LD_EXP 44
31231: DOUBLE
31232: EQUAL
31233: IFTRUE 31237
31235: GO 31252
31237: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31238: LD_EXP 44
31242: PPUSH
31243: LD_STRING DA1-Cyrus-1a
31245: PPUSH
31246: CALL_OW 91
31250: GO 31559
31252: LD_EXP 40
31256: DOUBLE
31257: EQUAL
31258: IFTRUE 31262
31260: GO 31277
31262: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31263: LD_EXP 40
31267: PPUSH
31268: LD_STRING DA1-Huck-1a
31270: PPUSH
31271: CALL_OW 91
31275: GO 31559
31277: LD_EXP 54
31281: DOUBLE
31282: EQUAL
31283: IFTRUE 31287
31285: GO 31302
31287: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31288: LD_EXP 54
31292: PPUSH
31293: LD_STRING DA1-Huck-1a
31295: PPUSH
31296: CALL_OW 91
31300: GO 31559
31302: LD_EXP 46
31306: DOUBLE
31307: EQUAL
31308: IFTRUE 31312
31310: GO 31327
31312: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31313: LD_EXP 46
31317: PPUSH
31318: LD_STRING DA1-Brown-1a
31320: PPUSH
31321: CALL_OW 91
31325: GO 31559
31327: LD_EXP 50
31331: DOUBLE
31332: EQUAL
31333: IFTRUE 31337
31335: GO 31352
31337: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31338: LD_EXP 50
31342: PPUSH
31343: LD_STRING DA1-Gary-1a
31345: PPUSH
31346: CALL_OW 91
31350: GO 31559
31352: LD_EXP 53
31356: DOUBLE
31357: EQUAL
31358: IFTRUE 31362
31360: GO 31377
31362: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31363: LD_EXP 53
31367: PPUSH
31368: LD_STRING DA1-Con-1a
31370: PPUSH
31371: CALL_OW 91
31375: GO 31559
31377: LD_EXP 59
31381: DOUBLE
31382: EQUAL
31383: IFTRUE 31387
31385: GO 31402
31387: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31388: LD_EXP 59
31392: PPUSH
31393: LD_STRING DA1-Kurt-1a
31395: PPUSH
31396: CALL_OW 91
31400: GO 31559
31402: LD_EXP 52
31406: DOUBLE
31407: EQUAL
31408: IFTRUE 31412
31410: GO 31427
31412: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31413: LD_EXP 52
31417: PPUSH
31418: LD_STRING DA1-Yam-1a
31420: PPUSH
31421: CALL_OW 91
31425: GO 31559
31427: LD_EXP 51
31431: DOUBLE
31432: EQUAL
31433: IFTRUE 31437
31435: GO 31452
31437: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31438: LD_EXP 51
31442: PPUSH
31443: LD_STRING DA1-Frank-1a
31445: PPUSH
31446: CALL_OW 91
31450: GO 31559
31452: POP
// begin join := rand ( 0 , 1 ) ;
31453: LD_ADDR_VAR 0 3
31457: PUSH
31458: LD_INT 0
31460: PPUSH
31461: LD_INT 1
31463: PPUSH
31464: CALL_OW 12
31468: ST_TO_ADDR
// if join then
31469: LD_VAR 0 3
31473: IFFALSE 31518
// begin if GetSex ( unit ) = sex_male then
31475: LD_VAR 0 1
31479: PPUSH
31480: CALL_OW 258
31484: PUSH
31485: LD_INT 1
31487: EQUAL
31488: IFFALSE 31504
// ForceSay ( unit , DA1-Sol1-1b ) else
31490: LD_VAR 0 1
31494: PPUSH
31495: LD_STRING DA1-Sol1-1b
31497: PPUSH
31498: CALL_OW 91
31502: GO 31516
// ForceSay ( unit , DA1-FSol1-1b ) ;
31504: LD_VAR 0 1
31508: PPUSH
31509: LD_STRING DA1-FSol1-1b
31511: PPUSH
31512: CALL_OW 91
// end else
31516: GO 31559
// begin if GetSex ( unit ) = sex_male then
31518: LD_VAR 0 1
31522: PPUSH
31523: CALL_OW 258
31527: PUSH
31528: LD_INT 1
31530: EQUAL
31531: IFFALSE 31547
// ForceSay ( unit , DA1-Sol1-1a ) else
31533: LD_VAR 0 1
31537: PPUSH
31538: LD_STRING DA1-Sol1-1a
31540: PPUSH
31541: CALL_OW 91
31545: GO 31559
// ForceSay ( unit , DA1-FSol1-1a ) ;
31547: LD_VAR 0 1
31551: PPUSH
31552: LD_STRING DA1-FSol1-1a
31554: PPUSH
31555: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31559: LD_VAR 0 1
31563: PUSH
31564: LD_EXP 38
31568: EQUAL
31569: IFFALSE 31580
// begin YouLost ( JMMCaptured ) ;
31571: LD_STRING JMMCaptured
31573: PPUSH
31574: CALL_OW 104
// exit ;
31578: GO 31878
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31580: LD_VAR 0 1
31584: PUSH
31585: LD_EXP 42
31589: PUSH
31590: LD_EXP 45
31594: PUSH
31595: LD_EXP 43
31599: PUSH
31600: LD_EXP 40
31604: PUSH
31605: LD_EXP 54
31609: PUSH
31610: LD_EXP 46
31614: PUSH
31615: LD_EXP 52
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: LIST
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: IN
31629: PUSH
31630: LD_VAR 0 3
31634: OR
31635: IFFALSE 31734
// begin Say ( Roth , DA-Roth-3 ) ;
31637: LD_EXP 73
31641: PPUSH
31642: LD_STRING DA-Roth-3
31644: PPUSH
31645: CALL_OW 88
// SetSide ( unit , 7 ) ;
31649: LD_VAR 0 1
31653: PPUSH
31654: LD_INT 7
31656: PPUSH
31657: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31661: LD_ADDR_EXP 101
31665: PUSH
31666: LD_EXP 101
31670: PPUSH
31671: LD_INT 1
31673: PPUSH
31674: LD_EXP 101
31678: PUSH
31679: LD_INT 1
31681: ARRAY
31682: PUSH
31683: LD_VAR 0 1
31687: ADD
31688: PPUSH
31689: CALL_OW 1
31693: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31694: LD_INT 260
31696: PPUSH
31697: LD_INT 235
31699: PPUSH
31700: LD_INT 1
31702: PPUSH
31703: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31707: LD_VAR 0 1
31711: PPUSH
31712: LD_INT 1000
31714: PPUSH
31715: CALL_OW 234
// DialogueOff ;
31719: CALL_OW 7
// ComFree ( unit ) ;
31723: LD_VAR 0 1
31727: PPUSH
31728: CALL_OW 139
// end else
31732: GO 31815
// begin Say ( Roth , DA-Roth-3a ) ;
31734: LD_EXP 73
31738: PPUSH
31739: LD_STRING DA-Roth-3a
31741: PPUSH
31742: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31746: LD_ADDR_EXP 35
31750: PUSH
31751: LD_EXP 35
31755: PUSH
31756: LD_VAR 0 1
31760: ADD
31761: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31762: LD_INT 260
31764: PPUSH
31765: LD_INT 235
31767: PPUSH
31768: LD_INT 1
31770: PPUSH
31771: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31775: LD_VAR 0 1
31779: PPUSH
31780: LD_INT 1000
31782: PPUSH
31783: CALL_OW 234
// DialogueOff ;
31787: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31791: LD_VAR 0 1
31795: PPUSH
31796: LD_INT 272
31798: PPUSH
31799: LD_INT 254
31801: PPUSH
31802: CALL_OW 111
// AddComHold ( unit ) ;
31806: LD_VAR 0 1
31810: PPUSH
31811: CALL_OW 200
// end ; if capturedUnit = 1 then
31815: LD_EXP 34
31819: PUSH
31820: LD_INT 1
31822: EQUAL
31823: IFFALSE 31878
// begin DialogueOn ;
31825: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31829: LD_EXP 38
31833: PPUSH
31834: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31838: LD_EXP 38
31842: PPUSH
31843: LD_STRING DAa-JMM-1
31845: PPUSH
31846: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31850: LD_EXP 38
31854: PPUSH
31855: LD_STRING DAa-JMM-1a
31857: PPUSH
31858: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31862: LD_EXP 38
31866: PPUSH
31867: LD_STRING DAa-JMM-1b
31869: PPUSH
31870: CALL_OW 88
// DialogueOff ;
31874: CALL_OW 7
// end ; end ;
31878: LD_VAR 0 2
31882: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31883: LD_EXP 15
31887: PUSH
31888: LD_INT 13
31890: GREATEREQUAL
31891: PUSH
31892: LD_INT 22
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 21
31904: PUSH
31905: LD_INT 1
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PPUSH
31916: CALL_OW 69
31920: PUSH
31921: LD_INT 0
31923: EQUAL
31924: AND
31925: PUSH
31926: LD_INT 22
31928: PUSH
31929: LD_INT 2
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 21
31938: PUSH
31939: LD_INT 2
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PUSH
31946: LD_INT 50
31948: PUSH
31949: EMPTY
31950: LIST
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: LIST
31956: PPUSH
31957: CALL_OW 69
31961: PUSH
31962: LD_INT 0
31964: EQUAL
31965: AND
31966: PUSH
31967: LD_EXP 21
31971: AND
31972: PUSH
31973: LD_EXP 22
31977: AND
31978: PUSH
31979: LD_EXP 23
31983: AND
31984: IFFALSE 32626
31986: GO 31988
31988: DISABLE
31989: LD_INT 0
31991: PPUSH
31992: PPUSH
31993: PPUSH
// begin m1 := false ;
31994: LD_ADDR_VAR 0 1
31998: PUSH
31999: LD_INT 0
32001: ST_TO_ADDR
// m2 := false ;
32002: LD_ADDR_VAR 0 2
32006: PUSH
32007: LD_INT 0
32009: ST_TO_ADDR
// m3 := false ;
32010: LD_ADDR_VAR 0 3
32014: PUSH
32015: LD_INT 0
32017: ST_TO_ADDR
// if not bombExploded then
32018: LD_EXP 37
32022: NOT
32023: IFFALSE 32032
// SetAchievement ( ACH_SIBROCKET ) ;
32025: LD_STRING ACH_SIBROCKET
32027: PPUSH
32028: CALL_OW 543
// if tick <= 120 120$00 then
32032: LD_OWVAR 1
32036: PUSH
32037: LD_INT 252000
32039: LESSEQUAL
32040: IFFALSE 32056
// begin wait ( 3 ) ;
32042: LD_INT 3
32044: PPUSH
32045: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32049: LD_STRING ACH_ASPEED_15
32051: PPUSH
32052: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32056: LD_EXP 38
32060: PPUSH
32061: CALL_OW 87
// music_class := 5 ;
32065: LD_ADDR_OWVAR 72
32069: PUSH
32070: LD_INT 5
32072: ST_TO_ADDR
// music_nat := 5 ;
32073: LD_ADDR_OWVAR 71
32077: PUSH
32078: LD_INT 5
32080: ST_TO_ADDR
// DialogueOn ;
32081: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32085: LD_EXP 38
32089: PPUSH
32090: LD_STRING D20-JMM-1
32092: PPUSH
32093: CALL_OW 88
// if IsOK ( Joan ) then
32097: LD_EXP 39
32101: PPUSH
32102: CALL_OW 302
32106: IFFALSE 32120
// Say ( Joan , D20-Joan-1 ) ;
32108: LD_EXP 39
32112: PPUSH
32113: LD_STRING D20-Joan-1
32115: PPUSH
32116: CALL_OW 88
// if IsOk ( Lisa ) then
32120: LD_EXP 41
32124: PPUSH
32125: CALL_OW 302
32129: IFFALSE 32143
// Say ( Lisa , D20-Lisa-1 ) ;
32131: LD_EXP 41
32135: PPUSH
32136: LD_STRING D20-Lisa-1
32138: PPUSH
32139: CALL_OW 88
// if IsOk ( Donaldson ) then
32143: LD_EXP 42
32147: PPUSH
32148: CALL_OW 302
32152: IFFALSE 32166
// Say ( Donaldson , D20-Don-1 ) ;
32154: LD_EXP 42
32158: PPUSH
32159: LD_STRING D20-Don-1
32161: PPUSH
32162: CALL_OW 88
// if IsOK ( Cornel ) then
32166: LD_EXP 49
32170: PPUSH
32171: CALL_OW 302
32175: IFFALSE 32189
// Say ( Cornel , D20-Corn-1 ) ;
32177: LD_EXP 49
32181: PPUSH
32182: LD_STRING D20-Corn-1
32184: PPUSH
32185: CALL_OW 88
// if IsOk ( Denis ) then
32189: LD_EXP 45
32193: PPUSH
32194: CALL_OW 302
32198: IFFALSE 32212
// Say ( Denis , D20-Den-1 ) ;
32200: LD_EXP 45
32204: PPUSH
32205: LD_STRING D20-Den-1
32207: PPUSH
32208: CALL_OW 88
// if IsOk ( Bobby ) then
32212: LD_EXP 43
32216: PPUSH
32217: CALL_OW 302
32221: IFFALSE 32235
// Say ( Bobby , D20-Bobby-1 ) ;
32223: LD_EXP 43
32227: PPUSH
32228: LD_STRING D20-Bobby-1
32230: PPUSH
32231: CALL_OW 88
// if IsOk ( Gladstone ) then
32235: LD_EXP 47
32239: PPUSH
32240: CALL_OW 302
32244: IFFALSE 32258
// Say ( Gladstone , D20-Glad-1 ) ;
32246: LD_EXP 47
32250: PPUSH
32251: LD_STRING D20-Glad-1
32253: PPUSH
32254: CALL_OW 88
// if IsOk ( Cyrus ) then
32258: LD_EXP 44
32262: PPUSH
32263: CALL_OW 302
32267: IFFALSE 32281
// Say ( Cyrus , D20-Cyrus-1 ) ;
32269: LD_EXP 44
32273: PPUSH
32274: LD_STRING D20-Cyrus-1
32276: PPUSH
32277: CALL_OW 88
// if IsOk ( Stevens ) then
32281: LD_EXP 40
32285: PPUSH
32286: CALL_OW 302
32290: IFFALSE 32304
// Say ( Stevens , D20-Huck-1 ) ;
32292: LD_EXP 40
32296: PPUSH
32297: LD_STRING D20-Huck-1
32299: PPUSH
32300: CALL_OW 88
// if IsOk ( Brown ) then
32304: LD_EXP 46
32308: PPUSH
32309: CALL_OW 302
32313: IFFALSE 32327
// Say ( Brown , D20-Brown-1 ) ;
32315: LD_EXP 46
32319: PPUSH
32320: LD_STRING D20-Brown-1
32322: PPUSH
32323: CALL_OW 88
// if IsOk ( Gary ) then
32327: LD_EXP 50
32331: PPUSH
32332: CALL_OW 302
32336: IFFALSE 32350
// Say ( Gary , D20-Gary-1 ) ;
32338: LD_EXP 50
32342: PPUSH
32343: LD_STRING D20-Gary-1
32345: PPUSH
32346: CALL_OW 88
// if IsOk ( Connie ) then
32350: LD_EXP 53
32354: PPUSH
32355: CALL_OW 302
32359: IFFALSE 32373
// Say ( Connie , D20-Con-1 ) ;
32361: LD_EXP 53
32365: PPUSH
32366: LD_STRING D20-Con-1
32368: PPUSH
32369: CALL_OW 88
// if IsOk ( Kurt ) then
32373: LD_EXP 59
32377: PPUSH
32378: CALL_OW 302
32382: IFFALSE 32396
// Say ( Kurt , D20-Kurt-1 ) ;
32384: LD_EXP 59
32388: PPUSH
32389: LD_STRING D20-Kurt-1
32391: PPUSH
32392: CALL_OW 88
// if IsOk ( Kikuchi ) then
32396: LD_EXP 52
32400: PPUSH
32401: CALL_OW 302
32405: IFFALSE 32419
// Say ( Kikuchi , D20-Yam-1 ) ;
32407: LD_EXP 52
32411: PPUSH
32412: LD_STRING D20-Yam-1
32414: PPUSH
32415: CALL_OW 88
// if IsOk ( Frank ) then
32419: LD_EXP 51
32423: PPUSH
32424: CALL_OW 302
32428: IFFALSE 32442
// Say ( Frank , D20-Frank-1 ) ;
32430: LD_EXP 51
32434: PPUSH
32435: LD_STRING D20-Frank-1
32437: PPUSH
32438: CALL_OW 88
// DialogueOff ;
32442: CALL_OW 7
// if RothCaptured then
32446: LD_EXP 33
32450: IFFALSE 32472
// begin m1 := true ;
32452: LD_ADDR_VAR 0 1
32456: PUSH
32457: LD_INT 1
32459: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32460: LD_STRING Roth
32462: PPUSH
32463: LD_INT 1
32465: PPUSH
32466: CALL_OW 101
// end else
32470: GO 32483
// AddMedal ( Roth , - 1 ) ;
32472: LD_STRING Roth
32474: PPUSH
32475: LD_INT 1
32477: NEG
32478: PPUSH
32479: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32483: LD_EXP 27
32487: IFFALSE 32509
// begin m2 := true ;
32489: LD_ADDR_VAR 0 2
32493: PUSH
32494: LD_INT 1
32496: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32497: LD_STRING Project
32499: PPUSH
32500: LD_INT 1
32502: PPUSH
32503: CALL_OW 101
// end else
32507: GO 32520
// AddMedal ( Project , - 1 ) ;
32509: LD_STRING Project
32511: PPUSH
32512: LD_INT 1
32514: NEG
32515: PPUSH
32516: CALL_OW 101
// if lostCounter = 0 then
32520: LD_EXP 32
32524: PUSH
32525: LD_INT 0
32527: EQUAL
32528: IFFALSE 32550
// begin m3 := true ;
32530: LD_ADDR_VAR 0 3
32534: PUSH
32535: LD_INT 1
32537: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32538: LD_STRING NoLosses
32540: PPUSH
32541: LD_INT 1
32543: PPUSH
32544: CALL_OW 101
// end else
32548: GO 32561
// AddMedal ( NoLosses , - 1 ) ;
32550: LD_STRING NoLosses
32552: PPUSH
32553: LD_INT 1
32555: NEG
32556: PPUSH
32557: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32561: LD_VAR 0 1
32565: PUSH
32566: LD_VAR 0 2
32570: AND
32571: PUSH
32572: LD_VAR 0 3
32576: AND
32577: PUSH
32578: LD_OWVAR 67
32582: PUSH
32583: LD_INT 3
32585: EQUAL
32586: AND
32587: IFFALSE 32599
// SetAchievementEX ( ACH_AMER , 15 ) ;
32589: LD_STRING ACH_AMER
32591: PPUSH
32592: LD_INT 15
32594: PPUSH
32595: CALL_OW 564
// GiveMedals ( MAIN ) ;
32599: LD_STRING MAIN
32601: PPUSH
32602: CALL_OW 102
// music_class := 4 ;
32606: LD_ADDR_OWVAR 72
32610: PUSH
32611: LD_INT 4
32613: ST_TO_ADDR
// music_nat := 1 ;
32614: LD_ADDR_OWVAR 71
32618: PUSH
32619: LD_INT 1
32621: ST_TO_ADDR
// YouWin ;
32622: CALL_OW 103
// end ; end_of_file
32626: PPOPN 3
32628: END
// export function CustomEvent ( event ) ; begin
32629: LD_INT 0
32631: PPUSH
// end ;
32632: LD_VAR 0 2
32636: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32637: LD_VAR 0 1
32641: PUSH
32642: LD_INT 1
32644: EQUAL
32645: PUSH
32646: LD_VAR 0 2
32650: PUSH
32651: LD_INT 4
32653: EQUAL
32654: AND
32655: PUSH
32656: LD_EXP 57
32660: PPUSH
32661: CALL_OW 300
32665: AND
32666: IFFALSE 32682
// begin wait ( 0 0$2 ) ;
32668: LD_INT 70
32670: PPUSH
32671: CALL_OW 67
// YouLost ( Dismissed ) ;
32675: LD_STRING Dismissed
32677: PPUSH
32678: CALL_OW 104
// end ; end ;
32682: PPOPN 2
32684: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32685: LD_VAR 0 2
32689: PPUSH
32690: LD_VAR 0 3
32694: PPUSH
32695: LD_INT 18
32697: PPUSH
32698: CALL_OW 309
32702: IFFALSE 32711
// YouLost ( Motherlode3 ) ;
32704: LD_STRING Motherlode3
32706: PPUSH
32707: CALL_OW 104
// end ;
32711: PPOPN 3
32713: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32714: LD_EXP 27
32718: NOT
32719: IFFALSE 32729
// behemothDone := true ;
32721: LD_ADDR_EXP 28
32725: PUSH
32726: LD_INT 1
32728: ST_TO_ADDR
// end ;
32729: PPOPN 1
32731: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
32732: LD_VAR 0 1
32736: PPUSH
32737: CALL_OW 255
32741: PUSH
32742: LD_INT 1
32744: EQUAL
32745: IFFALSE 32755
// bombExploded := true ;
32747: LD_ADDR_EXP 37
32751: PUSH
32752: LD_INT 1
32754: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32755: LD_VAR 0 1
32759: PPUSH
32760: CALL_OW 255
32764: PUSH
32765: LD_INT 1
32767: EQUAL
32768: PUSH
32769: LD_EXP 30
32773: AND
32774: PUSH
32775: LD_INT 22
32777: PUSH
32778: LD_INT 3
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 34
32787: PUSH
32788: LD_INT 48
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PPUSH
32799: CALL_OW 69
32803: AND
32804: PUSH
32805: LD_INT 22
32807: PUSH
32808: LD_INT 1
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: LD_INT 34
32817: PUSH
32818: LD_INT 8
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PPUSH
32829: CALL_OW 69
32833: NOT
32834: AND
32835: IFFALSE 32887
// begin wait ( 0 0$5 ) ;
32837: LD_INT 175
32839: PPUSH
32840: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32844: LD_INT 22
32846: PUSH
32847: LD_INT 3
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 34
32856: PUSH
32857: LD_INT 48
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PPUSH
32868: CALL_OW 69
32872: PUSH
32873: LD_INT 1
32875: ARRAY
32876: PPUSH
32877: LD_INT 60
32879: PPUSH
32880: LD_INT 95
32882: PPUSH
32883: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32887: LD_VAR 0 2
32891: PPUSH
32892: LD_VAR 0 3
32896: PPUSH
32897: LD_INT 18
32899: PPUSH
32900: CALL_OW 309
32904: IFFALSE 32964
// begin if GetSide ( unit ) = 1 then
32906: LD_VAR 0 1
32910: PPUSH
32911: CALL_OW 255
32915: PUSH
32916: LD_INT 1
32918: EQUAL
32919: IFFALSE 32935
// begin wait ( 0 0$6 ) ;
32921: LD_INT 210
32923: PPUSH
32924: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32928: LD_STRING Motherlode2
32930: PPUSH
32931: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32935: LD_VAR 0 1
32939: PPUSH
32940: CALL_OW 255
32944: PUSH
32945: LD_INT 8
32947: EQUAL
32948: IFFALSE 32964
// begin wait ( 0 0$6 ) ;
32950: LD_INT 210
32952: PPUSH
32953: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32957: LD_STRING Motherlode1
32959: PPUSH
32960: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32964: LD_VAR 0 1
32968: PPUSH
32969: CALL_OW 255
32973: PUSH
32974: LD_INT 3
32976: EQUAL
32977: IFFALSE 32998
// begin wait ( 0 0$5 ) ;
32979: LD_INT 175
32981: PPUSH
32982: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32986: LD_EXP 63
32990: PPUSH
32991: LD_STRING D18-Pla-1
32993: PPUSH
32994: CALL_OW 94
// end ; end ;
32998: PPOPN 3
33000: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33001: LD_VAR 0 1
33005: PUSH
33006: LD_EXP 72
33010: IN
33011: IFFALSE 33031
// begin behemothBuilders := behemothBuilders diff un ;
33013: LD_ADDR_EXP 72
33017: PUSH
33018: LD_EXP 72
33022: PUSH
33023: LD_VAR 0 1
33027: DIFF
33028: ST_TO_ADDR
// exit ;
33029: GO 33129
// end ; if un = JMM then
33031: LD_VAR 0 1
33035: PUSH
33036: LD_EXP 38
33040: EQUAL
33041: IFFALSE 33052
// begin YouLost ( JMM ) ;
33043: LD_STRING JMM
33045: PPUSH
33046: CALL_OW 104
// exit ;
33050: GO 33129
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33052: LD_VAR 0 1
33056: PUSH
33057: LD_INT 22
33059: PUSH
33060: LD_INT 1
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 3
33069: PUSH
33070: LD_INT 25
33072: PUSH
33073: LD_INT 16
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 25
33082: PUSH
33083: LD_INT 12
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: LIST
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PPUSH
33099: CALL_OW 69
33103: IN
33104: IFFALSE 33120
// lostCounter := lostCounter + 1 ;
33106: LD_ADDR_EXP 32
33110: PUSH
33111: LD_EXP 32
33115: PUSH
33116: LD_INT 1
33118: PLUS
33119: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33120: LD_VAR 0 1
33124: PPUSH
33125: CALL 61309 0 1
// end ;
33129: PPOPN 1
33131: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33132: LD_VAR 0 1
33136: PPUSH
33137: LD_VAR 0 2
33141: PPUSH
33142: CALL 63643 0 2
// end ;
33146: PPOPN 2
33148: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33149: LD_VAR 0 1
33153: PPUSH
33154: CALL 62711 0 1
// end ;
33158: PPOPN 1
33160: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33161: LD_VAR 0 1
33165: PUSH
33166: LD_INT 22
33168: PUSH
33169: LD_INT 8
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 30
33178: PUSH
33179: LD_INT 2
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 23
33188: PUSH
33189: LD_INT 3
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: LIST
33200: PPUSH
33201: CALL_OW 69
33205: IN
33206: IFFALSE 33233
// begin ComUpgrade ( building ) ;
33208: LD_VAR 0 1
33212: PPUSH
33213: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33217: LD_EXP 60
33221: PPUSH
33222: LD_VAR 0 1
33226: PPUSH
33227: CALL 74349 0 2
// exit ;
33231: GO 33242
// end ; MCE_BuildingComplete ( building ) ;
33233: LD_VAR 0 1
33237: PPUSH
33238: CALL 62952 0 1
// end ;
33242: PPOPN 1
33244: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33245: LD_VAR 0 1
33249: PPUSH
33250: LD_VAR 0 2
33254: PPUSH
33255: CALL 61005 0 2
// end ;
33259: PPOPN 2
33261: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33262: LD_VAR 0 1
33266: PPUSH
33267: LD_VAR 0 2
33271: PPUSH
33272: LD_VAR 0 3
33276: PPUSH
33277: LD_VAR 0 4
33281: PPUSH
33282: LD_VAR 0 5
33286: PPUSH
33287: CALL 60625 0 5
// end ;
33291: PPOPN 5
33293: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33294: LD_VAR 0 1
33298: PPUSH
33299: LD_VAR 0 2
33303: PPUSH
33304: CALL 60221 0 2
// end ;
33308: PPOPN 2
33310: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33311: LD_VAR 0 1
33315: PPUSH
33316: LD_VAR 0 2
33320: PPUSH
33321: LD_VAR 0 3
33325: PPUSH
33326: LD_VAR 0 4
33330: PPUSH
33331: CALL 60059 0 4
// end ;
33335: PPOPN 4
33337: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33338: LD_VAR 0 1
33342: PPUSH
33343: LD_VAR 0 2
33347: PPUSH
33348: LD_VAR 0 3
33352: PPUSH
33353: CALL 59834 0 3
// end ;
33357: PPOPN 3
33359: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33360: LD_VAR 0 1
33364: PPUSH
33365: LD_VAR 0 2
33369: PPUSH
33370: CALL 59719 0 2
// end ;
33374: PPOPN 2
33376: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33377: LD_VAR 0 1
33381: PPUSH
33382: LD_VAR 0 2
33386: PPUSH
33387: CALL 63904 0 2
// end ;
33391: PPOPN 2
33393: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33394: LD_VAR 0 1
33398: PPUSH
33399: CALL_OW 255
33403: PUSH
33404: LD_INT 4
33406: EQUAL
33407: PUSH
33408: LD_VAR 0 1
33412: PUSH
33413: LD_EXP 18
33417: PUSH
33418: LD_INT 1
33420: ARRAY
33421: IN
33422: AND
33423: PUSH
33424: LD_EXP 19
33428: AND
33429: IFFALSE 33448
// begin ComMoveXY ( driver , 61 , 93 ) ;
33431: LD_VAR 0 1
33435: PPUSH
33436: LD_INT 61
33438: PPUSH
33439: LD_INT 93
33441: PPUSH
33442: CALL_OW 111
// exit ;
33446: GO 33472
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33448: LD_VAR 0 1
33452: PPUSH
33453: LD_VAR 0 2
33457: PPUSH
33458: LD_VAR 0 3
33462: PPUSH
33463: LD_VAR 0 4
33467: PPUSH
33468: CALL 64120 0 4
// end ;
33472: PPOPN 4
33474: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33475: LD_VAR 0 1
33479: PPUSH
33480: LD_VAR 0 2
33484: PPUSH
33485: CALL 59528 0 2
// end ;
33489: PPOPN 2
33491: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33492: LD_VAR 0 1
33496: PPUSH
33497: CALL 107547 0 1
// end ; end_of_file
33501: PPOPN 1
33503: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33504: LD_EXP 15
33508: PUSH
33509: LD_INT 2
33511: EQUAL
33512: IFFALSE 33991
33514: GO 33516
33516: DISABLE
33517: LD_INT 0
33519: PPUSH
// begin time := 0 0$40 ;
33520: LD_ADDR_VAR 0 1
33524: PUSH
33525: LD_INT 1400
33527: ST_TO_ADDR
// repeat wait ( time ) ;
33528: LD_VAR 0 1
33532: PPUSH
33533: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33537: LD_INT 1
33539: PPUSH
33540: LD_INT 5
33542: PPUSH
33543: CALL_OW 12
33547: PPUSH
33548: LD_INT 106
33550: PPUSH
33551: LD_INT 150
33553: PPUSH
33554: LD_INT 19
33556: PPUSH
33557: LD_INT 1
33559: PPUSH
33560: CALL_OW 56
// time := time + 0 0$9 ;
33564: LD_ADDR_VAR 0 1
33568: PUSH
33569: LD_VAR 0 1
33573: PUSH
33574: LD_INT 315
33576: PLUS
33577: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33578: LD_INT 455
33580: PPUSH
33581: LD_INT 840
33583: PPUSH
33584: CALL_OW 12
33588: PPUSH
33589: CALL_OW 67
// if Prob ( 50 ) then
33593: LD_INT 50
33595: PPUSH
33596: CALL_OW 13
33600: IFFALSE 33629
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33602: LD_INT 1
33604: PPUSH
33605: LD_INT 5
33607: PPUSH
33608: CALL_OW 12
33612: PPUSH
33613: LD_INT 62
33615: PPUSH
33616: LD_INT 108
33618: PPUSH
33619: LD_INT 10
33621: PPUSH
33622: LD_INT 1
33624: PPUSH
33625: CALL_OW 56
// until missionStage > 4 ;
33629: LD_EXP 15
33633: PUSH
33634: LD_INT 4
33636: GREATER
33637: IFFALSE 33528
// repeat wait ( 0 0$1 ) ;
33639: LD_INT 35
33641: PPUSH
33642: CALL_OW 67
// until missionStage = 6 ;
33646: LD_EXP 15
33650: PUSH
33651: LD_INT 6
33653: EQUAL
33654: IFFALSE 33639
// time := 0 0$50 ;
33656: LD_ADDR_VAR 0 1
33660: PUSH
33661: LD_INT 1750
33663: ST_TO_ADDR
// repeat wait ( time ) ;
33664: LD_VAR 0 1
33668: PPUSH
33669: CALL_OW 67
// if Prob ( 50 ) then
33673: LD_INT 50
33675: PPUSH
33676: CALL_OW 13
33680: IFFALSE 33709
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33682: LD_INT 1
33684: PPUSH
33685: LD_INT 5
33687: PPUSH
33688: CALL_OW 12
33692: PPUSH
33693: LD_INT 106
33695: PPUSH
33696: LD_INT 89
33698: PPUSH
33699: LD_INT 45
33701: PPUSH
33702: LD_INT 1
33704: PPUSH
33705: CALL_OW 56
// time := time + 0 0$3 ;
33709: LD_ADDR_VAR 0 1
33713: PUSH
33714: LD_VAR 0 1
33718: PUSH
33719: LD_INT 105
33721: PLUS
33722: ST_TO_ADDR
// if Prob ( 30 ) then
33723: LD_INT 30
33725: PPUSH
33726: CALL_OW 13
33730: IFFALSE 33776
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33732: LD_INT 525
33734: PPUSH
33735: LD_INT 735
33737: PPUSH
33738: CALL_OW 12
33742: PPUSH
33743: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33747: LD_INT 1
33749: PPUSH
33750: LD_INT 5
33752: PPUSH
33753: CALL_OW 12
33757: PPUSH
33758: LD_INT 21
33760: PPUSH
33761: LD_INT 26
33763: PPUSH
33764: LD_INT 12
33766: PPUSH
33767: LD_INT 1
33769: PPUSH
33770: CALL_OW 56
// end else
33774: GO 33812
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33776: LD_INT 700
33778: PPUSH
33779: LD_INT 1225
33781: PPUSH
33782: CALL_OW 12
33786: PPUSH
33787: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33791: LD_INT 1
33793: PPUSH
33794: LD_INT 5
33796: PPUSH
33797: CALL_OW 12
33801: PPUSH
33802: LD_INT 16
33804: PPUSH
33805: LD_INT 1
33807: PPUSH
33808: CALL_OW 55
// end ; if Prob ( 50 ) then
33812: LD_INT 50
33814: PPUSH
33815: CALL_OW 13
33819: IFFALSE 33865
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33821: LD_INT 700
33823: PPUSH
33824: LD_INT 1050
33826: PPUSH
33827: CALL_OW 12
33831: PPUSH
33832: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33836: LD_INT 1
33838: PPUSH
33839: LD_INT 5
33841: PPUSH
33842: CALL_OW 12
33846: PPUSH
33847: LD_INT 181
33849: PPUSH
33850: LD_INT 218
33852: PPUSH
33853: LD_INT 16
33855: PPUSH
33856: LD_INT 1
33858: PPUSH
33859: CALL_OW 56
// end else
33863: GO 33901
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33865: LD_INT 350
33867: PPUSH
33868: LD_INT 525
33870: PPUSH
33871: CALL_OW 12
33875: PPUSH
33876: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33880: LD_INT 1
33882: PPUSH
33883: LD_INT 5
33885: PPUSH
33886: CALL_OW 12
33890: PPUSH
33891: LD_INT 15
33893: PPUSH
33894: LD_INT 1
33896: PPUSH
33897: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33901: LD_INT 45
33903: PUSH
33904: LD_INT 32
33906: PUSH
33907: LD_INT 25
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: LIST
33914: PUSH
33915: LD_OWVAR 67
33919: ARRAY
33920: PPUSH
33921: CALL_OW 13
33925: IFFALSE 33969
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33927: LD_INT 525
33929: PPUSH
33930: LD_INT 875
33932: PPUSH
33933: CALL_OW 12
33937: PPUSH
33938: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33942: LD_INT 1
33944: PPUSH
33945: LD_INT 5
33947: PPUSH
33948: CALL_OW 12
33952: PPUSH
33953: LD_INT 103
33955: PPUSH
33956: LD_INT 140
33958: PPUSH
33959: LD_INT 20
33961: PPUSH
33962: LD_INT 1
33964: PPUSH
33965: CALL_OW 56
// end ; if time > 2 2$20 then
33969: LD_VAR 0 1
33973: PUSH
33974: LD_INT 4900
33976: GREATER
33977: IFFALSE 33987
// time := 0 0$50 ;
33979: LD_ADDR_VAR 0 1
33983: PUSH
33984: LD_INT 1750
33986: ST_TO_ADDR
// until false ;
33987: LD_INT 0
33989: IFFALSE 33664
// end ; end_of_file
33991: PPOPN 1
33993: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33994: LD_EXP 13
33998: PUSH
33999: LD_EXP 15
34003: PUSH
34004: LD_INT 6
34006: GREATEREQUAL
34007: AND
34008: IFFALSE 34045
34010: GO 34012
34012: DISABLE
// begin enable ;
34013: ENABLE
// missionTime := missionTime + 0 0$1 ;
34014: LD_ADDR_EXP 14
34018: PUSH
34019: LD_EXP 14
34023: PUSH
34024: LD_INT 35
34026: PLUS
34027: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34028: LD_ADDR_OWVAR 47
34032: PUSH
34033: LD_STRING #Am15-1
34035: PUSH
34036: LD_EXP 14
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: ST_TO_ADDR
// end ; end_of_file
34045: END
// export function InitNature ; begin
34046: LD_INT 0
34048: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34049: LD_INT 3
34051: PPUSH
34052: LD_INT 3
34054: PPUSH
34055: LD_INT 2
34057: PPUSH
34058: LD_INT 1
34060: PPUSH
34061: LD_INT 1
34063: PPUSH
34064: LD_INT 0
34066: PPUSH
34067: LD_INT 0
34069: PPUSH
34070: LD_INT 20
34072: PPUSH
34073: LD_INT 0
34075: PPUSH
34076: CALL 99190 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34080: LD_INT 2
34082: PPUSH
34083: LD_INT 1
34085: PPUSH
34086: LD_INT 1
34088: PPUSH
34089: LD_INT 1
34091: PPUSH
34092: LD_INT 1
34094: PPUSH
34095: LD_INT 0
34097: PPUSH
34098: LD_INT 0
34100: PPUSH
34101: LD_INT 21
34103: PPUSH
34104: LD_INT 0
34106: PPUSH
34107: CALL 99190 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34111: LD_INT 4
34113: PPUSH
34114: LD_INT 1
34116: PPUSH
34117: LD_INT 2
34119: PPUSH
34120: LD_INT 4
34122: PPUSH
34123: LD_INT 2
34125: PPUSH
34126: LD_INT 1
34128: PPUSH
34129: LD_INT 0
34131: PPUSH
34132: LD_INT 22
34134: PPUSH
34135: LD_INT 0
34137: PPUSH
34138: CALL 99190 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34142: LD_INT 0
34144: PPUSH
34145: LD_INT 0
34147: PPUSH
34148: LD_INT 0
34150: PPUSH
34151: LD_INT 0
34153: PPUSH
34154: LD_INT 0
34156: PPUSH
34157: LD_INT 0
34159: PPUSH
34160: LD_INT 9
34162: PPUSH
34163: LD_INT 0
34165: PPUSH
34166: LD_INT 23
34168: PPUSH
34169: CALL 99190 0 9
// end ; end_of_file
34173: LD_VAR 0 1
34177: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34178: GO 34180
34180: DISABLE
// begin ru_radar := 98 ;
34181: LD_ADDR_EXP 94
34185: PUSH
34186: LD_INT 98
34188: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34189: LD_ADDR_EXP 95
34193: PUSH
34194: LD_INT 89
34196: ST_TO_ADDR
// us_hack := 99 ;
34197: LD_ADDR_EXP 96
34201: PUSH
34202: LD_INT 99
34204: ST_TO_ADDR
// us_artillery := 97 ;
34205: LD_ADDR_EXP 97
34209: PUSH
34210: LD_INT 97
34212: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34213: LD_ADDR_EXP 98
34217: PUSH
34218: LD_INT 91
34220: ST_TO_ADDR
// end ; end_of_file
34221: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34222: LD_INT 0
34224: PPUSH
34225: PPUSH
// skirmish := false ;
34226: LD_ADDR_EXP 99
34230: PUSH
34231: LD_INT 0
34233: ST_TO_ADDR
// debug_mc := false ;
34234: LD_ADDR_EXP 100
34238: PUSH
34239: LD_INT 0
34241: ST_TO_ADDR
// mc_bases := [ ] ;
34242: LD_ADDR_EXP 101
34246: PUSH
34247: EMPTY
34248: ST_TO_ADDR
// mc_sides := [ ] ;
34249: LD_ADDR_EXP 127
34253: PUSH
34254: EMPTY
34255: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34256: LD_ADDR_EXP 102
34260: PUSH
34261: EMPTY
34262: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34263: LD_ADDR_EXP 103
34267: PUSH
34268: EMPTY
34269: ST_TO_ADDR
// mc_need_heal := [ ] ;
34270: LD_ADDR_EXP 104
34274: PUSH
34275: EMPTY
34276: ST_TO_ADDR
// mc_healers := [ ] ;
34277: LD_ADDR_EXP 105
34281: PUSH
34282: EMPTY
34283: ST_TO_ADDR
// mc_build_list := [ ] ;
34284: LD_ADDR_EXP 106
34288: PUSH
34289: EMPTY
34290: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34291: LD_ADDR_EXP 133
34295: PUSH
34296: EMPTY
34297: ST_TO_ADDR
// mc_builders := [ ] ;
34298: LD_ADDR_EXP 107
34302: PUSH
34303: EMPTY
34304: ST_TO_ADDR
// mc_construct_list := [ ] ;
34305: LD_ADDR_EXP 108
34309: PUSH
34310: EMPTY
34311: ST_TO_ADDR
// mc_turret_list := [ ] ;
34312: LD_ADDR_EXP 109
34316: PUSH
34317: EMPTY
34318: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34319: LD_ADDR_EXP 110
34323: PUSH
34324: EMPTY
34325: ST_TO_ADDR
// mc_miners := [ ] ;
34326: LD_ADDR_EXP 115
34330: PUSH
34331: EMPTY
34332: ST_TO_ADDR
// mc_mines := [ ] ;
34333: LD_ADDR_EXP 114
34337: PUSH
34338: EMPTY
34339: ST_TO_ADDR
// mc_minefields := [ ] ;
34340: LD_ADDR_EXP 116
34344: PUSH
34345: EMPTY
34346: ST_TO_ADDR
// mc_crates := [ ] ;
34347: LD_ADDR_EXP 117
34351: PUSH
34352: EMPTY
34353: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34354: LD_ADDR_EXP 118
34358: PUSH
34359: EMPTY
34360: ST_TO_ADDR
// mc_crates_area := [ ] ;
34361: LD_ADDR_EXP 119
34365: PUSH
34366: EMPTY
34367: ST_TO_ADDR
// mc_vehicles := [ ] ;
34368: LD_ADDR_EXP 120
34372: PUSH
34373: EMPTY
34374: ST_TO_ADDR
// mc_attack := [ ] ;
34375: LD_ADDR_EXP 121
34379: PUSH
34380: EMPTY
34381: ST_TO_ADDR
// mc_produce := [ ] ;
34382: LD_ADDR_EXP 122
34386: PUSH
34387: EMPTY
34388: ST_TO_ADDR
// mc_defender := [ ] ;
34389: LD_ADDR_EXP 123
34393: PUSH
34394: EMPTY
34395: ST_TO_ADDR
// mc_parking := [ ] ;
34396: LD_ADDR_EXP 125
34400: PUSH
34401: EMPTY
34402: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34403: LD_ADDR_EXP 111
34407: PUSH
34408: EMPTY
34409: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34410: LD_ADDR_EXP 113
34414: PUSH
34415: EMPTY
34416: ST_TO_ADDR
// mc_scan := [ ] ;
34417: LD_ADDR_EXP 124
34421: PUSH
34422: EMPTY
34423: ST_TO_ADDR
// mc_scan_area := [ ] ;
34424: LD_ADDR_EXP 126
34428: PUSH
34429: EMPTY
34430: ST_TO_ADDR
// mc_tech := [ ] ;
34431: LD_ADDR_EXP 128
34435: PUSH
34436: EMPTY
34437: ST_TO_ADDR
// mc_class := [ ] ;
34438: LD_ADDR_EXP 142
34442: PUSH
34443: EMPTY
34444: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34445: LD_ADDR_EXP 143
34449: PUSH
34450: EMPTY
34451: ST_TO_ADDR
// end ;
34452: LD_VAR 0 1
34456: RET
// export function MC_Kill ( base ) ; begin
34457: LD_INT 0
34459: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34460: LD_ADDR_EXP 101
34464: PUSH
34465: LD_EXP 101
34469: PPUSH
34470: LD_VAR 0 1
34474: PPUSH
34475: EMPTY
34476: PPUSH
34477: CALL_OW 1
34481: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34482: LD_ADDR_EXP 102
34486: PUSH
34487: LD_EXP 102
34491: PPUSH
34492: LD_VAR 0 1
34496: PPUSH
34497: EMPTY
34498: PPUSH
34499: CALL_OW 1
34503: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34504: LD_ADDR_EXP 103
34508: PUSH
34509: LD_EXP 103
34513: PPUSH
34514: LD_VAR 0 1
34518: PPUSH
34519: EMPTY
34520: PPUSH
34521: CALL_OW 1
34525: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34526: LD_ADDR_EXP 104
34530: PUSH
34531: LD_EXP 104
34535: PPUSH
34536: LD_VAR 0 1
34540: PPUSH
34541: EMPTY
34542: PPUSH
34543: CALL_OW 1
34547: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34548: LD_ADDR_EXP 105
34552: PUSH
34553: LD_EXP 105
34557: PPUSH
34558: LD_VAR 0 1
34562: PPUSH
34563: EMPTY
34564: PPUSH
34565: CALL_OW 1
34569: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34570: LD_ADDR_EXP 106
34574: PUSH
34575: LD_EXP 106
34579: PPUSH
34580: LD_VAR 0 1
34584: PPUSH
34585: EMPTY
34586: PPUSH
34587: CALL_OW 1
34591: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34592: LD_ADDR_EXP 107
34596: PUSH
34597: LD_EXP 107
34601: PPUSH
34602: LD_VAR 0 1
34606: PPUSH
34607: EMPTY
34608: PPUSH
34609: CALL_OW 1
34613: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34614: LD_ADDR_EXP 108
34618: PUSH
34619: LD_EXP 108
34623: PPUSH
34624: LD_VAR 0 1
34628: PPUSH
34629: EMPTY
34630: PPUSH
34631: CALL_OW 1
34635: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34636: LD_ADDR_EXP 109
34640: PUSH
34641: LD_EXP 109
34645: PPUSH
34646: LD_VAR 0 1
34650: PPUSH
34651: EMPTY
34652: PPUSH
34653: CALL_OW 1
34657: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34658: LD_ADDR_EXP 110
34662: PUSH
34663: LD_EXP 110
34667: PPUSH
34668: LD_VAR 0 1
34672: PPUSH
34673: EMPTY
34674: PPUSH
34675: CALL_OW 1
34679: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34680: LD_ADDR_EXP 111
34684: PUSH
34685: LD_EXP 111
34689: PPUSH
34690: LD_VAR 0 1
34694: PPUSH
34695: EMPTY
34696: PPUSH
34697: CALL_OW 1
34701: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34702: LD_ADDR_EXP 112
34706: PUSH
34707: LD_EXP 112
34711: PPUSH
34712: LD_VAR 0 1
34716: PPUSH
34717: LD_INT 0
34719: PPUSH
34720: CALL_OW 1
34724: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34725: LD_ADDR_EXP 113
34729: PUSH
34730: LD_EXP 113
34734: PPUSH
34735: LD_VAR 0 1
34739: PPUSH
34740: EMPTY
34741: PPUSH
34742: CALL_OW 1
34746: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34747: LD_ADDR_EXP 114
34751: PUSH
34752: LD_EXP 114
34756: PPUSH
34757: LD_VAR 0 1
34761: PPUSH
34762: EMPTY
34763: PPUSH
34764: CALL_OW 1
34768: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34769: LD_ADDR_EXP 115
34773: PUSH
34774: LD_EXP 115
34778: PPUSH
34779: LD_VAR 0 1
34783: PPUSH
34784: EMPTY
34785: PPUSH
34786: CALL_OW 1
34790: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34791: LD_ADDR_EXP 116
34795: PUSH
34796: LD_EXP 116
34800: PPUSH
34801: LD_VAR 0 1
34805: PPUSH
34806: EMPTY
34807: PPUSH
34808: CALL_OW 1
34812: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34813: LD_ADDR_EXP 117
34817: PUSH
34818: LD_EXP 117
34822: PPUSH
34823: LD_VAR 0 1
34827: PPUSH
34828: EMPTY
34829: PPUSH
34830: CALL_OW 1
34834: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34835: LD_ADDR_EXP 118
34839: PUSH
34840: LD_EXP 118
34844: PPUSH
34845: LD_VAR 0 1
34849: PPUSH
34850: EMPTY
34851: PPUSH
34852: CALL_OW 1
34856: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34857: LD_ADDR_EXP 119
34861: PUSH
34862: LD_EXP 119
34866: PPUSH
34867: LD_VAR 0 1
34871: PPUSH
34872: EMPTY
34873: PPUSH
34874: CALL_OW 1
34878: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34879: LD_ADDR_EXP 120
34883: PUSH
34884: LD_EXP 120
34888: PPUSH
34889: LD_VAR 0 1
34893: PPUSH
34894: EMPTY
34895: PPUSH
34896: CALL_OW 1
34900: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34901: LD_ADDR_EXP 121
34905: PUSH
34906: LD_EXP 121
34910: PPUSH
34911: LD_VAR 0 1
34915: PPUSH
34916: EMPTY
34917: PPUSH
34918: CALL_OW 1
34922: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34923: LD_ADDR_EXP 122
34927: PUSH
34928: LD_EXP 122
34932: PPUSH
34933: LD_VAR 0 1
34937: PPUSH
34938: EMPTY
34939: PPUSH
34940: CALL_OW 1
34944: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34945: LD_ADDR_EXP 123
34949: PUSH
34950: LD_EXP 123
34954: PPUSH
34955: LD_VAR 0 1
34959: PPUSH
34960: EMPTY
34961: PPUSH
34962: CALL_OW 1
34966: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34967: LD_ADDR_EXP 124
34971: PUSH
34972: LD_EXP 124
34976: PPUSH
34977: LD_VAR 0 1
34981: PPUSH
34982: EMPTY
34983: PPUSH
34984: CALL_OW 1
34988: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34989: LD_ADDR_EXP 125
34993: PUSH
34994: LD_EXP 125
34998: PPUSH
34999: LD_VAR 0 1
35003: PPUSH
35004: EMPTY
35005: PPUSH
35006: CALL_OW 1
35010: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35011: LD_ADDR_EXP 126
35015: PUSH
35016: LD_EXP 126
35020: PPUSH
35021: LD_VAR 0 1
35025: PPUSH
35026: EMPTY
35027: PPUSH
35028: CALL_OW 1
35032: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35033: LD_ADDR_EXP 128
35037: PUSH
35038: LD_EXP 128
35042: PPUSH
35043: LD_VAR 0 1
35047: PPUSH
35048: EMPTY
35049: PPUSH
35050: CALL_OW 1
35054: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35055: LD_ADDR_EXP 130
35059: PUSH
35060: LD_EXP 130
35064: PPUSH
35065: LD_VAR 0 1
35069: PPUSH
35070: EMPTY
35071: PPUSH
35072: CALL_OW 1
35076: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35077: LD_ADDR_EXP 131
35081: PUSH
35082: LD_EXP 131
35086: PPUSH
35087: LD_VAR 0 1
35091: PPUSH
35092: EMPTY
35093: PPUSH
35094: CALL_OW 1
35098: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35099: LD_ADDR_EXP 132
35103: PUSH
35104: LD_EXP 132
35108: PPUSH
35109: LD_VAR 0 1
35113: PPUSH
35114: EMPTY
35115: PPUSH
35116: CALL_OW 1
35120: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35121: LD_ADDR_EXP 133
35125: PUSH
35126: LD_EXP 133
35130: PPUSH
35131: LD_VAR 0 1
35135: PPUSH
35136: EMPTY
35137: PPUSH
35138: CALL_OW 1
35142: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35143: LD_ADDR_EXP 134
35147: PUSH
35148: LD_EXP 134
35152: PPUSH
35153: LD_VAR 0 1
35157: PPUSH
35158: EMPTY
35159: PPUSH
35160: CALL_OW 1
35164: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35165: LD_ADDR_EXP 135
35169: PUSH
35170: LD_EXP 135
35174: PPUSH
35175: LD_VAR 0 1
35179: PPUSH
35180: EMPTY
35181: PPUSH
35182: CALL_OW 1
35186: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35187: LD_ADDR_EXP 136
35191: PUSH
35192: LD_EXP 136
35196: PPUSH
35197: LD_VAR 0 1
35201: PPUSH
35202: EMPTY
35203: PPUSH
35204: CALL_OW 1
35208: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35209: LD_ADDR_EXP 137
35213: PUSH
35214: LD_EXP 137
35218: PPUSH
35219: LD_VAR 0 1
35223: PPUSH
35224: EMPTY
35225: PPUSH
35226: CALL_OW 1
35230: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35231: LD_ADDR_EXP 138
35235: PUSH
35236: LD_EXP 138
35240: PPUSH
35241: LD_VAR 0 1
35245: PPUSH
35246: EMPTY
35247: PPUSH
35248: CALL_OW 1
35252: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35253: LD_ADDR_EXP 139
35257: PUSH
35258: LD_EXP 139
35262: PPUSH
35263: LD_VAR 0 1
35267: PPUSH
35268: EMPTY
35269: PPUSH
35270: CALL_OW 1
35274: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35275: LD_ADDR_EXP 140
35279: PUSH
35280: LD_EXP 140
35284: PPUSH
35285: LD_VAR 0 1
35289: PPUSH
35290: EMPTY
35291: PPUSH
35292: CALL_OW 1
35296: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35297: LD_ADDR_EXP 141
35301: PUSH
35302: LD_EXP 141
35306: PPUSH
35307: LD_VAR 0 1
35311: PPUSH
35312: EMPTY
35313: PPUSH
35314: CALL_OW 1
35318: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35319: LD_ADDR_EXP 142
35323: PUSH
35324: LD_EXP 142
35328: PPUSH
35329: LD_VAR 0 1
35333: PPUSH
35334: EMPTY
35335: PPUSH
35336: CALL_OW 1
35340: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35341: LD_ADDR_EXP 143
35345: PUSH
35346: LD_EXP 143
35350: PPUSH
35351: LD_VAR 0 1
35355: PPUSH
35356: LD_INT 0
35358: PPUSH
35359: CALL_OW 1
35363: ST_TO_ADDR
// end ;
35364: LD_VAR 0 2
35368: RET
// export function MC_Add ( side , units ) ; var base ; begin
35369: LD_INT 0
35371: PPUSH
35372: PPUSH
// base := mc_bases + 1 ;
35373: LD_ADDR_VAR 0 4
35377: PUSH
35378: LD_EXP 101
35382: PUSH
35383: LD_INT 1
35385: PLUS
35386: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35387: LD_ADDR_EXP 127
35391: PUSH
35392: LD_EXP 127
35396: PPUSH
35397: LD_VAR 0 4
35401: PPUSH
35402: LD_VAR 0 1
35406: PPUSH
35407: CALL_OW 1
35411: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35412: LD_ADDR_EXP 101
35416: PUSH
35417: LD_EXP 101
35421: PPUSH
35422: LD_VAR 0 4
35426: PPUSH
35427: LD_VAR 0 2
35431: PPUSH
35432: CALL_OW 1
35436: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35437: LD_ADDR_EXP 102
35441: PUSH
35442: LD_EXP 102
35446: PPUSH
35447: LD_VAR 0 4
35451: PPUSH
35452: EMPTY
35453: PPUSH
35454: CALL_OW 1
35458: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35459: LD_ADDR_EXP 103
35463: PUSH
35464: LD_EXP 103
35468: PPUSH
35469: LD_VAR 0 4
35473: PPUSH
35474: EMPTY
35475: PPUSH
35476: CALL_OW 1
35480: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35481: LD_ADDR_EXP 104
35485: PUSH
35486: LD_EXP 104
35490: PPUSH
35491: LD_VAR 0 4
35495: PPUSH
35496: EMPTY
35497: PPUSH
35498: CALL_OW 1
35502: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35503: LD_ADDR_EXP 105
35507: PUSH
35508: LD_EXP 105
35512: PPUSH
35513: LD_VAR 0 4
35517: PPUSH
35518: EMPTY
35519: PPUSH
35520: CALL_OW 1
35524: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35525: LD_ADDR_EXP 106
35529: PUSH
35530: LD_EXP 106
35534: PPUSH
35535: LD_VAR 0 4
35539: PPUSH
35540: EMPTY
35541: PPUSH
35542: CALL_OW 1
35546: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35547: LD_ADDR_EXP 107
35551: PUSH
35552: LD_EXP 107
35556: PPUSH
35557: LD_VAR 0 4
35561: PPUSH
35562: EMPTY
35563: PPUSH
35564: CALL_OW 1
35568: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35569: LD_ADDR_EXP 108
35573: PUSH
35574: LD_EXP 108
35578: PPUSH
35579: LD_VAR 0 4
35583: PPUSH
35584: EMPTY
35585: PPUSH
35586: CALL_OW 1
35590: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35591: LD_ADDR_EXP 109
35595: PUSH
35596: LD_EXP 109
35600: PPUSH
35601: LD_VAR 0 4
35605: PPUSH
35606: EMPTY
35607: PPUSH
35608: CALL_OW 1
35612: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35613: LD_ADDR_EXP 110
35617: PUSH
35618: LD_EXP 110
35622: PPUSH
35623: LD_VAR 0 4
35627: PPUSH
35628: EMPTY
35629: PPUSH
35630: CALL_OW 1
35634: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35635: LD_ADDR_EXP 111
35639: PUSH
35640: LD_EXP 111
35644: PPUSH
35645: LD_VAR 0 4
35649: PPUSH
35650: EMPTY
35651: PPUSH
35652: CALL_OW 1
35656: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35657: LD_ADDR_EXP 112
35661: PUSH
35662: LD_EXP 112
35666: PPUSH
35667: LD_VAR 0 4
35671: PPUSH
35672: LD_INT 0
35674: PPUSH
35675: CALL_OW 1
35679: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35680: LD_ADDR_EXP 113
35684: PUSH
35685: LD_EXP 113
35689: PPUSH
35690: LD_VAR 0 4
35694: PPUSH
35695: EMPTY
35696: PPUSH
35697: CALL_OW 1
35701: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35702: LD_ADDR_EXP 114
35706: PUSH
35707: LD_EXP 114
35711: PPUSH
35712: LD_VAR 0 4
35716: PPUSH
35717: EMPTY
35718: PPUSH
35719: CALL_OW 1
35723: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35724: LD_ADDR_EXP 115
35728: PUSH
35729: LD_EXP 115
35733: PPUSH
35734: LD_VAR 0 4
35738: PPUSH
35739: EMPTY
35740: PPUSH
35741: CALL_OW 1
35745: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35746: LD_ADDR_EXP 116
35750: PUSH
35751: LD_EXP 116
35755: PPUSH
35756: LD_VAR 0 4
35760: PPUSH
35761: EMPTY
35762: PPUSH
35763: CALL_OW 1
35767: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35768: LD_ADDR_EXP 117
35772: PUSH
35773: LD_EXP 117
35777: PPUSH
35778: LD_VAR 0 4
35782: PPUSH
35783: EMPTY
35784: PPUSH
35785: CALL_OW 1
35789: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35790: LD_ADDR_EXP 118
35794: PUSH
35795: LD_EXP 118
35799: PPUSH
35800: LD_VAR 0 4
35804: PPUSH
35805: EMPTY
35806: PPUSH
35807: CALL_OW 1
35811: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35812: LD_ADDR_EXP 119
35816: PUSH
35817: LD_EXP 119
35821: PPUSH
35822: LD_VAR 0 4
35826: PPUSH
35827: EMPTY
35828: PPUSH
35829: CALL_OW 1
35833: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35834: LD_ADDR_EXP 120
35838: PUSH
35839: LD_EXP 120
35843: PPUSH
35844: LD_VAR 0 4
35848: PPUSH
35849: EMPTY
35850: PPUSH
35851: CALL_OW 1
35855: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35856: LD_ADDR_EXP 121
35860: PUSH
35861: LD_EXP 121
35865: PPUSH
35866: LD_VAR 0 4
35870: PPUSH
35871: EMPTY
35872: PPUSH
35873: CALL_OW 1
35877: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35878: LD_ADDR_EXP 122
35882: PUSH
35883: LD_EXP 122
35887: PPUSH
35888: LD_VAR 0 4
35892: PPUSH
35893: EMPTY
35894: PPUSH
35895: CALL_OW 1
35899: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35900: LD_ADDR_EXP 123
35904: PUSH
35905: LD_EXP 123
35909: PPUSH
35910: LD_VAR 0 4
35914: PPUSH
35915: EMPTY
35916: PPUSH
35917: CALL_OW 1
35921: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35922: LD_ADDR_EXP 124
35926: PUSH
35927: LD_EXP 124
35931: PPUSH
35932: LD_VAR 0 4
35936: PPUSH
35937: EMPTY
35938: PPUSH
35939: CALL_OW 1
35943: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35944: LD_ADDR_EXP 125
35948: PUSH
35949: LD_EXP 125
35953: PPUSH
35954: LD_VAR 0 4
35958: PPUSH
35959: EMPTY
35960: PPUSH
35961: CALL_OW 1
35965: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35966: LD_ADDR_EXP 126
35970: PUSH
35971: LD_EXP 126
35975: PPUSH
35976: LD_VAR 0 4
35980: PPUSH
35981: EMPTY
35982: PPUSH
35983: CALL_OW 1
35987: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35988: LD_ADDR_EXP 128
35992: PUSH
35993: LD_EXP 128
35997: PPUSH
35998: LD_VAR 0 4
36002: PPUSH
36003: EMPTY
36004: PPUSH
36005: CALL_OW 1
36009: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36010: LD_ADDR_EXP 130
36014: PUSH
36015: LD_EXP 130
36019: PPUSH
36020: LD_VAR 0 4
36024: PPUSH
36025: EMPTY
36026: PPUSH
36027: CALL_OW 1
36031: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36032: LD_ADDR_EXP 131
36036: PUSH
36037: LD_EXP 131
36041: PPUSH
36042: LD_VAR 0 4
36046: PPUSH
36047: EMPTY
36048: PPUSH
36049: CALL_OW 1
36053: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36054: LD_ADDR_EXP 132
36058: PUSH
36059: LD_EXP 132
36063: PPUSH
36064: LD_VAR 0 4
36068: PPUSH
36069: EMPTY
36070: PPUSH
36071: CALL_OW 1
36075: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36076: LD_ADDR_EXP 133
36080: PUSH
36081: LD_EXP 133
36085: PPUSH
36086: LD_VAR 0 4
36090: PPUSH
36091: EMPTY
36092: PPUSH
36093: CALL_OW 1
36097: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36098: LD_ADDR_EXP 134
36102: PUSH
36103: LD_EXP 134
36107: PPUSH
36108: LD_VAR 0 4
36112: PPUSH
36113: EMPTY
36114: PPUSH
36115: CALL_OW 1
36119: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36120: LD_ADDR_EXP 135
36124: PUSH
36125: LD_EXP 135
36129: PPUSH
36130: LD_VAR 0 4
36134: PPUSH
36135: EMPTY
36136: PPUSH
36137: CALL_OW 1
36141: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36142: LD_ADDR_EXP 136
36146: PUSH
36147: LD_EXP 136
36151: PPUSH
36152: LD_VAR 0 4
36156: PPUSH
36157: EMPTY
36158: PPUSH
36159: CALL_OW 1
36163: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36164: LD_ADDR_EXP 137
36168: PUSH
36169: LD_EXP 137
36173: PPUSH
36174: LD_VAR 0 4
36178: PPUSH
36179: EMPTY
36180: PPUSH
36181: CALL_OW 1
36185: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36186: LD_ADDR_EXP 138
36190: PUSH
36191: LD_EXP 138
36195: PPUSH
36196: LD_VAR 0 4
36200: PPUSH
36201: EMPTY
36202: PPUSH
36203: CALL_OW 1
36207: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36208: LD_ADDR_EXP 139
36212: PUSH
36213: LD_EXP 139
36217: PPUSH
36218: LD_VAR 0 4
36222: PPUSH
36223: EMPTY
36224: PPUSH
36225: CALL_OW 1
36229: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36230: LD_ADDR_EXP 140
36234: PUSH
36235: LD_EXP 140
36239: PPUSH
36240: LD_VAR 0 4
36244: PPUSH
36245: EMPTY
36246: PPUSH
36247: CALL_OW 1
36251: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36252: LD_ADDR_EXP 141
36256: PUSH
36257: LD_EXP 141
36261: PPUSH
36262: LD_VAR 0 4
36266: PPUSH
36267: EMPTY
36268: PPUSH
36269: CALL_OW 1
36273: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36274: LD_ADDR_EXP 142
36278: PUSH
36279: LD_EXP 142
36283: PPUSH
36284: LD_VAR 0 4
36288: PPUSH
36289: EMPTY
36290: PPUSH
36291: CALL_OW 1
36295: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36296: LD_ADDR_EXP 143
36300: PUSH
36301: LD_EXP 143
36305: PPUSH
36306: LD_VAR 0 4
36310: PPUSH
36311: LD_INT 0
36313: PPUSH
36314: CALL_OW 1
36318: ST_TO_ADDR
// result := base ;
36319: LD_ADDR_VAR 0 3
36323: PUSH
36324: LD_VAR 0 4
36328: ST_TO_ADDR
// end ;
36329: LD_VAR 0 3
36333: RET
// export function MC_Start ( ) ; var i ; begin
36334: LD_INT 0
36336: PPUSH
36337: PPUSH
// for i = 1 to mc_bases do
36338: LD_ADDR_VAR 0 2
36342: PUSH
36343: DOUBLE
36344: LD_INT 1
36346: DEC
36347: ST_TO_ADDR
36348: LD_EXP 101
36352: PUSH
36353: FOR_TO
36354: IFFALSE 37431
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36356: LD_ADDR_EXP 101
36360: PUSH
36361: LD_EXP 101
36365: PPUSH
36366: LD_VAR 0 2
36370: PPUSH
36371: LD_EXP 101
36375: PUSH
36376: LD_VAR 0 2
36380: ARRAY
36381: PUSH
36382: LD_INT 0
36384: DIFF
36385: PPUSH
36386: CALL_OW 1
36390: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36391: LD_ADDR_EXP 102
36395: PUSH
36396: LD_EXP 102
36400: PPUSH
36401: LD_VAR 0 2
36405: PPUSH
36406: EMPTY
36407: PPUSH
36408: CALL_OW 1
36412: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36413: LD_ADDR_EXP 103
36417: PUSH
36418: LD_EXP 103
36422: PPUSH
36423: LD_VAR 0 2
36427: PPUSH
36428: EMPTY
36429: PPUSH
36430: CALL_OW 1
36434: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36435: LD_ADDR_EXP 104
36439: PUSH
36440: LD_EXP 104
36444: PPUSH
36445: LD_VAR 0 2
36449: PPUSH
36450: EMPTY
36451: PPUSH
36452: CALL_OW 1
36456: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36457: LD_ADDR_EXP 105
36461: PUSH
36462: LD_EXP 105
36466: PPUSH
36467: LD_VAR 0 2
36471: PPUSH
36472: EMPTY
36473: PUSH
36474: EMPTY
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PPUSH
36480: CALL_OW 1
36484: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36485: LD_ADDR_EXP 106
36489: PUSH
36490: LD_EXP 106
36494: PPUSH
36495: LD_VAR 0 2
36499: PPUSH
36500: EMPTY
36501: PPUSH
36502: CALL_OW 1
36506: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36507: LD_ADDR_EXP 133
36511: PUSH
36512: LD_EXP 133
36516: PPUSH
36517: LD_VAR 0 2
36521: PPUSH
36522: EMPTY
36523: PPUSH
36524: CALL_OW 1
36528: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36529: LD_ADDR_EXP 107
36533: PUSH
36534: LD_EXP 107
36538: PPUSH
36539: LD_VAR 0 2
36543: PPUSH
36544: EMPTY
36545: PPUSH
36546: CALL_OW 1
36550: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36551: LD_ADDR_EXP 108
36555: PUSH
36556: LD_EXP 108
36560: PPUSH
36561: LD_VAR 0 2
36565: PPUSH
36566: EMPTY
36567: PPUSH
36568: CALL_OW 1
36572: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36573: LD_ADDR_EXP 109
36577: PUSH
36578: LD_EXP 109
36582: PPUSH
36583: LD_VAR 0 2
36587: PPUSH
36588: LD_EXP 101
36592: PUSH
36593: LD_VAR 0 2
36597: ARRAY
36598: PPUSH
36599: LD_INT 2
36601: PUSH
36602: LD_INT 30
36604: PUSH
36605: LD_INT 32
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 30
36614: PUSH
36615: LD_INT 33
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: LIST
36626: PPUSH
36627: CALL_OW 72
36631: PPUSH
36632: CALL_OW 1
36636: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36637: LD_ADDR_EXP 110
36641: PUSH
36642: LD_EXP 110
36646: PPUSH
36647: LD_VAR 0 2
36651: PPUSH
36652: LD_EXP 101
36656: PUSH
36657: LD_VAR 0 2
36661: ARRAY
36662: PPUSH
36663: LD_INT 2
36665: PUSH
36666: LD_INT 30
36668: PUSH
36669: LD_INT 32
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 30
36678: PUSH
36679: LD_INT 31
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: EMPTY
36687: LIST
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 58
36693: PUSH
36694: EMPTY
36695: LIST
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PPUSH
36701: CALL_OW 72
36705: PPUSH
36706: CALL_OW 1
36710: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36711: LD_ADDR_EXP 111
36715: PUSH
36716: LD_EXP 111
36720: PPUSH
36721: LD_VAR 0 2
36725: PPUSH
36726: EMPTY
36727: PPUSH
36728: CALL_OW 1
36732: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36733: LD_ADDR_EXP 115
36737: PUSH
36738: LD_EXP 115
36742: PPUSH
36743: LD_VAR 0 2
36747: PPUSH
36748: EMPTY
36749: PPUSH
36750: CALL_OW 1
36754: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36755: LD_ADDR_EXP 114
36759: PUSH
36760: LD_EXP 114
36764: PPUSH
36765: LD_VAR 0 2
36769: PPUSH
36770: EMPTY
36771: PPUSH
36772: CALL_OW 1
36776: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36777: LD_ADDR_EXP 116
36781: PUSH
36782: LD_EXP 116
36786: PPUSH
36787: LD_VAR 0 2
36791: PPUSH
36792: EMPTY
36793: PPUSH
36794: CALL_OW 1
36798: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36799: LD_ADDR_EXP 117
36803: PUSH
36804: LD_EXP 117
36808: PPUSH
36809: LD_VAR 0 2
36813: PPUSH
36814: EMPTY
36815: PPUSH
36816: CALL_OW 1
36820: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36821: LD_ADDR_EXP 118
36825: PUSH
36826: LD_EXP 118
36830: PPUSH
36831: LD_VAR 0 2
36835: PPUSH
36836: EMPTY
36837: PPUSH
36838: CALL_OW 1
36842: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36843: LD_ADDR_EXP 119
36847: PUSH
36848: LD_EXP 119
36852: PPUSH
36853: LD_VAR 0 2
36857: PPUSH
36858: EMPTY
36859: PPUSH
36860: CALL_OW 1
36864: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36865: LD_ADDR_EXP 120
36869: PUSH
36870: LD_EXP 120
36874: PPUSH
36875: LD_VAR 0 2
36879: PPUSH
36880: EMPTY
36881: PPUSH
36882: CALL_OW 1
36886: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36887: LD_ADDR_EXP 121
36891: PUSH
36892: LD_EXP 121
36896: PPUSH
36897: LD_VAR 0 2
36901: PPUSH
36902: EMPTY
36903: PPUSH
36904: CALL_OW 1
36908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36909: LD_ADDR_EXP 122
36913: PUSH
36914: LD_EXP 122
36918: PPUSH
36919: LD_VAR 0 2
36923: PPUSH
36924: EMPTY
36925: PPUSH
36926: CALL_OW 1
36930: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36931: LD_ADDR_EXP 123
36935: PUSH
36936: LD_EXP 123
36940: PPUSH
36941: LD_VAR 0 2
36945: PPUSH
36946: EMPTY
36947: PPUSH
36948: CALL_OW 1
36952: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36953: LD_ADDR_EXP 112
36957: PUSH
36958: LD_EXP 112
36962: PPUSH
36963: LD_VAR 0 2
36967: PPUSH
36968: LD_INT 0
36970: PPUSH
36971: CALL_OW 1
36975: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36976: LD_ADDR_EXP 125
36980: PUSH
36981: LD_EXP 125
36985: PPUSH
36986: LD_VAR 0 2
36990: PPUSH
36991: LD_INT 0
36993: PPUSH
36994: CALL_OW 1
36998: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36999: LD_ADDR_EXP 113
37003: PUSH
37004: LD_EXP 113
37008: PPUSH
37009: LD_VAR 0 2
37013: PPUSH
37014: EMPTY
37015: PPUSH
37016: CALL_OW 1
37020: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37021: LD_ADDR_EXP 124
37025: PUSH
37026: LD_EXP 124
37030: PPUSH
37031: LD_VAR 0 2
37035: PPUSH
37036: LD_INT 0
37038: PPUSH
37039: CALL_OW 1
37043: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37044: LD_ADDR_EXP 126
37048: PUSH
37049: LD_EXP 126
37053: PPUSH
37054: LD_VAR 0 2
37058: PPUSH
37059: EMPTY
37060: PPUSH
37061: CALL_OW 1
37065: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37066: LD_ADDR_EXP 129
37070: PUSH
37071: LD_EXP 129
37075: PPUSH
37076: LD_VAR 0 2
37080: PPUSH
37081: LD_INT 0
37083: PPUSH
37084: CALL_OW 1
37088: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37089: LD_ADDR_EXP 130
37093: PUSH
37094: LD_EXP 130
37098: PPUSH
37099: LD_VAR 0 2
37103: PPUSH
37104: EMPTY
37105: PPUSH
37106: CALL_OW 1
37110: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37111: LD_ADDR_EXP 131
37115: PUSH
37116: LD_EXP 131
37120: PPUSH
37121: LD_VAR 0 2
37125: PPUSH
37126: EMPTY
37127: PPUSH
37128: CALL_OW 1
37132: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37133: LD_ADDR_EXP 132
37137: PUSH
37138: LD_EXP 132
37142: PPUSH
37143: LD_VAR 0 2
37147: PPUSH
37148: EMPTY
37149: PPUSH
37150: CALL_OW 1
37154: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37155: LD_ADDR_EXP 134
37159: PUSH
37160: LD_EXP 134
37164: PPUSH
37165: LD_VAR 0 2
37169: PPUSH
37170: LD_EXP 101
37174: PUSH
37175: LD_VAR 0 2
37179: ARRAY
37180: PPUSH
37181: LD_INT 2
37183: PUSH
37184: LD_INT 30
37186: PUSH
37187: LD_INT 6
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 30
37196: PUSH
37197: LD_INT 7
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 30
37206: PUSH
37207: LD_INT 8
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: LIST
37218: LIST
37219: PPUSH
37220: CALL_OW 72
37224: PPUSH
37225: CALL_OW 1
37229: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37230: LD_ADDR_EXP 135
37234: PUSH
37235: LD_EXP 135
37239: PPUSH
37240: LD_VAR 0 2
37244: PPUSH
37245: EMPTY
37246: PPUSH
37247: CALL_OW 1
37251: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37252: LD_ADDR_EXP 136
37256: PUSH
37257: LD_EXP 136
37261: PPUSH
37262: LD_VAR 0 2
37266: PPUSH
37267: EMPTY
37268: PPUSH
37269: CALL_OW 1
37273: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37274: LD_ADDR_EXP 137
37278: PUSH
37279: LD_EXP 137
37283: PPUSH
37284: LD_VAR 0 2
37288: PPUSH
37289: EMPTY
37290: PPUSH
37291: CALL_OW 1
37295: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37296: LD_ADDR_EXP 138
37300: PUSH
37301: LD_EXP 138
37305: PPUSH
37306: LD_VAR 0 2
37310: PPUSH
37311: EMPTY
37312: PPUSH
37313: CALL_OW 1
37317: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37318: LD_ADDR_EXP 139
37322: PUSH
37323: LD_EXP 139
37327: PPUSH
37328: LD_VAR 0 2
37332: PPUSH
37333: EMPTY
37334: PPUSH
37335: CALL_OW 1
37339: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37340: LD_ADDR_EXP 140
37344: PUSH
37345: LD_EXP 140
37349: PPUSH
37350: LD_VAR 0 2
37354: PPUSH
37355: EMPTY
37356: PPUSH
37357: CALL_OW 1
37361: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37362: LD_ADDR_EXP 141
37366: PUSH
37367: LD_EXP 141
37371: PPUSH
37372: LD_VAR 0 2
37376: PPUSH
37377: EMPTY
37378: PPUSH
37379: CALL_OW 1
37383: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37384: LD_ADDR_EXP 142
37388: PUSH
37389: LD_EXP 142
37393: PPUSH
37394: LD_VAR 0 2
37398: PPUSH
37399: EMPTY
37400: PPUSH
37401: CALL_OW 1
37405: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37406: LD_ADDR_EXP 143
37410: PUSH
37411: LD_EXP 143
37415: PPUSH
37416: LD_VAR 0 2
37420: PPUSH
37421: LD_INT 0
37423: PPUSH
37424: CALL_OW 1
37428: ST_TO_ADDR
// end ;
37429: GO 36353
37431: POP
37432: POP
// MC_InitSides ( ) ;
37433: CALL 37719 0 0
// MC_InitResearch ( ) ;
37437: CALL 37458 0 0
// CustomInitMacro ( ) ;
37441: CALL 460 0 0
// skirmish := true ;
37445: LD_ADDR_EXP 99
37449: PUSH
37450: LD_INT 1
37452: ST_TO_ADDR
// end ;
37453: LD_VAR 0 1
37457: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37458: LD_INT 0
37460: PPUSH
37461: PPUSH
37462: PPUSH
37463: PPUSH
37464: PPUSH
37465: PPUSH
// if not mc_bases then
37466: LD_EXP 101
37470: NOT
37471: IFFALSE 37475
// exit ;
37473: GO 37714
// for i = 1 to 8 do
37475: LD_ADDR_VAR 0 2
37479: PUSH
37480: DOUBLE
37481: LD_INT 1
37483: DEC
37484: ST_TO_ADDR
37485: LD_INT 8
37487: PUSH
37488: FOR_TO
37489: IFFALSE 37515
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37491: LD_ADDR_EXP 128
37495: PUSH
37496: LD_EXP 128
37500: PPUSH
37501: LD_VAR 0 2
37505: PPUSH
37506: EMPTY
37507: PPUSH
37508: CALL_OW 1
37512: ST_TO_ADDR
37513: GO 37488
37515: POP
37516: POP
// tmp := [ ] ;
37517: LD_ADDR_VAR 0 5
37521: PUSH
37522: EMPTY
37523: ST_TO_ADDR
// for i = 1 to mc_sides do
37524: LD_ADDR_VAR 0 2
37528: PUSH
37529: DOUBLE
37530: LD_INT 1
37532: DEC
37533: ST_TO_ADDR
37534: LD_EXP 127
37538: PUSH
37539: FOR_TO
37540: IFFALSE 37598
// if not mc_sides [ i ] in tmp then
37542: LD_EXP 127
37546: PUSH
37547: LD_VAR 0 2
37551: ARRAY
37552: PUSH
37553: LD_VAR 0 5
37557: IN
37558: NOT
37559: IFFALSE 37596
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37561: LD_ADDR_VAR 0 5
37565: PUSH
37566: LD_VAR 0 5
37570: PPUSH
37571: LD_VAR 0 5
37575: PUSH
37576: LD_INT 1
37578: PLUS
37579: PPUSH
37580: LD_EXP 127
37584: PUSH
37585: LD_VAR 0 2
37589: ARRAY
37590: PPUSH
37591: CALL_OW 2
37595: ST_TO_ADDR
37596: GO 37539
37598: POP
37599: POP
// if not tmp then
37600: LD_VAR 0 5
37604: NOT
37605: IFFALSE 37609
// exit ;
37607: GO 37714
// for j in tmp do
37609: LD_ADDR_VAR 0 3
37613: PUSH
37614: LD_VAR 0 5
37618: PUSH
37619: FOR_IN
37620: IFFALSE 37712
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37622: LD_ADDR_VAR 0 6
37626: PUSH
37627: LD_INT 22
37629: PUSH
37630: LD_VAR 0 3
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PPUSH
37639: CALL_OW 69
37643: ST_TO_ADDR
// if not un then
37644: LD_VAR 0 6
37648: NOT
37649: IFFALSE 37653
// continue ;
37651: GO 37619
// nation := GetNation ( un [ 1 ] ) ;
37653: LD_ADDR_VAR 0 4
37657: PUSH
37658: LD_VAR 0 6
37662: PUSH
37663: LD_INT 1
37665: ARRAY
37666: PPUSH
37667: CALL_OW 248
37671: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37672: LD_ADDR_EXP 128
37676: PUSH
37677: LD_EXP 128
37681: PPUSH
37682: LD_VAR 0 3
37686: PPUSH
37687: LD_VAR 0 3
37691: PPUSH
37692: LD_VAR 0 4
37696: PPUSH
37697: LD_INT 1
37699: PPUSH
37700: CALL 64324 0 3
37704: PPUSH
37705: CALL_OW 1
37709: ST_TO_ADDR
// end ;
37710: GO 37619
37712: POP
37713: POP
// end ;
37714: LD_VAR 0 1
37718: RET
// export function MC_InitSides ( ) ; var i ; begin
37719: LD_INT 0
37721: PPUSH
37722: PPUSH
// if not mc_bases then
37723: LD_EXP 101
37727: NOT
37728: IFFALSE 37732
// exit ;
37730: GO 37806
// for i = 1 to mc_bases do
37732: LD_ADDR_VAR 0 2
37736: PUSH
37737: DOUBLE
37738: LD_INT 1
37740: DEC
37741: ST_TO_ADDR
37742: LD_EXP 101
37746: PUSH
37747: FOR_TO
37748: IFFALSE 37804
// if mc_bases [ i ] then
37750: LD_EXP 101
37754: PUSH
37755: LD_VAR 0 2
37759: ARRAY
37760: IFFALSE 37802
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37762: LD_ADDR_EXP 127
37766: PUSH
37767: LD_EXP 127
37771: PPUSH
37772: LD_VAR 0 2
37776: PPUSH
37777: LD_EXP 101
37781: PUSH
37782: LD_VAR 0 2
37786: ARRAY
37787: PUSH
37788: LD_INT 1
37790: ARRAY
37791: PPUSH
37792: CALL_OW 255
37796: PPUSH
37797: CALL_OW 1
37801: ST_TO_ADDR
37802: GO 37747
37804: POP
37805: POP
// end ;
37806: LD_VAR 0 1
37810: RET
// every 0 0$01 trigger skirmish do
37811: LD_EXP 99
37815: IFFALSE 37969
37817: GO 37819
37819: DISABLE
// begin enable ;
37820: ENABLE
// MC_CheckBuildings ( ) ;
37821: CALL 42467 0 0
// MC_CheckPeopleLife ( ) ;
37825: CALL 42592 0 0
// RaiseSailEvent ( 100 ) ;
37829: LD_INT 100
37831: PPUSH
37832: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37836: LD_INT 103
37838: PPUSH
37839: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37843: LD_INT 104
37845: PPUSH
37846: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37850: LD_INT 105
37852: PPUSH
37853: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37857: LD_INT 106
37859: PPUSH
37860: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37864: LD_INT 107
37866: PPUSH
37867: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37871: LD_INT 108
37873: PPUSH
37874: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37878: LD_INT 109
37880: PPUSH
37881: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37885: LD_INT 110
37887: PPUSH
37888: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37892: LD_INT 111
37894: PPUSH
37895: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37899: LD_INT 112
37901: PPUSH
37902: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37906: LD_INT 113
37908: PPUSH
37909: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37913: LD_INT 120
37915: PPUSH
37916: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37920: LD_INT 121
37922: PPUSH
37923: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37927: LD_INT 122
37929: PPUSH
37930: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37934: LD_INT 123
37936: PPUSH
37937: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37941: LD_INT 124
37943: PPUSH
37944: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37948: LD_INT 125
37950: PPUSH
37951: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37955: LD_INT 126
37957: PPUSH
37958: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37962: LD_INT 200
37964: PPUSH
37965: CALL_OW 427
// end ;
37969: END
// on SailEvent ( event ) do begin if event < 100 then
37970: LD_VAR 0 1
37974: PUSH
37975: LD_INT 100
37977: LESS
37978: IFFALSE 37989
// CustomEvent ( event ) ;
37980: LD_VAR 0 1
37984: PPUSH
37985: CALL 32629 0 1
// if event = 100 then
37989: LD_VAR 0 1
37993: PUSH
37994: LD_INT 100
37996: EQUAL
37997: IFFALSE 38003
// MC_ClassManager ( ) ;
37999: CALL 38395 0 0
// if event = 101 then
38003: LD_VAR 0 1
38007: PUSH
38008: LD_INT 101
38010: EQUAL
38011: IFFALSE 38017
// MC_RepairBuildings ( ) ;
38013: CALL 43188 0 0
// if event = 102 then
38017: LD_VAR 0 1
38021: PUSH
38022: LD_INT 102
38024: EQUAL
38025: IFFALSE 38031
// MC_Heal ( ) ;
38027: CALL 44052 0 0
// if event = 103 then
38031: LD_VAR 0 1
38035: PUSH
38036: LD_INT 103
38038: EQUAL
38039: IFFALSE 38045
// MC_Build ( ) ;
38041: CALL 44474 0 0
// if event = 104 then
38045: LD_VAR 0 1
38049: PUSH
38050: LD_INT 104
38052: EQUAL
38053: IFFALSE 38059
// MC_TurretWeapon ( ) ;
38055: CALL 46087 0 0
// if event = 105 then
38059: LD_VAR 0 1
38063: PUSH
38064: LD_INT 105
38066: EQUAL
38067: IFFALSE 38073
// MC_BuildUpgrade ( ) ;
38069: CALL 45638 0 0
// if event = 106 then
38073: LD_VAR 0 1
38077: PUSH
38078: LD_INT 106
38080: EQUAL
38081: IFFALSE 38087
// MC_PlantMines ( ) ;
38083: CALL 46517 0 0
// if event = 107 then
38087: LD_VAR 0 1
38091: PUSH
38092: LD_INT 107
38094: EQUAL
38095: IFFALSE 38101
// MC_CollectCrates ( ) ;
38097: CALL 47315 0 0
// if event = 108 then
38101: LD_VAR 0 1
38105: PUSH
38106: LD_INT 108
38108: EQUAL
38109: IFFALSE 38115
// MC_LinkRemoteControl ( ) ;
38111: CALL 49091 0 0
// if event = 109 then
38115: LD_VAR 0 1
38119: PUSH
38120: LD_INT 109
38122: EQUAL
38123: IFFALSE 38129
// MC_ProduceVehicle ( ) ;
38125: CALL 49272 0 0
// if event = 110 then
38129: LD_VAR 0 1
38133: PUSH
38134: LD_INT 110
38136: EQUAL
38137: IFFALSE 38143
// MC_SendAttack ( ) ;
38139: CALL 49738 0 0
// if event = 111 then
38143: LD_VAR 0 1
38147: PUSH
38148: LD_INT 111
38150: EQUAL
38151: IFFALSE 38157
// MC_Defend ( ) ;
38153: CALL 49846 0 0
// if event = 112 then
38157: LD_VAR 0 1
38161: PUSH
38162: LD_INT 112
38164: EQUAL
38165: IFFALSE 38171
// MC_Research ( ) ;
38167: CALL 50451 0 0
// if event = 113 then
38171: LD_VAR 0 1
38175: PUSH
38176: LD_INT 113
38178: EQUAL
38179: IFFALSE 38185
// MC_MinesTrigger ( ) ;
38181: CALL 51565 0 0
// if event = 120 then
38185: LD_VAR 0 1
38189: PUSH
38190: LD_INT 120
38192: EQUAL
38193: IFFALSE 38199
// MC_RepairVehicle ( ) ;
38195: CALL 51664 0 0
// if event = 121 then
38199: LD_VAR 0 1
38203: PUSH
38204: LD_INT 121
38206: EQUAL
38207: IFFALSE 38213
// MC_TameApe ( ) ;
38209: CALL 52394 0 0
// if event = 122 then
38213: LD_VAR 0 1
38217: PUSH
38218: LD_INT 122
38220: EQUAL
38221: IFFALSE 38227
// MC_ChangeApeClass ( ) ;
38223: CALL 53223 0 0
// if event = 123 then
38227: LD_VAR 0 1
38231: PUSH
38232: LD_INT 123
38234: EQUAL
38235: IFFALSE 38241
// MC_Bazooka ( ) ;
38237: CALL 53873 0 0
// if event = 124 then
38241: LD_VAR 0 1
38245: PUSH
38246: LD_INT 124
38248: EQUAL
38249: IFFALSE 38255
// MC_TeleportExit ( ) ;
38251: CALL 54071 0 0
// if event = 125 then
38255: LD_VAR 0 1
38259: PUSH
38260: LD_INT 125
38262: EQUAL
38263: IFFALSE 38269
// MC_Deposits ( ) ;
38265: CALL 54718 0 0
// if event = 126 then
38269: LD_VAR 0 1
38273: PUSH
38274: LD_INT 126
38276: EQUAL
38277: IFFALSE 38283
// MC_RemoteDriver ( ) ;
38279: CALL 55343 0 0
// if event = 200 then
38283: LD_VAR 0 1
38287: PUSH
38288: LD_INT 200
38290: EQUAL
38291: IFFALSE 38297
// MC_Idle ( ) ;
38293: CALL 57292 0 0
// end ;
38297: PPOPN 1
38299: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38300: LD_INT 0
38302: PPUSH
38303: PPUSH
// if not mc_bases [ base ] or not tag then
38304: LD_EXP 101
38308: PUSH
38309: LD_VAR 0 1
38313: ARRAY
38314: NOT
38315: PUSH
38316: LD_VAR 0 2
38320: NOT
38321: OR
38322: IFFALSE 38326
// exit ;
38324: GO 38390
// for i in mc_bases [ base ] union mc_ape [ base ] do
38326: LD_ADDR_VAR 0 4
38330: PUSH
38331: LD_EXP 101
38335: PUSH
38336: LD_VAR 0 1
38340: ARRAY
38341: PUSH
38342: LD_EXP 130
38346: PUSH
38347: LD_VAR 0 1
38351: ARRAY
38352: UNION
38353: PUSH
38354: FOR_IN
38355: IFFALSE 38388
// if GetTag ( i ) = tag then
38357: LD_VAR 0 4
38361: PPUSH
38362: CALL_OW 110
38366: PUSH
38367: LD_VAR 0 2
38371: EQUAL
38372: IFFALSE 38386
// SetTag ( i , 0 ) ;
38374: LD_VAR 0 4
38378: PPUSH
38379: LD_INT 0
38381: PPUSH
38382: CALL_OW 109
38386: GO 38354
38388: POP
38389: POP
// end ;
38390: LD_VAR 0 3
38394: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38395: LD_INT 0
38397: PPUSH
38398: PPUSH
38399: PPUSH
38400: PPUSH
38401: PPUSH
38402: PPUSH
38403: PPUSH
38404: PPUSH
// if not mc_bases then
38405: LD_EXP 101
38409: NOT
38410: IFFALSE 38414
// exit ;
38412: GO 38872
// for i = 1 to mc_bases do
38414: LD_ADDR_VAR 0 2
38418: PUSH
38419: DOUBLE
38420: LD_INT 1
38422: DEC
38423: ST_TO_ADDR
38424: LD_EXP 101
38428: PUSH
38429: FOR_TO
38430: IFFALSE 38870
// begin tmp := MC_ClassCheckReq ( i ) ;
38432: LD_ADDR_VAR 0 4
38436: PUSH
38437: LD_VAR 0 2
38441: PPUSH
38442: CALL 38877 0 1
38446: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38447: LD_ADDR_EXP 142
38451: PUSH
38452: LD_EXP 142
38456: PPUSH
38457: LD_VAR 0 2
38461: PPUSH
38462: LD_VAR 0 4
38466: PPUSH
38467: CALL_OW 1
38471: ST_TO_ADDR
// if not tmp then
38472: LD_VAR 0 4
38476: NOT
38477: IFFALSE 38481
// continue ;
38479: GO 38429
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38481: LD_ADDR_VAR 0 6
38485: PUSH
38486: LD_EXP 101
38490: PUSH
38491: LD_VAR 0 2
38495: ARRAY
38496: PPUSH
38497: LD_INT 2
38499: PUSH
38500: LD_INT 30
38502: PUSH
38503: LD_INT 4
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 30
38512: PUSH
38513: LD_INT 5
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: LIST
38524: PPUSH
38525: CALL_OW 72
38529: PUSH
38530: LD_EXP 101
38534: PUSH
38535: LD_VAR 0 2
38539: ARRAY
38540: PPUSH
38541: LD_INT 2
38543: PUSH
38544: LD_INT 30
38546: PUSH
38547: LD_INT 0
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: LD_INT 30
38556: PUSH
38557: LD_INT 1
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: EMPTY
38565: LIST
38566: LIST
38567: LIST
38568: PPUSH
38569: CALL_OW 72
38573: PUSH
38574: LD_EXP 101
38578: PUSH
38579: LD_VAR 0 2
38583: ARRAY
38584: PPUSH
38585: LD_INT 30
38587: PUSH
38588: LD_INT 3
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PPUSH
38595: CALL_OW 72
38599: PUSH
38600: LD_EXP 101
38604: PUSH
38605: LD_VAR 0 2
38609: ARRAY
38610: PPUSH
38611: LD_INT 2
38613: PUSH
38614: LD_INT 30
38616: PUSH
38617: LD_INT 6
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 30
38626: PUSH
38627: LD_INT 7
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: LD_INT 30
38636: PUSH
38637: LD_INT 8
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: PPUSH
38650: CALL_OW 72
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: LIST
38659: LIST
38660: ST_TO_ADDR
// for j = 1 to 4 do
38661: LD_ADDR_VAR 0 3
38665: PUSH
38666: DOUBLE
38667: LD_INT 1
38669: DEC
38670: ST_TO_ADDR
38671: LD_INT 4
38673: PUSH
38674: FOR_TO
38675: IFFALSE 38866
// begin if not tmp [ j ] then
38677: LD_VAR 0 4
38681: PUSH
38682: LD_VAR 0 3
38686: ARRAY
38687: NOT
38688: IFFALSE 38692
// continue ;
38690: GO 38674
// for p in tmp [ j ] do
38692: LD_ADDR_VAR 0 5
38696: PUSH
38697: LD_VAR 0 4
38701: PUSH
38702: LD_VAR 0 3
38706: ARRAY
38707: PUSH
38708: FOR_IN
38709: IFFALSE 38862
// begin if not b [ j ] then
38711: LD_VAR 0 6
38715: PUSH
38716: LD_VAR 0 3
38720: ARRAY
38721: NOT
38722: IFFALSE 38726
// break ;
38724: GO 38862
// e := 0 ;
38726: LD_ADDR_VAR 0 7
38730: PUSH
38731: LD_INT 0
38733: ST_TO_ADDR
// for k in b [ j ] do
38734: LD_ADDR_VAR 0 8
38738: PUSH
38739: LD_VAR 0 6
38743: PUSH
38744: LD_VAR 0 3
38748: ARRAY
38749: PUSH
38750: FOR_IN
38751: IFFALSE 38778
// if IsNotFull ( k ) then
38753: LD_VAR 0 8
38757: PPUSH
38758: CALL 68764 0 1
38762: IFFALSE 38776
// begin e := k ;
38764: LD_ADDR_VAR 0 7
38768: PUSH
38769: LD_VAR 0 8
38773: ST_TO_ADDR
// break ;
38774: GO 38778
// end ;
38776: GO 38750
38778: POP
38779: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38780: LD_VAR 0 7
38784: PUSH
38785: LD_VAR 0 5
38789: PPUSH
38790: LD_VAR 0 7
38794: PPUSH
38795: CALL 105909 0 2
38799: NOT
38800: AND
38801: IFFALSE 38860
// begin if IsInUnit ( p ) then
38803: LD_VAR 0 5
38807: PPUSH
38808: CALL_OW 310
38812: IFFALSE 38823
// ComExitBuilding ( p ) ;
38814: LD_VAR 0 5
38818: PPUSH
38819: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38823: LD_VAR 0 5
38827: PPUSH
38828: LD_VAR 0 7
38832: PPUSH
38833: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38837: LD_VAR 0 5
38841: PPUSH
38842: LD_VAR 0 3
38846: PPUSH
38847: CALL_OW 183
// AddComExitBuilding ( p ) ;
38851: LD_VAR 0 5
38855: PPUSH
38856: CALL_OW 182
// end ; end ;
38860: GO 38708
38862: POP
38863: POP
// end ;
38864: GO 38674
38866: POP
38867: POP
// end ;
38868: GO 38429
38870: POP
38871: POP
// end ;
38872: LD_VAR 0 1
38876: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38877: LD_INT 0
38879: PPUSH
38880: PPUSH
38881: PPUSH
38882: PPUSH
38883: PPUSH
38884: PPUSH
38885: PPUSH
38886: PPUSH
38887: PPUSH
38888: PPUSH
38889: PPUSH
38890: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38891: LD_VAR 0 1
38895: NOT
38896: PUSH
38897: LD_EXP 101
38901: PUSH
38902: LD_VAR 0 1
38906: ARRAY
38907: NOT
38908: OR
38909: PUSH
38910: LD_EXP 101
38914: PUSH
38915: LD_VAR 0 1
38919: ARRAY
38920: PPUSH
38921: LD_INT 2
38923: PUSH
38924: LD_INT 30
38926: PUSH
38927: LD_INT 0
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 30
38936: PUSH
38937: LD_INT 1
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: LIST
38948: PPUSH
38949: CALL_OW 72
38953: NOT
38954: OR
38955: IFFALSE 38959
// exit ;
38957: GO 42462
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38959: LD_ADDR_VAR 0 4
38963: PUSH
38964: LD_EXP 101
38968: PUSH
38969: LD_VAR 0 1
38973: ARRAY
38974: PPUSH
38975: LD_INT 2
38977: PUSH
38978: LD_INT 25
38980: PUSH
38981: LD_INT 1
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 25
38990: PUSH
38991: LD_INT 2
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 25
39000: PUSH
39001: LD_INT 3
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 25
39010: PUSH
39011: LD_INT 4
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 25
39020: PUSH
39021: LD_INT 5
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 25
39030: PUSH
39031: LD_INT 8
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 25
39040: PUSH
39041: LD_INT 9
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: PPUSH
39058: CALL_OW 72
39062: ST_TO_ADDR
// if not tmp then
39063: LD_VAR 0 4
39067: NOT
39068: IFFALSE 39072
// exit ;
39070: GO 42462
// for i in tmp do
39072: LD_ADDR_VAR 0 3
39076: PUSH
39077: LD_VAR 0 4
39081: PUSH
39082: FOR_IN
39083: IFFALSE 39114
// if GetTag ( i ) then
39085: LD_VAR 0 3
39089: PPUSH
39090: CALL_OW 110
39094: IFFALSE 39112
// tmp := tmp diff i ;
39096: LD_ADDR_VAR 0 4
39100: PUSH
39101: LD_VAR 0 4
39105: PUSH
39106: LD_VAR 0 3
39110: DIFF
39111: ST_TO_ADDR
39112: GO 39082
39114: POP
39115: POP
// if not tmp then
39116: LD_VAR 0 4
39120: NOT
39121: IFFALSE 39125
// exit ;
39123: GO 42462
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39125: LD_ADDR_VAR 0 5
39129: PUSH
39130: LD_EXP 101
39134: PUSH
39135: LD_VAR 0 1
39139: ARRAY
39140: PPUSH
39141: LD_INT 2
39143: PUSH
39144: LD_INT 25
39146: PUSH
39147: LD_INT 1
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 25
39156: PUSH
39157: LD_INT 5
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 25
39166: PUSH
39167: LD_INT 8
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 25
39176: PUSH
39177: LD_INT 9
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: LIST
39190: PPUSH
39191: CALL_OW 72
39195: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39196: LD_ADDR_VAR 0 6
39200: PUSH
39201: LD_EXP 101
39205: PUSH
39206: LD_VAR 0 1
39210: ARRAY
39211: PPUSH
39212: LD_INT 25
39214: PUSH
39215: LD_INT 2
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PPUSH
39222: CALL_OW 72
39226: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39227: LD_ADDR_VAR 0 7
39231: PUSH
39232: LD_EXP 101
39236: PUSH
39237: LD_VAR 0 1
39241: ARRAY
39242: PPUSH
39243: LD_INT 25
39245: PUSH
39246: LD_INT 3
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PPUSH
39253: CALL_OW 72
39257: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39258: LD_ADDR_VAR 0 8
39262: PUSH
39263: LD_EXP 101
39267: PUSH
39268: LD_VAR 0 1
39272: ARRAY
39273: PPUSH
39274: LD_INT 25
39276: PUSH
39277: LD_INT 4
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: PUSH
39284: LD_INT 24
39286: PUSH
39287: LD_INT 251
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PPUSH
39298: CALL_OW 72
39302: ST_TO_ADDR
// if mc_scan [ base ] then
39303: LD_EXP 124
39307: PUSH
39308: LD_VAR 0 1
39312: ARRAY
39313: IFFALSE 39774
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39315: LD_ADDR_EXP 143
39319: PUSH
39320: LD_EXP 143
39324: PPUSH
39325: LD_VAR 0 1
39329: PPUSH
39330: LD_INT 4
39332: PPUSH
39333: CALL_OW 1
39337: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39338: LD_ADDR_VAR 0 12
39342: PUSH
39343: LD_EXP 101
39347: PUSH
39348: LD_VAR 0 1
39352: ARRAY
39353: PPUSH
39354: LD_INT 2
39356: PUSH
39357: LD_INT 30
39359: PUSH
39360: LD_INT 4
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 30
39369: PUSH
39370: LD_INT 5
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: LIST
39381: PPUSH
39382: CALL_OW 72
39386: ST_TO_ADDR
// if not b then
39387: LD_VAR 0 12
39391: NOT
39392: IFFALSE 39396
// exit ;
39394: GO 42462
// p := [ ] ;
39396: LD_ADDR_VAR 0 11
39400: PUSH
39401: EMPTY
39402: ST_TO_ADDR
// if sci >= 2 then
39403: LD_VAR 0 8
39407: PUSH
39408: LD_INT 2
39410: GREATEREQUAL
39411: IFFALSE 39442
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39413: LD_ADDR_VAR 0 8
39417: PUSH
39418: LD_VAR 0 8
39422: PUSH
39423: LD_INT 1
39425: ARRAY
39426: PUSH
39427: LD_VAR 0 8
39431: PUSH
39432: LD_INT 2
39434: ARRAY
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: ST_TO_ADDR
39440: GO 39503
// if sci = 1 then
39442: LD_VAR 0 8
39446: PUSH
39447: LD_INT 1
39449: EQUAL
39450: IFFALSE 39471
// sci := [ sci [ 1 ] ] else
39452: LD_ADDR_VAR 0 8
39456: PUSH
39457: LD_VAR 0 8
39461: PUSH
39462: LD_INT 1
39464: ARRAY
39465: PUSH
39466: EMPTY
39467: LIST
39468: ST_TO_ADDR
39469: GO 39503
// if sci = 0 then
39471: LD_VAR 0 8
39475: PUSH
39476: LD_INT 0
39478: EQUAL
39479: IFFALSE 39503
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39481: LD_ADDR_VAR 0 11
39485: PUSH
39486: LD_VAR 0 4
39490: PPUSH
39491: LD_INT 4
39493: PPUSH
39494: CALL 105772 0 2
39498: PUSH
39499: LD_INT 1
39501: ARRAY
39502: ST_TO_ADDR
// if eng > 4 then
39503: LD_VAR 0 6
39507: PUSH
39508: LD_INT 4
39510: GREATER
39511: IFFALSE 39557
// for i = eng downto 4 do
39513: LD_ADDR_VAR 0 3
39517: PUSH
39518: DOUBLE
39519: LD_VAR 0 6
39523: INC
39524: ST_TO_ADDR
39525: LD_INT 4
39527: PUSH
39528: FOR_DOWNTO
39529: IFFALSE 39555
// eng := eng diff eng [ i ] ;
39531: LD_ADDR_VAR 0 6
39535: PUSH
39536: LD_VAR 0 6
39540: PUSH
39541: LD_VAR 0 6
39545: PUSH
39546: LD_VAR 0 3
39550: ARRAY
39551: DIFF
39552: ST_TO_ADDR
39553: GO 39528
39555: POP
39556: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39557: LD_ADDR_VAR 0 4
39561: PUSH
39562: LD_VAR 0 4
39566: PUSH
39567: LD_VAR 0 5
39571: PUSH
39572: LD_VAR 0 6
39576: UNION
39577: PUSH
39578: LD_VAR 0 7
39582: UNION
39583: PUSH
39584: LD_VAR 0 8
39588: UNION
39589: DIFF
39590: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39591: LD_ADDR_VAR 0 13
39595: PUSH
39596: LD_EXP 101
39600: PUSH
39601: LD_VAR 0 1
39605: ARRAY
39606: PPUSH
39607: LD_INT 2
39609: PUSH
39610: LD_INT 30
39612: PUSH
39613: LD_INT 32
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 30
39622: PUSH
39623: LD_INT 31
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: LIST
39634: PPUSH
39635: CALL_OW 72
39639: PUSH
39640: LD_EXP 101
39644: PUSH
39645: LD_VAR 0 1
39649: ARRAY
39650: PPUSH
39651: LD_INT 2
39653: PUSH
39654: LD_INT 30
39656: PUSH
39657: LD_INT 4
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 30
39666: PUSH
39667: LD_INT 5
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: LIST
39678: PPUSH
39679: CALL_OW 72
39683: PUSH
39684: LD_INT 6
39686: MUL
39687: PLUS
39688: ST_TO_ADDR
// if bcount < tmp then
39689: LD_VAR 0 13
39693: PUSH
39694: LD_VAR 0 4
39698: LESS
39699: IFFALSE 39745
// for i = tmp downto bcount do
39701: LD_ADDR_VAR 0 3
39705: PUSH
39706: DOUBLE
39707: LD_VAR 0 4
39711: INC
39712: ST_TO_ADDR
39713: LD_VAR 0 13
39717: PUSH
39718: FOR_DOWNTO
39719: IFFALSE 39743
// tmp := Delete ( tmp , tmp ) ;
39721: LD_ADDR_VAR 0 4
39725: PUSH
39726: LD_VAR 0 4
39730: PPUSH
39731: LD_VAR 0 4
39735: PPUSH
39736: CALL_OW 3
39740: ST_TO_ADDR
39741: GO 39718
39743: POP
39744: POP
// result := [ tmp , 0 , 0 , p ] ;
39745: LD_ADDR_VAR 0 2
39749: PUSH
39750: LD_VAR 0 4
39754: PUSH
39755: LD_INT 0
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: LD_VAR 0 11
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: LIST
39770: LIST
39771: ST_TO_ADDR
// exit ;
39772: GO 42462
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39774: LD_EXP 101
39778: PUSH
39779: LD_VAR 0 1
39783: ARRAY
39784: PPUSH
39785: LD_INT 2
39787: PUSH
39788: LD_INT 30
39790: PUSH
39791: LD_INT 6
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: LD_INT 30
39800: PUSH
39801: LD_INT 7
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 30
39810: PUSH
39811: LD_INT 8
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: PPUSH
39824: CALL_OW 72
39828: NOT
39829: PUSH
39830: LD_EXP 101
39834: PUSH
39835: LD_VAR 0 1
39839: ARRAY
39840: PPUSH
39841: LD_INT 30
39843: PUSH
39844: LD_INT 3
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PPUSH
39851: CALL_OW 72
39855: NOT
39856: AND
39857: IFFALSE 39929
// begin if eng = tmp then
39859: LD_VAR 0 6
39863: PUSH
39864: LD_VAR 0 4
39868: EQUAL
39869: IFFALSE 39873
// exit ;
39871: GO 42462
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39873: LD_ADDR_EXP 143
39877: PUSH
39878: LD_EXP 143
39882: PPUSH
39883: LD_VAR 0 1
39887: PPUSH
39888: LD_INT 1
39890: PPUSH
39891: CALL_OW 1
39895: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39896: LD_ADDR_VAR 0 2
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: LD_VAR 0 4
39908: PUSH
39909: LD_VAR 0 6
39913: DIFF
39914: PUSH
39915: LD_INT 0
39917: PUSH
39918: LD_INT 0
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: ST_TO_ADDR
// exit ;
39927: GO 42462
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39929: LD_EXP 128
39933: PUSH
39934: LD_EXP 127
39938: PUSH
39939: LD_VAR 0 1
39943: ARRAY
39944: ARRAY
39945: PUSH
39946: LD_EXP 101
39950: PUSH
39951: LD_VAR 0 1
39955: ARRAY
39956: PPUSH
39957: LD_INT 2
39959: PUSH
39960: LD_INT 30
39962: PUSH
39963: LD_INT 6
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 30
39972: PUSH
39973: LD_INT 7
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 30
39982: PUSH
39983: LD_INT 8
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: PPUSH
39996: CALL_OW 72
40000: AND
40001: PUSH
40002: LD_EXP 101
40006: PUSH
40007: LD_VAR 0 1
40011: ARRAY
40012: PPUSH
40013: LD_INT 30
40015: PUSH
40016: LD_INT 3
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PPUSH
40023: CALL_OW 72
40027: NOT
40028: AND
40029: IFFALSE 40243
// begin if sci >= 6 then
40031: LD_VAR 0 8
40035: PUSH
40036: LD_INT 6
40038: GREATEREQUAL
40039: IFFALSE 40043
// exit ;
40041: GO 42462
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40043: LD_ADDR_EXP 143
40047: PUSH
40048: LD_EXP 143
40052: PPUSH
40053: LD_VAR 0 1
40057: PPUSH
40058: LD_INT 2
40060: PPUSH
40061: CALL_OW 1
40065: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40066: LD_ADDR_VAR 0 9
40070: PUSH
40071: LD_VAR 0 4
40075: PUSH
40076: LD_VAR 0 8
40080: DIFF
40081: PPUSH
40082: LD_INT 4
40084: PPUSH
40085: CALL 105772 0 2
40089: ST_TO_ADDR
// p := [ ] ;
40090: LD_ADDR_VAR 0 11
40094: PUSH
40095: EMPTY
40096: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40097: LD_VAR 0 8
40101: PUSH
40102: LD_INT 6
40104: LESS
40105: PUSH
40106: LD_VAR 0 9
40110: PUSH
40111: LD_INT 6
40113: GREATER
40114: AND
40115: IFFALSE 40196
// begin for i = 1 to 6 - sci do
40117: LD_ADDR_VAR 0 3
40121: PUSH
40122: DOUBLE
40123: LD_INT 1
40125: DEC
40126: ST_TO_ADDR
40127: LD_INT 6
40129: PUSH
40130: LD_VAR 0 8
40134: MINUS
40135: PUSH
40136: FOR_TO
40137: IFFALSE 40192
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40139: LD_ADDR_VAR 0 11
40143: PUSH
40144: LD_VAR 0 11
40148: PPUSH
40149: LD_VAR 0 11
40153: PUSH
40154: LD_INT 1
40156: PLUS
40157: PPUSH
40158: LD_VAR 0 9
40162: PUSH
40163: LD_INT 1
40165: ARRAY
40166: PPUSH
40167: CALL_OW 2
40171: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40172: LD_ADDR_VAR 0 9
40176: PUSH
40177: LD_VAR 0 9
40181: PPUSH
40182: LD_INT 1
40184: PPUSH
40185: CALL_OW 3
40189: ST_TO_ADDR
// end ;
40190: GO 40136
40192: POP
40193: POP
// end else
40194: GO 40216
// if sort then
40196: LD_VAR 0 9
40200: IFFALSE 40216
// p := sort [ 1 ] ;
40202: LD_ADDR_VAR 0 11
40206: PUSH
40207: LD_VAR 0 9
40211: PUSH
40212: LD_INT 1
40214: ARRAY
40215: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40216: LD_ADDR_VAR 0 2
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: LD_INT 0
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: LD_VAR 0 11
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: ST_TO_ADDR
// exit ;
40241: GO 42462
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40243: LD_EXP 128
40247: PUSH
40248: LD_EXP 127
40252: PUSH
40253: LD_VAR 0 1
40257: ARRAY
40258: ARRAY
40259: PUSH
40260: LD_EXP 101
40264: PUSH
40265: LD_VAR 0 1
40269: ARRAY
40270: PPUSH
40271: LD_INT 2
40273: PUSH
40274: LD_INT 30
40276: PUSH
40277: LD_INT 6
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 30
40286: PUSH
40287: LD_INT 7
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 30
40296: PUSH
40297: LD_INT 8
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: PPUSH
40310: CALL_OW 72
40314: AND
40315: PUSH
40316: LD_EXP 101
40320: PUSH
40321: LD_VAR 0 1
40325: ARRAY
40326: PPUSH
40327: LD_INT 30
40329: PUSH
40330: LD_INT 3
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PPUSH
40337: CALL_OW 72
40341: AND
40342: IFFALSE 41076
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40344: LD_ADDR_EXP 143
40348: PUSH
40349: LD_EXP 143
40353: PPUSH
40354: LD_VAR 0 1
40358: PPUSH
40359: LD_INT 3
40361: PPUSH
40362: CALL_OW 1
40366: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40367: LD_ADDR_VAR 0 2
40371: PUSH
40372: LD_INT 0
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: LD_INT 0
40380: PUSH
40381: LD_INT 0
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: ST_TO_ADDR
// if not eng then
40390: LD_VAR 0 6
40394: NOT
40395: IFFALSE 40458
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40397: LD_ADDR_VAR 0 11
40401: PUSH
40402: LD_VAR 0 4
40406: PPUSH
40407: LD_INT 2
40409: PPUSH
40410: CALL 105772 0 2
40414: PUSH
40415: LD_INT 1
40417: ARRAY
40418: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40419: LD_ADDR_VAR 0 2
40423: PUSH
40424: LD_VAR 0 2
40428: PPUSH
40429: LD_INT 2
40431: PPUSH
40432: LD_VAR 0 11
40436: PPUSH
40437: CALL_OW 1
40441: ST_TO_ADDR
// tmp := tmp diff p ;
40442: LD_ADDR_VAR 0 4
40446: PUSH
40447: LD_VAR 0 4
40451: PUSH
40452: LD_VAR 0 11
40456: DIFF
40457: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40458: LD_VAR 0 4
40462: PUSH
40463: LD_VAR 0 8
40467: PUSH
40468: LD_INT 6
40470: LESS
40471: AND
40472: IFFALSE 40660
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40474: LD_ADDR_VAR 0 9
40478: PUSH
40479: LD_VAR 0 4
40483: PUSH
40484: LD_VAR 0 8
40488: PUSH
40489: LD_VAR 0 7
40493: UNION
40494: DIFF
40495: PPUSH
40496: LD_INT 4
40498: PPUSH
40499: CALL 105772 0 2
40503: ST_TO_ADDR
// p := [ ] ;
40504: LD_ADDR_VAR 0 11
40508: PUSH
40509: EMPTY
40510: ST_TO_ADDR
// if sort then
40511: LD_VAR 0 9
40515: IFFALSE 40631
// for i = 1 to 6 - sci do
40517: LD_ADDR_VAR 0 3
40521: PUSH
40522: DOUBLE
40523: LD_INT 1
40525: DEC
40526: ST_TO_ADDR
40527: LD_INT 6
40529: PUSH
40530: LD_VAR 0 8
40534: MINUS
40535: PUSH
40536: FOR_TO
40537: IFFALSE 40629
// begin if i = sort then
40539: LD_VAR 0 3
40543: PUSH
40544: LD_VAR 0 9
40548: EQUAL
40549: IFFALSE 40553
// break ;
40551: GO 40629
// if GetClass ( i ) = 4 then
40553: LD_VAR 0 3
40557: PPUSH
40558: CALL_OW 257
40562: PUSH
40563: LD_INT 4
40565: EQUAL
40566: IFFALSE 40570
// continue ;
40568: GO 40536
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40570: LD_ADDR_VAR 0 11
40574: PUSH
40575: LD_VAR 0 11
40579: PPUSH
40580: LD_VAR 0 11
40584: PUSH
40585: LD_INT 1
40587: PLUS
40588: PPUSH
40589: LD_VAR 0 9
40593: PUSH
40594: LD_VAR 0 3
40598: ARRAY
40599: PPUSH
40600: CALL_OW 2
40604: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40605: LD_ADDR_VAR 0 4
40609: PUSH
40610: LD_VAR 0 4
40614: PUSH
40615: LD_VAR 0 9
40619: PUSH
40620: LD_VAR 0 3
40624: ARRAY
40625: DIFF
40626: ST_TO_ADDR
// end ;
40627: GO 40536
40629: POP
40630: POP
// if p then
40631: LD_VAR 0 11
40635: IFFALSE 40660
// result := Replace ( result , 4 , p ) ;
40637: LD_ADDR_VAR 0 2
40641: PUSH
40642: LD_VAR 0 2
40646: PPUSH
40647: LD_INT 4
40649: PPUSH
40650: LD_VAR 0 11
40654: PPUSH
40655: CALL_OW 1
40659: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40660: LD_VAR 0 4
40664: PUSH
40665: LD_VAR 0 7
40669: PUSH
40670: LD_INT 6
40672: LESS
40673: AND
40674: IFFALSE 40862
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40676: LD_ADDR_VAR 0 9
40680: PUSH
40681: LD_VAR 0 4
40685: PUSH
40686: LD_VAR 0 8
40690: PUSH
40691: LD_VAR 0 7
40695: UNION
40696: DIFF
40697: PPUSH
40698: LD_INT 3
40700: PPUSH
40701: CALL 105772 0 2
40705: ST_TO_ADDR
// p := [ ] ;
40706: LD_ADDR_VAR 0 11
40710: PUSH
40711: EMPTY
40712: ST_TO_ADDR
// if sort then
40713: LD_VAR 0 9
40717: IFFALSE 40833
// for i = 1 to 6 - mech do
40719: LD_ADDR_VAR 0 3
40723: PUSH
40724: DOUBLE
40725: LD_INT 1
40727: DEC
40728: ST_TO_ADDR
40729: LD_INT 6
40731: PUSH
40732: LD_VAR 0 7
40736: MINUS
40737: PUSH
40738: FOR_TO
40739: IFFALSE 40831
// begin if i = sort then
40741: LD_VAR 0 3
40745: PUSH
40746: LD_VAR 0 9
40750: EQUAL
40751: IFFALSE 40755
// break ;
40753: GO 40831
// if GetClass ( i ) = 3 then
40755: LD_VAR 0 3
40759: PPUSH
40760: CALL_OW 257
40764: PUSH
40765: LD_INT 3
40767: EQUAL
40768: IFFALSE 40772
// continue ;
40770: GO 40738
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40772: LD_ADDR_VAR 0 11
40776: PUSH
40777: LD_VAR 0 11
40781: PPUSH
40782: LD_VAR 0 11
40786: PUSH
40787: LD_INT 1
40789: PLUS
40790: PPUSH
40791: LD_VAR 0 9
40795: PUSH
40796: LD_VAR 0 3
40800: ARRAY
40801: PPUSH
40802: CALL_OW 2
40806: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40807: LD_ADDR_VAR 0 4
40811: PUSH
40812: LD_VAR 0 4
40816: PUSH
40817: LD_VAR 0 9
40821: PUSH
40822: LD_VAR 0 3
40826: ARRAY
40827: DIFF
40828: ST_TO_ADDR
// end ;
40829: GO 40738
40831: POP
40832: POP
// if p then
40833: LD_VAR 0 11
40837: IFFALSE 40862
// result := Replace ( result , 3 , p ) ;
40839: LD_ADDR_VAR 0 2
40843: PUSH
40844: LD_VAR 0 2
40848: PPUSH
40849: LD_INT 3
40851: PPUSH
40852: LD_VAR 0 11
40856: PPUSH
40857: CALL_OW 1
40861: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40862: LD_VAR 0 4
40866: PUSH
40867: LD_INT 6
40869: GREATER
40870: PUSH
40871: LD_VAR 0 6
40875: PUSH
40876: LD_INT 6
40878: LESS
40879: AND
40880: IFFALSE 41074
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40882: LD_ADDR_VAR 0 9
40886: PUSH
40887: LD_VAR 0 4
40891: PUSH
40892: LD_VAR 0 8
40896: PUSH
40897: LD_VAR 0 7
40901: UNION
40902: PUSH
40903: LD_VAR 0 6
40907: UNION
40908: DIFF
40909: PPUSH
40910: LD_INT 2
40912: PPUSH
40913: CALL 105772 0 2
40917: ST_TO_ADDR
// p := [ ] ;
40918: LD_ADDR_VAR 0 11
40922: PUSH
40923: EMPTY
40924: ST_TO_ADDR
// if sort then
40925: LD_VAR 0 9
40929: IFFALSE 41045
// for i = 1 to 6 - eng do
40931: LD_ADDR_VAR 0 3
40935: PUSH
40936: DOUBLE
40937: LD_INT 1
40939: DEC
40940: ST_TO_ADDR
40941: LD_INT 6
40943: PUSH
40944: LD_VAR 0 6
40948: MINUS
40949: PUSH
40950: FOR_TO
40951: IFFALSE 41043
// begin if i = sort then
40953: LD_VAR 0 3
40957: PUSH
40958: LD_VAR 0 9
40962: EQUAL
40963: IFFALSE 40967
// break ;
40965: GO 41043
// if GetClass ( i ) = 2 then
40967: LD_VAR 0 3
40971: PPUSH
40972: CALL_OW 257
40976: PUSH
40977: LD_INT 2
40979: EQUAL
40980: IFFALSE 40984
// continue ;
40982: GO 40950
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40984: LD_ADDR_VAR 0 11
40988: PUSH
40989: LD_VAR 0 11
40993: PPUSH
40994: LD_VAR 0 11
40998: PUSH
40999: LD_INT 1
41001: PLUS
41002: PPUSH
41003: LD_VAR 0 9
41007: PUSH
41008: LD_VAR 0 3
41012: ARRAY
41013: PPUSH
41014: CALL_OW 2
41018: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41019: LD_ADDR_VAR 0 4
41023: PUSH
41024: LD_VAR 0 4
41028: PUSH
41029: LD_VAR 0 9
41033: PUSH
41034: LD_VAR 0 3
41038: ARRAY
41039: DIFF
41040: ST_TO_ADDR
// end ;
41041: GO 40950
41043: POP
41044: POP
// if p then
41045: LD_VAR 0 11
41049: IFFALSE 41074
// result := Replace ( result , 2 , p ) ;
41051: LD_ADDR_VAR 0 2
41055: PUSH
41056: LD_VAR 0 2
41060: PPUSH
41061: LD_INT 2
41063: PPUSH
41064: LD_VAR 0 11
41068: PPUSH
41069: CALL_OW 1
41073: ST_TO_ADDR
// end ; exit ;
41074: GO 42462
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41076: LD_EXP 128
41080: PUSH
41081: LD_EXP 127
41085: PUSH
41086: LD_VAR 0 1
41090: ARRAY
41091: ARRAY
41092: NOT
41093: PUSH
41094: LD_EXP 101
41098: PUSH
41099: LD_VAR 0 1
41103: ARRAY
41104: PPUSH
41105: LD_INT 30
41107: PUSH
41108: LD_INT 3
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PPUSH
41115: CALL_OW 72
41119: AND
41120: PUSH
41121: LD_EXP 106
41125: PUSH
41126: LD_VAR 0 1
41130: ARRAY
41131: AND
41132: IFFALSE 41740
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41134: LD_ADDR_EXP 143
41138: PUSH
41139: LD_EXP 143
41143: PPUSH
41144: LD_VAR 0 1
41148: PPUSH
41149: LD_INT 5
41151: PPUSH
41152: CALL_OW 1
41156: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41157: LD_ADDR_VAR 0 2
41161: PUSH
41162: LD_INT 0
41164: PUSH
41165: LD_INT 0
41167: PUSH
41168: LD_INT 0
41170: PUSH
41171: LD_INT 0
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: LIST
41178: LIST
41179: ST_TO_ADDR
// if sci > 1 then
41180: LD_VAR 0 8
41184: PUSH
41185: LD_INT 1
41187: GREATER
41188: IFFALSE 41216
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41190: LD_ADDR_VAR 0 4
41194: PUSH
41195: LD_VAR 0 4
41199: PUSH
41200: LD_VAR 0 8
41204: PUSH
41205: LD_VAR 0 8
41209: PUSH
41210: LD_INT 1
41212: ARRAY
41213: DIFF
41214: DIFF
41215: ST_TO_ADDR
// if tmp and not sci then
41216: LD_VAR 0 4
41220: PUSH
41221: LD_VAR 0 8
41225: NOT
41226: AND
41227: IFFALSE 41296
// begin sort := SortBySkill ( tmp , 4 ) ;
41229: LD_ADDR_VAR 0 9
41233: PUSH
41234: LD_VAR 0 4
41238: PPUSH
41239: LD_INT 4
41241: PPUSH
41242: CALL 105772 0 2
41246: ST_TO_ADDR
// if sort then
41247: LD_VAR 0 9
41251: IFFALSE 41267
// p := sort [ 1 ] ;
41253: LD_ADDR_VAR 0 11
41257: PUSH
41258: LD_VAR 0 9
41262: PUSH
41263: LD_INT 1
41265: ARRAY
41266: ST_TO_ADDR
// if p then
41267: LD_VAR 0 11
41271: IFFALSE 41296
// result := Replace ( result , 4 , p ) ;
41273: LD_ADDR_VAR 0 2
41277: PUSH
41278: LD_VAR 0 2
41282: PPUSH
41283: LD_INT 4
41285: PPUSH
41286: LD_VAR 0 11
41290: PPUSH
41291: CALL_OW 1
41295: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41296: LD_ADDR_VAR 0 4
41300: PUSH
41301: LD_VAR 0 4
41305: PUSH
41306: LD_VAR 0 7
41310: DIFF
41311: ST_TO_ADDR
// if tmp and mech < 6 then
41312: LD_VAR 0 4
41316: PUSH
41317: LD_VAR 0 7
41321: PUSH
41322: LD_INT 6
41324: LESS
41325: AND
41326: IFFALSE 41514
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41328: LD_ADDR_VAR 0 9
41332: PUSH
41333: LD_VAR 0 4
41337: PUSH
41338: LD_VAR 0 8
41342: PUSH
41343: LD_VAR 0 7
41347: UNION
41348: DIFF
41349: PPUSH
41350: LD_INT 3
41352: PPUSH
41353: CALL 105772 0 2
41357: ST_TO_ADDR
// p := [ ] ;
41358: LD_ADDR_VAR 0 11
41362: PUSH
41363: EMPTY
41364: ST_TO_ADDR
// if sort then
41365: LD_VAR 0 9
41369: IFFALSE 41485
// for i = 1 to 6 - mech do
41371: LD_ADDR_VAR 0 3
41375: PUSH
41376: DOUBLE
41377: LD_INT 1
41379: DEC
41380: ST_TO_ADDR
41381: LD_INT 6
41383: PUSH
41384: LD_VAR 0 7
41388: MINUS
41389: PUSH
41390: FOR_TO
41391: IFFALSE 41483
// begin if i = sort then
41393: LD_VAR 0 3
41397: PUSH
41398: LD_VAR 0 9
41402: EQUAL
41403: IFFALSE 41407
// break ;
41405: GO 41483
// if GetClass ( i ) = 3 then
41407: LD_VAR 0 3
41411: PPUSH
41412: CALL_OW 257
41416: PUSH
41417: LD_INT 3
41419: EQUAL
41420: IFFALSE 41424
// continue ;
41422: GO 41390
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41424: LD_ADDR_VAR 0 11
41428: PUSH
41429: LD_VAR 0 11
41433: PPUSH
41434: LD_VAR 0 11
41438: PUSH
41439: LD_INT 1
41441: PLUS
41442: PPUSH
41443: LD_VAR 0 9
41447: PUSH
41448: LD_VAR 0 3
41452: ARRAY
41453: PPUSH
41454: CALL_OW 2
41458: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41459: LD_ADDR_VAR 0 4
41463: PUSH
41464: LD_VAR 0 4
41468: PUSH
41469: LD_VAR 0 9
41473: PUSH
41474: LD_VAR 0 3
41478: ARRAY
41479: DIFF
41480: ST_TO_ADDR
// end ;
41481: GO 41390
41483: POP
41484: POP
// if p then
41485: LD_VAR 0 11
41489: IFFALSE 41514
// result := Replace ( result , 3 , p ) ;
41491: LD_ADDR_VAR 0 2
41495: PUSH
41496: LD_VAR 0 2
41500: PPUSH
41501: LD_INT 3
41503: PPUSH
41504: LD_VAR 0 11
41508: PPUSH
41509: CALL_OW 1
41513: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41514: LD_ADDR_VAR 0 4
41518: PUSH
41519: LD_VAR 0 4
41523: PUSH
41524: LD_VAR 0 6
41528: DIFF
41529: ST_TO_ADDR
// if tmp and eng < 6 then
41530: LD_VAR 0 4
41534: PUSH
41535: LD_VAR 0 6
41539: PUSH
41540: LD_INT 6
41542: LESS
41543: AND
41544: IFFALSE 41738
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41546: LD_ADDR_VAR 0 9
41550: PUSH
41551: LD_VAR 0 4
41555: PUSH
41556: LD_VAR 0 8
41560: PUSH
41561: LD_VAR 0 7
41565: UNION
41566: PUSH
41567: LD_VAR 0 6
41571: UNION
41572: DIFF
41573: PPUSH
41574: LD_INT 2
41576: PPUSH
41577: CALL 105772 0 2
41581: ST_TO_ADDR
// p := [ ] ;
41582: LD_ADDR_VAR 0 11
41586: PUSH
41587: EMPTY
41588: ST_TO_ADDR
// if sort then
41589: LD_VAR 0 9
41593: IFFALSE 41709
// for i = 1 to 6 - eng do
41595: LD_ADDR_VAR 0 3
41599: PUSH
41600: DOUBLE
41601: LD_INT 1
41603: DEC
41604: ST_TO_ADDR
41605: LD_INT 6
41607: PUSH
41608: LD_VAR 0 6
41612: MINUS
41613: PUSH
41614: FOR_TO
41615: IFFALSE 41707
// begin if i = sort then
41617: LD_VAR 0 3
41621: PUSH
41622: LD_VAR 0 9
41626: EQUAL
41627: IFFALSE 41631
// break ;
41629: GO 41707
// if GetClass ( i ) = 2 then
41631: LD_VAR 0 3
41635: PPUSH
41636: CALL_OW 257
41640: PUSH
41641: LD_INT 2
41643: EQUAL
41644: IFFALSE 41648
// continue ;
41646: GO 41614
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41648: LD_ADDR_VAR 0 11
41652: PUSH
41653: LD_VAR 0 11
41657: PPUSH
41658: LD_VAR 0 11
41662: PUSH
41663: LD_INT 1
41665: PLUS
41666: PPUSH
41667: LD_VAR 0 9
41671: PUSH
41672: LD_VAR 0 3
41676: ARRAY
41677: PPUSH
41678: CALL_OW 2
41682: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41683: LD_ADDR_VAR 0 4
41687: PUSH
41688: LD_VAR 0 4
41692: PUSH
41693: LD_VAR 0 9
41697: PUSH
41698: LD_VAR 0 3
41702: ARRAY
41703: DIFF
41704: ST_TO_ADDR
// end ;
41705: GO 41614
41707: POP
41708: POP
// if p then
41709: LD_VAR 0 11
41713: IFFALSE 41738
// result := Replace ( result , 2 , p ) ;
41715: LD_ADDR_VAR 0 2
41719: PUSH
41720: LD_VAR 0 2
41724: PPUSH
41725: LD_INT 2
41727: PPUSH
41728: LD_VAR 0 11
41732: PPUSH
41733: CALL_OW 1
41737: ST_TO_ADDR
// end ; exit ;
41738: GO 42462
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41740: LD_EXP 128
41744: PUSH
41745: LD_EXP 127
41749: PUSH
41750: LD_VAR 0 1
41754: ARRAY
41755: ARRAY
41756: NOT
41757: PUSH
41758: LD_EXP 101
41762: PUSH
41763: LD_VAR 0 1
41767: ARRAY
41768: PPUSH
41769: LD_INT 30
41771: PUSH
41772: LD_INT 3
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: PPUSH
41779: CALL_OW 72
41783: AND
41784: PUSH
41785: LD_EXP 106
41789: PUSH
41790: LD_VAR 0 1
41794: ARRAY
41795: NOT
41796: AND
41797: IFFALSE 42462
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41799: LD_ADDR_EXP 143
41803: PUSH
41804: LD_EXP 143
41808: PPUSH
41809: LD_VAR 0 1
41813: PPUSH
41814: LD_INT 6
41816: PPUSH
41817: CALL_OW 1
41821: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41822: LD_ADDR_VAR 0 2
41826: PUSH
41827: LD_INT 0
41829: PUSH
41830: LD_INT 0
41832: PUSH
41833: LD_INT 0
41835: PUSH
41836: LD_INT 0
41838: PUSH
41839: EMPTY
41840: LIST
41841: LIST
41842: LIST
41843: LIST
41844: ST_TO_ADDR
// if sci >= 1 then
41845: LD_VAR 0 8
41849: PUSH
41850: LD_INT 1
41852: GREATEREQUAL
41853: IFFALSE 41875
// tmp := tmp diff sci [ 1 ] ;
41855: LD_ADDR_VAR 0 4
41859: PUSH
41860: LD_VAR 0 4
41864: PUSH
41865: LD_VAR 0 8
41869: PUSH
41870: LD_INT 1
41872: ARRAY
41873: DIFF
41874: ST_TO_ADDR
// if tmp and not sci then
41875: LD_VAR 0 4
41879: PUSH
41880: LD_VAR 0 8
41884: NOT
41885: AND
41886: IFFALSE 41955
// begin sort := SortBySkill ( tmp , 4 ) ;
41888: LD_ADDR_VAR 0 9
41892: PUSH
41893: LD_VAR 0 4
41897: PPUSH
41898: LD_INT 4
41900: PPUSH
41901: CALL 105772 0 2
41905: ST_TO_ADDR
// if sort then
41906: LD_VAR 0 9
41910: IFFALSE 41926
// p := sort [ 1 ] ;
41912: LD_ADDR_VAR 0 11
41916: PUSH
41917: LD_VAR 0 9
41921: PUSH
41922: LD_INT 1
41924: ARRAY
41925: ST_TO_ADDR
// if p then
41926: LD_VAR 0 11
41930: IFFALSE 41955
// result := Replace ( result , 4 , p ) ;
41932: LD_ADDR_VAR 0 2
41936: PUSH
41937: LD_VAR 0 2
41941: PPUSH
41942: LD_INT 4
41944: PPUSH
41945: LD_VAR 0 11
41949: PPUSH
41950: CALL_OW 1
41954: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41955: LD_ADDR_VAR 0 4
41959: PUSH
41960: LD_VAR 0 4
41964: PUSH
41965: LD_VAR 0 7
41969: DIFF
41970: ST_TO_ADDR
// if tmp and mech < 6 then
41971: LD_VAR 0 4
41975: PUSH
41976: LD_VAR 0 7
41980: PUSH
41981: LD_INT 6
41983: LESS
41984: AND
41985: IFFALSE 42167
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41987: LD_ADDR_VAR 0 9
41991: PUSH
41992: LD_VAR 0 4
41996: PUSH
41997: LD_VAR 0 7
42001: DIFF
42002: PPUSH
42003: LD_INT 3
42005: PPUSH
42006: CALL 105772 0 2
42010: ST_TO_ADDR
// p := [ ] ;
42011: LD_ADDR_VAR 0 11
42015: PUSH
42016: EMPTY
42017: ST_TO_ADDR
// if sort then
42018: LD_VAR 0 9
42022: IFFALSE 42138
// for i = 1 to 6 - mech do
42024: LD_ADDR_VAR 0 3
42028: PUSH
42029: DOUBLE
42030: LD_INT 1
42032: DEC
42033: ST_TO_ADDR
42034: LD_INT 6
42036: PUSH
42037: LD_VAR 0 7
42041: MINUS
42042: PUSH
42043: FOR_TO
42044: IFFALSE 42136
// begin if i = sort then
42046: LD_VAR 0 3
42050: PUSH
42051: LD_VAR 0 9
42055: EQUAL
42056: IFFALSE 42060
// break ;
42058: GO 42136
// if GetClass ( i ) = 3 then
42060: LD_VAR 0 3
42064: PPUSH
42065: CALL_OW 257
42069: PUSH
42070: LD_INT 3
42072: EQUAL
42073: IFFALSE 42077
// continue ;
42075: GO 42043
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42077: LD_ADDR_VAR 0 11
42081: PUSH
42082: LD_VAR 0 11
42086: PPUSH
42087: LD_VAR 0 11
42091: PUSH
42092: LD_INT 1
42094: PLUS
42095: PPUSH
42096: LD_VAR 0 9
42100: PUSH
42101: LD_VAR 0 3
42105: ARRAY
42106: PPUSH
42107: CALL_OW 2
42111: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42112: LD_ADDR_VAR 0 4
42116: PUSH
42117: LD_VAR 0 4
42121: PUSH
42122: LD_VAR 0 9
42126: PUSH
42127: LD_VAR 0 3
42131: ARRAY
42132: DIFF
42133: ST_TO_ADDR
// end ;
42134: GO 42043
42136: POP
42137: POP
// if p then
42138: LD_VAR 0 11
42142: IFFALSE 42167
// result := Replace ( result , 3 , p ) ;
42144: LD_ADDR_VAR 0 2
42148: PUSH
42149: LD_VAR 0 2
42153: PPUSH
42154: LD_INT 3
42156: PPUSH
42157: LD_VAR 0 11
42161: PPUSH
42162: CALL_OW 1
42166: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42167: LD_ADDR_VAR 0 4
42171: PUSH
42172: LD_VAR 0 4
42176: PUSH
42177: LD_VAR 0 6
42181: DIFF
42182: ST_TO_ADDR
// if tmp and eng < 4 then
42183: LD_VAR 0 4
42187: PUSH
42188: LD_VAR 0 6
42192: PUSH
42193: LD_INT 4
42195: LESS
42196: AND
42197: IFFALSE 42387
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42199: LD_ADDR_VAR 0 9
42203: PUSH
42204: LD_VAR 0 4
42208: PUSH
42209: LD_VAR 0 7
42213: PUSH
42214: LD_VAR 0 6
42218: UNION
42219: DIFF
42220: PPUSH
42221: LD_INT 2
42223: PPUSH
42224: CALL 105772 0 2
42228: ST_TO_ADDR
// p := [ ] ;
42229: LD_ADDR_VAR 0 11
42233: PUSH
42234: EMPTY
42235: ST_TO_ADDR
// if sort then
42236: LD_VAR 0 9
42240: IFFALSE 42356
// for i = 1 to 4 - eng do
42242: LD_ADDR_VAR 0 3
42246: PUSH
42247: DOUBLE
42248: LD_INT 1
42250: DEC
42251: ST_TO_ADDR
42252: LD_INT 4
42254: PUSH
42255: LD_VAR 0 6
42259: MINUS
42260: PUSH
42261: FOR_TO
42262: IFFALSE 42354
// begin if i = sort then
42264: LD_VAR 0 3
42268: PUSH
42269: LD_VAR 0 9
42273: EQUAL
42274: IFFALSE 42278
// break ;
42276: GO 42354
// if GetClass ( i ) = 2 then
42278: LD_VAR 0 3
42282: PPUSH
42283: CALL_OW 257
42287: PUSH
42288: LD_INT 2
42290: EQUAL
42291: IFFALSE 42295
// continue ;
42293: GO 42261
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42295: LD_ADDR_VAR 0 11
42299: PUSH
42300: LD_VAR 0 11
42304: PPUSH
42305: LD_VAR 0 11
42309: PUSH
42310: LD_INT 1
42312: PLUS
42313: PPUSH
42314: LD_VAR 0 9
42318: PUSH
42319: LD_VAR 0 3
42323: ARRAY
42324: PPUSH
42325: CALL_OW 2
42329: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42330: LD_ADDR_VAR 0 4
42334: PUSH
42335: LD_VAR 0 4
42339: PUSH
42340: LD_VAR 0 9
42344: PUSH
42345: LD_VAR 0 3
42349: ARRAY
42350: DIFF
42351: ST_TO_ADDR
// end ;
42352: GO 42261
42354: POP
42355: POP
// if p then
42356: LD_VAR 0 11
42360: IFFALSE 42385
// result := Replace ( result , 2 , p ) ;
42362: LD_ADDR_VAR 0 2
42366: PUSH
42367: LD_VAR 0 2
42371: PPUSH
42372: LD_INT 2
42374: PPUSH
42375: LD_VAR 0 11
42379: PPUSH
42380: CALL_OW 1
42384: ST_TO_ADDR
// end else
42385: GO 42431
// for i = eng downto 5 do
42387: LD_ADDR_VAR 0 3
42391: PUSH
42392: DOUBLE
42393: LD_VAR 0 6
42397: INC
42398: ST_TO_ADDR
42399: LD_INT 5
42401: PUSH
42402: FOR_DOWNTO
42403: IFFALSE 42429
// tmp := tmp union eng [ i ] ;
42405: LD_ADDR_VAR 0 4
42409: PUSH
42410: LD_VAR 0 4
42414: PUSH
42415: LD_VAR 0 6
42419: PUSH
42420: LD_VAR 0 3
42424: ARRAY
42425: UNION
42426: ST_TO_ADDR
42427: GO 42402
42429: POP
42430: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42431: LD_ADDR_VAR 0 2
42435: PUSH
42436: LD_VAR 0 2
42440: PPUSH
42441: LD_INT 1
42443: PPUSH
42444: LD_VAR 0 4
42448: PUSH
42449: LD_VAR 0 5
42453: DIFF
42454: PPUSH
42455: CALL_OW 1
42459: ST_TO_ADDR
// exit ;
42460: GO 42462
// end ; end ;
42462: LD_VAR 0 2
42466: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42467: LD_INT 0
42469: PPUSH
42470: PPUSH
42471: PPUSH
// if not mc_bases then
42472: LD_EXP 101
42476: NOT
42477: IFFALSE 42481
// exit ;
42479: GO 42587
// for i = 1 to mc_bases do
42481: LD_ADDR_VAR 0 2
42485: PUSH
42486: DOUBLE
42487: LD_INT 1
42489: DEC
42490: ST_TO_ADDR
42491: LD_EXP 101
42495: PUSH
42496: FOR_TO
42497: IFFALSE 42578
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42499: LD_ADDR_VAR 0 3
42503: PUSH
42504: LD_EXP 101
42508: PUSH
42509: LD_VAR 0 2
42513: ARRAY
42514: PPUSH
42515: LD_INT 21
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: LD_INT 24
42530: PUSH
42531: LD_INT 1000
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PPUSH
42546: CALL_OW 72
42550: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42551: LD_ADDR_EXP 102
42555: PUSH
42556: LD_EXP 102
42560: PPUSH
42561: LD_VAR 0 2
42565: PPUSH
42566: LD_VAR 0 3
42570: PPUSH
42571: CALL_OW 1
42575: ST_TO_ADDR
// end ;
42576: GO 42496
42578: POP
42579: POP
// RaiseSailEvent ( 101 ) ;
42580: LD_INT 101
42582: PPUSH
42583: CALL_OW 427
// end ;
42587: LD_VAR 0 1
42591: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42592: LD_INT 0
42594: PPUSH
42595: PPUSH
42596: PPUSH
42597: PPUSH
42598: PPUSH
42599: PPUSH
42600: PPUSH
// if not mc_bases then
42601: LD_EXP 101
42605: NOT
42606: IFFALSE 42610
// exit ;
42608: GO 43183
// for i = 1 to mc_bases do
42610: LD_ADDR_VAR 0 2
42614: PUSH
42615: DOUBLE
42616: LD_INT 1
42618: DEC
42619: ST_TO_ADDR
42620: LD_EXP 101
42624: PUSH
42625: FOR_TO
42626: IFFALSE 43174
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42628: LD_ADDR_VAR 0 5
42632: PUSH
42633: LD_EXP 101
42637: PUSH
42638: LD_VAR 0 2
42642: ARRAY
42643: PUSH
42644: LD_EXP 130
42648: PUSH
42649: LD_VAR 0 2
42653: ARRAY
42654: UNION
42655: PPUSH
42656: LD_INT 21
42658: PUSH
42659: LD_INT 1
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 1
42668: PUSH
42669: LD_INT 3
42671: PUSH
42672: LD_INT 54
42674: PUSH
42675: EMPTY
42676: LIST
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 3
42684: PUSH
42685: LD_INT 24
42687: PUSH
42688: LD_INT 800
42690: PUSH
42691: EMPTY
42692: LIST
42693: LIST
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: LIST
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PPUSH
42708: CALL_OW 72
42712: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42713: LD_ADDR_VAR 0 6
42717: PUSH
42718: LD_EXP 101
42722: PUSH
42723: LD_VAR 0 2
42727: ARRAY
42728: PPUSH
42729: LD_INT 21
42731: PUSH
42732: LD_INT 1
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: PUSH
42739: LD_INT 1
42741: PUSH
42742: LD_INT 3
42744: PUSH
42745: LD_INT 54
42747: PUSH
42748: EMPTY
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 3
42757: PUSH
42758: LD_INT 24
42760: PUSH
42761: LD_INT 250
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: LIST
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PPUSH
42781: CALL_OW 72
42785: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42786: LD_ADDR_VAR 0 7
42790: PUSH
42791: LD_VAR 0 5
42795: PUSH
42796: LD_VAR 0 6
42800: DIFF
42801: ST_TO_ADDR
// if not need_heal_1 then
42802: LD_VAR 0 6
42806: NOT
42807: IFFALSE 42840
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42809: LD_ADDR_EXP 104
42813: PUSH
42814: LD_EXP 104
42818: PPUSH
42819: LD_VAR 0 2
42823: PUSH
42824: LD_INT 1
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: PPUSH
42831: EMPTY
42832: PPUSH
42833: CALL 71498 0 3
42837: ST_TO_ADDR
42838: GO 42910
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42840: LD_ADDR_EXP 104
42844: PUSH
42845: LD_EXP 104
42849: PPUSH
42850: LD_VAR 0 2
42854: PUSH
42855: LD_INT 1
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PPUSH
42862: LD_EXP 104
42866: PUSH
42867: LD_VAR 0 2
42871: ARRAY
42872: PUSH
42873: LD_INT 1
42875: ARRAY
42876: PPUSH
42877: LD_INT 3
42879: PUSH
42880: LD_INT 24
42882: PUSH
42883: LD_INT 1000
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PPUSH
42894: CALL_OW 72
42898: PUSH
42899: LD_VAR 0 6
42903: UNION
42904: PPUSH
42905: CALL 71498 0 3
42909: ST_TO_ADDR
// if not need_heal_2 then
42910: LD_VAR 0 7
42914: NOT
42915: IFFALSE 42948
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42917: LD_ADDR_EXP 104
42921: PUSH
42922: LD_EXP 104
42926: PPUSH
42927: LD_VAR 0 2
42931: PUSH
42932: LD_INT 2
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PPUSH
42939: EMPTY
42940: PPUSH
42941: CALL 71498 0 3
42945: ST_TO_ADDR
42946: GO 42980
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42948: LD_ADDR_EXP 104
42952: PUSH
42953: LD_EXP 104
42957: PPUSH
42958: LD_VAR 0 2
42962: PUSH
42963: LD_INT 2
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PPUSH
42970: LD_VAR 0 7
42974: PPUSH
42975: CALL 71498 0 3
42979: ST_TO_ADDR
// if need_heal_2 then
42980: LD_VAR 0 7
42984: IFFALSE 43156
// for j in need_heal_2 do
42986: LD_ADDR_VAR 0 3
42990: PUSH
42991: LD_VAR 0 7
42995: PUSH
42996: FOR_IN
42997: IFFALSE 43154
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42999: LD_ADDR_VAR 0 5
43003: PUSH
43004: LD_EXP 101
43008: PUSH
43009: LD_VAR 0 2
43013: ARRAY
43014: PPUSH
43015: LD_INT 2
43017: PUSH
43018: LD_INT 30
43020: PUSH
43021: LD_INT 6
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PUSH
43028: LD_INT 30
43030: PUSH
43031: LD_INT 7
43033: PUSH
43034: EMPTY
43035: LIST
43036: LIST
43037: PUSH
43038: LD_INT 30
43040: PUSH
43041: LD_INT 8
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: LD_INT 30
43050: PUSH
43051: LD_INT 0
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: LD_INT 30
43060: PUSH
43061: LD_INT 1
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: LD_INT 25
43070: PUSH
43071: LD_INT 4
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: LIST
43082: LIST
43083: LIST
43084: LIST
43085: LIST
43086: PPUSH
43087: CALL_OW 72
43091: ST_TO_ADDR
// if tmp then
43092: LD_VAR 0 5
43096: IFFALSE 43152
// begin k := NearestUnitToUnit ( tmp , j ) ;
43098: LD_ADDR_VAR 0 4
43102: PUSH
43103: LD_VAR 0 5
43107: PPUSH
43108: LD_VAR 0 3
43112: PPUSH
43113: CALL_OW 74
43117: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43118: LD_VAR 0 3
43122: PPUSH
43123: LD_VAR 0 4
43127: PPUSH
43128: CALL_OW 296
43132: PUSH
43133: LD_INT 7
43135: GREATER
43136: IFFALSE 43152
// ComMoveUnit ( j , k ) ;
43138: LD_VAR 0 3
43142: PPUSH
43143: LD_VAR 0 4
43147: PPUSH
43148: CALL_OW 112
// end ; end ;
43152: GO 42996
43154: POP
43155: POP
// if not need_heal_1 and not need_heal_2 then
43156: LD_VAR 0 6
43160: NOT
43161: PUSH
43162: LD_VAR 0 7
43166: NOT
43167: AND
43168: IFFALSE 43172
// continue ;
43170: GO 42625
// end ;
43172: GO 42625
43174: POP
43175: POP
// RaiseSailEvent ( 102 ) ;
43176: LD_INT 102
43178: PPUSH
43179: CALL_OW 427
// end ;
43183: LD_VAR 0 1
43187: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43188: LD_INT 0
43190: PPUSH
43191: PPUSH
43192: PPUSH
43193: PPUSH
43194: PPUSH
43195: PPUSH
43196: PPUSH
43197: PPUSH
// if not mc_bases then
43198: LD_EXP 101
43202: NOT
43203: IFFALSE 43207
// exit ;
43205: GO 44047
// for i = 1 to mc_bases do
43207: LD_ADDR_VAR 0 2
43211: PUSH
43212: DOUBLE
43213: LD_INT 1
43215: DEC
43216: ST_TO_ADDR
43217: LD_EXP 101
43221: PUSH
43222: FOR_TO
43223: IFFALSE 44045
// begin if not mc_building_need_repair [ i ] then
43225: LD_EXP 102
43229: PUSH
43230: LD_VAR 0 2
43234: ARRAY
43235: NOT
43236: IFFALSE 43410
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43238: LD_ADDR_VAR 0 6
43242: PUSH
43243: LD_EXP 120
43247: PUSH
43248: LD_VAR 0 2
43252: ARRAY
43253: PPUSH
43254: LD_INT 3
43256: PUSH
43257: LD_INT 24
43259: PUSH
43260: LD_INT 1000
43262: PUSH
43263: EMPTY
43264: LIST
43265: LIST
43266: PUSH
43267: EMPTY
43268: LIST
43269: LIST
43270: PUSH
43271: LD_INT 2
43273: PUSH
43274: LD_INT 34
43276: PUSH
43277: LD_INT 13
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 34
43286: PUSH
43287: LD_INT 52
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PUSH
43294: EMPTY
43295: LIST
43296: LIST
43297: LIST
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PPUSH
43303: CALL_OW 72
43307: ST_TO_ADDR
// if cranes then
43308: LD_VAR 0 6
43312: IFFALSE 43374
// for j in cranes do
43314: LD_ADDR_VAR 0 3
43318: PUSH
43319: LD_VAR 0 6
43323: PUSH
43324: FOR_IN
43325: IFFALSE 43372
// if not IsInArea ( j , mc_parking [ i ] ) then
43327: LD_VAR 0 3
43331: PPUSH
43332: LD_EXP 125
43336: PUSH
43337: LD_VAR 0 2
43341: ARRAY
43342: PPUSH
43343: CALL_OW 308
43347: NOT
43348: IFFALSE 43370
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43350: LD_VAR 0 3
43354: PPUSH
43355: LD_EXP 125
43359: PUSH
43360: LD_VAR 0 2
43364: ARRAY
43365: PPUSH
43366: CALL_OW 113
43370: GO 43324
43372: POP
43373: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43374: LD_ADDR_EXP 103
43378: PUSH
43379: LD_EXP 103
43383: PPUSH
43384: LD_VAR 0 2
43388: PPUSH
43389: EMPTY
43390: PPUSH
43391: CALL_OW 1
43395: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43396: LD_VAR 0 2
43400: PPUSH
43401: LD_INT 101
43403: PPUSH
43404: CALL 38300 0 2
// continue ;
43408: GO 43222
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43410: LD_ADDR_EXP 107
43414: PUSH
43415: LD_EXP 107
43419: PPUSH
43420: LD_VAR 0 2
43424: PPUSH
43425: EMPTY
43426: PPUSH
43427: CALL_OW 1
43431: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43432: LD_VAR 0 2
43436: PPUSH
43437: LD_INT 103
43439: PPUSH
43440: CALL 38300 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43444: LD_ADDR_VAR 0 5
43448: PUSH
43449: LD_EXP 101
43453: PUSH
43454: LD_VAR 0 2
43458: ARRAY
43459: PUSH
43460: LD_EXP 130
43464: PUSH
43465: LD_VAR 0 2
43469: ARRAY
43470: UNION
43471: PPUSH
43472: LD_INT 2
43474: PUSH
43475: LD_INT 25
43477: PUSH
43478: LD_INT 2
43480: PUSH
43481: EMPTY
43482: LIST
43483: LIST
43484: PUSH
43485: LD_INT 25
43487: PUSH
43488: LD_INT 16
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: LIST
43499: PUSH
43500: EMPTY
43501: LIST
43502: PPUSH
43503: CALL_OW 72
43507: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43508: LD_ADDR_VAR 0 6
43512: PUSH
43513: LD_EXP 120
43517: PUSH
43518: LD_VAR 0 2
43522: ARRAY
43523: PPUSH
43524: LD_INT 2
43526: PUSH
43527: LD_INT 34
43529: PUSH
43530: LD_INT 13
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 34
43539: PUSH
43540: LD_INT 52
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: LIST
43551: PPUSH
43552: CALL_OW 72
43556: ST_TO_ADDR
// if cranes then
43557: LD_VAR 0 6
43561: IFFALSE 43697
// begin for j in cranes do
43563: LD_ADDR_VAR 0 3
43567: PUSH
43568: LD_VAR 0 6
43572: PUSH
43573: FOR_IN
43574: IFFALSE 43695
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43576: LD_VAR 0 3
43580: PPUSH
43581: CALL_OW 256
43585: PUSH
43586: LD_INT 500
43588: GREATEREQUAL
43589: PUSH
43590: LD_VAR 0 3
43594: PPUSH
43595: CALL_OW 314
43599: NOT
43600: AND
43601: IFFALSE 43635
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43603: LD_VAR 0 3
43607: PPUSH
43608: LD_EXP 102
43612: PUSH
43613: LD_VAR 0 2
43617: ARRAY
43618: PPUSH
43619: LD_VAR 0 3
43623: PPUSH
43624: CALL_OW 74
43628: PPUSH
43629: CALL_OW 130
43633: GO 43693
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43635: LD_VAR 0 3
43639: PPUSH
43640: CALL_OW 256
43644: PUSH
43645: LD_INT 500
43647: LESS
43648: PUSH
43649: LD_VAR 0 3
43653: PPUSH
43654: LD_EXP 125
43658: PUSH
43659: LD_VAR 0 2
43663: ARRAY
43664: PPUSH
43665: CALL_OW 308
43669: NOT
43670: AND
43671: IFFALSE 43693
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43673: LD_VAR 0 3
43677: PPUSH
43678: LD_EXP 125
43682: PUSH
43683: LD_VAR 0 2
43687: ARRAY
43688: PPUSH
43689: CALL_OW 113
43693: GO 43573
43695: POP
43696: POP
// end ; if not tmp then
43697: LD_VAR 0 5
43701: NOT
43702: IFFALSE 43706
// continue ;
43704: GO 43222
// for j in tmp do
43706: LD_ADDR_VAR 0 3
43710: PUSH
43711: LD_VAR 0 5
43715: PUSH
43716: FOR_IN
43717: IFFALSE 44041
// begin if mc_need_heal [ i ] then
43719: LD_EXP 104
43723: PUSH
43724: LD_VAR 0 2
43728: ARRAY
43729: IFFALSE 43777
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43731: LD_VAR 0 3
43735: PUSH
43736: LD_EXP 104
43740: PUSH
43741: LD_VAR 0 2
43745: ARRAY
43746: PUSH
43747: LD_INT 1
43749: ARRAY
43750: IN
43751: PUSH
43752: LD_VAR 0 3
43756: PUSH
43757: LD_EXP 104
43761: PUSH
43762: LD_VAR 0 2
43766: ARRAY
43767: PUSH
43768: LD_INT 2
43770: ARRAY
43771: IN
43772: OR
43773: IFFALSE 43777
// continue ;
43775: GO 43716
// if IsInUnit ( j ) then
43777: LD_VAR 0 3
43781: PPUSH
43782: CALL_OW 310
43786: IFFALSE 43797
// ComExitBuilding ( j ) ;
43788: LD_VAR 0 3
43792: PPUSH
43793: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43797: LD_VAR 0 3
43801: PUSH
43802: LD_EXP 103
43806: PUSH
43807: LD_VAR 0 2
43811: ARRAY
43812: IN
43813: NOT
43814: IFFALSE 43872
// begin SetTag ( j , 101 ) ;
43816: LD_VAR 0 3
43820: PPUSH
43821: LD_INT 101
43823: PPUSH
43824: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43828: LD_ADDR_EXP 103
43832: PUSH
43833: LD_EXP 103
43837: PPUSH
43838: LD_VAR 0 2
43842: PUSH
43843: LD_EXP 103
43847: PUSH
43848: LD_VAR 0 2
43852: ARRAY
43853: PUSH
43854: LD_INT 1
43856: PLUS
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PPUSH
43862: LD_VAR 0 3
43866: PPUSH
43867: CALL 71498 0 3
43871: ST_TO_ADDR
// end ; wait ( 1 ) ;
43872: LD_INT 1
43874: PPUSH
43875: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
43879: LD_ADDR_VAR 0 7
43883: PUSH
43884: LD_EXP 102
43888: PUSH
43889: LD_VAR 0 2
43893: ARRAY
43894: ST_TO_ADDR
// if mc_scan [ i ] then
43895: LD_EXP 124
43899: PUSH
43900: LD_VAR 0 2
43904: ARRAY
43905: IFFALSE 43974
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
43907: LD_ADDR_VAR 0 7
43911: PUSH
43912: LD_EXP 102
43916: PUSH
43917: LD_VAR 0 2
43921: ARRAY
43922: PPUSH
43923: LD_INT 3
43925: PUSH
43926: LD_INT 2
43928: PUSH
43929: LD_INT 30
43931: PUSH
43932: LD_INT 32
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 30
43941: PUSH
43942: LD_INT 33
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 30
43951: PUSH
43952: LD_INT 31
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: EMPTY
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PPUSH
43969: CALL_OW 72
43973: ST_TO_ADDR
// if not to_repair_tmp then
43974: LD_VAR 0 7
43978: NOT
43979: IFFALSE 43983
// continue ;
43981: GO 43716
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
43983: LD_ADDR_VAR 0 8
43987: PUSH
43988: LD_VAR 0 7
43992: PPUSH
43993: LD_VAR 0 3
43997: PPUSH
43998: CALL_OW 74
44002: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44003: LD_VAR 0 8
44007: PPUSH
44008: LD_INT 14
44010: PPUSH
44011: CALL 74091 0 2
44015: PUSH
44016: LD_INT 4
44018: ARRAY
44019: PUSH
44020: LD_INT 5
44022: LESS
44023: IFFALSE 44039
// ComRepairBuilding ( j , to_repair ) ;
44025: LD_VAR 0 3
44029: PPUSH
44030: LD_VAR 0 8
44034: PPUSH
44035: CALL_OW 130
// end ;
44039: GO 43716
44041: POP
44042: POP
// end ;
44043: GO 43222
44045: POP
44046: POP
// end ;
44047: LD_VAR 0 1
44051: RET
// export function MC_Heal ; var i , j , tmp ; begin
44052: LD_INT 0
44054: PPUSH
44055: PPUSH
44056: PPUSH
44057: PPUSH
// if not mc_bases then
44058: LD_EXP 101
44062: NOT
44063: IFFALSE 44067
// exit ;
44065: GO 44469
// for i = 1 to mc_bases do
44067: LD_ADDR_VAR 0 2
44071: PUSH
44072: DOUBLE
44073: LD_INT 1
44075: DEC
44076: ST_TO_ADDR
44077: LD_EXP 101
44081: PUSH
44082: FOR_TO
44083: IFFALSE 44467
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44085: LD_EXP 104
44089: PUSH
44090: LD_VAR 0 2
44094: ARRAY
44095: PUSH
44096: LD_INT 1
44098: ARRAY
44099: NOT
44100: PUSH
44101: LD_EXP 104
44105: PUSH
44106: LD_VAR 0 2
44110: ARRAY
44111: PUSH
44112: LD_INT 2
44114: ARRAY
44115: NOT
44116: AND
44117: IFFALSE 44155
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44119: LD_ADDR_EXP 105
44123: PUSH
44124: LD_EXP 105
44128: PPUSH
44129: LD_VAR 0 2
44133: PPUSH
44134: EMPTY
44135: PPUSH
44136: CALL_OW 1
44140: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44141: LD_VAR 0 2
44145: PPUSH
44146: LD_INT 102
44148: PPUSH
44149: CALL 38300 0 2
// continue ;
44153: GO 44082
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44155: LD_ADDR_VAR 0 4
44159: PUSH
44160: LD_EXP 101
44164: PUSH
44165: LD_VAR 0 2
44169: ARRAY
44170: PPUSH
44171: LD_INT 25
44173: PUSH
44174: LD_INT 4
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PPUSH
44181: CALL_OW 72
44185: ST_TO_ADDR
// if not tmp then
44186: LD_VAR 0 4
44190: NOT
44191: IFFALSE 44195
// continue ;
44193: GO 44082
// if mc_taming [ i ] then
44195: LD_EXP 132
44199: PUSH
44200: LD_VAR 0 2
44204: ARRAY
44205: IFFALSE 44229
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44207: LD_ADDR_EXP 132
44211: PUSH
44212: LD_EXP 132
44216: PPUSH
44217: LD_VAR 0 2
44221: PPUSH
44222: EMPTY
44223: PPUSH
44224: CALL_OW 1
44228: ST_TO_ADDR
// for j in tmp do
44229: LD_ADDR_VAR 0 3
44233: PUSH
44234: LD_VAR 0 4
44238: PUSH
44239: FOR_IN
44240: IFFALSE 44463
// begin if IsInUnit ( j ) then
44242: LD_VAR 0 3
44246: PPUSH
44247: CALL_OW 310
44251: IFFALSE 44262
// ComExitBuilding ( j ) ;
44253: LD_VAR 0 3
44257: PPUSH
44258: CALL_OW 122
// if not j in mc_healers [ i ] then
44262: LD_VAR 0 3
44266: PUSH
44267: LD_EXP 105
44271: PUSH
44272: LD_VAR 0 2
44276: ARRAY
44277: IN
44278: NOT
44279: IFFALSE 44325
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44281: LD_ADDR_EXP 105
44285: PUSH
44286: LD_EXP 105
44290: PPUSH
44291: LD_VAR 0 2
44295: PUSH
44296: LD_EXP 105
44300: PUSH
44301: LD_VAR 0 2
44305: ARRAY
44306: PUSH
44307: LD_INT 1
44309: PLUS
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PPUSH
44315: LD_VAR 0 3
44319: PPUSH
44320: CALL 71498 0 3
44324: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44325: LD_VAR 0 3
44329: PPUSH
44330: CALL_OW 110
44334: PUSH
44335: LD_INT 102
44337: NONEQUAL
44338: IFFALSE 44352
// SetTag ( j , 102 ) ;
44340: LD_VAR 0 3
44344: PPUSH
44345: LD_INT 102
44347: PPUSH
44348: CALL_OW 109
// Wait ( 3 ) ;
44352: LD_INT 3
44354: PPUSH
44355: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44359: LD_EXP 104
44363: PUSH
44364: LD_VAR 0 2
44368: ARRAY
44369: PUSH
44370: LD_INT 1
44372: ARRAY
44373: IFFALSE 44405
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44375: LD_VAR 0 3
44379: PPUSH
44380: LD_EXP 104
44384: PUSH
44385: LD_VAR 0 2
44389: ARRAY
44390: PUSH
44391: LD_INT 1
44393: ARRAY
44394: PUSH
44395: LD_INT 1
44397: ARRAY
44398: PPUSH
44399: CALL_OW 128
44403: GO 44461
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44405: LD_VAR 0 3
44409: PPUSH
44410: CALL_OW 314
44414: NOT
44415: PUSH
44416: LD_EXP 104
44420: PUSH
44421: LD_VAR 0 2
44425: ARRAY
44426: PUSH
44427: LD_INT 2
44429: ARRAY
44430: AND
44431: IFFALSE 44461
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44433: LD_VAR 0 3
44437: PPUSH
44438: LD_EXP 104
44442: PUSH
44443: LD_VAR 0 2
44447: ARRAY
44448: PUSH
44449: LD_INT 2
44451: ARRAY
44452: PUSH
44453: LD_INT 1
44455: ARRAY
44456: PPUSH
44457: CALL_OW 128
// end ;
44461: GO 44239
44463: POP
44464: POP
// end ;
44465: GO 44082
44467: POP
44468: POP
// end ;
44469: LD_VAR 0 1
44473: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44474: LD_INT 0
44476: PPUSH
44477: PPUSH
44478: PPUSH
44479: PPUSH
44480: PPUSH
// if not mc_bases then
44481: LD_EXP 101
44485: NOT
44486: IFFALSE 44490
// exit ;
44488: GO 45633
// for i = 1 to mc_bases do
44490: LD_ADDR_VAR 0 2
44494: PUSH
44495: DOUBLE
44496: LD_INT 1
44498: DEC
44499: ST_TO_ADDR
44500: LD_EXP 101
44504: PUSH
44505: FOR_TO
44506: IFFALSE 45631
// begin if mc_scan [ i ] then
44508: LD_EXP 124
44512: PUSH
44513: LD_VAR 0 2
44517: ARRAY
44518: IFFALSE 44522
// continue ;
44520: GO 44505
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44522: LD_EXP 106
44526: PUSH
44527: LD_VAR 0 2
44531: ARRAY
44532: NOT
44533: PUSH
44534: LD_EXP 108
44538: PUSH
44539: LD_VAR 0 2
44543: ARRAY
44544: NOT
44545: AND
44546: PUSH
44547: LD_EXP 107
44551: PUSH
44552: LD_VAR 0 2
44556: ARRAY
44557: AND
44558: IFFALSE 44596
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44560: LD_ADDR_EXP 107
44564: PUSH
44565: LD_EXP 107
44569: PPUSH
44570: LD_VAR 0 2
44574: PPUSH
44575: EMPTY
44576: PPUSH
44577: CALL_OW 1
44581: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44582: LD_VAR 0 2
44586: PPUSH
44587: LD_INT 103
44589: PPUSH
44590: CALL 38300 0 2
// continue ;
44594: GO 44505
// end ; if mc_construct_list [ i ] then
44596: LD_EXP 108
44600: PUSH
44601: LD_VAR 0 2
44605: ARRAY
44606: IFFALSE 44826
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44608: LD_ADDR_VAR 0 4
44612: PUSH
44613: LD_EXP 101
44617: PUSH
44618: LD_VAR 0 2
44622: ARRAY
44623: PPUSH
44624: LD_INT 25
44626: PUSH
44627: LD_INT 2
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PPUSH
44634: CALL_OW 72
44638: PUSH
44639: LD_EXP 103
44643: PUSH
44644: LD_VAR 0 2
44648: ARRAY
44649: DIFF
44650: ST_TO_ADDR
// if not tmp then
44651: LD_VAR 0 4
44655: NOT
44656: IFFALSE 44660
// continue ;
44658: GO 44505
// for j in tmp do
44660: LD_ADDR_VAR 0 3
44664: PUSH
44665: LD_VAR 0 4
44669: PUSH
44670: FOR_IN
44671: IFFALSE 44822
// begin if not mc_builders [ i ] then
44673: LD_EXP 107
44677: PUSH
44678: LD_VAR 0 2
44682: ARRAY
44683: NOT
44684: IFFALSE 44742
// begin SetTag ( j , 103 ) ;
44686: LD_VAR 0 3
44690: PPUSH
44691: LD_INT 103
44693: PPUSH
44694: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44698: LD_ADDR_EXP 107
44702: PUSH
44703: LD_EXP 107
44707: PPUSH
44708: LD_VAR 0 2
44712: PUSH
44713: LD_EXP 107
44717: PUSH
44718: LD_VAR 0 2
44722: ARRAY
44723: PUSH
44724: LD_INT 1
44726: PLUS
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PPUSH
44732: LD_VAR 0 3
44736: PPUSH
44737: CALL 71498 0 3
44741: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44742: LD_VAR 0 3
44746: PPUSH
44747: CALL_OW 310
44751: IFFALSE 44762
// ComExitBuilding ( j ) ;
44753: LD_VAR 0 3
44757: PPUSH
44758: CALL_OW 122
// wait ( 3 ) ;
44762: LD_INT 3
44764: PPUSH
44765: CALL_OW 67
// if not mc_construct_list [ i ] then
44769: LD_EXP 108
44773: PUSH
44774: LD_VAR 0 2
44778: ARRAY
44779: NOT
44780: IFFALSE 44784
// break ;
44782: GO 44822
// if not HasTask ( j ) then
44784: LD_VAR 0 3
44788: PPUSH
44789: CALL_OW 314
44793: NOT
44794: IFFALSE 44820
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44796: LD_VAR 0 3
44800: PPUSH
44801: LD_EXP 108
44805: PUSH
44806: LD_VAR 0 2
44810: ARRAY
44811: PUSH
44812: LD_INT 1
44814: ARRAY
44815: PPUSH
44816: CALL 74349 0 2
// end ;
44820: GO 44670
44822: POP
44823: POP
// end else
44824: GO 45629
// if mc_build_list [ i ] then
44826: LD_EXP 106
44830: PUSH
44831: LD_VAR 0 2
44835: ARRAY
44836: IFFALSE 45629
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44838: LD_ADDR_VAR 0 5
44842: PUSH
44843: LD_EXP 101
44847: PUSH
44848: LD_VAR 0 2
44852: ARRAY
44853: PPUSH
44854: LD_INT 2
44856: PUSH
44857: LD_INT 30
44859: PUSH
44860: LD_INT 0
44862: PUSH
44863: EMPTY
44864: LIST
44865: LIST
44866: PUSH
44867: LD_INT 30
44869: PUSH
44870: LD_INT 1
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: LIST
44881: PPUSH
44882: CALL_OW 72
44886: ST_TO_ADDR
// if depot then
44887: LD_VAR 0 5
44891: IFFALSE 44909
// depot := depot [ 1 ] else
44893: LD_ADDR_VAR 0 5
44897: PUSH
44898: LD_VAR 0 5
44902: PUSH
44903: LD_INT 1
44905: ARRAY
44906: ST_TO_ADDR
44907: GO 44917
// depot := 0 ;
44909: LD_ADDR_VAR 0 5
44913: PUSH
44914: LD_INT 0
44916: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44917: LD_EXP 106
44921: PUSH
44922: LD_VAR 0 2
44926: ARRAY
44927: PUSH
44928: LD_INT 1
44930: ARRAY
44931: PUSH
44932: LD_INT 1
44934: ARRAY
44935: PPUSH
44936: CALL 74179 0 1
44940: PUSH
44941: LD_EXP 101
44945: PUSH
44946: LD_VAR 0 2
44950: ARRAY
44951: PPUSH
44952: LD_INT 2
44954: PUSH
44955: LD_INT 30
44957: PUSH
44958: LD_INT 2
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 30
44967: PUSH
44968: LD_INT 3
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: LIST
44979: PPUSH
44980: CALL_OW 72
44984: NOT
44985: AND
44986: IFFALSE 45091
// begin for j = 1 to mc_build_list [ i ] do
44988: LD_ADDR_VAR 0 3
44992: PUSH
44993: DOUBLE
44994: LD_INT 1
44996: DEC
44997: ST_TO_ADDR
44998: LD_EXP 106
45002: PUSH
45003: LD_VAR 0 2
45007: ARRAY
45008: PUSH
45009: FOR_TO
45010: IFFALSE 45089
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45012: LD_EXP 106
45016: PUSH
45017: LD_VAR 0 2
45021: ARRAY
45022: PUSH
45023: LD_VAR 0 3
45027: ARRAY
45028: PUSH
45029: LD_INT 1
45031: ARRAY
45032: PUSH
45033: LD_INT 2
45035: EQUAL
45036: IFFALSE 45087
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45038: LD_ADDR_EXP 106
45042: PUSH
45043: LD_EXP 106
45047: PPUSH
45048: LD_VAR 0 2
45052: PPUSH
45053: LD_EXP 106
45057: PUSH
45058: LD_VAR 0 2
45062: ARRAY
45063: PPUSH
45064: LD_VAR 0 3
45068: PPUSH
45069: LD_INT 1
45071: PPUSH
45072: LD_INT 0
45074: PPUSH
45075: CALL 70916 0 4
45079: PPUSH
45080: CALL_OW 1
45084: ST_TO_ADDR
// break ;
45085: GO 45089
// end ;
45087: GO 45009
45089: POP
45090: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45091: LD_EXP 106
45095: PUSH
45096: LD_VAR 0 2
45100: ARRAY
45101: PUSH
45102: LD_INT 1
45104: ARRAY
45105: PUSH
45106: LD_INT 1
45108: ARRAY
45109: PUSH
45110: LD_INT 0
45112: EQUAL
45113: PUSH
45114: LD_VAR 0 5
45118: PUSH
45119: LD_VAR 0 5
45123: PPUSH
45124: LD_EXP 106
45128: PUSH
45129: LD_VAR 0 2
45133: ARRAY
45134: PUSH
45135: LD_INT 1
45137: ARRAY
45138: PUSH
45139: LD_INT 1
45141: ARRAY
45142: PPUSH
45143: LD_EXP 106
45147: PUSH
45148: LD_VAR 0 2
45152: ARRAY
45153: PUSH
45154: LD_INT 1
45156: ARRAY
45157: PUSH
45158: LD_INT 2
45160: ARRAY
45161: PPUSH
45162: LD_EXP 106
45166: PUSH
45167: LD_VAR 0 2
45171: ARRAY
45172: PUSH
45173: LD_INT 1
45175: ARRAY
45176: PUSH
45177: LD_INT 3
45179: ARRAY
45180: PPUSH
45181: LD_EXP 106
45185: PUSH
45186: LD_VAR 0 2
45190: ARRAY
45191: PUSH
45192: LD_INT 1
45194: ARRAY
45195: PUSH
45196: LD_INT 4
45198: ARRAY
45199: PPUSH
45200: CALL 78913 0 5
45204: AND
45205: OR
45206: IFFALSE 45487
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45208: LD_ADDR_VAR 0 4
45212: PUSH
45213: LD_EXP 101
45217: PUSH
45218: LD_VAR 0 2
45222: ARRAY
45223: PPUSH
45224: LD_INT 25
45226: PUSH
45227: LD_INT 2
45229: PUSH
45230: EMPTY
45231: LIST
45232: LIST
45233: PPUSH
45234: CALL_OW 72
45238: PUSH
45239: LD_EXP 103
45243: PUSH
45244: LD_VAR 0 2
45248: ARRAY
45249: DIFF
45250: ST_TO_ADDR
// if not tmp then
45251: LD_VAR 0 4
45255: NOT
45256: IFFALSE 45260
// continue ;
45258: GO 44505
// for j in tmp do
45260: LD_ADDR_VAR 0 3
45264: PUSH
45265: LD_VAR 0 4
45269: PUSH
45270: FOR_IN
45271: IFFALSE 45483
// begin if not mc_builders [ i ] then
45273: LD_EXP 107
45277: PUSH
45278: LD_VAR 0 2
45282: ARRAY
45283: NOT
45284: IFFALSE 45342
// begin SetTag ( j , 103 ) ;
45286: LD_VAR 0 3
45290: PPUSH
45291: LD_INT 103
45293: PPUSH
45294: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45298: LD_ADDR_EXP 107
45302: PUSH
45303: LD_EXP 107
45307: PPUSH
45308: LD_VAR 0 2
45312: PUSH
45313: LD_EXP 107
45317: PUSH
45318: LD_VAR 0 2
45322: ARRAY
45323: PUSH
45324: LD_INT 1
45326: PLUS
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PPUSH
45332: LD_VAR 0 3
45336: PPUSH
45337: CALL 71498 0 3
45341: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45342: LD_VAR 0 3
45346: PPUSH
45347: CALL_OW 310
45351: IFFALSE 45362
// ComExitBuilding ( j ) ;
45353: LD_VAR 0 3
45357: PPUSH
45358: CALL_OW 122
// wait ( 3 ) ;
45362: LD_INT 3
45364: PPUSH
45365: CALL_OW 67
// if not mc_build_list [ i ] then
45369: LD_EXP 106
45373: PUSH
45374: LD_VAR 0 2
45378: ARRAY
45379: NOT
45380: IFFALSE 45384
// break ;
45382: GO 45483
// if not HasTask ( j ) then
45384: LD_VAR 0 3
45388: PPUSH
45389: CALL_OW 314
45393: NOT
45394: IFFALSE 45481
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45396: LD_VAR 0 3
45400: PPUSH
45401: LD_EXP 106
45405: PUSH
45406: LD_VAR 0 2
45410: ARRAY
45411: PUSH
45412: LD_INT 1
45414: ARRAY
45415: PUSH
45416: LD_INT 1
45418: ARRAY
45419: PPUSH
45420: LD_EXP 106
45424: PUSH
45425: LD_VAR 0 2
45429: ARRAY
45430: PUSH
45431: LD_INT 1
45433: ARRAY
45434: PUSH
45435: LD_INT 2
45437: ARRAY
45438: PPUSH
45439: LD_EXP 106
45443: PUSH
45444: LD_VAR 0 2
45448: ARRAY
45449: PUSH
45450: LD_INT 1
45452: ARRAY
45453: PUSH
45454: LD_INT 3
45456: ARRAY
45457: PPUSH
45458: LD_EXP 106
45462: PUSH
45463: LD_VAR 0 2
45467: ARRAY
45468: PUSH
45469: LD_INT 1
45471: ARRAY
45472: PUSH
45473: LD_INT 4
45475: ARRAY
45476: PPUSH
45477: CALL_OW 145
// end ;
45481: GO 45270
45483: POP
45484: POP
// end else
45485: GO 45629
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45487: LD_EXP 101
45491: PUSH
45492: LD_VAR 0 2
45496: ARRAY
45497: PPUSH
45498: LD_EXP 106
45502: PUSH
45503: LD_VAR 0 2
45507: ARRAY
45508: PUSH
45509: LD_INT 1
45511: ARRAY
45512: PUSH
45513: LD_INT 1
45515: ARRAY
45516: PPUSH
45517: LD_EXP 106
45521: PUSH
45522: LD_VAR 0 2
45526: ARRAY
45527: PUSH
45528: LD_INT 1
45530: ARRAY
45531: PUSH
45532: LD_INT 2
45534: ARRAY
45535: PPUSH
45536: LD_EXP 106
45540: PUSH
45541: LD_VAR 0 2
45545: ARRAY
45546: PUSH
45547: LD_INT 1
45549: ARRAY
45550: PUSH
45551: LD_INT 3
45553: ARRAY
45554: PPUSH
45555: LD_EXP 106
45559: PUSH
45560: LD_VAR 0 2
45564: ARRAY
45565: PUSH
45566: LD_INT 1
45568: ARRAY
45569: PUSH
45570: LD_INT 4
45572: ARRAY
45573: PPUSH
45574: CALL 78249 0 5
45578: NOT
45579: IFFALSE 45629
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45581: LD_ADDR_EXP 106
45585: PUSH
45586: LD_EXP 106
45590: PPUSH
45591: LD_VAR 0 2
45595: PPUSH
45596: LD_EXP 106
45600: PUSH
45601: LD_VAR 0 2
45605: ARRAY
45606: PPUSH
45607: LD_INT 1
45609: PPUSH
45610: LD_INT 1
45612: NEG
45613: PPUSH
45614: LD_INT 0
45616: PPUSH
45617: CALL 70916 0 4
45621: PPUSH
45622: CALL_OW 1
45626: ST_TO_ADDR
// continue ;
45627: GO 44505
// end ; end ; end ;
45629: GO 44505
45631: POP
45632: POP
// end ;
45633: LD_VAR 0 1
45637: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45638: LD_INT 0
45640: PPUSH
45641: PPUSH
45642: PPUSH
45643: PPUSH
45644: PPUSH
45645: PPUSH
// if not mc_bases then
45646: LD_EXP 101
45650: NOT
45651: IFFALSE 45655
// exit ;
45653: GO 46082
// for i = 1 to mc_bases do
45655: LD_ADDR_VAR 0 2
45659: PUSH
45660: DOUBLE
45661: LD_INT 1
45663: DEC
45664: ST_TO_ADDR
45665: LD_EXP 101
45669: PUSH
45670: FOR_TO
45671: IFFALSE 46080
// begin tmp := mc_build_upgrade [ i ] ;
45673: LD_ADDR_VAR 0 4
45677: PUSH
45678: LD_EXP 133
45682: PUSH
45683: LD_VAR 0 2
45687: ARRAY
45688: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45689: LD_ADDR_VAR 0 6
45693: PUSH
45694: LD_EXP 134
45698: PUSH
45699: LD_VAR 0 2
45703: ARRAY
45704: PPUSH
45705: LD_INT 2
45707: PUSH
45708: LD_INT 30
45710: PUSH
45711: LD_INT 6
45713: PUSH
45714: EMPTY
45715: LIST
45716: LIST
45717: PUSH
45718: LD_INT 30
45720: PUSH
45721: LD_INT 7
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: LIST
45732: PPUSH
45733: CALL_OW 72
45737: ST_TO_ADDR
// if not tmp and not lab then
45738: LD_VAR 0 4
45742: NOT
45743: PUSH
45744: LD_VAR 0 6
45748: NOT
45749: AND
45750: IFFALSE 45754
// continue ;
45752: GO 45670
// if tmp then
45754: LD_VAR 0 4
45758: IFFALSE 45878
// for j in tmp do
45760: LD_ADDR_VAR 0 3
45764: PUSH
45765: LD_VAR 0 4
45769: PUSH
45770: FOR_IN
45771: IFFALSE 45876
// begin if UpgradeCost ( j ) then
45773: LD_VAR 0 3
45777: PPUSH
45778: CALL 77909 0 1
45782: IFFALSE 45874
// begin ComUpgrade ( j ) ;
45784: LD_VAR 0 3
45788: PPUSH
45789: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45793: LD_ADDR_EXP 133
45797: PUSH
45798: LD_EXP 133
45802: PPUSH
45803: LD_VAR 0 2
45807: PPUSH
45808: LD_EXP 133
45812: PUSH
45813: LD_VAR 0 2
45817: ARRAY
45818: PUSH
45819: LD_VAR 0 3
45823: DIFF
45824: PPUSH
45825: CALL_OW 1
45829: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45830: LD_ADDR_EXP 108
45834: PUSH
45835: LD_EXP 108
45839: PPUSH
45840: LD_VAR 0 2
45844: PUSH
45845: LD_EXP 108
45849: PUSH
45850: LD_VAR 0 2
45854: ARRAY
45855: PUSH
45856: LD_INT 1
45858: PLUS
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PPUSH
45864: LD_VAR 0 3
45868: PPUSH
45869: CALL 71498 0 3
45873: ST_TO_ADDR
// end ; end ;
45874: GO 45770
45876: POP
45877: POP
// if not lab or not mc_lab_upgrade [ i ] then
45878: LD_VAR 0 6
45882: NOT
45883: PUSH
45884: LD_EXP 135
45888: PUSH
45889: LD_VAR 0 2
45893: ARRAY
45894: NOT
45895: OR
45896: IFFALSE 45900
// continue ;
45898: GO 45670
// for j in lab do
45900: LD_ADDR_VAR 0 3
45904: PUSH
45905: LD_VAR 0 6
45909: PUSH
45910: FOR_IN
45911: IFFALSE 46076
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45913: LD_VAR 0 3
45917: PPUSH
45918: CALL_OW 266
45922: PUSH
45923: LD_INT 6
45925: PUSH
45926: LD_INT 7
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: IN
45933: PUSH
45934: LD_VAR 0 3
45938: PPUSH
45939: CALL_OW 461
45943: PUSH
45944: LD_INT 1
45946: NONEQUAL
45947: AND
45948: IFFALSE 46074
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45950: LD_VAR 0 3
45954: PPUSH
45955: LD_EXP 135
45959: PUSH
45960: LD_VAR 0 2
45964: ARRAY
45965: PUSH
45966: LD_INT 1
45968: ARRAY
45969: PPUSH
45970: CALL 78114 0 2
45974: IFFALSE 46074
// begin ComCancel ( j ) ;
45976: LD_VAR 0 3
45980: PPUSH
45981: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45985: LD_VAR 0 3
45989: PPUSH
45990: LD_EXP 135
45994: PUSH
45995: LD_VAR 0 2
45999: ARRAY
46000: PUSH
46001: LD_INT 1
46003: ARRAY
46004: PPUSH
46005: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46009: LD_VAR 0 3
46013: PUSH
46014: LD_EXP 108
46018: PUSH
46019: LD_VAR 0 2
46023: ARRAY
46024: IN
46025: NOT
46026: IFFALSE 46072
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46028: LD_ADDR_EXP 108
46032: PUSH
46033: LD_EXP 108
46037: PPUSH
46038: LD_VAR 0 2
46042: PUSH
46043: LD_EXP 108
46047: PUSH
46048: LD_VAR 0 2
46052: ARRAY
46053: PUSH
46054: LD_INT 1
46056: PLUS
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PPUSH
46062: LD_VAR 0 3
46066: PPUSH
46067: CALL 71498 0 3
46071: ST_TO_ADDR
// break ;
46072: GO 46076
// end ; end ; end ;
46074: GO 45910
46076: POP
46077: POP
// end ;
46078: GO 45670
46080: POP
46081: POP
// end ;
46082: LD_VAR 0 1
46086: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46087: LD_INT 0
46089: PPUSH
46090: PPUSH
46091: PPUSH
46092: PPUSH
46093: PPUSH
46094: PPUSH
46095: PPUSH
46096: PPUSH
46097: PPUSH
// if not mc_bases then
46098: LD_EXP 101
46102: NOT
46103: IFFALSE 46107
// exit ;
46105: GO 46512
// for i = 1 to mc_bases do
46107: LD_ADDR_VAR 0 2
46111: PUSH
46112: DOUBLE
46113: LD_INT 1
46115: DEC
46116: ST_TO_ADDR
46117: LD_EXP 101
46121: PUSH
46122: FOR_TO
46123: IFFALSE 46510
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46125: LD_EXP 109
46129: PUSH
46130: LD_VAR 0 2
46134: ARRAY
46135: NOT
46136: PUSH
46137: LD_EXP 101
46141: PUSH
46142: LD_VAR 0 2
46146: ARRAY
46147: PPUSH
46148: LD_INT 30
46150: PUSH
46151: LD_INT 3
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: PPUSH
46158: CALL_OW 72
46162: NOT
46163: OR
46164: IFFALSE 46168
// continue ;
46166: GO 46122
// busy := false ;
46168: LD_ADDR_VAR 0 8
46172: PUSH
46173: LD_INT 0
46175: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46176: LD_ADDR_VAR 0 4
46180: PUSH
46181: LD_EXP 101
46185: PUSH
46186: LD_VAR 0 2
46190: ARRAY
46191: PPUSH
46192: LD_INT 30
46194: PUSH
46195: LD_INT 3
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PPUSH
46202: CALL_OW 72
46206: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46207: LD_ADDR_VAR 0 6
46211: PUSH
46212: LD_EXP 109
46216: PUSH
46217: LD_VAR 0 2
46221: ARRAY
46222: PPUSH
46223: LD_INT 2
46225: PUSH
46226: LD_INT 30
46228: PUSH
46229: LD_INT 32
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 30
46238: PUSH
46239: LD_INT 33
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: EMPTY
46247: LIST
46248: LIST
46249: LIST
46250: PPUSH
46251: CALL_OW 72
46255: ST_TO_ADDR
// if not t then
46256: LD_VAR 0 6
46260: NOT
46261: IFFALSE 46265
// continue ;
46263: GO 46122
// for j in tmp do
46265: LD_ADDR_VAR 0 3
46269: PUSH
46270: LD_VAR 0 4
46274: PUSH
46275: FOR_IN
46276: IFFALSE 46306
// if not BuildingStatus ( j ) = bs_idle then
46278: LD_VAR 0 3
46282: PPUSH
46283: CALL_OW 461
46287: PUSH
46288: LD_INT 2
46290: EQUAL
46291: NOT
46292: IFFALSE 46304
// begin busy := true ;
46294: LD_ADDR_VAR 0 8
46298: PUSH
46299: LD_INT 1
46301: ST_TO_ADDR
// break ;
46302: GO 46306
// end ;
46304: GO 46275
46306: POP
46307: POP
// if busy then
46308: LD_VAR 0 8
46312: IFFALSE 46316
// continue ;
46314: GO 46122
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46316: LD_ADDR_VAR 0 7
46320: PUSH
46321: LD_VAR 0 6
46325: PPUSH
46326: LD_INT 35
46328: PUSH
46329: LD_INT 0
46331: PUSH
46332: EMPTY
46333: LIST
46334: LIST
46335: PPUSH
46336: CALL_OW 72
46340: ST_TO_ADDR
// if tw then
46341: LD_VAR 0 7
46345: IFFALSE 46422
// begin tw := tw [ 1 ] ;
46347: LD_ADDR_VAR 0 7
46351: PUSH
46352: LD_VAR 0 7
46356: PUSH
46357: LD_INT 1
46359: ARRAY
46360: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46361: LD_ADDR_VAR 0 9
46365: PUSH
46366: LD_VAR 0 7
46370: PPUSH
46371: LD_EXP 126
46375: PUSH
46376: LD_VAR 0 2
46380: ARRAY
46381: PPUSH
46382: CALL 76468 0 2
46386: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46387: LD_EXP 140
46391: PUSH
46392: LD_VAR 0 2
46396: ARRAY
46397: IFFALSE 46420
// if not weapon in mc_allowed_tower_weapons [ i ] then
46399: LD_VAR 0 9
46403: PUSH
46404: LD_EXP 140
46408: PUSH
46409: LD_VAR 0 2
46413: ARRAY
46414: IN
46415: NOT
46416: IFFALSE 46420
// continue ;
46418: GO 46122
// end else
46420: GO 46485
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46422: LD_ADDR_VAR 0 5
46426: PUSH
46427: LD_EXP 109
46431: PUSH
46432: LD_VAR 0 2
46436: ARRAY
46437: PPUSH
46438: LD_VAR 0 4
46442: PPUSH
46443: CALL 106695 0 2
46447: ST_TO_ADDR
// if not tmp2 then
46448: LD_VAR 0 5
46452: NOT
46453: IFFALSE 46457
// continue ;
46455: GO 46122
// tw := tmp2 [ 1 ] ;
46457: LD_ADDR_VAR 0 7
46461: PUSH
46462: LD_VAR 0 5
46466: PUSH
46467: LD_INT 1
46469: ARRAY
46470: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46471: LD_ADDR_VAR 0 9
46475: PUSH
46476: LD_VAR 0 5
46480: PUSH
46481: LD_INT 2
46483: ARRAY
46484: ST_TO_ADDR
// end ; if not weapon then
46485: LD_VAR 0 9
46489: NOT
46490: IFFALSE 46494
// continue ;
46492: GO 46122
// ComPlaceWeapon ( tw , weapon ) ;
46494: LD_VAR 0 7
46498: PPUSH
46499: LD_VAR 0 9
46503: PPUSH
46504: CALL_OW 148
// end ;
46508: GO 46122
46510: POP
46511: POP
// end ;
46512: LD_VAR 0 1
46516: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46517: LD_INT 0
46519: PPUSH
46520: PPUSH
46521: PPUSH
46522: PPUSH
46523: PPUSH
46524: PPUSH
// if not mc_bases then
46525: LD_EXP 101
46529: NOT
46530: IFFALSE 46534
// exit ;
46532: GO 47310
// for i = 1 to mc_bases do
46534: LD_ADDR_VAR 0 2
46538: PUSH
46539: DOUBLE
46540: LD_INT 1
46542: DEC
46543: ST_TO_ADDR
46544: LD_EXP 101
46548: PUSH
46549: FOR_TO
46550: IFFALSE 47308
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
46552: LD_EXP 114
46556: PUSH
46557: LD_VAR 0 2
46561: ARRAY
46562: NOT
46563: PUSH
46564: LD_EXP 114
46568: PUSH
46569: LD_VAR 0 2
46573: ARRAY
46574: PUSH
46575: LD_EXP 115
46579: PUSH
46580: LD_VAR 0 2
46584: ARRAY
46585: EQUAL
46586: OR
46587: PUSH
46588: LD_EXP 124
46592: PUSH
46593: LD_VAR 0 2
46597: ARRAY
46598: OR
46599: IFFALSE 46603
// continue ;
46601: GO 46549
// if mc_miners [ i ] then
46603: LD_EXP 115
46607: PUSH
46608: LD_VAR 0 2
46612: ARRAY
46613: IFFALSE 46995
// begin for j = mc_miners [ i ] downto 1 do
46615: LD_ADDR_VAR 0 3
46619: PUSH
46620: DOUBLE
46621: LD_EXP 115
46625: PUSH
46626: LD_VAR 0 2
46630: ARRAY
46631: INC
46632: ST_TO_ADDR
46633: LD_INT 1
46635: PUSH
46636: FOR_DOWNTO
46637: IFFALSE 46993
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46639: LD_EXP 115
46643: PUSH
46644: LD_VAR 0 2
46648: ARRAY
46649: PUSH
46650: LD_VAR 0 3
46654: ARRAY
46655: PPUSH
46656: CALL_OW 301
46660: PUSH
46661: LD_EXP 115
46665: PUSH
46666: LD_VAR 0 2
46670: ARRAY
46671: PUSH
46672: LD_VAR 0 3
46676: ARRAY
46677: PPUSH
46678: CALL_OW 257
46682: PUSH
46683: LD_INT 1
46685: NONEQUAL
46686: OR
46687: IFFALSE 46750
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46689: LD_ADDR_VAR 0 5
46693: PUSH
46694: LD_EXP 115
46698: PUSH
46699: LD_VAR 0 2
46703: ARRAY
46704: PUSH
46705: LD_EXP 115
46709: PUSH
46710: LD_VAR 0 2
46714: ARRAY
46715: PUSH
46716: LD_VAR 0 3
46720: ARRAY
46721: DIFF
46722: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46723: LD_ADDR_EXP 115
46727: PUSH
46728: LD_EXP 115
46732: PPUSH
46733: LD_VAR 0 2
46737: PPUSH
46738: LD_VAR 0 5
46742: PPUSH
46743: CALL_OW 1
46747: ST_TO_ADDR
// continue ;
46748: GO 46636
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
46750: LD_EXP 115
46754: PUSH
46755: LD_VAR 0 2
46759: ARRAY
46760: PUSH
46761: LD_VAR 0 3
46765: ARRAY
46766: PPUSH
46767: CALL_OW 257
46771: PUSH
46772: LD_INT 1
46774: EQUAL
46775: PUSH
46776: LD_EXP 115
46780: PUSH
46781: LD_VAR 0 2
46785: ARRAY
46786: PUSH
46787: LD_VAR 0 3
46791: ARRAY
46792: PPUSH
46793: CALL_OW 459
46797: NOT
46798: AND
46799: PUSH
46800: LD_EXP 115
46804: PUSH
46805: LD_VAR 0 2
46809: ARRAY
46810: PUSH
46811: LD_VAR 0 3
46815: ARRAY
46816: PPUSH
46817: CALL_OW 314
46821: NOT
46822: AND
46823: IFFALSE 46991
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46825: LD_EXP 115
46829: PUSH
46830: LD_VAR 0 2
46834: ARRAY
46835: PUSH
46836: LD_VAR 0 3
46840: ARRAY
46841: PPUSH
46842: CALL_OW 310
46846: IFFALSE 46869
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46848: LD_EXP 115
46852: PUSH
46853: LD_VAR 0 2
46857: ARRAY
46858: PUSH
46859: LD_VAR 0 3
46863: ARRAY
46864: PPUSH
46865: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46869: LD_EXP 115
46873: PUSH
46874: LD_VAR 0 2
46878: ARRAY
46879: PUSH
46880: LD_VAR 0 3
46884: ARRAY
46885: PPUSH
46886: CALL_OW 314
46890: NOT
46891: IFFALSE 46991
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
46893: LD_EXP 115
46897: PUSH
46898: LD_VAR 0 2
46902: ARRAY
46903: PUSH
46904: LD_VAR 0 3
46908: ARRAY
46909: PPUSH
46910: LD_EXP 114
46914: PUSH
46915: LD_VAR 0 2
46919: ARRAY
46920: PUSH
46921: LD_VAR 0 3
46925: PUSH
46926: LD_EXP 114
46930: PUSH
46931: LD_VAR 0 2
46935: ARRAY
46936: MOD
46937: PUSH
46938: LD_INT 1
46940: PLUS
46941: ARRAY
46942: PUSH
46943: LD_INT 1
46945: ARRAY
46946: PPUSH
46947: LD_EXP 114
46951: PUSH
46952: LD_VAR 0 2
46956: ARRAY
46957: PUSH
46958: LD_VAR 0 3
46962: PUSH
46963: LD_EXP 114
46967: PUSH
46968: LD_VAR 0 2
46972: ARRAY
46973: MOD
46974: PUSH
46975: LD_INT 1
46977: PLUS
46978: ARRAY
46979: PUSH
46980: LD_INT 2
46982: ARRAY
46983: PPUSH
46984: LD_INT 0
46986: PPUSH
46987: CALL_OW 193
// end ; end ;
46991: GO 46636
46993: POP
46994: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46995: LD_ADDR_VAR 0 5
46999: PUSH
47000: LD_EXP 101
47004: PUSH
47005: LD_VAR 0 2
47009: ARRAY
47010: PPUSH
47011: LD_INT 2
47013: PUSH
47014: LD_INT 30
47016: PUSH
47017: LD_INT 4
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: LD_INT 30
47026: PUSH
47027: LD_INT 5
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: LD_INT 30
47036: PUSH
47037: LD_INT 32
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: PUSH
47044: EMPTY
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: PPUSH
47050: CALL_OW 72
47054: ST_TO_ADDR
// if not tmp then
47055: LD_VAR 0 5
47059: NOT
47060: IFFALSE 47064
// continue ;
47062: GO 46549
// list := [ ] ;
47064: LD_ADDR_VAR 0 6
47068: PUSH
47069: EMPTY
47070: ST_TO_ADDR
// for j in tmp do
47071: LD_ADDR_VAR 0 3
47075: PUSH
47076: LD_VAR 0 5
47080: PUSH
47081: FOR_IN
47082: IFFALSE 47151
// begin for k in UnitsInside ( j ) do
47084: LD_ADDR_VAR 0 4
47088: PUSH
47089: LD_VAR 0 3
47093: PPUSH
47094: CALL_OW 313
47098: PUSH
47099: FOR_IN
47100: IFFALSE 47147
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47102: LD_VAR 0 4
47106: PPUSH
47107: CALL_OW 257
47111: PUSH
47112: LD_INT 1
47114: EQUAL
47115: PUSH
47116: LD_VAR 0 4
47120: PPUSH
47121: CALL_OW 459
47125: NOT
47126: AND
47127: IFFALSE 47145
// list := list ^ k ;
47129: LD_ADDR_VAR 0 6
47133: PUSH
47134: LD_VAR 0 6
47138: PUSH
47139: LD_VAR 0 4
47143: ADD
47144: ST_TO_ADDR
47145: GO 47099
47147: POP
47148: POP
// end ;
47149: GO 47081
47151: POP
47152: POP
// list := list diff mc_miners [ i ] ;
47153: LD_ADDR_VAR 0 6
47157: PUSH
47158: LD_VAR 0 6
47162: PUSH
47163: LD_EXP 115
47167: PUSH
47168: LD_VAR 0 2
47172: ARRAY
47173: DIFF
47174: ST_TO_ADDR
// if not list then
47175: LD_VAR 0 6
47179: NOT
47180: IFFALSE 47184
// continue ;
47182: GO 46549
// k := mc_mines [ i ] - mc_miners [ i ] ;
47184: LD_ADDR_VAR 0 4
47188: PUSH
47189: LD_EXP 114
47193: PUSH
47194: LD_VAR 0 2
47198: ARRAY
47199: PUSH
47200: LD_EXP 115
47204: PUSH
47205: LD_VAR 0 2
47209: ARRAY
47210: MINUS
47211: ST_TO_ADDR
// if k > list then
47212: LD_VAR 0 4
47216: PUSH
47217: LD_VAR 0 6
47221: GREATER
47222: IFFALSE 47234
// k := list ;
47224: LD_ADDR_VAR 0 4
47228: PUSH
47229: LD_VAR 0 6
47233: ST_TO_ADDR
// for j = 1 to k do
47234: LD_ADDR_VAR 0 3
47238: PUSH
47239: DOUBLE
47240: LD_INT 1
47242: DEC
47243: ST_TO_ADDR
47244: LD_VAR 0 4
47248: PUSH
47249: FOR_TO
47250: IFFALSE 47304
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47252: LD_ADDR_EXP 115
47256: PUSH
47257: LD_EXP 115
47261: PPUSH
47262: LD_VAR 0 2
47266: PUSH
47267: LD_EXP 115
47271: PUSH
47272: LD_VAR 0 2
47276: ARRAY
47277: PUSH
47278: LD_INT 1
47280: PLUS
47281: PUSH
47282: EMPTY
47283: LIST
47284: LIST
47285: PPUSH
47286: LD_VAR 0 6
47290: PUSH
47291: LD_VAR 0 3
47295: ARRAY
47296: PPUSH
47297: CALL 71498 0 3
47301: ST_TO_ADDR
47302: GO 47249
47304: POP
47305: POP
// end ;
47306: GO 46549
47308: POP
47309: POP
// end ;
47310: LD_VAR 0 1
47314: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47315: LD_INT 0
47317: PPUSH
47318: PPUSH
47319: PPUSH
47320: PPUSH
47321: PPUSH
47322: PPUSH
47323: PPUSH
47324: PPUSH
47325: PPUSH
47326: PPUSH
// if not mc_bases then
47327: LD_EXP 101
47331: NOT
47332: IFFALSE 47336
// exit ;
47334: GO 49086
// for i = 1 to mc_bases do
47336: LD_ADDR_VAR 0 2
47340: PUSH
47341: DOUBLE
47342: LD_INT 1
47344: DEC
47345: ST_TO_ADDR
47346: LD_EXP 101
47350: PUSH
47351: FOR_TO
47352: IFFALSE 49084
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47354: LD_EXP 101
47358: PUSH
47359: LD_VAR 0 2
47363: ARRAY
47364: NOT
47365: PUSH
47366: LD_EXP 108
47370: PUSH
47371: LD_VAR 0 2
47375: ARRAY
47376: OR
47377: IFFALSE 47381
// continue ;
47379: GO 47351
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47381: LD_EXP 117
47385: PUSH
47386: LD_VAR 0 2
47390: ARRAY
47391: NOT
47392: PUSH
47393: LD_EXP 118
47397: PUSH
47398: LD_VAR 0 2
47402: ARRAY
47403: AND
47404: IFFALSE 47442
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47406: LD_ADDR_EXP 118
47410: PUSH
47411: LD_EXP 118
47415: PPUSH
47416: LD_VAR 0 2
47420: PPUSH
47421: EMPTY
47422: PPUSH
47423: CALL_OW 1
47427: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47428: LD_VAR 0 2
47432: PPUSH
47433: LD_INT 107
47435: PPUSH
47436: CALL 38300 0 2
// continue ;
47440: GO 47351
// end ; target := [ ] ;
47442: LD_ADDR_VAR 0 6
47446: PUSH
47447: EMPTY
47448: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47449: LD_ADDR_VAR 0 3
47453: PUSH
47454: DOUBLE
47455: LD_EXP 117
47459: PUSH
47460: LD_VAR 0 2
47464: ARRAY
47465: INC
47466: ST_TO_ADDR
47467: LD_INT 1
47469: PUSH
47470: FOR_DOWNTO
47471: IFFALSE 47731
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47473: LD_EXP 117
47477: PUSH
47478: LD_VAR 0 2
47482: ARRAY
47483: PUSH
47484: LD_VAR 0 3
47488: ARRAY
47489: PUSH
47490: LD_INT 2
47492: ARRAY
47493: PPUSH
47494: LD_EXP 117
47498: PUSH
47499: LD_VAR 0 2
47503: ARRAY
47504: PUSH
47505: LD_VAR 0 3
47509: ARRAY
47510: PUSH
47511: LD_INT 3
47513: ARRAY
47514: PPUSH
47515: CALL_OW 488
47519: PUSH
47520: LD_EXP 117
47524: PUSH
47525: LD_VAR 0 2
47529: ARRAY
47530: PUSH
47531: LD_VAR 0 3
47535: ARRAY
47536: PUSH
47537: LD_INT 2
47539: ARRAY
47540: PPUSH
47541: LD_EXP 117
47545: PUSH
47546: LD_VAR 0 2
47550: ARRAY
47551: PUSH
47552: LD_VAR 0 3
47556: ARRAY
47557: PUSH
47558: LD_INT 3
47560: ARRAY
47561: PPUSH
47562: CALL_OW 284
47566: PUSH
47567: LD_INT 0
47569: EQUAL
47570: AND
47571: IFFALSE 47626
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47573: LD_ADDR_VAR 0 5
47577: PUSH
47578: LD_EXP 117
47582: PUSH
47583: LD_VAR 0 2
47587: ARRAY
47588: PPUSH
47589: LD_VAR 0 3
47593: PPUSH
47594: CALL_OW 3
47598: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47599: LD_ADDR_EXP 117
47603: PUSH
47604: LD_EXP 117
47608: PPUSH
47609: LD_VAR 0 2
47613: PPUSH
47614: LD_VAR 0 5
47618: PPUSH
47619: CALL_OW 1
47623: ST_TO_ADDR
// continue ;
47624: GO 47470
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47626: LD_EXP 101
47630: PUSH
47631: LD_VAR 0 2
47635: ARRAY
47636: PUSH
47637: LD_INT 1
47639: ARRAY
47640: PPUSH
47641: CALL_OW 255
47645: PPUSH
47646: LD_EXP 117
47650: PUSH
47651: LD_VAR 0 2
47655: ARRAY
47656: PUSH
47657: LD_VAR 0 3
47661: ARRAY
47662: PUSH
47663: LD_INT 2
47665: ARRAY
47666: PPUSH
47667: LD_EXP 117
47671: PUSH
47672: LD_VAR 0 2
47676: ARRAY
47677: PUSH
47678: LD_VAR 0 3
47682: ARRAY
47683: PUSH
47684: LD_INT 3
47686: ARRAY
47687: PPUSH
47688: LD_INT 30
47690: PPUSH
47691: CALL 72394 0 4
47695: PUSH
47696: LD_INT 4
47698: ARRAY
47699: PUSH
47700: LD_INT 0
47702: EQUAL
47703: IFFALSE 47729
// begin target := mc_crates [ i ] [ j ] ;
47705: LD_ADDR_VAR 0 6
47709: PUSH
47710: LD_EXP 117
47714: PUSH
47715: LD_VAR 0 2
47719: ARRAY
47720: PUSH
47721: LD_VAR 0 3
47725: ARRAY
47726: ST_TO_ADDR
// break ;
47727: GO 47731
// end ; end ;
47729: GO 47470
47731: POP
47732: POP
// if not target then
47733: LD_VAR 0 6
47737: NOT
47738: IFFALSE 47742
// continue ;
47740: GO 47351
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47742: LD_ADDR_VAR 0 7
47746: PUSH
47747: LD_EXP 120
47751: PUSH
47752: LD_VAR 0 2
47756: ARRAY
47757: PPUSH
47758: LD_INT 2
47760: PUSH
47761: LD_INT 3
47763: PUSH
47764: LD_INT 58
47766: PUSH
47767: EMPTY
47768: LIST
47769: PUSH
47770: EMPTY
47771: LIST
47772: LIST
47773: PUSH
47774: LD_INT 61
47776: PUSH
47777: EMPTY
47778: LIST
47779: PUSH
47780: LD_INT 33
47782: PUSH
47783: LD_INT 5
47785: PUSH
47786: EMPTY
47787: LIST
47788: LIST
47789: PUSH
47790: LD_INT 33
47792: PUSH
47793: LD_INT 3
47795: PUSH
47796: EMPTY
47797: LIST
47798: LIST
47799: PUSH
47800: EMPTY
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: LIST
47806: PUSH
47807: LD_INT 2
47809: PUSH
47810: LD_INT 34
47812: PUSH
47813: LD_INT 32
47815: PUSH
47816: EMPTY
47817: LIST
47818: LIST
47819: PUSH
47820: LD_INT 34
47822: PUSH
47823: LD_INT 51
47825: PUSH
47826: EMPTY
47827: LIST
47828: LIST
47829: PUSH
47830: LD_INT 34
47832: PUSH
47833: LD_INT 12
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: PPUSH
47850: CALL_OW 72
47854: ST_TO_ADDR
// if not cargo then
47855: LD_VAR 0 7
47859: NOT
47860: IFFALSE 48503
// begin if mc_crates_collector [ i ] < 5 then
47862: LD_EXP 118
47866: PUSH
47867: LD_VAR 0 2
47871: ARRAY
47872: PUSH
47873: LD_INT 5
47875: LESS
47876: IFFALSE 48242
// begin if mc_ape [ i ] then
47878: LD_EXP 130
47882: PUSH
47883: LD_VAR 0 2
47887: ARRAY
47888: IFFALSE 47935
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47890: LD_ADDR_VAR 0 5
47894: PUSH
47895: LD_EXP 130
47899: PUSH
47900: LD_VAR 0 2
47904: ARRAY
47905: PPUSH
47906: LD_INT 25
47908: PUSH
47909: LD_INT 16
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: LD_INT 24
47918: PUSH
47919: LD_INT 750
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: EMPTY
47927: LIST
47928: LIST
47929: PPUSH
47930: CALL_OW 72
47934: ST_TO_ADDR
// if not tmp then
47935: LD_VAR 0 5
47939: NOT
47940: IFFALSE 47987
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47942: LD_ADDR_VAR 0 5
47946: PUSH
47947: LD_EXP 101
47951: PUSH
47952: LD_VAR 0 2
47956: ARRAY
47957: PPUSH
47958: LD_INT 25
47960: PUSH
47961: LD_INT 2
47963: PUSH
47964: EMPTY
47965: LIST
47966: LIST
47967: PUSH
47968: LD_INT 24
47970: PUSH
47971: LD_INT 750
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: EMPTY
47979: LIST
47980: LIST
47981: PPUSH
47982: CALL_OW 72
47986: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47987: LD_EXP 130
47991: PUSH
47992: LD_VAR 0 2
47996: ARRAY
47997: PUSH
47998: LD_EXP 101
48002: PUSH
48003: LD_VAR 0 2
48007: ARRAY
48008: PPUSH
48009: LD_INT 25
48011: PUSH
48012: LD_INT 2
48014: PUSH
48015: EMPTY
48016: LIST
48017: LIST
48018: PUSH
48019: LD_INT 24
48021: PUSH
48022: LD_INT 750
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: PUSH
48029: EMPTY
48030: LIST
48031: LIST
48032: PPUSH
48033: CALL_OW 72
48037: AND
48038: PUSH
48039: LD_VAR 0 5
48043: PUSH
48044: LD_INT 5
48046: LESS
48047: AND
48048: IFFALSE 48130
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48050: LD_ADDR_VAR 0 3
48054: PUSH
48055: LD_EXP 101
48059: PUSH
48060: LD_VAR 0 2
48064: ARRAY
48065: PPUSH
48066: LD_INT 25
48068: PUSH
48069: LD_INT 2
48071: PUSH
48072: EMPTY
48073: LIST
48074: LIST
48075: PUSH
48076: LD_INT 24
48078: PUSH
48079: LD_INT 750
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: PPUSH
48090: CALL_OW 72
48094: PUSH
48095: FOR_IN
48096: IFFALSE 48128
// begin tmp := tmp union j ;
48098: LD_ADDR_VAR 0 5
48102: PUSH
48103: LD_VAR 0 5
48107: PUSH
48108: LD_VAR 0 3
48112: UNION
48113: ST_TO_ADDR
// if tmp >= 5 then
48114: LD_VAR 0 5
48118: PUSH
48119: LD_INT 5
48121: GREATEREQUAL
48122: IFFALSE 48126
// break ;
48124: GO 48128
// end ;
48126: GO 48095
48128: POP
48129: POP
// end ; if not tmp then
48130: LD_VAR 0 5
48134: NOT
48135: IFFALSE 48139
// continue ;
48137: GO 47351
// for j in tmp do
48139: LD_ADDR_VAR 0 3
48143: PUSH
48144: LD_VAR 0 5
48148: PUSH
48149: FOR_IN
48150: IFFALSE 48240
// if not GetTag ( j ) then
48152: LD_VAR 0 3
48156: PPUSH
48157: CALL_OW 110
48161: NOT
48162: IFFALSE 48238
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48164: LD_ADDR_EXP 118
48168: PUSH
48169: LD_EXP 118
48173: PPUSH
48174: LD_VAR 0 2
48178: PUSH
48179: LD_EXP 118
48183: PUSH
48184: LD_VAR 0 2
48188: ARRAY
48189: PUSH
48190: LD_INT 1
48192: PLUS
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PPUSH
48198: LD_VAR 0 3
48202: PPUSH
48203: CALL 71498 0 3
48207: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48208: LD_VAR 0 3
48212: PPUSH
48213: LD_INT 107
48215: PPUSH
48216: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48220: LD_EXP 118
48224: PUSH
48225: LD_VAR 0 2
48229: ARRAY
48230: PUSH
48231: LD_INT 5
48233: GREATEREQUAL
48234: IFFALSE 48238
// break ;
48236: GO 48240
// end ;
48238: GO 48149
48240: POP
48241: POP
// end ; if mc_crates_collector [ i ] and target then
48242: LD_EXP 118
48246: PUSH
48247: LD_VAR 0 2
48251: ARRAY
48252: PUSH
48253: LD_VAR 0 6
48257: AND
48258: IFFALSE 48501
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48260: LD_EXP 118
48264: PUSH
48265: LD_VAR 0 2
48269: ARRAY
48270: PUSH
48271: LD_VAR 0 6
48275: PUSH
48276: LD_INT 1
48278: ARRAY
48279: LESS
48280: IFFALSE 48300
// tmp := mc_crates_collector [ i ] else
48282: LD_ADDR_VAR 0 5
48286: PUSH
48287: LD_EXP 118
48291: PUSH
48292: LD_VAR 0 2
48296: ARRAY
48297: ST_TO_ADDR
48298: GO 48314
// tmp := target [ 1 ] ;
48300: LD_ADDR_VAR 0 5
48304: PUSH
48305: LD_VAR 0 6
48309: PUSH
48310: LD_INT 1
48312: ARRAY
48313: ST_TO_ADDR
// k := 0 ;
48314: LD_ADDR_VAR 0 4
48318: PUSH
48319: LD_INT 0
48321: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48322: LD_ADDR_VAR 0 3
48326: PUSH
48327: LD_EXP 118
48331: PUSH
48332: LD_VAR 0 2
48336: ARRAY
48337: PUSH
48338: FOR_IN
48339: IFFALSE 48499
// begin k := k + 1 ;
48341: LD_ADDR_VAR 0 4
48345: PUSH
48346: LD_VAR 0 4
48350: PUSH
48351: LD_INT 1
48353: PLUS
48354: ST_TO_ADDR
// if k > tmp then
48355: LD_VAR 0 4
48359: PUSH
48360: LD_VAR 0 5
48364: GREATER
48365: IFFALSE 48369
// break ;
48367: GO 48499
// if not GetClass ( j ) in [ 2 , 16 ] then
48369: LD_VAR 0 3
48373: PPUSH
48374: CALL_OW 257
48378: PUSH
48379: LD_INT 2
48381: PUSH
48382: LD_INT 16
48384: PUSH
48385: EMPTY
48386: LIST
48387: LIST
48388: IN
48389: NOT
48390: IFFALSE 48443
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48392: LD_ADDR_EXP 118
48396: PUSH
48397: LD_EXP 118
48401: PPUSH
48402: LD_VAR 0 2
48406: PPUSH
48407: LD_EXP 118
48411: PUSH
48412: LD_VAR 0 2
48416: ARRAY
48417: PUSH
48418: LD_VAR 0 3
48422: DIFF
48423: PPUSH
48424: CALL_OW 1
48428: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48429: LD_VAR 0 3
48433: PPUSH
48434: LD_INT 0
48436: PPUSH
48437: CALL_OW 109
// continue ;
48441: GO 48338
// end ; if IsInUnit ( j ) then
48443: LD_VAR 0 3
48447: PPUSH
48448: CALL_OW 310
48452: IFFALSE 48463
// ComExitBuilding ( j ) ;
48454: LD_VAR 0 3
48458: PPUSH
48459: CALL_OW 122
// wait ( 3 ) ;
48463: LD_INT 3
48465: PPUSH
48466: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48470: LD_VAR 0 3
48474: PPUSH
48475: LD_VAR 0 6
48479: PUSH
48480: LD_INT 2
48482: ARRAY
48483: PPUSH
48484: LD_VAR 0 6
48488: PUSH
48489: LD_INT 3
48491: ARRAY
48492: PPUSH
48493: CALL_OW 117
// end ;
48497: GO 48338
48499: POP
48500: POP
// end ; end else
48501: GO 49082
// begin for j in cargo do
48503: LD_ADDR_VAR 0 3
48507: PUSH
48508: LD_VAR 0 7
48512: PUSH
48513: FOR_IN
48514: IFFALSE 49080
// begin if GetTag ( j ) <> 0 then
48516: LD_VAR 0 3
48520: PPUSH
48521: CALL_OW 110
48525: PUSH
48526: LD_INT 0
48528: NONEQUAL
48529: IFFALSE 48533
// continue ;
48531: GO 48513
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48533: LD_VAR 0 3
48537: PPUSH
48538: CALL_OW 256
48542: PUSH
48543: LD_INT 1000
48545: LESS
48546: PUSH
48547: LD_VAR 0 3
48551: PPUSH
48552: LD_EXP 125
48556: PUSH
48557: LD_VAR 0 2
48561: ARRAY
48562: PPUSH
48563: CALL_OW 308
48567: NOT
48568: AND
48569: IFFALSE 48591
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48571: LD_VAR 0 3
48575: PPUSH
48576: LD_EXP 125
48580: PUSH
48581: LD_VAR 0 2
48585: ARRAY
48586: PPUSH
48587: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48591: LD_VAR 0 3
48595: PPUSH
48596: CALL_OW 256
48600: PUSH
48601: LD_INT 1000
48603: LESS
48604: PUSH
48605: LD_VAR 0 3
48609: PPUSH
48610: LD_EXP 125
48614: PUSH
48615: LD_VAR 0 2
48619: ARRAY
48620: PPUSH
48621: CALL_OW 308
48625: AND
48626: IFFALSE 48630
// continue ;
48628: GO 48513
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48630: LD_VAR 0 3
48634: PPUSH
48635: CALL_OW 262
48639: PUSH
48640: LD_INT 2
48642: EQUAL
48643: PUSH
48644: LD_VAR 0 3
48648: PPUSH
48649: CALL_OW 261
48653: PUSH
48654: LD_INT 15
48656: LESS
48657: AND
48658: IFFALSE 48662
// continue ;
48660: GO 48513
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48662: LD_VAR 0 3
48666: PPUSH
48667: CALL_OW 262
48671: PUSH
48672: LD_INT 1
48674: EQUAL
48675: PUSH
48676: LD_VAR 0 3
48680: PPUSH
48681: CALL_OW 261
48685: PUSH
48686: LD_INT 10
48688: LESS
48689: AND
48690: IFFALSE 49019
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48692: LD_ADDR_VAR 0 8
48696: PUSH
48697: LD_EXP 101
48701: PUSH
48702: LD_VAR 0 2
48706: ARRAY
48707: PPUSH
48708: LD_INT 2
48710: PUSH
48711: LD_INT 30
48713: PUSH
48714: LD_INT 0
48716: PUSH
48717: EMPTY
48718: LIST
48719: LIST
48720: PUSH
48721: LD_INT 30
48723: PUSH
48724: LD_INT 1
48726: PUSH
48727: EMPTY
48728: LIST
48729: LIST
48730: PUSH
48731: EMPTY
48732: LIST
48733: LIST
48734: LIST
48735: PPUSH
48736: CALL_OW 72
48740: ST_TO_ADDR
// if not depot then
48741: LD_VAR 0 8
48745: NOT
48746: IFFALSE 48750
// continue ;
48748: GO 48513
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48750: LD_VAR 0 3
48754: PPUSH
48755: LD_VAR 0 8
48759: PPUSH
48760: LD_VAR 0 3
48764: PPUSH
48765: CALL_OW 74
48769: PPUSH
48770: CALL_OW 296
48774: PUSH
48775: LD_INT 6
48777: LESS
48778: IFFALSE 48794
// SetFuel ( j , 100 ) else
48780: LD_VAR 0 3
48784: PPUSH
48785: LD_INT 100
48787: PPUSH
48788: CALL_OW 240
48792: GO 49019
// if GetFuel ( j ) = 0 then
48794: LD_VAR 0 3
48798: PPUSH
48799: CALL_OW 261
48803: PUSH
48804: LD_INT 0
48806: EQUAL
48807: IFFALSE 49019
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48809: LD_ADDR_EXP 120
48813: PUSH
48814: LD_EXP 120
48818: PPUSH
48819: LD_VAR 0 2
48823: PPUSH
48824: LD_EXP 120
48828: PUSH
48829: LD_VAR 0 2
48833: ARRAY
48834: PUSH
48835: LD_VAR 0 3
48839: DIFF
48840: PPUSH
48841: CALL_OW 1
48845: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48846: LD_VAR 0 3
48850: PPUSH
48851: CALL_OW 263
48855: PUSH
48856: LD_INT 1
48858: EQUAL
48859: IFFALSE 48875
// ComExitVehicle ( IsInUnit ( j ) ) ;
48861: LD_VAR 0 3
48865: PPUSH
48866: CALL_OW 310
48870: PPUSH
48871: CALL_OW 121
// if GetControl ( j ) = control_remote then
48875: LD_VAR 0 3
48879: PPUSH
48880: CALL_OW 263
48884: PUSH
48885: LD_INT 2
48887: EQUAL
48888: IFFALSE 48899
// ComUnlink ( j ) ;
48890: LD_VAR 0 3
48894: PPUSH
48895: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48899: LD_ADDR_VAR 0 9
48903: PUSH
48904: LD_VAR 0 2
48908: PPUSH
48909: LD_INT 3
48911: PPUSH
48912: CALL 58372 0 2
48916: ST_TO_ADDR
// if fac then
48917: LD_VAR 0 9
48921: IFFALSE 49017
// begin for k in fac do
48923: LD_ADDR_VAR 0 4
48927: PUSH
48928: LD_VAR 0 9
48932: PUSH
48933: FOR_IN
48934: IFFALSE 49015
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48936: LD_ADDR_VAR 0 10
48940: PUSH
48941: LD_VAR 0 9
48945: PPUSH
48946: LD_VAR 0 3
48950: PPUSH
48951: CALL_OW 265
48955: PPUSH
48956: LD_VAR 0 3
48960: PPUSH
48961: CALL_OW 262
48965: PPUSH
48966: LD_VAR 0 3
48970: PPUSH
48971: CALL_OW 263
48975: PPUSH
48976: LD_VAR 0 3
48980: PPUSH
48981: CALL_OW 264
48985: PPUSH
48986: CALL 69030 0 5
48990: ST_TO_ADDR
// if components then
48991: LD_VAR 0 10
48995: IFFALSE 49013
// begin MC_InsertProduceList ( i , components ) ;
48997: LD_VAR 0 2
49001: PPUSH
49002: LD_VAR 0 10
49006: PPUSH
49007: CALL 57917 0 2
// break ;
49011: GO 49015
// end ; end ;
49013: GO 48933
49015: POP
49016: POP
// end ; continue ;
49017: GO 48513
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49019: LD_VAR 0 3
49023: PPUSH
49024: LD_INT 1
49026: PPUSH
49027: CALL_OW 289
49031: PUSH
49032: LD_INT 100
49034: LESS
49035: PUSH
49036: LD_VAR 0 3
49040: PPUSH
49041: CALL_OW 314
49045: NOT
49046: AND
49047: IFFALSE 49076
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49049: LD_VAR 0 3
49053: PPUSH
49054: LD_VAR 0 6
49058: PUSH
49059: LD_INT 2
49061: ARRAY
49062: PPUSH
49063: LD_VAR 0 6
49067: PUSH
49068: LD_INT 3
49070: ARRAY
49071: PPUSH
49072: CALL_OW 117
// break ;
49076: GO 49080
// end ;
49078: GO 48513
49080: POP
49081: POP
// end ; end ;
49082: GO 47351
49084: POP
49085: POP
// end ;
49086: LD_VAR 0 1
49090: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49091: LD_INT 0
49093: PPUSH
49094: PPUSH
49095: PPUSH
49096: PPUSH
// if not mc_bases then
49097: LD_EXP 101
49101: NOT
49102: IFFALSE 49106
// exit ;
49104: GO 49267
// for i = 1 to mc_bases do
49106: LD_ADDR_VAR 0 2
49110: PUSH
49111: DOUBLE
49112: LD_INT 1
49114: DEC
49115: ST_TO_ADDR
49116: LD_EXP 101
49120: PUSH
49121: FOR_TO
49122: IFFALSE 49265
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49124: LD_ADDR_VAR 0 4
49128: PUSH
49129: LD_EXP 120
49133: PUSH
49134: LD_VAR 0 2
49138: ARRAY
49139: PUSH
49140: LD_EXP 123
49144: PUSH
49145: LD_VAR 0 2
49149: ARRAY
49150: UNION
49151: PPUSH
49152: LD_INT 33
49154: PUSH
49155: LD_INT 2
49157: PUSH
49158: EMPTY
49159: LIST
49160: LIST
49161: PPUSH
49162: CALL_OW 72
49166: ST_TO_ADDR
// if tmp then
49167: LD_VAR 0 4
49171: IFFALSE 49263
// for j in tmp do
49173: LD_ADDR_VAR 0 3
49177: PUSH
49178: LD_VAR 0 4
49182: PUSH
49183: FOR_IN
49184: IFFALSE 49261
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49186: LD_VAR 0 3
49190: PPUSH
49191: CALL_OW 312
49195: NOT
49196: PUSH
49197: LD_VAR 0 3
49201: PPUSH
49202: CALL_OW 256
49206: PUSH
49207: LD_INT 250
49209: GREATEREQUAL
49210: AND
49211: IFFALSE 49224
// Connect ( j ) else
49213: LD_VAR 0 3
49217: PPUSH
49218: CALL 74431 0 1
49222: GO 49259
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49224: LD_VAR 0 3
49228: PPUSH
49229: CALL_OW 256
49233: PUSH
49234: LD_INT 250
49236: LESS
49237: PUSH
49238: LD_VAR 0 3
49242: PPUSH
49243: CALL_OW 312
49247: AND
49248: IFFALSE 49259
// ComUnlink ( j ) ;
49250: LD_VAR 0 3
49254: PPUSH
49255: CALL_OW 136
49259: GO 49183
49261: POP
49262: POP
// end ;
49263: GO 49121
49265: POP
49266: POP
// end ;
49267: LD_VAR 0 1
49271: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49272: LD_INT 0
49274: PPUSH
49275: PPUSH
49276: PPUSH
49277: PPUSH
49278: PPUSH
// if not mc_bases then
49279: LD_EXP 101
49283: NOT
49284: IFFALSE 49288
// exit ;
49286: GO 49733
// for i = 1 to mc_bases do
49288: LD_ADDR_VAR 0 2
49292: PUSH
49293: DOUBLE
49294: LD_INT 1
49296: DEC
49297: ST_TO_ADDR
49298: LD_EXP 101
49302: PUSH
49303: FOR_TO
49304: IFFALSE 49731
// begin if not mc_produce [ i ] then
49306: LD_EXP 122
49310: PUSH
49311: LD_VAR 0 2
49315: ARRAY
49316: NOT
49317: IFFALSE 49321
// continue ;
49319: GO 49303
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49321: LD_ADDR_VAR 0 5
49325: PUSH
49326: LD_EXP 101
49330: PUSH
49331: LD_VAR 0 2
49335: ARRAY
49336: PPUSH
49337: LD_INT 30
49339: PUSH
49340: LD_INT 3
49342: PUSH
49343: EMPTY
49344: LIST
49345: LIST
49346: PPUSH
49347: CALL_OW 72
49351: ST_TO_ADDR
// if not fac then
49352: LD_VAR 0 5
49356: NOT
49357: IFFALSE 49361
// continue ;
49359: GO 49303
// for j in fac do
49361: LD_ADDR_VAR 0 3
49365: PUSH
49366: LD_VAR 0 5
49370: PUSH
49371: FOR_IN
49372: IFFALSE 49727
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49374: LD_VAR 0 3
49378: PPUSH
49379: CALL_OW 461
49383: PUSH
49384: LD_INT 2
49386: NONEQUAL
49387: PUSH
49388: LD_VAR 0 3
49392: PPUSH
49393: LD_INT 15
49395: PPUSH
49396: CALL 74091 0 2
49400: PUSH
49401: LD_INT 4
49403: ARRAY
49404: OR
49405: IFFALSE 49409
// continue ;
49407: GO 49371
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49409: LD_VAR 0 3
49413: PPUSH
49414: LD_EXP 122
49418: PUSH
49419: LD_VAR 0 2
49423: ARRAY
49424: PUSH
49425: LD_INT 1
49427: ARRAY
49428: PUSH
49429: LD_INT 1
49431: ARRAY
49432: PPUSH
49433: LD_EXP 122
49437: PUSH
49438: LD_VAR 0 2
49442: ARRAY
49443: PUSH
49444: LD_INT 1
49446: ARRAY
49447: PUSH
49448: LD_INT 2
49450: ARRAY
49451: PPUSH
49452: LD_EXP 122
49456: PUSH
49457: LD_VAR 0 2
49461: ARRAY
49462: PUSH
49463: LD_INT 1
49465: ARRAY
49466: PUSH
49467: LD_INT 3
49469: ARRAY
49470: PPUSH
49471: LD_EXP 122
49475: PUSH
49476: LD_VAR 0 2
49480: ARRAY
49481: PUSH
49482: LD_INT 1
49484: ARRAY
49485: PUSH
49486: LD_INT 4
49488: ARRAY
49489: PPUSH
49490: CALL_OW 448
49494: PUSH
49495: LD_VAR 0 3
49499: PPUSH
49500: LD_EXP 122
49504: PUSH
49505: LD_VAR 0 2
49509: ARRAY
49510: PUSH
49511: LD_INT 1
49513: ARRAY
49514: PUSH
49515: LD_INT 1
49517: ARRAY
49518: PUSH
49519: LD_EXP 122
49523: PUSH
49524: LD_VAR 0 2
49528: ARRAY
49529: PUSH
49530: LD_INT 1
49532: ARRAY
49533: PUSH
49534: LD_INT 2
49536: ARRAY
49537: PUSH
49538: LD_EXP 122
49542: PUSH
49543: LD_VAR 0 2
49547: ARRAY
49548: PUSH
49549: LD_INT 1
49551: ARRAY
49552: PUSH
49553: LD_INT 3
49555: ARRAY
49556: PUSH
49557: LD_EXP 122
49561: PUSH
49562: LD_VAR 0 2
49566: ARRAY
49567: PUSH
49568: LD_INT 1
49570: ARRAY
49571: PUSH
49572: LD_INT 4
49574: ARRAY
49575: PUSH
49576: EMPTY
49577: LIST
49578: LIST
49579: LIST
49580: LIST
49581: PPUSH
49582: CALL 77762 0 2
49586: AND
49587: IFFALSE 49725
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49589: LD_VAR 0 3
49593: PPUSH
49594: LD_EXP 122
49598: PUSH
49599: LD_VAR 0 2
49603: ARRAY
49604: PUSH
49605: LD_INT 1
49607: ARRAY
49608: PUSH
49609: LD_INT 1
49611: ARRAY
49612: PPUSH
49613: LD_EXP 122
49617: PUSH
49618: LD_VAR 0 2
49622: ARRAY
49623: PUSH
49624: LD_INT 1
49626: ARRAY
49627: PUSH
49628: LD_INT 2
49630: ARRAY
49631: PPUSH
49632: LD_EXP 122
49636: PUSH
49637: LD_VAR 0 2
49641: ARRAY
49642: PUSH
49643: LD_INT 1
49645: ARRAY
49646: PUSH
49647: LD_INT 3
49649: ARRAY
49650: PPUSH
49651: LD_EXP 122
49655: PUSH
49656: LD_VAR 0 2
49660: ARRAY
49661: PUSH
49662: LD_INT 1
49664: ARRAY
49665: PUSH
49666: LD_INT 4
49668: ARRAY
49669: PPUSH
49670: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49674: LD_ADDR_VAR 0 4
49678: PUSH
49679: LD_EXP 122
49683: PUSH
49684: LD_VAR 0 2
49688: ARRAY
49689: PPUSH
49690: LD_INT 1
49692: PPUSH
49693: CALL_OW 3
49697: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49698: LD_ADDR_EXP 122
49702: PUSH
49703: LD_EXP 122
49707: PPUSH
49708: LD_VAR 0 2
49712: PPUSH
49713: LD_VAR 0 4
49717: PPUSH
49718: CALL_OW 1
49722: ST_TO_ADDR
// break ;
49723: GO 49727
// end ; end ;
49725: GO 49371
49727: POP
49728: POP
// end ;
49729: GO 49303
49731: POP
49732: POP
// end ;
49733: LD_VAR 0 1
49737: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49738: LD_INT 0
49740: PPUSH
49741: PPUSH
49742: PPUSH
// if not mc_bases then
49743: LD_EXP 101
49747: NOT
49748: IFFALSE 49752
// exit ;
49750: GO 49841
// for i = 1 to mc_bases do
49752: LD_ADDR_VAR 0 2
49756: PUSH
49757: DOUBLE
49758: LD_INT 1
49760: DEC
49761: ST_TO_ADDR
49762: LD_EXP 101
49766: PUSH
49767: FOR_TO
49768: IFFALSE 49839
// begin if mc_attack [ i ] then
49770: LD_EXP 121
49774: PUSH
49775: LD_VAR 0 2
49779: ARRAY
49780: IFFALSE 49837
// begin tmp := mc_attack [ i ] [ 1 ] ;
49782: LD_ADDR_VAR 0 3
49786: PUSH
49787: LD_EXP 121
49791: PUSH
49792: LD_VAR 0 2
49796: ARRAY
49797: PUSH
49798: LD_INT 1
49800: ARRAY
49801: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49802: LD_ADDR_EXP 121
49806: PUSH
49807: LD_EXP 121
49811: PPUSH
49812: LD_VAR 0 2
49816: PPUSH
49817: EMPTY
49818: PPUSH
49819: CALL_OW 1
49823: ST_TO_ADDR
// Attack ( tmp ) ;
49824: LD_VAR 0 3
49828: PPUSH
49829: CALL 99975 0 1
// exit ;
49833: POP
49834: POP
49835: GO 49841
// end ; end ;
49837: GO 49767
49839: POP
49840: POP
// end ;
49841: LD_VAR 0 1
49845: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49846: LD_INT 0
49848: PPUSH
49849: PPUSH
49850: PPUSH
49851: PPUSH
49852: PPUSH
49853: PPUSH
49854: PPUSH
// if not mc_bases then
49855: LD_EXP 101
49859: NOT
49860: IFFALSE 49864
// exit ;
49862: GO 50446
// for i = 1 to mc_bases do
49864: LD_ADDR_VAR 0 2
49868: PUSH
49869: DOUBLE
49870: LD_INT 1
49872: DEC
49873: ST_TO_ADDR
49874: LD_EXP 101
49878: PUSH
49879: FOR_TO
49880: IFFALSE 50444
// begin if not mc_bases [ i ] then
49882: LD_EXP 101
49886: PUSH
49887: LD_VAR 0 2
49891: ARRAY
49892: NOT
49893: IFFALSE 49897
// continue ;
49895: GO 49879
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49897: LD_ADDR_VAR 0 7
49901: PUSH
49902: LD_EXP 101
49906: PUSH
49907: LD_VAR 0 2
49911: ARRAY
49912: PUSH
49913: LD_INT 1
49915: ARRAY
49916: PPUSH
49917: CALL 68334 0 1
49921: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49922: LD_ADDR_EXP 124
49926: PUSH
49927: LD_EXP 124
49931: PPUSH
49932: LD_VAR 0 2
49936: PPUSH
49937: LD_EXP 101
49941: PUSH
49942: LD_VAR 0 2
49946: ARRAY
49947: PUSH
49948: LD_INT 1
49950: ARRAY
49951: PPUSH
49952: CALL_OW 255
49956: PPUSH
49957: LD_EXP 126
49961: PUSH
49962: LD_VAR 0 2
49966: ARRAY
49967: PPUSH
49968: CALL 65888 0 2
49972: PPUSH
49973: CALL_OW 1
49977: ST_TO_ADDR
// if not mc_scan [ i ] then
49978: LD_EXP 124
49982: PUSH
49983: LD_VAR 0 2
49987: ARRAY
49988: NOT
49989: IFFALSE 50144
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49991: LD_ADDR_VAR 0 4
49995: PUSH
49996: LD_EXP 101
50000: PUSH
50001: LD_VAR 0 2
50005: ARRAY
50006: PPUSH
50007: LD_INT 2
50009: PUSH
50010: LD_INT 25
50012: PUSH
50013: LD_INT 5
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: PUSH
50020: LD_INT 25
50022: PUSH
50023: LD_INT 8
50025: PUSH
50026: EMPTY
50027: LIST
50028: LIST
50029: PUSH
50030: LD_INT 25
50032: PUSH
50033: LD_INT 9
50035: PUSH
50036: EMPTY
50037: LIST
50038: LIST
50039: PUSH
50040: EMPTY
50041: LIST
50042: LIST
50043: LIST
50044: LIST
50045: PPUSH
50046: CALL_OW 72
50050: ST_TO_ADDR
// if not tmp then
50051: LD_VAR 0 4
50055: NOT
50056: IFFALSE 50060
// continue ;
50058: GO 49879
// for j in tmp do
50060: LD_ADDR_VAR 0 3
50064: PUSH
50065: LD_VAR 0 4
50069: PUSH
50070: FOR_IN
50071: IFFALSE 50142
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50073: LD_VAR 0 3
50077: PPUSH
50078: CALL_OW 310
50082: PPUSH
50083: CALL_OW 266
50087: PUSH
50088: LD_INT 5
50090: EQUAL
50091: PUSH
50092: LD_VAR 0 3
50096: PPUSH
50097: CALL_OW 257
50101: PUSH
50102: LD_INT 1
50104: EQUAL
50105: AND
50106: PUSH
50107: LD_VAR 0 3
50111: PPUSH
50112: CALL_OW 459
50116: NOT
50117: AND
50118: PUSH
50119: LD_VAR 0 7
50123: AND
50124: IFFALSE 50140
// ComChangeProfession ( j , class ) ;
50126: LD_VAR 0 3
50130: PPUSH
50131: LD_VAR 0 7
50135: PPUSH
50136: CALL_OW 123
50140: GO 50070
50142: POP
50143: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50144: LD_EXP 124
50148: PUSH
50149: LD_VAR 0 2
50153: ARRAY
50154: PUSH
50155: LD_EXP 123
50159: PUSH
50160: LD_VAR 0 2
50164: ARRAY
50165: NOT
50166: AND
50167: PUSH
50168: LD_EXP 101
50172: PUSH
50173: LD_VAR 0 2
50177: ARRAY
50178: PPUSH
50179: LD_INT 30
50181: PUSH
50182: LD_INT 32
50184: PUSH
50185: EMPTY
50186: LIST
50187: LIST
50188: PPUSH
50189: CALL_OW 72
50193: NOT
50194: AND
50195: PUSH
50196: LD_EXP 101
50200: PUSH
50201: LD_VAR 0 2
50205: ARRAY
50206: PPUSH
50207: LD_INT 2
50209: PUSH
50210: LD_INT 30
50212: PUSH
50213: LD_INT 4
50215: PUSH
50216: EMPTY
50217: LIST
50218: LIST
50219: PUSH
50220: LD_INT 30
50222: PUSH
50223: LD_INT 5
50225: PUSH
50226: EMPTY
50227: LIST
50228: LIST
50229: PUSH
50230: EMPTY
50231: LIST
50232: LIST
50233: LIST
50234: PPUSH
50235: CALL_OW 72
50239: NOT
50240: AND
50241: IFFALSE 50373
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50243: LD_ADDR_VAR 0 4
50247: PUSH
50248: LD_EXP 101
50252: PUSH
50253: LD_VAR 0 2
50257: ARRAY
50258: PPUSH
50259: LD_INT 2
50261: PUSH
50262: LD_INT 25
50264: PUSH
50265: LD_INT 1
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: PUSH
50272: LD_INT 25
50274: PUSH
50275: LD_INT 5
50277: PUSH
50278: EMPTY
50279: LIST
50280: LIST
50281: PUSH
50282: LD_INT 25
50284: PUSH
50285: LD_INT 8
50287: PUSH
50288: EMPTY
50289: LIST
50290: LIST
50291: PUSH
50292: LD_INT 25
50294: PUSH
50295: LD_INT 9
50297: PUSH
50298: EMPTY
50299: LIST
50300: LIST
50301: PUSH
50302: EMPTY
50303: LIST
50304: LIST
50305: LIST
50306: LIST
50307: LIST
50308: PPUSH
50309: CALL_OW 72
50313: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50314: LD_ADDR_VAR 0 4
50318: PUSH
50319: LD_VAR 0 4
50323: PUSH
50324: LD_VAR 0 4
50328: PPUSH
50329: LD_INT 18
50331: PPUSH
50332: CALL 104784 0 2
50336: DIFF
50337: ST_TO_ADDR
// if tmp then
50338: LD_VAR 0 4
50342: IFFALSE 50373
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50344: LD_VAR 0 2
50348: PPUSH
50349: LD_VAR 0 4
50353: PPUSH
50354: LD_EXP 126
50358: PUSH
50359: LD_VAR 0 2
50363: ARRAY
50364: PPUSH
50365: CALL 65923 0 3
// exit ;
50369: POP
50370: POP
50371: GO 50446
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50373: LD_EXP 124
50377: PUSH
50378: LD_VAR 0 2
50382: ARRAY
50383: PUSH
50384: LD_EXP 123
50388: PUSH
50389: LD_VAR 0 2
50393: ARRAY
50394: AND
50395: IFFALSE 50442
// begin tmp := mc_defender [ i ] ;
50397: LD_ADDR_VAR 0 4
50401: PUSH
50402: LD_EXP 123
50406: PUSH
50407: LD_VAR 0 2
50411: ARRAY
50412: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50413: LD_VAR 0 2
50417: PPUSH
50418: LD_VAR 0 4
50422: PPUSH
50423: LD_EXP 124
50427: PUSH
50428: LD_VAR 0 2
50432: ARRAY
50433: PPUSH
50434: CALL 66484 0 3
// exit ;
50438: POP
50439: POP
50440: GO 50446
// end ; end ;
50442: GO 49879
50444: POP
50445: POP
// end ;
50446: LD_VAR 0 1
50450: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50451: LD_INT 0
50453: PPUSH
50454: PPUSH
50455: PPUSH
50456: PPUSH
50457: PPUSH
50458: PPUSH
50459: PPUSH
50460: PPUSH
50461: PPUSH
50462: PPUSH
50463: PPUSH
// if not mc_bases then
50464: LD_EXP 101
50468: NOT
50469: IFFALSE 50473
// exit ;
50471: GO 51560
// for i = 1 to mc_bases do
50473: LD_ADDR_VAR 0 2
50477: PUSH
50478: DOUBLE
50479: LD_INT 1
50481: DEC
50482: ST_TO_ADDR
50483: LD_EXP 101
50487: PUSH
50488: FOR_TO
50489: IFFALSE 51558
// begin tmp := mc_lab [ i ] ;
50491: LD_ADDR_VAR 0 6
50495: PUSH
50496: LD_EXP 134
50500: PUSH
50501: LD_VAR 0 2
50505: ARRAY
50506: ST_TO_ADDR
// if not tmp then
50507: LD_VAR 0 6
50511: NOT
50512: IFFALSE 50516
// continue ;
50514: GO 50488
// idle_lab := 0 ;
50516: LD_ADDR_VAR 0 11
50520: PUSH
50521: LD_INT 0
50523: ST_TO_ADDR
// for j in tmp do
50524: LD_ADDR_VAR 0 3
50528: PUSH
50529: LD_VAR 0 6
50533: PUSH
50534: FOR_IN
50535: IFFALSE 51554
// begin researching := false ;
50537: LD_ADDR_VAR 0 10
50541: PUSH
50542: LD_INT 0
50544: ST_TO_ADDR
// side := GetSide ( j ) ;
50545: LD_ADDR_VAR 0 4
50549: PUSH
50550: LD_VAR 0 3
50554: PPUSH
50555: CALL_OW 255
50559: ST_TO_ADDR
// if not mc_tech [ side ] then
50560: LD_EXP 128
50564: PUSH
50565: LD_VAR 0 4
50569: ARRAY
50570: NOT
50571: IFFALSE 50575
// continue ;
50573: GO 50534
// if BuildingStatus ( j ) = bs_idle then
50575: LD_VAR 0 3
50579: PPUSH
50580: CALL_OW 461
50584: PUSH
50585: LD_INT 2
50587: EQUAL
50588: IFFALSE 50776
// begin if idle_lab and UnitsInside ( j ) < 6 then
50590: LD_VAR 0 11
50594: PUSH
50595: LD_VAR 0 3
50599: PPUSH
50600: CALL_OW 313
50604: PUSH
50605: LD_INT 6
50607: LESS
50608: AND
50609: IFFALSE 50680
// begin tmp2 := UnitsInside ( idle_lab ) ;
50611: LD_ADDR_VAR 0 9
50615: PUSH
50616: LD_VAR 0 11
50620: PPUSH
50621: CALL_OW 313
50625: ST_TO_ADDR
// if tmp2 then
50626: LD_VAR 0 9
50630: IFFALSE 50672
// for x in tmp2 do
50632: LD_ADDR_VAR 0 7
50636: PUSH
50637: LD_VAR 0 9
50641: PUSH
50642: FOR_IN
50643: IFFALSE 50670
// begin ComExitBuilding ( x ) ;
50645: LD_VAR 0 7
50649: PPUSH
50650: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50654: LD_VAR 0 7
50658: PPUSH
50659: LD_VAR 0 3
50663: PPUSH
50664: CALL_OW 180
// end ;
50668: GO 50642
50670: POP
50671: POP
// idle_lab := 0 ;
50672: LD_ADDR_VAR 0 11
50676: PUSH
50677: LD_INT 0
50679: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50680: LD_ADDR_VAR 0 5
50684: PUSH
50685: LD_EXP 128
50689: PUSH
50690: LD_VAR 0 4
50694: ARRAY
50695: PUSH
50696: FOR_IN
50697: IFFALSE 50757
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50699: LD_VAR 0 3
50703: PPUSH
50704: LD_VAR 0 5
50708: PPUSH
50709: CALL_OW 430
50713: PUSH
50714: LD_VAR 0 4
50718: PPUSH
50719: LD_VAR 0 5
50723: PPUSH
50724: CALL 64993 0 2
50728: AND
50729: IFFALSE 50755
// begin researching := true ;
50731: LD_ADDR_VAR 0 10
50735: PUSH
50736: LD_INT 1
50738: ST_TO_ADDR
// ComResearch ( j , t ) ;
50739: LD_VAR 0 3
50743: PPUSH
50744: LD_VAR 0 5
50748: PPUSH
50749: CALL_OW 124
// break ;
50753: GO 50757
// end ;
50755: GO 50696
50757: POP
50758: POP
// if not researching then
50759: LD_VAR 0 10
50763: NOT
50764: IFFALSE 50776
// idle_lab := j ;
50766: LD_ADDR_VAR 0 11
50770: PUSH
50771: LD_VAR 0 3
50775: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50776: LD_VAR 0 3
50780: PPUSH
50781: CALL_OW 461
50785: PUSH
50786: LD_INT 10
50788: EQUAL
50789: IFFALSE 51377
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50791: LD_EXP 130
50795: PUSH
50796: LD_VAR 0 2
50800: ARRAY
50801: NOT
50802: PUSH
50803: LD_EXP 131
50807: PUSH
50808: LD_VAR 0 2
50812: ARRAY
50813: NOT
50814: AND
50815: PUSH
50816: LD_EXP 128
50820: PUSH
50821: LD_VAR 0 4
50825: ARRAY
50826: PUSH
50827: LD_INT 1
50829: GREATER
50830: AND
50831: IFFALSE 50962
// begin ComCancel ( j ) ;
50833: LD_VAR 0 3
50837: PPUSH
50838: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50842: LD_ADDR_EXP 128
50846: PUSH
50847: LD_EXP 128
50851: PPUSH
50852: LD_VAR 0 4
50856: PPUSH
50857: LD_EXP 128
50861: PUSH
50862: LD_VAR 0 4
50866: ARRAY
50867: PPUSH
50868: LD_EXP 128
50872: PUSH
50873: LD_VAR 0 4
50877: ARRAY
50878: PUSH
50879: LD_INT 1
50881: MINUS
50882: PPUSH
50883: LD_EXP 128
50887: PUSH
50888: LD_VAR 0 4
50892: ARRAY
50893: PPUSH
50894: LD_INT 0
50896: PPUSH
50897: CALL 70916 0 4
50901: PPUSH
50902: CALL_OW 1
50906: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50907: LD_ADDR_EXP 128
50911: PUSH
50912: LD_EXP 128
50916: PPUSH
50917: LD_VAR 0 4
50921: PPUSH
50922: LD_EXP 128
50926: PUSH
50927: LD_VAR 0 4
50931: ARRAY
50932: PPUSH
50933: LD_EXP 128
50937: PUSH
50938: LD_VAR 0 4
50942: ARRAY
50943: PPUSH
50944: LD_INT 1
50946: PPUSH
50947: LD_INT 0
50949: PPUSH
50950: CALL 70916 0 4
50954: PPUSH
50955: CALL_OW 1
50959: ST_TO_ADDR
// continue ;
50960: GO 50534
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50962: LD_EXP 130
50966: PUSH
50967: LD_VAR 0 2
50971: ARRAY
50972: PUSH
50973: LD_EXP 131
50977: PUSH
50978: LD_VAR 0 2
50982: ARRAY
50983: NOT
50984: AND
50985: IFFALSE 51112
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50987: LD_ADDR_EXP 131
50991: PUSH
50992: LD_EXP 131
50996: PPUSH
50997: LD_VAR 0 2
51001: PUSH
51002: LD_EXP 131
51006: PUSH
51007: LD_VAR 0 2
51011: ARRAY
51012: PUSH
51013: LD_INT 1
51015: PLUS
51016: PUSH
51017: EMPTY
51018: LIST
51019: LIST
51020: PPUSH
51021: LD_EXP 130
51025: PUSH
51026: LD_VAR 0 2
51030: ARRAY
51031: PUSH
51032: LD_INT 1
51034: ARRAY
51035: PPUSH
51036: CALL 71498 0 3
51040: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51041: LD_EXP 130
51045: PUSH
51046: LD_VAR 0 2
51050: ARRAY
51051: PUSH
51052: LD_INT 1
51054: ARRAY
51055: PPUSH
51056: LD_INT 112
51058: PPUSH
51059: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51063: LD_ADDR_VAR 0 9
51067: PUSH
51068: LD_EXP 130
51072: PUSH
51073: LD_VAR 0 2
51077: ARRAY
51078: PPUSH
51079: LD_INT 1
51081: PPUSH
51082: CALL_OW 3
51086: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51087: LD_ADDR_EXP 130
51091: PUSH
51092: LD_EXP 130
51096: PPUSH
51097: LD_VAR 0 2
51101: PPUSH
51102: LD_VAR 0 9
51106: PPUSH
51107: CALL_OW 1
51111: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51112: LD_EXP 130
51116: PUSH
51117: LD_VAR 0 2
51121: ARRAY
51122: PUSH
51123: LD_EXP 131
51127: PUSH
51128: LD_VAR 0 2
51132: ARRAY
51133: AND
51134: PUSH
51135: LD_EXP 131
51139: PUSH
51140: LD_VAR 0 2
51144: ARRAY
51145: PUSH
51146: LD_INT 1
51148: ARRAY
51149: PPUSH
51150: CALL_OW 310
51154: NOT
51155: AND
51156: PUSH
51157: LD_VAR 0 3
51161: PPUSH
51162: CALL_OW 313
51166: PUSH
51167: LD_INT 6
51169: EQUAL
51170: AND
51171: IFFALSE 51227
// begin tmp2 := UnitsInside ( j ) ;
51173: LD_ADDR_VAR 0 9
51177: PUSH
51178: LD_VAR 0 3
51182: PPUSH
51183: CALL_OW 313
51187: ST_TO_ADDR
// if tmp2 = 6 then
51188: LD_VAR 0 9
51192: PUSH
51193: LD_INT 6
51195: EQUAL
51196: IFFALSE 51227
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51198: LD_VAR 0 9
51202: PUSH
51203: LD_INT 1
51205: ARRAY
51206: PPUSH
51207: LD_INT 112
51209: PPUSH
51210: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51214: LD_VAR 0 9
51218: PUSH
51219: LD_INT 1
51221: ARRAY
51222: PPUSH
51223: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51227: LD_EXP 131
51231: PUSH
51232: LD_VAR 0 2
51236: ARRAY
51237: PUSH
51238: LD_EXP 131
51242: PUSH
51243: LD_VAR 0 2
51247: ARRAY
51248: PUSH
51249: LD_INT 1
51251: ARRAY
51252: PPUSH
51253: CALL_OW 314
51257: NOT
51258: AND
51259: PUSH
51260: LD_EXP 131
51264: PUSH
51265: LD_VAR 0 2
51269: ARRAY
51270: PUSH
51271: LD_INT 1
51273: ARRAY
51274: PPUSH
51275: CALL_OW 310
51279: NOT
51280: AND
51281: IFFALSE 51307
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51283: LD_EXP 131
51287: PUSH
51288: LD_VAR 0 2
51292: ARRAY
51293: PUSH
51294: LD_INT 1
51296: ARRAY
51297: PPUSH
51298: LD_VAR 0 3
51302: PPUSH
51303: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51307: LD_EXP 131
51311: PUSH
51312: LD_VAR 0 2
51316: ARRAY
51317: PUSH
51318: LD_INT 1
51320: ARRAY
51321: PPUSH
51322: CALL_OW 310
51326: PUSH
51327: LD_EXP 131
51331: PUSH
51332: LD_VAR 0 2
51336: ARRAY
51337: PUSH
51338: LD_INT 1
51340: ARRAY
51341: PPUSH
51342: CALL_OW 310
51346: PPUSH
51347: CALL_OW 461
51351: PUSH
51352: LD_INT 3
51354: NONEQUAL
51355: AND
51356: IFFALSE 51377
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51358: LD_EXP 131
51362: PUSH
51363: LD_VAR 0 2
51367: ARRAY
51368: PUSH
51369: LD_INT 1
51371: ARRAY
51372: PPUSH
51373: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51377: LD_VAR 0 3
51381: PPUSH
51382: CALL_OW 461
51386: PUSH
51387: LD_INT 6
51389: EQUAL
51390: PUSH
51391: LD_VAR 0 6
51395: PUSH
51396: LD_INT 1
51398: GREATER
51399: AND
51400: IFFALSE 51552
// begin sci := [ ] ;
51402: LD_ADDR_VAR 0 8
51406: PUSH
51407: EMPTY
51408: ST_TO_ADDR
// for x in ( tmp diff j ) do
51409: LD_ADDR_VAR 0 7
51413: PUSH
51414: LD_VAR 0 6
51418: PUSH
51419: LD_VAR 0 3
51423: DIFF
51424: PUSH
51425: FOR_IN
51426: IFFALSE 51478
// begin if sci = 6 then
51428: LD_VAR 0 8
51432: PUSH
51433: LD_INT 6
51435: EQUAL
51436: IFFALSE 51440
// break ;
51438: GO 51478
// if BuildingStatus ( x ) = bs_idle then
51440: LD_VAR 0 7
51444: PPUSH
51445: CALL_OW 461
51449: PUSH
51450: LD_INT 2
51452: EQUAL
51453: IFFALSE 51476
// sci := sci ^ UnitsInside ( x ) ;
51455: LD_ADDR_VAR 0 8
51459: PUSH
51460: LD_VAR 0 8
51464: PUSH
51465: LD_VAR 0 7
51469: PPUSH
51470: CALL_OW 313
51474: ADD
51475: ST_TO_ADDR
// end ;
51476: GO 51425
51478: POP
51479: POP
// if not sci then
51480: LD_VAR 0 8
51484: NOT
51485: IFFALSE 51489
// continue ;
51487: GO 50534
// for x in sci do
51489: LD_ADDR_VAR 0 7
51493: PUSH
51494: LD_VAR 0 8
51498: PUSH
51499: FOR_IN
51500: IFFALSE 51550
// if IsInUnit ( x ) and not HasTask ( x ) then
51502: LD_VAR 0 7
51506: PPUSH
51507: CALL_OW 310
51511: PUSH
51512: LD_VAR 0 7
51516: PPUSH
51517: CALL_OW 314
51521: NOT
51522: AND
51523: IFFALSE 51548
// begin ComExitBuilding ( x ) ;
51525: LD_VAR 0 7
51529: PPUSH
51530: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51534: LD_VAR 0 7
51538: PPUSH
51539: LD_VAR 0 3
51543: PPUSH
51544: CALL_OW 180
// end ;
51548: GO 51499
51550: POP
51551: POP
// end ; end ;
51552: GO 50534
51554: POP
51555: POP
// end ;
51556: GO 50488
51558: POP
51559: POP
// end ;
51560: LD_VAR 0 1
51564: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51565: LD_INT 0
51567: PPUSH
51568: PPUSH
// if not mc_bases then
51569: LD_EXP 101
51573: NOT
51574: IFFALSE 51578
// exit ;
51576: GO 51659
// for i = 1 to mc_bases do
51578: LD_ADDR_VAR 0 2
51582: PUSH
51583: DOUBLE
51584: LD_INT 1
51586: DEC
51587: ST_TO_ADDR
51588: LD_EXP 101
51592: PUSH
51593: FOR_TO
51594: IFFALSE 51657
// if mc_mines [ i ] and mc_miners [ i ] then
51596: LD_EXP 114
51600: PUSH
51601: LD_VAR 0 2
51605: ARRAY
51606: PUSH
51607: LD_EXP 115
51611: PUSH
51612: LD_VAR 0 2
51616: ARRAY
51617: AND
51618: IFFALSE 51655
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51620: LD_EXP 115
51624: PUSH
51625: LD_VAR 0 2
51629: ARRAY
51630: PUSH
51631: LD_INT 1
51633: ARRAY
51634: PPUSH
51635: CALL_OW 255
51639: PPUSH
51640: LD_EXP 114
51644: PUSH
51645: LD_VAR 0 2
51649: ARRAY
51650: PPUSH
51651: CALL 68487 0 2
51655: GO 51593
51657: POP
51658: POP
// end ;
51659: LD_VAR 0 1
51663: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51664: LD_INT 0
51666: PPUSH
51667: PPUSH
51668: PPUSH
51669: PPUSH
51670: PPUSH
51671: PPUSH
51672: PPUSH
51673: PPUSH
// if not mc_bases or not mc_parking then
51674: LD_EXP 101
51678: NOT
51679: PUSH
51680: LD_EXP 125
51684: NOT
51685: OR
51686: IFFALSE 51690
// exit ;
51688: GO 52389
// for i = 1 to mc_bases do
51690: LD_ADDR_VAR 0 2
51694: PUSH
51695: DOUBLE
51696: LD_INT 1
51698: DEC
51699: ST_TO_ADDR
51700: LD_EXP 101
51704: PUSH
51705: FOR_TO
51706: IFFALSE 52387
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51708: LD_EXP 101
51712: PUSH
51713: LD_VAR 0 2
51717: ARRAY
51718: NOT
51719: PUSH
51720: LD_EXP 125
51724: PUSH
51725: LD_VAR 0 2
51729: ARRAY
51730: NOT
51731: OR
51732: IFFALSE 51736
// continue ;
51734: GO 51705
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51736: LD_ADDR_VAR 0 5
51740: PUSH
51741: LD_EXP 101
51745: PUSH
51746: LD_VAR 0 2
51750: ARRAY
51751: PUSH
51752: LD_INT 1
51754: ARRAY
51755: PPUSH
51756: CALL_OW 255
51760: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51761: LD_ADDR_VAR 0 6
51765: PUSH
51766: LD_EXP 101
51770: PUSH
51771: LD_VAR 0 2
51775: ARRAY
51776: PPUSH
51777: LD_INT 30
51779: PUSH
51780: LD_INT 3
51782: PUSH
51783: EMPTY
51784: LIST
51785: LIST
51786: PPUSH
51787: CALL_OW 72
51791: ST_TO_ADDR
// if not fac then
51792: LD_VAR 0 6
51796: NOT
51797: IFFALSE 51848
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51799: LD_ADDR_VAR 0 6
51803: PUSH
51804: LD_EXP 101
51808: PUSH
51809: LD_VAR 0 2
51813: ARRAY
51814: PPUSH
51815: LD_INT 2
51817: PUSH
51818: LD_INT 30
51820: PUSH
51821: LD_INT 0
51823: PUSH
51824: EMPTY
51825: LIST
51826: LIST
51827: PUSH
51828: LD_INT 30
51830: PUSH
51831: LD_INT 1
51833: PUSH
51834: EMPTY
51835: LIST
51836: LIST
51837: PUSH
51838: EMPTY
51839: LIST
51840: LIST
51841: LIST
51842: PPUSH
51843: CALL_OW 72
51847: ST_TO_ADDR
// if not fac then
51848: LD_VAR 0 6
51852: NOT
51853: IFFALSE 51857
// continue ;
51855: GO 51705
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51857: LD_ADDR_VAR 0 7
51861: PUSH
51862: LD_EXP 125
51866: PUSH
51867: LD_VAR 0 2
51871: ARRAY
51872: PPUSH
51873: LD_INT 22
51875: PUSH
51876: LD_VAR 0 5
51880: PUSH
51881: EMPTY
51882: LIST
51883: LIST
51884: PUSH
51885: LD_INT 21
51887: PUSH
51888: LD_INT 2
51890: PUSH
51891: EMPTY
51892: LIST
51893: LIST
51894: PUSH
51895: LD_INT 3
51897: PUSH
51898: LD_INT 24
51900: PUSH
51901: LD_INT 1000
51903: PUSH
51904: EMPTY
51905: LIST
51906: LIST
51907: PUSH
51908: EMPTY
51909: LIST
51910: LIST
51911: PUSH
51912: EMPTY
51913: LIST
51914: LIST
51915: LIST
51916: PPUSH
51917: CALL_OW 70
51921: ST_TO_ADDR
// for j in fac do
51922: LD_ADDR_VAR 0 3
51926: PUSH
51927: LD_VAR 0 6
51931: PUSH
51932: FOR_IN
51933: IFFALSE 52014
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51935: LD_ADDR_VAR 0 7
51939: PUSH
51940: LD_VAR 0 7
51944: PUSH
51945: LD_INT 22
51947: PUSH
51948: LD_VAR 0 5
51952: PUSH
51953: EMPTY
51954: LIST
51955: LIST
51956: PUSH
51957: LD_INT 91
51959: PUSH
51960: LD_VAR 0 3
51964: PUSH
51965: LD_INT 15
51967: PUSH
51968: EMPTY
51969: LIST
51970: LIST
51971: LIST
51972: PUSH
51973: LD_INT 21
51975: PUSH
51976: LD_INT 2
51978: PUSH
51979: EMPTY
51980: LIST
51981: LIST
51982: PUSH
51983: LD_INT 3
51985: PUSH
51986: LD_INT 24
51988: PUSH
51989: LD_INT 1000
51991: PUSH
51992: EMPTY
51993: LIST
51994: LIST
51995: PUSH
51996: EMPTY
51997: LIST
51998: LIST
51999: PUSH
52000: EMPTY
52001: LIST
52002: LIST
52003: LIST
52004: LIST
52005: PPUSH
52006: CALL_OW 69
52010: UNION
52011: ST_TO_ADDR
52012: GO 51932
52014: POP
52015: POP
// if not vehs then
52016: LD_VAR 0 7
52020: NOT
52021: IFFALSE 52047
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52023: LD_ADDR_EXP 113
52027: PUSH
52028: LD_EXP 113
52032: PPUSH
52033: LD_VAR 0 2
52037: PPUSH
52038: EMPTY
52039: PPUSH
52040: CALL_OW 1
52044: ST_TO_ADDR
// continue ;
52045: GO 51705
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52047: LD_ADDR_VAR 0 8
52051: PUSH
52052: LD_EXP 101
52056: PUSH
52057: LD_VAR 0 2
52061: ARRAY
52062: PPUSH
52063: LD_INT 30
52065: PUSH
52066: LD_INT 3
52068: PUSH
52069: EMPTY
52070: LIST
52071: LIST
52072: PPUSH
52073: CALL_OW 72
52077: ST_TO_ADDR
// if tmp then
52078: LD_VAR 0 8
52082: IFFALSE 52185
// begin for j in tmp do
52084: LD_ADDR_VAR 0 3
52088: PUSH
52089: LD_VAR 0 8
52093: PUSH
52094: FOR_IN
52095: IFFALSE 52183
// for k in UnitsInside ( j ) do
52097: LD_ADDR_VAR 0 4
52101: PUSH
52102: LD_VAR 0 3
52106: PPUSH
52107: CALL_OW 313
52111: PUSH
52112: FOR_IN
52113: IFFALSE 52179
// if k then
52115: LD_VAR 0 4
52119: IFFALSE 52177
// if not k in mc_repair_vehicle [ i ] then
52121: LD_VAR 0 4
52125: PUSH
52126: LD_EXP 113
52130: PUSH
52131: LD_VAR 0 2
52135: ARRAY
52136: IN
52137: NOT
52138: IFFALSE 52177
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52140: LD_ADDR_EXP 113
52144: PUSH
52145: LD_EXP 113
52149: PPUSH
52150: LD_VAR 0 2
52154: PPUSH
52155: LD_EXP 113
52159: PUSH
52160: LD_VAR 0 2
52164: ARRAY
52165: PUSH
52166: LD_VAR 0 4
52170: UNION
52171: PPUSH
52172: CALL_OW 1
52176: ST_TO_ADDR
52177: GO 52112
52179: POP
52180: POP
52181: GO 52094
52183: POP
52184: POP
// end ; if not mc_repair_vehicle [ i ] then
52185: LD_EXP 113
52189: PUSH
52190: LD_VAR 0 2
52194: ARRAY
52195: NOT
52196: IFFALSE 52200
// continue ;
52198: GO 51705
// for j in mc_repair_vehicle [ i ] do
52200: LD_ADDR_VAR 0 3
52204: PUSH
52205: LD_EXP 113
52209: PUSH
52210: LD_VAR 0 2
52214: ARRAY
52215: PUSH
52216: FOR_IN
52217: IFFALSE 52383
// begin if GetClass ( j ) <> 3 then
52219: LD_VAR 0 3
52223: PPUSH
52224: CALL_OW 257
52228: PUSH
52229: LD_INT 3
52231: NONEQUAL
52232: IFFALSE 52273
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52234: LD_ADDR_EXP 113
52238: PUSH
52239: LD_EXP 113
52243: PPUSH
52244: LD_VAR 0 2
52248: PPUSH
52249: LD_EXP 113
52253: PUSH
52254: LD_VAR 0 2
52258: ARRAY
52259: PUSH
52260: LD_VAR 0 3
52264: DIFF
52265: PPUSH
52266: CALL_OW 1
52270: ST_TO_ADDR
// continue ;
52271: GO 52216
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52273: LD_VAR 0 3
52277: PPUSH
52278: CALL_OW 311
52282: NOT
52283: PUSH
52284: LD_VAR 0 3
52288: PUSH
52289: LD_EXP 104
52293: PUSH
52294: LD_VAR 0 2
52298: ARRAY
52299: PUSH
52300: LD_INT 1
52302: ARRAY
52303: IN
52304: NOT
52305: AND
52306: PUSH
52307: LD_VAR 0 3
52311: PUSH
52312: LD_EXP 104
52316: PUSH
52317: LD_VAR 0 2
52321: ARRAY
52322: PUSH
52323: LD_INT 2
52325: ARRAY
52326: IN
52327: NOT
52328: AND
52329: IFFALSE 52381
// begin if IsInUnit ( j ) then
52331: LD_VAR 0 3
52335: PPUSH
52336: CALL_OW 310
52340: IFFALSE 52351
// ComExitBuilding ( j ) ;
52342: LD_VAR 0 3
52346: PPUSH
52347: CALL_OW 122
// if not HasTask ( j ) then
52351: LD_VAR 0 3
52355: PPUSH
52356: CALL_OW 314
52360: NOT
52361: IFFALSE 52381
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52363: LD_VAR 0 3
52367: PPUSH
52368: LD_VAR 0 7
52372: PUSH
52373: LD_INT 1
52375: ARRAY
52376: PPUSH
52377: CALL_OW 189
// end ; end ;
52381: GO 52216
52383: POP
52384: POP
// end ;
52385: GO 51705
52387: POP
52388: POP
// end ;
52389: LD_VAR 0 1
52393: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52394: LD_INT 0
52396: PPUSH
52397: PPUSH
52398: PPUSH
52399: PPUSH
52400: PPUSH
52401: PPUSH
52402: PPUSH
52403: PPUSH
52404: PPUSH
52405: PPUSH
52406: PPUSH
// if not mc_bases then
52407: LD_EXP 101
52411: NOT
52412: IFFALSE 52416
// exit ;
52414: GO 53218
// for i = 1 to mc_bases do
52416: LD_ADDR_VAR 0 2
52420: PUSH
52421: DOUBLE
52422: LD_INT 1
52424: DEC
52425: ST_TO_ADDR
52426: LD_EXP 101
52430: PUSH
52431: FOR_TO
52432: IFFALSE 53216
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52434: LD_EXP 129
52438: PUSH
52439: LD_VAR 0 2
52443: ARRAY
52444: NOT
52445: PUSH
52446: LD_EXP 104
52450: PUSH
52451: LD_VAR 0 2
52455: ARRAY
52456: PUSH
52457: LD_INT 1
52459: ARRAY
52460: OR
52461: PUSH
52462: LD_EXP 104
52466: PUSH
52467: LD_VAR 0 2
52471: ARRAY
52472: PUSH
52473: LD_INT 2
52475: ARRAY
52476: OR
52477: PUSH
52478: LD_EXP 127
52482: PUSH
52483: LD_VAR 0 2
52487: ARRAY
52488: PPUSH
52489: LD_INT 1
52491: PPUSH
52492: CALL_OW 325
52496: NOT
52497: OR
52498: PUSH
52499: LD_EXP 124
52503: PUSH
52504: LD_VAR 0 2
52508: ARRAY
52509: OR
52510: IFFALSE 52514
// continue ;
52512: GO 52431
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52514: LD_ADDR_VAR 0 8
52518: PUSH
52519: LD_EXP 101
52523: PUSH
52524: LD_VAR 0 2
52528: ARRAY
52529: PPUSH
52530: LD_INT 25
52532: PUSH
52533: LD_INT 4
52535: PUSH
52536: EMPTY
52537: LIST
52538: LIST
52539: PUSH
52540: LD_INT 50
52542: PUSH
52543: EMPTY
52544: LIST
52545: PUSH
52546: LD_INT 3
52548: PUSH
52549: LD_INT 60
52551: PUSH
52552: EMPTY
52553: LIST
52554: PUSH
52555: EMPTY
52556: LIST
52557: LIST
52558: PUSH
52559: EMPTY
52560: LIST
52561: LIST
52562: LIST
52563: PPUSH
52564: CALL_OW 72
52568: PUSH
52569: LD_EXP 105
52573: PUSH
52574: LD_VAR 0 2
52578: ARRAY
52579: DIFF
52580: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52581: LD_ADDR_VAR 0 9
52585: PUSH
52586: LD_EXP 101
52590: PUSH
52591: LD_VAR 0 2
52595: ARRAY
52596: PPUSH
52597: LD_INT 2
52599: PUSH
52600: LD_INT 30
52602: PUSH
52603: LD_INT 0
52605: PUSH
52606: EMPTY
52607: LIST
52608: LIST
52609: PUSH
52610: LD_INT 30
52612: PUSH
52613: LD_INT 1
52615: PUSH
52616: EMPTY
52617: LIST
52618: LIST
52619: PUSH
52620: EMPTY
52621: LIST
52622: LIST
52623: LIST
52624: PPUSH
52625: CALL_OW 72
52629: ST_TO_ADDR
// if not tmp or not dep then
52630: LD_VAR 0 8
52634: NOT
52635: PUSH
52636: LD_VAR 0 9
52640: NOT
52641: OR
52642: IFFALSE 52646
// continue ;
52644: GO 52431
// side := GetSide ( tmp [ 1 ] ) ;
52646: LD_ADDR_VAR 0 11
52650: PUSH
52651: LD_VAR 0 8
52655: PUSH
52656: LD_INT 1
52658: ARRAY
52659: PPUSH
52660: CALL_OW 255
52664: ST_TO_ADDR
// dep := dep [ 1 ] ;
52665: LD_ADDR_VAR 0 9
52669: PUSH
52670: LD_VAR 0 9
52674: PUSH
52675: LD_INT 1
52677: ARRAY
52678: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52679: LD_ADDR_VAR 0 7
52683: PUSH
52684: LD_EXP 129
52688: PUSH
52689: LD_VAR 0 2
52693: ARRAY
52694: PPUSH
52695: LD_INT 22
52697: PUSH
52698: LD_INT 0
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: PUSH
52705: LD_INT 25
52707: PUSH
52708: LD_INT 12
52710: PUSH
52711: EMPTY
52712: LIST
52713: LIST
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: PPUSH
52719: CALL_OW 70
52723: PUSH
52724: LD_INT 22
52726: PUSH
52727: LD_INT 0
52729: PUSH
52730: EMPTY
52731: LIST
52732: LIST
52733: PUSH
52734: LD_INT 25
52736: PUSH
52737: LD_INT 12
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: PUSH
52744: LD_INT 91
52746: PUSH
52747: LD_VAR 0 9
52751: PUSH
52752: LD_INT 20
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: LIST
52759: PUSH
52760: EMPTY
52761: LIST
52762: LIST
52763: LIST
52764: PPUSH
52765: CALL_OW 69
52769: UNION
52770: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52771: LD_ADDR_VAR 0 10
52775: PUSH
52776: LD_EXP 129
52780: PUSH
52781: LD_VAR 0 2
52785: ARRAY
52786: PPUSH
52787: LD_INT 81
52789: PUSH
52790: LD_VAR 0 11
52794: PUSH
52795: EMPTY
52796: LIST
52797: LIST
52798: PPUSH
52799: CALL_OW 70
52803: ST_TO_ADDR
// if not apes or danger_at_area then
52804: LD_VAR 0 7
52808: NOT
52809: PUSH
52810: LD_VAR 0 10
52814: OR
52815: IFFALSE 52865
// begin if mc_taming [ i ] then
52817: LD_EXP 132
52821: PUSH
52822: LD_VAR 0 2
52826: ARRAY
52827: IFFALSE 52863
// begin MC_Reset ( i , 121 ) ;
52829: LD_VAR 0 2
52833: PPUSH
52834: LD_INT 121
52836: PPUSH
52837: CALL 38300 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52841: LD_ADDR_EXP 132
52845: PUSH
52846: LD_EXP 132
52850: PPUSH
52851: LD_VAR 0 2
52855: PPUSH
52856: EMPTY
52857: PPUSH
52858: CALL_OW 1
52862: ST_TO_ADDR
// end ; continue ;
52863: GO 52431
// end ; for j in tmp do
52865: LD_ADDR_VAR 0 3
52869: PUSH
52870: LD_VAR 0 8
52874: PUSH
52875: FOR_IN
52876: IFFALSE 53212
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52878: LD_VAR 0 3
52882: PUSH
52883: LD_EXP 132
52887: PUSH
52888: LD_VAR 0 2
52892: ARRAY
52893: IN
52894: NOT
52895: PUSH
52896: LD_EXP 132
52900: PUSH
52901: LD_VAR 0 2
52905: ARRAY
52906: PUSH
52907: LD_INT 3
52909: LESS
52910: AND
52911: IFFALSE 52969
// begin SetTag ( j , 121 ) ;
52913: LD_VAR 0 3
52917: PPUSH
52918: LD_INT 121
52920: PPUSH
52921: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52925: LD_ADDR_EXP 132
52929: PUSH
52930: LD_EXP 132
52934: PPUSH
52935: LD_VAR 0 2
52939: PUSH
52940: LD_EXP 132
52944: PUSH
52945: LD_VAR 0 2
52949: ARRAY
52950: PUSH
52951: LD_INT 1
52953: PLUS
52954: PUSH
52955: EMPTY
52956: LIST
52957: LIST
52958: PPUSH
52959: LD_VAR 0 3
52963: PPUSH
52964: CALL 71498 0 3
52968: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52969: LD_VAR 0 3
52973: PUSH
52974: LD_EXP 132
52978: PUSH
52979: LD_VAR 0 2
52983: ARRAY
52984: IN
52985: IFFALSE 53210
// begin if GetClass ( j ) <> 4 then
52987: LD_VAR 0 3
52991: PPUSH
52992: CALL_OW 257
52996: PUSH
52997: LD_INT 4
52999: NONEQUAL
53000: IFFALSE 53053
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53002: LD_ADDR_EXP 132
53006: PUSH
53007: LD_EXP 132
53011: PPUSH
53012: LD_VAR 0 2
53016: PPUSH
53017: LD_EXP 132
53021: PUSH
53022: LD_VAR 0 2
53026: ARRAY
53027: PUSH
53028: LD_VAR 0 3
53032: DIFF
53033: PPUSH
53034: CALL_OW 1
53038: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53039: LD_VAR 0 3
53043: PPUSH
53044: LD_INT 0
53046: PPUSH
53047: CALL_OW 109
// continue ;
53051: GO 52875
// end ; if IsInUnit ( j ) then
53053: LD_VAR 0 3
53057: PPUSH
53058: CALL_OW 310
53062: IFFALSE 53073
// ComExitBuilding ( j ) ;
53064: LD_VAR 0 3
53068: PPUSH
53069: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53073: LD_ADDR_VAR 0 6
53077: PUSH
53078: LD_VAR 0 7
53082: PPUSH
53083: LD_VAR 0 3
53087: PPUSH
53088: CALL_OW 74
53092: ST_TO_ADDR
// if not ape then
53093: LD_VAR 0 6
53097: NOT
53098: IFFALSE 53102
// break ;
53100: GO 53212
// x := GetX ( ape ) ;
53102: LD_ADDR_VAR 0 4
53106: PUSH
53107: LD_VAR 0 6
53111: PPUSH
53112: CALL_OW 250
53116: ST_TO_ADDR
// y := GetY ( ape ) ;
53117: LD_ADDR_VAR 0 5
53121: PUSH
53122: LD_VAR 0 6
53126: PPUSH
53127: CALL_OW 251
53131: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53132: LD_VAR 0 4
53136: PPUSH
53137: LD_VAR 0 5
53141: PPUSH
53142: CALL_OW 488
53146: NOT
53147: PUSH
53148: LD_VAR 0 11
53152: PPUSH
53153: LD_VAR 0 4
53157: PPUSH
53158: LD_VAR 0 5
53162: PPUSH
53163: LD_INT 20
53165: PPUSH
53166: CALL 72394 0 4
53170: PUSH
53171: LD_INT 4
53173: ARRAY
53174: OR
53175: IFFALSE 53179
// break ;
53177: GO 53212
// if not HasTask ( j ) then
53179: LD_VAR 0 3
53183: PPUSH
53184: CALL_OW 314
53188: NOT
53189: IFFALSE 53210
// ComTameXY ( j , x , y ) ;
53191: LD_VAR 0 3
53195: PPUSH
53196: LD_VAR 0 4
53200: PPUSH
53201: LD_VAR 0 5
53205: PPUSH
53206: CALL_OW 131
// end ; end ;
53210: GO 52875
53212: POP
53213: POP
// end ;
53214: GO 52431
53216: POP
53217: POP
// end ;
53218: LD_VAR 0 1
53222: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53223: LD_INT 0
53225: PPUSH
53226: PPUSH
53227: PPUSH
53228: PPUSH
53229: PPUSH
53230: PPUSH
53231: PPUSH
53232: PPUSH
// if not mc_bases then
53233: LD_EXP 101
53237: NOT
53238: IFFALSE 53242
// exit ;
53240: GO 53868
// for i = 1 to mc_bases do
53242: LD_ADDR_VAR 0 2
53246: PUSH
53247: DOUBLE
53248: LD_INT 1
53250: DEC
53251: ST_TO_ADDR
53252: LD_EXP 101
53256: PUSH
53257: FOR_TO
53258: IFFALSE 53866
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53260: LD_EXP 130
53264: PUSH
53265: LD_VAR 0 2
53269: ARRAY
53270: NOT
53271: PUSH
53272: LD_EXP 130
53276: PUSH
53277: LD_VAR 0 2
53281: ARRAY
53282: PPUSH
53283: LD_INT 25
53285: PUSH
53286: LD_INT 12
53288: PUSH
53289: EMPTY
53290: LIST
53291: LIST
53292: PPUSH
53293: CALL_OW 72
53297: NOT
53298: OR
53299: IFFALSE 53303
// continue ;
53301: GO 53257
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53303: LD_ADDR_VAR 0 5
53307: PUSH
53308: LD_EXP 130
53312: PUSH
53313: LD_VAR 0 2
53317: ARRAY
53318: PUSH
53319: LD_INT 1
53321: ARRAY
53322: PPUSH
53323: CALL_OW 255
53327: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53328: LD_VAR 0 5
53332: PPUSH
53333: LD_INT 2
53335: PPUSH
53336: CALL_OW 325
53340: IFFALSE 53593
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53342: LD_ADDR_VAR 0 4
53346: PUSH
53347: LD_EXP 130
53351: PUSH
53352: LD_VAR 0 2
53356: ARRAY
53357: PPUSH
53358: LD_INT 25
53360: PUSH
53361: LD_INT 16
53363: PUSH
53364: EMPTY
53365: LIST
53366: LIST
53367: PPUSH
53368: CALL_OW 72
53372: ST_TO_ADDR
// if tmp < 6 then
53373: LD_VAR 0 4
53377: PUSH
53378: LD_INT 6
53380: LESS
53381: IFFALSE 53593
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53383: LD_ADDR_VAR 0 6
53387: PUSH
53388: LD_EXP 101
53392: PUSH
53393: LD_VAR 0 2
53397: ARRAY
53398: PPUSH
53399: LD_INT 2
53401: PUSH
53402: LD_INT 30
53404: PUSH
53405: LD_INT 0
53407: PUSH
53408: EMPTY
53409: LIST
53410: LIST
53411: PUSH
53412: LD_INT 30
53414: PUSH
53415: LD_INT 1
53417: PUSH
53418: EMPTY
53419: LIST
53420: LIST
53421: PUSH
53422: EMPTY
53423: LIST
53424: LIST
53425: LIST
53426: PPUSH
53427: CALL_OW 72
53431: ST_TO_ADDR
// if depot then
53432: LD_VAR 0 6
53436: IFFALSE 53593
// begin selected := 0 ;
53438: LD_ADDR_VAR 0 7
53442: PUSH
53443: LD_INT 0
53445: ST_TO_ADDR
// for j in depot do
53446: LD_ADDR_VAR 0 3
53450: PUSH
53451: LD_VAR 0 6
53455: PUSH
53456: FOR_IN
53457: IFFALSE 53488
// begin if UnitsInside ( j ) < 6 then
53459: LD_VAR 0 3
53463: PPUSH
53464: CALL_OW 313
53468: PUSH
53469: LD_INT 6
53471: LESS
53472: IFFALSE 53486
// begin selected := j ;
53474: LD_ADDR_VAR 0 7
53478: PUSH
53479: LD_VAR 0 3
53483: ST_TO_ADDR
// break ;
53484: GO 53488
// end ; end ;
53486: GO 53456
53488: POP
53489: POP
// if selected then
53490: LD_VAR 0 7
53494: IFFALSE 53593
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53496: LD_ADDR_VAR 0 3
53500: PUSH
53501: LD_EXP 130
53505: PUSH
53506: LD_VAR 0 2
53510: ARRAY
53511: PPUSH
53512: LD_INT 25
53514: PUSH
53515: LD_INT 12
53517: PUSH
53518: EMPTY
53519: LIST
53520: LIST
53521: PPUSH
53522: CALL_OW 72
53526: PUSH
53527: FOR_IN
53528: IFFALSE 53591
// if not HasTask ( j ) then
53530: LD_VAR 0 3
53534: PPUSH
53535: CALL_OW 314
53539: NOT
53540: IFFALSE 53589
// begin if not IsInUnit ( j ) then
53542: LD_VAR 0 3
53546: PPUSH
53547: CALL_OW 310
53551: NOT
53552: IFFALSE 53568
// ComEnterUnit ( j , selected ) ;
53554: LD_VAR 0 3
53558: PPUSH
53559: LD_VAR 0 7
53563: PPUSH
53564: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53568: LD_VAR 0 3
53572: PPUSH
53573: LD_INT 16
53575: PPUSH
53576: CALL_OW 183
// AddComExitBuilding ( j ) ;
53580: LD_VAR 0 3
53584: PPUSH
53585: CALL_OW 182
// end ;
53589: GO 53527
53591: POP
53592: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53593: LD_VAR 0 5
53597: PPUSH
53598: LD_INT 11
53600: PPUSH
53601: CALL_OW 325
53605: IFFALSE 53864
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53607: LD_ADDR_VAR 0 4
53611: PUSH
53612: LD_EXP 130
53616: PUSH
53617: LD_VAR 0 2
53621: ARRAY
53622: PPUSH
53623: LD_INT 25
53625: PUSH
53626: LD_INT 16
53628: PUSH
53629: EMPTY
53630: LIST
53631: LIST
53632: PPUSH
53633: CALL_OW 72
53637: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53638: LD_VAR 0 4
53642: PUSH
53643: LD_INT 6
53645: GREATEREQUAL
53646: PUSH
53647: LD_VAR 0 5
53651: PPUSH
53652: LD_INT 2
53654: PPUSH
53655: CALL_OW 325
53659: NOT
53660: OR
53661: IFFALSE 53864
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53663: LD_ADDR_VAR 0 8
53667: PUSH
53668: LD_EXP 101
53672: PUSH
53673: LD_VAR 0 2
53677: ARRAY
53678: PPUSH
53679: LD_INT 2
53681: PUSH
53682: LD_INT 30
53684: PUSH
53685: LD_INT 4
53687: PUSH
53688: EMPTY
53689: LIST
53690: LIST
53691: PUSH
53692: LD_INT 30
53694: PUSH
53695: LD_INT 5
53697: PUSH
53698: EMPTY
53699: LIST
53700: LIST
53701: PUSH
53702: EMPTY
53703: LIST
53704: LIST
53705: LIST
53706: PPUSH
53707: CALL_OW 72
53711: ST_TO_ADDR
// if barracks then
53712: LD_VAR 0 8
53716: IFFALSE 53864
// begin selected := 0 ;
53718: LD_ADDR_VAR 0 7
53722: PUSH
53723: LD_INT 0
53725: ST_TO_ADDR
// for j in barracks do
53726: LD_ADDR_VAR 0 3
53730: PUSH
53731: LD_VAR 0 8
53735: PUSH
53736: FOR_IN
53737: IFFALSE 53768
// begin if UnitsInside ( j ) < 6 then
53739: LD_VAR 0 3
53743: PPUSH
53744: CALL_OW 313
53748: PUSH
53749: LD_INT 6
53751: LESS
53752: IFFALSE 53766
// begin selected := j ;
53754: LD_ADDR_VAR 0 7
53758: PUSH
53759: LD_VAR 0 3
53763: ST_TO_ADDR
// break ;
53764: GO 53768
// end ; end ;
53766: GO 53736
53768: POP
53769: POP
// if selected then
53770: LD_VAR 0 7
53774: IFFALSE 53864
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53776: LD_ADDR_VAR 0 3
53780: PUSH
53781: LD_EXP 130
53785: PUSH
53786: LD_VAR 0 2
53790: ARRAY
53791: PPUSH
53792: LD_INT 25
53794: PUSH
53795: LD_INT 12
53797: PUSH
53798: EMPTY
53799: LIST
53800: LIST
53801: PPUSH
53802: CALL_OW 72
53806: PUSH
53807: FOR_IN
53808: IFFALSE 53862
// if not IsInUnit ( j ) and not HasTask ( j ) then
53810: LD_VAR 0 3
53814: PPUSH
53815: CALL_OW 310
53819: NOT
53820: PUSH
53821: LD_VAR 0 3
53825: PPUSH
53826: CALL_OW 314
53830: NOT
53831: AND
53832: IFFALSE 53860
// begin ComEnterUnit ( j , selected ) ;
53834: LD_VAR 0 3
53838: PPUSH
53839: LD_VAR 0 7
53843: PPUSH
53844: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53848: LD_VAR 0 3
53852: PPUSH
53853: LD_INT 15
53855: PPUSH
53856: CALL_OW 183
// end ;
53860: GO 53807
53862: POP
53863: POP
// end ; end ; end ; end ; end ;
53864: GO 53257
53866: POP
53867: POP
// end ;
53868: LD_VAR 0 1
53872: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53873: LD_INT 0
53875: PPUSH
53876: PPUSH
53877: PPUSH
53878: PPUSH
// if not mc_bases then
53879: LD_EXP 101
53883: NOT
53884: IFFALSE 53888
// exit ;
53886: GO 54066
// for i = 1 to mc_bases do
53888: LD_ADDR_VAR 0 2
53892: PUSH
53893: DOUBLE
53894: LD_INT 1
53896: DEC
53897: ST_TO_ADDR
53898: LD_EXP 101
53902: PUSH
53903: FOR_TO
53904: IFFALSE 54064
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53906: LD_ADDR_VAR 0 4
53910: PUSH
53911: LD_EXP 101
53915: PUSH
53916: LD_VAR 0 2
53920: ARRAY
53921: PPUSH
53922: LD_INT 25
53924: PUSH
53925: LD_INT 9
53927: PUSH
53928: EMPTY
53929: LIST
53930: LIST
53931: PPUSH
53932: CALL_OW 72
53936: ST_TO_ADDR
// if not tmp then
53937: LD_VAR 0 4
53941: NOT
53942: IFFALSE 53946
// continue ;
53944: GO 53903
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53946: LD_EXP 127
53950: PUSH
53951: LD_VAR 0 2
53955: ARRAY
53956: PPUSH
53957: LD_INT 29
53959: PPUSH
53960: CALL_OW 325
53964: NOT
53965: PUSH
53966: LD_EXP 127
53970: PUSH
53971: LD_VAR 0 2
53975: ARRAY
53976: PPUSH
53977: LD_INT 28
53979: PPUSH
53980: CALL_OW 325
53984: NOT
53985: AND
53986: IFFALSE 53990
// continue ;
53988: GO 53903
// for j in tmp do
53990: LD_ADDR_VAR 0 3
53994: PUSH
53995: LD_VAR 0 4
53999: PUSH
54000: FOR_IN
54001: IFFALSE 54060
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54003: LD_VAR 0 3
54007: PUSH
54008: LD_EXP 104
54012: PUSH
54013: LD_VAR 0 2
54017: ARRAY
54018: PUSH
54019: LD_INT 1
54021: ARRAY
54022: IN
54023: NOT
54024: PUSH
54025: LD_VAR 0 3
54029: PUSH
54030: LD_EXP 104
54034: PUSH
54035: LD_VAR 0 2
54039: ARRAY
54040: PUSH
54041: LD_INT 2
54043: ARRAY
54044: IN
54045: NOT
54046: AND
54047: IFFALSE 54058
// ComSpaceTimeShoot ( j ) ;
54049: LD_VAR 0 3
54053: PPUSH
54054: CALL 65084 0 1
54058: GO 54000
54060: POP
54061: POP
// end ;
54062: GO 53903
54064: POP
54065: POP
// end ;
54066: LD_VAR 0 1
54070: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54071: LD_INT 0
54073: PPUSH
54074: PPUSH
54075: PPUSH
54076: PPUSH
54077: PPUSH
54078: PPUSH
54079: PPUSH
54080: PPUSH
54081: PPUSH
// if not mc_bases then
54082: LD_EXP 101
54086: NOT
54087: IFFALSE 54091
// exit ;
54089: GO 54713
// for i = 1 to mc_bases do
54091: LD_ADDR_VAR 0 2
54095: PUSH
54096: DOUBLE
54097: LD_INT 1
54099: DEC
54100: ST_TO_ADDR
54101: LD_EXP 101
54105: PUSH
54106: FOR_TO
54107: IFFALSE 54711
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54109: LD_EXP 136
54113: PUSH
54114: LD_VAR 0 2
54118: ARRAY
54119: NOT
54120: PUSH
54121: LD_INT 38
54123: PPUSH
54124: LD_EXP 127
54128: PUSH
54129: LD_VAR 0 2
54133: ARRAY
54134: PPUSH
54135: CALL_OW 321
54139: PUSH
54140: LD_INT 2
54142: NONEQUAL
54143: OR
54144: IFFALSE 54148
// continue ;
54146: GO 54106
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54148: LD_ADDR_VAR 0 8
54152: PUSH
54153: LD_EXP 101
54157: PUSH
54158: LD_VAR 0 2
54162: ARRAY
54163: PPUSH
54164: LD_INT 30
54166: PUSH
54167: LD_INT 34
54169: PUSH
54170: EMPTY
54171: LIST
54172: LIST
54173: PPUSH
54174: CALL_OW 72
54178: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54179: LD_ADDR_VAR 0 9
54183: PUSH
54184: LD_EXP 101
54188: PUSH
54189: LD_VAR 0 2
54193: ARRAY
54194: PPUSH
54195: LD_INT 25
54197: PUSH
54198: LD_INT 4
54200: PUSH
54201: EMPTY
54202: LIST
54203: LIST
54204: PPUSH
54205: CALL_OW 72
54209: PPUSH
54210: LD_INT 0
54212: PPUSH
54213: CALL 104784 0 2
54217: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54218: LD_VAR 0 9
54222: NOT
54223: PUSH
54224: LD_VAR 0 8
54228: NOT
54229: OR
54230: PUSH
54231: LD_EXP 101
54235: PUSH
54236: LD_VAR 0 2
54240: ARRAY
54241: PPUSH
54242: LD_INT 124
54244: PPUSH
54245: CALL 104784 0 2
54249: OR
54250: IFFALSE 54254
// continue ;
54252: GO 54106
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54254: LD_EXP 137
54258: PUSH
54259: LD_VAR 0 2
54263: ARRAY
54264: PUSH
54265: LD_EXP 136
54269: PUSH
54270: LD_VAR 0 2
54274: ARRAY
54275: LESS
54276: PUSH
54277: LD_EXP 137
54281: PUSH
54282: LD_VAR 0 2
54286: ARRAY
54287: PUSH
54288: LD_VAR 0 8
54292: LESS
54293: AND
54294: IFFALSE 54709
// begin tmp := sci [ 1 ] ;
54296: LD_ADDR_VAR 0 7
54300: PUSH
54301: LD_VAR 0 9
54305: PUSH
54306: LD_INT 1
54308: ARRAY
54309: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54310: LD_VAR 0 7
54314: PPUSH
54315: LD_INT 124
54317: PPUSH
54318: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54322: LD_ADDR_VAR 0 3
54326: PUSH
54327: DOUBLE
54328: LD_EXP 136
54332: PUSH
54333: LD_VAR 0 2
54337: ARRAY
54338: INC
54339: ST_TO_ADDR
54340: LD_EXP 136
54344: PUSH
54345: LD_VAR 0 2
54349: ARRAY
54350: PUSH
54351: FOR_DOWNTO
54352: IFFALSE 54695
// begin if IsInUnit ( tmp ) then
54354: LD_VAR 0 7
54358: PPUSH
54359: CALL_OW 310
54363: IFFALSE 54374
// ComExitBuilding ( tmp ) ;
54365: LD_VAR 0 7
54369: PPUSH
54370: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54374: LD_INT 35
54376: PPUSH
54377: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54381: LD_VAR 0 7
54385: PPUSH
54386: CALL_OW 310
54390: NOT
54391: PUSH
54392: LD_VAR 0 7
54396: PPUSH
54397: CALL_OW 314
54401: NOT
54402: AND
54403: IFFALSE 54374
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54405: LD_ADDR_VAR 0 6
54409: PUSH
54410: LD_VAR 0 7
54414: PPUSH
54415: CALL_OW 250
54419: PUSH
54420: LD_VAR 0 7
54424: PPUSH
54425: CALL_OW 251
54429: PUSH
54430: EMPTY
54431: LIST
54432: LIST
54433: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54434: LD_INT 35
54436: PPUSH
54437: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54441: LD_ADDR_VAR 0 4
54445: PUSH
54446: LD_EXP 136
54450: PUSH
54451: LD_VAR 0 2
54455: ARRAY
54456: PUSH
54457: LD_VAR 0 3
54461: ARRAY
54462: PUSH
54463: LD_INT 1
54465: ARRAY
54466: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54467: LD_ADDR_VAR 0 5
54471: PUSH
54472: LD_EXP 136
54476: PUSH
54477: LD_VAR 0 2
54481: ARRAY
54482: PUSH
54483: LD_VAR 0 3
54487: ARRAY
54488: PUSH
54489: LD_INT 2
54491: ARRAY
54492: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54493: LD_VAR 0 7
54497: PPUSH
54498: LD_INT 10
54500: PPUSH
54501: CALL 74091 0 2
54505: PUSH
54506: LD_INT 4
54508: ARRAY
54509: IFFALSE 54547
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54511: LD_VAR 0 7
54515: PPUSH
54516: LD_VAR 0 6
54520: PUSH
54521: LD_INT 1
54523: ARRAY
54524: PPUSH
54525: LD_VAR 0 6
54529: PUSH
54530: LD_INT 2
54532: ARRAY
54533: PPUSH
54534: CALL_OW 111
// wait ( 0 0$10 ) ;
54538: LD_INT 350
54540: PPUSH
54541: CALL_OW 67
// end else
54545: GO 54573
// begin ComMoveXY ( tmp , x , y ) ;
54547: LD_VAR 0 7
54551: PPUSH
54552: LD_VAR 0 4
54556: PPUSH
54557: LD_VAR 0 5
54561: PPUSH
54562: CALL_OW 111
// wait ( 0 0$3 ) ;
54566: LD_INT 105
54568: PPUSH
54569: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54573: LD_VAR 0 7
54577: PPUSH
54578: LD_VAR 0 4
54582: PPUSH
54583: LD_VAR 0 5
54587: PPUSH
54588: CALL_OW 307
54592: IFFALSE 54434
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54594: LD_VAR 0 7
54598: PPUSH
54599: LD_VAR 0 4
54603: PPUSH
54604: LD_VAR 0 5
54608: PPUSH
54609: LD_VAR 0 8
54613: PUSH
54614: LD_VAR 0 3
54618: ARRAY
54619: PPUSH
54620: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54624: LD_INT 35
54626: PPUSH
54627: CALL_OW 67
// until not HasTask ( tmp ) ;
54631: LD_VAR 0 7
54635: PPUSH
54636: CALL_OW 314
54640: NOT
54641: IFFALSE 54624
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54643: LD_ADDR_EXP 137
54647: PUSH
54648: LD_EXP 137
54652: PPUSH
54653: LD_VAR 0 2
54657: PUSH
54658: LD_EXP 137
54662: PUSH
54663: LD_VAR 0 2
54667: ARRAY
54668: PUSH
54669: LD_INT 1
54671: PLUS
54672: PUSH
54673: EMPTY
54674: LIST
54675: LIST
54676: PPUSH
54677: LD_VAR 0 8
54681: PUSH
54682: LD_VAR 0 3
54686: ARRAY
54687: PPUSH
54688: CALL 71498 0 3
54692: ST_TO_ADDR
// end ;
54693: GO 54351
54695: POP
54696: POP
// MC_Reset ( i , 124 ) ;
54697: LD_VAR 0 2
54701: PPUSH
54702: LD_INT 124
54704: PPUSH
54705: CALL 38300 0 2
// end ; end ;
54709: GO 54106
54711: POP
54712: POP
// end ;
54713: LD_VAR 0 1
54717: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54718: LD_INT 0
54720: PPUSH
54721: PPUSH
54722: PPUSH
// if not mc_bases then
54723: LD_EXP 101
54727: NOT
54728: IFFALSE 54732
// exit ;
54730: GO 55338
// for i = 1 to mc_bases do
54732: LD_ADDR_VAR 0 2
54736: PUSH
54737: DOUBLE
54738: LD_INT 1
54740: DEC
54741: ST_TO_ADDR
54742: LD_EXP 101
54746: PUSH
54747: FOR_TO
54748: IFFALSE 55336
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54750: LD_ADDR_VAR 0 3
54754: PUSH
54755: LD_EXP 101
54759: PUSH
54760: LD_VAR 0 2
54764: ARRAY
54765: PPUSH
54766: LD_INT 25
54768: PUSH
54769: LD_INT 4
54771: PUSH
54772: EMPTY
54773: LIST
54774: LIST
54775: PPUSH
54776: CALL_OW 72
54780: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54781: LD_VAR 0 3
54785: NOT
54786: PUSH
54787: LD_EXP 138
54791: PUSH
54792: LD_VAR 0 2
54796: ARRAY
54797: NOT
54798: OR
54799: PUSH
54800: LD_EXP 101
54804: PUSH
54805: LD_VAR 0 2
54809: ARRAY
54810: PPUSH
54811: LD_INT 2
54813: PUSH
54814: LD_INT 30
54816: PUSH
54817: LD_INT 0
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: PUSH
54824: LD_INT 30
54826: PUSH
54827: LD_INT 1
54829: PUSH
54830: EMPTY
54831: LIST
54832: LIST
54833: PUSH
54834: EMPTY
54835: LIST
54836: LIST
54837: LIST
54838: PPUSH
54839: CALL_OW 72
54843: NOT
54844: OR
54845: IFFALSE 54895
// begin if mc_deposits_finder [ i ] then
54847: LD_EXP 139
54851: PUSH
54852: LD_VAR 0 2
54856: ARRAY
54857: IFFALSE 54893
// begin MC_Reset ( i , 125 ) ;
54859: LD_VAR 0 2
54863: PPUSH
54864: LD_INT 125
54866: PPUSH
54867: CALL 38300 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54871: LD_ADDR_EXP 139
54875: PUSH
54876: LD_EXP 139
54880: PPUSH
54881: LD_VAR 0 2
54885: PPUSH
54886: EMPTY
54887: PPUSH
54888: CALL_OW 1
54892: ST_TO_ADDR
// end ; continue ;
54893: GO 54747
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54895: LD_EXP 138
54899: PUSH
54900: LD_VAR 0 2
54904: ARRAY
54905: PUSH
54906: LD_INT 1
54908: ARRAY
54909: PUSH
54910: LD_INT 3
54912: ARRAY
54913: PUSH
54914: LD_INT 1
54916: EQUAL
54917: PUSH
54918: LD_INT 20
54920: PPUSH
54921: LD_EXP 127
54925: PUSH
54926: LD_VAR 0 2
54930: ARRAY
54931: PPUSH
54932: CALL_OW 321
54936: PUSH
54937: LD_INT 2
54939: NONEQUAL
54940: AND
54941: IFFALSE 54991
// begin if mc_deposits_finder [ i ] then
54943: LD_EXP 139
54947: PUSH
54948: LD_VAR 0 2
54952: ARRAY
54953: IFFALSE 54989
// begin MC_Reset ( i , 125 ) ;
54955: LD_VAR 0 2
54959: PPUSH
54960: LD_INT 125
54962: PPUSH
54963: CALL 38300 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54967: LD_ADDR_EXP 139
54971: PUSH
54972: LD_EXP 139
54976: PPUSH
54977: LD_VAR 0 2
54981: PPUSH
54982: EMPTY
54983: PPUSH
54984: CALL_OW 1
54988: ST_TO_ADDR
// end ; continue ;
54989: GO 54747
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54991: LD_EXP 138
54995: PUSH
54996: LD_VAR 0 2
55000: ARRAY
55001: PUSH
55002: LD_INT 1
55004: ARRAY
55005: PUSH
55006: LD_INT 1
55008: ARRAY
55009: PPUSH
55010: LD_EXP 138
55014: PUSH
55015: LD_VAR 0 2
55019: ARRAY
55020: PUSH
55021: LD_INT 1
55023: ARRAY
55024: PUSH
55025: LD_INT 2
55027: ARRAY
55028: PPUSH
55029: LD_EXP 127
55033: PUSH
55034: LD_VAR 0 2
55038: ARRAY
55039: PPUSH
55040: CALL_OW 440
55044: IFFALSE 55087
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55046: LD_ADDR_EXP 138
55050: PUSH
55051: LD_EXP 138
55055: PPUSH
55056: LD_VAR 0 2
55060: PPUSH
55061: LD_EXP 138
55065: PUSH
55066: LD_VAR 0 2
55070: ARRAY
55071: PPUSH
55072: LD_INT 1
55074: PPUSH
55075: CALL_OW 3
55079: PPUSH
55080: CALL_OW 1
55084: ST_TO_ADDR
55085: GO 55334
// begin if not mc_deposits_finder [ i ] then
55087: LD_EXP 139
55091: PUSH
55092: LD_VAR 0 2
55096: ARRAY
55097: NOT
55098: IFFALSE 55150
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55100: LD_ADDR_EXP 139
55104: PUSH
55105: LD_EXP 139
55109: PPUSH
55110: LD_VAR 0 2
55114: PPUSH
55115: LD_VAR 0 3
55119: PUSH
55120: LD_INT 1
55122: ARRAY
55123: PUSH
55124: EMPTY
55125: LIST
55126: PPUSH
55127: CALL_OW 1
55131: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55132: LD_VAR 0 3
55136: PUSH
55137: LD_INT 1
55139: ARRAY
55140: PPUSH
55141: LD_INT 125
55143: PPUSH
55144: CALL_OW 109
// end else
55148: GO 55334
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55150: LD_EXP 139
55154: PUSH
55155: LD_VAR 0 2
55159: ARRAY
55160: PUSH
55161: LD_INT 1
55163: ARRAY
55164: PPUSH
55165: CALL_OW 310
55169: IFFALSE 55192
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55171: LD_EXP 139
55175: PUSH
55176: LD_VAR 0 2
55180: ARRAY
55181: PUSH
55182: LD_INT 1
55184: ARRAY
55185: PPUSH
55186: CALL_OW 122
55190: GO 55334
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55192: LD_EXP 139
55196: PUSH
55197: LD_VAR 0 2
55201: ARRAY
55202: PUSH
55203: LD_INT 1
55205: ARRAY
55206: PPUSH
55207: CALL_OW 314
55211: NOT
55212: PUSH
55213: LD_EXP 139
55217: PUSH
55218: LD_VAR 0 2
55222: ARRAY
55223: PUSH
55224: LD_INT 1
55226: ARRAY
55227: PPUSH
55228: LD_EXP 138
55232: PUSH
55233: LD_VAR 0 2
55237: ARRAY
55238: PUSH
55239: LD_INT 1
55241: ARRAY
55242: PUSH
55243: LD_INT 1
55245: ARRAY
55246: PPUSH
55247: LD_EXP 138
55251: PUSH
55252: LD_VAR 0 2
55256: ARRAY
55257: PUSH
55258: LD_INT 1
55260: ARRAY
55261: PUSH
55262: LD_INT 2
55264: ARRAY
55265: PPUSH
55266: CALL_OW 297
55270: PUSH
55271: LD_INT 6
55273: GREATER
55274: AND
55275: IFFALSE 55334
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55277: LD_EXP 139
55281: PUSH
55282: LD_VAR 0 2
55286: ARRAY
55287: PUSH
55288: LD_INT 1
55290: ARRAY
55291: PPUSH
55292: LD_EXP 138
55296: PUSH
55297: LD_VAR 0 2
55301: ARRAY
55302: PUSH
55303: LD_INT 1
55305: ARRAY
55306: PUSH
55307: LD_INT 1
55309: ARRAY
55310: PPUSH
55311: LD_EXP 138
55315: PUSH
55316: LD_VAR 0 2
55320: ARRAY
55321: PUSH
55322: LD_INT 1
55324: ARRAY
55325: PUSH
55326: LD_INT 2
55328: ARRAY
55329: PPUSH
55330: CALL_OW 111
// end ; end ; end ;
55334: GO 54747
55336: POP
55337: POP
// end ;
55338: LD_VAR 0 1
55342: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55343: LD_INT 0
55345: PPUSH
55346: PPUSH
55347: PPUSH
55348: PPUSH
55349: PPUSH
55350: PPUSH
55351: PPUSH
55352: PPUSH
55353: PPUSH
55354: PPUSH
55355: PPUSH
// if not mc_bases then
55356: LD_EXP 101
55360: NOT
55361: IFFALSE 55365
// exit ;
55363: GO 56305
// for i = 1 to mc_bases do
55365: LD_ADDR_VAR 0 2
55369: PUSH
55370: DOUBLE
55371: LD_INT 1
55373: DEC
55374: ST_TO_ADDR
55375: LD_EXP 101
55379: PUSH
55380: FOR_TO
55381: IFFALSE 56303
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55383: LD_EXP 101
55387: PUSH
55388: LD_VAR 0 2
55392: ARRAY
55393: NOT
55394: PUSH
55395: LD_EXP 124
55399: PUSH
55400: LD_VAR 0 2
55404: ARRAY
55405: OR
55406: IFFALSE 55410
// continue ;
55408: GO 55380
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55410: LD_ADDR_VAR 0 7
55414: PUSH
55415: LD_EXP 101
55419: PUSH
55420: LD_VAR 0 2
55424: ARRAY
55425: PUSH
55426: LD_INT 1
55428: ARRAY
55429: PPUSH
55430: CALL_OW 248
55434: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55435: LD_VAR 0 7
55439: PUSH
55440: LD_INT 3
55442: EQUAL
55443: PUSH
55444: LD_EXP 120
55448: PUSH
55449: LD_VAR 0 2
55453: ARRAY
55454: PUSH
55455: LD_EXP 123
55459: PUSH
55460: LD_VAR 0 2
55464: ARRAY
55465: UNION
55466: PPUSH
55467: LD_INT 33
55469: PUSH
55470: LD_INT 2
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: PPUSH
55477: CALL_OW 72
55481: NOT
55482: OR
55483: IFFALSE 55487
// continue ;
55485: GO 55380
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55487: LD_ADDR_VAR 0 9
55491: PUSH
55492: LD_EXP 101
55496: PUSH
55497: LD_VAR 0 2
55501: ARRAY
55502: PPUSH
55503: LD_INT 30
55505: PUSH
55506: LD_INT 36
55508: PUSH
55509: EMPTY
55510: LIST
55511: LIST
55512: PPUSH
55513: CALL_OW 72
55517: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55518: LD_ADDR_VAR 0 10
55522: PUSH
55523: LD_EXP 120
55527: PUSH
55528: LD_VAR 0 2
55532: ARRAY
55533: PPUSH
55534: LD_INT 34
55536: PUSH
55537: LD_INT 31
55539: PUSH
55540: EMPTY
55541: LIST
55542: LIST
55543: PPUSH
55544: CALL_OW 72
55548: ST_TO_ADDR
// if not cts and not mcts then
55549: LD_VAR 0 9
55553: NOT
55554: PUSH
55555: LD_VAR 0 10
55559: NOT
55560: AND
55561: IFFALSE 55565
// continue ;
55563: GO 55380
// x := cts ;
55565: LD_ADDR_VAR 0 11
55569: PUSH
55570: LD_VAR 0 9
55574: ST_TO_ADDR
// if not x then
55575: LD_VAR 0 11
55579: NOT
55580: IFFALSE 55592
// x := mcts ;
55582: LD_ADDR_VAR 0 11
55586: PUSH
55587: LD_VAR 0 10
55591: ST_TO_ADDR
// if not x then
55592: LD_VAR 0 11
55596: NOT
55597: IFFALSE 55601
// continue ;
55599: GO 55380
// if mc_remote_driver [ i ] then
55601: LD_EXP 141
55605: PUSH
55606: LD_VAR 0 2
55610: ARRAY
55611: IFFALSE 55998
// for j in mc_remote_driver [ i ] do
55613: LD_ADDR_VAR 0 3
55617: PUSH
55618: LD_EXP 141
55622: PUSH
55623: LD_VAR 0 2
55627: ARRAY
55628: PUSH
55629: FOR_IN
55630: IFFALSE 55996
// begin if GetClass ( j ) <> 3 then
55632: LD_VAR 0 3
55636: PPUSH
55637: CALL_OW 257
55641: PUSH
55642: LD_INT 3
55644: NONEQUAL
55645: IFFALSE 55698
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55647: LD_ADDR_EXP 141
55651: PUSH
55652: LD_EXP 141
55656: PPUSH
55657: LD_VAR 0 2
55661: PPUSH
55662: LD_EXP 141
55666: PUSH
55667: LD_VAR 0 2
55671: ARRAY
55672: PUSH
55673: LD_VAR 0 3
55677: DIFF
55678: PPUSH
55679: CALL_OW 1
55683: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55684: LD_VAR 0 3
55688: PPUSH
55689: LD_INT 0
55691: PPUSH
55692: CALL_OW 109
// continue ;
55696: GO 55629
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55698: LD_EXP 120
55702: PUSH
55703: LD_VAR 0 2
55707: ARRAY
55708: PPUSH
55709: LD_INT 34
55711: PUSH
55712: LD_INT 31
55714: PUSH
55715: EMPTY
55716: LIST
55717: LIST
55718: PUSH
55719: LD_INT 58
55721: PUSH
55722: EMPTY
55723: LIST
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: PPUSH
55729: CALL_OW 72
55733: PUSH
55734: LD_VAR 0 3
55738: PPUSH
55739: CALL 104872 0 1
55743: NOT
55744: AND
55745: IFFALSE 55816
// begin if IsInUnit ( j ) then
55747: LD_VAR 0 3
55751: PPUSH
55752: CALL_OW 310
55756: IFFALSE 55767
// ComExitBuilding ( j ) ;
55758: LD_VAR 0 3
55762: PPUSH
55763: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55767: LD_VAR 0 3
55771: PPUSH
55772: LD_EXP 120
55776: PUSH
55777: LD_VAR 0 2
55781: ARRAY
55782: PPUSH
55783: LD_INT 34
55785: PUSH
55786: LD_INT 31
55788: PUSH
55789: EMPTY
55790: LIST
55791: LIST
55792: PUSH
55793: LD_INT 58
55795: PUSH
55796: EMPTY
55797: LIST
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: PPUSH
55803: CALL_OW 72
55807: PUSH
55808: LD_INT 1
55810: ARRAY
55811: PPUSH
55812: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55816: LD_VAR 0 3
55820: PPUSH
55821: CALL_OW 310
55825: NOT
55826: PUSH
55827: LD_VAR 0 3
55831: PPUSH
55832: CALL_OW 310
55836: PPUSH
55837: CALL_OW 266
55841: PUSH
55842: LD_INT 36
55844: NONEQUAL
55845: PUSH
55846: LD_VAR 0 3
55850: PPUSH
55851: CALL 104872 0 1
55855: NOT
55856: AND
55857: OR
55858: IFFALSE 55994
// begin if IsInUnit ( j ) then
55860: LD_VAR 0 3
55864: PPUSH
55865: CALL_OW 310
55869: IFFALSE 55880
// ComExitBuilding ( j ) ;
55871: LD_VAR 0 3
55875: PPUSH
55876: CALL_OW 122
// ct := 0 ;
55880: LD_ADDR_VAR 0 8
55884: PUSH
55885: LD_INT 0
55887: ST_TO_ADDR
// for k in x do
55888: LD_ADDR_VAR 0 4
55892: PUSH
55893: LD_VAR 0 11
55897: PUSH
55898: FOR_IN
55899: IFFALSE 55972
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55901: LD_VAR 0 4
55905: PPUSH
55906: CALL_OW 264
55910: PUSH
55911: LD_INT 31
55913: EQUAL
55914: PUSH
55915: LD_VAR 0 4
55919: PPUSH
55920: CALL_OW 311
55924: NOT
55925: AND
55926: PUSH
55927: LD_VAR 0 4
55931: PPUSH
55932: CALL_OW 266
55936: PUSH
55937: LD_INT 36
55939: EQUAL
55940: PUSH
55941: LD_VAR 0 4
55945: PPUSH
55946: CALL_OW 313
55950: PUSH
55951: LD_INT 3
55953: LESS
55954: AND
55955: OR
55956: IFFALSE 55970
// begin ct := k ;
55958: LD_ADDR_VAR 0 8
55962: PUSH
55963: LD_VAR 0 4
55967: ST_TO_ADDR
// break ;
55968: GO 55972
// end ;
55970: GO 55898
55972: POP
55973: POP
// if ct then
55974: LD_VAR 0 8
55978: IFFALSE 55994
// ComEnterUnit ( j , ct ) ;
55980: LD_VAR 0 3
55984: PPUSH
55985: LD_VAR 0 8
55989: PPUSH
55990: CALL_OW 120
// end ; end ;
55994: GO 55629
55996: POP
55997: POP
// places := 0 ;
55998: LD_ADDR_VAR 0 5
56002: PUSH
56003: LD_INT 0
56005: ST_TO_ADDR
// for j = 1 to x do
56006: LD_ADDR_VAR 0 3
56010: PUSH
56011: DOUBLE
56012: LD_INT 1
56014: DEC
56015: ST_TO_ADDR
56016: LD_VAR 0 11
56020: PUSH
56021: FOR_TO
56022: IFFALSE 56098
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56024: LD_VAR 0 11
56028: PUSH
56029: LD_VAR 0 3
56033: ARRAY
56034: PPUSH
56035: CALL_OW 264
56039: PUSH
56040: LD_INT 31
56042: EQUAL
56043: IFFALSE 56061
// places := places + 1 else
56045: LD_ADDR_VAR 0 5
56049: PUSH
56050: LD_VAR 0 5
56054: PUSH
56055: LD_INT 1
56057: PLUS
56058: ST_TO_ADDR
56059: GO 56096
// if GetBType ( x [ j ] ) = b_control_tower then
56061: LD_VAR 0 11
56065: PUSH
56066: LD_VAR 0 3
56070: ARRAY
56071: PPUSH
56072: CALL_OW 266
56076: PUSH
56077: LD_INT 36
56079: EQUAL
56080: IFFALSE 56096
// places := places + 3 ;
56082: LD_ADDR_VAR 0 5
56086: PUSH
56087: LD_VAR 0 5
56091: PUSH
56092: LD_INT 3
56094: PLUS
56095: ST_TO_ADDR
56096: GO 56021
56098: POP
56099: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56100: LD_VAR 0 5
56104: PUSH
56105: LD_INT 0
56107: EQUAL
56108: PUSH
56109: LD_VAR 0 5
56113: PUSH
56114: LD_EXP 141
56118: PUSH
56119: LD_VAR 0 2
56123: ARRAY
56124: LESSEQUAL
56125: OR
56126: IFFALSE 56130
// continue ;
56128: GO 55380
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56130: LD_ADDR_VAR 0 6
56134: PUSH
56135: LD_EXP 101
56139: PUSH
56140: LD_VAR 0 2
56144: ARRAY
56145: PPUSH
56146: LD_INT 25
56148: PUSH
56149: LD_INT 3
56151: PUSH
56152: EMPTY
56153: LIST
56154: LIST
56155: PPUSH
56156: CALL_OW 72
56160: PUSH
56161: LD_EXP 141
56165: PUSH
56166: LD_VAR 0 2
56170: ARRAY
56171: DIFF
56172: PPUSH
56173: LD_INT 3
56175: PPUSH
56176: CALL 105772 0 2
56180: ST_TO_ADDR
// for j in tmp do
56181: LD_ADDR_VAR 0 3
56185: PUSH
56186: LD_VAR 0 6
56190: PUSH
56191: FOR_IN
56192: IFFALSE 56227
// if GetTag ( j ) > 0 then
56194: LD_VAR 0 3
56198: PPUSH
56199: CALL_OW 110
56203: PUSH
56204: LD_INT 0
56206: GREATER
56207: IFFALSE 56225
// tmp := tmp diff j ;
56209: LD_ADDR_VAR 0 6
56213: PUSH
56214: LD_VAR 0 6
56218: PUSH
56219: LD_VAR 0 3
56223: DIFF
56224: ST_TO_ADDR
56225: GO 56191
56227: POP
56228: POP
// if not tmp then
56229: LD_VAR 0 6
56233: NOT
56234: IFFALSE 56238
// continue ;
56236: GO 55380
// if places then
56238: LD_VAR 0 5
56242: IFFALSE 56301
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56244: LD_ADDR_EXP 141
56248: PUSH
56249: LD_EXP 141
56253: PPUSH
56254: LD_VAR 0 2
56258: PPUSH
56259: LD_EXP 141
56263: PUSH
56264: LD_VAR 0 2
56268: ARRAY
56269: PUSH
56270: LD_VAR 0 6
56274: PUSH
56275: LD_INT 1
56277: ARRAY
56278: UNION
56279: PPUSH
56280: CALL_OW 1
56284: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56285: LD_VAR 0 6
56289: PUSH
56290: LD_INT 1
56292: ARRAY
56293: PPUSH
56294: LD_INT 126
56296: PPUSH
56297: CALL_OW 109
// end ; end ;
56301: GO 55380
56303: POP
56304: POP
// end ;
56305: LD_VAR 0 1
56309: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56310: LD_INT 0
56312: PPUSH
56313: PPUSH
56314: PPUSH
56315: PPUSH
56316: PPUSH
56317: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56318: LD_VAR 0 1
56322: NOT
56323: PUSH
56324: LD_VAR 0 2
56328: NOT
56329: OR
56330: PUSH
56331: LD_VAR 0 3
56335: NOT
56336: OR
56337: PUSH
56338: LD_VAR 0 4
56342: PUSH
56343: LD_INT 1
56345: PUSH
56346: LD_INT 2
56348: PUSH
56349: LD_INT 3
56351: PUSH
56352: LD_INT 4
56354: PUSH
56355: LD_INT 5
56357: PUSH
56358: LD_INT 8
56360: PUSH
56361: LD_INT 9
56363: PUSH
56364: LD_INT 15
56366: PUSH
56367: LD_INT 16
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: LIST
56374: LIST
56375: LIST
56376: LIST
56377: LIST
56378: LIST
56379: LIST
56380: IN
56381: NOT
56382: OR
56383: IFFALSE 56387
// exit ;
56385: GO 57287
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56387: LD_ADDR_VAR 0 2
56391: PUSH
56392: LD_VAR 0 2
56396: PPUSH
56397: LD_INT 21
56399: PUSH
56400: LD_INT 3
56402: PUSH
56403: EMPTY
56404: LIST
56405: LIST
56406: PUSH
56407: LD_INT 24
56409: PUSH
56410: LD_INT 250
56412: PUSH
56413: EMPTY
56414: LIST
56415: LIST
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: PPUSH
56421: CALL_OW 72
56425: ST_TO_ADDR
// case class of 1 , 15 :
56426: LD_VAR 0 4
56430: PUSH
56431: LD_INT 1
56433: DOUBLE
56434: EQUAL
56435: IFTRUE 56445
56437: LD_INT 15
56439: DOUBLE
56440: EQUAL
56441: IFTRUE 56445
56443: GO 56530
56445: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56446: LD_ADDR_VAR 0 8
56450: PUSH
56451: LD_VAR 0 2
56455: PPUSH
56456: LD_INT 2
56458: PUSH
56459: LD_INT 30
56461: PUSH
56462: LD_INT 32
56464: PUSH
56465: EMPTY
56466: LIST
56467: LIST
56468: PUSH
56469: LD_INT 30
56471: PUSH
56472: LD_INT 31
56474: PUSH
56475: EMPTY
56476: LIST
56477: LIST
56478: PUSH
56479: EMPTY
56480: LIST
56481: LIST
56482: LIST
56483: PPUSH
56484: CALL_OW 72
56488: PUSH
56489: LD_VAR 0 2
56493: PPUSH
56494: LD_INT 2
56496: PUSH
56497: LD_INT 30
56499: PUSH
56500: LD_INT 4
56502: PUSH
56503: EMPTY
56504: LIST
56505: LIST
56506: PUSH
56507: LD_INT 30
56509: PUSH
56510: LD_INT 5
56512: PUSH
56513: EMPTY
56514: LIST
56515: LIST
56516: PUSH
56517: EMPTY
56518: LIST
56519: LIST
56520: LIST
56521: PPUSH
56522: CALL_OW 72
56526: ADD
56527: ST_TO_ADDR
56528: GO 56776
56530: LD_INT 2
56532: DOUBLE
56533: EQUAL
56534: IFTRUE 56544
56536: LD_INT 16
56538: DOUBLE
56539: EQUAL
56540: IFTRUE 56544
56542: GO 56590
56544: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56545: LD_ADDR_VAR 0 8
56549: PUSH
56550: LD_VAR 0 2
56554: PPUSH
56555: LD_INT 2
56557: PUSH
56558: LD_INT 30
56560: PUSH
56561: LD_INT 0
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: PUSH
56568: LD_INT 30
56570: PUSH
56571: LD_INT 1
56573: PUSH
56574: EMPTY
56575: LIST
56576: LIST
56577: PUSH
56578: EMPTY
56579: LIST
56580: LIST
56581: LIST
56582: PPUSH
56583: CALL_OW 72
56587: ST_TO_ADDR
56588: GO 56776
56590: LD_INT 3
56592: DOUBLE
56593: EQUAL
56594: IFTRUE 56598
56596: GO 56644
56598: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56599: LD_ADDR_VAR 0 8
56603: PUSH
56604: LD_VAR 0 2
56608: PPUSH
56609: LD_INT 2
56611: PUSH
56612: LD_INT 30
56614: PUSH
56615: LD_INT 2
56617: PUSH
56618: EMPTY
56619: LIST
56620: LIST
56621: PUSH
56622: LD_INT 30
56624: PUSH
56625: LD_INT 3
56627: PUSH
56628: EMPTY
56629: LIST
56630: LIST
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: LIST
56636: PPUSH
56637: CALL_OW 72
56641: ST_TO_ADDR
56642: GO 56776
56644: LD_INT 4
56646: DOUBLE
56647: EQUAL
56648: IFTRUE 56652
56650: GO 56709
56652: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56653: LD_ADDR_VAR 0 8
56657: PUSH
56658: LD_VAR 0 2
56662: PPUSH
56663: LD_INT 2
56665: PUSH
56666: LD_INT 30
56668: PUSH
56669: LD_INT 6
56671: PUSH
56672: EMPTY
56673: LIST
56674: LIST
56675: PUSH
56676: LD_INT 30
56678: PUSH
56679: LD_INT 7
56681: PUSH
56682: EMPTY
56683: LIST
56684: LIST
56685: PUSH
56686: LD_INT 30
56688: PUSH
56689: LD_INT 8
56691: PUSH
56692: EMPTY
56693: LIST
56694: LIST
56695: PUSH
56696: EMPTY
56697: LIST
56698: LIST
56699: LIST
56700: LIST
56701: PPUSH
56702: CALL_OW 72
56706: ST_TO_ADDR
56707: GO 56776
56709: LD_INT 5
56711: DOUBLE
56712: EQUAL
56713: IFTRUE 56729
56715: LD_INT 8
56717: DOUBLE
56718: EQUAL
56719: IFTRUE 56729
56721: LD_INT 9
56723: DOUBLE
56724: EQUAL
56725: IFTRUE 56729
56727: GO 56775
56729: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56730: LD_ADDR_VAR 0 8
56734: PUSH
56735: LD_VAR 0 2
56739: PPUSH
56740: LD_INT 2
56742: PUSH
56743: LD_INT 30
56745: PUSH
56746: LD_INT 4
56748: PUSH
56749: EMPTY
56750: LIST
56751: LIST
56752: PUSH
56753: LD_INT 30
56755: PUSH
56756: LD_INT 5
56758: PUSH
56759: EMPTY
56760: LIST
56761: LIST
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: LIST
56767: PPUSH
56768: CALL_OW 72
56772: ST_TO_ADDR
56773: GO 56776
56775: POP
// if not tmp then
56776: LD_VAR 0 8
56780: NOT
56781: IFFALSE 56785
// exit ;
56783: GO 57287
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56785: LD_VAR 0 4
56789: PUSH
56790: LD_INT 1
56792: PUSH
56793: LD_INT 15
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: IN
56800: PUSH
56801: LD_EXP 110
56805: PUSH
56806: LD_VAR 0 1
56810: ARRAY
56811: AND
56812: IFFALSE 56968
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56814: LD_ADDR_VAR 0 9
56818: PUSH
56819: LD_EXP 110
56823: PUSH
56824: LD_VAR 0 1
56828: ARRAY
56829: PUSH
56830: LD_INT 1
56832: ARRAY
56833: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56834: LD_VAR 0 9
56838: PUSH
56839: LD_EXP 111
56843: PUSH
56844: LD_VAR 0 1
56848: ARRAY
56849: IN
56850: NOT
56851: IFFALSE 56966
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56853: LD_ADDR_EXP 111
56857: PUSH
56858: LD_EXP 111
56862: PPUSH
56863: LD_VAR 0 1
56867: PUSH
56868: LD_EXP 111
56872: PUSH
56873: LD_VAR 0 1
56877: ARRAY
56878: PUSH
56879: LD_INT 1
56881: PLUS
56882: PUSH
56883: EMPTY
56884: LIST
56885: LIST
56886: PPUSH
56887: LD_VAR 0 9
56891: PPUSH
56892: CALL 71498 0 3
56896: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56897: LD_ADDR_EXP 110
56901: PUSH
56902: LD_EXP 110
56906: PPUSH
56907: LD_VAR 0 1
56911: PPUSH
56912: LD_EXP 110
56916: PUSH
56917: LD_VAR 0 1
56921: ARRAY
56922: PUSH
56923: LD_VAR 0 9
56927: DIFF
56928: PPUSH
56929: CALL_OW 1
56933: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56934: LD_VAR 0 3
56938: PPUSH
56939: LD_EXP 111
56943: PUSH
56944: LD_VAR 0 1
56948: ARRAY
56949: PUSH
56950: LD_EXP 111
56954: PUSH
56955: LD_VAR 0 1
56959: ARRAY
56960: ARRAY
56961: PPUSH
56962: CALL_OW 120
// end ; exit ;
56966: GO 57287
// end ; if tmp > 1 then
56968: LD_VAR 0 8
56972: PUSH
56973: LD_INT 1
56975: GREATER
56976: IFFALSE 57080
// for i = 2 to tmp do
56978: LD_ADDR_VAR 0 6
56982: PUSH
56983: DOUBLE
56984: LD_INT 2
56986: DEC
56987: ST_TO_ADDR
56988: LD_VAR 0 8
56992: PUSH
56993: FOR_TO
56994: IFFALSE 57078
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56996: LD_VAR 0 8
57000: PUSH
57001: LD_VAR 0 6
57005: ARRAY
57006: PPUSH
57007: CALL_OW 461
57011: PUSH
57012: LD_INT 6
57014: EQUAL
57015: IFFALSE 57076
// begin x := tmp [ i ] ;
57017: LD_ADDR_VAR 0 9
57021: PUSH
57022: LD_VAR 0 8
57026: PUSH
57027: LD_VAR 0 6
57031: ARRAY
57032: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57033: LD_ADDR_VAR 0 8
57037: PUSH
57038: LD_VAR 0 8
57042: PPUSH
57043: LD_VAR 0 6
57047: PPUSH
57048: CALL_OW 3
57052: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57053: LD_ADDR_VAR 0 8
57057: PUSH
57058: LD_VAR 0 8
57062: PPUSH
57063: LD_INT 1
57065: PPUSH
57066: LD_VAR 0 9
57070: PPUSH
57071: CALL_OW 2
57075: ST_TO_ADDR
// end ;
57076: GO 56993
57078: POP
57079: POP
// for i in tmp do
57080: LD_ADDR_VAR 0 6
57084: PUSH
57085: LD_VAR 0 8
57089: PUSH
57090: FOR_IN
57091: IFFALSE 57160
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57093: LD_VAR 0 6
57097: PPUSH
57098: CALL_OW 313
57102: PUSH
57103: LD_INT 6
57105: LESS
57106: PUSH
57107: LD_VAR 0 6
57111: PPUSH
57112: CALL_OW 266
57116: PUSH
57117: LD_INT 31
57119: PUSH
57120: LD_INT 32
57122: PUSH
57123: EMPTY
57124: LIST
57125: LIST
57126: IN
57127: NOT
57128: AND
57129: PUSH
57130: LD_VAR 0 6
57134: PPUSH
57135: CALL_OW 313
57139: PUSH
57140: LD_INT 0
57142: EQUAL
57143: OR
57144: IFFALSE 57158
// begin j := i ;
57146: LD_ADDR_VAR 0 7
57150: PUSH
57151: LD_VAR 0 6
57155: ST_TO_ADDR
// break ;
57156: GO 57160
// end ; end ;
57158: GO 57090
57160: POP
57161: POP
// if j then
57162: LD_VAR 0 7
57166: IFFALSE 57184
// ComEnterUnit ( unit , j ) else
57168: LD_VAR 0 3
57172: PPUSH
57173: LD_VAR 0 7
57177: PPUSH
57178: CALL_OW 120
57182: GO 57287
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57184: LD_ADDR_VAR 0 10
57188: PUSH
57189: LD_VAR 0 2
57193: PPUSH
57194: LD_INT 2
57196: PUSH
57197: LD_INT 30
57199: PUSH
57200: LD_INT 0
57202: PUSH
57203: EMPTY
57204: LIST
57205: LIST
57206: PUSH
57207: LD_INT 30
57209: PUSH
57210: LD_INT 1
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: PUSH
57217: EMPTY
57218: LIST
57219: LIST
57220: LIST
57221: PPUSH
57222: CALL_OW 72
57226: ST_TO_ADDR
// if depot then
57227: LD_VAR 0 10
57231: IFFALSE 57287
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57233: LD_ADDR_VAR 0 10
57237: PUSH
57238: LD_VAR 0 10
57242: PPUSH
57243: LD_VAR 0 3
57247: PPUSH
57248: CALL_OW 74
57252: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57253: LD_VAR 0 3
57257: PPUSH
57258: LD_VAR 0 10
57262: PPUSH
57263: CALL_OW 296
57267: PUSH
57268: LD_INT 10
57270: GREATER
57271: IFFALSE 57287
// ComStandNearbyBuilding ( unit , depot ) ;
57273: LD_VAR 0 3
57277: PPUSH
57278: LD_VAR 0 10
57282: PPUSH
57283: CALL 65701 0 2
// end ; end ; end ;
57287: LD_VAR 0 5
57291: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57292: LD_INT 0
57294: PPUSH
57295: PPUSH
57296: PPUSH
57297: PPUSH
// if not mc_bases then
57298: LD_EXP 101
57302: NOT
57303: IFFALSE 57307
// exit ;
57305: GO 57546
// for i = 1 to mc_bases do
57307: LD_ADDR_VAR 0 2
57311: PUSH
57312: DOUBLE
57313: LD_INT 1
57315: DEC
57316: ST_TO_ADDR
57317: LD_EXP 101
57321: PUSH
57322: FOR_TO
57323: IFFALSE 57544
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57325: LD_ADDR_VAR 0 4
57329: PUSH
57330: LD_EXP 101
57334: PUSH
57335: LD_VAR 0 2
57339: ARRAY
57340: PPUSH
57341: LD_INT 21
57343: PUSH
57344: LD_INT 1
57346: PUSH
57347: EMPTY
57348: LIST
57349: LIST
57350: PPUSH
57351: CALL_OW 72
57355: PUSH
57356: LD_EXP 130
57360: PUSH
57361: LD_VAR 0 2
57365: ARRAY
57366: UNION
57367: ST_TO_ADDR
// if not tmp then
57368: LD_VAR 0 4
57372: NOT
57373: IFFALSE 57377
// continue ;
57375: GO 57322
// for j in tmp do
57377: LD_ADDR_VAR 0 3
57381: PUSH
57382: LD_VAR 0 4
57386: PUSH
57387: FOR_IN
57388: IFFALSE 57540
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57390: LD_VAR 0 3
57394: PPUSH
57395: CALL_OW 110
57399: NOT
57400: PUSH
57401: LD_VAR 0 3
57405: PPUSH
57406: CALL_OW 314
57410: NOT
57411: AND
57412: PUSH
57413: LD_VAR 0 3
57417: PPUSH
57418: CALL_OW 311
57422: NOT
57423: AND
57424: PUSH
57425: LD_VAR 0 3
57429: PPUSH
57430: CALL_OW 310
57434: NOT
57435: AND
57436: PUSH
57437: LD_VAR 0 3
57441: PUSH
57442: LD_EXP 104
57446: PUSH
57447: LD_VAR 0 2
57451: ARRAY
57452: PUSH
57453: LD_INT 1
57455: ARRAY
57456: IN
57457: NOT
57458: AND
57459: PUSH
57460: LD_VAR 0 3
57464: PUSH
57465: LD_EXP 104
57469: PUSH
57470: LD_VAR 0 2
57474: ARRAY
57475: PUSH
57476: LD_INT 2
57478: ARRAY
57479: IN
57480: NOT
57481: AND
57482: PUSH
57483: LD_VAR 0 3
57487: PUSH
57488: LD_EXP 113
57492: PUSH
57493: LD_VAR 0 2
57497: ARRAY
57498: IN
57499: NOT
57500: AND
57501: IFFALSE 57538
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57503: LD_VAR 0 2
57507: PPUSH
57508: LD_EXP 101
57512: PUSH
57513: LD_VAR 0 2
57517: ARRAY
57518: PPUSH
57519: LD_VAR 0 3
57523: PPUSH
57524: LD_VAR 0 3
57528: PPUSH
57529: CALL_OW 257
57533: PPUSH
57534: CALL 56310 0 4
// end ;
57538: GO 57387
57540: POP
57541: POP
// end ;
57542: GO 57322
57544: POP
57545: POP
// end ;
57546: LD_VAR 0 1
57550: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57551: LD_INT 0
57553: PPUSH
57554: PPUSH
57555: PPUSH
57556: PPUSH
57557: PPUSH
57558: PPUSH
// if not mc_bases [ base ] then
57559: LD_EXP 101
57563: PUSH
57564: LD_VAR 0 1
57568: ARRAY
57569: NOT
57570: IFFALSE 57574
// exit ;
57572: GO 57756
// tmp := [ ] ;
57574: LD_ADDR_VAR 0 6
57578: PUSH
57579: EMPTY
57580: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57581: LD_ADDR_VAR 0 7
57585: PUSH
57586: LD_VAR 0 3
57590: PPUSH
57591: LD_INT 0
57593: PPUSH
57594: CALL_OW 517
57598: ST_TO_ADDR
// if not list then
57599: LD_VAR 0 7
57603: NOT
57604: IFFALSE 57608
// exit ;
57606: GO 57756
// for i = 1 to amount do
57608: LD_ADDR_VAR 0 5
57612: PUSH
57613: DOUBLE
57614: LD_INT 1
57616: DEC
57617: ST_TO_ADDR
57618: LD_VAR 0 2
57622: PUSH
57623: FOR_TO
57624: IFFALSE 57704
// begin x := rand ( 1 , list [ 1 ] ) ;
57626: LD_ADDR_VAR 0 8
57630: PUSH
57631: LD_INT 1
57633: PPUSH
57634: LD_VAR 0 7
57638: PUSH
57639: LD_INT 1
57641: ARRAY
57642: PPUSH
57643: CALL_OW 12
57647: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57648: LD_ADDR_VAR 0 6
57652: PUSH
57653: LD_VAR 0 6
57657: PPUSH
57658: LD_VAR 0 5
57662: PPUSH
57663: LD_VAR 0 7
57667: PUSH
57668: LD_INT 1
57670: ARRAY
57671: PUSH
57672: LD_VAR 0 8
57676: ARRAY
57677: PUSH
57678: LD_VAR 0 7
57682: PUSH
57683: LD_INT 2
57685: ARRAY
57686: PUSH
57687: LD_VAR 0 8
57691: ARRAY
57692: PUSH
57693: EMPTY
57694: LIST
57695: LIST
57696: PPUSH
57697: CALL_OW 1
57701: ST_TO_ADDR
// end ;
57702: GO 57623
57704: POP
57705: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57706: LD_ADDR_EXP 114
57710: PUSH
57711: LD_EXP 114
57715: PPUSH
57716: LD_VAR 0 1
57720: PPUSH
57721: LD_VAR 0 6
57725: PPUSH
57726: CALL_OW 1
57730: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57731: LD_ADDR_EXP 116
57735: PUSH
57736: LD_EXP 116
57740: PPUSH
57741: LD_VAR 0 1
57745: PPUSH
57746: LD_VAR 0 3
57750: PPUSH
57751: CALL_OW 1
57755: ST_TO_ADDR
// end ;
57756: LD_VAR 0 4
57760: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57761: LD_INT 0
57763: PPUSH
// if not mc_bases [ base ] then
57764: LD_EXP 101
57768: PUSH
57769: LD_VAR 0 1
57773: ARRAY
57774: NOT
57775: IFFALSE 57779
// exit ;
57777: GO 57804
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57779: LD_ADDR_EXP 106
57783: PUSH
57784: LD_EXP 106
57788: PPUSH
57789: LD_VAR 0 1
57793: PPUSH
57794: LD_VAR 0 2
57798: PPUSH
57799: CALL_OW 1
57803: ST_TO_ADDR
// end ;
57804: LD_VAR 0 3
57808: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57809: LD_INT 0
57811: PPUSH
// if not mc_bases [ base ] then
57812: LD_EXP 101
57816: PUSH
57817: LD_VAR 0 1
57821: ARRAY
57822: NOT
57823: IFFALSE 57827
// exit ;
57825: GO 57864
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57827: LD_ADDR_EXP 106
57831: PUSH
57832: LD_EXP 106
57836: PPUSH
57837: LD_VAR 0 1
57841: PPUSH
57842: LD_EXP 106
57846: PUSH
57847: LD_VAR 0 1
57851: ARRAY
57852: PUSH
57853: LD_VAR 0 2
57857: UNION
57858: PPUSH
57859: CALL_OW 1
57863: ST_TO_ADDR
// end ;
57864: LD_VAR 0 3
57868: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57869: LD_INT 0
57871: PPUSH
// if not mc_bases [ base ] then
57872: LD_EXP 101
57876: PUSH
57877: LD_VAR 0 1
57881: ARRAY
57882: NOT
57883: IFFALSE 57887
// exit ;
57885: GO 57912
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57887: LD_ADDR_EXP 122
57891: PUSH
57892: LD_EXP 122
57896: PPUSH
57897: LD_VAR 0 1
57901: PPUSH
57902: LD_VAR 0 2
57906: PPUSH
57907: CALL_OW 1
57911: ST_TO_ADDR
// end ;
57912: LD_VAR 0 3
57916: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57917: LD_INT 0
57919: PPUSH
// if not mc_bases [ base ] then
57920: LD_EXP 101
57924: PUSH
57925: LD_VAR 0 1
57929: ARRAY
57930: NOT
57931: IFFALSE 57935
// exit ;
57933: GO 57972
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57935: LD_ADDR_EXP 122
57939: PUSH
57940: LD_EXP 122
57944: PPUSH
57945: LD_VAR 0 1
57949: PPUSH
57950: LD_EXP 122
57954: PUSH
57955: LD_VAR 0 1
57959: ARRAY
57960: PUSH
57961: LD_VAR 0 2
57965: ADD
57966: PPUSH
57967: CALL_OW 1
57971: ST_TO_ADDR
// end ;
57972: LD_VAR 0 3
57976: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57977: LD_INT 0
57979: PPUSH
// if not mc_bases [ base ] then
57980: LD_EXP 101
57984: PUSH
57985: LD_VAR 0 1
57989: ARRAY
57990: NOT
57991: IFFALSE 57995
// exit ;
57993: GO 58049
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57995: LD_ADDR_EXP 123
57999: PUSH
58000: LD_EXP 123
58004: PPUSH
58005: LD_VAR 0 1
58009: PPUSH
58010: LD_VAR 0 2
58014: PPUSH
58015: CALL_OW 1
58019: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58020: LD_ADDR_EXP 112
58024: PUSH
58025: LD_EXP 112
58029: PPUSH
58030: LD_VAR 0 1
58034: PPUSH
58035: LD_VAR 0 2
58039: PUSH
58040: LD_INT 0
58042: PLUS
58043: PPUSH
58044: CALL_OW 1
58048: ST_TO_ADDR
// end ;
58049: LD_VAR 0 3
58053: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58054: LD_INT 0
58056: PPUSH
// if not mc_bases [ base ] then
58057: LD_EXP 101
58061: PUSH
58062: LD_VAR 0 1
58066: ARRAY
58067: NOT
58068: IFFALSE 58072
// exit ;
58070: GO 58097
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58072: LD_ADDR_EXP 112
58076: PUSH
58077: LD_EXP 112
58081: PPUSH
58082: LD_VAR 0 1
58086: PPUSH
58087: LD_VAR 0 2
58091: PPUSH
58092: CALL_OW 1
58096: ST_TO_ADDR
// end ;
58097: LD_VAR 0 3
58101: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58102: LD_INT 0
58104: PPUSH
58105: PPUSH
58106: PPUSH
58107: PPUSH
// if not mc_bases [ base ] then
58108: LD_EXP 101
58112: PUSH
58113: LD_VAR 0 1
58117: ARRAY
58118: NOT
58119: IFFALSE 58123
// exit ;
58121: GO 58188
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58123: LD_ADDR_EXP 121
58127: PUSH
58128: LD_EXP 121
58132: PPUSH
58133: LD_VAR 0 1
58137: PUSH
58138: LD_EXP 121
58142: PUSH
58143: LD_VAR 0 1
58147: ARRAY
58148: PUSH
58149: LD_INT 1
58151: PLUS
58152: PUSH
58153: EMPTY
58154: LIST
58155: LIST
58156: PPUSH
58157: LD_VAR 0 1
58161: PUSH
58162: LD_VAR 0 2
58166: PUSH
58167: LD_VAR 0 3
58171: PUSH
58172: LD_VAR 0 4
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: LIST
58181: LIST
58182: PPUSH
58183: CALL 71498 0 3
58187: ST_TO_ADDR
// end ;
58188: LD_VAR 0 5
58192: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58193: LD_INT 0
58195: PPUSH
// if not mc_bases [ base ] then
58196: LD_EXP 101
58200: PUSH
58201: LD_VAR 0 1
58205: ARRAY
58206: NOT
58207: IFFALSE 58211
// exit ;
58209: GO 58236
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58211: LD_ADDR_EXP 138
58215: PUSH
58216: LD_EXP 138
58220: PPUSH
58221: LD_VAR 0 1
58225: PPUSH
58226: LD_VAR 0 2
58230: PPUSH
58231: CALL_OW 1
58235: ST_TO_ADDR
// end ;
58236: LD_VAR 0 3
58240: RET
// export function MC_GetMinesField ( base ) ; begin
58241: LD_INT 0
58243: PPUSH
// result := mc_mines [ base ] ;
58244: LD_ADDR_VAR 0 2
58248: PUSH
58249: LD_EXP 114
58253: PUSH
58254: LD_VAR 0 1
58258: ARRAY
58259: ST_TO_ADDR
// end ;
58260: LD_VAR 0 2
58264: RET
// export function MC_GetProduceList ( base ) ; begin
58265: LD_INT 0
58267: PPUSH
// result := mc_produce [ base ] ;
58268: LD_ADDR_VAR 0 2
58272: PUSH
58273: LD_EXP 122
58277: PUSH
58278: LD_VAR 0 1
58282: ARRAY
58283: ST_TO_ADDR
// end ;
58284: LD_VAR 0 2
58288: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58289: LD_INT 0
58291: PPUSH
58292: PPUSH
// if not mc_bases then
58293: LD_EXP 101
58297: NOT
58298: IFFALSE 58302
// exit ;
58300: GO 58367
// if mc_bases [ base ] then
58302: LD_EXP 101
58306: PUSH
58307: LD_VAR 0 1
58311: ARRAY
58312: IFFALSE 58367
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58314: LD_ADDR_VAR 0 3
58318: PUSH
58319: LD_EXP 101
58323: PUSH
58324: LD_VAR 0 1
58328: ARRAY
58329: PPUSH
58330: LD_INT 30
58332: PUSH
58333: LD_VAR 0 2
58337: PUSH
58338: EMPTY
58339: LIST
58340: LIST
58341: PPUSH
58342: CALL_OW 72
58346: ST_TO_ADDR
// if result then
58347: LD_VAR 0 3
58351: IFFALSE 58367
// result := result [ 1 ] ;
58353: LD_ADDR_VAR 0 3
58357: PUSH
58358: LD_VAR 0 3
58362: PUSH
58363: LD_INT 1
58365: ARRAY
58366: ST_TO_ADDR
// end ; end ;
58367: LD_VAR 0 3
58371: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58372: LD_INT 0
58374: PPUSH
58375: PPUSH
// if not mc_bases then
58376: LD_EXP 101
58380: NOT
58381: IFFALSE 58385
// exit ;
58383: GO 58430
// if mc_bases [ base ] then
58385: LD_EXP 101
58389: PUSH
58390: LD_VAR 0 1
58394: ARRAY
58395: IFFALSE 58430
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58397: LD_ADDR_VAR 0 3
58401: PUSH
58402: LD_EXP 101
58406: PUSH
58407: LD_VAR 0 1
58411: ARRAY
58412: PPUSH
58413: LD_INT 30
58415: PUSH
58416: LD_VAR 0 2
58420: PUSH
58421: EMPTY
58422: LIST
58423: LIST
58424: PPUSH
58425: CALL_OW 72
58429: ST_TO_ADDR
// end ;
58430: LD_VAR 0 3
58434: RET
// export function MC_SetTame ( base , area ) ; begin
58435: LD_INT 0
58437: PPUSH
// if not mc_bases or not base then
58438: LD_EXP 101
58442: NOT
58443: PUSH
58444: LD_VAR 0 1
58448: NOT
58449: OR
58450: IFFALSE 58454
// exit ;
58452: GO 58479
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58454: LD_ADDR_EXP 129
58458: PUSH
58459: LD_EXP 129
58463: PPUSH
58464: LD_VAR 0 1
58468: PPUSH
58469: LD_VAR 0 2
58473: PPUSH
58474: CALL_OW 1
58478: ST_TO_ADDR
// end ;
58479: LD_VAR 0 3
58483: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58484: LD_INT 0
58486: PPUSH
58487: PPUSH
// if not mc_bases or not base then
58488: LD_EXP 101
58492: NOT
58493: PUSH
58494: LD_VAR 0 1
58498: NOT
58499: OR
58500: IFFALSE 58504
// exit ;
58502: GO 58606
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58504: LD_ADDR_VAR 0 4
58508: PUSH
58509: LD_EXP 101
58513: PUSH
58514: LD_VAR 0 1
58518: ARRAY
58519: PPUSH
58520: LD_INT 30
58522: PUSH
58523: LD_VAR 0 2
58527: PUSH
58528: EMPTY
58529: LIST
58530: LIST
58531: PPUSH
58532: CALL_OW 72
58536: ST_TO_ADDR
// if not tmp then
58537: LD_VAR 0 4
58541: NOT
58542: IFFALSE 58546
// exit ;
58544: GO 58606
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58546: LD_ADDR_EXP 133
58550: PUSH
58551: LD_EXP 133
58555: PPUSH
58556: LD_VAR 0 1
58560: PPUSH
58561: LD_EXP 133
58565: PUSH
58566: LD_VAR 0 1
58570: ARRAY
58571: PPUSH
58572: LD_EXP 133
58576: PUSH
58577: LD_VAR 0 1
58581: ARRAY
58582: PUSH
58583: LD_INT 1
58585: PLUS
58586: PPUSH
58587: LD_VAR 0 4
58591: PUSH
58592: LD_INT 1
58594: ARRAY
58595: PPUSH
58596: CALL_OW 2
58600: PPUSH
58601: CALL_OW 1
58605: ST_TO_ADDR
// end ;
58606: LD_VAR 0 3
58610: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58611: LD_INT 0
58613: PPUSH
58614: PPUSH
// if not mc_bases or not base or not kinds then
58615: LD_EXP 101
58619: NOT
58620: PUSH
58621: LD_VAR 0 1
58625: NOT
58626: OR
58627: PUSH
58628: LD_VAR 0 2
58632: NOT
58633: OR
58634: IFFALSE 58638
// exit ;
58636: GO 58699
// for i in kinds do
58638: LD_ADDR_VAR 0 4
58642: PUSH
58643: LD_VAR 0 2
58647: PUSH
58648: FOR_IN
58649: IFFALSE 58697
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58651: LD_ADDR_EXP 135
58655: PUSH
58656: LD_EXP 135
58660: PPUSH
58661: LD_VAR 0 1
58665: PUSH
58666: LD_EXP 135
58670: PUSH
58671: LD_VAR 0 1
58675: ARRAY
58676: PUSH
58677: LD_INT 1
58679: PLUS
58680: PUSH
58681: EMPTY
58682: LIST
58683: LIST
58684: PPUSH
58685: LD_VAR 0 4
58689: PPUSH
58690: CALL 71498 0 3
58694: ST_TO_ADDR
58695: GO 58648
58697: POP
58698: POP
// end ;
58699: LD_VAR 0 3
58703: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58704: LD_INT 0
58706: PPUSH
// if not mc_bases or not base or not areas then
58707: LD_EXP 101
58711: NOT
58712: PUSH
58713: LD_VAR 0 1
58717: NOT
58718: OR
58719: PUSH
58720: LD_VAR 0 2
58724: NOT
58725: OR
58726: IFFALSE 58730
// exit ;
58728: GO 58755
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58730: LD_ADDR_EXP 119
58734: PUSH
58735: LD_EXP 119
58739: PPUSH
58740: LD_VAR 0 1
58744: PPUSH
58745: LD_VAR 0 2
58749: PPUSH
58750: CALL_OW 1
58754: ST_TO_ADDR
// end ;
58755: LD_VAR 0 3
58759: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58760: LD_INT 0
58762: PPUSH
// if not mc_bases or not base or not teleports_exit then
58763: LD_EXP 101
58767: NOT
58768: PUSH
58769: LD_VAR 0 1
58773: NOT
58774: OR
58775: PUSH
58776: LD_VAR 0 2
58780: NOT
58781: OR
58782: IFFALSE 58786
// exit ;
58784: GO 58811
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58786: LD_ADDR_EXP 136
58790: PUSH
58791: LD_EXP 136
58795: PPUSH
58796: LD_VAR 0 1
58800: PPUSH
58801: LD_VAR 0 2
58805: PPUSH
58806: CALL_OW 1
58810: ST_TO_ADDR
// end ;
58811: LD_VAR 0 3
58815: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58816: LD_INT 0
58818: PPUSH
58819: PPUSH
58820: PPUSH
// if not mc_bases or not base or not ext_list then
58821: LD_EXP 101
58825: NOT
58826: PUSH
58827: LD_VAR 0 1
58831: NOT
58832: OR
58833: PUSH
58834: LD_VAR 0 5
58838: NOT
58839: OR
58840: IFFALSE 58844
// exit ;
58842: GO 59017
// tmp := GetFacExtXYD ( x , y , d ) ;
58844: LD_ADDR_VAR 0 8
58848: PUSH
58849: LD_VAR 0 2
58853: PPUSH
58854: LD_VAR 0 3
58858: PPUSH
58859: LD_VAR 0 4
58863: PPUSH
58864: CALL 104902 0 3
58868: ST_TO_ADDR
// if not tmp then
58869: LD_VAR 0 8
58873: NOT
58874: IFFALSE 58878
// exit ;
58876: GO 59017
// for i in tmp do
58878: LD_ADDR_VAR 0 7
58882: PUSH
58883: LD_VAR 0 8
58887: PUSH
58888: FOR_IN
58889: IFFALSE 59015
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58891: LD_ADDR_EXP 106
58895: PUSH
58896: LD_EXP 106
58900: PPUSH
58901: LD_VAR 0 1
58905: PPUSH
58906: LD_EXP 106
58910: PUSH
58911: LD_VAR 0 1
58915: ARRAY
58916: PPUSH
58917: LD_EXP 106
58921: PUSH
58922: LD_VAR 0 1
58926: ARRAY
58927: PUSH
58928: LD_INT 1
58930: PLUS
58931: PPUSH
58932: LD_VAR 0 5
58936: PUSH
58937: LD_INT 1
58939: ARRAY
58940: PUSH
58941: LD_VAR 0 7
58945: PUSH
58946: LD_INT 1
58948: ARRAY
58949: PUSH
58950: LD_VAR 0 7
58954: PUSH
58955: LD_INT 2
58957: ARRAY
58958: PUSH
58959: LD_VAR 0 7
58963: PUSH
58964: LD_INT 3
58966: ARRAY
58967: PUSH
58968: EMPTY
58969: LIST
58970: LIST
58971: LIST
58972: LIST
58973: PPUSH
58974: CALL_OW 2
58978: PPUSH
58979: CALL_OW 1
58983: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58984: LD_ADDR_VAR 0 5
58988: PUSH
58989: LD_VAR 0 5
58993: PPUSH
58994: LD_INT 1
58996: PPUSH
58997: CALL_OW 3
59001: ST_TO_ADDR
// if not ext_list then
59002: LD_VAR 0 5
59006: NOT
59007: IFFALSE 59013
// exit ;
59009: POP
59010: POP
59011: GO 59017
// end ;
59013: GO 58888
59015: POP
59016: POP
// end ;
59017: LD_VAR 0 6
59021: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59022: LD_INT 0
59024: PPUSH
// if not mc_bases or not base or not weapon_list then
59025: LD_EXP 101
59029: NOT
59030: PUSH
59031: LD_VAR 0 1
59035: NOT
59036: OR
59037: PUSH
59038: LD_VAR 0 2
59042: NOT
59043: OR
59044: IFFALSE 59048
// exit ;
59046: GO 59073
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59048: LD_ADDR_EXP 140
59052: PUSH
59053: LD_EXP 140
59057: PPUSH
59058: LD_VAR 0 1
59062: PPUSH
59063: LD_VAR 0 2
59067: PPUSH
59068: CALL_OW 1
59072: ST_TO_ADDR
// end ;
59073: LD_VAR 0 3
59077: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59078: LD_INT 0
59080: PPUSH
// if not mc_bases or not base or not tech_list then
59081: LD_EXP 101
59085: NOT
59086: PUSH
59087: LD_VAR 0 1
59091: NOT
59092: OR
59093: PUSH
59094: LD_VAR 0 2
59098: NOT
59099: OR
59100: IFFALSE 59104
// exit ;
59102: GO 59129
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59104: LD_ADDR_EXP 128
59108: PUSH
59109: LD_EXP 128
59113: PPUSH
59114: LD_VAR 0 1
59118: PPUSH
59119: LD_VAR 0 2
59123: PPUSH
59124: CALL_OW 1
59128: ST_TO_ADDR
// end ;
59129: LD_VAR 0 3
59133: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59134: LD_INT 0
59136: PPUSH
// if not mc_bases or not parking_area or not base then
59137: LD_EXP 101
59141: NOT
59142: PUSH
59143: LD_VAR 0 2
59147: NOT
59148: OR
59149: PUSH
59150: LD_VAR 0 1
59154: NOT
59155: OR
59156: IFFALSE 59160
// exit ;
59158: GO 59185
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59160: LD_ADDR_EXP 125
59164: PUSH
59165: LD_EXP 125
59169: PPUSH
59170: LD_VAR 0 1
59174: PPUSH
59175: LD_VAR 0 2
59179: PPUSH
59180: CALL_OW 1
59184: ST_TO_ADDR
// end ;
59185: LD_VAR 0 3
59189: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59190: LD_INT 0
59192: PPUSH
// if not mc_bases or not base or not scan_area then
59193: LD_EXP 101
59197: NOT
59198: PUSH
59199: LD_VAR 0 1
59203: NOT
59204: OR
59205: PUSH
59206: LD_VAR 0 2
59210: NOT
59211: OR
59212: IFFALSE 59216
// exit ;
59214: GO 59241
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59216: LD_ADDR_EXP 126
59220: PUSH
59221: LD_EXP 126
59225: PPUSH
59226: LD_VAR 0 1
59230: PPUSH
59231: LD_VAR 0 2
59235: PPUSH
59236: CALL_OW 1
59240: ST_TO_ADDR
// end ;
59241: LD_VAR 0 3
59245: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59246: LD_INT 0
59248: PPUSH
59249: PPUSH
// if not mc_bases or not base then
59250: LD_EXP 101
59254: NOT
59255: PUSH
59256: LD_VAR 0 1
59260: NOT
59261: OR
59262: IFFALSE 59266
// exit ;
59264: GO 59330
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59266: LD_ADDR_VAR 0 3
59270: PUSH
59271: LD_INT 1
59273: PUSH
59274: LD_INT 2
59276: PUSH
59277: LD_INT 3
59279: PUSH
59280: LD_INT 4
59282: PUSH
59283: LD_INT 11
59285: PUSH
59286: EMPTY
59287: LIST
59288: LIST
59289: LIST
59290: LIST
59291: LIST
59292: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59293: LD_ADDR_EXP 128
59297: PUSH
59298: LD_EXP 128
59302: PPUSH
59303: LD_VAR 0 1
59307: PPUSH
59308: LD_EXP 128
59312: PUSH
59313: LD_VAR 0 1
59317: ARRAY
59318: PUSH
59319: LD_VAR 0 3
59323: DIFF
59324: PPUSH
59325: CALL_OW 1
59329: ST_TO_ADDR
// end ;
59330: LD_VAR 0 2
59334: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59335: LD_INT 0
59337: PPUSH
// result := mc_vehicles [ base ] ;
59338: LD_ADDR_VAR 0 3
59342: PUSH
59343: LD_EXP 120
59347: PUSH
59348: LD_VAR 0 1
59352: ARRAY
59353: ST_TO_ADDR
// if onlyCombat then
59354: LD_VAR 0 2
59358: IFFALSE 59523
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59360: LD_ADDR_VAR 0 3
59364: PUSH
59365: LD_VAR 0 3
59369: PUSH
59370: LD_VAR 0 3
59374: PPUSH
59375: LD_INT 2
59377: PUSH
59378: LD_INT 34
59380: PUSH
59381: LD_INT 12
59383: PUSH
59384: EMPTY
59385: LIST
59386: LIST
59387: PUSH
59388: LD_INT 34
59390: PUSH
59391: LD_INT 51
59393: PUSH
59394: EMPTY
59395: LIST
59396: LIST
59397: PUSH
59398: LD_INT 34
59400: PUSH
59401: LD_EXP 95
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: PUSH
59410: LD_INT 34
59412: PUSH
59413: LD_INT 32
59415: PUSH
59416: EMPTY
59417: LIST
59418: LIST
59419: PUSH
59420: LD_INT 34
59422: PUSH
59423: LD_INT 13
59425: PUSH
59426: EMPTY
59427: LIST
59428: LIST
59429: PUSH
59430: LD_INT 34
59432: PUSH
59433: LD_INT 52
59435: PUSH
59436: EMPTY
59437: LIST
59438: LIST
59439: PUSH
59440: LD_INT 34
59442: PUSH
59443: LD_INT 14
59445: PUSH
59446: EMPTY
59447: LIST
59448: LIST
59449: PUSH
59450: LD_INT 34
59452: PUSH
59453: LD_INT 53
59455: PUSH
59456: EMPTY
59457: LIST
59458: LIST
59459: PUSH
59460: LD_INT 34
59462: PUSH
59463: LD_EXP 94
59467: PUSH
59468: EMPTY
59469: LIST
59470: LIST
59471: PUSH
59472: LD_INT 34
59474: PUSH
59475: LD_INT 31
59477: PUSH
59478: EMPTY
59479: LIST
59480: LIST
59481: PUSH
59482: LD_INT 34
59484: PUSH
59485: LD_INT 48
59487: PUSH
59488: EMPTY
59489: LIST
59490: LIST
59491: PUSH
59492: LD_INT 34
59494: PUSH
59495: LD_INT 8
59497: PUSH
59498: EMPTY
59499: LIST
59500: LIST
59501: PUSH
59502: EMPTY
59503: LIST
59504: LIST
59505: LIST
59506: LIST
59507: LIST
59508: LIST
59509: LIST
59510: LIST
59511: LIST
59512: LIST
59513: LIST
59514: LIST
59515: LIST
59516: PPUSH
59517: CALL_OW 72
59521: DIFF
59522: ST_TO_ADDR
// end ; end_of_file
59523: LD_VAR 0 3
59527: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59528: LD_INT 0
59530: PPUSH
59531: PPUSH
59532: PPUSH
// if not mc_bases or not skirmish then
59533: LD_EXP 101
59537: NOT
59538: PUSH
59539: LD_EXP 99
59543: NOT
59544: OR
59545: IFFALSE 59549
// exit ;
59547: GO 59714
// for i = 1 to mc_bases do
59549: LD_ADDR_VAR 0 4
59553: PUSH
59554: DOUBLE
59555: LD_INT 1
59557: DEC
59558: ST_TO_ADDR
59559: LD_EXP 101
59563: PUSH
59564: FOR_TO
59565: IFFALSE 59712
// begin if sci in mc_bases [ i ] then
59567: LD_VAR 0 2
59571: PUSH
59572: LD_EXP 101
59576: PUSH
59577: LD_VAR 0 4
59581: ARRAY
59582: IN
59583: IFFALSE 59710
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59585: LD_ADDR_EXP 130
59589: PUSH
59590: LD_EXP 130
59594: PPUSH
59595: LD_VAR 0 4
59599: PUSH
59600: LD_EXP 130
59604: PUSH
59605: LD_VAR 0 4
59609: ARRAY
59610: PUSH
59611: LD_INT 1
59613: PLUS
59614: PUSH
59615: EMPTY
59616: LIST
59617: LIST
59618: PPUSH
59619: LD_VAR 0 1
59623: PPUSH
59624: CALL 71498 0 3
59628: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59629: LD_ADDR_VAR 0 5
59633: PUSH
59634: LD_EXP 101
59638: PUSH
59639: LD_VAR 0 4
59643: ARRAY
59644: PPUSH
59645: LD_INT 2
59647: PUSH
59648: LD_INT 30
59650: PUSH
59651: LD_INT 0
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: PUSH
59658: LD_INT 30
59660: PUSH
59661: LD_INT 1
59663: PUSH
59664: EMPTY
59665: LIST
59666: LIST
59667: PUSH
59668: EMPTY
59669: LIST
59670: LIST
59671: LIST
59672: PPUSH
59673: CALL_OW 72
59677: PPUSH
59678: LD_VAR 0 1
59682: PPUSH
59683: CALL_OW 74
59687: ST_TO_ADDR
// if tmp then
59688: LD_VAR 0 5
59692: IFFALSE 59708
// ComStandNearbyBuilding ( ape , tmp ) ;
59694: LD_VAR 0 1
59698: PPUSH
59699: LD_VAR 0 5
59703: PPUSH
59704: CALL 65701 0 2
// break ;
59708: GO 59712
// end ; end ;
59710: GO 59564
59712: POP
59713: POP
// end ;
59714: LD_VAR 0 3
59718: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59719: LD_INT 0
59721: PPUSH
59722: PPUSH
59723: PPUSH
// if not mc_bases or not skirmish then
59724: LD_EXP 101
59728: NOT
59729: PUSH
59730: LD_EXP 99
59734: NOT
59735: OR
59736: IFFALSE 59740
// exit ;
59738: GO 59829
// for i = 1 to mc_bases do
59740: LD_ADDR_VAR 0 4
59744: PUSH
59745: DOUBLE
59746: LD_INT 1
59748: DEC
59749: ST_TO_ADDR
59750: LD_EXP 101
59754: PUSH
59755: FOR_TO
59756: IFFALSE 59827
// begin if building in mc_busy_turret_list [ i ] then
59758: LD_VAR 0 1
59762: PUSH
59763: LD_EXP 111
59767: PUSH
59768: LD_VAR 0 4
59772: ARRAY
59773: IN
59774: IFFALSE 59825
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59776: LD_ADDR_VAR 0 5
59780: PUSH
59781: LD_EXP 111
59785: PUSH
59786: LD_VAR 0 4
59790: ARRAY
59791: PUSH
59792: LD_VAR 0 1
59796: DIFF
59797: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59798: LD_ADDR_EXP 111
59802: PUSH
59803: LD_EXP 111
59807: PPUSH
59808: LD_VAR 0 4
59812: PPUSH
59813: LD_VAR 0 5
59817: PPUSH
59818: CALL_OW 1
59822: ST_TO_ADDR
// break ;
59823: GO 59827
// end ; end ;
59825: GO 59755
59827: POP
59828: POP
// end ;
59829: LD_VAR 0 3
59833: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59834: LD_INT 0
59836: PPUSH
59837: PPUSH
59838: PPUSH
// if not mc_bases or not skirmish then
59839: LD_EXP 101
59843: NOT
59844: PUSH
59845: LD_EXP 99
59849: NOT
59850: OR
59851: IFFALSE 59855
// exit ;
59853: GO 60054
// for i = 1 to mc_bases do
59855: LD_ADDR_VAR 0 5
59859: PUSH
59860: DOUBLE
59861: LD_INT 1
59863: DEC
59864: ST_TO_ADDR
59865: LD_EXP 101
59869: PUSH
59870: FOR_TO
59871: IFFALSE 60052
// if building in mc_bases [ i ] then
59873: LD_VAR 0 1
59877: PUSH
59878: LD_EXP 101
59882: PUSH
59883: LD_VAR 0 5
59887: ARRAY
59888: IN
59889: IFFALSE 60050
// begin tmp := mc_bases [ i ] diff building ;
59891: LD_ADDR_VAR 0 6
59895: PUSH
59896: LD_EXP 101
59900: PUSH
59901: LD_VAR 0 5
59905: ARRAY
59906: PUSH
59907: LD_VAR 0 1
59911: DIFF
59912: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59913: LD_ADDR_EXP 101
59917: PUSH
59918: LD_EXP 101
59922: PPUSH
59923: LD_VAR 0 5
59927: PPUSH
59928: LD_VAR 0 6
59932: PPUSH
59933: CALL_OW 1
59937: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59938: LD_VAR 0 1
59942: PUSH
59943: LD_EXP 109
59947: PUSH
59948: LD_VAR 0 5
59952: ARRAY
59953: IN
59954: IFFALSE 59993
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59956: LD_ADDR_EXP 109
59960: PUSH
59961: LD_EXP 109
59965: PPUSH
59966: LD_VAR 0 5
59970: PPUSH
59971: LD_EXP 109
59975: PUSH
59976: LD_VAR 0 5
59980: ARRAY
59981: PUSH
59982: LD_VAR 0 1
59986: DIFF
59987: PPUSH
59988: CALL_OW 1
59992: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
59993: LD_VAR 0 1
59997: PUSH
59998: LD_EXP 110
60002: PUSH
60003: LD_VAR 0 5
60007: ARRAY
60008: IN
60009: IFFALSE 60048
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60011: LD_ADDR_EXP 110
60015: PUSH
60016: LD_EXP 110
60020: PPUSH
60021: LD_VAR 0 5
60025: PPUSH
60026: LD_EXP 110
60030: PUSH
60031: LD_VAR 0 5
60035: ARRAY
60036: PUSH
60037: LD_VAR 0 1
60041: DIFF
60042: PPUSH
60043: CALL_OW 1
60047: ST_TO_ADDR
// break ;
60048: GO 60052
// end ;
60050: GO 59870
60052: POP
60053: POP
// end ;
60054: LD_VAR 0 4
60058: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60059: LD_INT 0
60061: PPUSH
60062: PPUSH
60063: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60064: LD_EXP 101
60068: NOT
60069: PUSH
60070: LD_EXP 99
60074: NOT
60075: OR
60076: PUSH
60077: LD_VAR 0 3
60081: PUSH
60082: LD_EXP 127
60086: IN
60087: NOT
60088: OR
60089: IFFALSE 60093
// exit ;
60091: GO 60216
// for i = 1 to mc_vehicles do
60093: LD_ADDR_VAR 0 6
60097: PUSH
60098: DOUBLE
60099: LD_INT 1
60101: DEC
60102: ST_TO_ADDR
60103: LD_EXP 120
60107: PUSH
60108: FOR_TO
60109: IFFALSE 60214
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60111: LD_VAR 0 2
60115: PUSH
60116: LD_EXP 120
60120: PUSH
60121: LD_VAR 0 6
60125: ARRAY
60126: IN
60127: PUSH
60128: LD_VAR 0 1
60132: PUSH
60133: LD_EXP 120
60137: PUSH
60138: LD_VAR 0 6
60142: ARRAY
60143: IN
60144: OR
60145: IFFALSE 60212
// begin tmp := mc_vehicles [ i ] diff old ;
60147: LD_ADDR_VAR 0 7
60151: PUSH
60152: LD_EXP 120
60156: PUSH
60157: LD_VAR 0 6
60161: ARRAY
60162: PUSH
60163: LD_VAR 0 2
60167: DIFF
60168: ST_TO_ADDR
// tmp := tmp diff new ;
60169: LD_ADDR_VAR 0 7
60173: PUSH
60174: LD_VAR 0 7
60178: PUSH
60179: LD_VAR 0 1
60183: DIFF
60184: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60185: LD_ADDR_EXP 120
60189: PUSH
60190: LD_EXP 120
60194: PPUSH
60195: LD_VAR 0 6
60199: PPUSH
60200: LD_VAR 0 7
60204: PPUSH
60205: CALL_OW 1
60209: ST_TO_ADDR
// break ;
60210: GO 60214
// end ;
60212: GO 60108
60214: POP
60215: POP
// end ;
60216: LD_VAR 0 5
60220: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60221: LD_INT 0
60223: PPUSH
60224: PPUSH
60225: PPUSH
60226: PPUSH
// if not mc_bases or not skirmish then
60227: LD_EXP 101
60231: NOT
60232: PUSH
60233: LD_EXP 99
60237: NOT
60238: OR
60239: IFFALSE 60243
// exit ;
60241: GO 60620
// side := GetSide ( vehicle ) ;
60243: LD_ADDR_VAR 0 5
60247: PUSH
60248: LD_VAR 0 1
60252: PPUSH
60253: CALL_OW 255
60257: ST_TO_ADDR
// for i = 1 to mc_bases do
60258: LD_ADDR_VAR 0 4
60262: PUSH
60263: DOUBLE
60264: LD_INT 1
60266: DEC
60267: ST_TO_ADDR
60268: LD_EXP 101
60272: PUSH
60273: FOR_TO
60274: IFFALSE 60618
// begin if factory in mc_bases [ i ] then
60276: LD_VAR 0 2
60280: PUSH
60281: LD_EXP 101
60285: PUSH
60286: LD_VAR 0 4
60290: ARRAY
60291: IN
60292: IFFALSE 60616
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60294: LD_EXP 123
60298: PUSH
60299: LD_VAR 0 4
60303: ARRAY
60304: PUSH
60305: LD_EXP 112
60309: PUSH
60310: LD_VAR 0 4
60314: ARRAY
60315: LESS
60316: PUSH
60317: LD_VAR 0 1
60321: PPUSH
60322: CALL_OW 264
60326: PUSH
60327: LD_INT 31
60329: PUSH
60330: LD_INT 32
60332: PUSH
60333: LD_INT 51
60335: PUSH
60336: LD_EXP 95
60340: PUSH
60341: LD_INT 12
60343: PUSH
60344: LD_INT 30
60346: PUSH
60347: LD_EXP 94
60351: PUSH
60352: LD_INT 11
60354: PUSH
60355: LD_INT 53
60357: PUSH
60358: LD_INT 14
60360: PUSH
60361: LD_EXP 98
60365: PUSH
60366: LD_INT 29
60368: PUSH
60369: LD_EXP 96
60373: PUSH
60374: LD_INT 13
60376: PUSH
60377: LD_INT 52
60379: PUSH
60380: LD_INT 48
60382: PUSH
60383: LD_INT 8
60385: PUSH
60386: EMPTY
60387: LIST
60388: LIST
60389: LIST
60390: LIST
60391: LIST
60392: LIST
60393: LIST
60394: LIST
60395: LIST
60396: LIST
60397: LIST
60398: LIST
60399: LIST
60400: LIST
60401: LIST
60402: LIST
60403: LIST
60404: IN
60405: NOT
60406: AND
60407: IFFALSE 60455
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60409: LD_ADDR_EXP 123
60413: PUSH
60414: LD_EXP 123
60418: PPUSH
60419: LD_VAR 0 4
60423: PUSH
60424: LD_EXP 123
60428: PUSH
60429: LD_VAR 0 4
60433: ARRAY
60434: PUSH
60435: LD_INT 1
60437: PLUS
60438: PUSH
60439: EMPTY
60440: LIST
60441: LIST
60442: PPUSH
60443: LD_VAR 0 1
60447: PPUSH
60448: CALL 71498 0 3
60452: ST_TO_ADDR
60453: GO 60499
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60455: LD_ADDR_EXP 120
60459: PUSH
60460: LD_EXP 120
60464: PPUSH
60465: LD_VAR 0 4
60469: PUSH
60470: LD_EXP 120
60474: PUSH
60475: LD_VAR 0 4
60479: ARRAY
60480: PUSH
60481: LD_INT 1
60483: PLUS
60484: PUSH
60485: EMPTY
60486: LIST
60487: LIST
60488: PPUSH
60489: LD_VAR 0 1
60493: PPUSH
60494: CALL 71498 0 3
60498: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60499: LD_VAR 0 1
60503: PPUSH
60504: CALL_OW 263
60508: PUSH
60509: LD_INT 2
60511: EQUAL
60512: IFFALSE 60532
// begin repeat wait ( 0 0$1 ) ;
60514: LD_INT 35
60516: PPUSH
60517: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60521: LD_VAR 0 1
60525: PPUSH
60526: CALL_OW 312
60530: IFFALSE 60514
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60532: LD_VAR 0 1
60536: PPUSH
60537: LD_EXP 125
60541: PUSH
60542: LD_VAR 0 4
60546: ARRAY
60547: PPUSH
60548: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60552: LD_VAR 0 1
60556: PPUSH
60557: CALL_OW 263
60561: PUSH
60562: LD_INT 1
60564: NONEQUAL
60565: IFFALSE 60569
// break ;
60567: GO 60618
// repeat wait ( 0 0$1 ) ;
60569: LD_INT 35
60571: PPUSH
60572: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60576: LD_VAR 0 1
60580: PPUSH
60581: LD_EXP 125
60585: PUSH
60586: LD_VAR 0 4
60590: ARRAY
60591: PPUSH
60592: CALL_OW 308
60596: IFFALSE 60569
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60598: LD_VAR 0 1
60602: PPUSH
60603: CALL_OW 311
60607: PPUSH
60608: CALL_OW 121
// exit ;
60612: POP
60613: POP
60614: GO 60620
// end ; end ;
60616: GO 60273
60618: POP
60619: POP
// end ;
60620: LD_VAR 0 3
60624: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60625: LD_INT 0
60627: PPUSH
60628: PPUSH
60629: PPUSH
60630: PPUSH
// if not mc_bases or not skirmish then
60631: LD_EXP 101
60635: NOT
60636: PUSH
60637: LD_EXP 99
60641: NOT
60642: OR
60643: IFFALSE 60647
// exit ;
60645: GO 61000
// repeat wait ( 0 0$1 ) ;
60647: LD_INT 35
60649: PPUSH
60650: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60654: LD_VAR 0 2
60658: PPUSH
60659: LD_VAR 0 3
60663: PPUSH
60664: CALL_OW 284
60668: IFFALSE 60647
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60670: LD_VAR 0 2
60674: PPUSH
60675: LD_VAR 0 3
60679: PPUSH
60680: CALL_OW 283
60684: PUSH
60685: LD_INT 4
60687: EQUAL
60688: IFFALSE 60692
// exit ;
60690: GO 61000
// for i = 1 to mc_bases do
60692: LD_ADDR_VAR 0 7
60696: PUSH
60697: DOUBLE
60698: LD_INT 1
60700: DEC
60701: ST_TO_ADDR
60702: LD_EXP 101
60706: PUSH
60707: FOR_TO
60708: IFFALSE 60998
// begin if mc_crates_area [ i ] then
60710: LD_EXP 119
60714: PUSH
60715: LD_VAR 0 7
60719: ARRAY
60720: IFFALSE 60831
// for j in mc_crates_area [ i ] do
60722: LD_ADDR_VAR 0 8
60726: PUSH
60727: LD_EXP 119
60731: PUSH
60732: LD_VAR 0 7
60736: ARRAY
60737: PUSH
60738: FOR_IN
60739: IFFALSE 60829
// if InArea ( x , y , j ) then
60741: LD_VAR 0 2
60745: PPUSH
60746: LD_VAR 0 3
60750: PPUSH
60751: LD_VAR 0 8
60755: PPUSH
60756: CALL_OW 309
60760: IFFALSE 60827
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60762: LD_ADDR_EXP 117
60766: PUSH
60767: LD_EXP 117
60771: PPUSH
60772: LD_VAR 0 7
60776: PUSH
60777: LD_EXP 117
60781: PUSH
60782: LD_VAR 0 7
60786: ARRAY
60787: PUSH
60788: LD_INT 1
60790: PLUS
60791: PUSH
60792: EMPTY
60793: LIST
60794: LIST
60795: PPUSH
60796: LD_VAR 0 4
60800: PUSH
60801: LD_VAR 0 2
60805: PUSH
60806: LD_VAR 0 3
60810: PUSH
60811: EMPTY
60812: LIST
60813: LIST
60814: LIST
60815: PPUSH
60816: CALL 71498 0 3
60820: ST_TO_ADDR
// exit ;
60821: POP
60822: POP
60823: POP
60824: POP
60825: GO 61000
// end ;
60827: GO 60738
60829: POP
60830: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60831: LD_ADDR_VAR 0 9
60835: PUSH
60836: LD_EXP 101
60840: PUSH
60841: LD_VAR 0 7
60845: ARRAY
60846: PPUSH
60847: LD_INT 2
60849: PUSH
60850: LD_INT 30
60852: PUSH
60853: LD_INT 0
60855: PUSH
60856: EMPTY
60857: LIST
60858: LIST
60859: PUSH
60860: LD_INT 30
60862: PUSH
60863: LD_INT 1
60865: PUSH
60866: EMPTY
60867: LIST
60868: LIST
60869: PUSH
60870: EMPTY
60871: LIST
60872: LIST
60873: LIST
60874: PPUSH
60875: CALL_OW 72
60879: ST_TO_ADDR
// if not depot then
60880: LD_VAR 0 9
60884: NOT
60885: IFFALSE 60889
// continue ;
60887: GO 60707
// for j in depot do
60889: LD_ADDR_VAR 0 8
60893: PUSH
60894: LD_VAR 0 9
60898: PUSH
60899: FOR_IN
60900: IFFALSE 60994
// if GetDistUnitXY ( j , x , y ) < 30 then
60902: LD_VAR 0 8
60906: PPUSH
60907: LD_VAR 0 2
60911: PPUSH
60912: LD_VAR 0 3
60916: PPUSH
60917: CALL_OW 297
60921: PUSH
60922: LD_INT 30
60924: LESS
60925: IFFALSE 60992
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60927: LD_ADDR_EXP 117
60931: PUSH
60932: LD_EXP 117
60936: PPUSH
60937: LD_VAR 0 7
60941: PUSH
60942: LD_EXP 117
60946: PUSH
60947: LD_VAR 0 7
60951: ARRAY
60952: PUSH
60953: LD_INT 1
60955: PLUS
60956: PUSH
60957: EMPTY
60958: LIST
60959: LIST
60960: PPUSH
60961: LD_VAR 0 4
60965: PUSH
60966: LD_VAR 0 2
60970: PUSH
60971: LD_VAR 0 3
60975: PUSH
60976: EMPTY
60977: LIST
60978: LIST
60979: LIST
60980: PPUSH
60981: CALL 71498 0 3
60985: ST_TO_ADDR
// exit ;
60986: POP
60987: POP
60988: POP
60989: POP
60990: GO 61000
// end ;
60992: GO 60899
60994: POP
60995: POP
// end ;
60996: GO 60707
60998: POP
60999: POP
// end ;
61000: LD_VAR 0 6
61004: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61005: LD_INT 0
61007: PPUSH
61008: PPUSH
61009: PPUSH
61010: PPUSH
// if not mc_bases or not skirmish then
61011: LD_EXP 101
61015: NOT
61016: PUSH
61017: LD_EXP 99
61021: NOT
61022: OR
61023: IFFALSE 61027
// exit ;
61025: GO 61304
// side := GetSide ( lab ) ;
61027: LD_ADDR_VAR 0 4
61031: PUSH
61032: LD_VAR 0 2
61036: PPUSH
61037: CALL_OW 255
61041: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61042: LD_VAR 0 4
61046: PUSH
61047: LD_EXP 127
61051: IN
61052: NOT
61053: PUSH
61054: LD_EXP 128
61058: NOT
61059: OR
61060: PUSH
61061: LD_EXP 101
61065: NOT
61066: OR
61067: IFFALSE 61071
// exit ;
61069: GO 61304
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61071: LD_ADDR_EXP 128
61075: PUSH
61076: LD_EXP 128
61080: PPUSH
61081: LD_VAR 0 4
61085: PPUSH
61086: LD_EXP 128
61090: PUSH
61091: LD_VAR 0 4
61095: ARRAY
61096: PUSH
61097: LD_VAR 0 1
61101: DIFF
61102: PPUSH
61103: CALL_OW 1
61107: ST_TO_ADDR
// for i = 1 to mc_bases do
61108: LD_ADDR_VAR 0 5
61112: PUSH
61113: DOUBLE
61114: LD_INT 1
61116: DEC
61117: ST_TO_ADDR
61118: LD_EXP 101
61122: PUSH
61123: FOR_TO
61124: IFFALSE 61302
// begin if lab in mc_bases [ i ] then
61126: LD_VAR 0 2
61130: PUSH
61131: LD_EXP 101
61135: PUSH
61136: LD_VAR 0 5
61140: ARRAY
61141: IN
61142: IFFALSE 61300
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61144: LD_VAR 0 1
61148: PUSH
61149: LD_INT 11
61151: PUSH
61152: LD_INT 4
61154: PUSH
61155: LD_INT 3
61157: PUSH
61158: LD_INT 2
61160: PUSH
61161: EMPTY
61162: LIST
61163: LIST
61164: LIST
61165: LIST
61166: IN
61167: PUSH
61168: LD_EXP 131
61172: PUSH
61173: LD_VAR 0 5
61177: ARRAY
61178: AND
61179: IFFALSE 61300
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61181: LD_ADDR_VAR 0 6
61185: PUSH
61186: LD_EXP 131
61190: PUSH
61191: LD_VAR 0 5
61195: ARRAY
61196: PUSH
61197: LD_INT 1
61199: ARRAY
61200: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61201: LD_ADDR_EXP 131
61205: PUSH
61206: LD_EXP 131
61210: PPUSH
61211: LD_VAR 0 5
61215: PPUSH
61216: EMPTY
61217: PPUSH
61218: CALL_OW 1
61222: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61223: LD_VAR 0 6
61227: PPUSH
61228: LD_INT 0
61230: PPUSH
61231: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61235: LD_VAR 0 6
61239: PPUSH
61240: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61244: LD_ADDR_EXP 130
61248: PUSH
61249: LD_EXP 130
61253: PPUSH
61254: LD_VAR 0 5
61258: PPUSH
61259: LD_EXP 130
61263: PUSH
61264: LD_VAR 0 5
61268: ARRAY
61269: PPUSH
61270: LD_INT 1
61272: PPUSH
61273: LD_VAR 0 6
61277: PPUSH
61278: CALL_OW 2
61282: PPUSH
61283: CALL_OW 1
61287: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61288: LD_VAR 0 5
61292: PPUSH
61293: LD_INT 112
61295: PPUSH
61296: CALL 38300 0 2
// end ; end ; end ;
61300: GO 61123
61302: POP
61303: POP
// end ;
61304: LD_VAR 0 3
61308: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61309: LD_INT 0
61311: PPUSH
61312: PPUSH
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
61317: PPUSH
61318: PPUSH
// if not mc_bases or not skirmish then
61319: LD_EXP 101
61323: NOT
61324: PUSH
61325: LD_EXP 99
61329: NOT
61330: OR
61331: IFFALSE 61335
// exit ;
61333: GO 62706
// for i = 1 to mc_bases do
61335: LD_ADDR_VAR 0 3
61339: PUSH
61340: DOUBLE
61341: LD_INT 1
61343: DEC
61344: ST_TO_ADDR
61345: LD_EXP 101
61349: PUSH
61350: FOR_TO
61351: IFFALSE 62704
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61353: LD_VAR 0 1
61357: PUSH
61358: LD_EXP 101
61362: PUSH
61363: LD_VAR 0 3
61367: ARRAY
61368: IN
61369: PUSH
61370: LD_VAR 0 1
61374: PUSH
61375: LD_EXP 108
61379: PUSH
61380: LD_VAR 0 3
61384: ARRAY
61385: IN
61386: OR
61387: PUSH
61388: LD_VAR 0 1
61392: PUSH
61393: LD_EXP 123
61397: PUSH
61398: LD_VAR 0 3
61402: ARRAY
61403: IN
61404: OR
61405: PUSH
61406: LD_VAR 0 1
61410: PUSH
61411: LD_EXP 120
61415: PUSH
61416: LD_VAR 0 3
61420: ARRAY
61421: IN
61422: OR
61423: PUSH
61424: LD_VAR 0 1
61428: PUSH
61429: LD_EXP 130
61433: PUSH
61434: LD_VAR 0 3
61438: ARRAY
61439: IN
61440: OR
61441: PUSH
61442: LD_VAR 0 1
61446: PUSH
61447: LD_EXP 131
61451: PUSH
61452: LD_VAR 0 3
61456: ARRAY
61457: IN
61458: OR
61459: IFFALSE 62702
// begin if un in mc_ape [ i ] then
61461: LD_VAR 0 1
61465: PUSH
61466: LD_EXP 130
61470: PUSH
61471: LD_VAR 0 3
61475: ARRAY
61476: IN
61477: IFFALSE 61516
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61479: LD_ADDR_EXP 130
61483: PUSH
61484: LD_EXP 130
61488: PPUSH
61489: LD_VAR 0 3
61493: PPUSH
61494: LD_EXP 130
61498: PUSH
61499: LD_VAR 0 3
61503: ARRAY
61504: PUSH
61505: LD_VAR 0 1
61509: DIFF
61510: PPUSH
61511: CALL_OW 1
61515: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61516: LD_VAR 0 1
61520: PUSH
61521: LD_EXP 131
61525: PUSH
61526: LD_VAR 0 3
61530: ARRAY
61531: IN
61532: IFFALSE 61556
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61534: LD_ADDR_EXP 131
61538: PUSH
61539: LD_EXP 131
61543: PPUSH
61544: LD_VAR 0 3
61548: PPUSH
61549: EMPTY
61550: PPUSH
61551: CALL_OW 1
61555: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61556: LD_VAR 0 1
61560: PPUSH
61561: CALL_OW 247
61565: PUSH
61566: LD_INT 2
61568: EQUAL
61569: PUSH
61570: LD_VAR 0 1
61574: PPUSH
61575: CALL_OW 110
61579: PUSH
61580: LD_INT 20
61582: EQUAL
61583: PUSH
61584: LD_VAR 0 1
61588: PUSH
61589: LD_EXP 123
61593: PUSH
61594: LD_VAR 0 3
61598: ARRAY
61599: IN
61600: OR
61601: PUSH
61602: LD_VAR 0 1
61606: PPUSH
61607: CALL_OW 264
61611: PUSH
61612: LD_INT 12
61614: PUSH
61615: LD_INT 51
61617: PUSH
61618: LD_EXP 95
61622: PUSH
61623: LD_INT 32
61625: PUSH
61626: LD_INT 13
61628: PUSH
61629: LD_INT 52
61631: PUSH
61632: LD_INT 31
61634: PUSH
61635: EMPTY
61636: LIST
61637: LIST
61638: LIST
61639: LIST
61640: LIST
61641: LIST
61642: LIST
61643: IN
61644: OR
61645: AND
61646: IFFALSE 61954
// begin if un in mc_defender [ i ] then
61648: LD_VAR 0 1
61652: PUSH
61653: LD_EXP 123
61657: PUSH
61658: LD_VAR 0 3
61662: ARRAY
61663: IN
61664: IFFALSE 61703
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61666: LD_ADDR_EXP 123
61670: PUSH
61671: LD_EXP 123
61675: PPUSH
61676: LD_VAR 0 3
61680: PPUSH
61681: LD_EXP 123
61685: PUSH
61686: LD_VAR 0 3
61690: ARRAY
61691: PUSH
61692: LD_VAR 0 1
61696: DIFF
61697: PPUSH
61698: CALL_OW 1
61702: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61703: LD_ADDR_VAR 0 8
61707: PUSH
61708: LD_VAR 0 3
61712: PPUSH
61713: LD_INT 3
61715: PPUSH
61716: CALL 58372 0 2
61720: ST_TO_ADDR
// if fac then
61721: LD_VAR 0 8
61725: IFFALSE 61954
// begin for j in fac do
61727: LD_ADDR_VAR 0 4
61731: PUSH
61732: LD_VAR 0 8
61736: PUSH
61737: FOR_IN
61738: IFFALSE 61952
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61740: LD_ADDR_VAR 0 9
61744: PUSH
61745: LD_VAR 0 8
61749: PPUSH
61750: LD_VAR 0 1
61754: PPUSH
61755: CALL_OW 265
61759: PPUSH
61760: LD_VAR 0 1
61764: PPUSH
61765: CALL_OW 262
61769: PPUSH
61770: LD_VAR 0 1
61774: PPUSH
61775: CALL_OW 263
61779: PPUSH
61780: LD_VAR 0 1
61784: PPUSH
61785: CALL_OW 264
61789: PPUSH
61790: CALL 69030 0 5
61794: ST_TO_ADDR
// if components then
61795: LD_VAR 0 9
61799: IFFALSE 61950
// begin if GetWeapon ( un ) = ar_control_tower then
61801: LD_VAR 0 1
61805: PPUSH
61806: CALL_OW 264
61810: PUSH
61811: LD_INT 31
61813: EQUAL
61814: IFFALSE 61931
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61816: LD_VAR 0 1
61820: PPUSH
61821: CALL_OW 311
61825: PPUSH
61826: LD_INT 0
61828: PPUSH
61829: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61833: LD_ADDR_EXP 141
61837: PUSH
61838: LD_EXP 141
61842: PPUSH
61843: LD_VAR 0 3
61847: PPUSH
61848: LD_EXP 141
61852: PUSH
61853: LD_VAR 0 3
61857: ARRAY
61858: PUSH
61859: LD_VAR 0 1
61863: PPUSH
61864: CALL_OW 311
61868: DIFF
61869: PPUSH
61870: CALL_OW 1
61874: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61875: LD_ADDR_VAR 0 7
61879: PUSH
61880: LD_EXP 122
61884: PUSH
61885: LD_VAR 0 3
61889: ARRAY
61890: PPUSH
61891: LD_INT 1
61893: PPUSH
61894: LD_VAR 0 9
61898: PPUSH
61899: CALL_OW 2
61903: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
61904: LD_ADDR_EXP 122
61908: PUSH
61909: LD_EXP 122
61913: PPUSH
61914: LD_VAR 0 3
61918: PPUSH
61919: LD_VAR 0 7
61923: PPUSH
61924: CALL_OW 1
61928: ST_TO_ADDR
// end else
61929: GO 61948
// MC_InsertProduceList ( i , [ components ] ) ;
61931: LD_VAR 0 3
61935: PPUSH
61936: LD_VAR 0 9
61940: PUSH
61941: EMPTY
61942: LIST
61943: PPUSH
61944: CALL 57917 0 2
// break ;
61948: GO 61952
// end ; end ;
61950: GO 61737
61952: POP
61953: POP
// end ; end ; if GetType ( un ) = unit_building then
61954: LD_VAR 0 1
61958: PPUSH
61959: CALL_OW 247
61963: PUSH
61964: LD_INT 3
61966: EQUAL
61967: IFFALSE 62370
// begin btype := GetBType ( un ) ;
61969: LD_ADDR_VAR 0 5
61973: PUSH
61974: LD_VAR 0 1
61978: PPUSH
61979: CALL_OW 266
61983: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
61984: LD_VAR 0 5
61988: PUSH
61989: LD_INT 29
61991: PUSH
61992: LD_INT 30
61994: PUSH
61995: EMPTY
61996: LIST
61997: LIST
61998: IN
61999: IFFALSE 62072
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62001: LD_VAR 0 1
62005: PPUSH
62006: CALL_OW 250
62010: PPUSH
62011: LD_VAR 0 1
62015: PPUSH
62016: CALL_OW 251
62020: PPUSH
62021: LD_VAR 0 1
62025: PPUSH
62026: CALL_OW 255
62030: PPUSH
62031: CALL_OW 440
62035: NOT
62036: IFFALSE 62072
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62038: LD_VAR 0 1
62042: PPUSH
62043: CALL_OW 250
62047: PPUSH
62048: LD_VAR 0 1
62052: PPUSH
62053: CALL_OW 251
62057: PPUSH
62058: LD_VAR 0 1
62062: PPUSH
62063: CALL_OW 255
62067: PPUSH
62068: CALL_OW 441
// end ; if btype = b_warehouse then
62072: LD_VAR 0 5
62076: PUSH
62077: LD_INT 1
62079: EQUAL
62080: IFFALSE 62098
// begin btype := b_depot ;
62082: LD_ADDR_VAR 0 5
62086: PUSH
62087: LD_INT 0
62089: ST_TO_ADDR
// pos := 1 ;
62090: LD_ADDR_VAR 0 6
62094: PUSH
62095: LD_INT 1
62097: ST_TO_ADDR
// end ; if btype = b_factory then
62098: LD_VAR 0 5
62102: PUSH
62103: LD_INT 3
62105: EQUAL
62106: IFFALSE 62124
// begin btype := b_workshop ;
62108: LD_ADDR_VAR 0 5
62112: PUSH
62113: LD_INT 2
62115: ST_TO_ADDR
// pos := 1 ;
62116: LD_ADDR_VAR 0 6
62120: PUSH
62121: LD_INT 1
62123: ST_TO_ADDR
// end ; if btype = b_barracks then
62124: LD_VAR 0 5
62128: PUSH
62129: LD_INT 5
62131: EQUAL
62132: IFFALSE 62142
// btype := b_armoury ;
62134: LD_ADDR_VAR 0 5
62138: PUSH
62139: LD_INT 4
62141: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62142: LD_VAR 0 5
62146: PUSH
62147: LD_INT 7
62149: PUSH
62150: LD_INT 8
62152: PUSH
62153: EMPTY
62154: LIST
62155: LIST
62156: IN
62157: IFFALSE 62167
// btype := b_lab ;
62159: LD_ADDR_VAR 0 5
62163: PUSH
62164: LD_INT 6
62166: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62167: LD_ADDR_EXP 106
62171: PUSH
62172: LD_EXP 106
62176: PPUSH
62177: LD_VAR 0 3
62181: PUSH
62182: LD_EXP 106
62186: PUSH
62187: LD_VAR 0 3
62191: ARRAY
62192: PUSH
62193: LD_INT 1
62195: PLUS
62196: PUSH
62197: EMPTY
62198: LIST
62199: LIST
62200: PPUSH
62201: LD_VAR 0 5
62205: PUSH
62206: LD_VAR 0 1
62210: PPUSH
62211: CALL_OW 250
62215: PUSH
62216: LD_VAR 0 1
62220: PPUSH
62221: CALL_OW 251
62225: PUSH
62226: LD_VAR 0 1
62230: PPUSH
62231: CALL_OW 254
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: LIST
62240: LIST
62241: PPUSH
62242: CALL 71498 0 3
62246: ST_TO_ADDR
// if pos = 1 then
62247: LD_VAR 0 6
62251: PUSH
62252: LD_INT 1
62254: EQUAL
62255: IFFALSE 62370
// begin tmp := mc_build_list [ i ] ;
62257: LD_ADDR_VAR 0 7
62261: PUSH
62262: LD_EXP 106
62266: PUSH
62267: LD_VAR 0 3
62271: ARRAY
62272: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62273: LD_VAR 0 7
62277: PPUSH
62278: LD_INT 2
62280: PUSH
62281: LD_INT 30
62283: PUSH
62284: LD_INT 0
62286: PUSH
62287: EMPTY
62288: LIST
62289: LIST
62290: PUSH
62291: LD_INT 30
62293: PUSH
62294: LD_INT 1
62296: PUSH
62297: EMPTY
62298: LIST
62299: LIST
62300: PUSH
62301: EMPTY
62302: LIST
62303: LIST
62304: LIST
62305: PPUSH
62306: CALL_OW 72
62310: IFFALSE 62320
// pos := 2 ;
62312: LD_ADDR_VAR 0 6
62316: PUSH
62317: LD_INT 2
62319: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62320: LD_ADDR_VAR 0 7
62324: PUSH
62325: LD_VAR 0 7
62329: PPUSH
62330: LD_VAR 0 6
62334: PPUSH
62335: LD_VAR 0 7
62339: PPUSH
62340: CALL 71824 0 3
62344: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62345: LD_ADDR_EXP 106
62349: PUSH
62350: LD_EXP 106
62354: PPUSH
62355: LD_VAR 0 3
62359: PPUSH
62360: LD_VAR 0 7
62364: PPUSH
62365: CALL_OW 1
62369: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62370: LD_VAR 0 1
62374: PUSH
62375: LD_EXP 101
62379: PUSH
62380: LD_VAR 0 3
62384: ARRAY
62385: IN
62386: IFFALSE 62425
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62388: LD_ADDR_EXP 101
62392: PUSH
62393: LD_EXP 101
62397: PPUSH
62398: LD_VAR 0 3
62402: PPUSH
62403: LD_EXP 101
62407: PUSH
62408: LD_VAR 0 3
62412: ARRAY
62413: PUSH
62414: LD_VAR 0 1
62418: DIFF
62419: PPUSH
62420: CALL_OW 1
62424: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62425: LD_VAR 0 1
62429: PUSH
62430: LD_EXP 108
62434: PUSH
62435: LD_VAR 0 3
62439: ARRAY
62440: IN
62441: IFFALSE 62480
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62443: LD_ADDR_EXP 108
62447: PUSH
62448: LD_EXP 108
62452: PPUSH
62453: LD_VAR 0 3
62457: PPUSH
62458: LD_EXP 108
62462: PUSH
62463: LD_VAR 0 3
62467: ARRAY
62468: PUSH
62469: LD_VAR 0 1
62473: DIFF
62474: PPUSH
62475: CALL_OW 1
62479: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62480: LD_VAR 0 1
62484: PUSH
62485: LD_EXP 120
62489: PUSH
62490: LD_VAR 0 3
62494: ARRAY
62495: IN
62496: IFFALSE 62535
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62498: LD_ADDR_EXP 120
62502: PUSH
62503: LD_EXP 120
62507: PPUSH
62508: LD_VAR 0 3
62512: PPUSH
62513: LD_EXP 120
62517: PUSH
62518: LD_VAR 0 3
62522: ARRAY
62523: PUSH
62524: LD_VAR 0 1
62528: DIFF
62529: PPUSH
62530: CALL_OW 1
62534: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62535: LD_VAR 0 1
62539: PUSH
62540: LD_EXP 123
62544: PUSH
62545: LD_VAR 0 3
62549: ARRAY
62550: IN
62551: IFFALSE 62590
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62553: LD_ADDR_EXP 123
62557: PUSH
62558: LD_EXP 123
62562: PPUSH
62563: LD_VAR 0 3
62567: PPUSH
62568: LD_EXP 123
62572: PUSH
62573: LD_VAR 0 3
62577: ARRAY
62578: PUSH
62579: LD_VAR 0 1
62583: DIFF
62584: PPUSH
62585: CALL_OW 1
62589: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62590: LD_VAR 0 1
62594: PUSH
62595: LD_EXP 110
62599: PUSH
62600: LD_VAR 0 3
62604: ARRAY
62605: IN
62606: IFFALSE 62645
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62608: LD_ADDR_EXP 110
62612: PUSH
62613: LD_EXP 110
62617: PPUSH
62618: LD_VAR 0 3
62622: PPUSH
62623: LD_EXP 110
62627: PUSH
62628: LD_VAR 0 3
62632: ARRAY
62633: PUSH
62634: LD_VAR 0 1
62638: DIFF
62639: PPUSH
62640: CALL_OW 1
62644: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62645: LD_VAR 0 1
62649: PUSH
62650: LD_EXP 109
62654: PUSH
62655: LD_VAR 0 3
62659: ARRAY
62660: IN
62661: IFFALSE 62700
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62663: LD_ADDR_EXP 109
62667: PUSH
62668: LD_EXP 109
62672: PPUSH
62673: LD_VAR 0 3
62677: PPUSH
62678: LD_EXP 109
62682: PUSH
62683: LD_VAR 0 3
62687: ARRAY
62688: PUSH
62689: LD_VAR 0 1
62693: DIFF
62694: PPUSH
62695: CALL_OW 1
62699: ST_TO_ADDR
// end ; break ;
62700: GO 62704
// end ;
62702: GO 61350
62704: POP
62705: POP
// end ;
62706: LD_VAR 0 2
62710: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62711: LD_INT 0
62713: PPUSH
62714: PPUSH
62715: PPUSH
// if not mc_bases or not skirmish then
62716: LD_EXP 101
62720: NOT
62721: PUSH
62722: LD_EXP 99
62726: NOT
62727: OR
62728: IFFALSE 62732
// exit ;
62730: GO 62947
// for i = 1 to mc_bases do
62732: LD_ADDR_VAR 0 3
62736: PUSH
62737: DOUBLE
62738: LD_INT 1
62740: DEC
62741: ST_TO_ADDR
62742: LD_EXP 101
62746: PUSH
62747: FOR_TO
62748: IFFALSE 62945
// begin if building in mc_construct_list [ i ] then
62750: LD_VAR 0 1
62754: PUSH
62755: LD_EXP 108
62759: PUSH
62760: LD_VAR 0 3
62764: ARRAY
62765: IN
62766: IFFALSE 62943
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62768: LD_ADDR_EXP 108
62772: PUSH
62773: LD_EXP 108
62777: PPUSH
62778: LD_VAR 0 3
62782: PPUSH
62783: LD_EXP 108
62787: PUSH
62788: LD_VAR 0 3
62792: ARRAY
62793: PUSH
62794: LD_VAR 0 1
62798: DIFF
62799: PPUSH
62800: CALL_OW 1
62804: ST_TO_ADDR
// if building in mc_lab [ i ] then
62805: LD_VAR 0 1
62809: PUSH
62810: LD_EXP 134
62814: PUSH
62815: LD_VAR 0 3
62819: ARRAY
62820: IN
62821: IFFALSE 62876
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62823: LD_ADDR_EXP 135
62827: PUSH
62828: LD_EXP 135
62832: PPUSH
62833: LD_VAR 0 3
62837: PPUSH
62838: LD_EXP 135
62842: PUSH
62843: LD_VAR 0 3
62847: ARRAY
62848: PPUSH
62849: LD_INT 1
62851: PPUSH
62852: LD_EXP 135
62856: PUSH
62857: LD_VAR 0 3
62861: ARRAY
62862: PPUSH
62863: LD_INT 0
62865: PPUSH
62866: CALL 70916 0 4
62870: PPUSH
62871: CALL_OW 1
62875: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62876: LD_VAR 0 1
62880: PUSH
62881: LD_EXP 101
62885: PUSH
62886: LD_VAR 0 3
62890: ARRAY
62891: IN
62892: NOT
62893: IFFALSE 62939
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62895: LD_ADDR_EXP 101
62899: PUSH
62900: LD_EXP 101
62904: PPUSH
62905: LD_VAR 0 3
62909: PUSH
62910: LD_EXP 101
62914: PUSH
62915: LD_VAR 0 3
62919: ARRAY
62920: PUSH
62921: LD_INT 1
62923: PLUS
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: PPUSH
62929: LD_VAR 0 1
62933: PPUSH
62934: CALL 71498 0 3
62938: ST_TO_ADDR
// exit ;
62939: POP
62940: POP
62941: GO 62947
// end ; end ;
62943: GO 62747
62945: POP
62946: POP
// end ;
62947: LD_VAR 0 2
62951: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62952: LD_INT 0
62954: PPUSH
62955: PPUSH
62956: PPUSH
62957: PPUSH
62958: PPUSH
62959: PPUSH
62960: PPUSH
// if not mc_bases or not skirmish then
62961: LD_EXP 101
62965: NOT
62966: PUSH
62967: LD_EXP 99
62971: NOT
62972: OR
62973: IFFALSE 62977
// exit ;
62975: GO 63638
// for i = 1 to mc_bases do
62977: LD_ADDR_VAR 0 3
62981: PUSH
62982: DOUBLE
62983: LD_INT 1
62985: DEC
62986: ST_TO_ADDR
62987: LD_EXP 101
62991: PUSH
62992: FOR_TO
62993: IFFALSE 63636
// begin if building in mc_construct_list [ i ] then
62995: LD_VAR 0 1
62999: PUSH
63000: LD_EXP 108
63004: PUSH
63005: LD_VAR 0 3
63009: ARRAY
63010: IN
63011: IFFALSE 63634
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63013: LD_ADDR_EXP 108
63017: PUSH
63018: LD_EXP 108
63022: PPUSH
63023: LD_VAR 0 3
63027: PPUSH
63028: LD_EXP 108
63032: PUSH
63033: LD_VAR 0 3
63037: ARRAY
63038: PUSH
63039: LD_VAR 0 1
63043: DIFF
63044: PPUSH
63045: CALL_OW 1
63049: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63050: LD_ADDR_EXP 101
63054: PUSH
63055: LD_EXP 101
63059: PPUSH
63060: LD_VAR 0 3
63064: PUSH
63065: LD_EXP 101
63069: PUSH
63070: LD_VAR 0 3
63074: ARRAY
63075: PUSH
63076: LD_INT 1
63078: PLUS
63079: PUSH
63080: EMPTY
63081: LIST
63082: LIST
63083: PPUSH
63084: LD_VAR 0 1
63088: PPUSH
63089: CALL 71498 0 3
63093: ST_TO_ADDR
// btype := GetBType ( building ) ;
63094: LD_ADDR_VAR 0 5
63098: PUSH
63099: LD_VAR 0 1
63103: PPUSH
63104: CALL_OW 266
63108: ST_TO_ADDR
// side := GetSide ( building ) ;
63109: LD_ADDR_VAR 0 8
63113: PUSH
63114: LD_VAR 0 1
63118: PPUSH
63119: CALL_OW 255
63123: ST_TO_ADDR
// if btype = b_lab then
63124: LD_VAR 0 5
63128: PUSH
63129: LD_INT 6
63131: EQUAL
63132: IFFALSE 63182
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63134: LD_ADDR_EXP 134
63138: PUSH
63139: LD_EXP 134
63143: PPUSH
63144: LD_VAR 0 3
63148: PUSH
63149: LD_EXP 134
63153: PUSH
63154: LD_VAR 0 3
63158: ARRAY
63159: PUSH
63160: LD_INT 1
63162: PLUS
63163: PUSH
63164: EMPTY
63165: LIST
63166: LIST
63167: PPUSH
63168: LD_VAR 0 1
63172: PPUSH
63173: CALL 71498 0 3
63177: ST_TO_ADDR
// exit ;
63178: POP
63179: POP
63180: GO 63638
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63182: LD_VAR 0 5
63186: PUSH
63187: LD_INT 0
63189: PUSH
63190: LD_INT 2
63192: PUSH
63193: LD_INT 4
63195: PUSH
63196: EMPTY
63197: LIST
63198: LIST
63199: LIST
63200: IN
63201: IFFALSE 63325
// begin if btype = b_armoury then
63203: LD_VAR 0 5
63207: PUSH
63208: LD_INT 4
63210: EQUAL
63211: IFFALSE 63221
// btype := b_barracks ;
63213: LD_ADDR_VAR 0 5
63217: PUSH
63218: LD_INT 5
63220: ST_TO_ADDR
// if btype = b_depot then
63221: LD_VAR 0 5
63225: PUSH
63226: LD_INT 0
63228: EQUAL
63229: IFFALSE 63239
// btype := b_warehouse ;
63231: LD_ADDR_VAR 0 5
63235: PUSH
63236: LD_INT 1
63238: ST_TO_ADDR
// if btype = b_workshop then
63239: LD_VAR 0 5
63243: PUSH
63244: LD_INT 2
63246: EQUAL
63247: IFFALSE 63257
// btype := b_factory ;
63249: LD_ADDR_VAR 0 5
63253: PUSH
63254: LD_INT 3
63256: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63257: LD_VAR 0 5
63261: PPUSH
63262: LD_VAR 0 8
63266: PPUSH
63267: CALL_OW 323
63271: PUSH
63272: LD_INT 1
63274: EQUAL
63275: IFFALSE 63321
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63277: LD_ADDR_EXP 133
63281: PUSH
63282: LD_EXP 133
63286: PPUSH
63287: LD_VAR 0 3
63291: PUSH
63292: LD_EXP 133
63296: PUSH
63297: LD_VAR 0 3
63301: ARRAY
63302: PUSH
63303: LD_INT 1
63305: PLUS
63306: PUSH
63307: EMPTY
63308: LIST
63309: LIST
63310: PPUSH
63311: LD_VAR 0 1
63315: PPUSH
63316: CALL 71498 0 3
63320: ST_TO_ADDR
// exit ;
63321: POP
63322: POP
63323: GO 63638
// end ; if btype in [ b_bunker , b_turret ] then
63325: LD_VAR 0 5
63329: PUSH
63330: LD_INT 32
63332: PUSH
63333: LD_INT 33
63335: PUSH
63336: EMPTY
63337: LIST
63338: LIST
63339: IN
63340: IFFALSE 63630
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63342: LD_ADDR_EXP 109
63346: PUSH
63347: LD_EXP 109
63351: PPUSH
63352: LD_VAR 0 3
63356: PUSH
63357: LD_EXP 109
63361: PUSH
63362: LD_VAR 0 3
63366: ARRAY
63367: PUSH
63368: LD_INT 1
63370: PLUS
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: PPUSH
63376: LD_VAR 0 1
63380: PPUSH
63381: CALL 71498 0 3
63385: ST_TO_ADDR
// if btype = b_bunker then
63386: LD_VAR 0 5
63390: PUSH
63391: LD_INT 32
63393: EQUAL
63394: IFFALSE 63630
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63396: LD_ADDR_EXP 110
63400: PUSH
63401: LD_EXP 110
63405: PPUSH
63406: LD_VAR 0 3
63410: PUSH
63411: LD_EXP 110
63415: PUSH
63416: LD_VAR 0 3
63420: ARRAY
63421: PUSH
63422: LD_INT 1
63424: PLUS
63425: PUSH
63426: EMPTY
63427: LIST
63428: LIST
63429: PPUSH
63430: LD_VAR 0 1
63434: PPUSH
63435: CALL 71498 0 3
63439: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63440: LD_ADDR_VAR 0 6
63444: PUSH
63445: LD_EXP 101
63449: PUSH
63450: LD_VAR 0 3
63454: ARRAY
63455: PPUSH
63456: LD_INT 25
63458: PUSH
63459: LD_INT 1
63461: PUSH
63462: EMPTY
63463: LIST
63464: LIST
63465: PUSH
63466: LD_INT 3
63468: PUSH
63469: LD_INT 54
63471: PUSH
63472: EMPTY
63473: LIST
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PUSH
63479: EMPTY
63480: LIST
63481: LIST
63482: PPUSH
63483: CALL_OW 72
63487: ST_TO_ADDR
// if tmp then
63488: LD_VAR 0 6
63492: IFFALSE 63498
// exit ;
63494: POP
63495: POP
63496: GO 63638
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63498: LD_ADDR_VAR 0 6
63502: PUSH
63503: LD_EXP 101
63507: PUSH
63508: LD_VAR 0 3
63512: ARRAY
63513: PPUSH
63514: LD_INT 2
63516: PUSH
63517: LD_INT 30
63519: PUSH
63520: LD_INT 4
63522: PUSH
63523: EMPTY
63524: LIST
63525: LIST
63526: PUSH
63527: LD_INT 30
63529: PUSH
63530: LD_INT 5
63532: PUSH
63533: EMPTY
63534: LIST
63535: LIST
63536: PUSH
63537: EMPTY
63538: LIST
63539: LIST
63540: LIST
63541: PPUSH
63542: CALL_OW 72
63546: ST_TO_ADDR
// if not tmp then
63547: LD_VAR 0 6
63551: NOT
63552: IFFALSE 63558
// exit ;
63554: POP
63555: POP
63556: GO 63638
// for j in tmp do
63558: LD_ADDR_VAR 0 4
63562: PUSH
63563: LD_VAR 0 6
63567: PUSH
63568: FOR_IN
63569: IFFALSE 63628
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63571: LD_ADDR_VAR 0 7
63575: PUSH
63576: LD_VAR 0 4
63580: PPUSH
63581: CALL_OW 313
63585: PPUSH
63586: LD_INT 25
63588: PUSH
63589: LD_INT 1
63591: PUSH
63592: EMPTY
63593: LIST
63594: LIST
63595: PPUSH
63596: CALL_OW 72
63600: ST_TO_ADDR
// if units then
63601: LD_VAR 0 7
63605: IFFALSE 63626
// begin ComExitBuilding ( units [ 1 ] ) ;
63607: LD_VAR 0 7
63611: PUSH
63612: LD_INT 1
63614: ARRAY
63615: PPUSH
63616: CALL_OW 122
// exit ;
63620: POP
63621: POP
63622: POP
63623: POP
63624: GO 63638
// end ; end ;
63626: GO 63568
63628: POP
63629: POP
// end ; end ; exit ;
63630: POP
63631: POP
63632: GO 63638
// end ; end ;
63634: GO 62992
63636: POP
63637: POP
// end ;
63638: LD_VAR 0 2
63642: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63643: LD_INT 0
63645: PPUSH
63646: PPUSH
63647: PPUSH
63648: PPUSH
63649: PPUSH
63650: PPUSH
63651: PPUSH
// if not mc_bases or not skirmish then
63652: LD_EXP 101
63656: NOT
63657: PUSH
63658: LD_EXP 99
63662: NOT
63663: OR
63664: IFFALSE 63668
// exit ;
63666: GO 63899
// btype := GetBType ( building ) ;
63668: LD_ADDR_VAR 0 6
63672: PUSH
63673: LD_VAR 0 1
63677: PPUSH
63678: CALL_OW 266
63682: ST_TO_ADDR
// x := GetX ( building ) ;
63683: LD_ADDR_VAR 0 7
63687: PUSH
63688: LD_VAR 0 1
63692: PPUSH
63693: CALL_OW 250
63697: ST_TO_ADDR
// y := GetY ( building ) ;
63698: LD_ADDR_VAR 0 8
63702: PUSH
63703: LD_VAR 0 1
63707: PPUSH
63708: CALL_OW 251
63712: ST_TO_ADDR
// d := GetDir ( building ) ;
63713: LD_ADDR_VAR 0 9
63717: PUSH
63718: LD_VAR 0 1
63722: PPUSH
63723: CALL_OW 254
63727: ST_TO_ADDR
// for i = 1 to mc_bases do
63728: LD_ADDR_VAR 0 4
63732: PUSH
63733: DOUBLE
63734: LD_INT 1
63736: DEC
63737: ST_TO_ADDR
63738: LD_EXP 101
63742: PUSH
63743: FOR_TO
63744: IFFALSE 63897
// begin if not mc_build_list [ i ] then
63746: LD_EXP 106
63750: PUSH
63751: LD_VAR 0 4
63755: ARRAY
63756: NOT
63757: IFFALSE 63761
// continue ;
63759: GO 63743
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63761: LD_VAR 0 6
63765: PUSH
63766: LD_VAR 0 7
63770: PUSH
63771: LD_VAR 0 8
63775: PUSH
63776: LD_VAR 0 9
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: LIST
63785: LIST
63786: PPUSH
63787: LD_EXP 106
63791: PUSH
63792: LD_VAR 0 4
63796: ARRAY
63797: PUSH
63798: LD_INT 1
63800: ARRAY
63801: PPUSH
63802: CALL 77667 0 2
63806: IFFALSE 63895
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63808: LD_ADDR_EXP 106
63812: PUSH
63813: LD_EXP 106
63817: PPUSH
63818: LD_VAR 0 4
63822: PPUSH
63823: LD_EXP 106
63827: PUSH
63828: LD_VAR 0 4
63832: ARRAY
63833: PPUSH
63834: LD_INT 1
63836: PPUSH
63837: CALL_OW 3
63841: PPUSH
63842: CALL_OW 1
63846: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63847: LD_ADDR_EXP 108
63851: PUSH
63852: LD_EXP 108
63856: PPUSH
63857: LD_VAR 0 4
63861: PUSH
63862: LD_EXP 108
63866: PUSH
63867: LD_VAR 0 4
63871: ARRAY
63872: PUSH
63873: LD_INT 1
63875: PLUS
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: PPUSH
63881: LD_VAR 0 1
63885: PPUSH
63886: CALL 71498 0 3
63890: ST_TO_ADDR
// exit ;
63891: POP
63892: POP
63893: GO 63899
// end ; end ;
63895: GO 63743
63897: POP
63898: POP
// end ;
63899: LD_VAR 0 3
63903: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63904: LD_INT 0
63906: PPUSH
63907: PPUSH
63908: PPUSH
// if not mc_bases or not skirmish then
63909: LD_EXP 101
63913: NOT
63914: PUSH
63915: LD_EXP 99
63919: NOT
63920: OR
63921: IFFALSE 63925
// exit ;
63923: GO 64115
// for i = 1 to mc_bases do
63925: LD_ADDR_VAR 0 4
63929: PUSH
63930: DOUBLE
63931: LD_INT 1
63933: DEC
63934: ST_TO_ADDR
63935: LD_EXP 101
63939: PUSH
63940: FOR_TO
63941: IFFALSE 64028
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63943: LD_VAR 0 1
63947: PUSH
63948: LD_EXP 109
63952: PUSH
63953: LD_VAR 0 4
63957: ARRAY
63958: IN
63959: PUSH
63960: LD_VAR 0 1
63964: PUSH
63965: LD_EXP 110
63969: PUSH
63970: LD_VAR 0 4
63974: ARRAY
63975: IN
63976: NOT
63977: AND
63978: IFFALSE 64026
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63980: LD_ADDR_EXP 110
63984: PUSH
63985: LD_EXP 110
63989: PPUSH
63990: LD_VAR 0 4
63994: PUSH
63995: LD_EXP 110
63999: PUSH
64000: LD_VAR 0 4
64004: ARRAY
64005: PUSH
64006: LD_INT 1
64008: PLUS
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: PPUSH
64014: LD_VAR 0 1
64018: PPUSH
64019: CALL 71498 0 3
64023: ST_TO_ADDR
// break ;
64024: GO 64028
// end ; end ;
64026: GO 63940
64028: POP
64029: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64030: LD_VAR 0 1
64034: PPUSH
64035: CALL_OW 257
64039: PUSH
64040: LD_EXP 127
64044: IN
64045: PUSH
64046: LD_VAR 0 1
64050: PPUSH
64051: CALL_OW 266
64055: PUSH
64056: LD_INT 5
64058: EQUAL
64059: AND
64060: PUSH
64061: LD_VAR 0 2
64065: PPUSH
64066: CALL_OW 110
64070: PUSH
64071: LD_INT 18
64073: NONEQUAL
64074: AND
64075: IFFALSE 64115
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64077: LD_VAR 0 2
64081: PPUSH
64082: CALL_OW 257
64086: PUSH
64087: LD_INT 5
64089: PUSH
64090: LD_INT 8
64092: PUSH
64093: LD_INT 9
64095: PUSH
64096: EMPTY
64097: LIST
64098: LIST
64099: LIST
64100: IN
64101: IFFALSE 64115
// SetClass ( unit , 1 ) ;
64103: LD_VAR 0 2
64107: PPUSH
64108: LD_INT 1
64110: PPUSH
64111: CALL_OW 336
// end ;
64115: LD_VAR 0 3
64119: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64120: LD_INT 0
64122: PPUSH
64123: PPUSH
// if not mc_bases or not skirmish then
64124: LD_EXP 101
64128: NOT
64129: PUSH
64130: LD_EXP 99
64134: NOT
64135: OR
64136: IFFALSE 64140
// exit ;
64138: GO 64256
// if GetLives ( abandoned_vehicle ) > 250 then
64140: LD_VAR 0 2
64144: PPUSH
64145: CALL_OW 256
64149: PUSH
64150: LD_INT 250
64152: GREATER
64153: IFFALSE 64157
// exit ;
64155: GO 64256
// for i = 1 to mc_bases do
64157: LD_ADDR_VAR 0 6
64161: PUSH
64162: DOUBLE
64163: LD_INT 1
64165: DEC
64166: ST_TO_ADDR
64167: LD_EXP 101
64171: PUSH
64172: FOR_TO
64173: IFFALSE 64254
// begin if driver in mc_bases [ i ] then
64175: LD_VAR 0 1
64179: PUSH
64180: LD_EXP 101
64184: PUSH
64185: LD_VAR 0 6
64189: ARRAY
64190: IN
64191: IFFALSE 64252
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64193: LD_VAR 0 1
64197: PPUSH
64198: LD_EXP 101
64202: PUSH
64203: LD_VAR 0 6
64207: ARRAY
64208: PPUSH
64209: LD_INT 2
64211: PUSH
64212: LD_INT 30
64214: PUSH
64215: LD_INT 0
64217: PUSH
64218: EMPTY
64219: LIST
64220: LIST
64221: PUSH
64222: LD_INT 30
64224: PUSH
64225: LD_INT 1
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: LIST
64236: PPUSH
64237: CALL_OW 72
64241: PUSH
64242: LD_INT 1
64244: ARRAY
64245: PPUSH
64246: CALL_OW 112
// break ;
64250: GO 64254
// end ; end ;
64252: GO 64172
64254: POP
64255: POP
// end ; end_of_file
64256: LD_VAR 0 5
64260: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64261: LD_INT 0
64263: PPUSH
64264: PPUSH
// if exist_mode then
64265: LD_VAR 0 2
64269: IFFALSE 64294
// unit := CreateCharacter ( prefix & ident ) else
64271: LD_ADDR_VAR 0 5
64275: PUSH
64276: LD_VAR 0 3
64280: PUSH
64281: LD_VAR 0 1
64285: STR
64286: PPUSH
64287: CALL_OW 34
64291: ST_TO_ADDR
64292: GO 64309
// unit := NewCharacter ( ident ) ;
64294: LD_ADDR_VAR 0 5
64298: PUSH
64299: LD_VAR 0 1
64303: PPUSH
64304: CALL_OW 25
64308: ST_TO_ADDR
// result := unit ;
64309: LD_ADDR_VAR 0 4
64313: PUSH
64314: LD_VAR 0 5
64318: ST_TO_ADDR
// end ;
64319: LD_VAR 0 4
64323: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64324: LD_INT 0
64326: PPUSH
64327: PPUSH
// if not side or not nation then
64328: LD_VAR 0 1
64332: NOT
64333: PUSH
64334: LD_VAR 0 2
64338: NOT
64339: OR
64340: IFFALSE 64344
// exit ;
64342: GO 64988
// case nation of nation_american :
64344: LD_VAR 0 2
64348: PUSH
64349: LD_INT 1
64351: DOUBLE
64352: EQUAL
64353: IFTRUE 64357
64355: GO 64531
64357: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64358: LD_ADDR_VAR 0 4
64362: PUSH
64363: LD_INT 35
64365: PUSH
64366: LD_INT 45
64368: PUSH
64369: LD_INT 46
64371: PUSH
64372: LD_INT 47
64374: PUSH
64375: LD_INT 1
64377: PUSH
64378: LD_INT 2
64380: PUSH
64381: LD_INT 6
64383: PUSH
64384: LD_INT 15
64386: PUSH
64387: LD_INT 16
64389: PUSH
64390: LD_INT 7
64392: PUSH
64393: LD_INT 12
64395: PUSH
64396: LD_INT 13
64398: PUSH
64399: LD_INT 10
64401: PUSH
64402: LD_INT 14
64404: PUSH
64405: LD_INT 20
64407: PUSH
64408: LD_INT 21
64410: PUSH
64411: LD_INT 22
64413: PUSH
64414: LD_INT 25
64416: PUSH
64417: LD_INT 32
64419: PUSH
64420: LD_INT 27
64422: PUSH
64423: LD_INT 36
64425: PUSH
64426: LD_INT 69
64428: PUSH
64429: LD_INT 39
64431: PUSH
64432: LD_INT 34
64434: PUSH
64435: LD_INT 40
64437: PUSH
64438: LD_INT 48
64440: PUSH
64441: LD_INT 49
64443: PUSH
64444: LD_INT 50
64446: PUSH
64447: LD_INT 51
64449: PUSH
64450: LD_INT 52
64452: PUSH
64453: LD_INT 53
64455: PUSH
64456: LD_INT 54
64458: PUSH
64459: LD_INT 55
64461: PUSH
64462: LD_INT 56
64464: PUSH
64465: LD_INT 57
64467: PUSH
64468: LD_INT 58
64470: PUSH
64471: LD_INT 59
64473: PUSH
64474: LD_INT 60
64476: PUSH
64477: LD_INT 61
64479: PUSH
64480: LD_INT 62
64482: PUSH
64483: LD_INT 80
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: ST_TO_ADDR
64529: GO 64912
64531: LD_INT 2
64533: DOUBLE
64534: EQUAL
64535: IFTRUE 64539
64537: GO 64721
64539: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64540: LD_ADDR_VAR 0 4
64544: PUSH
64545: LD_INT 35
64547: PUSH
64548: LD_INT 45
64550: PUSH
64551: LD_INT 46
64553: PUSH
64554: LD_INT 47
64556: PUSH
64557: LD_INT 70
64559: PUSH
64560: LD_INT 1
64562: PUSH
64563: LD_INT 11
64565: PUSH
64566: LD_INT 3
64568: PUSH
64569: LD_INT 4
64571: PUSH
64572: LD_INT 5
64574: PUSH
64575: LD_INT 6
64577: PUSH
64578: LD_INT 15
64580: PUSH
64581: LD_INT 18
64583: PUSH
64584: LD_INT 7
64586: PUSH
64587: LD_INT 17
64589: PUSH
64590: LD_INT 8
64592: PUSH
64593: LD_INT 20
64595: PUSH
64596: LD_INT 21
64598: PUSH
64599: LD_INT 22
64601: PUSH
64602: LD_INT 72
64604: PUSH
64605: LD_INT 26
64607: PUSH
64608: LD_INT 69
64610: PUSH
64611: LD_INT 39
64613: PUSH
64614: LD_INT 40
64616: PUSH
64617: LD_INT 41
64619: PUSH
64620: LD_INT 42
64622: PUSH
64623: LD_INT 43
64625: PUSH
64626: LD_INT 48
64628: PUSH
64629: LD_INT 49
64631: PUSH
64632: LD_INT 50
64634: PUSH
64635: LD_INT 51
64637: PUSH
64638: LD_INT 52
64640: PUSH
64641: LD_INT 53
64643: PUSH
64644: LD_INT 54
64646: PUSH
64647: LD_INT 55
64649: PUSH
64650: LD_INT 56
64652: PUSH
64653: LD_INT 60
64655: PUSH
64656: LD_INT 61
64658: PUSH
64659: LD_INT 62
64661: PUSH
64662: LD_INT 66
64664: PUSH
64665: LD_INT 67
64667: PUSH
64668: LD_INT 68
64670: PUSH
64671: LD_INT 81
64673: PUSH
64674: EMPTY
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: ST_TO_ADDR
64719: GO 64912
64721: LD_INT 3
64723: DOUBLE
64724: EQUAL
64725: IFTRUE 64729
64727: GO 64911
64729: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64730: LD_ADDR_VAR 0 4
64734: PUSH
64735: LD_INT 46
64737: PUSH
64738: LD_INT 47
64740: PUSH
64741: LD_INT 1
64743: PUSH
64744: LD_INT 2
64746: PUSH
64747: LD_INT 11
64749: PUSH
64750: LD_INT 9
64752: PUSH
64753: LD_INT 20
64755: PUSH
64756: LD_INT 19
64758: PUSH
64759: LD_INT 21
64761: PUSH
64762: LD_INT 24
64764: PUSH
64765: LD_INT 22
64767: PUSH
64768: LD_INT 25
64770: PUSH
64771: LD_INT 28
64773: PUSH
64774: LD_INT 29
64776: PUSH
64777: LD_INT 30
64779: PUSH
64780: LD_INT 31
64782: PUSH
64783: LD_INT 37
64785: PUSH
64786: LD_INT 38
64788: PUSH
64789: LD_INT 32
64791: PUSH
64792: LD_INT 27
64794: PUSH
64795: LD_INT 33
64797: PUSH
64798: LD_INT 69
64800: PUSH
64801: LD_INT 39
64803: PUSH
64804: LD_INT 34
64806: PUSH
64807: LD_INT 40
64809: PUSH
64810: LD_INT 71
64812: PUSH
64813: LD_INT 23
64815: PUSH
64816: LD_INT 44
64818: PUSH
64819: LD_INT 48
64821: PUSH
64822: LD_INT 49
64824: PUSH
64825: LD_INT 50
64827: PUSH
64828: LD_INT 51
64830: PUSH
64831: LD_INT 52
64833: PUSH
64834: LD_INT 53
64836: PUSH
64837: LD_INT 54
64839: PUSH
64840: LD_INT 55
64842: PUSH
64843: LD_INT 56
64845: PUSH
64846: LD_INT 57
64848: PUSH
64849: LD_INT 58
64851: PUSH
64852: LD_INT 59
64854: PUSH
64855: LD_INT 63
64857: PUSH
64858: LD_INT 64
64860: PUSH
64861: LD_INT 65
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: LIST
64871: LIST
64872: LIST
64873: LIST
64874: LIST
64875: LIST
64876: LIST
64877: LIST
64878: LIST
64879: LIST
64880: LIST
64881: LIST
64882: LIST
64883: LIST
64884: LIST
64885: LIST
64886: LIST
64887: LIST
64888: LIST
64889: LIST
64890: LIST
64891: LIST
64892: LIST
64893: LIST
64894: LIST
64895: LIST
64896: LIST
64897: LIST
64898: LIST
64899: LIST
64900: LIST
64901: LIST
64902: LIST
64903: LIST
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: ST_TO_ADDR
64909: GO 64912
64911: POP
// if state > - 1 and state < 3 then
64912: LD_VAR 0 3
64916: PUSH
64917: LD_INT 1
64919: NEG
64920: GREATER
64921: PUSH
64922: LD_VAR 0 3
64926: PUSH
64927: LD_INT 3
64929: LESS
64930: AND
64931: IFFALSE 64988
// for i in result do
64933: LD_ADDR_VAR 0 5
64937: PUSH
64938: LD_VAR 0 4
64942: PUSH
64943: FOR_IN
64944: IFFALSE 64986
// if GetTech ( i , side ) <> state then
64946: LD_VAR 0 5
64950: PPUSH
64951: LD_VAR 0 1
64955: PPUSH
64956: CALL_OW 321
64960: PUSH
64961: LD_VAR 0 3
64965: NONEQUAL
64966: IFFALSE 64984
// result := result diff i ;
64968: LD_ADDR_VAR 0 4
64972: PUSH
64973: LD_VAR 0 4
64977: PUSH
64978: LD_VAR 0 5
64982: DIFF
64983: ST_TO_ADDR
64984: GO 64943
64986: POP
64987: POP
// end ;
64988: LD_VAR 0 4
64992: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64993: LD_INT 0
64995: PPUSH
64996: PPUSH
64997: PPUSH
// result := true ;
64998: LD_ADDR_VAR 0 3
65002: PUSH
65003: LD_INT 1
65005: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65006: LD_ADDR_VAR 0 5
65010: PUSH
65011: LD_VAR 0 2
65015: PPUSH
65016: CALL_OW 480
65020: ST_TO_ADDR
// if not tmp then
65021: LD_VAR 0 5
65025: NOT
65026: IFFALSE 65030
// exit ;
65028: GO 65079
// for i in tmp do
65030: LD_ADDR_VAR 0 4
65034: PUSH
65035: LD_VAR 0 5
65039: PUSH
65040: FOR_IN
65041: IFFALSE 65077
// if GetTech ( i , side ) <> state_researched then
65043: LD_VAR 0 4
65047: PPUSH
65048: LD_VAR 0 1
65052: PPUSH
65053: CALL_OW 321
65057: PUSH
65058: LD_INT 2
65060: NONEQUAL
65061: IFFALSE 65075
// begin result := false ;
65063: LD_ADDR_VAR 0 3
65067: PUSH
65068: LD_INT 0
65070: ST_TO_ADDR
// exit ;
65071: POP
65072: POP
65073: GO 65079
// end ;
65075: GO 65040
65077: POP
65078: POP
// end ;
65079: LD_VAR 0 3
65083: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65084: LD_INT 0
65086: PPUSH
65087: PPUSH
65088: PPUSH
65089: PPUSH
65090: PPUSH
65091: PPUSH
65092: PPUSH
65093: PPUSH
65094: PPUSH
65095: PPUSH
65096: PPUSH
65097: PPUSH
65098: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65099: LD_VAR 0 1
65103: NOT
65104: PUSH
65105: LD_VAR 0 1
65109: PPUSH
65110: CALL_OW 257
65114: PUSH
65115: LD_INT 9
65117: NONEQUAL
65118: OR
65119: IFFALSE 65123
// exit ;
65121: GO 65696
// side := GetSide ( unit ) ;
65123: LD_ADDR_VAR 0 9
65127: PUSH
65128: LD_VAR 0 1
65132: PPUSH
65133: CALL_OW 255
65137: ST_TO_ADDR
// tech_space := tech_spacanom ;
65138: LD_ADDR_VAR 0 12
65142: PUSH
65143: LD_INT 29
65145: ST_TO_ADDR
// tech_time := tech_taurad ;
65146: LD_ADDR_VAR 0 13
65150: PUSH
65151: LD_INT 28
65153: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65154: LD_ADDR_VAR 0 11
65158: PUSH
65159: LD_VAR 0 1
65163: PPUSH
65164: CALL_OW 310
65168: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65169: LD_VAR 0 11
65173: PPUSH
65174: CALL_OW 247
65178: PUSH
65179: LD_INT 2
65181: EQUAL
65182: IFFALSE 65186
// exit ;
65184: GO 65696
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65186: LD_ADDR_VAR 0 8
65190: PUSH
65191: LD_INT 81
65193: PUSH
65194: LD_VAR 0 9
65198: PUSH
65199: EMPTY
65200: LIST
65201: LIST
65202: PUSH
65203: LD_INT 3
65205: PUSH
65206: LD_INT 21
65208: PUSH
65209: LD_INT 3
65211: PUSH
65212: EMPTY
65213: LIST
65214: LIST
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: PUSH
65220: EMPTY
65221: LIST
65222: LIST
65223: PPUSH
65224: CALL_OW 69
65228: ST_TO_ADDR
// if not tmp then
65229: LD_VAR 0 8
65233: NOT
65234: IFFALSE 65238
// exit ;
65236: GO 65696
// if in_unit then
65238: LD_VAR 0 11
65242: IFFALSE 65266
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65244: LD_ADDR_VAR 0 10
65248: PUSH
65249: LD_VAR 0 8
65253: PPUSH
65254: LD_VAR 0 11
65258: PPUSH
65259: CALL_OW 74
65263: ST_TO_ADDR
65264: GO 65286
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65266: LD_ADDR_VAR 0 10
65270: PUSH
65271: LD_VAR 0 8
65275: PPUSH
65276: LD_VAR 0 1
65280: PPUSH
65281: CALL_OW 74
65285: ST_TO_ADDR
// if not enemy then
65286: LD_VAR 0 10
65290: NOT
65291: IFFALSE 65295
// exit ;
65293: GO 65696
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65295: LD_VAR 0 11
65299: PUSH
65300: LD_VAR 0 11
65304: PPUSH
65305: LD_VAR 0 10
65309: PPUSH
65310: CALL_OW 296
65314: PUSH
65315: LD_INT 13
65317: GREATER
65318: AND
65319: PUSH
65320: LD_VAR 0 1
65324: PPUSH
65325: LD_VAR 0 10
65329: PPUSH
65330: CALL_OW 296
65334: PUSH
65335: LD_INT 12
65337: GREATER
65338: OR
65339: IFFALSE 65343
// exit ;
65341: GO 65696
// missile := [ 1 ] ;
65343: LD_ADDR_VAR 0 14
65347: PUSH
65348: LD_INT 1
65350: PUSH
65351: EMPTY
65352: LIST
65353: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65354: LD_VAR 0 9
65358: PPUSH
65359: LD_VAR 0 12
65363: PPUSH
65364: CALL_OW 325
65368: IFFALSE 65397
// missile := Insert ( missile , missile + 1 , 2 ) ;
65370: LD_ADDR_VAR 0 14
65374: PUSH
65375: LD_VAR 0 14
65379: PPUSH
65380: LD_VAR 0 14
65384: PUSH
65385: LD_INT 1
65387: PLUS
65388: PPUSH
65389: LD_INT 2
65391: PPUSH
65392: CALL_OW 2
65396: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65397: LD_VAR 0 9
65401: PPUSH
65402: LD_VAR 0 13
65406: PPUSH
65407: CALL_OW 325
65411: PUSH
65412: LD_VAR 0 10
65416: PPUSH
65417: CALL_OW 255
65421: PPUSH
65422: LD_VAR 0 13
65426: PPUSH
65427: CALL_OW 325
65431: NOT
65432: AND
65433: IFFALSE 65462
// missile := Insert ( missile , missile + 1 , 3 ) ;
65435: LD_ADDR_VAR 0 14
65439: PUSH
65440: LD_VAR 0 14
65444: PPUSH
65445: LD_VAR 0 14
65449: PUSH
65450: LD_INT 1
65452: PLUS
65453: PPUSH
65454: LD_INT 3
65456: PPUSH
65457: CALL_OW 2
65461: ST_TO_ADDR
// if missile < 2 then
65462: LD_VAR 0 14
65466: PUSH
65467: LD_INT 2
65469: LESS
65470: IFFALSE 65474
// exit ;
65472: GO 65696
// x := GetX ( enemy ) ;
65474: LD_ADDR_VAR 0 4
65478: PUSH
65479: LD_VAR 0 10
65483: PPUSH
65484: CALL_OW 250
65488: ST_TO_ADDR
// y := GetY ( enemy ) ;
65489: LD_ADDR_VAR 0 5
65493: PUSH
65494: LD_VAR 0 10
65498: PPUSH
65499: CALL_OW 251
65503: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65504: LD_ADDR_VAR 0 6
65508: PUSH
65509: LD_VAR 0 4
65513: PUSH
65514: LD_INT 1
65516: NEG
65517: PPUSH
65518: LD_INT 1
65520: PPUSH
65521: CALL_OW 12
65525: PLUS
65526: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65527: LD_ADDR_VAR 0 7
65531: PUSH
65532: LD_VAR 0 5
65536: PUSH
65537: LD_INT 1
65539: NEG
65540: PPUSH
65541: LD_INT 1
65543: PPUSH
65544: CALL_OW 12
65548: PLUS
65549: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65550: LD_VAR 0 6
65554: PPUSH
65555: LD_VAR 0 7
65559: PPUSH
65560: CALL_OW 488
65564: NOT
65565: IFFALSE 65587
// begin _x := x ;
65567: LD_ADDR_VAR 0 6
65571: PUSH
65572: LD_VAR 0 4
65576: ST_TO_ADDR
// _y := y ;
65577: LD_ADDR_VAR 0 7
65581: PUSH
65582: LD_VAR 0 5
65586: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65587: LD_ADDR_VAR 0 3
65591: PUSH
65592: LD_INT 1
65594: PPUSH
65595: LD_VAR 0 14
65599: PPUSH
65600: CALL_OW 12
65604: ST_TO_ADDR
// case i of 1 :
65605: LD_VAR 0 3
65609: PUSH
65610: LD_INT 1
65612: DOUBLE
65613: EQUAL
65614: IFTRUE 65618
65616: GO 65635
65618: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65619: LD_VAR 0 1
65623: PPUSH
65624: LD_VAR 0 10
65628: PPUSH
65629: CALL_OW 115
65633: GO 65696
65635: LD_INT 2
65637: DOUBLE
65638: EQUAL
65639: IFTRUE 65643
65641: GO 65665
65643: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65644: LD_VAR 0 1
65648: PPUSH
65649: LD_VAR 0 6
65653: PPUSH
65654: LD_VAR 0 7
65658: PPUSH
65659: CALL_OW 153
65663: GO 65696
65665: LD_INT 3
65667: DOUBLE
65668: EQUAL
65669: IFTRUE 65673
65671: GO 65695
65673: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65674: LD_VAR 0 1
65678: PPUSH
65679: LD_VAR 0 6
65683: PPUSH
65684: LD_VAR 0 7
65688: PPUSH
65689: CALL_OW 154
65693: GO 65696
65695: POP
// end ;
65696: LD_VAR 0 2
65700: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65701: LD_INT 0
65703: PPUSH
65704: PPUSH
65705: PPUSH
65706: PPUSH
65707: PPUSH
65708: PPUSH
// if not unit or not building then
65709: LD_VAR 0 1
65713: NOT
65714: PUSH
65715: LD_VAR 0 2
65719: NOT
65720: OR
65721: IFFALSE 65725
// exit ;
65723: GO 65883
// x := GetX ( building ) ;
65725: LD_ADDR_VAR 0 5
65729: PUSH
65730: LD_VAR 0 2
65734: PPUSH
65735: CALL_OW 250
65739: ST_TO_ADDR
// y := GetY ( building ) ;
65740: LD_ADDR_VAR 0 6
65744: PUSH
65745: LD_VAR 0 2
65749: PPUSH
65750: CALL_OW 251
65754: ST_TO_ADDR
// for i = 0 to 5 do
65755: LD_ADDR_VAR 0 4
65759: PUSH
65760: DOUBLE
65761: LD_INT 0
65763: DEC
65764: ST_TO_ADDR
65765: LD_INT 5
65767: PUSH
65768: FOR_TO
65769: IFFALSE 65881
// begin _x := ShiftX ( x , i , 3 ) ;
65771: LD_ADDR_VAR 0 7
65775: PUSH
65776: LD_VAR 0 5
65780: PPUSH
65781: LD_VAR 0 4
65785: PPUSH
65786: LD_INT 3
65788: PPUSH
65789: CALL_OW 272
65793: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65794: LD_ADDR_VAR 0 8
65798: PUSH
65799: LD_VAR 0 6
65803: PPUSH
65804: LD_VAR 0 4
65808: PPUSH
65809: LD_INT 3
65811: PPUSH
65812: CALL_OW 273
65816: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65817: LD_VAR 0 7
65821: PPUSH
65822: LD_VAR 0 8
65826: PPUSH
65827: CALL_OW 488
65831: NOT
65832: IFFALSE 65836
// continue ;
65834: GO 65768
// if HexInfo ( _x , _y ) = 0 then
65836: LD_VAR 0 7
65840: PPUSH
65841: LD_VAR 0 8
65845: PPUSH
65846: CALL_OW 428
65850: PUSH
65851: LD_INT 0
65853: EQUAL
65854: IFFALSE 65879
// begin ComMoveXY ( unit , _x , _y ) ;
65856: LD_VAR 0 1
65860: PPUSH
65861: LD_VAR 0 7
65865: PPUSH
65866: LD_VAR 0 8
65870: PPUSH
65871: CALL_OW 111
// exit ;
65875: POP
65876: POP
65877: GO 65883
// end ; end ;
65879: GO 65768
65881: POP
65882: POP
// end ;
65883: LD_VAR 0 3
65887: RET
// export function ScanBase ( side , base_area ) ; begin
65888: LD_INT 0
65890: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65891: LD_ADDR_VAR 0 3
65895: PUSH
65896: LD_VAR 0 2
65900: PPUSH
65901: LD_INT 81
65903: PUSH
65904: LD_VAR 0 1
65908: PUSH
65909: EMPTY
65910: LIST
65911: LIST
65912: PPUSH
65913: CALL_OW 70
65917: ST_TO_ADDR
// end ;
65918: LD_VAR 0 3
65922: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65923: LD_INT 0
65925: PPUSH
65926: PPUSH
65927: PPUSH
65928: PPUSH
65929: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65930: LD_VAR 0 1
65934: NOT
65935: PUSH
65936: LD_EXP 101
65940: PUSH
65941: LD_VAR 0 1
65945: ARRAY
65946: NOT
65947: OR
65948: PUSH
65949: LD_VAR 0 2
65953: NOT
65954: OR
65955: PUSH
65956: LD_VAR 0 3
65960: NOT
65961: OR
65962: IFFALSE 65966
// exit ;
65964: GO 66479
// side := mc_sides [ base ] ;
65966: LD_ADDR_VAR 0 6
65970: PUSH
65971: LD_EXP 127
65975: PUSH
65976: LD_VAR 0 1
65980: ARRAY
65981: ST_TO_ADDR
// if not side then
65982: LD_VAR 0 6
65986: NOT
65987: IFFALSE 65991
// exit ;
65989: GO 66479
// for i in solds do
65991: LD_ADDR_VAR 0 7
65995: PUSH
65996: LD_VAR 0 2
66000: PUSH
66001: FOR_IN
66002: IFFALSE 66063
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66004: LD_VAR 0 7
66008: PPUSH
66009: CALL_OW 310
66013: PPUSH
66014: CALL_OW 266
66018: PUSH
66019: LD_INT 32
66021: PUSH
66022: LD_INT 31
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: IN
66029: IFFALSE 66049
// solds := solds diff i else
66031: LD_ADDR_VAR 0 2
66035: PUSH
66036: LD_VAR 0 2
66040: PUSH
66041: LD_VAR 0 7
66045: DIFF
66046: ST_TO_ADDR
66047: GO 66061
// SetTag ( i , 18 ) ;
66049: LD_VAR 0 7
66053: PPUSH
66054: LD_INT 18
66056: PPUSH
66057: CALL_OW 109
66061: GO 66001
66063: POP
66064: POP
// if not solds then
66065: LD_VAR 0 2
66069: NOT
66070: IFFALSE 66074
// exit ;
66072: GO 66479
// repeat wait ( 0 0$1 ) ;
66074: LD_INT 35
66076: PPUSH
66077: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66081: LD_ADDR_VAR 0 5
66085: PUSH
66086: LD_VAR 0 6
66090: PPUSH
66091: LD_VAR 0 3
66095: PPUSH
66096: CALL 65888 0 2
66100: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66101: LD_EXP 101
66105: PUSH
66106: LD_VAR 0 1
66110: ARRAY
66111: NOT
66112: PUSH
66113: LD_EXP 101
66117: PUSH
66118: LD_VAR 0 1
66122: ARRAY
66123: PUSH
66124: EMPTY
66125: EQUAL
66126: OR
66127: IFFALSE 66164
// begin for i in solds do
66129: LD_ADDR_VAR 0 7
66133: PUSH
66134: LD_VAR 0 2
66138: PUSH
66139: FOR_IN
66140: IFFALSE 66153
// ComStop ( i ) ;
66142: LD_VAR 0 7
66146: PPUSH
66147: CALL_OW 141
66151: GO 66139
66153: POP
66154: POP
// solds := [ ] ;
66155: LD_ADDR_VAR 0 2
66159: PUSH
66160: EMPTY
66161: ST_TO_ADDR
// exit ;
66162: GO 66479
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66164: LD_VAR 0 5
66168: NOT
66169: PUSH
66170: LD_VAR 0 5
66174: PUSH
66175: LD_INT 3
66177: GREATER
66178: OR
66179: PUSH
66180: LD_EXP 123
66184: PUSH
66185: LD_VAR 0 1
66189: ARRAY
66190: OR
66191: IFFALSE 66232
// begin for i in solds do
66193: LD_ADDR_VAR 0 7
66197: PUSH
66198: LD_VAR 0 2
66202: PUSH
66203: FOR_IN
66204: IFFALSE 66228
// if HasTask ( i ) then
66206: LD_VAR 0 7
66210: PPUSH
66211: CALL_OW 314
66215: IFFALSE 66226
// ComStop ( i ) ;
66217: LD_VAR 0 7
66221: PPUSH
66222: CALL_OW 141
66226: GO 66203
66228: POP
66229: POP
// break ;
66230: GO 66467
// end ; for i in solds do
66232: LD_ADDR_VAR 0 7
66236: PUSH
66237: LD_VAR 0 2
66241: PUSH
66242: FOR_IN
66243: IFFALSE 66459
// begin if IsInUnit ( i ) then
66245: LD_VAR 0 7
66249: PPUSH
66250: CALL_OW 310
66254: IFFALSE 66265
// ComExitBuilding ( i ) ;
66256: LD_VAR 0 7
66260: PPUSH
66261: CALL_OW 122
// if GetLives ( i ) > 333 then
66265: LD_VAR 0 7
66269: PPUSH
66270: CALL_OW 256
66274: PUSH
66275: LD_INT 333
66277: GREATER
66278: IFFALSE 66306
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66280: LD_VAR 0 7
66284: PPUSH
66285: LD_VAR 0 5
66289: PPUSH
66290: LD_VAR 0 7
66294: PPUSH
66295: CALL_OW 74
66299: PPUSH
66300: CALL_OW 115
66304: GO 66457
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66306: LD_ADDR_VAR 0 8
66310: PUSH
66311: LD_EXP 101
66315: PUSH
66316: LD_VAR 0 1
66320: ARRAY
66321: PPUSH
66322: LD_INT 2
66324: PUSH
66325: LD_INT 30
66327: PUSH
66328: LD_INT 0
66330: PUSH
66331: EMPTY
66332: LIST
66333: LIST
66334: PUSH
66335: LD_INT 30
66337: PUSH
66338: LD_INT 1
66340: PUSH
66341: EMPTY
66342: LIST
66343: LIST
66344: PUSH
66345: LD_INT 30
66347: PUSH
66348: LD_INT 6
66350: PUSH
66351: EMPTY
66352: LIST
66353: LIST
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: PPUSH
66361: CALL_OW 72
66365: PPUSH
66366: LD_VAR 0 7
66370: PPUSH
66371: CALL_OW 74
66375: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66376: LD_VAR 0 7
66380: PPUSH
66381: LD_VAR 0 8
66385: PPUSH
66386: CALL_OW 250
66390: PPUSH
66391: LD_INT 3
66393: PPUSH
66394: LD_INT 5
66396: PPUSH
66397: CALL_OW 272
66401: PPUSH
66402: LD_VAR 0 8
66406: PPUSH
66407: CALL_OW 251
66411: PPUSH
66412: LD_INT 3
66414: PPUSH
66415: LD_INT 5
66417: PPUSH
66418: CALL_OW 273
66422: PPUSH
66423: CALL_OW 111
// SetTag ( i , 0 ) ;
66427: LD_VAR 0 7
66431: PPUSH
66432: LD_INT 0
66434: PPUSH
66435: CALL_OW 109
// solds := solds diff i ;
66439: LD_ADDR_VAR 0 2
66443: PUSH
66444: LD_VAR 0 2
66448: PUSH
66449: LD_VAR 0 7
66453: DIFF
66454: ST_TO_ADDR
// continue ;
66455: GO 66242
// end ; end ;
66457: GO 66242
66459: POP
66460: POP
// until solds ;
66461: LD_VAR 0 2
66465: IFFALSE 66074
// MC_Reset ( base , 18 ) ;
66467: LD_VAR 0 1
66471: PPUSH
66472: LD_INT 18
66474: PPUSH
66475: CALL 38300 0 2
// end ;
66479: LD_VAR 0 4
66483: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66484: LD_INT 0
66486: PPUSH
66487: PPUSH
66488: PPUSH
66489: PPUSH
66490: PPUSH
66491: PPUSH
66492: PPUSH
66493: PPUSH
66494: PPUSH
66495: PPUSH
66496: PPUSH
66497: PPUSH
66498: PPUSH
66499: PPUSH
66500: PPUSH
66501: PPUSH
66502: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66503: LD_ADDR_VAR 0 13
66507: PUSH
66508: LD_EXP 101
66512: PUSH
66513: LD_VAR 0 1
66517: ARRAY
66518: PPUSH
66519: LD_INT 25
66521: PUSH
66522: LD_INT 3
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PPUSH
66529: CALL_OW 72
66533: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66534: LD_EXP 141
66538: PUSH
66539: LD_VAR 0 1
66543: ARRAY
66544: IFFALSE 66568
// mechs := mechs diff mc_remote_driver [ base ] ;
66546: LD_ADDR_VAR 0 13
66550: PUSH
66551: LD_VAR 0 13
66555: PUSH
66556: LD_EXP 141
66560: PUSH
66561: LD_VAR 0 1
66565: ARRAY
66566: DIFF
66567: ST_TO_ADDR
// for i in mechs do
66568: LD_ADDR_VAR 0 5
66572: PUSH
66573: LD_VAR 0 13
66577: PUSH
66578: FOR_IN
66579: IFFALSE 66614
// if GetTag ( i ) > 0 then
66581: LD_VAR 0 5
66585: PPUSH
66586: CALL_OW 110
66590: PUSH
66591: LD_INT 0
66593: GREATER
66594: IFFALSE 66612
// mechs := mechs diff i ;
66596: LD_ADDR_VAR 0 13
66600: PUSH
66601: LD_VAR 0 13
66605: PUSH
66606: LD_VAR 0 5
66610: DIFF
66611: ST_TO_ADDR
66612: GO 66578
66614: POP
66615: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66616: LD_ADDR_VAR 0 9
66620: PUSH
66621: LD_EXP 101
66625: PUSH
66626: LD_VAR 0 1
66630: ARRAY
66631: PPUSH
66632: LD_INT 2
66634: PUSH
66635: LD_INT 25
66637: PUSH
66638: LD_INT 1
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: PUSH
66645: LD_INT 25
66647: PUSH
66648: LD_INT 5
66650: PUSH
66651: EMPTY
66652: LIST
66653: LIST
66654: PUSH
66655: LD_INT 25
66657: PUSH
66658: LD_INT 8
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 25
66667: PUSH
66668: LD_INT 9
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: EMPTY
66676: LIST
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: PPUSH
66682: CALL_OW 72
66686: ST_TO_ADDR
// if not defenders and not solds then
66687: LD_VAR 0 2
66691: NOT
66692: PUSH
66693: LD_VAR 0 9
66697: NOT
66698: AND
66699: IFFALSE 66703
// exit ;
66701: GO 68329
// depot_under_attack := false ;
66703: LD_ADDR_VAR 0 17
66707: PUSH
66708: LD_INT 0
66710: ST_TO_ADDR
// sold_defenders := [ ] ;
66711: LD_ADDR_VAR 0 18
66715: PUSH
66716: EMPTY
66717: ST_TO_ADDR
// if mechs then
66718: LD_VAR 0 13
66722: IFFALSE 66851
// for i in defenders do
66724: LD_ADDR_VAR 0 5
66728: PUSH
66729: LD_VAR 0 2
66733: PUSH
66734: FOR_IN
66735: IFFALSE 66849
// begin SetTag ( i , 20 ) ;
66737: LD_VAR 0 5
66741: PPUSH
66742: LD_INT 20
66744: PPUSH
66745: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66749: LD_VAR 0 5
66753: PPUSH
66754: CALL_OW 263
66758: PUSH
66759: LD_INT 1
66761: EQUAL
66762: PUSH
66763: LD_VAR 0 5
66767: PPUSH
66768: CALL_OW 311
66772: NOT
66773: AND
66774: PUSH
66775: LD_VAR 0 13
66779: AND
66780: IFFALSE 66847
// begin un := mechs [ 1 ] ;
66782: LD_ADDR_VAR 0 11
66786: PUSH
66787: LD_VAR 0 13
66791: PUSH
66792: LD_INT 1
66794: ARRAY
66795: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66796: LD_VAR 0 11
66800: PPUSH
66801: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66805: LD_VAR 0 11
66809: PPUSH
66810: LD_VAR 0 5
66814: PPUSH
66815: CALL_OW 180
// SetTag ( un , 19 ) ;
66819: LD_VAR 0 11
66823: PPUSH
66824: LD_INT 19
66826: PPUSH
66827: CALL_OW 109
// mechs := mechs diff un ;
66831: LD_ADDR_VAR 0 13
66835: PUSH
66836: LD_VAR 0 13
66840: PUSH
66841: LD_VAR 0 11
66845: DIFF
66846: ST_TO_ADDR
// end ; end ;
66847: GO 66734
66849: POP
66850: POP
// if solds then
66851: LD_VAR 0 9
66855: IFFALSE 66914
// for i in solds do
66857: LD_ADDR_VAR 0 5
66861: PUSH
66862: LD_VAR 0 9
66866: PUSH
66867: FOR_IN
66868: IFFALSE 66912
// if not GetTag ( i ) then
66870: LD_VAR 0 5
66874: PPUSH
66875: CALL_OW 110
66879: NOT
66880: IFFALSE 66910
// begin defenders := defenders union i ;
66882: LD_ADDR_VAR 0 2
66886: PUSH
66887: LD_VAR 0 2
66891: PUSH
66892: LD_VAR 0 5
66896: UNION
66897: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66898: LD_VAR 0 5
66902: PPUSH
66903: LD_INT 18
66905: PPUSH
66906: CALL_OW 109
// end ;
66910: GO 66867
66912: POP
66913: POP
// repeat wait ( 0 0$1 ) ;
66914: LD_INT 35
66916: PPUSH
66917: CALL_OW 67
// enemy := mc_scan [ base ] ;
66921: LD_ADDR_VAR 0 3
66925: PUSH
66926: LD_EXP 124
66930: PUSH
66931: LD_VAR 0 1
66935: ARRAY
66936: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66937: LD_EXP 101
66941: PUSH
66942: LD_VAR 0 1
66946: ARRAY
66947: NOT
66948: PUSH
66949: LD_EXP 101
66953: PUSH
66954: LD_VAR 0 1
66958: ARRAY
66959: PUSH
66960: EMPTY
66961: EQUAL
66962: OR
66963: IFFALSE 67000
// begin for i in defenders do
66965: LD_ADDR_VAR 0 5
66969: PUSH
66970: LD_VAR 0 2
66974: PUSH
66975: FOR_IN
66976: IFFALSE 66989
// ComStop ( i ) ;
66978: LD_VAR 0 5
66982: PPUSH
66983: CALL_OW 141
66987: GO 66975
66989: POP
66990: POP
// defenders := [ ] ;
66991: LD_ADDR_VAR 0 2
66995: PUSH
66996: EMPTY
66997: ST_TO_ADDR
// exit ;
66998: GO 68329
// end ; for i in defenders do
67000: LD_ADDR_VAR 0 5
67004: PUSH
67005: LD_VAR 0 2
67009: PUSH
67010: FOR_IN
67011: IFFALSE 67829
// begin e := NearestUnitToUnit ( enemy , i ) ;
67013: LD_ADDR_VAR 0 14
67017: PUSH
67018: LD_VAR 0 3
67022: PPUSH
67023: LD_VAR 0 5
67027: PPUSH
67028: CALL_OW 74
67032: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67033: LD_ADDR_VAR 0 8
67037: PUSH
67038: LD_EXP 101
67042: PUSH
67043: LD_VAR 0 1
67047: ARRAY
67048: PPUSH
67049: LD_INT 2
67051: PUSH
67052: LD_INT 30
67054: PUSH
67055: LD_INT 0
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: PUSH
67062: LD_INT 30
67064: PUSH
67065: LD_INT 1
67067: PUSH
67068: EMPTY
67069: LIST
67070: LIST
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: LIST
67076: PPUSH
67077: CALL_OW 72
67081: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67082: LD_ADDR_VAR 0 17
67086: PUSH
67087: LD_VAR 0 8
67091: NOT
67092: PUSH
67093: LD_VAR 0 8
67097: PPUSH
67098: LD_INT 3
67100: PUSH
67101: LD_INT 24
67103: PUSH
67104: LD_INT 600
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PPUSH
67115: CALL_OW 72
67119: OR
67120: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67121: LD_VAR 0 5
67125: PPUSH
67126: CALL_OW 247
67130: PUSH
67131: LD_INT 2
67133: DOUBLE
67134: EQUAL
67135: IFTRUE 67139
67137: GO 67535
67139: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67140: LD_VAR 0 5
67144: PPUSH
67145: CALL_OW 256
67149: PUSH
67150: LD_INT 650
67152: GREATER
67153: PUSH
67154: LD_VAR 0 5
67158: PPUSH
67159: LD_VAR 0 14
67163: PPUSH
67164: CALL_OW 296
67168: PUSH
67169: LD_INT 40
67171: LESS
67172: PUSH
67173: LD_VAR 0 14
67177: PPUSH
67178: LD_EXP 126
67182: PUSH
67183: LD_VAR 0 1
67187: ARRAY
67188: PPUSH
67189: CALL_OW 308
67193: OR
67194: AND
67195: IFFALSE 67317
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67197: LD_VAR 0 5
67201: PPUSH
67202: CALL_OW 262
67206: PUSH
67207: LD_INT 1
67209: EQUAL
67210: PUSH
67211: LD_VAR 0 5
67215: PPUSH
67216: CALL_OW 261
67220: PUSH
67221: LD_INT 30
67223: LESS
67224: AND
67225: PUSH
67226: LD_VAR 0 8
67230: AND
67231: IFFALSE 67301
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67233: LD_VAR 0 5
67237: PPUSH
67238: LD_VAR 0 8
67242: PPUSH
67243: LD_VAR 0 5
67247: PPUSH
67248: CALL_OW 74
67252: PPUSH
67253: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67257: LD_VAR 0 5
67261: PPUSH
67262: LD_VAR 0 8
67266: PPUSH
67267: LD_VAR 0 5
67271: PPUSH
67272: CALL_OW 74
67276: PPUSH
67277: CALL_OW 296
67281: PUSH
67282: LD_INT 6
67284: LESS
67285: IFFALSE 67299
// SetFuel ( i , 100 ) ;
67287: LD_VAR 0 5
67291: PPUSH
67292: LD_INT 100
67294: PPUSH
67295: CALL_OW 240
// end else
67299: GO 67315
// ComAttackUnit ( i , e ) ;
67301: LD_VAR 0 5
67305: PPUSH
67306: LD_VAR 0 14
67310: PPUSH
67311: CALL_OW 115
// end else
67315: GO 67418
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67317: LD_VAR 0 14
67321: PPUSH
67322: LD_EXP 126
67326: PUSH
67327: LD_VAR 0 1
67331: ARRAY
67332: PPUSH
67333: CALL_OW 308
67337: NOT
67338: PUSH
67339: LD_VAR 0 5
67343: PPUSH
67344: LD_VAR 0 14
67348: PPUSH
67349: CALL_OW 296
67353: PUSH
67354: LD_INT 40
67356: GREATEREQUAL
67357: AND
67358: PUSH
67359: LD_VAR 0 5
67363: PPUSH
67364: CALL_OW 256
67368: PUSH
67369: LD_INT 650
67371: LESSEQUAL
67372: OR
67373: PUSH
67374: LD_VAR 0 5
67378: PPUSH
67379: LD_EXP 125
67383: PUSH
67384: LD_VAR 0 1
67388: ARRAY
67389: PPUSH
67390: CALL_OW 308
67394: NOT
67395: AND
67396: IFFALSE 67418
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67398: LD_VAR 0 5
67402: PPUSH
67403: LD_EXP 125
67407: PUSH
67408: LD_VAR 0 1
67412: ARRAY
67413: PPUSH
67414: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67418: LD_VAR 0 5
67422: PPUSH
67423: CALL_OW 256
67427: PUSH
67428: LD_INT 998
67430: LESS
67431: PUSH
67432: LD_VAR 0 5
67436: PPUSH
67437: CALL_OW 263
67441: PUSH
67442: LD_INT 1
67444: EQUAL
67445: AND
67446: PUSH
67447: LD_VAR 0 5
67451: PPUSH
67452: CALL_OW 311
67456: AND
67457: PUSH
67458: LD_VAR 0 5
67462: PPUSH
67463: LD_EXP 125
67467: PUSH
67468: LD_VAR 0 1
67472: ARRAY
67473: PPUSH
67474: CALL_OW 308
67478: AND
67479: IFFALSE 67533
// begin mech := IsDrivenBy ( i ) ;
67481: LD_ADDR_VAR 0 10
67485: PUSH
67486: LD_VAR 0 5
67490: PPUSH
67491: CALL_OW 311
67495: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67496: LD_VAR 0 10
67500: PPUSH
67501: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67505: LD_VAR 0 10
67509: PPUSH
67510: LD_VAR 0 5
67514: PPUSH
67515: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67519: LD_VAR 0 10
67523: PPUSH
67524: LD_VAR 0 5
67528: PPUSH
67529: CALL_OW 180
// end ; end ; unit_human :
67533: GO 67800
67535: LD_INT 1
67537: DOUBLE
67538: EQUAL
67539: IFTRUE 67543
67541: GO 67799
67543: POP
// begin b := IsInUnit ( i ) ;
67544: LD_ADDR_VAR 0 19
67548: PUSH
67549: LD_VAR 0 5
67553: PPUSH
67554: CALL_OW 310
67558: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67559: LD_ADDR_VAR 0 20
67563: PUSH
67564: LD_VAR 0 19
67568: NOT
67569: PUSH
67570: LD_VAR 0 19
67574: PPUSH
67575: CALL_OW 266
67579: PUSH
67580: LD_INT 32
67582: PUSH
67583: LD_INT 31
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: IN
67590: OR
67591: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67592: LD_VAR 0 17
67596: PUSH
67597: LD_VAR 0 2
67601: PPUSH
67602: LD_INT 21
67604: PUSH
67605: LD_INT 2
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PPUSH
67612: CALL_OW 72
67616: PUSH
67617: LD_INT 1
67619: LESSEQUAL
67620: OR
67621: PUSH
67622: LD_VAR 0 20
67626: AND
67627: PUSH
67628: LD_VAR 0 5
67632: PUSH
67633: LD_VAR 0 18
67637: IN
67638: NOT
67639: AND
67640: IFFALSE 67733
// begin if b then
67642: LD_VAR 0 19
67646: IFFALSE 67695
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67648: LD_VAR 0 19
67652: PPUSH
67653: LD_VAR 0 3
67657: PPUSH
67658: LD_VAR 0 19
67662: PPUSH
67663: CALL_OW 74
67667: PPUSH
67668: CALL_OW 296
67672: PUSH
67673: LD_INT 10
67675: LESS
67676: PUSH
67677: LD_VAR 0 19
67681: PPUSH
67682: CALL_OW 461
67686: PUSH
67687: LD_INT 7
67689: NONEQUAL
67690: AND
67691: IFFALSE 67695
// continue ;
67693: GO 67010
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67695: LD_ADDR_VAR 0 18
67699: PUSH
67700: LD_VAR 0 18
67704: PPUSH
67705: LD_VAR 0 18
67709: PUSH
67710: LD_INT 1
67712: PLUS
67713: PPUSH
67714: LD_VAR 0 5
67718: PPUSH
67719: CALL_OW 1
67723: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67724: LD_VAR 0 5
67728: PPUSH
67729: CALL_OW 122
// end ; if sold_defenders then
67733: LD_VAR 0 18
67737: IFFALSE 67797
// if i in sold_defenders then
67739: LD_VAR 0 5
67743: PUSH
67744: LD_VAR 0 18
67748: IN
67749: IFFALSE 67797
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67751: LD_VAR 0 5
67755: PPUSH
67756: CALL_OW 314
67760: NOT
67761: PUSH
67762: LD_VAR 0 5
67766: PPUSH
67767: LD_VAR 0 14
67771: PPUSH
67772: CALL_OW 296
67776: PUSH
67777: LD_INT 30
67779: LESS
67780: AND
67781: IFFALSE 67797
// ComAttackUnit ( i , e ) ;
67783: LD_VAR 0 5
67787: PPUSH
67788: LD_VAR 0 14
67792: PPUSH
67793: CALL_OW 115
// end ; end ; end ;
67797: GO 67800
67799: POP
// if IsDead ( i ) then
67800: LD_VAR 0 5
67804: PPUSH
67805: CALL_OW 301
67809: IFFALSE 67827
// defenders := defenders diff i ;
67811: LD_ADDR_VAR 0 2
67815: PUSH
67816: LD_VAR 0 2
67820: PUSH
67821: LD_VAR 0 5
67825: DIFF
67826: ST_TO_ADDR
// end ;
67827: GO 67010
67829: POP
67830: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67831: LD_VAR 0 3
67835: NOT
67836: PUSH
67837: LD_VAR 0 2
67841: NOT
67842: OR
67843: PUSH
67844: LD_EXP 101
67848: PUSH
67849: LD_VAR 0 1
67853: ARRAY
67854: NOT
67855: OR
67856: IFFALSE 66914
// MC_Reset ( base , 18 ) ;
67858: LD_VAR 0 1
67862: PPUSH
67863: LD_INT 18
67865: PPUSH
67866: CALL 38300 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67870: LD_ADDR_VAR 0 2
67874: PUSH
67875: LD_VAR 0 2
67879: PUSH
67880: LD_VAR 0 2
67884: PPUSH
67885: LD_INT 2
67887: PUSH
67888: LD_INT 25
67890: PUSH
67891: LD_INT 1
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 25
67900: PUSH
67901: LD_INT 5
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 25
67910: PUSH
67911: LD_INT 8
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 25
67920: PUSH
67921: LD_INT 9
67923: PUSH
67924: EMPTY
67925: LIST
67926: LIST
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: PPUSH
67935: CALL_OW 72
67939: DIFF
67940: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67941: LD_VAR 0 3
67945: NOT
67946: PUSH
67947: LD_VAR 0 2
67951: PPUSH
67952: LD_INT 21
67954: PUSH
67955: LD_INT 2
67957: PUSH
67958: EMPTY
67959: LIST
67960: LIST
67961: PPUSH
67962: CALL_OW 72
67966: AND
67967: IFFALSE 68305
// begin tmp := FilterByTag ( defenders , 19 ) ;
67969: LD_ADDR_VAR 0 12
67973: PUSH
67974: LD_VAR 0 2
67978: PPUSH
67979: LD_INT 19
67981: PPUSH
67982: CALL 104784 0 2
67986: ST_TO_ADDR
// if tmp then
67987: LD_VAR 0 12
67991: IFFALSE 68061
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
67993: LD_ADDR_VAR 0 12
67997: PUSH
67998: LD_VAR 0 12
68002: PPUSH
68003: LD_INT 25
68005: PUSH
68006: LD_INT 3
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PPUSH
68013: CALL_OW 72
68017: ST_TO_ADDR
// if tmp then
68018: LD_VAR 0 12
68022: IFFALSE 68061
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68024: LD_ADDR_EXP 113
68028: PUSH
68029: LD_EXP 113
68033: PPUSH
68034: LD_VAR 0 1
68038: PPUSH
68039: LD_EXP 113
68043: PUSH
68044: LD_VAR 0 1
68048: ARRAY
68049: PUSH
68050: LD_VAR 0 12
68054: UNION
68055: PPUSH
68056: CALL_OW 1
68060: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68061: LD_VAR 0 1
68065: PPUSH
68066: LD_INT 19
68068: PPUSH
68069: CALL 38300 0 2
// repeat wait ( 0 0$1 ) ;
68073: LD_INT 35
68075: PPUSH
68076: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68080: LD_EXP 101
68084: PUSH
68085: LD_VAR 0 1
68089: ARRAY
68090: NOT
68091: PUSH
68092: LD_EXP 101
68096: PUSH
68097: LD_VAR 0 1
68101: ARRAY
68102: PUSH
68103: EMPTY
68104: EQUAL
68105: OR
68106: IFFALSE 68143
// begin for i in defenders do
68108: LD_ADDR_VAR 0 5
68112: PUSH
68113: LD_VAR 0 2
68117: PUSH
68118: FOR_IN
68119: IFFALSE 68132
// ComStop ( i ) ;
68121: LD_VAR 0 5
68125: PPUSH
68126: CALL_OW 141
68130: GO 68118
68132: POP
68133: POP
// defenders := [ ] ;
68134: LD_ADDR_VAR 0 2
68138: PUSH
68139: EMPTY
68140: ST_TO_ADDR
// exit ;
68141: GO 68329
// end ; for i in defenders do
68143: LD_ADDR_VAR 0 5
68147: PUSH
68148: LD_VAR 0 2
68152: PUSH
68153: FOR_IN
68154: IFFALSE 68243
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68156: LD_VAR 0 5
68160: PPUSH
68161: LD_EXP 125
68165: PUSH
68166: LD_VAR 0 1
68170: ARRAY
68171: PPUSH
68172: CALL_OW 308
68176: NOT
68177: IFFALSE 68201
// ComMoveToArea ( i , mc_parking [ base ] ) else
68179: LD_VAR 0 5
68183: PPUSH
68184: LD_EXP 125
68188: PUSH
68189: LD_VAR 0 1
68193: ARRAY
68194: PPUSH
68195: CALL_OW 113
68199: GO 68241
// if GetControl ( i ) = control_manual then
68201: LD_VAR 0 5
68205: PPUSH
68206: CALL_OW 263
68210: PUSH
68211: LD_INT 1
68213: EQUAL
68214: IFFALSE 68241
// if IsDrivenBy ( i ) then
68216: LD_VAR 0 5
68220: PPUSH
68221: CALL_OW 311
68225: IFFALSE 68241
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68227: LD_VAR 0 5
68231: PPUSH
68232: CALL_OW 311
68236: PPUSH
68237: CALL_OW 121
// end ;
68241: GO 68153
68243: POP
68244: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68245: LD_VAR 0 2
68249: PPUSH
68250: LD_INT 95
68252: PUSH
68253: LD_EXP 125
68257: PUSH
68258: LD_VAR 0 1
68262: ARRAY
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PPUSH
68268: CALL_OW 72
68272: PUSH
68273: LD_VAR 0 2
68277: EQUAL
68278: PUSH
68279: LD_EXP 124
68283: PUSH
68284: LD_VAR 0 1
68288: ARRAY
68289: OR
68290: PUSH
68291: LD_EXP 101
68295: PUSH
68296: LD_VAR 0 1
68300: ARRAY
68301: NOT
68302: OR
68303: IFFALSE 68073
// end ; MC_Reset ( base , 19 ) ;
68305: LD_VAR 0 1
68309: PPUSH
68310: LD_INT 19
68312: PPUSH
68313: CALL 38300 0 2
// MC_Reset ( base , 20 ) ;
68317: LD_VAR 0 1
68321: PPUSH
68322: LD_INT 20
68324: PPUSH
68325: CALL 38300 0 2
// end ;
68329: LD_VAR 0 4
68333: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68334: LD_INT 0
68336: PPUSH
68337: PPUSH
68338: PPUSH
68339: PPUSH
// result := false ;
68340: LD_ADDR_VAR 0 2
68344: PUSH
68345: LD_INT 0
68347: ST_TO_ADDR
// side := GetSide ( unit ) ;
68348: LD_ADDR_VAR 0 3
68352: PUSH
68353: LD_VAR 0 1
68357: PPUSH
68358: CALL_OW 255
68362: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68363: LD_ADDR_VAR 0 4
68367: PUSH
68368: LD_VAR 0 1
68372: PPUSH
68373: CALL_OW 248
68377: ST_TO_ADDR
// case nat of 1 :
68378: LD_VAR 0 4
68382: PUSH
68383: LD_INT 1
68385: DOUBLE
68386: EQUAL
68387: IFTRUE 68391
68389: GO 68402
68391: POP
// tech := tech_lassight ; 2 :
68392: LD_ADDR_VAR 0 5
68396: PUSH
68397: LD_INT 12
68399: ST_TO_ADDR
68400: GO 68441
68402: LD_INT 2
68404: DOUBLE
68405: EQUAL
68406: IFTRUE 68410
68408: GO 68421
68410: POP
// tech := tech_mortar ; 3 :
68411: LD_ADDR_VAR 0 5
68415: PUSH
68416: LD_INT 41
68418: ST_TO_ADDR
68419: GO 68441
68421: LD_INT 3
68423: DOUBLE
68424: EQUAL
68425: IFTRUE 68429
68427: GO 68440
68429: POP
// tech := tech_bazooka ; end ;
68430: LD_ADDR_VAR 0 5
68434: PUSH
68435: LD_INT 44
68437: ST_TO_ADDR
68438: GO 68441
68440: POP
// if Researched ( side , tech ) then
68441: LD_VAR 0 3
68445: PPUSH
68446: LD_VAR 0 5
68450: PPUSH
68451: CALL_OW 325
68455: IFFALSE 68482
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68457: LD_ADDR_VAR 0 2
68461: PUSH
68462: LD_INT 5
68464: PUSH
68465: LD_INT 8
68467: PUSH
68468: LD_INT 9
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: LIST
68475: PUSH
68476: LD_VAR 0 4
68480: ARRAY
68481: ST_TO_ADDR
// end ;
68482: LD_VAR 0 2
68486: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68487: LD_INT 0
68489: PPUSH
68490: PPUSH
68491: PPUSH
// if not mines then
68492: LD_VAR 0 2
68496: NOT
68497: IFFALSE 68501
// exit ;
68499: GO 68645
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68501: LD_ADDR_VAR 0 5
68505: PUSH
68506: LD_INT 81
68508: PUSH
68509: LD_VAR 0 1
68513: PUSH
68514: EMPTY
68515: LIST
68516: LIST
68517: PUSH
68518: LD_INT 3
68520: PUSH
68521: LD_INT 21
68523: PUSH
68524: LD_INT 3
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: PPUSH
68539: CALL_OW 69
68543: ST_TO_ADDR
// for i in mines do
68544: LD_ADDR_VAR 0 4
68548: PUSH
68549: LD_VAR 0 2
68553: PUSH
68554: FOR_IN
68555: IFFALSE 68643
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68557: LD_VAR 0 4
68561: PUSH
68562: LD_INT 1
68564: ARRAY
68565: PPUSH
68566: LD_VAR 0 4
68570: PUSH
68571: LD_INT 2
68573: ARRAY
68574: PPUSH
68575: CALL_OW 458
68579: NOT
68580: IFFALSE 68584
// continue ;
68582: GO 68554
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68584: LD_VAR 0 4
68588: PUSH
68589: LD_INT 1
68591: ARRAY
68592: PPUSH
68593: LD_VAR 0 4
68597: PUSH
68598: LD_INT 2
68600: ARRAY
68601: PPUSH
68602: CALL_OW 428
68606: PUSH
68607: LD_VAR 0 5
68611: IN
68612: IFFALSE 68641
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68614: LD_VAR 0 4
68618: PUSH
68619: LD_INT 1
68621: ARRAY
68622: PPUSH
68623: LD_VAR 0 4
68627: PUSH
68628: LD_INT 2
68630: ARRAY
68631: PPUSH
68632: LD_VAR 0 1
68636: PPUSH
68637: CALL_OW 456
// end ;
68641: GO 68554
68643: POP
68644: POP
// end ;
68645: LD_VAR 0 3
68649: RET
// export function Count ( array ) ; var i ; begin
68650: LD_INT 0
68652: PPUSH
68653: PPUSH
// result := 0 ;
68654: LD_ADDR_VAR 0 2
68658: PUSH
68659: LD_INT 0
68661: ST_TO_ADDR
// for i in array do
68662: LD_ADDR_VAR 0 3
68666: PUSH
68667: LD_VAR 0 1
68671: PUSH
68672: FOR_IN
68673: IFFALSE 68697
// if i then
68675: LD_VAR 0 3
68679: IFFALSE 68695
// result := result + 1 ;
68681: LD_ADDR_VAR 0 2
68685: PUSH
68686: LD_VAR 0 2
68690: PUSH
68691: LD_INT 1
68693: PLUS
68694: ST_TO_ADDR
68695: GO 68672
68697: POP
68698: POP
// end ;
68699: LD_VAR 0 2
68703: RET
// export function IsEmpty ( building ) ; begin
68704: LD_INT 0
68706: PPUSH
// if not building then
68707: LD_VAR 0 1
68711: NOT
68712: IFFALSE 68716
// exit ;
68714: GO 68759
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68716: LD_ADDR_VAR 0 2
68720: PUSH
68721: LD_VAR 0 1
68725: PUSH
68726: LD_INT 22
68728: PUSH
68729: LD_VAR 0 1
68733: PPUSH
68734: CALL_OW 255
68738: PUSH
68739: EMPTY
68740: LIST
68741: LIST
68742: PUSH
68743: LD_INT 58
68745: PUSH
68746: EMPTY
68747: LIST
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PPUSH
68753: CALL_OW 69
68757: IN
68758: ST_TO_ADDR
// end ;
68759: LD_VAR 0 2
68763: RET
// export function IsNotFull ( building ) ; begin
68764: LD_INT 0
68766: PPUSH
// if not building then
68767: LD_VAR 0 1
68771: NOT
68772: IFFALSE 68776
// exit ;
68774: GO 68795
// result := UnitsInside ( building ) < 6 ;
68776: LD_ADDR_VAR 0 2
68780: PUSH
68781: LD_VAR 0 1
68785: PPUSH
68786: CALL_OW 313
68790: PUSH
68791: LD_INT 6
68793: LESS
68794: ST_TO_ADDR
// end ;
68795: LD_VAR 0 2
68799: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68800: LD_INT 0
68802: PPUSH
68803: PPUSH
68804: PPUSH
68805: PPUSH
// tmp := [ ] ;
68806: LD_ADDR_VAR 0 3
68810: PUSH
68811: EMPTY
68812: ST_TO_ADDR
// list := [ ] ;
68813: LD_ADDR_VAR 0 5
68817: PUSH
68818: EMPTY
68819: ST_TO_ADDR
// for i = 16 to 25 do
68820: LD_ADDR_VAR 0 4
68824: PUSH
68825: DOUBLE
68826: LD_INT 16
68828: DEC
68829: ST_TO_ADDR
68830: LD_INT 25
68832: PUSH
68833: FOR_TO
68834: IFFALSE 68907
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68836: LD_ADDR_VAR 0 3
68840: PUSH
68841: LD_VAR 0 3
68845: PUSH
68846: LD_INT 22
68848: PUSH
68849: LD_VAR 0 1
68853: PPUSH
68854: CALL_OW 255
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 91
68865: PUSH
68866: LD_VAR 0 1
68870: PUSH
68871: LD_INT 6
68873: PUSH
68874: EMPTY
68875: LIST
68876: LIST
68877: LIST
68878: PUSH
68879: LD_INT 30
68881: PUSH
68882: LD_VAR 0 4
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: LIST
68895: PUSH
68896: EMPTY
68897: LIST
68898: PPUSH
68899: CALL_OW 69
68903: ADD
68904: ST_TO_ADDR
68905: GO 68833
68907: POP
68908: POP
// for i = 1 to tmp do
68909: LD_ADDR_VAR 0 4
68913: PUSH
68914: DOUBLE
68915: LD_INT 1
68917: DEC
68918: ST_TO_ADDR
68919: LD_VAR 0 3
68923: PUSH
68924: FOR_TO
68925: IFFALSE 69013
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68927: LD_ADDR_VAR 0 5
68931: PUSH
68932: LD_VAR 0 5
68936: PUSH
68937: LD_VAR 0 3
68941: PUSH
68942: LD_VAR 0 4
68946: ARRAY
68947: PPUSH
68948: CALL_OW 266
68952: PUSH
68953: LD_VAR 0 3
68957: PUSH
68958: LD_VAR 0 4
68962: ARRAY
68963: PPUSH
68964: CALL_OW 250
68968: PUSH
68969: LD_VAR 0 3
68973: PUSH
68974: LD_VAR 0 4
68978: ARRAY
68979: PPUSH
68980: CALL_OW 251
68984: PUSH
68985: LD_VAR 0 3
68989: PUSH
68990: LD_VAR 0 4
68994: ARRAY
68995: PPUSH
68996: CALL_OW 254
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: PUSH
69007: EMPTY
69008: LIST
69009: ADD
69010: ST_TO_ADDR
69011: GO 68924
69013: POP
69014: POP
// result := list ;
69015: LD_ADDR_VAR 0 2
69019: PUSH
69020: LD_VAR 0 5
69024: ST_TO_ADDR
// end ;
69025: LD_VAR 0 2
69029: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69030: LD_INT 0
69032: PPUSH
69033: PPUSH
69034: PPUSH
69035: PPUSH
69036: PPUSH
69037: PPUSH
69038: PPUSH
// if not factory then
69039: LD_VAR 0 1
69043: NOT
69044: IFFALSE 69048
// exit ;
69046: GO 69641
// if control = control_apeman then
69048: LD_VAR 0 4
69052: PUSH
69053: LD_INT 5
69055: EQUAL
69056: IFFALSE 69165
// begin tmp := UnitsInside ( factory ) ;
69058: LD_ADDR_VAR 0 8
69062: PUSH
69063: LD_VAR 0 1
69067: PPUSH
69068: CALL_OW 313
69072: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69073: LD_VAR 0 8
69077: PPUSH
69078: LD_INT 25
69080: PUSH
69081: LD_INT 12
69083: PUSH
69084: EMPTY
69085: LIST
69086: LIST
69087: PPUSH
69088: CALL_OW 72
69092: NOT
69093: IFFALSE 69103
// control := control_manual ;
69095: LD_ADDR_VAR 0 4
69099: PUSH
69100: LD_INT 1
69102: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69103: LD_ADDR_VAR 0 8
69107: PUSH
69108: LD_VAR 0 1
69112: PPUSH
69113: CALL 68800 0 1
69117: ST_TO_ADDR
// if tmp then
69118: LD_VAR 0 8
69122: IFFALSE 69165
// begin for i in tmp do
69124: LD_ADDR_VAR 0 7
69128: PUSH
69129: LD_VAR 0 8
69133: PUSH
69134: FOR_IN
69135: IFFALSE 69163
// if i [ 1 ] = b_ext_radio then
69137: LD_VAR 0 7
69141: PUSH
69142: LD_INT 1
69144: ARRAY
69145: PUSH
69146: LD_INT 22
69148: EQUAL
69149: IFFALSE 69161
// begin control := control_remote ;
69151: LD_ADDR_VAR 0 4
69155: PUSH
69156: LD_INT 2
69158: ST_TO_ADDR
// break ;
69159: GO 69163
// end ;
69161: GO 69134
69163: POP
69164: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69165: LD_VAR 0 1
69169: PPUSH
69170: LD_VAR 0 2
69174: PPUSH
69175: LD_VAR 0 3
69179: PPUSH
69180: LD_VAR 0 4
69184: PPUSH
69185: LD_VAR 0 5
69189: PPUSH
69190: CALL_OW 448
69194: IFFALSE 69229
// begin result := [ chassis , engine , control , weapon ] ;
69196: LD_ADDR_VAR 0 6
69200: PUSH
69201: LD_VAR 0 2
69205: PUSH
69206: LD_VAR 0 3
69210: PUSH
69211: LD_VAR 0 4
69215: PUSH
69216: LD_VAR 0 5
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: LIST
69225: LIST
69226: ST_TO_ADDR
// exit ;
69227: GO 69641
// end ; _chassis := AvailableChassisList ( factory ) ;
69229: LD_ADDR_VAR 0 9
69233: PUSH
69234: LD_VAR 0 1
69238: PPUSH
69239: CALL_OW 475
69243: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69244: LD_ADDR_VAR 0 11
69248: PUSH
69249: LD_VAR 0 1
69253: PPUSH
69254: CALL_OW 476
69258: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69259: LD_ADDR_VAR 0 12
69263: PUSH
69264: LD_VAR 0 1
69268: PPUSH
69269: CALL_OW 477
69273: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69274: LD_ADDR_VAR 0 10
69278: PUSH
69279: LD_VAR 0 1
69283: PPUSH
69284: CALL_OW 478
69288: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69289: LD_VAR 0 9
69293: NOT
69294: PUSH
69295: LD_VAR 0 11
69299: NOT
69300: OR
69301: PUSH
69302: LD_VAR 0 12
69306: NOT
69307: OR
69308: PUSH
69309: LD_VAR 0 10
69313: NOT
69314: OR
69315: IFFALSE 69350
// begin result := [ chassis , engine , control , weapon ] ;
69317: LD_ADDR_VAR 0 6
69321: PUSH
69322: LD_VAR 0 2
69326: PUSH
69327: LD_VAR 0 3
69331: PUSH
69332: LD_VAR 0 4
69336: PUSH
69337: LD_VAR 0 5
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: ST_TO_ADDR
// exit ;
69348: GO 69641
// end ; if not chassis in _chassis then
69350: LD_VAR 0 2
69354: PUSH
69355: LD_VAR 0 9
69359: IN
69360: NOT
69361: IFFALSE 69387
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69363: LD_ADDR_VAR 0 2
69367: PUSH
69368: LD_VAR 0 9
69372: PUSH
69373: LD_INT 1
69375: PPUSH
69376: LD_VAR 0 9
69380: PPUSH
69381: CALL_OW 12
69385: ARRAY
69386: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69387: LD_VAR 0 2
69391: PPUSH
69392: LD_VAR 0 3
69396: PPUSH
69397: CALL 69646 0 2
69401: NOT
69402: IFFALSE 69461
// repeat engine := _engine [ 1 ] ;
69404: LD_ADDR_VAR 0 3
69408: PUSH
69409: LD_VAR 0 11
69413: PUSH
69414: LD_INT 1
69416: ARRAY
69417: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69418: LD_ADDR_VAR 0 11
69422: PUSH
69423: LD_VAR 0 11
69427: PPUSH
69428: LD_INT 1
69430: PPUSH
69431: CALL_OW 3
69435: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69436: LD_VAR 0 2
69440: PPUSH
69441: LD_VAR 0 3
69445: PPUSH
69446: CALL 69646 0 2
69450: PUSH
69451: LD_VAR 0 11
69455: PUSH
69456: EMPTY
69457: EQUAL
69458: OR
69459: IFFALSE 69404
// if not control in _control then
69461: LD_VAR 0 4
69465: PUSH
69466: LD_VAR 0 12
69470: IN
69471: NOT
69472: IFFALSE 69498
// control := _control [ rand ( 1 , _control ) ] ;
69474: LD_ADDR_VAR 0 4
69478: PUSH
69479: LD_VAR 0 12
69483: PUSH
69484: LD_INT 1
69486: PPUSH
69487: LD_VAR 0 12
69491: PPUSH
69492: CALL_OW 12
69496: ARRAY
69497: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69498: LD_VAR 0 2
69502: PPUSH
69503: LD_VAR 0 5
69507: PPUSH
69508: CALL 69866 0 2
69512: NOT
69513: IFFALSE 69572
// repeat weapon := _weapon [ 1 ] ;
69515: LD_ADDR_VAR 0 5
69519: PUSH
69520: LD_VAR 0 10
69524: PUSH
69525: LD_INT 1
69527: ARRAY
69528: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69529: LD_ADDR_VAR 0 10
69533: PUSH
69534: LD_VAR 0 10
69538: PPUSH
69539: LD_INT 1
69541: PPUSH
69542: CALL_OW 3
69546: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69547: LD_VAR 0 2
69551: PPUSH
69552: LD_VAR 0 5
69556: PPUSH
69557: CALL 69866 0 2
69561: PUSH
69562: LD_VAR 0 10
69566: PUSH
69567: EMPTY
69568: EQUAL
69569: OR
69570: IFFALSE 69515
// result := [ ] ;
69572: LD_ADDR_VAR 0 6
69576: PUSH
69577: EMPTY
69578: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69579: LD_VAR 0 1
69583: PPUSH
69584: LD_VAR 0 2
69588: PPUSH
69589: LD_VAR 0 3
69593: PPUSH
69594: LD_VAR 0 4
69598: PPUSH
69599: LD_VAR 0 5
69603: PPUSH
69604: CALL_OW 448
69608: IFFALSE 69641
// result := [ chassis , engine , control , weapon ] ;
69610: LD_ADDR_VAR 0 6
69614: PUSH
69615: LD_VAR 0 2
69619: PUSH
69620: LD_VAR 0 3
69624: PUSH
69625: LD_VAR 0 4
69629: PUSH
69630: LD_VAR 0 5
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: ST_TO_ADDR
// end ;
69641: LD_VAR 0 6
69645: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69646: LD_INT 0
69648: PPUSH
// if not chassis or not engine then
69649: LD_VAR 0 1
69653: NOT
69654: PUSH
69655: LD_VAR 0 2
69659: NOT
69660: OR
69661: IFFALSE 69665
// exit ;
69663: GO 69861
// case engine of engine_solar :
69665: LD_VAR 0 2
69669: PUSH
69670: LD_INT 2
69672: DOUBLE
69673: EQUAL
69674: IFTRUE 69678
69676: GO 69716
69678: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69679: LD_ADDR_VAR 0 3
69683: PUSH
69684: LD_INT 11
69686: PUSH
69687: LD_INT 12
69689: PUSH
69690: LD_INT 13
69692: PUSH
69693: LD_INT 14
69695: PUSH
69696: LD_INT 1
69698: PUSH
69699: LD_INT 2
69701: PUSH
69702: LD_INT 3
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: ST_TO_ADDR
69714: GO 69845
69716: LD_INT 1
69718: DOUBLE
69719: EQUAL
69720: IFTRUE 69724
69722: GO 69786
69724: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69725: LD_ADDR_VAR 0 3
69729: PUSH
69730: LD_INT 11
69732: PUSH
69733: LD_INT 12
69735: PUSH
69736: LD_INT 13
69738: PUSH
69739: LD_INT 14
69741: PUSH
69742: LD_INT 1
69744: PUSH
69745: LD_INT 2
69747: PUSH
69748: LD_INT 3
69750: PUSH
69751: LD_INT 4
69753: PUSH
69754: LD_INT 5
69756: PUSH
69757: LD_INT 21
69759: PUSH
69760: LD_INT 23
69762: PUSH
69763: LD_INT 22
69765: PUSH
69766: LD_INT 24
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: LIST
69773: LIST
69774: LIST
69775: LIST
69776: LIST
69777: LIST
69778: LIST
69779: LIST
69780: LIST
69781: LIST
69782: LIST
69783: ST_TO_ADDR
69784: GO 69845
69786: LD_INT 3
69788: DOUBLE
69789: EQUAL
69790: IFTRUE 69794
69792: GO 69844
69794: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69795: LD_ADDR_VAR 0 3
69799: PUSH
69800: LD_INT 13
69802: PUSH
69803: LD_INT 14
69805: PUSH
69806: LD_INT 2
69808: PUSH
69809: LD_INT 3
69811: PUSH
69812: LD_INT 4
69814: PUSH
69815: LD_INT 5
69817: PUSH
69818: LD_INT 21
69820: PUSH
69821: LD_INT 22
69823: PUSH
69824: LD_INT 23
69826: PUSH
69827: LD_INT 24
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: LIST
69834: LIST
69835: LIST
69836: LIST
69837: LIST
69838: LIST
69839: LIST
69840: LIST
69841: ST_TO_ADDR
69842: GO 69845
69844: POP
// result := ( chassis in result ) ;
69845: LD_ADDR_VAR 0 3
69849: PUSH
69850: LD_VAR 0 1
69854: PUSH
69855: LD_VAR 0 3
69859: IN
69860: ST_TO_ADDR
// end ;
69861: LD_VAR 0 3
69865: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69866: LD_INT 0
69868: PPUSH
// if not chassis or not weapon then
69869: LD_VAR 0 1
69873: NOT
69874: PUSH
69875: LD_VAR 0 2
69879: NOT
69880: OR
69881: IFFALSE 69885
// exit ;
69883: GO 70911
// case weapon of us_machine_gun :
69885: LD_VAR 0 2
69889: PUSH
69890: LD_INT 2
69892: DOUBLE
69893: EQUAL
69894: IFTRUE 69898
69896: GO 69928
69898: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69899: LD_ADDR_VAR 0 3
69903: PUSH
69904: LD_INT 1
69906: PUSH
69907: LD_INT 2
69909: PUSH
69910: LD_INT 3
69912: PUSH
69913: LD_INT 4
69915: PUSH
69916: LD_INT 5
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: LIST
69923: LIST
69924: LIST
69925: ST_TO_ADDR
69926: GO 70895
69928: LD_INT 3
69930: DOUBLE
69931: EQUAL
69932: IFTRUE 69936
69934: GO 69966
69936: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69937: LD_ADDR_VAR 0 3
69941: PUSH
69942: LD_INT 1
69944: PUSH
69945: LD_INT 2
69947: PUSH
69948: LD_INT 3
69950: PUSH
69951: LD_INT 4
69953: PUSH
69954: LD_INT 5
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: ST_TO_ADDR
69964: GO 70895
69966: LD_INT 11
69968: DOUBLE
69969: EQUAL
69970: IFTRUE 69974
69972: GO 70004
69974: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69975: LD_ADDR_VAR 0 3
69979: PUSH
69980: LD_INT 1
69982: PUSH
69983: LD_INT 2
69985: PUSH
69986: LD_INT 3
69988: PUSH
69989: LD_INT 4
69991: PUSH
69992: LD_INT 5
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: LIST
69999: LIST
70000: LIST
70001: ST_TO_ADDR
70002: GO 70895
70004: LD_INT 4
70006: DOUBLE
70007: EQUAL
70008: IFTRUE 70012
70010: GO 70038
70012: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70013: LD_ADDR_VAR 0 3
70017: PUSH
70018: LD_INT 2
70020: PUSH
70021: LD_INT 3
70023: PUSH
70024: LD_INT 4
70026: PUSH
70027: LD_INT 5
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: LIST
70034: LIST
70035: ST_TO_ADDR
70036: GO 70895
70038: LD_INT 5
70040: DOUBLE
70041: EQUAL
70042: IFTRUE 70046
70044: GO 70072
70046: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70047: LD_ADDR_VAR 0 3
70051: PUSH
70052: LD_INT 2
70054: PUSH
70055: LD_INT 3
70057: PUSH
70058: LD_INT 4
70060: PUSH
70061: LD_INT 5
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: LIST
70068: LIST
70069: ST_TO_ADDR
70070: GO 70895
70072: LD_INT 9
70074: DOUBLE
70075: EQUAL
70076: IFTRUE 70080
70078: GO 70106
70080: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70081: LD_ADDR_VAR 0 3
70085: PUSH
70086: LD_INT 2
70088: PUSH
70089: LD_INT 3
70091: PUSH
70092: LD_INT 4
70094: PUSH
70095: LD_INT 5
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: ST_TO_ADDR
70104: GO 70895
70106: LD_INT 7
70108: DOUBLE
70109: EQUAL
70110: IFTRUE 70114
70112: GO 70140
70114: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70115: LD_ADDR_VAR 0 3
70119: PUSH
70120: LD_INT 2
70122: PUSH
70123: LD_INT 3
70125: PUSH
70126: LD_INT 4
70128: PUSH
70129: LD_INT 5
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: LIST
70136: LIST
70137: ST_TO_ADDR
70138: GO 70895
70140: LD_INT 12
70142: DOUBLE
70143: EQUAL
70144: IFTRUE 70148
70146: GO 70174
70148: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70149: LD_ADDR_VAR 0 3
70153: PUSH
70154: LD_INT 2
70156: PUSH
70157: LD_INT 3
70159: PUSH
70160: LD_INT 4
70162: PUSH
70163: LD_INT 5
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: LIST
70170: LIST
70171: ST_TO_ADDR
70172: GO 70895
70174: LD_INT 13
70176: DOUBLE
70177: EQUAL
70178: IFTRUE 70182
70180: GO 70208
70182: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70183: LD_ADDR_VAR 0 3
70187: PUSH
70188: LD_INT 2
70190: PUSH
70191: LD_INT 3
70193: PUSH
70194: LD_INT 4
70196: PUSH
70197: LD_INT 5
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: ST_TO_ADDR
70206: GO 70895
70208: LD_INT 14
70210: DOUBLE
70211: EQUAL
70212: IFTRUE 70216
70214: GO 70234
70216: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70217: LD_ADDR_VAR 0 3
70221: PUSH
70222: LD_INT 4
70224: PUSH
70225: LD_INT 5
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: ST_TO_ADDR
70232: GO 70895
70234: LD_INT 6
70236: DOUBLE
70237: EQUAL
70238: IFTRUE 70242
70240: GO 70260
70242: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70243: LD_ADDR_VAR 0 3
70247: PUSH
70248: LD_INT 4
70250: PUSH
70251: LD_INT 5
70253: PUSH
70254: EMPTY
70255: LIST
70256: LIST
70257: ST_TO_ADDR
70258: GO 70895
70260: LD_INT 10
70262: DOUBLE
70263: EQUAL
70264: IFTRUE 70268
70266: GO 70286
70268: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70269: LD_ADDR_VAR 0 3
70273: PUSH
70274: LD_INT 4
70276: PUSH
70277: LD_INT 5
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: ST_TO_ADDR
70284: GO 70895
70286: LD_INT 22
70288: DOUBLE
70289: EQUAL
70290: IFTRUE 70294
70292: GO 70320
70294: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70295: LD_ADDR_VAR 0 3
70299: PUSH
70300: LD_INT 11
70302: PUSH
70303: LD_INT 12
70305: PUSH
70306: LD_INT 13
70308: PUSH
70309: LD_INT 14
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: ST_TO_ADDR
70318: GO 70895
70320: LD_INT 23
70322: DOUBLE
70323: EQUAL
70324: IFTRUE 70328
70326: GO 70354
70328: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70329: LD_ADDR_VAR 0 3
70333: PUSH
70334: LD_INT 11
70336: PUSH
70337: LD_INT 12
70339: PUSH
70340: LD_INT 13
70342: PUSH
70343: LD_INT 14
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: LIST
70350: LIST
70351: ST_TO_ADDR
70352: GO 70895
70354: LD_INT 24
70356: DOUBLE
70357: EQUAL
70358: IFTRUE 70362
70360: GO 70388
70362: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70363: LD_ADDR_VAR 0 3
70367: PUSH
70368: LD_INT 11
70370: PUSH
70371: LD_INT 12
70373: PUSH
70374: LD_INT 13
70376: PUSH
70377: LD_INT 14
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: LIST
70384: LIST
70385: ST_TO_ADDR
70386: GO 70895
70388: LD_INT 30
70390: DOUBLE
70391: EQUAL
70392: IFTRUE 70396
70394: GO 70422
70396: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70397: LD_ADDR_VAR 0 3
70401: PUSH
70402: LD_INT 11
70404: PUSH
70405: LD_INT 12
70407: PUSH
70408: LD_INT 13
70410: PUSH
70411: LD_INT 14
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: ST_TO_ADDR
70420: GO 70895
70422: LD_INT 25
70424: DOUBLE
70425: EQUAL
70426: IFTRUE 70430
70428: GO 70448
70430: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70431: LD_ADDR_VAR 0 3
70435: PUSH
70436: LD_INT 13
70438: PUSH
70439: LD_INT 14
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: ST_TO_ADDR
70446: GO 70895
70448: LD_INT 27
70450: DOUBLE
70451: EQUAL
70452: IFTRUE 70456
70454: GO 70474
70456: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70457: LD_ADDR_VAR 0 3
70461: PUSH
70462: LD_INT 13
70464: PUSH
70465: LD_INT 14
70467: PUSH
70468: EMPTY
70469: LIST
70470: LIST
70471: ST_TO_ADDR
70472: GO 70895
70474: LD_INT 28
70476: DOUBLE
70477: EQUAL
70478: IFTRUE 70482
70480: GO 70500
70482: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70483: LD_ADDR_VAR 0 3
70487: PUSH
70488: LD_INT 13
70490: PUSH
70491: LD_INT 14
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: ST_TO_ADDR
70498: GO 70895
70500: LD_INT 29
70502: DOUBLE
70503: EQUAL
70504: IFTRUE 70508
70506: GO 70526
70508: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70509: LD_ADDR_VAR 0 3
70513: PUSH
70514: LD_INT 13
70516: PUSH
70517: LD_INT 14
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: ST_TO_ADDR
70524: GO 70895
70526: LD_INT 31
70528: DOUBLE
70529: EQUAL
70530: IFTRUE 70534
70532: GO 70552
70534: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70535: LD_ADDR_VAR 0 3
70539: PUSH
70540: LD_INT 13
70542: PUSH
70543: LD_INT 14
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: ST_TO_ADDR
70550: GO 70895
70552: LD_INT 26
70554: DOUBLE
70555: EQUAL
70556: IFTRUE 70560
70558: GO 70578
70560: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70561: LD_ADDR_VAR 0 3
70565: PUSH
70566: LD_INT 13
70568: PUSH
70569: LD_INT 14
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: ST_TO_ADDR
70576: GO 70895
70578: LD_INT 42
70580: DOUBLE
70581: EQUAL
70582: IFTRUE 70586
70584: GO 70612
70586: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70587: LD_ADDR_VAR 0 3
70591: PUSH
70592: LD_INT 21
70594: PUSH
70595: LD_INT 22
70597: PUSH
70598: LD_INT 23
70600: PUSH
70601: LD_INT 24
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: LIST
70608: LIST
70609: ST_TO_ADDR
70610: GO 70895
70612: LD_INT 43
70614: DOUBLE
70615: EQUAL
70616: IFTRUE 70620
70618: GO 70646
70620: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70621: LD_ADDR_VAR 0 3
70625: PUSH
70626: LD_INT 21
70628: PUSH
70629: LD_INT 22
70631: PUSH
70632: LD_INT 23
70634: PUSH
70635: LD_INT 24
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: ST_TO_ADDR
70644: GO 70895
70646: LD_INT 44
70648: DOUBLE
70649: EQUAL
70650: IFTRUE 70654
70652: GO 70680
70654: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70655: LD_ADDR_VAR 0 3
70659: PUSH
70660: LD_INT 21
70662: PUSH
70663: LD_INT 22
70665: PUSH
70666: LD_INT 23
70668: PUSH
70669: LD_INT 24
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: ST_TO_ADDR
70678: GO 70895
70680: LD_INT 45
70682: DOUBLE
70683: EQUAL
70684: IFTRUE 70688
70686: GO 70714
70688: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70689: LD_ADDR_VAR 0 3
70693: PUSH
70694: LD_INT 21
70696: PUSH
70697: LD_INT 22
70699: PUSH
70700: LD_INT 23
70702: PUSH
70703: LD_INT 24
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: ST_TO_ADDR
70712: GO 70895
70714: LD_INT 49
70716: DOUBLE
70717: EQUAL
70718: IFTRUE 70722
70720: GO 70748
70722: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70723: LD_ADDR_VAR 0 3
70727: PUSH
70728: LD_INT 21
70730: PUSH
70731: LD_INT 22
70733: PUSH
70734: LD_INT 23
70736: PUSH
70737: LD_INT 24
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: ST_TO_ADDR
70746: GO 70895
70748: LD_INT 51
70750: DOUBLE
70751: EQUAL
70752: IFTRUE 70756
70754: GO 70782
70756: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70757: LD_ADDR_VAR 0 3
70761: PUSH
70762: LD_INT 21
70764: PUSH
70765: LD_INT 22
70767: PUSH
70768: LD_INT 23
70770: PUSH
70771: LD_INT 24
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: ST_TO_ADDR
70780: GO 70895
70782: LD_INT 52
70784: DOUBLE
70785: EQUAL
70786: IFTRUE 70790
70788: GO 70816
70790: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70791: LD_ADDR_VAR 0 3
70795: PUSH
70796: LD_INT 21
70798: PUSH
70799: LD_INT 22
70801: PUSH
70802: LD_INT 23
70804: PUSH
70805: LD_INT 24
70807: PUSH
70808: EMPTY
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: ST_TO_ADDR
70814: GO 70895
70816: LD_INT 53
70818: DOUBLE
70819: EQUAL
70820: IFTRUE 70824
70822: GO 70842
70824: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70825: LD_ADDR_VAR 0 3
70829: PUSH
70830: LD_INT 23
70832: PUSH
70833: LD_INT 24
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: ST_TO_ADDR
70840: GO 70895
70842: LD_INT 46
70844: DOUBLE
70845: EQUAL
70846: IFTRUE 70850
70848: GO 70868
70850: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70851: LD_ADDR_VAR 0 3
70855: PUSH
70856: LD_INT 23
70858: PUSH
70859: LD_INT 24
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: ST_TO_ADDR
70866: GO 70895
70868: LD_INT 47
70870: DOUBLE
70871: EQUAL
70872: IFTRUE 70876
70874: GO 70894
70876: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70877: LD_ADDR_VAR 0 3
70881: PUSH
70882: LD_INT 23
70884: PUSH
70885: LD_INT 24
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: ST_TO_ADDR
70892: GO 70895
70894: POP
// result := ( chassis in result ) ;
70895: LD_ADDR_VAR 0 3
70899: PUSH
70900: LD_VAR 0 1
70904: PUSH
70905: LD_VAR 0 3
70909: IN
70910: ST_TO_ADDR
// end ;
70911: LD_VAR 0 3
70915: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70916: LD_INT 0
70918: PPUSH
70919: PPUSH
70920: PPUSH
70921: PPUSH
70922: PPUSH
70923: PPUSH
70924: PPUSH
// result := array ;
70925: LD_ADDR_VAR 0 5
70929: PUSH
70930: LD_VAR 0 1
70934: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70935: LD_VAR 0 1
70939: NOT
70940: PUSH
70941: LD_VAR 0 2
70945: NOT
70946: OR
70947: PUSH
70948: LD_VAR 0 3
70952: NOT
70953: OR
70954: PUSH
70955: LD_VAR 0 2
70959: PUSH
70960: LD_VAR 0 1
70964: GREATER
70965: OR
70966: PUSH
70967: LD_VAR 0 3
70971: PUSH
70972: LD_VAR 0 1
70976: GREATER
70977: OR
70978: IFFALSE 70982
// exit ;
70980: GO 71278
// if direction then
70982: LD_VAR 0 4
70986: IFFALSE 71050
// begin d := 1 ;
70988: LD_ADDR_VAR 0 9
70992: PUSH
70993: LD_INT 1
70995: ST_TO_ADDR
// if i_from > i_to then
70996: LD_VAR 0 2
71000: PUSH
71001: LD_VAR 0 3
71005: GREATER
71006: IFFALSE 71032
// length := ( array - i_from ) + i_to else
71008: LD_ADDR_VAR 0 11
71012: PUSH
71013: LD_VAR 0 1
71017: PUSH
71018: LD_VAR 0 2
71022: MINUS
71023: PUSH
71024: LD_VAR 0 3
71028: PLUS
71029: ST_TO_ADDR
71030: GO 71048
// length := i_to - i_from ;
71032: LD_ADDR_VAR 0 11
71036: PUSH
71037: LD_VAR 0 3
71041: PUSH
71042: LD_VAR 0 2
71046: MINUS
71047: ST_TO_ADDR
// end else
71048: GO 71111
// begin d := - 1 ;
71050: LD_ADDR_VAR 0 9
71054: PUSH
71055: LD_INT 1
71057: NEG
71058: ST_TO_ADDR
// if i_from > i_to then
71059: LD_VAR 0 2
71063: PUSH
71064: LD_VAR 0 3
71068: GREATER
71069: IFFALSE 71089
// length := i_from - i_to else
71071: LD_ADDR_VAR 0 11
71075: PUSH
71076: LD_VAR 0 2
71080: PUSH
71081: LD_VAR 0 3
71085: MINUS
71086: ST_TO_ADDR
71087: GO 71111
// length := ( array - i_to ) + i_from ;
71089: LD_ADDR_VAR 0 11
71093: PUSH
71094: LD_VAR 0 1
71098: PUSH
71099: LD_VAR 0 3
71103: MINUS
71104: PUSH
71105: LD_VAR 0 2
71109: PLUS
71110: ST_TO_ADDR
// end ; if not length then
71111: LD_VAR 0 11
71115: NOT
71116: IFFALSE 71120
// exit ;
71118: GO 71278
// tmp := array ;
71120: LD_ADDR_VAR 0 10
71124: PUSH
71125: LD_VAR 0 1
71129: ST_TO_ADDR
// for i = 1 to length do
71130: LD_ADDR_VAR 0 6
71134: PUSH
71135: DOUBLE
71136: LD_INT 1
71138: DEC
71139: ST_TO_ADDR
71140: LD_VAR 0 11
71144: PUSH
71145: FOR_TO
71146: IFFALSE 71266
// begin for j = 1 to array do
71148: LD_ADDR_VAR 0 7
71152: PUSH
71153: DOUBLE
71154: LD_INT 1
71156: DEC
71157: ST_TO_ADDR
71158: LD_VAR 0 1
71162: PUSH
71163: FOR_TO
71164: IFFALSE 71252
// begin k := j + d ;
71166: LD_ADDR_VAR 0 8
71170: PUSH
71171: LD_VAR 0 7
71175: PUSH
71176: LD_VAR 0 9
71180: PLUS
71181: ST_TO_ADDR
// if k > array then
71182: LD_VAR 0 8
71186: PUSH
71187: LD_VAR 0 1
71191: GREATER
71192: IFFALSE 71202
// k := 1 ;
71194: LD_ADDR_VAR 0 8
71198: PUSH
71199: LD_INT 1
71201: ST_TO_ADDR
// if not k then
71202: LD_VAR 0 8
71206: NOT
71207: IFFALSE 71219
// k := array ;
71209: LD_ADDR_VAR 0 8
71213: PUSH
71214: LD_VAR 0 1
71218: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71219: LD_ADDR_VAR 0 10
71223: PUSH
71224: LD_VAR 0 10
71228: PPUSH
71229: LD_VAR 0 8
71233: PPUSH
71234: LD_VAR 0 1
71238: PUSH
71239: LD_VAR 0 7
71243: ARRAY
71244: PPUSH
71245: CALL_OW 1
71249: ST_TO_ADDR
// end ;
71250: GO 71163
71252: POP
71253: POP
// array := tmp ;
71254: LD_ADDR_VAR 0 1
71258: PUSH
71259: LD_VAR 0 10
71263: ST_TO_ADDR
// end ;
71264: GO 71145
71266: POP
71267: POP
// result := array ;
71268: LD_ADDR_VAR 0 5
71272: PUSH
71273: LD_VAR 0 1
71277: ST_TO_ADDR
// end ;
71278: LD_VAR 0 5
71282: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71283: LD_INT 0
71285: PPUSH
71286: PPUSH
// result := 0 ;
71287: LD_ADDR_VAR 0 3
71291: PUSH
71292: LD_INT 0
71294: ST_TO_ADDR
// if not array or not value in array then
71295: LD_VAR 0 1
71299: NOT
71300: PUSH
71301: LD_VAR 0 2
71305: PUSH
71306: LD_VAR 0 1
71310: IN
71311: NOT
71312: OR
71313: IFFALSE 71317
// exit ;
71315: GO 71371
// for i = 1 to array do
71317: LD_ADDR_VAR 0 4
71321: PUSH
71322: DOUBLE
71323: LD_INT 1
71325: DEC
71326: ST_TO_ADDR
71327: LD_VAR 0 1
71331: PUSH
71332: FOR_TO
71333: IFFALSE 71369
// if value = array [ i ] then
71335: LD_VAR 0 2
71339: PUSH
71340: LD_VAR 0 1
71344: PUSH
71345: LD_VAR 0 4
71349: ARRAY
71350: EQUAL
71351: IFFALSE 71367
// begin result := i ;
71353: LD_ADDR_VAR 0 3
71357: PUSH
71358: LD_VAR 0 4
71362: ST_TO_ADDR
// exit ;
71363: POP
71364: POP
71365: GO 71371
// end ;
71367: GO 71332
71369: POP
71370: POP
// end ;
71371: LD_VAR 0 3
71375: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71376: LD_INT 0
71378: PPUSH
// vc_chassis := chassis ;
71379: LD_ADDR_OWVAR 37
71383: PUSH
71384: LD_VAR 0 1
71388: ST_TO_ADDR
// vc_engine := engine ;
71389: LD_ADDR_OWVAR 39
71393: PUSH
71394: LD_VAR 0 2
71398: ST_TO_ADDR
// vc_control := control ;
71399: LD_ADDR_OWVAR 38
71403: PUSH
71404: LD_VAR 0 3
71408: ST_TO_ADDR
// vc_weapon := weapon ;
71409: LD_ADDR_OWVAR 40
71413: PUSH
71414: LD_VAR 0 4
71418: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71419: LD_ADDR_OWVAR 41
71423: PUSH
71424: LD_VAR 0 5
71428: ST_TO_ADDR
// end ;
71429: LD_VAR 0 6
71433: RET
// export function WantPlant ( unit ) ; var task ; begin
71434: LD_INT 0
71436: PPUSH
71437: PPUSH
// result := false ;
71438: LD_ADDR_VAR 0 2
71442: PUSH
71443: LD_INT 0
71445: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71446: LD_ADDR_VAR 0 3
71450: PUSH
71451: LD_VAR 0 1
71455: PPUSH
71456: CALL_OW 437
71460: ST_TO_ADDR
// if task then
71461: LD_VAR 0 3
71465: IFFALSE 71493
// if task [ 1 ] [ 1 ] = p then
71467: LD_VAR 0 3
71471: PUSH
71472: LD_INT 1
71474: ARRAY
71475: PUSH
71476: LD_INT 1
71478: ARRAY
71479: PUSH
71480: LD_STRING p
71482: EQUAL
71483: IFFALSE 71493
// result := true ;
71485: LD_ADDR_VAR 0 2
71489: PUSH
71490: LD_INT 1
71492: ST_TO_ADDR
// end ;
71493: LD_VAR 0 2
71497: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71498: LD_INT 0
71500: PPUSH
71501: PPUSH
71502: PPUSH
71503: PPUSH
// if pos < 1 then
71504: LD_VAR 0 2
71508: PUSH
71509: LD_INT 1
71511: LESS
71512: IFFALSE 71516
// exit ;
71514: GO 71819
// if pos = 1 then
71516: LD_VAR 0 2
71520: PUSH
71521: LD_INT 1
71523: EQUAL
71524: IFFALSE 71557
// result := Replace ( arr , pos [ 1 ] , value ) else
71526: LD_ADDR_VAR 0 4
71530: PUSH
71531: LD_VAR 0 1
71535: PPUSH
71536: LD_VAR 0 2
71540: PUSH
71541: LD_INT 1
71543: ARRAY
71544: PPUSH
71545: LD_VAR 0 3
71549: PPUSH
71550: CALL_OW 1
71554: ST_TO_ADDR
71555: GO 71819
// begin tmp := arr ;
71557: LD_ADDR_VAR 0 6
71561: PUSH
71562: LD_VAR 0 1
71566: ST_TO_ADDR
// s_arr := [ tmp ] ;
71567: LD_ADDR_VAR 0 7
71571: PUSH
71572: LD_VAR 0 6
71576: PUSH
71577: EMPTY
71578: LIST
71579: ST_TO_ADDR
// for i = 1 to pos - 1 do
71580: LD_ADDR_VAR 0 5
71584: PUSH
71585: DOUBLE
71586: LD_INT 1
71588: DEC
71589: ST_TO_ADDR
71590: LD_VAR 0 2
71594: PUSH
71595: LD_INT 1
71597: MINUS
71598: PUSH
71599: FOR_TO
71600: IFFALSE 71645
// begin tmp := tmp [ pos [ i ] ] ;
71602: LD_ADDR_VAR 0 6
71606: PUSH
71607: LD_VAR 0 6
71611: PUSH
71612: LD_VAR 0 2
71616: PUSH
71617: LD_VAR 0 5
71621: ARRAY
71622: ARRAY
71623: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71624: LD_ADDR_VAR 0 7
71628: PUSH
71629: LD_VAR 0 7
71633: PUSH
71634: LD_VAR 0 6
71638: PUSH
71639: EMPTY
71640: LIST
71641: ADD
71642: ST_TO_ADDR
// end ;
71643: GO 71599
71645: POP
71646: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71647: LD_ADDR_VAR 0 6
71651: PUSH
71652: LD_VAR 0 6
71656: PPUSH
71657: LD_VAR 0 2
71661: PUSH
71662: LD_VAR 0 2
71666: ARRAY
71667: PPUSH
71668: LD_VAR 0 3
71672: PPUSH
71673: CALL_OW 1
71677: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71678: LD_ADDR_VAR 0 7
71682: PUSH
71683: LD_VAR 0 7
71687: PPUSH
71688: LD_VAR 0 7
71692: PPUSH
71693: LD_VAR 0 6
71697: PPUSH
71698: CALL_OW 1
71702: ST_TO_ADDR
// for i = s_arr downto 2 do
71703: LD_ADDR_VAR 0 5
71707: PUSH
71708: DOUBLE
71709: LD_VAR 0 7
71713: INC
71714: ST_TO_ADDR
71715: LD_INT 2
71717: PUSH
71718: FOR_DOWNTO
71719: IFFALSE 71803
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71721: LD_ADDR_VAR 0 6
71725: PUSH
71726: LD_VAR 0 7
71730: PUSH
71731: LD_VAR 0 5
71735: PUSH
71736: LD_INT 1
71738: MINUS
71739: ARRAY
71740: PPUSH
71741: LD_VAR 0 2
71745: PUSH
71746: LD_VAR 0 5
71750: PUSH
71751: LD_INT 1
71753: MINUS
71754: ARRAY
71755: PPUSH
71756: LD_VAR 0 7
71760: PUSH
71761: LD_VAR 0 5
71765: ARRAY
71766: PPUSH
71767: CALL_OW 1
71771: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71772: LD_ADDR_VAR 0 7
71776: PUSH
71777: LD_VAR 0 7
71781: PPUSH
71782: LD_VAR 0 5
71786: PUSH
71787: LD_INT 1
71789: MINUS
71790: PPUSH
71791: LD_VAR 0 6
71795: PPUSH
71796: CALL_OW 1
71800: ST_TO_ADDR
// end ;
71801: GO 71718
71803: POP
71804: POP
// result := s_arr [ 1 ] ;
71805: LD_ADDR_VAR 0 4
71809: PUSH
71810: LD_VAR 0 7
71814: PUSH
71815: LD_INT 1
71817: ARRAY
71818: ST_TO_ADDR
// end ; end ;
71819: LD_VAR 0 4
71823: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71824: LD_INT 0
71826: PPUSH
71827: PPUSH
// if not list then
71828: LD_VAR 0 1
71832: NOT
71833: IFFALSE 71837
// exit ;
71835: GO 71928
// i := list [ pos1 ] ;
71837: LD_ADDR_VAR 0 5
71841: PUSH
71842: LD_VAR 0 1
71846: PUSH
71847: LD_VAR 0 2
71851: ARRAY
71852: ST_TO_ADDR
// if not i then
71853: LD_VAR 0 5
71857: NOT
71858: IFFALSE 71862
// exit ;
71860: GO 71928
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71862: LD_ADDR_VAR 0 1
71866: PUSH
71867: LD_VAR 0 1
71871: PPUSH
71872: LD_VAR 0 2
71876: PPUSH
71877: LD_VAR 0 1
71881: PUSH
71882: LD_VAR 0 3
71886: ARRAY
71887: PPUSH
71888: CALL_OW 1
71892: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71893: LD_ADDR_VAR 0 1
71897: PUSH
71898: LD_VAR 0 1
71902: PPUSH
71903: LD_VAR 0 3
71907: PPUSH
71908: LD_VAR 0 5
71912: PPUSH
71913: CALL_OW 1
71917: ST_TO_ADDR
// result := list ;
71918: LD_ADDR_VAR 0 4
71922: PUSH
71923: LD_VAR 0 1
71927: ST_TO_ADDR
// end ;
71928: LD_VAR 0 4
71932: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71933: LD_INT 0
71935: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71936: LD_ADDR_VAR 0 5
71940: PUSH
71941: LD_VAR 0 1
71945: PPUSH
71946: CALL_OW 250
71950: PPUSH
71951: LD_VAR 0 1
71955: PPUSH
71956: CALL_OW 251
71960: PPUSH
71961: LD_VAR 0 2
71965: PPUSH
71966: LD_VAR 0 3
71970: PPUSH
71971: LD_VAR 0 4
71975: PPUSH
71976: CALL 71986 0 5
71980: ST_TO_ADDR
// end ;
71981: LD_VAR 0 5
71985: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71986: LD_INT 0
71988: PPUSH
71989: PPUSH
71990: PPUSH
71991: PPUSH
// if not list then
71992: LD_VAR 0 3
71996: NOT
71997: IFFALSE 72001
// exit ;
71999: GO 72389
// result := [ ] ;
72001: LD_ADDR_VAR 0 6
72005: PUSH
72006: EMPTY
72007: ST_TO_ADDR
// for i in list do
72008: LD_ADDR_VAR 0 7
72012: PUSH
72013: LD_VAR 0 3
72017: PUSH
72018: FOR_IN
72019: IFFALSE 72221
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72021: LD_ADDR_VAR 0 9
72025: PUSH
72026: LD_VAR 0 7
72030: PPUSH
72031: LD_VAR 0 1
72035: PPUSH
72036: LD_VAR 0 2
72040: PPUSH
72041: CALL_OW 297
72045: ST_TO_ADDR
// if not result then
72046: LD_VAR 0 6
72050: NOT
72051: IFFALSE 72077
// result := [ [ i , tmp ] ] else
72053: LD_ADDR_VAR 0 6
72057: PUSH
72058: LD_VAR 0 7
72062: PUSH
72063: LD_VAR 0 9
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: EMPTY
72073: LIST
72074: ST_TO_ADDR
72075: GO 72219
// begin if result [ result ] [ 2 ] < tmp then
72077: LD_VAR 0 6
72081: PUSH
72082: LD_VAR 0 6
72086: ARRAY
72087: PUSH
72088: LD_INT 2
72090: ARRAY
72091: PUSH
72092: LD_VAR 0 9
72096: LESS
72097: IFFALSE 72139
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72099: LD_ADDR_VAR 0 6
72103: PUSH
72104: LD_VAR 0 6
72108: PPUSH
72109: LD_VAR 0 6
72113: PUSH
72114: LD_INT 1
72116: PLUS
72117: PPUSH
72118: LD_VAR 0 7
72122: PUSH
72123: LD_VAR 0 9
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PPUSH
72132: CALL_OW 2
72136: ST_TO_ADDR
72137: GO 72219
// for j = 1 to result do
72139: LD_ADDR_VAR 0 8
72143: PUSH
72144: DOUBLE
72145: LD_INT 1
72147: DEC
72148: ST_TO_ADDR
72149: LD_VAR 0 6
72153: PUSH
72154: FOR_TO
72155: IFFALSE 72217
// begin if tmp < result [ j ] [ 2 ] then
72157: LD_VAR 0 9
72161: PUSH
72162: LD_VAR 0 6
72166: PUSH
72167: LD_VAR 0 8
72171: ARRAY
72172: PUSH
72173: LD_INT 2
72175: ARRAY
72176: LESS
72177: IFFALSE 72215
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72179: LD_ADDR_VAR 0 6
72183: PUSH
72184: LD_VAR 0 6
72188: PPUSH
72189: LD_VAR 0 8
72193: PPUSH
72194: LD_VAR 0 7
72198: PUSH
72199: LD_VAR 0 9
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PPUSH
72208: CALL_OW 2
72212: ST_TO_ADDR
// break ;
72213: GO 72217
// end ; end ;
72215: GO 72154
72217: POP
72218: POP
// end ; end ;
72219: GO 72018
72221: POP
72222: POP
// if result and not asc then
72223: LD_VAR 0 6
72227: PUSH
72228: LD_VAR 0 4
72232: NOT
72233: AND
72234: IFFALSE 72309
// begin tmp := result ;
72236: LD_ADDR_VAR 0 9
72240: PUSH
72241: LD_VAR 0 6
72245: ST_TO_ADDR
// for i = tmp downto 1 do
72246: LD_ADDR_VAR 0 7
72250: PUSH
72251: DOUBLE
72252: LD_VAR 0 9
72256: INC
72257: ST_TO_ADDR
72258: LD_INT 1
72260: PUSH
72261: FOR_DOWNTO
72262: IFFALSE 72307
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72264: LD_ADDR_VAR 0 6
72268: PUSH
72269: LD_VAR 0 6
72273: PPUSH
72274: LD_VAR 0 9
72278: PUSH
72279: LD_VAR 0 7
72283: MINUS
72284: PUSH
72285: LD_INT 1
72287: PLUS
72288: PPUSH
72289: LD_VAR 0 9
72293: PUSH
72294: LD_VAR 0 7
72298: ARRAY
72299: PPUSH
72300: CALL_OW 1
72304: ST_TO_ADDR
72305: GO 72261
72307: POP
72308: POP
// end ; tmp := [ ] ;
72309: LD_ADDR_VAR 0 9
72313: PUSH
72314: EMPTY
72315: ST_TO_ADDR
// if mode then
72316: LD_VAR 0 5
72320: IFFALSE 72389
// begin for i = 1 to result do
72322: LD_ADDR_VAR 0 7
72326: PUSH
72327: DOUBLE
72328: LD_INT 1
72330: DEC
72331: ST_TO_ADDR
72332: LD_VAR 0 6
72336: PUSH
72337: FOR_TO
72338: IFFALSE 72377
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72340: LD_ADDR_VAR 0 9
72344: PUSH
72345: LD_VAR 0 9
72349: PPUSH
72350: LD_VAR 0 7
72354: PPUSH
72355: LD_VAR 0 6
72359: PUSH
72360: LD_VAR 0 7
72364: ARRAY
72365: PUSH
72366: LD_INT 1
72368: ARRAY
72369: PPUSH
72370: CALL_OW 1
72374: ST_TO_ADDR
72375: GO 72337
72377: POP
72378: POP
// result := tmp ;
72379: LD_ADDR_VAR 0 6
72383: PUSH
72384: LD_VAR 0 9
72388: ST_TO_ADDR
// end ; end ;
72389: LD_VAR 0 6
72393: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72394: LD_INT 0
72396: PPUSH
72397: PPUSH
72398: PPUSH
72399: PPUSH
72400: PPUSH
72401: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72402: LD_ADDR_VAR 0 5
72406: PUSH
72407: LD_INT 0
72409: PUSH
72410: LD_INT 0
72412: PUSH
72413: LD_INT 0
72415: PUSH
72416: EMPTY
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: ST_TO_ADDR
// if not x or not y then
72424: LD_VAR 0 2
72428: NOT
72429: PUSH
72430: LD_VAR 0 3
72434: NOT
72435: OR
72436: IFFALSE 72440
// exit ;
72438: GO 74086
// if not range then
72440: LD_VAR 0 4
72444: NOT
72445: IFFALSE 72455
// range := 10 ;
72447: LD_ADDR_VAR 0 4
72451: PUSH
72452: LD_INT 10
72454: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72455: LD_ADDR_VAR 0 8
72459: PUSH
72460: LD_INT 81
72462: PUSH
72463: LD_VAR 0 1
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 92
72474: PUSH
72475: LD_VAR 0 2
72479: PUSH
72480: LD_VAR 0 3
72484: PUSH
72485: LD_VAR 0 4
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: LIST
72494: LIST
72495: PUSH
72496: LD_INT 3
72498: PUSH
72499: LD_INT 21
72501: PUSH
72502: LD_INT 3
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: LIST
72517: PPUSH
72518: CALL_OW 69
72522: ST_TO_ADDR
// if not tmp then
72523: LD_VAR 0 8
72527: NOT
72528: IFFALSE 72532
// exit ;
72530: GO 74086
// for i in tmp do
72532: LD_ADDR_VAR 0 6
72536: PUSH
72537: LD_VAR 0 8
72541: PUSH
72542: FOR_IN
72543: IFFALSE 74061
// begin points := [ 0 , 0 , 0 ] ;
72545: LD_ADDR_VAR 0 9
72549: PUSH
72550: LD_INT 0
72552: PUSH
72553: LD_INT 0
72555: PUSH
72556: LD_INT 0
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: LIST
72563: ST_TO_ADDR
// bpoints := 1 ;
72564: LD_ADDR_VAR 0 10
72568: PUSH
72569: LD_INT 1
72571: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72572: LD_VAR 0 6
72576: PPUSH
72577: CALL_OW 247
72581: PUSH
72582: LD_INT 1
72584: DOUBLE
72585: EQUAL
72586: IFTRUE 72590
72588: GO 73168
72590: POP
// begin if GetClass ( i ) = 1 then
72591: LD_VAR 0 6
72595: PPUSH
72596: CALL_OW 257
72600: PUSH
72601: LD_INT 1
72603: EQUAL
72604: IFFALSE 72625
// points := [ 10 , 5 , 3 ] ;
72606: LD_ADDR_VAR 0 9
72610: PUSH
72611: LD_INT 10
72613: PUSH
72614: LD_INT 5
72616: PUSH
72617: LD_INT 3
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: LIST
72624: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72625: LD_VAR 0 6
72629: PPUSH
72630: CALL_OW 257
72634: PUSH
72635: LD_INT 2
72637: PUSH
72638: LD_INT 3
72640: PUSH
72641: LD_INT 4
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: LIST
72648: IN
72649: IFFALSE 72670
// points := [ 3 , 2 , 1 ] ;
72651: LD_ADDR_VAR 0 9
72655: PUSH
72656: LD_INT 3
72658: PUSH
72659: LD_INT 2
72661: PUSH
72662: LD_INT 1
72664: PUSH
72665: EMPTY
72666: LIST
72667: LIST
72668: LIST
72669: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72670: LD_VAR 0 6
72674: PPUSH
72675: CALL_OW 257
72679: PUSH
72680: LD_INT 5
72682: EQUAL
72683: IFFALSE 72704
// points := [ 130 , 5 , 2 ] ;
72685: LD_ADDR_VAR 0 9
72689: PUSH
72690: LD_INT 130
72692: PUSH
72693: LD_INT 5
72695: PUSH
72696: LD_INT 2
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: LIST
72703: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72704: LD_VAR 0 6
72708: PPUSH
72709: CALL_OW 257
72713: PUSH
72714: LD_INT 8
72716: EQUAL
72717: IFFALSE 72738
// points := [ 35 , 35 , 30 ] ;
72719: LD_ADDR_VAR 0 9
72723: PUSH
72724: LD_INT 35
72726: PUSH
72727: LD_INT 35
72729: PUSH
72730: LD_INT 30
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: LIST
72737: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72738: LD_VAR 0 6
72742: PPUSH
72743: CALL_OW 257
72747: PUSH
72748: LD_INT 9
72750: EQUAL
72751: IFFALSE 72772
// points := [ 20 , 55 , 40 ] ;
72753: LD_ADDR_VAR 0 9
72757: PUSH
72758: LD_INT 20
72760: PUSH
72761: LD_INT 55
72763: PUSH
72764: LD_INT 40
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: LIST
72771: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72772: LD_VAR 0 6
72776: PPUSH
72777: CALL_OW 257
72781: PUSH
72782: LD_INT 12
72784: PUSH
72785: LD_INT 16
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: IN
72792: IFFALSE 72813
// points := [ 5 , 3 , 2 ] ;
72794: LD_ADDR_VAR 0 9
72798: PUSH
72799: LD_INT 5
72801: PUSH
72802: LD_INT 3
72804: PUSH
72805: LD_INT 2
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: LIST
72812: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72813: LD_VAR 0 6
72817: PPUSH
72818: CALL_OW 257
72822: PUSH
72823: LD_INT 17
72825: EQUAL
72826: IFFALSE 72847
// points := [ 100 , 50 , 75 ] ;
72828: LD_ADDR_VAR 0 9
72832: PUSH
72833: LD_INT 100
72835: PUSH
72836: LD_INT 50
72838: PUSH
72839: LD_INT 75
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: LIST
72846: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72847: LD_VAR 0 6
72851: PPUSH
72852: CALL_OW 257
72856: PUSH
72857: LD_INT 15
72859: EQUAL
72860: IFFALSE 72881
// points := [ 10 , 5 , 3 ] ;
72862: LD_ADDR_VAR 0 9
72866: PUSH
72867: LD_INT 10
72869: PUSH
72870: LD_INT 5
72872: PUSH
72873: LD_INT 3
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: LIST
72880: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72881: LD_VAR 0 6
72885: PPUSH
72886: CALL_OW 257
72890: PUSH
72891: LD_INT 14
72893: EQUAL
72894: IFFALSE 72915
// points := [ 10 , 0 , 0 ] ;
72896: LD_ADDR_VAR 0 9
72900: PUSH
72901: LD_INT 10
72903: PUSH
72904: LD_INT 0
72906: PUSH
72907: LD_INT 0
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: LIST
72914: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72915: LD_VAR 0 6
72919: PPUSH
72920: CALL_OW 257
72924: PUSH
72925: LD_INT 11
72927: EQUAL
72928: IFFALSE 72949
// points := [ 30 , 10 , 5 ] ;
72930: LD_ADDR_VAR 0 9
72934: PUSH
72935: LD_INT 30
72937: PUSH
72938: LD_INT 10
72940: PUSH
72941: LD_INT 5
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: LIST
72948: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72949: LD_VAR 0 1
72953: PPUSH
72954: LD_INT 5
72956: PPUSH
72957: CALL_OW 321
72961: PUSH
72962: LD_INT 2
72964: EQUAL
72965: IFFALSE 72982
// bpoints := bpoints * 1.8 ;
72967: LD_ADDR_VAR 0 10
72971: PUSH
72972: LD_VAR 0 10
72976: PUSH
72977: LD_REAL  1.80000000000000E+0000
72980: MUL
72981: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72982: LD_VAR 0 6
72986: PPUSH
72987: CALL_OW 257
72991: PUSH
72992: LD_INT 1
72994: PUSH
72995: LD_INT 2
72997: PUSH
72998: LD_INT 3
73000: PUSH
73001: LD_INT 4
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: IN
73010: PUSH
73011: LD_VAR 0 1
73015: PPUSH
73016: LD_INT 51
73018: PPUSH
73019: CALL_OW 321
73023: PUSH
73024: LD_INT 2
73026: EQUAL
73027: AND
73028: IFFALSE 73045
// bpoints := bpoints * 1.2 ;
73030: LD_ADDR_VAR 0 10
73034: PUSH
73035: LD_VAR 0 10
73039: PUSH
73040: LD_REAL  1.20000000000000E+0000
73043: MUL
73044: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73045: LD_VAR 0 6
73049: PPUSH
73050: CALL_OW 257
73054: PUSH
73055: LD_INT 5
73057: PUSH
73058: LD_INT 7
73060: PUSH
73061: LD_INT 9
73063: PUSH
73064: EMPTY
73065: LIST
73066: LIST
73067: LIST
73068: IN
73069: PUSH
73070: LD_VAR 0 1
73074: PPUSH
73075: LD_INT 52
73077: PPUSH
73078: CALL_OW 321
73082: PUSH
73083: LD_INT 2
73085: EQUAL
73086: AND
73087: IFFALSE 73104
// bpoints := bpoints * 1.5 ;
73089: LD_ADDR_VAR 0 10
73093: PUSH
73094: LD_VAR 0 10
73098: PUSH
73099: LD_REAL  1.50000000000000E+0000
73102: MUL
73103: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73104: LD_VAR 0 1
73108: PPUSH
73109: LD_INT 66
73111: PPUSH
73112: CALL_OW 321
73116: PUSH
73117: LD_INT 2
73119: EQUAL
73120: IFFALSE 73137
// bpoints := bpoints * 1.1 ;
73122: LD_ADDR_VAR 0 10
73126: PUSH
73127: LD_VAR 0 10
73131: PUSH
73132: LD_REAL  1.10000000000000E+0000
73135: MUL
73136: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73137: LD_ADDR_VAR 0 10
73141: PUSH
73142: LD_VAR 0 10
73146: PUSH
73147: LD_VAR 0 6
73151: PPUSH
73152: LD_INT 1
73154: PPUSH
73155: CALL_OW 259
73159: PUSH
73160: LD_REAL  1.15000000000000E+0000
73163: MUL
73164: MUL
73165: ST_TO_ADDR
// end ; unit_vehicle :
73166: GO 73990
73168: LD_INT 2
73170: DOUBLE
73171: EQUAL
73172: IFTRUE 73176
73174: GO 73978
73176: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73177: LD_VAR 0 6
73181: PPUSH
73182: CALL_OW 264
73186: PUSH
73187: LD_INT 2
73189: PUSH
73190: LD_INT 42
73192: PUSH
73193: LD_INT 24
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: LIST
73200: IN
73201: IFFALSE 73222
// points := [ 25 , 5 , 3 ] ;
73203: LD_ADDR_VAR 0 9
73207: PUSH
73208: LD_INT 25
73210: PUSH
73211: LD_INT 5
73213: PUSH
73214: LD_INT 3
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: LIST
73221: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73222: LD_VAR 0 6
73226: PPUSH
73227: CALL_OW 264
73231: PUSH
73232: LD_INT 4
73234: PUSH
73235: LD_INT 43
73237: PUSH
73238: LD_INT 25
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: LIST
73245: IN
73246: IFFALSE 73267
// points := [ 40 , 15 , 5 ] ;
73248: LD_ADDR_VAR 0 9
73252: PUSH
73253: LD_INT 40
73255: PUSH
73256: LD_INT 15
73258: PUSH
73259: LD_INT 5
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: LIST
73266: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73267: LD_VAR 0 6
73271: PPUSH
73272: CALL_OW 264
73276: PUSH
73277: LD_INT 3
73279: PUSH
73280: LD_INT 23
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: IN
73287: IFFALSE 73308
// points := [ 7 , 25 , 8 ] ;
73289: LD_ADDR_VAR 0 9
73293: PUSH
73294: LD_INT 7
73296: PUSH
73297: LD_INT 25
73299: PUSH
73300: LD_INT 8
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: LIST
73307: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73308: LD_VAR 0 6
73312: PPUSH
73313: CALL_OW 264
73317: PUSH
73318: LD_INT 5
73320: PUSH
73321: LD_INT 27
73323: PUSH
73324: LD_INT 44
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: LIST
73331: IN
73332: IFFALSE 73353
// points := [ 14 , 50 , 16 ] ;
73334: LD_ADDR_VAR 0 9
73338: PUSH
73339: LD_INT 14
73341: PUSH
73342: LD_INT 50
73344: PUSH
73345: LD_INT 16
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: LIST
73352: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73353: LD_VAR 0 6
73357: PPUSH
73358: CALL_OW 264
73362: PUSH
73363: LD_INT 6
73365: PUSH
73366: LD_INT 46
73368: PUSH
73369: EMPTY
73370: LIST
73371: LIST
73372: IN
73373: IFFALSE 73394
// points := [ 32 , 120 , 70 ] ;
73375: LD_ADDR_VAR 0 9
73379: PUSH
73380: LD_INT 32
73382: PUSH
73383: LD_INT 120
73385: PUSH
73386: LD_INT 70
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: LIST
73393: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73394: LD_VAR 0 6
73398: PPUSH
73399: CALL_OW 264
73403: PUSH
73404: LD_INT 7
73406: PUSH
73407: LD_INT 28
73409: PUSH
73410: LD_INT 45
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: LIST
73417: IN
73418: IFFALSE 73439
// points := [ 35 , 20 , 45 ] ;
73420: LD_ADDR_VAR 0 9
73424: PUSH
73425: LD_INT 35
73427: PUSH
73428: LD_INT 20
73430: PUSH
73431: LD_INT 45
73433: PUSH
73434: EMPTY
73435: LIST
73436: LIST
73437: LIST
73438: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73439: LD_VAR 0 6
73443: PPUSH
73444: CALL_OW 264
73448: PUSH
73449: LD_INT 47
73451: PUSH
73452: EMPTY
73453: LIST
73454: IN
73455: IFFALSE 73476
// points := [ 67 , 45 , 75 ] ;
73457: LD_ADDR_VAR 0 9
73461: PUSH
73462: LD_INT 67
73464: PUSH
73465: LD_INT 45
73467: PUSH
73468: LD_INT 75
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: LIST
73475: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73476: LD_VAR 0 6
73480: PPUSH
73481: CALL_OW 264
73485: PUSH
73486: LD_INT 26
73488: PUSH
73489: EMPTY
73490: LIST
73491: IN
73492: IFFALSE 73513
// points := [ 120 , 30 , 80 ] ;
73494: LD_ADDR_VAR 0 9
73498: PUSH
73499: LD_INT 120
73501: PUSH
73502: LD_INT 30
73504: PUSH
73505: LD_INT 80
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: LIST
73512: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73513: LD_VAR 0 6
73517: PPUSH
73518: CALL_OW 264
73522: PUSH
73523: LD_INT 22
73525: PUSH
73526: EMPTY
73527: LIST
73528: IN
73529: IFFALSE 73550
// points := [ 40 , 1 , 1 ] ;
73531: LD_ADDR_VAR 0 9
73535: PUSH
73536: LD_INT 40
73538: PUSH
73539: LD_INT 1
73541: PUSH
73542: LD_INT 1
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: LIST
73549: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73550: LD_VAR 0 6
73554: PPUSH
73555: CALL_OW 264
73559: PUSH
73560: LD_INT 29
73562: PUSH
73563: EMPTY
73564: LIST
73565: IN
73566: IFFALSE 73587
// points := [ 70 , 200 , 400 ] ;
73568: LD_ADDR_VAR 0 9
73572: PUSH
73573: LD_INT 70
73575: PUSH
73576: LD_INT 200
73578: PUSH
73579: LD_INT 400
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: LIST
73586: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73587: LD_VAR 0 6
73591: PPUSH
73592: CALL_OW 264
73596: PUSH
73597: LD_INT 14
73599: PUSH
73600: LD_INT 53
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: IN
73607: IFFALSE 73628
// points := [ 40 , 10 , 20 ] ;
73609: LD_ADDR_VAR 0 9
73613: PUSH
73614: LD_INT 40
73616: PUSH
73617: LD_INT 10
73619: PUSH
73620: LD_INT 20
73622: PUSH
73623: EMPTY
73624: LIST
73625: LIST
73626: LIST
73627: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73628: LD_VAR 0 6
73632: PPUSH
73633: CALL_OW 264
73637: PUSH
73638: LD_INT 9
73640: PUSH
73641: EMPTY
73642: LIST
73643: IN
73644: IFFALSE 73665
// points := [ 5 , 70 , 20 ] ;
73646: LD_ADDR_VAR 0 9
73650: PUSH
73651: LD_INT 5
73653: PUSH
73654: LD_INT 70
73656: PUSH
73657: LD_INT 20
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: LIST
73664: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73665: LD_VAR 0 6
73669: PPUSH
73670: CALL_OW 264
73674: PUSH
73675: LD_INT 10
73677: PUSH
73678: EMPTY
73679: LIST
73680: IN
73681: IFFALSE 73702
// points := [ 35 , 110 , 70 ] ;
73683: LD_ADDR_VAR 0 9
73687: PUSH
73688: LD_INT 35
73690: PUSH
73691: LD_INT 110
73693: PUSH
73694: LD_INT 70
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: LIST
73701: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73702: LD_VAR 0 6
73706: PPUSH
73707: CALL_OW 265
73711: PUSH
73712: LD_INT 25
73714: EQUAL
73715: IFFALSE 73736
// points := [ 80 , 65 , 100 ] ;
73717: LD_ADDR_VAR 0 9
73721: PUSH
73722: LD_INT 80
73724: PUSH
73725: LD_INT 65
73727: PUSH
73728: LD_INT 100
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: LIST
73735: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73736: LD_VAR 0 6
73740: PPUSH
73741: CALL_OW 263
73745: PUSH
73746: LD_INT 1
73748: EQUAL
73749: IFFALSE 73784
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73751: LD_ADDR_VAR 0 10
73755: PUSH
73756: LD_VAR 0 10
73760: PUSH
73761: LD_VAR 0 6
73765: PPUSH
73766: CALL_OW 311
73770: PPUSH
73771: LD_INT 3
73773: PPUSH
73774: CALL_OW 259
73778: PUSH
73779: LD_INT 4
73781: MUL
73782: MUL
73783: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73784: LD_VAR 0 6
73788: PPUSH
73789: CALL_OW 263
73793: PUSH
73794: LD_INT 2
73796: EQUAL
73797: IFFALSE 73848
// begin j := IsControledBy ( i ) ;
73799: LD_ADDR_VAR 0 7
73803: PUSH
73804: LD_VAR 0 6
73808: PPUSH
73809: CALL_OW 312
73813: ST_TO_ADDR
// if j then
73814: LD_VAR 0 7
73818: IFFALSE 73848
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73820: LD_ADDR_VAR 0 10
73824: PUSH
73825: LD_VAR 0 10
73829: PUSH
73830: LD_VAR 0 7
73834: PPUSH
73835: LD_INT 3
73837: PPUSH
73838: CALL_OW 259
73842: PUSH
73843: LD_INT 3
73845: MUL
73846: MUL
73847: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73848: LD_VAR 0 6
73852: PPUSH
73853: CALL_OW 264
73857: PUSH
73858: LD_INT 5
73860: PUSH
73861: LD_INT 6
73863: PUSH
73864: LD_INT 46
73866: PUSH
73867: LD_INT 44
73869: PUSH
73870: LD_INT 47
73872: PUSH
73873: LD_INT 45
73875: PUSH
73876: LD_INT 28
73878: PUSH
73879: LD_INT 7
73881: PUSH
73882: LD_INT 27
73884: PUSH
73885: LD_INT 29
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: IN
73900: PUSH
73901: LD_VAR 0 1
73905: PPUSH
73906: LD_INT 52
73908: PPUSH
73909: CALL_OW 321
73913: PUSH
73914: LD_INT 2
73916: EQUAL
73917: AND
73918: IFFALSE 73935
// bpoints := bpoints * 1.2 ;
73920: LD_ADDR_VAR 0 10
73924: PUSH
73925: LD_VAR 0 10
73929: PUSH
73930: LD_REAL  1.20000000000000E+0000
73933: MUL
73934: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73935: LD_VAR 0 6
73939: PPUSH
73940: CALL_OW 264
73944: PUSH
73945: LD_INT 6
73947: PUSH
73948: LD_INT 46
73950: PUSH
73951: LD_INT 47
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: LIST
73958: IN
73959: IFFALSE 73976
// bpoints := bpoints * 1.2 ;
73961: LD_ADDR_VAR 0 10
73965: PUSH
73966: LD_VAR 0 10
73970: PUSH
73971: LD_REAL  1.20000000000000E+0000
73974: MUL
73975: ST_TO_ADDR
// end ; unit_building :
73976: GO 73990
73978: LD_INT 3
73980: DOUBLE
73981: EQUAL
73982: IFTRUE 73986
73984: GO 73989
73986: POP
// ; end ;
73987: GO 73990
73989: POP
// for j = 1 to 3 do
73990: LD_ADDR_VAR 0 7
73994: PUSH
73995: DOUBLE
73996: LD_INT 1
73998: DEC
73999: ST_TO_ADDR
74000: LD_INT 3
74002: PUSH
74003: FOR_TO
74004: IFFALSE 74057
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74006: LD_ADDR_VAR 0 5
74010: PUSH
74011: LD_VAR 0 5
74015: PPUSH
74016: LD_VAR 0 7
74020: PPUSH
74021: LD_VAR 0 5
74025: PUSH
74026: LD_VAR 0 7
74030: ARRAY
74031: PUSH
74032: LD_VAR 0 9
74036: PUSH
74037: LD_VAR 0 7
74041: ARRAY
74042: PUSH
74043: LD_VAR 0 10
74047: MUL
74048: PLUS
74049: PPUSH
74050: CALL_OW 1
74054: ST_TO_ADDR
74055: GO 74003
74057: POP
74058: POP
// end ;
74059: GO 72542
74061: POP
74062: POP
// result := Replace ( result , 4 , tmp ) ;
74063: LD_ADDR_VAR 0 5
74067: PUSH
74068: LD_VAR 0 5
74072: PPUSH
74073: LD_INT 4
74075: PPUSH
74076: LD_VAR 0 8
74080: PPUSH
74081: CALL_OW 1
74085: ST_TO_ADDR
// end ;
74086: LD_VAR 0 5
74090: RET
// export function DangerAtRange ( unit , range ) ; begin
74091: LD_INT 0
74093: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74094: LD_ADDR_VAR 0 3
74098: PUSH
74099: LD_VAR 0 1
74103: PPUSH
74104: CALL_OW 255
74108: PPUSH
74109: LD_VAR 0 1
74113: PPUSH
74114: CALL_OW 250
74118: PPUSH
74119: LD_VAR 0 1
74123: PPUSH
74124: CALL_OW 251
74128: PPUSH
74129: LD_VAR 0 2
74133: PPUSH
74134: CALL 72394 0 4
74138: ST_TO_ADDR
// end ;
74139: LD_VAR 0 3
74143: RET
// export function DangerInArea ( side , area ) ; begin
74144: LD_INT 0
74146: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74147: LD_ADDR_VAR 0 3
74151: PUSH
74152: LD_VAR 0 2
74156: PPUSH
74157: LD_INT 81
74159: PUSH
74160: LD_VAR 0 1
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: PPUSH
74169: CALL_OW 70
74173: ST_TO_ADDR
// end ;
74174: LD_VAR 0 3
74178: RET
// export function IsExtension ( b ) ; begin
74179: LD_INT 0
74181: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74182: LD_ADDR_VAR 0 2
74186: PUSH
74187: LD_VAR 0 1
74191: PUSH
74192: LD_INT 23
74194: PUSH
74195: LD_INT 20
74197: PUSH
74198: LD_INT 22
74200: PUSH
74201: LD_INT 17
74203: PUSH
74204: LD_INT 24
74206: PUSH
74207: LD_INT 21
74209: PUSH
74210: LD_INT 19
74212: PUSH
74213: LD_INT 16
74215: PUSH
74216: LD_INT 25
74218: PUSH
74219: LD_INT 18
74221: PUSH
74222: EMPTY
74223: LIST
74224: LIST
74225: LIST
74226: LIST
74227: LIST
74228: LIST
74229: LIST
74230: LIST
74231: LIST
74232: LIST
74233: IN
74234: ST_TO_ADDR
// end ;
74235: LD_VAR 0 2
74239: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74240: LD_INT 0
74242: PPUSH
74243: PPUSH
74244: PPUSH
// result := [ ] ;
74245: LD_ADDR_VAR 0 3
74249: PUSH
74250: EMPTY
74251: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74252: LD_ADDR_VAR 0 4
74256: PUSH
74257: LD_VAR 0 2
74261: PPUSH
74262: LD_INT 21
74264: PUSH
74265: LD_INT 3
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PPUSH
74272: CALL_OW 70
74276: ST_TO_ADDR
// if not tmp then
74277: LD_VAR 0 4
74281: NOT
74282: IFFALSE 74286
// exit ;
74284: GO 74344
// for i in tmp do
74286: LD_ADDR_VAR 0 5
74290: PUSH
74291: LD_VAR 0 4
74295: PUSH
74296: FOR_IN
74297: IFFALSE 74332
// if GetBase ( i ) <> base then
74299: LD_VAR 0 5
74303: PPUSH
74304: CALL_OW 274
74308: PUSH
74309: LD_VAR 0 1
74313: NONEQUAL
74314: IFFALSE 74330
// ComLinkToBase ( base , i ) ;
74316: LD_VAR 0 1
74320: PPUSH
74321: LD_VAR 0 5
74325: PPUSH
74326: CALL_OW 169
74330: GO 74296
74332: POP
74333: POP
// result := tmp ;
74334: LD_ADDR_VAR 0 3
74338: PUSH
74339: LD_VAR 0 4
74343: ST_TO_ADDR
// end ;
74344: LD_VAR 0 3
74348: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74349: LD_INT 0
74351: PPUSH
74352: PPUSH
// if BuildingStatus ( b ) = bs_build then
74353: LD_VAR 0 2
74357: PPUSH
74358: CALL_OW 461
74362: PUSH
74363: LD_INT 1
74365: EQUAL
74366: IFFALSE 74426
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74368: LD_VAR 0 1
74372: PPUSH
74373: LD_STRING h
74375: PUSH
74376: LD_VAR 0 2
74380: PPUSH
74381: CALL_OW 250
74385: PUSH
74386: LD_VAR 0 2
74390: PPUSH
74391: CALL_OW 251
74395: PUSH
74396: LD_VAR 0 2
74400: PUSH
74401: LD_INT 0
74403: PUSH
74404: LD_INT 0
74406: PUSH
74407: LD_INT 0
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: PUSH
74419: EMPTY
74420: LIST
74421: PPUSH
74422: CALL_OW 446
// end ;
74426: LD_VAR 0 3
74430: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74431: LD_INT 0
74433: PPUSH
74434: PPUSH
74435: PPUSH
74436: PPUSH
74437: PPUSH
74438: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74439: LD_VAR 0 1
74443: NOT
74444: PUSH
74445: LD_VAR 0 1
74449: PPUSH
74450: CALL_OW 263
74454: PUSH
74455: LD_INT 2
74457: EQUAL
74458: NOT
74459: OR
74460: IFFALSE 74464
// exit ;
74462: GO 74780
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74464: LD_ADDR_VAR 0 6
74468: PUSH
74469: LD_INT 22
74471: PUSH
74472: LD_VAR 0 1
74476: PPUSH
74477: CALL_OW 255
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PUSH
74486: LD_INT 2
74488: PUSH
74489: LD_INT 30
74491: PUSH
74492: LD_INT 36
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 34
74501: PUSH
74502: LD_INT 31
74504: PUSH
74505: EMPTY
74506: LIST
74507: LIST
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: LIST
74513: PUSH
74514: EMPTY
74515: LIST
74516: LIST
74517: PPUSH
74518: CALL_OW 69
74522: ST_TO_ADDR
// if not tmp then
74523: LD_VAR 0 6
74527: NOT
74528: IFFALSE 74532
// exit ;
74530: GO 74780
// result := [ ] ;
74532: LD_ADDR_VAR 0 2
74536: PUSH
74537: EMPTY
74538: ST_TO_ADDR
// for i in tmp do
74539: LD_ADDR_VAR 0 3
74543: PUSH
74544: LD_VAR 0 6
74548: PUSH
74549: FOR_IN
74550: IFFALSE 74621
// begin t := UnitsInside ( i ) ;
74552: LD_ADDR_VAR 0 4
74556: PUSH
74557: LD_VAR 0 3
74561: PPUSH
74562: CALL_OW 313
74566: ST_TO_ADDR
// if t then
74567: LD_VAR 0 4
74571: IFFALSE 74619
// for j in t do
74573: LD_ADDR_VAR 0 7
74577: PUSH
74578: LD_VAR 0 4
74582: PUSH
74583: FOR_IN
74584: IFFALSE 74617
// result := Insert ( result , result + 1 , j ) ;
74586: LD_ADDR_VAR 0 2
74590: PUSH
74591: LD_VAR 0 2
74595: PPUSH
74596: LD_VAR 0 2
74600: PUSH
74601: LD_INT 1
74603: PLUS
74604: PPUSH
74605: LD_VAR 0 7
74609: PPUSH
74610: CALL_OW 2
74614: ST_TO_ADDR
74615: GO 74583
74617: POP
74618: POP
// end ;
74619: GO 74549
74621: POP
74622: POP
// if not result then
74623: LD_VAR 0 2
74627: NOT
74628: IFFALSE 74632
// exit ;
74630: GO 74780
// mech := result [ 1 ] ;
74632: LD_ADDR_VAR 0 5
74636: PUSH
74637: LD_VAR 0 2
74641: PUSH
74642: LD_INT 1
74644: ARRAY
74645: ST_TO_ADDR
// if result > 1 then
74646: LD_VAR 0 2
74650: PUSH
74651: LD_INT 1
74653: GREATER
74654: IFFALSE 74766
// for i = 2 to result do
74656: LD_ADDR_VAR 0 3
74660: PUSH
74661: DOUBLE
74662: LD_INT 2
74664: DEC
74665: ST_TO_ADDR
74666: LD_VAR 0 2
74670: PUSH
74671: FOR_TO
74672: IFFALSE 74764
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74674: LD_ADDR_VAR 0 4
74678: PUSH
74679: LD_VAR 0 2
74683: PUSH
74684: LD_VAR 0 3
74688: ARRAY
74689: PPUSH
74690: LD_INT 3
74692: PPUSH
74693: CALL_OW 259
74697: PUSH
74698: LD_VAR 0 2
74702: PUSH
74703: LD_VAR 0 3
74707: ARRAY
74708: PPUSH
74709: CALL_OW 432
74713: MINUS
74714: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74715: LD_VAR 0 4
74719: PUSH
74720: LD_VAR 0 5
74724: PPUSH
74725: LD_INT 3
74727: PPUSH
74728: CALL_OW 259
74732: PUSH
74733: LD_VAR 0 5
74737: PPUSH
74738: CALL_OW 432
74742: MINUS
74743: GREATEREQUAL
74744: IFFALSE 74762
// mech := result [ i ] ;
74746: LD_ADDR_VAR 0 5
74750: PUSH
74751: LD_VAR 0 2
74755: PUSH
74756: LD_VAR 0 3
74760: ARRAY
74761: ST_TO_ADDR
// end ;
74762: GO 74671
74764: POP
74765: POP
// ComLinkTo ( vehicle , mech ) ;
74766: LD_VAR 0 1
74770: PPUSH
74771: LD_VAR 0 5
74775: PPUSH
74776: CALL_OW 135
// end ;
74780: LD_VAR 0 2
74784: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74785: LD_INT 0
74787: PPUSH
74788: PPUSH
74789: PPUSH
74790: PPUSH
74791: PPUSH
74792: PPUSH
74793: PPUSH
74794: PPUSH
74795: PPUSH
74796: PPUSH
74797: PPUSH
74798: PPUSH
74799: PPUSH
// result := [ ] ;
74800: LD_ADDR_VAR 0 7
74804: PUSH
74805: EMPTY
74806: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74807: LD_VAR 0 1
74811: PPUSH
74812: CALL_OW 266
74816: PUSH
74817: LD_INT 0
74819: PUSH
74820: LD_INT 1
74822: PUSH
74823: EMPTY
74824: LIST
74825: LIST
74826: IN
74827: NOT
74828: IFFALSE 74832
// exit ;
74830: GO 76463
// if name then
74832: LD_VAR 0 3
74836: IFFALSE 74852
// SetBName ( base_dep , name ) ;
74838: LD_VAR 0 1
74842: PPUSH
74843: LD_VAR 0 3
74847: PPUSH
74848: CALL_OW 500
// base := GetBase ( base_dep ) ;
74852: LD_ADDR_VAR 0 15
74856: PUSH
74857: LD_VAR 0 1
74861: PPUSH
74862: CALL_OW 274
74866: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74867: LD_ADDR_VAR 0 16
74871: PUSH
74872: LD_VAR 0 1
74876: PPUSH
74877: CALL_OW 255
74881: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74882: LD_ADDR_VAR 0 17
74886: PUSH
74887: LD_VAR 0 1
74891: PPUSH
74892: CALL_OW 248
74896: ST_TO_ADDR
// if sources then
74897: LD_VAR 0 5
74901: IFFALSE 74948
// for i = 1 to 3 do
74903: LD_ADDR_VAR 0 8
74907: PUSH
74908: DOUBLE
74909: LD_INT 1
74911: DEC
74912: ST_TO_ADDR
74913: LD_INT 3
74915: PUSH
74916: FOR_TO
74917: IFFALSE 74946
// AddResourceType ( base , i , sources [ i ] ) ;
74919: LD_VAR 0 15
74923: PPUSH
74924: LD_VAR 0 8
74928: PPUSH
74929: LD_VAR 0 5
74933: PUSH
74934: LD_VAR 0 8
74938: ARRAY
74939: PPUSH
74940: CALL_OW 276
74944: GO 74916
74946: POP
74947: POP
// buildings := GetBaseBuildings ( base , area ) ;
74948: LD_ADDR_VAR 0 18
74952: PUSH
74953: LD_VAR 0 15
74957: PPUSH
74958: LD_VAR 0 2
74962: PPUSH
74963: CALL 74240 0 2
74967: ST_TO_ADDR
// InitHc ;
74968: CALL_OW 19
// InitUc ;
74972: CALL_OW 18
// uc_side := side ;
74976: LD_ADDR_OWVAR 20
74980: PUSH
74981: LD_VAR 0 16
74985: ST_TO_ADDR
// uc_nation := nation ;
74986: LD_ADDR_OWVAR 21
74990: PUSH
74991: LD_VAR 0 17
74995: ST_TO_ADDR
// if buildings then
74996: LD_VAR 0 18
75000: IFFALSE 76322
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75002: LD_ADDR_VAR 0 19
75006: PUSH
75007: LD_VAR 0 18
75011: PPUSH
75012: LD_INT 2
75014: PUSH
75015: LD_INT 30
75017: PUSH
75018: LD_INT 29
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: LD_INT 30
75027: PUSH
75028: LD_INT 30
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: LIST
75039: PPUSH
75040: CALL_OW 72
75044: ST_TO_ADDR
// if tmp then
75045: LD_VAR 0 19
75049: IFFALSE 75097
// for i in tmp do
75051: LD_ADDR_VAR 0 8
75055: PUSH
75056: LD_VAR 0 19
75060: PUSH
75061: FOR_IN
75062: IFFALSE 75095
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75064: LD_VAR 0 8
75068: PPUSH
75069: CALL_OW 250
75073: PPUSH
75074: LD_VAR 0 8
75078: PPUSH
75079: CALL_OW 251
75083: PPUSH
75084: LD_VAR 0 16
75088: PPUSH
75089: CALL_OW 441
75093: GO 75061
75095: POP
75096: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75097: LD_VAR 0 18
75101: PPUSH
75102: LD_INT 2
75104: PUSH
75105: LD_INT 30
75107: PUSH
75108: LD_INT 32
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 30
75117: PUSH
75118: LD_INT 33
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: LIST
75129: PPUSH
75130: CALL_OW 72
75134: IFFALSE 75222
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75136: LD_ADDR_VAR 0 8
75140: PUSH
75141: LD_VAR 0 18
75145: PPUSH
75146: LD_INT 2
75148: PUSH
75149: LD_INT 30
75151: PUSH
75152: LD_INT 32
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 30
75161: PUSH
75162: LD_INT 33
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: LIST
75173: PPUSH
75174: CALL_OW 72
75178: PUSH
75179: FOR_IN
75180: IFFALSE 75220
// begin if not GetBWeapon ( i ) then
75182: LD_VAR 0 8
75186: PPUSH
75187: CALL_OW 269
75191: NOT
75192: IFFALSE 75218
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75194: LD_VAR 0 8
75198: PPUSH
75199: LD_VAR 0 8
75203: PPUSH
75204: LD_VAR 0 2
75208: PPUSH
75209: CALL 76468 0 2
75213: PPUSH
75214: CALL_OW 431
// end ;
75218: GO 75179
75220: POP
75221: POP
// end ; for i = 1 to personel do
75222: LD_ADDR_VAR 0 8
75226: PUSH
75227: DOUBLE
75228: LD_INT 1
75230: DEC
75231: ST_TO_ADDR
75232: LD_VAR 0 6
75236: PUSH
75237: FOR_TO
75238: IFFALSE 76302
// begin if i > 4 then
75240: LD_VAR 0 8
75244: PUSH
75245: LD_INT 4
75247: GREATER
75248: IFFALSE 75252
// break ;
75250: GO 76302
// case i of 1 :
75252: LD_VAR 0 8
75256: PUSH
75257: LD_INT 1
75259: DOUBLE
75260: EQUAL
75261: IFTRUE 75265
75263: GO 75345
75265: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75266: LD_ADDR_VAR 0 12
75270: PUSH
75271: LD_VAR 0 18
75275: PPUSH
75276: LD_INT 22
75278: PUSH
75279: LD_VAR 0 16
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 58
75290: PUSH
75291: EMPTY
75292: LIST
75293: PUSH
75294: LD_INT 2
75296: PUSH
75297: LD_INT 30
75299: PUSH
75300: LD_INT 32
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: LD_INT 30
75309: PUSH
75310: LD_INT 4
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: LD_INT 30
75319: PUSH
75320: LD_INT 5
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: LIST
75331: LIST
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: LIST
75337: PPUSH
75338: CALL_OW 72
75342: ST_TO_ADDR
75343: GO 75567
75345: LD_INT 2
75347: DOUBLE
75348: EQUAL
75349: IFTRUE 75353
75351: GO 75415
75353: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75354: LD_ADDR_VAR 0 12
75358: PUSH
75359: LD_VAR 0 18
75363: PPUSH
75364: LD_INT 22
75366: PUSH
75367: LD_VAR 0 16
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 2
75378: PUSH
75379: LD_INT 30
75381: PUSH
75382: LD_INT 0
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 30
75391: PUSH
75392: LD_INT 1
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: LIST
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PPUSH
75408: CALL_OW 72
75412: ST_TO_ADDR
75413: GO 75567
75415: LD_INT 3
75417: DOUBLE
75418: EQUAL
75419: IFTRUE 75423
75421: GO 75485
75423: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75424: LD_ADDR_VAR 0 12
75428: PUSH
75429: LD_VAR 0 18
75433: PPUSH
75434: LD_INT 22
75436: PUSH
75437: LD_VAR 0 16
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: LD_INT 2
75448: PUSH
75449: LD_INT 30
75451: PUSH
75452: LD_INT 2
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: LD_INT 30
75461: PUSH
75462: LD_INT 3
75464: PUSH
75465: EMPTY
75466: LIST
75467: LIST
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: LIST
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PPUSH
75478: CALL_OW 72
75482: ST_TO_ADDR
75483: GO 75567
75485: LD_INT 4
75487: DOUBLE
75488: EQUAL
75489: IFTRUE 75493
75491: GO 75566
75493: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75494: LD_ADDR_VAR 0 12
75498: PUSH
75499: LD_VAR 0 18
75503: PPUSH
75504: LD_INT 22
75506: PUSH
75507: LD_VAR 0 16
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: PUSH
75516: LD_INT 2
75518: PUSH
75519: LD_INT 30
75521: PUSH
75522: LD_INT 6
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 30
75531: PUSH
75532: LD_INT 7
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: LD_INT 30
75541: PUSH
75542: LD_INT 8
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: PPUSH
75559: CALL_OW 72
75563: ST_TO_ADDR
75564: GO 75567
75566: POP
// if i = 1 then
75567: LD_VAR 0 8
75571: PUSH
75572: LD_INT 1
75574: EQUAL
75575: IFFALSE 75686
// begin tmp := [ ] ;
75577: LD_ADDR_VAR 0 19
75581: PUSH
75582: EMPTY
75583: ST_TO_ADDR
// for j in f do
75584: LD_ADDR_VAR 0 9
75588: PUSH
75589: LD_VAR 0 12
75593: PUSH
75594: FOR_IN
75595: IFFALSE 75668
// if GetBType ( j ) = b_bunker then
75597: LD_VAR 0 9
75601: PPUSH
75602: CALL_OW 266
75606: PUSH
75607: LD_INT 32
75609: EQUAL
75610: IFFALSE 75637
// tmp := Insert ( tmp , 1 , j ) else
75612: LD_ADDR_VAR 0 19
75616: PUSH
75617: LD_VAR 0 19
75621: PPUSH
75622: LD_INT 1
75624: PPUSH
75625: LD_VAR 0 9
75629: PPUSH
75630: CALL_OW 2
75634: ST_TO_ADDR
75635: GO 75666
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75637: LD_ADDR_VAR 0 19
75641: PUSH
75642: LD_VAR 0 19
75646: PPUSH
75647: LD_VAR 0 19
75651: PUSH
75652: LD_INT 1
75654: PLUS
75655: PPUSH
75656: LD_VAR 0 9
75660: PPUSH
75661: CALL_OW 2
75665: ST_TO_ADDR
75666: GO 75594
75668: POP
75669: POP
// if tmp then
75670: LD_VAR 0 19
75674: IFFALSE 75686
// f := tmp ;
75676: LD_ADDR_VAR 0 12
75680: PUSH
75681: LD_VAR 0 19
75685: ST_TO_ADDR
// end ; x := personel [ i ] ;
75686: LD_ADDR_VAR 0 13
75690: PUSH
75691: LD_VAR 0 6
75695: PUSH
75696: LD_VAR 0 8
75700: ARRAY
75701: ST_TO_ADDR
// if x = - 1 then
75702: LD_VAR 0 13
75706: PUSH
75707: LD_INT 1
75709: NEG
75710: EQUAL
75711: IFFALSE 75920
// begin for j in f do
75713: LD_ADDR_VAR 0 9
75717: PUSH
75718: LD_VAR 0 12
75722: PUSH
75723: FOR_IN
75724: IFFALSE 75916
// repeat InitHc ;
75726: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75730: LD_VAR 0 9
75734: PPUSH
75735: CALL_OW 266
75739: PUSH
75740: LD_INT 5
75742: EQUAL
75743: IFFALSE 75813
// begin if UnitsInside ( j ) < 3 then
75745: LD_VAR 0 9
75749: PPUSH
75750: CALL_OW 313
75754: PUSH
75755: LD_INT 3
75757: LESS
75758: IFFALSE 75794
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75760: LD_INT 0
75762: PPUSH
75763: LD_INT 5
75765: PUSH
75766: LD_INT 8
75768: PUSH
75769: LD_INT 9
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: LIST
75776: PUSH
75777: LD_VAR 0 17
75781: ARRAY
75782: PPUSH
75783: LD_VAR 0 4
75787: PPUSH
75788: CALL_OW 380
75792: GO 75811
// PrepareHuman ( false , i , skill ) ;
75794: LD_INT 0
75796: PPUSH
75797: LD_VAR 0 8
75801: PPUSH
75802: LD_VAR 0 4
75806: PPUSH
75807: CALL_OW 380
// end else
75811: GO 75830
// PrepareHuman ( false , i , skill ) ;
75813: LD_INT 0
75815: PPUSH
75816: LD_VAR 0 8
75820: PPUSH
75821: LD_VAR 0 4
75825: PPUSH
75826: CALL_OW 380
// un := CreateHuman ;
75830: LD_ADDR_VAR 0 14
75834: PUSH
75835: CALL_OW 44
75839: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75840: LD_ADDR_VAR 0 7
75844: PUSH
75845: LD_VAR 0 7
75849: PPUSH
75850: LD_INT 1
75852: PPUSH
75853: LD_VAR 0 14
75857: PPUSH
75858: CALL_OW 2
75862: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75863: LD_VAR 0 14
75867: PPUSH
75868: LD_VAR 0 9
75872: PPUSH
75873: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75877: LD_VAR 0 9
75881: PPUSH
75882: CALL_OW 313
75886: PUSH
75887: LD_INT 6
75889: EQUAL
75890: PUSH
75891: LD_VAR 0 9
75895: PPUSH
75896: CALL_OW 266
75900: PUSH
75901: LD_INT 32
75903: PUSH
75904: LD_INT 31
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: IN
75911: OR
75912: IFFALSE 75726
75914: GO 75723
75916: POP
75917: POP
// end else
75918: GO 76300
// for j = 1 to x do
75920: LD_ADDR_VAR 0 9
75924: PUSH
75925: DOUBLE
75926: LD_INT 1
75928: DEC
75929: ST_TO_ADDR
75930: LD_VAR 0 13
75934: PUSH
75935: FOR_TO
75936: IFFALSE 76298
// begin InitHc ;
75938: CALL_OW 19
// if not f then
75942: LD_VAR 0 12
75946: NOT
75947: IFFALSE 76036
// begin PrepareHuman ( false , i , skill ) ;
75949: LD_INT 0
75951: PPUSH
75952: LD_VAR 0 8
75956: PPUSH
75957: LD_VAR 0 4
75961: PPUSH
75962: CALL_OW 380
// un := CreateHuman ;
75966: LD_ADDR_VAR 0 14
75970: PUSH
75971: CALL_OW 44
75975: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75976: LD_ADDR_VAR 0 7
75980: PUSH
75981: LD_VAR 0 7
75985: PPUSH
75986: LD_INT 1
75988: PPUSH
75989: LD_VAR 0 14
75993: PPUSH
75994: CALL_OW 2
75998: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75999: LD_VAR 0 14
76003: PPUSH
76004: LD_VAR 0 1
76008: PPUSH
76009: CALL_OW 250
76013: PPUSH
76014: LD_VAR 0 1
76018: PPUSH
76019: CALL_OW 251
76023: PPUSH
76024: LD_INT 10
76026: PPUSH
76027: LD_INT 0
76029: PPUSH
76030: CALL_OW 50
// continue ;
76034: GO 75935
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76036: LD_VAR 0 12
76040: PUSH
76041: LD_INT 1
76043: ARRAY
76044: PPUSH
76045: CALL_OW 313
76049: PUSH
76050: LD_VAR 0 12
76054: PUSH
76055: LD_INT 1
76057: ARRAY
76058: PPUSH
76059: CALL_OW 266
76063: PUSH
76064: LD_INT 32
76066: PUSH
76067: LD_INT 31
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: IN
76074: AND
76075: PUSH
76076: LD_VAR 0 12
76080: PUSH
76081: LD_INT 1
76083: ARRAY
76084: PPUSH
76085: CALL_OW 313
76089: PUSH
76090: LD_INT 6
76092: EQUAL
76093: OR
76094: IFFALSE 76114
// f := Delete ( f , 1 ) ;
76096: LD_ADDR_VAR 0 12
76100: PUSH
76101: LD_VAR 0 12
76105: PPUSH
76106: LD_INT 1
76108: PPUSH
76109: CALL_OW 3
76113: ST_TO_ADDR
// if not f then
76114: LD_VAR 0 12
76118: NOT
76119: IFFALSE 76137
// begin x := x + 2 ;
76121: LD_ADDR_VAR 0 13
76125: PUSH
76126: LD_VAR 0 13
76130: PUSH
76131: LD_INT 2
76133: PLUS
76134: ST_TO_ADDR
// continue ;
76135: GO 75935
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76137: LD_VAR 0 12
76141: PUSH
76142: LD_INT 1
76144: ARRAY
76145: PPUSH
76146: CALL_OW 266
76150: PUSH
76151: LD_INT 5
76153: EQUAL
76154: IFFALSE 76228
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76156: LD_VAR 0 12
76160: PUSH
76161: LD_INT 1
76163: ARRAY
76164: PPUSH
76165: CALL_OW 313
76169: PUSH
76170: LD_INT 3
76172: LESS
76173: IFFALSE 76209
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76175: LD_INT 0
76177: PPUSH
76178: LD_INT 5
76180: PUSH
76181: LD_INT 8
76183: PUSH
76184: LD_INT 9
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: LIST
76191: PUSH
76192: LD_VAR 0 17
76196: ARRAY
76197: PPUSH
76198: LD_VAR 0 4
76202: PPUSH
76203: CALL_OW 380
76207: GO 76226
// PrepareHuman ( false , i , skill ) ;
76209: LD_INT 0
76211: PPUSH
76212: LD_VAR 0 8
76216: PPUSH
76217: LD_VAR 0 4
76221: PPUSH
76222: CALL_OW 380
// end else
76226: GO 76245
// PrepareHuman ( false , i , skill ) ;
76228: LD_INT 0
76230: PPUSH
76231: LD_VAR 0 8
76235: PPUSH
76236: LD_VAR 0 4
76240: PPUSH
76241: CALL_OW 380
// un := CreateHuman ;
76245: LD_ADDR_VAR 0 14
76249: PUSH
76250: CALL_OW 44
76254: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76255: LD_ADDR_VAR 0 7
76259: PUSH
76260: LD_VAR 0 7
76264: PPUSH
76265: LD_INT 1
76267: PPUSH
76268: LD_VAR 0 14
76272: PPUSH
76273: CALL_OW 2
76277: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76278: LD_VAR 0 14
76282: PPUSH
76283: LD_VAR 0 12
76287: PUSH
76288: LD_INT 1
76290: ARRAY
76291: PPUSH
76292: CALL_OW 52
// end ;
76296: GO 75935
76298: POP
76299: POP
// end ;
76300: GO 75237
76302: POP
76303: POP
// result := result ^ buildings ;
76304: LD_ADDR_VAR 0 7
76308: PUSH
76309: LD_VAR 0 7
76313: PUSH
76314: LD_VAR 0 18
76318: ADD
76319: ST_TO_ADDR
// end else
76320: GO 76463
// begin for i = 1 to personel do
76322: LD_ADDR_VAR 0 8
76326: PUSH
76327: DOUBLE
76328: LD_INT 1
76330: DEC
76331: ST_TO_ADDR
76332: LD_VAR 0 6
76336: PUSH
76337: FOR_TO
76338: IFFALSE 76461
// begin if i > 4 then
76340: LD_VAR 0 8
76344: PUSH
76345: LD_INT 4
76347: GREATER
76348: IFFALSE 76352
// break ;
76350: GO 76461
// x := personel [ i ] ;
76352: LD_ADDR_VAR 0 13
76356: PUSH
76357: LD_VAR 0 6
76361: PUSH
76362: LD_VAR 0 8
76366: ARRAY
76367: ST_TO_ADDR
// if x = - 1 then
76368: LD_VAR 0 13
76372: PUSH
76373: LD_INT 1
76375: NEG
76376: EQUAL
76377: IFFALSE 76381
// continue ;
76379: GO 76337
// PrepareHuman ( false , i , skill ) ;
76381: LD_INT 0
76383: PPUSH
76384: LD_VAR 0 8
76388: PPUSH
76389: LD_VAR 0 4
76393: PPUSH
76394: CALL_OW 380
// un := CreateHuman ;
76398: LD_ADDR_VAR 0 14
76402: PUSH
76403: CALL_OW 44
76407: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76408: LD_VAR 0 14
76412: PPUSH
76413: LD_VAR 0 1
76417: PPUSH
76418: CALL_OW 250
76422: PPUSH
76423: LD_VAR 0 1
76427: PPUSH
76428: CALL_OW 251
76432: PPUSH
76433: LD_INT 10
76435: PPUSH
76436: LD_INT 0
76438: PPUSH
76439: CALL_OW 50
// result := result ^ un ;
76443: LD_ADDR_VAR 0 7
76447: PUSH
76448: LD_VAR 0 7
76452: PUSH
76453: LD_VAR 0 14
76457: ADD
76458: ST_TO_ADDR
// end ;
76459: GO 76337
76461: POP
76462: POP
// end ; end ;
76463: LD_VAR 0 7
76467: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76468: LD_INT 0
76470: PPUSH
76471: PPUSH
76472: PPUSH
76473: PPUSH
76474: PPUSH
76475: PPUSH
76476: PPUSH
76477: PPUSH
76478: PPUSH
76479: PPUSH
76480: PPUSH
76481: PPUSH
76482: PPUSH
76483: PPUSH
76484: PPUSH
76485: PPUSH
// result := false ;
76486: LD_ADDR_VAR 0 3
76490: PUSH
76491: LD_INT 0
76493: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76494: LD_VAR 0 1
76498: NOT
76499: PUSH
76500: LD_VAR 0 1
76504: PPUSH
76505: CALL_OW 266
76509: PUSH
76510: LD_INT 32
76512: PUSH
76513: LD_INT 33
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: IN
76520: NOT
76521: OR
76522: IFFALSE 76526
// exit ;
76524: GO 77662
// nat := GetNation ( tower ) ;
76526: LD_ADDR_VAR 0 12
76530: PUSH
76531: LD_VAR 0 1
76535: PPUSH
76536: CALL_OW 248
76540: ST_TO_ADDR
// side := GetSide ( tower ) ;
76541: LD_ADDR_VAR 0 16
76545: PUSH
76546: LD_VAR 0 1
76550: PPUSH
76551: CALL_OW 255
76555: ST_TO_ADDR
// x := GetX ( tower ) ;
76556: LD_ADDR_VAR 0 10
76560: PUSH
76561: LD_VAR 0 1
76565: PPUSH
76566: CALL_OW 250
76570: ST_TO_ADDR
// y := GetY ( tower ) ;
76571: LD_ADDR_VAR 0 11
76575: PUSH
76576: LD_VAR 0 1
76580: PPUSH
76581: CALL_OW 251
76585: ST_TO_ADDR
// if not x or not y then
76586: LD_VAR 0 10
76590: NOT
76591: PUSH
76592: LD_VAR 0 11
76596: NOT
76597: OR
76598: IFFALSE 76602
// exit ;
76600: GO 77662
// weapon := 0 ;
76602: LD_ADDR_VAR 0 18
76606: PUSH
76607: LD_INT 0
76609: ST_TO_ADDR
// fac_list := [ ] ;
76610: LD_ADDR_VAR 0 17
76614: PUSH
76615: EMPTY
76616: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76617: LD_ADDR_VAR 0 6
76621: PUSH
76622: LD_VAR 0 1
76626: PPUSH
76627: CALL_OW 274
76631: PPUSH
76632: LD_VAR 0 2
76636: PPUSH
76637: CALL 74240 0 2
76641: PPUSH
76642: LD_INT 30
76644: PUSH
76645: LD_INT 3
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: PPUSH
76652: CALL_OW 72
76656: ST_TO_ADDR
// if not factories then
76657: LD_VAR 0 6
76661: NOT
76662: IFFALSE 76666
// exit ;
76664: GO 77662
// for i in factories do
76666: LD_ADDR_VAR 0 8
76670: PUSH
76671: LD_VAR 0 6
76675: PUSH
76676: FOR_IN
76677: IFFALSE 76702
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76679: LD_ADDR_VAR 0 17
76683: PUSH
76684: LD_VAR 0 17
76688: PUSH
76689: LD_VAR 0 8
76693: PPUSH
76694: CALL_OW 478
76698: UNION
76699: ST_TO_ADDR
76700: GO 76676
76702: POP
76703: POP
// if not fac_list then
76704: LD_VAR 0 17
76708: NOT
76709: IFFALSE 76713
// exit ;
76711: GO 77662
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76713: LD_ADDR_VAR 0 5
76717: PUSH
76718: LD_INT 4
76720: PUSH
76721: LD_INT 5
76723: PUSH
76724: LD_INT 9
76726: PUSH
76727: LD_INT 10
76729: PUSH
76730: LD_INT 6
76732: PUSH
76733: LD_INT 7
76735: PUSH
76736: LD_INT 11
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: LIST
76743: LIST
76744: LIST
76745: LIST
76746: LIST
76747: PUSH
76748: LD_INT 27
76750: PUSH
76751: LD_INT 28
76753: PUSH
76754: LD_INT 26
76756: PUSH
76757: LD_INT 30
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: LIST
76764: LIST
76765: PUSH
76766: LD_INT 43
76768: PUSH
76769: LD_INT 44
76771: PUSH
76772: LD_INT 46
76774: PUSH
76775: LD_INT 45
76777: PUSH
76778: LD_INT 47
76780: PUSH
76781: LD_INT 49
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: LIST
76788: LIST
76789: LIST
76790: LIST
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: LIST
76796: PUSH
76797: LD_VAR 0 12
76801: ARRAY
76802: ST_TO_ADDR
// for i in list do
76803: LD_ADDR_VAR 0 8
76807: PUSH
76808: LD_VAR 0 5
76812: PUSH
76813: FOR_IN
76814: IFFALSE 76847
// if not i in fac_list then
76816: LD_VAR 0 8
76820: PUSH
76821: LD_VAR 0 17
76825: IN
76826: NOT
76827: IFFALSE 76845
// list := list diff i ;
76829: LD_ADDR_VAR 0 5
76833: PUSH
76834: LD_VAR 0 5
76838: PUSH
76839: LD_VAR 0 8
76843: DIFF
76844: ST_TO_ADDR
76845: GO 76813
76847: POP
76848: POP
// if not list then
76849: LD_VAR 0 5
76853: NOT
76854: IFFALSE 76858
// exit ;
76856: GO 77662
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76858: LD_VAR 0 12
76862: PUSH
76863: LD_INT 3
76865: EQUAL
76866: PUSH
76867: LD_INT 49
76869: PUSH
76870: LD_VAR 0 5
76874: IN
76875: AND
76876: PUSH
76877: LD_INT 31
76879: PPUSH
76880: LD_VAR 0 16
76884: PPUSH
76885: CALL_OW 321
76889: PUSH
76890: LD_INT 2
76892: EQUAL
76893: AND
76894: IFFALSE 76954
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76896: LD_INT 22
76898: PUSH
76899: LD_VAR 0 16
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: PUSH
76908: LD_INT 35
76910: PUSH
76911: LD_INT 49
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PUSH
76918: LD_INT 91
76920: PUSH
76921: LD_VAR 0 1
76925: PUSH
76926: LD_INT 10
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: LIST
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: LIST
76938: PPUSH
76939: CALL_OW 69
76943: NOT
76944: IFFALSE 76954
// weapon := ru_time_lapser ;
76946: LD_ADDR_VAR 0 18
76950: PUSH
76951: LD_INT 49
76953: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76954: LD_VAR 0 12
76958: PUSH
76959: LD_INT 1
76961: PUSH
76962: LD_INT 2
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: IN
76969: PUSH
76970: LD_INT 11
76972: PUSH
76973: LD_VAR 0 5
76977: IN
76978: PUSH
76979: LD_INT 30
76981: PUSH
76982: LD_VAR 0 5
76986: IN
76987: OR
76988: AND
76989: PUSH
76990: LD_INT 6
76992: PPUSH
76993: LD_VAR 0 16
76997: PPUSH
76998: CALL_OW 321
77002: PUSH
77003: LD_INT 2
77005: EQUAL
77006: AND
77007: IFFALSE 77172
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77009: LD_INT 22
77011: PUSH
77012: LD_VAR 0 16
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PUSH
77021: LD_INT 2
77023: PUSH
77024: LD_INT 35
77026: PUSH
77027: LD_INT 11
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 35
77036: PUSH
77037: LD_INT 30
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 91
77051: PUSH
77052: LD_VAR 0 1
77056: PUSH
77057: LD_INT 18
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: LIST
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: LIST
77069: PPUSH
77070: CALL_OW 69
77074: NOT
77075: PUSH
77076: LD_INT 22
77078: PUSH
77079: LD_VAR 0 16
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 2
77090: PUSH
77091: LD_INT 30
77093: PUSH
77094: LD_INT 32
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: LD_INT 30
77103: PUSH
77104: LD_INT 33
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: EMPTY
77112: LIST
77113: LIST
77114: LIST
77115: PUSH
77116: LD_INT 91
77118: PUSH
77119: LD_VAR 0 1
77123: PUSH
77124: LD_INT 12
77126: PUSH
77127: EMPTY
77128: LIST
77129: LIST
77130: LIST
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: LIST
77136: PUSH
77137: EMPTY
77138: LIST
77139: PPUSH
77140: CALL_OW 69
77144: PUSH
77145: LD_INT 2
77147: GREATER
77148: AND
77149: IFFALSE 77172
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77151: LD_ADDR_VAR 0 18
77155: PUSH
77156: LD_INT 11
77158: PUSH
77159: LD_INT 30
77161: PUSH
77162: EMPTY
77163: LIST
77164: LIST
77165: PUSH
77166: LD_VAR 0 12
77170: ARRAY
77171: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77172: LD_VAR 0 18
77176: NOT
77177: PUSH
77178: LD_INT 40
77180: PPUSH
77181: LD_VAR 0 16
77185: PPUSH
77186: CALL_OW 321
77190: PUSH
77191: LD_INT 2
77193: EQUAL
77194: AND
77195: PUSH
77196: LD_INT 7
77198: PUSH
77199: LD_VAR 0 5
77203: IN
77204: PUSH
77205: LD_INT 28
77207: PUSH
77208: LD_VAR 0 5
77212: IN
77213: OR
77214: PUSH
77215: LD_INT 45
77217: PUSH
77218: LD_VAR 0 5
77222: IN
77223: OR
77224: AND
77225: IFFALSE 77479
// begin hex := GetHexInfo ( x , y ) ;
77227: LD_ADDR_VAR 0 4
77231: PUSH
77232: LD_VAR 0 10
77236: PPUSH
77237: LD_VAR 0 11
77241: PPUSH
77242: CALL_OW 546
77246: ST_TO_ADDR
// if hex [ 1 ] then
77247: LD_VAR 0 4
77251: PUSH
77252: LD_INT 1
77254: ARRAY
77255: IFFALSE 77259
// exit ;
77257: GO 77662
// height := hex [ 2 ] ;
77259: LD_ADDR_VAR 0 15
77263: PUSH
77264: LD_VAR 0 4
77268: PUSH
77269: LD_INT 2
77271: ARRAY
77272: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77273: LD_ADDR_VAR 0 14
77277: PUSH
77278: LD_INT 0
77280: PUSH
77281: LD_INT 2
77283: PUSH
77284: LD_INT 3
77286: PUSH
77287: LD_INT 5
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: LIST
77294: LIST
77295: ST_TO_ADDR
// for i in tmp do
77296: LD_ADDR_VAR 0 8
77300: PUSH
77301: LD_VAR 0 14
77305: PUSH
77306: FOR_IN
77307: IFFALSE 77477
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77309: LD_ADDR_VAR 0 9
77313: PUSH
77314: LD_VAR 0 10
77318: PPUSH
77319: LD_VAR 0 8
77323: PPUSH
77324: LD_INT 5
77326: PPUSH
77327: CALL_OW 272
77331: PUSH
77332: LD_VAR 0 11
77336: PPUSH
77337: LD_VAR 0 8
77341: PPUSH
77342: LD_INT 5
77344: PPUSH
77345: CALL_OW 273
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77354: LD_VAR 0 9
77358: PUSH
77359: LD_INT 1
77361: ARRAY
77362: PPUSH
77363: LD_VAR 0 9
77367: PUSH
77368: LD_INT 2
77370: ARRAY
77371: PPUSH
77372: CALL_OW 488
77376: IFFALSE 77475
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77378: LD_ADDR_VAR 0 4
77382: PUSH
77383: LD_VAR 0 9
77387: PUSH
77388: LD_INT 1
77390: ARRAY
77391: PPUSH
77392: LD_VAR 0 9
77396: PUSH
77397: LD_INT 2
77399: ARRAY
77400: PPUSH
77401: CALL_OW 546
77405: ST_TO_ADDR
// if hex [ 1 ] then
77406: LD_VAR 0 4
77410: PUSH
77411: LD_INT 1
77413: ARRAY
77414: IFFALSE 77418
// continue ;
77416: GO 77306
// h := hex [ 2 ] ;
77418: LD_ADDR_VAR 0 13
77422: PUSH
77423: LD_VAR 0 4
77427: PUSH
77428: LD_INT 2
77430: ARRAY
77431: ST_TO_ADDR
// if h + 7 < height then
77432: LD_VAR 0 13
77436: PUSH
77437: LD_INT 7
77439: PLUS
77440: PUSH
77441: LD_VAR 0 15
77445: LESS
77446: IFFALSE 77475
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77448: LD_ADDR_VAR 0 18
77452: PUSH
77453: LD_INT 7
77455: PUSH
77456: LD_INT 28
77458: PUSH
77459: LD_INT 45
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: LIST
77466: PUSH
77467: LD_VAR 0 12
77471: ARRAY
77472: ST_TO_ADDR
// break ;
77473: GO 77477
// end ; end ; end ;
77475: GO 77306
77477: POP
77478: POP
// end ; if not weapon then
77479: LD_VAR 0 18
77483: NOT
77484: IFFALSE 77544
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77486: LD_ADDR_VAR 0 5
77490: PUSH
77491: LD_VAR 0 5
77495: PUSH
77496: LD_INT 11
77498: PUSH
77499: LD_INT 30
77501: PUSH
77502: LD_INT 49
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: LIST
77509: DIFF
77510: ST_TO_ADDR
// if not list then
77511: LD_VAR 0 5
77515: NOT
77516: IFFALSE 77520
// exit ;
77518: GO 77662
// weapon := list [ rand ( 1 , list ) ] ;
77520: LD_ADDR_VAR 0 18
77524: PUSH
77525: LD_VAR 0 5
77529: PUSH
77530: LD_INT 1
77532: PPUSH
77533: LD_VAR 0 5
77537: PPUSH
77538: CALL_OW 12
77542: ARRAY
77543: ST_TO_ADDR
// end ; if weapon then
77544: LD_VAR 0 18
77548: IFFALSE 77662
// begin tmp := CostOfWeapon ( weapon ) ;
77550: LD_ADDR_VAR 0 14
77554: PUSH
77555: LD_VAR 0 18
77559: PPUSH
77560: CALL_OW 451
77564: ST_TO_ADDR
// j := GetBase ( tower ) ;
77565: LD_ADDR_VAR 0 9
77569: PUSH
77570: LD_VAR 0 1
77574: PPUSH
77575: CALL_OW 274
77579: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77580: LD_VAR 0 9
77584: PPUSH
77585: LD_INT 1
77587: PPUSH
77588: CALL_OW 275
77592: PUSH
77593: LD_VAR 0 14
77597: PUSH
77598: LD_INT 1
77600: ARRAY
77601: GREATEREQUAL
77602: PUSH
77603: LD_VAR 0 9
77607: PPUSH
77608: LD_INT 2
77610: PPUSH
77611: CALL_OW 275
77615: PUSH
77616: LD_VAR 0 14
77620: PUSH
77621: LD_INT 2
77623: ARRAY
77624: GREATEREQUAL
77625: AND
77626: PUSH
77627: LD_VAR 0 9
77631: PPUSH
77632: LD_INT 3
77634: PPUSH
77635: CALL_OW 275
77639: PUSH
77640: LD_VAR 0 14
77644: PUSH
77645: LD_INT 3
77647: ARRAY
77648: GREATEREQUAL
77649: AND
77650: IFFALSE 77662
// result := weapon ;
77652: LD_ADDR_VAR 0 3
77656: PUSH
77657: LD_VAR 0 18
77661: ST_TO_ADDR
// end ; end ;
77662: LD_VAR 0 3
77666: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77667: LD_INT 0
77669: PPUSH
77670: PPUSH
// result := true ;
77671: LD_ADDR_VAR 0 3
77675: PUSH
77676: LD_INT 1
77678: ST_TO_ADDR
// if array1 = array2 then
77679: LD_VAR 0 1
77683: PUSH
77684: LD_VAR 0 2
77688: EQUAL
77689: IFFALSE 77749
// begin for i = 1 to array1 do
77691: LD_ADDR_VAR 0 4
77695: PUSH
77696: DOUBLE
77697: LD_INT 1
77699: DEC
77700: ST_TO_ADDR
77701: LD_VAR 0 1
77705: PUSH
77706: FOR_TO
77707: IFFALSE 77745
// if array1 [ i ] <> array2 [ i ] then
77709: LD_VAR 0 1
77713: PUSH
77714: LD_VAR 0 4
77718: ARRAY
77719: PUSH
77720: LD_VAR 0 2
77724: PUSH
77725: LD_VAR 0 4
77729: ARRAY
77730: NONEQUAL
77731: IFFALSE 77743
// begin result := false ;
77733: LD_ADDR_VAR 0 3
77737: PUSH
77738: LD_INT 0
77740: ST_TO_ADDR
// break ;
77741: GO 77745
// end ;
77743: GO 77706
77745: POP
77746: POP
// end else
77747: GO 77757
// result := false ;
77749: LD_ADDR_VAR 0 3
77753: PUSH
77754: LD_INT 0
77756: ST_TO_ADDR
// end ;
77757: LD_VAR 0 3
77761: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77762: LD_INT 0
77764: PPUSH
77765: PPUSH
77766: PPUSH
// pom := GetBase ( fac ) ;
77767: LD_ADDR_VAR 0 5
77771: PUSH
77772: LD_VAR 0 1
77776: PPUSH
77777: CALL_OW 274
77781: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77782: LD_ADDR_VAR 0 4
77786: PUSH
77787: LD_VAR 0 2
77791: PUSH
77792: LD_INT 1
77794: ARRAY
77795: PPUSH
77796: LD_VAR 0 2
77800: PUSH
77801: LD_INT 2
77803: ARRAY
77804: PPUSH
77805: LD_VAR 0 2
77809: PUSH
77810: LD_INT 3
77812: ARRAY
77813: PPUSH
77814: LD_VAR 0 2
77818: PUSH
77819: LD_INT 4
77821: ARRAY
77822: PPUSH
77823: CALL_OW 449
77827: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77828: LD_ADDR_VAR 0 3
77832: PUSH
77833: LD_VAR 0 5
77837: PPUSH
77838: LD_INT 1
77840: PPUSH
77841: CALL_OW 275
77845: PUSH
77846: LD_VAR 0 4
77850: PUSH
77851: LD_INT 1
77853: ARRAY
77854: GREATEREQUAL
77855: PUSH
77856: LD_VAR 0 5
77860: PPUSH
77861: LD_INT 2
77863: PPUSH
77864: CALL_OW 275
77868: PUSH
77869: LD_VAR 0 4
77873: PUSH
77874: LD_INT 2
77876: ARRAY
77877: GREATEREQUAL
77878: AND
77879: PUSH
77880: LD_VAR 0 5
77884: PPUSH
77885: LD_INT 3
77887: PPUSH
77888: CALL_OW 275
77892: PUSH
77893: LD_VAR 0 4
77897: PUSH
77898: LD_INT 3
77900: ARRAY
77901: GREATEREQUAL
77902: AND
77903: ST_TO_ADDR
// end ;
77904: LD_VAR 0 3
77908: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77909: LD_INT 0
77911: PPUSH
77912: PPUSH
77913: PPUSH
77914: PPUSH
// pom := GetBase ( building ) ;
77915: LD_ADDR_VAR 0 3
77919: PUSH
77920: LD_VAR 0 1
77924: PPUSH
77925: CALL_OW 274
77929: ST_TO_ADDR
// if not pom then
77930: LD_VAR 0 3
77934: NOT
77935: IFFALSE 77939
// exit ;
77937: GO 78109
// btype := GetBType ( building ) ;
77939: LD_ADDR_VAR 0 5
77943: PUSH
77944: LD_VAR 0 1
77948: PPUSH
77949: CALL_OW 266
77953: ST_TO_ADDR
// if btype = b_armoury then
77954: LD_VAR 0 5
77958: PUSH
77959: LD_INT 4
77961: EQUAL
77962: IFFALSE 77972
// btype := b_barracks ;
77964: LD_ADDR_VAR 0 5
77968: PUSH
77969: LD_INT 5
77971: ST_TO_ADDR
// if btype = b_depot then
77972: LD_VAR 0 5
77976: PUSH
77977: LD_INT 0
77979: EQUAL
77980: IFFALSE 77990
// btype := b_warehouse ;
77982: LD_ADDR_VAR 0 5
77986: PUSH
77987: LD_INT 1
77989: ST_TO_ADDR
// if btype = b_workshop then
77990: LD_VAR 0 5
77994: PUSH
77995: LD_INT 2
77997: EQUAL
77998: IFFALSE 78008
// btype := b_factory ;
78000: LD_ADDR_VAR 0 5
78004: PUSH
78005: LD_INT 3
78007: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78008: LD_ADDR_VAR 0 4
78012: PUSH
78013: LD_VAR 0 5
78017: PPUSH
78018: LD_VAR 0 1
78022: PPUSH
78023: CALL_OW 248
78027: PPUSH
78028: CALL_OW 450
78032: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78033: LD_ADDR_VAR 0 2
78037: PUSH
78038: LD_VAR 0 3
78042: PPUSH
78043: LD_INT 1
78045: PPUSH
78046: CALL_OW 275
78050: PUSH
78051: LD_VAR 0 4
78055: PUSH
78056: LD_INT 1
78058: ARRAY
78059: GREATEREQUAL
78060: PUSH
78061: LD_VAR 0 3
78065: PPUSH
78066: LD_INT 2
78068: PPUSH
78069: CALL_OW 275
78073: PUSH
78074: LD_VAR 0 4
78078: PUSH
78079: LD_INT 2
78081: ARRAY
78082: GREATEREQUAL
78083: AND
78084: PUSH
78085: LD_VAR 0 3
78089: PPUSH
78090: LD_INT 3
78092: PPUSH
78093: CALL_OW 275
78097: PUSH
78098: LD_VAR 0 4
78102: PUSH
78103: LD_INT 3
78105: ARRAY
78106: GREATEREQUAL
78107: AND
78108: ST_TO_ADDR
// end ;
78109: LD_VAR 0 2
78113: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78114: LD_INT 0
78116: PPUSH
78117: PPUSH
78118: PPUSH
// pom := GetBase ( building ) ;
78119: LD_ADDR_VAR 0 4
78123: PUSH
78124: LD_VAR 0 1
78128: PPUSH
78129: CALL_OW 274
78133: ST_TO_ADDR
// if not pom then
78134: LD_VAR 0 4
78138: NOT
78139: IFFALSE 78143
// exit ;
78141: GO 78244
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78143: LD_ADDR_VAR 0 5
78147: PUSH
78148: LD_VAR 0 2
78152: PPUSH
78153: LD_VAR 0 1
78157: PPUSH
78158: CALL_OW 248
78162: PPUSH
78163: CALL_OW 450
78167: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78168: LD_ADDR_VAR 0 3
78172: PUSH
78173: LD_VAR 0 4
78177: PPUSH
78178: LD_INT 1
78180: PPUSH
78181: CALL_OW 275
78185: PUSH
78186: LD_VAR 0 5
78190: PUSH
78191: LD_INT 1
78193: ARRAY
78194: GREATEREQUAL
78195: PUSH
78196: LD_VAR 0 4
78200: PPUSH
78201: LD_INT 2
78203: PPUSH
78204: CALL_OW 275
78208: PUSH
78209: LD_VAR 0 5
78213: PUSH
78214: LD_INT 2
78216: ARRAY
78217: GREATEREQUAL
78218: AND
78219: PUSH
78220: LD_VAR 0 4
78224: PPUSH
78225: LD_INT 3
78227: PPUSH
78228: CALL_OW 275
78232: PUSH
78233: LD_VAR 0 5
78237: PUSH
78238: LD_INT 3
78240: ARRAY
78241: GREATEREQUAL
78242: AND
78243: ST_TO_ADDR
// end ;
78244: LD_VAR 0 3
78248: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78249: LD_INT 0
78251: PPUSH
78252: PPUSH
78253: PPUSH
78254: PPUSH
78255: PPUSH
78256: PPUSH
78257: PPUSH
78258: PPUSH
78259: PPUSH
78260: PPUSH
// result := false ;
78261: LD_ADDR_VAR 0 6
78265: PUSH
78266: LD_INT 0
78268: ST_TO_ADDR
// if not base or not btype or not x or not y then
78269: LD_VAR 0 1
78273: NOT
78274: PUSH
78275: LD_VAR 0 2
78279: NOT
78280: OR
78281: PUSH
78282: LD_VAR 0 3
78286: NOT
78287: OR
78288: PUSH
78289: LD_VAR 0 4
78293: NOT
78294: OR
78295: IFFALSE 78299
// exit ;
78297: GO 78908
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78299: LD_ADDR_VAR 0 12
78303: PUSH
78304: LD_VAR 0 2
78308: PPUSH
78309: LD_VAR 0 3
78313: PPUSH
78314: LD_VAR 0 4
78318: PPUSH
78319: LD_VAR 0 5
78323: PPUSH
78324: LD_VAR 0 1
78328: PUSH
78329: LD_INT 1
78331: ARRAY
78332: PPUSH
78333: CALL_OW 248
78337: PPUSH
78338: LD_INT 0
78340: PPUSH
78341: CALL 79745 0 6
78345: ST_TO_ADDR
// if not hexes then
78346: LD_VAR 0 12
78350: NOT
78351: IFFALSE 78355
// exit ;
78353: GO 78908
// for i = 1 to hexes do
78355: LD_ADDR_VAR 0 7
78359: PUSH
78360: DOUBLE
78361: LD_INT 1
78363: DEC
78364: ST_TO_ADDR
78365: LD_VAR 0 12
78369: PUSH
78370: FOR_TO
78371: IFFALSE 78906
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78373: LD_ADDR_VAR 0 11
78377: PUSH
78378: LD_VAR 0 12
78382: PUSH
78383: LD_VAR 0 7
78387: ARRAY
78388: PUSH
78389: LD_INT 1
78391: ARRAY
78392: PPUSH
78393: LD_VAR 0 12
78397: PUSH
78398: LD_VAR 0 7
78402: ARRAY
78403: PUSH
78404: LD_INT 2
78406: ARRAY
78407: PPUSH
78408: CALL_OW 428
78412: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78413: LD_VAR 0 12
78417: PUSH
78418: LD_VAR 0 7
78422: ARRAY
78423: PUSH
78424: LD_INT 1
78426: ARRAY
78427: PPUSH
78428: LD_VAR 0 12
78432: PUSH
78433: LD_VAR 0 7
78437: ARRAY
78438: PUSH
78439: LD_INT 2
78441: ARRAY
78442: PPUSH
78443: CALL_OW 351
78447: PUSH
78448: LD_VAR 0 12
78452: PUSH
78453: LD_VAR 0 7
78457: ARRAY
78458: PUSH
78459: LD_INT 1
78461: ARRAY
78462: PPUSH
78463: LD_VAR 0 12
78467: PUSH
78468: LD_VAR 0 7
78472: ARRAY
78473: PUSH
78474: LD_INT 2
78476: ARRAY
78477: PPUSH
78478: CALL_OW 488
78482: NOT
78483: OR
78484: PUSH
78485: LD_VAR 0 11
78489: PPUSH
78490: CALL_OW 247
78494: PUSH
78495: LD_INT 3
78497: EQUAL
78498: OR
78499: IFFALSE 78505
// exit ;
78501: POP
78502: POP
78503: GO 78908
// if not tmp or not tmp in base then
78505: LD_VAR 0 11
78509: NOT
78510: PUSH
78511: LD_VAR 0 11
78515: PUSH
78516: LD_VAR 0 1
78520: IN
78521: NOT
78522: OR
78523: IFFALSE 78527
// continue ;
78525: GO 78370
// result := true ;
78527: LD_ADDR_VAR 0 6
78531: PUSH
78532: LD_INT 1
78534: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78535: LD_ADDR_VAR 0 15
78539: PUSH
78540: LD_VAR 0 1
78544: PPUSH
78545: LD_INT 22
78547: PUSH
78548: LD_VAR 0 11
78552: PPUSH
78553: CALL_OW 255
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: LD_INT 2
78564: PUSH
78565: LD_INT 30
78567: PUSH
78568: LD_INT 0
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 30
78577: PUSH
78578: LD_INT 1
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: LIST
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PPUSH
78594: CALL_OW 72
78598: ST_TO_ADDR
// if dep then
78599: LD_VAR 0 15
78603: IFFALSE 78739
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78605: LD_ADDR_VAR 0 14
78609: PUSH
78610: LD_VAR 0 15
78614: PUSH
78615: LD_INT 1
78617: ARRAY
78618: PPUSH
78619: CALL_OW 250
78623: PPUSH
78624: LD_VAR 0 15
78628: PUSH
78629: LD_INT 1
78631: ARRAY
78632: PPUSH
78633: CALL_OW 254
78637: PPUSH
78638: LD_INT 5
78640: PPUSH
78641: CALL_OW 272
78645: PUSH
78646: LD_VAR 0 15
78650: PUSH
78651: LD_INT 1
78653: ARRAY
78654: PPUSH
78655: CALL_OW 251
78659: PPUSH
78660: LD_VAR 0 15
78664: PUSH
78665: LD_INT 1
78667: ARRAY
78668: PPUSH
78669: CALL_OW 254
78673: PPUSH
78674: LD_INT 5
78676: PPUSH
78677: CALL_OW 273
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78686: LD_VAR 0 14
78690: PUSH
78691: LD_INT 1
78693: ARRAY
78694: PPUSH
78695: LD_VAR 0 14
78699: PUSH
78700: LD_INT 2
78702: ARRAY
78703: PPUSH
78704: CALL_OW 488
78708: IFFALSE 78739
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78710: LD_VAR 0 11
78714: PPUSH
78715: LD_VAR 0 14
78719: PUSH
78720: LD_INT 1
78722: ARRAY
78723: PPUSH
78724: LD_VAR 0 14
78728: PUSH
78729: LD_INT 2
78731: ARRAY
78732: PPUSH
78733: CALL_OW 111
// continue ;
78737: GO 78370
// end ; end ; r := GetDir ( tmp ) ;
78739: LD_ADDR_VAR 0 13
78743: PUSH
78744: LD_VAR 0 11
78748: PPUSH
78749: CALL_OW 254
78753: ST_TO_ADDR
// if r = 5 then
78754: LD_VAR 0 13
78758: PUSH
78759: LD_INT 5
78761: EQUAL
78762: IFFALSE 78772
// r := 0 ;
78764: LD_ADDR_VAR 0 13
78768: PUSH
78769: LD_INT 0
78771: ST_TO_ADDR
// for j = r to 5 do
78772: LD_ADDR_VAR 0 8
78776: PUSH
78777: DOUBLE
78778: LD_VAR 0 13
78782: DEC
78783: ST_TO_ADDR
78784: LD_INT 5
78786: PUSH
78787: FOR_TO
78788: IFFALSE 78902
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78790: LD_ADDR_VAR 0 9
78794: PUSH
78795: LD_VAR 0 11
78799: PPUSH
78800: CALL_OW 250
78804: PPUSH
78805: LD_VAR 0 8
78809: PPUSH
78810: LD_INT 2
78812: PPUSH
78813: CALL_OW 272
78817: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78818: LD_ADDR_VAR 0 10
78822: PUSH
78823: LD_VAR 0 11
78827: PPUSH
78828: CALL_OW 251
78832: PPUSH
78833: LD_VAR 0 8
78837: PPUSH
78838: LD_INT 2
78840: PPUSH
78841: CALL_OW 273
78845: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78846: LD_VAR 0 9
78850: PPUSH
78851: LD_VAR 0 10
78855: PPUSH
78856: CALL_OW 488
78860: PUSH
78861: LD_VAR 0 9
78865: PPUSH
78866: LD_VAR 0 10
78870: PPUSH
78871: CALL_OW 428
78875: NOT
78876: AND
78877: IFFALSE 78900
// begin ComMoveXY ( tmp , _x , _y ) ;
78879: LD_VAR 0 11
78883: PPUSH
78884: LD_VAR 0 9
78888: PPUSH
78889: LD_VAR 0 10
78893: PPUSH
78894: CALL_OW 111
// break ;
78898: GO 78902
// end ; end ;
78900: GO 78787
78902: POP
78903: POP
// end ;
78904: GO 78370
78906: POP
78907: POP
// end ;
78908: LD_VAR 0 6
78912: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78913: LD_INT 0
78915: PPUSH
78916: PPUSH
78917: PPUSH
78918: PPUSH
78919: PPUSH
78920: PPUSH
78921: PPUSH
78922: PPUSH
78923: PPUSH
78924: PPUSH
// result := false ;
78925: LD_ADDR_VAR 0 6
78929: PUSH
78930: LD_INT 0
78932: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78933: LD_VAR 0 1
78937: NOT
78938: PUSH
78939: LD_VAR 0 1
78943: PPUSH
78944: CALL_OW 266
78948: PUSH
78949: LD_INT 0
78951: PUSH
78952: LD_INT 1
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: IN
78959: NOT
78960: OR
78961: PUSH
78962: LD_VAR 0 2
78966: NOT
78967: OR
78968: PUSH
78969: LD_VAR 0 5
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: LD_INT 1
78979: PUSH
78980: LD_INT 2
78982: PUSH
78983: LD_INT 3
78985: PUSH
78986: LD_INT 4
78988: PUSH
78989: LD_INT 5
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: IN
79000: NOT
79001: OR
79002: PUSH
79003: LD_VAR 0 3
79007: PPUSH
79008: LD_VAR 0 4
79012: PPUSH
79013: CALL_OW 488
79017: NOT
79018: OR
79019: IFFALSE 79023
// exit ;
79021: GO 79740
// pom := GetBase ( depot ) ;
79023: LD_ADDR_VAR 0 10
79027: PUSH
79028: LD_VAR 0 1
79032: PPUSH
79033: CALL_OW 274
79037: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79038: LD_ADDR_VAR 0 11
79042: PUSH
79043: LD_VAR 0 2
79047: PPUSH
79048: LD_VAR 0 1
79052: PPUSH
79053: CALL_OW 248
79057: PPUSH
79058: CALL_OW 450
79062: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79063: LD_VAR 0 10
79067: PPUSH
79068: LD_INT 1
79070: PPUSH
79071: CALL_OW 275
79075: PUSH
79076: LD_VAR 0 11
79080: PUSH
79081: LD_INT 1
79083: ARRAY
79084: GREATEREQUAL
79085: PUSH
79086: LD_VAR 0 10
79090: PPUSH
79091: LD_INT 2
79093: PPUSH
79094: CALL_OW 275
79098: PUSH
79099: LD_VAR 0 11
79103: PUSH
79104: LD_INT 2
79106: ARRAY
79107: GREATEREQUAL
79108: AND
79109: PUSH
79110: LD_VAR 0 10
79114: PPUSH
79115: LD_INT 3
79117: PPUSH
79118: CALL_OW 275
79122: PUSH
79123: LD_VAR 0 11
79127: PUSH
79128: LD_INT 3
79130: ARRAY
79131: GREATEREQUAL
79132: AND
79133: NOT
79134: IFFALSE 79138
// exit ;
79136: GO 79740
// if GetBType ( depot ) = b_depot then
79138: LD_VAR 0 1
79142: PPUSH
79143: CALL_OW 266
79147: PUSH
79148: LD_INT 0
79150: EQUAL
79151: IFFALSE 79163
// dist := 28 else
79153: LD_ADDR_VAR 0 14
79157: PUSH
79158: LD_INT 28
79160: ST_TO_ADDR
79161: GO 79171
// dist := 36 ;
79163: LD_ADDR_VAR 0 14
79167: PUSH
79168: LD_INT 36
79170: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79171: LD_VAR 0 1
79175: PPUSH
79176: LD_VAR 0 3
79180: PPUSH
79181: LD_VAR 0 4
79185: PPUSH
79186: CALL_OW 297
79190: PUSH
79191: LD_VAR 0 14
79195: GREATER
79196: IFFALSE 79200
// exit ;
79198: GO 79740
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79200: LD_ADDR_VAR 0 12
79204: PUSH
79205: LD_VAR 0 2
79209: PPUSH
79210: LD_VAR 0 3
79214: PPUSH
79215: LD_VAR 0 4
79219: PPUSH
79220: LD_VAR 0 5
79224: PPUSH
79225: LD_VAR 0 1
79229: PPUSH
79230: CALL_OW 248
79234: PPUSH
79235: LD_INT 0
79237: PPUSH
79238: CALL 79745 0 6
79242: ST_TO_ADDR
// if not hexes then
79243: LD_VAR 0 12
79247: NOT
79248: IFFALSE 79252
// exit ;
79250: GO 79740
// hex := GetHexInfo ( x , y ) ;
79252: LD_ADDR_VAR 0 15
79256: PUSH
79257: LD_VAR 0 3
79261: PPUSH
79262: LD_VAR 0 4
79266: PPUSH
79267: CALL_OW 546
79271: ST_TO_ADDR
// if hex [ 1 ] then
79272: LD_VAR 0 15
79276: PUSH
79277: LD_INT 1
79279: ARRAY
79280: IFFALSE 79284
// exit ;
79282: GO 79740
// height := hex [ 2 ] ;
79284: LD_ADDR_VAR 0 13
79288: PUSH
79289: LD_VAR 0 15
79293: PUSH
79294: LD_INT 2
79296: ARRAY
79297: ST_TO_ADDR
// for i = 1 to hexes do
79298: LD_ADDR_VAR 0 7
79302: PUSH
79303: DOUBLE
79304: LD_INT 1
79306: DEC
79307: ST_TO_ADDR
79308: LD_VAR 0 12
79312: PUSH
79313: FOR_TO
79314: IFFALSE 79644
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79316: LD_VAR 0 12
79320: PUSH
79321: LD_VAR 0 7
79325: ARRAY
79326: PUSH
79327: LD_INT 1
79329: ARRAY
79330: PPUSH
79331: LD_VAR 0 12
79335: PUSH
79336: LD_VAR 0 7
79340: ARRAY
79341: PUSH
79342: LD_INT 2
79344: ARRAY
79345: PPUSH
79346: CALL_OW 488
79350: NOT
79351: PUSH
79352: LD_VAR 0 12
79356: PUSH
79357: LD_VAR 0 7
79361: ARRAY
79362: PUSH
79363: LD_INT 1
79365: ARRAY
79366: PPUSH
79367: LD_VAR 0 12
79371: PUSH
79372: LD_VAR 0 7
79376: ARRAY
79377: PUSH
79378: LD_INT 2
79380: ARRAY
79381: PPUSH
79382: CALL_OW 428
79386: PUSH
79387: LD_INT 0
79389: GREATER
79390: OR
79391: PUSH
79392: LD_VAR 0 12
79396: PUSH
79397: LD_VAR 0 7
79401: ARRAY
79402: PUSH
79403: LD_INT 1
79405: ARRAY
79406: PPUSH
79407: LD_VAR 0 12
79411: PUSH
79412: LD_VAR 0 7
79416: ARRAY
79417: PUSH
79418: LD_INT 2
79420: ARRAY
79421: PPUSH
79422: CALL_OW 351
79426: OR
79427: IFFALSE 79433
// exit ;
79429: POP
79430: POP
79431: GO 79740
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79433: LD_ADDR_VAR 0 8
79437: PUSH
79438: LD_VAR 0 12
79442: PUSH
79443: LD_VAR 0 7
79447: ARRAY
79448: PUSH
79449: LD_INT 1
79451: ARRAY
79452: PPUSH
79453: LD_VAR 0 12
79457: PUSH
79458: LD_VAR 0 7
79462: ARRAY
79463: PUSH
79464: LD_INT 2
79466: ARRAY
79467: PPUSH
79468: CALL_OW 546
79472: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79473: LD_VAR 0 8
79477: PUSH
79478: LD_INT 1
79480: ARRAY
79481: PUSH
79482: LD_VAR 0 8
79486: PUSH
79487: LD_INT 2
79489: ARRAY
79490: PUSH
79491: LD_VAR 0 13
79495: PUSH
79496: LD_INT 2
79498: PLUS
79499: GREATER
79500: OR
79501: PUSH
79502: LD_VAR 0 8
79506: PUSH
79507: LD_INT 2
79509: ARRAY
79510: PUSH
79511: LD_VAR 0 13
79515: PUSH
79516: LD_INT 2
79518: MINUS
79519: LESS
79520: OR
79521: PUSH
79522: LD_VAR 0 8
79526: PUSH
79527: LD_INT 3
79529: ARRAY
79530: PUSH
79531: LD_INT 0
79533: PUSH
79534: LD_INT 8
79536: PUSH
79537: LD_INT 9
79539: PUSH
79540: LD_INT 10
79542: PUSH
79543: LD_INT 11
79545: PUSH
79546: LD_INT 12
79548: PUSH
79549: LD_INT 13
79551: PUSH
79552: LD_INT 16
79554: PUSH
79555: LD_INT 17
79557: PUSH
79558: LD_INT 18
79560: PUSH
79561: LD_INT 19
79563: PUSH
79564: LD_INT 20
79566: PUSH
79567: LD_INT 21
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: LIST
79574: LIST
79575: LIST
79576: LIST
79577: LIST
79578: LIST
79579: LIST
79580: LIST
79581: LIST
79582: LIST
79583: LIST
79584: IN
79585: NOT
79586: OR
79587: PUSH
79588: LD_VAR 0 8
79592: PUSH
79593: LD_INT 5
79595: ARRAY
79596: NOT
79597: OR
79598: PUSH
79599: LD_VAR 0 8
79603: PUSH
79604: LD_INT 6
79606: ARRAY
79607: PUSH
79608: LD_INT 1
79610: PUSH
79611: LD_INT 2
79613: PUSH
79614: LD_INT 7
79616: PUSH
79617: LD_INT 9
79619: PUSH
79620: LD_INT 10
79622: PUSH
79623: LD_INT 11
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: IN
79634: NOT
79635: OR
79636: IFFALSE 79642
// exit ;
79638: POP
79639: POP
79640: GO 79740
// end ;
79642: GO 79313
79644: POP
79645: POP
// side := GetSide ( depot ) ;
79646: LD_ADDR_VAR 0 9
79650: PUSH
79651: LD_VAR 0 1
79655: PPUSH
79656: CALL_OW 255
79660: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79661: LD_VAR 0 9
79665: PPUSH
79666: LD_VAR 0 3
79670: PPUSH
79671: LD_VAR 0 4
79675: PPUSH
79676: LD_INT 20
79678: PPUSH
79679: CALL 72394 0 4
79683: PUSH
79684: LD_INT 4
79686: ARRAY
79687: IFFALSE 79691
// exit ;
79689: GO 79740
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79691: LD_VAR 0 2
79695: PUSH
79696: LD_INT 29
79698: PUSH
79699: LD_INT 30
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: IN
79706: PUSH
79707: LD_VAR 0 3
79711: PPUSH
79712: LD_VAR 0 4
79716: PPUSH
79717: LD_VAR 0 9
79721: PPUSH
79722: CALL_OW 440
79726: NOT
79727: AND
79728: IFFALSE 79732
// exit ;
79730: GO 79740
// result := true ;
79732: LD_ADDR_VAR 0 6
79736: PUSH
79737: LD_INT 1
79739: ST_TO_ADDR
// end ;
79740: LD_VAR 0 6
79744: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79745: LD_INT 0
79747: PPUSH
79748: PPUSH
79749: PPUSH
79750: PPUSH
79751: PPUSH
79752: PPUSH
79753: PPUSH
79754: PPUSH
79755: PPUSH
79756: PPUSH
79757: PPUSH
79758: PPUSH
79759: PPUSH
79760: PPUSH
79761: PPUSH
79762: PPUSH
79763: PPUSH
79764: PPUSH
79765: PPUSH
79766: PPUSH
79767: PPUSH
79768: PPUSH
79769: PPUSH
79770: PPUSH
79771: PPUSH
79772: PPUSH
79773: PPUSH
79774: PPUSH
79775: PPUSH
79776: PPUSH
79777: PPUSH
79778: PPUSH
79779: PPUSH
79780: PPUSH
79781: PPUSH
79782: PPUSH
79783: PPUSH
79784: PPUSH
79785: PPUSH
79786: PPUSH
79787: PPUSH
79788: PPUSH
79789: PPUSH
79790: PPUSH
79791: PPUSH
79792: PPUSH
79793: PPUSH
79794: PPUSH
79795: PPUSH
79796: PPUSH
79797: PPUSH
79798: PPUSH
79799: PPUSH
79800: PPUSH
79801: PPUSH
79802: PPUSH
79803: PPUSH
79804: PPUSH
// result = [ ] ;
79805: LD_ADDR_VAR 0 7
79809: PUSH
79810: EMPTY
79811: ST_TO_ADDR
// temp_list = [ ] ;
79812: LD_ADDR_VAR 0 9
79816: PUSH
79817: EMPTY
79818: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79819: LD_VAR 0 4
79823: PUSH
79824: LD_INT 0
79826: PUSH
79827: LD_INT 1
79829: PUSH
79830: LD_INT 2
79832: PUSH
79833: LD_INT 3
79835: PUSH
79836: LD_INT 4
79838: PUSH
79839: LD_INT 5
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: IN
79850: NOT
79851: PUSH
79852: LD_VAR 0 1
79856: PUSH
79857: LD_INT 0
79859: PUSH
79860: LD_INT 1
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: IN
79867: PUSH
79868: LD_VAR 0 5
79872: PUSH
79873: LD_INT 1
79875: PUSH
79876: LD_INT 2
79878: PUSH
79879: LD_INT 3
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: LIST
79886: IN
79887: NOT
79888: AND
79889: OR
79890: IFFALSE 79894
// exit ;
79892: GO 98285
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79894: LD_VAR 0 1
79898: PUSH
79899: LD_INT 6
79901: PUSH
79902: LD_INT 7
79904: PUSH
79905: LD_INT 8
79907: PUSH
79908: LD_INT 13
79910: PUSH
79911: LD_INT 12
79913: PUSH
79914: LD_INT 15
79916: PUSH
79917: LD_INT 11
79919: PUSH
79920: LD_INT 14
79922: PUSH
79923: LD_INT 10
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: IN
79937: IFFALSE 79947
// btype = b_lab ;
79939: LD_ADDR_VAR 0 1
79943: PUSH
79944: LD_INT 6
79946: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79947: LD_VAR 0 6
79951: PUSH
79952: LD_INT 0
79954: PUSH
79955: LD_INT 1
79957: PUSH
79958: LD_INT 2
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: LIST
79965: IN
79966: NOT
79967: PUSH
79968: LD_VAR 0 1
79972: PUSH
79973: LD_INT 0
79975: PUSH
79976: LD_INT 1
79978: PUSH
79979: LD_INT 2
79981: PUSH
79982: LD_INT 3
79984: PUSH
79985: LD_INT 6
79987: PUSH
79988: LD_INT 36
79990: PUSH
79991: LD_INT 4
79993: PUSH
79994: LD_INT 5
79996: PUSH
79997: LD_INT 31
79999: PUSH
80000: LD_INT 32
80002: PUSH
80003: LD_INT 33
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: IN
80019: NOT
80020: PUSH
80021: LD_VAR 0 6
80025: PUSH
80026: LD_INT 1
80028: EQUAL
80029: AND
80030: OR
80031: PUSH
80032: LD_VAR 0 1
80036: PUSH
80037: LD_INT 2
80039: PUSH
80040: LD_INT 3
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: IN
80047: NOT
80048: PUSH
80049: LD_VAR 0 6
80053: PUSH
80054: LD_INT 2
80056: EQUAL
80057: AND
80058: OR
80059: IFFALSE 80069
// mode = 0 ;
80061: LD_ADDR_VAR 0 6
80065: PUSH
80066: LD_INT 0
80068: ST_TO_ADDR
// case mode of 0 :
80069: LD_VAR 0 6
80073: PUSH
80074: LD_INT 0
80076: DOUBLE
80077: EQUAL
80078: IFTRUE 80082
80080: GO 91535
80082: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80083: LD_ADDR_VAR 0 11
80087: PUSH
80088: LD_INT 0
80090: PUSH
80091: LD_INT 0
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 0
80100: PUSH
80101: LD_INT 1
80103: NEG
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 1
80111: PUSH
80112: LD_INT 0
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 1
80121: PUSH
80122: LD_INT 1
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 0
80131: PUSH
80132: LD_INT 1
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 1
80141: NEG
80142: PUSH
80143: LD_INT 0
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 1
80152: NEG
80153: PUSH
80154: LD_INT 1
80156: NEG
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: LD_INT 1
80164: NEG
80165: PUSH
80166: LD_INT 2
80168: NEG
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 0
80176: PUSH
80177: LD_INT 2
80179: NEG
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_INT 1
80187: PUSH
80188: LD_INT 1
80190: NEG
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 1
80198: PUSH
80199: LD_INT 2
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: PUSH
80206: LD_INT 0
80208: PUSH
80209: LD_INT 2
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 1
80218: NEG
80219: PUSH
80220: LD_INT 1
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 1
80229: PUSH
80230: LD_INT 3
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 0
80239: PUSH
80240: LD_INT 3
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 1
80249: NEG
80250: PUSH
80251: LD_INT 2
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: LIST
80262: LIST
80263: LIST
80264: LIST
80265: LIST
80266: LIST
80267: LIST
80268: LIST
80269: LIST
80270: LIST
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80276: LD_ADDR_VAR 0 12
80280: PUSH
80281: LD_INT 0
80283: PUSH
80284: LD_INT 0
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 0
80293: PUSH
80294: LD_INT 1
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 1
80304: PUSH
80305: LD_INT 0
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 1
80314: PUSH
80315: LD_INT 1
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: LD_INT 0
80324: PUSH
80325: LD_INT 1
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 1
80334: NEG
80335: PUSH
80336: LD_INT 0
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 1
80345: NEG
80346: PUSH
80347: LD_INT 1
80349: NEG
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 1
80357: PUSH
80358: LD_INT 1
80360: NEG
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 2
80368: PUSH
80369: LD_INT 0
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: PUSH
80376: LD_INT 2
80378: PUSH
80379: LD_INT 1
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: LD_INT 1
80388: NEG
80389: PUSH
80390: LD_INT 1
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 2
80399: NEG
80400: PUSH
80401: LD_INT 0
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 2
80410: NEG
80411: PUSH
80412: LD_INT 1
80414: NEG
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 2
80422: NEG
80423: PUSH
80424: LD_INT 1
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 3
80433: NEG
80434: PUSH
80435: LD_INT 0
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 3
80444: NEG
80445: PUSH
80446: LD_INT 1
80448: NEG
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80472: LD_ADDR_VAR 0 13
80476: PUSH
80477: LD_INT 0
80479: PUSH
80480: LD_INT 0
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 0
80489: PUSH
80490: LD_INT 1
80492: NEG
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 1
80500: PUSH
80501: LD_INT 0
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 1
80510: PUSH
80511: LD_INT 1
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 0
80520: PUSH
80521: LD_INT 1
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 1
80530: NEG
80531: PUSH
80532: LD_INT 0
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 1
80541: NEG
80542: PUSH
80543: LD_INT 1
80545: NEG
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: LD_INT 1
80553: NEG
80554: PUSH
80555: LD_INT 2
80557: NEG
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: PUSH
80563: LD_INT 2
80565: PUSH
80566: LD_INT 1
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PUSH
80573: LD_INT 2
80575: PUSH
80576: LD_INT 2
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 1
80585: PUSH
80586: LD_INT 2
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: LD_INT 2
80595: NEG
80596: PUSH
80597: LD_INT 1
80599: NEG
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 2
80607: NEG
80608: PUSH
80609: LD_INT 2
80611: NEG
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 2
80619: NEG
80620: PUSH
80621: LD_INT 3
80623: NEG
80624: PUSH
80625: EMPTY
80626: LIST
80627: LIST
80628: PUSH
80629: LD_INT 3
80631: NEG
80632: PUSH
80633: LD_INT 2
80635: NEG
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 3
80643: NEG
80644: PUSH
80645: LD_INT 3
80647: NEG
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: LIST
80669: LIST
80670: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80671: LD_ADDR_VAR 0 14
80675: PUSH
80676: LD_INT 0
80678: PUSH
80679: LD_INT 0
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 0
80688: PUSH
80689: LD_INT 1
80691: NEG
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 1
80699: PUSH
80700: LD_INT 0
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 1
80709: PUSH
80710: LD_INT 1
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 0
80719: PUSH
80720: LD_INT 1
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 1
80729: NEG
80730: PUSH
80731: LD_INT 0
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 1
80740: NEG
80741: PUSH
80742: LD_INT 1
80744: NEG
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 1
80752: NEG
80753: PUSH
80754: LD_INT 2
80756: NEG
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 0
80764: PUSH
80765: LD_INT 2
80767: NEG
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: PUSH
80773: LD_INT 1
80775: PUSH
80776: LD_INT 1
80778: NEG
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 1
80786: PUSH
80787: LD_INT 2
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 0
80796: PUSH
80797: LD_INT 2
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 1
80806: NEG
80807: PUSH
80808: LD_INT 1
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 1
80817: NEG
80818: PUSH
80819: LD_INT 3
80821: NEG
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 0
80829: PUSH
80830: LD_INT 3
80832: NEG
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 1
80840: PUSH
80841: LD_INT 2
80843: NEG
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: LIST
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: LIST
80858: LIST
80859: LIST
80860: LIST
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: LIST
80866: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80867: LD_ADDR_VAR 0 15
80871: PUSH
80872: LD_INT 0
80874: PUSH
80875: LD_INT 0
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 0
80884: PUSH
80885: LD_INT 1
80887: NEG
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 1
80895: PUSH
80896: LD_INT 0
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: PUSH
80906: LD_INT 1
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 0
80915: PUSH
80916: LD_INT 1
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: PUSH
80923: LD_INT 1
80925: NEG
80926: PUSH
80927: LD_INT 0
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 1
80936: NEG
80937: PUSH
80938: LD_INT 1
80940: NEG
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 1
80948: PUSH
80949: LD_INT 1
80951: NEG
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 2
80959: PUSH
80960: LD_INT 0
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: LD_INT 2
80969: PUSH
80970: LD_INT 1
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 1
80979: NEG
80980: PUSH
80981: LD_INT 1
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PUSH
80988: LD_INT 2
80990: NEG
80991: PUSH
80992: LD_INT 0
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 2
81001: NEG
81002: PUSH
81003: LD_INT 1
81005: NEG
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 2
81013: PUSH
81014: LD_INT 1
81016: NEG
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 3
81024: PUSH
81025: LD_INT 0
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 3
81034: PUSH
81035: LD_INT 1
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: EMPTY
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81060: LD_ADDR_VAR 0 16
81064: PUSH
81065: LD_INT 0
81067: PUSH
81068: LD_INT 0
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 0
81077: PUSH
81078: LD_INT 1
81080: NEG
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: LD_INT 1
81088: PUSH
81089: LD_INT 0
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PUSH
81096: LD_INT 1
81098: PUSH
81099: LD_INT 1
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PUSH
81106: LD_INT 0
81108: PUSH
81109: LD_INT 1
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: LD_INT 1
81118: NEG
81119: PUSH
81120: LD_INT 0
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: LD_INT 1
81129: NEG
81130: PUSH
81131: LD_INT 1
81133: NEG
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 1
81141: NEG
81142: PUSH
81143: LD_INT 2
81145: NEG
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 2
81153: PUSH
81154: LD_INT 1
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 2
81163: PUSH
81164: LD_INT 2
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 1
81173: PUSH
81174: LD_INT 2
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: PUSH
81181: LD_INT 2
81183: NEG
81184: PUSH
81185: LD_INT 1
81187: NEG
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: PUSH
81193: LD_INT 2
81195: NEG
81196: PUSH
81197: LD_INT 2
81199: NEG
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 3
81207: PUSH
81208: LD_INT 2
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 3
81217: PUSH
81218: LD_INT 3
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 2
81227: PUSH
81228: LD_INT 3
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: EMPTY
81236: LIST
81237: LIST
81238: LIST
81239: LIST
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: LIST
81245: LIST
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81253: LD_ADDR_VAR 0 17
81257: PUSH
81258: LD_INT 0
81260: PUSH
81261: LD_INT 0
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 0
81270: PUSH
81271: LD_INT 1
81273: NEG
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 1
81281: PUSH
81282: LD_INT 0
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: LD_INT 1
81291: PUSH
81292: LD_INT 1
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: PUSH
81299: LD_INT 0
81301: PUSH
81302: LD_INT 1
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 1
81311: NEG
81312: PUSH
81313: LD_INT 0
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 1
81322: NEG
81323: PUSH
81324: LD_INT 1
81326: NEG
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: PUSH
81332: LD_INT 1
81334: NEG
81335: PUSH
81336: LD_INT 2
81338: NEG
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 0
81346: PUSH
81347: LD_INT 2
81349: NEG
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 1
81357: PUSH
81358: LD_INT 1
81360: NEG
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 2
81368: PUSH
81369: LD_INT 0
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 2
81378: PUSH
81379: LD_INT 1
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 2
81388: PUSH
81389: LD_INT 2
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 1
81398: PUSH
81399: LD_INT 2
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 0
81408: PUSH
81409: LD_INT 2
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: PUSH
81416: LD_INT 1
81418: NEG
81419: PUSH
81420: LD_INT 1
81422: PUSH
81423: EMPTY
81424: LIST
81425: LIST
81426: PUSH
81427: LD_INT 2
81429: NEG
81430: PUSH
81431: LD_INT 0
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 2
81440: NEG
81441: PUSH
81442: LD_INT 1
81444: NEG
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 2
81452: NEG
81453: PUSH
81454: LD_INT 2
81456: NEG
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81483: LD_ADDR_VAR 0 18
81487: PUSH
81488: LD_INT 0
81490: PUSH
81491: LD_INT 0
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PUSH
81498: LD_INT 0
81500: PUSH
81501: LD_INT 1
81503: NEG
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 1
81511: PUSH
81512: LD_INT 0
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 1
81521: PUSH
81522: LD_INT 1
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 0
81531: PUSH
81532: LD_INT 1
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: PUSH
81539: LD_INT 1
81541: NEG
81542: PUSH
81543: LD_INT 0
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PUSH
81550: LD_INT 1
81552: NEG
81553: PUSH
81554: LD_INT 1
81556: NEG
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 1
81564: NEG
81565: PUSH
81566: LD_INT 2
81568: NEG
81569: PUSH
81570: EMPTY
81571: LIST
81572: LIST
81573: PUSH
81574: LD_INT 0
81576: PUSH
81577: LD_INT 2
81579: NEG
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: PUSH
81585: LD_INT 1
81587: PUSH
81588: LD_INT 1
81590: NEG
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 2
81598: PUSH
81599: LD_INT 0
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 2
81608: PUSH
81609: LD_INT 1
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 2
81618: PUSH
81619: LD_INT 2
81621: PUSH
81622: EMPTY
81623: LIST
81624: LIST
81625: PUSH
81626: LD_INT 1
81628: PUSH
81629: LD_INT 2
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 0
81638: PUSH
81639: LD_INT 2
81641: PUSH
81642: EMPTY
81643: LIST
81644: LIST
81645: PUSH
81646: LD_INT 1
81648: NEG
81649: PUSH
81650: LD_INT 1
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: PUSH
81657: LD_INT 2
81659: NEG
81660: PUSH
81661: LD_INT 0
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 2
81670: NEG
81671: PUSH
81672: LD_INT 1
81674: NEG
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PUSH
81680: LD_INT 2
81682: NEG
81683: PUSH
81684: LD_INT 2
81686: NEG
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81713: LD_ADDR_VAR 0 19
81717: PUSH
81718: LD_INT 0
81720: PUSH
81721: LD_INT 0
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 0
81730: PUSH
81731: LD_INT 1
81733: NEG
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 1
81741: PUSH
81742: LD_INT 0
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 1
81751: PUSH
81752: LD_INT 1
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 0
81761: PUSH
81762: LD_INT 1
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 1
81771: NEG
81772: PUSH
81773: LD_INT 0
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 1
81782: NEG
81783: PUSH
81784: LD_INT 1
81786: NEG
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: PUSH
81792: LD_INT 1
81794: NEG
81795: PUSH
81796: LD_INT 2
81798: NEG
81799: PUSH
81800: EMPTY
81801: LIST
81802: LIST
81803: PUSH
81804: LD_INT 0
81806: PUSH
81807: LD_INT 2
81809: NEG
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 1
81817: PUSH
81818: LD_INT 1
81820: NEG
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 2
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 2
81838: PUSH
81839: LD_INT 1
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 2
81848: PUSH
81849: LD_INT 2
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 1
81858: PUSH
81859: LD_INT 2
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 0
81868: PUSH
81869: LD_INT 2
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: PUSH
81876: LD_INT 1
81878: NEG
81879: PUSH
81880: LD_INT 1
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 2
81889: NEG
81890: PUSH
81891: LD_INT 0
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: LD_INT 2
81900: NEG
81901: PUSH
81902: LD_INT 1
81904: NEG
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 2
81912: NEG
81913: PUSH
81914: LD_INT 2
81916: NEG
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: LIST
81926: LIST
81927: LIST
81928: LIST
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81943: LD_ADDR_VAR 0 20
81947: PUSH
81948: LD_INT 0
81950: PUSH
81951: LD_INT 0
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 0
81960: PUSH
81961: LD_INT 1
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 1
81971: PUSH
81972: LD_INT 0
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 1
81981: PUSH
81982: LD_INT 1
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 0
81991: PUSH
81992: LD_INT 1
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 1
82001: NEG
82002: PUSH
82003: LD_INT 0
82005: PUSH
82006: EMPTY
82007: LIST
82008: LIST
82009: PUSH
82010: LD_INT 1
82012: NEG
82013: PUSH
82014: LD_INT 1
82016: NEG
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 1
82024: NEG
82025: PUSH
82026: LD_INT 2
82028: NEG
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: PUSH
82034: LD_INT 0
82036: PUSH
82037: LD_INT 2
82039: NEG
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PUSH
82045: LD_INT 1
82047: PUSH
82048: LD_INT 1
82050: NEG
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: PUSH
82056: LD_INT 2
82058: PUSH
82059: LD_INT 0
82061: PUSH
82062: EMPTY
82063: LIST
82064: LIST
82065: PUSH
82066: LD_INT 2
82068: PUSH
82069: LD_INT 1
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: LD_INT 2
82078: PUSH
82079: LD_INT 2
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: LD_INT 1
82088: PUSH
82089: LD_INT 2
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: PUSH
82096: LD_INT 0
82098: PUSH
82099: LD_INT 2
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: PUSH
82106: LD_INT 1
82108: NEG
82109: PUSH
82110: LD_INT 1
82112: PUSH
82113: EMPTY
82114: LIST
82115: LIST
82116: PUSH
82117: LD_INT 2
82119: NEG
82120: PUSH
82121: LD_INT 0
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 2
82130: NEG
82131: PUSH
82132: LD_INT 1
82134: NEG
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 2
82142: NEG
82143: PUSH
82144: LD_INT 2
82146: NEG
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82173: LD_ADDR_VAR 0 21
82177: PUSH
82178: LD_INT 0
82180: PUSH
82181: LD_INT 0
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 0
82190: PUSH
82191: LD_INT 1
82193: NEG
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 1
82201: PUSH
82202: LD_INT 0
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 1
82211: PUSH
82212: LD_INT 1
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 0
82221: PUSH
82222: LD_INT 1
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 1
82231: NEG
82232: PUSH
82233: LD_INT 0
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 1
82242: NEG
82243: PUSH
82244: LD_INT 1
82246: NEG
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 1
82254: NEG
82255: PUSH
82256: LD_INT 2
82258: NEG
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PUSH
82264: LD_INT 0
82266: PUSH
82267: LD_INT 2
82269: NEG
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 1
82277: PUSH
82278: LD_INT 1
82280: NEG
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 2
82288: PUSH
82289: LD_INT 0
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 2
82298: PUSH
82299: LD_INT 1
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PUSH
82306: LD_INT 2
82308: PUSH
82309: LD_INT 2
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: LD_INT 1
82318: PUSH
82319: LD_INT 2
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 0
82328: PUSH
82329: LD_INT 2
82331: PUSH
82332: EMPTY
82333: LIST
82334: LIST
82335: PUSH
82336: LD_INT 1
82338: NEG
82339: PUSH
82340: LD_INT 1
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 2
82349: NEG
82350: PUSH
82351: LD_INT 0
82353: PUSH
82354: EMPTY
82355: LIST
82356: LIST
82357: PUSH
82358: LD_INT 2
82360: NEG
82361: PUSH
82362: LD_INT 1
82364: NEG
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 2
82372: NEG
82373: PUSH
82374: LD_INT 2
82376: NEG
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82403: LD_ADDR_VAR 0 22
82407: PUSH
82408: LD_INT 0
82410: PUSH
82411: LD_INT 0
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: LD_INT 0
82420: PUSH
82421: LD_INT 1
82423: NEG
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 1
82431: PUSH
82432: LD_INT 0
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 1
82441: PUSH
82442: LD_INT 1
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 0
82451: PUSH
82452: LD_INT 1
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 1
82461: NEG
82462: PUSH
82463: LD_INT 0
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 1
82472: NEG
82473: PUSH
82474: LD_INT 1
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 1
82484: NEG
82485: PUSH
82486: LD_INT 2
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 0
82496: PUSH
82497: LD_INT 2
82499: NEG
82500: PUSH
82501: EMPTY
82502: LIST
82503: LIST
82504: PUSH
82505: LD_INT 1
82507: PUSH
82508: LD_INT 1
82510: NEG
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: LD_INT 2
82518: PUSH
82519: LD_INT 0
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 2
82528: PUSH
82529: LD_INT 1
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PUSH
82536: LD_INT 2
82538: PUSH
82539: LD_INT 2
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PUSH
82546: LD_INT 1
82548: PUSH
82549: LD_INT 2
82551: PUSH
82552: EMPTY
82553: LIST
82554: LIST
82555: PUSH
82556: LD_INT 0
82558: PUSH
82559: LD_INT 2
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 1
82568: NEG
82569: PUSH
82570: LD_INT 1
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: LD_INT 2
82579: NEG
82580: PUSH
82581: LD_INT 0
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 2
82590: NEG
82591: PUSH
82592: LD_INT 1
82594: NEG
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 2
82602: NEG
82603: PUSH
82604: LD_INT 2
82606: NEG
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: LIST
82616: LIST
82617: LIST
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82633: LD_ADDR_VAR 0 23
82637: PUSH
82638: LD_INT 0
82640: PUSH
82641: LD_INT 0
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 0
82650: PUSH
82651: LD_INT 1
82653: NEG
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: PUSH
82659: LD_INT 1
82661: PUSH
82662: LD_INT 0
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 1
82671: PUSH
82672: LD_INT 1
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 0
82681: PUSH
82682: LD_INT 1
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 1
82691: NEG
82692: PUSH
82693: LD_INT 0
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 1
82702: NEG
82703: PUSH
82704: LD_INT 1
82706: NEG
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 1
82714: NEG
82715: PUSH
82716: LD_INT 2
82718: NEG
82719: PUSH
82720: EMPTY
82721: LIST
82722: LIST
82723: PUSH
82724: LD_INT 0
82726: PUSH
82727: LD_INT 2
82729: NEG
82730: PUSH
82731: EMPTY
82732: LIST
82733: LIST
82734: PUSH
82735: LD_INT 1
82737: PUSH
82738: LD_INT 1
82740: NEG
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PUSH
82746: LD_INT 2
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 2
82758: PUSH
82759: LD_INT 1
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 2
82768: PUSH
82769: LD_INT 2
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 1
82778: PUSH
82779: LD_INT 2
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 0
82788: PUSH
82789: LD_INT 2
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 1
82798: NEG
82799: PUSH
82800: LD_INT 1
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: PUSH
82807: LD_INT 2
82809: NEG
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: PUSH
82818: LD_INT 2
82820: NEG
82821: PUSH
82822: LD_INT 1
82824: NEG
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: LD_INT 2
82832: NEG
82833: PUSH
82834: LD_INT 2
82836: NEG
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 2
82844: NEG
82845: PUSH
82846: LD_INT 3
82848: NEG
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 1
82856: NEG
82857: PUSH
82858: LD_INT 3
82860: NEG
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: PUSH
82866: LD_INT 1
82868: PUSH
82869: LD_INT 2
82871: NEG
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 2
82879: PUSH
82880: LD_INT 1
82882: NEG
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: EMPTY
82889: LIST
82890: LIST
82891: LIST
82892: LIST
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82913: LD_ADDR_VAR 0 24
82917: PUSH
82918: LD_INT 0
82920: PUSH
82921: LD_INT 0
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 0
82930: PUSH
82931: LD_INT 1
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 1
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 1
82951: PUSH
82952: LD_INT 1
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: LD_INT 0
82961: PUSH
82962: LD_INT 1
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 1
82971: NEG
82972: PUSH
82973: LD_INT 0
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PUSH
82980: LD_INT 1
82982: NEG
82983: PUSH
82984: LD_INT 1
82986: NEG
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PUSH
82992: LD_INT 1
82994: NEG
82995: PUSH
82996: LD_INT 2
82998: NEG
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: LD_INT 2
83009: NEG
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: LD_INT 1
83017: PUSH
83018: LD_INT 1
83020: NEG
83021: PUSH
83022: EMPTY
83023: LIST
83024: LIST
83025: PUSH
83026: LD_INT 2
83028: PUSH
83029: LD_INT 0
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 2
83038: PUSH
83039: LD_INT 1
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: PUSH
83046: LD_INT 2
83048: PUSH
83049: LD_INT 2
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 1
83058: PUSH
83059: LD_INT 2
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 0
83068: PUSH
83069: LD_INT 2
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 1
83078: NEG
83079: PUSH
83080: LD_INT 1
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 2
83089: NEG
83090: PUSH
83091: LD_INT 0
83093: PUSH
83094: EMPTY
83095: LIST
83096: LIST
83097: PUSH
83098: LD_INT 2
83100: NEG
83101: PUSH
83102: LD_INT 1
83104: NEG
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 2
83112: NEG
83113: PUSH
83114: LD_INT 2
83116: NEG
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 1
83124: PUSH
83125: LD_INT 2
83127: NEG
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 2
83135: PUSH
83136: LD_INT 1
83138: NEG
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: PUSH
83144: LD_INT 3
83146: PUSH
83147: LD_INT 1
83149: PUSH
83150: EMPTY
83151: LIST
83152: LIST
83153: PUSH
83154: LD_INT 3
83156: PUSH
83157: LD_INT 2
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: LIST
83172: LIST
83173: LIST
83174: LIST
83175: LIST
83176: LIST
83177: LIST
83178: LIST
83179: LIST
83180: LIST
83181: LIST
83182: LIST
83183: LIST
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83189: LD_ADDR_VAR 0 25
83193: PUSH
83194: LD_INT 0
83196: PUSH
83197: LD_INT 0
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 0
83206: PUSH
83207: LD_INT 1
83209: NEG
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 1
83217: PUSH
83218: LD_INT 0
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 1
83227: PUSH
83228: LD_INT 1
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 0
83237: PUSH
83238: LD_INT 1
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 1
83247: NEG
83248: PUSH
83249: LD_INT 0
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 1
83258: NEG
83259: PUSH
83260: LD_INT 1
83262: NEG
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 1
83270: NEG
83271: PUSH
83272: LD_INT 2
83274: NEG
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 0
83282: PUSH
83283: LD_INT 2
83285: NEG
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: PUSH
83291: LD_INT 1
83293: PUSH
83294: LD_INT 1
83296: NEG
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 2
83304: PUSH
83305: LD_INT 0
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 2
83314: PUSH
83315: LD_INT 1
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 2
83324: PUSH
83325: LD_INT 2
83327: PUSH
83328: EMPTY
83329: LIST
83330: LIST
83331: PUSH
83332: LD_INT 1
83334: PUSH
83335: LD_INT 2
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 0
83344: PUSH
83345: LD_INT 2
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: PUSH
83352: LD_INT 1
83354: NEG
83355: PUSH
83356: LD_INT 1
83358: PUSH
83359: EMPTY
83360: LIST
83361: LIST
83362: PUSH
83363: LD_INT 2
83365: NEG
83366: PUSH
83367: LD_INT 0
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: PUSH
83374: LD_INT 2
83376: NEG
83377: PUSH
83378: LD_INT 1
83380: NEG
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 2
83388: NEG
83389: PUSH
83390: LD_INT 2
83392: NEG
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PUSH
83398: LD_INT 3
83400: PUSH
83401: LD_INT 1
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 3
83410: PUSH
83411: LD_INT 2
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: PUSH
83418: LD_INT 2
83420: PUSH
83421: LD_INT 3
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 1
83430: PUSH
83431: LD_INT 3
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: LIST
83446: LIST
83447: LIST
83448: LIST
83449: LIST
83450: LIST
83451: LIST
83452: LIST
83453: LIST
83454: LIST
83455: LIST
83456: LIST
83457: LIST
83458: LIST
83459: LIST
83460: LIST
83461: LIST
83462: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83463: LD_ADDR_VAR 0 26
83467: PUSH
83468: LD_INT 0
83470: PUSH
83471: LD_INT 0
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: LD_INT 0
83480: PUSH
83481: LD_INT 1
83483: NEG
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 1
83491: PUSH
83492: LD_INT 0
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 1
83501: PUSH
83502: LD_INT 1
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 0
83511: PUSH
83512: LD_INT 1
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 1
83521: NEG
83522: PUSH
83523: LD_INT 0
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: PUSH
83530: LD_INT 1
83532: NEG
83533: PUSH
83534: LD_INT 1
83536: NEG
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 1
83544: NEG
83545: PUSH
83546: LD_INT 2
83548: NEG
83549: PUSH
83550: EMPTY
83551: LIST
83552: LIST
83553: PUSH
83554: LD_INT 0
83556: PUSH
83557: LD_INT 2
83559: NEG
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PUSH
83565: LD_INT 1
83567: PUSH
83568: LD_INT 1
83570: NEG
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PUSH
83576: LD_INT 2
83578: PUSH
83579: LD_INT 0
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: LD_INT 2
83588: PUSH
83589: LD_INT 1
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PUSH
83596: LD_INT 2
83598: PUSH
83599: LD_INT 2
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: PUSH
83606: LD_INT 1
83608: PUSH
83609: LD_INT 2
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: PUSH
83616: LD_INT 0
83618: PUSH
83619: LD_INT 2
83621: PUSH
83622: EMPTY
83623: LIST
83624: LIST
83625: PUSH
83626: LD_INT 1
83628: NEG
83629: PUSH
83630: LD_INT 1
83632: PUSH
83633: EMPTY
83634: LIST
83635: LIST
83636: PUSH
83637: LD_INT 2
83639: NEG
83640: PUSH
83641: LD_INT 0
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: PUSH
83648: LD_INT 2
83650: NEG
83651: PUSH
83652: LD_INT 1
83654: NEG
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: PUSH
83660: LD_INT 2
83662: NEG
83663: PUSH
83664: LD_INT 2
83666: NEG
83667: PUSH
83668: EMPTY
83669: LIST
83670: LIST
83671: PUSH
83672: LD_INT 2
83674: PUSH
83675: LD_INT 3
83677: PUSH
83678: EMPTY
83679: LIST
83680: LIST
83681: PUSH
83682: LD_INT 1
83684: PUSH
83685: LD_INT 3
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 1
83694: NEG
83695: PUSH
83696: LD_INT 2
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 2
83705: NEG
83706: PUSH
83707: LD_INT 1
83709: PUSH
83710: EMPTY
83711: LIST
83712: LIST
83713: PUSH
83714: EMPTY
83715: LIST
83716: LIST
83717: LIST
83718: LIST
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: LIST
83735: LIST
83736: LIST
83737: LIST
83738: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83739: LD_ADDR_VAR 0 27
83743: PUSH
83744: LD_INT 0
83746: PUSH
83747: LD_INT 0
83749: PUSH
83750: EMPTY
83751: LIST
83752: LIST
83753: PUSH
83754: LD_INT 0
83756: PUSH
83757: LD_INT 1
83759: NEG
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 1
83767: PUSH
83768: LD_INT 0
83770: PUSH
83771: EMPTY
83772: LIST
83773: LIST
83774: PUSH
83775: LD_INT 1
83777: PUSH
83778: LD_INT 1
83780: PUSH
83781: EMPTY
83782: LIST
83783: LIST
83784: PUSH
83785: LD_INT 0
83787: PUSH
83788: LD_INT 1
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: PUSH
83795: LD_INT 1
83797: NEG
83798: PUSH
83799: LD_INT 0
83801: PUSH
83802: EMPTY
83803: LIST
83804: LIST
83805: PUSH
83806: LD_INT 1
83808: NEG
83809: PUSH
83810: LD_INT 1
83812: NEG
83813: PUSH
83814: EMPTY
83815: LIST
83816: LIST
83817: PUSH
83818: LD_INT 1
83820: NEG
83821: PUSH
83822: LD_INT 2
83824: NEG
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: PUSH
83830: LD_INT 0
83832: PUSH
83833: LD_INT 2
83835: NEG
83836: PUSH
83837: EMPTY
83838: LIST
83839: LIST
83840: PUSH
83841: LD_INT 1
83843: PUSH
83844: LD_INT 1
83846: NEG
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PUSH
83852: LD_INT 2
83854: PUSH
83855: LD_INT 0
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: LD_INT 2
83864: PUSH
83865: LD_INT 1
83867: PUSH
83868: EMPTY
83869: LIST
83870: LIST
83871: PUSH
83872: LD_INT 2
83874: PUSH
83875: LD_INT 2
83877: PUSH
83878: EMPTY
83879: LIST
83880: LIST
83881: PUSH
83882: LD_INT 1
83884: PUSH
83885: LD_INT 2
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 0
83894: PUSH
83895: LD_INT 2
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: PUSH
83902: LD_INT 1
83904: NEG
83905: PUSH
83906: LD_INT 1
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: LD_INT 2
83915: NEG
83916: PUSH
83917: LD_INT 0
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: LD_INT 2
83926: NEG
83927: PUSH
83928: LD_INT 1
83930: NEG
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 2
83938: NEG
83939: PUSH
83940: LD_INT 2
83942: NEG
83943: PUSH
83944: EMPTY
83945: LIST
83946: LIST
83947: PUSH
83948: LD_INT 1
83950: NEG
83951: PUSH
83952: LD_INT 2
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PUSH
83959: LD_INT 2
83961: NEG
83962: PUSH
83963: LD_INT 1
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: PUSH
83970: LD_INT 3
83972: NEG
83973: PUSH
83974: LD_INT 1
83976: NEG
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: LD_INT 3
83984: NEG
83985: PUSH
83986: LD_INT 2
83988: NEG
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: LIST
84003: LIST
84004: LIST
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84019: LD_ADDR_VAR 0 28
84023: PUSH
84024: LD_INT 0
84026: PUSH
84027: LD_INT 0
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 0
84036: PUSH
84037: LD_INT 1
84039: NEG
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: PUSH
84048: LD_INT 0
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 1
84057: PUSH
84058: LD_INT 1
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 0
84067: PUSH
84068: LD_INT 1
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 1
84077: NEG
84078: PUSH
84079: LD_INT 0
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 1
84088: NEG
84089: PUSH
84090: LD_INT 1
84092: NEG
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PUSH
84098: LD_INT 1
84100: NEG
84101: PUSH
84102: LD_INT 2
84104: NEG
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: LD_INT 2
84115: NEG
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 1
84123: PUSH
84124: LD_INT 1
84126: NEG
84127: PUSH
84128: EMPTY
84129: LIST
84130: LIST
84131: PUSH
84132: LD_INT 2
84134: PUSH
84135: LD_INT 0
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 2
84144: PUSH
84145: LD_INT 1
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 2
84154: PUSH
84155: LD_INT 2
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 1
84164: PUSH
84165: LD_INT 2
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PUSH
84172: LD_INT 0
84174: PUSH
84175: LD_INT 2
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: PUSH
84182: LD_INT 1
84184: NEG
84185: PUSH
84186: LD_INT 1
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 2
84195: NEG
84196: PUSH
84197: LD_INT 0
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 2
84206: NEG
84207: PUSH
84208: LD_INT 1
84210: NEG
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 2
84218: NEG
84219: PUSH
84220: LD_INT 2
84222: NEG
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: LD_INT 2
84230: NEG
84231: PUSH
84232: LD_INT 3
84234: NEG
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 1
84242: NEG
84243: PUSH
84244: LD_INT 3
84246: NEG
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 3
84254: NEG
84255: PUSH
84256: LD_INT 1
84258: NEG
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 3
84266: NEG
84267: PUSH
84268: LD_INT 2
84270: NEG
84271: PUSH
84272: EMPTY
84273: LIST
84274: LIST
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84301: LD_ADDR_VAR 0 29
84305: PUSH
84306: LD_INT 0
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 0
84318: PUSH
84319: LD_INT 1
84321: NEG
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 1
84329: PUSH
84330: LD_INT 0
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 1
84339: PUSH
84340: LD_INT 1
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 0
84349: PUSH
84350: LD_INT 1
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: LD_INT 1
84359: NEG
84360: PUSH
84361: LD_INT 0
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: LD_INT 1
84370: NEG
84371: PUSH
84372: LD_INT 1
84374: NEG
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 1
84382: NEG
84383: PUSH
84384: LD_INT 2
84386: NEG
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 0
84394: PUSH
84395: LD_INT 2
84397: NEG
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 1
84405: PUSH
84406: LD_INT 1
84408: NEG
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 2
84416: PUSH
84417: LD_INT 0
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 2
84426: PUSH
84427: LD_INT 1
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 1
84436: PUSH
84437: LD_INT 2
84439: PUSH
84440: EMPTY
84441: LIST
84442: LIST
84443: PUSH
84444: LD_INT 0
84446: PUSH
84447: LD_INT 2
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: PUSH
84454: LD_INT 1
84456: NEG
84457: PUSH
84458: LD_INT 1
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 2
84467: NEG
84468: PUSH
84469: LD_INT 1
84471: NEG
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: LD_INT 2
84483: NEG
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: LD_INT 2
84491: NEG
84492: PUSH
84493: LD_INT 3
84495: NEG
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: LD_INT 2
84503: PUSH
84504: LD_INT 1
84506: NEG
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PUSH
84512: LD_INT 3
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 1
84524: PUSH
84525: LD_INT 3
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: PUSH
84532: LD_INT 1
84534: NEG
84535: PUSH
84536: LD_INT 2
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: PUSH
84543: LD_INT 3
84545: NEG
84546: PUSH
84547: LD_INT 2
84549: NEG
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: LIST
84559: LIST
84560: LIST
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84580: LD_ADDR_VAR 0 30
84584: PUSH
84585: LD_INT 0
84587: PUSH
84588: LD_INT 0
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 0
84597: PUSH
84598: LD_INT 1
84600: NEG
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 1
84608: PUSH
84609: LD_INT 0
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 1
84618: PUSH
84619: LD_INT 1
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: LD_INT 0
84628: PUSH
84629: LD_INT 1
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: LD_INT 1
84638: NEG
84639: PUSH
84640: LD_INT 0
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 1
84649: NEG
84650: PUSH
84651: LD_INT 1
84653: NEG
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: LD_INT 1
84661: NEG
84662: PUSH
84663: LD_INT 2
84665: NEG
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: LD_INT 2
84676: NEG
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: PUSH
84682: LD_INT 1
84684: PUSH
84685: LD_INT 1
84687: NEG
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: PUSH
84693: LD_INT 2
84695: PUSH
84696: LD_INT 0
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 2
84705: PUSH
84706: LD_INT 1
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: PUSH
84713: LD_INT 2
84715: PUSH
84716: LD_INT 2
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: PUSH
84723: LD_INT 1
84725: PUSH
84726: LD_INT 2
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 1
84735: NEG
84736: PUSH
84737: LD_INT 1
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 2
84746: NEG
84747: PUSH
84748: LD_INT 0
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 2
84757: NEG
84758: PUSH
84759: LD_INT 1
84761: NEG
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 1
84769: NEG
84770: PUSH
84771: LD_INT 3
84773: NEG
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 1
84781: PUSH
84782: LD_INT 2
84784: NEG
84785: PUSH
84786: EMPTY
84787: LIST
84788: LIST
84789: PUSH
84790: LD_INT 3
84792: PUSH
84793: LD_INT 2
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 2
84802: PUSH
84803: LD_INT 3
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: PUSH
84810: LD_INT 2
84812: NEG
84813: PUSH
84814: LD_INT 1
84816: PUSH
84817: EMPTY
84818: LIST
84819: LIST
84820: PUSH
84821: LD_INT 3
84823: NEG
84824: PUSH
84825: LD_INT 1
84827: NEG
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84858: LD_ADDR_VAR 0 31
84862: PUSH
84863: LD_INT 0
84865: PUSH
84866: LD_INT 0
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 0
84875: PUSH
84876: LD_INT 1
84878: NEG
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 1
84886: PUSH
84887: LD_INT 0
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 1
84896: PUSH
84897: LD_INT 1
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 0
84906: PUSH
84907: LD_INT 1
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 1
84916: NEG
84917: PUSH
84918: LD_INT 0
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PUSH
84925: LD_INT 1
84927: NEG
84928: PUSH
84929: LD_INT 1
84931: NEG
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_INT 1
84939: NEG
84940: PUSH
84941: LD_INT 2
84943: NEG
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 1
84951: PUSH
84952: LD_INT 1
84954: NEG
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 2
84962: PUSH
84963: LD_INT 0
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: LD_INT 2
84972: PUSH
84973: LD_INT 1
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 2
84982: PUSH
84983: LD_INT 2
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 1
84992: PUSH
84993: LD_INT 2
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: PUSH
85000: LD_INT 0
85002: PUSH
85003: LD_INT 2
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: LD_INT 1
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: LD_INT 2
85023: NEG
85024: PUSH
85025: LD_INT 1
85027: NEG
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 2
85035: NEG
85036: PUSH
85037: LD_INT 2
85039: NEG
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: PUSH
85045: LD_INT 2
85047: NEG
85048: PUSH
85049: LD_INT 3
85051: NEG
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 2
85059: PUSH
85060: LD_INT 1
85062: NEG
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: PUSH
85068: LD_INT 3
85070: PUSH
85071: LD_INT 1
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 1
85080: PUSH
85081: LD_INT 3
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 1
85090: NEG
85091: PUSH
85092: LD_INT 2
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: PUSH
85099: LD_INT 3
85101: NEG
85102: PUSH
85103: LD_INT 2
85105: NEG
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: EMPTY
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85136: LD_ADDR_VAR 0 32
85140: PUSH
85141: LD_INT 0
85143: PUSH
85144: LD_INT 0
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 0
85153: PUSH
85154: LD_INT 1
85156: NEG
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: PUSH
85162: LD_INT 1
85164: PUSH
85165: LD_INT 0
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: LD_INT 1
85174: PUSH
85175: LD_INT 1
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: PUSH
85182: LD_INT 0
85184: PUSH
85185: LD_INT 1
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: LD_INT 1
85194: NEG
85195: PUSH
85196: LD_INT 0
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: PUSH
85203: LD_INT 1
85205: NEG
85206: PUSH
85207: LD_INT 1
85209: NEG
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: LD_INT 1
85217: NEG
85218: PUSH
85219: LD_INT 2
85221: NEG
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 0
85229: PUSH
85230: LD_INT 2
85232: NEG
85233: PUSH
85234: EMPTY
85235: LIST
85236: LIST
85237: PUSH
85238: LD_INT 1
85240: PUSH
85241: LD_INT 1
85243: NEG
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 2
85251: PUSH
85252: LD_INT 1
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 2
85261: PUSH
85262: LD_INT 2
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 1
85271: PUSH
85272: LD_INT 2
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 0
85281: PUSH
85282: LD_INT 2
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 1
85291: NEG
85292: PUSH
85293: LD_INT 1
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 2
85302: NEG
85303: PUSH
85304: LD_INT 0
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 2
85313: NEG
85314: PUSH
85315: LD_INT 1
85317: NEG
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 1
85325: NEG
85326: PUSH
85327: LD_INT 3
85329: NEG
85330: PUSH
85331: EMPTY
85332: LIST
85333: LIST
85334: PUSH
85335: LD_INT 1
85337: PUSH
85338: LD_INT 2
85340: NEG
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: PUSH
85346: LD_INT 3
85348: PUSH
85349: LD_INT 2
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: PUSH
85356: LD_INT 2
85358: PUSH
85359: LD_INT 3
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 2
85368: NEG
85369: PUSH
85370: LD_INT 1
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 3
85379: NEG
85380: PUSH
85381: LD_INT 1
85383: NEG
85384: PUSH
85385: EMPTY
85386: LIST
85387: LIST
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85414: LD_ADDR_VAR 0 33
85418: PUSH
85419: LD_INT 0
85421: PUSH
85422: LD_INT 0
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 0
85431: PUSH
85432: LD_INT 1
85434: NEG
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 1
85442: PUSH
85443: LD_INT 0
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 1
85452: PUSH
85453: LD_INT 1
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 0
85462: PUSH
85463: LD_INT 1
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: LD_INT 1
85472: NEG
85473: PUSH
85474: LD_INT 0
85476: PUSH
85477: EMPTY
85478: LIST
85479: LIST
85480: PUSH
85481: LD_INT 1
85483: NEG
85484: PUSH
85485: LD_INT 1
85487: NEG
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 1
85495: NEG
85496: PUSH
85497: LD_INT 2
85499: NEG
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PUSH
85505: LD_INT 1
85507: PUSH
85508: LD_INT 1
85510: NEG
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 2
85518: PUSH
85519: LD_INT 0
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 2
85528: PUSH
85529: LD_INT 1
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: LD_INT 1
85538: PUSH
85539: LD_INT 2
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PUSH
85546: LD_INT 0
85548: PUSH
85549: LD_INT 2
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: PUSH
85556: LD_INT 1
85558: NEG
85559: PUSH
85560: LD_INT 1
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: PUSH
85567: LD_INT 2
85569: NEG
85570: PUSH
85571: LD_INT 0
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 2
85580: NEG
85581: PUSH
85582: LD_INT 1
85584: NEG
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 2
85592: NEG
85593: PUSH
85594: LD_INT 2
85596: NEG
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: PUSH
85602: LD_INT 2
85604: NEG
85605: PUSH
85606: LD_INT 3
85608: NEG
85609: PUSH
85610: EMPTY
85611: LIST
85612: LIST
85613: PUSH
85614: LD_INT 2
85616: PUSH
85617: LD_INT 1
85619: NEG
85620: PUSH
85621: EMPTY
85622: LIST
85623: LIST
85624: PUSH
85625: LD_INT 3
85627: PUSH
85628: LD_INT 1
85630: PUSH
85631: EMPTY
85632: LIST
85633: LIST
85634: PUSH
85635: LD_INT 1
85637: PUSH
85638: LD_INT 3
85640: PUSH
85641: EMPTY
85642: LIST
85643: LIST
85644: PUSH
85645: LD_INT 1
85647: NEG
85648: PUSH
85649: LD_INT 2
85651: PUSH
85652: EMPTY
85653: LIST
85654: LIST
85655: PUSH
85656: LD_INT 3
85658: NEG
85659: PUSH
85660: LD_INT 2
85662: NEG
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85693: LD_ADDR_VAR 0 34
85697: PUSH
85698: LD_INT 0
85700: PUSH
85701: LD_INT 0
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 0
85710: PUSH
85711: LD_INT 1
85713: NEG
85714: PUSH
85715: EMPTY
85716: LIST
85717: LIST
85718: PUSH
85719: LD_INT 1
85721: PUSH
85722: LD_INT 0
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 1
85731: PUSH
85732: LD_INT 1
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 0
85741: PUSH
85742: LD_INT 1
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 1
85751: NEG
85752: PUSH
85753: LD_INT 0
85755: PUSH
85756: EMPTY
85757: LIST
85758: LIST
85759: PUSH
85760: LD_INT 1
85762: NEG
85763: PUSH
85764: LD_INT 1
85766: NEG
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 1
85774: NEG
85775: PUSH
85776: LD_INT 2
85778: NEG
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: PUSH
85784: LD_INT 0
85786: PUSH
85787: LD_INT 2
85789: NEG
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: PUSH
85795: LD_INT 1
85797: PUSH
85798: LD_INT 1
85800: NEG
85801: PUSH
85802: EMPTY
85803: LIST
85804: LIST
85805: PUSH
85806: LD_INT 2
85808: PUSH
85809: LD_INT 1
85811: PUSH
85812: EMPTY
85813: LIST
85814: LIST
85815: PUSH
85816: LD_INT 2
85818: PUSH
85819: LD_INT 2
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: PUSH
85826: LD_INT 1
85828: PUSH
85829: LD_INT 2
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 1
85838: NEG
85839: PUSH
85840: LD_INT 1
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 2
85849: NEG
85850: PUSH
85851: LD_INT 0
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: PUSH
85858: LD_INT 2
85860: NEG
85861: PUSH
85862: LD_INT 1
85864: NEG
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 2
85872: NEG
85873: PUSH
85874: LD_INT 2
85876: NEG
85877: PUSH
85878: EMPTY
85879: LIST
85880: LIST
85881: PUSH
85882: LD_INT 1
85884: NEG
85885: PUSH
85886: LD_INT 3
85888: NEG
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 1
85896: PUSH
85897: LD_INT 2
85899: NEG
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PUSH
85905: LD_INT 3
85907: PUSH
85908: LD_INT 2
85910: PUSH
85911: EMPTY
85912: LIST
85913: LIST
85914: PUSH
85915: LD_INT 2
85917: PUSH
85918: LD_INT 3
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: LD_INT 2
85927: NEG
85928: PUSH
85929: LD_INT 1
85931: PUSH
85932: EMPTY
85933: LIST
85934: LIST
85935: PUSH
85936: LD_INT 3
85938: NEG
85939: PUSH
85940: LD_INT 1
85942: NEG
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85973: LD_ADDR_VAR 0 35
85977: PUSH
85978: LD_INT 0
85980: PUSH
85981: LD_INT 0
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 0
85990: PUSH
85991: LD_INT 1
85993: NEG
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: LD_INT 1
86001: PUSH
86002: LD_INT 0
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 1
86011: PUSH
86012: LD_INT 1
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_INT 0
86021: PUSH
86022: LD_INT 1
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: LD_INT 1
86031: NEG
86032: PUSH
86033: LD_INT 0
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 1
86042: NEG
86043: PUSH
86044: LD_INT 1
86046: NEG
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: LD_INT 2
86054: PUSH
86055: LD_INT 1
86057: PUSH
86058: EMPTY
86059: LIST
86060: LIST
86061: PUSH
86062: LD_INT 2
86064: NEG
86065: PUSH
86066: LD_INT 1
86068: NEG
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86085: LD_ADDR_VAR 0 36
86089: PUSH
86090: LD_INT 0
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 0
86102: PUSH
86103: LD_INT 1
86105: NEG
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: PUSH
86111: LD_INT 1
86113: PUSH
86114: LD_INT 0
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 1
86123: PUSH
86124: LD_INT 1
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 0
86133: PUSH
86134: LD_INT 1
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 1
86143: NEG
86144: PUSH
86145: LD_INT 0
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 1
86154: NEG
86155: PUSH
86156: LD_INT 1
86158: NEG
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: PUSH
86164: LD_INT 1
86166: NEG
86167: PUSH
86168: LD_INT 2
86170: NEG
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: PUSH
86176: LD_INT 1
86178: PUSH
86179: LD_INT 2
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86197: LD_ADDR_VAR 0 37
86201: PUSH
86202: LD_INT 0
86204: PUSH
86205: LD_INT 0
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 0
86214: PUSH
86215: LD_INT 1
86217: NEG
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: LD_INT 1
86225: PUSH
86226: LD_INT 0
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PUSH
86233: LD_INT 1
86235: PUSH
86236: LD_INT 1
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 0
86245: PUSH
86246: LD_INT 1
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: LD_INT 1
86255: NEG
86256: PUSH
86257: LD_INT 0
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: PUSH
86264: LD_INT 1
86266: NEG
86267: PUSH
86268: LD_INT 1
86270: NEG
86271: PUSH
86272: EMPTY
86273: LIST
86274: LIST
86275: PUSH
86276: LD_INT 1
86278: PUSH
86279: LD_INT 1
86281: NEG
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: PUSH
86287: LD_INT 1
86289: NEG
86290: PUSH
86291: LD_INT 1
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86309: LD_ADDR_VAR 0 38
86313: PUSH
86314: LD_INT 0
86316: PUSH
86317: LD_INT 0
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 0
86326: PUSH
86327: LD_INT 1
86329: NEG
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: LD_INT 1
86337: PUSH
86338: LD_INT 0
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: LD_INT 1
86347: PUSH
86348: LD_INT 1
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 0
86357: PUSH
86358: LD_INT 1
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 1
86367: NEG
86368: PUSH
86369: LD_INT 0
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: LD_INT 1
86378: NEG
86379: PUSH
86380: LD_INT 1
86382: NEG
86383: PUSH
86384: EMPTY
86385: LIST
86386: LIST
86387: PUSH
86388: LD_INT 2
86390: PUSH
86391: LD_INT 1
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: LD_INT 2
86400: NEG
86401: PUSH
86402: LD_INT 1
86404: NEG
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86421: LD_ADDR_VAR 0 39
86425: PUSH
86426: LD_INT 0
86428: PUSH
86429: LD_INT 0
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 0
86438: PUSH
86439: LD_INT 1
86441: NEG
86442: PUSH
86443: EMPTY
86444: LIST
86445: LIST
86446: PUSH
86447: LD_INT 1
86449: PUSH
86450: LD_INT 0
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 1
86459: PUSH
86460: LD_INT 1
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 0
86469: PUSH
86470: LD_INT 1
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 1
86479: NEG
86480: PUSH
86481: LD_INT 0
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 1
86490: NEG
86491: PUSH
86492: LD_INT 1
86494: NEG
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 1
86502: NEG
86503: PUSH
86504: LD_INT 2
86506: NEG
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 1
86514: PUSH
86515: LD_INT 2
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: PUSH
86522: EMPTY
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86533: LD_ADDR_VAR 0 40
86537: PUSH
86538: LD_INT 0
86540: PUSH
86541: LD_INT 0
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 0
86550: PUSH
86551: LD_INT 1
86553: NEG
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 1
86561: PUSH
86562: LD_INT 0
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 1
86571: PUSH
86572: LD_INT 1
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: PUSH
86579: LD_INT 0
86581: PUSH
86582: LD_INT 1
86584: PUSH
86585: EMPTY
86586: LIST
86587: LIST
86588: PUSH
86589: LD_INT 1
86591: NEG
86592: PUSH
86593: LD_INT 0
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 1
86602: NEG
86603: PUSH
86604: LD_INT 1
86606: NEG
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: LD_INT 1
86614: PUSH
86615: LD_INT 1
86617: NEG
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 1
86625: NEG
86626: PUSH
86627: LD_INT 1
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: EMPTY
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86645: LD_ADDR_VAR 0 41
86649: PUSH
86650: LD_INT 0
86652: PUSH
86653: LD_INT 0
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: PUSH
86660: LD_INT 0
86662: PUSH
86663: LD_INT 1
86665: NEG
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 1
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 1
86683: PUSH
86684: LD_INT 1
86686: PUSH
86687: EMPTY
86688: LIST
86689: LIST
86690: PUSH
86691: LD_INT 0
86693: PUSH
86694: LD_INT 1
86696: PUSH
86697: EMPTY
86698: LIST
86699: LIST
86700: PUSH
86701: LD_INT 1
86703: NEG
86704: PUSH
86705: LD_INT 0
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PUSH
86712: LD_INT 1
86714: NEG
86715: PUSH
86716: LD_INT 1
86718: NEG
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 1
86726: NEG
86727: PUSH
86728: LD_INT 2
86730: NEG
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 1
86738: PUSH
86739: LD_INT 1
86741: NEG
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PUSH
86747: LD_INT 2
86749: PUSH
86750: LD_INT 0
86752: PUSH
86753: EMPTY
86754: LIST
86755: LIST
86756: PUSH
86757: LD_INT 2
86759: PUSH
86760: LD_INT 1
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 2
86769: PUSH
86770: LD_INT 2
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PUSH
86777: LD_INT 1
86779: PUSH
86780: LD_INT 2
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: LD_INT 1
86789: NEG
86790: PUSH
86791: LD_INT 1
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: PUSH
86798: LD_INT 2
86800: NEG
86801: PUSH
86802: LD_INT 0
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 2
86811: NEG
86812: PUSH
86813: LD_INT 1
86815: NEG
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 2
86823: NEG
86824: PUSH
86825: LD_INT 2
86827: NEG
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 2
86835: NEG
86836: PUSH
86837: LD_INT 3
86839: NEG
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 2
86847: PUSH
86848: LD_INT 1
86850: NEG
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: LD_INT 3
86858: PUSH
86859: LD_INT 0
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 3
86868: PUSH
86869: LD_INT 1
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: PUSH
86876: LD_INT 3
86878: PUSH
86879: LD_INT 2
86881: PUSH
86882: EMPTY
86883: LIST
86884: LIST
86885: PUSH
86886: LD_INT 3
86888: PUSH
86889: LD_INT 3
86891: PUSH
86892: EMPTY
86893: LIST
86894: LIST
86895: PUSH
86896: LD_INT 2
86898: PUSH
86899: LD_INT 3
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 2
86908: NEG
86909: PUSH
86910: LD_INT 1
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: PUSH
86917: LD_INT 3
86919: NEG
86920: PUSH
86921: LD_INT 0
86923: PUSH
86924: EMPTY
86925: LIST
86926: LIST
86927: PUSH
86928: LD_INT 3
86930: NEG
86931: PUSH
86932: LD_INT 1
86934: NEG
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 3
86942: NEG
86943: PUSH
86944: LD_INT 2
86946: NEG
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 3
86954: NEG
86955: PUSH
86956: LD_INT 3
86958: NEG
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86995: LD_ADDR_VAR 0 42
86999: PUSH
87000: LD_INT 0
87002: PUSH
87003: LD_INT 0
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: PUSH
87010: LD_INT 0
87012: PUSH
87013: LD_INT 1
87015: NEG
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 1
87023: PUSH
87024: LD_INT 0
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: LD_INT 1
87033: PUSH
87034: LD_INT 1
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: PUSH
87041: LD_INT 0
87043: PUSH
87044: LD_INT 1
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: LD_INT 1
87053: NEG
87054: PUSH
87055: LD_INT 0
87057: PUSH
87058: EMPTY
87059: LIST
87060: LIST
87061: PUSH
87062: LD_INT 1
87064: NEG
87065: PUSH
87066: LD_INT 1
87068: NEG
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: PUSH
87074: LD_INT 1
87076: NEG
87077: PUSH
87078: LD_INT 2
87080: NEG
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: PUSH
87086: LD_INT 0
87088: PUSH
87089: LD_INT 2
87091: NEG
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: PUSH
87097: LD_INT 1
87099: PUSH
87100: LD_INT 1
87102: NEG
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 2
87110: PUSH
87111: LD_INT 1
87113: PUSH
87114: EMPTY
87115: LIST
87116: LIST
87117: PUSH
87118: LD_INT 2
87120: PUSH
87121: LD_INT 2
87123: PUSH
87124: EMPTY
87125: LIST
87126: LIST
87127: PUSH
87128: LD_INT 1
87130: PUSH
87131: LD_INT 2
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: PUSH
87138: LD_INT 0
87140: PUSH
87141: LD_INT 2
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: PUSH
87148: LD_INT 1
87150: NEG
87151: PUSH
87152: LD_INT 1
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 2
87161: NEG
87162: PUSH
87163: LD_INT 1
87165: NEG
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: LD_INT 2
87173: NEG
87174: PUSH
87175: LD_INT 2
87177: NEG
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: PUSH
87183: LD_INT 2
87185: NEG
87186: PUSH
87187: LD_INT 3
87189: NEG
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 1
87197: NEG
87198: PUSH
87199: LD_INT 3
87201: NEG
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 0
87209: PUSH
87210: LD_INT 3
87212: NEG
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: PUSH
87218: LD_INT 1
87220: PUSH
87221: LD_INT 2
87223: NEG
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: PUSH
87229: LD_INT 3
87231: PUSH
87232: LD_INT 2
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: PUSH
87239: LD_INT 3
87241: PUSH
87242: LD_INT 3
87244: PUSH
87245: EMPTY
87246: LIST
87247: LIST
87248: PUSH
87249: LD_INT 2
87251: PUSH
87252: LD_INT 3
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: PUSH
87259: LD_INT 1
87261: PUSH
87262: LD_INT 3
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 0
87271: PUSH
87272: LD_INT 3
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: PUSH
87279: LD_INT 1
87281: NEG
87282: PUSH
87283: LD_INT 2
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 3
87292: NEG
87293: PUSH
87294: LD_INT 2
87296: NEG
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: LD_INT 3
87304: NEG
87305: PUSH
87306: LD_INT 3
87308: NEG
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: LIST
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87345: LD_ADDR_VAR 0 43
87349: PUSH
87350: LD_INT 0
87352: PUSH
87353: LD_INT 0
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 0
87362: PUSH
87363: LD_INT 1
87365: NEG
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 1
87373: PUSH
87374: LD_INT 0
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: LD_INT 1
87383: PUSH
87384: LD_INT 1
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 0
87393: PUSH
87394: LD_INT 1
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 1
87403: NEG
87404: PUSH
87405: LD_INT 0
87407: PUSH
87408: EMPTY
87409: LIST
87410: LIST
87411: PUSH
87412: LD_INT 1
87414: NEG
87415: PUSH
87416: LD_INT 1
87418: NEG
87419: PUSH
87420: EMPTY
87421: LIST
87422: LIST
87423: PUSH
87424: LD_INT 1
87426: NEG
87427: PUSH
87428: LD_INT 2
87430: NEG
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: PUSH
87436: LD_INT 0
87438: PUSH
87439: LD_INT 2
87441: NEG
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: PUSH
87447: LD_INT 1
87449: PUSH
87450: LD_INT 1
87452: NEG
87453: PUSH
87454: EMPTY
87455: LIST
87456: LIST
87457: PUSH
87458: LD_INT 2
87460: PUSH
87461: LD_INT 0
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: PUSH
87468: LD_INT 2
87470: PUSH
87471: LD_INT 1
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PUSH
87478: LD_INT 1
87480: PUSH
87481: LD_INT 2
87483: PUSH
87484: EMPTY
87485: LIST
87486: LIST
87487: PUSH
87488: LD_INT 0
87490: PUSH
87491: LD_INT 2
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 1
87500: NEG
87501: PUSH
87502: LD_INT 1
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: PUSH
87509: LD_INT 2
87511: NEG
87512: PUSH
87513: LD_INT 0
87515: PUSH
87516: EMPTY
87517: LIST
87518: LIST
87519: PUSH
87520: LD_INT 2
87522: NEG
87523: PUSH
87524: LD_INT 1
87526: NEG
87527: PUSH
87528: EMPTY
87529: LIST
87530: LIST
87531: PUSH
87532: LD_INT 1
87534: NEG
87535: PUSH
87536: LD_INT 3
87538: NEG
87539: PUSH
87540: EMPTY
87541: LIST
87542: LIST
87543: PUSH
87544: LD_INT 0
87546: PUSH
87547: LD_INT 3
87549: NEG
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 1
87557: PUSH
87558: LD_INT 2
87560: NEG
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: PUSH
87566: LD_INT 2
87568: PUSH
87569: LD_INT 1
87571: NEG
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 3
87579: PUSH
87580: LD_INT 0
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PUSH
87587: LD_INT 3
87589: PUSH
87590: LD_INT 1
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PUSH
87597: LD_INT 1
87599: PUSH
87600: LD_INT 3
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 0
87609: PUSH
87610: LD_INT 3
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 1
87619: NEG
87620: PUSH
87621: LD_INT 2
87623: PUSH
87624: EMPTY
87625: LIST
87626: LIST
87627: PUSH
87628: LD_INT 2
87630: NEG
87631: PUSH
87632: LD_INT 1
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 3
87641: NEG
87642: PUSH
87643: LD_INT 0
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 3
87652: NEG
87653: PUSH
87654: LD_INT 1
87656: NEG
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87693: LD_ADDR_VAR 0 44
87697: PUSH
87698: LD_INT 0
87700: PUSH
87701: LD_INT 0
87703: PUSH
87704: EMPTY
87705: LIST
87706: LIST
87707: PUSH
87708: LD_INT 0
87710: PUSH
87711: LD_INT 1
87713: NEG
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 1
87721: PUSH
87722: LD_INT 0
87724: PUSH
87725: EMPTY
87726: LIST
87727: LIST
87728: PUSH
87729: LD_INT 1
87731: PUSH
87732: LD_INT 1
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: PUSH
87739: LD_INT 0
87741: PUSH
87742: LD_INT 1
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: PUSH
87749: LD_INT 1
87751: NEG
87752: PUSH
87753: LD_INT 0
87755: PUSH
87756: EMPTY
87757: LIST
87758: LIST
87759: PUSH
87760: LD_INT 1
87762: NEG
87763: PUSH
87764: LD_INT 1
87766: NEG
87767: PUSH
87768: EMPTY
87769: LIST
87770: LIST
87771: PUSH
87772: LD_INT 1
87774: NEG
87775: PUSH
87776: LD_INT 2
87778: NEG
87779: PUSH
87780: EMPTY
87781: LIST
87782: LIST
87783: PUSH
87784: LD_INT 1
87786: PUSH
87787: LD_INT 1
87789: NEG
87790: PUSH
87791: EMPTY
87792: LIST
87793: LIST
87794: PUSH
87795: LD_INT 2
87797: PUSH
87798: LD_INT 0
87800: PUSH
87801: EMPTY
87802: LIST
87803: LIST
87804: PUSH
87805: LD_INT 2
87807: PUSH
87808: LD_INT 1
87810: PUSH
87811: EMPTY
87812: LIST
87813: LIST
87814: PUSH
87815: LD_INT 2
87817: PUSH
87818: LD_INT 2
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 1
87827: PUSH
87828: LD_INT 2
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 1
87837: NEG
87838: PUSH
87839: LD_INT 1
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 2
87848: NEG
87849: PUSH
87850: LD_INT 0
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 2
87859: NEG
87860: PUSH
87861: LD_INT 1
87863: NEG
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: PUSH
87869: LD_INT 2
87871: NEG
87872: PUSH
87873: LD_INT 2
87875: NEG
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 2
87883: NEG
87884: PUSH
87885: LD_INT 3
87887: NEG
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: PUSH
87893: LD_INT 2
87895: PUSH
87896: LD_INT 1
87898: NEG
87899: PUSH
87900: EMPTY
87901: LIST
87902: LIST
87903: PUSH
87904: LD_INT 3
87906: PUSH
87907: LD_INT 0
87909: PUSH
87910: EMPTY
87911: LIST
87912: LIST
87913: PUSH
87914: LD_INT 3
87916: PUSH
87917: LD_INT 1
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: PUSH
87924: LD_INT 3
87926: PUSH
87927: LD_INT 2
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: PUSH
87934: LD_INT 3
87936: PUSH
87937: LD_INT 3
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 2
87946: PUSH
87947: LD_INT 3
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 2
87956: NEG
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: PUSH
87965: LD_INT 3
87967: NEG
87968: PUSH
87969: LD_INT 0
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: PUSH
87976: LD_INT 3
87978: NEG
87979: PUSH
87980: LD_INT 1
87982: NEG
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 3
87990: NEG
87991: PUSH
87992: LD_INT 2
87994: NEG
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 3
88002: NEG
88003: PUSH
88004: LD_INT 3
88006: NEG
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: EMPTY
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88043: LD_ADDR_VAR 0 45
88047: PUSH
88048: LD_INT 0
88050: PUSH
88051: LD_INT 0
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: PUSH
88058: LD_INT 0
88060: PUSH
88061: LD_INT 1
88063: NEG
88064: PUSH
88065: EMPTY
88066: LIST
88067: LIST
88068: PUSH
88069: LD_INT 1
88071: PUSH
88072: LD_INT 0
88074: PUSH
88075: EMPTY
88076: LIST
88077: LIST
88078: PUSH
88079: LD_INT 1
88081: PUSH
88082: LD_INT 1
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 0
88091: PUSH
88092: LD_INT 1
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: PUSH
88099: LD_INT 1
88101: NEG
88102: PUSH
88103: LD_INT 0
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PUSH
88110: LD_INT 1
88112: NEG
88113: PUSH
88114: LD_INT 1
88116: NEG
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: PUSH
88122: LD_INT 1
88124: NEG
88125: PUSH
88126: LD_INT 2
88128: NEG
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PUSH
88134: LD_INT 0
88136: PUSH
88137: LD_INT 2
88139: NEG
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 1
88147: PUSH
88148: LD_INT 1
88150: NEG
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PUSH
88156: LD_INT 2
88158: PUSH
88159: LD_INT 1
88161: PUSH
88162: EMPTY
88163: LIST
88164: LIST
88165: PUSH
88166: LD_INT 2
88168: PUSH
88169: LD_INT 2
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PUSH
88176: LD_INT 1
88178: PUSH
88179: LD_INT 2
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: LD_INT 2
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: PUSH
88196: LD_INT 1
88198: NEG
88199: PUSH
88200: LD_INT 1
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: PUSH
88207: LD_INT 2
88209: NEG
88210: PUSH
88211: LD_INT 1
88213: NEG
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 2
88221: NEG
88222: PUSH
88223: LD_INT 2
88225: NEG
88226: PUSH
88227: EMPTY
88228: LIST
88229: LIST
88230: PUSH
88231: LD_INT 2
88233: NEG
88234: PUSH
88235: LD_INT 3
88237: NEG
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: PUSH
88243: LD_INT 1
88245: NEG
88246: PUSH
88247: LD_INT 3
88249: NEG
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PUSH
88255: LD_INT 0
88257: PUSH
88258: LD_INT 3
88260: NEG
88261: PUSH
88262: EMPTY
88263: LIST
88264: LIST
88265: PUSH
88266: LD_INT 1
88268: PUSH
88269: LD_INT 2
88271: NEG
88272: PUSH
88273: EMPTY
88274: LIST
88275: LIST
88276: PUSH
88277: LD_INT 3
88279: PUSH
88280: LD_INT 2
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: LD_INT 3
88289: PUSH
88290: LD_INT 3
88292: PUSH
88293: EMPTY
88294: LIST
88295: LIST
88296: PUSH
88297: LD_INT 2
88299: PUSH
88300: LD_INT 3
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: PUSH
88307: LD_INT 1
88309: PUSH
88310: LD_INT 3
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: PUSH
88317: LD_INT 0
88319: PUSH
88320: LD_INT 3
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: LD_INT 1
88329: NEG
88330: PUSH
88331: LD_INT 2
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: PUSH
88338: LD_INT 3
88340: NEG
88341: PUSH
88342: LD_INT 2
88344: NEG
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 3
88352: NEG
88353: PUSH
88354: LD_INT 3
88356: NEG
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: LIST
88373: LIST
88374: LIST
88375: LIST
88376: LIST
88377: LIST
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88393: LD_ADDR_VAR 0 46
88397: PUSH
88398: LD_INT 0
88400: PUSH
88401: LD_INT 0
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: PUSH
88408: LD_INT 0
88410: PUSH
88411: LD_INT 1
88413: NEG
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PUSH
88419: LD_INT 1
88421: PUSH
88422: LD_INT 0
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: PUSH
88429: LD_INT 1
88431: PUSH
88432: LD_INT 1
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: PUSH
88439: LD_INT 0
88441: PUSH
88442: LD_INT 1
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: PUSH
88449: LD_INT 1
88451: NEG
88452: PUSH
88453: LD_INT 0
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: PUSH
88460: LD_INT 1
88462: NEG
88463: PUSH
88464: LD_INT 1
88466: NEG
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PUSH
88472: LD_INT 1
88474: NEG
88475: PUSH
88476: LD_INT 2
88478: NEG
88479: PUSH
88480: EMPTY
88481: LIST
88482: LIST
88483: PUSH
88484: LD_INT 0
88486: PUSH
88487: LD_INT 2
88489: NEG
88490: PUSH
88491: EMPTY
88492: LIST
88493: LIST
88494: PUSH
88495: LD_INT 1
88497: PUSH
88498: LD_INT 1
88500: NEG
88501: PUSH
88502: EMPTY
88503: LIST
88504: LIST
88505: PUSH
88506: LD_INT 2
88508: PUSH
88509: LD_INT 0
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: LD_INT 2
88518: PUSH
88519: LD_INT 1
88521: PUSH
88522: EMPTY
88523: LIST
88524: LIST
88525: PUSH
88526: LD_INT 1
88528: PUSH
88529: LD_INT 2
88531: PUSH
88532: EMPTY
88533: LIST
88534: LIST
88535: PUSH
88536: LD_INT 0
88538: PUSH
88539: LD_INT 2
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 1
88548: NEG
88549: PUSH
88550: LD_INT 1
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: LD_INT 2
88559: NEG
88560: PUSH
88561: LD_INT 0
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 2
88570: NEG
88571: PUSH
88572: LD_INT 1
88574: NEG
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 1
88582: NEG
88583: PUSH
88584: LD_INT 3
88586: NEG
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: PUSH
88592: LD_INT 0
88594: PUSH
88595: LD_INT 3
88597: NEG
88598: PUSH
88599: EMPTY
88600: LIST
88601: LIST
88602: PUSH
88603: LD_INT 1
88605: PUSH
88606: LD_INT 2
88608: NEG
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: PUSH
88614: LD_INT 2
88616: PUSH
88617: LD_INT 1
88619: NEG
88620: PUSH
88621: EMPTY
88622: LIST
88623: LIST
88624: PUSH
88625: LD_INT 3
88627: PUSH
88628: LD_INT 0
88630: PUSH
88631: EMPTY
88632: LIST
88633: LIST
88634: PUSH
88635: LD_INT 3
88637: PUSH
88638: LD_INT 1
88640: PUSH
88641: EMPTY
88642: LIST
88643: LIST
88644: PUSH
88645: LD_INT 1
88647: PUSH
88648: LD_INT 3
88650: PUSH
88651: EMPTY
88652: LIST
88653: LIST
88654: PUSH
88655: LD_INT 0
88657: PUSH
88658: LD_INT 3
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PUSH
88665: LD_INT 1
88667: NEG
88668: PUSH
88669: LD_INT 2
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 2
88678: NEG
88679: PUSH
88680: LD_INT 1
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 3
88689: NEG
88690: PUSH
88691: LD_INT 0
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 3
88700: NEG
88701: PUSH
88702: LD_INT 1
88704: NEG
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88741: LD_ADDR_VAR 0 47
88745: PUSH
88746: LD_INT 0
88748: PUSH
88749: LD_INT 0
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: PUSH
88756: LD_INT 0
88758: PUSH
88759: LD_INT 1
88761: NEG
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: PUSH
88767: LD_INT 1
88769: PUSH
88770: LD_INT 0
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 1
88779: PUSH
88780: LD_INT 1
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 0
88789: PUSH
88790: LD_INT 1
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 1
88799: NEG
88800: PUSH
88801: LD_INT 0
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 1
88810: NEG
88811: PUSH
88812: LD_INT 1
88814: NEG
88815: PUSH
88816: EMPTY
88817: LIST
88818: LIST
88819: PUSH
88820: LD_INT 1
88822: NEG
88823: PUSH
88824: LD_INT 2
88826: NEG
88827: PUSH
88828: EMPTY
88829: LIST
88830: LIST
88831: PUSH
88832: LD_INT 0
88834: PUSH
88835: LD_INT 2
88837: NEG
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: PUSH
88843: LD_INT 1
88845: PUSH
88846: LD_INT 1
88848: NEG
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: LD_INT 2
88856: NEG
88857: PUSH
88858: LD_INT 1
88860: NEG
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: PUSH
88866: LD_INT 2
88868: NEG
88869: PUSH
88870: LD_INT 2
88872: NEG
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: EMPTY
88879: LIST
88880: LIST
88881: LIST
88882: LIST
88883: LIST
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: LIST
88891: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88892: LD_ADDR_VAR 0 48
88896: PUSH
88897: LD_INT 0
88899: PUSH
88900: LD_INT 0
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: PUSH
88907: LD_INT 0
88909: PUSH
88910: LD_INT 1
88912: NEG
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 1
88920: PUSH
88921: LD_INT 0
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 1
88930: PUSH
88931: LD_INT 1
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: PUSH
88938: LD_INT 0
88940: PUSH
88941: LD_INT 1
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: PUSH
88948: LD_INT 1
88950: NEG
88951: PUSH
88952: LD_INT 0
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: PUSH
88959: LD_INT 1
88961: NEG
88962: PUSH
88963: LD_INT 1
88965: NEG
88966: PUSH
88967: EMPTY
88968: LIST
88969: LIST
88970: PUSH
88971: LD_INT 1
88973: NEG
88974: PUSH
88975: LD_INT 2
88977: NEG
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PUSH
88983: LD_INT 0
88985: PUSH
88986: LD_INT 2
88988: NEG
88989: PUSH
88990: EMPTY
88991: LIST
88992: LIST
88993: PUSH
88994: LD_INT 1
88996: PUSH
88997: LD_INT 1
88999: NEG
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 2
89007: PUSH
89008: LD_INT 0
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 2
89017: PUSH
89018: LD_INT 1
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: LIST
89034: LIST
89035: LIST
89036: LIST
89037: LIST
89038: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89039: LD_ADDR_VAR 0 49
89043: PUSH
89044: LD_INT 0
89046: PUSH
89047: LD_INT 0
89049: PUSH
89050: EMPTY
89051: LIST
89052: LIST
89053: PUSH
89054: LD_INT 0
89056: PUSH
89057: LD_INT 1
89059: NEG
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: PUSH
89065: LD_INT 1
89067: PUSH
89068: LD_INT 0
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 1
89077: PUSH
89078: LD_INT 1
89080: PUSH
89081: EMPTY
89082: LIST
89083: LIST
89084: PUSH
89085: LD_INT 0
89087: PUSH
89088: LD_INT 1
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 1
89097: NEG
89098: PUSH
89099: LD_INT 0
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 1
89108: NEG
89109: PUSH
89110: LD_INT 1
89112: NEG
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PUSH
89118: LD_INT 1
89120: PUSH
89121: LD_INT 1
89123: NEG
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PUSH
89129: LD_INT 2
89131: PUSH
89132: LD_INT 0
89134: PUSH
89135: EMPTY
89136: LIST
89137: LIST
89138: PUSH
89139: LD_INT 2
89141: PUSH
89142: LD_INT 1
89144: PUSH
89145: EMPTY
89146: LIST
89147: LIST
89148: PUSH
89149: LD_INT 2
89151: PUSH
89152: LD_INT 2
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 1
89161: PUSH
89162: LD_INT 2
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: LIST
89180: LIST
89181: LIST
89182: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89183: LD_ADDR_VAR 0 50
89187: PUSH
89188: LD_INT 0
89190: PUSH
89191: LD_INT 0
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PUSH
89198: LD_INT 0
89200: PUSH
89201: LD_INT 1
89203: NEG
89204: PUSH
89205: EMPTY
89206: LIST
89207: LIST
89208: PUSH
89209: LD_INT 1
89211: PUSH
89212: LD_INT 0
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: PUSH
89219: LD_INT 1
89221: PUSH
89222: LD_INT 1
89224: PUSH
89225: EMPTY
89226: LIST
89227: LIST
89228: PUSH
89229: LD_INT 0
89231: PUSH
89232: LD_INT 1
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: PUSH
89239: LD_INT 1
89241: NEG
89242: PUSH
89243: LD_INT 0
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: LD_INT 1
89252: NEG
89253: PUSH
89254: LD_INT 1
89256: NEG
89257: PUSH
89258: EMPTY
89259: LIST
89260: LIST
89261: PUSH
89262: LD_INT 2
89264: PUSH
89265: LD_INT 1
89267: PUSH
89268: EMPTY
89269: LIST
89270: LIST
89271: PUSH
89272: LD_INT 2
89274: PUSH
89275: LD_INT 2
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 1
89284: PUSH
89285: LD_INT 2
89287: PUSH
89288: EMPTY
89289: LIST
89290: LIST
89291: PUSH
89292: LD_INT 0
89294: PUSH
89295: LD_INT 2
89297: PUSH
89298: EMPTY
89299: LIST
89300: LIST
89301: PUSH
89302: LD_INT 1
89304: NEG
89305: PUSH
89306: LD_INT 1
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: LIST
89326: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89327: LD_ADDR_VAR 0 51
89331: PUSH
89332: LD_INT 0
89334: PUSH
89335: LD_INT 0
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: PUSH
89342: LD_INT 0
89344: PUSH
89345: LD_INT 1
89347: NEG
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 1
89355: PUSH
89356: LD_INT 0
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 1
89365: PUSH
89366: LD_INT 1
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 0
89375: PUSH
89376: LD_INT 1
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 1
89385: NEG
89386: PUSH
89387: LD_INT 0
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 1
89396: NEG
89397: PUSH
89398: LD_INT 1
89400: NEG
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 1
89408: PUSH
89409: LD_INT 2
89411: PUSH
89412: EMPTY
89413: LIST
89414: LIST
89415: PUSH
89416: LD_INT 0
89418: PUSH
89419: LD_INT 2
89421: PUSH
89422: EMPTY
89423: LIST
89424: LIST
89425: PUSH
89426: LD_INT 1
89428: NEG
89429: PUSH
89430: LD_INT 1
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: LD_INT 2
89439: NEG
89440: PUSH
89441: LD_INT 0
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 2
89450: NEG
89451: PUSH
89452: LD_INT 1
89454: NEG
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89474: LD_ADDR_VAR 0 52
89478: PUSH
89479: LD_INT 0
89481: PUSH
89482: LD_INT 0
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 0
89491: PUSH
89492: LD_INT 1
89494: NEG
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 1
89502: PUSH
89503: LD_INT 0
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 1
89512: PUSH
89513: LD_INT 1
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 0
89522: PUSH
89523: LD_INT 1
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 1
89532: NEG
89533: PUSH
89534: LD_INT 0
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 1
89543: NEG
89544: PUSH
89545: LD_INT 1
89547: NEG
89548: PUSH
89549: EMPTY
89550: LIST
89551: LIST
89552: PUSH
89553: LD_INT 1
89555: NEG
89556: PUSH
89557: LD_INT 2
89559: NEG
89560: PUSH
89561: EMPTY
89562: LIST
89563: LIST
89564: PUSH
89565: LD_INT 1
89567: NEG
89568: PUSH
89569: LD_INT 1
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: PUSH
89576: LD_INT 2
89578: NEG
89579: PUSH
89580: LD_INT 0
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: PUSH
89587: LD_INT 2
89589: NEG
89590: PUSH
89591: LD_INT 1
89593: NEG
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 2
89601: NEG
89602: PUSH
89603: LD_INT 2
89605: NEG
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: EMPTY
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89625: LD_ADDR_VAR 0 53
89629: PUSH
89630: LD_INT 0
89632: PUSH
89633: LD_INT 0
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 0
89642: PUSH
89643: LD_INT 1
89645: NEG
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 1
89653: PUSH
89654: LD_INT 0
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 1
89663: PUSH
89664: LD_INT 1
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: PUSH
89671: LD_INT 0
89673: PUSH
89674: LD_INT 1
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: LD_INT 1
89683: NEG
89684: PUSH
89685: LD_INT 0
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: PUSH
89692: LD_INT 1
89694: NEG
89695: PUSH
89696: LD_INT 1
89698: NEG
89699: PUSH
89700: EMPTY
89701: LIST
89702: LIST
89703: PUSH
89704: LD_INT 1
89706: NEG
89707: PUSH
89708: LD_INT 2
89710: NEG
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: PUSH
89716: LD_INT 0
89718: PUSH
89719: LD_INT 2
89721: NEG
89722: PUSH
89723: EMPTY
89724: LIST
89725: LIST
89726: PUSH
89727: LD_INT 1
89729: PUSH
89730: LD_INT 1
89732: NEG
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: PUSH
89738: LD_INT 2
89740: PUSH
89741: LD_INT 0
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: PUSH
89748: LD_INT 2
89750: PUSH
89751: LD_INT 1
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 2
89760: PUSH
89761: LD_INT 2
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: PUSH
89768: LD_INT 1
89770: PUSH
89771: LD_INT 2
89773: PUSH
89774: EMPTY
89775: LIST
89776: LIST
89777: PUSH
89778: LD_INT 0
89780: PUSH
89781: LD_INT 2
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: PUSH
89788: LD_INT 1
89790: NEG
89791: PUSH
89792: LD_INT 1
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 2
89801: NEG
89802: PUSH
89803: LD_INT 0
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 2
89812: NEG
89813: PUSH
89814: LD_INT 1
89816: NEG
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 2
89824: NEG
89825: PUSH
89826: LD_INT 2
89828: NEG
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: LIST
89847: LIST
89848: LIST
89849: LIST
89850: LIST
89851: LIST
89852: LIST
89853: LIST
89854: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89855: LD_ADDR_VAR 0 54
89859: PUSH
89860: LD_INT 0
89862: PUSH
89863: LD_INT 0
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: PUSH
89870: LD_INT 0
89872: PUSH
89873: LD_INT 1
89875: NEG
89876: PUSH
89877: EMPTY
89878: LIST
89879: LIST
89880: PUSH
89881: LD_INT 1
89883: PUSH
89884: LD_INT 0
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: PUSH
89891: LD_INT 1
89893: PUSH
89894: LD_INT 1
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PUSH
89901: LD_INT 0
89903: PUSH
89904: LD_INT 1
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: PUSH
89911: LD_INT 1
89913: NEG
89914: PUSH
89915: LD_INT 0
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 1
89924: NEG
89925: PUSH
89926: LD_INT 1
89928: NEG
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 1
89936: NEG
89937: PUSH
89938: LD_INT 2
89940: NEG
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: LD_INT 0
89948: PUSH
89949: LD_INT 2
89951: NEG
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: PUSH
89957: LD_INT 1
89959: PUSH
89960: LD_INT 1
89962: NEG
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: PUSH
89968: LD_INT 2
89970: PUSH
89971: LD_INT 0
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: LD_INT 2
89980: PUSH
89981: LD_INT 1
89983: PUSH
89984: EMPTY
89985: LIST
89986: LIST
89987: PUSH
89988: LD_INT 2
89990: PUSH
89991: LD_INT 2
89993: PUSH
89994: EMPTY
89995: LIST
89996: LIST
89997: PUSH
89998: LD_INT 1
90000: PUSH
90001: LD_INT 2
90003: PUSH
90004: EMPTY
90005: LIST
90006: LIST
90007: PUSH
90008: LD_INT 0
90010: PUSH
90011: LD_INT 2
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: PUSH
90018: LD_INT 1
90020: NEG
90021: PUSH
90022: LD_INT 1
90024: PUSH
90025: EMPTY
90026: LIST
90027: LIST
90028: PUSH
90029: LD_INT 2
90031: NEG
90032: PUSH
90033: LD_INT 0
90035: PUSH
90036: EMPTY
90037: LIST
90038: LIST
90039: PUSH
90040: LD_INT 2
90042: NEG
90043: PUSH
90044: LD_INT 1
90046: NEG
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 2
90054: NEG
90055: PUSH
90056: LD_INT 2
90058: NEG
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90085: LD_ADDR_VAR 0 55
90089: PUSH
90090: LD_INT 0
90092: PUSH
90093: LD_INT 0
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: PUSH
90100: LD_INT 0
90102: PUSH
90103: LD_INT 1
90105: NEG
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: PUSH
90111: LD_INT 1
90113: PUSH
90114: LD_INT 0
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 1
90123: PUSH
90124: LD_INT 1
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: LD_INT 0
90133: PUSH
90134: LD_INT 1
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PUSH
90141: LD_INT 1
90143: NEG
90144: PUSH
90145: LD_INT 0
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PUSH
90152: LD_INT 1
90154: NEG
90155: PUSH
90156: LD_INT 1
90158: NEG
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 1
90166: NEG
90167: PUSH
90168: LD_INT 2
90170: NEG
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: LD_INT 0
90178: PUSH
90179: LD_INT 2
90181: NEG
90182: PUSH
90183: EMPTY
90184: LIST
90185: LIST
90186: PUSH
90187: LD_INT 1
90189: PUSH
90190: LD_INT 1
90192: NEG
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: LD_INT 2
90200: PUSH
90201: LD_INT 0
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: PUSH
90208: LD_INT 2
90210: PUSH
90211: LD_INT 1
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: LD_INT 2
90220: PUSH
90221: LD_INT 2
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: PUSH
90228: LD_INT 1
90230: PUSH
90231: LD_INT 2
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: PUSH
90238: LD_INT 0
90240: PUSH
90241: LD_INT 2
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 1
90250: NEG
90251: PUSH
90252: LD_INT 1
90254: PUSH
90255: EMPTY
90256: LIST
90257: LIST
90258: PUSH
90259: LD_INT 2
90261: NEG
90262: PUSH
90263: LD_INT 0
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: PUSH
90270: LD_INT 2
90272: NEG
90273: PUSH
90274: LD_INT 1
90276: NEG
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: PUSH
90282: LD_INT 2
90284: NEG
90285: PUSH
90286: LD_INT 2
90288: NEG
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90315: LD_ADDR_VAR 0 56
90319: PUSH
90320: LD_INT 0
90322: PUSH
90323: LD_INT 0
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: PUSH
90330: LD_INT 0
90332: PUSH
90333: LD_INT 1
90335: NEG
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 1
90343: PUSH
90344: LD_INT 0
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 1
90353: PUSH
90354: LD_INT 1
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 0
90363: PUSH
90364: LD_INT 1
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PUSH
90371: LD_INT 1
90373: NEG
90374: PUSH
90375: LD_INT 0
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: PUSH
90382: LD_INT 1
90384: NEG
90385: PUSH
90386: LD_INT 1
90388: NEG
90389: PUSH
90390: EMPTY
90391: LIST
90392: LIST
90393: PUSH
90394: LD_INT 1
90396: NEG
90397: PUSH
90398: LD_INT 2
90400: NEG
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: LD_INT 0
90408: PUSH
90409: LD_INT 2
90411: NEG
90412: PUSH
90413: EMPTY
90414: LIST
90415: LIST
90416: PUSH
90417: LD_INT 1
90419: PUSH
90420: LD_INT 1
90422: NEG
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: LD_INT 2
90430: PUSH
90431: LD_INT 0
90433: PUSH
90434: EMPTY
90435: LIST
90436: LIST
90437: PUSH
90438: LD_INT 2
90440: PUSH
90441: LD_INT 1
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: PUSH
90448: LD_INT 2
90450: PUSH
90451: LD_INT 2
90453: PUSH
90454: EMPTY
90455: LIST
90456: LIST
90457: PUSH
90458: LD_INT 1
90460: PUSH
90461: LD_INT 2
90463: PUSH
90464: EMPTY
90465: LIST
90466: LIST
90467: PUSH
90468: LD_INT 0
90470: PUSH
90471: LD_INT 2
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 1
90480: NEG
90481: PUSH
90482: LD_INT 1
90484: PUSH
90485: EMPTY
90486: LIST
90487: LIST
90488: PUSH
90489: LD_INT 2
90491: NEG
90492: PUSH
90493: LD_INT 0
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: PUSH
90500: LD_INT 2
90502: NEG
90503: PUSH
90504: LD_INT 1
90506: NEG
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 2
90514: NEG
90515: PUSH
90516: LD_INT 2
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: EMPTY
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: LIST
90533: LIST
90534: LIST
90535: LIST
90536: LIST
90537: LIST
90538: LIST
90539: LIST
90540: LIST
90541: LIST
90542: LIST
90543: LIST
90544: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90545: LD_ADDR_VAR 0 57
90549: PUSH
90550: LD_INT 0
90552: PUSH
90553: LD_INT 0
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: PUSH
90560: LD_INT 0
90562: PUSH
90563: LD_INT 1
90565: NEG
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PUSH
90571: LD_INT 1
90573: PUSH
90574: LD_INT 0
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: LD_INT 1
90583: PUSH
90584: LD_INT 1
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PUSH
90591: LD_INT 0
90593: PUSH
90594: LD_INT 1
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: LD_INT 1
90603: NEG
90604: PUSH
90605: LD_INT 0
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 1
90614: NEG
90615: PUSH
90616: LD_INT 1
90618: NEG
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 1
90626: NEG
90627: PUSH
90628: LD_INT 2
90630: NEG
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 0
90638: PUSH
90639: LD_INT 2
90641: NEG
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: PUSH
90647: LD_INT 1
90649: PUSH
90650: LD_INT 1
90652: NEG
90653: PUSH
90654: EMPTY
90655: LIST
90656: LIST
90657: PUSH
90658: LD_INT 2
90660: PUSH
90661: LD_INT 0
90663: PUSH
90664: EMPTY
90665: LIST
90666: LIST
90667: PUSH
90668: LD_INT 2
90670: PUSH
90671: LD_INT 1
90673: PUSH
90674: EMPTY
90675: LIST
90676: LIST
90677: PUSH
90678: LD_INT 2
90680: PUSH
90681: LD_INT 2
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: LD_INT 1
90690: PUSH
90691: LD_INT 2
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 0
90700: PUSH
90701: LD_INT 2
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 1
90710: NEG
90711: PUSH
90712: LD_INT 1
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PUSH
90719: LD_INT 2
90721: NEG
90722: PUSH
90723: LD_INT 0
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: PUSH
90730: LD_INT 2
90732: NEG
90733: PUSH
90734: LD_INT 1
90736: NEG
90737: PUSH
90738: EMPTY
90739: LIST
90740: LIST
90741: PUSH
90742: LD_INT 2
90744: NEG
90745: PUSH
90746: LD_INT 2
90748: NEG
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90775: LD_ADDR_VAR 0 58
90779: PUSH
90780: LD_INT 0
90782: PUSH
90783: LD_INT 0
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: PUSH
90790: LD_INT 0
90792: PUSH
90793: LD_INT 1
90795: NEG
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: PUSH
90801: LD_INT 1
90803: PUSH
90804: LD_INT 0
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: PUSH
90811: LD_INT 1
90813: PUSH
90814: LD_INT 1
90816: PUSH
90817: EMPTY
90818: LIST
90819: LIST
90820: PUSH
90821: LD_INT 0
90823: PUSH
90824: LD_INT 1
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: LD_INT 1
90833: NEG
90834: PUSH
90835: LD_INT 0
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 1
90844: NEG
90845: PUSH
90846: LD_INT 1
90848: NEG
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: LD_INT 1
90856: NEG
90857: PUSH
90858: LD_INT 2
90860: NEG
90861: PUSH
90862: EMPTY
90863: LIST
90864: LIST
90865: PUSH
90866: LD_INT 0
90868: PUSH
90869: LD_INT 2
90871: NEG
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: PUSH
90877: LD_INT 1
90879: PUSH
90880: LD_INT 1
90882: NEG
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PUSH
90888: LD_INT 2
90890: PUSH
90891: LD_INT 0
90893: PUSH
90894: EMPTY
90895: LIST
90896: LIST
90897: PUSH
90898: LD_INT 2
90900: PUSH
90901: LD_INT 1
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: PUSH
90908: LD_INT 2
90910: PUSH
90911: LD_INT 2
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: PUSH
90918: LD_INT 1
90920: PUSH
90921: LD_INT 2
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: LD_INT 0
90930: PUSH
90931: LD_INT 2
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 1
90940: NEG
90941: PUSH
90942: LD_INT 1
90944: PUSH
90945: EMPTY
90946: LIST
90947: LIST
90948: PUSH
90949: LD_INT 2
90951: NEG
90952: PUSH
90953: LD_INT 0
90955: PUSH
90956: EMPTY
90957: LIST
90958: LIST
90959: PUSH
90960: LD_INT 2
90962: NEG
90963: PUSH
90964: LD_INT 1
90966: NEG
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: LD_INT 2
90974: NEG
90975: PUSH
90976: LD_INT 2
90978: NEG
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91005: LD_ADDR_VAR 0 59
91009: PUSH
91010: LD_INT 0
91012: PUSH
91013: LD_INT 0
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: PUSH
91020: LD_INT 0
91022: PUSH
91023: LD_INT 1
91025: NEG
91026: PUSH
91027: EMPTY
91028: LIST
91029: LIST
91030: PUSH
91031: LD_INT 1
91033: PUSH
91034: LD_INT 0
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PUSH
91041: LD_INT 1
91043: PUSH
91044: LD_INT 1
91046: PUSH
91047: EMPTY
91048: LIST
91049: LIST
91050: PUSH
91051: LD_INT 0
91053: PUSH
91054: LD_INT 1
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PUSH
91061: LD_INT 1
91063: NEG
91064: PUSH
91065: LD_INT 0
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: LD_INT 1
91074: NEG
91075: PUSH
91076: LD_INT 1
91078: NEG
91079: PUSH
91080: EMPTY
91081: LIST
91082: LIST
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91093: LD_ADDR_VAR 0 60
91097: PUSH
91098: LD_INT 0
91100: PUSH
91101: LD_INT 0
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: LD_INT 0
91110: PUSH
91111: LD_INT 1
91113: NEG
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 1
91121: PUSH
91122: LD_INT 0
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: LD_INT 1
91131: PUSH
91132: LD_INT 1
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: PUSH
91139: LD_INT 0
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: LD_INT 1
91151: NEG
91152: PUSH
91153: LD_INT 0
91155: PUSH
91156: EMPTY
91157: LIST
91158: LIST
91159: PUSH
91160: LD_INT 1
91162: NEG
91163: PUSH
91164: LD_INT 1
91166: NEG
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91181: LD_ADDR_VAR 0 61
91185: PUSH
91186: LD_INT 0
91188: PUSH
91189: LD_INT 0
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: PUSH
91196: LD_INT 0
91198: PUSH
91199: LD_INT 1
91201: NEG
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 1
91209: PUSH
91210: LD_INT 0
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: LD_INT 1
91219: PUSH
91220: LD_INT 1
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 0
91229: PUSH
91230: LD_INT 1
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: PUSH
91237: LD_INT 1
91239: NEG
91240: PUSH
91241: LD_INT 0
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: LD_INT 1
91250: NEG
91251: PUSH
91252: LD_INT 1
91254: NEG
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91269: LD_ADDR_VAR 0 62
91273: PUSH
91274: LD_INT 0
91276: PUSH
91277: LD_INT 0
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: LD_INT 0
91286: PUSH
91287: LD_INT 1
91289: NEG
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 1
91297: PUSH
91298: LD_INT 0
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: PUSH
91305: LD_INT 1
91307: PUSH
91308: LD_INT 1
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: LD_INT 0
91317: PUSH
91318: LD_INT 1
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: LD_INT 1
91327: NEG
91328: PUSH
91329: LD_INT 0
91331: PUSH
91332: EMPTY
91333: LIST
91334: LIST
91335: PUSH
91336: LD_INT 1
91338: NEG
91339: PUSH
91340: LD_INT 1
91342: NEG
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: EMPTY
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91357: LD_ADDR_VAR 0 63
91361: PUSH
91362: LD_INT 0
91364: PUSH
91365: LD_INT 0
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PUSH
91372: LD_INT 0
91374: PUSH
91375: LD_INT 1
91377: NEG
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: LD_INT 1
91385: PUSH
91386: LD_INT 0
91388: PUSH
91389: EMPTY
91390: LIST
91391: LIST
91392: PUSH
91393: LD_INT 1
91395: PUSH
91396: LD_INT 1
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: PUSH
91403: LD_INT 0
91405: PUSH
91406: LD_INT 1
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: PUSH
91413: LD_INT 1
91415: NEG
91416: PUSH
91417: LD_INT 0
91419: PUSH
91420: EMPTY
91421: LIST
91422: LIST
91423: PUSH
91424: LD_INT 1
91426: NEG
91427: PUSH
91428: LD_INT 1
91430: NEG
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91445: LD_ADDR_VAR 0 64
91449: PUSH
91450: LD_INT 0
91452: PUSH
91453: LD_INT 0
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: LD_INT 0
91462: PUSH
91463: LD_INT 1
91465: NEG
91466: PUSH
91467: EMPTY
91468: LIST
91469: LIST
91470: PUSH
91471: LD_INT 1
91473: PUSH
91474: LD_INT 0
91476: PUSH
91477: EMPTY
91478: LIST
91479: LIST
91480: PUSH
91481: LD_INT 1
91483: PUSH
91484: LD_INT 1
91486: PUSH
91487: EMPTY
91488: LIST
91489: LIST
91490: PUSH
91491: LD_INT 0
91493: PUSH
91494: LD_INT 1
91496: PUSH
91497: EMPTY
91498: LIST
91499: LIST
91500: PUSH
91501: LD_INT 1
91503: NEG
91504: PUSH
91505: LD_INT 0
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 1
91514: NEG
91515: PUSH
91516: LD_INT 1
91518: NEG
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: LIST
91531: LIST
91532: ST_TO_ADDR
// end ; 1 :
91533: GO 97430
91535: LD_INT 1
91537: DOUBLE
91538: EQUAL
91539: IFTRUE 91543
91541: GO 94166
91543: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91544: LD_ADDR_VAR 0 11
91548: PUSH
91549: LD_INT 1
91551: NEG
91552: PUSH
91553: LD_INT 3
91555: NEG
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 0
91563: PUSH
91564: LD_INT 3
91566: NEG
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: PUSH
91572: LD_INT 1
91574: PUSH
91575: LD_INT 2
91577: NEG
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: EMPTY
91584: LIST
91585: LIST
91586: LIST
91587: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91588: LD_ADDR_VAR 0 12
91592: PUSH
91593: LD_INT 2
91595: PUSH
91596: LD_INT 1
91598: NEG
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 3
91606: PUSH
91607: LD_INT 0
91609: PUSH
91610: EMPTY
91611: LIST
91612: LIST
91613: PUSH
91614: LD_INT 3
91616: PUSH
91617: LD_INT 1
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: LIST
91628: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91629: LD_ADDR_VAR 0 13
91633: PUSH
91634: LD_INT 3
91636: PUSH
91637: LD_INT 2
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: LD_INT 3
91646: PUSH
91647: LD_INT 3
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 2
91656: PUSH
91657: LD_INT 3
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: LIST
91668: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91669: LD_ADDR_VAR 0 14
91673: PUSH
91674: LD_INT 1
91676: PUSH
91677: LD_INT 3
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: LD_INT 0
91686: PUSH
91687: LD_INT 3
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 1
91696: NEG
91697: PUSH
91698: LD_INT 2
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: LIST
91709: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91710: LD_ADDR_VAR 0 15
91714: PUSH
91715: LD_INT 2
91717: NEG
91718: PUSH
91719: LD_INT 1
91721: PUSH
91722: EMPTY
91723: LIST
91724: LIST
91725: PUSH
91726: LD_INT 3
91728: NEG
91729: PUSH
91730: LD_INT 0
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: PUSH
91737: LD_INT 3
91739: NEG
91740: PUSH
91741: LD_INT 1
91743: NEG
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PUSH
91749: EMPTY
91750: LIST
91751: LIST
91752: LIST
91753: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91754: LD_ADDR_VAR 0 16
91758: PUSH
91759: LD_INT 2
91761: NEG
91762: PUSH
91763: LD_INT 3
91765: NEG
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: PUSH
91771: LD_INT 3
91773: NEG
91774: PUSH
91775: LD_INT 2
91777: NEG
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: PUSH
91783: LD_INT 3
91785: NEG
91786: PUSH
91787: LD_INT 3
91789: NEG
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: LIST
91799: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91800: LD_ADDR_VAR 0 17
91804: PUSH
91805: LD_INT 1
91807: NEG
91808: PUSH
91809: LD_INT 3
91811: NEG
91812: PUSH
91813: EMPTY
91814: LIST
91815: LIST
91816: PUSH
91817: LD_INT 0
91819: PUSH
91820: LD_INT 3
91822: NEG
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PUSH
91828: LD_INT 1
91830: PUSH
91831: LD_INT 2
91833: NEG
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: PUSH
91839: EMPTY
91840: LIST
91841: LIST
91842: LIST
91843: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91844: LD_ADDR_VAR 0 18
91848: PUSH
91849: LD_INT 2
91851: PUSH
91852: LD_INT 1
91854: NEG
91855: PUSH
91856: EMPTY
91857: LIST
91858: LIST
91859: PUSH
91860: LD_INT 3
91862: PUSH
91863: LD_INT 0
91865: PUSH
91866: EMPTY
91867: LIST
91868: LIST
91869: PUSH
91870: LD_INT 3
91872: PUSH
91873: LD_INT 1
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: LIST
91884: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91885: LD_ADDR_VAR 0 19
91889: PUSH
91890: LD_INT 3
91892: PUSH
91893: LD_INT 2
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: PUSH
91900: LD_INT 3
91902: PUSH
91903: LD_INT 3
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: PUSH
91910: LD_INT 2
91912: PUSH
91913: LD_INT 3
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: LIST
91924: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91925: LD_ADDR_VAR 0 20
91929: PUSH
91930: LD_INT 1
91932: PUSH
91933: LD_INT 3
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PUSH
91940: LD_INT 0
91942: PUSH
91943: LD_INT 3
91945: PUSH
91946: EMPTY
91947: LIST
91948: LIST
91949: PUSH
91950: LD_INT 1
91952: NEG
91953: PUSH
91954: LD_INT 2
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: LIST
91965: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91966: LD_ADDR_VAR 0 21
91970: PUSH
91971: LD_INT 2
91973: NEG
91974: PUSH
91975: LD_INT 1
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: LD_INT 3
91984: NEG
91985: PUSH
91986: LD_INT 0
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 3
91995: NEG
91996: PUSH
91997: LD_INT 1
91999: NEG
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: LIST
92009: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92010: LD_ADDR_VAR 0 22
92014: PUSH
92015: LD_INT 2
92017: NEG
92018: PUSH
92019: LD_INT 3
92021: NEG
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: PUSH
92027: LD_INT 3
92029: NEG
92030: PUSH
92031: LD_INT 2
92033: NEG
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: PUSH
92039: LD_INT 3
92041: NEG
92042: PUSH
92043: LD_INT 3
92045: NEG
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: LIST
92055: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92056: LD_ADDR_VAR 0 23
92060: PUSH
92061: LD_INT 0
92063: PUSH
92064: LD_INT 3
92066: NEG
92067: PUSH
92068: EMPTY
92069: LIST
92070: LIST
92071: PUSH
92072: LD_INT 1
92074: NEG
92075: PUSH
92076: LD_INT 4
92078: NEG
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: LD_INT 1
92086: PUSH
92087: LD_INT 3
92089: NEG
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: LIST
92099: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92100: LD_ADDR_VAR 0 24
92104: PUSH
92105: LD_INT 3
92107: PUSH
92108: LD_INT 0
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: LD_INT 3
92117: PUSH
92118: LD_INT 1
92120: NEG
92121: PUSH
92122: EMPTY
92123: LIST
92124: LIST
92125: PUSH
92126: LD_INT 4
92128: PUSH
92129: LD_INT 1
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: PUSH
92136: EMPTY
92137: LIST
92138: LIST
92139: LIST
92140: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92141: LD_ADDR_VAR 0 25
92145: PUSH
92146: LD_INT 3
92148: PUSH
92149: LD_INT 3
92151: PUSH
92152: EMPTY
92153: LIST
92154: LIST
92155: PUSH
92156: LD_INT 4
92158: PUSH
92159: LD_INT 3
92161: PUSH
92162: EMPTY
92163: LIST
92164: LIST
92165: PUSH
92166: LD_INT 3
92168: PUSH
92169: LD_INT 4
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: LIST
92180: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92181: LD_ADDR_VAR 0 26
92185: PUSH
92186: LD_INT 0
92188: PUSH
92189: LD_INT 3
92191: PUSH
92192: EMPTY
92193: LIST
92194: LIST
92195: PUSH
92196: LD_INT 1
92198: PUSH
92199: LD_INT 4
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: PUSH
92206: LD_INT 1
92208: NEG
92209: PUSH
92210: LD_INT 3
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: LIST
92221: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92222: LD_ADDR_VAR 0 27
92226: PUSH
92227: LD_INT 3
92229: NEG
92230: PUSH
92231: LD_INT 0
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PUSH
92238: LD_INT 3
92240: NEG
92241: PUSH
92242: LD_INT 1
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: PUSH
92249: LD_INT 4
92251: NEG
92252: PUSH
92253: LD_INT 1
92255: NEG
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: PUSH
92261: EMPTY
92262: LIST
92263: LIST
92264: LIST
92265: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92266: LD_ADDR_VAR 0 28
92270: PUSH
92271: LD_INT 3
92273: NEG
92274: PUSH
92275: LD_INT 3
92277: NEG
92278: PUSH
92279: EMPTY
92280: LIST
92281: LIST
92282: PUSH
92283: LD_INT 3
92285: NEG
92286: PUSH
92287: LD_INT 4
92289: NEG
92290: PUSH
92291: EMPTY
92292: LIST
92293: LIST
92294: PUSH
92295: LD_INT 4
92297: NEG
92298: PUSH
92299: LD_INT 3
92301: NEG
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: LIST
92311: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92312: LD_ADDR_VAR 0 29
92316: PUSH
92317: LD_INT 1
92319: NEG
92320: PUSH
92321: LD_INT 3
92323: NEG
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 0
92331: PUSH
92332: LD_INT 3
92334: NEG
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: LD_INT 1
92342: PUSH
92343: LD_INT 2
92345: NEG
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: PUSH
92351: LD_INT 1
92353: NEG
92354: PUSH
92355: LD_INT 4
92357: NEG
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: LD_INT 0
92365: PUSH
92366: LD_INT 4
92368: NEG
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: PUSH
92374: LD_INT 1
92376: PUSH
92377: LD_INT 3
92379: NEG
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: PUSH
92385: LD_INT 1
92387: NEG
92388: PUSH
92389: LD_INT 5
92391: NEG
92392: PUSH
92393: EMPTY
92394: LIST
92395: LIST
92396: PUSH
92397: LD_INT 0
92399: PUSH
92400: LD_INT 5
92402: NEG
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: PUSH
92408: LD_INT 1
92410: PUSH
92411: LD_INT 4
92413: NEG
92414: PUSH
92415: EMPTY
92416: LIST
92417: LIST
92418: PUSH
92419: LD_INT 1
92421: NEG
92422: PUSH
92423: LD_INT 6
92425: NEG
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 0
92433: PUSH
92434: LD_INT 6
92436: NEG
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: PUSH
92442: LD_INT 1
92444: PUSH
92445: LD_INT 5
92447: NEG
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: PUSH
92453: EMPTY
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92467: LD_ADDR_VAR 0 30
92471: PUSH
92472: LD_INT 2
92474: PUSH
92475: LD_INT 1
92477: NEG
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 3
92485: PUSH
92486: LD_INT 0
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 3
92495: PUSH
92496: LD_INT 1
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PUSH
92503: LD_INT 3
92505: PUSH
92506: LD_INT 1
92508: NEG
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PUSH
92514: LD_INT 4
92516: PUSH
92517: LD_INT 0
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 4
92526: PUSH
92527: LD_INT 1
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: PUSH
92534: LD_INT 4
92536: PUSH
92537: LD_INT 1
92539: NEG
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 5
92547: PUSH
92548: LD_INT 0
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: LD_INT 5
92557: PUSH
92558: LD_INT 1
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PUSH
92565: LD_INT 5
92567: PUSH
92568: LD_INT 1
92570: NEG
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 6
92578: PUSH
92579: LD_INT 0
92581: PUSH
92582: EMPTY
92583: LIST
92584: LIST
92585: PUSH
92586: LD_INT 6
92588: PUSH
92589: LD_INT 1
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PUSH
92596: EMPTY
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: LIST
92604: LIST
92605: LIST
92606: LIST
92607: LIST
92608: LIST
92609: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92610: LD_ADDR_VAR 0 31
92614: PUSH
92615: LD_INT 3
92617: PUSH
92618: LD_INT 2
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 3
92627: PUSH
92628: LD_INT 3
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: LD_INT 2
92637: PUSH
92638: LD_INT 3
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 4
92647: PUSH
92648: LD_INT 3
92650: PUSH
92651: EMPTY
92652: LIST
92653: LIST
92654: PUSH
92655: LD_INT 4
92657: PUSH
92658: LD_INT 4
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 3
92667: PUSH
92668: LD_INT 4
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 5
92677: PUSH
92678: LD_INT 4
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: PUSH
92685: LD_INT 5
92687: PUSH
92688: LD_INT 5
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: PUSH
92695: LD_INT 4
92697: PUSH
92698: LD_INT 5
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 6
92707: PUSH
92708: LD_INT 5
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: LD_INT 6
92717: PUSH
92718: LD_INT 6
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: PUSH
92725: LD_INT 5
92727: PUSH
92728: LD_INT 6
92730: PUSH
92731: EMPTY
92732: LIST
92733: LIST
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: LIST
92747: LIST
92748: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92749: LD_ADDR_VAR 0 32
92753: PUSH
92754: LD_INT 1
92756: PUSH
92757: LD_INT 3
92759: PUSH
92760: EMPTY
92761: LIST
92762: LIST
92763: PUSH
92764: LD_INT 0
92766: PUSH
92767: LD_INT 3
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: PUSH
92774: LD_INT 1
92776: NEG
92777: PUSH
92778: LD_INT 2
92780: PUSH
92781: EMPTY
92782: LIST
92783: LIST
92784: PUSH
92785: LD_INT 1
92787: PUSH
92788: LD_INT 4
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: PUSH
92795: LD_INT 0
92797: PUSH
92798: LD_INT 4
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 1
92807: NEG
92808: PUSH
92809: LD_INT 3
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: LD_INT 1
92818: PUSH
92819: LD_INT 5
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: LD_INT 0
92828: PUSH
92829: LD_INT 5
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 1
92838: NEG
92839: PUSH
92840: LD_INT 4
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 1
92849: PUSH
92850: LD_INT 6
92852: PUSH
92853: EMPTY
92854: LIST
92855: LIST
92856: PUSH
92857: LD_INT 0
92859: PUSH
92860: LD_INT 6
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: PUSH
92867: LD_INT 1
92869: NEG
92870: PUSH
92871: LD_INT 5
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92892: LD_ADDR_VAR 0 33
92896: PUSH
92897: LD_INT 2
92899: NEG
92900: PUSH
92901: LD_INT 1
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 3
92910: NEG
92911: PUSH
92912: LD_INT 0
92914: PUSH
92915: EMPTY
92916: LIST
92917: LIST
92918: PUSH
92919: LD_INT 3
92921: NEG
92922: PUSH
92923: LD_INT 1
92925: NEG
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 3
92933: NEG
92934: PUSH
92935: LD_INT 1
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: PUSH
92942: LD_INT 4
92944: NEG
92945: PUSH
92946: LD_INT 0
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 4
92955: NEG
92956: PUSH
92957: LD_INT 1
92959: NEG
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 4
92967: NEG
92968: PUSH
92969: LD_INT 1
92971: PUSH
92972: EMPTY
92973: LIST
92974: LIST
92975: PUSH
92976: LD_INT 5
92978: NEG
92979: PUSH
92980: LD_INT 0
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 5
92989: NEG
92990: PUSH
92991: LD_INT 1
92993: NEG
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 5
93001: NEG
93002: PUSH
93003: LD_INT 1
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 6
93012: NEG
93013: PUSH
93014: LD_INT 0
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 6
93023: NEG
93024: PUSH
93025: LD_INT 1
93027: NEG
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93047: LD_ADDR_VAR 0 34
93051: PUSH
93052: LD_INT 2
93054: NEG
93055: PUSH
93056: LD_INT 3
93058: NEG
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 3
93066: NEG
93067: PUSH
93068: LD_INT 2
93070: NEG
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 3
93078: NEG
93079: PUSH
93080: LD_INT 3
93082: NEG
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PUSH
93088: LD_INT 3
93090: NEG
93091: PUSH
93092: LD_INT 4
93094: NEG
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 4
93102: NEG
93103: PUSH
93104: LD_INT 3
93106: NEG
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: PUSH
93112: LD_INT 4
93114: NEG
93115: PUSH
93116: LD_INT 4
93118: NEG
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PUSH
93124: LD_INT 4
93126: NEG
93127: PUSH
93128: LD_INT 5
93130: NEG
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 5
93138: NEG
93139: PUSH
93140: LD_INT 4
93142: NEG
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 5
93150: NEG
93151: PUSH
93152: LD_INT 5
93154: NEG
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 5
93162: NEG
93163: PUSH
93164: LD_INT 6
93166: NEG
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PUSH
93172: LD_INT 6
93174: NEG
93175: PUSH
93176: LD_INT 5
93178: NEG
93179: PUSH
93180: EMPTY
93181: LIST
93182: LIST
93183: PUSH
93184: LD_INT 6
93186: NEG
93187: PUSH
93188: LD_INT 6
93190: NEG
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93210: LD_ADDR_VAR 0 41
93214: PUSH
93215: LD_INT 0
93217: PUSH
93218: LD_INT 2
93220: NEG
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 1
93228: NEG
93229: PUSH
93230: LD_INT 3
93232: NEG
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 1
93240: PUSH
93241: LD_INT 2
93243: NEG
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: LIST
93253: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93254: LD_ADDR_VAR 0 42
93258: PUSH
93259: LD_INT 2
93261: PUSH
93262: LD_INT 0
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: LD_INT 2
93271: PUSH
93272: LD_INT 1
93274: NEG
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: LD_INT 3
93282: PUSH
93283: LD_INT 1
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: LIST
93294: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93295: LD_ADDR_VAR 0 43
93299: PUSH
93300: LD_INT 2
93302: PUSH
93303: LD_INT 2
93305: PUSH
93306: EMPTY
93307: LIST
93308: LIST
93309: PUSH
93310: LD_INT 3
93312: PUSH
93313: LD_INT 2
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: PUSH
93320: LD_INT 2
93322: PUSH
93323: LD_INT 3
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: LIST
93334: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93335: LD_ADDR_VAR 0 44
93339: PUSH
93340: LD_INT 0
93342: PUSH
93343: LD_INT 2
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: LD_INT 1
93352: PUSH
93353: LD_INT 3
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 1
93362: NEG
93363: PUSH
93364: LD_INT 2
93366: PUSH
93367: EMPTY
93368: LIST
93369: LIST
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: LIST
93375: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93376: LD_ADDR_VAR 0 45
93380: PUSH
93381: LD_INT 2
93383: NEG
93384: PUSH
93385: LD_INT 0
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 2
93394: NEG
93395: PUSH
93396: LD_INT 1
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: LD_INT 3
93405: NEG
93406: PUSH
93407: LD_INT 1
93409: NEG
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: LIST
93419: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93420: LD_ADDR_VAR 0 46
93424: PUSH
93425: LD_INT 2
93427: NEG
93428: PUSH
93429: LD_INT 2
93431: NEG
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: LD_INT 2
93439: NEG
93440: PUSH
93441: LD_INT 3
93443: NEG
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: LD_INT 3
93451: NEG
93452: PUSH
93453: LD_INT 2
93455: NEG
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: LIST
93465: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93466: LD_ADDR_VAR 0 47
93470: PUSH
93471: LD_INT 2
93473: NEG
93474: PUSH
93475: LD_INT 3
93477: NEG
93478: PUSH
93479: EMPTY
93480: LIST
93481: LIST
93482: PUSH
93483: LD_INT 1
93485: NEG
93486: PUSH
93487: LD_INT 3
93489: NEG
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93499: LD_ADDR_VAR 0 48
93503: PUSH
93504: LD_INT 1
93506: PUSH
93507: LD_INT 2
93509: NEG
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: LD_INT 2
93517: PUSH
93518: LD_INT 1
93520: NEG
93521: PUSH
93522: EMPTY
93523: LIST
93524: LIST
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93530: LD_ADDR_VAR 0 49
93534: PUSH
93535: LD_INT 3
93537: PUSH
93538: LD_INT 1
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: PUSH
93545: LD_INT 3
93547: PUSH
93548: LD_INT 2
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: PUSH
93555: EMPTY
93556: LIST
93557: LIST
93558: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93559: LD_ADDR_VAR 0 50
93563: PUSH
93564: LD_INT 2
93566: PUSH
93567: LD_INT 3
93569: PUSH
93570: EMPTY
93571: LIST
93572: LIST
93573: PUSH
93574: LD_INT 1
93576: PUSH
93577: LD_INT 3
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93588: LD_ADDR_VAR 0 51
93592: PUSH
93593: LD_INT 1
93595: NEG
93596: PUSH
93597: LD_INT 2
93599: PUSH
93600: EMPTY
93601: LIST
93602: LIST
93603: PUSH
93604: LD_INT 2
93606: NEG
93607: PUSH
93608: LD_INT 1
93610: PUSH
93611: EMPTY
93612: LIST
93613: LIST
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93619: LD_ADDR_VAR 0 52
93623: PUSH
93624: LD_INT 3
93626: NEG
93627: PUSH
93628: LD_INT 1
93630: NEG
93631: PUSH
93632: EMPTY
93633: LIST
93634: LIST
93635: PUSH
93636: LD_INT 3
93638: NEG
93639: PUSH
93640: LD_INT 2
93642: NEG
93643: PUSH
93644: EMPTY
93645: LIST
93646: LIST
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93652: LD_ADDR_VAR 0 53
93656: PUSH
93657: LD_INT 1
93659: NEG
93660: PUSH
93661: LD_INT 3
93663: NEG
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 0
93671: PUSH
93672: LD_INT 3
93674: NEG
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: PUSH
93680: LD_INT 1
93682: PUSH
93683: LD_INT 2
93685: NEG
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: LIST
93695: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93696: LD_ADDR_VAR 0 54
93700: PUSH
93701: LD_INT 2
93703: PUSH
93704: LD_INT 1
93706: NEG
93707: PUSH
93708: EMPTY
93709: LIST
93710: LIST
93711: PUSH
93712: LD_INT 3
93714: PUSH
93715: LD_INT 0
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: PUSH
93722: LD_INT 3
93724: PUSH
93725: LD_INT 1
93727: PUSH
93728: EMPTY
93729: LIST
93730: LIST
93731: PUSH
93732: EMPTY
93733: LIST
93734: LIST
93735: LIST
93736: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93737: LD_ADDR_VAR 0 55
93741: PUSH
93742: LD_INT 3
93744: PUSH
93745: LD_INT 2
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: LD_INT 3
93754: PUSH
93755: LD_INT 3
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: LD_INT 2
93764: PUSH
93765: LD_INT 3
93767: PUSH
93768: EMPTY
93769: LIST
93770: LIST
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: LIST
93776: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93777: LD_ADDR_VAR 0 56
93781: PUSH
93782: LD_INT 1
93784: PUSH
93785: LD_INT 3
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: LD_INT 0
93794: PUSH
93795: LD_INT 3
93797: PUSH
93798: EMPTY
93799: LIST
93800: LIST
93801: PUSH
93802: LD_INT 1
93804: NEG
93805: PUSH
93806: LD_INT 2
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: LIST
93817: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93818: LD_ADDR_VAR 0 57
93822: PUSH
93823: LD_INT 2
93825: NEG
93826: PUSH
93827: LD_INT 1
93829: PUSH
93830: EMPTY
93831: LIST
93832: LIST
93833: PUSH
93834: LD_INT 3
93836: NEG
93837: PUSH
93838: LD_INT 0
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: LD_INT 3
93847: NEG
93848: PUSH
93849: LD_INT 1
93851: NEG
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: LIST
93861: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93862: LD_ADDR_VAR 0 58
93866: PUSH
93867: LD_INT 2
93869: NEG
93870: PUSH
93871: LD_INT 3
93873: NEG
93874: PUSH
93875: EMPTY
93876: LIST
93877: LIST
93878: PUSH
93879: LD_INT 3
93881: NEG
93882: PUSH
93883: LD_INT 2
93885: NEG
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: PUSH
93891: LD_INT 3
93893: NEG
93894: PUSH
93895: LD_INT 3
93897: NEG
93898: PUSH
93899: EMPTY
93900: LIST
93901: LIST
93902: PUSH
93903: EMPTY
93904: LIST
93905: LIST
93906: LIST
93907: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93908: LD_ADDR_VAR 0 59
93912: PUSH
93913: LD_INT 1
93915: NEG
93916: PUSH
93917: LD_INT 2
93919: NEG
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: PUSH
93925: LD_INT 0
93927: PUSH
93928: LD_INT 2
93930: NEG
93931: PUSH
93932: EMPTY
93933: LIST
93934: LIST
93935: PUSH
93936: LD_INT 1
93938: PUSH
93939: LD_INT 1
93941: NEG
93942: PUSH
93943: EMPTY
93944: LIST
93945: LIST
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: LIST
93951: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93952: LD_ADDR_VAR 0 60
93956: PUSH
93957: LD_INT 1
93959: PUSH
93960: LD_INT 1
93962: NEG
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: LD_INT 2
93970: PUSH
93971: LD_INT 0
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: PUSH
93978: LD_INT 2
93980: PUSH
93981: LD_INT 1
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: LIST
93992: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93993: LD_ADDR_VAR 0 61
93997: PUSH
93998: LD_INT 2
94000: PUSH
94001: LD_INT 1
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: LD_INT 2
94010: PUSH
94011: LD_INT 2
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: PUSH
94018: LD_INT 1
94020: PUSH
94021: LD_INT 2
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: LIST
94032: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94033: LD_ADDR_VAR 0 62
94037: PUSH
94038: LD_INT 1
94040: PUSH
94041: LD_INT 2
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: LD_INT 0
94050: PUSH
94051: LD_INT 2
94053: PUSH
94054: EMPTY
94055: LIST
94056: LIST
94057: PUSH
94058: LD_INT 1
94060: NEG
94061: PUSH
94062: LD_INT 1
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: LIST
94073: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94074: LD_ADDR_VAR 0 63
94078: PUSH
94079: LD_INT 1
94081: NEG
94082: PUSH
94083: LD_INT 1
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: PUSH
94090: LD_INT 2
94092: NEG
94093: PUSH
94094: LD_INT 0
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: LD_INT 2
94103: NEG
94104: PUSH
94105: LD_INT 1
94107: NEG
94108: PUSH
94109: EMPTY
94110: LIST
94111: LIST
94112: PUSH
94113: EMPTY
94114: LIST
94115: LIST
94116: LIST
94117: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94118: LD_ADDR_VAR 0 64
94122: PUSH
94123: LD_INT 1
94125: NEG
94126: PUSH
94127: LD_INT 2
94129: NEG
94130: PUSH
94131: EMPTY
94132: LIST
94133: LIST
94134: PUSH
94135: LD_INT 2
94137: NEG
94138: PUSH
94139: LD_INT 1
94141: NEG
94142: PUSH
94143: EMPTY
94144: LIST
94145: LIST
94146: PUSH
94147: LD_INT 2
94149: NEG
94150: PUSH
94151: LD_INT 2
94153: NEG
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: LIST
94163: ST_TO_ADDR
// end ; 2 :
94164: GO 97430
94166: LD_INT 2
94168: DOUBLE
94169: EQUAL
94170: IFTRUE 94174
94172: GO 97429
94174: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94175: LD_ADDR_VAR 0 29
94179: PUSH
94180: LD_INT 4
94182: PUSH
94183: LD_INT 0
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: PUSH
94190: LD_INT 4
94192: PUSH
94193: LD_INT 1
94195: NEG
94196: PUSH
94197: EMPTY
94198: LIST
94199: LIST
94200: PUSH
94201: LD_INT 5
94203: PUSH
94204: LD_INT 0
94206: PUSH
94207: EMPTY
94208: LIST
94209: LIST
94210: PUSH
94211: LD_INT 5
94213: PUSH
94214: LD_INT 1
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: PUSH
94221: LD_INT 4
94223: PUSH
94224: LD_INT 1
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 3
94233: PUSH
94234: LD_INT 0
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 3
94243: PUSH
94244: LD_INT 1
94246: NEG
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: PUSH
94252: LD_INT 3
94254: PUSH
94255: LD_INT 2
94257: NEG
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 5
94265: PUSH
94266: LD_INT 2
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: PUSH
94273: LD_INT 3
94275: PUSH
94276: LD_INT 3
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: PUSH
94283: LD_INT 3
94285: PUSH
94286: LD_INT 2
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: LD_INT 4
94295: PUSH
94296: LD_INT 3
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: PUSH
94303: LD_INT 4
94305: PUSH
94306: LD_INT 4
94308: PUSH
94309: EMPTY
94310: LIST
94311: LIST
94312: PUSH
94313: LD_INT 3
94315: PUSH
94316: LD_INT 4
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: PUSH
94323: LD_INT 2
94325: PUSH
94326: LD_INT 3
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: PUSH
94333: LD_INT 2
94335: PUSH
94336: LD_INT 2
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: PUSH
94343: LD_INT 4
94345: PUSH
94346: LD_INT 2
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 2
94355: PUSH
94356: LD_INT 4
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: LD_INT 0
94365: PUSH
94366: LD_INT 4
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 0
94375: PUSH
94376: LD_INT 3
94378: PUSH
94379: EMPTY
94380: LIST
94381: LIST
94382: PUSH
94383: LD_INT 1
94385: PUSH
94386: LD_INT 4
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: PUSH
94393: LD_INT 1
94395: PUSH
94396: LD_INT 5
94398: PUSH
94399: EMPTY
94400: LIST
94401: LIST
94402: PUSH
94403: LD_INT 0
94405: PUSH
94406: LD_INT 5
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PUSH
94413: LD_INT 1
94415: NEG
94416: PUSH
94417: LD_INT 4
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 1
94426: NEG
94427: PUSH
94428: LD_INT 3
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: PUSH
94435: LD_INT 2
94437: PUSH
94438: LD_INT 5
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: PUSH
94445: LD_INT 2
94447: NEG
94448: PUSH
94449: LD_INT 3
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: LD_INT 3
94458: NEG
94459: PUSH
94460: LD_INT 0
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: LD_INT 3
94469: NEG
94470: PUSH
94471: LD_INT 1
94473: NEG
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: PUSH
94479: LD_INT 2
94481: NEG
94482: PUSH
94483: LD_INT 0
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 2
94492: NEG
94493: PUSH
94494: LD_INT 1
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 3
94503: NEG
94504: PUSH
94505: LD_INT 1
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 4
94514: NEG
94515: PUSH
94516: LD_INT 0
94518: PUSH
94519: EMPTY
94520: LIST
94521: LIST
94522: PUSH
94523: LD_INT 4
94525: NEG
94526: PUSH
94527: LD_INT 1
94529: NEG
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: PUSH
94535: LD_INT 4
94537: NEG
94538: PUSH
94539: LD_INT 2
94541: NEG
94542: PUSH
94543: EMPTY
94544: LIST
94545: LIST
94546: PUSH
94547: LD_INT 2
94549: NEG
94550: PUSH
94551: LD_INT 2
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: PUSH
94558: LD_INT 4
94560: NEG
94561: PUSH
94562: LD_INT 4
94564: NEG
94565: PUSH
94566: EMPTY
94567: LIST
94568: LIST
94569: PUSH
94570: LD_INT 4
94572: NEG
94573: PUSH
94574: LD_INT 5
94576: NEG
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 3
94584: NEG
94585: PUSH
94586: LD_INT 4
94588: NEG
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 3
94596: NEG
94597: PUSH
94598: LD_INT 3
94600: NEG
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 4
94608: NEG
94609: PUSH
94610: LD_INT 3
94612: NEG
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: PUSH
94618: LD_INT 5
94620: NEG
94621: PUSH
94622: LD_INT 4
94624: NEG
94625: PUSH
94626: EMPTY
94627: LIST
94628: LIST
94629: PUSH
94630: LD_INT 5
94632: NEG
94633: PUSH
94634: LD_INT 5
94636: NEG
94637: PUSH
94638: EMPTY
94639: LIST
94640: LIST
94641: PUSH
94642: LD_INT 3
94644: NEG
94645: PUSH
94646: LD_INT 5
94648: NEG
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: PUSH
94654: LD_INT 5
94656: NEG
94657: PUSH
94658: LD_INT 3
94660: NEG
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: PUSH
94666: EMPTY
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94713: LD_ADDR_VAR 0 30
94717: PUSH
94718: LD_INT 4
94720: PUSH
94721: LD_INT 4
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 4
94730: PUSH
94731: LD_INT 3
94733: PUSH
94734: EMPTY
94735: LIST
94736: LIST
94737: PUSH
94738: LD_INT 5
94740: PUSH
94741: LD_INT 4
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: PUSH
94748: LD_INT 5
94750: PUSH
94751: LD_INT 5
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: PUSH
94758: LD_INT 4
94760: PUSH
94761: LD_INT 5
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: PUSH
94768: LD_INT 3
94770: PUSH
94771: LD_INT 4
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 3
94780: PUSH
94781: LD_INT 3
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: PUSH
94788: LD_INT 5
94790: PUSH
94791: LD_INT 3
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: LD_INT 3
94800: PUSH
94801: LD_INT 5
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PUSH
94808: LD_INT 0
94810: PUSH
94811: LD_INT 3
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: PUSH
94818: LD_INT 0
94820: PUSH
94821: LD_INT 2
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: LD_INT 1
94830: PUSH
94831: LD_INT 3
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 1
94840: PUSH
94841: LD_INT 4
94843: PUSH
94844: EMPTY
94845: LIST
94846: LIST
94847: PUSH
94848: LD_INT 0
94850: PUSH
94851: LD_INT 4
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 1
94860: NEG
94861: PUSH
94862: LD_INT 3
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 1
94871: NEG
94872: PUSH
94873: LD_INT 2
94875: PUSH
94876: EMPTY
94877: LIST
94878: LIST
94879: PUSH
94880: LD_INT 2
94882: PUSH
94883: LD_INT 4
94885: PUSH
94886: EMPTY
94887: LIST
94888: LIST
94889: PUSH
94890: LD_INT 2
94892: NEG
94893: PUSH
94894: LD_INT 2
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: PUSH
94901: LD_INT 4
94903: NEG
94904: PUSH
94905: LD_INT 0
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: PUSH
94912: LD_INT 4
94914: NEG
94915: PUSH
94916: LD_INT 1
94918: NEG
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: LD_INT 3
94926: NEG
94927: PUSH
94928: LD_INT 0
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: LD_INT 3
94937: NEG
94938: PUSH
94939: LD_INT 1
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 4
94948: NEG
94949: PUSH
94950: LD_INT 1
94952: PUSH
94953: EMPTY
94954: LIST
94955: LIST
94956: PUSH
94957: LD_INT 5
94959: NEG
94960: PUSH
94961: LD_INT 0
94963: PUSH
94964: EMPTY
94965: LIST
94966: LIST
94967: PUSH
94968: LD_INT 5
94970: NEG
94971: PUSH
94972: LD_INT 1
94974: NEG
94975: PUSH
94976: EMPTY
94977: LIST
94978: LIST
94979: PUSH
94980: LD_INT 5
94982: NEG
94983: PUSH
94984: LD_INT 2
94986: NEG
94987: PUSH
94988: EMPTY
94989: LIST
94990: LIST
94991: PUSH
94992: LD_INT 3
94994: NEG
94995: PUSH
94996: LD_INT 2
94998: PUSH
94999: EMPTY
95000: LIST
95001: LIST
95002: PUSH
95003: LD_INT 3
95005: NEG
95006: PUSH
95007: LD_INT 3
95009: NEG
95010: PUSH
95011: EMPTY
95012: LIST
95013: LIST
95014: PUSH
95015: LD_INT 3
95017: NEG
95018: PUSH
95019: LD_INT 4
95021: NEG
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 2
95029: NEG
95030: PUSH
95031: LD_INT 3
95033: NEG
95034: PUSH
95035: EMPTY
95036: LIST
95037: LIST
95038: PUSH
95039: LD_INT 2
95041: NEG
95042: PUSH
95043: LD_INT 2
95045: NEG
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: PUSH
95051: LD_INT 3
95053: NEG
95054: PUSH
95055: LD_INT 2
95057: NEG
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: PUSH
95063: LD_INT 4
95065: NEG
95066: PUSH
95067: LD_INT 3
95069: NEG
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: PUSH
95075: LD_INT 4
95077: NEG
95078: PUSH
95079: LD_INT 4
95081: NEG
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PUSH
95087: LD_INT 2
95089: NEG
95090: PUSH
95091: LD_INT 4
95093: NEG
95094: PUSH
95095: EMPTY
95096: LIST
95097: LIST
95098: PUSH
95099: LD_INT 4
95101: NEG
95102: PUSH
95103: LD_INT 2
95105: NEG
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: PUSH
95111: LD_INT 0
95113: PUSH
95114: LD_INT 4
95116: NEG
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 0
95124: PUSH
95125: LD_INT 5
95127: NEG
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 1
95135: PUSH
95136: LD_INT 4
95138: NEG
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PUSH
95144: LD_INT 1
95146: PUSH
95147: LD_INT 3
95149: NEG
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: LD_INT 0
95157: PUSH
95158: LD_INT 3
95160: NEG
95161: PUSH
95162: EMPTY
95163: LIST
95164: LIST
95165: PUSH
95166: LD_INT 1
95168: NEG
95169: PUSH
95170: LD_INT 4
95172: NEG
95173: PUSH
95174: EMPTY
95175: LIST
95176: LIST
95177: PUSH
95178: LD_INT 1
95180: NEG
95181: PUSH
95182: LD_INT 5
95184: NEG
95185: PUSH
95186: EMPTY
95187: LIST
95188: LIST
95189: PUSH
95190: LD_INT 2
95192: PUSH
95193: LD_INT 3
95195: NEG
95196: PUSH
95197: EMPTY
95198: LIST
95199: LIST
95200: PUSH
95201: LD_INT 2
95203: NEG
95204: PUSH
95205: LD_INT 5
95207: NEG
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95260: LD_ADDR_VAR 0 31
95264: PUSH
95265: LD_INT 0
95267: PUSH
95268: LD_INT 4
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 0
95277: PUSH
95278: LD_INT 3
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: LD_INT 1
95287: PUSH
95288: LD_INT 4
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: PUSH
95295: LD_INT 1
95297: PUSH
95298: LD_INT 5
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 0
95307: PUSH
95308: LD_INT 5
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 1
95317: NEG
95318: PUSH
95319: LD_INT 4
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PUSH
95326: LD_INT 1
95328: NEG
95329: PUSH
95330: LD_INT 3
95332: PUSH
95333: EMPTY
95334: LIST
95335: LIST
95336: PUSH
95337: LD_INT 2
95339: PUSH
95340: LD_INT 5
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 2
95349: NEG
95350: PUSH
95351: LD_INT 3
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: LD_INT 3
95360: NEG
95361: PUSH
95362: LD_INT 0
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 3
95371: NEG
95372: PUSH
95373: LD_INT 1
95375: NEG
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 2
95383: NEG
95384: PUSH
95385: LD_INT 0
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 2
95394: NEG
95395: PUSH
95396: LD_INT 1
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PUSH
95403: LD_INT 3
95405: NEG
95406: PUSH
95407: LD_INT 1
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: PUSH
95414: LD_INT 4
95416: NEG
95417: PUSH
95418: LD_INT 0
95420: PUSH
95421: EMPTY
95422: LIST
95423: LIST
95424: PUSH
95425: LD_INT 4
95427: NEG
95428: PUSH
95429: LD_INT 1
95431: NEG
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: PUSH
95437: LD_INT 4
95439: NEG
95440: PUSH
95441: LD_INT 2
95443: NEG
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: LD_INT 2
95451: NEG
95452: PUSH
95453: LD_INT 2
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: PUSH
95460: LD_INT 4
95462: NEG
95463: PUSH
95464: LD_INT 4
95466: NEG
95467: PUSH
95468: EMPTY
95469: LIST
95470: LIST
95471: PUSH
95472: LD_INT 4
95474: NEG
95475: PUSH
95476: LD_INT 5
95478: NEG
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: PUSH
95484: LD_INT 3
95486: NEG
95487: PUSH
95488: LD_INT 4
95490: NEG
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 3
95498: NEG
95499: PUSH
95500: LD_INT 3
95502: NEG
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 4
95510: NEG
95511: PUSH
95512: LD_INT 3
95514: NEG
95515: PUSH
95516: EMPTY
95517: LIST
95518: LIST
95519: PUSH
95520: LD_INT 5
95522: NEG
95523: PUSH
95524: LD_INT 4
95526: NEG
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: PUSH
95532: LD_INT 5
95534: NEG
95535: PUSH
95536: LD_INT 5
95538: NEG
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: LD_INT 3
95546: NEG
95547: PUSH
95548: LD_INT 5
95550: NEG
95551: PUSH
95552: EMPTY
95553: LIST
95554: LIST
95555: PUSH
95556: LD_INT 5
95558: NEG
95559: PUSH
95560: LD_INT 3
95562: NEG
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 0
95570: PUSH
95571: LD_INT 3
95573: NEG
95574: PUSH
95575: EMPTY
95576: LIST
95577: LIST
95578: PUSH
95579: LD_INT 0
95581: PUSH
95582: LD_INT 4
95584: NEG
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: PUSH
95590: LD_INT 1
95592: PUSH
95593: LD_INT 3
95595: NEG
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: LD_INT 1
95603: PUSH
95604: LD_INT 2
95606: NEG
95607: PUSH
95608: EMPTY
95609: LIST
95610: LIST
95611: PUSH
95612: LD_INT 0
95614: PUSH
95615: LD_INT 2
95617: NEG
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: PUSH
95623: LD_INT 1
95625: NEG
95626: PUSH
95627: LD_INT 3
95629: NEG
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PUSH
95635: LD_INT 1
95637: NEG
95638: PUSH
95639: LD_INT 4
95641: NEG
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: PUSH
95647: LD_INT 2
95649: PUSH
95650: LD_INT 2
95652: NEG
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: LD_INT 2
95660: NEG
95661: PUSH
95662: LD_INT 4
95664: NEG
95665: PUSH
95666: EMPTY
95667: LIST
95668: LIST
95669: PUSH
95670: LD_INT 4
95672: PUSH
95673: LD_INT 0
95675: PUSH
95676: EMPTY
95677: LIST
95678: LIST
95679: PUSH
95680: LD_INT 4
95682: PUSH
95683: LD_INT 1
95685: NEG
95686: PUSH
95687: EMPTY
95688: LIST
95689: LIST
95690: PUSH
95691: LD_INT 5
95693: PUSH
95694: LD_INT 0
95696: PUSH
95697: EMPTY
95698: LIST
95699: LIST
95700: PUSH
95701: LD_INT 5
95703: PUSH
95704: LD_INT 1
95706: PUSH
95707: EMPTY
95708: LIST
95709: LIST
95710: PUSH
95711: LD_INT 4
95713: PUSH
95714: LD_INT 1
95716: PUSH
95717: EMPTY
95718: LIST
95719: LIST
95720: PUSH
95721: LD_INT 3
95723: PUSH
95724: LD_INT 0
95726: PUSH
95727: EMPTY
95728: LIST
95729: LIST
95730: PUSH
95731: LD_INT 3
95733: PUSH
95734: LD_INT 1
95736: NEG
95737: PUSH
95738: EMPTY
95739: LIST
95740: LIST
95741: PUSH
95742: LD_INT 3
95744: PUSH
95745: LD_INT 2
95747: NEG
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: PUSH
95753: LD_INT 5
95755: PUSH
95756: LD_INT 2
95758: PUSH
95759: EMPTY
95760: LIST
95761: LIST
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95810: LD_ADDR_VAR 0 32
95814: PUSH
95815: LD_INT 4
95817: NEG
95818: PUSH
95819: LD_INT 0
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: LD_INT 4
95828: NEG
95829: PUSH
95830: LD_INT 1
95832: NEG
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 3
95840: NEG
95841: PUSH
95842: LD_INT 0
95844: PUSH
95845: EMPTY
95846: LIST
95847: LIST
95848: PUSH
95849: LD_INT 3
95851: NEG
95852: PUSH
95853: LD_INT 1
95855: PUSH
95856: EMPTY
95857: LIST
95858: LIST
95859: PUSH
95860: LD_INT 4
95862: NEG
95863: PUSH
95864: LD_INT 1
95866: PUSH
95867: EMPTY
95868: LIST
95869: LIST
95870: PUSH
95871: LD_INT 5
95873: NEG
95874: PUSH
95875: LD_INT 0
95877: PUSH
95878: EMPTY
95879: LIST
95880: LIST
95881: PUSH
95882: LD_INT 5
95884: NEG
95885: PUSH
95886: LD_INT 1
95888: NEG
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 5
95896: NEG
95897: PUSH
95898: LD_INT 2
95900: NEG
95901: PUSH
95902: EMPTY
95903: LIST
95904: LIST
95905: PUSH
95906: LD_INT 3
95908: NEG
95909: PUSH
95910: LD_INT 2
95912: PUSH
95913: EMPTY
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 3
95919: NEG
95920: PUSH
95921: LD_INT 3
95923: NEG
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: PUSH
95929: LD_INT 3
95931: NEG
95932: PUSH
95933: LD_INT 4
95935: NEG
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 2
95943: NEG
95944: PUSH
95945: LD_INT 3
95947: NEG
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 2
95955: NEG
95956: PUSH
95957: LD_INT 2
95959: NEG
95960: PUSH
95961: EMPTY
95962: LIST
95963: LIST
95964: PUSH
95965: LD_INT 3
95967: NEG
95968: PUSH
95969: LD_INT 2
95971: NEG
95972: PUSH
95973: EMPTY
95974: LIST
95975: LIST
95976: PUSH
95977: LD_INT 4
95979: NEG
95980: PUSH
95981: LD_INT 3
95983: NEG
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: PUSH
95989: LD_INT 4
95991: NEG
95992: PUSH
95993: LD_INT 4
95995: NEG
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: PUSH
96001: LD_INT 2
96003: NEG
96004: PUSH
96005: LD_INT 4
96007: NEG
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PUSH
96013: LD_INT 4
96015: NEG
96016: PUSH
96017: LD_INT 2
96019: NEG
96020: PUSH
96021: EMPTY
96022: LIST
96023: LIST
96024: PUSH
96025: LD_INT 0
96027: PUSH
96028: LD_INT 4
96030: NEG
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: LD_INT 0
96038: PUSH
96039: LD_INT 5
96041: NEG
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: PUSH
96047: LD_INT 1
96049: PUSH
96050: LD_INT 4
96052: NEG
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 1
96060: PUSH
96061: LD_INT 3
96063: NEG
96064: PUSH
96065: EMPTY
96066: LIST
96067: LIST
96068: PUSH
96069: LD_INT 0
96071: PUSH
96072: LD_INT 3
96074: NEG
96075: PUSH
96076: EMPTY
96077: LIST
96078: LIST
96079: PUSH
96080: LD_INT 1
96082: NEG
96083: PUSH
96084: LD_INT 4
96086: NEG
96087: PUSH
96088: EMPTY
96089: LIST
96090: LIST
96091: PUSH
96092: LD_INT 1
96094: NEG
96095: PUSH
96096: LD_INT 5
96098: NEG
96099: PUSH
96100: EMPTY
96101: LIST
96102: LIST
96103: PUSH
96104: LD_INT 2
96106: PUSH
96107: LD_INT 3
96109: NEG
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: PUSH
96115: LD_INT 2
96117: NEG
96118: PUSH
96119: LD_INT 5
96121: NEG
96122: PUSH
96123: EMPTY
96124: LIST
96125: LIST
96126: PUSH
96127: LD_INT 3
96129: PUSH
96130: LD_INT 0
96132: PUSH
96133: EMPTY
96134: LIST
96135: LIST
96136: PUSH
96137: LD_INT 3
96139: PUSH
96140: LD_INT 1
96142: NEG
96143: PUSH
96144: EMPTY
96145: LIST
96146: LIST
96147: PUSH
96148: LD_INT 4
96150: PUSH
96151: LD_INT 0
96153: PUSH
96154: EMPTY
96155: LIST
96156: LIST
96157: PUSH
96158: LD_INT 4
96160: PUSH
96161: LD_INT 1
96163: PUSH
96164: EMPTY
96165: LIST
96166: LIST
96167: PUSH
96168: LD_INT 3
96170: PUSH
96171: LD_INT 1
96173: PUSH
96174: EMPTY
96175: LIST
96176: LIST
96177: PUSH
96178: LD_INT 2
96180: PUSH
96181: LD_INT 0
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: PUSH
96188: LD_INT 2
96190: PUSH
96191: LD_INT 1
96193: NEG
96194: PUSH
96195: EMPTY
96196: LIST
96197: LIST
96198: PUSH
96199: LD_INT 2
96201: PUSH
96202: LD_INT 2
96204: NEG
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: LD_INT 4
96212: PUSH
96213: LD_INT 2
96215: PUSH
96216: EMPTY
96217: LIST
96218: LIST
96219: PUSH
96220: LD_INT 4
96222: PUSH
96223: LD_INT 4
96225: PUSH
96226: EMPTY
96227: LIST
96228: LIST
96229: PUSH
96230: LD_INT 4
96232: PUSH
96233: LD_INT 3
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: PUSH
96240: LD_INT 5
96242: PUSH
96243: LD_INT 4
96245: PUSH
96246: EMPTY
96247: LIST
96248: LIST
96249: PUSH
96250: LD_INT 5
96252: PUSH
96253: LD_INT 5
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: PUSH
96260: LD_INT 4
96262: PUSH
96263: LD_INT 5
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 3
96272: PUSH
96273: LD_INT 4
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 3
96282: PUSH
96283: LD_INT 3
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: PUSH
96290: LD_INT 5
96292: PUSH
96293: LD_INT 3
96295: PUSH
96296: EMPTY
96297: LIST
96298: LIST
96299: PUSH
96300: LD_INT 3
96302: PUSH
96303: LD_INT 5
96305: PUSH
96306: EMPTY
96307: LIST
96308: LIST
96309: PUSH
96310: EMPTY
96311: LIST
96312: LIST
96313: LIST
96314: LIST
96315: LIST
96316: LIST
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: LIST
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96357: LD_ADDR_VAR 0 33
96361: PUSH
96362: LD_INT 4
96364: NEG
96365: PUSH
96366: LD_INT 4
96368: NEG
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PUSH
96374: LD_INT 4
96376: NEG
96377: PUSH
96378: LD_INT 5
96380: NEG
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_INT 3
96388: NEG
96389: PUSH
96390: LD_INT 4
96392: NEG
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: PUSH
96398: LD_INT 3
96400: NEG
96401: PUSH
96402: LD_INT 3
96404: NEG
96405: PUSH
96406: EMPTY
96407: LIST
96408: LIST
96409: PUSH
96410: LD_INT 4
96412: NEG
96413: PUSH
96414: LD_INT 3
96416: NEG
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: PUSH
96422: LD_INT 5
96424: NEG
96425: PUSH
96426: LD_INT 4
96428: NEG
96429: PUSH
96430: EMPTY
96431: LIST
96432: LIST
96433: PUSH
96434: LD_INT 5
96436: NEG
96437: PUSH
96438: LD_INT 5
96440: NEG
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: PUSH
96446: LD_INT 3
96448: NEG
96449: PUSH
96450: LD_INT 5
96452: NEG
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: LD_INT 5
96460: NEG
96461: PUSH
96462: LD_INT 3
96464: NEG
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PUSH
96470: LD_INT 0
96472: PUSH
96473: LD_INT 3
96475: NEG
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: PUSH
96481: LD_INT 0
96483: PUSH
96484: LD_INT 4
96486: NEG
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: PUSH
96492: LD_INT 1
96494: PUSH
96495: LD_INT 3
96497: NEG
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PUSH
96503: LD_INT 1
96505: PUSH
96506: LD_INT 2
96508: NEG
96509: PUSH
96510: EMPTY
96511: LIST
96512: LIST
96513: PUSH
96514: LD_INT 0
96516: PUSH
96517: LD_INT 2
96519: NEG
96520: PUSH
96521: EMPTY
96522: LIST
96523: LIST
96524: PUSH
96525: LD_INT 1
96527: NEG
96528: PUSH
96529: LD_INT 3
96531: NEG
96532: PUSH
96533: EMPTY
96534: LIST
96535: LIST
96536: PUSH
96537: LD_INT 1
96539: NEG
96540: PUSH
96541: LD_INT 4
96543: NEG
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: PUSH
96549: LD_INT 2
96551: PUSH
96552: LD_INT 2
96554: NEG
96555: PUSH
96556: EMPTY
96557: LIST
96558: LIST
96559: PUSH
96560: LD_INT 2
96562: NEG
96563: PUSH
96564: LD_INT 4
96566: NEG
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: PUSH
96572: LD_INT 4
96574: PUSH
96575: LD_INT 0
96577: PUSH
96578: EMPTY
96579: LIST
96580: LIST
96581: PUSH
96582: LD_INT 4
96584: PUSH
96585: LD_INT 1
96587: NEG
96588: PUSH
96589: EMPTY
96590: LIST
96591: LIST
96592: PUSH
96593: LD_INT 5
96595: PUSH
96596: LD_INT 0
96598: PUSH
96599: EMPTY
96600: LIST
96601: LIST
96602: PUSH
96603: LD_INT 5
96605: PUSH
96606: LD_INT 1
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: PUSH
96613: LD_INT 4
96615: PUSH
96616: LD_INT 1
96618: PUSH
96619: EMPTY
96620: LIST
96621: LIST
96622: PUSH
96623: LD_INT 3
96625: PUSH
96626: LD_INT 0
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: PUSH
96633: LD_INT 3
96635: PUSH
96636: LD_INT 1
96638: NEG
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PUSH
96644: LD_INT 3
96646: PUSH
96647: LD_INT 2
96649: NEG
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 5
96657: PUSH
96658: LD_INT 2
96660: PUSH
96661: EMPTY
96662: LIST
96663: LIST
96664: PUSH
96665: LD_INT 3
96667: PUSH
96668: LD_INT 3
96670: PUSH
96671: EMPTY
96672: LIST
96673: LIST
96674: PUSH
96675: LD_INT 3
96677: PUSH
96678: LD_INT 2
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: PUSH
96685: LD_INT 4
96687: PUSH
96688: LD_INT 3
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: LD_INT 4
96697: PUSH
96698: LD_INT 4
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 3
96707: PUSH
96708: LD_INT 4
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 2
96717: PUSH
96718: LD_INT 3
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 2
96727: PUSH
96728: LD_INT 2
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: LD_INT 4
96737: PUSH
96738: LD_INT 2
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: PUSH
96745: LD_INT 2
96747: PUSH
96748: LD_INT 4
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: PUSH
96755: LD_INT 0
96757: PUSH
96758: LD_INT 4
96760: PUSH
96761: EMPTY
96762: LIST
96763: LIST
96764: PUSH
96765: LD_INT 0
96767: PUSH
96768: LD_INT 3
96770: PUSH
96771: EMPTY
96772: LIST
96773: LIST
96774: PUSH
96775: LD_INT 1
96777: PUSH
96778: LD_INT 4
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PUSH
96785: LD_INT 1
96787: PUSH
96788: LD_INT 5
96790: PUSH
96791: EMPTY
96792: LIST
96793: LIST
96794: PUSH
96795: LD_INT 0
96797: PUSH
96798: LD_INT 5
96800: PUSH
96801: EMPTY
96802: LIST
96803: LIST
96804: PUSH
96805: LD_INT 1
96807: NEG
96808: PUSH
96809: LD_INT 4
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 1
96818: NEG
96819: PUSH
96820: LD_INT 3
96822: PUSH
96823: EMPTY
96824: LIST
96825: LIST
96826: PUSH
96827: LD_INT 2
96829: PUSH
96830: LD_INT 5
96832: PUSH
96833: EMPTY
96834: LIST
96835: LIST
96836: PUSH
96837: LD_INT 2
96839: NEG
96840: PUSH
96841: LD_INT 3
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96895: LD_ADDR_VAR 0 34
96899: PUSH
96900: LD_INT 0
96902: PUSH
96903: LD_INT 4
96905: NEG
96906: PUSH
96907: EMPTY
96908: LIST
96909: LIST
96910: PUSH
96911: LD_INT 0
96913: PUSH
96914: LD_INT 5
96916: NEG
96917: PUSH
96918: EMPTY
96919: LIST
96920: LIST
96921: PUSH
96922: LD_INT 1
96924: PUSH
96925: LD_INT 4
96927: NEG
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: PUSH
96933: LD_INT 1
96935: PUSH
96936: LD_INT 3
96938: NEG
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: LD_INT 0
96946: PUSH
96947: LD_INT 3
96949: NEG
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: LD_INT 1
96957: NEG
96958: PUSH
96959: LD_INT 4
96961: NEG
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: PUSH
96967: LD_INT 1
96969: NEG
96970: PUSH
96971: LD_INT 5
96973: NEG
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: PUSH
96979: LD_INT 2
96981: PUSH
96982: LD_INT 3
96984: NEG
96985: PUSH
96986: EMPTY
96987: LIST
96988: LIST
96989: PUSH
96990: LD_INT 2
96992: NEG
96993: PUSH
96994: LD_INT 5
96996: NEG
96997: PUSH
96998: EMPTY
96999: LIST
97000: LIST
97001: PUSH
97002: LD_INT 3
97004: PUSH
97005: LD_INT 0
97007: PUSH
97008: EMPTY
97009: LIST
97010: LIST
97011: PUSH
97012: LD_INT 3
97014: PUSH
97015: LD_INT 1
97017: NEG
97018: PUSH
97019: EMPTY
97020: LIST
97021: LIST
97022: PUSH
97023: LD_INT 4
97025: PUSH
97026: LD_INT 0
97028: PUSH
97029: EMPTY
97030: LIST
97031: LIST
97032: PUSH
97033: LD_INT 4
97035: PUSH
97036: LD_INT 1
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PUSH
97043: LD_INT 3
97045: PUSH
97046: LD_INT 1
97048: PUSH
97049: EMPTY
97050: LIST
97051: LIST
97052: PUSH
97053: LD_INT 2
97055: PUSH
97056: LD_INT 0
97058: PUSH
97059: EMPTY
97060: LIST
97061: LIST
97062: PUSH
97063: LD_INT 2
97065: PUSH
97066: LD_INT 1
97068: NEG
97069: PUSH
97070: EMPTY
97071: LIST
97072: LIST
97073: PUSH
97074: LD_INT 2
97076: PUSH
97077: LD_INT 2
97079: NEG
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: PUSH
97085: LD_INT 4
97087: PUSH
97088: LD_INT 2
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 4
97097: PUSH
97098: LD_INT 4
97100: PUSH
97101: EMPTY
97102: LIST
97103: LIST
97104: PUSH
97105: LD_INT 4
97107: PUSH
97108: LD_INT 3
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: PUSH
97115: LD_INT 5
97117: PUSH
97118: LD_INT 4
97120: PUSH
97121: EMPTY
97122: LIST
97123: LIST
97124: PUSH
97125: LD_INT 5
97127: PUSH
97128: LD_INT 5
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PUSH
97135: LD_INT 4
97137: PUSH
97138: LD_INT 5
97140: PUSH
97141: EMPTY
97142: LIST
97143: LIST
97144: PUSH
97145: LD_INT 3
97147: PUSH
97148: LD_INT 4
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PUSH
97155: LD_INT 3
97157: PUSH
97158: LD_INT 3
97160: PUSH
97161: EMPTY
97162: LIST
97163: LIST
97164: PUSH
97165: LD_INT 5
97167: PUSH
97168: LD_INT 3
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PUSH
97175: LD_INT 3
97177: PUSH
97178: LD_INT 5
97180: PUSH
97181: EMPTY
97182: LIST
97183: LIST
97184: PUSH
97185: LD_INT 0
97187: PUSH
97188: LD_INT 3
97190: PUSH
97191: EMPTY
97192: LIST
97193: LIST
97194: PUSH
97195: LD_INT 0
97197: PUSH
97198: LD_INT 2
97200: PUSH
97201: EMPTY
97202: LIST
97203: LIST
97204: PUSH
97205: LD_INT 1
97207: PUSH
97208: LD_INT 3
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PUSH
97215: LD_INT 1
97217: PUSH
97218: LD_INT 4
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: PUSH
97225: LD_INT 0
97227: PUSH
97228: LD_INT 4
97230: PUSH
97231: EMPTY
97232: LIST
97233: LIST
97234: PUSH
97235: LD_INT 1
97237: NEG
97238: PUSH
97239: LD_INT 3
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 1
97248: NEG
97249: PUSH
97250: LD_INT 2
97252: PUSH
97253: EMPTY
97254: LIST
97255: LIST
97256: PUSH
97257: LD_INT 2
97259: PUSH
97260: LD_INT 4
97262: PUSH
97263: EMPTY
97264: LIST
97265: LIST
97266: PUSH
97267: LD_INT 2
97269: NEG
97270: PUSH
97271: LD_INT 2
97273: PUSH
97274: EMPTY
97275: LIST
97276: LIST
97277: PUSH
97278: LD_INT 4
97280: NEG
97281: PUSH
97282: LD_INT 0
97284: PUSH
97285: EMPTY
97286: LIST
97287: LIST
97288: PUSH
97289: LD_INT 4
97291: NEG
97292: PUSH
97293: LD_INT 1
97295: NEG
97296: PUSH
97297: EMPTY
97298: LIST
97299: LIST
97300: PUSH
97301: LD_INT 3
97303: NEG
97304: PUSH
97305: LD_INT 0
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: PUSH
97312: LD_INT 3
97314: NEG
97315: PUSH
97316: LD_INT 1
97318: PUSH
97319: EMPTY
97320: LIST
97321: LIST
97322: PUSH
97323: LD_INT 4
97325: NEG
97326: PUSH
97327: LD_INT 1
97329: PUSH
97330: EMPTY
97331: LIST
97332: LIST
97333: PUSH
97334: LD_INT 5
97336: NEG
97337: PUSH
97338: LD_INT 0
97340: PUSH
97341: EMPTY
97342: LIST
97343: LIST
97344: PUSH
97345: LD_INT 5
97347: NEG
97348: PUSH
97349: LD_INT 1
97351: NEG
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_INT 5
97359: NEG
97360: PUSH
97361: LD_INT 2
97363: NEG
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: LD_INT 3
97371: NEG
97372: PUSH
97373: LD_INT 2
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: PUSH
97380: EMPTY
97381: LIST
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: LIST
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: ST_TO_ADDR
// end ; end ;
97427: GO 97430
97429: POP
// case btype of b_depot , b_warehouse :
97430: LD_VAR 0 1
97434: PUSH
97435: LD_INT 0
97437: DOUBLE
97438: EQUAL
97439: IFTRUE 97449
97441: LD_INT 1
97443: DOUBLE
97444: EQUAL
97445: IFTRUE 97449
97447: GO 97650
97449: POP
// case nation of nation_american :
97450: LD_VAR 0 5
97454: PUSH
97455: LD_INT 1
97457: DOUBLE
97458: EQUAL
97459: IFTRUE 97463
97461: GO 97519
97463: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97464: LD_ADDR_VAR 0 9
97468: PUSH
97469: LD_VAR 0 11
97473: PUSH
97474: LD_VAR 0 12
97478: PUSH
97479: LD_VAR 0 13
97483: PUSH
97484: LD_VAR 0 14
97488: PUSH
97489: LD_VAR 0 15
97493: PUSH
97494: LD_VAR 0 16
97498: PUSH
97499: EMPTY
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: PUSH
97507: LD_VAR 0 4
97511: PUSH
97512: LD_INT 1
97514: PLUS
97515: ARRAY
97516: ST_TO_ADDR
97517: GO 97648
97519: LD_INT 2
97521: DOUBLE
97522: EQUAL
97523: IFTRUE 97527
97525: GO 97583
97527: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97528: LD_ADDR_VAR 0 9
97532: PUSH
97533: LD_VAR 0 17
97537: PUSH
97538: LD_VAR 0 18
97542: PUSH
97543: LD_VAR 0 19
97547: PUSH
97548: LD_VAR 0 20
97552: PUSH
97553: LD_VAR 0 21
97557: PUSH
97558: LD_VAR 0 22
97562: PUSH
97563: EMPTY
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: PUSH
97571: LD_VAR 0 4
97575: PUSH
97576: LD_INT 1
97578: PLUS
97579: ARRAY
97580: ST_TO_ADDR
97581: GO 97648
97583: LD_INT 3
97585: DOUBLE
97586: EQUAL
97587: IFTRUE 97591
97589: GO 97647
97591: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97592: LD_ADDR_VAR 0 9
97596: PUSH
97597: LD_VAR 0 23
97601: PUSH
97602: LD_VAR 0 24
97606: PUSH
97607: LD_VAR 0 25
97611: PUSH
97612: LD_VAR 0 26
97616: PUSH
97617: LD_VAR 0 27
97621: PUSH
97622: LD_VAR 0 28
97626: PUSH
97627: EMPTY
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: PUSH
97635: LD_VAR 0 4
97639: PUSH
97640: LD_INT 1
97642: PLUS
97643: ARRAY
97644: ST_TO_ADDR
97645: GO 97648
97647: POP
97648: GO 98203
97650: LD_INT 2
97652: DOUBLE
97653: EQUAL
97654: IFTRUE 97664
97656: LD_INT 3
97658: DOUBLE
97659: EQUAL
97660: IFTRUE 97664
97662: GO 97720
97664: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97665: LD_ADDR_VAR 0 9
97669: PUSH
97670: LD_VAR 0 29
97674: PUSH
97675: LD_VAR 0 30
97679: PUSH
97680: LD_VAR 0 31
97684: PUSH
97685: LD_VAR 0 32
97689: PUSH
97690: LD_VAR 0 33
97694: PUSH
97695: LD_VAR 0 34
97699: PUSH
97700: EMPTY
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: PUSH
97708: LD_VAR 0 4
97712: PUSH
97713: LD_INT 1
97715: PLUS
97716: ARRAY
97717: ST_TO_ADDR
97718: GO 98203
97720: LD_INT 16
97722: DOUBLE
97723: EQUAL
97724: IFTRUE 97782
97726: LD_INT 17
97728: DOUBLE
97729: EQUAL
97730: IFTRUE 97782
97732: LD_INT 18
97734: DOUBLE
97735: EQUAL
97736: IFTRUE 97782
97738: LD_INT 19
97740: DOUBLE
97741: EQUAL
97742: IFTRUE 97782
97744: LD_INT 22
97746: DOUBLE
97747: EQUAL
97748: IFTRUE 97782
97750: LD_INT 20
97752: DOUBLE
97753: EQUAL
97754: IFTRUE 97782
97756: LD_INT 21
97758: DOUBLE
97759: EQUAL
97760: IFTRUE 97782
97762: LD_INT 23
97764: DOUBLE
97765: EQUAL
97766: IFTRUE 97782
97768: LD_INT 24
97770: DOUBLE
97771: EQUAL
97772: IFTRUE 97782
97774: LD_INT 25
97776: DOUBLE
97777: EQUAL
97778: IFTRUE 97782
97780: GO 97838
97782: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97783: LD_ADDR_VAR 0 9
97787: PUSH
97788: LD_VAR 0 35
97792: PUSH
97793: LD_VAR 0 36
97797: PUSH
97798: LD_VAR 0 37
97802: PUSH
97803: LD_VAR 0 38
97807: PUSH
97808: LD_VAR 0 39
97812: PUSH
97813: LD_VAR 0 40
97817: PUSH
97818: EMPTY
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: PUSH
97826: LD_VAR 0 4
97830: PUSH
97831: LD_INT 1
97833: PLUS
97834: ARRAY
97835: ST_TO_ADDR
97836: GO 98203
97838: LD_INT 6
97840: DOUBLE
97841: EQUAL
97842: IFTRUE 97894
97844: LD_INT 7
97846: DOUBLE
97847: EQUAL
97848: IFTRUE 97894
97850: LD_INT 8
97852: DOUBLE
97853: EQUAL
97854: IFTRUE 97894
97856: LD_INT 13
97858: DOUBLE
97859: EQUAL
97860: IFTRUE 97894
97862: LD_INT 12
97864: DOUBLE
97865: EQUAL
97866: IFTRUE 97894
97868: LD_INT 15
97870: DOUBLE
97871: EQUAL
97872: IFTRUE 97894
97874: LD_INT 11
97876: DOUBLE
97877: EQUAL
97878: IFTRUE 97894
97880: LD_INT 14
97882: DOUBLE
97883: EQUAL
97884: IFTRUE 97894
97886: LD_INT 10
97888: DOUBLE
97889: EQUAL
97890: IFTRUE 97894
97892: GO 97950
97894: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97895: LD_ADDR_VAR 0 9
97899: PUSH
97900: LD_VAR 0 41
97904: PUSH
97905: LD_VAR 0 42
97909: PUSH
97910: LD_VAR 0 43
97914: PUSH
97915: LD_VAR 0 44
97919: PUSH
97920: LD_VAR 0 45
97924: PUSH
97925: LD_VAR 0 46
97929: PUSH
97930: EMPTY
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: PUSH
97938: LD_VAR 0 4
97942: PUSH
97943: LD_INT 1
97945: PLUS
97946: ARRAY
97947: ST_TO_ADDR
97948: GO 98203
97950: LD_INT 36
97952: DOUBLE
97953: EQUAL
97954: IFTRUE 97958
97956: GO 98014
97958: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97959: LD_ADDR_VAR 0 9
97963: PUSH
97964: LD_VAR 0 47
97968: PUSH
97969: LD_VAR 0 48
97973: PUSH
97974: LD_VAR 0 49
97978: PUSH
97979: LD_VAR 0 50
97983: PUSH
97984: LD_VAR 0 51
97988: PUSH
97989: LD_VAR 0 52
97993: PUSH
97994: EMPTY
97995: LIST
97996: LIST
97997: LIST
97998: LIST
97999: LIST
98000: LIST
98001: PUSH
98002: LD_VAR 0 4
98006: PUSH
98007: LD_INT 1
98009: PLUS
98010: ARRAY
98011: ST_TO_ADDR
98012: GO 98203
98014: LD_INT 4
98016: DOUBLE
98017: EQUAL
98018: IFTRUE 98040
98020: LD_INT 5
98022: DOUBLE
98023: EQUAL
98024: IFTRUE 98040
98026: LD_INT 34
98028: DOUBLE
98029: EQUAL
98030: IFTRUE 98040
98032: LD_INT 37
98034: DOUBLE
98035: EQUAL
98036: IFTRUE 98040
98038: GO 98096
98040: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98041: LD_ADDR_VAR 0 9
98045: PUSH
98046: LD_VAR 0 53
98050: PUSH
98051: LD_VAR 0 54
98055: PUSH
98056: LD_VAR 0 55
98060: PUSH
98061: LD_VAR 0 56
98065: PUSH
98066: LD_VAR 0 57
98070: PUSH
98071: LD_VAR 0 58
98075: PUSH
98076: EMPTY
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: LIST
98082: LIST
98083: PUSH
98084: LD_VAR 0 4
98088: PUSH
98089: LD_INT 1
98091: PLUS
98092: ARRAY
98093: ST_TO_ADDR
98094: GO 98203
98096: LD_INT 31
98098: DOUBLE
98099: EQUAL
98100: IFTRUE 98146
98102: LD_INT 32
98104: DOUBLE
98105: EQUAL
98106: IFTRUE 98146
98108: LD_INT 33
98110: DOUBLE
98111: EQUAL
98112: IFTRUE 98146
98114: LD_INT 27
98116: DOUBLE
98117: EQUAL
98118: IFTRUE 98146
98120: LD_INT 26
98122: DOUBLE
98123: EQUAL
98124: IFTRUE 98146
98126: LD_INT 28
98128: DOUBLE
98129: EQUAL
98130: IFTRUE 98146
98132: LD_INT 29
98134: DOUBLE
98135: EQUAL
98136: IFTRUE 98146
98138: LD_INT 30
98140: DOUBLE
98141: EQUAL
98142: IFTRUE 98146
98144: GO 98202
98146: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98147: LD_ADDR_VAR 0 9
98151: PUSH
98152: LD_VAR 0 59
98156: PUSH
98157: LD_VAR 0 60
98161: PUSH
98162: LD_VAR 0 61
98166: PUSH
98167: LD_VAR 0 62
98171: PUSH
98172: LD_VAR 0 63
98176: PUSH
98177: LD_VAR 0 64
98181: PUSH
98182: EMPTY
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: PUSH
98190: LD_VAR 0 4
98194: PUSH
98195: LD_INT 1
98197: PLUS
98198: ARRAY
98199: ST_TO_ADDR
98200: GO 98203
98202: POP
// temp_list2 = [ ] ;
98203: LD_ADDR_VAR 0 10
98207: PUSH
98208: EMPTY
98209: ST_TO_ADDR
// for i in temp_list do
98210: LD_ADDR_VAR 0 8
98214: PUSH
98215: LD_VAR 0 9
98219: PUSH
98220: FOR_IN
98221: IFFALSE 98273
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98223: LD_ADDR_VAR 0 10
98227: PUSH
98228: LD_VAR 0 10
98232: PUSH
98233: LD_VAR 0 8
98237: PUSH
98238: LD_INT 1
98240: ARRAY
98241: PUSH
98242: LD_VAR 0 2
98246: PLUS
98247: PUSH
98248: LD_VAR 0 8
98252: PUSH
98253: LD_INT 2
98255: ARRAY
98256: PUSH
98257: LD_VAR 0 3
98261: PLUS
98262: PUSH
98263: EMPTY
98264: LIST
98265: LIST
98266: PUSH
98267: EMPTY
98268: LIST
98269: ADD
98270: ST_TO_ADDR
98271: GO 98220
98273: POP
98274: POP
// result = temp_list2 ;
98275: LD_ADDR_VAR 0 7
98279: PUSH
98280: LD_VAR 0 10
98284: ST_TO_ADDR
// end ;
98285: LD_VAR 0 7
98289: RET
// export function EnemyInRange ( unit , dist ) ; begin
98290: LD_INT 0
98292: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98293: LD_ADDR_VAR 0 3
98297: PUSH
98298: LD_VAR 0 1
98302: PPUSH
98303: CALL_OW 255
98307: PPUSH
98308: LD_VAR 0 1
98312: PPUSH
98313: CALL_OW 250
98317: PPUSH
98318: LD_VAR 0 1
98322: PPUSH
98323: CALL_OW 251
98327: PPUSH
98328: LD_VAR 0 2
98332: PPUSH
98333: CALL 72394 0 4
98337: PUSH
98338: LD_INT 4
98340: ARRAY
98341: ST_TO_ADDR
// end ;
98342: LD_VAR 0 3
98346: RET
// export function PlayerSeeMe ( unit ) ; begin
98347: LD_INT 0
98349: PPUSH
// result := See ( your_side , unit ) ;
98350: LD_ADDR_VAR 0 2
98354: PUSH
98355: LD_OWVAR 2
98359: PPUSH
98360: LD_VAR 0 1
98364: PPUSH
98365: CALL_OW 292
98369: ST_TO_ADDR
// end ;
98370: LD_VAR 0 2
98374: RET
// export function ReverseDir ( unit ) ; begin
98375: LD_INT 0
98377: PPUSH
// if not unit then
98378: LD_VAR 0 1
98382: NOT
98383: IFFALSE 98387
// exit ;
98385: GO 98433
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
98387: LD_ADDR_VAR 0 2
98391: PUSH
98392: LD_INT 3
98394: PUSH
98395: LD_INT 4
98397: PUSH
98398: LD_INT 5
98400: PUSH
98401: LD_INT 0
98403: PUSH
98404: LD_INT 1
98406: PUSH
98407: LD_INT 2
98409: PUSH
98410: EMPTY
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: PUSH
98418: LD_VAR 0 1
98422: PPUSH
98423: CALL_OW 254
98427: PUSH
98428: LD_INT 1
98430: PLUS
98431: ARRAY
98432: ST_TO_ADDR
// end ;
98433: LD_VAR 0 2
98437: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98438: LD_INT 0
98440: PPUSH
98441: PPUSH
98442: PPUSH
98443: PPUSH
98444: PPUSH
// if not hexes then
98445: LD_VAR 0 2
98449: NOT
98450: IFFALSE 98454
// exit ;
98452: GO 98602
// dist := 9999 ;
98454: LD_ADDR_VAR 0 5
98458: PUSH
98459: LD_INT 9999
98461: ST_TO_ADDR
// for i = 1 to hexes do
98462: LD_ADDR_VAR 0 4
98466: PUSH
98467: DOUBLE
98468: LD_INT 1
98470: DEC
98471: ST_TO_ADDR
98472: LD_VAR 0 2
98476: PUSH
98477: FOR_TO
98478: IFFALSE 98590
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98480: LD_VAR 0 1
98484: PPUSH
98485: LD_VAR 0 2
98489: PUSH
98490: LD_VAR 0 4
98494: ARRAY
98495: PUSH
98496: LD_INT 1
98498: ARRAY
98499: PPUSH
98500: LD_VAR 0 2
98504: PUSH
98505: LD_VAR 0 4
98509: ARRAY
98510: PUSH
98511: LD_INT 2
98513: ARRAY
98514: PPUSH
98515: CALL_OW 297
98519: PUSH
98520: LD_VAR 0 5
98524: LESS
98525: IFFALSE 98588
// begin hex := hexes [ i ] ;
98527: LD_ADDR_VAR 0 7
98531: PUSH
98532: LD_VAR 0 2
98536: PUSH
98537: LD_VAR 0 4
98541: ARRAY
98542: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98543: LD_ADDR_VAR 0 5
98547: PUSH
98548: LD_VAR 0 1
98552: PPUSH
98553: LD_VAR 0 2
98557: PUSH
98558: LD_VAR 0 4
98562: ARRAY
98563: PUSH
98564: LD_INT 1
98566: ARRAY
98567: PPUSH
98568: LD_VAR 0 2
98572: PUSH
98573: LD_VAR 0 4
98577: ARRAY
98578: PUSH
98579: LD_INT 2
98581: ARRAY
98582: PPUSH
98583: CALL_OW 297
98587: ST_TO_ADDR
// end ; end ;
98588: GO 98477
98590: POP
98591: POP
// result := hex ;
98592: LD_ADDR_VAR 0 3
98596: PUSH
98597: LD_VAR 0 7
98601: ST_TO_ADDR
// end ;
98602: LD_VAR 0 3
98606: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98607: LD_INT 0
98609: PPUSH
98610: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98611: LD_VAR 0 1
98615: NOT
98616: PUSH
98617: LD_VAR 0 1
98621: PUSH
98622: LD_INT 21
98624: PUSH
98625: LD_INT 2
98627: PUSH
98628: EMPTY
98629: LIST
98630: LIST
98631: PUSH
98632: LD_INT 23
98634: PUSH
98635: LD_INT 2
98637: PUSH
98638: EMPTY
98639: LIST
98640: LIST
98641: PUSH
98642: EMPTY
98643: LIST
98644: LIST
98645: PPUSH
98646: CALL_OW 69
98650: IN
98651: NOT
98652: OR
98653: IFFALSE 98657
// exit ;
98655: GO 98704
// for i = 1 to 3 do
98657: LD_ADDR_VAR 0 3
98661: PUSH
98662: DOUBLE
98663: LD_INT 1
98665: DEC
98666: ST_TO_ADDR
98667: LD_INT 3
98669: PUSH
98670: FOR_TO
98671: IFFALSE 98702
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98673: LD_VAR 0 1
98677: PPUSH
98678: CALL_OW 250
98682: PPUSH
98683: LD_VAR 0 1
98687: PPUSH
98688: CALL_OW 251
98692: PPUSH
98693: LD_INT 1
98695: PPUSH
98696: CALL_OW 453
98700: GO 98670
98702: POP
98703: POP
// end ;
98704: LD_VAR 0 2
98708: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98709: LD_INT 0
98711: PPUSH
98712: PPUSH
98713: PPUSH
98714: PPUSH
98715: PPUSH
98716: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98717: LD_VAR 0 1
98721: NOT
98722: PUSH
98723: LD_VAR 0 2
98727: NOT
98728: OR
98729: PUSH
98730: LD_VAR 0 1
98734: PPUSH
98735: CALL_OW 314
98739: OR
98740: IFFALSE 98744
// exit ;
98742: GO 99185
// x := GetX ( enemy_unit ) ;
98744: LD_ADDR_VAR 0 7
98748: PUSH
98749: LD_VAR 0 2
98753: PPUSH
98754: CALL_OW 250
98758: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98759: LD_ADDR_VAR 0 8
98763: PUSH
98764: LD_VAR 0 2
98768: PPUSH
98769: CALL_OW 251
98773: ST_TO_ADDR
// if not x or not y then
98774: LD_VAR 0 7
98778: NOT
98779: PUSH
98780: LD_VAR 0 8
98784: NOT
98785: OR
98786: IFFALSE 98790
// exit ;
98788: GO 99185
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98790: LD_ADDR_VAR 0 6
98794: PUSH
98795: LD_VAR 0 7
98799: PPUSH
98800: LD_INT 0
98802: PPUSH
98803: LD_INT 4
98805: PPUSH
98806: CALL_OW 272
98810: PUSH
98811: LD_VAR 0 8
98815: PPUSH
98816: LD_INT 0
98818: PPUSH
98819: LD_INT 4
98821: PPUSH
98822: CALL_OW 273
98826: PUSH
98827: EMPTY
98828: LIST
98829: LIST
98830: PUSH
98831: LD_VAR 0 7
98835: PPUSH
98836: LD_INT 1
98838: PPUSH
98839: LD_INT 4
98841: PPUSH
98842: CALL_OW 272
98846: PUSH
98847: LD_VAR 0 8
98851: PPUSH
98852: LD_INT 1
98854: PPUSH
98855: LD_INT 4
98857: PPUSH
98858: CALL_OW 273
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: PUSH
98867: LD_VAR 0 7
98871: PPUSH
98872: LD_INT 2
98874: PPUSH
98875: LD_INT 4
98877: PPUSH
98878: CALL_OW 272
98882: PUSH
98883: LD_VAR 0 8
98887: PPUSH
98888: LD_INT 2
98890: PPUSH
98891: LD_INT 4
98893: PPUSH
98894: CALL_OW 273
98898: PUSH
98899: EMPTY
98900: LIST
98901: LIST
98902: PUSH
98903: LD_VAR 0 7
98907: PPUSH
98908: LD_INT 3
98910: PPUSH
98911: LD_INT 4
98913: PPUSH
98914: CALL_OW 272
98918: PUSH
98919: LD_VAR 0 8
98923: PPUSH
98924: LD_INT 3
98926: PPUSH
98927: LD_INT 4
98929: PPUSH
98930: CALL_OW 273
98934: PUSH
98935: EMPTY
98936: LIST
98937: LIST
98938: PUSH
98939: LD_VAR 0 7
98943: PPUSH
98944: LD_INT 4
98946: PPUSH
98947: LD_INT 4
98949: PPUSH
98950: CALL_OW 272
98954: PUSH
98955: LD_VAR 0 8
98959: PPUSH
98960: LD_INT 4
98962: PPUSH
98963: LD_INT 4
98965: PPUSH
98966: CALL_OW 273
98970: PUSH
98971: EMPTY
98972: LIST
98973: LIST
98974: PUSH
98975: LD_VAR 0 7
98979: PPUSH
98980: LD_INT 5
98982: PPUSH
98983: LD_INT 4
98985: PPUSH
98986: CALL_OW 272
98990: PUSH
98991: LD_VAR 0 8
98995: PPUSH
98996: LD_INT 5
98998: PPUSH
98999: LD_INT 4
99001: PPUSH
99002: CALL_OW 273
99006: PUSH
99007: EMPTY
99008: LIST
99009: LIST
99010: PUSH
99011: EMPTY
99012: LIST
99013: LIST
99014: LIST
99015: LIST
99016: LIST
99017: LIST
99018: ST_TO_ADDR
// for i = tmp downto 1 do
99019: LD_ADDR_VAR 0 4
99023: PUSH
99024: DOUBLE
99025: LD_VAR 0 6
99029: INC
99030: ST_TO_ADDR
99031: LD_INT 1
99033: PUSH
99034: FOR_DOWNTO
99035: IFFALSE 99136
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99037: LD_VAR 0 6
99041: PUSH
99042: LD_VAR 0 4
99046: ARRAY
99047: PUSH
99048: LD_INT 1
99050: ARRAY
99051: PPUSH
99052: LD_VAR 0 6
99056: PUSH
99057: LD_VAR 0 4
99061: ARRAY
99062: PUSH
99063: LD_INT 2
99065: ARRAY
99066: PPUSH
99067: CALL_OW 488
99071: NOT
99072: PUSH
99073: LD_VAR 0 6
99077: PUSH
99078: LD_VAR 0 4
99082: ARRAY
99083: PUSH
99084: LD_INT 1
99086: ARRAY
99087: PPUSH
99088: LD_VAR 0 6
99092: PUSH
99093: LD_VAR 0 4
99097: ARRAY
99098: PUSH
99099: LD_INT 2
99101: ARRAY
99102: PPUSH
99103: CALL_OW 428
99107: PUSH
99108: LD_INT 0
99110: NONEQUAL
99111: OR
99112: IFFALSE 99134
// tmp := Delete ( tmp , i ) ;
99114: LD_ADDR_VAR 0 6
99118: PUSH
99119: LD_VAR 0 6
99123: PPUSH
99124: LD_VAR 0 4
99128: PPUSH
99129: CALL_OW 3
99133: ST_TO_ADDR
99134: GO 99034
99136: POP
99137: POP
// j := GetClosestHex ( unit , tmp ) ;
99138: LD_ADDR_VAR 0 5
99142: PUSH
99143: LD_VAR 0 1
99147: PPUSH
99148: LD_VAR 0 6
99152: PPUSH
99153: CALL 98438 0 2
99157: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99158: LD_VAR 0 1
99162: PPUSH
99163: LD_VAR 0 5
99167: PUSH
99168: LD_INT 1
99170: ARRAY
99171: PPUSH
99172: LD_VAR 0 5
99176: PUSH
99177: LD_INT 2
99179: ARRAY
99180: PPUSH
99181: CALL_OW 111
// end ;
99185: LD_VAR 0 3
99189: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99190: LD_INT 0
99192: PPUSH
99193: PPUSH
99194: PPUSH
// uc_side = 0 ;
99195: LD_ADDR_OWVAR 20
99199: PUSH
99200: LD_INT 0
99202: ST_TO_ADDR
// uc_nation = 0 ;
99203: LD_ADDR_OWVAR 21
99207: PUSH
99208: LD_INT 0
99210: ST_TO_ADDR
// InitHc ;
99211: CALL_OW 19
// InitVc ;
99215: CALL_OW 20
// if mastodonts then
99219: LD_VAR 0 6
99223: IFFALSE 99290
// for i = 1 to mastodonts do
99225: LD_ADDR_VAR 0 11
99229: PUSH
99230: DOUBLE
99231: LD_INT 1
99233: DEC
99234: ST_TO_ADDR
99235: LD_VAR 0 6
99239: PUSH
99240: FOR_TO
99241: IFFALSE 99288
// begin vc_chassis := 31 ;
99243: LD_ADDR_OWVAR 37
99247: PUSH
99248: LD_INT 31
99250: ST_TO_ADDR
// vc_control := control_rider ;
99251: LD_ADDR_OWVAR 38
99255: PUSH
99256: LD_INT 4
99258: ST_TO_ADDR
// animal := CreateVehicle ;
99259: LD_ADDR_VAR 0 12
99263: PUSH
99264: CALL_OW 45
99268: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99269: LD_VAR 0 12
99273: PPUSH
99274: LD_VAR 0 8
99278: PPUSH
99279: LD_INT 0
99281: PPUSH
99282: CALL 106061 0 3
// end ;
99286: GO 99240
99288: POP
99289: POP
// if horses then
99290: LD_VAR 0 5
99294: IFFALSE 99361
// for i = 1 to horses do
99296: LD_ADDR_VAR 0 11
99300: PUSH
99301: DOUBLE
99302: LD_INT 1
99304: DEC
99305: ST_TO_ADDR
99306: LD_VAR 0 5
99310: PUSH
99311: FOR_TO
99312: IFFALSE 99359
// begin hc_class := 21 ;
99314: LD_ADDR_OWVAR 28
99318: PUSH
99319: LD_INT 21
99321: ST_TO_ADDR
// hc_gallery :=  ;
99322: LD_ADDR_OWVAR 33
99326: PUSH
99327: LD_STRING 
99329: ST_TO_ADDR
// animal := CreateHuman ;
99330: LD_ADDR_VAR 0 12
99334: PUSH
99335: CALL_OW 44
99339: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99340: LD_VAR 0 12
99344: PPUSH
99345: LD_VAR 0 8
99349: PPUSH
99350: LD_INT 0
99352: PPUSH
99353: CALL 106061 0 3
// end ;
99357: GO 99311
99359: POP
99360: POP
// if birds then
99361: LD_VAR 0 1
99365: IFFALSE 99432
// for i = 1 to birds do
99367: LD_ADDR_VAR 0 11
99371: PUSH
99372: DOUBLE
99373: LD_INT 1
99375: DEC
99376: ST_TO_ADDR
99377: LD_VAR 0 1
99381: PUSH
99382: FOR_TO
99383: IFFALSE 99430
// begin hc_class = 18 ;
99385: LD_ADDR_OWVAR 28
99389: PUSH
99390: LD_INT 18
99392: ST_TO_ADDR
// hc_gallery =  ;
99393: LD_ADDR_OWVAR 33
99397: PUSH
99398: LD_STRING 
99400: ST_TO_ADDR
// animal := CreateHuman ;
99401: LD_ADDR_VAR 0 12
99405: PUSH
99406: CALL_OW 44
99410: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99411: LD_VAR 0 12
99415: PPUSH
99416: LD_VAR 0 8
99420: PPUSH
99421: LD_INT 0
99423: PPUSH
99424: CALL 106061 0 3
// end ;
99428: GO 99382
99430: POP
99431: POP
// if tigers then
99432: LD_VAR 0 2
99436: IFFALSE 99520
// for i = 1 to tigers do
99438: LD_ADDR_VAR 0 11
99442: PUSH
99443: DOUBLE
99444: LD_INT 1
99446: DEC
99447: ST_TO_ADDR
99448: LD_VAR 0 2
99452: PUSH
99453: FOR_TO
99454: IFFALSE 99518
// begin hc_class = class_tiger ;
99456: LD_ADDR_OWVAR 28
99460: PUSH
99461: LD_INT 14
99463: ST_TO_ADDR
// hc_gallery =  ;
99464: LD_ADDR_OWVAR 33
99468: PUSH
99469: LD_STRING 
99471: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99472: LD_ADDR_OWVAR 35
99476: PUSH
99477: LD_INT 7
99479: NEG
99480: PPUSH
99481: LD_INT 7
99483: PPUSH
99484: CALL_OW 12
99488: ST_TO_ADDR
// animal := CreateHuman ;
99489: LD_ADDR_VAR 0 12
99493: PUSH
99494: CALL_OW 44
99498: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99499: LD_VAR 0 12
99503: PPUSH
99504: LD_VAR 0 8
99508: PPUSH
99509: LD_INT 0
99511: PPUSH
99512: CALL 106061 0 3
// end ;
99516: GO 99453
99518: POP
99519: POP
// if apemans then
99520: LD_VAR 0 3
99524: IFFALSE 99647
// for i = 1 to apemans do
99526: LD_ADDR_VAR 0 11
99530: PUSH
99531: DOUBLE
99532: LD_INT 1
99534: DEC
99535: ST_TO_ADDR
99536: LD_VAR 0 3
99540: PUSH
99541: FOR_TO
99542: IFFALSE 99645
// begin hc_class = class_apeman ;
99544: LD_ADDR_OWVAR 28
99548: PUSH
99549: LD_INT 12
99551: ST_TO_ADDR
// hc_gallery =  ;
99552: LD_ADDR_OWVAR 33
99556: PUSH
99557: LD_STRING 
99559: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99560: LD_ADDR_OWVAR 35
99564: PUSH
99565: LD_INT 5
99567: NEG
99568: PPUSH
99569: LD_INT 5
99571: PPUSH
99572: CALL_OW 12
99576: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99577: LD_ADDR_OWVAR 31
99581: PUSH
99582: LD_INT 1
99584: PPUSH
99585: LD_INT 3
99587: PPUSH
99588: CALL_OW 12
99592: PUSH
99593: LD_INT 1
99595: PPUSH
99596: LD_INT 3
99598: PPUSH
99599: CALL_OW 12
99603: PUSH
99604: LD_INT 0
99606: PUSH
99607: LD_INT 0
99609: PUSH
99610: EMPTY
99611: LIST
99612: LIST
99613: LIST
99614: LIST
99615: ST_TO_ADDR
// animal := CreateHuman ;
99616: LD_ADDR_VAR 0 12
99620: PUSH
99621: CALL_OW 44
99625: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99626: LD_VAR 0 12
99630: PPUSH
99631: LD_VAR 0 8
99635: PPUSH
99636: LD_INT 0
99638: PPUSH
99639: CALL 106061 0 3
// end ;
99643: GO 99541
99645: POP
99646: POP
// if enchidnas then
99647: LD_VAR 0 4
99651: IFFALSE 99718
// for i = 1 to enchidnas do
99653: LD_ADDR_VAR 0 11
99657: PUSH
99658: DOUBLE
99659: LD_INT 1
99661: DEC
99662: ST_TO_ADDR
99663: LD_VAR 0 4
99667: PUSH
99668: FOR_TO
99669: IFFALSE 99716
// begin hc_class = 13 ;
99671: LD_ADDR_OWVAR 28
99675: PUSH
99676: LD_INT 13
99678: ST_TO_ADDR
// hc_gallery =  ;
99679: LD_ADDR_OWVAR 33
99683: PUSH
99684: LD_STRING 
99686: ST_TO_ADDR
// animal := CreateHuman ;
99687: LD_ADDR_VAR 0 12
99691: PUSH
99692: CALL_OW 44
99696: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99697: LD_VAR 0 12
99701: PPUSH
99702: LD_VAR 0 8
99706: PPUSH
99707: LD_INT 0
99709: PPUSH
99710: CALL 106061 0 3
// end ;
99714: GO 99668
99716: POP
99717: POP
// if fishes then
99718: LD_VAR 0 7
99722: IFFALSE 99789
// for i = 1 to fishes do
99724: LD_ADDR_VAR 0 11
99728: PUSH
99729: DOUBLE
99730: LD_INT 1
99732: DEC
99733: ST_TO_ADDR
99734: LD_VAR 0 7
99738: PUSH
99739: FOR_TO
99740: IFFALSE 99787
// begin hc_class = 20 ;
99742: LD_ADDR_OWVAR 28
99746: PUSH
99747: LD_INT 20
99749: ST_TO_ADDR
// hc_gallery =  ;
99750: LD_ADDR_OWVAR 33
99754: PUSH
99755: LD_STRING 
99757: ST_TO_ADDR
// animal := CreateHuman ;
99758: LD_ADDR_VAR 0 12
99762: PUSH
99763: CALL_OW 44
99767: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99768: LD_VAR 0 12
99772: PPUSH
99773: LD_VAR 0 9
99777: PPUSH
99778: LD_INT 0
99780: PPUSH
99781: CALL 106061 0 3
// end ;
99785: GO 99739
99787: POP
99788: POP
// end ;
99789: LD_VAR 0 10
99793: RET
// export function WantHeal ( sci , unit ) ; begin
99794: LD_INT 0
99796: PPUSH
// if GetTaskList ( sci ) > 0 then
99797: LD_VAR 0 1
99801: PPUSH
99802: CALL_OW 437
99806: PUSH
99807: LD_INT 0
99809: GREATER
99810: IFFALSE 99880
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99812: LD_VAR 0 1
99816: PPUSH
99817: CALL_OW 437
99821: PUSH
99822: LD_INT 1
99824: ARRAY
99825: PUSH
99826: LD_INT 1
99828: ARRAY
99829: PUSH
99830: LD_STRING l
99832: EQUAL
99833: PUSH
99834: LD_VAR 0 1
99838: PPUSH
99839: CALL_OW 437
99843: PUSH
99844: LD_INT 1
99846: ARRAY
99847: PUSH
99848: LD_INT 4
99850: ARRAY
99851: PUSH
99852: LD_VAR 0 2
99856: EQUAL
99857: AND
99858: IFFALSE 99870
// result := true else
99860: LD_ADDR_VAR 0 3
99864: PUSH
99865: LD_INT 1
99867: ST_TO_ADDR
99868: GO 99878
// result := false ;
99870: LD_ADDR_VAR 0 3
99874: PUSH
99875: LD_INT 0
99877: ST_TO_ADDR
// end else
99878: GO 99888
// result := false ;
99880: LD_ADDR_VAR 0 3
99884: PUSH
99885: LD_INT 0
99887: ST_TO_ADDR
// end ;
99888: LD_VAR 0 3
99892: RET
// export function HealTarget ( sci ) ; begin
99893: LD_INT 0
99895: PPUSH
// if not sci then
99896: LD_VAR 0 1
99900: NOT
99901: IFFALSE 99905
// exit ;
99903: GO 99970
// result := 0 ;
99905: LD_ADDR_VAR 0 2
99909: PUSH
99910: LD_INT 0
99912: ST_TO_ADDR
// if GetTaskList ( sci ) then
99913: LD_VAR 0 1
99917: PPUSH
99918: CALL_OW 437
99922: IFFALSE 99970
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99924: LD_VAR 0 1
99928: PPUSH
99929: CALL_OW 437
99933: PUSH
99934: LD_INT 1
99936: ARRAY
99937: PUSH
99938: LD_INT 1
99940: ARRAY
99941: PUSH
99942: LD_STRING l
99944: EQUAL
99945: IFFALSE 99970
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99947: LD_ADDR_VAR 0 2
99951: PUSH
99952: LD_VAR 0 1
99956: PPUSH
99957: CALL_OW 437
99961: PUSH
99962: LD_INT 1
99964: ARRAY
99965: PUSH
99966: LD_INT 4
99968: ARRAY
99969: ST_TO_ADDR
// end ;
99970: LD_VAR 0 2
99974: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99975: LD_INT 0
99977: PPUSH
99978: PPUSH
99979: PPUSH
99980: PPUSH
99981: PPUSH
99982: PPUSH
99983: PPUSH
99984: PPUSH
99985: PPUSH
99986: PPUSH
99987: PPUSH
99988: PPUSH
99989: PPUSH
99990: PPUSH
99991: PPUSH
99992: PPUSH
99993: PPUSH
99994: PPUSH
99995: PPUSH
99996: PPUSH
99997: PPUSH
99998: PPUSH
99999: PPUSH
100000: PPUSH
100001: PPUSH
100002: PPUSH
100003: PPUSH
100004: PPUSH
100005: PPUSH
100006: PPUSH
100007: PPUSH
100008: PPUSH
100009: PPUSH
100010: PPUSH
// if not list then
100011: LD_VAR 0 1
100015: NOT
100016: IFFALSE 100020
// exit ;
100018: GO 104672
// base := list [ 1 ] ;
100020: LD_ADDR_VAR 0 3
100024: PUSH
100025: LD_VAR 0 1
100029: PUSH
100030: LD_INT 1
100032: ARRAY
100033: ST_TO_ADDR
// group := list [ 2 ] ;
100034: LD_ADDR_VAR 0 4
100038: PUSH
100039: LD_VAR 0 1
100043: PUSH
100044: LD_INT 2
100046: ARRAY
100047: ST_TO_ADDR
// path := list [ 3 ] ;
100048: LD_ADDR_VAR 0 5
100052: PUSH
100053: LD_VAR 0 1
100057: PUSH
100058: LD_INT 3
100060: ARRAY
100061: ST_TO_ADDR
// flags := list [ 4 ] ;
100062: LD_ADDR_VAR 0 6
100066: PUSH
100067: LD_VAR 0 1
100071: PUSH
100072: LD_INT 4
100074: ARRAY
100075: ST_TO_ADDR
// mined := [ ] ;
100076: LD_ADDR_VAR 0 27
100080: PUSH
100081: EMPTY
100082: ST_TO_ADDR
// bombed := [ ] ;
100083: LD_ADDR_VAR 0 28
100087: PUSH
100088: EMPTY
100089: ST_TO_ADDR
// healers := [ ] ;
100090: LD_ADDR_VAR 0 31
100094: PUSH
100095: EMPTY
100096: ST_TO_ADDR
// to_heal := [ ] ;
100097: LD_ADDR_VAR 0 30
100101: PUSH
100102: EMPTY
100103: ST_TO_ADDR
// repairs := [ ] ;
100104: LD_ADDR_VAR 0 33
100108: PUSH
100109: EMPTY
100110: ST_TO_ADDR
// to_repair := [ ] ;
100111: LD_ADDR_VAR 0 32
100115: PUSH
100116: EMPTY
100117: ST_TO_ADDR
// if not group or not path then
100118: LD_VAR 0 4
100122: NOT
100123: PUSH
100124: LD_VAR 0 5
100128: NOT
100129: OR
100130: IFFALSE 100134
// exit ;
100132: GO 104672
// side := GetSide ( group [ 1 ] ) ;
100134: LD_ADDR_VAR 0 35
100138: PUSH
100139: LD_VAR 0 4
100143: PUSH
100144: LD_INT 1
100146: ARRAY
100147: PPUSH
100148: CALL_OW 255
100152: ST_TO_ADDR
// if flags then
100153: LD_VAR 0 6
100157: IFFALSE 100301
// begin f_ignore_area := flags [ 1 ] ;
100159: LD_ADDR_VAR 0 17
100163: PUSH
100164: LD_VAR 0 6
100168: PUSH
100169: LD_INT 1
100171: ARRAY
100172: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100173: LD_ADDR_VAR 0 18
100177: PUSH
100178: LD_VAR 0 6
100182: PUSH
100183: LD_INT 2
100185: ARRAY
100186: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100187: LD_ADDR_VAR 0 19
100191: PUSH
100192: LD_VAR 0 6
100196: PUSH
100197: LD_INT 3
100199: ARRAY
100200: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100201: LD_ADDR_VAR 0 20
100205: PUSH
100206: LD_VAR 0 6
100210: PUSH
100211: LD_INT 4
100213: ARRAY
100214: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100215: LD_ADDR_VAR 0 21
100219: PUSH
100220: LD_VAR 0 6
100224: PUSH
100225: LD_INT 5
100227: ARRAY
100228: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100229: LD_ADDR_VAR 0 22
100233: PUSH
100234: LD_VAR 0 6
100238: PUSH
100239: LD_INT 6
100241: ARRAY
100242: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100243: LD_ADDR_VAR 0 23
100247: PUSH
100248: LD_VAR 0 6
100252: PUSH
100253: LD_INT 7
100255: ARRAY
100256: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100257: LD_ADDR_VAR 0 24
100261: PUSH
100262: LD_VAR 0 6
100266: PUSH
100267: LD_INT 8
100269: ARRAY
100270: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100271: LD_ADDR_VAR 0 25
100275: PUSH
100276: LD_VAR 0 6
100280: PUSH
100281: LD_INT 9
100283: ARRAY
100284: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100285: LD_ADDR_VAR 0 26
100289: PUSH
100290: LD_VAR 0 6
100294: PUSH
100295: LD_INT 10
100297: ARRAY
100298: ST_TO_ADDR
// end else
100299: GO 100381
// begin f_ignore_area := false ;
100301: LD_ADDR_VAR 0 17
100305: PUSH
100306: LD_INT 0
100308: ST_TO_ADDR
// f_capture := false ;
100309: LD_ADDR_VAR 0 18
100313: PUSH
100314: LD_INT 0
100316: ST_TO_ADDR
// f_ignore_civ := false ;
100317: LD_ADDR_VAR 0 19
100321: PUSH
100322: LD_INT 0
100324: ST_TO_ADDR
// f_murder := false ;
100325: LD_ADDR_VAR 0 20
100329: PUSH
100330: LD_INT 0
100332: ST_TO_ADDR
// f_mines := false ;
100333: LD_ADDR_VAR 0 21
100337: PUSH
100338: LD_INT 0
100340: ST_TO_ADDR
// f_repair := false ;
100341: LD_ADDR_VAR 0 22
100345: PUSH
100346: LD_INT 0
100348: ST_TO_ADDR
// f_heal := false ;
100349: LD_ADDR_VAR 0 23
100353: PUSH
100354: LD_INT 0
100356: ST_TO_ADDR
// f_spacetime := false ;
100357: LD_ADDR_VAR 0 24
100361: PUSH
100362: LD_INT 0
100364: ST_TO_ADDR
// f_attack_depot := false ;
100365: LD_ADDR_VAR 0 25
100369: PUSH
100370: LD_INT 0
100372: ST_TO_ADDR
// f_crawl := false ;
100373: LD_ADDR_VAR 0 26
100377: PUSH
100378: LD_INT 0
100380: ST_TO_ADDR
// end ; if f_heal then
100381: LD_VAR 0 23
100385: IFFALSE 100412
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100387: LD_ADDR_VAR 0 31
100391: PUSH
100392: LD_VAR 0 4
100396: PPUSH
100397: LD_INT 25
100399: PUSH
100400: LD_INT 4
100402: PUSH
100403: EMPTY
100404: LIST
100405: LIST
100406: PPUSH
100407: CALL_OW 72
100411: ST_TO_ADDR
// if f_repair then
100412: LD_VAR 0 22
100416: IFFALSE 100443
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100418: LD_ADDR_VAR 0 33
100422: PUSH
100423: LD_VAR 0 4
100427: PPUSH
100428: LD_INT 25
100430: PUSH
100431: LD_INT 3
100433: PUSH
100434: EMPTY
100435: LIST
100436: LIST
100437: PPUSH
100438: CALL_OW 72
100442: ST_TO_ADDR
// units_path := [ ] ;
100443: LD_ADDR_VAR 0 16
100447: PUSH
100448: EMPTY
100449: ST_TO_ADDR
// for i = 1 to group do
100450: LD_ADDR_VAR 0 7
100454: PUSH
100455: DOUBLE
100456: LD_INT 1
100458: DEC
100459: ST_TO_ADDR
100460: LD_VAR 0 4
100464: PUSH
100465: FOR_TO
100466: IFFALSE 100495
// units_path := Replace ( units_path , i , path ) ;
100468: LD_ADDR_VAR 0 16
100472: PUSH
100473: LD_VAR 0 16
100477: PPUSH
100478: LD_VAR 0 7
100482: PPUSH
100483: LD_VAR 0 5
100487: PPUSH
100488: CALL_OW 1
100492: ST_TO_ADDR
100493: GO 100465
100495: POP
100496: POP
// repeat for i = group downto 1 do
100497: LD_ADDR_VAR 0 7
100501: PUSH
100502: DOUBLE
100503: LD_VAR 0 4
100507: INC
100508: ST_TO_ADDR
100509: LD_INT 1
100511: PUSH
100512: FOR_DOWNTO
100513: IFFALSE 104635
// begin wait ( 5 ) ;
100515: LD_INT 5
100517: PPUSH
100518: CALL_OW 67
// tmp := [ ] ;
100522: LD_ADDR_VAR 0 14
100526: PUSH
100527: EMPTY
100528: ST_TO_ADDR
// attacking := false ;
100529: LD_ADDR_VAR 0 29
100533: PUSH
100534: LD_INT 0
100536: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100537: LD_VAR 0 4
100541: PUSH
100542: LD_VAR 0 7
100546: ARRAY
100547: PPUSH
100548: CALL_OW 301
100552: PUSH
100553: LD_VAR 0 4
100557: PUSH
100558: LD_VAR 0 7
100562: ARRAY
100563: NOT
100564: OR
100565: IFFALSE 100674
// begin if GetType ( group [ i ] ) = unit_human then
100567: LD_VAR 0 4
100571: PUSH
100572: LD_VAR 0 7
100576: ARRAY
100577: PPUSH
100578: CALL_OW 247
100582: PUSH
100583: LD_INT 1
100585: EQUAL
100586: IFFALSE 100632
// begin to_heal := to_heal diff group [ i ] ;
100588: LD_ADDR_VAR 0 30
100592: PUSH
100593: LD_VAR 0 30
100597: PUSH
100598: LD_VAR 0 4
100602: PUSH
100603: LD_VAR 0 7
100607: ARRAY
100608: DIFF
100609: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100610: LD_ADDR_VAR 0 31
100614: PUSH
100615: LD_VAR 0 31
100619: PUSH
100620: LD_VAR 0 4
100624: PUSH
100625: LD_VAR 0 7
100629: ARRAY
100630: DIFF
100631: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100632: LD_ADDR_VAR 0 4
100636: PUSH
100637: LD_VAR 0 4
100641: PPUSH
100642: LD_VAR 0 7
100646: PPUSH
100647: CALL_OW 3
100651: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100652: LD_ADDR_VAR 0 16
100656: PUSH
100657: LD_VAR 0 16
100661: PPUSH
100662: LD_VAR 0 7
100666: PPUSH
100667: CALL_OW 3
100671: ST_TO_ADDR
// continue ;
100672: GO 100512
// end ; if f_repair then
100674: LD_VAR 0 22
100678: IFFALSE 101167
// begin if GetType ( group [ i ] ) = unit_vehicle then
100680: LD_VAR 0 4
100684: PUSH
100685: LD_VAR 0 7
100689: ARRAY
100690: PPUSH
100691: CALL_OW 247
100695: PUSH
100696: LD_INT 2
100698: EQUAL
100699: IFFALSE 100889
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100701: LD_VAR 0 4
100705: PUSH
100706: LD_VAR 0 7
100710: ARRAY
100711: PPUSH
100712: CALL_OW 256
100716: PUSH
100717: LD_INT 700
100719: LESS
100720: PUSH
100721: LD_VAR 0 4
100725: PUSH
100726: LD_VAR 0 7
100730: ARRAY
100731: PUSH
100732: LD_VAR 0 32
100736: IN
100737: NOT
100738: AND
100739: IFFALSE 100763
// to_repair := to_repair union group [ i ] ;
100741: LD_ADDR_VAR 0 32
100745: PUSH
100746: LD_VAR 0 32
100750: PUSH
100751: LD_VAR 0 4
100755: PUSH
100756: LD_VAR 0 7
100760: ARRAY
100761: UNION
100762: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100763: LD_VAR 0 4
100767: PUSH
100768: LD_VAR 0 7
100772: ARRAY
100773: PPUSH
100774: CALL_OW 256
100778: PUSH
100779: LD_INT 1000
100781: EQUAL
100782: PUSH
100783: LD_VAR 0 4
100787: PUSH
100788: LD_VAR 0 7
100792: ARRAY
100793: PUSH
100794: LD_VAR 0 32
100798: IN
100799: AND
100800: IFFALSE 100824
// to_repair := to_repair diff group [ i ] ;
100802: LD_ADDR_VAR 0 32
100806: PUSH
100807: LD_VAR 0 32
100811: PUSH
100812: LD_VAR 0 4
100816: PUSH
100817: LD_VAR 0 7
100821: ARRAY
100822: DIFF
100823: ST_TO_ADDR
// if group [ i ] in to_repair then
100824: LD_VAR 0 4
100828: PUSH
100829: LD_VAR 0 7
100833: ARRAY
100834: PUSH
100835: LD_VAR 0 32
100839: IN
100840: IFFALSE 100887
// begin if not IsInArea ( group [ i ] , f_repair ) then
100842: LD_VAR 0 4
100846: PUSH
100847: LD_VAR 0 7
100851: ARRAY
100852: PPUSH
100853: LD_VAR 0 22
100857: PPUSH
100858: CALL_OW 308
100862: NOT
100863: IFFALSE 100885
// ComMoveToArea ( group [ i ] , f_repair ) ;
100865: LD_VAR 0 4
100869: PUSH
100870: LD_VAR 0 7
100874: ARRAY
100875: PPUSH
100876: LD_VAR 0 22
100880: PPUSH
100881: CALL_OW 113
// continue ;
100885: GO 100512
// end ; end else
100887: GO 101167
// if group [ i ] in repairs then
100889: LD_VAR 0 4
100893: PUSH
100894: LD_VAR 0 7
100898: ARRAY
100899: PUSH
100900: LD_VAR 0 33
100904: IN
100905: IFFALSE 101167
// begin if IsInUnit ( group [ i ] ) then
100907: LD_VAR 0 4
100911: PUSH
100912: LD_VAR 0 7
100916: ARRAY
100917: PPUSH
100918: CALL_OW 310
100922: IFFALSE 100990
// begin z := IsInUnit ( group [ i ] ) ;
100924: LD_ADDR_VAR 0 13
100928: PUSH
100929: LD_VAR 0 4
100933: PUSH
100934: LD_VAR 0 7
100938: ARRAY
100939: PPUSH
100940: CALL_OW 310
100944: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100945: LD_VAR 0 13
100949: PUSH
100950: LD_VAR 0 32
100954: IN
100955: PUSH
100956: LD_VAR 0 13
100960: PPUSH
100961: LD_VAR 0 22
100965: PPUSH
100966: CALL_OW 308
100970: AND
100971: IFFALSE 100988
// ComExitVehicle ( group [ i ] ) ;
100973: LD_VAR 0 4
100977: PUSH
100978: LD_VAR 0 7
100982: ARRAY
100983: PPUSH
100984: CALL_OW 121
// end else
100988: GO 101167
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100990: LD_ADDR_VAR 0 13
100994: PUSH
100995: LD_VAR 0 4
100999: PPUSH
101000: LD_INT 95
101002: PUSH
101003: LD_VAR 0 22
101007: PUSH
101008: EMPTY
101009: LIST
101010: LIST
101011: PUSH
101012: LD_INT 58
101014: PUSH
101015: EMPTY
101016: LIST
101017: PUSH
101018: EMPTY
101019: LIST
101020: LIST
101021: PPUSH
101022: CALL_OW 72
101026: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101027: LD_VAR 0 4
101031: PUSH
101032: LD_VAR 0 7
101036: ARRAY
101037: PPUSH
101038: CALL_OW 314
101042: NOT
101043: IFFALSE 101165
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101045: LD_ADDR_VAR 0 10
101049: PUSH
101050: LD_VAR 0 13
101054: PPUSH
101055: LD_VAR 0 4
101059: PUSH
101060: LD_VAR 0 7
101064: ARRAY
101065: PPUSH
101066: CALL_OW 74
101070: ST_TO_ADDR
// if not x then
101071: LD_VAR 0 10
101075: NOT
101076: IFFALSE 101080
// continue ;
101078: GO 100512
// if GetLives ( x ) < 1000 then
101080: LD_VAR 0 10
101084: PPUSH
101085: CALL_OW 256
101089: PUSH
101090: LD_INT 1000
101092: LESS
101093: IFFALSE 101117
// ComRepairVehicle ( group [ i ] , x ) else
101095: LD_VAR 0 4
101099: PUSH
101100: LD_VAR 0 7
101104: ARRAY
101105: PPUSH
101106: LD_VAR 0 10
101110: PPUSH
101111: CALL_OW 129
101115: GO 101165
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101117: LD_VAR 0 23
101121: PUSH
101122: LD_VAR 0 4
101126: PUSH
101127: LD_VAR 0 7
101131: ARRAY
101132: PPUSH
101133: CALL_OW 256
101137: PUSH
101138: LD_INT 1000
101140: LESS
101141: AND
101142: NOT
101143: IFFALSE 101165
// ComEnterUnit ( group [ i ] , x ) ;
101145: LD_VAR 0 4
101149: PUSH
101150: LD_VAR 0 7
101154: ARRAY
101155: PPUSH
101156: LD_VAR 0 10
101160: PPUSH
101161: CALL_OW 120
// end ; continue ;
101165: GO 100512
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101167: LD_VAR 0 23
101171: PUSH
101172: LD_VAR 0 4
101176: PUSH
101177: LD_VAR 0 7
101181: ARRAY
101182: PPUSH
101183: CALL_OW 247
101187: PUSH
101188: LD_INT 1
101190: EQUAL
101191: AND
101192: IFFALSE 101670
// begin if group [ i ] in healers then
101194: LD_VAR 0 4
101198: PUSH
101199: LD_VAR 0 7
101203: ARRAY
101204: PUSH
101205: LD_VAR 0 31
101209: IN
101210: IFFALSE 101483
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101212: LD_VAR 0 4
101216: PUSH
101217: LD_VAR 0 7
101221: ARRAY
101222: PPUSH
101223: LD_VAR 0 23
101227: PPUSH
101228: CALL_OW 308
101232: NOT
101233: PUSH
101234: LD_VAR 0 4
101238: PUSH
101239: LD_VAR 0 7
101243: ARRAY
101244: PPUSH
101245: CALL_OW 314
101249: NOT
101250: AND
101251: IFFALSE 101275
// ComMoveToArea ( group [ i ] , f_heal ) else
101253: LD_VAR 0 4
101257: PUSH
101258: LD_VAR 0 7
101262: ARRAY
101263: PPUSH
101264: LD_VAR 0 23
101268: PPUSH
101269: CALL_OW 113
101273: GO 101481
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101275: LD_VAR 0 4
101279: PUSH
101280: LD_VAR 0 7
101284: ARRAY
101285: PPUSH
101286: CALL 99893 0 1
101290: PPUSH
101291: CALL_OW 256
101295: PUSH
101296: LD_INT 1000
101298: EQUAL
101299: IFFALSE 101318
// ComStop ( group [ i ] ) else
101301: LD_VAR 0 4
101305: PUSH
101306: LD_VAR 0 7
101310: ARRAY
101311: PPUSH
101312: CALL_OW 141
101316: GO 101481
// if not HasTask ( group [ i ] ) and to_heal then
101318: LD_VAR 0 4
101322: PUSH
101323: LD_VAR 0 7
101327: ARRAY
101328: PPUSH
101329: CALL_OW 314
101333: NOT
101334: PUSH
101335: LD_VAR 0 30
101339: AND
101340: IFFALSE 101481
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101342: LD_ADDR_VAR 0 13
101346: PUSH
101347: LD_VAR 0 30
101351: PPUSH
101352: LD_INT 3
101354: PUSH
101355: LD_INT 54
101357: PUSH
101358: EMPTY
101359: LIST
101360: PUSH
101361: EMPTY
101362: LIST
101363: LIST
101364: PPUSH
101365: CALL_OW 72
101369: PPUSH
101370: LD_VAR 0 4
101374: PUSH
101375: LD_VAR 0 7
101379: ARRAY
101380: PPUSH
101381: CALL_OW 74
101385: ST_TO_ADDR
// if z then
101386: LD_VAR 0 13
101390: IFFALSE 101481
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101392: LD_INT 91
101394: PUSH
101395: LD_VAR 0 13
101399: PUSH
101400: LD_INT 10
101402: PUSH
101403: EMPTY
101404: LIST
101405: LIST
101406: LIST
101407: PUSH
101408: LD_INT 81
101410: PUSH
101411: LD_VAR 0 13
101415: PPUSH
101416: CALL_OW 255
101420: PUSH
101421: EMPTY
101422: LIST
101423: LIST
101424: PUSH
101425: EMPTY
101426: LIST
101427: LIST
101428: PPUSH
101429: CALL_OW 69
101433: PUSH
101434: LD_INT 0
101436: EQUAL
101437: IFFALSE 101461
// ComHeal ( group [ i ] , z ) else
101439: LD_VAR 0 4
101443: PUSH
101444: LD_VAR 0 7
101448: ARRAY
101449: PPUSH
101450: LD_VAR 0 13
101454: PPUSH
101455: CALL_OW 128
101459: GO 101481
// ComMoveToArea ( group [ i ] , f_heal ) ;
101461: LD_VAR 0 4
101465: PUSH
101466: LD_VAR 0 7
101470: ARRAY
101471: PPUSH
101472: LD_VAR 0 23
101476: PPUSH
101477: CALL_OW 113
// end ; continue ;
101481: GO 100512
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101483: LD_VAR 0 4
101487: PUSH
101488: LD_VAR 0 7
101492: ARRAY
101493: PPUSH
101494: CALL_OW 256
101498: PUSH
101499: LD_INT 700
101501: LESS
101502: PUSH
101503: LD_VAR 0 4
101507: PUSH
101508: LD_VAR 0 7
101512: ARRAY
101513: PUSH
101514: LD_VAR 0 30
101518: IN
101519: NOT
101520: AND
101521: IFFALSE 101545
// to_heal := to_heal union group [ i ] ;
101523: LD_ADDR_VAR 0 30
101527: PUSH
101528: LD_VAR 0 30
101532: PUSH
101533: LD_VAR 0 4
101537: PUSH
101538: LD_VAR 0 7
101542: ARRAY
101543: UNION
101544: ST_TO_ADDR
// if group [ i ] in to_heal then
101545: LD_VAR 0 4
101549: PUSH
101550: LD_VAR 0 7
101554: ARRAY
101555: PUSH
101556: LD_VAR 0 30
101560: IN
101561: IFFALSE 101670
// begin if GetLives ( group [ i ] ) = 1000 then
101563: LD_VAR 0 4
101567: PUSH
101568: LD_VAR 0 7
101572: ARRAY
101573: PPUSH
101574: CALL_OW 256
101578: PUSH
101579: LD_INT 1000
101581: EQUAL
101582: IFFALSE 101608
// to_heal := to_heal diff group [ i ] else
101584: LD_ADDR_VAR 0 30
101588: PUSH
101589: LD_VAR 0 30
101593: PUSH
101594: LD_VAR 0 4
101598: PUSH
101599: LD_VAR 0 7
101603: ARRAY
101604: DIFF
101605: ST_TO_ADDR
101606: GO 101670
// begin if not IsInArea ( group [ i ] , to_heal ) then
101608: LD_VAR 0 4
101612: PUSH
101613: LD_VAR 0 7
101617: ARRAY
101618: PPUSH
101619: LD_VAR 0 30
101623: PPUSH
101624: CALL_OW 308
101628: NOT
101629: IFFALSE 101653
// ComMoveToArea ( group [ i ] , f_heal ) else
101631: LD_VAR 0 4
101635: PUSH
101636: LD_VAR 0 7
101640: ARRAY
101641: PPUSH
101642: LD_VAR 0 23
101646: PPUSH
101647: CALL_OW 113
101651: GO 101668
// ComHold ( group [ i ] ) ;
101653: LD_VAR 0 4
101657: PUSH
101658: LD_VAR 0 7
101662: ARRAY
101663: PPUSH
101664: CALL_OW 140
// continue ;
101668: GO 100512
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101670: LD_VAR 0 4
101674: PUSH
101675: LD_VAR 0 7
101679: ARRAY
101680: PPUSH
101681: LD_INT 10
101683: PPUSH
101684: CALL 98290 0 2
101688: NOT
101689: PUSH
101690: LD_VAR 0 16
101694: PUSH
101695: LD_VAR 0 7
101699: ARRAY
101700: PUSH
101701: EMPTY
101702: EQUAL
101703: NOT
101704: AND
101705: IFFALSE 101971
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101707: LD_VAR 0 4
101711: PUSH
101712: LD_VAR 0 7
101716: ARRAY
101717: PPUSH
101718: CALL_OW 262
101722: PUSH
101723: LD_INT 1
101725: PUSH
101726: LD_INT 2
101728: PUSH
101729: EMPTY
101730: LIST
101731: LIST
101732: IN
101733: IFFALSE 101774
// if GetFuel ( group [ i ] ) < 10 then
101735: LD_VAR 0 4
101739: PUSH
101740: LD_VAR 0 7
101744: ARRAY
101745: PPUSH
101746: CALL_OW 261
101750: PUSH
101751: LD_INT 10
101753: LESS
101754: IFFALSE 101774
// SetFuel ( group [ i ] , 12 ) ;
101756: LD_VAR 0 4
101760: PUSH
101761: LD_VAR 0 7
101765: ARRAY
101766: PPUSH
101767: LD_INT 12
101769: PPUSH
101770: CALL_OW 240
// if units_path [ i ] then
101774: LD_VAR 0 16
101778: PUSH
101779: LD_VAR 0 7
101783: ARRAY
101784: IFFALSE 101969
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101786: LD_VAR 0 4
101790: PUSH
101791: LD_VAR 0 7
101795: ARRAY
101796: PPUSH
101797: LD_VAR 0 16
101801: PUSH
101802: LD_VAR 0 7
101806: ARRAY
101807: PUSH
101808: LD_INT 1
101810: ARRAY
101811: PUSH
101812: LD_INT 1
101814: ARRAY
101815: PPUSH
101816: LD_VAR 0 16
101820: PUSH
101821: LD_VAR 0 7
101825: ARRAY
101826: PUSH
101827: LD_INT 1
101829: ARRAY
101830: PUSH
101831: LD_INT 2
101833: ARRAY
101834: PPUSH
101835: CALL_OW 297
101839: PUSH
101840: LD_INT 6
101842: GREATER
101843: IFFALSE 101918
// begin if not HasTask ( group [ i ] ) then
101845: LD_VAR 0 4
101849: PUSH
101850: LD_VAR 0 7
101854: ARRAY
101855: PPUSH
101856: CALL_OW 314
101860: NOT
101861: IFFALSE 101916
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101863: LD_VAR 0 4
101867: PUSH
101868: LD_VAR 0 7
101872: ARRAY
101873: PPUSH
101874: LD_VAR 0 16
101878: PUSH
101879: LD_VAR 0 7
101883: ARRAY
101884: PUSH
101885: LD_INT 1
101887: ARRAY
101888: PUSH
101889: LD_INT 1
101891: ARRAY
101892: PPUSH
101893: LD_VAR 0 16
101897: PUSH
101898: LD_VAR 0 7
101902: ARRAY
101903: PUSH
101904: LD_INT 1
101906: ARRAY
101907: PUSH
101908: LD_INT 2
101910: ARRAY
101911: PPUSH
101912: CALL_OW 114
// end else
101916: GO 101969
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101918: LD_ADDR_VAR 0 15
101922: PUSH
101923: LD_VAR 0 16
101927: PUSH
101928: LD_VAR 0 7
101932: ARRAY
101933: PPUSH
101934: LD_INT 1
101936: PPUSH
101937: CALL_OW 3
101941: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101942: LD_ADDR_VAR 0 16
101946: PUSH
101947: LD_VAR 0 16
101951: PPUSH
101952: LD_VAR 0 7
101956: PPUSH
101957: LD_VAR 0 15
101961: PPUSH
101962: CALL_OW 1
101966: ST_TO_ADDR
// continue ;
101967: GO 100512
// end ; end ; end else
101969: GO 104633
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101971: LD_ADDR_VAR 0 14
101975: PUSH
101976: LD_INT 81
101978: PUSH
101979: LD_VAR 0 4
101983: PUSH
101984: LD_VAR 0 7
101988: ARRAY
101989: PPUSH
101990: CALL_OW 255
101994: PUSH
101995: EMPTY
101996: LIST
101997: LIST
101998: PPUSH
101999: CALL_OW 69
102003: ST_TO_ADDR
// if not tmp then
102004: LD_VAR 0 14
102008: NOT
102009: IFFALSE 102013
// continue ;
102011: GO 100512
// if f_ignore_area then
102013: LD_VAR 0 17
102017: IFFALSE 102105
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102019: LD_ADDR_VAR 0 15
102023: PUSH
102024: LD_VAR 0 14
102028: PPUSH
102029: LD_INT 3
102031: PUSH
102032: LD_INT 92
102034: PUSH
102035: LD_VAR 0 17
102039: PUSH
102040: LD_INT 1
102042: ARRAY
102043: PUSH
102044: LD_VAR 0 17
102048: PUSH
102049: LD_INT 2
102051: ARRAY
102052: PUSH
102053: LD_VAR 0 17
102057: PUSH
102058: LD_INT 3
102060: ARRAY
102061: PUSH
102062: EMPTY
102063: LIST
102064: LIST
102065: LIST
102066: LIST
102067: PUSH
102068: EMPTY
102069: LIST
102070: LIST
102071: PPUSH
102072: CALL_OW 72
102076: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102077: LD_VAR 0 14
102081: PUSH
102082: LD_VAR 0 15
102086: DIFF
102087: IFFALSE 102105
// tmp := tmp diff tmp2 ;
102089: LD_ADDR_VAR 0 14
102093: PUSH
102094: LD_VAR 0 14
102098: PUSH
102099: LD_VAR 0 15
102103: DIFF
102104: ST_TO_ADDR
// end ; if not f_murder then
102105: LD_VAR 0 20
102109: NOT
102110: IFFALSE 102168
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102112: LD_ADDR_VAR 0 15
102116: PUSH
102117: LD_VAR 0 14
102121: PPUSH
102122: LD_INT 3
102124: PUSH
102125: LD_INT 50
102127: PUSH
102128: EMPTY
102129: LIST
102130: PUSH
102131: EMPTY
102132: LIST
102133: LIST
102134: PPUSH
102135: CALL_OW 72
102139: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102140: LD_VAR 0 14
102144: PUSH
102145: LD_VAR 0 15
102149: DIFF
102150: IFFALSE 102168
// tmp := tmp diff tmp2 ;
102152: LD_ADDR_VAR 0 14
102156: PUSH
102157: LD_VAR 0 14
102161: PUSH
102162: LD_VAR 0 15
102166: DIFF
102167: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102168: LD_ADDR_VAR 0 14
102172: PUSH
102173: LD_VAR 0 4
102177: PUSH
102178: LD_VAR 0 7
102182: ARRAY
102183: PPUSH
102184: LD_VAR 0 14
102188: PPUSH
102189: LD_INT 1
102191: PPUSH
102192: LD_INT 1
102194: PPUSH
102195: CALL 71933 0 4
102199: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102200: LD_VAR 0 4
102204: PUSH
102205: LD_VAR 0 7
102209: ARRAY
102210: PPUSH
102211: CALL_OW 257
102215: PUSH
102216: LD_INT 1
102218: EQUAL
102219: IFFALSE 102667
// begin if WantPlant ( group [ i ] ) then
102221: LD_VAR 0 4
102225: PUSH
102226: LD_VAR 0 7
102230: ARRAY
102231: PPUSH
102232: CALL 71434 0 1
102236: IFFALSE 102240
// continue ;
102238: GO 100512
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102240: LD_VAR 0 18
102244: PUSH
102245: LD_VAR 0 4
102249: PUSH
102250: LD_VAR 0 7
102254: ARRAY
102255: PPUSH
102256: CALL_OW 310
102260: NOT
102261: AND
102262: PUSH
102263: LD_VAR 0 14
102267: PUSH
102268: LD_INT 1
102270: ARRAY
102271: PUSH
102272: LD_VAR 0 14
102276: PPUSH
102277: LD_INT 21
102279: PUSH
102280: LD_INT 2
102282: PUSH
102283: EMPTY
102284: LIST
102285: LIST
102286: PUSH
102287: LD_INT 58
102289: PUSH
102290: EMPTY
102291: LIST
102292: PUSH
102293: EMPTY
102294: LIST
102295: LIST
102296: PPUSH
102297: CALL_OW 72
102301: IN
102302: AND
102303: IFFALSE 102339
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102305: LD_VAR 0 4
102309: PUSH
102310: LD_VAR 0 7
102314: ARRAY
102315: PPUSH
102316: LD_VAR 0 14
102320: PUSH
102321: LD_INT 1
102323: ARRAY
102324: PPUSH
102325: CALL_OW 120
// attacking := true ;
102329: LD_ADDR_VAR 0 29
102333: PUSH
102334: LD_INT 1
102336: ST_TO_ADDR
// continue ;
102337: GO 100512
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102339: LD_VAR 0 26
102343: PUSH
102344: LD_VAR 0 4
102348: PUSH
102349: LD_VAR 0 7
102353: ARRAY
102354: PPUSH
102355: CALL_OW 257
102359: PUSH
102360: LD_INT 1
102362: EQUAL
102363: AND
102364: PUSH
102365: LD_VAR 0 4
102369: PUSH
102370: LD_VAR 0 7
102374: ARRAY
102375: PPUSH
102376: CALL_OW 256
102380: PUSH
102381: LD_INT 800
102383: LESS
102384: AND
102385: PUSH
102386: LD_VAR 0 4
102390: PUSH
102391: LD_VAR 0 7
102395: ARRAY
102396: PPUSH
102397: CALL_OW 318
102401: NOT
102402: AND
102403: IFFALSE 102420
// ComCrawl ( group [ i ] ) ;
102405: LD_VAR 0 4
102409: PUSH
102410: LD_VAR 0 7
102414: ARRAY
102415: PPUSH
102416: CALL_OW 137
// if f_mines then
102420: LD_VAR 0 21
102424: IFFALSE 102667
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102426: LD_VAR 0 14
102430: PUSH
102431: LD_INT 1
102433: ARRAY
102434: PPUSH
102435: CALL_OW 247
102439: PUSH
102440: LD_INT 3
102442: EQUAL
102443: PUSH
102444: LD_VAR 0 14
102448: PUSH
102449: LD_INT 1
102451: ARRAY
102452: PUSH
102453: LD_VAR 0 27
102457: IN
102458: NOT
102459: AND
102460: IFFALSE 102667
// begin x := GetX ( tmp [ 1 ] ) ;
102462: LD_ADDR_VAR 0 10
102466: PUSH
102467: LD_VAR 0 14
102471: PUSH
102472: LD_INT 1
102474: ARRAY
102475: PPUSH
102476: CALL_OW 250
102480: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102481: LD_ADDR_VAR 0 11
102485: PUSH
102486: LD_VAR 0 14
102490: PUSH
102491: LD_INT 1
102493: ARRAY
102494: PPUSH
102495: CALL_OW 251
102499: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102500: LD_ADDR_VAR 0 12
102504: PUSH
102505: LD_VAR 0 4
102509: PUSH
102510: LD_VAR 0 7
102514: ARRAY
102515: PPUSH
102516: CALL 98375 0 1
102520: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102521: LD_VAR 0 4
102525: PUSH
102526: LD_VAR 0 7
102530: ARRAY
102531: PPUSH
102532: LD_VAR 0 10
102536: PPUSH
102537: LD_VAR 0 11
102541: PPUSH
102542: LD_VAR 0 14
102546: PUSH
102547: LD_INT 1
102549: ARRAY
102550: PPUSH
102551: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102555: LD_VAR 0 4
102559: PUSH
102560: LD_VAR 0 7
102564: ARRAY
102565: PPUSH
102566: LD_VAR 0 10
102570: PPUSH
102571: LD_VAR 0 12
102575: PPUSH
102576: LD_INT 7
102578: PPUSH
102579: CALL_OW 272
102583: PPUSH
102584: LD_VAR 0 11
102588: PPUSH
102589: LD_VAR 0 12
102593: PPUSH
102594: LD_INT 7
102596: PPUSH
102597: CALL_OW 273
102601: PPUSH
102602: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102606: LD_VAR 0 4
102610: PUSH
102611: LD_VAR 0 7
102615: ARRAY
102616: PPUSH
102617: LD_INT 71
102619: PPUSH
102620: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102624: LD_ADDR_VAR 0 27
102628: PUSH
102629: LD_VAR 0 27
102633: PPUSH
102634: LD_VAR 0 27
102638: PUSH
102639: LD_INT 1
102641: PLUS
102642: PPUSH
102643: LD_VAR 0 14
102647: PUSH
102648: LD_INT 1
102650: ARRAY
102651: PPUSH
102652: CALL_OW 1
102656: ST_TO_ADDR
// attacking := true ;
102657: LD_ADDR_VAR 0 29
102661: PUSH
102662: LD_INT 1
102664: ST_TO_ADDR
// continue ;
102665: GO 100512
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102667: LD_VAR 0 4
102671: PUSH
102672: LD_VAR 0 7
102676: ARRAY
102677: PPUSH
102678: CALL_OW 257
102682: PUSH
102683: LD_INT 17
102685: EQUAL
102686: PUSH
102687: LD_VAR 0 4
102691: PUSH
102692: LD_VAR 0 7
102696: ARRAY
102697: PPUSH
102698: CALL_OW 110
102702: PUSH
102703: LD_INT 71
102705: EQUAL
102706: NOT
102707: AND
102708: IFFALSE 102854
// begin attacking := false ;
102710: LD_ADDR_VAR 0 29
102714: PUSH
102715: LD_INT 0
102717: ST_TO_ADDR
// k := 5 ;
102718: LD_ADDR_VAR 0 9
102722: PUSH
102723: LD_INT 5
102725: ST_TO_ADDR
// if tmp < k then
102726: LD_VAR 0 14
102730: PUSH
102731: LD_VAR 0 9
102735: LESS
102736: IFFALSE 102748
// k := tmp ;
102738: LD_ADDR_VAR 0 9
102742: PUSH
102743: LD_VAR 0 14
102747: ST_TO_ADDR
// for j = 1 to k do
102748: LD_ADDR_VAR 0 8
102752: PUSH
102753: DOUBLE
102754: LD_INT 1
102756: DEC
102757: ST_TO_ADDR
102758: LD_VAR 0 9
102762: PUSH
102763: FOR_TO
102764: IFFALSE 102852
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102766: LD_VAR 0 14
102770: PUSH
102771: LD_VAR 0 8
102775: ARRAY
102776: PUSH
102777: LD_VAR 0 14
102781: PPUSH
102782: LD_INT 58
102784: PUSH
102785: EMPTY
102786: LIST
102787: PPUSH
102788: CALL_OW 72
102792: IN
102793: NOT
102794: IFFALSE 102850
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102796: LD_VAR 0 4
102800: PUSH
102801: LD_VAR 0 7
102805: ARRAY
102806: PPUSH
102807: LD_VAR 0 14
102811: PUSH
102812: LD_VAR 0 8
102816: ARRAY
102817: PPUSH
102818: CALL_OW 115
// attacking := true ;
102822: LD_ADDR_VAR 0 29
102826: PUSH
102827: LD_INT 1
102829: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102830: LD_VAR 0 4
102834: PUSH
102835: LD_VAR 0 7
102839: ARRAY
102840: PPUSH
102841: LD_INT 71
102843: PPUSH
102844: CALL_OW 109
// continue ;
102848: GO 102763
// end ; end ;
102850: GO 102763
102852: POP
102853: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102854: LD_VAR 0 4
102858: PUSH
102859: LD_VAR 0 7
102863: ARRAY
102864: PPUSH
102865: CALL_OW 257
102869: PUSH
102870: LD_INT 8
102872: EQUAL
102873: PUSH
102874: LD_VAR 0 4
102878: PUSH
102879: LD_VAR 0 7
102883: ARRAY
102884: PPUSH
102885: CALL_OW 264
102889: PUSH
102890: LD_INT 28
102892: PUSH
102893: LD_INT 45
102895: PUSH
102896: LD_INT 7
102898: PUSH
102899: LD_INT 47
102901: PUSH
102902: EMPTY
102903: LIST
102904: LIST
102905: LIST
102906: LIST
102907: IN
102908: OR
102909: IFFALSE 103165
// begin attacking := false ;
102911: LD_ADDR_VAR 0 29
102915: PUSH
102916: LD_INT 0
102918: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102919: LD_VAR 0 14
102923: PUSH
102924: LD_INT 1
102926: ARRAY
102927: PPUSH
102928: CALL_OW 266
102932: PUSH
102933: LD_INT 32
102935: PUSH
102936: LD_INT 31
102938: PUSH
102939: LD_INT 33
102941: PUSH
102942: LD_INT 4
102944: PUSH
102945: LD_INT 5
102947: PUSH
102948: EMPTY
102949: LIST
102950: LIST
102951: LIST
102952: LIST
102953: LIST
102954: IN
102955: IFFALSE 103141
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102957: LD_ADDR_VAR 0 9
102961: PUSH
102962: LD_VAR 0 14
102966: PUSH
102967: LD_INT 1
102969: ARRAY
102970: PPUSH
102971: CALL_OW 266
102975: PPUSH
102976: LD_VAR 0 14
102980: PUSH
102981: LD_INT 1
102983: ARRAY
102984: PPUSH
102985: CALL_OW 250
102989: PPUSH
102990: LD_VAR 0 14
102994: PUSH
102995: LD_INT 1
102997: ARRAY
102998: PPUSH
102999: CALL_OW 251
103003: PPUSH
103004: LD_VAR 0 14
103008: PUSH
103009: LD_INT 1
103011: ARRAY
103012: PPUSH
103013: CALL_OW 254
103017: PPUSH
103018: LD_VAR 0 14
103022: PUSH
103023: LD_INT 1
103025: ARRAY
103026: PPUSH
103027: CALL_OW 248
103031: PPUSH
103032: LD_INT 0
103034: PPUSH
103035: CALL 79745 0 6
103039: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103040: LD_ADDR_VAR 0 8
103044: PUSH
103045: LD_VAR 0 4
103049: PUSH
103050: LD_VAR 0 7
103054: ARRAY
103055: PPUSH
103056: LD_VAR 0 9
103060: PPUSH
103061: CALL 98438 0 2
103065: ST_TO_ADDR
// if j then
103066: LD_VAR 0 8
103070: IFFALSE 103139
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103072: LD_VAR 0 8
103076: PUSH
103077: LD_INT 1
103079: ARRAY
103080: PPUSH
103081: LD_VAR 0 8
103085: PUSH
103086: LD_INT 2
103088: ARRAY
103089: PPUSH
103090: CALL_OW 488
103094: IFFALSE 103139
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103096: LD_VAR 0 4
103100: PUSH
103101: LD_VAR 0 7
103105: ARRAY
103106: PPUSH
103107: LD_VAR 0 8
103111: PUSH
103112: LD_INT 1
103114: ARRAY
103115: PPUSH
103116: LD_VAR 0 8
103120: PUSH
103121: LD_INT 2
103123: ARRAY
103124: PPUSH
103125: CALL_OW 116
// attacking := true ;
103129: LD_ADDR_VAR 0 29
103133: PUSH
103134: LD_INT 1
103136: ST_TO_ADDR
// continue ;
103137: GO 100512
// end ; end else
103139: GO 103165
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103141: LD_VAR 0 4
103145: PUSH
103146: LD_VAR 0 7
103150: ARRAY
103151: PPUSH
103152: LD_VAR 0 14
103156: PUSH
103157: LD_INT 1
103159: ARRAY
103160: PPUSH
103161: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103165: LD_VAR 0 4
103169: PUSH
103170: LD_VAR 0 7
103174: ARRAY
103175: PPUSH
103176: CALL_OW 265
103180: PUSH
103181: LD_INT 11
103183: EQUAL
103184: IFFALSE 103462
// begin k := 10 ;
103186: LD_ADDR_VAR 0 9
103190: PUSH
103191: LD_INT 10
103193: ST_TO_ADDR
// x := 0 ;
103194: LD_ADDR_VAR 0 10
103198: PUSH
103199: LD_INT 0
103201: ST_TO_ADDR
// if tmp < k then
103202: LD_VAR 0 14
103206: PUSH
103207: LD_VAR 0 9
103211: LESS
103212: IFFALSE 103224
// k := tmp ;
103214: LD_ADDR_VAR 0 9
103218: PUSH
103219: LD_VAR 0 14
103223: ST_TO_ADDR
// for j = k downto 1 do
103224: LD_ADDR_VAR 0 8
103228: PUSH
103229: DOUBLE
103230: LD_VAR 0 9
103234: INC
103235: ST_TO_ADDR
103236: LD_INT 1
103238: PUSH
103239: FOR_DOWNTO
103240: IFFALSE 103315
// begin if GetType ( tmp [ j ] ) = unit_human then
103242: LD_VAR 0 14
103246: PUSH
103247: LD_VAR 0 8
103251: ARRAY
103252: PPUSH
103253: CALL_OW 247
103257: PUSH
103258: LD_INT 1
103260: EQUAL
103261: IFFALSE 103313
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103263: LD_VAR 0 4
103267: PUSH
103268: LD_VAR 0 7
103272: ARRAY
103273: PPUSH
103274: LD_VAR 0 14
103278: PUSH
103279: LD_VAR 0 8
103283: ARRAY
103284: PPUSH
103285: CALL 98709 0 2
// x := tmp [ j ] ;
103289: LD_ADDR_VAR 0 10
103293: PUSH
103294: LD_VAR 0 14
103298: PUSH
103299: LD_VAR 0 8
103303: ARRAY
103304: ST_TO_ADDR
// attacking := true ;
103305: LD_ADDR_VAR 0 29
103309: PUSH
103310: LD_INT 1
103312: ST_TO_ADDR
// end ; end ;
103313: GO 103239
103315: POP
103316: POP
// if not x then
103317: LD_VAR 0 10
103321: NOT
103322: IFFALSE 103462
// begin attacking := true ;
103324: LD_ADDR_VAR 0 29
103328: PUSH
103329: LD_INT 1
103331: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103332: LD_VAR 0 4
103336: PUSH
103337: LD_VAR 0 7
103341: ARRAY
103342: PPUSH
103343: CALL_OW 250
103347: PPUSH
103348: LD_VAR 0 4
103352: PUSH
103353: LD_VAR 0 7
103357: ARRAY
103358: PPUSH
103359: CALL_OW 251
103363: PPUSH
103364: CALL_OW 546
103368: PUSH
103369: LD_INT 2
103371: ARRAY
103372: PUSH
103373: LD_VAR 0 14
103377: PUSH
103378: LD_INT 1
103380: ARRAY
103381: PPUSH
103382: CALL_OW 250
103386: PPUSH
103387: LD_VAR 0 14
103391: PUSH
103392: LD_INT 1
103394: ARRAY
103395: PPUSH
103396: CALL_OW 251
103400: PPUSH
103401: CALL_OW 546
103405: PUSH
103406: LD_INT 2
103408: ARRAY
103409: EQUAL
103410: IFFALSE 103438
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103412: LD_VAR 0 4
103416: PUSH
103417: LD_VAR 0 7
103421: ARRAY
103422: PPUSH
103423: LD_VAR 0 14
103427: PUSH
103428: LD_INT 1
103430: ARRAY
103431: PPUSH
103432: CALL 98709 0 2
103436: GO 103462
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103438: LD_VAR 0 4
103442: PUSH
103443: LD_VAR 0 7
103447: ARRAY
103448: PPUSH
103449: LD_VAR 0 14
103453: PUSH
103454: LD_INT 1
103456: ARRAY
103457: PPUSH
103458: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103462: LD_VAR 0 4
103466: PUSH
103467: LD_VAR 0 7
103471: ARRAY
103472: PPUSH
103473: CALL_OW 264
103477: PUSH
103478: LD_INT 29
103480: EQUAL
103481: IFFALSE 103847
// begin if WantsToAttack ( group [ i ] ) in bombed then
103483: LD_VAR 0 4
103487: PUSH
103488: LD_VAR 0 7
103492: ARRAY
103493: PPUSH
103494: CALL_OW 319
103498: PUSH
103499: LD_VAR 0 28
103503: IN
103504: IFFALSE 103508
// continue ;
103506: GO 100512
// k := 8 ;
103508: LD_ADDR_VAR 0 9
103512: PUSH
103513: LD_INT 8
103515: ST_TO_ADDR
// x := 0 ;
103516: LD_ADDR_VAR 0 10
103520: PUSH
103521: LD_INT 0
103523: ST_TO_ADDR
// if tmp < k then
103524: LD_VAR 0 14
103528: PUSH
103529: LD_VAR 0 9
103533: LESS
103534: IFFALSE 103546
// k := tmp ;
103536: LD_ADDR_VAR 0 9
103540: PUSH
103541: LD_VAR 0 14
103545: ST_TO_ADDR
// for j = 1 to k do
103546: LD_ADDR_VAR 0 8
103550: PUSH
103551: DOUBLE
103552: LD_INT 1
103554: DEC
103555: ST_TO_ADDR
103556: LD_VAR 0 9
103560: PUSH
103561: FOR_TO
103562: IFFALSE 103694
// begin if GetType ( tmp [ j ] ) = unit_building then
103564: LD_VAR 0 14
103568: PUSH
103569: LD_VAR 0 8
103573: ARRAY
103574: PPUSH
103575: CALL_OW 247
103579: PUSH
103580: LD_INT 3
103582: EQUAL
103583: IFFALSE 103692
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103585: LD_VAR 0 14
103589: PUSH
103590: LD_VAR 0 8
103594: ARRAY
103595: PUSH
103596: LD_VAR 0 28
103600: IN
103601: NOT
103602: PUSH
103603: LD_VAR 0 14
103607: PUSH
103608: LD_VAR 0 8
103612: ARRAY
103613: PPUSH
103614: CALL_OW 313
103618: AND
103619: IFFALSE 103692
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103621: LD_VAR 0 4
103625: PUSH
103626: LD_VAR 0 7
103630: ARRAY
103631: PPUSH
103632: LD_VAR 0 14
103636: PUSH
103637: LD_VAR 0 8
103641: ARRAY
103642: PPUSH
103643: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103647: LD_ADDR_VAR 0 28
103651: PUSH
103652: LD_VAR 0 28
103656: PPUSH
103657: LD_VAR 0 28
103661: PUSH
103662: LD_INT 1
103664: PLUS
103665: PPUSH
103666: LD_VAR 0 14
103670: PUSH
103671: LD_VAR 0 8
103675: ARRAY
103676: PPUSH
103677: CALL_OW 1
103681: ST_TO_ADDR
// attacking := true ;
103682: LD_ADDR_VAR 0 29
103686: PUSH
103687: LD_INT 1
103689: ST_TO_ADDR
// break ;
103690: GO 103694
// end ; end ;
103692: GO 103561
103694: POP
103695: POP
// if not attacking and f_attack_depot then
103696: LD_VAR 0 29
103700: NOT
103701: PUSH
103702: LD_VAR 0 25
103706: AND
103707: IFFALSE 103802
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103709: LD_ADDR_VAR 0 13
103713: PUSH
103714: LD_VAR 0 14
103718: PPUSH
103719: LD_INT 2
103721: PUSH
103722: LD_INT 30
103724: PUSH
103725: LD_INT 0
103727: PUSH
103728: EMPTY
103729: LIST
103730: LIST
103731: PUSH
103732: LD_INT 30
103734: PUSH
103735: LD_INT 1
103737: PUSH
103738: EMPTY
103739: LIST
103740: LIST
103741: PUSH
103742: EMPTY
103743: LIST
103744: LIST
103745: LIST
103746: PPUSH
103747: CALL_OW 72
103751: ST_TO_ADDR
// if z then
103752: LD_VAR 0 13
103756: IFFALSE 103802
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103758: LD_VAR 0 4
103762: PUSH
103763: LD_VAR 0 7
103767: ARRAY
103768: PPUSH
103769: LD_VAR 0 13
103773: PPUSH
103774: LD_VAR 0 4
103778: PUSH
103779: LD_VAR 0 7
103783: ARRAY
103784: PPUSH
103785: CALL_OW 74
103789: PPUSH
103790: CALL_OW 115
// attacking := true ;
103794: LD_ADDR_VAR 0 29
103798: PUSH
103799: LD_INT 1
103801: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103802: LD_VAR 0 4
103806: PUSH
103807: LD_VAR 0 7
103811: ARRAY
103812: PPUSH
103813: CALL_OW 256
103817: PUSH
103818: LD_INT 500
103820: LESS
103821: IFFALSE 103847
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103823: LD_VAR 0 4
103827: PUSH
103828: LD_VAR 0 7
103832: ARRAY
103833: PPUSH
103834: LD_VAR 0 14
103838: PUSH
103839: LD_INT 1
103841: ARRAY
103842: PPUSH
103843: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103847: LD_VAR 0 4
103851: PUSH
103852: LD_VAR 0 7
103856: ARRAY
103857: PPUSH
103858: CALL_OW 264
103862: PUSH
103863: LD_INT 49
103865: EQUAL
103866: IFFALSE 103987
// begin if not HasTask ( group [ i ] ) then
103868: LD_VAR 0 4
103872: PUSH
103873: LD_VAR 0 7
103877: ARRAY
103878: PPUSH
103879: CALL_OW 314
103883: NOT
103884: IFFALSE 103987
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103886: LD_ADDR_VAR 0 9
103890: PUSH
103891: LD_INT 81
103893: PUSH
103894: LD_VAR 0 4
103898: PUSH
103899: LD_VAR 0 7
103903: ARRAY
103904: PPUSH
103905: CALL_OW 255
103909: PUSH
103910: EMPTY
103911: LIST
103912: LIST
103913: PPUSH
103914: CALL_OW 69
103918: PPUSH
103919: LD_VAR 0 4
103923: PUSH
103924: LD_VAR 0 7
103928: ARRAY
103929: PPUSH
103930: CALL_OW 74
103934: ST_TO_ADDR
// if k then
103935: LD_VAR 0 9
103939: IFFALSE 103987
// if GetDistUnits ( group [ i ] , k ) > 10 then
103941: LD_VAR 0 4
103945: PUSH
103946: LD_VAR 0 7
103950: ARRAY
103951: PPUSH
103952: LD_VAR 0 9
103956: PPUSH
103957: CALL_OW 296
103961: PUSH
103962: LD_INT 10
103964: GREATER
103965: IFFALSE 103987
// ComMoveUnit ( group [ i ] , k ) ;
103967: LD_VAR 0 4
103971: PUSH
103972: LD_VAR 0 7
103976: ARRAY
103977: PPUSH
103978: LD_VAR 0 9
103982: PPUSH
103983: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103987: LD_VAR 0 4
103991: PUSH
103992: LD_VAR 0 7
103996: ARRAY
103997: PPUSH
103998: CALL_OW 256
104002: PUSH
104003: LD_INT 250
104005: LESS
104006: PUSH
104007: LD_VAR 0 4
104011: PUSH
104012: LD_VAR 0 7
104016: ARRAY
104017: PUSH
104018: LD_INT 21
104020: PUSH
104021: LD_INT 2
104023: PUSH
104024: EMPTY
104025: LIST
104026: LIST
104027: PUSH
104028: LD_INT 23
104030: PUSH
104031: LD_INT 2
104033: PUSH
104034: EMPTY
104035: LIST
104036: LIST
104037: PUSH
104038: EMPTY
104039: LIST
104040: LIST
104041: PPUSH
104042: CALL_OW 69
104046: IN
104047: AND
104048: IFFALSE 104173
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104050: LD_ADDR_VAR 0 9
104054: PUSH
104055: LD_OWVAR 3
104059: PUSH
104060: LD_VAR 0 4
104064: PUSH
104065: LD_VAR 0 7
104069: ARRAY
104070: DIFF
104071: PPUSH
104072: LD_VAR 0 4
104076: PUSH
104077: LD_VAR 0 7
104081: ARRAY
104082: PPUSH
104083: CALL_OW 74
104087: ST_TO_ADDR
// if not k then
104088: LD_VAR 0 9
104092: NOT
104093: IFFALSE 104097
// continue ;
104095: GO 100512
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104097: LD_VAR 0 9
104101: PUSH
104102: LD_INT 81
104104: PUSH
104105: LD_VAR 0 4
104109: PUSH
104110: LD_VAR 0 7
104114: ARRAY
104115: PPUSH
104116: CALL_OW 255
104120: PUSH
104121: EMPTY
104122: LIST
104123: LIST
104124: PPUSH
104125: CALL_OW 69
104129: IN
104130: PUSH
104131: LD_VAR 0 9
104135: PPUSH
104136: LD_VAR 0 4
104140: PUSH
104141: LD_VAR 0 7
104145: ARRAY
104146: PPUSH
104147: CALL_OW 296
104151: PUSH
104152: LD_INT 5
104154: LESS
104155: AND
104156: IFFALSE 104173
// ComAutodestruct ( group [ i ] ) ;
104158: LD_VAR 0 4
104162: PUSH
104163: LD_VAR 0 7
104167: ARRAY
104168: PPUSH
104169: CALL 98607 0 1
// end ; if f_attack_depot then
104173: LD_VAR 0 25
104177: IFFALSE 104289
// begin k := 6 ;
104179: LD_ADDR_VAR 0 9
104183: PUSH
104184: LD_INT 6
104186: ST_TO_ADDR
// if tmp < k then
104187: LD_VAR 0 14
104191: PUSH
104192: LD_VAR 0 9
104196: LESS
104197: IFFALSE 104209
// k := tmp ;
104199: LD_ADDR_VAR 0 9
104203: PUSH
104204: LD_VAR 0 14
104208: ST_TO_ADDR
// for j = 1 to k do
104209: LD_ADDR_VAR 0 8
104213: PUSH
104214: DOUBLE
104215: LD_INT 1
104217: DEC
104218: ST_TO_ADDR
104219: LD_VAR 0 9
104223: PUSH
104224: FOR_TO
104225: IFFALSE 104287
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104227: LD_VAR 0 8
104231: PPUSH
104232: CALL_OW 266
104236: PUSH
104237: LD_INT 0
104239: PUSH
104240: LD_INT 1
104242: PUSH
104243: EMPTY
104244: LIST
104245: LIST
104246: IN
104247: IFFALSE 104285
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104249: LD_VAR 0 4
104253: PUSH
104254: LD_VAR 0 7
104258: ARRAY
104259: PPUSH
104260: LD_VAR 0 14
104264: PUSH
104265: LD_VAR 0 8
104269: ARRAY
104270: PPUSH
104271: CALL_OW 115
// attacking := true ;
104275: LD_ADDR_VAR 0 29
104279: PUSH
104280: LD_INT 1
104282: ST_TO_ADDR
// break ;
104283: GO 104287
// end ;
104285: GO 104224
104287: POP
104288: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104289: LD_VAR 0 4
104293: PUSH
104294: LD_VAR 0 7
104298: ARRAY
104299: PPUSH
104300: CALL_OW 302
104304: PUSH
104305: LD_VAR 0 29
104309: NOT
104310: AND
104311: IFFALSE 104633
// begin if GetTag ( group [ i ] ) = 71 then
104313: LD_VAR 0 4
104317: PUSH
104318: LD_VAR 0 7
104322: ARRAY
104323: PPUSH
104324: CALL_OW 110
104328: PUSH
104329: LD_INT 71
104331: EQUAL
104332: IFFALSE 104373
// begin if HasTask ( group [ i ] ) then
104334: LD_VAR 0 4
104338: PUSH
104339: LD_VAR 0 7
104343: ARRAY
104344: PPUSH
104345: CALL_OW 314
104349: IFFALSE 104355
// continue else
104351: GO 100512
104353: GO 104373
// SetTag ( group [ i ] , 0 ) ;
104355: LD_VAR 0 4
104359: PUSH
104360: LD_VAR 0 7
104364: ARRAY
104365: PPUSH
104366: LD_INT 0
104368: PPUSH
104369: CALL_OW 109
// end ; k := 8 ;
104373: LD_ADDR_VAR 0 9
104377: PUSH
104378: LD_INT 8
104380: ST_TO_ADDR
// x := 0 ;
104381: LD_ADDR_VAR 0 10
104385: PUSH
104386: LD_INT 0
104388: ST_TO_ADDR
// if tmp < k then
104389: LD_VAR 0 14
104393: PUSH
104394: LD_VAR 0 9
104398: LESS
104399: IFFALSE 104411
// k := tmp ;
104401: LD_ADDR_VAR 0 9
104405: PUSH
104406: LD_VAR 0 14
104410: ST_TO_ADDR
// for j = 1 to k do
104411: LD_ADDR_VAR 0 8
104415: PUSH
104416: DOUBLE
104417: LD_INT 1
104419: DEC
104420: ST_TO_ADDR
104421: LD_VAR 0 9
104425: PUSH
104426: FOR_TO
104427: IFFALSE 104525
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104429: LD_VAR 0 14
104433: PUSH
104434: LD_VAR 0 8
104438: ARRAY
104439: PPUSH
104440: CALL_OW 247
104444: PUSH
104445: LD_INT 1
104447: EQUAL
104448: PUSH
104449: LD_VAR 0 14
104453: PUSH
104454: LD_VAR 0 8
104458: ARRAY
104459: PPUSH
104460: CALL_OW 256
104464: PUSH
104465: LD_INT 250
104467: LESS
104468: PUSH
104469: LD_VAR 0 20
104473: AND
104474: PUSH
104475: LD_VAR 0 20
104479: NOT
104480: PUSH
104481: LD_VAR 0 14
104485: PUSH
104486: LD_VAR 0 8
104490: ARRAY
104491: PPUSH
104492: CALL_OW 256
104496: PUSH
104497: LD_INT 250
104499: GREATEREQUAL
104500: AND
104501: OR
104502: AND
104503: IFFALSE 104523
// begin x := tmp [ j ] ;
104505: LD_ADDR_VAR 0 10
104509: PUSH
104510: LD_VAR 0 14
104514: PUSH
104515: LD_VAR 0 8
104519: ARRAY
104520: ST_TO_ADDR
// break ;
104521: GO 104525
// end ;
104523: GO 104426
104525: POP
104526: POP
// if x then
104527: LD_VAR 0 10
104531: IFFALSE 104555
// ComAttackUnit ( group [ i ] , x ) else
104533: LD_VAR 0 4
104537: PUSH
104538: LD_VAR 0 7
104542: ARRAY
104543: PPUSH
104544: LD_VAR 0 10
104548: PPUSH
104549: CALL_OW 115
104553: GO 104579
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104555: LD_VAR 0 4
104559: PUSH
104560: LD_VAR 0 7
104564: ARRAY
104565: PPUSH
104566: LD_VAR 0 14
104570: PUSH
104571: LD_INT 1
104573: ARRAY
104574: PPUSH
104575: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104579: LD_VAR 0 4
104583: PUSH
104584: LD_VAR 0 7
104588: ARRAY
104589: PPUSH
104590: CALL_OW 314
104594: NOT
104595: IFFALSE 104633
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104597: LD_VAR 0 4
104601: PUSH
104602: LD_VAR 0 7
104606: ARRAY
104607: PPUSH
104608: LD_VAR 0 14
104612: PPUSH
104613: LD_VAR 0 4
104617: PUSH
104618: LD_VAR 0 7
104622: ARRAY
104623: PPUSH
104624: CALL_OW 74
104628: PPUSH
104629: CALL_OW 115
// end ; end ; end ;
104633: GO 100512
104635: POP
104636: POP
// wait ( 0 0$1 ) ;
104637: LD_INT 35
104639: PPUSH
104640: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104644: LD_VAR 0 4
104648: PUSH
104649: EMPTY
104650: EQUAL
104651: PUSH
104652: LD_INT 81
104654: PUSH
104655: LD_VAR 0 35
104659: PUSH
104660: EMPTY
104661: LIST
104662: LIST
104663: PPUSH
104664: CALL_OW 69
104668: NOT
104669: OR
104670: IFFALSE 100497
// end ;
104672: LD_VAR 0 2
104676: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104677: LD_INT 0
104679: PPUSH
104680: PPUSH
104681: PPUSH
104682: PPUSH
// if not base_units then
104683: LD_VAR 0 1
104687: NOT
104688: IFFALSE 104692
// exit ;
104690: GO 104779
// result := false ;
104692: LD_ADDR_VAR 0 2
104696: PUSH
104697: LD_INT 0
104699: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104700: LD_ADDR_VAR 0 5
104704: PUSH
104705: LD_VAR 0 1
104709: PPUSH
104710: LD_INT 21
104712: PUSH
104713: LD_INT 3
104715: PUSH
104716: EMPTY
104717: LIST
104718: LIST
104719: PPUSH
104720: CALL_OW 72
104724: ST_TO_ADDR
// if not tmp then
104725: LD_VAR 0 5
104729: NOT
104730: IFFALSE 104734
// exit ;
104732: GO 104779
// for i in tmp do
104734: LD_ADDR_VAR 0 3
104738: PUSH
104739: LD_VAR 0 5
104743: PUSH
104744: FOR_IN
104745: IFFALSE 104777
// begin result := EnemyInRange ( i , 22 ) ;
104747: LD_ADDR_VAR 0 2
104751: PUSH
104752: LD_VAR 0 3
104756: PPUSH
104757: LD_INT 22
104759: PPUSH
104760: CALL 98290 0 2
104764: ST_TO_ADDR
// if result then
104765: LD_VAR 0 2
104769: IFFALSE 104775
// exit ;
104771: POP
104772: POP
104773: GO 104779
// end ;
104775: GO 104744
104777: POP
104778: POP
// end ;
104779: LD_VAR 0 2
104783: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104784: LD_INT 0
104786: PPUSH
104787: PPUSH
// if not units then
104788: LD_VAR 0 1
104792: NOT
104793: IFFALSE 104797
// exit ;
104795: GO 104867
// result := [ ] ;
104797: LD_ADDR_VAR 0 3
104801: PUSH
104802: EMPTY
104803: ST_TO_ADDR
// for i in units do
104804: LD_ADDR_VAR 0 4
104808: PUSH
104809: LD_VAR 0 1
104813: PUSH
104814: FOR_IN
104815: IFFALSE 104865
// if GetTag ( i ) = tag then
104817: LD_VAR 0 4
104821: PPUSH
104822: CALL_OW 110
104826: PUSH
104827: LD_VAR 0 2
104831: EQUAL
104832: IFFALSE 104863
// result := Insert ( result , result + 1 , i ) ;
104834: LD_ADDR_VAR 0 3
104838: PUSH
104839: LD_VAR 0 3
104843: PPUSH
104844: LD_VAR 0 3
104848: PUSH
104849: LD_INT 1
104851: PLUS
104852: PPUSH
104853: LD_VAR 0 4
104857: PPUSH
104858: CALL_OW 2
104862: ST_TO_ADDR
104863: GO 104814
104865: POP
104866: POP
// end ;
104867: LD_VAR 0 3
104871: RET
// export function IsDriver ( un ) ; begin
104872: LD_INT 0
104874: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104875: LD_ADDR_VAR 0 2
104879: PUSH
104880: LD_VAR 0 1
104884: PUSH
104885: LD_INT 55
104887: PUSH
104888: EMPTY
104889: LIST
104890: PPUSH
104891: CALL_OW 69
104895: IN
104896: ST_TO_ADDR
// end ;
104897: LD_VAR 0 2
104901: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104902: LD_INT 0
104904: PPUSH
104905: PPUSH
// list := [ ] ;
104906: LD_ADDR_VAR 0 5
104910: PUSH
104911: EMPTY
104912: ST_TO_ADDR
// case d of 0 :
104913: LD_VAR 0 3
104917: PUSH
104918: LD_INT 0
104920: DOUBLE
104921: EQUAL
104922: IFTRUE 104926
104924: GO 105059
104926: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104927: LD_ADDR_VAR 0 5
104931: PUSH
104932: LD_VAR 0 1
104936: PUSH
104937: LD_INT 4
104939: MINUS
104940: PUSH
104941: LD_VAR 0 2
104945: PUSH
104946: LD_INT 4
104948: MINUS
104949: PUSH
104950: LD_INT 2
104952: PUSH
104953: EMPTY
104954: LIST
104955: LIST
104956: LIST
104957: PUSH
104958: LD_VAR 0 1
104962: PUSH
104963: LD_INT 3
104965: MINUS
104966: PUSH
104967: LD_VAR 0 2
104971: PUSH
104972: LD_INT 1
104974: PUSH
104975: EMPTY
104976: LIST
104977: LIST
104978: LIST
104979: PUSH
104980: LD_VAR 0 1
104984: PUSH
104985: LD_INT 4
104987: PLUS
104988: PUSH
104989: LD_VAR 0 2
104993: PUSH
104994: LD_INT 4
104996: PUSH
104997: EMPTY
104998: LIST
104999: LIST
105000: LIST
105001: PUSH
105002: LD_VAR 0 1
105006: PUSH
105007: LD_INT 3
105009: PLUS
105010: PUSH
105011: LD_VAR 0 2
105015: PUSH
105016: LD_INT 3
105018: PLUS
105019: PUSH
105020: LD_INT 5
105022: PUSH
105023: EMPTY
105024: LIST
105025: LIST
105026: LIST
105027: PUSH
105028: LD_VAR 0 1
105032: PUSH
105033: LD_VAR 0 2
105037: PUSH
105038: LD_INT 4
105040: PLUS
105041: PUSH
105042: LD_INT 0
105044: PUSH
105045: EMPTY
105046: LIST
105047: LIST
105048: LIST
105049: PUSH
105050: EMPTY
105051: LIST
105052: LIST
105053: LIST
105054: LIST
105055: LIST
105056: ST_TO_ADDR
// end ; 1 :
105057: GO 105757
105059: LD_INT 1
105061: DOUBLE
105062: EQUAL
105063: IFTRUE 105067
105065: GO 105200
105067: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105068: LD_ADDR_VAR 0 5
105072: PUSH
105073: LD_VAR 0 1
105077: PUSH
105078: LD_VAR 0 2
105082: PUSH
105083: LD_INT 4
105085: MINUS
105086: PUSH
105087: LD_INT 3
105089: PUSH
105090: EMPTY
105091: LIST
105092: LIST
105093: LIST
105094: PUSH
105095: LD_VAR 0 1
105099: PUSH
105100: LD_INT 3
105102: MINUS
105103: PUSH
105104: LD_VAR 0 2
105108: PUSH
105109: LD_INT 3
105111: MINUS
105112: PUSH
105113: LD_INT 2
105115: PUSH
105116: EMPTY
105117: LIST
105118: LIST
105119: LIST
105120: PUSH
105121: LD_VAR 0 1
105125: PUSH
105126: LD_INT 4
105128: MINUS
105129: PUSH
105130: LD_VAR 0 2
105134: PUSH
105135: LD_INT 1
105137: PUSH
105138: EMPTY
105139: LIST
105140: LIST
105141: LIST
105142: PUSH
105143: LD_VAR 0 1
105147: PUSH
105148: LD_VAR 0 2
105152: PUSH
105153: LD_INT 3
105155: PLUS
105156: PUSH
105157: LD_INT 0
105159: PUSH
105160: EMPTY
105161: LIST
105162: LIST
105163: LIST
105164: PUSH
105165: LD_VAR 0 1
105169: PUSH
105170: LD_INT 4
105172: PLUS
105173: PUSH
105174: LD_VAR 0 2
105178: PUSH
105179: LD_INT 4
105181: PLUS
105182: PUSH
105183: LD_INT 5
105185: PUSH
105186: EMPTY
105187: LIST
105188: LIST
105189: LIST
105190: PUSH
105191: EMPTY
105192: LIST
105193: LIST
105194: LIST
105195: LIST
105196: LIST
105197: ST_TO_ADDR
// end ; 2 :
105198: GO 105757
105200: LD_INT 2
105202: DOUBLE
105203: EQUAL
105204: IFTRUE 105208
105206: GO 105337
105208: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105209: LD_ADDR_VAR 0 5
105213: PUSH
105214: LD_VAR 0 1
105218: PUSH
105219: LD_VAR 0 2
105223: PUSH
105224: LD_INT 3
105226: MINUS
105227: PUSH
105228: LD_INT 3
105230: PUSH
105231: EMPTY
105232: LIST
105233: LIST
105234: LIST
105235: PUSH
105236: LD_VAR 0 1
105240: PUSH
105241: LD_INT 4
105243: PLUS
105244: PUSH
105245: LD_VAR 0 2
105249: PUSH
105250: LD_INT 4
105252: PUSH
105253: EMPTY
105254: LIST
105255: LIST
105256: LIST
105257: PUSH
105258: LD_VAR 0 1
105262: PUSH
105263: LD_VAR 0 2
105267: PUSH
105268: LD_INT 4
105270: PLUS
105271: PUSH
105272: LD_INT 0
105274: PUSH
105275: EMPTY
105276: LIST
105277: LIST
105278: LIST
105279: PUSH
105280: LD_VAR 0 1
105284: PUSH
105285: LD_INT 3
105287: MINUS
105288: PUSH
105289: LD_VAR 0 2
105293: PUSH
105294: LD_INT 1
105296: PUSH
105297: EMPTY
105298: LIST
105299: LIST
105300: LIST
105301: PUSH
105302: LD_VAR 0 1
105306: PUSH
105307: LD_INT 4
105309: MINUS
105310: PUSH
105311: LD_VAR 0 2
105315: PUSH
105316: LD_INT 4
105318: MINUS
105319: PUSH
105320: LD_INT 2
105322: PUSH
105323: EMPTY
105324: LIST
105325: LIST
105326: LIST
105327: PUSH
105328: EMPTY
105329: LIST
105330: LIST
105331: LIST
105332: LIST
105333: LIST
105334: ST_TO_ADDR
// end ; 3 :
105335: GO 105757
105337: LD_INT 3
105339: DOUBLE
105340: EQUAL
105341: IFTRUE 105345
105343: GO 105478
105345: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105346: LD_ADDR_VAR 0 5
105350: PUSH
105351: LD_VAR 0 1
105355: PUSH
105356: LD_INT 3
105358: PLUS
105359: PUSH
105360: LD_VAR 0 2
105364: PUSH
105365: LD_INT 4
105367: PUSH
105368: EMPTY
105369: LIST
105370: LIST
105371: LIST
105372: PUSH
105373: LD_VAR 0 1
105377: PUSH
105378: LD_INT 4
105380: PLUS
105381: PUSH
105382: LD_VAR 0 2
105386: PUSH
105387: LD_INT 4
105389: PLUS
105390: PUSH
105391: LD_INT 5
105393: PUSH
105394: EMPTY
105395: LIST
105396: LIST
105397: LIST
105398: PUSH
105399: LD_VAR 0 1
105403: PUSH
105404: LD_INT 4
105406: MINUS
105407: PUSH
105408: LD_VAR 0 2
105412: PUSH
105413: LD_INT 1
105415: PUSH
105416: EMPTY
105417: LIST
105418: LIST
105419: LIST
105420: PUSH
105421: LD_VAR 0 1
105425: PUSH
105426: LD_VAR 0 2
105430: PUSH
105431: LD_INT 4
105433: MINUS
105434: PUSH
105435: LD_INT 3
105437: PUSH
105438: EMPTY
105439: LIST
105440: LIST
105441: LIST
105442: PUSH
105443: LD_VAR 0 1
105447: PUSH
105448: LD_INT 3
105450: MINUS
105451: PUSH
105452: LD_VAR 0 2
105456: PUSH
105457: LD_INT 3
105459: MINUS
105460: PUSH
105461: LD_INT 2
105463: PUSH
105464: EMPTY
105465: LIST
105466: LIST
105467: LIST
105468: PUSH
105469: EMPTY
105470: LIST
105471: LIST
105472: LIST
105473: LIST
105474: LIST
105475: ST_TO_ADDR
// end ; 4 :
105476: GO 105757
105478: LD_INT 4
105480: DOUBLE
105481: EQUAL
105482: IFTRUE 105486
105484: GO 105619
105486: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105487: LD_ADDR_VAR 0 5
105491: PUSH
105492: LD_VAR 0 1
105496: PUSH
105497: LD_VAR 0 2
105501: PUSH
105502: LD_INT 4
105504: PLUS
105505: PUSH
105506: LD_INT 0
105508: PUSH
105509: EMPTY
105510: LIST
105511: LIST
105512: LIST
105513: PUSH
105514: LD_VAR 0 1
105518: PUSH
105519: LD_INT 3
105521: PLUS
105522: PUSH
105523: LD_VAR 0 2
105527: PUSH
105528: LD_INT 3
105530: PLUS
105531: PUSH
105532: LD_INT 5
105534: PUSH
105535: EMPTY
105536: LIST
105537: LIST
105538: LIST
105539: PUSH
105540: LD_VAR 0 1
105544: PUSH
105545: LD_INT 4
105547: PLUS
105548: PUSH
105549: LD_VAR 0 2
105553: PUSH
105554: LD_INT 4
105556: PUSH
105557: EMPTY
105558: LIST
105559: LIST
105560: LIST
105561: PUSH
105562: LD_VAR 0 1
105566: PUSH
105567: LD_VAR 0 2
105571: PUSH
105572: LD_INT 3
105574: MINUS
105575: PUSH
105576: LD_INT 3
105578: PUSH
105579: EMPTY
105580: LIST
105581: LIST
105582: LIST
105583: PUSH
105584: LD_VAR 0 1
105588: PUSH
105589: LD_INT 4
105591: MINUS
105592: PUSH
105593: LD_VAR 0 2
105597: PUSH
105598: LD_INT 4
105600: MINUS
105601: PUSH
105602: LD_INT 2
105604: PUSH
105605: EMPTY
105606: LIST
105607: LIST
105608: LIST
105609: PUSH
105610: EMPTY
105611: LIST
105612: LIST
105613: LIST
105614: LIST
105615: LIST
105616: ST_TO_ADDR
// end ; 5 :
105617: GO 105757
105619: LD_INT 5
105621: DOUBLE
105622: EQUAL
105623: IFTRUE 105627
105625: GO 105756
105627: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105628: LD_ADDR_VAR 0 5
105632: PUSH
105633: LD_VAR 0 1
105637: PUSH
105638: LD_INT 4
105640: MINUS
105641: PUSH
105642: LD_VAR 0 2
105646: PUSH
105647: LD_INT 1
105649: PUSH
105650: EMPTY
105651: LIST
105652: LIST
105653: LIST
105654: PUSH
105655: LD_VAR 0 1
105659: PUSH
105660: LD_VAR 0 2
105664: PUSH
105665: LD_INT 4
105667: MINUS
105668: PUSH
105669: LD_INT 3
105671: PUSH
105672: EMPTY
105673: LIST
105674: LIST
105675: LIST
105676: PUSH
105677: LD_VAR 0 1
105681: PUSH
105682: LD_INT 4
105684: PLUS
105685: PUSH
105686: LD_VAR 0 2
105690: PUSH
105691: LD_INT 4
105693: PLUS
105694: PUSH
105695: LD_INT 5
105697: PUSH
105698: EMPTY
105699: LIST
105700: LIST
105701: LIST
105702: PUSH
105703: LD_VAR 0 1
105707: PUSH
105708: LD_INT 3
105710: PLUS
105711: PUSH
105712: LD_VAR 0 2
105716: PUSH
105717: LD_INT 4
105719: PUSH
105720: EMPTY
105721: LIST
105722: LIST
105723: LIST
105724: PUSH
105725: LD_VAR 0 1
105729: PUSH
105730: LD_VAR 0 2
105734: PUSH
105735: LD_INT 3
105737: PLUS
105738: PUSH
105739: LD_INT 0
105741: PUSH
105742: EMPTY
105743: LIST
105744: LIST
105745: LIST
105746: PUSH
105747: EMPTY
105748: LIST
105749: LIST
105750: LIST
105751: LIST
105752: LIST
105753: ST_TO_ADDR
// end ; end ;
105754: GO 105757
105756: POP
// result := list ;
105757: LD_ADDR_VAR 0 4
105761: PUSH
105762: LD_VAR 0 5
105766: ST_TO_ADDR
// end ;
105767: LD_VAR 0 4
105771: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105772: LD_INT 0
105774: PPUSH
105775: PPUSH
105776: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105777: LD_VAR 0 1
105781: NOT
105782: PUSH
105783: LD_VAR 0 2
105787: PUSH
105788: LD_INT 1
105790: PUSH
105791: LD_INT 2
105793: PUSH
105794: LD_INT 3
105796: PUSH
105797: LD_INT 4
105799: PUSH
105800: EMPTY
105801: LIST
105802: LIST
105803: LIST
105804: LIST
105805: IN
105806: NOT
105807: OR
105808: IFFALSE 105812
// exit ;
105810: GO 105904
// tmp := [ ] ;
105812: LD_ADDR_VAR 0 5
105816: PUSH
105817: EMPTY
105818: ST_TO_ADDR
// for i in units do
105819: LD_ADDR_VAR 0 4
105823: PUSH
105824: LD_VAR 0 1
105828: PUSH
105829: FOR_IN
105830: IFFALSE 105873
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105832: LD_ADDR_VAR 0 5
105836: PUSH
105837: LD_VAR 0 5
105841: PPUSH
105842: LD_VAR 0 5
105846: PUSH
105847: LD_INT 1
105849: PLUS
105850: PPUSH
105851: LD_VAR 0 4
105855: PPUSH
105856: LD_VAR 0 2
105860: PPUSH
105861: CALL_OW 259
105865: PPUSH
105866: CALL_OW 2
105870: ST_TO_ADDR
105871: GO 105829
105873: POP
105874: POP
// if not tmp then
105875: LD_VAR 0 5
105879: NOT
105880: IFFALSE 105884
// exit ;
105882: GO 105904
// result := SortListByListDesc ( units , tmp ) ;
105884: LD_ADDR_VAR 0 3
105888: PUSH
105889: LD_VAR 0 1
105893: PPUSH
105894: LD_VAR 0 5
105898: PPUSH
105899: CALL_OW 77
105903: ST_TO_ADDR
// end ;
105904: LD_VAR 0 3
105908: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105909: LD_INT 0
105911: PPUSH
105912: PPUSH
105913: PPUSH
// x := GetX ( building ) ;
105914: LD_ADDR_VAR 0 4
105918: PUSH
105919: LD_VAR 0 2
105923: PPUSH
105924: CALL_OW 250
105928: ST_TO_ADDR
// y := GetY ( building ) ;
105929: LD_ADDR_VAR 0 5
105933: PUSH
105934: LD_VAR 0 2
105938: PPUSH
105939: CALL_OW 251
105943: ST_TO_ADDR
// if GetTaskList ( unit ) then
105944: LD_VAR 0 1
105948: PPUSH
105949: CALL_OW 437
105953: IFFALSE 106048
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105955: LD_STRING e
105957: PUSH
105958: LD_VAR 0 1
105962: PPUSH
105963: CALL_OW 437
105967: PUSH
105968: LD_INT 1
105970: ARRAY
105971: PUSH
105972: LD_INT 1
105974: ARRAY
105975: EQUAL
105976: PUSH
105977: LD_VAR 0 4
105981: PUSH
105982: LD_VAR 0 1
105986: PPUSH
105987: CALL_OW 437
105991: PUSH
105992: LD_INT 1
105994: ARRAY
105995: PUSH
105996: LD_INT 2
105998: ARRAY
105999: EQUAL
106000: AND
106001: PUSH
106002: LD_VAR 0 5
106006: PUSH
106007: LD_VAR 0 1
106011: PPUSH
106012: CALL_OW 437
106016: PUSH
106017: LD_INT 1
106019: ARRAY
106020: PUSH
106021: LD_INT 3
106023: ARRAY
106024: EQUAL
106025: AND
106026: IFFALSE 106038
// result := true else
106028: LD_ADDR_VAR 0 3
106032: PUSH
106033: LD_INT 1
106035: ST_TO_ADDR
106036: GO 106046
// result := false ;
106038: LD_ADDR_VAR 0 3
106042: PUSH
106043: LD_INT 0
106045: ST_TO_ADDR
// end else
106046: GO 106056
// result := false ;
106048: LD_ADDR_VAR 0 3
106052: PUSH
106053: LD_INT 0
106055: ST_TO_ADDR
// end ;
106056: LD_VAR 0 3
106060: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106061: LD_INT 0
106063: PPUSH
106064: PPUSH
106065: PPUSH
106066: PPUSH
// if not unit or not area then
106067: LD_VAR 0 1
106071: NOT
106072: PUSH
106073: LD_VAR 0 2
106077: NOT
106078: OR
106079: IFFALSE 106083
// exit ;
106081: GO 106247
// tmp := AreaToList ( area , i ) ;
106083: LD_ADDR_VAR 0 6
106087: PUSH
106088: LD_VAR 0 2
106092: PPUSH
106093: LD_VAR 0 5
106097: PPUSH
106098: CALL_OW 517
106102: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106103: LD_ADDR_VAR 0 5
106107: PUSH
106108: DOUBLE
106109: LD_INT 1
106111: DEC
106112: ST_TO_ADDR
106113: LD_VAR 0 6
106117: PUSH
106118: LD_INT 1
106120: ARRAY
106121: PUSH
106122: FOR_TO
106123: IFFALSE 106245
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106125: LD_ADDR_VAR 0 7
106129: PUSH
106130: LD_VAR 0 6
106134: PUSH
106135: LD_INT 1
106137: ARRAY
106138: PUSH
106139: LD_VAR 0 5
106143: ARRAY
106144: PUSH
106145: LD_VAR 0 6
106149: PUSH
106150: LD_INT 2
106152: ARRAY
106153: PUSH
106154: LD_VAR 0 5
106158: ARRAY
106159: PUSH
106160: EMPTY
106161: LIST
106162: LIST
106163: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106164: LD_VAR 0 7
106168: PUSH
106169: LD_INT 1
106171: ARRAY
106172: PPUSH
106173: LD_VAR 0 7
106177: PUSH
106178: LD_INT 2
106180: ARRAY
106181: PPUSH
106182: CALL_OW 428
106186: PUSH
106187: LD_INT 0
106189: EQUAL
106190: IFFALSE 106243
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106192: LD_VAR 0 1
106196: PPUSH
106197: LD_VAR 0 7
106201: PUSH
106202: LD_INT 1
106204: ARRAY
106205: PPUSH
106206: LD_VAR 0 7
106210: PUSH
106211: LD_INT 2
106213: ARRAY
106214: PPUSH
106215: LD_VAR 0 3
106219: PPUSH
106220: CALL_OW 48
// result := IsPlaced ( unit ) ;
106224: LD_ADDR_VAR 0 4
106228: PUSH
106229: LD_VAR 0 1
106233: PPUSH
106234: CALL_OW 305
106238: ST_TO_ADDR
// exit ;
106239: POP
106240: POP
106241: GO 106247
// end ; end ;
106243: GO 106122
106245: POP
106246: POP
// end ;
106247: LD_VAR 0 4
106251: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106252: LD_INT 0
106254: PPUSH
106255: PPUSH
106256: PPUSH
// if not side or side > 8 then
106257: LD_VAR 0 1
106261: NOT
106262: PUSH
106263: LD_VAR 0 1
106267: PUSH
106268: LD_INT 8
106270: GREATER
106271: OR
106272: IFFALSE 106276
// exit ;
106274: GO 106463
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106276: LD_ADDR_VAR 0 4
106280: PUSH
106281: LD_INT 22
106283: PUSH
106284: LD_VAR 0 1
106288: PUSH
106289: EMPTY
106290: LIST
106291: LIST
106292: PUSH
106293: LD_INT 21
106295: PUSH
106296: LD_INT 3
106298: PUSH
106299: EMPTY
106300: LIST
106301: LIST
106302: PUSH
106303: EMPTY
106304: LIST
106305: LIST
106306: PPUSH
106307: CALL_OW 69
106311: ST_TO_ADDR
// if not tmp then
106312: LD_VAR 0 4
106316: NOT
106317: IFFALSE 106321
// exit ;
106319: GO 106463
// enable_addtolog := true ;
106321: LD_ADDR_OWVAR 81
106325: PUSH
106326: LD_INT 1
106328: ST_TO_ADDR
// AddToLog ( [ ) ;
106329: LD_STRING [
106331: PPUSH
106332: CALL_OW 561
// for i in tmp do
106336: LD_ADDR_VAR 0 3
106340: PUSH
106341: LD_VAR 0 4
106345: PUSH
106346: FOR_IN
106347: IFFALSE 106454
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106349: LD_STRING [
106351: PUSH
106352: LD_VAR 0 3
106356: PPUSH
106357: CALL_OW 266
106361: STR
106362: PUSH
106363: LD_STRING , 
106365: STR
106366: PUSH
106367: LD_VAR 0 3
106371: PPUSH
106372: CALL_OW 250
106376: STR
106377: PUSH
106378: LD_STRING , 
106380: STR
106381: PUSH
106382: LD_VAR 0 3
106386: PPUSH
106387: CALL_OW 251
106391: STR
106392: PUSH
106393: LD_STRING , 
106395: STR
106396: PUSH
106397: LD_VAR 0 3
106401: PPUSH
106402: CALL_OW 254
106406: STR
106407: PUSH
106408: LD_STRING , 
106410: STR
106411: PUSH
106412: LD_VAR 0 3
106416: PPUSH
106417: LD_INT 1
106419: PPUSH
106420: CALL_OW 268
106424: STR
106425: PUSH
106426: LD_STRING , 
106428: STR
106429: PUSH
106430: LD_VAR 0 3
106434: PPUSH
106435: LD_INT 2
106437: PPUSH
106438: CALL_OW 268
106442: STR
106443: PUSH
106444: LD_STRING ],
106446: STR
106447: PPUSH
106448: CALL_OW 561
// end ;
106452: GO 106346
106454: POP
106455: POP
// AddToLog ( ]; ) ;
106456: LD_STRING ];
106458: PPUSH
106459: CALL_OW 561
// end ;
106463: LD_VAR 0 2
106467: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106468: LD_INT 0
106470: PPUSH
106471: PPUSH
106472: PPUSH
106473: PPUSH
106474: PPUSH
// if not area or not rate or not max then
106475: LD_VAR 0 1
106479: NOT
106480: PUSH
106481: LD_VAR 0 2
106485: NOT
106486: OR
106487: PUSH
106488: LD_VAR 0 4
106492: NOT
106493: OR
106494: IFFALSE 106498
// exit ;
106496: GO 106690
// while 1 do
106498: LD_INT 1
106500: IFFALSE 106690
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106502: LD_ADDR_VAR 0 9
106506: PUSH
106507: LD_VAR 0 1
106511: PPUSH
106512: LD_INT 1
106514: PPUSH
106515: CALL_OW 287
106519: PUSH
106520: LD_INT 10
106522: MUL
106523: ST_TO_ADDR
// r := rate / 10 ;
106524: LD_ADDR_VAR 0 7
106528: PUSH
106529: LD_VAR 0 2
106533: PUSH
106534: LD_INT 10
106536: DIVREAL
106537: ST_TO_ADDR
// time := 1 1$00 ;
106538: LD_ADDR_VAR 0 8
106542: PUSH
106543: LD_INT 2100
106545: ST_TO_ADDR
// if amount < min then
106546: LD_VAR 0 9
106550: PUSH
106551: LD_VAR 0 3
106555: LESS
106556: IFFALSE 106574
// r := r * 2 else
106558: LD_ADDR_VAR 0 7
106562: PUSH
106563: LD_VAR 0 7
106567: PUSH
106568: LD_INT 2
106570: MUL
106571: ST_TO_ADDR
106572: GO 106600
// if amount > max then
106574: LD_VAR 0 9
106578: PUSH
106579: LD_VAR 0 4
106583: GREATER
106584: IFFALSE 106600
// r := r / 2 ;
106586: LD_ADDR_VAR 0 7
106590: PUSH
106591: LD_VAR 0 7
106595: PUSH
106596: LD_INT 2
106598: DIVREAL
106599: ST_TO_ADDR
// time := time / r ;
106600: LD_ADDR_VAR 0 8
106604: PUSH
106605: LD_VAR 0 8
106609: PUSH
106610: LD_VAR 0 7
106614: DIVREAL
106615: ST_TO_ADDR
// if time < 0 then
106616: LD_VAR 0 8
106620: PUSH
106621: LD_INT 0
106623: LESS
106624: IFFALSE 106641
// time := time * - 1 ;
106626: LD_ADDR_VAR 0 8
106630: PUSH
106631: LD_VAR 0 8
106635: PUSH
106636: LD_INT 1
106638: NEG
106639: MUL
106640: ST_TO_ADDR
// wait ( time ) ;
106641: LD_VAR 0 8
106645: PPUSH
106646: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106650: LD_INT 35
106652: PPUSH
106653: LD_INT 875
106655: PPUSH
106656: CALL_OW 12
106660: PPUSH
106661: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106665: LD_INT 1
106667: PPUSH
106668: LD_INT 5
106670: PPUSH
106671: CALL_OW 12
106675: PPUSH
106676: LD_VAR 0 1
106680: PPUSH
106681: LD_INT 1
106683: PPUSH
106684: CALL_OW 55
// end ;
106688: GO 106498
// end ;
106690: LD_VAR 0 5
106694: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106695: LD_INT 0
106697: PPUSH
106698: PPUSH
106699: PPUSH
106700: PPUSH
106701: PPUSH
106702: PPUSH
106703: PPUSH
106704: PPUSH
// if not turrets or not factories then
106705: LD_VAR 0 1
106709: NOT
106710: PUSH
106711: LD_VAR 0 2
106715: NOT
106716: OR
106717: IFFALSE 106721
// exit ;
106719: GO 107028
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106721: LD_ADDR_VAR 0 10
106725: PUSH
106726: LD_INT 5
106728: PUSH
106729: LD_INT 6
106731: PUSH
106732: EMPTY
106733: LIST
106734: LIST
106735: PUSH
106736: LD_INT 2
106738: PUSH
106739: LD_INT 4
106741: PUSH
106742: EMPTY
106743: LIST
106744: LIST
106745: PUSH
106746: LD_INT 3
106748: PUSH
106749: LD_INT 5
106751: PUSH
106752: EMPTY
106753: LIST
106754: LIST
106755: PUSH
106756: EMPTY
106757: LIST
106758: LIST
106759: LIST
106760: PUSH
106761: LD_INT 24
106763: PUSH
106764: LD_INT 25
106766: PUSH
106767: EMPTY
106768: LIST
106769: LIST
106770: PUSH
106771: LD_INT 23
106773: PUSH
106774: LD_INT 27
106776: PUSH
106777: EMPTY
106778: LIST
106779: LIST
106780: PUSH
106781: EMPTY
106782: LIST
106783: LIST
106784: PUSH
106785: LD_INT 42
106787: PUSH
106788: LD_INT 43
106790: PUSH
106791: EMPTY
106792: LIST
106793: LIST
106794: PUSH
106795: LD_INT 44
106797: PUSH
106798: LD_INT 46
106800: PUSH
106801: EMPTY
106802: LIST
106803: LIST
106804: PUSH
106805: LD_INT 45
106807: PUSH
106808: LD_INT 47
106810: PUSH
106811: EMPTY
106812: LIST
106813: LIST
106814: PUSH
106815: EMPTY
106816: LIST
106817: LIST
106818: LIST
106819: PUSH
106820: EMPTY
106821: LIST
106822: LIST
106823: LIST
106824: ST_TO_ADDR
// result := [ ] ;
106825: LD_ADDR_VAR 0 3
106829: PUSH
106830: EMPTY
106831: ST_TO_ADDR
// for i in turrets do
106832: LD_ADDR_VAR 0 4
106836: PUSH
106837: LD_VAR 0 1
106841: PUSH
106842: FOR_IN
106843: IFFALSE 107026
// begin nat := GetNation ( i ) ;
106845: LD_ADDR_VAR 0 7
106849: PUSH
106850: LD_VAR 0 4
106854: PPUSH
106855: CALL_OW 248
106859: ST_TO_ADDR
// weapon := 0 ;
106860: LD_ADDR_VAR 0 8
106864: PUSH
106865: LD_INT 0
106867: ST_TO_ADDR
// if not nat then
106868: LD_VAR 0 7
106872: NOT
106873: IFFALSE 106877
// continue ;
106875: GO 106842
// for j in list [ nat ] do
106877: LD_ADDR_VAR 0 5
106881: PUSH
106882: LD_VAR 0 10
106886: PUSH
106887: LD_VAR 0 7
106891: ARRAY
106892: PUSH
106893: FOR_IN
106894: IFFALSE 106935
// if GetBWeapon ( i ) = j [ 1 ] then
106896: LD_VAR 0 4
106900: PPUSH
106901: CALL_OW 269
106905: PUSH
106906: LD_VAR 0 5
106910: PUSH
106911: LD_INT 1
106913: ARRAY
106914: EQUAL
106915: IFFALSE 106933
// begin weapon := j [ 2 ] ;
106917: LD_ADDR_VAR 0 8
106921: PUSH
106922: LD_VAR 0 5
106926: PUSH
106927: LD_INT 2
106929: ARRAY
106930: ST_TO_ADDR
// break ;
106931: GO 106935
// end ;
106933: GO 106893
106935: POP
106936: POP
// if not weapon then
106937: LD_VAR 0 8
106941: NOT
106942: IFFALSE 106946
// continue ;
106944: GO 106842
// for k in factories do
106946: LD_ADDR_VAR 0 6
106950: PUSH
106951: LD_VAR 0 2
106955: PUSH
106956: FOR_IN
106957: IFFALSE 107022
// begin weapons := AvailableWeaponList ( k ) ;
106959: LD_ADDR_VAR 0 9
106963: PUSH
106964: LD_VAR 0 6
106968: PPUSH
106969: CALL_OW 478
106973: ST_TO_ADDR
// if not weapons then
106974: LD_VAR 0 9
106978: NOT
106979: IFFALSE 106983
// continue ;
106981: GO 106956
// if weapon in weapons then
106983: LD_VAR 0 8
106987: PUSH
106988: LD_VAR 0 9
106992: IN
106993: IFFALSE 107020
// begin result := [ i , weapon ] ;
106995: LD_ADDR_VAR 0 3
106999: PUSH
107000: LD_VAR 0 4
107004: PUSH
107005: LD_VAR 0 8
107009: PUSH
107010: EMPTY
107011: LIST
107012: LIST
107013: ST_TO_ADDR
// exit ;
107014: POP
107015: POP
107016: POP
107017: POP
107018: GO 107028
// end ; end ;
107020: GO 106956
107022: POP
107023: POP
// end ;
107024: GO 106842
107026: POP
107027: POP
// end ;
107028: LD_VAR 0 3
107032: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107033: LD_INT 0
107035: PPUSH
// if not side or side > 8 then
107036: LD_VAR 0 3
107040: NOT
107041: PUSH
107042: LD_VAR 0 3
107046: PUSH
107047: LD_INT 8
107049: GREATER
107050: OR
107051: IFFALSE 107055
// exit ;
107053: GO 107114
// if not range then
107055: LD_VAR 0 4
107059: NOT
107060: IFFALSE 107071
// range := - 12 ;
107062: LD_ADDR_VAR 0 4
107066: PUSH
107067: LD_INT 12
107069: NEG
107070: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107071: LD_VAR 0 1
107075: PPUSH
107076: LD_VAR 0 2
107080: PPUSH
107081: LD_VAR 0 3
107085: PPUSH
107086: LD_VAR 0 4
107090: PPUSH
107091: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107095: LD_VAR 0 1
107099: PPUSH
107100: LD_VAR 0 2
107104: PPUSH
107105: LD_VAR 0 3
107109: PPUSH
107110: CALL_OW 331
// end ;
107114: LD_VAR 0 5
107118: RET
// export function Video ( mode ) ; begin
107119: LD_INT 0
107121: PPUSH
// ingame_video = mode ;
107122: LD_ADDR_OWVAR 52
107126: PUSH
107127: LD_VAR 0 1
107131: ST_TO_ADDR
// interface_hidden = mode ;
107132: LD_ADDR_OWVAR 54
107136: PUSH
107137: LD_VAR 0 1
107141: ST_TO_ADDR
// end ;
107142: LD_VAR 0 2
107146: RET
// export function Join ( array , element ) ; begin
107147: LD_INT 0
107149: PPUSH
// result := array ^ element ;
107150: LD_ADDR_VAR 0 3
107154: PUSH
107155: LD_VAR 0 1
107159: PUSH
107160: LD_VAR 0 2
107164: ADD
107165: ST_TO_ADDR
// end ;
107166: LD_VAR 0 3
107170: RET
// export function JoinUnion ( array , element ) ; begin
107171: LD_INT 0
107173: PPUSH
// result := array union element ;
107174: LD_ADDR_VAR 0 3
107178: PUSH
107179: LD_VAR 0 1
107183: PUSH
107184: LD_VAR 0 2
107188: UNION
107189: ST_TO_ADDR
// end ;
107190: LD_VAR 0 3
107194: RET
// export function GetBehemoths ( side ) ; begin
107195: LD_INT 0
107197: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107198: LD_ADDR_VAR 0 2
107202: PUSH
107203: LD_INT 22
107205: PUSH
107206: LD_VAR 0 1
107210: PUSH
107211: EMPTY
107212: LIST
107213: LIST
107214: PUSH
107215: LD_INT 31
107217: PUSH
107218: LD_INT 25
107220: PUSH
107221: EMPTY
107222: LIST
107223: LIST
107224: PUSH
107225: EMPTY
107226: LIST
107227: LIST
107228: PPUSH
107229: CALL_OW 69
107233: ST_TO_ADDR
// end ;
107234: LD_VAR 0 2
107238: RET
// export function Shuffle ( array ) ; var i , index ; begin
107239: LD_INT 0
107241: PPUSH
107242: PPUSH
107243: PPUSH
// result := [ ] ;
107244: LD_ADDR_VAR 0 2
107248: PUSH
107249: EMPTY
107250: ST_TO_ADDR
// if not array then
107251: LD_VAR 0 1
107255: NOT
107256: IFFALSE 107260
// exit ;
107258: GO 107359
// Randomize ;
107260: CALL_OW 10
// for i = array downto 1 do
107264: LD_ADDR_VAR 0 3
107268: PUSH
107269: DOUBLE
107270: LD_VAR 0 1
107274: INC
107275: ST_TO_ADDR
107276: LD_INT 1
107278: PUSH
107279: FOR_DOWNTO
107280: IFFALSE 107357
// begin index := rand ( 1 , array ) ;
107282: LD_ADDR_VAR 0 4
107286: PUSH
107287: LD_INT 1
107289: PPUSH
107290: LD_VAR 0 1
107294: PPUSH
107295: CALL_OW 12
107299: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107300: LD_ADDR_VAR 0 2
107304: PUSH
107305: LD_VAR 0 2
107309: PPUSH
107310: LD_VAR 0 2
107314: PUSH
107315: LD_INT 1
107317: PLUS
107318: PPUSH
107319: LD_VAR 0 1
107323: PUSH
107324: LD_VAR 0 4
107328: ARRAY
107329: PPUSH
107330: CALL_OW 2
107334: ST_TO_ADDR
// array := Delete ( array , index ) ;
107335: LD_ADDR_VAR 0 1
107339: PUSH
107340: LD_VAR 0 1
107344: PPUSH
107345: LD_VAR 0 4
107349: PPUSH
107350: CALL_OW 3
107354: ST_TO_ADDR
// end ;
107355: GO 107279
107357: POP
107358: POP
// end ;
107359: LD_VAR 0 2
107363: RET
// export function GetBaseMaterials ( base ) ; begin
107364: LD_INT 0
107366: PPUSH
// result := [ 0 , 0 , 0 ] ;
107367: LD_ADDR_VAR 0 2
107371: PUSH
107372: LD_INT 0
107374: PUSH
107375: LD_INT 0
107377: PUSH
107378: LD_INT 0
107380: PUSH
107381: EMPTY
107382: LIST
107383: LIST
107384: LIST
107385: ST_TO_ADDR
// if not base then
107386: LD_VAR 0 1
107390: NOT
107391: IFFALSE 107395
// exit ;
107393: GO 107444
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107395: LD_ADDR_VAR 0 2
107399: PUSH
107400: LD_VAR 0 1
107404: PPUSH
107405: LD_INT 1
107407: PPUSH
107408: CALL_OW 275
107412: PUSH
107413: LD_VAR 0 1
107417: PPUSH
107418: LD_INT 2
107420: PPUSH
107421: CALL_OW 275
107425: PUSH
107426: LD_VAR 0 1
107430: PPUSH
107431: LD_INT 3
107433: PPUSH
107434: CALL_OW 275
107438: PUSH
107439: EMPTY
107440: LIST
107441: LIST
107442: LIST
107443: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107444: LD_VAR 0 2
107448: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107449: LD_INT 0
107451: PPUSH
107452: PPUSH
107453: PPUSH
107454: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107455: LD_VAR 0 1
107459: PPUSH
107460: CALL_OW 264
107464: PUSH
107465: LD_EXP 98
107469: EQUAL
107470: IFFALSE 107542
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107472: LD_INT 68
107474: PPUSH
107475: LD_VAR 0 1
107479: PPUSH
107480: CALL_OW 255
107484: PPUSH
107485: CALL_OW 321
107489: PUSH
107490: LD_INT 2
107492: EQUAL
107493: IFFALSE 107505
// eff := 70 else
107495: LD_ADDR_VAR 0 6
107499: PUSH
107500: LD_INT 70
107502: ST_TO_ADDR
107503: GO 107513
// eff := 30 ;
107505: LD_ADDR_VAR 0 6
107509: PUSH
107510: LD_INT 30
107512: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107513: LD_VAR 0 1
107517: PPUSH
107518: CALL_OW 250
107522: PPUSH
107523: LD_VAR 0 1
107527: PPUSH
107528: CALL_OW 251
107532: PPUSH
107533: LD_VAR 0 6
107537: PPUSH
107538: CALL_OW 495
// end ; end ;
107542: LD_VAR 0 4
107546: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107547: LD_INT 0
107549: PPUSH
107550: PPUSH
107551: PPUSH
107552: PPUSH
107553: PPUSH
107554: PPUSH
// if cmd = 124 then
107555: LD_VAR 0 1
107559: PUSH
107560: LD_INT 124
107562: EQUAL
107563: IFFALSE 107769
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107565: LD_ADDR_VAR 0 5
107569: PUSH
107570: LD_INT 2
107572: PUSH
107573: LD_INT 34
107575: PUSH
107576: LD_INT 53
107578: PUSH
107579: EMPTY
107580: LIST
107581: LIST
107582: PUSH
107583: LD_INT 34
107585: PUSH
107586: LD_INT 14
107588: PUSH
107589: EMPTY
107590: LIST
107591: LIST
107592: PUSH
107593: EMPTY
107594: LIST
107595: LIST
107596: LIST
107597: PPUSH
107598: CALL_OW 69
107602: ST_TO_ADDR
// if not tmp then
107603: LD_VAR 0 5
107607: NOT
107608: IFFALSE 107612
// exit ;
107610: GO 107769
// for i in tmp do
107612: LD_ADDR_VAR 0 3
107616: PUSH
107617: LD_VAR 0 5
107621: PUSH
107622: FOR_IN
107623: IFFALSE 107767
// begin taskList := GetTaskList ( i ) ;
107625: LD_ADDR_VAR 0 6
107629: PUSH
107630: LD_VAR 0 3
107634: PPUSH
107635: CALL_OW 437
107639: ST_TO_ADDR
// if not taskList then
107640: LD_VAR 0 6
107644: NOT
107645: IFFALSE 107649
// continue ;
107647: GO 107622
// for j = 1 to taskList do
107649: LD_ADDR_VAR 0 4
107653: PUSH
107654: DOUBLE
107655: LD_INT 1
107657: DEC
107658: ST_TO_ADDR
107659: LD_VAR 0 6
107663: PUSH
107664: FOR_TO
107665: IFFALSE 107763
// if taskList [ j ] [ 1 ] = | then
107667: LD_VAR 0 6
107671: PUSH
107672: LD_VAR 0 4
107676: ARRAY
107677: PUSH
107678: LD_INT 1
107680: ARRAY
107681: PUSH
107682: LD_STRING |
107684: EQUAL
107685: IFFALSE 107761
// begin _taskList := Delete ( taskList , 1 ) ;
107687: LD_ADDR_VAR 0 7
107691: PUSH
107692: LD_VAR 0 6
107696: PPUSH
107697: LD_INT 1
107699: PPUSH
107700: CALL_OW 3
107704: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107705: LD_VAR 0 3
107709: PPUSH
107710: LD_VAR 0 7
107714: PPUSH
107715: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107719: LD_VAR 0 3
107723: PPUSH
107724: LD_VAR 0 6
107728: PUSH
107729: LD_VAR 0 4
107733: ARRAY
107734: PUSH
107735: LD_INT 2
107737: ARRAY
107738: PPUSH
107739: LD_VAR 0 6
107743: PUSH
107744: LD_VAR 0 4
107748: ARRAY
107749: PUSH
107750: LD_INT 3
107752: ARRAY
107753: PPUSH
107754: LD_INT 8
107756: PPUSH
107757: CALL 107774 0 4
// end ;
107761: GO 107664
107763: POP
107764: POP
// end ;
107765: GO 107622
107767: POP
107768: POP
// end ; end ;
107769: LD_VAR 0 2
107773: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107774: LD_INT 0
107776: PPUSH
107777: PPUSH
107778: PPUSH
107779: PPUSH
107780: PPUSH
107781: PPUSH
107782: PPUSH
107783: PPUSH
107784: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107785: LD_VAR 0 1
107789: NOT
107790: PUSH
107791: LD_VAR 0 2
107795: PPUSH
107796: LD_VAR 0 3
107800: PPUSH
107801: CALL_OW 488
107805: NOT
107806: OR
107807: PUSH
107808: LD_VAR 0 4
107812: NOT
107813: OR
107814: IFFALSE 107818
// exit ;
107816: GO 108158
// list := [ ] ;
107818: LD_ADDR_VAR 0 13
107822: PUSH
107823: EMPTY
107824: ST_TO_ADDR
// if x - r < 0 then
107825: LD_VAR 0 2
107829: PUSH
107830: LD_VAR 0 4
107834: MINUS
107835: PUSH
107836: LD_INT 0
107838: LESS
107839: IFFALSE 107851
// min_x := 0 else
107841: LD_ADDR_VAR 0 7
107845: PUSH
107846: LD_INT 0
107848: ST_TO_ADDR
107849: GO 107867
// min_x := x - r ;
107851: LD_ADDR_VAR 0 7
107855: PUSH
107856: LD_VAR 0 2
107860: PUSH
107861: LD_VAR 0 4
107865: MINUS
107866: ST_TO_ADDR
// if y - r < 0 then
107867: LD_VAR 0 3
107871: PUSH
107872: LD_VAR 0 4
107876: MINUS
107877: PUSH
107878: LD_INT 0
107880: LESS
107881: IFFALSE 107893
// min_y := 0 else
107883: LD_ADDR_VAR 0 8
107887: PUSH
107888: LD_INT 0
107890: ST_TO_ADDR
107891: GO 107909
// min_y := y - r ;
107893: LD_ADDR_VAR 0 8
107897: PUSH
107898: LD_VAR 0 3
107902: PUSH
107903: LD_VAR 0 4
107907: MINUS
107908: ST_TO_ADDR
// max_x := x + r ;
107909: LD_ADDR_VAR 0 9
107913: PUSH
107914: LD_VAR 0 2
107918: PUSH
107919: LD_VAR 0 4
107923: PLUS
107924: ST_TO_ADDR
// max_y := y + r ;
107925: LD_ADDR_VAR 0 10
107929: PUSH
107930: LD_VAR 0 3
107934: PUSH
107935: LD_VAR 0 4
107939: PLUS
107940: ST_TO_ADDR
// for _x = min_x to max_x do
107941: LD_ADDR_VAR 0 11
107945: PUSH
107946: DOUBLE
107947: LD_VAR 0 7
107951: DEC
107952: ST_TO_ADDR
107953: LD_VAR 0 9
107957: PUSH
107958: FOR_TO
107959: IFFALSE 108076
// for _y = min_y to max_y do
107961: LD_ADDR_VAR 0 12
107965: PUSH
107966: DOUBLE
107967: LD_VAR 0 8
107971: DEC
107972: ST_TO_ADDR
107973: LD_VAR 0 10
107977: PUSH
107978: FOR_TO
107979: IFFALSE 108072
// begin if not ValidHex ( _x , _y ) then
107981: LD_VAR 0 11
107985: PPUSH
107986: LD_VAR 0 12
107990: PPUSH
107991: CALL_OW 488
107995: NOT
107996: IFFALSE 108000
// continue ;
107998: GO 107978
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108000: LD_VAR 0 11
108004: PPUSH
108005: LD_VAR 0 12
108009: PPUSH
108010: CALL_OW 351
108014: PUSH
108015: LD_VAR 0 11
108019: PPUSH
108020: LD_VAR 0 12
108024: PPUSH
108025: CALL_OW 554
108029: AND
108030: IFFALSE 108070
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108032: LD_ADDR_VAR 0 13
108036: PUSH
108037: LD_VAR 0 13
108041: PPUSH
108042: LD_VAR 0 13
108046: PUSH
108047: LD_INT 1
108049: PLUS
108050: PPUSH
108051: LD_VAR 0 11
108055: PUSH
108056: LD_VAR 0 12
108060: PUSH
108061: EMPTY
108062: LIST
108063: LIST
108064: PPUSH
108065: CALL_OW 2
108069: ST_TO_ADDR
// end ;
108070: GO 107978
108072: POP
108073: POP
108074: GO 107958
108076: POP
108077: POP
// if not list then
108078: LD_VAR 0 13
108082: NOT
108083: IFFALSE 108087
// exit ;
108085: GO 108158
// for i in list do
108087: LD_ADDR_VAR 0 6
108091: PUSH
108092: LD_VAR 0 13
108096: PUSH
108097: FOR_IN
108098: IFFALSE 108156
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108100: LD_VAR 0 1
108104: PPUSH
108105: LD_STRING M
108107: PUSH
108108: LD_VAR 0 6
108112: PUSH
108113: LD_INT 1
108115: ARRAY
108116: PUSH
108117: LD_VAR 0 6
108121: PUSH
108122: LD_INT 2
108124: ARRAY
108125: PUSH
108126: LD_INT 0
108128: PUSH
108129: LD_INT 0
108131: PUSH
108132: LD_INT 0
108134: PUSH
108135: LD_INT 0
108137: PUSH
108138: EMPTY
108139: LIST
108140: LIST
108141: LIST
108142: LIST
108143: LIST
108144: LIST
108145: LIST
108146: PUSH
108147: EMPTY
108148: LIST
108149: PPUSH
108150: CALL_OW 447
108154: GO 108097
108156: POP
108157: POP
// end ;
108158: LD_VAR 0 5
108162: RET
