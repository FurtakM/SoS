// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34060 0 0
// InitNature ;
  19: CALL 33884 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10958 0 0
// PrepareRussian ;
  40: CALL 6941 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2935 0 0
// PrepareAmerican ;
  52: CALL 1707 0 0
// Action ;
  56: CALL 14865 0 0
// MC_Start ( ) ;
  60: CALL 36172 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// end ;
 455: LD_VAR 0 1
 459: RET
// export function CustomInitMacro ( ) ; begin
 460: LD_INT 0
 462: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 463: LD_ADDR_EXP 125
 467: PUSH
 468: LD_INT 2
 470: PUSH
 471: LD_INT 3
 473: PUSH
 474: LD_INT 6
 476: PUSH
 477: LD_INT 10
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 486: LD_ADDR_EXP 126
 490: PUSH
 491: LD_INT 1
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: LD_INT 5
 499: PUSH
 500: LD_INT 9
 502: PUSH
 503: EMPTY
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 509: LD_INT 1
 511: PPUSH
 512: LD_INT 10
 514: PUSH
 515: LD_INT 11
 517: PUSH
 518: LD_INT 12
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: LIST
 525: PPUSH
 526: CALL 58553 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 530: LD_INT 1
 532: PPUSH
 533: LD_INT 17
 535: PUSH
 536: EMPTY
 537: LIST
 538: PPUSH
 539: CALL 58646 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 5
 548: PPUSH
 549: CALL 57996 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 553: LD_INT 1
 555: PPUSH
 556: LD_INT 24
 558: PUSH
 559: LD_INT 3
 561: PUSH
 562: LD_INT 3
 564: PUSH
 565: LD_INT 47
 567: PUSH
 568: EMPTY
 569: LIST
 570: LIST
 571: LIST
 572: LIST
 573: PUSH
 574: LD_INT 24
 576: PUSH
 577: LD_INT 3
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 47
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: PUSH
 592: LD_INT 24
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 47
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: PUSH
 610: LD_INT 24
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 47
 621: PUSH
 622: EMPTY
 623: LIST
 624: LIST
 625: LIST
 626: LIST
 627: PUSH
 628: LD_INT 24
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 1
 636: PUSH
 637: LD_INT 47
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: LIST
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PPUSH
 653: CALL 57811 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 657: LD_INT 2
 659: PPUSH
 660: LD_INT 10
 662: PUSH
 663: LD_INT 11
 665: PUSH
 666: LD_INT 12
 668: PUSH
 669: LD_INT 14
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: PPUSH
 678: CALL 58553 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 682: LD_INT 2
 684: PPUSH
 685: LD_INT 16
 687: PUSH
 688: EMPTY
 689: LIST
 690: PPUSH
 691: CALL 58646 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 21
 700: PUSH
 701: LD_INT 3
 703: PUSH
 704: LD_INT 3
 706: PUSH
 707: LD_INT 51
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: LIST
 715: PUSH
 716: LD_INT 22
 718: PUSH
 719: LD_INT 3
 721: PUSH
 722: LD_INT 3
 724: PUSH
 725: LD_INT 52
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 22
 736: PUSH
 737: LD_INT 3
 739: PUSH
 740: LD_INT 3
 742: PUSH
 743: LD_INT 52
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 24
 754: PUSH
 755: LD_INT 3
 757: PUSH
 758: LD_INT 3
 760: PUSH
 761: LD_INT 47
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 24
 772: PUSH
 773: LD_INT 3
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 47
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 24
 790: PUSH
 791: LD_INT 3
 793: PUSH
 794: LD_INT 3
 796: PUSH
 797: LD_INT 47
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 24
 808: PUSH
 809: LD_INT 3
 811: PUSH
 812: LD_INT 3
 814: PUSH
 815: LD_INT 47
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 24
 826: PUSH
 827: LD_INT 3
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: LD_INT 47
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: PPUSH
 852: CALL 57811 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 856: LD_INT 2
 858: PPUSH
 859: LD_INT 5
 861: PPUSH
 862: CALL 57996 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 866: LD_INT 2
 868: PPUSH
 869: LD_INT 0
 871: PPUSH
 872: CALL 58426 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 876: LD_INT 3
 878: PPUSH
 879: LD_INT 10
 881: PUSH
 882: LD_INT 12
 884: PUSH
 885: LD_INT 15
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: LIST
 892: PUSH
 893: LD_OWVAR 67
 897: ARRAY
 898: PPUSH
 899: LD_INT 27
 901: PPUSH
 902: CALL 57493 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 906: LD_INT 3
 908: PPUSH
 909: LD_INT 10
 911: PUSH
 912: LD_INT 11
 914: PUSH
 915: LD_INT 13
 917: PUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL 58553 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 931: LD_INT 3
 933: PPUSH
 934: LD_INT 15
 936: PUSH
 937: EMPTY
 938: LIST
 939: PPUSH
 940: CALL 58646 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 944: LD_ADDR_EXP 130
 948: PUSH
 949: LD_EXP 130
 953: PPUSH
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 22
 959: PUSH
 960: LD_INT 8
 962: PUSH
 963: EMPTY
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 25
 969: PUSH
 970: LD_INT 15
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: PPUSH
 981: CALL_OW 69
 985: PPUSH
 986: CALL_OW 1
 990: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 991: LD_INT 3
 993: PPUSH
 994: LD_INT 13
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 31
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: PUSH
1012: LD_INT 13
1014: PUSH
1015: LD_INT 2
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 31
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: LIST
1028: LIST
1029: PUSH
1030: LD_INT 13
1032: PUSH
1033: LD_INT 3
1035: PUSH
1036: LD_INT 2
1038: PUSH
1039: LD_INT 32
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PPUSH
1053: CALL 57811 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: PPUSH
1070: CALL 58553 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1074: LD_INT 4
1076: PPUSH
1077: LD_INT 9
1079: PUSH
1080: EMPTY
1081: LIST
1082: PPUSH
1083: CALL 58646 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1087: LD_INT 4
1089: PPUSH
1090: LD_INT 26
1092: PUSH
1093: LD_INT 74
1095: PUSH
1096: LD_INT 107
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 32
1110: PUSH
1111: LD_INT 77
1113: PUSH
1114: LD_INT 101
1116: PUSH
1117: LD_INT 4
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 32
1128: PUSH
1129: LD_INT 69
1131: PUSH
1132: LD_INT 86
1134: PUSH
1135: LD_INT 4
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 27
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 110
1152: PUSH
1153: LD_INT 3
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 42
1167: PUSH
1168: LD_INT 79
1170: PUSH
1171: LD_INT 5
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 29
1182: PUSH
1183: LD_INT 86
1185: PUSH
1186: LD_INT 105
1188: PUSH
1189: LD_INT 2
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 40
1203: PUSH
1204: LD_INT 75
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 80
1221: PUSH
1222: LD_INT 106
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 32
1236: PUSH
1237: LD_INT 75
1239: PUSH
1240: LD_INT 114
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 82
1257: PUSH
1258: LD_INT 110
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 62
1275: PUSH
1276: LD_INT 78
1278: PUSH
1279: LD_INT 4
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 4
1290: PUSH
1291: LD_INT 39
1293: PUSH
1294: LD_INT 61
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL 57703 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1324: LD_INT 4
1326: PPUSH
1327: LD_INT 5
1329: PUSH
1330: LD_INT 6
1332: PUSH
1333: LD_INT 7
1335: PUSH
1336: LD_INT 9
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 58964 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 58135 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 58426 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 58426 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 58758 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 57811 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 58377 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$1 trigger debug do var i , tmp ;
1542: LD_EXP 1
1546: IFFALSE 1653
1548: GO 1550
1550: DISABLE
1551: LD_INT 0
1553: PPUSH
1554: PPUSH
// begin enable ;
1555: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1556: LD_ADDR_VAR 0 2
1560: PUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: LD_INT 3
1573: PUSH
1574: LD_INT 21
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: PUSH
1588: LD_INT 3
1590: PUSH
1591: LD_INT 24
1593: PUSH
1594: LD_INT 999
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: LIST
1609: PPUSH
1610: CALL_OW 69
1614: ST_TO_ADDR
// if not tmp then
1615: LD_VAR 0 2
1619: NOT
1620: IFFALSE 1624
// exit ;
1622: GO 1653
// for i in tmp do
1624: LD_ADDR_VAR 0 1
1628: PUSH
1629: LD_VAR 0 2
1633: PUSH
1634: FOR_IN
1635: IFFALSE 1651
// SetLives ( i , 1000 ) ;
1637: LD_VAR 0 1
1641: PPUSH
1642: LD_INT 1000
1644: PPUSH
1645: CALL_OW 234
1649: GO 1634
1651: POP
1652: POP
// end ;
1653: PPOPN 2
1655: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1656: LD_EXP 36
1660: PUSH
1661: LD_EXP 17
1665: PUSH
1666: LD_INT 2
1668: GREATEREQUAL
1669: AND
1670: IFFALSE 1682
1672: GO 1674
1674: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1675: LD_STRING ACH_POWELL
1677: PPUSH
1678: CALL_OW 543
1682: END
// every 0 0$1 trigger allianceDestroyed and not capturedUnit do
1683: LD_EXP 23
1687: PUSH
1688: LD_EXP 34
1692: NOT
1693: AND
1694: IFFALSE 1706
1696: GO 1698
1698: DISABLE
// SetAchievement ( ACH_ALLIANCE ) ; end_of_file
1699: LD_STRING ACH_ALLIANCE
1701: PPUSH
1702: CALL_OW 543
1706: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1707: LD_INT 0
1709: PPUSH
// uc_side := 1 ;
1710: LD_ADDR_OWVAR 20
1714: PUSH
1715: LD_INT 1
1717: ST_TO_ADDR
// uc_nation := 1 ;
1718: LD_ADDR_OWVAR 21
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1726: LD_ADDR_EXP 38
1730: PUSH
1731: LD_STRING JMM
1733: PPUSH
1734: LD_EXP 1
1738: NOT
1739: PPUSH
1740: LD_STRING 14_
1742: PPUSH
1743: CALL 64203 0 3
1747: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1748: LD_EXP 4
1752: NOT
1753: PUSH
1754: LD_EXP 4
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PUSH
1763: LD_INT 1
1765: ARRAY
1766: NOT
1767: OR
1768: IFFALSE 1791
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 1
1778: PPUSH
1779: LD_INT 5
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 71318 0 5
1789: GO 1850
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1791: LD_EXP 4
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PUSH
1800: LD_INT 1
1802: ARRAY
1803: PPUSH
1804: LD_EXP 4
1808: PUSH
1809: LD_INT 2
1811: ARRAY
1812: PUSH
1813: LD_INT 1
1815: ARRAY
1816: PPUSH
1817: LD_EXP 4
1821: PUSH
1822: LD_INT 3
1824: ARRAY
1825: PUSH
1826: LD_INT 1
1828: ARRAY
1829: PPUSH
1830: LD_EXP 4
1834: PUSH
1835: LD_INT 4
1837: ARRAY
1838: PUSH
1839: LD_INT 1
1841: ARRAY
1842: PPUSH
1843: LD_INT 30
1845: PPUSH
1846: CALL 71318 0 5
// JMMNewVeh := CreateVehicle ;
1850: LD_ADDR_EXP 55
1854: PUSH
1855: CALL_OW 45
1859: ST_TO_ADDR
// if not JMMNewVeh then
1860: LD_EXP 55
1864: NOT
1865: IFFALSE 1896
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1867: LD_INT 3
1869: PPUSH
1870: LD_INT 3
1872: PPUSH
1873: LD_INT 1
1875: PPUSH
1876: LD_INT 5
1878: PPUSH
1879: LD_INT 100
1881: PPUSH
1882: CALL 71318 0 5
// JMMNewVeh := CreateVehicle ;
1886: LD_ADDR_EXP 55
1890: PUSH
1891: CALL_OW 45
1895: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1896: LD_EXP 55
1900: PPUSH
1901: LD_INT 4
1903: PPUSH
1904: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1908: LD_EXP 55
1912: PPUSH
1913: LD_INT 79
1915: PPUSH
1916: LD_INT 91
1918: PPUSH
1919: LD_INT 0
1921: PPUSH
1922: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1926: LD_EXP 38
1930: PPUSH
1931: LD_EXP 55
1935: PPUSH
1936: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1940: LD_EXP 6
1944: PUSH
1945: LD_EXP 2
1949: NOT
1950: AND
1951: IFFALSE 2209
// begin if not JMMGirlVeh then
1953: LD_EXP 5
1957: NOT
1958: IFFALSE 1981
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1960: LD_INT 3
1962: PPUSH
1963: LD_INT 3
1965: PPUSH
1966: LD_INT 1
1968: PPUSH
1969: LD_INT 9
1971: PPUSH
1972: LD_INT 100
1974: PPUSH
1975: CALL 71318 0 5
1979: GO 2040
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1981: LD_EXP 5
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: LD_EXP 5
1998: PUSH
1999: LD_INT 2
2001: ARRAY
2002: PUSH
2003: LD_INT 1
2005: ARRAY
2006: PPUSH
2007: LD_EXP 5
2011: PUSH
2012: LD_INT 3
2014: ARRAY
2015: PUSH
2016: LD_INT 1
2018: ARRAY
2019: PPUSH
2020: LD_EXP 5
2024: PUSH
2025: LD_INT 4
2027: ARRAY
2028: PUSH
2029: LD_INT 1
2031: ARRAY
2032: PPUSH
2033: LD_INT 30
2035: PPUSH
2036: CALL 71318 0 5
// GirlNewVeh := CreateVehicle ;
2040: LD_ADDR_EXP 56
2044: PUSH
2045: CALL_OW 45
2049: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2050: LD_EXP 56
2054: PPUSH
2055: LD_INT 4
2057: PPUSH
2058: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2062: LD_EXP 56
2066: PPUSH
2067: LD_INT 82
2069: PPUSH
2070: LD_INT 96
2072: PPUSH
2073: LD_INT 0
2075: PPUSH
2076: CALL_OW 48
// if JMMGirl = 1 then
2080: LD_EXP 7
2084: PUSH
2085: LD_INT 1
2087: EQUAL
2088: IFFALSE 2123
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2090: LD_ADDR_EXP 39
2094: PUSH
2095: LD_STRING Joan
2097: PPUSH
2098: LD_INT 1
2100: PPUSH
2101: LD_STRING 14_
2103: PPUSH
2104: CALL 64203 0 3
2108: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2109: LD_EXP 39
2113: PPUSH
2114: LD_EXP 56
2118: PPUSH
2119: CALL_OW 52
// end ; if JMMGirl = 2 then
2123: LD_EXP 7
2127: PUSH
2128: LD_INT 2
2130: EQUAL
2131: IFFALSE 2166
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2133: LD_ADDR_EXP 41
2137: PUSH
2138: LD_STRING Lisa
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: LD_STRING 14_
2146: PPUSH
2147: CALL 64203 0 3
2151: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2152: LD_EXP 41
2156: PPUSH
2157: LD_EXP 56
2161: PPUSH
2162: CALL_OW 52
// end ; if JMMGirl = 3 then
2166: LD_EXP 7
2170: PUSH
2171: LD_INT 3
2173: EQUAL
2174: IFFALSE 2209
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2176: LD_ADDR_EXP 53
2180: PUSH
2181: LD_STRING Connie
2183: PPUSH
2184: LD_INT 1
2186: PPUSH
2187: LD_STRING 14_
2189: PPUSH
2190: CALL 64203 0 3
2194: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2195: LD_EXP 53
2199: PPUSH
2200: LD_EXP 56
2204: PPUSH
2205: CALL_OW 52
// end ; end ; end ;
2209: LD_VAR 0 1
2213: RET
// export function PrepareStevensSquad ; var tmp ; begin
2214: LD_INT 0
2216: PPUSH
2217: PPUSH
// uc_side := 1 ;
2218: LD_ADDR_OWVAR 20
2222: PUSH
2223: LD_INT 1
2225: ST_TO_ADDR
// uc_nation := 1 ;
2226: LD_ADDR_OWVAR 21
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// tmp := [ ] ;
2234: LD_ADDR_VAR 0 2
2238: PUSH
2239: EMPTY
2240: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2241: LD_ADDR_EXP 40
2245: PUSH
2246: LD_STRING Stevens
2248: PPUSH
2249: LD_EXP 1
2253: NOT
2254: PPUSH
2255: LD_STRING 13f_
2257: PPUSH
2258: CALL 64203 0 3
2262: ST_TO_ADDR
// if not Stevens then
2263: LD_EXP 40
2267: NOT
2268: IFFALSE 2324
// begin hc_name = Baker Smith ;
2270: LD_ADDR_OWVAR 26
2274: PUSH
2275: LD_STRING Baker Smith
2277: ST_TO_ADDR
// hc_gallery =  ;
2278: LD_ADDR_OWVAR 33
2282: PUSH
2283: LD_STRING 
2285: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2286: LD_INT 1
2288: PPUSH
2289: LD_INT 10
2291: PPUSH
2292: CALL_OW 384
// Baker = CreateHuman ;
2296: LD_ADDR_EXP 54
2300: PUSH
2301: CALL_OW 44
2305: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2306: LD_ADDR_VAR 0 2
2310: PUSH
2311: LD_VAR 0 2
2315: PUSH
2316: LD_EXP 54
2320: ADD
2321: ST_TO_ADDR
// end else
2322: GO 2340
// tmp := tmp ^ Stevens ;
2324: LD_ADDR_VAR 0 2
2328: PUSH
2329: LD_VAR 0 2
2333: PUSH
2334: LD_EXP 40
2338: ADD
2339: ST_TO_ADDR
// if not Lisa then
2340: LD_EXP 41
2344: NOT
2345: IFFALSE 2391
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2347: LD_ADDR_EXP 41
2351: PUSH
2352: LD_STRING Lisa
2354: PPUSH
2355: LD_EXP 1
2359: NOT
2360: PPUSH
2361: LD_STRING 13f_
2363: PPUSH
2364: CALL 64203 0 3
2368: ST_TO_ADDR
// if Lisa then
2369: LD_EXP 41
2373: IFFALSE 2391
// tmp := tmp ^ Lisa ;
2375: LD_ADDR_VAR 0 2
2379: PUSH
2380: LD_VAR 0 2
2384: PUSH
2385: LD_EXP 41
2389: ADD
2390: ST_TO_ADDR
// end ; if not Donaldson then
2391: LD_EXP 42
2395: NOT
2396: IFFALSE 2442
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2398: LD_ADDR_EXP 42
2402: PUSH
2403: LD_STRING Donaldson
2405: PPUSH
2406: LD_EXP 1
2410: NOT
2411: PPUSH
2412: LD_STRING 13f_
2414: PPUSH
2415: CALL 64203 0 3
2419: ST_TO_ADDR
// if Donaldson then
2420: LD_EXP 42
2424: IFFALSE 2442
// tmp := tmp ^ Donaldson ;
2426: LD_ADDR_VAR 0 2
2430: PUSH
2431: LD_VAR 0 2
2435: PUSH
2436: LD_EXP 42
2440: ADD
2441: ST_TO_ADDR
// end ; if not Bobby then
2442: LD_EXP 43
2446: NOT
2447: IFFALSE 2493
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2449: LD_ADDR_EXP 43
2453: PUSH
2454: LD_STRING Bobby
2456: PPUSH
2457: LD_EXP 1
2461: NOT
2462: PPUSH
2463: LD_STRING 13f_
2465: PPUSH
2466: CALL 64203 0 3
2470: ST_TO_ADDR
// if Bobby then
2471: LD_EXP 43
2475: IFFALSE 2493
// tmp := tmp ^ Bobby ;
2477: LD_ADDR_VAR 0 2
2481: PUSH
2482: LD_VAR 0 2
2486: PUSH
2487: LD_EXP 43
2491: ADD
2492: ST_TO_ADDR
// end ; if not Cyrus then
2493: LD_EXP 44
2497: NOT
2498: IFFALSE 2544
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2500: LD_ADDR_EXP 44
2504: PUSH
2505: LD_STRING Cyrus
2507: PPUSH
2508: LD_EXP 1
2512: NOT
2513: PPUSH
2514: LD_STRING 13f_
2516: PPUSH
2517: CALL 64203 0 3
2521: ST_TO_ADDR
// if Cyrus then
2522: LD_EXP 44
2526: IFFALSE 2544
// tmp := tmp ^ Cyrus ;
2528: LD_ADDR_VAR 0 2
2532: PUSH
2533: LD_VAR 0 2
2537: PUSH
2538: LD_EXP 44
2542: ADD
2543: ST_TO_ADDR
// end ; if not Brown then
2544: LD_EXP 46
2548: NOT
2549: IFFALSE 2595
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2551: LD_ADDR_EXP 46
2555: PUSH
2556: LD_STRING Brown
2558: PPUSH
2559: LD_EXP 1
2563: NOT
2564: PPUSH
2565: LD_STRING 13f_
2567: PPUSH
2568: CALL 64203 0 3
2572: ST_TO_ADDR
// if Brown then
2573: LD_EXP 46
2577: IFFALSE 2595
// tmp := tmp ^ Brown ;
2579: LD_ADDR_VAR 0 2
2583: PUSH
2584: LD_VAR 0 2
2588: PUSH
2589: LD_EXP 46
2593: ADD
2594: ST_TO_ADDR
// end ; if not Gladstone then
2595: LD_EXP 47
2599: NOT
2600: IFFALSE 2646
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2602: LD_ADDR_EXP 47
2606: PUSH
2607: LD_STRING Gladstone
2609: PPUSH
2610: LD_EXP 1
2614: NOT
2615: PPUSH
2616: LD_STRING 13f_
2618: PPUSH
2619: CALL 64203 0 3
2623: ST_TO_ADDR
// if Gladstone then
2624: LD_EXP 47
2628: IFFALSE 2646
// tmp := tmp ^ Gladstone ;
2630: LD_ADDR_VAR 0 2
2634: PUSH
2635: LD_VAR 0 2
2639: PUSH
2640: LD_EXP 47
2644: ADD
2645: ST_TO_ADDR
// end ; if not Houten then
2646: LD_EXP 48
2650: NOT
2651: IFFALSE 2697
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2653: LD_ADDR_EXP 48
2657: PUSH
2658: LD_STRING Houten
2660: PPUSH
2661: LD_EXP 1
2665: NOT
2666: PPUSH
2667: LD_STRING 13f_
2669: PPUSH
2670: CALL 64203 0 3
2674: ST_TO_ADDR
// if Houten then
2675: LD_EXP 48
2679: IFFALSE 2697
// tmp := tmp ^ Houten ;
2681: LD_ADDR_VAR 0 2
2685: PUSH
2686: LD_VAR 0 2
2690: PUSH
2691: LD_EXP 48
2695: ADD
2696: ST_TO_ADDR
// end ; if not Cornel then
2697: LD_EXP 49
2701: NOT
2702: IFFALSE 2748
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2704: LD_ADDR_EXP 49
2708: PUSH
2709: LD_STRING Cornel
2711: PPUSH
2712: LD_EXP 1
2716: NOT
2717: PPUSH
2718: LD_STRING 13f_
2720: PPUSH
2721: CALL 64203 0 3
2725: ST_TO_ADDR
// if Cornel then
2726: LD_EXP 49
2730: IFFALSE 2748
// tmp := tmp ^ Cornel ;
2732: LD_ADDR_VAR 0 2
2736: PUSH
2737: LD_VAR 0 2
2741: PUSH
2742: LD_EXP 49
2746: ADD
2747: ST_TO_ADDR
// end ; if not Gary then
2748: LD_EXP 50
2752: NOT
2753: IFFALSE 2799
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2755: LD_ADDR_EXP 50
2759: PUSH
2760: LD_STRING Gary
2762: PPUSH
2763: LD_EXP 1
2767: NOT
2768: PPUSH
2769: LD_STRING 13f_
2771: PPUSH
2772: CALL 64203 0 3
2776: ST_TO_ADDR
// if Gary then
2777: LD_EXP 50
2781: IFFALSE 2799
// tmp := tmp ^ Gary ;
2783: LD_ADDR_VAR 0 2
2787: PUSH
2788: LD_VAR 0 2
2792: PUSH
2793: LD_EXP 50
2797: ADD
2798: ST_TO_ADDR
// end ; if not Frank then
2799: LD_EXP 51
2803: NOT
2804: IFFALSE 2850
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2806: LD_ADDR_EXP 51
2810: PUSH
2811: LD_STRING Frank
2813: PPUSH
2814: LD_EXP 1
2818: NOT
2819: PPUSH
2820: LD_STRING 13f_
2822: PPUSH
2823: CALL 64203 0 3
2827: ST_TO_ADDR
// if Frank then
2828: LD_EXP 51
2832: IFFALSE 2850
// tmp := tmp ^ Frank ;
2834: LD_ADDR_VAR 0 2
2838: PUSH
2839: LD_VAR 0 2
2843: PUSH
2844: LD_EXP 51
2848: ADD
2849: ST_TO_ADDR
// end ; if not Kikuchi then
2850: LD_EXP 52
2854: NOT
2855: IFFALSE 2901
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2857: LD_ADDR_EXP 52
2861: PUSH
2862: LD_STRING Kikuchi
2864: PPUSH
2865: LD_EXP 1
2869: NOT
2870: PPUSH
2871: LD_STRING 13f_
2873: PPUSH
2874: CALL 64203 0 3
2878: ST_TO_ADDR
// if Kikuchi then
2879: LD_EXP 52
2883: IFFALSE 2901
// tmp := tmp ^ Kikuchi ;
2885: LD_ADDR_VAR 0 2
2889: PUSH
2890: LD_VAR 0 2
2894: PUSH
2895: LD_EXP 52
2899: ADD
2900: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2901: LD_ADDR_VAR 0 2
2905: PUSH
2906: LD_VAR 0 2
2910: PUSH
2911: LD_STRING 13_other_survivors
2913: PPUSH
2914: CALL_OW 31
2918: UNION
2919: ST_TO_ADDR
// result := tmp ;
2920: LD_ADDR_VAR 0 1
2924: PUSH
2925: LD_VAR 0 2
2929: ST_TO_ADDR
// end ; end_of_file
2930: LD_VAR 0 1
2934: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2935: LD_INT 0
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
2942: PPUSH
2943: PPUSH
2944: PPUSH
2945: PPUSH
2946: PPUSH
// uc_side := 4 ;
2947: LD_ADDR_OWVAR 20
2951: PUSH
2952: LD_INT 4
2954: ST_TO_ADDR
// uc_nation := 1 ;
2955: LD_ADDR_OWVAR 21
2959: PUSH
2960: LD_INT 1
2962: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2963: LD_INT 387
2965: PPUSH
2966: CALL_OW 274
2970: PPUSH
2971: LD_INT 1
2973: PPUSH
2974: LD_INT 2500
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 57
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 57
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 57
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 58
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 41
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 64203 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 41
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 41
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 42
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 64203 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 42
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 42
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 43
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 64203 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 43
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 43
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 44
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 64203 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 44
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 44
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 45
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 64203 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 45
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 45
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 64203 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 45
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 45
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 46
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 64203 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 46
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 46
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 47
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 64203 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 47
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 47
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 48
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 64203 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 48
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 48
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 49
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 64203 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 49
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 49
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 50
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 64203 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 50
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 50
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 51
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 64203 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 51
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 51
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 52
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 64203 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 52
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 52
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 58
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 20 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 20
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 20 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 20
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 71318 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 59
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64203 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 59
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 64203 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 59
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 59
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 59
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 60
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 64203 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 60
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 60
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4448: LD_ADDR_VAR 0 5
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_VAR 0 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 30
4467: PUSH
4468: LD_INT 32
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 58
4477: PUSH
4478: EMPTY
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// for i = 1 to 10 do
4491: LD_ADDR_VAR 0 2
4495: PUSH
4496: DOUBLE
4497: LD_INT 1
4499: DEC
4500: ST_TO_ADDR
4501: LD_INT 10
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4577
// begin uc_nation := nation_nature ;
4507: LD_ADDR_OWVAR 21
4511: PUSH
4512: LD_INT 0
4514: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4515: LD_ADDR_OWVAR 28
4519: PUSH
4520: LD_INT 15
4522: ST_TO_ADDR
// hc_gallery :=  ;
4523: LD_ADDR_OWVAR 33
4527: PUSH
4528: LD_STRING 
4530: ST_TO_ADDR
// hc_name :=  ;
4531: LD_ADDR_OWVAR 26
4535: PUSH
4536: LD_STRING 
4538: ST_TO_ADDR
// un := CreateHuman ;
4539: LD_ADDR_VAR 0 4
4543: PUSH
4544: CALL_OW 44
4548: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4549: LD_VAR 0 4
4553: PPUSH
4554: LD_VAR 0 5
4558: PUSH
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: MINUS
4569: ARRAY
4570: PPUSH
4571: CALL_OW 52
// end ;
4575: GO 4504
4577: POP
4578: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4579: LD_ADDR_VAR 0 5
4583: PUSH
4584: LD_STRING 12_kurt_squad
4586: PPUSH
4587: CALL_OW 31
4591: ST_TO_ADDR
// if tmp then
4592: LD_VAR 0 5
4596: IFFALSE 4630
// for i in tmp do
4598: LD_ADDR_VAR 0 2
4602: PUSH
4603: LD_VAR 0 5
4607: PUSH
4608: FOR_IN
4609: IFFALSE 4628
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4611: LD_VAR 0 2
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_INT 0
4621: PPUSH
4622: CALL_OW 49
4626: GO 4608
4628: POP
4629: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4630: LD_INT 324
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_STRING 
4638: PPUSH
4639: LD_INT 8
4641: PUSH
4642: LD_INT 9
4644: PUSH
4645: LD_INT 10
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: LIST
4652: PUSH
4653: LD_OWVAR 67
4657: ARRAY
4658: PPUSH
4659: LD_INT 3000
4661: PUSH
4662: LD_INT 500
4664: PUSH
4665: LD_INT 150
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: PPUSH
4673: LD_INT 16
4675: PUSH
4676: LD_INT 6
4678: PUSH
4679: LD_INT 6
4681: PUSH
4682: LD_INT 8
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL 74727 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4695: LD_ADDR_EXP 101
4699: PUSH
4700: LD_EXP 101
4704: PPUSH
4705: LD_INT 3
4707: PPUSH
4708: LD_INT 22
4710: PUSH
4711: LD_VAR 0 3
4715: PUSH
4716: EMPTY
4717: LIST
4718: LIST
4719: PUSH
4720: LD_INT 23
4722: PUSH
4723: LD_INT 2
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 3
4732: PUSH
4733: LD_INT 21
4735: PUSH
4736: LD_INT 2
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: PPUSH
4752: CALL_OW 69
4756: PUSH
4757: LD_EXP 59
4761: DIFF
4762: PPUSH
4763: CALL_OW 1
4767: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4768: LD_INT 1
4770: PPUSH
4771: LD_INT 7
4773: PPUSH
4774: CALL_OW 383
// Friend := CreateHuman ;
4778: LD_ADDR_EXP 61
4782: PUSH
4783: CALL_OW 44
4787: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4788: LD_INT 14
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 29
4799: PPUSH
4800: LD_INT 100
4802: PPUSH
4803: CALL 71318 0 5
// powellBomb := CreateVehicle ;
4807: LD_ADDR_EXP 62
4811: PUSH
4812: CALL_OW 45
4816: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4817: LD_EXP 62
4821: PPUSH
4822: LD_INT 90
4824: PPUSH
4825: LD_INT 51
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 48
// end ;
4835: LD_VAR 0 1
4839: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4840: LD_INT 0
4842: PPUSH
4843: PPUSH
4844: PPUSH
// if IsLive ( kozlov_fac ) then
4845: LD_INT 332
4847: PPUSH
4848: CALL_OW 300
4852: IFFALSE 4856
// exit ;
4854: GO 5423
// ComExitBuilding ( Kozlov ) ;
4856: LD_EXP 60
4860: PPUSH
4861: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4865: LD_EXP 60
4869: PPUSH
4870: CALL_OW 257
4874: PUSH
4875: LD_INT 2
4877: NONEQUAL
4878: IFFALSE 4913
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4880: LD_EXP 60
4884: PPUSH
4885: LD_INT 324
4887: PPUSH
4888: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4892: LD_EXP 60
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4904: LD_EXP 60
4908: PPUSH
4909: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4913: LD_EXP 60
4917: PPUSH
4918: LD_INT 2
4920: PPUSH
4921: LD_INT 93
4923: PPUSH
4924: LD_INT 32
4926: PPUSH
4927: LD_INT 3
4929: PPUSH
4930: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4934: LD_INT 35
4936: PPUSH
4937: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4941: LD_INT 22
4943: PUSH
4944: LD_INT 8
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: LD_INT 30
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: LD_INT 23
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: PUSH
4971: LD_INT 57
4973: PUSH
4974: EMPTY
4975: LIST
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: PPUSH
4983: CALL_OW 69
4987: IFFALSE 4934
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: LD_INT 22
4996: PUSH
4997: LD_INT 8
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 30
5006: PUSH
5007: LD_INT 3
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: LD_INT 23
5016: PUSH
5017: LD_INT 3
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: PUSH
5024: LD_INT 57
5026: PUSH
5027: EMPTY
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 69
5040: PUSH
5041: LD_INT 1
5043: ARRAY
5044: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5045: LD_INT 22
5047: PUSH
5048: LD_INT 8
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: PUSH
5055: LD_INT 23
5057: PUSH
5058: LD_INT 3
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 21
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: PPUSH
5080: CALL_OW 69
5084: NOT
5085: IFFALSE 5163
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5087: LD_EXP 60
5091: PPUSH
5092: LD_INT 21
5094: PPUSH
5095: LD_INT 97
5097: PPUSH
5098: LD_INT 36
5100: PPUSH
5101: LD_INT 5
5103: PPUSH
5104: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5108: LD_INT 35
5110: PPUSH
5111: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5115: LD_INT 22
5117: PUSH
5118: LD_INT 8
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 23
5127: PUSH
5128: LD_INT 3
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 30
5137: PUSH
5138: LD_INT 21
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 57
5147: PUSH
5148: EMPTY
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: PPUSH
5157: CALL_OW 69
5161: IFFALSE 5108
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5163: LD_INT 22
5165: PUSH
5166: LD_INT 8
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 23
5175: PUSH
5176: LD_INT 3
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: LD_INT 30
5185: PUSH
5186: LD_INT 18
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: NOT
5203: IFFALSE 5281
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5205: LD_EXP 60
5209: PPUSH
5210: LD_INT 18
5212: PPUSH
5213: LD_INT 89
5215: PPUSH
5216: LD_INT 32
5218: PPUSH
5219: LD_INT 1
5221: PPUSH
5222: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5226: LD_INT 35
5228: PPUSH
5229: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5233: LD_INT 22
5235: PUSH
5236: LD_INT 8
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: PUSH
5243: LD_INT 23
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 30
5255: PUSH
5256: LD_INT 18
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 57
5265: PUSH
5266: EMPTY
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: LIST
5274: PPUSH
5275: CALL_OW 69
5279: IFFALSE 5226
// end ; lab := kozlov_lab ;
5281: LD_ADDR_VAR 0 3
5285: PUSH
5286: LD_INT 336
5288: ST_TO_ADDR
// if not lab then
5289: LD_VAR 0 3
5293: NOT
5294: IFFALSE 5298
// exit ;
5296: GO 5423
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5298: LD_EXP 60
5302: PPUSH
5303: LD_VAR 0 3
5307: PUSH
5308: LD_INT 1
5310: ARRAY
5311: PPUSH
5312: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5316: LD_EXP 60
5320: PPUSH
5321: LD_INT 4
5323: PPUSH
5324: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5328: LD_VAR 0 3
5332: PUSH
5333: LD_INT 1
5335: ARRAY
5336: PPUSH
5337: LD_INT 25
5339: PPUSH
5340: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5344: LD_INT 35
5346: PPUSH
5347: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5351: LD_INT 25
5353: PPUSH
5354: LD_INT 8
5356: PPUSH
5357: CALL_OW 321
5361: PUSH
5362: LD_INT 2
5364: EQUAL
5365: IFFALSE 5344
// ComExitBuilding ( Kozlov ) ;
5367: LD_EXP 60
5371: PPUSH
5372: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5376: LD_EXP 60
5380: PPUSH
5381: LD_VAR 0 2
5385: PPUSH
5386: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5390: LD_EXP 60
5394: PPUSH
5395: LD_INT 3
5397: PPUSH
5398: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_INT 23
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: LD_INT 1
5415: PPUSH
5416: LD_INT 48
5418: PPUSH
5419: CALL_OW 125
// end ;
5423: LD_VAR 0 1
5427: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5428: LD_EXP 22
5432: NOT
5433: PUSH
5434: LD_EXP 15
5438: PUSH
5439: LD_INT 6
5441: GREATEREQUAL
5442: AND
5443: IFFALSE 5524
5445: GO 5447
5447: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5448: LD_INT 3
5450: PPUSH
5451: LD_INT 3
5453: PPUSH
5454: CALL 57996 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5458: LD_INT 3
5460: PPUSH
5461: LD_INT 14
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 28
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 14
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 28
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 14
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 28
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL 57859 0 2
// end ;
5524: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5525: LD_EXP 22
5529: NOT
5530: PUSH
5531: LD_EXP 15
5535: PUSH
5536: LD_INT 6
5538: GREATEREQUAL
5539: AND
5540: PUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_INT 1
5546: PPUSH
5547: CALL 59277 0 2
5551: NOT
5552: AND
5553: IFFALSE 6393
5555: GO 5557
5557: DISABLE
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5564: LD_INT 22
5566: PUSH
5567: LD_INT 8
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: LD_INT 23
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 30
5586: PUSH
5587: LD_INT 3
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: LIST
5598: PPUSH
5599: CALL_OW 69
5603: NOT
5604: IFFALSE 5608
// exit ;
5606: GO 6393
// if Prob ( 40 ) then
5608: LD_INT 40
5610: PPUSH
5611: CALL_OW 13
5615: IFFALSE 5742
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5617: LD_INT 3
5619: PPUSH
5620: LD_INT 14
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 2
5628: PUSH
5629: LD_INT 28
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: PUSH
5638: LD_INT 14
5640: PUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 2
5646: PUSH
5647: LD_INT 28
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 14
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: LD_INT 2
5664: PUSH
5665: LD_INT 28
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: PUSH
5674: LD_INT 14
5676: PUSH
5677: LD_INT 1
5679: PUSH
5680: LD_INT 2
5682: PUSH
5683: LD_INT 28
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 14
5694: PUSH
5695: LD_INT 1
5697: PUSH
5698: LD_INT 2
5700: PUSH
5701: LD_INT 28
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_INT 14
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 26
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL 57859 0 2
// end else
5740: GO 5933
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 14
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: LD_INT 2
5753: PUSH
5754: LD_INT 27
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_OWVAR 67
5772: ARRAY
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 14
5782: PUSH
5783: LD_INT 1
5785: PUSH
5786: LD_INT 2
5788: PUSH
5789: LD_INT 27
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 26
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 14
5817: PUSH
5818: LD_INT 1
5820: PUSH
5821: LD_INT 2
5823: PUSH
5824: LD_INT 26
5826: PUSH
5827: LD_INT 26
5829: PUSH
5830: LD_INT 29
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: LIST
5837: PUSH
5838: LD_OWVAR 67
5842: ARRAY
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 13
5852: PUSH
5853: LD_INT 1
5855: PUSH
5856: LD_INT 2
5858: PUSH
5859: LD_INT 26
5861: PUSH
5862: LD_INT 29
5864: PUSH
5865: LD_INT 29
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: LD_OWVAR 67
5877: ARRAY
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 13
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: LD_INT 2
5893: PUSH
5894: LD_INT 29
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: PPUSH
5929: CALL 57859 0 2
// end ; repeat wait ( 0 0$1 ) ;
5933: LD_INT 35
5935: PPUSH
5936: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5940: LD_INT 3
5942: PPUSH
5943: LD_INT 1
5945: PPUSH
5946: CALL 59277 0 2
5950: PUSH
5951: LD_INT 6
5953: GREATEREQUAL
5954: IFFALSE 5933
// wait ( 0 0$30 ) ;
5956: LD_INT 1050
5958: PPUSH
5959: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5963: LD_ADDR_VAR 0 2
5967: PUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: CALL 59277 0 2
5978: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5979: LD_ADDR_EXP 120
5983: PUSH
5984: LD_EXP 120
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: LD_EXP 120
5996: PUSH
5997: LD_INT 3
5999: ARRAY
6000: PUSH
6001: LD_VAR 0 2
6005: DIFF
6006: PPUSH
6007: CALL_OW 1
6011: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6012: LD_ADDR_VAR 0 3
6016: PUSH
6017: LD_INT 0
6019: PPUSH
6020: LD_INT 2
6022: PPUSH
6023: CALL_OW 12
6027: ST_TO_ADDR
// if target then
6028: LD_VAR 0 3
6032: IFFALSE 6160
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6034: LD_ADDR_VAR 0 2
6038: PUSH
6039: LD_VAR 0 2
6043: PPUSH
6044: LD_INT 24
6046: PUSH
6047: LD_INT 250
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PPUSH
6054: CALL_OW 72
6058: ST_TO_ADDR
// for i in tmp do
6059: LD_ADDR_VAR 0 1
6063: PUSH
6064: LD_VAR 0 2
6068: PUSH
6069: FOR_IN
6070: IFFALSE 6110
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_INT 89
6079: PPUSH
6080: LD_INT 71
6082: PPUSH
6083: CALL_OW 297
6087: PUSH
6088: LD_INT 9
6090: GREATER
6091: IFFALSE 6108
// ComMoveXY ( i , 89 , 71 ) ;
6093: LD_VAR 0 1
6097: PPUSH
6098: LD_INT 89
6100: PPUSH
6101: LD_INT 71
6103: PPUSH
6104: CALL_OW 111
6108: GO 6069
6110: POP
6111: POP
// wait ( 0 0$1 ) ;
6112: LD_INT 35
6114: PPUSH
6115: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6119: LD_VAR 0 2
6123: PPUSH
6124: LD_INT 92
6126: PUSH
6127: LD_INT 89
6129: PUSH
6130: LD_INT 71
6132: PUSH
6133: LD_INT 9
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 72
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_INT 1
6154: MINUS
6155: GREATEREQUAL
6156: IFFALSE 6034
// end else
6158: GO 6284
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_VAR 0 2
6169: PPUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 250
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PPUSH
6180: CALL_OW 72
6184: ST_TO_ADDR
// for i in tmp do
6185: LD_ADDR_VAR 0 1
6189: PUSH
6190: LD_VAR 0 2
6194: PUSH
6195: FOR_IN
6196: IFFALSE 6236
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 125
6205: PPUSH
6206: LD_INT 129
6208: PPUSH
6209: CALL_OW 297
6213: PUSH
6214: LD_INT 9
6216: GREATER
6217: IFFALSE 6234
// ComMoveXY ( i , 125 , 129 ) ;
6219: LD_VAR 0 1
6223: PPUSH
6224: LD_INT 125
6226: PPUSH
6227: LD_INT 129
6229: PPUSH
6230: CALL_OW 111
6234: GO 6195
6236: POP
6237: POP
// wait ( 0 0$1 ) ;
6238: LD_INT 35
6240: PPUSH
6241: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6245: LD_VAR 0 2
6249: PPUSH
6250: LD_INT 92
6252: PUSH
6253: LD_INT 125
6255: PUSH
6256: LD_INT 129
6258: PUSH
6259: LD_INT 9
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PPUSH
6268: CALL_OW 72
6272: PUSH
6273: LD_VAR 0 2
6277: PUSH
6278: LD_INT 1
6280: MINUS
6281: GREATEREQUAL
6282: IFFALSE 6160
// end ; repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// for i in tmp do
6291: LD_ADDR_VAR 0 1
6295: PUSH
6296: LD_VAR 0 2
6300: PUSH
6301: FOR_IN
6302: IFFALSE 6384
// begin if GetLives ( i ) > 251 then
6304: LD_VAR 0 1
6308: PPUSH
6309: CALL_OW 256
6313: PUSH
6314: LD_INT 251
6316: GREATER
6317: IFFALSE 6355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6319: LD_VAR 0 1
6323: PPUSH
6324: LD_INT 81
6326: PUSH
6327: LD_INT 8
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL_OW 69
6338: PPUSH
6339: LD_VAR 0 1
6343: PPUSH
6344: CALL_OW 74
6348: PPUSH
6349: CALL_OW 115
6353: GO 6382
// if IsDead ( i ) then
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL_OW 301
6364: IFFALSE 6382
// tmp := tmp diff i ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_VAR 0 2
6375: PUSH
6376: LD_VAR 0 1
6380: DIFF
6381: ST_TO_ADDR
// end ;
6382: GO 6301
6384: POP
6385: POP
// until not tmp ;
6386: LD_VAR 0 2
6390: NOT
6391: IFFALSE 6284
// end ;
6393: PPOPN 3
6395: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6396: LD_EXP 22
6400: NOT
6401: PUSH
6402: LD_EXP 15
6406: PUSH
6407: LD_INT 6
6409: GREATEREQUAL
6410: AND
6411: PUSH
6412: LD_OWVAR 67
6416: PUSH
6417: LD_INT 1
6419: GREATER
6420: AND
6421: IFFALSE 6938
6423: GO 6425
6425: DISABLE
6426: LD_INT 0
6428: PPUSH
6429: PPUSH
6430: PPUSH
// begin enable ;
6431: ENABLE
// tmp := [ ] ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: EMPTY
6438: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6439: LD_ADDR_VAR 0 1
6443: PUSH
6444: DOUBLE
6445: LD_INT 1
6447: DEC
6448: ST_TO_ADDR
6449: LD_INT 4
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: LD_INT 7
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: PUSH
6463: LD_OWVAR 67
6467: ARRAY
6468: PUSH
6469: FOR_TO
6470: IFFALSE 6630
// begin uc_side := 8 ;
6472: LD_ADDR_OWVAR 20
6476: PUSH
6477: LD_INT 8
6479: ST_TO_ADDR
// uc_nation := 2 ;
6480: LD_ADDR_OWVAR 21
6484: PUSH
6485: LD_INT 2
6487: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6488: LD_INT 13
6490: PUSH
6491: LD_INT 14
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 1
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 12
6508: ARRAY
6509: PPUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 5
6515: PPUSH
6516: LD_INT 27
6518: PUSH
6519: LD_INT 28
6521: PUSH
6522: LD_INT 26
6524: PUSH
6525: LD_INT 25
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_INT 4
6539: PPUSH
6540: CALL_OW 12
6544: ARRAY
6545: PPUSH
6546: LD_INT 88
6548: PPUSH
6549: CALL 71318 0 5
// un := CreateVehicle ;
6553: LD_ADDR_VAR 0 2
6557: PUSH
6558: CALL_OW 45
6562: ST_TO_ADDR
// tmp := tmp ^ un ;
6563: LD_ADDR_VAR 0 3
6567: PUSH
6568: LD_VAR 0 3
6572: PUSH
6573: LD_VAR 0 2
6577: ADD
6578: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6579: LD_VAR 0 2
6583: PPUSH
6584: LD_INT 3
6586: PPUSH
6587: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6591: LD_VAR 0 2
6595: PPUSH
6596: LD_INT 30
6598: PPUSH
6599: LD_INT 0
6601: PPUSH
6602: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 16
6613: PPUSH
6614: LD_INT 11
6616: PPUSH
6617: CALL_OW 111
// wait ( 0 0$2 ) ;
6621: LD_INT 70
6623: PPUSH
6624: CALL_OW 67
// end ;
6628: GO 6469
6630: POP
6631: POP
// for i = 1 to Difficulty do
6632: LD_ADDR_VAR 0 1
6636: PUSH
6637: DOUBLE
6638: LD_INT 1
6640: DEC
6641: ST_TO_ADDR
6642: LD_OWVAR 67
6646: PUSH
6647: FOR_TO
6648: IFFALSE 6773
// begin uc_side := 8 ;
6650: LD_ADDR_OWVAR 20
6654: PUSH
6655: LD_INT 8
6657: ST_TO_ADDR
// uc_nation := 2 ;
6658: LD_ADDR_OWVAR 21
6662: PUSH
6663: LD_INT 2
6665: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6666: LD_INT 0
6668: PPUSH
6669: LD_INT 8
6671: PPUSH
6672: LD_INT 8
6674: PUSH
6675: LD_INT 8
6677: PUSH
6678: LD_INT 9
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_OWVAR 67
6690: ARRAY
6691: PPUSH
6692: CALL_OW 380
// un := CreateHuman ;
6696: LD_ADDR_VAR 0 2
6700: PUSH
6701: CALL_OW 44
6705: ST_TO_ADDR
// tmp := tmp ^ un ;
6706: LD_ADDR_VAR 0 3
6710: PUSH
6711: LD_VAR 0 3
6715: PUSH
6716: LD_VAR 0 2
6720: ADD
6721: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 3
6729: PPUSH
6730: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 30
6741: PPUSH
6742: LD_INT 0
6744: PPUSH
6745: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 16
6756: PPUSH
6757: LD_INT 11
6759: PPUSH
6760: CALL_OW 111
// wait ( 0 0$2 ) ;
6764: LD_INT 70
6766: PPUSH
6767: CALL_OW 67
// end ;
6771: GO 6647
6773: POP
6774: POP
// repeat wait ( 0 0$1 ) ;
6775: LD_INT 35
6777: PPUSH
6778: CALL_OW 67
// for i in tmp do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6929
// begin if GetLives ( i ) > 250 then
6795: LD_VAR 0 1
6799: PPUSH
6800: CALL_OW 256
6804: PUSH
6805: LD_INT 250
6807: GREATER
6808: IFFALSE 6900
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6810: LD_INT 81
6812: PUSH
6813: LD_INT 8
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: LD_INT 91
6822: PUSH
6823: LD_VAR 0 1
6827: PUSH
6828: LD_INT 10
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 69
6844: NOT
6845: IFFALSE 6864
// ComAgressiveMove ( i , 67 , 110 ) else
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_INT 67
6854: PPUSH
6855: LD_INT 110
6857: PPUSH
6858: CALL_OW 114
6862: GO 6898
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6864: LD_VAR 0 1
6868: PPUSH
6869: LD_INT 81
6871: PUSH
6872: LD_INT 8
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PPUSH
6884: LD_VAR 0 1
6888: PPUSH
6889: CALL_OW 74
6893: PPUSH
6894: CALL_OW 115
// end else
6898: GO 6927
// if IsDead ( i ) then
6900: LD_VAR 0 1
6904: PPUSH
6905: CALL_OW 301
6909: IFFALSE 6927
// tmp := tmp diff i ;
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: LD_VAR 0 3
6920: PUSH
6921: LD_VAR 0 1
6925: DIFF
6926: ST_TO_ADDR
// end ;
6927: GO 6792
6929: POP
6930: POP
// until not tmp ;
6931: LD_VAR 0 3
6935: NOT
6936: IFFALSE 6775
// end ; end_of_file
6938: PPOPN 3
6940: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
6948: PPUSH
6949: PPUSH
6950: PPUSH
6951: PPUSH
// side := 3 ;
6952: LD_ADDR_VAR 0 6
6956: PUSH
6957: LD_INT 3
6959: ST_TO_ADDR
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 6
6969: ST_TO_ADDR
// uc_nation := 3 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 3
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 21
6997: PUSH
6998: LD_INT 3
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7031
// SetBLevel ( i , 10 ) ;
7017: LD_VAR 0 2
7021: PPUSH
7022: LD_INT 10
7024: PPUSH
7025: CALL_OW 241
7029: GO 7014
7031: POP
7032: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7033: LD_ADDR_VAR 0 9
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_VAR 0 6
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 30
7052: PUSH
7053: LD_INT 34
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PPUSH
7064: CALL_OW 69
7068: ST_TO_ADDR
// if teleport then
7069: LD_VAR 0 9
7073: IFFALSE 7094
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7075: LD_VAR 0 9
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PPUSH
7084: LD_INT 123
7086: PPUSH
7087: LD_INT 122
7089: PPUSH
7090: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7094: LD_ADDR_EXP 63
7098: PUSH
7099: LD_STRING Platonov
7101: PPUSH
7102: CALL_OW 25
7106: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7107: LD_ADDR_EXP 64
7111: PUSH
7112: LD_STRING Kovalyuk
7114: PPUSH
7115: CALL_OW 25
7119: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7120: LD_ADDR_EXP 66
7124: PUSH
7125: LD_STRING Yakotich
7127: PPUSH
7128: CALL_OW 25
7132: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7133: LD_ADDR_EXP 65
7137: PUSH
7138: LD_STRING Bystrov
7140: PPUSH
7141: CALL_OW 25
7145: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7146: LD_ADDR_EXP 67
7150: PUSH
7151: LD_STRING Gleb
7153: PPUSH
7154: CALL_OW 25
7158: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7159: LD_STRING 03_Cornel
7161: PPUSH
7162: CALL_OW 28
7166: IFFALSE 7214
// begin Bierezov := NewCharacter ( Mikhail ) ;
7168: LD_ADDR_EXP 68
7172: PUSH
7173: LD_STRING Mikhail
7175: PPUSH
7176: CALL_OW 25
7180: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7181: LD_EXP 68
7185: PPUSH
7186: LD_INT 197
7188: PPUSH
7189: LD_INT 111
7191: PPUSH
7192: LD_INT 9
7194: PPUSH
7195: LD_INT 0
7197: PPUSH
7198: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7202: LD_EXP 68
7206: PPUSH
7207: LD_INT 3
7209: PPUSH
7210: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7214: LD_EXP 63
7218: PPUSH
7219: LD_INT 126
7221: PPUSH
7222: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7226: LD_EXP 64
7230: PPUSH
7231: LD_INT 134
7233: PPUSH
7234: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7238: LD_EXP 66
7242: PPUSH
7243: LD_INT 197
7245: PPUSH
7246: LD_INT 111
7248: PPUSH
7249: LD_INT 9
7251: PPUSH
7252: LD_INT 0
7254: PPUSH
7255: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7259: LD_EXP 65
7263: PPUSH
7264: LD_INT 197
7266: PPUSH
7267: LD_INT 111
7269: PPUSH
7270: LD_INT 9
7272: PPUSH
7273: LD_INT 0
7275: PPUSH
7276: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7280: LD_EXP 67
7284: PPUSH
7285: LD_INT 197
7287: PPUSH
7288: LD_INT 111
7290: PPUSH
7291: LD_INT 9
7293: PPUSH
7294: LD_INT 0
7296: PPUSH
7297: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7301: LD_ADDR_VAR 0 5
7305: PUSH
7306: LD_INT 126
7308: PPUSH
7309: LD_INT 4
7311: PPUSH
7312: LD_STRING zhukov
7314: PPUSH
7315: LD_INT 9
7317: PUSH
7318: LD_INT 10
7320: PUSH
7321: LD_INT 10
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: PUSH
7329: LD_OWVAR 67
7333: ARRAY
7334: PPUSH
7335: LD_INT 90000
7337: PUSH
7338: LD_INT 1000
7340: PUSH
7341: LD_INT 300
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: LIST
7348: PPUSH
7349: LD_INT 21
7351: PUSH
7352: LD_INT 8
7354: PUSH
7355: LD_INT 13
7357: PUSH
7358: LD_INT 8
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: PPUSH
7367: CALL 74727 0 6
7371: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7372: LD_ADDR_VAR 0 4
7376: PUSH
7377: LD_INT 267
7379: PPUSH
7380: CALL_OW 274
7384: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7385: LD_VAR 0 4
7389: PPUSH
7390: LD_INT 1
7392: PPUSH
7393: LD_INT 5000
7395: PPUSH
7396: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7400: LD_VAR 0 4
7404: PPUSH
7405: LD_INT 2
7407: PPUSH
7408: LD_INT 200
7410: PPUSH
7411: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7415: LD_VAR 0 4
7419: PPUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 200
7425: PPUSH
7426: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7430: LD_ADDR_EXP 101
7434: PUSH
7435: LD_EXP 101
7439: PPUSH
7440: LD_INT 2
7442: PPUSH
7443: LD_VAR 0 5
7447: PUSH
7448: LD_INT 22
7450: PUSH
7451: LD_VAR 0 6
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 3
7462: PUSH
7463: LD_INT 21
7465: PUSH
7466: LD_INT 2
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: PPUSH
7481: CALL_OW 69
7485: UNION
7486: PUSH
7487: LD_EXP 63
7491: DIFF
7492: PPUSH
7493: CALL_OW 1
7497: ST_TO_ADDR
// behemoths := [ ] ;
7498: LD_ADDR_EXP 71
7502: PUSH
7503: EMPTY
7504: ST_TO_ADDR
// behemothBuilders := [ ] ;
7505: LD_ADDR_EXP 72
7509: PUSH
7510: EMPTY
7511: ST_TO_ADDR
// if Kovalyuk then
7512: LD_EXP 64
7516: IFFALSE 7538
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7518: LD_ADDR_EXP 72
7522: PUSH
7523: LD_EXP 72
7527: PPUSH
7528: LD_EXP 64
7532: PPUSH
7533: CALL 107063 0 2
7537: ST_TO_ADDR
// j := 3 ;
7538: LD_ADDR_VAR 0 3
7542: PUSH
7543: LD_INT 3
7545: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7546: LD_ADDR_VAR 0 2
7550: PUSH
7551: LD_INT 22
7553: PUSH
7554: LD_INT 3
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 25
7563: PUSH
7564: LD_INT 3
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PPUSH
7575: CALL_OW 69
7579: PUSH
7580: LD_EXP 64
7584: DIFF
7585: PUSH
7586: FOR_IN
7587: IFFALSE 7637
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7589: LD_ADDR_EXP 72
7593: PUSH
7594: LD_EXP 72
7598: PPUSH
7599: LD_VAR 0 2
7603: PPUSH
7604: CALL 107063 0 2
7608: ST_TO_ADDR
// j := j - 1 ;
7609: LD_ADDR_VAR 0 3
7613: PUSH
7614: LD_VAR 0 3
7618: PUSH
7619: LD_INT 1
7621: MINUS
7622: ST_TO_ADDR
// if j = 0 then
7623: LD_VAR 0 3
7627: PUSH
7628: LD_INT 0
7630: EQUAL
7631: IFFALSE 7635
// break ;
7633: GO 7637
// end ;
7635: GO 7586
7637: POP
7638: POP
// end ;
7639: LD_VAR 0 1
7643: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7644: LD_INT 0
7646: PPUSH
7647: PPUSH
7648: PPUSH
7649: PPUSH
7650: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7651: LD_ADDR_VAR 0 4
7655: PUSH
7656: LD_INT 209
7658: PUSH
7659: LD_INT 149
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: PUSH
7666: LD_INT 219
7668: PUSH
7669: LD_INT 154
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: PUSH
7676: LD_INT 223
7678: PUSH
7679: LD_INT 149
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 232
7688: PUSH
7689: LD_INT 155
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: ST_TO_ADDR
// if not behemothBuilders then
7702: LD_EXP 72
7706: NOT
7707: IFFALSE 7711
// exit ;
7709: GO 7815
// j := 1 ;
7711: LD_ADDR_VAR 0 3
7715: PUSH
7716: LD_INT 1
7718: ST_TO_ADDR
// for i in behemothBuilders do
7719: LD_ADDR_VAR 0 2
7723: PUSH
7724: LD_EXP 72
7728: PUSH
7729: FOR_IN
7730: IFFALSE 7813
// begin if IsInUnit ( i ) then
7732: LD_VAR 0 2
7736: PPUSH
7737: CALL_OW 310
7741: IFFALSE 7752
// ComExitBuilding ( i ) ;
7743: LD_VAR 0 2
7747: PPUSH
7748: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7752: LD_VAR 0 2
7756: PPUSH
7757: LD_INT 37
7759: PPUSH
7760: LD_VAR 0 4
7764: PUSH
7765: LD_VAR 0 3
7769: ARRAY
7770: PUSH
7771: LD_INT 1
7773: ARRAY
7774: PPUSH
7775: LD_VAR 0 4
7779: PUSH
7780: LD_VAR 0 3
7784: ARRAY
7785: PUSH
7786: LD_INT 2
7788: ARRAY
7789: PPUSH
7790: LD_INT 0
7792: PPUSH
7793: CALL_OW 230
// j := j + 1 ;
7797: LD_ADDR_VAR 0 3
7801: PUSH
7802: LD_VAR 0 3
7806: PUSH
7807: LD_INT 1
7809: PLUS
7810: ST_TO_ADDR
// end ;
7811: GO 7729
7813: POP
7814: POP
// end ;
7815: LD_VAR 0 1
7819: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7820: LD_INT 24
7822: PPUSH
7823: LD_INT 30
7825: PUSH
7826: LD_INT 37
7828: PUSH
7829: EMPTY
7830: LIST
7831: LIST
7832: PPUSH
7833: CALL_OW 70
7837: IFFALSE 7850
7839: GO 7841
7841: DISABLE
// behemothUnderConstruct := true ;
7842: LD_ADDR_EXP 26
7846: PUSH
7847: LD_INT 1
7849: ST_TO_ADDR
7850: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7851: LD_INT 3
7853: PPUSH
7854: CALL 107111 0 1
7858: PUSH
7859: LD_INT 22
7861: PUSH
7862: LD_INT 3
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PUSH
7869: LD_INT 30
7871: PUSH
7872: LD_INT 37
7874: PUSH
7875: EMPTY
7876: LIST
7877: LIST
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PPUSH
7883: CALL_OW 69
7887: NOT
7888: AND
7889: IFFALSE 8075
7891: GO 7893
7893: DISABLE
7894: LD_INT 0
7896: PPUSH
7897: PPUSH
// begin enable ;
7898: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7899: LD_ADDR_VAR 0 2
7903: PUSH
7904: LD_INT 3
7906: PPUSH
7907: CALL 107111 0 1
7911: ST_TO_ADDR
// for i in tmp do
7912: LD_ADDR_VAR 0 1
7916: PUSH
7917: LD_VAR 0 2
7921: PUSH
7922: FOR_IN
7923: IFFALSE 8073
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7925: LD_VAR 0 1
7929: PPUSH
7930: LD_INT 9
7932: PPUSH
7933: CALL_OW 308
7937: PUSH
7938: LD_VAR 0 1
7942: PPUSH
7943: CALL_OW 110
7947: PUSH
7948: LD_INT 2
7950: EQUAL
7951: NOT
7952: AND
7953: IFFALSE 7967
// SetTag ( i , 2 ) ;
7955: LD_VAR 0 1
7959: PPUSH
7960: LD_INT 2
7962: PPUSH
7963: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7967: LD_INT 81
7969: PUSH
7970: LD_INT 3
7972: PUSH
7973: EMPTY
7974: LIST
7975: LIST
7976: PUSH
7977: LD_INT 91
7979: PUSH
7980: LD_VAR 0 1
7984: PUSH
7985: LD_INT 12
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: PPUSH
7997: CALL_OW 69
8001: NOT
8002: PUSH
8003: LD_VAR 0 1
8007: PPUSH
8008: CALL_OW 110
8012: PUSH
8013: LD_INT 2
8015: EQUAL
8016: NOT
8017: AND
8018: IFFALSE 8037
// ComAgressiveMove ( i , 64 , 93 ) else
8020: LD_VAR 0 1
8024: PPUSH
8025: LD_INT 64
8027: PPUSH
8028: LD_INT 93
8030: PPUSH
8031: CALL_OW 114
8035: GO 8071
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8037: LD_VAR 0 1
8041: PPUSH
8042: LD_INT 81
8044: PUSH
8045: LD_INT 3
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: PPUSH
8052: CALL_OW 69
8056: PPUSH
8057: LD_VAR 0 1
8061: PPUSH
8062: CALL_OW 74
8066: PPUSH
8067: CALL_OW 115
// end ;
8071: GO 7922
8073: POP
8074: POP
// end ;
8075: PPOPN 2
8077: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8078: LD_INT 0
8080: PPUSH
8081: PPUSH
8082: PPUSH
// result := [ ] ;
8083: LD_ADDR_VAR 0 2
8087: PUSH
8088: EMPTY
8089: ST_TO_ADDR
// uc_side := 6 ;
8090: LD_ADDR_OWVAR 20
8094: PUSH
8095: LD_INT 6
8097: ST_TO_ADDR
// uc_nation := 3 ;
8098: LD_ADDR_OWVAR 21
8102: PUSH
8103: LD_INT 3
8105: ST_TO_ADDR
// case strength of 1 :
8106: LD_VAR 0 1
8110: PUSH
8111: LD_INT 1
8113: DOUBLE
8114: EQUAL
8115: IFTRUE 8119
8117: GO 8257
8119: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8120: LD_ADDR_VAR 0 3
8124: PUSH
8125: DOUBLE
8126: LD_INT 1
8128: DEC
8129: ST_TO_ADDR
8130: LD_INT 4
8132: PUSH
8133: LD_INT 5
8135: PUSH
8136: LD_INT 6
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: LIST
8143: PUSH
8144: LD_OWVAR 67
8148: ARRAY
8149: PUSH
8150: FOR_TO
8151: IFFALSE 8253
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8153: LD_INT 22
8155: PUSH
8156: LD_INT 24
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PUSH
8163: LD_VAR 0 3
8167: PUSH
8168: LD_INT 2
8170: MOD
8171: PUSH
8172: LD_INT 1
8174: PLUS
8175: ARRAY
8176: PPUSH
8177: LD_INT 1
8179: PUSH
8180: LD_INT 3
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: LD_INT 1
8189: PPUSH
8190: LD_INT 2
8192: PPUSH
8193: CALL_OW 12
8197: ARRAY
8198: PPUSH
8199: LD_INT 3
8201: PPUSH
8202: LD_INT 43
8204: PUSH
8205: LD_INT 44
8207: PUSH
8208: LD_INT 45
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: LIST
8215: PUSH
8216: LD_INT 1
8218: PPUSH
8219: LD_INT 3
8221: PPUSH
8222: CALL_OW 12
8226: ARRAY
8227: PPUSH
8228: LD_INT 80
8230: PPUSH
8231: CALL 71318 0 5
// result := result union CreateVehicle ;
8235: LD_ADDR_VAR 0 2
8239: PUSH
8240: LD_VAR 0 2
8244: PUSH
8245: CALL_OW 45
8249: UNION
8250: ST_TO_ADDR
// end ;
8251: GO 8150
8253: POP
8254: POP
// end ; 2 :
8255: GO 9201
8257: LD_INT 2
8259: DOUBLE
8260: EQUAL
8261: IFTRUE 8265
8263: GO 8421
8265: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8266: LD_ADDR_VAR 0 3
8270: PUSH
8271: DOUBLE
8272: LD_INT 1
8274: DEC
8275: ST_TO_ADDR
8276: LD_INT 5
8278: PUSH
8279: LD_INT 6
8281: PUSH
8282: LD_INT 7
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: LIST
8289: PUSH
8290: LD_OWVAR 67
8294: ARRAY
8295: PUSH
8296: FOR_TO
8297: IFFALSE 8417
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8299: LD_INT 22
8301: PUSH
8302: LD_INT 24
8304: PUSH
8305: LD_INT 24
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: LIST
8312: PUSH
8313: LD_VAR 0 3
8317: PUSH
8318: LD_INT 3
8320: MOD
8321: PUSH
8322: LD_INT 1
8324: PLUS
8325: ARRAY
8326: PPUSH
8327: LD_INT 1
8329: PUSH
8330: LD_INT 3
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: PUSH
8337: LD_INT 1
8339: PPUSH
8340: LD_INT 2
8342: PPUSH
8343: CALL_OW 12
8347: ARRAY
8348: PPUSH
8349: LD_INT 3
8351: PPUSH
8352: LD_INT 43
8354: PUSH
8355: LD_INT 44
8357: PUSH
8358: LD_INT 45
8360: PUSH
8361: LD_INT 44
8363: PUSH
8364: LD_INT 46
8366: PUSH
8367: LD_INT 46
8369: PUSH
8370: EMPTY
8371: LIST
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: LIST
8377: PUSH
8378: LD_VAR 0 3
8382: PUSH
8383: LD_INT 6
8385: MOD
8386: PUSH
8387: LD_INT 1
8389: PLUS
8390: ARRAY
8391: PPUSH
8392: LD_INT 80
8394: PPUSH
8395: CALL 71318 0 5
// result := result union CreateVehicle ;
8399: LD_ADDR_VAR 0 2
8403: PUSH
8404: LD_VAR 0 2
8408: PUSH
8409: CALL_OW 45
8413: UNION
8414: ST_TO_ADDR
// end ;
8415: GO 8296
8417: POP
8418: POP
// end ; 3 :
8419: GO 9201
8421: LD_INT 3
8423: DOUBLE
8424: EQUAL
8425: IFTRUE 8429
8427: GO 8585
8429: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8430: LD_ADDR_VAR 0 3
8434: PUSH
8435: DOUBLE
8436: LD_INT 1
8438: DEC
8439: ST_TO_ADDR
8440: LD_INT 5
8442: PUSH
8443: LD_INT 7
8445: PUSH
8446: LD_INT 8
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: LIST
8453: PUSH
8454: LD_OWVAR 67
8458: ARRAY
8459: PUSH
8460: FOR_TO
8461: IFFALSE 8581
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8463: LD_INT 22
8465: PUSH
8466: LD_INT 24
8468: PUSH
8469: LD_INT 24
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: LIST
8476: PUSH
8477: LD_VAR 0 3
8481: PUSH
8482: LD_INT 3
8484: MOD
8485: PUSH
8486: LD_INT 1
8488: PLUS
8489: ARRAY
8490: PPUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: LD_INT 1
8503: PPUSH
8504: LD_INT 2
8506: PPUSH
8507: CALL_OW 12
8511: ARRAY
8512: PPUSH
8513: LD_INT 3
8515: PPUSH
8516: LD_INT 43
8518: PUSH
8519: LD_INT 47
8521: PUSH
8522: LD_INT 45
8524: PUSH
8525: LD_INT 45
8527: PUSH
8528: LD_INT 46
8530: PUSH
8531: LD_INT 46
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: LIST
8539: LIST
8540: LIST
8541: PUSH
8542: LD_VAR 0 3
8546: PUSH
8547: LD_INT 6
8549: MOD
8550: PUSH
8551: LD_INT 1
8553: PLUS
8554: ARRAY
8555: PPUSH
8556: LD_INT 80
8558: PPUSH
8559: CALL 71318 0 5
// result := result union CreateVehicle ;
8563: LD_ADDR_VAR 0 2
8567: PUSH
8568: LD_VAR 0 2
8572: PUSH
8573: CALL_OW 45
8577: UNION
8578: ST_TO_ADDR
// end ;
8579: GO 8460
8581: POP
8582: POP
// end ; 4 :
8583: GO 9201
8585: LD_INT 4
8587: DOUBLE
8588: EQUAL
8589: IFTRUE 8593
8591: GO 9200
8593: POP
// begin uc_nation := 3 ;
8594: LD_ADDR_OWVAR 21
8598: PUSH
8599: LD_INT 3
8601: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8602: LD_ADDR_VAR 0 3
8606: PUSH
8607: DOUBLE
8608: LD_INT 1
8610: DEC
8611: ST_TO_ADDR
8612: LD_INT 6
8614: PUSH
8615: LD_INT 8
8617: PUSH
8618: LD_INT 9
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: PUSH
8626: LD_OWVAR 67
8630: ARRAY
8631: PUSH
8632: FOR_TO
8633: IFFALSE 8753
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8635: LD_INT 22
8637: PUSH
8638: LD_INT 24
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: EMPTY
8645: LIST
8646: LIST
8647: LIST
8648: PUSH
8649: LD_VAR 0 3
8653: PUSH
8654: LD_INT 3
8656: MOD
8657: PUSH
8658: LD_INT 1
8660: PLUS
8661: ARRAY
8662: PPUSH
8663: LD_INT 1
8665: PUSH
8666: LD_INT 3
8668: PUSH
8669: EMPTY
8670: LIST
8671: LIST
8672: PUSH
8673: LD_INT 1
8675: PPUSH
8676: LD_INT 2
8678: PPUSH
8679: CALL_OW 12
8683: ARRAY
8684: PPUSH
8685: LD_INT 3
8687: PPUSH
8688: LD_INT 45
8690: PUSH
8691: LD_INT 47
8693: PUSH
8694: LD_INT 47
8696: PUSH
8697: LD_INT 45
8699: PUSH
8700: LD_INT 46
8702: PUSH
8703: LD_INT 46
8705: PUSH
8706: EMPTY
8707: LIST
8708: LIST
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_VAR 0 3
8718: PUSH
8719: LD_INT 6
8721: MOD
8722: PUSH
8723: LD_INT 1
8725: PLUS
8726: ARRAY
8727: PPUSH
8728: LD_INT 80
8730: PPUSH
8731: CALL 71318 0 5
// result := result union CreateVehicle ;
8735: LD_ADDR_VAR 0 2
8739: PUSH
8740: LD_VAR 0 2
8744: PUSH
8745: CALL_OW 45
8749: UNION
8750: ST_TO_ADDR
// end ;
8751: GO 8632
8753: POP
8754: POP
// if not KappaStatus then
8755: LD_EXP 2
8759: NOT
8760: IFFALSE 8995
// begin uc_nation := 1 ;
8762: LD_ADDR_OWVAR 21
8766: PUSH
8767: LD_INT 1
8769: ST_TO_ADDR
// for i = 1 to 3 do
8770: LD_ADDR_VAR 0 3
8774: PUSH
8775: DOUBLE
8776: LD_INT 1
8778: DEC
8779: ST_TO_ADDR
8780: LD_INT 3
8782: PUSH
8783: FOR_TO
8784: IFFALSE 8920
// begin j := rand ( 0 , 1 ) ;
8786: LD_ADDR_VAR 0 4
8790: PUSH
8791: LD_INT 0
8793: PPUSH
8794: LD_INT 1
8796: PPUSH
8797: CALL_OW 12
8801: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8802: LD_INT 3
8804: PUSH
8805: LD_INT 5
8807: PUSH
8808: LD_INT 5
8810: PUSH
8811: LD_INT 4
8813: PUSH
8814: EMPTY
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: PUSH
8820: LD_VAR 0 4
8824: PUSH
8825: LD_INT 1
8827: PPUSH
8828: LD_INT 3
8830: PPUSH
8831: CALL_OW 12
8835: PLUS
8836: ARRAY
8837: PPUSH
8838: LD_INT 1
8840: PUSH
8841: LD_INT 3
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: PUSH
8848: LD_INT 1
8850: PPUSH
8851: LD_INT 2
8853: PPUSH
8854: CALL_OW 12
8858: ARRAY
8859: PPUSH
8860: LD_INT 3
8862: PPUSH
8863: LD_INT 9
8865: PUSH
8866: LD_INT 7
8868: PUSH
8869: LD_INT 6
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: LIST
8876: PUSH
8877: LD_VAR 0 4
8881: PUSH
8882: LD_INT 1
8884: PPUSH
8885: LD_INT 2
8887: PPUSH
8888: CALL_OW 12
8892: PLUS
8893: ARRAY
8894: PPUSH
8895: LD_INT 85
8897: PPUSH
8898: CALL 71318 0 5
// result := result union CreateVehicle ;
8902: LD_ADDR_VAR 0 2
8906: PUSH
8907: LD_VAR 0 2
8911: PUSH
8912: CALL_OW 45
8916: UNION
8917: ST_TO_ADDR
// end ;
8918: GO 8783
8920: POP
8921: POP
// if vsevolodFirstAttack then
8922: LD_EXP 24
8926: IFFALSE 8993
// begin vsevolodFirstAttack := false ;
8928: LD_ADDR_EXP 24
8932: PUSH
8933: LD_INT 0
8935: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8936: LD_INT 5
8938: PPUSH
8939: LD_INT 3
8941: PPUSH
8942: LD_INT 1
8944: PPUSH
8945: LD_INT 6
8947: PPUSH
8948: LD_INT 100
8950: PPUSH
8951: CALL 71318 0 5
// sewiVeh := CreateVehicle ;
8955: LD_ADDR_EXP 70
8959: PUSH
8960: CALL_OW 45
8964: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8965: LD_EXP 70
8969: PPUSH
8970: LD_INT 1
8972: PPUSH
8973: CALL_OW 242
// result := result union sewiVeh ;
8977: LD_ADDR_VAR 0 2
8981: PUSH
8982: LD_VAR 0 2
8986: PUSH
8987: LD_EXP 70
8991: UNION
8992: ST_TO_ADDR
// end ; end else
8993: GO 9198
// if vsevolodFirstAttack then
8995: LD_EXP 24
8999: IFFALSE 9198
// begin vsevolodFirstAttack := false ;
9001: LD_ADDR_EXP 24
9005: PUSH
9006: LD_INT 0
9008: ST_TO_ADDR
// uc_nation := 3 ;
9009: LD_ADDR_OWVAR 21
9013: PUSH
9014: LD_INT 3
9016: ST_TO_ADDR
// for i = 1 to 3 do
9017: LD_ADDR_VAR 0 3
9021: PUSH
9022: DOUBLE
9023: LD_INT 1
9025: DEC
9026: ST_TO_ADDR
9027: LD_INT 3
9029: PUSH
9030: FOR_TO
9031: IFFALSE 9139
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9033: LD_INT 22
9035: PUSH
9036: LD_INT 24
9038: PUSH
9039: LD_INT 24
9041: PUSH
9042: EMPTY
9043: LIST
9044: LIST
9045: LIST
9046: PUSH
9047: LD_VAR 0 3
9051: PUSH
9052: LD_INT 3
9054: MOD
9055: PUSH
9056: LD_INT 1
9058: PLUS
9059: ARRAY
9060: PPUSH
9061: LD_INT 1
9063: PUSH
9064: LD_INT 3
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: PUSH
9071: LD_INT 1
9073: PPUSH
9074: LD_INT 2
9076: PPUSH
9077: CALL_OW 12
9081: ARRAY
9082: PPUSH
9083: LD_INT 3
9085: PPUSH
9086: LD_INT 45
9088: PUSH
9089: LD_INT 47
9091: PUSH
9092: LD_INT 47
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: LIST
9099: PUSH
9100: LD_VAR 0 3
9104: PUSH
9105: LD_INT 3
9107: MOD
9108: PUSH
9109: LD_INT 1
9111: PLUS
9112: ARRAY
9113: PPUSH
9114: LD_INT 80
9116: PPUSH
9117: CALL 71318 0 5
// result := result union CreateVehicle ;
9121: LD_ADDR_VAR 0 2
9125: PUSH
9126: LD_VAR 0 2
9130: PUSH
9131: CALL_OW 45
9135: UNION
9136: ST_TO_ADDR
// end ;
9137: GO 9030
9139: POP
9140: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9141: LD_INT 24
9143: PPUSH
9144: LD_INT 3
9146: PPUSH
9147: LD_INT 1
9149: PPUSH
9150: LD_INT 47
9152: PPUSH
9153: LD_INT 100
9155: PPUSH
9156: CALL 71318 0 5
// sewiVeh := CreateVehicle ;
9160: LD_ADDR_EXP 70
9164: PUSH
9165: CALL_OW 45
9169: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9170: LD_EXP 70
9174: PPUSH
9175: LD_INT 1
9177: PPUSH
9178: CALL_OW 242
// result := result union sewiVeh ;
9182: LD_ADDR_VAR 0 2
9186: PUSH
9187: LD_VAR 0 2
9191: PUSH
9192: LD_EXP 70
9196: UNION
9197: ST_TO_ADDR
// end ; end ; end ;
9198: GO 9201
9200: POP
// end ;
9201: LD_VAR 0 2
9205: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9206: LD_EXP 16
9210: IFFALSE 9968
9212: GO 9214
9214: DISABLE
9215: LD_INT 0
9217: PPUSH
9218: PPUSH
9219: PPUSH
9220: PPUSH
9221: PPUSH
9222: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9223: LD_ADDR_VAR 0 4
9227: PUSH
9228: LD_INT 11
9230: PUSH
9231: LD_INT 12
9233: PUSH
9234: EMPTY
9235: LIST
9236: LIST
9237: ST_TO_ADDR
// time := [ 4 4$20 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9238: LD_ADDR_VAR 0 3
9242: PUSH
9243: LD_INT 9100
9245: PUSH
9246: LD_INT 7350
9248: PUSH
9249: LD_INT 6650
9251: PUSH
9252: EMPTY
9253: LIST
9254: LIST
9255: LIST
9256: PUSH
9257: LD_OWVAR 67
9261: ARRAY
9262: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9263: LD_ADDR_VAR 0 6
9267: PUSH
9268: LD_INT 70
9270: PUSH
9271: LD_INT 118
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PUSH
9278: LD_INT 78
9280: PUSH
9281: LD_INT 31
9283: PUSH
9284: EMPTY
9285: LIST
9286: LIST
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: ST_TO_ADDR
// repeat if missionStage = 2 then
9292: LD_EXP 15
9296: PUSH
9297: LD_INT 2
9299: EQUAL
9300: IFFALSE 9311
// wait ( 1 1$30 ) else
9302: LD_INT 3150
9304: PPUSH
9305: CALL_OW 67
9309: GO 9320
// wait ( time ) ;
9311: LD_VAR 0 3
9315: PPUSH
9316: CALL_OW 67
// if missionStage = 6 then
9320: LD_EXP 15
9324: PUSH
9325: LD_INT 6
9327: EQUAL
9328: IFFALSE 9356
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9330: LD_INT 51
9332: PPUSH
9333: LD_INT 6
9335: PPUSH
9336: LD_INT 2
9338: PPUSH
9339: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9343: LD_INT 57
9345: PPUSH
9346: LD_INT 6
9348: PPUSH
9349: LD_INT 2
9351: PPUSH
9352: CALL_OW 322
// end ; if missionStage = 8 then
9356: LD_EXP 15
9360: PUSH
9361: LD_INT 8
9363: EQUAL
9364: IFFALSE 9392
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9366: LD_INT 52
9368: PPUSH
9369: LD_INT 6
9371: PPUSH
9372: LD_INT 2
9374: PPUSH
9375: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9379: LD_INT 58
9381: PPUSH
9382: LD_INT 6
9384: PPUSH
9385: LD_INT 2
9387: PPUSH
9388: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9392: LD_EXP 15
9396: PUSH
9397: LD_INT 10
9399: EQUAL
9400: PUSH
9401: LD_OWVAR 67
9405: PUSH
9406: LD_INT 1
9408: GREATER
9409: AND
9410: IFFALSE 9438
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9412: LD_INT 53
9414: PPUSH
9415: LD_INT 6
9417: PPUSH
9418: LD_INT 2
9420: PPUSH
9421: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9425: LD_INT 59
9427: PPUSH
9428: LD_INT 6
9430: PPUSH
9431: LD_INT 2
9433: PPUSH
9434: CALL_OW 322
// end ; if activeAttacks then
9438: LD_EXP 16
9442: IFFALSE 9962
// begin if missionStage = 2 then
9444: LD_EXP 15
9448: PUSH
9449: LD_INT 2
9451: EQUAL
9452: IFFALSE 9462
// strength := 1 ;
9454: LD_ADDR_VAR 0 5
9458: PUSH
9459: LD_INT 1
9461: ST_TO_ADDR
// if missionStage > 2 then
9462: LD_EXP 15
9466: PUSH
9467: LD_INT 2
9469: GREATER
9470: IFFALSE 9480
// strength := 2 ;
9472: LD_ADDR_VAR 0 5
9476: PUSH
9477: LD_INT 2
9479: ST_TO_ADDR
// if missionStage > 6 then
9480: LD_EXP 15
9484: PUSH
9485: LD_INT 6
9487: GREATER
9488: IFFALSE 9498
// strength := 3 ;
9490: LD_ADDR_VAR 0 5
9494: PUSH
9495: LD_INT 3
9497: ST_TO_ADDR
// if missionStage > 10 then
9498: LD_EXP 15
9502: PUSH
9503: LD_INT 10
9505: GREATER
9506: IFFALSE 9516
// strength := 4 ;
9508: LD_ADDR_VAR 0 5
9512: PUSH
9513: LD_INT 4
9515: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9516: LD_ADDR_VAR 0 2
9520: PUSH
9521: LD_VAR 0 5
9525: PPUSH
9526: CALL 8078 0 1
9530: ST_TO_ADDR
// for i in tmp do
9531: LD_ADDR_VAR 0 1
9535: PUSH
9536: LD_VAR 0 2
9540: PUSH
9541: FOR_IN
9542: IFFALSE 9642
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9544: LD_VAR 0 1
9548: PPUSH
9549: LD_VAR 0 4
9553: PUSH
9554: LD_INT 1
9556: PPUSH
9557: LD_INT 2
9559: PPUSH
9560: CALL_OW 12
9564: ARRAY
9565: PPUSH
9566: LD_INT 0
9568: PPUSH
9569: CALL_OW 49
// if i = sewiVeh then
9573: LD_VAR 0 1
9577: PUSH
9578: LD_EXP 70
9582: EQUAL
9583: IFFALSE 9618
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9585: LD_ADDR_EXP 69
9589: PUSH
9590: LD_STRING Vsevolod
9592: PPUSH
9593: LD_INT 0
9595: PPUSH
9596: LD_STRING 
9598: PPUSH
9599: CALL 64203 0 3
9603: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9604: LD_EXP 69
9608: PPUSH
9609: LD_VAR 0 1
9613: PPUSH
9614: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9618: LD_VAR 0 1
9622: PPUSH
9623: LD_INT 111
9625: PPUSH
9626: LD_INT 197
9628: PPUSH
9629: CALL_OW 111
// wait ( 0 0$2 ) ;
9633: LD_INT 70
9635: PPUSH
9636: CALL_OW 67
// end ;
9640: GO 9541
9642: POP
9643: POP
// repeat wait ( 0 0$1 ) ;
9644: LD_INT 35
9646: PPUSH
9647: CALL_OW 67
// for i in tmp do
9651: LD_ADDR_VAR 0 1
9655: PUSH
9656: LD_VAR 0 2
9660: PUSH
9661: FOR_IN
9662: IFFALSE 9943
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9664: LD_INT 81
9666: PUSH
9667: LD_INT 6
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 91
9676: PUSH
9677: LD_VAR 0 1
9681: PUSH
9682: LD_INT 12
9684: PUSH
9685: EMPTY
9686: LIST
9687: LIST
9688: LIST
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: PPUSH
9694: CALL_OW 69
9698: IFFALSE 9756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9700: LD_VAR 0 1
9704: PPUSH
9705: LD_INT 81
9707: PUSH
9708: LD_INT 6
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PUSH
9715: LD_INT 91
9717: PUSH
9718: LD_VAR 0 1
9722: PUSH
9723: LD_INT 12
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: LIST
9730: PUSH
9731: EMPTY
9732: LIST
9733: LIST
9734: PPUSH
9735: CALL_OW 69
9739: PPUSH
9740: LD_VAR 0 1
9744: PPUSH
9745: CALL_OW 74
9749: PPUSH
9750: CALL_OW 115
9754: GO 9941
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9756: LD_INT 9
9758: PPUSH
9759: LD_INT 81
9761: PUSH
9762: LD_INT 6
9764: PUSH
9765: EMPTY
9766: LIST
9767: LIST
9768: PPUSH
9769: CALL_OW 70
9773: IFFALSE 9907
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_VAR 0 6
9784: PUSH
9785: LD_INT 1
9787: ARRAY
9788: PUSH
9789: LD_INT 1
9791: ARRAY
9792: PPUSH
9793: LD_VAR 0 6
9797: PUSH
9798: LD_INT 1
9800: ARRAY
9801: PUSH
9802: LD_INT 2
9804: ARRAY
9805: PPUSH
9806: CALL_OW 297
9810: PUSH
9811: LD_INT 10
9813: GREATER
9814: PUSH
9815: LD_VAR 0 1
9819: PPUSH
9820: LD_INT 9
9822: PPUSH
9823: CALL_OW 308
9827: NOT
9828: AND
9829: IFFALSE 9868
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9831: LD_VAR 0 1
9835: PPUSH
9836: LD_VAR 0 6
9840: PUSH
9841: LD_INT 1
9843: ARRAY
9844: PUSH
9845: LD_INT 1
9847: ARRAY
9848: PPUSH
9849: LD_VAR 0 6
9853: PUSH
9854: LD_INT 1
9856: ARRAY
9857: PUSH
9858: LD_INT 2
9860: ARRAY
9861: PPUSH
9862: CALL_OW 114
9866: GO 9905
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9868: LD_VAR 0 1
9872: PPUSH
9873: LD_INT 9
9875: PPUSH
9876: LD_INT 81
9878: PUSH
9879: LD_INT 6
9881: PUSH
9882: EMPTY
9883: LIST
9884: LIST
9885: PPUSH
9886: CALL_OW 70
9890: PPUSH
9891: LD_VAR 0 1
9895: PPUSH
9896: CALL_OW 74
9900: PPUSH
9901: CALL_OW 115
// end else
9905: GO 9941
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 81
9914: PUSH
9915: LD_INT 6
9917: PUSH
9918: EMPTY
9919: LIST
9920: LIST
9921: PPUSH
9922: CALL_OW 69
9926: PPUSH
9927: LD_VAR 0 1
9931: PPUSH
9932: CALL_OW 74
9936: PPUSH
9937: CALL_OW 115
// end ;
9941: GO 9661
9943: POP
9944: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9945: LD_INT 22
9947: PUSH
9948: LD_INT 6
9950: PUSH
9951: EMPTY
9952: LIST
9953: LIST
9954: PPUSH
9955: CALL_OW 69
9959: NOT
9960: IFFALSE 9644
// end ; until russianDestroyed ;
9962: LD_EXP 21
9966: IFFALSE 9292
// end ;
9968: PPOPN 6
9970: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9971: LD_EXP 21
9975: NOT
9976: PUSH
9977: LD_EXP 15
9981: PUSH
9982: LD_INT 6
9984: GREATEREQUAL
9985: AND
9986: PUSH
9987: LD_INT 2
9989: PPUSH
9990: LD_INT 1
9992: PPUSH
9993: CALL 59277 0 2
9997: NOT
9998: AND
9999: IFFALSE 10955
10001: GO 10003
10003: DISABLE
10004: LD_INT 0
10006: PPUSH
10007: PPUSH
10008: PPUSH
10009: PPUSH
// begin enable ;
10010: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10011: LD_INT 22
10013: PUSH
10014: LD_INT 3
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 30
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PPUSH
10035: CALL_OW 69
10039: NOT
10040: IFFALSE 10044
// exit ;
10042: GO 10955
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10044: LD_ADDR_VAR 0 4
10048: PUSH
10049: LD_INT 22
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: EMPTY
10056: LIST
10057: LIST
10058: PUSH
10059: LD_INT 30
10061: PUSH
10062: LD_INT 34
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PPUSH
10073: CALL_OW 69
10077: ST_TO_ADDR
// if Prob ( 40 ) then
10078: LD_INT 40
10080: PPUSH
10081: CALL_OW 13
10085: IFFALSE 10212
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10087: LD_INT 2
10089: PPUSH
10090: LD_INT 22
10092: PUSH
10093: LD_INT 3
10095: PUSH
10096: LD_INT 3
10098: PUSH
10099: LD_INT 49
10101: PUSH
10102: EMPTY
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: PUSH
10108: LD_INT 22
10110: PUSH
10111: LD_INT 3
10113: PUSH
10114: LD_INT 3
10116: PUSH
10117: LD_INT 49
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: PUSH
10126: LD_INT 22
10128: PUSH
10129: LD_INT 3
10131: PUSH
10132: LD_INT 3
10134: PUSH
10135: LD_INT 49
10137: PUSH
10138: EMPTY
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: PUSH
10144: LD_INT 24
10146: PUSH
10147: LD_INT 3
10149: PUSH
10150: LD_INT 3
10152: PUSH
10153: LD_INT 46
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: LIST
10160: LIST
10161: PUSH
10162: LD_INT 24
10164: PUSH
10165: LD_INT 3
10167: PUSH
10168: LD_INT 3
10170: PUSH
10171: LD_INT 46
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: PUSH
10180: LD_INT 24
10182: PUSH
10183: LD_INT 3
10185: PUSH
10186: LD_INT 3
10188: PUSH
10189: LD_INT 46
10191: PUSH
10192: EMPTY
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: LIST
10204: LIST
10205: PPUSH
10206: CALL 57859 0 2
// end else
10210: GO 10335
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10212: LD_INT 2
10214: PPUSH
10215: LD_INT 24
10217: PUSH
10218: LD_INT 3
10220: PUSH
10221: LD_INT 3
10223: PUSH
10224: LD_INT 47
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: PUSH
10233: LD_INT 24
10235: PUSH
10236: LD_INT 3
10238: PUSH
10239: LD_INT 3
10241: PUSH
10242: LD_INT 47
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: LIST
10249: LIST
10250: PUSH
10251: LD_INT 24
10253: PUSH
10254: LD_INT 3
10256: PUSH
10257: LD_INT 3
10259: PUSH
10260: LD_INT 47
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: LIST
10267: LIST
10268: PUSH
10269: LD_INT 24
10271: PUSH
10272: LD_INT 3
10274: PUSH
10275: LD_INT 3
10277: PUSH
10278: LD_INT 46
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: PUSH
10287: LD_INT 24
10289: PUSH
10290: LD_INT 3
10292: PUSH
10293: LD_INT 3
10295: PUSH
10296: LD_INT 46
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: PUSH
10305: LD_INT 24
10307: PUSH
10308: LD_INT 3
10310: PUSH
10311: LD_INT 3
10313: PUSH
10314: LD_INT 46
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: PPUSH
10331: CALL 57859 0 2
// end ; if Difficulty > 1 then
10335: LD_OWVAR 67
10339: PUSH
10340: LD_INT 1
10342: GREATER
10343: IFFALSE 10373
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10345: LD_INT 2
10347: PPUSH
10348: LD_INT 24
10350: PUSH
10351: LD_INT 3
10353: PUSH
10354: LD_INT 3
10356: PUSH
10357: LD_INT 47
10359: PUSH
10360: EMPTY
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: PUSH
10366: EMPTY
10367: LIST
10368: PPUSH
10369: CALL 57859 0 2
// repeat wait ( 0 0$1 ) ;
10373: LD_INT 35
10375: PPUSH
10376: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10380: LD_INT 2
10382: PPUSH
10383: LD_INT 1
10385: PPUSH
10386: CALL 59277 0 2
10390: PUSH
10391: LD_INT 6
10393: PUSH
10394: LD_INT 7
10396: PUSH
10397: LD_INT 7
10399: PUSH
10400: EMPTY
10401: LIST
10402: LIST
10403: LIST
10404: PUSH
10405: LD_OWVAR 67
10409: ARRAY
10410: GREATEREQUAL
10411: IFFALSE 10373
// wait ( 0 0$30 ) ;
10413: LD_INT 1050
10415: PPUSH
10416: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10420: LD_ADDR_VAR 0 2
10424: PUSH
10425: LD_INT 2
10427: PPUSH
10428: LD_INT 1
10430: PPUSH
10431: CALL 59277 0 2
10435: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10436: LD_ADDR_EXP 120
10440: PUSH
10441: LD_EXP 120
10445: PPUSH
10446: LD_INT 2
10448: PPUSH
10449: LD_EXP 120
10453: PUSH
10454: LD_INT 2
10456: ARRAY
10457: PUSH
10458: LD_VAR 0 2
10462: DIFF
10463: PPUSH
10464: CALL_OW 1
10468: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10469: LD_ADDR_VAR 0 3
10473: PUSH
10474: LD_INT 0
10476: PPUSH
10477: LD_INT 1
10479: PPUSH
10480: CALL_OW 12
10484: ST_TO_ADDR
// if target then
10485: LD_VAR 0 3
10489: IFFALSE 10617
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10491: LD_ADDR_VAR 0 2
10495: PUSH
10496: LD_VAR 0 2
10500: PPUSH
10501: LD_INT 24
10503: PUSH
10504: LD_INT 250
10506: PUSH
10507: EMPTY
10508: LIST
10509: LIST
10510: PPUSH
10511: CALL_OW 72
10515: ST_TO_ADDR
// for i in tmp do
10516: LD_ADDR_VAR 0 1
10520: PUSH
10521: LD_VAR 0 2
10525: PUSH
10526: FOR_IN
10527: IFFALSE 10567
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10529: LD_VAR 0 1
10533: PPUSH
10534: LD_INT 139
10536: PPUSH
10537: LD_INT 89
10539: PPUSH
10540: CALL_OW 297
10544: PUSH
10545: LD_INT 9
10547: GREATER
10548: IFFALSE 10565
// ComMoveXY ( i , 139 , 89 ) ;
10550: LD_VAR 0 1
10554: PPUSH
10555: LD_INT 139
10557: PPUSH
10558: LD_INT 89
10560: PPUSH
10561: CALL_OW 111
10565: GO 10526
10567: POP
10568: POP
// wait ( 0 0$1 ) ;
10569: LD_INT 35
10571: PPUSH
10572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10576: LD_VAR 0 2
10580: PPUSH
10581: LD_INT 92
10583: PUSH
10584: LD_INT 139
10586: PUSH
10587: LD_INT 89
10589: PUSH
10590: LD_INT 9
10592: PUSH
10593: EMPTY
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: PPUSH
10599: CALL_OW 72
10603: PUSH
10604: LD_VAR 0 2
10608: PUSH
10609: LD_INT 1
10611: MINUS
10612: GREATEREQUAL
10613: IFFALSE 10491
// end else
10615: GO 10759
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10617: LD_VAR 0 2
10621: PPUSH
10622: LD_VAR 0 4
10626: PUSH
10627: LD_INT 1
10629: ARRAY
10630: PPUSH
10631: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10635: LD_ADDR_VAR 0 2
10639: PUSH
10640: LD_VAR 0 2
10644: PPUSH
10645: LD_INT 24
10647: PUSH
10648: LD_INT 250
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PPUSH
10655: CALL_OW 72
10659: ST_TO_ADDR
// for i in tmp do
10660: LD_ADDR_VAR 0 1
10664: PUSH
10665: LD_VAR 0 2
10669: PUSH
10670: FOR_IN
10671: IFFALSE 10711
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10673: LD_VAR 0 1
10677: PPUSH
10678: LD_INT 124
10680: PPUSH
10681: LD_INT 139
10683: PPUSH
10684: CALL_OW 297
10688: PUSH
10689: LD_INT 9
10691: GREATER
10692: IFFALSE 10709
// ComMoveXY ( i , 124 , 139 ) ;
10694: LD_VAR 0 1
10698: PPUSH
10699: LD_INT 124
10701: PPUSH
10702: LD_INT 139
10704: PPUSH
10705: CALL_OW 111
10709: GO 10670
10711: POP
10712: POP
// wait ( 0 0$1 ) ;
10713: LD_INT 35
10715: PPUSH
10716: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10720: LD_VAR 0 2
10724: PPUSH
10725: LD_INT 92
10727: PUSH
10728: LD_INT 124
10730: PUSH
10731: LD_INT 139
10733: PUSH
10734: LD_INT 9
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: LIST
10741: LIST
10742: PPUSH
10743: CALL_OW 72
10747: PUSH
10748: LD_VAR 0 2
10752: PUSH
10753: LD_INT 1
10755: MINUS
10756: GREATEREQUAL
10757: IFFALSE 10635
// end ; repeat wait ( 0 0$1 ) ;
10759: LD_INT 35
10761: PPUSH
10762: CALL_OW 67
// for i in tmp do
10766: LD_ADDR_VAR 0 1
10770: PUSH
10771: LD_VAR 0 2
10775: PUSH
10776: FOR_IN
10777: IFFALSE 10946
// begin if GetLives ( i ) > 251 then
10779: LD_VAR 0 1
10783: PPUSH
10784: CALL_OW 256
10788: PUSH
10789: LD_INT 251
10791: GREATER
10792: IFFALSE 10917
// begin if GetWeapon ( i ) = ru_time_lapser then
10794: LD_VAR 0 1
10798: PPUSH
10799: CALL_OW 264
10803: PUSH
10804: LD_INT 49
10806: EQUAL
10807: IFFALSE 10863
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10809: LD_VAR 0 1
10813: PPUSH
10814: LD_INT 2
10816: PUSH
10817: LD_INT 22
10819: PUSH
10820: LD_INT 1
10822: PUSH
10823: EMPTY
10824: LIST
10825: LIST
10826: PUSH
10827: LD_INT 22
10829: PUSH
10830: LD_INT 8
10832: PUSH
10833: EMPTY
10834: LIST
10835: LIST
10836: PUSH
10837: EMPTY
10838: LIST
10839: LIST
10840: LIST
10841: PPUSH
10842: CALL_OW 69
10846: PPUSH
10847: LD_VAR 0 1
10851: PPUSH
10852: CALL_OW 74
10856: PPUSH
10857: CALL_OW 112
10861: GO 10915
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10863: LD_VAR 0 1
10867: PPUSH
10868: LD_INT 2
10870: PUSH
10871: LD_INT 22
10873: PUSH
10874: LD_INT 1
10876: PUSH
10877: EMPTY
10878: LIST
10879: LIST
10880: PUSH
10881: LD_INT 22
10883: PUSH
10884: LD_INT 8
10886: PUSH
10887: EMPTY
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: LIST
10895: PPUSH
10896: CALL_OW 69
10900: PPUSH
10901: LD_VAR 0 1
10905: PPUSH
10906: CALL_OW 74
10910: PPUSH
10911: CALL_OW 115
// end else
10915: GO 10944
// if IsDead ( i ) then
10917: LD_VAR 0 1
10921: PPUSH
10922: CALL_OW 301
10926: IFFALSE 10944
// tmp := tmp diff i ;
10928: LD_ADDR_VAR 0 2
10932: PUSH
10933: LD_VAR 0 2
10937: PUSH
10938: LD_VAR 0 1
10942: DIFF
10943: ST_TO_ADDR
// end ;
10944: GO 10776
10946: POP
10947: POP
// until not tmp ;
10948: LD_VAR 0 2
10952: NOT
10953: IFFALSE 10759
// end ; end_of_file
10955: PPOPN 4
10957: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10958: LD_INT 0
10960: PPUSH
10961: PPUSH
10962: PPUSH
10963: PPUSH
10964: PPUSH
10965: PPUSH
// side := 7 ;
10966: LD_ADDR_VAR 0 5
10970: PUSH
10971: LD_INT 7
10973: ST_TO_ADDR
// uc_side := side ;
10974: LD_ADDR_OWVAR 20
10978: PUSH
10979: LD_VAR 0 5
10983: ST_TO_ADDR
// uc_nation := 1 ;
10984: LD_ADDR_OWVAR 21
10988: PUSH
10989: LD_INT 1
10991: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10992: LD_ADDR_VAR 0 2
10996: PUSH
10997: LD_INT 22
10999: PUSH
11000: LD_VAR 0 5
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: PUSH
11009: LD_INT 21
11011: PUSH
11012: LD_INT 3
11014: PUSH
11015: EMPTY
11016: LIST
11017: LIST
11018: PUSH
11019: EMPTY
11020: LIST
11021: LIST
11022: PPUSH
11023: CALL_OW 69
11027: PUSH
11028: FOR_IN
11029: IFFALSE 11045
// SetBLevel ( i , 10 ) ;
11031: LD_VAR 0 2
11035: PPUSH
11036: LD_INT 10
11038: PPUSH
11039: CALL_OW 241
11043: GO 11028
11045: POP
11046: POP
// base := GetBase ( al_depot ) ;
11047: LD_ADDR_VAR 0 4
11051: PUSH
11052: LD_INT 2
11054: PPUSH
11055: CALL_OW 274
11059: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11060: LD_ADDR_VAR 0 6
11064: PUSH
11065: LD_INT 22
11067: PUSH
11068: LD_VAR 0 5
11072: PUSH
11073: EMPTY
11074: LIST
11075: LIST
11076: PUSH
11077: LD_INT 30
11079: PUSH
11080: LD_INT 34
11082: PUSH
11083: EMPTY
11084: LIST
11085: LIST
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PPUSH
11091: CALL_OW 69
11095: ST_TO_ADDR
// if teleport then
11096: LD_VAR 0 6
11100: IFFALSE 11121
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11102: LD_VAR 0 6
11106: PUSH
11107: LD_INT 1
11109: ARRAY
11110: PPUSH
11111: LD_INT 262
11113: PPUSH
11114: LD_INT 119
11116: PPUSH
11117: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11121: LD_VAR 0 4
11125: PPUSH
11126: LD_INT 1
11128: PPUSH
11129: LD_INT 19500
11131: PPUSH
11132: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11136: LD_VAR 0 4
11140: PPUSH
11141: LD_INT 2
11143: PPUSH
11144: LD_INT 200
11146: PPUSH
11147: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11151: LD_VAR 0 4
11155: PPUSH
11156: LD_INT 3
11158: PPUSH
11159: LD_INT 650
11161: PPUSH
11162: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11166: LD_ADDR_EXP 73
11170: PUSH
11171: LD_STRING Roth
11173: PPUSH
11174: CALL_OW 25
11178: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11179: LD_ADDR_EXP 74
11183: PUSH
11184: LD_STRING Simms
11186: PPUSH
11187: LD_EXP 1
11191: NOT
11192: PPUSH
11193: LD_STRING 10c_
11195: PPUSH
11196: CALL 64203 0 3
11200: ST_TO_ADDR
// if not Simms then
11201: LD_EXP 74
11205: NOT
11206: IFFALSE 11236
// begin uc_nation := 1 ;
11208: LD_ADDR_OWVAR 21
11212: PUSH
11213: LD_INT 1
11215: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11216: LD_INT 2
11218: PPUSH
11219: LD_INT 10
11221: PPUSH
11222: CALL_OW 384
// Simms := CreateHuman ;
11226: LD_ADDR_EXP 74
11230: PUSH
11231: CALL_OW 44
11235: ST_TO_ADDR
// end ; uc_nation := 3 ;
11236: LD_ADDR_OWVAR 21
11240: PUSH
11241: LD_INT 3
11243: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11244: LD_ADDR_EXP 75
11248: PUSH
11249: LD_STRING Kirilenkova
11251: PPUSH
11252: CALL_OW 25
11256: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11257: LD_ADDR_EXP 89
11261: PUSH
11262: LD_STRING Oblukov
11264: PPUSH
11265: CALL_OW 25
11269: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11270: LD_ADDR_EXP 76
11274: PUSH
11275: LD_STRING Dolgov
11277: PPUSH
11278: CALL_OW 25
11282: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11283: LD_ADDR_EXP 77
11287: PUSH
11288: LD_STRING Petrosyan
11290: PPUSH
11291: CALL_OW 25
11295: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11296: LD_ADDR_EXP 88
11300: PUSH
11301: LD_STRING Scholtze
11303: PPUSH
11304: CALL_OW 25
11308: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11309: LD_ADDR_EXP 87
11313: PUSH
11314: LD_STRING Kapitsova
11316: PPUSH
11317: CALL_OW 25
11321: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11322: LD_ADDR_EXP 78
11326: PUSH
11327: LD_STRING Petrovova
11329: PPUSH
11330: CALL_OW 25
11334: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11335: LD_ADDR_EXP 79
11339: PUSH
11340: LD_STRING Kuzmov
11342: PPUSH
11343: CALL_OW 25
11347: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11348: LD_ADDR_EXP 86
11352: PUSH
11353: LD_STRING Karamazov
11355: PPUSH
11356: CALL_OW 25
11360: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11361: LD_STRING 13_Lipshchin_1
11363: PPUSH
11364: LD_INT 0
11366: PPUSH
11367: CALL_OW 30
11371: IFFALSE 11386
// Lipshchin := NewCharacter ( Lipshchin ) ;
11373: LD_ADDR_EXP 80
11377: PUSH
11378: LD_STRING Lipshchin
11380: PPUSH
11381: CALL_OW 25
11385: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11386: LD_STRING 13_Titov_1
11388: PPUSH
11389: LD_INT 0
11391: PPUSH
11392: CALL_OW 30
11396: IFFALSE 11411
// Titov := NewCharacter ( Titov ) ;
11398: LD_ADDR_EXP 82
11402: PUSH
11403: LD_STRING Titov
11405: PPUSH
11406: CALL_OW 25
11410: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11411: LD_STRING 13_Gnyevko_1
11413: PPUSH
11414: LD_INT 0
11416: PPUSH
11417: CALL_OW 30
11421: IFFALSE 11436
// Gnyevko := NewCharacter ( Gnyevko ) ;
11423: LD_ADDR_EXP 81
11427: PUSH
11428: LD_STRING Gnyevko
11430: PPUSH
11431: CALL_OW 25
11435: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11436: LD_STRING 13_Xavier_1
11438: PPUSH
11439: LD_INT 0
11441: PPUSH
11442: CALL_OW 30
11446: IFFALSE 11461
// Xavier := NewCharacter ( Xavier2 ) ;
11448: LD_ADDR_EXP 83
11452: PUSH
11453: LD_STRING Xavier2
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11461: LD_STRING 13_Belkov_1
11463: PPUSH
11464: LD_INT 0
11466: PPUSH
11467: CALL_OW 30
11471: IFFALSE 11486
// Belkov := NewCharacter ( Belkov ) ;
11473: LD_ADDR_EXP 84
11477: PUSH
11478: LD_STRING Belkov
11480: PPUSH
11481: CALL_OW 25
11485: ST_TO_ADDR
// if not BurlakStatus then
11486: LD_EXP 9
11490: NOT
11491: IFFALSE 11506
// Burlak = NewCharacter ( Burlak ) ;
11493: LD_ADDR_EXP 85
11497: PUSH
11498: LD_STRING Burlak
11500: PPUSH
11501: CALL_OW 25
11505: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11506: LD_ADDR_VAR 0 3
11510: PUSH
11511: LD_EXP 73
11515: PUSH
11516: LD_EXP 75
11520: PUSH
11521: LD_EXP 89
11525: PUSH
11526: LD_EXP 76
11530: PUSH
11531: LD_EXP 77
11535: PUSH
11536: LD_EXP 88
11540: PUSH
11541: LD_EXP 87
11545: PUSH
11546: LD_EXP 78
11550: PUSH
11551: LD_EXP 79
11555: PUSH
11556: LD_EXP 86
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: LIST
11565: LIST
11566: LIST
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: LIST
11572: ST_TO_ADDR
// if Simms then
11573: LD_EXP 74
11577: IFFALSE 11595
// tmp := tmp ^ Simms ;
11579: LD_ADDR_VAR 0 3
11583: PUSH
11584: LD_VAR 0 3
11588: PUSH
11589: LD_EXP 74
11593: ADD
11594: ST_TO_ADDR
// if Titov then
11595: LD_EXP 82
11599: IFFALSE 11617
// tmp := tmp ^ Titov ;
11601: LD_ADDR_VAR 0 3
11605: PUSH
11606: LD_VAR 0 3
11610: PUSH
11611: LD_EXP 82
11615: ADD
11616: ST_TO_ADDR
// if Lipshchin then
11617: LD_EXP 80
11621: IFFALSE 11639
// tmp := tmp ^ Lipshchin ;
11623: LD_ADDR_VAR 0 3
11627: PUSH
11628: LD_VAR 0 3
11632: PUSH
11633: LD_EXP 80
11637: ADD
11638: ST_TO_ADDR
// if Gnyevko then
11639: LD_EXP 81
11643: IFFALSE 11661
// tmp := tmp ^ Gnyevko ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_VAR 0 3
11654: PUSH
11655: LD_EXP 81
11659: ADD
11660: ST_TO_ADDR
// if Xavier then
11661: LD_EXP 83
11665: IFFALSE 11683
// tmp := tmp ^ Xavier ;
11667: LD_ADDR_VAR 0 3
11671: PUSH
11672: LD_VAR 0 3
11676: PUSH
11677: LD_EXP 83
11681: ADD
11682: ST_TO_ADDR
// if Belkov then
11683: LD_EXP 84
11687: IFFALSE 11705
// tmp := tmp ^ Belkov ;
11689: LD_ADDR_VAR 0 3
11693: PUSH
11694: LD_VAR 0 3
11698: PUSH
11699: LD_EXP 84
11703: ADD
11704: ST_TO_ADDR
// if Burlak then
11705: LD_EXP 85
11709: IFFALSE 11727
// tmp := tmp ^ Burlak ;
11711: LD_ADDR_VAR 0 3
11715: PUSH
11716: LD_VAR 0 3
11720: PUSH
11721: LD_EXP 85
11725: ADD
11726: ST_TO_ADDR
// for i = 1 to 8 do
11727: LD_ADDR_VAR 0 2
11731: PUSH
11732: DOUBLE
11733: LD_INT 1
11735: DEC
11736: ST_TO_ADDR
11737: LD_INT 8
11739: PUSH
11740: FOR_TO
11741: IFFALSE 11807
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11743: LD_ADDR_OWVAR 21
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: LD_INT 3
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: PUSH
11758: LD_INT 1
11760: PPUSH
11761: LD_INT 2
11763: PPUSH
11764: CALL_OW 12
11768: ARRAY
11769: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11770: LD_INT 0
11772: PPUSH
11773: LD_VAR 0 2
11777: PUSH
11778: LD_INT 2
11780: DIV
11781: PPUSH
11782: LD_INT 10
11784: PPUSH
11785: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11789: LD_ADDR_VAR 0 3
11793: PUSH
11794: LD_VAR 0 3
11798: PUSH
11799: CALL_OW 44
11803: ADD
11804: ST_TO_ADDR
// end ;
11805: GO 11740
11807: POP
11808: POP
// for i in tmp do
11809: LD_ADDR_VAR 0 2
11813: PUSH
11814: LD_VAR 0 3
11818: PUSH
11819: FOR_IN
11820: IFFALSE 11845
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11822: LD_VAR 0 2
11826: PPUSH
11827: LD_INT 260
11829: PPUSH
11830: LD_INT 235
11832: PPUSH
11833: LD_INT 8
11835: PPUSH
11836: LD_INT 0
11838: PPUSH
11839: CALL_OW 50
11843: GO 11819
11845: POP
11846: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11847: LD_ADDR_EXP 101
11851: PUSH
11852: LD_EXP 101
11856: PPUSH
11857: LD_INT 1
11859: PPUSH
11860: LD_INT 22
11862: PUSH
11863: LD_VAR 0 5
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: PUSH
11872: LD_INT 3
11874: PUSH
11875: LD_INT 21
11877: PUSH
11878: LD_INT 2
11880: PUSH
11881: EMPTY
11882: LIST
11883: LIST
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PUSH
11889: EMPTY
11890: LIST
11891: LIST
11892: PPUSH
11893: CALL_OW 69
11897: PUSH
11898: LD_EXP 73
11902: PUSH
11903: LD_EXP 74
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: DIFF
11912: PPUSH
11913: CALL_OW 1
11917: ST_TO_ADDR
// uc_side := 0 ;
11918: LD_ADDR_OWVAR 20
11922: PUSH
11923: LD_INT 0
11925: ST_TO_ADDR
// uc_nation := 0 ;
11926: LD_ADDR_OWVAR 21
11930: PUSH
11931: LD_INT 0
11933: ST_TO_ADDR
// for i = 1 to 5 do
11934: LD_ADDR_VAR 0 2
11938: PUSH
11939: DOUBLE
11940: LD_INT 1
11942: DEC
11943: ST_TO_ADDR
11944: LD_INT 5
11946: PUSH
11947: FOR_TO
11948: IFFALSE 11985
// begin InitHc ;
11950: CALL_OW 19
// hc_class := class_apeman ;
11954: LD_ADDR_OWVAR 28
11958: PUSH
11959: LD_INT 12
11961: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11962: CALL_OW 44
11966: PPUSH
11967: LD_INT 299
11969: PPUSH
11970: LD_INT 229
11972: PPUSH
11973: LD_INT 10
11975: PPUSH
11976: LD_INT 0
11978: PPUSH
11979: CALL_OW 50
// end ;
11983: GO 11947
11985: POP
11986: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11987: LD_EXP 73
11991: PPUSH
11992: LD_INT 259
11994: PPUSH
11995: LD_INT 235
11997: PPUSH
11998: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12002: LD_EXP 73
12006: PPUSH
12007: LD_INT 262
12009: PPUSH
12010: LD_INT 235
12012: PPUSH
12013: CALL_OW 178
// if Simms then
12017: LD_EXP 74
12021: IFFALSE 12052
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12023: LD_EXP 74
12027: PPUSH
12028: LD_INT 262
12030: PPUSH
12031: LD_INT 235
12033: PPUSH
12034: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12038: LD_EXP 74
12042: PPUSH
12043: LD_EXP 73
12047: PPUSH
12048: CALL_OW 179
// end ; end ;
12052: LD_VAR 0 1
12056: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12057: LD_EXP 31
12061: PUSH
12062: LD_EXP 23
12066: NOT
12067: AND
12068: IFFALSE 12244
12070: GO 12072
12072: DISABLE
12073: LD_INT 0
12075: PPUSH
12076: PPUSH
12077: PPUSH
// begin enable ;
12078: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12079: LD_ADDR_VAR 0 2
12083: PUSH
12084: LD_INT 81
12086: PUSH
12087: LD_INT 7
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: LD_INT 2
12096: PUSH
12097: LD_INT 32
12099: PUSH
12100: LD_INT 3
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 30
12109: PUSH
12110: LD_INT 30
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 30
12119: PUSH
12120: LD_INT 28
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: LD_INT 34
12129: PUSH
12130: LD_INT 49
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PUSH
12137: LD_INT 34
12139: PUSH
12140: LD_INT 10
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 34
12149: PUSH
12150: LD_INT 8
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: EMPTY
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: LIST
12164: LIST
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PPUSH
12170: CALL_OW 69
12174: ST_TO_ADDR
// if not tmp then
12175: LD_VAR 0 2
12179: NOT
12180: IFFALSE 12184
// exit ;
12182: GO 12244
// target := tmp [ rand ( 1 , tmp ) ] ;
12184: LD_ADDR_VAR 0 3
12188: PUSH
12189: LD_VAR 0 2
12193: PUSH
12194: LD_INT 1
12196: PPUSH
12197: LD_VAR 0 2
12201: PPUSH
12202: CALL_OW 12
12206: ARRAY
12207: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12208: LD_VAR 0 3
12212: PPUSH
12213: CALL_OW 255
12217: PUSH
12218: LD_INT 1
12220: EQUAL
12221: IFFALSE 12232
// CenterNowOnUnits ( target ) ;
12223: LD_VAR 0 3
12227: PPUSH
12228: CALL_OW 87
// SetLives ( target , 0 ) ;
12232: LD_VAR 0 3
12236: PPUSH
12237: LD_INT 0
12239: PPUSH
12240: CALL_OW 234
// end ;
12244: PPOPN 3
12246: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12247: LD_EXP 23
12251: NOT
12252: PUSH
12253: LD_EXP 31
12257: AND
12258: IFFALSE 12780
12260: GO 12262
12262: DISABLE
12263: LD_INT 0
12265: PPUSH
12266: PPUSH
12267: PPUSH
// begin uc_side := 7 ;
12268: LD_ADDR_OWVAR 20
12272: PUSH
12273: LD_INT 7
12275: ST_TO_ADDR
// uc_nation := 1 ;
12276: LD_ADDR_OWVAR 21
12280: PUSH
12281: LD_INT 1
12283: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12284: LD_ADDR_VAR 0 3
12288: PUSH
12289: LD_INT 125
12291: PUSH
12292: LD_INT 163
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 185
12301: PUSH
12302: LD_INT 168
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: LD_INT 111
12311: PUSH
12312: LD_INT 97
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: EMPTY
12320: LIST
12321: LIST
12322: LIST
12323: PPUSH
12324: CALL 107155 0 1
12328: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12329: LD_ADDR_EXP 90
12333: PUSH
12334: EMPTY
12335: ST_TO_ADDR
// for i = 1 to Difficulty do
12336: LD_ADDR_VAR 0 1
12340: PUSH
12341: DOUBLE
12342: LD_INT 1
12344: DEC
12345: ST_TO_ADDR
12346: LD_OWVAR 67
12350: PUSH
12351: FOR_TO
12352: IFFALSE 12510
// begin InitHc ;
12354: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12358: LD_INT 0
12360: PPUSH
12361: LD_INT 8
12363: PPUSH
12364: CALL_OW 381
// un := CreateHuman ;
12368: LD_ADDR_VAR 0 2
12372: PUSH
12373: CALL_OW 44
12377: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12378: LD_VAR 0 2
12382: PPUSH
12383: LD_INT 258
12385: PPUSH
12386: LD_INT 267
12388: PPUSH
12389: LD_INT 4
12391: PPUSH
12392: LD_INT 0
12394: PPUSH
12395: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12399: LD_ADDR_EXP 90
12403: PUSH
12404: LD_EXP 90
12408: PUSH
12409: LD_VAR 0 2
12413: UNION
12414: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12415: LD_VAR 0 2
12419: PPUSH
12420: LD_VAR 0 3
12424: PUSH
12425: LD_VAR 0 1
12429: ARRAY
12430: PUSH
12431: LD_INT 1
12433: ARRAY
12434: PPUSH
12435: LD_VAR 0 3
12439: PUSH
12440: LD_VAR 0 1
12444: ARRAY
12445: PUSH
12446: LD_INT 2
12448: ARRAY
12449: PPUSH
12450: LD_INT 4
12452: PPUSH
12453: LD_INT 1
12455: PPUSH
12456: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12460: LD_VAR 0 2
12464: PPUSH
12465: LD_VAR 0 3
12469: PUSH
12470: LD_VAR 0 1
12474: ARRAY
12475: PUSH
12476: LD_INT 1
12478: ARRAY
12479: PPUSH
12480: LD_VAR 0 3
12484: PUSH
12485: LD_VAR 0 1
12489: ARRAY
12490: PUSH
12491: LD_INT 2
12493: ARRAY
12494: PPUSH
12495: CALL_OW 171
// AddComInvisible ( un ) ;
12499: LD_VAR 0 2
12503: PPUSH
12504: CALL_OW 212
// end ;
12508: GO 12351
12510: POP
12511: POP
// repeat wait ( 0 0$20 ) ;
12512: LD_INT 700
12514: PPUSH
12515: CALL_OW 67
// for i in allianceSpecialForce do
12519: LD_ADDR_VAR 0 1
12523: PUSH
12524: LD_EXP 90
12528: PUSH
12529: FOR_IN
12530: IFFALSE 12765
// begin if IsInvisible ( i ) then
12532: LD_VAR 0 1
12536: PPUSH
12537: CALL_OW 571
12541: IFFALSE 12734
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12543: LD_ADDR_VAR 0 3
12547: PUSH
12548: LD_INT 22
12550: PUSH
12551: LD_INT 1
12553: PUSH
12554: EMPTY
12555: LIST
12556: LIST
12557: PUSH
12558: LD_INT 50
12560: PUSH
12561: EMPTY
12562: LIST
12563: PUSH
12564: LD_INT 56
12566: PUSH
12567: EMPTY
12568: LIST
12569: PUSH
12570: LD_INT 91
12572: PUSH
12573: LD_VAR 0 1
12577: PUSH
12578: LD_INT 25
12580: PUSH
12581: LD_INT 30
12583: PUSH
12584: LD_INT 35
12586: PUSH
12587: EMPTY
12588: LIST
12589: LIST
12590: LIST
12591: PUSH
12592: LD_OWVAR 67
12596: ARRAY
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: LIST
12602: PUSH
12603: LD_INT 2
12605: PUSH
12606: LD_INT 25
12608: PUSH
12609: LD_INT 1
12611: PUSH
12612: EMPTY
12613: LIST
12614: LIST
12615: PUSH
12616: LD_INT 25
12618: PUSH
12619: LD_INT 2
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PUSH
12626: LD_INT 25
12628: PUSH
12629: LD_INT 3
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: LD_INT 25
12638: PUSH
12639: LD_INT 4
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: PUSH
12646: LD_INT 25
12648: PUSH
12649: LD_INT 5
12651: PUSH
12652: EMPTY
12653: LIST
12654: LIST
12655: PUSH
12656: LD_INT 25
12658: PUSH
12659: LD_INT 8
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: PPUSH
12682: CALL_OW 69
12686: ST_TO_ADDR
// if not tmp then
12687: LD_VAR 0 3
12691: NOT
12692: IFFALSE 12696
// continue ;
12694: GO 12529
// if Prob ( 30 * Difficulty ) then
12696: LD_INT 30
12698: PUSH
12699: LD_OWVAR 67
12703: MUL
12704: PPUSH
12705: CALL_OW 13
12709: IFFALSE 12734
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12711: LD_VAR 0 3
12715: PUSH
12716: LD_INT 1
12718: PPUSH
12719: LD_VAR 0 3
12723: PPUSH
12724: CALL_OW 12
12728: ARRAY
12729: PPUSH
12730: CALL 30205 0 1
// end ; if IsDead ( i ) then
12734: LD_VAR 0 1
12738: PPUSH
12739: CALL_OW 301
12743: IFFALSE 12763
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12745: LD_ADDR_EXP 90
12749: PUSH
12750: LD_EXP 90
12754: PUSH
12755: LD_VAR 0 1
12759: DIFF
12760: ST_TO_ADDR
// continue ;
12761: GO 12529
// end ; end ;
12763: GO 12529
12765: POP
12766: POP
// until allianceDestroyed or not allianceSpecialForce ;
12767: LD_EXP 23
12771: PUSH
12772: LD_EXP 90
12776: NOT
12777: OR
12778: IFFALSE 12512
// end ;
12780: PPOPN 3
12782: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12783: LD_EXP 23
12787: NOT
12788: PUSH
12789: LD_EXP 31
12793: AND
12794: PUSH
12795: LD_INT 1
12797: PPUSH
12798: LD_INT 1
12800: PPUSH
12801: CALL 59277 0 2
12805: NOT
12806: AND
12807: IFFALSE 13774
12809: GO 12811
12811: DISABLE
12812: LD_INT 0
12814: PPUSH
12815: PPUSH
12816: PPUSH
12817: PPUSH
// begin enable ;
12818: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12819: LD_INT 22
12821: PUSH
12822: LD_INT 7
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: PUSH
12829: LD_INT 30
12831: PUSH
12832: LD_INT 3
12834: PUSH
12835: EMPTY
12836: LIST
12837: LIST
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: PPUSH
12843: CALL_OW 69
12847: NOT
12848: IFFALSE 12852
// exit ;
12850: GO 13774
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12852: LD_ADDR_VAR 0 4
12856: PUSH
12857: LD_INT 22
12859: PUSH
12860: LD_INT 7
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: PUSH
12867: LD_INT 30
12869: PUSH
12870: LD_INT 34
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: ST_TO_ADDR
// if Prob ( 40 ) then
12886: LD_INT 40
12888: PPUSH
12889: CALL_OW 13
12893: IFFALSE 13020
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12895: LD_INT 1
12897: PPUSH
12898: LD_INT 5
12900: PUSH
12901: LD_INT 3
12903: PUSH
12904: LD_INT 2
12906: PUSH
12907: LD_INT 6
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: PUSH
12916: LD_INT 5
12918: PUSH
12919: LD_INT 3
12921: PUSH
12922: LD_INT 2
12924: PUSH
12925: LD_INT 6
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: LIST
12932: LIST
12933: PUSH
12934: LD_INT 5
12936: PUSH
12937: LD_INT 3
12939: PUSH
12940: LD_INT 2
12942: PUSH
12943: LD_INT 6
12945: PUSH
12946: EMPTY
12947: LIST
12948: LIST
12949: LIST
12950: LIST
12951: PUSH
12952: LD_INT 24
12954: PUSH
12955: LD_INT 3
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: LD_INT 45
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: PUSH
12970: LD_INT 24
12972: PUSH
12973: LD_INT 3
12975: PUSH
12976: LD_INT 3
12978: PUSH
12979: LD_INT 47
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: PUSH
12988: LD_INT 24
12990: PUSH
12991: LD_INT 3
12993: PUSH
12994: LD_INT 3
12996: PUSH
12997: LD_INT 45
12999: PUSH
13000: EMPTY
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: PPUSH
13014: CALL 57859 0 2
// end else
13018: GO 13143
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13020: LD_INT 1
13022: PPUSH
13023: LD_INT 24
13025: PUSH
13026: LD_INT 3
13028: PUSH
13029: LD_INT 3
13031: PUSH
13032: LD_INT 47
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: LIST
13039: LIST
13040: PUSH
13041: LD_INT 24
13043: PUSH
13044: LD_INT 3
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: LD_INT 47
13052: PUSH
13053: EMPTY
13054: LIST
13055: LIST
13056: LIST
13057: LIST
13058: PUSH
13059: LD_INT 5
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: LD_INT 2
13067: PUSH
13068: LD_INT 9
13070: PUSH
13071: EMPTY
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: PUSH
13077: LD_INT 5
13079: PUSH
13080: LD_INT 3
13082: PUSH
13083: LD_INT 2
13085: PUSH
13086: LD_INT 9
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: LIST
13093: LIST
13094: PUSH
13095: LD_INT 24
13097: PUSH
13098: LD_INT 1
13100: PUSH
13101: LD_INT 3
13103: PUSH
13104: LD_INT 45
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: PUSH
13113: LD_INT 24
13115: PUSH
13116: LD_INT 1
13118: PUSH
13119: LD_INT 3
13121: PUSH
13122: LD_INT 45
13124: PUSH
13125: EMPTY
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: PPUSH
13139: CALL 57859 0 2
// end ; if Difficulty > 1 then
13143: LD_OWVAR 67
13147: PUSH
13148: LD_INT 1
13150: GREATER
13151: IFFALSE 13181
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13153: LD_INT 1
13155: PPUSH
13156: LD_INT 24
13158: PUSH
13159: LD_INT 3
13161: PUSH
13162: LD_INT 3
13164: PUSH
13165: LD_INT 47
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: PPUSH
13177: CALL 57859 0 2
// repeat wait ( 0 0$1 ) ;
13181: LD_INT 35
13183: PPUSH
13184: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13188: LD_INT 1
13190: PPUSH
13191: LD_INT 1
13193: PPUSH
13194: CALL 59277 0 2
13198: PUSH
13199: LD_INT 6
13201: PUSH
13202: LD_INT 7
13204: PUSH
13205: LD_INT 7
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: PUSH
13213: LD_OWVAR 67
13217: ARRAY
13218: GREATEREQUAL
13219: IFFALSE 13181
// wait ( 0 0$40 ) ;
13221: LD_INT 1400
13223: PPUSH
13224: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13228: LD_ADDR_VAR 0 2
13232: PUSH
13233: LD_INT 1
13235: PPUSH
13236: LD_INT 1
13238: PPUSH
13239: CALL 59277 0 2
13243: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13244: LD_ADDR_EXP 120
13248: PUSH
13249: LD_EXP 120
13253: PPUSH
13254: LD_INT 1
13256: PPUSH
13257: LD_EXP 120
13261: PUSH
13262: LD_INT 1
13264: ARRAY
13265: PUSH
13266: LD_VAR 0 2
13270: DIFF
13271: PPUSH
13272: CALL_OW 1
13276: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13277: LD_ADDR_VAR 0 3
13281: PUSH
13282: LD_INT 0
13284: PPUSH
13285: LD_INT 1
13287: PPUSH
13288: CALL_OW 12
13292: ST_TO_ADDR
// if target then
13293: LD_VAR 0 3
13297: IFFALSE 13463
// begin for i in tmp do
13299: LD_ADDR_VAR 0 1
13303: PUSH
13304: LD_VAR 0 2
13308: PUSH
13309: FOR_IN
13310: IFFALSE 13335
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13312: LD_VAR 0 1
13316: PPUSH
13317: LD_INT 179
13319: PPUSH
13320: LD_INT 209
13322: PPUSH
13323: LD_INT 8
13325: PPUSH
13326: LD_INT 1
13328: PPUSH
13329: CALL_OW 483
13333: GO 13309
13335: POP
13336: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13337: LD_ADDR_VAR 0 2
13341: PUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: LD_INT 24
13349: PUSH
13350: LD_INT 250
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PPUSH
13357: CALL_OW 72
13361: ST_TO_ADDR
// for i in tmp do
13362: LD_ADDR_VAR 0 1
13366: PUSH
13367: LD_VAR 0 2
13371: PUSH
13372: FOR_IN
13373: IFFALSE 13413
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13375: LD_VAR 0 1
13379: PPUSH
13380: LD_INT 179
13382: PPUSH
13383: LD_INT 209
13385: PPUSH
13386: CALL_OW 297
13390: PUSH
13391: LD_INT 9
13393: GREATER
13394: IFFALSE 13411
// ComMoveXY ( i , 179 , 209 ) ;
13396: LD_VAR 0 1
13400: PPUSH
13401: LD_INT 179
13403: PPUSH
13404: LD_INT 209
13406: PPUSH
13407: CALL_OW 111
13411: GO 13372
13413: POP
13414: POP
// wait ( 0 0$1 ) ;
13415: LD_INT 35
13417: PPUSH
13418: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13422: LD_VAR 0 2
13426: PPUSH
13427: LD_INT 92
13429: PUSH
13430: LD_INT 179
13432: PUSH
13433: LD_INT 209
13435: PUSH
13436: LD_INT 9
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: PPUSH
13445: CALL_OW 72
13449: PUSH
13450: LD_VAR 0 2
13454: PUSH
13455: LD_INT 1
13457: MINUS
13458: GREATEREQUAL
13459: IFFALSE 13337
// end else
13461: GO 13625
// begin for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13499
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13476: LD_VAR 0 1
13480: PPUSH
13481: LD_INT 285
13483: PPUSH
13484: LD_INT 163
13486: PPUSH
13487: LD_INT 8
13489: PPUSH
13490: LD_INT 1
13492: PPUSH
13493: CALL_OW 483
13497: GO 13473
13499: POP
13500: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13501: LD_ADDR_VAR 0 2
13505: PUSH
13506: LD_VAR 0 2
13510: PPUSH
13511: LD_INT 24
13513: PUSH
13514: LD_INT 250
13516: PUSH
13517: EMPTY
13518: LIST
13519: LIST
13520: PPUSH
13521: CALL_OW 72
13525: ST_TO_ADDR
// for i in tmp do
13526: LD_ADDR_VAR 0 1
13530: PUSH
13531: LD_VAR 0 2
13535: PUSH
13536: FOR_IN
13537: IFFALSE 13577
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13539: LD_VAR 0 1
13543: PPUSH
13544: LD_INT 285
13546: PPUSH
13547: LD_INT 163
13549: PPUSH
13550: CALL_OW 297
13554: PUSH
13555: LD_INT 9
13557: GREATER
13558: IFFALSE 13575
// ComMoveXY ( i , 285 , 163 ) ;
13560: LD_VAR 0 1
13564: PPUSH
13565: LD_INT 285
13567: PPUSH
13568: LD_INT 163
13570: PPUSH
13571: CALL_OW 111
13575: GO 13536
13577: POP
13578: POP
// wait ( 0 0$1 ) ;
13579: LD_INT 35
13581: PPUSH
13582: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13586: LD_VAR 0 2
13590: PPUSH
13591: LD_INT 92
13593: PUSH
13594: LD_INT 285
13596: PUSH
13597: LD_INT 163
13599: PUSH
13600: LD_INT 9
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: LIST
13607: LIST
13608: PPUSH
13609: CALL_OW 72
13613: PUSH
13614: LD_VAR 0 2
13618: PUSH
13619: LD_INT 1
13621: MINUS
13622: GREATEREQUAL
13623: IFFALSE 13501
// end ; repeat wait ( 0 0$1 ) ;
13625: LD_INT 35
13627: PPUSH
13628: CALL_OW 67
// for i in tmp do
13632: LD_ADDR_VAR 0 1
13636: PUSH
13637: LD_VAR 0 2
13641: PUSH
13642: FOR_IN
13643: IFFALSE 13765
// if GetLives ( i ) > 251 then
13645: LD_VAR 0 1
13649: PPUSH
13650: CALL_OW 256
13654: PUSH
13655: LD_INT 251
13657: GREATER
13658: IFFALSE 13747
// begin if GetWeapon ( i ) = ru_time_lapser then
13660: LD_VAR 0 1
13664: PPUSH
13665: CALL_OW 264
13669: PUSH
13670: LD_INT 49
13672: EQUAL
13673: IFFALSE 13711
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13675: LD_VAR 0 1
13679: PPUSH
13680: LD_INT 81
13682: PUSH
13683: LD_INT 7
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PPUSH
13690: CALL_OW 69
13694: PPUSH
13695: LD_VAR 0 1
13699: PPUSH
13700: CALL_OW 74
13704: PPUSH
13705: CALL_OW 112
13709: GO 13745
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13711: LD_VAR 0 1
13715: PPUSH
13716: LD_INT 81
13718: PUSH
13719: LD_INT 7
13721: PUSH
13722: EMPTY
13723: LIST
13724: LIST
13725: PPUSH
13726: CALL_OW 69
13730: PPUSH
13731: LD_VAR 0 1
13735: PPUSH
13736: CALL_OW 74
13740: PPUSH
13741: CALL_OW 115
// end else
13745: GO 13763
// tmp := tmp diff i ;
13747: LD_ADDR_VAR 0 2
13751: PUSH
13752: LD_VAR 0 2
13756: PUSH
13757: LD_VAR 0 1
13761: DIFF
13762: ST_TO_ADDR
13763: GO 13642
13765: POP
13766: POP
// until not tmp ;
13767: LD_VAR 0 2
13771: NOT
13772: IFFALSE 13625
// end ; end_of_file
13774: PPOPN 4
13776: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13777: LD_INT 0
13779: PPUSH
13780: PPUSH
13781: PPUSH
13782: PPUSH
// missionStage := 13 ;
13783: LD_ADDR_EXP 15
13787: PUSH
13788: LD_INT 13
13790: ST_TO_ADDR
// uc_side := 2 ;
13791: LD_ADDR_OWVAR 20
13795: PUSH
13796: LD_INT 2
13798: ST_TO_ADDR
// uc_nation := 2 ;
13799: LD_ADDR_OWVAR 21
13803: PUSH
13804: LD_INT 2
13806: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13807: LD_ADDR_EXP 91
13811: PUSH
13812: LD_STRING Omar
13814: PPUSH
13815: CALL_OW 25
13819: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13820: LD_EXP 91
13824: PPUSH
13825: LD_INT 4
13827: PPUSH
13828: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13832: LD_EXP 91
13836: PPUSH
13837: LD_INT 242
13839: PPUSH
13840: LD_INT 75
13842: PPUSH
13843: LD_INT 0
13845: PPUSH
13846: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13850: LD_ADDR_EXP 92
13854: PUSH
13855: LD_STRING Heike
13857: PPUSH
13858: CALL_OW 25
13862: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13863: LD_INT 14
13865: PPUSH
13866: LD_INT 3
13868: PPUSH
13869: LD_INT 1
13871: PPUSH
13872: LD_INT 27
13874: PPUSH
13875: LD_INT 100
13877: PPUSH
13878: CALL 71318 0 5
// veh := CreateVehicle ;
13882: LD_ADDR_VAR 0 3
13886: PUSH
13887: CALL_OW 45
13891: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13892: LD_VAR 0 3
13896: PPUSH
13897: LD_INT 1
13899: PPUSH
13900: CALL_OW 242
// SetDir ( veh , 4 ) ;
13904: LD_VAR 0 3
13908: PPUSH
13909: LD_INT 4
13911: PPUSH
13912: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13916: LD_VAR 0 3
13920: PPUSH
13921: LD_INT 241
13923: PPUSH
13924: LD_INT 72
13926: PPUSH
13927: LD_INT 0
13929: PPUSH
13930: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13934: LD_EXP 92
13938: PPUSH
13939: LD_VAR 0 3
13943: PPUSH
13944: CALL_OW 52
// if KhatamStatus then
13948: LD_EXP 8
13952: IFFALSE 14003
// begin Khatam := NewCharacter ( Khatam ) ;
13954: LD_ADDR_EXP 93
13958: PUSH
13959: LD_STRING Khatam
13961: PPUSH
13962: CALL_OW 25
13966: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13967: LD_EXP 93
13971: PPUSH
13972: LD_INT 245
13974: PPUSH
13975: LD_INT 78
13977: PPUSH
13978: LD_INT 3
13980: PPUSH
13981: LD_INT 0
13983: PPUSH
13984: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13988: LD_EXP 93
13992: PPUSH
13993: LD_INT 4
13995: PPUSH
13996: LD_INT 10
13998: PPUSH
13999: CALL_OW 237
// end ; for i = 1 to Difficulty do
14003: LD_ADDR_VAR 0 2
14007: PUSH
14008: DOUBLE
14009: LD_INT 1
14011: DEC
14012: ST_TO_ADDR
14013: LD_OWVAR 67
14017: PUSH
14018: FOR_TO
14019: IFFALSE 14085
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14021: LD_INT 0
14023: PPUSH
14024: LD_INT 7
14026: PUSH
14027: LD_OWVAR 67
14031: PLUS
14032: PPUSH
14033: CALL_OW 384
// un := CreateHuman ;
14037: LD_ADDR_VAR 0 4
14041: PUSH
14042: CALL_OW 44
14046: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14047: LD_VAR 0 4
14051: PPUSH
14052: LD_INT 28
14054: PUSH
14055: LD_INT 29
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: PUSH
14062: LD_VAR 0 2
14066: PUSH
14067: LD_INT 2
14069: MOD
14070: PUSH
14071: LD_INT 1
14073: PLUS
14074: ARRAY
14075: PPUSH
14076: LD_INT 0
14078: PPUSH
14079: CALL_OW 49
// end ;
14083: GO 14018
14085: POP
14086: POP
// for i = 1 to 6 do
14087: LD_ADDR_VAR 0 2
14091: PUSH
14092: DOUBLE
14093: LD_INT 1
14095: DEC
14096: ST_TO_ADDR
14097: LD_INT 6
14099: PUSH
14100: FOR_TO
14101: IFFALSE 14146
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14103: LD_INT 0
14105: PPUSH
14106: LD_INT 7
14108: PUSH
14109: LD_OWVAR 67
14113: PLUS
14114: PPUSH
14115: CALL_OW 381
// un := CreateHuman ;
14119: LD_ADDR_VAR 0 4
14123: PUSH
14124: CALL_OW 44
14128: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14129: LD_VAR 0 4
14133: PPUSH
14134: LD_INT 28
14136: PPUSH
14137: LD_INT 0
14139: PPUSH
14140: CALL_OW 49
// end ;
14144: GO 14100
14146: POP
14147: POP
// for i = 1 to 3 do
14148: LD_ADDR_VAR 0 2
14152: PUSH
14153: DOUBLE
14154: LD_INT 1
14156: DEC
14157: ST_TO_ADDR
14158: LD_INT 3
14160: PUSH
14161: FOR_TO
14162: IFFALSE 14210
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14164: LD_INT 0
14166: PPUSH
14167: LD_INT 8
14169: PPUSH
14170: LD_INT 7
14172: PUSH
14173: LD_OWVAR 67
14177: PLUS
14178: PPUSH
14179: CALL_OW 380
// un := CreateHuman ;
14183: LD_ADDR_VAR 0 4
14187: PUSH
14188: CALL_OW 44
14192: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14193: LD_VAR 0 4
14197: PPUSH
14198: LD_INT 28
14200: PPUSH
14201: LD_INT 0
14203: PPUSH
14204: CALL_OW 49
// end ;
14208: GO 14161
14210: POP
14211: POP
// for i = 1 to 3 do
14212: LD_ADDR_VAR 0 2
14216: PUSH
14217: DOUBLE
14218: LD_INT 1
14220: DEC
14221: ST_TO_ADDR
14222: LD_INT 3
14224: PUSH
14225: FOR_TO
14226: IFFALSE 14316
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14228: LD_INT 14
14230: PPUSH
14231: LD_INT 2
14233: PPUSH
14234: LD_INT 1
14236: PPUSH
14237: LD_INT 28
14239: PPUSH
14240: LD_INT 80
14242: PPUSH
14243: CALL 71318 0 5
// veh := CreateVehicle ;
14247: LD_ADDR_VAR 0 3
14251: PUSH
14252: CALL_OW 45
14256: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14257: LD_VAR 0 3
14261: PPUSH
14262: LD_INT 3
14264: PPUSH
14265: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14269: LD_VAR 0 3
14273: PPUSH
14274: LD_INT 29
14276: PPUSH
14277: LD_INT 0
14279: PPUSH
14280: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14284: LD_INT 0
14286: PPUSH
14287: LD_INT 7
14289: PUSH
14290: LD_OWVAR 67
14294: PLUS
14295: PPUSH
14296: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14300: CALL_OW 44
14304: PPUSH
14305: LD_VAR 0 3
14309: PPUSH
14310: CALL_OW 52
// end ;
14314: GO 14225
14316: POP
14317: POP
// for i = 1 to 5 + Difficulty do
14318: LD_ADDR_VAR 0 2
14322: PUSH
14323: DOUBLE
14324: LD_INT 1
14326: DEC
14327: ST_TO_ADDR
14328: LD_INT 5
14330: PUSH
14331: LD_OWVAR 67
14335: PLUS
14336: PUSH
14337: FOR_TO
14338: IFFALSE 14465
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14340: LD_INT 14
14342: PPUSH
14343: LD_INT 1
14345: PPUSH
14346: LD_INT 3
14348: PPUSH
14349: CALL_OW 12
14353: PPUSH
14354: LD_INT 1
14356: PPUSH
14357: LD_INT 28
14359: PUSH
14360: LD_INT 26
14362: PUSH
14363: LD_INT 27
14365: PUSH
14366: LD_INT 25
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: PUSH
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 4
14382: MOD
14383: PUSH
14384: LD_INT 1
14386: PLUS
14387: ARRAY
14388: PPUSH
14389: LD_INT 80
14391: PPUSH
14392: CALL 71318 0 5
// veh := CreateVehicle ;
14396: LD_ADDR_VAR 0 3
14400: PUSH
14401: CALL_OW 45
14405: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14406: LD_VAR 0 3
14410: PPUSH
14411: LD_INT 4
14413: PPUSH
14414: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14418: LD_VAR 0 3
14422: PPUSH
14423: LD_INT 28
14425: PPUSH
14426: LD_INT 0
14428: PPUSH
14429: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14433: LD_INT 0
14435: PPUSH
14436: LD_INT 7
14438: PUSH
14439: LD_OWVAR 67
14443: PLUS
14444: PPUSH
14445: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14449: CALL_OW 44
14453: PPUSH
14454: LD_VAR 0 3
14458: PPUSH
14459: CALL_OW 52
// end ;
14463: GO 14337
14465: POP
14466: POP
// for i = 1 to 3 do
14467: LD_ADDR_VAR 0 2
14471: PUSH
14472: DOUBLE
14473: LD_INT 1
14475: DEC
14476: ST_TO_ADDR
14477: LD_INT 3
14479: PUSH
14480: FOR_TO
14481: IFFALSE 14541
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14483: LD_INT 14
14485: PPUSH
14486: LD_INT 3
14488: PPUSH
14489: LD_INT 5
14491: PPUSH
14492: LD_INT 29
14494: PPUSH
14495: LD_INT 80
14497: PPUSH
14498: CALL 71318 0 5
// veh := CreateVehicle ;
14502: LD_ADDR_VAR 0 3
14506: PUSH
14507: CALL_OW 45
14511: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14512: LD_VAR 0 3
14516: PPUSH
14517: LD_INT 4
14519: PPUSH
14520: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14524: LD_VAR 0 3
14528: PPUSH
14529: LD_INT 28
14531: PPUSH
14532: LD_INT 0
14534: PPUSH
14535: CALL_OW 49
// end ;
14539: GO 14480
14541: POP
14542: POP
// end ;
14543: LD_VAR 0 1
14547: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14548: LD_INT 22
14550: PUSH
14551: LD_INT 2
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: PPUSH
14558: CALL_OW 69
14562: IFFALSE 14862
14564: GO 14566
14566: DISABLE
14567: LD_INT 0
14569: PPUSH
14570: PPUSH
14571: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14572: LD_ADDR_VAR 0 3
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 2
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 25
14589: PUSH
14590: LD_INT 4
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_EXP 93
14610: DIFF
14611: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14612: LD_ADDR_VAR 0 2
14616: PUSH
14617: LD_INT 22
14619: PUSH
14620: LD_INT 2
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PPUSH
14627: CALL_OW 69
14631: PUSH
14632: LD_EXP 93
14636: PUSH
14637: LD_VAR 0 3
14641: UNION
14642: DIFF
14643: ST_TO_ADDR
// if Khatam then
14644: LD_EXP 93
14648: IFFALSE 14665
// ComMoveXY ( Khatam , 211 , 92 ) ;
14650: LD_EXP 93
14654: PPUSH
14655: LD_INT 211
14657: PPUSH
14658: LD_INT 92
14660: PPUSH
14661: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14665: LD_INT 197
14667: PPUSH
14668: LD_INT 80
14670: PPUSH
14671: LD_INT 2
14673: PPUSH
14674: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14678: LD_INT 213
14680: PPUSH
14681: LD_INT 90
14683: PPUSH
14684: LD_INT 2
14686: PPUSH
14687: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14691: LD_INT 215
14693: PPUSH
14694: LD_INT 129
14696: PPUSH
14697: LD_INT 2
14699: PPUSH
14700: CALL_OW 441
// if sci then
14704: LD_VAR 0 3
14708: IFFALSE 14729
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14710: LD_VAR 0 3
14714: PUSH
14715: LD_INT 1
14717: ARRAY
14718: PPUSH
14719: LD_INT 197
14721: PPUSH
14722: LD_INT 80
14724: PPUSH
14725: CALL_OW 158
// if sci > 1 then
14729: LD_VAR 0 3
14733: PUSH
14734: LD_INT 1
14736: GREATER
14737: IFFALSE 14758
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14739: LD_VAR 0 3
14743: PUSH
14744: LD_INT 2
14746: ARRAY
14747: PPUSH
14748: LD_INT 213
14750: PPUSH
14751: LD_INT 90
14753: PPUSH
14754: CALL_OW 158
// if sci > 2 then
14758: LD_VAR 0 3
14762: PUSH
14763: LD_INT 2
14765: GREATER
14766: IFFALSE 14787
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14768: LD_VAR 0 3
14772: PUSH
14773: LD_INT 3
14775: ARRAY
14776: PPUSH
14777: LD_INT 215
14779: PPUSH
14780: LD_INT 129
14782: PPUSH
14783: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14787: LD_INT 35
14789: PPUSH
14790: CALL_OW 67
// for i in tmp do
14794: LD_ADDR_VAR 0 1
14798: PUSH
14799: LD_VAR 0 2
14803: PUSH
14804: FOR_IN
14805: IFFALSE 14843
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14807: LD_VAR 0 1
14811: PPUSH
14812: LD_INT 81
14814: PUSH
14815: LD_INT 2
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PPUSH
14822: CALL_OW 69
14826: PPUSH
14827: LD_VAR 0 1
14831: PPUSH
14832: CALL_OW 74
14836: PPUSH
14837: CALL_OW 115
14841: GO 14804
14843: POP
14844: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14845: LD_INT 22
14847: PUSH
14848: LD_INT 2
14850: PUSH
14851: EMPTY
14852: LIST
14853: LIST
14854: PPUSH
14855: CALL_OW 69
14859: NOT
14860: IFFALSE 14787
// end ; end_of_file
14862: PPOPN 3
14864: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14865: LD_INT 0
14867: PPUSH
14868: PPUSH
14869: PPUSH
14870: PPUSH
14871: PPUSH
14872: PPUSH
14873: PPUSH
14874: PPUSH
14875: PPUSH
// Video ( true ) ;
14876: LD_INT 1
14878: PPUSH
14879: CALL 107035 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14883: LD_ADDR_VAR 0 5
14887: PUSH
14888: LD_INT 7
14890: PPUSH
14891: LD_INT 0
14893: PPUSH
14894: CALL_OW 517
14898: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14899: LD_ADDR_VAR 0 2
14903: PUSH
14904: DOUBLE
14905: LD_INT 1
14907: DEC
14908: ST_TO_ADDR
14909: LD_VAR 0 5
14913: PUSH
14914: LD_INT 1
14916: ARRAY
14917: PUSH
14918: FOR_TO
14919: IFFALSE 14964
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14921: LD_VAR 0 5
14925: PUSH
14926: LD_INT 1
14928: ARRAY
14929: PUSH
14930: LD_VAR 0 2
14934: ARRAY
14935: PPUSH
14936: LD_VAR 0 5
14940: PUSH
14941: LD_INT 2
14943: ARRAY
14944: PUSH
14945: LD_VAR 0 2
14949: ARRAY
14950: PPUSH
14951: LD_INT 1
14953: PPUSH
14954: LD_INT 15
14956: NEG
14957: PPUSH
14958: CALL 106949 0 4
14962: GO 14918
14964: POP
14965: POP
// CenterNowOnUnits ( Powell ) ;
14966: LD_EXP 57
14970: PPUSH
14971: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14975: LD_ADDR_VAR 0 5
14979: PUSH
14980: LD_EXP 55
14984: PUSH
14985: EMPTY
14986: LIST
14987: ST_TO_ADDR
// if GirlNewVeh then
14988: LD_EXP 56
14992: IFFALSE 15010
// tmp := tmp ^ GirlNewVeh ;
14994: LD_ADDR_VAR 0 5
14998: PUSH
14999: LD_VAR 0 5
15003: PUSH
15004: LD_EXP 56
15008: ADD
15009: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15010: LD_VAR 0 5
15014: PPUSH
15015: LD_INT 60
15017: PPUSH
15018: LD_INT 109
15020: PPUSH
15021: CALL_OW 111
// if KappaStatus then
15025: LD_EXP 2
15029: IFFALSE 15081
// begin Say ( JMM , D1nT-JMM-1 ) ;
15031: LD_EXP 38
15035: PPUSH
15036: LD_STRING D1nT-JMM-1
15038: PPUSH
15039: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15043: LD_EXP 57
15047: PPUSH
15048: LD_STRING D1T-Pow-1
15050: PPUSH
15051: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15055: LD_EXP 38
15059: PPUSH
15060: LD_STRING D1T-JMM-2
15062: PPUSH
15063: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15067: LD_EXP 57
15071: PPUSH
15072: LD_STRING D1T-Pow-2
15074: PPUSH
15075: CALL_OW 88
// end else
15079: GO 15287
// if JMMGirlStatus then
15081: LD_EXP 6
15085: IFFALSE 15230
// begin Say ( JMM , D1T-JMM-1 ) ;
15087: LD_EXP 38
15091: PPUSH
15092: LD_STRING D1T-JMM-1
15094: PPUSH
15095: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15099: LD_EXP 57
15103: PPUSH
15104: LD_STRING D1T-Pow-1
15106: PPUSH
15107: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15111: LD_EXP 38
15115: PPUSH
15116: LD_STRING D1T-JMM-3
15118: PPUSH
15119: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15123: LD_EXP 57
15127: PPUSH
15128: LD_STRING D1T-Pow-3
15130: PPUSH
15131: CALL_OW 88
// if JMMGirl then
15135: LD_EXP 7
15139: IFFALSE 15228
// begin case JMMGirl of 1 :
15141: LD_EXP 7
15145: PUSH
15146: LD_INT 1
15148: DOUBLE
15149: EQUAL
15150: IFTRUE 15154
15152: GO 15169
15154: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15155: LD_EXP 39
15159: PPUSH
15160: LD_STRING D1T-Joan-3
15162: PPUSH
15163: CALL_OW 88
15167: GO 15216
15169: LD_INT 2
15171: DOUBLE
15172: EQUAL
15173: IFTRUE 15177
15175: GO 15192
15177: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15178: LD_EXP 41
15182: PPUSH
15183: LD_STRING D1T-Lisa-3
15185: PPUSH
15186: CALL_OW 88
15190: GO 15216
15192: LD_INT 3
15194: DOUBLE
15195: EQUAL
15196: IFTRUE 15200
15198: GO 15215
15200: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15201: LD_EXP 53
15205: PPUSH
15206: LD_STRING D1T-Con-3
15208: PPUSH
15209: CALL_OW 88
15213: GO 15216
15215: POP
// Say ( Powell , D1T-Pow-4 ) ;
15216: LD_EXP 57
15220: PPUSH
15221: LD_STRING D1T-Pow-4
15223: PPUSH
15224: CALL_OW 88
// end ; end else
15228: GO 15287
// if not FastEnd then
15230: LD_EXP 11
15234: NOT
15235: IFFALSE 15263
// begin Say ( JMM , D1T-JMM-4 ) ;
15237: LD_EXP 38
15241: PPUSH
15242: LD_STRING D1T-JMM-4
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15249: LD_EXP 57
15253: PPUSH
15254: LD_STRING D1T-Pow-5
15256: PPUSH
15257: CALL_OW 88
// end else
15261: GO 15287
// begin Say ( JMM , D1nT-JMM-1 ) ;
15263: LD_EXP 38
15267: PPUSH
15268: LD_STRING D1nT-JMM-1
15270: PPUSH
15271: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15275: LD_EXP 57
15279: PPUSH
15280: LD_STRING D1nT-Pow-1
15282: PPUSH
15283: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15287: LD_INT 35
15289: PPUSH
15290: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15294: LD_EXP 55
15298: PPUSH
15299: CALL_OW 314
15303: NOT
15304: IFFALSE 15287
// ComExitVehicle ( JMM ) ;
15306: LD_EXP 38
15310: PPUSH
15311: CALL_OW 121
// wait ( 3 ) ;
15315: LD_INT 3
15317: PPUSH
15318: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15322: LD_EXP 38
15326: PPUSH
15327: LD_INT 60
15329: PPUSH
15330: LD_INT 94
15332: PPUSH
15333: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15337: LD_EXP 38
15341: PPUSH
15342: LD_EXP 57
15346: PPUSH
15347: CALL_OW 179
// if Joan then
15351: LD_EXP 39
15355: IFFALSE 15409
// begin ComExitVehicle ( Joan ) ;
15357: LD_EXP 39
15361: PPUSH
15362: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15366: LD_EXP 39
15370: PPUSH
15371: LD_INT 35
15373: PPUSH
15374: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15378: LD_EXP 39
15382: PPUSH
15383: LD_INT 65
15385: PPUSH
15386: LD_INT 104
15388: PPUSH
15389: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15393: LD_EXP 39
15397: PPUSH
15398: LD_EXP 38
15402: PPUSH
15403: CALL_OW 179
// end else
15407: GO 15543
// if Lisa and JMMGirl = 2 then
15409: LD_EXP 41
15413: PUSH
15414: LD_EXP 7
15418: PUSH
15419: LD_INT 2
15421: EQUAL
15422: AND
15423: IFFALSE 15477
// begin ComExitVehicle ( Lisa ) ;
15425: LD_EXP 41
15429: PPUSH
15430: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15434: LD_EXP 41
15438: PPUSH
15439: LD_INT 35
15441: PPUSH
15442: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15446: LD_EXP 41
15450: PPUSH
15451: LD_INT 65
15453: PPUSH
15454: LD_INT 104
15456: PPUSH
15457: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15461: LD_EXP 41
15465: PPUSH
15466: LD_EXP 38
15470: PPUSH
15471: CALL_OW 179
// end else
15475: GO 15543
// if Connie and JMMGirl = 3 then
15477: LD_EXP 53
15481: PUSH
15482: LD_EXP 7
15486: PUSH
15487: LD_INT 3
15489: EQUAL
15490: AND
15491: IFFALSE 15543
// begin ComExitVehicle ( Connie ) ;
15493: LD_EXP 53
15497: PPUSH
15498: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15502: LD_EXP 53
15506: PPUSH
15507: LD_INT 35
15509: PPUSH
15510: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15514: LD_EXP 53
15518: PPUSH
15519: LD_INT 65
15521: PPUSH
15522: LD_INT 104
15524: PPUSH
15525: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15529: LD_EXP 53
15533: PPUSH
15534: LD_EXP 38
15538: PPUSH
15539: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15543: LD_INT 35
15545: PPUSH
15546: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15550: LD_EXP 38
15554: PPUSH
15555: LD_EXP 57
15559: PPUSH
15560: CALL_OW 296
15564: PUSH
15565: LD_INT 6
15567: LESS
15568: IFFALSE 15543
// wait ( 0 0$0.5 ) ;
15570: LD_INT 18
15572: PPUSH
15573: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15577: LD_EXP 38
15581: PPUSH
15582: LD_STRING D1-JMM-1
15584: PPUSH
15585: CALL_OW 88
// async ;
15589: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15590: LD_EXP 57
15594: PPUSH
15595: LD_STRING D1-Pow-1
15597: PPUSH
15598: CALL_OW 88
// if not dialogue_skipped then
15602: LD_OWVAR 59
15606: NOT
15607: IFFALSE 15616
// wait ( 0 0$2 ) ;
15609: LD_INT 70
15611: PPUSH
15612: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15616: LD_INT 170
15618: PPUSH
15619: LD_INT 99
15621: PPUSH
15622: LD_INT 1
15624: PPUSH
15625: LD_INT 6
15627: NEG
15628: PPUSH
15629: CALL 106949 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15633: LD_INT 174
15635: PPUSH
15636: LD_INT 115
15638: PPUSH
15639: LD_INT 1
15641: PPUSH
15642: LD_INT 6
15644: NEG
15645: PPUSH
15646: CALL 106949 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15650: LD_INT 169
15652: PPUSH
15653: LD_INT 71
15655: PPUSH
15656: LD_INT 1
15658: PPUSH
15659: LD_INT 6
15661: NEG
15662: PPUSH
15663: CALL 106949 0 4
// if not dialogue_skipped then
15667: LD_OWVAR 59
15671: NOT
15672: IFFALSE 15691
// begin CenterOnXY ( 170 , 99 ) ;
15674: LD_INT 170
15676: PPUSH
15677: LD_INT 99
15679: PPUSH
15680: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15684: LD_INT 80
15686: PPUSH
15687: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15691: LD_INT 75
15693: PPUSH
15694: LD_INT 53
15696: PPUSH
15697: LD_INT 1
15699: PPUSH
15700: LD_INT 9
15702: NEG
15703: PPUSH
15704: CALL 106949 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15708: LD_INT 54
15710: PPUSH
15711: LD_INT 42
15713: PPUSH
15714: LD_INT 1
15716: PPUSH
15717: LD_INT 9
15719: NEG
15720: PPUSH
15721: CALL 106949 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15725: LD_INT 62
15727: PPUSH
15728: LD_INT 51
15730: PPUSH
15731: LD_INT 1
15733: PPUSH
15734: LD_INT 9
15736: NEG
15737: PPUSH
15738: CALL 106949 0 4
// if not dialogue_skipped then
15742: LD_OWVAR 59
15746: NOT
15747: IFFALSE 15766
// begin CenterOnXY ( 75 , 53 ) ;
15749: LD_INT 75
15751: PPUSH
15752: LD_INT 53
15754: PPUSH
15755: CALL_OW 84
// wait ( 0 0$4 ) ;
15759: LD_INT 140
15761: PPUSH
15762: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15766: LD_EXP 57
15770: PPUSH
15771: CALL_OW 87
// if not dialogue_skipped then
15775: LD_OWVAR 59
15779: NOT
15780: IFFALSE 15789
// wait ( 0 0$2 ) ;
15782: LD_INT 70
15784: PPUSH
15785: CALL_OW 67
// sync ;
15789: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15790: LD_EXP 38
15794: PPUSH
15795: LD_STRING D1-JMM-2
15797: PPUSH
15798: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15802: LD_EXP 57
15806: PPUSH
15807: LD_STRING D1-Pow-2
15809: PPUSH
15810: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15814: LD_EXP 38
15818: PPUSH
15819: LD_STRING D1-JMM-3
15821: PPUSH
15822: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15826: LD_EXP 57
15830: PPUSH
15831: LD_STRING D1-Pow-3
15833: PPUSH
15834: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15838: LD_EXP 38
15842: PPUSH
15843: LD_STRING D1-JMM-4
15845: PPUSH
15846: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15850: LD_EXP 57
15854: PPUSH
15855: LD_STRING D1-Pow-4
15857: PPUSH
15858: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15862: LD_EXP 38
15866: PPUSH
15867: LD_STRING D1-JMM-5
15869: PPUSH
15870: CALL_OW 88
// async ;
15874: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15875: LD_EXP 57
15879: PPUSH
15880: LD_STRING D1-Pow-5
15882: PPUSH
15883: CALL_OW 88
// if not dialogue_skipped then
15887: LD_OWVAR 59
15891: NOT
15892: IFFALSE 15901
// wait ( 0 0$3.6 ) ;
15894: LD_INT 126
15896: PPUSH
15897: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15901: LD_INT 134
15903: PPUSH
15904: LD_INT 210
15906: PPUSH
15907: LD_INT 1
15909: PPUSH
15910: LD_INT 11
15912: NEG
15913: PPUSH
15914: CALL 106949 0 4
// if not dialogue_skipped then
15918: LD_OWVAR 59
15922: NOT
15923: IFFALSE 15942
// begin CenterOnXY ( 134 , 210 ) ;
15925: LD_INT 134
15927: PPUSH
15928: LD_INT 210
15930: PPUSH
15931: CALL_OW 84
// wait ( 0 0$2 ) ;
15935: LD_INT 70
15937: PPUSH
15938: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15942: LD_INT 101
15944: PPUSH
15945: LD_INT 159
15947: PPUSH
15948: LD_INT 1
15950: PPUSH
15951: LD_INT 10
15953: NEG
15954: PPUSH
15955: CALL 106949 0 4
// if not dialogue_skipped then
15959: LD_OWVAR 59
15963: NOT
15964: IFFALSE 15983
// begin CenterOnXY ( 101 , 159 ) ;
15966: LD_INT 101
15968: PPUSH
15969: LD_INT 159
15971: PPUSH
15972: CALL_OW 84
// wait ( 0 0$2 ) ;
15976: LD_INT 70
15978: PPUSH
15979: CALL_OW 67
// end ; sync ;
15983: SYNC
// CenterNowOnUnits ( Powell ) ;
15984: LD_EXP 57
15988: PPUSH
15989: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15993: LD_ADDR_VAR 0 6
15997: PUSH
15998: LD_INT 1
16000: PUSH
16001: LD_INT 2
16003: PUSH
16004: LD_INT 3
16006: PUSH
16007: LD_INT 4
16009: PUSH
16010: LD_INT 5
16012: PUSH
16013: LD_INT 6
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: LIST
16020: LIST
16021: LIST
16022: LIST
16023: ST_TO_ADDR
// if not dialogue_skipped then
16024: LD_OWVAR 59
16028: NOT
16029: IFFALSE 16198
// begin game_speed := 4 ;
16031: LD_ADDR_OWVAR 65
16035: PUSH
16036: LD_INT 4
16038: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16039: LD_INT 210
16041: PPUSH
16042: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16046: LD_ADDR_VAR 0 7
16050: PUSH
16051: LD_STRING Q1
16053: PPUSH
16054: LD_VAR 0 6
16058: PPUSH
16059: CALL_OW 98
16063: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16064: LD_ADDR_VAR 0 7
16068: PUSH
16069: LD_STRING Q1
16071: PPUSH
16072: LD_VAR 0 6
16076: PPUSH
16077: CALL_OW 98
16081: ST_TO_ADDR
// options = options diff dec ;
16082: LD_ADDR_VAR 0 6
16086: PUSH
16087: LD_VAR 0 6
16091: PUSH
16092: LD_VAR 0 7
16096: DIFF
16097: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16098: LD_VAR 0 7
16102: PPUSH
16103: LD_VAR 0 6
16107: PPUSH
16108: CALL 17501 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16112: LD_VAR 0 7
16116: PUSH
16117: LD_INT 5
16119: PUSH
16120: LD_INT 6
16122: PUSH
16123: EMPTY
16124: LIST
16125: LIST
16126: IN
16127: PUSH
16128: LD_VAR 0 6
16132: PUSH
16133: LD_INT 2
16135: EQUAL
16136: OR
16137: IFFALSE 16064
// if not ( dec in [ 5 , 6 ] ) then
16139: LD_VAR 0 7
16143: PUSH
16144: LD_INT 5
16146: PUSH
16147: LD_INT 6
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: IN
16154: NOT
16155: IFFALSE 16198
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16157: LD_ADDR_VAR 0 7
16161: PUSH
16162: LD_STRING Q1a
16164: PPUSH
16165: LD_INT 1
16167: PUSH
16168: LD_INT 2
16170: PUSH
16171: EMPTY
16172: LIST
16173: LIST
16174: PPUSH
16175: CALL_OW 98
16179: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16180: LD_VAR 0 7
16184: PUSH
16185: LD_INT 4
16187: PLUS
16188: PPUSH
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL 17501 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16198: LD_INT 81
16200: PPUSH
16201: LD_INT 127
16203: PPUSH
16204: CALL_OW 84
// amount := 5 ;
16208: LD_ADDR_VAR 0 8
16212: PUSH
16213: LD_INT 5
16215: ST_TO_ADDR
// macmilan_squad := [ ] ;
16216: LD_ADDR_VAR 0 9
16220: PUSH
16221: EMPTY
16222: ST_TO_ADDR
// if vip < amount then
16223: LD_EXP 58
16227: PUSH
16228: LD_VAR 0 8
16232: LESS
16233: IFFALSE 16277
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16235: LD_ADDR_VAR 0 5
16239: PUSH
16240: LD_EXP 58
16244: PUSH
16245: LD_INT 22
16247: PUSH
16248: LD_INT 4
16250: PUSH
16251: EMPTY
16252: LIST
16253: LIST
16254: PUSH
16255: LD_INT 21
16257: PUSH
16258: LD_INT 1
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PUSH
16265: EMPTY
16266: LIST
16267: LIST
16268: PPUSH
16269: CALL_OW 69
16273: UNION
16274: ST_TO_ADDR
16275: GO 16287
// tmp := vip ;
16277: LD_ADDR_VAR 0 5
16281: PUSH
16282: LD_EXP 58
16286: ST_TO_ADDR
// tmp := tmp diff Powell ;
16287: LD_ADDR_VAR 0 5
16291: PUSH
16292: LD_VAR 0 5
16296: PUSH
16297: LD_EXP 57
16301: DIFF
16302: ST_TO_ADDR
// if tmp < amount then
16303: LD_VAR 0 5
16307: PUSH
16308: LD_VAR 0 8
16312: LESS
16313: IFFALSE 16325
// amount := tmp ;
16315: LD_ADDR_VAR 0 8
16319: PUSH
16320: LD_VAR 0 5
16324: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16325: LD_VAR 0 5
16329: PUSH
16330: LD_INT 1
16332: ARRAY
16333: PPUSH
16334: CALL_OW 257
16338: PUSH
16339: LD_INT 2
16341: NONEQUAL
16342: IFFALSE 16404
// begin if IsInUnit ( tmp [ 1 ] ) then
16344: LD_VAR 0 5
16348: PUSH
16349: LD_INT 1
16351: ARRAY
16352: PPUSH
16353: CALL_OW 310
16357: IFFALSE 16372
// ComExitBuilding ( tmp [ 1 ] ) ;
16359: LD_VAR 0 5
16363: PUSH
16364: LD_INT 1
16366: ARRAY
16367: PPUSH
16368: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16372: LD_VAR 0 5
16376: PUSH
16377: LD_INT 1
16379: ARRAY
16380: PPUSH
16381: LD_INT 387
16383: PPUSH
16384: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16388: LD_VAR 0 5
16392: PUSH
16393: LD_INT 1
16395: ARRAY
16396: PPUSH
16397: LD_INT 2
16399: PPUSH
16400: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16404: LD_EXP 38
16408: PPUSH
16409: LD_INT 82
16411: PPUSH
16412: LD_INT 129
16414: PPUSH
16415: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16419: LD_EXP 38
16423: PPUSH
16424: LD_EXP 57
16428: PPUSH
16429: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16433: LD_INT 22
16435: PUSH
16436: LD_INT 1
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: PPUSH
16443: CALL_OW 69
16447: PUSH
16448: LD_EXP 38
16452: DIFF
16453: PPUSH
16454: LD_INT 84
16456: PPUSH
16457: LD_INT 128
16459: PPUSH
16460: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16464: LD_INT 22
16466: PUSH
16467: LD_INT 1
16469: PUSH
16470: EMPTY
16471: LIST
16472: LIST
16473: PPUSH
16474: CALL_OW 69
16478: PUSH
16479: LD_EXP 38
16483: DIFF
16484: PPUSH
16485: LD_EXP 38
16489: PPUSH
16490: CALL_OW 179
// for i = 1 to amount do
16494: LD_ADDR_VAR 0 2
16498: PUSH
16499: DOUBLE
16500: LD_INT 1
16502: DEC
16503: ST_TO_ADDR
16504: LD_VAR 0 8
16508: PUSH
16509: FOR_TO
16510: IFFALSE 16678
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16512: LD_ADDR_VAR 0 9
16516: PUSH
16517: LD_VAR 0 9
16521: PUSH
16522: LD_VAR 0 5
16526: PUSH
16527: LD_VAR 0 2
16531: ARRAY
16532: ADD
16533: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16534: LD_VAR 0 5
16538: PUSH
16539: LD_VAR 0 2
16543: ARRAY
16544: PPUSH
16545: CALL_OW 310
16549: IFFALSE 16566
// AddComExitBuilding ( tmp [ i ] ) ;
16551: LD_VAR 0 5
16555: PUSH
16556: LD_VAR 0 2
16560: ARRAY
16561: PPUSH
16562: CALL_OW 182
// if i = 2 and JMMNewVeh then
16566: LD_VAR 0 2
16570: PUSH
16571: LD_INT 2
16573: EQUAL
16574: PUSH
16575: LD_EXP 55
16579: AND
16580: IFFALSE 16638
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16582: LD_VAR 0 5
16586: PUSH
16587: LD_VAR 0 2
16591: ARRAY
16592: PPUSH
16593: LD_EXP 55
16597: PPUSH
16598: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16602: LD_VAR 0 5
16606: PUSH
16607: LD_VAR 0 2
16611: ARRAY
16612: PPUSH
16613: LD_INT 86
16615: PPUSH
16616: LD_INT 133
16618: PPUSH
16619: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16623: LD_VAR 0 5
16627: PUSH
16628: LD_VAR 0 2
16632: ARRAY
16633: PPUSH
16634: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16638: LD_VAR 0 5
16642: PUSH
16643: LD_VAR 0 2
16647: ARRAY
16648: PPUSH
16649: LD_INT 8
16651: PPUSH
16652: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16656: LD_VAR 0 5
16660: PUSH
16661: LD_VAR 0 2
16665: ARRAY
16666: PPUSH
16667: LD_EXP 38
16671: PPUSH
16672: CALL_OW 179
// end ;
16676: GO 16509
16678: POP
16679: POP
// if GirlNewVeh then
16680: LD_EXP 56
16684: IFFALSE 16698
// SetSide ( GirlNewVeh , 4 ) ;
16686: LD_EXP 56
16690: PPUSH
16691: LD_INT 4
16693: PPUSH
16694: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16698: LD_INT 35
16700: PPUSH
16701: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16705: LD_VAR 0 9
16709: PPUSH
16710: LD_INT 95
16712: PUSH
16713: LD_INT 9
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: PPUSH
16720: CALL_OW 72
16724: PUSH
16725: LD_INT 0
16727: EQUAL
16728: PUSH
16729: LD_EXP 38
16733: PPUSH
16734: LD_INT 9
16736: PPUSH
16737: CALL_OW 308
16741: NOT
16742: AND
16743: IFFALSE 16698
// wait ( 0 0$2 ) ;
16745: LD_INT 70
16747: PPUSH
16748: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16752: LD_VAR 0 9
16756: PPUSH
16757: LD_INT 1
16759: PPUSH
16760: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16764: LD_INT 21
16766: PUSH
16767: LD_INT 2
16769: PUSH
16770: EMPTY
16771: LIST
16772: LIST
16773: PUSH
16774: LD_INT 92
16776: PUSH
16777: LD_INT 83
16779: PUSH
16780: LD_INT 130
16782: PUSH
16783: LD_INT 10
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: PUSH
16792: EMPTY
16793: LIST
16794: LIST
16795: PPUSH
16796: CALL_OW 69
16800: PPUSH
16801: LD_INT 1
16803: PPUSH
16804: CALL_OW 235
// Video ( false ) ;
16808: LD_INT 0
16810: PPUSH
16811: CALL 107035 0 1
// ChangeMissionObjectives ( M1 ) ;
16815: LD_STRING M1
16817: PPUSH
16818: CALL_OW 337
// SaveForQuickRestart ;
16822: CALL_OW 22
// missionStart := true ;
16826: LD_ADDR_EXP 13
16830: PUSH
16831: LD_INT 1
16833: ST_TO_ADDR
// missionStage := 2 ;
16834: LD_ADDR_EXP 15
16838: PUSH
16839: LD_INT 2
16841: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16842: LD_INT 105
16844: PPUSH
16845: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16849: LD_ADDR_VAR 0 5
16853: PUSH
16854: LD_INT 22
16856: PUSH
16857: LD_INT 4
16859: PUSH
16860: EMPTY
16861: LIST
16862: LIST
16863: PUSH
16864: LD_INT 21
16866: PUSH
16867: LD_INT 1
16869: PUSH
16870: EMPTY
16871: LIST
16872: LIST
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PPUSH
16878: CALL_OW 69
16882: PUSH
16883: LD_EXP 57
16887: DIFF
16888: ST_TO_ADDR
// if not tmp then
16889: LD_VAR 0 5
16893: NOT
16894: IFFALSE 16909
// tmp := [ Powell ] ;
16896: LD_ADDR_VAR 0 5
16900: PUSH
16901: LD_EXP 57
16905: PUSH
16906: EMPTY
16907: LIST
16908: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16909: LD_ADDR_EXP 101
16913: PUSH
16914: LD_EXP 101
16918: PPUSH
16919: LD_INT 4
16921: PPUSH
16922: LD_INT 22
16924: PUSH
16925: LD_INT 4
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PUSH
16932: LD_INT 23
16934: PUSH
16935: LD_INT 1
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: PUSH
16942: LD_INT 3
16944: PUSH
16945: LD_INT 21
16947: PUSH
16948: LD_INT 2
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: PPUSH
16964: CALL_OW 69
16968: PUSH
16969: LD_EXP 57
16973: DIFF
16974: PPUSH
16975: CALL_OW 1
16979: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16980: LD_ADDR_VAR 0 4
16984: PUSH
16985: LD_INT 22
16987: PUSH
16988: LD_INT 4
16990: PUSH
16991: EMPTY
16992: LIST
16993: LIST
16994: PUSH
16995: LD_INT 34
16997: PUSH
16998: LD_INT 12
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: PPUSH
17009: CALL_OW 69
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17018: LD_VAR 0 5
17022: PUSH
17023: LD_INT 1
17025: ARRAY
17026: PPUSH
17027: CALL_OW 310
17031: IFFALSE 17046
// ComExitBuilding ( tmp [ 1 ] ) ;
17033: LD_VAR 0 5
17037: PUSH
17038: LD_INT 1
17040: ARRAY
17041: PPUSH
17042: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17046: LD_VAR 0 5
17050: PUSH
17051: LD_INT 1
17053: ARRAY
17054: PPUSH
17055: LD_VAR 0 4
17059: PPUSH
17060: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17064: LD_VAR 0 5
17068: PUSH
17069: LD_INT 1
17071: ARRAY
17072: PPUSH
17073: LD_INT 80
17075: PPUSH
17076: LD_INT 136
17078: PPUSH
17079: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17083: LD_VAR 0 5
17087: PUSH
17088: LD_INT 1
17090: ARRAY
17091: PPUSH
17092: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17096: LD_VAR 0 5
17100: PUSH
17101: LD_INT 1
17103: ARRAY
17104: PPUSH
17105: LD_INT 59
17107: PPUSH
17108: LD_INT 112
17110: PPUSH
17111: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17115: LD_VAR 0 5
17119: PUSH
17120: LD_INT 1
17122: ARRAY
17123: PPUSH
17124: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17128: LD_EXP 41
17132: PUSH
17133: LD_EXP 58
17137: IN
17138: PUSH
17139: LD_EXP 41
17143: PPUSH
17144: CALL_OW 255
17148: PUSH
17149: LD_INT 1
17151: EQUAL
17152: AND
17153: IFFALSE 17169
// Say ( Lisa , D3nW-Lisa-1 ) else
17155: LD_EXP 41
17159: PPUSH
17160: LD_STRING D3nW-Lisa-1
17162: PPUSH
17163: CALL_OW 88
17167: GO 17413
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17169: LD_EXP 44
17173: PUSH
17174: LD_EXP 58
17178: IN
17179: PUSH
17180: LD_EXP 44
17184: PPUSH
17185: CALL_OW 255
17189: PUSH
17190: LD_INT 1
17192: EQUAL
17193: AND
17194: IFFALSE 17210
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17196: LD_EXP 44
17200: PPUSH
17201: LD_STRING D3nW-Cyrus-1
17203: PPUSH
17204: CALL_OW 88
17208: GO 17413
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17210: LD_EXP 43
17214: PUSH
17215: LD_EXP 58
17219: IN
17220: PUSH
17221: LD_EXP 43
17225: PPUSH
17226: CALL_OW 255
17230: PUSH
17231: LD_INT 1
17233: EQUAL
17234: AND
17235: IFFALSE 17251
// Say ( Bobby , D3nW-Bobby-1 ) else
17237: LD_EXP 43
17241: PPUSH
17242: LD_STRING D3nW-Bobby-1
17244: PPUSH
17245: CALL_OW 88
17249: GO 17413
// if Gary in vip and GetSide ( Gary ) = 1 then
17251: LD_EXP 50
17255: PUSH
17256: LD_EXP 58
17260: IN
17261: PUSH
17262: LD_EXP 50
17266: PPUSH
17267: CALL_OW 255
17271: PUSH
17272: LD_INT 1
17274: EQUAL
17275: AND
17276: IFFALSE 17292
// Say ( Gary , D3nW-Gary-1 ) else
17278: LD_EXP 50
17282: PPUSH
17283: LD_STRING D3nW-Gary-1
17285: PPUSH
17286: CALL_OW 88
17290: GO 17413
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17292: LD_EXP 42
17296: PUSH
17297: LD_EXP 58
17301: IN
17302: PUSH
17303: LD_EXP 42
17307: PPUSH
17308: CALL_OW 255
17312: PUSH
17313: LD_INT 1
17315: EQUAL
17316: AND
17317: IFFALSE 17333
// Say ( Donaldson , D3nW-Don-1 ) else
17319: LD_EXP 42
17323: PPUSH
17324: LD_STRING D3nW-Don-1
17326: PPUSH
17327: CALL_OW 88
17331: GO 17413
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17333: LD_EXP 49
17337: PUSH
17338: LD_EXP 58
17342: IN
17343: PUSH
17344: LD_EXP 49
17348: PPUSH
17349: CALL_OW 255
17353: PUSH
17354: LD_INT 1
17356: EQUAL
17357: AND
17358: IFFALSE 17374
// Say ( Cornel , D3nW-Corn-1 ) else
17360: LD_EXP 49
17364: PPUSH
17365: LD_STRING D3nW-Corn-1
17367: PPUSH
17368: CALL_OW 88
17372: GO 17413
// if Frank in vip and GetSide ( Frank ) = 1 then
17374: LD_EXP 51
17378: PUSH
17379: LD_EXP 58
17383: IN
17384: PUSH
17385: LD_EXP 51
17389: PPUSH
17390: CALL_OW 255
17394: PUSH
17395: LD_INT 1
17397: EQUAL
17398: AND
17399: IFFALSE 17413
// Say ( Frank , D3nW-Frank-1 ) ;
17401: LD_EXP 51
17405: PPUSH
17406: LD_STRING D3nW-Frank-1
17408: PPUSH
17409: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17413: LD_EXP 38
17417: PPUSH
17418: LD_STRING D3nW-JMM-1
17420: PPUSH
17421: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17425: LD_EXP 38
17429: PPUSH
17430: LD_STRING D3nW-JMM-1a
17432: PPUSH
17433: CALL_OW 88
// t := 0 0$00 ;
17437: LD_ADDR_VAR 0 3
17441: PUSH
17442: LD_INT 0
17444: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17445: LD_INT 35
17447: PPUSH
17448: CALL_OW 67
// t := t + 0 0$1 ;
17452: LD_ADDR_VAR 0 3
17456: PUSH
17457: LD_VAR 0 3
17461: PUSH
17462: LD_INT 35
17464: PLUS
17465: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17466: LD_INT 59
17468: PPUSH
17469: LD_INT 112
17471: PPUSH
17472: CALL_OW 428
17476: PUSH
17477: LD_VAR 0 3
17481: PUSH
17482: LD_INT 2100
17484: GREATER
17485: OR
17486: IFFALSE 17445
// activeAttacks := true ;
17488: LD_ADDR_EXP 16
17492: PUSH
17493: LD_INT 1
17495: ST_TO_ADDR
// end ;
17496: LD_VAR 0 1
17500: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17501: LD_INT 0
17503: PPUSH
// case question of 1 :
17504: LD_VAR 0 1
17508: PUSH
17509: LD_INT 1
17511: DOUBLE
17512: EQUAL
17513: IFTRUE 17517
17515: GO 17568
17517: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17518: LD_EXP 38
17522: PPUSH
17523: LD_STRING D2Mot-JMM-1
17525: PPUSH
17526: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17530: LD_EXP 57
17534: PPUSH
17535: LD_STRING D2Mot-Pow-1
17537: PPUSH
17538: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17542: LD_EXP 38
17546: PPUSH
17547: LD_STRING D2Mot-JMM-2
17549: PPUSH
17550: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17554: LD_EXP 57
17558: PPUSH
17559: LD_STRING D2Mot-Pow-2
17561: PPUSH
17562: CALL_OW 88
// end ; 2 :
17566: GO 17919
17568: LD_INT 2
17570: DOUBLE
17571: EQUAL
17572: IFTRUE 17576
17574: GO 17652
17576: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17577: LD_EXP 38
17581: PPUSH
17582: LD_STRING D2Rus-JMM-1
17584: PPUSH
17585: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17589: LD_EXP 57
17593: PPUSH
17594: LD_STRING D2Rus-Pow-1
17596: PPUSH
17597: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17601: LD_EXP 38
17605: PPUSH
17606: LD_STRING D2Rus-JMM-2
17608: PPUSH
17609: CALL_OW 88
// if not ( 3 in list_of_q ) then
17613: LD_INT 3
17615: PUSH
17616: LD_VAR 0 2
17620: IN
17621: NOT
17622: IFFALSE 17638
// Say ( Powell , D2Rus-Pow-2 ) else
17624: LD_EXP 57
17628: PPUSH
17629: LD_STRING D2Rus-Pow-2
17631: PPUSH
17632: CALL_OW 88
17636: GO 17650
// Say ( Powell , D2Rus-Pow-2a ) ;
17638: LD_EXP 57
17642: PPUSH
17643: LD_STRING D2Rus-Pow-2a
17645: PPUSH
17646: CALL_OW 88
// end ; 3 :
17650: GO 17919
17652: LD_INT 3
17654: DOUBLE
17655: EQUAL
17656: IFTRUE 17660
17658: GO 17745
17660: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17661: LD_EXP 38
17665: PPUSH
17666: LD_STRING D2Leg-JMM-1
17668: PPUSH
17669: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17673: LD_EXP 57
17677: PPUSH
17678: LD_STRING D2Leg-Pow-1
17680: PPUSH
17681: CALL_OW 88
// if 2 in list_of_q then
17685: LD_INT 2
17687: PUSH
17688: LD_VAR 0 2
17692: IN
17693: IFFALSE 17719
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17695: LD_EXP 38
17699: PPUSH
17700: LD_STRING D2Leg-JMM-2
17702: PPUSH
17703: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17707: LD_EXP 57
17711: PPUSH
17712: LD_STRING D2Leg-Pow-2
17714: PPUSH
17715: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17719: LD_EXP 38
17723: PPUSH
17724: LD_STRING D2Leg-JMM-3
17726: PPUSH
17727: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17731: LD_EXP 57
17735: PPUSH
17736: LD_STRING D2Leg-Pow-3
17738: PPUSH
17739: CALL_OW 88
// end ; 4 :
17743: GO 17919
17745: LD_INT 4
17747: DOUBLE
17748: EQUAL
17749: IFTRUE 17753
17751: GO 17828
17753: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17754: LD_EXP 38
17758: PPUSH
17759: LD_STRING D2Ar-JMM-1
17761: PPUSH
17762: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17766: LD_EXP 57
17770: PPUSH
17771: LD_STRING D2Ar-Pow-1
17773: PPUSH
17774: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17778: LD_EXP 38
17782: PPUSH
17783: LD_STRING D2Ar-JMM-2
17785: PPUSH
17786: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17790: LD_EXP 57
17794: PPUSH
17795: LD_STRING D2Ar-Pow-2
17797: PPUSH
17798: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17802: LD_EXP 38
17806: PPUSH
17807: LD_STRING D2Ar-JMM-3
17809: PPUSH
17810: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17814: LD_EXP 57
17818: PPUSH
17819: LD_STRING D2Ar-Pow-3
17821: PPUSH
17822: CALL_OW 88
// end ; 5 :
17826: GO 17919
17828: LD_INT 5
17830: DOUBLE
17831: EQUAL
17832: IFTRUE 17836
17834: GO 17851
17836: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17837: LD_EXP 38
17841: PPUSH
17842: LD_STRING D2Conf-JMM-1
17844: PPUSH
17845: CALL_OW 88
17849: GO 17919
17851: LD_INT 6
17853: DOUBLE
17854: EQUAL
17855: IFTRUE 17859
17857: GO 17918
17859: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17860: LD_EXP 38
17864: PPUSH
17865: LD_STRING D2Com-JMM-1
17867: PPUSH
17868: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17872: LD_EXP 57
17876: PPUSH
17877: LD_STRING D2Com-Pow-1
17879: PPUSH
17880: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17884: LD_EXP 38
17888: PPUSH
17889: LD_STRING D2Com-JMM-2
17891: PPUSH
17892: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17896: LD_EXP 57
17900: PPUSH
17901: LD_STRING D2Com-Pow-2
17903: PPUSH
17904: CALL_OW 88
// powellAngerQuery := true ;
17908: LD_ADDR_EXP 36
17912: PUSH
17913: LD_INT 1
17915: ST_TO_ADDR
// end ; end ;
17916: GO 17919
17918: POP
// end ;
17919: LD_VAR 0 3
17923: RET
// every 0 0$5 trigger missionStart do var tmp ;
17924: LD_EXP 13
17928: IFFALSE 18211
17930: GO 17932
17932: DISABLE
17933: LD_INT 0
17935: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17936: LD_INT 35
17938: PPUSH
17939: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17943: LD_INT 14
17945: PPUSH
17946: LD_INT 22
17948: PUSH
17949: LD_INT 1
17951: PUSH
17952: EMPTY
17953: LIST
17954: LIST
17955: PPUSH
17956: CALL_OW 70
17960: PUSH
17961: LD_EXP 15
17965: PUSH
17966: LD_INT 2
17968: PUSH
17969: LD_INT 3
17971: PUSH
17972: LD_INT 4
17974: PUSH
17975: LD_INT 5
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: LIST
17982: LIST
17983: IN
17984: AND
17985: IFFALSE 18201
// begin powellAnger := powellAnger + 1 ;
17987: LD_ADDR_EXP 17
17991: PUSH
17992: LD_EXP 17
17996: PUSH
17997: LD_INT 1
17999: PLUS
18000: ST_TO_ADDR
// Video ( true ) ;
18001: LD_INT 1
18003: PPUSH
18004: CALL 107035 0 1
// CenterNowOnUnits ( tmp ) ;
18008: LD_VAR 0 1
18012: PPUSH
18013: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18017: LD_INT 14
18019: PPUSH
18020: LD_INT 22
18022: PUSH
18023: LD_INT 1
18025: PUSH
18026: EMPTY
18027: LIST
18028: LIST
18029: PPUSH
18030: CALL_OW 70
18034: PPUSH
18035: LD_INT 86
18037: PPUSH
18038: LD_INT 133
18040: PPUSH
18041: CALL_OW 111
// async ;
18045: ASYNC
// case powellAnger of 1 :
18046: LD_EXP 17
18050: PUSH
18051: LD_INT 1
18053: DOUBLE
18054: EQUAL
18055: IFTRUE 18059
18057: GO 18074
18059: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18060: LD_EXP 57
18064: PPUSH
18065: LD_STRING DBack1-Pow-1
18067: PPUSH
18068: CALL_OW 88
18072: GO 18121
18074: LD_INT 2
18076: DOUBLE
18077: EQUAL
18078: IFTRUE 18082
18080: GO 18097
18082: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18083: LD_EXP 57
18087: PPUSH
18088: LD_STRING DBack2-Pow-1
18090: PPUSH
18091: CALL_OW 88
18095: GO 18121
18097: LD_INT 3
18099: DOUBLE
18100: EQUAL
18101: IFTRUE 18105
18103: GO 18120
18105: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18106: LD_EXP 57
18110: PPUSH
18111: LD_STRING DBack3-Pow-1
18113: PPUSH
18114: CALL_OW 88
18118: GO 18121
18120: POP
// sync ;
18121: SYNC
// repeat wait ( 0 0$1 ) ;
18122: LD_INT 35
18124: PPUSH
18125: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18129: LD_INT 14
18131: PPUSH
18132: LD_INT 22
18134: PUSH
18135: LD_INT 1
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: PPUSH
18142: CALL_OW 70
18146: PPUSH
18147: LD_INT 86
18149: PPUSH
18150: LD_INT 133
18152: PPUSH
18153: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18157: LD_INT 14
18159: PPUSH
18160: LD_INT 22
18162: PUSH
18163: LD_INT 1
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: PPUSH
18170: CALL_OW 70
18174: NOT
18175: IFFALSE 18122
// if powellAnger >= 3 then
18177: LD_EXP 17
18181: PUSH
18182: LD_INT 3
18184: GREATEREQUAL
18185: IFFALSE 18194
// YouLost ( Dismissed ) ;
18187: LD_STRING Dismissed
18189: PPUSH
18190: CALL_OW 104
// Video ( false ) ;
18194: LD_INT 0
18196: PPUSH
18197: CALL 107035 0 1
// end ; until missionStage > 5 ;
18201: LD_EXP 15
18205: PUSH
18206: LD_INT 5
18208: GREATER
18209: IFFALSE 17936
// end ;
18211: PPOPN 1
18213: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18214: LD_EXP 13
18218: PUSH
18219: LD_INT 22
18221: PUSH
18222: LD_INT 4
18224: PUSH
18225: EMPTY
18226: LIST
18227: LIST
18228: PUSH
18229: LD_INT 21
18231: PUSH
18232: LD_INT 2
18234: PUSH
18235: EMPTY
18236: LIST
18237: LIST
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: PPUSH
18243: CALL_OW 69
18247: PUSH
18248: LD_INT 4
18250: GREATEREQUAL
18251: AND
18252: PUSH
18253: LD_EXP 15
18257: PUSH
18258: LD_INT 2
18260: EQUAL
18261: AND
18262: IFFALSE 20085
18264: GO 18266
18266: DISABLE
18267: LD_INT 0
18269: PPUSH
18270: PPUSH
18271: PPUSH
18272: PPUSH
18273: PPUSH
18274: PPUSH
18275: PPUSH
18276: PPUSH
// begin missionStage := 3 ;
18277: LD_ADDR_EXP 15
18281: PUSH
18282: LD_INT 3
18284: ST_TO_ADDR
// retreat := false ;
18285: LD_ADDR_VAR 0 4
18289: PUSH
18290: LD_INT 0
18292: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18293: LD_ADDR_VAR 0 5
18297: PUSH
18298: LD_INT 22
18300: PUSH
18301: LD_INT 4
18303: PUSH
18304: EMPTY
18305: LIST
18306: LIST
18307: PUSH
18308: LD_INT 30
18310: PUSH
18311: LD_INT 4
18313: PUSH
18314: EMPTY
18315: LIST
18316: LIST
18317: PUSH
18318: EMPTY
18319: LIST
18320: LIST
18321: PPUSH
18322: CALL_OW 69
18326: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18327: LD_ADDR_VAR 0 6
18331: PUSH
18332: LD_INT 22
18334: PUSH
18335: LD_INT 4
18337: PUSH
18338: EMPTY
18339: LIST
18340: LIST
18341: PUSH
18342: LD_INT 30
18344: PUSH
18345: LD_INT 5
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: PUSH
18352: EMPTY
18353: LIST
18354: LIST
18355: PPUSH
18356: CALL_OW 69
18360: ST_TO_ADDR
// if not bar then
18361: LD_VAR 0 6
18365: NOT
18366: IFFALSE 18419
// begin repeat wait ( 0 0$1 ) ;
18368: LD_INT 35
18370: PPUSH
18371: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18375: LD_INT 22
18377: PUSH
18378: LD_INT 4
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: LD_INT 3
18387: PUSH
18388: LD_INT 57
18390: PUSH
18391: EMPTY
18392: LIST
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: LD_INT 30
18400: PUSH
18401: LD_INT 5
18403: PUSH
18404: EMPTY
18405: LIST
18406: LIST
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: LIST
18412: PPUSH
18413: CALL_OW 69
18417: IFFALSE 18368
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18419: LD_ADDR_VAR 0 6
18423: PUSH
18424: LD_INT 22
18426: PUSH
18427: LD_INT 4
18429: PUSH
18430: EMPTY
18431: LIST
18432: LIST
18433: PUSH
18434: LD_INT 30
18436: PUSH
18437: LD_INT 5
18439: PUSH
18440: EMPTY
18441: LIST
18442: LIST
18443: PUSH
18444: EMPTY
18445: LIST
18446: LIST
18447: PPUSH
18448: CALL_OW 69
18452: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18453: LD_INT 35
18455: PPUSH
18456: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18460: LD_EXP 120
18464: PUSH
18465: LD_INT 4
18467: ARRAY
18468: PUSH
18469: LD_INT 4
18471: GREATEREQUAL
18472: IFFALSE 18453
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18474: LD_ADDR_VAR 0 2
18478: PUSH
18479: LD_INT 22
18481: PUSH
18482: LD_INT 4
18484: PUSH
18485: EMPTY
18486: LIST
18487: LIST
18488: PUSH
18489: LD_INT 2
18491: PUSH
18492: LD_INT 25
18494: PUSH
18495: LD_INT 1
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: PUSH
18502: LD_INT 25
18504: PUSH
18505: LD_INT 2
18507: PUSH
18508: EMPTY
18509: LIST
18510: LIST
18511: PUSH
18512: LD_INT 25
18514: PUSH
18515: LD_INT 3
18517: PUSH
18518: EMPTY
18519: LIST
18520: LIST
18521: PUSH
18522: LD_INT 25
18524: PUSH
18525: LD_INT 4
18527: PUSH
18528: EMPTY
18529: LIST
18530: LIST
18531: PUSH
18532: LD_INT 25
18534: PUSH
18535: LD_INT 5
18537: PUSH
18538: EMPTY
18539: LIST
18540: LIST
18541: PUSH
18542: EMPTY
18543: LIST
18544: LIST
18545: LIST
18546: LIST
18547: LIST
18548: LIST
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: PPUSH
18554: CALL_OW 69
18558: PUSH
18559: LD_EXP 57
18563: PUSH
18564: LD_EXP 58
18568: ADD
18569: DIFF
18570: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18571: LD_ADDR_VAR 0 3
18575: PUSH
18576: LD_VAR 0 2
18580: PPUSH
18581: LD_INT 26
18583: PUSH
18584: LD_INT 1
18586: PUSH
18587: EMPTY
18588: LIST
18589: LIST
18590: PPUSH
18591: CALL_OW 72
18595: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18596: LD_ADDR_VAR 0 2
18600: PUSH
18601: LD_VAR 0 2
18605: PUSH
18606: LD_VAR 0 3
18610: DIFF
18611: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18612: LD_ADDR_VAR 0 2
18616: PUSH
18617: LD_VAR 0 2
18621: PPUSH
18622: LD_INT 1
18624: PPUSH
18625: CALL 105688 0 2
18629: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18630: LD_ADDR_VAR 0 3
18634: PUSH
18635: LD_VAR 0 3
18639: PPUSH
18640: LD_INT 1
18642: PPUSH
18643: CALL 105688 0 2
18647: ST_TO_ADDR
// for i = 1 to 4 do
18648: LD_ADDR_VAR 0 1
18652: PUSH
18653: DOUBLE
18654: LD_INT 1
18656: DEC
18657: ST_TO_ADDR
18658: LD_INT 4
18660: PUSH
18661: FOR_TO
18662: IFFALSE 18828
// begin if tmp2 then
18664: LD_VAR 0 3
18668: IFFALSE 18749
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18670: LD_ADDR_EXP 18
18674: PUSH
18675: LD_EXP 18
18679: PPUSH
18680: LD_INT 1
18682: PPUSH
18683: LD_EXP 18
18687: PUSH
18688: LD_INT 1
18690: ARRAY
18691: PUSH
18692: LD_VAR 0 3
18696: PUSH
18697: LD_VAR 0 3
18701: ARRAY
18702: ADD
18703: PPUSH
18704: CALL_OW 1
18708: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18709: LD_VAR 0 3
18713: PUSH
18714: LD_VAR 0 3
18718: ARRAY
18719: PPUSH
18720: LD_INT 1
18722: PPUSH
18723: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18727: LD_ADDR_VAR 0 3
18731: PUSH
18732: LD_VAR 0 3
18736: PPUSH
18737: LD_VAR 0 3
18741: PPUSH
18742: CALL_OW 3
18746: ST_TO_ADDR
// end else
18747: GO 18826
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18749: LD_ADDR_EXP 18
18753: PUSH
18754: LD_EXP 18
18758: PPUSH
18759: LD_INT 1
18761: PPUSH
18762: LD_EXP 18
18766: PUSH
18767: LD_INT 1
18769: ARRAY
18770: PUSH
18771: LD_VAR 0 2
18775: PUSH
18776: LD_VAR 0 2
18780: ARRAY
18781: ADD
18782: PPUSH
18783: CALL_OW 1
18787: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18788: LD_VAR 0 2
18792: PUSH
18793: LD_VAR 0 2
18797: ARRAY
18798: PPUSH
18799: LD_INT 1
18801: PPUSH
18802: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18806: LD_ADDR_VAR 0 2
18810: PUSH
18811: LD_VAR 0 2
18815: PPUSH
18816: LD_VAR 0 2
18820: PPUSH
18821: CALL_OW 3
18825: ST_TO_ADDR
// end ; end ;
18826: GO 18661
18828: POP
18829: POP
// if tmp2 then
18830: LD_VAR 0 3
18834: IFFALSE 18852
// tmp := tmp union tmp2 ;
18836: LD_ADDR_VAR 0 2
18840: PUSH
18841: LD_VAR 0 2
18845: PUSH
18846: LD_VAR 0 3
18850: UNION
18851: ST_TO_ADDR
// for i = 1 to 4 do
18852: LD_ADDR_VAR 0 1
18856: PUSH
18857: DOUBLE
18858: LD_INT 1
18860: DEC
18861: ST_TO_ADDR
18862: LD_INT 4
18864: PUSH
18865: FOR_TO
18866: IFFALSE 18915
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18868: LD_ADDR_EXP 18
18872: PUSH
18873: LD_EXP 18
18877: PPUSH
18878: LD_INT 2
18880: PPUSH
18881: LD_EXP 18
18885: PUSH
18886: LD_INT 2
18888: ARRAY
18889: PUSH
18890: LD_VAR 0 2
18894: PUSH
18895: LD_VAR 0 2
18899: PUSH
18900: LD_VAR 0 1
18904: MINUS
18905: ARRAY
18906: ADD
18907: PPUSH
18908: CALL_OW 1
18912: ST_TO_ADDR
18913: GO 18865
18915: POP
18916: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18917: LD_ADDR_EXP 101
18921: PUSH
18922: LD_EXP 101
18926: PPUSH
18927: LD_INT 4
18929: PPUSH
18930: LD_EXP 101
18934: PUSH
18935: LD_INT 4
18937: ARRAY
18938: PUSH
18939: LD_EXP 18
18943: PUSH
18944: LD_INT 1
18946: ARRAY
18947: DIFF
18948: PPUSH
18949: CALL_OW 1
18953: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18954: LD_VAR 0 5
18958: PUSH
18959: LD_INT 1
18961: ARRAY
18962: PPUSH
18963: CALL_OW 313
18967: IFFALSE 19022
// begin for i in UnitsInside ( arm [ 1 ] ) do
18969: LD_ADDR_VAR 0 1
18973: PUSH
18974: LD_VAR 0 5
18978: PUSH
18979: LD_INT 1
18981: ARRAY
18982: PPUSH
18983: CALL_OW 313
18987: PUSH
18988: FOR_IN
18989: IFFALSE 19020
// begin ComExitBuilding ( i ) ;
18991: LD_VAR 0 1
18995: PPUSH
18996: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19000: LD_VAR 0 1
19004: PPUSH
19005: LD_VAR 0 6
19009: PUSH
19010: LD_INT 1
19012: ARRAY
19013: PPUSH
19014: CALL_OW 180
// end ;
19018: GO 18988
19020: POP
19021: POP
// end ; wait ( 0 0$3 ) ;
19022: LD_INT 105
19024: PPUSH
19025: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19029: LD_ADDR_VAR 0 1
19033: PUSH
19034: LD_EXP 18
19038: PUSH
19039: LD_INT 1
19041: ARRAY
19042: PUSH
19043: FOR_IN
19044: IFFALSE 19151
// begin if IsInUnit ( i ) then
19046: LD_VAR 0 1
19050: PPUSH
19051: CALL_OW 310
19055: IFFALSE 19066
// ComExitBuilding ( i ) ;
19057: LD_VAR 0 1
19061: PPUSH
19062: CALL_OW 122
// if GetClass ( i ) <> 1 then
19066: LD_VAR 0 1
19070: PPUSH
19071: CALL_OW 257
19075: PUSH
19076: LD_INT 1
19078: NONEQUAL
19079: IFFALSE 19120
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19081: LD_VAR 0 1
19085: PPUSH
19086: LD_VAR 0 5
19090: PUSH
19091: LD_INT 1
19093: ARRAY
19094: PPUSH
19095: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19099: LD_VAR 0 1
19103: PPUSH
19104: LD_INT 1
19106: PPUSH
19107: CALL_OW 183
// AddComExitBuilding ( i ) ;
19111: LD_VAR 0 1
19115: PPUSH
19116: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19120: LD_VAR 0 1
19124: PPUSH
19125: LD_INT 60
19127: PPUSH
19128: LD_INT 94
19130: PPUSH
19131: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19135: LD_VAR 0 1
19139: PPUSH
19140: LD_EXP 57
19144: PPUSH
19145: CALL_OW 179
// end ;
19149: GO 19043
19151: POP
19152: POP
// wait ( 0 0$15 ) ;
19153: LD_INT 525
19155: PPUSH
19156: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19160: LD_EXP 57
19164: PPUSH
19165: LD_STRING D4-Pow-1
19167: PPUSH
19168: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19172: LD_ADDR_VAR 0 2
19176: PUSH
19177: LD_EXP 18
19181: PUSH
19182: LD_INT 1
19184: ARRAY
19185: PPUSH
19186: LD_INT 26
19188: PUSH
19189: LD_INT 1
19191: PUSH
19192: EMPTY
19193: LIST
19194: LIST
19195: PPUSH
19196: CALL_OW 72
19200: ST_TO_ADDR
// if tmp then
19201: LD_VAR 0 2
19205: IFFALSE 19223
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19207: LD_VAR 0 2
19211: PUSH
19212: LD_INT 1
19214: ARRAY
19215: PPUSH
19216: LD_STRING D4-Sol1-1
19218: PPUSH
19219: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19223: LD_EXP 57
19227: PPUSH
19228: LD_STRING D4-Pow-2
19230: PPUSH
19231: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19235: LD_ADDR_VAR 0 1
19239: PUSH
19240: DOUBLE
19241: LD_INT 1
19243: DEC
19244: ST_TO_ADDR
19245: LD_EXP 18
19249: PUSH
19250: LD_INT 1
19252: ARRAY
19253: PUSH
19254: FOR_TO
19255: IFFALSE 19348
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19257: LD_EXP 18
19261: PUSH
19262: LD_INT 1
19264: ARRAY
19265: PUSH
19266: LD_VAR 0 1
19270: ARRAY
19271: PPUSH
19272: LD_EXP 120
19276: PUSH
19277: LD_INT 4
19279: ARRAY
19280: PUSH
19281: LD_INT 1
19283: ARRAY
19284: PPUSH
19285: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19289: LD_ADDR_EXP 120
19293: PUSH
19294: LD_EXP 120
19298: PPUSH
19299: LD_INT 4
19301: PPUSH
19302: LD_EXP 120
19306: PUSH
19307: LD_INT 4
19309: ARRAY
19310: PPUSH
19311: LD_INT 1
19313: PPUSH
19314: CALL_OW 3
19318: PPUSH
19319: CALL_OW 1
19323: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19324: LD_INT 8
19326: PPUSH
19327: LD_EXP 18
19331: PUSH
19332: LD_INT 1
19334: ARRAY
19335: PUSH
19336: LD_VAR 0 1
19340: ARRAY
19341: PPUSH
19342: CALL_OW 471
// end ;
19346: GO 19254
19348: POP
19349: POP
// repeat wait ( 0 0$1 ) ;
19350: LD_INT 35
19352: PPUSH
19353: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19357: LD_EXP 18
19361: PUSH
19362: LD_INT 1
19364: ARRAY
19365: PPUSH
19366: LD_INT 55
19368: PUSH
19369: EMPTY
19370: LIST
19371: PPUSH
19372: CALL_OW 72
19376: PUSH
19377: LD_INT 4
19379: GREATEREQUAL
19380: IFFALSE 19350
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19382: LD_EXP 18
19386: PUSH
19387: LD_INT 1
19389: ARRAY
19390: PPUSH
19391: LD_INT 69
19393: PPUSH
19394: LD_INT 94
19396: PPUSH
19397: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19401: LD_EXP 18
19405: PUSH
19406: LD_INT 1
19408: ARRAY
19409: PPUSH
19410: LD_INT 82
19412: PPUSH
19413: LD_INT 83
19415: PPUSH
19416: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19420: LD_EXP 18
19424: PUSH
19425: LD_INT 1
19427: ARRAY
19428: PPUSH
19429: LD_INT 77
19431: PPUSH
19432: LD_INT 69
19434: PPUSH
19435: CALL_OW 174
// repeat wait ( 3 ) ;
19439: LD_INT 3
19441: PPUSH
19442: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19446: LD_ADDR_VAR 0 1
19450: PUSH
19451: LD_EXP 18
19455: PUSH
19456: LD_INT 1
19458: ARRAY
19459: PUSH
19460: FOR_IN
19461: IFFALSE 19597
// begin if GetLives ( i ) < 990 then
19463: LD_VAR 0 1
19467: PPUSH
19468: CALL_OW 256
19472: PUSH
19473: LD_INT 990
19475: LESS
19476: IFFALSE 19490
// SetLives ( i , 1000 ) ;
19478: LD_VAR 0 1
19482: PPUSH
19483: LD_INT 1000
19485: PPUSH
19486: CALL_OW 234
// if not IsInUnit ( i ) then
19490: LD_VAR 0 1
19494: PPUSH
19495: CALL_OW 310
19499: NOT
19500: IFFALSE 19595
// begin if not HasTask ( i ) then
19502: LD_VAR 0 1
19506: PPUSH
19507: CALL_OW 314
19511: NOT
19512: IFFALSE 19529
// ComMoveXY ( i , 64 , 93 ) ;
19514: LD_VAR 0 1
19518: PPUSH
19519: LD_INT 64
19521: PPUSH
19522: LD_INT 93
19524: PPUSH
19525: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19529: LD_VAR 0 4
19533: NOT
19534: PUSH
19535: LD_VAR 0 1
19539: PPUSH
19540: CALL_OW 258
19544: PUSH
19545: LD_INT 1
19547: EQUAL
19548: AND
19549: IFFALSE 19595
// begin retreat := true ;
19551: LD_ADDR_VAR 0 4
19555: PUSH
19556: LD_INT 1
19558: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19559: LD_VAR 0 1
19563: PPUSH
19564: LD_INT 2
19566: PPUSH
19567: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19571: LD_VAR 0 1
19575: PPUSH
19576: LD_STRING D4a-Sol1-1
19578: PPUSH
19579: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19583: LD_EXP 57
19587: PPUSH
19588: LD_STRING D4a-Pow-1
19590: PPUSH
19591: CALL_OW 88
// end ; end ; end ;
19595: GO 19460
19597: POP
19598: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19599: LD_EXP 18
19603: PUSH
19604: LD_INT 1
19606: ARRAY
19607: PPUSH
19608: LD_INT 95
19610: PUSH
19611: LD_INT 9
19613: PUSH
19614: EMPTY
19615: LIST
19616: LIST
19617: PUSH
19618: LD_INT 3
19620: PUSH
19621: LD_INT 55
19623: PUSH
19624: EMPTY
19625: LIST
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: PUSH
19631: EMPTY
19632: LIST
19633: LIST
19634: PPUSH
19635: CALL_OW 72
19639: PUSH
19640: LD_INT 4
19642: GREATEREQUAL
19643: IFFALSE 19439
// for i in powellSquadAttack [ 1 ] do
19645: LD_ADDR_VAR 0 1
19649: PUSH
19650: LD_EXP 18
19654: PUSH
19655: LD_INT 1
19657: ARRAY
19658: PUSH
19659: FOR_IN
19660: IFFALSE 19796
// begin if GetTag ( i ) = 2 then
19662: LD_VAR 0 1
19666: PPUSH
19667: CALL_OW 110
19671: PUSH
19672: LD_INT 2
19674: EQUAL
19675: IFFALSE 19737
// begin ComMoveXY ( i , 60 , 94 ) ;
19677: LD_VAR 0 1
19681: PPUSH
19682: LD_INT 60
19684: PPUSH
19685: LD_INT 94
19687: PPUSH
19688: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19692: LD_VAR 0 1
19696: PPUSH
19697: LD_EXP 57
19701: PPUSH
19702: CALL_OW 179
// wait ( 0 0$3 ) ;
19706: LD_INT 105
19708: PPUSH
19709: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19713: LD_VAR 0 1
19717: PPUSH
19718: LD_STRING D4a-Sol1-2
19720: PPUSH
19721: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19725: LD_EXP 57
19729: PPUSH
19730: LD_STRING D4a-Pow-2
19732: PPUSH
19733: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19737: LD_VAR 0 1
19741: PPUSH
19742: LD_INT 0
19744: PPUSH
19745: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19749: LD_ADDR_EXP 101
19753: PUSH
19754: LD_EXP 101
19758: PPUSH
19759: LD_INT 4
19761: PPUSH
19762: LD_EXP 101
19766: PUSH
19767: LD_INT 4
19769: ARRAY
19770: PUSH
19771: LD_VAR 0 1
19775: UNION
19776: PPUSH
19777: CALL_OW 1
19781: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19782: LD_INT 8
19784: PPUSH
19785: LD_VAR 0 1
19789: PPUSH
19790: CALL_OW 472
// end ;
19794: GO 19659
19796: POP
19797: POP
// wait ( 4 4$00 ) ;
19798: LD_INT 8400
19800: PPUSH
19801: CALL_OW 67
// uc_side := 6 ;
19805: LD_ADDR_OWVAR 20
19809: PUSH
19810: LD_INT 6
19812: ST_TO_ADDR
// uc_nation := 3 ;
19813: LD_ADDR_OWVAR 21
19817: PUSH
19818: LD_INT 3
19820: ST_TO_ADDR
// ru := [ ] ;
19821: LD_ADDR_VAR 0 7
19825: PUSH
19826: EMPTY
19827: ST_TO_ADDR
// for i = 1 to 4 do
19828: LD_ADDR_VAR 0 1
19832: PUSH
19833: DOUBLE
19834: LD_INT 1
19836: DEC
19837: ST_TO_ADDR
19838: LD_INT 4
19840: PUSH
19841: FOR_TO
19842: IFFALSE 19943
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19844: LD_INT 22
19846: PPUSH
19847: LD_INT 1
19849: PPUSH
19850: LD_INT 3
19852: PPUSH
19853: LD_INT 43
19855: PUSH
19856: LD_INT 44
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: PUSH
19863: LD_INT 1
19865: PPUSH
19866: LD_INT 2
19868: PPUSH
19869: CALL_OW 12
19873: ARRAY
19874: PPUSH
19875: LD_INT 89
19877: PPUSH
19878: CALL 71318 0 5
// un := CreateVehicle ;
19882: LD_ADDR_VAR 0 8
19886: PUSH
19887: CALL_OW 45
19891: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19892: LD_VAR 0 8
19896: PPUSH
19897: LD_INT 4
19899: PPUSH
19900: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19904: LD_VAR 0 8
19908: PPUSH
19909: LD_INT 136
19911: PPUSH
19912: LD_INT 90
19914: PPUSH
19915: LD_INT 8
19917: PPUSH
19918: LD_INT 0
19920: PPUSH
19921: CALL_OW 50
// ru := ru ^ un ;
19925: LD_ADDR_VAR 0 7
19929: PUSH
19930: LD_VAR 0 7
19934: PUSH
19935: LD_VAR 0 8
19939: ADD
19940: ST_TO_ADDR
// end ;
19941: GO 19841
19943: POP
19944: POP
// if ru then
19945: LD_VAR 0 7
19949: IFFALSE 19966
// ComAgressiveMove ( ru , 80 , 92 ) ;
19951: LD_VAR 0 7
19955: PPUSH
19956: LD_INT 80
19958: PPUSH
19959: LD_INT 92
19961: PPUSH
19962: CALL_OW 114
// wait ( 8 8$00 ) ;
19966: LD_INT 16800
19968: PPUSH
19969: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19973: LD_INT 4
19975: PPUSH
19976: LD_INT 3
19978: PUSH
19979: LD_INT 1
19981: PUSH
19982: LD_INT 1
19984: PUSH
19985: LD_INT 5
19987: PUSH
19988: EMPTY
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: PUSH
19994: LD_INT 4
19996: PUSH
19997: LD_INT 1
19999: PUSH
20000: LD_INT 1
20002: PUSH
20003: LD_INT 6
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: LIST
20010: LIST
20011: PUSH
20012: LD_INT 4
20014: PUSH
20015: LD_INT 1
20017: PUSH
20018: LD_INT 1
20020: PUSH
20021: LD_INT 7
20023: PUSH
20024: EMPTY
20025: LIST
20026: LIST
20027: LIST
20028: LIST
20029: PUSH
20030: LD_INT 3
20032: PUSH
20033: LD_INT 1
20035: PUSH
20036: LD_INT 1
20038: PUSH
20039: LD_INT 7
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: LIST
20046: LIST
20047: PUSH
20048: LD_INT 3
20050: PUSH
20051: LD_INT 1
20053: PUSH
20054: LD_INT 1
20056: PUSH
20057: LD_INT 5
20059: PUSH
20060: EMPTY
20061: LIST
20062: LIST
20063: LIST
20064: LIST
20065: PUSH
20066: EMPTY
20067: LIST
20068: LIST
20069: LIST
20070: LIST
20071: LIST
20072: PPUSH
20073: CALL 57811 0 2
// missionStage := 4 ;
20077: LD_ADDR_EXP 15
20081: PUSH
20082: LD_INT 4
20084: ST_TO_ADDR
// end ;
20085: PPOPN 8
20087: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20088: LD_EXP 15
20092: PUSH
20093: LD_INT 4
20095: EQUAL
20096: PUSH
20097: LD_INT 22
20099: PUSH
20100: LD_INT 4
20102: PUSH
20103: EMPTY
20104: LIST
20105: LIST
20106: PUSH
20107: LD_INT 21
20109: PUSH
20110: LD_INT 2
20112: PUSH
20113: EMPTY
20114: LIST
20115: LIST
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PPUSH
20121: CALL_OW 69
20125: PUSH
20126: LD_INT 5
20128: GREATEREQUAL
20129: AND
20130: IFFALSE 24235
20132: GO 20134
20134: DISABLE
20135: LD_INT 0
20137: PPUSH
20138: PPUSH
20139: PPUSH
20140: PPUSH
20141: PPUSH
20142: PPUSH
20143: PPUSH
20144: PPUSH
20145: PPUSH
20146: PPUSH
20147: PPUSH
20148: PPUSH
20149: PPUSH
// begin missionStage := 5 ;
20150: LD_ADDR_EXP 15
20154: PUSH
20155: LD_INT 5
20157: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20158: LD_ADDR_VAR 0 10
20162: PUSH
20163: LD_INT 22
20165: PUSH
20166: LD_INT 4
20168: PUSH
20169: EMPTY
20170: LIST
20171: LIST
20172: PUSH
20173: LD_INT 2
20175: PUSH
20176: LD_INT 30
20178: PUSH
20179: LD_INT 4
20181: PUSH
20182: EMPTY
20183: LIST
20184: LIST
20185: PUSH
20186: LD_INT 30
20188: PUSH
20189: LD_INT 5
20191: PUSH
20192: EMPTY
20193: LIST
20194: LIST
20195: PUSH
20196: EMPTY
20197: LIST
20198: LIST
20199: LIST
20200: PUSH
20201: EMPTY
20202: LIST
20203: LIST
20204: PPUSH
20205: CALL_OW 69
20209: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20210: LD_ADDR_VAR 0 6
20214: PUSH
20215: LD_INT 22
20217: PUSH
20218: LD_INT 4
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PUSH
20225: LD_INT 21
20227: PUSH
20228: LD_INT 1
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: PUSH
20235: LD_INT 3
20237: PUSH
20238: LD_INT 25
20240: PUSH
20241: LD_INT 16
20243: PUSH
20244: EMPTY
20245: LIST
20246: LIST
20247: PUSH
20248: EMPTY
20249: LIST
20250: LIST
20251: PUSH
20252: LD_INT 3
20254: PUSH
20255: LD_INT 25
20257: PUSH
20258: LD_INT 12
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: PUSH
20265: EMPTY
20266: LIST
20267: LIST
20268: PUSH
20269: EMPTY
20270: LIST
20271: LIST
20272: LIST
20273: LIST
20274: PPUSH
20275: CALL_OW 69
20279: PUSH
20280: LD_EXP 57
20284: DIFF
20285: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20286: LD_ADDR_VAR 0 9
20290: PUSH
20291: LD_INT 22
20293: PUSH
20294: LD_INT 4
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: PUSH
20301: LD_INT 30
20303: PUSH
20304: LD_INT 3
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: PPUSH
20315: CALL_OW 69
20319: PUSH
20320: LD_INT 1
20322: ARRAY
20323: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20324: LD_INT 35
20326: PPUSH
20327: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20331: LD_EXP 120
20335: PUSH
20336: LD_INT 4
20338: ARRAY
20339: PUSH
20340: LD_INT 5
20342: GREATEREQUAL
20343: PUSH
20344: LD_EXP 120
20348: PUSH
20349: LD_INT 4
20351: ARRAY
20352: PPUSH
20353: LD_INT 58
20355: PUSH
20356: EMPTY
20357: LIST
20358: PPUSH
20359: CALL_OW 72
20363: PUSH
20364: LD_INT 5
20366: GREATEREQUAL
20367: AND
20368: IFFALSE 20324
// powellAllowRetreat := false ;
20370: LD_ADDR_EXP 19
20374: PUSH
20375: LD_INT 0
20377: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20378: LD_INT 700
20380: PPUSH
20381: CALL_OW 67
// activeAttacks := false ;
20385: LD_ADDR_EXP 16
20389: PUSH
20390: LD_INT 0
20392: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20393: LD_INT 35
20395: PPUSH
20396: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20400: LD_INT 22
20402: PUSH
20403: LD_INT 6
20405: PUSH
20406: EMPTY
20407: LIST
20408: LIST
20409: PPUSH
20410: CALL_OW 69
20414: PUSH
20415: LD_INT 0
20417: EQUAL
20418: IFFALSE 20393
// tmp := mc_vehicles [ 4 ] ;
20420: LD_ADDR_VAR 0 3
20424: PUSH
20425: LD_EXP 120
20429: PUSH
20430: LD_INT 4
20432: ARRAY
20433: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20434: LD_ADDR_VAR 0 1
20438: PUSH
20439: DOUBLE
20440: LD_INT 1
20442: DEC
20443: ST_TO_ADDR
20444: LD_EXP 18
20448: PUSH
20449: FOR_TO
20450: IFFALSE 20711
// begin for j in powellSquadAttack [ i ] do
20452: LD_ADDR_VAR 0 2
20456: PUSH
20457: LD_EXP 18
20461: PUSH
20462: LD_VAR 0 1
20466: ARRAY
20467: PUSH
20468: FOR_IN
20469: IFFALSE 20707
// begin forces := forces diff j ;
20471: LD_ADDR_VAR 0 6
20475: PUSH
20476: LD_VAR 0 6
20480: PUSH
20481: LD_VAR 0 2
20485: DIFF
20486: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20487: LD_VAR 0 2
20491: PPUSH
20492: LD_INT 1
20494: PPUSH
20495: CALL_OW 109
// wait ( 0 0$2 ) ;
20499: LD_INT 70
20501: PPUSH
20502: CALL_OW 67
// if IsInUnit ( j ) then
20506: LD_VAR 0 2
20510: PPUSH
20511: CALL_OW 310
20515: IFFALSE 20526
// ComExitBuilding ( j ) ;
20517: LD_VAR 0 2
20521: PPUSH
20522: CALL_OW 122
// if GetClass ( j ) <> 1 then
20526: LD_VAR 0 2
20530: PPUSH
20531: CALL_OW 257
20535: PUSH
20536: LD_INT 1
20538: NONEQUAL
20539: IFFALSE 20619
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20541: LD_VAR 0 10
20545: PUSH
20546: LD_INT 1
20548: ARRAY
20549: PPUSH
20550: CALL_OW 313
20554: PUSH
20555: LD_INT 5
20557: GREATEREQUAL
20558: IFFALSE 20580
// AddComEnterUnit ( j , arm [ 2 ] ) else
20560: LD_VAR 0 2
20564: PPUSH
20565: LD_VAR 0 10
20569: PUSH
20570: LD_INT 2
20572: ARRAY
20573: PPUSH
20574: CALL_OW 180
20578: GO 20598
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20580: LD_VAR 0 2
20584: PPUSH
20585: LD_VAR 0 10
20589: PUSH
20590: LD_INT 1
20592: ARRAY
20593: PPUSH
20594: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20598: LD_VAR 0 2
20602: PPUSH
20603: LD_INT 1
20605: PPUSH
20606: CALL_OW 183
// AddComExitBuilding ( j ) ;
20610: LD_VAR 0 2
20614: PPUSH
20615: CALL_OW 182
// end ; if i = 2 then
20619: LD_VAR 0 1
20623: PUSH
20624: LD_INT 2
20626: EQUAL
20627: IFFALSE 20644
// AddComMoveXY ( j , 61 , 93 ) ;
20629: LD_VAR 0 2
20633: PPUSH
20634: LD_INT 61
20636: PPUSH
20637: LD_INT 93
20639: PPUSH
20640: CALL_OW 171
// if i = 1 then
20644: LD_VAR 0 1
20648: PUSH
20649: LD_INT 1
20651: EQUAL
20652: IFFALSE 20705
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20654: LD_VAR 0 2
20658: PPUSH
20659: LD_VAR 0 3
20663: PUSH
20664: LD_INT 1
20666: ARRAY
20667: PPUSH
20668: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20672: LD_ADDR_VAR 0 3
20676: PUSH
20677: LD_VAR 0 3
20681: PPUSH
20682: LD_INT 1
20684: PPUSH
20685: CALL_OW 3
20689: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20690: LD_VAR 0 2
20694: PPUSH
20695: LD_INT 69
20697: PPUSH
20698: LD_INT 94
20700: PPUSH
20701: CALL_OW 171
// end ; end ;
20705: GO 20468
20707: POP
20708: POP
// end ;
20709: GO 20449
20711: POP
20712: POP
// wait ( 0 0$55 ) ;
20713: LD_INT 1925
20715: PPUSH
20716: CALL_OW 67
// MC_Kill ( 4 ) ;
20720: LD_INT 4
20722: PPUSH
20723: CALL 34295 0 1
// tmp := UnitsInside ( fac ) ;
20727: LD_ADDR_VAR 0 3
20731: PUSH
20732: LD_VAR 0 9
20736: PPUSH
20737: CALL_OW 313
20741: ST_TO_ADDR
// if tmp then
20742: LD_VAR 0 3
20746: IFFALSE 20867
// for i in tmp do
20748: LD_ADDR_VAR 0 1
20752: PUSH
20753: LD_VAR 0 3
20757: PUSH
20758: FOR_IN
20759: IFFALSE 20865
// begin ComExitBuilding ( i ) ;
20761: LD_VAR 0 1
20765: PPUSH
20766: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20770: LD_VAR 0 10
20774: PUSH
20775: LD_INT 2
20777: ARRAY
20778: PPUSH
20779: CALL_OW 313
20783: PUSH
20784: LD_INT 6
20786: LESS
20787: IFFALSE 20809
// AddComEnterUnit ( i , arm [ 2 ] ) else
20789: LD_VAR 0 1
20793: PPUSH
20794: LD_VAR 0 10
20798: PUSH
20799: LD_INT 2
20801: ARRAY
20802: PPUSH
20803: CALL_OW 180
20807: GO 20863
// if UnitsInside ( arm [ 1 ] ) < 6 then
20809: LD_VAR 0 10
20813: PUSH
20814: LD_INT 1
20816: ARRAY
20817: PPUSH
20818: CALL_OW 313
20822: PUSH
20823: LD_INT 6
20825: LESS
20826: IFFALSE 20848
// AddComEnterUnit ( i , arm [ 1 ] ) else
20828: LD_VAR 0 1
20832: PPUSH
20833: LD_VAR 0 10
20837: PUSH
20838: LD_INT 1
20840: ARRAY
20841: PPUSH
20842: CALL_OW 180
20846: GO 20863
// AddComMoveXY ( i , 37 , 68 ) ;
20848: LD_VAR 0 1
20852: PPUSH
20853: LD_INT 37
20855: PPUSH
20856: LD_INT 68
20858: PPUSH
20859: CALL_OW 171
// end ;
20863: GO 20758
20865: POP
20866: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20867: LD_ADDR_VAR 0 11
20871: PUSH
20872: LD_VAR 0 6
20876: PPUSH
20877: LD_INT 26
20879: PUSH
20880: LD_INT 1
20882: PUSH
20883: EMPTY
20884: LIST
20885: LIST
20886: PPUSH
20887: CALL_OW 72
20891: PUSH
20892: LD_EXP 58
20896: DIFF
20897: ST_TO_ADDR
// if not speaker then
20898: LD_VAR 0 11
20902: NOT
20903: IFFALSE 20930
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20905: LD_ADDR_VAR 0 11
20909: PUSH
20910: LD_VAR 0 6
20914: PPUSH
20915: LD_INT 26
20917: PUSH
20918: LD_INT 1
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: PPUSH
20925: CALL_OW 72
20929: ST_TO_ADDR
// if speaker then
20930: LD_VAR 0 11
20934: IFFALSE 20950
// speaker := speaker [ 1 ] ;
20936: LD_ADDR_VAR 0 11
20940: PUSH
20941: LD_VAR 0 11
20945: PUSH
20946: LD_INT 1
20948: ARRAY
20949: ST_TO_ADDR
// Video ( true ) ;
20950: LD_INT 1
20952: PPUSH
20953: CALL 107035 0 1
// CenterNowOnUnits ( Powell ) ;
20957: LD_EXP 57
20961: PPUSH
20962: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20966: LD_ADDR_VAR 0 3
20970: PUSH
20971: LD_VAR 0 6
20975: PPUSH
20976: LD_INT 3
20978: PUSH
20979: LD_INT 25
20981: PUSH
20982: LD_INT 1
20984: PUSH
20985: EMPTY
20986: LIST
20987: LIST
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: PPUSH
20993: CALL_OW 72
20997: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20998: LD_ADDR_VAR 0 12
21002: PUSH
21003: LD_INT 22
21005: PUSH
21006: LD_INT 4
21008: PUSH
21009: EMPTY
21010: LIST
21011: LIST
21012: PUSH
21013: LD_INT 30
21015: PUSH
21016: LD_INT 32
21018: PUSH
21019: EMPTY
21020: LIST
21021: LIST
21022: PUSH
21023: LD_INT 58
21025: PUSH
21026: EMPTY
21027: LIST
21028: PUSH
21029: EMPTY
21030: LIST
21031: LIST
21032: LIST
21033: PPUSH
21034: CALL_OW 69
21038: ST_TO_ADDR
// for i = 1 to 6 do
21039: LD_ADDR_VAR 0 1
21043: PUSH
21044: DOUBLE
21045: LD_INT 1
21047: DEC
21048: ST_TO_ADDR
21049: LD_INT 6
21051: PUSH
21052: FOR_TO
21053: IFFALSE 21194
// begin if IsInUnit ( tmp [ i ] ) then
21055: LD_VAR 0 3
21059: PUSH
21060: LD_VAR 0 1
21064: ARRAY
21065: PPUSH
21066: CALL_OW 310
21070: IFFALSE 21087
// ComExitBuilding ( tmp [ i ] ) ;
21072: LD_VAR 0 3
21076: PUSH
21077: LD_VAR 0 1
21081: ARRAY
21082: PPUSH
21083: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21087: LD_VAR 0 3
21091: PUSH
21092: LD_VAR 0 1
21096: ARRAY
21097: PPUSH
21098: LD_VAR 0 10
21102: PUSH
21103: LD_INT 1
21105: ARRAY
21106: PPUSH
21107: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21111: LD_VAR 0 3
21115: PUSH
21116: LD_VAR 0 1
21120: ARRAY
21121: PPUSH
21122: LD_INT 1
21124: PPUSH
21125: CALL_OW 183
// if emp_towers then
21129: LD_VAR 0 12
21133: IFFALSE 21192
// begin AddComExitBuilding ( tmp [ i ] ) ;
21135: LD_VAR 0 3
21139: PUSH
21140: LD_VAR 0 1
21144: ARRAY
21145: PPUSH
21146: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21150: LD_VAR 0 3
21154: PUSH
21155: LD_VAR 0 1
21159: ARRAY
21160: PPUSH
21161: LD_VAR 0 12
21165: PUSH
21166: LD_INT 1
21168: ARRAY
21169: PPUSH
21170: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21174: LD_ADDR_VAR 0 12
21178: PUSH
21179: LD_VAR 0 12
21183: PPUSH
21184: LD_INT 1
21186: PPUSH
21187: CALL_OW 3
21191: ST_TO_ADDR
// end ; end ;
21192: GO 21052
21194: POP
21195: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21196: LD_ADDR_VAR 0 3
21200: PUSH
21201: LD_EXP 18
21205: PUSH
21206: LD_INT 1
21208: ARRAY
21209: PUSH
21210: LD_EXP 18
21214: PUSH
21215: LD_INT 2
21217: ARRAY
21218: ADD
21219: PPUSH
21220: LD_INT 26
21222: PUSH
21223: LD_INT 1
21225: PUSH
21226: EMPTY
21227: LIST
21228: LIST
21229: PPUSH
21230: CALL_OW 72
21234: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21235: LD_ADDR_VAR 0 1
21239: PUSH
21240: LD_EXP 18
21244: PUSH
21245: LD_INT 2
21247: ARRAY
21248: PUSH
21249: FOR_IN
21250: IFFALSE 21268
// ComTurnUnit ( i , Powell ) ;
21252: LD_VAR 0 1
21256: PPUSH
21257: LD_EXP 57
21261: PPUSH
21262: CALL_OW 119
21266: GO 21249
21268: POP
21269: POP
// Say ( Powell , D5-Pow-1 ) ;
21270: LD_EXP 57
21274: PPUSH
21275: LD_STRING D5-Pow-1
21277: PPUSH
21278: CALL_OW 88
// if tmp then
21282: LD_VAR 0 3
21286: IFFALSE 21304
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21288: LD_VAR 0 3
21292: PUSH
21293: LD_INT 1
21295: ARRAY
21296: PPUSH
21297: LD_STRING D5-Sol2-1
21299: PPUSH
21300: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21304: LD_EXP 57
21308: PPUSH
21309: LD_STRING D5-Pow-2
21311: PPUSH
21312: CALL_OW 88
// if tmp > 1 then
21316: LD_VAR 0 3
21320: PUSH
21321: LD_INT 1
21323: GREATER
21324: IFFALSE 21342
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21326: LD_VAR 0 3
21330: PUSH
21331: LD_INT 2
21333: ARRAY
21334: PPUSH
21335: LD_STRING D5-Sol2-2
21337: PPUSH
21338: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21342: LD_EXP 57
21346: PPUSH
21347: LD_STRING D5-Pow-3
21349: PPUSH
21350: CALL_OW 88
// wait ( 0 0$1 ) ;
21354: LD_INT 35
21356: PPUSH
21357: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21361: LD_ADDR_VAR 0 3
21365: PUSH
21366: LD_EXP 18
21370: PUSH
21371: LD_INT 1
21373: ARRAY
21374: PUSH
21375: LD_EXP 18
21379: PUSH
21380: LD_INT 2
21382: ARRAY
21383: UNION
21384: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21385: LD_VAR 0 3
21389: PPUSH
21390: LD_INT 80
21392: PPUSH
21393: LD_INT 67
21395: PPUSH
21396: CALL_OW 114
// wait ( 0 0$2 ) ;
21400: LD_INT 70
21402: PPUSH
21403: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21407: LD_INT 79
21409: PPUSH
21410: LD_INT 72
21412: PPUSH
21413: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21417: LD_INT 35
21419: PPUSH
21420: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21424: LD_VAR 0 3
21428: PPUSH
21429: LD_INT 3
21431: PUSH
21432: LD_INT 24
21434: PUSH
21435: LD_INT 1000
21437: PUSH
21438: EMPTY
21439: LIST
21440: LIST
21441: PUSH
21442: EMPTY
21443: LIST
21444: LIST
21445: PPUSH
21446: CALL_OW 72
21450: IFFALSE 21417
// Say ( Powell , D5a-Pow-1 ) ;
21452: LD_EXP 57
21456: PPUSH
21457: LD_STRING D5a-Pow-1
21459: PPUSH
21460: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21464: LD_EXP 57
21468: PPUSH
21469: LD_STRING D5a-Pow-1a
21471: PPUSH
21472: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21476: LD_INT 10
21478: PPUSH
21479: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21483: LD_EXP 57
21487: PPUSH
21488: LD_STRING D5a-Pow-1b
21490: PPUSH
21491: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21495: LD_EXP 57
21499: PPUSH
21500: LD_STRING D5a-Pow-1c
21502: PPUSH
21503: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21507: LD_EXP 57
21511: PPUSH
21512: LD_STRING D5a-Pow-1d
21514: PPUSH
21515: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21519: LD_INT 35
21521: PPUSH
21522: CALL_OW 67
// if not HasTask ( tmp ) then
21526: LD_VAR 0 3
21530: PPUSH
21531: CALL_OW 314
21535: NOT
21536: IFFALSE 21553
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21538: LD_VAR 0 3
21542: PPUSH
21543: LD_INT 80
21545: PPUSH
21546: LD_INT 67
21548: PPUSH
21549: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21553: LD_VAR 0 3
21557: PPUSH
21558: LD_INT 24
21560: PUSH
21561: LD_INT 1
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: PPUSH
21568: CALL_OW 72
21572: NOT
21573: IFFALSE 21519
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21575: LD_ADDR_VAR 0 3
21579: PUSH
21580: LD_INT 22
21582: PUSH
21583: LD_INT 4
21585: PUSH
21586: EMPTY
21587: LIST
21588: LIST
21589: PUSH
21590: LD_INT 92
21592: PUSH
21593: LD_INT 60
21595: PUSH
21596: LD_INT 93
21598: PUSH
21599: LD_INT 10
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: LIST
21606: LIST
21607: PUSH
21608: LD_INT 3
21610: PUSH
21611: LD_INT 54
21613: PUSH
21614: EMPTY
21615: LIST
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: LIST
21625: PPUSH
21626: CALL_OW 69
21630: PUSH
21631: LD_EXP 57
21635: DIFF
21636: ST_TO_ADDR
// if tmp then
21637: LD_VAR 0 3
21641: IFFALSE 21675
// for i in tmp do
21643: LD_ADDR_VAR 0 1
21647: PUSH
21648: LD_VAR 0 3
21652: PUSH
21653: FOR_IN
21654: IFFALSE 21673
// ComMoveXY ( i , 36 , 67 ) ;
21656: LD_VAR 0 1
21660: PPUSH
21661: LD_INT 36
21663: PPUSH
21664: LD_INT 67
21666: PPUSH
21667: CALL_OW 111
21671: GO 21653
21673: POP
21674: POP
// wait ( 0 0$3 ) ;
21675: LD_INT 105
21677: PPUSH
21678: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21682: LD_VAR 0 11
21686: PPUSH
21687: LD_STRING D6-Sol3-1
21689: PPUSH
21690: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21694: LD_EXP 57
21698: PPUSH
21699: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21703: LD_EXP 57
21707: PPUSH
21708: LD_STRING D6-Pow-1
21710: PPUSH
21711: CALL_OW 88
// tmp := [ ] ;
21715: LD_ADDR_VAR 0 3
21719: PUSH
21720: EMPTY
21721: ST_TO_ADDR
// for i = 1 to 2 do
21722: LD_ADDR_VAR 0 1
21726: PUSH
21727: DOUBLE
21728: LD_INT 1
21730: DEC
21731: ST_TO_ADDR
21732: LD_INT 2
21734: PUSH
21735: FOR_TO
21736: IFFALSE 21850
// begin uc_side := 8 ;
21738: LD_ADDR_OWVAR 20
21742: PUSH
21743: LD_INT 8
21745: ST_TO_ADDR
// uc_nation := 2 ;
21746: LD_ADDR_OWVAR 21
21750: PUSH
21751: LD_INT 2
21753: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21754: LD_INT 14
21756: PPUSH
21757: LD_INT 3
21759: PPUSH
21760: LD_INT 2
21762: PPUSH
21763: LD_INT 29
21765: PPUSH
21766: LD_INT 100
21768: PPUSH
21769: CALL 71318 0 5
// veh := CreateVehicle ;
21773: LD_ADDR_VAR 0 13
21777: PUSH
21778: CALL_OW 45
21782: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21783: LD_VAR 0 13
21787: PPUSH
21788: LD_INT 4
21790: PPUSH
21791: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21795: LD_VAR 0 13
21799: PPUSH
21800: LD_INT 99
21802: PPUSH
21803: LD_INT 83
21805: PPUSH
21806: LD_INT 6
21808: PPUSH
21809: LD_INT 0
21811: PPUSH
21812: CALL_OW 50
// wait ( 3 ) ;
21816: LD_INT 3
21818: PPUSH
21819: CALL_OW 67
// Connect ( veh ) ;
21823: LD_VAR 0 13
21827: PPUSH
21828: CALL 74373 0 1
// tmp := tmp ^ veh ;
21832: LD_ADDR_VAR 0 3
21836: PUSH
21837: LD_VAR 0 3
21841: PUSH
21842: LD_VAR 0 13
21846: ADD
21847: ST_TO_ADDR
// end ;
21848: GO 21735
21850: POP
21851: POP
// wait ( 0 0$1 ) ;
21852: LD_INT 35
21854: PPUSH
21855: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21859: LD_INT 99
21861: PPUSH
21862: LD_INT 83
21864: PPUSH
21865: LD_INT 1
21867: PPUSH
21868: LD_INT 10
21870: PPUSH
21871: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21875: LD_INT 99
21877: PPUSH
21878: LD_INT 83
21880: PPUSH
21881: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21885: LD_VAR 0 11
21889: PPUSH
21890: LD_STRING D6-Sol3-2
21892: PPUSH
21893: CALL_OW 88
// async ;
21897: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21898: LD_EXP 57
21902: PPUSH
21903: LD_STRING D6-Pow-2
21905: PPUSH
21906: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21910: LD_VAR 0 3
21914: PUSH
21915: LD_INT 1
21917: ARRAY
21918: PPUSH
21919: LD_VAR 0 9
21923: PPUSH
21924: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21928: LD_VAR 0 3
21932: PUSH
21933: LD_INT 2
21935: ARRAY
21936: PPUSH
21937: LD_INT 22
21939: PUSH
21940: LD_INT 4
21942: PUSH
21943: EMPTY
21944: LIST
21945: LIST
21946: PUSH
21947: LD_INT 21
21949: PUSH
21950: LD_INT 3
21952: PUSH
21953: EMPTY
21954: LIST
21955: LIST
21956: PUSH
21957: EMPTY
21958: LIST
21959: LIST
21960: PPUSH
21961: CALL_OW 69
21965: PPUSH
21966: LD_VAR 0 3
21970: PUSH
21971: LD_INT 2
21973: ARRAY
21974: PPUSH
21975: CALL_OW 74
21979: PPUSH
21980: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21984: LD_EXP 57
21988: PPUSH
21989: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21993: LD_INT 99
21995: PPUSH
21996: LD_INT 83
21998: PPUSH
21999: LD_INT 1
22001: PPUSH
22002: CALL_OW 331
// repeat wait ( 4 ) ;
22006: LD_INT 4
22008: PPUSH
22009: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22013: LD_VAR 0 3
22017: PUSH
22018: LD_INT 1
22020: ARRAY
22021: PPUSH
22022: CALL_OW 256
22026: PUSH
22027: LD_INT 1000
22029: LESS
22030: IFFALSE 22048
// SetLives ( tmp [ 1 ] , 1000 ) ;
22032: LD_VAR 0 3
22036: PUSH
22037: LD_INT 1
22039: ARRAY
22040: PPUSH
22041: LD_INT 1000
22043: PPUSH
22044: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22048: LD_INT 22
22050: PUSH
22051: LD_INT 4
22053: PUSH
22054: EMPTY
22055: LIST
22056: LIST
22057: PUSH
22058: LD_INT 30
22060: PUSH
22061: LD_INT 3
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: PUSH
22068: EMPTY
22069: LIST
22070: LIST
22071: PPUSH
22072: CALL_OW 69
22076: PUSH
22077: LD_INT 0
22079: EQUAL
22080: IFFALSE 22006
// sync ;
22082: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22083: LD_EXP 57
22087: PPUSH
22088: LD_STRING D6a-Pow-1
22090: PPUSH
22091: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22095: LD_VAR 0 11
22099: PPUSH
22100: LD_STRING D6a-Sol3-1
22102: PPUSH
22103: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22107: LD_EXP 57
22111: PPUSH
22112: LD_STRING D6a-Pow-2
22114: PPUSH
22115: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22119: LD_VAR 0 11
22123: PPUSH
22124: LD_STRING D6a-Sol3-2
22126: PPUSH
22127: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22131: LD_EXP 57
22135: PPUSH
22136: LD_STRING D6a-Pow-3
22138: PPUSH
22139: CALL_OW 88
// powellCenterCameraMode := true ;
22143: LD_ADDR_EXP 20
22147: PUSH
22148: LD_INT 1
22150: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22151: LD_ADDR_VAR 0 1
22155: PUSH
22156: LD_INT 22
22158: PUSH
22159: LD_INT 8
22161: PUSH
22162: EMPTY
22163: LIST
22164: LIST
22165: PUSH
22166: LD_INT 25
22168: PUSH
22169: LD_INT 2
22171: PUSH
22172: EMPTY
22173: LIST
22174: LIST
22175: PUSH
22176: EMPTY
22177: LIST
22178: LIST
22179: PPUSH
22180: CALL_OW 69
22184: PUSH
22185: FOR_IN
22186: IFFALSE 22241
// begin SetTag ( i , 1 ) ;
22188: LD_VAR 0 1
22192: PPUSH
22193: LD_INT 1
22195: PPUSH
22196: CALL_OW 109
// ComExitBuilding ( i ) ;
22200: LD_VAR 0 1
22204: PPUSH
22205: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22209: LD_VAR 0 1
22213: PPUSH
22214: LD_INT 35
22216: PPUSH
22217: LD_INT 6
22219: PPUSH
22220: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22224: LD_VAR 0 1
22228: PPUSH
22229: LD_INT 53
22231: PPUSH
22232: LD_INT 4
22234: PPUSH
22235: CALL_OW 171
// end ;
22239: GO 22185
22241: POP
22242: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22243: LD_ADDR_VAR 0 3
22247: PUSH
22248: LD_INT 22
22250: PUSH
22251: LD_INT 4
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: PUSH
22258: LD_INT 21
22260: PUSH
22261: LD_INT 2
22263: PUSH
22264: EMPTY
22265: LIST
22266: LIST
22267: PUSH
22268: LD_INT 3
22270: PUSH
22271: LD_INT 34
22273: PUSH
22274: LD_INT 12
22276: PUSH
22277: EMPTY
22278: LIST
22279: LIST
22280: PUSH
22281: EMPTY
22282: LIST
22283: LIST
22284: PUSH
22285: EMPTY
22286: LIST
22287: LIST
22288: LIST
22289: PPUSH
22290: CALL_OW 69
22294: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22295: LD_EXP 57
22299: PPUSH
22300: LD_VAR 0 3
22304: PPUSH
22305: LD_EXP 57
22309: PPUSH
22310: CALL_OW 74
22314: PPUSH
22315: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22319: LD_EXP 57
22323: PPUSH
22324: LD_INT 100
22326: PPUSH
22327: LD_INT 88
22329: PPUSH
22330: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22334: LD_EXP 57
22338: PPUSH
22339: LD_INT 100
22341: PPUSH
22342: LD_INT 75
22344: PPUSH
22345: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22349: LD_EXP 57
22353: PPUSH
22354: LD_INT 88
22356: PPUSH
22357: LD_INT 53
22359: PPUSH
22360: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22364: LD_INT 8
22366: PPUSH
22367: LD_EXP 57
22371: PPUSH
22372: CALL_OW 471
// repeat wait ( 3 ) ;
22376: LD_INT 3
22378: PPUSH
22379: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22383: LD_INT 22
22385: PUSH
22386: LD_INT 4
22388: PUSH
22389: EMPTY
22390: LIST
22391: LIST
22392: PUSH
22393: LD_INT 92
22395: PUSH
22396: LD_INT 100
22398: PUSH
22399: LD_INT 75
22401: PUSH
22402: LD_INT 6
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: LIST
22409: LIST
22410: PUSH
22411: EMPTY
22412: LIST
22413: LIST
22414: PPUSH
22415: CALL_OW 69
22419: IFFALSE 22376
// async ;
22421: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22422: LD_EXP 57
22426: PPUSH
22427: LD_STRING D6b-Pow-1
22429: PPUSH
22430: CALL_OW 88
// repeat wait ( 3 ) ;
22434: LD_INT 3
22436: PPUSH
22437: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22441: LD_EXP 57
22445: PPUSH
22446: CALL_OW 310
22450: PPUSH
22451: CALL_OW 256
22455: PUSH
22456: LD_INT 1000
22458: LESS
22459: IFFALSE 22478
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22461: LD_EXP 57
22465: PPUSH
22466: CALL_OW 310
22470: PPUSH
22471: LD_INT 1000
22473: PPUSH
22474: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22478: LD_EXP 57
22482: PPUSH
22483: CALL_OW 256
22487: PUSH
22488: LD_INT 1000
22490: LESS
22491: IFFALSE 22505
// SetLives ( Powell , 1000 ) ;
22493: LD_EXP 57
22497: PPUSH
22498: LD_INT 1000
22500: PPUSH
22501: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22505: LD_EXP 57
22509: PPUSH
22510: LD_EXP 62
22514: PPUSH
22515: CALL_OW 296
22519: PUSH
22520: LD_INT 5
22522: LESS
22523: PUSH
22524: LD_EXP 57
22528: PPUSH
22529: CALL_OW 310
22533: PPUSH
22534: LD_EXP 62
22538: PPUSH
22539: CALL_OW 296
22543: PUSH
22544: LD_INT 5
22546: LESS
22547: OR
22548: IFFALSE 22567
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22550: LD_EXP 57
22554: PPUSH
22555: CALL_OW 310
22559: PPUSH
22560: LD_INT 100
22562: PPUSH
22563: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22567: LD_EXP 57
22571: PPUSH
22572: CALL_OW 310
22576: NOT
22577: IFFALSE 22434
// DoNotAttack ( 8 , powellBomb ) ;
22579: LD_INT 8
22581: PPUSH
22582: LD_EXP 62
22586: PPUSH
22587: CALL_OW 471
// game_speed := 4 ;
22591: LD_ADDR_OWVAR 65
22595: PUSH
22596: LD_INT 4
22598: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22599: LD_EXP 57
22603: PPUSH
22604: LD_STRING D6b-Pow-1a
22606: PPUSH
22607: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22611: LD_EXP 57
22615: PPUSH
22616: LD_EXP 62
22620: PPUSH
22621: CALL_OW 180
// sync ;
22625: SYNC
// repeat wait ( 0 0$1 ) ;
22626: LD_INT 35
22628: PPUSH
22629: CALL_OW 67
// until IsInUnit ( Powell ) ;
22633: LD_EXP 57
22637: PPUSH
22638: CALL_OW 310
22642: IFFALSE 22626
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22644: LD_INT 8
22646: PPUSH
22647: LD_EXP 57
22651: PPUSH
22652: CALL_OW 310
22656: PPUSH
22657: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22661: LD_EXP 57
22665: PPUSH
22666: LD_INT 91
22668: PPUSH
22669: LD_INT 44
22671: PPUSH
22672: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22676: LD_EXP 57
22680: PPUSH
22681: LD_INT 96
22683: PPUSH
22684: LD_INT 44
22686: PPUSH
22687: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22691: LD_EXP 57
22695: PPUSH
22696: LD_INT 96
22698: PPUSH
22699: LD_INT 41
22701: PPUSH
22702: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22706: LD_EXP 57
22710: PPUSH
22711: LD_INT 92
22713: PPUSH
22714: LD_INT 39
22716: PPUSH
22717: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22721: LD_EXP 57
22725: PPUSH
22726: LD_INT 88
22728: PPUSH
22729: LD_INT 41
22731: PPUSH
22732: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22736: LD_EXP 57
22740: PPUSH
22741: LD_INT 91
22743: PPUSH
22744: LD_INT 44
22746: PPUSH
22747: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22751: LD_EXP 57
22755: PPUSH
22756: LD_INT 96
22758: PPUSH
22759: LD_INT 44
22761: PPUSH
22762: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22766: LD_EXP 57
22770: PPUSH
22771: LD_INT 96
22773: PPUSH
22774: LD_INT 41
22776: PPUSH
22777: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22781: LD_EXP 57
22785: PPUSH
22786: LD_INT 92
22788: PPUSH
22789: LD_INT 39
22791: PPUSH
22792: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22796: LD_EXP 57
22800: PPUSH
22801: LD_INT 88
22803: PPUSH
22804: LD_INT 41
22806: PPUSH
22807: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22811: LD_EXP 57
22815: PPUSH
22816: LD_INT 91
22818: PPUSH
22819: LD_INT 44
22821: PPUSH
22822: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22826: LD_EXP 57
22830: PPUSH
22831: LD_INT 93
22833: PPUSH
22834: LD_INT 39
22836: PPUSH
22837: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22841: LD_EXP 57
22845: PPUSH
22846: LD_INT 93
22848: PPUSH
22849: LD_INT 36
22851: PPUSH
22852: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22856: LD_INT 122
22858: PPUSH
22859: CALL_OW 67
// game_speed := 4 ;
22863: LD_ADDR_OWVAR 65
22867: PUSH
22868: LD_INT 4
22870: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22871: LD_EXP 57
22875: PPUSH
22876: LD_STRING D6b-Pow-1b
22878: PPUSH
22879: CALL_OW 88
// tmp := [ ] ;
22883: LD_ADDR_VAR 0 3
22887: PUSH
22888: EMPTY
22889: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22890: LD_ADDR_VAR 0 5
22894: PUSH
22895: LD_INT 78
22897: PUSH
22898: LD_INT 47
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: PUSH
22905: LD_INT 106
22907: PUSH
22908: LD_INT 53
22910: PUSH
22911: EMPTY
22912: LIST
22913: LIST
22914: PUSH
22915: EMPTY
22916: LIST
22917: LIST
22918: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22919: LD_ADDR_VAR 0 1
22923: PUSH
22924: LD_INT 22
22926: PUSH
22927: LD_INT 8
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: PUSH
22934: LD_INT 21
22936: PUSH
22937: LD_INT 3
22939: PUSH
22940: EMPTY
22941: LIST
22942: LIST
22943: PUSH
22944: LD_INT 92
22946: PUSH
22947: LD_INT 90
22949: PUSH
22950: LD_INT 52
22952: PUSH
22953: LD_INT 12
22955: PUSH
22956: EMPTY
22957: LIST
22958: LIST
22959: LIST
22960: LIST
22961: PUSH
22962: EMPTY
22963: LIST
22964: LIST
22965: LIST
22966: PPUSH
22967: CALL_OW 69
22971: PUSH
22972: FOR_IN
22973: IFFALSE 22998
// tmp := tmp ^ UnitsInside ( i ) ;
22975: LD_ADDR_VAR 0 3
22979: PUSH
22980: LD_VAR 0 3
22984: PUSH
22985: LD_VAR 0 1
22989: PPUSH
22990: CALL_OW 313
22994: ADD
22995: ST_TO_ADDR
22996: GO 22972
22998: POP
22999: POP
// for i in tmp do
23000: LD_ADDR_VAR 0 1
23004: PUSH
23005: LD_VAR 0 3
23009: PUSH
23010: FOR_IN
23011: IFFALSE 23173
// begin dist := 9999 ;
23013: LD_ADDR_VAR 0 8
23017: PUSH
23018: LD_INT 9999
23020: ST_TO_ADDR
// _xy := [ ] ;
23021: LD_ADDR_VAR 0 7
23025: PUSH
23026: EMPTY
23027: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23028: LD_VAR 0 1
23032: PPUSH
23033: LD_INT 1
23035: PPUSH
23036: CALL_OW 109
// ComExitBuilding ( i ) ;
23040: LD_VAR 0 1
23044: PPUSH
23045: CALL_OW 122
// for j in xy do
23049: LD_ADDR_VAR 0 2
23053: PUSH
23054: LD_VAR 0 5
23058: PUSH
23059: FOR_IN
23060: IFFALSE 23142
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23062: LD_VAR 0 1
23066: PPUSH
23067: LD_VAR 0 2
23071: PUSH
23072: LD_INT 1
23074: ARRAY
23075: PPUSH
23076: LD_VAR 0 2
23080: PUSH
23081: LD_INT 2
23083: ARRAY
23084: PPUSH
23085: CALL_OW 297
23089: PUSH
23090: LD_VAR 0 8
23094: LESS
23095: IFFALSE 23140
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23097: LD_ADDR_VAR 0 8
23101: PUSH
23102: LD_VAR 0 1
23106: PPUSH
23107: LD_VAR 0 2
23111: PUSH
23112: LD_INT 1
23114: ARRAY
23115: PPUSH
23116: LD_VAR 0 2
23120: PUSH
23121: LD_INT 2
23123: ARRAY
23124: PPUSH
23125: CALL_OW 297
23129: ST_TO_ADDR
// _xy := j ;
23130: LD_ADDR_VAR 0 7
23134: PUSH
23135: LD_VAR 0 2
23139: ST_TO_ADDR
// end ;
23140: GO 23059
23142: POP
23143: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23144: LD_VAR 0 1
23148: PPUSH
23149: LD_VAR 0 7
23153: PUSH
23154: LD_INT 1
23156: ARRAY
23157: PPUSH
23158: LD_VAR 0 7
23162: PUSH
23163: LD_INT 2
23165: ARRAY
23166: PPUSH
23167: CALL_OW 171
// end ;
23171: GO 23010
23173: POP
23174: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23175: LD_ADDR_VAR 0 4
23179: PUSH
23180: LD_VAR 0 3
23184: PPUSH
23185: LD_INT 26
23187: PUSH
23188: LD_INT 1
23190: PUSH
23191: EMPTY
23192: LIST
23193: LIST
23194: PUSH
23195: LD_INT 25
23197: PUSH
23198: LD_INT 1
23200: PUSH
23201: EMPTY
23202: LIST
23203: LIST
23204: PUSH
23205: EMPTY
23206: LIST
23207: LIST
23208: PPUSH
23209: CALL_OW 72
23213: ST_TO_ADDR
// if tmp2 < 2 then
23214: LD_VAR 0 4
23218: PUSH
23219: LD_INT 2
23221: LESS
23222: IFFALSE 23291
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23224: LD_ADDR_VAR 0 4
23228: PUSH
23229: LD_INT 22
23231: PUSH
23232: LD_INT 8
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: PUSH
23239: LD_INT 26
23241: PUSH
23242: LD_INT 1
23244: PUSH
23245: EMPTY
23246: LIST
23247: LIST
23248: PUSH
23249: LD_INT 3
23251: PUSH
23252: LD_INT 25
23254: PUSH
23255: LD_INT 15
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: PUSH
23262: EMPTY
23263: LIST
23264: LIST
23265: PUSH
23266: EMPTY
23267: LIST
23268: LIST
23269: LIST
23270: PPUSH
23271: CALL_OW 69
23275: PUSH
23276: LD_EXP 59
23280: PUSH
23281: LD_EXP 60
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: DIFF
23290: ST_TO_ADDR
// if tmp2 then
23291: LD_VAR 0 4
23295: IFFALSE 23313
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23297: LD_VAR 0 4
23301: PUSH
23302: LD_INT 1
23304: ARRAY
23305: PPUSH
23306: LD_STRING D6b-ArSol1-1
23308: PPUSH
23309: CALL_OW 88
// async ;
23313: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23314: LD_EXP 57
23318: PPUSH
23319: LD_STRING D6b-Pow-2
23321: PPUSH
23322: CALL_OW 88
// wait ( 0 0$1 ) ;
23326: LD_INT 35
23328: PPUSH
23329: CALL_OW 67
// if tmp2 > 1 then
23333: LD_VAR 0 4
23337: PUSH
23338: LD_INT 1
23340: GREATER
23341: IFFALSE 23359
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23343: LD_VAR 0 4
23347: PUSH
23348: LD_INT 2
23350: ARRAY
23351: PPUSH
23352: LD_STRING D6b-ArSol2-1
23354: PPUSH
23355: CALL_OW 88
// sync ;
23359: SYNC
// repeat wait ( 5 ) ;
23360: LD_INT 5
23362: PPUSH
23363: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23367: LD_INT 93
23369: PPUSH
23370: LD_INT 36
23372: PPUSH
23373: CALL_OW 428
23377: PPUSH
23378: CALL_OW 255
23382: PUSH
23383: LD_INT 4
23385: EQUAL
23386: IFFALSE 23360
// DialogueOn ;
23388: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23392: LD_INT 10
23394: PPUSH
23395: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23399: LD_EXP 57
23403: PPUSH
23404: LD_STRING D6b-Pow-2a
23406: PPUSH
23407: CALL_OW 88
// DialogueOff ;
23411: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23415: LD_EXP 57
23419: PPUSH
23420: CALL_OW 310
23424: PPUSH
23425: LD_INT 332
23427: PPUSH
23428: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23432: LD_INT 93
23434: PPUSH
23435: LD_INT 35
23437: PPUSH
23438: LD_INT 1
23440: PPUSH
23441: LD_INT 6
23443: NEG
23444: PPUSH
23445: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23449: LD_INT 35
23451: PPUSH
23452: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23456: LD_INT 332
23458: PPUSH
23459: CALL_OW 256
23463: PUSH
23464: LD_INT 1000
23466: LESS
23467: PUSH
23468: LD_INT 332
23470: PPUSH
23471: CALL_OW 300
23475: AND
23476: IFFALSE 23488
// SetLives ( kozlov_fac , 0 ) ;
23478: LD_INT 332
23480: PPUSH
23481: LD_INT 0
23483: PPUSH
23484: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23488: LD_INT 332
23490: PPUSH
23491: CALL_OW 301
23495: PUSH
23496: LD_EXP 57
23500: PPUSH
23501: CALL_OW 301
23505: OR
23506: IFFALSE 23449
// game_speed := 4 ;
23508: LD_ADDR_OWVAR 65
23512: PUSH
23513: LD_INT 4
23515: ST_TO_ADDR
// powellCenterCameraMode := false ;
23516: LD_ADDR_EXP 20
23520: PUSH
23521: LD_INT 0
23523: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23524: LD_ADDR_VAR 0 1
23528: PUSH
23529: LD_VAR 0 3
23533: PUSH
23534: LD_INT 22
23536: PUSH
23537: LD_INT 8
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: LD_INT 25
23546: PUSH
23547: LD_INT 2
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PUSH
23554: EMPTY
23555: LIST
23556: LIST
23557: PPUSH
23558: CALL_OW 69
23562: UNION
23563: PUSH
23564: FOR_IN
23565: IFFALSE 23581
// SetTag ( i , 0 ) ;
23567: LD_VAR 0 1
23571: PPUSH
23572: LD_INT 0
23574: PPUSH
23575: CALL_OW 109
23579: GO 23564
23581: POP
23582: POP
// wait ( 0 0$3 ) ;
23583: LD_INT 105
23585: PPUSH
23586: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23590: LD_INT 93
23592: PPUSH
23593: LD_INT 35
23595: PPUSH
23596: LD_INT 1
23598: PPUSH
23599: CALL_OW 331
// DialogueOn ;
23603: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23607: LD_VAR 0 11
23611: PPUSH
23612: LD_STRING D6c-Sol3-1
23614: PPUSH
23615: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23619: LD_INT 10
23621: PPUSH
23622: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23626: LD_EXP 38
23630: PPUSH
23631: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23635: LD_EXP 38
23639: PPUSH
23640: LD_STRING D6c-JMM-1
23642: PPUSH
23643: CALL_OW 88
// if Cyrus then
23647: LD_EXP 44
23651: IFFALSE 23665
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23653: LD_EXP 44
23657: PPUSH
23658: LD_STRING D6c-Cyrus-1
23660: PPUSH
23661: CALL_OW 88
// if Bobby then
23665: LD_EXP 43
23669: IFFALSE 23683
// Say ( Bobby , D6c-Bobby-1 ) ;
23671: LD_EXP 43
23675: PPUSH
23676: LD_STRING D6c-Bobby-1
23678: PPUSH
23679: CALL_OW 88
// if Cornel then
23683: LD_EXP 49
23687: IFFALSE 23701
// Say ( Cornel , D6c-Corn-1 ) ;
23689: LD_EXP 49
23693: PPUSH
23694: LD_STRING D6c-Corn-1
23696: PPUSH
23697: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23701: LD_ADDR_VAR 0 4
23705: PUSH
23706: LD_INT 2
23708: PUSH
23709: LD_INT 22
23711: PUSH
23712: LD_INT 1
23714: PUSH
23715: EMPTY
23716: LIST
23717: LIST
23718: PUSH
23719: LD_INT 22
23721: PUSH
23722: LD_INT 4
23724: PUSH
23725: EMPTY
23726: LIST
23727: LIST
23728: PUSH
23729: EMPTY
23730: LIST
23731: LIST
23732: LIST
23733: PUSH
23734: LD_INT 26
23736: PUSH
23737: LD_INT 1
23739: PUSH
23740: EMPTY
23741: LIST
23742: LIST
23743: PUSH
23744: LD_INT 3
23746: PUSH
23747: LD_INT 25
23749: PUSH
23750: LD_INT 16
23752: PUSH
23753: EMPTY
23754: LIST
23755: LIST
23756: PUSH
23757: LD_INT 25
23759: PUSH
23760: LD_INT 12
23762: PUSH
23763: EMPTY
23764: LIST
23765: LIST
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: LIST
23771: PUSH
23772: EMPTY
23773: LIST
23774: LIST
23775: LIST
23776: PPUSH
23777: CALL_OW 69
23781: PUSH
23782: LD_VAR 0 11
23786: PUSH
23787: LD_EXP 38
23791: UNION
23792: PUSH
23793: LD_EXP 58
23797: UNION
23798: PUSH
23799: EMPTY
23800: LIST
23801: DIFF
23802: ST_TO_ADDR
// if tmp2 then
23803: LD_VAR 0 4
23807: IFFALSE 23825
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23809: LD_VAR 0 4
23813: PUSH
23814: LD_INT 1
23816: ARRAY
23817: PPUSH
23818: LD_STRING D6c-Sol1-1
23820: PPUSH
23821: CALL_OW 88
// if Lisa then
23825: LD_EXP 41
23829: IFFALSE 23843
// Say ( Lisa , D6c-Lisa-1 ) ;
23831: LD_EXP 41
23835: PPUSH
23836: LD_STRING D6c-Lisa-1
23838: PPUSH
23839: CALL_OW 88
// if Gary then
23843: LD_EXP 50
23847: IFFALSE 23861
// Say ( Gary , D6c-Gary-1 ) ;
23849: LD_EXP 50
23853: PPUSH
23854: LD_STRING D6c-Gary-1
23856: PPUSH
23857: CALL_OW 88
// if Donaldson then
23861: LD_EXP 42
23865: IFFALSE 23879
// Say ( Donaldson , D6c-Don-1 ) ;
23867: LD_EXP 42
23871: PPUSH
23872: LD_STRING D6c-Don-1
23874: PPUSH
23875: CALL_OW 88
// if tmp2 > 1 then
23879: LD_VAR 0 4
23883: PUSH
23884: LD_INT 1
23886: GREATER
23887: IFFALSE 23905
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23889: LD_VAR 0 4
23893: PUSH
23894: LD_INT 2
23896: ARRAY
23897: PPUSH
23898: LD_STRING D6c-Sol2-1
23900: PPUSH
23901: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23905: LD_VAR 0 11
23909: PPUSH
23910: LD_STRING D6c-Sol3-2
23912: PPUSH
23913: CALL_OW 88
// dwait ( 0 0$1 ) ;
23917: LD_INT 35
23919: PPUSH
23920: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23924: LD_EXP 38
23928: PPUSH
23929: LD_STRING D6c-JMM-2
23931: PPUSH
23932: CALL_OW 88
// DialogueOff ;
23936: CALL_OW 7
// Video ( false ) ;
23940: LD_INT 0
23942: PPUSH
23943: CALL 107035 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23947: LD_INT 22
23949: PUSH
23950: LD_INT 4
23952: PUSH
23953: EMPTY
23954: LIST
23955: LIST
23956: PPUSH
23957: CALL_OW 69
23961: PPUSH
23962: LD_INT 1
23964: PPUSH
23965: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23969: LD_INT 4
23971: PPUSH
23972: LD_INT 4
23974: PPUSH
23975: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23979: LD_ADDR_VAR 0 1
23983: PUSH
23984: LD_INT 4
23986: PPUSH
23987: LD_INT 1
23989: PPUSH
23990: LD_INT 2
23992: PPUSH
23993: CALL 64266 0 3
23997: PUSH
23998: FOR_IN
23999: IFFALSE 24036
// if GetTech ( i , 1 ) <> state_researched then
24001: LD_VAR 0 1
24005: PPUSH
24006: LD_INT 1
24008: PPUSH
24009: CALL_OW 321
24013: PUSH
24014: LD_INT 2
24016: NONEQUAL
24017: IFFALSE 24034
// SetTech ( i , 1 , state_researched ) ;
24019: LD_VAR 0 1
24023: PPUSH
24024: LD_INT 1
24026: PPUSH
24027: LD_INT 2
24029: PPUSH
24030: CALL_OW 322
24034: GO 23998
24036: POP
24037: POP
// missionStage := 6 ;
24038: LD_ADDR_EXP 15
24042: PUSH
24043: LD_INT 6
24045: ST_TO_ADDR
// activeAttacks := true ;
24046: LD_ADDR_EXP 16
24050: PUSH
24051: LD_INT 1
24053: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24054: LD_STRING M2
24056: PPUSH
24057: CALL_OW 337
// SaveForQuickRestart ;
24061: CALL_OW 22
// wait ( 0 0$40 ) ;
24065: LD_INT 1400
24067: PPUSH
24068: CALL_OW 67
// DialogueOn ;
24072: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24076: LD_EXP 61
24080: PPUSH
24081: LD_STRING D7-Friend-1
24083: PPUSH
24084: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24088: LD_EXP 38
24092: PPUSH
24093: LD_STRING D7-JMM-1
24095: PPUSH
24096: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24100: LD_EXP 61
24104: PPUSH
24105: LD_STRING D7-Friend-2
24107: PPUSH
24108: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24112: LD_EXP 38
24116: PPUSH
24117: LD_STRING D7-JMM-2
24119: PPUSH
24120: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24124: LD_EXP 61
24128: PPUSH
24129: LD_STRING D7-Friend-3
24131: PPUSH
24132: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24136: LD_EXP 38
24140: PPUSH
24141: LD_STRING D7-JMM-3
24143: PPUSH
24144: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24148: LD_EXP 61
24152: PPUSH
24153: LD_STRING D7-Friend-4
24155: PPUSH
24156: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24160: LD_EXP 38
24164: PPUSH
24165: LD_STRING D7-JMM-4
24167: PPUSH
24168: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24172: LD_EXP 61
24176: PPUSH
24177: LD_STRING D7-Friend-5
24179: PPUSH
24180: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24184: LD_EXP 38
24188: PPUSH
24189: LD_STRING D7-JMM-5
24191: PPUSH
24192: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24196: LD_EXP 61
24200: PPUSH
24201: LD_STRING D7-Friend-6
24203: PPUSH
24204: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24208: LD_EXP 38
24212: PPUSH
24213: LD_STRING D7-JMM-6
24215: PPUSH
24216: CALL_OW 88
// DialogueOff ;
24220: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24224: LD_STRING Mlegion
24226: PPUSH
24227: CALL_OW 337
// RebuildKozlovFactory ;
24231: CALL 4840 0 0
// end ;
24235: PPOPN 13
24237: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24238: LD_EXP 20
24242: PUSH
24243: LD_EXP 57
24247: PPUSH
24248: CALL_OW 300
24252: AND
24253: IFFALSE 24295
24255: GO 24257
24257: DISABLE
// begin enable ;
24258: ENABLE
// if IsInUnit ( Powell ) then
24259: LD_EXP 57
24263: PPUSH
24264: CALL_OW 310
24268: IFFALSE 24286
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24270: LD_EXP 57
24274: PPUSH
24275: CALL_OW 310
24279: PPUSH
24280: CALL_OW 85
24284: GO 24295
// CenterOnUnits ( Powell ) ;
24286: LD_EXP 57
24290: PPUSH
24291: CALL_OW 85
// end ;
24295: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24296: LD_INT 22
24298: PUSH
24299: LD_INT 8
24301: PUSH
24302: EMPTY
24303: LIST
24304: LIST
24305: PUSH
24306: LD_INT 34
24308: PUSH
24309: LD_INT 48
24311: PUSH
24312: EMPTY
24313: LIST
24314: LIST
24315: PUSH
24316: EMPTY
24317: LIST
24318: LIST
24319: PPUSH
24320: CALL_OW 69
24324: IFFALSE 24587
24326: GO 24328
24328: DISABLE
24329: LD_INT 0
24331: PPUSH
24332: PPUSH
// begin if missionStage < 9 then
24333: LD_EXP 15
24337: PUSH
24338: LD_INT 9
24340: LESS
24341: IFFALSE 24351
// missionStage := 9 ;
24343: LD_ADDR_EXP 15
24347: PUSH
24348: LD_INT 9
24350: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24351: LD_ADDR_VAR 0 1
24355: PUSH
24356: LD_INT 22
24358: PUSH
24359: LD_INT 8
24361: PUSH
24362: EMPTY
24363: LIST
24364: LIST
24365: PUSH
24366: LD_INT 34
24368: PUSH
24369: LD_INT 48
24371: PUSH
24372: EMPTY
24373: LIST
24374: LIST
24375: PUSH
24376: EMPTY
24377: LIST
24378: LIST
24379: PPUSH
24380: CALL_OW 69
24384: PUSH
24385: LD_INT 1
24387: ARRAY
24388: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24389: LD_INT 175
24391: PPUSH
24392: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24396: LD_EXP 12
24400: PUSH
24401: LD_EXP 3
24405: PUSH
24406: LD_INT 0
24408: PUSH
24409: LD_INT 2
24411: PUSH
24412: EMPTY
24413: LIST
24414: LIST
24415: IN
24416: OR
24417: IFFALSE 24440
// target := [ 68 , 108 , 1 ] else
24419: LD_ADDR_VAR 0 2
24423: PUSH
24424: LD_INT 68
24426: PUSH
24427: LD_INT 108
24429: PUSH
24430: LD_INT 1
24432: PUSH
24433: EMPTY
24434: LIST
24435: LIST
24436: LIST
24437: ST_TO_ADDR
24438: GO 24459
// target := [ 181 , 88 , 2 ] ;
24440: LD_ADDR_VAR 0 2
24444: PUSH
24445: LD_INT 181
24447: PUSH
24448: LD_INT 88
24450: PUSH
24451: LD_INT 2
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: LIST
24458: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24459: LD_VAR 0 1
24463: PPUSH
24464: LD_VAR 0 2
24468: PUSH
24469: LD_INT 1
24471: ARRAY
24472: PPUSH
24473: LD_VAR 0 2
24477: PUSH
24478: LD_INT 2
24480: ARRAY
24481: PPUSH
24482: CALL_OW 176
// if target [ 3 ] = 1 then
24486: LD_VAR 0 2
24490: PUSH
24491: LD_INT 3
24493: ARRAY
24494: PUSH
24495: LD_INT 1
24497: EQUAL
24498: IFFALSE 24514
// SayRadio ( Kurt , D12-Kurt-1 ) else
24500: LD_EXP 59
24504: PPUSH
24505: LD_STRING D12-Kurt-1
24507: PPUSH
24508: CALL_OW 94
24512: GO 24538
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24514: LD_EXP 59
24518: PPUSH
24519: LD_STRING D12a-Kurt-1
24521: PPUSH
24522: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24526: LD_EXP 73
24530: PPUSH
24531: LD_STRING D12a-Roth-1
24533: PPUSH
24534: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24538: LD_INT 350
24540: PPUSH
24541: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24545: LD_VAR 0 1
24549: PPUSH
24550: LD_INT 22
24552: PUSH
24553: LD_INT 8
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: PUSH
24560: LD_INT 30
24562: PUSH
24563: LD_INT 3
24565: PUSH
24566: EMPTY
24567: LIST
24568: LIST
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PPUSH
24574: CALL_OW 69
24578: PUSH
24579: LD_INT 1
24581: ARRAY
24582: PPUSH
24583: CALL_OW 228
// end ;
24587: PPOPN 2
24589: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24590: LD_INT 22
24592: PUSH
24593: LD_INT 8
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: LD_INT 21
24602: PUSH
24603: LD_INT 1
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 23
24612: PUSH
24613: LD_INT 2
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: EMPTY
24621: LIST
24622: LIST
24623: LIST
24624: PPUSH
24625: CALL_OW 69
24629: PUSH
24630: LD_INT 9
24632: PUSH
24633: LD_INT 8
24635: PUSH
24636: LD_INT 7
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: LIST
24643: PUSH
24644: LD_OWVAR 67
24648: ARRAY
24649: LESSEQUAL
24650: PUSH
24651: LD_INT 22
24653: PUSH
24654: LD_INT 8
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 34
24663: PUSH
24664: LD_INT 48
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PPUSH
24675: CALL_OW 69
24679: NOT
24680: AND
24681: PUSH
24682: LD_EXP 59
24686: PPUSH
24687: CALL_OW 302
24691: AND
24692: IFFALSE 24997
24694: GO 24696
24696: DISABLE
// begin DialogueOn ;
24697: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24701: LD_EXP 38
24705: PPUSH
24706: LD_STRING D13-JMM-1
24708: PPUSH
24709: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24713: LD_EXP 59
24717: PPUSH
24718: LD_STRING D13-Kurt-1
24720: PPUSH
24721: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24725: LD_EXP 38
24729: PPUSH
24730: LD_STRING D13-JMM-2
24732: PPUSH
24733: CALL_OW 88
// if FakeInfo then
24737: LD_EXP 12
24741: IFFALSE 24761
// begin Say ( Kurt , D13-Kurt-2 ) ;
24743: LD_EXP 59
24747: PPUSH
24748: LD_STRING D13-Kurt-2
24750: PPUSH
24751: CALL_OW 88
// DialogueOff ;
24755: CALL_OW 7
// exit ;
24759: GO 24997
// end ; if not KurtStatus then
24761: LD_EXP 3
24765: NOT
24766: IFFALSE 24782
// Say ( Kurt , D13-Kurt-2b ) else
24768: LD_EXP 59
24772: PPUSH
24773: LD_STRING D13-Kurt-2b
24775: PPUSH
24776: CALL_OW 88
24780: GO 24794
// Say ( Kurt , D13-Kurt-2a ) ;
24782: LD_EXP 59
24786: PPUSH
24787: LD_STRING D13-Kurt-2a
24789: PPUSH
24790: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24794: LD_EXP 38
24798: PPUSH
24799: LD_STRING D13-JMM-3
24801: PPUSH
24802: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24806: LD_EXP 59
24810: PPUSH
24811: LD_STRING D13-Kurt-3
24813: PPUSH
24814: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24818: LD_EXP 38
24822: PPUSH
24823: LD_STRING D13-JMM-4
24825: PPUSH
24826: CALL_OW 88
// DialogueOff ;
24830: CALL_OW 7
// MC_Kill ( 3 ) ;
24834: LD_INT 3
24836: PPUSH
24837: CALL 34295 0 1
// KillUnit ( Kozlov ) ;
24841: LD_EXP 60
24845: PPUSH
24846: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24850: LD_INT 22
24852: PUSH
24853: LD_INT 8
24855: PUSH
24856: EMPTY
24857: LIST
24858: LIST
24859: PUSH
24860: LD_INT 21
24862: PUSH
24863: LD_INT 3
24865: PUSH
24866: EMPTY
24867: LIST
24868: LIST
24869: PUSH
24870: LD_INT 23
24872: PUSH
24873: LD_INT 3
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 30
24882: PUSH
24883: LD_INT 3
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: LIST
24894: LIST
24895: PPUSH
24896: CALL_OW 69
24900: PUSH
24901: LD_INT 1
24903: ARRAY
24904: PPUSH
24905: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24909: LD_INT 8
24911: PPUSH
24912: LD_INT 1
24914: PPUSH
24915: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24919: LD_INT 22
24921: PUSH
24922: LD_INT 8
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PPUSH
24929: CALL_OW 69
24933: PPUSH
24934: LD_INT 1
24936: PPUSH
24937: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24941: LD_INT 8
24943: PPUSH
24944: LD_INT 1
24946: PPUSH
24947: LD_INT 1
24949: PPUSH
24950: LD_INT 1
24952: PPUSH
24953: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24957: LD_EXP 61
24961: PPUSH
24962: LD_INT 37
24964: PPUSH
24965: LD_INT 1
24967: PPUSH
24968: LD_INT 0
24970: PPUSH
24971: CALL_OW 48
// wait ( 0 0$1 ) ;
24975: LD_INT 35
24977: PPUSH
24978: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24982: LD_EXP 61
24986: PPUSH
24987: LD_INT 60
24989: PPUSH
24990: LD_INT 95
24992: PPUSH
24993: CALL_OW 111
// end ;
24997: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24998: LD_INT 22
25000: PUSH
25001: LD_INT 8
25003: PUSH
25004: EMPTY
25005: LIST
25006: LIST
25007: PUSH
25008: LD_INT 21
25010: PUSH
25011: LD_INT 1
25013: PUSH
25014: EMPTY
25015: LIST
25016: LIST
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: PPUSH
25022: CALL_OW 69
25026: PUSH
25027: LD_INT 0
25029: EQUAL
25030: IFFALSE 25050
25032: GO 25034
25034: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25035: LD_STRING MlegionOut
25037: PPUSH
25038: CALL_OW 337
// legionDestroyed := true ;
25042: LD_ADDR_EXP 22
25046: PUSH
25047: LD_INT 1
25049: ST_TO_ADDR
// end ;
25050: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25051: LD_INT 1
25053: PPUSH
25054: LD_EXP 61
25058: PPUSH
25059: CALL_OW 292
25063: IFFALSE 25363
25065: GO 25067
25067: DISABLE
25068: LD_INT 0
25070: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
25071: LD_EXP 61
25075: PPUSH
25076: CALL_OW 87
// DialogueOn ;
25080: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25084: LD_EXP 38
25088: PPUSH
25089: LD_STRING D14-JMM-1
25091: PPUSH
25092: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25096: LD_EXP 61
25100: PPUSH
25101: LD_STRING D14-Friend-1
25103: PPUSH
25104: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25108: LD_EXP 38
25112: PPUSH
25113: LD_STRING D14-JMM-2
25115: PPUSH
25116: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25120: LD_EXP 61
25124: PPUSH
25125: LD_STRING D14-Friend-2
25127: PPUSH
25128: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25132: LD_EXP 38
25136: PPUSH
25137: LD_STRING D14-JMM-3
25139: PPUSH
25140: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25144: LD_EXP 61
25148: PPUSH
25149: LD_STRING D14-Friend-3
25151: PPUSH
25152: CALL_OW 88
// DialogueOff ;
25156: CALL_OW 7
// dec = Query ( Q14 ) ;
25160: LD_ADDR_VAR 0 1
25164: PUSH
25165: LD_STRING Q14
25167: PPUSH
25168: CALL_OW 97
25172: ST_TO_ADDR
// if dec = 1 then
25173: LD_VAR 0 1
25177: PUSH
25178: LD_INT 1
25180: EQUAL
25181: IFFALSE 25215
// begin DialogueOn ;
25183: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25187: LD_EXP 38
25191: PPUSH
25192: LD_STRING D14a-JMM-1
25194: PPUSH
25195: CALL_OW 88
// DialogueOff ;
25199: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25203: LD_EXP 61
25207: PPUSH
25208: LD_INT 1
25210: PPUSH
25211: CALL_OW 235
// end ; if dec = 2 then
25215: LD_VAR 0 1
25219: PUSH
25220: LD_INT 2
25222: EQUAL
25223: IFFALSE 25269
// begin DialogueOn ;
25225: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25229: LD_EXP 38
25233: PPUSH
25234: LD_STRING D14b-JMM-1
25236: PPUSH
25237: CALL_OW 88
// DialogueOff ;
25241: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25245: LD_EXP 61
25249: PPUSH
25250: LD_INT 9
25252: PPUSH
25253: LD_INT 2
25255: PPUSH
25256: CALL_OW 111
// AddComHold ( Friend ) ;
25260: LD_EXP 61
25264: PPUSH
25265: CALL_OW 200
// end ; if dec = 3 then
25269: LD_VAR 0 1
25273: PUSH
25274: LD_INT 3
25276: EQUAL
25277: IFFALSE 25363
// begin DialogueOn ;
25279: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25283: LD_EXP 38
25287: PPUSH
25288: LD_STRING D14c-JMM-1
25290: PPUSH
25291: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25295: LD_EXP 61
25299: PPUSH
25300: LD_STRING D14c-Friend-1
25302: PPUSH
25303: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25307: LD_EXP 38
25311: PPUSH
25312: LD_STRING D14c-JMM-2
25314: PPUSH
25315: CALL_OW 88
// DialogueOff ;
25319: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25323: LD_INT 8
25325: PPUSH
25326: LD_INT 1
25328: PPUSH
25329: LD_INT 2
25331: PPUSH
25332: LD_INT 1
25334: PPUSH
25335: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25339: LD_EXP 61
25343: PPUSH
25344: LD_INT 9
25346: PPUSH
25347: LD_INT 2
25349: PPUSH
25350: CALL_OW 111
// AddComHold ( Friend ) ;
25354: LD_EXP 61
25358: PPUSH
25359: CALL_OW 200
// end ; end ;
25363: PPOPN 1
25365: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25366: LD_INT 9
25368: PPUSH
25369: LD_INT 2
25371: PPUSH
25372: CALL_OW 428
25376: PUSH
25377: LD_EXP 61
25381: EQUAL
25382: PUSH
25383: LD_EXP 61
25387: PPUSH
25388: CALL_OW 255
25392: PUSH
25393: LD_INT 8
25395: EQUAL
25396: AND
25397: IFFALSE 25411
25399: GO 25401
25401: DISABLE
// RemoveUnit ( Friend ) ;
25402: LD_EXP 61
25406: PPUSH
25407: CALL_OW 64
25411: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25412: LD_EXP 14
25416: PUSH
25417: LD_INT 31500
25419: GREATEREQUAL
25420: PUSH
25421: LD_EXP 7
25425: AND
25426: PUSH
25427: LD_EXP 2
25431: AND
25432: IFFALSE 25862
25434: GO 25436
25436: DISABLE
25437: LD_INT 0
25439: PPUSH
25440: PPUSH
25441: PPUSH
// begin missionStage := 7 ;
25442: LD_ADDR_EXP 15
25446: PUSH
25447: LD_INT 7
25449: ST_TO_ADDR
// uc_side = 1 ;
25450: LD_ADDR_OWVAR 20
25454: PUSH
25455: LD_INT 1
25457: ST_TO_ADDR
// uc_nation = 1 ;
25458: LD_ADDR_OWVAR 21
25462: PUSH
25463: LD_INT 1
25465: ST_TO_ADDR
// for i = 1 to 5 do
25466: LD_ADDR_VAR 0 1
25470: PUSH
25471: DOUBLE
25472: LD_INT 1
25474: DEC
25475: ST_TO_ADDR
25476: LD_INT 5
25478: PUSH
25479: FOR_TO
25480: IFFALSE 25576
// begin vc_engine = 3 ;
25482: LD_ADDR_OWVAR 39
25486: PUSH
25487: LD_INT 3
25489: ST_TO_ADDR
// vc_control = 3 ;
25490: LD_ADDR_OWVAR 38
25494: PUSH
25495: LD_INT 3
25497: ST_TO_ADDR
// vc_chassis = 3 ;
25498: LD_ADDR_OWVAR 37
25502: PUSH
25503: LD_INT 3
25505: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25506: LD_ADDR_OWVAR 40
25510: PUSH
25511: LD_INT 5
25513: PUSH
25514: LD_INT 9
25516: PUSH
25517: LD_INT 7
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: PUSH
25525: LD_INT 1
25527: PPUSH
25528: LD_INT 3
25530: PPUSH
25531: CALL_OW 12
25535: ARRAY
25536: ST_TO_ADDR
// veh = CreateVehicle ;
25537: LD_ADDR_VAR 0 2
25541: PUSH
25542: CALL_OW 45
25546: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25547: LD_VAR 0 2
25551: PPUSH
25552: LD_INT 1
25554: PPUSH
25555: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25559: LD_VAR 0 2
25563: PPUSH
25564: LD_INT 19
25566: PPUSH
25567: LD_INT 0
25569: PPUSH
25570: CALL_OW 49
// end ;
25574: GO 25479
25576: POP
25577: POP
// vc_engine = 3 ;
25578: LD_ADDR_OWVAR 39
25582: PUSH
25583: LD_INT 3
25585: ST_TO_ADDR
// vc_control = 1 ;
25586: LD_ADDR_OWVAR 38
25590: PUSH
25591: LD_INT 1
25593: ST_TO_ADDR
// vc_chassis = 3 ;
25594: LD_ADDR_OWVAR 37
25598: PUSH
25599: LD_INT 3
25601: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25602: LD_ADDR_OWVAR 40
25606: PUSH
25607: LD_INT 5
25609: PUSH
25610: LD_INT 9
25612: PUSH
25613: LD_INT 7
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 1
25623: PPUSH
25624: LD_INT 3
25626: PPUSH
25627: CALL_OW 12
25631: ARRAY
25632: ST_TO_ADDR
// vehG = CreateVehicle ;
25633: LD_ADDR_VAR 0 3
25637: PUSH
25638: CALL_OW 45
25642: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25643: LD_VAR 0 3
25647: PPUSH
25648: LD_INT 1
25650: PPUSH
25651: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25655: LD_VAR 0 3
25659: PPUSH
25660: LD_INT 19
25662: PPUSH
25663: LD_INT 0
25665: PPUSH
25666: CALL_OW 49
// if JMMGirl = 1 then
25670: LD_EXP 7
25674: PUSH
25675: LD_INT 1
25677: EQUAL
25678: IFFALSE 25734
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25680: LD_ADDR_EXP 39
25684: PUSH
25685: LD_STRING Joan
25687: PPUSH
25688: LD_INT 1
25690: PPUSH
25691: LD_STRING 14_
25693: PPUSH
25694: CALL 64203 0 3
25698: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25699: LD_EXP 39
25703: PPUSH
25704: LD_VAR 0 3
25708: PPUSH
25709: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25713: LD_VAR 0 3
25717: PPUSH
25718: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25722: LD_EXP 39
25726: PPUSH
25727: LD_STRING D10BW-Joan-1
25729: PPUSH
25730: CALL_OW 94
// end ; if JMMGirl = 2 then
25734: LD_EXP 7
25738: PUSH
25739: LD_INT 2
25741: EQUAL
25742: IFFALSE 25798
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25744: LD_ADDR_EXP 41
25748: PUSH
25749: LD_STRING Lisa
25751: PPUSH
25752: LD_INT 1
25754: PPUSH
25755: LD_STRING 14_
25757: PPUSH
25758: CALL 64203 0 3
25762: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25763: LD_EXP 41
25767: PPUSH
25768: LD_VAR 0 3
25772: PPUSH
25773: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25777: LD_VAR 0 3
25781: PPUSH
25782: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25786: LD_EXP 41
25790: PPUSH
25791: LD_STRING D10BW-Lisa-1
25793: PPUSH
25794: CALL_OW 94
// end ; if JMMGirl = 3 then
25798: LD_EXP 7
25802: PUSH
25803: LD_INT 3
25805: EQUAL
25806: IFFALSE 25862
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25808: LD_ADDR_EXP 53
25812: PUSH
25813: LD_STRING Connie
25815: PPUSH
25816: LD_INT 1
25818: PPUSH
25819: LD_STRING 14_
25821: PPUSH
25822: CALL 64203 0 3
25826: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25827: LD_EXP 53
25831: PPUSH
25832: LD_VAR 0 3
25836: PPUSH
25837: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25841: LD_VAR 0 3
25845: PPUSH
25846: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
25850: LD_EXP 53
25854: PPUSH
25855: LD_STRING D10BW-Con-1
25857: PPUSH
25858: CALL_OW 94
// end ; end ;
25862: PPOPN 3
25864: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25865: LD_EXP 14
25869: PUSH
25870: LD_INT 94500
25872: GREATEREQUAL
25873: IFFALSE 26285
25875: GO 25877
25877: DISABLE
25878: LD_INT 0
25880: PPUSH
25881: PPUSH
25882: PPUSH
// begin tmp := PrepareStevensSquad ;
25883: LD_ADDR_VAR 0 3
25887: PUSH
25888: CALL 2214 0 0
25892: ST_TO_ADDR
// if not tmp then
25893: LD_VAR 0 3
25897: NOT
25898: IFFALSE 25902
// exit ;
25900: GO 26285
// uc_side := 1 ;
25902: LD_ADDR_OWVAR 20
25906: PUSH
25907: LD_INT 1
25909: ST_TO_ADDR
// uc_nation := 1 ;
25910: LD_ADDR_OWVAR 21
25914: PUSH
25915: LD_INT 1
25917: ST_TO_ADDR
// for i in tmp do
25918: LD_ADDR_VAR 0 1
25922: PUSH
25923: LD_VAR 0 3
25927: PUSH
25928: FOR_IN
25929: IFFALSE 26026
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25931: LD_INT 3
25933: PPUSH
25934: LD_INT 3
25936: PPUSH
25937: LD_INT 1
25939: PPUSH
25940: LD_INT 5
25942: PUSH
25943: LD_INT 9
25945: PUSH
25946: LD_INT 7
25948: PUSH
25949: EMPTY
25950: LIST
25951: LIST
25952: LIST
25953: PUSH
25954: LD_INT 1
25956: PPUSH
25957: LD_INT 3
25959: PPUSH
25960: CALL_OW 12
25964: ARRAY
25965: PPUSH
25966: LD_INT 40
25968: PPUSH
25969: CALL 71318 0 5
// veh := CreateVehicle ;
25973: LD_ADDR_VAR 0 2
25977: PUSH
25978: CALL_OW 45
25982: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25983: LD_VAR 0 2
25987: PPUSH
25988: LD_INT 1
25990: PPUSH
25991: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25995: LD_VAR 0 2
25999: PPUSH
26000: LD_INT 19
26002: PPUSH
26003: LD_INT 0
26005: PPUSH
26006: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26010: LD_VAR 0 1
26014: PPUSH
26015: LD_VAR 0 2
26019: PPUSH
26020: CALL_OW 52
// end ;
26024: GO 25928
26026: POP
26027: POP
// missionStage := 8 ;
26028: LD_ADDR_EXP 15
26032: PUSH
26033: LD_INT 8
26035: ST_TO_ADDR
// DialogueOn ;
26036: CALL_OW 6
// if Stevens then
26040: LD_EXP 40
26044: IFFALSE 26158
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26046: LD_EXP 40
26050: PPUSH
26051: CALL_OW 310
26055: PPUSH
26056: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26060: LD_EXP 40
26064: PPUSH
26065: LD_STRING D8-Huck-1
26067: PPUSH
26068: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26072: LD_EXP 38
26076: PPUSH
26077: LD_STRING D8-JMM-1
26079: PPUSH
26080: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26084: LD_EXP 40
26088: PPUSH
26089: LD_STRING D8-Huck-2
26091: PPUSH
26092: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26096: LD_EXP 38
26100: PPUSH
26101: LD_STRING D8-JMM-2
26103: PPUSH
26104: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26108: LD_EXP 40
26112: PPUSH
26113: LD_STRING D8-Huck-3
26115: PPUSH
26116: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26120: LD_EXP 38
26124: PPUSH
26125: LD_STRING D8-JMM-3
26127: PPUSH
26128: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26132: LD_EXP 40
26136: PPUSH
26137: LD_STRING D8-Huck-4
26139: PPUSH
26140: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26144: LD_EXP 38
26148: PPUSH
26149: LD_STRING D8-JMM-4
26151: PPUSH
26152: CALL_OW 88
// end else
26156: GO 26268
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26158: LD_EXP 54
26162: PPUSH
26163: CALL_OW 310
26167: PPUSH
26168: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26172: LD_EXP 54
26176: PPUSH
26177: LD_STRING D8-Huck-1
26179: PPUSH
26180: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26184: LD_EXP 38
26188: PPUSH
26189: LD_STRING D8-JMM-1a
26191: PPUSH
26192: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26196: LD_EXP 54
26200: PPUSH
26201: LD_STRING D8-Huck-2
26203: PPUSH
26204: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26208: LD_EXP 38
26212: PPUSH
26213: LD_STRING D8-JMM-2
26215: PPUSH
26216: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26220: LD_EXP 54
26224: PPUSH
26225: LD_STRING D8-Huck-3
26227: PPUSH
26228: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26232: LD_EXP 38
26236: PPUSH
26237: LD_STRING D8-JMM-3
26239: PPUSH
26240: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26244: LD_EXP 54
26248: PPUSH
26249: LD_STRING D8-Huck-4
26251: PPUSH
26252: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26256: LD_EXP 38
26260: PPUSH
26261: LD_STRING D8-JMM-4
26263: PPUSH
26264: CALL_OW 88
// end ; DialogueOff ;
26268: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26272: LD_INT 25
26274: PPUSH
26275: LD_INT 1
26277: PPUSH
26278: LD_INT 1
26280: PPUSH
26281: CALL_OW 322
// end ;
26285: PPOPN 3
26287: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26288: LD_INT 1
26290: PPUSH
26291: LD_EXP 70
26295: PPUSH
26296: CALL_OW 292
26300: IFFALSE 26551
26302: GO 26304
26304: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26305: LD_EXP 70
26309: PPUSH
26310: CALL_OW 87
// DialogueOn ;
26314: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26318: LD_EXP 38
26322: PPUSH
26323: LD_STRING D10nB-JMM-1
26325: PPUSH
26326: CALL_OW 88
// if BurlakStatus = 1 then
26330: LD_EXP 9
26334: PUSH
26335: LD_INT 1
26337: EQUAL
26338: IFFALSE 26352
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26340: LD_EXP 69
26344: PPUSH
26345: LD_STRING D10nB-Vse-1a
26347: PPUSH
26348: CALL_OW 94
// end ; if BurlakStatus = 0 then
26352: LD_EXP 9
26356: PUSH
26357: LD_INT 0
26359: EQUAL
26360: IFFALSE 26374
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26362: LD_EXP 69
26366: PPUSH
26367: LD_STRING D10nB-Vse-1
26369: PPUSH
26370: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26374: LD_EXP 38
26378: PPUSH
26379: LD_STRING D10nB-JMM-2
26381: PPUSH
26382: CALL_OW 88
// if KappaStatus then
26386: LD_EXP 2
26390: IFFALSE 26404
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26392: LD_EXP 69
26396: PPUSH
26397: LD_STRING D10nB-Vse-5a
26399: PPUSH
26400: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26404: LD_EXP 2
26408: NOT
26409: PUSH
26410: LD_EXP 6
26414: PUSH
26415: LD_INT 0
26417: EQUAL
26418: AND
26419: IFFALSE 26547
// begin if JMMGirl = 1 then
26421: LD_EXP 7
26425: PUSH
26426: LD_INT 1
26428: EQUAL
26429: IFFALSE 26479
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26431: LD_EXP 69
26435: PPUSH
26436: LD_STRING D10nB-Vse-2
26438: PPUSH
26439: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26443: LD_EXP 38
26447: PPUSH
26448: LD_STRING D10nB-JMM-3
26450: PPUSH
26451: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26455: LD_EXP 69
26459: PPUSH
26460: LD_STRING D10nB-Vse-3
26462: PPUSH
26463: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26467: LD_EXP 38
26471: PPUSH
26472: LD_STRING D10nB-JMM-4
26474: PPUSH
26475: CALL_OW 88
// end ; if JMMGirl = 2 then
26479: LD_EXP 7
26483: PUSH
26484: LD_INT 2
26486: EQUAL
26487: IFFALSE 26513
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26489: LD_EXP 69
26493: PPUSH
26494: LD_STRING D10nB-Vse-4
26496: PPUSH
26497: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26501: LD_EXP 38
26505: PPUSH
26506: LD_STRING D10nB-JMM-5
26508: PPUSH
26509: CALL_OW 88
// end ; if JMMGirl = 3 then
26513: LD_EXP 7
26517: PUSH
26518: LD_INT 3
26520: EQUAL
26521: IFFALSE 26547
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26523: LD_EXP 69
26527: PPUSH
26528: LD_STRING D10nB-Vse-5
26530: PPUSH
26531: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26535: LD_EXP 38
26539: PPUSH
26540: LD_STRING D10nB-JMM-6
26542: PPUSH
26543: CALL_OW 88
// end ; end ; DialogueOff ;
26547: CALL_OW 7
// end ;
26551: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26552: LD_EXP 14
26556: PUSH
26557: LD_INT 115500
26559: GREATEREQUAL
26560: IFFALSE 26925
26562: GO 26564
26564: DISABLE
26565: LD_INT 0
26567: PPUSH
// begin missionStage := 10 ;
26568: LD_ADDR_EXP 15
26572: PUSH
26573: LD_INT 10
26575: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26576: LD_ADDR_VAR 0 1
26580: PUSH
26581: LD_INT 22
26583: PUSH
26584: LD_INT 1
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: LD_INT 26
26593: PUSH
26594: LD_INT 1
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PUSH
26601: LD_INT 3
26603: PUSH
26604: LD_INT 25
26606: PUSH
26607: LD_INT 12
26609: PUSH
26610: EMPTY
26611: LIST
26612: LIST
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PUSH
26618: LD_INT 3
26620: PUSH
26621: LD_INT 25
26623: PUSH
26624: LD_INT 16
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: LIST
26639: LIST
26640: PPUSH
26641: CALL_OW 69
26645: PUSH
26646: LD_EXP 38
26650: PUSH
26651: LD_EXP 59
26655: PUSH
26656: LD_EXP 40
26660: PUSH
26661: LD_EXP 54
26665: PUSH
26666: LD_EXP 41
26670: PUSH
26671: LD_EXP 42
26675: PUSH
26676: LD_EXP 43
26680: PUSH
26681: LD_EXP 44
26685: PUSH
26686: LD_EXP 45
26690: PUSH
26691: LD_EXP 46
26695: PUSH
26696: LD_EXP 47
26700: PUSH
26701: LD_EXP 48
26705: PUSH
26706: LD_EXP 49
26710: PUSH
26711: LD_EXP 50
26715: PUSH
26716: LD_EXP 51
26720: PUSH
26721: LD_EXP 52
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: LIST
26730: LIST
26731: LIST
26732: LIST
26733: LIST
26734: LIST
26735: LIST
26736: LIST
26737: LIST
26738: LIST
26739: LIST
26740: LIST
26741: LIST
26742: LIST
26743: DIFF
26744: ST_TO_ADDR
// if not tmp and Brown then
26745: LD_VAR 0 1
26749: NOT
26750: PUSH
26751: LD_EXP 46
26755: AND
26756: IFFALSE 26771
// tmp := [ Brown ] ;
26758: LD_ADDR_VAR 0 1
26762: PUSH
26763: LD_EXP 46
26767: PUSH
26768: EMPTY
26769: LIST
26770: ST_TO_ADDR
// DialogueOn ;
26771: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26775: LD_VAR 0 1
26779: PUSH
26780: LD_INT 1
26782: ARRAY
26783: PPUSH
26784: LD_STRING D11-Sol1-1
26786: PPUSH
26787: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26791: LD_EXP 63
26795: PPUSH
26796: LD_STRING D11-Pla-1
26798: PPUSH
26799: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26803: LD_EXP 64
26807: PPUSH
26808: LD_STRING D11-Kov-1
26810: PPUSH
26811: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26815: LD_EXP 63
26819: PPUSH
26820: LD_STRING D11-Pla-2
26822: PPUSH
26823: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26827: LD_VAR 0 1
26831: PUSH
26832: LD_INT 1
26834: ARRAY
26835: PPUSH
26836: LD_STRING D11-Sol1-2
26838: PPUSH
26839: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26843: LD_EXP 38
26847: PPUSH
26848: LD_STRING D11-JMM-2
26850: PPUSH
26851: CALL_OW 88
// DialogueOff ;
26855: CALL_OW 7
// allowBehemothConstruct := true ;
26859: LD_ADDR_EXP 25
26863: PUSH
26864: LD_INT 1
26866: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26867: LD_STRING M4
26869: PPUSH
26870: CALL_OW 337
// BuildBehemoths ;
26874: CALL 7644 0 0
// repeat wait ( 15 15$00 ) ;
26878: LD_INT 31500
26880: PPUSH
26881: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26885: LD_EXP 27
26889: IFFALSE 26893
// break ;
26891: GO 26925
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26893: LD_INT 267
26895: PPUSH
26896: CALL_OW 274
26900: PPUSH
26901: LD_INT 1
26903: PPUSH
26904: CALL_OW 275
26908: PUSH
26909: LD_INT 1000
26911: GREATEREQUAL
26912: IFFALSE 26918
// BuildBehemoths ;
26914: CALL 7644 0 0
// until not behemothBuilders ;
26918: LD_EXP 72
26922: NOT
26923: IFFALSE 26878
// end ;
26925: PPOPN 1
26927: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26928: LD_EXP 72
26932: NOT
26933: PUSH
26934: LD_EXP 28
26938: NOT
26939: AND
26940: PUSH
26941: LD_EXP 25
26945: AND
26946: IFFALSE 26966
26948: GO 26950
26950: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26951: LD_STRING M4a
26953: PPUSH
26954: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26958: LD_ADDR_EXP 27
26962: PUSH
26963: LD_INT 1
26965: ST_TO_ADDR
// end ;
26966: END
// every 0 0$1 trigger behemothDone do
26967: LD_EXP 28
26971: IFFALSE 26983
26973: GO 26975
26975: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26976: LD_STRING M4b
26978: PPUSH
26979: CALL_OW 337
26983: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26984: LD_EXP 29
26988: NOT
26989: IFFALSE 27185
26991: GO 26993
26993: DISABLE
26994: LD_INT 0
26996: PPUSH
26997: PPUSH
// begin enable ;
26998: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26999: LD_ADDR_VAR 0 1
27003: PUSH
27004: LD_INT 3
27006: PPUSH
27007: CALL 107111 0 1
27011: ST_TO_ADDR
// if not tmp and not behemothDone then
27012: LD_VAR 0 1
27016: NOT
27017: PUSH
27018: LD_EXP 28
27022: NOT
27023: AND
27024: IFFALSE 27060
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27026: LD_ADDR_VAR 0 1
27030: PUSH
27031: LD_INT 22
27033: PUSH
27034: LD_INT 3
27036: PUSH
27037: EMPTY
27038: LIST
27039: LIST
27040: PUSH
27041: LD_INT 30
27043: PUSH
27044: LD_INT 37
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PPUSH
27055: CALL_OW 69
27059: ST_TO_ADDR
// if not tmp then
27060: LD_VAR 0 1
27064: NOT
27065: IFFALSE 27069
// exit ;
27067: GO 27185
// for i in tmp do
27069: LD_ADDR_VAR 0 2
27073: PUSH
27074: LD_VAR 0 1
27078: PUSH
27079: FOR_IN
27080: IFFALSE 27183
// if See ( 1 , i ) then
27082: LD_INT 1
27084: PPUSH
27085: LD_VAR 0 2
27089: PPUSH
27090: CALL_OW 292
27094: IFFALSE 27181
// begin if GetType ( i ) = unit_building then
27096: LD_VAR 0 2
27100: PPUSH
27101: CALL_OW 247
27105: PUSH
27106: LD_INT 3
27108: EQUAL
27109: IFFALSE 27147
// begin CenterNowOnUnits ( i ) ;
27111: LD_VAR 0 2
27115: PPUSH
27116: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27120: LD_EXP 38
27124: PPUSH
27125: LD_STRING D17a-JMM-1
27127: PPUSH
27128: CALL_OW 88
// seeBehemoth := true ;
27132: LD_ADDR_EXP 29
27136: PUSH
27137: LD_INT 1
27139: ST_TO_ADDR
// disable ;
27140: DISABLE
// exit ;
27141: POP
27142: POP
27143: GO 27185
// end else
27145: GO 27181
// begin CenterNowOnUnits ( i ) ;
27147: LD_VAR 0 2
27151: PPUSH
27152: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27156: LD_EXP 38
27160: PPUSH
27161: LD_STRING D17b-JMM-1
27163: PPUSH
27164: CALL_OW 88
// seeBehemoth := true ;
27168: LD_ADDR_EXP 29
27172: PUSH
27173: LD_INT 1
27175: ST_TO_ADDR
// disable ;
27176: DISABLE
// exit ;
27177: POP
27178: POP
27179: GO 27185
// end ; end ;
27181: GO 27079
27183: POP
27184: POP
// end ;
27185: PPOPN 2
27187: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27188: LD_EXP 14
27192: PUSH
27193: LD_INT 116550
27195: GREATEREQUAL
27196: IFFALSE 28372
27198: GO 27200
27200: DISABLE
27201: LD_INT 0
27203: PPUSH
27204: PPUSH
27205: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27206: LD_INT 2
27208: PPUSH
27209: LD_INT 23
27211: PUSH
27212: LD_INT 3
27214: PUSH
27215: LD_INT 3
27217: PUSH
27218: LD_INT 48
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: LIST
27225: LIST
27226: PUSH
27227: EMPTY
27228: LIST
27229: PPUSH
27230: CALL 57859 0 2
// repeat wait ( 0 0$1 ) ;
27234: LD_INT 35
27236: PPUSH
27237: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27241: LD_INT 22
27243: PUSH
27244: LD_INT 3
27246: PUSH
27247: EMPTY
27248: LIST
27249: LIST
27250: PUSH
27251: LD_INT 34
27253: PUSH
27254: LD_INT 48
27256: PUSH
27257: EMPTY
27258: LIST
27259: LIST
27260: PUSH
27261: EMPTY
27262: LIST
27263: LIST
27264: PPUSH
27265: CALL_OW 69
27269: IFFALSE 27234
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27271: LD_ADDR_VAR 0 1
27275: PUSH
27276: LD_INT 22
27278: PUSH
27279: LD_INT 3
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: LD_INT 34
27288: PUSH
27289: LD_INT 48
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: PPUSH
27300: CALL_OW 69
27304: PUSH
27305: LD_INT 1
27307: ARRAY
27308: ST_TO_ADDR
// missionStage := 12 ;
27309: LD_ADDR_EXP 15
27313: PUSH
27314: LD_INT 12
27316: ST_TO_ADDR
// platonovHasBomb := true ;
27317: LD_ADDR_EXP 30
27321: PUSH
27322: LD_INT 1
27324: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27325: LD_VAR 0 1
27329: PPUSH
27330: LD_INT 181
27332: PPUSH
27333: LD_INT 86
27335: PPUSH
27336: CALL_OW 171
// AddComHold ( bomb ) ;
27340: LD_VAR 0 1
27344: PPUSH
27345: CALL_OW 200
// wait ( 0 0$10 ) ;
27349: LD_INT 350
27351: PPUSH
27352: CALL_OW 67
// DialogueOn ;
27356: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27360: LD_EXP 63
27364: PPUSH
27365: LD_STRING D15-Pla-1
27367: PPUSH
27368: CALL_OW 94
// dec = Query ( Q15a ) ;
27372: LD_ADDR_VAR 0 2
27376: PUSH
27377: LD_STRING Q15a
27379: PPUSH
27380: CALL_OW 97
27384: ST_TO_ADDR
// if dec = 1 then
27385: LD_VAR 0 2
27389: PUSH
27390: LD_INT 1
27392: EQUAL
27393: IFFALSE 27416
// begin Say ( JMM , D15a-JMM-1 ) ;
27395: LD_EXP 38
27399: PPUSH
27400: LD_STRING D15a-JMM-1
27402: PPUSH
27403: CALL_OW 88
// YouLost ( Surrender ) ;
27407: LD_STRING Surrender
27409: PPUSH
27410: CALL_OW 104
// exit ;
27414: GO 28372
// end ; if dec = 2 then
27416: LD_VAR 0 2
27420: PUSH
27421: LD_INT 2
27423: EQUAL
27424: IFFALSE 27493
// begin Say ( JMM , D15b-JMM-1 ) ;
27426: LD_EXP 38
27430: PPUSH
27431: LD_STRING D15b-JMM-1
27433: PPUSH
27434: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27438: LD_EXP 63
27442: PPUSH
27443: LD_STRING D15b-Pla-1
27445: PPUSH
27446: CALL_OW 94
// DialogueOff ;
27450: CALL_OW 7
// wait ( 3 3$00 ) ;
27454: LD_INT 6300
27456: PPUSH
27457: CALL_OW 67
// DialogueOn ;
27461: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27465: LD_EXP 38
27469: PPUSH
27470: LD_STRING D15d-JMM-1a
27472: PPUSH
27473: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27477: LD_EXP 63
27481: PPUSH
27482: LD_STRING D15d-Pla-1
27484: PPUSH
27485: CALL_OW 94
// DialogueOff ;
27489: CALL_OW 7
// end ; if dec = 3 then
27493: LD_VAR 0 2
27497: PUSH
27498: LD_INT 3
27500: EQUAL
27501: IFFALSE 27555
// begin Say ( JMM , D15c-JMM-1 ) ;
27503: LD_EXP 38
27507: PPUSH
27508: LD_STRING D15c-JMM-1
27510: PPUSH
27511: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27515: LD_EXP 63
27519: PPUSH
27520: LD_STRING D15c-Pla-1
27522: PPUSH
27523: CALL_OW 94
// DialogueOff ;
27527: CALL_OW 7
// wait ( 0 0$15 ) ;
27531: LD_INT 525
27533: PPUSH
27534: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27538: LD_VAR 0 1
27542: PPUSH
27543: LD_INT 60
27545: PPUSH
27546: LD_INT 95
27548: PPUSH
27549: CALL_OW 116
// exit ;
27553: GO 28372
// end ; if dec = 4 then
27555: LD_VAR 0 2
27559: PUSH
27560: LD_INT 4
27562: EQUAL
27563: IFFALSE 27593
// begin Say ( JMM , D15d-JMM-1 ) ;
27565: LD_EXP 38
27569: PPUSH
27570: LD_STRING D15d-JMM-1
27572: PPUSH
27573: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27577: LD_EXP 63
27581: PPUSH
27582: LD_STRING D15d-Pla-1
27584: PPUSH
27585: CALL_OW 94
// DialogueOff ;
27589: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27593: LD_EXP 61
27597: PPUSH
27598: CALL_OW 302
27602: PUSH
27603: LD_EXP 61
27607: PPUSH
27608: CALL_OW 255
27612: PUSH
27613: LD_INT 1
27615: EQUAL
27616: AND
27617: PUSH
27618: LD_INT 22
27620: PUSH
27621: LD_INT 1
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PUSH
27628: LD_INT 34
27630: PUSH
27631: LD_INT 8
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PUSH
27638: EMPTY
27639: LIST
27640: LIST
27641: PPUSH
27642: CALL_OW 69
27646: NOT
27647: AND
27648: IFFALSE 28273
// begin SetSide ( Friend , 8 ) ;
27650: LD_EXP 61
27654: PPUSH
27655: LD_INT 8
27657: PPUSH
27658: CALL_OW 235
// if IsInUnit ( Friend ) then
27662: LD_EXP 61
27666: PPUSH
27667: CALL_OW 310
27671: IFFALSE 27682
// ComExitBuilding ( Friend ) ;
27673: LD_EXP 61
27677: PPUSH
27678: CALL_OW 122
// if IsDriver ( Friend ) then
27682: LD_EXP 61
27686: PPUSH
27687: CALL 104788 0 1
27691: IFFALSE 27702
// ComExitVehicle ( Friend ) ;
27693: LD_EXP 61
27697: PPUSH
27698: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27702: LD_EXP 61
27706: PPUSH
27707: LD_INT 9
27709: PPUSH
27710: LD_INT 2
27712: PPUSH
27713: CALL_OW 171
// wait ( 0 0$05 ) ;
27717: LD_INT 175
27719: PPUSH
27720: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27724: LD_EXP 61
27728: PPUSH
27729: CALL_OW 87
// DialogueOn ;
27733: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27737: LD_EXP 38
27741: PPUSH
27742: LD_STRING D16-JMM-1
27744: PPUSH
27745: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27749: LD_EXP 61
27753: PPUSH
27754: LD_STRING D16-Friend-1
27756: PPUSH
27757: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27761: LD_EXP 38
27765: PPUSH
27766: LD_STRING D16-JMM-2
27768: PPUSH
27769: CALL_OW 88
// DialogueOff ;
27773: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27777: LD_EXP 61
27781: PPUSH
27782: LD_INT 1
27784: PPUSH
27785: CALL_OW 235
// ComHold ( Friend ) ;
27789: LD_EXP 61
27793: PPUSH
27794: CALL_OW 140
// wait ( 0 0$20 ) ;
27798: LD_INT 700
27800: PPUSH
27801: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27805: LD_EXP 61
27809: PPUSH
27810: LD_INT 9
27812: PPUSH
27813: LD_INT 2
27815: PPUSH
27816: CALL_OW 297
27820: PUSH
27821: LD_INT 30
27823: LESS
27824: IFFALSE 27893
// begin SetSide ( Friend , 8 ) ;
27826: LD_EXP 61
27830: PPUSH
27831: LD_INT 8
27833: PPUSH
27834: CALL_OW 235
// if IsInUnit ( Friend ) then
27838: LD_EXP 61
27842: PPUSH
27843: CALL_OW 310
27847: IFFALSE 27858
// ComExitBuilding ( Friend ) ;
27849: LD_EXP 61
27853: PPUSH
27854: CALL_OW 122
// if IsDriver ( Friend ) then
27858: LD_EXP 61
27862: PPUSH
27863: CALL 104788 0 1
27867: IFFALSE 27878
// ComExitVehicle ( Friend ) ;
27869: LD_EXP 61
27873: PPUSH
27874: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27878: LD_EXP 61
27882: PPUSH
27883: LD_INT 9
27885: PPUSH
27886: LD_INT 2
27888: PPUSH
27889: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27893: LD_INT 1050
27895: PPUSH
27896: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27900: LD_INT 22
27902: PUSH
27903: LD_INT 1
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: PUSH
27910: LD_INT 34
27912: PUSH
27913: LD_INT 8
27915: PUSH
27916: EMPTY
27917: LIST
27918: LIST
27919: PUSH
27920: EMPTY
27921: LIST
27922: LIST
27923: PPUSH
27924: CALL_OW 69
27928: NOT
27929: IFFALSE 28251
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27931: LD_ADDR_VAR 0 3
27935: PUSH
27936: LD_INT 22
27938: PUSH
27939: LD_INT 1
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 26
27948: PUSH
27949: LD_INT 1
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 3
27958: PUSH
27959: LD_INT 25
27961: PUSH
27962: LD_INT 12
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: PUSH
27969: LD_INT 25
27971: PUSH
27972: LD_INT 16
27974: PUSH
27975: EMPTY
27976: LIST
27977: LIST
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: LIST
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: LIST
27988: PPUSH
27989: CALL_OW 69
27993: PUSH
27994: LD_EXP 38
27998: PUSH
27999: LD_EXP 40
28003: PUSH
28004: LD_EXP 54
28008: PUSH
28009: LD_EXP 41
28013: PUSH
28014: LD_EXP 42
28018: PUSH
28019: LD_EXP 43
28023: PUSH
28024: LD_EXP 44
28028: PUSH
28029: LD_EXP 45
28033: PUSH
28034: LD_EXP 46
28038: PUSH
28039: LD_EXP 47
28043: PUSH
28044: LD_EXP 48
28048: PUSH
28049: LD_EXP 49
28053: PUSH
28054: LD_EXP 50
28058: PUSH
28059: LD_EXP 51
28063: PUSH
28064: LD_EXP 52
28068: PUSH
28069: EMPTY
28070: LIST
28071: LIST
28072: LIST
28073: LIST
28074: LIST
28075: LIST
28076: LIST
28077: LIST
28078: LIST
28079: LIST
28080: LIST
28081: LIST
28082: LIST
28083: LIST
28084: LIST
28085: DIFF
28086: ST_TO_ADDR
// DialogueOn ;
28087: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28091: LD_EXP 63
28095: PPUSH
28096: LD_STRING D16a-Pla-1
28098: PPUSH
28099: CALL_OW 94
// if Stevens then
28103: LD_EXP 40
28107: IFFALSE 28123
// Say ( Stevens , D16a-Huck-1 ) else
28109: LD_EXP 40
28113: PPUSH
28114: LD_STRING D16a-Huck-1
28116: PPUSH
28117: CALL_OW 88
28121: GO 28165
// if Baker then
28123: LD_EXP 54
28127: IFFALSE 28143
// Say ( Baker , D16a-Huck-1 ) else
28129: LD_EXP 54
28133: PPUSH
28134: LD_STRING D16a-Huck-1
28136: PPUSH
28137: CALL_OW 88
28141: GO 28165
// if tmp then
28143: LD_VAR 0 3
28147: IFFALSE 28165
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28149: LD_VAR 0 3
28153: PUSH
28154: LD_INT 1
28156: ARRAY
28157: PPUSH
28158: LD_STRING D16a-Sol1-1
28160: PPUSH
28161: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28165: LD_EXP 61
28169: PPUSH
28170: CALL_OW 255
28174: PUSH
28175: LD_INT 8
28177: EQUAL
28178: IFFALSE 28194
// Say ( JMM , D16a-JMM-1 ) else
28180: LD_EXP 38
28184: PPUSH
28185: LD_STRING D16a-JMM-1
28187: PPUSH
28188: CALL_OW 88
28192: GO 28230
// begin Say ( JMM , D16a-JMM-1a ) ;
28194: LD_EXP 38
28198: PPUSH
28199: LD_STRING D16a-JMM-1a
28201: PPUSH
28202: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28206: LD_EXP 61
28210: PPUSH
28211: LD_STRING D16a-Friend-1
28213: PPUSH
28214: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28218: LD_EXP 61
28222: PPUSH
28223: LD_INT 3
28225: PPUSH
28226: CALL_OW 235
// end ; DialogueOff ;
28230: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28234: LD_VAR 0 1
28238: PPUSH
28239: LD_INT 60
28241: PPUSH
28242: LD_INT 95
28244: PPUSH
28245: CALL_OW 116
// end else
28249: GO 28271
// begin DialogueOn ;
28251: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28255: LD_EXP 63
28259: PPUSH
28260: LD_STRING D16c-Pla-
28262: PPUSH
28263: CALL_OW 94
// DialogueOff ;
28267: CALL_OW 7
// end ; end else
28271: GO 28372
// begin wait ( 3 3$00 ) ;
28273: LD_INT 6300
28275: PPUSH
28276: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28280: LD_INT 22
28282: PUSH
28283: LD_INT 1
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 34
28292: PUSH
28293: LD_INT 8
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PPUSH
28304: CALL_OW 69
28308: NOT
28309: IFFALSE 28352
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28311: LD_EXP 63
28315: PPUSH
28316: LD_STRING D16b-Pla-1
28318: PPUSH
28319: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28323: LD_EXP 38
28327: PPUSH
28328: LD_STRING D16b-JMM-
28330: PPUSH
28331: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28335: LD_VAR 0 1
28339: PPUSH
28340: LD_INT 60
28342: PPUSH
28343: LD_INT 95
28345: PPUSH
28346: CALL_OW 116
// end else
28350: GO 28372
// begin DialogueOn ;
28352: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28356: LD_EXP 63
28360: PPUSH
28361: LD_STRING D16c-Pla-
28363: PPUSH
28364: CALL_OW 94
// DialogueOff ;
28368: CALL_OW 7
// end ; end ; end ;
28372: PPOPN 3
28374: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28375: LD_EXP 14
28379: PUSH
28380: LD_INT 126000
28382: GREATEREQUAL
28383: PUSH
28384: LD_EXP 23
28388: NOT
28389: AND
28390: PUSH
28391: LD_EXP 73
28395: PPUSH
28396: CALL_OW 302
28400: AND
28401: IFFALSE 28759
28403: GO 28405
28405: DISABLE
28406: LD_INT 0
28408: PPUSH
// begin missionStage = 11 ;
28409: LD_ADDR_EXP 15
28413: PUSH
28414: LD_INT 11
28416: ST_TO_ADDR
// DialogueOn ;
28417: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28421: LD_EXP 73
28425: PPUSH
28426: LD_STRING D9-Roth-1
28428: PPUSH
28429: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28433: LD_EXP 38
28437: PPUSH
28438: LD_STRING D9-JMM-1
28440: PPUSH
28441: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28445: LD_EXP 73
28449: PPUSH
28450: LD_STRING D9-Roth-2
28452: PPUSH
28453: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28457: LD_EXP 73
28461: PPUSH
28462: LD_STRING D9-Roth-2a
28464: PPUSH
28465: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28469: LD_EXP 63
28473: PPUSH
28474: LD_STRING D9-Pla-2
28476: PPUSH
28477: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28481: LD_EXP 73
28485: PPUSH
28486: LD_STRING D9-Roth-3
28488: PPUSH
28489: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28493: LD_EXP 63
28497: PPUSH
28498: LD_STRING D9-Pla-3
28500: PPUSH
28501: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28505: LD_EXP 73
28509: PPUSH
28510: LD_STRING D9-Roth-4
28512: PPUSH
28513: CALL_OW 94
// dec = Query ( Q9 ) ;
28517: LD_ADDR_VAR 0 1
28521: PUSH
28522: LD_STRING Q9
28524: PPUSH
28525: CALL_OW 97
28529: ST_TO_ADDR
// if dec = 1 then
28530: LD_VAR 0 1
28534: PUSH
28535: LD_INT 1
28537: EQUAL
28538: IFFALSE 28552
// SayRadio ( Roth , D9a-Roth-1 ) ;
28540: LD_EXP 73
28544: PPUSH
28545: LD_STRING D9a-Roth-1
28547: PPUSH
28548: CALL_OW 94
// if dec = 2 then
28552: LD_VAR 0 1
28556: PUSH
28557: LD_INT 2
28559: EQUAL
28560: IFFALSE 28586
// begin Say ( JMM , D9b-JMM-1 ) ;
28562: LD_EXP 38
28566: PPUSH
28567: LD_STRING D9b-JMM-1
28569: PPUSH
28570: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28574: LD_EXP 73
28578: PPUSH
28579: LD_STRING D9b-Roth-1
28581: PPUSH
28582: CALL_OW 94
// end ; if dec = 3 then
28586: LD_VAR 0 1
28590: PUSH
28591: LD_INT 3
28593: EQUAL
28594: IFFALSE 28656
// begin Say ( JMM , D9c-JMM-1 ) ;
28596: LD_EXP 38
28600: PPUSH
28601: LD_STRING D9c-JMM-1
28603: PPUSH
28604: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28608: LD_EXP 73
28612: PPUSH
28613: LD_STRING D9c-Roth-1
28615: PPUSH
28616: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28620: LD_EXP 38
28624: PPUSH
28625: LD_STRING D9c-JMM-2
28627: PPUSH
28628: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28632: LD_EXP 73
28636: PPUSH
28637: LD_STRING D9c-Roth-2
28639: PPUSH
28640: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28644: LD_EXP 38
28648: PPUSH
28649: LD_STRING D9c-JMM-3
28651: PPUSH
28652: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28656: LD_EXP 73
28660: PPUSH
28661: LD_STRING D9c-Roth-3
28663: PPUSH
28664: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28668: LD_EXP 73
28672: PPUSH
28673: LD_STRING D9cont-Roth-1
28675: PPUSH
28676: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28680: LD_EXP 38
28684: PPUSH
28685: LD_STRING D9cont-JMM-1
28687: PPUSH
28688: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28692: LD_EXP 73
28696: PPUSH
28697: LD_STRING D9cont-Roth-2
28699: PPUSH
28700: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28704: LD_EXP 38
28708: PPUSH
28709: LD_STRING D9cont-JMM-2
28711: PPUSH
28712: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28716: LD_EXP 73
28720: PPUSH
28721: LD_STRING D9cont-Roth-3
28723: PPUSH
28724: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28728: LD_EXP 38
28732: PPUSH
28733: LD_STRING D9cont-JMM-3
28735: PPUSH
28736: CALL_OW 88
// DialogueOff ;
28740: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28744: LD_STRING M3
28746: PPUSH
28747: CALL_OW 337
// allianceActive := true ;
28751: LD_ADDR_EXP 31
28755: PUSH
28756: LD_INT 1
28758: ST_TO_ADDR
// end ;
28759: PPOPN 1
28761: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28762: LD_EXP 63
28766: PPUSH
28767: CALL_OW 301
28771: PUSH
28772: LD_EXP 66
28776: PPUSH
28777: CALL_OW 301
28781: AND
28782: PUSH
28783: LD_INT 22
28785: PUSH
28786: LD_INT 3
28788: PUSH
28789: EMPTY
28790: LIST
28791: LIST
28792: PUSH
28793: LD_INT 21
28795: PUSH
28796: LD_INT 1
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: PUSH
28803: LD_INT 50
28805: PUSH
28806: EMPTY
28807: LIST
28808: PUSH
28809: EMPTY
28810: LIST
28811: LIST
28812: LIST
28813: PPUSH
28814: CALL_OW 69
28818: PUSH
28819: LD_INT 7
28821: PUSH
28822: LD_INT 8
28824: PUSH
28825: LD_INT 9
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: LIST
28832: PUSH
28833: LD_OWVAR 67
28837: ARRAY
28838: LESS
28839: AND
28840: IFFALSE 29611
28842: GO 28844
28844: DISABLE
28845: LD_INT 0
28847: PPUSH
28848: PPUSH
28849: PPUSH
28850: PPUSH
// begin MC_Kill ( 1 ) ;
28851: LD_INT 1
28853: PPUSH
28854: CALL 34295 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28858: LD_INT 1
28860: PPUSH
28861: LD_INT 3
28863: PPUSH
28864: LD_INT 1
28866: PPUSH
28867: LD_INT 1
28869: PPUSH
28870: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28874: LD_ADDR_VAR 0 1
28878: PUSH
28879: LD_INT 22
28881: PUSH
28882: LD_INT 3
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 21
28891: PUSH
28892: LD_INT 1
28894: PUSH
28895: EMPTY
28896: LIST
28897: LIST
28898: PUSH
28899: LD_INT 24
28901: PUSH
28902: LD_INT 900
28904: PUSH
28905: EMPTY
28906: LIST
28907: LIST
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: LIST
28913: PPUSH
28914: CALL_OW 69
28918: PUSH
28919: FOR_IN
28920: IFFALSE 28951
// if GetSex ( i ) = sex_male then
28922: LD_VAR 0 1
28926: PPUSH
28927: CALL_OW 258
28931: PUSH
28932: LD_INT 1
28934: EQUAL
28935: IFFALSE 28949
// begin tmp = i ;
28937: LD_ADDR_VAR 0 2
28941: PUSH
28942: LD_VAR 0 1
28946: ST_TO_ADDR
// break ;
28947: GO 28951
// end ;
28949: GO 28919
28951: POP
28952: POP
// if tmp = 0 then
28953: LD_VAR 0 2
28957: PUSH
28958: LD_INT 0
28960: EQUAL
28961: IFFALSE 29015
// begin uc_side = 3 ;
28963: LD_ADDR_OWVAR 20
28967: PUSH
28968: LD_INT 3
28970: ST_TO_ADDR
// uc_nation = 3 ;
28971: LD_ADDR_OWVAR 21
28975: PUSH
28976: LD_INT 3
28978: ST_TO_ADDR
// hc_name =  ;
28979: LD_ADDR_OWVAR 26
28983: PUSH
28984: LD_STRING 
28986: ST_TO_ADDR
// hc_gallery =  ;
28987: LD_ADDR_OWVAR 33
28991: PUSH
28992: LD_STRING 
28994: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28995: LD_INT 1
28997: PPUSH
28998: LD_INT 10
29000: PPUSH
29001: CALL_OW 381
// tmp = CreateHuman ;
29005: LD_ADDR_VAR 0 2
29009: PUSH
29010: CALL_OW 44
29014: ST_TO_ADDR
// end ; DialogueOn ;
29015: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29019: LD_VAR 0 2
29023: PPUSH
29024: LD_STRING DSurrenderRussians-RSol1-1a
29026: PPUSH
29027: CALL_OW 94
// DialogueOff ;
29031: CALL_OW 7
// russianDestroyed := true ;
29035: LD_ADDR_EXP 21
29039: PUSH
29040: LD_INT 1
29042: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29043: LD_INT 22
29045: PUSH
29046: LD_INT 3
29048: PUSH
29049: EMPTY
29050: LIST
29051: LIST
29052: PUSH
29053: LD_INT 21
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PPUSH
29067: CALL_OW 69
29071: PPUSH
29072: CALL_OW 122
// wait ( 0 0$1 ) ;
29076: LD_INT 35
29078: PPUSH
29079: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29083: LD_INT 22
29085: PUSH
29086: LD_INT 3
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PUSH
29093: LD_INT 21
29095: PUSH
29096: LD_INT 1
29098: PUSH
29099: EMPTY
29100: LIST
29101: LIST
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PPUSH
29107: CALL_OW 69
29111: PPUSH
29112: LD_INT 25
29114: PPUSH
29115: CALL_OW 173
// wait ( 0 0$10 ) ;
29119: LD_INT 350
29121: PPUSH
29122: CALL_OW 67
// PrepareOmarInvasion ;
29126: CALL 13777 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29130: LD_ADDR_VAR 0 2
29134: PUSH
29135: LD_EXP 91
29139: PPUSH
29140: CALL_OW 250
29144: PUSH
29145: LD_EXP 91
29149: PPUSH
29150: CALL_OW 251
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29159: LD_VAR 0 2
29163: PUSH
29164: LD_INT 1
29166: ARRAY
29167: PPUSH
29168: LD_VAR 0 2
29172: PUSH
29173: LD_INT 2
29175: ARRAY
29176: PPUSH
29177: LD_INT 1
29179: PPUSH
29180: LD_INT 8
29182: NEG
29183: PPUSH
29184: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29188: LD_EXP 91
29192: PPUSH
29193: CALL_OW 87
// DialogueOn ;
29197: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29201: LD_EXP 38
29205: PPUSH
29206: LD_STRING D19-JMM-1
29208: PPUSH
29209: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29213: LD_ADDR_VAR 0 3
29217: PUSH
29218: LD_INT 22
29220: PUSH
29221: LD_INT 1
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 26
29230: PUSH
29231: LD_INT 1
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 2
29240: PUSH
29241: LD_INT 25
29243: PUSH
29244: LD_INT 1
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: LD_INT 25
29253: PUSH
29254: LD_INT 2
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: PUSH
29261: LD_INT 25
29263: PUSH
29264: LD_INT 3
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: PUSH
29271: LD_INT 25
29273: PUSH
29274: LD_INT 4
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: LD_INT 25
29283: PUSH
29284: LD_INT 5
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: LD_INT 25
29293: PUSH
29294: LD_INT 8
29296: PUSH
29297: EMPTY
29298: LIST
29299: LIST
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: LIST
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: LIST
29314: PPUSH
29315: CALL_OW 69
29319: PUSH
29320: LD_EXP 38
29324: PUSH
29325: LD_EXP 39
29329: PUSH
29330: LD_EXP 40
29334: PUSH
29335: LD_EXP 41
29339: PUSH
29340: LD_EXP 42
29344: PUSH
29345: LD_EXP 43
29349: PUSH
29350: LD_EXP 44
29354: PUSH
29355: LD_EXP 45
29359: PUSH
29360: LD_EXP 46
29364: PUSH
29365: LD_EXP 47
29369: PUSH
29370: LD_EXP 48
29374: PUSH
29375: LD_EXP 49
29379: PUSH
29380: LD_EXP 50
29384: PUSH
29385: LD_EXP 51
29389: PUSH
29390: LD_EXP 52
29394: PUSH
29395: LD_EXP 53
29399: PUSH
29400: LD_EXP 54
29404: PUSH
29405: EMPTY
29406: LIST
29407: LIST
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: DIFF
29424: ST_TO_ADDR
// if tmp2 then
29425: LD_VAR 0 3
29429: IFFALSE 29447
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29431: LD_VAR 0 3
29435: PUSH
29436: LD_INT 1
29438: ARRAY
29439: PPUSH
29440: LD_STRING D19-Sol1-1
29442: PPUSH
29443: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29447: LD_EXP 38
29451: PPUSH
29452: LD_STRING D19-JMM-2
29454: PPUSH
29455: CALL_OW 88
// DialogueOff ;
29459: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29463: LD_VAR 0 2
29467: PUSH
29468: LD_INT 1
29470: ARRAY
29471: PPUSH
29472: LD_VAR 0 2
29476: PUSH
29477: LD_INT 2
29479: ARRAY
29480: PPUSH
29481: LD_INT 1
29483: PPUSH
29484: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29488: LD_STRING M5
29490: PPUSH
29491: CALL_OW 337
// omarOnMotherLode := false ;
29495: LD_ADDR_VAR 0 4
29499: PUSH
29500: LD_INT 0
29502: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29503: LD_INT 35
29505: PPUSH
29506: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29510: LD_EXP 91
29514: PPUSH
29515: LD_INT 215
29517: PPUSH
29518: LD_INT 100
29520: PPUSH
29521: CALL_OW 297
29525: PUSH
29526: LD_INT 10
29528: LESS
29529: PUSH
29530: LD_VAR 0 4
29534: NOT
29535: AND
29536: IFFALSE 29570
// begin omarOnMotherLode := true ;
29538: LD_ADDR_VAR 0 4
29542: PUSH
29543: LD_INT 1
29545: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29546: LD_EXP 38
29550: PPUSH
29551: LD_STRING D19b-JMM-1
29553: PPUSH
29554: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29558: LD_EXP 91
29562: PPUSH
29563: LD_STRING DOmarContam-Omar-1
29565: PPUSH
29566: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29570: LD_EXP 91
29574: PPUSH
29575: CALL_OW 301
29579: IFFALSE 29503
// Say ( JMM , D19a-JMM-1 ) ;
29581: LD_EXP 38
29585: PPUSH
29586: LD_STRING D19a-JMM-1
29588: PPUSH
29589: CALL_OW 88
// if Heike then
29593: LD_EXP 92
29597: IFFALSE 29611
// Say ( Heike , D19a-Hke-1 ) ;
29599: LD_EXP 92
29603: PPUSH
29604: LD_STRING D19a-Hke-1
29606: PPUSH
29607: CALL_OW 88
// end ;
29611: PPOPN 4
29613: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29614: LD_INT 22
29616: PUSH
29617: LD_INT 3
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 21
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PPUSH
29638: CALL_OW 69
29642: PUSH
29643: LD_EXP 21
29647: AND
29648: IFFALSE 29716
29650: GO 29652
29652: DISABLE
29653: LD_INT 0
29655: PPUSH
29656: PPUSH
// begin enable ;
29657: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29658: LD_ADDR_VAR 0 2
29662: PUSH
29663: LD_INT 25
29665: PPUSH
29666: LD_INT 22
29668: PUSH
29669: LD_INT 3
29671: PUSH
29672: EMPTY
29673: LIST
29674: LIST
29675: PPUSH
29676: CALL_OW 70
29680: ST_TO_ADDR
// if not tmp then
29681: LD_VAR 0 2
29685: NOT
29686: IFFALSE 29690
// exit ;
29688: GO 29716
// for i in tmp do
29690: LD_ADDR_VAR 0 1
29694: PUSH
29695: LD_VAR 0 2
29699: PUSH
29700: FOR_IN
29701: IFFALSE 29714
// RemoveUnit ( i ) ;
29703: LD_VAR 0 1
29707: PPUSH
29708: CALL_OW 64
29712: GO 29700
29714: POP
29715: POP
// end ;
29716: PPOPN 2
29718: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29719: LD_INT 22
29721: PUSH
29722: LD_INT 7
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 21
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PPUSH
29743: CALL_OW 69
29747: PUSH
29748: LD_INT 6
29750: LESS
29751: IFFALSE 30202
29753: GO 29755
29755: DISABLE
29756: LD_INT 0
29758: PPUSH
29759: PPUSH
// begin MC_Kill ( 1 ) ;
29760: LD_INT 1
29762: PPUSH
29763: CALL 34295 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29767: LD_INT 7
29769: PPUSH
29770: LD_INT 1
29772: PPUSH
29773: LD_INT 1
29775: PPUSH
29776: LD_INT 1
29778: PPUSH
29779: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29783: LD_ADDR_VAR 0 1
29787: PUSH
29788: LD_INT 22
29790: PUSH
29791: LD_INT 7
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: PUSH
29798: LD_INT 26
29800: PUSH
29801: LD_INT 1
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: PPUSH
29812: CALL_OW 69
29816: PUSH
29817: LD_EXP 73
29821: DIFF
29822: ST_TO_ADDR
// if tmp then
29823: LD_VAR 0 1
29827: IFFALSE 29845
// tmp := tmp [ 1 ] else
29829: LD_ADDR_VAR 0 1
29833: PUSH
29834: LD_VAR 0 1
29838: PUSH
29839: LD_INT 1
29841: ARRAY
29842: ST_TO_ADDR
29843: GO 29881
// begin uc_side := 7 ;
29845: LD_ADDR_OWVAR 20
29849: PUSH
29850: LD_INT 7
29852: ST_TO_ADDR
// uc_nation := 1 ;
29853: LD_ADDR_OWVAR 21
29857: PUSH
29858: LD_INT 1
29860: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29861: LD_INT 1
29863: PPUSH
29864: LD_INT 8
29866: PPUSH
29867: CALL_OW 384
// tmp := CreateHuman ;
29871: LD_ADDR_VAR 0 1
29875: PUSH
29876: CALL_OW 44
29880: ST_TO_ADDR
// end ; DialogueOn ;
29881: CALL_OW 6
// if IsOK ( Roth ) then
29885: LD_EXP 73
29889: PPUSH
29890: CALL_OW 302
29894: IFFALSE 29908
// Say ( JMM , DAb-JMM-1 ) ;
29896: LD_EXP 38
29900: PPUSH
29901: LD_STRING DAb-JMM-1
29903: PPUSH
29904: CALL_OW 88
// if IsOK ( Roth ) then
29908: LD_EXP 73
29912: PPUSH
29913: CALL_OW 302
29917: IFFALSE 29941
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29919: LD_EXP 73
29923: PPUSH
29924: LD_STRING DSurrenderAlliance-Roth-1
29926: PPUSH
29927: CALL_OW 88
// RothCaptured := true ;
29931: LD_ADDR_EXP 33
29935: PUSH
29936: LD_INT 1
29938: ST_TO_ADDR
// end else
29939: GO 29953
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29941: LD_VAR 0 1
29945: PPUSH
29946: LD_STRING DSurrenderAlliance-Sci1-1
29948: PPUSH
29949: CALL_OW 88
// DialogueOff ;
29953: CALL_OW 7
// allianceDestroyed := true ;
29957: LD_ADDR_EXP 23
29961: PUSH
29962: LD_INT 1
29964: ST_TO_ADDR
// if trueAmericans then
29965: LD_EXP 35
29969: IFFALSE 30045
// begin if trueAmericans = 1 then
29971: LD_EXP 35
29975: PUSH
29976: LD_INT 1
29978: EQUAL
29979: IFFALSE 29995
// Say ( JMM , DAb-JMM-1a ) else
29981: LD_EXP 38
29985: PPUSH
29986: LD_STRING DAb-JMM-1a
29988: PPUSH
29989: CALL_OW 88
29993: GO 30007
// Say ( JMM , DAb-JMM-1b ) ;
29995: LD_EXP 38
29999: PPUSH
30000: LD_STRING DAb-JMM-1b
30002: PPUSH
30003: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30007: LD_EXP 35
30011: PPUSH
30012: CALL_OW 87
// for i in trueAmericans do
30016: LD_ADDR_VAR 0 2
30020: PUSH
30021: LD_EXP 35
30025: PUSH
30026: FOR_IN
30027: IFFALSE 30043
// SetSide ( i , 1 ) ;
30029: LD_VAR 0 2
30033: PPUSH
30034: LD_INT 1
30036: PPUSH
30037: CALL_OW 235
30041: GO 30026
30043: POP
30044: POP
// end ; repeat wait ( 0 0$1 ) ;
30045: LD_INT 35
30047: PPUSH
30048: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30052: LD_ADDR_VAR 0 2
30056: PUSH
30057: LD_INT 22
30059: PUSH
30060: LD_INT 7
30062: PUSH
30063: EMPTY
30064: LIST
30065: LIST
30066: PUSH
30067: LD_INT 21
30069: PUSH
30070: LD_INT 1
30072: PUSH
30073: EMPTY
30074: LIST
30075: LIST
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PPUSH
30081: CALL_OW 69
30085: PUSH
30086: FOR_IN
30087: IFFALSE 30169
// begin if IsInUnit ( i ) then
30089: LD_VAR 0 2
30093: PPUSH
30094: CALL_OW 310
30098: IFFALSE 30109
// ComExitBuilding ( i ) ;
30100: LD_VAR 0 2
30104: PPUSH
30105: CALL_OW 122
// if IsDriver ( i ) then
30109: LD_VAR 0 2
30113: PPUSH
30114: CALL 104788 0 1
30118: IFFALSE 30129
// ComExitVehicle ( i ) ;
30120: LD_VAR 0 2
30124: PPUSH
30125: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30129: LD_VAR 0 2
30133: PPUSH
30134: LD_INT 26
30136: PPUSH
30137: CALL_OW 308
30141: NOT
30142: IFFALSE 30158
// AddComMoveToArea ( i , allianceEscapeArea ) else
30144: LD_VAR 0 2
30148: PPUSH
30149: LD_INT 26
30151: PPUSH
30152: CALL_OW 173
30156: GO 30167
// RemoveUnit ( i ) ;
30158: LD_VAR 0 2
30162: PPUSH
30163: CALL_OW 64
// end ;
30167: GO 30086
30169: POP
30170: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30171: LD_INT 22
30173: PUSH
30174: LD_INT 7
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 21
30183: PUSH
30184: LD_INT 1
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PPUSH
30195: CALL_OW 69
30199: NOT
30200: IFFALSE 30045
// end ;
30202: PPOPN 2
30204: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30205: LD_INT 0
30207: PPUSH
30208: PPUSH
// if not unit then
30209: LD_VAR 0 1
30213: NOT
30214: IFFALSE 30218
// exit ;
30216: GO 31716
// DoNotAttack ( 7 , unit ) ;
30218: LD_INT 7
30220: PPUSH
30221: LD_VAR 0 1
30225: PPUSH
30226: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30230: LD_VAR 0 1
30234: PPUSH
30235: LD_INT 260
30237: PPUSH
30238: LD_INT 235
30240: PPUSH
30241: LD_INT 3
30243: PPUSH
30244: LD_INT 1
30246: PPUSH
30247: CALL_OW 483
// SetSide ( unit , 4 ) ;
30251: LD_VAR 0 1
30255: PPUSH
30256: LD_INT 4
30258: PPUSH
30259: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30263: LD_ADDR_EXP 34
30267: PUSH
30268: LD_EXP 34
30272: PUSH
30273: LD_INT 1
30275: PLUS
30276: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30277: LD_INT 70
30279: PPUSH
30280: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30284: LD_INT 260
30286: PPUSH
30287: LD_INT 235
30289: PPUSH
30290: LD_INT 1
30292: PPUSH
30293: LD_INT 8
30295: NEG
30296: PPUSH
30297: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30301: LD_VAR 0 1
30305: PPUSH
30306: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30310: LD_VAR 0 1
30314: PPUSH
30315: LD_EXP 73
30319: PPUSH
30320: CALL_OW 119
// DialogueOn ;
30324: CALL_OW 6
// case unit of JMM :
30328: LD_VAR 0 1
30332: PUSH
30333: LD_EXP 38
30337: DOUBLE
30338: EQUAL
30339: IFTRUE 30343
30341: GO 30358
30343: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30344: LD_EXP 38
30348: PPUSH
30349: LD_STRING DA1-JMM-1
30351: PPUSH
30352: CALL_OW 91
30356: GO 30800
30358: LD_EXP 39
30362: DOUBLE
30363: EQUAL
30364: IFTRUE 30368
30366: GO 30383
30368: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30369: LD_EXP 39
30373: PPUSH
30374: LD_STRING DA1-Joan-1
30376: PPUSH
30377: CALL_OW 91
30381: GO 30800
30383: LD_EXP 41
30387: DOUBLE
30388: EQUAL
30389: IFTRUE 30393
30391: GO 30408
30393: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30394: LD_EXP 41
30398: PPUSH
30399: LD_STRING DA1-Lisa-1
30401: PPUSH
30402: CALL_OW 91
30406: GO 30800
30408: LD_EXP 42
30412: DOUBLE
30413: EQUAL
30414: IFTRUE 30418
30416: GO 30433
30418: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30419: LD_EXP 42
30423: PPUSH
30424: LD_STRING DA1-Don-1
30426: PPUSH
30427: CALL_OW 91
30431: GO 30800
30433: LD_EXP 49
30437: DOUBLE
30438: EQUAL
30439: IFTRUE 30443
30441: GO 30458
30443: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30444: LD_EXP 49
30448: PPUSH
30449: LD_STRING DA1-Corn-1
30451: PPUSH
30452: CALL_OW 91
30456: GO 30800
30458: LD_EXP 45
30462: DOUBLE
30463: EQUAL
30464: IFTRUE 30468
30466: GO 30483
30468: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30469: LD_EXP 45
30473: PPUSH
30474: LD_STRING DA1-Den-1
30476: PPUSH
30477: CALL_OW 91
30481: GO 30800
30483: LD_EXP 43
30487: DOUBLE
30488: EQUAL
30489: IFTRUE 30493
30491: GO 30508
30493: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30494: LD_EXP 43
30498: PPUSH
30499: LD_STRING DA1-Bobby-1
30501: PPUSH
30502: CALL_OW 91
30506: GO 30800
30508: LD_EXP 47
30512: DOUBLE
30513: EQUAL
30514: IFTRUE 30518
30516: GO 30533
30518: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30519: LD_EXP 47
30523: PPUSH
30524: LD_STRING DA1-Glad-1
30526: PPUSH
30527: CALL_OW 91
30531: GO 30800
30533: LD_EXP 44
30537: DOUBLE
30538: EQUAL
30539: IFTRUE 30543
30541: GO 30558
30543: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30544: LD_EXP 44
30548: PPUSH
30549: LD_STRING DA1-Cyrus-1
30551: PPUSH
30552: CALL_OW 91
30556: GO 30800
30558: LD_EXP 40
30562: DOUBLE
30563: EQUAL
30564: IFTRUE 30568
30566: GO 30583
30568: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30569: LD_EXP 40
30573: PPUSH
30574: LD_STRING DA1-Huck-1
30576: PPUSH
30577: CALL_OW 91
30581: GO 30800
30583: LD_EXP 54
30587: DOUBLE
30588: EQUAL
30589: IFTRUE 30593
30591: GO 30608
30593: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30594: LD_EXP 54
30598: PPUSH
30599: LD_STRING DA1-Huck-1
30601: PPUSH
30602: CALL_OW 91
30606: GO 30800
30608: LD_EXP 46
30612: DOUBLE
30613: EQUAL
30614: IFTRUE 30618
30616: GO 30633
30618: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30619: LD_EXP 46
30623: PPUSH
30624: LD_STRING DA1-Brown-1
30626: PPUSH
30627: CALL_OW 91
30631: GO 30800
30633: LD_EXP 50
30637: DOUBLE
30638: EQUAL
30639: IFTRUE 30643
30641: GO 30658
30643: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30644: LD_EXP 50
30648: PPUSH
30649: LD_STRING DA1-Gary-1
30651: PPUSH
30652: CALL_OW 91
30656: GO 30800
30658: LD_EXP 53
30662: DOUBLE
30663: EQUAL
30664: IFTRUE 30668
30666: GO 30683
30668: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30669: LD_EXP 53
30673: PPUSH
30674: LD_STRING DA1-Con-1
30676: PPUSH
30677: CALL_OW 91
30681: GO 30800
30683: LD_EXP 59
30687: DOUBLE
30688: EQUAL
30689: IFTRUE 30693
30691: GO 30708
30693: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30694: LD_EXP 59
30698: PPUSH
30699: LD_STRING DA1-Kurt-1
30701: PPUSH
30702: CALL_OW 91
30706: GO 30800
30708: LD_EXP 52
30712: DOUBLE
30713: EQUAL
30714: IFTRUE 30718
30716: GO 30733
30718: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30719: LD_EXP 52
30723: PPUSH
30724: LD_STRING DA1-Yam-1
30726: PPUSH
30727: CALL_OW 91
30731: GO 30800
30733: LD_EXP 51
30737: DOUBLE
30738: EQUAL
30739: IFTRUE 30743
30741: GO 30758
30743: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30744: LD_EXP 51
30748: PPUSH
30749: LD_STRING DA1-Frank-1
30751: PPUSH
30752: CALL_OW 91
30756: GO 30800
30758: POP
// begin if GetSex ( unit ) = sex_male then
30759: LD_VAR 0 1
30763: PPUSH
30764: CALL_OW 258
30768: PUSH
30769: LD_INT 1
30771: EQUAL
30772: IFFALSE 30788
// ForceSay ( unit , DA1-Sol1-1 ) else
30774: LD_VAR 0 1
30778: PPUSH
30779: LD_STRING DA1-Sol1-1
30781: PPUSH
30782: CALL_OW 91
30786: GO 30800
// ForceSay ( unit , DA1-FSol1-1 ) ;
30788: LD_VAR 0 1
30792: PPUSH
30793: LD_STRING DA1-FSol1-1
30795: PPUSH
30796: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30800: LD_EXP 73
30804: PPUSH
30805: LD_STRING DA-Roth-1
30807: PPUSH
30808: CALL_OW 88
// if capturedUnit = 1 then
30812: LD_EXP 34
30816: PUSH
30817: LD_INT 1
30819: EQUAL
30820: IFFALSE 30848
// begin Say ( Simms , DA-Sim-1 ) ;
30822: LD_EXP 74
30826: PPUSH
30827: LD_STRING DA-Sim-1
30829: PPUSH
30830: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30834: LD_EXP 73
30838: PPUSH
30839: LD_STRING DA-Roth-2
30841: PPUSH
30842: CALL_OW 88
// end else
30846: GO 30860
// Say ( Simms , DA-Sim-2 ) ;
30848: LD_EXP 74
30852: PPUSH
30853: LD_STRING DA-Sim-2
30855: PPUSH
30856: CALL_OW 88
// case unit of JMM :
30860: LD_VAR 0 1
30864: PUSH
30865: LD_EXP 38
30869: DOUBLE
30870: EQUAL
30871: IFTRUE 30875
30873: GO 30890
30875: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30876: LD_EXP 38
30880: PPUSH
30881: LD_STRING DA1-JMM-1a
30883: PPUSH
30884: CALL_OW 91
30888: GO 31397
30890: LD_EXP 39
30894: DOUBLE
30895: EQUAL
30896: IFTRUE 30900
30898: GO 30915
30900: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30901: LD_EXP 39
30905: PPUSH
30906: LD_STRING DA1-Joan-1a
30908: PPUSH
30909: CALL_OW 91
30913: GO 31397
30915: LD_EXP 41
30919: DOUBLE
30920: EQUAL
30921: IFTRUE 30925
30923: GO 30940
30925: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30926: LD_EXP 41
30930: PPUSH
30931: LD_STRING DA1-Lisa-1a
30933: PPUSH
30934: CALL_OW 91
30938: GO 31397
30940: LD_EXP 42
30944: DOUBLE
30945: EQUAL
30946: IFTRUE 30950
30948: GO 30965
30950: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30951: LD_EXP 42
30955: PPUSH
30956: LD_STRING DA1-Don-1a
30958: PPUSH
30959: CALL_OW 91
30963: GO 31397
30965: LD_EXP 49
30969: DOUBLE
30970: EQUAL
30971: IFTRUE 30975
30973: GO 30990
30975: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30976: LD_EXP 49
30980: PPUSH
30981: LD_STRING DA1-Corn-1a
30983: PPUSH
30984: CALL_OW 91
30988: GO 31397
30990: LD_EXP 45
30994: DOUBLE
30995: EQUAL
30996: IFTRUE 31000
30998: GO 31015
31000: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31001: LD_EXP 45
31005: PPUSH
31006: LD_STRING DA1-Den-1a
31008: PPUSH
31009: CALL_OW 91
31013: GO 31397
31015: LD_EXP 43
31019: DOUBLE
31020: EQUAL
31021: IFTRUE 31025
31023: GO 31040
31025: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31026: LD_EXP 43
31030: PPUSH
31031: LD_STRING DA1-Bobby-1a
31033: PPUSH
31034: CALL_OW 91
31038: GO 31397
31040: LD_EXP 47
31044: DOUBLE
31045: EQUAL
31046: IFTRUE 31050
31048: GO 31065
31050: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31051: LD_EXP 47
31055: PPUSH
31056: LD_STRING DA1-Glad-1a
31058: PPUSH
31059: CALL_OW 91
31063: GO 31397
31065: LD_EXP 44
31069: DOUBLE
31070: EQUAL
31071: IFTRUE 31075
31073: GO 31090
31075: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31076: LD_EXP 44
31080: PPUSH
31081: LD_STRING DA1-Cyrus-1a
31083: PPUSH
31084: CALL_OW 91
31088: GO 31397
31090: LD_EXP 40
31094: DOUBLE
31095: EQUAL
31096: IFTRUE 31100
31098: GO 31115
31100: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31101: LD_EXP 40
31105: PPUSH
31106: LD_STRING DA1-Huck-1a
31108: PPUSH
31109: CALL_OW 91
31113: GO 31397
31115: LD_EXP 54
31119: DOUBLE
31120: EQUAL
31121: IFTRUE 31125
31123: GO 31140
31125: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31126: LD_EXP 54
31130: PPUSH
31131: LD_STRING DA1-Huck-1a
31133: PPUSH
31134: CALL_OW 91
31138: GO 31397
31140: LD_EXP 46
31144: DOUBLE
31145: EQUAL
31146: IFTRUE 31150
31148: GO 31165
31150: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31151: LD_EXP 46
31155: PPUSH
31156: LD_STRING DA1-Brown-1a
31158: PPUSH
31159: CALL_OW 91
31163: GO 31397
31165: LD_EXP 50
31169: DOUBLE
31170: EQUAL
31171: IFTRUE 31175
31173: GO 31190
31175: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31176: LD_EXP 50
31180: PPUSH
31181: LD_STRING DA1-Gary-1a
31183: PPUSH
31184: CALL_OW 91
31188: GO 31397
31190: LD_EXP 53
31194: DOUBLE
31195: EQUAL
31196: IFTRUE 31200
31198: GO 31215
31200: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31201: LD_EXP 53
31205: PPUSH
31206: LD_STRING DA1-Con-1a
31208: PPUSH
31209: CALL_OW 91
31213: GO 31397
31215: LD_EXP 59
31219: DOUBLE
31220: EQUAL
31221: IFTRUE 31225
31223: GO 31240
31225: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31226: LD_EXP 59
31230: PPUSH
31231: LD_STRING DA1-Kurt-1a
31233: PPUSH
31234: CALL_OW 91
31238: GO 31397
31240: LD_EXP 52
31244: DOUBLE
31245: EQUAL
31246: IFTRUE 31250
31248: GO 31265
31250: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31251: LD_EXP 52
31255: PPUSH
31256: LD_STRING DA1-Yam-1a
31258: PPUSH
31259: CALL_OW 91
31263: GO 31397
31265: LD_EXP 51
31269: DOUBLE
31270: EQUAL
31271: IFTRUE 31275
31273: GO 31290
31275: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31276: LD_EXP 51
31280: PPUSH
31281: LD_STRING DA1-Frank-1a
31283: PPUSH
31284: CALL_OW 91
31288: GO 31397
31290: POP
// begin join := rand ( 0 , 1 ) ;
31291: LD_ADDR_VAR 0 3
31295: PUSH
31296: LD_INT 0
31298: PPUSH
31299: LD_INT 1
31301: PPUSH
31302: CALL_OW 12
31306: ST_TO_ADDR
// if join then
31307: LD_VAR 0 3
31311: IFFALSE 31356
// begin if GetSex ( unit ) = sex_male then
31313: LD_VAR 0 1
31317: PPUSH
31318: CALL_OW 258
31322: PUSH
31323: LD_INT 1
31325: EQUAL
31326: IFFALSE 31342
// ForceSay ( unit , DA1-Sol1-1b ) else
31328: LD_VAR 0 1
31332: PPUSH
31333: LD_STRING DA1-Sol1-1b
31335: PPUSH
31336: CALL_OW 91
31340: GO 31354
// ForceSay ( unit , DA1-FSol1-1b ) ;
31342: LD_VAR 0 1
31346: PPUSH
31347: LD_STRING DA1-FSol1-1b
31349: PPUSH
31350: CALL_OW 91
// end else
31354: GO 31397
// begin if GetSex ( unit ) = sex_male then
31356: LD_VAR 0 1
31360: PPUSH
31361: CALL_OW 258
31365: PUSH
31366: LD_INT 1
31368: EQUAL
31369: IFFALSE 31385
// ForceSay ( unit , DA1-Sol1-1a ) else
31371: LD_VAR 0 1
31375: PPUSH
31376: LD_STRING DA1-Sol1-1a
31378: PPUSH
31379: CALL_OW 91
31383: GO 31397
// ForceSay ( unit , DA1-FSol1-1a ) ;
31385: LD_VAR 0 1
31389: PPUSH
31390: LD_STRING DA1-FSol1-1a
31392: PPUSH
31393: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31397: LD_VAR 0 1
31401: PUSH
31402: LD_EXP 38
31406: EQUAL
31407: IFFALSE 31418
// begin YouLost ( JMMCaptured ) ;
31409: LD_STRING JMMCaptured
31411: PPUSH
31412: CALL_OW 104
// exit ;
31416: GO 31716
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31418: LD_VAR 0 1
31422: PUSH
31423: LD_EXP 42
31427: PUSH
31428: LD_EXP 45
31432: PUSH
31433: LD_EXP 43
31437: PUSH
31438: LD_EXP 40
31442: PUSH
31443: LD_EXP 54
31447: PUSH
31448: LD_EXP 46
31452: PUSH
31453: LD_EXP 52
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: IN
31467: PUSH
31468: LD_VAR 0 3
31472: OR
31473: IFFALSE 31572
// begin Say ( Roth , DA-Roth-3 ) ;
31475: LD_EXP 73
31479: PPUSH
31480: LD_STRING DA-Roth-3
31482: PPUSH
31483: CALL_OW 88
// SetSide ( unit , 7 ) ;
31487: LD_VAR 0 1
31491: PPUSH
31492: LD_INT 7
31494: PPUSH
31495: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31499: LD_ADDR_EXP 101
31503: PUSH
31504: LD_EXP 101
31508: PPUSH
31509: LD_INT 1
31511: PPUSH
31512: LD_EXP 101
31516: PUSH
31517: LD_INT 1
31519: ARRAY
31520: PUSH
31521: LD_VAR 0 1
31525: ADD
31526: PPUSH
31527: CALL_OW 1
31531: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31532: LD_INT 260
31534: PPUSH
31535: LD_INT 235
31537: PPUSH
31538: LD_INT 1
31540: PPUSH
31541: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31545: LD_VAR 0 1
31549: PPUSH
31550: LD_INT 1000
31552: PPUSH
31553: CALL_OW 234
// DialogueOff ;
31557: CALL_OW 7
// ComFree ( unit ) ;
31561: LD_VAR 0 1
31565: PPUSH
31566: CALL_OW 139
// end else
31570: GO 31653
// begin Say ( Roth , DA-Roth-3a ) ;
31572: LD_EXP 73
31576: PPUSH
31577: LD_STRING DA-Roth-3a
31579: PPUSH
31580: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31584: LD_ADDR_EXP 35
31588: PUSH
31589: LD_EXP 35
31593: PUSH
31594: LD_VAR 0 1
31598: ADD
31599: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31600: LD_INT 260
31602: PPUSH
31603: LD_INT 235
31605: PPUSH
31606: LD_INT 1
31608: PPUSH
31609: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31613: LD_VAR 0 1
31617: PPUSH
31618: LD_INT 1000
31620: PPUSH
31621: CALL_OW 234
// DialogueOff ;
31625: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31629: LD_VAR 0 1
31633: PPUSH
31634: LD_INT 272
31636: PPUSH
31637: LD_INT 254
31639: PPUSH
31640: CALL_OW 111
// AddComHold ( unit ) ;
31644: LD_VAR 0 1
31648: PPUSH
31649: CALL_OW 200
// end ; if capturedUnit = 1 then
31653: LD_EXP 34
31657: PUSH
31658: LD_INT 1
31660: EQUAL
31661: IFFALSE 31716
// begin DialogueOn ;
31663: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31667: LD_EXP 38
31671: PPUSH
31672: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31676: LD_EXP 38
31680: PPUSH
31681: LD_STRING DAa-JMM-1
31683: PPUSH
31684: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31688: LD_EXP 38
31692: PPUSH
31693: LD_STRING DAa-JMM-1a
31695: PPUSH
31696: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31700: LD_EXP 38
31704: PPUSH
31705: LD_STRING DAa-JMM-1b
31707: PPUSH
31708: CALL_OW 88
// DialogueOff ;
31712: CALL_OW 7
// end ; end ;
31716: LD_VAR 0 2
31720: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31721: LD_EXP 15
31725: PUSH
31726: LD_INT 13
31728: GREATEREQUAL
31729: PUSH
31730: LD_INT 22
31732: PUSH
31733: LD_INT 2
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: LD_INT 21
31742: PUSH
31743: LD_INT 1
31745: PUSH
31746: EMPTY
31747: LIST
31748: LIST
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PPUSH
31754: CALL_OW 69
31758: PUSH
31759: LD_INT 0
31761: EQUAL
31762: AND
31763: PUSH
31764: LD_INT 22
31766: PUSH
31767: LD_INT 2
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 21
31776: PUSH
31777: LD_INT 2
31779: PUSH
31780: EMPTY
31781: LIST
31782: LIST
31783: PUSH
31784: LD_INT 50
31786: PUSH
31787: EMPTY
31788: LIST
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: LIST
31794: PPUSH
31795: CALL_OW 69
31799: PUSH
31800: LD_INT 0
31802: EQUAL
31803: AND
31804: PUSH
31805: LD_EXP 21
31809: AND
31810: PUSH
31811: LD_EXP 22
31815: AND
31816: PUSH
31817: LD_EXP 23
31821: AND
31822: IFFALSE 32464
31824: GO 31826
31826: DISABLE
31827: LD_INT 0
31829: PPUSH
31830: PPUSH
31831: PPUSH
// begin m1 := false ;
31832: LD_ADDR_VAR 0 1
31836: PUSH
31837: LD_INT 0
31839: ST_TO_ADDR
// m2 := false ;
31840: LD_ADDR_VAR 0 2
31844: PUSH
31845: LD_INT 0
31847: ST_TO_ADDR
// m3 := false ;
31848: LD_ADDR_VAR 0 3
31852: PUSH
31853: LD_INT 0
31855: ST_TO_ADDR
// if not bombExploded then
31856: LD_EXP 37
31860: NOT
31861: IFFALSE 31870
// SetAchievement ( ACH_SIBROCKET ) ;
31863: LD_STRING ACH_SIBROCKET
31865: PPUSH
31866: CALL_OW 543
// if tick <= 120 120$00 then
31870: LD_OWVAR 1
31874: PUSH
31875: LD_INT 252000
31877: LESSEQUAL
31878: IFFALSE 31894
// begin wait ( 3 ) ;
31880: LD_INT 3
31882: PPUSH
31883: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
31887: LD_STRING ACH_ASPEED_15
31889: PPUSH
31890: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
31894: LD_EXP 38
31898: PPUSH
31899: CALL_OW 87
// music_class := 5 ;
31903: LD_ADDR_OWVAR 72
31907: PUSH
31908: LD_INT 5
31910: ST_TO_ADDR
// music_nat := 5 ;
31911: LD_ADDR_OWVAR 71
31915: PUSH
31916: LD_INT 5
31918: ST_TO_ADDR
// DialogueOn ;
31919: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
31923: LD_EXP 38
31927: PPUSH
31928: LD_STRING D20-JMM-1
31930: PPUSH
31931: CALL_OW 88
// if IsOK ( Joan ) then
31935: LD_EXP 39
31939: PPUSH
31940: CALL_OW 302
31944: IFFALSE 31958
// Say ( Joan , D20-Joan-1 ) ;
31946: LD_EXP 39
31950: PPUSH
31951: LD_STRING D20-Joan-1
31953: PPUSH
31954: CALL_OW 88
// if IsOk ( Lisa ) then
31958: LD_EXP 41
31962: PPUSH
31963: CALL_OW 302
31967: IFFALSE 31981
// Say ( Lisa , D20-Lisa-1 ) ;
31969: LD_EXP 41
31973: PPUSH
31974: LD_STRING D20-Lisa-1
31976: PPUSH
31977: CALL_OW 88
// if IsOk ( Donaldson ) then
31981: LD_EXP 42
31985: PPUSH
31986: CALL_OW 302
31990: IFFALSE 32004
// Say ( Donaldson , D20-Don-1 ) ;
31992: LD_EXP 42
31996: PPUSH
31997: LD_STRING D20-Don-1
31999: PPUSH
32000: CALL_OW 88
// if IsOK ( Cornel ) then
32004: LD_EXP 49
32008: PPUSH
32009: CALL_OW 302
32013: IFFALSE 32027
// Say ( Cornel , D20-Corn-1 ) ;
32015: LD_EXP 49
32019: PPUSH
32020: LD_STRING D20-Corn-1
32022: PPUSH
32023: CALL_OW 88
// if IsOk ( Denis ) then
32027: LD_EXP 45
32031: PPUSH
32032: CALL_OW 302
32036: IFFALSE 32050
// Say ( Denis , D20-Den-1 ) ;
32038: LD_EXP 45
32042: PPUSH
32043: LD_STRING D20-Den-1
32045: PPUSH
32046: CALL_OW 88
// if IsOk ( Bobby ) then
32050: LD_EXP 43
32054: PPUSH
32055: CALL_OW 302
32059: IFFALSE 32073
// Say ( Bobby , D20-Bobby-1 ) ;
32061: LD_EXP 43
32065: PPUSH
32066: LD_STRING D20-Bobby-1
32068: PPUSH
32069: CALL_OW 88
// if IsOk ( Gladstone ) then
32073: LD_EXP 47
32077: PPUSH
32078: CALL_OW 302
32082: IFFALSE 32096
// Say ( Gladstone , D20-Glad-1 ) ;
32084: LD_EXP 47
32088: PPUSH
32089: LD_STRING D20-Glad-1
32091: PPUSH
32092: CALL_OW 88
// if IsOk ( Cyrus ) then
32096: LD_EXP 44
32100: PPUSH
32101: CALL_OW 302
32105: IFFALSE 32119
// Say ( Cyrus , D20-Cyrus-1 ) ;
32107: LD_EXP 44
32111: PPUSH
32112: LD_STRING D20-Cyrus-1
32114: PPUSH
32115: CALL_OW 88
// if IsOk ( Stevens ) then
32119: LD_EXP 40
32123: PPUSH
32124: CALL_OW 302
32128: IFFALSE 32142
// Say ( Stevens , D20-Huck-1 ) ;
32130: LD_EXP 40
32134: PPUSH
32135: LD_STRING D20-Huck-1
32137: PPUSH
32138: CALL_OW 88
// if IsOk ( Brown ) then
32142: LD_EXP 46
32146: PPUSH
32147: CALL_OW 302
32151: IFFALSE 32165
// Say ( Brown , D20-Brown-1 ) ;
32153: LD_EXP 46
32157: PPUSH
32158: LD_STRING D20-Brown-1
32160: PPUSH
32161: CALL_OW 88
// if IsOk ( Gary ) then
32165: LD_EXP 50
32169: PPUSH
32170: CALL_OW 302
32174: IFFALSE 32188
// Say ( Gary , D20-Gary-1 ) ;
32176: LD_EXP 50
32180: PPUSH
32181: LD_STRING D20-Gary-1
32183: PPUSH
32184: CALL_OW 88
// if IsOk ( Connie ) then
32188: LD_EXP 53
32192: PPUSH
32193: CALL_OW 302
32197: IFFALSE 32211
// Say ( Connie , D20-Con-1 ) ;
32199: LD_EXP 53
32203: PPUSH
32204: LD_STRING D20-Con-1
32206: PPUSH
32207: CALL_OW 88
// if IsOk ( Kurt ) then
32211: LD_EXP 59
32215: PPUSH
32216: CALL_OW 302
32220: IFFALSE 32234
// Say ( Kurt , D20-Kurt-1 ) ;
32222: LD_EXP 59
32226: PPUSH
32227: LD_STRING D20-Kurt-1
32229: PPUSH
32230: CALL_OW 88
// if IsOk ( Kikuchi ) then
32234: LD_EXP 52
32238: PPUSH
32239: CALL_OW 302
32243: IFFALSE 32257
// Say ( Kikuchi , D20-Yam-1 ) ;
32245: LD_EXP 52
32249: PPUSH
32250: LD_STRING D20-Yam-1
32252: PPUSH
32253: CALL_OW 88
// if IsOk ( Frank ) then
32257: LD_EXP 51
32261: PPUSH
32262: CALL_OW 302
32266: IFFALSE 32280
// Say ( Frank , D20-Frank-1 ) ;
32268: LD_EXP 51
32272: PPUSH
32273: LD_STRING D20-Frank-1
32275: PPUSH
32276: CALL_OW 88
// DialogueOff ;
32280: CALL_OW 7
// if RothCaptured then
32284: LD_EXP 33
32288: IFFALSE 32310
// begin m1 := true ;
32290: LD_ADDR_VAR 0 1
32294: PUSH
32295: LD_INT 1
32297: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32298: LD_STRING Roth
32300: PPUSH
32301: LD_INT 1
32303: PPUSH
32304: CALL_OW 101
// end else
32308: GO 32321
// AddMedal ( Roth , - 1 ) ;
32310: LD_STRING Roth
32312: PPUSH
32313: LD_INT 1
32315: NEG
32316: PPUSH
32317: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32321: LD_EXP 27
32325: IFFALSE 32347
// begin m2 := true ;
32327: LD_ADDR_VAR 0 2
32331: PUSH
32332: LD_INT 1
32334: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32335: LD_STRING Project
32337: PPUSH
32338: LD_INT 1
32340: PPUSH
32341: CALL_OW 101
// end else
32345: GO 32358
// AddMedal ( Project , - 1 ) ;
32347: LD_STRING Project
32349: PPUSH
32350: LD_INT 1
32352: NEG
32353: PPUSH
32354: CALL_OW 101
// if lostCounter = 0 then
32358: LD_EXP 32
32362: PUSH
32363: LD_INT 0
32365: EQUAL
32366: IFFALSE 32388
// begin m3 := true ;
32368: LD_ADDR_VAR 0 3
32372: PUSH
32373: LD_INT 1
32375: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32376: LD_STRING NoLosses
32378: PPUSH
32379: LD_INT 1
32381: PPUSH
32382: CALL_OW 101
// end else
32386: GO 32399
// AddMedal ( NoLosses , - 1 ) ;
32388: LD_STRING NoLosses
32390: PPUSH
32391: LD_INT 1
32393: NEG
32394: PPUSH
32395: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32399: LD_VAR 0 1
32403: PUSH
32404: LD_VAR 0 2
32408: AND
32409: PUSH
32410: LD_VAR 0 3
32414: AND
32415: PUSH
32416: LD_OWVAR 67
32420: PUSH
32421: LD_INT 3
32423: EQUAL
32424: AND
32425: IFFALSE 32437
// SetAchievementEX ( ACH_AMER , 15 ) ;
32427: LD_STRING ACH_AMER
32429: PPUSH
32430: LD_INT 15
32432: PPUSH
32433: CALL_OW 564
// GiveMedals ( MAIN ) ;
32437: LD_STRING MAIN
32439: PPUSH
32440: CALL_OW 102
// music_class := 4 ;
32444: LD_ADDR_OWVAR 72
32448: PUSH
32449: LD_INT 4
32451: ST_TO_ADDR
// music_nat := 1 ;
32452: LD_ADDR_OWVAR 71
32456: PUSH
32457: LD_INT 1
32459: ST_TO_ADDR
// YouWin ;
32460: CALL_OW 103
// end ; end_of_file
32464: PPOPN 3
32466: END
// export function CustomEvent ( event ) ; begin
32467: LD_INT 0
32469: PPUSH
// end ;
32470: LD_VAR 0 2
32474: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32475: LD_VAR 0 1
32479: PUSH
32480: LD_INT 1
32482: EQUAL
32483: PUSH
32484: LD_VAR 0 2
32488: PUSH
32489: LD_INT 4
32491: EQUAL
32492: AND
32493: PUSH
32494: LD_EXP 57
32498: PPUSH
32499: CALL_OW 300
32503: AND
32504: IFFALSE 32520
// begin wait ( 0 0$2 ) ;
32506: LD_INT 70
32508: PPUSH
32509: CALL_OW 67
// YouLost ( Dismissed ) ;
32513: LD_STRING Dismissed
32515: PPUSH
32516: CALL_OW 104
// end ; end ;
32520: PPOPN 2
32522: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32523: LD_VAR 0 2
32527: PPUSH
32528: LD_VAR 0 3
32532: PPUSH
32533: LD_INT 18
32535: PPUSH
32536: CALL_OW 309
32540: IFFALSE 32549
// YouLost ( Motherlode3 ) ;
32542: LD_STRING Motherlode3
32544: PPUSH
32545: CALL_OW 104
// end ;
32549: PPOPN 3
32551: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32552: LD_EXP 27
32556: NOT
32557: IFFALSE 32567
// behemothDone := true ;
32559: LD_ADDR_EXP 28
32563: PUSH
32564: LD_INT 1
32566: ST_TO_ADDR
// end ;
32567: PPOPN 1
32569: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
32570: LD_VAR 0 1
32574: PPUSH
32575: CALL_OW 255
32579: PUSH
32580: LD_INT 1
32582: EQUAL
32583: IFFALSE 32593
// bombExploded := true ;
32585: LD_ADDR_EXP 37
32589: PUSH
32590: LD_INT 1
32592: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32593: LD_VAR 0 1
32597: PPUSH
32598: CALL_OW 255
32602: PUSH
32603: LD_INT 1
32605: EQUAL
32606: PUSH
32607: LD_EXP 30
32611: AND
32612: PUSH
32613: LD_INT 22
32615: PUSH
32616: LD_INT 3
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 34
32625: PUSH
32626: LD_INT 48
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PPUSH
32637: CALL_OW 69
32641: AND
32642: PUSH
32643: LD_INT 22
32645: PUSH
32646: LD_INT 1
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 34
32655: PUSH
32656: LD_INT 8
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PPUSH
32667: CALL_OW 69
32671: NOT
32672: AND
32673: IFFALSE 32725
// begin wait ( 0 0$5 ) ;
32675: LD_INT 175
32677: PPUSH
32678: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32682: LD_INT 22
32684: PUSH
32685: LD_INT 3
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 34
32694: PUSH
32695: LD_INT 48
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PPUSH
32706: CALL_OW 69
32710: PUSH
32711: LD_INT 1
32713: ARRAY
32714: PPUSH
32715: LD_INT 60
32717: PPUSH
32718: LD_INT 95
32720: PPUSH
32721: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32725: LD_VAR 0 2
32729: PPUSH
32730: LD_VAR 0 3
32734: PPUSH
32735: LD_INT 18
32737: PPUSH
32738: CALL_OW 309
32742: IFFALSE 32802
// begin if GetSide ( unit ) = 1 then
32744: LD_VAR 0 1
32748: PPUSH
32749: CALL_OW 255
32753: PUSH
32754: LD_INT 1
32756: EQUAL
32757: IFFALSE 32773
// begin wait ( 0 0$6 ) ;
32759: LD_INT 210
32761: PPUSH
32762: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32766: LD_STRING Motherlode2
32768: PPUSH
32769: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32773: LD_VAR 0 1
32777: PPUSH
32778: CALL_OW 255
32782: PUSH
32783: LD_INT 8
32785: EQUAL
32786: IFFALSE 32802
// begin wait ( 0 0$6 ) ;
32788: LD_INT 210
32790: PPUSH
32791: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32795: LD_STRING Motherlode1
32797: PPUSH
32798: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32802: LD_VAR 0 1
32806: PPUSH
32807: CALL_OW 255
32811: PUSH
32812: LD_INT 3
32814: EQUAL
32815: IFFALSE 32836
// begin wait ( 0 0$5 ) ;
32817: LD_INT 175
32819: PPUSH
32820: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32824: LD_EXP 63
32828: PPUSH
32829: LD_STRING D18-Pla-1
32831: PPUSH
32832: CALL_OW 94
// end ; end ;
32836: PPOPN 3
32838: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32839: LD_VAR 0 1
32843: PUSH
32844: LD_EXP 72
32848: IN
32849: IFFALSE 32869
// begin behemothBuilders := behemothBuilders diff un ;
32851: LD_ADDR_EXP 72
32855: PUSH
32856: LD_EXP 72
32860: PUSH
32861: LD_VAR 0 1
32865: DIFF
32866: ST_TO_ADDR
// exit ;
32867: GO 32967
// end ; if un = JMM then
32869: LD_VAR 0 1
32873: PUSH
32874: LD_EXP 38
32878: EQUAL
32879: IFFALSE 32890
// begin YouLost ( JMM ) ;
32881: LD_STRING JMM
32883: PPUSH
32884: CALL_OW 104
// exit ;
32888: GO 32967
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32890: LD_VAR 0 1
32894: PUSH
32895: LD_INT 22
32897: PUSH
32898: LD_INT 1
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: PUSH
32905: LD_INT 3
32907: PUSH
32908: LD_INT 25
32910: PUSH
32911: LD_INT 16
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 25
32920: PUSH
32921: LD_INT 12
32923: PUSH
32924: EMPTY
32925: LIST
32926: LIST
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: LIST
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PPUSH
32937: CALL_OW 69
32941: IN
32942: IFFALSE 32958
// lostCounter := lostCounter + 1 ;
32944: LD_ADDR_EXP 32
32948: PUSH
32949: LD_EXP 32
32953: PUSH
32954: LD_INT 1
32956: PLUS
32957: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32958: LD_VAR 0 1
32962: PPUSH
32963: CALL 61251 0 1
// end ;
32967: PPOPN 1
32969: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32970: LD_VAR 0 1
32974: PPUSH
32975: LD_VAR 0 2
32979: PPUSH
32980: CALL 63585 0 2
// end ;
32984: PPOPN 2
32986: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32987: LD_VAR 0 1
32991: PPUSH
32992: CALL 62653 0 1
// end ;
32996: PPOPN 1
32998: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32999: LD_VAR 0 1
33003: PUSH
33004: LD_INT 22
33006: PUSH
33007: LD_INT 8
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: PUSH
33014: LD_INT 30
33016: PUSH
33017: LD_INT 2
33019: PUSH
33020: EMPTY
33021: LIST
33022: LIST
33023: PUSH
33024: LD_INT 23
33026: PUSH
33027: LD_INT 3
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: LIST
33038: PPUSH
33039: CALL_OW 69
33043: IN
33044: IFFALSE 33071
// begin ComUpgrade ( building ) ;
33046: LD_VAR 0 1
33050: PPUSH
33051: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33055: LD_EXP 60
33059: PPUSH
33060: LD_VAR 0 1
33064: PPUSH
33065: CALL 74291 0 2
// exit ;
33069: GO 33080
// end ; MCE_BuildingComplete ( building ) ;
33071: LD_VAR 0 1
33075: PPUSH
33076: CALL 62894 0 1
// end ;
33080: PPOPN 1
33082: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33083: LD_VAR 0 1
33087: PPUSH
33088: LD_VAR 0 2
33092: PPUSH
33093: CALL 60947 0 2
// end ;
33097: PPOPN 2
33099: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33100: LD_VAR 0 1
33104: PPUSH
33105: LD_VAR 0 2
33109: PPUSH
33110: LD_VAR 0 3
33114: PPUSH
33115: LD_VAR 0 4
33119: PPUSH
33120: LD_VAR 0 5
33124: PPUSH
33125: CALL 60567 0 5
// end ;
33129: PPOPN 5
33131: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33132: LD_VAR 0 1
33136: PPUSH
33137: LD_VAR 0 2
33141: PPUSH
33142: CALL 60163 0 2
// end ;
33146: PPOPN 2
33148: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33149: LD_VAR 0 1
33153: PPUSH
33154: LD_VAR 0 2
33158: PPUSH
33159: LD_VAR 0 3
33163: PPUSH
33164: LD_VAR 0 4
33168: PPUSH
33169: CALL 60001 0 4
// end ;
33173: PPOPN 4
33175: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33176: LD_VAR 0 1
33180: PPUSH
33181: LD_VAR 0 2
33185: PPUSH
33186: LD_VAR 0 3
33190: PPUSH
33191: CALL 59776 0 3
// end ;
33195: PPOPN 3
33197: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33198: LD_VAR 0 1
33202: PPUSH
33203: LD_VAR 0 2
33207: PPUSH
33208: CALL 59661 0 2
// end ;
33212: PPOPN 2
33214: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33215: LD_VAR 0 1
33219: PPUSH
33220: LD_VAR 0 2
33224: PPUSH
33225: CALL 63846 0 2
// end ;
33229: PPOPN 2
33231: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33232: LD_VAR 0 1
33236: PPUSH
33237: CALL_OW 255
33241: PUSH
33242: LD_INT 4
33244: EQUAL
33245: PUSH
33246: LD_VAR 0 1
33250: PUSH
33251: LD_EXP 18
33255: PUSH
33256: LD_INT 1
33258: ARRAY
33259: IN
33260: AND
33261: PUSH
33262: LD_EXP 19
33266: AND
33267: IFFALSE 33286
// begin ComMoveXY ( driver , 61 , 93 ) ;
33269: LD_VAR 0 1
33273: PPUSH
33274: LD_INT 61
33276: PPUSH
33277: LD_INT 93
33279: PPUSH
33280: CALL_OW 111
// exit ;
33284: GO 33310
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33286: LD_VAR 0 1
33290: PPUSH
33291: LD_VAR 0 2
33295: PPUSH
33296: LD_VAR 0 3
33300: PPUSH
33301: LD_VAR 0 4
33305: PPUSH
33306: CALL 64062 0 4
// end ;
33310: PPOPN 4
33312: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33313: LD_VAR 0 1
33317: PPUSH
33318: LD_VAR 0 2
33322: PPUSH
33323: CALL 59470 0 2
// end ;
33327: PPOPN 2
33329: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33330: LD_VAR 0 1
33334: PPUSH
33335: CALL 107463 0 1
// end ; end_of_file
33339: PPOPN 1
33341: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33342: LD_EXP 15
33346: PUSH
33347: LD_INT 2
33349: EQUAL
33350: IFFALSE 33829
33352: GO 33354
33354: DISABLE
33355: LD_INT 0
33357: PPUSH
// begin time := 0 0$40 ;
33358: LD_ADDR_VAR 0 1
33362: PUSH
33363: LD_INT 1400
33365: ST_TO_ADDR
// repeat wait ( time ) ;
33366: LD_VAR 0 1
33370: PPUSH
33371: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33375: LD_INT 1
33377: PPUSH
33378: LD_INT 5
33380: PPUSH
33381: CALL_OW 12
33385: PPUSH
33386: LD_INT 106
33388: PPUSH
33389: LD_INT 150
33391: PPUSH
33392: LD_INT 19
33394: PPUSH
33395: LD_INT 1
33397: PPUSH
33398: CALL_OW 56
// time := time + 0 0$9 ;
33402: LD_ADDR_VAR 0 1
33406: PUSH
33407: LD_VAR 0 1
33411: PUSH
33412: LD_INT 315
33414: PLUS
33415: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33416: LD_INT 455
33418: PPUSH
33419: LD_INT 840
33421: PPUSH
33422: CALL_OW 12
33426: PPUSH
33427: CALL_OW 67
// if Prob ( 50 ) then
33431: LD_INT 50
33433: PPUSH
33434: CALL_OW 13
33438: IFFALSE 33467
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33440: LD_INT 1
33442: PPUSH
33443: LD_INT 5
33445: PPUSH
33446: CALL_OW 12
33450: PPUSH
33451: LD_INT 62
33453: PPUSH
33454: LD_INT 108
33456: PPUSH
33457: LD_INT 10
33459: PPUSH
33460: LD_INT 1
33462: PPUSH
33463: CALL_OW 56
// until missionStage > 4 ;
33467: LD_EXP 15
33471: PUSH
33472: LD_INT 4
33474: GREATER
33475: IFFALSE 33366
// repeat wait ( 0 0$1 ) ;
33477: LD_INT 35
33479: PPUSH
33480: CALL_OW 67
// until missionStage = 6 ;
33484: LD_EXP 15
33488: PUSH
33489: LD_INT 6
33491: EQUAL
33492: IFFALSE 33477
// time := 0 0$50 ;
33494: LD_ADDR_VAR 0 1
33498: PUSH
33499: LD_INT 1750
33501: ST_TO_ADDR
// repeat wait ( time ) ;
33502: LD_VAR 0 1
33506: PPUSH
33507: CALL_OW 67
// if Prob ( 50 ) then
33511: LD_INT 50
33513: PPUSH
33514: CALL_OW 13
33518: IFFALSE 33547
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33520: LD_INT 1
33522: PPUSH
33523: LD_INT 5
33525: PPUSH
33526: CALL_OW 12
33530: PPUSH
33531: LD_INT 106
33533: PPUSH
33534: LD_INT 89
33536: PPUSH
33537: LD_INT 45
33539: PPUSH
33540: LD_INT 1
33542: PPUSH
33543: CALL_OW 56
// time := time + 0 0$3 ;
33547: LD_ADDR_VAR 0 1
33551: PUSH
33552: LD_VAR 0 1
33556: PUSH
33557: LD_INT 105
33559: PLUS
33560: ST_TO_ADDR
// if Prob ( 30 ) then
33561: LD_INT 30
33563: PPUSH
33564: CALL_OW 13
33568: IFFALSE 33614
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33570: LD_INT 525
33572: PPUSH
33573: LD_INT 735
33575: PPUSH
33576: CALL_OW 12
33580: PPUSH
33581: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33585: LD_INT 1
33587: PPUSH
33588: LD_INT 5
33590: PPUSH
33591: CALL_OW 12
33595: PPUSH
33596: LD_INT 21
33598: PPUSH
33599: LD_INT 26
33601: PPUSH
33602: LD_INT 12
33604: PPUSH
33605: LD_INT 1
33607: PPUSH
33608: CALL_OW 56
// end else
33612: GO 33650
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33614: LD_INT 700
33616: PPUSH
33617: LD_INT 1225
33619: PPUSH
33620: CALL_OW 12
33624: PPUSH
33625: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33629: LD_INT 1
33631: PPUSH
33632: LD_INT 5
33634: PPUSH
33635: CALL_OW 12
33639: PPUSH
33640: LD_INT 16
33642: PPUSH
33643: LD_INT 1
33645: PPUSH
33646: CALL_OW 55
// end ; if Prob ( 50 ) then
33650: LD_INT 50
33652: PPUSH
33653: CALL_OW 13
33657: IFFALSE 33703
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33659: LD_INT 700
33661: PPUSH
33662: LD_INT 1050
33664: PPUSH
33665: CALL_OW 12
33669: PPUSH
33670: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33674: LD_INT 1
33676: PPUSH
33677: LD_INT 5
33679: PPUSH
33680: CALL_OW 12
33684: PPUSH
33685: LD_INT 181
33687: PPUSH
33688: LD_INT 218
33690: PPUSH
33691: LD_INT 16
33693: PPUSH
33694: LD_INT 1
33696: PPUSH
33697: CALL_OW 56
// end else
33701: GO 33739
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33703: LD_INT 350
33705: PPUSH
33706: LD_INT 525
33708: PPUSH
33709: CALL_OW 12
33713: PPUSH
33714: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33718: LD_INT 1
33720: PPUSH
33721: LD_INT 5
33723: PPUSH
33724: CALL_OW 12
33728: PPUSH
33729: LD_INT 15
33731: PPUSH
33732: LD_INT 1
33734: PPUSH
33735: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33739: LD_INT 45
33741: PUSH
33742: LD_INT 32
33744: PUSH
33745: LD_INT 25
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: LIST
33752: PUSH
33753: LD_OWVAR 67
33757: ARRAY
33758: PPUSH
33759: CALL_OW 13
33763: IFFALSE 33807
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33765: LD_INT 525
33767: PPUSH
33768: LD_INT 875
33770: PPUSH
33771: CALL_OW 12
33775: PPUSH
33776: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33780: LD_INT 1
33782: PPUSH
33783: LD_INT 5
33785: PPUSH
33786: CALL_OW 12
33790: PPUSH
33791: LD_INT 103
33793: PPUSH
33794: LD_INT 140
33796: PPUSH
33797: LD_INT 20
33799: PPUSH
33800: LD_INT 1
33802: PPUSH
33803: CALL_OW 56
// end ; if time > 2 2$20 then
33807: LD_VAR 0 1
33811: PUSH
33812: LD_INT 4900
33814: GREATER
33815: IFFALSE 33825
// time := 0 0$50 ;
33817: LD_ADDR_VAR 0 1
33821: PUSH
33822: LD_INT 1750
33824: ST_TO_ADDR
// until false ;
33825: LD_INT 0
33827: IFFALSE 33502
// end ; end_of_file
33829: PPOPN 1
33831: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33832: LD_EXP 13
33836: PUSH
33837: LD_EXP 15
33841: PUSH
33842: LD_INT 6
33844: GREATEREQUAL
33845: AND
33846: IFFALSE 33883
33848: GO 33850
33850: DISABLE
// begin enable ;
33851: ENABLE
// missionTime := missionTime + 0 0$1 ;
33852: LD_ADDR_EXP 14
33856: PUSH
33857: LD_EXP 14
33861: PUSH
33862: LD_INT 35
33864: PLUS
33865: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33866: LD_ADDR_OWVAR 47
33870: PUSH
33871: LD_STRING #Am15-1
33873: PUSH
33874: LD_EXP 14
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: ST_TO_ADDR
// end ; end_of_file
33883: END
// export function InitNature ; begin
33884: LD_INT 0
33886: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33887: LD_INT 3
33889: PPUSH
33890: LD_INT 3
33892: PPUSH
33893: LD_INT 2
33895: PPUSH
33896: LD_INT 1
33898: PPUSH
33899: LD_INT 1
33901: PPUSH
33902: LD_INT 0
33904: PPUSH
33905: LD_INT 0
33907: PPUSH
33908: LD_INT 20
33910: PPUSH
33911: LD_INT 0
33913: PPUSH
33914: CALL 99132 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33918: LD_INT 2
33920: PPUSH
33921: LD_INT 1
33923: PPUSH
33924: LD_INT 1
33926: PPUSH
33927: LD_INT 1
33929: PPUSH
33930: LD_INT 1
33932: PPUSH
33933: LD_INT 0
33935: PPUSH
33936: LD_INT 0
33938: PPUSH
33939: LD_INT 21
33941: PPUSH
33942: LD_INT 0
33944: PPUSH
33945: CALL 99132 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33949: LD_INT 4
33951: PPUSH
33952: LD_INT 1
33954: PPUSH
33955: LD_INT 2
33957: PPUSH
33958: LD_INT 4
33960: PPUSH
33961: LD_INT 2
33963: PPUSH
33964: LD_INT 1
33966: PPUSH
33967: LD_INT 0
33969: PPUSH
33970: LD_INT 22
33972: PPUSH
33973: LD_INT 0
33975: PPUSH
33976: CALL 99132 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33980: LD_INT 0
33982: PPUSH
33983: LD_INT 0
33985: PPUSH
33986: LD_INT 0
33988: PPUSH
33989: LD_INT 0
33991: PPUSH
33992: LD_INT 0
33994: PPUSH
33995: LD_INT 0
33997: PPUSH
33998: LD_INT 9
34000: PPUSH
34001: LD_INT 0
34003: PPUSH
34004: LD_INT 23
34006: PPUSH
34007: CALL 99132 0 9
// end ; end_of_file
34011: LD_VAR 0 1
34015: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34016: GO 34018
34018: DISABLE
// begin ru_radar := 98 ;
34019: LD_ADDR_EXP 94
34023: PUSH
34024: LD_INT 98
34026: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34027: LD_ADDR_EXP 95
34031: PUSH
34032: LD_INT 89
34034: ST_TO_ADDR
// us_hack := 99 ;
34035: LD_ADDR_EXP 96
34039: PUSH
34040: LD_INT 99
34042: ST_TO_ADDR
// us_artillery := 97 ;
34043: LD_ADDR_EXP 97
34047: PUSH
34048: LD_INT 97
34050: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34051: LD_ADDR_EXP 98
34055: PUSH
34056: LD_INT 91
34058: ST_TO_ADDR
// end ; end_of_file
34059: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34060: LD_INT 0
34062: PPUSH
34063: PPUSH
// skirmish := false ;
34064: LD_ADDR_EXP 99
34068: PUSH
34069: LD_INT 0
34071: ST_TO_ADDR
// debug_mc := false ;
34072: LD_ADDR_EXP 100
34076: PUSH
34077: LD_INT 0
34079: ST_TO_ADDR
// mc_bases := [ ] ;
34080: LD_ADDR_EXP 101
34084: PUSH
34085: EMPTY
34086: ST_TO_ADDR
// mc_sides := [ ] ;
34087: LD_ADDR_EXP 127
34091: PUSH
34092: EMPTY
34093: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34094: LD_ADDR_EXP 102
34098: PUSH
34099: EMPTY
34100: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34101: LD_ADDR_EXP 103
34105: PUSH
34106: EMPTY
34107: ST_TO_ADDR
// mc_need_heal := [ ] ;
34108: LD_ADDR_EXP 104
34112: PUSH
34113: EMPTY
34114: ST_TO_ADDR
// mc_healers := [ ] ;
34115: LD_ADDR_EXP 105
34119: PUSH
34120: EMPTY
34121: ST_TO_ADDR
// mc_build_list := [ ] ;
34122: LD_ADDR_EXP 106
34126: PUSH
34127: EMPTY
34128: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34129: LD_ADDR_EXP 133
34133: PUSH
34134: EMPTY
34135: ST_TO_ADDR
// mc_builders := [ ] ;
34136: LD_ADDR_EXP 107
34140: PUSH
34141: EMPTY
34142: ST_TO_ADDR
// mc_construct_list := [ ] ;
34143: LD_ADDR_EXP 108
34147: PUSH
34148: EMPTY
34149: ST_TO_ADDR
// mc_turret_list := [ ] ;
34150: LD_ADDR_EXP 109
34154: PUSH
34155: EMPTY
34156: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34157: LD_ADDR_EXP 110
34161: PUSH
34162: EMPTY
34163: ST_TO_ADDR
// mc_miners := [ ] ;
34164: LD_ADDR_EXP 115
34168: PUSH
34169: EMPTY
34170: ST_TO_ADDR
// mc_mines := [ ] ;
34171: LD_ADDR_EXP 114
34175: PUSH
34176: EMPTY
34177: ST_TO_ADDR
// mc_minefields := [ ] ;
34178: LD_ADDR_EXP 116
34182: PUSH
34183: EMPTY
34184: ST_TO_ADDR
// mc_crates := [ ] ;
34185: LD_ADDR_EXP 117
34189: PUSH
34190: EMPTY
34191: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34192: LD_ADDR_EXP 118
34196: PUSH
34197: EMPTY
34198: ST_TO_ADDR
// mc_crates_area := [ ] ;
34199: LD_ADDR_EXP 119
34203: PUSH
34204: EMPTY
34205: ST_TO_ADDR
// mc_vehicles := [ ] ;
34206: LD_ADDR_EXP 120
34210: PUSH
34211: EMPTY
34212: ST_TO_ADDR
// mc_attack := [ ] ;
34213: LD_ADDR_EXP 121
34217: PUSH
34218: EMPTY
34219: ST_TO_ADDR
// mc_produce := [ ] ;
34220: LD_ADDR_EXP 122
34224: PUSH
34225: EMPTY
34226: ST_TO_ADDR
// mc_defender := [ ] ;
34227: LD_ADDR_EXP 123
34231: PUSH
34232: EMPTY
34233: ST_TO_ADDR
// mc_parking := [ ] ;
34234: LD_ADDR_EXP 125
34238: PUSH
34239: EMPTY
34240: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34241: LD_ADDR_EXP 111
34245: PUSH
34246: EMPTY
34247: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34248: LD_ADDR_EXP 113
34252: PUSH
34253: EMPTY
34254: ST_TO_ADDR
// mc_scan := [ ] ;
34255: LD_ADDR_EXP 124
34259: PUSH
34260: EMPTY
34261: ST_TO_ADDR
// mc_scan_area := [ ] ;
34262: LD_ADDR_EXP 126
34266: PUSH
34267: EMPTY
34268: ST_TO_ADDR
// mc_tech := [ ] ;
34269: LD_ADDR_EXP 128
34273: PUSH
34274: EMPTY
34275: ST_TO_ADDR
// mc_class := [ ] ;
34276: LD_ADDR_EXP 142
34280: PUSH
34281: EMPTY
34282: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34283: LD_ADDR_EXP 143
34287: PUSH
34288: EMPTY
34289: ST_TO_ADDR
// end ;
34290: LD_VAR 0 1
34294: RET
// export function MC_Kill ( base ) ; begin
34295: LD_INT 0
34297: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34298: LD_ADDR_EXP 101
34302: PUSH
34303: LD_EXP 101
34307: PPUSH
34308: LD_VAR 0 1
34312: PPUSH
34313: EMPTY
34314: PPUSH
34315: CALL_OW 1
34319: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34320: LD_ADDR_EXP 102
34324: PUSH
34325: LD_EXP 102
34329: PPUSH
34330: LD_VAR 0 1
34334: PPUSH
34335: EMPTY
34336: PPUSH
34337: CALL_OW 1
34341: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34342: LD_ADDR_EXP 103
34346: PUSH
34347: LD_EXP 103
34351: PPUSH
34352: LD_VAR 0 1
34356: PPUSH
34357: EMPTY
34358: PPUSH
34359: CALL_OW 1
34363: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34364: LD_ADDR_EXP 104
34368: PUSH
34369: LD_EXP 104
34373: PPUSH
34374: LD_VAR 0 1
34378: PPUSH
34379: EMPTY
34380: PPUSH
34381: CALL_OW 1
34385: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34386: LD_ADDR_EXP 105
34390: PUSH
34391: LD_EXP 105
34395: PPUSH
34396: LD_VAR 0 1
34400: PPUSH
34401: EMPTY
34402: PPUSH
34403: CALL_OW 1
34407: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34408: LD_ADDR_EXP 106
34412: PUSH
34413: LD_EXP 106
34417: PPUSH
34418: LD_VAR 0 1
34422: PPUSH
34423: EMPTY
34424: PPUSH
34425: CALL_OW 1
34429: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34430: LD_ADDR_EXP 107
34434: PUSH
34435: LD_EXP 107
34439: PPUSH
34440: LD_VAR 0 1
34444: PPUSH
34445: EMPTY
34446: PPUSH
34447: CALL_OW 1
34451: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34452: LD_ADDR_EXP 108
34456: PUSH
34457: LD_EXP 108
34461: PPUSH
34462: LD_VAR 0 1
34466: PPUSH
34467: EMPTY
34468: PPUSH
34469: CALL_OW 1
34473: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34474: LD_ADDR_EXP 109
34478: PUSH
34479: LD_EXP 109
34483: PPUSH
34484: LD_VAR 0 1
34488: PPUSH
34489: EMPTY
34490: PPUSH
34491: CALL_OW 1
34495: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34496: LD_ADDR_EXP 110
34500: PUSH
34501: LD_EXP 110
34505: PPUSH
34506: LD_VAR 0 1
34510: PPUSH
34511: EMPTY
34512: PPUSH
34513: CALL_OW 1
34517: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34518: LD_ADDR_EXP 111
34522: PUSH
34523: LD_EXP 111
34527: PPUSH
34528: LD_VAR 0 1
34532: PPUSH
34533: EMPTY
34534: PPUSH
34535: CALL_OW 1
34539: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34540: LD_ADDR_EXP 112
34544: PUSH
34545: LD_EXP 112
34549: PPUSH
34550: LD_VAR 0 1
34554: PPUSH
34555: LD_INT 0
34557: PPUSH
34558: CALL_OW 1
34562: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34563: LD_ADDR_EXP 113
34567: PUSH
34568: LD_EXP 113
34572: PPUSH
34573: LD_VAR 0 1
34577: PPUSH
34578: EMPTY
34579: PPUSH
34580: CALL_OW 1
34584: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34585: LD_ADDR_EXP 114
34589: PUSH
34590: LD_EXP 114
34594: PPUSH
34595: LD_VAR 0 1
34599: PPUSH
34600: EMPTY
34601: PPUSH
34602: CALL_OW 1
34606: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34607: LD_ADDR_EXP 115
34611: PUSH
34612: LD_EXP 115
34616: PPUSH
34617: LD_VAR 0 1
34621: PPUSH
34622: EMPTY
34623: PPUSH
34624: CALL_OW 1
34628: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34629: LD_ADDR_EXP 116
34633: PUSH
34634: LD_EXP 116
34638: PPUSH
34639: LD_VAR 0 1
34643: PPUSH
34644: EMPTY
34645: PPUSH
34646: CALL_OW 1
34650: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34651: LD_ADDR_EXP 117
34655: PUSH
34656: LD_EXP 117
34660: PPUSH
34661: LD_VAR 0 1
34665: PPUSH
34666: EMPTY
34667: PPUSH
34668: CALL_OW 1
34672: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34673: LD_ADDR_EXP 118
34677: PUSH
34678: LD_EXP 118
34682: PPUSH
34683: LD_VAR 0 1
34687: PPUSH
34688: EMPTY
34689: PPUSH
34690: CALL_OW 1
34694: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34695: LD_ADDR_EXP 119
34699: PUSH
34700: LD_EXP 119
34704: PPUSH
34705: LD_VAR 0 1
34709: PPUSH
34710: EMPTY
34711: PPUSH
34712: CALL_OW 1
34716: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34717: LD_ADDR_EXP 120
34721: PUSH
34722: LD_EXP 120
34726: PPUSH
34727: LD_VAR 0 1
34731: PPUSH
34732: EMPTY
34733: PPUSH
34734: CALL_OW 1
34738: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34739: LD_ADDR_EXP 121
34743: PUSH
34744: LD_EXP 121
34748: PPUSH
34749: LD_VAR 0 1
34753: PPUSH
34754: EMPTY
34755: PPUSH
34756: CALL_OW 1
34760: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34761: LD_ADDR_EXP 122
34765: PUSH
34766: LD_EXP 122
34770: PPUSH
34771: LD_VAR 0 1
34775: PPUSH
34776: EMPTY
34777: PPUSH
34778: CALL_OW 1
34782: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34783: LD_ADDR_EXP 123
34787: PUSH
34788: LD_EXP 123
34792: PPUSH
34793: LD_VAR 0 1
34797: PPUSH
34798: EMPTY
34799: PPUSH
34800: CALL_OW 1
34804: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34805: LD_ADDR_EXP 124
34809: PUSH
34810: LD_EXP 124
34814: PPUSH
34815: LD_VAR 0 1
34819: PPUSH
34820: EMPTY
34821: PPUSH
34822: CALL_OW 1
34826: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34827: LD_ADDR_EXP 125
34831: PUSH
34832: LD_EXP 125
34836: PPUSH
34837: LD_VAR 0 1
34841: PPUSH
34842: EMPTY
34843: PPUSH
34844: CALL_OW 1
34848: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34849: LD_ADDR_EXP 126
34853: PUSH
34854: LD_EXP 126
34858: PPUSH
34859: LD_VAR 0 1
34863: PPUSH
34864: EMPTY
34865: PPUSH
34866: CALL_OW 1
34870: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34871: LD_ADDR_EXP 128
34875: PUSH
34876: LD_EXP 128
34880: PPUSH
34881: LD_VAR 0 1
34885: PPUSH
34886: EMPTY
34887: PPUSH
34888: CALL_OW 1
34892: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34893: LD_ADDR_EXP 130
34897: PUSH
34898: LD_EXP 130
34902: PPUSH
34903: LD_VAR 0 1
34907: PPUSH
34908: EMPTY
34909: PPUSH
34910: CALL_OW 1
34914: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34915: LD_ADDR_EXP 131
34919: PUSH
34920: LD_EXP 131
34924: PPUSH
34925: LD_VAR 0 1
34929: PPUSH
34930: EMPTY
34931: PPUSH
34932: CALL_OW 1
34936: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34937: LD_ADDR_EXP 132
34941: PUSH
34942: LD_EXP 132
34946: PPUSH
34947: LD_VAR 0 1
34951: PPUSH
34952: EMPTY
34953: PPUSH
34954: CALL_OW 1
34958: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34959: LD_ADDR_EXP 133
34963: PUSH
34964: LD_EXP 133
34968: PPUSH
34969: LD_VAR 0 1
34973: PPUSH
34974: EMPTY
34975: PPUSH
34976: CALL_OW 1
34980: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34981: LD_ADDR_EXP 134
34985: PUSH
34986: LD_EXP 134
34990: PPUSH
34991: LD_VAR 0 1
34995: PPUSH
34996: EMPTY
34997: PPUSH
34998: CALL_OW 1
35002: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35003: LD_ADDR_EXP 135
35007: PUSH
35008: LD_EXP 135
35012: PPUSH
35013: LD_VAR 0 1
35017: PPUSH
35018: EMPTY
35019: PPUSH
35020: CALL_OW 1
35024: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35025: LD_ADDR_EXP 136
35029: PUSH
35030: LD_EXP 136
35034: PPUSH
35035: LD_VAR 0 1
35039: PPUSH
35040: EMPTY
35041: PPUSH
35042: CALL_OW 1
35046: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35047: LD_ADDR_EXP 137
35051: PUSH
35052: LD_EXP 137
35056: PPUSH
35057: LD_VAR 0 1
35061: PPUSH
35062: EMPTY
35063: PPUSH
35064: CALL_OW 1
35068: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35069: LD_ADDR_EXP 138
35073: PUSH
35074: LD_EXP 138
35078: PPUSH
35079: LD_VAR 0 1
35083: PPUSH
35084: EMPTY
35085: PPUSH
35086: CALL_OW 1
35090: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35091: LD_ADDR_EXP 139
35095: PUSH
35096: LD_EXP 139
35100: PPUSH
35101: LD_VAR 0 1
35105: PPUSH
35106: EMPTY
35107: PPUSH
35108: CALL_OW 1
35112: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35113: LD_ADDR_EXP 140
35117: PUSH
35118: LD_EXP 140
35122: PPUSH
35123: LD_VAR 0 1
35127: PPUSH
35128: EMPTY
35129: PPUSH
35130: CALL_OW 1
35134: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35135: LD_ADDR_EXP 141
35139: PUSH
35140: LD_EXP 141
35144: PPUSH
35145: LD_VAR 0 1
35149: PPUSH
35150: EMPTY
35151: PPUSH
35152: CALL_OW 1
35156: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35157: LD_ADDR_EXP 142
35161: PUSH
35162: LD_EXP 142
35166: PPUSH
35167: LD_VAR 0 1
35171: PPUSH
35172: EMPTY
35173: PPUSH
35174: CALL_OW 1
35178: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35179: LD_ADDR_EXP 143
35183: PUSH
35184: LD_EXP 143
35188: PPUSH
35189: LD_VAR 0 1
35193: PPUSH
35194: LD_INT 0
35196: PPUSH
35197: CALL_OW 1
35201: ST_TO_ADDR
// end ;
35202: LD_VAR 0 2
35206: RET
// export function MC_Add ( side , units ) ; var base ; begin
35207: LD_INT 0
35209: PPUSH
35210: PPUSH
// base := mc_bases + 1 ;
35211: LD_ADDR_VAR 0 4
35215: PUSH
35216: LD_EXP 101
35220: PUSH
35221: LD_INT 1
35223: PLUS
35224: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35225: LD_ADDR_EXP 127
35229: PUSH
35230: LD_EXP 127
35234: PPUSH
35235: LD_VAR 0 4
35239: PPUSH
35240: LD_VAR 0 1
35244: PPUSH
35245: CALL_OW 1
35249: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35250: LD_ADDR_EXP 101
35254: PUSH
35255: LD_EXP 101
35259: PPUSH
35260: LD_VAR 0 4
35264: PPUSH
35265: LD_VAR 0 2
35269: PPUSH
35270: CALL_OW 1
35274: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35275: LD_ADDR_EXP 102
35279: PUSH
35280: LD_EXP 102
35284: PPUSH
35285: LD_VAR 0 4
35289: PPUSH
35290: EMPTY
35291: PPUSH
35292: CALL_OW 1
35296: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35297: LD_ADDR_EXP 103
35301: PUSH
35302: LD_EXP 103
35306: PPUSH
35307: LD_VAR 0 4
35311: PPUSH
35312: EMPTY
35313: PPUSH
35314: CALL_OW 1
35318: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35319: LD_ADDR_EXP 104
35323: PUSH
35324: LD_EXP 104
35328: PPUSH
35329: LD_VAR 0 4
35333: PPUSH
35334: EMPTY
35335: PPUSH
35336: CALL_OW 1
35340: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35341: LD_ADDR_EXP 105
35345: PUSH
35346: LD_EXP 105
35350: PPUSH
35351: LD_VAR 0 4
35355: PPUSH
35356: EMPTY
35357: PPUSH
35358: CALL_OW 1
35362: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35363: LD_ADDR_EXP 106
35367: PUSH
35368: LD_EXP 106
35372: PPUSH
35373: LD_VAR 0 4
35377: PPUSH
35378: EMPTY
35379: PPUSH
35380: CALL_OW 1
35384: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35385: LD_ADDR_EXP 107
35389: PUSH
35390: LD_EXP 107
35394: PPUSH
35395: LD_VAR 0 4
35399: PPUSH
35400: EMPTY
35401: PPUSH
35402: CALL_OW 1
35406: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35407: LD_ADDR_EXP 108
35411: PUSH
35412: LD_EXP 108
35416: PPUSH
35417: LD_VAR 0 4
35421: PPUSH
35422: EMPTY
35423: PPUSH
35424: CALL_OW 1
35428: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35429: LD_ADDR_EXP 109
35433: PUSH
35434: LD_EXP 109
35438: PPUSH
35439: LD_VAR 0 4
35443: PPUSH
35444: EMPTY
35445: PPUSH
35446: CALL_OW 1
35450: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35451: LD_ADDR_EXP 110
35455: PUSH
35456: LD_EXP 110
35460: PPUSH
35461: LD_VAR 0 4
35465: PPUSH
35466: EMPTY
35467: PPUSH
35468: CALL_OW 1
35472: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35473: LD_ADDR_EXP 111
35477: PUSH
35478: LD_EXP 111
35482: PPUSH
35483: LD_VAR 0 4
35487: PPUSH
35488: EMPTY
35489: PPUSH
35490: CALL_OW 1
35494: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35495: LD_ADDR_EXP 112
35499: PUSH
35500: LD_EXP 112
35504: PPUSH
35505: LD_VAR 0 4
35509: PPUSH
35510: LD_INT 0
35512: PPUSH
35513: CALL_OW 1
35517: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35518: LD_ADDR_EXP 113
35522: PUSH
35523: LD_EXP 113
35527: PPUSH
35528: LD_VAR 0 4
35532: PPUSH
35533: EMPTY
35534: PPUSH
35535: CALL_OW 1
35539: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35540: LD_ADDR_EXP 114
35544: PUSH
35545: LD_EXP 114
35549: PPUSH
35550: LD_VAR 0 4
35554: PPUSH
35555: EMPTY
35556: PPUSH
35557: CALL_OW 1
35561: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35562: LD_ADDR_EXP 115
35566: PUSH
35567: LD_EXP 115
35571: PPUSH
35572: LD_VAR 0 4
35576: PPUSH
35577: EMPTY
35578: PPUSH
35579: CALL_OW 1
35583: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35584: LD_ADDR_EXP 116
35588: PUSH
35589: LD_EXP 116
35593: PPUSH
35594: LD_VAR 0 4
35598: PPUSH
35599: EMPTY
35600: PPUSH
35601: CALL_OW 1
35605: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35606: LD_ADDR_EXP 117
35610: PUSH
35611: LD_EXP 117
35615: PPUSH
35616: LD_VAR 0 4
35620: PPUSH
35621: EMPTY
35622: PPUSH
35623: CALL_OW 1
35627: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35628: LD_ADDR_EXP 118
35632: PUSH
35633: LD_EXP 118
35637: PPUSH
35638: LD_VAR 0 4
35642: PPUSH
35643: EMPTY
35644: PPUSH
35645: CALL_OW 1
35649: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35650: LD_ADDR_EXP 119
35654: PUSH
35655: LD_EXP 119
35659: PPUSH
35660: LD_VAR 0 4
35664: PPUSH
35665: EMPTY
35666: PPUSH
35667: CALL_OW 1
35671: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35672: LD_ADDR_EXP 120
35676: PUSH
35677: LD_EXP 120
35681: PPUSH
35682: LD_VAR 0 4
35686: PPUSH
35687: EMPTY
35688: PPUSH
35689: CALL_OW 1
35693: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35694: LD_ADDR_EXP 121
35698: PUSH
35699: LD_EXP 121
35703: PPUSH
35704: LD_VAR 0 4
35708: PPUSH
35709: EMPTY
35710: PPUSH
35711: CALL_OW 1
35715: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35716: LD_ADDR_EXP 122
35720: PUSH
35721: LD_EXP 122
35725: PPUSH
35726: LD_VAR 0 4
35730: PPUSH
35731: EMPTY
35732: PPUSH
35733: CALL_OW 1
35737: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35738: LD_ADDR_EXP 123
35742: PUSH
35743: LD_EXP 123
35747: PPUSH
35748: LD_VAR 0 4
35752: PPUSH
35753: EMPTY
35754: PPUSH
35755: CALL_OW 1
35759: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35760: LD_ADDR_EXP 124
35764: PUSH
35765: LD_EXP 124
35769: PPUSH
35770: LD_VAR 0 4
35774: PPUSH
35775: EMPTY
35776: PPUSH
35777: CALL_OW 1
35781: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35782: LD_ADDR_EXP 125
35786: PUSH
35787: LD_EXP 125
35791: PPUSH
35792: LD_VAR 0 4
35796: PPUSH
35797: EMPTY
35798: PPUSH
35799: CALL_OW 1
35803: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35804: LD_ADDR_EXP 126
35808: PUSH
35809: LD_EXP 126
35813: PPUSH
35814: LD_VAR 0 4
35818: PPUSH
35819: EMPTY
35820: PPUSH
35821: CALL_OW 1
35825: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35826: LD_ADDR_EXP 128
35830: PUSH
35831: LD_EXP 128
35835: PPUSH
35836: LD_VAR 0 4
35840: PPUSH
35841: EMPTY
35842: PPUSH
35843: CALL_OW 1
35847: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35848: LD_ADDR_EXP 130
35852: PUSH
35853: LD_EXP 130
35857: PPUSH
35858: LD_VAR 0 4
35862: PPUSH
35863: EMPTY
35864: PPUSH
35865: CALL_OW 1
35869: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35870: LD_ADDR_EXP 131
35874: PUSH
35875: LD_EXP 131
35879: PPUSH
35880: LD_VAR 0 4
35884: PPUSH
35885: EMPTY
35886: PPUSH
35887: CALL_OW 1
35891: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35892: LD_ADDR_EXP 132
35896: PUSH
35897: LD_EXP 132
35901: PPUSH
35902: LD_VAR 0 4
35906: PPUSH
35907: EMPTY
35908: PPUSH
35909: CALL_OW 1
35913: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35914: LD_ADDR_EXP 133
35918: PUSH
35919: LD_EXP 133
35923: PPUSH
35924: LD_VAR 0 4
35928: PPUSH
35929: EMPTY
35930: PPUSH
35931: CALL_OW 1
35935: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35936: LD_ADDR_EXP 134
35940: PUSH
35941: LD_EXP 134
35945: PPUSH
35946: LD_VAR 0 4
35950: PPUSH
35951: EMPTY
35952: PPUSH
35953: CALL_OW 1
35957: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35958: LD_ADDR_EXP 135
35962: PUSH
35963: LD_EXP 135
35967: PPUSH
35968: LD_VAR 0 4
35972: PPUSH
35973: EMPTY
35974: PPUSH
35975: CALL_OW 1
35979: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35980: LD_ADDR_EXP 136
35984: PUSH
35985: LD_EXP 136
35989: PPUSH
35990: LD_VAR 0 4
35994: PPUSH
35995: EMPTY
35996: PPUSH
35997: CALL_OW 1
36001: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36002: LD_ADDR_EXP 137
36006: PUSH
36007: LD_EXP 137
36011: PPUSH
36012: LD_VAR 0 4
36016: PPUSH
36017: EMPTY
36018: PPUSH
36019: CALL_OW 1
36023: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36024: LD_ADDR_EXP 138
36028: PUSH
36029: LD_EXP 138
36033: PPUSH
36034: LD_VAR 0 4
36038: PPUSH
36039: EMPTY
36040: PPUSH
36041: CALL_OW 1
36045: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36046: LD_ADDR_EXP 139
36050: PUSH
36051: LD_EXP 139
36055: PPUSH
36056: LD_VAR 0 4
36060: PPUSH
36061: EMPTY
36062: PPUSH
36063: CALL_OW 1
36067: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36068: LD_ADDR_EXP 140
36072: PUSH
36073: LD_EXP 140
36077: PPUSH
36078: LD_VAR 0 4
36082: PPUSH
36083: EMPTY
36084: PPUSH
36085: CALL_OW 1
36089: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36090: LD_ADDR_EXP 141
36094: PUSH
36095: LD_EXP 141
36099: PPUSH
36100: LD_VAR 0 4
36104: PPUSH
36105: EMPTY
36106: PPUSH
36107: CALL_OW 1
36111: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36112: LD_ADDR_EXP 142
36116: PUSH
36117: LD_EXP 142
36121: PPUSH
36122: LD_VAR 0 4
36126: PPUSH
36127: EMPTY
36128: PPUSH
36129: CALL_OW 1
36133: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36134: LD_ADDR_EXP 143
36138: PUSH
36139: LD_EXP 143
36143: PPUSH
36144: LD_VAR 0 4
36148: PPUSH
36149: LD_INT 0
36151: PPUSH
36152: CALL_OW 1
36156: ST_TO_ADDR
// result := base ;
36157: LD_ADDR_VAR 0 3
36161: PUSH
36162: LD_VAR 0 4
36166: ST_TO_ADDR
// end ;
36167: LD_VAR 0 3
36171: RET
// export function MC_Start ( ) ; var i ; begin
36172: LD_INT 0
36174: PPUSH
36175: PPUSH
// for i = 1 to mc_bases do
36176: LD_ADDR_VAR 0 2
36180: PUSH
36181: DOUBLE
36182: LD_INT 1
36184: DEC
36185: ST_TO_ADDR
36186: LD_EXP 101
36190: PUSH
36191: FOR_TO
36192: IFFALSE 37269
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36194: LD_ADDR_EXP 101
36198: PUSH
36199: LD_EXP 101
36203: PPUSH
36204: LD_VAR 0 2
36208: PPUSH
36209: LD_EXP 101
36213: PUSH
36214: LD_VAR 0 2
36218: ARRAY
36219: PUSH
36220: LD_INT 0
36222: DIFF
36223: PPUSH
36224: CALL_OW 1
36228: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36229: LD_ADDR_EXP 102
36233: PUSH
36234: LD_EXP 102
36238: PPUSH
36239: LD_VAR 0 2
36243: PPUSH
36244: EMPTY
36245: PPUSH
36246: CALL_OW 1
36250: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36251: LD_ADDR_EXP 103
36255: PUSH
36256: LD_EXP 103
36260: PPUSH
36261: LD_VAR 0 2
36265: PPUSH
36266: EMPTY
36267: PPUSH
36268: CALL_OW 1
36272: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36273: LD_ADDR_EXP 104
36277: PUSH
36278: LD_EXP 104
36282: PPUSH
36283: LD_VAR 0 2
36287: PPUSH
36288: EMPTY
36289: PPUSH
36290: CALL_OW 1
36294: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36295: LD_ADDR_EXP 105
36299: PUSH
36300: LD_EXP 105
36304: PPUSH
36305: LD_VAR 0 2
36309: PPUSH
36310: EMPTY
36311: PUSH
36312: EMPTY
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PPUSH
36318: CALL_OW 1
36322: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36323: LD_ADDR_EXP 106
36327: PUSH
36328: LD_EXP 106
36332: PPUSH
36333: LD_VAR 0 2
36337: PPUSH
36338: EMPTY
36339: PPUSH
36340: CALL_OW 1
36344: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36345: LD_ADDR_EXP 133
36349: PUSH
36350: LD_EXP 133
36354: PPUSH
36355: LD_VAR 0 2
36359: PPUSH
36360: EMPTY
36361: PPUSH
36362: CALL_OW 1
36366: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36367: LD_ADDR_EXP 107
36371: PUSH
36372: LD_EXP 107
36376: PPUSH
36377: LD_VAR 0 2
36381: PPUSH
36382: EMPTY
36383: PPUSH
36384: CALL_OW 1
36388: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36389: LD_ADDR_EXP 108
36393: PUSH
36394: LD_EXP 108
36398: PPUSH
36399: LD_VAR 0 2
36403: PPUSH
36404: EMPTY
36405: PPUSH
36406: CALL_OW 1
36410: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36411: LD_ADDR_EXP 109
36415: PUSH
36416: LD_EXP 109
36420: PPUSH
36421: LD_VAR 0 2
36425: PPUSH
36426: LD_EXP 101
36430: PUSH
36431: LD_VAR 0 2
36435: ARRAY
36436: PPUSH
36437: LD_INT 2
36439: PUSH
36440: LD_INT 30
36442: PUSH
36443: LD_INT 32
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 30
36452: PUSH
36453: LD_INT 33
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: LIST
36464: PPUSH
36465: CALL_OW 72
36469: PPUSH
36470: CALL_OW 1
36474: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36475: LD_ADDR_EXP 110
36479: PUSH
36480: LD_EXP 110
36484: PPUSH
36485: LD_VAR 0 2
36489: PPUSH
36490: LD_EXP 101
36494: PUSH
36495: LD_VAR 0 2
36499: ARRAY
36500: PPUSH
36501: LD_INT 2
36503: PUSH
36504: LD_INT 30
36506: PUSH
36507: LD_INT 32
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 30
36516: PUSH
36517: LD_INT 31
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 58
36531: PUSH
36532: EMPTY
36533: LIST
36534: PUSH
36535: EMPTY
36536: LIST
36537: LIST
36538: PPUSH
36539: CALL_OW 72
36543: PPUSH
36544: CALL_OW 1
36548: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36549: LD_ADDR_EXP 111
36553: PUSH
36554: LD_EXP 111
36558: PPUSH
36559: LD_VAR 0 2
36563: PPUSH
36564: EMPTY
36565: PPUSH
36566: CALL_OW 1
36570: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36571: LD_ADDR_EXP 115
36575: PUSH
36576: LD_EXP 115
36580: PPUSH
36581: LD_VAR 0 2
36585: PPUSH
36586: EMPTY
36587: PPUSH
36588: CALL_OW 1
36592: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36593: LD_ADDR_EXP 114
36597: PUSH
36598: LD_EXP 114
36602: PPUSH
36603: LD_VAR 0 2
36607: PPUSH
36608: EMPTY
36609: PPUSH
36610: CALL_OW 1
36614: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36615: LD_ADDR_EXP 116
36619: PUSH
36620: LD_EXP 116
36624: PPUSH
36625: LD_VAR 0 2
36629: PPUSH
36630: EMPTY
36631: PPUSH
36632: CALL_OW 1
36636: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36637: LD_ADDR_EXP 117
36641: PUSH
36642: LD_EXP 117
36646: PPUSH
36647: LD_VAR 0 2
36651: PPUSH
36652: EMPTY
36653: PPUSH
36654: CALL_OW 1
36658: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36659: LD_ADDR_EXP 118
36663: PUSH
36664: LD_EXP 118
36668: PPUSH
36669: LD_VAR 0 2
36673: PPUSH
36674: EMPTY
36675: PPUSH
36676: CALL_OW 1
36680: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36681: LD_ADDR_EXP 119
36685: PUSH
36686: LD_EXP 119
36690: PPUSH
36691: LD_VAR 0 2
36695: PPUSH
36696: EMPTY
36697: PPUSH
36698: CALL_OW 1
36702: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36703: LD_ADDR_EXP 120
36707: PUSH
36708: LD_EXP 120
36712: PPUSH
36713: LD_VAR 0 2
36717: PPUSH
36718: EMPTY
36719: PPUSH
36720: CALL_OW 1
36724: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36725: LD_ADDR_EXP 121
36729: PUSH
36730: LD_EXP 121
36734: PPUSH
36735: LD_VAR 0 2
36739: PPUSH
36740: EMPTY
36741: PPUSH
36742: CALL_OW 1
36746: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36747: LD_ADDR_EXP 122
36751: PUSH
36752: LD_EXP 122
36756: PPUSH
36757: LD_VAR 0 2
36761: PPUSH
36762: EMPTY
36763: PPUSH
36764: CALL_OW 1
36768: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36769: LD_ADDR_EXP 123
36773: PUSH
36774: LD_EXP 123
36778: PPUSH
36779: LD_VAR 0 2
36783: PPUSH
36784: EMPTY
36785: PPUSH
36786: CALL_OW 1
36790: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36791: LD_ADDR_EXP 112
36795: PUSH
36796: LD_EXP 112
36800: PPUSH
36801: LD_VAR 0 2
36805: PPUSH
36806: LD_INT 0
36808: PPUSH
36809: CALL_OW 1
36813: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36814: LD_ADDR_EXP 125
36818: PUSH
36819: LD_EXP 125
36823: PPUSH
36824: LD_VAR 0 2
36828: PPUSH
36829: LD_INT 0
36831: PPUSH
36832: CALL_OW 1
36836: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36837: LD_ADDR_EXP 113
36841: PUSH
36842: LD_EXP 113
36846: PPUSH
36847: LD_VAR 0 2
36851: PPUSH
36852: EMPTY
36853: PPUSH
36854: CALL_OW 1
36858: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36859: LD_ADDR_EXP 124
36863: PUSH
36864: LD_EXP 124
36868: PPUSH
36869: LD_VAR 0 2
36873: PPUSH
36874: LD_INT 0
36876: PPUSH
36877: CALL_OW 1
36881: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36882: LD_ADDR_EXP 126
36886: PUSH
36887: LD_EXP 126
36891: PPUSH
36892: LD_VAR 0 2
36896: PPUSH
36897: EMPTY
36898: PPUSH
36899: CALL_OW 1
36903: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36904: LD_ADDR_EXP 129
36908: PUSH
36909: LD_EXP 129
36913: PPUSH
36914: LD_VAR 0 2
36918: PPUSH
36919: LD_INT 0
36921: PPUSH
36922: CALL_OW 1
36926: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36927: LD_ADDR_EXP 130
36931: PUSH
36932: LD_EXP 130
36936: PPUSH
36937: LD_VAR 0 2
36941: PPUSH
36942: EMPTY
36943: PPUSH
36944: CALL_OW 1
36948: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36949: LD_ADDR_EXP 131
36953: PUSH
36954: LD_EXP 131
36958: PPUSH
36959: LD_VAR 0 2
36963: PPUSH
36964: EMPTY
36965: PPUSH
36966: CALL_OW 1
36970: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36971: LD_ADDR_EXP 132
36975: PUSH
36976: LD_EXP 132
36980: PPUSH
36981: LD_VAR 0 2
36985: PPUSH
36986: EMPTY
36987: PPUSH
36988: CALL_OW 1
36992: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36993: LD_ADDR_EXP 134
36997: PUSH
36998: LD_EXP 134
37002: PPUSH
37003: LD_VAR 0 2
37007: PPUSH
37008: LD_EXP 101
37012: PUSH
37013: LD_VAR 0 2
37017: ARRAY
37018: PPUSH
37019: LD_INT 2
37021: PUSH
37022: LD_INT 30
37024: PUSH
37025: LD_INT 6
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 30
37034: PUSH
37035: LD_INT 7
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 30
37044: PUSH
37045: LD_INT 8
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: EMPTY
37053: LIST
37054: LIST
37055: LIST
37056: LIST
37057: PPUSH
37058: CALL_OW 72
37062: PPUSH
37063: CALL_OW 1
37067: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37068: LD_ADDR_EXP 135
37072: PUSH
37073: LD_EXP 135
37077: PPUSH
37078: LD_VAR 0 2
37082: PPUSH
37083: EMPTY
37084: PPUSH
37085: CALL_OW 1
37089: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37090: LD_ADDR_EXP 136
37094: PUSH
37095: LD_EXP 136
37099: PPUSH
37100: LD_VAR 0 2
37104: PPUSH
37105: EMPTY
37106: PPUSH
37107: CALL_OW 1
37111: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37112: LD_ADDR_EXP 137
37116: PUSH
37117: LD_EXP 137
37121: PPUSH
37122: LD_VAR 0 2
37126: PPUSH
37127: EMPTY
37128: PPUSH
37129: CALL_OW 1
37133: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37134: LD_ADDR_EXP 138
37138: PUSH
37139: LD_EXP 138
37143: PPUSH
37144: LD_VAR 0 2
37148: PPUSH
37149: EMPTY
37150: PPUSH
37151: CALL_OW 1
37155: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37156: LD_ADDR_EXP 139
37160: PUSH
37161: LD_EXP 139
37165: PPUSH
37166: LD_VAR 0 2
37170: PPUSH
37171: EMPTY
37172: PPUSH
37173: CALL_OW 1
37177: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37178: LD_ADDR_EXP 140
37182: PUSH
37183: LD_EXP 140
37187: PPUSH
37188: LD_VAR 0 2
37192: PPUSH
37193: EMPTY
37194: PPUSH
37195: CALL_OW 1
37199: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37200: LD_ADDR_EXP 141
37204: PUSH
37205: LD_EXP 141
37209: PPUSH
37210: LD_VAR 0 2
37214: PPUSH
37215: EMPTY
37216: PPUSH
37217: CALL_OW 1
37221: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37222: LD_ADDR_EXP 142
37226: PUSH
37227: LD_EXP 142
37231: PPUSH
37232: LD_VAR 0 2
37236: PPUSH
37237: EMPTY
37238: PPUSH
37239: CALL_OW 1
37243: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37244: LD_ADDR_EXP 143
37248: PUSH
37249: LD_EXP 143
37253: PPUSH
37254: LD_VAR 0 2
37258: PPUSH
37259: LD_INT 0
37261: PPUSH
37262: CALL_OW 1
37266: ST_TO_ADDR
// end ;
37267: GO 36191
37269: POP
37270: POP
// MC_InitSides ( ) ;
37271: CALL 37557 0 0
// MC_InitResearch ( ) ;
37275: CALL 37296 0 0
// CustomInitMacro ( ) ;
37279: CALL 460 0 0
// skirmish := true ;
37283: LD_ADDR_EXP 99
37287: PUSH
37288: LD_INT 1
37290: ST_TO_ADDR
// end ;
37291: LD_VAR 0 1
37295: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37296: LD_INT 0
37298: PPUSH
37299: PPUSH
37300: PPUSH
37301: PPUSH
37302: PPUSH
37303: PPUSH
// if not mc_bases then
37304: LD_EXP 101
37308: NOT
37309: IFFALSE 37313
// exit ;
37311: GO 37552
// for i = 1 to 8 do
37313: LD_ADDR_VAR 0 2
37317: PUSH
37318: DOUBLE
37319: LD_INT 1
37321: DEC
37322: ST_TO_ADDR
37323: LD_INT 8
37325: PUSH
37326: FOR_TO
37327: IFFALSE 37353
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37329: LD_ADDR_EXP 128
37333: PUSH
37334: LD_EXP 128
37338: PPUSH
37339: LD_VAR 0 2
37343: PPUSH
37344: EMPTY
37345: PPUSH
37346: CALL_OW 1
37350: ST_TO_ADDR
37351: GO 37326
37353: POP
37354: POP
// tmp := [ ] ;
37355: LD_ADDR_VAR 0 5
37359: PUSH
37360: EMPTY
37361: ST_TO_ADDR
// for i = 1 to mc_sides do
37362: LD_ADDR_VAR 0 2
37366: PUSH
37367: DOUBLE
37368: LD_INT 1
37370: DEC
37371: ST_TO_ADDR
37372: LD_EXP 127
37376: PUSH
37377: FOR_TO
37378: IFFALSE 37436
// if not mc_sides [ i ] in tmp then
37380: LD_EXP 127
37384: PUSH
37385: LD_VAR 0 2
37389: ARRAY
37390: PUSH
37391: LD_VAR 0 5
37395: IN
37396: NOT
37397: IFFALSE 37434
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37399: LD_ADDR_VAR 0 5
37403: PUSH
37404: LD_VAR 0 5
37408: PPUSH
37409: LD_VAR 0 5
37413: PUSH
37414: LD_INT 1
37416: PLUS
37417: PPUSH
37418: LD_EXP 127
37422: PUSH
37423: LD_VAR 0 2
37427: ARRAY
37428: PPUSH
37429: CALL_OW 2
37433: ST_TO_ADDR
37434: GO 37377
37436: POP
37437: POP
// if not tmp then
37438: LD_VAR 0 5
37442: NOT
37443: IFFALSE 37447
// exit ;
37445: GO 37552
// for j in tmp do
37447: LD_ADDR_VAR 0 3
37451: PUSH
37452: LD_VAR 0 5
37456: PUSH
37457: FOR_IN
37458: IFFALSE 37550
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37460: LD_ADDR_VAR 0 6
37464: PUSH
37465: LD_INT 22
37467: PUSH
37468: LD_VAR 0 3
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PPUSH
37477: CALL_OW 69
37481: ST_TO_ADDR
// if not un then
37482: LD_VAR 0 6
37486: NOT
37487: IFFALSE 37491
// continue ;
37489: GO 37457
// nation := GetNation ( un [ 1 ] ) ;
37491: LD_ADDR_VAR 0 4
37495: PUSH
37496: LD_VAR 0 6
37500: PUSH
37501: LD_INT 1
37503: ARRAY
37504: PPUSH
37505: CALL_OW 248
37509: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37510: LD_ADDR_EXP 128
37514: PUSH
37515: LD_EXP 128
37519: PPUSH
37520: LD_VAR 0 3
37524: PPUSH
37525: LD_VAR 0 3
37529: PPUSH
37530: LD_VAR 0 4
37534: PPUSH
37535: LD_INT 1
37537: PPUSH
37538: CALL 64266 0 3
37542: PPUSH
37543: CALL_OW 1
37547: ST_TO_ADDR
// end ;
37548: GO 37457
37550: POP
37551: POP
// end ;
37552: LD_VAR 0 1
37556: RET
// export function MC_InitSides ( ) ; var i ; begin
37557: LD_INT 0
37559: PPUSH
37560: PPUSH
// if not mc_bases then
37561: LD_EXP 101
37565: NOT
37566: IFFALSE 37570
// exit ;
37568: GO 37644
// for i = 1 to mc_bases do
37570: LD_ADDR_VAR 0 2
37574: PUSH
37575: DOUBLE
37576: LD_INT 1
37578: DEC
37579: ST_TO_ADDR
37580: LD_EXP 101
37584: PUSH
37585: FOR_TO
37586: IFFALSE 37642
// if mc_bases [ i ] then
37588: LD_EXP 101
37592: PUSH
37593: LD_VAR 0 2
37597: ARRAY
37598: IFFALSE 37640
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37600: LD_ADDR_EXP 127
37604: PUSH
37605: LD_EXP 127
37609: PPUSH
37610: LD_VAR 0 2
37614: PPUSH
37615: LD_EXP 101
37619: PUSH
37620: LD_VAR 0 2
37624: ARRAY
37625: PUSH
37626: LD_INT 1
37628: ARRAY
37629: PPUSH
37630: CALL_OW 255
37634: PPUSH
37635: CALL_OW 1
37639: ST_TO_ADDR
37640: GO 37585
37642: POP
37643: POP
// end ;
37644: LD_VAR 0 1
37648: RET
// every 0 0$01 trigger skirmish do
37649: LD_EXP 99
37653: IFFALSE 37807
37655: GO 37657
37657: DISABLE
// begin enable ;
37658: ENABLE
// MC_CheckBuildings ( ) ;
37659: CALL 42305 0 0
// MC_CheckPeopleLife ( ) ;
37663: CALL 42430 0 0
// RaiseSailEvent ( 100 ) ;
37667: LD_INT 100
37669: PPUSH
37670: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37674: LD_INT 103
37676: PPUSH
37677: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37681: LD_INT 104
37683: PPUSH
37684: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37688: LD_INT 105
37690: PPUSH
37691: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37695: LD_INT 106
37697: PPUSH
37698: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37702: LD_INT 107
37704: PPUSH
37705: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37709: LD_INT 108
37711: PPUSH
37712: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37716: LD_INT 109
37718: PPUSH
37719: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37723: LD_INT 110
37725: PPUSH
37726: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37730: LD_INT 111
37732: PPUSH
37733: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37737: LD_INT 112
37739: PPUSH
37740: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37744: LD_INT 113
37746: PPUSH
37747: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37751: LD_INT 120
37753: PPUSH
37754: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37758: LD_INT 121
37760: PPUSH
37761: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37765: LD_INT 122
37767: PPUSH
37768: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37772: LD_INT 123
37774: PPUSH
37775: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37779: LD_INT 124
37781: PPUSH
37782: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37786: LD_INT 125
37788: PPUSH
37789: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37793: LD_INT 126
37795: PPUSH
37796: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37800: LD_INT 200
37802: PPUSH
37803: CALL_OW 427
// end ;
37807: END
// on SailEvent ( event ) do begin if event < 100 then
37808: LD_VAR 0 1
37812: PUSH
37813: LD_INT 100
37815: LESS
37816: IFFALSE 37827
// CustomEvent ( event ) ;
37818: LD_VAR 0 1
37822: PPUSH
37823: CALL 32467 0 1
// if event = 100 then
37827: LD_VAR 0 1
37831: PUSH
37832: LD_INT 100
37834: EQUAL
37835: IFFALSE 37841
// MC_ClassManager ( ) ;
37837: CALL 38233 0 0
// if event = 101 then
37841: LD_VAR 0 1
37845: PUSH
37846: LD_INT 101
37848: EQUAL
37849: IFFALSE 37855
// MC_RepairBuildings ( ) ;
37851: CALL 43026 0 0
// if event = 102 then
37855: LD_VAR 0 1
37859: PUSH
37860: LD_INT 102
37862: EQUAL
37863: IFFALSE 37869
// MC_Heal ( ) ;
37865: CALL 43758 0 0
// if event = 103 then
37869: LD_VAR 0 1
37873: PUSH
37874: LD_INT 103
37876: EQUAL
37877: IFFALSE 37883
// MC_Build ( ) ;
37879: CALL 44180 0 0
// if event = 104 then
37883: LD_VAR 0 1
37887: PUSH
37888: LD_INT 104
37890: EQUAL
37891: IFFALSE 37897
// MC_TurretWeapon ( ) ;
37893: CALL 45793 0 0
// if event = 105 then
37897: LD_VAR 0 1
37901: PUSH
37902: LD_INT 105
37904: EQUAL
37905: IFFALSE 37911
// MC_BuildUpgrade ( ) ;
37907: CALL 45344 0 0
// if event = 106 then
37911: LD_VAR 0 1
37915: PUSH
37916: LD_INT 106
37918: EQUAL
37919: IFFALSE 37925
// MC_PlantMines ( ) ;
37921: CALL 46223 0 0
// if event = 107 then
37925: LD_VAR 0 1
37929: PUSH
37930: LD_INT 107
37932: EQUAL
37933: IFFALSE 37939
// MC_CollectCrates ( ) ;
37935: CALL 47257 0 0
// if event = 108 then
37939: LD_VAR 0 1
37943: PUSH
37944: LD_INT 108
37946: EQUAL
37947: IFFALSE 37953
// MC_LinkRemoteControl ( ) ;
37949: CALL 49033 0 0
// if event = 109 then
37953: LD_VAR 0 1
37957: PUSH
37958: LD_INT 109
37960: EQUAL
37961: IFFALSE 37967
// MC_ProduceVehicle ( ) ;
37963: CALL 49214 0 0
// if event = 110 then
37967: LD_VAR 0 1
37971: PUSH
37972: LD_INT 110
37974: EQUAL
37975: IFFALSE 37981
// MC_SendAttack ( ) ;
37977: CALL 49680 0 0
// if event = 111 then
37981: LD_VAR 0 1
37985: PUSH
37986: LD_INT 111
37988: EQUAL
37989: IFFALSE 37995
// MC_Defend ( ) ;
37991: CALL 49788 0 0
// if event = 112 then
37995: LD_VAR 0 1
37999: PUSH
38000: LD_INT 112
38002: EQUAL
38003: IFFALSE 38009
// MC_Research ( ) ;
38005: CALL 50393 0 0
// if event = 113 then
38009: LD_VAR 0 1
38013: PUSH
38014: LD_INT 113
38016: EQUAL
38017: IFFALSE 38023
// MC_MinesTrigger ( ) ;
38019: CALL 51507 0 0
// if event = 120 then
38023: LD_VAR 0 1
38027: PUSH
38028: LD_INT 120
38030: EQUAL
38031: IFFALSE 38037
// MC_RepairVehicle ( ) ;
38033: CALL 51606 0 0
// if event = 121 then
38037: LD_VAR 0 1
38041: PUSH
38042: LD_INT 121
38044: EQUAL
38045: IFFALSE 38051
// MC_TameApe ( ) ;
38047: CALL 52336 0 0
// if event = 122 then
38051: LD_VAR 0 1
38055: PUSH
38056: LD_INT 122
38058: EQUAL
38059: IFFALSE 38065
// MC_ChangeApeClass ( ) ;
38061: CALL 53165 0 0
// if event = 123 then
38065: LD_VAR 0 1
38069: PUSH
38070: LD_INT 123
38072: EQUAL
38073: IFFALSE 38079
// MC_Bazooka ( ) ;
38075: CALL 53815 0 0
// if event = 124 then
38079: LD_VAR 0 1
38083: PUSH
38084: LD_INT 124
38086: EQUAL
38087: IFFALSE 38093
// MC_TeleportExit ( ) ;
38089: CALL 54013 0 0
// if event = 125 then
38093: LD_VAR 0 1
38097: PUSH
38098: LD_INT 125
38100: EQUAL
38101: IFFALSE 38107
// MC_Deposits ( ) ;
38103: CALL 54660 0 0
// if event = 126 then
38107: LD_VAR 0 1
38111: PUSH
38112: LD_INT 126
38114: EQUAL
38115: IFFALSE 38121
// MC_RemoteDriver ( ) ;
38117: CALL 55285 0 0
// if event = 200 then
38121: LD_VAR 0 1
38125: PUSH
38126: LD_INT 200
38128: EQUAL
38129: IFFALSE 38135
// MC_Idle ( ) ;
38131: CALL 57234 0 0
// end ;
38135: PPOPN 1
38137: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38138: LD_INT 0
38140: PPUSH
38141: PPUSH
// if not mc_bases [ base ] or not tag then
38142: LD_EXP 101
38146: PUSH
38147: LD_VAR 0 1
38151: ARRAY
38152: NOT
38153: PUSH
38154: LD_VAR 0 2
38158: NOT
38159: OR
38160: IFFALSE 38164
// exit ;
38162: GO 38228
// for i in mc_bases [ base ] union mc_ape [ base ] do
38164: LD_ADDR_VAR 0 4
38168: PUSH
38169: LD_EXP 101
38173: PUSH
38174: LD_VAR 0 1
38178: ARRAY
38179: PUSH
38180: LD_EXP 130
38184: PUSH
38185: LD_VAR 0 1
38189: ARRAY
38190: UNION
38191: PUSH
38192: FOR_IN
38193: IFFALSE 38226
// if GetTag ( i ) = tag then
38195: LD_VAR 0 4
38199: PPUSH
38200: CALL_OW 110
38204: PUSH
38205: LD_VAR 0 2
38209: EQUAL
38210: IFFALSE 38224
// SetTag ( i , 0 ) ;
38212: LD_VAR 0 4
38216: PPUSH
38217: LD_INT 0
38219: PPUSH
38220: CALL_OW 109
38224: GO 38192
38226: POP
38227: POP
// end ;
38228: LD_VAR 0 3
38232: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38233: LD_INT 0
38235: PPUSH
38236: PPUSH
38237: PPUSH
38238: PPUSH
38239: PPUSH
38240: PPUSH
38241: PPUSH
38242: PPUSH
// if not mc_bases then
38243: LD_EXP 101
38247: NOT
38248: IFFALSE 38252
// exit ;
38250: GO 38710
// for i = 1 to mc_bases do
38252: LD_ADDR_VAR 0 2
38256: PUSH
38257: DOUBLE
38258: LD_INT 1
38260: DEC
38261: ST_TO_ADDR
38262: LD_EXP 101
38266: PUSH
38267: FOR_TO
38268: IFFALSE 38708
// begin tmp := MC_ClassCheckReq ( i ) ;
38270: LD_ADDR_VAR 0 4
38274: PUSH
38275: LD_VAR 0 2
38279: PPUSH
38280: CALL 38715 0 1
38284: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38285: LD_ADDR_EXP 142
38289: PUSH
38290: LD_EXP 142
38294: PPUSH
38295: LD_VAR 0 2
38299: PPUSH
38300: LD_VAR 0 4
38304: PPUSH
38305: CALL_OW 1
38309: ST_TO_ADDR
// if not tmp then
38310: LD_VAR 0 4
38314: NOT
38315: IFFALSE 38319
// continue ;
38317: GO 38267
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38319: LD_ADDR_VAR 0 6
38323: PUSH
38324: LD_EXP 101
38328: PUSH
38329: LD_VAR 0 2
38333: ARRAY
38334: PPUSH
38335: LD_INT 2
38337: PUSH
38338: LD_INT 30
38340: PUSH
38341: LD_INT 4
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 30
38350: PUSH
38351: LD_INT 5
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: LIST
38362: PPUSH
38363: CALL_OW 72
38367: PUSH
38368: LD_EXP 101
38372: PUSH
38373: LD_VAR 0 2
38377: ARRAY
38378: PPUSH
38379: LD_INT 2
38381: PUSH
38382: LD_INT 30
38384: PUSH
38385: LD_INT 0
38387: PUSH
38388: EMPTY
38389: LIST
38390: LIST
38391: PUSH
38392: LD_INT 30
38394: PUSH
38395: LD_INT 1
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: LIST
38406: PPUSH
38407: CALL_OW 72
38411: PUSH
38412: LD_EXP 101
38416: PUSH
38417: LD_VAR 0 2
38421: ARRAY
38422: PPUSH
38423: LD_INT 30
38425: PUSH
38426: LD_INT 3
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PPUSH
38433: CALL_OW 72
38437: PUSH
38438: LD_EXP 101
38442: PUSH
38443: LD_VAR 0 2
38447: ARRAY
38448: PPUSH
38449: LD_INT 2
38451: PUSH
38452: LD_INT 30
38454: PUSH
38455: LD_INT 6
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 30
38464: PUSH
38465: LD_INT 7
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 30
38474: PUSH
38475: LD_INT 8
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: LIST
38486: LIST
38487: PPUSH
38488: CALL_OW 72
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: ST_TO_ADDR
// for j = 1 to 4 do
38499: LD_ADDR_VAR 0 3
38503: PUSH
38504: DOUBLE
38505: LD_INT 1
38507: DEC
38508: ST_TO_ADDR
38509: LD_INT 4
38511: PUSH
38512: FOR_TO
38513: IFFALSE 38704
// begin if not tmp [ j ] then
38515: LD_VAR 0 4
38519: PUSH
38520: LD_VAR 0 3
38524: ARRAY
38525: NOT
38526: IFFALSE 38530
// continue ;
38528: GO 38512
// for p in tmp [ j ] do
38530: LD_ADDR_VAR 0 5
38534: PUSH
38535: LD_VAR 0 4
38539: PUSH
38540: LD_VAR 0 3
38544: ARRAY
38545: PUSH
38546: FOR_IN
38547: IFFALSE 38700
// begin if not b [ j ] then
38549: LD_VAR 0 6
38553: PUSH
38554: LD_VAR 0 3
38558: ARRAY
38559: NOT
38560: IFFALSE 38564
// break ;
38562: GO 38700
// e := 0 ;
38564: LD_ADDR_VAR 0 7
38568: PUSH
38569: LD_INT 0
38571: ST_TO_ADDR
// for k in b [ j ] do
38572: LD_ADDR_VAR 0 8
38576: PUSH
38577: LD_VAR 0 6
38581: PUSH
38582: LD_VAR 0 3
38586: ARRAY
38587: PUSH
38588: FOR_IN
38589: IFFALSE 38616
// if IsNotFull ( k ) then
38591: LD_VAR 0 8
38595: PPUSH
38596: CALL 68706 0 1
38600: IFFALSE 38614
// begin e := k ;
38602: LD_ADDR_VAR 0 7
38606: PUSH
38607: LD_VAR 0 8
38611: ST_TO_ADDR
// break ;
38612: GO 38616
// end ;
38614: GO 38588
38616: POP
38617: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38618: LD_VAR 0 7
38622: PUSH
38623: LD_VAR 0 5
38627: PPUSH
38628: LD_VAR 0 7
38632: PPUSH
38633: CALL 105825 0 2
38637: NOT
38638: AND
38639: IFFALSE 38698
// begin if IsInUnit ( p ) then
38641: LD_VAR 0 5
38645: PPUSH
38646: CALL_OW 310
38650: IFFALSE 38661
// ComExitBuilding ( p ) ;
38652: LD_VAR 0 5
38656: PPUSH
38657: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38661: LD_VAR 0 5
38665: PPUSH
38666: LD_VAR 0 7
38670: PPUSH
38671: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38675: LD_VAR 0 5
38679: PPUSH
38680: LD_VAR 0 3
38684: PPUSH
38685: CALL_OW 183
// AddComExitBuilding ( p ) ;
38689: LD_VAR 0 5
38693: PPUSH
38694: CALL_OW 182
// end ; end ;
38698: GO 38546
38700: POP
38701: POP
// end ;
38702: GO 38512
38704: POP
38705: POP
// end ;
38706: GO 38267
38708: POP
38709: POP
// end ;
38710: LD_VAR 0 1
38714: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38715: LD_INT 0
38717: PPUSH
38718: PPUSH
38719: PPUSH
38720: PPUSH
38721: PPUSH
38722: PPUSH
38723: PPUSH
38724: PPUSH
38725: PPUSH
38726: PPUSH
38727: PPUSH
38728: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38729: LD_VAR 0 1
38733: NOT
38734: PUSH
38735: LD_EXP 101
38739: PUSH
38740: LD_VAR 0 1
38744: ARRAY
38745: NOT
38746: OR
38747: PUSH
38748: LD_EXP 101
38752: PUSH
38753: LD_VAR 0 1
38757: ARRAY
38758: PPUSH
38759: LD_INT 2
38761: PUSH
38762: LD_INT 30
38764: PUSH
38765: LD_INT 0
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: PUSH
38772: LD_INT 30
38774: PUSH
38775: LD_INT 1
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: LIST
38786: PPUSH
38787: CALL_OW 72
38791: NOT
38792: OR
38793: IFFALSE 38797
// exit ;
38795: GO 42300
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38797: LD_ADDR_VAR 0 4
38801: PUSH
38802: LD_EXP 101
38806: PUSH
38807: LD_VAR 0 1
38811: ARRAY
38812: PPUSH
38813: LD_INT 2
38815: PUSH
38816: LD_INT 25
38818: PUSH
38819: LD_INT 1
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 25
38828: PUSH
38829: LD_INT 2
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 25
38838: PUSH
38839: LD_INT 3
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PUSH
38846: LD_INT 25
38848: PUSH
38849: LD_INT 4
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 25
38858: PUSH
38859: LD_INT 5
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: LD_INT 25
38868: PUSH
38869: LD_INT 8
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 25
38878: PUSH
38879: LD_INT 9
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: PPUSH
38896: CALL_OW 72
38900: ST_TO_ADDR
// if not tmp then
38901: LD_VAR 0 4
38905: NOT
38906: IFFALSE 38910
// exit ;
38908: GO 42300
// for i in tmp do
38910: LD_ADDR_VAR 0 3
38914: PUSH
38915: LD_VAR 0 4
38919: PUSH
38920: FOR_IN
38921: IFFALSE 38952
// if GetTag ( i ) then
38923: LD_VAR 0 3
38927: PPUSH
38928: CALL_OW 110
38932: IFFALSE 38950
// tmp := tmp diff i ;
38934: LD_ADDR_VAR 0 4
38938: PUSH
38939: LD_VAR 0 4
38943: PUSH
38944: LD_VAR 0 3
38948: DIFF
38949: ST_TO_ADDR
38950: GO 38920
38952: POP
38953: POP
// if not tmp then
38954: LD_VAR 0 4
38958: NOT
38959: IFFALSE 38963
// exit ;
38961: GO 42300
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38963: LD_ADDR_VAR 0 5
38967: PUSH
38968: LD_EXP 101
38972: PUSH
38973: LD_VAR 0 1
38977: ARRAY
38978: PPUSH
38979: LD_INT 2
38981: PUSH
38982: LD_INT 25
38984: PUSH
38985: LD_INT 1
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 25
38994: PUSH
38995: LD_INT 5
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 25
39004: PUSH
39005: LD_INT 8
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 25
39014: PUSH
39015: LD_INT 9
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: LIST
39026: LIST
39027: LIST
39028: PPUSH
39029: CALL_OW 72
39033: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39034: LD_ADDR_VAR 0 6
39038: PUSH
39039: LD_EXP 101
39043: PUSH
39044: LD_VAR 0 1
39048: ARRAY
39049: PPUSH
39050: LD_INT 25
39052: PUSH
39053: LD_INT 2
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PPUSH
39060: CALL_OW 72
39064: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39065: LD_ADDR_VAR 0 7
39069: PUSH
39070: LD_EXP 101
39074: PUSH
39075: LD_VAR 0 1
39079: ARRAY
39080: PPUSH
39081: LD_INT 25
39083: PUSH
39084: LD_INT 3
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PPUSH
39091: CALL_OW 72
39095: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39096: LD_ADDR_VAR 0 8
39100: PUSH
39101: LD_EXP 101
39105: PUSH
39106: LD_VAR 0 1
39110: ARRAY
39111: PPUSH
39112: LD_INT 25
39114: PUSH
39115: LD_INT 4
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 24
39124: PUSH
39125: LD_INT 251
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PPUSH
39136: CALL_OW 72
39140: ST_TO_ADDR
// if mc_scan [ base ] then
39141: LD_EXP 124
39145: PUSH
39146: LD_VAR 0 1
39150: ARRAY
39151: IFFALSE 39612
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39153: LD_ADDR_EXP 143
39157: PUSH
39158: LD_EXP 143
39162: PPUSH
39163: LD_VAR 0 1
39167: PPUSH
39168: LD_INT 4
39170: PPUSH
39171: CALL_OW 1
39175: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39176: LD_ADDR_VAR 0 12
39180: PUSH
39181: LD_EXP 101
39185: PUSH
39186: LD_VAR 0 1
39190: ARRAY
39191: PPUSH
39192: LD_INT 2
39194: PUSH
39195: LD_INT 30
39197: PUSH
39198: LD_INT 4
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 30
39207: PUSH
39208: LD_INT 5
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: LIST
39219: PPUSH
39220: CALL_OW 72
39224: ST_TO_ADDR
// if not b then
39225: LD_VAR 0 12
39229: NOT
39230: IFFALSE 39234
// exit ;
39232: GO 42300
// p := [ ] ;
39234: LD_ADDR_VAR 0 11
39238: PUSH
39239: EMPTY
39240: ST_TO_ADDR
// if sci >= 2 then
39241: LD_VAR 0 8
39245: PUSH
39246: LD_INT 2
39248: GREATEREQUAL
39249: IFFALSE 39280
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39251: LD_ADDR_VAR 0 8
39255: PUSH
39256: LD_VAR 0 8
39260: PUSH
39261: LD_INT 1
39263: ARRAY
39264: PUSH
39265: LD_VAR 0 8
39269: PUSH
39270: LD_INT 2
39272: ARRAY
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: ST_TO_ADDR
39278: GO 39341
// if sci = 1 then
39280: LD_VAR 0 8
39284: PUSH
39285: LD_INT 1
39287: EQUAL
39288: IFFALSE 39309
// sci := [ sci [ 1 ] ] else
39290: LD_ADDR_VAR 0 8
39294: PUSH
39295: LD_VAR 0 8
39299: PUSH
39300: LD_INT 1
39302: ARRAY
39303: PUSH
39304: EMPTY
39305: LIST
39306: ST_TO_ADDR
39307: GO 39341
// if sci = 0 then
39309: LD_VAR 0 8
39313: PUSH
39314: LD_INT 0
39316: EQUAL
39317: IFFALSE 39341
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39319: LD_ADDR_VAR 0 11
39323: PUSH
39324: LD_VAR 0 4
39328: PPUSH
39329: LD_INT 4
39331: PPUSH
39332: CALL 105688 0 2
39336: PUSH
39337: LD_INT 1
39339: ARRAY
39340: ST_TO_ADDR
// if eng > 4 then
39341: LD_VAR 0 6
39345: PUSH
39346: LD_INT 4
39348: GREATER
39349: IFFALSE 39395
// for i = eng downto 4 do
39351: LD_ADDR_VAR 0 3
39355: PUSH
39356: DOUBLE
39357: LD_VAR 0 6
39361: INC
39362: ST_TO_ADDR
39363: LD_INT 4
39365: PUSH
39366: FOR_DOWNTO
39367: IFFALSE 39393
// eng := eng diff eng [ i ] ;
39369: LD_ADDR_VAR 0 6
39373: PUSH
39374: LD_VAR 0 6
39378: PUSH
39379: LD_VAR 0 6
39383: PUSH
39384: LD_VAR 0 3
39388: ARRAY
39389: DIFF
39390: ST_TO_ADDR
39391: GO 39366
39393: POP
39394: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39395: LD_ADDR_VAR 0 4
39399: PUSH
39400: LD_VAR 0 4
39404: PUSH
39405: LD_VAR 0 5
39409: PUSH
39410: LD_VAR 0 6
39414: UNION
39415: PUSH
39416: LD_VAR 0 7
39420: UNION
39421: PUSH
39422: LD_VAR 0 8
39426: UNION
39427: DIFF
39428: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39429: LD_ADDR_VAR 0 13
39433: PUSH
39434: LD_EXP 101
39438: PUSH
39439: LD_VAR 0 1
39443: ARRAY
39444: PPUSH
39445: LD_INT 2
39447: PUSH
39448: LD_INT 30
39450: PUSH
39451: LD_INT 32
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 30
39460: PUSH
39461: LD_INT 31
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: LIST
39472: PPUSH
39473: CALL_OW 72
39477: PUSH
39478: LD_EXP 101
39482: PUSH
39483: LD_VAR 0 1
39487: ARRAY
39488: PPUSH
39489: LD_INT 2
39491: PUSH
39492: LD_INT 30
39494: PUSH
39495: LD_INT 4
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 30
39504: PUSH
39505: LD_INT 5
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: LIST
39516: PPUSH
39517: CALL_OW 72
39521: PUSH
39522: LD_INT 6
39524: MUL
39525: PLUS
39526: ST_TO_ADDR
// if bcount < tmp then
39527: LD_VAR 0 13
39531: PUSH
39532: LD_VAR 0 4
39536: LESS
39537: IFFALSE 39583
// for i = tmp downto bcount do
39539: LD_ADDR_VAR 0 3
39543: PUSH
39544: DOUBLE
39545: LD_VAR 0 4
39549: INC
39550: ST_TO_ADDR
39551: LD_VAR 0 13
39555: PUSH
39556: FOR_DOWNTO
39557: IFFALSE 39581
// tmp := Delete ( tmp , tmp ) ;
39559: LD_ADDR_VAR 0 4
39563: PUSH
39564: LD_VAR 0 4
39568: PPUSH
39569: LD_VAR 0 4
39573: PPUSH
39574: CALL_OW 3
39578: ST_TO_ADDR
39579: GO 39556
39581: POP
39582: POP
// result := [ tmp , 0 , 0 , p ] ;
39583: LD_ADDR_VAR 0 2
39587: PUSH
39588: LD_VAR 0 4
39592: PUSH
39593: LD_INT 0
39595: PUSH
39596: LD_INT 0
39598: PUSH
39599: LD_VAR 0 11
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: LIST
39608: LIST
39609: ST_TO_ADDR
// exit ;
39610: GO 42300
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39612: LD_EXP 101
39616: PUSH
39617: LD_VAR 0 1
39621: ARRAY
39622: PPUSH
39623: LD_INT 2
39625: PUSH
39626: LD_INT 30
39628: PUSH
39629: LD_INT 6
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 30
39638: PUSH
39639: LD_INT 7
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 30
39648: PUSH
39649: LD_INT 8
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: LIST
39660: LIST
39661: PPUSH
39662: CALL_OW 72
39666: NOT
39667: PUSH
39668: LD_EXP 101
39672: PUSH
39673: LD_VAR 0 1
39677: ARRAY
39678: PPUSH
39679: LD_INT 30
39681: PUSH
39682: LD_INT 3
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PPUSH
39689: CALL_OW 72
39693: NOT
39694: AND
39695: IFFALSE 39767
// begin if eng = tmp then
39697: LD_VAR 0 6
39701: PUSH
39702: LD_VAR 0 4
39706: EQUAL
39707: IFFALSE 39711
// exit ;
39709: GO 42300
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39711: LD_ADDR_EXP 143
39715: PUSH
39716: LD_EXP 143
39720: PPUSH
39721: LD_VAR 0 1
39725: PPUSH
39726: LD_INT 1
39728: PPUSH
39729: CALL_OW 1
39733: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39734: LD_ADDR_VAR 0 2
39738: PUSH
39739: LD_INT 0
39741: PUSH
39742: LD_VAR 0 4
39746: PUSH
39747: LD_VAR 0 6
39751: DIFF
39752: PUSH
39753: LD_INT 0
39755: PUSH
39756: LD_INT 0
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: LIST
39763: LIST
39764: ST_TO_ADDR
// exit ;
39765: GO 42300
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39767: LD_EXP 128
39771: PUSH
39772: LD_EXP 127
39776: PUSH
39777: LD_VAR 0 1
39781: ARRAY
39782: ARRAY
39783: PUSH
39784: LD_EXP 101
39788: PUSH
39789: LD_VAR 0 1
39793: ARRAY
39794: PPUSH
39795: LD_INT 2
39797: PUSH
39798: LD_INT 30
39800: PUSH
39801: LD_INT 6
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 30
39810: PUSH
39811: LD_INT 7
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 30
39820: PUSH
39821: LD_INT 8
39823: PUSH
39824: EMPTY
39825: LIST
39826: LIST
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: LIST
39832: LIST
39833: PPUSH
39834: CALL_OW 72
39838: AND
39839: PUSH
39840: LD_EXP 101
39844: PUSH
39845: LD_VAR 0 1
39849: ARRAY
39850: PPUSH
39851: LD_INT 30
39853: PUSH
39854: LD_INT 3
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: PPUSH
39861: CALL_OW 72
39865: NOT
39866: AND
39867: IFFALSE 40081
// begin if sci >= 6 then
39869: LD_VAR 0 8
39873: PUSH
39874: LD_INT 6
39876: GREATEREQUAL
39877: IFFALSE 39881
// exit ;
39879: GO 42300
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39881: LD_ADDR_EXP 143
39885: PUSH
39886: LD_EXP 143
39890: PPUSH
39891: LD_VAR 0 1
39895: PPUSH
39896: LD_INT 2
39898: PPUSH
39899: CALL_OW 1
39903: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39904: LD_ADDR_VAR 0 9
39908: PUSH
39909: LD_VAR 0 4
39913: PUSH
39914: LD_VAR 0 8
39918: DIFF
39919: PPUSH
39920: LD_INT 4
39922: PPUSH
39923: CALL 105688 0 2
39927: ST_TO_ADDR
// p := [ ] ;
39928: LD_ADDR_VAR 0 11
39932: PUSH
39933: EMPTY
39934: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39935: LD_VAR 0 8
39939: PUSH
39940: LD_INT 6
39942: LESS
39943: PUSH
39944: LD_VAR 0 9
39948: PUSH
39949: LD_INT 6
39951: GREATER
39952: AND
39953: IFFALSE 40034
// begin for i = 1 to 6 - sci do
39955: LD_ADDR_VAR 0 3
39959: PUSH
39960: DOUBLE
39961: LD_INT 1
39963: DEC
39964: ST_TO_ADDR
39965: LD_INT 6
39967: PUSH
39968: LD_VAR 0 8
39972: MINUS
39973: PUSH
39974: FOR_TO
39975: IFFALSE 40030
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39977: LD_ADDR_VAR 0 11
39981: PUSH
39982: LD_VAR 0 11
39986: PPUSH
39987: LD_VAR 0 11
39991: PUSH
39992: LD_INT 1
39994: PLUS
39995: PPUSH
39996: LD_VAR 0 9
40000: PUSH
40001: LD_INT 1
40003: ARRAY
40004: PPUSH
40005: CALL_OW 2
40009: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40010: LD_ADDR_VAR 0 9
40014: PUSH
40015: LD_VAR 0 9
40019: PPUSH
40020: LD_INT 1
40022: PPUSH
40023: CALL_OW 3
40027: ST_TO_ADDR
// end ;
40028: GO 39974
40030: POP
40031: POP
// end else
40032: GO 40054
// if sort then
40034: LD_VAR 0 9
40038: IFFALSE 40054
// p := sort [ 1 ] ;
40040: LD_ADDR_VAR 0 11
40044: PUSH
40045: LD_VAR 0 9
40049: PUSH
40050: LD_INT 1
40052: ARRAY
40053: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40054: LD_ADDR_VAR 0 2
40058: PUSH
40059: LD_INT 0
40061: PUSH
40062: LD_INT 0
40064: PUSH
40065: LD_INT 0
40067: PUSH
40068: LD_VAR 0 11
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: LIST
40077: LIST
40078: ST_TO_ADDR
// exit ;
40079: GO 42300
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40081: LD_EXP 128
40085: PUSH
40086: LD_EXP 127
40090: PUSH
40091: LD_VAR 0 1
40095: ARRAY
40096: ARRAY
40097: PUSH
40098: LD_EXP 101
40102: PUSH
40103: LD_VAR 0 1
40107: ARRAY
40108: PPUSH
40109: LD_INT 2
40111: PUSH
40112: LD_INT 30
40114: PUSH
40115: LD_INT 6
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: LD_INT 30
40124: PUSH
40125: LD_INT 7
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 30
40134: PUSH
40135: LD_INT 8
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: PPUSH
40148: CALL_OW 72
40152: AND
40153: PUSH
40154: LD_EXP 101
40158: PUSH
40159: LD_VAR 0 1
40163: ARRAY
40164: PPUSH
40165: LD_INT 30
40167: PUSH
40168: LD_INT 3
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PPUSH
40175: CALL_OW 72
40179: AND
40180: IFFALSE 40914
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40182: LD_ADDR_EXP 143
40186: PUSH
40187: LD_EXP 143
40191: PPUSH
40192: LD_VAR 0 1
40196: PPUSH
40197: LD_INT 3
40199: PPUSH
40200: CALL_OW 1
40204: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40205: LD_ADDR_VAR 0 2
40209: PUSH
40210: LD_INT 0
40212: PUSH
40213: LD_INT 0
40215: PUSH
40216: LD_INT 0
40218: PUSH
40219: LD_INT 0
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: ST_TO_ADDR
// if not eng then
40228: LD_VAR 0 6
40232: NOT
40233: IFFALSE 40296
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40235: LD_ADDR_VAR 0 11
40239: PUSH
40240: LD_VAR 0 4
40244: PPUSH
40245: LD_INT 2
40247: PPUSH
40248: CALL 105688 0 2
40252: PUSH
40253: LD_INT 1
40255: ARRAY
40256: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40257: LD_ADDR_VAR 0 2
40261: PUSH
40262: LD_VAR 0 2
40266: PPUSH
40267: LD_INT 2
40269: PPUSH
40270: LD_VAR 0 11
40274: PPUSH
40275: CALL_OW 1
40279: ST_TO_ADDR
// tmp := tmp diff p ;
40280: LD_ADDR_VAR 0 4
40284: PUSH
40285: LD_VAR 0 4
40289: PUSH
40290: LD_VAR 0 11
40294: DIFF
40295: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40296: LD_VAR 0 4
40300: PUSH
40301: LD_VAR 0 8
40305: PUSH
40306: LD_INT 6
40308: LESS
40309: AND
40310: IFFALSE 40498
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40312: LD_ADDR_VAR 0 9
40316: PUSH
40317: LD_VAR 0 4
40321: PUSH
40322: LD_VAR 0 8
40326: PUSH
40327: LD_VAR 0 7
40331: UNION
40332: DIFF
40333: PPUSH
40334: LD_INT 4
40336: PPUSH
40337: CALL 105688 0 2
40341: ST_TO_ADDR
// p := [ ] ;
40342: LD_ADDR_VAR 0 11
40346: PUSH
40347: EMPTY
40348: ST_TO_ADDR
// if sort then
40349: LD_VAR 0 9
40353: IFFALSE 40469
// for i = 1 to 6 - sci do
40355: LD_ADDR_VAR 0 3
40359: PUSH
40360: DOUBLE
40361: LD_INT 1
40363: DEC
40364: ST_TO_ADDR
40365: LD_INT 6
40367: PUSH
40368: LD_VAR 0 8
40372: MINUS
40373: PUSH
40374: FOR_TO
40375: IFFALSE 40467
// begin if i = sort then
40377: LD_VAR 0 3
40381: PUSH
40382: LD_VAR 0 9
40386: EQUAL
40387: IFFALSE 40391
// break ;
40389: GO 40467
// if GetClass ( i ) = 4 then
40391: LD_VAR 0 3
40395: PPUSH
40396: CALL_OW 257
40400: PUSH
40401: LD_INT 4
40403: EQUAL
40404: IFFALSE 40408
// continue ;
40406: GO 40374
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40408: LD_ADDR_VAR 0 11
40412: PUSH
40413: LD_VAR 0 11
40417: PPUSH
40418: LD_VAR 0 11
40422: PUSH
40423: LD_INT 1
40425: PLUS
40426: PPUSH
40427: LD_VAR 0 9
40431: PUSH
40432: LD_VAR 0 3
40436: ARRAY
40437: PPUSH
40438: CALL_OW 2
40442: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40443: LD_ADDR_VAR 0 4
40447: PUSH
40448: LD_VAR 0 4
40452: PUSH
40453: LD_VAR 0 9
40457: PUSH
40458: LD_VAR 0 3
40462: ARRAY
40463: DIFF
40464: ST_TO_ADDR
// end ;
40465: GO 40374
40467: POP
40468: POP
// if p then
40469: LD_VAR 0 11
40473: IFFALSE 40498
// result := Replace ( result , 4 , p ) ;
40475: LD_ADDR_VAR 0 2
40479: PUSH
40480: LD_VAR 0 2
40484: PPUSH
40485: LD_INT 4
40487: PPUSH
40488: LD_VAR 0 11
40492: PPUSH
40493: CALL_OW 1
40497: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40498: LD_VAR 0 4
40502: PUSH
40503: LD_VAR 0 7
40507: PUSH
40508: LD_INT 6
40510: LESS
40511: AND
40512: IFFALSE 40700
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40514: LD_ADDR_VAR 0 9
40518: PUSH
40519: LD_VAR 0 4
40523: PUSH
40524: LD_VAR 0 8
40528: PUSH
40529: LD_VAR 0 7
40533: UNION
40534: DIFF
40535: PPUSH
40536: LD_INT 3
40538: PPUSH
40539: CALL 105688 0 2
40543: ST_TO_ADDR
// p := [ ] ;
40544: LD_ADDR_VAR 0 11
40548: PUSH
40549: EMPTY
40550: ST_TO_ADDR
// if sort then
40551: LD_VAR 0 9
40555: IFFALSE 40671
// for i = 1 to 6 - mech do
40557: LD_ADDR_VAR 0 3
40561: PUSH
40562: DOUBLE
40563: LD_INT 1
40565: DEC
40566: ST_TO_ADDR
40567: LD_INT 6
40569: PUSH
40570: LD_VAR 0 7
40574: MINUS
40575: PUSH
40576: FOR_TO
40577: IFFALSE 40669
// begin if i = sort then
40579: LD_VAR 0 3
40583: PUSH
40584: LD_VAR 0 9
40588: EQUAL
40589: IFFALSE 40593
// break ;
40591: GO 40669
// if GetClass ( i ) = 3 then
40593: LD_VAR 0 3
40597: PPUSH
40598: CALL_OW 257
40602: PUSH
40603: LD_INT 3
40605: EQUAL
40606: IFFALSE 40610
// continue ;
40608: GO 40576
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40610: LD_ADDR_VAR 0 11
40614: PUSH
40615: LD_VAR 0 11
40619: PPUSH
40620: LD_VAR 0 11
40624: PUSH
40625: LD_INT 1
40627: PLUS
40628: PPUSH
40629: LD_VAR 0 9
40633: PUSH
40634: LD_VAR 0 3
40638: ARRAY
40639: PPUSH
40640: CALL_OW 2
40644: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40645: LD_ADDR_VAR 0 4
40649: PUSH
40650: LD_VAR 0 4
40654: PUSH
40655: LD_VAR 0 9
40659: PUSH
40660: LD_VAR 0 3
40664: ARRAY
40665: DIFF
40666: ST_TO_ADDR
// end ;
40667: GO 40576
40669: POP
40670: POP
// if p then
40671: LD_VAR 0 11
40675: IFFALSE 40700
// result := Replace ( result , 3 , p ) ;
40677: LD_ADDR_VAR 0 2
40681: PUSH
40682: LD_VAR 0 2
40686: PPUSH
40687: LD_INT 3
40689: PPUSH
40690: LD_VAR 0 11
40694: PPUSH
40695: CALL_OW 1
40699: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40700: LD_VAR 0 4
40704: PUSH
40705: LD_INT 6
40707: GREATER
40708: PUSH
40709: LD_VAR 0 6
40713: PUSH
40714: LD_INT 6
40716: LESS
40717: AND
40718: IFFALSE 40912
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40720: LD_ADDR_VAR 0 9
40724: PUSH
40725: LD_VAR 0 4
40729: PUSH
40730: LD_VAR 0 8
40734: PUSH
40735: LD_VAR 0 7
40739: UNION
40740: PUSH
40741: LD_VAR 0 6
40745: UNION
40746: DIFF
40747: PPUSH
40748: LD_INT 2
40750: PPUSH
40751: CALL 105688 0 2
40755: ST_TO_ADDR
// p := [ ] ;
40756: LD_ADDR_VAR 0 11
40760: PUSH
40761: EMPTY
40762: ST_TO_ADDR
// if sort then
40763: LD_VAR 0 9
40767: IFFALSE 40883
// for i = 1 to 6 - eng do
40769: LD_ADDR_VAR 0 3
40773: PUSH
40774: DOUBLE
40775: LD_INT 1
40777: DEC
40778: ST_TO_ADDR
40779: LD_INT 6
40781: PUSH
40782: LD_VAR 0 6
40786: MINUS
40787: PUSH
40788: FOR_TO
40789: IFFALSE 40881
// begin if i = sort then
40791: LD_VAR 0 3
40795: PUSH
40796: LD_VAR 0 9
40800: EQUAL
40801: IFFALSE 40805
// break ;
40803: GO 40881
// if GetClass ( i ) = 2 then
40805: LD_VAR 0 3
40809: PPUSH
40810: CALL_OW 257
40814: PUSH
40815: LD_INT 2
40817: EQUAL
40818: IFFALSE 40822
// continue ;
40820: GO 40788
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40822: LD_ADDR_VAR 0 11
40826: PUSH
40827: LD_VAR 0 11
40831: PPUSH
40832: LD_VAR 0 11
40836: PUSH
40837: LD_INT 1
40839: PLUS
40840: PPUSH
40841: LD_VAR 0 9
40845: PUSH
40846: LD_VAR 0 3
40850: ARRAY
40851: PPUSH
40852: CALL_OW 2
40856: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40857: LD_ADDR_VAR 0 4
40861: PUSH
40862: LD_VAR 0 4
40866: PUSH
40867: LD_VAR 0 9
40871: PUSH
40872: LD_VAR 0 3
40876: ARRAY
40877: DIFF
40878: ST_TO_ADDR
// end ;
40879: GO 40788
40881: POP
40882: POP
// if p then
40883: LD_VAR 0 11
40887: IFFALSE 40912
// result := Replace ( result , 2 , p ) ;
40889: LD_ADDR_VAR 0 2
40893: PUSH
40894: LD_VAR 0 2
40898: PPUSH
40899: LD_INT 2
40901: PPUSH
40902: LD_VAR 0 11
40906: PPUSH
40907: CALL_OW 1
40911: ST_TO_ADDR
// end ; exit ;
40912: GO 42300
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40914: LD_EXP 128
40918: PUSH
40919: LD_EXP 127
40923: PUSH
40924: LD_VAR 0 1
40928: ARRAY
40929: ARRAY
40930: NOT
40931: PUSH
40932: LD_EXP 101
40936: PUSH
40937: LD_VAR 0 1
40941: ARRAY
40942: PPUSH
40943: LD_INT 30
40945: PUSH
40946: LD_INT 3
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PPUSH
40953: CALL_OW 72
40957: AND
40958: PUSH
40959: LD_EXP 106
40963: PUSH
40964: LD_VAR 0 1
40968: ARRAY
40969: AND
40970: IFFALSE 41578
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40972: LD_ADDR_EXP 143
40976: PUSH
40977: LD_EXP 143
40981: PPUSH
40982: LD_VAR 0 1
40986: PPUSH
40987: LD_INT 5
40989: PPUSH
40990: CALL_OW 1
40994: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40995: LD_ADDR_VAR 0 2
40999: PUSH
41000: LD_INT 0
41002: PUSH
41003: LD_INT 0
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: LD_INT 0
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: ST_TO_ADDR
// if sci > 1 then
41018: LD_VAR 0 8
41022: PUSH
41023: LD_INT 1
41025: GREATER
41026: IFFALSE 41054
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41028: LD_ADDR_VAR 0 4
41032: PUSH
41033: LD_VAR 0 4
41037: PUSH
41038: LD_VAR 0 8
41042: PUSH
41043: LD_VAR 0 8
41047: PUSH
41048: LD_INT 1
41050: ARRAY
41051: DIFF
41052: DIFF
41053: ST_TO_ADDR
// if tmp and not sci then
41054: LD_VAR 0 4
41058: PUSH
41059: LD_VAR 0 8
41063: NOT
41064: AND
41065: IFFALSE 41134
// begin sort := SortBySkill ( tmp , 4 ) ;
41067: LD_ADDR_VAR 0 9
41071: PUSH
41072: LD_VAR 0 4
41076: PPUSH
41077: LD_INT 4
41079: PPUSH
41080: CALL 105688 0 2
41084: ST_TO_ADDR
// if sort then
41085: LD_VAR 0 9
41089: IFFALSE 41105
// p := sort [ 1 ] ;
41091: LD_ADDR_VAR 0 11
41095: PUSH
41096: LD_VAR 0 9
41100: PUSH
41101: LD_INT 1
41103: ARRAY
41104: ST_TO_ADDR
// if p then
41105: LD_VAR 0 11
41109: IFFALSE 41134
// result := Replace ( result , 4 , p ) ;
41111: LD_ADDR_VAR 0 2
41115: PUSH
41116: LD_VAR 0 2
41120: PPUSH
41121: LD_INT 4
41123: PPUSH
41124: LD_VAR 0 11
41128: PPUSH
41129: CALL_OW 1
41133: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41134: LD_ADDR_VAR 0 4
41138: PUSH
41139: LD_VAR 0 4
41143: PUSH
41144: LD_VAR 0 7
41148: DIFF
41149: ST_TO_ADDR
// if tmp and mech < 6 then
41150: LD_VAR 0 4
41154: PUSH
41155: LD_VAR 0 7
41159: PUSH
41160: LD_INT 6
41162: LESS
41163: AND
41164: IFFALSE 41352
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41166: LD_ADDR_VAR 0 9
41170: PUSH
41171: LD_VAR 0 4
41175: PUSH
41176: LD_VAR 0 8
41180: PUSH
41181: LD_VAR 0 7
41185: UNION
41186: DIFF
41187: PPUSH
41188: LD_INT 3
41190: PPUSH
41191: CALL 105688 0 2
41195: ST_TO_ADDR
// p := [ ] ;
41196: LD_ADDR_VAR 0 11
41200: PUSH
41201: EMPTY
41202: ST_TO_ADDR
// if sort then
41203: LD_VAR 0 9
41207: IFFALSE 41323
// for i = 1 to 6 - mech do
41209: LD_ADDR_VAR 0 3
41213: PUSH
41214: DOUBLE
41215: LD_INT 1
41217: DEC
41218: ST_TO_ADDR
41219: LD_INT 6
41221: PUSH
41222: LD_VAR 0 7
41226: MINUS
41227: PUSH
41228: FOR_TO
41229: IFFALSE 41321
// begin if i = sort then
41231: LD_VAR 0 3
41235: PUSH
41236: LD_VAR 0 9
41240: EQUAL
41241: IFFALSE 41245
// break ;
41243: GO 41321
// if GetClass ( i ) = 3 then
41245: LD_VAR 0 3
41249: PPUSH
41250: CALL_OW 257
41254: PUSH
41255: LD_INT 3
41257: EQUAL
41258: IFFALSE 41262
// continue ;
41260: GO 41228
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41262: LD_ADDR_VAR 0 11
41266: PUSH
41267: LD_VAR 0 11
41271: PPUSH
41272: LD_VAR 0 11
41276: PUSH
41277: LD_INT 1
41279: PLUS
41280: PPUSH
41281: LD_VAR 0 9
41285: PUSH
41286: LD_VAR 0 3
41290: ARRAY
41291: PPUSH
41292: CALL_OW 2
41296: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41297: LD_ADDR_VAR 0 4
41301: PUSH
41302: LD_VAR 0 4
41306: PUSH
41307: LD_VAR 0 9
41311: PUSH
41312: LD_VAR 0 3
41316: ARRAY
41317: DIFF
41318: ST_TO_ADDR
// end ;
41319: GO 41228
41321: POP
41322: POP
// if p then
41323: LD_VAR 0 11
41327: IFFALSE 41352
// result := Replace ( result , 3 , p ) ;
41329: LD_ADDR_VAR 0 2
41333: PUSH
41334: LD_VAR 0 2
41338: PPUSH
41339: LD_INT 3
41341: PPUSH
41342: LD_VAR 0 11
41346: PPUSH
41347: CALL_OW 1
41351: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41352: LD_ADDR_VAR 0 4
41356: PUSH
41357: LD_VAR 0 4
41361: PUSH
41362: LD_VAR 0 6
41366: DIFF
41367: ST_TO_ADDR
// if tmp and eng < 6 then
41368: LD_VAR 0 4
41372: PUSH
41373: LD_VAR 0 6
41377: PUSH
41378: LD_INT 6
41380: LESS
41381: AND
41382: IFFALSE 41576
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41384: LD_ADDR_VAR 0 9
41388: PUSH
41389: LD_VAR 0 4
41393: PUSH
41394: LD_VAR 0 8
41398: PUSH
41399: LD_VAR 0 7
41403: UNION
41404: PUSH
41405: LD_VAR 0 6
41409: UNION
41410: DIFF
41411: PPUSH
41412: LD_INT 2
41414: PPUSH
41415: CALL 105688 0 2
41419: ST_TO_ADDR
// p := [ ] ;
41420: LD_ADDR_VAR 0 11
41424: PUSH
41425: EMPTY
41426: ST_TO_ADDR
// if sort then
41427: LD_VAR 0 9
41431: IFFALSE 41547
// for i = 1 to 6 - eng do
41433: LD_ADDR_VAR 0 3
41437: PUSH
41438: DOUBLE
41439: LD_INT 1
41441: DEC
41442: ST_TO_ADDR
41443: LD_INT 6
41445: PUSH
41446: LD_VAR 0 6
41450: MINUS
41451: PUSH
41452: FOR_TO
41453: IFFALSE 41545
// begin if i = sort then
41455: LD_VAR 0 3
41459: PUSH
41460: LD_VAR 0 9
41464: EQUAL
41465: IFFALSE 41469
// break ;
41467: GO 41545
// if GetClass ( i ) = 2 then
41469: LD_VAR 0 3
41473: PPUSH
41474: CALL_OW 257
41478: PUSH
41479: LD_INT 2
41481: EQUAL
41482: IFFALSE 41486
// continue ;
41484: GO 41452
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41486: LD_ADDR_VAR 0 11
41490: PUSH
41491: LD_VAR 0 11
41495: PPUSH
41496: LD_VAR 0 11
41500: PUSH
41501: LD_INT 1
41503: PLUS
41504: PPUSH
41505: LD_VAR 0 9
41509: PUSH
41510: LD_VAR 0 3
41514: ARRAY
41515: PPUSH
41516: CALL_OW 2
41520: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41521: LD_ADDR_VAR 0 4
41525: PUSH
41526: LD_VAR 0 4
41530: PUSH
41531: LD_VAR 0 9
41535: PUSH
41536: LD_VAR 0 3
41540: ARRAY
41541: DIFF
41542: ST_TO_ADDR
// end ;
41543: GO 41452
41545: POP
41546: POP
// if p then
41547: LD_VAR 0 11
41551: IFFALSE 41576
// result := Replace ( result , 2 , p ) ;
41553: LD_ADDR_VAR 0 2
41557: PUSH
41558: LD_VAR 0 2
41562: PPUSH
41563: LD_INT 2
41565: PPUSH
41566: LD_VAR 0 11
41570: PPUSH
41571: CALL_OW 1
41575: ST_TO_ADDR
// end ; exit ;
41576: GO 42300
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41578: LD_EXP 128
41582: PUSH
41583: LD_EXP 127
41587: PUSH
41588: LD_VAR 0 1
41592: ARRAY
41593: ARRAY
41594: NOT
41595: PUSH
41596: LD_EXP 101
41600: PUSH
41601: LD_VAR 0 1
41605: ARRAY
41606: PPUSH
41607: LD_INT 30
41609: PUSH
41610: LD_INT 3
41612: PUSH
41613: EMPTY
41614: LIST
41615: LIST
41616: PPUSH
41617: CALL_OW 72
41621: AND
41622: PUSH
41623: LD_EXP 106
41627: PUSH
41628: LD_VAR 0 1
41632: ARRAY
41633: NOT
41634: AND
41635: IFFALSE 42300
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41637: LD_ADDR_EXP 143
41641: PUSH
41642: LD_EXP 143
41646: PPUSH
41647: LD_VAR 0 1
41651: PPUSH
41652: LD_INT 6
41654: PPUSH
41655: CALL_OW 1
41659: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41660: LD_ADDR_VAR 0 2
41664: PUSH
41665: LD_INT 0
41667: PUSH
41668: LD_INT 0
41670: PUSH
41671: LD_INT 0
41673: PUSH
41674: LD_INT 0
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: ST_TO_ADDR
// if sci >= 1 then
41683: LD_VAR 0 8
41687: PUSH
41688: LD_INT 1
41690: GREATEREQUAL
41691: IFFALSE 41713
// tmp := tmp diff sci [ 1 ] ;
41693: LD_ADDR_VAR 0 4
41697: PUSH
41698: LD_VAR 0 4
41702: PUSH
41703: LD_VAR 0 8
41707: PUSH
41708: LD_INT 1
41710: ARRAY
41711: DIFF
41712: ST_TO_ADDR
// if tmp and not sci then
41713: LD_VAR 0 4
41717: PUSH
41718: LD_VAR 0 8
41722: NOT
41723: AND
41724: IFFALSE 41793
// begin sort := SortBySkill ( tmp , 4 ) ;
41726: LD_ADDR_VAR 0 9
41730: PUSH
41731: LD_VAR 0 4
41735: PPUSH
41736: LD_INT 4
41738: PPUSH
41739: CALL 105688 0 2
41743: ST_TO_ADDR
// if sort then
41744: LD_VAR 0 9
41748: IFFALSE 41764
// p := sort [ 1 ] ;
41750: LD_ADDR_VAR 0 11
41754: PUSH
41755: LD_VAR 0 9
41759: PUSH
41760: LD_INT 1
41762: ARRAY
41763: ST_TO_ADDR
// if p then
41764: LD_VAR 0 11
41768: IFFALSE 41793
// result := Replace ( result , 4 , p ) ;
41770: LD_ADDR_VAR 0 2
41774: PUSH
41775: LD_VAR 0 2
41779: PPUSH
41780: LD_INT 4
41782: PPUSH
41783: LD_VAR 0 11
41787: PPUSH
41788: CALL_OW 1
41792: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41793: LD_ADDR_VAR 0 4
41797: PUSH
41798: LD_VAR 0 4
41802: PUSH
41803: LD_VAR 0 7
41807: DIFF
41808: ST_TO_ADDR
// if tmp and mech < 6 then
41809: LD_VAR 0 4
41813: PUSH
41814: LD_VAR 0 7
41818: PUSH
41819: LD_INT 6
41821: LESS
41822: AND
41823: IFFALSE 42005
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41825: LD_ADDR_VAR 0 9
41829: PUSH
41830: LD_VAR 0 4
41834: PUSH
41835: LD_VAR 0 7
41839: DIFF
41840: PPUSH
41841: LD_INT 3
41843: PPUSH
41844: CALL 105688 0 2
41848: ST_TO_ADDR
// p := [ ] ;
41849: LD_ADDR_VAR 0 11
41853: PUSH
41854: EMPTY
41855: ST_TO_ADDR
// if sort then
41856: LD_VAR 0 9
41860: IFFALSE 41976
// for i = 1 to 6 - mech do
41862: LD_ADDR_VAR 0 3
41866: PUSH
41867: DOUBLE
41868: LD_INT 1
41870: DEC
41871: ST_TO_ADDR
41872: LD_INT 6
41874: PUSH
41875: LD_VAR 0 7
41879: MINUS
41880: PUSH
41881: FOR_TO
41882: IFFALSE 41974
// begin if i = sort then
41884: LD_VAR 0 3
41888: PUSH
41889: LD_VAR 0 9
41893: EQUAL
41894: IFFALSE 41898
// break ;
41896: GO 41974
// if GetClass ( i ) = 3 then
41898: LD_VAR 0 3
41902: PPUSH
41903: CALL_OW 257
41907: PUSH
41908: LD_INT 3
41910: EQUAL
41911: IFFALSE 41915
// continue ;
41913: GO 41881
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41915: LD_ADDR_VAR 0 11
41919: PUSH
41920: LD_VAR 0 11
41924: PPUSH
41925: LD_VAR 0 11
41929: PUSH
41930: LD_INT 1
41932: PLUS
41933: PPUSH
41934: LD_VAR 0 9
41938: PUSH
41939: LD_VAR 0 3
41943: ARRAY
41944: PPUSH
41945: CALL_OW 2
41949: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41950: LD_ADDR_VAR 0 4
41954: PUSH
41955: LD_VAR 0 4
41959: PUSH
41960: LD_VAR 0 9
41964: PUSH
41965: LD_VAR 0 3
41969: ARRAY
41970: DIFF
41971: ST_TO_ADDR
// end ;
41972: GO 41881
41974: POP
41975: POP
// if p then
41976: LD_VAR 0 11
41980: IFFALSE 42005
// result := Replace ( result , 3 , p ) ;
41982: LD_ADDR_VAR 0 2
41986: PUSH
41987: LD_VAR 0 2
41991: PPUSH
41992: LD_INT 3
41994: PPUSH
41995: LD_VAR 0 11
41999: PPUSH
42000: CALL_OW 1
42004: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42005: LD_ADDR_VAR 0 4
42009: PUSH
42010: LD_VAR 0 4
42014: PUSH
42015: LD_VAR 0 6
42019: DIFF
42020: ST_TO_ADDR
// if tmp and eng < 4 then
42021: LD_VAR 0 4
42025: PUSH
42026: LD_VAR 0 6
42030: PUSH
42031: LD_INT 4
42033: LESS
42034: AND
42035: IFFALSE 42225
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42037: LD_ADDR_VAR 0 9
42041: PUSH
42042: LD_VAR 0 4
42046: PUSH
42047: LD_VAR 0 7
42051: PUSH
42052: LD_VAR 0 6
42056: UNION
42057: DIFF
42058: PPUSH
42059: LD_INT 2
42061: PPUSH
42062: CALL 105688 0 2
42066: ST_TO_ADDR
// p := [ ] ;
42067: LD_ADDR_VAR 0 11
42071: PUSH
42072: EMPTY
42073: ST_TO_ADDR
// if sort then
42074: LD_VAR 0 9
42078: IFFALSE 42194
// for i = 1 to 4 - eng do
42080: LD_ADDR_VAR 0 3
42084: PUSH
42085: DOUBLE
42086: LD_INT 1
42088: DEC
42089: ST_TO_ADDR
42090: LD_INT 4
42092: PUSH
42093: LD_VAR 0 6
42097: MINUS
42098: PUSH
42099: FOR_TO
42100: IFFALSE 42192
// begin if i = sort then
42102: LD_VAR 0 3
42106: PUSH
42107: LD_VAR 0 9
42111: EQUAL
42112: IFFALSE 42116
// break ;
42114: GO 42192
// if GetClass ( i ) = 2 then
42116: LD_VAR 0 3
42120: PPUSH
42121: CALL_OW 257
42125: PUSH
42126: LD_INT 2
42128: EQUAL
42129: IFFALSE 42133
// continue ;
42131: GO 42099
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42133: LD_ADDR_VAR 0 11
42137: PUSH
42138: LD_VAR 0 11
42142: PPUSH
42143: LD_VAR 0 11
42147: PUSH
42148: LD_INT 1
42150: PLUS
42151: PPUSH
42152: LD_VAR 0 9
42156: PUSH
42157: LD_VAR 0 3
42161: ARRAY
42162: PPUSH
42163: CALL_OW 2
42167: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42168: LD_ADDR_VAR 0 4
42172: PUSH
42173: LD_VAR 0 4
42177: PUSH
42178: LD_VAR 0 9
42182: PUSH
42183: LD_VAR 0 3
42187: ARRAY
42188: DIFF
42189: ST_TO_ADDR
// end ;
42190: GO 42099
42192: POP
42193: POP
// if p then
42194: LD_VAR 0 11
42198: IFFALSE 42223
// result := Replace ( result , 2 , p ) ;
42200: LD_ADDR_VAR 0 2
42204: PUSH
42205: LD_VAR 0 2
42209: PPUSH
42210: LD_INT 2
42212: PPUSH
42213: LD_VAR 0 11
42217: PPUSH
42218: CALL_OW 1
42222: ST_TO_ADDR
// end else
42223: GO 42269
// for i = eng downto 5 do
42225: LD_ADDR_VAR 0 3
42229: PUSH
42230: DOUBLE
42231: LD_VAR 0 6
42235: INC
42236: ST_TO_ADDR
42237: LD_INT 5
42239: PUSH
42240: FOR_DOWNTO
42241: IFFALSE 42267
// tmp := tmp union eng [ i ] ;
42243: LD_ADDR_VAR 0 4
42247: PUSH
42248: LD_VAR 0 4
42252: PUSH
42253: LD_VAR 0 6
42257: PUSH
42258: LD_VAR 0 3
42262: ARRAY
42263: UNION
42264: ST_TO_ADDR
42265: GO 42240
42267: POP
42268: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42269: LD_ADDR_VAR 0 2
42273: PUSH
42274: LD_VAR 0 2
42278: PPUSH
42279: LD_INT 1
42281: PPUSH
42282: LD_VAR 0 4
42286: PUSH
42287: LD_VAR 0 5
42291: DIFF
42292: PPUSH
42293: CALL_OW 1
42297: ST_TO_ADDR
// exit ;
42298: GO 42300
// end ; end ;
42300: LD_VAR 0 2
42304: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42305: LD_INT 0
42307: PPUSH
42308: PPUSH
42309: PPUSH
// if not mc_bases then
42310: LD_EXP 101
42314: NOT
42315: IFFALSE 42319
// exit ;
42317: GO 42425
// for i = 1 to mc_bases do
42319: LD_ADDR_VAR 0 2
42323: PUSH
42324: DOUBLE
42325: LD_INT 1
42327: DEC
42328: ST_TO_ADDR
42329: LD_EXP 101
42333: PUSH
42334: FOR_TO
42335: IFFALSE 42416
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42337: LD_ADDR_VAR 0 3
42341: PUSH
42342: LD_EXP 101
42346: PUSH
42347: LD_VAR 0 2
42351: ARRAY
42352: PPUSH
42353: LD_INT 21
42355: PUSH
42356: LD_INT 3
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 3
42365: PUSH
42366: LD_INT 24
42368: PUSH
42369: LD_INT 1000
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: PPUSH
42384: CALL_OW 72
42388: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42389: LD_ADDR_EXP 102
42393: PUSH
42394: LD_EXP 102
42398: PPUSH
42399: LD_VAR 0 2
42403: PPUSH
42404: LD_VAR 0 3
42408: PPUSH
42409: CALL_OW 1
42413: ST_TO_ADDR
// end ;
42414: GO 42334
42416: POP
42417: POP
// RaiseSailEvent ( 101 ) ;
42418: LD_INT 101
42420: PPUSH
42421: CALL_OW 427
// end ;
42425: LD_VAR 0 1
42429: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42430: LD_INT 0
42432: PPUSH
42433: PPUSH
42434: PPUSH
42435: PPUSH
42436: PPUSH
42437: PPUSH
42438: PPUSH
// if not mc_bases then
42439: LD_EXP 101
42443: NOT
42444: IFFALSE 42448
// exit ;
42446: GO 43021
// for i = 1 to mc_bases do
42448: LD_ADDR_VAR 0 2
42452: PUSH
42453: DOUBLE
42454: LD_INT 1
42456: DEC
42457: ST_TO_ADDR
42458: LD_EXP 101
42462: PUSH
42463: FOR_TO
42464: IFFALSE 43012
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42466: LD_ADDR_VAR 0 5
42470: PUSH
42471: LD_EXP 101
42475: PUSH
42476: LD_VAR 0 2
42480: ARRAY
42481: PUSH
42482: LD_EXP 130
42486: PUSH
42487: LD_VAR 0 2
42491: ARRAY
42492: UNION
42493: PPUSH
42494: LD_INT 21
42496: PUSH
42497: LD_INT 1
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: PUSH
42504: LD_INT 1
42506: PUSH
42507: LD_INT 3
42509: PUSH
42510: LD_INT 54
42512: PUSH
42513: EMPTY
42514: LIST
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: LD_INT 3
42522: PUSH
42523: LD_INT 24
42525: PUSH
42526: LD_INT 800
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: LIST
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PPUSH
42546: CALL_OW 72
42550: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42551: LD_ADDR_VAR 0 6
42555: PUSH
42556: LD_EXP 101
42560: PUSH
42561: LD_VAR 0 2
42565: ARRAY
42566: PPUSH
42567: LD_INT 21
42569: PUSH
42570: LD_INT 1
42572: PUSH
42573: EMPTY
42574: LIST
42575: LIST
42576: PUSH
42577: LD_INT 1
42579: PUSH
42580: LD_INT 3
42582: PUSH
42583: LD_INT 54
42585: PUSH
42586: EMPTY
42587: LIST
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: LD_INT 3
42595: PUSH
42596: LD_INT 24
42598: PUSH
42599: LD_INT 250
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: LIST
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: PPUSH
42619: CALL_OW 72
42623: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42624: LD_ADDR_VAR 0 7
42628: PUSH
42629: LD_VAR 0 5
42633: PUSH
42634: LD_VAR 0 6
42638: DIFF
42639: ST_TO_ADDR
// if not need_heal_1 then
42640: LD_VAR 0 6
42644: NOT
42645: IFFALSE 42678
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42647: LD_ADDR_EXP 104
42651: PUSH
42652: LD_EXP 104
42656: PPUSH
42657: LD_VAR 0 2
42661: PUSH
42662: LD_INT 1
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: PPUSH
42669: EMPTY
42670: PPUSH
42671: CALL 71440 0 3
42675: ST_TO_ADDR
42676: GO 42748
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42678: LD_ADDR_EXP 104
42682: PUSH
42683: LD_EXP 104
42687: PPUSH
42688: LD_VAR 0 2
42692: PUSH
42693: LD_INT 1
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PPUSH
42700: LD_EXP 104
42704: PUSH
42705: LD_VAR 0 2
42709: ARRAY
42710: PUSH
42711: LD_INT 1
42713: ARRAY
42714: PPUSH
42715: LD_INT 3
42717: PUSH
42718: LD_INT 24
42720: PUSH
42721: LD_INT 1000
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PPUSH
42732: CALL_OW 72
42736: PUSH
42737: LD_VAR 0 6
42741: UNION
42742: PPUSH
42743: CALL 71440 0 3
42747: ST_TO_ADDR
// if not need_heal_2 then
42748: LD_VAR 0 7
42752: NOT
42753: IFFALSE 42786
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42755: LD_ADDR_EXP 104
42759: PUSH
42760: LD_EXP 104
42764: PPUSH
42765: LD_VAR 0 2
42769: PUSH
42770: LD_INT 2
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PPUSH
42777: EMPTY
42778: PPUSH
42779: CALL 71440 0 3
42783: ST_TO_ADDR
42784: GO 42818
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42786: LD_ADDR_EXP 104
42790: PUSH
42791: LD_EXP 104
42795: PPUSH
42796: LD_VAR 0 2
42800: PUSH
42801: LD_INT 2
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PPUSH
42808: LD_VAR 0 7
42812: PPUSH
42813: CALL 71440 0 3
42817: ST_TO_ADDR
// if need_heal_2 then
42818: LD_VAR 0 7
42822: IFFALSE 42994
// for j in need_heal_2 do
42824: LD_ADDR_VAR 0 3
42828: PUSH
42829: LD_VAR 0 7
42833: PUSH
42834: FOR_IN
42835: IFFALSE 42992
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42837: LD_ADDR_VAR 0 5
42841: PUSH
42842: LD_EXP 101
42846: PUSH
42847: LD_VAR 0 2
42851: ARRAY
42852: PPUSH
42853: LD_INT 2
42855: PUSH
42856: LD_INT 30
42858: PUSH
42859: LD_INT 6
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: LD_INT 30
42868: PUSH
42869: LD_INT 7
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 30
42878: PUSH
42879: LD_INT 8
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: LD_INT 30
42888: PUSH
42889: LD_INT 0
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: PUSH
42896: LD_INT 30
42898: PUSH
42899: LD_INT 1
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 25
42908: PUSH
42909: LD_INT 4
42911: PUSH
42912: EMPTY
42913: LIST
42914: LIST
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: LIST
42920: LIST
42921: LIST
42922: LIST
42923: LIST
42924: PPUSH
42925: CALL_OW 72
42929: ST_TO_ADDR
// if tmp then
42930: LD_VAR 0 5
42934: IFFALSE 42990
// begin k := NearestUnitToUnit ( tmp , j ) ;
42936: LD_ADDR_VAR 0 4
42940: PUSH
42941: LD_VAR 0 5
42945: PPUSH
42946: LD_VAR 0 3
42950: PPUSH
42951: CALL_OW 74
42955: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42956: LD_VAR 0 3
42960: PPUSH
42961: LD_VAR 0 4
42965: PPUSH
42966: CALL_OW 296
42970: PUSH
42971: LD_INT 7
42973: GREATER
42974: IFFALSE 42990
// ComMoveUnit ( j , k ) ;
42976: LD_VAR 0 3
42980: PPUSH
42981: LD_VAR 0 4
42985: PPUSH
42986: CALL_OW 112
// end ; end ;
42990: GO 42834
42992: POP
42993: POP
// if not need_heal_1 and not need_heal_2 then
42994: LD_VAR 0 6
42998: NOT
42999: PUSH
43000: LD_VAR 0 7
43004: NOT
43005: AND
43006: IFFALSE 43010
// continue ;
43008: GO 42463
// end ;
43010: GO 42463
43012: POP
43013: POP
// RaiseSailEvent ( 102 ) ;
43014: LD_INT 102
43016: PPUSH
43017: CALL_OW 427
// end ;
43021: LD_VAR 0 1
43025: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
43026: LD_INT 0
43028: PPUSH
43029: PPUSH
43030: PPUSH
43031: PPUSH
43032: PPUSH
43033: PPUSH
// if not mc_bases then
43034: LD_EXP 101
43038: NOT
43039: IFFALSE 43043
// exit ;
43041: GO 43753
// for i = 1 to mc_bases do
43043: LD_ADDR_VAR 0 2
43047: PUSH
43048: DOUBLE
43049: LD_INT 1
43051: DEC
43052: ST_TO_ADDR
43053: LD_EXP 101
43057: PUSH
43058: FOR_TO
43059: IFFALSE 43751
// begin if not mc_building_need_repair [ i ] then
43061: LD_EXP 102
43065: PUSH
43066: LD_VAR 0 2
43070: ARRAY
43071: NOT
43072: IFFALSE 43246
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43074: LD_ADDR_VAR 0 6
43078: PUSH
43079: LD_EXP 120
43083: PUSH
43084: LD_VAR 0 2
43088: ARRAY
43089: PPUSH
43090: LD_INT 3
43092: PUSH
43093: LD_INT 24
43095: PUSH
43096: LD_INT 1000
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 2
43109: PUSH
43110: LD_INT 34
43112: PUSH
43113: LD_INT 13
43115: PUSH
43116: EMPTY
43117: LIST
43118: LIST
43119: PUSH
43120: LD_INT 34
43122: PUSH
43123: LD_INT 52
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: LIST
43134: PUSH
43135: EMPTY
43136: LIST
43137: LIST
43138: PPUSH
43139: CALL_OW 72
43143: ST_TO_ADDR
// if cranes then
43144: LD_VAR 0 6
43148: IFFALSE 43210
// for j in cranes do
43150: LD_ADDR_VAR 0 3
43154: PUSH
43155: LD_VAR 0 6
43159: PUSH
43160: FOR_IN
43161: IFFALSE 43208
// if not IsInArea ( j , mc_parking [ i ] ) then
43163: LD_VAR 0 3
43167: PPUSH
43168: LD_EXP 125
43172: PUSH
43173: LD_VAR 0 2
43177: ARRAY
43178: PPUSH
43179: CALL_OW 308
43183: NOT
43184: IFFALSE 43206
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43186: LD_VAR 0 3
43190: PPUSH
43191: LD_EXP 125
43195: PUSH
43196: LD_VAR 0 2
43200: ARRAY
43201: PPUSH
43202: CALL_OW 113
43206: GO 43160
43208: POP
43209: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43210: LD_ADDR_EXP 103
43214: PUSH
43215: LD_EXP 103
43219: PPUSH
43220: LD_VAR 0 2
43224: PPUSH
43225: EMPTY
43226: PPUSH
43227: CALL_OW 1
43231: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43232: LD_VAR 0 2
43236: PPUSH
43237: LD_INT 101
43239: PPUSH
43240: CALL 38138 0 2
// continue ;
43244: GO 43058
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43246: LD_ADDR_EXP 107
43250: PUSH
43251: LD_EXP 107
43255: PPUSH
43256: LD_VAR 0 2
43260: PPUSH
43261: EMPTY
43262: PPUSH
43263: CALL_OW 1
43267: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43268: LD_VAR 0 2
43272: PPUSH
43273: LD_INT 103
43275: PPUSH
43276: CALL 38138 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43280: LD_ADDR_VAR 0 5
43284: PUSH
43285: LD_EXP 101
43289: PUSH
43290: LD_VAR 0 2
43294: ARRAY
43295: PUSH
43296: LD_EXP 130
43300: PUSH
43301: LD_VAR 0 2
43305: ARRAY
43306: UNION
43307: PPUSH
43308: LD_INT 2
43310: PUSH
43311: LD_INT 25
43313: PUSH
43314: LD_INT 2
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 25
43323: PUSH
43324: LD_INT 16
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: EMPTY
43332: LIST
43333: LIST
43334: LIST
43335: PUSH
43336: EMPTY
43337: LIST
43338: PPUSH
43339: CALL_OW 72
43343: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43344: LD_ADDR_VAR 0 6
43348: PUSH
43349: LD_EXP 120
43353: PUSH
43354: LD_VAR 0 2
43358: ARRAY
43359: PPUSH
43360: LD_INT 2
43362: PUSH
43363: LD_INT 34
43365: PUSH
43366: LD_INT 13
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: PUSH
43373: LD_INT 34
43375: PUSH
43376: LD_INT 52
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: LIST
43387: PPUSH
43388: CALL_OW 72
43392: ST_TO_ADDR
// if cranes then
43393: LD_VAR 0 6
43397: IFFALSE 43533
// begin for j in cranes do
43399: LD_ADDR_VAR 0 3
43403: PUSH
43404: LD_VAR 0 6
43408: PUSH
43409: FOR_IN
43410: IFFALSE 43531
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43412: LD_VAR 0 3
43416: PPUSH
43417: CALL_OW 256
43421: PUSH
43422: LD_INT 500
43424: GREATEREQUAL
43425: PUSH
43426: LD_VAR 0 3
43430: PPUSH
43431: CALL_OW 314
43435: NOT
43436: AND
43437: IFFALSE 43471
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43439: LD_VAR 0 3
43443: PPUSH
43444: LD_EXP 102
43448: PUSH
43449: LD_VAR 0 2
43453: ARRAY
43454: PPUSH
43455: LD_VAR 0 3
43459: PPUSH
43460: CALL_OW 74
43464: PPUSH
43465: CALL_OW 130
43469: GO 43529
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43471: LD_VAR 0 3
43475: PPUSH
43476: CALL_OW 256
43480: PUSH
43481: LD_INT 500
43483: LESS
43484: PUSH
43485: LD_VAR 0 3
43489: PPUSH
43490: LD_EXP 125
43494: PUSH
43495: LD_VAR 0 2
43499: ARRAY
43500: PPUSH
43501: CALL_OW 308
43505: NOT
43506: AND
43507: IFFALSE 43529
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43509: LD_VAR 0 3
43513: PPUSH
43514: LD_EXP 125
43518: PUSH
43519: LD_VAR 0 2
43523: ARRAY
43524: PPUSH
43525: CALL_OW 113
43529: GO 43409
43531: POP
43532: POP
// end ; if not tmp then
43533: LD_VAR 0 5
43537: NOT
43538: IFFALSE 43542
// continue ;
43540: GO 43058
// for j in tmp do
43542: LD_ADDR_VAR 0 3
43546: PUSH
43547: LD_VAR 0 5
43551: PUSH
43552: FOR_IN
43553: IFFALSE 43747
// begin if mc_need_heal [ i ] then
43555: LD_EXP 104
43559: PUSH
43560: LD_VAR 0 2
43564: ARRAY
43565: IFFALSE 43613
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43567: LD_VAR 0 3
43571: PUSH
43572: LD_EXP 104
43576: PUSH
43577: LD_VAR 0 2
43581: ARRAY
43582: PUSH
43583: LD_INT 1
43585: ARRAY
43586: IN
43587: PUSH
43588: LD_VAR 0 3
43592: PUSH
43593: LD_EXP 104
43597: PUSH
43598: LD_VAR 0 2
43602: ARRAY
43603: PUSH
43604: LD_INT 2
43606: ARRAY
43607: IN
43608: OR
43609: IFFALSE 43613
// continue ;
43611: GO 43552
// if IsInUnit ( j ) then
43613: LD_VAR 0 3
43617: PPUSH
43618: CALL_OW 310
43622: IFFALSE 43633
// ComExitBuilding ( j ) ;
43624: LD_VAR 0 3
43628: PPUSH
43629: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43633: LD_VAR 0 3
43637: PUSH
43638: LD_EXP 103
43642: PUSH
43643: LD_VAR 0 2
43647: ARRAY
43648: IN
43649: NOT
43650: IFFALSE 43708
// begin SetTag ( j , 101 ) ;
43652: LD_VAR 0 3
43656: PPUSH
43657: LD_INT 101
43659: PPUSH
43660: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43664: LD_ADDR_EXP 103
43668: PUSH
43669: LD_EXP 103
43673: PPUSH
43674: LD_VAR 0 2
43678: PUSH
43679: LD_EXP 103
43683: PUSH
43684: LD_VAR 0 2
43688: ARRAY
43689: PUSH
43690: LD_INT 1
43692: PLUS
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: PPUSH
43698: LD_VAR 0 3
43702: PPUSH
43703: CALL 71440 0 3
43707: ST_TO_ADDR
// end ; wait ( 1 ) ;
43708: LD_INT 1
43710: PPUSH
43711: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43715: LD_VAR 0 3
43719: PPUSH
43720: LD_EXP 102
43724: PUSH
43725: LD_VAR 0 2
43729: ARRAY
43730: PPUSH
43731: LD_VAR 0 3
43735: PPUSH
43736: CALL_OW 74
43740: PPUSH
43741: CALL_OW 130
// end ;
43745: GO 43552
43747: POP
43748: POP
// end ;
43749: GO 43058
43751: POP
43752: POP
// end ;
43753: LD_VAR 0 1
43757: RET
// export function MC_Heal ; var i , j , tmp ; begin
43758: LD_INT 0
43760: PPUSH
43761: PPUSH
43762: PPUSH
43763: PPUSH
// if not mc_bases then
43764: LD_EXP 101
43768: NOT
43769: IFFALSE 43773
// exit ;
43771: GO 44175
// for i = 1 to mc_bases do
43773: LD_ADDR_VAR 0 2
43777: PUSH
43778: DOUBLE
43779: LD_INT 1
43781: DEC
43782: ST_TO_ADDR
43783: LD_EXP 101
43787: PUSH
43788: FOR_TO
43789: IFFALSE 44173
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43791: LD_EXP 104
43795: PUSH
43796: LD_VAR 0 2
43800: ARRAY
43801: PUSH
43802: LD_INT 1
43804: ARRAY
43805: NOT
43806: PUSH
43807: LD_EXP 104
43811: PUSH
43812: LD_VAR 0 2
43816: ARRAY
43817: PUSH
43818: LD_INT 2
43820: ARRAY
43821: NOT
43822: AND
43823: IFFALSE 43861
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43825: LD_ADDR_EXP 105
43829: PUSH
43830: LD_EXP 105
43834: PPUSH
43835: LD_VAR 0 2
43839: PPUSH
43840: EMPTY
43841: PPUSH
43842: CALL_OW 1
43846: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43847: LD_VAR 0 2
43851: PPUSH
43852: LD_INT 102
43854: PPUSH
43855: CALL 38138 0 2
// continue ;
43859: GO 43788
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43861: LD_ADDR_VAR 0 4
43865: PUSH
43866: LD_EXP 101
43870: PUSH
43871: LD_VAR 0 2
43875: ARRAY
43876: PPUSH
43877: LD_INT 25
43879: PUSH
43880: LD_INT 4
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PPUSH
43887: CALL_OW 72
43891: ST_TO_ADDR
// if not tmp then
43892: LD_VAR 0 4
43896: NOT
43897: IFFALSE 43901
// continue ;
43899: GO 43788
// if mc_taming [ i ] then
43901: LD_EXP 132
43905: PUSH
43906: LD_VAR 0 2
43910: ARRAY
43911: IFFALSE 43935
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43913: LD_ADDR_EXP 132
43917: PUSH
43918: LD_EXP 132
43922: PPUSH
43923: LD_VAR 0 2
43927: PPUSH
43928: EMPTY
43929: PPUSH
43930: CALL_OW 1
43934: ST_TO_ADDR
// for j in tmp do
43935: LD_ADDR_VAR 0 3
43939: PUSH
43940: LD_VAR 0 4
43944: PUSH
43945: FOR_IN
43946: IFFALSE 44169
// begin if IsInUnit ( j ) then
43948: LD_VAR 0 3
43952: PPUSH
43953: CALL_OW 310
43957: IFFALSE 43968
// ComExitBuilding ( j ) ;
43959: LD_VAR 0 3
43963: PPUSH
43964: CALL_OW 122
// if not j in mc_healers [ i ] then
43968: LD_VAR 0 3
43972: PUSH
43973: LD_EXP 105
43977: PUSH
43978: LD_VAR 0 2
43982: ARRAY
43983: IN
43984: NOT
43985: IFFALSE 44031
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43987: LD_ADDR_EXP 105
43991: PUSH
43992: LD_EXP 105
43996: PPUSH
43997: LD_VAR 0 2
44001: PUSH
44002: LD_EXP 105
44006: PUSH
44007: LD_VAR 0 2
44011: ARRAY
44012: PUSH
44013: LD_INT 1
44015: PLUS
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PPUSH
44021: LD_VAR 0 3
44025: PPUSH
44026: CALL 71440 0 3
44030: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44031: LD_VAR 0 3
44035: PPUSH
44036: CALL_OW 110
44040: PUSH
44041: LD_INT 102
44043: NONEQUAL
44044: IFFALSE 44058
// SetTag ( j , 102 ) ;
44046: LD_VAR 0 3
44050: PPUSH
44051: LD_INT 102
44053: PPUSH
44054: CALL_OW 109
// Wait ( 3 ) ;
44058: LD_INT 3
44060: PPUSH
44061: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44065: LD_EXP 104
44069: PUSH
44070: LD_VAR 0 2
44074: ARRAY
44075: PUSH
44076: LD_INT 1
44078: ARRAY
44079: IFFALSE 44111
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44081: LD_VAR 0 3
44085: PPUSH
44086: LD_EXP 104
44090: PUSH
44091: LD_VAR 0 2
44095: ARRAY
44096: PUSH
44097: LD_INT 1
44099: ARRAY
44100: PUSH
44101: LD_INT 1
44103: ARRAY
44104: PPUSH
44105: CALL_OW 128
44109: GO 44167
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44111: LD_VAR 0 3
44115: PPUSH
44116: CALL_OW 314
44120: NOT
44121: PUSH
44122: LD_EXP 104
44126: PUSH
44127: LD_VAR 0 2
44131: ARRAY
44132: PUSH
44133: LD_INT 2
44135: ARRAY
44136: AND
44137: IFFALSE 44167
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44139: LD_VAR 0 3
44143: PPUSH
44144: LD_EXP 104
44148: PUSH
44149: LD_VAR 0 2
44153: ARRAY
44154: PUSH
44155: LD_INT 2
44157: ARRAY
44158: PUSH
44159: LD_INT 1
44161: ARRAY
44162: PPUSH
44163: CALL_OW 128
// end ;
44167: GO 43945
44169: POP
44170: POP
// end ;
44171: GO 43788
44173: POP
44174: POP
// end ;
44175: LD_VAR 0 1
44179: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44180: LD_INT 0
44182: PPUSH
44183: PPUSH
44184: PPUSH
44185: PPUSH
44186: PPUSH
// if not mc_bases then
44187: LD_EXP 101
44191: NOT
44192: IFFALSE 44196
// exit ;
44194: GO 45339
// for i = 1 to mc_bases do
44196: LD_ADDR_VAR 0 2
44200: PUSH
44201: DOUBLE
44202: LD_INT 1
44204: DEC
44205: ST_TO_ADDR
44206: LD_EXP 101
44210: PUSH
44211: FOR_TO
44212: IFFALSE 45337
// begin if mc_scan [ i ] then
44214: LD_EXP 124
44218: PUSH
44219: LD_VAR 0 2
44223: ARRAY
44224: IFFALSE 44228
// continue ;
44226: GO 44211
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44228: LD_EXP 106
44232: PUSH
44233: LD_VAR 0 2
44237: ARRAY
44238: NOT
44239: PUSH
44240: LD_EXP 108
44244: PUSH
44245: LD_VAR 0 2
44249: ARRAY
44250: NOT
44251: AND
44252: PUSH
44253: LD_EXP 107
44257: PUSH
44258: LD_VAR 0 2
44262: ARRAY
44263: AND
44264: IFFALSE 44302
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44266: LD_ADDR_EXP 107
44270: PUSH
44271: LD_EXP 107
44275: PPUSH
44276: LD_VAR 0 2
44280: PPUSH
44281: EMPTY
44282: PPUSH
44283: CALL_OW 1
44287: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44288: LD_VAR 0 2
44292: PPUSH
44293: LD_INT 103
44295: PPUSH
44296: CALL 38138 0 2
// continue ;
44300: GO 44211
// end ; if mc_construct_list [ i ] then
44302: LD_EXP 108
44306: PUSH
44307: LD_VAR 0 2
44311: ARRAY
44312: IFFALSE 44532
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44314: LD_ADDR_VAR 0 4
44318: PUSH
44319: LD_EXP 101
44323: PUSH
44324: LD_VAR 0 2
44328: ARRAY
44329: PPUSH
44330: LD_INT 25
44332: PUSH
44333: LD_INT 2
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PPUSH
44340: CALL_OW 72
44344: PUSH
44345: LD_EXP 103
44349: PUSH
44350: LD_VAR 0 2
44354: ARRAY
44355: DIFF
44356: ST_TO_ADDR
// if not tmp then
44357: LD_VAR 0 4
44361: NOT
44362: IFFALSE 44366
// continue ;
44364: GO 44211
// for j in tmp do
44366: LD_ADDR_VAR 0 3
44370: PUSH
44371: LD_VAR 0 4
44375: PUSH
44376: FOR_IN
44377: IFFALSE 44528
// begin if not mc_builders [ i ] then
44379: LD_EXP 107
44383: PUSH
44384: LD_VAR 0 2
44388: ARRAY
44389: NOT
44390: IFFALSE 44448
// begin SetTag ( j , 103 ) ;
44392: LD_VAR 0 3
44396: PPUSH
44397: LD_INT 103
44399: PPUSH
44400: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44404: LD_ADDR_EXP 107
44408: PUSH
44409: LD_EXP 107
44413: PPUSH
44414: LD_VAR 0 2
44418: PUSH
44419: LD_EXP 107
44423: PUSH
44424: LD_VAR 0 2
44428: ARRAY
44429: PUSH
44430: LD_INT 1
44432: PLUS
44433: PUSH
44434: EMPTY
44435: LIST
44436: LIST
44437: PPUSH
44438: LD_VAR 0 3
44442: PPUSH
44443: CALL 71440 0 3
44447: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44448: LD_VAR 0 3
44452: PPUSH
44453: CALL_OW 310
44457: IFFALSE 44468
// ComExitBuilding ( j ) ;
44459: LD_VAR 0 3
44463: PPUSH
44464: CALL_OW 122
// wait ( 3 ) ;
44468: LD_INT 3
44470: PPUSH
44471: CALL_OW 67
// if not mc_construct_list [ i ] then
44475: LD_EXP 108
44479: PUSH
44480: LD_VAR 0 2
44484: ARRAY
44485: NOT
44486: IFFALSE 44490
// break ;
44488: GO 44528
// if not HasTask ( j ) then
44490: LD_VAR 0 3
44494: PPUSH
44495: CALL_OW 314
44499: NOT
44500: IFFALSE 44526
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44502: LD_VAR 0 3
44506: PPUSH
44507: LD_EXP 108
44511: PUSH
44512: LD_VAR 0 2
44516: ARRAY
44517: PUSH
44518: LD_INT 1
44520: ARRAY
44521: PPUSH
44522: CALL 74291 0 2
// end ;
44526: GO 44376
44528: POP
44529: POP
// end else
44530: GO 45335
// if mc_build_list [ i ] then
44532: LD_EXP 106
44536: PUSH
44537: LD_VAR 0 2
44541: ARRAY
44542: IFFALSE 45335
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44544: LD_ADDR_VAR 0 5
44548: PUSH
44549: LD_EXP 101
44553: PUSH
44554: LD_VAR 0 2
44558: ARRAY
44559: PPUSH
44560: LD_INT 2
44562: PUSH
44563: LD_INT 30
44565: PUSH
44566: LD_INT 0
44568: PUSH
44569: EMPTY
44570: LIST
44571: LIST
44572: PUSH
44573: LD_INT 30
44575: PUSH
44576: LD_INT 1
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: EMPTY
44584: LIST
44585: LIST
44586: LIST
44587: PPUSH
44588: CALL_OW 72
44592: ST_TO_ADDR
// if depot then
44593: LD_VAR 0 5
44597: IFFALSE 44615
// depot := depot [ 1 ] else
44599: LD_ADDR_VAR 0 5
44603: PUSH
44604: LD_VAR 0 5
44608: PUSH
44609: LD_INT 1
44611: ARRAY
44612: ST_TO_ADDR
44613: GO 44623
// depot := 0 ;
44615: LD_ADDR_VAR 0 5
44619: PUSH
44620: LD_INT 0
44622: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44623: LD_EXP 106
44627: PUSH
44628: LD_VAR 0 2
44632: ARRAY
44633: PUSH
44634: LD_INT 1
44636: ARRAY
44637: PUSH
44638: LD_INT 1
44640: ARRAY
44641: PPUSH
44642: CALL 74121 0 1
44646: PUSH
44647: LD_EXP 101
44651: PUSH
44652: LD_VAR 0 2
44656: ARRAY
44657: PPUSH
44658: LD_INT 2
44660: PUSH
44661: LD_INT 30
44663: PUSH
44664: LD_INT 2
44666: PUSH
44667: EMPTY
44668: LIST
44669: LIST
44670: PUSH
44671: LD_INT 30
44673: PUSH
44674: LD_INT 3
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: LIST
44685: PPUSH
44686: CALL_OW 72
44690: NOT
44691: AND
44692: IFFALSE 44797
// begin for j = 1 to mc_build_list [ i ] do
44694: LD_ADDR_VAR 0 3
44698: PUSH
44699: DOUBLE
44700: LD_INT 1
44702: DEC
44703: ST_TO_ADDR
44704: LD_EXP 106
44708: PUSH
44709: LD_VAR 0 2
44713: ARRAY
44714: PUSH
44715: FOR_TO
44716: IFFALSE 44795
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44718: LD_EXP 106
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: PUSH
44729: LD_VAR 0 3
44733: ARRAY
44734: PUSH
44735: LD_INT 1
44737: ARRAY
44738: PUSH
44739: LD_INT 2
44741: EQUAL
44742: IFFALSE 44793
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44744: LD_ADDR_EXP 106
44748: PUSH
44749: LD_EXP 106
44753: PPUSH
44754: LD_VAR 0 2
44758: PPUSH
44759: LD_EXP 106
44763: PUSH
44764: LD_VAR 0 2
44768: ARRAY
44769: PPUSH
44770: LD_VAR 0 3
44774: PPUSH
44775: LD_INT 1
44777: PPUSH
44778: LD_INT 0
44780: PPUSH
44781: CALL 70858 0 4
44785: PPUSH
44786: CALL_OW 1
44790: ST_TO_ADDR
// break ;
44791: GO 44795
// end ;
44793: GO 44715
44795: POP
44796: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44797: LD_EXP 106
44801: PUSH
44802: LD_VAR 0 2
44806: ARRAY
44807: PUSH
44808: LD_INT 1
44810: ARRAY
44811: PUSH
44812: LD_INT 1
44814: ARRAY
44815: PUSH
44816: LD_INT 0
44818: EQUAL
44819: PUSH
44820: LD_VAR 0 5
44824: PUSH
44825: LD_VAR 0 5
44829: PPUSH
44830: LD_EXP 106
44834: PUSH
44835: LD_VAR 0 2
44839: ARRAY
44840: PUSH
44841: LD_INT 1
44843: ARRAY
44844: PUSH
44845: LD_INT 1
44847: ARRAY
44848: PPUSH
44849: LD_EXP 106
44853: PUSH
44854: LD_VAR 0 2
44858: ARRAY
44859: PUSH
44860: LD_INT 1
44862: ARRAY
44863: PUSH
44864: LD_INT 2
44866: ARRAY
44867: PPUSH
44868: LD_EXP 106
44872: PUSH
44873: LD_VAR 0 2
44877: ARRAY
44878: PUSH
44879: LD_INT 1
44881: ARRAY
44882: PUSH
44883: LD_INT 3
44885: ARRAY
44886: PPUSH
44887: LD_EXP 106
44891: PUSH
44892: LD_VAR 0 2
44896: ARRAY
44897: PUSH
44898: LD_INT 1
44900: ARRAY
44901: PUSH
44902: LD_INT 4
44904: ARRAY
44905: PPUSH
44906: CALL 78855 0 5
44910: AND
44911: OR
44912: IFFALSE 45193
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44914: LD_ADDR_VAR 0 4
44918: PUSH
44919: LD_EXP 101
44923: PUSH
44924: LD_VAR 0 2
44928: ARRAY
44929: PPUSH
44930: LD_INT 25
44932: PUSH
44933: LD_INT 2
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: PPUSH
44940: CALL_OW 72
44944: PUSH
44945: LD_EXP 103
44949: PUSH
44950: LD_VAR 0 2
44954: ARRAY
44955: DIFF
44956: ST_TO_ADDR
// if not tmp then
44957: LD_VAR 0 4
44961: NOT
44962: IFFALSE 44966
// continue ;
44964: GO 44211
// for j in tmp do
44966: LD_ADDR_VAR 0 3
44970: PUSH
44971: LD_VAR 0 4
44975: PUSH
44976: FOR_IN
44977: IFFALSE 45189
// begin if not mc_builders [ i ] then
44979: LD_EXP 107
44983: PUSH
44984: LD_VAR 0 2
44988: ARRAY
44989: NOT
44990: IFFALSE 45048
// begin SetTag ( j , 103 ) ;
44992: LD_VAR 0 3
44996: PPUSH
44997: LD_INT 103
44999: PPUSH
45000: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45004: LD_ADDR_EXP 107
45008: PUSH
45009: LD_EXP 107
45013: PPUSH
45014: LD_VAR 0 2
45018: PUSH
45019: LD_EXP 107
45023: PUSH
45024: LD_VAR 0 2
45028: ARRAY
45029: PUSH
45030: LD_INT 1
45032: PLUS
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PPUSH
45038: LD_VAR 0 3
45042: PPUSH
45043: CALL 71440 0 3
45047: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45048: LD_VAR 0 3
45052: PPUSH
45053: CALL_OW 310
45057: IFFALSE 45068
// ComExitBuilding ( j ) ;
45059: LD_VAR 0 3
45063: PPUSH
45064: CALL_OW 122
// wait ( 3 ) ;
45068: LD_INT 3
45070: PPUSH
45071: CALL_OW 67
// if not mc_build_list [ i ] then
45075: LD_EXP 106
45079: PUSH
45080: LD_VAR 0 2
45084: ARRAY
45085: NOT
45086: IFFALSE 45090
// break ;
45088: GO 45189
// if not HasTask ( j ) then
45090: LD_VAR 0 3
45094: PPUSH
45095: CALL_OW 314
45099: NOT
45100: IFFALSE 45187
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45102: LD_VAR 0 3
45106: PPUSH
45107: LD_EXP 106
45111: PUSH
45112: LD_VAR 0 2
45116: ARRAY
45117: PUSH
45118: LD_INT 1
45120: ARRAY
45121: PUSH
45122: LD_INT 1
45124: ARRAY
45125: PPUSH
45126: LD_EXP 106
45130: PUSH
45131: LD_VAR 0 2
45135: ARRAY
45136: PUSH
45137: LD_INT 1
45139: ARRAY
45140: PUSH
45141: LD_INT 2
45143: ARRAY
45144: PPUSH
45145: LD_EXP 106
45149: PUSH
45150: LD_VAR 0 2
45154: ARRAY
45155: PUSH
45156: LD_INT 1
45158: ARRAY
45159: PUSH
45160: LD_INT 3
45162: ARRAY
45163: PPUSH
45164: LD_EXP 106
45168: PUSH
45169: LD_VAR 0 2
45173: ARRAY
45174: PUSH
45175: LD_INT 1
45177: ARRAY
45178: PUSH
45179: LD_INT 4
45181: ARRAY
45182: PPUSH
45183: CALL_OW 145
// end ;
45187: GO 44976
45189: POP
45190: POP
// end else
45191: GO 45335
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45193: LD_EXP 101
45197: PUSH
45198: LD_VAR 0 2
45202: ARRAY
45203: PPUSH
45204: LD_EXP 106
45208: PUSH
45209: LD_VAR 0 2
45213: ARRAY
45214: PUSH
45215: LD_INT 1
45217: ARRAY
45218: PUSH
45219: LD_INT 1
45221: ARRAY
45222: PPUSH
45223: LD_EXP 106
45227: PUSH
45228: LD_VAR 0 2
45232: ARRAY
45233: PUSH
45234: LD_INT 1
45236: ARRAY
45237: PUSH
45238: LD_INT 2
45240: ARRAY
45241: PPUSH
45242: LD_EXP 106
45246: PUSH
45247: LD_VAR 0 2
45251: ARRAY
45252: PUSH
45253: LD_INT 1
45255: ARRAY
45256: PUSH
45257: LD_INT 3
45259: ARRAY
45260: PPUSH
45261: LD_EXP 106
45265: PUSH
45266: LD_VAR 0 2
45270: ARRAY
45271: PUSH
45272: LD_INT 1
45274: ARRAY
45275: PUSH
45276: LD_INT 4
45278: ARRAY
45279: PPUSH
45280: CALL 78191 0 5
45284: NOT
45285: IFFALSE 45335
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45287: LD_ADDR_EXP 106
45291: PUSH
45292: LD_EXP 106
45296: PPUSH
45297: LD_VAR 0 2
45301: PPUSH
45302: LD_EXP 106
45306: PUSH
45307: LD_VAR 0 2
45311: ARRAY
45312: PPUSH
45313: LD_INT 1
45315: PPUSH
45316: LD_INT 1
45318: NEG
45319: PPUSH
45320: LD_INT 0
45322: PPUSH
45323: CALL 70858 0 4
45327: PPUSH
45328: CALL_OW 1
45332: ST_TO_ADDR
// continue ;
45333: GO 44211
// end ; end ; end ;
45335: GO 44211
45337: POP
45338: POP
// end ;
45339: LD_VAR 0 1
45343: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45344: LD_INT 0
45346: PPUSH
45347: PPUSH
45348: PPUSH
45349: PPUSH
45350: PPUSH
45351: PPUSH
// if not mc_bases then
45352: LD_EXP 101
45356: NOT
45357: IFFALSE 45361
// exit ;
45359: GO 45788
// for i = 1 to mc_bases do
45361: LD_ADDR_VAR 0 2
45365: PUSH
45366: DOUBLE
45367: LD_INT 1
45369: DEC
45370: ST_TO_ADDR
45371: LD_EXP 101
45375: PUSH
45376: FOR_TO
45377: IFFALSE 45786
// begin tmp := mc_build_upgrade [ i ] ;
45379: LD_ADDR_VAR 0 4
45383: PUSH
45384: LD_EXP 133
45388: PUSH
45389: LD_VAR 0 2
45393: ARRAY
45394: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45395: LD_ADDR_VAR 0 6
45399: PUSH
45400: LD_EXP 134
45404: PUSH
45405: LD_VAR 0 2
45409: ARRAY
45410: PPUSH
45411: LD_INT 2
45413: PUSH
45414: LD_INT 30
45416: PUSH
45417: LD_INT 6
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: LD_INT 30
45426: PUSH
45427: LD_INT 7
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: LIST
45438: PPUSH
45439: CALL_OW 72
45443: ST_TO_ADDR
// if not tmp and not lab then
45444: LD_VAR 0 4
45448: NOT
45449: PUSH
45450: LD_VAR 0 6
45454: NOT
45455: AND
45456: IFFALSE 45460
// continue ;
45458: GO 45376
// if tmp then
45460: LD_VAR 0 4
45464: IFFALSE 45584
// for j in tmp do
45466: LD_ADDR_VAR 0 3
45470: PUSH
45471: LD_VAR 0 4
45475: PUSH
45476: FOR_IN
45477: IFFALSE 45582
// begin if UpgradeCost ( j ) then
45479: LD_VAR 0 3
45483: PPUSH
45484: CALL 77851 0 1
45488: IFFALSE 45580
// begin ComUpgrade ( j ) ;
45490: LD_VAR 0 3
45494: PPUSH
45495: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45499: LD_ADDR_EXP 133
45503: PUSH
45504: LD_EXP 133
45508: PPUSH
45509: LD_VAR 0 2
45513: PPUSH
45514: LD_EXP 133
45518: PUSH
45519: LD_VAR 0 2
45523: ARRAY
45524: PUSH
45525: LD_VAR 0 3
45529: DIFF
45530: PPUSH
45531: CALL_OW 1
45535: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45536: LD_ADDR_EXP 108
45540: PUSH
45541: LD_EXP 108
45545: PPUSH
45546: LD_VAR 0 2
45550: PUSH
45551: LD_EXP 108
45555: PUSH
45556: LD_VAR 0 2
45560: ARRAY
45561: PUSH
45562: LD_INT 1
45564: PLUS
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PPUSH
45570: LD_VAR 0 3
45574: PPUSH
45575: CALL 71440 0 3
45579: ST_TO_ADDR
// end ; end ;
45580: GO 45476
45582: POP
45583: POP
// if not lab or not mc_lab_upgrade [ i ] then
45584: LD_VAR 0 6
45588: NOT
45589: PUSH
45590: LD_EXP 135
45594: PUSH
45595: LD_VAR 0 2
45599: ARRAY
45600: NOT
45601: OR
45602: IFFALSE 45606
// continue ;
45604: GO 45376
// for j in lab do
45606: LD_ADDR_VAR 0 3
45610: PUSH
45611: LD_VAR 0 6
45615: PUSH
45616: FOR_IN
45617: IFFALSE 45782
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45619: LD_VAR 0 3
45623: PPUSH
45624: CALL_OW 266
45628: PUSH
45629: LD_INT 6
45631: PUSH
45632: LD_INT 7
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: IN
45639: PUSH
45640: LD_VAR 0 3
45644: PPUSH
45645: CALL_OW 461
45649: PUSH
45650: LD_INT 1
45652: NONEQUAL
45653: AND
45654: IFFALSE 45780
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45656: LD_VAR 0 3
45660: PPUSH
45661: LD_EXP 135
45665: PUSH
45666: LD_VAR 0 2
45670: ARRAY
45671: PUSH
45672: LD_INT 1
45674: ARRAY
45675: PPUSH
45676: CALL 78056 0 2
45680: IFFALSE 45780
// begin ComCancel ( j ) ;
45682: LD_VAR 0 3
45686: PPUSH
45687: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45691: LD_VAR 0 3
45695: PPUSH
45696: LD_EXP 135
45700: PUSH
45701: LD_VAR 0 2
45705: ARRAY
45706: PUSH
45707: LD_INT 1
45709: ARRAY
45710: PPUSH
45711: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45715: LD_VAR 0 3
45719: PUSH
45720: LD_EXP 108
45724: PUSH
45725: LD_VAR 0 2
45729: ARRAY
45730: IN
45731: NOT
45732: IFFALSE 45778
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45734: LD_ADDR_EXP 108
45738: PUSH
45739: LD_EXP 108
45743: PPUSH
45744: LD_VAR 0 2
45748: PUSH
45749: LD_EXP 108
45753: PUSH
45754: LD_VAR 0 2
45758: ARRAY
45759: PUSH
45760: LD_INT 1
45762: PLUS
45763: PUSH
45764: EMPTY
45765: LIST
45766: LIST
45767: PPUSH
45768: LD_VAR 0 3
45772: PPUSH
45773: CALL 71440 0 3
45777: ST_TO_ADDR
// break ;
45778: GO 45782
// end ; end ; end ;
45780: GO 45616
45782: POP
45783: POP
// end ;
45784: GO 45376
45786: POP
45787: POP
// end ;
45788: LD_VAR 0 1
45792: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45793: LD_INT 0
45795: PPUSH
45796: PPUSH
45797: PPUSH
45798: PPUSH
45799: PPUSH
45800: PPUSH
45801: PPUSH
45802: PPUSH
45803: PPUSH
// if not mc_bases then
45804: LD_EXP 101
45808: NOT
45809: IFFALSE 45813
// exit ;
45811: GO 46218
// for i = 1 to mc_bases do
45813: LD_ADDR_VAR 0 2
45817: PUSH
45818: DOUBLE
45819: LD_INT 1
45821: DEC
45822: ST_TO_ADDR
45823: LD_EXP 101
45827: PUSH
45828: FOR_TO
45829: IFFALSE 46216
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45831: LD_EXP 109
45835: PUSH
45836: LD_VAR 0 2
45840: ARRAY
45841: NOT
45842: PUSH
45843: LD_EXP 101
45847: PUSH
45848: LD_VAR 0 2
45852: ARRAY
45853: PPUSH
45854: LD_INT 30
45856: PUSH
45857: LD_INT 3
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PPUSH
45864: CALL_OW 72
45868: NOT
45869: OR
45870: IFFALSE 45874
// continue ;
45872: GO 45828
// busy := false ;
45874: LD_ADDR_VAR 0 8
45878: PUSH
45879: LD_INT 0
45881: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45882: LD_ADDR_VAR 0 4
45886: PUSH
45887: LD_EXP 101
45891: PUSH
45892: LD_VAR 0 2
45896: ARRAY
45897: PPUSH
45898: LD_INT 30
45900: PUSH
45901: LD_INT 3
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: PPUSH
45908: CALL_OW 72
45912: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45913: LD_ADDR_VAR 0 6
45917: PUSH
45918: LD_EXP 109
45922: PUSH
45923: LD_VAR 0 2
45927: ARRAY
45928: PPUSH
45929: LD_INT 2
45931: PUSH
45932: LD_INT 30
45934: PUSH
45935: LD_INT 32
45937: PUSH
45938: EMPTY
45939: LIST
45940: LIST
45941: PUSH
45942: LD_INT 30
45944: PUSH
45945: LD_INT 33
45947: PUSH
45948: EMPTY
45949: LIST
45950: LIST
45951: PUSH
45952: EMPTY
45953: LIST
45954: LIST
45955: LIST
45956: PPUSH
45957: CALL_OW 72
45961: ST_TO_ADDR
// if not t then
45962: LD_VAR 0 6
45966: NOT
45967: IFFALSE 45971
// continue ;
45969: GO 45828
// for j in tmp do
45971: LD_ADDR_VAR 0 3
45975: PUSH
45976: LD_VAR 0 4
45980: PUSH
45981: FOR_IN
45982: IFFALSE 46012
// if not BuildingStatus ( j ) = bs_idle then
45984: LD_VAR 0 3
45988: PPUSH
45989: CALL_OW 461
45993: PUSH
45994: LD_INT 2
45996: EQUAL
45997: NOT
45998: IFFALSE 46010
// begin busy := true ;
46000: LD_ADDR_VAR 0 8
46004: PUSH
46005: LD_INT 1
46007: ST_TO_ADDR
// break ;
46008: GO 46012
// end ;
46010: GO 45981
46012: POP
46013: POP
// if busy then
46014: LD_VAR 0 8
46018: IFFALSE 46022
// continue ;
46020: GO 45828
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46022: LD_ADDR_VAR 0 7
46026: PUSH
46027: LD_VAR 0 6
46031: PPUSH
46032: LD_INT 35
46034: PUSH
46035: LD_INT 0
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PPUSH
46042: CALL_OW 72
46046: ST_TO_ADDR
// if tw then
46047: LD_VAR 0 7
46051: IFFALSE 46128
// begin tw := tw [ 1 ] ;
46053: LD_ADDR_VAR 0 7
46057: PUSH
46058: LD_VAR 0 7
46062: PUSH
46063: LD_INT 1
46065: ARRAY
46066: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46067: LD_ADDR_VAR 0 9
46071: PUSH
46072: LD_VAR 0 7
46076: PPUSH
46077: LD_EXP 126
46081: PUSH
46082: LD_VAR 0 2
46086: ARRAY
46087: PPUSH
46088: CALL 76410 0 2
46092: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46093: LD_EXP 140
46097: PUSH
46098: LD_VAR 0 2
46102: ARRAY
46103: IFFALSE 46126
// if not weapon in mc_allowed_tower_weapons [ i ] then
46105: LD_VAR 0 9
46109: PUSH
46110: LD_EXP 140
46114: PUSH
46115: LD_VAR 0 2
46119: ARRAY
46120: IN
46121: NOT
46122: IFFALSE 46126
// continue ;
46124: GO 45828
// end else
46126: GO 46191
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46128: LD_ADDR_VAR 0 5
46132: PUSH
46133: LD_EXP 109
46137: PUSH
46138: LD_VAR 0 2
46142: ARRAY
46143: PPUSH
46144: LD_VAR 0 4
46148: PPUSH
46149: CALL 106611 0 2
46153: ST_TO_ADDR
// if not tmp2 then
46154: LD_VAR 0 5
46158: NOT
46159: IFFALSE 46163
// continue ;
46161: GO 45828
// tw := tmp2 [ 1 ] ;
46163: LD_ADDR_VAR 0 7
46167: PUSH
46168: LD_VAR 0 5
46172: PUSH
46173: LD_INT 1
46175: ARRAY
46176: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46177: LD_ADDR_VAR 0 9
46181: PUSH
46182: LD_VAR 0 5
46186: PUSH
46187: LD_INT 2
46189: ARRAY
46190: ST_TO_ADDR
// end ; if not weapon then
46191: LD_VAR 0 9
46195: NOT
46196: IFFALSE 46200
// continue ;
46198: GO 45828
// ComPlaceWeapon ( tw , weapon ) ;
46200: LD_VAR 0 7
46204: PPUSH
46205: LD_VAR 0 9
46209: PPUSH
46210: CALL_OW 148
// end ;
46214: GO 45828
46216: POP
46217: POP
// end ;
46218: LD_VAR 0 1
46222: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46223: LD_INT 0
46225: PPUSH
46226: PPUSH
46227: PPUSH
46228: PPUSH
46229: PPUSH
46230: PPUSH
// if not mc_bases then
46231: LD_EXP 101
46235: NOT
46236: IFFALSE 46240
// exit ;
46238: GO 47252
// for i = 1 to mc_bases do
46240: LD_ADDR_VAR 0 2
46244: PUSH
46245: DOUBLE
46246: LD_INT 1
46248: DEC
46249: ST_TO_ADDR
46250: LD_EXP 101
46254: PUSH
46255: FOR_TO
46256: IFFALSE 47250
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
46258: LD_EXP 114
46262: PUSH
46263: LD_VAR 0 2
46267: ARRAY
46268: NOT
46269: PUSH
46270: LD_EXP 114
46274: PUSH
46275: LD_VAR 0 2
46279: ARRAY
46280: PUSH
46281: LD_EXP 115
46285: PUSH
46286: LD_VAR 0 2
46290: ARRAY
46291: EQUAL
46292: OR
46293: IFFALSE 46297
// continue ;
46295: GO 46255
// if mc_miners [ i ] then
46297: LD_EXP 115
46301: PUSH
46302: LD_VAR 0 2
46306: ARRAY
46307: IFFALSE 46937
// begin k := 1 ;
46309: LD_ADDR_VAR 0 4
46313: PUSH
46314: LD_INT 1
46316: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46317: LD_ADDR_VAR 0 3
46321: PUSH
46322: DOUBLE
46323: LD_EXP 115
46327: PUSH
46328: LD_VAR 0 2
46332: ARRAY
46333: INC
46334: ST_TO_ADDR
46335: LD_INT 1
46337: PUSH
46338: FOR_DOWNTO
46339: IFFALSE 46935
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46341: LD_EXP 115
46345: PUSH
46346: LD_VAR 0 2
46350: ARRAY
46351: PUSH
46352: LD_VAR 0 3
46356: ARRAY
46357: PPUSH
46358: CALL_OW 301
46362: PUSH
46363: LD_EXP 115
46367: PUSH
46368: LD_VAR 0 2
46372: ARRAY
46373: PUSH
46374: LD_VAR 0 3
46378: ARRAY
46379: PPUSH
46380: CALL_OW 257
46384: PUSH
46385: LD_INT 1
46387: NONEQUAL
46388: OR
46389: IFFALSE 46452
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46391: LD_ADDR_VAR 0 5
46395: PUSH
46396: LD_EXP 115
46400: PUSH
46401: LD_VAR 0 2
46405: ARRAY
46406: PUSH
46407: LD_EXP 115
46411: PUSH
46412: LD_VAR 0 2
46416: ARRAY
46417: PUSH
46418: LD_VAR 0 3
46422: ARRAY
46423: DIFF
46424: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46425: LD_ADDR_EXP 115
46429: PUSH
46430: LD_EXP 115
46434: PPUSH
46435: LD_VAR 0 2
46439: PPUSH
46440: LD_VAR 0 5
46444: PPUSH
46445: CALL_OW 1
46449: ST_TO_ADDR
// continue ;
46450: GO 46338
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46452: LD_EXP 115
46456: PUSH
46457: LD_VAR 0 2
46461: ARRAY
46462: PUSH
46463: LD_VAR 0 3
46467: ARRAY
46468: PPUSH
46469: CALL 71376 0 1
46473: PUSH
46474: LD_EXP 115
46478: PUSH
46479: LD_VAR 0 2
46483: ARRAY
46484: PUSH
46485: LD_VAR 0 3
46489: ARRAY
46490: PPUSH
46491: CALL_OW 255
46495: PPUSH
46496: LD_EXP 114
46500: PUSH
46501: LD_VAR 0 2
46505: ARRAY
46506: PUSH
46507: LD_VAR 0 4
46511: ARRAY
46512: PUSH
46513: LD_INT 1
46515: ARRAY
46516: PPUSH
46517: LD_EXP 114
46521: PUSH
46522: LD_VAR 0 2
46526: ARRAY
46527: PUSH
46528: LD_VAR 0 4
46532: ARRAY
46533: PUSH
46534: LD_INT 2
46536: ARRAY
46537: PPUSH
46538: LD_INT 15
46540: PPUSH
46541: CALL 72336 0 4
46545: PUSH
46546: LD_INT 4
46548: ARRAY
46549: PUSH
46550: LD_EXP 115
46554: PUSH
46555: LD_VAR 0 2
46559: ARRAY
46560: PUSH
46561: LD_VAR 0 3
46565: ARRAY
46566: PPUSH
46567: LD_INT 10
46569: PPUSH
46570: CALL 74033 0 2
46574: PUSH
46575: LD_INT 4
46577: ARRAY
46578: OR
46579: AND
46580: IFFALSE 46603
// ComStop ( mc_miners [ i ] [ j ] ) ;
46582: LD_EXP 115
46586: PUSH
46587: LD_VAR 0 2
46591: ARRAY
46592: PUSH
46593: LD_VAR 0 3
46597: ARRAY
46598: PPUSH
46599: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46603: LD_EXP 115
46607: PUSH
46608: LD_VAR 0 2
46612: ARRAY
46613: PUSH
46614: LD_VAR 0 3
46618: ARRAY
46619: PPUSH
46620: CALL_OW 257
46624: PUSH
46625: LD_INT 1
46627: EQUAL
46628: PUSH
46629: LD_EXP 115
46633: PUSH
46634: LD_VAR 0 2
46638: ARRAY
46639: PUSH
46640: LD_VAR 0 3
46644: ARRAY
46645: PPUSH
46646: CALL_OW 459
46650: NOT
46651: AND
46652: PUSH
46653: LD_EXP 115
46657: PUSH
46658: LD_VAR 0 2
46662: ARRAY
46663: PUSH
46664: LD_VAR 0 3
46668: ARRAY
46669: PPUSH
46670: CALL_OW 255
46674: PPUSH
46675: LD_EXP 114
46679: PUSH
46680: LD_VAR 0 2
46684: ARRAY
46685: PUSH
46686: LD_VAR 0 4
46690: ARRAY
46691: PUSH
46692: LD_INT 1
46694: ARRAY
46695: PPUSH
46696: LD_EXP 114
46700: PUSH
46701: LD_VAR 0 2
46705: ARRAY
46706: PUSH
46707: LD_VAR 0 4
46711: ARRAY
46712: PUSH
46713: LD_INT 2
46715: ARRAY
46716: PPUSH
46717: LD_INT 15
46719: PPUSH
46720: CALL 72336 0 4
46724: PUSH
46725: LD_INT 4
46727: ARRAY
46728: PUSH
46729: LD_INT 0
46731: EQUAL
46732: AND
46733: PUSH
46734: LD_EXP 115
46738: PUSH
46739: LD_VAR 0 2
46743: ARRAY
46744: PUSH
46745: LD_VAR 0 3
46749: ARRAY
46750: PPUSH
46751: CALL_OW 314
46755: NOT
46756: AND
46757: IFFALSE 46933
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46759: LD_EXP 115
46763: PUSH
46764: LD_VAR 0 2
46768: ARRAY
46769: PUSH
46770: LD_VAR 0 3
46774: ARRAY
46775: PPUSH
46776: CALL_OW 310
46780: IFFALSE 46803
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46782: LD_EXP 115
46786: PUSH
46787: LD_VAR 0 2
46791: ARRAY
46792: PUSH
46793: LD_VAR 0 3
46797: ARRAY
46798: PPUSH
46799: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46803: LD_EXP 115
46807: PUSH
46808: LD_VAR 0 2
46812: ARRAY
46813: PUSH
46814: LD_VAR 0 3
46818: ARRAY
46819: PPUSH
46820: CALL_OW 314
46824: NOT
46825: IFFALSE 46893
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46827: LD_EXP 115
46831: PUSH
46832: LD_VAR 0 2
46836: ARRAY
46837: PUSH
46838: LD_VAR 0 3
46842: ARRAY
46843: PPUSH
46844: LD_EXP 114
46848: PUSH
46849: LD_VAR 0 2
46853: ARRAY
46854: PUSH
46855: LD_VAR 0 4
46859: ARRAY
46860: PUSH
46861: LD_INT 1
46863: ARRAY
46864: PPUSH
46865: LD_EXP 114
46869: PUSH
46870: LD_VAR 0 2
46874: ARRAY
46875: PUSH
46876: LD_VAR 0 4
46880: ARRAY
46881: PUSH
46882: LD_INT 2
46884: ARRAY
46885: PPUSH
46886: LD_INT 0
46888: PPUSH
46889: CALL_OW 193
// k := k + 1 ;
46893: LD_ADDR_VAR 0 4
46897: PUSH
46898: LD_VAR 0 4
46902: PUSH
46903: LD_INT 1
46905: PLUS
46906: ST_TO_ADDR
// if k > mc_mines [ i ] then
46907: LD_VAR 0 4
46911: PUSH
46912: LD_EXP 114
46916: PUSH
46917: LD_VAR 0 2
46921: ARRAY
46922: GREATER
46923: IFFALSE 46933
// k := 1 ;
46925: LD_ADDR_VAR 0 4
46929: PUSH
46930: LD_INT 1
46932: ST_TO_ADDR
// end ; end ;
46933: GO 46338
46935: POP
46936: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46937: LD_ADDR_VAR 0 5
46941: PUSH
46942: LD_EXP 101
46946: PUSH
46947: LD_VAR 0 2
46951: ARRAY
46952: PPUSH
46953: LD_INT 2
46955: PUSH
46956: LD_INT 30
46958: PUSH
46959: LD_INT 4
46961: PUSH
46962: EMPTY
46963: LIST
46964: LIST
46965: PUSH
46966: LD_INT 30
46968: PUSH
46969: LD_INT 5
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 30
46978: PUSH
46979: LD_INT 32
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: PUSH
46986: EMPTY
46987: LIST
46988: LIST
46989: LIST
46990: LIST
46991: PPUSH
46992: CALL_OW 72
46996: ST_TO_ADDR
// if not tmp then
46997: LD_VAR 0 5
47001: NOT
47002: IFFALSE 47006
// continue ;
47004: GO 46255
// list := [ ] ;
47006: LD_ADDR_VAR 0 6
47010: PUSH
47011: EMPTY
47012: ST_TO_ADDR
// for j in tmp do
47013: LD_ADDR_VAR 0 3
47017: PUSH
47018: LD_VAR 0 5
47022: PUSH
47023: FOR_IN
47024: IFFALSE 47093
// begin for k in UnitsInside ( j ) do
47026: LD_ADDR_VAR 0 4
47030: PUSH
47031: LD_VAR 0 3
47035: PPUSH
47036: CALL_OW 313
47040: PUSH
47041: FOR_IN
47042: IFFALSE 47089
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47044: LD_VAR 0 4
47048: PPUSH
47049: CALL_OW 257
47053: PUSH
47054: LD_INT 1
47056: EQUAL
47057: PUSH
47058: LD_VAR 0 4
47062: PPUSH
47063: CALL_OW 459
47067: NOT
47068: AND
47069: IFFALSE 47087
// list := list ^ k ;
47071: LD_ADDR_VAR 0 6
47075: PUSH
47076: LD_VAR 0 6
47080: PUSH
47081: LD_VAR 0 4
47085: ADD
47086: ST_TO_ADDR
47087: GO 47041
47089: POP
47090: POP
// end ;
47091: GO 47023
47093: POP
47094: POP
// list := list diff mc_miners [ i ] ;
47095: LD_ADDR_VAR 0 6
47099: PUSH
47100: LD_VAR 0 6
47104: PUSH
47105: LD_EXP 115
47109: PUSH
47110: LD_VAR 0 2
47114: ARRAY
47115: DIFF
47116: ST_TO_ADDR
// if not list then
47117: LD_VAR 0 6
47121: NOT
47122: IFFALSE 47126
// continue ;
47124: GO 46255
// k := mc_mines [ i ] - mc_miners [ i ] ;
47126: LD_ADDR_VAR 0 4
47130: PUSH
47131: LD_EXP 114
47135: PUSH
47136: LD_VAR 0 2
47140: ARRAY
47141: PUSH
47142: LD_EXP 115
47146: PUSH
47147: LD_VAR 0 2
47151: ARRAY
47152: MINUS
47153: ST_TO_ADDR
// if k > list then
47154: LD_VAR 0 4
47158: PUSH
47159: LD_VAR 0 6
47163: GREATER
47164: IFFALSE 47176
// k := list ;
47166: LD_ADDR_VAR 0 4
47170: PUSH
47171: LD_VAR 0 6
47175: ST_TO_ADDR
// for j = 1 to k do
47176: LD_ADDR_VAR 0 3
47180: PUSH
47181: DOUBLE
47182: LD_INT 1
47184: DEC
47185: ST_TO_ADDR
47186: LD_VAR 0 4
47190: PUSH
47191: FOR_TO
47192: IFFALSE 47246
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47194: LD_ADDR_EXP 115
47198: PUSH
47199: LD_EXP 115
47203: PPUSH
47204: LD_VAR 0 2
47208: PUSH
47209: LD_EXP 115
47213: PUSH
47214: LD_VAR 0 2
47218: ARRAY
47219: PUSH
47220: LD_INT 1
47222: PLUS
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PPUSH
47228: LD_VAR 0 6
47232: PUSH
47233: LD_VAR 0 3
47237: ARRAY
47238: PPUSH
47239: CALL 71440 0 3
47243: ST_TO_ADDR
47244: GO 47191
47246: POP
47247: POP
// end ;
47248: GO 46255
47250: POP
47251: POP
// end ;
47252: LD_VAR 0 1
47256: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47257: LD_INT 0
47259: PPUSH
47260: PPUSH
47261: PPUSH
47262: PPUSH
47263: PPUSH
47264: PPUSH
47265: PPUSH
47266: PPUSH
47267: PPUSH
47268: PPUSH
// if not mc_bases then
47269: LD_EXP 101
47273: NOT
47274: IFFALSE 47278
// exit ;
47276: GO 49028
// for i = 1 to mc_bases do
47278: LD_ADDR_VAR 0 2
47282: PUSH
47283: DOUBLE
47284: LD_INT 1
47286: DEC
47287: ST_TO_ADDR
47288: LD_EXP 101
47292: PUSH
47293: FOR_TO
47294: IFFALSE 49026
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47296: LD_EXP 101
47300: PUSH
47301: LD_VAR 0 2
47305: ARRAY
47306: NOT
47307: PUSH
47308: LD_EXP 108
47312: PUSH
47313: LD_VAR 0 2
47317: ARRAY
47318: OR
47319: IFFALSE 47323
// continue ;
47321: GO 47293
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47323: LD_EXP 117
47327: PUSH
47328: LD_VAR 0 2
47332: ARRAY
47333: NOT
47334: PUSH
47335: LD_EXP 118
47339: PUSH
47340: LD_VAR 0 2
47344: ARRAY
47345: AND
47346: IFFALSE 47384
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47348: LD_ADDR_EXP 118
47352: PUSH
47353: LD_EXP 118
47357: PPUSH
47358: LD_VAR 0 2
47362: PPUSH
47363: EMPTY
47364: PPUSH
47365: CALL_OW 1
47369: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47370: LD_VAR 0 2
47374: PPUSH
47375: LD_INT 107
47377: PPUSH
47378: CALL 38138 0 2
// continue ;
47382: GO 47293
// end ; target := [ ] ;
47384: LD_ADDR_VAR 0 6
47388: PUSH
47389: EMPTY
47390: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47391: LD_ADDR_VAR 0 3
47395: PUSH
47396: DOUBLE
47397: LD_EXP 117
47401: PUSH
47402: LD_VAR 0 2
47406: ARRAY
47407: INC
47408: ST_TO_ADDR
47409: LD_INT 1
47411: PUSH
47412: FOR_DOWNTO
47413: IFFALSE 47673
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47415: LD_EXP 117
47419: PUSH
47420: LD_VAR 0 2
47424: ARRAY
47425: PUSH
47426: LD_VAR 0 3
47430: ARRAY
47431: PUSH
47432: LD_INT 2
47434: ARRAY
47435: PPUSH
47436: LD_EXP 117
47440: PUSH
47441: LD_VAR 0 2
47445: ARRAY
47446: PUSH
47447: LD_VAR 0 3
47451: ARRAY
47452: PUSH
47453: LD_INT 3
47455: ARRAY
47456: PPUSH
47457: CALL_OW 488
47461: PUSH
47462: LD_EXP 117
47466: PUSH
47467: LD_VAR 0 2
47471: ARRAY
47472: PUSH
47473: LD_VAR 0 3
47477: ARRAY
47478: PUSH
47479: LD_INT 2
47481: ARRAY
47482: PPUSH
47483: LD_EXP 117
47487: PUSH
47488: LD_VAR 0 2
47492: ARRAY
47493: PUSH
47494: LD_VAR 0 3
47498: ARRAY
47499: PUSH
47500: LD_INT 3
47502: ARRAY
47503: PPUSH
47504: CALL_OW 284
47508: PUSH
47509: LD_INT 0
47511: EQUAL
47512: AND
47513: IFFALSE 47568
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47515: LD_ADDR_VAR 0 5
47519: PUSH
47520: LD_EXP 117
47524: PUSH
47525: LD_VAR 0 2
47529: ARRAY
47530: PPUSH
47531: LD_VAR 0 3
47535: PPUSH
47536: CALL_OW 3
47540: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47541: LD_ADDR_EXP 117
47545: PUSH
47546: LD_EXP 117
47550: PPUSH
47551: LD_VAR 0 2
47555: PPUSH
47556: LD_VAR 0 5
47560: PPUSH
47561: CALL_OW 1
47565: ST_TO_ADDR
// continue ;
47566: GO 47412
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47568: LD_EXP 101
47572: PUSH
47573: LD_VAR 0 2
47577: ARRAY
47578: PUSH
47579: LD_INT 1
47581: ARRAY
47582: PPUSH
47583: CALL_OW 255
47587: PPUSH
47588: LD_EXP 117
47592: PUSH
47593: LD_VAR 0 2
47597: ARRAY
47598: PUSH
47599: LD_VAR 0 3
47603: ARRAY
47604: PUSH
47605: LD_INT 2
47607: ARRAY
47608: PPUSH
47609: LD_EXP 117
47613: PUSH
47614: LD_VAR 0 2
47618: ARRAY
47619: PUSH
47620: LD_VAR 0 3
47624: ARRAY
47625: PUSH
47626: LD_INT 3
47628: ARRAY
47629: PPUSH
47630: LD_INT 30
47632: PPUSH
47633: CALL 72336 0 4
47637: PUSH
47638: LD_INT 4
47640: ARRAY
47641: PUSH
47642: LD_INT 0
47644: EQUAL
47645: IFFALSE 47671
// begin target := mc_crates [ i ] [ j ] ;
47647: LD_ADDR_VAR 0 6
47651: PUSH
47652: LD_EXP 117
47656: PUSH
47657: LD_VAR 0 2
47661: ARRAY
47662: PUSH
47663: LD_VAR 0 3
47667: ARRAY
47668: ST_TO_ADDR
// break ;
47669: GO 47673
// end ; end ;
47671: GO 47412
47673: POP
47674: POP
// if not target then
47675: LD_VAR 0 6
47679: NOT
47680: IFFALSE 47684
// continue ;
47682: GO 47293
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47684: LD_ADDR_VAR 0 7
47688: PUSH
47689: LD_EXP 120
47693: PUSH
47694: LD_VAR 0 2
47698: ARRAY
47699: PPUSH
47700: LD_INT 2
47702: PUSH
47703: LD_INT 3
47705: PUSH
47706: LD_INT 58
47708: PUSH
47709: EMPTY
47710: LIST
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: PUSH
47716: LD_INT 61
47718: PUSH
47719: EMPTY
47720: LIST
47721: PUSH
47722: LD_INT 33
47724: PUSH
47725: LD_INT 5
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: PUSH
47732: LD_INT 33
47734: PUSH
47735: LD_INT 3
47737: PUSH
47738: EMPTY
47739: LIST
47740: LIST
47741: PUSH
47742: EMPTY
47743: LIST
47744: LIST
47745: LIST
47746: LIST
47747: LIST
47748: PUSH
47749: LD_INT 2
47751: PUSH
47752: LD_INT 34
47754: PUSH
47755: LD_INT 32
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: PUSH
47762: LD_INT 34
47764: PUSH
47765: LD_INT 51
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: PUSH
47772: LD_INT 34
47774: PUSH
47775: LD_INT 12
47777: PUSH
47778: EMPTY
47779: LIST
47780: LIST
47781: PUSH
47782: EMPTY
47783: LIST
47784: LIST
47785: LIST
47786: LIST
47787: PUSH
47788: EMPTY
47789: LIST
47790: LIST
47791: PPUSH
47792: CALL_OW 72
47796: ST_TO_ADDR
// if not cargo then
47797: LD_VAR 0 7
47801: NOT
47802: IFFALSE 48445
// begin if mc_crates_collector [ i ] < 5 then
47804: LD_EXP 118
47808: PUSH
47809: LD_VAR 0 2
47813: ARRAY
47814: PUSH
47815: LD_INT 5
47817: LESS
47818: IFFALSE 48184
// begin if mc_ape [ i ] then
47820: LD_EXP 130
47824: PUSH
47825: LD_VAR 0 2
47829: ARRAY
47830: IFFALSE 47877
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47832: LD_ADDR_VAR 0 5
47836: PUSH
47837: LD_EXP 130
47841: PUSH
47842: LD_VAR 0 2
47846: ARRAY
47847: PPUSH
47848: LD_INT 25
47850: PUSH
47851: LD_INT 16
47853: PUSH
47854: EMPTY
47855: LIST
47856: LIST
47857: PUSH
47858: LD_INT 24
47860: PUSH
47861: LD_INT 750
47863: PUSH
47864: EMPTY
47865: LIST
47866: LIST
47867: PUSH
47868: EMPTY
47869: LIST
47870: LIST
47871: PPUSH
47872: CALL_OW 72
47876: ST_TO_ADDR
// if not tmp then
47877: LD_VAR 0 5
47881: NOT
47882: IFFALSE 47929
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47884: LD_ADDR_VAR 0 5
47888: PUSH
47889: LD_EXP 101
47893: PUSH
47894: LD_VAR 0 2
47898: ARRAY
47899: PPUSH
47900: LD_INT 25
47902: PUSH
47903: LD_INT 2
47905: PUSH
47906: EMPTY
47907: LIST
47908: LIST
47909: PUSH
47910: LD_INT 24
47912: PUSH
47913: LD_INT 750
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: PPUSH
47924: CALL_OW 72
47928: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47929: LD_EXP 130
47933: PUSH
47934: LD_VAR 0 2
47938: ARRAY
47939: PUSH
47940: LD_EXP 101
47944: PUSH
47945: LD_VAR 0 2
47949: ARRAY
47950: PPUSH
47951: LD_INT 25
47953: PUSH
47954: LD_INT 2
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: PUSH
47961: LD_INT 24
47963: PUSH
47964: LD_INT 750
47966: PUSH
47967: EMPTY
47968: LIST
47969: LIST
47970: PUSH
47971: EMPTY
47972: LIST
47973: LIST
47974: PPUSH
47975: CALL_OW 72
47979: AND
47980: PUSH
47981: LD_VAR 0 5
47985: PUSH
47986: LD_INT 5
47988: LESS
47989: AND
47990: IFFALSE 48072
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47992: LD_ADDR_VAR 0 3
47996: PUSH
47997: LD_EXP 101
48001: PUSH
48002: LD_VAR 0 2
48006: ARRAY
48007: PPUSH
48008: LD_INT 25
48010: PUSH
48011: LD_INT 2
48013: PUSH
48014: EMPTY
48015: LIST
48016: LIST
48017: PUSH
48018: LD_INT 24
48020: PUSH
48021: LD_INT 750
48023: PUSH
48024: EMPTY
48025: LIST
48026: LIST
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: PPUSH
48032: CALL_OW 72
48036: PUSH
48037: FOR_IN
48038: IFFALSE 48070
// begin tmp := tmp union j ;
48040: LD_ADDR_VAR 0 5
48044: PUSH
48045: LD_VAR 0 5
48049: PUSH
48050: LD_VAR 0 3
48054: UNION
48055: ST_TO_ADDR
// if tmp >= 5 then
48056: LD_VAR 0 5
48060: PUSH
48061: LD_INT 5
48063: GREATEREQUAL
48064: IFFALSE 48068
// break ;
48066: GO 48070
// end ;
48068: GO 48037
48070: POP
48071: POP
// end ; if not tmp then
48072: LD_VAR 0 5
48076: NOT
48077: IFFALSE 48081
// continue ;
48079: GO 47293
// for j in tmp do
48081: LD_ADDR_VAR 0 3
48085: PUSH
48086: LD_VAR 0 5
48090: PUSH
48091: FOR_IN
48092: IFFALSE 48182
// if not GetTag ( j ) then
48094: LD_VAR 0 3
48098: PPUSH
48099: CALL_OW 110
48103: NOT
48104: IFFALSE 48180
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48106: LD_ADDR_EXP 118
48110: PUSH
48111: LD_EXP 118
48115: PPUSH
48116: LD_VAR 0 2
48120: PUSH
48121: LD_EXP 118
48125: PUSH
48126: LD_VAR 0 2
48130: ARRAY
48131: PUSH
48132: LD_INT 1
48134: PLUS
48135: PUSH
48136: EMPTY
48137: LIST
48138: LIST
48139: PPUSH
48140: LD_VAR 0 3
48144: PPUSH
48145: CALL 71440 0 3
48149: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48150: LD_VAR 0 3
48154: PPUSH
48155: LD_INT 107
48157: PPUSH
48158: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48162: LD_EXP 118
48166: PUSH
48167: LD_VAR 0 2
48171: ARRAY
48172: PUSH
48173: LD_INT 5
48175: GREATEREQUAL
48176: IFFALSE 48180
// break ;
48178: GO 48182
// end ;
48180: GO 48091
48182: POP
48183: POP
// end ; if mc_crates_collector [ i ] and target then
48184: LD_EXP 118
48188: PUSH
48189: LD_VAR 0 2
48193: ARRAY
48194: PUSH
48195: LD_VAR 0 6
48199: AND
48200: IFFALSE 48443
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48202: LD_EXP 118
48206: PUSH
48207: LD_VAR 0 2
48211: ARRAY
48212: PUSH
48213: LD_VAR 0 6
48217: PUSH
48218: LD_INT 1
48220: ARRAY
48221: LESS
48222: IFFALSE 48242
// tmp := mc_crates_collector [ i ] else
48224: LD_ADDR_VAR 0 5
48228: PUSH
48229: LD_EXP 118
48233: PUSH
48234: LD_VAR 0 2
48238: ARRAY
48239: ST_TO_ADDR
48240: GO 48256
// tmp := target [ 1 ] ;
48242: LD_ADDR_VAR 0 5
48246: PUSH
48247: LD_VAR 0 6
48251: PUSH
48252: LD_INT 1
48254: ARRAY
48255: ST_TO_ADDR
// k := 0 ;
48256: LD_ADDR_VAR 0 4
48260: PUSH
48261: LD_INT 0
48263: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48264: LD_ADDR_VAR 0 3
48268: PUSH
48269: LD_EXP 118
48273: PUSH
48274: LD_VAR 0 2
48278: ARRAY
48279: PUSH
48280: FOR_IN
48281: IFFALSE 48441
// begin k := k + 1 ;
48283: LD_ADDR_VAR 0 4
48287: PUSH
48288: LD_VAR 0 4
48292: PUSH
48293: LD_INT 1
48295: PLUS
48296: ST_TO_ADDR
// if k > tmp then
48297: LD_VAR 0 4
48301: PUSH
48302: LD_VAR 0 5
48306: GREATER
48307: IFFALSE 48311
// break ;
48309: GO 48441
// if not GetClass ( j ) in [ 2 , 16 ] then
48311: LD_VAR 0 3
48315: PPUSH
48316: CALL_OW 257
48320: PUSH
48321: LD_INT 2
48323: PUSH
48324: LD_INT 16
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: IN
48331: NOT
48332: IFFALSE 48385
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48334: LD_ADDR_EXP 118
48338: PUSH
48339: LD_EXP 118
48343: PPUSH
48344: LD_VAR 0 2
48348: PPUSH
48349: LD_EXP 118
48353: PUSH
48354: LD_VAR 0 2
48358: ARRAY
48359: PUSH
48360: LD_VAR 0 3
48364: DIFF
48365: PPUSH
48366: CALL_OW 1
48370: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48371: LD_VAR 0 3
48375: PPUSH
48376: LD_INT 0
48378: PPUSH
48379: CALL_OW 109
// continue ;
48383: GO 48280
// end ; if IsInUnit ( j ) then
48385: LD_VAR 0 3
48389: PPUSH
48390: CALL_OW 310
48394: IFFALSE 48405
// ComExitBuilding ( j ) ;
48396: LD_VAR 0 3
48400: PPUSH
48401: CALL_OW 122
// wait ( 3 ) ;
48405: LD_INT 3
48407: PPUSH
48408: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48412: LD_VAR 0 3
48416: PPUSH
48417: LD_VAR 0 6
48421: PUSH
48422: LD_INT 2
48424: ARRAY
48425: PPUSH
48426: LD_VAR 0 6
48430: PUSH
48431: LD_INT 3
48433: ARRAY
48434: PPUSH
48435: CALL_OW 117
// end ;
48439: GO 48280
48441: POP
48442: POP
// end ; end else
48443: GO 49024
// begin for j in cargo do
48445: LD_ADDR_VAR 0 3
48449: PUSH
48450: LD_VAR 0 7
48454: PUSH
48455: FOR_IN
48456: IFFALSE 49022
// begin if GetTag ( j ) <> 0 then
48458: LD_VAR 0 3
48462: PPUSH
48463: CALL_OW 110
48467: PUSH
48468: LD_INT 0
48470: NONEQUAL
48471: IFFALSE 48475
// continue ;
48473: GO 48455
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48475: LD_VAR 0 3
48479: PPUSH
48480: CALL_OW 256
48484: PUSH
48485: LD_INT 1000
48487: LESS
48488: PUSH
48489: LD_VAR 0 3
48493: PPUSH
48494: LD_EXP 125
48498: PUSH
48499: LD_VAR 0 2
48503: ARRAY
48504: PPUSH
48505: CALL_OW 308
48509: NOT
48510: AND
48511: IFFALSE 48533
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48513: LD_VAR 0 3
48517: PPUSH
48518: LD_EXP 125
48522: PUSH
48523: LD_VAR 0 2
48527: ARRAY
48528: PPUSH
48529: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48533: LD_VAR 0 3
48537: PPUSH
48538: CALL_OW 256
48542: PUSH
48543: LD_INT 1000
48545: LESS
48546: PUSH
48547: LD_VAR 0 3
48551: PPUSH
48552: LD_EXP 125
48556: PUSH
48557: LD_VAR 0 2
48561: ARRAY
48562: PPUSH
48563: CALL_OW 308
48567: AND
48568: IFFALSE 48572
// continue ;
48570: GO 48455
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48572: LD_VAR 0 3
48576: PPUSH
48577: CALL_OW 262
48581: PUSH
48582: LD_INT 2
48584: EQUAL
48585: PUSH
48586: LD_VAR 0 3
48590: PPUSH
48591: CALL_OW 261
48595: PUSH
48596: LD_INT 15
48598: LESS
48599: AND
48600: IFFALSE 48604
// continue ;
48602: GO 48455
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48604: LD_VAR 0 3
48608: PPUSH
48609: CALL_OW 262
48613: PUSH
48614: LD_INT 1
48616: EQUAL
48617: PUSH
48618: LD_VAR 0 3
48622: PPUSH
48623: CALL_OW 261
48627: PUSH
48628: LD_INT 10
48630: LESS
48631: AND
48632: IFFALSE 48961
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48634: LD_ADDR_VAR 0 8
48638: PUSH
48639: LD_EXP 101
48643: PUSH
48644: LD_VAR 0 2
48648: ARRAY
48649: PPUSH
48650: LD_INT 2
48652: PUSH
48653: LD_INT 30
48655: PUSH
48656: LD_INT 0
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: PUSH
48663: LD_INT 30
48665: PUSH
48666: LD_INT 1
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PUSH
48673: EMPTY
48674: LIST
48675: LIST
48676: LIST
48677: PPUSH
48678: CALL_OW 72
48682: ST_TO_ADDR
// if not depot then
48683: LD_VAR 0 8
48687: NOT
48688: IFFALSE 48692
// continue ;
48690: GO 48455
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48692: LD_VAR 0 3
48696: PPUSH
48697: LD_VAR 0 8
48701: PPUSH
48702: LD_VAR 0 3
48706: PPUSH
48707: CALL_OW 74
48711: PPUSH
48712: CALL_OW 296
48716: PUSH
48717: LD_INT 6
48719: LESS
48720: IFFALSE 48736
// SetFuel ( j , 100 ) else
48722: LD_VAR 0 3
48726: PPUSH
48727: LD_INT 100
48729: PPUSH
48730: CALL_OW 240
48734: GO 48961
// if GetFuel ( j ) = 0 then
48736: LD_VAR 0 3
48740: PPUSH
48741: CALL_OW 261
48745: PUSH
48746: LD_INT 0
48748: EQUAL
48749: IFFALSE 48961
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48751: LD_ADDR_EXP 120
48755: PUSH
48756: LD_EXP 120
48760: PPUSH
48761: LD_VAR 0 2
48765: PPUSH
48766: LD_EXP 120
48770: PUSH
48771: LD_VAR 0 2
48775: ARRAY
48776: PUSH
48777: LD_VAR 0 3
48781: DIFF
48782: PPUSH
48783: CALL_OW 1
48787: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48788: LD_VAR 0 3
48792: PPUSH
48793: CALL_OW 263
48797: PUSH
48798: LD_INT 1
48800: EQUAL
48801: IFFALSE 48817
// ComExitVehicle ( IsInUnit ( j ) ) ;
48803: LD_VAR 0 3
48807: PPUSH
48808: CALL_OW 310
48812: PPUSH
48813: CALL_OW 121
// if GetControl ( j ) = control_remote then
48817: LD_VAR 0 3
48821: PPUSH
48822: CALL_OW 263
48826: PUSH
48827: LD_INT 2
48829: EQUAL
48830: IFFALSE 48841
// ComUnlink ( j ) ;
48832: LD_VAR 0 3
48836: PPUSH
48837: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48841: LD_ADDR_VAR 0 9
48845: PUSH
48846: LD_VAR 0 2
48850: PPUSH
48851: LD_INT 3
48853: PPUSH
48854: CALL 58314 0 2
48858: ST_TO_ADDR
// if fac then
48859: LD_VAR 0 9
48863: IFFALSE 48959
// begin for k in fac do
48865: LD_ADDR_VAR 0 4
48869: PUSH
48870: LD_VAR 0 9
48874: PUSH
48875: FOR_IN
48876: IFFALSE 48957
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48878: LD_ADDR_VAR 0 10
48882: PUSH
48883: LD_VAR 0 9
48887: PPUSH
48888: LD_VAR 0 3
48892: PPUSH
48893: CALL_OW 265
48897: PPUSH
48898: LD_VAR 0 3
48902: PPUSH
48903: CALL_OW 262
48907: PPUSH
48908: LD_VAR 0 3
48912: PPUSH
48913: CALL_OW 263
48917: PPUSH
48918: LD_VAR 0 3
48922: PPUSH
48923: CALL_OW 264
48927: PPUSH
48928: CALL 68972 0 5
48932: ST_TO_ADDR
// if components then
48933: LD_VAR 0 10
48937: IFFALSE 48955
// begin MC_InsertProduceList ( i , components ) ;
48939: LD_VAR 0 2
48943: PPUSH
48944: LD_VAR 0 10
48948: PPUSH
48949: CALL 57859 0 2
// break ;
48953: GO 48957
// end ; end ;
48955: GO 48875
48957: POP
48958: POP
// end ; continue ;
48959: GO 48455
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48961: LD_VAR 0 3
48965: PPUSH
48966: LD_INT 1
48968: PPUSH
48969: CALL_OW 289
48973: PUSH
48974: LD_INT 100
48976: LESS
48977: PUSH
48978: LD_VAR 0 3
48982: PPUSH
48983: CALL_OW 314
48987: NOT
48988: AND
48989: IFFALSE 49018
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48991: LD_VAR 0 3
48995: PPUSH
48996: LD_VAR 0 6
49000: PUSH
49001: LD_INT 2
49003: ARRAY
49004: PPUSH
49005: LD_VAR 0 6
49009: PUSH
49010: LD_INT 3
49012: ARRAY
49013: PPUSH
49014: CALL_OW 117
// break ;
49018: GO 49022
// end ;
49020: GO 48455
49022: POP
49023: POP
// end ; end ;
49024: GO 47293
49026: POP
49027: POP
// end ;
49028: LD_VAR 0 1
49032: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49033: LD_INT 0
49035: PPUSH
49036: PPUSH
49037: PPUSH
49038: PPUSH
// if not mc_bases then
49039: LD_EXP 101
49043: NOT
49044: IFFALSE 49048
// exit ;
49046: GO 49209
// for i = 1 to mc_bases do
49048: LD_ADDR_VAR 0 2
49052: PUSH
49053: DOUBLE
49054: LD_INT 1
49056: DEC
49057: ST_TO_ADDR
49058: LD_EXP 101
49062: PUSH
49063: FOR_TO
49064: IFFALSE 49207
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49066: LD_ADDR_VAR 0 4
49070: PUSH
49071: LD_EXP 120
49075: PUSH
49076: LD_VAR 0 2
49080: ARRAY
49081: PUSH
49082: LD_EXP 123
49086: PUSH
49087: LD_VAR 0 2
49091: ARRAY
49092: UNION
49093: PPUSH
49094: LD_INT 33
49096: PUSH
49097: LD_INT 2
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: PPUSH
49104: CALL_OW 72
49108: ST_TO_ADDR
// if tmp then
49109: LD_VAR 0 4
49113: IFFALSE 49205
// for j in tmp do
49115: LD_ADDR_VAR 0 3
49119: PUSH
49120: LD_VAR 0 4
49124: PUSH
49125: FOR_IN
49126: IFFALSE 49203
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49128: LD_VAR 0 3
49132: PPUSH
49133: CALL_OW 312
49137: NOT
49138: PUSH
49139: LD_VAR 0 3
49143: PPUSH
49144: CALL_OW 256
49148: PUSH
49149: LD_INT 250
49151: GREATEREQUAL
49152: AND
49153: IFFALSE 49166
// Connect ( j ) else
49155: LD_VAR 0 3
49159: PPUSH
49160: CALL 74373 0 1
49164: GO 49201
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49166: LD_VAR 0 3
49170: PPUSH
49171: CALL_OW 256
49175: PUSH
49176: LD_INT 250
49178: LESS
49179: PUSH
49180: LD_VAR 0 3
49184: PPUSH
49185: CALL_OW 312
49189: AND
49190: IFFALSE 49201
// ComUnlink ( j ) ;
49192: LD_VAR 0 3
49196: PPUSH
49197: CALL_OW 136
49201: GO 49125
49203: POP
49204: POP
// end ;
49205: GO 49063
49207: POP
49208: POP
// end ;
49209: LD_VAR 0 1
49213: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49214: LD_INT 0
49216: PPUSH
49217: PPUSH
49218: PPUSH
49219: PPUSH
49220: PPUSH
// if not mc_bases then
49221: LD_EXP 101
49225: NOT
49226: IFFALSE 49230
// exit ;
49228: GO 49675
// for i = 1 to mc_bases do
49230: LD_ADDR_VAR 0 2
49234: PUSH
49235: DOUBLE
49236: LD_INT 1
49238: DEC
49239: ST_TO_ADDR
49240: LD_EXP 101
49244: PUSH
49245: FOR_TO
49246: IFFALSE 49673
// begin if not mc_produce [ i ] then
49248: LD_EXP 122
49252: PUSH
49253: LD_VAR 0 2
49257: ARRAY
49258: NOT
49259: IFFALSE 49263
// continue ;
49261: GO 49245
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49263: LD_ADDR_VAR 0 5
49267: PUSH
49268: LD_EXP 101
49272: PUSH
49273: LD_VAR 0 2
49277: ARRAY
49278: PPUSH
49279: LD_INT 30
49281: PUSH
49282: LD_INT 3
49284: PUSH
49285: EMPTY
49286: LIST
49287: LIST
49288: PPUSH
49289: CALL_OW 72
49293: ST_TO_ADDR
// if not fac then
49294: LD_VAR 0 5
49298: NOT
49299: IFFALSE 49303
// continue ;
49301: GO 49245
// for j in fac do
49303: LD_ADDR_VAR 0 3
49307: PUSH
49308: LD_VAR 0 5
49312: PUSH
49313: FOR_IN
49314: IFFALSE 49669
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49316: LD_VAR 0 3
49320: PPUSH
49321: CALL_OW 461
49325: PUSH
49326: LD_INT 2
49328: NONEQUAL
49329: PUSH
49330: LD_VAR 0 3
49334: PPUSH
49335: LD_INT 15
49337: PPUSH
49338: CALL 74033 0 2
49342: PUSH
49343: LD_INT 4
49345: ARRAY
49346: OR
49347: IFFALSE 49351
// continue ;
49349: GO 49313
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49351: LD_VAR 0 3
49355: PPUSH
49356: LD_EXP 122
49360: PUSH
49361: LD_VAR 0 2
49365: ARRAY
49366: PUSH
49367: LD_INT 1
49369: ARRAY
49370: PUSH
49371: LD_INT 1
49373: ARRAY
49374: PPUSH
49375: LD_EXP 122
49379: PUSH
49380: LD_VAR 0 2
49384: ARRAY
49385: PUSH
49386: LD_INT 1
49388: ARRAY
49389: PUSH
49390: LD_INT 2
49392: ARRAY
49393: PPUSH
49394: LD_EXP 122
49398: PUSH
49399: LD_VAR 0 2
49403: ARRAY
49404: PUSH
49405: LD_INT 1
49407: ARRAY
49408: PUSH
49409: LD_INT 3
49411: ARRAY
49412: PPUSH
49413: LD_EXP 122
49417: PUSH
49418: LD_VAR 0 2
49422: ARRAY
49423: PUSH
49424: LD_INT 1
49426: ARRAY
49427: PUSH
49428: LD_INT 4
49430: ARRAY
49431: PPUSH
49432: CALL_OW 448
49436: PUSH
49437: LD_VAR 0 3
49441: PPUSH
49442: LD_EXP 122
49446: PUSH
49447: LD_VAR 0 2
49451: ARRAY
49452: PUSH
49453: LD_INT 1
49455: ARRAY
49456: PUSH
49457: LD_INT 1
49459: ARRAY
49460: PUSH
49461: LD_EXP 122
49465: PUSH
49466: LD_VAR 0 2
49470: ARRAY
49471: PUSH
49472: LD_INT 1
49474: ARRAY
49475: PUSH
49476: LD_INT 2
49478: ARRAY
49479: PUSH
49480: LD_EXP 122
49484: PUSH
49485: LD_VAR 0 2
49489: ARRAY
49490: PUSH
49491: LD_INT 1
49493: ARRAY
49494: PUSH
49495: LD_INT 3
49497: ARRAY
49498: PUSH
49499: LD_EXP 122
49503: PUSH
49504: LD_VAR 0 2
49508: ARRAY
49509: PUSH
49510: LD_INT 1
49512: ARRAY
49513: PUSH
49514: LD_INT 4
49516: ARRAY
49517: PUSH
49518: EMPTY
49519: LIST
49520: LIST
49521: LIST
49522: LIST
49523: PPUSH
49524: CALL 77704 0 2
49528: AND
49529: IFFALSE 49667
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49531: LD_VAR 0 3
49535: PPUSH
49536: LD_EXP 122
49540: PUSH
49541: LD_VAR 0 2
49545: ARRAY
49546: PUSH
49547: LD_INT 1
49549: ARRAY
49550: PUSH
49551: LD_INT 1
49553: ARRAY
49554: PPUSH
49555: LD_EXP 122
49559: PUSH
49560: LD_VAR 0 2
49564: ARRAY
49565: PUSH
49566: LD_INT 1
49568: ARRAY
49569: PUSH
49570: LD_INT 2
49572: ARRAY
49573: PPUSH
49574: LD_EXP 122
49578: PUSH
49579: LD_VAR 0 2
49583: ARRAY
49584: PUSH
49585: LD_INT 1
49587: ARRAY
49588: PUSH
49589: LD_INT 3
49591: ARRAY
49592: PPUSH
49593: LD_EXP 122
49597: PUSH
49598: LD_VAR 0 2
49602: ARRAY
49603: PUSH
49604: LD_INT 1
49606: ARRAY
49607: PUSH
49608: LD_INT 4
49610: ARRAY
49611: PPUSH
49612: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49616: LD_ADDR_VAR 0 4
49620: PUSH
49621: LD_EXP 122
49625: PUSH
49626: LD_VAR 0 2
49630: ARRAY
49631: PPUSH
49632: LD_INT 1
49634: PPUSH
49635: CALL_OW 3
49639: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49640: LD_ADDR_EXP 122
49644: PUSH
49645: LD_EXP 122
49649: PPUSH
49650: LD_VAR 0 2
49654: PPUSH
49655: LD_VAR 0 4
49659: PPUSH
49660: CALL_OW 1
49664: ST_TO_ADDR
// break ;
49665: GO 49669
// end ; end ;
49667: GO 49313
49669: POP
49670: POP
// end ;
49671: GO 49245
49673: POP
49674: POP
// end ;
49675: LD_VAR 0 1
49679: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49680: LD_INT 0
49682: PPUSH
49683: PPUSH
49684: PPUSH
// if not mc_bases then
49685: LD_EXP 101
49689: NOT
49690: IFFALSE 49694
// exit ;
49692: GO 49783
// for i = 1 to mc_bases do
49694: LD_ADDR_VAR 0 2
49698: PUSH
49699: DOUBLE
49700: LD_INT 1
49702: DEC
49703: ST_TO_ADDR
49704: LD_EXP 101
49708: PUSH
49709: FOR_TO
49710: IFFALSE 49781
// begin if mc_attack [ i ] then
49712: LD_EXP 121
49716: PUSH
49717: LD_VAR 0 2
49721: ARRAY
49722: IFFALSE 49779
// begin tmp := mc_attack [ i ] [ 1 ] ;
49724: LD_ADDR_VAR 0 3
49728: PUSH
49729: LD_EXP 121
49733: PUSH
49734: LD_VAR 0 2
49738: ARRAY
49739: PUSH
49740: LD_INT 1
49742: ARRAY
49743: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49744: LD_ADDR_EXP 121
49748: PUSH
49749: LD_EXP 121
49753: PPUSH
49754: LD_VAR 0 2
49758: PPUSH
49759: EMPTY
49760: PPUSH
49761: CALL_OW 1
49765: ST_TO_ADDR
// Attack ( tmp ) ;
49766: LD_VAR 0 3
49770: PPUSH
49771: CALL 99917 0 1
// exit ;
49775: POP
49776: POP
49777: GO 49783
// end ; end ;
49779: GO 49709
49781: POP
49782: POP
// end ;
49783: LD_VAR 0 1
49787: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49788: LD_INT 0
49790: PPUSH
49791: PPUSH
49792: PPUSH
49793: PPUSH
49794: PPUSH
49795: PPUSH
49796: PPUSH
// if not mc_bases then
49797: LD_EXP 101
49801: NOT
49802: IFFALSE 49806
// exit ;
49804: GO 50388
// for i = 1 to mc_bases do
49806: LD_ADDR_VAR 0 2
49810: PUSH
49811: DOUBLE
49812: LD_INT 1
49814: DEC
49815: ST_TO_ADDR
49816: LD_EXP 101
49820: PUSH
49821: FOR_TO
49822: IFFALSE 50386
// begin if not mc_bases [ i ] then
49824: LD_EXP 101
49828: PUSH
49829: LD_VAR 0 2
49833: ARRAY
49834: NOT
49835: IFFALSE 49839
// continue ;
49837: GO 49821
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49839: LD_ADDR_VAR 0 7
49843: PUSH
49844: LD_EXP 101
49848: PUSH
49849: LD_VAR 0 2
49853: ARRAY
49854: PUSH
49855: LD_INT 1
49857: ARRAY
49858: PPUSH
49859: CALL 68276 0 1
49863: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49864: LD_ADDR_EXP 124
49868: PUSH
49869: LD_EXP 124
49873: PPUSH
49874: LD_VAR 0 2
49878: PPUSH
49879: LD_EXP 101
49883: PUSH
49884: LD_VAR 0 2
49888: ARRAY
49889: PUSH
49890: LD_INT 1
49892: ARRAY
49893: PPUSH
49894: CALL_OW 255
49898: PPUSH
49899: LD_EXP 126
49903: PUSH
49904: LD_VAR 0 2
49908: ARRAY
49909: PPUSH
49910: CALL 65830 0 2
49914: PPUSH
49915: CALL_OW 1
49919: ST_TO_ADDR
// if not mc_scan [ i ] then
49920: LD_EXP 124
49924: PUSH
49925: LD_VAR 0 2
49929: ARRAY
49930: NOT
49931: IFFALSE 50086
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49933: LD_ADDR_VAR 0 4
49937: PUSH
49938: LD_EXP 101
49942: PUSH
49943: LD_VAR 0 2
49947: ARRAY
49948: PPUSH
49949: LD_INT 2
49951: PUSH
49952: LD_INT 25
49954: PUSH
49955: LD_INT 5
49957: PUSH
49958: EMPTY
49959: LIST
49960: LIST
49961: PUSH
49962: LD_INT 25
49964: PUSH
49965: LD_INT 8
49967: PUSH
49968: EMPTY
49969: LIST
49970: LIST
49971: PUSH
49972: LD_INT 25
49974: PUSH
49975: LD_INT 9
49977: PUSH
49978: EMPTY
49979: LIST
49980: LIST
49981: PUSH
49982: EMPTY
49983: LIST
49984: LIST
49985: LIST
49986: LIST
49987: PPUSH
49988: CALL_OW 72
49992: ST_TO_ADDR
// if not tmp then
49993: LD_VAR 0 4
49997: NOT
49998: IFFALSE 50002
// continue ;
50000: GO 49821
// for j in tmp do
50002: LD_ADDR_VAR 0 3
50006: PUSH
50007: LD_VAR 0 4
50011: PUSH
50012: FOR_IN
50013: IFFALSE 50084
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50015: LD_VAR 0 3
50019: PPUSH
50020: CALL_OW 310
50024: PPUSH
50025: CALL_OW 266
50029: PUSH
50030: LD_INT 5
50032: EQUAL
50033: PUSH
50034: LD_VAR 0 3
50038: PPUSH
50039: CALL_OW 257
50043: PUSH
50044: LD_INT 1
50046: EQUAL
50047: AND
50048: PUSH
50049: LD_VAR 0 3
50053: PPUSH
50054: CALL_OW 459
50058: NOT
50059: AND
50060: PUSH
50061: LD_VAR 0 7
50065: AND
50066: IFFALSE 50082
// ComChangeProfession ( j , class ) ;
50068: LD_VAR 0 3
50072: PPUSH
50073: LD_VAR 0 7
50077: PPUSH
50078: CALL_OW 123
50082: GO 50012
50084: POP
50085: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50086: LD_EXP 124
50090: PUSH
50091: LD_VAR 0 2
50095: ARRAY
50096: PUSH
50097: LD_EXP 123
50101: PUSH
50102: LD_VAR 0 2
50106: ARRAY
50107: NOT
50108: AND
50109: PUSH
50110: LD_EXP 101
50114: PUSH
50115: LD_VAR 0 2
50119: ARRAY
50120: PPUSH
50121: LD_INT 30
50123: PUSH
50124: LD_INT 32
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: PPUSH
50131: CALL_OW 72
50135: NOT
50136: AND
50137: PUSH
50138: LD_EXP 101
50142: PUSH
50143: LD_VAR 0 2
50147: ARRAY
50148: PPUSH
50149: LD_INT 2
50151: PUSH
50152: LD_INT 30
50154: PUSH
50155: LD_INT 4
50157: PUSH
50158: EMPTY
50159: LIST
50160: LIST
50161: PUSH
50162: LD_INT 30
50164: PUSH
50165: LD_INT 5
50167: PUSH
50168: EMPTY
50169: LIST
50170: LIST
50171: PUSH
50172: EMPTY
50173: LIST
50174: LIST
50175: LIST
50176: PPUSH
50177: CALL_OW 72
50181: NOT
50182: AND
50183: IFFALSE 50315
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50185: LD_ADDR_VAR 0 4
50189: PUSH
50190: LD_EXP 101
50194: PUSH
50195: LD_VAR 0 2
50199: ARRAY
50200: PPUSH
50201: LD_INT 2
50203: PUSH
50204: LD_INT 25
50206: PUSH
50207: LD_INT 1
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PUSH
50214: LD_INT 25
50216: PUSH
50217: LD_INT 5
50219: PUSH
50220: EMPTY
50221: LIST
50222: LIST
50223: PUSH
50224: LD_INT 25
50226: PUSH
50227: LD_INT 8
50229: PUSH
50230: EMPTY
50231: LIST
50232: LIST
50233: PUSH
50234: LD_INT 25
50236: PUSH
50237: LD_INT 9
50239: PUSH
50240: EMPTY
50241: LIST
50242: LIST
50243: PUSH
50244: EMPTY
50245: LIST
50246: LIST
50247: LIST
50248: LIST
50249: LIST
50250: PPUSH
50251: CALL_OW 72
50255: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50256: LD_ADDR_VAR 0 4
50260: PUSH
50261: LD_VAR 0 4
50265: PUSH
50266: LD_VAR 0 4
50270: PPUSH
50271: LD_INT 18
50273: PPUSH
50274: CALL 104700 0 2
50278: DIFF
50279: ST_TO_ADDR
// if tmp then
50280: LD_VAR 0 4
50284: IFFALSE 50315
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50286: LD_VAR 0 2
50290: PPUSH
50291: LD_VAR 0 4
50295: PPUSH
50296: LD_EXP 126
50300: PUSH
50301: LD_VAR 0 2
50305: ARRAY
50306: PPUSH
50307: CALL 65865 0 3
// exit ;
50311: POP
50312: POP
50313: GO 50388
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50315: LD_EXP 124
50319: PUSH
50320: LD_VAR 0 2
50324: ARRAY
50325: PUSH
50326: LD_EXP 123
50330: PUSH
50331: LD_VAR 0 2
50335: ARRAY
50336: AND
50337: IFFALSE 50384
// begin tmp := mc_defender [ i ] ;
50339: LD_ADDR_VAR 0 4
50343: PUSH
50344: LD_EXP 123
50348: PUSH
50349: LD_VAR 0 2
50353: ARRAY
50354: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50355: LD_VAR 0 2
50359: PPUSH
50360: LD_VAR 0 4
50364: PPUSH
50365: LD_EXP 124
50369: PUSH
50370: LD_VAR 0 2
50374: ARRAY
50375: PPUSH
50376: CALL 66426 0 3
// exit ;
50380: POP
50381: POP
50382: GO 50388
// end ; end ;
50384: GO 49821
50386: POP
50387: POP
// end ;
50388: LD_VAR 0 1
50392: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50393: LD_INT 0
50395: PPUSH
50396: PPUSH
50397: PPUSH
50398: PPUSH
50399: PPUSH
50400: PPUSH
50401: PPUSH
50402: PPUSH
50403: PPUSH
50404: PPUSH
50405: PPUSH
// if not mc_bases then
50406: LD_EXP 101
50410: NOT
50411: IFFALSE 50415
// exit ;
50413: GO 51502
// for i = 1 to mc_bases do
50415: LD_ADDR_VAR 0 2
50419: PUSH
50420: DOUBLE
50421: LD_INT 1
50423: DEC
50424: ST_TO_ADDR
50425: LD_EXP 101
50429: PUSH
50430: FOR_TO
50431: IFFALSE 51500
// begin tmp := mc_lab [ i ] ;
50433: LD_ADDR_VAR 0 6
50437: PUSH
50438: LD_EXP 134
50442: PUSH
50443: LD_VAR 0 2
50447: ARRAY
50448: ST_TO_ADDR
// if not tmp then
50449: LD_VAR 0 6
50453: NOT
50454: IFFALSE 50458
// continue ;
50456: GO 50430
// idle_lab := 0 ;
50458: LD_ADDR_VAR 0 11
50462: PUSH
50463: LD_INT 0
50465: ST_TO_ADDR
// for j in tmp do
50466: LD_ADDR_VAR 0 3
50470: PUSH
50471: LD_VAR 0 6
50475: PUSH
50476: FOR_IN
50477: IFFALSE 51496
// begin researching := false ;
50479: LD_ADDR_VAR 0 10
50483: PUSH
50484: LD_INT 0
50486: ST_TO_ADDR
// side := GetSide ( j ) ;
50487: LD_ADDR_VAR 0 4
50491: PUSH
50492: LD_VAR 0 3
50496: PPUSH
50497: CALL_OW 255
50501: ST_TO_ADDR
// if not mc_tech [ side ] then
50502: LD_EXP 128
50506: PUSH
50507: LD_VAR 0 4
50511: ARRAY
50512: NOT
50513: IFFALSE 50517
// continue ;
50515: GO 50476
// if BuildingStatus ( j ) = bs_idle then
50517: LD_VAR 0 3
50521: PPUSH
50522: CALL_OW 461
50526: PUSH
50527: LD_INT 2
50529: EQUAL
50530: IFFALSE 50718
// begin if idle_lab and UnitsInside ( j ) < 6 then
50532: LD_VAR 0 11
50536: PUSH
50537: LD_VAR 0 3
50541: PPUSH
50542: CALL_OW 313
50546: PUSH
50547: LD_INT 6
50549: LESS
50550: AND
50551: IFFALSE 50622
// begin tmp2 := UnitsInside ( idle_lab ) ;
50553: LD_ADDR_VAR 0 9
50557: PUSH
50558: LD_VAR 0 11
50562: PPUSH
50563: CALL_OW 313
50567: ST_TO_ADDR
// if tmp2 then
50568: LD_VAR 0 9
50572: IFFALSE 50614
// for x in tmp2 do
50574: LD_ADDR_VAR 0 7
50578: PUSH
50579: LD_VAR 0 9
50583: PUSH
50584: FOR_IN
50585: IFFALSE 50612
// begin ComExitBuilding ( x ) ;
50587: LD_VAR 0 7
50591: PPUSH
50592: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50596: LD_VAR 0 7
50600: PPUSH
50601: LD_VAR 0 3
50605: PPUSH
50606: CALL_OW 180
// end ;
50610: GO 50584
50612: POP
50613: POP
// idle_lab := 0 ;
50614: LD_ADDR_VAR 0 11
50618: PUSH
50619: LD_INT 0
50621: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50622: LD_ADDR_VAR 0 5
50626: PUSH
50627: LD_EXP 128
50631: PUSH
50632: LD_VAR 0 4
50636: ARRAY
50637: PUSH
50638: FOR_IN
50639: IFFALSE 50699
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50641: LD_VAR 0 3
50645: PPUSH
50646: LD_VAR 0 5
50650: PPUSH
50651: CALL_OW 430
50655: PUSH
50656: LD_VAR 0 4
50660: PPUSH
50661: LD_VAR 0 5
50665: PPUSH
50666: CALL 64935 0 2
50670: AND
50671: IFFALSE 50697
// begin researching := true ;
50673: LD_ADDR_VAR 0 10
50677: PUSH
50678: LD_INT 1
50680: ST_TO_ADDR
// ComResearch ( j , t ) ;
50681: LD_VAR 0 3
50685: PPUSH
50686: LD_VAR 0 5
50690: PPUSH
50691: CALL_OW 124
// break ;
50695: GO 50699
// end ;
50697: GO 50638
50699: POP
50700: POP
// if not researching then
50701: LD_VAR 0 10
50705: NOT
50706: IFFALSE 50718
// idle_lab := j ;
50708: LD_ADDR_VAR 0 11
50712: PUSH
50713: LD_VAR 0 3
50717: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50718: LD_VAR 0 3
50722: PPUSH
50723: CALL_OW 461
50727: PUSH
50728: LD_INT 10
50730: EQUAL
50731: IFFALSE 51319
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50733: LD_EXP 130
50737: PUSH
50738: LD_VAR 0 2
50742: ARRAY
50743: NOT
50744: PUSH
50745: LD_EXP 131
50749: PUSH
50750: LD_VAR 0 2
50754: ARRAY
50755: NOT
50756: AND
50757: PUSH
50758: LD_EXP 128
50762: PUSH
50763: LD_VAR 0 4
50767: ARRAY
50768: PUSH
50769: LD_INT 1
50771: GREATER
50772: AND
50773: IFFALSE 50904
// begin ComCancel ( j ) ;
50775: LD_VAR 0 3
50779: PPUSH
50780: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50784: LD_ADDR_EXP 128
50788: PUSH
50789: LD_EXP 128
50793: PPUSH
50794: LD_VAR 0 4
50798: PPUSH
50799: LD_EXP 128
50803: PUSH
50804: LD_VAR 0 4
50808: ARRAY
50809: PPUSH
50810: LD_EXP 128
50814: PUSH
50815: LD_VAR 0 4
50819: ARRAY
50820: PUSH
50821: LD_INT 1
50823: MINUS
50824: PPUSH
50825: LD_EXP 128
50829: PUSH
50830: LD_VAR 0 4
50834: ARRAY
50835: PPUSH
50836: LD_INT 0
50838: PPUSH
50839: CALL 70858 0 4
50843: PPUSH
50844: CALL_OW 1
50848: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50849: LD_ADDR_EXP 128
50853: PUSH
50854: LD_EXP 128
50858: PPUSH
50859: LD_VAR 0 4
50863: PPUSH
50864: LD_EXP 128
50868: PUSH
50869: LD_VAR 0 4
50873: ARRAY
50874: PPUSH
50875: LD_EXP 128
50879: PUSH
50880: LD_VAR 0 4
50884: ARRAY
50885: PPUSH
50886: LD_INT 1
50888: PPUSH
50889: LD_INT 0
50891: PPUSH
50892: CALL 70858 0 4
50896: PPUSH
50897: CALL_OW 1
50901: ST_TO_ADDR
// continue ;
50902: GO 50476
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50904: LD_EXP 130
50908: PUSH
50909: LD_VAR 0 2
50913: ARRAY
50914: PUSH
50915: LD_EXP 131
50919: PUSH
50920: LD_VAR 0 2
50924: ARRAY
50925: NOT
50926: AND
50927: IFFALSE 51054
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50929: LD_ADDR_EXP 131
50933: PUSH
50934: LD_EXP 131
50938: PPUSH
50939: LD_VAR 0 2
50943: PUSH
50944: LD_EXP 131
50948: PUSH
50949: LD_VAR 0 2
50953: ARRAY
50954: PUSH
50955: LD_INT 1
50957: PLUS
50958: PUSH
50959: EMPTY
50960: LIST
50961: LIST
50962: PPUSH
50963: LD_EXP 130
50967: PUSH
50968: LD_VAR 0 2
50972: ARRAY
50973: PUSH
50974: LD_INT 1
50976: ARRAY
50977: PPUSH
50978: CALL 71440 0 3
50982: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50983: LD_EXP 130
50987: PUSH
50988: LD_VAR 0 2
50992: ARRAY
50993: PUSH
50994: LD_INT 1
50996: ARRAY
50997: PPUSH
50998: LD_INT 112
51000: PPUSH
51001: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51005: LD_ADDR_VAR 0 9
51009: PUSH
51010: LD_EXP 130
51014: PUSH
51015: LD_VAR 0 2
51019: ARRAY
51020: PPUSH
51021: LD_INT 1
51023: PPUSH
51024: CALL_OW 3
51028: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51029: LD_ADDR_EXP 130
51033: PUSH
51034: LD_EXP 130
51038: PPUSH
51039: LD_VAR 0 2
51043: PPUSH
51044: LD_VAR 0 9
51048: PPUSH
51049: CALL_OW 1
51053: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51054: LD_EXP 130
51058: PUSH
51059: LD_VAR 0 2
51063: ARRAY
51064: PUSH
51065: LD_EXP 131
51069: PUSH
51070: LD_VAR 0 2
51074: ARRAY
51075: AND
51076: PUSH
51077: LD_EXP 131
51081: PUSH
51082: LD_VAR 0 2
51086: ARRAY
51087: PUSH
51088: LD_INT 1
51090: ARRAY
51091: PPUSH
51092: CALL_OW 310
51096: NOT
51097: AND
51098: PUSH
51099: LD_VAR 0 3
51103: PPUSH
51104: CALL_OW 313
51108: PUSH
51109: LD_INT 6
51111: EQUAL
51112: AND
51113: IFFALSE 51169
// begin tmp2 := UnitsInside ( j ) ;
51115: LD_ADDR_VAR 0 9
51119: PUSH
51120: LD_VAR 0 3
51124: PPUSH
51125: CALL_OW 313
51129: ST_TO_ADDR
// if tmp2 = 6 then
51130: LD_VAR 0 9
51134: PUSH
51135: LD_INT 6
51137: EQUAL
51138: IFFALSE 51169
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51140: LD_VAR 0 9
51144: PUSH
51145: LD_INT 1
51147: ARRAY
51148: PPUSH
51149: LD_INT 112
51151: PPUSH
51152: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51156: LD_VAR 0 9
51160: PUSH
51161: LD_INT 1
51163: ARRAY
51164: PPUSH
51165: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51169: LD_EXP 131
51173: PUSH
51174: LD_VAR 0 2
51178: ARRAY
51179: PUSH
51180: LD_EXP 131
51184: PUSH
51185: LD_VAR 0 2
51189: ARRAY
51190: PUSH
51191: LD_INT 1
51193: ARRAY
51194: PPUSH
51195: CALL_OW 314
51199: NOT
51200: AND
51201: PUSH
51202: LD_EXP 131
51206: PUSH
51207: LD_VAR 0 2
51211: ARRAY
51212: PUSH
51213: LD_INT 1
51215: ARRAY
51216: PPUSH
51217: CALL_OW 310
51221: NOT
51222: AND
51223: IFFALSE 51249
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51225: LD_EXP 131
51229: PUSH
51230: LD_VAR 0 2
51234: ARRAY
51235: PUSH
51236: LD_INT 1
51238: ARRAY
51239: PPUSH
51240: LD_VAR 0 3
51244: PPUSH
51245: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51249: LD_EXP 131
51253: PUSH
51254: LD_VAR 0 2
51258: ARRAY
51259: PUSH
51260: LD_INT 1
51262: ARRAY
51263: PPUSH
51264: CALL_OW 310
51268: PUSH
51269: LD_EXP 131
51273: PUSH
51274: LD_VAR 0 2
51278: ARRAY
51279: PUSH
51280: LD_INT 1
51282: ARRAY
51283: PPUSH
51284: CALL_OW 310
51288: PPUSH
51289: CALL_OW 461
51293: PUSH
51294: LD_INT 3
51296: NONEQUAL
51297: AND
51298: IFFALSE 51319
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51300: LD_EXP 131
51304: PUSH
51305: LD_VAR 0 2
51309: ARRAY
51310: PUSH
51311: LD_INT 1
51313: ARRAY
51314: PPUSH
51315: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51319: LD_VAR 0 3
51323: PPUSH
51324: CALL_OW 461
51328: PUSH
51329: LD_INT 6
51331: EQUAL
51332: PUSH
51333: LD_VAR 0 6
51337: PUSH
51338: LD_INT 1
51340: GREATER
51341: AND
51342: IFFALSE 51494
// begin sci := [ ] ;
51344: LD_ADDR_VAR 0 8
51348: PUSH
51349: EMPTY
51350: ST_TO_ADDR
// for x in ( tmp diff j ) do
51351: LD_ADDR_VAR 0 7
51355: PUSH
51356: LD_VAR 0 6
51360: PUSH
51361: LD_VAR 0 3
51365: DIFF
51366: PUSH
51367: FOR_IN
51368: IFFALSE 51420
// begin if sci = 6 then
51370: LD_VAR 0 8
51374: PUSH
51375: LD_INT 6
51377: EQUAL
51378: IFFALSE 51382
// break ;
51380: GO 51420
// if BuildingStatus ( x ) = bs_idle then
51382: LD_VAR 0 7
51386: PPUSH
51387: CALL_OW 461
51391: PUSH
51392: LD_INT 2
51394: EQUAL
51395: IFFALSE 51418
// sci := sci ^ UnitsInside ( x ) ;
51397: LD_ADDR_VAR 0 8
51401: PUSH
51402: LD_VAR 0 8
51406: PUSH
51407: LD_VAR 0 7
51411: PPUSH
51412: CALL_OW 313
51416: ADD
51417: ST_TO_ADDR
// end ;
51418: GO 51367
51420: POP
51421: POP
// if not sci then
51422: LD_VAR 0 8
51426: NOT
51427: IFFALSE 51431
// continue ;
51429: GO 50476
// for x in sci do
51431: LD_ADDR_VAR 0 7
51435: PUSH
51436: LD_VAR 0 8
51440: PUSH
51441: FOR_IN
51442: IFFALSE 51492
// if IsInUnit ( x ) and not HasTask ( x ) then
51444: LD_VAR 0 7
51448: PPUSH
51449: CALL_OW 310
51453: PUSH
51454: LD_VAR 0 7
51458: PPUSH
51459: CALL_OW 314
51463: NOT
51464: AND
51465: IFFALSE 51490
// begin ComExitBuilding ( x ) ;
51467: LD_VAR 0 7
51471: PPUSH
51472: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51476: LD_VAR 0 7
51480: PPUSH
51481: LD_VAR 0 3
51485: PPUSH
51486: CALL_OW 180
// end ;
51490: GO 51441
51492: POP
51493: POP
// end ; end ;
51494: GO 50476
51496: POP
51497: POP
// end ;
51498: GO 50430
51500: POP
51501: POP
// end ;
51502: LD_VAR 0 1
51506: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51507: LD_INT 0
51509: PPUSH
51510: PPUSH
// if not mc_bases then
51511: LD_EXP 101
51515: NOT
51516: IFFALSE 51520
// exit ;
51518: GO 51601
// for i = 1 to mc_bases do
51520: LD_ADDR_VAR 0 2
51524: PUSH
51525: DOUBLE
51526: LD_INT 1
51528: DEC
51529: ST_TO_ADDR
51530: LD_EXP 101
51534: PUSH
51535: FOR_TO
51536: IFFALSE 51599
// if mc_mines [ i ] and mc_miners [ i ] then
51538: LD_EXP 114
51542: PUSH
51543: LD_VAR 0 2
51547: ARRAY
51548: PUSH
51549: LD_EXP 115
51553: PUSH
51554: LD_VAR 0 2
51558: ARRAY
51559: AND
51560: IFFALSE 51597
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51562: LD_EXP 115
51566: PUSH
51567: LD_VAR 0 2
51571: ARRAY
51572: PUSH
51573: LD_INT 1
51575: ARRAY
51576: PPUSH
51577: CALL_OW 255
51581: PPUSH
51582: LD_EXP 114
51586: PUSH
51587: LD_VAR 0 2
51591: ARRAY
51592: PPUSH
51593: CALL 68429 0 2
51597: GO 51535
51599: POP
51600: POP
// end ;
51601: LD_VAR 0 1
51605: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51606: LD_INT 0
51608: PPUSH
51609: PPUSH
51610: PPUSH
51611: PPUSH
51612: PPUSH
51613: PPUSH
51614: PPUSH
51615: PPUSH
// if not mc_bases or not mc_parking then
51616: LD_EXP 101
51620: NOT
51621: PUSH
51622: LD_EXP 125
51626: NOT
51627: OR
51628: IFFALSE 51632
// exit ;
51630: GO 52331
// for i = 1 to mc_bases do
51632: LD_ADDR_VAR 0 2
51636: PUSH
51637: DOUBLE
51638: LD_INT 1
51640: DEC
51641: ST_TO_ADDR
51642: LD_EXP 101
51646: PUSH
51647: FOR_TO
51648: IFFALSE 52329
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51650: LD_EXP 101
51654: PUSH
51655: LD_VAR 0 2
51659: ARRAY
51660: NOT
51661: PUSH
51662: LD_EXP 125
51666: PUSH
51667: LD_VAR 0 2
51671: ARRAY
51672: NOT
51673: OR
51674: IFFALSE 51678
// continue ;
51676: GO 51647
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51678: LD_ADDR_VAR 0 5
51682: PUSH
51683: LD_EXP 101
51687: PUSH
51688: LD_VAR 0 2
51692: ARRAY
51693: PUSH
51694: LD_INT 1
51696: ARRAY
51697: PPUSH
51698: CALL_OW 255
51702: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51703: LD_ADDR_VAR 0 6
51707: PUSH
51708: LD_EXP 101
51712: PUSH
51713: LD_VAR 0 2
51717: ARRAY
51718: PPUSH
51719: LD_INT 30
51721: PUSH
51722: LD_INT 3
51724: PUSH
51725: EMPTY
51726: LIST
51727: LIST
51728: PPUSH
51729: CALL_OW 72
51733: ST_TO_ADDR
// if not fac then
51734: LD_VAR 0 6
51738: NOT
51739: IFFALSE 51790
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51741: LD_ADDR_VAR 0 6
51745: PUSH
51746: LD_EXP 101
51750: PUSH
51751: LD_VAR 0 2
51755: ARRAY
51756: PPUSH
51757: LD_INT 2
51759: PUSH
51760: LD_INT 30
51762: PUSH
51763: LD_INT 0
51765: PUSH
51766: EMPTY
51767: LIST
51768: LIST
51769: PUSH
51770: LD_INT 30
51772: PUSH
51773: LD_INT 1
51775: PUSH
51776: EMPTY
51777: LIST
51778: LIST
51779: PUSH
51780: EMPTY
51781: LIST
51782: LIST
51783: LIST
51784: PPUSH
51785: CALL_OW 72
51789: ST_TO_ADDR
// if not fac then
51790: LD_VAR 0 6
51794: NOT
51795: IFFALSE 51799
// continue ;
51797: GO 51647
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51799: LD_ADDR_VAR 0 7
51803: PUSH
51804: LD_EXP 125
51808: PUSH
51809: LD_VAR 0 2
51813: ARRAY
51814: PPUSH
51815: LD_INT 22
51817: PUSH
51818: LD_VAR 0 5
51822: PUSH
51823: EMPTY
51824: LIST
51825: LIST
51826: PUSH
51827: LD_INT 21
51829: PUSH
51830: LD_INT 2
51832: PUSH
51833: EMPTY
51834: LIST
51835: LIST
51836: PUSH
51837: LD_INT 3
51839: PUSH
51840: LD_INT 24
51842: PUSH
51843: LD_INT 1000
51845: PUSH
51846: EMPTY
51847: LIST
51848: LIST
51849: PUSH
51850: EMPTY
51851: LIST
51852: LIST
51853: PUSH
51854: EMPTY
51855: LIST
51856: LIST
51857: LIST
51858: PPUSH
51859: CALL_OW 70
51863: ST_TO_ADDR
// for j in fac do
51864: LD_ADDR_VAR 0 3
51868: PUSH
51869: LD_VAR 0 6
51873: PUSH
51874: FOR_IN
51875: IFFALSE 51956
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51877: LD_ADDR_VAR 0 7
51881: PUSH
51882: LD_VAR 0 7
51886: PUSH
51887: LD_INT 22
51889: PUSH
51890: LD_VAR 0 5
51894: PUSH
51895: EMPTY
51896: LIST
51897: LIST
51898: PUSH
51899: LD_INT 91
51901: PUSH
51902: LD_VAR 0 3
51906: PUSH
51907: LD_INT 15
51909: PUSH
51910: EMPTY
51911: LIST
51912: LIST
51913: LIST
51914: PUSH
51915: LD_INT 21
51917: PUSH
51918: LD_INT 2
51920: PUSH
51921: EMPTY
51922: LIST
51923: LIST
51924: PUSH
51925: LD_INT 3
51927: PUSH
51928: LD_INT 24
51930: PUSH
51931: LD_INT 1000
51933: PUSH
51934: EMPTY
51935: LIST
51936: LIST
51937: PUSH
51938: EMPTY
51939: LIST
51940: LIST
51941: PUSH
51942: EMPTY
51943: LIST
51944: LIST
51945: LIST
51946: LIST
51947: PPUSH
51948: CALL_OW 69
51952: UNION
51953: ST_TO_ADDR
51954: GO 51874
51956: POP
51957: POP
// if not vehs then
51958: LD_VAR 0 7
51962: NOT
51963: IFFALSE 51989
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51965: LD_ADDR_EXP 113
51969: PUSH
51970: LD_EXP 113
51974: PPUSH
51975: LD_VAR 0 2
51979: PPUSH
51980: EMPTY
51981: PPUSH
51982: CALL_OW 1
51986: ST_TO_ADDR
// continue ;
51987: GO 51647
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51989: LD_ADDR_VAR 0 8
51993: PUSH
51994: LD_EXP 101
51998: PUSH
51999: LD_VAR 0 2
52003: ARRAY
52004: PPUSH
52005: LD_INT 30
52007: PUSH
52008: LD_INT 3
52010: PUSH
52011: EMPTY
52012: LIST
52013: LIST
52014: PPUSH
52015: CALL_OW 72
52019: ST_TO_ADDR
// if tmp then
52020: LD_VAR 0 8
52024: IFFALSE 52127
// begin for j in tmp do
52026: LD_ADDR_VAR 0 3
52030: PUSH
52031: LD_VAR 0 8
52035: PUSH
52036: FOR_IN
52037: IFFALSE 52125
// for k in UnitsInside ( j ) do
52039: LD_ADDR_VAR 0 4
52043: PUSH
52044: LD_VAR 0 3
52048: PPUSH
52049: CALL_OW 313
52053: PUSH
52054: FOR_IN
52055: IFFALSE 52121
// if k then
52057: LD_VAR 0 4
52061: IFFALSE 52119
// if not k in mc_repair_vehicle [ i ] then
52063: LD_VAR 0 4
52067: PUSH
52068: LD_EXP 113
52072: PUSH
52073: LD_VAR 0 2
52077: ARRAY
52078: IN
52079: NOT
52080: IFFALSE 52119
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52082: LD_ADDR_EXP 113
52086: PUSH
52087: LD_EXP 113
52091: PPUSH
52092: LD_VAR 0 2
52096: PPUSH
52097: LD_EXP 113
52101: PUSH
52102: LD_VAR 0 2
52106: ARRAY
52107: PUSH
52108: LD_VAR 0 4
52112: UNION
52113: PPUSH
52114: CALL_OW 1
52118: ST_TO_ADDR
52119: GO 52054
52121: POP
52122: POP
52123: GO 52036
52125: POP
52126: POP
// end ; if not mc_repair_vehicle [ i ] then
52127: LD_EXP 113
52131: PUSH
52132: LD_VAR 0 2
52136: ARRAY
52137: NOT
52138: IFFALSE 52142
// continue ;
52140: GO 51647
// for j in mc_repair_vehicle [ i ] do
52142: LD_ADDR_VAR 0 3
52146: PUSH
52147: LD_EXP 113
52151: PUSH
52152: LD_VAR 0 2
52156: ARRAY
52157: PUSH
52158: FOR_IN
52159: IFFALSE 52325
// begin if GetClass ( j ) <> 3 then
52161: LD_VAR 0 3
52165: PPUSH
52166: CALL_OW 257
52170: PUSH
52171: LD_INT 3
52173: NONEQUAL
52174: IFFALSE 52215
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52176: LD_ADDR_EXP 113
52180: PUSH
52181: LD_EXP 113
52185: PPUSH
52186: LD_VAR 0 2
52190: PPUSH
52191: LD_EXP 113
52195: PUSH
52196: LD_VAR 0 2
52200: ARRAY
52201: PUSH
52202: LD_VAR 0 3
52206: DIFF
52207: PPUSH
52208: CALL_OW 1
52212: ST_TO_ADDR
// continue ;
52213: GO 52158
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52215: LD_VAR 0 3
52219: PPUSH
52220: CALL_OW 311
52224: NOT
52225: PUSH
52226: LD_VAR 0 3
52230: PUSH
52231: LD_EXP 104
52235: PUSH
52236: LD_VAR 0 2
52240: ARRAY
52241: PUSH
52242: LD_INT 1
52244: ARRAY
52245: IN
52246: NOT
52247: AND
52248: PUSH
52249: LD_VAR 0 3
52253: PUSH
52254: LD_EXP 104
52258: PUSH
52259: LD_VAR 0 2
52263: ARRAY
52264: PUSH
52265: LD_INT 2
52267: ARRAY
52268: IN
52269: NOT
52270: AND
52271: IFFALSE 52323
// begin if IsInUnit ( j ) then
52273: LD_VAR 0 3
52277: PPUSH
52278: CALL_OW 310
52282: IFFALSE 52293
// ComExitBuilding ( j ) ;
52284: LD_VAR 0 3
52288: PPUSH
52289: CALL_OW 122
// if not HasTask ( j ) then
52293: LD_VAR 0 3
52297: PPUSH
52298: CALL_OW 314
52302: NOT
52303: IFFALSE 52323
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52305: LD_VAR 0 3
52309: PPUSH
52310: LD_VAR 0 7
52314: PUSH
52315: LD_INT 1
52317: ARRAY
52318: PPUSH
52319: CALL_OW 189
// end ; end ;
52323: GO 52158
52325: POP
52326: POP
// end ;
52327: GO 51647
52329: POP
52330: POP
// end ;
52331: LD_VAR 0 1
52335: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52336: LD_INT 0
52338: PPUSH
52339: PPUSH
52340: PPUSH
52341: PPUSH
52342: PPUSH
52343: PPUSH
52344: PPUSH
52345: PPUSH
52346: PPUSH
52347: PPUSH
52348: PPUSH
// if not mc_bases then
52349: LD_EXP 101
52353: NOT
52354: IFFALSE 52358
// exit ;
52356: GO 53160
// for i = 1 to mc_bases do
52358: LD_ADDR_VAR 0 2
52362: PUSH
52363: DOUBLE
52364: LD_INT 1
52366: DEC
52367: ST_TO_ADDR
52368: LD_EXP 101
52372: PUSH
52373: FOR_TO
52374: IFFALSE 53158
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52376: LD_EXP 129
52380: PUSH
52381: LD_VAR 0 2
52385: ARRAY
52386: NOT
52387: PUSH
52388: LD_EXP 104
52392: PUSH
52393: LD_VAR 0 2
52397: ARRAY
52398: PUSH
52399: LD_INT 1
52401: ARRAY
52402: OR
52403: PUSH
52404: LD_EXP 104
52408: PUSH
52409: LD_VAR 0 2
52413: ARRAY
52414: PUSH
52415: LD_INT 2
52417: ARRAY
52418: OR
52419: PUSH
52420: LD_EXP 127
52424: PUSH
52425: LD_VAR 0 2
52429: ARRAY
52430: PPUSH
52431: LD_INT 1
52433: PPUSH
52434: CALL_OW 325
52438: NOT
52439: OR
52440: PUSH
52441: LD_EXP 124
52445: PUSH
52446: LD_VAR 0 2
52450: ARRAY
52451: OR
52452: IFFALSE 52456
// continue ;
52454: GO 52373
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52456: LD_ADDR_VAR 0 8
52460: PUSH
52461: LD_EXP 101
52465: PUSH
52466: LD_VAR 0 2
52470: ARRAY
52471: PPUSH
52472: LD_INT 25
52474: PUSH
52475: LD_INT 4
52477: PUSH
52478: EMPTY
52479: LIST
52480: LIST
52481: PUSH
52482: LD_INT 50
52484: PUSH
52485: EMPTY
52486: LIST
52487: PUSH
52488: LD_INT 3
52490: PUSH
52491: LD_INT 60
52493: PUSH
52494: EMPTY
52495: LIST
52496: PUSH
52497: EMPTY
52498: LIST
52499: LIST
52500: PUSH
52501: EMPTY
52502: LIST
52503: LIST
52504: LIST
52505: PPUSH
52506: CALL_OW 72
52510: PUSH
52511: LD_EXP 105
52515: PUSH
52516: LD_VAR 0 2
52520: ARRAY
52521: DIFF
52522: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52523: LD_ADDR_VAR 0 9
52527: PUSH
52528: LD_EXP 101
52532: PUSH
52533: LD_VAR 0 2
52537: ARRAY
52538: PPUSH
52539: LD_INT 2
52541: PUSH
52542: LD_INT 30
52544: PUSH
52545: LD_INT 0
52547: PUSH
52548: EMPTY
52549: LIST
52550: LIST
52551: PUSH
52552: LD_INT 30
52554: PUSH
52555: LD_INT 1
52557: PUSH
52558: EMPTY
52559: LIST
52560: LIST
52561: PUSH
52562: EMPTY
52563: LIST
52564: LIST
52565: LIST
52566: PPUSH
52567: CALL_OW 72
52571: ST_TO_ADDR
// if not tmp or not dep then
52572: LD_VAR 0 8
52576: NOT
52577: PUSH
52578: LD_VAR 0 9
52582: NOT
52583: OR
52584: IFFALSE 52588
// continue ;
52586: GO 52373
// side := GetSide ( tmp [ 1 ] ) ;
52588: LD_ADDR_VAR 0 11
52592: PUSH
52593: LD_VAR 0 8
52597: PUSH
52598: LD_INT 1
52600: ARRAY
52601: PPUSH
52602: CALL_OW 255
52606: ST_TO_ADDR
// dep := dep [ 1 ] ;
52607: LD_ADDR_VAR 0 9
52611: PUSH
52612: LD_VAR 0 9
52616: PUSH
52617: LD_INT 1
52619: ARRAY
52620: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52621: LD_ADDR_VAR 0 7
52625: PUSH
52626: LD_EXP 129
52630: PUSH
52631: LD_VAR 0 2
52635: ARRAY
52636: PPUSH
52637: LD_INT 22
52639: PUSH
52640: LD_INT 0
52642: PUSH
52643: EMPTY
52644: LIST
52645: LIST
52646: PUSH
52647: LD_INT 25
52649: PUSH
52650: LD_INT 12
52652: PUSH
52653: EMPTY
52654: LIST
52655: LIST
52656: PUSH
52657: EMPTY
52658: LIST
52659: LIST
52660: PPUSH
52661: CALL_OW 70
52665: PUSH
52666: LD_INT 22
52668: PUSH
52669: LD_INT 0
52671: PUSH
52672: EMPTY
52673: LIST
52674: LIST
52675: PUSH
52676: LD_INT 25
52678: PUSH
52679: LD_INT 12
52681: PUSH
52682: EMPTY
52683: LIST
52684: LIST
52685: PUSH
52686: LD_INT 91
52688: PUSH
52689: LD_VAR 0 9
52693: PUSH
52694: LD_INT 20
52696: PUSH
52697: EMPTY
52698: LIST
52699: LIST
52700: LIST
52701: PUSH
52702: EMPTY
52703: LIST
52704: LIST
52705: LIST
52706: PPUSH
52707: CALL_OW 69
52711: UNION
52712: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52713: LD_ADDR_VAR 0 10
52717: PUSH
52718: LD_EXP 129
52722: PUSH
52723: LD_VAR 0 2
52727: ARRAY
52728: PPUSH
52729: LD_INT 81
52731: PUSH
52732: LD_VAR 0 11
52736: PUSH
52737: EMPTY
52738: LIST
52739: LIST
52740: PPUSH
52741: CALL_OW 70
52745: ST_TO_ADDR
// if not apes or danger_at_area then
52746: LD_VAR 0 7
52750: NOT
52751: PUSH
52752: LD_VAR 0 10
52756: OR
52757: IFFALSE 52807
// begin if mc_taming [ i ] then
52759: LD_EXP 132
52763: PUSH
52764: LD_VAR 0 2
52768: ARRAY
52769: IFFALSE 52805
// begin MC_Reset ( i , 121 ) ;
52771: LD_VAR 0 2
52775: PPUSH
52776: LD_INT 121
52778: PPUSH
52779: CALL 38138 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52783: LD_ADDR_EXP 132
52787: PUSH
52788: LD_EXP 132
52792: PPUSH
52793: LD_VAR 0 2
52797: PPUSH
52798: EMPTY
52799: PPUSH
52800: CALL_OW 1
52804: ST_TO_ADDR
// end ; continue ;
52805: GO 52373
// end ; for j in tmp do
52807: LD_ADDR_VAR 0 3
52811: PUSH
52812: LD_VAR 0 8
52816: PUSH
52817: FOR_IN
52818: IFFALSE 53154
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52820: LD_VAR 0 3
52824: PUSH
52825: LD_EXP 132
52829: PUSH
52830: LD_VAR 0 2
52834: ARRAY
52835: IN
52836: NOT
52837: PUSH
52838: LD_EXP 132
52842: PUSH
52843: LD_VAR 0 2
52847: ARRAY
52848: PUSH
52849: LD_INT 3
52851: LESS
52852: AND
52853: IFFALSE 52911
// begin SetTag ( j , 121 ) ;
52855: LD_VAR 0 3
52859: PPUSH
52860: LD_INT 121
52862: PPUSH
52863: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52867: LD_ADDR_EXP 132
52871: PUSH
52872: LD_EXP 132
52876: PPUSH
52877: LD_VAR 0 2
52881: PUSH
52882: LD_EXP 132
52886: PUSH
52887: LD_VAR 0 2
52891: ARRAY
52892: PUSH
52893: LD_INT 1
52895: PLUS
52896: PUSH
52897: EMPTY
52898: LIST
52899: LIST
52900: PPUSH
52901: LD_VAR 0 3
52905: PPUSH
52906: CALL 71440 0 3
52910: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52911: LD_VAR 0 3
52915: PUSH
52916: LD_EXP 132
52920: PUSH
52921: LD_VAR 0 2
52925: ARRAY
52926: IN
52927: IFFALSE 53152
// begin if GetClass ( j ) <> 4 then
52929: LD_VAR 0 3
52933: PPUSH
52934: CALL_OW 257
52938: PUSH
52939: LD_INT 4
52941: NONEQUAL
52942: IFFALSE 52995
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52944: LD_ADDR_EXP 132
52948: PUSH
52949: LD_EXP 132
52953: PPUSH
52954: LD_VAR 0 2
52958: PPUSH
52959: LD_EXP 132
52963: PUSH
52964: LD_VAR 0 2
52968: ARRAY
52969: PUSH
52970: LD_VAR 0 3
52974: DIFF
52975: PPUSH
52976: CALL_OW 1
52980: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52981: LD_VAR 0 3
52985: PPUSH
52986: LD_INT 0
52988: PPUSH
52989: CALL_OW 109
// continue ;
52993: GO 52817
// end ; if IsInUnit ( j ) then
52995: LD_VAR 0 3
52999: PPUSH
53000: CALL_OW 310
53004: IFFALSE 53015
// ComExitBuilding ( j ) ;
53006: LD_VAR 0 3
53010: PPUSH
53011: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53015: LD_ADDR_VAR 0 6
53019: PUSH
53020: LD_VAR 0 7
53024: PPUSH
53025: LD_VAR 0 3
53029: PPUSH
53030: CALL_OW 74
53034: ST_TO_ADDR
// if not ape then
53035: LD_VAR 0 6
53039: NOT
53040: IFFALSE 53044
// break ;
53042: GO 53154
// x := GetX ( ape ) ;
53044: LD_ADDR_VAR 0 4
53048: PUSH
53049: LD_VAR 0 6
53053: PPUSH
53054: CALL_OW 250
53058: ST_TO_ADDR
// y := GetY ( ape ) ;
53059: LD_ADDR_VAR 0 5
53063: PUSH
53064: LD_VAR 0 6
53068: PPUSH
53069: CALL_OW 251
53073: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53074: LD_VAR 0 4
53078: PPUSH
53079: LD_VAR 0 5
53083: PPUSH
53084: CALL_OW 488
53088: NOT
53089: PUSH
53090: LD_VAR 0 11
53094: PPUSH
53095: LD_VAR 0 4
53099: PPUSH
53100: LD_VAR 0 5
53104: PPUSH
53105: LD_INT 20
53107: PPUSH
53108: CALL 72336 0 4
53112: PUSH
53113: LD_INT 4
53115: ARRAY
53116: OR
53117: IFFALSE 53121
// break ;
53119: GO 53154
// if not HasTask ( j ) then
53121: LD_VAR 0 3
53125: PPUSH
53126: CALL_OW 314
53130: NOT
53131: IFFALSE 53152
// ComTameXY ( j , x , y ) ;
53133: LD_VAR 0 3
53137: PPUSH
53138: LD_VAR 0 4
53142: PPUSH
53143: LD_VAR 0 5
53147: PPUSH
53148: CALL_OW 131
// end ; end ;
53152: GO 52817
53154: POP
53155: POP
// end ;
53156: GO 52373
53158: POP
53159: POP
// end ;
53160: LD_VAR 0 1
53164: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53165: LD_INT 0
53167: PPUSH
53168: PPUSH
53169: PPUSH
53170: PPUSH
53171: PPUSH
53172: PPUSH
53173: PPUSH
53174: PPUSH
// if not mc_bases then
53175: LD_EXP 101
53179: NOT
53180: IFFALSE 53184
// exit ;
53182: GO 53810
// for i = 1 to mc_bases do
53184: LD_ADDR_VAR 0 2
53188: PUSH
53189: DOUBLE
53190: LD_INT 1
53192: DEC
53193: ST_TO_ADDR
53194: LD_EXP 101
53198: PUSH
53199: FOR_TO
53200: IFFALSE 53808
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53202: LD_EXP 130
53206: PUSH
53207: LD_VAR 0 2
53211: ARRAY
53212: NOT
53213: PUSH
53214: LD_EXP 130
53218: PUSH
53219: LD_VAR 0 2
53223: ARRAY
53224: PPUSH
53225: LD_INT 25
53227: PUSH
53228: LD_INT 12
53230: PUSH
53231: EMPTY
53232: LIST
53233: LIST
53234: PPUSH
53235: CALL_OW 72
53239: NOT
53240: OR
53241: IFFALSE 53245
// continue ;
53243: GO 53199
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53245: LD_ADDR_VAR 0 5
53249: PUSH
53250: LD_EXP 130
53254: PUSH
53255: LD_VAR 0 2
53259: ARRAY
53260: PUSH
53261: LD_INT 1
53263: ARRAY
53264: PPUSH
53265: CALL_OW 255
53269: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53270: LD_VAR 0 5
53274: PPUSH
53275: LD_INT 2
53277: PPUSH
53278: CALL_OW 325
53282: IFFALSE 53535
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53284: LD_ADDR_VAR 0 4
53288: PUSH
53289: LD_EXP 130
53293: PUSH
53294: LD_VAR 0 2
53298: ARRAY
53299: PPUSH
53300: LD_INT 25
53302: PUSH
53303: LD_INT 16
53305: PUSH
53306: EMPTY
53307: LIST
53308: LIST
53309: PPUSH
53310: CALL_OW 72
53314: ST_TO_ADDR
// if tmp < 6 then
53315: LD_VAR 0 4
53319: PUSH
53320: LD_INT 6
53322: LESS
53323: IFFALSE 53535
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53325: LD_ADDR_VAR 0 6
53329: PUSH
53330: LD_EXP 101
53334: PUSH
53335: LD_VAR 0 2
53339: ARRAY
53340: PPUSH
53341: LD_INT 2
53343: PUSH
53344: LD_INT 30
53346: PUSH
53347: LD_INT 0
53349: PUSH
53350: EMPTY
53351: LIST
53352: LIST
53353: PUSH
53354: LD_INT 30
53356: PUSH
53357: LD_INT 1
53359: PUSH
53360: EMPTY
53361: LIST
53362: LIST
53363: PUSH
53364: EMPTY
53365: LIST
53366: LIST
53367: LIST
53368: PPUSH
53369: CALL_OW 72
53373: ST_TO_ADDR
// if depot then
53374: LD_VAR 0 6
53378: IFFALSE 53535
// begin selected := 0 ;
53380: LD_ADDR_VAR 0 7
53384: PUSH
53385: LD_INT 0
53387: ST_TO_ADDR
// for j in depot do
53388: LD_ADDR_VAR 0 3
53392: PUSH
53393: LD_VAR 0 6
53397: PUSH
53398: FOR_IN
53399: IFFALSE 53430
// begin if UnitsInside ( j ) < 6 then
53401: LD_VAR 0 3
53405: PPUSH
53406: CALL_OW 313
53410: PUSH
53411: LD_INT 6
53413: LESS
53414: IFFALSE 53428
// begin selected := j ;
53416: LD_ADDR_VAR 0 7
53420: PUSH
53421: LD_VAR 0 3
53425: ST_TO_ADDR
// break ;
53426: GO 53430
// end ; end ;
53428: GO 53398
53430: POP
53431: POP
// if selected then
53432: LD_VAR 0 7
53436: IFFALSE 53535
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53438: LD_ADDR_VAR 0 3
53442: PUSH
53443: LD_EXP 130
53447: PUSH
53448: LD_VAR 0 2
53452: ARRAY
53453: PPUSH
53454: LD_INT 25
53456: PUSH
53457: LD_INT 12
53459: PUSH
53460: EMPTY
53461: LIST
53462: LIST
53463: PPUSH
53464: CALL_OW 72
53468: PUSH
53469: FOR_IN
53470: IFFALSE 53533
// if not HasTask ( j ) then
53472: LD_VAR 0 3
53476: PPUSH
53477: CALL_OW 314
53481: NOT
53482: IFFALSE 53531
// begin if not IsInUnit ( j ) then
53484: LD_VAR 0 3
53488: PPUSH
53489: CALL_OW 310
53493: NOT
53494: IFFALSE 53510
// ComEnterUnit ( j , selected ) ;
53496: LD_VAR 0 3
53500: PPUSH
53501: LD_VAR 0 7
53505: PPUSH
53506: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53510: LD_VAR 0 3
53514: PPUSH
53515: LD_INT 16
53517: PPUSH
53518: CALL_OW 183
// AddComExitBuilding ( j ) ;
53522: LD_VAR 0 3
53526: PPUSH
53527: CALL_OW 182
// end ;
53531: GO 53469
53533: POP
53534: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53535: LD_VAR 0 5
53539: PPUSH
53540: LD_INT 11
53542: PPUSH
53543: CALL_OW 325
53547: IFFALSE 53806
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53549: LD_ADDR_VAR 0 4
53553: PUSH
53554: LD_EXP 130
53558: PUSH
53559: LD_VAR 0 2
53563: ARRAY
53564: PPUSH
53565: LD_INT 25
53567: PUSH
53568: LD_INT 16
53570: PUSH
53571: EMPTY
53572: LIST
53573: LIST
53574: PPUSH
53575: CALL_OW 72
53579: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53580: LD_VAR 0 4
53584: PUSH
53585: LD_INT 6
53587: GREATEREQUAL
53588: PUSH
53589: LD_VAR 0 5
53593: PPUSH
53594: LD_INT 2
53596: PPUSH
53597: CALL_OW 325
53601: NOT
53602: OR
53603: IFFALSE 53806
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53605: LD_ADDR_VAR 0 8
53609: PUSH
53610: LD_EXP 101
53614: PUSH
53615: LD_VAR 0 2
53619: ARRAY
53620: PPUSH
53621: LD_INT 2
53623: PUSH
53624: LD_INT 30
53626: PUSH
53627: LD_INT 4
53629: PUSH
53630: EMPTY
53631: LIST
53632: LIST
53633: PUSH
53634: LD_INT 30
53636: PUSH
53637: LD_INT 5
53639: PUSH
53640: EMPTY
53641: LIST
53642: LIST
53643: PUSH
53644: EMPTY
53645: LIST
53646: LIST
53647: LIST
53648: PPUSH
53649: CALL_OW 72
53653: ST_TO_ADDR
// if barracks then
53654: LD_VAR 0 8
53658: IFFALSE 53806
// begin selected := 0 ;
53660: LD_ADDR_VAR 0 7
53664: PUSH
53665: LD_INT 0
53667: ST_TO_ADDR
// for j in barracks do
53668: LD_ADDR_VAR 0 3
53672: PUSH
53673: LD_VAR 0 8
53677: PUSH
53678: FOR_IN
53679: IFFALSE 53710
// begin if UnitsInside ( j ) < 6 then
53681: LD_VAR 0 3
53685: PPUSH
53686: CALL_OW 313
53690: PUSH
53691: LD_INT 6
53693: LESS
53694: IFFALSE 53708
// begin selected := j ;
53696: LD_ADDR_VAR 0 7
53700: PUSH
53701: LD_VAR 0 3
53705: ST_TO_ADDR
// break ;
53706: GO 53710
// end ; end ;
53708: GO 53678
53710: POP
53711: POP
// if selected then
53712: LD_VAR 0 7
53716: IFFALSE 53806
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53718: LD_ADDR_VAR 0 3
53722: PUSH
53723: LD_EXP 130
53727: PUSH
53728: LD_VAR 0 2
53732: ARRAY
53733: PPUSH
53734: LD_INT 25
53736: PUSH
53737: LD_INT 12
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: PPUSH
53744: CALL_OW 72
53748: PUSH
53749: FOR_IN
53750: IFFALSE 53804
// if not IsInUnit ( j ) and not HasTask ( j ) then
53752: LD_VAR 0 3
53756: PPUSH
53757: CALL_OW 310
53761: NOT
53762: PUSH
53763: LD_VAR 0 3
53767: PPUSH
53768: CALL_OW 314
53772: NOT
53773: AND
53774: IFFALSE 53802
// begin ComEnterUnit ( j , selected ) ;
53776: LD_VAR 0 3
53780: PPUSH
53781: LD_VAR 0 7
53785: PPUSH
53786: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53790: LD_VAR 0 3
53794: PPUSH
53795: LD_INT 15
53797: PPUSH
53798: CALL_OW 183
// end ;
53802: GO 53749
53804: POP
53805: POP
// end ; end ; end ; end ; end ;
53806: GO 53199
53808: POP
53809: POP
// end ;
53810: LD_VAR 0 1
53814: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53815: LD_INT 0
53817: PPUSH
53818: PPUSH
53819: PPUSH
53820: PPUSH
// if not mc_bases then
53821: LD_EXP 101
53825: NOT
53826: IFFALSE 53830
// exit ;
53828: GO 54008
// for i = 1 to mc_bases do
53830: LD_ADDR_VAR 0 2
53834: PUSH
53835: DOUBLE
53836: LD_INT 1
53838: DEC
53839: ST_TO_ADDR
53840: LD_EXP 101
53844: PUSH
53845: FOR_TO
53846: IFFALSE 54006
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53848: LD_ADDR_VAR 0 4
53852: PUSH
53853: LD_EXP 101
53857: PUSH
53858: LD_VAR 0 2
53862: ARRAY
53863: PPUSH
53864: LD_INT 25
53866: PUSH
53867: LD_INT 9
53869: PUSH
53870: EMPTY
53871: LIST
53872: LIST
53873: PPUSH
53874: CALL_OW 72
53878: ST_TO_ADDR
// if not tmp then
53879: LD_VAR 0 4
53883: NOT
53884: IFFALSE 53888
// continue ;
53886: GO 53845
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53888: LD_EXP 127
53892: PUSH
53893: LD_VAR 0 2
53897: ARRAY
53898: PPUSH
53899: LD_INT 29
53901: PPUSH
53902: CALL_OW 325
53906: NOT
53907: PUSH
53908: LD_EXP 127
53912: PUSH
53913: LD_VAR 0 2
53917: ARRAY
53918: PPUSH
53919: LD_INT 28
53921: PPUSH
53922: CALL_OW 325
53926: NOT
53927: AND
53928: IFFALSE 53932
// continue ;
53930: GO 53845
// for j in tmp do
53932: LD_ADDR_VAR 0 3
53936: PUSH
53937: LD_VAR 0 4
53941: PUSH
53942: FOR_IN
53943: IFFALSE 54002
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53945: LD_VAR 0 3
53949: PUSH
53950: LD_EXP 104
53954: PUSH
53955: LD_VAR 0 2
53959: ARRAY
53960: PUSH
53961: LD_INT 1
53963: ARRAY
53964: IN
53965: NOT
53966: PUSH
53967: LD_VAR 0 3
53971: PUSH
53972: LD_EXP 104
53976: PUSH
53977: LD_VAR 0 2
53981: ARRAY
53982: PUSH
53983: LD_INT 2
53985: ARRAY
53986: IN
53987: NOT
53988: AND
53989: IFFALSE 54000
// ComSpaceTimeShoot ( j ) ;
53991: LD_VAR 0 3
53995: PPUSH
53996: CALL 65026 0 1
54000: GO 53942
54002: POP
54003: POP
// end ;
54004: GO 53845
54006: POP
54007: POP
// end ;
54008: LD_VAR 0 1
54012: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54013: LD_INT 0
54015: PPUSH
54016: PPUSH
54017: PPUSH
54018: PPUSH
54019: PPUSH
54020: PPUSH
54021: PPUSH
54022: PPUSH
54023: PPUSH
// if not mc_bases then
54024: LD_EXP 101
54028: NOT
54029: IFFALSE 54033
// exit ;
54031: GO 54655
// for i = 1 to mc_bases do
54033: LD_ADDR_VAR 0 2
54037: PUSH
54038: DOUBLE
54039: LD_INT 1
54041: DEC
54042: ST_TO_ADDR
54043: LD_EXP 101
54047: PUSH
54048: FOR_TO
54049: IFFALSE 54653
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54051: LD_EXP 136
54055: PUSH
54056: LD_VAR 0 2
54060: ARRAY
54061: NOT
54062: PUSH
54063: LD_INT 38
54065: PPUSH
54066: LD_EXP 127
54070: PUSH
54071: LD_VAR 0 2
54075: ARRAY
54076: PPUSH
54077: CALL_OW 321
54081: PUSH
54082: LD_INT 2
54084: NONEQUAL
54085: OR
54086: IFFALSE 54090
// continue ;
54088: GO 54048
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54090: LD_ADDR_VAR 0 8
54094: PUSH
54095: LD_EXP 101
54099: PUSH
54100: LD_VAR 0 2
54104: ARRAY
54105: PPUSH
54106: LD_INT 30
54108: PUSH
54109: LD_INT 34
54111: PUSH
54112: EMPTY
54113: LIST
54114: LIST
54115: PPUSH
54116: CALL_OW 72
54120: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54121: LD_ADDR_VAR 0 9
54125: PUSH
54126: LD_EXP 101
54130: PUSH
54131: LD_VAR 0 2
54135: ARRAY
54136: PPUSH
54137: LD_INT 25
54139: PUSH
54140: LD_INT 4
54142: PUSH
54143: EMPTY
54144: LIST
54145: LIST
54146: PPUSH
54147: CALL_OW 72
54151: PPUSH
54152: LD_INT 0
54154: PPUSH
54155: CALL 104700 0 2
54159: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54160: LD_VAR 0 9
54164: NOT
54165: PUSH
54166: LD_VAR 0 8
54170: NOT
54171: OR
54172: PUSH
54173: LD_EXP 101
54177: PUSH
54178: LD_VAR 0 2
54182: ARRAY
54183: PPUSH
54184: LD_INT 124
54186: PPUSH
54187: CALL 104700 0 2
54191: OR
54192: IFFALSE 54196
// continue ;
54194: GO 54048
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54196: LD_EXP 137
54200: PUSH
54201: LD_VAR 0 2
54205: ARRAY
54206: PUSH
54207: LD_EXP 136
54211: PUSH
54212: LD_VAR 0 2
54216: ARRAY
54217: LESS
54218: PUSH
54219: LD_EXP 137
54223: PUSH
54224: LD_VAR 0 2
54228: ARRAY
54229: PUSH
54230: LD_VAR 0 8
54234: LESS
54235: AND
54236: IFFALSE 54651
// begin tmp := sci [ 1 ] ;
54238: LD_ADDR_VAR 0 7
54242: PUSH
54243: LD_VAR 0 9
54247: PUSH
54248: LD_INT 1
54250: ARRAY
54251: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54252: LD_VAR 0 7
54256: PPUSH
54257: LD_INT 124
54259: PPUSH
54260: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54264: LD_ADDR_VAR 0 3
54268: PUSH
54269: DOUBLE
54270: LD_EXP 136
54274: PUSH
54275: LD_VAR 0 2
54279: ARRAY
54280: INC
54281: ST_TO_ADDR
54282: LD_EXP 136
54286: PUSH
54287: LD_VAR 0 2
54291: ARRAY
54292: PUSH
54293: FOR_DOWNTO
54294: IFFALSE 54637
// begin if IsInUnit ( tmp ) then
54296: LD_VAR 0 7
54300: PPUSH
54301: CALL_OW 310
54305: IFFALSE 54316
// ComExitBuilding ( tmp ) ;
54307: LD_VAR 0 7
54311: PPUSH
54312: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54316: LD_INT 35
54318: PPUSH
54319: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54323: LD_VAR 0 7
54327: PPUSH
54328: CALL_OW 310
54332: NOT
54333: PUSH
54334: LD_VAR 0 7
54338: PPUSH
54339: CALL_OW 314
54343: NOT
54344: AND
54345: IFFALSE 54316
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54347: LD_ADDR_VAR 0 6
54351: PUSH
54352: LD_VAR 0 7
54356: PPUSH
54357: CALL_OW 250
54361: PUSH
54362: LD_VAR 0 7
54366: PPUSH
54367: CALL_OW 251
54371: PUSH
54372: EMPTY
54373: LIST
54374: LIST
54375: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54376: LD_INT 35
54378: PPUSH
54379: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54383: LD_ADDR_VAR 0 4
54387: PUSH
54388: LD_EXP 136
54392: PUSH
54393: LD_VAR 0 2
54397: ARRAY
54398: PUSH
54399: LD_VAR 0 3
54403: ARRAY
54404: PUSH
54405: LD_INT 1
54407: ARRAY
54408: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54409: LD_ADDR_VAR 0 5
54413: PUSH
54414: LD_EXP 136
54418: PUSH
54419: LD_VAR 0 2
54423: ARRAY
54424: PUSH
54425: LD_VAR 0 3
54429: ARRAY
54430: PUSH
54431: LD_INT 2
54433: ARRAY
54434: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54435: LD_VAR 0 7
54439: PPUSH
54440: LD_INT 10
54442: PPUSH
54443: CALL 74033 0 2
54447: PUSH
54448: LD_INT 4
54450: ARRAY
54451: IFFALSE 54489
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54453: LD_VAR 0 7
54457: PPUSH
54458: LD_VAR 0 6
54462: PUSH
54463: LD_INT 1
54465: ARRAY
54466: PPUSH
54467: LD_VAR 0 6
54471: PUSH
54472: LD_INT 2
54474: ARRAY
54475: PPUSH
54476: CALL_OW 111
// wait ( 0 0$10 ) ;
54480: LD_INT 350
54482: PPUSH
54483: CALL_OW 67
// end else
54487: GO 54515
// begin ComMoveXY ( tmp , x , y ) ;
54489: LD_VAR 0 7
54493: PPUSH
54494: LD_VAR 0 4
54498: PPUSH
54499: LD_VAR 0 5
54503: PPUSH
54504: CALL_OW 111
// wait ( 0 0$3 ) ;
54508: LD_INT 105
54510: PPUSH
54511: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54515: LD_VAR 0 7
54519: PPUSH
54520: LD_VAR 0 4
54524: PPUSH
54525: LD_VAR 0 5
54529: PPUSH
54530: CALL_OW 307
54534: IFFALSE 54376
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54536: LD_VAR 0 7
54540: PPUSH
54541: LD_VAR 0 4
54545: PPUSH
54546: LD_VAR 0 5
54550: PPUSH
54551: LD_VAR 0 8
54555: PUSH
54556: LD_VAR 0 3
54560: ARRAY
54561: PPUSH
54562: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54566: LD_INT 35
54568: PPUSH
54569: CALL_OW 67
// until not HasTask ( tmp ) ;
54573: LD_VAR 0 7
54577: PPUSH
54578: CALL_OW 314
54582: NOT
54583: IFFALSE 54566
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54585: LD_ADDR_EXP 137
54589: PUSH
54590: LD_EXP 137
54594: PPUSH
54595: LD_VAR 0 2
54599: PUSH
54600: LD_EXP 137
54604: PUSH
54605: LD_VAR 0 2
54609: ARRAY
54610: PUSH
54611: LD_INT 1
54613: PLUS
54614: PUSH
54615: EMPTY
54616: LIST
54617: LIST
54618: PPUSH
54619: LD_VAR 0 8
54623: PUSH
54624: LD_VAR 0 3
54628: ARRAY
54629: PPUSH
54630: CALL 71440 0 3
54634: ST_TO_ADDR
// end ;
54635: GO 54293
54637: POP
54638: POP
// MC_Reset ( i , 124 ) ;
54639: LD_VAR 0 2
54643: PPUSH
54644: LD_INT 124
54646: PPUSH
54647: CALL 38138 0 2
// end ; end ;
54651: GO 54048
54653: POP
54654: POP
// end ;
54655: LD_VAR 0 1
54659: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54660: LD_INT 0
54662: PPUSH
54663: PPUSH
54664: PPUSH
// if not mc_bases then
54665: LD_EXP 101
54669: NOT
54670: IFFALSE 54674
// exit ;
54672: GO 55280
// for i = 1 to mc_bases do
54674: LD_ADDR_VAR 0 2
54678: PUSH
54679: DOUBLE
54680: LD_INT 1
54682: DEC
54683: ST_TO_ADDR
54684: LD_EXP 101
54688: PUSH
54689: FOR_TO
54690: IFFALSE 55278
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54692: LD_ADDR_VAR 0 3
54696: PUSH
54697: LD_EXP 101
54701: PUSH
54702: LD_VAR 0 2
54706: ARRAY
54707: PPUSH
54708: LD_INT 25
54710: PUSH
54711: LD_INT 4
54713: PUSH
54714: EMPTY
54715: LIST
54716: LIST
54717: PPUSH
54718: CALL_OW 72
54722: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54723: LD_VAR 0 3
54727: NOT
54728: PUSH
54729: LD_EXP 138
54733: PUSH
54734: LD_VAR 0 2
54738: ARRAY
54739: NOT
54740: OR
54741: PUSH
54742: LD_EXP 101
54746: PUSH
54747: LD_VAR 0 2
54751: ARRAY
54752: PPUSH
54753: LD_INT 2
54755: PUSH
54756: LD_INT 30
54758: PUSH
54759: LD_INT 0
54761: PUSH
54762: EMPTY
54763: LIST
54764: LIST
54765: PUSH
54766: LD_INT 30
54768: PUSH
54769: LD_INT 1
54771: PUSH
54772: EMPTY
54773: LIST
54774: LIST
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: LIST
54780: PPUSH
54781: CALL_OW 72
54785: NOT
54786: OR
54787: IFFALSE 54837
// begin if mc_deposits_finder [ i ] then
54789: LD_EXP 139
54793: PUSH
54794: LD_VAR 0 2
54798: ARRAY
54799: IFFALSE 54835
// begin MC_Reset ( i , 125 ) ;
54801: LD_VAR 0 2
54805: PPUSH
54806: LD_INT 125
54808: PPUSH
54809: CALL 38138 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54813: LD_ADDR_EXP 139
54817: PUSH
54818: LD_EXP 139
54822: PPUSH
54823: LD_VAR 0 2
54827: PPUSH
54828: EMPTY
54829: PPUSH
54830: CALL_OW 1
54834: ST_TO_ADDR
// end ; continue ;
54835: GO 54689
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54837: LD_EXP 138
54841: PUSH
54842: LD_VAR 0 2
54846: ARRAY
54847: PUSH
54848: LD_INT 1
54850: ARRAY
54851: PUSH
54852: LD_INT 3
54854: ARRAY
54855: PUSH
54856: LD_INT 1
54858: EQUAL
54859: PUSH
54860: LD_INT 20
54862: PPUSH
54863: LD_EXP 127
54867: PUSH
54868: LD_VAR 0 2
54872: ARRAY
54873: PPUSH
54874: CALL_OW 321
54878: PUSH
54879: LD_INT 2
54881: NONEQUAL
54882: AND
54883: IFFALSE 54933
// begin if mc_deposits_finder [ i ] then
54885: LD_EXP 139
54889: PUSH
54890: LD_VAR 0 2
54894: ARRAY
54895: IFFALSE 54931
// begin MC_Reset ( i , 125 ) ;
54897: LD_VAR 0 2
54901: PPUSH
54902: LD_INT 125
54904: PPUSH
54905: CALL 38138 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54909: LD_ADDR_EXP 139
54913: PUSH
54914: LD_EXP 139
54918: PPUSH
54919: LD_VAR 0 2
54923: PPUSH
54924: EMPTY
54925: PPUSH
54926: CALL_OW 1
54930: ST_TO_ADDR
// end ; continue ;
54931: GO 54689
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54933: LD_EXP 138
54937: PUSH
54938: LD_VAR 0 2
54942: ARRAY
54943: PUSH
54944: LD_INT 1
54946: ARRAY
54947: PUSH
54948: LD_INT 1
54950: ARRAY
54951: PPUSH
54952: LD_EXP 138
54956: PUSH
54957: LD_VAR 0 2
54961: ARRAY
54962: PUSH
54963: LD_INT 1
54965: ARRAY
54966: PUSH
54967: LD_INT 2
54969: ARRAY
54970: PPUSH
54971: LD_EXP 127
54975: PUSH
54976: LD_VAR 0 2
54980: ARRAY
54981: PPUSH
54982: CALL_OW 440
54986: IFFALSE 55029
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54988: LD_ADDR_EXP 138
54992: PUSH
54993: LD_EXP 138
54997: PPUSH
54998: LD_VAR 0 2
55002: PPUSH
55003: LD_EXP 138
55007: PUSH
55008: LD_VAR 0 2
55012: ARRAY
55013: PPUSH
55014: LD_INT 1
55016: PPUSH
55017: CALL_OW 3
55021: PPUSH
55022: CALL_OW 1
55026: ST_TO_ADDR
55027: GO 55276
// begin if not mc_deposits_finder [ i ] then
55029: LD_EXP 139
55033: PUSH
55034: LD_VAR 0 2
55038: ARRAY
55039: NOT
55040: IFFALSE 55092
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55042: LD_ADDR_EXP 139
55046: PUSH
55047: LD_EXP 139
55051: PPUSH
55052: LD_VAR 0 2
55056: PPUSH
55057: LD_VAR 0 3
55061: PUSH
55062: LD_INT 1
55064: ARRAY
55065: PUSH
55066: EMPTY
55067: LIST
55068: PPUSH
55069: CALL_OW 1
55073: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55074: LD_VAR 0 3
55078: PUSH
55079: LD_INT 1
55081: ARRAY
55082: PPUSH
55083: LD_INT 125
55085: PPUSH
55086: CALL_OW 109
// end else
55090: GO 55276
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55092: LD_EXP 139
55096: PUSH
55097: LD_VAR 0 2
55101: ARRAY
55102: PUSH
55103: LD_INT 1
55105: ARRAY
55106: PPUSH
55107: CALL_OW 310
55111: IFFALSE 55134
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55113: LD_EXP 139
55117: PUSH
55118: LD_VAR 0 2
55122: ARRAY
55123: PUSH
55124: LD_INT 1
55126: ARRAY
55127: PPUSH
55128: CALL_OW 122
55132: GO 55276
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55134: LD_EXP 139
55138: PUSH
55139: LD_VAR 0 2
55143: ARRAY
55144: PUSH
55145: LD_INT 1
55147: ARRAY
55148: PPUSH
55149: CALL_OW 314
55153: NOT
55154: PUSH
55155: LD_EXP 139
55159: PUSH
55160: LD_VAR 0 2
55164: ARRAY
55165: PUSH
55166: LD_INT 1
55168: ARRAY
55169: PPUSH
55170: LD_EXP 138
55174: PUSH
55175: LD_VAR 0 2
55179: ARRAY
55180: PUSH
55181: LD_INT 1
55183: ARRAY
55184: PUSH
55185: LD_INT 1
55187: ARRAY
55188: PPUSH
55189: LD_EXP 138
55193: PUSH
55194: LD_VAR 0 2
55198: ARRAY
55199: PUSH
55200: LD_INT 1
55202: ARRAY
55203: PUSH
55204: LD_INT 2
55206: ARRAY
55207: PPUSH
55208: CALL_OW 297
55212: PUSH
55213: LD_INT 6
55215: GREATER
55216: AND
55217: IFFALSE 55276
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55219: LD_EXP 139
55223: PUSH
55224: LD_VAR 0 2
55228: ARRAY
55229: PUSH
55230: LD_INT 1
55232: ARRAY
55233: PPUSH
55234: LD_EXP 138
55238: PUSH
55239: LD_VAR 0 2
55243: ARRAY
55244: PUSH
55245: LD_INT 1
55247: ARRAY
55248: PUSH
55249: LD_INT 1
55251: ARRAY
55252: PPUSH
55253: LD_EXP 138
55257: PUSH
55258: LD_VAR 0 2
55262: ARRAY
55263: PUSH
55264: LD_INT 1
55266: ARRAY
55267: PUSH
55268: LD_INT 2
55270: ARRAY
55271: PPUSH
55272: CALL_OW 111
// end ; end ; end ;
55276: GO 54689
55278: POP
55279: POP
// end ;
55280: LD_VAR 0 1
55284: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55285: LD_INT 0
55287: PPUSH
55288: PPUSH
55289: PPUSH
55290: PPUSH
55291: PPUSH
55292: PPUSH
55293: PPUSH
55294: PPUSH
55295: PPUSH
55296: PPUSH
55297: PPUSH
// if not mc_bases then
55298: LD_EXP 101
55302: NOT
55303: IFFALSE 55307
// exit ;
55305: GO 56247
// for i = 1 to mc_bases do
55307: LD_ADDR_VAR 0 2
55311: PUSH
55312: DOUBLE
55313: LD_INT 1
55315: DEC
55316: ST_TO_ADDR
55317: LD_EXP 101
55321: PUSH
55322: FOR_TO
55323: IFFALSE 56245
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55325: LD_EXP 101
55329: PUSH
55330: LD_VAR 0 2
55334: ARRAY
55335: NOT
55336: PUSH
55337: LD_EXP 124
55341: PUSH
55342: LD_VAR 0 2
55346: ARRAY
55347: OR
55348: IFFALSE 55352
// continue ;
55350: GO 55322
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55352: LD_ADDR_VAR 0 7
55356: PUSH
55357: LD_EXP 101
55361: PUSH
55362: LD_VAR 0 2
55366: ARRAY
55367: PUSH
55368: LD_INT 1
55370: ARRAY
55371: PPUSH
55372: CALL_OW 248
55376: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55377: LD_VAR 0 7
55381: PUSH
55382: LD_INT 3
55384: EQUAL
55385: PUSH
55386: LD_EXP 120
55390: PUSH
55391: LD_VAR 0 2
55395: ARRAY
55396: PUSH
55397: LD_EXP 123
55401: PUSH
55402: LD_VAR 0 2
55406: ARRAY
55407: UNION
55408: PPUSH
55409: LD_INT 33
55411: PUSH
55412: LD_INT 2
55414: PUSH
55415: EMPTY
55416: LIST
55417: LIST
55418: PPUSH
55419: CALL_OW 72
55423: NOT
55424: OR
55425: IFFALSE 55429
// continue ;
55427: GO 55322
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55429: LD_ADDR_VAR 0 9
55433: PUSH
55434: LD_EXP 101
55438: PUSH
55439: LD_VAR 0 2
55443: ARRAY
55444: PPUSH
55445: LD_INT 30
55447: PUSH
55448: LD_INT 36
55450: PUSH
55451: EMPTY
55452: LIST
55453: LIST
55454: PPUSH
55455: CALL_OW 72
55459: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55460: LD_ADDR_VAR 0 10
55464: PUSH
55465: LD_EXP 120
55469: PUSH
55470: LD_VAR 0 2
55474: ARRAY
55475: PPUSH
55476: LD_INT 34
55478: PUSH
55479: LD_INT 31
55481: PUSH
55482: EMPTY
55483: LIST
55484: LIST
55485: PPUSH
55486: CALL_OW 72
55490: ST_TO_ADDR
// if not cts and not mcts then
55491: LD_VAR 0 9
55495: NOT
55496: PUSH
55497: LD_VAR 0 10
55501: NOT
55502: AND
55503: IFFALSE 55507
// continue ;
55505: GO 55322
// x := cts ;
55507: LD_ADDR_VAR 0 11
55511: PUSH
55512: LD_VAR 0 9
55516: ST_TO_ADDR
// if not x then
55517: LD_VAR 0 11
55521: NOT
55522: IFFALSE 55534
// x := mcts ;
55524: LD_ADDR_VAR 0 11
55528: PUSH
55529: LD_VAR 0 10
55533: ST_TO_ADDR
// if not x then
55534: LD_VAR 0 11
55538: NOT
55539: IFFALSE 55543
// continue ;
55541: GO 55322
// if mc_remote_driver [ i ] then
55543: LD_EXP 141
55547: PUSH
55548: LD_VAR 0 2
55552: ARRAY
55553: IFFALSE 55940
// for j in mc_remote_driver [ i ] do
55555: LD_ADDR_VAR 0 3
55559: PUSH
55560: LD_EXP 141
55564: PUSH
55565: LD_VAR 0 2
55569: ARRAY
55570: PUSH
55571: FOR_IN
55572: IFFALSE 55938
// begin if GetClass ( j ) <> 3 then
55574: LD_VAR 0 3
55578: PPUSH
55579: CALL_OW 257
55583: PUSH
55584: LD_INT 3
55586: NONEQUAL
55587: IFFALSE 55640
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55589: LD_ADDR_EXP 141
55593: PUSH
55594: LD_EXP 141
55598: PPUSH
55599: LD_VAR 0 2
55603: PPUSH
55604: LD_EXP 141
55608: PUSH
55609: LD_VAR 0 2
55613: ARRAY
55614: PUSH
55615: LD_VAR 0 3
55619: DIFF
55620: PPUSH
55621: CALL_OW 1
55625: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55626: LD_VAR 0 3
55630: PPUSH
55631: LD_INT 0
55633: PPUSH
55634: CALL_OW 109
// continue ;
55638: GO 55571
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55640: LD_EXP 120
55644: PUSH
55645: LD_VAR 0 2
55649: ARRAY
55650: PPUSH
55651: LD_INT 34
55653: PUSH
55654: LD_INT 31
55656: PUSH
55657: EMPTY
55658: LIST
55659: LIST
55660: PUSH
55661: LD_INT 58
55663: PUSH
55664: EMPTY
55665: LIST
55666: PUSH
55667: EMPTY
55668: LIST
55669: LIST
55670: PPUSH
55671: CALL_OW 72
55675: PUSH
55676: LD_VAR 0 3
55680: PPUSH
55681: CALL 104788 0 1
55685: NOT
55686: AND
55687: IFFALSE 55758
// begin if IsInUnit ( j ) then
55689: LD_VAR 0 3
55693: PPUSH
55694: CALL_OW 310
55698: IFFALSE 55709
// ComExitBuilding ( j ) ;
55700: LD_VAR 0 3
55704: PPUSH
55705: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55709: LD_VAR 0 3
55713: PPUSH
55714: LD_EXP 120
55718: PUSH
55719: LD_VAR 0 2
55723: ARRAY
55724: PPUSH
55725: LD_INT 34
55727: PUSH
55728: LD_INT 31
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: PUSH
55735: LD_INT 58
55737: PUSH
55738: EMPTY
55739: LIST
55740: PUSH
55741: EMPTY
55742: LIST
55743: LIST
55744: PPUSH
55745: CALL_OW 72
55749: PUSH
55750: LD_INT 1
55752: ARRAY
55753: PPUSH
55754: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55758: LD_VAR 0 3
55762: PPUSH
55763: CALL_OW 310
55767: NOT
55768: PUSH
55769: LD_VAR 0 3
55773: PPUSH
55774: CALL_OW 310
55778: PPUSH
55779: CALL_OW 266
55783: PUSH
55784: LD_INT 36
55786: NONEQUAL
55787: PUSH
55788: LD_VAR 0 3
55792: PPUSH
55793: CALL 104788 0 1
55797: NOT
55798: AND
55799: OR
55800: IFFALSE 55936
// begin if IsInUnit ( j ) then
55802: LD_VAR 0 3
55806: PPUSH
55807: CALL_OW 310
55811: IFFALSE 55822
// ComExitBuilding ( j ) ;
55813: LD_VAR 0 3
55817: PPUSH
55818: CALL_OW 122
// ct := 0 ;
55822: LD_ADDR_VAR 0 8
55826: PUSH
55827: LD_INT 0
55829: ST_TO_ADDR
// for k in x do
55830: LD_ADDR_VAR 0 4
55834: PUSH
55835: LD_VAR 0 11
55839: PUSH
55840: FOR_IN
55841: IFFALSE 55914
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55843: LD_VAR 0 4
55847: PPUSH
55848: CALL_OW 264
55852: PUSH
55853: LD_INT 31
55855: EQUAL
55856: PUSH
55857: LD_VAR 0 4
55861: PPUSH
55862: CALL_OW 311
55866: NOT
55867: AND
55868: PUSH
55869: LD_VAR 0 4
55873: PPUSH
55874: CALL_OW 266
55878: PUSH
55879: LD_INT 36
55881: EQUAL
55882: PUSH
55883: LD_VAR 0 4
55887: PPUSH
55888: CALL_OW 313
55892: PUSH
55893: LD_INT 3
55895: LESS
55896: AND
55897: OR
55898: IFFALSE 55912
// begin ct := k ;
55900: LD_ADDR_VAR 0 8
55904: PUSH
55905: LD_VAR 0 4
55909: ST_TO_ADDR
// break ;
55910: GO 55914
// end ;
55912: GO 55840
55914: POP
55915: POP
// if ct then
55916: LD_VAR 0 8
55920: IFFALSE 55936
// ComEnterUnit ( j , ct ) ;
55922: LD_VAR 0 3
55926: PPUSH
55927: LD_VAR 0 8
55931: PPUSH
55932: CALL_OW 120
// end ; end ;
55936: GO 55571
55938: POP
55939: POP
// places := 0 ;
55940: LD_ADDR_VAR 0 5
55944: PUSH
55945: LD_INT 0
55947: ST_TO_ADDR
// for j = 1 to x do
55948: LD_ADDR_VAR 0 3
55952: PUSH
55953: DOUBLE
55954: LD_INT 1
55956: DEC
55957: ST_TO_ADDR
55958: LD_VAR 0 11
55962: PUSH
55963: FOR_TO
55964: IFFALSE 56040
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55966: LD_VAR 0 11
55970: PUSH
55971: LD_VAR 0 3
55975: ARRAY
55976: PPUSH
55977: CALL_OW 264
55981: PUSH
55982: LD_INT 31
55984: EQUAL
55985: IFFALSE 56003
// places := places + 1 else
55987: LD_ADDR_VAR 0 5
55991: PUSH
55992: LD_VAR 0 5
55996: PUSH
55997: LD_INT 1
55999: PLUS
56000: ST_TO_ADDR
56001: GO 56038
// if GetBType ( x [ j ] ) = b_control_tower then
56003: LD_VAR 0 11
56007: PUSH
56008: LD_VAR 0 3
56012: ARRAY
56013: PPUSH
56014: CALL_OW 266
56018: PUSH
56019: LD_INT 36
56021: EQUAL
56022: IFFALSE 56038
// places := places + 3 ;
56024: LD_ADDR_VAR 0 5
56028: PUSH
56029: LD_VAR 0 5
56033: PUSH
56034: LD_INT 3
56036: PLUS
56037: ST_TO_ADDR
56038: GO 55963
56040: POP
56041: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56042: LD_VAR 0 5
56046: PUSH
56047: LD_INT 0
56049: EQUAL
56050: PUSH
56051: LD_VAR 0 5
56055: PUSH
56056: LD_EXP 141
56060: PUSH
56061: LD_VAR 0 2
56065: ARRAY
56066: LESSEQUAL
56067: OR
56068: IFFALSE 56072
// continue ;
56070: GO 55322
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56072: LD_ADDR_VAR 0 6
56076: PUSH
56077: LD_EXP 101
56081: PUSH
56082: LD_VAR 0 2
56086: ARRAY
56087: PPUSH
56088: LD_INT 25
56090: PUSH
56091: LD_INT 3
56093: PUSH
56094: EMPTY
56095: LIST
56096: LIST
56097: PPUSH
56098: CALL_OW 72
56102: PUSH
56103: LD_EXP 141
56107: PUSH
56108: LD_VAR 0 2
56112: ARRAY
56113: DIFF
56114: PPUSH
56115: LD_INT 3
56117: PPUSH
56118: CALL 105688 0 2
56122: ST_TO_ADDR
// for j in tmp do
56123: LD_ADDR_VAR 0 3
56127: PUSH
56128: LD_VAR 0 6
56132: PUSH
56133: FOR_IN
56134: IFFALSE 56169
// if GetTag ( j ) > 0 then
56136: LD_VAR 0 3
56140: PPUSH
56141: CALL_OW 110
56145: PUSH
56146: LD_INT 0
56148: GREATER
56149: IFFALSE 56167
// tmp := tmp diff j ;
56151: LD_ADDR_VAR 0 6
56155: PUSH
56156: LD_VAR 0 6
56160: PUSH
56161: LD_VAR 0 3
56165: DIFF
56166: ST_TO_ADDR
56167: GO 56133
56169: POP
56170: POP
// if not tmp then
56171: LD_VAR 0 6
56175: NOT
56176: IFFALSE 56180
// continue ;
56178: GO 55322
// if places then
56180: LD_VAR 0 5
56184: IFFALSE 56243
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56186: LD_ADDR_EXP 141
56190: PUSH
56191: LD_EXP 141
56195: PPUSH
56196: LD_VAR 0 2
56200: PPUSH
56201: LD_EXP 141
56205: PUSH
56206: LD_VAR 0 2
56210: ARRAY
56211: PUSH
56212: LD_VAR 0 6
56216: PUSH
56217: LD_INT 1
56219: ARRAY
56220: UNION
56221: PPUSH
56222: CALL_OW 1
56226: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56227: LD_VAR 0 6
56231: PUSH
56232: LD_INT 1
56234: ARRAY
56235: PPUSH
56236: LD_INT 126
56238: PPUSH
56239: CALL_OW 109
// end ; end ;
56243: GO 55322
56245: POP
56246: POP
// end ;
56247: LD_VAR 0 1
56251: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56252: LD_INT 0
56254: PPUSH
56255: PPUSH
56256: PPUSH
56257: PPUSH
56258: PPUSH
56259: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56260: LD_VAR 0 1
56264: NOT
56265: PUSH
56266: LD_VAR 0 2
56270: NOT
56271: OR
56272: PUSH
56273: LD_VAR 0 3
56277: NOT
56278: OR
56279: PUSH
56280: LD_VAR 0 4
56284: PUSH
56285: LD_INT 1
56287: PUSH
56288: LD_INT 2
56290: PUSH
56291: LD_INT 3
56293: PUSH
56294: LD_INT 4
56296: PUSH
56297: LD_INT 5
56299: PUSH
56300: LD_INT 8
56302: PUSH
56303: LD_INT 9
56305: PUSH
56306: LD_INT 15
56308: PUSH
56309: LD_INT 16
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: LIST
56316: LIST
56317: LIST
56318: LIST
56319: LIST
56320: LIST
56321: LIST
56322: IN
56323: NOT
56324: OR
56325: IFFALSE 56329
// exit ;
56327: GO 57229
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56329: LD_ADDR_VAR 0 2
56333: PUSH
56334: LD_VAR 0 2
56338: PPUSH
56339: LD_INT 21
56341: PUSH
56342: LD_INT 3
56344: PUSH
56345: EMPTY
56346: LIST
56347: LIST
56348: PUSH
56349: LD_INT 24
56351: PUSH
56352: LD_INT 250
56354: PUSH
56355: EMPTY
56356: LIST
56357: LIST
56358: PUSH
56359: EMPTY
56360: LIST
56361: LIST
56362: PPUSH
56363: CALL_OW 72
56367: ST_TO_ADDR
// case class of 1 , 15 :
56368: LD_VAR 0 4
56372: PUSH
56373: LD_INT 1
56375: DOUBLE
56376: EQUAL
56377: IFTRUE 56387
56379: LD_INT 15
56381: DOUBLE
56382: EQUAL
56383: IFTRUE 56387
56385: GO 56472
56387: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56388: LD_ADDR_VAR 0 8
56392: PUSH
56393: LD_VAR 0 2
56397: PPUSH
56398: LD_INT 2
56400: PUSH
56401: LD_INT 30
56403: PUSH
56404: LD_INT 32
56406: PUSH
56407: EMPTY
56408: LIST
56409: LIST
56410: PUSH
56411: LD_INT 30
56413: PUSH
56414: LD_INT 31
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: PUSH
56421: EMPTY
56422: LIST
56423: LIST
56424: LIST
56425: PPUSH
56426: CALL_OW 72
56430: PUSH
56431: LD_VAR 0 2
56435: PPUSH
56436: LD_INT 2
56438: PUSH
56439: LD_INT 30
56441: PUSH
56442: LD_INT 4
56444: PUSH
56445: EMPTY
56446: LIST
56447: LIST
56448: PUSH
56449: LD_INT 30
56451: PUSH
56452: LD_INT 5
56454: PUSH
56455: EMPTY
56456: LIST
56457: LIST
56458: PUSH
56459: EMPTY
56460: LIST
56461: LIST
56462: LIST
56463: PPUSH
56464: CALL_OW 72
56468: ADD
56469: ST_TO_ADDR
56470: GO 56718
56472: LD_INT 2
56474: DOUBLE
56475: EQUAL
56476: IFTRUE 56486
56478: LD_INT 16
56480: DOUBLE
56481: EQUAL
56482: IFTRUE 56486
56484: GO 56532
56486: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56487: LD_ADDR_VAR 0 8
56491: PUSH
56492: LD_VAR 0 2
56496: PPUSH
56497: LD_INT 2
56499: PUSH
56500: LD_INT 30
56502: PUSH
56503: LD_INT 0
56505: PUSH
56506: EMPTY
56507: LIST
56508: LIST
56509: PUSH
56510: LD_INT 30
56512: PUSH
56513: LD_INT 1
56515: PUSH
56516: EMPTY
56517: LIST
56518: LIST
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: LIST
56524: PPUSH
56525: CALL_OW 72
56529: ST_TO_ADDR
56530: GO 56718
56532: LD_INT 3
56534: DOUBLE
56535: EQUAL
56536: IFTRUE 56540
56538: GO 56586
56540: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56541: LD_ADDR_VAR 0 8
56545: PUSH
56546: LD_VAR 0 2
56550: PPUSH
56551: LD_INT 2
56553: PUSH
56554: LD_INT 30
56556: PUSH
56557: LD_INT 2
56559: PUSH
56560: EMPTY
56561: LIST
56562: LIST
56563: PUSH
56564: LD_INT 30
56566: PUSH
56567: LD_INT 3
56569: PUSH
56570: EMPTY
56571: LIST
56572: LIST
56573: PUSH
56574: EMPTY
56575: LIST
56576: LIST
56577: LIST
56578: PPUSH
56579: CALL_OW 72
56583: ST_TO_ADDR
56584: GO 56718
56586: LD_INT 4
56588: DOUBLE
56589: EQUAL
56590: IFTRUE 56594
56592: GO 56651
56594: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56595: LD_ADDR_VAR 0 8
56599: PUSH
56600: LD_VAR 0 2
56604: PPUSH
56605: LD_INT 2
56607: PUSH
56608: LD_INT 30
56610: PUSH
56611: LD_INT 6
56613: PUSH
56614: EMPTY
56615: LIST
56616: LIST
56617: PUSH
56618: LD_INT 30
56620: PUSH
56621: LD_INT 7
56623: PUSH
56624: EMPTY
56625: LIST
56626: LIST
56627: PUSH
56628: LD_INT 30
56630: PUSH
56631: LD_INT 8
56633: PUSH
56634: EMPTY
56635: LIST
56636: LIST
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: LIST
56642: LIST
56643: PPUSH
56644: CALL_OW 72
56648: ST_TO_ADDR
56649: GO 56718
56651: LD_INT 5
56653: DOUBLE
56654: EQUAL
56655: IFTRUE 56671
56657: LD_INT 8
56659: DOUBLE
56660: EQUAL
56661: IFTRUE 56671
56663: LD_INT 9
56665: DOUBLE
56666: EQUAL
56667: IFTRUE 56671
56669: GO 56717
56671: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56672: LD_ADDR_VAR 0 8
56676: PUSH
56677: LD_VAR 0 2
56681: PPUSH
56682: LD_INT 2
56684: PUSH
56685: LD_INT 30
56687: PUSH
56688: LD_INT 4
56690: PUSH
56691: EMPTY
56692: LIST
56693: LIST
56694: PUSH
56695: LD_INT 30
56697: PUSH
56698: LD_INT 5
56700: PUSH
56701: EMPTY
56702: LIST
56703: LIST
56704: PUSH
56705: EMPTY
56706: LIST
56707: LIST
56708: LIST
56709: PPUSH
56710: CALL_OW 72
56714: ST_TO_ADDR
56715: GO 56718
56717: POP
// if not tmp then
56718: LD_VAR 0 8
56722: NOT
56723: IFFALSE 56727
// exit ;
56725: GO 57229
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56727: LD_VAR 0 4
56731: PUSH
56732: LD_INT 1
56734: PUSH
56735: LD_INT 15
56737: PUSH
56738: EMPTY
56739: LIST
56740: LIST
56741: IN
56742: PUSH
56743: LD_EXP 110
56747: PUSH
56748: LD_VAR 0 1
56752: ARRAY
56753: AND
56754: IFFALSE 56910
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56756: LD_ADDR_VAR 0 9
56760: PUSH
56761: LD_EXP 110
56765: PUSH
56766: LD_VAR 0 1
56770: ARRAY
56771: PUSH
56772: LD_INT 1
56774: ARRAY
56775: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56776: LD_VAR 0 9
56780: PUSH
56781: LD_EXP 111
56785: PUSH
56786: LD_VAR 0 1
56790: ARRAY
56791: IN
56792: NOT
56793: IFFALSE 56908
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56795: LD_ADDR_EXP 111
56799: PUSH
56800: LD_EXP 111
56804: PPUSH
56805: LD_VAR 0 1
56809: PUSH
56810: LD_EXP 111
56814: PUSH
56815: LD_VAR 0 1
56819: ARRAY
56820: PUSH
56821: LD_INT 1
56823: PLUS
56824: PUSH
56825: EMPTY
56826: LIST
56827: LIST
56828: PPUSH
56829: LD_VAR 0 9
56833: PPUSH
56834: CALL 71440 0 3
56838: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56839: LD_ADDR_EXP 110
56843: PUSH
56844: LD_EXP 110
56848: PPUSH
56849: LD_VAR 0 1
56853: PPUSH
56854: LD_EXP 110
56858: PUSH
56859: LD_VAR 0 1
56863: ARRAY
56864: PUSH
56865: LD_VAR 0 9
56869: DIFF
56870: PPUSH
56871: CALL_OW 1
56875: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56876: LD_VAR 0 3
56880: PPUSH
56881: LD_EXP 111
56885: PUSH
56886: LD_VAR 0 1
56890: ARRAY
56891: PUSH
56892: LD_EXP 111
56896: PUSH
56897: LD_VAR 0 1
56901: ARRAY
56902: ARRAY
56903: PPUSH
56904: CALL_OW 120
// end ; exit ;
56908: GO 57229
// end ; if tmp > 1 then
56910: LD_VAR 0 8
56914: PUSH
56915: LD_INT 1
56917: GREATER
56918: IFFALSE 57022
// for i = 2 to tmp do
56920: LD_ADDR_VAR 0 6
56924: PUSH
56925: DOUBLE
56926: LD_INT 2
56928: DEC
56929: ST_TO_ADDR
56930: LD_VAR 0 8
56934: PUSH
56935: FOR_TO
56936: IFFALSE 57020
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56938: LD_VAR 0 8
56942: PUSH
56943: LD_VAR 0 6
56947: ARRAY
56948: PPUSH
56949: CALL_OW 461
56953: PUSH
56954: LD_INT 6
56956: EQUAL
56957: IFFALSE 57018
// begin x := tmp [ i ] ;
56959: LD_ADDR_VAR 0 9
56963: PUSH
56964: LD_VAR 0 8
56968: PUSH
56969: LD_VAR 0 6
56973: ARRAY
56974: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56975: LD_ADDR_VAR 0 8
56979: PUSH
56980: LD_VAR 0 8
56984: PPUSH
56985: LD_VAR 0 6
56989: PPUSH
56990: CALL_OW 3
56994: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56995: LD_ADDR_VAR 0 8
56999: PUSH
57000: LD_VAR 0 8
57004: PPUSH
57005: LD_INT 1
57007: PPUSH
57008: LD_VAR 0 9
57012: PPUSH
57013: CALL_OW 2
57017: ST_TO_ADDR
// end ;
57018: GO 56935
57020: POP
57021: POP
// for i in tmp do
57022: LD_ADDR_VAR 0 6
57026: PUSH
57027: LD_VAR 0 8
57031: PUSH
57032: FOR_IN
57033: IFFALSE 57102
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57035: LD_VAR 0 6
57039: PPUSH
57040: CALL_OW 313
57044: PUSH
57045: LD_INT 6
57047: LESS
57048: PUSH
57049: LD_VAR 0 6
57053: PPUSH
57054: CALL_OW 266
57058: PUSH
57059: LD_INT 31
57061: PUSH
57062: LD_INT 32
57064: PUSH
57065: EMPTY
57066: LIST
57067: LIST
57068: IN
57069: NOT
57070: AND
57071: PUSH
57072: LD_VAR 0 6
57076: PPUSH
57077: CALL_OW 313
57081: PUSH
57082: LD_INT 0
57084: EQUAL
57085: OR
57086: IFFALSE 57100
// begin j := i ;
57088: LD_ADDR_VAR 0 7
57092: PUSH
57093: LD_VAR 0 6
57097: ST_TO_ADDR
// break ;
57098: GO 57102
// end ; end ;
57100: GO 57032
57102: POP
57103: POP
// if j then
57104: LD_VAR 0 7
57108: IFFALSE 57126
// ComEnterUnit ( unit , j ) else
57110: LD_VAR 0 3
57114: PPUSH
57115: LD_VAR 0 7
57119: PPUSH
57120: CALL_OW 120
57124: GO 57229
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57126: LD_ADDR_VAR 0 10
57130: PUSH
57131: LD_VAR 0 2
57135: PPUSH
57136: LD_INT 2
57138: PUSH
57139: LD_INT 30
57141: PUSH
57142: LD_INT 0
57144: PUSH
57145: EMPTY
57146: LIST
57147: LIST
57148: PUSH
57149: LD_INT 30
57151: PUSH
57152: LD_INT 1
57154: PUSH
57155: EMPTY
57156: LIST
57157: LIST
57158: PUSH
57159: EMPTY
57160: LIST
57161: LIST
57162: LIST
57163: PPUSH
57164: CALL_OW 72
57168: ST_TO_ADDR
// if depot then
57169: LD_VAR 0 10
57173: IFFALSE 57229
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57175: LD_ADDR_VAR 0 10
57179: PUSH
57180: LD_VAR 0 10
57184: PPUSH
57185: LD_VAR 0 3
57189: PPUSH
57190: CALL_OW 74
57194: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57195: LD_VAR 0 3
57199: PPUSH
57200: LD_VAR 0 10
57204: PPUSH
57205: CALL_OW 296
57209: PUSH
57210: LD_INT 10
57212: GREATER
57213: IFFALSE 57229
// ComStandNearbyBuilding ( unit , depot ) ;
57215: LD_VAR 0 3
57219: PPUSH
57220: LD_VAR 0 10
57224: PPUSH
57225: CALL 65643 0 2
// end ; end ; end ;
57229: LD_VAR 0 5
57233: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57234: LD_INT 0
57236: PPUSH
57237: PPUSH
57238: PPUSH
57239: PPUSH
// if not mc_bases then
57240: LD_EXP 101
57244: NOT
57245: IFFALSE 57249
// exit ;
57247: GO 57488
// for i = 1 to mc_bases do
57249: LD_ADDR_VAR 0 2
57253: PUSH
57254: DOUBLE
57255: LD_INT 1
57257: DEC
57258: ST_TO_ADDR
57259: LD_EXP 101
57263: PUSH
57264: FOR_TO
57265: IFFALSE 57486
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57267: LD_ADDR_VAR 0 4
57271: PUSH
57272: LD_EXP 101
57276: PUSH
57277: LD_VAR 0 2
57281: ARRAY
57282: PPUSH
57283: LD_INT 21
57285: PUSH
57286: LD_INT 1
57288: PUSH
57289: EMPTY
57290: LIST
57291: LIST
57292: PPUSH
57293: CALL_OW 72
57297: PUSH
57298: LD_EXP 130
57302: PUSH
57303: LD_VAR 0 2
57307: ARRAY
57308: UNION
57309: ST_TO_ADDR
// if not tmp then
57310: LD_VAR 0 4
57314: NOT
57315: IFFALSE 57319
// continue ;
57317: GO 57264
// for j in tmp do
57319: LD_ADDR_VAR 0 3
57323: PUSH
57324: LD_VAR 0 4
57328: PUSH
57329: FOR_IN
57330: IFFALSE 57482
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57332: LD_VAR 0 3
57336: PPUSH
57337: CALL_OW 110
57341: NOT
57342: PUSH
57343: LD_VAR 0 3
57347: PPUSH
57348: CALL_OW 314
57352: NOT
57353: AND
57354: PUSH
57355: LD_VAR 0 3
57359: PPUSH
57360: CALL_OW 311
57364: NOT
57365: AND
57366: PUSH
57367: LD_VAR 0 3
57371: PPUSH
57372: CALL_OW 310
57376: NOT
57377: AND
57378: PUSH
57379: LD_VAR 0 3
57383: PUSH
57384: LD_EXP 104
57388: PUSH
57389: LD_VAR 0 2
57393: ARRAY
57394: PUSH
57395: LD_INT 1
57397: ARRAY
57398: IN
57399: NOT
57400: AND
57401: PUSH
57402: LD_VAR 0 3
57406: PUSH
57407: LD_EXP 104
57411: PUSH
57412: LD_VAR 0 2
57416: ARRAY
57417: PUSH
57418: LD_INT 2
57420: ARRAY
57421: IN
57422: NOT
57423: AND
57424: PUSH
57425: LD_VAR 0 3
57429: PUSH
57430: LD_EXP 113
57434: PUSH
57435: LD_VAR 0 2
57439: ARRAY
57440: IN
57441: NOT
57442: AND
57443: IFFALSE 57480
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57445: LD_VAR 0 2
57449: PPUSH
57450: LD_EXP 101
57454: PUSH
57455: LD_VAR 0 2
57459: ARRAY
57460: PPUSH
57461: LD_VAR 0 3
57465: PPUSH
57466: LD_VAR 0 3
57470: PPUSH
57471: CALL_OW 257
57475: PPUSH
57476: CALL 56252 0 4
// end ;
57480: GO 57329
57482: POP
57483: POP
// end ;
57484: GO 57264
57486: POP
57487: POP
// end ;
57488: LD_VAR 0 1
57492: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57493: LD_INT 0
57495: PPUSH
57496: PPUSH
57497: PPUSH
57498: PPUSH
57499: PPUSH
57500: PPUSH
// if not mc_bases [ base ] then
57501: LD_EXP 101
57505: PUSH
57506: LD_VAR 0 1
57510: ARRAY
57511: NOT
57512: IFFALSE 57516
// exit ;
57514: GO 57698
// tmp := [ ] ;
57516: LD_ADDR_VAR 0 6
57520: PUSH
57521: EMPTY
57522: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57523: LD_ADDR_VAR 0 7
57527: PUSH
57528: LD_VAR 0 3
57532: PPUSH
57533: LD_INT 0
57535: PPUSH
57536: CALL_OW 517
57540: ST_TO_ADDR
// if not list then
57541: LD_VAR 0 7
57545: NOT
57546: IFFALSE 57550
// exit ;
57548: GO 57698
// for i = 1 to amount do
57550: LD_ADDR_VAR 0 5
57554: PUSH
57555: DOUBLE
57556: LD_INT 1
57558: DEC
57559: ST_TO_ADDR
57560: LD_VAR 0 2
57564: PUSH
57565: FOR_TO
57566: IFFALSE 57646
// begin x := rand ( 1 , list [ 1 ] ) ;
57568: LD_ADDR_VAR 0 8
57572: PUSH
57573: LD_INT 1
57575: PPUSH
57576: LD_VAR 0 7
57580: PUSH
57581: LD_INT 1
57583: ARRAY
57584: PPUSH
57585: CALL_OW 12
57589: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57590: LD_ADDR_VAR 0 6
57594: PUSH
57595: LD_VAR 0 6
57599: PPUSH
57600: LD_VAR 0 5
57604: PPUSH
57605: LD_VAR 0 7
57609: PUSH
57610: LD_INT 1
57612: ARRAY
57613: PUSH
57614: LD_VAR 0 8
57618: ARRAY
57619: PUSH
57620: LD_VAR 0 7
57624: PUSH
57625: LD_INT 2
57627: ARRAY
57628: PUSH
57629: LD_VAR 0 8
57633: ARRAY
57634: PUSH
57635: EMPTY
57636: LIST
57637: LIST
57638: PPUSH
57639: CALL_OW 1
57643: ST_TO_ADDR
// end ;
57644: GO 57565
57646: POP
57647: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57648: LD_ADDR_EXP 114
57652: PUSH
57653: LD_EXP 114
57657: PPUSH
57658: LD_VAR 0 1
57662: PPUSH
57663: LD_VAR 0 6
57667: PPUSH
57668: CALL_OW 1
57672: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57673: LD_ADDR_EXP 116
57677: PUSH
57678: LD_EXP 116
57682: PPUSH
57683: LD_VAR 0 1
57687: PPUSH
57688: LD_VAR 0 3
57692: PPUSH
57693: CALL_OW 1
57697: ST_TO_ADDR
// end ;
57698: LD_VAR 0 4
57702: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57703: LD_INT 0
57705: PPUSH
// if not mc_bases [ base ] then
57706: LD_EXP 101
57710: PUSH
57711: LD_VAR 0 1
57715: ARRAY
57716: NOT
57717: IFFALSE 57721
// exit ;
57719: GO 57746
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57721: LD_ADDR_EXP 106
57725: PUSH
57726: LD_EXP 106
57730: PPUSH
57731: LD_VAR 0 1
57735: PPUSH
57736: LD_VAR 0 2
57740: PPUSH
57741: CALL_OW 1
57745: ST_TO_ADDR
// end ;
57746: LD_VAR 0 3
57750: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57751: LD_INT 0
57753: PPUSH
// if not mc_bases [ base ] then
57754: LD_EXP 101
57758: PUSH
57759: LD_VAR 0 1
57763: ARRAY
57764: NOT
57765: IFFALSE 57769
// exit ;
57767: GO 57806
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57769: LD_ADDR_EXP 106
57773: PUSH
57774: LD_EXP 106
57778: PPUSH
57779: LD_VAR 0 1
57783: PPUSH
57784: LD_EXP 106
57788: PUSH
57789: LD_VAR 0 1
57793: ARRAY
57794: PUSH
57795: LD_VAR 0 2
57799: UNION
57800: PPUSH
57801: CALL_OW 1
57805: ST_TO_ADDR
// end ;
57806: LD_VAR 0 3
57810: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57811: LD_INT 0
57813: PPUSH
// if not mc_bases [ base ] then
57814: LD_EXP 101
57818: PUSH
57819: LD_VAR 0 1
57823: ARRAY
57824: NOT
57825: IFFALSE 57829
// exit ;
57827: GO 57854
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57829: LD_ADDR_EXP 122
57833: PUSH
57834: LD_EXP 122
57838: PPUSH
57839: LD_VAR 0 1
57843: PPUSH
57844: LD_VAR 0 2
57848: PPUSH
57849: CALL_OW 1
57853: ST_TO_ADDR
// end ;
57854: LD_VAR 0 3
57858: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57859: LD_INT 0
57861: PPUSH
// if not mc_bases [ base ] then
57862: LD_EXP 101
57866: PUSH
57867: LD_VAR 0 1
57871: ARRAY
57872: NOT
57873: IFFALSE 57877
// exit ;
57875: GO 57914
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57877: LD_ADDR_EXP 122
57881: PUSH
57882: LD_EXP 122
57886: PPUSH
57887: LD_VAR 0 1
57891: PPUSH
57892: LD_EXP 122
57896: PUSH
57897: LD_VAR 0 1
57901: ARRAY
57902: PUSH
57903: LD_VAR 0 2
57907: ADD
57908: PPUSH
57909: CALL_OW 1
57913: ST_TO_ADDR
// end ;
57914: LD_VAR 0 3
57918: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57919: LD_INT 0
57921: PPUSH
// if not mc_bases [ base ] then
57922: LD_EXP 101
57926: PUSH
57927: LD_VAR 0 1
57931: ARRAY
57932: NOT
57933: IFFALSE 57937
// exit ;
57935: GO 57991
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57937: LD_ADDR_EXP 123
57941: PUSH
57942: LD_EXP 123
57946: PPUSH
57947: LD_VAR 0 1
57951: PPUSH
57952: LD_VAR 0 2
57956: PPUSH
57957: CALL_OW 1
57961: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57962: LD_ADDR_EXP 112
57966: PUSH
57967: LD_EXP 112
57971: PPUSH
57972: LD_VAR 0 1
57976: PPUSH
57977: LD_VAR 0 2
57981: PUSH
57982: LD_INT 0
57984: PLUS
57985: PPUSH
57986: CALL_OW 1
57990: ST_TO_ADDR
// end ;
57991: LD_VAR 0 3
57995: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57996: LD_INT 0
57998: PPUSH
// if not mc_bases [ base ] then
57999: LD_EXP 101
58003: PUSH
58004: LD_VAR 0 1
58008: ARRAY
58009: NOT
58010: IFFALSE 58014
// exit ;
58012: GO 58039
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58014: LD_ADDR_EXP 112
58018: PUSH
58019: LD_EXP 112
58023: PPUSH
58024: LD_VAR 0 1
58028: PPUSH
58029: LD_VAR 0 2
58033: PPUSH
58034: CALL_OW 1
58038: ST_TO_ADDR
// end ;
58039: LD_VAR 0 3
58043: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58044: LD_INT 0
58046: PPUSH
58047: PPUSH
58048: PPUSH
58049: PPUSH
// if not mc_bases [ base ] then
58050: LD_EXP 101
58054: PUSH
58055: LD_VAR 0 1
58059: ARRAY
58060: NOT
58061: IFFALSE 58065
// exit ;
58063: GO 58130
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58065: LD_ADDR_EXP 121
58069: PUSH
58070: LD_EXP 121
58074: PPUSH
58075: LD_VAR 0 1
58079: PUSH
58080: LD_EXP 121
58084: PUSH
58085: LD_VAR 0 1
58089: ARRAY
58090: PUSH
58091: LD_INT 1
58093: PLUS
58094: PUSH
58095: EMPTY
58096: LIST
58097: LIST
58098: PPUSH
58099: LD_VAR 0 1
58103: PUSH
58104: LD_VAR 0 2
58108: PUSH
58109: LD_VAR 0 3
58113: PUSH
58114: LD_VAR 0 4
58118: PUSH
58119: EMPTY
58120: LIST
58121: LIST
58122: LIST
58123: LIST
58124: PPUSH
58125: CALL 71440 0 3
58129: ST_TO_ADDR
// end ;
58130: LD_VAR 0 5
58134: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58135: LD_INT 0
58137: PPUSH
// if not mc_bases [ base ] then
58138: LD_EXP 101
58142: PUSH
58143: LD_VAR 0 1
58147: ARRAY
58148: NOT
58149: IFFALSE 58153
// exit ;
58151: GO 58178
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58153: LD_ADDR_EXP 138
58157: PUSH
58158: LD_EXP 138
58162: PPUSH
58163: LD_VAR 0 1
58167: PPUSH
58168: LD_VAR 0 2
58172: PPUSH
58173: CALL_OW 1
58177: ST_TO_ADDR
// end ;
58178: LD_VAR 0 3
58182: RET
// export function MC_GetMinesField ( base ) ; begin
58183: LD_INT 0
58185: PPUSH
// result := mc_mines [ base ] ;
58186: LD_ADDR_VAR 0 2
58190: PUSH
58191: LD_EXP 114
58195: PUSH
58196: LD_VAR 0 1
58200: ARRAY
58201: ST_TO_ADDR
// end ;
58202: LD_VAR 0 2
58206: RET
// export function MC_GetProduceList ( base ) ; begin
58207: LD_INT 0
58209: PPUSH
// result := mc_produce [ base ] ;
58210: LD_ADDR_VAR 0 2
58214: PUSH
58215: LD_EXP 122
58219: PUSH
58220: LD_VAR 0 1
58224: ARRAY
58225: ST_TO_ADDR
// end ;
58226: LD_VAR 0 2
58230: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58231: LD_INT 0
58233: PPUSH
58234: PPUSH
// if not mc_bases then
58235: LD_EXP 101
58239: NOT
58240: IFFALSE 58244
// exit ;
58242: GO 58309
// if mc_bases [ base ] then
58244: LD_EXP 101
58248: PUSH
58249: LD_VAR 0 1
58253: ARRAY
58254: IFFALSE 58309
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58256: LD_ADDR_VAR 0 3
58260: PUSH
58261: LD_EXP 101
58265: PUSH
58266: LD_VAR 0 1
58270: ARRAY
58271: PPUSH
58272: LD_INT 30
58274: PUSH
58275: LD_VAR 0 2
58279: PUSH
58280: EMPTY
58281: LIST
58282: LIST
58283: PPUSH
58284: CALL_OW 72
58288: ST_TO_ADDR
// if result then
58289: LD_VAR 0 3
58293: IFFALSE 58309
// result := result [ 1 ] ;
58295: LD_ADDR_VAR 0 3
58299: PUSH
58300: LD_VAR 0 3
58304: PUSH
58305: LD_INT 1
58307: ARRAY
58308: ST_TO_ADDR
// end ; end ;
58309: LD_VAR 0 3
58313: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58314: LD_INT 0
58316: PPUSH
58317: PPUSH
// if not mc_bases then
58318: LD_EXP 101
58322: NOT
58323: IFFALSE 58327
// exit ;
58325: GO 58372
// if mc_bases [ base ] then
58327: LD_EXP 101
58331: PUSH
58332: LD_VAR 0 1
58336: ARRAY
58337: IFFALSE 58372
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58339: LD_ADDR_VAR 0 3
58343: PUSH
58344: LD_EXP 101
58348: PUSH
58349: LD_VAR 0 1
58353: ARRAY
58354: PPUSH
58355: LD_INT 30
58357: PUSH
58358: LD_VAR 0 2
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: PPUSH
58367: CALL_OW 72
58371: ST_TO_ADDR
// end ;
58372: LD_VAR 0 3
58376: RET
// export function MC_SetTame ( base , area ) ; begin
58377: LD_INT 0
58379: PPUSH
// if not mc_bases or not base then
58380: LD_EXP 101
58384: NOT
58385: PUSH
58386: LD_VAR 0 1
58390: NOT
58391: OR
58392: IFFALSE 58396
// exit ;
58394: GO 58421
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58396: LD_ADDR_EXP 129
58400: PUSH
58401: LD_EXP 129
58405: PPUSH
58406: LD_VAR 0 1
58410: PPUSH
58411: LD_VAR 0 2
58415: PPUSH
58416: CALL_OW 1
58420: ST_TO_ADDR
// end ;
58421: LD_VAR 0 3
58425: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58426: LD_INT 0
58428: PPUSH
58429: PPUSH
// if not mc_bases or not base then
58430: LD_EXP 101
58434: NOT
58435: PUSH
58436: LD_VAR 0 1
58440: NOT
58441: OR
58442: IFFALSE 58446
// exit ;
58444: GO 58548
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58446: LD_ADDR_VAR 0 4
58450: PUSH
58451: LD_EXP 101
58455: PUSH
58456: LD_VAR 0 1
58460: ARRAY
58461: PPUSH
58462: LD_INT 30
58464: PUSH
58465: LD_VAR 0 2
58469: PUSH
58470: EMPTY
58471: LIST
58472: LIST
58473: PPUSH
58474: CALL_OW 72
58478: ST_TO_ADDR
// if not tmp then
58479: LD_VAR 0 4
58483: NOT
58484: IFFALSE 58488
// exit ;
58486: GO 58548
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58488: LD_ADDR_EXP 133
58492: PUSH
58493: LD_EXP 133
58497: PPUSH
58498: LD_VAR 0 1
58502: PPUSH
58503: LD_EXP 133
58507: PUSH
58508: LD_VAR 0 1
58512: ARRAY
58513: PPUSH
58514: LD_EXP 133
58518: PUSH
58519: LD_VAR 0 1
58523: ARRAY
58524: PUSH
58525: LD_INT 1
58527: PLUS
58528: PPUSH
58529: LD_VAR 0 4
58533: PUSH
58534: LD_INT 1
58536: ARRAY
58537: PPUSH
58538: CALL_OW 2
58542: PPUSH
58543: CALL_OW 1
58547: ST_TO_ADDR
// end ;
58548: LD_VAR 0 3
58552: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58553: LD_INT 0
58555: PPUSH
58556: PPUSH
// if not mc_bases or not base or not kinds then
58557: LD_EXP 101
58561: NOT
58562: PUSH
58563: LD_VAR 0 1
58567: NOT
58568: OR
58569: PUSH
58570: LD_VAR 0 2
58574: NOT
58575: OR
58576: IFFALSE 58580
// exit ;
58578: GO 58641
// for i in kinds do
58580: LD_ADDR_VAR 0 4
58584: PUSH
58585: LD_VAR 0 2
58589: PUSH
58590: FOR_IN
58591: IFFALSE 58639
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58593: LD_ADDR_EXP 135
58597: PUSH
58598: LD_EXP 135
58602: PPUSH
58603: LD_VAR 0 1
58607: PUSH
58608: LD_EXP 135
58612: PUSH
58613: LD_VAR 0 1
58617: ARRAY
58618: PUSH
58619: LD_INT 1
58621: PLUS
58622: PUSH
58623: EMPTY
58624: LIST
58625: LIST
58626: PPUSH
58627: LD_VAR 0 4
58631: PPUSH
58632: CALL 71440 0 3
58636: ST_TO_ADDR
58637: GO 58590
58639: POP
58640: POP
// end ;
58641: LD_VAR 0 3
58645: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58646: LD_INT 0
58648: PPUSH
// if not mc_bases or not base or not areas then
58649: LD_EXP 101
58653: NOT
58654: PUSH
58655: LD_VAR 0 1
58659: NOT
58660: OR
58661: PUSH
58662: LD_VAR 0 2
58666: NOT
58667: OR
58668: IFFALSE 58672
// exit ;
58670: GO 58697
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58672: LD_ADDR_EXP 119
58676: PUSH
58677: LD_EXP 119
58681: PPUSH
58682: LD_VAR 0 1
58686: PPUSH
58687: LD_VAR 0 2
58691: PPUSH
58692: CALL_OW 1
58696: ST_TO_ADDR
// end ;
58697: LD_VAR 0 3
58701: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58702: LD_INT 0
58704: PPUSH
// if not mc_bases or not base or not teleports_exit then
58705: LD_EXP 101
58709: NOT
58710: PUSH
58711: LD_VAR 0 1
58715: NOT
58716: OR
58717: PUSH
58718: LD_VAR 0 2
58722: NOT
58723: OR
58724: IFFALSE 58728
// exit ;
58726: GO 58753
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58728: LD_ADDR_EXP 136
58732: PUSH
58733: LD_EXP 136
58737: PPUSH
58738: LD_VAR 0 1
58742: PPUSH
58743: LD_VAR 0 2
58747: PPUSH
58748: CALL_OW 1
58752: ST_TO_ADDR
// end ;
58753: LD_VAR 0 3
58757: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58758: LD_INT 0
58760: PPUSH
58761: PPUSH
58762: PPUSH
// if not mc_bases or not base or not ext_list then
58763: LD_EXP 101
58767: NOT
58768: PUSH
58769: LD_VAR 0 1
58773: NOT
58774: OR
58775: PUSH
58776: LD_VAR 0 5
58780: NOT
58781: OR
58782: IFFALSE 58786
// exit ;
58784: GO 58959
// tmp := GetFacExtXYD ( x , y , d ) ;
58786: LD_ADDR_VAR 0 8
58790: PUSH
58791: LD_VAR 0 2
58795: PPUSH
58796: LD_VAR 0 3
58800: PPUSH
58801: LD_VAR 0 4
58805: PPUSH
58806: CALL 104818 0 3
58810: ST_TO_ADDR
// if not tmp then
58811: LD_VAR 0 8
58815: NOT
58816: IFFALSE 58820
// exit ;
58818: GO 58959
// for i in tmp do
58820: LD_ADDR_VAR 0 7
58824: PUSH
58825: LD_VAR 0 8
58829: PUSH
58830: FOR_IN
58831: IFFALSE 58957
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58833: LD_ADDR_EXP 106
58837: PUSH
58838: LD_EXP 106
58842: PPUSH
58843: LD_VAR 0 1
58847: PPUSH
58848: LD_EXP 106
58852: PUSH
58853: LD_VAR 0 1
58857: ARRAY
58858: PPUSH
58859: LD_EXP 106
58863: PUSH
58864: LD_VAR 0 1
58868: ARRAY
58869: PUSH
58870: LD_INT 1
58872: PLUS
58873: PPUSH
58874: LD_VAR 0 5
58878: PUSH
58879: LD_INT 1
58881: ARRAY
58882: PUSH
58883: LD_VAR 0 7
58887: PUSH
58888: LD_INT 1
58890: ARRAY
58891: PUSH
58892: LD_VAR 0 7
58896: PUSH
58897: LD_INT 2
58899: ARRAY
58900: PUSH
58901: LD_VAR 0 7
58905: PUSH
58906: LD_INT 3
58908: ARRAY
58909: PUSH
58910: EMPTY
58911: LIST
58912: LIST
58913: LIST
58914: LIST
58915: PPUSH
58916: CALL_OW 2
58920: PPUSH
58921: CALL_OW 1
58925: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58926: LD_ADDR_VAR 0 5
58930: PUSH
58931: LD_VAR 0 5
58935: PPUSH
58936: LD_INT 1
58938: PPUSH
58939: CALL_OW 3
58943: ST_TO_ADDR
// if not ext_list then
58944: LD_VAR 0 5
58948: NOT
58949: IFFALSE 58955
// exit ;
58951: POP
58952: POP
58953: GO 58959
// end ;
58955: GO 58830
58957: POP
58958: POP
// end ;
58959: LD_VAR 0 6
58963: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58964: LD_INT 0
58966: PPUSH
// if not mc_bases or not base or not weapon_list then
58967: LD_EXP 101
58971: NOT
58972: PUSH
58973: LD_VAR 0 1
58977: NOT
58978: OR
58979: PUSH
58980: LD_VAR 0 2
58984: NOT
58985: OR
58986: IFFALSE 58990
// exit ;
58988: GO 59015
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58990: LD_ADDR_EXP 140
58994: PUSH
58995: LD_EXP 140
58999: PPUSH
59000: LD_VAR 0 1
59004: PPUSH
59005: LD_VAR 0 2
59009: PPUSH
59010: CALL_OW 1
59014: ST_TO_ADDR
// end ;
59015: LD_VAR 0 3
59019: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59020: LD_INT 0
59022: PPUSH
// if not mc_bases or not base or not tech_list then
59023: LD_EXP 101
59027: NOT
59028: PUSH
59029: LD_VAR 0 1
59033: NOT
59034: OR
59035: PUSH
59036: LD_VAR 0 2
59040: NOT
59041: OR
59042: IFFALSE 59046
// exit ;
59044: GO 59071
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59046: LD_ADDR_EXP 128
59050: PUSH
59051: LD_EXP 128
59055: PPUSH
59056: LD_VAR 0 1
59060: PPUSH
59061: LD_VAR 0 2
59065: PPUSH
59066: CALL_OW 1
59070: ST_TO_ADDR
// end ;
59071: LD_VAR 0 3
59075: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59076: LD_INT 0
59078: PPUSH
// if not mc_bases or not parking_area or not base then
59079: LD_EXP 101
59083: NOT
59084: PUSH
59085: LD_VAR 0 2
59089: NOT
59090: OR
59091: PUSH
59092: LD_VAR 0 1
59096: NOT
59097: OR
59098: IFFALSE 59102
// exit ;
59100: GO 59127
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59102: LD_ADDR_EXP 125
59106: PUSH
59107: LD_EXP 125
59111: PPUSH
59112: LD_VAR 0 1
59116: PPUSH
59117: LD_VAR 0 2
59121: PPUSH
59122: CALL_OW 1
59126: ST_TO_ADDR
// end ;
59127: LD_VAR 0 3
59131: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59132: LD_INT 0
59134: PPUSH
// if not mc_bases or not base or not scan_area then
59135: LD_EXP 101
59139: NOT
59140: PUSH
59141: LD_VAR 0 1
59145: NOT
59146: OR
59147: PUSH
59148: LD_VAR 0 2
59152: NOT
59153: OR
59154: IFFALSE 59158
// exit ;
59156: GO 59183
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59158: LD_ADDR_EXP 126
59162: PUSH
59163: LD_EXP 126
59167: PPUSH
59168: LD_VAR 0 1
59172: PPUSH
59173: LD_VAR 0 2
59177: PPUSH
59178: CALL_OW 1
59182: ST_TO_ADDR
// end ;
59183: LD_VAR 0 3
59187: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59188: LD_INT 0
59190: PPUSH
59191: PPUSH
// if not mc_bases or not base then
59192: LD_EXP 101
59196: NOT
59197: PUSH
59198: LD_VAR 0 1
59202: NOT
59203: OR
59204: IFFALSE 59208
// exit ;
59206: GO 59272
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59208: LD_ADDR_VAR 0 3
59212: PUSH
59213: LD_INT 1
59215: PUSH
59216: LD_INT 2
59218: PUSH
59219: LD_INT 3
59221: PUSH
59222: LD_INT 4
59224: PUSH
59225: LD_INT 11
59227: PUSH
59228: EMPTY
59229: LIST
59230: LIST
59231: LIST
59232: LIST
59233: LIST
59234: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59235: LD_ADDR_EXP 128
59239: PUSH
59240: LD_EXP 128
59244: PPUSH
59245: LD_VAR 0 1
59249: PPUSH
59250: LD_EXP 128
59254: PUSH
59255: LD_VAR 0 1
59259: ARRAY
59260: PUSH
59261: LD_VAR 0 3
59265: DIFF
59266: PPUSH
59267: CALL_OW 1
59271: ST_TO_ADDR
// end ;
59272: LD_VAR 0 2
59276: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59277: LD_INT 0
59279: PPUSH
// result := mc_vehicles [ base ] ;
59280: LD_ADDR_VAR 0 3
59284: PUSH
59285: LD_EXP 120
59289: PUSH
59290: LD_VAR 0 1
59294: ARRAY
59295: ST_TO_ADDR
// if onlyCombat then
59296: LD_VAR 0 2
59300: IFFALSE 59465
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59302: LD_ADDR_VAR 0 3
59306: PUSH
59307: LD_VAR 0 3
59311: PUSH
59312: LD_VAR 0 3
59316: PPUSH
59317: LD_INT 2
59319: PUSH
59320: LD_INT 34
59322: PUSH
59323: LD_INT 12
59325: PUSH
59326: EMPTY
59327: LIST
59328: LIST
59329: PUSH
59330: LD_INT 34
59332: PUSH
59333: LD_INT 51
59335: PUSH
59336: EMPTY
59337: LIST
59338: LIST
59339: PUSH
59340: LD_INT 34
59342: PUSH
59343: LD_EXP 95
59347: PUSH
59348: EMPTY
59349: LIST
59350: LIST
59351: PUSH
59352: LD_INT 34
59354: PUSH
59355: LD_INT 32
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: PUSH
59362: LD_INT 34
59364: PUSH
59365: LD_INT 13
59367: PUSH
59368: EMPTY
59369: LIST
59370: LIST
59371: PUSH
59372: LD_INT 34
59374: PUSH
59375: LD_INT 52
59377: PUSH
59378: EMPTY
59379: LIST
59380: LIST
59381: PUSH
59382: LD_INT 34
59384: PUSH
59385: LD_INT 14
59387: PUSH
59388: EMPTY
59389: LIST
59390: LIST
59391: PUSH
59392: LD_INT 34
59394: PUSH
59395: LD_INT 53
59397: PUSH
59398: EMPTY
59399: LIST
59400: LIST
59401: PUSH
59402: LD_INT 34
59404: PUSH
59405: LD_EXP 94
59409: PUSH
59410: EMPTY
59411: LIST
59412: LIST
59413: PUSH
59414: LD_INT 34
59416: PUSH
59417: LD_INT 31
59419: PUSH
59420: EMPTY
59421: LIST
59422: LIST
59423: PUSH
59424: LD_INT 34
59426: PUSH
59427: LD_INT 48
59429: PUSH
59430: EMPTY
59431: LIST
59432: LIST
59433: PUSH
59434: LD_INT 34
59436: PUSH
59437: LD_INT 8
59439: PUSH
59440: EMPTY
59441: LIST
59442: LIST
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: LIST
59448: LIST
59449: LIST
59450: LIST
59451: LIST
59452: LIST
59453: LIST
59454: LIST
59455: LIST
59456: LIST
59457: LIST
59458: PPUSH
59459: CALL_OW 72
59463: DIFF
59464: ST_TO_ADDR
// end ; end_of_file
59465: LD_VAR 0 3
59469: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59470: LD_INT 0
59472: PPUSH
59473: PPUSH
59474: PPUSH
// if not mc_bases or not skirmish then
59475: LD_EXP 101
59479: NOT
59480: PUSH
59481: LD_EXP 99
59485: NOT
59486: OR
59487: IFFALSE 59491
// exit ;
59489: GO 59656
// for i = 1 to mc_bases do
59491: LD_ADDR_VAR 0 4
59495: PUSH
59496: DOUBLE
59497: LD_INT 1
59499: DEC
59500: ST_TO_ADDR
59501: LD_EXP 101
59505: PUSH
59506: FOR_TO
59507: IFFALSE 59654
// begin if sci in mc_bases [ i ] then
59509: LD_VAR 0 2
59513: PUSH
59514: LD_EXP 101
59518: PUSH
59519: LD_VAR 0 4
59523: ARRAY
59524: IN
59525: IFFALSE 59652
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59527: LD_ADDR_EXP 130
59531: PUSH
59532: LD_EXP 130
59536: PPUSH
59537: LD_VAR 0 4
59541: PUSH
59542: LD_EXP 130
59546: PUSH
59547: LD_VAR 0 4
59551: ARRAY
59552: PUSH
59553: LD_INT 1
59555: PLUS
59556: PUSH
59557: EMPTY
59558: LIST
59559: LIST
59560: PPUSH
59561: LD_VAR 0 1
59565: PPUSH
59566: CALL 71440 0 3
59570: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59571: LD_ADDR_VAR 0 5
59575: PUSH
59576: LD_EXP 101
59580: PUSH
59581: LD_VAR 0 4
59585: ARRAY
59586: PPUSH
59587: LD_INT 2
59589: PUSH
59590: LD_INT 30
59592: PUSH
59593: LD_INT 0
59595: PUSH
59596: EMPTY
59597: LIST
59598: LIST
59599: PUSH
59600: LD_INT 30
59602: PUSH
59603: LD_INT 1
59605: PUSH
59606: EMPTY
59607: LIST
59608: LIST
59609: PUSH
59610: EMPTY
59611: LIST
59612: LIST
59613: LIST
59614: PPUSH
59615: CALL_OW 72
59619: PPUSH
59620: LD_VAR 0 1
59624: PPUSH
59625: CALL_OW 74
59629: ST_TO_ADDR
// if tmp then
59630: LD_VAR 0 5
59634: IFFALSE 59650
// ComStandNearbyBuilding ( ape , tmp ) ;
59636: LD_VAR 0 1
59640: PPUSH
59641: LD_VAR 0 5
59645: PPUSH
59646: CALL 65643 0 2
// break ;
59650: GO 59654
// end ; end ;
59652: GO 59506
59654: POP
59655: POP
// end ;
59656: LD_VAR 0 3
59660: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59661: LD_INT 0
59663: PPUSH
59664: PPUSH
59665: PPUSH
// if not mc_bases or not skirmish then
59666: LD_EXP 101
59670: NOT
59671: PUSH
59672: LD_EXP 99
59676: NOT
59677: OR
59678: IFFALSE 59682
// exit ;
59680: GO 59771
// for i = 1 to mc_bases do
59682: LD_ADDR_VAR 0 4
59686: PUSH
59687: DOUBLE
59688: LD_INT 1
59690: DEC
59691: ST_TO_ADDR
59692: LD_EXP 101
59696: PUSH
59697: FOR_TO
59698: IFFALSE 59769
// begin if building in mc_busy_turret_list [ i ] then
59700: LD_VAR 0 1
59704: PUSH
59705: LD_EXP 111
59709: PUSH
59710: LD_VAR 0 4
59714: ARRAY
59715: IN
59716: IFFALSE 59767
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59718: LD_ADDR_VAR 0 5
59722: PUSH
59723: LD_EXP 111
59727: PUSH
59728: LD_VAR 0 4
59732: ARRAY
59733: PUSH
59734: LD_VAR 0 1
59738: DIFF
59739: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59740: LD_ADDR_EXP 111
59744: PUSH
59745: LD_EXP 111
59749: PPUSH
59750: LD_VAR 0 4
59754: PPUSH
59755: LD_VAR 0 5
59759: PPUSH
59760: CALL_OW 1
59764: ST_TO_ADDR
// break ;
59765: GO 59769
// end ; end ;
59767: GO 59697
59769: POP
59770: POP
// end ;
59771: LD_VAR 0 3
59775: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59776: LD_INT 0
59778: PPUSH
59779: PPUSH
59780: PPUSH
// if not mc_bases or not skirmish then
59781: LD_EXP 101
59785: NOT
59786: PUSH
59787: LD_EXP 99
59791: NOT
59792: OR
59793: IFFALSE 59797
// exit ;
59795: GO 59996
// for i = 1 to mc_bases do
59797: LD_ADDR_VAR 0 5
59801: PUSH
59802: DOUBLE
59803: LD_INT 1
59805: DEC
59806: ST_TO_ADDR
59807: LD_EXP 101
59811: PUSH
59812: FOR_TO
59813: IFFALSE 59994
// if building in mc_bases [ i ] then
59815: LD_VAR 0 1
59819: PUSH
59820: LD_EXP 101
59824: PUSH
59825: LD_VAR 0 5
59829: ARRAY
59830: IN
59831: IFFALSE 59992
// begin tmp := mc_bases [ i ] diff building ;
59833: LD_ADDR_VAR 0 6
59837: PUSH
59838: LD_EXP 101
59842: PUSH
59843: LD_VAR 0 5
59847: ARRAY
59848: PUSH
59849: LD_VAR 0 1
59853: DIFF
59854: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59855: LD_ADDR_EXP 101
59859: PUSH
59860: LD_EXP 101
59864: PPUSH
59865: LD_VAR 0 5
59869: PPUSH
59870: LD_VAR 0 6
59874: PPUSH
59875: CALL_OW 1
59879: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59880: LD_VAR 0 1
59884: PUSH
59885: LD_EXP 109
59889: PUSH
59890: LD_VAR 0 5
59894: ARRAY
59895: IN
59896: IFFALSE 59935
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59898: LD_ADDR_EXP 109
59902: PUSH
59903: LD_EXP 109
59907: PPUSH
59908: LD_VAR 0 5
59912: PPUSH
59913: LD_EXP 109
59917: PUSH
59918: LD_VAR 0 5
59922: ARRAY
59923: PUSH
59924: LD_VAR 0 1
59928: DIFF
59929: PPUSH
59930: CALL_OW 1
59934: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
59935: LD_VAR 0 1
59939: PUSH
59940: LD_EXP 110
59944: PUSH
59945: LD_VAR 0 5
59949: ARRAY
59950: IN
59951: IFFALSE 59990
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
59953: LD_ADDR_EXP 110
59957: PUSH
59958: LD_EXP 110
59962: PPUSH
59963: LD_VAR 0 5
59967: PPUSH
59968: LD_EXP 110
59972: PUSH
59973: LD_VAR 0 5
59977: ARRAY
59978: PUSH
59979: LD_VAR 0 1
59983: DIFF
59984: PPUSH
59985: CALL_OW 1
59989: ST_TO_ADDR
// break ;
59990: GO 59994
// end ;
59992: GO 59812
59994: POP
59995: POP
// end ;
59996: LD_VAR 0 4
60000: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60001: LD_INT 0
60003: PPUSH
60004: PPUSH
60005: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60006: LD_EXP 101
60010: NOT
60011: PUSH
60012: LD_EXP 99
60016: NOT
60017: OR
60018: PUSH
60019: LD_VAR 0 3
60023: PUSH
60024: LD_EXP 127
60028: IN
60029: NOT
60030: OR
60031: IFFALSE 60035
// exit ;
60033: GO 60158
// for i = 1 to mc_vehicles do
60035: LD_ADDR_VAR 0 6
60039: PUSH
60040: DOUBLE
60041: LD_INT 1
60043: DEC
60044: ST_TO_ADDR
60045: LD_EXP 120
60049: PUSH
60050: FOR_TO
60051: IFFALSE 60156
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60053: LD_VAR 0 2
60057: PUSH
60058: LD_EXP 120
60062: PUSH
60063: LD_VAR 0 6
60067: ARRAY
60068: IN
60069: PUSH
60070: LD_VAR 0 1
60074: PUSH
60075: LD_EXP 120
60079: PUSH
60080: LD_VAR 0 6
60084: ARRAY
60085: IN
60086: OR
60087: IFFALSE 60154
// begin tmp := mc_vehicles [ i ] diff old ;
60089: LD_ADDR_VAR 0 7
60093: PUSH
60094: LD_EXP 120
60098: PUSH
60099: LD_VAR 0 6
60103: ARRAY
60104: PUSH
60105: LD_VAR 0 2
60109: DIFF
60110: ST_TO_ADDR
// tmp := tmp diff new ;
60111: LD_ADDR_VAR 0 7
60115: PUSH
60116: LD_VAR 0 7
60120: PUSH
60121: LD_VAR 0 1
60125: DIFF
60126: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60127: LD_ADDR_EXP 120
60131: PUSH
60132: LD_EXP 120
60136: PPUSH
60137: LD_VAR 0 6
60141: PPUSH
60142: LD_VAR 0 7
60146: PPUSH
60147: CALL_OW 1
60151: ST_TO_ADDR
// break ;
60152: GO 60156
// end ;
60154: GO 60050
60156: POP
60157: POP
// end ;
60158: LD_VAR 0 5
60162: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60163: LD_INT 0
60165: PPUSH
60166: PPUSH
60167: PPUSH
60168: PPUSH
// if not mc_bases or not skirmish then
60169: LD_EXP 101
60173: NOT
60174: PUSH
60175: LD_EXP 99
60179: NOT
60180: OR
60181: IFFALSE 60185
// exit ;
60183: GO 60562
// side := GetSide ( vehicle ) ;
60185: LD_ADDR_VAR 0 5
60189: PUSH
60190: LD_VAR 0 1
60194: PPUSH
60195: CALL_OW 255
60199: ST_TO_ADDR
// for i = 1 to mc_bases do
60200: LD_ADDR_VAR 0 4
60204: PUSH
60205: DOUBLE
60206: LD_INT 1
60208: DEC
60209: ST_TO_ADDR
60210: LD_EXP 101
60214: PUSH
60215: FOR_TO
60216: IFFALSE 60560
// begin if factory in mc_bases [ i ] then
60218: LD_VAR 0 2
60222: PUSH
60223: LD_EXP 101
60227: PUSH
60228: LD_VAR 0 4
60232: ARRAY
60233: IN
60234: IFFALSE 60558
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60236: LD_EXP 123
60240: PUSH
60241: LD_VAR 0 4
60245: ARRAY
60246: PUSH
60247: LD_EXP 112
60251: PUSH
60252: LD_VAR 0 4
60256: ARRAY
60257: LESS
60258: PUSH
60259: LD_VAR 0 1
60263: PPUSH
60264: CALL_OW 264
60268: PUSH
60269: LD_INT 31
60271: PUSH
60272: LD_INT 32
60274: PUSH
60275: LD_INT 51
60277: PUSH
60278: LD_EXP 95
60282: PUSH
60283: LD_INT 12
60285: PUSH
60286: LD_INT 30
60288: PUSH
60289: LD_EXP 94
60293: PUSH
60294: LD_INT 11
60296: PUSH
60297: LD_INT 53
60299: PUSH
60300: LD_INT 14
60302: PUSH
60303: LD_EXP 98
60307: PUSH
60308: LD_INT 29
60310: PUSH
60311: LD_EXP 96
60315: PUSH
60316: LD_INT 13
60318: PUSH
60319: LD_INT 52
60321: PUSH
60322: LD_INT 48
60324: PUSH
60325: LD_INT 8
60327: PUSH
60328: EMPTY
60329: LIST
60330: LIST
60331: LIST
60332: LIST
60333: LIST
60334: LIST
60335: LIST
60336: LIST
60337: LIST
60338: LIST
60339: LIST
60340: LIST
60341: LIST
60342: LIST
60343: LIST
60344: LIST
60345: LIST
60346: IN
60347: NOT
60348: AND
60349: IFFALSE 60397
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60351: LD_ADDR_EXP 123
60355: PUSH
60356: LD_EXP 123
60360: PPUSH
60361: LD_VAR 0 4
60365: PUSH
60366: LD_EXP 123
60370: PUSH
60371: LD_VAR 0 4
60375: ARRAY
60376: PUSH
60377: LD_INT 1
60379: PLUS
60380: PUSH
60381: EMPTY
60382: LIST
60383: LIST
60384: PPUSH
60385: LD_VAR 0 1
60389: PPUSH
60390: CALL 71440 0 3
60394: ST_TO_ADDR
60395: GO 60441
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60397: LD_ADDR_EXP 120
60401: PUSH
60402: LD_EXP 120
60406: PPUSH
60407: LD_VAR 0 4
60411: PUSH
60412: LD_EXP 120
60416: PUSH
60417: LD_VAR 0 4
60421: ARRAY
60422: PUSH
60423: LD_INT 1
60425: PLUS
60426: PUSH
60427: EMPTY
60428: LIST
60429: LIST
60430: PPUSH
60431: LD_VAR 0 1
60435: PPUSH
60436: CALL 71440 0 3
60440: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60441: LD_VAR 0 1
60445: PPUSH
60446: CALL_OW 263
60450: PUSH
60451: LD_INT 2
60453: EQUAL
60454: IFFALSE 60474
// begin repeat wait ( 0 0$1 ) ;
60456: LD_INT 35
60458: PPUSH
60459: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60463: LD_VAR 0 1
60467: PPUSH
60468: CALL_OW 312
60472: IFFALSE 60456
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60474: LD_VAR 0 1
60478: PPUSH
60479: LD_EXP 125
60483: PUSH
60484: LD_VAR 0 4
60488: ARRAY
60489: PPUSH
60490: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60494: LD_VAR 0 1
60498: PPUSH
60499: CALL_OW 263
60503: PUSH
60504: LD_INT 1
60506: NONEQUAL
60507: IFFALSE 60511
// break ;
60509: GO 60560
// repeat wait ( 0 0$1 ) ;
60511: LD_INT 35
60513: PPUSH
60514: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60518: LD_VAR 0 1
60522: PPUSH
60523: LD_EXP 125
60527: PUSH
60528: LD_VAR 0 4
60532: ARRAY
60533: PPUSH
60534: CALL_OW 308
60538: IFFALSE 60511
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60540: LD_VAR 0 1
60544: PPUSH
60545: CALL_OW 311
60549: PPUSH
60550: CALL_OW 121
// exit ;
60554: POP
60555: POP
60556: GO 60562
// end ; end ;
60558: GO 60215
60560: POP
60561: POP
// end ;
60562: LD_VAR 0 3
60566: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60567: LD_INT 0
60569: PPUSH
60570: PPUSH
60571: PPUSH
60572: PPUSH
// if not mc_bases or not skirmish then
60573: LD_EXP 101
60577: NOT
60578: PUSH
60579: LD_EXP 99
60583: NOT
60584: OR
60585: IFFALSE 60589
// exit ;
60587: GO 60942
// repeat wait ( 0 0$1 ) ;
60589: LD_INT 35
60591: PPUSH
60592: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60596: LD_VAR 0 2
60600: PPUSH
60601: LD_VAR 0 3
60605: PPUSH
60606: CALL_OW 284
60610: IFFALSE 60589
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60612: LD_VAR 0 2
60616: PPUSH
60617: LD_VAR 0 3
60621: PPUSH
60622: CALL_OW 283
60626: PUSH
60627: LD_INT 4
60629: EQUAL
60630: IFFALSE 60634
// exit ;
60632: GO 60942
// for i = 1 to mc_bases do
60634: LD_ADDR_VAR 0 7
60638: PUSH
60639: DOUBLE
60640: LD_INT 1
60642: DEC
60643: ST_TO_ADDR
60644: LD_EXP 101
60648: PUSH
60649: FOR_TO
60650: IFFALSE 60940
// begin if mc_crates_area [ i ] then
60652: LD_EXP 119
60656: PUSH
60657: LD_VAR 0 7
60661: ARRAY
60662: IFFALSE 60773
// for j in mc_crates_area [ i ] do
60664: LD_ADDR_VAR 0 8
60668: PUSH
60669: LD_EXP 119
60673: PUSH
60674: LD_VAR 0 7
60678: ARRAY
60679: PUSH
60680: FOR_IN
60681: IFFALSE 60771
// if InArea ( x , y , j ) then
60683: LD_VAR 0 2
60687: PPUSH
60688: LD_VAR 0 3
60692: PPUSH
60693: LD_VAR 0 8
60697: PPUSH
60698: CALL_OW 309
60702: IFFALSE 60769
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60704: LD_ADDR_EXP 117
60708: PUSH
60709: LD_EXP 117
60713: PPUSH
60714: LD_VAR 0 7
60718: PUSH
60719: LD_EXP 117
60723: PUSH
60724: LD_VAR 0 7
60728: ARRAY
60729: PUSH
60730: LD_INT 1
60732: PLUS
60733: PUSH
60734: EMPTY
60735: LIST
60736: LIST
60737: PPUSH
60738: LD_VAR 0 4
60742: PUSH
60743: LD_VAR 0 2
60747: PUSH
60748: LD_VAR 0 3
60752: PUSH
60753: EMPTY
60754: LIST
60755: LIST
60756: LIST
60757: PPUSH
60758: CALL 71440 0 3
60762: ST_TO_ADDR
// exit ;
60763: POP
60764: POP
60765: POP
60766: POP
60767: GO 60942
// end ;
60769: GO 60680
60771: POP
60772: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60773: LD_ADDR_VAR 0 9
60777: PUSH
60778: LD_EXP 101
60782: PUSH
60783: LD_VAR 0 7
60787: ARRAY
60788: PPUSH
60789: LD_INT 2
60791: PUSH
60792: LD_INT 30
60794: PUSH
60795: LD_INT 0
60797: PUSH
60798: EMPTY
60799: LIST
60800: LIST
60801: PUSH
60802: LD_INT 30
60804: PUSH
60805: LD_INT 1
60807: PUSH
60808: EMPTY
60809: LIST
60810: LIST
60811: PUSH
60812: EMPTY
60813: LIST
60814: LIST
60815: LIST
60816: PPUSH
60817: CALL_OW 72
60821: ST_TO_ADDR
// if not depot then
60822: LD_VAR 0 9
60826: NOT
60827: IFFALSE 60831
// continue ;
60829: GO 60649
// for j in depot do
60831: LD_ADDR_VAR 0 8
60835: PUSH
60836: LD_VAR 0 9
60840: PUSH
60841: FOR_IN
60842: IFFALSE 60936
// if GetDistUnitXY ( j , x , y ) < 30 then
60844: LD_VAR 0 8
60848: PPUSH
60849: LD_VAR 0 2
60853: PPUSH
60854: LD_VAR 0 3
60858: PPUSH
60859: CALL_OW 297
60863: PUSH
60864: LD_INT 30
60866: LESS
60867: IFFALSE 60934
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60869: LD_ADDR_EXP 117
60873: PUSH
60874: LD_EXP 117
60878: PPUSH
60879: LD_VAR 0 7
60883: PUSH
60884: LD_EXP 117
60888: PUSH
60889: LD_VAR 0 7
60893: ARRAY
60894: PUSH
60895: LD_INT 1
60897: PLUS
60898: PUSH
60899: EMPTY
60900: LIST
60901: LIST
60902: PPUSH
60903: LD_VAR 0 4
60907: PUSH
60908: LD_VAR 0 2
60912: PUSH
60913: LD_VAR 0 3
60917: PUSH
60918: EMPTY
60919: LIST
60920: LIST
60921: LIST
60922: PPUSH
60923: CALL 71440 0 3
60927: ST_TO_ADDR
// exit ;
60928: POP
60929: POP
60930: POP
60931: POP
60932: GO 60942
// end ;
60934: GO 60841
60936: POP
60937: POP
// end ;
60938: GO 60649
60940: POP
60941: POP
// end ;
60942: LD_VAR 0 6
60946: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
60947: LD_INT 0
60949: PPUSH
60950: PPUSH
60951: PPUSH
60952: PPUSH
// if not mc_bases or not skirmish then
60953: LD_EXP 101
60957: NOT
60958: PUSH
60959: LD_EXP 99
60963: NOT
60964: OR
60965: IFFALSE 60969
// exit ;
60967: GO 61246
// side := GetSide ( lab ) ;
60969: LD_ADDR_VAR 0 4
60973: PUSH
60974: LD_VAR 0 2
60978: PPUSH
60979: CALL_OW 255
60983: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60984: LD_VAR 0 4
60988: PUSH
60989: LD_EXP 127
60993: IN
60994: NOT
60995: PUSH
60996: LD_EXP 128
61000: NOT
61001: OR
61002: PUSH
61003: LD_EXP 101
61007: NOT
61008: OR
61009: IFFALSE 61013
// exit ;
61011: GO 61246
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61013: LD_ADDR_EXP 128
61017: PUSH
61018: LD_EXP 128
61022: PPUSH
61023: LD_VAR 0 4
61027: PPUSH
61028: LD_EXP 128
61032: PUSH
61033: LD_VAR 0 4
61037: ARRAY
61038: PUSH
61039: LD_VAR 0 1
61043: DIFF
61044: PPUSH
61045: CALL_OW 1
61049: ST_TO_ADDR
// for i = 1 to mc_bases do
61050: LD_ADDR_VAR 0 5
61054: PUSH
61055: DOUBLE
61056: LD_INT 1
61058: DEC
61059: ST_TO_ADDR
61060: LD_EXP 101
61064: PUSH
61065: FOR_TO
61066: IFFALSE 61244
// begin if lab in mc_bases [ i ] then
61068: LD_VAR 0 2
61072: PUSH
61073: LD_EXP 101
61077: PUSH
61078: LD_VAR 0 5
61082: ARRAY
61083: IN
61084: IFFALSE 61242
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61086: LD_VAR 0 1
61090: PUSH
61091: LD_INT 11
61093: PUSH
61094: LD_INT 4
61096: PUSH
61097: LD_INT 3
61099: PUSH
61100: LD_INT 2
61102: PUSH
61103: EMPTY
61104: LIST
61105: LIST
61106: LIST
61107: LIST
61108: IN
61109: PUSH
61110: LD_EXP 131
61114: PUSH
61115: LD_VAR 0 5
61119: ARRAY
61120: AND
61121: IFFALSE 61242
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61123: LD_ADDR_VAR 0 6
61127: PUSH
61128: LD_EXP 131
61132: PUSH
61133: LD_VAR 0 5
61137: ARRAY
61138: PUSH
61139: LD_INT 1
61141: ARRAY
61142: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61143: LD_ADDR_EXP 131
61147: PUSH
61148: LD_EXP 131
61152: PPUSH
61153: LD_VAR 0 5
61157: PPUSH
61158: EMPTY
61159: PPUSH
61160: CALL_OW 1
61164: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61165: LD_VAR 0 6
61169: PPUSH
61170: LD_INT 0
61172: PPUSH
61173: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61177: LD_VAR 0 6
61181: PPUSH
61182: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61186: LD_ADDR_EXP 130
61190: PUSH
61191: LD_EXP 130
61195: PPUSH
61196: LD_VAR 0 5
61200: PPUSH
61201: LD_EXP 130
61205: PUSH
61206: LD_VAR 0 5
61210: ARRAY
61211: PPUSH
61212: LD_INT 1
61214: PPUSH
61215: LD_VAR 0 6
61219: PPUSH
61220: CALL_OW 2
61224: PPUSH
61225: CALL_OW 1
61229: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61230: LD_VAR 0 5
61234: PPUSH
61235: LD_INT 112
61237: PPUSH
61238: CALL 38138 0 2
// end ; end ; end ;
61242: GO 61065
61244: POP
61245: POP
// end ;
61246: LD_VAR 0 3
61250: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61251: LD_INT 0
61253: PPUSH
61254: PPUSH
61255: PPUSH
61256: PPUSH
61257: PPUSH
61258: PPUSH
61259: PPUSH
61260: PPUSH
// if not mc_bases or not skirmish then
61261: LD_EXP 101
61265: NOT
61266: PUSH
61267: LD_EXP 99
61271: NOT
61272: OR
61273: IFFALSE 61277
// exit ;
61275: GO 62648
// for i = 1 to mc_bases do
61277: LD_ADDR_VAR 0 3
61281: PUSH
61282: DOUBLE
61283: LD_INT 1
61285: DEC
61286: ST_TO_ADDR
61287: LD_EXP 101
61291: PUSH
61292: FOR_TO
61293: IFFALSE 62646
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61295: LD_VAR 0 1
61299: PUSH
61300: LD_EXP 101
61304: PUSH
61305: LD_VAR 0 3
61309: ARRAY
61310: IN
61311: PUSH
61312: LD_VAR 0 1
61316: PUSH
61317: LD_EXP 108
61321: PUSH
61322: LD_VAR 0 3
61326: ARRAY
61327: IN
61328: OR
61329: PUSH
61330: LD_VAR 0 1
61334: PUSH
61335: LD_EXP 123
61339: PUSH
61340: LD_VAR 0 3
61344: ARRAY
61345: IN
61346: OR
61347: PUSH
61348: LD_VAR 0 1
61352: PUSH
61353: LD_EXP 120
61357: PUSH
61358: LD_VAR 0 3
61362: ARRAY
61363: IN
61364: OR
61365: PUSH
61366: LD_VAR 0 1
61370: PUSH
61371: LD_EXP 130
61375: PUSH
61376: LD_VAR 0 3
61380: ARRAY
61381: IN
61382: OR
61383: PUSH
61384: LD_VAR 0 1
61388: PUSH
61389: LD_EXP 131
61393: PUSH
61394: LD_VAR 0 3
61398: ARRAY
61399: IN
61400: OR
61401: IFFALSE 62644
// begin if un in mc_ape [ i ] then
61403: LD_VAR 0 1
61407: PUSH
61408: LD_EXP 130
61412: PUSH
61413: LD_VAR 0 3
61417: ARRAY
61418: IN
61419: IFFALSE 61458
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61421: LD_ADDR_EXP 130
61425: PUSH
61426: LD_EXP 130
61430: PPUSH
61431: LD_VAR 0 3
61435: PPUSH
61436: LD_EXP 130
61440: PUSH
61441: LD_VAR 0 3
61445: ARRAY
61446: PUSH
61447: LD_VAR 0 1
61451: DIFF
61452: PPUSH
61453: CALL_OW 1
61457: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61458: LD_VAR 0 1
61462: PUSH
61463: LD_EXP 131
61467: PUSH
61468: LD_VAR 0 3
61472: ARRAY
61473: IN
61474: IFFALSE 61498
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61476: LD_ADDR_EXP 131
61480: PUSH
61481: LD_EXP 131
61485: PPUSH
61486: LD_VAR 0 3
61490: PPUSH
61491: EMPTY
61492: PPUSH
61493: CALL_OW 1
61497: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61498: LD_VAR 0 1
61502: PPUSH
61503: CALL_OW 247
61507: PUSH
61508: LD_INT 2
61510: EQUAL
61511: PUSH
61512: LD_VAR 0 1
61516: PPUSH
61517: CALL_OW 110
61521: PUSH
61522: LD_INT 20
61524: EQUAL
61525: PUSH
61526: LD_VAR 0 1
61530: PUSH
61531: LD_EXP 123
61535: PUSH
61536: LD_VAR 0 3
61540: ARRAY
61541: IN
61542: OR
61543: PUSH
61544: LD_VAR 0 1
61548: PPUSH
61549: CALL_OW 264
61553: PUSH
61554: LD_INT 12
61556: PUSH
61557: LD_INT 51
61559: PUSH
61560: LD_EXP 95
61564: PUSH
61565: LD_INT 32
61567: PUSH
61568: LD_INT 13
61570: PUSH
61571: LD_INT 52
61573: PUSH
61574: LD_INT 31
61576: PUSH
61577: EMPTY
61578: LIST
61579: LIST
61580: LIST
61581: LIST
61582: LIST
61583: LIST
61584: LIST
61585: IN
61586: OR
61587: AND
61588: IFFALSE 61896
// begin if un in mc_defender [ i ] then
61590: LD_VAR 0 1
61594: PUSH
61595: LD_EXP 123
61599: PUSH
61600: LD_VAR 0 3
61604: ARRAY
61605: IN
61606: IFFALSE 61645
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61608: LD_ADDR_EXP 123
61612: PUSH
61613: LD_EXP 123
61617: PPUSH
61618: LD_VAR 0 3
61622: PPUSH
61623: LD_EXP 123
61627: PUSH
61628: LD_VAR 0 3
61632: ARRAY
61633: PUSH
61634: LD_VAR 0 1
61638: DIFF
61639: PPUSH
61640: CALL_OW 1
61644: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61645: LD_ADDR_VAR 0 8
61649: PUSH
61650: LD_VAR 0 3
61654: PPUSH
61655: LD_INT 3
61657: PPUSH
61658: CALL 58314 0 2
61662: ST_TO_ADDR
// if fac then
61663: LD_VAR 0 8
61667: IFFALSE 61896
// begin for j in fac do
61669: LD_ADDR_VAR 0 4
61673: PUSH
61674: LD_VAR 0 8
61678: PUSH
61679: FOR_IN
61680: IFFALSE 61894
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61682: LD_ADDR_VAR 0 9
61686: PUSH
61687: LD_VAR 0 8
61691: PPUSH
61692: LD_VAR 0 1
61696: PPUSH
61697: CALL_OW 265
61701: PPUSH
61702: LD_VAR 0 1
61706: PPUSH
61707: CALL_OW 262
61711: PPUSH
61712: LD_VAR 0 1
61716: PPUSH
61717: CALL_OW 263
61721: PPUSH
61722: LD_VAR 0 1
61726: PPUSH
61727: CALL_OW 264
61731: PPUSH
61732: CALL 68972 0 5
61736: ST_TO_ADDR
// if components then
61737: LD_VAR 0 9
61741: IFFALSE 61892
// begin if GetWeapon ( un ) = ar_control_tower then
61743: LD_VAR 0 1
61747: PPUSH
61748: CALL_OW 264
61752: PUSH
61753: LD_INT 31
61755: EQUAL
61756: IFFALSE 61873
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61758: LD_VAR 0 1
61762: PPUSH
61763: CALL_OW 311
61767: PPUSH
61768: LD_INT 0
61770: PPUSH
61771: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61775: LD_ADDR_EXP 141
61779: PUSH
61780: LD_EXP 141
61784: PPUSH
61785: LD_VAR 0 3
61789: PPUSH
61790: LD_EXP 141
61794: PUSH
61795: LD_VAR 0 3
61799: ARRAY
61800: PUSH
61801: LD_VAR 0 1
61805: PPUSH
61806: CALL_OW 311
61810: DIFF
61811: PPUSH
61812: CALL_OW 1
61816: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61817: LD_ADDR_VAR 0 7
61821: PUSH
61822: LD_EXP 122
61826: PUSH
61827: LD_VAR 0 3
61831: ARRAY
61832: PPUSH
61833: LD_INT 1
61835: PPUSH
61836: LD_VAR 0 9
61840: PPUSH
61841: CALL_OW 2
61845: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
61846: LD_ADDR_EXP 122
61850: PUSH
61851: LD_EXP 122
61855: PPUSH
61856: LD_VAR 0 3
61860: PPUSH
61861: LD_VAR 0 7
61865: PPUSH
61866: CALL_OW 1
61870: ST_TO_ADDR
// end else
61871: GO 61890
// MC_InsertProduceList ( i , [ components ] ) ;
61873: LD_VAR 0 3
61877: PPUSH
61878: LD_VAR 0 9
61882: PUSH
61883: EMPTY
61884: LIST
61885: PPUSH
61886: CALL 57859 0 2
// break ;
61890: GO 61894
// end ; end ;
61892: GO 61679
61894: POP
61895: POP
// end ; end ; if GetType ( un ) = unit_building then
61896: LD_VAR 0 1
61900: PPUSH
61901: CALL_OW 247
61905: PUSH
61906: LD_INT 3
61908: EQUAL
61909: IFFALSE 62312
// begin btype := GetBType ( un ) ;
61911: LD_ADDR_VAR 0 5
61915: PUSH
61916: LD_VAR 0 1
61920: PPUSH
61921: CALL_OW 266
61925: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
61926: LD_VAR 0 5
61930: PUSH
61931: LD_INT 29
61933: PUSH
61934: LD_INT 30
61936: PUSH
61937: EMPTY
61938: LIST
61939: LIST
61940: IN
61941: IFFALSE 62014
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
61943: LD_VAR 0 1
61947: PPUSH
61948: CALL_OW 250
61952: PPUSH
61953: LD_VAR 0 1
61957: PPUSH
61958: CALL_OW 251
61962: PPUSH
61963: LD_VAR 0 1
61967: PPUSH
61968: CALL_OW 255
61972: PPUSH
61973: CALL_OW 440
61977: NOT
61978: IFFALSE 62014
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
61980: LD_VAR 0 1
61984: PPUSH
61985: CALL_OW 250
61989: PPUSH
61990: LD_VAR 0 1
61994: PPUSH
61995: CALL_OW 251
61999: PPUSH
62000: LD_VAR 0 1
62004: PPUSH
62005: CALL_OW 255
62009: PPUSH
62010: CALL_OW 441
// end ; if btype = b_warehouse then
62014: LD_VAR 0 5
62018: PUSH
62019: LD_INT 1
62021: EQUAL
62022: IFFALSE 62040
// begin btype := b_depot ;
62024: LD_ADDR_VAR 0 5
62028: PUSH
62029: LD_INT 0
62031: ST_TO_ADDR
// pos := 1 ;
62032: LD_ADDR_VAR 0 6
62036: PUSH
62037: LD_INT 1
62039: ST_TO_ADDR
// end ; if btype = b_factory then
62040: LD_VAR 0 5
62044: PUSH
62045: LD_INT 3
62047: EQUAL
62048: IFFALSE 62066
// begin btype := b_workshop ;
62050: LD_ADDR_VAR 0 5
62054: PUSH
62055: LD_INT 2
62057: ST_TO_ADDR
// pos := 1 ;
62058: LD_ADDR_VAR 0 6
62062: PUSH
62063: LD_INT 1
62065: ST_TO_ADDR
// end ; if btype = b_barracks then
62066: LD_VAR 0 5
62070: PUSH
62071: LD_INT 5
62073: EQUAL
62074: IFFALSE 62084
// btype := b_armoury ;
62076: LD_ADDR_VAR 0 5
62080: PUSH
62081: LD_INT 4
62083: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62084: LD_VAR 0 5
62088: PUSH
62089: LD_INT 7
62091: PUSH
62092: LD_INT 8
62094: PUSH
62095: EMPTY
62096: LIST
62097: LIST
62098: IN
62099: IFFALSE 62109
// btype := b_lab ;
62101: LD_ADDR_VAR 0 5
62105: PUSH
62106: LD_INT 6
62108: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62109: LD_ADDR_EXP 106
62113: PUSH
62114: LD_EXP 106
62118: PPUSH
62119: LD_VAR 0 3
62123: PUSH
62124: LD_EXP 106
62128: PUSH
62129: LD_VAR 0 3
62133: ARRAY
62134: PUSH
62135: LD_INT 1
62137: PLUS
62138: PUSH
62139: EMPTY
62140: LIST
62141: LIST
62142: PPUSH
62143: LD_VAR 0 5
62147: PUSH
62148: LD_VAR 0 1
62152: PPUSH
62153: CALL_OW 250
62157: PUSH
62158: LD_VAR 0 1
62162: PPUSH
62163: CALL_OW 251
62167: PUSH
62168: LD_VAR 0 1
62172: PPUSH
62173: CALL_OW 254
62177: PUSH
62178: EMPTY
62179: LIST
62180: LIST
62181: LIST
62182: LIST
62183: PPUSH
62184: CALL 71440 0 3
62188: ST_TO_ADDR
// if pos = 1 then
62189: LD_VAR 0 6
62193: PUSH
62194: LD_INT 1
62196: EQUAL
62197: IFFALSE 62312
// begin tmp := mc_build_list [ i ] ;
62199: LD_ADDR_VAR 0 7
62203: PUSH
62204: LD_EXP 106
62208: PUSH
62209: LD_VAR 0 3
62213: ARRAY
62214: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62215: LD_VAR 0 7
62219: PPUSH
62220: LD_INT 2
62222: PUSH
62223: LD_INT 30
62225: PUSH
62226: LD_INT 0
62228: PUSH
62229: EMPTY
62230: LIST
62231: LIST
62232: PUSH
62233: LD_INT 30
62235: PUSH
62236: LD_INT 1
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PUSH
62243: EMPTY
62244: LIST
62245: LIST
62246: LIST
62247: PPUSH
62248: CALL_OW 72
62252: IFFALSE 62262
// pos := 2 ;
62254: LD_ADDR_VAR 0 6
62258: PUSH
62259: LD_INT 2
62261: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62262: LD_ADDR_VAR 0 7
62266: PUSH
62267: LD_VAR 0 7
62271: PPUSH
62272: LD_VAR 0 6
62276: PPUSH
62277: LD_VAR 0 7
62281: PPUSH
62282: CALL 71766 0 3
62286: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62287: LD_ADDR_EXP 106
62291: PUSH
62292: LD_EXP 106
62296: PPUSH
62297: LD_VAR 0 3
62301: PPUSH
62302: LD_VAR 0 7
62306: PPUSH
62307: CALL_OW 1
62311: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62312: LD_VAR 0 1
62316: PUSH
62317: LD_EXP 101
62321: PUSH
62322: LD_VAR 0 3
62326: ARRAY
62327: IN
62328: IFFALSE 62367
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62330: LD_ADDR_EXP 101
62334: PUSH
62335: LD_EXP 101
62339: PPUSH
62340: LD_VAR 0 3
62344: PPUSH
62345: LD_EXP 101
62349: PUSH
62350: LD_VAR 0 3
62354: ARRAY
62355: PUSH
62356: LD_VAR 0 1
62360: DIFF
62361: PPUSH
62362: CALL_OW 1
62366: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62367: LD_VAR 0 1
62371: PUSH
62372: LD_EXP 108
62376: PUSH
62377: LD_VAR 0 3
62381: ARRAY
62382: IN
62383: IFFALSE 62422
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62385: LD_ADDR_EXP 108
62389: PUSH
62390: LD_EXP 108
62394: PPUSH
62395: LD_VAR 0 3
62399: PPUSH
62400: LD_EXP 108
62404: PUSH
62405: LD_VAR 0 3
62409: ARRAY
62410: PUSH
62411: LD_VAR 0 1
62415: DIFF
62416: PPUSH
62417: CALL_OW 1
62421: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62422: LD_VAR 0 1
62426: PUSH
62427: LD_EXP 120
62431: PUSH
62432: LD_VAR 0 3
62436: ARRAY
62437: IN
62438: IFFALSE 62477
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62440: LD_ADDR_EXP 120
62444: PUSH
62445: LD_EXP 120
62449: PPUSH
62450: LD_VAR 0 3
62454: PPUSH
62455: LD_EXP 120
62459: PUSH
62460: LD_VAR 0 3
62464: ARRAY
62465: PUSH
62466: LD_VAR 0 1
62470: DIFF
62471: PPUSH
62472: CALL_OW 1
62476: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62477: LD_VAR 0 1
62481: PUSH
62482: LD_EXP 123
62486: PUSH
62487: LD_VAR 0 3
62491: ARRAY
62492: IN
62493: IFFALSE 62532
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62495: LD_ADDR_EXP 123
62499: PUSH
62500: LD_EXP 123
62504: PPUSH
62505: LD_VAR 0 3
62509: PPUSH
62510: LD_EXP 123
62514: PUSH
62515: LD_VAR 0 3
62519: ARRAY
62520: PUSH
62521: LD_VAR 0 1
62525: DIFF
62526: PPUSH
62527: CALL_OW 1
62531: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62532: LD_VAR 0 1
62536: PUSH
62537: LD_EXP 110
62541: PUSH
62542: LD_VAR 0 3
62546: ARRAY
62547: IN
62548: IFFALSE 62587
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62550: LD_ADDR_EXP 110
62554: PUSH
62555: LD_EXP 110
62559: PPUSH
62560: LD_VAR 0 3
62564: PPUSH
62565: LD_EXP 110
62569: PUSH
62570: LD_VAR 0 3
62574: ARRAY
62575: PUSH
62576: LD_VAR 0 1
62580: DIFF
62581: PPUSH
62582: CALL_OW 1
62586: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62587: LD_VAR 0 1
62591: PUSH
62592: LD_EXP 109
62596: PUSH
62597: LD_VAR 0 3
62601: ARRAY
62602: IN
62603: IFFALSE 62642
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62605: LD_ADDR_EXP 109
62609: PUSH
62610: LD_EXP 109
62614: PPUSH
62615: LD_VAR 0 3
62619: PPUSH
62620: LD_EXP 109
62624: PUSH
62625: LD_VAR 0 3
62629: ARRAY
62630: PUSH
62631: LD_VAR 0 1
62635: DIFF
62636: PPUSH
62637: CALL_OW 1
62641: ST_TO_ADDR
// end ; break ;
62642: GO 62646
// end ;
62644: GO 61292
62646: POP
62647: POP
// end ;
62648: LD_VAR 0 2
62652: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62653: LD_INT 0
62655: PPUSH
62656: PPUSH
62657: PPUSH
// if not mc_bases or not skirmish then
62658: LD_EXP 101
62662: NOT
62663: PUSH
62664: LD_EXP 99
62668: NOT
62669: OR
62670: IFFALSE 62674
// exit ;
62672: GO 62889
// for i = 1 to mc_bases do
62674: LD_ADDR_VAR 0 3
62678: PUSH
62679: DOUBLE
62680: LD_INT 1
62682: DEC
62683: ST_TO_ADDR
62684: LD_EXP 101
62688: PUSH
62689: FOR_TO
62690: IFFALSE 62887
// begin if building in mc_construct_list [ i ] then
62692: LD_VAR 0 1
62696: PUSH
62697: LD_EXP 108
62701: PUSH
62702: LD_VAR 0 3
62706: ARRAY
62707: IN
62708: IFFALSE 62885
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62710: LD_ADDR_EXP 108
62714: PUSH
62715: LD_EXP 108
62719: PPUSH
62720: LD_VAR 0 3
62724: PPUSH
62725: LD_EXP 108
62729: PUSH
62730: LD_VAR 0 3
62734: ARRAY
62735: PUSH
62736: LD_VAR 0 1
62740: DIFF
62741: PPUSH
62742: CALL_OW 1
62746: ST_TO_ADDR
// if building in mc_lab [ i ] then
62747: LD_VAR 0 1
62751: PUSH
62752: LD_EXP 134
62756: PUSH
62757: LD_VAR 0 3
62761: ARRAY
62762: IN
62763: IFFALSE 62818
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62765: LD_ADDR_EXP 135
62769: PUSH
62770: LD_EXP 135
62774: PPUSH
62775: LD_VAR 0 3
62779: PPUSH
62780: LD_EXP 135
62784: PUSH
62785: LD_VAR 0 3
62789: ARRAY
62790: PPUSH
62791: LD_INT 1
62793: PPUSH
62794: LD_EXP 135
62798: PUSH
62799: LD_VAR 0 3
62803: ARRAY
62804: PPUSH
62805: LD_INT 0
62807: PPUSH
62808: CALL 70858 0 4
62812: PPUSH
62813: CALL_OW 1
62817: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62818: LD_VAR 0 1
62822: PUSH
62823: LD_EXP 101
62827: PUSH
62828: LD_VAR 0 3
62832: ARRAY
62833: IN
62834: NOT
62835: IFFALSE 62881
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62837: LD_ADDR_EXP 101
62841: PUSH
62842: LD_EXP 101
62846: PPUSH
62847: LD_VAR 0 3
62851: PUSH
62852: LD_EXP 101
62856: PUSH
62857: LD_VAR 0 3
62861: ARRAY
62862: PUSH
62863: LD_INT 1
62865: PLUS
62866: PUSH
62867: EMPTY
62868: LIST
62869: LIST
62870: PPUSH
62871: LD_VAR 0 1
62875: PPUSH
62876: CALL 71440 0 3
62880: ST_TO_ADDR
// exit ;
62881: POP
62882: POP
62883: GO 62889
// end ; end ;
62885: GO 62689
62887: POP
62888: POP
// end ;
62889: LD_VAR 0 2
62893: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62894: LD_INT 0
62896: PPUSH
62897: PPUSH
62898: PPUSH
62899: PPUSH
62900: PPUSH
62901: PPUSH
62902: PPUSH
// if not mc_bases or not skirmish then
62903: LD_EXP 101
62907: NOT
62908: PUSH
62909: LD_EXP 99
62913: NOT
62914: OR
62915: IFFALSE 62919
// exit ;
62917: GO 63580
// for i = 1 to mc_bases do
62919: LD_ADDR_VAR 0 3
62923: PUSH
62924: DOUBLE
62925: LD_INT 1
62927: DEC
62928: ST_TO_ADDR
62929: LD_EXP 101
62933: PUSH
62934: FOR_TO
62935: IFFALSE 63578
// begin if building in mc_construct_list [ i ] then
62937: LD_VAR 0 1
62941: PUSH
62942: LD_EXP 108
62946: PUSH
62947: LD_VAR 0 3
62951: ARRAY
62952: IN
62953: IFFALSE 63576
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62955: LD_ADDR_EXP 108
62959: PUSH
62960: LD_EXP 108
62964: PPUSH
62965: LD_VAR 0 3
62969: PPUSH
62970: LD_EXP 108
62974: PUSH
62975: LD_VAR 0 3
62979: ARRAY
62980: PUSH
62981: LD_VAR 0 1
62985: DIFF
62986: PPUSH
62987: CALL_OW 1
62991: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62992: LD_ADDR_EXP 101
62996: PUSH
62997: LD_EXP 101
63001: PPUSH
63002: LD_VAR 0 3
63006: PUSH
63007: LD_EXP 101
63011: PUSH
63012: LD_VAR 0 3
63016: ARRAY
63017: PUSH
63018: LD_INT 1
63020: PLUS
63021: PUSH
63022: EMPTY
63023: LIST
63024: LIST
63025: PPUSH
63026: LD_VAR 0 1
63030: PPUSH
63031: CALL 71440 0 3
63035: ST_TO_ADDR
// btype := GetBType ( building ) ;
63036: LD_ADDR_VAR 0 5
63040: PUSH
63041: LD_VAR 0 1
63045: PPUSH
63046: CALL_OW 266
63050: ST_TO_ADDR
// side := GetSide ( building ) ;
63051: LD_ADDR_VAR 0 8
63055: PUSH
63056: LD_VAR 0 1
63060: PPUSH
63061: CALL_OW 255
63065: ST_TO_ADDR
// if btype = b_lab then
63066: LD_VAR 0 5
63070: PUSH
63071: LD_INT 6
63073: EQUAL
63074: IFFALSE 63124
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63076: LD_ADDR_EXP 134
63080: PUSH
63081: LD_EXP 134
63085: PPUSH
63086: LD_VAR 0 3
63090: PUSH
63091: LD_EXP 134
63095: PUSH
63096: LD_VAR 0 3
63100: ARRAY
63101: PUSH
63102: LD_INT 1
63104: PLUS
63105: PUSH
63106: EMPTY
63107: LIST
63108: LIST
63109: PPUSH
63110: LD_VAR 0 1
63114: PPUSH
63115: CALL 71440 0 3
63119: ST_TO_ADDR
// exit ;
63120: POP
63121: POP
63122: GO 63580
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63124: LD_VAR 0 5
63128: PUSH
63129: LD_INT 0
63131: PUSH
63132: LD_INT 2
63134: PUSH
63135: LD_INT 4
63137: PUSH
63138: EMPTY
63139: LIST
63140: LIST
63141: LIST
63142: IN
63143: IFFALSE 63267
// begin if btype = b_armoury then
63145: LD_VAR 0 5
63149: PUSH
63150: LD_INT 4
63152: EQUAL
63153: IFFALSE 63163
// btype := b_barracks ;
63155: LD_ADDR_VAR 0 5
63159: PUSH
63160: LD_INT 5
63162: ST_TO_ADDR
// if btype = b_depot then
63163: LD_VAR 0 5
63167: PUSH
63168: LD_INT 0
63170: EQUAL
63171: IFFALSE 63181
// btype := b_warehouse ;
63173: LD_ADDR_VAR 0 5
63177: PUSH
63178: LD_INT 1
63180: ST_TO_ADDR
// if btype = b_workshop then
63181: LD_VAR 0 5
63185: PUSH
63186: LD_INT 2
63188: EQUAL
63189: IFFALSE 63199
// btype := b_factory ;
63191: LD_ADDR_VAR 0 5
63195: PUSH
63196: LD_INT 3
63198: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63199: LD_VAR 0 5
63203: PPUSH
63204: LD_VAR 0 8
63208: PPUSH
63209: CALL_OW 323
63213: PUSH
63214: LD_INT 1
63216: EQUAL
63217: IFFALSE 63263
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63219: LD_ADDR_EXP 133
63223: PUSH
63224: LD_EXP 133
63228: PPUSH
63229: LD_VAR 0 3
63233: PUSH
63234: LD_EXP 133
63238: PUSH
63239: LD_VAR 0 3
63243: ARRAY
63244: PUSH
63245: LD_INT 1
63247: PLUS
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: PPUSH
63253: LD_VAR 0 1
63257: PPUSH
63258: CALL 71440 0 3
63262: ST_TO_ADDR
// exit ;
63263: POP
63264: POP
63265: GO 63580
// end ; if btype in [ b_bunker , b_turret ] then
63267: LD_VAR 0 5
63271: PUSH
63272: LD_INT 32
63274: PUSH
63275: LD_INT 33
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: IN
63282: IFFALSE 63572
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63284: LD_ADDR_EXP 109
63288: PUSH
63289: LD_EXP 109
63293: PPUSH
63294: LD_VAR 0 3
63298: PUSH
63299: LD_EXP 109
63303: PUSH
63304: LD_VAR 0 3
63308: ARRAY
63309: PUSH
63310: LD_INT 1
63312: PLUS
63313: PUSH
63314: EMPTY
63315: LIST
63316: LIST
63317: PPUSH
63318: LD_VAR 0 1
63322: PPUSH
63323: CALL 71440 0 3
63327: ST_TO_ADDR
// if btype = b_bunker then
63328: LD_VAR 0 5
63332: PUSH
63333: LD_INT 32
63335: EQUAL
63336: IFFALSE 63572
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63338: LD_ADDR_EXP 110
63342: PUSH
63343: LD_EXP 110
63347: PPUSH
63348: LD_VAR 0 3
63352: PUSH
63353: LD_EXP 110
63357: PUSH
63358: LD_VAR 0 3
63362: ARRAY
63363: PUSH
63364: LD_INT 1
63366: PLUS
63367: PUSH
63368: EMPTY
63369: LIST
63370: LIST
63371: PPUSH
63372: LD_VAR 0 1
63376: PPUSH
63377: CALL 71440 0 3
63381: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63382: LD_ADDR_VAR 0 6
63386: PUSH
63387: LD_EXP 101
63391: PUSH
63392: LD_VAR 0 3
63396: ARRAY
63397: PPUSH
63398: LD_INT 25
63400: PUSH
63401: LD_INT 1
63403: PUSH
63404: EMPTY
63405: LIST
63406: LIST
63407: PUSH
63408: LD_INT 3
63410: PUSH
63411: LD_INT 54
63413: PUSH
63414: EMPTY
63415: LIST
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PUSH
63421: EMPTY
63422: LIST
63423: LIST
63424: PPUSH
63425: CALL_OW 72
63429: ST_TO_ADDR
// if tmp then
63430: LD_VAR 0 6
63434: IFFALSE 63440
// exit ;
63436: POP
63437: POP
63438: GO 63580
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63440: LD_ADDR_VAR 0 6
63444: PUSH
63445: LD_EXP 101
63449: PUSH
63450: LD_VAR 0 3
63454: ARRAY
63455: PPUSH
63456: LD_INT 2
63458: PUSH
63459: LD_INT 30
63461: PUSH
63462: LD_INT 4
63464: PUSH
63465: EMPTY
63466: LIST
63467: LIST
63468: PUSH
63469: LD_INT 30
63471: PUSH
63472: LD_INT 5
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PUSH
63479: EMPTY
63480: LIST
63481: LIST
63482: LIST
63483: PPUSH
63484: CALL_OW 72
63488: ST_TO_ADDR
// if not tmp then
63489: LD_VAR 0 6
63493: NOT
63494: IFFALSE 63500
// exit ;
63496: POP
63497: POP
63498: GO 63580
// for j in tmp do
63500: LD_ADDR_VAR 0 4
63504: PUSH
63505: LD_VAR 0 6
63509: PUSH
63510: FOR_IN
63511: IFFALSE 63570
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63513: LD_ADDR_VAR 0 7
63517: PUSH
63518: LD_VAR 0 4
63522: PPUSH
63523: CALL_OW 313
63527: PPUSH
63528: LD_INT 25
63530: PUSH
63531: LD_INT 1
63533: PUSH
63534: EMPTY
63535: LIST
63536: LIST
63537: PPUSH
63538: CALL_OW 72
63542: ST_TO_ADDR
// if units then
63543: LD_VAR 0 7
63547: IFFALSE 63568
// begin ComExitBuilding ( units [ 1 ] ) ;
63549: LD_VAR 0 7
63553: PUSH
63554: LD_INT 1
63556: ARRAY
63557: PPUSH
63558: CALL_OW 122
// exit ;
63562: POP
63563: POP
63564: POP
63565: POP
63566: GO 63580
// end ; end ;
63568: GO 63510
63570: POP
63571: POP
// end ; end ; exit ;
63572: POP
63573: POP
63574: GO 63580
// end ; end ;
63576: GO 62934
63578: POP
63579: POP
// end ;
63580: LD_VAR 0 2
63584: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63585: LD_INT 0
63587: PPUSH
63588: PPUSH
63589: PPUSH
63590: PPUSH
63591: PPUSH
63592: PPUSH
63593: PPUSH
// if not mc_bases or not skirmish then
63594: LD_EXP 101
63598: NOT
63599: PUSH
63600: LD_EXP 99
63604: NOT
63605: OR
63606: IFFALSE 63610
// exit ;
63608: GO 63841
// btype := GetBType ( building ) ;
63610: LD_ADDR_VAR 0 6
63614: PUSH
63615: LD_VAR 0 1
63619: PPUSH
63620: CALL_OW 266
63624: ST_TO_ADDR
// x := GetX ( building ) ;
63625: LD_ADDR_VAR 0 7
63629: PUSH
63630: LD_VAR 0 1
63634: PPUSH
63635: CALL_OW 250
63639: ST_TO_ADDR
// y := GetY ( building ) ;
63640: LD_ADDR_VAR 0 8
63644: PUSH
63645: LD_VAR 0 1
63649: PPUSH
63650: CALL_OW 251
63654: ST_TO_ADDR
// d := GetDir ( building ) ;
63655: LD_ADDR_VAR 0 9
63659: PUSH
63660: LD_VAR 0 1
63664: PPUSH
63665: CALL_OW 254
63669: ST_TO_ADDR
// for i = 1 to mc_bases do
63670: LD_ADDR_VAR 0 4
63674: PUSH
63675: DOUBLE
63676: LD_INT 1
63678: DEC
63679: ST_TO_ADDR
63680: LD_EXP 101
63684: PUSH
63685: FOR_TO
63686: IFFALSE 63839
// begin if not mc_build_list [ i ] then
63688: LD_EXP 106
63692: PUSH
63693: LD_VAR 0 4
63697: ARRAY
63698: NOT
63699: IFFALSE 63703
// continue ;
63701: GO 63685
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63703: LD_VAR 0 6
63707: PUSH
63708: LD_VAR 0 7
63712: PUSH
63713: LD_VAR 0 8
63717: PUSH
63718: LD_VAR 0 9
63722: PUSH
63723: EMPTY
63724: LIST
63725: LIST
63726: LIST
63727: LIST
63728: PPUSH
63729: LD_EXP 106
63733: PUSH
63734: LD_VAR 0 4
63738: ARRAY
63739: PUSH
63740: LD_INT 1
63742: ARRAY
63743: PPUSH
63744: CALL 77609 0 2
63748: IFFALSE 63837
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63750: LD_ADDR_EXP 106
63754: PUSH
63755: LD_EXP 106
63759: PPUSH
63760: LD_VAR 0 4
63764: PPUSH
63765: LD_EXP 106
63769: PUSH
63770: LD_VAR 0 4
63774: ARRAY
63775: PPUSH
63776: LD_INT 1
63778: PPUSH
63779: CALL_OW 3
63783: PPUSH
63784: CALL_OW 1
63788: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63789: LD_ADDR_EXP 108
63793: PUSH
63794: LD_EXP 108
63798: PPUSH
63799: LD_VAR 0 4
63803: PUSH
63804: LD_EXP 108
63808: PUSH
63809: LD_VAR 0 4
63813: ARRAY
63814: PUSH
63815: LD_INT 1
63817: PLUS
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: PPUSH
63823: LD_VAR 0 1
63827: PPUSH
63828: CALL 71440 0 3
63832: ST_TO_ADDR
// exit ;
63833: POP
63834: POP
63835: GO 63841
// end ; end ;
63837: GO 63685
63839: POP
63840: POP
// end ;
63841: LD_VAR 0 3
63845: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63846: LD_INT 0
63848: PPUSH
63849: PPUSH
63850: PPUSH
// if not mc_bases or not skirmish then
63851: LD_EXP 101
63855: NOT
63856: PUSH
63857: LD_EXP 99
63861: NOT
63862: OR
63863: IFFALSE 63867
// exit ;
63865: GO 64057
// for i = 1 to mc_bases do
63867: LD_ADDR_VAR 0 4
63871: PUSH
63872: DOUBLE
63873: LD_INT 1
63875: DEC
63876: ST_TO_ADDR
63877: LD_EXP 101
63881: PUSH
63882: FOR_TO
63883: IFFALSE 63970
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63885: LD_VAR 0 1
63889: PUSH
63890: LD_EXP 109
63894: PUSH
63895: LD_VAR 0 4
63899: ARRAY
63900: IN
63901: PUSH
63902: LD_VAR 0 1
63906: PUSH
63907: LD_EXP 110
63911: PUSH
63912: LD_VAR 0 4
63916: ARRAY
63917: IN
63918: NOT
63919: AND
63920: IFFALSE 63968
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63922: LD_ADDR_EXP 110
63926: PUSH
63927: LD_EXP 110
63931: PPUSH
63932: LD_VAR 0 4
63936: PUSH
63937: LD_EXP 110
63941: PUSH
63942: LD_VAR 0 4
63946: ARRAY
63947: PUSH
63948: LD_INT 1
63950: PLUS
63951: PUSH
63952: EMPTY
63953: LIST
63954: LIST
63955: PPUSH
63956: LD_VAR 0 1
63960: PPUSH
63961: CALL 71440 0 3
63965: ST_TO_ADDR
// break ;
63966: GO 63970
// end ; end ;
63968: GO 63882
63970: POP
63971: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
63972: LD_VAR 0 1
63976: PPUSH
63977: CALL_OW 257
63981: PUSH
63982: LD_EXP 127
63986: IN
63987: PUSH
63988: LD_VAR 0 1
63992: PPUSH
63993: CALL_OW 266
63997: PUSH
63998: LD_INT 5
64000: EQUAL
64001: AND
64002: PUSH
64003: LD_VAR 0 2
64007: PPUSH
64008: CALL_OW 110
64012: PUSH
64013: LD_INT 18
64015: NONEQUAL
64016: AND
64017: IFFALSE 64057
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64019: LD_VAR 0 2
64023: PPUSH
64024: CALL_OW 257
64028: PUSH
64029: LD_INT 5
64031: PUSH
64032: LD_INT 8
64034: PUSH
64035: LD_INT 9
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: LIST
64042: IN
64043: IFFALSE 64057
// SetClass ( unit , 1 ) ;
64045: LD_VAR 0 2
64049: PPUSH
64050: LD_INT 1
64052: PPUSH
64053: CALL_OW 336
// end ;
64057: LD_VAR 0 3
64061: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64062: LD_INT 0
64064: PPUSH
64065: PPUSH
// if not mc_bases or not skirmish then
64066: LD_EXP 101
64070: NOT
64071: PUSH
64072: LD_EXP 99
64076: NOT
64077: OR
64078: IFFALSE 64082
// exit ;
64080: GO 64198
// if GetLives ( abandoned_vehicle ) > 250 then
64082: LD_VAR 0 2
64086: PPUSH
64087: CALL_OW 256
64091: PUSH
64092: LD_INT 250
64094: GREATER
64095: IFFALSE 64099
// exit ;
64097: GO 64198
// for i = 1 to mc_bases do
64099: LD_ADDR_VAR 0 6
64103: PUSH
64104: DOUBLE
64105: LD_INT 1
64107: DEC
64108: ST_TO_ADDR
64109: LD_EXP 101
64113: PUSH
64114: FOR_TO
64115: IFFALSE 64196
// begin if driver in mc_bases [ i ] then
64117: LD_VAR 0 1
64121: PUSH
64122: LD_EXP 101
64126: PUSH
64127: LD_VAR 0 6
64131: ARRAY
64132: IN
64133: IFFALSE 64194
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64135: LD_VAR 0 1
64139: PPUSH
64140: LD_EXP 101
64144: PUSH
64145: LD_VAR 0 6
64149: ARRAY
64150: PPUSH
64151: LD_INT 2
64153: PUSH
64154: LD_INT 30
64156: PUSH
64157: LD_INT 0
64159: PUSH
64160: EMPTY
64161: LIST
64162: LIST
64163: PUSH
64164: LD_INT 30
64166: PUSH
64167: LD_INT 1
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: PUSH
64174: EMPTY
64175: LIST
64176: LIST
64177: LIST
64178: PPUSH
64179: CALL_OW 72
64183: PUSH
64184: LD_INT 1
64186: ARRAY
64187: PPUSH
64188: CALL_OW 112
// break ;
64192: GO 64196
// end ; end ;
64194: GO 64114
64196: POP
64197: POP
// end ; end_of_file
64198: LD_VAR 0 5
64202: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64203: LD_INT 0
64205: PPUSH
64206: PPUSH
// if exist_mode then
64207: LD_VAR 0 2
64211: IFFALSE 64236
// unit := CreateCharacter ( prefix & ident ) else
64213: LD_ADDR_VAR 0 5
64217: PUSH
64218: LD_VAR 0 3
64222: PUSH
64223: LD_VAR 0 1
64227: STR
64228: PPUSH
64229: CALL_OW 34
64233: ST_TO_ADDR
64234: GO 64251
// unit := NewCharacter ( ident ) ;
64236: LD_ADDR_VAR 0 5
64240: PUSH
64241: LD_VAR 0 1
64245: PPUSH
64246: CALL_OW 25
64250: ST_TO_ADDR
// result := unit ;
64251: LD_ADDR_VAR 0 4
64255: PUSH
64256: LD_VAR 0 5
64260: ST_TO_ADDR
// end ;
64261: LD_VAR 0 4
64265: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64266: LD_INT 0
64268: PPUSH
64269: PPUSH
// if not side or not nation then
64270: LD_VAR 0 1
64274: NOT
64275: PUSH
64276: LD_VAR 0 2
64280: NOT
64281: OR
64282: IFFALSE 64286
// exit ;
64284: GO 64930
// case nation of nation_american :
64286: LD_VAR 0 2
64290: PUSH
64291: LD_INT 1
64293: DOUBLE
64294: EQUAL
64295: IFTRUE 64299
64297: GO 64473
64299: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64300: LD_ADDR_VAR 0 4
64304: PUSH
64305: LD_INT 35
64307: PUSH
64308: LD_INT 45
64310: PUSH
64311: LD_INT 46
64313: PUSH
64314: LD_INT 47
64316: PUSH
64317: LD_INT 1
64319: PUSH
64320: LD_INT 2
64322: PUSH
64323: LD_INT 6
64325: PUSH
64326: LD_INT 15
64328: PUSH
64329: LD_INT 16
64331: PUSH
64332: LD_INT 7
64334: PUSH
64335: LD_INT 12
64337: PUSH
64338: LD_INT 13
64340: PUSH
64341: LD_INT 10
64343: PUSH
64344: LD_INT 14
64346: PUSH
64347: LD_INT 20
64349: PUSH
64350: LD_INT 21
64352: PUSH
64353: LD_INT 22
64355: PUSH
64356: LD_INT 25
64358: PUSH
64359: LD_INT 32
64361: PUSH
64362: LD_INT 27
64364: PUSH
64365: LD_INT 36
64367: PUSH
64368: LD_INT 69
64370: PUSH
64371: LD_INT 39
64373: PUSH
64374: LD_INT 34
64376: PUSH
64377: LD_INT 40
64379: PUSH
64380: LD_INT 48
64382: PUSH
64383: LD_INT 49
64385: PUSH
64386: LD_INT 50
64388: PUSH
64389: LD_INT 51
64391: PUSH
64392: LD_INT 52
64394: PUSH
64395: LD_INT 53
64397: PUSH
64398: LD_INT 54
64400: PUSH
64401: LD_INT 55
64403: PUSH
64404: LD_INT 56
64406: PUSH
64407: LD_INT 57
64409: PUSH
64410: LD_INT 58
64412: PUSH
64413: LD_INT 59
64415: PUSH
64416: LD_INT 60
64418: PUSH
64419: LD_INT 61
64421: PUSH
64422: LD_INT 62
64424: PUSH
64425: LD_INT 80
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: LIST
64432: LIST
64433: LIST
64434: LIST
64435: LIST
64436: LIST
64437: LIST
64438: LIST
64439: LIST
64440: LIST
64441: LIST
64442: LIST
64443: LIST
64444: LIST
64445: LIST
64446: LIST
64447: LIST
64448: LIST
64449: LIST
64450: LIST
64451: LIST
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: ST_TO_ADDR
64471: GO 64854
64473: LD_INT 2
64475: DOUBLE
64476: EQUAL
64477: IFTRUE 64481
64479: GO 64663
64481: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64482: LD_ADDR_VAR 0 4
64486: PUSH
64487: LD_INT 35
64489: PUSH
64490: LD_INT 45
64492: PUSH
64493: LD_INT 46
64495: PUSH
64496: LD_INT 47
64498: PUSH
64499: LD_INT 70
64501: PUSH
64502: LD_INT 1
64504: PUSH
64505: LD_INT 11
64507: PUSH
64508: LD_INT 3
64510: PUSH
64511: LD_INT 4
64513: PUSH
64514: LD_INT 5
64516: PUSH
64517: LD_INT 6
64519: PUSH
64520: LD_INT 15
64522: PUSH
64523: LD_INT 18
64525: PUSH
64526: LD_INT 7
64528: PUSH
64529: LD_INT 17
64531: PUSH
64532: LD_INT 8
64534: PUSH
64535: LD_INT 20
64537: PUSH
64538: LD_INT 21
64540: PUSH
64541: LD_INT 22
64543: PUSH
64544: LD_INT 72
64546: PUSH
64547: LD_INT 26
64549: PUSH
64550: LD_INT 69
64552: PUSH
64553: LD_INT 39
64555: PUSH
64556: LD_INT 40
64558: PUSH
64559: LD_INT 41
64561: PUSH
64562: LD_INT 42
64564: PUSH
64565: LD_INT 43
64567: PUSH
64568: LD_INT 48
64570: PUSH
64571: LD_INT 49
64573: PUSH
64574: LD_INT 50
64576: PUSH
64577: LD_INT 51
64579: PUSH
64580: LD_INT 52
64582: PUSH
64583: LD_INT 53
64585: PUSH
64586: LD_INT 54
64588: PUSH
64589: LD_INT 55
64591: PUSH
64592: LD_INT 56
64594: PUSH
64595: LD_INT 60
64597: PUSH
64598: LD_INT 61
64600: PUSH
64601: LD_INT 62
64603: PUSH
64604: LD_INT 66
64606: PUSH
64607: LD_INT 67
64609: PUSH
64610: LD_INT 68
64612: PUSH
64613: LD_INT 81
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: LIST
64620: LIST
64621: LIST
64622: LIST
64623: LIST
64624: LIST
64625: LIST
64626: LIST
64627: LIST
64628: LIST
64629: LIST
64630: LIST
64631: LIST
64632: LIST
64633: LIST
64634: LIST
64635: LIST
64636: LIST
64637: LIST
64638: LIST
64639: LIST
64640: LIST
64641: LIST
64642: LIST
64643: LIST
64644: LIST
64645: LIST
64646: LIST
64647: LIST
64648: LIST
64649: LIST
64650: LIST
64651: LIST
64652: LIST
64653: LIST
64654: LIST
64655: LIST
64656: LIST
64657: LIST
64658: LIST
64659: LIST
64660: ST_TO_ADDR
64661: GO 64854
64663: LD_INT 3
64665: DOUBLE
64666: EQUAL
64667: IFTRUE 64671
64669: GO 64853
64671: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64672: LD_ADDR_VAR 0 4
64676: PUSH
64677: LD_INT 46
64679: PUSH
64680: LD_INT 47
64682: PUSH
64683: LD_INT 1
64685: PUSH
64686: LD_INT 2
64688: PUSH
64689: LD_INT 11
64691: PUSH
64692: LD_INT 9
64694: PUSH
64695: LD_INT 20
64697: PUSH
64698: LD_INT 19
64700: PUSH
64701: LD_INT 21
64703: PUSH
64704: LD_INT 24
64706: PUSH
64707: LD_INT 22
64709: PUSH
64710: LD_INT 25
64712: PUSH
64713: LD_INT 28
64715: PUSH
64716: LD_INT 29
64718: PUSH
64719: LD_INT 30
64721: PUSH
64722: LD_INT 31
64724: PUSH
64725: LD_INT 37
64727: PUSH
64728: LD_INT 38
64730: PUSH
64731: LD_INT 32
64733: PUSH
64734: LD_INT 27
64736: PUSH
64737: LD_INT 33
64739: PUSH
64740: LD_INT 69
64742: PUSH
64743: LD_INT 39
64745: PUSH
64746: LD_INT 34
64748: PUSH
64749: LD_INT 40
64751: PUSH
64752: LD_INT 71
64754: PUSH
64755: LD_INT 23
64757: PUSH
64758: LD_INT 44
64760: PUSH
64761: LD_INT 48
64763: PUSH
64764: LD_INT 49
64766: PUSH
64767: LD_INT 50
64769: PUSH
64770: LD_INT 51
64772: PUSH
64773: LD_INT 52
64775: PUSH
64776: LD_INT 53
64778: PUSH
64779: LD_INT 54
64781: PUSH
64782: LD_INT 55
64784: PUSH
64785: LD_INT 56
64787: PUSH
64788: LD_INT 57
64790: PUSH
64791: LD_INT 58
64793: PUSH
64794: LD_INT 59
64796: PUSH
64797: LD_INT 63
64799: PUSH
64800: LD_INT 64
64802: PUSH
64803: LD_INT 65
64805: PUSH
64806: EMPTY
64807: LIST
64808: LIST
64809: LIST
64810: LIST
64811: LIST
64812: LIST
64813: LIST
64814: LIST
64815: LIST
64816: LIST
64817: LIST
64818: LIST
64819: LIST
64820: LIST
64821: LIST
64822: LIST
64823: LIST
64824: LIST
64825: LIST
64826: LIST
64827: LIST
64828: LIST
64829: LIST
64830: LIST
64831: LIST
64832: LIST
64833: LIST
64834: LIST
64835: LIST
64836: LIST
64837: LIST
64838: LIST
64839: LIST
64840: LIST
64841: LIST
64842: LIST
64843: LIST
64844: LIST
64845: LIST
64846: LIST
64847: LIST
64848: LIST
64849: LIST
64850: ST_TO_ADDR
64851: GO 64854
64853: POP
// if state > - 1 and state < 3 then
64854: LD_VAR 0 3
64858: PUSH
64859: LD_INT 1
64861: NEG
64862: GREATER
64863: PUSH
64864: LD_VAR 0 3
64868: PUSH
64869: LD_INT 3
64871: LESS
64872: AND
64873: IFFALSE 64930
// for i in result do
64875: LD_ADDR_VAR 0 5
64879: PUSH
64880: LD_VAR 0 4
64884: PUSH
64885: FOR_IN
64886: IFFALSE 64928
// if GetTech ( i , side ) <> state then
64888: LD_VAR 0 5
64892: PPUSH
64893: LD_VAR 0 1
64897: PPUSH
64898: CALL_OW 321
64902: PUSH
64903: LD_VAR 0 3
64907: NONEQUAL
64908: IFFALSE 64926
// result := result diff i ;
64910: LD_ADDR_VAR 0 4
64914: PUSH
64915: LD_VAR 0 4
64919: PUSH
64920: LD_VAR 0 5
64924: DIFF
64925: ST_TO_ADDR
64926: GO 64885
64928: POP
64929: POP
// end ;
64930: LD_VAR 0 4
64934: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64935: LD_INT 0
64937: PPUSH
64938: PPUSH
64939: PPUSH
// result := true ;
64940: LD_ADDR_VAR 0 3
64944: PUSH
64945: LD_INT 1
64947: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64948: LD_ADDR_VAR 0 5
64952: PUSH
64953: LD_VAR 0 2
64957: PPUSH
64958: CALL_OW 480
64962: ST_TO_ADDR
// if not tmp then
64963: LD_VAR 0 5
64967: NOT
64968: IFFALSE 64972
// exit ;
64970: GO 65021
// for i in tmp do
64972: LD_ADDR_VAR 0 4
64976: PUSH
64977: LD_VAR 0 5
64981: PUSH
64982: FOR_IN
64983: IFFALSE 65019
// if GetTech ( i , side ) <> state_researched then
64985: LD_VAR 0 4
64989: PPUSH
64990: LD_VAR 0 1
64994: PPUSH
64995: CALL_OW 321
64999: PUSH
65000: LD_INT 2
65002: NONEQUAL
65003: IFFALSE 65017
// begin result := false ;
65005: LD_ADDR_VAR 0 3
65009: PUSH
65010: LD_INT 0
65012: ST_TO_ADDR
// exit ;
65013: POP
65014: POP
65015: GO 65021
// end ;
65017: GO 64982
65019: POP
65020: POP
// end ;
65021: LD_VAR 0 3
65025: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65026: LD_INT 0
65028: PPUSH
65029: PPUSH
65030: PPUSH
65031: PPUSH
65032: PPUSH
65033: PPUSH
65034: PPUSH
65035: PPUSH
65036: PPUSH
65037: PPUSH
65038: PPUSH
65039: PPUSH
65040: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65041: LD_VAR 0 1
65045: NOT
65046: PUSH
65047: LD_VAR 0 1
65051: PPUSH
65052: CALL_OW 257
65056: PUSH
65057: LD_INT 9
65059: NONEQUAL
65060: OR
65061: IFFALSE 65065
// exit ;
65063: GO 65638
// side := GetSide ( unit ) ;
65065: LD_ADDR_VAR 0 9
65069: PUSH
65070: LD_VAR 0 1
65074: PPUSH
65075: CALL_OW 255
65079: ST_TO_ADDR
// tech_space := tech_spacanom ;
65080: LD_ADDR_VAR 0 12
65084: PUSH
65085: LD_INT 29
65087: ST_TO_ADDR
// tech_time := tech_taurad ;
65088: LD_ADDR_VAR 0 13
65092: PUSH
65093: LD_INT 28
65095: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65096: LD_ADDR_VAR 0 11
65100: PUSH
65101: LD_VAR 0 1
65105: PPUSH
65106: CALL_OW 310
65110: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65111: LD_VAR 0 11
65115: PPUSH
65116: CALL_OW 247
65120: PUSH
65121: LD_INT 2
65123: EQUAL
65124: IFFALSE 65128
// exit ;
65126: GO 65638
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65128: LD_ADDR_VAR 0 8
65132: PUSH
65133: LD_INT 81
65135: PUSH
65136: LD_VAR 0 9
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: LD_INT 3
65147: PUSH
65148: LD_INT 21
65150: PUSH
65151: LD_INT 3
65153: PUSH
65154: EMPTY
65155: LIST
65156: LIST
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PPUSH
65166: CALL_OW 69
65170: ST_TO_ADDR
// if not tmp then
65171: LD_VAR 0 8
65175: NOT
65176: IFFALSE 65180
// exit ;
65178: GO 65638
// if in_unit then
65180: LD_VAR 0 11
65184: IFFALSE 65208
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65186: LD_ADDR_VAR 0 10
65190: PUSH
65191: LD_VAR 0 8
65195: PPUSH
65196: LD_VAR 0 11
65200: PPUSH
65201: CALL_OW 74
65205: ST_TO_ADDR
65206: GO 65228
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65208: LD_ADDR_VAR 0 10
65212: PUSH
65213: LD_VAR 0 8
65217: PPUSH
65218: LD_VAR 0 1
65222: PPUSH
65223: CALL_OW 74
65227: ST_TO_ADDR
// if not enemy then
65228: LD_VAR 0 10
65232: NOT
65233: IFFALSE 65237
// exit ;
65235: GO 65638
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65237: LD_VAR 0 11
65241: PUSH
65242: LD_VAR 0 11
65246: PPUSH
65247: LD_VAR 0 10
65251: PPUSH
65252: CALL_OW 296
65256: PUSH
65257: LD_INT 13
65259: GREATER
65260: AND
65261: PUSH
65262: LD_VAR 0 1
65266: PPUSH
65267: LD_VAR 0 10
65271: PPUSH
65272: CALL_OW 296
65276: PUSH
65277: LD_INT 12
65279: GREATER
65280: OR
65281: IFFALSE 65285
// exit ;
65283: GO 65638
// missile := [ 1 ] ;
65285: LD_ADDR_VAR 0 14
65289: PUSH
65290: LD_INT 1
65292: PUSH
65293: EMPTY
65294: LIST
65295: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65296: LD_VAR 0 9
65300: PPUSH
65301: LD_VAR 0 12
65305: PPUSH
65306: CALL_OW 325
65310: IFFALSE 65339
// missile := Insert ( missile , missile + 1 , 2 ) ;
65312: LD_ADDR_VAR 0 14
65316: PUSH
65317: LD_VAR 0 14
65321: PPUSH
65322: LD_VAR 0 14
65326: PUSH
65327: LD_INT 1
65329: PLUS
65330: PPUSH
65331: LD_INT 2
65333: PPUSH
65334: CALL_OW 2
65338: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65339: LD_VAR 0 9
65343: PPUSH
65344: LD_VAR 0 13
65348: PPUSH
65349: CALL_OW 325
65353: PUSH
65354: LD_VAR 0 10
65358: PPUSH
65359: CALL_OW 255
65363: PPUSH
65364: LD_VAR 0 13
65368: PPUSH
65369: CALL_OW 325
65373: NOT
65374: AND
65375: IFFALSE 65404
// missile := Insert ( missile , missile + 1 , 3 ) ;
65377: LD_ADDR_VAR 0 14
65381: PUSH
65382: LD_VAR 0 14
65386: PPUSH
65387: LD_VAR 0 14
65391: PUSH
65392: LD_INT 1
65394: PLUS
65395: PPUSH
65396: LD_INT 3
65398: PPUSH
65399: CALL_OW 2
65403: ST_TO_ADDR
// if missile < 2 then
65404: LD_VAR 0 14
65408: PUSH
65409: LD_INT 2
65411: LESS
65412: IFFALSE 65416
// exit ;
65414: GO 65638
// x := GetX ( enemy ) ;
65416: LD_ADDR_VAR 0 4
65420: PUSH
65421: LD_VAR 0 10
65425: PPUSH
65426: CALL_OW 250
65430: ST_TO_ADDR
// y := GetY ( enemy ) ;
65431: LD_ADDR_VAR 0 5
65435: PUSH
65436: LD_VAR 0 10
65440: PPUSH
65441: CALL_OW 251
65445: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65446: LD_ADDR_VAR 0 6
65450: PUSH
65451: LD_VAR 0 4
65455: PUSH
65456: LD_INT 1
65458: NEG
65459: PPUSH
65460: LD_INT 1
65462: PPUSH
65463: CALL_OW 12
65467: PLUS
65468: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65469: LD_ADDR_VAR 0 7
65473: PUSH
65474: LD_VAR 0 5
65478: PUSH
65479: LD_INT 1
65481: NEG
65482: PPUSH
65483: LD_INT 1
65485: PPUSH
65486: CALL_OW 12
65490: PLUS
65491: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65492: LD_VAR 0 6
65496: PPUSH
65497: LD_VAR 0 7
65501: PPUSH
65502: CALL_OW 488
65506: NOT
65507: IFFALSE 65529
// begin _x := x ;
65509: LD_ADDR_VAR 0 6
65513: PUSH
65514: LD_VAR 0 4
65518: ST_TO_ADDR
// _y := y ;
65519: LD_ADDR_VAR 0 7
65523: PUSH
65524: LD_VAR 0 5
65528: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65529: LD_ADDR_VAR 0 3
65533: PUSH
65534: LD_INT 1
65536: PPUSH
65537: LD_VAR 0 14
65541: PPUSH
65542: CALL_OW 12
65546: ST_TO_ADDR
// case i of 1 :
65547: LD_VAR 0 3
65551: PUSH
65552: LD_INT 1
65554: DOUBLE
65555: EQUAL
65556: IFTRUE 65560
65558: GO 65577
65560: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65561: LD_VAR 0 1
65565: PPUSH
65566: LD_VAR 0 10
65570: PPUSH
65571: CALL_OW 115
65575: GO 65638
65577: LD_INT 2
65579: DOUBLE
65580: EQUAL
65581: IFTRUE 65585
65583: GO 65607
65585: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65586: LD_VAR 0 1
65590: PPUSH
65591: LD_VAR 0 6
65595: PPUSH
65596: LD_VAR 0 7
65600: PPUSH
65601: CALL_OW 153
65605: GO 65638
65607: LD_INT 3
65609: DOUBLE
65610: EQUAL
65611: IFTRUE 65615
65613: GO 65637
65615: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65616: LD_VAR 0 1
65620: PPUSH
65621: LD_VAR 0 6
65625: PPUSH
65626: LD_VAR 0 7
65630: PPUSH
65631: CALL_OW 154
65635: GO 65638
65637: POP
// end ;
65638: LD_VAR 0 2
65642: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65643: LD_INT 0
65645: PPUSH
65646: PPUSH
65647: PPUSH
65648: PPUSH
65649: PPUSH
65650: PPUSH
// if not unit or not building then
65651: LD_VAR 0 1
65655: NOT
65656: PUSH
65657: LD_VAR 0 2
65661: NOT
65662: OR
65663: IFFALSE 65667
// exit ;
65665: GO 65825
// x := GetX ( building ) ;
65667: LD_ADDR_VAR 0 5
65671: PUSH
65672: LD_VAR 0 2
65676: PPUSH
65677: CALL_OW 250
65681: ST_TO_ADDR
// y := GetY ( building ) ;
65682: LD_ADDR_VAR 0 6
65686: PUSH
65687: LD_VAR 0 2
65691: PPUSH
65692: CALL_OW 251
65696: ST_TO_ADDR
// for i = 0 to 5 do
65697: LD_ADDR_VAR 0 4
65701: PUSH
65702: DOUBLE
65703: LD_INT 0
65705: DEC
65706: ST_TO_ADDR
65707: LD_INT 5
65709: PUSH
65710: FOR_TO
65711: IFFALSE 65823
// begin _x := ShiftX ( x , i , 3 ) ;
65713: LD_ADDR_VAR 0 7
65717: PUSH
65718: LD_VAR 0 5
65722: PPUSH
65723: LD_VAR 0 4
65727: PPUSH
65728: LD_INT 3
65730: PPUSH
65731: CALL_OW 272
65735: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65736: LD_ADDR_VAR 0 8
65740: PUSH
65741: LD_VAR 0 6
65745: PPUSH
65746: LD_VAR 0 4
65750: PPUSH
65751: LD_INT 3
65753: PPUSH
65754: CALL_OW 273
65758: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65759: LD_VAR 0 7
65763: PPUSH
65764: LD_VAR 0 8
65768: PPUSH
65769: CALL_OW 488
65773: NOT
65774: IFFALSE 65778
// continue ;
65776: GO 65710
// if HexInfo ( _x , _y ) = 0 then
65778: LD_VAR 0 7
65782: PPUSH
65783: LD_VAR 0 8
65787: PPUSH
65788: CALL_OW 428
65792: PUSH
65793: LD_INT 0
65795: EQUAL
65796: IFFALSE 65821
// begin ComMoveXY ( unit , _x , _y ) ;
65798: LD_VAR 0 1
65802: PPUSH
65803: LD_VAR 0 7
65807: PPUSH
65808: LD_VAR 0 8
65812: PPUSH
65813: CALL_OW 111
// exit ;
65817: POP
65818: POP
65819: GO 65825
// end ; end ;
65821: GO 65710
65823: POP
65824: POP
// end ;
65825: LD_VAR 0 3
65829: RET
// export function ScanBase ( side , base_area ) ; begin
65830: LD_INT 0
65832: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65833: LD_ADDR_VAR 0 3
65837: PUSH
65838: LD_VAR 0 2
65842: PPUSH
65843: LD_INT 81
65845: PUSH
65846: LD_VAR 0 1
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: PPUSH
65855: CALL_OW 70
65859: ST_TO_ADDR
// end ;
65860: LD_VAR 0 3
65864: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65865: LD_INT 0
65867: PPUSH
65868: PPUSH
65869: PPUSH
65870: PPUSH
65871: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65872: LD_VAR 0 1
65876: NOT
65877: PUSH
65878: LD_EXP 101
65882: PUSH
65883: LD_VAR 0 1
65887: ARRAY
65888: NOT
65889: OR
65890: PUSH
65891: LD_VAR 0 2
65895: NOT
65896: OR
65897: PUSH
65898: LD_VAR 0 3
65902: NOT
65903: OR
65904: IFFALSE 65908
// exit ;
65906: GO 66421
// side := mc_sides [ base ] ;
65908: LD_ADDR_VAR 0 6
65912: PUSH
65913: LD_EXP 127
65917: PUSH
65918: LD_VAR 0 1
65922: ARRAY
65923: ST_TO_ADDR
// if not side then
65924: LD_VAR 0 6
65928: NOT
65929: IFFALSE 65933
// exit ;
65931: GO 66421
// for i in solds do
65933: LD_ADDR_VAR 0 7
65937: PUSH
65938: LD_VAR 0 2
65942: PUSH
65943: FOR_IN
65944: IFFALSE 66005
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
65946: LD_VAR 0 7
65950: PPUSH
65951: CALL_OW 310
65955: PPUSH
65956: CALL_OW 266
65960: PUSH
65961: LD_INT 32
65963: PUSH
65964: LD_INT 31
65966: PUSH
65967: EMPTY
65968: LIST
65969: LIST
65970: IN
65971: IFFALSE 65991
// solds := solds diff i else
65973: LD_ADDR_VAR 0 2
65977: PUSH
65978: LD_VAR 0 2
65982: PUSH
65983: LD_VAR 0 7
65987: DIFF
65988: ST_TO_ADDR
65989: GO 66003
// SetTag ( i , 18 ) ;
65991: LD_VAR 0 7
65995: PPUSH
65996: LD_INT 18
65998: PPUSH
65999: CALL_OW 109
66003: GO 65943
66005: POP
66006: POP
// if not solds then
66007: LD_VAR 0 2
66011: NOT
66012: IFFALSE 66016
// exit ;
66014: GO 66421
// repeat wait ( 0 0$1 ) ;
66016: LD_INT 35
66018: PPUSH
66019: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66023: LD_ADDR_VAR 0 5
66027: PUSH
66028: LD_VAR 0 6
66032: PPUSH
66033: LD_VAR 0 3
66037: PPUSH
66038: CALL 65830 0 2
66042: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66043: LD_EXP 101
66047: PUSH
66048: LD_VAR 0 1
66052: ARRAY
66053: NOT
66054: PUSH
66055: LD_EXP 101
66059: PUSH
66060: LD_VAR 0 1
66064: ARRAY
66065: PUSH
66066: EMPTY
66067: EQUAL
66068: OR
66069: IFFALSE 66106
// begin for i in solds do
66071: LD_ADDR_VAR 0 7
66075: PUSH
66076: LD_VAR 0 2
66080: PUSH
66081: FOR_IN
66082: IFFALSE 66095
// ComStop ( i ) ;
66084: LD_VAR 0 7
66088: PPUSH
66089: CALL_OW 141
66093: GO 66081
66095: POP
66096: POP
// solds := [ ] ;
66097: LD_ADDR_VAR 0 2
66101: PUSH
66102: EMPTY
66103: ST_TO_ADDR
// exit ;
66104: GO 66421
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66106: LD_VAR 0 5
66110: NOT
66111: PUSH
66112: LD_VAR 0 5
66116: PUSH
66117: LD_INT 3
66119: GREATER
66120: OR
66121: PUSH
66122: LD_EXP 123
66126: PUSH
66127: LD_VAR 0 1
66131: ARRAY
66132: OR
66133: IFFALSE 66174
// begin for i in solds do
66135: LD_ADDR_VAR 0 7
66139: PUSH
66140: LD_VAR 0 2
66144: PUSH
66145: FOR_IN
66146: IFFALSE 66170
// if HasTask ( i ) then
66148: LD_VAR 0 7
66152: PPUSH
66153: CALL_OW 314
66157: IFFALSE 66168
// ComStop ( i ) ;
66159: LD_VAR 0 7
66163: PPUSH
66164: CALL_OW 141
66168: GO 66145
66170: POP
66171: POP
// break ;
66172: GO 66409
// end ; for i in solds do
66174: LD_ADDR_VAR 0 7
66178: PUSH
66179: LD_VAR 0 2
66183: PUSH
66184: FOR_IN
66185: IFFALSE 66401
// begin if IsInUnit ( i ) then
66187: LD_VAR 0 7
66191: PPUSH
66192: CALL_OW 310
66196: IFFALSE 66207
// ComExitBuilding ( i ) ;
66198: LD_VAR 0 7
66202: PPUSH
66203: CALL_OW 122
// if GetLives ( i ) > 333 then
66207: LD_VAR 0 7
66211: PPUSH
66212: CALL_OW 256
66216: PUSH
66217: LD_INT 333
66219: GREATER
66220: IFFALSE 66248
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66222: LD_VAR 0 7
66226: PPUSH
66227: LD_VAR 0 5
66231: PPUSH
66232: LD_VAR 0 7
66236: PPUSH
66237: CALL_OW 74
66241: PPUSH
66242: CALL_OW 115
66246: GO 66399
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66248: LD_ADDR_VAR 0 8
66252: PUSH
66253: LD_EXP 101
66257: PUSH
66258: LD_VAR 0 1
66262: ARRAY
66263: PPUSH
66264: LD_INT 2
66266: PUSH
66267: LD_INT 30
66269: PUSH
66270: LD_INT 0
66272: PUSH
66273: EMPTY
66274: LIST
66275: LIST
66276: PUSH
66277: LD_INT 30
66279: PUSH
66280: LD_INT 1
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: LD_INT 30
66289: PUSH
66290: LD_INT 6
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: PPUSH
66303: CALL_OW 72
66307: PPUSH
66308: LD_VAR 0 7
66312: PPUSH
66313: CALL_OW 74
66317: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66318: LD_VAR 0 7
66322: PPUSH
66323: LD_VAR 0 8
66327: PPUSH
66328: CALL_OW 250
66332: PPUSH
66333: LD_INT 3
66335: PPUSH
66336: LD_INT 5
66338: PPUSH
66339: CALL_OW 272
66343: PPUSH
66344: LD_VAR 0 8
66348: PPUSH
66349: CALL_OW 251
66353: PPUSH
66354: LD_INT 3
66356: PPUSH
66357: LD_INT 5
66359: PPUSH
66360: CALL_OW 273
66364: PPUSH
66365: CALL_OW 111
// SetTag ( i , 0 ) ;
66369: LD_VAR 0 7
66373: PPUSH
66374: LD_INT 0
66376: PPUSH
66377: CALL_OW 109
// solds := solds diff i ;
66381: LD_ADDR_VAR 0 2
66385: PUSH
66386: LD_VAR 0 2
66390: PUSH
66391: LD_VAR 0 7
66395: DIFF
66396: ST_TO_ADDR
// continue ;
66397: GO 66184
// end ; end ;
66399: GO 66184
66401: POP
66402: POP
// until solds ;
66403: LD_VAR 0 2
66407: IFFALSE 66016
// MC_Reset ( base , 18 ) ;
66409: LD_VAR 0 1
66413: PPUSH
66414: LD_INT 18
66416: PPUSH
66417: CALL 38138 0 2
// end ;
66421: LD_VAR 0 4
66425: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66426: LD_INT 0
66428: PPUSH
66429: PPUSH
66430: PPUSH
66431: PPUSH
66432: PPUSH
66433: PPUSH
66434: PPUSH
66435: PPUSH
66436: PPUSH
66437: PPUSH
66438: PPUSH
66439: PPUSH
66440: PPUSH
66441: PPUSH
66442: PPUSH
66443: PPUSH
66444: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66445: LD_ADDR_VAR 0 13
66449: PUSH
66450: LD_EXP 101
66454: PUSH
66455: LD_VAR 0 1
66459: ARRAY
66460: PPUSH
66461: LD_INT 25
66463: PUSH
66464: LD_INT 3
66466: PUSH
66467: EMPTY
66468: LIST
66469: LIST
66470: PPUSH
66471: CALL_OW 72
66475: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66476: LD_EXP 141
66480: PUSH
66481: LD_VAR 0 1
66485: ARRAY
66486: IFFALSE 66510
// mechs := mechs diff mc_remote_driver [ base ] ;
66488: LD_ADDR_VAR 0 13
66492: PUSH
66493: LD_VAR 0 13
66497: PUSH
66498: LD_EXP 141
66502: PUSH
66503: LD_VAR 0 1
66507: ARRAY
66508: DIFF
66509: ST_TO_ADDR
// for i in mechs do
66510: LD_ADDR_VAR 0 5
66514: PUSH
66515: LD_VAR 0 13
66519: PUSH
66520: FOR_IN
66521: IFFALSE 66556
// if GetTag ( i ) > 0 then
66523: LD_VAR 0 5
66527: PPUSH
66528: CALL_OW 110
66532: PUSH
66533: LD_INT 0
66535: GREATER
66536: IFFALSE 66554
// mechs := mechs diff i ;
66538: LD_ADDR_VAR 0 13
66542: PUSH
66543: LD_VAR 0 13
66547: PUSH
66548: LD_VAR 0 5
66552: DIFF
66553: ST_TO_ADDR
66554: GO 66520
66556: POP
66557: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66558: LD_ADDR_VAR 0 9
66562: PUSH
66563: LD_EXP 101
66567: PUSH
66568: LD_VAR 0 1
66572: ARRAY
66573: PPUSH
66574: LD_INT 2
66576: PUSH
66577: LD_INT 25
66579: PUSH
66580: LD_INT 1
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 25
66589: PUSH
66590: LD_INT 5
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 25
66599: PUSH
66600: LD_INT 8
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 25
66609: PUSH
66610: LD_INT 9
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: EMPTY
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: PPUSH
66624: CALL_OW 72
66628: ST_TO_ADDR
// if not defenders and not solds then
66629: LD_VAR 0 2
66633: NOT
66634: PUSH
66635: LD_VAR 0 9
66639: NOT
66640: AND
66641: IFFALSE 66645
// exit ;
66643: GO 68271
// depot_under_attack := false ;
66645: LD_ADDR_VAR 0 17
66649: PUSH
66650: LD_INT 0
66652: ST_TO_ADDR
// sold_defenders := [ ] ;
66653: LD_ADDR_VAR 0 18
66657: PUSH
66658: EMPTY
66659: ST_TO_ADDR
// if mechs then
66660: LD_VAR 0 13
66664: IFFALSE 66793
// for i in defenders do
66666: LD_ADDR_VAR 0 5
66670: PUSH
66671: LD_VAR 0 2
66675: PUSH
66676: FOR_IN
66677: IFFALSE 66791
// begin SetTag ( i , 20 ) ;
66679: LD_VAR 0 5
66683: PPUSH
66684: LD_INT 20
66686: PPUSH
66687: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66691: LD_VAR 0 5
66695: PPUSH
66696: CALL_OW 263
66700: PUSH
66701: LD_INT 1
66703: EQUAL
66704: PUSH
66705: LD_VAR 0 5
66709: PPUSH
66710: CALL_OW 311
66714: NOT
66715: AND
66716: PUSH
66717: LD_VAR 0 13
66721: AND
66722: IFFALSE 66789
// begin un := mechs [ 1 ] ;
66724: LD_ADDR_VAR 0 11
66728: PUSH
66729: LD_VAR 0 13
66733: PUSH
66734: LD_INT 1
66736: ARRAY
66737: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66738: LD_VAR 0 11
66742: PPUSH
66743: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66747: LD_VAR 0 11
66751: PPUSH
66752: LD_VAR 0 5
66756: PPUSH
66757: CALL_OW 180
// SetTag ( un , 19 ) ;
66761: LD_VAR 0 11
66765: PPUSH
66766: LD_INT 19
66768: PPUSH
66769: CALL_OW 109
// mechs := mechs diff un ;
66773: LD_ADDR_VAR 0 13
66777: PUSH
66778: LD_VAR 0 13
66782: PUSH
66783: LD_VAR 0 11
66787: DIFF
66788: ST_TO_ADDR
// end ; end ;
66789: GO 66676
66791: POP
66792: POP
// if solds then
66793: LD_VAR 0 9
66797: IFFALSE 66856
// for i in solds do
66799: LD_ADDR_VAR 0 5
66803: PUSH
66804: LD_VAR 0 9
66808: PUSH
66809: FOR_IN
66810: IFFALSE 66854
// if not GetTag ( i ) then
66812: LD_VAR 0 5
66816: PPUSH
66817: CALL_OW 110
66821: NOT
66822: IFFALSE 66852
// begin defenders := defenders union i ;
66824: LD_ADDR_VAR 0 2
66828: PUSH
66829: LD_VAR 0 2
66833: PUSH
66834: LD_VAR 0 5
66838: UNION
66839: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66840: LD_VAR 0 5
66844: PPUSH
66845: LD_INT 18
66847: PPUSH
66848: CALL_OW 109
// end ;
66852: GO 66809
66854: POP
66855: POP
// repeat wait ( 0 0$1 ) ;
66856: LD_INT 35
66858: PPUSH
66859: CALL_OW 67
// enemy := mc_scan [ base ] ;
66863: LD_ADDR_VAR 0 3
66867: PUSH
66868: LD_EXP 124
66872: PUSH
66873: LD_VAR 0 1
66877: ARRAY
66878: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66879: LD_EXP 101
66883: PUSH
66884: LD_VAR 0 1
66888: ARRAY
66889: NOT
66890: PUSH
66891: LD_EXP 101
66895: PUSH
66896: LD_VAR 0 1
66900: ARRAY
66901: PUSH
66902: EMPTY
66903: EQUAL
66904: OR
66905: IFFALSE 66942
// begin for i in defenders do
66907: LD_ADDR_VAR 0 5
66911: PUSH
66912: LD_VAR 0 2
66916: PUSH
66917: FOR_IN
66918: IFFALSE 66931
// ComStop ( i ) ;
66920: LD_VAR 0 5
66924: PPUSH
66925: CALL_OW 141
66929: GO 66917
66931: POP
66932: POP
// defenders := [ ] ;
66933: LD_ADDR_VAR 0 2
66937: PUSH
66938: EMPTY
66939: ST_TO_ADDR
// exit ;
66940: GO 68271
// end ; for i in defenders do
66942: LD_ADDR_VAR 0 5
66946: PUSH
66947: LD_VAR 0 2
66951: PUSH
66952: FOR_IN
66953: IFFALSE 67771
// begin e := NearestUnitToUnit ( enemy , i ) ;
66955: LD_ADDR_VAR 0 14
66959: PUSH
66960: LD_VAR 0 3
66964: PPUSH
66965: LD_VAR 0 5
66969: PPUSH
66970: CALL_OW 74
66974: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66975: LD_ADDR_VAR 0 8
66979: PUSH
66980: LD_EXP 101
66984: PUSH
66985: LD_VAR 0 1
66989: ARRAY
66990: PPUSH
66991: LD_INT 2
66993: PUSH
66994: LD_INT 30
66996: PUSH
66997: LD_INT 0
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 30
67006: PUSH
67007: LD_INT 1
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: LIST
67018: PPUSH
67019: CALL_OW 72
67023: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67024: LD_ADDR_VAR 0 17
67028: PUSH
67029: LD_VAR 0 8
67033: NOT
67034: PUSH
67035: LD_VAR 0 8
67039: PPUSH
67040: LD_INT 3
67042: PUSH
67043: LD_INT 24
67045: PUSH
67046: LD_INT 600
67048: PUSH
67049: EMPTY
67050: LIST
67051: LIST
67052: PUSH
67053: EMPTY
67054: LIST
67055: LIST
67056: PPUSH
67057: CALL_OW 72
67061: OR
67062: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67063: LD_VAR 0 5
67067: PPUSH
67068: CALL_OW 247
67072: PUSH
67073: LD_INT 2
67075: DOUBLE
67076: EQUAL
67077: IFTRUE 67081
67079: GO 67477
67081: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67082: LD_VAR 0 5
67086: PPUSH
67087: CALL_OW 256
67091: PUSH
67092: LD_INT 650
67094: GREATER
67095: PUSH
67096: LD_VAR 0 5
67100: PPUSH
67101: LD_VAR 0 14
67105: PPUSH
67106: CALL_OW 296
67110: PUSH
67111: LD_INT 40
67113: LESS
67114: PUSH
67115: LD_VAR 0 14
67119: PPUSH
67120: LD_EXP 126
67124: PUSH
67125: LD_VAR 0 1
67129: ARRAY
67130: PPUSH
67131: CALL_OW 308
67135: OR
67136: AND
67137: IFFALSE 67259
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67139: LD_VAR 0 5
67143: PPUSH
67144: CALL_OW 262
67148: PUSH
67149: LD_INT 1
67151: EQUAL
67152: PUSH
67153: LD_VAR 0 5
67157: PPUSH
67158: CALL_OW 261
67162: PUSH
67163: LD_INT 30
67165: LESS
67166: AND
67167: PUSH
67168: LD_VAR 0 8
67172: AND
67173: IFFALSE 67243
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67175: LD_VAR 0 5
67179: PPUSH
67180: LD_VAR 0 8
67184: PPUSH
67185: LD_VAR 0 5
67189: PPUSH
67190: CALL_OW 74
67194: PPUSH
67195: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67199: LD_VAR 0 5
67203: PPUSH
67204: LD_VAR 0 8
67208: PPUSH
67209: LD_VAR 0 5
67213: PPUSH
67214: CALL_OW 74
67218: PPUSH
67219: CALL_OW 296
67223: PUSH
67224: LD_INT 6
67226: LESS
67227: IFFALSE 67241
// SetFuel ( i , 100 ) ;
67229: LD_VAR 0 5
67233: PPUSH
67234: LD_INT 100
67236: PPUSH
67237: CALL_OW 240
// end else
67241: GO 67257
// ComAttackUnit ( i , e ) ;
67243: LD_VAR 0 5
67247: PPUSH
67248: LD_VAR 0 14
67252: PPUSH
67253: CALL_OW 115
// end else
67257: GO 67360
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67259: LD_VAR 0 14
67263: PPUSH
67264: LD_EXP 126
67268: PUSH
67269: LD_VAR 0 1
67273: ARRAY
67274: PPUSH
67275: CALL_OW 308
67279: NOT
67280: PUSH
67281: LD_VAR 0 5
67285: PPUSH
67286: LD_VAR 0 14
67290: PPUSH
67291: CALL_OW 296
67295: PUSH
67296: LD_INT 40
67298: GREATEREQUAL
67299: AND
67300: PUSH
67301: LD_VAR 0 5
67305: PPUSH
67306: CALL_OW 256
67310: PUSH
67311: LD_INT 650
67313: LESSEQUAL
67314: OR
67315: PUSH
67316: LD_VAR 0 5
67320: PPUSH
67321: LD_EXP 125
67325: PUSH
67326: LD_VAR 0 1
67330: ARRAY
67331: PPUSH
67332: CALL_OW 308
67336: NOT
67337: AND
67338: IFFALSE 67360
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67340: LD_VAR 0 5
67344: PPUSH
67345: LD_EXP 125
67349: PUSH
67350: LD_VAR 0 1
67354: ARRAY
67355: PPUSH
67356: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67360: LD_VAR 0 5
67364: PPUSH
67365: CALL_OW 256
67369: PUSH
67370: LD_INT 998
67372: LESS
67373: PUSH
67374: LD_VAR 0 5
67378: PPUSH
67379: CALL_OW 263
67383: PUSH
67384: LD_INT 1
67386: EQUAL
67387: AND
67388: PUSH
67389: LD_VAR 0 5
67393: PPUSH
67394: CALL_OW 311
67398: AND
67399: PUSH
67400: LD_VAR 0 5
67404: PPUSH
67405: LD_EXP 125
67409: PUSH
67410: LD_VAR 0 1
67414: ARRAY
67415: PPUSH
67416: CALL_OW 308
67420: AND
67421: IFFALSE 67475
// begin mech := IsDrivenBy ( i ) ;
67423: LD_ADDR_VAR 0 10
67427: PUSH
67428: LD_VAR 0 5
67432: PPUSH
67433: CALL_OW 311
67437: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67438: LD_VAR 0 10
67442: PPUSH
67443: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67447: LD_VAR 0 10
67451: PPUSH
67452: LD_VAR 0 5
67456: PPUSH
67457: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67461: LD_VAR 0 10
67465: PPUSH
67466: LD_VAR 0 5
67470: PPUSH
67471: CALL_OW 180
// end ; end ; unit_human :
67475: GO 67742
67477: LD_INT 1
67479: DOUBLE
67480: EQUAL
67481: IFTRUE 67485
67483: GO 67741
67485: POP
// begin b := IsInUnit ( i ) ;
67486: LD_ADDR_VAR 0 19
67490: PUSH
67491: LD_VAR 0 5
67495: PPUSH
67496: CALL_OW 310
67500: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67501: LD_ADDR_VAR 0 20
67505: PUSH
67506: LD_VAR 0 19
67510: NOT
67511: PUSH
67512: LD_VAR 0 19
67516: PPUSH
67517: CALL_OW 266
67521: PUSH
67522: LD_INT 32
67524: PUSH
67525: LD_INT 31
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: IN
67532: OR
67533: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67534: LD_VAR 0 17
67538: PUSH
67539: LD_VAR 0 2
67543: PPUSH
67544: LD_INT 21
67546: PUSH
67547: LD_INT 2
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PPUSH
67554: CALL_OW 72
67558: PUSH
67559: LD_INT 1
67561: LESSEQUAL
67562: OR
67563: PUSH
67564: LD_VAR 0 20
67568: AND
67569: PUSH
67570: LD_VAR 0 5
67574: PUSH
67575: LD_VAR 0 18
67579: IN
67580: NOT
67581: AND
67582: IFFALSE 67675
// begin if b then
67584: LD_VAR 0 19
67588: IFFALSE 67637
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67590: LD_VAR 0 19
67594: PPUSH
67595: LD_VAR 0 3
67599: PPUSH
67600: LD_VAR 0 19
67604: PPUSH
67605: CALL_OW 74
67609: PPUSH
67610: CALL_OW 296
67614: PUSH
67615: LD_INT 10
67617: LESS
67618: PUSH
67619: LD_VAR 0 19
67623: PPUSH
67624: CALL_OW 461
67628: PUSH
67629: LD_INT 7
67631: NONEQUAL
67632: AND
67633: IFFALSE 67637
// continue ;
67635: GO 66952
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67637: LD_ADDR_VAR 0 18
67641: PUSH
67642: LD_VAR 0 18
67646: PPUSH
67647: LD_VAR 0 18
67651: PUSH
67652: LD_INT 1
67654: PLUS
67655: PPUSH
67656: LD_VAR 0 5
67660: PPUSH
67661: CALL_OW 1
67665: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67666: LD_VAR 0 5
67670: PPUSH
67671: CALL_OW 122
// end ; if sold_defenders then
67675: LD_VAR 0 18
67679: IFFALSE 67739
// if i in sold_defenders then
67681: LD_VAR 0 5
67685: PUSH
67686: LD_VAR 0 18
67690: IN
67691: IFFALSE 67739
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67693: LD_VAR 0 5
67697: PPUSH
67698: CALL_OW 314
67702: NOT
67703: PUSH
67704: LD_VAR 0 5
67708: PPUSH
67709: LD_VAR 0 14
67713: PPUSH
67714: CALL_OW 296
67718: PUSH
67719: LD_INT 30
67721: LESS
67722: AND
67723: IFFALSE 67739
// ComAttackUnit ( i , e ) ;
67725: LD_VAR 0 5
67729: PPUSH
67730: LD_VAR 0 14
67734: PPUSH
67735: CALL_OW 115
// end ; end ; end ;
67739: GO 67742
67741: POP
// if IsDead ( i ) then
67742: LD_VAR 0 5
67746: PPUSH
67747: CALL_OW 301
67751: IFFALSE 67769
// defenders := defenders diff i ;
67753: LD_ADDR_VAR 0 2
67757: PUSH
67758: LD_VAR 0 2
67762: PUSH
67763: LD_VAR 0 5
67767: DIFF
67768: ST_TO_ADDR
// end ;
67769: GO 66952
67771: POP
67772: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67773: LD_VAR 0 3
67777: NOT
67778: PUSH
67779: LD_VAR 0 2
67783: NOT
67784: OR
67785: PUSH
67786: LD_EXP 101
67790: PUSH
67791: LD_VAR 0 1
67795: ARRAY
67796: NOT
67797: OR
67798: IFFALSE 66856
// MC_Reset ( base , 18 ) ;
67800: LD_VAR 0 1
67804: PPUSH
67805: LD_INT 18
67807: PPUSH
67808: CALL 38138 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67812: LD_ADDR_VAR 0 2
67816: PUSH
67817: LD_VAR 0 2
67821: PUSH
67822: LD_VAR 0 2
67826: PPUSH
67827: LD_INT 2
67829: PUSH
67830: LD_INT 25
67832: PUSH
67833: LD_INT 1
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: PUSH
67840: LD_INT 25
67842: PUSH
67843: LD_INT 5
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: LD_INT 25
67852: PUSH
67853: LD_INT 8
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: LD_INT 25
67862: PUSH
67863: LD_INT 9
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: PPUSH
67877: CALL_OW 72
67881: DIFF
67882: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67883: LD_VAR 0 3
67887: NOT
67888: PUSH
67889: LD_VAR 0 2
67893: PPUSH
67894: LD_INT 21
67896: PUSH
67897: LD_INT 2
67899: PUSH
67900: EMPTY
67901: LIST
67902: LIST
67903: PPUSH
67904: CALL_OW 72
67908: AND
67909: IFFALSE 68247
// begin tmp := FilterByTag ( defenders , 19 ) ;
67911: LD_ADDR_VAR 0 12
67915: PUSH
67916: LD_VAR 0 2
67920: PPUSH
67921: LD_INT 19
67923: PPUSH
67924: CALL 104700 0 2
67928: ST_TO_ADDR
// if tmp then
67929: LD_VAR 0 12
67933: IFFALSE 68003
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
67935: LD_ADDR_VAR 0 12
67939: PUSH
67940: LD_VAR 0 12
67944: PPUSH
67945: LD_INT 25
67947: PUSH
67948: LD_INT 3
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: PPUSH
67955: CALL_OW 72
67959: ST_TO_ADDR
// if tmp then
67960: LD_VAR 0 12
67964: IFFALSE 68003
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
67966: LD_ADDR_EXP 113
67970: PUSH
67971: LD_EXP 113
67975: PPUSH
67976: LD_VAR 0 1
67980: PPUSH
67981: LD_EXP 113
67985: PUSH
67986: LD_VAR 0 1
67990: ARRAY
67991: PUSH
67992: LD_VAR 0 12
67996: UNION
67997: PPUSH
67998: CALL_OW 1
68002: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68003: LD_VAR 0 1
68007: PPUSH
68008: LD_INT 19
68010: PPUSH
68011: CALL 38138 0 2
// repeat wait ( 0 0$1 ) ;
68015: LD_INT 35
68017: PPUSH
68018: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68022: LD_EXP 101
68026: PUSH
68027: LD_VAR 0 1
68031: ARRAY
68032: NOT
68033: PUSH
68034: LD_EXP 101
68038: PUSH
68039: LD_VAR 0 1
68043: ARRAY
68044: PUSH
68045: EMPTY
68046: EQUAL
68047: OR
68048: IFFALSE 68085
// begin for i in defenders do
68050: LD_ADDR_VAR 0 5
68054: PUSH
68055: LD_VAR 0 2
68059: PUSH
68060: FOR_IN
68061: IFFALSE 68074
// ComStop ( i ) ;
68063: LD_VAR 0 5
68067: PPUSH
68068: CALL_OW 141
68072: GO 68060
68074: POP
68075: POP
// defenders := [ ] ;
68076: LD_ADDR_VAR 0 2
68080: PUSH
68081: EMPTY
68082: ST_TO_ADDR
// exit ;
68083: GO 68271
// end ; for i in defenders do
68085: LD_ADDR_VAR 0 5
68089: PUSH
68090: LD_VAR 0 2
68094: PUSH
68095: FOR_IN
68096: IFFALSE 68185
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68098: LD_VAR 0 5
68102: PPUSH
68103: LD_EXP 125
68107: PUSH
68108: LD_VAR 0 1
68112: ARRAY
68113: PPUSH
68114: CALL_OW 308
68118: NOT
68119: IFFALSE 68143
// ComMoveToArea ( i , mc_parking [ base ] ) else
68121: LD_VAR 0 5
68125: PPUSH
68126: LD_EXP 125
68130: PUSH
68131: LD_VAR 0 1
68135: ARRAY
68136: PPUSH
68137: CALL_OW 113
68141: GO 68183
// if GetControl ( i ) = control_manual then
68143: LD_VAR 0 5
68147: PPUSH
68148: CALL_OW 263
68152: PUSH
68153: LD_INT 1
68155: EQUAL
68156: IFFALSE 68183
// if IsDrivenBy ( i ) then
68158: LD_VAR 0 5
68162: PPUSH
68163: CALL_OW 311
68167: IFFALSE 68183
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68169: LD_VAR 0 5
68173: PPUSH
68174: CALL_OW 311
68178: PPUSH
68179: CALL_OW 121
// end ;
68183: GO 68095
68185: POP
68186: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68187: LD_VAR 0 2
68191: PPUSH
68192: LD_INT 95
68194: PUSH
68195: LD_EXP 125
68199: PUSH
68200: LD_VAR 0 1
68204: ARRAY
68205: PUSH
68206: EMPTY
68207: LIST
68208: LIST
68209: PPUSH
68210: CALL_OW 72
68214: PUSH
68215: LD_VAR 0 2
68219: EQUAL
68220: PUSH
68221: LD_EXP 124
68225: PUSH
68226: LD_VAR 0 1
68230: ARRAY
68231: OR
68232: PUSH
68233: LD_EXP 101
68237: PUSH
68238: LD_VAR 0 1
68242: ARRAY
68243: NOT
68244: OR
68245: IFFALSE 68015
// end ; MC_Reset ( base , 19 ) ;
68247: LD_VAR 0 1
68251: PPUSH
68252: LD_INT 19
68254: PPUSH
68255: CALL 38138 0 2
// MC_Reset ( base , 20 ) ;
68259: LD_VAR 0 1
68263: PPUSH
68264: LD_INT 20
68266: PPUSH
68267: CALL 38138 0 2
// end ;
68271: LD_VAR 0 4
68275: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68276: LD_INT 0
68278: PPUSH
68279: PPUSH
68280: PPUSH
68281: PPUSH
// result := false ;
68282: LD_ADDR_VAR 0 2
68286: PUSH
68287: LD_INT 0
68289: ST_TO_ADDR
// side := GetSide ( unit ) ;
68290: LD_ADDR_VAR 0 3
68294: PUSH
68295: LD_VAR 0 1
68299: PPUSH
68300: CALL_OW 255
68304: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68305: LD_ADDR_VAR 0 4
68309: PUSH
68310: LD_VAR 0 1
68314: PPUSH
68315: CALL_OW 248
68319: ST_TO_ADDR
// case nat of 1 :
68320: LD_VAR 0 4
68324: PUSH
68325: LD_INT 1
68327: DOUBLE
68328: EQUAL
68329: IFTRUE 68333
68331: GO 68344
68333: POP
// tech := tech_lassight ; 2 :
68334: LD_ADDR_VAR 0 5
68338: PUSH
68339: LD_INT 12
68341: ST_TO_ADDR
68342: GO 68383
68344: LD_INT 2
68346: DOUBLE
68347: EQUAL
68348: IFTRUE 68352
68350: GO 68363
68352: POP
// tech := tech_mortar ; 3 :
68353: LD_ADDR_VAR 0 5
68357: PUSH
68358: LD_INT 41
68360: ST_TO_ADDR
68361: GO 68383
68363: LD_INT 3
68365: DOUBLE
68366: EQUAL
68367: IFTRUE 68371
68369: GO 68382
68371: POP
// tech := tech_bazooka ; end ;
68372: LD_ADDR_VAR 0 5
68376: PUSH
68377: LD_INT 44
68379: ST_TO_ADDR
68380: GO 68383
68382: POP
// if Researched ( side , tech ) then
68383: LD_VAR 0 3
68387: PPUSH
68388: LD_VAR 0 5
68392: PPUSH
68393: CALL_OW 325
68397: IFFALSE 68424
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68399: LD_ADDR_VAR 0 2
68403: PUSH
68404: LD_INT 5
68406: PUSH
68407: LD_INT 8
68409: PUSH
68410: LD_INT 9
68412: PUSH
68413: EMPTY
68414: LIST
68415: LIST
68416: LIST
68417: PUSH
68418: LD_VAR 0 4
68422: ARRAY
68423: ST_TO_ADDR
// end ;
68424: LD_VAR 0 2
68428: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68429: LD_INT 0
68431: PPUSH
68432: PPUSH
68433: PPUSH
// if not mines then
68434: LD_VAR 0 2
68438: NOT
68439: IFFALSE 68443
// exit ;
68441: GO 68587
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68443: LD_ADDR_VAR 0 5
68447: PUSH
68448: LD_INT 81
68450: PUSH
68451: LD_VAR 0 1
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 3
68462: PUSH
68463: LD_INT 21
68465: PUSH
68466: LD_INT 3
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: EMPTY
68474: LIST
68475: LIST
68476: PUSH
68477: EMPTY
68478: LIST
68479: LIST
68480: PPUSH
68481: CALL_OW 69
68485: ST_TO_ADDR
// for i in mines do
68486: LD_ADDR_VAR 0 4
68490: PUSH
68491: LD_VAR 0 2
68495: PUSH
68496: FOR_IN
68497: IFFALSE 68585
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68499: LD_VAR 0 4
68503: PUSH
68504: LD_INT 1
68506: ARRAY
68507: PPUSH
68508: LD_VAR 0 4
68512: PUSH
68513: LD_INT 2
68515: ARRAY
68516: PPUSH
68517: CALL_OW 458
68521: NOT
68522: IFFALSE 68526
// continue ;
68524: GO 68496
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68526: LD_VAR 0 4
68530: PUSH
68531: LD_INT 1
68533: ARRAY
68534: PPUSH
68535: LD_VAR 0 4
68539: PUSH
68540: LD_INT 2
68542: ARRAY
68543: PPUSH
68544: CALL_OW 428
68548: PUSH
68549: LD_VAR 0 5
68553: IN
68554: IFFALSE 68583
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68556: LD_VAR 0 4
68560: PUSH
68561: LD_INT 1
68563: ARRAY
68564: PPUSH
68565: LD_VAR 0 4
68569: PUSH
68570: LD_INT 2
68572: ARRAY
68573: PPUSH
68574: LD_VAR 0 1
68578: PPUSH
68579: CALL_OW 456
// end ;
68583: GO 68496
68585: POP
68586: POP
// end ;
68587: LD_VAR 0 3
68591: RET
// export function Count ( array ) ; var i ; begin
68592: LD_INT 0
68594: PPUSH
68595: PPUSH
// result := 0 ;
68596: LD_ADDR_VAR 0 2
68600: PUSH
68601: LD_INT 0
68603: ST_TO_ADDR
// for i in array do
68604: LD_ADDR_VAR 0 3
68608: PUSH
68609: LD_VAR 0 1
68613: PUSH
68614: FOR_IN
68615: IFFALSE 68639
// if i then
68617: LD_VAR 0 3
68621: IFFALSE 68637
// result := result + 1 ;
68623: LD_ADDR_VAR 0 2
68627: PUSH
68628: LD_VAR 0 2
68632: PUSH
68633: LD_INT 1
68635: PLUS
68636: ST_TO_ADDR
68637: GO 68614
68639: POP
68640: POP
// end ;
68641: LD_VAR 0 2
68645: RET
// export function IsEmpty ( building ) ; begin
68646: LD_INT 0
68648: PPUSH
// if not building then
68649: LD_VAR 0 1
68653: NOT
68654: IFFALSE 68658
// exit ;
68656: GO 68701
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68658: LD_ADDR_VAR 0 2
68662: PUSH
68663: LD_VAR 0 1
68667: PUSH
68668: LD_INT 22
68670: PUSH
68671: LD_VAR 0 1
68675: PPUSH
68676: CALL_OW 255
68680: PUSH
68681: EMPTY
68682: LIST
68683: LIST
68684: PUSH
68685: LD_INT 58
68687: PUSH
68688: EMPTY
68689: LIST
68690: PUSH
68691: EMPTY
68692: LIST
68693: LIST
68694: PPUSH
68695: CALL_OW 69
68699: IN
68700: ST_TO_ADDR
// end ;
68701: LD_VAR 0 2
68705: RET
// export function IsNotFull ( building ) ; begin
68706: LD_INT 0
68708: PPUSH
// if not building then
68709: LD_VAR 0 1
68713: NOT
68714: IFFALSE 68718
// exit ;
68716: GO 68737
// result := UnitsInside ( building ) < 6 ;
68718: LD_ADDR_VAR 0 2
68722: PUSH
68723: LD_VAR 0 1
68727: PPUSH
68728: CALL_OW 313
68732: PUSH
68733: LD_INT 6
68735: LESS
68736: ST_TO_ADDR
// end ;
68737: LD_VAR 0 2
68741: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68742: LD_INT 0
68744: PPUSH
68745: PPUSH
68746: PPUSH
68747: PPUSH
// tmp := [ ] ;
68748: LD_ADDR_VAR 0 3
68752: PUSH
68753: EMPTY
68754: ST_TO_ADDR
// list := [ ] ;
68755: LD_ADDR_VAR 0 5
68759: PUSH
68760: EMPTY
68761: ST_TO_ADDR
// for i = 16 to 25 do
68762: LD_ADDR_VAR 0 4
68766: PUSH
68767: DOUBLE
68768: LD_INT 16
68770: DEC
68771: ST_TO_ADDR
68772: LD_INT 25
68774: PUSH
68775: FOR_TO
68776: IFFALSE 68849
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68778: LD_ADDR_VAR 0 3
68782: PUSH
68783: LD_VAR 0 3
68787: PUSH
68788: LD_INT 22
68790: PUSH
68791: LD_VAR 0 1
68795: PPUSH
68796: CALL_OW 255
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 91
68807: PUSH
68808: LD_VAR 0 1
68812: PUSH
68813: LD_INT 6
68815: PUSH
68816: EMPTY
68817: LIST
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 30
68823: PUSH
68824: LD_VAR 0 4
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: LIST
68837: PUSH
68838: EMPTY
68839: LIST
68840: PPUSH
68841: CALL_OW 69
68845: ADD
68846: ST_TO_ADDR
68847: GO 68775
68849: POP
68850: POP
// for i = 1 to tmp do
68851: LD_ADDR_VAR 0 4
68855: PUSH
68856: DOUBLE
68857: LD_INT 1
68859: DEC
68860: ST_TO_ADDR
68861: LD_VAR 0 3
68865: PUSH
68866: FOR_TO
68867: IFFALSE 68955
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68869: LD_ADDR_VAR 0 5
68873: PUSH
68874: LD_VAR 0 5
68878: PUSH
68879: LD_VAR 0 3
68883: PUSH
68884: LD_VAR 0 4
68888: ARRAY
68889: PPUSH
68890: CALL_OW 266
68894: PUSH
68895: LD_VAR 0 3
68899: PUSH
68900: LD_VAR 0 4
68904: ARRAY
68905: PPUSH
68906: CALL_OW 250
68910: PUSH
68911: LD_VAR 0 3
68915: PUSH
68916: LD_VAR 0 4
68920: ARRAY
68921: PPUSH
68922: CALL_OW 251
68926: PUSH
68927: LD_VAR 0 3
68931: PUSH
68932: LD_VAR 0 4
68936: ARRAY
68937: PPUSH
68938: CALL_OW 254
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: PUSH
68949: EMPTY
68950: LIST
68951: ADD
68952: ST_TO_ADDR
68953: GO 68866
68955: POP
68956: POP
// result := list ;
68957: LD_ADDR_VAR 0 2
68961: PUSH
68962: LD_VAR 0 5
68966: ST_TO_ADDR
// end ;
68967: LD_VAR 0 2
68971: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68972: LD_INT 0
68974: PPUSH
68975: PPUSH
68976: PPUSH
68977: PPUSH
68978: PPUSH
68979: PPUSH
68980: PPUSH
// if not factory then
68981: LD_VAR 0 1
68985: NOT
68986: IFFALSE 68990
// exit ;
68988: GO 69583
// if control = control_apeman then
68990: LD_VAR 0 4
68994: PUSH
68995: LD_INT 5
68997: EQUAL
68998: IFFALSE 69107
// begin tmp := UnitsInside ( factory ) ;
69000: LD_ADDR_VAR 0 8
69004: PUSH
69005: LD_VAR 0 1
69009: PPUSH
69010: CALL_OW 313
69014: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69015: LD_VAR 0 8
69019: PPUSH
69020: LD_INT 25
69022: PUSH
69023: LD_INT 12
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: PPUSH
69030: CALL_OW 72
69034: NOT
69035: IFFALSE 69045
// control := control_manual ;
69037: LD_ADDR_VAR 0 4
69041: PUSH
69042: LD_INT 1
69044: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69045: LD_ADDR_VAR 0 8
69049: PUSH
69050: LD_VAR 0 1
69054: PPUSH
69055: CALL 68742 0 1
69059: ST_TO_ADDR
// if tmp then
69060: LD_VAR 0 8
69064: IFFALSE 69107
// begin for i in tmp do
69066: LD_ADDR_VAR 0 7
69070: PUSH
69071: LD_VAR 0 8
69075: PUSH
69076: FOR_IN
69077: IFFALSE 69105
// if i [ 1 ] = b_ext_radio then
69079: LD_VAR 0 7
69083: PUSH
69084: LD_INT 1
69086: ARRAY
69087: PUSH
69088: LD_INT 22
69090: EQUAL
69091: IFFALSE 69103
// begin control := control_remote ;
69093: LD_ADDR_VAR 0 4
69097: PUSH
69098: LD_INT 2
69100: ST_TO_ADDR
// break ;
69101: GO 69105
// end ;
69103: GO 69076
69105: POP
69106: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69107: LD_VAR 0 1
69111: PPUSH
69112: LD_VAR 0 2
69116: PPUSH
69117: LD_VAR 0 3
69121: PPUSH
69122: LD_VAR 0 4
69126: PPUSH
69127: LD_VAR 0 5
69131: PPUSH
69132: CALL_OW 448
69136: IFFALSE 69171
// begin result := [ chassis , engine , control , weapon ] ;
69138: LD_ADDR_VAR 0 6
69142: PUSH
69143: LD_VAR 0 2
69147: PUSH
69148: LD_VAR 0 3
69152: PUSH
69153: LD_VAR 0 4
69157: PUSH
69158: LD_VAR 0 5
69162: PUSH
69163: EMPTY
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: ST_TO_ADDR
// exit ;
69169: GO 69583
// end ; _chassis := AvailableChassisList ( factory ) ;
69171: LD_ADDR_VAR 0 9
69175: PUSH
69176: LD_VAR 0 1
69180: PPUSH
69181: CALL_OW 475
69185: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69186: LD_ADDR_VAR 0 11
69190: PUSH
69191: LD_VAR 0 1
69195: PPUSH
69196: CALL_OW 476
69200: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69201: LD_ADDR_VAR 0 12
69205: PUSH
69206: LD_VAR 0 1
69210: PPUSH
69211: CALL_OW 477
69215: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69216: LD_ADDR_VAR 0 10
69220: PUSH
69221: LD_VAR 0 1
69225: PPUSH
69226: CALL_OW 478
69230: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69231: LD_VAR 0 9
69235: NOT
69236: PUSH
69237: LD_VAR 0 11
69241: NOT
69242: OR
69243: PUSH
69244: LD_VAR 0 12
69248: NOT
69249: OR
69250: PUSH
69251: LD_VAR 0 10
69255: NOT
69256: OR
69257: IFFALSE 69292
// begin result := [ chassis , engine , control , weapon ] ;
69259: LD_ADDR_VAR 0 6
69263: PUSH
69264: LD_VAR 0 2
69268: PUSH
69269: LD_VAR 0 3
69273: PUSH
69274: LD_VAR 0 4
69278: PUSH
69279: LD_VAR 0 5
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: LIST
69288: LIST
69289: ST_TO_ADDR
// exit ;
69290: GO 69583
// end ; if not chassis in _chassis then
69292: LD_VAR 0 2
69296: PUSH
69297: LD_VAR 0 9
69301: IN
69302: NOT
69303: IFFALSE 69329
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69305: LD_ADDR_VAR 0 2
69309: PUSH
69310: LD_VAR 0 9
69314: PUSH
69315: LD_INT 1
69317: PPUSH
69318: LD_VAR 0 9
69322: PPUSH
69323: CALL_OW 12
69327: ARRAY
69328: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69329: LD_VAR 0 2
69333: PPUSH
69334: LD_VAR 0 3
69338: PPUSH
69339: CALL 69588 0 2
69343: NOT
69344: IFFALSE 69403
// repeat engine := _engine [ 1 ] ;
69346: LD_ADDR_VAR 0 3
69350: PUSH
69351: LD_VAR 0 11
69355: PUSH
69356: LD_INT 1
69358: ARRAY
69359: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69360: LD_ADDR_VAR 0 11
69364: PUSH
69365: LD_VAR 0 11
69369: PPUSH
69370: LD_INT 1
69372: PPUSH
69373: CALL_OW 3
69377: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69378: LD_VAR 0 2
69382: PPUSH
69383: LD_VAR 0 3
69387: PPUSH
69388: CALL 69588 0 2
69392: PUSH
69393: LD_VAR 0 11
69397: PUSH
69398: EMPTY
69399: EQUAL
69400: OR
69401: IFFALSE 69346
// if not control in _control then
69403: LD_VAR 0 4
69407: PUSH
69408: LD_VAR 0 12
69412: IN
69413: NOT
69414: IFFALSE 69440
// control := _control [ rand ( 1 , _control ) ] ;
69416: LD_ADDR_VAR 0 4
69420: PUSH
69421: LD_VAR 0 12
69425: PUSH
69426: LD_INT 1
69428: PPUSH
69429: LD_VAR 0 12
69433: PPUSH
69434: CALL_OW 12
69438: ARRAY
69439: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69440: LD_VAR 0 2
69444: PPUSH
69445: LD_VAR 0 5
69449: PPUSH
69450: CALL 69808 0 2
69454: NOT
69455: IFFALSE 69514
// repeat weapon := _weapon [ 1 ] ;
69457: LD_ADDR_VAR 0 5
69461: PUSH
69462: LD_VAR 0 10
69466: PUSH
69467: LD_INT 1
69469: ARRAY
69470: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69471: LD_ADDR_VAR 0 10
69475: PUSH
69476: LD_VAR 0 10
69480: PPUSH
69481: LD_INT 1
69483: PPUSH
69484: CALL_OW 3
69488: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69489: LD_VAR 0 2
69493: PPUSH
69494: LD_VAR 0 5
69498: PPUSH
69499: CALL 69808 0 2
69503: PUSH
69504: LD_VAR 0 10
69508: PUSH
69509: EMPTY
69510: EQUAL
69511: OR
69512: IFFALSE 69457
// result := [ ] ;
69514: LD_ADDR_VAR 0 6
69518: PUSH
69519: EMPTY
69520: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69521: LD_VAR 0 1
69525: PPUSH
69526: LD_VAR 0 2
69530: PPUSH
69531: LD_VAR 0 3
69535: PPUSH
69536: LD_VAR 0 4
69540: PPUSH
69541: LD_VAR 0 5
69545: PPUSH
69546: CALL_OW 448
69550: IFFALSE 69583
// result := [ chassis , engine , control , weapon ] ;
69552: LD_ADDR_VAR 0 6
69556: PUSH
69557: LD_VAR 0 2
69561: PUSH
69562: LD_VAR 0 3
69566: PUSH
69567: LD_VAR 0 4
69571: PUSH
69572: LD_VAR 0 5
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: ST_TO_ADDR
// end ;
69583: LD_VAR 0 6
69587: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69588: LD_INT 0
69590: PPUSH
// if not chassis or not engine then
69591: LD_VAR 0 1
69595: NOT
69596: PUSH
69597: LD_VAR 0 2
69601: NOT
69602: OR
69603: IFFALSE 69607
// exit ;
69605: GO 69803
// case engine of engine_solar :
69607: LD_VAR 0 2
69611: PUSH
69612: LD_INT 2
69614: DOUBLE
69615: EQUAL
69616: IFTRUE 69620
69618: GO 69658
69620: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69621: LD_ADDR_VAR 0 3
69625: PUSH
69626: LD_INT 11
69628: PUSH
69629: LD_INT 12
69631: PUSH
69632: LD_INT 13
69634: PUSH
69635: LD_INT 14
69637: PUSH
69638: LD_INT 1
69640: PUSH
69641: LD_INT 2
69643: PUSH
69644: LD_INT 3
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: LIST
69655: ST_TO_ADDR
69656: GO 69787
69658: LD_INT 1
69660: DOUBLE
69661: EQUAL
69662: IFTRUE 69666
69664: GO 69728
69666: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69667: LD_ADDR_VAR 0 3
69671: PUSH
69672: LD_INT 11
69674: PUSH
69675: LD_INT 12
69677: PUSH
69678: LD_INT 13
69680: PUSH
69681: LD_INT 14
69683: PUSH
69684: LD_INT 1
69686: PUSH
69687: LD_INT 2
69689: PUSH
69690: LD_INT 3
69692: PUSH
69693: LD_INT 4
69695: PUSH
69696: LD_INT 5
69698: PUSH
69699: LD_INT 21
69701: PUSH
69702: LD_INT 23
69704: PUSH
69705: LD_INT 22
69707: PUSH
69708: LD_INT 24
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: ST_TO_ADDR
69726: GO 69787
69728: LD_INT 3
69730: DOUBLE
69731: EQUAL
69732: IFTRUE 69736
69734: GO 69786
69736: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69737: LD_ADDR_VAR 0 3
69741: PUSH
69742: LD_INT 13
69744: PUSH
69745: LD_INT 14
69747: PUSH
69748: LD_INT 2
69750: PUSH
69751: LD_INT 3
69753: PUSH
69754: LD_INT 4
69756: PUSH
69757: LD_INT 5
69759: PUSH
69760: LD_INT 21
69762: PUSH
69763: LD_INT 22
69765: PUSH
69766: LD_INT 23
69768: PUSH
69769: LD_INT 24
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: LIST
69776: LIST
69777: LIST
69778: LIST
69779: LIST
69780: LIST
69781: LIST
69782: LIST
69783: ST_TO_ADDR
69784: GO 69787
69786: POP
// result := ( chassis in result ) ;
69787: LD_ADDR_VAR 0 3
69791: PUSH
69792: LD_VAR 0 1
69796: PUSH
69797: LD_VAR 0 3
69801: IN
69802: ST_TO_ADDR
// end ;
69803: LD_VAR 0 3
69807: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69808: LD_INT 0
69810: PPUSH
// if not chassis or not weapon then
69811: LD_VAR 0 1
69815: NOT
69816: PUSH
69817: LD_VAR 0 2
69821: NOT
69822: OR
69823: IFFALSE 69827
// exit ;
69825: GO 70853
// case weapon of us_machine_gun :
69827: LD_VAR 0 2
69831: PUSH
69832: LD_INT 2
69834: DOUBLE
69835: EQUAL
69836: IFTRUE 69840
69838: GO 69870
69840: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69841: LD_ADDR_VAR 0 3
69845: PUSH
69846: LD_INT 1
69848: PUSH
69849: LD_INT 2
69851: PUSH
69852: LD_INT 3
69854: PUSH
69855: LD_INT 4
69857: PUSH
69858: LD_INT 5
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: ST_TO_ADDR
69868: GO 70837
69870: LD_INT 3
69872: DOUBLE
69873: EQUAL
69874: IFTRUE 69878
69876: GO 69908
69878: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69879: LD_ADDR_VAR 0 3
69883: PUSH
69884: LD_INT 1
69886: PUSH
69887: LD_INT 2
69889: PUSH
69890: LD_INT 3
69892: PUSH
69893: LD_INT 4
69895: PUSH
69896: LD_INT 5
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: LIST
69903: LIST
69904: LIST
69905: ST_TO_ADDR
69906: GO 70837
69908: LD_INT 11
69910: DOUBLE
69911: EQUAL
69912: IFTRUE 69916
69914: GO 69946
69916: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69917: LD_ADDR_VAR 0 3
69921: PUSH
69922: LD_INT 1
69924: PUSH
69925: LD_INT 2
69927: PUSH
69928: LD_INT 3
69930: PUSH
69931: LD_INT 4
69933: PUSH
69934: LD_INT 5
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: ST_TO_ADDR
69944: GO 70837
69946: LD_INT 4
69948: DOUBLE
69949: EQUAL
69950: IFTRUE 69954
69952: GO 69980
69954: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69955: LD_ADDR_VAR 0 3
69959: PUSH
69960: LD_INT 2
69962: PUSH
69963: LD_INT 3
69965: PUSH
69966: LD_INT 4
69968: PUSH
69969: LD_INT 5
69971: PUSH
69972: EMPTY
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: ST_TO_ADDR
69978: GO 70837
69980: LD_INT 5
69982: DOUBLE
69983: EQUAL
69984: IFTRUE 69988
69986: GO 70014
69988: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69989: LD_ADDR_VAR 0 3
69993: PUSH
69994: LD_INT 2
69996: PUSH
69997: LD_INT 3
69999: PUSH
70000: LD_INT 4
70002: PUSH
70003: LD_INT 5
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: ST_TO_ADDR
70012: GO 70837
70014: LD_INT 9
70016: DOUBLE
70017: EQUAL
70018: IFTRUE 70022
70020: GO 70048
70022: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70023: LD_ADDR_VAR 0 3
70027: PUSH
70028: LD_INT 2
70030: PUSH
70031: LD_INT 3
70033: PUSH
70034: LD_INT 4
70036: PUSH
70037: LD_INT 5
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: ST_TO_ADDR
70046: GO 70837
70048: LD_INT 7
70050: DOUBLE
70051: EQUAL
70052: IFTRUE 70056
70054: GO 70082
70056: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70057: LD_ADDR_VAR 0 3
70061: PUSH
70062: LD_INT 2
70064: PUSH
70065: LD_INT 3
70067: PUSH
70068: LD_INT 4
70070: PUSH
70071: LD_INT 5
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: ST_TO_ADDR
70080: GO 70837
70082: LD_INT 12
70084: DOUBLE
70085: EQUAL
70086: IFTRUE 70090
70088: GO 70116
70090: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70091: LD_ADDR_VAR 0 3
70095: PUSH
70096: LD_INT 2
70098: PUSH
70099: LD_INT 3
70101: PUSH
70102: LD_INT 4
70104: PUSH
70105: LD_INT 5
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: LIST
70112: LIST
70113: ST_TO_ADDR
70114: GO 70837
70116: LD_INT 13
70118: DOUBLE
70119: EQUAL
70120: IFTRUE 70124
70122: GO 70150
70124: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70125: LD_ADDR_VAR 0 3
70129: PUSH
70130: LD_INT 2
70132: PUSH
70133: LD_INT 3
70135: PUSH
70136: LD_INT 4
70138: PUSH
70139: LD_INT 5
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: ST_TO_ADDR
70148: GO 70837
70150: LD_INT 14
70152: DOUBLE
70153: EQUAL
70154: IFTRUE 70158
70156: GO 70176
70158: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70159: LD_ADDR_VAR 0 3
70163: PUSH
70164: LD_INT 4
70166: PUSH
70167: LD_INT 5
70169: PUSH
70170: EMPTY
70171: LIST
70172: LIST
70173: ST_TO_ADDR
70174: GO 70837
70176: LD_INT 6
70178: DOUBLE
70179: EQUAL
70180: IFTRUE 70184
70182: GO 70202
70184: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70185: LD_ADDR_VAR 0 3
70189: PUSH
70190: LD_INT 4
70192: PUSH
70193: LD_INT 5
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: ST_TO_ADDR
70200: GO 70837
70202: LD_INT 10
70204: DOUBLE
70205: EQUAL
70206: IFTRUE 70210
70208: GO 70228
70210: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70211: LD_ADDR_VAR 0 3
70215: PUSH
70216: LD_INT 4
70218: PUSH
70219: LD_INT 5
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: ST_TO_ADDR
70226: GO 70837
70228: LD_INT 22
70230: DOUBLE
70231: EQUAL
70232: IFTRUE 70236
70234: GO 70262
70236: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70237: LD_ADDR_VAR 0 3
70241: PUSH
70242: LD_INT 11
70244: PUSH
70245: LD_INT 12
70247: PUSH
70248: LD_INT 13
70250: PUSH
70251: LD_INT 14
70253: PUSH
70254: EMPTY
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: ST_TO_ADDR
70260: GO 70837
70262: LD_INT 23
70264: DOUBLE
70265: EQUAL
70266: IFTRUE 70270
70268: GO 70296
70270: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70271: LD_ADDR_VAR 0 3
70275: PUSH
70276: LD_INT 11
70278: PUSH
70279: LD_INT 12
70281: PUSH
70282: LD_INT 13
70284: PUSH
70285: LD_INT 14
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: ST_TO_ADDR
70294: GO 70837
70296: LD_INT 24
70298: DOUBLE
70299: EQUAL
70300: IFTRUE 70304
70302: GO 70330
70304: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70305: LD_ADDR_VAR 0 3
70309: PUSH
70310: LD_INT 11
70312: PUSH
70313: LD_INT 12
70315: PUSH
70316: LD_INT 13
70318: PUSH
70319: LD_INT 14
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: ST_TO_ADDR
70328: GO 70837
70330: LD_INT 30
70332: DOUBLE
70333: EQUAL
70334: IFTRUE 70338
70336: GO 70364
70338: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70339: LD_ADDR_VAR 0 3
70343: PUSH
70344: LD_INT 11
70346: PUSH
70347: LD_INT 12
70349: PUSH
70350: LD_INT 13
70352: PUSH
70353: LD_INT 14
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: LIST
70360: LIST
70361: ST_TO_ADDR
70362: GO 70837
70364: LD_INT 25
70366: DOUBLE
70367: EQUAL
70368: IFTRUE 70372
70370: GO 70390
70372: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70373: LD_ADDR_VAR 0 3
70377: PUSH
70378: LD_INT 13
70380: PUSH
70381: LD_INT 14
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: ST_TO_ADDR
70388: GO 70837
70390: LD_INT 27
70392: DOUBLE
70393: EQUAL
70394: IFTRUE 70398
70396: GO 70416
70398: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70399: LD_ADDR_VAR 0 3
70403: PUSH
70404: LD_INT 13
70406: PUSH
70407: LD_INT 14
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: ST_TO_ADDR
70414: GO 70837
70416: LD_INT 28
70418: DOUBLE
70419: EQUAL
70420: IFTRUE 70424
70422: GO 70442
70424: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70425: LD_ADDR_VAR 0 3
70429: PUSH
70430: LD_INT 13
70432: PUSH
70433: LD_INT 14
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: ST_TO_ADDR
70440: GO 70837
70442: LD_INT 29
70444: DOUBLE
70445: EQUAL
70446: IFTRUE 70450
70448: GO 70468
70450: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70451: LD_ADDR_VAR 0 3
70455: PUSH
70456: LD_INT 13
70458: PUSH
70459: LD_INT 14
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: ST_TO_ADDR
70466: GO 70837
70468: LD_INT 31
70470: DOUBLE
70471: EQUAL
70472: IFTRUE 70476
70474: GO 70494
70476: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70477: LD_ADDR_VAR 0 3
70481: PUSH
70482: LD_INT 13
70484: PUSH
70485: LD_INT 14
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: ST_TO_ADDR
70492: GO 70837
70494: LD_INT 26
70496: DOUBLE
70497: EQUAL
70498: IFTRUE 70502
70500: GO 70520
70502: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70503: LD_ADDR_VAR 0 3
70507: PUSH
70508: LD_INT 13
70510: PUSH
70511: LD_INT 14
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: ST_TO_ADDR
70518: GO 70837
70520: LD_INT 42
70522: DOUBLE
70523: EQUAL
70524: IFTRUE 70528
70526: GO 70554
70528: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70529: LD_ADDR_VAR 0 3
70533: PUSH
70534: LD_INT 21
70536: PUSH
70537: LD_INT 22
70539: PUSH
70540: LD_INT 23
70542: PUSH
70543: LD_INT 24
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: ST_TO_ADDR
70552: GO 70837
70554: LD_INT 43
70556: DOUBLE
70557: EQUAL
70558: IFTRUE 70562
70560: GO 70588
70562: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70563: LD_ADDR_VAR 0 3
70567: PUSH
70568: LD_INT 21
70570: PUSH
70571: LD_INT 22
70573: PUSH
70574: LD_INT 23
70576: PUSH
70577: LD_INT 24
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: ST_TO_ADDR
70586: GO 70837
70588: LD_INT 44
70590: DOUBLE
70591: EQUAL
70592: IFTRUE 70596
70594: GO 70622
70596: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70597: LD_ADDR_VAR 0 3
70601: PUSH
70602: LD_INT 21
70604: PUSH
70605: LD_INT 22
70607: PUSH
70608: LD_INT 23
70610: PUSH
70611: LD_INT 24
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: ST_TO_ADDR
70620: GO 70837
70622: LD_INT 45
70624: DOUBLE
70625: EQUAL
70626: IFTRUE 70630
70628: GO 70656
70630: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70631: LD_ADDR_VAR 0 3
70635: PUSH
70636: LD_INT 21
70638: PUSH
70639: LD_INT 22
70641: PUSH
70642: LD_INT 23
70644: PUSH
70645: LD_INT 24
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: ST_TO_ADDR
70654: GO 70837
70656: LD_INT 49
70658: DOUBLE
70659: EQUAL
70660: IFTRUE 70664
70662: GO 70690
70664: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70665: LD_ADDR_VAR 0 3
70669: PUSH
70670: LD_INT 21
70672: PUSH
70673: LD_INT 22
70675: PUSH
70676: LD_INT 23
70678: PUSH
70679: LD_INT 24
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: ST_TO_ADDR
70688: GO 70837
70690: LD_INT 51
70692: DOUBLE
70693: EQUAL
70694: IFTRUE 70698
70696: GO 70724
70698: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70699: LD_ADDR_VAR 0 3
70703: PUSH
70704: LD_INT 21
70706: PUSH
70707: LD_INT 22
70709: PUSH
70710: LD_INT 23
70712: PUSH
70713: LD_INT 24
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: ST_TO_ADDR
70722: GO 70837
70724: LD_INT 52
70726: DOUBLE
70727: EQUAL
70728: IFTRUE 70732
70730: GO 70758
70732: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70733: LD_ADDR_VAR 0 3
70737: PUSH
70738: LD_INT 21
70740: PUSH
70741: LD_INT 22
70743: PUSH
70744: LD_INT 23
70746: PUSH
70747: LD_INT 24
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: ST_TO_ADDR
70756: GO 70837
70758: LD_INT 53
70760: DOUBLE
70761: EQUAL
70762: IFTRUE 70766
70764: GO 70784
70766: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70767: LD_ADDR_VAR 0 3
70771: PUSH
70772: LD_INT 23
70774: PUSH
70775: LD_INT 24
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: ST_TO_ADDR
70782: GO 70837
70784: LD_INT 46
70786: DOUBLE
70787: EQUAL
70788: IFTRUE 70792
70790: GO 70810
70792: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70793: LD_ADDR_VAR 0 3
70797: PUSH
70798: LD_INT 23
70800: PUSH
70801: LD_INT 24
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: ST_TO_ADDR
70808: GO 70837
70810: LD_INT 47
70812: DOUBLE
70813: EQUAL
70814: IFTRUE 70818
70816: GO 70836
70818: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70819: LD_ADDR_VAR 0 3
70823: PUSH
70824: LD_INT 23
70826: PUSH
70827: LD_INT 24
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: ST_TO_ADDR
70834: GO 70837
70836: POP
// result := ( chassis in result ) ;
70837: LD_ADDR_VAR 0 3
70841: PUSH
70842: LD_VAR 0 1
70846: PUSH
70847: LD_VAR 0 3
70851: IN
70852: ST_TO_ADDR
// end ;
70853: LD_VAR 0 3
70857: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70858: LD_INT 0
70860: PPUSH
70861: PPUSH
70862: PPUSH
70863: PPUSH
70864: PPUSH
70865: PPUSH
70866: PPUSH
// result := array ;
70867: LD_ADDR_VAR 0 5
70871: PUSH
70872: LD_VAR 0 1
70876: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70877: LD_VAR 0 1
70881: NOT
70882: PUSH
70883: LD_VAR 0 2
70887: NOT
70888: OR
70889: PUSH
70890: LD_VAR 0 3
70894: NOT
70895: OR
70896: PUSH
70897: LD_VAR 0 2
70901: PUSH
70902: LD_VAR 0 1
70906: GREATER
70907: OR
70908: PUSH
70909: LD_VAR 0 3
70913: PUSH
70914: LD_VAR 0 1
70918: GREATER
70919: OR
70920: IFFALSE 70924
// exit ;
70922: GO 71220
// if direction then
70924: LD_VAR 0 4
70928: IFFALSE 70992
// begin d := 1 ;
70930: LD_ADDR_VAR 0 9
70934: PUSH
70935: LD_INT 1
70937: ST_TO_ADDR
// if i_from > i_to then
70938: LD_VAR 0 2
70942: PUSH
70943: LD_VAR 0 3
70947: GREATER
70948: IFFALSE 70974
// length := ( array - i_from ) + i_to else
70950: LD_ADDR_VAR 0 11
70954: PUSH
70955: LD_VAR 0 1
70959: PUSH
70960: LD_VAR 0 2
70964: MINUS
70965: PUSH
70966: LD_VAR 0 3
70970: PLUS
70971: ST_TO_ADDR
70972: GO 70990
// length := i_to - i_from ;
70974: LD_ADDR_VAR 0 11
70978: PUSH
70979: LD_VAR 0 3
70983: PUSH
70984: LD_VAR 0 2
70988: MINUS
70989: ST_TO_ADDR
// end else
70990: GO 71053
// begin d := - 1 ;
70992: LD_ADDR_VAR 0 9
70996: PUSH
70997: LD_INT 1
70999: NEG
71000: ST_TO_ADDR
// if i_from > i_to then
71001: LD_VAR 0 2
71005: PUSH
71006: LD_VAR 0 3
71010: GREATER
71011: IFFALSE 71031
// length := i_from - i_to else
71013: LD_ADDR_VAR 0 11
71017: PUSH
71018: LD_VAR 0 2
71022: PUSH
71023: LD_VAR 0 3
71027: MINUS
71028: ST_TO_ADDR
71029: GO 71053
// length := ( array - i_to ) + i_from ;
71031: LD_ADDR_VAR 0 11
71035: PUSH
71036: LD_VAR 0 1
71040: PUSH
71041: LD_VAR 0 3
71045: MINUS
71046: PUSH
71047: LD_VAR 0 2
71051: PLUS
71052: ST_TO_ADDR
// end ; if not length then
71053: LD_VAR 0 11
71057: NOT
71058: IFFALSE 71062
// exit ;
71060: GO 71220
// tmp := array ;
71062: LD_ADDR_VAR 0 10
71066: PUSH
71067: LD_VAR 0 1
71071: ST_TO_ADDR
// for i = 1 to length do
71072: LD_ADDR_VAR 0 6
71076: PUSH
71077: DOUBLE
71078: LD_INT 1
71080: DEC
71081: ST_TO_ADDR
71082: LD_VAR 0 11
71086: PUSH
71087: FOR_TO
71088: IFFALSE 71208
// begin for j = 1 to array do
71090: LD_ADDR_VAR 0 7
71094: PUSH
71095: DOUBLE
71096: LD_INT 1
71098: DEC
71099: ST_TO_ADDR
71100: LD_VAR 0 1
71104: PUSH
71105: FOR_TO
71106: IFFALSE 71194
// begin k := j + d ;
71108: LD_ADDR_VAR 0 8
71112: PUSH
71113: LD_VAR 0 7
71117: PUSH
71118: LD_VAR 0 9
71122: PLUS
71123: ST_TO_ADDR
// if k > array then
71124: LD_VAR 0 8
71128: PUSH
71129: LD_VAR 0 1
71133: GREATER
71134: IFFALSE 71144
// k := 1 ;
71136: LD_ADDR_VAR 0 8
71140: PUSH
71141: LD_INT 1
71143: ST_TO_ADDR
// if not k then
71144: LD_VAR 0 8
71148: NOT
71149: IFFALSE 71161
// k := array ;
71151: LD_ADDR_VAR 0 8
71155: PUSH
71156: LD_VAR 0 1
71160: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71161: LD_ADDR_VAR 0 10
71165: PUSH
71166: LD_VAR 0 10
71170: PPUSH
71171: LD_VAR 0 8
71175: PPUSH
71176: LD_VAR 0 1
71180: PUSH
71181: LD_VAR 0 7
71185: ARRAY
71186: PPUSH
71187: CALL_OW 1
71191: ST_TO_ADDR
// end ;
71192: GO 71105
71194: POP
71195: POP
// array := tmp ;
71196: LD_ADDR_VAR 0 1
71200: PUSH
71201: LD_VAR 0 10
71205: ST_TO_ADDR
// end ;
71206: GO 71087
71208: POP
71209: POP
// result := array ;
71210: LD_ADDR_VAR 0 5
71214: PUSH
71215: LD_VAR 0 1
71219: ST_TO_ADDR
// end ;
71220: LD_VAR 0 5
71224: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71225: LD_INT 0
71227: PPUSH
71228: PPUSH
// result := 0 ;
71229: LD_ADDR_VAR 0 3
71233: PUSH
71234: LD_INT 0
71236: ST_TO_ADDR
// if not array or not value in array then
71237: LD_VAR 0 1
71241: NOT
71242: PUSH
71243: LD_VAR 0 2
71247: PUSH
71248: LD_VAR 0 1
71252: IN
71253: NOT
71254: OR
71255: IFFALSE 71259
// exit ;
71257: GO 71313
// for i = 1 to array do
71259: LD_ADDR_VAR 0 4
71263: PUSH
71264: DOUBLE
71265: LD_INT 1
71267: DEC
71268: ST_TO_ADDR
71269: LD_VAR 0 1
71273: PUSH
71274: FOR_TO
71275: IFFALSE 71311
// if value = array [ i ] then
71277: LD_VAR 0 2
71281: PUSH
71282: LD_VAR 0 1
71286: PUSH
71287: LD_VAR 0 4
71291: ARRAY
71292: EQUAL
71293: IFFALSE 71309
// begin result := i ;
71295: LD_ADDR_VAR 0 3
71299: PUSH
71300: LD_VAR 0 4
71304: ST_TO_ADDR
// exit ;
71305: POP
71306: POP
71307: GO 71313
// end ;
71309: GO 71274
71311: POP
71312: POP
// end ;
71313: LD_VAR 0 3
71317: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71318: LD_INT 0
71320: PPUSH
// vc_chassis := chassis ;
71321: LD_ADDR_OWVAR 37
71325: PUSH
71326: LD_VAR 0 1
71330: ST_TO_ADDR
// vc_engine := engine ;
71331: LD_ADDR_OWVAR 39
71335: PUSH
71336: LD_VAR 0 2
71340: ST_TO_ADDR
// vc_control := control ;
71341: LD_ADDR_OWVAR 38
71345: PUSH
71346: LD_VAR 0 3
71350: ST_TO_ADDR
// vc_weapon := weapon ;
71351: LD_ADDR_OWVAR 40
71355: PUSH
71356: LD_VAR 0 4
71360: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71361: LD_ADDR_OWVAR 41
71365: PUSH
71366: LD_VAR 0 5
71370: ST_TO_ADDR
// end ;
71371: LD_VAR 0 6
71375: RET
// export function WantPlant ( unit ) ; var task ; begin
71376: LD_INT 0
71378: PPUSH
71379: PPUSH
// result := false ;
71380: LD_ADDR_VAR 0 2
71384: PUSH
71385: LD_INT 0
71387: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71388: LD_ADDR_VAR 0 3
71392: PUSH
71393: LD_VAR 0 1
71397: PPUSH
71398: CALL_OW 437
71402: ST_TO_ADDR
// if task then
71403: LD_VAR 0 3
71407: IFFALSE 71435
// if task [ 1 ] [ 1 ] = p then
71409: LD_VAR 0 3
71413: PUSH
71414: LD_INT 1
71416: ARRAY
71417: PUSH
71418: LD_INT 1
71420: ARRAY
71421: PUSH
71422: LD_STRING p
71424: EQUAL
71425: IFFALSE 71435
// result := true ;
71427: LD_ADDR_VAR 0 2
71431: PUSH
71432: LD_INT 1
71434: ST_TO_ADDR
// end ;
71435: LD_VAR 0 2
71439: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71440: LD_INT 0
71442: PPUSH
71443: PPUSH
71444: PPUSH
71445: PPUSH
// if pos < 1 then
71446: LD_VAR 0 2
71450: PUSH
71451: LD_INT 1
71453: LESS
71454: IFFALSE 71458
// exit ;
71456: GO 71761
// if pos = 1 then
71458: LD_VAR 0 2
71462: PUSH
71463: LD_INT 1
71465: EQUAL
71466: IFFALSE 71499
// result := Replace ( arr , pos [ 1 ] , value ) else
71468: LD_ADDR_VAR 0 4
71472: PUSH
71473: LD_VAR 0 1
71477: PPUSH
71478: LD_VAR 0 2
71482: PUSH
71483: LD_INT 1
71485: ARRAY
71486: PPUSH
71487: LD_VAR 0 3
71491: PPUSH
71492: CALL_OW 1
71496: ST_TO_ADDR
71497: GO 71761
// begin tmp := arr ;
71499: LD_ADDR_VAR 0 6
71503: PUSH
71504: LD_VAR 0 1
71508: ST_TO_ADDR
// s_arr := [ tmp ] ;
71509: LD_ADDR_VAR 0 7
71513: PUSH
71514: LD_VAR 0 6
71518: PUSH
71519: EMPTY
71520: LIST
71521: ST_TO_ADDR
// for i = 1 to pos - 1 do
71522: LD_ADDR_VAR 0 5
71526: PUSH
71527: DOUBLE
71528: LD_INT 1
71530: DEC
71531: ST_TO_ADDR
71532: LD_VAR 0 2
71536: PUSH
71537: LD_INT 1
71539: MINUS
71540: PUSH
71541: FOR_TO
71542: IFFALSE 71587
// begin tmp := tmp [ pos [ i ] ] ;
71544: LD_ADDR_VAR 0 6
71548: PUSH
71549: LD_VAR 0 6
71553: PUSH
71554: LD_VAR 0 2
71558: PUSH
71559: LD_VAR 0 5
71563: ARRAY
71564: ARRAY
71565: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71566: LD_ADDR_VAR 0 7
71570: PUSH
71571: LD_VAR 0 7
71575: PUSH
71576: LD_VAR 0 6
71580: PUSH
71581: EMPTY
71582: LIST
71583: ADD
71584: ST_TO_ADDR
// end ;
71585: GO 71541
71587: POP
71588: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71589: LD_ADDR_VAR 0 6
71593: PUSH
71594: LD_VAR 0 6
71598: PPUSH
71599: LD_VAR 0 2
71603: PUSH
71604: LD_VAR 0 2
71608: ARRAY
71609: PPUSH
71610: LD_VAR 0 3
71614: PPUSH
71615: CALL_OW 1
71619: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71620: LD_ADDR_VAR 0 7
71624: PUSH
71625: LD_VAR 0 7
71629: PPUSH
71630: LD_VAR 0 7
71634: PPUSH
71635: LD_VAR 0 6
71639: PPUSH
71640: CALL_OW 1
71644: ST_TO_ADDR
// for i = s_arr downto 2 do
71645: LD_ADDR_VAR 0 5
71649: PUSH
71650: DOUBLE
71651: LD_VAR 0 7
71655: INC
71656: ST_TO_ADDR
71657: LD_INT 2
71659: PUSH
71660: FOR_DOWNTO
71661: IFFALSE 71745
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71663: LD_ADDR_VAR 0 6
71667: PUSH
71668: LD_VAR 0 7
71672: PUSH
71673: LD_VAR 0 5
71677: PUSH
71678: LD_INT 1
71680: MINUS
71681: ARRAY
71682: PPUSH
71683: LD_VAR 0 2
71687: PUSH
71688: LD_VAR 0 5
71692: PUSH
71693: LD_INT 1
71695: MINUS
71696: ARRAY
71697: PPUSH
71698: LD_VAR 0 7
71702: PUSH
71703: LD_VAR 0 5
71707: ARRAY
71708: PPUSH
71709: CALL_OW 1
71713: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71714: LD_ADDR_VAR 0 7
71718: PUSH
71719: LD_VAR 0 7
71723: PPUSH
71724: LD_VAR 0 5
71728: PUSH
71729: LD_INT 1
71731: MINUS
71732: PPUSH
71733: LD_VAR 0 6
71737: PPUSH
71738: CALL_OW 1
71742: ST_TO_ADDR
// end ;
71743: GO 71660
71745: POP
71746: POP
// result := s_arr [ 1 ] ;
71747: LD_ADDR_VAR 0 4
71751: PUSH
71752: LD_VAR 0 7
71756: PUSH
71757: LD_INT 1
71759: ARRAY
71760: ST_TO_ADDR
// end ; end ;
71761: LD_VAR 0 4
71765: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71766: LD_INT 0
71768: PPUSH
71769: PPUSH
// if not list then
71770: LD_VAR 0 1
71774: NOT
71775: IFFALSE 71779
// exit ;
71777: GO 71870
// i := list [ pos1 ] ;
71779: LD_ADDR_VAR 0 5
71783: PUSH
71784: LD_VAR 0 1
71788: PUSH
71789: LD_VAR 0 2
71793: ARRAY
71794: ST_TO_ADDR
// if not i then
71795: LD_VAR 0 5
71799: NOT
71800: IFFALSE 71804
// exit ;
71802: GO 71870
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71804: LD_ADDR_VAR 0 1
71808: PUSH
71809: LD_VAR 0 1
71813: PPUSH
71814: LD_VAR 0 2
71818: PPUSH
71819: LD_VAR 0 1
71823: PUSH
71824: LD_VAR 0 3
71828: ARRAY
71829: PPUSH
71830: CALL_OW 1
71834: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71835: LD_ADDR_VAR 0 1
71839: PUSH
71840: LD_VAR 0 1
71844: PPUSH
71845: LD_VAR 0 3
71849: PPUSH
71850: LD_VAR 0 5
71854: PPUSH
71855: CALL_OW 1
71859: ST_TO_ADDR
// result := list ;
71860: LD_ADDR_VAR 0 4
71864: PUSH
71865: LD_VAR 0 1
71869: ST_TO_ADDR
// end ;
71870: LD_VAR 0 4
71874: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71875: LD_INT 0
71877: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71878: LD_ADDR_VAR 0 5
71882: PUSH
71883: LD_VAR 0 1
71887: PPUSH
71888: CALL_OW 250
71892: PPUSH
71893: LD_VAR 0 1
71897: PPUSH
71898: CALL_OW 251
71902: PPUSH
71903: LD_VAR 0 2
71907: PPUSH
71908: LD_VAR 0 3
71912: PPUSH
71913: LD_VAR 0 4
71917: PPUSH
71918: CALL 71928 0 5
71922: ST_TO_ADDR
// end ;
71923: LD_VAR 0 5
71927: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71928: LD_INT 0
71930: PPUSH
71931: PPUSH
71932: PPUSH
71933: PPUSH
// if not list then
71934: LD_VAR 0 3
71938: NOT
71939: IFFALSE 71943
// exit ;
71941: GO 72331
// result := [ ] ;
71943: LD_ADDR_VAR 0 6
71947: PUSH
71948: EMPTY
71949: ST_TO_ADDR
// for i in list do
71950: LD_ADDR_VAR 0 7
71954: PUSH
71955: LD_VAR 0 3
71959: PUSH
71960: FOR_IN
71961: IFFALSE 72163
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71963: LD_ADDR_VAR 0 9
71967: PUSH
71968: LD_VAR 0 7
71972: PPUSH
71973: LD_VAR 0 1
71977: PPUSH
71978: LD_VAR 0 2
71982: PPUSH
71983: CALL_OW 297
71987: ST_TO_ADDR
// if not result then
71988: LD_VAR 0 6
71992: NOT
71993: IFFALSE 72019
// result := [ [ i , tmp ] ] else
71995: LD_ADDR_VAR 0 6
71999: PUSH
72000: LD_VAR 0 7
72004: PUSH
72005: LD_VAR 0 9
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: EMPTY
72015: LIST
72016: ST_TO_ADDR
72017: GO 72161
// begin if result [ result ] [ 2 ] < tmp then
72019: LD_VAR 0 6
72023: PUSH
72024: LD_VAR 0 6
72028: ARRAY
72029: PUSH
72030: LD_INT 2
72032: ARRAY
72033: PUSH
72034: LD_VAR 0 9
72038: LESS
72039: IFFALSE 72081
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72041: LD_ADDR_VAR 0 6
72045: PUSH
72046: LD_VAR 0 6
72050: PPUSH
72051: LD_VAR 0 6
72055: PUSH
72056: LD_INT 1
72058: PLUS
72059: PPUSH
72060: LD_VAR 0 7
72064: PUSH
72065: LD_VAR 0 9
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PPUSH
72074: CALL_OW 2
72078: ST_TO_ADDR
72079: GO 72161
// for j = 1 to result do
72081: LD_ADDR_VAR 0 8
72085: PUSH
72086: DOUBLE
72087: LD_INT 1
72089: DEC
72090: ST_TO_ADDR
72091: LD_VAR 0 6
72095: PUSH
72096: FOR_TO
72097: IFFALSE 72159
// begin if tmp < result [ j ] [ 2 ] then
72099: LD_VAR 0 9
72103: PUSH
72104: LD_VAR 0 6
72108: PUSH
72109: LD_VAR 0 8
72113: ARRAY
72114: PUSH
72115: LD_INT 2
72117: ARRAY
72118: LESS
72119: IFFALSE 72157
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72121: LD_ADDR_VAR 0 6
72125: PUSH
72126: LD_VAR 0 6
72130: PPUSH
72131: LD_VAR 0 8
72135: PPUSH
72136: LD_VAR 0 7
72140: PUSH
72141: LD_VAR 0 9
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PPUSH
72150: CALL_OW 2
72154: ST_TO_ADDR
// break ;
72155: GO 72159
// end ; end ;
72157: GO 72096
72159: POP
72160: POP
// end ; end ;
72161: GO 71960
72163: POP
72164: POP
// if result and not asc then
72165: LD_VAR 0 6
72169: PUSH
72170: LD_VAR 0 4
72174: NOT
72175: AND
72176: IFFALSE 72251
// begin tmp := result ;
72178: LD_ADDR_VAR 0 9
72182: PUSH
72183: LD_VAR 0 6
72187: ST_TO_ADDR
// for i = tmp downto 1 do
72188: LD_ADDR_VAR 0 7
72192: PUSH
72193: DOUBLE
72194: LD_VAR 0 9
72198: INC
72199: ST_TO_ADDR
72200: LD_INT 1
72202: PUSH
72203: FOR_DOWNTO
72204: IFFALSE 72249
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72206: LD_ADDR_VAR 0 6
72210: PUSH
72211: LD_VAR 0 6
72215: PPUSH
72216: LD_VAR 0 9
72220: PUSH
72221: LD_VAR 0 7
72225: MINUS
72226: PUSH
72227: LD_INT 1
72229: PLUS
72230: PPUSH
72231: LD_VAR 0 9
72235: PUSH
72236: LD_VAR 0 7
72240: ARRAY
72241: PPUSH
72242: CALL_OW 1
72246: ST_TO_ADDR
72247: GO 72203
72249: POP
72250: POP
// end ; tmp := [ ] ;
72251: LD_ADDR_VAR 0 9
72255: PUSH
72256: EMPTY
72257: ST_TO_ADDR
// if mode then
72258: LD_VAR 0 5
72262: IFFALSE 72331
// begin for i = 1 to result do
72264: LD_ADDR_VAR 0 7
72268: PUSH
72269: DOUBLE
72270: LD_INT 1
72272: DEC
72273: ST_TO_ADDR
72274: LD_VAR 0 6
72278: PUSH
72279: FOR_TO
72280: IFFALSE 72319
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72282: LD_ADDR_VAR 0 9
72286: PUSH
72287: LD_VAR 0 9
72291: PPUSH
72292: LD_VAR 0 7
72296: PPUSH
72297: LD_VAR 0 6
72301: PUSH
72302: LD_VAR 0 7
72306: ARRAY
72307: PUSH
72308: LD_INT 1
72310: ARRAY
72311: PPUSH
72312: CALL_OW 1
72316: ST_TO_ADDR
72317: GO 72279
72319: POP
72320: POP
// result := tmp ;
72321: LD_ADDR_VAR 0 6
72325: PUSH
72326: LD_VAR 0 9
72330: ST_TO_ADDR
// end ; end ;
72331: LD_VAR 0 6
72335: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72336: LD_INT 0
72338: PPUSH
72339: PPUSH
72340: PPUSH
72341: PPUSH
72342: PPUSH
72343: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72344: LD_ADDR_VAR 0 5
72348: PUSH
72349: LD_INT 0
72351: PUSH
72352: LD_INT 0
72354: PUSH
72355: LD_INT 0
72357: PUSH
72358: EMPTY
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: LIST
72364: LIST
72365: ST_TO_ADDR
// if not x or not y then
72366: LD_VAR 0 2
72370: NOT
72371: PUSH
72372: LD_VAR 0 3
72376: NOT
72377: OR
72378: IFFALSE 72382
// exit ;
72380: GO 74028
// if not range then
72382: LD_VAR 0 4
72386: NOT
72387: IFFALSE 72397
// range := 10 ;
72389: LD_ADDR_VAR 0 4
72393: PUSH
72394: LD_INT 10
72396: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72397: LD_ADDR_VAR 0 8
72401: PUSH
72402: LD_INT 81
72404: PUSH
72405: LD_VAR 0 1
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 92
72416: PUSH
72417: LD_VAR 0 2
72421: PUSH
72422: LD_VAR 0 3
72426: PUSH
72427: LD_VAR 0 4
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 3
72440: PUSH
72441: LD_INT 21
72443: PUSH
72444: LD_INT 3
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: LIST
72459: PPUSH
72460: CALL_OW 69
72464: ST_TO_ADDR
// if not tmp then
72465: LD_VAR 0 8
72469: NOT
72470: IFFALSE 72474
// exit ;
72472: GO 74028
// for i in tmp do
72474: LD_ADDR_VAR 0 6
72478: PUSH
72479: LD_VAR 0 8
72483: PUSH
72484: FOR_IN
72485: IFFALSE 74003
// begin points := [ 0 , 0 , 0 ] ;
72487: LD_ADDR_VAR 0 9
72491: PUSH
72492: LD_INT 0
72494: PUSH
72495: LD_INT 0
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: LIST
72505: ST_TO_ADDR
// bpoints := 1 ;
72506: LD_ADDR_VAR 0 10
72510: PUSH
72511: LD_INT 1
72513: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72514: LD_VAR 0 6
72518: PPUSH
72519: CALL_OW 247
72523: PUSH
72524: LD_INT 1
72526: DOUBLE
72527: EQUAL
72528: IFTRUE 72532
72530: GO 73110
72532: POP
// begin if GetClass ( i ) = 1 then
72533: LD_VAR 0 6
72537: PPUSH
72538: CALL_OW 257
72542: PUSH
72543: LD_INT 1
72545: EQUAL
72546: IFFALSE 72567
// points := [ 10 , 5 , 3 ] ;
72548: LD_ADDR_VAR 0 9
72552: PUSH
72553: LD_INT 10
72555: PUSH
72556: LD_INT 5
72558: PUSH
72559: LD_INT 3
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: LIST
72566: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72567: LD_VAR 0 6
72571: PPUSH
72572: CALL_OW 257
72576: PUSH
72577: LD_INT 2
72579: PUSH
72580: LD_INT 3
72582: PUSH
72583: LD_INT 4
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: LIST
72590: IN
72591: IFFALSE 72612
// points := [ 3 , 2 , 1 ] ;
72593: LD_ADDR_VAR 0 9
72597: PUSH
72598: LD_INT 3
72600: PUSH
72601: LD_INT 2
72603: PUSH
72604: LD_INT 1
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: LIST
72611: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72612: LD_VAR 0 6
72616: PPUSH
72617: CALL_OW 257
72621: PUSH
72622: LD_INT 5
72624: EQUAL
72625: IFFALSE 72646
// points := [ 130 , 5 , 2 ] ;
72627: LD_ADDR_VAR 0 9
72631: PUSH
72632: LD_INT 130
72634: PUSH
72635: LD_INT 5
72637: PUSH
72638: LD_INT 2
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: LIST
72645: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72646: LD_VAR 0 6
72650: PPUSH
72651: CALL_OW 257
72655: PUSH
72656: LD_INT 8
72658: EQUAL
72659: IFFALSE 72680
// points := [ 35 , 35 , 30 ] ;
72661: LD_ADDR_VAR 0 9
72665: PUSH
72666: LD_INT 35
72668: PUSH
72669: LD_INT 35
72671: PUSH
72672: LD_INT 30
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: LIST
72679: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72680: LD_VAR 0 6
72684: PPUSH
72685: CALL_OW 257
72689: PUSH
72690: LD_INT 9
72692: EQUAL
72693: IFFALSE 72714
// points := [ 20 , 55 , 40 ] ;
72695: LD_ADDR_VAR 0 9
72699: PUSH
72700: LD_INT 20
72702: PUSH
72703: LD_INT 55
72705: PUSH
72706: LD_INT 40
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: LIST
72713: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72714: LD_VAR 0 6
72718: PPUSH
72719: CALL_OW 257
72723: PUSH
72724: LD_INT 12
72726: PUSH
72727: LD_INT 16
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: IN
72734: IFFALSE 72755
// points := [ 5 , 3 , 2 ] ;
72736: LD_ADDR_VAR 0 9
72740: PUSH
72741: LD_INT 5
72743: PUSH
72744: LD_INT 3
72746: PUSH
72747: LD_INT 2
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: LIST
72754: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72755: LD_VAR 0 6
72759: PPUSH
72760: CALL_OW 257
72764: PUSH
72765: LD_INT 17
72767: EQUAL
72768: IFFALSE 72789
// points := [ 100 , 50 , 75 ] ;
72770: LD_ADDR_VAR 0 9
72774: PUSH
72775: LD_INT 100
72777: PUSH
72778: LD_INT 50
72780: PUSH
72781: LD_INT 75
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: LIST
72788: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72789: LD_VAR 0 6
72793: PPUSH
72794: CALL_OW 257
72798: PUSH
72799: LD_INT 15
72801: EQUAL
72802: IFFALSE 72823
// points := [ 10 , 5 , 3 ] ;
72804: LD_ADDR_VAR 0 9
72808: PUSH
72809: LD_INT 10
72811: PUSH
72812: LD_INT 5
72814: PUSH
72815: LD_INT 3
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: LIST
72822: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72823: LD_VAR 0 6
72827: PPUSH
72828: CALL_OW 257
72832: PUSH
72833: LD_INT 14
72835: EQUAL
72836: IFFALSE 72857
// points := [ 10 , 0 , 0 ] ;
72838: LD_ADDR_VAR 0 9
72842: PUSH
72843: LD_INT 10
72845: PUSH
72846: LD_INT 0
72848: PUSH
72849: LD_INT 0
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: LIST
72856: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72857: LD_VAR 0 6
72861: PPUSH
72862: CALL_OW 257
72866: PUSH
72867: LD_INT 11
72869: EQUAL
72870: IFFALSE 72891
// points := [ 30 , 10 , 5 ] ;
72872: LD_ADDR_VAR 0 9
72876: PUSH
72877: LD_INT 30
72879: PUSH
72880: LD_INT 10
72882: PUSH
72883: LD_INT 5
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: LIST
72890: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72891: LD_VAR 0 1
72895: PPUSH
72896: LD_INT 5
72898: PPUSH
72899: CALL_OW 321
72903: PUSH
72904: LD_INT 2
72906: EQUAL
72907: IFFALSE 72924
// bpoints := bpoints * 1.8 ;
72909: LD_ADDR_VAR 0 10
72913: PUSH
72914: LD_VAR 0 10
72918: PUSH
72919: LD_REAL  1.80000000000000E+0000
72922: MUL
72923: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72924: LD_VAR 0 6
72928: PPUSH
72929: CALL_OW 257
72933: PUSH
72934: LD_INT 1
72936: PUSH
72937: LD_INT 2
72939: PUSH
72940: LD_INT 3
72942: PUSH
72943: LD_INT 4
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: LIST
72950: LIST
72951: IN
72952: PUSH
72953: LD_VAR 0 1
72957: PPUSH
72958: LD_INT 51
72960: PPUSH
72961: CALL_OW 321
72965: PUSH
72966: LD_INT 2
72968: EQUAL
72969: AND
72970: IFFALSE 72987
// bpoints := bpoints * 1.2 ;
72972: LD_ADDR_VAR 0 10
72976: PUSH
72977: LD_VAR 0 10
72981: PUSH
72982: LD_REAL  1.20000000000000E+0000
72985: MUL
72986: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72987: LD_VAR 0 6
72991: PPUSH
72992: CALL_OW 257
72996: PUSH
72997: LD_INT 5
72999: PUSH
73000: LD_INT 7
73002: PUSH
73003: LD_INT 9
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: LIST
73010: IN
73011: PUSH
73012: LD_VAR 0 1
73016: PPUSH
73017: LD_INT 52
73019: PPUSH
73020: CALL_OW 321
73024: PUSH
73025: LD_INT 2
73027: EQUAL
73028: AND
73029: IFFALSE 73046
// bpoints := bpoints * 1.5 ;
73031: LD_ADDR_VAR 0 10
73035: PUSH
73036: LD_VAR 0 10
73040: PUSH
73041: LD_REAL  1.50000000000000E+0000
73044: MUL
73045: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73046: LD_VAR 0 1
73050: PPUSH
73051: LD_INT 66
73053: PPUSH
73054: CALL_OW 321
73058: PUSH
73059: LD_INT 2
73061: EQUAL
73062: IFFALSE 73079
// bpoints := bpoints * 1.1 ;
73064: LD_ADDR_VAR 0 10
73068: PUSH
73069: LD_VAR 0 10
73073: PUSH
73074: LD_REAL  1.10000000000000E+0000
73077: MUL
73078: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73079: LD_ADDR_VAR 0 10
73083: PUSH
73084: LD_VAR 0 10
73088: PUSH
73089: LD_VAR 0 6
73093: PPUSH
73094: LD_INT 1
73096: PPUSH
73097: CALL_OW 259
73101: PUSH
73102: LD_REAL  1.15000000000000E+0000
73105: MUL
73106: MUL
73107: ST_TO_ADDR
// end ; unit_vehicle :
73108: GO 73932
73110: LD_INT 2
73112: DOUBLE
73113: EQUAL
73114: IFTRUE 73118
73116: GO 73920
73118: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73119: LD_VAR 0 6
73123: PPUSH
73124: CALL_OW 264
73128: PUSH
73129: LD_INT 2
73131: PUSH
73132: LD_INT 42
73134: PUSH
73135: LD_INT 24
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: LIST
73142: IN
73143: IFFALSE 73164
// points := [ 25 , 5 , 3 ] ;
73145: LD_ADDR_VAR 0 9
73149: PUSH
73150: LD_INT 25
73152: PUSH
73153: LD_INT 5
73155: PUSH
73156: LD_INT 3
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: LIST
73163: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73164: LD_VAR 0 6
73168: PPUSH
73169: CALL_OW 264
73173: PUSH
73174: LD_INT 4
73176: PUSH
73177: LD_INT 43
73179: PUSH
73180: LD_INT 25
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: LIST
73187: IN
73188: IFFALSE 73209
// points := [ 40 , 15 , 5 ] ;
73190: LD_ADDR_VAR 0 9
73194: PUSH
73195: LD_INT 40
73197: PUSH
73198: LD_INT 15
73200: PUSH
73201: LD_INT 5
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: LIST
73208: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73209: LD_VAR 0 6
73213: PPUSH
73214: CALL_OW 264
73218: PUSH
73219: LD_INT 3
73221: PUSH
73222: LD_INT 23
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: IN
73229: IFFALSE 73250
// points := [ 7 , 25 , 8 ] ;
73231: LD_ADDR_VAR 0 9
73235: PUSH
73236: LD_INT 7
73238: PUSH
73239: LD_INT 25
73241: PUSH
73242: LD_INT 8
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: LIST
73249: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73250: LD_VAR 0 6
73254: PPUSH
73255: CALL_OW 264
73259: PUSH
73260: LD_INT 5
73262: PUSH
73263: LD_INT 27
73265: PUSH
73266: LD_INT 44
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: LIST
73273: IN
73274: IFFALSE 73295
// points := [ 14 , 50 , 16 ] ;
73276: LD_ADDR_VAR 0 9
73280: PUSH
73281: LD_INT 14
73283: PUSH
73284: LD_INT 50
73286: PUSH
73287: LD_INT 16
73289: PUSH
73290: EMPTY
73291: LIST
73292: LIST
73293: LIST
73294: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73295: LD_VAR 0 6
73299: PPUSH
73300: CALL_OW 264
73304: PUSH
73305: LD_INT 6
73307: PUSH
73308: LD_INT 46
73310: PUSH
73311: EMPTY
73312: LIST
73313: LIST
73314: IN
73315: IFFALSE 73336
// points := [ 32 , 120 , 70 ] ;
73317: LD_ADDR_VAR 0 9
73321: PUSH
73322: LD_INT 32
73324: PUSH
73325: LD_INT 120
73327: PUSH
73328: LD_INT 70
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: LIST
73335: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73336: LD_VAR 0 6
73340: PPUSH
73341: CALL_OW 264
73345: PUSH
73346: LD_INT 7
73348: PUSH
73349: LD_INT 28
73351: PUSH
73352: LD_INT 45
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: LIST
73359: IN
73360: IFFALSE 73381
// points := [ 35 , 20 , 45 ] ;
73362: LD_ADDR_VAR 0 9
73366: PUSH
73367: LD_INT 35
73369: PUSH
73370: LD_INT 20
73372: PUSH
73373: LD_INT 45
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: LIST
73380: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73381: LD_VAR 0 6
73385: PPUSH
73386: CALL_OW 264
73390: PUSH
73391: LD_INT 47
73393: PUSH
73394: EMPTY
73395: LIST
73396: IN
73397: IFFALSE 73418
// points := [ 67 , 45 , 75 ] ;
73399: LD_ADDR_VAR 0 9
73403: PUSH
73404: LD_INT 67
73406: PUSH
73407: LD_INT 45
73409: PUSH
73410: LD_INT 75
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: LIST
73417: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73418: LD_VAR 0 6
73422: PPUSH
73423: CALL_OW 264
73427: PUSH
73428: LD_INT 26
73430: PUSH
73431: EMPTY
73432: LIST
73433: IN
73434: IFFALSE 73455
// points := [ 120 , 30 , 80 ] ;
73436: LD_ADDR_VAR 0 9
73440: PUSH
73441: LD_INT 120
73443: PUSH
73444: LD_INT 30
73446: PUSH
73447: LD_INT 80
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: LIST
73454: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73455: LD_VAR 0 6
73459: PPUSH
73460: CALL_OW 264
73464: PUSH
73465: LD_INT 22
73467: PUSH
73468: EMPTY
73469: LIST
73470: IN
73471: IFFALSE 73492
// points := [ 40 , 1 , 1 ] ;
73473: LD_ADDR_VAR 0 9
73477: PUSH
73478: LD_INT 40
73480: PUSH
73481: LD_INT 1
73483: PUSH
73484: LD_INT 1
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: LIST
73491: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73492: LD_VAR 0 6
73496: PPUSH
73497: CALL_OW 264
73501: PUSH
73502: LD_INT 29
73504: PUSH
73505: EMPTY
73506: LIST
73507: IN
73508: IFFALSE 73529
// points := [ 70 , 200 , 400 ] ;
73510: LD_ADDR_VAR 0 9
73514: PUSH
73515: LD_INT 70
73517: PUSH
73518: LD_INT 200
73520: PUSH
73521: LD_INT 400
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: LIST
73528: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73529: LD_VAR 0 6
73533: PPUSH
73534: CALL_OW 264
73538: PUSH
73539: LD_INT 14
73541: PUSH
73542: LD_INT 53
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: IN
73549: IFFALSE 73570
// points := [ 40 , 10 , 20 ] ;
73551: LD_ADDR_VAR 0 9
73555: PUSH
73556: LD_INT 40
73558: PUSH
73559: LD_INT 10
73561: PUSH
73562: LD_INT 20
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: LIST
73569: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73570: LD_VAR 0 6
73574: PPUSH
73575: CALL_OW 264
73579: PUSH
73580: LD_INT 9
73582: PUSH
73583: EMPTY
73584: LIST
73585: IN
73586: IFFALSE 73607
// points := [ 5 , 70 , 20 ] ;
73588: LD_ADDR_VAR 0 9
73592: PUSH
73593: LD_INT 5
73595: PUSH
73596: LD_INT 70
73598: PUSH
73599: LD_INT 20
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: LIST
73606: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73607: LD_VAR 0 6
73611: PPUSH
73612: CALL_OW 264
73616: PUSH
73617: LD_INT 10
73619: PUSH
73620: EMPTY
73621: LIST
73622: IN
73623: IFFALSE 73644
// points := [ 35 , 110 , 70 ] ;
73625: LD_ADDR_VAR 0 9
73629: PUSH
73630: LD_INT 35
73632: PUSH
73633: LD_INT 110
73635: PUSH
73636: LD_INT 70
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: LIST
73643: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73644: LD_VAR 0 6
73648: PPUSH
73649: CALL_OW 265
73653: PUSH
73654: LD_INT 25
73656: EQUAL
73657: IFFALSE 73678
// points := [ 80 , 65 , 100 ] ;
73659: LD_ADDR_VAR 0 9
73663: PUSH
73664: LD_INT 80
73666: PUSH
73667: LD_INT 65
73669: PUSH
73670: LD_INT 100
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: LIST
73677: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73678: LD_VAR 0 6
73682: PPUSH
73683: CALL_OW 263
73687: PUSH
73688: LD_INT 1
73690: EQUAL
73691: IFFALSE 73726
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73693: LD_ADDR_VAR 0 10
73697: PUSH
73698: LD_VAR 0 10
73702: PUSH
73703: LD_VAR 0 6
73707: PPUSH
73708: CALL_OW 311
73712: PPUSH
73713: LD_INT 3
73715: PPUSH
73716: CALL_OW 259
73720: PUSH
73721: LD_INT 4
73723: MUL
73724: MUL
73725: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73726: LD_VAR 0 6
73730: PPUSH
73731: CALL_OW 263
73735: PUSH
73736: LD_INT 2
73738: EQUAL
73739: IFFALSE 73790
// begin j := IsControledBy ( i ) ;
73741: LD_ADDR_VAR 0 7
73745: PUSH
73746: LD_VAR 0 6
73750: PPUSH
73751: CALL_OW 312
73755: ST_TO_ADDR
// if j then
73756: LD_VAR 0 7
73760: IFFALSE 73790
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73762: LD_ADDR_VAR 0 10
73766: PUSH
73767: LD_VAR 0 10
73771: PUSH
73772: LD_VAR 0 7
73776: PPUSH
73777: LD_INT 3
73779: PPUSH
73780: CALL_OW 259
73784: PUSH
73785: LD_INT 3
73787: MUL
73788: MUL
73789: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73790: LD_VAR 0 6
73794: PPUSH
73795: CALL_OW 264
73799: PUSH
73800: LD_INT 5
73802: PUSH
73803: LD_INT 6
73805: PUSH
73806: LD_INT 46
73808: PUSH
73809: LD_INT 44
73811: PUSH
73812: LD_INT 47
73814: PUSH
73815: LD_INT 45
73817: PUSH
73818: LD_INT 28
73820: PUSH
73821: LD_INT 7
73823: PUSH
73824: LD_INT 27
73826: PUSH
73827: LD_INT 29
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: LIST
73834: LIST
73835: LIST
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: IN
73842: PUSH
73843: LD_VAR 0 1
73847: PPUSH
73848: LD_INT 52
73850: PPUSH
73851: CALL_OW 321
73855: PUSH
73856: LD_INT 2
73858: EQUAL
73859: AND
73860: IFFALSE 73877
// bpoints := bpoints * 1.2 ;
73862: LD_ADDR_VAR 0 10
73866: PUSH
73867: LD_VAR 0 10
73871: PUSH
73872: LD_REAL  1.20000000000000E+0000
73875: MUL
73876: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73877: LD_VAR 0 6
73881: PPUSH
73882: CALL_OW 264
73886: PUSH
73887: LD_INT 6
73889: PUSH
73890: LD_INT 46
73892: PUSH
73893: LD_INT 47
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: LIST
73900: IN
73901: IFFALSE 73918
// bpoints := bpoints * 1.2 ;
73903: LD_ADDR_VAR 0 10
73907: PUSH
73908: LD_VAR 0 10
73912: PUSH
73913: LD_REAL  1.20000000000000E+0000
73916: MUL
73917: ST_TO_ADDR
// end ; unit_building :
73918: GO 73932
73920: LD_INT 3
73922: DOUBLE
73923: EQUAL
73924: IFTRUE 73928
73926: GO 73931
73928: POP
// ; end ;
73929: GO 73932
73931: POP
// for j = 1 to 3 do
73932: LD_ADDR_VAR 0 7
73936: PUSH
73937: DOUBLE
73938: LD_INT 1
73940: DEC
73941: ST_TO_ADDR
73942: LD_INT 3
73944: PUSH
73945: FOR_TO
73946: IFFALSE 73999
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73948: LD_ADDR_VAR 0 5
73952: PUSH
73953: LD_VAR 0 5
73957: PPUSH
73958: LD_VAR 0 7
73962: PPUSH
73963: LD_VAR 0 5
73967: PUSH
73968: LD_VAR 0 7
73972: ARRAY
73973: PUSH
73974: LD_VAR 0 9
73978: PUSH
73979: LD_VAR 0 7
73983: ARRAY
73984: PUSH
73985: LD_VAR 0 10
73989: MUL
73990: PLUS
73991: PPUSH
73992: CALL_OW 1
73996: ST_TO_ADDR
73997: GO 73945
73999: POP
74000: POP
// end ;
74001: GO 72484
74003: POP
74004: POP
// result := Replace ( result , 4 , tmp ) ;
74005: LD_ADDR_VAR 0 5
74009: PUSH
74010: LD_VAR 0 5
74014: PPUSH
74015: LD_INT 4
74017: PPUSH
74018: LD_VAR 0 8
74022: PPUSH
74023: CALL_OW 1
74027: ST_TO_ADDR
// end ;
74028: LD_VAR 0 5
74032: RET
// export function DangerAtRange ( unit , range ) ; begin
74033: LD_INT 0
74035: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74036: LD_ADDR_VAR 0 3
74040: PUSH
74041: LD_VAR 0 1
74045: PPUSH
74046: CALL_OW 255
74050: PPUSH
74051: LD_VAR 0 1
74055: PPUSH
74056: CALL_OW 250
74060: PPUSH
74061: LD_VAR 0 1
74065: PPUSH
74066: CALL_OW 251
74070: PPUSH
74071: LD_VAR 0 2
74075: PPUSH
74076: CALL 72336 0 4
74080: ST_TO_ADDR
// end ;
74081: LD_VAR 0 3
74085: RET
// export function DangerInArea ( side , area ) ; begin
74086: LD_INT 0
74088: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74089: LD_ADDR_VAR 0 3
74093: PUSH
74094: LD_VAR 0 2
74098: PPUSH
74099: LD_INT 81
74101: PUSH
74102: LD_VAR 0 1
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PPUSH
74111: CALL_OW 70
74115: ST_TO_ADDR
// end ;
74116: LD_VAR 0 3
74120: RET
// export function IsExtension ( b ) ; begin
74121: LD_INT 0
74123: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74124: LD_ADDR_VAR 0 2
74128: PUSH
74129: LD_VAR 0 1
74133: PUSH
74134: LD_INT 23
74136: PUSH
74137: LD_INT 20
74139: PUSH
74140: LD_INT 22
74142: PUSH
74143: LD_INT 17
74145: PUSH
74146: LD_INT 24
74148: PUSH
74149: LD_INT 21
74151: PUSH
74152: LD_INT 19
74154: PUSH
74155: LD_INT 16
74157: PUSH
74158: LD_INT 25
74160: PUSH
74161: LD_INT 18
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: LIST
74168: LIST
74169: LIST
74170: LIST
74171: LIST
74172: LIST
74173: LIST
74174: LIST
74175: IN
74176: ST_TO_ADDR
// end ;
74177: LD_VAR 0 2
74181: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74182: LD_INT 0
74184: PPUSH
74185: PPUSH
74186: PPUSH
// result := [ ] ;
74187: LD_ADDR_VAR 0 3
74191: PUSH
74192: EMPTY
74193: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74194: LD_ADDR_VAR 0 4
74198: PUSH
74199: LD_VAR 0 2
74203: PPUSH
74204: LD_INT 21
74206: PUSH
74207: LD_INT 3
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: PPUSH
74214: CALL_OW 70
74218: ST_TO_ADDR
// if not tmp then
74219: LD_VAR 0 4
74223: NOT
74224: IFFALSE 74228
// exit ;
74226: GO 74286
// for i in tmp do
74228: LD_ADDR_VAR 0 5
74232: PUSH
74233: LD_VAR 0 4
74237: PUSH
74238: FOR_IN
74239: IFFALSE 74274
// if GetBase ( i ) <> base then
74241: LD_VAR 0 5
74245: PPUSH
74246: CALL_OW 274
74250: PUSH
74251: LD_VAR 0 1
74255: NONEQUAL
74256: IFFALSE 74272
// ComLinkToBase ( base , i ) ;
74258: LD_VAR 0 1
74262: PPUSH
74263: LD_VAR 0 5
74267: PPUSH
74268: CALL_OW 169
74272: GO 74238
74274: POP
74275: POP
// result := tmp ;
74276: LD_ADDR_VAR 0 3
74280: PUSH
74281: LD_VAR 0 4
74285: ST_TO_ADDR
// end ;
74286: LD_VAR 0 3
74290: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74291: LD_INT 0
74293: PPUSH
74294: PPUSH
// if BuildingStatus ( b ) = bs_build then
74295: LD_VAR 0 2
74299: PPUSH
74300: CALL_OW 461
74304: PUSH
74305: LD_INT 1
74307: EQUAL
74308: IFFALSE 74368
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74310: LD_VAR 0 1
74314: PPUSH
74315: LD_STRING h
74317: PUSH
74318: LD_VAR 0 2
74322: PPUSH
74323: CALL_OW 250
74327: PUSH
74328: LD_VAR 0 2
74332: PPUSH
74333: CALL_OW 251
74337: PUSH
74338: LD_VAR 0 2
74342: PUSH
74343: LD_INT 0
74345: PUSH
74346: LD_INT 0
74348: PUSH
74349: LD_INT 0
74351: PUSH
74352: EMPTY
74353: LIST
74354: LIST
74355: LIST
74356: LIST
74357: LIST
74358: LIST
74359: LIST
74360: PUSH
74361: EMPTY
74362: LIST
74363: PPUSH
74364: CALL_OW 446
// end ;
74368: LD_VAR 0 3
74372: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74373: LD_INT 0
74375: PPUSH
74376: PPUSH
74377: PPUSH
74378: PPUSH
74379: PPUSH
74380: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74381: LD_VAR 0 1
74385: NOT
74386: PUSH
74387: LD_VAR 0 1
74391: PPUSH
74392: CALL_OW 263
74396: PUSH
74397: LD_INT 2
74399: EQUAL
74400: NOT
74401: OR
74402: IFFALSE 74406
// exit ;
74404: GO 74722
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74406: LD_ADDR_VAR 0 6
74410: PUSH
74411: LD_INT 22
74413: PUSH
74414: LD_VAR 0 1
74418: PPUSH
74419: CALL_OW 255
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: PUSH
74428: LD_INT 2
74430: PUSH
74431: LD_INT 30
74433: PUSH
74434: LD_INT 36
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: LD_INT 34
74443: PUSH
74444: LD_INT 31
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: LIST
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PPUSH
74460: CALL_OW 69
74464: ST_TO_ADDR
// if not tmp then
74465: LD_VAR 0 6
74469: NOT
74470: IFFALSE 74474
// exit ;
74472: GO 74722
// result := [ ] ;
74474: LD_ADDR_VAR 0 2
74478: PUSH
74479: EMPTY
74480: ST_TO_ADDR
// for i in tmp do
74481: LD_ADDR_VAR 0 3
74485: PUSH
74486: LD_VAR 0 6
74490: PUSH
74491: FOR_IN
74492: IFFALSE 74563
// begin t := UnitsInside ( i ) ;
74494: LD_ADDR_VAR 0 4
74498: PUSH
74499: LD_VAR 0 3
74503: PPUSH
74504: CALL_OW 313
74508: ST_TO_ADDR
// if t then
74509: LD_VAR 0 4
74513: IFFALSE 74561
// for j in t do
74515: LD_ADDR_VAR 0 7
74519: PUSH
74520: LD_VAR 0 4
74524: PUSH
74525: FOR_IN
74526: IFFALSE 74559
// result := Insert ( result , result + 1 , j ) ;
74528: LD_ADDR_VAR 0 2
74532: PUSH
74533: LD_VAR 0 2
74537: PPUSH
74538: LD_VAR 0 2
74542: PUSH
74543: LD_INT 1
74545: PLUS
74546: PPUSH
74547: LD_VAR 0 7
74551: PPUSH
74552: CALL_OW 2
74556: ST_TO_ADDR
74557: GO 74525
74559: POP
74560: POP
// end ;
74561: GO 74491
74563: POP
74564: POP
// if not result then
74565: LD_VAR 0 2
74569: NOT
74570: IFFALSE 74574
// exit ;
74572: GO 74722
// mech := result [ 1 ] ;
74574: LD_ADDR_VAR 0 5
74578: PUSH
74579: LD_VAR 0 2
74583: PUSH
74584: LD_INT 1
74586: ARRAY
74587: ST_TO_ADDR
// if result > 1 then
74588: LD_VAR 0 2
74592: PUSH
74593: LD_INT 1
74595: GREATER
74596: IFFALSE 74708
// for i = 2 to result do
74598: LD_ADDR_VAR 0 3
74602: PUSH
74603: DOUBLE
74604: LD_INT 2
74606: DEC
74607: ST_TO_ADDR
74608: LD_VAR 0 2
74612: PUSH
74613: FOR_TO
74614: IFFALSE 74706
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74616: LD_ADDR_VAR 0 4
74620: PUSH
74621: LD_VAR 0 2
74625: PUSH
74626: LD_VAR 0 3
74630: ARRAY
74631: PPUSH
74632: LD_INT 3
74634: PPUSH
74635: CALL_OW 259
74639: PUSH
74640: LD_VAR 0 2
74644: PUSH
74645: LD_VAR 0 3
74649: ARRAY
74650: PPUSH
74651: CALL_OW 432
74655: MINUS
74656: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74657: LD_VAR 0 4
74661: PUSH
74662: LD_VAR 0 5
74666: PPUSH
74667: LD_INT 3
74669: PPUSH
74670: CALL_OW 259
74674: PUSH
74675: LD_VAR 0 5
74679: PPUSH
74680: CALL_OW 432
74684: MINUS
74685: GREATEREQUAL
74686: IFFALSE 74704
// mech := result [ i ] ;
74688: LD_ADDR_VAR 0 5
74692: PUSH
74693: LD_VAR 0 2
74697: PUSH
74698: LD_VAR 0 3
74702: ARRAY
74703: ST_TO_ADDR
// end ;
74704: GO 74613
74706: POP
74707: POP
// ComLinkTo ( vehicle , mech ) ;
74708: LD_VAR 0 1
74712: PPUSH
74713: LD_VAR 0 5
74717: PPUSH
74718: CALL_OW 135
// end ;
74722: LD_VAR 0 2
74726: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74727: LD_INT 0
74729: PPUSH
74730: PPUSH
74731: PPUSH
74732: PPUSH
74733: PPUSH
74734: PPUSH
74735: PPUSH
74736: PPUSH
74737: PPUSH
74738: PPUSH
74739: PPUSH
74740: PPUSH
74741: PPUSH
// result := [ ] ;
74742: LD_ADDR_VAR 0 7
74746: PUSH
74747: EMPTY
74748: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74749: LD_VAR 0 1
74753: PPUSH
74754: CALL_OW 266
74758: PUSH
74759: LD_INT 0
74761: PUSH
74762: LD_INT 1
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: IN
74769: NOT
74770: IFFALSE 74774
// exit ;
74772: GO 76405
// if name then
74774: LD_VAR 0 3
74778: IFFALSE 74794
// SetBName ( base_dep , name ) ;
74780: LD_VAR 0 1
74784: PPUSH
74785: LD_VAR 0 3
74789: PPUSH
74790: CALL_OW 500
// base := GetBase ( base_dep ) ;
74794: LD_ADDR_VAR 0 15
74798: PUSH
74799: LD_VAR 0 1
74803: PPUSH
74804: CALL_OW 274
74808: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74809: LD_ADDR_VAR 0 16
74813: PUSH
74814: LD_VAR 0 1
74818: PPUSH
74819: CALL_OW 255
74823: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74824: LD_ADDR_VAR 0 17
74828: PUSH
74829: LD_VAR 0 1
74833: PPUSH
74834: CALL_OW 248
74838: ST_TO_ADDR
// if sources then
74839: LD_VAR 0 5
74843: IFFALSE 74890
// for i = 1 to 3 do
74845: LD_ADDR_VAR 0 8
74849: PUSH
74850: DOUBLE
74851: LD_INT 1
74853: DEC
74854: ST_TO_ADDR
74855: LD_INT 3
74857: PUSH
74858: FOR_TO
74859: IFFALSE 74888
// AddResourceType ( base , i , sources [ i ] ) ;
74861: LD_VAR 0 15
74865: PPUSH
74866: LD_VAR 0 8
74870: PPUSH
74871: LD_VAR 0 5
74875: PUSH
74876: LD_VAR 0 8
74880: ARRAY
74881: PPUSH
74882: CALL_OW 276
74886: GO 74858
74888: POP
74889: POP
// buildings := GetBaseBuildings ( base , area ) ;
74890: LD_ADDR_VAR 0 18
74894: PUSH
74895: LD_VAR 0 15
74899: PPUSH
74900: LD_VAR 0 2
74904: PPUSH
74905: CALL 74182 0 2
74909: ST_TO_ADDR
// InitHc ;
74910: CALL_OW 19
// InitUc ;
74914: CALL_OW 18
// uc_side := side ;
74918: LD_ADDR_OWVAR 20
74922: PUSH
74923: LD_VAR 0 16
74927: ST_TO_ADDR
// uc_nation := nation ;
74928: LD_ADDR_OWVAR 21
74932: PUSH
74933: LD_VAR 0 17
74937: ST_TO_ADDR
// if buildings then
74938: LD_VAR 0 18
74942: IFFALSE 76264
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74944: LD_ADDR_VAR 0 19
74948: PUSH
74949: LD_VAR 0 18
74953: PPUSH
74954: LD_INT 2
74956: PUSH
74957: LD_INT 30
74959: PUSH
74960: LD_INT 29
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 30
74969: PUSH
74970: LD_INT 30
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: LIST
74981: PPUSH
74982: CALL_OW 72
74986: ST_TO_ADDR
// if tmp then
74987: LD_VAR 0 19
74991: IFFALSE 75039
// for i in tmp do
74993: LD_ADDR_VAR 0 8
74997: PUSH
74998: LD_VAR 0 19
75002: PUSH
75003: FOR_IN
75004: IFFALSE 75037
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75006: LD_VAR 0 8
75010: PPUSH
75011: CALL_OW 250
75015: PPUSH
75016: LD_VAR 0 8
75020: PPUSH
75021: CALL_OW 251
75025: PPUSH
75026: LD_VAR 0 16
75030: PPUSH
75031: CALL_OW 441
75035: GO 75003
75037: POP
75038: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75039: LD_VAR 0 18
75043: PPUSH
75044: LD_INT 2
75046: PUSH
75047: LD_INT 30
75049: PUSH
75050: LD_INT 32
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 30
75059: PUSH
75060: LD_INT 33
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: LIST
75071: PPUSH
75072: CALL_OW 72
75076: IFFALSE 75164
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75078: LD_ADDR_VAR 0 8
75082: PUSH
75083: LD_VAR 0 18
75087: PPUSH
75088: LD_INT 2
75090: PUSH
75091: LD_INT 30
75093: PUSH
75094: LD_INT 32
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 30
75103: PUSH
75104: LD_INT 33
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: LIST
75115: PPUSH
75116: CALL_OW 72
75120: PUSH
75121: FOR_IN
75122: IFFALSE 75162
// begin if not GetBWeapon ( i ) then
75124: LD_VAR 0 8
75128: PPUSH
75129: CALL_OW 269
75133: NOT
75134: IFFALSE 75160
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75136: LD_VAR 0 8
75140: PPUSH
75141: LD_VAR 0 8
75145: PPUSH
75146: LD_VAR 0 2
75150: PPUSH
75151: CALL 76410 0 2
75155: PPUSH
75156: CALL_OW 431
// end ;
75160: GO 75121
75162: POP
75163: POP
// end ; for i = 1 to personel do
75164: LD_ADDR_VAR 0 8
75168: PUSH
75169: DOUBLE
75170: LD_INT 1
75172: DEC
75173: ST_TO_ADDR
75174: LD_VAR 0 6
75178: PUSH
75179: FOR_TO
75180: IFFALSE 76244
// begin if i > 4 then
75182: LD_VAR 0 8
75186: PUSH
75187: LD_INT 4
75189: GREATER
75190: IFFALSE 75194
// break ;
75192: GO 76244
// case i of 1 :
75194: LD_VAR 0 8
75198: PUSH
75199: LD_INT 1
75201: DOUBLE
75202: EQUAL
75203: IFTRUE 75207
75205: GO 75287
75207: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75208: LD_ADDR_VAR 0 12
75212: PUSH
75213: LD_VAR 0 18
75217: PPUSH
75218: LD_INT 22
75220: PUSH
75221: LD_VAR 0 16
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PUSH
75230: LD_INT 58
75232: PUSH
75233: EMPTY
75234: LIST
75235: PUSH
75236: LD_INT 2
75238: PUSH
75239: LD_INT 30
75241: PUSH
75242: LD_INT 32
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 30
75251: PUSH
75252: LD_INT 4
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: PUSH
75259: LD_INT 30
75261: PUSH
75262: LD_INT 5
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: PUSH
75269: EMPTY
75270: LIST
75271: LIST
75272: LIST
75273: LIST
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: LIST
75279: PPUSH
75280: CALL_OW 72
75284: ST_TO_ADDR
75285: GO 75509
75287: LD_INT 2
75289: DOUBLE
75290: EQUAL
75291: IFTRUE 75295
75293: GO 75357
75295: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75296: LD_ADDR_VAR 0 12
75300: PUSH
75301: LD_VAR 0 18
75305: PPUSH
75306: LD_INT 22
75308: PUSH
75309: LD_VAR 0 16
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 2
75320: PUSH
75321: LD_INT 30
75323: PUSH
75324: LD_INT 0
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 30
75333: PUSH
75334: LD_INT 1
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: LIST
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PPUSH
75350: CALL_OW 72
75354: ST_TO_ADDR
75355: GO 75509
75357: LD_INT 3
75359: DOUBLE
75360: EQUAL
75361: IFTRUE 75365
75363: GO 75427
75365: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75366: LD_ADDR_VAR 0 12
75370: PUSH
75371: LD_VAR 0 18
75375: PPUSH
75376: LD_INT 22
75378: PUSH
75379: LD_VAR 0 16
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 2
75390: PUSH
75391: LD_INT 30
75393: PUSH
75394: LD_INT 2
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 30
75403: PUSH
75404: LD_INT 3
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: LIST
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PPUSH
75420: CALL_OW 72
75424: ST_TO_ADDR
75425: GO 75509
75427: LD_INT 4
75429: DOUBLE
75430: EQUAL
75431: IFTRUE 75435
75433: GO 75508
75435: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75436: LD_ADDR_VAR 0 12
75440: PUSH
75441: LD_VAR 0 18
75445: PPUSH
75446: LD_INT 22
75448: PUSH
75449: LD_VAR 0 16
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: PUSH
75458: LD_INT 2
75460: PUSH
75461: LD_INT 30
75463: PUSH
75464: LD_INT 6
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 30
75473: PUSH
75474: LD_INT 7
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: LD_INT 30
75483: PUSH
75484: LD_INT 8
75486: PUSH
75487: EMPTY
75488: LIST
75489: LIST
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: PPUSH
75501: CALL_OW 72
75505: ST_TO_ADDR
75506: GO 75509
75508: POP
// if i = 1 then
75509: LD_VAR 0 8
75513: PUSH
75514: LD_INT 1
75516: EQUAL
75517: IFFALSE 75628
// begin tmp := [ ] ;
75519: LD_ADDR_VAR 0 19
75523: PUSH
75524: EMPTY
75525: ST_TO_ADDR
// for j in f do
75526: LD_ADDR_VAR 0 9
75530: PUSH
75531: LD_VAR 0 12
75535: PUSH
75536: FOR_IN
75537: IFFALSE 75610
// if GetBType ( j ) = b_bunker then
75539: LD_VAR 0 9
75543: PPUSH
75544: CALL_OW 266
75548: PUSH
75549: LD_INT 32
75551: EQUAL
75552: IFFALSE 75579
// tmp := Insert ( tmp , 1 , j ) else
75554: LD_ADDR_VAR 0 19
75558: PUSH
75559: LD_VAR 0 19
75563: PPUSH
75564: LD_INT 1
75566: PPUSH
75567: LD_VAR 0 9
75571: PPUSH
75572: CALL_OW 2
75576: ST_TO_ADDR
75577: GO 75608
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75579: LD_ADDR_VAR 0 19
75583: PUSH
75584: LD_VAR 0 19
75588: PPUSH
75589: LD_VAR 0 19
75593: PUSH
75594: LD_INT 1
75596: PLUS
75597: PPUSH
75598: LD_VAR 0 9
75602: PPUSH
75603: CALL_OW 2
75607: ST_TO_ADDR
75608: GO 75536
75610: POP
75611: POP
// if tmp then
75612: LD_VAR 0 19
75616: IFFALSE 75628
// f := tmp ;
75618: LD_ADDR_VAR 0 12
75622: PUSH
75623: LD_VAR 0 19
75627: ST_TO_ADDR
// end ; x := personel [ i ] ;
75628: LD_ADDR_VAR 0 13
75632: PUSH
75633: LD_VAR 0 6
75637: PUSH
75638: LD_VAR 0 8
75642: ARRAY
75643: ST_TO_ADDR
// if x = - 1 then
75644: LD_VAR 0 13
75648: PUSH
75649: LD_INT 1
75651: NEG
75652: EQUAL
75653: IFFALSE 75862
// begin for j in f do
75655: LD_ADDR_VAR 0 9
75659: PUSH
75660: LD_VAR 0 12
75664: PUSH
75665: FOR_IN
75666: IFFALSE 75858
// repeat InitHc ;
75668: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75672: LD_VAR 0 9
75676: PPUSH
75677: CALL_OW 266
75681: PUSH
75682: LD_INT 5
75684: EQUAL
75685: IFFALSE 75755
// begin if UnitsInside ( j ) < 3 then
75687: LD_VAR 0 9
75691: PPUSH
75692: CALL_OW 313
75696: PUSH
75697: LD_INT 3
75699: LESS
75700: IFFALSE 75736
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75702: LD_INT 0
75704: PPUSH
75705: LD_INT 5
75707: PUSH
75708: LD_INT 8
75710: PUSH
75711: LD_INT 9
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: LIST
75718: PUSH
75719: LD_VAR 0 17
75723: ARRAY
75724: PPUSH
75725: LD_VAR 0 4
75729: PPUSH
75730: CALL_OW 380
75734: GO 75753
// PrepareHuman ( false , i , skill ) ;
75736: LD_INT 0
75738: PPUSH
75739: LD_VAR 0 8
75743: PPUSH
75744: LD_VAR 0 4
75748: PPUSH
75749: CALL_OW 380
// end else
75753: GO 75772
// PrepareHuman ( false , i , skill ) ;
75755: LD_INT 0
75757: PPUSH
75758: LD_VAR 0 8
75762: PPUSH
75763: LD_VAR 0 4
75767: PPUSH
75768: CALL_OW 380
// un := CreateHuman ;
75772: LD_ADDR_VAR 0 14
75776: PUSH
75777: CALL_OW 44
75781: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75782: LD_ADDR_VAR 0 7
75786: PUSH
75787: LD_VAR 0 7
75791: PPUSH
75792: LD_INT 1
75794: PPUSH
75795: LD_VAR 0 14
75799: PPUSH
75800: CALL_OW 2
75804: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75805: LD_VAR 0 14
75809: PPUSH
75810: LD_VAR 0 9
75814: PPUSH
75815: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75819: LD_VAR 0 9
75823: PPUSH
75824: CALL_OW 313
75828: PUSH
75829: LD_INT 6
75831: EQUAL
75832: PUSH
75833: LD_VAR 0 9
75837: PPUSH
75838: CALL_OW 266
75842: PUSH
75843: LD_INT 32
75845: PUSH
75846: LD_INT 31
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: IN
75853: OR
75854: IFFALSE 75668
75856: GO 75665
75858: POP
75859: POP
// end else
75860: GO 76242
// for j = 1 to x do
75862: LD_ADDR_VAR 0 9
75866: PUSH
75867: DOUBLE
75868: LD_INT 1
75870: DEC
75871: ST_TO_ADDR
75872: LD_VAR 0 13
75876: PUSH
75877: FOR_TO
75878: IFFALSE 76240
// begin InitHc ;
75880: CALL_OW 19
// if not f then
75884: LD_VAR 0 12
75888: NOT
75889: IFFALSE 75978
// begin PrepareHuman ( false , i , skill ) ;
75891: LD_INT 0
75893: PPUSH
75894: LD_VAR 0 8
75898: PPUSH
75899: LD_VAR 0 4
75903: PPUSH
75904: CALL_OW 380
// un := CreateHuman ;
75908: LD_ADDR_VAR 0 14
75912: PUSH
75913: CALL_OW 44
75917: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75918: LD_ADDR_VAR 0 7
75922: PUSH
75923: LD_VAR 0 7
75927: PPUSH
75928: LD_INT 1
75930: PPUSH
75931: LD_VAR 0 14
75935: PPUSH
75936: CALL_OW 2
75940: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75941: LD_VAR 0 14
75945: PPUSH
75946: LD_VAR 0 1
75950: PPUSH
75951: CALL_OW 250
75955: PPUSH
75956: LD_VAR 0 1
75960: PPUSH
75961: CALL_OW 251
75965: PPUSH
75966: LD_INT 10
75968: PPUSH
75969: LD_INT 0
75971: PPUSH
75972: CALL_OW 50
// continue ;
75976: GO 75877
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75978: LD_VAR 0 12
75982: PUSH
75983: LD_INT 1
75985: ARRAY
75986: PPUSH
75987: CALL_OW 313
75991: PUSH
75992: LD_VAR 0 12
75996: PUSH
75997: LD_INT 1
75999: ARRAY
76000: PPUSH
76001: CALL_OW 266
76005: PUSH
76006: LD_INT 32
76008: PUSH
76009: LD_INT 31
76011: PUSH
76012: EMPTY
76013: LIST
76014: LIST
76015: IN
76016: AND
76017: PUSH
76018: LD_VAR 0 12
76022: PUSH
76023: LD_INT 1
76025: ARRAY
76026: PPUSH
76027: CALL_OW 313
76031: PUSH
76032: LD_INT 6
76034: EQUAL
76035: OR
76036: IFFALSE 76056
// f := Delete ( f , 1 ) ;
76038: LD_ADDR_VAR 0 12
76042: PUSH
76043: LD_VAR 0 12
76047: PPUSH
76048: LD_INT 1
76050: PPUSH
76051: CALL_OW 3
76055: ST_TO_ADDR
// if not f then
76056: LD_VAR 0 12
76060: NOT
76061: IFFALSE 76079
// begin x := x + 2 ;
76063: LD_ADDR_VAR 0 13
76067: PUSH
76068: LD_VAR 0 13
76072: PUSH
76073: LD_INT 2
76075: PLUS
76076: ST_TO_ADDR
// continue ;
76077: GO 75877
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76079: LD_VAR 0 12
76083: PUSH
76084: LD_INT 1
76086: ARRAY
76087: PPUSH
76088: CALL_OW 266
76092: PUSH
76093: LD_INT 5
76095: EQUAL
76096: IFFALSE 76170
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76098: LD_VAR 0 12
76102: PUSH
76103: LD_INT 1
76105: ARRAY
76106: PPUSH
76107: CALL_OW 313
76111: PUSH
76112: LD_INT 3
76114: LESS
76115: IFFALSE 76151
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76117: LD_INT 0
76119: PPUSH
76120: LD_INT 5
76122: PUSH
76123: LD_INT 8
76125: PUSH
76126: LD_INT 9
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: LIST
76133: PUSH
76134: LD_VAR 0 17
76138: ARRAY
76139: PPUSH
76140: LD_VAR 0 4
76144: PPUSH
76145: CALL_OW 380
76149: GO 76168
// PrepareHuman ( false , i , skill ) ;
76151: LD_INT 0
76153: PPUSH
76154: LD_VAR 0 8
76158: PPUSH
76159: LD_VAR 0 4
76163: PPUSH
76164: CALL_OW 380
// end else
76168: GO 76187
// PrepareHuman ( false , i , skill ) ;
76170: LD_INT 0
76172: PPUSH
76173: LD_VAR 0 8
76177: PPUSH
76178: LD_VAR 0 4
76182: PPUSH
76183: CALL_OW 380
// un := CreateHuman ;
76187: LD_ADDR_VAR 0 14
76191: PUSH
76192: CALL_OW 44
76196: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76197: LD_ADDR_VAR 0 7
76201: PUSH
76202: LD_VAR 0 7
76206: PPUSH
76207: LD_INT 1
76209: PPUSH
76210: LD_VAR 0 14
76214: PPUSH
76215: CALL_OW 2
76219: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76220: LD_VAR 0 14
76224: PPUSH
76225: LD_VAR 0 12
76229: PUSH
76230: LD_INT 1
76232: ARRAY
76233: PPUSH
76234: CALL_OW 52
// end ;
76238: GO 75877
76240: POP
76241: POP
// end ;
76242: GO 75179
76244: POP
76245: POP
// result := result ^ buildings ;
76246: LD_ADDR_VAR 0 7
76250: PUSH
76251: LD_VAR 0 7
76255: PUSH
76256: LD_VAR 0 18
76260: ADD
76261: ST_TO_ADDR
// end else
76262: GO 76405
// begin for i = 1 to personel do
76264: LD_ADDR_VAR 0 8
76268: PUSH
76269: DOUBLE
76270: LD_INT 1
76272: DEC
76273: ST_TO_ADDR
76274: LD_VAR 0 6
76278: PUSH
76279: FOR_TO
76280: IFFALSE 76403
// begin if i > 4 then
76282: LD_VAR 0 8
76286: PUSH
76287: LD_INT 4
76289: GREATER
76290: IFFALSE 76294
// break ;
76292: GO 76403
// x := personel [ i ] ;
76294: LD_ADDR_VAR 0 13
76298: PUSH
76299: LD_VAR 0 6
76303: PUSH
76304: LD_VAR 0 8
76308: ARRAY
76309: ST_TO_ADDR
// if x = - 1 then
76310: LD_VAR 0 13
76314: PUSH
76315: LD_INT 1
76317: NEG
76318: EQUAL
76319: IFFALSE 76323
// continue ;
76321: GO 76279
// PrepareHuman ( false , i , skill ) ;
76323: LD_INT 0
76325: PPUSH
76326: LD_VAR 0 8
76330: PPUSH
76331: LD_VAR 0 4
76335: PPUSH
76336: CALL_OW 380
// un := CreateHuman ;
76340: LD_ADDR_VAR 0 14
76344: PUSH
76345: CALL_OW 44
76349: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76350: LD_VAR 0 14
76354: PPUSH
76355: LD_VAR 0 1
76359: PPUSH
76360: CALL_OW 250
76364: PPUSH
76365: LD_VAR 0 1
76369: PPUSH
76370: CALL_OW 251
76374: PPUSH
76375: LD_INT 10
76377: PPUSH
76378: LD_INT 0
76380: PPUSH
76381: CALL_OW 50
// result := result ^ un ;
76385: LD_ADDR_VAR 0 7
76389: PUSH
76390: LD_VAR 0 7
76394: PUSH
76395: LD_VAR 0 14
76399: ADD
76400: ST_TO_ADDR
// end ;
76401: GO 76279
76403: POP
76404: POP
// end ; end ;
76405: LD_VAR 0 7
76409: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76410: LD_INT 0
76412: PPUSH
76413: PPUSH
76414: PPUSH
76415: PPUSH
76416: PPUSH
76417: PPUSH
76418: PPUSH
76419: PPUSH
76420: PPUSH
76421: PPUSH
76422: PPUSH
76423: PPUSH
76424: PPUSH
76425: PPUSH
76426: PPUSH
76427: PPUSH
// result := false ;
76428: LD_ADDR_VAR 0 3
76432: PUSH
76433: LD_INT 0
76435: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76436: LD_VAR 0 1
76440: NOT
76441: PUSH
76442: LD_VAR 0 1
76446: PPUSH
76447: CALL_OW 266
76451: PUSH
76452: LD_INT 32
76454: PUSH
76455: LD_INT 33
76457: PUSH
76458: EMPTY
76459: LIST
76460: LIST
76461: IN
76462: NOT
76463: OR
76464: IFFALSE 76468
// exit ;
76466: GO 77604
// nat := GetNation ( tower ) ;
76468: LD_ADDR_VAR 0 12
76472: PUSH
76473: LD_VAR 0 1
76477: PPUSH
76478: CALL_OW 248
76482: ST_TO_ADDR
// side := GetSide ( tower ) ;
76483: LD_ADDR_VAR 0 16
76487: PUSH
76488: LD_VAR 0 1
76492: PPUSH
76493: CALL_OW 255
76497: ST_TO_ADDR
// x := GetX ( tower ) ;
76498: LD_ADDR_VAR 0 10
76502: PUSH
76503: LD_VAR 0 1
76507: PPUSH
76508: CALL_OW 250
76512: ST_TO_ADDR
// y := GetY ( tower ) ;
76513: LD_ADDR_VAR 0 11
76517: PUSH
76518: LD_VAR 0 1
76522: PPUSH
76523: CALL_OW 251
76527: ST_TO_ADDR
// if not x or not y then
76528: LD_VAR 0 10
76532: NOT
76533: PUSH
76534: LD_VAR 0 11
76538: NOT
76539: OR
76540: IFFALSE 76544
// exit ;
76542: GO 77604
// weapon := 0 ;
76544: LD_ADDR_VAR 0 18
76548: PUSH
76549: LD_INT 0
76551: ST_TO_ADDR
// fac_list := [ ] ;
76552: LD_ADDR_VAR 0 17
76556: PUSH
76557: EMPTY
76558: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76559: LD_ADDR_VAR 0 6
76563: PUSH
76564: LD_VAR 0 1
76568: PPUSH
76569: CALL_OW 274
76573: PPUSH
76574: LD_VAR 0 2
76578: PPUSH
76579: CALL 74182 0 2
76583: PPUSH
76584: LD_INT 30
76586: PUSH
76587: LD_INT 3
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PPUSH
76594: CALL_OW 72
76598: ST_TO_ADDR
// if not factories then
76599: LD_VAR 0 6
76603: NOT
76604: IFFALSE 76608
// exit ;
76606: GO 77604
// for i in factories do
76608: LD_ADDR_VAR 0 8
76612: PUSH
76613: LD_VAR 0 6
76617: PUSH
76618: FOR_IN
76619: IFFALSE 76644
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76621: LD_ADDR_VAR 0 17
76625: PUSH
76626: LD_VAR 0 17
76630: PUSH
76631: LD_VAR 0 8
76635: PPUSH
76636: CALL_OW 478
76640: UNION
76641: ST_TO_ADDR
76642: GO 76618
76644: POP
76645: POP
// if not fac_list then
76646: LD_VAR 0 17
76650: NOT
76651: IFFALSE 76655
// exit ;
76653: GO 77604
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76655: LD_ADDR_VAR 0 5
76659: PUSH
76660: LD_INT 4
76662: PUSH
76663: LD_INT 5
76665: PUSH
76666: LD_INT 9
76668: PUSH
76669: LD_INT 10
76671: PUSH
76672: LD_INT 6
76674: PUSH
76675: LD_INT 7
76677: PUSH
76678: LD_INT 11
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 27
76692: PUSH
76693: LD_INT 28
76695: PUSH
76696: LD_INT 26
76698: PUSH
76699: LD_INT 30
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 43
76710: PUSH
76711: LD_INT 44
76713: PUSH
76714: LD_INT 46
76716: PUSH
76717: LD_INT 45
76719: PUSH
76720: LD_INT 47
76722: PUSH
76723: LD_INT 49
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: LIST
76730: LIST
76731: LIST
76732: LIST
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: LIST
76738: PUSH
76739: LD_VAR 0 12
76743: ARRAY
76744: ST_TO_ADDR
// for i in list do
76745: LD_ADDR_VAR 0 8
76749: PUSH
76750: LD_VAR 0 5
76754: PUSH
76755: FOR_IN
76756: IFFALSE 76789
// if not i in fac_list then
76758: LD_VAR 0 8
76762: PUSH
76763: LD_VAR 0 17
76767: IN
76768: NOT
76769: IFFALSE 76787
// list := list diff i ;
76771: LD_ADDR_VAR 0 5
76775: PUSH
76776: LD_VAR 0 5
76780: PUSH
76781: LD_VAR 0 8
76785: DIFF
76786: ST_TO_ADDR
76787: GO 76755
76789: POP
76790: POP
// if not list then
76791: LD_VAR 0 5
76795: NOT
76796: IFFALSE 76800
// exit ;
76798: GO 77604
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76800: LD_VAR 0 12
76804: PUSH
76805: LD_INT 3
76807: EQUAL
76808: PUSH
76809: LD_INT 49
76811: PUSH
76812: LD_VAR 0 5
76816: IN
76817: AND
76818: PUSH
76819: LD_INT 31
76821: PPUSH
76822: LD_VAR 0 16
76826: PPUSH
76827: CALL_OW 321
76831: PUSH
76832: LD_INT 2
76834: EQUAL
76835: AND
76836: IFFALSE 76896
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76838: LD_INT 22
76840: PUSH
76841: LD_VAR 0 16
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 35
76852: PUSH
76853: LD_INT 49
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: LD_INT 91
76862: PUSH
76863: LD_VAR 0 1
76867: PUSH
76868: LD_INT 10
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: LIST
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: LIST
76880: PPUSH
76881: CALL_OW 69
76885: NOT
76886: IFFALSE 76896
// weapon := ru_time_lapser ;
76888: LD_ADDR_VAR 0 18
76892: PUSH
76893: LD_INT 49
76895: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76896: LD_VAR 0 12
76900: PUSH
76901: LD_INT 1
76903: PUSH
76904: LD_INT 2
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: IN
76911: PUSH
76912: LD_INT 11
76914: PUSH
76915: LD_VAR 0 5
76919: IN
76920: PUSH
76921: LD_INT 30
76923: PUSH
76924: LD_VAR 0 5
76928: IN
76929: OR
76930: AND
76931: PUSH
76932: LD_INT 6
76934: PPUSH
76935: LD_VAR 0 16
76939: PPUSH
76940: CALL_OW 321
76944: PUSH
76945: LD_INT 2
76947: EQUAL
76948: AND
76949: IFFALSE 77114
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76951: LD_INT 22
76953: PUSH
76954: LD_VAR 0 16
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: PUSH
76963: LD_INT 2
76965: PUSH
76966: LD_INT 35
76968: PUSH
76969: LD_INT 11
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: LD_INT 35
76978: PUSH
76979: LD_INT 30
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: LIST
76990: PUSH
76991: LD_INT 91
76993: PUSH
76994: LD_VAR 0 1
76998: PUSH
76999: LD_INT 18
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: LIST
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: LIST
77011: PPUSH
77012: CALL_OW 69
77016: NOT
77017: PUSH
77018: LD_INT 22
77020: PUSH
77021: LD_VAR 0 16
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 2
77032: PUSH
77033: LD_INT 30
77035: PUSH
77036: LD_INT 32
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: PUSH
77043: LD_INT 30
77045: PUSH
77046: LD_INT 33
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 91
77060: PUSH
77061: LD_VAR 0 1
77065: PUSH
77066: LD_INT 12
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: LIST
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: LIST
77078: PUSH
77079: EMPTY
77080: LIST
77081: PPUSH
77082: CALL_OW 69
77086: PUSH
77087: LD_INT 2
77089: GREATER
77090: AND
77091: IFFALSE 77114
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77093: LD_ADDR_VAR 0 18
77097: PUSH
77098: LD_INT 11
77100: PUSH
77101: LD_INT 30
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: PUSH
77108: LD_VAR 0 12
77112: ARRAY
77113: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77114: LD_VAR 0 18
77118: NOT
77119: PUSH
77120: LD_INT 40
77122: PPUSH
77123: LD_VAR 0 16
77127: PPUSH
77128: CALL_OW 321
77132: PUSH
77133: LD_INT 2
77135: EQUAL
77136: AND
77137: PUSH
77138: LD_INT 7
77140: PUSH
77141: LD_VAR 0 5
77145: IN
77146: PUSH
77147: LD_INT 28
77149: PUSH
77150: LD_VAR 0 5
77154: IN
77155: OR
77156: PUSH
77157: LD_INT 45
77159: PUSH
77160: LD_VAR 0 5
77164: IN
77165: OR
77166: AND
77167: IFFALSE 77421
// begin hex := GetHexInfo ( x , y ) ;
77169: LD_ADDR_VAR 0 4
77173: PUSH
77174: LD_VAR 0 10
77178: PPUSH
77179: LD_VAR 0 11
77183: PPUSH
77184: CALL_OW 546
77188: ST_TO_ADDR
// if hex [ 1 ] then
77189: LD_VAR 0 4
77193: PUSH
77194: LD_INT 1
77196: ARRAY
77197: IFFALSE 77201
// exit ;
77199: GO 77604
// height := hex [ 2 ] ;
77201: LD_ADDR_VAR 0 15
77205: PUSH
77206: LD_VAR 0 4
77210: PUSH
77211: LD_INT 2
77213: ARRAY
77214: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77215: LD_ADDR_VAR 0 14
77219: PUSH
77220: LD_INT 0
77222: PUSH
77223: LD_INT 2
77225: PUSH
77226: LD_INT 3
77228: PUSH
77229: LD_INT 5
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: LIST
77236: LIST
77237: ST_TO_ADDR
// for i in tmp do
77238: LD_ADDR_VAR 0 8
77242: PUSH
77243: LD_VAR 0 14
77247: PUSH
77248: FOR_IN
77249: IFFALSE 77419
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77251: LD_ADDR_VAR 0 9
77255: PUSH
77256: LD_VAR 0 10
77260: PPUSH
77261: LD_VAR 0 8
77265: PPUSH
77266: LD_INT 5
77268: PPUSH
77269: CALL_OW 272
77273: PUSH
77274: LD_VAR 0 11
77278: PPUSH
77279: LD_VAR 0 8
77283: PPUSH
77284: LD_INT 5
77286: PPUSH
77287: CALL_OW 273
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77296: LD_VAR 0 9
77300: PUSH
77301: LD_INT 1
77303: ARRAY
77304: PPUSH
77305: LD_VAR 0 9
77309: PUSH
77310: LD_INT 2
77312: ARRAY
77313: PPUSH
77314: CALL_OW 488
77318: IFFALSE 77417
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77320: LD_ADDR_VAR 0 4
77324: PUSH
77325: LD_VAR 0 9
77329: PUSH
77330: LD_INT 1
77332: ARRAY
77333: PPUSH
77334: LD_VAR 0 9
77338: PUSH
77339: LD_INT 2
77341: ARRAY
77342: PPUSH
77343: CALL_OW 546
77347: ST_TO_ADDR
// if hex [ 1 ] then
77348: LD_VAR 0 4
77352: PUSH
77353: LD_INT 1
77355: ARRAY
77356: IFFALSE 77360
// continue ;
77358: GO 77248
// h := hex [ 2 ] ;
77360: LD_ADDR_VAR 0 13
77364: PUSH
77365: LD_VAR 0 4
77369: PUSH
77370: LD_INT 2
77372: ARRAY
77373: ST_TO_ADDR
// if h + 7 < height then
77374: LD_VAR 0 13
77378: PUSH
77379: LD_INT 7
77381: PLUS
77382: PUSH
77383: LD_VAR 0 15
77387: LESS
77388: IFFALSE 77417
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77390: LD_ADDR_VAR 0 18
77394: PUSH
77395: LD_INT 7
77397: PUSH
77398: LD_INT 28
77400: PUSH
77401: LD_INT 45
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: LIST
77408: PUSH
77409: LD_VAR 0 12
77413: ARRAY
77414: ST_TO_ADDR
// break ;
77415: GO 77419
// end ; end ; end ;
77417: GO 77248
77419: POP
77420: POP
// end ; if not weapon then
77421: LD_VAR 0 18
77425: NOT
77426: IFFALSE 77486
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77428: LD_ADDR_VAR 0 5
77432: PUSH
77433: LD_VAR 0 5
77437: PUSH
77438: LD_INT 11
77440: PUSH
77441: LD_INT 30
77443: PUSH
77444: LD_INT 49
77446: PUSH
77447: EMPTY
77448: LIST
77449: LIST
77450: LIST
77451: DIFF
77452: ST_TO_ADDR
// if not list then
77453: LD_VAR 0 5
77457: NOT
77458: IFFALSE 77462
// exit ;
77460: GO 77604
// weapon := list [ rand ( 1 , list ) ] ;
77462: LD_ADDR_VAR 0 18
77466: PUSH
77467: LD_VAR 0 5
77471: PUSH
77472: LD_INT 1
77474: PPUSH
77475: LD_VAR 0 5
77479: PPUSH
77480: CALL_OW 12
77484: ARRAY
77485: ST_TO_ADDR
// end ; if weapon then
77486: LD_VAR 0 18
77490: IFFALSE 77604
// begin tmp := CostOfWeapon ( weapon ) ;
77492: LD_ADDR_VAR 0 14
77496: PUSH
77497: LD_VAR 0 18
77501: PPUSH
77502: CALL_OW 451
77506: ST_TO_ADDR
// j := GetBase ( tower ) ;
77507: LD_ADDR_VAR 0 9
77511: PUSH
77512: LD_VAR 0 1
77516: PPUSH
77517: CALL_OW 274
77521: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77522: LD_VAR 0 9
77526: PPUSH
77527: LD_INT 1
77529: PPUSH
77530: CALL_OW 275
77534: PUSH
77535: LD_VAR 0 14
77539: PUSH
77540: LD_INT 1
77542: ARRAY
77543: GREATEREQUAL
77544: PUSH
77545: LD_VAR 0 9
77549: PPUSH
77550: LD_INT 2
77552: PPUSH
77553: CALL_OW 275
77557: PUSH
77558: LD_VAR 0 14
77562: PUSH
77563: LD_INT 2
77565: ARRAY
77566: GREATEREQUAL
77567: AND
77568: PUSH
77569: LD_VAR 0 9
77573: PPUSH
77574: LD_INT 3
77576: PPUSH
77577: CALL_OW 275
77581: PUSH
77582: LD_VAR 0 14
77586: PUSH
77587: LD_INT 3
77589: ARRAY
77590: GREATEREQUAL
77591: AND
77592: IFFALSE 77604
// result := weapon ;
77594: LD_ADDR_VAR 0 3
77598: PUSH
77599: LD_VAR 0 18
77603: ST_TO_ADDR
// end ; end ;
77604: LD_VAR 0 3
77608: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77609: LD_INT 0
77611: PPUSH
77612: PPUSH
// result := true ;
77613: LD_ADDR_VAR 0 3
77617: PUSH
77618: LD_INT 1
77620: ST_TO_ADDR
// if array1 = array2 then
77621: LD_VAR 0 1
77625: PUSH
77626: LD_VAR 0 2
77630: EQUAL
77631: IFFALSE 77691
// begin for i = 1 to array1 do
77633: LD_ADDR_VAR 0 4
77637: PUSH
77638: DOUBLE
77639: LD_INT 1
77641: DEC
77642: ST_TO_ADDR
77643: LD_VAR 0 1
77647: PUSH
77648: FOR_TO
77649: IFFALSE 77687
// if array1 [ i ] <> array2 [ i ] then
77651: LD_VAR 0 1
77655: PUSH
77656: LD_VAR 0 4
77660: ARRAY
77661: PUSH
77662: LD_VAR 0 2
77666: PUSH
77667: LD_VAR 0 4
77671: ARRAY
77672: NONEQUAL
77673: IFFALSE 77685
// begin result := false ;
77675: LD_ADDR_VAR 0 3
77679: PUSH
77680: LD_INT 0
77682: ST_TO_ADDR
// break ;
77683: GO 77687
// end ;
77685: GO 77648
77687: POP
77688: POP
// end else
77689: GO 77699
// result := false ;
77691: LD_ADDR_VAR 0 3
77695: PUSH
77696: LD_INT 0
77698: ST_TO_ADDR
// end ;
77699: LD_VAR 0 3
77703: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77704: LD_INT 0
77706: PPUSH
77707: PPUSH
77708: PPUSH
// pom := GetBase ( fac ) ;
77709: LD_ADDR_VAR 0 5
77713: PUSH
77714: LD_VAR 0 1
77718: PPUSH
77719: CALL_OW 274
77723: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77724: LD_ADDR_VAR 0 4
77728: PUSH
77729: LD_VAR 0 2
77733: PUSH
77734: LD_INT 1
77736: ARRAY
77737: PPUSH
77738: LD_VAR 0 2
77742: PUSH
77743: LD_INT 2
77745: ARRAY
77746: PPUSH
77747: LD_VAR 0 2
77751: PUSH
77752: LD_INT 3
77754: ARRAY
77755: PPUSH
77756: LD_VAR 0 2
77760: PUSH
77761: LD_INT 4
77763: ARRAY
77764: PPUSH
77765: CALL_OW 449
77769: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77770: LD_ADDR_VAR 0 3
77774: PUSH
77775: LD_VAR 0 5
77779: PPUSH
77780: LD_INT 1
77782: PPUSH
77783: CALL_OW 275
77787: PUSH
77788: LD_VAR 0 4
77792: PUSH
77793: LD_INT 1
77795: ARRAY
77796: GREATEREQUAL
77797: PUSH
77798: LD_VAR 0 5
77802: PPUSH
77803: LD_INT 2
77805: PPUSH
77806: CALL_OW 275
77810: PUSH
77811: LD_VAR 0 4
77815: PUSH
77816: LD_INT 2
77818: ARRAY
77819: GREATEREQUAL
77820: AND
77821: PUSH
77822: LD_VAR 0 5
77826: PPUSH
77827: LD_INT 3
77829: PPUSH
77830: CALL_OW 275
77834: PUSH
77835: LD_VAR 0 4
77839: PUSH
77840: LD_INT 3
77842: ARRAY
77843: GREATEREQUAL
77844: AND
77845: ST_TO_ADDR
// end ;
77846: LD_VAR 0 3
77850: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77851: LD_INT 0
77853: PPUSH
77854: PPUSH
77855: PPUSH
77856: PPUSH
// pom := GetBase ( building ) ;
77857: LD_ADDR_VAR 0 3
77861: PUSH
77862: LD_VAR 0 1
77866: PPUSH
77867: CALL_OW 274
77871: ST_TO_ADDR
// if not pom then
77872: LD_VAR 0 3
77876: NOT
77877: IFFALSE 77881
// exit ;
77879: GO 78051
// btype := GetBType ( building ) ;
77881: LD_ADDR_VAR 0 5
77885: PUSH
77886: LD_VAR 0 1
77890: PPUSH
77891: CALL_OW 266
77895: ST_TO_ADDR
// if btype = b_armoury then
77896: LD_VAR 0 5
77900: PUSH
77901: LD_INT 4
77903: EQUAL
77904: IFFALSE 77914
// btype := b_barracks ;
77906: LD_ADDR_VAR 0 5
77910: PUSH
77911: LD_INT 5
77913: ST_TO_ADDR
// if btype = b_depot then
77914: LD_VAR 0 5
77918: PUSH
77919: LD_INT 0
77921: EQUAL
77922: IFFALSE 77932
// btype := b_warehouse ;
77924: LD_ADDR_VAR 0 5
77928: PUSH
77929: LD_INT 1
77931: ST_TO_ADDR
// if btype = b_workshop then
77932: LD_VAR 0 5
77936: PUSH
77937: LD_INT 2
77939: EQUAL
77940: IFFALSE 77950
// btype := b_factory ;
77942: LD_ADDR_VAR 0 5
77946: PUSH
77947: LD_INT 3
77949: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77950: LD_ADDR_VAR 0 4
77954: PUSH
77955: LD_VAR 0 5
77959: PPUSH
77960: LD_VAR 0 1
77964: PPUSH
77965: CALL_OW 248
77969: PPUSH
77970: CALL_OW 450
77974: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77975: LD_ADDR_VAR 0 2
77979: PUSH
77980: LD_VAR 0 3
77984: PPUSH
77985: LD_INT 1
77987: PPUSH
77988: CALL_OW 275
77992: PUSH
77993: LD_VAR 0 4
77997: PUSH
77998: LD_INT 1
78000: ARRAY
78001: GREATEREQUAL
78002: PUSH
78003: LD_VAR 0 3
78007: PPUSH
78008: LD_INT 2
78010: PPUSH
78011: CALL_OW 275
78015: PUSH
78016: LD_VAR 0 4
78020: PUSH
78021: LD_INT 2
78023: ARRAY
78024: GREATEREQUAL
78025: AND
78026: PUSH
78027: LD_VAR 0 3
78031: PPUSH
78032: LD_INT 3
78034: PPUSH
78035: CALL_OW 275
78039: PUSH
78040: LD_VAR 0 4
78044: PUSH
78045: LD_INT 3
78047: ARRAY
78048: GREATEREQUAL
78049: AND
78050: ST_TO_ADDR
// end ;
78051: LD_VAR 0 2
78055: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78056: LD_INT 0
78058: PPUSH
78059: PPUSH
78060: PPUSH
// pom := GetBase ( building ) ;
78061: LD_ADDR_VAR 0 4
78065: PUSH
78066: LD_VAR 0 1
78070: PPUSH
78071: CALL_OW 274
78075: ST_TO_ADDR
// if not pom then
78076: LD_VAR 0 4
78080: NOT
78081: IFFALSE 78085
// exit ;
78083: GO 78186
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78085: LD_ADDR_VAR 0 5
78089: PUSH
78090: LD_VAR 0 2
78094: PPUSH
78095: LD_VAR 0 1
78099: PPUSH
78100: CALL_OW 248
78104: PPUSH
78105: CALL_OW 450
78109: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78110: LD_ADDR_VAR 0 3
78114: PUSH
78115: LD_VAR 0 4
78119: PPUSH
78120: LD_INT 1
78122: PPUSH
78123: CALL_OW 275
78127: PUSH
78128: LD_VAR 0 5
78132: PUSH
78133: LD_INT 1
78135: ARRAY
78136: GREATEREQUAL
78137: PUSH
78138: LD_VAR 0 4
78142: PPUSH
78143: LD_INT 2
78145: PPUSH
78146: CALL_OW 275
78150: PUSH
78151: LD_VAR 0 5
78155: PUSH
78156: LD_INT 2
78158: ARRAY
78159: GREATEREQUAL
78160: AND
78161: PUSH
78162: LD_VAR 0 4
78166: PPUSH
78167: LD_INT 3
78169: PPUSH
78170: CALL_OW 275
78174: PUSH
78175: LD_VAR 0 5
78179: PUSH
78180: LD_INT 3
78182: ARRAY
78183: GREATEREQUAL
78184: AND
78185: ST_TO_ADDR
// end ;
78186: LD_VAR 0 3
78190: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78191: LD_INT 0
78193: PPUSH
78194: PPUSH
78195: PPUSH
78196: PPUSH
78197: PPUSH
78198: PPUSH
78199: PPUSH
78200: PPUSH
78201: PPUSH
78202: PPUSH
// result := false ;
78203: LD_ADDR_VAR 0 6
78207: PUSH
78208: LD_INT 0
78210: ST_TO_ADDR
// if not base or not btype or not x or not y then
78211: LD_VAR 0 1
78215: NOT
78216: PUSH
78217: LD_VAR 0 2
78221: NOT
78222: OR
78223: PUSH
78224: LD_VAR 0 3
78228: NOT
78229: OR
78230: PUSH
78231: LD_VAR 0 4
78235: NOT
78236: OR
78237: IFFALSE 78241
// exit ;
78239: GO 78850
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78241: LD_ADDR_VAR 0 12
78245: PUSH
78246: LD_VAR 0 2
78250: PPUSH
78251: LD_VAR 0 3
78255: PPUSH
78256: LD_VAR 0 4
78260: PPUSH
78261: LD_VAR 0 5
78265: PPUSH
78266: LD_VAR 0 1
78270: PUSH
78271: LD_INT 1
78273: ARRAY
78274: PPUSH
78275: CALL_OW 248
78279: PPUSH
78280: LD_INT 0
78282: PPUSH
78283: CALL 79687 0 6
78287: ST_TO_ADDR
// if not hexes then
78288: LD_VAR 0 12
78292: NOT
78293: IFFALSE 78297
// exit ;
78295: GO 78850
// for i = 1 to hexes do
78297: LD_ADDR_VAR 0 7
78301: PUSH
78302: DOUBLE
78303: LD_INT 1
78305: DEC
78306: ST_TO_ADDR
78307: LD_VAR 0 12
78311: PUSH
78312: FOR_TO
78313: IFFALSE 78848
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78315: LD_ADDR_VAR 0 11
78319: PUSH
78320: LD_VAR 0 12
78324: PUSH
78325: LD_VAR 0 7
78329: ARRAY
78330: PUSH
78331: LD_INT 1
78333: ARRAY
78334: PPUSH
78335: LD_VAR 0 12
78339: PUSH
78340: LD_VAR 0 7
78344: ARRAY
78345: PUSH
78346: LD_INT 2
78348: ARRAY
78349: PPUSH
78350: CALL_OW 428
78354: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78355: LD_VAR 0 12
78359: PUSH
78360: LD_VAR 0 7
78364: ARRAY
78365: PUSH
78366: LD_INT 1
78368: ARRAY
78369: PPUSH
78370: LD_VAR 0 12
78374: PUSH
78375: LD_VAR 0 7
78379: ARRAY
78380: PUSH
78381: LD_INT 2
78383: ARRAY
78384: PPUSH
78385: CALL_OW 351
78389: PUSH
78390: LD_VAR 0 12
78394: PUSH
78395: LD_VAR 0 7
78399: ARRAY
78400: PUSH
78401: LD_INT 1
78403: ARRAY
78404: PPUSH
78405: LD_VAR 0 12
78409: PUSH
78410: LD_VAR 0 7
78414: ARRAY
78415: PUSH
78416: LD_INT 2
78418: ARRAY
78419: PPUSH
78420: CALL_OW 488
78424: NOT
78425: OR
78426: PUSH
78427: LD_VAR 0 11
78431: PPUSH
78432: CALL_OW 247
78436: PUSH
78437: LD_INT 3
78439: EQUAL
78440: OR
78441: IFFALSE 78447
// exit ;
78443: POP
78444: POP
78445: GO 78850
// if not tmp or not tmp in base then
78447: LD_VAR 0 11
78451: NOT
78452: PUSH
78453: LD_VAR 0 11
78457: PUSH
78458: LD_VAR 0 1
78462: IN
78463: NOT
78464: OR
78465: IFFALSE 78469
// continue ;
78467: GO 78312
// result := true ;
78469: LD_ADDR_VAR 0 6
78473: PUSH
78474: LD_INT 1
78476: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78477: LD_ADDR_VAR 0 15
78481: PUSH
78482: LD_VAR 0 1
78486: PPUSH
78487: LD_INT 22
78489: PUSH
78490: LD_VAR 0 11
78494: PPUSH
78495: CALL_OW 255
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PUSH
78504: LD_INT 2
78506: PUSH
78507: LD_INT 30
78509: PUSH
78510: LD_INT 0
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 30
78519: PUSH
78520: LD_INT 1
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: LIST
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PPUSH
78536: CALL_OW 72
78540: ST_TO_ADDR
// if dep then
78541: LD_VAR 0 15
78545: IFFALSE 78681
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78547: LD_ADDR_VAR 0 14
78551: PUSH
78552: LD_VAR 0 15
78556: PUSH
78557: LD_INT 1
78559: ARRAY
78560: PPUSH
78561: CALL_OW 250
78565: PPUSH
78566: LD_VAR 0 15
78570: PUSH
78571: LD_INT 1
78573: ARRAY
78574: PPUSH
78575: CALL_OW 254
78579: PPUSH
78580: LD_INT 5
78582: PPUSH
78583: CALL_OW 272
78587: PUSH
78588: LD_VAR 0 15
78592: PUSH
78593: LD_INT 1
78595: ARRAY
78596: PPUSH
78597: CALL_OW 251
78601: PPUSH
78602: LD_VAR 0 15
78606: PUSH
78607: LD_INT 1
78609: ARRAY
78610: PPUSH
78611: CALL_OW 254
78615: PPUSH
78616: LD_INT 5
78618: PPUSH
78619: CALL_OW 273
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78628: LD_VAR 0 14
78632: PUSH
78633: LD_INT 1
78635: ARRAY
78636: PPUSH
78637: LD_VAR 0 14
78641: PUSH
78642: LD_INT 2
78644: ARRAY
78645: PPUSH
78646: CALL_OW 488
78650: IFFALSE 78681
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78652: LD_VAR 0 11
78656: PPUSH
78657: LD_VAR 0 14
78661: PUSH
78662: LD_INT 1
78664: ARRAY
78665: PPUSH
78666: LD_VAR 0 14
78670: PUSH
78671: LD_INT 2
78673: ARRAY
78674: PPUSH
78675: CALL_OW 111
// continue ;
78679: GO 78312
// end ; end ; r := GetDir ( tmp ) ;
78681: LD_ADDR_VAR 0 13
78685: PUSH
78686: LD_VAR 0 11
78690: PPUSH
78691: CALL_OW 254
78695: ST_TO_ADDR
// if r = 5 then
78696: LD_VAR 0 13
78700: PUSH
78701: LD_INT 5
78703: EQUAL
78704: IFFALSE 78714
// r := 0 ;
78706: LD_ADDR_VAR 0 13
78710: PUSH
78711: LD_INT 0
78713: ST_TO_ADDR
// for j = r to 5 do
78714: LD_ADDR_VAR 0 8
78718: PUSH
78719: DOUBLE
78720: LD_VAR 0 13
78724: DEC
78725: ST_TO_ADDR
78726: LD_INT 5
78728: PUSH
78729: FOR_TO
78730: IFFALSE 78844
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78732: LD_ADDR_VAR 0 9
78736: PUSH
78737: LD_VAR 0 11
78741: PPUSH
78742: CALL_OW 250
78746: PPUSH
78747: LD_VAR 0 8
78751: PPUSH
78752: LD_INT 2
78754: PPUSH
78755: CALL_OW 272
78759: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78760: LD_ADDR_VAR 0 10
78764: PUSH
78765: LD_VAR 0 11
78769: PPUSH
78770: CALL_OW 251
78774: PPUSH
78775: LD_VAR 0 8
78779: PPUSH
78780: LD_INT 2
78782: PPUSH
78783: CALL_OW 273
78787: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78788: LD_VAR 0 9
78792: PPUSH
78793: LD_VAR 0 10
78797: PPUSH
78798: CALL_OW 488
78802: PUSH
78803: LD_VAR 0 9
78807: PPUSH
78808: LD_VAR 0 10
78812: PPUSH
78813: CALL_OW 428
78817: NOT
78818: AND
78819: IFFALSE 78842
// begin ComMoveXY ( tmp , _x , _y ) ;
78821: LD_VAR 0 11
78825: PPUSH
78826: LD_VAR 0 9
78830: PPUSH
78831: LD_VAR 0 10
78835: PPUSH
78836: CALL_OW 111
// break ;
78840: GO 78844
// end ; end ;
78842: GO 78729
78844: POP
78845: POP
// end ;
78846: GO 78312
78848: POP
78849: POP
// end ;
78850: LD_VAR 0 6
78854: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78855: LD_INT 0
78857: PPUSH
78858: PPUSH
78859: PPUSH
78860: PPUSH
78861: PPUSH
78862: PPUSH
78863: PPUSH
78864: PPUSH
78865: PPUSH
78866: PPUSH
// result := false ;
78867: LD_ADDR_VAR 0 6
78871: PUSH
78872: LD_INT 0
78874: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78875: LD_VAR 0 1
78879: NOT
78880: PUSH
78881: LD_VAR 0 1
78885: PPUSH
78886: CALL_OW 266
78890: PUSH
78891: LD_INT 0
78893: PUSH
78894: LD_INT 1
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: IN
78901: NOT
78902: OR
78903: PUSH
78904: LD_VAR 0 2
78908: NOT
78909: OR
78910: PUSH
78911: LD_VAR 0 5
78915: PUSH
78916: LD_INT 0
78918: PUSH
78919: LD_INT 1
78921: PUSH
78922: LD_INT 2
78924: PUSH
78925: LD_INT 3
78927: PUSH
78928: LD_INT 4
78930: PUSH
78931: LD_INT 5
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: LIST
78938: LIST
78939: LIST
78940: LIST
78941: IN
78942: NOT
78943: OR
78944: PUSH
78945: LD_VAR 0 3
78949: PPUSH
78950: LD_VAR 0 4
78954: PPUSH
78955: CALL_OW 488
78959: NOT
78960: OR
78961: IFFALSE 78965
// exit ;
78963: GO 79682
// pom := GetBase ( depot ) ;
78965: LD_ADDR_VAR 0 10
78969: PUSH
78970: LD_VAR 0 1
78974: PPUSH
78975: CALL_OW 274
78979: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78980: LD_ADDR_VAR 0 11
78984: PUSH
78985: LD_VAR 0 2
78989: PPUSH
78990: LD_VAR 0 1
78994: PPUSH
78995: CALL_OW 248
78999: PPUSH
79000: CALL_OW 450
79004: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79005: LD_VAR 0 10
79009: PPUSH
79010: LD_INT 1
79012: PPUSH
79013: CALL_OW 275
79017: PUSH
79018: LD_VAR 0 11
79022: PUSH
79023: LD_INT 1
79025: ARRAY
79026: GREATEREQUAL
79027: PUSH
79028: LD_VAR 0 10
79032: PPUSH
79033: LD_INT 2
79035: PPUSH
79036: CALL_OW 275
79040: PUSH
79041: LD_VAR 0 11
79045: PUSH
79046: LD_INT 2
79048: ARRAY
79049: GREATEREQUAL
79050: AND
79051: PUSH
79052: LD_VAR 0 10
79056: PPUSH
79057: LD_INT 3
79059: PPUSH
79060: CALL_OW 275
79064: PUSH
79065: LD_VAR 0 11
79069: PUSH
79070: LD_INT 3
79072: ARRAY
79073: GREATEREQUAL
79074: AND
79075: NOT
79076: IFFALSE 79080
// exit ;
79078: GO 79682
// if GetBType ( depot ) = b_depot then
79080: LD_VAR 0 1
79084: PPUSH
79085: CALL_OW 266
79089: PUSH
79090: LD_INT 0
79092: EQUAL
79093: IFFALSE 79105
// dist := 28 else
79095: LD_ADDR_VAR 0 14
79099: PUSH
79100: LD_INT 28
79102: ST_TO_ADDR
79103: GO 79113
// dist := 36 ;
79105: LD_ADDR_VAR 0 14
79109: PUSH
79110: LD_INT 36
79112: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79113: LD_VAR 0 1
79117: PPUSH
79118: LD_VAR 0 3
79122: PPUSH
79123: LD_VAR 0 4
79127: PPUSH
79128: CALL_OW 297
79132: PUSH
79133: LD_VAR 0 14
79137: GREATER
79138: IFFALSE 79142
// exit ;
79140: GO 79682
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79142: LD_ADDR_VAR 0 12
79146: PUSH
79147: LD_VAR 0 2
79151: PPUSH
79152: LD_VAR 0 3
79156: PPUSH
79157: LD_VAR 0 4
79161: PPUSH
79162: LD_VAR 0 5
79166: PPUSH
79167: LD_VAR 0 1
79171: PPUSH
79172: CALL_OW 248
79176: PPUSH
79177: LD_INT 0
79179: PPUSH
79180: CALL 79687 0 6
79184: ST_TO_ADDR
// if not hexes then
79185: LD_VAR 0 12
79189: NOT
79190: IFFALSE 79194
// exit ;
79192: GO 79682
// hex := GetHexInfo ( x , y ) ;
79194: LD_ADDR_VAR 0 15
79198: PUSH
79199: LD_VAR 0 3
79203: PPUSH
79204: LD_VAR 0 4
79208: PPUSH
79209: CALL_OW 546
79213: ST_TO_ADDR
// if hex [ 1 ] then
79214: LD_VAR 0 15
79218: PUSH
79219: LD_INT 1
79221: ARRAY
79222: IFFALSE 79226
// exit ;
79224: GO 79682
// height := hex [ 2 ] ;
79226: LD_ADDR_VAR 0 13
79230: PUSH
79231: LD_VAR 0 15
79235: PUSH
79236: LD_INT 2
79238: ARRAY
79239: ST_TO_ADDR
// for i = 1 to hexes do
79240: LD_ADDR_VAR 0 7
79244: PUSH
79245: DOUBLE
79246: LD_INT 1
79248: DEC
79249: ST_TO_ADDR
79250: LD_VAR 0 12
79254: PUSH
79255: FOR_TO
79256: IFFALSE 79586
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79258: LD_VAR 0 12
79262: PUSH
79263: LD_VAR 0 7
79267: ARRAY
79268: PUSH
79269: LD_INT 1
79271: ARRAY
79272: PPUSH
79273: LD_VAR 0 12
79277: PUSH
79278: LD_VAR 0 7
79282: ARRAY
79283: PUSH
79284: LD_INT 2
79286: ARRAY
79287: PPUSH
79288: CALL_OW 488
79292: NOT
79293: PUSH
79294: LD_VAR 0 12
79298: PUSH
79299: LD_VAR 0 7
79303: ARRAY
79304: PUSH
79305: LD_INT 1
79307: ARRAY
79308: PPUSH
79309: LD_VAR 0 12
79313: PUSH
79314: LD_VAR 0 7
79318: ARRAY
79319: PUSH
79320: LD_INT 2
79322: ARRAY
79323: PPUSH
79324: CALL_OW 428
79328: PUSH
79329: LD_INT 0
79331: GREATER
79332: OR
79333: PUSH
79334: LD_VAR 0 12
79338: PUSH
79339: LD_VAR 0 7
79343: ARRAY
79344: PUSH
79345: LD_INT 1
79347: ARRAY
79348: PPUSH
79349: LD_VAR 0 12
79353: PUSH
79354: LD_VAR 0 7
79358: ARRAY
79359: PUSH
79360: LD_INT 2
79362: ARRAY
79363: PPUSH
79364: CALL_OW 351
79368: OR
79369: IFFALSE 79375
// exit ;
79371: POP
79372: POP
79373: GO 79682
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79375: LD_ADDR_VAR 0 8
79379: PUSH
79380: LD_VAR 0 12
79384: PUSH
79385: LD_VAR 0 7
79389: ARRAY
79390: PUSH
79391: LD_INT 1
79393: ARRAY
79394: PPUSH
79395: LD_VAR 0 12
79399: PUSH
79400: LD_VAR 0 7
79404: ARRAY
79405: PUSH
79406: LD_INT 2
79408: ARRAY
79409: PPUSH
79410: CALL_OW 546
79414: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79415: LD_VAR 0 8
79419: PUSH
79420: LD_INT 1
79422: ARRAY
79423: PUSH
79424: LD_VAR 0 8
79428: PUSH
79429: LD_INT 2
79431: ARRAY
79432: PUSH
79433: LD_VAR 0 13
79437: PUSH
79438: LD_INT 2
79440: PLUS
79441: GREATER
79442: OR
79443: PUSH
79444: LD_VAR 0 8
79448: PUSH
79449: LD_INT 2
79451: ARRAY
79452: PUSH
79453: LD_VAR 0 13
79457: PUSH
79458: LD_INT 2
79460: MINUS
79461: LESS
79462: OR
79463: PUSH
79464: LD_VAR 0 8
79468: PUSH
79469: LD_INT 3
79471: ARRAY
79472: PUSH
79473: LD_INT 0
79475: PUSH
79476: LD_INT 8
79478: PUSH
79479: LD_INT 9
79481: PUSH
79482: LD_INT 10
79484: PUSH
79485: LD_INT 11
79487: PUSH
79488: LD_INT 12
79490: PUSH
79491: LD_INT 13
79493: PUSH
79494: LD_INT 16
79496: PUSH
79497: LD_INT 17
79499: PUSH
79500: LD_INT 18
79502: PUSH
79503: LD_INT 19
79505: PUSH
79506: LD_INT 20
79508: PUSH
79509: LD_INT 21
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: LIST
79526: IN
79527: NOT
79528: OR
79529: PUSH
79530: LD_VAR 0 8
79534: PUSH
79535: LD_INT 5
79537: ARRAY
79538: NOT
79539: OR
79540: PUSH
79541: LD_VAR 0 8
79545: PUSH
79546: LD_INT 6
79548: ARRAY
79549: PUSH
79550: LD_INT 1
79552: PUSH
79553: LD_INT 2
79555: PUSH
79556: LD_INT 7
79558: PUSH
79559: LD_INT 9
79561: PUSH
79562: LD_INT 10
79564: PUSH
79565: LD_INT 11
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: LIST
79572: LIST
79573: LIST
79574: LIST
79575: IN
79576: NOT
79577: OR
79578: IFFALSE 79584
// exit ;
79580: POP
79581: POP
79582: GO 79682
// end ;
79584: GO 79255
79586: POP
79587: POP
// side := GetSide ( depot ) ;
79588: LD_ADDR_VAR 0 9
79592: PUSH
79593: LD_VAR 0 1
79597: PPUSH
79598: CALL_OW 255
79602: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79603: LD_VAR 0 9
79607: PPUSH
79608: LD_VAR 0 3
79612: PPUSH
79613: LD_VAR 0 4
79617: PPUSH
79618: LD_INT 20
79620: PPUSH
79621: CALL 72336 0 4
79625: PUSH
79626: LD_INT 4
79628: ARRAY
79629: IFFALSE 79633
// exit ;
79631: GO 79682
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79633: LD_VAR 0 2
79637: PUSH
79638: LD_INT 29
79640: PUSH
79641: LD_INT 30
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: IN
79648: PUSH
79649: LD_VAR 0 3
79653: PPUSH
79654: LD_VAR 0 4
79658: PPUSH
79659: LD_VAR 0 9
79663: PPUSH
79664: CALL_OW 440
79668: NOT
79669: AND
79670: IFFALSE 79674
// exit ;
79672: GO 79682
// result := true ;
79674: LD_ADDR_VAR 0 6
79678: PUSH
79679: LD_INT 1
79681: ST_TO_ADDR
// end ;
79682: LD_VAR 0 6
79686: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79687: LD_INT 0
79689: PPUSH
79690: PPUSH
79691: PPUSH
79692: PPUSH
79693: PPUSH
79694: PPUSH
79695: PPUSH
79696: PPUSH
79697: PPUSH
79698: PPUSH
79699: PPUSH
79700: PPUSH
79701: PPUSH
79702: PPUSH
79703: PPUSH
79704: PPUSH
79705: PPUSH
79706: PPUSH
79707: PPUSH
79708: PPUSH
79709: PPUSH
79710: PPUSH
79711: PPUSH
79712: PPUSH
79713: PPUSH
79714: PPUSH
79715: PPUSH
79716: PPUSH
79717: PPUSH
79718: PPUSH
79719: PPUSH
79720: PPUSH
79721: PPUSH
79722: PPUSH
79723: PPUSH
79724: PPUSH
79725: PPUSH
79726: PPUSH
79727: PPUSH
79728: PPUSH
79729: PPUSH
79730: PPUSH
79731: PPUSH
79732: PPUSH
79733: PPUSH
79734: PPUSH
79735: PPUSH
79736: PPUSH
79737: PPUSH
79738: PPUSH
79739: PPUSH
79740: PPUSH
79741: PPUSH
79742: PPUSH
79743: PPUSH
79744: PPUSH
79745: PPUSH
79746: PPUSH
// result = [ ] ;
79747: LD_ADDR_VAR 0 7
79751: PUSH
79752: EMPTY
79753: ST_TO_ADDR
// temp_list = [ ] ;
79754: LD_ADDR_VAR 0 9
79758: PUSH
79759: EMPTY
79760: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79761: LD_VAR 0 4
79765: PUSH
79766: LD_INT 0
79768: PUSH
79769: LD_INT 1
79771: PUSH
79772: LD_INT 2
79774: PUSH
79775: LD_INT 3
79777: PUSH
79778: LD_INT 4
79780: PUSH
79781: LD_INT 5
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: LIST
79788: LIST
79789: LIST
79790: LIST
79791: IN
79792: NOT
79793: PUSH
79794: LD_VAR 0 1
79798: PUSH
79799: LD_INT 0
79801: PUSH
79802: LD_INT 1
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: IN
79809: PUSH
79810: LD_VAR 0 5
79814: PUSH
79815: LD_INT 1
79817: PUSH
79818: LD_INT 2
79820: PUSH
79821: LD_INT 3
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: LIST
79828: IN
79829: NOT
79830: AND
79831: OR
79832: IFFALSE 79836
// exit ;
79834: GO 98227
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79836: LD_VAR 0 1
79840: PUSH
79841: LD_INT 6
79843: PUSH
79844: LD_INT 7
79846: PUSH
79847: LD_INT 8
79849: PUSH
79850: LD_INT 13
79852: PUSH
79853: LD_INT 12
79855: PUSH
79856: LD_INT 15
79858: PUSH
79859: LD_INT 11
79861: PUSH
79862: LD_INT 14
79864: PUSH
79865: LD_INT 10
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: IN
79879: IFFALSE 79889
// btype = b_lab ;
79881: LD_ADDR_VAR 0 1
79885: PUSH
79886: LD_INT 6
79888: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79889: LD_VAR 0 6
79893: PUSH
79894: LD_INT 0
79896: PUSH
79897: LD_INT 1
79899: PUSH
79900: LD_INT 2
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: LIST
79907: IN
79908: NOT
79909: PUSH
79910: LD_VAR 0 1
79914: PUSH
79915: LD_INT 0
79917: PUSH
79918: LD_INT 1
79920: PUSH
79921: LD_INT 2
79923: PUSH
79924: LD_INT 3
79926: PUSH
79927: LD_INT 6
79929: PUSH
79930: LD_INT 36
79932: PUSH
79933: LD_INT 4
79935: PUSH
79936: LD_INT 5
79938: PUSH
79939: LD_INT 31
79941: PUSH
79942: LD_INT 32
79944: PUSH
79945: LD_INT 33
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: LIST
79952: LIST
79953: LIST
79954: LIST
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: IN
79961: NOT
79962: PUSH
79963: LD_VAR 0 6
79967: PUSH
79968: LD_INT 1
79970: EQUAL
79971: AND
79972: OR
79973: PUSH
79974: LD_VAR 0 1
79978: PUSH
79979: LD_INT 2
79981: PUSH
79982: LD_INT 3
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: IN
79989: NOT
79990: PUSH
79991: LD_VAR 0 6
79995: PUSH
79996: LD_INT 2
79998: EQUAL
79999: AND
80000: OR
80001: IFFALSE 80011
// mode = 0 ;
80003: LD_ADDR_VAR 0 6
80007: PUSH
80008: LD_INT 0
80010: ST_TO_ADDR
// case mode of 0 :
80011: LD_VAR 0 6
80015: PUSH
80016: LD_INT 0
80018: DOUBLE
80019: EQUAL
80020: IFTRUE 80024
80022: GO 91477
80024: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80025: LD_ADDR_VAR 0 11
80029: PUSH
80030: LD_INT 0
80032: PUSH
80033: LD_INT 0
80035: PUSH
80036: EMPTY
80037: LIST
80038: LIST
80039: PUSH
80040: LD_INT 0
80042: PUSH
80043: LD_INT 1
80045: NEG
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: LD_INT 1
80053: PUSH
80054: LD_INT 0
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 1
80063: PUSH
80064: LD_INT 1
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 0
80073: PUSH
80074: LD_INT 1
80076: PUSH
80077: EMPTY
80078: LIST
80079: LIST
80080: PUSH
80081: LD_INT 1
80083: NEG
80084: PUSH
80085: LD_INT 0
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: LD_INT 1
80094: NEG
80095: PUSH
80096: LD_INT 1
80098: NEG
80099: PUSH
80100: EMPTY
80101: LIST
80102: LIST
80103: PUSH
80104: LD_INT 1
80106: NEG
80107: PUSH
80108: LD_INT 2
80110: NEG
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 0
80118: PUSH
80119: LD_INT 2
80121: NEG
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PUSH
80127: LD_INT 1
80129: PUSH
80130: LD_INT 1
80132: NEG
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 1
80140: PUSH
80141: LD_INT 2
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: LD_INT 0
80150: PUSH
80151: LD_INT 2
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 1
80160: NEG
80161: PUSH
80162: LD_INT 1
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: LD_INT 1
80171: PUSH
80172: LD_INT 3
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 0
80181: PUSH
80182: LD_INT 3
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: PUSH
80189: LD_INT 1
80191: NEG
80192: PUSH
80193: LD_INT 2
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: LIST
80204: LIST
80205: LIST
80206: LIST
80207: LIST
80208: LIST
80209: LIST
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80218: LD_ADDR_VAR 0 12
80222: PUSH
80223: LD_INT 0
80225: PUSH
80226: LD_INT 0
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 0
80235: PUSH
80236: LD_INT 1
80238: NEG
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 1
80246: PUSH
80247: LD_INT 0
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: PUSH
80254: LD_INT 1
80256: PUSH
80257: LD_INT 1
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: PUSH
80264: LD_INT 0
80266: PUSH
80267: LD_INT 1
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 1
80276: NEG
80277: PUSH
80278: LD_INT 0
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 1
80287: NEG
80288: PUSH
80289: LD_INT 1
80291: NEG
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 1
80299: PUSH
80300: LD_INT 1
80302: NEG
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 2
80310: PUSH
80311: LD_INT 0
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 2
80320: PUSH
80321: LD_INT 1
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 1
80330: NEG
80331: PUSH
80332: LD_INT 1
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 2
80341: NEG
80342: PUSH
80343: LD_INT 0
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 2
80352: NEG
80353: PUSH
80354: LD_INT 1
80356: NEG
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 2
80364: NEG
80365: PUSH
80366: LD_INT 1
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PUSH
80373: LD_INT 3
80375: NEG
80376: PUSH
80377: LD_INT 0
80379: PUSH
80380: EMPTY
80381: LIST
80382: LIST
80383: PUSH
80384: LD_INT 3
80386: NEG
80387: PUSH
80388: LD_INT 1
80390: NEG
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: EMPTY
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80414: LD_ADDR_VAR 0 13
80418: PUSH
80419: LD_INT 0
80421: PUSH
80422: LD_INT 0
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: PUSH
80429: LD_INT 0
80431: PUSH
80432: LD_INT 1
80434: NEG
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: LD_INT 1
80442: PUSH
80443: LD_INT 0
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: PUSH
80450: LD_INT 1
80452: PUSH
80453: LD_INT 1
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: PUSH
80460: LD_INT 0
80462: PUSH
80463: LD_INT 1
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 1
80472: NEG
80473: PUSH
80474: LD_INT 0
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 1
80483: NEG
80484: PUSH
80485: LD_INT 1
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 1
80495: NEG
80496: PUSH
80497: LD_INT 2
80499: NEG
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 2
80507: PUSH
80508: LD_INT 1
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 2
80517: PUSH
80518: LD_INT 2
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 1
80527: PUSH
80528: LD_INT 2
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 2
80537: NEG
80538: PUSH
80539: LD_INT 1
80541: NEG
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 2
80549: NEG
80550: PUSH
80551: LD_INT 2
80553: NEG
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 2
80561: NEG
80562: PUSH
80563: LD_INT 3
80565: NEG
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 3
80573: NEG
80574: PUSH
80575: LD_INT 2
80577: NEG
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 3
80585: NEG
80586: PUSH
80587: LD_INT 3
80589: NEG
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80613: LD_ADDR_VAR 0 14
80617: PUSH
80618: LD_INT 0
80620: PUSH
80621: LD_INT 0
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 0
80630: PUSH
80631: LD_INT 1
80633: NEG
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PUSH
80639: LD_INT 1
80641: PUSH
80642: LD_INT 0
80644: PUSH
80645: EMPTY
80646: LIST
80647: LIST
80648: PUSH
80649: LD_INT 1
80651: PUSH
80652: LD_INT 1
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 0
80661: PUSH
80662: LD_INT 1
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 1
80671: NEG
80672: PUSH
80673: LD_INT 0
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 1
80682: NEG
80683: PUSH
80684: LD_INT 1
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 1
80694: NEG
80695: PUSH
80696: LD_INT 2
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 0
80706: PUSH
80707: LD_INT 2
80709: NEG
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: LD_INT 1
80717: PUSH
80718: LD_INT 1
80720: NEG
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 1
80728: PUSH
80729: LD_INT 2
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 0
80738: PUSH
80739: LD_INT 2
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: LD_INT 1
80748: NEG
80749: PUSH
80750: LD_INT 1
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: LD_INT 1
80759: NEG
80760: PUSH
80761: LD_INT 3
80763: NEG
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 0
80771: PUSH
80772: LD_INT 3
80774: NEG
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 1
80782: PUSH
80783: LD_INT 2
80785: NEG
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: LIST
80795: LIST
80796: LIST
80797: LIST
80798: LIST
80799: LIST
80800: LIST
80801: LIST
80802: LIST
80803: LIST
80804: LIST
80805: LIST
80806: LIST
80807: LIST
80808: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80809: LD_ADDR_VAR 0 15
80813: PUSH
80814: LD_INT 0
80816: PUSH
80817: LD_INT 0
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 0
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 1
80837: PUSH
80838: LD_INT 0
80840: PUSH
80841: EMPTY
80842: LIST
80843: LIST
80844: PUSH
80845: LD_INT 1
80847: PUSH
80848: LD_INT 1
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PUSH
80855: LD_INT 0
80857: PUSH
80858: LD_INT 1
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 1
80867: NEG
80868: PUSH
80869: LD_INT 0
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 1
80878: NEG
80879: PUSH
80880: LD_INT 1
80882: NEG
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 1
80890: PUSH
80891: LD_INT 1
80893: NEG
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 2
80901: PUSH
80902: LD_INT 0
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 2
80911: PUSH
80912: LD_INT 1
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: LD_INT 1
80921: NEG
80922: PUSH
80923: LD_INT 1
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 2
80932: NEG
80933: PUSH
80934: LD_INT 0
80936: PUSH
80937: EMPTY
80938: LIST
80939: LIST
80940: PUSH
80941: LD_INT 2
80943: NEG
80944: PUSH
80945: LD_INT 1
80947: NEG
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: LD_INT 2
80955: PUSH
80956: LD_INT 1
80958: NEG
80959: PUSH
80960: EMPTY
80961: LIST
80962: LIST
80963: PUSH
80964: LD_INT 3
80966: PUSH
80967: LD_INT 0
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 3
80976: PUSH
80977: LD_INT 1
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81002: LD_ADDR_VAR 0 16
81006: PUSH
81007: LD_INT 0
81009: PUSH
81010: LD_INT 0
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 0
81019: PUSH
81020: LD_INT 1
81022: NEG
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 1
81030: PUSH
81031: LD_INT 0
81033: PUSH
81034: EMPTY
81035: LIST
81036: LIST
81037: PUSH
81038: LD_INT 1
81040: PUSH
81041: LD_INT 1
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: LD_INT 0
81050: PUSH
81051: LD_INT 1
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 1
81060: NEG
81061: PUSH
81062: LD_INT 0
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 1
81071: NEG
81072: PUSH
81073: LD_INT 1
81075: NEG
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 1
81083: NEG
81084: PUSH
81085: LD_INT 2
81087: NEG
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 2
81095: PUSH
81096: LD_INT 1
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 2
81105: PUSH
81106: LD_INT 2
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 1
81115: PUSH
81116: LD_INT 2
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 2
81125: NEG
81126: PUSH
81127: LD_INT 1
81129: NEG
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 2
81137: NEG
81138: PUSH
81139: LD_INT 2
81141: NEG
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: LD_INT 3
81149: PUSH
81150: LD_INT 2
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 3
81159: PUSH
81160: LD_INT 3
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 2
81169: PUSH
81170: LD_INT 3
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81195: LD_ADDR_VAR 0 17
81199: PUSH
81200: LD_INT 0
81202: PUSH
81203: LD_INT 0
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 0
81212: PUSH
81213: LD_INT 1
81215: NEG
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 1
81223: PUSH
81224: LD_INT 0
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 1
81233: PUSH
81234: LD_INT 1
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PUSH
81241: LD_INT 0
81243: PUSH
81244: LD_INT 1
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PUSH
81251: LD_INT 1
81253: NEG
81254: PUSH
81255: LD_INT 0
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PUSH
81262: LD_INT 1
81264: NEG
81265: PUSH
81266: LD_INT 1
81268: NEG
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 1
81276: NEG
81277: PUSH
81278: LD_INT 2
81280: NEG
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 0
81288: PUSH
81289: LD_INT 2
81291: NEG
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 1
81299: PUSH
81300: LD_INT 1
81302: NEG
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 2
81310: PUSH
81311: LD_INT 0
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 2
81320: PUSH
81321: LD_INT 1
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 2
81330: PUSH
81331: LD_INT 2
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 1
81340: PUSH
81341: LD_INT 2
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 0
81350: PUSH
81351: LD_INT 2
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: LD_INT 1
81360: NEG
81361: PUSH
81362: LD_INT 1
81364: PUSH
81365: EMPTY
81366: LIST
81367: LIST
81368: PUSH
81369: LD_INT 2
81371: NEG
81372: PUSH
81373: LD_INT 0
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 2
81382: NEG
81383: PUSH
81384: LD_INT 1
81386: NEG
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: PUSH
81392: LD_INT 2
81394: NEG
81395: PUSH
81396: LD_INT 2
81398: NEG
81399: PUSH
81400: EMPTY
81401: LIST
81402: LIST
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81425: LD_ADDR_VAR 0 18
81429: PUSH
81430: LD_INT 0
81432: PUSH
81433: LD_INT 0
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: LD_INT 0
81442: PUSH
81443: LD_INT 1
81445: NEG
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 1
81453: PUSH
81454: LD_INT 0
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 1
81463: PUSH
81464: LD_INT 1
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 0
81473: PUSH
81474: LD_INT 1
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 1
81483: NEG
81484: PUSH
81485: LD_INT 0
81487: PUSH
81488: EMPTY
81489: LIST
81490: LIST
81491: PUSH
81492: LD_INT 1
81494: NEG
81495: PUSH
81496: LD_INT 1
81498: NEG
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 1
81506: NEG
81507: PUSH
81508: LD_INT 2
81510: NEG
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: LD_INT 0
81518: PUSH
81519: LD_INT 2
81521: NEG
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: PUSH
81527: LD_INT 1
81529: PUSH
81530: LD_INT 1
81532: NEG
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: PUSH
81538: LD_INT 2
81540: PUSH
81541: LD_INT 0
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: PUSH
81548: LD_INT 2
81550: PUSH
81551: LD_INT 1
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 2
81560: PUSH
81561: LD_INT 2
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: PUSH
81568: LD_INT 1
81570: PUSH
81571: LD_INT 2
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: LD_INT 0
81580: PUSH
81581: LD_INT 2
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: PUSH
81588: LD_INT 1
81590: NEG
81591: PUSH
81592: LD_INT 1
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 2
81601: NEG
81602: PUSH
81603: LD_INT 0
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 2
81612: NEG
81613: PUSH
81614: LD_INT 1
81616: NEG
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: PUSH
81622: LD_INT 2
81624: NEG
81625: PUSH
81626: LD_INT 2
81628: NEG
81629: PUSH
81630: EMPTY
81631: LIST
81632: LIST
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81655: LD_ADDR_VAR 0 19
81659: PUSH
81660: LD_INT 0
81662: PUSH
81663: LD_INT 0
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 0
81672: PUSH
81673: LD_INT 1
81675: NEG
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 1
81683: PUSH
81684: LD_INT 0
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: PUSH
81691: LD_INT 1
81693: PUSH
81694: LD_INT 1
81696: PUSH
81697: EMPTY
81698: LIST
81699: LIST
81700: PUSH
81701: LD_INT 0
81703: PUSH
81704: LD_INT 1
81706: PUSH
81707: EMPTY
81708: LIST
81709: LIST
81710: PUSH
81711: LD_INT 1
81713: NEG
81714: PUSH
81715: LD_INT 0
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: PUSH
81722: LD_INT 1
81724: NEG
81725: PUSH
81726: LD_INT 1
81728: NEG
81729: PUSH
81730: EMPTY
81731: LIST
81732: LIST
81733: PUSH
81734: LD_INT 1
81736: NEG
81737: PUSH
81738: LD_INT 2
81740: NEG
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 0
81748: PUSH
81749: LD_INT 2
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 1
81759: PUSH
81760: LD_INT 1
81762: NEG
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 2
81770: PUSH
81771: LD_INT 0
81773: PUSH
81774: EMPTY
81775: LIST
81776: LIST
81777: PUSH
81778: LD_INT 2
81780: PUSH
81781: LD_INT 1
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 2
81790: PUSH
81791: LD_INT 2
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: PUSH
81798: LD_INT 1
81800: PUSH
81801: LD_INT 2
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 0
81810: PUSH
81811: LD_INT 2
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 1
81820: NEG
81821: PUSH
81822: LD_INT 1
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 2
81831: NEG
81832: PUSH
81833: LD_INT 0
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 2
81842: NEG
81843: PUSH
81844: LD_INT 1
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 2
81854: NEG
81855: PUSH
81856: LD_INT 2
81858: NEG
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: LIST
81868: LIST
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: LIST
81874: LIST
81875: LIST
81876: LIST
81877: LIST
81878: LIST
81879: LIST
81880: LIST
81881: LIST
81882: LIST
81883: LIST
81884: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81885: LD_ADDR_VAR 0 20
81889: PUSH
81890: LD_INT 0
81892: PUSH
81893: LD_INT 0
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: PUSH
81900: LD_INT 0
81902: PUSH
81903: LD_INT 1
81905: NEG
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 1
81913: PUSH
81914: LD_INT 0
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 1
81923: PUSH
81924: LD_INT 1
81926: PUSH
81927: EMPTY
81928: LIST
81929: LIST
81930: PUSH
81931: LD_INT 0
81933: PUSH
81934: LD_INT 1
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 1
81943: NEG
81944: PUSH
81945: LD_INT 0
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: PUSH
81952: LD_INT 1
81954: NEG
81955: PUSH
81956: LD_INT 1
81958: NEG
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 1
81966: NEG
81967: PUSH
81968: LD_INT 2
81970: NEG
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: LD_INT 0
81978: PUSH
81979: LD_INT 2
81981: NEG
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 1
81989: PUSH
81990: LD_INT 1
81992: NEG
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 2
82000: PUSH
82001: LD_INT 0
82003: PUSH
82004: EMPTY
82005: LIST
82006: LIST
82007: PUSH
82008: LD_INT 2
82010: PUSH
82011: LD_INT 1
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: PUSH
82018: LD_INT 2
82020: PUSH
82021: LD_INT 2
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: PUSH
82028: LD_INT 1
82030: PUSH
82031: LD_INT 2
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 0
82040: PUSH
82041: LD_INT 2
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 1
82050: NEG
82051: PUSH
82052: LD_INT 1
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 2
82061: NEG
82062: PUSH
82063: LD_INT 0
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 2
82072: NEG
82073: PUSH
82074: LD_INT 1
82076: NEG
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 2
82084: NEG
82085: PUSH
82086: LD_INT 2
82088: NEG
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: LIST
82104: LIST
82105: LIST
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82115: LD_ADDR_VAR 0 21
82119: PUSH
82120: LD_INT 0
82122: PUSH
82123: LD_INT 0
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 0
82132: PUSH
82133: LD_INT 1
82135: NEG
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: LD_INT 1
82143: PUSH
82144: LD_INT 0
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 1
82153: PUSH
82154: LD_INT 1
82156: PUSH
82157: EMPTY
82158: LIST
82159: LIST
82160: PUSH
82161: LD_INT 0
82163: PUSH
82164: LD_INT 1
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: LD_INT 0
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 1
82184: NEG
82185: PUSH
82186: LD_INT 1
82188: NEG
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 1
82196: NEG
82197: PUSH
82198: LD_INT 2
82200: NEG
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 0
82208: PUSH
82209: LD_INT 2
82211: NEG
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 1
82219: PUSH
82220: LD_INT 1
82222: NEG
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: PUSH
82228: LD_INT 2
82230: PUSH
82231: LD_INT 0
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 2
82240: PUSH
82241: LD_INT 1
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 2
82250: PUSH
82251: LD_INT 2
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 1
82260: PUSH
82261: LD_INT 2
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PUSH
82268: LD_INT 0
82270: PUSH
82271: LD_INT 2
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 1
82280: NEG
82281: PUSH
82282: LD_INT 1
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 2
82291: NEG
82292: PUSH
82293: LD_INT 0
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 2
82302: NEG
82303: PUSH
82304: LD_INT 1
82306: NEG
82307: PUSH
82308: EMPTY
82309: LIST
82310: LIST
82311: PUSH
82312: LD_INT 2
82314: NEG
82315: PUSH
82316: LD_INT 2
82318: NEG
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82345: LD_ADDR_VAR 0 22
82349: PUSH
82350: LD_INT 0
82352: PUSH
82353: LD_INT 0
82355: PUSH
82356: EMPTY
82357: LIST
82358: LIST
82359: PUSH
82360: LD_INT 0
82362: PUSH
82363: LD_INT 1
82365: NEG
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: PUSH
82371: LD_INT 1
82373: PUSH
82374: LD_INT 0
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 1
82383: PUSH
82384: LD_INT 1
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PUSH
82391: LD_INT 0
82393: PUSH
82394: LD_INT 1
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: PUSH
82401: LD_INT 1
82403: NEG
82404: PUSH
82405: LD_INT 0
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: LD_INT 1
82414: NEG
82415: PUSH
82416: LD_INT 1
82418: NEG
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 1
82426: NEG
82427: PUSH
82428: LD_INT 2
82430: NEG
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: LD_INT 2
82441: NEG
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 1
82449: PUSH
82450: LD_INT 1
82452: NEG
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PUSH
82458: LD_INT 2
82460: PUSH
82461: LD_INT 0
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 2
82470: PUSH
82471: LD_INT 1
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 2
82480: PUSH
82481: LD_INT 2
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 1
82490: PUSH
82491: LD_INT 2
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 0
82500: PUSH
82501: LD_INT 2
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 1
82510: NEG
82511: PUSH
82512: LD_INT 1
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 2
82521: NEG
82522: PUSH
82523: LD_INT 0
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 2
82532: NEG
82533: PUSH
82534: LD_INT 1
82536: NEG
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: PUSH
82542: LD_INT 2
82544: NEG
82545: PUSH
82546: LD_INT 2
82548: NEG
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82575: LD_ADDR_VAR 0 23
82579: PUSH
82580: LD_INT 0
82582: PUSH
82583: LD_INT 0
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 0
82592: PUSH
82593: LD_INT 1
82595: NEG
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: PUSH
82601: LD_INT 1
82603: PUSH
82604: LD_INT 0
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 1
82613: PUSH
82614: LD_INT 1
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: PUSH
82621: LD_INT 0
82623: PUSH
82624: LD_INT 1
82626: PUSH
82627: EMPTY
82628: LIST
82629: LIST
82630: PUSH
82631: LD_INT 1
82633: NEG
82634: PUSH
82635: LD_INT 0
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: PUSH
82642: LD_INT 1
82644: NEG
82645: PUSH
82646: LD_INT 1
82648: NEG
82649: PUSH
82650: EMPTY
82651: LIST
82652: LIST
82653: PUSH
82654: LD_INT 1
82656: NEG
82657: PUSH
82658: LD_INT 2
82660: NEG
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_INT 0
82668: PUSH
82669: LD_INT 2
82671: NEG
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: PUSH
82677: LD_INT 1
82679: PUSH
82680: LD_INT 1
82682: NEG
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: PUSH
82688: LD_INT 2
82690: PUSH
82691: LD_INT 0
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 2
82700: PUSH
82701: LD_INT 1
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: PUSH
82708: LD_INT 2
82710: PUSH
82711: LD_INT 2
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 1
82720: PUSH
82721: LD_INT 2
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: LD_INT 0
82730: PUSH
82731: LD_INT 2
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 1
82740: NEG
82741: PUSH
82742: LD_INT 1
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 2
82751: NEG
82752: PUSH
82753: LD_INT 0
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 2
82762: NEG
82763: PUSH
82764: LD_INT 1
82766: NEG
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 2
82774: NEG
82775: PUSH
82776: LD_INT 2
82778: NEG
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 2
82786: NEG
82787: PUSH
82788: LD_INT 3
82790: NEG
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 1
82798: NEG
82799: PUSH
82800: LD_INT 3
82802: NEG
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: LD_INT 1
82810: PUSH
82811: LD_INT 2
82813: NEG
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 2
82821: PUSH
82822: LD_INT 1
82824: NEG
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82855: LD_ADDR_VAR 0 24
82859: PUSH
82860: LD_INT 0
82862: PUSH
82863: LD_INT 0
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 0
82872: PUSH
82873: LD_INT 1
82875: NEG
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 1
82883: PUSH
82884: LD_INT 0
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 1
82893: PUSH
82894: LD_INT 1
82896: PUSH
82897: EMPTY
82898: LIST
82899: LIST
82900: PUSH
82901: LD_INT 0
82903: PUSH
82904: LD_INT 1
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 1
82913: NEG
82914: PUSH
82915: LD_INT 0
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 1
82924: NEG
82925: PUSH
82926: LD_INT 1
82928: NEG
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 1
82936: NEG
82937: PUSH
82938: LD_INT 2
82940: NEG
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 0
82948: PUSH
82949: LD_INT 2
82951: NEG
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 1
82959: PUSH
82960: LD_INT 1
82962: NEG
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 2
82970: PUSH
82971: LD_INT 0
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 2
82980: PUSH
82981: LD_INT 1
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 2
82990: PUSH
82991: LD_INT 2
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 1
83000: PUSH
83001: LD_INT 2
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: PUSH
83008: LD_INT 0
83010: PUSH
83011: LD_INT 2
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 1
83020: NEG
83021: PUSH
83022: LD_INT 1
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 2
83031: NEG
83032: PUSH
83033: LD_INT 0
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 2
83042: NEG
83043: PUSH
83044: LD_INT 1
83046: NEG
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: LD_INT 2
83054: NEG
83055: PUSH
83056: LD_INT 2
83058: NEG
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 1
83066: PUSH
83067: LD_INT 2
83069: NEG
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 2
83077: PUSH
83078: LD_INT 1
83080: NEG
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 3
83088: PUSH
83089: LD_INT 1
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 3
83098: PUSH
83099: LD_INT 2
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83131: LD_ADDR_VAR 0 25
83135: PUSH
83136: LD_INT 0
83138: PUSH
83139: LD_INT 0
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 0
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 1
83159: PUSH
83160: LD_INT 0
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 1
83169: PUSH
83170: LD_INT 1
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: LD_INT 0
83179: PUSH
83180: LD_INT 1
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 1
83189: NEG
83190: PUSH
83191: LD_INT 0
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: PUSH
83198: LD_INT 1
83200: NEG
83201: PUSH
83202: LD_INT 1
83204: NEG
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 1
83212: NEG
83213: PUSH
83214: LD_INT 2
83216: NEG
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PUSH
83222: LD_INT 0
83224: PUSH
83225: LD_INT 2
83227: NEG
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 1
83235: PUSH
83236: LD_INT 1
83238: NEG
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: LD_INT 2
83246: PUSH
83247: LD_INT 0
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: PUSH
83254: LD_INT 2
83256: PUSH
83257: LD_INT 1
83259: PUSH
83260: EMPTY
83261: LIST
83262: LIST
83263: PUSH
83264: LD_INT 2
83266: PUSH
83267: LD_INT 2
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 1
83276: PUSH
83277: LD_INT 2
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 0
83286: PUSH
83287: LD_INT 2
83289: PUSH
83290: EMPTY
83291: LIST
83292: LIST
83293: PUSH
83294: LD_INT 1
83296: NEG
83297: PUSH
83298: LD_INT 1
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: PUSH
83305: LD_INT 2
83307: NEG
83308: PUSH
83309: LD_INT 0
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 2
83318: NEG
83319: PUSH
83320: LD_INT 1
83322: NEG
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 2
83330: NEG
83331: PUSH
83332: LD_INT 2
83334: NEG
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 3
83342: PUSH
83343: LD_INT 1
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: PUSH
83350: LD_INT 3
83352: PUSH
83353: LD_INT 2
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 2
83362: PUSH
83363: LD_INT 3
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PUSH
83370: LD_INT 1
83372: PUSH
83373: LD_INT 3
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: PUSH
83380: EMPTY
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83405: LD_ADDR_VAR 0 26
83409: PUSH
83410: LD_INT 0
83412: PUSH
83413: LD_INT 0
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 0
83422: PUSH
83423: LD_INT 1
83425: NEG
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: PUSH
83431: LD_INT 1
83433: PUSH
83434: LD_INT 0
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: PUSH
83441: LD_INT 1
83443: PUSH
83444: LD_INT 1
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 0
83453: PUSH
83454: LD_INT 1
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PUSH
83461: LD_INT 1
83463: NEG
83464: PUSH
83465: LD_INT 0
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 1
83474: NEG
83475: PUSH
83476: LD_INT 1
83478: NEG
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 1
83486: NEG
83487: PUSH
83488: LD_INT 2
83490: NEG
83491: PUSH
83492: EMPTY
83493: LIST
83494: LIST
83495: PUSH
83496: LD_INT 0
83498: PUSH
83499: LD_INT 2
83501: NEG
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_INT 1
83509: PUSH
83510: LD_INT 1
83512: NEG
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: PUSH
83518: LD_INT 2
83520: PUSH
83521: LD_INT 0
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 2
83530: PUSH
83531: LD_INT 1
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 2
83540: PUSH
83541: LD_INT 2
83543: PUSH
83544: EMPTY
83545: LIST
83546: LIST
83547: PUSH
83548: LD_INT 1
83550: PUSH
83551: LD_INT 2
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 0
83560: PUSH
83561: LD_INT 2
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 1
83570: NEG
83571: PUSH
83572: LD_INT 1
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 2
83581: NEG
83582: PUSH
83583: LD_INT 0
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 2
83592: NEG
83593: PUSH
83594: LD_INT 1
83596: NEG
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 2
83604: NEG
83605: PUSH
83606: LD_INT 2
83608: NEG
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: PUSH
83614: LD_INT 2
83616: PUSH
83617: LD_INT 3
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 1
83626: PUSH
83627: LD_INT 3
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_INT 1
83636: NEG
83637: PUSH
83638: LD_INT 2
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PUSH
83645: LD_INT 2
83647: NEG
83648: PUSH
83649: LD_INT 1
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: LIST
83669: LIST
83670: LIST
83671: LIST
83672: LIST
83673: LIST
83674: LIST
83675: LIST
83676: LIST
83677: LIST
83678: LIST
83679: LIST
83680: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83681: LD_ADDR_VAR 0 27
83685: PUSH
83686: LD_INT 0
83688: PUSH
83689: LD_INT 0
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: LD_INT 0
83698: PUSH
83699: LD_INT 1
83701: NEG
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 1
83709: PUSH
83710: LD_INT 0
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 1
83719: PUSH
83720: LD_INT 1
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 0
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: EMPTY
83734: LIST
83735: LIST
83736: PUSH
83737: LD_INT 1
83739: NEG
83740: PUSH
83741: LD_INT 0
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: PUSH
83748: LD_INT 1
83750: NEG
83751: PUSH
83752: LD_INT 1
83754: NEG
83755: PUSH
83756: EMPTY
83757: LIST
83758: LIST
83759: PUSH
83760: LD_INT 1
83762: NEG
83763: PUSH
83764: LD_INT 2
83766: NEG
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 0
83774: PUSH
83775: LD_INT 2
83777: NEG
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 1
83785: PUSH
83786: LD_INT 1
83788: NEG
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 2
83796: PUSH
83797: LD_INT 0
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: LD_INT 2
83806: PUSH
83807: LD_INT 1
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 2
83816: PUSH
83817: LD_INT 2
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 1
83826: PUSH
83827: LD_INT 2
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 0
83836: PUSH
83837: LD_INT 2
83839: PUSH
83840: EMPTY
83841: LIST
83842: LIST
83843: PUSH
83844: LD_INT 1
83846: NEG
83847: PUSH
83848: LD_INT 1
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 2
83857: NEG
83858: PUSH
83859: LD_INT 0
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 2
83868: NEG
83869: PUSH
83870: LD_INT 1
83872: NEG
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 2
83880: NEG
83881: PUSH
83882: LD_INT 2
83884: NEG
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 1
83892: NEG
83893: PUSH
83894: LD_INT 2
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 2
83903: NEG
83904: PUSH
83905: LD_INT 1
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 3
83914: NEG
83915: PUSH
83916: LD_INT 1
83918: NEG
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: LD_INT 3
83926: NEG
83927: PUSH
83928: LD_INT 2
83930: NEG
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: EMPTY
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83961: LD_ADDR_VAR 0 28
83965: PUSH
83966: LD_INT 0
83968: PUSH
83969: LD_INT 0
83971: PUSH
83972: EMPTY
83973: LIST
83974: LIST
83975: PUSH
83976: LD_INT 0
83978: PUSH
83979: LD_INT 1
83981: NEG
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: LD_INT 0
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 1
83999: PUSH
84000: LD_INT 1
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: PUSH
84007: LD_INT 0
84009: PUSH
84010: LD_INT 1
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 1
84019: NEG
84020: PUSH
84021: LD_INT 0
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: PUSH
84028: LD_INT 1
84030: NEG
84031: PUSH
84032: LD_INT 1
84034: NEG
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 1
84042: NEG
84043: PUSH
84044: LD_INT 2
84046: NEG
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 0
84054: PUSH
84055: LD_INT 2
84057: NEG
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 1
84065: PUSH
84066: LD_INT 1
84068: NEG
84069: PUSH
84070: EMPTY
84071: LIST
84072: LIST
84073: PUSH
84074: LD_INT 2
84076: PUSH
84077: LD_INT 0
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: PUSH
84084: LD_INT 2
84086: PUSH
84087: LD_INT 1
84089: PUSH
84090: EMPTY
84091: LIST
84092: LIST
84093: PUSH
84094: LD_INT 2
84096: PUSH
84097: LD_INT 2
84099: PUSH
84100: EMPTY
84101: LIST
84102: LIST
84103: PUSH
84104: LD_INT 1
84106: PUSH
84107: LD_INT 2
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: LD_INT 0
84116: PUSH
84117: LD_INT 2
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: PUSH
84124: LD_INT 1
84126: NEG
84127: PUSH
84128: LD_INT 1
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: PUSH
84135: LD_INT 2
84137: NEG
84138: PUSH
84139: LD_INT 0
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 2
84148: NEG
84149: PUSH
84150: LD_INT 1
84152: NEG
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PUSH
84158: LD_INT 2
84160: NEG
84161: PUSH
84162: LD_INT 2
84164: NEG
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: PUSH
84170: LD_INT 2
84172: NEG
84173: PUSH
84174: LD_INT 3
84176: NEG
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: PUSH
84182: LD_INT 1
84184: NEG
84185: PUSH
84186: LD_INT 3
84188: NEG
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 3
84196: NEG
84197: PUSH
84198: LD_INT 1
84200: NEG
84201: PUSH
84202: EMPTY
84203: LIST
84204: LIST
84205: PUSH
84206: LD_INT 3
84208: NEG
84209: PUSH
84210: LD_INT 2
84212: NEG
84213: PUSH
84214: EMPTY
84215: LIST
84216: LIST
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84243: LD_ADDR_VAR 0 29
84247: PUSH
84248: LD_INT 0
84250: PUSH
84251: LD_INT 0
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PUSH
84258: LD_INT 0
84260: PUSH
84261: LD_INT 1
84263: NEG
84264: PUSH
84265: EMPTY
84266: LIST
84267: LIST
84268: PUSH
84269: LD_INT 1
84271: PUSH
84272: LD_INT 0
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 1
84281: PUSH
84282: LD_INT 1
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_INT 0
84291: PUSH
84292: LD_INT 1
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: PUSH
84299: LD_INT 1
84301: NEG
84302: PUSH
84303: LD_INT 0
84305: PUSH
84306: EMPTY
84307: LIST
84308: LIST
84309: PUSH
84310: LD_INT 1
84312: NEG
84313: PUSH
84314: LD_INT 1
84316: NEG
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: PUSH
84322: LD_INT 1
84324: NEG
84325: PUSH
84326: LD_INT 2
84328: NEG
84329: PUSH
84330: EMPTY
84331: LIST
84332: LIST
84333: PUSH
84334: LD_INT 0
84336: PUSH
84337: LD_INT 2
84339: NEG
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 1
84347: PUSH
84348: LD_INT 1
84350: NEG
84351: PUSH
84352: EMPTY
84353: LIST
84354: LIST
84355: PUSH
84356: LD_INT 2
84358: PUSH
84359: LD_INT 0
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: PUSH
84366: LD_INT 2
84368: PUSH
84369: LD_INT 1
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 1
84378: PUSH
84379: LD_INT 2
84381: PUSH
84382: EMPTY
84383: LIST
84384: LIST
84385: PUSH
84386: LD_INT 0
84388: PUSH
84389: LD_INT 2
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: PUSH
84396: LD_INT 1
84398: NEG
84399: PUSH
84400: LD_INT 1
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: PUSH
84407: LD_INT 2
84409: NEG
84410: PUSH
84411: LD_INT 1
84413: NEG
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 2
84421: NEG
84422: PUSH
84423: LD_INT 2
84425: NEG
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: PUSH
84431: LD_INT 2
84433: NEG
84434: PUSH
84435: LD_INT 3
84437: NEG
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: PUSH
84443: LD_INT 2
84445: PUSH
84446: LD_INT 1
84448: NEG
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: PUSH
84454: LD_INT 3
84456: PUSH
84457: LD_INT 1
84459: PUSH
84460: EMPTY
84461: LIST
84462: LIST
84463: PUSH
84464: LD_INT 1
84466: PUSH
84467: LD_INT 3
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: LD_INT 1
84476: NEG
84477: PUSH
84478: LD_INT 2
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 3
84487: NEG
84488: PUSH
84489: LD_INT 2
84491: NEG
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84522: LD_ADDR_VAR 0 30
84526: PUSH
84527: LD_INT 0
84529: PUSH
84530: LD_INT 0
84532: PUSH
84533: EMPTY
84534: LIST
84535: LIST
84536: PUSH
84537: LD_INT 0
84539: PUSH
84540: LD_INT 1
84542: NEG
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: PUSH
84548: LD_INT 1
84550: PUSH
84551: LD_INT 0
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: LD_INT 1
84560: PUSH
84561: LD_INT 1
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: PUSH
84568: LD_INT 0
84570: PUSH
84571: LD_INT 1
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: LD_INT 1
84580: NEG
84581: PUSH
84582: LD_INT 0
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: PUSH
84589: LD_INT 1
84591: NEG
84592: PUSH
84593: LD_INT 1
84595: NEG
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 1
84603: NEG
84604: PUSH
84605: LD_INT 2
84607: NEG
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 0
84615: PUSH
84616: LD_INT 2
84618: NEG
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 1
84626: PUSH
84627: LD_INT 1
84629: NEG
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: PUSH
84635: LD_INT 2
84637: PUSH
84638: LD_INT 0
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 2
84647: PUSH
84648: LD_INT 1
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: PUSH
84655: LD_INT 2
84657: PUSH
84658: LD_INT 2
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 1
84667: PUSH
84668: LD_INT 2
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 1
84677: NEG
84678: PUSH
84679: LD_INT 1
84681: PUSH
84682: EMPTY
84683: LIST
84684: LIST
84685: PUSH
84686: LD_INT 2
84688: NEG
84689: PUSH
84690: LD_INT 0
84692: PUSH
84693: EMPTY
84694: LIST
84695: LIST
84696: PUSH
84697: LD_INT 2
84699: NEG
84700: PUSH
84701: LD_INT 1
84703: NEG
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: LD_INT 1
84711: NEG
84712: PUSH
84713: LD_INT 3
84715: NEG
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 1
84723: PUSH
84724: LD_INT 2
84726: NEG
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 3
84734: PUSH
84735: LD_INT 2
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: PUSH
84742: LD_INT 2
84744: PUSH
84745: LD_INT 3
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 2
84754: NEG
84755: PUSH
84756: LD_INT 1
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 3
84765: NEG
84766: PUSH
84767: LD_INT 1
84769: NEG
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: LIST
84782: LIST
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: LIST
84789: LIST
84790: LIST
84791: LIST
84792: LIST
84793: LIST
84794: LIST
84795: LIST
84796: LIST
84797: LIST
84798: LIST
84799: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84800: LD_ADDR_VAR 0 31
84804: PUSH
84805: LD_INT 0
84807: PUSH
84808: LD_INT 0
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: LD_INT 0
84817: PUSH
84818: LD_INT 1
84820: NEG
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 1
84828: PUSH
84829: LD_INT 0
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 1
84838: PUSH
84839: LD_INT 1
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 0
84848: PUSH
84849: LD_INT 1
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: LD_INT 1
84858: NEG
84859: PUSH
84860: LD_INT 0
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: PUSH
84867: LD_INT 1
84869: NEG
84870: PUSH
84871: LD_INT 1
84873: NEG
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: LD_INT 1
84881: NEG
84882: PUSH
84883: LD_INT 2
84885: NEG
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: LD_INT 1
84893: PUSH
84894: LD_INT 1
84896: NEG
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: LD_INT 2
84904: PUSH
84905: LD_INT 0
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: PUSH
84912: LD_INT 2
84914: PUSH
84915: LD_INT 1
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 2
84924: PUSH
84925: LD_INT 2
84927: PUSH
84928: EMPTY
84929: LIST
84930: LIST
84931: PUSH
84932: LD_INT 1
84934: PUSH
84935: LD_INT 2
84937: PUSH
84938: EMPTY
84939: LIST
84940: LIST
84941: PUSH
84942: LD_INT 0
84944: PUSH
84945: LD_INT 2
84947: PUSH
84948: EMPTY
84949: LIST
84950: LIST
84951: PUSH
84952: LD_INT 1
84954: NEG
84955: PUSH
84956: LD_INT 1
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: PUSH
84963: LD_INT 2
84965: NEG
84966: PUSH
84967: LD_INT 1
84969: NEG
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 2
84977: NEG
84978: PUSH
84979: LD_INT 2
84981: NEG
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 2
84989: NEG
84990: PUSH
84991: LD_INT 3
84993: NEG
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 2
85001: PUSH
85002: LD_INT 1
85004: NEG
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 3
85012: PUSH
85013: LD_INT 1
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: LD_INT 1
85022: PUSH
85023: LD_INT 3
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 1
85032: NEG
85033: PUSH
85034: LD_INT 2
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 3
85043: NEG
85044: PUSH
85045: LD_INT 2
85047: NEG
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85078: LD_ADDR_VAR 0 32
85082: PUSH
85083: LD_INT 0
85085: PUSH
85086: LD_INT 0
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 0
85095: PUSH
85096: LD_INT 1
85098: NEG
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: PUSH
85104: LD_INT 1
85106: PUSH
85107: LD_INT 0
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 1
85116: PUSH
85117: LD_INT 1
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 0
85126: PUSH
85127: LD_INT 1
85129: PUSH
85130: EMPTY
85131: LIST
85132: LIST
85133: PUSH
85134: LD_INT 1
85136: NEG
85137: PUSH
85138: LD_INT 0
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 1
85147: NEG
85148: PUSH
85149: LD_INT 1
85151: NEG
85152: PUSH
85153: EMPTY
85154: LIST
85155: LIST
85156: PUSH
85157: LD_INT 1
85159: NEG
85160: PUSH
85161: LD_INT 2
85163: NEG
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 0
85171: PUSH
85172: LD_INT 2
85174: NEG
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 1
85182: PUSH
85183: LD_INT 1
85185: NEG
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: LD_INT 2
85193: PUSH
85194: LD_INT 1
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_INT 2
85203: PUSH
85204: LD_INT 2
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 1
85213: PUSH
85214: LD_INT 2
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 0
85223: PUSH
85224: LD_INT 2
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 1
85233: NEG
85234: PUSH
85235: LD_INT 1
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 2
85244: NEG
85245: PUSH
85246: LD_INT 0
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 2
85255: NEG
85256: PUSH
85257: LD_INT 1
85259: NEG
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 1
85267: NEG
85268: PUSH
85269: LD_INT 3
85271: NEG
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: LD_INT 1
85279: PUSH
85280: LD_INT 2
85282: NEG
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 3
85290: PUSH
85291: LD_INT 2
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: LD_INT 2
85300: PUSH
85301: LD_INT 3
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: PUSH
85308: LD_INT 2
85310: NEG
85311: PUSH
85312: LD_INT 1
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 3
85321: NEG
85322: PUSH
85323: LD_INT 1
85325: NEG
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: EMPTY
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85356: LD_ADDR_VAR 0 33
85360: PUSH
85361: LD_INT 0
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: LD_INT 0
85373: PUSH
85374: LD_INT 1
85376: NEG
85377: PUSH
85378: EMPTY
85379: LIST
85380: LIST
85381: PUSH
85382: LD_INT 1
85384: PUSH
85385: LD_INT 0
85387: PUSH
85388: EMPTY
85389: LIST
85390: LIST
85391: PUSH
85392: LD_INT 1
85394: PUSH
85395: LD_INT 1
85397: PUSH
85398: EMPTY
85399: LIST
85400: LIST
85401: PUSH
85402: LD_INT 0
85404: PUSH
85405: LD_INT 1
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_INT 1
85414: NEG
85415: PUSH
85416: LD_INT 0
85418: PUSH
85419: EMPTY
85420: LIST
85421: LIST
85422: PUSH
85423: LD_INT 1
85425: NEG
85426: PUSH
85427: LD_INT 1
85429: NEG
85430: PUSH
85431: EMPTY
85432: LIST
85433: LIST
85434: PUSH
85435: LD_INT 1
85437: NEG
85438: PUSH
85439: LD_INT 2
85441: NEG
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: PUSH
85447: LD_INT 1
85449: PUSH
85450: LD_INT 1
85452: NEG
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 2
85460: PUSH
85461: LD_INT 0
85463: PUSH
85464: EMPTY
85465: LIST
85466: LIST
85467: PUSH
85468: LD_INT 2
85470: PUSH
85471: LD_INT 1
85473: PUSH
85474: EMPTY
85475: LIST
85476: LIST
85477: PUSH
85478: LD_INT 1
85480: PUSH
85481: LD_INT 2
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: LD_INT 0
85490: PUSH
85491: LD_INT 2
85493: PUSH
85494: EMPTY
85495: LIST
85496: LIST
85497: PUSH
85498: LD_INT 1
85500: NEG
85501: PUSH
85502: LD_INT 1
85504: PUSH
85505: EMPTY
85506: LIST
85507: LIST
85508: PUSH
85509: LD_INT 2
85511: NEG
85512: PUSH
85513: LD_INT 0
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: PUSH
85520: LD_INT 2
85522: NEG
85523: PUSH
85524: LD_INT 1
85526: NEG
85527: PUSH
85528: EMPTY
85529: LIST
85530: LIST
85531: PUSH
85532: LD_INT 2
85534: NEG
85535: PUSH
85536: LD_INT 2
85538: NEG
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: PUSH
85544: LD_INT 2
85546: NEG
85547: PUSH
85548: LD_INT 3
85550: NEG
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: PUSH
85556: LD_INT 2
85558: PUSH
85559: LD_INT 1
85561: NEG
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: PUSH
85567: LD_INT 3
85569: PUSH
85570: LD_INT 1
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: PUSH
85577: LD_INT 1
85579: PUSH
85580: LD_INT 3
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: LD_INT 1
85589: NEG
85590: PUSH
85591: LD_INT 2
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: PUSH
85598: LD_INT 3
85600: NEG
85601: PUSH
85602: LD_INT 2
85604: NEG
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: PUSH
85610: EMPTY
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85635: LD_ADDR_VAR 0 34
85639: PUSH
85640: LD_INT 0
85642: PUSH
85643: LD_INT 0
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: LD_INT 1
85655: NEG
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: PUSH
85661: LD_INT 1
85663: PUSH
85664: LD_INT 0
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 1
85673: PUSH
85674: LD_INT 1
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 0
85683: PUSH
85684: LD_INT 1
85686: PUSH
85687: EMPTY
85688: LIST
85689: LIST
85690: PUSH
85691: LD_INT 1
85693: NEG
85694: PUSH
85695: LD_INT 0
85697: PUSH
85698: EMPTY
85699: LIST
85700: LIST
85701: PUSH
85702: LD_INT 1
85704: NEG
85705: PUSH
85706: LD_INT 1
85708: NEG
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: PUSH
85714: LD_INT 1
85716: NEG
85717: PUSH
85718: LD_INT 2
85720: NEG
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 0
85728: PUSH
85729: LD_INT 2
85731: NEG
85732: PUSH
85733: EMPTY
85734: LIST
85735: LIST
85736: PUSH
85737: LD_INT 1
85739: PUSH
85740: LD_INT 1
85742: NEG
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 2
85750: PUSH
85751: LD_INT 1
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 2
85760: PUSH
85761: LD_INT 2
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 1
85770: PUSH
85771: LD_INT 2
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: PUSH
85778: LD_INT 1
85780: NEG
85781: PUSH
85782: LD_INT 1
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: PUSH
85789: LD_INT 2
85791: NEG
85792: PUSH
85793: LD_INT 0
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 2
85802: NEG
85803: PUSH
85804: LD_INT 1
85806: NEG
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 2
85814: NEG
85815: PUSH
85816: LD_INT 2
85818: NEG
85819: PUSH
85820: EMPTY
85821: LIST
85822: LIST
85823: PUSH
85824: LD_INT 1
85826: NEG
85827: PUSH
85828: LD_INT 3
85830: NEG
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 1
85838: PUSH
85839: LD_INT 2
85841: NEG
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 3
85849: PUSH
85850: LD_INT 2
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 2
85859: PUSH
85860: LD_INT 3
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 2
85869: NEG
85870: PUSH
85871: LD_INT 1
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: PUSH
85878: LD_INT 3
85880: NEG
85881: PUSH
85882: LD_INT 1
85884: NEG
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: LIST
85905: LIST
85906: LIST
85907: LIST
85908: LIST
85909: LIST
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85915: LD_ADDR_VAR 0 35
85919: PUSH
85920: LD_INT 0
85922: PUSH
85923: LD_INT 0
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: PUSH
85930: LD_INT 0
85932: PUSH
85933: LD_INT 1
85935: NEG
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 1
85943: PUSH
85944: LD_INT 0
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 1
85953: PUSH
85954: LD_INT 1
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 0
85963: PUSH
85964: LD_INT 1
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 1
85973: NEG
85974: PUSH
85975: LD_INT 0
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 1
85984: NEG
85985: PUSH
85986: LD_INT 1
85988: NEG
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 2
85996: PUSH
85997: LD_INT 1
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: LD_INT 2
86006: NEG
86007: PUSH
86008: LD_INT 1
86010: NEG
86011: PUSH
86012: EMPTY
86013: LIST
86014: LIST
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: LIST
86020: LIST
86021: LIST
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86027: LD_ADDR_VAR 0 36
86031: PUSH
86032: LD_INT 0
86034: PUSH
86035: LD_INT 0
86037: PUSH
86038: EMPTY
86039: LIST
86040: LIST
86041: PUSH
86042: LD_INT 0
86044: PUSH
86045: LD_INT 1
86047: NEG
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 1
86055: PUSH
86056: LD_INT 0
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 1
86065: PUSH
86066: LD_INT 1
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 0
86075: PUSH
86076: LD_INT 1
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 1
86085: NEG
86086: PUSH
86087: LD_INT 0
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: LD_INT 1
86096: NEG
86097: PUSH
86098: LD_INT 1
86100: NEG
86101: PUSH
86102: EMPTY
86103: LIST
86104: LIST
86105: PUSH
86106: LD_INT 1
86108: NEG
86109: PUSH
86110: LD_INT 2
86112: NEG
86113: PUSH
86114: EMPTY
86115: LIST
86116: LIST
86117: PUSH
86118: LD_INT 1
86120: PUSH
86121: LD_INT 2
86123: PUSH
86124: EMPTY
86125: LIST
86126: LIST
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: LIST
86132: LIST
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86139: LD_ADDR_VAR 0 37
86143: PUSH
86144: LD_INT 0
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PUSH
86154: LD_INT 0
86156: PUSH
86157: LD_INT 1
86159: NEG
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 1
86167: PUSH
86168: LD_INT 0
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: LD_INT 1
86177: PUSH
86178: LD_INT 1
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: PUSH
86185: LD_INT 0
86187: PUSH
86188: LD_INT 1
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: PUSH
86195: LD_INT 1
86197: NEG
86198: PUSH
86199: LD_INT 0
86201: PUSH
86202: EMPTY
86203: LIST
86204: LIST
86205: PUSH
86206: LD_INT 1
86208: NEG
86209: PUSH
86210: LD_INT 1
86212: NEG
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: PUSH
86218: LD_INT 1
86220: PUSH
86221: LD_INT 1
86223: NEG
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 1
86231: NEG
86232: PUSH
86233: LD_INT 1
86235: PUSH
86236: EMPTY
86237: LIST
86238: LIST
86239: PUSH
86240: EMPTY
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86251: LD_ADDR_VAR 0 38
86255: PUSH
86256: LD_INT 0
86258: PUSH
86259: LD_INT 0
86261: PUSH
86262: EMPTY
86263: LIST
86264: LIST
86265: PUSH
86266: LD_INT 0
86268: PUSH
86269: LD_INT 1
86271: NEG
86272: PUSH
86273: EMPTY
86274: LIST
86275: LIST
86276: PUSH
86277: LD_INT 1
86279: PUSH
86280: LD_INT 0
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: PUSH
86287: LD_INT 1
86289: PUSH
86290: LD_INT 1
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: LD_INT 0
86299: PUSH
86300: LD_INT 1
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PUSH
86307: LD_INT 1
86309: NEG
86310: PUSH
86311: LD_INT 0
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: PUSH
86318: LD_INT 1
86320: NEG
86321: PUSH
86322: LD_INT 1
86324: NEG
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: PUSH
86330: LD_INT 2
86332: PUSH
86333: LD_INT 1
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: PUSH
86340: LD_INT 2
86342: NEG
86343: PUSH
86344: LD_INT 1
86346: NEG
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: PUSH
86352: EMPTY
86353: LIST
86354: LIST
86355: LIST
86356: LIST
86357: LIST
86358: LIST
86359: LIST
86360: LIST
86361: LIST
86362: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86363: LD_ADDR_VAR 0 39
86367: PUSH
86368: LD_INT 0
86370: PUSH
86371: LD_INT 0
86373: PUSH
86374: EMPTY
86375: LIST
86376: LIST
86377: PUSH
86378: LD_INT 0
86380: PUSH
86381: LD_INT 1
86383: NEG
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: LD_INT 1
86391: PUSH
86392: LD_INT 0
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: LD_INT 1
86401: PUSH
86402: LD_INT 1
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 0
86411: PUSH
86412: LD_INT 1
86414: PUSH
86415: EMPTY
86416: LIST
86417: LIST
86418: PUSH
86419: LD_INT 1
86421: NEG
86422: PUSH
86423: LD_INT 0
86425: PUSH
86426: EMPTY
86427: LIST
86428: LIST
86429: PUSH
86430: LD_INT 1
86432: NEG
86433: PUSH
86434: LD_INT 1
86436: NEG
86437: PUSH
86438: EMPTY
86439: LIST
86440: LIST
86441: PUSH
86442: LD_INT 1
86444: NEG
86445: PUSH
86446: LD_INT 2
86448: NEG
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: PUSH
86454: LD_INT 1
86456: PUSH
86457: LD_INT 2
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86475: LD_ADDR_VAR 0 40
86479: PUSH
86480: LD_INT 0
86482: PUSH
86483: LD_INT 0
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 0
86492: PUSH
86493: LD_INT 1
86495: NEG
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: LD_INT 1
86503: PUSH
86504: LD_INT 0
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: PUSH
86511: LD_INT 1
86513: PUSH
86514: LD_INT 1
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 0
86523: PUSH
86524: LD_INT 1
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: LD_INT 1
86533: NEG
86534: PUSH
86535: LD_INT 0
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 1
86544: NEG
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 1
86556: PUSH
86557: LD_INT 1
86559: NEG
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 1
86567: NEG
86568: PUSH
86569: LD_INT 1
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86587: LD_ADDR_VAR 0 41
86591: PUSH
86592: LD_INT 0
86594: PUSH
86595: LD_INT 0
86597: PUSH
86598: EMPTY
86599: LIST
86600: LIST
86601: PUSH
86602: LD_INT 0
86604: PUSH
86605: LD_INT 1
86607: NEG
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 1
86615: PUSH
86616: LD_INT 0
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 1
86625: PUSH
86626: LD_INT 1
86628: PUSH
86629: EMPTY
86630: LIST
86631: LIST
86632: PUSH
86633: LD_INT 0
86635: PUSH
86636: LD_INT 1
86638: PUSH
86639: EMPTY
86640: LIST
86641: LIST
86642: PUSH
86643: LD_INT 1
86645: NEG
86646: PUSH
86647: LD_INT 0
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: PUSH
86654: LD_INT 1
86656: NEG
86657: PUSH
86658: LD_INT 1
86660: NEG
86661: PUSH
86662: EMPTY
86663: LIST
86664: LIST
86665: PUSH
86666: LD_INT 1
86668: NEG
86669: PUSH
86670: LD_INT 2
86672: NEG
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: PUSH
86678: LD_INT 1
86680: PUSH
86681: LD_INT 1
86683: NEG
86684: PUSH
86685: EMPTY
86686: LIST
86687: LIST
86688: PUSH
86689: LD_INT 2
86691: PUSH
86692: LD_INT 0
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 2
86701: PUSH
86702: LD_INT 1
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PUSH
86709: LD_INT 2
86711: PUSH
86712: LD_INT 2
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 1
86721: PUSH
86722: LD_INT 2
86724: PUSH
86725: EMPTY
86726: LIST
86727: LIST
86728: PUSH
86729: LD_INT 1
86731: NEG
86732: PUSH
86733: LD_INT 1
86735: PUSH
86736: EMPTY
86737: LIST
86738: LIST
86739: PUSH
86740: LD_INT 2
86742: NEG
86743: PUSH
86744: LD_INT 0
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: PUSH
86751: LD_INT 2
86753: NEG
86754: PUSH
86755: LD_INT 1
86757: NEG
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 2
86765: NEG
86766: PUSH
86767: LD_INT 2
86769: NEG
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 2
86777: NEG
86778: PUSH
86779: LD_INT 3
86781: NEG
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: LD_INT 2
86789: PUSH
86790: LD_INT 1
86792: NEG
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: PUSH
86798: LD_INT 3
86800: PUSH
86801: LD_INT 0
86803: PUSH
86804: EMPTY
86805: LIST
86806: LIST
86807: PUSH
86808: LD_INT 3
86810: PUSH
86811: LD_INT 1
86813: PUSH
86814: EMPTY
86815: LIST
86816: LIST
86817: PUSH
86818: LD_INT 3
86820: PUSH
86821: LD_INT 2
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 3
86830: PUSH
86831: LD_INT 3
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 2
86840: PUSH
86841: LD_INT 3
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 2
86850: NEG
86851: PUSH
86852: LD_INT 1
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 3
86861: NEG
86862: PUSH
86863: LD_INT 0
86865: PUSH
86866: EMPTY
86867: LIST
86868: LIST
86869: PUSH
86870: LD_INT 3
86872: NEG
86873: PUSH
86874: LD_INT 1
86876: NEG
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 3
86884: NEG
86885: PUSH
86886: LD_INT 2
86888: NEG
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: LD_INT 3
86896: NEG
86897: PUSH
86898: LD_INT 3
86900: NEG
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86937: LD_ADDR_VAR 0 42
86941: PUSH
86942: LD_INT 0
86944: PUSH
86945: LD_INT 0
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 0
86954: PUSH
86955: LD_INT 1
86957: NEG
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: PUSH
86963: LD_INT 1
86965: PUSH
86966: LD_INT 0
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: LD_INT 1
86975: PUSH
86976: LD_INT 1
86978: PUSH
86979: EMPTY
86980: LIST
86981: LIST
86982: PUSH
86983: LD_INT 0
86985: PUSH
86986: LD_INT 1
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: PUSH
86993: LD_INT 1
86995: NEG
86996: PUSH
86997: LD_INT 0
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: LD_INT 1
87006: NEG
87007: PUSH
87008: LD_INT 1
87010: NEG
87011: PUSH
87012: EMPTY
87013: LIST
87014: LIST
87015: PUSH
87016: LD_INT 1
87018: NEG
87019: PUSH
87020: LD_INT 2
87022: NEG
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PUSH
87028: LD_INT 0
87030: PUSH
87031: LD_INT 2
87033: NEG
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 1
87041: PUSH
87042: LD_INT 1
87044: NEG
87045: PUSH
87046: EMPTY
87047: LIST
87048: LIST
87049: PUSH
87050: LD_INT 2
87052: PUSH
87053: LD_INT 1
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 2
87062: PUSH
87063: LD_INT 2
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 1
87072: PUSH
87073: LD_INT 2
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 0
87082: PUSH
87083: LD_INT 2
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: PUSH
87090: LD_INT 1
87092: NEG
87093: PUSH
87094: LD_INT 1
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: PUSH
87101: LD_INT 2
87103: NEG
87104: PUSH
87105: LD_INT 1
87107: NEG
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 2
87115: NEG
87116: PUSH
87117: LD_INT 2
87119: NEG
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: LD_INT 2
87127: NEG
87128: PUSH
87129: LD_INT 3
87131: NEG
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: PUSH
87137: LD_INT 1
87139: NEG
87140: PUSH
87141: LD_INT 3
87143: NEG
87144: PUSH
87145: EMPTY
87146: LIST
87147: LIST
87148: PUSH
87149: LD_INT 0
87151: PUSH
87152: LD_INT 3
87154: NEG
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: PUSH
87160: LD_INT 1
87162: PUSH
87163: LD_INT 2
87165: NEG
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: LD_INT 3
87173: PUSH
87174: LD_INT 2
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 3
87183: PUSH
87184: LD_INT 3
87186: PUSH
87187: EMPTY
87188: LIST
87189: LIST
87190: PUSH
87191: LD_INT 2
87193: PUSH
87194: LD_INT 3
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 1
87203: PUSH
87204: LD_INT 3
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: LD_INT 3
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 1
87223: NEG
87224: PUSH
87225: LD_INT 2
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 3
87234: NEG
87235: PUSH
87236: LD_INT 2
87238: NEG
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: LD_INT 3
87246: NEG
87247: PUSH
87248: LD_INT 3
87250: NEG
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: PUSH
87256: EMPTY
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: LIST
87285: LIST
87286: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87287: LD_ADDR_VAR 0 43
87291: PUSH
87292: LD_INT 0
87294: PUSH
87295: LD_INT 0
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: LD_INT 0
87304: PUSH
87305: LD_INT 1
87307: NEG
87308: PUSH
87309: EMPTY
87310: LIST
87311: LIST
87312: PUSH
87313: LD_INT 1
87315: PUSH
87316: LD_INT 0
87318: PUSH
87319: EMPTY
87320: LIST
87321: LIST
87322: PUSH
87323: LD_INT 1
87325: PUSH
87326: LD_INT 1
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: PUSH
87333: LD_INT 0
87335: PUSH
87336: LD_INT 1
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: PUSH
87343: LD_INT 1
87345: NEG
87346: PUSH
87347: LD_INT 0
87349: PUSH
87350: EMPTY
87351: LIST
87352: LIST
87353: PUSH
87354: LD_INT 1
87356: NEG
87357: PUSH
87358: LD_INT 1
87360: NEG
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 1
87368: NEG
87369: PUSH
87370: LD_INT 2
87372: NEG
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 0
87380: PUSH
87381: LD_INT 2
87383: NEG
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 1
87391: PUSH
87392: LD_INT 1
87394: NEG
87395: PUSH
87396: EMPTY
87397: LIST
87398: LIST
87399: PUSH
87400: LD_INT 2
87402: PUSH
87403: LD_INT 0
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: PUSH
87410: LD_INT 2
87412: PUSH
87413: LD_INT 1
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 1
87422: PUSH
87423: LD_INT 2
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: LD_INT 0
87432: PUSH
87433: LD_INT 2
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PUSH
87440: LD_INT 1
87442: NEG
87443: PUSH
87444: LD_INT 1
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 2
87453: NEG
87454: PUSH
87455: LD_INT 0
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 2
87464: NEG
87465: PUSH
87466: LD_INT 1
87468: NEG
87469: PUSH
87470: EMPTY
87471: LIST
87472: LIST
87473: PUSH
87474: LD_INT 1
87476: NEG
87477: PUSH
87478: LD_INT 3
87480: NEG
87481: PUSH
87482: EMPTY
87483: LIST
87484: LIST
87485: PUSH
87486: LD_INT 0
87488: PUSH
87489: LD_INT 3
87491: NEG
87492: PUSH
87493: EMPTY
87494: LIST
87495: LIST
87496: PUSH
87497: LD_INT 1
87499: PUSH
87500: LD_INT 2
87502: NEG
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: PUSH
87508: LD_INT 2
87510: PUSH
87511: LD_INT 1
87513: NEG
87514: PUSH
87515: EMPTY
87516: LIST
87517: LIST
87518: PUSH
87519: LD_INT 3
87521: PUSH
87522: LD_INT 0
87524: PUSH
87525: EMPTY
87526: LIST
87527: LIST
87528: PUSH
87529: LD_INT 3
87531: PUSH
87532: LD_INT 1
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 1
87541: PUSH
87542: LD_INT 3
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: LD_INT 0
87551: PUSH
87552: LD_INT 3
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 1
87561: NEG
87562: PUSH
87563: LD_INT 2
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 2
87572: NEG
87573: PUSH
87574: LD_INT 1
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: PUSH
87581: LD_INT 3
87583: NEG
87584: PUSH
87585: LD_INT 0
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: PUSH
87592: LD_INT 3
87594: NEG
87595: PUSH
87596: LD_INT 1
87598: NEG
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: LIST
87625: LIST
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87635: LD_ADDR_VAR 0 44
87639: PUSH
87640: LD_INT 0
87642: PUSH
87643: LD_INT 0
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 0
87652: PUSH
87653: LD_INT 1
87655: NEG
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: PUSH
87661: LD_INT 1
87663: PUSH
87664: LD_INT 0
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: LD_INT 1
87673: PUSH
87674: LD_INT 1
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 0
87683: PUSH
87684: LD_INT 1
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 1
87693: NEG
87694: PUSH
87695: LD_INT 0
87697: PUSH
87698: EMPTY
87699: LIST
87700: LIST
87701: PUSH
87702: LD_INT 1
87704: NEG
87705: PUSH
87706: LD_INT 1
87708: NEG
87709: PUSH
87710: EMPTY
87711: LIST
87712: LIST
87713: PUSH
87714: LD_INT 1
87716: NEG
87717: PUSH
87718: LD_INT 2
87720: NEG
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 1
87728: PUSH
87729: LD_INT 1
87731: NEG
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: PUSH
87737: LD_INT 2
87739: PUSH
87740: LD_INT 0
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PUSH
87747: LD_INT 2
87749: PUSH
87750: LD_INT 1
87752: PUSH
87753: EMPTY
87754: LIST
87755: LIST
87756: PUSH
87757: LD_INT 2
87759: PUSH
87760: LD_INT 2
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 1
87769: PUSH
87770: LD_INT 2
87772: PUSH
87773: EMPTY
87774: LIST
87775: LIST
87776: PUSH
87777: LD_INT 1
87779: NEG
87780: PUSH
87781: LD_INT 1
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: PUSH
87788: LD_INT 2
87790: NEG
87791: PUSH
87792: LD_INT 0
87794: PUSH
87795: EMPTY
87796: LIST
87797: LIST
87798: PUSH
87799: LD_INT 2
87801: NEG
87802: PUSH
87803: LD_INT 1
87805: NEG
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 2
87813: NEG
87814: PUSH
87815: LD_INT 2
87817: NEG
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 2
87825: NEG
87826: PUSH
87827: LD_INT 3
87829: NEG
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 2
87837: PUSH
87838: LD_INT 1
87840: NEG
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 3
87848: PUSH
87849: LD_INT 0
87851: PUSH
87852: EMPTY
87853: LIST
87854: LIST
87855: PUSH
87856: LD_INT 3
87858: PUSH
87859: LD_INT 1
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 3
87868: PUSH
87869: LD_INT 2
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 3
87878: PUSH
87879: LD_INT 3
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 2
87888: PUSH
87889: LD_INT 3
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: LD_INT 2
87898: NEG
87899: PUSH
87900: LD_INT 1
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 3
87909: NEG
87910: PUSH
87911: LD_INT 0
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 3
87920: NEG
87921: PUSH
87922: LD_INT 1
87924: NEG
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 3
87932: NEG
87933: PUSH
87934: LD_INT 2
87936: NEG
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 3
87944: NEG
87945: PUSH
87946: LD_INT 3
87948: NEG
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87985: LD_ADDR_VAR 0 45
87989: PUSH
87990: LD_INT 0
87992: PUSH
87993: LD_INT 0
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 0
88002: PUSH
88003: LD_INT 1
88005: NEG
88006: PUSH
88007: EMPTY
88008: LIST
88009: LIST
88010: PUSH
88011: LD_INT 1
88013: PUSH
88014: LD_INT 0
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 1
88023: PUSH
88024: LD_INT 1
88026: PUSH
88027: EMPTY
88028: LIST
88029: LIST
88030: PUSH
88031: LD_INT 0
88033: PUSH
88034: LD_INT 1
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 1
88043: NEG
88044: PUSH
88045: LD_INT 0
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: PUSH
88052: LD_INT 1
88054: NEG
88055: PUSH
88056: LD_INT 1
88058: NEG
88059: PUSH
88060: EMPTY
88061: LIST
88062: LIST
88063: PUSH
88064: LD_INT 1
88066: NEG
88067: PUSH
88068: LD_INT 2
88070: NEG
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: LD_INT 0
88078: PUSH
88079: LD_INT 2
88081: NEG
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 1
88089: PUSH
88090: LD_INT 1
88092: NEG
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: PUSH
88098: LD_INT 2
88100: PUSH
88101: LD_INT 1
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 2
88110: PUSH
88111: LD_INT 2
88113: PUSH
88114: EMPTY
88115: LIST
88116: LIST
88117: PUSH
88118: LD_INT 1
88120: PUSH
88121: LD_INT 2
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: LD_INT 0
88130: PUSH
88131: LD_INT 2
88133: PUSH
88134: EMPTY
88135: LIST
88136: LIST
88137: PUSH
88138: LD_INT 1
88140: NEG
88141: PUSH
88142: LD_INT 1
88144: PUSH
88145: EMPTY
88146: LIST
88147: LIST
88148: PUSH
88149: LD_INT 2
88151: NEG
88152: PUSH
88153: LD_INT 1
88155: NEG
88156: PUSH
88157: EMPTY
88158: LIST
88159: LIST
88160: PUSH
88161: LD_INT 2
88163: NEG
88164: PUSH
88165: LD_INT 2
88167: NEG
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: PUSH
88173: LD_INT 2
88175: NEG
88176: PUSH
88177: LD_INT 3
88179: NEG
88180: PUSH
88181: EMPTY
88182: LIST
88183: LIST
88184: PUSH
88185: LD_INT 1
88187: NEG
88188: PUSH
88189: LD_INT 3
88191: NEG
88192: PUSH
88193: EMPTY
88194: LIST
88195: LIST
88196: PUSH
88197: LD_INT 0
88199: PUSH
88200: LD_INT 3
88202: NEG
88203: PUSH
88204: EMPTY
88205: LIST
88206: LIST
88207: PUSH
88208: LD_INT 1
88210: PUSH
88211: LD_INT 2
88213: NEG
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 3
88221: PUSH
88222: LD_INT 2
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 3
88231: PUSH
88232: LD_INT 3
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 2
88241: PUSH
88242: LD_INT 3
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 1
88251: PUSH
88252: LD_INT 3
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 0
88261: PUSH
88262: LD_INT 3
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 1
88271: NEG
88272: PUSH
88273: LD_INT 2
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 3
88282: NEG
88283: PUSH
88284: LD_INT 2
88286: NEG
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 3
88294: NEG
88295: PUSH
88296: LD_INT 3
88298: NEG
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88335: LD_ADDR_VAR 0 46
88339: PUSH
88340: LD_INT 0
88342: PUSH
88343: LD_INT 0
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 0
88352: PUSH
88353: LD_INT 1
88355: NEG
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: PUSH
88361: LD_INT 1
88363: PUSH
88364: LD_INT 0
88366: PUSH
88367: EMPTY
88368: LIST
88369: LIST
88370: PUSH
88371: LD_INT 1
88373: PUSH
88374: LD_INT 1
88376: PUSH
88377: EMPTY
88378: LIST
88379: LIST
88380: PUSH
88381: LD_INT 0
88383: PUSH
88384: LD_INT 1
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: PUSH
88391: LD_INT 1
88393: NEG
88394: PUSH
88395: LD_INT 0
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: PUSH
88402: LD_INT 1
88404: NEG
88405: PUSH
88406: LD_INT 1
88408: NEG
88409: PUSH
88410: EMPTY
88411: LIST
88412: LIST
88413: PUSH
88414: LD_INT 1
88416: NEG
88417: PUSH
88418: LD_INT 2
88420: NEG
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: PUSH
88426: LD_INT 0
88428: PUSH
88429: LD_INT 2
88431: NEG
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: PUSH
88437: LD_INT 1
88439: PUSH
88440: LD_INT 1
88442: NEG
88443: PUSH
88444: EMPTY
88445: LIST
88446: LIST
88447: PUSH
88448: LD_INT 2
88450: PUSH
88451: LD_INT 0
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PUSH
88458: LD_INT 2
88460: PUSH
88461: LD_INT 1
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: PUSH
88468: LD_INT 1
88470: PUSH
88471: LD_INT 2
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 0
88480: PUSH
88481: LD_INT 2
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 1
88490: NEG
88491: PUSH
88492: LD_INT 1
88494: PUSH
88495: EMPTY
88496: LIST
88497: LIST
88498: PUSH
88499: LD_INT 2
88501: NEG
88502: PUSH
88503: LD_INT 0
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 2
88512: NEG
88513: PUSH
88514: LD_INT 1
88516: NEG
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 1
88524: NEG
88525: PUSH
88526: LD_INT 3
88528: NEG
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: PUSH
88534: LD_INT 0
88536: PUSH
88537: LD_INT 3
88539: NEG
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 1
88547: PUSH
88548: LD_INT 2
88550: NEG
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: LD_INT 2
88558: PUSH
88559: LD_INT 1
88561: NEG
88562: PUSH
88563: EMPTY
88564: LIST
88565: LIST
88566: PUSH
88567: LD_INT 3
88569: PUSH
88570: LD_INT 0
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: LD_INT 3
88579: PUSH
88580: LD_INT 1
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 1
88589: PUSH
88590: LD_INT 3
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 0
88599: PUSH
88600: LD_INT 3
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 1
88609: NEG
88610: PUSH
88611: LD_INT 2
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PUSH
88618: LD_INT 2
88620: NEG
88621: PUSH
88622: LD_INT 1
88624: PUSH
88625: EMPTY
88626: LIST
88627: LIST
88628: PUSH
88629: LD_INT 3
88631: NEG
88632: PUSH
88633: LD_INT 0
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 3
88642: NEG
88643: PUSH
88644: LD_INT 1
88646: NEG
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: PUSH
88652: EMPTY
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88683: LD_ADDR_VAR 0 47
88687: PUSH
88688: LD_INT 0
88690: PUSH
88691: LD_INT 0
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 0
88700: PUSH
88701: LD_INT 1
88703: NEG
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: LD_INT 1
88711: PUSH
88712: LD_INT 0
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: PUSH
88719: LD_INT 1
88721: PUSH
88722: LD_INT 1
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 0
88731: PUSH
88732: LD_INT 1
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 1
88741: NEG
88742: PUSH
88743: LD_INT 0
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: LD_INT 1
88752: NEG
88753: PUSH
88754: LD_INT 1
88756: NEG
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 1
88764: NEG
88765: PUSH
88766: LD_INT 2
88768: NEG
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 0
88776: PUSH
88777: LD_INT 2
88779: NEG
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: PUSH
88785: LD_INT 1
88787: PUSH
88788: LD_INT 1
88790: NEG
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 2
88798: NEG
88799: PUSH
88800: LD_INT 1
88802: NEG
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 2
88810: NEG
88811: PUSH
88812: LD_INT 2
88814: NEG
88815: PUSH
88816: EMPTY
88817: LIST
88818: LIST
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88834: LD_ADDR_VAR 0 48
88838: PUSH
88839: LD_INT 0
88841: PUSH
88842: LD_INT 0
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: PUSH
88849: LD_INT 0
88851: PUSH
88852: LD_INT 1
88854: NEG
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 1
88862: PUSH
88863: LD_INT 0
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 1
88872: PUSH
88873: LD_INT 1
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 0
88882: PUSH
88883: LD_INT 1
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 1
88892: NEG
88893: PUSH
88894: LD_INT 0
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 1
88903: NEG
88904: PUSH
88905: LD_INT 1
88907: NEG
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: PUSH
88913: LD_INT 1
88915: NEG
88916: PUSH
88917: LD_INT 2
88919: NEG
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 0
88927: PUSH
88928: LD_INT 2
88930: NEG
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: PUSH
88936: LD_INT 1
88938: PUSH
88939: LD_INT 1
88941: NEG
88942: PUSH
88943: EMPTY
88944: LIST
88945: LIST
88946: PUSH
88947: LD_INT 2
88949: PUSH
88950: LD_INT 0
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: PUSH
88957: LD_INT 2
88959: PUSH
88960: LD_INT 1
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: PUSH
88967: EMPTY
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88981: LD_ADDR_VAR 0 49
88985: PUSH
88986: LD_INT 0
88988: PUSH
88989: LD_INT 0
88991: PUSH
88992: EMPTY
88993: LIST
88994: LIST
88995: PUSH
88996: LD_INT 0
88998: PUSH
88999: LD_INT 1
89001: NEG
89002: PUSH
89003: EMPTY
89004: LIST
89005: LIST
89006: PUSH
89007: LD_INT 1
89009: PUSH
89010: LD_INT 0
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: PUSH
89017: LD_INT 1
89019: PUSH
89020: LD_INT 1
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 0
89029: PUSH
89030: LD_INT 1
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 1
89039: NEG
89040: PUSH
89041: LD_INT 0
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: LD_INT 1
89050: NEG
89051: PUSH
89052: LD_INT 1
89054: NEG
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 1
89062: PUSH
89063: LD_INT 1
89065: NEG
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 2
89073: PUSH
89074: LD_INT 0
89076: PUSH
89077: EMPTY
89078: LIST
89079: LIST
89080: PUSH
89081: LD_INT 2
89083: PUSH
89084: LD_INT 1
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 2
89093: PUSH
89094: LD_INT 2
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 1
89103: PUSH
89104: LD_INT 2
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89125: LD_ADDR_VAR 0 50
89129: PUSH
89130: LD_INT 0
89132: PUSH
89133: LD_INT 0
89135: PUSH
89136: EMPTY
89137: LIST
89138: LIST
89139: PUSH
89140: LD_INT 0
89142: PUSH
89143: LD_INT 1
89145: NEG
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: PUSH
89151: LD_INT 1
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 1
89163: PUSH
89164: LD_INT 1
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 0
89173: PUSH
89174: LD_INT 1
89176: PUSH
89177: EMPTY
89178: LIST
89179: LIST
89180: PUSH
89181: LD_INT 1
89183: NEG
89184: PUSH
89185: LD_INT 0
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 1
89194: NEG
89195: PUSH
89196: LD_INT 1
89198: NEG
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: LD_INT 2
89206: PUSH
89207: LD_INT 1
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PUSH
89214: LD_INT 2
89216: PUSH
89217: LD_INT 2
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: PUSH
89224: LD_INT 1
89226: PUSH
89227: LD_INT 2
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 0
89236: PUSH
89237: LD_INT 2
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 1
89246: NEG
89247: PUSH
89248: LD_INT 1
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: LIST
89268: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89269: LD_ADDR_VAR 0 51
89273: PUSH
89274: LD_INT 0
89276: PUSH
89277: LD_INT 0
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: PUSH
89284: LD_INT 0
89286: PUSH
89287: LD_INT 1
89289: NEG
89290: PUSH
89291: EMPTY
89292: LIST
89293: LIST
89294: PUSH
89295: LD_INT 1
89297: PUSH
89298: LD_INT 0
89300: PUSH
89301: EMPTY
89302: LIST
89303: LIST
89304: PUSH
89305: LD_INT 1
89307: PUSH
89308: LD_INT 1
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: PUSH
89315: LD_INT 0
89317: PUSH
89318: LD_INT 1
89320: PUSH
89321: EMPTY
89322: LIST
89323: LIST
89324: PUSH
89325: LD_INT 1
89327: NEG
89328: PUSH
89329: LD_INT 0
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 1
89338: NEG
89339: PUSH
89340: LD_INT 1
89342: NEG
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: PUSH
89348: LD_INT 1
89350: PUSH
89351: LD_INT 2
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 0
89360: PUSH
89361: LD_INT 2
89363: PUSH
89364: EMPTY
89365: LIST
89366: LIST
89367: PUSH
89368: LD_INT 1
89370: NEG
89371: PUSH
89372: LD_INT 1
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: PUSH
89379: LD_INT 2
89381: NEG
89382: PUSH
89383: LD_INT 0
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: PUSH
89390: LD_INT 2
89392: NEG
89393: PUSH
89394: LD_INT 1
89396: NEG
89397: PUSH
89398: EMPTY
89399: LIST
89400: LIST
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89416: LD_ADDR_VAR 0 52
89420: PUSH
89421: LD_INT 0
89423: PUSH
89424: LD_INT 0
89426: PUSH
89427: EMPTY
89428: LIST
89429: LIST
89430: PUSH
89431: LD_INT 0
89433: PUSH
89434: LD_INT 1
89436: NEG
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 1
89444: PUSH
89445: LD_INT 0
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: PUSH
89452: LD_INT 1
89454: PUSH
89455: LD_INT 1
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: PUSH
89462: LD_INT 0
89464: PUSH
89465: LD_INT 1
89467: PUSH
89468: EMPTY
89469: LIST
89470: LIST
89471: PUSH
89472: LD_INT 1
89474: NEG
89475: PUSH
89476: LD_INT 0
89478: PUSH
89479: EMPTY
89480: LIST
89481: LIST
89482: PUSH
89483: LD_INT 1
89485: NEG
89486: PUSH
89487: LD_INT 1
89489: NEG
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: PUSH
89495: LD_INT 1
89497: NEG
89498: PUSH
89499: LD_INT 2
89501: NEG
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: PUSH
89507: LD_INT 1
89509: NEG
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 2
89520: NEG
89521: PUSH
89522: LD_INT 0
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 2
89531: NEG
89532: PUSH
89533: LD_INT 1
89535: NEG
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 2
89543: NEG
89544: PUSH
89545: LD_INT 2
89547: NEG
89548: PUSH
89549: EMPTY
89550: LIST
89551: LIST
89552: PUSH
89553: EMPTY
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89567: LD_ADDR_VAR 0 53
89571: PUSH
89572: LD_INT 0
89574: PUSH
89575: LD_INT 0
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: LD_INT 0
89584: PUSH
89585: LD_INT 1
89587: NEG
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 1
89595: PUSH
89596: LD_INT 0
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 1
89605: PUSH
89606: LD_INT 1
89608: PUSH
89609: EMPTY
89610: LIST
89611: LIST
89612: PUSH
89613: LD_INT 0
89615: PUSH
89616: LD_INT 1
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: PUSH
89623: LD_INT 1
89625: NEG
89626: PUSH
89627: LD_INT 0
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 1
89636: NEG
89637: PUSH
89638: LD_INT 1
89640: NEG
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 1
89648: NEG
89649: PUSH
89650: LD_INT 2
89652: NEG
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: LD_INT 0
89660: PUSH
89661: LD_INT 2
89663: NEG
89664: PUSH
89665: EMPTY
89666: LIST
89667: LIST
89668: PUSH
89669: LD_INT 1
89671: PUSH
89672: LD_INT 1
89674: NEG
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PUSH
89680: LD_INT 2
89682: PUSH
89683: LD_INT 0
89685: PUSH
89686: EMPTY
89687: LIST
89688: LIST
89689: PUSH
89690: LD_INT 2
89692: PUSH
89693: LD_INT 1
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PUSH
89700: LD_INT 2
89702: PUSH
89703: LD_INT 2
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 1
89712: PUSH
89713: LD_INT 2
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 0
89722: PUSH
89723: LD_INT 2
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 1
89732: NEG
89733: PUSH
89734: LD_INT 1
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: PUSH
89741: LD_INT 2
89743: NEG
89744: PUSH
89745: LD_INT 0
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 2
89754: NEG
89755: PUSH
89756: LD_INT 1
89758: NEG
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: LD_INT 2
89766: NEG
89767: PUSH
89768: LD_INT 2
89770: NEG
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89797: LD_ADDR_VAR 0 54
89801: PUSH
89802: LD_INT 0
89804: PUSH
89805: LD_INT 0
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 0
89814: PUSH
89815: LD_INT 1
89817: NEG
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 1
89825: PUSH
89826: LD_INT 0
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 1
89835: PUSH
89836: LD_INT 1
89838: PUSH
89839: EMPTY
89840: LIST
89841: LIST
89842: PUSH
89843: LD_INT 0
89845: PUSH
89846: LD_INT 1
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 1
89855: NEG
89856: PUSH
89857: LD_INT 0
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: LD_INT 1
89866: NEG
89867: PUSH
89868: LD_INT 1
89870: NEG
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: PUSH
89876: LD_INT 1
89878: NEG
89879: PUSH
89880: LD_INT 2
89882: NEG
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 0
89890: PUSH
89891: LD_INT 2
89893: NEG
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 1
89901: PUSH
89902: LD_INT 1
89904: NEG
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: LD_INT 2
89912: PUSH
89913: LD_INT 0
89915: PUSH
89916: EMPTY
89917: LIST
89918: LIST
89919: PUSH
89920: LD_INT 2
89922: PUSH
89923: LD_INT 1
89925: PUSH
89926: EMPTY
89927: LIST
89928: LIST
89929: PUSH
89930: LD_INT 2
89932: PUSH
89933: LD_INT 2
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 1
89942: PUSH
89943: LD_INT 2
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PUSH
89950: LD_INT 0
89952: PUSH
89953: LD_INT 2
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: PUSH
89960: LD_INT 1
89962: NEG
89963: PUSH
89964: LD_INT 1
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: PUSH
89971: LD_INT 2
89973: NEG
89974: PUSH
89975: LD_INT 0
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 2
89984: NEG
89985: PUSH
89986: LD_INT 1
89988: NEG
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: PUSH
89994: LD_INT 2
89996: NEG
89997: PUSH
89998: LD_INT 2
90000: NEG
90001: PUSH
90002: EMPTY
90003: LIST
90004: LIST
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: LIST
90026: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90027: LD_ADDR_VAR 0 55
90031: PUSH
90032: LD_INT 0
90034: PUSH
90035: LD_INT 0
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: LD_INT 0
90044: PUSH
90045: LD_INT 1
90047: NEG
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: LD_INT 1
90055: PUSH
90056: LD_INT 0
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: PUSH
90063: LD_INT 1
90065: PUSH
90066: LD_INT 1
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: PUSH
90073: LD_INT 0
90075: PUSH
90076: LD_INT 1
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 1
90085: NEG
90086: PUSH
90087: LD_INT 0
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 1
90096: NEG
90097: PUSH
90098: LD_INT 1
90100: NEG
90101: PUSH
90102: EMPTY
90103: LIST
90104: LIST
90105: PUSH
90106: LD_INT 1
90108: NEG
90109: PUSH
90110: LD_INT 2
90112: NEG
90113: PUSH
90114: EMPTY
90115: LIST
90116: LIST
90117: PUSH
90118: LD_INT 0
90120: PUSH
90121: LD_INT 2
90123: NEG
90124: PUSH
90125: EMPTY
90126: LIST
90127: LIST
90128: PUSH
90129: LD_INT 1
90131: PUSH
90132: LD_INT 1
90134: NEG
90135: PUSH
90136: EMPTY
90137: LIST
90138: LIST
90139: PUSH
90140: LD_INT 2
90142: PUSH
90143: LD_INT 0
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: PUSH
90150: LD_INT 2
90152: PUSH
90153: LD_INT 1
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: PUSH
90160: LD_INT 2
90162: PUSH
90163: LD_INT 2
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PUSH
90170: LD_INT 1
90172: PUSH
90173: LD_INT 2
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: PUSH
90180: LD_INT 0
90182: PUSH
90183: LD_INT 2
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PUSH
90190: LD_INT 1
90192: NEG
90193: PUSH
90194: LD_INT 1
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 2
90203: NEG
90204: PUSH
90205: LD_INT 0
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 2
90214: NEG
90215: PUSH
90216: LD_INT 1
90218: NEG
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: LD_INT 2
90226: NEG
90227: PUSH
90228: LD_INT 2
90230: NEG
90231: PUSH
90232: EMPTY
90233: LIST
90234: LIST
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90257: LD_ADDR_VAR 0 56
90261: PUSH
90262: LD_INT 0
90264: PUSH
90265: LD_INT 0
90267: PUSH
90268: EMPTY
90269: LIST
90270: LIST
90271: PUSH
90272: LD_INT 0
90274: PUSH
90275: LD_INT 1
90277: NEG
90278: PUSH
90279: EMPTY
90280: LIST
90281: LIST
90282: PUSH
90283: LD_INT 1
90285: PUSH
90286: LD_INT 0
90288: PUSH
90289: EMPTY
90290: LIST
90291: LIST
90292: PUSH
90293: LD_INT 1
90295: PUSH
90296: LD_INT 1
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PUSH
90303: LD_INT 0
90305: PUSH
90306: LD_INT 1
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: PUSH
90313: LD_INT 1
90315: NEG
90316: PUSH
90317: LD_INT 0
90319: PUSH
90320: EMPTY
90321: LIST
90322: LIST
90323: PUSH
90324: LD_INT 1
90326: NEG
90327: PUSH
90328: LD_INT 1
90330: NEG
90331: PUSH
90332: EMPTY
90333: LIST
90334: LIST
90335: PUSH
90336: LD_INT 1
90338: NEG
90339: PUSH
90340: LD_INT 2
90342: NEG
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: LD_INT 0
90350: PUSH
90351: LD_INT 2
90353: NEG
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: LD_INT 1
90361: PUSH
90362: LD_INT 1
90364: NEG
90365: PUSH
90366: EMPTY
90367: LIST
90368: LIST
90369: PUSH
90370: LD_INT 2
90372: PUSH
90373: LD_INT 0
90375: PUSH
90376: EMPTY
90377: LIST
90378: LIST
90379: PUSH
90380: LD_INT 2
90382: PUSH
90383: LD_INT 1
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: PUSH
90390: LD_INT 2
90392: PUSH
90393: LD_INT 2
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: LD_INT 1
90402: PUSH
90403: LD_INT 2
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 0
90412: PUSH
90413: LD_INT 2
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: LD_INT 1
90422: NEG
90423: PUSH
90424: LD_INT 1
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 2
90433: NEG
90434: PUSH
90435: LD_INT 0
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 2
90444: NEG
90445: PUSH
90446: LD_INT 1
90448: NEG
90449: PUSH
90450: EMPTY
90451: LIST
90452: LIST
90453: PUSH
90454: LD_INT 2
90456: NEG
90457: PUSH
90458: LD_INT 2
90460: NEG
90461: PUSH
90462: EMPTY
90463: LIST
90464: LIST
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90487: LD_ADDR_VAR 0 57
90491: PUSH
90492: LD_INT 0
90494: PUSH
90495: LD_INT 0
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 0
90504: PUSH
90505: LD_INT 1
90507: NEG
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 1
90515: PUSH
90516: LD_INT 0
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: PUSH
90523: LD_INT 1
90525: PUSH
90526: LD_INT 1
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: PUSH
90533: LD_INT 0
90535: PUSH
90536: LD_INT 1
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 1
90545: NEG
90546: PUSH
90547: LD_INT 0
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: LD_INT 1
90556: NEG
90557: PUSH
90558: LD_INT 1
90560: NEG
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PUSH
90566: LD_INT 1
90568: NEG
90569: PUSH
90570: LD_INT 2
90572: NEG
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: PUSH
90578: LD_INT 0
90580: PUSH
90581: LD_INT 2
90583: NEG
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: PUSH
90589: LD_INT 1
90591: PUSH
90592: LD_INT 1
90594: NEG
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: PUSH
90600: LD_INT 2
90602: PUSH
90603: LD_INT 0
90605: PUSH
90606: EMPTY
90607: LIST
90608: LIST
90609: PUSH
90610: LD_INT 2
90612: PUSH
90613: LD_INT 1
90615: PUSH
90616: EMPTY
90617: LIST
90618: LIST
90619: PUSH
90620: LD_INT 2
90622: PUSH
90623: LD_INT 2
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: PUSH
90630: LD_INT 1
90632: PUSH
90633: LD_INT 2
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: PUSH
90640: LD_INT 0
90642: PUSH
90643: LD_INT 2
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 1
90652: NEG
90653: PUSH
90654: LD_INT 1
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 2
90663: NEG
90664: PUSH
90665: LD_INT 0
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 2
90674: NEG
90675: PUSH
90676: LD_INT 1
90678: NEG
90679: PUSH
90680: EMPTY
90681: LIST
90682: LIST
90683: PUSH
90684: LD_INT 2
90686: NEG
90687: PUSH
90688: LD_INT 2
90690: NEG
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90717: LD_ADDR_VAR 0 58
90721: PUSH
90722: LD_INT 0
90724: PUSH
90725: LD_INT 0
90727: PUSH
90728: EMPTY
90729: LIST
90730: LIST
90731: PUSH
90732: LD_INT 0
90734: PUSH
90735: LD_INT 1
90737: NEG
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 1
90745: PUSH
90746: LD_INT 0
90748: PUSH
90749: EMPTY
90750: LIST
90751: LIST
90752: PUSH
90753: LD_INT 1
90755: PUSH
90756: LD_INT 1
90758: PUSH
90759: EMPTY
90760: LIST
90761: LIST
90762: PUSH
90763: LD_INT 0
90765: PUSH
90766: LD_INT 1
90768: PUSH
90769: EMPTY
90770: LIST
90771: LIST
90772: PUSH
90773: LD_INT 1
90775: NEG
90776: PUSH
90777: LD_INT 0
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 1
90786: NEG
90787: PUSH
90788: LD_INT 1
90790: NEG
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PUSH
90796: LD_INT 1
90798: NEG
90799: PUSH
90800: LD_INT 2
90802: NEG
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 0
90810: PUSH
90811: LD_INT 2
90813: NEG
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 1
90821: PUSH
90822: LD_INT 1
90824: NEG
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 2
90832: PUSH
90833: LD_INT 0
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 2
90842: PUSH
90843: LD_INT 1
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: LD_INT 2
90852: PUSH
90853: LD_INT 2
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 1
90862: PUSH
90863: LD_INT 2
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: PUSH
90870: LD_INT 0
90872: PUSH
90873: LD_INT 2
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: PUSH
90880: LD_INT 1
90882: NEG
90883: PUSH
90884: LD_INT 1
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 2
90893: NEG
90894: PUSH
90895: LD_INT 0
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 2
90904: NEG
90905: PUSH
90906: LD_INT 1
90908: NEG
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: PUSH
90914: LD_INT 2
90916: NEG
90917: PUSH
90918: LD_INT 2
90920: NEG
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90947: LD_ADDR_VAR 0 59
90951: PUSH
90952: LD_INT 0
90954: PUSH
90955: LD_INT 0
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 0
90964: PUSH
90965: LD_INT 1
90967: NEG
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: PUSH
90973: LD_INT 1
90975: PUSH
90976: LD_INT 0
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: LD_INT 1
90985: PUSH
90986: LD_INT 1
90988: PUSH
90989: EMPTY
90990: LIST
90991: LIST
90992: PUSH
90993: LD_INT 0
90995: PUSH
90996: LD_INT 1
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: PUSH
91003: LD_INT 1
91005: NEG
91006: PUSH
91007: LD_INT 0
91009: PUSH
91010: EMPTY
91011: LIST
91012: LIST
91013: PUSH
91014: LD_INT 1
91016: NEG
91017: PUSH
91018: LD_INT 1
91020: NEG
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91035: LD_ADDR_VAR 0 60
91039: PUSH
91040: LD_INT 0
91042: PUSH
91043: LD_INT 0
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: PUSH
91050: LD_INT 0
91052: PUSH
91053: LD_INT 1
91055: NEG
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PUSH
91061: LD_INT 1
91063: PUSH
91064: LD_INT 0
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 1
91073: PUSH
91074: LD_INT 1
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 0
91083: PUSH
91084: LD_INT 1
91086: PUSH
91087: EMPTY
91088: LIST
91089: LIST
91090: PUSH
91091: LD_INT 1
91093: NEG
91094: PUSH
91095: LD_INT 0
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: PUSH
91102: LD_INT 1
91104: NEG
91105: PUSH
91106: LD_INT 1
91108: NEG
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: LIST
91118: LIST
91119: LIST
91120: LIST
91121: LIST
91122: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91123: LD_ADDR_VAR 0 61
91127: PUSH
91128: LD_INT 0
91130: PUSH
91131: LD_INT 0
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: LD_INT 1
91143: NEG
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: LD_INT 1
91151: PUSH
91152: LD_INT 0
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: LD_INT 1
91161: PUSH
91162: LD_INT 1
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: LD_INT 1
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: PUSH
91179: LD_INT 1
91181: NEG
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 1
91192: NEG
91193: PUSH
91194: LD_INT 1
91196: NEG
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91211: LD_ADDR_VAR 0 62
91215: PUSH
91216: LD_INT 0
91218: PUSH
91219: LD_INT 0
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: LD_INT 0
91228: PUSH
91229: LD_INT 1
91231: NEG
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: PUSH
91237: LD_INT 1
91239: PUSH
91240: LD_INT 0
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: LD_INT 1
91249: PUSH
91250: LD_INT 1
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 0
91259: PUSH
91260: LD_INT 1
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 1
91269: NEG
91270: PUSH
91271: LD_INT 0
91273: PUSH
91274: EMPTY
91275: LIST
91276: LIST
91277: PUSH
91278: LD_INT 1
91280: NEG
91281: PUSH
91282: LD_INT 1
91284: NEG
91285: PUSH
91286: EMPTY
91287: LIST
91288: LIST
91289: PUSH
91290: EMPTY
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91299: LD_ADDR_VAR 0 63
91303: PUSH
91304: LD_INT 0
91306: PUSH
91307: LD_INT 0
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 0
91316: PUSH
91317: LD_INT 1
91319: NEG
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: LD_INT 1
91327: PUSH
91328: LD_INT 0
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: LD_INT 1
91337: PUSH
91338: LD_INT 1
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: PUSH
91345: LD_INT 0
91347: PUSH
91348: LD_INT 1
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: PUSH
91355: LD_INT 1
91357: NEG
91358: PUSH
91359: LD_INT 0
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: LD_INT 1
91368: NEG
91369: PUSH
91370: LD_INT 1
91372: NEG
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: EMPTY
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: LIST
91384: LIST
91385: LIST
91386: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91387: LD_ADDR_VAR 0 64
91391: PUSH
91392: LD_INT 0
91394: PUSH
91395: LD_INT 0
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: PUSH
91402: LD_INT 0
91404: PUSH
91405: LD_INT 1
91407: NEG
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: PUSH
91413: LD_INT 1
91415: PUSH
91416: LD_INT 0
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: LD_INT 1
91425: PUSH
91426: LD_INT 1
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: LD_INT 0
91435: PUSH
91436: LD_INT 1
91438: PUSH
91439: EMPTY
91440: LIST
91441: LIST
91442: PUSH
91443: LD_INT 1
91445: NEG
91446: PUSH
91447: LD_INT 0
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: PUSH
91454: LD_INT 1
91456: NEG
91457: PUSH
91458: LD_INT 1
91460: NEG
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: EMPTY
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: ST_TO_ADDR
// end ; 1 :
91475: GO 97372
91477: LD_INT 1
91479: DOUBLE
91480: EQUAL
91481: IFTRUE 91485
91483: GO 94108
91485: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91486: LD_ADDR_VAR 0 11
91490: PUSH
91491: LD_INT 1
91493: NEG
91494: PUSH
91495: LD_INT 3
91497: NEG
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: PUSH
91503: LD_INT 0
91505: PUSH
91506: LD_INT 3
91508: NEG
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: PUSH
91514: LD_INT 1
91516: PUSH
91517: LD_INT 2
91519: NEG
91520: PUSH
91521: EMPTY
91522: LIST
91523: LIST
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: LIST
91529: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91530: LD_ADDR_VAR 0 12
91534: PUSH
91535: LD_INT 2
91537: PUSH
91538: LD_INT 1
91540: NEG
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: LD_INT 3
91548: PUSH
91549: LD_INT 0
91551: PUSH
91552: EMPTY
91553: LIST
91554: LIST
91555: PUSH
91556: LD_INT 3
91558: PUSH
91559: LD_INT 1
91561: PUSH
91562: EMPTY
91563: LIST
91564: LIST
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: LIST
91570: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91571: LD_ADDR_VAR 0 13
91575: PUSH
91576: LD_INT 3
91578: PUSH
91579: LD_INT 2
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: LD_INT 3
91588: PUSH
91589: LD_INT 3
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: PUSH
91596: LD_INT 2
91598: PUSH
91599: LD_INT 3
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: LIST
91610: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91611: LD_ADDR_VAR 0 14
91615: PUSH
91616: LD_INT 1
91618: PUSH
91619: LD_INT 3
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 0
91628: PUSH
91629: LD_INT 3
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: LD_INT 1
91638: NEG
91639: PUSH
91640: LD_INT 2
91642: PUSH
91643: EMPTY
91644: LIST
91645: LIST
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: LIST
91651: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91652: LD_ADDR_VAR 0 15
91656: PUSH
91657: LD_INT 2
91659: NEG
91660: PUSH
91661: LD_INT 1
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: PUSH
91668: LD_INT 3
91670: NEG
91671: PUSH
91672: LD_INT 0
91674: PUSH
91675: EMPTY
91676: LIST
91677: LIST
91678: PUSH
91679: LD_INT 3
91681: NEG
91682: PUSH
91683: LD_INT 1
91685: NEG
91686: PUSH
91687: EMPTY
91688: LIST
91689: LIST
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: LIST
91695: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91696: LD_ADDR_VAR 0 16
91700: PUSH
91701: LD_INT 2
91703: NEG
91704: PUSH
91705: LD_INT 3
91707: NEG
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: PUSH
91713: LD_INT 3
91715: NEG
91716: PUSH
91717: LD_INT 2
91719: NEG
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: PUSH
91725: LD_INT 3
91727: NEG
91728: PUSH
91729: LD_INT 3
91731: NEG
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: LIST
91741: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91742: LD_ADDR_VAR 0 17
91746: PUSH
91747: LD_INT 1
91749: NEG
91750: PUSH
91751: LD_INT 3
91753: NEG
91754: PUSH
91755: EMPTY
91756: LIST
91757: LIST
91758: PUSH
91759: LD_INT 0
91761: PUSH
91762: LD_INT 3
91764: NEG
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: PUSH
91770: LD_INT 1
91772: PUSH
91773: LD_INT 2
91775: NEG
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: LIST
91785: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91786: LD_ADDR_VAR 0 18
91790: PUSH
91791: LD_INT 2
91793: PUSH
91794: LD_INT 1
91796: NEG
91797: PUSH
91798: EMPTY
91799: LIST
91800: LIST
91801: PUSH
91802: LD_INT 3
91804: PUSH
91805: LD_INT 0
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: LD_INT 3
91814: PUSH
91815: LD_INT 1
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: LIST
91826: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91827: LD_ADDR_VAR 0 19
91831: PUSH
91832: LD_INT 3
91834: PUSH
91835: LD_INT 2
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 3
91844: PUSH
91845: LD_INT 3
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 2
91854: PUSH
91855: LD_INT 3
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: LIST
91866: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91867: LD_ADDR_VAR 0 20
91871: PUSH
91872: LD_INT 1
91874: PUSH
91875: LD_INT 3
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 0
91884: PUSH
91885: LD_INT 3
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: LD_INT 1
91894: NEG
91895: PUSH
91896: LD_INT 2
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: LIST
91907: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91908: LD_ADDR_VAR 0 21
91912: PUSH
91913: LD_INT 2
91915: NEG
91916: PUSH
91917: LD_INT 1
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: PUSH
91924: LD_INT 3
91926: NEG
91927: PUSH
91928: LD_INT 0
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PUSH
91935: LD_INT 3
91937: NEG
91938: PUSH
91939: LD_INT 1
91941: NEG
91942: PUSH
91943: EMPTY
91944: LIST
91945: LIST
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: LIST
91951: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91952: LD_ADDR_VAR 0 22
91956: PUSH
91957: LD_INT 2
91959: NEG
91960: PUSH
91961: LD_INT 3
91963: NEG
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: LD_INT 3
91971: NEG
91972: PUSH
91973: LD_INT 2
91975: NEG
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 3
91983: NEG
91984: PUSH
91985: LD_INT 3
91987: NEG
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: LIST
91997: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91998: LD_ADDR_VAR 0 23
92002: PUSH
92003: LD_INT 0
92005: PUSH
92006: LD_INT 3
92008: NEG
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: PUSH
92014: LD_INT 1
92016: NEG
92017: PUSH
92018: LD_INT 4
92020: NEG
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: LD_INT 1
92028: PUSH
92029: LD_INT 3
92031: NEG
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: LIST
92041: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92042: LD_ADDR_VAR 0 24
92046: PUSH
92047: LD_INT 3
92049: PUSH
92050: LD_INT 0
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PUSH
92057: LD_INT 3
92059: PUSH
92060: LD_INT 1
92062: NEG
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: PUSH
92068: LD_INT 4
92070: PUSH
92071: LD_INT 1
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: LIST
92082: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92083: LD_ADDR_VAR 0 25
92087: PUSH
92088: LD_INT 3
92090: PUSH
92091: LD_INT 3
92093: PUSH
92094: EMPTY
92095: LIST
92096: LIST
92097: PUSH
92098: LD_INT 4
92100: PUSH
92101: LD_INT 3
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 3
92110: PUSH
92111: LD_INT 4
92113: PUSH
92114: EMPTY
92115: LIST
92116: LIST
92117: PUSH
92118: EMPTY
92119: LIST
92120: LIST
92121: LIST
92122: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92123: LD_ADDR_VAR 0 26
92127: PUSH
92128: LD_INT 0
92130: PUSH
92131: LD_INT 3
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 1
92140: PUSH
92141: LD_INT 4
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: PUSH
92148: LD_INT 1
92150: NEG
92151: PUSH
92152: LD_INT 3
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: LIST
92163: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92164: LD_ADDR_VAR 0 27
92168: PUSH
92169: LD_INT 3
92171: NEG
92172: PUSH
92173: LD_INT 0
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: LD_INT 3
92182: NEG
92183: PUSH
92184: LD_INT 1
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: PUSH
92191: LD_INT 4
92193: NEG
92194: PUSH
92195: LD_INT 1
92197: NEG
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: LIST
92207: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92208: LD_ADDR_VAR 0 28
92212: PUSH
92213: LD_INT 3
92215: NEG
92216: PUSH
92217: LD_INT 3
92219: NEG
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 3
92227: NEG
92228: PUSH
92229: LD_INT 4
92231: NEG
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 4
92239: NEG
92240: PUSH
92241: LD_INT 3
92243: NEG
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: LIST
92253: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92254: LD_ADDR_VAR 0 29
92258: PUSH
92259: LD_INT 1
92261: NEG
92262: PUSH
92263: LD_INT 3
92265: NEG
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: LD_INT 0
92273: PUSH
92274: LD_INT 3
92276: NEG
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: PUSH
92282: LD_INT 1
92284: PUSH
92285: LD_INT 2
92287: NEG
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: PUSH
92293: LD_INT 1
92295: NEG
92296: PUSH
92297: LD_INT 4
92299: NEG
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: PUSH
92305: LD_INT 0
92307: PUSH
92308: LD_INT 4
92310: NEG
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: PUSH
92316: LD_INT 1
92318: PUSH
92319: LD_INT 3
92321: NEG
92322: PUSH
92323: EMPTY
92324: LIST
92325: LIST
92326: PUSH
92327: LD_INT 1
92329: NEG
92330: PUSH
92331: LD_INT 5
92333: NEG
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PUSH
92339: LD_INT 0
92341: PUSH
92342: LD_INT 5
92344: NEG
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: PUSH
92350: LD_INT 1
92352: PUSH
92353: LD_INT 4
92355: NEG
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: PUSH
92361: LD_INT 1
92363: NEG
92364: PUSH
92365: LD_INT 6
92367: NEG
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: PUSH
92373: LD_INT 0
92375: PUSH
92376: LD_INT 6
92378: NEG
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: PUSH
92384: LD_INT 1
92386: PUSH
92387: LD_INT 5
92389: NEG
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: LIST
92399: LIST
92400: LIST
92401: LIST
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92409: LD_ADDR_VAR 0 30
92413: PUSH
92414: LD_INT 2
92416: PUSH
92417: LD_INT 1
92419: NEG
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: PUSH
92425: LD_INT 3
92427: PUSH
92428: LD_INT 0
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: PUSH
92435: LD_INT 3
92437: PUSH
92438: LD_INT 1
92440: PUSH
92441: EMPTY
92442: LIST
92443: LIST
92444: PUSH
92445: LD_INT 3
92447: PUSH
92448: LD_INT 1
92450: NEG
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: PUSH
92456: LD_INT 4
92458: PUSH
92459: LD_INT 0
92461: PUSH
92462: EMPTY
92463: LIST
92464: LIST
92465: PUSH
92466: LD_INT 4
92468: PUSH
92469: LD_INT 1
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: PUSH
92476: LD_INT 4
92478: PUSH
92479: LD_INT 1
92481: NEG
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: LD_INT 5
92489: PUSH
92490: LD_INT 0
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: PUSH
92497: LD_INT 5
92499: PUSH
92500: LD_INT 1
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: LD_INT 5
92509: PUSH
92510: LD_INT 1
92512: NEG
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: LD_INT 6
92520: PUSH
92521: LD_INT 0
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: PUSH
92528: LD_INT 6
92530: PUSH
92531: LD_INT 1
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: PUSH
92538: EMPTY
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: LIST
92549: LIST
92550: LIST
92551: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92552: LD_ADDR_VAR 0 31
92556: PUSH
92557: LD_INT 3
92559: PUSH
92560: LD_INT 2
92562: PUSH
92563: EMPTY
92564: LIST
92565: LIST
92566: PUSH
92567: LD_INT 3
92569: PUSH
92570: LD_INT 3
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PUSH
92577: LD_INT 2
92579: PUSH
92580: LD_INT 3
92582: PUSH
92583: EMPTY
92584: LIST
92585: LIST
92586: PUSH
92587: LD_INT 4
92589: PUSH
92590: LD_INT 3
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: PUSH
92597: LD_INT 4
92599: PUSH
92600: LD_INT 4
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 3
92609: PUSH
92610: LD_INT 4
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: PUSH
92617: LD_INT 5
92619: PUSH
92620: LD_INT 4
92622: PUSH
92623: EMPTY
92624: LIST
92625: LIST
92626: PUSH
92627: LD_INT 5
92629: PUSH
92630: LD_INT 5
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: PUSH
92637: LD_INT 4
92639: PUSH
92640: LD_INT 5
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: PUSH
92647: LD_INT 6
92649: PUSH
92650: LD_INT 5
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: LD_INT 6
92659: PUSH
92660: LD_INT 6
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 5
92669: PUSH
92670: LD_INT 6
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92691: LD_ADDR_VAR 0 32
92695: PUSH
92696: LD_INT 1
92698: PUSH
92699: LD_INT 3
92701: PUSH
92702: EMPTY
92703: LIST
92704: LIST
92705: PUSH
92706: LD_INT 0
92708: PUSH
92709: LD_INT 3
92711: PUSH
92712: EMPTY
92713: LIST
92714: LIST
92715: PUSH
92716: LD_INT 1
92718: NEG
92719: PUSH
92720: LD_INT 2
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: PUSH
92727: LD_INT 1
92729: PUSH
92730: LD_INT 4
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 0
92739: PUSH
92740: LD_INT 4
92742: PUSH
92743: EMPTY
92744: LIST
92745: LIST
92746: PUSH
92747: LD_INT 1
92749: NEG
92750: PUSH
92751: LD_INT 3
92753: PUSH
92754: EMPTY
92755: LIST
92756: LIST
92757: PUSH
92758: LD_INT 1
92760: PUSH
92761: LD_INT 5
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 0
92770: PUSH
92771: LD_INT 5
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: LD_INT 1
92780: NEG
92781: PUSH
92782: LD_INT 4
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 1
92791: PUSH
92792: LD_INT 6
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 0
92801: PUSH
92802: LD_INT 6
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: PUSH
92809: LD_INT 1
92811: NEG
92812: PUSH
92813: LD_INT 5
92815: PUSH
92816: EMPTY
92817: LIST
92818: LIST
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92834: LD_ADDR_VAR 0 33
92838: PUSH
92839: LD_INT 2
92841: NEG
92842: PUSH
92843: LD_INT 1
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: PUSH
92850: LD_INT 3
92852: NEG
92853: PUSH
92854: LD_INT 0
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 3
92863: NEG
92864: PUSH
92865: LD_INT 1
92867: NEG
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 3
92875: NEG
92876: PUSH
92877: LD_INT 1
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: PUSH
92884: LD_INT 4
92886: NEG
92887: PUSH
92888: LD_INT 0
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 4
92897: NEG
92898: PUSH
92899: LD_INT 1
92901: NEG
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 4
92909: NEG
92910: PUSH
92911: LD_INT 1
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 5
92920: NEG
92921: PUSH
92922: LD_INT 0
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 5
92931: NEG
92932: PUSH
92933: LD_INT 1
92935: NEG
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: LD_INT 5
92943: NEG
92944: PUSH
92945: LD_INT 1
92947: PUSH
92948: EMPTY
92949: LIST
92950: LIST
92951: PUSH
92952: LD_INT 6
92954: NEG
92955: PUSH
92956: LD_INT 0
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 6
92965: NEG
92966: PUSH
92967: LD_INT 1
92969: NEG
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92989: LD_ADDR_VAR 0 34
92993: PUSH
92994: LD_INT 2
92996: NEG
92997: PUSH
92998: LD_INT 3
93000: NEG
93001: PUSH
93002: EMPTY
93003: LIST
93004: LIST
93005: PUSH
93006: LD_INT 3
93008: NEG
93009: PUSH
93010: LD_INT 2
93012: NEG
93013: PUSH
93014: EMPTY
93015: LIST
93016: LIST
93017: PUSH
93018: LD_INT 3
93020: NEG
93021: PUSH
93022: LD_INT 3
93024: NEG
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PUSH
93030: LD_INT 3
93032: NEG
93033: PUSH
93034: LD_INT 4
93036: NEG
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 4
93044: NEG
93045: PUSH
93046: LD_INT 3
93048: NEG
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: PUSH
93054: LD_INT 4
93056: NEG
93057: PUSH
93058: LD_INT 4
93060: NEG
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 4
93068: NEG
93069: PUSH
93070: LD_INT 5
93072: NEG
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: LD_INT 5
93080: NEG
93081: PUSH
93082: LD_INT 4
93084: NEG
93085: PUSH
93086: EMPTY
93087: LIST
93088: LIST
93089: PUSH
93090: LD_INT 5
93092: NEG
93093: PUSH
93094: LD_INT 5
93096: NEG
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 5
93104: NEG
93105: PUSH
93106: LD_INT 6
93108: NEG
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: LD_INT 6
93116: NEG
93117: PUSH
93118: LD_INT 5
93120: NEG
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 6
93128: NEG
93129: PUSH
93130: LD_INT 6
93132: NEG
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93152: LD_ADDR_VAR 0 41
93156: PUSH
93157: LD_INT 0
93159: PUSH
93160: LD_INT 2
93162: NEG
93163: PUSH
93164: EMPTY
93165: LIST
93166: LIST
93167: PUSH
93168: LD_INT 1
93170: NEG
93171: PUSH
93172: LD_INT 3
93174: NEG
93175: PUSH
93176: EMPTY
93177: LIST
93178: LIST
93179: PUSH
93180: LD_INT 1
93182: PUSH
93183: LD_INT 2
93185: NEG
93186: PUSH
93187: EMPTY
93188: LIST
93189: LIST
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: LIST
93195: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93196: LD_ADDR_VAR 0 42
93200: PUSH
93201: LD_INT 2
93203: PUSH
93204: LD_INT 0
93206: PUSH
93207: EMPTY
93208: LIST
93209: LIST
93210: PUSH
93211: LD_INT 2
93213: PUSH
93214: LD_INT 1
93216: NEG
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 3
93224: PUSH
93225: LD_INT 1
93227: PUSH
93228: EMPTY
93229: LIST
93230: LIST
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: LIST
93236: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93237: LD_ADDR_VAR 0 43
93241: PUSH
93242: LD_INT 2
93244: PUSH
93245: LD_INT 2
93247: PUSH
93248: EMPTY
93249: LIST
93250: LIST
93251: PUSH
93252: LD_INT 3
93254: PUSH
93255: LD_INT 2
93257: PUSH
93258: EMPTY
93259: LIST
93260: LIST
93261: PUSH
93262: LD_INT 2
93264: PUSH
93265: LD_INT 3
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: EMPTY
93273: LIST
93274: LIST
93275: LIST
93276: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93277: LD_ADDR_VAR 0 44
93281: PUSH
93282: LD_INT 0
93284: PUSH
93285: LD_INT 2
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: LD_INT 1
93294: PUSH
93295: LD_INT 3
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 1
93304: NEG
93305: PUSH
93306: LD_INT 2
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: LIST
93317: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93318: LD_ADDR_VAR 0 45
93322: PUSH
93323: LD_INT 2
93325: NEG
93326: PUSH
93327: LD_INT 0
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: PUSH
93334: LD_INT 2
93336: NEG
93337: PUSH
93338: LD_INT 1
93340: PUSH
93341: EMPTY
93342: LIST
93343: LIST
93344: PUSH
93345: LD_INT 3
93347: NEG
93348: PUSH
93349: LD_INT 1
93351: NEG
93352: PUSH
93353: EMPTY
93354: LIST
93355: LIST
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: LIST
93361: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93362: LD_ADDR_VAR 0 46
93366: PUSH
93367: LD_INT 2
93369: NEG
93370: PUSH
93371: LD_INT 2
93373: NEG
93374: PUSH
93375: EMPTY
93376: LIST
93377: LIST
93378: PUSH
93379: LD_INT 2
93381: NEG
93382: PUSH
93383: LD_INT 3
93385: NEG
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 3
93393: NEG
93394: PUSH
93395: LD_INT 2
93397: NEG
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: LIST
93407: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93408: LD_ADDR_VAR 0 47
93412: PUSH
93413: LD_INT 2
93415: NEG
93416: PUSH
93417: LD_INT 3
93419: NEG
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 1
93427: NEG
93428: PUSH
93429: LD_INT 3
93431: NEG
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93441: LD_ADDR_VAR 0 48
93445: PUSH
93446: LD_INT 1
93448: PUSH
93449: LD_INT 2
93451: NEG
93452: PUSH
93453: EMPTY
93454: LIST
93455: LIST
93456: PUSH
93457: LD_INT 2
93459: PUSH
93460: LD_INT 1
93462: NEG
93463: PUSH
93464: EMPTY
93465: LIST
93466: LIST
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93472: LD_ADDR_VAR 0 49
93476: PUSH
93477: LD_INT 3
93479: PUSH
93480: LD_INT 1
93482: PUSH
93483: EMPTY
93484: LIST
93485: LIST
93486: PUSH
93487: LD_INT 3
93489: PUSH
93490: LD_INT 2
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93501: LD_ADDR_VAR 0 50
93505: PUSH
93506: LD_INT 2
93508: PUSH
93509: LD_INT 3
93511: PUSH
93512: EMPTY
93513: LIST
93514: LIST
93515: PUSH
93516: LD_INT 1
93518: PUSH
93519: LD_INT 3
93521: PUSH
93522: EMPTY
93523: LIST
93524: LIST
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93530: LD_ADDR_VAR 0 51
93534: PUSH
93535: LD_INT 1
93537: NEG
93538: PUSH
93539: LD_INT 2
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: PUSH
93546: LD_INT 2
93548: NEG
93549: PUSH
93550: LD_INT 1
93552: PUSH
93553: EMPTY
93554: LIST
93555: LIST
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93561: LD_ADDR_VAR 0 52
93565: PUSH
93566: LD_INT 3
93568: NEG
93569: PUSH
93570: LD_INT 1
93572: NEG
93573: PUSH
93574: EMPTY
93575: LIST
93576: LIST
93577: PUSH
93578: LD_INT 3
93580: NEG
93581: PUSH
93582: LD_INT 2
93584: NEG
93585: PUSH
93586: EMPTY
93587: LIST
93588: LIST
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93594: LD_ADDR_VAR 0 53
93598: PUSH
93599: LD_INT 1
93601: NEG
93602: PUSH
93603: LD_INT 3
93605: NEG
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 0
93613: PUSH
93614: LD_INT 3
93616: NEG
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: LD_INT 1
93624: PUSH
93625: LD_INT 2
93627: NEG
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: LIST
93637: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93638: LD_ADDR_VAR 0 54
93642: PUSH
93643: LD_INT 2
93645: PUSH
93646: LD_INT 1
93648: NEG
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 3
93656: PUSH
93657: LD_INT 0
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: LD_INT 3
93666: PUSH
93667: LD_INT 1
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: PUSH
93674: EMPTY
93675: LIST
93676: LIST
93677: LIST
93678: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93679: LD_ADDR_VAR 0 55
93683: PUSH
93684: LD_INT 3
93686: PUSH
93687: LD_INT 2
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 3
93696: PUSH
93697: LD_INT 3
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: PUSH
93704: LD_INT 2
93706: PUSH
93707: LD_INT 3
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: LIST
93718: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93719: LD_ADDR_VAR 0 56
93723: PUSH
93724: LD_INT 1
93726: PUSH
93727: LD_INT 3
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: LD_INT 0
93736: PUSH
93737: LD_INT 3
93739: PUSH
93740: EMPTY
93741: LIST
93742: LIST
93743: PUSH
93744: LD_INT 1
93746: NEG
93747: PUSH
93748: LD_INT 2
93750: PUSH
93751: EMPTY
93752: LIST
93753: LIST
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: LIST
93759: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93760: LD_ADDR_VAR 0 57
93764: PUSH
93765: LD_INT 2
93767: NEG
93768: PUSH
93769: LD_INT 1
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: PUSH
93776: LD_INT 3
93778: NEG
93779: PUSH
93780: LD_INT 0
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 3
93789: NEG
93790: PUSH
93791: LD_INT 1
93793: NEG
93794: PUSH
93795: EMPTY
93796: LIST
93797: LIST
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: LIST
93803: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93804: LD_ADDR_VAR 0 58
93808: PUSH
93809: LD_INT 2
93811: NEG
93812: PUSH
93813: LD_INT 3
93815: NEG
93816: PUSH
93817: EMPTY
93818: LIST
93819: LIST
93820: PUSH
93821: LD_INT 3
93823: NEG
93824: PUSH
93825: LD_INT 2
93827: NEG
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 3
93835: NEG
93836: PUSH
93837: LD_INT 3
93839: NEG
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: LIST
93849: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93850: LD_ADDR_VAR 0 59
93854: PUSH
93855: LD_INT 1
93857: NEG
93858: PUSH
93859: LD_INT 2
93861: NEG
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: PUSH
93867: LD_INT 0
93869: PUSH
93870: LD_INT 2
93872: NEG
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: PUSH
93878: LD_INT 1
93880: PUSH
93881: LD_INT 1
93883: NEG
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: LIST
93893: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93894: LD_ADDR_VAR 0 60
93898: PUSH
93899: LD_INT 1
93901: PUSH
93902: LD_INT 1
93904: NEG
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: LD_INT 2
93912: PUSH
93913: LD_INT 0
93915: PUSH
93916: EMPTY
93917: LIST
93918: LIST
93919: PUSH
93920: LD_INT 2
93922: PUSH
93923: LD_INT 1
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: EMPTY
93931: LIST
93932: LIST
93933: LIST
93934: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93935: LD_ADDR_VAR 0 61
93939: PUSH
93940: LD_INT 2
93942: PUSH
93943: LD_INT 1
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: PUSH
93950: LD_INT 2
93952: PUSH
93953: LD_INT 2
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: LD_INT 1
93962: PUSH
93963: LD_INT 2
93965: PUSH
93966: EMPTY
93967: LIST
93968: LIST
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: LIST
93974: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93975: LD_ADDR_VAR 0 62
93979: PUSH
93980: LD_INT 1
93982: PUSH
93983: LD_INT 2
93985: PUSH
93986: EMPTY
93987: LIST
93988: LIST
93989: PUSH
93990: LD_INT 0
93992: PUSH
93993: LD_INT 2
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 1
94002: NEG
94003: PUSH
94004: LD_INT 1
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: LIST
94015: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94016: LD_ADDR_VAR 0 63
94020: PUSH
94021: LD_INT 1
94023: NEG
94024: PUSH
94025: LD_INT 1
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: PUSH
94032: LD_INT 2
94034: NEG
94035: PUSH
94036: LD_INT 0
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 2
94045: NEG
94046: PUSH
94047: LD_INT 1
94049: NEG
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: LIST
94059: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94060: LD_ADDR_VAR 0 64
94064: PUSH
94065: LD_INT 1
94067: NEG
94068: PUSH
94069: LD_INT 2
94071: NEG
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: PUSH
94077: LD_INT 2
94079: NEG
94080: PUSH
94081: LD_INT 1
94083: NEG
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 2
94091: NEG
94092: PUSH
94093: LD_INT 2
94095: NEG
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: LIST
94105: ST_TO_ADDR
// end ; 2 :
94106: GO 97372
94108: LD_INT 2
94110: DOUBLE
94111: EQUAL
94112: IFTRUE 94116
94114: GO 97371
94116: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94117: LD_ADDR_VAR 0 29
94121: PUSH
94122: LD_INT 4
94124: PUSH
94125: LD_INT 0
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: PUSH
94132: LD_INT 4
94134: PUSH
94135: LD_INT 1
94137: NEG
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: PUSH
94143: LD_INT 5
94145: PUSH
94146: LD_INT 0
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: PUSH
94153: LD_INT 5
94155: PUSH
94156: LD_INT 1
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 4
94165: PUSH
94166: LD_INT 1
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: PUSH
94173: LD_INT 3
94175: PUSH
94176: LD_INT 0
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 3
94185: PUSH
94186: LD_INT 1
94188: NEG
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: LD_INT 3
94196: PUSH
94197: LD_INT 2
94199: NEG
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: PUSH
94205: LD_INT 5
94207: PUSH
94208: LD_INT 2
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 3
94217: PUSH
94218: LD_INT 3
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 3
94227: PUSH
94228: LD_INT 2
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 4
94237: PUSH
94238: LD_INT 3
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: PUSH
94245: LD_INT 4
94247: PUSH
94248: LD_INT 4
94250: PUSH
94251: EMPTY
94252: LIST
94253: LIST
94254: PUSH
94255: LD_INT 3
94257: PUSH
94258: LD_INT 4
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: PUSH
94265: LD_INT 2
94267: PUSH
94268: LD_INT 3
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 2
94277: PUSH
94278: LD_INT 2
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 4
94287: PUSH
94288: LD_INT 2
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 2
94297: PUSH
94298: LD_INT 4
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PUSH
94305: LD_INT 0
94307: PUSH
94308: LD_INT 4
94310: PUSH
94311: EMPTY
94312: LIST
94313: LIST
94314: PUSH
94315: LD_INT 0
94317: PUSH
94318: LD_INT 3
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: LD_INT 1
94327: PUSH
94328: LD_INT 4
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 1
94337: PUSH
94338: LD_INT 5
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 0
94347: PUSH
94348: LD_INT 5
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 1
94357: NEG
94358: PUSH
94359: LD_INT 4
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 1
94368: NEG
94369: PUSH
94370: LD_INT 3
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: PUSH
94377: LD_INT 2
94379: PUSH
94380: LD_INT 5
94382: PUSH
94383: EMPTY
94384: LIST
94385: LIST
94386: PUSH
94387: LD_INT 2
94389: NEG
94390: PUSH
94391: LD_INT 3
94393: PUSH
94394: EMPTY
94395: LIST
94396: LIST
94397: PUSH
94398: LD_INT 3
94400: NEG
94401: PUSH
94402: LD_INT 0
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: PUSH
94409: LD_INT 3
94411: NEG
94412: PUSH
94413: LD_INT 1
94415: NEG
94416: PUSH
94417: EMPTY
94418: LIST
94419: LIST
94420: PUSH
94421: LD_INT 2
94423: NEG
94424: PUSH
94425: LD_INT 0
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: LD_INT 2
94434: NEG
94435: PUSH
94436: LD_INT 1
94438: PUSH
94439: EMPTY
94440: LIST
94441: LIST
94442: PUSH
94443: LD_INT 3
94445: NEG
94446: PUSH
94447: LD_INT 1
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PUSH
94454: LD_INT 4
94456: NEG
94457: PUSH
94458: LD_INT 0
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: LD_INT 4
94467: NEG
94468: PUSH
94469: LD_INT 1
94471: NEG
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PUSH
94477: LD_INT 4
94479: NEG
94480: PUSH
94481: LD_INT 2
94483: NEG
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PUSH
94489: LD_INT 2
94491: NEG
94492: PUSH
94493: LD_INT 2
94495: PUSH
94496: EMPTY
94497: LIST
94498: LIST
94499: PUSH
94500: LD_INT 4
94502: NEG
94503: PUSH
94504: LD_INT 4
94506: NEG
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 4
94514: NEG
94515: PUSH
94516: LD_INT 5
94518: NEG
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: PUSH
94524: LD_INT 3
94526: NEG
94527: PUSH
94528: LD_INT 4
94530: NEG
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: LD_INT 3
94538: NEG
94539: PUSH
94540: LD_INT 3
94542: NEG
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: LD_INT 4
94550: NEG
94551: PUSH
94552: LD_INT 3
94554: NEG
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 5
94562: NEG
94563: PUSH
94564: LD_INT 4
94566: NEG
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 5
94574: NEG
94575: PUSH
94576: LD_INT 5
94578: NEG
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: PUSH
94584: LD_INT 3
94586: NEG
94587: PUSH
94588: LD_INT 5
94590: NEG
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 5
94598: NEG
94599: PUSH
94600: LD_INT 3
94602: NEG
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: LIST
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94655: LD_ADDR_VAR 0 30
94659: PUSH
94660: LD_INT 4
94662: PUSH
94663: LD_INT 4
94665: PUSH
94666: EMPTY
94667: LIST
94668: LIST
94669: PUSH
94670: LD_INT 4
94672: PUSH
94673: LD_INT 3
94675: PUSH
94676: EMPTY
94677: LIST
94678: LIST
94679: PUSH
94680: LD_INT 5
94682: PUSH
94683: LD_INT 4
94685: PUSH
94686: EMPTY
94687: LIST
94688: LIST
94689: PUSH
94690: LD_INT 5
94692: PUSH
94693: LD_INT 5
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: PUSH
94700: LD_INT 4
94702: PUSH
94703: LD_INT 5
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: PUSH
94710: LD_INT 3
94712: PUSH
94713: LD_INT 4
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 3
94722: PUSH
94723: LD_INT 3
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 5
94732: PUSH
94733: LD_INT 3
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 3
94742: PUSH
94743: LD_INT 5
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: PUSH
94750: LD_INT 0
94752: PUSH
94753: LD_INT 3
94755: PUSH
94756: EMPTY
94757: LIST
94758: LIST
94759: PUSH
94760: LD_INT 0
94762: PUSH
94763: LD_INT 2
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 1
94772: PUSH
94773: LD_INT 3
94775: PUSH
94776: EMPTY
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 1
94782: PUSH
94783: LD_INT 4
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 0
94792: PUSH
94793: LD_INT 4
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 1
94802: NEG
94803: PUSH
94804: LD_INT 3
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: PUSH
94811: LD_INT 1
94813: NEG
94814: PUSH
94815: LD_INT 2
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: PUSH
94822: LD_INT 2
94824: PUSH
94825: LD_INT 4
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: PUSH
94832: LD_INT 2
94834: NEG
94835: PUSH
94836: LD_INT 2
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 4
94845: NEG
94846: PUSH
94847: LD_INT 0
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 4
94856: NEG
94857: PUSH
94858: LD_INT 1
94860: NEG
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: LD_INT 3
94868: NEG
94869: PUSH
94870: LD_INT 0
94872: PUSH
94873: EMPTY
94874: LIST
94875: LIST
94876: PUSH
94877: LD_INT 3
94879: NEG
94880: PUSH
94881: LD_INT 1
94883: PUSH
94884: EMPTY
94885: LIST
94886: LIST
94887: PUSH
94888: LD_INT 4
94890: NEG
94891: PUSH
94892: LD_INT 1
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 5
94901: NEG
94902: PUSH
94903: LD_INT 0
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: LD_INT 5
94912: NEG
94913: PUSH
94914: LD_INT 1
94916: NEG
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 5
94924: NEG
94925: PUSH
94926: LD_INT 2
94928: NEG
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 3
94936: NEG
94937: PUSH
94938: LD_INT 2
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 3
94947: NEG
94948: PUSH
94949: LD_INT 3
94951: NEG
94952: PUSH
94953: EMPTY
94954: LIST
94955: LIST
94956: PUSH
94957: LD_INT 3
94959: NEG
94960: PUSH
94961: LD_INT 4
94963: NEG
94964: PUSH
94965: EMPTY
94966: LIST
94967: LIST
94968: PUSH
94969: LD_INT 2
94971: NEG
94972: PUSH
94973: LD_INT 3
94975: NEG
94976: PUSH
94977: EMPTY
94978: LIST
94979: LIST
94980: PUSH
94981: LD_INT 2
94983: NEG
94984: PUSH
94985: LD_INT 2
94987: NEG
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: PUSH
94993: LD_INT 3
94995: NEG
94996: PUSH
94997: LD_INT 2
94999: NEG
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: LD_INT 4
95007: NEG
95008: PUSH
95009: LD_INT 3
95011: NEG
95012: PUSH
95013: EMPTY
95014: LIST
95015: LIST
95016: PUSH
95017: LD_INT 4
95019: NEG
95020: PUSH
95021: LD_INT 4
95023: NEG
95024: PUSH
95025: EMPTY
95026: LIST
95027: LIST
95028: PUSH
95029: LD_INT 2
95031: NEG
95032: PUSH
95033: LD_INT 4
95035: NEG
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: PUSH
95041: LD_INT 4
95043: NEG
95044: PUSH
95045: LD_INT 2
95047: NEG
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: PUSH
95053: LD_INT 0
95055: PUSH
95056: LD_INT 4
95058: NEG
95059: PUSH
95060: EMPTY
95061: LIST
95062: LIST
95063: PUSH
95064: LD_INT 0
95066: PUSH
95067: LD_INT 5
95069: NEG
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: PUSH
95075: LD_INT 1
95077: PUSH
95078: LD_INT 4
95080: NEG
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 1
95088: PUSH
95089: LD_INT 3
95091: NEG
95092: PUSH
95093: EMPTY
95094: LIST
95095: LIST
95096: PUSH
95097: LD_INT 0
95099: PUSH
95100: LD_INT 3
95102: NEG
95103: PUSH
95104: EMPTY
95105: LIST
95106: LIST
95107: PUSH
95108: LD_INT 1
95110: NEG
95111: PUSH
95112: LD_INT 4
95114: NEG
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 1
95122: NEG
95123: PUSH
95124: LD_INT 5
95126: NEG
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 2
95134: PUSH
95135: LD_INT 3
95137: NEG
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_INT 2
95145: NEG
95146: PUSH
95147: LD_INT 5
95149: NEG
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95202: LD_ADDR_VAR 0 31
95206: PUSH
95207: LD_INT 0
95209: PUSH
95210: LD_INT 4
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: PUSH
95217: LD_INT 0
95219: PUSH
95220: LD_INT 3
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 1
95229: PUSH
95230: LD_INT 4
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 1
95239: PUSH
95240: LD_INT 5
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: LD_INT 0
95249: PUSH
95250: LD_INT 5
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 1
95259: NEG
95260: PUSH
95261: LD_INT 4
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: LD_INT 1
95270: NEG
95271: PUSH
95272: LD_INT 3
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 2
95281: PUSH
95282: LD_INT 5
95284: PUSH
95285: EMPTY
95286: LIST
95287: LIST
95288: PUSH
95289: LD_INT 2
95291: NEG
95292: PUSH
95293: LD_INT 3
95295: PUSH
95296: EMPTY
95297: LIST
95298: LIST
95299: PUSH
95300: LD_INT 3
95302: NEG
95303: PUSH
95304: LD_INT 0
95306: PUSH
95307: EMPTY
95308: LIST
95309: LIST
95310: PUSH
95311: LD_INT 3
95313: NEG
95314: PUSH
95315: LD_INT 1
95317: NEG
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: PUSH
95323: LD_INT 2
95325: NEG
95326: PUSH
95327: LD_INT 0
95329: PUSH
95330: EMPTY
95331: LIST
95332: LIST
95333: PUSH
95334: LD_INT 2
95336: NEG
95337: PUSH
95338: LD_INT 1
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 3
95347: NEG
95348: PUSH
95349: LD_INT 1
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 4
95358: NEG
95359: PUSH
95360: LD_INT 0
95362: PUSH
95363: EMPTY
95364: LIST
95365: LIST
95366: PUSH
95367: LD_INT 4
95369: NEG
95370: PUSH
95371: LD_INT 1
95373: NEG
95374: PUSH
95375: EMPTY
95376: LIST
95377: LIST
95378: PUSH
95379: LD_INT 4
95381: NEG
95382: PUSH
95383: LD_INT 2
95385: NEG
95386: PUSH
95387: EMPTY
95388: LIST
95389: LIST
95390: PUSH
95391: LD_INT 2
95393: NEG
95394: PUSH
95395: LD_INT 2
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: PUSH
95402: LD_INT 4
95404: NEG
95405: PUSH
95406: LD_INT 4
95408: NEG
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: PUSH
95414: LD_INT 4
95416: NEG
95417: PUSH
95418: LD_INT 5
95420: NEG
95421: PUSH
95422: EMPTY
95423: LIST
95424: LIST
95425: PUSH
95426: LD_INT 3
95428: NEG
95429: PUSH
95430: LD_INT 4
95432: NEG
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 3
95440: NEG
95441: PUSH
95442: LD_INT 3
95444: NEG
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 4
95452: NEG
95453: PUSH
95454: LD_INT 3
95456: NEG
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 5
95464: NEG
95465: PUSH
95466: LD_INT 4
95468: NEG
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: PUSH
95474: LD_INT 5
95476: NEG
95477: PUSH
95478: LD_INT 5
95480: NEG
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 3
95488: NEG
95489: PUSH
95490: LD_INT 5
95492: NEG
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: PUSH
95498: LD_INT 5
95500: NEG
95501: PUSH
95502: LD_INT 3
95504: NEG
95505: PUSH
95506: EMPTY
95507: LIST
95508: LIST
95509: PUSH
95510: LD_INT 0
95512: PUSH
95513: LD_INT 3
95515: NEG
95516: PUSH
95517: EMPTY
95518: LIST
95519: LIST
95520: PUSH
95521: LD_INT 0
95523: PUSH
95524: LD_INT 4
95526: NEG
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: PUSH
95532: LD_INT 1
95534: PUSH
95535: LD_INT 3
95537: NEG
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PUSH
95543: LD_INT 1
95545: PUSH
95546: LD_INT 2
95548: NEG
95549: PUSH
95550: EMPTY
95551: LIST
95552: LIST
95553: PUSH
95554: LD_INT 0
95556: PUSH
95557: LD_INT 2
95559: NEG
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PUSH
95565: LD_INT 1
95567: NEG
95568: PUSH
95569: LD_INT 3
95571: NEG
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 1
95579: NEG
95580: PUSH
95581: LD_INT 4
95583: NEG
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: PUSH
95589: LD_INT 2
95591: PUSH
95592: LD_INT 2
95594: NEG
95595: PUSH
95596: EMPTY
95597: LIST
95598: LIST
95599: PUSH
95600: LD_INT 2
95602: NEG
95603: PUSH
95604: LD_INT 4
95606: NEG
95607: PUSH
95608: EMPTY
95609: LIST
95610: LIST
95611: PUSH
95612: LD_INT 4
95614: PUSH
95615: LD_INT 0
95617: PUSH
95618: EMPTY
95619: LIST
95620: LIST
95621: PUSH
95622: LD_INT 4
95624: PUSH
95625: LD_INT 1
95627: NEG
95628: PUSH
95629: EMPTY
95630: LIST
95631: LIST
95632: PUSH
95633: LD_INT 5
95635: PUSH
95636: LD_INT 0
95638: PUSH
95639: EMPTY
95640: LIST
95641: LIST
95642: PUSH
95643: LD_INT 5
95645: PUSH
95646: LD_INT 1
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: PUSH
95653: LD_INT 4
95655: PUSH
95656: LD_INT 1
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: PUSH
95663: LD_INT 3
95665: PUSH
95666: LD_INT 0
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: PUSH
95673: LD_INT 3
95675: PUSH
95676: LD_INT 1
95678: NEG
95679: PUSH
95680: EMPTY
95681: LIST
95682: LIST
95683: PUSH
95684: LD_INT 3
95686: PUSH
95687: LD_INT 2
95689: NEG
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 5
95697: PUSH
95698: LD_INT 2
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: EMPTY
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95752: LD_ADDR_VAR 0 32
95756: PUSH
95757: LD_INT 4
95759: NEG
95760: PUSH
95761: LD_INT 0
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: LD_INT 4
95770: NEG
95771: PUSH
95772: LD_INT 1
95774: NEG
95775: PUSH
95776: EMPTY
95777: LIST
95778: LIST
95779: PUSH
95780: LD_INT 3
95782: NEG
95783: PUSH
95784: LD_INT 0
95786: PUSH
95787: EMPTY
95788: LIST
95789: LIST
95790: PUSH
95791: LD_INT 3
95793: NEG
95794: PUSH
95795: LD_INT 1
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 4
95804: NEG
95805: PUSH
95806: LD_INT 1
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: PUSH
95813: LD_INT 5
95815: NEG
95816: PUSH
95817: LD_INT 0
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: PUSH
95824: LD_INT 5
95826: NEG
95827: PUSH
95828: LD_INT 1
95830: NEG
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: LD_INT 5
95838: NEG
95839: PUSH
95840: LD_INT 2
95842: NEG
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: PUSH
95848: LD_INT 3
95850: NEG
95851: PUSH
95852: LD_INT 2
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 3
95861: NEG
95862: PUSH
95863: LD_INT 3
95865: NEG
95866: PUSH
95867: EMPTY
95868: LIST
95869: LIST
95870: PUSH
95871: LD_INT 3
95873: NEG
95874: PUSH
95875: LD_INT 4
95877: NEG
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: PUSH
95883: LD_INT 2
95885: NEG
95886: PUSH
95887: LD_INT 3
95889: NEG
95890: PUSH
95891: EMPTY
95892: LIST
95893: LIST
95894: PUSH
95895: LD_INT 2
95897: NEG
95898: PUSH
95899: LD_INT 2
95901: NEG
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 3
95909: NEG
95910: PUSH
95911: LD_INT 2
95913: NEG
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 4
95921: NEG
95922: PUSH
95923: LD_INT 3
95925: NEG
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: LD_INT 4
95933: NEG
95934: PUSH
95935: LD_INT 4
95937: NEG
95938: PUSH
95939: EMPTY
95940: LIST
95941: LIST
95942: PUSH
95943: LD_INT 2
95945: NEG
95946: PUSH
95947: LD_INT 4
95949: NEG
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: PUSH
95955: LD_INT 4
95957: NEG
95958: PUSH
95959: LD_INT 2
95961: NEG
95962: PUSH
95963: EMPTY
95964: LIST
95965: LIST
95966: PUSH
95967: LD_INT 0
95969: PUSH
95970: LD_INT 4
95972: NEG
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 0
95980: PUSH
95981: LD_INT 5
95983: NEG
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: PUSH
95989: LD_INT 1
95991: PUSH
95992: LD_INT 4
95994: NEG
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: PUSH
96000: LD_INT 1
96002: PUSH
96003: LD_INT 3
96005: NEG
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: PUSH
96011: LD_INT 0
96013: PUSH
96014: LD_INT 3
96016: NEG
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: PUSH
96022: LD_INT 1
96024: NEG
96025: PUSH
96026: LD_INT 4
96028: NEG
96029: PUSH
96030: EMPTY
96031: LIST
96032: LIST
96033: PUSH
96034: LD_INT 1
96036: NEG
96037: PUSH
96038: LD_INT 5
96040: NEG
96041: PUSH
96042: EMPTY
96043: LIST
96044: LIST
96045: PUSH
96046: LD_INT 2
96048: PUSH
96049: LD_INT 3
96051: NEG
96052: PUSH
96053: EMPTY
96054: LIST
96055: LIST
96056: PUSH
96057: LD_INT 2
96059: NEG
96060: PUSH
96061: LD_INT 5
96063: NEG
96064: PUSH
96065: EMPTY
96066: LIST
96067: LIST
96068: PUSH
96069: LD_INT 3
96071: PUSH
96072: LD_INT 0
96074: PUSH
96075: EMPTY
96076: LIST
96077: LIST
96078: PUSH
96079: LD_INT 3
96081: PUSH
96082: LD_INT 1
96084: NEG
96085: PUSH
96086: EMPTY
96087: LIST
96088: LIST
96089: PUSH
96090: LD_INT 4
96092: PUSH
96093: LD_INT 0
96095: PUSH
96096: EMPTY
96097: LIST
96098: LIST
96099: PUSH
96100: LD_INT 4
96102: PUSH
96103: LD_INT 1
96105: PUSH
96106: EMPTY
96107: LIST
96108: LIST
96109: PUSH
96110: LD_INT 3
96112: PUSH
96113: LD_INT 1
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 2
96122: PUSH
96123: LD_INT 0
96125: PUSH
96126: EMPTY
96127: LIST
96128: LIST
96129: PUSH
96130: LD_INT 2
96132: PUSH
96133: LD_INT 1
96135: NEG
96136: PUSH
96137: EMPTY
96138: LIST
96139: LIST
96140: PUSH
96141: LD_INT 2
96143: PUSH
96144: LD_INT 2
96146: NEG
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 4
96154: PUSH
96155: LD_INT 2
96157: PUSH
96158: EMPTY
96159: LIST
96160: LIST
96161: PUSH
96162: LD_INT 4
96164: PUSH
96165: LD_INT 4
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: PUSH
96172: LD_INT 4
96174: PUSH
96175: LD_INT 3
96177: PUSH
96178: EMPTY
96179: LIST
96180: LIST
96181: PUSH
96182: LD_INT 5
96184: PUSH
96185: LD_INT 4
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: PUSH
96192: LD_INT 5
96194: PUSH
96195: LD_INT 5
96197: PUSH
96198: EMPTY
96199: LIST
96200: LIST
96201: PUSH
96202: LD_INT 4
96204: PUSH
96205: LD_INT 5
96207: PUSH
96208: EMPTY
96209: LIST
96210: LIST
96211: PUSH
96212: LD_INT 3
96214: PUSH
96215: LD_INT 4
96217: PUSH
96218: EMPTY
96219: LIST
96220: LIST
96221: PUSH
96222: LD_INT 3
96224: PUSH
96225: LD_INT 3
96227: PUSH
96228: EMPTY
96229: LIST
96230: LIST
96231: PUSH
96232: LD_INT 5
96234: PUSH
96235: LD_INT 3
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: LD_INT 3
96244: PUSH
96245: LD_INT 5
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: PUSH
96252: EMPTY
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96299: LD_ADDR_VAR 0 33
96303: PUSH
96304: LD_INT 4
96306: NEG
96307: PUSH
96308: LD_INT 4
96310: NEG
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 4
96318: NEG
96319: PUSH
96320: LD_INT 5
96322: NEG
96323: PUSH
96324: EMPTY
96325: LIST
96326: LIST
96327: PUSH
96328: LD_INT 3
96330: NEG
96331: PUSH
96332: LD_INT 4
96334: NEG
96335: PUSH
96336: EMPTY
96337: LIST
96338: LIST
96339: PUSH
96340: LD_INT 3
96342: NEG
96343: PUSH
96344: LD_INT 3
96346: NEG
96347: PUSH
96348: EMPTY
96349: LIST
96350: LIST
96351: PUSH
96352: LD_INT 4
96354: NEG
96355: PUSH
96356: LD_INT 3
96358: NEG
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: LD_INT 5
96366: NEG
96367: PUSH
96368: LD_INT 4
96370: NEG
96371: PUSH
96372: EMPTY
96373: LIST
96374: LIST
96375: PUSH
96376: LD_INT 5
96378: NEG
96379: PUSH
96380: LD_INT 5
96382: NEG
96383: PUSH
96384: EMPTY
96385: LIST
96386: LIST
96387: PUSH
96388: LD_INT 3
96390: NEG
96391: PUSH
96392: LD_INT 5
96394: NEG
96395: PUSH
96396: EMPTY
96397: LIST
96398: LIST
96399: PUSH
96400: LD_INT 5
96402: NEG
96403: PUSH
96404: LD_INT 3
96406: NEG
96407: PUSH
96408: EMPTY
96409: LIST
96410: LIST
96411: PUSH
96412: LD_INT 0
96414: PUSH
96415: LD_INT 3
96417: NEG
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: PUSH
96423: LD_INT 0
96425: PUSH
96426: LD_INT 4
96428: NEG
96429: PUSH
96430: EMPTY
96431: LIST
96432: LIST
96433: PUSH
96434: LD_INT 1
96436: PUSH
96437: LD_INT 3
96439: NEG
96440: PUSH
96441: EMPTY
96442: LIST
96443: LIST
96444: PUSH
96445: LD_INT 1
96447: PUSH
96448: LD_INT 2
96450: NEG
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: LD_INT 0
96458: PUSH
96459: LD_INT 2
96461: NEG
96462: PUSH
96463: EMPTY
96464: LIST
96465: LIST
96466: PUSH
96467: LD_INT 1
96469: NEG
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: EMPTY
96476: LIST
96477: LIST
96478: PUSH
96479: LD_INT 1
96481: NEG
96482: PUSH
96483: LD_INT 4
96485: NEG
96486: PUSH
96487: EMPTY
96488: LIST
96489: LIST
96490: PUSH
96491: LD_INT 2
96493: PUSH
96494: LD_INT 2
96496: NEG
96497: PUSH
96498: EMPTY
96499: LIST
96500: LIST
96501: PUSH
96502: LD_INT 2
96504: NEG
96505: PUSH
96506: LD_INT 4
96508: NEG
96509: PUSH
96510: EMPTY
96511: LIST
96512: LIST
96513: PUSH
96514: LD_INT 4
96516: PUSH
96517: LD_INT 0
96519: PUSH
96520: EMPTY
96521: LIST
96522: LIST
96523: PUSH
96524: LD_INT 4
96526: PUSH
96527: LD_INT 1
96529: NEG
96530: PUSH
96531: EMPTY
96532: LIST
96533: LIST
96534: PUSH
96535: LD_INT 5
96537: PUSH
96538: LD_INT 0
96540: PUSH
96541: EMPTY
96542: LIST
96543: LIST
96544: PUSH
96545: LD_INT 5
96547: PUSH
96548: LD_INT 1
96550: PUSH
96551: EMPTY
96552: LIST
96553: LIST
96554: PUSH
96555: LD_INT 4
96557: PUSH
96558: LD_INT 1
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 3
96567: PUSH
96568: LD_INT 0
96570: PUSH
96571: EMPTY
96572: LIST
96573: LIST
96574: PUSH
96575: LD_INT 3
96577: PUSH
96578: LD_INT 1
96580: NEG
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: PUSH
96586: LD_INT 3
96588: PUSH
96589: LD_INT 2
96591: NEG
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: PUSH
96597: LD_INT 5
96599: PUSH
96600: LD_INT 2
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: PUSH
96607: LD_INT 3
96609: PUSH
96610: LD_INT 3
96612: PUSH
96613: EMPTY
96614: LIST
96615: LIST
96616: PUSH
96617: LD_INT 3
96619: PUSH
96620: LD_INT 2
96622: PUSH
96623: EMPTY
96624: LIST
96625: LIST
96626: PUSH
96627: LD_INT 4
96629: PUSH
96630: LD_INT 3
96632: PUSH
96633: EMPTY
96634: LIST
96635: LIST
96636: PUSH
96637: LD_INT 4
96639: PUSH
96640: LD_INT 4
96642: PUSH
96643: EMPTY
96644: LIST
96645: LIST
96646: PUSH
96647: LD_INT 3
96649: PUSH
96650: LD_INT 4
96652: PUSH
96653: EMPTY
96654: LIST
96655: LIST
96656: PUSH
96657: LD_INT 2
96659: PUSH
96660: LD_INT 3
96662: PUSH
96663: EMPTY
96664: LIST
96665: LIST
96666: PUSH
96667: LD_INT 2
96669: PUSH
96670: LD_INT 2
96672: PUSH
96673: EMPTY
96674: LIST
96675: LIST
96676: PUSH
96677: LD_INT 4
96679: PUSH
96680: LD_INT 2
96682: PUSH
96683: EMPTY
96684: LIST
96685: LIST
96686: PUSH
96687: LD_INT 2
96689: PUSH
96690: LD_INT 4
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: PUSH
96697: LD_INT 0
96699: PUSH
96700: LD_INT 4
96702: PUSH
96703: EMPTY
96704: LIST
96705: LIST
96706: PUSH
96707: LD_INT 0
96709: PUSH
96710: LD_INT 3
96712: PUSH
96713: EMPTY
96714: LIST
96715: LIST
96716: PUSH
96717: LD_INT 1
96719: PUSH
96720: LD_INT 4
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: PUSH
96727: LD_INT 1
96729: PUSH
96730: LD_INT 5
96732: PUSH
96733: EMPTY
96734: LIST
96735: LIST
96736: PUSH
96737: LD_INT 0
96739: PUSH
96740: LD_INT 5
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: PUSH
96747: LD_INT 1
96749: NEG
96750: PUSH
96751: LD_INT 4
96753: PUSH
96754: EMPTY
96755: LIST
96756: LIST
96757: PUSH
96758: LD_INT 1
96760: NEG
96761: PUSH
96762: LD_INT 3
96764: PUSH
96765: EMPTY
96766: LIST
96767: LIST
96768: PUSH
96769: LD_INT 2
96771: PUSH
96772: LD_INT 5
96774: PUSH
96775: EMPTY
96776: LIST
96777: LIST
96778: PUSH
96779: LD_INT 2
96781: NEG
96782: PUSH
96783: LD_INT 3
96785: PUSH
96786: EMPTY
96787: LIST
96788: LIST
96789: PUSH
96790: EMPTY
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96837: LD_ADDR_VAR 0 34
96841: PUSH
96842: LD_INT 0
96844: PUSH
96845: LD_INT 4
96847: NEG
96848: PUSH
96849: EMPTY
96850: LIST
96851: LIST
96852: PUSH
96853: LD_INT 0
96855: PUSH
96856: LD_INT 5
96858: NEG
96859: PUSH
96860: EMPTY
96861: LIST
96862: LIST
96863: PUSH
96864: LD_INT 1
96866: PUSH
96867: LD_INT 4
96869: NEG
96870: PUSH
96871: EMPTY
96872: LIST
96873: LIST
96874: PUSH
96875: LD_INT 1
96877: PUSH
96878: LD_INT 3
96880: NEG
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 0
96888: PUSH
96889: LD_INT 3
96891: NEG
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: PUSH
96897: LD_INT 1
96899: NEG
96900: PUSH
96901: LD_INT 4
96903: NEG
96904: PUSH
96905: EMPTY
96906: LIST
96907: LIST
96908: PUSH
96909: LD_INT 1
96911: NEG
96912: PUSH
96913: LD_INT 5
96915: NEG
96916: PUSH
96917: EMPTY
96918: LIST
96919: LIST
96920: PUSH
96921: LD_INT 2
96923: PUSH
96924: LD_INT 3
96926: NEG
96927: PUSH
96928: EMPTY
96929: LIST
96930: LIST
96931: PUSH
96932: LD_INT 2
96934: NEG
96935: PUSH
96936: LD_INT 5
96938: NEG
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: LD_INT 3
96946: PUSH
96947: LD_INT 0
96949: PUSH
96950: EMPTY
96951: LIST
96952: LIST
96953: PUSH
96954: LD_INT 3
96956: PUSH
96957: LD_INT 1
96959: NEG
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: PUSH
96965: LD_INT 4
96967: PUSH
96968: LD_INT 0
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: LD_INT 4
96977: PUSH
96978: LD_INT 1
96980: PUSH
96981: EMPTY
96982: LIST
96983: LIST
96984: PUSH
96985: LD_INT 3
96987: PUSH
96988: LD_INT 1
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: PUSH
96995: LD_INT 2
96997: PUSH
96998: LD_INT 0
97000: PUSH
97001: EMPTY
97002: LIST
97003: LIST
97004: PUSH
97005: LD_INT 2
97007: PUSH
97008: LD_INT 1
97010: NEG
97011: PUSH
97012: EMPTY
97013: LIST
97014: LIST
97015: PUSH
97016: LD_INT 2
97018: PUSH
97019: LD_INT 2
97021: NEG
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: PUSH
97027: LD_INT 4
97029: PUSH
97030: LD_INT 2
97032: PUSH
97033: EMPTY
97034: LIST
97035: LIST
97036: PUSH
97037: LD_INT 4
97039: PUSH
97040: LD_INT 4
97042: PUSH
97043: EMPTY
97044: LIST
97045: LIST
97046: PUSH
97047: LD_INT 4
97049: PUSH
97050: LD_INT 3
97052: PUSH
97053: EMPTY
97054: LIST
97055: LIST
97056: PUSH
97057: LD_INT 5
97059: PUSH
97060: LD_INT 4
97062: PUSH
97063: EMPTY
97064: LIST
97065: LIST
97066: PUSH
97067: LD_INT 5
97069: PUSH
97070: LD_INT 5
97072: PUSH
97073: EMPTY
97074: LIST
97075: LIST
97076: PUSH
97077: LD_INT 4
97079: PUSH
97080: LD_INT 5
97082: PUSH
97083: EMPTY
97084: LIST
97085: LIST
97086: PUSH
97087: LD_INT 3
97089: PUSH
97090: LD_INT 4
97092: PUSH
97093: EMPTY
97094: LIST
97095: LIST
97096: PUSH
97097: LD_INT 3
97099: PUSH
97100: LD_INT 3
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 5
97109: PUSH
97110: LD_INT 3
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: LD_INT 3
97119: PUSH
97120: LD_INT 5
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: PUSH
97127: LD_INT 0
97129: PUSH
97130: LD_INT 3
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: PUSH
97137: LD_INT 0
97139: PUSH
97140: LD_INT 2
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 1
97149: PUSH
97150: LD_INT 3
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: PUSH
97157: LD_INT 1
97159: PUSH
97160: LD_INT 4
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: PUSH
97167: LD_INT 0
97169: PUSH
97170: LD_INT 4
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: PUSH
97177: LD_INT 1
97179: NEG
97180: PUSH
97181: LD_INT 3
97183: PUSH
97184: EMPTY
97185: LIST
97186: LIST
97187: PUSH
97188: LD_INT 1
97190: NEG
97191: PUSH
97192: LD_INT 2
97194: PUSH
97195: EMPTY
97196: LIST
97197: LIST
97198: PUSH
97199: LD_INT 2
97201: PUSH
97202: LD_INT 4
97204: PUSH
97205: EMPTY
97206: LIST
97207: LIST
97208: PUSH
97209: LD_INT 2
97211: NEG
97212: PUSH
97213: LD_INT 2
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: PUSH
97220: LD_INT 4
97222: NEG
97223: PUSH
97224: LD_INT 0
97226: PUSH
97227: EMPTY
97228: LIST
97229: LIST
97230: PUSH
97231: LD_INT 4
97233: NEG
97234: PUSH
97235: LD_INT 1
97237: NEG
97238: PUSH
97239: EMPTY
97240: LIST
97241: LIST
97242: PUSH
97243: LD_INT 3
97245: NEG
97246: PUSH
97247: LD_INT 0
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: LD_INT 3
97256: NEG
97257: PUSH
97258: LD_INT 1
97260: PUSH
97261: EMPTY
97262: LIST
97263: LIST
97264: PUSH
97265: LD_INT 4
97267: NEG
97268: PUSH
97269: LD_INT 1
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: LD_INT 5
97278: NEG
97279: PUSH
97280: LD_INT 0
97282: PUSH
97283: EMPTY
97284: LIST
97285: LIST
97286: PUSH
97287: LD_INT 5
97289: NEG
97290: PUSH
97291: LD_INT 1
97293: NEG
97294: PUSH
97295: EMPTY
97296: LIST
97297: LIST
97298: PUSH
97299: LD_INT 5
97301: NEG
97302: PUSH
97303: LD_INT 2
97305: NEG
97306: PUSH
97307: EMPTY
97308: LIST
97309: LIST
97310: PUSH
97311: LD_INT 3
97313: NEG
97314: PUSH
97315: LD_INT 2
97317: PUSH
97318: EMPTY
97319: LIST
97320: LIST
97321: PUSH
97322: EMPTY
97323: LIST
97324: LIST
97325: LIST
97326: LIST
97327: LIST
97328: LIST
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: LIST
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: ST_TO_ADDR
// end ; end ;
97369: GO 97372
97371: POP
// case btype of b_depot , b_warehouse :
97372: LD_VAR 0 1
97376: PUSH
97377: LD_INT 0
97379: DOUBLE
97380: EQUAL
97381: IFTRUE 97391
97383: LD_INT 1
97385: DOUBLE
97386: EQUAL
97387: IFTRUE 97391
97389: GO 97592
97391: POP
// case nation of nation_american :
97392: LD_VAR 0 5
97396: PUSH
97397: LD_INT 1
97399: DOUBLE
97400: EQUAL
97401: IFTRUE 97405
97403: GO 97461
97405: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97406: LD_ADDR_VAR 0 9
97410: PUSH
97411: LD_VAR 0 11
97415: PUSH
97416: LD_VAR 0 12
97420: PUSH
97421: LD_VAR 0 13
97425: PUSH
97426: LD_VAR 0 14
97430: PUSH
97431: LD_VAR 0 15
97435: PUSH
97436: LD_VAR 0 16
97440: PUSH
97441: EMPTY
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: PUSH
97449: LD_VAR 0 4
97453: PUSH
97454: LD_INT 1
97456: PLUS
97457: ARRAY
97458: ST_TO_ADDR
97459: GO 97590
97461: LD_INT 2
97463: DOUBLE
97464: EQUAL
97465: IFTRUE 97469
97467: GO 97525
97469: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97470: LD_ADDR_VAR 0 9
97474: PUSH
97475: LD_VAR 0 17
97479: PUSH
97480: LD_VAR 0 18
97484: PUSH
97485: LD_VAR 0 19
97489: PUSH
97490: LD_VAR 0 20
97494: PUSH
97495: LD_VAR 0 21
97499: PUSH
97500: LD_VAR 0 22
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: PUSH
97513: LD_VAR 0 4
97517: PUSH
97518: LD_INT 1
97520: PLUS
97521: ARRAY
97522: ST_TO_ADDR
97523: GO 97590
97525: LD_INT 3
97527: DOUBLE
97528: EQUAL
97529: IFTRUE 97533
97531: GO 97589
97533: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97534: LD_ADDR_VAR 0 9
97538: PUSH
97539: LD_VAR 0 23
97543: PUSH
97544: LD_VAR 0 24
97548: PUSH
97549: LD_VAR 0 25
97553: PUSH
97554: LD_VAR 0 26
97558: PUSH
97559: LD_VAR 0 27
97563: PUSH
97564: LD_VAR 0 28
97568: PUSH
97569: EMPTY
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: PUSH
97577: LD_VAR 0 4
97581: PUSH
97582: LD_INT 1
97584: PLUS
97585: ARRAY
97586: ST_TO_ADDR
97587: GO 97590
97589: POP
97590: GO 98145
97592: LD_INT 2
97594: DOUBLE
97595: EQUAL
97596: IFTRUE 97606
97598: LD_INT 3
97600: DOUBLE
97601: EQUAL
97602: IFTRUE 97606
97604: GO 97662
97606: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97607: LD_ADDR_VAR 0 9
97611: PUSH
97612: LD_VAR 0 29
97616: PUSH
97617: LD_VAR 0 30
97621: PUSH
97622: LD_VAR 0 31
97626: PUSH
97627: LD_VAR 0 32
97631: PUSH
97632: LD_VAR 0 33
97636: PUSH
97637: LD_VAR 0 34
97641: PUSH
97642: EMPTY
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: PUSH
97650: LD_VAR 0 4
97654: PUSH
97655: LD_INT 1
97657: PLUS
97658: ARRAY
97659: ST_TO_ADDR
97660: GO 98145
97662: LD_INT 16
97664: DOUBLE
97665: EQUAL
97666: IFTRUE 97724
97668: LD_INT 17
97670: DOUBLE
97671: EQUAL
97672: IFTRUE 97724
97674: LD_INT 18
97676: DOUBLE
97677: EQUAL
97678: IFTRUE 97724
97680: LD_INT 19
97682: DOUBLE
97683: EQUAL
97684: IFTRUE 97724
97686: LD_INT 22
97688: DOUBLE
97689: EQUAL
97690: IFTRUE 97724
97692: LD_INT 20
97694: DOUBLE
97695: EQUAL
97696: IFTRUE 97724
97698: LD_INT 21
97700: DOUBLE
97701: EQUAL
97702: IFTRUE 97724
97704: LD_INT 23
97706: DOUBLE
97707: EQUAL
97708: IFTRUE 97724
97710: LD_INT 24
97712: DOUBLE
97713: EQUAL
97714: IFTRUE 97724
97716: LD_INT 25
97718: DOUBLE
97719: EQUAL
97720: IFTRUE 97724
97722: GO 97780
97724: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97725: LD_ADDR_VAR 0 9
97729: PUSH
97730: LD_VAR 0 35
97734: PUSH
97735: LD_VAR 0 36
97739: PUSH
97740: LD_VAR 0 37
97744: PUSH
97745: LD_VAR 0 38
97749: PUSH
97750: LD_VAR 0 39
97754: PUSH
97755: LD_VAR 0 40
97759: PUSH
97760: EMPTY
97761: LIST
97762: LIST
97763: LIST
97764: LIST
97765: LIST
97766: LIST
97767: PUSH
97768: LD_VAR 0 4
97772: PUSH
97773: LD_INT 1
97775: PLUS
97776: ARRAY
97777: ST_TO_ADDR
97778: GO 98145
97780: LD_INT 6
97782: DOUBLE
97783: EQUAL
97784: IFTRUE 97836
97786: LD_INT 7
97788: DOUBLE
97789: EQUAL
97790: IFTRUE 97836
97792: LD_INT 8
97794: DOUBLE
97795: EQUAL
97796: IFTRUE 97836
97798: LD_INT 13
97800: DOUBLE
97801: EQUAL
97802: IFTRUE 97836
97804: LD_INT 12
97806: DOUBLE
97807: EQUAL
97808: IFTRUE 97836
97810: LD_INT 15
97812: DOUBLE
97813: EQUAL
97814: IFTRUE 97836
97816: LD_INT 11
97818: DOUBLE
97819: EQUAL
97820: IFTRUE 97836
97822: LD_INT 14
97824: DOUBLE
97825: EQUAL
97826: IFTRUE 97836
97828: LD_INT 10
97830: DOUBLE
97831: EQUAL
97832: IFTRUE 97836
97834: GO 97892
97836: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97837: LD_ADDR_VAR 0 9
97841: PUSH
97842: LD_VAR 0 41
97846: PUSH
97847: LD_VAR 0 42
97851: PUSH
97852: LD_VAR 0 43
97856: PUSH
97857: LD_VAR 0 44
97861: PUSH
97862: LD_VAR 0 45
97866: PUSH
97867: LD_VAR 0 46
97871: PUSH
97872: EMPTY
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: PUSH
97880: LD_VAR 0 4
97884: PUSH
97885: LD_INT 1
97887: PLUS
97888: ARRAY
97889: ST_TO_ADDR
97890: GO 98145
97892: LD_INT 36
97894: DOUBLE
97895: EQUAL
97896: IFTRUE 97900
97898: GO 97956
97900: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97901: LD_ADDR_VAR 0 9
97905: PUSH
97906: LD_VAR 0 47
97910: PUSH
97911: LD_VAR 0 48
97915: PUSH
97916: LD_VAR 0 49
97920: PUSH
97921: LD_VAR 0 50
97925: PUSH
97926: LD_VAR 0 51
97930: PUSH
97931: LD_VAR 0 52
97935: PUSH
97936: EMPTY
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: PUSH
97944: LD_VAR 0 4
97948: PUSH
97949: LD_INT 1
97951: PLUS
97952: ARRAY
97953: ST_TO_ADDR
97954: GO 98145
97956: LD_INT 4
97958: DOUBLE
97959: EQUAL
97960: IFTRUE 97982
97962: LD_INT 5
97964: DOUBLE
97965: EQUAL
97966: IFTRUE 97982
97968: LD_INT 34
97970: DOUBLE
97971: EQUAL
97972: IFTRUE 97982
97974: LD_INT 37
97976: DOUBLE
97977: EQUAL
97978: IFTRUE 97982
97980: GO 98038
97982: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97983: LD_ADDR_VAR 0 9
97987: PUSH
97988: LD_VAR 0 53
97992: PUSH
97993: LD_VAR 0 54
97997: PUSH
97998: LD_VAR 0 55
98002: PUSH
98003: LD_VAR 0 56
98007: PUSH
98008: LD_VAR 0 57
98012: PUSH
98013: LD_VAR 0 58
98017: PUSH
98018: EMPTY
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: PUSH
98026: LD_VAR 0 4
98030: PUSH
98031: LD_INT 1
98033: PLUS
98034: ARRAY
98035: ST_TO_ADDR
98036: GO 98145
98038: LD_INT 31
98040: DOUBLE
98041: EQUAL
98042: IFTRUE 98088
98044: LD_INT 32
98046: DOUBLE
98047: EQUAL
98048: IFTRUE 98088
98050: LD_INT 33
98052: DOUBLE
98053: EQUAL
98054: IFTRUE 98088
98056: LD_INT 27
98058: DOUBLE
98059: EQUAL
98060: IFTRUE 98088
98062: LD_INT 26
98064: DOUBLE
98065: EQUAL
98066: IFTRUE 98088
98068: LD_INT 28
98070: DOUBLE
98071: EQUAL
98072: IFTRUE 98088
98074: LD_INT 29
98076: DOUBLE
98077: EQUAL
98078: IFTRUE 98088
98080: LD_INT 30
98082: DOUBLE
98083: EQUAL
98084: IFTRUE 98088
98086: GO 98144
98088: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98089: LD_ADDR_VAR 0 9
98093: PUSH
98094: LD_VAR 0 59
98098: PUSH
98099: LD_VAR 0 60
98103: PUSH
98104: LD_VAR 0 61
98108: PUSH
98109: LD_VAR 0 62
98113: PUSH
98114: LD_VAR 0 63
98118: PUSH
98119: LD_VAR 0 64
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: LIST
98128: LIST
98129: LIST
98130: LIST
98131: PUSH
98132: LD_VAR 0 4
98136: PUSH
98137: LD_INT 1
98139: PLUS
98140: ARRAY
98141: ST_TO_ADDR
98142: GO 98145
98144: POP
// temp_list2 = [ ] ;
98145: LD_ADDR_VAR 0 10
98149: PUSH
98150: EMPTY
98151: ST_TO_ADDR
// for i in temp_list do
98152: LD_ADDR_VAR 0 8
98156: PUSH
98157: LD_VAR 0 9
98161: PUSH
98162: FOR_IN
98163: IFFALSE 98215
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98165: LD_ADDR_VAR 0 10
98169: PUSH
98170: LD_VAR 0 10
98174: PUSH
98175: LD_VAR 0 8
98179: PUSH
98180: LD_INT 1
98182: ARRAY
98183: PUSH
98184: LD_VAR 0 2
98188: PLUS
98189: PUSH
98190: LD_VAR 0 8
98194: PUSH
98195: LD_INT 2
98197: ARRAY
98198: PUSH
98199: LD_VAR 0 3
98203: PLUS
98204: PUSH
98205: EMPTY
98206: LIST
98207: LIST
98208: PUSH
98209: EMPTY
98210: LIST
98211: ADD
98212: ST_TO_ADDR
98213: GO 98162
98215: POP
98216: POP
// result = temp_list2 ;
98217: LD_ADDR_VAR 0 7
98221: PUSH
98222: LD_VAR 0 10
98226: ST_TO_ADDR
// end ;
98227: LD_VAR 0 7
98231: RET
// export function EnemyInRange ( unit , dist ) ; begin
98232: LD_INT 0
98234: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98235: LD_ADDR_VAR 0 3
98239: PUSH
98240: LD_VAR 0 1
98244: PPUSH
98245: CALL_OW 255
98249: PPUSH
98250: LD_VAR 0 1
98254: PPUSH
98255: CALL_OW 250
98259: PPUSH
98260: LD_VAR 0 1
98264: PPUSH
98265: CALL_OW 251
98269: PPUSH
98270: LD_VAR 0 2
98274: PPUSH
98275: CALL 72336 0 4
98279: PUSH
98280: LD_INT 4
98282: ARRAY
98283: ST_TO_ADDR
// end ;
98284: LD_VAR 0 3
98288: RET
// export function PlayerSeeMe ( unit ) ; begin
98289: LD_INT 0
98291: PPUSH
// result := See ( your_side , unit ) ;
98292: LD_ADDR_VAR 0 2
98296: PUSH
98297: LD_OWVAR 2
98301: PPUSH
98302: LD_VAR 0 1
98306: PPUSH
98307: CALL_OW 292
98311: ST_TO_ADDR
// end ;
98312: LD_VAR 0 2
98316: RET
// export function ReverseDir ( unit ) ; begin
98317: LD_INT 0
98319: PPUSH
// if not unit then
98320: LD_VAR 0 1
98324: NOT
98325: IFFALSE 98329
// exit ;
98327: GO 98375
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
98329: LD_ADDR_VAR 0 2
98333: PUSH
98334: LD_INT 3
98336: PUSH
98337: LD_INT 4
98339: PUSH
98340: LD_INT 5
98342: PUSH
98343: LD_INT 0
98345: PUSH
98346: LD_INT 1
98348: PUSH
98349: LD_INT 2
98351: PUSH
98352: EMPTY
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: PUSH
98360: LD_VAR 0 1
98364: PPUSH
98365: CALL_OW 254
98369: PUSH
98370: LD_INT 1
98372: PLUS
98373: ARRAY
98374: ST_TO_ADDR
// end ;
98375: LD_VAR 0 2
98379: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98380: LD_INT 0
98382: PPUSH
98383: PPUSH
98384: PPUSH
98385: PPUSH
98386: PPUSH
// if not hexes then
98387: LD_VAR 0 2
98391: NOT
98392: IFFALSE 98396
// exit ;
98394: GO 98544
// dist := 9999 ;
98396: LD_ADDR_VAR 0 5
98400: PUSH
98401: LD_INT 9999
98403: ST_TO_ADDR
// for i = 1 to hexes do
98404: LD_ADDR_VAR 0 4
98408: PUSH
98409: DOUBLE
98410: LD_INT 1
98412: DEC
98413: ST_TO_ADDR
98414: LD_VAR 0 2
98418: PUSH
98419: FOR_TO
98420: IFFALSE 98532
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98422: LD_VAR 0 1
98426: PPUSH
98427: LD_VAR 0 2
98431: PUSH
98432: LD_VAR 0 4
98436: ARRAY
98437: PUSH
98438: LD_INT 1
98440: ARRAY
98441: PPUSH
98442: LD_VAR 0 2
98446: PUSH
98447: LD_VAR 0 4
98451: ARRAY
98452: PUSH
98453: LD_INT 2
98455: ARRAY
98456: PPUSH
98457: CALL_OW 297
98461: PUSH
98462: LD_VAR 0 5
98466: LESS
98467: IFFALSE 98530
// begin hex := hexes [ i ] ;
98469: LD_ADDR_VAR 0 7
98473: PUSH
98474: LD_VAR 0 2
98478: PUSH
98479: LD_VAR 0 4
98483: ARRAY
98484: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98485: LD_ADDR_VAR 0 5
98489: PUSH
98490: LD_VAR 0 1
98494: PPUSH
98495: LD_VAR 0 2
98499: PUSH
98500: LD_VAR 0 4
98504: ARRAY
98505: PUSH
98506: LD_INT 1
98508: ARRAY
98509: PPUSH
98510: LD_VAR 0 2
98514: PUSH
98515: LD_VAR 0 4
98519: ARRAY
98520: PUSH
98521: LD_INT 2
98523: ARRAY
98524: PPUSH
98525: CALL_OW 297
98529: ST_TO_ADDR
// end ; end ;
98530: GO 98419
98532: POP
98533: POP
// result := hex ;
98534: LD_ADDR_VAR 0 3
98538: PUSH
98539: LD_VAR 0 7
98543: ST_TO_ADDR
// end ;
98544: LD_VAR 0 3
98548: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98549: LD_INT 0
98551: PPUSH
98552: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98553: LD_VAR 0 1
98557: NOT
98558: PUSH
98559: LD_VAR 0 1
98563: PUSH
98564: LD_INT 21
98566: PUSH
98567: LD_INT 2
98569: PUSH
98570: EMPTY
98571: LIST
98572: LIST
98573: PUSH
98574: LD_INT 23
98576: PUSH
98577: LD_INT 2
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: PUSH
98584: EMPTY
98585: LIST
98586: LIST
98587: PPUSH
98588: CALL_OW 69
98592: IN
98593: NOT
98594: OR
98595: IFFALSE 98599
// exit ;
98597: GO 98646
// for i = 1 to 3 do
98599: LD_ADDR_VAR 0 3
98603: PUSH
98604: DOUBLE
98605: LD_INT 1
98607: DEC
98608: ST_TO_ADDR
98609: LD_INT 3
98611: PUSH
98612: FOR_TO
98613: IFFALSE 98644
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98615: LD_VAR 0 1
98619: PPUSH
98620: CALL_OW 250
98624: PPUSH
98625: LD_VAR 0 1
98629: PPUSH
98630: CALL_OW 251
98634: PPUSH
98635: LD_INT 1
98637: PPUSH
98638: CALL_OW 453
98642: GO 98612
98644: POP
98645: POP
// end ;
98646: LD_VAR 0 2
98650: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98651: LD_INT 0
98653: PPUSH
98654: PPUSH
98655: PPUSH
98656: PPUSH
98657: PPUSH
98658: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98659: LD_VAR 0 1
98663: NOT
98664: PUSH
98665: LD_VAR 0 2
98669: NOT
98670: OR
98671: PUSH
98672: LD_VAR 0 1
98676: PPUSH
98677: CALL_OW 314
98681: OR
98682: IFFALSE 98686
// exit ;
98684: GO 99127
// x := GetX ( enemy_unit ) ;
98686: LD_ADDR_VAR 0 7
98690: PUSH
98691: LD_VAR 0 2
98695: PPUSH
98696: CALL_OW 250
98700: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98701: LD_ADDR_VAR 0 8
98705: PUSH
98706: LD_VAR 0 2
98710: PPUSH
98711: CALL_OW 251
98715: ST_TO_ADDR
// if not x or not y then
98716: LD_VAR 0 7
98720: NOT
98721: PUSH
98722: LD_VAR 0 8
98726: NOT
98727: OR
98728: IFFALSE 98732
// exit ;
98730: GO 99127
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98732: LD_ADDR_VAR 0 6
98736: PUSH
98737: LD_VAR 0 7
98741: PPUSH
98742: LD_INT 0
98744: PPUSH
98745: LD_INT 4
98747: PPUSH
98748: CALL_OW 272
98752: PUSH
98753: LD_VAR 0 8
98757: PPUSH
98758: LD_INT 0
98760: PPUSH
98761: LD_INT 4
98763: PPUSH
98764: CALL_OW 273
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: PUSH
98773: LD_VAR 0 7
98777: PPUSH
98778: LD_INT 1
98780: PPUSH
98781: LD_INT 4
98783: PPUSH
98784: CALL_OW 272
98788: PUSH
98789: LD_VAR 0 8
98793: PPUSH
98794: LD_INT 1
98796: PPUSH
98797: LD_INT 4
98799: PPUSH
98800: CALL_OW 273
98804: PUSH
98805: EMPTY
98806: LIST
98807: LIST
98808: PUSH
98809: LD_VAR 0 7
98813: PPUSH
98814: LD_INT 2
98816: PPUSH
98817: LD_INT 4
98819: PPUSH
98820: CALL_OW 272
98824: PUSH
98825: LD_VAR 0 8
98829: PPUSH
98830: LD_INT 2
98832: PPUSH
98833: LD_INT 4
98835: PPUSH
98836: CALL_OW 273
98840: PUSH
98841: EMPTY
98842: LIST
98843: LIST
98844: PUSH
98845: LD_VAR 0 7
98849: PPUSH
98850: LD_INT 3
98852: PPUSH
98853: LD_INT 4
98855: PPUSH
98856: CALL_OW 272
98860: PUSH
98861: LD_VAR 0 8
98865: PPUSH
98866: LD_INT 3
98868: PPUSH
98869: LD_INT 4
98871: PPUSH
98872: CALL_OW 273
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: PUSH
98881: LD_VAR 0 7
98885: PPUSH
98886: LD_INT 4
98888: PPUSH
98889: LD_INT 4
98891: PPUSH
98892: CALL_OW 272
98896: PUSH
98897: LD_VAR 0 8
98901: PPUSH
98902: LD_INT 4
98904: PPUSH
98905: LD_INT 4
98907: PPUSH
98908: CALL_OW 273
98912: PUSH
98913: EMPTY
98914: LIST
98915: LIST
98916: PUSH
98917: LD_VAR 0 7
98921: PPUSH
98922: LD_INT 5
98924: PPUSH
98925: LD_INT 4
98927: PPUSH
98928: CALL_OW 272
98932: PUSH
98933: LD_VAR 0 8
98937: PPUSH
98938: LD_INT 5
98940: PPUSH
98941: LD_INT 4
98943: PPUSH
98944: CALL_OW 273
98948: PUSH
98949: EMPTY
98950: LIST
98951: LIST
98952: PUSH
98953: EMPTY
98954: LIST
98955: LIST
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: ST_TO_ADDR
// for i = tmp downto 1 do
98961: LD_ADDR_VAR 0 4
98965: PUSH
98966: DOUBLE
98967: LD_VAR 0 6
98971: INC
98972: ST_TO_ADDR
98973: LD_INT 1
98975: PUSH
98976: FOR_DOWNTO
98977: IFFALSE 99078
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98979: LD_VAR 0 6
98983: PUSH
98984: LD_VAR 0 4
98988: ARRAY
98989: PUSH
98990: LD_INT 1
98992: ARRAY
98993: PPUSH
98994: LD_VAR 0 6
98998: PUSH
98999: LD_VAR 0 4
99003: ARRAY
99004: PUSH
99005: LD_INT 2
99007: ARRAY
99008: PPUSH
99009: CALL_OW 488
99013: NOT
99014: PUSH
99015: LD_VAR 0 6
99019: PUSH
99020: LD_VAR 0 4
99024: ARRAY
99025: PUSH
99026: LD_INT 1
99028: ARRAY
99029: PPUSH
99030: LD_VAR 0 6
99034: PUSH
99035: LD_VAR 0 4
99039: ARRAY
99040: PUSH
99041: LD_INT 2
99043: ARRAY
99044: PPUSH
99045: CALL_OW 428
99049: PUSH
99050: LD_INT 0
99052: NONEQUAL
99053: OR
99054: IFFALSE 99076
// tmp := Delete ( tmp , i ) ;
99056: LD_ADDR_VAR 0 6
99060: PUSH
99061: LD_VAR 0 6
99065: PPUSH
99066: LD_VAR 0 4
99070: PPUSH
99071: CALL_OW 3
99075: ST_TO_ADDR
99076: GO 98976
99078: POP
99079: POP
// j := GetClosestHex ( unit , tmp ) ;
99080: LD_ADDR_VAR 0 5
99084: PUSH
99085: LD_VAR 0 1
99089: PPUSH
99090: LD_VAR 0 6
99094: PPUSH
99095: CALL 98380 0 2
99099: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99100: LD_VAR 0 1
99104: PPUSH
99105: LD_VAR 0 5
99109: PUSH
99110: LD_INT 1
99112: ARRAY
99113: PPUSH
99114: LD_VAR 0 5
99118: PUSH
99119: LD_INT 2
99121: ARRAY
99122: PPUSH
99123: CALL_OW 111
// end ;
99127: LD_VAR 0 3
99131: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99132: LD_INT 0
99134: PPUSH
99135: PPUSH
99136: PPUSH
// uc_side = 0 ;
99137: LD_ADDR_OWVAR 20
99141: PUSH
99142: LD_INT 0
99144: ST_TO_ADDR
// uc_nation = 0 ;
99145: LD_ADDR_OWVAR 21
99149: PUSH
99150: LD_INT 0
99152: ST_TO_ADDR
// InitHc ;
99153: CALL_OW 19
// InitVc ;
99157: CALL_OW 20
// if mastodonts then
99161: LD_VAR 0 6
99165: IFFALSE 99232
// for i = 1 to mastodonts do
99167: LD_ADDR_VAR 0 11
99171: PUSH
99172: DOUBLE
99173: LD_INT 1
99175: DEC
99176: ST_TO_ADDR
99177: LD_VAR 0 6
99181: PUSH
99182: FOR_TO
99183: IFFALSE 99230
// begin vc_chassis := 31 ;
99185: LD_ADDR_OWVAR 37
99189: PUSH
99190: LD_INT 31
99192: ST_TO_ADDR
// vc_control := control_rider ;
99193: LD_ADDR_OWVAR 38
99197: PUSH
99198: LD_INT 4
99200: ST_TO_ADDR
// animal := CreateVehicle ;
99201: LD_ADDR_VAR 0 12
99205: PUSH
99206: CALL_OW 45
99210: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99211: LD_VAR 0 12
99215: PPUSH
99216: LD_VAR 0 8
99220: PPUSH
99221: LD_INT 0
99223: PPUSH
99224: CALL 105977 0 3
// end ;
99228: GO 99182
99230: POP
99231: POP
// if horses then
99232: LD_VAR 0 5
99236: IFFALSE 99303
// for i = 1 to horses do
99238: LD_ADDR_VAR 0 11
99242: PUSH
99243: DOUBLE
99244: LD_INT 1
99246: DEC
99247: ST_TO_ADDR
99248: LD_VAR 0 5
99252: PUSH
99253: FOR_TO
99254: IFFALSE 99301
// begin hc_class := 21 ;
99256: LD_ADDR_OWVAR 28
99260: PUSH
99261: LD_INT 21
99263: ST_TO_ADDR
// hc_gallery :=  ;
99264: LD_ADDR_OWVAR 33
99268: PUSH
99269: LD_STRING 
99271: ST_TO_ADDR
// animal := CreateHuman ;
99272: LD_ADDR_VAR 0 12
99276: PUSH
99277: CALL_OW 44
99281: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99282: LD_VAR 0 12
99286: PPUSH
99287: LD_VAR 0 8
99291: PPUSH
99292: LD_INT 0
99294: PPUSH
99295: CALL 105977 0 3
// end ;
99299: GO 99253
99301: POP
99302: POP
// if birds then
99303: LD_VAR 0 1
99307: IFFALSE 99374
// for i = 1 to birds do
99309: LD_ADDR_VAR 0 11
99313: PUSH
99314: DOUBLE
99315: LD_INT 1
99317: DEC
99318: ST_TO_ADDR
99319: LD_VAR 0 1
99323: PUSH
99324: FOR_TO
99325: IFFALSE 99372
// begin hc_class = 18 ;
99327: LD_ADDR_OWVAR 28
99331: PUSH
99332: LD_INT 18
99334: ST_TO_ADDR
// hc_gallery =  ;
99335: LD_ADDR_OWVAR 33
99339: PUSH
99340: LD_STRING 
99342: ST_TO_ADDR
// animal := CreateHuman ;
99343: LD_ADDR_VAR 0 12
99347: PUSH
99348: CALL_OW 44
99352: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99353: LD_VAR 0 12
99357: PPUSH
99358: LD_VAR 0 8
99362: PPUSH
99363: LD_INT 0
99365: PPUSH
99366: CALL 105977 0 3
// end ;
99370: GO 99324
99372: POP
99373: POP
// if tigers then
99374: LD_VAR 0 2
99378: IFFALSE 99462
// for i = 1 to tigers do
99380: LD_ADDR_VAR 0 11
99384: PUSH
99385: DOUBLE
99386: LD_INT 1
99388: DEC
99389: ST_TO_ADDR
99390: LD_VAR 0 2
99394: PUSH
99395: FOR_TO
99396: IFFALSE 99460
// begin hc_class = class_tiger ;
99398: LD_ADDR_OWVAR 28
99402: PUSH
99403: LD_INT 14
99405: ST_TO_ADDR
// hc_gallery =  ;
99406: LD_ADDR_OWVAR 33
99410: PUSH
99411: LD_STRING 
99413: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99414: LD_ADDR_OWVAR 35
99418: PUSH
99419: LD_INT 7
99421: NEG
99422: PPUSH
99423: LD_INT 7
99425: PPUSH
99426: CALL_OW 12
99430: ST_TO_ADDR
// animal := CreateHuman ;
99431: LD_ADDR_VAR 0 12
99435: PUSH
99436: CALL_OW 44
99440: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99441: LD_VAR 0 12
99445: PPUSH
99446: LD_VAR 0 8
99450: PPUSH
99451: LD_INT 0
99453: PPUSH
99454: CALL 105977 0 3
// end ;
99458: GO 99395
99460: POP
99461: POP
// if apemans then
99462: LD_VAR 0 3
99466: IFFALSE 99589
// for i = 1 to apemans do
99468: LD_ADDR_VAR 0 11
99472: PUSH
99473: DOUBLE
99474: LD_INT 1
99476: DEC
99477: ST_TO_ADDR
99478: LD_VAR 0 3
99482: PUSH
99483: FOR_TO
99484: IFFALSE 99587
// begin hc_class = class_apeman ;
99486: LD_ADDR_OWVAR 28
99490: PUSH
99491: LD_INT 12
99493: ST_TO_ADDR
// hc_gallery =  ;
99494: LD_ADDR_OWVAR 33
99498: PUSH
99499: LD_STRING 
99501: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99502: LD_ADDR_OWVAR 35
99506: PUSH
99507: LD_INT 5
99509: NEG
99510: PPUSH
99511: LD_INT 5
99513: PPUSH
99514: CALL_OW 12
99518: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99519: LD_ADDR_OWVAR 31
99523: PUSH
99524: LD_INT 1
99526: PPUSH
99527: LD_INT 3
99529: PPUSH
99530: CALL_OW 12
99534: PUSH
99535: LD_INT 1
99537: PPUSH
99538: LD_INT 3
99540: PPUSH
99541: CALL_OW 12
99545: PUSH
99546: LD_INT 0
99548: PUSH
99549: LD_INT 0
99551: PUSH
99552: EMPTY
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: ST_TO_ADDR
// animal := CreateHuman ;
99558: LD_ADDR_VAR 0 12
99562: PUSH
99563: CALL_OW 44
99567: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99568: LD_VAR 0 12
99572: PPUSH
99573: LD_VAR 0 8
99577: PPUSH
99578: LD_INT 0
99580: PPUSH
99581: CALL 105977 0 3
// end ;
99585: GO 99483
99587: POP
99588: POP
// if enchidnas then
99589: LD_VAR 0 4
99593: IFFALSE 99660
// for i = 1 to enchidnas do
99595: LD_ADDR_VAR 0 11
99599: PUSH
99600: DOUBLE
99601: LD_INT 1
99603: DEC
99604: ST_TO_ADDR
99605: LD_VAR 0 4
99609: PUSH
99610: FOR_TO
99611: IFFALSE 99658
// begin hc_class = 13 ;
99613: LD_ADDR_OWVAR 28
99617: PUSH
99618: LD_INT 13
99620: ST_TO_ADDR
// hc_gallery =  ;
99621: LD_ADDR_OWVAR 33
99625: PUSH
99626: LD_STRING 
99628: ST_TO_ADDR
// animal := CreateHuman ;
99629: LD_ADDR_VAR 0 12
99633: PUSH
99634: CALL_OW 44
99638: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99639: LD_VAR 0 12
99643: PPUSH
99644: LD_VAR 0 8
99648: PPUSH
99649: LD_INT 0
99651: PPUSH
99652: CALL 105977 0 3
// end ;
99656: GO 99610
99658: POP
99659: POP
// if fishes then
99660: LD_VAR 0 7
99664: IFFALSE 99731
// for i = 1 to fishes do
99666: LD_ADDR_VAR 0 11
99670: PUSH
99671: DOUBLE
99672: LD_INT 1
99674: DEC
99675: ST_TO_ADDR
99676: LD_VAR 0 7
99680: PUSH
99681: FOR_TO
99682: IFFALSE 99729
// begin hc_class = 20 ;
99684: LD_ADDR_OWVAR 28
99688: PUSH
99689: LD_INT 20
99691: ST_TO_ADDR
// hc_gallery =  ;
99692: LD_ADDR_OWVAR 33
99696: PUSH
99697: LD_STRING 
99699: ST_TO_ADDR
// animal := CreateHuman ;
99700: LD_ADDR_VAR 0 12
99704: PUSH
99705: CALL_OW 44
99709: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99710: LD_VAR 0 12
99714: PPUSH
99715: LD_VAR 0 9
99719: PPUSH
99720: LD_INT 0
99722: PPUSH
99723: CALL 105977 0 3
// end ;
99727: GO 99681
99729: POP
99730: POP
// end ;
99731: LD_VAR 0 10
99735: RET
// export function WantHeal ( sci , unit ) ; begin
99736: LD_INT 0
99738: PPUSH
// if GetTaskList ( sci ) > 0 then
99739: LD_VAR 0 1
99743: PPUSH
99744: CALL_OW 437
99748: PUSH
99749: LD_INT 0
99751: GREATER
99752: IFFALSE 99822
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99754: LD_VAR 0 1
99758: PPUSH
99759: CALL_OW 437
99763: PUSH
99764: LD_INT 1
99766: ARRAY
99767: PUSH
99768: LD_INT 1
99770: ARRAY
99771: PUSH
99772: LD_STRING l
99774: EQUAL
99775: PUSH
99776: LD_VAR 0 1
99780: PPUSH
99781: CALL_OW 437
99785: PUSH
99786: LD_INT 1
99788: ARRAY
99789: PUSH
99790: LD_INT 4
99792: ARRAY
99793: PUSH
99794: LD_VAR 0 2
99798: EQUAL
99799: AND
99800: IFFALSE 99812
// result := true else
99802: LD_ADDR_VAR 0 3
99806: PUSH
99807: LD_INT 1
99809: ST_TO_ADDR
99810: GO 99820
// result := false ;
99812: LD_ADDR_VAR 0 3
99816: PUSH
99817: LD_INT 0
99819: ST_TO_ADDR
// end else
99820: GO 99830
// result := false ;
99822: LD_ADDR_VAR 0 3
99826: PUSH
99827: LD_INT 0
99829: ST_TO_ADDR
// end ;
99830: LD_VAR 0 3
99834: RET
// export function HealTarget ( sci ) ; begin
99835: LD_INT 0
99837: PPUSH
// if not sci then
99838: LD_VAR 0 1
99842: NOT
99843: IFFALSE 99847
// exit ;
99845: GO 99912
// result := 0 ;
99847: LD_ADDR_VAR 0 2
99851: PUSH
99852: LD_INT 0
99854: ST_TO_ADDR
// if GetTaskList ( sci ) then
99855: LD_VAR 0 1
99859: PPUSH
99860: CALL_OW 437
99864: IFFALSE 99912
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99866: LD_VAR 0 1
99870: PPUSH
99871: CALL_OW 437
99875: PUSH
99876: LD_INT 1
99878: ARRAY
99879: PUSH
99880: LD_INT 1
99882: ARRAY
99883: PUSH
99884: LD_STRING l
99886: EQUAL
99887: IFFALSE 99912
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99889: LD_ADDR_VAR 0 2
99893: PUSH
99894: LD_VAR 0 1
99898: PPUSH
99899: CALL_OW 437
99903: PUSH
99904: LD_INT 1
99906: ARRAY
99907: PUSH
99908: LD_INT 4
99910: ARRAY
99911: ST_TO_ADDR
// end ;
99912: LD_VAR 0 2
99916: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99917: LD_INT 0
99919: PPUSH
99920: PPUSH
99921: PPUSH
99922: PPUSH
99923: PPUSH
99924: PPUSH
99925: PPUSH
99926: PPUSH
99927: PPUSH
99928: PPUSH
99929: PPUSH
99930: PPUSH
99931: PPUSH
99932: PPUSH
99933: PPUSH
99934: PPUSH
99935: PPUSH
99936: PPUSH
99937: PPUSH
99938: PPUSH
99939: PPUSH
99940: PPUSH
99941: PPUSH
99942: PPUSH
99943: PPUSH
99944: PPUSH
99945: PPUSH
99946: PPUSH
99947: PPUSH
99948: PPUSH
99949: PPUSH
99950: PPUSH
99951: PPUSH
99952: PPUSH
// if not list then
99953: LD_VAR 0 1
99957: NOT
99958: IFFALSE 99962
// exit ;
99960: GO 104588
// base := list [ 1 ] ;
99962: LD_ADDR_VAR 0 3
99966: PUSH
99967: LD_VAR 0 1
99971: PUSH
99972: LD_INT 1
99974: ARRAY
99975: ST_TO_ADDR
// group := list [ 2 ] ;
99976: LD_ADDR_VAR 0 4
99980: PUSH
99981: LD_VAR 0 1
99985: PUSH
99986: LD_INT 2
99988: ARRAY
99989: ST_TO_ADDR
// path := list [ 3 ] ;
99990: LD_ADDR_VAR 0 5
99994: PUSH
99995: LD_VAR 0 1
99999: PUSH
100000: LD_INT 3
100002: ARRAY
100003: ST_TO_ADDR
// flags := list [ 4 ] ;
100004: LD_ADDR_VAR 0 6
100008: PUSH
100009: LD_VAR 0 1
100013: PUSH
100014: LD_INT 4
100016: ARRAY
100017: ST_TO_ADDR
// mined := [ ] ;
100018: LD_ADDR_VAR 0 27
100022: PUSH
100023: EMPTY
100024: ST_TO_ADDR
// bombed := [ ] ;
100025: LD_ADDR_VAR 0 28
100029: PUSH
100030: EMPTY
100031: ST_TO_ADDR
// healers := [ ] ;
100032: LD_ADDR_VAR 0 31
100036: PUSH
100037: EMPTY
100038: ST_TO_ADDR
// to_heal := [ ] ;
100039: LD_ADDR_VAR 0 30
100043: PUSH
100044: EMPTY
100045: ST_TO_ADDR
// repairs := [ ] ;
100046: LD_ADDR_VAR 0 33
100050: PUSH
100051: EMPTY
100052: ST_TO_ADDR
// to_repair := [ ] ;
100053: LD_ADDR_VAR 0 32
100057: PUSH
100058: EMPTY
100059: ST_TO_ADDR
// if not group or not path then
100060: LD_VAR 0 4
100064: NOT
100065: PUSH
100066: LD_VAR 0 5
100070: NOT
100071: OR
100072: IFFALSE 100076
// exit ;
100074: GO 104588
// side := GetSide ( group [ 1 ] ) ;
100076: LD_ADDR_VAR 0 35
100080: PUSH
100081: LD_VAR 0 4
100085: PUSH
100086: LD_INT 1
100088: ARRAY
100089: PPUSH
100090: CALL_OW 255
100094: ST_TO_ADDR
// if flags then
100095: LD_VAR 0 6
100099: IFFALSE 100243
// begin f_ignore_area := flags [ 1 ] ;
100101: LD_ADDR_VAR 0 17
100105: PUSH
100106: LD_VAR 0 6
100110: PUSH
100111: LD_INT 1
100113: ARRAY
100114: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100115: LD_ADDR_VAR 0 18
100119: PUSH
100120: LD_VAR 0 6
100124: PUSH
100125: LD_INT 2
100127: ARRAY
100128: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100129: LD_ADDR_VAR 0 19
100133: PUSH
100134: LD_VAR 0 6
100138: PUSH
100139: LD_INT 3
100141: ARRAY
100142: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100143: LD_ADDR_VAR 0 20
100147: PUSH
100148: LD_VAR 0 6
100152: PUSH
100153: LD_INT 4
100155: ARRAY
100156: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100157: LD_ADDR_VAR 0 21
100161: PUSH
100162: LD_VAR 0 6
100166: PUSH
100167: LD_INT 5
100169: ARRAY
100170: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100171: LD_ADDR_VAR 0 22
100175: PUSH
100176: LD_VAR 0 6
100180: PUSH
100181: LD_INT 6
100183: ARRAY
100184: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100185: LD_ADDR_VAR 0 23
100189: PUSH
100190: LD_VAR 0 6
100194: PUSH
100195: LD_INT 7
100197: ARRAY
100198: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100199: LD_ADDR_VAR 0 24
100203: PUSH
100204: LD_VAR 0 6
100208: PUSH
100209: LD_INT 8
100211: ARRAY
100212: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100213: LD_ADDR_VAR 0 25
100217: PUSH
100218: LD_VAR 0 6
100222: PUSH
100223: LD_INT 9
100225: ARRAY
100226: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100227: LD_ADDR_VAR 0 26
100231: PUSH
100232: LD_VAR 0 6
100236: PUSH
100237: LD_INT 10
100239: ARRAY
100240: ST_TO_ADDR
// end else
100241: GO 100323
// begin f_ignore_area := false ;
100243: LD_ADDR_VAR 0 17
100247: PUSH
100248: LD_INT 0
100250: ST_TO_ADDR
// f_capture := false ;
100251: LD_ADDR_VAR 0 18
100255: PUSH
100256: LD_INT 0
100258: ST_TO_ADDR
// f_ignore_civ := false ;
100259: LD_ADDR_VAR 0 19
100263: PUSH
100264: LD_INT 0
100266: ST_TO_ADDR
// f_murder := false ;
100267: LD_ADDR_VAR 0 20
100271: PUSH
100272: LD_INT 0
100274: ST_TO_ADDR
// f_mines := false ;
100275: LD_ADDR_VAR 0 21
100279: PUSH
100280: LD_INT 0
100282: ST_TO_ADDR
// f_repair := false ;
100283: LD_ADDR_VAR 0 22
100287: PUSH
100288: LD_INT 0
100290: ST_TO_ADDR
// f_heal := false ;
100291: LD_ADDR_VAR 0 23
100295: PUSH
100296: LD_INT 0
100298: ST_TO_ADDR
// f_spacetime := false ;
100299: LD_ADDR_VAR 0 24
100303: PUSH
100304: LD_INT 0
100306: ST_TO_ADDR
// f_attack_depot := false ;
100307: LD_ADDR_VAR 0 25
100311: PUSH
100312: LD_INT 0
100314: ST_TO_ADDR
// f_crawl := false ;
100315: LD_ADDR_VAR 0 26
100319: PUSH
100320: LD_INT 0
100322: ST_TO_ADDR
// end ; if f_heal then
100323: LD_VAR 0 23
100327: IFFALSE 100354
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100329: LD_ADDR_VAR 0 31
100333: PUSH
100334: LD_VAR 0 4
100338: PPUSH
100339: LD_INT 25
100341: PUSH
100342: LD_INT 4
100344: PUSH
100345: EMPTY
100346: LIST
100347: LIST
100348: PPUSH
100349: CALL_OW 72
100353: ST_TO_ADDR
// if f_repair then
100354: LD_VAR 0 22
100358: IFFALSE 100385
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100360: LD_ADDR_VAR 0 33
100364: PUSH
100365: LD_VAR 0 4
100369: PPUSH
100370: LD_INT 25
100372: PUSH
100373: LD_INT 3
100375: PUSH
100376: EMPTY
100377: LIST
100378: LIST
100379: PPUSH
100380: CALL_OW 72
100384: ST_TO_ADDR
// units_path := [ ] ;
100385: LD_ADDR_VAR 0 16
100389: PUSH
100390: EMPTY
100391: ST_TO_ADDR
// for i = 1 to group do
100392: LD_ADDR_VAR 0 7
100396: PUSH
100397: DOUBLE
100398: LD_INT 1
100400: DEC
100401: ST_TO_ADDR
100402: LD_VAR 0 4
100406: PUSH
100407: FOR_TO
100408: IFFALSE 100437
// units_path := Replace ( units_path , i , path ) ;
100410: LD_ADDR_VAR 0 16
100414: PUSH
100415: LD_VAR 0 16
100419: PPUSH
100420: LD_VAR 0 7
100424: PPUSH
100425: LD_VAR 0 5
100429: PPUSH
100430: CALL_OW 1
100434: ST_TO_ADDR
100435: GO 100407
100437: POP
100438: POP
// repeat for i = group downto 1 do
100439: LD_ADDR_VAR 0 7
100443: PUSH
100444: DOUBLE
100445: LD_VAR 0 4
100449: INC
100450: ST_TO_ADDR
100451: LD_INT 1
100453: PUSH
100454: FOR_DOWNTO
100455: IFFALSE 104551
// begin wait ( 5 ) ;
100457: LD_INT 5
100459: PPUSH
100460: CALL_OW 67
// tmp := [ ] ;
100464: LD_ADDR_VAR 0 14
100468: PUSH
100469: EMPTY
100470: ST_TO_ADDR
// attacking := false ;
100471: LD_ADDR_VAR 0 29
100475: PUSH
100476: LD_INT 0
100478: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100479: LD_VAR 0 4
100483: PUSH
100484: LD_VAR 0 7
100488: ARRAY
100489: PPUSH
100490: CALL_OW 301
100494: PUSH
100495: LD_VAR 0 4
100499: PUSH
100500: LD_VAR 0 7
100504: ARRAY
100505: NOT
100506: OR
100507: IFFALSE 100616
// begin if GetType ( group [ i ] ) = unit_human then
100509: LD_VAR 0 4
100513: PUSH
100514: LD_VAR 0 7
100518: ARRAY
100519: PPUSH
100520: CALL_OW 247
100524: PUSH
100525: LD_INT 1
100527: EQUAL
100528: IFFALSE 100574
// begin to_heal := to_heal diff group [ i ] ;
100530: LD_ADDR_VAR 0 30
100534: PUSH
100535: LD_VAR 0 30
100539: PUSH
100540: LD_VAR 0 4
100544: PUSH
100545: LD_VAR 0 7
100549: ARRAY
100550: DIFF
100551: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100552: LD_ADDR_VAR 0 31
100556: PUSH
100557: LD_VAR 0 31
100561: PUSH
100562: LD_VAR 0 4
100566: PUSH
100567: LD_VAR 0 7
100571: ARRAY
100572: DIFF
100573: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100574: LD_ADDR_VAR 0 4
100578: PUSH
100579: LD_VAR 0 4
100583: PPUSH
100584: LD_VAR 0 7
100588: PPUSH
100589: CALL_OW 3
100593: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100594: LD_ADDR_VAR 0 16
100598: PUSH
100599: LD_VAR 0 16
100603: PPUSH
100604: LD_VAR 0 7
100608: PPUSH
100609: CALL_OW 3
100613: ST_TO_ADDR
// continue ;
100614: GO 100454
// end ; if f_repair then
100616: LD_VAR 0 22
100620: IFFALSE 101109
// begin if GetType ( group [ i ] ) = unit_vehicle then
100622: LD_VAR 0 4
100626: PUSH
100627: LD_VAR 0 7
100631: ARRAY
100632: PPUSH
100633: CALL_OW 247
100637: PUSH
100638: LD_INT 2
100640: EQUAL
100641: IFFALSE 100831
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100643: LD_VAR 0 4
100647: PUSH
100648: LD_VAR 0 7
100652: ARRAY
100653: PPUSH
100654: CALL_OW 256
100658: PUSH
100659: LD_INT 700
100661: LESS
100662: PUSH
100663: LD_VAR 0 4
100667: PUSH
100668: LD_VAR 0 7
100672: ARRAY
100673: PUSH
100674: LD_VAR 0 32
100678: IN
100679: NOT
100680: AND
100681: IFFALSE 100705
// to_repair := to_repair union group [ i ] ;
100683: LD_ADDR_VAR 0 32
100687: PUSH
100688: LD_VAR 0 32
100692: PUSH
100693: LD_VAR 0 4
100697: PUSH
100698: LD_VAR 0 7
100702: ARRAY
100703: UNION
100704: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100705: LD_VAR 0 4
100709: PUSH
100710: LD_VAR 0 7
100714: ARRAY
100715: PPUSH
100716: CALL_OW 256
100720: PUSH
100721: LD_INT 1000
100723: EQUAL
100724: PUSH
100725: LD_VAR 0 4
100729: PUSH
100730: LD_VAR 0 7
100734: ARRAY
100735: PUSH
100736: LD_VAR 0 32
100740: IN
100741: AND
100742: IFFALSE 100766
// to_repair := to_repair diff group [ i ] ;
100744: LD_ADDR_VAR 0 32
100748: PUSH
100749: LD_VAR 0 32
100753: PUSH
100754: LD_VAR 0 4
100758: PUSH
100759: LD_VAR 0 7
100763: ARRAY
100764: DIFF
100765: ST_TO_ADDR
// if group [ i ] in to_repair then
100766: LD_VAR 0 4
100770: PUSH
100771: LD_VAR 0 7
100775: ARRAY
100776: PUSH
100777: LD_VAR 0 32
100781: IN
100782: IFFALSE 100829
// begin if not IsInArea ( group [ i ] , f_repair ) then
100784: LD_VAR 0 4
100788: PUSH
100789: LD_VAR 0 7
100793: ARRAY
100794: PPUSH
100795: LD_VAR 0 22
100799: PPUSH
100800: CALL_OW 308
100804: NOT
100805: IFFALSE 100827
// ComMoveToArea ( group [ i ] , f_repair ) ;
100807: LD_VAR 0 4
100811: PUSH
100812: LD_VAR 0 7
100816: ARRAY
100817: PPUSH
100818: LD_VAR 0 22
100822: PPUSH
100823: CALL_OW 113
// continue ;
100827: GO 100454
// end ; end else
100829: GO 101109
// if group [ i ] in repairs then
100831: LD_VAR 0 4
100835: PUSH
100836: LD_VAR 0 7
100840: ARRAY
100841: PUSH
100842: LD_VAR 0 33
100846: IN
100847: IFFALSE 101109
// begin if IsInUnit ( group [ i ] ) then
100849: LD_VAR 0 4
100853: PUSH
100854: LD_VAR 0 7
100858: ARRAY
100859: PPUSH
100860: CALL_OW 310
100864: IFFALSE 100932
// begin z := IsInUnit ( group [ i ] ) ;
100866: LD_ADDR_VAR 0 13
100870: PUSH
100871: LD_VAR 0 4
100875: PUSH
100876: LD_VAR 0 7
100880: ARRAY
100881: PPUSH
100882: CALL_OW 310
100886: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100887: LD_VAR 0 13
100891: PUSH
100892: LD_VAR 0 32
100896: IN
100897: PUSH
100898: LD_VAR 0 13
100902: PPUSH
100903: LD_VAR 0 22
100907: PPUSH
100908: CALL_OW 308
100912: AND
100913: IFFALSE 100930
// ComExitVehicle ( group [ i ] ) ;
100915: LD_VAR 0 4
100919: PUSH
100920: LD_VAR 0 7
100924: ARRAY
100925: PPUSH
100926: CALL_OW 121
// end else
100930: GO 101109
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100932: LD_ADDR_VAR 0 13
100936: PUSH
100937: LD_VAR 0 4
100941: PPUSH
100942: LD_INT 95
100944: PUSH
100945: LD_VAR 0 22
100949: PUSH
100950: EMPTY
100951: LIST
100952: LIST
100953: PUSH
100954: LD_INT 58
100956: PUSH
100957: EMPTY
100958: LIST
100959: PUSH
100960: EMPTY
100961: LIST
100962: LIST
100963: PPUSH
100964: CALL_OW 72
100968: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100969: LD_VAR 0 4
100973: PUSH
100974: LD_VAR 0 7
100978: ARRAY
100979: PPUSH
100980: CALL_OW 314
100984: NOT
100985: IFFALSE 101107
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100987: LD_ADDR_VAR 0 10
100991: PUSH
100992: LD_VAR 0 13
100996: PPUSH
100997: LD_VAR 0 4
101001: PUSH
101002: LD_VAR 0 7
101006: ARRAY
101007: PPUSH
101008: CALL_OW 74
101012: ST_TO_ADDR
// if not x then
101013: LD_VAR 0 10
101017: NOT
101018: IFFALSE 101022
// continue ;
101020: GO 100454
// if GetLives ( x ) < 1000 then
101022: LD_VAR 0 10
101026: PPUSH
101027: CALL_OW 256
101031: PUSH
101032: LD_INT 1000
101034: LESS
101035: IFFALSE 101059
// ComRepairVehicle ( group [ i ] , x ) else
101037: LD_VAR 0 4
101041: PUSH
101042: LD_VAR 0 7
101046: ARRAY
101047: PPUSH
101048: LD_VAR 0 10
101052: PPUSH
101053: CALL_OW 129
101057: GO 101107
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101059: LD_VAR 0 23
101063: PUSH
101064: LD_VAR 0 4
101068: PUSH
101069: LD_VAR 0 7
101073: ARRAY
101074: PPUSH
101075: CALL_OW 256
101079: PUSH
101080: LD_INT 1000
101082: LESS
101083: AND
101084: NOT
101085: IFFALSE 101107
// ComEnterUnit ( group [ i ] , x ) ;
101087: LD_VAR 0 4
101091: PUSH
101092: LD_VAR 0 7
101096: ARRAY
101097: PPUSH
101098: LD_VAR 0 10
101102: PPUSH
101103: CALL_OW 120
// end ; continue ;
101107: GO 100454
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101109: LD_VAR 0 23
101113: PUSH
101114: LD_VAR 0 4
101118: PUSH
101119: LD_VAR 0 7
101123: ARRAY
101124: PPUSH
101125: CALL_OW 247
101129: PUSH
101130: LD_INT 1
101132: EQUAL
101133: AND
101134: IFFALSE 101612
// begin if group [ i ] in healers then
101136: LD_VAR 0 4
101140: PUSH
101141: LD_VAR 0 7
101145: ARRAY
101146: PUSH
101147: LD_VAR 0 31
101151: IN
101152: IFFALSE 101425
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101154: LD_VAR 0 4
101158: PUSH
101159: LD_VAR 0 7
101163: ARRAY
101164: PPUSH
101165: LD_VAR 0 23
101169: PPUSH
101170: CALL_OW 308
101174: NOT
101175: PUSH
101176: LD_VAR 0 4
101180: PUSH
101181: LD_VAR 0 7
101185: ARRAY
101186: PPUSH
101187: CALL_OW 314
101191: NOT
101192: AND
101193: IFFALSE 101217
// ComMoveToArea ( group [ i ] , f_heal ) else
101195: LD_VAR 0 4
101199: PUSH
101200: LD_VAR 0 7
101204: ARRAY
101205: PPUSH
101206: LD_VAR 0 23
101210: PPUSH
101211: CALL_OW 113
101215: GO 101423
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101217: LD_VAR 0 4
101221: PUSH
101222: LD_VAR 0 7
101226: ARRAY
101227: PPUSH
101228: CALL 99835 0 1
101232: PPUSH
101233: CALL_OW 256
101237: PUSH
101238: LD_INT 1000
101240: EQUAL
101241: IFFALSE 101260
// ComStop ( group [ i ] ) else
101243: LD_VAR 0 4
101247: PUSH
101248: LD_VAR 0 7
101252: ARRAY
101253: PPUSH
101254: CALL_OW 141
101258: GO 101423
// if not HasTask ( group [ i ] ) and to_heal then
101260: LD_VAR 0 4
101264: PUSH
101265: LD_VAR 0 7
101269: ARRAY
101270: PPUSH
101271: CALL_OW 314
101275: NOT
101276: PUSH
101277: LD_VAR 0 30
101281: AND
101282: IFFALSE 101423
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101284: LD_ADDR_VAR 0 13
101288: PUSH
101289: LD_VAR 0 30
101293: PPUSH
101294: LD_INT 3
101296: PUSH
101297: LD_INT 54
101299: PUSH
101300: EMPTY
101301: LIST
101302: PUSH
101303: EMPTY
101304: LIST
101305: LIST
101306: PPUSH
101307: CALL_OW 72
101311: PPUSH
101312: LD_VAR 0 4
101316: PUSH
101317: LD_VAR 0 7
101321: ARRAY
101322: PPUSH
101323: CALL_OW 74
101327: ST_TO_ADDR
// if z then
101328: LD_VAR 0 13
101332: IFFALSE 101423
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101334: LD_INT 91
101336: PUSH
101337: LD_VAR 0 13
101341: PUSH
101342: LD_INT 10
101344: PUSH
101345: EMPTY
101346: LIST
101347: LIST
101348: LIST
101349: PUSH
101350: LD_INT 81
101352: PUSH
101353: LD_VAR 0 13
101357: PPUSH
101358: CALL_OW 255
101362: PUSH
101363: EMPTY
101364: LIST
101365: LIST
101366: PUSH
101367: EMPTY
101368: LIST
101369: LIST
101370: PPUSH
101371: CALL_OW 69
101375: PUSH
101376: LD_INT 0
101378: EQUAL
101379: IFFALSE 101403
// ComHeal ( group [ i ] , z ) else
101381: LD_VAR 0 4
101385: PUSH
101386: LD_VAR 0 7
101390: ARRAY
101391: PPUSH
101392: LD_VAR 0 13
101396: PPUSH
101397: CALL_OW 128
101401: GO 101423
// ComMoveToArea ( group [ i ] , f_heal ) ;
101403: LD_VAR 0 4
101407: PUSH
101408: LD_VAR 0 7
101412: ARRAY
101413: PPUSH
101414: LD_VAR 0 23
101418: PPUSH
101419: CALL_OW 113
// end ; continue ;
101423: GO 100454
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101425: LD_VAR 0 4
101429: PUSH
101430: LD_VAR 0 7
101434: ARRAY
101435: PPUSH
101436: CALL_OW 256
101440: PUSH
101441: LD_INT 700
101443: LESS
101444: PUSH
101445: LD_VAR 0 4
101449: PUSH
101450: LD_VAR 0 7
101454: ARRAY
101455: PUSH
101456: LD_VAR 0 30
101460: IN
101461: NOT
101462: AND
101463: IFFALSE 101487
// to_heal := to_heal union group [ i ] ;
101465: LD_ADDR_VAR 0 30
101469: PUSH
101470: LD_VAR 0 30
101474: PUSH
101475: LD_VAR 0 4
101479: PUSH
101480: LD_VAR 0 7
101484: ARRAY
101485: UNION
101486: ST_TO_ADDR
// if group [ i ] in to_heal then
101487: LD_VAR 0 4
101491: PUSH
101492: LD_VAR 0 7
101496: ARRAY
101497: PUSH
101498: LD_VAR 0 30
101502: IN
101503: IFFALSE 101612
// begin if GetLives ( group [ i ] ) = 1000 then
101505: LD_VAR 0 4
101509: PUSH
101510: LD_VAR 0 7
101514: ARRAY
101515: PPUSH
101516: CALL_OW 256
101520: PUSH
101521: LD_INT 1000
101523: EQUAL
101524: IFFALSE 101550
// to_heal := to_heal diff group [ i ] else
101526: LD_ADDR_VAR 0 30
101530: PUSH
101531: LD_VAR 0 30
101535: PUSH
101536: LD_VAR 0 4
101540: PUSH
101541: LD_VAR 0 7
101545: ARRAY
101546: DIFF
101547: ST_TO_ADDR
101548: GO 101612
// begin if not IsInArea ( group [ i ] , to_heal ) then
101550: LD_VAR 0 4
101554: PUSH
101555: LD_VAR 0 7
101559: ARRAY
101560: PPUSH
101561: LD_VAR 0 30
101565: PPUSH
101566: CALL_OW 308
101570: NOT
101571: IFFALSE 101595
// ComMoveToArea ( group [ i ] , f_heal ) else
101573: LD_VAR 0 4
101577: PUSH
101578: LD_VAR 0 7
101582: ARRAY
101583: PPUSH
101584: LD_VAR 0 23
101588: PPUSH
101589: CALL_OW 113
101593: GO 101610
// ComHold ( group [ i ] ) ;
101595: LD_VAR 0 4
101599: PUSH
101600: LD_VAR 0 7
101604: ARRAY
101605: PPUSH
101606: CALL_OW 140
// continue ;
101610: GO 100454
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101612: LD_VAR 0 4
101616: PUSH
101617: LD_VAR 0 7
101621: ARRAY
101622: PPUSH
101623: LD_INT 10
101625: PPUSH
101626: CALL 98232 0 2
101630: NOT
101631: PUSH
101632: LD_VAR 0 16
101636: PUSH
101637: LD_VAR 0 7
101641: ARRAY
101642: PUSH
101643: EMPTY
101644: EQUAL
101645: NOT
101646: AND
101647: IFFALSE 101913
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101649: LD_VAR 0 4
101653: PUSH
101654: LD_VAR 0 7
101658: ARRAY
101659: PPUSH
101660: CALL_OW 262
101664: PUSH
101665: LD_INT 1
101667: PUSH
101668: LD_INT 2
101670: PUSH
101671: EMPTY
101672: LIST
101673: LIST
101674: IN
101675: IFFALSE 101716
// if GetFuel ( group [ i ] ) < 10 then
101677: LD_VAR 0 4
101681: PUSH
101682: LD_VAR 0 7
101686: ARRAY
101687: PPUSH
101688: CALL_OW 261
101692: PUSH
101693: LD_INT 10
101695: LESS
101696: IFFALSE 101716
// SetFuel ( group [ i ] , 12 ) ;
101698: LD_VAR 0 4
101702: PUSH
101703: LD_VAR 0 7
101707: ARRAY
101708: PPUSH
101709: LD_INT 12
101711: PPUSH
101712: CALL_OW 240
// if units_path [ i ] then
101716: LD_VAR 0 16
101720: PUSH
101721: LD_VAR 0 7
101725: ARRAY
101726: IFFALSE 101911
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101728: LD_VAR 0 4
101732: PUSH
101733: LD_VAR 0 7
101737: ARRAY
101738: PPUSH
101739: LD_VAR 0 16
101743: PUSH
101744: LD_VAR 0 7
101748: ARRAY
101749: PUSH
101750: LD_INT 1
101752: ARRAY
101753: PUSH
101754: LD_INT 1
101756: ARRAY
101757: PPUSH
101758: LD_VAR 0 16
101762: PUSH
101763: LD_VAR 0 7
101767: ARRAY
101768: PUSH
101769: LD_INT 1
101771: ARRAY
101772: PUSH
101773: LD_INT 2
101775: ARRAY
101776: PPUSH
101777: CALL_OW 297
101781: PUSH
101782: LD_INT 6
101784: GREATER
101785: IFFALSE 101860
// begin if not HasTask ( group [ i ] ) then
101787: LD_VAR 0 4
101791: PUSH
101792: LD_VAR 0 7
101796: ARRAY
101797: PPUSH
101798: CALL_OW 314
101802: NOT
101803: IFFALSE 101858
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101805: LD_VAR 0 4
101809: PUSH
101810: LD_VAR 0 7
101814: ARRAY
101815: PPUSH
101816: LD_VAR 0 16
101820: PUSH
101821: LD_VAR 0 7
101825: ARRAY
101826: PUSH
101827: LD_INT 1
101829: ARRAY
101830: PUSH
101831: LD_INT 1
101833: ARRAY
101834: PPUSH
101835: LD_VAR 0 16
101839: PUSH
101840: LD_VAR 0 7
101844: ARRAY
101845: PUSH
101846: LD_INT 1
101848: ARRAY
101849: PUSH
101850: LD_INT 2
101852: ARRAY
101853: PPUSH
101854: CALL_OW 114
// end else
101858: GO 101911
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101860: LD_ADDR_VAR 0 15
101864: PUSH
101865: LD_VAR 0 16
101869: PUSH
101870: LD_VAR 0 7
101874: ARRAY
101875: PPUSH
101876: LD_INT 1
101878: PPUSH
101879: CALL_OW 3
101883: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101884: LD_ADDR_VAR 0 16
101888: PUSH
101889: LD_VAR 0 16
101893: PPUSH
101894: LD_VAR 0 7
101898: PPUSH
101899: LD_VAR 0 15
101903: PPUSH
101904: CALL_OW 1
101908: ST_TO_ADDR
// continue ;
101909: GO 100454
// end ; end ; end else
101911: GO 104549
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101913: LD_ADDR_VAR 0 14
101917: PUSH
101918: LD_INT 81
101920: PUSH
101921: LD_VAR 0 4
101925: PUSH
101926: LD_VAR 0 7
101930: ARRAY
101931: PPUSH
101932: CALL_OW 255
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: PPUSH
101941: CALL_OW 69
101945: ST_TO_ADDR
// if not tmp then
101946: LD_VAR 0 14
101950: NOT
101951: IFFALSE 101955
// continue ;
101953: GO 100454
// if f_ignore_area then
101955: LD_VAR 0 17
101959: IFFALSE 102047
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101961: LD_ADDR_VAR 0 15
101965: PUSH
101966: LD_VAR 0 14
101970: PPUSH
101971: LD_INT 3
101973: PUSH
101974: LD_INT 92
101976: PUSH
101977: LD_VAR 0 17
101981: PUSH
101982: LD_INT 1
101984: ARRAY
101985: PUSH
101986: LD_VAR 0 17
101990: PUSH
101991: LD_INT 2
101993: ARRAY
101994: PUSH
101995: LD_VAR 0 17
101999: PUSH
102000: LD_INT 3
102002: ARRAY
102003: PUSH
102004: EMPTY
102005: LIST
102006: LIST
102007: LIST
102008: LIST
102009: PUSH
102010: EMPTY
102011: LIST
102012: LIST
102013: PPUSH
102014: CALL_OW 72
102018: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102019: LD_VAR 0 14
102023: PUSH
102024: LD_VAR 0 15
102028: DIFF
102029: IFFALSE 102047
// tmp := tmp diff tmp2 ;
102031: LD_ADDR_VAR 0 14
102035: PUSH
102036: LD_VAR 0 14
102040: PUSH
102041: LD_VAR 0 15
102045: DIFF
102046: ST_TO_ADDR
// end ; if not f_murder then
102047: LD_VAR 0 20
102051: NOT
102052: IFFALSE 102110
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102054: LD_ADDR_VAR 0 15
102058: PUSH
102059: LD_VAR 0 14
102063: PPUSH
102064: LD_INT 3
102066: PUSH
102067: LD_INT 50
102069: PUSH
102070: EMPTY
102071: LIST
102072: PUSH
102073: EMPTY
102074: LIST
102075: LIST
102076: PPUSH
102077: CALL_OW 72
102081: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102082: LD_VAR 0 14
102086: PUSH
102087: LD_VAR 0 15
102091: DIFF
102092: IFFALSE 102110
// tmp := tmp diff tmp2 ;
102094: LD_ADDR_VAR 0 14
102098: PUSH
102099: LD_VAR 0 14
102103: PUSH
102104: LD_VAR 0 15
102108: DIFF
102109: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102110: LD_ADDR_VAR 0 14
102114: PUSH
102115: LD_VAR 0 4
102119: PUSH
102120: LD_VAR 0 7
102124: ARRAY
102125: PPUSH
102126: LD_VAR 0 14
102130: PPUSH
102131: LD_INT 1
102133: PPUSH
102134: LD_INT 1
102136: PPUSH
102137: CALL 71875 0 4
102141: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102142: LD_VAR 0 4
102146: PUSH
102147: LD_VAR 0 7
102151: ARRAY
102152: PPUSH
102153: CALL_OW 257
102157: PUSH
102158: LD_INT 1
102160: EQUAL
102161: IFFALSE 102609
// begin if WantPlant ( group [ i ] ) then
102163: LD_VAR 0 4
102167: PUSH
102168: LD_VAR 0 7
102172: ARRAY
102173: PPUSH
102174: CALL 71376 0 1
102178: IFFALSE 102182
// continue ;
102180: GO 100454
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102182: LD_VAR 0 18
102186: PUSH
102187: LD_VAR 0 4
102191: PUSH
102192: LD_VAR 0 7
102196: ARRAY
102197: PPUSH
102198: CALL_OW 310
102202: NOT
102203: AND
102204: PUSH
102205: LD_VAR 0 14
102209: PUSH
102210: LD_INT 1
102212: ARRAY
102213: PUSH
102214: LD_VAR 0 14
102218: PPUSH
102219: LD_INT 21
102221: PUSH
102222: LD_INT 2
102224: PUSH
102225: EMPTY
102226: LIST
102227: LIST
102228: PUSH
102229: LD_INT 58
102231: PUSH
102232: EMPTY
102233: LIST
102234: PUSH
102235: EMPTY
102236: LIST
102237: LIST
102238: PPUSH
102239: CALL_OW 72
102243: IN
102244: AND
102245: IFFALSE 102281
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102247: LD_VAR 0 4
102251: PUSH
102252: LD_VAR 0 7
102256: ARRAY
102257: PPUSH
102258: LD_VAR 0 14
102262: PUSH
102263: LD_INT 1
102265: ARRAY
102266: PPUSH
102267: CALL_OW 120
// attacking := true ;
102271: LD_ADDR_VAR 0 29
102275: PUSH
102276: LD_INT 1
102278: ST_TO_ADDR
// continue ;
102279: GO 100454
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102281: LD_VAR 0 26
102285: PUSH
102286: LD_VAR 0 4
102290: PUSH
102291: LD_VAR 0 7
102295: ARRAY
102296: PPUSH
102297: CALL_OW 257
102301: PUSH
102302: LD_INT 1
102304: EQUAL
102305: AND
102306: PUSH
102307: LD_VAR 0 4
102311: PUSH
102312: LD_VAR 0 7
102316: ARRAY
102317: PPUSH
102318: CALL_OW 256
102322: PUSH
102323: LD_INT 800
102325: LESS
102326: AND
102327: PUSH
102328: LD_VAR 0 4
102332: PUSH
102333: LD_VAR 0 7
102337: ARRAY
102338: PPUSH
102339: CALL_OW 318
102343: NOT
102344: AND
102345: IFFALSE 102362
// ComCrawl ( group [ i ] ) ;
102347: LD_VAR 0 4
102351: PUSH
102352: LD_VAR 0 7
102356: ARRAY
102357: PPUSH
102358: CALL_OW 137
// if f_mines then
102362: LD_VAR 0 21
102366: IFFALSE 102609
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102368: LD_VAR 0 14
102372: PUSH
102373: LD_INT 1
102375: ARRAY
102376: PPUSH
102377: CALL_OW 247
102381: PUSH
102382: LD_INT 3
102384: EQUAL
102385: PUSH
102386: LD_VAR 0 14
102390: PUSH
102391: LD_INT 1
102393: ARRAY
102394: PUSH
102395: LD_VAR 0 27
102399: IN
102400: NOT
102401: AND
102402: IFFALSE 102609
// begin x := GetX ( tmp [ 1 ] ) ;
102404: LD_ADDR_VAR 0 10
102408: PUSH
102409: LD_VAR 0 14
102413: PUSH
102414: LD_INT 1
102416: ARRAY
102417: PPUSH
102418: CALL_OW 250
102422: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102423: LD_ADDR_VAR 0 11
102427: PUSH
102428: LD_VAR 0 14
102432: PUSH
102433: LD_INT 1
102435: ARRAY
102436: PPUSH
102437: CALL_OW 251
102441: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102442: LD_ADDR_VAR 0 12
102446: PUSH
102447: LD_VAR 0 4
102451: PUSH
102452: LD_VAR 0 7
102456: ARRAY
102457: PPUSH
102458: CALL 98317 0 1
102462: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102463: LD_VAR 0 4
102467: PUSH
102468: LD_VAR 0 7
102472: ARRAY
102473: PPUSH
102474: LD_VAR 0 10
102478: PPUSH
102479: LD_VAR 0 11
102483: PPUSH
102484: LD_VAR 0 14
102488: PUSH
102489: LD_INT 1
102491: ARRAY
102492: PPUSH
102493: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102497: LD_VAR 0 4
102501: PUSH
102502: LD_VAR 0 7
102506: ARRAY
102507: PPUSH
102508: LD_VAR 0 10
102512: PPUSH
102513: LD_VAR 0 12
102517: PPUSH
102518: LD_INT 7
102520: PPUSH
102521: CALL_OW 272
102525: PPUSH
102526: LD_VAR 0 11
102530: PPUSH
102531: LD_VAR 0 12
102535: PPUSH
102536: LD_INT 7
102538: PPUSH
102539: CALL_OW 273
102543: PPUSH
102544: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102548: LD_VAR 0 4
102552: PUSH
102553: LD_VAR 0 7
102557: ARRAY
102558: PPUSH
102559: LD_INT 71
102561: PPUSH
102562: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102566: LD_ADDR_VAR 0 27
102570: PUSH
102571: LD_VAR 0 27
102575: PPUSH
102576: LD_VAR 0 27
102580: PUSH
102581: LD_INT 1
102583: PLUS
102584: PPUSH
102585: LD_VAR 0 14
102589: PUSH
102590: LD_INT 1
102592: ARRAY
102593: PPUSH
102594: CALL_OW 1
102598: ST_TO_ADDR
// attacking := true ;
102599: LD_ADDR_VAR 0 29
102603: PUSH
102604: LD_INT 1
102606: ST_TO_ADDR
// continue ;
102607: GO 100454
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102609: LD_VAR 0 4
102613: PUSH
102614: LD_VAR 0 7
102618: ARRAY
102619: PPUSH
102620: CALL_OW 257
102624: PUSH
102625: LD_INT 17
102627: EQUAL
102628: PUSH
102629: LD_VAR 0 4
102633: PUSH
102634: LD_VAR 0 7
102638: ARRAY
102639: PPUSH
102640: CALL_OW 110
102644: PUSH
102645: LD_INT 71
102647: EQUAL
102648: NOT
102649: AND
102650: IFFALSE 102796
// begin attacking := false ;
102652: LD_ADDR_VAR 0 29
102656: PUSH
102657: LD_INT 0
102659: ST_TO_ADDR
// k := 5 ;
102660: LD_ADDR_VAR 0 9
102664: PUSH
102665: LD_INT 5
102667: ST_TO_ADDR
// if tmp < k then
102668: LD_VAR 0 14
102672: PUSH
102673: LD_VAR 0 9
102677: LESS
102678: IFFALSE 102690
// k := tmp ;
102680: LD_ADDR_VAR 0 9
102684: PUSH
102685: LD_VAR 0 14
102689: ST_TO_ADDR
// for j = 1 to k do
102690: LD_ADDR_VAR 0 8
102694: PUSH
102695: DOUBLE
102696: LD_INT 1
102698: DEC
102699: ST_TO_ADDR
102700: LD_VAR 0 9
102704: PUSH
102705: FOR_TO
102706: IFFALSE 102794
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102708: LD_VAR 0 14
102712: PUSH
102713: LD_VAR 0 8
102717: ARRAY
102718: PUSH
102719: LD_VAR 0 14
102723: PPUSH
102724: LD_INT 58
102726: PUSH
102727: EMPTY
102728: LIST
102729: PPUSH
102730: CALL_OW 72
102734: IN
102735: NOT
102736: IFFALSE 102792
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102738: LD_VAR 0 4
102742: PUSH
102743: LD_VAR 0 7
102747: ARRAY
102748: PPUSH
102749: LD_VAR 0 14
102753: PUSH
102754: LD_VAR 0 8
102758: ARRAY
102759: PPUSH
102760: CALL_OW 115
// attacking := true ;
102764: LD_ADDR_VAR 0 29
102768: PUSH
102769: LD_INT 1
102771: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102772: LD_VAR 0 4
102776: PUSH
102777: LD_VAR 0 7
102781: ARRAY
102782: PPUSH
102783: LD_INT 71
102785: PPUSH
102786: CALL_OW 109
// continue ;
102790: GO 102705
// end ; end ;
102792: GO 102705
102794: POP
102795: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102796: LD_VAR 0 4
102800: PUSH
102801: LD_VAR 0 7
102805: ARRAY
102806: PPUSH
102807: CALL_OW 257
102811: PUSH
102812: LD_INT 8
102814: EQUAL
102815: PUSH
102816: LD_VAR 0 4
102820: PUSH
102821: LD_VAR 0 7
102825: ARRAY
102826: PPUSH
102827: CALL_OW 264
102831: PUSH
102832: LD_INT 28
102834: PUSH
102835: LD_INT 45
102837: PUSH
102838: LD_INT 7
102840: PUSH
102841: LD_INT 47
102843: PUSH
102844: EMPTY
102845: LIST
102846: LIST
102847: LIST
102848: LIST
102849: IN
102850: OR
102851: IFFALSE 103081
// begin attacking := false ;
102853: LD_ADDR_VAR 0 29
102857: PUSH
102858: LD_INT 0
102860: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102861: LD_VAR 0 14
102865: PUSH
102866: LD_INT 1
102868: ARRAY
102869: PPUSH
102870: CALL_OW 266
102874: PUSH
102875: LD_INT 32
102877: PUSH
102878: LD_INT 31
102880: PUSH
102881: LD_INT 33
102883: PUSH
102884: LD_INT 4
102886: PUSH
102887: LD_INT 5
102889: PUSH
102890: EMPTY
102891: LIST
102892: LIST
102893: LIST
102894: LIST
102895: LIST
102896: IN
102897: IFFALSE 103081
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102899: LD_ADDR_VAR 0 9
102903: PUSH
102904: LD_VAR 0 14
102908: PUSH
102909: LD_INT 1
102911: ARRAY
102912: PPUSH
102913: CALL_OW 266
102917: PPUSH
102918: LD_VAR 0 14
102922: PUSH
102923: LD_INT 1
102925: ARRAY
102926: PPUSH
102927: CALL_OW 250
102931: PPUSH
102932: LD_VAR 0 14
102936: PUSH
102937: LD_INT 1
102939: ARRAY
102940: PPUSH
102941: CALL_OW 251
102945: PPUSH
102946: LD_VAR 0 14
102950: PUSH
102951: LD_INT 1
102953: ARRAY
102954: PPUSH
102955: CALL_OW 254
102959: PPUSH
102960: LD_VAR 0 14
102964: PUSH
102965: LD_INT 1
102967: ARRAY
102968: PPUSH
102969: CALL_OW 248
102973: PPUSH
102974: LD_INT 0
102976: PPUSH
102977: CALL 79687 0 6
102981: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102982: LD_ADDR_VAR 0 8
102986: PUSH
102987: LD_VAR 0 4
102991: PUSH
102992: LD_VAR 0 7
102996: ARRAY
102997: PPUSH
102998: LD_VAR 0 9
103002: PPUSH
103003: CALL 98380 0 2
103007: ST_TO_ADDR
// if j then
103008: LD_VAR 0 8
103012: IFFALSE 103081
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103014: LD_VAR 0 8
103018: PUSH
103019: LD_INT 1
103021: ARRAY
103022: PPUSH
103023: LD_VAR 0 8
103027: PUSH
103028: LD_INT 2
103030: ARRAY
103031: PPUSH
103032: CALL_OW 488
103036: IFFALSE 103081
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103038: LD_VAR 0 4
103042: PUSH
103043: LD_VAR 0 7
103047: ARRAY
103048: PPUSH
103049: LD_VAR 0 8
103053: PUSH
103054: LD_INT 1
103056: ARRAY
103057: PPUSH
103058: LD_VAR 0 8
103062: PUSH
103063: LD_INT 2
103065: ARRAY
103066: PPUSH
103067: CALL_OW 116
// attacking := true ;
103071: LD_ADDR_VAR 0 29
103075: PUSH
103076: LD_INT 1
103078: ST_TO_ADDR
// continue ;
103079: GO 100454
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103081: LD_VAR 0 4
103085: PUSH
103086: LD_VAR 0 7
103090: ARRAY
103091: PPUSH
103092: CALL_OW 265
103096: PUSH
103097: LD_INT 11
103099: EQUAL
103100: IFFALSE 103378
// begin k := 10 ;
103102: LD_ADDR_VAR 0 9
103106: PUSH
103107: LD_INT 10
103109: ST_TO_ADDR
// x := 0 ;
103110: LD_ADDR_VAR 0 10
103114: PUSH
103115: LD_INT 0
103117: ST_TO_ADDR
// if tmp < k then
103118: LD_VAR 0 14
103122: PUSH
103123: LD_VAR 0 9
103127: LESS
103128: IFFALSE 103140
// k := tmp ;
103130: LD_ADDR_VAR 0 9
103134: PUSH
103135: LD_VAR 0 14
103139: ST_TO_ADDR
// for j = k downto 1 do
103140: LD_ADDR_VAR 0 8
103144: PUSH
103145: DOUBLE
103146: LD_VAR 0 9
103150: INC
103151: ST_TO_ADDR
103152: LD_INT 1
103154: PUSH
103155: FOR_DOWNTO
103156: IFFALSE 103231
// begin if GetType ( tmp [ j ] ) = unit_human then
103158: LD_VAR 0 14
103162: PUSH
103163: LD_VAR 0 8
103167: ARRAY
103168: PPUSH
103169: CALL_OW 247
103173: PUSH
103174: LD_INT 1
103176: EQUAL
103177: IFFALSE 103229
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103179: LD_VAR 0 4
103183: PUSH
103184: LD_VAR 0 7
103188: ARRAY
103189: PPUSH
103190: LD_VAR 0 14
103194: PUSH
103195: LD_VAR 0 8
103199: ARRAY
103200: PPUSH
103201: CALL 98651 0 2
// x := tmp [ j ] ;
103205: LD_ADDR_VAR 0 10
103209: PUSH
103210: LD_VAR 0 14
103214: PUSH
103215: LD_VAR 0 8
103219: ARRAY
103220: ST_TO_ADDR
// attacking := true ;
103221: LD_ADDR_VAR 0 29
103225: PUSH
103226: LD_INT 1
103228: ST_TO_ADDR
// end ; end ;
103229: GO 103155
103231: POP
103232: POP
// if not x then
103233: LD_VAR 0 10
103237: NOT
103238: IFFALSE 103378
// begin attacking := true ;
103240: LD_ADDR_VAR 0 29
103244: PUSH
103245: LD_INT 1
103247: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103248: LD_VAR 0 4
103252: PUSH
103253: LD_VAR 0 7
103257: ARRAY
103258: PPUSH
103259: CALL_OW 250
103263: PPUSH
103264: LD_VAR 0 4
103268: PUSH
103269: LD_VAR 0 7
103273: ARRAY
103274: PPUSH
103275: CALL_OW 251
103279: PPUSH
103280: CALL_OW 546
103284: PUSH
103285: LD_INT 2
103287: ARRAY
103288: PUSH
103289: LD_VAR 0 14
103293: PUSH
103294: LD_INT 1
103296: ARRAY
103297: PPUSH
103298: CALL_OW 250
103302: PPUSH
103303: LD_VAR 0 14
103307: PUSH
103308: LD_INT 1
103310: ARRAY
103311: PPUSH
103312: CALL_OW 251
103316: PPUSH
103317: CALL_OW 546
103321: PUSH
103322: LD_INT 2
103324: ARRAY
103325: EQUAL
103326: IFFALSE 103354
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103328: LD_VAR 0 4
103332: PUSH
103333: LD_VAR 0 7
103337: ARRAY
103338: PPUSH
103339: LD_VAR 0 14
103343: PUSH
103344: LD_INT 1
103346: ARRAY
103347: PPUSH
103348: CALL 98651 0 2
103352: GO 103378
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103354: LD_VAR 0 4
103358: PUSH
103359: LD_VAR 0 7
103363: ARRAY
103364: PPUSH
103365: LD_VAR 0 14
103369: PUSH
103370: LD_INT 1
103372: ARRAY
103373: PPUSH
103374: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103378: LD_VAR 0 4
103382: PUSH
103383: LD_VAR 0 7
103387: ARRAY
103388: PPUSH
103389: CALL_OW 264
103393: PUSH
103394: LD_INT 29
103396: EQUAL
103397: IFFALSE 103763
// begin if WantsToAttack ( group [ i ] ) in bombed then
103399: LD_VAR 0 4
103403: PUSH
103404: LD_VAR 0 7
103408: ARRAY
103409: PPUSH
103410: CALL_OW 319
103414: PUSH
103415: LD_VAR 0 28
103419: IN
103420: IFFALSE 103424
// continue ;
103422: GO 100454
// k := 8 ;
103424: LD_ADDR_VAR 0 9
103428: PUSH
103429: LD_INT 8
103431: ST_TO_ADDR
// x := 0 ;
103432: LD_ADDR_VAR 0 10
103436: PUSH
103437: LD_INT 0
103439: ST_TO_ADDR
// if tmp < k then
103440: LD_VAR 0 14
103444: PUSH
103445: LD_VAR 0 9
103449: LESS
103450: IFFALSE 103462
// k := tmp ;
103452: LD_ADDR_VAR 0 9
103456: PUSH
103457: LD_VAR 0 14
103461: ST_TO_ADDR
// for j = 1 to k do
103462: LD_ADDR_VAR 0 8
103466: PUSH
103467: DOUBLE
103468: LD_INT 1
103470: DEC
103471: ST_TO_ADDR
103472: LD_VAR 0 9
103476: PUSH
103477: FOR_TO
103478: IFFALSE 103610
// begin if GetType ( tmp [ j ] ) = unit_building then
103480: LD_VAR 0 14
103484: PUSH
103485: LD_VAR 0 8
103489: ARRAY
103490: PPUSH
103491: CALL_OW 247
103495: PUSH
103496: LD_INT 3
103498: EQUAL
103499: IFFALSE 103608
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103501: LD_VAR 0 14
103505: PUSH
103506: LD_VAR 0 8
103510: ARRAY
103511: PUSH
103512: LD_VAR 0 28
103516: IN
103517: NOT
103518: PUSH
103519: LD_VAR 0 14
103523: PUSH
103524: LD_VAR 0 8
103528: ARRAY
103529: PPUSH
103530: CALL_OW 313
103534: AND
103535: IFFALSE 103608
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103537: LD_VAR 0 4
103541: PUSH
103542: LD_VAR 0 7
103546: ARRAY
103547: PPUSH
103548: LD_VAR 0 14
103552: PUSH
103553: LD_VAR 0 8
103557: ARRAY
103558: PPUSH
103559: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103563: LD_ADDR_VAR 0 28
103567: PUSH
103568: LD_VAR 0 28
103572: PPUSH
103573: LD_VAR 0 28
103577: PUSH
103578: LD_INT 1
103580: PLUS
103581: PPUSH
103582: LD_VAR 0 14
103586: PUSH
103587: LD_VAR 0 8
103591: ARRAY
103592: PPUSH
103593: CALL_OW 1
103597: ST_TO_ADDR
// attacking := true ;
103598: LD_ADDR_VAR 0 29
103602: PUSH
103603: LD_INT 1
103605: ST_TO_ADDR
// break ;
103606: GO 103610
// end ; end ;
103608: GO 103477
103610: POP
103611: POP
// if not attacking and f_attack_depot then
103612: LD_VAR 0 29
103616: NOT
103617: PUSH
103618: LD_VAR 0 25
103622: AND
103623: IFFALSE 103718
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103625: LD_ADDR_VAR 0 13
103629: PUSH
103630: LD_VAR 0 14
103634: PPUSH
103635: LD_INT 2
103637: PUSH
103638: LD_INT 30
103640: PUSH
103641: LD_INT 0
103643: PUSH
103644: EMPTY
103645: LIST
103646: LIST
103647: PUSH
103648: LD_INT 30
103650: PUSH
103651: LD_INT 1
103653: PUSH
103654: EMPTY
103655: LIST
103656: LIST
103657: PUSH
103658: EMPTY
103659: LIST
103660: LIST
103661: LIST
103662: PPUSH
103663: CALL_OW 72
103667: ST_TO_ADDR
// if z then
103668: LD_VAR 0 13
103672: IFFALSE 103718
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103674: LD_VAR 0 4
103678: PUSH
103679: LD_VAR 0 7
103683: ARRAY
103684: PPUSH
103685: LD_VAR 0 13
103689: PPUSH
103690: LD_VAR 0 4
103694: PUSH
103695: LD_VAR 0 7
103699: ARRAY
103700: PPUSH
103701: CALL_OW 74
103705: PPUSH
103706: CALL_OW 115
// attacking := true ;
103710: LD_ADDR_VAR 0 29
103714: PUSH
103715: LD_INT 1
103717: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103718: LD_VAR 0 4
103722: PUSH
103723: LD_VAR 0 7
103727: ARRAY
103728: PPUSH
103729: CALL_OW 256
103733: PUSH
103734: LD_INT 500
103736: LESS
103737: IFFALSE 103763
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103739: LD_VAR 0 4
103743: PUSH
103744: LD_VAR 0 7
103748: ARRAY
103749: PPUSH
103750: LD_VAR 0 14
103754: PUSH
103755: LD_INT 1
103757: ARRAY
103758: PPUSH
103759: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103763: LD_VAR 0 4
103767: PUSH
103768: LD_VAR 0 7
103772: ARRAY
103773: PPUSH
103774: CALL_OW 264
103778: PUSH
103779: LD_INT 49
103781: EQUAL
103782: IFFALSE 103903
// begin if not HasTask ( group [ i ] ) then
103784: LD_VAR 0 4
103788: PUSH
103789: LD_VAR 0 7
103793: ARRAY
103794: PPUSH
103795: CALL_OW 314
103799: NOT
103800: IFFALSE 103903
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103802: LD_ADDR_VAR 0 9
103806: PUSH
103807: LD_INT 81
103809: PUSH
103810: LD_VAR 0 4
103814: PUSH
103815: LD_VAR 0 7
103819: ARRAY
103820: PPUSH
103821: CALL_OW 255
103825: PUSH
103826: EMPTY
103827: LIST
103828: LIST
103829: PPUSH
103830: CALL_OW 69
103834: PPUSH
103835: LD_VAR 0 4
103839: PUSH
103840: LD_VAR 0 7
103844: ARRAY
103845: PPUSH
103846: CALL_OW 74
103850: ST_TO_ADDR
// if k then
103851: LD_VAR 0 9
103855: IFFALSE 103903
// if GetDistUnits ( group [ i ] , k ) > 10 then
103857: LD_VAR 0 4
103861: PUSH
103862: LD_VAR 0 7
103866: ARRAY
103867: PPUSH
103868: LD_VAR 0 9
103872: PPUSH
103873: CALL_OW 296
103877: PUSH
103878: LD_INT 10
103880: GREATER
103881: IFFALSE 103903
// ComMoveUnit ( group [ i ] , k ) ;
103883: LD_VAR 0 4
103887: PUSH
103888: LD_VAR 0 7
103892: ARRAY
103893: PPUSH
103894: LD_VAR 0 9
103898: PPUSH
103899: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103903: LD_VAR 0 4
103907: PUSH
103908: LD_VAR 0 7
103912: ARRAY
103913: PPUSH
103914: CALL_OW 256
103918: PUSH
103919: LD_INT 250
103921: LESS
103922: PUSH
103923: LD_VAR 0 4
103927: PUSH
103928: LD_VAR 0 7
103932: ARRAY
103933: PUSH
103934: LD_INT 21
103936: PUSH
103937: LD_INT 2
103939: PUSH
103940: EMPTY
103941: LIST
103942: LIST
103943: PUSH
103944: LD_INT 23
103946: PUSH
103947: LD_INT 2
103949: PUSH
103950: EMPTY
103951: LIST
103952: LIST
103953: PUSH
103954: EMPTY
103955: LIST
103956: LIST
103957: PPUSH
103958: CALL_OW 69
103962: IN
103963: AND
103964: IFFALSE 104089
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103966: LD_ADDR_VAR 0 9
103970: PUSH
103971: LD_OWVAR 3
103975: PUSH
103976: LD_VAR 0 4
103980: PUSH
103981: LD_VAR 0 7
103985: ARRAY
103986: DIFF
103987: PPUSH
103988: LD_VAR 0 4
103992: PUSH
103993: LD_VAR 0 7
103997: ARRAY
103998: PPUSH
103999: CALL_OW 74
104003: ST_TO_ADDR
// if not k then
104004: LD_VAR 0 9
104008: NOT
104009: IFFALSE 104013
// continue ;
104011: GO 100454
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104013: LD_VAR 0 9
104017: PUSH
104018: LD_INT 81
104020: PUSH
104021: LD_VAR 0 4
104025: PUSH
104026: LD_VAR 0 7
104030: ARRAY
104031: PPUSH
104032: CALL_OW 255
104036: PUSH
104037: EMPTY
104038: LIST
104039: LIST
104040: PPUSH
104041: CALL_OW 69
104045: IN
104046: PUSH
104047: LD_VAR 0 9
104051: PPUSH
104052: LD_VAR 0 4
104056: PUSH
104057: LD_VAR 0 7
104061: ARRAY
104062: PPUSH
104063: CALL_OW 296
104067: PUSH
104068: LD_INT 5
104070: LESS
104071: AND
104072: IFFALSE 104089
// ComAutodestruct ( group [ i ] ) ;
104074: LD_VAR 0 4
104078: PUSH
104079: LD_VAR 0 7
104083: ARRAY
104084: PPUSH
104085: CALL 98549 0 1
// end ; if f_attack_depot then
104089: LD_VAR 0 25
104093: IFFALSE 104205
// begin k := 6 ;
104095: LD_ADDR_VAR 0 9
104099: PUSH
104100: LD_INT 6
104102: ST_TO_ADDR
// if tmp < k then
104103: LD_VAR 0 14
104107: PUSH
104108: LD_VAR 0 9
104112: LESS
104113: IFFALSE 104125
// k := tmp ;
104115: LD_ADDR_VAR 0 9
104119: PUSH
104120: LD_VAR 0 14
104124: ST_TO_ADDR
// for j = 1 to k do
104125: LD_ADDR_VAR 0 8
104129: PUSH
104130: DOUBLE
104131: LD_INT 1
104133: DEC
104134: ST_TO_ADDR
104135: LD_VAR 0 9
104139: PUSH
104140: FOR_TO
104141: IFFALSE 104203
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104143: LD_VAR 0 8
104147: PPUSH
104148: CALL_OW 266
104152: PUSH
104153: LD_INT 0
104155: PUSH
104156: LD_INT 1
104158: PUSH
104159: EMPTY
104160: LIST
104161: LIST
104162: IN
104163: IFFALSE 104201
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104165: LD_VAR 0 4
104169: PUSH
104170: LD_VAR 0 7
104174: ARRAY
104175: PPUSH
104176: LD_VAR 0 14
104180: PUSH
104181: LD_VAR 0 8
104185: ARRAY
104186: PPUSH
104187: CALL_OW 115
// attacking := true ;
104191: LD_ADDR_VAR 0 29
104195: PUSH
104196: LD_INT 1
104198: ST_TO_ADDR
// break ;
104199: GO 104203
// end ;
104201: GO 104140
104203: POP
104204: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104205: LD_VAR 0 4
104209: PUSH
104210: LD_VAR 0 7
104214: ARRAY
104215: PPUSH
104216: CALL_OW 302
104220: PUSH
104221: LD_VAR 0 29
104225: NOT
104226: AND
104227: IFFALSE 104549
// begin if GetTag ( group [ i ] ) = 71 then
104229: LD_VAR 0 4
104233: PUSH
104234: LD_VAR 0 7
104238: ARRAY
104239: PPUSH
104240: CALL_OW 110
104244: PUSH
104245: LD_INT 71
104247: EQUAL
104248: IFFALSE 104289
// begin if HasTask ( group [ i ] ) then
104250: LD_VAR 0 4
104254: PUSH
104255: LD_VAR 0 7
104259: ARRAY
104260: PPUSH
104261: CALL_OW 314
104265: IFFALSE 104271
// continue else
104267: GO 100454
104269: GO 104289
// SetTag ( group [ i ] , 0 ) ;
104271: LD_VAR 0 4
104275: PUSH
104276: LD_VAR 0 7
104280: ARRAY
104281: PPUSH
104282: LD_INT 0
104284: PPUSH
104285: CALL_OW 109
// end ; k := 8 ;
104289: LD_ADDR_VAR 0 9
104293: PUSH
104294: LD_INT 8
104296: ST_TO_ADDR
// x := 0 ;
104297: LD_ADDR_VAR 0 10
104301: PUSH
104302: LD_INT 0
104304: ST_TO_ADDR
// if tmp < k then
104305: LD_VAR 0 14
104309: PUSH
104310: LD_VAR 0 9
104314: LESS
104315: IFFALSE 104327
// k := tmp ;
104317: LD_ADDR_VAR 0 9
104321: PUSH
104322: LD_VAR 0 14
104326: ST_TO_ADDR
// for j = 1 to k do
104327: LD_ADDR_VAR 0 8
104331: PUSH
104332: DOUBLE
104333: LD_INT 1
104335: DEC
104336: ST_TO_ADDR
104337: LD_VAR 0 9
104341: PUSH
104342: FOR_TO
104343: IFFALSE 104441
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104345: LD_VAR 0 14
104349: PUSH
104350: LD_VAR 0 8
104354: ARRAY
104355: PPUSH
104356: CALL_OW 247
104360: PUSH
104361: LD_INT 1
104363: EQUAL
104364: PUSH
104365: LD_VAR 0 14
104369: PUSH
104370: LD_VAR 0 8
104374: ARRAY
104375: PPUSH
104376: CALL_OW 256
104380: PUSH
104381: LD_INT 250
104383: LESS
104384: PUSH
104385: LD_VAR 0 20
104389: AND
104390: PUSH
104391: LD_VAR 0 20
104395: NOT
104396: PUSH
104397: LD_VAR 0 14
104401: PUSH
104402: LD_VAR 0 8
104406: ARRAY
104407: PPUSH
104408: CALL_OW 256
104412: PUSH
104413: LD_INT 250
104415: GREATEREQUAL
104416: AND
104417: OR
104418: AND
104419: IFFALSE 104439
// begin x := tmp [ j ] ;
104421: LD_ADDR_VAR 0 10
104425: PUSH
104426: LD_VAR 0 14
104430: PUSH
104431: LD_VAR 0 8
104435: ARRAY
104436: ST_TO_ADDR
// break ;
104437: GO 104441
// end ;
104439: GO 104342
104441: POP
104442: POP
// if x then
104443: LD_VAR 0 10
104447: IFFALSE 104471
// ComAttackUnit ( group [ i ] , x ) else
104449: LD_VAR 0 4
104453: PUSH
104454: LD_VAR 0 7
104458: ARRAY
104459: PPUSH
104460: LD_VAR 0 10
104464: PPUSH
104465: CALL_OW 115
104469: GO 104495
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104471: LD_VAR 0 4
104475: PUSH
104476: LD_VAR 0 7
104480: ARRAY
104481: PPUSH
104482: LD_VAR 0 14
104486: PUSH
104487: LD_INT 1
104489: ARRAY
104490: PPUSH
104491: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104495: LD_VAR 0 4
104499: PUSH
104500: LD_VAR 0 7
104504: ARRAY
104505: PPUSH
104506: CALL_OW 314
104510: NOT
104511: IFFALSE 104549
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104513: LD_VAR 0 4
104517: PUSH
104518: LD_VAR 0 7
104522: ARRAY
104523: PPUSH
104524: LD_VAR 0 14
104528: PPUSH
104529: LD_VAR 0 4
104533: PUSH
104534: LD_VAR 0 7
104538: ARRAY
104539: PPUSH
104540: CALL_OW 74
104544: PPUSH
104545: CALL_OW 115
// end ; end ; end ;
104549: GO 100454
104551: POP
104552: POP
// wait ( 0 0$1 ) ;
104553: LD_INT 35
104555: PPUSH
104556: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104560: LD_VAR 0 4
104564: PUSH
104565: EMPTY
104566: EQUAL
104567: PUSH
104568: LD_INT 81
104570: PUSH
104571: LD_VAR 0 35
104575: PUSH
104576: EMPTY
104577: LIST
104578: LIST
104579: PPUSH
104580: CALL_OW 69
104584: NOT
104585: OR
104586: IFFALSE 100439
// end ;
104588: LD_VAR 0 2
104592: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104593: LD_INT 0
104595: PPUSH
104596: PPUSH
104597: PPUSH
104598: PPUSH
// if not base_units then
104599: LD_VAR 0 1
104603: NOT
104604: IFFALSE 104608
// exit ;
104606: GO 104695
// result := false ;
104608: LD_ADDR_VAR 0 2
104612: PUSH
104613: LD_INT 0
104615: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104616: LD_ADDR_VAR 0 5
104620: PUSH
104621: LD_VAR 0 1
104625: PPUSH
104626: LD_INT 21
104628: PUSH
104629: LD_INT 3
104631: PUSH
104632: EMPTY
104633: LIST
104634: LIST
104635: PPUSH
104636: CALL_OW 72
104640: ST_TO_ADDR
// if not tmp then
104641: LD_VAR 0 5
104645: NOT
104646: IFFALSE 104650
// exit ;
104648: GO 104695
// for i in tmp do
104650: LD_ADDR_VAR 0 3
104654: PUSH
104655: LD_VAR 0 5
104659: PUSH
104660: FOR_IN
104661: IFFALSE 104693
// begin result := EnemyInRange ( i , 22 ) ;
104663: LD_ADDR_VAR 0 2
104667: PUSH
104668: LD_VAR 0 3
104672: PPUSH
104673: LD_INT 22
104675: PPUSH
104676: CALL 98232 0 2
104680: ST_TO_ADDR
// if result then
104681: LD_VAR 0 2
104685: IFFALSE 104691
// exit ;
104687: POP
104688: POP
104689: GO 104695
// end ;
104691: GO 104660
104693: POP
104694: POP
// end ;
104695: LD_VAR 0 2
104699: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104700: LD_INT 0
104702: PPUSH
104703: PPUSH
// if not units then
104704: LD_VAR 0 1
104708: NOT
104709: IFFALSE 104713
// exit ;
104711: GO 104783
// result := [ ] ;
104713: LD_ADDR_VAR 0 3
104717: PUSH
104718: EMPTY
104719: ST_TO_ADDR
// for i in units do
104720: LD_ADDR_VAR 0 4
104724: PUSH
104725: LD_VAR 0 1
104729: PUSH
104730: FOR_IN
104731: IFFALSE 104781
// if GetTag ( i ) = tag then
104733: LD_VAR 0 4
104737: PPUSH
104738: CALL_OW 110
104742: PUSH
104743: LD_VAR 0 2
104747: EQUAL
104748: IFFALSE 104779
// result := Insert ( result , result + 1 , i ) ;
104750: LD_ADDR_VAR 0 3
104754: PUSH
104755: LD_VAR 0 3
104759: PPUSH
104760: LD_VAR 0 3
104764: PUSH
104765: LD_INT 1
104767: PLUS
104768: PPUSH
104769: LD_VAR 0 4
104773: PPUSH
104774: CALL_OW 2
104778: ST_TO_ADDR
104779: GO 104730
104781: POP
104782: POP
// end ;
104783: LD_VAR 0 3
104787: RET
// export function IsDriver ( un ) ; begin
104788: LD_INT 0
104790: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104791: LD_ADDR_VAR 0 2
104795: PUSH
104796: LD_VAR 0 1
104800: PUSH
104801: LD_INT 55
104803: PUSH
104804: EMPTY
104805: LIST
104806: PPUSH
104807: CALL_OW 69
104811: IN
104812: ST_TO_ADDR
// end ;
104813: LD_VAR 0 2
104817: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104818: LD_INT 0
104820: PPUSH
104821: PPUSH
// list := [ ] ;
104822: LD_ADDR_VAR 0 5
104826: PUSH
104827: EMPTY
104828: ST_TO_ADDR
// case d of 0 :
104829: LD_VAR 0 3
104833: PUSH
104834: LD_INT 0
104836: DOUBLE
104837: EQUAL
104838: IFTRUE 104842
104840: GO 104975
104842: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104843: LD_ADDR_VAR 0 5
104847: PUSH
104848: LD_VAR 0 1
104852: PUSH
104853: LD_INT 4
104855: MINUS
104856: PUSH
104857: LD_VAR 0 2
104861: PUSH
104862: LD_INT 4
104864: MINUS
104865: PUSH
104866: LD_INT 2
104868: PUSH
104869: EMPTY
104870: LIST
104871: LIST
104872: LIST
104873: PUSH
104874: LD_VAR 0 1
104878: PUSH
104879: LD_INT 3
104881: MINUS
104882: PUSH
104883: LD_VAR 0 2
104887: PUSH
104888: LD_INT 1
104890: PUSH
104891: EMPTY
104892: LIST
104893: LIST
104894: LIST
104895: PUSH
104896: LD_VAR 0 1
104900: PUSH
104901: LD_INT 4
104903: PLUS
104904: PUSH
104905: LD_VAR 0 2
104909: PUSH
104910: LD_INT 4
104912: PUSH
104913: EMPTY
104914: LIST
104915: LIST
104916: LIST
104917: PUSH
104918: LD_VAR 0 1
104922: PUSH
104923: LD_INT 3
104925: PLUS
104926: PUSH
104927: LD_VAR 0 2
104931: PUSH
104932: LD_INT 3
104934: PLUS
104935: PUSH
104936: LD_INT 5
104938: PUSH
104939: EMPTY
104940: LIST
104941: LIST
104942: LIST
104943: PUSH
104944: LD_VAR 0 1
104948: PUSH
104949: LD_VAR 0 2
104953: PUSH
104954: LD_INT 4
104956: PLUS
104957: PUSH
104958: LD_INT 0
104960: PUSH
104961: EMPTY
104962: LIST
104963: LIST
104964: LIST
104965: PUSH
104966: EMPTY
104967: LIST
104968: LIST
104969: LIST
104970: LIST
104971: LIST
104972: ST_TO_ADDR
// end ; 1 :
104973: GO 105673
104975: LD_INT 1
104977: DOUBLE
104978: EQUAL
104979: IFTRUE 104983
104981: GO 105116
104983: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104984: LD_ADDR_VAR 0 5
104988: PUSH
104989: LD_VAR 0 1
104993: PUSH
104994: LD_VAR 0 2
104998: PUSH
104999: LD_INT 4
105001: MINUS
105002: PUSH
105003: LD_INT 3
105005: PUSH
105006: EMPTY
105007: LIST
105008: LIST
105009: LIST
105010: PUSH
105011: LD_VAR 0 1
105015: PUSH
105016: LD_INT 3
105018: MINUS
105019: PUSH
105020: LD_VAR 0 2
105024: PUSH
105025: LD_INT 3
105027: MINUS
105028: PUSH
105029: LD_INT 2
105031: PUSH
105032: EMPTY
105033: LIST
105034: LIST
105035: LIST
105036: PUSH
105037: LD_VAR 0 1
105041: PUSH
105042: LD_INT 4
105044: MINUS
105045: PUSH
105046: LD_VAR 0 2
105050: PUSH
105051: LD_INT 1
105053: PUSH
105054: EMPTY
105055: LIST
105056: LIST
105057: LIST
105058: PUSH
105059: LD_VAR 0 1
105063: PUSH
105064: LD_VAR 0 2
105068: PUSH
105069: LD_INT 3
105071: PLUS
105072: PUSH
105073: LD_INT 0
105075: PUSH
105076: EMPTY
105077: LIST
105078: LIST
105079: LIST
105080: PUSH
105081: LD_VAR 0 1
105085: PUSH
105086: LD_INT 4
105088: PLUS
105089: PUSH
105090: LD_VAR 0 2
105094: PUSH
105095: LD_INT 4
105097: PLUS
105098: PUSH
105099: LD_INT 5
105101: PUSH
105102: EMPTY
105103: LIST
105104: LIST
105105: LIST
105106: PUSH
105107: EMPTY
105108: LIST
105109: LIST
105110: LIST
105111: LIST
105112: LIST
105113: ST_TO_ADDR
// end ; 2 :
105114: GO 105673
105116: LD_INT 2
105118: DOUBLE
105119: EQUAL
105120: IFTRUE 105124
105122: GO 105253
105124: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105125: LD_ADDR_VAR 0 5
105129: PUSH
105130: LD_VAR 0 1
105134: PUSH
105135: LD_VAR 0 2
105139: PUSH
105140: LD_INT 3
105142: MINUS
105143: PUSH
105144: LD_INT 3
105146: PUSH
105147: EMPTY
105148: LIST
105149: LIST
105150: LIST
105151: PUSH
105152: LD_VAR 0 1
105156: PUSH
105157: LD_INT 4
105159: PLUS
105160: PUSH
105161: LD_VAR 0 2
105165: PUSH
105166: LD_INT 4
105168: PUSH
105169: EMPTY
105170: LIST
105171: LIST
105172: LIST
105173: PUSH
105174: LD_VAR 0 1
105178: PUSH
105179: LD_VAR 0 2
105183: PUSH
105184: LD_INT 4
105186: PLUS
105187: PUSH
105188: LD_INT 0
105190: PUSH
105191: EMPTY
105192: LIST
105193: LIST
105194: LIST
105195: PUSH
105196: LD_VAR 0 1
105200: PUSH
105201: LD_INT 3
105203: MINUS
105204: PUSH
105205: LD_VAR 0 2
105209: PUSH
105210: LD_INT 1
105212: PUSH
105213: EMPTY
105214: LIST
105215: LIST
105216: LIST
105217: PUSH
105218: LD_VAR 0 1
105222: PUSH
105223: LD_INT 4
105225: MINUS
105226: PUSH
105227: LD_VAR 0 2
105231: PUSH
105232: LD_INT 4
105234: MINUS
105235: PUSH
105236: LD_INT 2
105238: PUSH
105239: EMPTY
105240: LIST
105241: LIST
105242: LIST
105243: PUSH
105244: EMPTY
105245: LIST
105246: LIST
105247: LIST
105248: LIST
105249: LIST
105250: ST_TO_ADDR
// end ; 3 :
105251: GO 105673
105253: LD_INT 3
105255: DOUBLE
105256: EQUAL
105257: IFTRUE 105261
105259: GO 105394
105261: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105262: LD_ADDR_VAR 0 5
105266: PUSH
105267: LD_VAR 0 1
105271: PUSH
105272: LD_INT 3
105274: PLUS
105275: PUSH
105276: LD_VAR 0 2
105280: PUSH
105281: LD_INT 4
105283: PUSH
105284: EMPTY
105285: LIST
105286: LIST
105287: LIST
105288: PUSH
105289: LD_VAR 0 1
105293: PUSH
105294: LD_INT 4
105296: PLUS
105297: PUSH
105298: LD_VAR 0 2
105302: PUSH
105303: LD_INT 4
105305: PLUS
105306: PUSH
105307: LD_INT 5
105309: PUSH
105310: EMPTY
105311: LIST
105312: LIST
105313: LIST
105314: PUSH
105315: LD_VAR 0 1
105319: PUSH
105320: LD_INT 4
105322: MINUS
105323: PUSH
105324: LD_VAR 0 2
105328: PUSH
105329: LD_INT 1
105331: PUSH
105332: EMPTY
105333: LIST
105334: LIST
105335: LIST
105336: PUSH
105337: LD_VAR 0 1
105341: PUSH
105342: LD_VAR 0 2
105346: PUSH
105347: LD_INT 4
105349: MINUS
105350: PUSH
105351: LD_INT 3
105353: PUSH
105354: EMPTY
105355: LIST
105356: LIST
105357: LIST
105358: PUSH
105359: LD_VAR 0 1
105363: PUSH
105364: LD_INT 3
105366: MINUS
105367: PUSH
105368: LD_VAR 0 2
105372: PUSH
105373: LD_INT 3
105375: MINUS
105376: PUSH
105377: LD_INT 2
105379: PUSH
105380: EMPTY
105381: LIST
105382: LIST
105383: LIST
105384: PUSH
105385: EMPTY
105386: LIST
105387: LIST
105388: LIST
105389: LIST
105390: LIST
105391: ST_TO_ADDR
// end ; 4 :
105392: GO 105673
105394: LD_INT 4
105396: DOUBLE
105397: EQUAL
105398: IFTRUE 105402
105400: GO 105535
105402: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105403: LD_ADDR_VAR 0 5
105407: PUSH
105408: LD_VAR 0 1
105412: PUSH
105413: LD_VAR 0 2
105417: PUSH
105418: LD_INT 4
105420: PLUS
105421: PUSH
105422: LD_INT 0
105424: PUSH
105425: EMPTY
105426: LIST
105427: LIST
105428: LIST
105429: PUSH
105430: LD_VAR 0 1
105434: PUSH
105435: LD_INT 3
105437: PLUS
105438: PUSH
105439: LD_VAR 0 2
105443: PUSH
105444: LD_INT 3
105446: PLUS
105447: PUSH
105448: LD_INT 5
105450: PUSH
105451: EMPTY
105452: LIST
105453: LIST
105454: LIST
105455: PUSH
105456: LD_VAR 0 1
105460: PUSH
105461: LD_INT 4
105463: PLUS
105464: PUSH
105465: LD_VAR 0 2
105469: PUSH
105470: LD_INT 4
105472: PUSH
105473: EMPTY
105474: LIST
105475: LIST
105476: LIST
105477: PUSH
105478: LD_VAR 0 1
105482: PUSH
105483: LD_VAR 0 2
105487: PUSH
105488: LD_INT 3
105490: MINUS
105491: PUSH
105492: LD_INT 3
105494: PUSH
105495: EMPTY
105496: LIST
105497: LIST
105498: LIST
105499: PUSH
105500: LD_VAR 0 1
105504: PUSH
105505: LD_INT 4
105507: MINUS
105508: PUSH
105509: LD_VAR 0 2
105513: PUSH
105514: LD_INT 4
105516: MINUS
105517: PUSH
105518: LD_INT 2
105520: PUSH
105521: EMPTY
105522: LIST
105523: LIST
105524: LIST
105525: PUSH
105526: EMPTY
105527: LIST
105528: LIST
105529: LIST
105530: LIST
105531: LIST
105532: ST_TO_ADDR
// end ; 5 :
105533: GO 105673
105535: LD_INT 5
105537: DOUBLE
105538: EQUAL
105539: IFTRUE 105543
105541: GO 105672
105543: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105544: LD_ADDR_VAR 0 5
105548: PUSH
105549: LD_VAR 0 1
105553: PUSH
105554: LD_INT 4
105556: MINUS
105557: PUSH
105558: LD_VAR 0 2
105562: PUSH
105563: LD_INT 1
105565: PUSH
105566: EMPTY
105567: LIST
105568: LIST
105569: LIST
105570: PUSH
105571: LD_VAR 0 1
105575: PUSH
105576: LD_VAR 0 2
105580: PUSH
105581: LD_INT 4
105583: MINUS
105584: PUSH
105585: LD_INT 3
105587: PUSH
105588: EMPTY
105589: LIST
105590: LIST
105591: LIST
105592: PUSH
105593: LD_VAR 0 1
105597: PUSH
105598: LD_INT 4
105600: PLUS
105601: PUSH
105602: LD_VAR 0 2
105606: PUSH
105607: LD_INT 4
105609: PLUS
105610: PUSH
105611: LD_INT 5
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: LIST
105618: PUSH
105619: LD_VAR 0 1
105623: PUSH
105624: LD_INT 3
105626: PLUS
105627: PUSH
105628: LD_VAR 0 2
105632: PUSH
105633: LD_INT 4
105635: PUSH
105636: EMPTY
105637: LIST
105638: LIST
105639: LIST
105640: PUSH
105641: LD_VAR 0 1
105645: PUSH
105646: LD_VAR 0 2
105650: PUSH
105651: LD_INT 3
105653: PLUS
105654: PUSH
105655: LD_INT 0
105657: PUSH
105658: EMPTY
105659: LIST
105660: LIST
105661: LIST
105662: PUSH
105663: EMPTY
105664: LIST
105665: LIST
105666: LIST
105667: LIST
105668: LIST
105669: ST_TO_ADDR
// end ; end ;
105670: GO 105673
105672: POP
// result := list ;
105673: LD_ADDR_VAR 0 4
105677: PUSH
105678: LD_VAR 0 5
105682: ST_TO_ADDR
// end ;
105683: LD_VAR 0 4
105687: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105688: LD_INT 0
105690: PPUSH
105691: PPUSH
105692: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105693: LD_VAR 0 1
105697: NOT
105698: PUSH
105699: LD_VAR 0 2
105703: PUSH
105704: LD_INT 1
105706: PUSH
105707: LD_INT 2
105709: PUSH
105710: LD_INT 3
105712: PUSH
105713: LD_INT 4
105715: PUSH
105716: EMPTY
105717: LIST
105718: LIST
105719: LIST
105720: LIST
105721: IN
105722: NOT
105723: OR
105724: IFFALSE 105728
// exit ;
105726: GO 105820
// tmp := [ ] ;
105728: LD_ADDR_VAR 0 5
105732: PUSH
105733: EMPTY
105734: ST_TO_ADDR
// for i in units do
105735: LD_ADDR_VAR 0 4
105739: PUSH
105740: LD_VAR 0 1
105744: PUSH
105745: FOR_IN
105746: IFFALSE 105789
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105748: LD_ADDR_VAR 0 5
105752: PUSH
105753: LD_VAR 0 5
105757: PPUSH
105758: LD_VAR 0 5
105762: PUSH
105763: LD_INT 1
105765: PLUS
105766: PPUSH
105767: LD_VAR 0 4
105771: PPUSH
105772: LD_VAR 0 2
105776: PPUSH
105777: CALL_OW 259
105781: PPUSH
105782: CALL_OW 2
105786: ST_TO_ADDR
105787: GO 105745
105789: POP
105790: POP
// if not tmp then
105791: LD_VAR 0 5
105795: NOT
105796: IFFALSE 105800
// exit ;
105798: GO 105820
// result := SortListByListDesc ( units , tmp ) ;
105800: LD_ADDR_VAR 0 3
105804: PUSH
105805: LD_VAR 0 1
105809: PPUSH
105810: LD_VAR 0 5
105814: PPUSH
105815: CALL_OW 77
105819: ST_TO_ADDR
// end ;
105820: LD_VAR 0 3
105824: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105825: LD_INT 0
105827: PPUSH
105828: PPUSH
105829: PPUSH
// x := GetX ( building ) ;
105830: LD_ADDR_VAR 0 4
105834: PUSH
105835: LD_VAR 0 2
105839: PPUSH
105840: CALL_OW 250
105844: ST_TO_ADDR
// y := GetY ( building ) ;
105845: LD_ADDR_VAR 0 5
105849: PUSH
105850: LD_VAR 0 2
105854: PPUSH
105855: CALL_OW 251
105859: ST_TO_ADDR
// if GetTaskList ( unit ) then
105860: LD_VAR 0 1
105864: PPUSH
105865: CALL_OW 437
105869: IFFALSE 105964
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105871: LD_STRING e
105873: PUSH
105874: LD_VAR 0 1
105878: PPUSH
105879: CALL_OW 437
105883: PUSH
105884: LD_INT 1
105886: ARRAY
105887: PUSH
105888: LD_INT 1
105890: ARRAY
105891: EQUAL
105892: PUSH
105893: LD_VAR 0 4
105897: PUSH
105898: LD_VAR 0 1
105902: PPUSH
105903: CALL_OW 437
105907: PUSH
105908: LD_INT 1
105910: ARRAY
105911: PUSH
105912: LD_INT 2
105914: ARRAY
105915: EQUAL
105916: AND
105917: PUSH
105918: LD_VAR 0 5
105922: PUSH
105923: LD_VAR 0 1
105927: PPUSH
105928: CALL_OW 437
105932: PUSH
105933: LD_INT 1
105935: ARRAY
105936: PUSH
105937: LD_INT 3
105939: ARRAY
105940: EQUAL
105941: AND
105942: IFFALSE 105954
// result := true else
105944: LD_ADDR_VAR 0 3
105948: PUSH
105949: LD_INT 1
105951: ST_TO_ADDR
105952: GO 105962
// result := false ;
105954: LD_ADDR_VAR 0 3
105958: PUSH
105959: LD_INT 0
105961: ST_TO_ADDR
// end else
105962: GO 105972
// result := false ;
105964: LD_ADDR_VAR 0 3
105968: PUSH
105969: LD_INT 0
105971: ST_TO_ADDR
// end ;
105972: LD_VAR 0 3
105976: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105977: LD_INT 0
105979: PPUSH
105980: PPUSH
105981: PPUSH
105982: PPUSH
// if not unit or not area then
105983: LD_VAR 0 1
105987: NOT
105988: PUSH
105989: LD_VAR 0 2
105993: NOT
105994: OR
105995: IFFALSE 105999
// exit ;
105997: GO 106163
// tmp := AreaToList ( area , i ) ;
105999: LD_ADDR_VAR 0 6
106003: PUSH
106004: LD_VAR 0 2
106008: PPUSH
106009: LD_VAR 0 5
106013: PPUSH
106014: CALL_OW 517
106018: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106019: LD_ADDR_VAR 0 5
106023: PUSH
106024: DOUBLE
106025: LD_INT 1
106027: DEC
106028: ST_TO_ADDR
106029: LD_VAR 0 6
106033: PUSH
106034: LD_INT 1
106036: ARRAY
106037: PUSH
106038: FOR_TO
106039: IFFALSE 106161
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106041: LD_ADDR_VAR 0 7
106045: PUSH
106046: LD_VAR 0 6
106050: PUSH
106051: LD_INT 1
106053: ARRAY
106054: PUSH
106055: LD_VAR 0 5
106059: ARRAY
106060: PUSH
106061: LD_VAR 0 6
106065: PUSH
106066: LD_INT 2
106068: ARRAY
106069: PUSH
106070: LD_VAR 0 5
106074: ARRAY
106075: PUSH
106076: EMPTY
106077: LIST
106078: LIST
106079: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106080: LD_VAR 0 7
106084: PUSH
106085: LD_INT 1
106087: ARRAY
106088: PPUSH
106089: LD_VAR 0 7
106093: PUSH
106094: LD_INT 2
106096: ARRAY
106097: PPUSH
106098: CALL_OW 428
106102: PUSH
106103: LD_INT 0
106105: EQUAL
106106: IFFALSE 106159
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106108: LD_VAR 0 1
106112: PPUSH
106113: LD_VAR 0 7
106117: PUSH
106118: LD_INT 1
106120: ARRAY
106121: PPUSH
106122: LD_VAR 0 7
106126: PUSH
106127: LD_INT 2
106129: ARRAY
106130: PPUSH
106131: LD_VAR 0 3
106135: PPUSH
106136: CALL_OW 48
// result := IsPlaced ( unit ) ;
106140: LD_ADDR_VAR 0 4
106144: PUSH
106145: LD_VAR 0 1
106149: PPUSH
106150: CALL_OW 305
106154: ST_TO_ADDR
// exit ;
106155: POP
106156: POP
106157: GO 106163
// end ; end ;
106159: GO 106038
106161: POP
106162: POP
// end ;
106163: LD_VAR 0 4
106167: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106168: LD_INT 0
106170: PPUSH
106171: PPUSH
106172: PPUSH
// if not side or side > 8 then
106173: LD_VAR 0 1
106177: NOT
106178: PUSH
106179: LD_VAR 0 1
106183: PUSH
106184: LD_INT 8
106186: GREATER
106187: OR
106188: IFFALSE 106192
// exit ;
106190: GO 106379
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106192: LD_ADDR_VAR 0 4
106196: PUSH
106197: LD_INT 22
106199: PUSH
106200: LD_VAR 0 1
106204: PUSH
106205: EMPTY
106206: LIST
106207: LIST
106208: PUSH
106209: LD_INT 21
106211: PUSH
106212: LD_INT 3
106214: PUSH
106215: EMPTY
106216: LIST
106217: LIST
106218: PUSH
106219: EMPTY
106220: LIST
106221: LIST
106222: PPUSH
106223: CALL_OW 69
106227: ST_TO_ADDR
// if not tmp then
106228: LD_VAR 0 4
106232: NOT
106233: IFFALSE 106237
// exit ;
106235: GO 106379
// enable_addtolog := true ;
106237: LD_ADDR_OWVAR 81
106241: PUSH
106242: LD_INT 1
106244: ST_TO_ADDR
// AddToLog ( [ ) ;
106245: LD_STRING [
106247: PPUSH
106248: CALL_OW 561
// for i in tmp do
106252: LD_ADDR_VAR 0 3
106256: PUSH
106257: LD_VAR 0 4
106261: PUSH
106262: FOR_IN
106263: IFFALSE 106370
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106265: LD_STRING [
106267: PUSH
106268: LD_VAR 0 3
106272: PPUSH
106273: CALL_OW 266
106277: STR
106278: PUSH
106279: LD_STRING , 
106281: STR
106282: PUSH
106283: LD_VAR 0 3
106287: PPUSH
106288: CALL_OW 250
106292: STR
106293: PUSH
106294: LD_STRING , 
106296: STR
106297: PUSH
106298: LD_VAR 0 3
106302: PPUSH
106303: CALL_OW 251
106307: STR
106308: PUSH
106309: LD_STRING , 
106311: STR
106312: PUSH
106313: LD_VAR 0 3
106317: PPUSH
106318: CALL_OW 254
106322: STR
106323: PUSH
106324: LD_STRING , 
106326: STR
106327: PUSH
106328: LD_VAR 0 3
106332: PPUSH
106333: LD_INT 1
106335: PPUSH
106336: CALL_OW 268
106340: STR
106341: PUSH
106342: LD_STRING , 
106344: STR
106345: PUSH
106346: LD_VAR 0 3
106350: PPUSH
106351: LD_INT 2
106353: PPUSH
106354: CALL_OW 268
106358: STR
106359: PUSH
106360: LD_STRING ],
106362: STR
106363: PPUSH
106364: CALL_OW 561
// end ;
106368: GO 106262
106370: POP
106371: POP
// AddToLog ( ]; ) ;
106372: LD_STRING ];
106374: PPUSH
106375: CALL_OW 561
// end ;
106379: LD_VAR 0 2
106383: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106384: LD_INT 0
106386: PPUSH
106387: PPUSH
106388: PPUSH
106389: PPUSH
106390: PPUSH
// if not area or not rate or not max then
106391: LD_VAR 0 1
106395: NOT
106396: PUSH
106397: LD_VAR 0 2
106401: NOT
106402: OR
106403: PUSH
106404: LD_VAR 0 4
106408: NOT
106409: OR
106410: IFFALSE 106414
// exit ;
106412: GO 106606
// while 1 do
106414: LD_INT 1
106416: IFFALSE 106606
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106418: LD_ADDR_VAR 0 9
106422: PUSH
106423: LD_VAR 0 1
106427: PPUSH
106428: LD_INT 1
106430: PPUSH
106431: CALL_OW 287
106435: PUSH
106436: LD_INT 10
106438: MUL
106439: ST_TO_ADDR
// r := rate / 10 ;
106440: LD_ADDR_VAR 0 7
106444: PUSH
106445: LD_VAR 0 2
106449: PUSH
106450: LD_INT 10
106452: DIVREAL
106453: ST_TO_ADDR
// time := 1 1$00 ;
106454: LD_ADDR_VAR 0 8
106458: PUSH
106459: LD_INT 2100
106461: ST_TO_ADDR
// if amount < min then
106462: LD_VAR 0 9
106466: PUSH
106467: LD_VAR 0 3
106471: LESS
106472: IFFALSE 106490
// r := r * 2 else
106474: LD_ADDR_VAR 0 7
106478: PUSH
106479: LD_VAR 0 7
106483: PUSH
106484: LD_INT 2
106486: MUL
106487: ST_TO_ADDR
106488: GO 106516
// if amount > max then
106490: LD_VAR 0 9
106494: PUSH
106495: LD_VAR 0 4
106499: GREATER
106500: IFFALSE 106516
// r := r / 2 ;
106502: LD_ADDR_VAR 0 7
106506: PUSH
106507: LD_VAR 0 7
106511: PUSH
106512: LD_INT 2
106514: DIVREAL
106515: ST_TO_ADDR
// time := time / r ;
106516: LD_ADDR_VAR 0 8
106520: PUSH
106521: LD_VAR 0 8
106525: PUSH
106526: LD_VAR 0 7
106530: DIVREAL
106531: ST_TO_ADDR
// if time < 0 then
106532: LD_VAR 0 8
106536: PUSH
106537: LD_INT 0
106539: LESS
106540: IFFALSE 106557
// time := time * - 1 ;
106542: LD_ADDR_VAR 0 8
106546: PUSH
106547: LD_VAR 0 8
106551: PUSH
106552: LD_INT 1
106554: NEG
106555: MUL
106556: ST_TO_ADDR
// wait ( time ) ;
106557: LD_VAR 0 8
106561: PPUSH
106562: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106566: LD_INT 35
106568: PPUSH
106569: LD_INT 875
106571: PPUSH
106572: CALL_OW 12
106576: PPUSH
106577: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106581: LD_INT 1
106583: PPUSH
106584: LD_INT 5
106586: PPUSH
106587: CALL_OW 12
106591: PPUSH
106592: LD_VAR 0 1
106596: PPUSH
106597: LD_INT 1
106599: PPUSH
106600: CALL_OW 55
// end ;
106604: GO 106414
// end ;
106606: LD_VAR 0 5
106610: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106611: LD_INT 0
106613: PPUSH
106614: PPUSH
106615: PPUSH
106616: PPUSH
106617: PPUSH
106618: PPUSH
106619: PPUSH
106620: PPUSH
// if not turrets or not factories then
106621: LD_VAR 0 1
106625: NOT
106626: PUSH
106627: LD_VAR 0 2
106631: NOT
106632: OR
106633: IFFALSE 106637
// exit ;
106635: GO 106944
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106637: LD_ADDR_VAR 0 10
106641: PUSH
106642: LD_INT 5
106644: PUSH
106645: LD_INT 6
106647: PUSH
106648: EMPTY
106649: LIST
106650: LIST
106651: PUSH
106652: LD_INT 2
106654: PUSH
106655: LD_INT 4
106657: PUSH
106658: EMPTY
106659: LIST
106660: LIST
106661: PUSH
106662: LD_INT 3
106664: PUSH
106665: LD_INT 5
106667: PUSH
106668: EMPTY
106669: LIST
106670: LIST
106671: PUSH
106672: EMPTY
106673: LIST
106674: LIST
106675: LIST
106676: PUSH
106677: LD_INT 24
106679: PUSH
106680: LD_INT 25
106682: PUSH
106683: EMPTY
106684: LIST
106685: LIST
106686: PUSH
106687: LD_INT 23
106689: PUSH
106690: LD_INT 27
106692: PUSH
106693: EMPTY
106694: LIST
106695: LIST
106696: PUSH
106697: EMPTY
106698: LIST
106699: LIST
106700: PUSH
106701: LD_INT 42
106703: PUSH
106704: LD_INT 43
106706: PUSH
106707: EMPTY
106708: LIST
106709: LIST
106710: PUSH
106711: LD_INT 44
106713: PUSH
106714: LD_INT 46
106716: PUSH
106717: EMPTY
106718: LIST
106719: LIST
106720: PUSH
106721: LD_INT 45
106723: PUSH
106724: LD_INT 47
106726: PUSH
106727: EMPTY
106728: LIST
106729: LIST
106730: PUSH
106731: EMPTY
106732: LIST
106733: LIST
106734: LIST
106735: PUSH
106736: EMPTY
106737: LIST
106738: LIST
106739: LIST
106740: ST_TO_ADDR
// result := [ ] ;
106741: LD_ADDR_VAR 0 3
106745: PUSH
106746: EMPTY
106747: ST_TO_ADDR
// for i in turrets do
106748: LD_ADDR_VAR 0 4
106752: PUSH
106753: LD_VAR 0 1
106757: PUSH
106758: FOR_IN
106759: IFFALSE 106942
// begin nat := GetNation ( i ) ;
106761: LD_ADDR_VAR 0 7
106765: PUSH
106766: LD_VAR 0 4
106770: PPUSH
106771: CALL_OW 248
106775: ST_TO_ADDR
// weapon := 0 ;
106776: LD_ADDR_VAR 0 8
106780: PUSH
106781: LD_INT 0
106783: ST_TO_ADDR
// if not nat then
106784: LD_VAR 0 7
106788: NOT
106789: IFFALSE 106793
// continue ;
106791: GO 106758
// for j in list [ nat ] do
106793: LD_ADDR_VAR 0 5
106797: PUSH
106798: LD_VAR 0 10
106802: PUSH
106803: LD_VAR 0 7
106807: ARRAY
106808: PUSH
106809: FOR_IN
106810: IFFALSE 106851
// if GetBWeapon ( i ) = j [ 1 ] then
106812: LD_VAR 0 4
106816: PPUSH
106817: CALL_OW 269
106821: PUSH
106822: LD_VAR 0 5
106826: PUSH
106827: LD_INT 1
106829: ARRAY
106830: EQUAL
106831: IFFALSE 106849
// begin weapon := j [ 2 ] ;
106833: LD_ADDR_VAR 0 8
106837: PUSH
106838: LD_VAR 0 5
106842: PUSH
106843: LD_INT 2
106845: ARRAY
106846: ST_TO_ADDR
// break ;
106847: GO 106851
// end ;
106849: GO 106809
106851: POP
106852: POP
// if not weapon then
106853: LD_VAR 0 8
106857: NOT
106858: IFFALSE 106862
// continue ;
106860: GO 106758
// for k in factories do
106862: LD_ADDR_VAR 0 6
106866: PUSH
106867: LD_VAR 0 2
106871: PUSH
106872: FOR_IN
106873: IFFALSE 106938
// begin weapons := AvailableWeaponList ( k ) ;
106875: LD_ADDR_VAR 0 9
106879: PUSH
106880: LD_VAR 0 6
106884: PPUSH
106885: CALL_OW 478
106889: ST_TO_ADDR
// if not weapons then
106890: LD_VAR 0 9
106894: NOT
106895: IFFALSE 106899
// continue ;
106897: GO 106872
// if weapon in weapons then
106899: LD_VAR 0 8
106903: PUSH
106904: LD_VAR 0 9
106908: IN
106909: IFFALSE 106936
// begin result := [ i , weapon ] ;
106911: LD_ADDR_VAR 0 3
106915: PUSH
106916: LD_VAR 0 4
106920: PUSH
106921: LD_VAR 0 8
106925: PUSH
106926: EMPTY
106927: LIST
106928: LIST
106929: ST_TO_ADDR
// exit ;
106930: POP
106931: POP
106932: POP
106933: POP
106934: GO 106944
// end ; end ;
106936: GO 106872
106938: POP
106939: POP
// end ;
106940: GO 106758
106942: POP
106943: POP
// end ;
106944: LD_VAR 0 3
106948: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
106949: LD_INT 0
106951: PPUSH
// if not side or side > 8 then
106952: LD_VAR 0 3
106956: NOT
106957: PUSH
106958: LD_VAR 0 3
106962: PUSH
106963: LD_INT 8
106965: GREATER
106966: OR
106967: IFFALSE 106971
// exit ;
106969: GO 107030
// if not range then
106971: LD_VAR 0 4
106975: NOT
106976: IFFALSE 106987
// range := - 12 ;
106978: LD_ADDR_VAR 0 4
106982: PUSH
106983: LD_INT 12
106985: NEG
106986: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106987: LD_VAR 0 1
106991: PPUSH
106992: LD_VAR 0 2
106996: PPUSH
106997: LD_VAR 0 3
107001: PPUSH
107002: LD_VAR 0 4
107006: PPUSH
107007: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107011: LD_VAR 0 1
107015: PPUSH
107016: LD_VAR 0 2
107020: PPUSH
107021: LD_VAR 0 3
107025: PPUSH
107026: CALL_OW 331
// end ;
107030: LD_VAR 0 5
107034: RET
// export function Video ( mode ) ; begin
107035: LD_INT 0
107037: PPUSH
// ingame_video = mode ;
107038: LD_ADDR_OWVAR 52
107042: PUSH
107043: LD_VAR 0 1
107047: ST_TO_ADDR
// interface_hidden = mode ;
107048: LD_ADDR_OWVAR 54
107052: PUSH
107053: LD_VAR 0 1
107057: ST_TO_ADDR
// end ;
107058: LD_VAR 0 2
107062: RET
// export function Join ( array , element ) ; begin
107063: LD_INT 0
107065: PPUSH
// result := array ^ element ;
107066: LD_ADDR_VAR 0 3
107070: PUSH
107071: LD_VAR 0 1
107075: PUSH
107076: LD_VAR 0 2
107080: ADD
107081: ST_TO_ADDR
// end ;
107082: LD_VAR 0 3
107086: RET
// export function JoinUnion ( array , element ) ; begin
107087: LD_INT 0
107089: PPUSH
// result := array union element ;
107090: LD_ADDR_VAR 0 3
107094: PUSH
107095: LD_VAR 0 1
107099: PUSH
107100: LD_VAR 0 2
107104: UNION
107105: ST_TO_ADDR
// end ;
107106: LD_VAR 0 3
107110: RET
// export function GetBehemoths ( side ) ; begin
107111: LD_INT 0
107113: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107114: LD_ADDR_VAR 0 2
107118: PUSH
107119: LD_INT 22
107121: PUSH
107122: LD_VAR 0 1
107126: PUSH
107127: EMPTY
107128: LIST
107129: LIST
107130: PUSH
107131: LD_INT 31
107133: PUSH
107134: LD_INT 25
107136: PUSH
107137: EMPTY
107138: LIST
107139: LIST
107140: PUSH
107141: EMPTY
107142: LIST
107143: LIST
107144: PPUSH
107145: CALL_OW 69
107149: ST_TO_ADDR
// end ;
107150: LD_VAR 0 2
107154: RET
// export function Shuffle ( array ) ; var i , index ; begin
107155: LD_INT 0
107157: PPUSH
107158: PPUSH
107159: PPUSH
// result := [ ] ;
107160: LD_ADDR_VAR 0 2
107164: PUSH
107165: EMPTY
107166: ST_TO_ADDR
// if not array then
107167: LD_VAR 0 1
107171: NOT
107172: IFFALSE 107176
// exit ;
107174: GO 107275
// Randomize ;
107176: CALL_OW 10
// for i = array downto 1 do
107180: LD_ADDR_VAR 0 3
107184: PUSH
107185: DOUBLE
107186: LD_VAR 0 1
107190: INC
107191: ST_TO_ADDR
107192: LD_INT 1
107194: PUSH
107195: FOR_DOWNTO
107196: IFFALSE 107273
// begin index := rand ( 1 , array ) ;
107198: LD_ADDR_VAR 0 4
107202: PUSH
107203: LD_INT 1
107205: PPUSH
107206: LD_VAR 0 1
107210: PPUSH
107211: CALL_OW 12
107215: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107216: LD_ADDR_VAR 0 2
107220: PUSH
107221: LD_VAR 0 2
107225: PPUSH
107226: LD_VAR 0 2
107230: PUSH
107231: LD_INT 1
107233: PLUS
107234: PPUSH
107235: LD_VAR 0 1
107239: PUSH
107240: LD_VAR 0 4
107244: ARRAY
107245: PPUSH
107246: CALL_OW 2
107250: ST_TO_ADDR
// array := Delete ( array , index ) ;
107251: LD_ADDR_VAR 0 1
107255: PUSH
107256: LD_VAR 0 1
107260: PPUSH
107261: LD_VAR 0 4
107265: PPUSH
107266: CALL_OW 3
107270: ST_TO_ADDR
// end ;
107271: GO 107195
107273: POP
107274: POP
// end ;
107275: LD_VAR 0 2
107279: RET
// export function GetBaseMaterials ( base ) ; begin
107280: LD_INT 0
107282: PPUSH
// result := [ 0 , 0 , 0 ] ;
107283: LD_ADDR_VAR 0 2
107287: PUSH
107288: LD_INT 0
107290: PUSH
107291: LD_INT 0
107293: PUSH
107294: LD_INT 0
107296: PUSH
107297: EMPTY
107298: LIST
107299: LIST
107300: LIST
107301: ST_TO_ADDR
// if not base then
107302: LD_VAR 0 1
107306: NOT
107307: IFFALSE 107311
// exit ;
107309: GO 107360
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107311: LD_ADDR_VAR 0 2
107315: PUSH
107316: LD_VAR 0 1
107320: PPUSH
107321: LD_INT 1
107323: PPUSH
107324: CALL_OW 275
107328: PUSH
107329: LD_VAR 0 1
107333: PPUSH
107334: LD_INT 2
107336: PPUSH
107337: CALL_OW 275
107341: PUSH
107342: LD_VAR 0 1
107346: PPUSH
107347: LD_INT 3
107349: PPUSH
107350: CALL_OW 275
107354: PUSH
107355: EMPTY
107356: LIST
107357: LIST
107358: LIST
107359: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107360: LD_VAR 0 2
107364: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107365: LD_INT 0
107367: PPUSH
107368: PPUSH
107369: PPUSH
107370: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107371: LD_VAR 0 1
107375: PPUSH
107376: CALL_OW 264
107380: PUSH
107381: LD_EXP 98
107385: EQUAL
107386: IFFALSE 107458
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107388: LD_INT 68
107390: PPUSH
107391: LD_VAR 0 1
107395: PPUSH
107396: CALL_OW 255
107400: PPUSH
107401: CALL_OW 321
107405: PUSH
107406: LD_INT 2
107408: EQUAL
107409: IFFALSE 107421
// eff := 70 else
107411: LD_ADDR_VAR 0 6
107415: PUSH
107416: LD_INT 70
107418: ST_TO_ADDR
107419: GO 107429
// eff := 30 ;
107421: LD_ADDR_VAR 0 6
107425: PUSH
107426: LD_INT 30
107428: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107429: LD_VAR 0 1
107433: PPUSH
107434: CALL_OW 250
107438: PPUSH
107439: LD_VAR 0 1
107443: PPUSH
107444: CALL_OW 251
107448: PPUSH
107449: LD_VAR 0 6
107453: PPUSH
107454: CALL_OW 495
// end ; end ;
107458: LD_VAR 0 4
107462: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107463: LD_INT 0
107465: PPUSH
107466: PPUSH
107467: PPUSH
107468: PPUSH
107469: PPUSH
107470: PPUSH
// if cmd = 124 then
107471: LD_VAR 0 1
107475: PUSH
107476: LD_INT 124
107478: EQUAL
107479: IFFALSE 107685
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107481: LD_ADDR_VAR 0 5
107485: PUSH
107486: LD_INT 2
107488: PUSH
107489: LD_INT 34
107491: PUSH
107492: LD_INT 53
107494: PUSH
107495: EMPTY
107496: LIST
107497: LIST
107498: PUSH
107499: LD_INT 34
107501: PUSH
107502: LD_INT 14
107504: PUSH
107505: EMPTY
107506: LIST
107507: LIST
107508: PUSH
107509: EMPTY
107510: LIST
107511: LIST
107512: LIST
107513: PPUSH
107514: CALL_OW 69
107518: ST_TO_ADDR
// if not tmp then
107519: LD_VAR 0 5
107523: NOT
107524: IFFALSE 107528
// exit ;
107526: GO 107685
// for i in tmp do
107528: LD_ADDR_VAR 0 3
107532: PUSH
107533: LD_VAR 0 5
107537: PUSH
107538: FOR_IN
107539: IFFALSE 107683
// begin taskList := GetTaskList ( i ) ;
107541: LD_ADDR_VAR 0 6
107545: PUSH
107546: LD_VAR 0 3
107550: PPUSH
107551: CALL_OW 437
107555: ST_TO_ADDR
// if not taskList then
107556: LD_VAR 0 6
107560: NOT
107561: IFFALSE 107565
// continue ;
107563: GO 107538
// for j = 1 to taskList do
107565: LD_ADDR_VAR 0 4
107569: PUSH
107570: DOUBLE
107571: LD_INT 1
107573: DEC
107574: ST_TO_ADDR
107575: LD_VAR 0 6
107579: PUSH
107580: FOR_TO
107581: IFFALSE 107679
// if taskList [ j ] [ 1 ] = | then
107583: LD_VAR 0 6
107587: PUSH
107588: LD_VAR 0 4
107592: ARRAY
107593: PUSH
107594: LD_INT 1
107596: ARRAY
107597: PUSH
107598: LD_STRING |
107600: EQUAL
107601: IFFALSE 107677
// begin _taskList := Delete ( taskList , 1 ) ;
107603: LD_ADDR_VAR 0 7
107607: PUSH
107608: LD_VAR 0 6
107612: PPUSH
107613: LD_INT 1
107615: PPUSH
107616: CALL_OW 3
107620: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107621: LD_VAR 0 3
107625: PPUSH
107626: LD_VAR 0 7
107630: PPUSH
107631: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107635: LD_VAR 0 3
107639: PPUSH
107640: LD_VAR 0 6
107644: PUSH
107645: LD_VAR 0 4
107649: ARRAY
107650: PUSH
107651: LD_INT 2
107653: ARRAY
107654: PPUSH
107655: LD_VAR 0 6
107659: PUSH
107660: LD_VAR 0 4
107664: ARRAY
107665: PUSH
107666: LD_INT 3
107668: ARRAY
107669: PPUSH
107670: LD_INT 8
107672: PPUSH
107673: CALL 107690 0 4
// end ;
107677: GO 107580
107679: POP
107680: POP
// end ;
107681: GO 107538
107683: POP
107684: POP
// end ; end ;
107685: LD_VAR 0 2
107689: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107690: LD_INT 0
107692: PPUSH
107693: PPUSH
107694: PPUSH
107695: PPUSH
107696: PPUSH
107697: PPUSH
107698: PPUSH
107699: PPUSH
107700: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107701: LD_VAR 0 1
107705: NOT
107706: PUSH
107707: LD_VAR 0 2
107711: PPUSH
107712: LD_VAR 0 3
107716: PPUSH
107717: CALL_OW 488
107721: NOT
107722: OR
107723: PUSH
107724: LD_VAR 0 4
107728: NOT
107729: OR
107730: IFFALSE 107734
// exit ;
107732: GO 108074
// list := [ ] ;
107734: LD_ADDR_VAR 0 13
107738: PUSH
107739: EMPTY
107740: ST_TO_ADDR
// if x - r < 0 then
107741: LD_VAR 0 2
107745: PUSH
107746: LD_VAR 0 4
107750: MINUS
107751: PUSH
107752: LD_INT 0
107754: LESS
107755: IFFALSE 107767
// min_x := 0 else
107757: LD_ADDR_VAR 0 7
107761: PUSH
107762: LD_INT 0
107764: ST_TO_ADDR
107765: GO 107783
// min_x := x - r ;
107767: LD_ADDR_VAR 0 7
107771: PUSH
107772: LD_VAR 0 2
107776: PUSH
107777: LD_VAR 0 4
107781: MINUS
107782: ST_TO_ADDR
// if y - r < 0 then
107783: LD_VAR 0 3
107787: PUSH
107788: LD_VAR 0 4
107792: MINUS
107793: PUSH
107794: LD_INT 0
107796: LESS
107797: IFFALSE 107809
// min_y := 0 else
107799: LD_ADDR_VAR 0 8
107803: PUSH
107804: LD_INT 0
107806: ST_TO_ADDR
107807: GO 107825
// min_y := y - r ;
107809: LD_ADDR_VAR 0 8
107813: PUSH
107814: LD_VAR 0 3
107818: PUSH
107819: LD_VAR 0 4
107823: MINUS
107824: ST_TO_ADDR
// max_x := x + r ;
107825: LD_ADDR_VAR 0 9
107829: PUSH
107830: LD_VAR 0 2
107834: PUSH
107835: LD_VAR 0 4
107839: PLUS
107840: ST_TO_ADDR
// max_y := y + r ;
107841: LD_ADDR_VAR 0 10
107845: PUSH
107846: LD_VAR 0 3
107850: PUSH
107851: LD_VAR 0 4
107855: PLUS
107856: ST_TO_ADDR
// for _x = min_x to max_x do
107857: LD_ADDR_VAR 0 11
107861: PUSH
107862: DOUBLE
107863: LD_VAR 0 7
107867: DEC
107868: ST_TO_ADDR
107869: LD_VAR 0 9
107873: PUSH
107874: FOR_TO
107875: IFFALSE 107992
// for _y = min_y to max_y do
107877: LD_ADDR_VAR 0 12
107881: PUSH
107882: DOUBLE
107883: LD_VAR 0 8
107887: DEC
107888: ST_TO_ADDR
107889: LD_VAR 0 10
107893: PUSH
107894: FOR_TO
107895: IFFALSE 107988
// begin if not ValidHex ( _x , _y ) then
107897: LD_VAR 0 11
107901: PPUSH
107902: LD_VAR 0 12
107906: PPUSH
107907: CALL_OW 488
107911: NOT
107912: IFFALSE 107916
// continue ;
107914: GO 107894
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107916: LD_VAR 0 11
107920: PPUSH
107921: LD_VAR 0 12
107925: PPUSH
107926: CALL_OW 351
107930: PUSH
107931: LD_VAR 0 11
107935: PPUSH
107936: LD_VAR 0 12
107940: PPUSH
107941: CALL_OW 554
107945: AND
107946: IFFALSE 107986
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107948: LD_ADDR_VAR 0 13
107952: PUSH
107953: LD_VAR 0 13
107957: PPUSH
107958: LD_VAR 0 13
107962: PUSH
107963: LD_INT 1
107965: PLUS
107966: PPUSH
107967: LD_VAR 0 11
107971: PUSH
107972: LD_VAR 0 12
107976: PUSH
107977: EMPTY
107978: LIST
107979: LIST
107980: PPUSH
107981: CALL_OW 2
107985: ST_TO_ADDR
// end ;
107986: GO 107894
107988: POP
107989: POP
107990: GO 107874
107992: POP
107993: POP
// if not list then
107994: LD_VAR 0 13
107998: NOT
107999: IFFALSE 108003
// exit ;
108001: GO 108074
// for i in list do
108003: LD_ADDR_VAR 0 6
108007: PUSH
108008: LD_VAR 0 13
108012: PUSH
108013: FOR_IN
108014: IFFALSE 108072
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108016: LD_VAR 0 1
108020: PPUSH
108021: LD_STRING M
108023: PUSH
108024: LD_VAR 0 6
108028: PUSH
108029: LD_INT 1
108031: ARRAY
108032: PUSH
108033: LD_VAR 0 6
108037: PUSH
108038: LD_INT 2
108040: ARRAY
108041: PUSH
108042: LD_INT 0
108044: PUSH
108045: LD_INT 0
108047: PUSH
108048: LD_INT 0
108050: PUSH
108051: LD_INT 0
108053: PUSH
108054: EMPTY
108055: LIST
108056: LIST
108057: LIST
108058: LIST
108059: LIST
108060: LIST
108061: LIST
108062: PUSH
108063: EMPTY
108064: LIST
108065: PPUSH
108066: CALL_OW 447
108070: GO 108013
108072: POP
108073: POP
// end ;
108074: LD_VAR 0 5
108078: RET
