// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 36872 0 0
// InitNature ;
  19: CALL 36740 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11915 0 0
// PrepareRussian ;
  40: CALL 7187 0 0
// PrepareLegion ;
  44: CALL 4342 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 15994 0 0
// MC_Start ( ) ;
  60: CALL 39044 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 124
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 125
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 61842 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 61935 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 61285 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 61100 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 61842 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 61935 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 61100 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 61285 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 61715 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 60782 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 61842 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 61935 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 129
 971: PUSH
 972: LD_EXP 129
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 61100 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 61842 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 61935 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 60992 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 62253 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61424 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 61715 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 61715 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 62047 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 61100 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 61666 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67536 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72551 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72551 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72551 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72551 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72551 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67536 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67536 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67536 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67536 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 67536 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 67536 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 67536 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 67536 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 67536 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 67536 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 67536 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 67536 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 67536 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 67536 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 67536 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3159: LD_ADDR_EXP 60
3163: PUSH
3164: LD_STRING Powell
3166: PPUSH
3167: CALL_OW 25
3171: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3172: LD_EXP 60
3176: PPUSH
3177: LD_INT 57
3179: PPUSH
3180: LD_INT 94
3182: PPUSH
3183: LD_INT 0
3185: PPUSH
3186: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3190: LD_EXP 60
3194: PPUSH
3195: LD_INT 58
3197: PPUSH
3198: LD_INT 94
3200: PPUSH
3201: CALL_OW 118
// vip := [ ] ;
3205: LD_ADDR_EXP 61
3209: PUSH
3210: EMPTY
3211: ST_TO_ADDR
// tmp := [ ] ;
3212: LD_ADDR_VAR 0 5
3216: PUSH
3217: EMPTY
3218: ST_TO_ADDR
// if JMMGirl <> 2 then
3219: LD_EXP 7
3223: PUSH
3224: LD_INT 2
3226: NONEQUAL
3227: IFFALSE 3251
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3229: LD_ADDR_EXP 43
3233: PUSH
3234: LD_STRING Lisa
3236: PPUSH
3237: LD_EXP 1
3241: NOT
3242: PPUSH
3243: LD_STRING 13s_
3245: PPUSH
3246: CALL 67536 0 3
3250: ST_TO_ADDR
// if Lisa then
3251: LD_EXP 43
3255: IFFALSE 3273
// tmp := tmp ^ Lisa ;
3257: LD_ADDR_VAR 0 5
3261: PUSH
3262: LD_VAR 0 5
3266: PUSH
3267: LD_EXP 43
3271: ADD
3272: ST_TO_ADDR
// if JMMGirl < 3 then
3273: LD_EXP 7
3277: PUSH
3278: LD_INT 3
3280: LESS
3281: IFFALSE 3312
// begin Connie := NewCharacter ( Coonie ) ;
3283: LD_ADDR_EXP 55
3287: PUSH
3288: LD_STRING Coonie
3290: PPUSH
3291: CALL_OW 25
3295: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3296: LD_ADDR_VAR 0 5
3300: PUSH
3301: LD_VAR 0 5
3305: PUSH
3306: LD_EXP 55
3310: ADD
3311: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 44
3316: PUSH
3317: LD_STRING Donaldson
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 67536 0 3
3333: ST_TO_ADDR
// if Donaldson then
3334: LD_EXP 44
3338: IFFALSE 3356
// tmp := tmp ^ Donaldson ;
3340: LD_ADDR_VAR 0 5
3344: PUSH
3345: LD_VAR 0 5
3349: PUSH
3350: LD_EXP 44
3354: ADD
3355: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 45
3360: PUSH
3361: LD_STRING Bobby
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 67536 0 3
3377: ST_TO_ADDR
// if Bobby then
3378: LD_EXP 45
3382: IFFALSE 3400
// tmp := tmp ^ Bobby ;
3384: LD_ADDR_VAR 0 5
3388: PUSH
3389: LD_VAR 0 5
3393: PUSH
3394: LD_EXP 45
3398: ADD
3399: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 46
3404: PUSH
3405: LD_STRING Cyrus
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 67536 0 3
3421: ST_TO_ADDR
// if Cyrus then
3422: LD_EXP 46
3426: IFFALSE 3444
// tmp := tmp ^ Cyrus ;
3428: LD_ADDR_VAR 0 5
3432: PUSH
3433: LD_VAR 0 5
3437: PUSH
3438: LD_EXP 46
3442: ADD
3443: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 47
3448: PUSH
3449: LD_STRING Denis
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 67536 0 3
3465: ST_TO_ADDR
// if not Denis then
3466: LD_EXP 47
3470: NOT
3471: IFFALSE 3495
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3473: LD_ADDR_EXP 47
3477: PUSH
3478: LD_STRING Denis
3480: PPUSH
3481: LD_EXP 1
3485: NOT
3486: PPUSH
3487: LD_STRING 13f_
3489: PPUSH
3490: CALL 67536 0 3
3494: ST_TO_ADDR
// if Denis then
3495: LD_EXP 47
3499: IFFALSE 3517
// tmp := tmp ^ Denis ;
3501: LD_ADDR_VAR 0 5
3505: PUSH
3506: LD_VAR 0 5
3510: PUSH
3511: LD_EXP 47
3515: ADD
3516: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3517: LD_ADDR_EXP 48
3521: PUSH
3522: LD_STRING Brown
3524: PPUSH
3525: LD_EXP 1
3529: NOT
3530: PPUSH
3531: LD_STRING 13s_
3533: PPUSH
3534: CALL 67536 0 3
3538: ST_TO_ADDR
// if Brown then
3539: LD_EXP 48
3543: IFFALSE 3561
// tmp := tmp ^ Brown ;
3545: LD_ADDR_VAR 0 5
3549: PUSH
3550: LD_VAR 0 5
3554: PUSH
3555: LD_EXP 48
3559: ADD
3560: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3561: LD_ADDR_EXP 49
3565: PUSH
3566: LD_STRING Gladstone
3568: PPUSH
3569: LD_EXP 1
3573: NOT
3574: PPUSH
3575: LD_STRING 13s_
3577: PPUSH
3578: CALL 67536 0 3
3582: ST_TO_ADDR
// if Gladstone then
3583: LD_EXP 49
3587: IFFALSE 3605
// tmp := tmp ^ Gladstone ;
3589: LD_ADDR_VAR 0 5
3593: PUSH
3594: LD_VAR 0 5
3598: PUSH
3599: LD_EXP 49
3603: ADD
3604: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3605: LD_ADDR_EXP 50
3609: PUSH
3610: LD_STRING Houten
3612: PPUSH
3613: LD_EXP 1
3617: NOT
3618: PPUSH
3619: LD_STRING 13s_
3621: PPUSH
3622: CALL 67536 0 3
3626: ST_TO_ADDR
// if Houten then
3627: LD_EXP 50
3631: IFFALSE 3649
// tmp := tmp ^ Houten ;
3633: LD_ADDR_VAR 0 5
3637: PUSH
3638: LD_VAR 0 5
3642: PUSH
3643: LD_EXP 50
3647: ADD
3648: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3649: LD_ADDR_EXP 51
3653: PUSH
3654: LD_STRING Cornel
3656: PPUSH
3657: LD_EXP 1
3661: NOT
3662: PPUSH
3663: LD_STRING 13s_
3665: PPUSH
3666: CALL 67536 0 3
3670: ST_TO_ADDR
// if Cornel then
3671: LD_EXP 51
3675: IFFALSE 3693
// tmp := tmp ^ Cornel ;
3677: LD_ADDR_VAR 0 5
3681: PUSH
3682: LD_VAR 0 5
3686: PUSH
3687: LD_EXP 51
3691: ADD
3692: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3693: LD_ADDR_EXP 52
3697: PUSH
3698: LD_STRING Gary
3700: PPUSH
3701: LD_EXP 1
3705: NOT
3706: PPUSH
3707: LD_STRING 13s_
3709: PPUSH
3710: CALL 67536 0 3
3714: ST_TO_ADDR
// if Gary then
3715: LD_EXP 52
3719: IFFALSE 3737
// tmp := tmp ^ Gary ;
3721: LD_ADDR_VAR 0 5
3725: PUSH
3726: LD_VAR 0 5
3730: PUSH
3731: LD_EXP 52
3735: ADD
3736: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3737: LD_ADDR_EXP 53
3741: PUSH
3742: LD_STRING Frank
3744: PPUSH
3745: LD_EXP 1
3749: NOT
3750: PPUSH
3751: LD_STRING 13s_
3753: PPUSH
3754: CALL 67536 0 3
3758: ST_TO_ADDR
// if Frank then
3759: LD_EXP 53
3763: IFFALSE 3781
// tmp := tmp ^ Frank ;
3765: LD_ADDR_VAR 0 5
3769: PUSH
3770: LD_VAR 0 5
3774: PUSH
3775: LD_EXP 53
3779: ADD
3780: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3781: LD_ADDR_EXP 54
3785: PUSH
3786: LD_STRING Kikuchi
3788: PPUSH
3789: LD_EXP 1
3793: NOT
3794: PPUSH
3795: LD_STRING 13s_
3797: PPUSH
3798: CALL 67536 0 3
3802: ST_TO_ADDR
// if Kikuchi then
3803: LD_EXP 54
3807: IFFALSE 3825
// tmp := tmp ^ Kikuchi ;
3809: LD_ADDR_VAR 0 5
3813: PUSH
3814: LD_VAR 0 5
3818: PUSH
3819: LD_EXP 54
3823: ADD
3824: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3825: LD_ADDR_EXP 57
3829: PUSH
3830: LD_STRING Mike
3832: PPUSH
3833: LD_EXP 1
3837: NOT
3838: PPUSH
3839: LD_STRING 10c_
3841: PPUSH
3842: CALL 67536 0 3
3846: ST_TO_ADDR
// if Mike then
3847: LD_EXP 57
3851: IFFALSE 3874
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3853: LD_EXP 57
3857: PPUSH
3858: LD_INT 61
3860: PPUSH
3861: LD_INT 89
3863: PPUSH
3864: LD_INT 8
3866: PPUSH
3867: LD_INT 0
3869: PPUSH
3870: CALL_OW 50
// vip := tmp ;
3874: LD_ADDR_EXP 61
3878: PUSH
3879: LD_VAR 0 5
3883: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3884: LD_ADDR_VAR 0 5
3888: PUSH
3889: LD_VAR 0 5
3893: PUSH
3894: LD_STRING 13s_others
3896: PPUSH
3897: CALL_OW 31
3901: UNION
3902: ST_TO_ADDR
// if tmp < 18 then
3903: LD_VAR 0 5
3907: PUSH
3908: LD_INT 18
3910: LESS
3911: IFFALSE 4004
// for i = 1 to 18 - tmp do
3913: LD_ADDR_VAR 0 2
3917: PUSH
3918: DOUBLE
3919: LD_INT 1
3921: DEC
3922: ST_TO_ADDR
3923: LD_INT 18
3925: PUSH
3926: LD_VAR 0 5
3930: MINUS
3931: PUSH
3932: FOR_TO
3933: IFFALSE 4002
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3935: LD_INT 1
3937: PPUSH
3938: LD_VAR 0 2
3942: PUSH
3943: LD_INT 4
3945: MOD
3946: PUSH
3947: LD_INT 1
3949: PLUS
3950: PPUSH
3951: LD_INT 4
3953: PPUSH
3954: CALL_OW 380
// un := CreateHuman ;
3958: LD_ADDR_VAR 0 10
3962: PUSH
3963: CALL_OW 44
3967: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3968: LD_ADDR_VAR 0 5
3972: PUSH
3973: LD_VAR 0 5
3977: PPUSH
3978: LD_VAR 0 10
3982: PPUSH
3983: CALL 105004 0 2
3987: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3988: LD_VAR 0 10
3992: PPUSH
3993: LD_INT 1
3995: PPUSH
3996: CALL_OW 109
// end ;
4000: GO 3932
4002: POP
4003: POP
// depot := HexInfo ( 53 , 94 ) ;
4004: LD_ADDR_VAR 0 6
4008: PUSH
4009: LD_INT 53
4011: PPUSH
4012: LD_INT 94
4014: PPUSH
4015: CALL_OW 428
4019: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4020: LD_ADDR_VAR 0 7
4024: PUSH
4025: LD_INT 56
4027: PPUSH
4028: LD_INT 101
4030: PPUSH
4031: CALL_OW 428
4035: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4036: LD_ADDR_VAR 0 8
4040: PUSH
4041: LD_INT 67
4043: PPUSH
4044: LD_INT 101
4046: PPUSH
4047: CALL_OW 428
4051: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4052: LD_ADDR_VAR 0 9
4056: PUSH
4057: LD_INT 54
4059: PPUSH
4060: LD_INT 85
4062: PPUSH
4063: CALL_OW 428
4067: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4068: LD_ADDR_VAR 0 3
4072: PUSH
4073: LD_VAR 0 8
4077: PUSH
4078: LD_VAR 0 6
4082: PUSH
4083: LD_VAR 0 9
4087: PUSH
4088: LD_VAR 0 7
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// for i in tmp do
4099: LD_ADDR_VAR 0 2
4103: PUSH
4104: LD_VAR 0 5
4108: PUSH
4109: FOR_IN
4110: IFFALSE 4198
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4112: LD_VAR 0 3
4116: PUSH
4117: LD_INT 1
4119: ARRAY
4120: PPUSH
4121: CALL_OW 313
4125: PUSH
4126: LD_INT 6
4128: EQUAL
4129: IFFALSE 4149
// b := Delete ( b , 1 ) ;
4131: LD_ADDR_VAR 0 3
4135: PUSH
4136: LD_VAR 0 3
4140: PPUSH
4141: LD_INT 1
4143: PPUSH
4144: CALL_OW 3
4148: ST_TO_ADDR
// if b then
4149: LD_VAR 0 3
4153: IFFALSE 4175
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4155: LD_VAR 0 2
4159: PPUSH
4160: LD_VAR 0 3
4164: PUSH
4165: LD_INT 1
4167: ARRAY
4168: PPUSH
4169: CALL_OW 52
4173: GO 4196
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4175: LD_VAR 0 2
4179: PPUSH
4180: LD_INT 61
4182: PPUSH
4183: LD_INT 89
4185: PPUSH
4186: LD_INT 8
4188: PPUSH
4189: LD_INT 0
4191: PPUSH
4192: CALL_OW 50
// end ;
4196: GO 4109
4198: POP
4199: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4200: LD_INT 2
4202: PPUSH
4203: LD_INT 1
4205: PPUSH
4206: LD_INT 1
4208: PPUSH
4209: LD_INT 12
4211: PPUSH
4212: LD_INT 100
4214: PPUSH
4215: CALL 72551 0 5
// veh := CreateVehicle ;
4219: LD_ADDR_VAR 0 4
4223: PUSH
4224: CALL_OW 45
4228: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4229: LD_VAR 0 4
4233: PPUSH
4234: LD_INT 4
4236: PPUSH
4237: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4241: LD_VAR 0 4
4245: PPUSH
4246: LD_INT 49
4248: PPUSH
4249: LD_INT 88
4251: PPUSH
4252: LD_INT 0
4254: PPUSH
4255: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4259: LD_VAR 0 4
4263: PPUSH
4264: LD_INT 1
4266: PPUSH
4267: LD_INT 100
4269: PPUSH
4270: CALL_OW 290
// uc_side := 0 ;
4274: LD_ADDR_OWVAR 20
4278: PUSH
4279: LD_INT 0
4281: ST_TO_ADDR
// uc_nation := 0 ;
4282: LD_ADDR_OWVAR 21
4286: PUSH
4287: LD_INT 0
4289: ST_TO_ADDR
// for i := 1 to 3 do
4290: LD_ADDR_VAR 0 2
4294: PUSH
4295: DOUBLE
4296: LD_INT 1
4298: DEC
4299: ST_TO_ADDR
4300: LD_INT 3
4302: PUSH
4303: FOR_TO
4304: IFFALSE 4335
// begin InitHc ;
4306: CALL_OW 19
// hc_class := class_apeman ;
4310: LD_ADDR_OWVAR 28
4314: PUSH
4315: LD_INT 12
4317: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4318: CALL_OW 44
4322: PPUSH
4323: LD_INT 13
4325: PPUSH
4326: LD_INT 0
4328: PPUSH
4329: CALL_OW 49
// end ;
4333: GO 4303
4335: POP
4336: POP
// end ; end_of_file
4337: LD_VAR 0 1
4341: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4342: LD_INT 0
4344: PPUSH
4345: PPUSH
4346: PPUSH
4347: PPUSH
4348: PPUSH
// side := 8 ;
4349: LD_ADDR_VAR 0 3
4353: PUSH
4354: LD_INT 8
4356: ST_TO_ADDR
// uc_side := side ;
4357: LD_ADDR_OWVAR 20
4361: PUSH
4362: LD_VAR 0 3
4366: ST_TO_ADDR
// uc_nation := 2 ;
4367: LD_ADDR_OWVAR 21
4371: PUSH
4372: LD_INT 2
4374: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4375: LD_ADDR_VAR 0 2
4379: PUSH
4380: LD_INT 22
4382: PUSH
4383: LD_VAR 0 3
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: LD_INT 21
4394: PUSH
4395: LD_INT 3
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PPUSH
4406: CALL_OW 69
4410: PUSH
4411: FOR_IN
4412: IFFALSE 4428
// SetBLevel ( i , 10 ) ;
4414: LD_VAR 0 2
4418: PPUSH
4419: LD_INT 10
4421: PPUSH
4422: CALL_OW 241
4426: GO 4411
4428: POP
4429: POP
// if KurtStatus then
4430: LD_EXP 3
4434: IFFALSE 4457
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4436: LD_ADDR_EXP 62
4440: PUSH
4441: LD_STRING Kurt
4443: PPUSH
4444: LD_INT 0
4446: PPUSH
4447: LD_STRING 
4449: PPUSH
4450: CALL 67536 0 3
4454: ST_TO_ADDR
4455: GO 4479
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4457: LD_ADDR_EXP 62
4461: PUSH
4462: LD_STRING AltKurt
4464: PPUSH
4465: LD_EXP 1
4469: NOT
4470: PPUSH
4471: LD_STRING 
4473: PPUSH
4474: CALL 67536 0 3
4478: ST_TO_ADDR
// if not Kurt then
4479: LD_EXP 62
4483: NOT
4484: IFFALSE 4510
// begin InitHc ;
4486: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4490: LD_INT 1
4492: PPUSH
4493: LD_INT 10
4495: PPUSH
4496: CALL_OW 381
// Kurt := CreateHuman ;
4500: LD_ADDR_EXP 62
4504: PUSH
4505: CALL_OW 44
4509: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4510: LD_EXP 62
4514: PPUSH
4515: LD_INT 324
4517: PPUSH
4518: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4522: LD_ADDR_EXP 63
4526: PUSH
4527: LD_STRING Kozlov
4529: PPUSH
4530: LD_INT 0
4532: PPUSH
4533: LD_STRING 
4535: PPUSH
4536: CALL 67536 0 3
4540: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4541: LD_EXP 63
4545: PPUSH
4546: LD_INT 22
4548: PUSH
4549: LD_INT 8
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 23
4558: PUSH
4559: LD_INT 3
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 30
4568: PUSH
4569: LD_INT 8
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: LIST
4580: PPUSH
4581: CALL_OW 69
4585: PUSH
4586: LD_INT 1
4588: ARRAY
4589: PPUSH
4590: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4594: LD_EXP 63
4598: PPUSH
4599: LD_INT 3
4601: PPUSH
4602: LD_INT 10
4604: PPUSH
4605: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4609: LD_EXP 63
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 10
4619: PPUSH
4620: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4624: LD_ADDR_VAR 0 5
4628: PUSH
4629: LD_INT 22
4631: PUSH
4632: LD_VAR 0 3
4636: PUSH
4637: EMPTY
4638: LIST
4639: LIST
4640: PUSH
4641: LD_INT 30
4643: PUSH
4644: LD_INT 32
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PUSH
4651: LD_INT 58
4653: PUSH
4654: EMPTY
4655: LIST
4656: PUSH
4657: EMPTY
4658: LIST
4659: LIST
4660: LIST
4661: PPUSH
4662: CALL_OW 69
4666: ST_TO_ADDR
// for i = 1 to 10 do
4667: LD_ADDR_VAR 0 2
4671: PUSH
4672: DOUBLE
4673: LD_INT 1
4675: DEC
4676: ST_TO_ADDR
4677: LD_INT 10
4679: PUSH
4680: FOR_TO
4681: IFFALSE 4753
// begin uc_nation := nation_nature ;
4683: LD_ADDR_OWVAR 21
4687: PUSH
4688: LD_INT 0
4690: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4691: LD_ADDR_OWVAR 28
4695: PUSH
4696: LD_INT 15
4698: ST_TO_ADDR
// hc_gallery :=  ;
4699: LD_ADDR_OWVAR 33
4703: PUSH
4704: LD_STRING 
4706: ST_TO_ADDR
// hc_name :=  ;
4707: LD_ADDR_OWVAR 26
4711: PUSH
4712: LD_STRING 
4714: ST_TO_ADDR
// un := CreateHuman ;
4715: LD_ADDR_VAR 0 4
4719: PUSH
4720: CALL_OW 44
4724: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4725: LD_VAR 0 4
4729: PPUSH
4730: LD_VAR 0 5
4734: PUSH
4735: LD_VAR 0 5
4739: PUSH
4740: LD_VAR 0 2
4744: MINUS
4745: ARRAY
4746: PPUSH
4747: CALL_OW 52
// end ;
4751: GO 4680
4753: POP
4754: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4755: LD_ADDR_VAR 0 5
4759: PUSH
4760: LD_STRING 12_kurt_squad
4762: PPUSH
4763: CALL_OW 31
4767: ST_TO_ADDR
// if tmp then
4768: LD_VAR 0 5
4772: IFFALSE 4806
// for i in tmp do
4774: LD_ADDR_VAR 0 2
4778: PUSH
4779: LD_VAR 0 5
4783: PUSH
4784: FOR_IN
4785: IFFALSE 4804
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4787: LD_VAR 0 2
4791: PPUSH
4792: LD_INT 5
4794: PPUSH
4795: LD_INT 0
4797: PPUSH
4798: CALL_OW 49
4802: GO 4784
4804: POP
4805: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4806: LD_INT 324
4808: PPUSH
4809: LD_INT 5
4811: PPUSH
4812: LD_STRING 
4814: PPUSH
4815: LD_INT 8
4817: PUSH
4818: LD_INT 9
4820: PUSH
4821: LD_INT 10
4823: PUSH
4824: LD_INT 10
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: PUSH
4833: LD_OWVAR 67
4837: ARRAY
4838: PPUSH
4839: LD_INT 3000
4841: PUSH
4842: LD_INT 500
4844: PUSH
4845: LD_INT 150
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: LIST
4852: PPUSH
4853: LD_INT 16
4855: PUSH
4856: LD_INT 6
4858: PUSH
4859: LD_INT 6
4861: PUSH
4862: LD_INT 8
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: PPUSH
4871: CALL 75995 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4875: LD_ADDR_EXP 100
4879: PUSH
4880: LD_EXP 100
4884: PPUSH
4885: LD_INT 3
4887: PPUSH
4888: LD_INT 22
4890: PUSH
4891: LD_VAR 0 3
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: PUSH
4900: LD_INT 23
4902: PUSH
4903: LD_INT 2
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 3
4912: PUSH
4913: LD_INT 21
4915: PUSH
4916: LD_INT 2
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PUSH
4927: EMPTY
4928: LIST
4929: LIST
4930: LIST
4931: PPUSH
4932: CALL_OW 69
4936: PUSH
4937: LD_EXP 62
4941: DIFF
4942: PPUSH
4943: CALL_OW 1
4947: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4948: LD_INT 1
4950: PPUSH
4951: LD_INT 7
4953: PPUSH
4954: CALL_OW 383
// hc_name := Ali Hadrach ;
4958: LD_ADDR_OWVAR 26
4962: PUSH
4963: LD_STRING Ali Hadrach
4965: ST_TO_ADDR
// hc_face_number := 31 ;
4966: LD_ADDR_OWVAR 34
4970: PUSH
4971: LD_INT 31
4973: ST_TO_ADDR
// Friend := CreateHuman ;
4974: LD_ADDR_EXP 64
4978: PUSH
4979: CALL_OW 44
4983: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4984: LD_INT 14
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 1
4992: PPUSH
4993: LD_INT 29
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 72551 0 5
// powellBomb := CreateVehicle ;
5003: LD_ADDR_EXP 65
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5013: LD_EXP 65
5017: PPUSH
5018: LD_INT 90
5020: PPUSH
5021: LD_INT 51
5023: PPUSH
5024: LD_INT 0
5026: PPUSH
5027: CALL_OW 48
// end ;
5031: LD_VAR 0 1
5035: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5036: LD_INT 0
5038: PPUSH
5039: PPUSH
5040: PPUSH
// if IsLive ( kozlov_fac ) then
5041: LD_INT 332
5043: PPUSH
5044: CALL_OW 300
5048: IFFALSE 5052
// exit ;
5050: GO 5619
// ComExitBuilding ( Kozlov ) ;
5052: LD_EXP 63
5056: PPUSH
5057: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5061: LD_EXP 63
5065: PPUSH
5066: CALL_OW 257
5070: PUSH
5071: LD_INT 2
5073: NONEQUAL
5074: IFFALSE 5109
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5076: LD_EXP 63
5080: PPUSH
5081: LD_INT 324
5083: PPUSH
5084: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5088: LD_EXP 63
5092: PPUSH
5093: LD_INT 2
5095: PPUSH
5096: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5100: LD_EXP 63
5104: PPUSH
5105: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5109: LD_EXP 63
5113: PPUSH
5114: LD_INT 2
5116: PPUSH
5117: LD_INT 93
5119: PPUSH
5120: LD_INT 32
5122: PPUSH
5123: LD_INT 3
5125: PPUSH
5126: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5130: LD_INT 35
5132: PPUSH
5133: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5137: LD_INT 22
5139: PUSH
5140: LD_INT 8
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PUSH
5147: LD_INT 30
5149: PUSH
5150: LD_INT 3
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: PUSH
5157: LD_INT 23
5159: PUSH
5160: LD_INT 3
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: PUSH
5167: LD_INT 57
5169: PUSH
5170: EMPTY
5171: LIST
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: LIST
5177: LIST
5178: PPUSH
5179: CALL_OW 69
5183: IFFALSE 5130
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5185: LD_ADDR_VAR 0 2
5189: PUSH
5190: LD_INT 22
5192: PUSH
5193: LD_INT 8
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: LD_INT 30
5202: PUSH
5203: LD_INT 3
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: PUSH
5210: LD_INT 23
5212: PUSH
5213: LD_INT 3
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PUSH
5220: LD_INT 57
5222: PUSH
5223: EMPTY
5224: LIST
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: PPUSH
5232: CALL_OW 69
5236: PUSH
5237: LD_INT 1
5239: ARRAY
5240: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5241: LD_INT 22
5243: PUSH
5244: LD_INT 8
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: PUSH
5251: LD_INT 23
5253: PUSH
5254: LD_INT 3
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 30
5263: PUSH
5264: LD_INT 21
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PUSH
5271: EMPTY
5272: LIST
5273: LIST
5274: LIST
5275: PPUSH
5276: CALL_OW 69
5280: NOT
5281: IFFALSE 5359
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5283: LD_EXP 63
5287: PPUSH
5288: LD_INT 21
5290: PPUSH
5291: LD_INT 97
5293: PPUSH
5294: LD_INT 36
5296: PPUSH
5297: LD_INT 5
5299: PPUSH
5300: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5304: LD_INT 35
5306: PPUSH
5307: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5311: LD_INT 22
5313: PUSH
5314: LD_INT 8
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PUSH
5321: LD_INT 23
5323: PUSH
5324: LD_INT 3
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 30
5333: PUSH
5334: LD_INT 21
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 57
5343: PUSH
5344: EMPTY
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: PPUSH
5353: CALL_OW 69
5357: IFFALSE 5304
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5359: LD_INT 22
5361: PUSH
5362: LD_INT 8
5364: PUSH
5365: EMPTY
5366: LIST
5367: LIST
5368: PUSH
5369: LD_INT 23
5371: PUSH
5372: LD_INT 3
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 30
5381: PUSH
5382: LD_INT 18
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: EMPTY
5390: LIST
5391: LIST
5392: LIST
5393: PPUSH
5394: CALL_OW 69
5398: NOT
5399: IFFALSE 5477
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5401: LD_EXP 63
5405: PPUSH
5406: LD_INT 18
5408: PPUSH
5409: LD_INT 89
5411: PPUSH
5412: LD_INT 32
5414: PPUSH
5415: LD_INT 1
5417: PPUSH
5418: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5422: LD_INT 35
5424: PPUSH
5425: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5429: LD_INT 22
5431: PUSH
5432: LD_INT 8
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: LD_INT 23
5441: PUSH
5442: LD_INT 3
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 30
5451: PUSH
5452: LD_INT 18
5454: PUSH
5455: EMPTY
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 57
5461: PUSH
5462: EMPTY
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: PPUSH
5471: CALL_OW 69
5475: IFFALSE 5422
// end ; lab := kozlov_lab ;
5477: LD_ADDR_VAR 0 3
5481: PUSH
5482: LD_INT 336
5484: ST_TO_ADDR
// if not lab then
5485: LD_VAR 0 3
5489: NOT
5490: IFFALSE 5494
// exit ;
5492: GO 5619
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5494: LD_EXP 63
5498: PPUSH
5499: LD_VAR 0 3
5503: PUSH
5504: LD_INT 1
5506: ARRAY
5507: PPUSH
5508: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5512: LD_EXP 63
5516: PPUSH
5517: LD_INT 4
5519: PPUSH
5520: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5524: LD_VAR 0 3
5528: PUSH
5529: LD_INT 1
5531: ARRAY
5532: PPUSH
5533: LD_INT 25
5535: PPUSH
5536: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5540: LD_INT 35
5542: PPUSH
5543: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5547: LD_INT 25
5549: PPUSH
5550: LD_INT 8
5552: PPUSH
5553: CALL_OW 321
5557: PUSH
5558: LD_INT 2
5560: EQUAL
5561: IFFALSE 5540
// ComExitBuilding ( Kozlov ) ;
5563: LD_EXP 63
5567: PPUSH
5568: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5572: LD_EXP 63
5576: PPUSH
5577: LD_VAR 0 2
5581: PPUSH
5582: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5586: LD_EXP 63
5590: PPUSH
5591: LD_INT 3
5593: PPUSH
5594: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5598: LD_VAR 0 2
5602: PPUSH
5603: LD_INT 23
5605: PPUSH
5606: LD_INT 3
5608: PPUSH
5609: LD_INT 1
5611: PPUSH
5612: LD_INT 48
5614: PPUSH
5615: CALL_OW 125
// end ;
5619: LD_VAR 0 1
5623: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5624: LD_EXP 22
5628: NOT
5629: PUSH
5630: LD_EXP 15
5634: PUSH
5635: LD_INT 6
5637: GREATEREQUAL
5638: AND
5639: IFFALSE 5720
5641: GO 5643
5643: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5644: LD_INT 3
5646: PPUSH
5647: LD_INT 3
5649: PPUSH
5650: CALL 61285 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5654: LD_INT 3
5656: PPUSH
5657: LD_INT 14
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 28
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 14
5677: PUSH
5678: LD_INT 1
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 28
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: PUSH
5693: LD_INT 14
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 28
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: LIST
5715: PPUSH
5716: CALL 61148 0 2
// end ;
5720: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5721: LD_EXP 22
5725: NOT
5726: PUSH
5727: LD_EXP 15
5731: PUSH
5732: LD_INT 6
5734: GREATEREQUAL
5735: AND
5736: PUSH
5737: LD_INT 3
5739: PPUSH
5740: LD_INT 1
5742: PPUSH
5743: CALL 62566 0 2
5747: NOT
5748: AND
5749: IFFALSE 6623
5751: GO 5753
5753: DISABLE
5754: LD_INT 0
5756: PPUSH
5757: PPUSH
5758: PPUSH
// begin enable ;
5759: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5760: LD_INT 22
5762: PUSH
5763: LD_INT 8
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: PUSH
5770: LD_INT 23
5772: PUSH
5773: LD_INT 2
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 30
5782: PUSH
5783: LD_INT 3
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: LIST
5794: PPUSH
5795: CALL_OW 69
5799: NOT
5800: IFFALSE 5804
// exit ;
5802: GO 6623
// if Prob ( 40 ) then
5804: LD_INT 40
5806: PPUSH
5807: CALL_OW 13
5811: IFFALSE 5938
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5813: LD_INT 3
5815: PPUSH
5816: LD_INT 14
5818: PUSH
5819: LD_INT 1
5821: PUSH
5822: LD_INT 2
5824: PUSH
5825: LD_INT 28
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: LIST
5833: PUSH
5834: LD_INT 14
5836: PUSH
5837: LD_INT 1
5839: PUSH
5840: LD_INT 2
5842: PUSH
5843: LD_INT 28
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_INT 14
5854: PUSH
5855: LD_INT 1
5857: PUSH
5858: LD_INT 2
5860: PUSH
5861: LD_INT 28
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 14
5872: PUSH
5873: LD_INT 1
5875: PUSH
5876: LD_INT 2
5878: PUSH
5879: LD_INT 28
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_INT 14
5890: PUSH
5891: LD_INT 1
5893: PUSH
5894: LD_INT 2
5896: PUSH
5897: LD_INT 28
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 14
5908: PUSH
5909: LD_INT 1
5911: PUSH
5912: LD_INT 2
5914: PUSH
5915: LD_INT 26
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL 61148 0 2
// end else
5936: GO 6145
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5938: LD_INT 3
5940: PPUSH
5941: LD_INT 14
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 2
5949: PUSH
5950: LD_INT 27
5952: PUSH
5953: LD_INT 26
5955: PUSH
5956: LD_INT 26
5958: PUSH
5959: LD_INT 28
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: PUSH
5968: LD_OWVAR 67
5972: ARRAY
5973: PUSH
5974: EMPTY
5975: LIST
5976: LIST
5977: LIST
5978: LIST
5979: PUSH
5980: LD_INT 14
5982: PUSH
5983: LD_INT 1
5985: PUSH
5986: LD_INT 2
5988: PUSH
5989: LD_INT 27
5991: PUSH
5992: LD_INT 26
5994: PUSH
5995: LD_INT 26
5997: PUSH
5998: LD_INT 26
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: PUSH
6007: LD_OWVAR 67
6011: ARRAY
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 14
6021: PUSH
6022: LD_INT 1
6024: PUSH
6025: LD_INT 2
6027: PUSH
6028: LD_INT 26
6030: PUSH
6031: LD_INT 26
6033: PUSH
6034: LD_INT 29
6036: PUSH
6037: LD_INT 29
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: PUSH
6046: LD_OWVAR 67
6050: ARRAY
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: LIST
6056: LIST
6057: PUSH
6058: LD_INT 13
6060: PUSH
6061: LD_INT 1
6063: PUSH
6064: LD_INT 2
6066: PUSH
6067: LD_INT 26
6069: PUSH
6070: LD_INT 29
6072: PUSH
6073: LD_INT 29
6075: PUSH
6076: LD_INT 29
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: LIST
6083: LIST
6084: PUSH
6085: LD_OWVAR 67
6089: ARRAY
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 13
6099: PUSH
6100: LD_INT 1
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: LD_INT 29
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 14
6117: PUSH
6118: LD_INT 1
6120: PUSH
6121: LD_INT 2
6123: PUSH
6124: LD_INT 26
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: LIST
6137: LIST
6138: LIST
6139: LIST
6140: PPUSH
6141: CALL 61148 0 2
// end ; repeat wait ( 0 0$1 ) ;
6145: LD_INT 35
6147: PPUSH
6148: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6152: LD_INT 3
6154: PPUSH
6155: LD_INT 1
6157: PPUSH
6158: CALL 62566 0 2
6162: PUSH
6163: LD_INT 6
6165: GREATEREQUAL
6166: IFFALSE 6145
// wait ( 0 0$30 ) ;
6168: LD_INT 1050
6170: PPUSH
6171: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6175: LD_ADDR_VAR 0 2
6179: PUSH
6180: LD_INT 3
6182: PPUSH
6183: LD_INT 1
6185: PPUSH
6186: CALL 62566 0 2
6190: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6191: LD_ADDR_EXP 119
6195: PUSH
6196: LD_EXP 119
6200: PPUSH
6201: LD_INT 3
6203: PPUSH
6204: LD_EXP 119
6208: PUSH
6209: LD_INT 3
6211: ARRAY
6212: PUSH
6213: LD_VAR 0 2
6217: DIFF
6218: PPUSH
6219: CALL_OW 1
6223: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6224: LD_ADDR_VAR 0 3
6228: PUSH
6229: LD_INT 0
6231: PPUSH
6232: LD_INT 2
6234: PPUSH
6235: CALL_OW 12
6239: ST_TO_ADDR
// if target then
6240: LD_VAR 0 3
6244: IFFALSE 6381
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PPUSH
6256: LD_INT 24
6258: PUSH
6259: LD_INT 250
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: PPUSH
6266: CALL_OW 72
6270: ST_TO_ADDR
// if not tmp then
6271: LD_VAR 0 2
6275: NOT
6276: IFFALSE 6280
// break ;
6278: GO 6379
// for i in tmp do
6280: LD_ADDR_VAR 0 1
6284: PUSH
6285: LD_VAR 0 2
6289: PUSH
6290: FOR_IN
6291: IFFALSE 6331
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6293: LD_VAR 0 1
6297: PPUSH
6298: LD_INT 89
6300: PPUSH
6301: LD_INT 71
6303: PPUSH
6304: CALL_OW 297
6308: PUSH
6309: LD_INT 9
6311: GREATER
6312: IFFALSE 6329
// ComMoveXY ( i , 89 , 71 ) ;
6314: LD_VAR 0 1
6318: PPUSH
6319: LD_INT 89
6321: PPUSH
6322: LD_INT 71
6324: PPUSH
6325: CALL_OW 111
6329: GO 6290
6331: POP
6332: POP
// wait ( 0 0$1 ) ;
6333: LD_INT 35
6335: PPUSH
6336: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6340: LD_VAR 0 2
6344: PPUSH
6345: LD_INT 92
6347: PUSH
6348: LD_INT 89
6350: PUSH
6351: LD_INT 71
6353: PUSH
6354: LD_INT 9
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PPUSH
6363: CALL_OW 72
6367: PUSH
6368: LD_VAR 0 2
6372: PUSH
6373: LD_INT 1
6375: MINUS
6376: GREATEREQUAL
6377: IFFALSE 6246
// end else
6379: GO 6514
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6381: LD_ADDR_VAR 0 2
6385: PUSH
6386: LD_VAR 0 2
6390: PPUSH
6391: LD_INT 24
6393: PUSH
6394: LD_INT 250
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: PPUSH
6401: CALL_OW 72
6405: ST_TO_ADDR
// if not tmp then
6406: LD_VAR 0 2
6410: NOT
6411: IFFALSE 6415
// break ;
6413: GO 6514
// for i in tmp do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: LD_VAR 0 2
6424: PUSH
6425: FOR_IN
6426: IFFALSE 6466
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6428: LD_VAR 0 1
6432: PPUSH
6433: LD_INT 125
6435: PPUSH
6436: LD_INT 129
6438: PPUSH
6439: CALL_OW 297
6443: PUSH
6444: LD_INT 9
6446: GREATER
6447: IFFALSE 6464
// ComMoveXY ( i , 125 , 129 ) ;
6449: LD_VAR 0 1
6453: PPUSH
6454: LD_INT 125
6456: PPUSH
6457: LD_INT 129
6459: PPUSH
6460: CALL_OW 111
6464: GO 6425
6466: POP
6467: POP
// wait ( 0 0$1 ) ;
6468: LD_INT 35
6470: PPUSH
6471: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6475: LD_VAR 0 2
6479: PPUSH
6480: LD_INT 92
6482: PUSH
6483: LD_INT 125
6485: PUSH
6486: LD_INT 129
6488: PUSH
6489: LD_INT 9
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PPUSH
6498: CALL_OW 72
6502: PUSH
6503: LD_VAR 0 2
6507: PUSH
6508: LD_INT 1
6510: MINUS
6511: GREATEREQUAL
6512: IFFALSE 6381
// end ; repeat wait ( 0 0$1 ) ;
6514: LD_INT 35
6516: PPUSH
6517: CALL_OW 67
// for i in tmp do
6521: LD_ADDR_VAR 0 1
6525: PUSH
6526: LD_VAR 0 2
6530: PUSH
6531: FOR_IN
6532: IFFALSE 6614
// begin if GetLives ( i ) > 251 then
6534: LD_VAR 0 1
6538: PPUSH
6539: CALL_OW 256
6543: PUSH
6544: LD_INT 251
6546: GREATER
6547: IFFALSE 6585
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6549: LD_VAR 0 1
6553: PPUSH
6554: LD_INT 81
6556: PUSH
6557: LD_INT 8
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PPUSH
6564: CALL_OW 69
6568: PPUSH
6569: LD_VAR 0 1
6573: PPUSH
6574: CALL_OW 74
6578: PPUSH
6579: CALL_OW 115
6583: GO 6612
// if IsDead ( i ) then
6585: LD_VAR 0 1
6589: PPUSH
6590: CALL_OW 301
6594: IFFALSE 6612
// tmp := tmp diff i ;
6596: LD_ADDR_VAR 0 2
6600: PUSH
6601: LD_VAR 0 2
6605: PUSH
6606: LD_VAR 0 1
6610: DIFF
6611: ST_TO_ADDR
// end ;
6612: GO 6531
6614: POP
6615: POP
// until not tmp ;
6616: LD_VAR 0 2
6620: NOT
6621: IFFALSE 6514
// end ;
6623: PPOPN 3
6625: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6626: LD_EXP 22
6630: NOT
6631: PUSH
6632: LD_EXP 15
6636: PUSH
6637: LD_INT 6
6639: GREATEREQUAL
6640: AND
6641: PUSH
6642: LD_OWVAR 67
6646: PUSH
6647: LD_INT 1
6649: GREATER
6650: AND
6651: IFFALSE 7184
6653: GO 6655
6655: DISABLE
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// begin enable ;
6661: ENABLE
// tmp := [ ] ;
6662: LD_ADDR_VAR 0 3
6666: PUSH
6667: EMPTY
6668: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6669: LD_ADDR_VAR 0 1
6673: PUSH
6674: DOUBLE
6675: LD_INT 1
6677: DEC
6678: ST_TO_ADDR
6679: LD_INT 4
6681: PUSH
6682: LD_INT 6
6684: PUSH
6685: LD_INT 7
6687: PUSH
6688: LD_INT 8
6690: PUSH
6691: EMPTY
6692: LIST
6693: LIST
6694: LIST
6695: LIST
6696: PUSH
6697: LD_OWVAR 67
6701: ARRAY
6702: PUSH
6703: FOR_TO
6704: IFFALSE 6864
// begin uc_side := 8 ;
6706: LD_ADDR_OWVAR 20
6710: PUSH
6711: LD_INT 8
6713: ST_TO_ADDR
// uc_nation := 2 ;
6714: LD_ADDR_OWVAR 21
6718: PUSH
6719: LD_INT 2
6721: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6722: LD_INT 13
6724: PUSH
6725: LD_INT 14
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: PUSH
6732: LD_INT 1
6734: PPUSH
6735: LD_INT 2
6737: PPUSH
6738: CALL_OW 12
6742: ARRAY
6743: PPUSH
6744: LD_INT 1
6746: PPUSH
6747: LD_INT 5
6749: PPUSH
6750: LD_INT 27
6752: PUSH
6753: LD_INT 28
6755: PUSH
6756: LD_INT 26
6758: PUSH
6759: LD_INT 25
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: LIST
6766: LIST
6767: PUSH
6768: LD_INT 1
6770: PPUSH
6771: LD_INT 4
6773: PPUSH
6774: CALL_OW 12
6778: ARRAY
6779: PPUSH
6780: LD_INT 88
6782: PPUSH
6783: CALL 72551 0 5
// un := CreateVehicle ;
6787: LD_ADDR_VAR 0 2
6791: PUSH
6792: CALL_OW 45
6796: ST_TO_ADDR
// tmp := tmp ^ un ;
6797: LD_ADDR_VAR 0 3
6801: PUSH
6802: LD_VAR 0 3
6806: PUSH
6807: LD_VAR 0 2
6811: ADD
6812: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6813: LD_VAR 0 2
6817: PPUSH
6818: LD_INT 3
6820: PPUSH
6821: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 30
6832: PPUSH
6833: LD_INT 0
6835: PPUSH
6836: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6840: LD_VAR 0 2
6844: PPUSH
6845: LD_INT 16
6847: PPUSH
6848: LD_INT 11
6850: PPUSH
6851: CALL_OW 111
// wait ( 0 0$2 ) ;
6855: LD_INT 70
6857: PPUSH
6858: CALL_OW 67
// end ;
6862: GO 6703
6864: POP
6865: POP
// for i = 1 to Difficulty do
6866: LD_ADDR_VAR 0 1
6870: PUSH
6871: DOUBLE
6872: LD_INT 1
6874: DEC
6875: ST_TO_ADDR
6876: LD_OWVAR 67
6880: PUSH
6881: FOR_TO
6882: IFFALSE 7011
// begin uc_side := 8 ;
6884: LD_ADDR_OWVAR 20
6888: PUSH
6889: LD_INT 8
6891: ST_TO_ADDR
// uc_nation := 2 ;
6892: LD_ADDR_OWVAR 21
6896: PUSH
6897: LD_INT 2
6899: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6900: LD_INT 0
6902: PPUSH
6903: LD_INT 8
6905: PPUSH
6906: LD_INT 8
6908: PUSH
6909: LD_INT 8
6911: PUSH
6912: LD_INT 9
6914: PUSH
6915: LD_INT 10
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: LIST
6922: LIST
6923: PUSH
6924: LD_OWVAR 67
6928: ARRAY
6929: PPUSH
6930: CALL_OW 380
// un := CreateHuman ;
6934: LD_ADDR_VAR 0 2
6938: PUSH
6939: CALL_OW 44
6943: ST_TO_ADDR
// tmp := tmp ^ un ;
6944: LD_ADDR_VAR 0 3
6948: PUSH
6949: LD_VAR 0 3
6953: PUSH
6954: LD_VAR 0 2
6958: ADD
6959: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6960: LD_VAR 0 2
6964: PPUSH
6965: LD_INT 3
6967: PPUSH
6968: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6972: LD_VAR 0 2
6976: PPUSH
6977: LD_INT 30
6979: PPUSH
6980: LD_INT 0
6982: PPUSH
6983: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6987: LD_VAR 0 2
6991: PPUSH
6992: LD_INT 16
6994: PPUSH
6995: LD_INT 11
6997: PPUSH
6998: CALL_OW 111
// wait ( 0 0$2 ) ;
7002: LD_INT 70
7004: PPUSH
7005: CALL_OW 67
// end ;
7009: GO 6881
7011: POP
7012: POP
// repeat wait ( 0 0$1 ) ;
7013: LD_INT 35
7015: PPUSH
7016: CALL_OW 67
// if legionDestroyed then
7020: LD_EXP 22
7024: IFFALSE 7028
// exit ;
7026: GO 7184
// for i in tmp do
7028: LD_ADDR_VAR 0 1
7032: PUSH
7033: LD_VAR 0 3
7037: PUSH
7038: FOR_IN
7039: IFFALSE 7175
// begin if GetLives ( i ) > 250 then
7041: LD_VAR 0 1
7045: PPUSH
7046: CALL_OW 256
7050: PUSH
7051: LD_INT 250
7053: GREATER
7054: IFFALSE 7146
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7056: LD_INT 81
7058: PUSH
7059: LD_INT 8
7061: PUSH
7062: EMPTY
7063: LIST
7064: LIST
7065: PUSH
7066: LD_INT 91
7068: PUSH
7069: LD_VAR 0 1
7073: PUSH
7074: LD_INT 10
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PPUSH
7086: CALL_OW 69
7090: NOT
7091: IFFALSE 7110
// ComAgressiveMove ( i , 67 , 110 ) else
7093: LD_VAR 0 1
7097: PPUSH
7098: LD_INT 67
7100: PPUSH
7101: LD_INT 110
7103: PPUSH
7104: CALL_OW 114
7108: GO 7144
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7110: LD_VAR 0 1
7114: PPUSH
7115: LD_INT 81
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL_OW 69
7129: PPUSH
7130: LD_VAR 0 1
7134: PPUSH
7135: CALL_OW 74
7139: PPUSH
7140: CALL_OW 115
// end else
7144: GO 7173
// if IsDead ( i ) then
7146: LD_VAR 0 1
7150: PPUSH
7151: CALL_OW 301
7155: IFFALSE 7173
// tmp := tmp diff i ;
7157: LD_ADDR_VAR 0 3
7161: PUSH
7162: LD_VAR 0 3
7166: PUSH
7167: LD_VAR 0 1
7171: DIFF
7172: ST_TO_ADDR
// end ;
7173: GO 7038
7175: POP
7176: POP
// until not tmp ;
7177: LD_VAR 0 3
7181: NOT
7182: IFFALSE 7013
// end ; end_of_file
7184: PPOPN 3
7186: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7187: LD_INT 0
7189: PPUSH
7190: PPUSH
7191: PPUSH
7192: PPUSH
7193: PPUSH
7194: PPUSH
7195: PPUSH
7196: PPUSH
7197: PPUSH
// side := 3 ;
7198: LD_ADDR_VAR 0 6
7202: PUSH
7203: LD_INT 3
7205: ST_TO_ADDR
// uc_side := side ;
7206: LD_ADDR_OWVAR 20
7210: PUSH
7211: LD_VAR 0 6
7215: ST_TO_ADDR
// uc_nation := 3 ;
7216: LD_ADDR_OWVAR 21
7220: PUSH
7221: LD_INT 3
7223: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7224: LD_ADDR_VAR 0 2
7228: PUSH
7229: LD_INT 22
7231: PUSH
7232: LD_VAR 0 6
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: LD_INT 21
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 69
7259: PUSH
7260: FOR_IN
7261: IFFALSE 7277
// SetBLevel ( i , 10 ) ;
7263: LD_VAR 0 2
7267: PPUSH
7268: LD_INT 10
7270: PPUSH
7271: CALL_OW 241
7275: GO 7260
7277: POP
7278: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7279: LD_ADDR_VAR 0 9
7283: PUSH
7284: LD_INT 22
7286: PUSH
7287: LD_VAR 0 6
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 30
7298: PUSH
7299: LD_INT 34
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PPUSH
7310: CALL_OW 69
7314: ST_TO_ADDR
// if teleport then
7315: LD_VAR 0 9
7319: IFFALSE 7340
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7321: LD_VAR 0 9
7325: PUSH
7326: LD_INT 1
7328: ARRAY
7329: PPUSH
7330: LD_INT 123
7332: PPUSH
7333: LD_INT 122
7335: PPUSH
7336: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7340: LD_ADDR_EXP 66
7344: PUSH
7345: LD_STRING Platonov
7347: PPUSH
7348: CALL_OW 25
7352: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7353: LD_ADDR_EXP 67
7357: PUSH
7358: LD_STRING Kovalyuk
7360: PPUSH
7361: CALL_OW 25
7365: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7366: LD_ADDR_EXP 69
7370: PUSH
7371: LD_STRING Yakotich
7373: PPUSH
7374: LD_EXP 1
7378: NOT
7379: PPUSH
7380: LD_STRING 09_
7382: PPUSH
7383: CALL 67536 0 3
7387: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7388: LD_ADDR_EXP 68
7392: PUSH
7393: LD_STRING Bystrov
7395: PPUSH
7396: CALL_OW 25
7400: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7401: LD_ADDR_EXP 70
7405: PUSH
7406: LD_STRING Gleb
7408: PPUSH
7409: CALL_OW 25
7413: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7414: LD_STRING 03_Cornel
7416: PPUSH
7417: CALL_OW 28
7421: IFFALSE 7469
// begin Bierezov := NewCharacter ( Mikhail ) ;
7423: LD_ADDR_EXP 71
7427: PUSH
7428: LD_STRING Mikhail
7430: PPUSH
7431: CALL_OW 25
7435: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7436: LD_EXP 71
7440: PPUSH
7441: LD_INT 197
7443: PPUSH
7444: LD_INT 111
7446: PPUSH
7447: LD_INT 9
7449: PPUSH
7450: LD_INT 0
7452: PPUSH
7453: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7457: LD_EXP 71
7461: PPUSH
7462: LD_INT 3
7464: PPUSH
7465: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7469: LD_EXP 66
7473: PPUSH
7474: LD_INT 126
7476: PPUSH
7477: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7481: LD_EXP 67
7485: PPUSH
7486: LD_INT 134
7488: PPUSH
7489: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7493: LD_EXP 69
7497: PPUSH
7498: LD_INT 197
7500: PPUSH
7501: LD_INT 111
7503: PPUSH
7504: LD_INT 9
7506: PPUSH
7507: LD_INT 0
7509: PPUSH
7510: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7514: LD_EXP 68
7518: PPUSH
7519: LD_INT 197
7521: PPUSH
7522: LD_INT 111
7524: PPUSH
7525: LD_INT 9
7527: PPUSH
7528: LD_INT 0
7530: PPUSH
7531: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7535: LD_EXP 70
7539: PPUSH
7540: LD_INT 197
7542: PPUSH
7543: LD_INT 111
7545: PPUSH
7546: LD_INT 9
7548: PPUSH
7549: LD_INT 0
7551: PPUSH
7552: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7556: LD_ADDR_VAR 0 5
7560: PUSH
7561: LD_INT 126
7563: PPUSH
7564: LD_INT 4
7566: PPUSH
7567: LD_STRING zhukov
7569: PPUSH
7570: LD_INT 9
7572: PUSH
7573: LD_INT 10
7575: PUSH
7576: LD_INT 10
7578: PUSH
7579: LD_INT 10
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: LIST
7587: PUSH
7588: LD_OWVAR 67
7592: ARRAY
7593: PPUSH
7594: LD_INT 90000
7596: PUSH
7597: LD_INT 1000
7599: PUSH
7600: LD_INT 300
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: LIST
7607: PPUSH
7608: LD_INT 18
7610: PUSH
7611: LD_INT 8
7613: PUSH
7614: LD_INT 13
7616: PUSH
7617: LD_INT 8
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL 75995 0 6
7630: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7631: LD_ADDR_VAR 0 4
7635: PUSH
7636: LD_INT 267
7638: PPUSH
7639: CALL_OW 274
7643: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7644: LD_VAR 0 4
7648: PPUSH
7649: LD_INT 1
7651: PPUSH
7652: LD_INT 5000
7654: PPUSH
7655: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7659: LD_VAR 0 4
7663: PPUSH
7664: LD_INT 2
7666: PPUSH
7667: LD_INT 200
7669: PPUSH
7670: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7674: LD_VAR 0 4
7678: PPUSH
7679: LD_INT 3
7681: PPUSH
7682: LD_INT 200
7684: PPUSH
7685: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7689: LD_ADDR_EXP 100
7693: PUSH
7694: LD_EXP 100
7698: PPUSH
7699: LD_INT 2
7701: PPUSH
7702: LD_VAR 0 5
7706: PUSH
7707: LD_INT 22
7709: PUSH
7710: LD_VAR 0 6
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: PUSH
7719: LD_INT 3
7721: PUSH
7722: LD_INT 21
7724: PUSH
7725: LD_INT 2
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PPUSH
7740: CALL_OW 69
7744: UNION
7745: PUSH
7746: LD_EXP 66
7750: DIFF
7751: PPUSH
7752: CALL_OW 1
7756: ST_TO_ADDR
// behemoths := [ ] ;
7757: LD_ADDR_EXP 74
7761: PUSH
7762: EMPTY
7763: ST_TO_ADDR
// behemothBuilders := [ ] ;
7764: LD_ADDR_EXP 75
7768: PUSH
7769: EMPTY
7770: ST_TO_ADDR
// if Kovalyuk then
7771: LD_EXP 67
7775: IFFALSE 7797
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7777: LD_ADDR_EXP 75
7781: PUSH
7782: LD_EXP 75
7786: PPUSH
7787: LD_EXP 67
7791: PPUSH
7792: CALL 105004 0 2
7796: ST_TO_ADDR
// j := 3 ;
7797: LD_ADDR_VAR 0 3
7801: PUSH
7802: LD_INT 3
7804: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7805: LD_ADDR_VAR 0 2
7809: PUSH
7810: LD_INT 22
7812: PUSH
7813: LD_INT 3
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: LD_INT 25
7822: PUSH
7823: LD_INT 3
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PPUSH
7834: CALL_OW 69
7838: PUSH
7839: LD_EXP 67
7843: DIFF
7844: PUSH
7845: FOR_IN
7846: IFFALSE 7896
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7848: LD_ADDR_EXP 75
7852: PUSH
7853: LD_EXP 75
7857: PPUSH
7858: LD_VAR 0 2
7862: PPUSH
7863: CALL 105004 0 2
7867: ST_TO_ADDR
// j := j - 1 ;
7868: LD_ADDR_VAR 0 3
7872: PUSH
7873: LD_VAR 0 3
7877: PUSH
7878: LD_INT 1
7880: MINUS
7881: ST_TO_ADDR
// if j = 0 then
7882: LD_VAR 0 3
7886: PUSH
7887: LD_INT 0
7889: EQUAL
7890: IFFALSE 7894
// break ;
7892: GO 7896
// end ;
7894: GO 7845
7896: POP
7897: POP
// end ;
7898: LD_VAR 0 1
7902: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
7907: PPUSH
7908: PPUSH
7909: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7910: LD_ADDR_VAR 0 4
7914: PUSH
7915: LD_INT 209
7917: PUSH
7918: LD_INT 149
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: PUSH
7925: LD_INT 219
7927: PUSH
7928: LD_INT 154
7930: PUSH
7931: EMPTY
7932: LIST
7933: LIST
7934: PUSH
7935: LD_INT 223
7937: PUSH
7938: LD_INT 149
7940: PUSH
7941: EMPTY
7942: LIST
7943: LIST
7944: PUSH
7945: LD_INT 232
7947: PUSH
7948: LD_INT 155
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: LIST
7959: LIST
7960: ST_TO_ADDR
// if not behemothBuilders then
7961: LD_EXP 75
7965: NOT
7966: IFFALSE 7970
// exit ;
7968: GO 8101
// j := 1 ;
7970: LD_ADDR_VAR 0 3
7974: PUSH
7975: LD_INT 1
7977: ST_TO_ADDR
// for i in behemothBuilders do
7978: LD_ADDR_VAR 0 2
7982: PUSH
7983: LD_EXP 75
7987: PUSH
7988: FOR_IN
7989: IFFALSE 8099
// begin if GetClass ( i ) <> class_mechanic then
7991: LD_VAR 0 2
7995: PPUSH
7996: CALL_OW 257
8000: PUSH
8001: LD_INT 3
8003: NONEQUAL
8004: IFFALSE 8018
// SetClass ( i , class_mechanic ) ;
8006: LD_VAR 0 2
8010: PPUSH
8011: LD_INT 3
8013: PPUSH
8014: CALL_OW 336
// if IsInUnit ( i ) then
8018: LD_VAR 0 2
8022: PPUSH
8023: CALL_OW 310
8027: IFFALSE 8038
// ComExitBuilding ( i ) ;
8029: LD_VAR 0 2
8033: PPUSH
8034: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8038: LD_VAR 0 2
8042: PPUSH
8043: LD_INT 37
8045: PPUSH
8046: LD_VAR 0 4
8050: PUSH
8051: LD_VAR 0 3
8055: ARRAY
8056: PUSH
8057: LD_INT 1
8059: ARRAY
8060: PPUSH
8061: LD_VAR 0 4
8065: PUSH
8066: LD_VAR 0 3
8070: ARRAY
8071: PUSH
8072: LD_INT 2
8074: ARRAY
8075: PPUSH
8076: LD_INT 0
8078: PPUSH
8079: CALL_OW 230
// j := j + 1 ;
8083: LD_ADDR_VAR 0 3
8087: PUSH
8088: LD_VAR 0 3
8092: PUSH
8093: LD_INT 1
8095: PLUS
8096: ST_TO_ADDR
// end ;
8097: GO 7988
8099: POP
8100: POP
// end ;
8101: LD_VAR 0 1
8105: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8106: LD_INT 24
8108: PPUSH
8109: LD_INT 30
8111: PUSH
8112: LD_INT 37
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PPUSH
8119: CALL_OW 70
8123: IFFALSE 8136
8125: GO 8127
8127: DISABLE
// behemothUnderConstruct := true ;
8128: LD_ADDR_EXP 26
8132: PUSH
8133: LD_INT 1
8135: ST_TO_ADDR
8136: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8137: LD_INT 3
8139: PPUSH
8140: CALL 105065 0 1
8144: PUSH
8145: LD_INT 22
8147: PUSH
8148: LD_INT 3
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: LD_INT 30
8157: PUSH
8158: LD_INT 37
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 69
8173: NOT
8174: AND
8175: IFFALSE 8361
8177: GO 8179
8179: DISABLE
8180: LD_INT 0
8182: PPUSH
8183: PPUSH
// begin enable ;
8184: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8185: LD_ADDR_VAR 0 2
8189: PUSH
8190: LD_INT 3
8192: PPUSH
8193: CALL 105065 0 1
8197: ST_TO_ADDR
// for i in tmp do
8198: LD_ADDR_VAR 0 1
8202: PUSH
8203: LD_VAR 0 2
8207: PUSH
8208: FOR_IN
8209: IFFALSE 8359
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8211: LD_VAR 0 1
8215: PPUSH
8216: LD_INT 9
8218: PPUSH
8219: CALL_OW 308
8223: PUSH
8224: LD_VAR 0 1
8228: PPUSH
8229: CALL_OW 110
8233: PUSH
8234: LD_INT 2
8236: EQUAL
8237: NOT
8238: AND
8239: IFFALSE 8253
// SetTag ( i , 2 ) ;
8241: LD_VAR 0 1
8245: PPUSH
8246: LD_INT 2
8248: PPUSH
8249: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8253: LD_INT 81
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: EMPTY
8260: LIST
8261: LIST
8262: PUSH
8263: LD_INT 91
8265: PUSH
8266: LD_VAR 0 1
8270: PUSH
8271: LD_INT 12
8273: PUSH
8274: EMPTY
8275: LIST
8276: LIST
8277: LIST
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: PPUSH
8283: CALL_OW 69
8287: NOT
8288: PUSH
8289: LD_VAR 0 1
8293: PPUSH
8294: CALL_OW 110
8298: PUSH
8299: LD_INT 2
8301: EQUAL
8302: NOT
8303: AND
8304: IFFALSE 8323
// ComAgressiveMove ( i , 64 , 93 ) else
8306: LD_VAR 0 1
8310: PPUSH
8311: LD_INT 64
8313: PPUSH
8314: LD_INT 93
8316: PPUSH
8317: CALL_OW 114
8321: GO 8357
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8323: LD_VAR 0 1
8327: PPUSH
8328: LD_INT 81
8330: PUSH
8331: LD_INT 3
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PPUSH
8338: CALL_OW 69
8342: PPUSH
8343: LD_VAR 0 1
8347: PPUSH
8348: CALL_OW 74
8352: PPUSH
8353: CALL_OW 115
// end ;
8357: GO 8208
8359: POP
8360: POP
// end ;
8361: PPOPN 2
8363: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8364: LD_INT 0
8366: PPUSH
8367: PPUSH
8368: PPUSH
// result := [ ] ;
8369: LD_ADDR_VAR 0 2
8373: PUSH
8374: EMPTY
8375: ST_TO_ADDR
// uc_side := 6 ;
8376: LD_ADDR_OWVAR 20
8380: PUSH
8381: LD_INT 6
8383: ST_TO_ADDR
// uc_nation := 3 ;
8384: LD_ADDR_OWVAR 21
8388: PUSH
8389: LD_INT 3
8391: ST_TO_ADDR
// case strength of 1 :
8392: LD_VAR 0 1
8396: PUSH
8397: LD_INT 1
8399: DOUBLE
8400: EQUAL
8401: IFTRUE 8405
8403: GO 8547
8405: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8406: LD_ADDR_VAR 0 3
8410: PUSH
8411: DOUBLE
8412: LD_INT 1
8414: DEC
8415: ST_TO_ADDR
8416: LD_INT 4
8418: PUSH
8419: LD_INT 5
8421: PUSH
8422: LD_INT 6
8424: PUSH
8425: LD_INT 7
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_OWVAR 67
8438: ARRAY
8439: PUSH
8440: FOR_TO
8441: IFFALSE 8543
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8443: LD_INT 22
8445: PUSH
8446: LD_INT 24
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: PUSH
8453: LD_VAR 0 3
8457: PUSH
8458: LD_INT 2
8460: MOD
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: ARRAY
8466: PPUSH
8467: LD_INT 1
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 1
8479: PPUSH
8480: LD_INT 2
8482: PPUSH
8483: CALL_OW 12
8487: ARRAY
8488: PPUSH
8489: LD_INT 3
8491: PPUSH
8492: LD_INT 43
8494: PUSH
8495: LD_INT 44
8497: PUSH
8498: LD_INT 45
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 1
8508: PPUSH
8509: LD_INT 3
8511: PPUSH
8512: CALL_OW 12
8516: ARRAY
8517: PPUSH
8518: LD_INT 80
8520: PPUSH
8521: CALL 72551 0 5
// result := result union CreateVehicle ;
8525: LD_ADDR_VAR 0 2
8529: PUSH
8530: LD_VAR 0 2
8534: PUSH
8535: CALL_OW 45
8539: UNION
8540: ST_TO_ADDR
// end ;
8541: GO 8440
8543: POP
8544: POP
// end ; 2 :
8545: GO 9542
8547: LD_INT 2
8549: DOUBLE
8550: EQUAL
8551: IFTRUE 8555
8553: GO 8723
8555: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8556: LD_ADDR_VAR 0 3
8560: PUSH
8561: DOUBLE
8562: LD_INT 1
8564: DEC
8565: ST_TO_ADDR
8566: LD_INT 5
8568: PUSH
8569: LD_INT 6
8571: PUSH
8572: LD_INT 7
8574: PUSH
8575: LD_INT 8
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: PUSH
8584: LD_OWVAR 67
8588: ARRAY
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8719
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8593: LD_INT 22
8595: PUSH
8596: LD_INT 24
8598: PUSH
8599: LD_INT 24
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: LIST
8606: PUSH
8607: LD_VAR 0 3
8611: PUSH
8612: LD_INT 3
8614: MOD
8615: PUSH
8616: LD_INT 1
8618: PLUS
8619: ARRAY
8620: PPUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PUSH
8631: LD_INT 1
8633: PPUSH
8634: LD_INT 2
8636: PPUSH
8637: CALL_OW 12
8641: ARRAY
8642: PPUSH
8643: LD_INT 3
8645: PPUSH
8646: LD_INT 43
8648: PUSH
8649: LD_INT 44
8651: PUSH
8652: LD_INT 45
8654: PUSH
8655: LD_INT 44
8657: PUSH
8658: LD_INT 46
8660: PUSH
8661: LD_INT 46
8663: PUSH
8664: LD_INT 49
8666: PUSH
8667: LD_INT 49
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: LIST
8675: LIST
8676: LIST
8677: LIST
8678: LIST
8679: PUSH
8680: LD_VAR 0 3
8684: PUSH
8685: LD_INT 8
8687: MOD
8688: PUSH
8689: LD_INT 1
8691: PLUS
8692: ARRAY
8693: PPUSH
8694: LD_INT 80
8696: PPUSH
8697: CALL 72551 0 5
// result := result union CreateVehicle ;
8701: LD_ADDR_VAR 0 2
8705: PUSH
8706: LD_VAR 0 2
8710: PUSH
8711: CALL_OW 45
8715: UNION
8716: ST_TO_ADDR
// end ;
8717: GO 8590
8719: POP
8720: POP
// end ; 3 :
8721: GO 9542
8723: LD_INT 3
8725: DOUBLE
8726: EQUAL
8727: IFTRUE 8731
8729: GO 8903
8731: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8732: LD_ADDR_VAR 0 3
8736: PUSH
8737: DOUBLE
8738: LD_INT 1
8740: DEC
8741: ST_TO_ADDR
8742: LD_INT 6
8744: PUSH
8745: LD_INT 7
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: LD_INT 9
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: LIST
8758: LIST
8759: PUSH
8760: LD_OWVAR 67
8764: ARRAY
8765: PUSH
8766: FOR_TO
8767: IFFALSE 8899
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8769: LD_INT 22
8771: PUSH
8772: LD_INT 24
8774: PUSH
8775: LD_INT 24
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: LIST
8782: PUSH
8783: LD_VAR 0 3
8787: PUSH
8788: LD_INT 3
8790: MOD
8791: PUSH
8792: LD_INT 1
8794: PLUS
8795: ARRAY
8796: PPUSH
8797: LD_INT 1
8799: PUSH
8800: LD_INT 3
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 1
8809: PPUSH
8810: LD_INT 2
8812: PPUSH
8813: CALL_OW 12
8817: ARRAY
8818: PPUSH
8819: LD_INT 3
8821: PPUSH
8822: LD_INT 43
8824: PUSH
8825: LD_INT 47
8827: PUSH
8828: LD_INT 45
8830: PUSH
8831: LD_INT 45
8833: PUSH
8834: LD_INT 46
8836: PUSH
8837: LD_INT 46
8839: PUSH
8840: LD_INT 49
8842: PUSH
8843: LD_INT 49
8845: PUSH
8846: LD_INT 49
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: LIST
8859: PUSH
8860: LD_VAR 0 3
8864: PUSH
8865: LD_INT 9
8867: MOD
8868: PUSH
8869: LD_INT 1
8871: PLUS
8872: ARRAY
8873: PPUSH
8874: LD_INT 80
8876: PPUSH
8877: CALL 72551 0 5
// result := result union CreateVehicle ;
8881: LD_ADDR_VAR 0 2
8885: PUSH
8886: LD_VAR 0 2
8890: PUSH
8891: CALL_OW 45
8895: UNION
8896: ST_TO_ADDR
// end ;
8897: GO 8766
8899: POP
8900: POP
// end ; 4 :
8901: GO 9542
8903: LD_INT 4
8905: DOUBLE
8906: EQUAL
8907: IFTRUE 8911
8909: GO 9541
8911: POP
// begin uc_nation := 3 ;
8912: LD_ADDR_OWVAR 21
8916: PUSH
8917: LD_INT 3
8919: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8920: LD_ADDR_VAR 0 3
8924: PUSH
8925: DOUBLE
8926: LD_INT 1
8928: DEC
8929: ST_TO_ADDR
8930: LD_INT 6
8932: PUSH
8933: LD_INT 8
8935: PUSH
8936: LD_INT 9
8938: PUSH
8939: LD_INT 10
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: LIST
8946: LIST
8947: PUSH
8948: LD_OWVAR 67
8952: ARRAY
8953: PUSH
8954: FOR_TO
8955: IFFALSE 9087
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8957: LD_INT 22
8959: PUSH
8960: LD_INT 24
8962: PUSH
8963: LD_INT 24
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_VAR 0 3
8975: PUSH
8976: LD_INT 3
8978: MOD
8979: PUSH
8980: LD_INT 1
8982: PLUS
8983: ARRAY
8984: PPUSH
8985: LD_INT 1
8987: PUSH
8988: LD_INT 3
8990: PUSH
8991: EMPTY
8992: LIST
8993: LIST
8994: PUSH
8995: LD_INT 1
8997: PPUSH
8998: LD_INT 2
9000: PPUSH
9001: CALL_OW 12
9005: ARRAY
9006: PPUSH
9007: LD_INT 3
9009: PPUSH
9010: LD_INT 45
9012: PUSH
9013: LD_INT 47
9015: PUSH
9016: LD_INT 47
9018: PUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 46
9024: PUSH
9025: LD_INT 46
9027: PUSH
9028: LD_INT 49
9030: PUSH
9031: LD_INT 49
9033: PUSH
9034: LD_INT 49
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: LIST
9043: LIST
9044: LIST
9045: LIST
9046: LIST
9047: PUSH
9048: LD_VAR 0 3
9052: PUSH
9053: LD_INT 9
9055: MOD
9056: PUSH
9057: LD_INT 1
9059: PLUS
9060: ARRAY
9061: PPUSH
9062: LD_INT 80
9064: PPUSH
9065: CALL 72551 0 5
// result := result union CreateVehicle ;
9069: LD_ADDR_VAR 0 2
9073: PUSH
9074: LD_VAR 0 2
9078: PUSH
9079: CALL_OW 45
9083: UNION
9084: ST_TO_ADDR
// end ;
9085: GO 8954
9087: POP
9088: POP
// if not KappaStatus then
9089: LD_EXP 2
9093: NOT
9094: IFFALSE 9329
// begin uc_nation := 1 ;
9096: LD_ADDR_OWVAR 21
9100: PUSH
9101: LD_INT 1
9103: ST_TO_ADDR
// for i = 1 to 3 do
9104: LD_ADDR_VAR 0 3
9108: PUSH
9109: DOUBLE
9110: LD_INT 1
9112: DEC
9113: ST_TO_ADDR
9114: LD_INT 3
9116: PUSH
9117: FOR_TO
9118: IFFALSE 9254
// begin j := rand ( 0 , 1 ) ;
9120: LD_ADDR_VAR 0 4
9124: PUSH
9125: LD_INT 0
9127: PPUSH
9128: LD_INT 1
9130: PPUSH
9131: CALL_OW 12
9135: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9136: LD_INT 3
9138: PUSH
9139: LD_INT 5
9141: PUSH
9142: LD_INT 5
9144: PUSH
9145: LD_INT 4
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: PUSH
9154: LD_VAR 0 4
9158: PUSH
9159: LD_INT 1
9161: PPUSH
9162: LD_INT 3
9164: PPUSH
9165: CALL_OW 12
9169: PLUS
9170: ARRAY
9171: PPUSH
9172: LD_INT 1
9174: PUSH
9175: LD_INT 3
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: CALL_OW 12
9192: ARRAY
9193: PPUSH
9194: LD_INT 3
9196: PPUSH
9197: LD_INT 9
9199: PUSH
9200: LD_INT 7
9202: PUSH
9203: LD_INT 6
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: LIST
9210: PUSH
9211: LD_VAR 0 4
9215: PUSH
9216: LD_INT 1
9218: PPUSH
9219: LD_INT 2
9221: PPUSH
9222: CALL_OW 12
9226: PLUS
9227: ARRAY
9228: PPUSH
9229: LD_INT 85
9231: PPUSH
9232: CALL 72551 0 5
// result := result union CreateVehicle ;
9236: LD_ADDR_VAR 0 2
9240: PUSH
9241: LD_VAR 0 2
9245: PUSH
9246: CALL_OW 45
9250: UNION
9251: ST_TO_ADDR
// end ;
9252: GO 9117
9254: POP
9255: POP
// if vsevolodFirstAttack then
9256: LD_EXP 24
9260: IFFALSE 9327
// begin vsevolodFirstAttack := false ;
9262: LD_ADDR_EXP 24
9266: PUSH
9267: LD_INT 0
9269: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9270: LD_INT 5
9272: PPUSH
9273: LD_INT 3
9275: PPUSH
9276: LD_INT 1
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 100
9284: PPUSH
9285: CALL 72551 0 5
// sewiVeh := CreateVehicle ;
9289: LD_ADDR_EXP 73
9293: PUSH
9294: CALL_OW 45
9298: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9299: LD_EXP 73
9303: PPUSH
9304: LD_INT 1
9306: PPUSH
9307: CALL_OW 242
// result := result union sewiVeh ;
9311: LD_ADDR_VAR 0 2
9315: PUSH
9316: LD_VAR 0 2
9320: PUSH
9321: LD_EXP 73
9325: UNION
9326: ST_TO_ADDR
// end ; end else
9327: GO 9539
// if vsevolodFirstAttack then
9329: LD_EXP 24
9333: IFFALSE 9539
// begin vsevolodFirstAttack := false ;
9335: LD_ADDR_EXP 24
9339: PUSH
9340: LD_INT 0
9342: ST_TO_ADDR
// uc_nation := 3 ;
9343: LD_ADDR_OWVAR 21
9347: PUSH
9348: LD_INT 3
9350: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9351: LD_ADDR_VAR 0 3
9355: PUSH
9356: DOUBLE
9357: LD_INT 1
9359: DEC
9360: ST_TO_ADDR
9361: LD_INT 2
9363: PUSH
9364: LD_OWVAR 67
9368: PLUS
9369: PUSH
9370: FOR_TO
9371: IFFALSE 9479
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9373: LD_INT 22
9375: PUSH
9376: LD_INT 24
9378: PUSH
9379: LD_INT 24
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: LIST
9386: PUSH
9387: LD_VAR 0 3
9391: PUSH
9392: LD_INT 3
9394: MOD
9395: PUSH
9396: LD_INT 1
9398: PLUS
9399: ARRAY
9400: PPUSH
9401: LD_INT 1
9403: PUSH
9404: LD_INT 3
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 1
9413: PPUSH
9414: LD_INT 2
9416: PPUSH
9417: CALL_OW 12
9421: ARRAY
9422: PPUSH
9423: LD_INT 1
9425: PPUSH
9426: LD_INT 45
9428: PUSH
9429: LD_INT 47
9431: PUSH
9432: LD_INT 47
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: LIST
9439: PUSH
9440: LD_VAR 0 3
9444: PUSH
9445: LD_INT 3
9447: MOD
9448: PUSH
9449: LD_INT 1
9451: PLUS
9452: ARRAY
9453: PPUSH
9454: LD_INT 80
9456: PPUSH
9457: CALL 72551 0 5
// result := result union CreateVehicle ;
9461: LD_ADDR_VAR 0 2
9465: PUSH
9466: LD_VAR 0 2
9470: PUSH
9471: CALL_OW 45
9475: UNION
9476: ST_TO_ADDR
// end ;
9477: GO 9370
9479: POP
9480: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9481: LD_INT 24
9483: PPUSH
9484: LD_INT 3
9486: PPUSH
9487: LD_INT 1
9489: PPUSH
9490: LD_INT 47
9492: PPUSH
9493: LD_INT 100
9495: PPUSH
9496: CALL 72551 0 5
// sewiVeh := CreateVehicle ;
9500: LD_ADDR_EXP 73
9504: PUSH
9505: CALL_OW 45
9509: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9510: LD_EXP 73
9514: PPUSH
9515: LD_INT 6
9517: NEG
9518: PPUSH
9519: CALL_OW 242
// result := result union sewiVeh ;
9523: LD_ADDR_VAR 0 2
9527: PUSH
9528: LD_VAR 0 2
9532: PUSH
9533: LD_EXP 73
9537: UNION
9538: ST_TO_ADDR
// end ; end ; end ;
9539: GO 9542
9541: POP
// end ;
9542: LD_VAR 0 2
9546: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9547: LD_EXP 16
9551: IFFALSE 10222
9553: GO 9555
9555: DISABLE
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
9562: PPUSH
9563: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9564: LD_ADDR_VAR 0 4
9568: PUSH
9569: LD_INT 11
9571: PUSH
9572: LD_INT 12
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9579: LD_ADDR_VAR 0 3
9583: PUSH
9584: LD_INT 11550
9586: PUSH
9587: LD_INT 10150
9589: PUSH
9590: LD_INT 9800
9592: PUSH
9593: LD_INT 9450
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: LIST
9600: LIST
9601: PUSH
9602: LD_OWVAR 67
9606: ARRAY
9607: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9608: LD_ADDR_VAR 0 6
9612: PUSH
9613: LD_INT 70
9615: PUSH
9616: LD_INT 118
9618: PUSH
9619: EMPTY
9620: LIST
9621: LIST
9622: PUSH
9623: LD_INT 78
9625: PUSH
9626: LD_INT 31
9628: PUSH
9629: EMPTY
9630: LIST
9631: LIST
9632: PUSH
9633: EMPTY
9634: LIST
9635: LIST
9636: ST_TO_ADDR
// repeat if missionStage = 2 then
9637: LD_EXP 15
9641: PUSH
9642: LD_INT 2
9644: EQUAL
9645: IFFALSE 9656
// wait ( 1 1$30 ) else
9647: LD_INT 3150
9649: PPUSH
9650: CALL_OW 67
9654: GO 9665
// wait ( time ) ;
9656: LD_VAR 0 3
9660: PPUSH
9661: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9665: LD_EXP 15
9669: PUSH
9670: LD_INT 6
9672: EQUAL
9673: PUSH
9674: LD_OWVAR 67
9678: PUSH
9679: LD_INT 2
9681: GREATER
9682: OR
9683: IFFALSE 9711
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9685: LD_INT 51
9687: PPUSH
9688: LD_INT 6
9690: PPUSH
9691: LD_INT 2
9693: PPUSH
9694: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9698: LD_INT 57
9700: PPUSH
9701: LD_INT 6
9703: PPUSH
9704: LD_INT 2
9706: PPUSH
9707: CALL_OW 322
// end ; if missionStage = 8 then
9711: LD_EXP 15
9715: PUSH
9716: LD_INT 8
9718: EQUAL
9719: IFFALSE 9747
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9721: LD_INT 52
9723: PPUSH
9724: LD_INT 6
9726: PPUSH
9727: LD_INT 2
9729: PPUSH
9730: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9734: LD_INT 58
9736: PPUSH
9737: LD_INT 6
9739: PPUSH
9740: LD_INT 2
9742: PPUSH
9743: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9747: LD_EXP 15
9751: PUSH
9752: LD_INT 10
9754: EQUAL
9755: PUSH
9756: LD_OWVAR 67
9760: PUSH
9761: LD_INT 1
9763: GREATER
9764: AND
9765: IFFALSE 9793
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9767: LD_INT 53
9769: PPUSH
9770: LD_INT 6
9772: PPUSH
9773: LD_INT 2
9775: PPUSH
9776: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9780: LD_INT 59
9782: PPUSH
9783: LD_INT 6
9785: PPUSH
9786: LD_INT 2
9788: PPUSH
9789: CALL_OW 322
// end ; if activeAttacks then
9793: LD_EXP 16
9797: IFFALSE 10216
// begin if missionStage = 2 then
9799: LD_EXP 15
9803: PUSH
9804: LD_INT 2
9806: EQUAL
9807: IFFALSE 9817
// strength := 1 ;
9809: LD_ADDR_VAR 0 5
9813: PUSH
9814: LD_INT 1
9816: ST_TO_ADDR
// if missionStage > 2 then
9817: LD_EXP 15
9821: PUSH
9822: LD_INT 2
9824: GREATER
9825: IFFALSE 9835
// strength := 2 ;
9827: LD_ADDR_VAR 0 5
9831: PUSH
9832: LD_INT 2
9834: ST_TO_ADDR
// if missionStage > 6 then
9835: LD_EXP 15
9839: PUSH
9840: LD_INT 6
9842: GREATER
9843: IFFALSE 9853
// strength := 3 ;
9845: LD_ADDR_VAR 0 5
9849: PUSH
9850: LD_INT 3
9852: ST_TO_ADDR
// if missionStage > 10 then
9853: LD_EXP 15
9857: PUSH
9858: LD_INT 10
9860: GREATER
9861: IFFALSE 9871
// strength := 4 ;
9863: LD_ADDR_VAR 0 5
9867: PUSH
9868: LD_INT 4
9870: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9871: LD_ADDR_VAR 0 2
9875: PUSH
9876: LD_VAR 0 5
9880: PPUSH
9881: CALL 8364 0 1
9885: ST_TO_ADDR
// for i in tmp do
9886: LD_ADDR_VAR 0 1
9890: PUSH
9891: LD_VAR 0 2
9895: PUSH
9896: FOR_IN
9897: IFFALSE 10106
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9899: LD_VAR 0 1
9903: PPUSH
9904: LD_VAR 0 4
9908: PUSH
9909: LD_INT 1
9911: PPUSH
9912: LD_INT 2
9914: PPUSH
9915: CALL_OW 12
9919: ARRAY
9920: PPUSH
9921: LD_INT 0
9923: PPUSH
9924: CALL_OW 49
// if i = sewiVeh then
9928: LD_VAR 0 1
9932: PUSH
9933: LD_EXP 73
9937: EQUAL
9938: IFFALSE 9975
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9940: LD_ADDR_EXP 72
9944: PUSH
9945: LD_STRING Vsevolod
9947: PPUSH
9948: LD_INT 0
9950: PPUSH
9951: LD_STRING 
9953: PPUSH
9954: CALL 67536 0 3
9958: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9959: LD_EXP 72
9963: PPUSH
9964: LD_VAR 0 1
9968: PPUSH
9969: CALL_OW 52
// end else
9973: GO 10056
// if GetControl ( i ) = control_manual then
9975: LD_VAR 0 1
9979: PPUSH
9980: CALL_OW 263
9984: PUSH
9985: LD_INT 1
9987: EQUAL
9988: IFFALSE 10056
// begin uc_side := 6 ;
9990: LD_ADDR_OWVAR 20
9994: PUSH
9995: LD_INT 6
9997: ST_TO_ADDR
// uc_nation := 3 ;
9998: LD_ADDR_OWVAR 21
10002: PUSH
10003: LD_INT 3
10005: ST_TO_ADDR
// hc_gallery :=  ;
10006: LD_ADDR_OWVAR 33
10010: PUSH
10011: LD_STRING 
10013: ST_TO_ADDR
// hc_name :=  ;
10014: LD_ADDR_OWVAR 26
10018: PUSH
10019: LD_STRING 
10021: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10022: LD_INT 0
10024: PPUSH
10025: LD_INT 3
10027: PPUSH
10028: LD_INT 10
10030: PPUSH
10031: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10035: CALL_OW 44
10039: PPUSH
10040: LD_VAR 0 1
10044: PPUSH
10045: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10049: LD_INT 10
10051: PPUSH
10052: CALL_OW 67
// end ; if Prob ( 50 ) then
10056: LD_INT 50
10058: PPUSH
10059: CALL_OW 13
10063: IFFALSE 10082
// ComMoveXY ( i , 111 , 197 ) else
10065: LD_VAR 0 1
10069: PPUSH
10070: LD_INT 111
10072: PPUSH
10073: LD_INT 197
10075: PPUSH
10076: CALL_OW 111
10080: GO 10097
// ComMoveXY ( i , 91 , 165 ) ;
10082: LD_VAR 0 1
10086: PPUSH
10087: LD_INT 91
10089: PPUSH
10090: LD_INT 165
10092: PPUSH
10093: CALL_OW 111
// wait ( 0 0$2 ) ;
10097: LD_INT 70
10099: PPUSH
10100: CALL_OW 67
// end ;
10104: GO 9896
10106: POP
10107: POP
// repeat wait ( 0 0$1 ) ;
10108: LD_INT 35
10110: PPUSH
10111: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10115: LD_ADDR_VAR 0 1
10119: PUSH
10120: LD_VAR 0 2
10124: PPUSH
10125: LD_INT 50
10127: PUSH
10128: EMPTY
10129: LIST
10130: PPUSH
10131: CALL_OW 72
10135: PUSH
10136: FOR_IN
10137: IFFALSE 10196
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10139: LD_VAR 0 1
10143: PPUSH
10144: LD_INT 108
10146: PUSH
10147: LD_INT 153
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 105
10156: PUSH
10157: LD_INT 149
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: PUSH
10164: LD_INT 85
10166: PUSH
10167: LD_INT 131
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 64
10176: PUSH
10177: LD_INT 105
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: PPUSH
10190: CALL 107608 0 2
10194: GO 10136
10196: POP
10197: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10198: LD_VAR 0 2
10202: PPUSH
10203: LD_INT 50
10205: PUSH
10206: EMPTY
10207: LIST
10208: PPUSH
10209: CALL_OW 72
10213: NOT
10214: IFFALSE 10108
// end ; until russianDestroyed ;
10216: LD_EXP 21
10220: IFFALSE 9637
// end ;
10222: PPOPN 6
10224: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10225: LD_EXP 21
10229: NOT
10230: PUSH
10231: LD_EXP 15
10235: PUSH
10236: LD_INT 6
10238: GREATEREQUAL
10239: AND
10240: PUSH
10241: LD_INT 2
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL 62566 0 2
10251: NOT
10252: AND
10253: IFFALSE 11192
10255: GO 10257
10257: DISABLE
10258: LD_INT 0
10260: PPUSH
10261: PPUSH
10262: PPUSH
10263: PPUSH
// begin enable ;
10264: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: PUSH
10275: LD_INT 30
10277: PUSH
10278: LD_INT 3
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: PPUSH
10289: CALL_OW 69
10293: NOT
10294: IFFALSE 10298
// exit ;
10296: GO 11192
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10298: LD_ADDR_VAR 0 4
10302: PUSH
10303: LD_INT 22
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: PUSH
10313: LD_INT 30
10315: PUSH
10316: LD_INT 34
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PPUSH
10327: CALL_OW 69
10331: ST_TO_ADDR
// if Prob ( 40 ) then
10332: LD_INT 40
10334: PPUSH
10335: CALL_OW 13
10339: IFFALSE 10485
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10341: LD_INT 2
10343: PPUSH
10344: LD_INT 22
10346: PUSH
10347: LD_INT 3
10349: PUSH
10350: LD_INT 3
10352: PUSH
10353: LD_INT 49
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: PUSH
10362: LD_INT 22
10364: PUSH
10365: LD_INT 3
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: LD_INT 49
10373: PUSH
10374: EMPTY
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 22
10382: PUSH
10383: LD_INT 3
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: LD_INT 49
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: LIST
10396: LIST
10397: PUSH
10398: LD_INT 24
10400: PUSH
10401: LD_INT 3
10403: PUSH
10404: LD_INT 3
10406: PUSH
10407: LD_INT 46
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: PUSH
10416: LD_INT 24
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 46
10427: PUSH
10428: EMPTY
10429: LIST
10430: LIST
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 24
10436: PUSH
10437: LD_INT 3
10439: PUSH
10440: LD_INT 3
10442: PUSH
10443: LD_INT 46
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: LIST
10450: LIST
10451: PUSH
10452: LD_INT 24
10454: PUSH
10455: LD_INT 3
10457: PUSH
10458: LD_INT 3
10460: PUSH
10461: LD_INT 46
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: PPUSH
10479: CALL 61148 0 2
// end else
10483: GO 10627
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10485: LD_INT 2
10487: PPUSH
10488: LD_INT 24
10490: PUSH
10491: LD_INT 3
10493: PUSH
10494: LD_INT 3
10496: PUSH
10497: LD_INT 47
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: PUSH
10506: LD_INT 24
10508: PUSH
10509: LD_INT 3
10511: PUSH
10512: LD_INT 3
10514: PUSH
10515: LD_INT 47
10517: PUSH
10518: EMPTY
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 24
10526: PUSH
10527: LD_INT 3
10529: PUSH
10530: LD_INT 3
10532: PUSH
10533: LD_INT 47
10535: PUSH
10536: EMPTY
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: PUSH
10542: LD_INT 24
10544: PUSH
10545: LD_INT 3
10547: PUSH
10548: LD_INT 3
10550: PUSH
10551: LD_INT 46
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: PUSH
10560: LD_INT 24
10562: PUSH
10563: LD_INT 3
10565: PUSH
10566: LD_INT 3
10568: PUSH
10569: LD_INT 46
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: PUSH
10578: LD_INT 24
10580: PUSH
10581: LD_INT 3
10583: PUSH
10584: LD_INT 3
10586: PUSH
10587: LD_INT 46
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: PUSH
10596: LD_INT 24
10598: PUSH
10599: LD_INT 3
10601: PUSH
10602: LD_INT 3
10604: PUSH
10605: LD_INT 46
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: PPUSH
10623: CALL 61148 0 2
// end ; repeat wait ( 0 0$1 ) ;
10627: LD_INT 35
10629: PPUSH
10630: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10634: LD_INT 2
10636: PPUSH
10637: LD_INT 1
10639: PPUSH
10640: CALL 62566 0 2
10644: PUSH
10645: LD_INT 7
10647: GREATEREQUAL
10648: IFFALSE 10627
// wait ( 0 0$10 ) ;
10650: LD_INT 350
10652: PPUSH
10653: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10657: LD_ADDR_VAR 0 2
10661: PUSH
10662: LD_INT 2
10664: PPUSH
10665: LD_INT 1
10667: PPUSH
10668: CALL 62566 0 2
10672: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10673: LD_ADDR_EXP 119
10677: PUSH
10678: LD_EXP 119
10682: PPUSH
10683: LD_INT 2
10685: PPUSH
10686: LD_EXP 119
10690: PUSH
10691: LD_INT 2
10693: ARRAY
10694: PUSH
10695: LD_VAR 0 2
10699: DIFF
10700: PPUSH
10701: CALL_OW 1
10705: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10706: LD_ADDR_VAR 0 3
10710: PUSH
10711: LD_INT 0
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: CALL_OW 12
10721: ST_TO_ADDR
// if target then
10722: LD_VAR 0 3
10726: IFFALSE 10854
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10728: LD_ADDR_VAR 0 2
10732: PUSH
10733: LD_VAR 0 2
10737: PPUSH
10738: LD_INT 24
10740: PUSH
10741: LD_INT 250
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: PPUSH
10748: CALL_OW 72
10752: ST_TO_ADDR
// for i in tmp do
10753: LD_ADDR_VAR 0 1
10757: PUSH
10758: LD_VAR 0 2
10762: PUSH
10763: FOR_IN
10764: IFFALSE 10804
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10766: LD_VAR 0 1
10770: PPUSH
10771: LD_INT 139
10773: PPUSH
10774: LD_INT 89
10776: PPUSH
10777: CALL_OW 297
10781: PUSH
10782: LD_INT 9
10784: GREATER
10785: IFFALSE 10802
// ComMoveXY ( i , 139 , 89 ) ;
10787: LD_VAR 0 1
10791: PPUSH
10792: LD_INT 139
10794: PPUSH
10795: LD_INT 89
10797: PPUSH
10798: CALL_OW 111
10802: GO 10763
10804: POP
10805: POP
// wait ( 0 0$1 ) ;
10806: LD_INT 35
10808: PPUSH
10809: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10813: LD_VAR 0 2
10817: PPUSH
10818: LD_INT 92
10820: PUSH
10821: LD_INT 139
10823: PUSH
10824: LD_INT 89
10826: PUSH
10827: LD_INT 9
10829: PUSH
10830: EMPTY
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: PPUSH
10836: CALL_OW 72
10840: PUSH
10841: LD_VAR 0 2
10845: PUSH
10846: LD_INT 1
10848: MINUS
10849: GREATEREQUAL
10850: IFFALSE 10728
// end else
10852: GO 10996
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10854: LD_VAR 0 2
10858: PPUSH
10859: LD_VAR 0 4
10863: PUSH
10864: LD_INT 1
10866: ARRAY
10867: PPUSH
10868: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10872: LD_ADDR_VAR 0 2
10876: PUSH
10877: LD_VAR 0 2
10881: PPUSH
10882: LD_INT 24
10884: PUSH
10885: LD_INT 250
10887: PUSH
10888: EMPTY
10889: LIST
10890: LIST
10891: PPUSH
10892: CALL_OW 72
10896: ST_TO_ADDR
// for i in tmp do
10897: LD_ADDR_VAR 0 1
10901: PUSH
10902: LD_VAR 0 2
10906: PUSH
10907: FOR_IN
10908: IFFALSE 10948
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10910: LD_VAR 0 1
10914: PPUSH
10915: LD_INT 124
10917: PPUSH
10918: LD_INT 139
10920: PPUSH
10921: CALL_OW 297
10925: PUSH
10926: LD_INT 9
10928: GREATER
10929: IFFALSE 10946
// ComMoveXY ( i , 124 , 139 ) ;
10931: LD_VAR 0 1
10935: PPUSH
10936: LD_INT 124
10938: PPUSH
10939: LD_INT 139
10941: PPUSH
10942: CALL_OW 111
10946: GO 10907
10948: POP
10949: POP
// wait ( 0 0$1 ) ;
10950: LD_INT 35
10952: PPUSH
10953: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10957: LD_VAR 0 2
10961: PPUSH
10962: LD_INT 92
10964: PUSH
10965: LD_INT 124
10967: PUSH
10968: LD_INT 139
10970: PUSH
10971: LD_INT 9
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: LIST
10978: LIST
10979: PPUSH
10980: CALL_OW 72
10984: PUSH
10985: LD_VAR 0 2
10989: PUSH
10990: LD_INT 1
10992: MINUS
10993: GREATEREQUAL
10994: IFFALSE 10872
// end ; repeat wait ( 0 0$1 ) ;
10996: LD_INT 35
10998: PPUSH
10999: CALL_OW 67
// for i in tmp do
11003: LD_ADDR_VAR 0 1
11007: PUSH
11008: LD_VAR 0 2
11012: PUSH
11013: FOR_IN
11014: IFFALSE 11183
// begin if GetLives ( i ) > 251 then
11016: LD_VAR 0 1
11020: PPUSH
11021: CALL_OW 256
11025: PUSH
11026: LD_INT 251
11028: GREATER
11029: IFFALSE 11154
// begin if GetWeapon ( i ) = ru_time_lapser then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 264
11040: PUSH
11041: LD_INT 49
11043: EQUAL
11044: IFFALSE 11100
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11046: LD_VAR 0 1
11050: PPUSH
11051: LD_INT 2
11053: PUSH
11054: LD_INT 22
11056: PUSH
11057: LD_INT 1
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 8
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: LIST
11078: PPUSH
11079: CALL_OW 69
11083: PPUSH
11084: LD_VAR 0 1
11088: PPUSH
11089: CALL_OW 74
11093: PPUSH
11094: CALL_OW 112
11098: GO 11152
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11100: LD_VAR 0 1
11104: PPUSH
11105: LD_INT 2
11107: PUSH
11108: LD_INT 22
11110: PUSH
11111: LD_INT 1
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: LD_INT 22
11120: PUSH
11121: LD_INT 8
11123: PUSH
11124: EMPTY
11125: LIST
11126: LIST
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: LIST
11132: PPUSH
11133: CALL_OW 69
11137: PPUSH
11138: LD_VAR 0 1
11142: PPUSH
11143: CALL_OW 74
11147: PPUSH
11148: CALL_OW 115
// end else
11152: GO 11181
// if IsDead ( i ) then
11154: LD_VAR 0 1
11158: PPUSH
11159: CALL_OW 301
11163: IFFALSE 11181
// tmp := tmp diff i ;
11165: LD_ADDR_VAR 0 2
11169: PUSH
11170: LD_VAR 0 2
11174: PUSH
11175: LD_VAR 0 1
11179: DIFF
11180: ST_TO_ADDR
// end ;
11181: GO 11013
11183: POP
11184: POP
// until not tmp ;
11185: LD_VAR 0 2
11189: NOT
11190: IFFALSE 10996
// end ;
11192: PPOPN 4
11194: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 8 and Difficulty > 1 do var i , veh , un ;
11195: LD_EXP 15
11199: PUSH
11200: LD_INT 8
11202: GREATEREQUAL
11203: PUSH
11204: LD_OWVAR 67
11208: PUSH
11209: LD_INT 1
11211: GREATER
11212: AND
11213: IFFALSE 11397
11215: GO 11217
11217: DISABLE
11218: LD_INT 0
11220: PPUSH
11221: PPUSH
11222: PPUSH
// begin ruMobile := [ ] ;
11223: LD_ADDR_EXP 76
11227: PUSH
11228: EMPTY
11229: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11230: LD_ADDR_VAR 0 1
11234: PUSH
11235: DOUBLE
11236: LD_INT 1
11238: DEC
11239: ST_TO_ADDR
11240: LD_INT 3
11242: PUSH
11243: LD_INT 4
11245: PUSH
11246: LD_INT 5
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: LIST
11253: PUSH
11254: LD_OWVAR 67
11258: PUSH
11259: LD_INT 1
11261: MINUS
11262: ARRAY
11263: PUSH
11264: FOR_TO
11265: IFFALSE 11395
// begin uc_side := 3 ;
11267: LD_ADDR_OWVAR 20
11271: PUSH
11272: LD_INT 3
11274: ST_TO_ADDR
// uc_nation := 3 ;
11275: LD_ADDR_OWVAR 21
11279: PUSH
11280: LD_INT 3
11282: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11283: LD_INT 21
11285: PPUSH
11286: LD_INT 3
11288: PPUSH
11289: LD_INT 1
11291: PPUSH
11292: LD_INT 45
11294: PPUSH
11295: LD_INT 100
11297: PPUSH
11298: CALL 72551 0 5
// veh := CreateVehicle ;
11302: LD_ADDR_VAR 0 2
11306: PUSH
11307: CALL_OW 45
11311: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11312: LD_VAR 0 2
11316: PPUSH
11317: LD_INT 3
11319: PPUSH
11320: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11324: LD_VAR 0 2
11328: PPUSH
11329: LD_INT 29
11331: PPUSH
11332: LD_INT 0
11334: PPUSH
11335: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11339: LD_INT 0
11341: PPUSH
11342: LD_INT 10
11344: PPUSH
11345: CALL_OW 383
// un := CreateHuman ;
11349: LD_ADDR_VAR 0 3
11353: PUSH
11354: CALL_OW 44
11358: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11359: LD_VAR 0 3
11363: PPUSH
11364: LD_VAR 0 2
11368: PPUSH
11369: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11373: LD_ADDR_EXP 76
11377: PUSH
11378: LD_EXP 76
11382: PPUSH
11383: LD_VAR 0 2
11387: PPUSH
11388: CALL 105004 0 2
11392: ST_TO_ADDR
// end ;
11393: GO 11264
11395: POP
11396: POP
// end ;
11397: PPOPN 3
11399: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11400: LD_EXP 76
11404: IFFALSE 11912
11406: GO 11408
11408: DISABLE
11409: LD_INT 0
11411: PPUSH
11412: PPUSH
11413: PPUSH
// begin enable ;
11414: ENABLE
// if not ruMobile then
11415: LD_EXP 76
11419: NOT
11420: IFFALSE 11424
// exit ;
11422: GO 11912
// for i in ruMobile do
11424: LD_ADDR_VAR 0 1
11428: PUSH
11429: LD_EXP 76
11433: PUSH
11434: FOR_IN
11435: IFFALSE 11910
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11437: LD_VAR 0 1
11441: PPUSH
11442: CALL_OW 302
11446: NOT
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 255
11457: PUSH
11458: LD_INT 3
11460: NONEQUAL
11461: OR
11462: IFFALSE 11482
// begin ruMobile := ruMobile diff i ;
11464: LD_ADDR_EXP 76
11468: PUSH
11469: LD_EXP 76
11473: PUSH
11474: LD_VAR 0 1
11478: DIFF
11479: ST_TO_ADDR
// continue ;
11480: GO 11434
// end ; if GetTag ( i ) = 300 then
11482: LD_VAR 0 1
11486: PPUSH
11487: CALL_OW 110
11491: PUSH
11492: LD_INT 300
11494: EQUAL
11495: IFFALSE 11545
// begin ComMoveXY ( i , 160 , 81 ) ;
11497: LD_VAR 0 1
11501: PPUSH
11502: LD_INT 160
11504: PPUSH
11505: LD_INT 81
11507: PPUSH
11508: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11512: LD_VAR 0 1
11516: PPUSH
11517: LD_INT 160
11519: PPUSH
11520: LD_INT 81
11522: PPUSH
11523: CALL_OW 297
11527: PUSH
11528: LD_INT 8
11530: LESS
11531: IFFALSE 11545
// SetTag ( i , 301 ) ;
11533: LD_VAR 0 1
11537: PPUSH
11538: LD_INT 301
11540: PPUSH
11541: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11545: LD_VAR 0 1
11549: PPUSH
11550: CALL_OW 110
11554: PUSH
11555: LD_INT 301
11557: EQUAL
11558: IFFALSE 11601
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11560: LD_VAR 0 1
11564: PPUSH
11565: LD_INT 33
11567: PPUSH
11568: CALL_OW 308
11572: NOT
11573: IFFALSE 11589
// ComMoveToArea ( i , ruMobileParkingArea ) else
11575: LD_VAR 0 1
11579: PPUSH
11580: LD_INT 33
11582: PPUSH
11583: CALL_OW 113
11587: GO 11601
// SetTag ( i , 302 ) ;
11589: LD_VAR 0 1
11593: PPUSH
11594: LD_INT 302
11596: PPUSH
11597: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11601: LD_VAR 0 1
11605: PPUSH
11606: CALL_OW 110
11610: PUSH
11611: LD_INT 302
11613: EQUAL
11614: IFFALSE 11744
// begin if GetLives ( i ) < 1000 then
11616: LD_VAR 0 1
11620: PPUSH
11621: CALL_OW 256
11625: PUSH
11626: LD_INT 1000
11628: LESS
11629: IFFALSE 11721
// begin if not IsDrivenBy ( i ) then
11631: LD_VAR 0 1
11635: PPUSH
11636: CALL_OW 311
11640: NOT
11641: IFFALSE 11645
// continue ;
11643: GO 11434
// mech := IsDrivenBy ( i ) ;
11645: LD_ADDR_VAR 0 2
11649: PUSH
11650: LD_VAR 0 1
11654: PPUSH
11655: CALL_OW 311
11659: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11660: LD_VAR 0 2
11664: PPUSH
11665: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11669: LD_VAR 0 2
11673: PPUSH
11674: LD_VAR 0 1
11678: PPUSH
11679: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11683: LD_INT 35
11685: PPUSH
11686: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11690: LD_VAR 0 1
11694: PPUSH
11695: CALL_OW 256
11699: PUSH
11700: LD_INT 1000
11702: EQUAL
11703: IFFALSE 11683
// ComEnterUnit ( mech , i ) ;
11705: LD_VAR 0 2
11709: PPUSH
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL_OW 120
// end else
11719: GO 11744
// if IsDrivenBy ( i ) then
11721: LD_VAR 0 1
11725: PPUSH
11726: CALL_OW 311
11730: IFFALSE 11744
// SetTag ( i , 0 ) ;
11732: LD_VAR 0 1
11736: PPUSH
11737: LD_INT 0
11739: PPUSH
11740: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11744: LD_VAR 0 1
11748: PPUSH
11749: CALL_OW 110
11753: PUSH
11754: LD_INT 300
11756: LESS
11757: IFFALSE 11908
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11759: LD_ADDR_VAR 0 3
11763: PUSH
11764: LD_INT 4
11766: PPUSH
11767: LD_INT 81
11769: PUSH
11770: LD_INT 3
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: PPUSH
11777: CALL_OW 70
11781: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11782: LD_VAR 0 1
11786: PPUSH
11787: CALL_OW 256
11791: PUSH
11792: LD_INT 650
11794: LESS
11795: IFFALSE 11820
// begin ComStop ( i ) ;
11797: LD_VAR 0 1
11801: PPUSH
11802: CALL_OW 141
// SetTag ( i , 300 ) ;
11806: LD_VAR 0 1
11810: PPUSH
11811: LD_INT 300
11813: PPUSH
11814: CALL_OW 109
// continue ;
11818: GO 11434
// end ; if enemy then
11820: LD_VAR 0 3
11824: IFFALSE 11864
// begin if not HasTask ( i ) then
11826: LD_VAR 0 1
11830: PPUSH
11831: CALL_OW 314
11835: NOT
11836: IFFALSE 11862
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11838: LD_VAR 0 1
11842: PPUSH
11843: LD_VAR 0 3
11847: PPUSH
11848: LD_VAR 0 1
11852: PPUSH
11853: CALL_OW 74
11857: PPUSH
11858: CALL_OW 115
// end else
11862: GO 11908
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
11864: LD_VAR 0 1
11868: PPUSH
11869: LD_INT 158
11871: PUSH
11872: LD_INT 61
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: PUSH
11879: LD_INT 98
11881: PUSH
11882: LD_INT 100
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PUSH
11889: LD_INT 78
11891: PUSH
11892: LD_INT 93
11894: PUSH
11895: EMPTY
11896: LIST
11897: LIST
11898: PUSH
11899: EMPTY
11900: LIST
11901: LIST
11902: LIST
11903: PPUSH
11904: CALL 107608 0 2
// end ; end ;
11908: GO 11434
11910: POP
11911: POP
// end ; end_of_file
11912: PPOPN 3
11914: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11915: LD_INT 0
11917: PPUSH
11918: PPUSH
11919: PPUSH
11920: PPUSH
11921: PPUSH
11922: PPUSH
// side := 7 ;
11923: LD_ADDR_VAR 0 5
11927: PUSH
11928: LD_INT 7
11930: ST_TO_ADDR
// uc_side := side ;
11931: LD_ADDR_OWVAR 20
11935: PUSH
11936: LD_VAR 0 5
11940: ST_TO_ADDR
// uc_nation := 1 ;
11941: LD_ADDR_OWVAR 21
11945: PUSH
11946: LD_INT 1
11948: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11949: LD_ADDR_VAR 0 2
11953: PUSH
11954: LD_INT 22
11956: PUSH
11957: LD_VAR 0 5
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: LD_INT 21
11968: PUSH
11969: LD_INT 3
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: PPUSH
11980: CALL_OW 69
11984: PUSH
11985: FOR_IN
11986: IFFALSE 12002
// SetBLevel ( i , 10 ) ;
11988: LD_VAR 0 2
11992: PPUSH
11993: LD_INT 10
11995: PPUSH
11996: CALL_OW 241
12000: GO 11985
12002: POP
12003: POP
// base := GetBase ( al_depot ) ;
12004: LD_ADDR_VAR 0 4
12008: PUSH
12009: LD_INT 2
12011: PPUSH
12012: CALL_OW 274
12016: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12017: LD_ADDR_VAR 0 6
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_VAR 0 5
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: PUSH
12034: LD_INT 30
12036: PUSH
12037: LD_INT 34
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PPUSH
12048: CALL_OW 69
12052: ST_TO_ADDR
// if teleport then
12053: LD_VAR 0 6
12057: IFFALSE 12078
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12059: LD_VAR 0 6
12063: PUSH
12064: LD_INT 1
12066: ARRAY
12067: PPUSH
12068: LD_INT 262
12070: PPUSH
12071: LD_INT 119
12073: PPUSH
12074: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12078: LD_VAR 0 4
12082: PPUSH
12083: LD_INT 1
12085: PPUSH
12086: LD_INT 19500
12088: PPUSH
12089: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12093: LD_VAR 0 4
12097: PPUSH
12098: LD_INT 2
12100: PPUSH
12101: LD_INT 200
12103: PPUSH
12104: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12108: LD_VAR 0 4
12112: PPUSH
12113: LD_INT 3
12115: PPUSH
12116: LD_INT 650
12118: PPUSH
12119: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12123: LD_ADDR_EXP 77
12127: PUSH
12128: LD_STRING Roth
12130: PPUSH
12131: CALL_OW 25
12135: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12136: LD_ADDR_EXP 78
12140: PUSH
12141: LD_STRING Simms
12143: PPUSH
12144: LD_EXP 1
12148: NOT
12149: PPUSH
12150: LD_STRING 10c_
12152: PPUSH
12153: CALL 67536 0 3
12157: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12158: LD_EXP 78
12162: PPUSH
12163: LD_INT 4
12165: PPUSH
12166: CALL_OW 336
// if not Simms then
12170: LD_EXP 78
12174: NOT
12175: IFFALSE 12205
// begin uc_nation := 1 ;
12177: LD_ADDR_OWVAR 21
12181: PUSH
12182: LD_INT 1
12184: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12185: LD_INT 2
12187: PPUSH
12188: LD_INT 10
12190: PPUSH
12191: CALL_OW 384
// Simms := CreateHuman ;
12195: LD_ADDR_EXP 78
12199: PUSH
12200: CALL_OW 44
12204: ST_TO_ADDR
// end ; uc_nation := 3 ;
12205: LD_ADDR_OWVAR 21
12209: PUSH
12210: LD_INT 3
12212: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12213: LD_ADDR_EXP 79
12217: PUSH
12218: LD_STRING Kirilenkova
12220: PPUSH
12221: CALL_OW 25
12225: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12226: LD_ADDR_EXP 93
12230: PUSH
12231: LD_STRING Oblukov
12233: PPUSH
12234: CALL_OW 25
12238: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12239: LD_ADDR_EXP 80
12243: PUSH
12244: LD_STRING Dolgov
12246: PPUSH
12247: CALL_OW 25
12251: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12252: LD_ADDR_EXP 81
12256: PUSH
12257: LD_STRING Petrosyan
12259: PPUSH
12260: CALL_OW 25
12264: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12265: LD_ADDR_EXP 92
12269: PUSH
12270: LD_STRING Scholtze
12272: PPUSH
12273: CALL_OW 25
12277: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12278: LD_ADDR_EXP 91
12282: PUSH
12283: LD_STRING Kapitsova
12285: PPUSH
12286: CALL_OW 25
12290: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12291: LD_ADDR_EXP 82
12295: PUSH
12296: LD_STRING Petrovova
12298: PPUSH
12299: CALL_OW 25
12303: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12304: LD_ADDR_EXP 83
12308: PUSH
12309: LD_STRING Kuzmov
12311: PPUSH
12312: CALL_OW 25
12316: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12317: LD_ADDR_EXP 90
12321: PUSH
12322: LD_STRING Karamazov
12324: PPUSH
12325: CALL_OW 25
12329: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12330: LD_STRING 13_Lipshchin_1
12332: PPUSH
12333: LD_INT 0
12335: PPUSH
12336: CALL_OW 30
12340: IFFALSE 12355
// Lipshchin := NewCharacter ( Lipshchin ) ;
12342: LD_ADDR_EXP 84
12346: PUSH
12347: LD_STRING Lipshchin
12349: PPUSH
12350: CALL_OW 25
12354: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12355: LD_STRING 13_Titov_1
12357: PPUSH
12358: LD_INT 0
12360: PPUSH
12361: CALL_OW 30
12365: IFFALSE 12380
// Titov := NewCharacter ( Titov ) ;
12367: LD_ADDR_EXP 86
12371: PUSH
12372: LD_STRING Titov
12374: PPUSH
12375: CALL_OW 25
12379: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12380: LD_STRING 13_Gnyevko_1
12382: PPUSH
12383: LD_INT 0
12385: PPUSH
12386: CALL_OW 30
12390: IFFALSE 12405
// Gnyevko := NewCharacter ( Gnyevko ) ;
12392: LD_ADDR_EXP 85
12396: PUSH
12397: LD_STRING Gnyevko
12399: PPUSH
12400: CALL_OW 25
12404: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12405: LD_STRING 13_Xavier_1
12407: PPUSH
12408: LD_INT 0
12410: PPUSH
12411: CALL_OW 30
12415: IFFALSE 12430
// Xavier := NewCharacter ( Xavier2 ) ;
12417: LD_ADDR_EXP 87
12421: PUSH
12422: LD_STRING Xavier2
12424: PPUSH
12425: CALL_OW 25
12429: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12430: LD_STRING 13_Belkov_1
12432: PPUSH
12433: LD_INT 0
12435: PPUSH
12436: CALL_OW 30
12440: IFFALSE 12455
// Belkov := NewCharacter ( Belkov ) ;
12442: LD_ADDR_EXP 88
12446: PUSH
12447: LD_STRING Belkov
12449: PPUSH
12450: CALL_OW 25
12454: ST_TO_ADDR
// if not BurlakStatus then
12455: LD_EXP 9
12459: NOT
12460: IFFALSE 12475
// Burlak = NewCharacter ( Burlak ) ;
12462: LD_ADDR_EXP 89
12466: PUSH
12467: LD_STRING Burlak
12469: PPUSH
12470: CALL_OW 25
12474: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12475: LD_ADDR_VAR 0 3
12479: PUSH
12480: LD_EXP 77
12484: PUSH
12485: LD_EXP 79
12489: PUSH
12490: LD_EXP 93
12494: PUSH
12495: LD_EXP 80
12499: PUSH
12500: LD_EXP 81
12504: PUSH
12505: LD_EXP 92
12509: PUSH
12510: LD_EXP 91
12514: PUSH
12515: LD_EXP 82
12519: PUSH
12520: LD_EXP 83
12524: PUSH
12525: LD_EXP 90
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: LIST
12534: LIST
12535: LIST
12536: LIST
12537: LIST
12538: LIST
12539: LIST
12540: LIST
12541: ST_TO_ADDR
// if Simms then
12542: LD_EXP 78
12546: IFFALSE 12564
// tmp := tmp ^ Simms ;
12548: LD_ADDR_VAR 0 3
12552: PUSH
12553: LD_VAR 0 3
12557: PUSH
12558: LD_EXP 78
12562: ADD
12563: ST_TO_ADDR
// if Titov then
12564: LD_EXP 86
12568: IFFALSE 12586
// tmp := tmp ^ Titov ;
12570: LD_ADDR_VAR 0 3
12574: PUSH
12575: LD_VAR 0 3
12579: PUSH
12580: LD_EXP 86
12584: ADD
12585: ST_TO_ADDR
// if Lipshchin then
12586: LD_EXP 84
12590: IFFALSE 12608
// tmp := tmp ^ Lipshchin ;
12592: LD_ADDR_VAR 0 3
12596: PUSH
12597: LD_VAR 0 3
12601: PUSH
12602: LD_EXP 84
12606: ADD
12607: ST_TO_ADDR
// if Gnyevko then
12608: LD_EXP 85
12612: IFFALSE 12630
// tmp := tmp ^ Gnyevko ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_EXP 85
12628: ADD
12629: ST_TO_ADDR
// if Xavier then
12630: LD_EXP 87
12634: IFFALSE 12652
// tmp := tmp ^ Xavier ;
12636: LD_ADDR_VAR 0 3
12640: PUSH
12641: LD_VAR 0 3
12645: PUSH
12646: LD_EXP 87
12650: ADD
12651: ST_TO_ADDR
// if Belkov then
12652: LD_EXP 88
12656: IFFALSE 12674
// tmp := tmp ^ Belkov ;
12658: LD_ADDR_VAR 0 3
12662: PUSH
12663: LD_VAR 0 3
12667: PUSH
12668: LD_EXP 88
12672: ADD
12673: ST_TO_ADDR
// if Burlak then
12674: LD_EXP 89
12678: IFFALSE 12696
// tmp := tmp ^ Burlak ;
12680: LD_ADDR_VAR 0 3
12684: PUSH
12685: LD_VAR 0 3
12689: PUSH
12690: LD_EXP 89
12694: ADD
12695: ST_TO_ADDR
// for i = 1 to 11 do
12696: LD_ADDR_VAR 0 2
12700: PUSH
12701: DOUBLE
12702: LD_INT 1
12704: DEC
12705: ST_TO_ADDR
12706: LD_INT 11
12708: PUSH
12709: FOR_TO
12710: IFFALSE 12776
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12712: LD_ADDR_OWVAR 21
12716: PUSH
12717: LD_INT 1
12719: PUSH
12720: LD_INT 3
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 1
12729: PPUSH
12730: LD_INT 2
12732: PPUSH
12733: CALL_OW 12
12737: ARRAY
12738: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
12739: LD_INT 0
12741: PPUSH
12742: LD_VAR 0 2
12746: PUSH
12747: LD_INT 2
12749: DIV
12750: PPUSH
12751: LD_INT 10
12753: PPUSH
12754: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12758: LD_ADDR_VAR 0 3
12762: PUSH
12763: LD_VAR 0 3
12767: PUSH
12768: CALL_OW 44
12772: ADD
12773: ST_TO_ADDR
// end ;
12774: GO 12709
12776: POP
12777: POP
// for i in tmp do
12778: LD_ADDR_VAR 0 2
12782: PUSH
12783: LD_VAR 0 3
12787: PUSH
12788: FOR_IN
12789: IFFALSE 12814
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12791: LD_VAR 0 2
12795: PPUSH
12796: LD_INT 260
12798: PPUSH
12799: LD_INT 235
12801: PPUSH
12802: LD_INT 8
12804: PPUSH
12805: LD_INT 0
12807: PPUSH
12808: CALL_OW 50
12812: GO 12788
12814: POP
12815: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12816: LD_ADDR_EXP 100
12820: PUSH
12821: LD_EXP 100
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: LD_INT 22
12831: PUSH
12832: LD_VAR 0 5
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 3
12843: PUSH
12844: LD_INT 21
12846: PUSH
12847: LD_INT 2
12849: PUSH
12850: EMPTY
12851: LIST
12852: LIST
12853: PUSH
12854: EMPTY
12855: LIST
12856: LIST
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: PPUSH
12862: CALL_OW 69
12866: PUSH
12867: LD_EXP 77
12871: PUSH
12872: LD_EXP 78
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: DIFF
12881: PPUSH
12882: CALL_OW 1
12886: ST_TO_ADDR
// uc_side := 0 ;
12887: LD_ADDR_OWVAR 20
12891: PUSH
12892: LD_INT 0
12894: ST_TO_ADDR
// uc_nation := 0 ;
12895: LD_ADDR_OWVAR 21
12899: PUSH
12900: LD_INT 0
12902: ST_TO_ADDR
// for i = 1 to 5 do
12903: LD_ADDR_VAR 0 2
12907: PUSH
12908: DOUBLE
12909: LD_INT 1
12911: DEC
12912: ST_TO_ADDR
12913: LD_INT 5
12915: PUSH
12916: FOR_TO
12917: IFFALSE 12954
// begin InitHc ;
12919: CALL_OW 19
// hc_class := class_apeman ;
12923: LD_ADDR_OWVAR 28
12927: PUSH
12928: LD_INT 12
12930: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12931: CALL_OW 44
12935: PPUSH
12936: LD_INT 299
12938: PPUSH
12939: LD_INT 229
12941: PPUSH
12942: LD_INT 10
12944: PPUSH
12945: LD_INT 0
12947: PPUSH
12948: CALL_OW 50
// end ;
12952: GO 12916
12954: POP
12955: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12956: LD_EXP 77
12960: PPUSH
12961: LD_INT 259
12963: PPUSH
12964: LD_INT 235
12966: PPUSH
12967: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12971: LD_EXP 77
12975: PPUSH
12976: LD_INT 262
12978: PPUSH
12979: LD_INT 235
12981: PPUSH
12982: CALL_OW 178
// if Simms then
12986: LD_EXP 78
12990: IFFALSE 13021
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12992: LD_EXP 78
12996: PPUSH
12997: LD_INT 262
12999: PPUSH
13000: LD_INT 235
13002: PPUSH
13003: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13007: LD_EXP 78
13011: PPUSH
13012: LD_EXP 77
13016: PPUSH
13017: CALL_OW 179
// end ; end ;
13021: LD_VAR 0 1
13025: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
13026: LD_EXP 31
13030: PUSH
13031: LD_EXP 23
13035: NOT
13036: AND
13037: IFFALSE 13265
13039: GO 13041
13041: DISABLE
13042: LD_INT 0
13044: PPUSH
13045: PPUSH
13046: PPUSH
// begin enable ;
13047: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13048: LD_ADDR_VAR 0 2
13052: PUSH
13053: LD_INT 81
13055: PUSH
13056: LD_INT 7
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 2
13065: PUSH
13066: LD_INT 32
13068: PUSH
13069: LD_INT 3
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PUSH
13076: LD_INT 30
13078: PUSH
13079: LD_INT 30
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: PUSH
13086: LD_INT 30
13088: PUSH
13089: LD_INT 28
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 34
13098: PUSH
13099: LD_INT 49
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PUSH
13106: LD_INT 34
13108: PUSH
13109: LD_INT 10
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PUSH
13116: LD_INT 34
13118: PUSH
13119: LD_INT 8
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: CALL_OW 69
13143: ST_TO_ADDR
// if not tmp then
13144: LD_VAR 0 2
13148: NOT
13149: IFFALSE 13153
// exit ;
13151: GO 13265
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13153: LD_VAR 0 2
13157: PPUSH
13158: LD_INT 34
13160: PUSH
13161: LD_INT 8
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PPUSH
13168: CALL_OW 72
13172: IFFALSE 13205
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13174: LD_ADDR_VAR 0 3
13178: PUSH
13179: LD_VAR 0 2
13183: PPUSH
13184: LD_INT 34
13186: PUSH
13187: LD_INT 8
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 72
13198: PUSH
13199: LD_INT 1
13201: ARRAY
13202: ST_TO_ADDR
13203: GO 13229
// target := tmp [ rand ( 1 , tmp ) ] ;
13205: LD_ADDR_VAR 0 3
13209: PUSH
13210: LD_VAR 0 2
13214: PUSH
13215: LD_INT 1
13217: PPUSH
13218: LD_VAR 0 2
13222: PPUSH
13223: CALL_OW 12
13227: ARRAY
13228: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13229: LD_VAR 0 3
13233: PPUSH
13234: CALL_OW 255
13238: PUSH
13239: LD_INT 1
13241: EQUAL
13242: IFFALSE 13253
// CenterNowOnUnits ( target ) ;
13244: LD_VAR 0 3
13248: PPUSH
13249: CALL_OW 87
// SetLives ( target , 0 ) ;
13253: LD_VAR 0 3
13257: PPUSH
13258: LD_INT 0
13260: PPUSH
13261: CALL_OW 234
// end ;
13265: PPOPN 3
13267: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13268: LD_EXP 23
13272: NOT
13273: PUSH
13274: LD_EXP 31
13278: AND
13279: IFFALSE 13805
13281: GO 13283
13283: DISABLE
13284: LD_INT 0
13286: PPUSH
13287: PPUSH
13288: PPUSH
// begin uc_side := 7 ;
13289: LD_ADDR_OWVAR 20
13293: PUSH
13294: LD_INT 7
13296: ST_TO_ADDR
// uc_nation := 1 ;
13297: LD_ADDR_OWVAR 21
13301: PUSH
13302: LD_INT 1
13304: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13305: LD_ADDR_VAR 0 3
13309: PUSH
13310: LD_INT 125
13312: PUSH
13313: LD_INT 163
13315: PUSH
13316: EMPTY
13317: LIST
13318: LIST
13319: PUSH
13320: LD_INT 185
13322: PUSH
13323: LD_INT 168
13325: PUSH
13326: EMPTY
13327: LIST
13328: LIST
13329: PUSH
13330: LD_INT 111
13332: PUSH
13333: LD_INT 97
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: LIST
13344: PPUSH
13345: CALL 105109 0 1
13349: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13350: LD_ADDR_EXP 94
13354: PUSH
13355: EMPTY
13356: ST_TO_ADDR
// for i = 1 to Difficulty do
13357: LD_ADDR_VAR 0 1
13361: PUSH
13362: DOUBLE
13363: LD_INT 1
13365: DEC
13366: ST_TO_ADDR
13367: LD_OWVAR 67
13371: PUSH
13372: FOR_TO
13373: IFFALSE 13531
// begin InitHc ;
13375: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13379: LD_INT 0
13381: PPUSH
13382: LD_INT 8
13384: PPUSH
13385: CALL_OW 381
// un := CreateHuman ;
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: CALL_OW 44
13398: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13399: LD_VAR 0 2
13403: PPUSH
13404: LD_INT 258
13406: PPUSH
13407: LD_INT 267
13409: PPUSH
13410: LD_INT 4
13412: PPUSH
13413: LD_INT 0
13415: PPUSH
13416: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13420: LD_ADDR_EXP 94
13424: PUSH
13425: LD_EXP 94
13429: PUSH
13430: LD_VAR 0 2
13434: UNION
13435: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13436: LD_VAR 0 2
13440: PPUSH
13441: LD_VAR 0 3
13445: PUSH
13446: LD_VAR 0 1
13450: ARRAY
13451: PUSH
13452: LD_INT 1
13454: ARRAY
13455: PPUSH
13456: LD_VAR 0 3
13460: PUSH
13461: LD_VAR 0 1
13465: ARRAY
13466: PUSH
13467: LD_INT 2
13469: ARRAY
13470: PPUSH
13471: LD_INT 4
13473: PPUSH
13474: LD_INT 1
13476: PPUSH
13477: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13481: LD_VAR 0 2
13485: PPUSH
13486: LD_VAR 0 3
13490: PUSH
13491: LD_VAR 0 1
13495: ARRAY
13496: PUSH
13497: LD_INT 1
13499: ARRAY
13500: PPUSH
13501: LD_VAR 0 3
13505: PUSH
13506: LD_VAR 0 1
13510: ARRAY
13511: PUSH
13512: LD_INT 2
13514: ARRAY
13515: PPUSH
13516: CALL_OW 171
// AddComInvisible ( un ) ;
13520: LD_VAR 0 2
13524: PPUSH
13525: CALL_OW 212
// end ;
13529: GO 13372
13531: POP
13532: POP
// repeat wait ( 0 0$20 ) ;
13533: LD_INT 700
13535: PPUSH
13536: CALL_OW 67
// for i in allianceSpecialForce do
13540: LD_ADDR_VAR 0 1
13544: PUSH
13545: LD_EXP 94
13549: PUSH
13550: FOR_IN
13551: IFFALSE 13790
// begin if IsInvisible ( i ) then
13553: LD_VAR 0 1
13557: PPUSH
13558: CALL_OW 571
13562: IFFALSE 13759
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13564: LD_ADDR_VAR 0 3
13568: PUSH
13569: LD_INT 22
13571: PUSH
13572: LD_INT 1
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PUSH
13579: LD_INT 50
13581: PUSH
13582: EMPTY
13583: LIST
13584: PUSH
13585: LD_INT 56
13587: PUSH
13588: EMPTY
13589: LIST
13590: PUSH
13591: LD_INT 91
13593: PUSH
13594: LD_VAR 0 1
13598: PUSH
13599: LD_INT 25
13601: PUSH
13602: LD_INT 30
13604: PUSH
13605: LD_INT 35
13607: PUSH
13608: LD_INT 40
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: PUSH
13617: LD_OWVAR 67
13621: ARRAY
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: LIST
13627: PUSH
13628: LD_INT 2
13630: PUSH
13631: LD_INT 25
13633: PUSH
13634: LD_INT 1
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: LD_INT 25
13643: PUSH
13644: LD_INT 2
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: LD_INT 25
13653: PUSH
13654: LD_INT 3
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: PUSH
13661: LD_INT 25
13663: PUSH
13664: LD_INT 4
13666: PUSH
13667: EMPTY
13668: LIST
13669: LIST
13670: PUSH
13671: LD_INT 25
13673: PUSH
13674: LD_INT 5
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 25
13683: PUSH
13684: LD_INT 8
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: PPUSH
13707: CALL_OW 69
13711: ST_TO_ADDR
// if not tmp then
13712: LD_VAR 0 3
13716: NOT
13717: IFFALSE 13721
// continue ;
13719: GO 13550
// if Prob ( 30 * Difficulty ) then
13721: LD_INT 30
13723: PUSH
13724: LD_OWVAR 67
13728: MUL
13729: PPUSH
13730: CALL_OW 13
13734: IFFALSE 13759
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13736: LD_VAR 0 3
13740: PUSH
13741: LD_INT 1
13743: PPUSH
13744: LD_VAR 0 3
13748: PPUSH
13749: CALL_OW 12
13753: ARRAY
13754: PPUSH
13755: CALL 32858 0 1
// end ; if IsDead ( i ) then
13759: LD_VAR 0 1
13763: PPUSH
13764: CALL_OW 301
13768: IFFALSE 13788
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13770: LD_ADDR_EXP 94
13774: PUSH
13775: LD_EXP 94
13779: PUSH
13780: LD_VAR 0 1
13784: DIFF
13785: ST_TO_ADDR
// continue ;
13786: GO 13550
// end ; end ;
13788: GO 13550
13790: POP
13791: POP
// until allianceDestroyed or not allianceSpecialForce ;
13792: LD_EXP 23
13796: PUSH
13797: LD_EXP 94
13801: NOT
13802: OR
13803: IFFALSE 13533
// end ;
13805: PPOPN 3
13807: END
// every 12 12$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13808: LD_EXP 23
13812: NOT
13813: PUSH
13814: LD_EXP 31
13818: AND
13819: IFFALSE 14769
13821: GO 13823
13823: DISABLE
13824: LD_INT 0
13826: PPUSH
13827: PPUSH
13828: PPUSH
13829: PPUSH
// begin enable ;
13830: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13831: LD_INT 22
13833: PUSH
13834: LD_INT 7
13836: PUSH
13837: EMPTY
13838: LIST
13839: LIST
13840: PUSH
13841: LD_INT 30
13843: PUSH
13844: LD_INT 3
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: EMPTY
13852: LIST
13853: LIST
13854: PPUSH
13855: CALL_OW 69
13859: NOT
13860: IFFALSE 13864
// exit ;
13862: GO 14769
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13864: LD_ADDR_VAR 0 4
13868: PUSH
13869: LD_INT 22
13871: PUSH
13872: LD_INT 7
13874: PUSH
13875: EMPTY
13876: LIST
13877: LIST
13878: PUSH
13879: LD_INT 30
13881: PUSH
13882: LD_INT 34
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: PUSH
13889: EMPTY
13890: LIST
13891: LIST
13892: PPUSH
13893: CALL_OW 69
13897: ST_TO_ADDR
// if Prob ( 40 ) then
13898: LD_INT 40
13900: PPUSH
13901: CALL_OW 13
13905: IFFALSE 14051
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13907: LD_INT 1
13909: PPUSH
13910: LD_INT 5
13912: PUSH
13913: LD_INT 3
13915: PUSH
13916: LD_INT 2
13918: PUSH
13919: LD_INT 6
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: PUSH
13928: LD_INT 5
13930: PUSH
13931: LD_INT 3
13933: PUSH
13934: LD_INT 2
13936: PUSH
13937: LD_INT 6
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 5
13948: PUSH
13949: LD_INT 3
13951: PUSH
13952: LD_INT 2
13954: PUSH
13955: LD_INT 6
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 5
13966: PUSH
13967: LD_INT 3
13969: PUSH
13970: LD_INT 2
13972: PUSH
13973: LD_INT 9
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: PUSH
13982: LD_INT 24
13984: PUSH
13985: LD_INT 3
13987: PUSH
13988: LD_INT 3
13990: PUSH
13991: LD_INT 45
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: PUSH
14000: LD_INT 24
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: LD_INT 3
14008: PUSH
14009: LD_INT 47
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: PUSH
14018: LD_INT 24
14020: PUSH
14021: LD_INT 3
14023: PUSH
14024: LD_INT 3
14026: PUSH
14027: LD_INT 45
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: PPUSH
14045: CALL 61148 0 2
// end else
14049: GO 14193
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
14051: LD_INT 1
14053: PPUSH
14054: LD_INT 24
14056: PUSH
14057: LD_INT 3
14059: PUSH
14060: LD_INT 3
14062: PUSH
14063: LD_INT 47
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: LIST
14070: LIST
14071: PUSH
14072: LD_INT 24
14074: PUSH
14075: LD_INT 3
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: LD_INT 47
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 5
14092: PUSH
14093: LD_INT 3
14095: PUSH
14096: LD_INT 2
14098: PUSH
14099: LD_INT 9
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: PUSH
14108: LD_INT 5
14110: PUSH
14111: LD_INT 3
14113: PUSH
14114: LD_INT 2
14116: PUSH
14117: LD_INT 9
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: PUSH
14126: LD_INT 5
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: LD_INT 2
14134: PUSH
14135: LD_INT 9
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: PUSH
14144: LD_INT 24
14146: PUSH
14147: LD_INT 1
14149: PUSH
14150: LD_INT 3
14152: PUSH
14153: LD_INT 45
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: PUSH
14162: LD_INT 24
14164: PUSH
14165: LD_INT 1
14167: PUSH
14168: LD_INT 3
14170: PUSH
14171: LD_INT 45
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: PPUSH
14189: CALL 61148 0 2
// end ; repeat wait ( 0 0$1 ) ;
14193: LD_INT 35
14195: PPUSH
14196: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14200: LD_INT 1
14202: PPUSH
14203: LD_INT 1
14205: PPUSH
14206: CALL 62566 0 2
14210: PUSH
14211: LD_INT 7
14213: GREATEREQUAL
14214: IFFALSE 14193
// wait ( 0 0$10 ) ;
14216: LD_INT 350
14218: PPUSH
14219: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14223: LD_ADDR_VAR 0 2
14227: PUSH
14228: LD_INT 1
14230: PPUSH
14231: LD_INT 1
14233: PPUSH
14234: CALL 62566 0 2
14238: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14239: LD_ADDR_EXP 119
14243: PUSH
14244: LD_EXP 119
14248: PPUSH
14249: LD_INT 1
14251: PPUSH
14252: LD_EXP 119
14256: PUSH
14257: LD_INT 1
14259: ARRAY
14260: PUSH
14261: LD_VAR 0 2
14265: DIFF
14266: PPUSH
14267: CALL_OW 1
14271: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14272: LD_ADDR_VAR 0 3
14276: PUSH
14277: LD_INT 0
14279: PPUSH
14280: LD_INT 1
14282: PPUSH
14283: CALL_OW 12
14287: ST_TO_ADDR
// if target then
14288: LD_VAR 0 3
14292: IFFALSE 14458
// begin for i in tmp do
14294: LD_ADDR_VAR 0 1
14298: PUSH
14299: LD_VAR 0 2
14303: PUSH
14304: FOR_IN
14305: IFFALSE 14330
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14307: LD_VAR 0 1
14311: PPUSH
14312: LD_INT 179
14314: PPUSH
14315: LD_INT 209
14317: PPUSH
14318: LD_INT 8
14320: PPUSH
14321: LD_INT 1
14323: PPUSH
14324: CALL_OW 483
14328: GO 14304
14330: POP
14331: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14332: LD_ADDR_VAR 0 2
14336: PUSH
14337: LD_VAR 0 2
14341: PPUSH
14342: LD_INT 24
14344: PUSH
14345: LD_INT 250
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PPUSH
14352: CALL_OW 72
14356: ST_TO_ADDR
// for i in tmp do
14357: LD_ADDR_VAR 0 1
14361: PUSH
14362: LD_VAR 0 2
14366: PUSH
14367: FOR_IN
14368: IFFALSE 14408
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14370: LD_VAR 0 1
14374: PPUSH
14375: LD_INT 179
14377: PPUSH
14378: LD_INT 209
14380: PPUSH
14381: CALL_OW 297
14385: PUSH
14386: LD_INT 9
14388: GREATER
14389: IFFALSE 14406
// ComMoveXY ( i , 179 , 209 ) ;
14391: LD_VAR 0 1
14395: PPUSH
14396: LD_INT 179
14398: PPUSH
14399: LD_INT 209
14401: PPUSH
14402: CALL_OW 111
14406: GO 14367
14408: POP
14409: POP
// wait ( 0 0$1 ) ;
14410: LD_INT 35
14412: PPUSH
14413: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14417: LD_VAR 0 2
14421: PPUSH
14422: LD_INT 92
14424: PUSH
14425: LD_INT 179
14427: PUSH
14428: LD_INT 209
14430: PUSH
14431: LD_INT 9
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: PPUSH
14440: CALL_OW 72
14444: PUSH
14445: LD_VAR 0 2
14449: PUSH
14450: LD_INT 1
14452: MINUS
14453: GREATEREQUAL
14454: IFFALSE 14332
// end else
14456: GO 14620
// begin for i in tmp do
14458: LD_ADDR_VAR 0 1
14462: PUSH
14463: LD_VAR 0 2
14467: PUSH
14468: FOR_IN
14469: IFFALSE 14494
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14471: LD_VAR 0 1
14475: PPUSH
14476: LD_INT 285
14478: PPUSH
14479: LD_INT 163
14481: PPUSH
14482: LD_INT 8
14484: PPUSH
14485: LD_INT 1
14487: PPUSH
14488: CALL_OW 483
14492: GO 14468
14494: POP
14495: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14496: LD_ADDR_VAR 0 2
14500: PUSH
14501: LD_VAR 0 2
14505: PPUSH
14506: LD_INT 24
14508: PUSH
14509: LD_INT 250
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PPUSH
14516: CALL_OW 72
14520: ST_TO_ADDR
// for i in tmp do
14521: LD_ADDR_VAR 0 1
14525: PUSH
14526: LD_VAR 0 2
14530: PUSH
14531: FOR_IN
14532: IFFALSE 14572
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14534: LD_VAR 0 1
14538: PPUSH
14539: LD_INT 285
14541: PPUSH
14542: LD_INT 163
14544: PPUSH
14545: CALL_OW 297
14549: PUSH
14550: LD_INT 9
14552: GREATER
14553: IFFALSE 14570
// ComMoveXY ( i , 285 , 163 ) ;
14555: LD_VAR 0 1
14559: PPUSH
14560: LD_INT 285
14562: PPUSH
14563: LD_INT 163
14565: PPUSH
14566: CALL_OW 111
14570: GO 14531
14572: POP
14573: POP
// wait ( 0 0$1 ) ;
14574: LD_INT 35
14576: PPUSH
14577: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14581: LD_VAR 0 2
14585: PPUSH
14586: LD_INT 92
14588: PUSH
14589: LD_INT 285
14591: PUSH
14592: LD_INT 163
14594: PUSH
14595: LD_INT 9
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: PPUSH
14604: CALL_OW 72
14608: PUSH
14609: LD_VAR 0 2
14613: PUSH
14614: LD_INT 1
14616: MINUS
14617: GREATEREQUAL
14618: IFFALSE 14496
// end ; repeat wait ( 0 0$1 ) ;
14620: LD_INT 35
14622: PPUSH
14623: CALL_OW 67
// for i in tmp do
14627: LD_ADDR_VAR 0 1
14631: PUSH
14632: LD_VAR 0 2
14636: PUSH
14637: FOR_IN
14638: IFFALSE 14760
// if GetLives ( i ) > 251 then
14640: LD_VAR 0 1
14644: PPUSH
14645: CALL_OW 256
14649: PUSH
14650: LD_INT 251
14652: GREATER
14653: IFFALSE 14742
// begin if GetWeapon ( i ) = ru_time_lapser then
14655: LD_VAR 0 1
14659: PPUSH
14660: CALL_OW 264
14664: PUSH
14665: LD_INT 49
14667: EQUAL
14668: IFFALSE 14706
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14670: LD_VAR 0 1
14674: PPUSH
14675: LD_INT 81
14677: PUSH
14678: LD_INT 7
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PPUSH
14685: CALL_OW 69
14689: PPUSH
14690: LD_VAR 0 1
14694: PPUSH
14695: CALL_OW 74
14699: PPUSH
14700: CALL_OW 112
14704: GO 14740
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14706: LD_VAR 0 1
14710: PPUSH
14711: LD_INT 81
14713: PUSH
14714: LD_INT 7
14716: PUSH
14717: EMPTY
14718: LIST
14719: LIST
14720: PPUSH
14721: CALL_OW 69
14725: PPUSH
14726: LD_VAR 0 1
14730: PPUSH
14731: CALL_OW 74
14735: PPUSH
14736: CALL_OW 115
// end else
14740: GO 14758
// tmp := tmp diff i ;
14742: LD_ADDR_VAR 0 2
14746: PUSH
14747: LD_VAR 0 2
14751: PUSH
14752: LD_VAR 0 1
14756: DIFF
14757: ST_TO_ADDR
14758: GO 14637
14760: POP
14761: POP
// until not tmp ;
14762: LD_VAR 0 2
14766: NOT
14767: IFFALSE 14620
// end ; end_of_file
14769: PPOPN 4
14771: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
14772: LD_INT 0
14774: PPUSH
14775: PPUSH
14776: PPUSH
14777: PPUSH
// missionStage := 13 ;
14778: LD_ADDR_EXP 15
14782: PUSH
14783: LD_INT 13
14785: ST_TO_ADDR
// uc_side := 2 ;
14786: LD_ADDR_OWVAR 20
14790: PUSH
14791: LD_INT 2
14793: ST_TO_ADDR
// uc_nation := 2 ;
14794: LD_ADDR_OWVAR 21
14798: PUSH
14799: LD_INT 2
14801: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14802: LD_ADDR_EXP 95
14806: PUSH
14807: LD_STRING Omar
14809: PPUSH
14810: CALL_OW 25
14814: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14815: LD_EXP 95
14819: PPUSH
14820: LD_INT 4
14822: PPUSH
14823: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14827: LD_EXP 95
14831: PPUSH
14832: LD_INT 242
14834: PPUSH
14835: LD_INT 75
14837: PPUSH
14838: LD_INT 0
14840: PPUSH
14841: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14845: LD_ADDR_EXP 96
14849: PUSH
14850: LD_STRING Heike
14852: PPUSH
14853: CALL_OW 25
14857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14858: LD_INT 14
14860: PPUSH
14861: LD_INT 3
14863: PPUSH
14864: LD_INT 1
14866: PPUSH
14867: LD_INT 27
14869: PPUSH
14870: LD_INT 100
14872: PPUSH
14873: CALL 72551 0 5
// veh := CreateVehicle ;
14877: LD_ADDR_VAR 0 3
14881: PUSH
14882: CALL_OW 45
14886: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14887: LD_VAR 0 3
14891: PPUSH
14892: LD_INT 2
14894: NEG
14895: PPUSH
14896: CALL_OW 242
// SetDir ( veh , 4 ) ;
14900: LD_VAR 0 3
14904: PPUSH
14905: LD_INT 4
14907: PPUSH
14908: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14912: LD_VAR 0 3
14916: PPUSH
14917: LD_INT 241
14919: PPUSH
14920: LD_INT 72
14922: PPUSH
14923: LD_INT 0
14925: PPUSH
14926: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14930: LD_EXP 96
14934: PPUSH
14935: LD_VAR 0 3
14939: PPUSH
14940: CALL_OW 52
// if KhatamStatus then
14944: LD_EXP 8
14948: IFFALSE 15011
// begin Khatam := NewCharacter ( Khatam ) ;
14950: LD_ADDR_EXP 97
14954: PUSH
14955: LD_STRING Khatam
14957: PPUSH
14958: CALL_OW 25
14962: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14963: LD_EXP 97
14967: PPUSH
14968: LD_INT 245
14970: PPUSH
14971: LD_INT 78
14973: PPUSH
14974: LD_INT 3
14976: PPUSH
14977: LD_INT 0
14979: PPUSH
14980: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14984: LD_EXP 97
14988: PPUSH
14989: LD_INT 4
14991: PPUSH
14992: LD_INT 10
14994: PPUSH
14995: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14999: LD_EXP 97
15003: PPUSH
15004: LD_INT 4
15006: PPUSH
15007: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: DOUBLE
15017: LD_INT 1
15019: DEC
15020: ST_TO_ADDR
15021: LD_INT 2
15023: PUSH
15024: LD_INT 2
15026: PUSH
15027: LD_INT 3
15029: PUSH
15030: LD_INT 3
15032: PUSH
15033: EMPTY
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: PUSH
15039: LD_OWVAR 67
15043: ARRAY
15044: PUSH
15045: FOR_TO
15046: IFFALSE 15112
// begin PrepareScientist ( false , 6 + Difficulty ) ;
15048: LD_INT 0
15050: PPUSH
15051: LD_INT 6
15053: PUSH
15054: LD_OWVAR 67
15058: PLUS
15059: PPUSH
15060: CALL_OW 384
// un := CreateHuman ;
15064: LD_ADDR_VAR 0 4
15068: PUSH
15069: CALL_OW 44
15073: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
15074: LD_VAR 0 4
15078: PPUSH
15079: LD_INT 28
15081: PUSH
15082: LD_INT 29
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PUSH
15089: LD_VAR 0 2
15093: PUSH
15094: LD_INT 2
15096: MOD
15097: PUSH
15098: LD_INT 1
15100: PLUS
15101: ARRAY
15102: PPUSH
15103: LD_INT 0
15105: PPUSH
15106: CALL_OW 49
// end ;
15110: GO 15045
15112: POP
15113: POP
// for i = 1 to 6 do
15114: LD_ADDR_VAR 0 2
15118: PUSH
15119: DOUBLE
15120: LD_INT 1
15122: DEC
15123: ST_TO_ADDR
15124: LD_INT 6
15126: PUSH
15127: FOR_TO
15128: IFFALSE 15173
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15130: LD_INT 0
15132: PPUSH
15133: LD_INT 6
15135: PUSH
15136: LD_OWVAR 67
15140: PLUS
15141: PPUSH
15142: CALL_OW 381
// un := CreateHuman ;
15146: LD_ADDR_VAR 0 4
15150: PUSH
15151: CALL_OW 44
15155: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15156: LD_VAR 0 4
15160: PPUSH
15161: LD_INT 32
15163: PPUSH
15164: LD_INT 0
15166: PPUSH
15167: CALL_OW 49
// end ;
15171: GO 15127
15173: POP
15174: POP
// for i = 1 to 3 do
15175: LD_ADDR_VAR 0 2
15179: PUSH
15180: DOUBLE
15181: LD_INT 1
15183: DEC
15184: ST_TO_ADDR
15185: LD_INT 3
15187: PUSH
15188: FOR_TO
15189: IFFALSE 15237
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15191: LD_INT 0
15193: PPUSH
15194: LD_INT 8
15196: PPUSH
15197: LD_INT 6
15199: PUSH
15200: LD_OWVAR 67
15204: PLUS
15205: PPUSH
15206: CALL_OW 380
// un := CreateHuman ;
15210: LD_ADDR_VAR 0 4
15214: PUSH
15215: CALL_OW 44
15219: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15220: LD_VAR 0 4
15224: PPUSH
15225: LD_INT 32
15227: PPUSH
15228: LD_INT 0
15230: PPUSH
15231: CALL_OW 49
// end ;
15235: GO 15188
15237: POP
15238: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15239: LD_ADDR_VAR 0 2
15243: PUSH
15244: DOUBLE
15245: LD_INT 1
15247: DEC
15248: ST_TO_ADDR
15249: LD_INT 2
15251: PUSH
15252: LD_INT 3
15254: PUSH
15255: LD_INT 4
15257: PUSH
15258: LD_INT 4
15260: PUSH
15261: EMPTY
15262: LIST
15263: LIST
15264: LIST
15265: LIST
15266: PUSH
15267: LD_OWVAR 67
15271: ARRAY
15272: PUSH
15273: FOR_TO
15274: IFFALSE 15364
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15276: LD_INT 14
15278: PPUSH
15279: LD_INT 2
15281: PPUSH
15282: LD_INT 1
15284: PPUSH
15285: LD_INT 28
15287: PPUSH
15288: LD_INT 80
15290: PPUSH
15291: CALL 72551 0 5
// veh := CreateVehicle ;
15295: LD_ADDR_VAR 0 3
15299: PUSH
15300: CALL_OW 45
15304: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15305: LD_VAR 0 3
15309: PPUSH
15310: LD_INT 3
15312: PPUSH
15313: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15317: LD_VAR 0 3
15321: PPUSH
15322: LD_INT 29
15324: PPUSH
15325: LD_INT 0
15327: PPUSH
15328: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15332: LD_INT 0
15334: PPUSH
15335: LD_INT 6
15337: PUSH
15338: LD_OWVAR 67
15342: PLUS
15343: PPUSH
15344: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15348: CALL_OW 44
15352: PPUSH
15353: LD_VAR 0 3
15357: PPUSH
15358: CALL_OW 52
// end ;
15362: GO 15273
15364: POP
15365: POP
// for i = 1 to 5 + Difficulty do
15366: LD_ADDR_VAR 0 2
15370: PUSH
15371: DOUBLE
15372: LD_INT 1
15374: DEC
15375: ST_TO_ADDR
15376: LD_INT 5
15378: PUSH
15379: LD_OWVAR 67
15383: PLUS
15384: PUSH
15385: FOR_TO
15386: IFFALSE 15513
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15388: LD_INT 14
15390: PPUSH
15391: LD_INT 1
15393: PPUSH
15394: LD_INT 3
15396: PPUSH
15397: CALL_OW 12
15401: PPUSH
15402: LD_INT 1
15404: PPUSH
15405: LD_INT 28
15407: PUSH
15408: LD_INT 26
15410: PUSH
15411: LD_INT 27
15413: PUSH
15414: LD_INT 25
15416: PUSH
15417: EMPTY
15418: LIST
15419: LIST
15420: LIST
15421: LIST
15422: PUSH
15423: LD_VAR 0 2
15427: PUSH
15428: LD_INT 4
15430: MOD
15431: PUSH
15432: LD_INT 1
15434: PLUS
15435: ARRAY
15436: PPUSH
15437: LD_INT 80
15439: PPUSH
15440: CALL 72551 0 5
// veh := CreateVehicle ;
15444: LD_ADDR_VAR 0 3
15448: PUSH
15449: CALL_OW 45
15453: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15454: LD_VAR 0 3
15458: PPUSH
15459: LD_INT 4
15461: PPUSH
15462: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15466: LD_VAR 0 3
15470: PPUSH
15471: LD_INT 28
15473: PPUSH
15474: LD_INT 0
15476: PPUSH
15477: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15481: LD_INT 0
15483: PPUSH
15484: LD_INT 6
15486: PUSH
15487: LD_OWVAR 67
15491: PLUS
15492: PPUSH
15493: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15497: CALL_OW 44
15501: PPUSH
15502: LD_VAR 0 3
15506: PPUSH
15507: CALL_OW 52
// end ;
15511: GO 15385
15513: POP
15514: POP
// for i = 1 to Difficulty do
15515: LD_ADDR_VAR 0 2
15519: PUSH
15520: DOUBLE
15521: LD_INT 1
15523: DEC
15524: ST_TO_ADDR
15525: LD_OWVAR 67
15529: PUSH
15530: FOR_TO
15531: IFFALSE 15591
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15533: LD_INT 14
15535: PPUSH
15536: LD_INT 3
15538: PPUSH
15539: LD_INT 5
15541: PPUSH
15542: LD_INT 29
15544: PPUSH
15545: LD_INT 80
15547: PPUSH
15548: CALL 72551 0 5
// veh := CreateVehicle ;
15552: LD_ADDR_VAR 0 3
15556: PUSH
15557: CALL_OW 45
15561: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15562: LD_VAR 0 3
15566: PPUSH
15567: LD_INT 4
15569: PPUSH
15570: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15574: LD_VAR 0 3
15578: PPUSH
15579: LD_INT 28
15581: PPUSH
15582: LD_INT 0
15584: PPUSH
15585: CALL_OW 49
// end ;
15589: GO 15530
15591: POP
15592: POP
// end ;
15593: LD_VAR 0 1
15597: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15598: LD_INT 22
15600: PUSH
15601: LD_INT 2
15603: PUSH
15604: EMPTY
15605: LIST
15606: LIST
15607: PPUSH
15608: CALL_OW 69
15612: IFFALSE 15991
15614: GO 15616
15616: DISABLE
15617: LD_INT 0
15619: PPUSH
15620: PPUSH
15621: PPUSH
15622: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15623: LD_ADDR_VAR 0 3
15627: PUSH
15628: LD_INT 22
15630: PUSH
15631: LD_INT 2
15633: PUSH
15634: EMPTY
15635: LIST
15636: LIST
15637: PUSH
15638: LD_INT 25
15640: PUSH
15641: LD_INT 4
15643: PUSH
15644: EMPTY
15645: LIST
15646: LIST
15647: PUSH
15648: EMPTY
15649: LIST
15650: LIST
15651: PPUSH
15652: CALL_OW 69
15656: PUSH
15657: LD_EXP 97
15661: DIFF
15662: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15663: LD_ADDR_VAR 0 2
15667: PUSH
15668: LD_INT 22
15670: PUSH
15671: LD_INT 2
15673: PUSH
15674: EMPTY
15675: LIST
15676: LIST
15677: PPUSH
15678: CALL_OW 69
15682: PUSH
15683: LD_EXP 97
15687: PUSH
15688: LD_VAR 0 3
15692: UNION
15693: DIFF
15694: ST_TO_ADDR
// if Khatam then
15695: LD_EXP 97
15699: IFFALSE 15716
// ComMoveXY ( Khatam , 211 , 92 ) ;
15701: LD_EXP 97
15705: PPUSH
15706: LD_INT 211
15708: PPUSH
15709: LD_INT 92
15711: PPUSH
15712: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15716: LD_INT 197
15718: PPUSH
15719: LD_INT 80
15721: PPUSH
15722: LD_INT 2
15724: PPUSH
15725: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15729: LD_INT 213
15731: PPUSH
15732: LD_INT 90
15734: PPUSH
15735: LD_INT 2
15737: PPUSH
15738: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
15742: LD_INT 215
15744: PPUSH
15745: LD_INT 129
15747: PPUSH
15748: LD_INT 2
15750: PPUSH
15751: CALL_OW 441
// if sci then
15755: LD_VAR 0 3
15759: IFFALSE 15780
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
15761: LD_VAR 0 3
15765: PUSH
15766: LD_INT 1
15768: ARRAY
15769: PPUSH
15770: LD_INT 197
15772: PPUSH
15773: LD_INT 80
15775: PPUSH
15776: CALL_OW 158
// if sci > 1 then
15780: LD_VAR 0 3
15784: PUSH
15785: LD_INT 1
15787: GREATER
15788: IFFALSE 15809
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
15790: LD_VAR 0 3
15794: PUSH
15795: LD_INT 2
15797: ARRAY
15798: PPUSH
15799: LD_INT 213
15801: PPUSH
15802: LD_INT 90
15804: PPUSH
15805: CALL_OW 158
// if sci > 2 then
15809: LD_VAR 0 3
15813: PUSH
15814: LD_INT 2
15816: GREATER
15817: IFFALSE 15838
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
15819: LD_VAR 0 3
15823: PUSH
15824: LD_INT 3
15826: ARRAY
15827: PPUSH
15828: LD_INT 215
15830: PPUSH
15831: LD_INT 129
15833: PPUSH
15834: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
15838: LD_VAR 0 2
15842: PPUSH
15843: LD_INT 195
15845: PPUSH
15846: LD_INT 102
15848: PPUSH
15849: CALL_OW 114
// wait ( 0 0$5 ) ;
15853: LD_INT 175
15855: PPUSH
15856: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
15860: LD_INT 70
15862: PPUSH
15863: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
15867: LD_ADDR_VAR 0 4
15871: PUSH
15872: LD_INT 92
15874: PUSH
15875: LD_INT 195
15877: PUSH
15878: LD_INT 102
15880: PUSH
15881: LD_INT 36
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: LIST
15889: PUSH
15890: LD_INT 22
15892: PUSH
15893: LD_INT 1
15895: PUSH
15896: EMPTY
15897: LIST
15898: LIST
15899: PUSH
15900: EMPTY
15901: LIST
15902: LIST
15903: PPUSH
15904: CALL_OW 69
15908: ST_TO_ADDR
// for i in tmp do
15909: LD_ADDR_VAR 0 1
15913: PUSH
15914: LD_VAR 0 2
15918: PUSH
15919: FOR_IN
15920: IFFALSE 15971
// if enemy then
15922: LD_VAR 0 4
15926: IFFALSE 15954
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_VAR 0 4
15937: PPUSH
15938: LD_VAR 0 1
15942: PPUSH
15943: CALL_OW 74
15947: PPUSH
15948: CALL_OW 115
15952: GO 15969
// ComAgressiveMove ( i , 195 , 102 ) ;
15954: LD_VAR 0 1
15958: PPUSH
15959: LD_INT 195
15961: PPUSH
15962: LD_INT 102
15964: PPUSH
15965: CALL_OW 114
15969: GO 15919
15971: POP
15972: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
15973: LD_VAR 0 2
15977: PPUSH
15978: LD_INT 50
15980: PUSH
15981: EMPTY
15982: LIST
15983: PPUSH
15984: CALL_OW 72
15988: NOT
15989: IFFALSE 15860
// end ; end_of_file
15991: PPOPN 4
15993: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15994: LD_INT 0
15996: PPUSH
15997: PPUSH
15998: PPUSH
15999: PPUSH
16000: PPUSH
16001: PPUSH
16002: PPUSH
16003: PPUSH
16004: PPUSH
// Video ( true ) ;
16005: LD_INT 1
16007: PPUSH
16008: CALL 104976 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
16012: LD_ADDR_VAR 0 5
16016: PUSH
16017: LD_INT 7
16019: PPUSH
16020: LD_INT 0
16022: PPUSH
16023: CALL_OW 517
16027: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
16028: LD_ADDR_VAR 0 2
16032: PUSH
16033: DOUBLE
16034: LD_INT 1
16036: DEC
16037: ST_TO_ADDR
16038: LD_VAR 0 5
16042: PUSH
16043: LD_INT 1
16045: ARRAY
16046: PUSH
16047: FOR_TO
16048: IFFALSE 16093
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
16050: LD_VAR 0 5
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PUSH
16059: LD_VAR 0 2
16063: ARRAY
16064: PPUSH
16065: LD_VAR 0 5
16069: PUSH
16070: LD_INT 2
16072: ARRAY
16073: PUSH
16074: LD_VAR 0 2
16078: ARRAY
16079: PPUSH
16080: LD_INT 1
16082: PPUSH
16083: LD_INT 15
16085: NEG
16086: PPUSH
16087: CALL 104890 0 4
16091: GO 16047
16093: POP
16094: POP
// CenterNowOnUnits ( Powell ) ;
16095: LD_EXP 60
16099: PPUSH
16100: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
16104: LD_ADDR_VAR 0 5
16108: PUSH
16109: LD_EXP 58
16113: PUSH
16114: EMPTY
16115: LIST
16116: ST_TO_ADDR
// if GirlNewVeh then
16117: LD_EXP 59
16121: IFFALSE 16139
// tmp := tmp ^ GirlNewVeh ;
16123: LD_ADDR_VAR 0 5
16127: PUSH
16128: LD_VAR 0 5
16132: PUSH
16133: LD_EXP 59
16137: ADD
16138: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16139: LD_VAR 0 5
16143: PPUSH
16144: LD_INT 60
16146: PPUSH
16147: LD_INT 109
16149: PPUSH
16150: CALL_OW 111
// if KappaStatus then
16154: LD_EXP 2
16158: IFFALSE 16210
// begin Say ( JMM , D1nT-JMM-1 ) ;
16160: LD_EXP 40
16164: PPUSH
16165: LD_STRING D1nT-JMM-1
16167: PPUSH
16168: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16172: LD_EXP 60
16176: PPUSH
16177: LD_STRING D1T-Pow-1
16179: PPUSH
16180: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16184: LD_EXP 40
16188: PPUSH
16189: LD_STRING D1T-JMM-2
16191: PPUSH
16192: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16196: LD_EXP 60
16200: PPUSH
16201: LD_STRING D1T-Pow-2
16203: PPUSH
16204: CALL_OW 88
// end else
16208: GO 16416
// if JMMGirlStatus then
16210: LD_EXP 6
16214: IFFALSE 16359
// begin Say ( JMM , D1T-JMM-1 ) ;
16216: LD_EXP 40
16220: PPUSH
16221: LD_STRING D1T-JMM-1
16223: PPUSH
16224: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16228: LD_EXP 60
16232: PPUSH
16233: LD_STRING D1T-Pow-1
16235: PPUSH
16236: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16240: LD_EXP 40
16244: PPUSH
16245: LD_STRING D1T-JMM-3
16247: PPUSH
16248: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16252: LD_EXP 60
16256: PPUSH
16257: LD_STRING D1T-Pow-3
16259: PPUSH
16260: CALL_OW 88
// if JMMGirl then
16264: LD_EXP 7
16268: IFFALSE 16357
// begin case JMMGirl of 1 :
16270: LD_EXP 7
16274: PUSH
16275: LD_INT 1
16277: DOUBLE
16278: EQUAL
16279: IFTRUE 16283
16281: GO 16298
16283: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16284: LD_EXP 41
16288: PPUSH
16289: LD_STRING D1T-Joan-3
16291: PPUSH
16292: CALL_OW 88
16296: GO 16345
16298: LD_INT 2
16300: DOUBLE
16301: EQUAL
16302: IFTRUE 16306
16304: GO 16321
16306: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16307: LD_EXP 43
16311: PPUSH
16312: LD_STRING D1T-Lisa-3
16314: PPUSH
16315: CALL_OW 88
16319: GO 16345
16321: LD_INT 3
16323: DOUBLE
16324: EQUAL
16325: IFTRUE 16329
16327: GO 16344
16329: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16330: LD_EXP 55
16334: PPUSH
16335: LD_STRING D1T-Con-3
16337: PPUSH
16338: CALL_OW 88
16342: GO 16345
16344: POP
// Say ( Powell , D1T-Pow-4 ) ;
16345: LD_EXP 60
16349: PPUSH
16350: LD_STRING D1T-Pow-4
16352: PPUSH
16353: CALL_OW 88
// end ; end else
16357: GO 16416
// if not FastEnd then
16359: LD_EXP 11
16363: NOT
16364: IFFALSE 16392
// begin Say ( JMM , D1T-JMM-4 ) ;
16366: LD_EXP 40
16370: PPUSH
16371: LD_STRING D1T-JMM-4
16373: PPUSH
16374: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16378: LD_EXP 60
16382: PPUSH
16383: LD_STRING D1T-Pow-5
16385: PPUSH
16386: CALL_OW 88
// end else
16390: GO 16416
// begin Say ( JMM , D1nT-JMM-1 ) ;
16392: LD_EXP 40
16396: PPUSH
16397: LD_STRING D1nT-JMM-1
16399: PPUSH
16400: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16404: LD_EXP 60
16408: PPUSH
16409: LD_STRING D1nT-Pow-1
16411: PPUSH
16412: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16416: LD_INT 3
16418: PPUSH
16419: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16423: LD_EXP 58
16427: PPUSH
16428: CALL_OW 314
16432: NOT
16433: IFFALSE 16416
// ComExitVehicle ( JMM ) ;
16435: LD_EXP 40
16439: PPUSH
16440: CALL_OW 121
// repeat wait ( 3 ) ;
16444: LD_INT 3
16446: PPUSH
16447: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16451: LD_EXP 40
16455: PPUSH
16456: CALL_OW 310
16460: NOT
16461: IFFALSE 16444
// ComMoveXY ( JMM , 60 , 94 ) ;
16463: LD_EXP 40
16467: PPUSH
16468: LD_INT 60
16470: PPUSH
16471: LD_INT 94
16473: PPUSH
16474: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16478: LD_EXP 40
16482: PPUSH
16483: LD_EXP 60
16487: PPUSH
16488: CALL_OW 179
// if Joan then
16492: LD_EXP 41
16496: IFFALSE 16550
// begin ComExitVehicle ( Joan ) ;
16498: LD_EXP 41
16502: PPUSH
16503: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16507: LD_EXP 41
16511: PPUSH
16512: LD_INT 35
16514: PPUSH
16515: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16519: LD_EXP 41
16523: PPUSH
16524: LD_INT 65
16526: PPUSH
16527: LD_INT 104
16529: PPUSH
16530: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16534: LD_EXP 41
16538: PPUSH
16539: LD_EXP 40
16543: PPUSH
16544: CALL_OW 179
// end else
16548: GO 16684
// if Lisa and JMMGirl = 2 then
16550: LD_EXP 43
16554: PUSH
16555: LD_EXP 7
16559: PUSH
16560: LD_INT 2
16562: EQUAL
16563: AND
16564: IFFALSE 16618
// begin ComExitVehicle ( Lisa ) ;
16566: LD_EXP 43
16570: PPUSH
16571: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16575: LD_EXP 43
16579: PPUSH
16580: LD_INT 35
16582: PPUSH
16583: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16587: LD_EXP 43
16591: PPUSH
16592: LD_INT 65
16594: PPUSH
16595: LD_INT 104
16597: PPUSH
16598: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16602: LD_EXP 43
16606: PPUSH
16607: LD_EXP 40
16611: PPUSH
16612: CALL_OW 179
// end else
16616: GO 16684
// if Connie and JMMGirl = 3 then
16618: LD_EXP 55
16622: PUSH
16623: LD_EXP 7
16627: PUSH
16628: LD_INT 3
16630: EQUAL
16631: AND
16632: IFFALSE 16684
// begin ComExitVehicle ( Connie ) ;
16634: LD_EXP 55
16638: PPUSH
16639: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16643: LD_EXP 55
16647: PPUSH
16648: LD_INT 35
16650: PPUSH
16651: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16655: LD_EXP 55
16659: PPUSH
16660: LD_INT 65
16662: PPUSH
16663: LD_INT 104
16665: PPUSH
16666: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16670: LD_EXP 55
16674: PPUSH
16675: LD_EXP 40
16679: PPUSH
16680: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16684: LD_INT 35
16686: PPUSH
16687: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16691: LD_EXP 40
16695: PPUSH
16696: LD_EXP 60
16700: PPUSH
16701: CALL_OW 296
16705: PUSH
16706: LD_INT 8
16708: LESS
16709: IFFALSE 16684
// wait ( 0 0$0.5 ) ;
16711: LD_INT 18
16713: PPUSH
16714: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16718: LD_EXP 40
16722: PPUSH
16723: LD_STRING D1-JMM-1
16725: PPUSH
16726: CALL_OW 88
// async ;
16730: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16731: LD_EXP 60
16735: PPUSH
16736: LD_STRING D1-Pow-1
16738: PPUSH
16739: CALL_OW 88
// if not dialogue_skipped then
16743: LD_OWVAR 59
16747: NOT
16748: IFFALSE 16757
// wait ( 0 0$2 ) ;
16750: LD_INT 70
16752: PPUSH
16753: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
16757: LD_INT 170
16759: PPUSH
16760: LD_INT 99
16762: PPUSH
16763: LD_INT 1
16765: PPUSH
16766: LD_INT 6
16768: NEG
16769: PPUSH
16770: CALL 104890 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
16774: LD_INT 174
16776: PPUSH
16777: LD_INT 115
16779: PPUSH
16780: LD_INT 1
16782: PPUSH
16783: LD_INT 6
16785: NEG
16786: PPUSH
16787: CALL 104890 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
16791: LD_INT 169
16793: PPUSH
16794: LD_INT 71
16796: PPUSH
16797: LD_INT 1
16799: PPUSH
16800: LD_INT 6
16802: NEG
16803: PPUSH
16804: CALL 104890 0 4
// if not dialogue_skipped then
16808: LD_OWVAR 59
16812: NOT
16813: IFFALSE 16832
// begin CenterOnXY ( 170 , 99 ) ;
16815: LD_INT 170
16817: PPUSH
16818: LD_INT 99
16820: PPUSH
16821: CALL_OW 84
// wait ( 0 0$2.3 ) ;
16825: LD_INT 80
16827: PPUSH
16828: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
16832: LD_INT 75
16834: PPUSH
16835: LD_INT 53
16837: PPUSH
16838: LD_INT 1
16840: PPUSH
16841: LD_INT 9
16843: NEG
16844: PPUSH
16845: CALL 104890 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
16849: LD_INT 54
16851: PPUSH
16852: LD_INT 42
16854: PPUSH
16855: LD_INT 1
16857: PPUSH
16858: LD_INT 9
16860: NEG
16861: PPUSH
16862: CALL 104890 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
16866: LD_INT 62
16868: PPUSH
16869: LD_INT 51
16871: PPUSH
16872: LD_INT 1
16874: PPUSH
16875: LD_INT 9
16877: NEG
16878: PPUSH
16879: CALL 104890 0 4
// if not dialogue_skipped then
16883: LD_OWVAR 59
16887: NOT
16888: IFFALSE 16907
// begin CenterOnXY ( 75 , 53 ) ;
16890: LD_INT 75
16892: PPUSH
16893: LD_INT 53
16895: PPUSH
16896: CALL_OW 84
// wait ( 0 0$4 ) ;
16900: LD_INT 140
16902: PPUSH
16903: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
16907: LD_EXP 60
16911: PPUSH
16912: CALL_OW 87
// if not dialogue_skipped then
16916: LD_OWVAR 59
16920: NOT
16921: IFFALSE 16930
// wait ( 0 0$2 ) ;
16923: LD_INT 70
16925: PPUSH
16926: CALL_OW 67
// sync ;
16930: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16931: LD_EXP 40
16935: PPUSH
16936: LD_STRING D1-JMM-2
16938: PPUSH
16939: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16943: LD_EXP 60
16947: PPUSH
16948: LD_STRING D1-Pow-2
16950: PPUSH
16951: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16955: LD_EXP 40
16959: PPUSH
16960: LD_STRING D1-JMM-3
16962: PPUSH
16963: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16967: LD_EXP 60
16971: PPUSH
16972: LD_STRING D1-Pow-3
16974: PPUSH
16975: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16979: LD_EXP 40
16983: PPUSH
16984: LD_STRING D1-JMM-4
16986: PPUSH
16987: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16991: LD_EXP 60
16995: PPUSH
16996: LD_STRING D1-Pow-4
16998: PPUSH
16999: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
17003: LD_EXP 40
17007: PPUSH
17008: LD_STRING D1-JMM-5
17010: PPUSH
17011: CALL_OW 88
// async ;
17015: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
17016: LD_EXP 60
17020: PPUSH
17021: LD_STRING D1-Pow-5
17023: PPUSH
17024: CALL_OW 88
// if not dialogue_skipped then
17028: LD_OWVAR 59
17032: NOT
17033: IFFALSE 17042
// wait ( 0 0$3.6 ) ;
17035: LD_INT 126
17037: PPUSH
17038: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
17042: LD_INT 134
17044: PPUSH
17045: LD_INT 210
17047: PPUSH
17048: LD_INT 1
17050: PPUSH
17051: LD_INT 11
17053: NEG
17054: PPUSH
17055: CALL 104890 0 4
// if not dialogue_skipped then
17059: LD_OWVAR 59
17063: NOT
17064: IFFALSE 17083
// begin CenterOnXY ( 134 , 210 ) ;
17066: LD_INT 134
17068: PPUSH
17069: LD_INT 210
17071: PPUSH
17072: CALL_OW 84
// wait ( 0 0$2 ) ;
17076: LD_INT 70
17078: PPUSH
17079: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
17083: LD_INT 101
17085: PPUSH
17086: LD_INT 159
17088: PPUSH
17089: LD_INT 1
17091: PPUSH
17092: LD_INT 10
17094: NEG
17095: PPUSH
17096: CALL 104890 0 4
// if not dialogue_skipped then
17100: LD_OWVAR 59
17104: NOT
17105: IFFALSE 17124
// begin CenterOnXY ( 101 , 159 ) ;
17107: LD_INT 101
17109: PPUSH
17110: LD_INT 159
17112: PPUSH
17113: CALL_OW 84
// wait ( 0 0$2 ) ;
17117: LD_INT 70
17119: PPUSH
17120: CALL_OW 67
// end ; sync ;
17124: SYNC
// CenterNowOnUnits ( Powell ) ;
17125: LD_EXP 60
17129: PPUSH
17130: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17134: LD_ADDR_VAR 0 6
17138: PUSH
17139: LD_INT 1
17141: PUSH
17142: LD_INT 2
17144: PUSH
17145: LD_INT 3
17147: PUSH
17148: LD_INT 4
17150: PUSH
17151: LD_INT 5
17153: PUSH
17154: LD_INT 6
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: LIST
17162: LIST
17163: LIST
17164: ST_TO_ADDR
// if not dialogue_skipped then
17165: LD_OWVAR 59
17169: NOT
17170: IFFALSE 17339
// begin game_speed := 4 ;
17172: LD_ADDR_OWVAR 65
17176: PUSH
17177: LD_INT 4
17179: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17180: LD_INT 210
17182: PPUSH
17183: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17187: LD_ADDR_VAR 0 7
17191: PUSH
17192: LD_STRING Q1
17194: PPUSH
17195: LD_VAR 0 6
17199: PPUSH
17200: CALL_OW 98
17204: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17205: LD_ADDR_VAR 0 7
17209: PUSH
17210: LD_STRING Q1
17212: PPUSH
17213: LD_VAR 0 6
17217: PPUSH
17218: CALL_OW 98
17222: ST_TO_ADDR
// options := options diff dec ;
17223: LD_ADDR_VAR 0 6
17227: PUSH
17228: LD_VAR 0 6
17232: PUSH
17233: LD_VAR 0 7
17237: DIFF
17238: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17239: LD_VAR 0 7
17243: PPUSH
17244: LD_VAR 0 6
17248: PPUSH
17249: CALL 18903 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17253: LD_VAR 0 7
17257: PUSH
17258: LD_INT 5
17260: PUSH
17261: LD_INT 6
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: IN
17268: PUSH
17269: LD_VAR 0 6
17273: PUSH
17274: LD_INT 2
17276: EQUAL
17277: OR
17278: IFFALSE 17205
// if not ( dec in [ 5 , 6 ] ) then
17280: LD_VAR 0 7
17284: PUSH
17285: LD_INT 5
17287: PUSH
17288: LD_INT 6
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: IN
17295: NOT
17296: IFFALSE 17339
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17298: LD_ADDR_VAR 0 7
17302: PUSH
17303: LD_STRING Q1a
17305: PPUSH
17306: LD_INT 1
17308: PUSH
17309: LD_INT 2
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PPUSH
17316: CALL_OW 98
17320: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17321: LD_VAR 0 7
17325: PUSH
17326: LD_INT 4
17328: PLUS
17329: PPUSH
17330: LD_VAR 0 6
17334: PPUSH
17335: CALL 18903 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17339: LD_INT 81
17341: PPUSH
17342: LD_INT 127
17344: PPUSH
17345: CALL_OW 84
// amount := 8 ;
17349: LD_ADDR_VAR 0 8
17353: PUSH
17354: LD_INT 8
17356: ST_TO_ADDR
// macmilan_squad := [ ] ;
17357: LD_ADDR_VAR 0 9
17361: PUSH
17362: EMPTY
17363: ST_TO_ADDR
// if vip < amount then
17364: LD_EXP 61
17368: PUSH
17369: LD_VAR 0 8
17373: LESS
17374: IFFALSE 17418
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17376: LD_ADDR_VAR 0 5
17380: PUSH
17381: LD_EXP 61
17385: PUSH
17386: LD_INT 22
17388: PUSH
17389: LD_INT 4
17391: PUSH
17392: EMPTY
17393: LIST
17394: LIST
17395: PUSH
17396: LD_INT 21
17398: PUSH
17399: LD_INT 1
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: PUSH
17406: EMPTY
17407: LIST
17408: LIST
17409: PPUSH
17410: CALL_OW 69
17414: UNION
17415: ST_TO_ADDR
17416: GO 17428
// tmp := vip ;
17418: LD_ADDR_VAR 0 5
17422: PUSH
17423: LD_EXP 61
17427: ST_TO_ADDR
// tmp := tmp diff Powell ;
17428: LD_ADDR_VAR 0 5
17432: PUSH
17433: LD_VAR 0 5
17437: PUSH
17438: LD_EXP 60
17442: DIFF
17443: ST_TO_ADDR
// if tmp < amount then
17444: LD_VAR 0 5
17448: PUSH
17449: LD_VAR 0 8
17453: LESS
17454: IFFALSE 17466
// amount := tmp ;
17456: LD_ADDR_VAR 0 8
17460: PUSH
17461: LD_VAR 0 5
17465: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17466: LD_VAR 0 5
17470: PUSH
17471: LD_INT 1
17473: ARRAY
17474: PPUSH
17475: CALL_OW 257
17479: PUSH
17480: LD_INT 2
17482: NONEQUAL
17483: IFFALSE 17581
// begin if IsInUnit ( tmp [ 1 ] ) then
17485: LD_VAR 0 5
17489: PUSH
17490: LD_INT 1
17492: ARRAY
17493: PPUSH
17494: CALL_OW 310
17498: IFFALSE 17513
// ComExitBuilding ( tmp [ 1 ] ) ;
17500: LD_VAR 0 5
17504: PUSH
17505: LD_INT 1
17507: ARRAY
17508: PPUSH
17509: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17513: LD_INT 387
17515: PPUSH
17516: CALL_OW 313
17520: PUSH
17521: LD_INT 6
17523: EQUAL
17524: IFFALSE 17549
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17526: LD_INT 387
17528: PPUSH
17529: CALL_OW 313
17533: PUSH
17534: LD_INT 1
17536: ARRAY
17537: PPUSH
17538: CALL_OW 122
// wait ( 3 ) ;
17542: LD_INT 3
17544: PPUSH
17545: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17549: LD_VAR 0 5
17553: PUSH
17554: LD_INT 1
17556: ARRAY
17557: PPUSH
17558: LD_INT 387
17560: PPUSH
17561: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17565: LD_VAR 0 5
17569: PUSH
17570: LD_INT 1
17572: ARRAY
17573: PPUSH
17574: LD_INT 2
17576: PPUSH
17577: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17581: LD_EXP 40
17585: PPUSH
17586: LD_INT 82
17588: PPUSH
17589: LD_INT 129
17591: PPUSH
17592: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17596: LD_EXP 40
17600: PPUSH
17601: LD_EXP 60
17605: PPUSH
17606: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17610: LD_INT 22
17612: PUSH
17613: LD_INT 1
17615: PUSH
17616: EMPTY
17617: LIST
17618: LIST
17619: PPUSH
17620: CALL_OW 69
17624: PUSH
17625: LD_EXP 40
17629: DIFF
17630: PPUSH
17631: LD_INT 84
17633: PPUSH
17634: LD_INT 128
17636: PPUSH
17637: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17641: LD_INT 22
17643: PUSH
17644: LD_INT 1
17646: PUSH
17647: EMPTY
17648: LIST
17649: LIST
17650: PPUSH
17651: CALL_OW 69
17655: PUSH
17656: LD_EXP 40
17660: DIFF
17661: PPUSH
17662: LD_EXP 40
17666: PPUSH
17667: CALL_OW 179
// for i = 1 to amount do
17671: LD_ADDR_VAR 0 2
17675: PUSH
17676: DOUBLE
17677: LD_INT 1
17679: DEC
17680: ST_TO_ADDR
17681: LD_VAR 0 8
17685: PUSH
17686: FOR_TO
17687: IFFALSE 17855
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17689: LD_ADDR_VAR 0 9
17693: PUSH
17694: LD_VAR 0 9
17698: PUSH
17699: LD_VAR 0 5
17703: PUSH
17704: LD_VAR 0 2
17708: ARRAY
17709: ADD
17710: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17711: LD_VAR 0 5
17715: PUSH
17716: LD_VAR 0 2
17720: ARRAY
17721: PPUSH
17722: CALL_OW 310
17726: IFFALSE 17743
// AddComExitBuilding ( tmp [ i ] ) ;
17728: LD_VAR 0 5
17732: PUSH
17733: LD_VAR 0 2
17737: ARRAY
17738: PPUSH
17739: CALL_OW 182
// if i = 2 and JMMNewVeh then
17743: LD_VAR 0 2
17747: PUSH
17748: LD_INT 2
17750: EQUAL
17751: PUSH
17752: LD_EXP 58
17756: AND
17757: IFFALSE 17815
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
17759: LD_VAR 0 5
17763: PUSH
17764: LD_VAR 0 2
17768: ARRAY
17769: PPUSH
17770: LD_EXP 58
17774: PPUSH
17775: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
17779: LD_VAR 0 5
17783: PUSH
17784: LD_VAR 0 2
17788: ARRAY
17789: PPUSH
17790: LD_INT 86
17792: PPUSH
17793: LD_INT 133
17795: PPUSH
17796: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 2
17809: ARRAY
17810: PPUSH
17811: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
17815: LD_VAR 0 5
17819: PUSH
17820: LD_VAR 0 2
17824: ARRAY
17825: PPUSH
17826: LD_INT 8
17828: PPUSH
17829: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
17833: LD_VAR 0 5
17837: PUSH
17838: LD_VAR 0 2
17842: ARRAY
17843: PPUSH
17844: LD_EXP 40
17848: PPUSH
17849: CALL_OW 179
// end ;
17853: GO 17686
17855: POP
17856: POP
// if GirlNewVeh then
17857: LD_EXP 59
17861: IFFALSE 17875
// SetSide ( GirlNewVeh , 4 ) ;
17863: LD_EXP 59
17867: PPUSH
17868: LD_INT 4
17870: PPUSH
17871: CALL_OW 235
// if Mike then
17875: LD_EXP 57
17879: IFFALSE 17916
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
17881: LD_ADDR_VAR 0 9
17885: PUSH
17886: LD_VAR 0 9
17890: PPUSH
17891: LD_EXP 57
17895: PPUSH
17896: CALL 105004 0 2
17900: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
17901: LD_EXP 57
17905: PPUSH
17906: LD_INT 86
17908: PPUSH
17909: LD_INT 133
17911: PPUSH
17912: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
17916: LD_INT 35
17918: PPUSH
17919: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
17923: LD_VAR 0 9
17927: PPUSH
17928: LD_INT 95
17930: PUSH
17931: LD_INT 9
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: PPUSH
17938: CALL_OW 72
17942: PUSH
17943: LD_INT 0
17945: EQUAL
17946: PUSH
17947: LD_EXP 40
17951: PPUSH
17952: LD_INT 9
17954: PPUSH
17955: CALL_OW 308
17959: NOT
17960: AND
17961: IFFALSE 17916
// wait ( 0 0$2 ) ;
17963: LD_INT 70
17965: PPUSH
17966: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
17970: LD_VAR 0 9
17974: PPUSH
17975: LD_INT 1
17977: PPUSH
17978: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
17982: LD_INT 21
17984: PUSH
17985: LD_INT 2
17987: PUSH
17988: EMPTY
17989: LIST
17990: LIST
17991: PUSH
17992: LD_INT 92
17994: PUSH
17995: LD_INT 83
17997: PUSH
17998: LD_INT 130
18000: PUSH
18001: LD_INT 10
18003: PUSH
18004: EMPTY
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: PUSH
18010: EMPTY
18011: LIST
18012: LIST
18013: PPUSH
18014: CALL_OW 69
18018: PPUSH
18019: LD_INT 1
18021: PPUSH
18022: CALL_OW 235
// tick := 0 ;
18026: LD_ADDR_OWVAR 1
18030: PUSH
18031: LD_INT 0
18033: ST_TO_ADDR
// Video ( false ) ;
18034: LD_INT 0
18036: PPUSH
18037: CALL 104976 0 1
// ChangeMissionObjectives ( M1 ) ;
18041: LD_STRING M1
18043: PPUSH
18044: CALL_OW 337
// SaveForQuickRestart ;
18048: CALL_OW 22
// missionStart := true ;
18052: LD_ADDR_EXP 13
18056: PUSH
18057: LD_INT 1
18059: ST_TO_ADDR
// missionStage := 2 ;
18060: LD_ADDR_EXP 15
18064: PUSH
18065: LD_INT 2
18067: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18068: LD_INT 35
18070: PPUSH
18071: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
18075: LD_ADDR_VAR 0 5
18079: PUSH
18080: LD_INT 22
18082: PUSH
18083: LD_INT 4
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: PUSH
18090: LD_INT 21
18092: PUSH
18093: LD_INT 1
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: PPUSH
18104: CALL_OW 69
18108: PUSH
18109: LD_EXP 60
18113: DIFF
18114: ST_TO_ADDR
// if not tmp then
18115: LD_VAR 0 5
18119: NOT
18120: IFFALSE 18135
// tmp := [ Powell ] ;
18122: LD_ADDR_VAR 0 5
18126: PUSH
18127: LD_EXP 60
18131: PUSH
18132: EMPTY
18133: LIST
18134: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
18135: LD_ADDR_VAR 0 4
18139: PUSH
18140: LD_INT 22
18142: PUSH
18143: LD_INT 4
18145: PUSH
18146: EMPTY
18147: LIST
18148: LIST
18149: PUSH
18150: LD_INT 34
18152: PUSH
18153: LD_INT 12
18155: PUSH
18156: EMPTY
18157: LIST
18158: LIST
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PPUSH
18164: CALL_OW 69
18168: PUSH
18169: LD_INT 1
18171: ARRAY
18172: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18173: LD_VAR 0 5
18177: PUSH
18178: LD_INT 1
18180: ARRAY
18181: PPUSH
18182: CALL_OW 310
18186: IFFALSE 18201
// ComExitBuilding ( tmp [ 1 ] ) ;
18188: LD_VAR 0 5
18192: PUSH
18193: LD_INT 1
18195: ARRAY
18196: PPUSH
18197: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18201: LD_VAR 0 5
18205: PUSH
18206: LD_INT 1
18208: ARRAY
18209: PPUSH
18210: LD_VAR 0 4
18214: PPUSH
18215: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18219: LD_VAR 0 5
18223: PUSH
18224: LD_INT 1
18226: ARRAY
18227: PPUSH
18228: LD_INT 80
18230: PPUSH
18231: LD_INT 136
18233: PPUSH
18234: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18238: LD_VAR 0 5
18242: PUSH
18243: LD_INT 1
18245: ARRAY
18246: PPUSH
18247: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18251: LD_VAR 0 5
18255: PUSH
18256: LD_INT 1
18258: ARRAY
18259: PPUSH
18260: LD_INT 59
18262: PPUSH
18263: LD_INT 112
18265: PPUSH
18266: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18270: LD_VAR 0 5
18274: PUSH
18275: LD_INT 1
18277: ARRAY
18278: PPUSH
18279: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18283: LD_EXP 41
18287: PUSH
18288: LD_EXP 41
18292: PPUSH
18293: CALL_OW 255
18297: PUSH
18298: LD_INT 1
18300: EQUAL
18301: AND
18302: IFFALSE 18328
// begin Say ( Joan , D3W-Joan-1 ) ;
18304: LD_EXP 41
18308: PPUSH
18309: LD_STRING D3W-Joan-1
18311: PPUSH
18312: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18316: LD_EXP 40
18320: PPUSH
18321: LD_STRING D3W-JMM-1
18323: PPUSH
18324: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18328: LD_EXP 43
18332: PUSH
18333: LD_EXP 43
18337: PPUSH
18338: CALL_OW 255
18342: PUSH
18343: LD_INT 1
18345: EQUAL
18346: AND
18347: PUSH
18348: LD_EXP 43
18352: PUSH
18353: LD_EXP 61
18357: IN
18358: NOT
18359: AND
18360: IFFALSE 18386
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18362: LD_EXP 43
18366: PPUSH
18367: LD_STRING D3W-Lisa-1
18369: PPUSH
18370: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18374: LD_EXP 40
18378: PPUSH
18379: LD_STRING D3W-JMM-1
18381: PPUSH
18382: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18386: LD_EXP 55
18390: PUSH
18391: LD_EXP 55
18395: PPUSH
18396: CALL_OW 255
18400: PUSH
18401: LD_INT 1
18403: EQUAL
18404: AND
18405: IFFALSE 18431
// begin Say ( Connie , D3W-Con-1 ) ;
18407: LD_EXP 55
18411: PPUSH
18412: LD_STRING D3W-Con-1
18414: PPUSH
18415: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18419: LD_EXP 40
18423: PPUSH
18424: LD_STRING D3W-JMM-1
18426: PPUSH
18427: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
18431: LD_INT 18
18433: PPUSH
18434: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
18438: LD_EXP 43
18442: PUSH
18443: LD_EXP 61
18447: IN
18448: PUSH
18449: LD_EXP 43
18453: PPUSH
18454: CALL_OW 255
18458: PUSH
18459: LD_INT 1
18461: EQUAL
18462: AND
18463: IFFALSE 18479
// Say ( Lisa , D3nW-Lisa-1 ) else
18465: LD_EXP 43
18469: PPUSH
18470: LD_STRING D3nW-Lisa-1
18472: PPUSH
18473: CALL_OW 88
18477: GO 18723
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18479: LD_EXP 46
18483: PUSH
18484: LD_EXP 61
18488: IN
18489: PUSH
18490: LD_EXP 46
18494: PPUSH
18495: CALL_OW 255
18499: PUSH
18500: LD_INT 1
18502: EQUAL
18503: AND
18504: IFFALSE 18520
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18506: LD_EXP 46
18510: PPUSH
18511: LD_STRING D3nW-Cyrus-1
18513: PPUSH
18514: CALL_OW 88
18518: GO 18723
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18520: LD_EXP 45
18524: PUSH
18525: LD_EXP 61
18529: IN
18530: PUSH
18531: LD_EXP 45
18535: PPUSH
18536: CALL_OW 255
18540: PUSH
18541: LD_INT 1
18543: EQUAL
18544: AND
18545: IFFALSE 18561
// Say ( Bobby , D3nW-Bobby-1 ) else
18547: LD_EXP 45
18551: PPUSH
18552: LD_STRING D3nW-Bobby-1
18554: PPUSH
18555: CALL_OW 88
18559: GO 18723
// if Gary in vip and GetSide ( Gary ) = 1 then
18561: LD_EXP 52
18565: PUSH
18566: LD_EXP 61
18570: IN
18571: PUSH
18572: LD_EXP 52
18576: PPUSH
18577: CALL_OW 255
18581: PUSH
18582: LD_INT 1
18584: EQUAL
18585: AND
18586: IFFALSE 18602
// Say ( Gary , D3nW-Gary-1 ) else
18588: LD_EXP 52
18592: PPUSH
18593: LD_STRING D3nW-Gary-1
18595: PPUSH
18596: CALL_OW 88
18600: GO 18723
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18602: LD_EXP 44
18606: PUSH
18607: LD_EXP 61
18611: IN
18612: PUSH
18613: LD_EXP 44
18617: PPUSH
18618: CALL_OW 255
18622: PUSH
18623: LD_INT 1
18625: EQUAL
18626: AND
18627: IFFALSE 18643
// Say ( Donaldson , D3nW-Don-1 ) else
18629: LD_EXP 44
18633: PPUSH
18634: LD_STRING D3nW-Don-1
18636: PPUSH
18637: CALL_OW 88
18641: GO 18723
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18643: LD_EXP 51
18647: PUSH
18648: LD_EXP 61
18652: IN
18653: PUSH
18654: LD_EXP 51
18658: PPUSH
18659: CALL_OW 255
18663: PUSH
18664: LD_INT 1
18666: EQUAL
18667: AND
18668: IFFALSE 18684
// Say ( Cornel , D3nW-Corn-1 ) else
18670: LD_EXP 51
18674: PPUSH
18675: LD_STRING D3nW-Corn-1
18677: PPUSH
18678: CALL_OW 88
18682: GO 18723
// if Frank in vip and GetSide ( Frank ) = 1 then
18684: LD_EXP 53
18688: PUSH
18689: LD_EXP 61
18693: IN
18694: PUSH
18695: LD_EXP 53
18699: PPUSH
18700: CALL_OW 255
18704: PUSH
18705: LD_INT 1
18707: EQUAL
18708: AND
18709: IFFALSE 18723
// Say ( Frank , D3nW-Frank-1 ) ;
18711: LD_EXP 53
18715: PPUSH
18716: LD_STRING D3nW-Frank-1
18718: PPUSH
18719: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18723: LD_EXP 61
18727: PPUSH
18728: LD_INT 22
18730: PUSH
18731: LD_INT 1
18733: PUSH
18734: EMPTY
18735: LIST
18736: LIST
18737: PPUSH
18738: CALL_OW 72
18742: IFFALSE 18768
// begin Say ( JMM , D3nW-JMM-1 ) ;
18744: LD_EXP 40
18748: PPUSH
18749: LD_STRING D3nW-JMM-1
18751: PPUSH
18752: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
18756: LD_EXP 40
18760: PPUSH
18761: LD_STRING D3nW-JMM-1a
18763: PPUSH
18764: CALL_OW 88
// end ; t := 0 0$00 ;
18768: LD_ADDR_VAR 0 3
18772: PUSH
18773: LD_INT 0
18775: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18776: LD_INT 35
18778: PPUSH
18779: CALL_OW 67
// t := t + 0 0$1 ;
18783: LD_ADDR_VAR 0 3
18787: PUSH
18788: LD_VAR 0 3
18792: PUSH
18793: LD_INT 35
18795: PLUS
18796: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
18797: LD_INT 59
18799: PPUSH
18800: LD_INT 112
18802: PPUSH
18803: CALL_OW 428
18807: PUSH
18808: LD_VAR 0 3
18812: PUSH
18813: LD_INT 2100
18815: GREATER
18816: OR
18817: IFFALSE 18776
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
18819: LD_ADDR_EXP 100
18823: PUSH
18824: LD_EXP 100
18828: PPUSH
18829: LD_INT 4
18831: PPUSH
18832: LD_INT 22
18834: PUSH
18835: LD_INT 4
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: PUSH
18842: LD_INT 23
18844: PUSH
18845: LD_INT 1
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: PUSH
18852: LD_INT 3
18854: PUSH
18855: LD_INT 21
18857: PUSH
18858: LD_INT 2
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: PUSH
18869: EMPTY
18870: LIST
18871: LIST
18872: LIST
18873: PPUSH
18874: CALL_OW 69
18878: PUSH
18879: LD_EXP 60
18883: DIFF
18884: PPUSH
18885: CALL_OW 1
18889: ST_TO_ADDR
// activeAttacks := true ;
18890: LD_ADDR_EXP 16
18894: PUSH
18895: LD_INT 1
18897: ST_TO_ADDR
// end ;
18898: LD_VAR 0 1
18902: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
18903: LD_INT 0
18905: PPUSH
// case question of 1 :
18906: LD_VAR 0 1
18910: PUSH
18911: LD_INT 1
18913: DOUBLE
18914: EQUAL
18915: IFTRUE 18919
18917: GO 18970
18919: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
18920: LD_EXP 40
18924: PPUSH
18925: LD_STRING D2Mot-JMM-1
18927: PPUSH
18928: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
18932: LD_EXP 60
18936: PPUSH
18937: LD_STRING D2Mot-Pow-1
18939: PPUSH
18940: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
18944: LD_EXP 40
18948: PPUSH
18949: LD_STRING D2Mot-JMM-2
18951: PPUSH
18952: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
18956: LD_EXP 60
18960: PPUSH
18961: LD_STRING D2Mot-Pow-2
18963: PPUSH
18964: CALL_OW 88
// end ; 2 :
18968: GO 19321
18970: LD_INT 2
18972: DOUBLE
18973: EQUAL
18974: IFTRUE 18978
18976: GO 19054
18978: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
18979: LD_EXP 40
18983: PPUSH
18984: LD_STRING D2Rus-JMM-1
18986: PPUSH
18987: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
18991: LD_EXP 60
18995: PPUSH
18996: LD_STRING D2Rus-Pow-1
18998: PPUSH
18999: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
19003: LD_EXP 40
19007: PPUSH
19008: LD_STRING D2Rus-JMM-2
19010: PPUSH
19011: CALL_OW 88
// if not ( 3 in list_of_q ) then
19015: LD_INT 3
19017: PUSH
19018: LD_VAR 0 2
19022: IN
19023: NOT
19024: IFFALSE 19040
// Say ( Powell , D2Rus-Pow-2 ) else
19026: LD_EXP 60
19030: PPUSH
19031: LD_STRING D2Rus-Pow-2
19033: PPUSH
19034: CALL_OW 88
19038: GO 19052
// Say ( Powell , D2Rus-Pow-2a ) ;
19040: LD_EXP 60
19044: PPUSH
19045: LD_STRING D2Rus-Pow-2a
19047: PPUSH
19048: CALL_OW 88
// end ; 3 :
19052: GO 19321
19054: LD_INT 3
19056: DOUBLE
19057: EQUAL
19058: IFTRUE 19062
19060: GO 19147
19062: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
19063: LD_EXP 40
19067: PPUSH
19068: LD_STRING D2Leg-JMM-1
19070: PPUSH
19071: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
19075: LD_EXP 60
19079: PPUSH
19080: LD_STRING D2Leg-Pow-1
19082: PPUSH
19083: CALL_OW 88
// if 2 in list_of_q then
19087: LD_INT 2
19089: PUSH
19090: LD_VAR 0 2
19094: IN
19095: IFFALSE 19121
// begin Say ( JMM , D2Leg-JMM-2 ) ;
19097: LD_EXP 40
19101: PPUSH
19102: LD_STRING D2Leg-JMM-2
19104: PPUSH
19105: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
19109: LD_EXP 60
19113: PPUSH
19114: LD_STRING D2Leg-Pow-2
19116: PPUSH
19117: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
19121: LD_EXP 40
19125: PPUSH
19126: LD_STRING D2Leg-JMM-3
19128: PPUSH
19129: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
19133: LD_EXP 60
19137: PPUSH
19138: LD_STRING D2Leg-Pow-3
19140: PPUSH
19141: CALL_OW 88
// end ; 4 :
19145: GO 19321
19147: LD_INT 4
19149: DOUBLE
19150: EQUAL
19151: IFTRUE 19155
19153: GO 19230
19155: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
19156: LD_EXP 40
19160: PPUSH
19161: LD_STRING D2Ar-JMM-1
19163: PPUSH
19164: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
19168: LD_EXP 60
19172: PPUSH
19173: LD_STRING D2Ar-Pow-1
19175: PPUSH
19176: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19180: LD_EXP 40
19184: PPUSH
19185: LD_STRING D2Ar-JMM-2
19187: PPUSH
19188: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19192: LD_EXP 60
19196: PPUSH
19197: LD_STRING D2Ar-Pow-2
19199: PPUSH
19200: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19204: LD_EXP 40
19208: PPUSH
19209: LD_STRING D2Ar-JMM-3
19211: PPUSH
19212: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19216: LD_EXP 60
19220: PPUSH
19221: LD_STRING D2Ar-Pow-3
19223: PPUSH
19224: CALL_OW 88
// end ; 5 :
19228: GO 19321
19230: LD_INT 5
19232: DOUBLE
19233: EQUAL
19234: IFTRUE 19238
19236: GO 19253
19238: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19239: LD_EXP 40
19243: PPUSH
19244: LD_STRING D2Conf-JMM-1
19246: PPUSH
19247: CALL_OW 88
19251: GO 19321
19253: LD_INT 6
19255: DOUBLE
19256: EQUAL
19257: IFTRUE 19261
19259: GO 19320
19261: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19262: LD_EXP 40
19266: PPUSH
19267: LD_STRING D2Com-JMM-1
19269: PPUSH
19270: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19274: LD_EXP 60
19278: PPUSH
19279: LD_STRING D2Com-Pow-1
19281: PPUSH
19282: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19286: LD_EXP 40
19290: PPUSH
19291: LD_STRING D2Com-JMM-2
19293: PPUSH
19294: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19298: LD_EXP 60
19302: PPUSH
19303: LD_STRING D2Com-Pow-2
19305: PPUSH
19306: CALL_OW 88
// powellAngerQuery := true ;
19310: LD_ADDR_EXP 36
19314: PUSH
19315: LD_INT 1
19317: ST_TO_ADDR
// end ; end ;
19318: GO 19321
19320: POP
// end ;
19321: LD_VAR 0 3
19325: RET
// every 0 0$5 trigger missionStart do var tmp ;
19326: LD_EXP 13
19330: IFFALSE 19613
19332: GO 19334
19334: DISABLE
19335: LD_INT 0
19337: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19338: LD_INT 35
19340: PPUSH
19341: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19345: LD_INT 14
19347: PPUSH
19348: LD_INT 22
19350: PUSH
19351: LD_INT 1
19353: PUSH
19354: EMPTY
19355: LIST
19356: LIST
19357: PPUSH
19358: CALL_OW 70
19362: PUSH
19363: LD_EXP 15
19367: PUSH
19368: LD_INT 2
19370: PUSH
19371: LD_INT 3
19373: PUSH
19374: LD_INT 4
19376: PUSH
19377: LD_INT 5
19379: PUSH
19380: EMPTY
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: IN
19386: AND
19387: IFFALSE 19603
// begin powellAnger := powellAnger + 1 ;
19389: LD_ADDR_EXP 17
19393: PUSH
19394: LD_EXP 17
19398: PUSH
19399: LD_INT 1
19401: PLUS
19402: ST_TO_ADDR
// Video ( true ) ;
19403: LD_INT 1
19405: PPUSH
19406: CALL 104976 0 1
// CenterNowOnUnits ( tmp ) ;
19410: LD_VAR 0 1
19414: PPUSH
19415: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19419: LD_INT 14
19421: PPUSH
19422: LD_INT 22
19424: PUSH
19425: LD_INT 1
19427: PUSH
19428: EMPTY
19429: LIST
19430: LIST
19431: PPUSH
19432: CALL_OW 70
19436: PPUSH
19437: LD_INT 86
19439: PPUSH
19440: LD_INT 133
19442: PPUSH
19443: CALL_OW 111
// async ;
19447: ASYNC
// case powellAnger of 1 :
19448: LD_EXP 17
19452: PUSH
19453: LD_INT 1
19455: DOUBLE
19456: EQUAL
19457: IFTRUE 19461
19459: GO 19476
19461: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19462: LD_EXP 60
19466: PPUSH
19467: LD_STRING DBack1-Pow-1
19469: PPUSH
19470: CALL_OW 88
19474: GO 19523
19476: LD_INT 2
19478: DOUBLE
19479: EQUAL
19480: IFTRUE 19484
19482: GO 19499
19484: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19485: LD_EXP 60
19489: PPUSH
19490: LD_STRING DBack2-Pow-1
19492: PPUSH
19493: CALL_OW 88
19497: GO 19523
19499: LD_INT 3
19501: DOUBLE
19502: EQUAL
19503: IFTRUE 19507
19505: GO 19522
19507: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19508: LD_EXP 60
19512: PPUSH
19513: LD_STRING DBack3-Pow-1
19515: PPUSH
19516: CALL_OW 88
19520: GO 19523
19522: POP
// sync ;
19523: SYNC
// repeat wait ( 0 0$1 ) ;
19524: LD_INT 35
19526: PPUSH
19527: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19531: LD_INT 14
19533: PPUSH
19534: LD_INT 22
19536: PUSH
19537: LD_INT 1
19539: PUSH
19540: EMPTY
19541: LIST
19542: LIST
19543: PPUSH
19544: CALL_OW 70
19548: PPUSH
19549: LD_INT 86
19551: PPUSH
19552: LD_INT 133
19554: PPUSH
19555: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19559: LD_INT 14
19561: PPUSH
19562: LD_INT 22
19564: PUSH
19565: LD_INT 1
19567: PUSH
19568: EMPTY
19569: LIST
19570: LIST
19571: PPUSH
19572: CALL_OW 70
19576: NOT
19577: IFFALSE 19524
// if powellAnger >= 3 then
19579: LD_EXP 17
19583: PUSH
19584: LD_INT 3
19586: GREATEREQUAL
19587: IFFALSE 19596
// YouLost ( Dismissed ) ;
19589: LD_STRING Dismissed
19591: PPUSH
19592: CALL_OW 104
// Video ( false ) ;
19596: LD_INT 0
19598: PPUSH
19599: CALL 104976 0 1
// end ; until missionStage > 5 ;
19603: LD_EXP 15
19607: PUSH
19608: LD_INT 5
19610: GREATER
19611: IFFALSE 19338
// end ;
19613: PPOPN 1
19615: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19616: LD_EXP 13
19620: PUSH
19621: LD_INT 22
19623: PUSH
19624: LD_INT 4
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: PUSH
19631: LD_INT 21
19633: PUSH
19634: LD_INT 2
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: PUSH
19641: EMPTY
19642: LIST
19643: LIST
19644: PPUSH
19645: CALL_OW 69
19649: PUSH
19650: LD_INT 4
19652: GREATEREQUAL
19653: AND
19654: PUSH
19655: LD_EXP 15
19659: PUSH
19660: LD_INT 2
19662: EQUAL
19663: AND
19664: IFFALSE 21854
19666: GO 19668
19668: DISABLE
19669: LD_INT 0
19671: PPUSH
19672: PPUSH
19673: PPUSH
19674: PPUSH
19675: PPUSH
19676: PPUSH
19677: PPUSH
19678: PPUSH
19679: PPUSH
19680: PPUSH
// begin missionStage := 3 ;
19681: LD_ADDR_EXP 15
19685: PUSH
19686: LD_INT 3
19688: ST_TO_ADDR
// retreat := false ;
19689: LD_ADDR_VAR 0 4
19693: PUSH
19694: LD_INT 0
19696: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19697: LD_ADDR_VAR 0 5
19701: PUSH
19702: LD_INT 22
19704: PUSH
19705: LD_INT 4
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: PUSH
19712: LD_INT 30
19714: PUSH
19715: LD_INT 4
19717: PUSH
19718: EMPTY
19719: LIST
19720: LIST
19721: PUSH
19722: EMPTY
19723: LIST
19724: LIST
19725: PPUSH
19726: CALL_OW 69
19730: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19731: LD_ADDR_VAR 0 6
19735: PUSH
19736: LD_INT 22
19738: PUSH
19739: LD_INT 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 30
19748: PUSH
19749: LD_INT 5
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: ST_TO_ADDR
// if not bar then
19765: LD_VAR 0 6
19769: NOT
19770: IFFALSE 19823
// begin repeat wait ( 0 0$1 ) ;
19772: LD_INT 35
19774: PPUSH
19775: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
19779: LD_INT 22
19781: PUSH
19782: LD_INT 4
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 3
19791: PUSH
19792: LD_INT 57
19794: PUSH
19795: EMPTY
19796: LIST
19797: PUSH
19798: EMPTY
19799: LIST
19800: LIST
19801: PUSH
19802: LD_INT 30
19804: PUSH
19805: LD_INT 5
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: LIST
19816: PPUSH
19817: CALL_OW 69
19821: IFFALSE 19772
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19823: LD_ADDR_VAR 0 6
19827: PUSH
19828: LD_INT 22
19830: PUSH
19831: LD_INT 4
19833: PUSH
19834: EMPTY
19835: LIST
19836: LIST
19837: PUSH
19838: LD_INT 30
19840: PUSH
19841: LD_INT 5
19843: PUSH
19844: EMPTY
19845: LIST
19846: LIST
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: PPUSH
19852: CALL_OW 69
19856: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19857: LD_INT 35
19859: PPUSH
19860: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
19864: LD_EXP 119
19868: PUSH
19869: LD_INT 4
19871: ARRAY
19872: PUSH
19873: LD_INT 4
19875: GREATEREQUAL
19876: IFFALSE 19857
// tmp := [ ] ;
19878: LD_ADDR_VAR 0 2
19882: PUSH
19883: EMPTY
19884: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
19885: LD_ADDR_VAR 0 1
19889: PUSH
19890: LD_INT 22
19892: PUSH
19893: LD_INT 4
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: PUSH
19900: LD_INT 2
19902: PUSH
19903: LD_INT 25
19905: PUSH
19906: LD_INT 1
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 25
19915: PUSH
19916: LD_INT 2
19918: PUSH
19919: EMPTY
19920: LIST
19921: LIST
19922: PUSH
19923: LD_INT 25
19925: PUSH
19926: LD_INT 3
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: PUSH
19933: LD_INT 25
19935: PUSH
19936: LD_INT 4
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: PUSH
19943: LD_INT 25
19945: PUSH
19946: LD_INT 5
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: PUSH
19961: EMPTY
19962: LIST
19963: LIST
19964: PPUSH
19965: CALL_OW 69
19969: PUSH
19970: LD_EXP 60
19974: PUSH
19975: LD_EXP 61
19979: ADD
19980: DIFF
19981: PUSH
19982: FOR_IN
19983: IFFALSE 20047
// if GetTag ( i ) = 1 then
19985: LD_VAR 0 1
19989: PPUSH
19990: CALL_OW 110
19994: PUSH
19995: LD_INT 1
19997: EQUAL
19998: IFFALSE 20022
// tmp := Join ( tmp , i ) else
20000: LD_ADDR_VAR 0 2
20004: PUSH
20005: LD_VAR 0 2
20009: PPUSH
20010: LD_VAR 0 1
20014: PPUSH
20015: CALL 105004 0 2
20019: ST_TO_ADDR
20020: GO 20045
// tmp := Insert ( tmp , 1 , i ) ;
20022: LD_ADDR_VAR 0 2
20026: PUSH
20027: LD_VAR 0 2
20031: PPUSH
20032: LD_INT 1
20034: PPUSH
20035: LD_VAR 0 1
20039: PPUSH
20040: CALL_OW 2
20044: ST_TO_ADDR
20045: GO 19982
20047: POP
20048: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
20049: LD_ADDR_VAR 0 3
20053: PUSH
20054: LD_VAR 0 2
20058: PPUSH
20059: LD_INT 26
20061: PUSH
20062: LD_INT 1
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: PPUSH
20069: CALL_OW 72
20073: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
20074: LD_ADDR_VAR 0 2
20078: PUSH
20079: LD_VAR 0 2
20083: PUSH
20084: LD_VAR 0 3
20088: DIFF
20089: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
20090: LD_ADDR_VAR 0 2
20094: PUSH
20095: LD_VAR 0 2
20099: PPUSH
20100: LD_INT 3
20102: PPUSH
20103: CALL 103520 0 2
20107: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_VAR 0 3
20117: PPUSH
20118: LD_INT 3
20120: PPUSH
20121: CALL 103520 0 2
20125: ST_TO_ADDR
// for i := 1 to 4 do
20126: LD_ADDR_VAR 0 1
20130: PUSH
20131: DOUBLE
20132: LD_INT 1
20134: DEC
20135: ST_TO_ADDR
20136: LD_INT 4
20138: PUSH
20139: FOR_TO
20140: IFFALSE 20293
// begin if tmp2 then
20142: LD_VAR 0 3
20146: IFFALSE 20214
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
20148: LD_ADDR_EXP 18
20152: PUSH
20153: LD_EXP 18
20157: PPUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_EXP 18
20165: PUSH
20166: LD_INT 1
20168: ARRAY
20169: PUSH
20170: LD_VAR 0 3
20174: PUSH
20175: LD_VAR 0 3
20179: ARRAY
20180: ADD
20181: PPUSH
20182: CALL_OW 1
20186: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20187: LD_VAR 0 3
20191: PUSH
20192: LD_VAR 0 3
20196: ARRAY
20197: PPUSH
20198: LD_INT 1
20200: PPUSH
20201: CALL_OW 109
// tmp2 := [ ] ;
20205: LD_ADDR_VAR 0 3
20209: PUSH
20210: EMPTY
20211: ST_TO_ADDR
// end else
20212: GO 20291
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20214: LD_ADDR_EXP 18
20218: PUSH
20219: LD_EXP 18
20223: PPUSH
20224: LD_INT 1
20226: PPUSH
20227: LD_EXP 18
20231: PUSH
20232: LD_INT 1
20234: ARRAY
20235: PUSH
20236: LD_VAR 0 2
20240: PUSH
20241: LD_VAR 0 2
20245: ARRAY
20246: ADD
20247: PPUSH
20248: CALL_OW 1
20252: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20253: LD_VAR 0 2
20257: PUSH
20258: LD_VAR 0 2
20262: ARRAY
20263: PPUSH
20264: LD_INT 1
20266: PPUSH
20267: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20271: LD_ADDR_VAR 0 2
20275: PUSH
20276: LD_VAR 0 2
20280: PPUSH
20281: LD_VAR 0 2
20285: PPUSH
20286: CALL_OW 3
20290: ST_TO_ADDR
// end ; end ;
20291: GO 20139
20293: POP
20294: POP
// if tmp2 then
20295: LD_VAR 0 3
20299: IFFALSE 20317
// tmp := tmp union tmp2 ;
20301: LD_ADDR_VAR 0 2
20305: PUSH
20306: LD_VAR 0 2
20310: PUSH
20311: LD_VAR 0 3
20315: UNION
20316: ST_TO_ADDR
// for i := 1 to 4 do
20317: LD_ADDR_VAR 0 1
20321: PUSH
20322: DOUBLE
20323: LD_INT 1
20325: DEC
20326: ST_TO_ADDR
20327: LD_INT 4
20329: PUSH
20330: FOR_TO
20331: IFFALSE 20380
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20333: LD_ADDR_EXP 18
20337: PUSH
20338: LD_EXP 18
20342: PPUSH
20343: LD_INT 2
20345: PPUSH
20346: LD_EXP 18
20350: PUSH
20351: LD_INT 2
20353: ARRAY
20354: PUSH
20355: LD_VAR 0 2
20359: PUSH
20360: LD_VAR 0 2
20364: PUSH
20365: LD_VAR 0 1
20369: MINUS
20370: ARRAY
20371: ADD
20372: PPUSH
20373: CALL_OW 1
20377: ST_TO_ADDR
20378: GO 20330
20380: POP
20381: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20382: LD_ADDR_EXP 100
20386: PUSH
20387: LD_EXP 100
20391: PPUSH
20392: LD_INT 4
20394: PPUSH
20395: LD_EXP 100
20399: PUSH
20400: LD_INT 4
20402: ARRAY
20403: PUSH
20404: LD_EXP 18
20408: PUSH
20409: LD_INT 1
20411: ARRAY
20412: DIFF
20413: PPUSH
20414: CALL_OW 1
20418: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20419: LD_VAR 0 5
20423: PUSH
20424: LD_INT 1
20426: ARRAY
20427: PPUSH
20428: CALL_OW 313
20432: IFFALSE 20487
// begin for i in UnitsInside ( arm [ 1 ] ) do
20434: LD_ADDR_VAR 0 1
20438: PUSH
20439: LD_VAR 0 5
20443: PUSH
20444: LD_INT 1
20446: ARRAY
20447: PPUSH
20448: CALL_OW 313
20452: PUSH
20453: FOR_IN
20454: IFFALSE 20485
// begin ComExitBuilding ( i ) ;
20456: LD_VAR 0 1
20460: PPUSH
20461: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20465: LD_VAR 0 1
20469: PPUSH
20470: LD_VAR 0 6
20474: PUSH
20475: LD_INT 1
20477: ARRAY
20478: PPUSH
20479: CALL_OW 180
// end ;
20483: GO 20453
20485: POP
20486: POP
// end ; wait ( 0 0$3 ) ;
20487: LD_INT 105
20489: PPUSH
20490: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20494: LD_ADDR_VAR 0 1
20498: PUSH
20499: LD_EXP 18
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: PUSH
20508: FOR_IN
20509: IFFALSE 20616
// begin if IsInUnit ( i ) then
20511: LD_VAR 0 1
20515: PPUSH
20516: CALL_OW 310
20520: IFFALSE 20531
// ComExitBuilding ( i ) ;
20522: LD_VAR 0 1
20526: PPUSH
20527: CALL_OW 122
// if GetClass ( i ) <> 1 then
20531: LD_VAR 0 1
20535: PPUSH
20536: CALL_OW 257
20540: PUSH
20541: LD_INT 1
20543: NONEQUAL
20544: IFFALSE 20585
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20546: LD_VAR 0 1
20550: PPUSH
20551: LD_VAR 0 5
20555: PUSH
20556: LD_INT 1
20558: ARRAY
20559: PPUSH
20560: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20564: LD_VAR 0 1
20568: PPUSH
20569: LD_INT 1
20571: PPUSH
20572: CALL_OW 183
// AddComExitBuilding ( i ) ;
20576: LD_VAR 0 1
20580: PPUSH
20581: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20585: LD_VAR 0 1
20589: PPUSH
20590: LD_INT 60
20592: PPUSH
20593: LD_INT 94
20595: PPUSH
20596: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20600: LD_VAR 0 1
20604: PPUSH
20605: LD_EXP 60
20609: PPUSH
20610: CALL_OW 179
// end ;
20614: GO 20508
20616: POP
20617: POP
// wait ( 0 0$10 ) ;
20618: LD_INT 350
20620: PPUSH
20621: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20625: LD_EXP 60
20629: PPUSH
20630: LD_STRING D4-Pow-1
20632: PPUSH
20633: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20637: LD_ADDR_VAR 0 2
20641: PUSH
20642: LD_EXP 18
20646: PUSH
20647: LD_INT 1
20649: ARRAY
20650: PPUSH
20651: LD_INT 26
20653: PUSH
20654: LD_INT 1
20656: PUSH
20657: EMPTY
20658: LIST
20659: LIST
20660: PPUSH
20661: CALL_OW 72
20665: ST_TO_ADDR
// if tmp then
20666: LD_VAR 0 2
20670: IFFALSE 20688
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20672: LD_VAR 0 2
20676: PUSH
20677: LD_INT 1
20679: ARRAY
20680: PPUSH
20681: LD_STRING D4-Sol1-1
20683: PPUSH
20684: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20688: LD_EXP 60
20692: PPUSH
20693: LD_STRING D4-Pow-2
20695: PPUSH
20696: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20700: LD_ADDR_VAR 0 1
20704: PUSH
20705: DOUBLE
20706: LD_INT 1
20708: DEC
20709: ST_TO_ADDR
20710: LD_EXP 18
20714: PUSH
20715: LD_INT 1
20717: ARRAY
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20813
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20722: LD_EXP 18
20726: PUSH
20727: LD_INT 1
20729: ARRAY
20730: PUSH
20731: LD_VAR 0 1
20735: ARRAY
20736: PPUSH
20737: LD_EXP 119
20741: PUSH
20742: LD_INT 4
20744: ARRAY
20745: PUSH
20746: LD_INT 1
20748: ARRAY
20749: PPUSH
20750: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
20754: LD_ADDR_EXP 119
20758: PUSH
20759: LD_EXP 119
20763: PPUSH
20764: LD_INT 4
20766: PPUSH
20767: LD_EXP 119
20771: PUSH
20772: LD_INT 4
20774: ARRAY
20775: PPUSH
20776: LD_INT 1
20778: PPUSH
20779: CALL_OW 3
20783: PPUSH
20784: CALL_OW 1
20788: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
20789: LD_INT 8
20791: PPUSH
20792: LD_EXP 18
20796: PUSH
20797: LD_INT 1
20799: ARRAY
20800: PUSH
20801: LD_VAR 0 1
20805: ARRAY
20806: PPUSH
20807: CALL_OW 471
// end ;
20811: GO 20719
20813: POP
20814: POP
// repeat wait ( 0 0$1 ) ;
20815: LD_INT 35
20817: PPUSH
20818: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
20822: LD_EXP 18
20826: PUSH
20827: LD_INT 1
20829: ARRAY
20830: PPUSH
20831: LD_INT 55
20833: PUSH
20834: EMPTY
20835: LIST
20836: PPUSH
20837: CALL_OW 72
20841: PUSH
20842: LD_INT 4
20844: GREATEREQUAL
20845: IFFALSE 20815
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
20847: LD_EXP 18
20851: PUSH
20852: LD_INT 1
20854: ARRAY
20855: PPUSH
20856: LD_INT 69
20858: PPUSH
20859: LD_INT 94
20861: PPUSH
20862: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
20866: LD_EXP 18
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: PPUSH
20875: LD_INT 82
20877: PPUSH
20878: LD_INT 83
20880: PPUSH
20881: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
20885: LD_EXP 18
20889: PUSH
20890: LD_INT 1
20892: ARRAY
20893: PPUSH
20894: LD_INT 77
20896: PPUSH
20897: LD_INT 69
20899: PPUSH
20900: CALL_OW 174
// repeat wait ( 3 ) ;
20904: LD_INT 3
20906: PPUSH
20907: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20911: LD_ADDR_VAR 0 1
20915: PUSH
20916: LD_EXP 18
20920: PUSH
20921: LD_INT 1
20923: ARRAY
20924: PUSH
20925: FOR_IN
20926: IFFALSE 21062
// begin if GetLives ( i ) < 990 then
20928: LD_VAR 0 1
20932: PPUSH
20933: CALL_OW 256
20937: PUSH
20938: LD_INT 990
20940: LESS
20941: IFFALSE 20955
// SetLives ( i , 1000 ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_INT 1000
20950: PPUSH
20951: CALL_OW 234
// if not IsInUnit ( i ) then
20955: LD_VAR 0 1
20959: PPUSH
20960: CALL_OW 310
20964: NOT
20965: IFFALSE 21060
// begin if not HasTask ( i ) then
20967: LD_VAR 0 1
20971: PPUSH
20972: CALL_OW 314
20976: NOT
20977: IFFALSE 20994
// ComMoveXY ( i , 64 , 93 ) ;
20979: LD_VAR 0 1
20983: PPUSH
20984: LD_INT 64
20986: PPUSH
20987: LD_INT 93
20989: PPUSH
20990: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
20994: LD_VAR 0 4
20998: NOT
20999: PUSH
21000: LD_VAR 0 1
21004: PPUSH
21005: CALL_OW 258
21009: PUSH
21010: LD_INT 1
21012: EQUAL
21013: AND
21014: IFFALSE 21060
// begin retreat := true ;
21016: LD_ADDR_VAR 0 4
21020: PUSH
21021: LD_INT 1
21023: ST_TO_ADDR
// SetTag ( i , 2 ) ;
21024: LD_VAR 0 1
21028: PPUSH
21029: LD_INT 2
21031: PPUSH
21032: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
21036: LD_VAR 0 1
21040: PPUSH
21041: LD_STRING D4a-Sol1-1
21043: PPUSH
21044: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
21048: LD_EXP 60
21052: PPUSH
21053: LD_STRING D4a-Pow-1
21055: PPUSH
21056: CALL_OW 88
// end ; end ; end ;
21060: GO 20925
21062: POP
21063: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
21064: LD_EXP 18
21068: PUSH
21069: LD_INT 1
21071: ARRAY
21072: PPUSH
21073: LD_INT 95
21075: PUSH
21076: LD_INT 9
21078: PUSH
21079: EMPTY
21080: LIST
21081: LIST
21082: PUSH
21083: LD_INT 3
21085: PUSH
21086: LD_INT 55
21088: PUSH
21089: EMPTY
21090: LIST
21091: PUSH
21092: EMPTY
21093: LIST
21094: LIST
21095: PUSH
21096: EMPTY
21097: LIST
21098: LIST
21099: PPUSH
21100: CALL_OW 72
21104: PUSH
21105: LD_INT 4
21107: GREATEREQUAL
21108: IFFALSE 20904
// for i in powellSquadAttack [ 1 ] do
21110: LD_ADDR_VAR 0 1
21114: PUSH
21115: LD_EXP 18
21119: PUSH
21120: LD_INT 1
21122: ARRAY
21123: PUSH
21124: FOR_IN
21125: IFFALSE 21261
// begin if GetTag ( i ) = 2 then
21127: LD_VAR 0 1
21131: PPUSH
21132: CALL_OW 110
21136: PUSH
21137: LD_INT 2
21139: EQUAL
21140: IFFALSE 21202
// begin ComMoveXY ( i , 60 , 94 ) ;
21142: LD_VAR 0 1
21146: PPUSH
21147: LD_INT 60
21149: PPUSH
21150: LD_INT 94
21152: PPUSH
21153: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
21157: LD_VAR 0 1
21161: PPUSH
21162: LD_EXP 60
21166: PPUSH
21167: CALL_OW 179
// wait ( 0 0$3 ) ;
21171: LD_INT 105
21173: PPUSH
21174: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21178: LD_VAR 0 1
21182: PPUSH
21183: LD_STRING D4a-Sol1-2
21185: PPUSH
21186: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21190: LD_EXP 60
21194: PPUSH
21195: LD_STRING D4a-Pow-2
21197: PPUSH
21198: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_INT 0
21209: PPUSH
21210: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21214: LD_ADDR_EXP 100
21218: PUSH
21219: LD_EXP 100
21223: PPUSH
21224: LD_INT 4
21226: PPUSH
21227: LD_EXP 100
21231: PUSH
21232: LD_INT 4
21234: ARRAY
21235: PUSH
21236: LD_VAR 0 1
21240: UNION
21241: PPUSH
21242: CALL_OW 1
21246: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21247: LD_INT 8
21249: PPUSH
21250: LD_VAR 0 1
21254: PPUSH
21255: CALL_OW 472
// end ;
21259: GO 21124
21261: POP
21262: POP
// wait ( 2 2$00 ) ;
21263: LD_INT 4200
21265: PPUSH
21266: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21270: LD_ADDR_VAR 0 9
21274: PUSH
21275: LD_INT 22
21277: PUSH
21278: LD_INT 4
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: PUSH
21285: LD_INT 30
21287: PUSH
21288: LD_INT 32
21290: PUSH
21291: EMPTY
21292: LIST
21293: LIST
21294: PUSH
21295: LD_INT 58
21297: PUSH
21298: EMPTY
21299: LIST
21300: PUSH
21301: EMPTY
21302: LIST
21303: LIST
21304: LIST
21305: PPUSH
21306: CALL_OW 69
21310: ST_TO_ADDR
// if tmp then
21311: LD_VAR 0 2
21315: IFFALSE 21555
// begin for i := 1 to tmp do
21317: LD_ADDR_VAR 0 1
21321: PUSH
21322: DOUBLE
21323: LD_INT 1
21325: DEC
21326: ST_TO_ADDR
21327: LD_VAR 0 2
21331: PUSH
21332: FOR_TO
21333: IFFALSE 21546
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21335: LD_ADDR_EXP 100
21339: PUSH
21340: LD_EXP 100
21344: PPUSH
21345: LD_INT 4
21347: PPUSH
21348: LD_EXP 100
21352: PUSH
21353: LD_INT 4
21355: ARRAY
21356: PUSH
21357: LD_VAR 0 2
21361: PUSH
21362: LD_VAR 0 1
21366: ARRAY
21367: DIFF
21368: PPUSH
21369: CALL_OW 1
21373: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21374: LD_ADDR_VAR 0 10
21378: PUSH
21379: LD_VAR 0 2
21383: PUSH
21384: LD_VAR 0 1
21388: ARRAY
21389: PPUSH
21390: CALL_OW 310
21394: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21395: LD_VAR 0 10
21399: PUSH
21400: LD_VAR 0 10
21404: PPUSH
21405: CALL_OW 266
21409: PUSH
21410: LD_INT 32
21412: EQUAL
21413: AND
21414: IFFALSE 21418
// continue ;
21416: GO 21332
// if t then
21418: LD_VAR 0 10
21422: IFFALSE 21439
// ComExitBuilding ( tmp [ i ] ) ;
21424: LD_VAR 0 2
21428: PUSH
21429: LD_VAR 0 1
21433: ARRAY
21434: PPUSH
21435: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21439: LD_VAR 0 2
21443: PUSH
21444: LD_VAR 0 1
21448: ARRAY
21449: PPUSH
21450: LD_VAR 0 5
21454: PUSH
21455: LD_INT 1
21457: ARRAY
21458: PPUSH
21459: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21463: LD_VAR 0 2
21467: PUSH
21468: LD_VAR 0 1
21472: ARRAY
21473: PPUSH
21474: LD_INT 1
21476: PPUSH
21477: CALL_OW 183
// if emptyTowers then
21481: LD_VAR 0 9
21485: IFFALSE 21544
// begin AddComExitBuilding ( tmp [ i ] ) ;
21487: LD_VAR 0 2
21491: PUSH
21492: LD_VAR 0 1
21496: ARRAY
21497: PPUSH
21498: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21502: LD_VAR 0 2
21506: PUSH
21507: LD_VAR 0 1
21511: ARRAY
21512: PPUSH
21513: LD_VAR 0 9
21517: PUSH
21518: LD_INT 1
21520: ARRAY
21521: PPUSH
21522: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21526: LD_ADDR_VAR 0 9
21530: PUSH
21531: LD_VAR 0 9
21535: PPUSH
21536: LD_INT 1
21538: PPUSH
21539: CALL_OW 3
21543: ST_TO_ADDR
// end ; end ;
21544: GO 21332
21546: POP
21547: POP
// wait ( 0 0$30 ) ;
21548: LD_INT 1050
21550: PPUSH
21551: CALL_OW 67
// end ; uc_side := 6 ;
21555: LD_ADDR_OWVAR 20
21559: PUSH
21560: LD_INT 6
21562: ST_TO_ADDR
// uc_nation := 3 ;
21563: LD_ADDR_OWVAR 21
21567: PUSH
21568: LD_INT 3
21570: ST_TO_ADDR
// ru := [ ] ;
21571: LD_ADDR_VAR 0 7
21575: PUSH
21576: EMPTY
21577: ST_TO_ADDR
// for i = 1 to 5 do
21578: LD_ADDR_VAR 0 1
21582: PUSH
21583: DOUBLE
21584: LD_INT 1
21586: DEC
21587: ST_TO_ADDR
21588: LD_INT 5
21590: PUSH
21591: FOR_TO
21592: IFFALSE 21712
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21594: LD_INT 22
21596: PUSH
21597: LD_INT 23
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PUSH
21604: LD_INT 1
21606: PPUSH
21607: LD_INT 2
21609: PPUSH
21610: CALL_OW 12
21614: ARRAY
21615: PPUSH
21616: LD_INT 1
21618: PPUSH
21619: LD_INT 3
21621: PPUSH
21622: LD_INT 43
21624: PUSH
21625: LD_INT 44
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: PUSH
21632: LD_INT 1
21634: PPUSH
21635: LD_INT 2
21637: PPUSH
21638: CALL_OW 12
21642: ARRAY
21643: PPUSH
21644: LD_INT 89
21646: PPUSH
21647: CALL 72551 0 5
// un := CreateVehicle ;
21651: LD_ADDR_VAR 0 8
21655: PUSH
21656: CALL_OW 45
21660: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21661: LD_VAR 0 8
21665: PPUSH
21666: LD_INT 4
21668: PPUSH
21669: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21673: LD_VAR 0 8
21677: PPUSH
21678: LD_INT 136
21680: PPUSH
21681: LD_INT 90
21683: PPUSH
21684: LD_INT 8
21686: PPUSH
21687: LD_INT 0
21689: PPUSH
21690: CALL_OW 50
// ru := ru ^ un ;
21694: LD_ADDR_VAR 0 7
21698: PUSH
21699: LD_VAR 0 7
21703: PUSH
21704: LD_VAR 0 8
21708: ADD
21709: ST_TO_ADDR
// end ;
21710: GO 21591
21712: POP
21713: POP
// if ru then
21714: LD_VAR 0 7
21718: IFFALSE 21735
// ComAgressiveMove ( ru , 57 , 94 ) ;
21720: LD_VAR 0 7
21724: PPUSH
21725: LD_INT 57
21727: PPUSH
21728: LD_INT 94
21730: PPUSH
21731: CALL_OW 114
// wait ( 3 3$00 ) ;
21735: LD_INT 6300
21737: PPUSH
21738: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21742: LD_INT 4
21744: PPUSH
21745: LD_INT 3
21747: PUSH
21748: LD_INT 1
21750: PUSH
21751: LD_INT 1
21753: PUSH
21754: LD_INT 5
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: LIST
21761: LIST
21762: PUSH
21763: LD_INT 4
21765: PUSH
21766: LD_INT 1
21768: PUSH
21769: LD_INT 1
21771: PUSH
21772: LD_INT 6
21774: PUSH
21775: EMPTY
21776: LIST
21777: LIST
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 4
21783: PUSH
21784: LD_INT 1
21786: PUSH
21787: LD_INT 1
21789: PUSH
21790: LD_INT 7
21792: PUSH
21793: EMPTY
21794: LIST
21795: LIST
21796: LIST
21797: LIST
21798: PUSH
21799: LD_INT 3
21801: PUSH
21802: LD_INT 1
21804: PUSH
21805: LD_INT 1
21807: PUSH
21808: LD_INT 7
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: LIST
21815: LIST
21816: PUSH
21817: LD_INT 3
21819: PUSH
21820: LD_INT 1
21822: PUSH
21823: LD_INT 1
21825: PUSH
21826: LD_INT 5
21828: PUSH
21829: EMPTY
21830: LIST
21831: LIST
21832: LIST
21833: LIST
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: LIST
21839: LIST
21840: LIST
21841: PPUSH
21842: CALL 61100 0 2
// missionStage := 4 ;
21846: LD_ADDR_EXP 15
21850: PUSH
21851: LD_INT 4
21853: ST_TO_ADDR
// end ;
21854: PPOPN 10
21856: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
21857: LD_EXP 15
21861: PUSH
21862: LD_INT 4
21864: EQUAL
21865: PUSH
21866: LD_INT 22
21868: PUSH
21869: LD_INT 4
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: LD_INT 21
21878: PUSH
21879: LD_INT 2
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PUSH
21886: EMPTY
21887: LIST
21888: LIST
21889: PPUSH
21890: CALL_OW 69
21894: PUSH
21895: LD_INT 5
21897: GREATEREQUAL
21898: AND
21899: IFFALSE 26112
21901: GO 21903
21903: DISABLE
21904: LD_INT 0
21906: PPUSH
21907: PPUSH
21908: PPUSH
21909: PPUSH
21910: PPUSH
21911: PPUSH
21912: PPUSH
21913: PPUSH
21914: PPUSH
21915: PPUSH
21916: PPUSH
21917: PPUSH
21918: PPUSH
// begin wait ( 0 0$10 ) ;
21919: LD_INT 350
21921: PPUSH
21922: CALL_OW 67
// missionStage := 5 ;
21926: LD_ADDR_EXP 15
21930: PUSH
21931: LD_INT 5
21933: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
21934: LD_ADDR_VAR 0 10
21938: PUSH
21939: LD_INT 22
21941: PUSH
21942: LD_INT 4
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: PUSH
21949: LD_INT 2
21951: PUSH
21952: LD_INT 30
21954: PUSH
21955: LD_INT 4
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PUSH
21962: LD_INT 30
21964: PUSH
21965: LD_INT 5
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: LIST
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: PPUSH
21981: CALL_OW 69
21985: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
21986: LD_ADDR_VAR 0 6
21990: PUSH
21991: LD_INT 22
21993: PUSH
21994: LD_INT 4
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 21
22003: PUSH
22004: LD_INT 1
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: PUSH
22011: LD_INT 3
22013: PUSH
22014: LD_INT 25
22016: PUSH
22017: LD_INT 16
22019: PUSH
22020: EMPTY
22021: LIST
22022: LIST
22023: PUSH
22024: EMPTY
22025: LIST
22026: LIST
22027: PUSH
22028: LD_INT 3
22030: PUSH
22031: LD_INT 25
22033: PUSH
22034: LD_INT 12
22036: PUSH
22037: EMPTY
22038: LIST
22039: LIST
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: LIST
22049: LIST
22050: PPUSH
22051: CALL_OW 69
22055: PUSH
22056: LD_EXP 60
22060: DIFF
22061: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
22062: LD_ADDR_VAR 0 9
22066: PUSH
22067: LD_INT 22
22069: PUSH
22070: LD_INT 4
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PUSH
22077: LD_INT 30
22079: PUSH
22080: LD_INT 3
22082: PUSH
22083: EMPTY
22084: LIST
22085: LIST
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PPUSH
22091: CALL_OW 69
22095: PUSH
22096: LD_INT 1
22098: ARRAY
22099: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
22100: LD_INT 350
22102: PPUSH
22103: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
22107: LD_EXP 119
22111: PUSH
22112: LD_INT 4
22114: ARRAY
22115: PUSH
22116: LD_INT 5
22118: LESS
22119: PUSH
22120: LD_VAR 0 9
22124: PPUSH
22125: CALL_OW 461
22129: PUSH
22130: LD_INT 2
22132: EQUAL
22133: AND
22134: IFFALSE 22164
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22136: LD_INT 4
22138: PPUSH
22139: LD_INT 3
22141: PUSH
22142: LD_INT 1
22144: PUSH
22145: LD_INT 1
22147: PUSH
22148: LD_INT 5
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: LIST
22155: LIST
22156: PUSH
22157: EMPTY
22158: LIST
22159: PPUSH
22160: CALL 61148 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
22164: LD_EXP 119
22168: PUSH
22169: LD_INT 4
22171: ARRAY
22172: PUSH
22173: LD_INT 5
22175: GREATEREQUAL
22176: PUSH
22177: LD_EXP 119
22181: PUSH
22182: LD_INT 4
22184: ARRAY
22185: PPUSH
22186: LD_INT 58
22188: PUSH
22189: EMPTY
22190: LIST
22191: PPUSH
22192: CALL_OW 72
22196: PUSH
22197: LD_INT 5
22199: GREATEREQUAL
22200: AND
22201: IFFALSE 22100
// powellAllowRetreat := false ;
22203: LD_ADDR_EXP 19
22207: PUSH
22208: LD_INT 0
22210: ST_TO_ADDR
// activeAttacks := false ;
22211: LD_ADDR_EXP 16
22215: PUSH
22216: LD_INT 0
22218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22219: LD_INT 35
22221: PPUSH
22222: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22226: LD_INT 22
22228: PUSH
22229: LD_INT 6
22231: PUSH
22232: EMPTY
22233: LIST
22234: LIST
22235: PPUSH
22236: CALL_OW 69
22240: PUSH
22241: LD_INT 0
22243: EQUAL
22244: IFFALSE 22219
// tmp := mc_vehicles [ 4 ] ;
22246: LD_ADDR_VAR 0 3
22250: PUSH
22251: LD_EXP 119
22255: PUSH
22256: LD_INT 4
22258: ARRAY
22259: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22260: LD_ADDR_VAR 0 1
22264: PUSH
22265: DOUBLE
22266: LD_INT 1
22268: DEC
22269: ST_TO_ADDR
22270: LD_EXP 18
22274: PUSH
22275: FOR_TO
22276: IFFALSE 22537
// begin for j in powellSquadAttack [ i ] do
22278: LD_ADDR_VAR 0 2
22282: PUSH
22283: LD_EXP 18
22287: PUSH
22288: LD_VAR 0 1
22292: ARRAY
22293: PUSH
22294: FOR_IN
22295: IFFALSE 22533
// begin forces := forces diff j ;
22297: LD_ADDR_VAR 0 6
22301: PUSH
22302: LD_VAR 0 6
22306: PUSH
22307: LD_VAR 0 2
22311: DIFF
22312: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22313: LD_VAR 0 2
22317: PPUSH
22318: LD_INT 1
22320: PPUSH
22321: CALL_OW 109
// wait ( 0 0$2 ) ;
22325: LD_INT 70
22327: PPUSH
22328: CALL_OW 67
// if IsInUnit ( j ) then
22332: LD_VAR 0 2
22336: PPUSH
22337: CALL_OW 310
22341: IFFALSE 22352
// ComExitBuilding ( j ) ;
22343: LD_VAR 0 2
22347: PPUSH
22348: CALL_OW 122
// if GetClass ( j ) <> 1 then
22352: LD_VAR 0 2
22356: PPUSH
22357: CALL_OW 257
22361: PUSH
22362: LD_INT 1
22364: NONEQUAL
22365: IFFALSE 22445
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22367: LD_VAR 0 10
22371: PUSH
22372: LD_INT 1
22374: ARRAY
22375: PPUSH
22376: CALL_OW 313
22380: PUSH
22381: LD_INT 5
22383: GREATEREQUAL
22384: IFFALSE 22406
// AddComEnterUnit ( j , arm [ 2 ] ) else
22386: LD_VAR 0 2
22390: PPUSH
22391: LD_VAR 0 10
22395: PUSH
22396: LD_INT 2
22398: ARRAY
22399: PPUSH
22400: CALL_OW 180
22404: GO 22424
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22406: LD_VAR 0 2
22410: PPUSH
22411: LD_VAR 0 10
22415: PUSH
22416: LD_INT 1
22418: ARRAY
22419: PPUSH
22420: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22424: LD_VAR 0 2
22428: PPUSH
22429: LD_INT 1
22431: PPUSH
22432: CALL_OW 183
// AddComExitBuilding ( j ) ;
22436: LD_VAR 0 2
22440: PPUSH
22441: CALL_OW 182
// end ; if i = 2 then
22445: LD_VAR 0 1
22449: PUSH
22450: LD_INT 2
22452: EQUAL
22453: IFFALSE 22470
// AddComMoveXY ( j , 61 , 93 ) ;
22455: LD_VAR 0 2
22459: PPUSH
22460: LD_INT 61
22462: PPUSH
22463: LD_INT 93
22465: PPUSH
22466: CALL_OW 171
// if i = 1 then
22470: LD_VAR 0 1
22474: PUSH
22475: LD_INT 1
22477: EQUAL
22478: IFFALSE 22531
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22480: LD_VAR 0 2
22484: PPUSH
22485: LD_VAR 0 3
22489: PUSH
22490: LD_INT 1
22492: ARRAY
22493: PPUSH
22494: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_VAR 0 3
22507: PPUSH
22508: LD_INT 1
22510: PPUSH
22511: CALL_OW 3
22515: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22516: LD_VAR 0 2
22520: PPUSH
22521: LD_INT 69
22523: PPUSH
22524: LD_INT 94
22526: PPUSH
22527: CALL_OW 171
// end ; end ;
22531: GO 22294
22533: POP
22534: POP
// end ;
22535: GO 22275
22537: POP
22538: POP
// wait ( 0 0$30 ) ;
22539: LD_INT 1050
22541: PPUSH
22542: CALL_OW 67
// MC_Kill ( 4 ) ;
22546: LD_INT 4
22548: PPUSH
22549: CALL 37121 0 1
// tmp := UnitsInside ( fac ) ;
22553: LD_ADDR_VAR 0 3
22557: PUSH
22558: LD_VAR 0 9
22562: PPUSH
22563: CALL_OW 313
22567: ST_TO_ADDR
// if tmp then
22568: LD_VAR 0 3
22572: IFFALSE 22693
// for i in tmp do
22574: LD_ADDR_VAR 0 1
22578: PUSH
22579: LD_VAR 0 3
22583: PUSH
22584: FOR_IN
22585: IFFALSE 22691
// begin ComExitBuilding ( i ) ;
22587: LD_VAR 0 1
22591: PPUSH
22592: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22596: LD_VAR 0 10
22600: PUSH
22601: LD_INT 2
22603: ARRAY
22604: PPUSH
22605: CALL_OW 313
22609: PUSH
22610: LD_INT 6
22612: LESS
22613: IFFALSE 22635
// AddComEnterUnit ( i , arm [ 2 ] ) else
22615: LD_VAR 0 1
22619: PPUSH
22620: LD_VAR 0 10
22624: PUSH
22625: LD_INT 2
22627: ARRAY
22628: PPUSH
22629: CALL_OW 180
22633: GO 22689
// if UnitsInside ( arm [ 1 ] ) < 6 then
22635: LD_VAR 0 10
22639: PUSH
22640: LD_INT 1
22642: ARRAY
22643: PPUSH
22644: CALL_OW 313
22648: PUSH
22649: LD_INT 6
22651: LESS
22652: IFFALSE 22674
// AddComEnterUnit ( i , arm [ 1 ] ) else
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 10
22663: PUSH
22664: LD_INT 1
22666: ARRAY
22667: PPUSH
22668: CALL_OW 180
22672: GO 22689
// AddComMoveXY ( i , 37 , 68 ) ;
22674: LD_VAR 0 1
22678: PPUSH
22679: LD_INT 37
22681: PPUSH
22682: LD_INT 68
22684: PPUSH
22685: CALL_OW 171
// end ;
22689: GO 22584
22691: POP
22692: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22693: LD_ADDR_VAR 0 11
22697: PUSH
22698: LD_VAR 0 6
22702: PPUSH
22703: LD_INT 26
22705: PUSH
22706: LD_INT 1
22708: PUSH
22709: EMPTY
22710: LIST
22711: LIST
22712: PPUSH
22713: CALL_OW 72
22717: PUSH
22718: LD_EXP 61
22722: DIFF
22723: ST_TO_ADDR
// if not speaker then
22724: LD_VAR 0 11
22728: NOT
22729: IFFALSE 22756
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22731: LD_ADDR_VAR 0 11
22735: PUSH
22736: LD_VAR 0 6
22740: PPUSH
22741: LD_INT 26
22743: PUSH
22744: LD_INT 1
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PPUSH
22751: CALL_OW 72
22755: ST_TO_ADDR
// if speaker then
22756: LD_VAR 0 11
22760: IFFALSE 22776
// speaker := speaker [ 1 ] ;
22762: LD_ADDR_VAR 0 11
22766: PUSH
22767: LD_VAR 0 11
22771: PUSH
22772: LD_INT 1
22774: ARRAY
22775: ST_TO_ADDR
// Video ( true ) ;
22776: LD_INT 1
22778: PPUSH
22779: CALL 104976 0 1
// CenterNowOnUnits ( Powell ) ;
22783: LD_EXP 60
22787: PPUSH
22788: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
22792: LD_ADDR_VAR 0 3
22796: PUSH
22797: LD_VAR 0 6
22801: PPUSH
22802: LD_INT 3
22804: PUSH
22805: LD_INT 25
22807: PUSH
22808: LD_INT 1
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: PPUSH
22819: CALL_OW 72
22823: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22824: LD_ADDR_VAR 0 12
22828: PUSH
22829: LD_INT 22
22831: PUSH
22832: LD_INT 4
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: PUSH
22839: LD_INT 30
22841: PUSH
22842: LD_INT 32
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: PUSH
22849: LD_INT 58
22851: PUSH
22852: EMPTY
22853: LIST
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: PPUSH
22860: CALL_OW 69
22864: ST_TO_ADDR
// for i := 1 to 4 do
22865: LD_ADDR_VAR 0 1
22869: PUSH
22870: DOUBLE
22871: LD_INT 1
22873: DEC
22874: ST_TO_ADDR
22875: LD_INT 4
22877: PUSH
22878: FOR_TO
22879: IFFALSE 23020
// begin if IsInUnit ( tmp [ i ] ) then
22881: LD_VAR 0 3
22885: PUSH
22886: LD_VAR 0 1
22890: ARRAY
22891: PPUSH
22892: CALL_OW 310
22896: IFFALSE 22913
// ComExitBuilding ( tmp [ i ] ) ;
22898: LD_VAR 0 3
22902: PUSH
22903: LD_VAR 0 1
22907: ARRAY
22908: PPUSH
22909: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22913: LD_VAR 0 3
22917: PUSH
22918: LD_VAR 0 1
22922: ARRAY
22923: PPUSH
22924: LD_VAR 0 10
22928: PUSH
22929: LD_INT 1
22931: ARRAY
22932: PPUSH
22933: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22937: LD_VAR 0 3
22941: PUSH
22942: LD_VAR 0 1
22946: ARRAY
22947: PPUSH
22948: LD_INT 1
22950: PPUSH
22951: CALL_OW 183
// if emp_towers then
22955: LD_VAR 0 12
22959: IFFALSE 23018
// begin AddComExitBuilding ( tmp [ i ] ) ;
22961: LD_VAR 0 3
22965: PUSH
22966: LD_VAR 0 1
22970: ARRAY
22971: PPUSH
22972: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
22976: LD_VAR 0 3
22980: PUSH
22981: LD_VAR 0 1
22985: ARRAY
22986: PPUSH
22987: LD_VAR 0 12
22991: PUSH
22992: LD_INT 1
22994: ARRAY
22995: PPUSH
22996: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
23000: LD_ADDR_VAR 0 12
23004: PUSH
23005: LD_VAR 0 12
23009: PPUSH
23010: LD_INT 1
23012: PPUSH
23013: CALL_OW 3
23017: ST_TO_ADDR
// end ; end ;
23018: GO 22878
23020: POP
23021: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
23022: LD_ADDR_VAR 0 3
23026: PUSH
23027: LD_EXP 18
23031: PUSH
23032: LD_INT 1
23034: ARRAY
23035: PUSH
23036: LD_EXP 18
23040: PUSH
23041: LD_INT 2
23043: ARRAY
23044: ADD
23045: PPUSH
23046: LD_INT 26
23048: PUSH
23049: LD_INT 1
23051: PUSH
23052: EMPTY
23053: LIST
23054: LIST
23055: PPUSH
23056: CALL_OW 72
23060: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
23061: LD_ADDR_VAR 0 1
23065: PUSH
23066: LD_EXP 18
23070: PUSH
23071: LD_INT 2
23073: ARRAY
23074: PUSH
23075: FOR_IN
23076: IFFALSE 23094
// ComTurnUnit ( i , Powell ) ;
23078: LD_VAR 0 1
23082: PPUSH
23083: LD_EXP 60
23087: PPUSH
23088: CALL_OW 119
23092: GO 23075
23094: POP
23095: POP
// Say ( Powell , D5-Pow-1 ) ;
23096: LD_EXP 60
23100: PPUSH
23101: LD_STRING D5-Pow-1
23103: PPUSH
23104: CALL_OW 88
// if tmp then
23108: LD_VAR 0 3
23112: IFFALSE 23130
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
23114: LD_VAR 0 3
23118: PUSH
23119: LD_INT 1
23121: ARRAY
23122: PPUSH
23123: LD_STRING D5-Sol2-1
23125: PPUSH
23126: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
23130: LD_EXP 60
23134: PPUSH
23135: LD_STRING D5-Pow-2
23137: PPUSH
23138: CALL_OW 88
// if tmp > 1 then
23142: LD_VAR 0 3
23146: PUSH
23147: LD_INT 1
23149: GREATER
23150: IFFALSE 23168
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
23152: LD_VAR 0 3
23156: PUSH
23157: LD_INT 2
23159: ARRAY
23160: PPUSH
23161: LD_STRING D5-Sol2-2
23163: PPUSH
23164: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
23168: LD_EXP 60
23172: PPUSH
23173: LD_STRING D5-Pow-3
23175: PPUSH
23176: CALL_OW 88
// wait ( 0 0$1 ) ;
23180: LD_INT 35
23182: PPUSH
23183: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23187: LD_ADDR_VAR 0 3
23191: PUSH
23192: LD_EXP 18
23196: PUSH
23197: LD_INT 1
23199: ARRAY
23200: PUSH
23201: LD_EXP 18
23205: PUSH
23206: LD_INT 2
23208: ARRAY
23209: UNION
23210: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23211: LD_VAR 0 3
23215: PPUSH
23216: LD_INT 80
23218: PPUSH
23219: LD_INT 67
23221: PPUSH
23222: CALL_OW 114
// wait ( 0 0$2 ) ;
23226: LD_INT 70
23228: PPUSH
23229: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23233: LD_INT 79
23235: PPUSH
23236: LD_INT 72
23238: PPUSH
23239: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23243: LD_INT 70
23245: PPUSH
23246: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23250: LD_VAR 0 3
23254: PPUSH
23255: LD_INT 3
23257: PUSH
23258: LD_INT 24
23260: PUSH
23261: LD_INT 1000
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PPUSH
23272: CALL_OW 72
23276: IFFALSE 23243
// Say ( Powell , D5a-Pow-1 ) ;
23278: LD_EXP 60
23282: PPUSH
23283: LD_STRING D5a-Pow-1
23285: PPUSH
23286: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23290: LD_EXP 60
23294: PPUSH
23295: LD_STRING D5a-Pow-1a
23297: PPUSH
23298: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23302: LD_INT 24
23304: PPUSH
23305: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23309: LD_EXP 60
23313: PPUSH
23314: LD_STRING D5a-Pow-1b
23316: PPUSH
23317: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23321: LD_INT 10
23323: PPUSH
23324: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23328: LD_EXP 60
23332: PPUSH
23333: LD_STRING D5a-Pow-1c
23335: PPUSH
23336: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23340: LD_VAR 0 3
23344: PPUSH
23345: LD_INT 68
23347: PPUSH
23348: LD_INT 63
23350: PPUSH
23351: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23355: LD_INT 18
23357: PPUSH
23358: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23362: LD_EXP 60
23366: PPUSH
23367: LD_STRING D5a-Pow-1d
23369: PPUSH
23370: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23374: LD_INT 35
23376: PPUSH
23377: CALL_OW 67
// if not HasTask ( tmp ) then
23381: LD_VAR 0 3
23385: PPUSH
23386: CALL_OW 314
23390: NOT
23391: IFFALSE 23408
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23393: LD_VAR 0 3
23397: PPUSH
23398: LD_INT 68
23400: PPUSH
23401: LD_INT 63
23403: PPUSH
23404: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23408: LD_VAR 0 3
23412: PPUSH
23413: LD_INT 24
23415: PUSH
23416: LD_INT 1
23418: PUSH
23419: EMPTY
23420: LIST
23421: LIST
23422: PPUSH
23423: CALL_OW 72
23427: NOT
23428: IFFALSE 23374
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_INT 22
23437: PUSH
23438: LD_INT 4
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: PUSH
23445: LD_INT 92
23447: PUSH
23448: LD_INT 60
23450: PUSH
23451: LD_INT 93
23453: PUSH
23454: LD_INT 10
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: LIST
23462: PUSH
23463: LD_INT 3
23465: PUSH
23466: LD_INT 54
23468: PUSH
23469: EMPTY
23470: LIST
23471: PUSH
23472: EMPTY
23473: LIST
23474: LIST
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: LIST
23480: PPUSH
23481: CALL_OW 69
23485: PUSH
23486: LD_EXP 60
23490: DIFF
23491: ST_TO_ADDR
// if tmp then
23492: LD_VAR 0 3
23496: IFFALSE 23530
// for i in tmp do
23498: LD_ADDR_VAR 0 1
23502: PUSH
23503: LD_VAR 0 3
23507: PUSH
23508: FOR_IN
23509: IFFALSE 23528
// ComMoveXY ( i , 36 , 67 ) ;
23511: LD_VAR 0 1
23515: PPUSH
23516: LD_INT 36
23518: PPUSH
23519: LD_INT 67
23521: PPUSH
23522: CALL_OW 111
23526: GO 23508
23528: POP
23529: POP
// wait ( 0 0$3 ) ;
23530: LD_INT 105
23532: PPUSH
23533: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23537: LD_VAR 0 11
23541: PPUSH
23542: LD_STRING D6-Sol3-1
23544: PPUSH
23545: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23549: LD_EXP 60
23553: PPUSH
23554: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23558: LD_EXP 60
23562: PPUSH
23563: LD_STRING D6-Pow-1
23565: PPUSH
23566: CALL_OW 88
// tmp := [ ] ;
23570: LD_ADDR_VAR 0 3
23574: PUSH
23575: EMPTY
23576: ST_TO_ADDR
// for i = 1 to 2 do
23577: LD_ADDR_VAR 0 1
23581: PUSH
23582: DOUBLE
23583: LD_INT 1
23585: DEC
23586: ST_TO_ADDR
23587: LD_INT 2
23589: PUSH
23590: FOR_TO
23591: IFFALSE 23705
// begin uc_side := 8 ;
23593: LD_ADDR_OWVAR 20
23597: PUSH
23598: LD_INT 8
23600: ST_TO_ADDR
// uc_nation := 2 ;
23601: LD_ADDR_OWVAR 21
23605: PUSH
23606: LD_INT 2
23608: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23609: LD_INT 14
23611: PPUSH
23612: LD_INT 3
23614: PPUSH
23615: LD_INT 2
23617: PPUSH
23618: LD_INT 29
23620: PPUSH
23621: LD_INT 100
23623: PPUSH
23624: CALL 72551 0 5
// veh := CreateVehicle ;
23628: LD_ADDR_VAR 0 13
23632: PUSH
23633: CALL_OW 45
23637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23638: LD_VAR 0 13
23642: PPUSH
23643: LD_INT 4
23645: PPUSH
23646: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23650: LD_VAR 0 13
23654: PPUSH
23655: LD_INT 99
23657: PPUSH
23658: LD_INT 83
23660: PPUSH
23661: LD_INT 3
23663: PPUSH
23664: LD_INT 0
23666: PPUSH
23667: CALL_OW 50
// wait ( 3 ) ;
23671: LD_INT 3
23673: PPUSH
23674: CALL_OW 67
// Connect ( veh ) ;
23678: LD_VAR 0 13
23682: PPUSH
23683: CALL 75642 0 1
// tmp := tmp ^ veh ;
23687: LD_ADDR_VAR 0 3
23691: PUSH
23692: LD_VAR 0 3
23696: PUSH
23697: LD_VAR 0 13
23701: ADD
23702: ST_TO_ADDR
// end ;
23703: GO 23590
23705: POP
23706: POP
// wait ( 0 0$1 ) ;
23707: LD_INT 35
23709: PPUSH
23710: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
23714: LD_INT 99
23716: PPUSH
23717: LD_INT 83
23719: PPUSH
23720: LD_INT 1
23722: PPUSH
23723: LD_INT 10
23725: PPUSH
23726: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
23730: LD_INT 99
23732: PPUSH
23733: LD_INT 83
23735: PPUSH
23736: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
23740: LD_VAR 0 11
23744: PPUSH
23745: LD_STRING D6-Sol3-2
23747: PPUSH
23748: CALL_OW 88
// async ;
23752: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
23753: LD_EXP 60
23757: PPUSH
23758: LD_STRING D6-Pow-2
23760: PPUSH
23761: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
23765: LD_VAR 0 3
23769: PUSH
23770: LD_INT 1
23772: ARRAY
23773: PPUSH
23774: LD_VAR 0 9
23778: PPUSH
23779: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
23783: LD_VAR 0 3
23787: PUSH
23788: LD_INT 2
23790: ARRAY
23791: PPUSH
23792: LD_INT 22
23794: PUSH
23795: LD_INT 4
23797: PUSH
23798: EMPTY
23799: LIST
23800: LIST
23801: PUSH
23802: LD_INT 21
23804: PUSH
23805: LD_INT 3
23807: PUSH
23808: EMPTY
23809: LIST
23810: LIST
23811: PUSH
23812: EMPTY
23813: LIST
23814: LIST
23815: PPUSH
23816: CALL_OW 69
23820: PPUSH
23821: LD_VAR 0 3
23825: PUSH
23826: LD_INT 2
23828: ARRAY
23829: PPUSH
23830: CALL_OW 74
23834: PPUSH
23835: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
23839: LD_EXP 60
23843: PPUSH
23844: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
23848: LD_INT 99
23850: PPUSH
23851: LD_INT 83
23853: PPUSH
23854: LD_INT 1
23856: PPUSH
23857: CALL_OW 331
// repeat wait ( 4 ) ;
23861: LD_INT 4
23863: PPUSH
23864: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
23868: LD_VAR 0 3
23872: PUSH
23873: LD_INT 1
23875: ARRAY
23876: PPUSH
23877: CALL_OW 256
23881: PUSH
23882: LD_INT 1000
23884: LESS
23885: IFFALSE 23903
// SetLives ( tmp [ 1 ] , 1000 ) ;
23887: LD_VAR 0 3
23891: PUSH
23892: LD_INT 1
23894: ARRAY
23895: PPUSH
23896: LD_INT 1000
23898: PPUSH
23899: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
23903: LD_INT 22
23905: PUSH
23906: LD_INT 4
23908: PUSH
23909: EMPTY
23910: LIST
23911: LIST
23912: PUSH
23913: LD_INT 30
23915: PUSH
23916: LD_INT 3
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PPUSH
23927: CALL_OW 69
23931: PUSH
23932: LD_INT 0
23934: EQUAL
23935: IFFALSE 23861
// skirmish := false ;
23937: LD_ADDR_EXP 98
23941: PUSH
23942: LD_INT 0
23944: ST_TO_ADDR
// sync ;
23945: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
23946: LD_EXP 60
23950: PPUSH
23951: LD_STRING D6a-Pow-1
23953: PPUSH
23954: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
23958: LD_VAR 0 11
23962: PPUSH
23963: LD_STRING D6a-Sol3-1
23965: PPUSH
23966: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
23970: LD_EXP 60
23974: PPUSH
23975: LD_STRING D6a-Pow-2
23977: PPUSH
23978: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
23982: LD_VAR 0 11
23986: PPUSH
23987: LD_STRING D6a-Sol3-2
23989: PPUSH
23990: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
23994: LD_EXP 60
23998: PPUSH
23999: LD_STRING D6a-Pow-3
24001: PPUSH
24002: CALL_OW 88
// powellCenterCameraMode := true ;
24006: LD_ADDR_EXP 20
24010: PUSH
24011: LD_INT 1
24013: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
24014: LD_ADDR_VAR 0 1
24018: PUSH
24019: LD_INT 22
24021: PUSH
24022: LD_INT 8
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 25
24031: PUSH
24032: LD_INT 2
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: EMPTY
24040: LIST
24041: LIST
24042: PPUSH
24043: CALL_OW 69
24047: PUSH
24048: FOR_IN
24049: IFFALSE 24104
// begin SetTag ( i , 1 ) ;
24051: LD_VAR 0 1
24055: PPUSH
24056: LD_INT 1
24058: PPUSH
24059: CALL_OW 109
// ComExitBuilding ( i ) ;
24063: LD_VAR 0 1
24067: PPUSH
24068: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
24072: LD_VAR 0 1
24076: PPUSH
24077: LD_INT 35
24079: PPUSH
24080: LD_INT 6
24082: PPUSH
24083: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
24087: LD_VAR 0 1
24091: PPUSH
24092: LD_INT 53
24094: PPUSH
24095: LD_INT 4
24097: PPUSH
24098: CALL_OW 171
// end ;
24102: GO 24048
24104: POP
24105: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
24106: LD_ADDR_VAR 0 3
24110: PUSH
24111: LD_INT 22
24113: PUSH
24114: LD_INT 4
24116: PUSH
24117: EMPTY
24118: LIST
24119: LIST
24120: PUSH
24121: LD_INT 21
24123: PUSH
24124: LD_INT 2
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PUSH
24131: LD_INT 3
24133: PUSH
24134: LD_INT 34
24136: PUSH
24137: LD_INT 12
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: PPUSH
24153: CALL_OW 69
24157: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
24158: LD_EXP 60
24162: PPUSH
24163: LD_VAR 0 3
24167: PPUSH
24168: LD_EXP 60
24172: PPUSH
24173: CALL_OW 74
24177: PPUSH
24178: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24182: LD_EXP 60
24186: PPUSH
24187: LD_INT 100
24189: PPUSH
24190: LD_INT 88
24192: PPUSH
24193: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24197: LD_EXP 60
24201: PPUSH
24202: LD_INT 100
24204: PPUSH
24205: LD_INT 75
24207: PPUSH
24208: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24212: LD_EXP 60
24216: PPUSH
24217: LD_INT 88
24219: PPUSH
24220: LD_INT 53
24222: PPUSH
24223: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24227: LD_INT 8
24229: PPUSH
24230: LD_EXP 60
24234: PPUSH
24235: CALL_OW 471
// repeat wait ( 3 ) ;
24239: LD_INT 3
24241: PPUSH
24242: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24246: LD_INT 22
24248: PUSH
24249: LD_INT 4
24251: PUSH
24252: EMPTY
24253: LIST
24254: LIST
24255: PUSH
24256: LD_INT 92
24258: PUSH
24259: LD_INT 100
24261: PUSH
24262: LD_INT 75
24264: PUSH
24265: LD_INT 6
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: LIST
24272: LIST
24273: PUSH
24274: EMPTY
24275: LIST
24276: LIST
24277: PPUSH
24278: CALL_OW 69
24282: IFFALSE 24239
// async ;
24284: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24285: LD_EXP 60
24289: PPUSH
24290: LD_STRING D6b-Pow-1
24292: PPUSH
24293: CALL_OW 88
// repeat wait ( 3 ) ;
24297: LD_INT 3
24299: PPUSH
24300: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24304: LD_EXP 60
24308: PPUSH
24309: CALL_OW 310
24313: PPUSH
24314: CALL_OW 256
24318: PUSH
24319: LD_INT 1000
24321: LESS
24322: IFFALSE 24341
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24324: LD_EXP 60
24328: PPUSH
24329: CALL_OW 310
24333: PPUSH
24334: LD_INT 1000
24336: PPUSH
24337: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24341: LD_EXP 60
24345: PPUSH
24346: CALL_OW 256
24350: PUSH
24351: LD_INT 1000
24353: LESS
24354: IFFALSE 24368
// SetLives ( Powell , 1000 ) ;
24356: LD_EXP 60
24360: PPUSH
24361: LD_INT 1000
24363: PPUSH
24364: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24368: LD_EXP 60
24372: PPUSH
24373: LD_EXP 65
24377: PPUSH
24378: CALL_OW 296
24382: PUSH
24383: LD_INT 5
24385: LESS
24386: PUSH
24387: LD_EXP 60
24391: PPUSH
24392: CALL_OW 310
24396: PPUSH
24397: LD_EXP 65
24401: PPUSH
24402: CALL_OW 296
24406: PUSH
24407: LD_INT 5
24409: LESS
24410: OR
24411: IFFALSE 24430
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24413: LD_EXP 60
24417: PPUSH
24418: CALL_OW 310
24422: PPUSH
24423: LD_INT 100
24425: PPUSH
24426: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24430: LD_EXP 60
24434: PPUSH
24435: CALL_OW 310
24439: NOT
24440: IFFALSE 24297
// DoNotAttack ( 8 , powellBomb ) ;
24442: LD_INT 8
24444: PPUSH
24445: LD_EXP 65
24449: PPUSH
24450: CALL_OW 471
// game_speed := 4 ;
24454: LD_ADDR_OWVAR 65
24458: PUSH
24459: LD_INT 4
24461: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24462: LD_EXP 60
24466: PPUSH
24467: LD_STRING D6b-Pow-1a
24469: PPUSH
24470: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24474: LD_EXP 60
24478: PPUSH
24479: LD_EXP 65
24483: PPUSH
24484: CALL_OW 180
// sync ;
24488: SYNC
// repeat wait ( 0 0$1 ) ;
24489: LD_INT 35
24491: PPUSH
24492: CALL_OW 67
// until IsInUnit ( Powell ) ;
24496: LD_EXP 60
24500: PPUSH
24501: CALL_OW 310
24505: IFFALSE 24489
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24507: LD_INT 8
24509: PPUSH
24510: LD_EXP 60
24514: PPUSH
24515: CALL_OW 310
24519: PPUSH
24520: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24524: LD_EXP 60
24528: PPUSH
24529: LD_INT 91
24531: PPUSH
24532: LD_INT 44
24534: PPUSH
24535: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24539: LD_EXP 60
24543: PPUSH
24544: LD_INT 96
24546: PPUSH
24547: LD_INT 44
24549: PPUSH
24550: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24554: LD_EXP 60
24558: PPUSH
24559: LD_INT 96
24561: PPUSH
24562: LD_INT 41
24564: PPUSH
24565: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24569: LD_EXP 60
24573: PPUSH
24574: LD_INT 92
24576: PPUSH
24577: LD_INT 39
24579: PPUSH
24580: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24584: LD_EXP 60
24588: PPUSH
24589: LD_INT 88
24591: PPUSH
24592: LD_INT 41
24594: PPUSH
24595: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24599: LD_EXP 60
24603: PPUSH
24604: LD_INT 91
24606: PPUSH
24607: LD_INT 44
24609: PPUSH
24610: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24614: LD_EXP 60
24618: PPUSH
24619: LD_INT 96
24621: PPUSH
24622: LD_INT 44
24624: PPUSH
24625: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24629: LD_EXP 60
24633: PPUSH
24634: LD_INT 96
24636: PPUSH
24637: LD_INT 41
24639: PPUSH
24640: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24644: LD_EXP 60
24648: PPUSH
24649: LD_INT 92
24651: PPUSH
24652: LD_INT 39
24654: PPUSH
24655: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24659: LD_EXP 60
24663: PPUSH
24664: LD_INT 88
24666: PPUSH
24667: LD_INT 41
24669: PPUSH
24670: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24674: LD_EXP 60
24678: PPUSH
24679: LD_INT 91
24681: PPUSH
24682: LD_INT 44
24684: PPUSH
24685: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
24689: LD_EXP 60
24693: PPUSH
24694: LD_INT 93
24696: PPUSH
24697: LD_INT 39
24699: PPUSH
24700: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
24704: LD_EXP 60
24708: PPUSH
24709: LD_INT 93
24711: PPUSH
24712: LD_INT 36
24714: PPUSH
24715: CALL_OW 171
// wait ( 0 0$3.5 ) ;
24719: LD_INT 122
24721: PPUSH
24722: CALL_OW 67
// game_speed := 4 ;
24726: LD_ADDR_OWVAR 65
24730: PUSH
24731: LD_INT 4
24733: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
24734: LD_EXP 60
24738: PPUSH
24739: LD_STRING D6b-Pow-1b
24741: PPUSH
24742: CALL_OW 88
// tmp := [ ] ;
24746: LD_ADDR_VAR 0 3
24750: PUSH
24751: EMPTY
24752: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
24753: LD_ADDR_VAR 0 5
24757: PUSH
24758: LD_INT 78
24760: PUSH
24761: LD_INT 47
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: PUSH
24768: LD_INT 106
24770: PUSH
24771: LD_INT 53
24773: PUSH
24774: EMPTY
24775: LIST
24776: LIST
24777: PUSH
24778: EMPTY
24779: LIST
24780: LIST
24781: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
24782: LD_ADDR_VAR 0 1
24786: PUSH
24787: LD_INT 22
24789: PUSH
24790: LD_INT 8
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 21
24799: PUSH
24800: LD_INT 3
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PUSH
24807: LD_INT 92
24809: PUSH
24810: LD_INT 90
24812: PUSH
24813: LD_INT 52
24815: PUSH
24816: LD_INT 12
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: LIST
24823: LIST
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: LIST
24829: PPUSH
24830: CALL_OW 69
24834: PUSH
24835: FOR_IN
24836: IFFALSE 24861
// tmp := tmp ^ UnitsInside ( i ) ;
24838: LD_ADDR_VAR 0 3
24842: PUSH
24843: LD_VAR 0 3
24847: PUSH
24848: LD_VAR 0 1
24852: PPUSH
24853: CALL_OW 313
24857: ADD
24858: ST_TO_ADDR
24859: GO 24835
24861: POP
24862: POP
// for i in tmp do
24863: LD_ADDR_VAR 0 1
24867: PUSH
24868: LD_VAR 0 3
24872: PUSH
24873: FOR_IN
24874: IFFALSE 25036
// begin dist := 9999 ;
24876: LD_ADDR_VAR 0 8
24880: PUSH
24881: LD_INT 9999
24883: ST_TO_ADDR
// _xy := [ ] ;
24884: LD_ADDR_VAR 0 7
24888: PUSH
24889: EMPTY
24890: ST_TO_ADDR
// SetTag ( i , 1 ) ;
24891: LD_VAR 0 1
24895: PPUSH
24896: LD_INT 1
24898: PPUSH
24899: CALL_OW 109
// ComExitBuilding ( i ) ;
24903: LD_VAR 0 1
24907: PPUSH
24908: CALL_OW 122
// for j in xy do
24912: LD_ADDR_VAR 0 2
24916: PUSH
24917: LD_VAR 0 5
24921: PUSH
24922: FOR_IN
24923: IFFALSE 25005
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
24925: LD_VAR 0 1
24929: PPUSH
24930: LD_VAR 0 2
24934: PUSH
24935: LD_INT 1
24937: ARRAY
24938: PPUSH
24939: LD_VAR 0 2
24943: PUSH
24944: LD_INT 2
24946: ARRAY
24947: PPUSH
24948: CALL_OW 297
24952: PUSH
24953: LD_VAR 0 8
24957: LESS
24958: IFFALSE 25003
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
24960: LD_ADDR_VAR 0 8
24964: PUSH
24965: LD_VAR 0 1
24969: PPUSH
24970: LD_VAR 0 2
24974: PUSH
24975: LD_INT 1
24977: ARRAY
24978: PPUSH
24979: LD_VAR 0 2
24983: PUSH
24984: LD_INT 2
24986: ARRAY
24987: PPUSH
24988: CALL_OW 297
24992: ST_TO_ADDR
// _xy := j ;
24993: LD_ADDR_VAR 0 7
24997: PUSH
24998: LD_VAR 0 2
25002: ST_TO_ADDR
// end ;
25003: GO 24922
25005: POP
25006: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
25007: LD_VAR 0 1
25011: PPUSH
25012: LD_VAR 0 7
25016: PUSH
25017: LD_INT 1
25019: ARRAY
25020: PPUSH
25021: LD_VAR 0 7
25025: PUSH
25026: LD_INT 2
25028: ARRAY
25029: PPUSH
25030: CALL_OW 171
// end ;
25034: GO 24873
25036: POP
25037: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
25038: LD_ADDR_VAR 0 4
25042: PUSH
25043: LD_VAR 0 3
25047: PPUSH
25048: LD_INT 26
25050: PUSH
25051: LD_INT 1
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 25
25060: PUSH
25061: LD_INT 1
25063: PUSH
25064: EMPTY
25065: LIST
25066: LIST
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PPUSH
25072: CALL_OW 72
25076: ST_TO_ADDR
// if tmp2 < 2 then
25077: LD_VAR 0 4
25081: PUSH
25082: LD_INT 2
25084: LESS
25085: IFFALSE 25154
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
25087: LD_ADDR_VAR 0 4
25091: PUSH
25092: LD_INT 22
25094: PUSH
25095: LD_INT 8
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: PUSH
25102: LD_INT 26
25104: PUSH
25105: LD_INT 1
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 3
25114: PUSH
25115: LD_INT 25
25117: PUSH
25118: LD_INT 15
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: PUSH
25125: EMPTY
25126: LIST
25127: LIST
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: PPUSH
25134: CALL_OW 69
25138: PUSH
25139: LD_EXP 62
25143: PUSH
25144: LD_EXP 63
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: DIFF
25153: ST_TO_ADDR
// if tmp2 then
25154: LD_VAR 0 4
25158: IFFALSE 25176
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
25160: LD_VAR 0 4
25164: PUSH
25165: LD_INT 1
25167: ARRAY
25168: PPUSH
25169: LD_STRING D6b-ArSol1-1
25171: PPUSH
25172: CALL_OW 88
// async ;
25176: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25177: LD_EXP 60
25181: PPUSH
25182: LD_STRING D6b-Pow-2
25184: PPUSH
25185: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25189: LD_INT 18
25191: PPUSH
25192: CALL_OW 67
// if tmp2 > 1 then
25196: LD_VAR 0 4
25200: PUSH
25201: LD_INT 1
25203: GREATER
25204: IFFALSE 25222
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25206: LD_VAR 0 4
25210: PUSH
25211: LD_INT 2
25213: ARRAY
25214: PPUSH
25215: LD_STRING D6b-ArSol2-1
25217: PPUSH
25218: CALL_OW 88
// sync ;
25222: SYNC
// repeat wait ( 5 ) ;
25223: LD_INT 5
25225: PPUSH
25226: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25230: LD_INT 93
25232: PPUSH
25233: LD_INT 36
25235: PPUSH
25236: CALL_OW 428
25240: PPUSH
25241: CALL_OW 255
25245: PUSH
25246: LD_INT 4
25248: EQUAL
25249: IFFALSE 25223
// DialogueOn ;
25251: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25255: LD_INT 10
25257: PPUSH
25258: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25262: LD_EXP 60
25266: PPUSH
25267: LD_STRING D6b-Pow-2a
25269: PPUSH
25270: CALL_OW 88
// DialogueOff ;
25274: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25278: LD_EXP 60
25282: PPUSH
25283: CALL_OW 310
25287: PPUSH
25288: LD_INT 332
25290: PPUSH
25291: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25295: LD_INT 93
25297: PPUSH
25298: LD_INT 35
25300: PPUSH
25301: LD_INT 1
25303: PPUSH
25304: LD_INT 6
25306: NEG
25307: PPUSH
25308: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25312: LD_INT 35
25314: PPUSH
25315: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25319: LD_INT 332
25321: PPUSH
25322: CALL_OW 256
25326: PUSH
25327: LD_INT 1000
25329: LESS
25330: PUSH
25331: LD_INT 332
25333: PPUSH
25334: CALL_OW 300
25338: AND
25339: IFFALSE 25351
// SetLives ( kozlov_fac , 0 ) ;
25341: LD_INT 332
25343: PPUSH
25344: LD_INT 0
25346: PPUSH
25347: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25351: LD_INT 332
25353: PPUSH
25354: CALL_OW 301
25358: PUSH
25359: LD_EXP 60
25363: PPUSH
25364: CALL_OW 301
25368: OR
25369: IFFALSE 25312
// game_speed := 4 ;
25371: LD_ADDR_OWVAR 65
25375: PUSH
25376: LD_INT 4
25378: ST_TO_ADDR
// powellCenterCameraMode := false ;
25379: LD_ADDR_EXP 20
25383: PUSH
25384: LD_INT 0
25386: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25387: LD_ADDR_VAR 0 1
25391: PUSH
25392: LD_VAR 0 3
25396: PUSH
25397: LD_INT 22
25399: PUSH
25400: LD_INT 8
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 25
25409: PUSH
25410: LD_INT 2
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: PPUSH
25421: CALL_OW 69
25425: UNION
25426: PUSH
25427: FOR_IN
25428: IFFALSE 25444
// SetTag ( i , 0 ) ;
25430: LD_VAR 0 1
25434: PPUSH
25435: LD_INT 0
25437: PPUSH
25438: CALL_OW 109
25442: GO 25427
25444: POP
25445: POP
// wait ( 0 0$3 ) ;
25446: LD_INT 105
25448: PPUSH
25449: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25453: LD_INT 93
25455: PPUSH
25456: LD_INT 35
25458: PPUSH
25459: LD_INT 1
25461: PPUSH
25462: CALL_OW 331
// DialogueOn ;
25466: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25470: LD_VAR 0 11
25474: PPUSH
25475: LD_STRING D6c-Sol3-1
25477: PPUSH
25478: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25482: LD_INT 10
25484: PPUSH
25485: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25489: LD_EXP 40
25493: PPUSH
25494: LD_STRING D6c-JMM-1
25496: PPUSH
25497: CALL_OW 88
// if Cyrus then
25501: LD_EXP 46
25505: IFFALSE 25519
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25507: LD_EXP 46
25511: PPUSH
25512: LD_STRING D6c-Cyrus-1
25514: PPUSH
25515: CALL_OW 88
// if Bobby then
25519: LD_EXP 45
25523: IFFALSE 25537
// Say ( Bobby , D6c-Bobby-1 ) ;
25525: LD_EXP 45
25529: PPUSH
25530: LD_STRING D6c-Bobby-1
25532: PPUSH
25533: CALL_OW 88
// if Cornel then
25537: LD_EXP 51
25541: IFFALSE 25555
// Say ( Cornel , D6c-Corn-1 ) ;
25543: LD_EXP 51
25547: PPUSH
25548: LD_STRING D6c-Corn-1
25550: PPUSH
25551: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25555: LD_ADDR_VAR 0 4
25559: PUSH
25560: LD_INT 2
25562: PUSH
25563: LD_INT 22
25565: PUSH
25566: LD_INT 1
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: LD_INT 22
25575: PUSH
25576: LD_INT 4
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 26
25590: PUSH
25591: LD_INT 1
25593: PUSH
25594: EMPTY
25595: LIST
25596: LIST
25597: PUSH
25598: LD_INT 23
25600: PUSH
25601: LD_INT 1
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: LIST
25612: PPUSH
25613: CALL_OW 69
25617: PUSH
25618: LD_VAR 0 11
25622: PUSH
25623: LD_EXP 40
25627: UNION
25628: PUSH
25629: LD_EXP 61
25633: UNION
25634: DIFF
25635: ST_TO_ADDR
// if tmp2 then
25636: LD_VAR 0 4
25640: IFFALSE 25658
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25642: LD_VAR 0 4
25646: PUSH
25647: LD_INT 1
25649: ARRAY
25650: PPUSH
25651: LD_STRING D6c-Sol1-1
25653: PPUSH
25654: CALL_OW 88
// if Lisa then
25658: LD_EXP 43
25662: IFFALSE 25676
// Say ( Lisa , D6c-Lisa-1 ) ;
25664: LD_EXP 43
25668: PPUSH
25669: LD_STRING D6c-Lisa-1
25671: PPUSH
25672: CALL_OW 88
// if Gary then
25676: LD_EXP 52
25680: IFFALSE 25694
// Say ( Gary , D6c-Gary-1 ) ;
25682: LD_EXP 52
25686: PPUSH
25687: LD_STRING D6c-Gary-1
25689: PPUSH
25690: CALL_OW 88
// if Donaldson then
25694: LD_EXP 44
25698: IFFALSE 25712
// Say ( Donaldson , D6c-Don-1 ) ;
25700: LD_EXP 44
25704: PPUSH
25705: LD_STRING D6c-Don-1
25707: PPUSH
25708: CALL_OW 88
// if tmp2 > 1 then
25712: LD_VAR 0 4
25716: PUSH
25717: LD_INT 1
25719: GREATER
25720: IFFALSE 25738
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
25722: LD_VAR 0 4
25726: PUSH
25727: LD_INT 2
25729: ARRAY
25730: PPUSH
25731: LD_STRING D6c-Sol2-1
25733: PPUSH
25734: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
25738: LD_VAR 0 11
25742: PPUSH
25743: LD_STRING D6c-Sol3-2
25745: PPUSH
25746: CALL_OW 88
// if IsInUnit ( JMM ) then
25750: LD_EXP 40
25754: PPUSH
25755: CALL_OW 310
25759: IFFALSE 25777
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
25761: LD_EXP 40
25765: PPUSH
25766: CALL_OW 310
25770: PPUSH
25771: CALL_OW 87
25775: GO 25786
// CenterNowOnUnits ( JMM ) ;
25777: LD_EXP 40
25781: PPUSH
25782: CALL_OW 87
// dwait ( 0 0$2 ) ;
25786: LD_INT 70
25788: PPUSH
25789: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
25793: LD_EXP 40
25797: PPUSH
25798: LD_STRING D6c-JMM-2
25800: PPUSH
25801: CALL_OW 88
// DialogueOff ;
25805: CALL_OW 7
// Video ( false ) ;
25809: LD_INT 0
25811: PPUSH
25812: CALL 104976 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
25816: LD_INT 22
25818: PUSH
25819: LD_INT 4
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PPUSH
25826: CALL_OW 69
25830: PPUSH
25831: LD_INT 1
25833: PPUSH
25834: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
25838: LD_INT 4
25840: PPUSH
25841: LD_INT 4
25843: PPUSH
25844: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
25848: LD_ADDR_VAR 0 1
25852: PUSH
25853: LD_INT 4
25855: PPUSH
25856: LD_INT 1
25858: PPUSH
25859: LD_INT 2
25861: PPUSH
25862: CALL 67599 0 3
25866: PUSH
25867: FOR_IN
25868: IFFALSE 25905
// if GetTech ( i , 1 ) <> state_researched then
25870: LD_VAR 0 1
25874: PPUSH
25875: LD_INT 1
25877: PPUSH
25878: CALL_OW 321
25882: PUSH
25883: LD_INT 2
25885: NONEQUAL
25886: IFFALSE 25903
// SetTech ( i , 1 , state_researched ) ;
25888: LD_VAR 0 1
25892: PPUSH
25893: LD_INT 1
25895: PPUSH
25896: LD_INT 2
25898: PPUSH
25899: CALL_OW 322
25903: GO 25867
25905: POP
25906: POP
// missionStage := 6 ;
25907: LD_ADDR_EXP 15
25911: PUSH
25912: LD_INT 6
25914: ST_TO_ADDR
// activeAttacks := true ;
25915: LD_ADDR_EXP 16
25919: PUSH
25920: LD_INT 1
25922: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
25923: LD_STRING M2
25925: PPUSH
25926: CALL_OW 337
// SaveForQuickRestart ;
25930: CALL_OW 22
// wait ( 0 0$40 ) ;
25934: LD_INT 1400
25936: PPUSH
25937: CALL_OW 67
// DialogueOn ;
25941: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
25945: LD_EXP 64
25949: PPUSH
25950: LD_STRING D7-Friend-1
25952: PPUSH
25953: CALL 108923 0 2
// Say ( JMM , D7-JMM-1 ) ;
25957: LD_EXP 40
25961: PPUSH
25962: LD_STRING D7-JMM-1
25964: PPUSH
25965: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
25969: LD_EXP 64
25973: PPUSH
25974: LD_STRING D7-Friend-2
25976: PPUSH
25977: CALL 108923 0 2
// Say ( JMM , D7-JMM-2 ) ;
25981: LD_EXP 40
25985: PPUSH
25986: LD_STRING D7-JMM-2
25988: PPUSH
25989: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
25993: LD_EXP 64
25997: PPUSH
25998: LD_STRING D7-Friend-3
26000: PPUSH
26001: CALL 108923 0 2
// Say ( JMM , D7-JMM-3 ) ;
26005: LD_EXP 40
26009: PPUSH
26010: LD_STRING D7-JMM-3
26012: PPUSH
26013: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
26017: LD_EXP 64
26021: PPUSH
26022: LD_STRING D7-Friend-4
26024: PPUSH
26025: CALL 108923 0 2
// Say ( JMM , D7-JMM-4 ) ;
26029: LD_EXP 40
26033: PPUSH
26034: LD_STRING D7-JMM-4
26036: PPUSH
26037: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
26041: LD_EXP 64
26045: PPUSH
26046: LD_STRING D7-Friend-5
26048: PPUSH
26049: CALL 108923 0 2
// Say ( JMM , D7-JMM-5 ) ;
26053: LD_EXP 40
26057: PPUSH
26058: LD_STRING D7-JMM-5
26060: PPUSH
26061: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
26065: LD_EXP 64
26069: PPUSH
26070: LD_STRING D7-Friend-6
26072: PPUSH
26073: CALL 108923 0 2
// Say ( JMM , D7-JMM-6 ) ;
26077: LD_EXP 40
26081: PPUSH
26082: LD_STRING D7-JMM-6
26084: PPUSH
26085: CALL_OW 88
// DialogueOff ;
26089: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
26093: LD_STRING Mlegion
26095: PPUSH
26096: CALL_OW 337
// skirmish := true ;
26100: LD_ADDR_EXP 98
26104: PUSH
26105: LD_INT 1
26107: ST_TO_ADDR
// RebuildKozlovFactory ;
26108: CALL 5036 0 0
// end ;
26112: PPOPN 13
26114: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
26115: LD_EXP 20
26119: PUSH
26120: LD_EXP 60
26124: PPUSH
26125: CALL_OW 300
26129: AND
26130: IFFALSE 26172
26132: GO 26134
26134: DISABLE
// begin enable ;
26135: ENABLE
// if IsInUnit ( Powell ) then
26136: LD_EXP 60
26140: PPUSH
26141: CALL_OW 310
26145: IFFALSE 26163
// CenterOnUnits ( IsInUnit ( Powell ) ) else
26147: LD_EXP 60
26151: PPUSH
26152: CALL_OW 310
26156: PPUSH
26157: CALL_OW 85
26161: GO 26172
// CenterOnUnits ( Powell ) ;
26163: LD_EXP 60
26167: PPUSH
26168: CALL_OW 85
// end ;
26172: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
26173: LD_INT 22
26175: PUSH
26176: LD_INT 8
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 34
26185: PUSH
26186: LD_INT 48
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: PPUSH
26197: CALL_OW 69
26201: IFFALSE 26475
26203: GO 26205
26205: DISABLE
26206: LD_INT 0
26208: PPUSH
26209: PPUSH
// begin if missionStage < 9 then
26210: LD_EXP 15
26214: PUSH
26215: LD_INT 9
26217: LESS
26218: IFFALSE 26228
// missionStage := 9 ;
26220: LD_ADDR_EXP 15
26224: PUSH
26225: LD_INT 9
26227: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26228: LD_ADDR_VAR 0 1
26232: PUSH
26233: LD_INT 22
26235: PUSH
26236: LD_INT 8
26238: PUSH
26239: EMPTY
26240: LIST
26241: LIST
26242: PUSH
26243: LD_INT 34
26245: PUSH
26246: LD_INT 48
26248: PUSH
26249: EMPTY
26250: LIST
26251: LIST
26252: PUSH
26253: EMPTY
26254: LIST
26255: LIST
26256: PPUSH
26257: CALL_OW 69
26261: PUSH
26262: LD_INT 1
26264: ARRAY
26265: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26266: LD_INT 175
26268: PPUSH
26269: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26273: LD_EXP 12
26277: PUSH
26278: LD_EXP 3
26282: PUSH
26283: LD_INT 0
26285: PUSH
26286: LD_INT 2
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: IN
26293: OR
26294: IFFALSE 26317
// target := [ 68 , 108 , 1 ] else
26296: LD_ADDR_VAR 0 2
26300: PUSH
26301: LD_INT 68
26303: PUSH
26304: LD_INT 108
26306: PUSH
26307: LD_INT 1
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: LIST
26314: ST_TO_ADDR
26315: GO 26336
// target := [ 181 , 88 , 2 ] ;
26317: LD_ADDR_VAR 0 2
26321: PUSH
26322: LD_INT 181
26324: PUSH
26325: LD_INT 88
26327: PUSH
26328: LD_INT 2
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26336: LD_VAR 0 1
26340: PPUSH
26341: LD_VAR 0 2
26345: PUSH
26346: LD_INT 1
26348: ARRAY
26349: PPUSH
26350: LD_VAR 0 2
26354: PUSH
26355: LD_INT 2
26357: ARRAY
26358: PPUSH
26359: CALL_OW 176
// if target [ 3 ] = 1 then
26363: LD_VAR 0 2
26367: PUSH
26368: LD_INT 3
26370: ARRAY
26371: PUSH
26372: LD_INT 1
26374: EQUAL
26375: IFFALSE 26391
// SayRadio ( Kurt , D12-Kurt-1 ) else
26377: LD_EXP 62
26381: PPUSH
26382: LD_STRING D12-Kurt-1
26384: PPUSH
26385: CALL_OW 94
26389: GO 26415
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26391: LD_EXP 62
26395: PPUSH
26396: LD_STRING D12a-Kurt-1
26398: PPUSH
26399: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26403: LD_EXP 77
26407: PPUSH
26408: LD_STRING D12a-Roth-1
26410: PPUSH
26411: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26415: LD_INT 350
26417: PPUSH
26418: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26422: LD_VAR 0 1
26426: PPUSH
26427: LD_INT 22
26429: PUSH
26430: LD_INT 8
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PUSH
26437: LD_INT 23
26439: PUSH
26440: LD_INT 2
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: LD_INT 30
26449: PUSH
26450: LD_INT 3
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: PPUSH
26462: CALL_OW 69
26466: PUSH
26467: LD_INT 1
26469: ARRAY
26470: PPUSH
26471: CALL_OW 228
// end ;
26475: PPOPN 2
26477: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26478: LD_EXP 62
26482: PPUSH
26483: CALL_OW 256
26487: PUSH
26488: LD_INT 999
26490: LESS
26491: PUSH
26492: LD_INT 22
26494: PUSH
26495: LD_INT 8
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: PUSH
26502: LD_INT 21
26504: PUSH
26505: LD_INT 1
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PUSH
26512: LD_INT 23
26514: PUSH
26515: LD_INT 2
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL_OW 69
26531: PUSH
26532: LD_INT 9
26534: PUSH
26535: LD_INT 8
26537: PUSH
26538: LD_INT 7
26540: PUSH
26541: LD_INT 6
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: LIST
26548: LIST
26549: PUSH
26550: LD_OWVAR 67
26554: ARRAY
26555: LESSEQUAL
26556: OR
26557: PUSH
26558: LD_INT 22
26560: PUSH
26561: LD_INT 8
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: PUSH
26568: LD_INT 34
26570: PUSH
26571: LD_INT 48
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PPUSH
26582: CALL_OW 69
26586: NOT
26587: AND
26588: PUSH
26589: LD_EXP 62
26593: PPUSH
26594: CALL_OW 302
26598: AND
26599: PUSH
26600: LD_INT 5
26602: PPUSH
26603: LD_INT 22
26605: PUSH
26606: LD_INT 1
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PPUSH
26613: CALL_OW 70
26617: AND
26618: IFFALSE 27362
26620: GO 26622
26622: DISABLE
26623: LD_INT 0
26625: PPUSH
26626: PPUSH
26627: PPUSH
// begin legionDestroyed := true ;
26628: LD_ADDR_EXP 22
26632: PUSH
26633: LD_INT 1
26635: ST_TO_ADDR
// DialogueOn ;
26636: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26640: LD_EXP 40
26644: PPUSH
26645: LD_STRING D13-JMM-1
26647: PPUSH
26648: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26652: LD_EXP 62
26656: PPUSH
26657: LD_STRING D13-Kurt-1
26659: PPUSH
26660: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26664: LD_EXP 40
26668: PPUSH
26669: LD_STRING D13-JMM-2
26671: PPUSH
26672: CALL_OW 88
// if FakeInfo then
26676: LD_EXP 12
26680: IFFALSE 26700
// begin Say ( Kurt , D13-Kurt-2 ) ;
26682: LD_EXP 62
26686: PPUSH
26687: LD_STRING D13-Kurt-2
26689: PPUSH
26690: CALL_OW 88
// DialogueOff ;
26694: CALL_OW 7
// exit ;
26698: GO 27362
// end ; if not KurtStatus then
26700: LD_EXP 3
26704: NOT
26705: IFFALSE 26721
// Say ( Kurt , D13-Kurt-2b ) else
26707: LD_EXP 62
26711: PPUSH
26712: LD_STRING D13-Kurt-2b
26714: PPUSH
26715: CALL_OW 88
26719: GO 26733
// Say ( Kurt , D13-Kurt-2a ) ;
26721: LD_EXP 62
26725: PPUSH
26726: LD_STRING D13-Kurt-2a
26728: PPUSH
26729: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
26733: LD_EXP 40
26737: PPUSH
26738: LD_STRING D13-JMM-3
26740: PPUSH
26741: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
26745: LD_EXP 62
26749: PPUSH
26750: LD_STRING D13-Kurt-3
26752: PPUSH
26753: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
26757: LD_EXP 40
26761: PPUSH
26762: LD_STRING D13-JMM-4
26764: PPUSH
26765: CALL_OW 88
// DialogueOff ;
26769: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
26773: LD_STRING MlegionOut
26775: PPUSH
26776: CALL_OW 337
// MC_Kill ( 3 ) ;
26780: LD_INT 3
26782: PPUSH
26783: CALL 37121 0 1
// KillUnit ( Kozlov ) ;
26787: LD_EXP 63
26791: PPUSH
26792: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
26796: LD_ADDR_VAR 0 1
26800: PUSH
26801: LD_INT 22
26803: PUSH
26804: LD_INT 8
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: PUSH
26811: LD_INT 23
26813: PUSH
26814: LD_INT 3
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: PUSH
26821: LD_INT 3
26823: PUSH
26824: LD_INT 21
26826: PUSH
26827: LD_INT 33
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: LIST
26842: PPUSH
26843: CALL_OW 69
26847: PUSH
26848: FOR_IN
26849: IFFALSE 26862
// KillUnit ( i ) ;
26851: LD_VAR 0 1
26855: PPUSH
26856: CALL_OW 66
26860: GO 26848
26862: POP
26863: POP
// ChangeSideFog ( 8 , 1 ) ;
26864: LD_INT 8
26866: PPUSH
26867: LD_INT 1
26869: PPUSH
26870: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
26874: LD_ADDR_VAR 0 2
26878: PUSH
26879: LD_INT 22
26881: PUSH
26882: LD_INT 8
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 21
26891: PUSH
26892: LD_INT 1
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PPUSH
26903: CALL_OW 69
26907: PUSH
26908: LD_EXP 63
26912: PUSH
26913: LD_EXP 62
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: DIFF
26922: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
26923: LD_VAR 0 2
26927: PUSH
26928: LD_INT 6
26930: PUSH
26931: LD_INT 5
26933: PUSH
26934: LD_INT 4
26936: PUSH
26937: LD_INT 3
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: PUSH
26946: LD_OWVAR 67
26950: ARRAY
26951: GREATEREQUAL
26952: IFFALSE 27104
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
26954: LD_ADDR_VAR 0 3
26958: PUSH
26959: LD_INT 6
26961: PUSH
26962: LD_INT 5
26964: PUSH
26965: LD_INT 4
26967: PUSH
26968: LD_INT 3
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: LIST
26975: LIST
26976: PUSH
26977: LD_OWVAR 67
26981: ARRAY
26982: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
26983: LD_ADDR_VAR 0 1
26987: PUSH
26988: DOUBLE
26989: LD_VAR 0 2
26993: PUSH
26994: LD_VAR 0 3
26998: PUSH
26999: LD_INT 1
27001: PLUS
27002: MINUS
27003: INC
27004: ST_TO_ADDR
27005: LD_INT 1
27007: PUSH
27008: FOR_DOWNTO
27009: IFFALSE 27100
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
27011: LD_ADDR_EXP 38
27015: PUSH
27016: LD_EXP 38
27020: PUSH
27021: LD_VAR 0 2
27025: PUSH
27026: LD_VAR 0 1
27030: ARRAY
27031: ADD
27032: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
27033: LD_VAR 0 2
27037: PUSH
27038: LD_VAR 0 1
27042: ARRAY
27043: PPUSH
27044: CALL_OW 310
27048: IFFALSE 27065
// ComExit ( tmp [ i ] ) ;
27050: LD_VAR 0 2
27054: PUSH
27055: LD_VAR 0 1
27059: ARRAY
27060: PPUSH
27061: CALL 105402 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
27065: LD_VAR 0 2
27069: PUSH
27070: LD_VAR 0 1
27074: ARRAY
27075: PPUSH
27076: LD_INT 34
27078: PUSH
27079: LD_INT 0
27081: PPUSH
27082: LD_INT 6
27084: PPUSH
27085: CALL_OW 12
27089: PLUS
27090: PPUSH
27091: LD_INT 1
27093: PPUSH
27094: CALL_OW 171
// end ;
27098: GO 27008
27100: POP
27101: POP
// end else
27102: GO 27114
// x := tmp ;
27104: LD_ADDR_VAR 0 3
27108: PUSH
27109: LD_VAR 0 2
27113: ST_TO_ADDR
// for i := tmp downto tmp - x do
27114: LD_ADDR_VAR 0 1
27118: PUSH
27119: DOUBLE
27120: LD_VAR 0 2
27124: INC
27125: ST_TO_ADDR
27126: LD_VAR 0 2
27130: PUSH
27131: LD_VAR 0 3
27135: MINUS
27136: PUSH
27137: FOR_DOWNTO
27138: IFFALSE 27192
// begin if IsInUnit ( tmp [ i ] ) then
27140: LD_VAR 0 2
27144: PUSH
27145: LD_VAR 0 1
27149: ARRAY
27150: PPUSH
27151: CALL_OW 310
27155: IFFALSE 27172
// ComExit ( tmp [ i ] ) ;
27157: LD_VAR 0 2
27161: PUSH
27162: LD_VAR 0 1
27166: ARRAY
27167: PPUSH
27168: CALL 105402 0 1
// SetSide ( tmp [ i ] , 1 ) ;
27172: LD_VAR 0 2
27176: PUSH
27177: LD_VAR 0 1
27181: ARRAY
27182: PPUSH
27183: LD_INT 1
27185: PPUSH
27186: CALL_OW 235
// end ;
27190: GO 27137
27192: POP
27193: POP
// wait ( 0 0$0.3 ) ;
27194: LD_INT 10
27196: PPUSH
27197: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
27201: LD_ADDR_VAR 0 1
27205: PUSH
27206: LD_INT 22
27208: PUSH
27209: LD_INT 8
27211: PUSH
27212: EMPTY
27213: LIST
27214: LIST
27215: PUSH
27216: LD_INT 21
27218: PUSH
27219: LD_INT 2
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PPUSH
27230: CALL_OW 69
27234: PUSH
27235: FOR_IN
27236: IFFALSE 27249
// KillUnit ( i ) ;
27238: LD_VAR 0 1
27242: PPUSH
27243: CALL_OW 66
27247: GO 27235
27249: POP
27250: POP
// SetSide ( Kurt , 1 ) ;
27251: LD_EXP 62
27255: PPUSH
27256: LD_INT 1
27258: PPUSH
27259: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
27263: LD_INT 22
27265: PUSH
27266: LD_INT 8
27268: PUSH
27269: EMPTY
27270: LIST
27271: LIST
27272: PUSH
27273: LD_INT 21
27275: PUSH
27276: LD_INT 3
27278: PUSH
27279: EMPTY
27280: LIST
27281: LIST
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PPUSH
27287: CALL_OW 69
27291: PPUSH
27292: LD_INT 1
27294: PPUSH
27295: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27299: LD_INT 8
27301: PPUSH
27302: LD_INT 1
27304: PPUSH
27305: LD_INT 1
27307: PPUSH
27308: LD_INT 1
27310: PPUSH
27311: CALL_OW 80
// wait ( 1 1$20 ) ;
27315: LD_INT 2800
27317: PPUSH
27318: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27322: LD_EXP 64
27326: PPUSH
27327: LD_INT 37
27329: PPUSH
27330: LD_INT 1
27332: PPUSH
27333: LD_INT 0
27335: PPUSH
27336: CALL_OW 48
// wait ( 0 0$1 ) ;
27340: LD_INT 35
27342: PPUSH
27343: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27347: LD_EXP 64
27351: PPUSH
27352: LD_INT 60
27354: PPUSH
27355: LD_INT 95
27357: PPUSH
27358: CALL_OW 111
// end ;
27362: PPOPN 3
27364: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27365: LD_EXP 22
27369: NOT
27370: PUSH
27371: LD_INT 22
27373: PUSH
27374: LD_INT 8
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: PUSH
27381: LD_INT 21
27383: PUSH
27384: LD_INT 1
27386: PUSH
27387: EMPTY
27388: LIST
27389: LIST
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PPUSH
27395: CALL_OW 69
27399: PUSH
27400: LD_INT 0
27402: EQUAL
27403: AND
27404: IFFALSE 27424
27406: GO 27408
27408: DISABLE
// begin legionDestroyed := true ;
27409: LD_ADDR_EXP 22
27413: PUSH
27414: LD_INT 1
27416: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27417: LD_STRING MlegionOut
27419: PPUSH
27420: CALL_OW 337
// end ;
27424: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27425: LD_EXP 38
27429: IFFALSE 27504
27431: GO 27433
27433: DISABLE
27434: LD_INT 0
27436: PPUSH
// begin enable ;
27437: ENABLE
// for i in legionEscapeUnits do
27438: LD_ADDR_VAR 0 1
27442: PUSH
27443: LD_EXP 38
27447: PUSH
27448: FOR_IN
27449: IFFALSE 27502
// begin if IsInArea ( i , legionEscapeArea ) then
27451: LD_VAR 0 1
27455: PPUSH
27456: LD_INT 31
27458: PPUSH
27459: CALL_OW 308
27463: IFFALSE 27476
// RemoveUnit ( i ) else
27465: LD_VAR 0 1
27469: PPUSH
27470: CALL_OW 64
27474: GO 27500
// if not HasTask ( i ) then
27476: LD_VAR 0 1
27480: PPUSH
27481: CALL_OW 314
27485: NOT
27486: IFFALSE 27500
// ComMoveToArea ( i , legionEscapeArea ) ;
27488: LD_VAR 0 1
27492: PPUSH
27493: LD_INT 31
27495: PPUSH
27496: CALL_OW 113
// end ;
27500: GO 27448
27502: POP
27503: POP
// end ;
27504: PPOPN 1
27506: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27507: LD_INT 1
27509: PPUSH
27510: LD_EXP 64
27514: PPUSH
27515: CALL_OW 292
27519: IFFALSE 27817
27521: GO 27523
27523: DISABLE
27524: LD_INT 0
27526: PPUSH
// begin wait ( 0 0$2 ) ;
27527: LD_INT 70
27529: PPUSH
27530: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27534: LD_EXP 64
27538: PPUSH
27539: CALL_OW 87
// DialogueOn ;
27543: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27547: LD_EXP 40
27551: PPUSH
27552: LD_STRING D14-JMM-1
27554: PPUSH
27555: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27559: LD_EXP 64
27563: PPUSH
27564: LD_STRING D14-Friend-1
27566: PPUSH
27567: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27571: LD_EXP 40
27575: PPUSH
27576: LD_STRING D14-JMM-2
27578: PPUSH
27579: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27583: LD_EXP 64
27587: PPUSH
27588: LD_STRING D14-Friend-2
27590: PPUSH
27591: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27595: LD_EXP 40
27599: PPUSH
27600: LD_STRING D14-JMM-3
27602: PPUSH
27603: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27607: LD_EXP 64
27611: PPUSH
27612: LD_STRING D14-Friend-3
27614: PPUSH
27615: CALL_OW 88
// DialogueOff ;
27619: CALL_OW 7
// dec = Query ( Q14 ) ;
27623: LD_ADDR_VAR 0 1
27627: PUSH
27628: LD_STRING Q14
27630: PPUSH
27631: CALL_OW 97
27635: ST_TO_ADDR
// if dec = 1 then
27636: LD_VAR 0 1
27640: PUSH
27641: LD_INT 1
27643: EQUAL
27644: IFFALSE 27678
// begin DialogueOn ;
27646: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27650: LD_EXP 40
27654: PPUSH
27655: LD_STRING D14a-JMM-1
27657: PPUSH
27658: CALL_OW 88
// DialogueOff ;
27662: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27666: LD_EXP 64
27670: PPUSH
27671: LD_INT 1
27673: PPUSH
27674: CALL_OW 235
// end ; if dec = 2 then
27678: LD_VAR 0 1
27682: PUSH
27683: LD_INT 2
27685: EQUAL
27686: IFFALSE 27739
// begin DialogueOn ;
27688: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
27692: LD_EXP 40
27696: PPUSH
27697: LD_STRING D14b-JMM-1
27699: PPUSH
27700: CALL_OW 88
// DialogueOff ;
27704: CALL_OW 7
// wait ( 0 0$1 ) ;
27708: LD_INT 35
27710: PPUSH
27711: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
27715: LD_EXP 64
27719: PPUSH
27720: LD_INT 9
27722: PPUSH
27723: LD_INT 2
27725: PPUSH
27726: CALL_OW 111
// AddComHold ( Friend ) ;
27730: LD_EXP 64
27734: PPUSH
27735: CALL_OW 200
// end ; if dec = 3 then
27739: LD_VAR 0 1
27743: PUSH
27744: LD_INT 3
27746: EQUAL
27747: IFFALSE 27817
// begin DialogueOn ;
27749: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
27753: LD_EXP 40
27757: PPUSH
27758: LD_STRING D14c-JMM-1
27760: PPUSH
27761: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
27765: LD_EXP 64
27769: PPUSH
27770: LD_STRING D14c-Friend-1
27772: PPUSH
27773: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
27777: LD_EXP 40
27781: PPUSH
27782: LD_STRING D14c-JMM-2
27784: PPUSH
27785: CALL_OW 88
// DialogueOff ;
27789: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
27793: LD_EXP 64
27797: PPUSH
27798: LD_INT 9
27800: PPUSH
27801: LD_INT 2
27803: PPUSH
27804: CALL_OW 111
// AddComHold ( Friend ) ;
27808: LD_EXP 64
27812: PPUSH
27813: CALL_OW 200
// end ; end ;
27817: PPOPN 1
27819: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
27820: LD_INT 9
27822: PPUSH
27823: LD_INT 2
27825: PPUSH
27826: CALL_OW 428
27830: PUSH
27831: LD_EXP 64
27835: EQUAL
27836: PUSH
27837: LD_EXP 64
27841: PPUSH
27842: CALL_OW 255
27846: PUSH
27847: LD_INT 8
27849: EQUAL
27850: AND
27851: IFFALSE 27865
27853: GO 27855
27855: DISABLE
// RemoveUnit ( Friend ) ;
27856: LD_EXP 64
27860: PPUSH
27861: CALL_OW 64
27865: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
27866: LD_EXP 14
27870: PUSH
27871: LD_INT 31500
27873: GREATEREQUAL
27874: PUSH
27875: LD_EXP 7
27879: AND
27880: PUSH
27881: LD_EXP 2
27885: AND
27886: IFFALSE 28316
27888: GO 27890
27890: DISABLE
27891: LD_INT 0
27893: PPUSH
27894: PPUSH
27895: PPUSH
// begin missionStage := 7 ;
27896: LD_ADDR_EXP 15
27900: PUSH
27901: LD_INT 7
27903: ST_TO_ADDR
// uc_side = 1 ;
27904: LD_ADDR_OWVAR 20
27908: PUSH
27909: LD_INT 1
27911: ST_TO_ADDR
// uc_nation = 1 ;
27912: LD_ADDR_OWVAR 21
27916: PUSH
27917: LD_INT 1
27919: ST_TO_ADDR
// for i = 1 to 5 do
27920: LD_ADDR_VAR 0 1
27924: PUSH
27925: DOUBLE
27926: LD_INT 1
27928: DEC
27929: ST_TO_ADDR
27930: LD_INT 5
27932: PUSH
27933: FOR_TO
27934: IFFALSE 28030
// begin vc_engine = 3 ;
27936: LD_ADDR_OWVAR 39
27940: PUSH
27941: LD_INT 3
27943: ST_TO_ADDR
// vc_control = 3 ;
27944: LD_ADDR_OWVAR 38
27948: PUSH
27949: LD_INT 3
27951: ST_TO_ADDR
// vc_chassis = 3 ;
27952: LD_ADDR_OWVAR 37
27956: PUSH
27957: LD_INT 3
27959: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27960: LD_ADDR_OWVAR 40
27964: PUSH
27965: LD_INT 5
27967: PUSH
27968: LD_INT 9
27970: PUSH
27971: LD_INT 7
27973: PUSH
27974: EMPTY
27975: LIST
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 1
27981: PPUSH
27982: LD_INT 3
27984: PPUSH
27985: CALL_OW 12
27989: ARRAY
27990: ST_TO_ADDR
// veh = CreateVehicle ;
27991: LD_ADDR_VAR 0 2
27995: PUSH
27996: CALL_OW 45
28000: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28001: LD_VAR 0 2
28005: PPUSH
28006: LD_INT 1
28008: PPUSH
28009: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28013: LD_VAR 0 2
28017: PPUSH
28018: LD_INT 19
28020: PPUSH
28021: LD_INT 0
28023: PPUSH
28024: CALL_OW 49
// end ;
28028: GO 27933
28030: POP
28031: POP
// vc_engine = 3 ;
28032: LD_ADDR_OWVAR 39
28036: PUSH
28037: LD_INT 3
28039: ST_TO_ADDR
// vc_control = 1 ;
28040: LD_ADDR_OWVAR 38
28044: PUSH
28045: LD_INT 1
28047: ST_TO_ADDR
// vc_chassis = 3 ;
28048: LD_ADDR_OWVAR 37
28052: PUSH
28053: LD_INT 3
28055: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
28056: LD_ADDR_OWVAR 40
28060: PUSH
28061: LD_INT 5
28063: PUSH
28064: LD_INT 9
28066: PUSH
28067: LD_INT 7
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: LIST
28074: PUSH
28075: LD_INT 1
28077: PPUSH
28078: LD_INT 3
28080: PPUSH
28081: CALL_OW 12
28085: ARRAY
28086: ST_TO_ADDR
// vehG = CreateVehicle ;
28087: LD_ADDR_VAR 0 3
28091: PUSH
28092: CALL_OW 45
28096: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
28097: LD_VAR 0 3
28101: PPUSH
28102: LD_INT 1
28104: PPUSH
28105: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
28109: LD_VAR 0 3
28113: PPUSH
28114: LD_INT 19
28116: PPUSH
28117: LD_INT 0
28119: PPUSH
28120: CALL_OW 49
// if JMMGirl = 1 then
28124: LD_EXP 7
28128: PUSH
28129: LD_INT 1
28131: EQUAL
28132: IFFALSE 28188
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
28134: LD_ADDR_EXP 41
28138: PUSH
28139: LD_STRING Joan
28141: PPUSH
28142: LD_INT 1
28144: PPUSH
28145: LD_STRING 14_
28147: PPUSH
28148: CALL 67536 0 3
28152: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
28153: LD_EXP 41
28157: PPUSH
28158: LD_VAR 0 3
28162: PPUSH
28163: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28167: LD_VAR 0 3
28171: PPUSH
28172: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28176: LD_EXP 41
28180: PPUSH
28181: LD_STRING D10BW-Joan-1
28183: PPUSH
28184: CALL_OW 94
// end ; if JMMGirl = 2 then
28188: LD_EXP 7
28192: PUSH
28193: LD_INT 2
28195: EQUAL
28196: IFFALSE 28252
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28198: LD_ADDR_EXP 43
28202: PUSH
28203: LD_STRING Lisa
28205: PPUSH
28206: LD_INT 1
28208: PPUSH
28209: LD_STRING 14_
28211: PPUSH
28212: CALL 67536 0 3
28216: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28217: LD_EXP 43
28221: PPUSH
28222: LD_VAR 0 3
28226: PPUSH
28227: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28231: LD_VAR 0 3
28235: PPUSH
28236: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28240: LD_EXP 43
28244: PPUSH
28245: LD_STRING D10BW-Lisa-1
28247: PPUSH
28248: CALL_OW 94
// end ; if JMMGirl = 3 then
28252: LD_EXP 7
28256: PUSH
28257: LD_INT 3
28259: EQUAL
28260: IFFALSE 28316
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28262: LD_ADDR_EXP 55
28266: PUSH
28267: LD_STRING Connie
28269: PPUSH
28270: LD_INT 1
28272: PPUSH
28273: LD_STRING 14_
28275: PPUSH
28276: CALL 67536 0 3
28280: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28281: LD_EXP 55
28285: PPUSH
28286: LD_VAR 0 3
28290: PPUSH
28291: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28295: LD_VAR 0 3
28299: PPUSH
28300: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28304: LD_EXP 55
28308: PPUSH
28309: LD_STRING D10BW-Con-1
28311: PPUSH
28312: CALL_OW 94
// end ; end ;
28316: PPOPN 3
28318: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28319: LD_EXP 14
28323: PUSH
28324: LD_INT 94500
28326: GREATEREQUAL
28327: IFFALSE 28739
28329: GO 28331
28331: DISABLE
28332: LD_INT 0
28334: PPUSH
28335: PPUSH
28336: PPUSH
// begin tmp := PrepareStevensSquad ;
28337: LD_ADDR_VAR 0 3
28341: PUSH
28342: CALL 2323 0 0
28346: ST_TO_ADDR
// if not tmp then
28347: LD_VAR 0 3
28351: NOT
28352: IFFALSE 28356
// exit ;
28354: GO 28739
// uc_side := 1 ;
28356: LD_ADDR_OWVAR 20
28360: PUSH
28361: LD_INT 1
28363: ST_TO_ADDR
// uc_nation := 1 ;
28364: LD_ADDR_OWVAR 21
28368: PUSH
28369: LD_INT 1
28371: ST_TO_ADDR
// for i in tmp do
28372: LD_ADDR_VAR 0 1
28376: PUSH
28377: LD_VAR 0 3
28381: PUSH
28382: FOR_IN
28383: IFFALSE 28480
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28385: LD_INT 3
28387: PPUSH
28388: LD_INT 3
28390: PPUSH
28391: LD_INT 1
28393: PPUSH
28394: LD_INT 5
28396: PUSH
28397: LD_INT 9
28399: PUSH
28400: LD_INT 7
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: LIST
28407: PUSH
28408: LD_INT 1
28410: PPUSH
28411: LD_INT 3
28413: PPUSH
28414: CALL_OW 12
28418: ARRAY
28419: PPUSH
28420: LD_INT 40
28422: PPUSH
28423: CALL 72551 0 5
// veh := CreateVehicle ;
28427: LD_ADDR_VAR 0 2
28431: PUSH
28432: CALL_OW 45
28436: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28437: LD_VAR 0 2
28441: PPUSH
28442: LD_INT 1
28444: PPUSH
28445: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28449: LD_VAR 0 2
28453: PPUSH
28454: LD_INT 19
28456: PPUSH
28457: LD_INT 0
28459: PPUSH
28460: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28464: LD_VAR 0 1
28468: PPUSH
28469: LD_VAR 0 2
28473: PPUSH
28474: CALL_OW 52
// end ;
28478: GO 28382
28480: POP
28481: POP
// missionStage := 8 ;
28482: LD_ADDR_EXP 15
28486: PUSH
28487: LD_INT 8
28489: ST_TO_ADDR
// DialogueOn ;
28490: CALL_OW 6
// if Stevens then
28494: LD_EXP 42
28498: IFFALSE 28612
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28500: LD_EXP 42
28504: PPUSH
28505: CALL_OW 310
28509: PPUSH
28510: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28514: LD_EXP 42
28518: PPUSH
28519: LD_STRING D8-Huck-1
28521: PPUSH
28522: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28526: LD_EXP 40
28530: PPUSH
28531: LD_STRING D8-JMM-1
28533: PPUSH
28534: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28538: LD_EXP 42
28542: PPUSH
28543: LD_STRING D8-Huck-2
28545: PPUSH
28546: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28550: LD_EXP 40
28554: PPUSH
28555: LD_STRING D8-JMM-2
28557: PPUSH
28558: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28562: LD_EXP 42
28566: PPUSH
28567: LD_STRING D8-Huck-3
28569: PPUSH
28570: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28574: LD_EXP 40
28578: PPUSH
28579: LD_STRING D8-JMM-3
28581: PPUSH
28582: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28586: LD_EXP 42
28590: PPUSH
28591: LD_STRING D8-Huck-4
28593: PPUSH
28594: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28598: LD_EXP 40
28602: PPUSH
28603: LD_STRING D8-JMM-4
28605: PPUSH
28606: CALL_OW 88
// end else
28610: GO 28722
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28612: LD_EXP 56
28616: PPUSH
28617: CALL_OW 310
28621: PPUSH
28622: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28626: LD_EXP 56
28630: PPUSH
28631: LD_STRING D8-Huck-1
28633: PPUSH
28634: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28638: LD_EXP 40
28642: PPUSH
28643: LD_STRING D8-JMM-1a
28645: PPUSH
28646: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28650: LD_EXP 56
28654: PPUSH
28655: LD_STRING D8-Huck-2
28657: PPUSH
28658: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28662: LD_EXP 40
28666: PPUSH
28667: LD_STRING D8-JMM-2
28669: PPUSH
28670: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28674: LD_EXP 56
28678: PPUSH
28679: LD_STRING D8-Huck-3
28681: PPUSH
28682: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28686: LD_EXP 40
28690: PPUSH
28691: LD_STRING D8-JMM-3
28693: PPUSH
28694: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
28698: LD_EXP 56
28702: PPUSH
28703: LD_STRING D8-Huck-4
28705: PPUSH
28706: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28710: LD_EXP 40
28714: PPUSH
28715: LD_STRING D8-JMM-4
28717: PPUSH
28718: CALL_OW 88
// end ; DialogueOff ;
28722: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
28726: LD_INT 25
28728: PPUSH
28729: LD_INT 1
28731: PPUSH
28732: LD_INT 1
28734: PPUSH
28735: CALL_OW 322
// end ;
28739: PPOPN 3
28741: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
28742: LD_EXP 73
28746: PPUSH
28747: CALL_OW 302
28751: PUSH
28752: LD_INT 1
28754: PPUSH
28755: LD_EXP 73
28759: PPUSH
28760: CALL_OW 292
28764: AND
28765: IFFALSE 29016
28767: GO 28769
28769: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
28770: LD_EXP 73
28774: PPUSH
28775: CALL_OW 87
// DialogueOn ;
28779: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
28783: LD_EXP 40
28787: PPUSH
28788: LD_STRING D10nB-JMM-1
28790: PPUSH
28791: CALL_OW 88
// if BurlakStatus = 1 then
28795: LD_EXP 9
28799: PUSH
28800: LD_INT 1
28802: EQUAL
28803: IFFALSE 28817
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
28805: LD_EXP 72
28809: PPUSH
28810: LD_STRING D10nB-Vse-1a
28812: PPUSH
28813: CALL_OW 94
// end ; if BurlakStatus = 0 then
28817: LD_EXP 9
28821: PUSH
28822: LD_INT 0
28824: EQUAL
28825: IFFALSE 28839
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
28827: LD_EXP 72
28831: PPUSH
28832: LD_STRING D10nB-Vse-1
28834: PPUSH
28835: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
28839: LD_EXP 40
28843: PPUSH
28844: LD_STRING D10nB-JMM-2
28846: PPUSH
28847: CALL_OW 88
// if KappaStatus then
28851: LD_EXP 2
28855: IFFALSE 28869
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
28857: LD_EXP 72
28861: PPUSH
28862: LD_STRING D10nB-Vse-5a
28864: PPUSH
28865: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
28869: LD_EXP 2
28873: NOT
28874: PUSH
28875: LD_EXP 6
28879: PUSH
28880: LD_INT 0
28882: EQUAL
28883: AND
28884: IFFALSE 29012
// begin if JMMGirl = 1 then
28886: LD_EXP 7
28890: PUSH
28891: LD_INT 1
28893: EQUAL
28894: IFFALSE 28944
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
28896: LD_EXP 72
28900: PPUSH
28901: LD_STRING D10nB-Vse-2
28903: PPUSH
28904: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
28908: LD_EXP 40
28912: PPUSH
28913: LD_STRING D10nB-JMM-3
28915: PPUSH
28916: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
28920: LD_EXP 72
28924: PPUSH
28925: LD_STRING D10nB-Vse-3
28927: PPUSH
28928: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
28932: LD_EXP 40
28936: PPUSH
28937: LD_STRING D10nB-JMM-4
28939: PPUSH
28940: CALL_OW 88
// end ; if JMMGirl = 2 then
28944: LD_EXP 7
28948: PUSH
28949: LD_INT 2
28951: EQUAL
28952: IFFALSE 28978
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
28954: LD_EXP 72
28958: PPUSH
28959: LD_STRING D10nB-Vse-4
28961: PPUSH
28962: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
28966: LD_EXP 40
28970: PPUSH
28971: LD_STRING D10nB-JMM-5
28973: PPUSH
28974: CALL_OW 88
// end ; if JMMGirl = 3 then
28978: LD_EXP 7
28982: PUSH
28983: LD_INT 3
28985: EQUAL
28986: IFFALSE 29012
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
28988: LD_EXP 72
28992: PPUSH
28993: LD_STRING D10nB-Vse-5
28995: PPUSH
28996: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
29000: LD_EXP 40
29004: PPUSH
29005: LD_STRING D10nB-JMM-6
29007: PPUSH
29008: CALL_OW 88
// end ; end ; DialogueOff ;
29012: CALL_OW 7
// end ;
29016: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
29017: LD_EXP 14
29021: PUSH
29022: LD_INT 115500
29024: GREATEREQUAL
29025: IFFALSE 29401
29027: GO 29029
29029: DISABLE
29030: LD_INT 0
29032: PPUSH
// begin missionStage := 10 ;
29033: LD_ADDR_EXP 15
29037: PUSH
29038: LD_INT 10
29040: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
29041: LD_ADDR_VAR 0 1
29045: PUSH
29046: LD_INT 22
29048: PUSH
29049: LD_INT 1
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 23
29058: PUSH
29059: LD_INT 1
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 26
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 3
29078: PUSH
29079: LD_INT 25
29081: PUSH
29082: LD_INT 12
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PUSH
29093: LD_INT 3
29095: PUSH
29096: LD_INT 25
29098: PUSH
29099: LD_INT 16
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: LIST
29115: LIST
29116: PPUSH
29117: CALL_OW 69
29121: PUSH
29122: LD_EXP 40
29126: PUSH
29127: LD_EXP 62
29131: PUSH
29132: LD_EXP 42
29136: PUSH
29137: LD_EXP 56
29141: PUSH
29142: LD_EXP 43
29146: PUSH
29147: LD_EXP 44
29151: PUSH
29152: LD_EXP 45
29156: PUSH
29157: LD_EXP 46
29161: PUSH
29162: LD_EXP 47
29166: PUSH
29167: LD_EXP 48
29171: PUSH
29172: LD_EXP 49
29176: PUSH
29177: LD_EXP 50
29181: PUSH
29182: LD_EXP 51
29186: PUSH
29187: LD_EXP 52
29191: PUSH
29192: LD_EXP 53
29196: PUSH
29197: LD_EXP 54
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: DIFF
29220: ST_TO_ADDR
// if not tmp and Brown then
29221: LD_VAR 0 1
29225: NOT
29226: PUSH
29227: LD_EXP 48
29231: AND
29232: IFFALSE 29247
// tmp := [ Brown ] ;
29234: LD_ADDR_VAR 0 1
29238: PUSH
29239: LD_EXP 48
29243: PUSH
29244: EMPTY
29245: LIST
29246: ST_TO_ADDR
// DialogueOn ;
29247: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29251: LD_VAR 0 1
29255: PUSH
29256: LD_INT 1
29258: ARRAY
29259: PPUSH
29260: LD_STRING D11-Sol1-1
29262: PPUSH
29263: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29267: LD_EXP 66
29271: PPUSH
29272: LD_STRING D11-Pla-1
29274: PPUSH
29275: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29279: LD_EXP 67
29283: PPUSH
29284: LD_STRING D11-Kov-1
29286: PPUSH
29287: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29291: LD_EXP 66
29295: PPUSH
29296: LD_STRING D11-Pla-2
29298: PPUSH
29299: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29303: LD_VAR 0 1
29307: PUSH
29308: LD_INT 1
29310: ARRAY
29311: PPUSH
29312: LD_STRING D11-Sol1-2
29314: PPUSH
29315: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29319: LD_EXP 40
29323: PPUSH
29324: LD_STRING D11-JMM-2
29326: PPUSH
29327: CALL_OW 88
// DialogueOff ;
29331: CALL_OW 7
// allowBehemothConstruct := true ;
29335: LD_ADDR_EXP 25
29339: PUSH
29340: LD_INT 1
29342: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29343: LD_STRING M4
29345: PPUSH
29346: CALL_OW 337
// BuildBehemoths ;
29350: CALL 7903 0 0
// repeat wait ( 15 15$00 ) ;
29354: LD_INT 31500
29356: PPUSH
29357: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29361: LD_EXP 27
29365: IFFALSE 29369
// break ;
29367: GO 29401
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29369: LD_INT 267
29371: PPUSH
29372: CALL_OW 274
29376: PPUSH
29377: LD_INT 1
29379: PPUSH
29380: CALL_OW 275
29384: PUSH
29385: LD_INT 1000
29387: GREATEREQUAL
29388: IFFALSE 29394
// BuildBehemoths ;
29390: CALL 7903 0 0
// until not behemothBuilders ;
29394: LD_EXP 75
29398: NOT
29399: IFFALSE 29354
// end ;
29401: PPOPN 1
29403: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29404: LD_EXP 75
29408: NOT
29409: PUSH
29410: LD_EXP 28
29414: NOT
29415: AND
29416: PUSH
29417: LD_EXP 25
29421: AND
29422: IFFALSE 29442
29424: GO 29426
29426: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29427: LD_STRING M4a
29429: PPUSH
29430: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29434: LD_ADDR_EXP 27
29438: PUSH
29439: LD_INT 1
29441: ST_TO_ADDR
// end ;
29442: END
// every 0 0$1 trigger behemothDone do
29443: LD_EXP 28
29447: IFFALSE 29459
29449: GO 29451
29451: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29452: LD_STRING M4b
29454: PPUSH
29455: CALL_OW 337
29459: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29460: LD_EXP 29
29464: NOT
29465: IFFALSE 29661
29467: GO 29469
29469: DISABLE
29470: LD_INT 0
29472: PPUSH
29473: PPUSH
// begin enable ;
29474: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29475: LD_ADDR_VAR 0 1
29479: PUSH
29480: LD_INT 3
29482: PPUSH
29483: CALL 105065 0 1
29487: ST_TO_ADDR
// if not tmp and not behemothDone then
29488: LD_VAR 0 1
29492: NOT
29493: PUSH
29494: LD_EXP 28
29498: NOT
29499: AND
29500: IFFALSE 29536
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29502: LD_ADDR_VAR 0 1
29506: PUSH
29507: LD_INT 22
29509: PUSH
29510: LD_INT 3
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 30
29519: PUSH
29520: LD_INT 37
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: PPUSH
29531: CALL_OW 69
29535: ST_TO_ADDR
// if not tmp then
29536: LD_VAR 0 1
29540: NOT
29541: IFFALSE 29545
// exit ;
29543: GO 29661
// for i in tmp do
29545: LD_ADDR_VAR 0 2
29549: PUSH
29550: LD_VAR 0 1
29554: PUSH
29555: FOR_IN
29556: IFFALSE 29659
// if See ( 1 , i ) then
29558: LD_INT 1
29560: PPUSH
29561: LD_VAR 0 2
29565: PPUSH
29566: CALL_OW 292
29570: IFFALSE 29657
// begin if GetType ( i ) = unit_building then
29572: LD_VAR 0 2
29576: PPUSH
29577: CALL_OW 247
29581: PUSH
29582: LD_INT 3
29584: EQUAL
29585: IFFALSE 29623
// begin disable ;
29587: DISABLE
// CenterNowOnUnits ( i ) ;
29588: LD_VAR 0 2
29592: PPUSH
29593: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29597: LD_EXP 40
29601: PPUSH
29602: LD_STRING D17a-JMM-1
29604: PPUSH
29605: CALL_OW 88
// seeBehemoth := true ;
29609: LD_ADDR_EXP 29
29613: PUSH
29614: LD_INT 1
29616: ST_TO_ADDR
// exit ;
29617: POP
29618: POP
29619: GO 29661
// end else
29621: GO 29657
// begin disable ;
29623: DISABLE
// CenterNowOnUnits ( i ) ;
29624: LD_VAR 0 2
29628: PPUSH
29629: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29633: LD_EXP 40
29637: PPUSH
29638: LD_STRING D17b-JMM-1
29640: PPUSH
29641: CALL_OW 88
// seeBehemoth := true ;
29645: LD_ADDR_EXP 29
29649: PUSH
29650: LD_INT 1
29652: ST_TO_ADDR
// exit ;
29653: POP
29654: POP
29655: GO 29661
// end ; end ;
29657: GO 29555
29659: POP
29660: POP
// end ;
29661: PPOPN 2
29663: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
29664: LD_EXP 14
29668: PUSH
29669: LD_INT 123200
29671: GREATEREQUAL
29672: IFFALSE 30872
29674: GO 29676
29676: DISABLE
29677: LD_INT 0
29679: PPUSH
29680: PPUSH
29681: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
29682: LD_INT 2
29684: PPUSH
29685: LD_INT 23
29687: PUSH
29688: LD_INT 3
29690: PUSH
29691: LD_INT 3
29693: PUSH
29694: LD_INT 48
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: PUSH
29703: EMPTY
29704: LIST
29705: PPUSH
29706: CALL 61148 0 2
// repeat wait ( 0 0$1 ) ;
29710: LD_INT 35
29712: PPUSH
29713: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
29717: LD_INT 22
29719: PUSH
29720: LD_INT 3
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PUSH
29727: LD_INT 34
29729: PUSH
29730: LD_INT 48
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PPUSH
29741: CALL_OW 69
29745: IFFALSE 29710
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
29747: LD_ADDR_VAR 0 1
29751: PUSH
29752: LD_INT 22
29754: PUSH
29755: LD_INT 3
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 34
29764: PUSH
29765: LD_INT 48
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PPUSH
29776: CALL_OW 69
29780: PUSH
29781: LD_INT 1
29783: ARRAY
29784: ST_TO_ADDR
// missionStage := 12 ;
29785: LD_ADDR_EXP 15
29789: PUSH
29790: LD_INT 12
29792: ST_TO_ADDR
// platonovHasBomb := true ;
29793: LD_ADDR_EXP 30
29797: PUSH
29798: LD_INT 1
29800: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
29801: LD_VAR 0 1
29805: PPUSH
29806: LD_INT 181
29808: PPUSH
29809: LD_INT 86
29811: PPUSH
29812: CALL_OW 171
// AddComHold ( bomb ) ;
29816: LD_VAR 0 1
29820: PPUSH
29821: CALL_OW 200
// wait ( 0 0$10 ) ;
29825: LD_INT 350
29827: PPUSH
29828: CALL_OW 67
// DialogueOn ;
29832: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
29836: LD_EXP 66
29840: PPUSH
29841: LD_STRING D15-Pla-1
29843: PPUSH
29844: CALL_OW 94
// dec = Query ( Q15a ) ;
29848: LD_ADDR_VAR 0 2
29852: PUSH
29853: LD_STRING Q15a
29855: PPUSH
29856: CALL_OW 97
29860: ST_TO_ADDR
// if dec = 1 then
29861: LD_VAR 0 2
29865: PUSH
29866: LD_INT 1
29868: EQUAL
29869: IFFALSE 29892
// begin Say ( JMM , D15a-JMM-1 ) ;
29871: LD_EXP 40
29875: PPUSH
29876: LD_STRING D15a-JMM-1
29878: PPUSH
29879: CALL_OW 88
// YouLost ( Surrender ) ;
29883: LD_STRING Surrender
29885: PPUSH
29886: CALL_OW 104
// exit ;
29890: GO 30872
// end ; if dec = 2 then
29892: LD_VAR 0 2
29896: PUSH
29897: LD_INT 2
29899: EQUAL
29900: IFFALSE 29969
// begin Say ( JMM , D15b-JMM-1 ) ;
29902: LD_EXP 40
29906: PPUSH
29907: LD_STRING D15b-JMM-1
29909: PPUSH
29910: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
29914: LD_EXP 66
29918: PPUSH
29919: LD_STRING D15b-Pla-1
29921: PPUSH
29922: CALL_OW 94
// DialogueOff ;
29926: CALL_OW 7
// wait ( 3 3$00 ) ;
29930: LD_INT 6300
29932: PPUSH
29933: CALL_OW 67
// DialogueOn ;
29937: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
29941: LD_EXP 40
29945: PPUSH
29946: LD_STRING D15d-JMM-1a
29948: PPUSH
29949: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29953: LD_EXP 66
29957: PPUSH
29958: LD_STRING D15d-Pla-1
29960: PPUSH
29961: CALL_OW 94
// DialogueOff ;
29965: CALL_OW 7
// end ; if dec = 3 then
29969: LD_VAR 0 2
29973: PUSH
29974: LD_INT 3
29976: EQUAL
29977: IFFALSE 30031
// begin Say ( JMM , D15c-JMM-1 ) ;
29979: LD_EXP 40
29983: PPUSH
29984: LD_STRING D15c-JMM-1
29986: PPUSH
29987: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
29991: LD_EXP 66
29995: PPUSH
29996: LD_STRING D15c-Pla-1
29998: PPUSH
29999: CALL_OW 94
// DialogueOff ;
30003: CALL_OW 7
// wait ( 0 0$15 ) ;
30007: LD_INT 525
30009: PPUSH
30010: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
30014: LD_VAR 0 1
30018: PPUSH
30019: LD_INT 60
30021: PPUSH
30022: LD_INT 95
30024: PPUSH
30025: CALL_OW 116
// exit ;
30029: GO 30872
// end ; if dec = 4 then
30031: LD_VAR 0 2
30035: PUSH
30036: LD_INT 4
30038: EQUAL
30039: IFFALSE 30069
// begin Say ( JMM , D15d-JMM-1 ) ;
30041: LD_EXP 40
30045: PPUSH
30046: LD_STRING D15d-JMM-1
30048: PPUSH
30049: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
30053: LD_EXP 66
30057: PPUSH
30058: LD_STRING D15d-Pla-1
30060: PPUSH
30061: CALL_OW 94
// DialogueOff ;
30065: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30069: LD_EXP 64
30073: PPUSH
30074: CALL_OW 302
30078: PUSH
30079: LD_EXP 64
30083: PPUSH
30084: CALL_OW 255
30088: PUSH
30089: LD_INT 1
30091: EQUAL
30092: AND
30093: PUSH
30094: LD_INT 22
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 34
30106: PUSH
30107: LD_INT 8
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PPUSH
30118: CALL_OW 69
30122: NOT
30123: AND
30124: IFFALSE 30773
// begin SetSide ( Friend , 8 ) ;
30126: LD_EXP 64
30130: PPUSH
30131: LD_INT 8
30133: PPUSH
30134: CALL_OW 235
// if IsInUnit ( Friend ) then
30138: LD_EXP 64
30142: PPUSH
30143: CALL_OW 310
30147: IFFALSE 30158
// ComExitBuilding ( Friend ) ;
30149: LD_EXP 64
30153: PPUSH
30154: CALL_OW 122
// if IsDriver ( Friend ) then
30158: LD_EXP 64
30162: PPUSH
30163: CALL 102620 0 1
30167: IFFALSE 30178
// ComExitVehicle ( Friend ) ;
30169: LD_EXP 64
30173: PPUSH
30174: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30178: LD_EXP 64
30182: PPUSH
30183: LD_INT 9
30185: PPUSH
30186: LD_INT 2
30188: PPUSH
30189: CALL_OW 171
// wait ( 0 0$05 ) ;
30193: LD_INT 175
30195: PPUSH
30196: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30200: LD_EXP 64
30204: PPUSH
30205: CALL_OW 87
// DialogueOn ;
30209: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30213: LD_EXP 40
30217: PPUSH
30218: LD_STRING D16-JMM-1
30220: PPUSH
30221: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30225: LD_EXP 64
30229: PPUSH
30230: LD_STRING D16-Friend-1
30232: PPUSH
30233: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30237: LD_EXP 40
30241: PPUSH
30242: LD_STRING D16-JMM-2
30244: PPUSH
30245: CALL_OW 88
// DialogueOff ;
30249: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30253: LD_EXP 64
30257: PPUSH
30258: LD_INT 1
30260: PPUSH
30261: CALL_OW 235
// ComHold ( Friend ) ;
30265: LD_EXP 64
30269: PPUSH
30270: CALL_OW 140
// wait ( 0 0$20 ) ;
30274: LD_INT 700
30276: PPUSH
30277: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30281: LD_EXP 64
30285: PPUSH
30286: LD_INT 9
30288: PPUSH
30289: LD_INT 2
30291: PPUSH
30292: CALL_OW 297
30296: PUSH
30297: LD_INT 30
30299: LESS
30300: IFFALSE 30369
// begin SetSide ( Friend , 8 ) ;
30302: LD_EXP 64
30306: PPUSH
30307: LD_INT 8
30309: PPUSH
30310: CALL_OW 235
// if IsInUnit ( Friend ) then
30314: LD_EXP 64
30318: PPUSH
30319: CALL_OW 310
30323: IFFALSE 30334
// ComExitBuilding ( Friend ) ;
30325: LD_EXP 64
30329: PPUSH
30330: CALL_OW 122
// if IsDriver ( Friend ) then
30334: LD_EXP 64
30338: PPUSH
30339: CALL 102620 0 1
30343: IFFALSE 30354
// ComExitVehicle ( Friend ) ;
30345: LD_EXP 64
30349: PPUSH
30350: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30354: LD_EXP 64
30358: PPUSH
30359: LD_INT 9
30361: PPUSH
30362: LD_INT 2
30364: PPUSH
30365: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30369: LD_INT 1050
30371: PPUSH
30372: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30376: LD_INT 22
30378: PUSH
30379: LD_INT 1
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 34
30388: PUSH
30389: LD_INT 8
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PPUSH
30400: CALL_OW 69
30404: NOT
30405: IFFALSE 30751
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30407: LD_ADDR_VAR 0 3
30411: PUSH
30412: LD_INT 22
30414: PUSH
30415: LD_INT 1
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 26
30424: PUSH
30425: LD_INT 1
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: LD_INT 3
30434: PUSH
30435: LD_INT 25
30437: PUSH
30438: LD_INT 12
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 25
30447: PUSH
30448: LD_INT 16
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: LIST
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: LIST
30464: PPUSH
30465: CALL_OW 69
30469: PUSH
30470: LD_EXP 40
30474: PUSH
30475: LD_EXP 42
30479: PUSH
30480: LD_EXP 56
30484: PUSH
30485: LD_EXP 43
30489: PUSH
30490: LD_EXP 44
30494: PUSH
30495: LD_EXP 45
30499: PUSH
30500: LD_EXP 46
30504: PUSH
30505: LD_EXP 47
30509: PUSH
30510: LD_EXP 48
30514: PUSH
30515: LD_EXP 49
30519: PUSH
30520: LD_EXP 50
30524: PUSH
30525: LD_EXP 51
30529: PUSH
30530: LD_EXP 52
30534: PUSH
30535: LD_EXP 53
30539: PUSH
30540: LD_EXP 54
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: LIST
30558: LIST
30559: LIST
30560: LIST
30561: DIFF
30562: ST_TO_ADDR
// DialogueOn ;
30563: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30567: LD_EXP 66
30571: PPUSH
30572: LD_STRING D16a-Pla-1
30574: PPUSH
30575: CALL_OW 94
// if Stevens then
30579: LD_EXP 42
30583: IFFALSE 30599
// Say ( Stevens , D16a-Huck-1 ) else
30585: LD_EXP 42
30589: PPUSH
30590: LD_STRING D16a-Huck-1
30592: PPUSH
30593: CALL_OW 88
30597: GO 30641
// if Baker then
30599: LD_EXP 56
30603: IFFALSE 30619
// Say ( Baker , D16a-Huck-1 ) else
30605: LD_EXP 56
30609: PPUSH
30610: LD_STRING D16a-Huck-1
30612: PPUSH
30613: CALL_OW 88
30617: GO 30641
// if tmp then
30619: LD_VAR 0 3
30623: IFFALSE 30641
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30625: LD_VAR 0 3
30629: PUSH
30630: LD_INT 1
30632: ARRAY
30633: PPUSH
30634: LD_STRING D16a-Sol1-1
30636: PPUSH
30637: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30641: LD_EXP 64
30645: PPUSH
30646: CALL_OW 255
30650: PUSH
30651: LD_INT 8
30653: EQUAL
30654: IFFALSE 30670
// Say ( JMM , D16a-JMM-1 ) else
30656: LD_EXP 40
30660: PPUSH
30661: LD_STRING D16a-JMM-1
30663: PPUSH
30664: CALL_OW 88
30668: GO 30730
// begin Say ( JMM , D16a-JMM-1a ) ;
30670: LD_EXP 40
30674: PPUSH
30675: LD_STRING D16a-JMM-1a
30677: PPUSH
30678: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
30682: LD_EXP 64
30686: PPUSH
30687: LD_STRING D16a-Friend-1
30689: PPUSH
30690: CALL_OW 88
// ComExitBuilding ( Friend ) ;
30694: LD_EXP 64
30698: PPUSH
30699: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
30703: LD_EXP 64
30707: PPUSH
30708: LD_INT 191
30710: PPUSH
30711: LD_INT 103
30713: PPUSH
30714: CALL_OW 171
// SetSide ( Friend , 3 ) ;
30718: LD_EXP 64
30722: PPUSH
30723: LD_INT 3
30725: PPUSH
30726: CALL_OW 235
// end ; DialogueOff ;
30730: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
30734: LD_VAR 0 1
30738: PPUSH
30739: LD_INT 60
30741: PPUSH
30742: LD_INT 95
30744: PPUSH
30745: CALL_OW 116
// end else
30749: GO 30771
// begin DialogueOn ;
30751: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30755: LD_EXP 66
30759: PPUSH
30760: LD_STRING D16c-Pla-1
30762: PPUSH
30763: CALL_OW 94
// DialogueOff ;
30767: CALL_OW 7
// end ; end else
30771: GO 30872
// begin wait ( 3 3$00 ) ;
30773: LD_INT 6300
30775: PPUSH
30776: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30780: LD_INT 22
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 34
30792: PUSH
30793: LD_INT 8
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PPUSH
30804: CALL_OW 69
30808: NOT
30809: IFFALSE 30852
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
30811: LD_EXP 66
30815: PPUSH
30816: LD_STRING D16b-Pla-1
30818: PPUSH
30819: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
30823: LD_EXP 40
30827: PPUSH
30828: LD_STRING D16b-JMM-1
30830: PPUSH
30831: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
30835: LD_VAR 0 1
30839: PPUSH
30840: LD_INT 60
30842: PPUSH
30843: LD_INT 95
30845: PPUSH
30846: CALL_OW 116
// end else
30850: GO 30872
// begin DialogueOn ;
30852: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30856: LD_EXP 66
30860: PPUSH
30861: LD_STRING D16c-Pla-1
30863: PPUSH
30864: CALL_OW 94
// DialogueOff ;
30868: CALL_OW 7
// end ; end ; end ;
30872: PPOPN 3
30874: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
30875: LD_EXP 14
30879: PUSH
30880: LD_INT 126000
30882: GREATEREQUAL
30883: PUSH
30884: LD_EXP 23
30888: NOT
30889: AND
30890: PUSH
30891: LD_EXP 77
30895: PPUSH
30896: CALL_OW 302
30900: AND
30901: IFFALSE 31259
30903: GO 30905
30905: DISABLE
30906: LD_INT 0
30908: PPUSH
// begin missionStage = 11 ;
30909: LD_ADDR_EXP 15
30913: PUSH
30914: LD_INT 11
30916: ST_TO_ADDR
// DialogueOn ;
30917: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
30921: LD_EXP 77
30925: PPUSH
30926: LD_STRING D9-Roth-1
30928: PPUSH
30929: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
30933: LD_EXP 40
30937: PPUSH
30938: LD_STRING D9-JMM-1
30940: PPUSH
30941: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
30945: LD_EXP 77
30949: PPUSH
30950: LD_STRING D9-Roth-2
30952: PPUSH
30953: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
30957: LD_EXP 77
30961: PPUSH
30962: LD_STRING D9-Roth-2a
30964: PPUSH
30965: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
30969: LD_EXP 66
30973: PPUSH
30974: LD_STRING D9-Pla-2
30976: PPUSH
30977: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
30981: LD_EXP 77
30985: PPUSH
30986: LD_STRING D9-Roth-3
30988: PPUSH
30989: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
30993: LD_EXP 66
30997: PPUSH
30998: LD_STRING D9-Pla-3
31000: PPUSH
31001: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
31005: LD_EXP 77
31009: PPUSH
31010: LD_STRING D9-Roth-4
31012: PPUSH
31013: CALL_OW 94
// dec = Query ( Q9 ) ;
31017: LD_ADDR_VAR 0 1
31021: PUSH
31022: LD_STRING Q9
31024: PPUSH
31025: CALL_OW 97
31029: ST_TO_ADDR
// if dec = 1 then
31030: LD_VAR 0 1
31034: PUSH
31035: LD_INT 1
31037: EQUAL
31038: IFFALSE 31052
// SayRadio ( Roth , D9a-Roth-1 ) ;
31040: LD_EXP 77
31044: PPUSH
31045: LD_STRING D9a-Roth-1
31047: PPUSH
31048: CALL_OW 94
// if dec = 2 then
31052: LD_VAR 0 1
31056: PUSH
31057: LD_INT 2
31059: EQUAL
31060: IFFALSE 31086
// begin Say ( JMM , D9b-JMM-1 ) ;
31062: LD_EXP 40
31066: PPUSH
31067: LD_STRING D9b-JMM-1
31069: PPUSH
31070: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
31074: LD_EXP 77
31078: PPUSH
31079: LD_STRING D9b-Roth-1
31081: PPUSH
31082: CALL_OW 94
// end ; if dec = 3 then
31086: LD_VAR 0 1
31090: PUSH
31091: LD_INT 3
31093: EQUAL
31094: IFFALSE 31156
// begin Say ( JMM , D9c-JMM-1 ) ;
31096: LD_EXP 40
31100: PPUSH
31101: LD_STRING D9c-JMM-1
31103: PPUSH
31104: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
31108: LD_EXP 77
31112: PPUSH
31113: LD_STRING D9c-Roth-1
31115: PPUSH
31116: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
31120: LD_EXP 40
31124: PPUSH
31125: LD_STRING D9c-JMM-2
31127: PPUSH
31128: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
31132: LD_EXP 77
31136: PPUSH
31137: LD_STRING D9c-Roth-2
31139: PPUSH
31140: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
31144: LD_EXP 40
31148: PPUSH
31149: LD_STRING D9c-JMM-3
31151: PPUSH
31152: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
31156: LD_EXP 77
31160: PPUSH
31161: LD_STRING D9c-Roth-3
31163: PPUSH
31164: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
31168: LD_EXP 77
31172: PPUSH
31173: LD_STRING D9cont-Roth-1
31175: PPUSH
31176: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
31180: LD_EXP 40
31184: PPUSH
31185: LD_STRING D9cont-JMM-1
31187: PPUSH
31188: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
31192: LD_EXP 77
31196: PPUSH
31197: LD_STRING D9cont-Roth-2
31199: PPUSH
31200: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
31204: LD_EXP 40
31208: PPUSH
31209: LD_STRING D9cont-JMM-2
31211: PPUSH
31212: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31216: LD_EXP 77
31220: PPUSH
31221: LD_STRING D9cont-Roth-3
31223: PPUSH
31224: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31228: LD_EXP 40
31232: PPUSH
31233: LD_STRING D9cont-JMM-3
31235: PPUSH
31236: CALL_OW 88
// DialogueOff ;
31240: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31244: LD_STRING M3
31246: PPUSH
31247: CALL_OW 337
// allianceActive := true ;
31251: LD_ADDR_EXP 31
31255: PUSH
31256: LD_INT 1
31258: ST_TO_ADDR
// end ;
31259: PPOPN 1
31261: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31262: LD_INT 1
31264: PPUSH
31265: LD_INT 126
31267: PPUSH
31268: CALL_OW 292
31272: PUSH
31273: LD_EXP 66
31277: PPUSH
31278: CALL_OW 310
31282: AND
31283: IFFALSE 31363
31285: GO 31287
31287: DISABLE
31288: LD_INT 0
31290: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31291: LD_EXP 66
31295: PPUSH
31296: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31300: LD_ADDR_VAR 0 1
31304: PUSH
31305: LD_INT 4
31307: PPUSH
31308: LD_INT 22
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PPUSH
31318: CALL_OW 70
31322: PPUSH
31323: LD_EXP 66
31327: PPUSH
31328: CALL_OW 74
31332: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31333: LD_EXP 66
31337: PPUSH
31338: LD_VAR 0 1
31342: PUSH
31343: LD_INT 1
31345: ARRAY
31346: PPUSH
31347: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
31351: LD_EXP 66
31355: PPUSH
31356: LD_STRING D18-Pla-1
31358: PPUSH
31359: CALL_OW 88
// end ;
31363: PPOPN 1
31365: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31366: LD_EXP 66
31370: PPUSH
31371: CALL_OW 301
31375: PUSH
31376: LD_EXP 69
31380: PPUSH
31381: CALL_OW 301
31385: AND
31386: PUSH
31387: LD_INT 22
31389: PUSH
31390: LD_INT 3
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 21
31399: PUSH
31400: LD_INT 1
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 50
31409: PUSH
31410: EMPTY
31411: LIST
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: LIST
31417: PPUSH
31418: CALL_OW 69
31422: PUSH
31423: LD_INT 7
31425: PUSH
31426: LD_INT 8
31428: PUSH
31429: LD_INT 9
31431: PUSH
31432: LD_INT 10
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: PUSH
31441: LD_OWVAR 67
31445: ARRAY
31446: LESS
31447: AND
31448: IFFALSE 32247
31450: GO 31452
31452: DISABLE
31453: LD_INT 0
31455: PPUSH
31456: PPUSH
31457: PPUSH
31458: PPUSH
// begin MC_Kill ( 2 ) ;
31459: LD_INT 2
31461: PPUSH
31462: CALL 37121 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31466: LD_INT 1
31468: PPUSH
31469: LD_INT 3
31471: PPUSH
31472: LD_INT 1
31474: PPUSH
31475: LD_INT 1
31477: PPUSH
31478: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31482: LD_ADDR_VAR 0 2
31486: PUSH
31487: LD_INT 22
31489: PUSH
31490: LD_INT 3
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 21
31499: PUSH
31500: LD_INT 1
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 50
31509: PUSH
31510: EMPTY
31511: LIST
31512: PUSH
31513: LD_INT 26
31515: PUSH
31516: LD_INT 1
31518: PUSH
31519: EMPTY
31520: LIST
31521: LIST
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: PPUSH
31529: CALL_OW 69
31533: ST_TO_ADDR
// if not tmp then
31534: LD_VAR 0 2
31538: NOT
31539: IFFALSE 31595
// begin uc_side = 3 ;
31541: LD_ADDR_OWVAR 20
31545: PUSH
31546: LD_INT 3
31548: ST_TO_ADDR
// uc_nation = 3 ;
31549: LD_ADDR_OWVAR 21
31553: PUSH
31554: LD_INT 3
31556: ST_TO_ADDR
// hc_name =  ;
31557: LD_ADDR_OWVAR 26
31561: PUSH
31562: LD_STRING 
31564: ST_TO_ADDR
// hc_gallery =  ;
31565: LD_ADDR_OWVAR 33
31569: PUSH
31570: LD_STRING 
31572: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31573: LD_INT 1
31575: PPUSH
31576: LD_INT 10
31578: PPUSH
31579: CALL_OW 381
// tmp = CreateHuman ;
31583: LD_ADDR_VAR 0 2
31587: PUSH
31588: CALL_OW 44
31592: ST_TO_ADDR
// end else
31593: GO 31609
// tmp := tmp [ 1 ] ;
31595: LD_ADDR_VAR 0 2
31599: PUSH
31600: LD_VAR 0 2
31604: PUSH
31605: LD_INT 1
31607: ARRAY
31608: ST_TO_ADDR
// DialogueOn ;
31609: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31613: LD_VAR 0 2
31617: PPUSH
31618: LD_STRING DSurrenderRussians-RSol1-1a
31620: PPUSH
31621: CALL_OW 94
// DialogueOff ;
31625: CALL_OW 7
// russianDestroyed := true ;
31629: LD_ADDR_EXP 21
31633: PUSH
31634: LD_INT 1
31636: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
31637: LD_ADDR_VAR 0 1
31641: PUSH
31642: LD_INT 22
31644: PUSH
31645: LD_INT 6
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PPUSH
31652: CALL_OW 69
31656: PUSH
31657: FOR_IN
31658: IFFALSE 31671
// KillUnit ( i ) ;
31660: LD_VAR 0 1
31664: PPUSH
31665: CALL_OW 66
31669: GO 31657
31671: POP
31672: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
31673: LD_INT 22
31675: PUSH
31676: LD_INT 3
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 21
31685: PUSH
31686: LD_INT 1
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PPUSH
31697: CALL_OW 69
31701: PPUSH
31702: CALL_OW 122
// wait ( 0 0$1 ) ;
31706: LD_INT 35
31708: PPUSH
31709: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
31713: LD_INT 22
31715: PUSH
31716: LD_INT 3
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 21
31725: PUSH
31726: LD_INT 1
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PPUSH
31737: CALL_OW 69
31741: PPUSH
31742: LD_INT 25
31744: PPUSH
31745: CALL_OW 173
// wait ( 0 0$35 ) ;
31749: LD_INT 1225
31751: PPUSH
31752: CALL_OW 67
// PrepareOmarInvasion ;
31756: CALL 14772 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
31760: LD_ADDR_VAR 0 2
31764: PUSH
31765: LD_EXP 95
31769: PPUSH
31770: CALL_OW 250
31774: PUSH
31775: LD_EXP 95
31779: PPUSH
31780: CALL_OW 251
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
31789: LD_VAR 0 2
31793: PUSH
31794: LD_INT 1
31796: ARRAY
31797: PPUSH
31798: LD_VAR 0 2
31802: PUSH
31803: LD_INT 2
31805: ARRAY
31806: PPUSH
31807: LD_INT 1
31809: PPUSH
31810: LD_INT 8
31812: NEG
31813: PPUSH
31814: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
31818: LD_EXP 95
31822: PPUSH
31823: CALL_OW 87
// DialogueOn ;
31827: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
31831: LD_EXP 40
31835: PPUSH
31836: LD_STRING D19-JMM-1
31838: PPUSH
31839: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
31843: LD_ADDR_VAR 0 3
31847: PUSH
31848: LD_INT 22
31850: PUSH
31851: LD_INT 1
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: LD_INT 26
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 2
31870: PUSH
31871: LD_INT 25
31873: PUSH
31874: LD_INT 1
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 25
31883: PUSH
31884: LD_INT 2
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 25
31893: PUSH
31894: LD_INT 3
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 25
31903: PUSH
31904: LD_INT 4
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 25
31913: PUSH
31914: LD_INT 5
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 25
31923: PUSH
31924: LD_INT 8
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: LIST
31944: PPUSH
31945: CALL_OW 69
31949: PUSH
31950: LD_EXP 40
31954: PUSH
31955: LD_EXP 41
31959: PUSH
31960: LD_EXP 62
31964: PUSH
31965: LD_EXP 42
31969: PUSH
31970: LD_EXP 43
31974: PUSH
31975: LD_EXP 44
31979: PUSH
31980: LD_EXP 45
31984: PUSH
31985: LD_EXP 46
31989: PUSH
31990: LD_EXP 47
31994: PUSH
31995: LD_EXP 48
31999: PUSH
32000: LD_EXP 49
32004: PUSH
32005: LD_EXP 50
32009: PUSH
32010: LD_EXP 51
32014: PUSH
32015: LD_EXP 52
32019: PUSH
32020: LD_EXP 53
32024: PUSH
32025: LD_EXP 54
32029: PUSH
32030: LD_EXP 55
32034: PUSH
32035: LD_EXP 56
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: DIFF
32060: ST_TO_ADDR
// if tmp2 then
32061: LD_VAR 0 3
32065: IFFALSE 32083
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
32067: LD_VAR 0 3
32071: PUSH
32072: LD_INT 1
32074: ARRAY
32075: PPUSH
32076: LD_STRING D19-Sol1-1
32078: PPUSH
32079: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
32083: LD_EXP 40
32087: PPUSH
32088: LD_STRING D19-JMM-2
32090: PPUSH
32091: CALL_OW 88
// DialogueOff ;
32095: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
32099: LD_VAR 0 2
32103: PUSH
32104: LD_INT 1
32106: ARRAY
32107: PPUSH
32108: LD_VAR 0 2
32112: PUSH
32113: LD_INT 2
32115: ARRAY
32116: PPUSH
32117: LD_INT 1
32119: PPUSH
32120: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
32124: LD_STRING M5
32126: PPUSH
32127: CALL_OW 337
// omarOnMotherLode := false ;
32131: LD_ADDR_VAR 0 4
32135: PUSH
32136: LD_INT 0
32138: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
32139: LD_INT 35
32141: PPUSH
32142: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
32146: LD_EXP 95
32150: PPUSH
32151: LD_INT 215
32153: PPUSH
32154: LD_INT 100
32156: PPUSH
32157: CALL_OW 297
32161: PUSH
32162: LD_INT 10
32164: LESS
32165: PUSH
32166: LD_VAR 0 4
32170: NOT
32171: AND
32172: IFFALSE 32206
// begin omarOnMotherLode := true ;
32174: LD_ADDR_VAR 0 4
32178: PUSH
32179: LD_INT 1
32181: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
32182: LD_EXP 40
32186: PPUSH
32187: LD_STRING D19b-JMM-1
32189: PPUSH
32190: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
32194: LD_EXP 95
32198: PPUSH
32199: LD_STRING DOmarContam-Omar-1
32201: PPUSH
32202: CALL_OW 88
// end ; until IsDead ( Omar ) ;
32206: LD_EXP 95
32210: PPUSH
32211: CALL_OW 301
32215: IFFALSE 32139
// Say ( JMM , D19a-JMM-1 ) ;
32217: LD_EXP 40
32221: PPUSH
32222: LD_STRING D19a-JMM-1
32224: PPUSH
32225: CALL_OW 88
// if Heike then
32229: LD_EXP 96
32233: IFFALSE 32247
// Say ( Heike , D19a-Hke-1 ) ;
32235: LD_EXP 96
32239: PPUSH
32240: LD_STRING D19a-Hke-1
32242: PPUSH
32243: CALL_OW 88
// end ;
32247: PPOPN 4
32249: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
32250: LD_INT 22
32252: PUSH
32253: LD_INT 3
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 21
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PPUSH
32274: CALL_OW 69
32278: PUSH
32279: LD_EXP 21
32283: AND
32284: IFFALSE 32352
32286: GO 32288
32288: DISABLE
32289: LD_INT 0
32291: PPUSH
32292: PPUSH
// begin enable ;
32293: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32294: LD_ADDR_VAR 0 2
32298: PUSH
32299: LD_INT 25
32301: PPUSH
32302: LD_INT 22
32304: PUSH
32305: LD_INT 3
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PPUSH
32312: CALL_OW 70
32316: ST_TO_ADDR
// if not tmp then
32317: LD_VAR 0 2
32321: NOT
32322: IFFALSE 32326
// exit ;
32324: GO 32352
// for i in tmp do
32326: LD_ADDR_VAR 0 1
32330: PUSH
32331: LD_VAR 0 2
32335: PUSH
32336: FOR_IN
32337: IFFALSE 32350
// RemoveUnit ( i ) ;
32339: LD_VAR 0 1
32343: PPUSH
32344: CALL_OW 64
32348: GO 32336
32350: POP
32351: POP
// end ;
32352: PPOPN 2
32354: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32355: LD_INT 22
32357: PUSH
32358: LD_INT 7
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 21
32367: PUSH
32368: LD_INT 1
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PPUSH
32379: CALL_OW 69
32383: PUSH
32384: LD_INT 6
32386: LESS
32387: IFFALSE 32855
32389: GO 32391
32391: DISABLE
32392: LD_INT 0
32394: PPUSH
32395: PPUSH
// begin MC_Kill ( 1 ) ;
32396: LD_INT 1
32398: PPUSH
32399: CALL 37121 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32403: LD_INT 7
32405: PPUSH
32406: LD_INT 1
32408: PPUSH
32409: LD_INT 1
32411: PPUSH
32412: LD_INT 1
32414: PPUSH
32415: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32419: LD_ADDR_VAR 0 1
32423: PUSH
32424: LD_INT 22
32426: PUSH
32427: LD_INT 7
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 26
32436: PUSH
32437: LD_INT 1
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PPUSH
32448: CALL_OW 69
32452: PUSH
32453: LD_EXP 77
32457: DIFF
32458: ST_TO_ADDR
// if tmp then
32459: LD_VAR 0 1
32463: IFFALSE 32481
// tmp := tmp [ 1 ] else
32465: LD_ADDR_VAR 0 1
32469: PUSH
32470: LD_VAR 0 1
32474: PUSH
32475: LD_INT 1
32477: ARRAY
32478: ST_TO_ADDR
32479: GO 32517
// begin uc_side := 7 ;
32481: LD_ADDR_OWVAR 20
32485: PUSH
32486: LD_INT 7
32488: ST_TO_ADDR
// uc_nation := 1 ;
32489: LD_ADDR_OWVAR 21
32493: PUSH
32494: LD_INT 1
32496: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32497: LD_INT 1
32499: PPUSH
32500: LD_INT 8
32502: PPUSH
32503: CALL_OW 384
// tmp := CreateHuman ;
32507: LD_ADDR_VAR 0 1
32511: PUSH
32512: CALL_OW 44
32516: ST_TO_ADDR
// end ; DialogueOn ;
32517: CALL_OW 6
// if IsOK ( Roth ) then
32521: LD_EXP 77
32525: PPUSH
32526: CALL_OW 302
32530: IFFALSE 32544
// Say ( JMM , DAb-JMM-1 ) ;
32532: LD_EXP 40
32536: PPUSH
32537: LD_STRING DAb-JMM-1
32539: PPUSH
32540: CALL_OW 88
// if IsOK ( Roth ) then
32544: LD_EXP 77
32548: PPUSH
32549: CALL_OW 302
32553: IFFALSE 32577
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32555: LD_EXP 77
32559: PPUSH
32560: LD_STRING DSurrenderAlliance-Roth-1
32562: PPUSH
32563: CALL_OW 88
// RothCaptured := true ;
32567: LD_ADDR_EXP 33
32571: PUSH
32572: LD_INT 1
32574: ST_TO_ADDR
// end else
32575: GO 32589
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32577: LD_VAR 0 1
32581: PPUSH
32582: LD_STRING DSurrenderAlliance-Sci1-1
32584: PPUSH
32585: CALL_OW 88
// DialogueOff ;
32589: CALL_OW 7
// allianceDestroyed := true ;
32593: LD_ADDR_EXP 23
32597: PUSH
32598: LD_INT 1
32600: ST_TO_ADDR
// if capturedUnit = 0 then
32601: LD_EXP 34
32605: PUSH
32606: LD_INT 0
32608: EQUAL
32609: IFFALSE 32618
// SetAchievement ( ACH_ALLIANCE ) ;
32611: LD_STRING ACH_ALLIANCE
32613: PPUSH
32614: CALL_OW 543
// if trueAmericans then
32618: LD_EXP 35
32622: IFFALSE 32698
// begin if trueAmericans = 1 then
32624: LD_EXP 35
32628: PUSH
32629: LD_INT 1
32631: EQUAL
32632: IFFALSE 32648
// Say ( JMM , DAb-JMM-1a ) else
32634: LD_EXP 40
32638: PPUSH
32639: LD_STRING DAb-JMM-1a
32641: PPUSH
32642: CALL_OW 88
32646: GO 32660
// Say ( JMM , DAb-JMM-1b ) ;
32648: LD_EXP 40
32652: PPUSH
32653: LD_STRING DAb-JMM-1b
32655: PPUSH
32656: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
32660: LD_EXP 35
32664: PPUSH
32665: CALL_OW 87
// for i in trueAmericans do
32669: LD_ADDR_VAR 0 2
32673: PUSH
32674: LD_EXP 35
32678: PUSH
32679: FOR_IN
32680: IFFALSE 32696
// SetSide ( i , 1 ) ;
32682: LD_VAR 0 2
32686: PPUSH
32687: LD_INT 1
32689: PPUSH
32690: CALL_OW 235
32694: GO 32679
32696: POP
32697: POP
// end ; repeat wait ( 0 0$1 ) ;
32698: LD_INT 35
32700: PPUSH
32701: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
32705: LD_ADDR_VAR 0 2
32709: PUSH
32710: LD_INT 22
32712: PUSH
32713: LD_INT 7
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 21
32722: PUSH
32723: LD_INT 1
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PPUSH
32734: CALL_OW 69
32738: PUSH
32739: FOR_IN
32740: IFFALSE 32822
// begin if IsInUnit ( i ) then
32742: LD_VAR 0 2
32746: PPUSH
32747: CALL_OW 310
32751: IFFALSE 32762
// ComExitBuilding ( i ) ;
32753: LD_VAR 0 2
32757: PPUSH
32758: CALL_OW 122
// if IsDriver ( i ) then
32762: LD_VAR 0 2
32766: PPUSH
32767: CALL 102620 0 1
32771: IFFALSE 32782
// ComExitVehicle ( i ) ;
32773: LD_VAR 0 2
32777: PPUSH
32778: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
32782: LD_VAR 0 2
32786: PPUSH
32787: LD_INT 26
32789: PPUSH
32790: CALL_OW 308
32794: NOT
32795: IFFALSE 32811
// AddComMoveToArea ( i , allianceEscapeArea ) else
32797: LD_VAR 0 2
32801: PPUSH
32802: LD_INT 26
32804: PPUSH
32805: CALL_OW 173
32809: GO 32820
// RemoveUnit ( i ) ;
32811: LD_VAR 0 2
32815: PPUSH
32816: CALL_OW 64
// end ;
32820: GO 32739
32822: POP
32823: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
32824: LD_INT 22
32826: PUSH
32827: LD_INT 7
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 21
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PPUSH
32848: CALL_OW 69
32852: NOT
32853: IFFALSE 32698
// end ;
32855: PPOPN 2
32857: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
32858: LD_INT 0
32860: PPUSH
32861: PPUSH
// if not unit then
32862: LD_VAR 0 1
32866: NOT
32867: IFFALSE 32871
// exit ;
32869: GO 34369
// DoNotAttack ( 7 , unit ) ;
32871: LD_INT 7
32873: PPUSH
32874: LD_VAR 0 1
32878: PPUSH
32879: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
32883: LD_VAR 0 1
32887: PPUSH
32888: LD_INT 260
32890: PPUSH
32891: LD_INT 235
32893: PPUSH
32894: LD_INT 3
32896: PPUSH
32897: LD_INT 1
32899: PPUSH
32900: CALL_OW 483
// SetSide ( unit , 4 ) ;
32904: LD_VAR 0 1
32908: PPUSH
32909: LD_INT 4
32911: PPUSH
32912: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
32916: LD_ADDR_EXP 34
32920: PUSH
32921: LD_EXP 34
32925: PUSH
32926: LD_INT 1
32928: PLUS
32929: ST_TO_ADDR
// wait ( 0 0$2 ) ;
32930: LD_INT 70
32932: PPUSH
32933: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
32937: LD_INT 260
32939: PPUSH
32940: LD_INT 235
32942: PPUSH
32943: LD_INT 1
32945: PPUSH
32946: LD_INT 8
32948: NEG
32949: PPUSH
32950: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
32954: LD_VAR 0 1
32958: PPUSH
32959: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
32963: LD_VAR 0 1
32967: PPUSH
32968: LD_EXP 77
32972: PPUSH
32973: CALL_OW 119
// DialogueOn ;
32977: CALL_OW 6
// case unit of JMM :
32981: LD_VAR 0 1
32985: PUSH
32986: LD_EXP 40
32990: DOUBLE
32991: EQUAL
32992: IFTRUE 32996
32994: GO 33011
32996: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
32997: LD_EXP 40
33001: PPUSH
33002: LD_STRING DA1-JMM-1
33004: PPUSH
33005: CALL_OW 91
33009: GO 33453
33011: LD_EXP 41
33015: DOUBLE
33016: EQUAL
33017: IFTRUE 33021
33019: GO 33036
33021: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
33022: LD_EXP 41
33026: PPUSH
33027: LD_STRING DA1-Joan-1
33029: PPUSH
33030: CALL_OW 91
33034: GO 33453
33036: LD_EXP 43
33040: DOUBLE
33041: EQUAL
33042: IFTRUE 33046
33044: GO 33061
33046: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
33047: LD_EXP 43
33051: PPUSH
33052: LD_STRING DA1-Lisa-1
33054: PPUSH
33055: CALL_OW 91
33059: GO 33453
33061: LD_EXP 44
33065: DOUBLE
33066: EQUAL
33067: IFTRUE 33071
33069: GO 33086
33071: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
33072: LD_EXP 44
33076: PPUSH
33077: LD_STRING DA1-Don-1
33079: PPUSH
33080: CALL_OW 91
33084: GO 33453
33086: LD_EXP 51
33090: DOUBLE
33091: EQUAL
33092: IFTRUE 33096
33094: GO 33111
33096: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
33097: LD_EXP 51
33101: PPUSH
33102: LD_STRING DA1-Corn-1
33104: PPUSH
33105: CALL_OW 91
33109: GO 33453
33111: LD_EXP 47
33115: DOUBLE
33116: EQUAL
33117: IFTRUE 33121
33119: GO 33136
33121: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
33122: LD_EXP 47
33126: PPUSH
33127: LD_STRING DA1-Den-1
33129: PPUSH
33130: CALL_OW 91
33134: GO 33453
33136: LD_EXP 45
33140: DOUBLE
33141: EQUAL
33142: IFTRUE 33146
33144: GO 33161
33146: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
33147: LD_EXP 45
33151: PPUSH
33152: LD_STRING DA1-Bobby-1
33154: PPUSH
33155: CALL_OW 91
33159: GO 33453
33161: LD_EXP 49
33165: DOUBLE
33166: EQUAL
33167: IFTRUE 33171
33169: GO 33186
33171: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
33172: LD_EXP 49
33176: PPUSH
33177: LD_STRING DA1-Glad-1
33179: PPUSH
33180: CALL_OW 91
33184: GO 33453
33186: LD_EXP 46
33190: DOUBLE
33191: EQUAL
33192: IFTRUE 33196
33194: GO 33211
33196: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
33197: LD_EXP 46
33201: PPUSH
33202: LD_STRING DA1-Cyrus-1
33204: PPUSH
33205: CALL_OW 91
33209: GO 33453
33211: LD_EXP 42
33215: DOUBLE
33216: EQUAL
33217: IFTRUE 33221
33219: GO 33236
33221: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
33222: LD_EXP 42
33226: PPUSH
33227: LD_STRING DA1-Huck-1
33229: PPUSH
33230: CALL_OW 91
33234: GO 33453
33236: LD_EXP 56
33240: DOUBLE
33241: EQUAL
33242: IFTRUE 33246
33244: GO 33261
33246: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
33247: LD_EXP 56
33251: PPUSH
33252: LD_STRING DA1-Huck-1
33254: PPUSH
33255: CALL_OW 91
33259: GO 33453
33261: LD_EXP 48
33265: DOUBLE
33266: EQUAL
33267: IFTRUE 33271
33269: GO 33286
33271: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33272: LD_EXP 48
33276: PPUSH
33277: LD_STRING DA1-Brown-1
33279: PPUSH
33280: CALL_OW 91
33284: GO 33453
33286: LD_EXP 52
33290: DOUBLE
33291: EQUAL
33292: IFTRUE 33296
33294: GO 33311
33296: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33297: LD_EXP 52
33301: PPUSH
33302: LD_STRING DA1-Gary-1
33304: PPUSH
33305: CALL_OW 91
33309: GO 33453
33311: LD_EXP 55
33315: DOUBLE
33316: EQUAL
33317: IFTRUE 33321
33319: GO 33336
33321: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33322: LD_EXP 55
33326: PPUSH
33327: LD_STRING DA1-Con-1
33329: PPUSH
33330: CALL_OW 91
33334: GO 33453
33336: LD_EXP 62
33340: DOUBLE
33341: EQUAL
33342: IFTRUE 33346
33344: GO 33361
33346: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33347: LD_EXP 62
33351: PPUSH
33352: LD_STRING DA1-Kurt-1
33354: PPUSH
33355: CALL_OW 91
33359: GO 33453
33361: LD_EXP 54
33365: DOUBLE
33366: EQUAL
33367: IFTRUE 33371
33369: GO 33386
33371: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33372: LD_EXP 54
33376: PPUSH
33377: LD_STRING DA1-Yam-1
33379: PPUSH
33380: CALL_OW 91
33384: GO 33453
33386: LD_EXP 53
33390: DOUBLE
33391: EQUAL
33392: IFTRUE 33396
33394: GO 33411
33396: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33397: LD_EXP 53
33401: PPUSH
33402: LD_STRING DA1-Frank-1
33404: PPUSH
33405: CALL_OW 91
33409: GO 33453
33411: POP
// begin if GetSex ( unit ) = sex_male then
33412: LD_VAR 0 1
33416: PPUSH
33417: CALL_OW 258
33421: PUSH
33422: LD_INT 1
33424: EQUAL
33425: IFFALSE 33441
// ForceSay ( unit , DA1-Sol1-1 ) else
33427: LD_VAR 0 1
33431: PPUSH
33432: LD_STRING DA1-Sol1-1
33434: PPUSH
33435: CALL_OW 91
33439: GO 33453
// ForceSay ( unit , DA1-FSol1-1 ) ;
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_STRING DA1-FSol1-1
33448: PPUSH
33449: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33453: LD_EXP 77
33457: PPUSH
33458: LD_STRING DA-Roth-1
33460: PPUSH
33461: CALL_OW 88
// if capturedUnit = 1 then
33465: LD_EXP 34
33469: PUSH
33470: LD_INT 1
33472: EQUAL
33473: IFFALSE 33501
// begin Say ( Simms , DA-Sim-1 ) ;
33475: LD_EXP 78
33479: PPUSH
33480: LD_STRING DA-Sim-1
33482: PPUSH
33483: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33487: LD_EXP 77
33491: PPUSH
33492: LD_STRING DA-Roth-2
33494: PPUSH
33495: CALL_OW 88
// end else
33499: GO 33513
// Say ( Simms , DA-Sim-2 ) ;
33501: LD_EXP 78
33505: PPUSH
33506: LD_STRING DA-Sim-2
33508: PPUSH
33509: CALL_OW 88
// case unit of JMM :
33513: LD_VAR 0 1
33517: PUSH
33518: LD_EXP 40
33522: DOUBLE
33523: EQUAL
33524: IFTRUE 33528
33526: GO 33543
33528: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33529: LD_EXP 40
33533: PPUSH
33534: LD_STRING DA1-JMM-1a
33536: PPUSH
33537: CALL_OW 91
33541: GO 34050
33543: LD_EXP 41
33547: DOUBLE
33548: EQUAL
33549: IFTRUE 33553
33551: GO 33568
33553: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33554: LD_EXP 41
33558: PPUSH
33559: LD_STRING DA1-Joan-1a
33561: PPUSH
33562: CALL_OW 91
33566: GO 34050
33568: LD_EXP 43
33572: DOUBLE
33573: EQUAL
33574: IFTRUE 33578
33576: GO 33593
33578: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33579: LD_EXP 43
33583: PPUSH
33584: LD_STRING DA1-Lisa-1a
33586: PPUSH
33587: CALL_OW 91
33591: GO 34050
33593: LD_EXP 44
33597: DOUBLE
33598: EQUAL
33599: IFTRUE 33603
33601: GO 33618
33603: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33604: LD_EXP 44
33608: PPUSH
33609: LD_STRING DA1-Don-1a
33611: PPUSH
33612: CALL_OW 91
33616: GO 34050
33618: LD_EXP 51
33622: DOUBLE
33623: EQUAL
33624: IFTRUE 33628
33626: GO 33643
33628: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33629: LD_EXP 51
33633: PPUSH
33634: LD_STRING DA1-Corn-1a
33636: PPUSH
33637: CALL_OW 91
33641: GO 34050
33643: LD_EXP 47
33647: DOUBLE
33648: EQUAL
33649: IFTRUE 33653
33651: GO 33668
33653: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
33654: LD_EXP 47
33658: PPUSH
33659: LD_STRING DA1-Den-1a
33661: PPUSH
33662: CALL_OW 91
33666: GO 34050
33668: LD_EXP 45
33672: DOUBLE
33673: EQUAL
33674: IFTRUE 33678
33676: GO 33693
33678: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
33679: LD_EXP 45
33683: PPUSH
33684: LD_STRING DA1-Bobby-1a
33686: PPUSH
33687: CALL_OW 91
33691: GO 34050
33693: LD_EXP 49
33697: DOUBLE
33698: EQUAL
33699: IFTRUE 33703
33701: GO 33718
33703: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
33704: LD_EXP 49
33708: PPUSH
33709: LD_STRING DA1-Glad-1a
33711: PPUSH
33712: CALL_OW 91
33716: GO 34050
33718: LD_EXP 46
33722: DOUBLE
33723: EQUAL
33724: IFTRUE 33728
33726: GO 33743
33728: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
33729: LD_EXP 46
33733: PPUSH
33734: LD_STRING DA1-Cyrus-1a
33736: PPUSH
33737: CALL_OW 91
33741: GO 34050
33743: LD_EXP 42
33747: DOUBLE
33748: EQUAL
33749: IFTRUE 33753
33751: GO 33768
33753: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
33754: LD_EXP 42
33758: PPUSH
33759: LD_STRING DA1-Huck-1a
33761: PPUSH
33762: CALL_OW 91
33766: GO 34050
33768: LD_EXP 56
33772: DOUBLE
33773: EQUAL
33774: IFTRUE 33778
33776: GO 33793
33778: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
33779: LD_EXP 56
33783: PPUSH
33784: LD_STRING DA1-Huck-1a
33786: PPUSH
33787: CALL_OW 91
33791: GO 34050
33793: LD_EXP 48
33797: DOUBLE
33798: EQUAL
33799: IFTRUE 33803
33801: GO 33818
33803: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
33804: LD_EXP 48
33808: PPUSH
33809: LD_STRING DA1-Brown-1a
33811: PPUSH
33812: CALL_OW 91
33816: GO 34050
33818: LD_EXP 52
33822: DOUBLE
33823: EQUAL
33824: IFTRUE 33828
33826: GO 33843
33828: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
33829: LD_EXP 52
33833: PPUSH
33834: LD_STRING DA1-Gary-1a
33836: PPUSH
33837: CALL_OW 91
33841: GO 34050
33843: LD_EXP 55
33847: DOUBLE
33848: EQUAL
33849: IFTRUE 33853
33851: GO 33868
33853: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
33854: LD_EXP 55
33858: PPUSH
33859: LD_STRING DA1-Con-1a
33861: PPUSH
33862: CALL_OW 91
33866: GO 34050
33868: LD_EXP 62
33872: DOUBLE
33873: EQUAL
33874: IFTRUE 33878
33876: GO 33893
33878: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
33879: LD_EXP 62
33883: PPUSH
33884: LD_STRING DA1-Kurt-1a
33886: PPUSH
33887: CALL_OW 91
33891: GO 34050
33893: LD_EXP 54
33897: DOUBLE
33898: EQUAL
33899: IFTRUE 33903
33901: GO 33918
33903: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
33904: LD_EXP 54
33908: PPUSH
33909: LD_STRING DA1-Yam-1a
33911: PPUSH
33912: CALL_OW 91
33916: GO 34050
33918: LD_EXP 53
33922: DOUBLE
33923: EQUAL
33924: IFTRUE 33928
33926: GO 33943
33928: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
33929: LD_EXP 53
33933: PPUSH
33934: LD_STRING DA1-Frank-1a
33936: PPUSH
33937: CALL_OW 91
33941: GO 34050
33943: POP
// begin join := rand ( 0 , 1 ) ;
33944: LD_ADDR_VAR 0 3
33948: PUSH
33949: LD_INT 0
33951: PPUSH
33952: LD_INT 1
33954: PPUSH
33955: CALL_OW 12
33959: ST_TO_ADDR
// if join then
33960: LD_VAR 0 3
33964: IFFALSE 34009
// begin if GetSex ( unit ) = sex_male then
33966: LD_VAR 0 1
33970: PPUSH
33971: CALL_OW 258
33975: PUSH
33976: LD_INT 1
33978: EQUAL
33979: IFFALSE 33995
// ForceSay ( unit , DA1-Sol1-1b ) else
33981: LD_VAR 0 1
33985: PPUSH
33986: LD_STRING DA1-Sol1-1b
33988: PPUSH
33989: CALL_OW 91
33993: GO 34007
// ForceSay ( unit , DA1-FSol1-1b ) ;
33995: LD_VAR 0 1
33999: PPUSH
34000: LD_STRING DA1-FSol1-1b
34002: PPUSH
34003: CALL_OW 91
// end else
34007: GO 34050
// begin if GetSex ( unit ) = sex_male then
34009: LD_VAR 0 1
34013: PPUSH
34014: CALL_OW 258
34018: PUSH
34019: LD_INT 1
34021: EQUAL
34022: IFFALSE 34038
// ForceSay ( unit , DA1-Sol1-1a ) else
34024: LD_VAR 0 1
34028: PPUSH
34029: LD_STRING DA1-Sol1-1a
34031: PPUSH
34032: CALL_OW 91
34036: GO 34050
// ForceSay ( unit , DA1-FSol1-1a ) ;
34038: LD_VAR 0 1
34042: PPUSH
34043: LD_STRING DA1-FSol1-1a
34045: PPUSH
34046: CALL_OW 91
// end ; end ; end ; if unit = JMM then
34050: LD_VAR 0 1
34054: PUSH
34055: LD_EXP 40
34059: EQUAL
34060: IFFALSE 34071
// begin YouLost ( JMMCaptured ) ;
34062: LD_STRING JMMCaptured
34064: PPUSH
34065: CALL_OW 104
// exit ;
34069: GO 34369
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
34071: LD_VAR 0 1
34075: PUSH
34076: LD_EXP 44
34080: PUSH
34081: LD_EXP 47
34085: PUSH
34086: LD_EXP 45
34090: PUSH
34091: LD_EXP 42
34095: PUSH
34096: LD_EXP 56
34100: PUSH
34101: LD_EXP 48
34105: PUSH
34106: LD_EXP 54
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: IN
34120: PUSH
34121: LD_VAR 0 3
34125: OR
34126: IFFALSE 34225
// begin Say ( Roth , DA-Roth-3 ) ;
34128: LD_EXP 77
34132: PPUSH
34133: LD_STRING DA-Roth-3
34135: PPUSH
34136: CALL_OW 88
// SetSide ( unit , 7 ) ;
34140: LD_VAR 0 1
34144: PPUSH
34145: LD_INT 7
34147: PPUSH
34148: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
34152: LD_ADDR_EXP 100
34156: PUSH
34157: LD_EXP 100
34161: PPUSH
34162: LD_INT 1
34164: PPUSH
34165: LD_EXP 100
34169: PUSH
34170: LD_INT 1
34172: ARRAY
34173: PUSH
34174: LD_VAR 0 1
34178: ADD
34179: PPUSH
34180: CALL_OW 1
34184: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34185: LD_INT 260
34187: PPUSH
34188: LD_INT 235
34190: PPUSH
34191: LD_INT 1
34193: PPUSH
34194: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34198: LD_VAR 0 1
34202: PPUSH
34203: LD_INT 1000
34205: PPUSH
34206: CALL_OW 234
// DialogueOff ;
34210: CALL_OW 7
// ComFree ( unit ) ;
34214: LD_VAR 0 1
34218: PPUSH
34219: CALL_OW 139
// end else
34223: GO 34306
// begin Say ( Roth , DA-Roth-3a ) ;
34225: LD_EXP 77
34229: PPUSH
34230: LD_STRING DA-Roth-3a
34232: PPUSH
34233: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
34237: LD_ADDR_EXP 35
34241: PUSH
34242: LD_EXP 35
34246: PUSH
34247: LD_VAR 0 1
34251: ADD
34252: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34253: LD_INT 260
34255: PPUSH
34256: LD_INT 235
34258: PPUSH
34259: LD_INT 1
34261: PPUSH
34262: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34266: LD_VAR 0 1
34270: PPUSH
34271: LD_INT 1000
34273: PPUSH
34274: CALL_OW 234
// DialogueOff ;
34278: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34282: LD_VAR 0 1
34286: PPUSH
34287: LD_INT 272
34289: PPUSH
34290: LD_INT 254
34292: PPUSH
34293: CALL_OW 111
// AddComHold ( unit ) ;
34297: LD_VAR 0 1
34301: PPUSH
34302: CALL_OW 200
// end ; if capturedUnit = 1 then
34306: LD_EXP 34
34310: PUSH
34311: LD_INT 1
34313: EQUAL
34314: IFFALSE 34369
// begin DialogueOn ;
34316: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34320: LD_EXP 40
34324: PPUSH
34325: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34329: LD_EXP 40
34333: PPUSH
34334: LD_STRING DAa-JMM-1
34336: PPUSH
34337: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34341: LD_EXP 40
34345: PPUSH
34346: LD_STRING DAa-JMM-1a
34348: PPUSH
34349: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34353: LD_EXP 40
34357: PPUSH
34358: LD_STRING DAa-JMM-1b
34360: PPUSH
34361: CALL_OW 88
// DialogueOff ;
34365: CALL_OW 7
// end ; end ;
34369: LD_VAR 0 2
34373: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34374: LD_EXP 15
34378: PUSH
34379: LD_INT 13
34381: GREATEREQUAL
34382: PUSH
34383: LD_INT 22
34385: PUSH
34386: LD_INT 2
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 21
34395: PUSH
34396: LD_INT 1
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PPUSH
34407: CALL_OW 69
34411: PUSH
34412: LD_INT 0
34414: EQUAL
34415: AND
34416: PUSH
34417: LD_INT 22
34419: PUSH
34420: LD_INT 2
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 33
34429: PUSH
34430: LD_INT 5
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 21
34439: PUSH
34440: LD_INT 2
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 50
34449: PUSH
34450: EMPTY
34451: LIST
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: PPUSH
34459: CALL_OW 69
34463: PUSH
34464: LD_INT 0
34466: EQUAL
34467: AND
34468: PUSH
34469: LD_EXP 21
34473: AND
34474: PUSH
34475: LD_EXP 22
34479: AND
34480: PUSH
34481: LD_EXP 23
34485: AND
34486: IFFALSE 35175
34488: GO 34490
34490: DISABLE
34491: LD_INT 0
34493: PPUSH
34494: PPUSH
34495: PPUSH
// begin m1 := false ;
34496: LD_ADDR_VAR 0 1
34500: PUSH
34501: LD_INT 0
34503: ST_TO_ADDR
// m2 := false ;
34504: LD_ADDR_VAR 0 2
34508: PUSH
34509: LD_INT 0
34511: ST_TO_ADDR
// m3 := false ;
34512: LD_ADDR_VAR 0 3
34516: PUSH
34517: LD_INT 0
34519: ST_TO_ADDR
// if not bombExploded then
34520: LD_EXP 37
34524: NOT
34525: IFFALSE 34534
// SetAchievement ( ACH_SIBROCKET ) ;
34527: LD_STRING ACH_SIBROCKET
34529: PPUSH
34530: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34534: LD_EXP 64
34538: PPUSH
34539: CALL_OW 255
34543: PUSH
34544: LD_INT 1
34546: EQUAL
34547: PUSH
34548: LD_EXP 64
34552: PPUSH
34553: CALL_OW 302
34557: AND
34558: IFFALSE 34574
// begin wait ( 3 ) ;
34560: LD_INT 3
34562: PPUSH
34563: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34567: LD_STRING ACH_OPO
34569: PPUSH
34570: CALL_OW 543
// end ; if tick <= 120 120$00 then
34574: LD_OWVAR 1
34578: PUSH
34579: LD_INT 252000
34581: LESSEQUAL
34582: IFFALSE 34598
// begin wait ( 3 ) ;
34584: LD_INT 3
34586: PPUSH
34587: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34591: LD_STRING ACH_ASPEED_15
34593: PPUSH
34594: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34598: LD_EXP 40
34602: PPUSH
34603: CALL_OW 87
// music_class := 5 ;
34607: LD_ADDR_OWVAR 72
34611: PUSH
34612: LD_INT 5
34614: ST_TO_ADDR
// music_nat := 5 ;
34615: LD_ADDR_OWVAR 71
34619: PUSH
34620: LD_INT 5
34622: ST_TO_ADDR
// DialogueOn ;
34623: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34627: LD_EXP 40
34631: PPUSH
34632: LD_STRING D20-JMM-1
34634: PPUSH
34635: CALL_OW 88
// if IsOK ( Joan ) then
34639: LD_EXP 41
34643: PPUSH
34644: CALL_OW 302
34648: IFFALSE 34662
// Say ( Joan , D20-Joan-1 ) ;
34650: LD_EXP 41
34654: PPUSH
34655: LD_STRING D20-Joan-1
34657: PPUSH
34658: CALL_OW 88
// if IsOk ( Lisa ) then
34662: LD_EXP 43
34666: PPUSH
34667: CALL_OW 302
34671: IFFALSE 34685
// Say ( Lisa , D20-Lisa-1 ) ;
34673: LD_EXP 43
34677: PPUSH
34678: LD_STRING D20-Lisa-1
34680: PPUSH
34681: CALL_OW 88
// if IsOk ( Donaldson ) then
34685: LD_EXP 44
34689: PPUSH
34690: CALL_OW 302
34694: IFFALSE 34708
// Say ( Donaldson , D20-Don-1 ) ;
34696: LD_EXP 44
34700: PPUSH
34701: LD_STRING D20-Don-1
34703: PPUSH
34704: CALL_OW 88
// if IsOK ( Cornel ) then
34708: LD_EXP 51
34712: PPUSH
34713: CALL_OW 302
34717: IFFALSE 34731
// Say ( Cornel , D20-Corn-1 ) ;
34719: LD_EXP 51
34723: PPUSH
34724: LD_STRING D20-Corn-1
34726: PPUSH
34727: CALL_OW 88
// if IsOk ( Denis ) then
34731: LD_EXP 47
34735: PPUSH
34736: CALL_OW 302
34740: IFFALSE 34754
// Say ( Denis , D20-Den-1 ) ;
34742: LD_EXP 47
34746: PPUSH
34747: LD_STRING D20-Den-1
34749: PPUSH
34750: CALL_OW 88
// if IsOk ( Bobby ) then
34754: LD_EXP 45
34758: PPUSH
34759: CALL_OW 302
34763: IFFALSE 34777
// Say ( Bobby , D20-Bobby-1 ) ;
34765: LD_EXP 45
34769: PPUSH
34770: LD_STRING D20-Bobby-1
34772: PPUSH
34773: CALL_OW 88
// if IsOk ( Gladstone ) then
34777: LD_EXP 49
34781: PPUSH
34782: CALL_OW 302
34786: IFFALSE 34800
// Say ( Gladstone , D20-Glad-1 ) ;
34788: LD_EXP 49
34792: PPUSH
34793: LD_STRING D20-Glad-1
34795: PPUSH
34796: CALL_OW 88
// if IsOk ( Cyrus ) then
34800: LD_EXP 46
34804: PPUSH
34805: CALL_OW 302
34809: IFFALSE 34823
// Say ( Cyrus , D20-Cyrus-1 ) ;
34811: LD_EXP 46
34815: PPUSH
34816: LD_STRING D20-Cyrus-1
34818: PPUSH
34819: CALL_OW 88
// if IsOk ( Stevens ) then
34823: LD_EXP 42
34827: PPUSH
34828: CALL_OW 302
34832: IFFALSE 34846
// Say ( Stevens , D20-Huck-1 ) ;
34834: LD_EXP 42
34838: PPUSH
34839: LD_STRING D20-Huck-1
34841: PPUSH
34842: CALL_OW 88
// if IsOk ( Brown ) then
34846: LD_EXP 48
34850: PPUSH
34851: CALL_OW 302
34855: IFFALSE 34869
// Say ( Brown , D20-Brown-1 ) ;
34857: LD_EXP 48
34861: PPUSH
34862: LD_STRING D20-Brown-1
34864: PPUSH
34865: CALL_OW 88
// if IsOk ( Gary ) then
34869: LD_EXP 52
34873: PPUSH
34874: CALL_OW 302
34878: IFFALSE 34892
// Say ( Gary , D20-Gary-1 ) ;
34880: LD_EXP 52
34884: PPUSH
34885: LD_STRING D20-Gary-1
34887: PPUSH
34888: CALL_OW 88
// if IsOk ( Connie ) then
34892: LD_EXP 55
34896: PPUSH
34897: CALL_OW 302
34901: IFFALSE 34915
// Say ( Connie , D20-Con-1 ) ;
34903: LD_EXP 55
34907: PPUSH
34908: LD_STRING D20-Con-1
34910: PPUSH
34911: CALL_OW 88
// if IsOk ( Kurt ) then
34915: LD_EXP 62
34919: PPUSH
34920: CALL_OW 302
34924: IFFALSE 34938
// Say ( Kurt , D20-Kurt-1 ) ;
34926: LD_EXP 62
34930: PPUSH
34931: LD_STRING D20-Kurt-1
34933: PPUSH
34934: CALL_OW 88
// if IsOk ( Kikuchi ) then
34938: LD_EXP 54
34942: PPUSH
34943: CALL_OW 302
34947: IFFALSE 34961
// Say ( Kikuchi , D20-Yam-1 ) ;
34949: LD_EXP 54
34953: PPUSH
34954: LD_STRING D20-Yam-1
34956: PPUSH
34957: CALL_OW 88
// if IsOk ( Frank ) then
34961: LD_EXP 53
34965: PPUSH
34966: CALL_OW 302
34970: IFFALSE 34984
// Say ( Frank , D20-Frank-1 ) ;
34972: LD_EXP 53
34976: PPUSH
34977: LD_STRING D20-Frank-1
34979: PPUSH
34980: CALL_OW 88
// DialogueOff ;
34984: CALL_OW 7
// if RothCaptured then
34988: LD_EXP 33
34992: IFFALSE 35014
// begin m1 := true ;
34994: LD_ADDR_VAR 0 1
34998: PUSH
34999: LD_INT 1
35001: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
35002: LD_STRING Roth
35004: PPUSH
35005: LD_INT 1
35007: PPUSH
35008: CALL_OW 101
// end else
35012: GO 35025
// AddMedal ( Roth , - 1 ) ;
35014: LD_STRING Roth
35016: PPUSH
35017: LD_INT 1
35019: NEG
35020: PPUSH
35021: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
35025: LD_EXP 25
35029: NOT
35030: PUSH
35031: LD_EXP 27
35035: OR
35036: IFFALSE 35058
// begin m2 := true ;
35038: LD_ADDR_VAR 0 2
35042: PUSH
35043: LD_INT 1
35045: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
35046: LD_STRING Project
35048: PPUSH
35049: LD_INT 1
35051: PPUSH
35052: CALL_OW 101
// end else
35056: GO 35069
// AddMedal ( Project , - 1 ) ;
35058: LD_STRING Project
35060: PPUSH
35061: LD_INT 1
35063: NEG
35064: PPUSH
35065: CALL_OW 101
// if lostCounter = 0 then
35069: LD_EXP 32
35073: PUSH
35074: LD_INT 0
35076: EQUAL
35077: IFFALSE 35099
// begin m3 := true ;
35079: LD_ADDR_VAR 0 3
35083: PUSH
35084: LD_INT 1
35086: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
35087: LD_STRING NoLosses
35089: PPUSH
35090: LD_INT 1
35092: PPUSH
35093: CALL_OW 101
// end else
35097: GO 35110
// AddMedal ( NoLosses , - 1 ) ;
35099: LD_STRING NoLosses
35101: PPUSH
35102: LD_INT 1
35104: NEG
35105: PPUSH
35106: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
35110: LD_VAR 0 1
35114: PUSH
35115: LD_VAR 0 2
35119: AND
35120: PUSH
35121: LD_VAR 0 3
35125: AND
35126: PUSH
35127: LD_OWVAR 67
35131: PUSH
35132: LD_INT 3
35134: GREATEREQUAL
35135: AND
35136: IFFALSE 35148
// SetAchievementEX ( ACH_AMER , 15 ) ;
35138: LD_STRING ACH_AMER
35140: PPUSH
35141: LD_INT 15
35143: PPUSH
35144: CALL_OW 564
// GiveMedals ( MAIN ) ;
35148: LD_STRING MAIN
35150: PPUSH
35151: CALL_OW 102
// music_class := 4 ;
35155: LD_ADDR_OWVAR 72
35159: PUSH
35160: LD_INT 4
35162: ST_TO_ADDR
// music_nat := 1 ;
35163: LD_ADDR_OWVAR 71
35167: PUSH
35168: LD_INT 1
35170: ST_TO_ADDR
// YouWin ;
35171: CALL_OW 103
// end ; end_of_file
35175: PPOPN 3
35177: END
// export function CustomEvent ( event ) ; begin
35178: LD_INT 0
35180: PPUSH
// end ;
35181: LD_VAR 0 2
35185: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
35186: LD_VAR 0 1
35190: PUSH
35191: LD_INT 1
35193: EQUAL
35194: PUSH
35195: LD_VAR 0 2
35199: PUSH
35200: LD_INT 4
35202: EQUAL
35203: AND
35204: PUSH
35205: LD_EXP 60
35209: PPUSH
35210: CALL_OW 300
35214: AND
35215: IFFALSE 35231
// begin wait ( 0 0$2 ) ;
35217: LD_INT 70
35219: PPUSH
35220: CALL_OW 67
// YouLost ( Dismissed ) ;
35224: LD_STRING Dismissed
35226: PPUSH
35227: CALL_OW 104
// end ; end ;
35231: PPOPN 2
35233: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
35234: LD_VAR 0 2
35238: PPUSH
35239: LD_VAR 0 3
35243: PPUSH
35244: LD_INT 18
35246: PPUSH
35247: CALL_OW 309
35251: IFFALSE 35260
// YouLost ( Motherlode3 ) ;
35253: LD_STRING Motherlode3
35255: PPUSH
35256: CALL_OW 104
// end ;
35260: PPOPN 3
35262: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35263: LD_EXP 27
35267: NOT
35268: IFFALSE 35278
// behemothDone := true ;
35270: LD_ADDR_EXP 28
35274: PUSH
35275: LD_INT 1
35277: ST_TO_ADDR
// end ;
35278: PPOPN 1
35280: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35281: LD_VAR 0 1
35285: PPUSH
35286: CALL_OW 255
35290: PUSH
35291: LD_INT 1
35293: EQUAL
35294: IFFALSE 35304
// bombExploded := true ;
35296: LD_ADDR_EXP 37
35300: PUSH
35301: LD_INT 1
35303: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
35304: LD_VAR 0 1
35308: PPUSH
35309: CALL_OW 255
35313: PUSH
35314: LD_INT 3
35316: EQUAL
35317: IFFALSE 35347
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
35319: LD_INT 2
35321: PPUSH
35322: LD_INT 23
35324: PUSH
35325: LD_INT 3
35327: PUSH
35328: LD_INT 3
35330: PUSH
35331: LD_INT 48
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: PUSH
35340: EMPTY
35341: LIST
35342: PPUSH
35343: CALL 61148 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35347: LD_VAR 0 1
35351: PPUSH
35352: CALL_OW 255
35356: PUSH
35357: LD_INT 1
35359: EQUAL
35360: PUSH
35361: LD_EXP 64
35365: PPUSH
35366: CALL_OW 255
35370: PUSH
35371: LD_INT 1
35373: EQUAL
35374: AND
35375: PUSH
35376: LD_EXP 64
35380: PPUSH
35381: CALL_OW 302
35385: AND
35386: PUSH
35387: LD_EXP 30
35391: AND
35392: PUSH
35393: LD_INT 22
35395: PUSH
35396: LD_INT 3
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 34
35405: PUSH
35406: LD_INT 48
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PPUSH
35417: CALL_OW 69
35421: AND
35422: PUSH
35423: LD_INT 22
35425: PUSH
35426: LD_INT 1
35428: PUSH
35429: EMPTY
35430: LIST
35431: LIST
35432: PUSH
35433: LD_INT 34
35435: PUSH
35436: LD_INT 8
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PPUSH
35447: CALL_OW 69
35451: NOT
35452: AND
35453: IFFALSE 35505
// begin wait ( 0 0$5 ) ;
35455: LD_INT 175
35457: PPUSH
35458: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35462: LD_INT 22
35464: PUSH
35465: LD_INT 3
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 34
35474: PUSH
35475: LD_INT 48
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PPUSH
35486: CALL_OW 69
35490: PUSH
35491: LD_INT 1
35493: ARRAY
35494: PPUSH
35495: LD_INT 60
35497: PPUSH
35498: LD_INT 95
35500: PPUSH
35501: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
35505: LD_VAR 0 2
35509: PPUSH
35510: LD_VAR 0 3
35514: PPUSH
35515: LD_INT 18
35517: PPUSH
35518: CALL_OW 309
35522: PUSH
35523: LD_VAR 0 2
35527: PPUSH
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_INT 18
35535: PPUSH
35536: CALL 108813 0 3
35540: OR
35541: IFFALSE 35588
// begin if GetSide ( unit ) = 1 then
35543: LD_VAR 0 1
35547: PPUSH
35548: CALL_OW 255
35552: PUSH
35553: LD_INT 1
35555: EQUAL
35556: IFFALSE 35574
// begin wait ( 0 0$6 ) ;
35558: LD_INT 210
35560: PPUSH
35561: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35565: LD_STRING Motherlode2
35567: PPUSH
35568: CALL_OW 104
// end else
35572: GO 35588
// begin wait ( 0 0$6 ) ;
35574: LD_INT 210
35576: PPUSH
35577: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35581: LD_STRING Motherlode1
35583: PPUSH
35584: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35588: LD_VAR 0 1
35592: PPUSH
35593: CALL_OW 255
35597: PUSH
35598: LD_INT 3
35600: EQUAL
35601: IFFALSE 35622
// begin wait ( 0 0$5 ) ;
35603: LD_INT 175
35605: PPUSH
35606: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35610: LD_EXP 66
35614: PPUSH
35615: LD_STRING D18-Pla-1
35617: PPUSH
35618: CALL_OW 94
// end ; end ;
35622: PPOPN 3
35624: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
35625: LD_VAR 0 1
35629: PPUSH
35630: CALL 124756 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
35634: LD_VAR 0 1
35638: PUSH
35639: LD_INT 22
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 21
35651: PUSH
35652: LD_INT 1
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 23
35661: PUSH
35662: LD_INT 1
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: LIST
35673: PPUSH
35674: CALL_OW 69
35678: IN
35679: IFFALSE 35695
// lostCounter := lostCounter + 1 ;
35681: LD_ADDR_EXP 32
35685: PUSH
35686: LD_EXP 32
35690: PUSH
35691: LD_INT 1
35693: PLUS
35694: ST_TO_ADDR
// if un in behemothBuilders then
35695: LD_VAR 0 1
35699: PUSH
35700: LD_EXP 75
35704: IN
35705: IFFALSE 35725
// begin behemothBuilders := behemothBuilders diff un ;
35707: LD_ADDR_EXP 75
35711: PUSH
35712: LD_EXP 75
35716: PUSH
35717: LD_VAR 0 1
35721: DIFF
35722: ST_TO_ADDR
// exit ;
35723: GO 35755
// end ; if un = JMM then
35725: LD_VAR 0 1
35729: PUSH
35730: LD_EXP 40
35734: EQUAL
35735: IFFALSE 35746
// begin YouLost ( JMM ) ;
35737: LD_STRING JMM
35739: PPUSH
35740: CALL_OW 104
// exit ;
35744: GO 35755
// end ; MCE_UnitDestroyed ( un ) ;
35746: LD_VAR 0 1
35750: PPUSH
35751: CALL 64552 0 1
// end ;
35755: PPOPN 1
35757: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
35758: LD_VAR 0 1
35762: PPUSH
35763: LD_VAR 0 2
35767: PPUSH
35768: CALL 66884 0 2
// end ;
35772: PPOPN 2
35774: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
35775: LD_VAR 0 1
35779: PPUSH
35780: CALL 65952 0 1
// end ;
35784: PPOPN 1
35786: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
35787: LD_VAR 0 1
35791: PUSH
35792: LD_INT 22
35794: PUSH
35795: LD_INT 8
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 30
35804: PUSH
35805: LD_INT 2
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 23
35814: PUSH
35815: LD_INT 3
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: LIST
35826: PPUSH
35827: CALL_OW 69
35831: IN
35832: IFFALSE 35859
// begin ComUpgrade ( building ) ;
35834: LD_VAR 0 1
35838: PPUSH
35839: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
35843: LD_EXP 63
35847: PPUSH
35848: LD_VAR 0 1
35852: PPUSH
35853: CALL 75534 0 2
// exit ;
35857: GO 35868
// end ; MCE_BuildingComplete ( building ) ;
35859: LD_VAR 0 1
35863: PPUSH
35864: CALL 66193 0 1
// end ;
35868: PPOPN 1
35870: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
35871: LD_VAR 0 1
35875: PPUSH
35876: LD_VAR 0 2
35880: PPUSH
35881: CALL 64248 0 2
// end ;
35885: PPOPN 2
35887: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
35888: LD_VAR 0 1
35892: PPUSH
35893: LD_VAR 0 2
35897: PPUSH
35898: LD_VAR 0 3
35902: PPUSH
35903: LD_VAR 0 4
35907: PPUSH
35908: LD_VAR 0 5
35912: PPUSH
35913: CALL 63868 0 5
// end ;
35917: PPOPN 5
35919: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
35920: LD_VAR 0 1
35924: PPUSH
35925: CALL_OW 255
35929: PUSH
35930: LD_INT 1
35932: EQUAL
35933: IFFALSE 35950
// amConstructCounter := Inc ( amConstructCounter ) ;
35935: LD_ADDR_EXP 39
35939: PUSH
35940: LD_EXP 39
35944: PPUSH
35945: CALL 106365 0 1
35949: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
35950: LD_VAR 0 1
35954: PPUSH
35955: LD_VAR 0 2
35959: PPUSH
35960: CALL 124876 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
35964: LD_VAR 0 1
35968: PPUSH
35969: LD_VAR 0 2
35973: PPUSH
35974: CALL 63459 0 2
// end ;
35978: PPOPN 2
35980: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
35981: LD_VAR 0 1
35985: PPUSH
35986: LD_VAR 0 2
35990: PPUSH
35991: LD_VAR 0 3
35995: PPUSH
35996: LD_VAR 0 4
36000: PPUSH
36001: CALL 63297 0 4
// end ;
36005: PPOPN 4
36007: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
36008: LD_VAR 0 1
36012: PPUSH
36013: LD_VAR 0 2
36017: PPUSH
36018: LD_VAR 0 3
36022: PPUSH
36023: CALL 63072 0 3
// end ;
36027: PPOPN 3
36029: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
36030: LD_VAR 0 1
36034: PPUSH
36035: LD_VAR 0 2
36039: PPUSH
36040: CALL 62957 0 2
// end ;
36044: PPOPN 2
36046: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
36047: LD_VAR 0 1
36051: PPUSH
36052: LD_VAR 0 2
36056: PPUSH
36057: CALL 67179 0 2
// end ;
36061: PPOPN 2
36063: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
36064: LD_VAR 0 1
36068: PPUSH
36069: CALL_OW 255
36073: PUSH
36074: LD_INT 4
36076: EQUAL
36077: PUSH
36078: LD_VAR 0 1
36082: PUSH
36083: LD_EXP 18
36087: PUSH
36088: LD_INT 1
36090: ARRAY
36091: IN
36092: AND
36093: PUSH
36094: LD_EXP 19
36098: AND
36099: IFFALSE 36118
// begin ComMoveXY ( driver , 61 , 93 ) ;
36101: LD_VAR 0 1
36105: PPUSH
36106: LD_INT 61
36108: PPUSH
36109: LD_INT 93
36111: PPUSH
36112: CALL_OW 111
// exit ;
36116: GO 36142
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
36118: LD_VAR 0 1
36122: PPUSH
36123: LD_VAR 0 2
36127: PPUSH
36128: LD_VAR 0 3
36132: PPUSH
36133: LD_VAR 0 4
36137: PPUSH
36138: CALL 67395 0 4
// end ;
36142: PPOPN 4
36144: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
36145: LD_VAR 0 1
36149: PPUSH
36150: LD_VAR 0 2
36154: PPUSH
36155: CALL 62766 0 2
// end ;
36159: PPOPN 2
36161: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
36162: LD_VAR 0 1
36166: PPUSH
36167: CALL 124860 0 1
// end ; end_of_file
36171: PPOPN 1
36173: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
36174: LD_EXP 15
36178: PUSH
36179: LD_INT 2
36181: EQUAL
36182: IFFALSE 36685
36184: GO 36186
36186: DISABLE
36187: LD_INT 0
36189: PPUSH
36190: PPUSH
// begin time := 0 0$35 ;
36191: LD_ADDR_VAR 0 2
36195: PUSH
36196: LD_INT 1225
36198: ST_TO_ADDR
// repeat wait ( time ) ;
36199: LD_VAR 0 2
36203: PPUSH
36204: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
36208: LD_INT 1
36210: PPUSH
36211: LD_INT 5
36213: PPUSH
36214: CALL_OW 12
36218: PPUSH
36219: LD_INT 106
36221: PPUSH
36222: LD_INT 150
36224: PPUSH
36225: LD_INT 19
36227: PPUSH
36228: LD_INT 1
36230: PPUSH
36231: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
36235: LD_INT 455
36237: PPUSH
36238: LD_INT 770
36240: PPUSH
36241: CALL_OW 12
36245: PPUSH
36246: CALL_OW 67
// if Prob ( 50 ) then
36250: LD_INT 50
36252: PPUSH
36253: CALL_OW 13
36257: IFFALSE 36286
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
36259: LD_INT 1
36261: PPUSH
36262: LD_INT 5
36264: PPUSH
36265: CALL_OW 12
36269: PPUSH
36270: LD_INT 62
36272: PPUSH
36273: LD_INT 108
36275: PPUSH
36276: LD_INT 10
36278: PPUSH
36279: LD_INT 1
36281: PPUSH
36282: CALL_OW 56
// until missionStage > 4 ;
36286: LD_EXP 15
36290: PUSH
36291: LD_INT 4
36293: GREATER
36294: IFFALSE 36199
// repeat wait ( 0 0$1 ) ;
36296: LD_INT 35
36298: PPUSH
36299: CALL_OW 67
// until missionStage = 6 ;
36303: LD_EXP 15
36307: PUSH
36308: LD_INT 6
36310: EQUAL
36311: IFFALSE 36296
// time := 0 0$20 ;
36313: LD_ADDR_VAR 0 2
36317: PUSH
36318: LD_INT 700
36320: ST_TO_ADDR
// repeat wait ( time ) ;
36321: LD_VAR 0 2
36325: PPUSH
36326: CALL_OW 67
// if Prob ( 90 ) then
36330: LD_INT 90
36332: PPUSH
36333: CALL_OW 13
36337: IFFALSE 36380
// begin time := time + 0 0$2 ;
36339: LD_ADDR_VAR 0 2
36343: PUSH
36344: LD_VAR 0 2
36348: PUSH
36349: LD_INT 70
36351: PLUS
36352: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36353: LD_INT 1
36355: PPUSH
36356: LD_INT 5
36358: PPUSH
36359: CALL_OW 12
36363: PPUSH
36364: LD_INT 106
36366: PPUSH
36367: LD_INT 89
36369: PPUSH
36370: LD_INT 45
36372: PPUSH
36373: LD_INT 1
36375: PPUSH
36376: CALL_OW 56
// end ; if Prob ( 45 ) then
36380: LD_INT 45
36382: PPUSH
36383: CALL_OW 13
36387: IFFALSE 36443
// begin for i := 1 to 4 do
36389: LD_ADDR_VAR 0 1
36393: PUSH
36394: DOUBLE
36395: LD_INT 1
36397: DEC
36398: ST_TO_ADDR
36399: LD_INT 4
36401: PUSH
36402: FOR_TO
36403: IFFALSE 36441
// begin wait ( 0 0$5 ) ;
36405: LD_INT 175
36407: PPUSH
36408: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36412: LD_INT 1
36414: PPUSH
36415: LD_INT 5
36417: PPUSH
36418: CALL_OW 12
36422: PPUSH
36423: LD_INT 113
36425: PPUSH
36426: LD_INT 117
36428: PPUSH
36429: LD_INT 25
36431: PPUSH
36432: LD_INT 1
36434: PPUSH
36435: CALL_OW 56
// end ;
36439: GO 36402
36441: POP
36442: POP
// end ; if Prob ( 40 ) then
36443: LD_INT 40
36445: PPUSH
36446: CALL_OW 13
36450: IFFALSE 36496
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36452: LD_INT 385
36454: PPUSH
36455: LD_INT 945
36457: PPUSH
36458: CALL_OW 12
36462: PPUSH
36463: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36467: LD_INT 1
36469: PPUSH
36470: LD_INT 5
36472: PPUSH
36473: CALL_OW 12
36477: PPUSH
36478: LD_INT 21
36480: PPUSH
36481: LD_INT 26
36483: PPUSH
36484: LD_INT 12
36486: PPUSH
36487: LD_INT 1
36489: PPUSH
36490: CALL_OW 56
// end else
36494: GO 36532
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36496: LD_INT 700
36498: PPUSH
36499: LD_INT 1225
36501: PPUSH
36502: CALL_OW 12
36506: PPUSH
36507: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36511: LD_INT 1
36513: PPUSH
36514: LD_INT 5
36516: PPUSH
36517: CALL_OW 12
36521: PPUSH
36522: LD_INT 16
36524: PPUSH
36525: LD_INT 1
36527: PPUSH
36528: CALL_OW 55
// end ; if Prob ( 50 ) then
36532: LD_INT 50
36534: PPUSH
36535: CALL_OW 13
36539: IFFALSE 36585
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36541: LD_INT 700
36543: PPUSH
36544: LD_INT 1050
36546: PPUSH
36547: CALL_OW 12
36551: PPUSH
36552: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36556: LD_INT 1
36558: PPUSH
36559: LD_INT 5
36561: PPUSH
36562: CALL_OW 12
36566: PPUSH
36567: LD_INT 168
36569: PPUSH
36570: LD_INT 168
36572: PPUSH
36573: LD_INT 16
36575: PPUSH
36576: LD_INT 1
36578: PPUSH
36579: CALL_OW 56
// end else
36583: GO 36621
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36585: LD_INT 350
36587: PPUSH
36588: LD_INT 525
36590: PPUSH
36591: CALL_OW 12
36595: PPUSH
36596: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
36600: LD_INT 1
36602: PPUSH
36603: LD_INT 5
36605: PPUSH
36606: CALL_OW 12
36610: PPUSH
36611: LD_INT 15
36613: PPUSH
36614: LD_INT 1
36616: PPUSH
36617: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
36621: LD_INT 175
36623: PPUSH
36624: LD_INT 315
36626: PPUSH
36627: CALL_OW 12
36631: PPUSH
36632: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
36636: LD_INT 1
36638: PPUSH
36639: LD_INT 5
36641: PPUSH
36642: CALL_OW 12
36646: PPUSH
36647: LD_INT 103
36649: PPUSH
36650: LD_INT 140
36652: PPUSH
36653: LD_INT 20
36655: PPUSH
36656: LD_INT 1
36658: PPUSH
36659: CALL_OW 56
// if time > 1 1$10 then
36663: LD_VAR 0 2
36667: PUSH
36668: LD_INT 2450
36670: GREATER
36671: IFFALSE 36681
// time := 0 0$30 ;
36673: LD_ADDR_VAR 0 2
36677: PUSH
36678: LD_INT 1050
36680: ST_TO_ADDR
// until false ;
36681: LD_INT 0
36683: IFFALSE 36321
// end ; end_of_file
36685: PPOPN 2
36687: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
36688: LD_EXP 13
36692: PUSH
36693: LD_EXP 15
36697: PUSH
36698: LD_INT 6
36700: GREATEREQUAL
36701: AND
36702: IFFALSE 36739
36704: GO 36706
36706: DISABLE
// begin enable ;
36707: ENABLE
// missionTime := missionTime + 0 0$1 ;
36708: LD_ADDR_EXP 14
36712: PUSH
36713: LD_EXP 14
36717: PUSH
36718: LD_INT 35
36720: PLUS
36721: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
36722: LD_ADDR_OWVAR 47
36726: PUSH
36727: LD_STRING #Am15-1
36729: PUSH
36730: LD_EXP 14
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: ST_TO_ADDR
// end ; end_of_file
36739: END
// export function InitNature ; begin
36740: LD_INT 0
36742: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
36743: LD_INT 3
36745: PPUSH
36746: LD_INT 3
36748: PPUSH
36749: LD_INT 2
36751: PPUSH
36752: LD_INT 1
36754: PPUSH
36755: LD_INT 1
36757: PPUSH
36758: LD_INT 0
36760: PPUSH
36761: LD_INT 0
36763: PPUSH
36764: LD_INT 20
36766: PPUSH
36767: LD_INT 0
36769: PPUSH
36770: CALL 101693 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
36774: LD_INT 2
36776: PPUSH
36777: LD_INT 1
36779: PPUSH
36780: LD_INT 1
36782: PPUSH
36783: LD_INT 1
36785: PPUSH
36786: LD_INT 1
36788: PPUSH
36789: LD_INT 0
36791: PPUSH
36792: LD_INT 0
36794: PPUSH
36795: LD_INT 21
36797: PPUSH
36798: LD_INT 0
36800: PPUSH
36801: CALL 101693 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
36805: LD_INT 4
36807: PPUSH
36808: LD_INT 1
36810: PPUSH
36811: LD_INT 2
36813: PPUSH
36814: LD_INT 4
36816: PPUSH
36817: LD_INT 2
36819: PPUSH
36820: LD_INT 1
36822: PPUSH
36823: LD_INT 0
36825: PPUSH
36826: LD_INT 22
36828: PPUSH
36829: LD_INT 0
36831: PPUSH
36832: CALL 101693 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
36836: LD_INT 0
36838: PPUSH
36839: LD_INT 0
36841: PPUSH
36842: LD_INT 0
36844: PPUSH
36845: LD_INT 0
36847: PPUSH
36848: LD_INT 0
36850: PPUSH
36851: LD_INT 0
36853: PPUSH
36854: LD_INT 9
36856: PPUSH
36857: LD_INT 0
36859: PPUSH
36860: LD_INT 23
36862: PPUSH
36863: CALL 101693 0 9
// end ; end_of_file
36867: LD_VAR 0 1
36871: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
36872: LD_INT 0
36874: PPUSH
36875: PPUSH
// skirmish := false ;
36876: LD_ADDR_EXP 98
36880: PUSH
36881: LD_INT 0
36883: ST_TO_ADDR
// debug_mc := false ;
36884: LD_ADDR_EXP 99
36888: PUSH
36889: LD_INT 0
36891: ST_TO_ADDR
// mc_bases := [ ] ;
36892: LD_ADDR_EXP 100
36896: PUSH
36897: EMPTY
36898: ST_TO_ADDR
// mc_sides := [ ] ;
36899: LD_ADDR_EXP 126
36903: PUSH
36904: EMPTY
36905: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
36906: LD_ADDR_EXP 101
36910: PUSH
36911: EMPTY
36912: ST_TO_ADDR
// mc_building_repairs := [ ] ;
36913: LD_ADDR_EXP 102
36917: PUSH
36918: EMPTY
36919: ST_TO_ADDR
// mc_need_heal := [ ] ;
36920: LD_ADDR_EXP 103
36924: PUSH
36925: EMPTY
36926: ST_TO_ADDR
// mc_healers := [ ] ;
36927: LD_ADDR_EXP 104
36931: PUSH
36932: EMPTY
36933: ST_TO_ADDR
// mc_build_list := [ ] ;
36934: LD_ADDR_EXP 105
36938: PUSH
36939: EMPTY
36940: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
36941: LD_ADDR_EXP 132
36945: PUSH
36946: EMPTY
36947: ST_TO_ADDR
// mc_builders := [ ] ;
36948: LD_ADDR_EXP 106
36952: PUSH
36953: EMPTY
36954: ST_TO_ADDR
// mc_construct_list := [ ] ;
36955: LD_ADDR_EXP 107
36959: PUSH
36960: EMPTY
36961: ST_TO_ADDR
// mc_turret_list := [ ] ;
36962: LD_ADDR_EXP 108
36966: PUSH
36967: EMPTY
36968: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
36969: LD_ADDR_EXP 109
36973: PUSH
36974: EMPTY
36975: ST_TO_ADDR
// mc_miners := [ ] ;
36976: LD_ADDR_EXP 114
36980: PUSH
36981: EMPTY
36982: ST_TO_ADDR
// mc_mines := [ ] ;
36983: LD_ADDR_EXP 113
36987: PUSH
36988: EMPTY
36989: ST_TO_ADDR
// mc_minefields := [ ] ;
36990: LD_ADDR_EXP 115
36994: PUSH
36995: EMPTY
36996: ST_TO_ADDR
// mc_crates := [ ] ;
36997: LD_ADDR_EXP 116
37001: PUSH
37002: EMPTY
37003: ST_TO_ADDR
// mc_crates_collector := [ ] ;
37004: LD_ADDR_EXP 117
37008: PUSH
37009: EMPTY
37010: ST_TO_ADDR
// mc_crates_area := [ ] ;
37011: LD_ADDR_EXP 118
37015: PUSH
37016: EMPTY
37017: ST_TO_ADDR
// mc_vehicles := [ ] ;
37018: LD_ADDR_EXP 119
37022: PUSH
37023: EMPTY
37024: ST_TO_ADDR
// mc_attack := [ ] ;
37025: LD_ADDR_EXP 120
37029: PUSH
37030: EMPTY
37031: ST_TO_ADDR
// mc_produce := [ ] ;
37032: LD_ADDR_EXP 121
37036: PUSH
37037: EMPTY
37038: ST_TO_ADDR
// mc_defender := [ ] ;
37039: LD_ADDR_EXP 122
37043: PUSH
37044: EMPTY
37045: ST_TO_ADDR
// mc_parking := [ ] ;
37046: LD_ADDR_EXP 124
37050: PUSH
37051: EMPTY
37052: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
37053: LD_ADDR_EXP 110
37057: PUSH
37058: EMPTY
37059: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
37060: LD_ADDR_EXP 112
37064: PUSH
37065: EMPTY
37066: ST_TO_ADDR
// mc_scan := [ ] ;
37067: LD_ADDR_EXP 123
37071: PUSH
37072: EMPTY
37073: ST_TO_ADDR
// mc_scan_area := [ ] ;
37074: LD_ADDR_EXP 125
37078: PUSH
37079: EMPTY
37080: ST_TO_ADDR
// mc_tech := [ ] ;
37081: LD_ADDR_EXP 127
37085: PUSH
37086: EMPTY
37087: ST_TO_ADDR
// mc_class := [ ] ;
37088: LD_ADDR_EXP 141
37092: PUSH
37093: EMPTY
37094: ST_TO_ADDR
// mc_class_case_use := [ ] ;
37095: LD_ADDR_EXP 142
37099: PUSH
37100: EMPTY
37101: ST_TO_ADDR
// mc_is_defending := [ ] ;
37102: LD_ADDR_EXP 143
37106: PUSH
37107: EMPTY
37108: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
37109: LD_ADDR_EXP 134
37113: PUSH
37114: EMPTY
37115: ST_TO_ADDR
// end ;
37116: LD_VAR 0 1
37120: RET
// export function MC_Kill ( base ) ; begin
37121: LD_INT 0
37123: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
37124: LD_ADDR_EXP 100
37128: PUSH
37129: LD_EXP 100
37133: PPUSH
37134: LD_VAR 0 1
37138: PPUSH
37139: EMPTY
37140: PPUSH
37141: CALL_OW 1
37145: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37146: LD_ADDR_EXP 101
37150: PUSH
37151: LD_EXP 101
37155: PPUSH
37156: LD_VAR 0 1
37160: PPUSH
37161: EMPTY
37162: PPUSH
37163: CALL_OW 1
37167: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37168: LD_ADDR_EXP 102
37172: PUSH
37173: LD_EXP 102
37177: PPUSH
37178: LD_VAR 0 1
37182: PPUSH
37183: EMPTY
37184: PPUSH
37185: CALL_OW 1
37189: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37190: LD_ADDR_EXP 103
37194: PUSH
37195: LD_EXP 103
37199: PPUSH
37200: LD_VAR 0 1
37204: PPUSH
37205: EMPTY
37206: PPUSH
37207: CALL_OW 1
37211: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37212: LD_ADDR_EXP 104
37216: PUSH
37217: LD_EXP 104
37221: PPUSH
37222: LD_VAR 0 1
37226: PPUSH
37227: EMPTY
37228: PPUSH
37229: CALL_OW 1
37233: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37234: LD_ADDR_EXP 105
37238: PUSH
37239: LD_EXP 105
37243: PPUSH
37244: LD_VAR 0 1
37248: PPUSH
37249: EMPTY
37250: PPUSH
37251: CALL_OW 1
37255: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37256: LD_ADDR_EXP 106
37260: PUSH
37261: LD_EXP 106
37265: PPUSH
37266: LD_VAR 0 1
37270: PPUSH
37271: EMPTY
37272: PPUSH
37273: CALL_OW 1
37277: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37278: LD_ADDR_EXP 107
37282: PUSH
37283: LD_EXP 107
37287: PPUSH
37288: LD_VAR 0 1
37292: PPUSH
37293: EMPTY
37294: PPUSH
37295: CALL_OW 1
37299: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37300: LD_ADDR_EXP 108
37304: PUSH
37305: LD_EXP 108
37309: PPUSH
37310: LD_VAR 0 1
37314: PPUSH
37315: EMPTY
37316: PPUSH
37317: CALL_OW 1
37321: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37322: LD_ADDR_EXP 109
37326: PUSH
37327: LD_EXP 109
37331: PPUSH
37332: LD_VAR 0 1
37336: PPUSH
37337: EMPTY
37338: PPUSH
37339: CALL_OW 1
37343: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37344: LD_ADDR_EXP 110
37348: PUSH
37349: LD_EXP 110
37353: PPUSH
37354: LD_VAR 0 1
37358: PPUSH
37359: EMPTY
37360: PPUSH
37361: CALL_OW 1
37365: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37366: LD_ADDR_EXP 111
37370: PUSH
37371: LD_EXP 111
37375: PPUSH
37376: LD_VAR 0 1
37380: PPUSH
37381: LD_INT 0
37383: PPUSH
37384: CALL_OW 1
37388: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37389: LD_ADDR_EXP 112
37393: PUSH
37394: LD_EXP 112
37398: PPUSH
37399: LD_VAR 0 1
37403: PPUSH
37404: EMPTY
37405: PPUSH
37406: CALL_OW 1
37410: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37411: LD_ADDR_EXP 113
37415: PUSH
37416: LD_EXP 113
37420: PPUSH
37421: LD_VAR 0 1
37425: PPUSH
37426: EMPTY
37427: PPUSH
37428: CALL_OW 1
37432: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37433: LD_ADDR_EXP 114
37437: PUSH
37438: LD_EXP 114
37442: PPUSH
37443: LD_VAR 0 1
37447: PPUSH
37448: EMPTY
37449: PPUSH
37450: CALL_OW 1
37454: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37455: LD_ADDR_EXP 115
37459: PUSH
37460: LD_EXP 115
37464: PPUSH
37465: LD_VAR 0 1
37469: PPUSH
37470: EMPTY
37471: PPUSH
37472: CALL_OW 1
37476: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37477: LD_ADDR_EXP 116
37481: PUSH
37482: LD_EXP 116
37486: PPUSH
37487: LD_VAR 0 1
37491: PPUSH
37492: EMPTY
37493: PPUSH
37494: CALL_OW 1
37498: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37499: LD_ADDR_EXP 117
37503: PUSH
37504: LD_EXP 117
37508: PPUSH
37509: LD_VAR 0 1
37513: PPUSH
37514: EMPTY
37515: PPUSH
37516: CALL_OW 1
37520: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37521: LD_ADDR_EXP 118
37525: PUSH
37526: LD_EXP 118
37530: PPUSH
37531: LD_VAR 0 1
37535: PPUSH
37536: EMPTY
37537: PPUSH
37538: CALL_OW 1
37542: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37543: LD_ADDR_EXP 119
37547: PUSH
37548: LD_EXP 119
37552: PPUSH
37553: LD_VAR 0 1
37557: PPUSH
37558: EMPTY
37559: PPUSH
37560: CALL_OW 1
37564: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37565: LD_ADDR_EXP 120
37569: PUSH
37570: LD_EXP 120
37574: PPUSH
37575: LD_VAR 0 1
37579: PPUSH
37580: EMPTY
37581: PPUSH
37582: CALL_OW 1
37586: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37587: LD_ADDR_EXP 121
37591: PUSH
37592: LD_EXP 121
37596: PPUSH
37597: LD_VAR 0 1
37601: PPUSH
37602: EMPTY
37603: PPUSH
37604: CALL_OW 1
37608: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37609: LD_ADDR_EXP 122
37613: PUSH
37614: LD_EXP 122
37618: PPUSH
37619: LD_VAR 0 1
37623: PPUSH
37624: EMPTY
37625: PPUSH
37626: CALL_OW 1
37630: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37631: LD_ADDR_EXP 123
37635: PUSH
37636: LD_EXP 123
37640: PPUSH
37641: LD_VAR 0 1
37645: PPUSH
37646: EMPTY
37647: PPUSH
37648: CALL_OW 1
37652: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37653: LD_ADDR_EXP 124
37657: PUSH
37658: LD_EXP 124
37662: PPUSH
37663: LD_VAR 0 1
37667: PPUSH
37668: EMPTY
37669: PPUSH
37670: CALL_OW 1
37674: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37675: LD_ADDR_EXP 125
37679: PUSH
37680: LD_EXP 125
37684: PPUSH
37685: LD_VAR 0 1
37689: PPUSH
37690: EMPTY
37691: PPUSH
37692: CALL_OW 1
37696: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37697: LD_ADDR_EXP 127
37701: PUSH
37702: LD_EXP 127
37706: PPUSH
37707: LD_VAR 0 1
37711: PPUSH
37712: EMPTY
37713: PPUSH
37714: CALL_OW 1
37718: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37719: LD_ADDR_EXP 129
37723: PUSH
37724: LD_EXP 129
37728: PPUSH
37729: LD_VAR 0 1
37733: PPUSH
37734: EMPTY
37735: PPUSH
37736: CALL_OW 1
37740: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37741: LD_ADDR_EXP 130
37745: PUSH
37746: LD_EXP 130
37750: PPUSH
37751: LD_VAR 0 1
37755: PPUSH
37756: EMPTY
37757: PPUSH
37758: CALL_OW 1
37762: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37763: LD_ADDR_EXP 131
37767: PUSH
37768: LD_EXP 131
37772: PPUSH
37773: LD_VAR 0 1
37777: PPUSH
37778: EMPTY
37779: PPUSH
37780: CALL_OW 1
37784: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37785: LD_ADDR_EXP 132
37789: PUSH
37790: LD_EXP 132
37794: PPUSH
37795: LD_VAR 0 1
37799: PPUSH
37800: EMPTY
37801: PPUSH
37802: CALL_OW 1
37806: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37807: LD_ADDR_EXP 133
37811: PUSH
37812: LD_EXP 133
37816: PPUSH
37817: LD_VAR 0 1
37821: PPUSH
37822: EMPTY
37823: PPUSH
37824: CALL_OW 1
37828: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37829: LD_ADDR_EXP 134
37833: PUSH
37834: LD_EXP 134
37838: PPUSH
37839: LD_VAR 0 1
37843: PPUSH
37844: EMPTY
37845: PPUSH
37846: CALL_OW 1
37850: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37851: LD_ADDR_EXP 135
37855: PUSH
37856: LD_EXP 135
37860: PPUSH
37861: LD_VAR 0 1
37865: PPUSH
37866: EMPTY
37867: PPUSH
37868: CALL_OW 1
37872: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37873: LD_ADDR_EXP 136
37877: PUSH
37878: LD_EXP 136
37882: PPUSH
37883: LD_VAR 0 1
37887: PPUSH
37888: EMPTY
37889: PPUSH
37890: CALL_OW 1
37894: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37895: LD_ADDR_EXP 137
37899: PUSH
37900: LD_EXP 137
37904: PPUSH
37905: LD_VAR 0 1
37909: PPUSH
37910: EMPTY
37911: PPUSH
37912: CALL_OW 1
37916: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37917: LD_ADDR_EXP 138
37921: PUSH
37922: LD_EXP 138
37926: PPUSH
37927: LD_VAR 0 1
37931: PPUSH
37932: EMPTY
37933: PPUSH
37934: CALL_OW 1
37938: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37939: LD_ADDR_EXP 139
37943: PUSH
37944: LD_EXP 139
37948: PPUSH
37949: LD_VAR 0 1
37953: PPUSH
37954: EMPTY
37955: PPUSH
37956: CALL_OW 1
37960: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37961: LD_ADDR_EXP 140
37965: PUSH
37966: LD_EXP 140
37970: PPUSH
37971: LD_VAR 0 1
37975: PPUSH
37976: EMPTY
37977: PPUSH
37978: CALL_OW 1
37982: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37983: LD_ADDR_EXP 141
37987: PUSH
37988: LD_EXP 141
37992: PPUSH
37993: LD_VAR 0 1
37997: PPUSH
37998: EMPTY
37999: PPUSH
38000: CALL_OW 1
38004: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38005: LD_ADDR_EXP 142
38009: PUSH
38010: LD_EXP 142
38014: PPUSH
38015: LD_VAR 0 1
38019: PPUSH
38020: LD_INT 0
38022: PPUSH
38023: CALL_OW 1
38027: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38028: LD_ADDR_EXP 143
38032: PUSH
38033: LD_EXP 143
38037: PPUSH
38038: LD_VAR 0 1
38042: PPUSH
38043: LD_INT 0
38045: PPUSH
38046: CALL_OW 1
38050: ST_TO_ADDR
// end ;
38051: LD_VAR 0 2
38055: RET
// export function MC_Add ( side , units ) ; var base ; begin
38056: LD_INT 0
38058: PPUSH
38059: PPUSH
// base := mc_bases + 1 ;
38060: LD_ADDR_VAR 0 4
38064: PUSH
38065: LD_EXP 100
38069: PUSH
38070: LD_INT 1
38072: PLUS
38073: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
38074: LD_ADDR_EXP 126
38078: PUSH
38079: LD_EXP 126
38083: PPUSH
38084: LD_VAR 0 4
38088: PPUSH
38089: LD_VAR 0 1
38093: PPUSH
38094: CALL_OW 1
38098: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
38099: LD_ADDR_EXP 100
38103: PUSH
38104: LD_EXP 100
38108: PPUSH
38109: LD_VAR 0 4
38113: PPUSH
38114: LD_VAR 0 2
38118: PPUSH
38119: CALL_OW 1
38123: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
38124: LD_ADDR_EXP 101
38128: PUSH
38129: LD_EXP 101
38133: PPUSH
38134: LD_VAR 0 4
38138: PPUSH
38139: EMPTY
38140: PPUSH
38141: CALL_OW 1
38145: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
38146: LD_ADDR_EXP 102
38150: PUSH
38151: LD_EXP 102
38155: PPUSH
38156: LD_VAR 0 4
38160: PPUSH
38161: EMPTY
38162: PPUSH
38163: CALL_OW 1
38167: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
38168: LD_ADDR_EXP 103
38172: PUSH
38173: LD_EXP 103
38177: PPUSH
38178: LD_VAR 0 4
38182: PPUSH
38183: EMPTY
38184: PPUSH
38185: CALL_OW 1
38189: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
38190: LD_ADDR_EXP 104
38194: PUSH
38195: LD_EXP 104
38199: PPUSH
38200: LD_VAR 0 4
38204: PPUSH
38205: EMPTY
38206: PPUSH
38207: CALL_OW 1
38211: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38212: LD_ADDR_EXP 105
38216: PUSH
38217: LD_EXP 105
38221: PPUSH
38222: LD_VAR 0 4
38226: PPUSH
38227: EMPTY
38228: PPUSH
38229: CALL_OW 1
38233: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38234: LD_ADDR_EXP 106
38238: PUSH
38239: LD_EXP 106
38243: PPUSH
38244: LD_VAR 0 4
38248: PPUSH
38249: EMPTY
38250: PPUSH
38251: CALL_OW 1
38255: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38256: LD_ADDR_EXP 107
38260: PUSH
38261: LD_EXP 107
38265: PPUSH
38266: LD_VAR 0 4
38270: PPUSH
38271: EMPTY
38272: PPUSH
38273: CALL_OW 1
38277: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38278: LD_ADDR_EXP 108
38282: PUSH
38283: LD_EXP 108
38287: PPUSH
38288: LD_VAR 0 4
38292: PPUSH
38293: EMPTY
38294: PPUSH
38295: CALL_OW 1
38299: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38300: LD_ADDR_EXP 109
38304: PUSH
38305: LD_EXP 109
38309: PPUSH
38310: LD_VAR 0 4
38314: PPUSH
38315: EMPTY
38316: PPUSH
38317: CALL_OW 1
38321: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38322: LD_ADDR_EXP 110
38326: PUSH
38327: LD_EXP 110
38331: PPUSH
38332: LD_VAR 0 4
38336: PPUSH
38337: EMPTY
38338: PPUSH
38339: CALL_OW 1
38343: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38344: LD_ADDR_EXP 111
38348: PUSH
38349: LD_EXP 111
38353: PPUSH
38354: LD_VAR 0 4
38358: PPUSH
38359: LD_INT 0
38361: PPUSH
38362: CALL_OW 1
38366: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38367: LD_ADDR_EXP 112
38371: PUSH
38372: LD_EXP 112
38376: PPUSH
38377: LD_VAR 0 4
38381: PPUSH
38382: EMPTY
38383: PPUSH
38384: CALL_OW 1
38388: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38389: LD_ADDR_EXP 113
38393: PUSH
38394: LD_EXP 113
38398: PPUSH
38399: LD_VAR 0 4
38403: PPUSH
38404: EMPTY
38405: PPUSH
38406: CALL_OW 1
38410: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38411: LD_ADDR_EXP 114
38415: PUSH
38416: LD_EXP 114
38420: PPUSH
38421: LD_VAR 0 4
38425: PPUSH
38426: EMPTY
38427: PPUSH
38428: CALL_OW 1
38432: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38433: LD_ADDR_EXP 115
38437: PUSH
38438: LD_EXP 115
38442: PPUSH
38443: LD_VAR 0 4
38447: PPUSH
38448: EMPTY
38449: PPUSH
38450: CALL_OW 1
38454: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38455: LD_ADDR_EXP 116
38459: PUSH
38460: LD_EXP 116
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: EMPTY
38471: PPUSH
38472: CALL_OW 1
38476: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38477: LD_ADDR_EXP 117
38481: PUSH
38482: LD_EXP 117
38486: PPUSH
38487: LD_VAR 0 4
38491: PPUSH
38492: EMPTY
38493: PPUSH
38494: CALL_OW 1
38498: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38499: LD_ADDR_EXP 118
38503: PUSH
38504: LD_EXP 118
38508: PPUSH
38509: LD_VAR 0 4
38513: PPUSH
38514: EMPTY
38515: PPUSH
38516: CALL_OW 1
38520: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38521: LD_ADDR_EXP 119
38525: PUSH
38526: LD_EXP 119
38530: PPUSH
38531: LD_VAR 0 4
38535: PPUSH
38536: EMPTY
38537: PPUSH
38538: CALL_OW 1
38542: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38543: LD_ADDR_EXP 120
38547: PUSH
38548: LD_EXP 120
38552: PPUSH
38553: LD_VAR 0 4
38557: PPUSH
38558: EMPTY
38559: PPUSH
38560: CALL_OW 1
38564: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38565: LD_ADDR_EXP 121
38569: PUSH
38570: LD_EXP 121
38574: PPUSH
38575: LD_VAR 0 4
38579: PPUSH
38580: EMPTY
38581: PPUSH
38582: CALL_OW 1
38586: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38587: LD_ADDR_EXP 122
38591: PUSH
38592: LD_EXP 122
38596: PPUSH
38597: LD_VAR 0 4
38601: PPUSH
38602: EMPTY
38603: PPUSH
38604: CALL_OW 1
38608: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38609: LD_ADDR_EXP 123
38613: PUSH
38614: LD_EXP 123
38618: PPUSH
38619: LD_VAR 0 4
38623: PPUSH
38624: EMPTY
38625: PPUSH
38626: CALL_OW 1
38630: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38631: LD_ADDR_EXP 124
38635: PUSH
38636: LD_EXP 124
38640: PPUSH
38641: LD_VAR 0 4
38645: PPUSH
38646: EMPTY
38647: PPUSH
38648: CALL_OW 1
38652: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38653: LD_ADDR_EXP 125
38657: PUSH
38658: LD_EXP 125
38662: PPUSH
38663: LD_VAR 0 4
38667: PPUSH
38668: EMPTY
38669: PPUSH
38670: CALL_OW 1
38674: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38675: LD_ADDR_EXP 127
38679: PUSH
38680: LD_EXP 127
38684: PPUSH
38685: LD_VAR 0 4
38689: PPUSH
38690: EMPTY
38691: PPUSH
38692: CALL_OW 1
38696: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38697: LD_ADDR_EXP 129
38701: PUSH
38702: LD_EXP 129
38706: PPUSH
38707: LD_VAR 0 4
38711: PPUSH
38712: EMPTY
38713: PPUSH
38714: CALL_OW 1
38718: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38719: LD_ADDR_EXP 130
38723: PUSH
38724: LD_EXP 130
38728: PPUSH
38729: LD_VAR 0 4
38733: PPUSH
38734: EMPTY
38735: PPUSH
38736: CALL_OW 1
38740: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38741: LD_ADDR_EXP 131
38745: PUSH
38746: LD_EXP 131
38750: PPUSH
38751: LD_VAR 0 4
38755: PPUSH
38756: EMPTY
38757: PPUSH
38758: CALL_OW 1
38762: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38763: LD_ADDR_EXP 132
38767: PUSH
38768: LD_EXP 132
38772: PPUSH
38773: LD_VAR 0 4
38777: PPUSH
38778: EMPTY
38779: PPUSH
38780: CALL_OW 1
38784: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38785: LD_ADDR_EXP 133
38789: PUSH
38790: LD_EXP 133
38794: PPUSH
38795: LD_VAR 0 4
38799: PPUSH
38800: EMPTY
38801: PPUSH
38802: CALL_OW 1
38806: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38807: LD_ADDR_EXP 134
38811: PUSH
38812: LD_EXP 134
38816: PPUSH
38817: LD_VAR 0 4
38821: PPUSH
38822: EMPTY
38823: PPUSH
38824: CALL_OW 1
38828: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38829: LD_ADDR_EXP 135
38833: PUSH
38834: LD_EXP 135
38838: PPUSH
38839: LD_VAR 0 4
38843: PPUSH
38844: EMPTY
38845: PPUSH
38846: CALL_OW 1
38850: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38851: LD_ADDR_EXP 136
38855: PUSH
38856: LD_EXP 136
38860: PPUSH
38861: LD_VAR 0 4
38865: PPUSH
38866: EMPTY
38867: PPUSH
38868: CALL_OW 1
38872: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38873: LD_ADDR_EXP 137
38877: PUSH
38878: LD_EXP 137
38882: PPUSH
38883: LD_VAR 0 4
38887: PPUSH
38888: EMPTY
38889: PPUSH
38890: CALL_OW 1
38894: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38895: LD_ADDR_EXP 138
38899: PUSH
38900: LD_EXP 138
38904: PPUSH
38905: LD_VAR 0 4
38909: PPUSH
38910: EMPTY
38911: PPUSH
38912: CALL_OW 1
38916: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38917: LD_ADDR_EXP 139
38921: PUSH
38922: LD_EXP 139
38926: PPUSH
38927: LD_VAR 0 4
38931: PPUSH
38932: EMPTY
38933: PPUSH
38934: CALL_OW 1
38938: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38939: LD_ADDR_EXP 140
38943: PUSH
38944: LD_EXP 140
38948: PPUSH
38949: LD_VAR 0 4
38953: PPUSH
38954: EMPTY
38955: PPUSH
38956: CALL_OW 1
38960: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38961: LD_ADDR_EXP 141
38965: PUSH
38966: LD_EXP 141
38970: PPUSH
38971: LD_VAR 0 4
38975: PPUSH
38976: EMPTY
38977: PPUSH
38978: CALL_OW 1
38982: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38983: LD_ADDR_EXP 142
38987: PUSH
38988: LD_EXP 142
38992: PPUSH
38993: LD_VAR 0 4
38997: PPUSH
38998: LD_INT 0
39000: PPUSH
39001: CALL_OW 1
39005: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39006: LD_ADDR_EXP 143
39010: PUSH
39011: LD_EXP 143
39015: PPUSH
39016: LD_VAR 0 4
39020: PPUSH
39021: LD_INT 0
39023: PPUSH
39024: CALL_OW 1
39028: ST_TO_ADDR
// result := base ;
39029: LD_ADDR_VAR 0 3
39033: PUSH
39034: LD_VAR 0 4
39038: ST_TO_ADDR
// end ;
39039: LD_VAR 0 3
39043: RET
// export function MC_Start ( ) ; var i ; begin
39044: LD_INT 0
39046: PPUSH
39047: PPUSH
// for i = 1 to mc_bases do
39048: LD_ADDR_VAR 0 2
39052: PUSH
39053: DOUBLE
39054: LD_INT 1
39056: DEC
39057: ST_TO_ADDR
39058: LD_EXP 100
39062: PUSH
39063: FOR_TO
39064: IFFALSE 40164
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
39066: LD_ADDR_EXP 100
39070: PUSH
39071: LD_EXP 100
39075: PPUSH
39076: LD_VAR 0 2
39080: PPUSH
39081: LD_EXP 100
39085: PUSH
39086: LD_VAR 0 2
39090: ARRAY
39091: PUSH
39092: LD_INT 0
39094: DIFF
39095: PPUSH
39096: CALL_OW 1
39100: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
39101: LD_ADDR_EXP 101
39105: PUSH
39106: LD_EXP 101
39110: PPUSH
39111: LD_VAR 0 2
39115: PPUSH
39116: EMPTY
39117: PPUSH
39118: CALL_OW 1
39122: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
39123: LD_ADDR_EXP 102
39127: PUSH
39128: LD_EXP 102
39132: PPUSH
39133: LD_VAR 0 2
39137: PPUSH
39138: EMPTY
39139: PPUSH
39140: CALL_OW 1
39144: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
39145: LD_ADDR_EXP 103
39149: PUSH
39150: LD_EXP 103
39154: PPUSH
39155: LD_VAR 0 2
39159: PPUSH
39160: EMPTY
39161: PPUSH
39162: CALL_OW 1
39166: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
39167: LD_ADDR_EXP 104
39171: PUSH
39172: LD_EXP 104
39176: PPUSH
39177: LD_VAR 0 2
39181: PPUSH
39182: EMPTY
39183: PUSH
39184: EMPTY
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PPUSH
39190: CALL_OW 1
39194: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
39195: LD_ADDR_EXP 105
39199: PUSH
39200: LD_EXP 105
39204: PPUSH
39205: LD_VAR 0 2
39209: PPUSH
39210: EMPTY
39211: PPUSH
39212: CALL_OW 1
39216: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
39217: LD_ADDR_EXP 132
39221: PUSH
39222: LD_EXP 132
39226: PPUSH
39227: LD_VAR 0 2
39231: PPUSH
39232: EMPTY
39233: PPUSH
39234: CALL_OW 1
39238: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
39239: LD_ADDR_EXP 106
39243: PUSH
39244: LD_EXP 106
39248: PPUSH
39249: LD_VAR 0 2
39253: PPUSH
39254: EMPTY
39255: PPUSH
39256: CALL_OW 1
39260: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
39261: LD_ADDR_EXP 107
39265: PUSH
39266: LD_EXP 107
39270: PPUSH
39271: LD_VAR 0 2
39275: PPUSH
39276: EMPTY
39277: PPUSH
39278: CALL_OW 1
39282: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
39283: LD_ADDR_EXP 108
39287: PUSH
39288: LD_EXP 108
39292: PPUSH
39293: LD_VAR 0 2
39297: PPUSH
39298: LD_EXP 100
39302: PUSH
39303: LD_VAR 0 2
39307: ARRAY
39308: PPUSH
39309: LD_INT 2
39311: PUSH
39312: LD_INT 30
39314: PUSH
39315: LD_INT 32
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 30
39324: PUSH
39325: LD_INT 33
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: LIST
39336: PPUSH
39337: CALL_OW 72
39341: PPUSH
39342: CALL_OW 1
39346: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39347: LD_ADDR_EXP 109
39351: PUSH
39352: LD_EXP 109
39356: PPUSH
39357: LD_VAR 0 2
39361: PPUSH
39362: LD_EXP 100
39366: PUSH
39367: LD_VAR 0 2
39371: ARRAY
39372: PPUSH
39373: LD_INT 2
39375: PUSH
39376: LD_INT 30
39378: PUSH
39379: LD_INT 32
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PUSH
39386: LD_INT 30
39388: PUSH
39389: LD_INT 31
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 58
39403: PUSH
39404: EMPTY
39405: LIST
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PPUSH
39411: CALL_OW 72
39415: PPUSH
39416: CALL_OW 1
39420: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39421: LD_ADDR_EXP 110
39425: PUSH
39426: LD_EXP 110
39430: PPUSH
39431: LD_VAR 0 2
39435: PPUSH
39436: EMPTY
39437: PPUSH
39438: CALL_OW 1
39442: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39443: LD_ADDR_EXP 114
39447: PUSH
39448: LD_EXP 114
39452: PPUSH
39453: LD_VAR 0 2
39457: PPUSH
39458: EMPTY
39459: PPUSH
39460: CALL_OW 1
39464: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39465: LD_ADDR_EXP 113
39469: PUSH
39470: LD_EXP 113
39474: PPUSH
39475: LD_VAR 0 2
39479: PPUSH
39480: EMPTY
39481: PPUSH
39482: CALL_OW 1
39486: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39487: LD_ADDR_EXP 115
39491: PUSH
39492: LD_EXP 115
39496: PPUSH
39497: LD_VAR 0 2
39501: PPUSH
39502: EMPTY
39503: PPUSH
39504: CALL_OW 1
39508: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39509: LD_ADDR_EXP 116
39513: PUSH
39514: LD_EXP 116
39518: PPUSH
39519: LD_VAR 0 2
39523: PPUSH
39524: EMPTY
39525: PPUSH
39526: CALL_OW 1
39530: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39531: LD_ADDR_EXP 117
39535: PUSH
39536: LD_EXP 117
39540: PPUSH
39541: LD_VAR 0 2
39545: PPUSH
39546: EMPTY
39547: PPUSH
39548: CALL_OW 1
39552: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39553: LD_ADDR_EXP 118
39557: PUSH
39558: LD_EXP 118
39562: PPUSH
39563: LD_VAR 0 2
39567: PPUSH
39568: EMPTY
39569: PPUSH
39570: CALL_OW 1
39574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39575: LD_ADDR_EXP 119
39579: PUSH
39580: LD_EXP 119
39584: PPUSH
39585: LD_VAR 0 2
39589: PPUSH
39590: EMPTY
39591: PPUSH
39592: CALL_OW 1
39596: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39597: LD_ADDR_EXP 120
39601: PUSH
39602: LD_EXP 120
39606: PPUSH
39607: LD_VAR 0 2
39611: PPUSH
39612: EMPTY
39613: PPUSH
39614: CALL_OW 1
39618: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
39619: LD_ADDR_EXP 121
39623: PUSH
39624: LD_EXP 121
39628: PPUSH
39629: LD_VAR 0 2
39633: PPUSH
39634: EMPTY
39635: PPUSH
39636: CALL_OW 1
39640: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39641: LD_ADDR_EXP 122
39645: PUSH
39646: LD_EXP 122
39650: PPUSH
39651: LD_VAR 0 2
39655: PPUSH
39656: EMPTY
39657: PPUSH
39658: CALL_OW 1
39662: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
39663: LD_ADDR_EXP 111
39667: PUSH
39668: LD_EXP 111
39672: PPUSH
39673: LD_VAR 0 2
39677: PPUSH
39678: LD_INT 0
39680: PPUSH
39681: CALL_OW 1
39685: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
39686: LD_ADDR_EXP 124
39690: PUSH
39691: LD_EXP 124
39695: PPUSH
39696: LD_VAR 0 2
39700: PPUSH
39701: LD_INT 0
39703: PPUSH
39704: CALL_OW 1
39708: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39709: LD_ADDR_EXP 112
39713: PUSH
39714: LD_EXP 112
39718: PPUSH
39719: LD_VAR 0 2
39723: PPUSH
39724: EMPTY
39725: PPUSH
39726: CALL_OW 1
39730: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
39731: LD_ADDR_EXP 123
39735: PUSH
39736: LD_EXP 123
39740: PPUSH
39741: LD_VAR 0 2
39745: PPUSH
39746: LD_INT 0
39748: PPUSH
39749: CALL_OW 1
39753: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
39754: LD_ADDR_EXP 125
39758: PUSH
39759: LD_EXP 125
39763: PPUSH
39764: LD_VAR 0 2
39768: PPUSH
39769: EMPTY
39770: PPUSH
39771: CALL_OW 1
39775: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
39776: LD_ADDR_EXP 128
39780: PUSH
39781: LD_EXP 128
39785: PPUSH
39786: LD_VAR 0 2
39790: PPUSH
39791: LD_INT 0
39793: PPUSH
39794: CALL_OW 1
39798: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
39799: LD_ADDR_EXP 129
39803: PUSH
39804: LD_EXP 129
39808: PPUSH
39809: LD_VAR 0 2
39813: PPUSH
39814: EMPTY
39815: PPUSH
39816: CALL_OW 1
39820: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39821: LD_ADDR_EXP 130
39825: PUSH
39826: LD_EXP 130
39830: PPUSH
39831: LD_VAR 0 2
39835: PPUSH
39836: EMPTY
39837: PPUSH
39838: CALL_OW 1
39842: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39843: LD_ADDR_EXP 131
39847: PUSH
39848: LD_EXP 131
39852: PPUSH
39853: LD_VAR 0 2
39857: PPUSH
39858: EMPTY
39859: PPUSH
39860: CALL_OW 1
39864: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
39865: LD_ADDR_EXP 133
39869: PUSH
39870: LD_EXP 133
39874: PPUSH
39875: LD_VAR 0 2
39879: PPUSH
39880: LD_EXP 100
39884: PUSH
39885: LD_VAR 0 2
39889: ARRAY
39890: PPUSH
39891: LD_INT 2
39893: PUSH
39894: LD_INT 30
39896: PUSH
39897: LD_INT 6
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 30
39906: PUSH
39907: LD_INT 7
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 30
39916: PUSH
39917: LD_INT 8
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: PPUSH
39930: CALL_OW 72
39934: PPUSH
39935: CALL_OW 1
39939: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
39940: LD_ADDR_EXP 134
39944: PUSH
39945: LD_EXP 134
39949: PPUSH
39950: LD_VAR 0 2
39954: PPUSH
39955: EMPTY
39956: PPUSH
39957: CALL_OW 1
39961: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
39962: LD_ADDR_EXP 135
39966: PUSH
39967: LD_EXP 135
39971: PPUSH
39972: LD_VAR 0 2
39976: PPUSH
39977: EMPTY
39978: PPUSH
39979: CALL_OW 1
39983: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
39984: LD_ADDR_EXP 136
39988: PUSH
39989: LD_EXP 136
39993: PPUSH
39994: LD_VAR 0 2
39998: PPUSH
39999: EMPTY
40000: PPUSH
40001: CALL_OW 1
40005: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
40006: LD_ADDR_EXP 137
40010: PUSH
40011: LD_EXP 137
40015: PPUSH
40016: LD_VAR 0 2
40020: PPUSH
40021: EMPTY
40022: PPUSH
40023: CALL_OW 1
40027: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40028: LD_ADDR_EXP 138
40032: PUSH
40033: LD_EXP 138
40037: PPUSH
40038: LD_VAR 0 2
40042: PPUSH
40043: EMPTY
40044: PPUSH
40045: CALL_OW 1
40049: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
40050: LD_ADDR_EXP 139
40054: PUSH
40055: LD_EXP 139
40059: PPUSH
40060: LD_VAR 0 2
40064: PPUSH
40065: EMPTY
40066: PPUSH
40067: CALL_OW 1
40071: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
40072: LD_ADDR_EXP 140
40076: PUSH
40077: LD_EXP 140
40081: PPUSH
40082: LD_VAR 0 2
40086: PPUSH
40087: EMPTY
40088: PPUSH
40089: CALL_OW 1
40093: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
40094: LD_ADDR_EXP 141
40098: PUSH
40099: LD_EXP 141
40103: PPUSH
40104: LD_VAR 0 2
40108: PPUSH
40109: EMPTY
40110: PPUSH
40111: CALL_OW 1
40115: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
40116: LD_ADDR_EXP 142
40120: PUSH
40121: LD_EXP 142
40125: PPUSH
40126: LD_VAR 0 2
40130: PPUSH
40131: LD_INT 0
40133: PPUSH
40134: CALL_OW 1
40138: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
40139: LD_ADDR_EXP 143
40143: PUSH
40144: LD_EXP 143
40148: PPUSH
40149: LD_VAR 0 2
40153: PPUSH
40154: LD_INT 0
40156: PPUSH
40157: CALL_OW 1
40161: ST_TO_ADDR
// end ;
40162: GO 39063
40164: POP
40165: POP
// MC_InitSides ( ) ;
40166: CALL 40452 0 0
// MC_InitResearch ( ) ;
40170: CALL 40191 0 0
// CustomInitMacro ( ) ;
40174: CALL 475 0 0
// skirmish := true ;
40178: LD_ADDR_EXP 98
40182: PUSH
40183: LD_INT 1
40185: ST_TO_ADDR
// end ;
40186: LD_VAR 0 1
40190: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
40191: LD_INT 0
40193: PPUSH
40194: PPUSH
40195: PPUSH
40196: PPUSH
40197: PPUSH
40198: PPUSH
// if not mc_bases then
40199: LD_EXP 100
40203: NOT
40204: IFFALSE 40208
// exit ;
40206: GO 40447
// for i = 1 to 8 do
40208: LD_ADDR_VAR 0 2
40212: PUSH
40213: DOUBLE
40214: LD_INT 1
40216: DEC
40217: ST_TO_ADDR
40218: LD_INT 8
40220: PUSH
40221: FOR_TO
40222: IFFALSE 40248
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
40224: LD_ADDR_EXP 127
40228: PUSH
40229: LD_EXP 127
40233: PPUSH
40234: LD_VAR 0 2
40238: PPUSH
40239: EMPTY
40240: PPUSH
40241: CALL_OW 1
40245: ST_TO_ADDR
40246: GO 40221
40248: POP
40249: POP
// tmp := [ ] ;
40250: LD_ADDR_VAR 0 5
40254: PUSH
40255: EMPTY
40256: ST_TO_ADDR
// for i = 1 to mc_sides do
40257: LD_ADDR_VAR 0 2
40261: PUSH
40262: DOUBLE
40263: LD_INT 1
40265: DEC
40266: ST_TO_ADDR
40267: LD_EXP 126
40271: PUSH
40272: FOR_TO
40273: IFFALSE 40331
// if not mc_sides [ i ] in tmp then
40275: LD_EXP 126
40279: PUSH
40280: LD_VAR 0 2
40284: ARRAY
40285: PUSH
40286: LD_VAR 0 5
40290: IN
40291: NOT
40292: IFFALSE 40329
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
40294: LD_ADDR_VAR 0 5
40298: PUSH
40299: LD_VAR 0 5
40303: PPUSH
40304: LD_VAR 0 5
40308: PUSH
40309: LD_INT 1
40311: PLUS
40312: PPUSH
40313: LD_EXP 126
40317: PUSH
40318: LD_VAR 0 2
40322: ARRAY
40323: PPUSH
40324: CALL_OW 2
40328: ST_TO_ADDR
40329: GO 40272
40331: POP
40332: POP
// if not tmp then
40333: LD_VAR 0 5
40337: NOT
40338: IFFALSE 40342
// exit ;
40340: GO 40447
// for j in tmp do
40342: LD_ADDR_VAR 0 3
40346: PUSH
40347: LD_VAR 0 5
40351: PUSH
40352: FOR_IN
40353: IFFALSE 40445
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40355: LD_ADDR_VAR 0 6
40359: PUSH
40360: LD_INT 22
40362: PUSH
40363: LD_VAR 0 3
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PPUSH
40372: CALL_OW 69
40376: ST_TO_ADDR
// if not un then
40377: LD_VAR 0 6
40381: NOT
40382: IFFALSE 40386
// continue ;
40384: GO 40352
// nation := GetNation ( un [ 1 ] ) ;
40386: LD_ADDR_VAR 0 4
40390: PUSH
40391: LD_VAR 0 6
40395: PUSH
40396: LD_INT 1
40398: ARRAY
40399: PPUSH
40400: CALL_OW 248
40404: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40405: LD_ADDR_EXP 127
40409: PUSH
40410: LD_EXP 127
40414: PPUSH
40415: LD_VAR 0 3
40419: PPUSH
40420: LD_VAR 0 3
40424: PPUSH
40425: LD_VAR 0 4
40429: PPUSH
40430: LD_INT 1
40432: PPUSH
40433: CALL 67599 0 3
40437: PPUSH
40438: CALL_OW 1
40442: ST_TO_ADDR
// end ;
40443: GO 40352
40445: POP
40446: POP
// end ;
40447: LD_VAR 0 1
40451: RET
// export function MC_InitSides ( ) ; var i ; begin
40452: LD_INT 0
40454: PPUSH
40455: PPUSH
// if not mc_bases then
40456: LD_EXP 100
40460: NOT
40461: IFFALSE 40465
// exit ;
40463: GO 40539
// for i = 1 to mc_bases do
40465: LD_ADDR_VAR 0 2
40469: PUSH
40470: DOUBLE
40471: LD_INT 1
40473: DEC
40474: ST_TO_ADDR
40475: LD_EXP 100
40479: PUSH
40480: FOR_TO
40481: IFFALSE 40537
// if mc_bases [ i ] then
40483: LD_EXP 100
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: IFFALSE 40535
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40495: LD_ADDR_EXP 126
40499: PUSH
40500: LD_EXP 126
40504: PPUSH
40505: LD_VAR 0 2
40509: PPUSH
40510: LD_EXP 100
40514: PUSH
40515: LD_VAR 0 2
40519: ARRAY
40520: PUSH
40521: LD_INT 1
40523: ARRAY
40524: PPUSH
40525: CALL_OW 255
40529: PPUSH
40530: CALL_OW 1
40534: ST_TO_ADDR
40535: GO 40480
40537: POP
40538: POP
// end ;
40539: LD_VAR 0 1
40543: RET
// every 0 0$03 trigger skirmish do
40544: LD_EXP 98
40548: IFFALSE 40702
40550: GO 40552
40552: DISABLE
// begin enable ;
40553: ENABLE
// MC_CheckBuildings ( ) ;
40554: CALL 45200 0 0
// MC_CheckPeopleLife ( ) ;
40558: CALL 45361 0 0
// RaiseSailEvent ( 100 ) ;
40562: LD_INT 100
40564: PPUSH
40565: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40569: LD_INT 103
40571: PPUSH
40572: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40576: LD_INT 104
40578: PPUSH
40579: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40583: LD_INT 105
40585: PPUSH
40586: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
40590: LD_INT 106
40592: PPUSH
40593: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
40597: LD_INT 107
40599: PPUSH
40600: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
40604: LD_INT 108
40606: PPUSH
40607: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
40611: LD_INT 109
40613: PPUSH
40614: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
40618: LD_INT 110
40620: PPUSH
40621: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
40625: LD_INT 111
40627: PPUSH
40628: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
40632: LD_INT 112
40634: PPUSH
40635: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
40639: LD_INT 113
40641: PPUSH
40642: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
40646: LD_INT 120
40648: PPUSH
40649: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
40653: LD_INT 121
40655: PPUSH
40656: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
40660: LD_INT 122
40662: PPUSH
40663: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
40667: LD_INT 123
40669: PPUSH
40670: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
40674: LD_INT 124
40676: PPUSH
40677: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
40681: LD_INT 125
40683: PPUSH
40684: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
40688: LD_INT 126
40690: PPUSH
40691: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
40695: LD_INT 200
40697: PPUSH
40698: CALL_OW 427
// end ;
40702: END
// on SailEvent ( event ) do begin if event < 100 then
40703: LD_VAR 0 1
40707: PUSH
40708: LD_INT 100
40710: LESS
40711: IFFALSE 40722
// CustomEvent ( event ) ;
40713: LD_VAR 0 1
40717: PPUSH
40718: CALL 35178 0 1
// if event = 100 then
40722: LD_VAR 0 1
40726: PUSH
40727: LD_INT 100
40729: EQUAL
40730: IFFALSE 40736
// MC_ClassManager ( ) ;
40732: CALL 41128 0 0
// if event = 101 then
40736: LD_VAR 0 1
40740: PUSH
40741: LD_INT 101
40743: EQUAL
40744: IFFALSE 40750
// MC_RepairBuildings ( ) ;
40746: CALL 45946 0 0
// if event = 102 then
40750: LD_VAR 0 1
40754: PUSH
40755: LD_INT 102
40757: EQUAL
40758: IFFALSE 40764
// MC_Heal ( ) ;
40760: CALL 46881 0 0
// if event = 103 then
40764: LD_VAR 0 1
40768: PUSH
40769: LD_INT 103
40771: EQUAL
40772: IFFALSE 40778
// MC_Build ( ) ;
40774: CALL 47303 0 0
// if event = 104 then
40778: LD_VAR 0 1
40782: PUSH
40783: LD_INT 104
40785: EQUAL
40786: IFFALSE 40792
// MC_TurretWeapon ( ) ;
40788: CALL 48937 0 0
// if event = 105 then
40792: LD_VAR 0 1
40796: PUSH
40797: LD_INT 105
40799: EQUAL
40800: IFFALSE 40806
// MC_BuildUpgrade ( ) ;
40802: CALL 48488 0 0
// if event = 106 then
40806: LD_VAR 0 1
40810: PUSH
40811: LD_INT 106
40813: EQUAL
40814: IFFALSE 40820
// MC_PlantMines ( ) ;
40816: CALL 49367 0 0
// if event = 107 then
40820: LD_VAR 0 1
40824: PUSH
40825: LD_INT 107
40827: EQUAL
40828: IFFALSE 40834
// MC_CollectCrates ( ) ;
40830: CALL 50158 0 0
// if event = 108 then
40834: LD_VAR 0 1
40838: PUSH
40839: LD_INT 108
40841: EQUAL
40842: IFFALSE 40848
// MC_LinkRemoteControl ( ) ;
40844: CALL 52008 0 0
// if event = 109 then
40848: LD_VAR 0 1
40852: PUSH
40853: LD_INT 109
40855: EQUAL
40856: IFFALSE 40862
// MC_ProduceVehicle ( ) ;
40858: CALL 52189 0 0
// if event = 110 then
40862: LD_VAR 0 1
40866: PUSH
40867: LD_INT 110
40869: EQUAL
40870: IFFALSE 40876
// MC_SendAttack ( ) ;
40872: CALL 52655 0 0
// if event = 111 then
40876: LD_VAR 0 1
40880: PUSH
40881: LD_INT 111
40883: EQUAL
40884: IFFALSE 40890
// MC_Defend ( ) ;
40886: CALL 52763 0 0
// if event = 112 then
40890: LD_VAR 0 1
40894: PUSH
40895: LD_INT 112
40897: EQUAL
40898: IFFALSE 40904
// MC_Research ( ) ;
40900: CALL 53643 0 0
// if event = 113 then
40904: LD_VAR 0 1
40908: PUSH
40909: LD_INT 113
40911: EQUAL
40912: IFFALSE 40918
// MC_MinesTrigger ( ) ;
40914: CALL 54757 0 0
// if event = 120 then
40918: LD_VAR 0 1
40922: PUSH
40923: LD_INT 120
40925: EQUAL
40926: IFFALSE 40932
// MC_RepairVehicle ( ) ;
40928: CALL 54856 0 0
// if event = 121 then
40932: LD_VAR 0 1
40936: PUSH
40937: LD_INT 121
40939: EQUAL
40940: IFFALSE 40946
// MC_TameApe ( ) ;
40942: CALL 55625 0 0
// if event = 122 then
40946: LD_VAR 0 1
40950: PUSH
40951: LD_INT 122
40953: EQUAL
40954: IFFALSE 40960
// MC_ChangeApeClass ( ) ;
40956: CALL 56454 0 0
// if event = 123 then
40960: LD_VAR 0 1
40964: PUSH
40965: LD_INT 123
40967: EQUAL
40968: IFFALSE 40974
// MC_Bazooka ( ) ;
40970: CALL 57104 0 0
// if event = 124 then
40974: LD_VAR 0 1
40978: PUSH
40979: LD_INT 124
40981: EQUAL
40982: IFFALSE 40988
// MC_TeleportExit ( ) ;
40984: CALL 57302 0 0
// if event = 125 then
40988: LD_VAR 0 1
40992: PUSH
40993: LD_INT 125
40995: EQUAL
40996: IFFALSE 41002
// MC_Deposits ( ) ;
40998: CALL 57949 0 0
// if event = 126 then
41002: LD_VAR 0 1
41006: PUSH
41007: LD_INT 126
41009: EQUAL
41010: IFFALSE 41016
// MC_RemoteDriver ( ) ;
41012: CALL 58574 0 0
// if event = 200 then
41016: LD_VAR 0 1
41020: PUSH
41021: LD_INT 200
41023: EQUAL
41024: IFFALSE 41030
// MC_Idle ( ) ;
41026: CALL 60523 0 0
// end ;
41030: PPOPN 1
41032: END
// export function MC_Reset ( base , tag ) ; var i ; begin
41033: LD_INT 0
41035: PPUSH
41036: PPUSH
// if not mc_bases [ base ] or not tag then
41037: LD_EXP 100
41041: PUSH
41042: LD_VAR 0 1
41046: ARRAY
41047: NOT
41048: PUSH
41049: LD_VAR 0 2
41053: NOT
41054: OR
41055: IFFALSE 41059
// exit ;
41057: GO 41123
// for i in mc_bases [ base ] union mc_ape [ base ] do
41059: LD_ADDR_VAR 0 4
41063: PUSH
41064: LD_EXP 100
41068: PUSH
41069: LD_VAR 0 1
41073: ARRAY
41074: PUSH
41075: LD_EXP 129
41079: PUSH
41080: LD_VAR 0 1
41084: ARRAY
41085: UNION
41086: PUSH
41087: FOR_IN
41088: IFFALSE 41121
// if GetTag ( i ) = tag then
41090: LD_VAR 0 4
41094: PPUSH
41095: CALL_OW 110
41099: PUSH
41100: LD_VAR 0 2
41104: EQUAL
41105: IFFALSE 41119
// SetTag ( i , 0 ) ;
41107: LD_VAR 0 4
41111: PPUSH
41112: LD_INT 0
41114: PPUSH
41115: CALL_OW 109
41119: GO 41087
41121: POP
41122: POP
// end ;
41123: LD_VAR 0 3
41127: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
41128: LD_INT 0
41130: PPUSH
41131: PPUSH
41132: PPUSH
41133: PPUSH
41134: PPUSH
41135: PPUSH
41136: PPUSH
41137: PPUSH
// if not mc_bases then
41138: LD_EXP 100
41142: NOT
41143: IFFALSE 41147
// exit ;
41145: GO 41605
// for i = 1 to mc_bases do
41147: LD_ADDR_VAR 0 2
41151: PUSH
41152: DOUBLE
41153: LD_INT 1
41155: DEC
41156: ST_TO_ADDR
41157: LD_EXP 100
41161: PUSH
41162: FOR_TO
41163: IFFALSE 41603
// begin tmp := MC_ClassCheckReq ( i ) ;
41165: LD_ADDR_VAR 0 4
41169: PUSH
41170: LD_VAR 0 2
41174: PPUSH
41175: CALL 41610 0 1
41179: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
41180: LD_ADDR_EXP 141
41184: PUSH
41185: LD_EXP 141
41189: PPUSH
41190: LD_VAR 0 2
41194: PPUSH
41195: LD_VAR 0 4
41199: PPUSH
41200: CALL_OW 1
41204: ST_TO_ADDR
// if not tmp then
41205: LD_VAR 0 4
41209: NOT
41210: IFFALSE 41214
// continue ;
41212: GO 41162
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
41214: LD_ADDR_VAR 0 6
41218: PUSH
41219: LD_EXP 100
41223: PUSH
41224: LD_VAR 0 2
41228: ARRAY
41229: PPUSH
41230: LD_INT 2
41232: PUSH
41233: LD_INT 30
41235: PUSH
41236: LD_INT 4
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 30
41245: PUSH
41246: LD_INT 5
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: LIST
41257: PPUSH
41258: CALL_OW 72
41262: PUSH
41263: LD_EXP 100
41267: PUSH
41268: LD_VAR 0 2
41272: ARRAY
41273: PPUSH
41274: LD_INT 2
41276: PUSH
41277: LD_INT 30
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 30
41289: PUSH
41290: LD_INT 1
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: LIST
41301: PPUSH
41302: CALL_OW 72
41306: PUSH
41307: LD_EXP 100
41311: PUSH
41312: LD_VAR 0 2
41316: ARRAY
41317: PPUSH
41318: LD_INT 30
41320: PUSH
41321: LD_INT 3
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PPUSH
41328: CALL_OW 72
41332: PUSH
41333: LD_EXP 100
41337: PUSH
41338: LD_VAR 0 2
41342: ARRAY
41343: PPUSH
41344: LD_INT 2
41346: PUSH
41347: LD_INT 30
41349: PUSH
41350: LD_INT 6
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 30
41359: PUSH
41360: LD_INT 7
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 30
41369: PUSH
41370: LD_INT 8
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: PPUSH
41383: CALL_OW 72
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: LIST
41392: LIST
41393: ST_TO_ADDR
// for j = 1 to 4 do
41394: LD_ADDR_VAR 0 3
41398: PUSH
41399: DOUBLE
41400: LD_INT 1
41402: DEC
41403: ST_TO_ADDR
41404: LD_INT 4
41406: PUSH
41407: FOR_TO
41408: IFFALSE 41599
// begin if not tmp [ j ] then
41410: LD_VAR 0 4
41414: PUSH
41415: LD_VAR 0 3
41419: ARRAY
41420: NOT
41421: IFFALSE 41425
// continue ;
41423: GO 41407
// for p in tmp [ j ] do
41425: LD_ADDR_VAR 0 5
41429: PUSH
41430: LD_VAR 0 4
41434: PUSH
41435: LD_VAR 0 3
41439: ARRAY
41440: PUSH
41441: FOR_IN
41442: IFFALSE 41595
// begin if not b [ j ] then
41444: LD_VAR 0 6
41448: PUSH
41449: LD_VAR 0 3
41453: ARRAY
41454: NOT
41455: IFFALSE 41459
// break ;
41457: GO 41595
// e := 0 ;
41459: LD_ADDR_VAR 0 7
41463: PUSH
41464: LD_INT 0
41466: ST_TO_ADDR
// for k in b [ j ] do
41467: LD_ADDR_VAR 0 8
41471: PUSH
41472: LD_VAR 0 6
41476: PUSH
41477: LD_VAR 0 3
41481: ARRAY
41482: PUSH
41483: FOR_IN
41484: IFFALSE 41511
// if IsNotFull ( k ) then
41486: LD_VAR 0 8
41490: PPUSH
41491: CALL 69752 0 1
41495: IFFALSE 41509
// begin e := k ;
41497: LD_ADDR_VAR 0 7
41501: PUSH
41502: LD_VAR 0 8
41506: ST_TO_ADDR
// break ;
41507: GO 41511
// end ;
41509: GO 41483
41511: POP
41512: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41513: LD_VAR 0 7
41517: PUSH
41518: LD_VAR 0 5
41522: PPUSH
41523: LD_VAR 0 7
41527: PPUSH
41528: CALL 103648 0 2
41532: NOT
41533: AND
41534: IFFALSE 41593
// begin if IsInUnit ( p ) then
41536: LD_VAR 0 5
41540: PPUSH
41541: CALL_OW 310
41545: IFFALSE 41556
// ComExitBuilding ( p ) ;
41547: LD_VAR 0 5
41551: PPUSH
41552: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41556: LD_VAR 0 5
41560: PPUSH
41561: LD_VAR 0 7
41565: PPUSH
41566: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41570: LD_VAR 0 5
41574: PPUSH
41575: LD_VAR 0 3
41579: PPUSH
41580: CALL_OW 183
// AddComExitBuilding ( p ) ;
41584: LD_VAR 0 5
41588: PPUSH
41589: CALL_OW 182
// end ; end ;
41593: GO 41441
41595: POP
41596: POP
// end ;
41597: GO 41407
41599: POP
41600: POP
// end ;
41601: GO 41162
41603: POP
41604: POP
// end ;
41605: LD_VAR 0 1
41609: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
41610: LD_INT 0
41612: PPUSH
41613: PPUSH
41614: PPUSH
41615: PPUSH
41616: PPUSH
41617: PPUSH
41618: PPUSH
41619: PPUSH
41620: PPUSH
41621: PPUSH
41622: PPUSH
41623: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41624: LD_VAR 0 1
41628: NOT
41629: PUSH
41630: LD_EXP 100
41634: PUSH
41635: LD_VAR 0 1
41639: ARRAY
41640: NOT
41641: OR
41642: PUSH
41643: LD_EXP 100
41647: PUSH
41648: LD_VAR 0 1
41652: ARRAY
41653: PPUSH
41654: LD_INT 2
41656: PUSH
41657: LD_INT 30
41659: PUSH
41660: LD_INT 0
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: LD_INT 30
41669: PUSH
41670: LD_INT 1
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: LIST
41681: PPUSH
41682: CALL_OW 72
41686: NOT
41687: OR
41688: IFFALSE 41692
// exit ;
41690: GO 45195
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41692: LD_ADDR_VAR 0 4
41696: PUSH
41697: LD_EXP 100
41701: PUSH
41702: LD_VAR 0 1
41706: ARRAY
41707: PPUSH
41708: LD_INT 2
41710: PUSH
41711: LD_INT 25
41713: PUSH
41714: LD_INT 1
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 25
41723: PUSH
41724: LD_INT 2
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 25
41733: PUSH
41734: LD_INT 3
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 25
41743: PUSH
41744: LD_INT 4
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 25
41753: PUSH
41754: LD_INT 5
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 25
41763: PUSH
41764: LD_INT 8
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PUSH
41771: LD_INT 25
41773: PUSH
41774: LD_INT 9
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: PPUSH
41791: CALL_OW 72
41795: ST_TO_ADDR
// if not tmp then
41796: LD_VAR 0 4
41800: NOT
41801: IFFALSE 41805
// exit ;
41803: GO 45195
// for i in tmp do
41805: LD_ADDR_VAR 0 3
41809: PUSH
41810: LD_VAR 0 4
41814: PUSH
41815: FOR_IN
41816: IFFALSE 41847
// if GetTag ( i ) then
41818: LD_VAR 0 3
41822: PPUSH
41823: CALL_OW 110
41827: IFFALSE 41845
// tmp := tmp diff i ;
41829: LD_ADDR_VAR 0 4
41833: PUSH
41834: LD_VAR 0 4
41838: PUSH
41839: LD_VAR 0 3
41843: DIFF
41844: ST_TO_ADDR
41845: GO 41815
41847: POP
41848: POP
// if not tmp then
41849: LD_VAR 0 4
41853: NOT
41854: IFFALSE 41858
// exit ;
41856: GO 45195
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41858: LD_ADDR_VAR 0 5
41862: PUSH
41863: LD_EXP 100
41867: PUSH
41868: LD_VAR 0 1
41872: ARRAY
41873: PPUSH
41874: LD_INT 2
41876: PUSH
41877: LD_INT 25
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 25
41889: PUSH
41890: LD_INT 5
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 25
41899: PUSH
41900: LD_INT 8
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 25
41909: PUSH
41910: LD_INT 9
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: EMPTY
41918: LIST
41919: LIST
41920: LIST
41921: LIST
41922: LIST
41923: PPUSH
41924: CALL_OW 72
41928: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
41929: LD_ADDR_VAR 0 6
41933: PUSH
41934: LD_EXP 100
41938: PUSH
41939: LD_VAR 0 1
41943: ARRAY
41944: PPUSH
41945: LD_INT 25
41947: PUSH
41948: LD_INT 2
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PPUSH
41955: CALL_OW 72
41959: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
41960: LD_ADDR_VAR 0 7
41964: PUSH
41965: LD_EXP 100
41969: PUSH
41970: LD_VAR 0 1
41974: ARRAY
41975: PPUSH
41976: LD_INT 25
41978: PUSH
41979: LD_INT 3
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: PPUSH
41986: CALL_OW 72
41990: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
41991: LD_ADDR_VAR 0 8
41995: PUSH
41996: LD_EXP 100
42000: PUSH
42001: LD_VAR 0 1
42005: ARRAY
42006: PPUSH
42007: LD_INT 25
42009: PUSH
42010: LD_INT 4
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: PUSH
42017: LD_INT 24
42019: PUSH
42020: LD_INT 251
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: PPUSH
42031: CALL_OW 72
42035: ST_TO_ADDR
// if mc_is_defending [ base ] then
42036: LD_EXP 143
42040: PUSH
42041: LD_VAR 0 1
42045: ARRAY
42046: IFFALSE 42507
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
42048: LD_ADDR_EXP 142
42052: PUSH
42053: LD_EXP 142
42057: PPUSH
42058: LD_VAR 0 1
42062: PPUSH
42063: LD_INT 4
42065: PPUSH
42066: CALL_OW 1
42070: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42071: LD_ADDR_VAR 0 12
42075: PUSH
42076: LD_EXP 100
42080: PUSH
42081: LD_VAR 0 1
42085: ARRAY
42086: PPUSH
42087: LD_INT 2
42089: PUSH
42090: LD_INT 30
42092: PUSH
42093: LD_INT 4
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: LD_INT 30
42102: PUSH
42103: LD_INT 5
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: LIST
42114: PPUSH
42115: CALL_OW 72
42119: ST_TO_ADDR
// if not b then
42120: LD_VAR 0 12
42124: NOT
42125: IFFALSE 42129
// exit ;
42127: GO 45195
// p := [ ] ;
42129: LD_ADDR_VAR 0 11
42133: PUSH
42134: EMPTY
42135: ST_TO_ADDR
// if sci >= 2 then
42136: LD_VAR 0 8
42140: PUSH
42141: LD_INT 2
42143: GREATEREQUAL
42144: IFFALSE 42175
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
42146: LD_ADDR_VAR 0 8
42150: PUSH
42151: LD_VAR 0 8
42155: PUSH
42156: LD_INT 1
42158: ARRAY
42159: PUSH
42160: LD_VAR 0 8
42164: PUSH
42165: LD_INT 2
42167: ARRAY
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: ST_TO_ADDR
42173: GO 42236
// if sci = 1 then
42175: LD_VAR 0 8
42179: PUSH
42180: LD_INT 1
42182: EQUAL
42183: IFFALSE 42204
// sci := [ sci [ 1 ] ] else
42185: LD_ADDR_VAR 0 8
42189: PUSH
42190: LD_VAR 0 8
42194: PUSH
42195: LD_INT 1
42197: ARRAY
42198: PUSH
42199: EMPTY
42200: LIST
42201: ST_TO_ADDR
42202: GO 42236
// if sci = 0 then
42204: LD_VAR 0 8
42208: PUSH
42209: LD_INT 0
42211: EQUAL
42212: IFFALSE 42236
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
42214: LD_ADDR_VAR 0 11
42218: PUSH
42219: LD_VAR 0 4
42223: PPUSH
42224: LD_INT 4
42226: PPUSH
42227: CALL 103520 0 2
42231: PUSH
42232: LD_INT 1
42234: ARRAY
42235: ST_TO_ADDR
// if eng > 4 then
42236: LD_VAR 0 6
42240: PUSH
42241: LD_INT 4
42243: GREATER
42244: IFFALSE 42290
// for i = eng downto 4 do
42246: LD_ADDR_VAR 0 3
42250: PUSH
42251: DOUBLE
42252: LD_VAR 0 6
42256: INC
42257: ST_TO_ADDR
42258: LD_INT 4
42260: PUSH
42261: FOR_DOWNTO
42262: IFFALSE 42288
// eng := eng diff eng [ i ] ;
42264: LD_ADDR_VAR 0 6
42268: PUSH
42269: LD_VAR 0 6
42273: PUSH
42274: LD_VAR 0 6
42278: PUSH
42279: LD_VAR 0 3
42283: ARRAY
42284: DIFF
42285: ST_TO_ADDR
42286: GO 42261
42288: POP
42289: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
42290: LD_ADDR_VAR 0 4
42294: PUSH
42295: LD_VAR 0 4
42299: PUSH
42300: LD_VAR 0 5
42304: PUSH
42305: LD_VAR 0 6
42309: UNION
42310: PUSH
42311: LD_VAR 0 7
42315: UNION
42316: PUSH
42317: LD_VAR 0 8
42321: UNION
42322: DIFF
42323: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
42324: LD_ADDR_VAR 0 13
42328: PUSH
42329: LD_EXP 100
42333: PUSH
42334: LD_VAR 0 1
42338: ARRAY
42339: PPUSH
42340: LD_INT 2
42342: PUSH
42343: LD_INT 30
42345: PUSH
42346: LD_INT 32
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 30
42355: PUSH
42356: LD_INT 31
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: LIST
42367: PPUSH
42368: CALL_OW 72
42372: PUSH
42373: LD_EXP 100
42377: PUSH
42378: LD_VAR 0 1
42382: ARRAY
42383: PPUSH
42384: LD_INT 2
42386: PUSH
42387: LD_INT 30
42389: PUSH
42390: LD_INT 4
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 30
42399: PUSH
42400: LD_INT 5
42402: PUSH
42403: EMPTY
42404: LIST
42405: LIST
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: LIST
42411: PPUSH
42412: CALL_OW 72
42416: PUSH
42417: LD_INT 6
42419: MUL
42420: PLUS
42421: ST_TO_ADDR
// if bcount < tmp then
42422: LD_VAR 0 13
42426: PUSH
42427: LD_VAR 0 4
42431: LESS
42432: IFFALSE 42478
// for i = tmp downto bcount do
42434: LD_ADDR_VAR 0 3
42438: PUSH
42439: DOUBLE
42440: LD_VAR 0 4
42444: INC
42445: ST_TO_ADDR
42446: LD_VAR 0 13
42450: PUSH
42451: FOR_DOWNTO
42452: IFFALSE 42476
// tmp := Delete ( tmp , tmp ) ;
42454: LD_ADDR_VAR 0 4
42458: PUSH
42459: LD_VAR 0 4
42463: PPUSH
42464: LD_VAR 0 4
42468: PPUSH
42469: CALL_OW 3
42473: ST_TO_ADDR
42474: GO 42451
42476: POP
42477: POP
// result := [ tmp , 0 , 0 , p ] ;
42478: LD_ADDR_VAR 0 2
42482: PUSH
42483: LD_VAR 0 4
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: LD_INT 0
42493: PUSH
42494: LD_VAR 0 11
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: ST_TO_ADDR
// exit ;
42505: GO 45195
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42507: LD_EXP 100
42511: PUSH
42512: LD_VAR 0 1
42516: ARRAY
42517: PPUSH
42518: LD_INT 2
42520: PUSH
42521: LD_INT 30
42523: PUSH
42524: LD_INT 6
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: LD_INT 30
42533: PUSH
42534: LD_INT 7
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 30
42543: PUSH
42544: LD_INT 8
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: LIST
42555: LIST
42556: PPUSH
42557: CALL_OW 72
42561: NOT
42562: PUSH
42563: LD_EXP 100
42567: PUSH
42568: LD_VAR 0 1
42572: ARRAY
42573: PPUSH
42574: LD_INT 30
42576: PUSH
42577: LD_INT 3
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PPUSH
42584: CALL_OW 72
42588: NOT
42589: AND
42590: IFFALSE 42662
// begin if eng = tmp then
42592: LD_VAR 0 6
42596: PUSH
42597: LD_VAR 0 4
42601: EQUAL
42602: IFFALSE 42606
// exit ;
42604: GO 45195
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
42606: LD_ADDR_EXP 142
42610: PUSH
42611: LD_EXP 142
42615: PPUSH
42616: LD_VAR 0 1
42620: PPUSH
42621: LD_INT 1
42623: PPUSH
42624: CALL_OW 1
42628: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
42629: LD_ADDR_VAR 0 2
42633: PUSH
42634: LD_INT 0
42636: PUSH
42637: LD_VAR 0 4
42641: PUSH
42642: LD_VAR 0 6
42646: DIFF
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: LD_INT 0
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: LIST
42658: LIST
42659: ST_TO_ADDR
// exit ;
42660: GO 45195
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42662: LD_EXP 127
42666: PUSH
42667: LD_EXP 126
42671: PUSH
42672: LD_VAR 0 1
42676: ARRAY
42677: ARRAY
42678: PUSH
42679: LD_EXP 100
42683: PUSH
42684: LD_VAR 0 1
42688: ARRAY
42689: PPUSH
42690: LD_INT 2
42692: PUSH
42693: LD_INT 30
42695: PUSH
42696: LD_INT 6
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: LD_INT 30
42705: PUSH
42706: LD_INT 7
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 30
42715: PUSH
42716: LD_INT 8
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: EMPTY
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: PPUSH
42729: CALL_OW 72
42733: AND
42734: PUSH
42735: LD_EXP 100
42739: PUSH
42740: LD_VAR 0 1
42744: ARRAY
42745: PPUSH
42746: LD_INT 30
42748: PUSH
42749: LD_INT 3
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PPUSH
42756: CALL_OW 72
42760: NOT
42761: AND
42762: IFFALSE 42976
// begin if sci >= 6 then
42764: LD_VAR 0 8
42768: PUSH
42769: LD_INT 6
42771: GREATEREQUAL
42772: IFFALSE 42776
// exit ;
42774: GO 45195
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
42776: LD_ADDR_EXP 142
42780: PUSH
42781: LD_EXP 142
42785: PPUSH
42786: LD_VAR 0 1
42790: PPUSH
42791: LD_INT 2
42793: PPUSH
42794: CALL_OW 1
42798: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
42799: LD_ADDR_VAR 0 9
42803: PUSH
42804: LD_VAR 0 4
42808: PUSH
42809: LD_VAR 0 8
42813: DIFF
42814: PPUSH
42815: LD_INT 4
42817: PPUSH
42818: CALL 103520 0 2
42822: ST_TO_ADDR
// p := [ ] ;
42823: LD_ADDR_VAR 0 11
42827: PUSH
42828: EMPTY
42829: ST_TO_ADDR
// if sci < 6 and sort > 6 then
42830: LD_VAR 0 8
42834: PUSH
42835: LD_INT 6
42837: LESS
42838: PUSH
42839: LD_VAR 0 9
42843: PUSH
42844: LD_INT 6
42846: GREATER
42847: AND
42848: IFFALSE 42929
// begin for i = 1 to 6 - sci do
42850: LD_ADDR_VAR 0 3
42854: PUSH
42855: DOUBLE
42856: LD_INT 1
42858: DEC
42859: ST_TO_ADDR
42860: LD_INT 6
42862: PUSH
42863: LD_VAR 0 8
42867: MINUS
42868: PUSH
42869: FOR_TO
42870: IFFALSE 42925
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
42872: LD_ADDR_VAR 0 11
42876: PUSH
42877: LD_VAR 0 11
42881: PPUSH
42882: LD_VAR 0 11
42886: PUSH
42887: LD_INT 1
42889: PLUS
42890: PPUSH
42891: LD_VAR 0 9
42895: PUSH
42896: LD_INT 1
42898: ARRAY
42899: PPUSH
42900: CALL_OW 2
42904: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
42905: LD_ADDR_VAR 0 9
42909: PUSH
42910: LD_VAR 0 9
42914: PPUSH
42915: LD_INT 1
42917: PPUSH
42918: CALL_OW 3
42922: ST_TO_ADDR
// end ;
42923: GO 42869
42925: POP
42926: POP
// end else
42927: GO 42949
// if sort then
42929: LD_VAR 0 9
42933: IFFALSE 42949
// p := sort [ 1 ] ;
42935: LD_ADDR_VAR 0 11
42939: PUSH
42940: LD_VAR 0 9
42944: PUSH
42945: LD_INT 1
42947: ARRAY
42948: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
42949: LD_ADDR_VAR 0 2
42953: PUSH
42954: LD_INT 0
42956: PUSH
42957: LD_INT 0
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: LD_VAR 0 11
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: LIST
42972: LIST
42973: ST_TO_ADDR
// exit ;
42974: GO 45195
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42976: LD_EXP 127
42980: PUSH
42981: LD_EXP 126
42985: PUSH
42986: LD_VAR 0 1
42990: ARRAY
42991: ARRAY
42992: PUSH
42993: LD_EXP 100
42997: PUSH
42998: LD_VAR 0 1
43002: ARRAY
43003: PPUSH
43004: LD_INT 2
43006: PUSH
43007: LD_INT 30
43009: PUSH
43010: LD_INT 6
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 30
43019: PUSH
43020: LD_INT 7
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 30
43029: PUSH
43030: LD_INT 8
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: PPUSH
43043: CALL_OW 72
43047: AND
43048: PUSH
43049: LD_EXP 100
43053: PUSH
43054: LD_VAR 0 1
43058: ARRAY
43059: PPUSH
43060: LD_INT 30
43062: PUSH
43063: LD_INT 3
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PPUSH
43070: CALL_OW 72
43074: AND
43075: IFFALSE 43809
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
43077: LD_ADDR_EXP 142
43081: PUSH
43082: LD_EXP 142
43086: PPUSH
43087: LD_VAR 0 1
43091: PPUSH
43092: LD_INT 3
43094: PPUSH
43095: CALL_OW 1
43099: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43100: LD_ADDR_VAR 0 2
43104: PUSH
43105: LD_INT 0
43107: PUSH
43108: LD_INT 0
43110: PUSH
43111: LD_INT 0
43113: PUSH
43114: LD_INT 0
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: LIST
43121: LIST
43122: ST_TO_ADDR
// if not eng then
43123: LD_VAR 0 6
43127: NOT
43128: IFFALSE 43191
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
43130: LD_ADDR_VAR 0 11
43134: PUSH
43135: LD_VAR 0 4
43139: PPUSH
43140: LD_INT 2
43142: PPUSH
43143: CALL 103520 0 2
43147: PUSH
43148: LD_INT 1
43150: ARRAY
43151: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
43152: LD_ADDR_VAR 0 2
43156: PUSH
43157: LD_VAR 0 2
43161: PPUSH
43162: LD_INT 2
43164: PPUSH
43165: LD_VAR 0 11
43169: PPUSH
43170: CALL_OW 1
43174: ST_TO_ADDR
// tmp := tmp diff p ;
43175: LD_ADDR_VAR 0 4
43179: PUSH
43180: LD_VAR 0 4
43184: PUSH
43185: LD_VAR 0 11
43189: DIFF
43190: ST_TO_ADDR
// end ; if tmp and sci < 6 then
43191: LD_VAR 0 4
43195: PUSH
43196: LD_VAR 0 8
43200: PUSH
43201: LD_INT 6
43203: LESS
43204: AND
43205: IFFALSE 43393
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
43207: LD_ADDR_VAR 0 9
43211: PUSH
43212: LD_VAR 0 4
43216: PUSH
43217: LD_VAR 0 8
43221: PUSH
43222: LD_VAR 0 7
43226: UNION
43227: DIFF
43228: PPUSH
43229: LD_INT 4
43231: PPUSH
43232: CALL 103520 0 2
43236: ST_TO_ADDR
// p := [ ] ;
43237: LD_ADDR_VAR 0 11
43241: PUSH
43242: EMPTY
43243: ST_TO_ADDR
// if sort then
43244: LD_VAR 0 9
43248: IFFALSE 43364
// for i = 1 to 6 - sci do
43250: LD_ADDR_VAR 0 3
43254: PUSH
43255: DOUBLE
43256: LD_INT 1
43258: DEC
43259: ST_TO_ADDR
43260: LD_INT 6
43262: PUSH
43263: LD_VAR 0 8
43267: MINUS
43268: PUSH
43269: FOR_TO
43270: IFFALSE 43362
// begin if i = sort then
43272: LD_VAR 0 3
43276: PUSH
43277: LD_VAR 0 9
43281: EQUAL
43282: IFFALSE 43286
// break ;
43284: GO 43362
// if GetClass ( i ) = 4 then
43286: LD_VAR 0 3
43290: PPUSH
43291: CALL_OW 257
43295: PUSH
43296: LD_INT 4
43298: EQUAL
43299: IFFALSE 43303
// continue ;
43301: GO 43269
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43303: LD_ADDR_VAR 0 11
43307: PUSH
43308: LD_VAR 0 11
43312: PPUSH
43313: LD_VAR 0 11
43317: PUSH
43318: LD_INT 1
43320: PLUS
43321: PPUSH
43322: LD_VAR 0 9
43326: PUSH
43327: LD_VAR 0 3
43331: ARRAY
43332: PPUSH
43333: CALL_OW 2
43337: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43338: LD_ADDR_VAR 0 4
43342: PUSH
43343: LD_VAR 0 4
43347: PUSH
43348: LD_VAR 0 9
43352: PUSH
43353: LD_VAR 0 3
43357: ARRAY
43358: DIFF
43359: ST_TO_ADDR
// end ;
43360: GO 43269
43362: POP
43363: POP
// if p then
43364: LD_VAR 0 11
43368: IFFALSE 43393
// result := Replace ( result , 4 , p ) ;
43370: LD_ADDR_VAR 0 2
43374: PUSH
43375: LD_VAR 0 2
43379: PPUSH
43380: LD_INT 4
43382: PPUSH
43383: LD_VAR 0 11
43387: PPUSH
43388: CALL_OW 1
43392: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43393: LD_VAR 0 4
43397: PUSH
43398: LD_VAR 0 7
43402: PUSH
43403: LD_INT 6
43405: LESS
43406: AND
43407: IFFALSE 43595
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43409: LD_ADDR_VAR 0 9
43413: PUSH
43414: LD_VAR 0 4
43418: PUSH
43419: LD_VAR 0 8
43423: PUSH
43424: LD_VAR 0 7
43428: UNION
43429: DIFF
43430: PPUSH
43431: LD_INT 3
43433: PPUSH
43434: CALL 103520 0 2
43438: ST_TO_ADDR
// p := [ ] ;
43439: LD_ADDR_VAR 0 11
43443: PUSH
43444: EMPTY
43445: ST_TO_ADDR
// if sort then
43446: LD_VAR 0 9
43450: IFFALSE 43566
// for i = 1 to 6 - mech do
43452: LD_ADDR_VAR 0 3
43456: PUSH
43457: DOUBLE
43458: LD_INT 1
43460: DEC
43461: ST_TO_ADDR
43462: LD_INT 6
43464: PUSH
43465: LD_VAR 0 7
43469: MINUS
43470: PUSH
43471: FOR_TO
43472: IFFALSE 43564
// begin if i = sort then
43474: LD_VAR 0 3
43478: PUSH
43479: LD_VAR 0 9
43483: EQUAL
43484: IFFALSE 43488
// break ;
43486: GO 43564
// if GetClass ( i ) = 3 then
43488: LD_VAR 0 3
43492: PPUSH
43493: CALL_OW 257
43497: PUSH
43498: LD_INT 3
43500: EQUAL
43501: IFFALSE 43505
// continue ;
43503: GO 43471
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43505: LD_ADDR_VAR 0 11
43509: PUSH
43510: LD_VAR 0 11
43514: PPUSH
43515: LD_VAR 0 11
43519: PUSH
43520: LD_INT 1
43522: PLUS
43523: PPUSH
43524: LD_VAR 0 9
43528: PUSH
43529: LD_VAR 0 3
43533: ARRAY
43534: PPUSH
43535: CALL_OW 2
43539: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43540: LD_ADDR_VAR 0 4
43544: PUSH
43545: LD_VAR 0 4
43549: PUSH
43550: LD_VAR 0 9
43554: PUSH
43555: LD_VAR 0 3
43559: ARRAY
43560: DIFF
43561: ST_TO_ADDR
// end ;
43562: GO 43471
43564: POP
43565: POP
// if p then
43566: LD_VAR 0 11
43570: IFFALSE 43595
// result := Replace ( result , 3 , p ) ;
43572: LD_ADDR_VAR 0 2
43576: PUSH
43577: LD_VAR 0 2
43581: PPUSH
43582: LD_INT 3
43584: PPUSH
43585: LD_VAR 0 11
43589: PPUSH
43590: CALL_OW 1
43594: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
43595: LD_VAR 0 4
43599: PUSH
43600: LD_INT 6
43602: GREATER
43603: PUSH
43604: LD_VAR 0 6
43608: PUSH
43609: LD_INT 6
43611: LESS
43612: AND
43613: IFFALSE 43807
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43615: LD_ADDR_VAR 0 9
43619: PUSH
43620: LD_VAR 0 4
43624: PUSH
43625: LD_VAR 0 8
43629: PUSH
43630: LD_VAR 0 7
43634: UNION
43635: PUSH
43636: LD_VAR 0 6
43640: UNION
43641: DIFF
43642: PPUSH
43643: LD_INT 2
43645: PPUSH
43646: CALL 103520 0 2
43650: ST_TO_ADDR
// p := [ ] ;
43651: LD_ADDR_VAR 0 11
43655: PUSH
43656: EMPTY
43657: ST_TO_ADDR
// if sort then
43658: LD_VAR 0 9
43662: IFFALSE 43778
// for i = 1 to 6 - eng do
43664: LD_ADDR_VAR 0 3
43668: PUSH
43669: DOUBLE
43670: LD_INT 1
43672: DEC
43673: ST_TO_ADDR
43674: LD_INT 6
43676: PUSH
43677: LD_VAR 0 6
43681: MINUS
43682: PUSH
43683: FOR_TO
43684: IFFALSE 43776
// begin if i = sort then
43686: LD_VAR 0 3
43690: PUSH
43691: LD_VAR 0 9
43695: EQUAL
43696: IFFALSE 43700
// break ;
43698: GO 43776
// if GetClass ( i ) = 2 then
43700: LD_VAR 0 3
43704: PPUSH
43705: CALL_OW 257
43709: PUSH
43710: LD_INT 2
43712: EQUAL
43713: IFFALSE 43717
// continue ;
43715: GO 43683
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43717: LD_ADDR_VAR 0 11
43721: PUSH
43722: LD_VAR 0 11
43726: PPUSH
43727: LD_VAR 0 11
43731: PUSH
43732: LD_INT 1
43734: PLUS
43735: PPUSH
43736: LD_VAR 0 9
43740: PUSH
43741: LD_VAR 0 3
43745: ARRAY
43746: PPUSH
43747: CALL_OW 2
43751: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43752: LD_ADDR_VAR 0 4
43756: PUSH
43757: LD_VAR 0 4
43761: PUSH
43762: LD_VAR 0 9
43766: PUSH
43767: LD_VAR 0 3
43771: ARRAY
43772: DIFF
43773: ST_TO_ADDR
// end ;
43774: GO 43683
43776: POP
43777: POP
// if p then
43778: LD_VAR 0 11
43782: IFFALSE 43807
// result := Replace ( result , 2 , p ) ;
43784: LD_ADDR_VAR 0 2
43788: PUSH
43789: LD_VAR 0 2
43793: PPUSH
43794: LD_INT 2
43796: PPUSH
43797: LD_VAR 0 11
43801: PPUSH
43802: CALL_OW 1
43806: ST_TO_ADDR
// end ; exit ;
43807: GO 45195
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
43809: LD_EXP 127
43813: PUSH
43814: LD_EXP 126
43818: PUSH
43819: LD_VAR 0 1
43823: ARRAY
43824: ARRAY
43825: NOT
43826: PUSH
43827: LD_EXP 100
43831: PUSH
43832: LD_VAR 0 1
43836: ARRAY
43837: PPUSH
43838: LD_INT 30
43840: PUSH
43841: LD_INT 3
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PPUSH
43848: CALL_OW 72
43852: AND
43853: PUSH
43854: LD_EXP 105
43858: PUSH
43859: LD_VAR 0 1
43863: ARRAY
43864: AND
43865: IFFALSE 44473
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
43867: LD_ADDR_EXP 142
43871: PUSH
43872: LD_EXP 142
43876: PPUSH
43877: LD_VAR 0 1
43881: PPUSH
43882: LD_INT 5
43884: PPUSH
43885: CALL_OW 1
43889: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43890: LD_ADDR_VAR 0 2
43894: PUSH
43895: LD_INT 0
43897: PUSH
43898: LD_INT 0
43900: PUSH
43901: LD_INT 0
43903: PUSH
43904: LD_INT 0
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: ST_TO_ADDR
// if sci > 1 then
43913: LD_VAR 0 8
43917: PUSH
43918: LD_INT 1
43920: GREATER
43921: IFFALSE 43949
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
43923: LD_ADDR_VAR 0 4
43927: PUSH
43928: LD_VAR 0 4
43932: PUSH
43933: LD_VAR 0 8
43937: PUSH
43938: LD_VAR 0 8
43942: PUSH
43943: LD_INT 1
43945: ARRAY
43946: DIFF
43947: DIFF
43948: ST_TO_ADDR
// if tmp and not sci then
43949: LD_VAR 0 4
43953: PUSH
43954: LD_VAR 0 8
43958: NOT
43959: AND
43960: IFFALSE 44029
// begin sort := SortBySkill ( tmp , 4 ) ;
43962: LD_ADDR_VAR 0 9
43966: PUSH
43967: LD_VAR 0 4
43971: PPUSH
43972: LD_INT 4
43974: PPUSH
43975: CALL 103520 0 2
43979: ST_TO_ADDR
// if sort then
43980: LD_VAR 0 9
43984: IFFALSE 44000
// p := sort [ 1 ] ;
43986: LD_ADDR_VAR 0 11
43990: PUSH
43991: LD_VAR 0 9
43995: PUSH
43996: LD_INT 1
43998: ARRAY
43999: ST_TO_ADDR
// if p then
44000: LD_VAR 0 11
44004: IFFALSE 44029
// result := Replace ( result , 4 , p ) ;
44006: LD_ADDR_VAR 0 2
44010: PUSH
44011: LD_VAR 0 2
44015: PPUSH
44016: LD_INT 4
44018: PPUSH
44019: LD_VAR 0 11
44023: PPUSH
44024: CALL_OW 1
44028: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44029: LD_ADDR_VAR 0 4
44033: PUSH
44034: LD_VAR 0 4
44038: PUSH
44039: LD_VAR 0 7
44043: DIFF
44044: ST_TO_ADDR
// if tmp and mech < 6 then
44045: LD_VAR 0 4
44049: PUSH
44050: LD_VAR 0 7
44054: PUSH
44055: LD_INT 6
44057: LESS
44058: AND
44059: IFFALSE 44247
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
44061: LD_ADDR_VAR 0 9
44065: PUSH
44066: LD_VAR 0 4
44070: PUSH
44071: LD_VAR 0 8
44075: PUSH
44076: LD_VAR 0 7
44080: UNION
44081: DIFF
44082: PPUSH
44083: LD_INT 3
44085: PPUSH
44086: CALL 103520 0 2
44090: ST_TO_ADDR
// p := [ ] ;
44091: LD_ADDR_VAR 0 11
44095: PUSH
44096: EMPTY
44097: ST_TO_ADDR
// if sort then
44098: LD_VAR 0 9
44102: IFFALSE 44218
// for i = 1 to 6 - mech do
44104: LD_ADDR_VAR 0 3
44108: PUSH
44109: DOUBLE
44110: LD_INT 1
44112: DEC
44113: ST_TO_ADDR
44114: LD_INT 6
44116: PUSH
44117: LD_VAR 0 7
44121: MINUS
44122: PUSH
44123: FOR_TO
44124: IFFALSE 44216
// begin if i = sort then
44126: LD_VAR 0 3
44130: PUSH
44131: LD_VAR 0 9
44135: EQUAL
44136: IFFALSE 44140
// break ;
44138: GO 44216
// if GetClass ( i ) = 3 then
44140: LD_VAR 0 3
44144: PPUSH
44145: CALL_OW 257
44149: PUSH
44150: LD_INT 3
44152: EQUAL
44153: IFFALSE 44157
// continue ;
44155: GO 44123
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44157: LD_ADDR_VAR 0 11
44161: PUSH
44162: LD_VAR 0 11
44166: PPUSH
44167: LD_VAR 0 11
44171: PUSH
44172: LD_INT 1
44174: PLUS
44175: PPUSH
44176: LD_VAR 0 9
44180: PUSH
44181: LD_VAR 0 3
44185: ARRAY
44186: PPUSH
44187: CALL_OW 2
44191: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44192: LD_ADDR_VAR 0 4
44196: PUSH
44197: LD_VAR 0 4
44201: PUSH
44202: LD_VAR 0 9
44206: PUSH
44207: LD_VAR 0 3
44211: ARRAY
44212: DIFF
44213: ST_TO_ADDR
// end ;
44214: GO 44123
44216: POP
44217: POP
// if p then
44218: LD_VAR 0 11
44222: IFFALSE 44247
// result := Replace ( result , 3 , p ) ;
44224: LD_ADDR_VAR 0 2
44228: PUSH
44229: LD_VAR 0 2
44233: PPUSH
44234: LD_INT 3
44236: PPUSH
44237: LD_VAR 0 11
44241: PPUSH
44242: CALL_OW 1
44246: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44247: LD_ADDR_VAR 0 4
44251: PUSH
44252: LD_VAR 0 4
44256: PUSH
44257: LD_VAR 0 6
44261: DIFF
44262: ST_TO_ADDR
// if tmp and eng < 6 then
44263: LD_VAR 0 4
44267: PUSH
44268: LD_VAR 0 6
44272: PUSH
44273: LD_INT 6
44275: LESS
44276: AND
44277: IFFALSE 44471
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44279: LD_ADDR_VAR 0 9
44283: PUSH
44284: LD_VAR 0 4
44288: PUSH
44289: LD_VAR 0 8
44293: PUSH
44294: LD_VAR 0 7
44298: UNION
44299: PUSH
44300: LD_VAR 0 6
44304: UNION
44305: DIFF
44306: PPUSH
44307: LD_INT 2
44309: PPUSH
44310: CALL 103520 0 2
44314: ST_TO_ADDR
// p := [ ] ;
44315: LD_ADDR_VAR 0 11
44319: PUSH
44320: EMPTY
44321: ST_TO_ADDR
// if sort then
44322: LD_VAR 0 9
44326: IFFALSE 44442
// for i = 1 to 6 - eng do
44328: LD_ADDR_VAR 0 3
44332: PUSH
44333: DOUBLE
44334: LD_INT 1
44336: DEC
44337: ST_TO_ADDR
44338: LD_INT 6
44340: PUSH
44341: LD_VAR 0 6
44345: MINUS
44346: PUSH
44347: FOR_TO
44348: IFFALSE 44440
// begin if i = sort then
44350: LD_VAR 0 3
44354: PUSH
44355: LD_VAR 0 9
44359: EQUAL
44360: IFFALSE 44364
// break ;
44362: GO 44440
// if GetClass ( i ) = 2 then
44364: LD_VAR 0 3
44368: PPUSH
44369: CALL_OW 257
44373: PUSH
44374: LD_INT 2
44376: EQUAL
44377: IFFALSE 44381
// continue ;
44379: GO 44347
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44381: LD_ADDR_VAR 0 11
44385: PUSH
44386: LD_VAR 0 11
44390: PPUSH
44391: LD_VAR 0 11
44395: PUSH
44396: LD_INT 1
44398: PLUS
44399: PPUSH
44400: LD_VAR 0 9
44404: PUSH
44405: LD_VAR 0 3
44409: ARRAY
44410: PPUSH
44411: CALL_OW 2
44415: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44416: LD_ADDR_VAR 0 4
44420: PUSH
44421: LD_VAR 0 4
44425: PUSH
44426: LD_VAR 0 9
44430: PUSH
44431: LD_VAR 0 3
44435: ARRAY
44436: DIFF
44437: ST_TO_ADDR
// end ;
44438: GO 44347
44440: POP
44441: POP
// if p then
44442: LD_VAR 0 11
44446: IFFALSE 44471
// result := Replace ( result , 2 , p ) ;
44448: LD_ADDR_VAR 0 2
44452: PUSH
44453: LD_VAR 0 2
44457: PPUSH
44458: LD_INT 2
44460: PPUSH
44461: LD_VAR 0 11
44465: PPUSH
44466: CALL_OW 1
44470: ST_TO_ADDR
// end ; exit ;
44471: GO 45195
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44473: LD_EXP 127
44477: PUSH
44478: LD_EXP 126
44482: PUSH
44483: LD_VAR 0 1
44487: ARRAY
44488: ARRAY
44489: NOT
44490: PUSH
44491: LD_EXP 100
44495: PUSH
44496: LD_VAR 0 1
44500: ARRAY
44501: PPUSH
44502: LD_INT 30
44504: PUSH
44505: LD_INT 3
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PPUSH
44512: CALL_OW 72
44516: AND
44517: PUSH
44518: LD_EXP 105
44522: PUSH
44523: LD_VAR 0 1
44527: ARRAY
44528: NOT
44529: AND
44530: IFFALSE 45195
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44532: LD_ADDR_EXP 142
44536: PUSH
44537: LD_EXP 142
44541: PPUSH
44542: LD_VAR 0 1
44546: PPUSH
44547: LD_INT 6
44549: PPUSH
44550: CALL_OW 1
44554: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44555: LD_ADDR_VAR 0 2
44559: PUSH
44560: LD_INT 0
44562: PUSH
44563: LD_INT 0
44565: PUSH
44566: LD_INT 0
44568: PUSH
44569: LD_INT 0
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: LIST
44576: LIST
44577: ST_TO_ADDR
// if sci >= 1 then
44578: LD_VAR 0 8
44582: PUSH
44583: LD_INT 1
44585: GREATEREQUAL
44586: IFFALSE 44608
// tmp := tmp diff sci [ 1 ] ;
44588: LD_ADDR_VAR 0 4
44592: PUSH
44593: LD_VAR 0 4
44597: PUSH
44598: LD_VAR 0 8
44602: PUSH
44603: LD_INT 1
44605: ARRAY
44606: DIFF
44607: ST_TO_ADDR
// if tmp and not sci then
44608: LD_VAR 0 4
44612: PUSH
44613: LD_VAR 0 8
44617: NOT
44618: AND
44619: IFFALSE 44688
// begin sort := SortBySkill ( tmp , 4 ) ;
44621: LD_ADDR_VAR 0 9
44625: PUSH
44626: LD_VAR 0 4
44630: PPUSH
44631: LD_INT 4
44633: PPUSH
44634: CALL 103520 0 2
44638: ST_TO_ADDR
// if sort then
44639: LD_VAR 0 9
44643: IFFALSE 44659
// p := sort [ 1 ] ;
44645: LD_ADDR_VAR 0 11
44649: PUSH
44650: LD_VAR 0 9
44654: PUSH
44655: LD_INT 1
44657: ARRAY
44658: ST_TO_ADDR
// if p then
44659: LD_VAR 0 11
44663: IFFALSE 44688
// result := Replace ( result , 4 , p ) ;
44665: LD_ADDR_VAR 0 2
44669: PUSH
44670: LD_VAR 0 2
44674: PPUSH
44675: LD_INT 4
44677: PPUSH
44678: LD_VAR 0 11
44682: PPUSH
44683: CALL_OW 1
44687: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44688: LD_ADDR_VAR 0 4
44692: PUSH
44693: LD_VAR 0 4
44697: PUSH
44698: LD_VAR 0 7
44702: DIFF
44703: ST_TO_ADDR
// if tmp and mech < 6 then
44704: LD_VAR 0 4
44708: PUSH
44709: LD_VAR 0 7
44713: PUSH
44714: LD_INT 6
44716: LESS
44717: AND
44718: IFFALSE 44900
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
44720: LD_ADDR_VAR 0 9
44724: PUSH
44725: LD_VAR 0 4
44729: PUSH
44730: LD_VAR 0 7
44734: DIFF
44735: PPUSH
44736: LD_INT 3
44738: PPUSH
44739: CALL 103520 0 2
44743: ST_TO_ADDR
// p := [ ] ;
44744: LD_ADDR_VAR 0 11
44748: PUSH
44749: EMPTY
44750: ST_TO_ADDR
// if sort then
44751: LD_VAR 0 9
44755: IFFALSE 44871
// for i = 1 to 6 - mech do
44757: LD_ADDR_VAR 0 3
44761: PUSH
44762: DOUBLE
44763: LD_INT 1
44765: DEC
44766: ST_TO_ADDR
44767: LD_INT 6
44769: PUSH
44770: LD_VAR 0 7
44774: MINUS
44775: PUSH
44776: FOR_TO
44777: IFFALSE 44869
// begin if i = sort then
44779: LD_VAR 0 3
44783: PUSH
44784: LD_VAR 0 9
44788: EQUAL
44789: IFFALSE 44793
// break ;
44791: GO 44869
// if GetClass ( i ) = 3 then
44793: LD_VAR 0 3
44797: PPUSH
44798: CALL_OW 257
44802: PUSH
44803: LD_INT 3
44805: EQUAL
44806: IFFALSE 44810
// continue ;
44808: GO 44776
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44810: LD_ADDR_VAR 0 11
44814: PUSH
44815: LD_VAR 0 11
44819: PPUSH
44820: LD_VAR 0 11
44824: PUSH
44825: LD_INT 1
44827: PLUS
44828: PPUSH
44829: LD_VAR 0 9
44833: PUSH
44834: LD_VAR 0 3
44838: ARRAY
44839: PPUSH
44840: CALL_OW 2
44844: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44845: LD_ADDR_VAR 0 4
44849: PUSH
44850: LD_VAR 0 4
44854: PUSH
44855: LD_VAR 0 9
44859: PUSH
44860: LD_VAR 0 3
44864: ARRAY
44865: DIFF
44866: ST_TO_ADDR
// end ;
44867: GO 44776
44869: POP
44870: POP
// if p then
44871: LD_VAR 0 11
44875: IFFALSE 44900
// result := Replace ( result , 3 , p ) ;
44877: LD_ADDR_VAR 0 2
44881: PUSH
44882: LD_VAR 0 2
44886: PPUSH
44887: LD_INT 3
44889: PPUSH
44890: LD_VAR 0 11
44894: PPUSH
44895: CALL_OW 1
44899: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44900: LD_ADDR_VAR 0 4
44904: PUSH
44905: LD_VAR 0 4
44909: PUSH
44910: LD_VAR 0 6
44914: DIFF
44915: ST_TO_ADDR
// if tmp and eng < 4 then
44916: LD_VAR 0 4
44920: PUSH
44921: LD_VAR 0 6
44925: PUSH
44926: LD_INT 4
44928: LESS
44929: AND
44930: IFFALSE 45120
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
44932: LD_ADDR_VAR 0 9
44936: PUSH
44937: LD_VAR 0 4
44941: PUSH
44942: LD_VAR 0 7
44946: PUSH
44947: LD_VAR 0 6
44951: UNION
44952: DIFF
44953: PPUSH
44954: LD_INT 2
44956: PPUSH
44957: CALL 103520 0 2
44961: ST_TO_ADDR
// p := [ ] ;
44962: LD_ADDR_VAR 0 11
44966: PUSH
44967: EMPTY
44968: ST_TO_ADDR
// if sort then
44969: LD_VAR 0 9
44973: IFFALSE 45089
// for i = 1 to 4 - eng do
44975: LD_ADDR_VAR 0 3
44979: PUSH
44980: DOUBLE
44981: LD_INT 1
44983: DEC
44984: ST_TO_ADDR
44985: LD_INT 4
44987: PUSH
44988: LD_VAR 0 6
44992: MINUS
44993: PUSH
44994: FOR_TO
44995: IFFALSE 45087
// begin if i = sort then
44997: LD_VAR 0 3
45001: PUSH
45002: LD_VAR 0 9
45006: EQUAL
45007: IFFALSE 45011
// break ;
45009: GO 45087
// if GetClass ( i ) = 2 then
45011: LD_VAR 0 3
45015: PPUSH
45016: CALL_OW 257
45020: PUSH
45021: LD_INT 2
45023: EQUAL
45024: IFFALSE 45028
// continue ;
45026: GO 44994
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45028: LD_ADDR_VAR 0 11
45032: PUSH
45033: LD_VAR 0 11
45037: PPUSH
45038: LD_VAR 0 11
45042: PUSH
45043: LD_INT 1
45045: PLUS
45046: PPUSH
45047: LD_VAR 0 9
45051: PUSH
45052: LD_VAR 0 3
45056: ARRAY
45057: PPUSH
45058: CALL_OW 2
45062: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45063: LD_ADDR_VAR 0 4
45067: PUSH
45068: LD_VAR 0 4
45072: PUSH
45073: LD_VAR 0 9
45077: PUSH
45078: LD_VAR 0 3
45082: ARRAY
45083: DIFF
45084: ST_TO_ADDR
// end ;
45085: GO 44994
45087: POP
45088: POP
// if p then
45089: LD_VAR 0 11
45093: IFFALSE 45118
// result := Replace ( result , 2 , p ) ;
45095: LD_ADDR_VAR 0 2
45099: PUSH
45100: LD_VAR 0 2
45104: PPUSH
45105: LD_INT 2
45107: PPUSH
45108: LD_VAR 0 11
45112: PPUSH
45113: CALL_OW 1
45117: ST_TO_ADDR
// end else
45118: GO 45164
// for i = eng downto 5 do
45120: LD_ADDR_VAR 0 3
45124: PUSH
45125: DOUBLE
45126: LD_VAR 0 6
45130: INC
45131: ST_TO_ADDR
45132: LD_INT 5
45134: PUSH
45135: FOR_DOWNTO
45136: IFFALSE 45162
// tmp := tmp union eng [ i ] ;
45138: LD_ADDR_VAR 0 4
45142: PUSH
45143: LD_VAR 0 4
45147: PUSH
45148: LD_VAR 0 6
45152: PUSH
45153: LD_VAR 0 3
45157: ARRAY
45158: UNION
45159: ST_TO_ADDR
45160: GO 45135
45162: POP
45163: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
45164: LD_ADDR_VAR 0 2
45168: PUSH
45169: LD_VAR 0 2
45173: PPUSH
45174: LD_INT 1
45176: PPUSH
45177: LD_VAR 0 4
45181: PUSH
45182: LD_VAR 0 5
45186: DIFF
45187: PPUSH
45188: CALL_OW 1
45192: ST_TO_ADDR
// exit ;
45193: GO 45195
// end ; end ;
45195: LD_VAR 0 2
45199: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
45200: LD_INT 0
45202: PPUSH
45203: PPUSH
45204: PPUSH
// if not mc_bases then
45205: LD_EXP 100
45209: NOT
45210: IFFALSE 45214
// exit ;
45212: GO 45356
// for i = 1 to mc_bases do
45214: LD_ADDR_VAR 0 2
45218: PUSH
45219: DOUBLE
45220: LD_INT 1
45222: DEC
45223: ST_TO_ADDR
45224: LD_EXP 100
45228: PUSH
45229: FOR_TO
45230: IFFALSE 45347
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
45232: LD_ADDR_VAR 0 3
45236: PUSH
45237: LD_EXP 100
45241: PUSH
45242: LD_VAR 0 2
45246: ARRAY
45247: PPUSH
45248: LD_INT 21
45250: PUSH
45251: LD_INT 3
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PUSH
45258: LD_INT 3
45260: PUSH
45261: LD_INT 2
45263: PUSH
45264: LD_INT 30
45266: PUSH
45267: LD_INT 29
45269: PUSH
45270: EMPTY
45271: LIST
45272: LIST
45273: PUSH
45274: LD_INT 30
45276: PUSH
45277: LD_INT 30
45279: PUSH
45280: EMPTY
45281: LIST
45282: LIST
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: LIST
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 3
45295: PUSH
45296: LD_INT 24
45298: PUSH
45299: LD_INT 1000
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: LIST
45314: PPUSH
45315: CALL_OW 72
45319: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
45320: LD_ADDR_EXP 101
45324: PUSH
45325: LD_EXP 101
45329: PPUSH
45330: LD_VAR 0 2
45334: PPUSH
45335: LD_VAR 0 3
45339: PPUSH
45340: CALL_OW 1
45344: ST_TO_ADDR
// end ;
45345: GO 45229
45347: POP
45348: POP
// RaiseSailEvent ( 101 ) ;
45349: LD_INT 101
45351: PPUSH
45352: CALL_OW 427
// end ;
45356: LD_VAR 0 1
45360: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45361: LD_INT 0
45363: PPUSH
45364: PPUSH
45365: PPUSH
45366: PPUSH
45367: PPUSH
45368: PPUSH
45369: PPUSH
// if not mc_bases then
45370: LD_EXP 100
45374: NOT
45375: IFFALSE 45379
// exit ;
45377: GO 45941
// for i = 1 to mc_bases do
45379: LD_ADDR_VAR 0 2
45383: PUSH
45384: DOUBLE
45385: LD_INT 1
45387: DEC
45388: ST_TO_ADDR
45389: LD_EXP 100
45393: PUSH
45394: FOR_TO
45395: IFFALSE 45932
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45397: LD_ADDR_VAR 0 5
45401: PUSH
45402: LD_EXP 100
45406: PUSH
45407: LD_VAR 0 2
45411: ARRAY
45412: PUSH
45413: LD_EXP 129
45417: PUSH
45418: LD_VAR 0 2
45422: ARRAY
45423: UNION
45424: PPUSH
45425: LD_INT 21
45427: PUSH
45428: LD_INT 1
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 1
45437: PUSH
45438: LD_INT 3
45440: PUSH
45441: LD_INT 54
45443: PUSH
45444: EMPTY
45445: LIST
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 3
45453: PUSH
45454: LD_INT 24
45456: PUSH
45457: LD_INT 1000
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: LIST
45472: PUSH
45473: EMPTY
45474: LIST
45475: LIST
45476: PPUSH
45477: CALL_OW 72
45481: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45482: LD_ADDR_VAR 0 6
45486: PUSH
45487: LD_EXP 100
45491: PUSH
45492: LD_VAR 0 2
45496: ARRAY
45497: PPUSH
45498: LD_INT 21
45500: PUSH
45501: LD_INT 1
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: PUSH
45508: LD_INT 1
45510: PUSH
45511: LD_INT 3
45513: PUSH
45514: LD_INT 54
45516: PUSH
45517: EMPTY
45518: LIST
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: PUSH
45524: LD_INT 3
45526: PUSH
45527: LD_INT 24
45529: PUSH
45530: LD_INT 250
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: LIST
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PPUSH
45550: CALL_OW 72
45554: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45555: LD_ADDR_VAR 0 7
45559: PUSH
45560: LD_VAR 0 5
45564: PUSH
45565: LD_VAR 0 6
45569: DIFF
45570: ST_TO_ADDR
// if not need_heal_1 then
45571: LD_VAR 0 6
45575: NOT
45576: IFFALSE 45609
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45578: LD_ADDR_EXP 103
45582: PUSH
45583: LD_EXP 103
45587: PPUSH
45588: LD_VAR 0 2
45592: PUSH
45593: LD_INT 1
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: PPUSH
45600: EMPTY
45601: PPUSH
45602: CALL 72673 0 3
45606: ST_TO_ADDR
45607: GO 45679
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
45609: LD_ADDR_EXP 103
45613: PUSH
45614: LD_EXP 103
45618: PPUSH
45619: LD_VAR 0 2
45623: PUSH
45624: LD_INT 1
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: PPUSH
45631: LD_EXP 103
45635: PUSH
45636: LD_VAR 0 2
45640: ARRAY
45641: PUSH
45642: LD_INT 1
45644: ARRAY
45645: PPUSH
45646: LD_INT 3
45648: PUSH
45649: LD_INT 24
45651: PUSH
45652: LD_INT 1000
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: EMPTY
45660: LIST
45661: LIST
45662: PPUSH
45663: CALL_OW 72
45667: PUSH
45668: LD_VAR 0 6
45672: UNION
45673: PPUSH
45674: CALL 72673 0 3
45678: ST_TO_ADDR
// if not need_heal_2 then
45679: LD_VAR 0 7
45683: NOT
45684: IFFALSE 45717
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
45686: LD_ADDR_EXP 103
45690: PUSH
45691: LD_EXP 103
45695: PPUSH
45696: LD_VAR 0 2
45700: PUSH
45701: LD_INT 2
45703: PUSH
45704: EMPTY
45705: LIST
45706: LIST
45707: PPUSH
45708: EMPTY
45709: PPUSH
45710: CALL 72673 0 3
45714: ST_TO_ADDR
45715: GO 45749
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
45717: LD_ADDR_EXP 103
45721: PUSH
45722: LD_EXP 103
45726: PPUSH
45727: LD_VAR 0 2
45731: PUSH
45732: LD_INT 2
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PPUSH
45739: LD_VAR 0 7
45743: PPUSH
45744: CALL 72673 0 3
45748: ST_TO_ADDR
// if need_heal_2 then
45749: LD_VAR 0 7
45753: IFFALSE 45914
// for j in need_heal_2 do
45755: LD_ADDR_VAR 0 3
45759: PUSH
45760: LD_VAR 0 7
45764: PUSH
45765: FOR_IN
45766: IFFALSE 45912
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45768: LD_ADDR_VAR 0 5
45772: PUSH
45773: LD_EXP 100
45777: PUSH
45778: LD_VAR 0 2
45782: ARRAY
45783: PPUSH
45784: LD_INT 2
45786: PUSH
45787: LD_INT 30
45789: PUSH
45790: LD_INT 6
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 30
45799: PUSH
45800: LD_INT 7
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 30
45809: PUSH
45810: LD_INT 8
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 30
45819: PUSH
45820: LD_INT 0
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 30
45829: PUSH
45830: LD_INT 1
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: LIST
45841: LIST
45842: LIST
45843: LIST
45844: PPUSH
45845: CALL_OW 72
45849: ST_TO_ADDR
// if tmp then
45850: LD_VAR 0 5
45854: IFFALSE 45910
// begin k := NearestUnitToUnit ( tmp , j ) ;
45856: LD_ADDR_VAR 0 4
45860: PUSH
45861: LD_VAR 0 5
45865: PPUSH
45866: LD_VAR 0 3
45870: PPUSH
45871: CALL_OW 74
45875: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
45876: LD_VAR 0 3
45880: PPUSH
45881: LD_VAR 0 4
45885: PPUSH
45886: CALL_OW 296
45890: PUSH
45891: LD_INT 5
45893: GREATER
45894: IFFALSE 45910
// ComMoveToNearbyEntrance ( j , k ) ;
45896: LD_VAR 0 3
45900: PPUSH
45901: LD_VAR 0 4
45905: PPUSH
45906: CALL 105881 0 2
// end ; end ;
45910: GO 45765
45912: POP
45913: POP
// if not need_heal_1 and not need_heal_2 then
45914: LD_VAR 0 6
45918: NOT
45919: PUSH
45920: LD_VAR 0 7
45924: NOT
45925: AND
45926: IFFALSE 45930
// continue ;
45928: GO 45394
// end ;
45930: GO 45394
45932: POP
45933: POP
// RaiseSailEvent ( 102 ) ;
45934: LD_INT 102
45936: PPUSH
45937: CALL_OW 427
// end ;
45941: LD_VAR 0 1
45945: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
45946: LD_INT 0
45948: PPUSH
45949: PPUSH
45950: PPUSH
45951: PPUSH
45952: PPUSH
45953: PPUSH
45954: PPUSH
45955: PPUSH
// if not mc_bases then
45956: LD_EXP 100
45960: NOT
45961: IFFALSE 45965
// exit ;
45963: GO 46876
// for i = 1 to mc_bases do
45965: LD_ADDR_VAR 0 2
45969: PUSH
45970: DOUBLE
45971: LD_INT 1
45973: DEC
45974: ST_TO_ADDR
45975: LD_EXP 100
45979: PUSH
45980: FOR_TO
45981: IFFALSE 46874
// begin if not mc_building_need_repair [ i ] then
45983: LD_EXP 101
45987: PUSH
45988: LD_VAR 0 2
45992: ARRAY
45993: NOT
45994: IFFALSE 46179
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
45996: LD_ADDR_VAR 0 6
46000: PUSH
46001: LD_EXP 119
46005: PUSH
46006: LD_VAR 0 2
46010: ARRAY
46011: PPUSH
46012: LD_INT 3
46014: PUSH
46015: LD_INT 24
46017: PUSH
46018: LD_INT 1000
46020: PUSH
46021: EMPTY
46022: LIST
46023: LIST
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 2
46031: PUSH
46032: LD_INT 34
46034: PUSH
46035: LD_INT 13
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 34
46044: PUSH
46045: LD_INT 52
46047: PUSH
46048: EMPTY
46049: LIST
46050: LIST
46051: PUSH
46052: LD_INT 34
46054: PUSH
46055: LD_INT 88
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: LIST
46066: LIST
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: PPUSH
46072: CALL_OW 72
46076: ST_TO_ADDR
// if cranes then
46077: LD_VAR 0 6
46081: IFFALSE 46143
// for j in cranes do
46083: LD_ADDR_VAR 0 3
46087: PUSH
46088: LD_VAR 0 6
46092: PUSH
46093: FOR_IN
46094: IFFALSE 46141
// if not IsInArea ( j , mc_parking [ i ] ) then
46096: LD_VAR 0 3
46100: PPUSH
46101: LD_EXP 124
46105: PUSH
46106: LD_VAR 0 2
46110: ARRAY
46111: PPUSH
46112: CALL_OW 308
46116: NOT
46117: IFFALSE 46139
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46119: LD_VAR 0 3
46123: PPUSH
46124: LD_EXP 124
46128: PUSH
46129: LD_VAR 0 2
46133: ARRAY
46134: PPUSH
46135: CALL_OW 113
46139: GO 46093
46141: POP
46142: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
46143: LD_ADDR_EXP 102
46147: PUSH
46148: LD_EXP 102
46152: PPUSH
46153: LD_VAR 0 2
46157: PPUSH
46158: EMPTY
46159: PPUSH
46160: CALL_OW 1
46164: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
46165: LD_VAR 0 2
46169: PPUSH
46170: LD_INT 101
46172: PPUSH
46173: CALL 41033 0 2
// continue ;
46177: GO 45980
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
46179: LD_ADDR_EXP 106
46183: PUSH
46184: LD_EXP 106
46188: PPUSH
46189: LD_VAR 0 2
46193: PPUSH
46194: EMPTY
46195: PPUSH
46196: CALL_OW 1
46200: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
46201: LD_VAR 0 2
46205: PPUSH
46206: LD_INT 103
46208: PPUSH
46209: CALL 41033 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
46213: LD_ADDR_VAR 0 5
46217: PUSH
46218: LD_EXP 100
46222: PUSH
46223: LD_VAR 0 2
46227: ARRAY
46228: PUSH
46229: LD_EXP 129
46233: PUSH
46234: LD_VAR 0 2
46238: ARRAY
46239: UNION
46240: PPUSH
46241: LD_INT 2
46243: PUSH
46244: LD_INT 25
46246: PUSH
46247: LD_INT 2
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 25
46256: PUSH
46257: LD_INT 16
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: LIST
46268: PUSH
46269: EMPTY
46270: LIST
46271: PPUSH
46272: CALL_OW 72
46276: ST_TO_ADDR
// if mc_need_heal [ i ] then
46277: LD_EXP 103
46281: PUSH
46282: LD_VAR 0 2
46286: ARRAY
46287: IFFALSE 46331
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
46289: LD_ADDR_VAR 0 5
46293: PUSH
46294: LD_VAR 0 5
46298: PUSH
46299: LD_EXP 103
46303: PUSH
46304: LD_VAR 0 2
46308: ARRAY
46309: PUSH
46310: LD_INT 1
46312: ARRAY
46313: PUSH
46314: LD_EXP 103
46318: PUSH
46319: LD_VAR 0 2
46323: ARRAY
46324: PUSH
46325: LD_INT 2
46327: ARRAY
46328: UNION
46329: DIFF
46330: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
46331: LD_ADDR_VAR 0 6
46335: PUSH
46336: LD_EXP 119
46340: PUSH
46341: LD_VAR 0 2
46345: ARRAY
46346: PPUSH
46347: LD_INT 2
46349: PUSH
46350: LD_INT 34
46352: PUSH
46353: LD_INT 13
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 34
46362: PUSH
46363: LD_INT 52
46365: PUSH
46366: EMPTY
46367: LIST
46368: LIST
46369: PUSH
46370: LD_INT 34
46372: PUSH
46373: LD_INT 88
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: PPUSH
46386: CALL_OW 72
46390: ST_TO_ADDR
// if cranes then
46391: LD_VAR 0 6
46395: IFFALSE 46563
// begin for j in cranes do
46397: LD_ADDR_VAR 0 3
46401: PUSH
46402: LD_VAR 0 6
46406: PUSH
46407: FOR_IN
46408: IFFALSE 46561
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46410: LD_VAR 0 3
46414: PPUSH
46415: CALL_OW 256
46419: PUSH
46420: LD_INT 1000
46422: EQUAL
46423: PUSH
46424: LD_VAR 0 3
46428: PPUSH
46429: CALL_OW 314
46433: NOT
46434: AND
46435: IFFALSE 46501
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46437: LD_ADDR_VAR 0 8
46441: PUSH
46442: LD_EXP 101
46446: PUSH
46447: LD_VAR 0 2
46451: ARRAY
46452: PPUSH
46453: LD_VAR 0 3
46457: PPUSH
46458: CALL_OW 74
46462: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46463: LD_VAR 0 8
46467: PPUSH
46468: LD_INT 16
46470: PPUSH
46471: CALL 75270 0 2
46475: PUSH
46476: LD_INT 4
46478: ARRAY
46479: PUSH
46480: LD_INT 10
46482: LESS
46483: IFFALSE 46499
// ComRepairBuilding ( j , to_repair ) ;
46485: LD_VAR 0 3
46489: PPUSH
46490: LD_VAR 0 8
46494: PPUSH
46495: CALL_OW 130
// end else
46499: GO 46559
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46501: LD_VAR 0 3
46505: PPUSH
46506: CALL_OW 256
46510: PUSH
46511: LD_INT 500
46513: LESS
46514: PUSH
46515: LD_VAR 0 3
46519: PPUSH
46520: LD_EXP 124
46524: PUSH
46525: LD_VAR 0 2
46529: ARRAY
46530: PPUSH
46531: CALL_OW 308
46535: NOT
46536: AND
46537: IFFALSE 46559
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46539: LD_VAR 0 3
46543: PPUSH
46544: LD_EXP 124
46548: PUSH
46549: LD_VAR 0 2
46553: ARRAY
46554: PPUSH
46555: CALL_OW 113
// end ;
46559: GO 46407
46561: POP
46562: POP
// end ; if tmp > 3 then
46563: LD_VAR 0 5
46567: PUSH
46568: LD_INT 3
46570: GREATER
46571: IFFALSE 46591
// tmp := ShrinkArray ( tmp , 4 ) ;
46573: LD_ADDR_VAR 0 5
46577: PUSH
46578: LD_VAR 0 5
46582: PPUSH
46583: LD_INT 4
46585: PPUSH
46586: CALL 105319 0 2
46590: ST_TO_ADDR
// if not tmp then
46591: LD_VAR 0 5
46595: NOT
46596: IFFALSE 46600
// continue ;
46598: GO 45980
// for j in tmp do
46600: LD_ADDR_VAR 0 3
46604: PUSH
46605: LD_VAR 0 5
46609: PUSH
46610: FOR_IN
46611: IFFALSE 46870
// begin if IsInUnit ( j ) then
46613: LD_VAR 0 3
46617: PPUSH
46618: CALL_OW 310
46622: IFFALSE 46633
// ComExitBuilding ( j ) ;
46624: LD_VAR 0 3
46628: PPUSH
46629: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
46633: LD_VAR 0 3
46637: PUSH
46638: LD_EXP 102
46642: PUSH
46643: LD_VAR 0 2
46647: ARRAY
46648: IN
46649: NOT
46650: IFFALSE 46708
// begin SetTag ( j , 101 ) ;
46652: LD_VAR 0 3
46656: PPUSH
46657: LD_INT 101
46659: PPUSH
46660: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
46664: LD_ADDR_EXP 102
46668: PUSH
46669: LD_EXP 102
46673: PPUSH
46674: LD_VAR 0 2
46678: PUSH
46679: LD_EXP 102
46683: PUSH
46684: LD_VAR 0 2
46688: ARRAY
46689: PUSH
46690: LD_INT 1
46692: PLUS
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PPUSH
46698: LD_VAR 0 3
46702: PPUSH
46703: CALL 72673 0 3
46707: ST_TO_ADDR
// end ; wait ( 1 ) ;
46708: LD_INT 1
46710: PPUSH
46711: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
46715: LD_ADDR_VAR 0 7
46719: PUSH
46720: LD_EXP 101
46724: PUSH
46725: LD_VAR 0 2
46729: ARRAY
46730: ST_TO_ADDR
// if mc_scan [ i ] then
46731: LD_EXP 123
46735: PUSH
46736: LD_VAR 0 2
46740: ARRAY
46741: IFFALSE 46803
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
46743: LD_ADDR_VAR 0 7
46747: PUSH
46748: LD_EXP 101
46752: PUSH
46753: LD_VAR 0 2
46757: ARRAY
46758: PPUSH
46759: LD_INT 3
46761: PUSH
46762: LD_INT 30
46764: PUSH
46765: LD_INT 32
46767: PUSH
46768: EMPTY
46769: LIST
46770: LIST
46771: PUSH
46772: LD_INT 30
46774: PUSH
46775: LD_INT 33
46777: PUSH
46778: EMPTY
46779: LIST
46780: LIST
46781: PUSH
46782: LD_INT 30
46784: PUSH
46785: LD_INT 31
46787: PUSH
46788: EMPTY
46789: LIST
46790: LIST
46791: PUSH
46792: EMPTY
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: PPUSH
46798: CALL_OW 72
46802: ST_TO_ADDR
// if not to_repair_tmp then
46803: LD_VAR 0 7
46807: NOT
46808: IFFALSE 46812
// continue ;
46810: GO 46610
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
46812: LD_ADDR_VAR 0 8
46816: PUSH
46817: LD_VAR 0 7
46821: PPUSH
46822: LD_VAR 0 3
46826: PPUSH
46827: CALL_OW 74
46831: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
46832: LD_VAR 0 8
46836: PPUSH
46837: LD_INT 16
46839: PPUSH
46840: CALL 75270 0 2
46844: PUSH
46845: LD_INT 4
46847: ARRAY
46848: PUSH
46849: LD_INT 14
46851: LESS
46852: IFFALSE 46868
// ComRepairBuilding ( j , to_repair ) ;
46854: LD_VAR 0 3
46858: PPUSH
46859: LD_VAR 0 8
46863: PPUSH
46864: CALL_OW 130
// end ;
46868: GO 46610
46870: POP
46871: POP
// end ;
46872: GO 45980
46874: POP
46875: POP
// end ;
46876: LD_VAR 0 1
46880: RET
// export function MC_Heal ; var i , j , tmp ; begin
46881: LD_INT 0
46883: PPUSH
46884: PPUSH
46885: PPUSH
46886: PPUSH
// if not mc_bases then
46887: LD_EXP 100
46891: NOT
46892: IFFALSE 46896
// exit ;
46894: GO 47298
// for i = 1 to mc_bases do
46896: LD_ADDR_VAR 0 2
46900: PUSH
46901: DOUBLE
46902: LD_INT 1
46904: DEC
46905: ST_TO_ADDR
46906: LD_EXP 100
46910: PUSH
46911: FOR_TO
46912: IFFALSE 47296
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
46914: LD_EXP 103
46918: PUSH
46919: LD_VAR 0 2
46923: ARRAY
46924: PUSH
46925: LD_INT 1
46927: ARRAY
46928: NOT
46929: PUSH
46930: LD_EXP 103
46934: PUSH
46935: LD_VAR 0 2
46939: ARRAY
46940: PUSH
46941: LD_INT 2
46943: ARRAY
46944: NOT
46945: AND
46946: IFFALSE 46984
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
46948: LD_ADDR_EXP 104
46952: PUSH
46953: LD_EXP 104
46957: PPUSH
46958: LD_VAR 0 2
46962: PPUSH
46963: EMPTY
46964: PPUSH
46965: CALL_OW 1
46969: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
46970: LD_VAR 0 2
46974: PPUSH
46975: LD_INT 102
46977: PPUSH
46978: CALL 41033 0 2
// continue ;
46982: GO 46911
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
46984: LD_ADDR_VAR 0 4
46988: PUSH
46989: LD_EXP 100
46993: PUSH
46994: LD_VAR 0 2
46998: ARRAY
46999: PPUSH
47000: LD_INT 25
47002: PUSH
47003: LD_INT 4
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PPUSH
47010: CALL_OW 72
47014: ST_TO_ADDR
// if not tmp then
47015: LD_VAR 0 4
47019: NOT
47020: IFFALSE 47024
// continue ;
47022: GO 46911
// if mc_taming [ i ] then
47024: LD_EXP 131
47028: PUSH
47029: LD_VAR 0 2
47033: ARRAY
47034: IFFALSE 47058
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
47036: LD_ADDR_EXP 131
47040: PUSH
47041: LD_EXP 131
47045: PPUSH
47046: LD_VAR 0 2
47050: PPUSH
47051: EMPTY
47052: PPUSH
47053: CALL_OW 1
47057: ST_TO_ADDR
// for j in tmp do
47058: LD_ADDR_VAR 0 3
47062: PUSH
47063: LD_VAR 0 4
47067: PUSH
47068: FOR_IN
47069: IFFALSE 47292
// begin if IsInUnit ( j ) then
47071: LD_VAR 0 3
47075: PPUSH
47076: CALL_OW 310
47080: IFFALSE 47091
// ComExitBuilding ( j ) ;
47082: LD_VAR 0 3
47086: PPUSH
47087: CALL_OW 122
// if not j in mc_healers [ i ] then
47091: LD_VAR 0 3
47095: PUSH
47096: LD_EXP 104
47100: PUSH
47101: LD_VAR 0 2
47105: ARRAY
47106: IN
47107: NOT
47108: IFFALSE 47154
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
47110: LD_ADDR_EXP 104
47114: PUSH
47115: LD_EXP 104
47119: PPUSH
47120: LD_VAR 0 2
47124: PUSH
47125: LD_EXP 104
47129: PUSH
47130: LD_VAR 0 2
47134: ARRAY
47135: PUSH
47136: LD_INT 1
47138: PLUS
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PPUSH
47144: LD_VAR 0 3
47148: PPUSH
47149: CALL 72673 0 3
47153: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
47154: LD_VAR 0 3
47158: PPUSH
47159: CALL_OW 110
47163: PUSH
47164: LD_INT 102
47166: NONEQUAL
47167: IFFALSE 47181
// SetTag ( j , 102 ) ;
47169: LD_VAR 0 3
47173: PPUSH
47174: LD_INT 102
47176: PPUSH
47177: CALL_OW 109
// Wait ( 3 ) ;
47181: LD_INT 3
47183: PPUSH
47184: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
47188: LD_EXP 103
47192: PUSH
47193: LD_VAR 0 2
47197: ARRAY
47198: PUSH
47199: LD_INT 1
47201: ARRAY
47202: IFFALSE 47234
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
47204: LD_VAR 0 3
47208: PPUSH
47209: LD_EXP 103
47213: PUSH
47214: LD_VAR 0 2
47218: ARRAY
47219: PUSH
47220: LD_INT 1
47222: ARRAY
47223: PUSH
47224: LD_INT 1
47226: ARRAY
47227: PPUSH
47228: CALL_OW 128
47232: GO 47290
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
47234: LD_VAR 0 3
47238: PPUSH
47239: CALL_OW 314
47243: NOT
47244: PUSH
47245: LD_EXP 103
47249: PUSH
47250: LD_VAR 0 2
47254: ARRAY
47255: PUSH
47256: LD_INT 2
47258: ARRAY
47259: AND
47260: IFFALSE 47290
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
47262: LD_VAR 0 3
47266: PPUSH
47267: LD_EXP 103
47271: PUSH
47272: LD_VAR 0 2
47276: ARRAY
47277: PUSH
47278: LD_INT 2
47280: ARRAY
47281: PUSH
47282: LD_INT 1
47284: ARRAY
47285: PPUSH
47286: CALL_OW 128
// end ;
47290: GO 47068
47292: POP
47293: POP
// end ;
47294: GO 46911
47296: POP
47297: POP
// end ;
47298: LD_VAR 0 1
47302: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
47303: LD_INT 0
47305: PPUSH
47306: PPUSH
47307: PPUSH
47308: PPUSH
47309: PPUSH
47310: PPUSH
// if not mc_bases then
47311: LD_EXP 100
47315: NOT
47316: IFFALSE 47320
// exit ;
47318: GO 48483
// for i = 1 to mc_bases do
47320: LD_ADDR_VAR 0 2
47324: PUSH
47325: DOUBLE
47326: LD_INT 1
47328: DEC
47329: ST_TO_ADDR
47330: LD_EXP 100
47334: PUSH
47335: FOR_TO
47336: IFFALSE 48481
// begin if mc_scan [ i ] then
47338: LD_EXP 123
47342: PUSH
47343: LD_VAR 0 2
47347: ARRAY
47348: IFFALSE 47352
// continue ;
47350: GO 47335
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47352: LD_EXP 105
47356: PUSH
47357: LD_VAR 0 2
47361: ARRAY
47362: NOT
47363: PUSH
47364: LD_EXP 107
47368: PUSH
47369: LD_VAR 0 2
47373: ARRAY
47374: NOT
47375: AND
47376: PUSH
47377: LD_EXP 106
47381: PUSH
47382: LD_VAR 0 2
47386: ARRAY
47387: AND
47388: IFFALSE 47426
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47390: LD_ADDR_EXP 106
47394: PUSH
47395: LD_EXP 106
47399: PPUSH
47400: LD_VAR 0 2
47404: PPUSH
47405: EMPTY
47406: PPUSH
47407: CALL_OW 1
47411: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47412: LD_VAR 0 2
47416: PPUSH
47417: LD_INT 103
47419: PPUSH
47420: CALL 41033 0 2
// continue ;
47424: GO 47335
// end ; if mc_construct_list [ i ] then
47426: LD_EXP 107
47430: PUSH
47431: LD_VAR 0 2
47435: ARRAY
47436: IFFALSE 47656
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47438: LD_ADDR_VAR 0 5
47442: PUSH
47443: LD_EXP 100
47447: PUSH
47448: LD_VAR 0 2
47452: ARRAY
47453: PPUSH
47454: LD_INT 25
47456: PUSH
47457: LD_INT 2
47459: PUSH
47460: EMPTY
47461: LIST
47462: LIST
47463: PPUSH
47464: CALL_OW 72
47468: PUSH
47469: LD_EXP 102
47473: PUSH
47474: LD_VAR 0 2
47478: ARRAY
47479: DIFF
47480: ST_TO_ADDR
// if not tmp then
47481: LD_VAR 0 5
47485: NOT
47486: IFFALSE 47490
// continue ;
47488: GO 47335
// for j in tmp do
47490: LD_ADDR_VAR 0 3
47494: PUSH
47495: LD_VAR 0 5
47499: PUSH
47500: FOR_IN
47501: IFFALSE 47652
// begin if not mc_builders [ i ] then
47503: LD_EXP 106
47507: PUSH
47508: LD_VAR 0 2
47512: ARRAY
47513: NOT
47514: IFFALSE 47572
// begin SetTag ( j , 103 ) ;
47516: LD_VAR 0 3
47520: PPUSH
47521: LD_INT 103
47523: PPUSH
47524: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47528: LD_ADDR_EXP 106
47532: PUSH
47533: LD_EXP 106
47537: PPUSH
47538: LD_VAR 0 2
47542: PUSH
47543: LD_EXP 106
47547: PUSH
47548: LD_VAR 0 2
47552: ARRAY
47553: PUSH
47554: LD_INT 1
47556: PLUS
47557: PUSH
47558: EMPTY
47559: LIST
47560: LIST
47561: PPUSH
47562: LD_VAR 0 3
47566: PPUSH
47567: CALL 72673 0 3
47571: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47572: LD_VAR 0 3
47576: PPUSH
47577: CALL_OW 310
47581: IFFALSE 47592
// ComExitBuilding ( j ) ;
47583: LD_VAR 0 3
47587: PPUSH
47588: CALL_OW 122
// wait ( 3 ) ;
47592: LD_INT 3
47594: PPUSH
47595: CALL_OW 67
// if not mc_construct_list [ i ] then
47599: LD_EXP 107
47603: PUSH
47604: LD_VAR 0 2
47608: ARRAY
47609: NOT
47610: IFFALSE 47614
// break ;
47612: GO 47652
// if not HasTask ( j ) then
47614: LD_VAR 0 3
47618: PPUSH
47619: CALL_OW 314
47623: NOT
47624: IFFALSE 47650
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
47626: LD_VAR 0 3
47630: PPUSH
47631: LD_EXP 107
47635: PUSH
47636: LD_VAR 0 2
47640: ARRAY
47641: PUSH
47642: LD_INT 1
47644: ARRAY
47645: PPUSH
47646: CALL 75534 0 2
// end ;
47650: GO 47500
47652: POP
47653: POP
// end else
47654: GO 48479
// if mc_build_list [ i ] then
47656: LD_EXP 105
47660: PUSH
47661: LD_VAR 0 2
47665: ARRAY
47666: IFFALSE 48479
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
47668: LD_EXP 105
47672: PUSH
47673: LD_VAR 0 2
47677: ARRAY
47678: PUSH
47679: LD_INT 1
47681: ARRAY
47682: PUSH
47683: LD_INT 1
47685: ARRAY
47686: PPUSH
47687: CALL 75358 0 1
47691: PUSH
47692: LD_EXP 100
47696: PUSH
47697: LD_VAR 0 2
47701: ARRAY
47702: PPUSH
47703: LD_INT 2
47705: PUSH
47706: LD_INT 30
47708: PUSH
47709: LD_INT 2
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: PUSH
47716: LD_INT 30
47718: PUSH
47719: LD_INT 3
47721: PUSH
47722: EMPTY
47723: LIST
47724: LIST
47725: PUSH
47726: EMPTY
47727: LIST
47728: LIST
47729: LIST
47730: PPUSH
47731: CALL_OW 72
47735: NOT
47736: AND
47737: IFFALSE 47842
// begin for j = 1 to mc_build_list [ i ] do
47739: LD_ADDR_VAR 0 3
47743: PUSH
47744: DOUBLE
47745: LD_INT 1
47747: DEC
47748: ST_TO_ADDR
47749: LD_EXP 105
47753: PUSH
47754: LD_VAR 0 2
47758: ARRAY
47759: PUSH
47760: FOR_TO
47761: IFFALSE 47840
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
47763: LD_EXP 105
47767: PUSH
47768: LD_VAR 0 2
47772: ARRAY
47773: PUSH
47774: LD_VAR 0 3
47778: ARRAY
47779: PUSH
47780: LD_INT 1
47782: ARRAY
47783: PUSH
47784: LD_INT 2
47786: EQUAL
47787: IFFALSE 47838
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
47789: LD_ADDR_EXP 105
47793: PUSH
47794: LD_EXP 105
47798: PPUSH
47799: LD_VAR 0 2
47803: PPUSH
47804: LD_EXP 105
47808: PUSH
47809: LD_VAR 0 2
47813: ARRAY
47814: PPUSH
47815: LD_VAR 0 3
47819: PPUSH
47820: LD_INT 1
47822: PPUSH
47823: LD_INT 0
47825: PPUSH
47826: CALL 72091 0 4
47830: PPUSH
47831: CALL_OW 1
47835: ST_TO_ADDR
// break ;
47836: GO 47840
// end ;
47838: GO 47760
47840: POP
47841: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47842: LD_ADDR_VAR 0 6
47846: PUSH
47847: LD_EXP 100
47851: PUSH
47852: LD_VAR 0 2
47856: ARRAY
47857: PPUSH
47858: LD_INT 2
47860: PUSH
47861: LD_INT 30
47863: PUSH
47864: LD_INT 0
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: PUSH
47871: LD_INT 30
47873: PUSH
47874: LD_INT 1
47876: PUSH
47877: EMPTY
47878: LIST
47879: LIST
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: LIST
47885: PPUSH
47886: CALL_OW 72
47890: ST_TO_ADDR
// for k := 1 to depot do
47891: LD_ADDR_VAR 0 4
47895: PUSH
47896: DOUBLE
47897: LD_INT 1
47899: DEC
47900: ST_TO_ADDR
47901: LD_VAR 0 6
47905: PUSH
47906: FOR_TO
47907: IFFALSE 48477
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
47909: LD_EXP 105
47913: PUSH
47914: LD_VAR 0 2
47918: ARRAY
47919: PUSH
47920: LD_INT 1
47922: ARRAY
47923: PUSH
47924: LD_INT 1
47926: ARRAY
47927: PUSH
47928: LD_INT 0
47930: EQUAL
47931: PUSH
47932: LD_VAR 0 6
47936: PUSH
47937: LD_VAR 0 4
47941: ARRAY
47942: PPUSH
47943: LD_EXP 105
47947: PUSH
47948: LD_VAR 0 2
47952: ARRAY
47953: PUSH
47954: LD_INT 1
47956: ARRAY
47957: PUSH
47958: LD_INT 1
47960: ARRAY
47961: PPUSH
47962: LD_EXP 105
47966: PUSH
47967: LD_VAR 0 2
47971: ARRAY
47972: PUSH
47973: LD_INT 1
47975: ARRAY
47976: PUSH
47977: LD_INT 2
47979: ARRAY
47980: PPUSH
47981: LD_EXP 105
47985: PUSH
47986: LD_VAR 0 2
47990: ARRAY
47991: PUSH
47992: LD_INT 1
47994: ARRAY
47995: PUSH
47996: LD_INT 3
47998: ARRAY
47999: PPUSH
48000: LD_EXP 105
48004: PUSH
48005: LD_VAR 0 2
48009: ARRAY
48010: PUSH
48011: LD_INT 1
48013: ARRAY
48014: PUSH
48015: LD_INT 4
48017: ARRAY
48018: PPUSH
48019: CALL 80770 0 5
48023: OR
48024: IFFALSE 48305
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
48026: LD_ADDR_VAR 0 5
48030: PUSH
48031: LD_EXP 100
48035: PUSH
48036: LD_VAR 0 2
48040: ARRAY
48041: PPUSH
48042: LD_INT 25
48044: PUSH
48045: LD_INT 2
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: PPUSH
48052: CALL_OW 72
48056: PUSH
48057: LD_EXP 102
48061: PUSH
48062: LD_VAR 0 2
48066: ARRAY
48067: DIFF
48068: ST_TO_ADDR
// if not tmp then
48069: LD_VAR 0 5
48073: NOT
48074: IFFALSE 48078
// continue ;
48076: GO 47906
// for j in tmp do
48078: LD_ADDR_VAR 0 3
48082: PUSH
48083: LD_VAR 0 5
48087: PUSH
48088: FOR_IN
48089: IFFALSE 48301
// begin if not mc_builders [ i ] then
48091: LD_EXP 106
48095: PUSH
48096: LD_VAR 0 2
48100: ARRAY
48101: NOT
48102: IFFALSE 48160
// begin SetTag ( j , 103 ) ;
48104: LD_VAR 0 3
48108: PPUSH
48109: LD_INT 103
48111: PPUSH
48112: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
48116: LD_ADDR_EXP 106
48120: PUSH
48121: LD_EXP 106
48125: PPUSH
48126: LD_VAR 0 2
48130: PUSH
48131: LD_EXP 106
48135: PUSH
48136: LD_VAR 0 2
48140: ARRAY
48141: PUSH
48142: LD_INT 1
48144: PLUS
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PPUSH
48150: LD_VAR 0 3
48154: PPUSH
48155: CALL 72673 0 3
48159: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
48160: LD_VAR 0 3
48164: PPUSH
48165: CALL_OW 310
48169: IFFALSE 48180
// ComExitBuilding ( j ) ;
48171: LD_VAR 0 3
48175: PPUSH
48176: CALL_OW 122
// wait ( 3 ) ;
48180: LD_INT 3
48182: PPUSH
48183: CALL_OW 67
// if not mc_build_list [ i ] then
48187: LD_EXP 105
48191: PUSH
48192: LD_VAR 0 2
48196: ARRAY
48197: NOT
48198: IFFALSE 48202
// break ;
48200: GO 48301
// if not HasTask ( j ) then
48202: LD_VAR 0 3
48206: PPUSH
48207: CALL_OW 314
48211: NOT
48212: IFFALSE 48299
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
48214: LD_VAR 0 3
48218: PPUSH
48219: LD_EXP 105
48223: PUSH
48224: LD_VAR 0 2
48228: ARRAY
48229: PUSH
48230: LD_INT 1
48232: ARRAY
48233: PUSH
48234: LD_INT 1
48236: ARRAY
48237: PPUSH
48238: LD_EXP 105
48242: PUSH
48243: LD_VAR 0 2
48247: ARRAY
48248: PUSH
48249: LD_INT 1
48251: ARRAY
48252: PUSH
48253: LD_INT 2
48255: ARRAY
48256: PPUSH
48257: LD_EXP 105
48261: PUSH
48262: LD_VAR 0 2
48266: ARRAY
48267: PUSH
48268: LD_INT 1
48270: ARRAY
48271: PUSH
48272: LD_INT 3
48274: ARRAY
48275: PPUSH
48276: LD_EXP 105
48280: PUSH
48281: LD_VAR 0 2
48285: ARRAY
48286: PUSH
48287: LD_INT 1
48289: ARRAY
48290: PUSH
48291: LD_INT 4
48293: ARRAY
48294: PPUSH
48295: CALL_OW 145
// end ;
48299: GO 48088
48301: POP
48302: POP
// end else
48303: GO 48475
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
48305: LD_EXP 100
48309: PUSH
48310: LD_VAR 0 2
48314: ARRAY
48315: PPUSH
48316: LD_EXP 105
48320: PUSH
48321: LD_VAR 0 2
48325: ARRAY
48326: PUSH
48327: LD_INT 1
48329: ARRAY
48330: PUSH
48331: LD_INT 1
48333: ARRAY
48334: PPUSH
48335: LD_EXP 105
48339: PUSH
48340: LD_VAR 0 2
48344: ARRAY
48345: PUSH
48346: LD_INT 1
48348: ARRAY
48349: PUSH
48350: LD_INT 2
48352: ARRAY
48353: PPUSH
48354: LD_EXP 105
48358: PUSH
48359: LD_VAR 0 2
48363: ARRAY
48364: PUSH
48365: LD_INT 1
48367: ARRAY
48368: PUSH
48369: LD_INT 3
48371: ARRAY
48372: PPUSH
48373: LD_EXP 105
48377: PUSH
48378: LD_VAR 0 2
48382: ARRAY
48383: PUSH
48384: LD_INT 1
48386: ARRAY
48387: PUSH
48388: LD_INT 4
48390: ARRAY
48391: PPUSH
48392: LD_EXP 100
48396: PUSH
48397: LD_VAR 0 2
48401: ARRAY
48402: PPUSH
48403: LD_INT 21
48405: PUSH
48406: LD_INT 3
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: PPUSH
48413: CALL_OW 72
48417: PPUSH
48418: EMPTY
48419: PPUSH
48420: CALL 79524 0 7
48424: NOT
48425: IFFALSE 48475
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48427: LD_ADDR_EXP 105
48431: PUSH
48432: LD_EXP 105
48436: PPUSH
48437: LD_VAR 0 2
48441: PPUSH
48442: LD_EXP 105
48446: PUSH
48447: LD_VAR 0 2
48451: ARRAY
48452: PPUSH
48453: LD_INT 1
48455: PPUSH
48456: LD_INT 1
48458: NEG
48459: PPUSH
48460: LD_INT 0
48462: PPUSH
48463: CALL 72091 0 4
48467: PPUSH
48468: CALL_OW 1
48472: ST_TO_ADDR
// continue ;
48473: GO 47906
// end ; end ;
48475: GO 47906
48477: POP
48478: POP
// end ; end ;
48479: GO 47335
48481: POP
48482: POP
// end ;
48483: LD_VAR 0 1
48487: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48488: LD_INT 0
48490: PPUSH
48491: PPUSH
48492: PPUSH
48493: PPUSH
48494: PPUSH
48495: PPUSH
// if not mc_bases then
48496: LD_EXP 100
48500: NOT
48501: IFFALSE 48505
// exit ;
48503: GO 48932
// for i = 1 to mc_bases do
48505: LD_ADDR_VAR 0 2
48509: PUSH
48510: DOUBLE
48511: LD_INT 1
48513: DEC
48514: ST_TO_ADDR
48515: LD_EXP 100
48519: PUSH
48520: FOR_TO
48521: IFFALSE 48930
// begin tmp := mc_build_upgrade [ i ] ;
48523: LD_ADDR_VAR 0 4
48527: PUSH
48528: LD_EXP 132
48532: PUSH
48533: LD_VAR 0 2
48537: ARRAY
48538: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48539: LD_ADDR_VAR 0 6
48543: PUSH
48544: LD_EXP 133
48548: PUSH
48549: LD_VAR 0 2
48553: ARRAY
48554: PPUSH
48555: LD_INT 2
48557: PUSH
48558: LD_INT 30
48560: PUSH
48561: LD_INT 6
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 30
48570: PUSH
48571: LD_INT 7
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: EMPTY
48579: LIST
48580: LIST
48581: LIST
48582: PPUSH
48583: CALL_OW 72
48587: ST_TO_ADDR
// if not tmp and not lab then
48588: LD_VAR 0 4
48592: NOT
48593: PUSH
48594: LD_VAR 0 6
48598: NOT
48599: AND
48600: IFFALSE 48604
// continue ;
48602: GO 48520
// if tmp then
48604: LD_VAR 0 4
48608: IFFALSE 48728
// for j in tmp do
48610: LD_ADDR_VAR 0 3
48614: PUSH
48615: LD_VAR 0 4
48619: PUSH
48620: FOR_IN
48621: IFFALSE 48726
// begin if UpgradeCost ( j ) then
48623: LD_VAR 0 3
48627: PPUSH
48628: CALL 79184 0 1
48632: IFFALSE 48724
// begin ComUpgrade ( j ) ;
48634: LD_VAR 0 3
48638: PPUSH
48639: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
48643: LD_ADDR_EXP 132
48647: PUSH
48648: LD_EXP 132
48652: PPUSH
48653: LD_VAR 0 2
48657: PPUSH
48658: LD_EXP 132
48662: PUSH
48663: LD_VAR 0 2
48667: ARRAY
48668: PUSH
48669: LD_VAR 0 3
48673: DIFF
48674: PPUSH
48675: CALL_OW 1
48679: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48680: LD_ADDR_EXP 107
48684: PUSH
48685: LD_EXP 107
48689: PPUSH
48690: LD_VAR 0 2
48694: PUSH
48695: LD_EXP 107
48699: PUSH
48700: LD_VAR 0 2
48704: ARRAY
48705: PUSH
48706: LD_INT 1
48708: PLUS
48709: PUSH
48710: EMPTY
48711: LIST
48712: LIST
48713: PPUSH
48714: LD_VAR 0 3
48718: PPUSH
48719: CALL 72673 0 3
48723: ST_TO_ADDR
// end ; end ;
48724: GO 48620
48726: POP
48727: POP
// if not lab or not mc_lab_upgrade [ i ] then
48728: LD_VAR 0 6
48732: NOT
48733: PUSH
48734: LD_EXP 134
48738: PUSH
48739: LD_VAR 0 2
48743: ARRAY
48744: NOT
48745: OR
48746: IFFALSE 48750
// continue ;
48748: GO 48520
// for j in lab do
48750: LD_ADDR_VAR 0 3
48754: PUSH
48755: LD_VAR 0 6
48759: PUSH
48760: FOR_IN
48761: IFFALSE 48926
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
48763: LD_VAR 0 3
48767: PPUSH
48768: CALL_OW 266
48772: PUSH
48773: LD_INT 6
48775: PUSH
48776: LD_INT 7
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: IN
48783: PUSH
48784: LD_VAR 0 3
48788: PPUSH
48789: CALL_OW 461
48793: PUSH
48794: LD_INT 1
48796: NONEQUAL
48797: AND
48798: IFFALSE 48924
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
48800: LD_VAR 0 3
48804: PPUSH
48805: LD_EXP 134
48809: PUSH
48810: LD_VAR 0 2
48814: ARRAY
48815: PUSH
48816: LD_INT 1
48818: ARRAY
48819: PPUSH
48820: CALL 79389 0 2
48824: IFFALSE 48924
// begin ComCancel ( j ) ;
48826: LD_VAR 0 3
48830: PPUSH
48831: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
48835: LD_VAR 0 3
48839: PPUSH
48840: LD_EXP 134
48844: PUSH
48845: LD_VAR 0 2
48849: ARRAY
48850: PUSH
48851: LD_INT 1
48853: ARRAY
48854: PPUSH
48855: CALL_OW 207
// if not j in mc_construct_list [ i ] then
48859: LD_VAR 0 3
48863: PUSH
48864: LD_EXP 107
48868: PUSH
48869: LD_VAR 0 2
48873: ARRAY
48874: IN
48875: NOT
48876: IFFALSE 48922
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48878: LD_ADDR_EXP 107
48882: PUSH
48883: LD_EXP 107
48887: PPUSH
48888: LD_VAR 0 2
48892: PUSH
48893: LD_EXP 107
48897: PUSH
48898: LD_VAR 0 2
48902: ARRAY
48903: PUSH
48904: LD_INT 1
48906: PLUS
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: PPUSH
48912: LD_VAR 0 3
48916: PPUSH
48917: CALL 72673 0 3
48921: ST_TO_ADDR
// break ;
48922: GO 48926
// end ; end ; end ;
48924: GO 48760
48926: POP
48927: POP
// end ;
48928: GO 48520
48930: POP
48931: POP
// end ;
48932: LD_VAR 0 1
48936: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
48937: LD_INT 0
48939: PPUSH
48940: PPUSH
48941: PPUSH
48942: PPUSH
48943: PPUSH
48944: PPUSH
48945: PPUSH
48946: PPUSH
48947: PPUSH
// if not mc_bases then
48948: LD_EXP 100
48952: NOT
48953: IFFALSE 48957
// exit ;
48955: GO 49362
// for i = 1 to mc_bases do
48957: LD_ADDR_VAR 0 2
48961: PUSH
48962: DOUBLE
48963: LD_INT 1
48965: DEC
48966: ST_TO_ADDR
48967: LD_EXP 100
48971: PUSH
48972: FOR_TO
48973: IFFALSE 49360
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
48975: LD_EXP 108
48979: PUSH
48980: LD_VAR 0 2
48984: ARRAY
48985: NOT
48986: PUSH
48987: LD_EXP 100
48991: PUSH
48992: LD_VAR 0 2
48996: ARRAY
48997: PPUSH
48998: LD_INT 30
49000: PUSH
49001: LD_INT 3
49003: PUSH
49004: EMPTY
49005: LIST
49006: LIST
49007: PPUSH
49008: CALL_OW 72
49012: NOT
49013: OR
49014: IFFALSE 49018
// continue ;
49016: GO 48972
// busy := false ;
49018: LD_ADDR_VAR 0 8
49022: PUSH
49023: LD_INT 0
49025: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49026: LD_ADDR_VAR 0 4
49030: PUSH
49031: LD_EXP 100
49035: PUSH
49036: LD_VAR 0 2
49040: ARRAY
49041: PPUSH
49042: LD_INT 30
49044: PUSH
49045: LD_INT 3
49047: PUSH
49048: EMPTY
49049: LIST
49050: LIST
49051: PPUSH
49052: CALL_OW 72
49056: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
49057: LD_ADDR_VAR 0 6
49061: PUSH
49062: LD_EXP 108
49066: PUSH
49067: LD_VAR 0 2
49071: ARRAY
49072: PPUSH
49073: LD_INT 2
49075: PUSH
49076: LD_INT 30
49078: PUSH
49079: LD_INT 32
49081: PUSH
49082: EMPTY
49083: LIST
49084: LIST
49085: PUSH
49086: LD_INT 30
49088: PUSH
49089: LD_INT 33
49091: PUSH
49092: EMPTY
49093: LIST
49094: LIST
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: LIST
49100: PPUSH
49101: CALL_OW 72
49105: ST_TO_ADDR
// if not t then
49106: LD_VAR 0 6
49110: NOT
49111: IFFALSE 49115
// continue ;
49113: GO 48972
// for j in tmp do
49115: LD_ADDR_VAR 0 3
49119: PUSH
49120: LD_VAR 0 4
49124: PUSH
49125: FOR_IN
49126: IFFALSE 49156
// if not BuildingStatus ( j ) = bs_idle then
49128: LD_VAR 0 3
49132: PPUSH
49133: CALL_OW 461
49137: PUSH
49138: LD_INT 2
49140: EQUAL
49141: NOT
49142: IFFALSE 49154
// begin busy := true ;
49144: LD_ADDR_VAR 0 8
49148: PUSH
49149: LD_INT 1
49151: ST_TO_ADDR
// break ;
49152: GO 49156
// end ;
49154: GO 49125
49156: POP
49157: POP
// if busy then
49158: LD_VAR 0 8
49162: IFFALSE 49166
// continue ;
49164: GO 48972
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
49166: LD_ADDR_VAR 0 7
49170: PUSH
49171: LD_VAR 0 6
49175: PPUSH
49176: LD_INT 35
49178: PUSH
49179: LD_INT 0
49181: PUSH
49182: EMPTY
49183: LIST
49184: LIST
49185: PPUSH
49186: CALL_OW 72
49190: ST_TO_ADDR
// if tw then
49191: LD_VAR 0 7
49195: IFFALSE 49272
// begin tw := tw [ 1 ] ;
49197: LD_ADDR_VAR 0 7
49201: PUSH
49202: LD_VAR 0 7
49206: PUSH
49207: LD_INT 1
49209: ARRAY
49210: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
49211: LD_ADDR_VAR 0 9
49215: PUSH
49216: LD_VAR 0 7
49220: PPUSH
49221: LD_EXP 125
49225: PUSH
49226: LD_VAR 0 2
49230: ARRAY
49231: PPUSH
49232: CALL 77681 0 2
49236: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
49237: LD_EXP 139
49241: PUSH
49242: LD_VAR 0 2
49246: ARRAY
49247: IFFALSE 49270
// if not weapon in mc_allowed_tower_weapons [ i ] then
49249: LD_VAR 0 9
49253: PUSH
49254: LD_EXP 139
49258: PUSH
49259: LD_VAR 0 2
49263: ARRAY
49264: IN
49265: NOT
49266: IFFALSE 49270
// continue ;
49268: GO 48972
// end else
49270: GO 49335
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
49272: LD_ADDR_VAR 0 5
49276: PUSH
49277: LD_EXP 108
49281: PUSH
49282: LD_VAR 0 2
49286: ARRAY
49287: PPUSH
49288: LD_VAR 0 4
49292: PPUSH
49293: CALL 104552 0 2
49297: ST_TO_ADDR
// if not tmp2 then
49298: LD_VAR 0 5
49302: NOT
49303: IFFALSE 49307
// continue ;
49305: GO 48972
// tw := tmp2 [ 1 ] ;
49307: LD_ADDR_VAR 0 7
49311: PUSH
49312: LD_VAR 0 5
49316: PUSH
49317: LD_INT 1
49319: ARRAY
49320: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
49321: LD_ADDR_VAR 0 9
49325: PUSH
49326: LD_VAR 0 5
49330: PUSH
49331: LD_INT 2
49333: ARRAY
49334: ST_TO_ADDR
// end ; if not weapon then
49335: LD_VAR 0 9
49339: NOT
49340: IFFALSE 49344
// continue ;
49342: GO 48972
// ComPlaceWeapon ( tw , weapon ) ;
49344: LD_VAR 0 7
49348: PPUSH
49349: LD_VAR 0 9
49353: PPUSH
49354: CALL_OW 148
// end ;
49358: GO 48972
49360: POP
49361: POP
// end ;
49362: LD_VAR 0 1
49366: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49367: LD_INT 0
49369: PPUSH
49370: PPUSH
49371: PPUSH
49372: PPUSH
49373: PPUSH
49374: PPUSH
49375: PPUSH
// if not mc_bases then
49376: LD_EXP 100
49380: NOT
49381: IFFALSE 49385
// exit ;
49383: GO 50153
// for i = 1 to mc_bases do
49385: LD_ADDR_VAR 0 2
49389: PUSH
49390: DOUBLE
49391: LD_INT 1
49393: DEC
49394: ST_TO_ADDR
49395: LD_EXP 100
49399: PUSH
49400: FOR_TO
49401: IFFALSE 50151
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49403: LD_EXP 113
49407: PUSH
49408: LD_VAR 0 2
49412: ARRAY
49413: NOT
49414: PUSH
49415: LD_EXP 113
49419: PUSH
49420: LD_VAR 0 2
49424: ARRAY
49425: PUSH
49426: LD_EXP 114
49430: PUSH
49431: LD_VAR 0 2
49435: ARRAY
49436: EQUAL
49437: OR
49438: PUSH
49439: LD_EXP 123
49443: PUSH
49444: LD_VAR 0 2
49448: ARRAY
49449: OR
49450: IFFALSE 49454
// continue ;
49452: GO 49400
// if mc_miners [ i ] then
49454: LD_EXP 114
49458: PUSH
49459: LD_VAR 0 2
49463: ARRAY
49464: IFFALSE 49838
// begin for j = mc_miners [ i ] downto 1 do
49466: LD_ADDR_VAR 0 3
49470: PUSH
49471: DOUBLE
49472: LD_EXP 114
49476: PUSH
49477: LD_VAR 0 2
49481: ARRAY
49482: INC
49483: ST_TO_ADDR
49484: LD_INT 1
49486: PUSH
49487: FOR_DOWNTO
49488: IFFALSE 49836
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49490: LD_EXP 114
49494: PUSH
49495: LD_VAR 0 2
49499: ARRAY
49500: PUSH
49501: LD_VAR 0 3
49505: ARRAY
49506: PPUSH
49507: CALL_OW 301
49511: PUSH
49512: LD_EXP 114
49516: PUSH
49517: LD_VAR 0 2
49521: ARRAY
49522: PUSH
49523: LD_VAR 0 3
49527: ARRAY
49528: PPUSH
49529: CALL_OW 257
49533: PUSH
49534: LD_INT 1
49536: NONEQUAL
49537: OR
49538: IFFALSE 49601
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49540: LD_ADDR_VAR 0 5
49544: PUSH
49545: LD_EXP 114
49549: PUSH
49550: LD_VAR 0 2
49554: ARRAY
49555: PUSH
49556: LD_EXP 114
49560: PUSH
49561: LD_VAR 0 2
49565: ARRAY
49566: PUSH
49567: LD_VAR 0 3
49571: ARRAY
49572: DIFF
49573: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49574: LD_ADDR_EXP 114
49578: PUSH
49579: LD_EXP 114
49583: PPUSH
49584: LD_VAR 0 2
49588: PPUSH
49589: LD_VAR 0 5
49593: PPUSH
49594: CALL_OW 1
49598: ST_TO_ADDR
// continue ;
49599: GO 49487
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
49601: LD_EXP 114
49605: PUSH
49606: LD_VAR 0 2
49610: ARRAY
49611: PUSH
49612: LD_VAR 0 3
49616: ARRAY
49617: PPUSH
49618: CALL_OW 257
49622: PUSH
49623: LD_INT 1
49625: EQUAL
49626: PUSH
49627: LD_EXP 114
49631: PUSH
49632: LD_VAR 0 2
49636: ARRAY
49637: PUSH
49638: LD_VAR 0 3
49642: ARRAY
49643: PPUSH
49644: CALL_OW 459
49648: NOT
49649: AND
49650: PUSH
49651: LD_EXP 114
49655: PUSH
49656: LD_VAR 0 2
49660: ARRAY
49661: PUSH
49662: LD_VAR 0 3
49666: ARRAY
49667: PPUSH
49668: CALL_OW 314
49672: NOT
49673: AND
49674: IFFALSE 49834
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
49676: LD_EXP 114
49680: PUSH
49681: LD_VAR 0 2
49685: ARRAY
49686: PUSH
49687: LD_VAR 0 3
49691: ARRAY
49692: PPUSH
49693: CALL_OW 310
49697: IFFALSE 49720
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
49699: LD_EXP 114
49703: PUSH
49704: LD_VAR 0 2
49708: ARRAY
49709: PUSH
49710: LD_VAR 0 3
49714: ARRAY
49715: PPUSH
49716: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
49720: LD_EXP 114
49724: PUSH
49725: LD_VAR 0 2
49729: ARRAY
49730: PUSH
49731: LD_VAR 0 3
49735: ARRAY
49736: PPUSH
49737: CALL_OW 314
49741: NOT
49742: IFFALSE 49834
// begin r := rand ( 1 , mc_mines [ i ] ) ;
49744: LD_ADDR_VAR 0 7
49748: PUSH
49749: LD_INT 1
49751: PPUSH
49752: LD_EXP 113
49756: PUSH
49757: LD_VAR 0 2
49761: ARRAY
49762: PPUSH
49763: CALL_OW 12
49767: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
49768: LD_EXP 114
49772: PUSH
49773: LD_VAR 0 2
49777: ARRAY
49778: PUSH
49779: LD_VAR 0 3
49783: ARRAY
49784: PPUSH
49785: LD_EXP 113
49789: PUSH
49790: LD_VAR 0 2
49794: ARRAY
49795: PUSH
49796: LD_VAR 0 7
49800: ARRAY
49801: PUSH
49802: LD_INT 1
49804: ARRAY
49805: PPUSH
49806: LD_EXP 113
49810: PUSH
49811: LD_VAR 0 2
49815: ARRAY
49816: PUSH
49817: LD_VAR 0 7
49821: ARRAY
49822: PUSH
49823: LD_INT 2
49825: ARRAY
49826: PPUSH
49827: LD_INT 0
49829: PPUSH
49830: CALL_OW 193
// end ; end ; end ;
49834: GO 49487
49836: POP
49837: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
49838: LD_ADDR_VAR 0 5
49842: PUSH
49843: LD_EXP 100
49847: PUSH
49848: LD_VAR 0 2
49852: ARRAY
49853: PPUSH
49854: LD_INT 2
49856: PUSH
49857: LD_INT 30
49859: PUSH
49860: LD_INT 4
49862: PUSH
49863: EMPTY
49864: LIST
49865: LIST
49866: PUSH
49867: LD_INT 30
49869: PUSH
49870: LD_INT 5
49872: PUSH
49873: EMPTY
49874: LIST
49875: LIST
49876: PUSH
49877: LD_INT 30
49879: PUSH
49880: LD_INT 32
49882: PUSH
49883: EMPTY
49884: LIST
49885: LIST
49886: PUSH
49887: EMPTY
49888: LIST
49889: LIST
49890: LIST
49891: LIST
49892: PPUSH
49893: CALL_OW 72
49897: ST_TO_ADDR
// if not tmp then
49898: LD_VAR 0 5
49902: NOT
49903: IFFALSE 49907
// continue ;
49905: GO 49400
// list := [ ] ;
49907: LD_ADDR_VAR 0 6
49911: PUSH
49912: EMPTY
49913: ST_TO_ADDR
// for j in tmp do
49914: LD_ADDR_VAR 0 3
49918: PUSH
49919: LD_VAR 0 5
49923: PUSH
49924: FOR_IN
49925: IFFALSE 49994
// begin for k in UnitsInside ( j ) do
49927: LD_ADDR_VAR 0 4
49931: PUSH
49932: LD_VAR 0 3
49936: PPUSH
49937: CALL_OW 313
49941: PUSH
49942: FOR_IN
49943: IFFALSE 49990
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
49945: LD_VAR 0 4
49949: PPUSH
49950: CALL_OW 257
49954: PUSH
49955: LD_INT 1
49957: EQUAL
49958: PUSH
49959: LD_VAR 0 4
49963: PPUSH
49964: CALL_OW 459
49968: NOT
49969: AND
49970: IFFALSE 49988
// list := list ^ k ;
49972: LD_ADDR_VAR 0 6
49976: PUSH
49977: LD_VAR 0 6
49981: PUSH
49982: LD_VAR 0 4
49986: ADD
49987: ST_TO_ADDR
49988: GO 49942
49990: POP
49991: POP
// end ;
49992: GO 49924
49994: POP
49995: POP
// list := list diff mc_miners [ i ] ;
49996: LD_ADDR_VAR 0 6
50000: PUSH
50001: LD_VAR 0 6
50005: PUSH
50006: LD_EXP 114
50010: PUSH
50011: LD_VAR 0 2
50015: ARRAY
50016: DIFF
50017: ST_TO_ADDR
// if not list then
50018: LD_VAR 0 6
50022: NOT
50023: IFFALSE 50027
// continue ;
50025: GO 49400
// k := mc_mines [ i ] - mc_miners [ i ] ;
50027: LD_ADDR_VAR 0 4
50031: PUSH
50032: LD_EXP 113
50036: PUSH
50037: LD_VAR 0 2
50041: ARRAY
50042: PUSH
50043: LD_EXP 114
50047: PUSH
50048: LD_VAR 0 2
50052: ARRAY
50053: MINUS
50054: ST_TO_ADDR
// if k > list then
50055: LD_VAR 0 4
50059: PUSH
50060: LD_VAR 0 6
50064: GREATER
50065: IFFALSE 50077
// k := list ;
50067: LD_ADDR_VAR 0 4
50071: PUSH
50072: LD_VAR 0 6
50076: ST_TO_ADDR
// for j = 1 to k do
50077: LD_ADDR_VAR 0 3
50081: PUSH
50082: DOUBLE
50083: LD_INT 1
50085: DEC
50086: ST_TO_ADDR
50087: LD_VAR 0 4
50091: PUSH
50092: FOR_TO
50093: IFFALSE 50147
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
50095: LD_ADDR_EXP 114
50099: PUSH
50100: LD_EXP 114
50104: PPUSH
50105: LD_VAR 0 2
50109: PUSH
50110: LD_EXP 114
50114: PUSH
50115: LD_VAR 0 2
50119: ARRAY
50120: PUSH
50121: LD_INT 1
50123: PLUS
50124: PUSH
50125: EMPTY
50126: LIST
50127: LIST
50128: PPUSH
50129: LD_VAR 0 6
50133: PUSH
50134: LD_VAR 0 3
50138: ARRAY
50139: PPUSH
50140: CALL 72673 0 3
50144: ST_TO_ADDR
50145: GO 50092
50147: POP
50148: POP
// end ;
50149: GO 49400
50151: POP
50152: POP
// end ;
50153: LD_VAR 0 1
50157: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
50158: LD_INT 0
50160: PPUSH
50161: PPUSH
50162: PPUSH
50163: PPUSH
50164: PPUSH
50165: PPUSH
50166: PPUSH
50167: PPUSH
50168: PPUSH
50169: PPUSH
50170: PPUSH
// if not mc_bases then
50171: LD_EXP 100
50175: NOT
50176: IFFALSE 50180
// exit ;
50178: GO 52003
// for i = 1 to mc_bases do
50180: LD_ADDR_VAR 0 2
50184: PUSH
50185: DOUBLE
50186: LD_INT 1
50188: DEC
50189: ST_TO_ADDR
50190: LD_EXP 100
50194: PUSH
50195: FOR_TO
50196: IFFALSE 52001
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
50198: LD_EXP 100
50202: PUSH
50203: LD_VAR 0 2
50207: ARRAY
50208: NOT
50209: PUSH
50210: LD_EXP 107
50214: PUSH
50215: LD_VAR 0 2
50219: ARRAY
50220: OR
50221: IFFALSE 50225
// continue ;
50223: GO 50195
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
50225: LD_EXP 116
50229: PUSH
50230: LD_VAR 0 2
50234: ARRAY
50235: NOT
50236: PUSH
50237: LD_EXP 117
50241: PUSH
50242: LD_VAR 0 2
50246: ARRAY
50247: AND
50248: IFFALSE 50286
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50250: LD_ADDR_EXP 117
50254: PUSH
50255: LD_EXP 117
50259: PPUSH
50260: LD_VAR 0 2
50264: PPUSH
50265: EMPTY
50266: PPUSH
50267: CALL_OW 1
50271: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
50272: LD_VAR 0 2
50276: PPUSH
50277: LD_INT 107
50279: PPUSH
50280: CALL 41033 0 2
// continue ;
50284: GO 50195
// end ; target := [ ] ;
50286: LD_ADDR_VAR 0 7
50290: PUSH
50291: EMPTY
50292: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50293: LD_ADDR_VAR 0 6
50297: PUSH
50298: LD_EXP 100
50302: PUSH
50303: LD_VAR 0 2
50307: ARRAY
50308: PUSH
50309: LD_INT 1
50311: ARRAY
50312: PPUSH
50313: CALL_OW 255
50317: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50318: LD_ADDR_VAR 0 9
50322: PUSH
50323: LD_EXP 100
50327: PUSH
50328: LD_VAR 0 2
50332: ARRAY
50333: PPUSH
50334: LD_INT 2
50336: PUSH
50337: LD_INT 30
50339: PUSH
50340: LD_INT 0
50342: PUSH
50343: EMPTY
50344: LIST
50345: LIST
50346: PUSH
50347: LD_INT 30
50349: PUSH
50350: LD_INT 1
50352: PUSH
50353: EMPTY
50354: LIST
50355: LIST
50356: PUSH
50357: EMPTY
50358: LIST
50359: LIST
50360: LIST
50361: PPUSH
50362: CALL_OW 72
50366: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50367: LD_ADDR_VAR 0 3
50371: PUSH
50372: DOUBLE
50373: LD_EXP 116
50377: PUSH
50378: LD_VAR 0 2
50382: ARRAY
50383: INC
50384: ST_TO_ADDR
50385: LD_INT 1
50387: PUSH
50388: FOR_DOWNTO
50389: IFFALSE 50634
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50391: LD_EXP 116
50395: PUSH
50396: LD_VAR 0 2
50400: ARRAY
50401: PUSH
50402: LD_VAR 0 3
50406: ARRAY
50407: PUSH
50408: LD_INT 2
50410: ARRAY
50411: PPUSH
50412: LD_EXP 116
50416: PUSH
50417: LD_VAR 0 2
50421: ARRAY
50422: PUSH
50423: LD_VAR 0 3
50427: ARRAY
50428: PUSH
50429: LD_INT 3
50431: ARRAY
50432: PPUSH
50433: CALL_OW 488
50437: PUSH
50438: LD_EXP 116
50442: PUSH
50443: LD_VAR 0 2
50447: ARRAY
50448: PUSH
50449: LD_VAR 0 3
50453: ARRAY
50454: PUSH
50455: LD_INT 2
50457: ARRAY
50458: PPUSH
50459: LD_EXP 116
50463: PUSH
50464: LD_VAR 0 2
50468: ARRAY
50469: PUSH
50470: LD_VAR 0 3
50474: ARRAY
50475: PUSH
50476: LD_INT 3
50478: ARRAY
50479: PPUSH
50480: CALL_OW 284
50484: PUSH
50485: LD_INT 0
50487: EQUAL
50488: AND
50489: IFFALSE 50544
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50491: LD_ADDR_VAR 0 5
50495: PUSH
50496: LD_EXP 116
50500: PUSH
50501: LD_VAR 0 2
50505: ARRAY
50506: PPUSH
50507: LD_VAR 0 3
50511: PPUSH
50512: CALL_OW 3
50516: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50517: LD_ADDR_EXP 116
50521: PUSH
50522: LD_EXP 116
50526: PPUSH
50527: LD_VAR 0 2
50531: PPUSH
50532: LD_VAR 0 5
50536: PPUSH
50537: CALL_OW 1
50541: ST_TO_ADDR
// continue ;
50542: GO 50388
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50544: LD_VAR 0 6
50548: PPUSH
50549: LD_EXP 116
50553: PUSH
50554: LD_VAR 0 2
50558: ARRAY
50559: PUSH
50560: LD_VAR 0 3
50564: ARRAY
50565: PUSH
50566: LD_INT 2
50568: ARRAY
50569: PPUSH
50570: LD_EXP 116
50574: PUSH
50575: LD_VAR 0 2
50579: ARRAY
50580: PUSH
50581: LD_VAR 0 3
50585: ARRAY
50586: PUSH
50587: LD_INT 3
50589: ARRAY
50590: PPUSH
50591: LD_INT 30
50593: PPUSH
50594: CALL 73569 0 4
50598: PUSH
50599: LD_INT 4
50601: ARRAY
50602: PUSH
50603: LD_INT 0
50605: EQUAL
50606: IFFALSE 50632
// begin target := mc_crates [ i ] [ j ] ;
50608: LD_ADDR_VAR 0 7
50612: PUSH
50613: LD_EXP 116
50617: PUSH
50618: LD_VAR 0 2
50622: ARRAY
50623: PUSH
50624: LD_VAR 0 3
50628: ARRAY
50629: ST_TO_ADDR
// break ;
50630: GO 50634
// end ; end ;
50632: GO 50388
50634: POP
50635: POP
// if not target then
50636: LD_VAR 0 7
50640: NOT
50641: IFFALSE 50645
// continue ;
50643: GO 50195
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
50645: LD_ADDR_VAR 0 8
50649: PUSH
50650: LD_EXP 119
50654: PUSH
50655: LD_VAR 0 2
50659: ARRAY
50660: PPUSH
50661: LD_INT 2
50663: PUSH
50664: LD_INT 3
50666: PUSH
50667: LD_INT 58
50669: PUSH
50670: EMPTY
50671: LIST
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: PUSH
50677: LD_INT 61
50679: PUSH
50680: EMPTY
50681: LIST
50682: PUSH
50683: LD_INT 33
50685: PUSH
50686: LD_INT 5
50688: PUSH
50689: EMPTY
50690: LIST
50691: LIST
50692: PUSH
50693: LD_INT 33
50695: PUSH
50696: LD_INT 3
50698: PUSH
50699: EMPTY
50700: LIST
50701: LIST
50702: PUSH
50703: EMPTY
50704: LIST
50705: LIST
50706: LIST
50707: LIST
50708: LIST
50709: PUSH
50710: LD_INT 2
50712: PUSH
50713: LD_INT 34
50715: PUSH
50716: LD_INT 32
50718: PUSH
50719: EMPTY
50720: LIST
50721: LIST
50722: PUSH
50723: LD_INT 34
50725: PUSH
50726: LD_INT 51
50728: PUSH
50729: EMPTY
50730: LIST
50731: LIST
50732: PUSH
50733: LD_INT 34
50735: PUSH
50736: LD_INT 12
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: LIST
50747: LIST
50748: PUSH
50749: EMPTY
50750: LIST
50751: LIST
50752: PPUSH
50753: CALL_OW 72
50757: ST_TO_ADDR
// if not cargo then
50758: LD_VAR 0 8
50762: NOT
50763: IFFALSE 51469
// begin if mc_crates_collector [ i ] < 5 then
50765: LD_EXP 117
50769: PUSH
50770: LD_VAR 0 2
50774: ARRAY
50775: PUSH
50776: LD_INT 5
50778: LESS
50779: IFFALSE 51145
// begin if mc_ape [ i ] then
50781: LD_EXP 129
50785: PUSH
50786: LD_VAR 0 2
50790: ARRAY
50791: IFFALSE 50838
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
50793: LD_ADDR_VAR 0 5
50797: PUSH
50798: LD_EXP 129
50802: PUSH
50803: LD_VAR 0 2
50807: ARRAY
50808: PPUSH
50809: LD_INT 25
50811: PUSH
50812: LD_INT 16
50814: PUSH
50815: EMPTY
50816: LIST
50817: LIST
50818: PUSH
50819: LD_INT 24
50821: PUSH
50822: LD_INT 750
50824: PUSH
50825: EMPTY
50826: LIST
50827: LIST
50828: PUSH
50829: EMPTY
50830: LIST
50831: LIST
50832: PPUSH
50833: CALL_OW 72
50837: ST_TO_ADDR
// if not tmp then
50838: LD_VAR 0 5
50842: NOT
50843: IFFALSE 50890
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
50845: LD_ADDR_VAR 0 5
50849: PUSH
50850: LD_EXP 100
50854: PUSH
50855: LD_VAR 0 2
50859: ARRAY
50860: PPUSH
50861: LD_INT 25
50863: PUSH
50864: LD_INT 2
50866: PUSH
50867: EMPTY
50868: LIST
50869: LIST
50870: PUSH
50871: LD_INT 24
50873: PUSH
50874: LD_INT 750
50876: PUSH
50877: EMPTY
50878: LIST
50879: LIST
50880: PUSH
50881: EMPTY
50882: LIST
50883: LIST
50884: PPUSH
50885: CALL_OW 72
50889: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
50890: LD_EXP 129
50894: PUSH
50895: LD_VAR 0 2
50899: ARRAY
50900: PUSH
50901: LD_EXP 100
50905: PUSH
50906: LD_VAR 0 2
50910: ARRAY
50911: PPUSH
50912: LD_INT 25
50914: PUSH
50915: LD_INT 2
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: PUSH
50922: LD_INT 24
50924: PUSH
50925: LD_INT 750
50927: PUSH
50928: EMPTY
50929: LIST
50930: LIST
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: PPUSH
50936: CALL_OW 72
50940: AND
50941: PUSH
50942: LD_VAR 0 5
50946: PUSH
50947: LD_INT 5
50949: LESS
50950: AND
50951: IFFALSE 51033
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
50953: LD_ADDR_VAR 0 3
50957: PUSH
50958: LD_EXP 100
50962: PUSH
50963: LD_VAR 0 2
50967: ARRAY
50968: PPUSH
50969: LD_INT 25
50971: PUSH
50972: LD_INT 2
50974: PUSH
50975: EMPTY
50976: LIST
50977: LIST
50978: PUSH
50979: LD_INT 24
50981: PUSH
50982: LD_INT 750
50984: PUSH
50985: EMPTY
50986: LIST
50987: LIST
50988: PUSH
50989: EMPTY
50990: LIST
50991: LIST
50992: PPUSH
50993: CALL_OW 72
50997: PUSH
50998: FOR_IN
50999: IFFALSE 51031
// begin tmp := tmp union j ;
51001: LD_ADDR_VAR 0 5
51005: PUSH
51006: LD_VAR 0 5
51010: PUSH
51011: LD_VAR 0 3
51015: UNION
51016: ST_TO_ADDR
// if tmp >= 5 then
51017: LD_VAR 0 5
51021: PUSH
51022: LD_INT 5
51024: GREATEREQUAL
51025: IFFALSE 51029
// break ;
51027: GO 51031
// end ;
51029: GO 50998
51031: POP
51032: POP
// end ; if not tmp then
51033: LD_VAR 0 5
51037: NOT
51038: IFFALSE 51042
// continue ;
51040: GO 50195
// for j in tmp do
51042: LD_ADDR_VAR 0 3
51046: PUSH
51047: LD_VAR 0 5
51051: PUSH
51052: FOR_IN
51053: IFFALSE 51143
// if not GetTag ( j ) then
51055: LD_VAR 0 3
51059: PPUSH
51060: CALL_OW 110
51064: NOT
51065: IFFALSE 51141
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
51067: LD_ADDR_EXP 117
51071: PUSH
51072: LD_EXP 117
51076: PPUSH
51077: LD_VAR 0 2
51081: PUSH
51082: LD_EXP 117
51086: PUSH
51087: LD_VAR 0 2
51091: ARRAY
51092: PUSH
51093: LD_INT 1
51095: PLUS
51096: PUSH
51097: EMPTY
51098: LIST
51099: LIST
51100: PPUSH
51101: LD_VAR 0 3
51105: PPUSH
51106: CALL 72673 0 3
51110: ST_TO_ADDR
// SetTag ( j , 107 ) ;
51111: LD_VAR 0 3
51115: PPUSH
51116: LD_INT 107
51118: PPUSH
51119: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
51123: LD_EXP 117
51127: PUSH
51128: LD_VAR 0 2
51132: ARRAY
51133: PUSH
51134: LD_INT 5
51136: GREATEREQUAL
51137: IFFALSE 51141
// break ;
51139: GO 51143
// end ;
51141: GO 51052
51143: POP
51144: POP
// end ; if mc_crates_collector [ i ] and target then
51145: LD_EXP 117
51149: PUSH
51150: LD_VAR 0 2
51154: ARRAY
51155: PUSH
51156: LD_VAR 0 7
51160: AND
51161: IFFALSE 51467
// begin if mc_crates_collector [ i ] < target [ 1 ] then
51163: LD_EXP 117
51167: PUSH
51168: LD_VAR 0 2
51172: ARRAY
51173: PUSH
51174: LD_VAR 0 7
51178: PUSH
51179: LD_INT 1
51181: ARRAY
51182: LESS
51183: IFFALSE 51203
// tmp := mc_crates_collector [ i ] else
51185: LD_ADDR_VAR 0 5
51189: PUSH
51190: LD_EXP 117
51194: PUSH
51195: LD_VAR 0 2
51199: ARRAY
51200: ST_TO_ADDR
51201: GO 51217
// tmp := target [ 1 ] ;
51203: LD_ADDR_VAR 0 5
51207: PUSH
51208: LD_VAR 0 7
51212: PUSH
51213: LD_INT 1
51215: ARRAY
51216: ST_TO_ADDR
// k := 0 ;
51217: LD_ADDR_VAR 0 4
51221: PUSH
51222: LD_INT 0
51224: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
51225: LD_ADDR_VAR 0 3
51229: PUSH
51230: LD_EXP 117
51234: PUSH
51235: LD_VAR 0 2
51239: ARRAY
51240: PUSH
51241: FOR_IN
51242: IFFALSE 51465
// begin k := k + 1 ;
51244: LD_ADDR_VAR 0 4
51248: PUSH
51249: LD_VAR 0 4
51253: PUSH
51254: LD_INT 1
51256: PLUS
51257: ST_TO_ADDR
// if k > tmp then
51258: LD_VAR 0 4
51262: PUSH
51263: LD_VAR 0 5
51267: GREATER
51268: IFFALSE 51272
// break ;
51270: GO 51465
// if not GetClass ( j ) in [ 2 , 16 ] then
51272: LD_VAR 0 3
51276: PPUSH
51277: CALL_OW 257
51281: PUSH
51282: LD_INT 2
51284: PUSH
51285: LD_INT 16
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: IN
51292: NOT
51293: IFFALSE 51346
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
51295: LD_ADDR_EXP 117
51299: PUSH
51300: LD_EXP 117
51304: PPUSH
51305: LD_VAR 0 2
51309: PPUSH
51310: LD_EXP 117
51314: PUSH
51315: LD_VAR 0 2
51319: ARRAY
51320: PUSH
51321: LD_VAR 0 3
51325: DIFF
51326: PPUSH
51327: CALL_OW 1
51331: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51332: LD_VAR 0 3
51336: PPUSH
51337: LD_INT 0
51339: PPUSH
51340: CALL_OW 109
// continue ;
51344: GO 51241
// end ; if IsInUnit ( j ) then
51346: LD_VAR 0 3
51350: PPUSH
51351: CALL_OW 310
51355: IFFALSE 51366
// ComExitBuilding ( j ) ;
51357: LD_VAR 0 3
51361: PPUSH
51362: CALL_OW 122
// wait ( 3 ) ;
51366: LD_INT 3
51368: PPUSH
51369: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51373: LD_VAR 0 3
51377: PPUSH
51378: CALL_OW 314
51382: PUSH
51383: LD_VAR 0 6
51387: PPUSH
51388: LD_VAR 0 7
51392: PUSH
51393: LD_INT 2
51395: ARRAY
51396: PPUSH
51397: LD_VAR 0 7
51401: PUSH
51402: LD_INT 3
51404: ARRAY
51405: PPUSH
51406: LD_INT 30
51408: PPUSH
51409: CALL 73569 0 4
51413: PUSH
51414: LD_INT 4
51416: ARRAY
51417: AND
51418: IFFALSE 51436
// ComStandNearbyBuilding ( j , depot ) else
51420: LD_VAR 0 3
51424: PPUSH
51425: LD_VAR 0 9
51429: PPUSH
51430: CALL 69100 0 2
51434: GO 51463
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51436: LD_VAR 0 3
51440: PPUSH
51441: LD_VAR 0 7
51445: PUSH
51446: LD_INT 2
51448: ARRAY
51449: PPUSH
51450: LD_VAR 0 7
51454: PUSH
51455: LD_INT 3
51457: ARRAY
51458: PPUSH
51459: CALL_OW 117
// end ;
51463: GO 51241
51465: POP
51466: POP
// end ; end else
51467: GO 51999
// begin for j in cargo do
51469: LD_ADDR_VAR 0 3
51473: PUSH
51474: LD_VAR 0 8
51478: PUSH
51479: FOR_IN
51480: IFFALSE 51997
// begin if GetTag ( j ) <> 0 then
51482: LD_VAR 0 3
51486: PPUSH
51487: CALL_OW 110
51491: PUSH
51492: LD_INT 0
51494: NONEQUAL
51495: IFFALSE 51499
// continue ;
51497: GO 51479
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51499: LD_VAR 0 3
51503: PPUSH
51504: CALL_OW 256
51508: PUSH
51509: LD_INT 1000
51511: LESS
51512: PUSH
51513: LD_VAR 0 3
51517: PPUSH
51518: LD_EXP 124
51522: PUSH
51523: LD_VAR 0 2
51527: ARRAY
51528: PPUSH
51529: CALL_OW 308
51533: NOT
51534: AND
51535: IFFALSE 51557
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51537: LD_VAR 0 3
51541: PPUSH
51542: LD_EXP 124
51546: PUSH
51547: LD_VAR 0 2
51551: ARRAY
51552: PPUSH
51553: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51557: LD_VAR 0 3
51561: PPUSH
51562: CALL_OW 256
51566: PUSH
51567: LD_INT 1000
51569: LESS
51570: PUSH
51571: LD_VAR 0 3
51575: PPUSH
51576: LD_EXP 124
51580: PUSH
51581: LD_VAR 0 2
51585: ARRAY
51586: PPUSH
51587: CALL_OW 308
51591: AND
51592: IFFALSE 51596
// continue ;
51594: GO 51479
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
51596: LD_VAR 0 3
51600: PPUSH
51601: CALL_OW 262
51605: PUSH
51606: LD_INT 2
51608: EQUAL
51609: PUSH
51610: LD_VAR 0 3
51614: PPUSH
51615: CALL_OW 261
51619: PUSH
51620: LD_INT 15
51622: LESS
51623: AND
51624: IFFALSE 51628
// continue ;
51626: GO 51479
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
51628: LD_VAR 0 3
51632: PPUSH
51633: CALL_OW 262
51637: PUSH
51638: LD_INT 1
51640: EQUAL
51641: PUSH
51642: LD_VAR 0 3
51646: PPUSH
51647: CALL_OW 261
51651: PUSH
51652: LD_INT 10
51654: LESS
51655: AND
51656: IFFALSE 51936
// begin if not depot then
51658: LD_VAR 0 9
51662: NOT
51663: IFFALSE 51667
// continue ;
51665: GO 51479
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
51667: LD_VAR 0 3
51671: PPUSH
51672: LD_VAR 0 9
51676: PPUSH
51677: LD_VAR 0 3
51681: PPUSH
51682: CALL_OW 74
51686: PPUSH
51687: CALL_OW 296
51691: PUSH
51692: LD_INT 6
51694: LESS
51695: IFFALSE 51711
// SetFuel ( j , 100 ) else
51697: LD_VAR 0 3
51701: PPUSH
51702: LD_INT 100
51704: PPUSH
51705: CALL_OW 240
51709: GO 51936
// if GetFuel ( j ) = 0 then
51711: LD_VAR 0 3
51715: PPUSH
51716: CALL_OW 261
51720: PUSH
51721: LD_INT 0
51723: EQUAL
51724: IFFALSE 51936
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
51726: LD_ADDR_EXP 119
51730: PUSH
51731: LD_EXP 119
51735: PPUSH
51736: LD_VAR 0 2
51740: PPUSH
51741: LD_EXP 119
51745: PUSH
51746: LD_VAR 0 2
51750: ARRAY
51751: PUSH
51752: LD_VAR 0 3
51756: DIFF
51757: PPUSH
51758: CALL_OW 1
51762: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
51763: LD_VAR 0 3
51767: PPUSH
51768: CALL_OW 263
51772: PUSH
51773: LD_INT 1
51775: EQUAL
51776: IFFALSE 51792
// ComExitVehicle ( IsInUnit ( j ) ) ;
51778: LD_VAR 0 3
51782: PPUSH
51783: CALL_OW 310
51787: PPUSH
51788: CALL_OW 121
// if GetControl ( j ) = control_remote then
51792: LD_VAR 0 3
51796: PPUSH
51797: CALL_OW 263
51801: PUSH
51802: LD_INT 2
51804: EQUAL
51805: IFFALSE 51816
// ComUnlink ( j ) ;
51807: LD_VAR 0 3
51811: PPUSH
51812: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
51816: LD_ADDR_VAR 0 10
51820: PUSH
51821: LD_VAR 0 2
51825: PPUSH
51826: LD_INT 3
51828: PPUSH
51829: CALL 61603 0 2
51833: ST_TO_ADDR
// if fac then
51834: LD_VAR 0 10
51838: IFFALSE 51934
// begin for k in fac do
51840: LD_ADDR_VAR 0 4
51844: PUSH
51845: LD_VAR 0 10
51849: PUSH
51850: FOR_IN
51851: IFFALSE 51932
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
51853: LD_ADDR_VAR 0 11
51857: PUSH
51858: LD_VAR 0 10
51862: PPUSH
51863: LD_VAR 0 3
51867: PPUSH
51868: CALL_OW 265
51872: PPUSH
51873: LD_VAR 0 3
51877: PPUSH
51878: CALL_OW 262
51882: PPUSH
51883: LD_VAR 0 3
51887: PPUSH
51888: CALL_OW 263
51892: PPUSH
51893: LD_VAR 0 3
51897: PPUSH
51898: CALL_OW 264
51902: PPUSH
51903: CALL 70171 0 5
51907: ST_TO_ADDR
// if components then
51908: LD_VAR 0 11
51912: IFFALSE 51930
// begin MC_InsertProduceList ( i , components ) ;
51914: LD_VAR 0 2
51918: PPUSH
51919: LD_VAR 0 11
51923: PPUSH
51924: CALL 61148 0 2
// break ;
51928: GO 51932
// end ; end ;
51930: GO 51850
51932: POP
51933: POP
// end ; continue ;
51934: GO 51479
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
51936: LD_VAR 0 3
51940: PPUSH
51941: LD_INT 1
51943: PPUSH
51944: CALL_OW 289
51948: PUSH
51949: LD_INT 100
51951: LESS
51952: PUSH
51953: LD_VAR 0 3
51957: PPUSH
51958: CALL_OW 314
51962: NOT
51963: AND
51964: IFFALSE 51993
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51966: LD_VAR 0 3
51970: PPUSH
51971: LD_VAR 0 7
51975: PUSH
51976: LD_INT 2
51978: ARRAY
51979: PPUSH
51980: LD_VAR 0 7
51984: PUSH
51985: LD_INT 3
51987: ARRAY
51988: PPUSH
51989: CALL_OW 117
// break ;
51993: GO 51997
// end ;
51995: GO 51479
51997: POP
51998: POP
// end ; end ;
51999: GO 50195
52001: POP
52002: POP
// end ;
52003: LD_VAR 0 1
52007: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
52008: LD_INT 0
52010: PPUSH
52011: PPUSH
52012: PPUSH
52013: PPUSH
// if not mc_bases then
52014: LD_EXP 100
52018: NOT
52019: IFFALSE 52023
// exit ;
52021: GO 52184
// for i = 1 to mc_bases do
52023: LD_ADDR_VAR 0 2
52027: PUSH
52028: DOUBLE
52029: LD_INT 1
52031: DEC
52032: ST_TO_ADDR
52033: LD_EXP 100
52037: PUSH
52038: FOR_TO
52039: IFFALSE 52182
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
52041: LD_ADDR_VAR 0 4
52045: PUSH
52046: LD_EXP 119
52050: PUSH
52051: LD_VAR 0 2
52055: ARRAY
52056: PUSH
52057: LD_EXP 122
52061: PUSH
52062: LD_VAR 0 2
52066: ARRAY
52067: UNION
52068: PPUSH
52069: LD_INT 33
52071: PUSH
52072: LD_INT 2
52074: PUSH
52075: EMPTY
52076: LIST
52077: LIST
52078: PPUSH
52079: CALL_OW 72
52083: ST_TO_ADDR
// if tmp then
52084: LD_VAR 0 4
52088: IFFALSE 52180
// for j in tmp do
52090: LD_ADDR_VAR 0 3
52094: PUSH
52095: LD_VAR 0 4
52099: PUSH
52100: FOR_IN
52101: IFFALSE 52178
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
52103: LD_VAR 0 3
52107: PPUSH
52108: CALL_OW 312
52112: NOT
52113: PUSH
52114: LD_VAR 0 3
52118: PPUSH
52119: CALL_OW 256
52123: PUSH
52124: LD_INT 250
52126: GREATEREQUAL
52127: AND
52128: IFFALSE 52141
// Connect ( j ) else
52130: LD_VAR 0 3
52134: PPUSH
52135: CALL 75642 0 1
52139: GO 52176
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
52141: LD_VAR 0 3
52145: PPUSH
52146: CALL_OW 256
52150: PUSH
52151: LD_INT 250
52153: LESS
52154: PUSH
52155: LD_VAR 0 3
52159: PPUSH
52160: CALL_OW 312
52164: AND
52165: IFFALSE 52176
// ComUnlink ( j ) ;
52167: LD_VAR 0 3
52171: PPUSH
52172: CALL_OW 136
52176: GO 52100
52178: POP
52179: POP
// end ;
52180: GO 52038
52182: POP
52183: POP
// end ;
52184: LD_VAR 0 1
52188: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
52189: LD_INT 0
52191: PPUSH
52192: PPUSH
52193: PPUSH
52194: PPUSH
52195: PPUSH
// if not mc_bases then
52196: LD_EXP 100
52200: NOT
52201: IFFALSE 52205
// exit ;
52203: GO 52650
// for i = 1 to mc_bases do
52205: LD_ADDR_VAR 0 2
52209: PUSH
52210: DOUBLE
52211: LD_INT 1
52213: DEC
52214: ST_TO_ADDR
52215: LD_EXP 100
52219: PUSH
52220: FOR_TO
52221: IFFALSE 52648
// begin if not mc_produce [ i ] then
52223: LD_EXP 121
52227: PUSH
52228: LD_VAR 0 2
52232: ARRAY
52233: NOT
52234: IFFALSE 52238
// continue ;
52236: GO 52220
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52238: LD_ADDR_VAR 0 5
52242: PUSH
52243: LD_EXP 100
52247: PUSH
52248: LD_VAR 0 2
52252: ARRAY
52253: PPUSH
52254: LD_INT 30
52256: PUSH
52257: LD_INT 3
52259: PUSH
52260: EMPTY
52261: LIST
52262: LIST
52263: PPUSH
52264: CALL_OW 72
52268: ST_TO_ADDR
// if not fac then
52269: LD_VAR 0 5
52273: NOT
52274: IFFALSE 52278
// continue ;
52276: GO 52220
// for j in fac do
52278: LD_ADDR_VAR 0 3
52282: PUSH
52283: LD_VAR 0 5
52287: PUSH
52288: FOR_IN
52289: IFFALSE 52644
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
52291: LD_VAR 0 3
52295: PPUSH
52296: CALL_OW 461
52300: PUSH
52301: LD_INT 2
52303: NONEQUAL
52304: PUSH
52305: LD_VAR 0 3
52309: PPUSH
52310: LD_INT 15
52312: PPUSH
52313: CALL 75270 0 2
52317: PUSH
52318: LD_INT 4
52320: ARRAY
52321: OR
52322: IFFALSE 52326
// continue ;
52324: GO 52288
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
52326: LD_VAR 0 3
52330: PPUSH
52331: LD_EXP 121
52335: PUSH
52336: LD_VAR 0 2
52340: ARRAY
52341: PUSH
52342: LD_INT 1
52344: ARRAY
52345: PUSH
52346: LD_INT 1
52348: ARRAY
52349: PPUSH
52350: LD_EXP 121
52354: PUSH
52355: LD_VAR 0 2
52359: ARRAY
52360: PUSH
52361: LD_INT 1
52363: ARRAY
52364: PUSH
52365: LD_INT 2
52367: ARRAY
52368: PPUSH
52369: LD_EXP 121
52373: PUSH
52374: LD_VAR 0 2
52378: ARRAY
52379: PUSH
52380: LD_INT 1
52382: ARRAY
52383: PUSH
52384: LD_INT 3
52386: ARRAY
52387: PPUSH
52388: LD_EXP 121
52392: PUSH
52393: LD_VAR 0 2
52397: ARRAY
52398: PUSH
52399: LD_INT 1
52401: ARRAY
52402: PUSH
52403: LD_INT 4
52405: ARRAY
52406: PPUSH
52407: CALL_OW 448
52411: PUSH
52412: LD_VAR 0 3
52416: PPUSH
52417: LD_EXP 121
52421: PUSH
52422: LD_VAR 0 2
52426: ARRAY
52427: PUSH
52428: LD_INT 1
52430: ARRAY
52431: PUSH
52432: LD_INT 1
52434: ARRAY
52435: PUSH
52436: LD_EXP 121
52440: PUSH
52441: LD_VAR 0 2
52445: ARRAY
52446: PUSH
52447: LD_INT 1
52449: ARRAY
52450: PUSH
52451: LD_INT 2
52453: ARRAY
52454: PUSH
52455: LD_EXP 121
52459: PUSH
52460: LD_VAR 0 2
52464: ARRAY
52465: PUSH
52466: LD_INT 1
52468: ARRAY
52469: PUSH
52470: LD_INT 3
52472: ARRAY
52473: PUSH
52474: LD_EXP 121
52478: PUSH
52479: LD_VAR 0 2
52483: ARRAY
52484: PUSH
52485: LD_INT 1
52487: ARRAY
52488: PUSH
52489: LD_INT 4
52491: ARRAY
52492: PUSH
52493: EMPTY
52494: LIST
52495: LIST
52496: LIST
52497: LIST
52498: PPUSH
52499: CALL 79037 0 2
52503: AND
52504: IFFALSE 52642
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52506: LD_VAR 0 3
52510: PPUSH
52511: LD_EXP 121
52515: PUSH
52516: LD_VAR 0 2
52520: ARRAY
52521: PUSH
52522: LD_INT 1
52524: ARRAY
52525: PUSH
52526: LD_INT 1
52528: ARRAY
52529: PPUSH
52530: LD_EXP 121
52534: PUSH
52535: LD_VAR 0 2
52539: ARRAY
52540: PUSH
52541: LD_INT 1
52543: ARRAY
52544: PUSH
52545: LD_INT 2
52547: ARRAY
52548: PPUSH
52549: LD_EXP 121
52553: PUSH
52554: LD_VAR 0 2
52558: ARRAY
52559: PUSH
52560: LD_INT 1
52562: ARRAY
52563: PUSH
52564: LD_INT 3
52566: ARRAY
52567: PPUSH
52568: LD_EXP 121
52572: PUSH
52573: LD_VAR 0 2
52577: ARRAY
52578: PUSH
52579: LD_INT 1
52581: ARRAY
52582: PUSH
52583: LD_INT 4
52585: ARRAY
52586: PPUSH
52587: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
52591: LD_ADDR_VAR 0 4
52595: PUSH
52596: LD_EXP 121
52600: PUSH
52601: LD_VAR 0 2
52605: ARRAY
52606: PPUSH
52607: LD_INT 1
52609: PPUSH
52610: CALL_OW 3
52614: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52615: LD_ADDR_EXP 121
52619: PUSH
52620: LD_EXP 121
52624: PPUSH
52625: LD_VAR 0 2
52629: PPUSH
52630: LD_VAR 0 4
52634: PPUSH
52635: CALL_OW 1
52639: ST_TO_ADDR
// break ;
52640: GO 52644
// end ; end ;
52642: GO 52288
52644: POP
52645: POP
// end ;
52646: GO 52220
52648: POP
52649: POP
// end ;
52650: LD_VAR 0 1
52654: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
52655: LD_INT 0
52657: PPUSH
52658: PPUSH
52659: PPUSH
// if not mc_bases then
52660: LD_EXP 100
52664: NOT
52665: IFFALSE 52669
// exit ;
52667: GO 52758
// for i = 1 to mc_bases do
52669: LD_ADDR_VAR 0 2
52673: PUSH
52674: DOUBLE
52675: LD_INT 1
52677: DEC
52678: ST_TO_ADDR
52679: LD_EXP 100
52683: PUSH
52684: FOR_TO
52685: IFFALSE 52756
// begin if mc_attack [ i ] then
52687: LD_EXP 120
52691: PUSH
52692: LD_VAR 0 2
52696: ARRAY
52697: IFFALSE 52754
// begin tmp := mc_attack [ i ] [ 1 ] ;
52699: LD_ADDR_VAR 0 3
52703: PUSH
52704: LD_EXP 120
52708: PUSH
52709: LD_VAR 0 2
52713: ARRAY
52714: PUSH
52715: LD_INT 1
52717: ARRAY
52718: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52719: LD_ADDR_EXP 120
52723: PUSH
52724: LD_EXP 120
52728: PPUSH
52729: LD_VAR 0 2
52733: PPUSH
52734: EMPTY
52735: PPUSH
52736: CALL_OW 1
52740: ST_TO_ADDR
// Attack ( tmp ) ;
52741: LD_VAR 0 3
52745: PPUSH
52746: CALL 129045 0 1
// exit ;
52750: POP
52751: POP
52752: GO 52758
// end ; end ;
52754: GO 52684
52756: POP
52757: POP
// end ;
52758: LD_VAR 0 1
52762: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
52763: LD_INT 0
52765: PPUSH
52766: PPUSH
52767: PPUSH
52768: PPUSH
52769: PPUSH
52770: PPUSH
52771: PPUSH
// if not mc_bases then
52772: LD_EXP 100
52776: NOT
52777: IFFALSE 52781
// exit ;
52779: GO 53638
// for i = 1 to mc_bases do
52781: LD_ADDR_VAR 0 2
52785: PUSH
52786: DOUBLE
52787: LD_INT 1
52789: DEC
52790: ST_TO_ADDR
52791: LD_EXP 100
52795: PUSH
52796: FOR_TO
52797: IFFALSE 53636
// begin if not mc_bases [ i ] then
52799: LD_EXP 100
52803: PUSH
52804: LD_VAR 0 2
52808: ARRAY
52809: NOT
52810: IFFALSE 52814
// continue ;
52812: GO 52796
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
52814: LD_ADDR_VAR 0 7
52818: PUSH
52819: LD_EXP 100
52823: PUSH
52824: LD_VAR 0 2
52828: ARRAY
52829: PUSH
52830: LD_INT 1
52832: ARRAY
52833: PPUSH
52834: CALL 69322 0 1
52838: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
52839: LD_ADDR_EXP 123
52843: PUSH
52844: LD_EXP 123
52848: PPUSH
52849: LD_VAR 0 2
52853: PPUSH
52854: LD_EXP 100
52858: PUSH
52859: LD_VAR 0 2
52863: ARRAY
52864: PUSH
52865: LD_INT 1
52867: ARRAY
52868: PPUSH
52869: CALL_OW 255
52873: PPUSH
52874: LD_EXP 125
52878: PUSH
52879: LD_VAR 0 2
52883: ARRAY
52884: PPUSH
52885: CALL 69287 0 2
52889: PPUSH
52890: CALL_OW 1
52894: ST_TO_ADDR
// if not mc_scan [ i ] then
52895: LD_EXP 123
52899: PUSH
52900: LD_VAR 0 2
52904: ARRAY
52905: NOT
52906: IFFALSE 53084
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52908: LD_ADDR_EXP 143
52912: PUSH
52913: LD_EXP 143
52917: PPUSH
52918: LD_VAR 0 2
52922: PPUSH
52923: LD_INT 0
52925: PPUSH
52926: CALL_OW 1
52930: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52931: LD_ADDR_VAR 0 4
52935: PUSH
52936: LD_EXP 100
52940: PUSH
52941: LD_VAR 0 2
52945: ARRAY
52946: PPUSH
52947: LD_INT 2
52949: PUSH
52950: LD_INT 25
52952: PUSH
52953: LD_INT 5
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: PUSH
52960: LD_INT 25
52962: PUSH
52963: LD_INT 8
52965: PUSH
52966: EMPTY
52967: LIST
52968: LIST
52969: PUSH
52970: LD_INT 25
52972: PUSH
52973: LD_INT 9
52975: PUSH
52976: EMPTY
52977: LIST
52978: LIST
52979: PUSH
52980: EMPTY
52981: LIST
52982: LIST
52983: LIST
52984: LIST
52985: PPUSH
52986: CALL_OW 72
52990: ST_TO_ADDR
// if not tmp then
52991: LD_VAR 0 4
52995: NOT
52996: IFFALSE 53000
// continue ;
52998: GO 52796
// for j in tmp do
53000: LD_ADDR_VAR 0 3
53004: PUSH
53005: LD_VAR 0 4
53009: PUSH
53010: FOR_IN
53011: IFFALSE 53082
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
53013: LD_VAR 0 3
53017: PPUSH
53018: CALL_OW 310
53022: PPUSH
53023: CALL_OW 266
53027: PUSH
53028: LD_INT 5
53030: EQUAL
53031: PUSH
53032: LD_VAR 0 3
53036: PPUSH
53037: CALL_OW 257
53041: PUSH
53042: LD_INT 1
53044: EQUAL
53045: AND
53046: PUSH
53047: LD_VAR 0 3
53051: PPUSH
53052: CALL_OW 459
53056: NOT
53057: AND
53058: PUSH
53059: LD_VAR 0 7
53063: AND
53064: IFFALSE 53080
// ComChangeProfession ( j , class ) ;
53066: LD_VAR 0 3
53070: PPUSH
53071: LD_VAR 0 7
53075: PPUSH
53076: CALL_OW 123
53080: GO 53010
53082: POP
53083: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
53084: LD_EXP 123
53088: PUSH
53089: LD_VAR 0 2
53093: ARRAY
53094: PUSH
53095: LD_EXP 143
53099: PUSH
53100: LD_VAR 0 2
53104: ARRAY
53105: NOT
53106: AND
53107: PUSH
53108: LD_EXP 122
53112: PUSH
53113: LD_VAR 0 2
53117: ARRAY
53118: NOT
53119: AND
53120: PUSH
53121: LD_EXP 100
53125: PUSH
53126: LD_VAR 0 2
53130: ARRAY
53131: PPUSH
53132: LD_INT 50
53134: PUSH
53135: EMPTY
53136: LIST
53137: PUSH
53138: LD_INT 2
53140: PUSH
53141: LD_INT 30
53143: PUSH
53144: LD_INT 32
53146: PUSH
53147: EMPTY
53148: LIST
53149: LIST
53150: PUSH
53151: LD_INT 30
53153: PUSH
53154: LD_INT 33
53156: PUSH
53157: EMPTY
53158: LIST
53159: LIST
53160: PUSH
53161: LD_INT 30
53163: PUSH
53164: LD_INT 4
53166: PUSH
53167: EMPTY
53168: LIST
53169: LIST
53170: PUSH
53171: LD_INT 30
53173: PUSH
53174: LD_INT 5
53176: PUSH
53177: EMPTY
53178: LIST
53179: LIST
53180: PUSH
53181: EMPTY
53182: LIST
53183: LIST
53184: LIST
53185: LIST
53186: LIST
53187: PUSH
53188: EMPTY
53189: LIST
53190: LIST
53191: PPUSH
53192: CALL_OW 72
53196: PUSH
53197: LD_INT 4
53199: LESS
53200: PUSH
53201: LD_EXP 100
53205: PUSH
53206: LD_VAR 0 2
53210: ARRAY
53211: PPUSH
53212: LD_INT 3
53214: PUSH
53215: LD_INT 24
53217: PUSH
53218: LD_INT 1000
53220: PUSH
53221: EMPTY
53222: LIST
53223: LIST
53224: PUSH
53225: EMPTY
53226: LIST
53227: LIST
53228: PUSH
53229: LD_INT 2
53231: PUSH
53232: LD_INT 30
53234: PUSH
53235: LD_INT 0
53237: PUSH
53238: EMPTY
53239: LIST
53240: LIST
53241: PUSH
53242: LD_INT 30
53244: PUSH
53245: LD_INT 1
53247: PUSH
53248: EMPTY
53249: LIST
53250: LIST
53251: PUSH
53252: EMPTY
53253: LIST
53254: LIST
53255: LIST
53256: PUSH
53257: EMPTY
53258: LIST
53259: LIST
53260: PPUSH
53261: CALL_OW 72
53265: OR
53266: AND
53267: IFFALSE 53518
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53269: LD_ADDR_EXP 143
53273: PUSH
53274: LD_EXP 143
53278: PPUSH
53279: LD_VAR 0 2
53283: PPUSH
53284: LD_INT 1
53286: PPUSH
53287: CALL_OW 1
53291: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53292: LD_ADDR_VAR 0 4
53296: PUSH
53297: LD_EXP 100
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: PPUSH
53308: LD_INT 2
53310: PUSH
53311: LD_INT 25
53313: PUSH
53314: LD_INT 1
53316: PUSH
53317: EMPTY
53318: LIST
53319: LIST
53320: PUSH
53321: LD_INT 25
53323: PUSH
53324: LD_INT 5
53326: PUSH
53327: EMPTY
53328: LIST
53329: LIST
53330: PUSH
53331: LD_INT 25
53333: PUSH
53334: LD_INT 8
53336: PUSH
53337: EMPTY
53338: LIST
53339: LIST
53340: PUSH
53341: LD_INT 25
53343: PUSH
53344: LD_INT 9
53346: PUSH
53347: EMPTY
53348: LIST
53349: LIST
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: LIST
53355: LIST
53356: LIST
53357: PPUSH
53358: CALL_OW 72
53362: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53363: LD_ADDR_VAR 0 4
53367: PUSH
53368: LD_VAR 0 4
53372: PUSH
53373: LD_VAR 0 4
53377: PPUSH
53378: LD_INT 18
53380: PPUSH
53381: CALL 102585 0 2
53385: DIFF
53386: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53387: LD_VAR 0 4
53391: NOT
53392: PUSH
53393: LD_EXP 100
53397: PUSH
53398: LD_VAR 0 2
53402: ARRAY
53403: PPUSH
53404: LD_INT 2
53406: PUSH
53407: LD_INT 30
53409: PUSH
53410: LD_INT 4
53412: PUSH
53413: EMPTY
53414: LIST
53415: LIST
53416: PUSH
53417: LD_INT 30
53419: PUSH
53420: LD_INT 5
53422: PUSH
53423: EMPTY
53424: LIST
53425: LIST
53426: PUSH
53427: EMPTY
53428: LIST
53429: LIST
53430: LIST
53431: PPUSH
53432: CALL_OW 72
53436: NOT
53437: AND
53438: IFFALSE 53500
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53440: LD_ADDR_VAR 0 4
53444: PUSH
53445: LD_EXP 100
53449: PUSH
53450: LD_VAR 0 2
53454: ARRAY
53455: PPUSH
53456: LD_INT 2
53458: PUSH
53459: LD_INT 25
53461: PUSH
53462: LD_INT 2
53464: PUSH
53465: EMPTY
53466: LIST
53467: LIST
53468: PUSH
53469: LD_INT 25
53471: PUSH
53472: LD_INT 3
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: PUSH
53479: LD_INT 25
53481: PUSH
53482: LD_INT 4
53484: PUSH
53485: EMPTY
53486: LIST
53487: LIST
53488: PUSH
53489: EMPTY
53490: LIST
53491: LIST
53492: LIST
53493: LIST
53494: PPUSH
53495: CALL_OW 72
53499: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53500: LD_VAR 0 2
53504: PPUSH
53505: LD_VAR 0 4
53509: PPUSH
53510: CALL 133754 0 2
// exit ;
53514: POP
53515: POP
53516: GO 53638
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53518: LD_EXP 123
53522: PUSH
53523: LD_VAR 0 2
53527: ARRAY
53528: PUSH
53529: LD_EXP 143
53533: PUSH
53534: LD_VAR 0 2
53538: ARRAY
53539: NOT
53540: AND
53541: PUSH
53542: LD_EXP 122
53546: PUSH
53547: LD_VAR 0 2
53551: ARRAY
53552: AND
53553: IFFALSE 53634
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53555: LD_ADDR_EXP 143
53559: PUSH
53560: LD_EXP 143
53564: PPUSH
53565: LD_VAR 0 2
53569: PPUSH
53570: LD_INT 1
53572: PPUSH
53573: CALL_OW 1
53577: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
53578: LD_ADDR_VAR 0 4
53582: PUSH
53583: LD_EXP 122
53587: PUSH
53588: LD_VAR 0 2
53592: ARRAY
53593: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53594: LD_ADDR_EXP 122
53598: PUSH
53599: LD_EXP 122
53603: PPUSH
53604: LD_VAR 0 2
53608: PPUSH
53609: EMPTY
53610: PPUSH
53611: CALL_OW 1
53615: ST_TO_ADDR
// Defend ( i , tmp ) ;
53616: LD_VAR 0 2
53620: PPUSH
53621: LD_VAR 0 4
53625: PPUSH
53626: CALL 134350 0 2
// exit ;
53630: POP
53631: POP
53632: GO 53638
// end ; end ;
53634: GO 52796
53636: POP
53637: POP
// end ;
53638: LD_VAR 0 1
53642: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
53643: LD_INT 0
53645: PPUSH
53646: PPUSH
53647: PPUSH
53648: PPUSH
53649: PPUSH
53650: PPUSH
53651: PPUSH
53652: PPUSH
53653: PPUSH
53654: PPUSH
53655: PPUSH
// if not mc_bases then
53656: LD_EXP 100
53660: NOT
53661: IFFALSE 53665
// exit ;
53663: GO 54752
// for i = 1 to mc_bases do
53665: LD_ADDR_VAR 0 2
53669: PUSH
53670: DOUBLE
53671: LD_INT 1
53673: DEC
53674: ST_TO_ADDR
53675: LD_EXP 100
53679: PUSH
53680: FOR_TO
53681: IFFALSE 54750
// begin tmp := mc_lab [ i ] ;
53683: LD_ADDR_VAR 0 6
53687: PUSH
53688: LD_EXP 133
53692: PUSH
53693: LD_VAR 0 2
53697: ARRAY
53698: ST_TO_ADDR
// if not tmp then
53699: LD_VAR 0 6
53703: NOT
53704: IFFALSE 53708
// continue ;
53706: GO 53680
// idle_lab := 0 ;
53708: LD_ADDR_VAR 0 11
53712: PUSH
53713: LD_INT 0
53715: ST_TO_ADDR
// for j in tmp do
53716: LD_ADDR_VAR 0 3
53720: PUSH
53721: LD_VAR 0 6
53725: PUSH
53726: FOR_IN
53727: IFFALSE 54746
// begin researching := false ;
53729: LD_ADDR_VAR 0 10
53733: PUSH
53734: LD_INT 0
53736: ST_TO_ADDR
// side := GetSide ( j ) ;
53737: LD_ADDR_VAR 0 4
53741: PUSH
53742: LD_VAR 0 3
53746: PPUSH
53747: CALL_OW 255
53751: ST_TO_ADDR
// if not mc_tech [ side ] then
53752: LD_EXP 127
53756: PUSH
53757: LD_VAR 0 4
53761: ARRAY
53762: NOT
53763: IFFALSE 53767
// continue ;
53765: GO 53726
// if BuildingStatus ( j ) = bs_idle then
53767: LD_VAR 0 3
53771: PPUSH
53772: CALL_OW 461
53776: PUSH
53777: LD_INT 2
53779: EQUAL
53780: IFFALSE 53968
// begin if idle_lab and UnitsInside ( j ) < 6 then
53782: LD_VAR 0 11
53786: PUSH
53787: LD_VAR 0 3
53791: PPUSH
53792: CALL_OW 313
53796: PUSH
53797: LD_INT 6
53799: LESS
53800: AND
53801: IFFALSE 53872
// begin tmp2 := UnitsInside ( idle_lab ) ;
53803: LD_ADDR_VAR 0 9
53807: PUSH
53808: LD_VAR 0 11
53812: PPUSH
53813: CALL_OW 313
53817: ST_TO_ADDR
// if tmp2 then
53818: LD_VAR 0 9
53822: IFFALSE 53864
// for x in tmp2 do
53824: LD_ADDR_VAR 0 7
53828: PUSH
53829: LD_VAR 0 9
53833: PUSH
53834: FOR_IN
53835: IFFALSE 53862
// begin ComExitBuilding ( x ) ;
53837: LD_VAR 0 7
53841: PPUSH
53842: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53846: LD_VAR 0 7
53850: PPUSH
53851: LD_VAR 0 3
53855: PPUSH
53856: CALL_OW 180
// end ;
53860: GO 53834
53862: POP
53863: POP
// idle_lab := 0 ;
53864: LD_ADDR_VAR 0 11
53868: PUSH
53869: LD_INT 0
53871: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
53872: LD_ADDR_VAR 0 5
53876: PUSH
53877: LD_EXP 127
53881: PUSH
53882: LD_VAR 0 4
53886: ARRAY
53887: PUSH
53888: FOR_IN
53889: IFFALSE 53949
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
53891: LD_VAR 0 3
53895: PPUSH
53896: LD_VAR 0 5
53900: PPUSH
53901: CALL_OW 430
53905: PUSH
53906: LD_VAR 0 4
53910: PPUSH
53911: LD_VAR 0 5
53915: PPUSH
53916: CALL 68392 0 2
53920: AND
53921: IFFALSE 53947
// begin researching := true ;
53923: LD_ADDR_VAR 0 10
53927: PUSH
53928: LD_INT 1
53930: ST_TO_ADDR
// ComResearch ( j , t ) ;
53931: LD_VAR 0 3
53935: PPUSH
53936: LD_VAR 0 5
53940: PPUSH
53941: CALL_OW 124
// break ;
53945: GO 53949
// end ;
53947: GO 53888
53949: POP
53950: POP
// if not researching then
53951: LD_VAR 0 10
53955: NOT
53956: IFFALSE 53968
// idle_lab := j ;
53958: LD_ADDR_VAR 0 11
53962: PUSH
53963: LD_VAR 0 3
53967: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
53968: LD_VAR 0 3
53972: PPUSH
53973: CALL_OW 461
53977: PUSH
53978: LD_INT 10
53980: EQUAL
53981: IFFALSE 54569
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
53983: LD_EXP 129
53987: PUSH
53988: LD_VAR 0 2
53992: ARRAY
53993: NOT
53994: PUSH
53995: LD_EXP 130
53999: PUSH
54000: LD_VAR 0 2
54004: ARRAY
54005: NOT
54006: AND
54007: PUSH
54008: LD_EXP 127
54012: PUSH
54013: LD_VAR 0 4
54017: ARRAY
54018: PUSH
54019: LD_INT 1
54021: GREATER
54022: AND
54023: IFFALSE 54154
// begin ComCancel ( j ) ;
54025: LD_VAR 0 3
54029: PPUSH
54030: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
54034: LD_ADDR_EXP 127
54038: PUSH
54039: LD_EXP 127
54043: PPUSH
54044: LD_VAR 0 4
54048: PPUSH
54049: LD_EXP 127
54053: PUSH
54054: LD_VAR 0 4
54058: ARRAY
54059: PPUSH
54060: LD_EXP 127
54064: PUSH
54065: LD_VAR 0 4
54069: ARRAY
54070: PUSH
54071: LD_INT 1
54073: MINUS
54074: PPUSH
54075: LD_EXP 127
54079: PUSH
54080: LD_VAR 0 4
54084: ARRAY
54085: PPUSH
54086: LD_INT 0
54088: PPUSH
54089: CALL 72091 0 4
54093: PPUSH
54094: CALL_OW 1
54098: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
54099: LD_ADDR_EXP 127
54103: PUSH
54104: LD_EXP 127
54108: PPUSH
54109: LD_VAR 0 4
54113: PPUSH
54114: LD_EXP 127
54118: PUSH
54119: LD_VAR 0 4
54123: ARRAY
54124: PPUSH
54125: LD_EXP 127
54129: PUSH
54130: LD_VAR 0 4
54134: ARRAY
54135: PPUSH
54136: LD_INT 1
54138: PPUSH
54139: LD_INT 0
54141: PPUSH
54142: CALL 72091 0 4
54146: PPUSH
54147: CALL_OW 1
54151: ST_TO_ADDR
// continue ;
54152: GO 53726
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
54154: LD_EXP 129
54158: PUSH
54159: LD_VAR 0 2
54163: ARRAY
54164: PUSH
54165: LD_EXP 130
54169: PUSH
54170: LD_VAR 0 2
54174: ARRAY
54175: NOT
54176: AND
54177: IFFALSE 54304
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
54179: LD_ADDR_EXP 130
54183: PUSH
54184: LD_EXP 130
54188: PPUSH
54189: LD_VAR 0 2
54193: PUSH
54194: LD_EXP 130
54198: PUSH
54199: LD_VAR 0 2
54203: ARRAY
54204: PUSH
54205: LD_INT 1
54207: PLUS
54208: PUSH
54209: EMPTY
54210: LIST
54211: LIST
54212: PPUSH
54213: LD_EXP 129
54217: PUSH
54218: LD_VAR 0 2
54222: ARRAY
54223: PUSH
54224: LD_INT 1
54226: ARRAY
54227: PPUSH
54228: CALL 72673 0 3
54232: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
54233: LD_EXP 129
54237: PUSH
54238: LD_VAR 0 2
54242: ARRAY
54243: PUSH
54244: LD_INT 1
54246: ARRAY
54247: PPUSH
54248: LD_INT 112
54250: PPUSH
54251: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
54255: LD_ADDR_VAR 0 9
54259: PUSH
54260: LD_EXP 129
54264: PUSH
54265: LD_VAR 0 2
54269: ARRAY
54270: PPUSH
54271: LD_INT 1
54273: PPUSH
54274: CALL_OW 3
54278: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
54279: LD_ADDR_EXP 129
54283: PUSH
54284: LD_EXP 129
54288: PPUSH
54289: LD_VAR 0 2
54293: PPUSH
54294: LD_VAR 0 9
54298: PPUSH
54299: CALL_OW 1
54303: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
54304: LD_EXP 129
54308: PUSH
54309: LD_VAR 0 2
54313: ARRAY
54314: PUSH
54315: LD_EXP 130
54319: PUSH
54320: LD_VAR 0 2
54324: ARRAY
54325: AND
54326: PUSH
54327: LD_EXP 130
54331: PUSH
54332: LD_VAR 0 2
54336: ARRAY
54337: PUSH
54338: LD_INT 1
54340: ARRAY
54341: PPUSH
54342: CALL_OW 310
54346: NOT
54347: AND
54348: PUSH
54349: LD_VAR 0 3
54353: PPUSH
54354: CALL_OW 313
54358: PUSH
54359: LD_INT 6
54361: EQUAL
54362: AND
54363: IFFALSE 54419
// begin tmp2 := UnitsInside ( j ) ;
54365: LD_ADDR_VAR 0 9
54369: PUSH
54370: LD_VAR 0 3
54374: PPUSH
54375: CALL_OW 313
54379: ST_TO_ADDR
// if tmp2 = 6 then
54380: LD_VAR 0 9
54384: PUSH
54385: LD_INT 6
54387: EQUAL
54388: IFFALSE 54419
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54390: LD_VAR 0 9
54394: PUSH
54395: LD_INT 1
54397: ARRAY
54398: PPUSH
54399: LD_INT 112
54401: PPUSH
54402: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54406: LD_VAR 0 9
54410: PUSH
54411: LD_INT 1
54413: ARRAY
54414: PPUSH
54415: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54419: LD_EXP 130
54423: PUSH
54424: LD_VAR 0 2
54428: ARRAY
54429: PUSH
54430: LD_EXP 130
54434: PUSH
54435: LD_VAR 0 2
54439: ARRAY
54440: PUSH
54441: LD_INT 1
54443: ARRAY
54444: PPUSH
54445: CALL_OW 314
54449: NOT
54450: AND
54451: PUSH
54452: LD_EXP 130
54456: PUSH
54457: LD_VAR 0 2
54461: ARRAY
54462: PUSH
54463: LD_INT 1
54465: ARRAY
54466: PPUSH
54467: CALL_OW 310
54471: NOT
54472: AND
54473: IFFALSE 54499
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54475: LD_EXP 130
54479: PUSH
54480: LD_VAR 0 2
54484: ARRAY
54485: PUSH
54486: LD_INT 1
54488: ARRAY
54489: PPUSH
54490: LD_VAR 0 3
54494: PPUSH
54495: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54499: LD_EXP 130
54503: PUSH
54504: LD_VAR 0 2
54508: ARRAY
54509: PUSH
54510: LD_INT 1
54512: ARRAY
54513: PPUSH
54514: CALL_OW 310
54518: PUSH
54519: LD_EXP 130
54523: PUSH
54524: LD_VAR 0 2
54528: ARRAY
54529: PUSH
54530: LD_INT 1
54532: ARRAY
54533: PPUSH
54534: CALL_OW 310
54538: PPUSH
54539: CALL_OW 461
54543: PUSH
54544: LD_INT 3
54546: NONEQUAL
54547: AND
54548: IFFALSE 54569
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54550: LD_EXP 130
54554: PUSH
54555: LD_VAR 0 2
54559: ARRAY
54560: PUSH
54561: LD_INT 1
54563: ARRAY
54564: PPUSH
54565: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54569: LD_VAR 0 3
54573: PPUSH
54574: CALL_OW 461
54578: PUSH
54579: LD_INT 6
54581: EQUAL
54582: PUSH
54583: LD_VAR 0 6
54587: PUSH
54588: LD_INT 1
54590: GREATER
54591: AND
54592: IFFALSE 54744
// begin sci := [ ] ;
54594: LD_ADDR_VAR 0 8
54598: PUSH
54599: EMPTY
54600: ST_TO_ADDR
// for x in ( tmp diff j ) do
54601: LD_ADDR_VAR 0 7
54605: PUSH
54606: LD_VAR 0 6
54610: PUSH
54611: LD_VAR 0 3
54615: DIFF
54616: PUSH
54617: FOR_IN
54618: IFFALSE 54670
// begin if sci = 6 then
54620: LD_VAR 0 8
54624: PUSH
54625: LD_INT 6
54627: EQUAL
54628: IFFALSE 54632
// break ;
54630: GO 54670
// if BuildingStatus ( x ) = bs_idle then
54632: LD_VAR 0 7
54636: PPUSH
54637: CALL_OW 461
54641: PUSH
54642: LD_INT 2
54644: EQUAL
54645: IFFALSE 54668
// sci := sci ^ UnitsInside ( x ) ;
54647: LD_ADDR_VAR 0 8
54651: PUSH
54652: LD_VAR 0 8
54656: PUSH
54657: LD_VAR 0 7
54661: PPUSH
54662: CALL_OW 313
54666: ADD
54667: ST_TO_ADDR
// end ;
54668: GO 54617
54670: POP
54671: POP
// if not sci then
54672: LD_VAR 0 8
54676: NOT
54677: IFFALSE 54681
// continue ;
54679: GO 53726
// for x in sci do
54681: LD_ADDR_VAR 0 7
54685: PUSH
54686: LD_VAR 0 8
54690: PUSH
54691: FOR_IN
54692: IFFALSE 54742
// if IsInUnit ( x ) and not HasTask ( x ) then
54694: LD_VAR 0 7
54698: PPUSH
54699: CALL_OW 310
54703: PUSH
54704: LD_VAR 0 7
54708: PPUSH
54709: CALL_OW 314
54713: NOT
54714: AND
54715: IFFALSE 54740
// begin ComExitBuilding ( x ) ;
54717: LD_VAR 0 7
54721: PPUSH
54722: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54726: LD_VAR 0 7
54730: PPUSH
54731: LD_VAR 0 3
54735: PPUSH
54736: CALL_OW 180
// end ;
54740: GO 54691
54742: POP
54743: POP
// end ; end ;
54744: GO 53726
54746: POP
54747: POP
// end ;
54748: GO 53680
54750: POP
54751: POP
// end ;
54752: LD_VAR 0 1
54756: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
54757: LD_INT 0
54759: PPUSH
54760: PPUSH
// if not mc_bases then
54761: LD_EXP 100
54765: NOT
54766: IFFALSE 54770
// exit ;
54768: GO 54851
// for i = 1 to mc_bases do
54770: LD_ADDR_VAR 0 2
54774: PUSH
54775: DOUBLE
54776: LD_INT 1
54778: DEC
54779: ST_TO_ADDR
54780: LD_EXP 100
54784: PUSH
54785: FOR_TO
54786: IFFALSE 54849
// if mc_mines [ i ] and mc_miners [ i ] then
54788: LD_EXP 113
54792: PUSH
54793: LD_VAR 0 2
54797: ARRAY
54798: PUSH
54799: LD_EXP 114
54803: PUSH
54804: LD_VAR 0 2
54808: ARRAY
54809: AND
54810: IFFALSE 54847
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
54812: LD_EXP 114
54816: PUSH
54817: LD_VAR 0 2
54821: ARRAY
54822: PUSH
54823: LD_INT 1
54825: ARRAY
54826: PPUSH
54827: CALL_OW 255
54831: PPUSH
54832: LD_EXP 113
54836: PUSH
54837: LD_VAR 0 2
54841: ARRAY
54842: PPUSH
54843: CALL 69475 0 2
54847: GO 54785
54849: POP
54850: POP
// end ;
54851: LD_VAR 0 1
54855: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
54856: LD_INT 0
54858: PPUSH
54859: PPUSH
54860: PPUSH
54861: PPUSH
54862: PPUSH
54863: PPUSH
54864: PPUSH
54865: PPUSH
// if not mc_bases or not mc_parking then
54866: LD_EXP 100
54870: NOT
54871: PUSH
54872: LD_EXP 124
54876: NOT
54877: OR
54878: IFFALSE 54882
// exit ;
54880: GO 55620
// for i = 1 to mc_bases do
54882: LD_ADDR_VAR 0 2
54886: PUSH
54887: DOUBLE
54888: LD_INT 1
54890: DEC
54891: ST_TO_ADDR
54892: LD_EXP 100
54896: PUSH
54897: FOR_TO
54898: IFFALSE 55618
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
54900: LD_EXP 100
54904: PUSH
54905: LD_VAR 0 2
54909: ARRAY
54910: NOT
54911: PUSH
54912: LD_EXP 124
54916: PUSH
54917: LD_VAR 0 2
54921: ARRAY
54922: NOT
54923: OR
54924: IFFALSE 54928
// continue ;
54926: GO 54897
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
54928: LD_ADDR_VAR 0 5
54932: PUSH
54933: LD_EXP 100
54937: PUSH
54938: LD_VAR 0 2
54942: ARRAY
54943: PUSH
54944: LD_INT 1
54946: ARRAY
54947: PPUSH
54948: CALL_OW 255
54952: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54953: LD_ADDR_VAR 0 6
54957: PUSH
54958: LD_EXP 100
54962: PUSH
54963: LD_VAR 0 2
54967: ARRAY
54968: PPUSH
54969: LD_INT 30
54971: PUSH
54972: LD_INT 3
54974: PUSH
54975: EMPTY
54976: LIST
54977: LIST
54978: PPUSH
54979: CALL_OW 72
54983: ST_TO_ADDR
// if not fac then
54984: LD_VAR 0 6
54988: NOT
54989: IFFALSE 55040
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54991: LD_ADDR_VAR 0 6
54995: PUSH
54996: LD_EXP 100
55000: PUSH
55001: LD_VAR 0 2
55005: ARRAY
55006: PPUSH
55007: LD_INT 2
55009: PUSH
55010: LD_INT 30
55012: PUSH
55013: LD_INT 0
55015: PUSH
55016: EMPTY
55017: LIST
55018: LIST
55019: PUSH
55020: LD_INT 30
55022: PUSH
55023: LD_INT 1
55025: PUSH
55026: EMPTY
55027: LIST
55028: LIST
55029: PUSH
55030: EMPTY
55031: LIST
55032: LIST
55033: LIST
55034: PPUSH
55035: CALL_OW 72
55039: ST_TO_ADDR
// if not fac then
55040: LD_VAR 0 6
55044: NOT
55045: IFFALSE 55049
// continue ;
55047: GO 54897
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55049: LD_ADDR_VAR 0 7
55053: PUSH
55054: LD_EXP 124
55058: PUSH
55059: LD_VAR 0 2
55063: ARRAY
55064: PPUSH
55065: LD_INT 22
55067: PUSH
55068: LD_VAR 0 5
55072: PUSH
55073: EMPTY
55074: LIST
55075: LIST
55076: PUSH
55077: LD_INT 21
55079: PUSH
55080: LD_INT 2
55082: PUSH
55083: EMPTY
55084: LIST
55085: LIST
55086: PUSH
55087: LD_INT 3
55089: PUSH
55090: LD_INT 60
55092: PUSH
55093: EMPTY
55094: LIST
55095: PUSH
55096: EMPTY
55097: LIST
55098: LIST
55099: PUSH
55100: LD_INT 3
55102: PUSH
55103: LD_INT 24
55105: PUSH
55106: LD_INT 1000
55108: PUSH
55109: EMPTY
55110: LIST
55111: LIST
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: LIST
55121: LIST
55122: PPUSH
55123: CALL_OW 70
55127: ST_TO_ADDR
// for j in fac do
55128: LD_ADDR_VAR 0 3
55132: PUSH
55133: LD_VAR 0 6
55137: PUSH
55138: FOR_IN
55139: IFFALSE 55234
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55141: LD_ADDR_VAR 0 7
55145: PUSH
55146: LD_VAR 0 7
55150: PUSH
55151: LD_INT 22
55153: PUSH
55154: LD_VAR 0 5
55158: PUSH
55159: EMPTY
55160: LIST
55161: LIST
55162: PUSH
55163: LD_INT 91
55165: PUSH
55166: LD_VAR 0 3
55170: PUSH
55171: LD_INT 15
55173: PUSH
55174: EMPTY
55175: LIST
55176: LIST
55177: LIST
55178: PUSH
55179: LD_INT 21
55181: PUSH
55182: LD_INT 2
55184: PUSH
55185: EMPTY
55186: LIST
55187: LIST
55188: PUSH
55189: LD_INT 3
55191: PUSH
55192: LD_INT 60
55194: PUSH
55195: EMPTY
55196: LIST
55197: PUSH
55198: EMPTY
55199: LIST
55200: LIST
55201: PUSH
55202: LD_INT 3
55204: PUSH
55205: LD_INT 24
55207: PUSH
55208: LD_INT 1000
55210: PUSH
55211: EMPTY
55212: LIST
55213: LIST
55214: PUSH
55215: EMPTY
55216: LIST
55217: LIST
55218: PUSH
55219: EMPTY
55220: LIST
55221: LIST
55222: LIST
55223: LIST
55224: LIST
55225: PPUSH
55226: CALL_OW 69
55230: UNION
55231: ST_TO_ADDR
55232: GO 55138
55234: POP
55235: POP
// if not vehs then
55236: LD_VAR 0 7
55240: NOT
55241: IFFALSE 55267
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55243: LD_ADDR_EXP 112
55247: PUSH
55248: LD_EXP 112
55252: PPUSH
55253: LD_VAR 0 2
55257: PPUSH
55258: EMPTY
55259: PPUSH
55260: CALL_OW 1
55264: ST_TO_ADDR
// continue ;
55265: GO 54897
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55267: LD_ADDR_VAR 0 8
55271: PUSH
55272: LD_EXP 100
55276: PUSH
55277: LD_VAR 0 2
55281: ARRAY
55282: PPUSH
55283: LD_INT 30
55285: PUSH
55286: LD_INT 3
55288: PUSH
55289: EMPTY
55290: LIST
55291: LIST
55292: PPUSH
55293: CALL_OW 72
55297: ST_TO_ADDR
// if tmp then
55298: LD_VAR 0 8
55302: IFFALSE 55405
// begin for j in tmp do
55304: LD_ADDR_VAR 0 3
55308: PUSH
55309: LD_VAR 0 8
55313: PUSH
55314: FOR_IN
55315: IFFALSE 55403
// for k in UnitsInside ( j ) do
55317: LD_ADDR_VAR 0 4
55321: PUSH
55322: LD_VAR 0 3
55326: PPUSH
55327: CALL_OW 313
55331: PUSH
55332: FOR_IN
55333: IFFALSE 55399
// if k then
55335: LD_VAR 0 4
55339: IFFALSE 55397
// if not k in mc_repair_vehicle [ i ] then
55341: LD_VAR 0 4
55345: PUSH
55346: LD_EXP 112
55350: PUSH
55351: LD_VAR 0 2
55355: ARRAY
55356: IN
55357: NOT
55358: IFFALSE 55397
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55360: LD_ADDR_EXP 112
55364: PUSH
55365: LD_EXP 112
55369: PPUSH
55370: LD_VAR 0 2
55374: PPUSH
55375: LD_EXP 112
55379: PUSH
55380: LD_VAR 0 2
55384: ARRAY
55385: PUSH
55386: LD_VAR 0 4
55390: UNION
55391: PPUSH
55392: CALL_OW 1
55396: ST_TO_ADDR
55397: GO 55332
55399: POP
55400: POP
55401: GO 55314
55403: POP
55404: POP
// end ; if not mc_repair_vehicle [ i ] then
55405: LD_EXP 112
55409: PUSH
55410: LD_VAR 0 2
55414: ARRAY
55415: NOT
55416: IFFALSE 55420
// continue ;
55418: GO 54897
// for j in mc_repair_vehicle [ i ] do
55420: LD_ADDR_VAR 0 3
55424: PUSH
55425: LD_EXP 112
55429: PUSH
55430: LD_VAR 0 2
55434: ARRAY
55435: PUSH
55436: FOR_IN
55437: IFFALSE 55614
// begin if GetClass ( j ) <> 3 then
55439: LD_VAR 0 3
55443: PPUSH
55444: CALL_OW 257
55448: PUSH
55449: LD_INT 3
55451: NONEQUAL
55452: IFFALSE 55493
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55454: LD_ADDR_EXP 112
55458: PUSH
55459: LD_EXP 112
55463: PPUSH
55464: LD_VAR 0 2
55468: PPUSH
55469: LD_EXP 112
55473: PUSH
55474: LD_VAR 0 2
55478: ARRAY
55479: PUSH
55480: LD_VAR 0 3
55484: DIFF
55485: PPUSH
55486: CALL_OW 1
55490: ST_TO_ADDR
// continue ;
55491: GO 55436
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55493: LD_VAR 0 3
55497: PPUSH
55498: CALL_OW 311
55502: NOT
55503: PUSH
55504: LD_VAR 0 3
55508: PUSH
55509: LD_EXP 103
55513: PUSH
55514: LD_VAR 0 2
55518: ARRAY
55519: PUSH
55520: LD_INT 1
55522: ARRAY
55523: IN
55524: NOT
55525: AND
55526: PUSH
55527: LD_VAR 0 3
55531: PUSH
55532: LD_EXP 103
55536: PUSH
55537: LD_VAR 0 2
55541: ARRAY
55542: PUSH
55543: LD_INT 2
55545: ARRAY
55546: IN
55547: NOT
55548: AND
55549: IFFALSE 55612
// begin if IsInUnit ( j ) then
55551: LD_VAR 0 3
55555: PPUSH
55556: CALL_OW 310
55560: IFFALSE 55573
// ComExitBuilding ( j ) else
55562: LD_VAR 0 3
55566: PPUSH
55567: CALL_OW 122
55571: GO 55612
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55573: LD_VAR 0 3
55577: PPUSH
55578: LD_VAR 0 7
55582: PUSH
55583: LD_INT 1
55585: ARRAY
55586: PPUSH
55587: CALL 107069 0 2
55591: NOT
55592: IFFALSE 55612
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
55594: LD_VAR 0 3
55598: PPUSH
55599: LD_VAR 0 7
55603: PUSH
55604: LD_INT 1
55606: ARRAY
55607: PPUSH
55608: CALL_OW 129
// end ; end ;
55612: GO 55436
55614: POP
55615: POP
// end ;
55616: GO 54897
55618: POP
55619: POP
// end ;
55620: LD_VAR 0 1
55624: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
55625: LD_INT 0
55627: PPUSH
55628: PPUSH
55629: PPUSH
55630: PPUSH
55631: PPUSH
55632: PPUSH
55633: PPUSH
55634: PPUSH
55635: PPUSH
55636: PPUSH
55637: PPUSH
// if not mc_bases then
55638: LD_EXP 100
55642: NOT
55643: IFFALSE 55647
// exit ;
55645: GO 56449
// for i = 1 to mc_bases do
55647: LD_ADDR_VAR 0 2
55651: PUSH
55652: DOUBLE
55653: LD_INT 1
55655: DEC
55656: ST_TO_ADDR
55657: LD_EXP 100
55661: PUSH
55662: FOR_TO
55663: IFFALSE 56447
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
55665: LD_EXP 128
55669: PUSH
55670: LD_VAR 0 2
55674: ARRAY
55675: NOT
55676: PUSH
55677: LD_EXP 103
55681: PUSH
55682: LD_VAR 0 2
55686: ARRAY
55687: PUSH
55688: LD_INT 1
55690: ARRAY
55691: OR
55692: PUSH
55693: LD_EXP 103
55697: PUSH
55698: LD_VAR 0 2
55702: ARRAY
55703: PUSH
55704: LD_INT 2
55706: ARRAY
55707: OR
55708: PUSH
55709: LD_EXP 126
55713: PUSH
55714: LD_VAR 0 2
55718: ARRAY
55719: PPUSH
55720: LD_INT 1
55722: PPUSH
55723: CALL_OW 325
55727: NOT
55728: OR
55729: PUSH
55730: LD_EXP 123
55734: PUSH
55735: LD_VAR 0 2
55739: ARRAY
55740: OR
55741: IFFALSE 55745
// continue ;
55743: GO 55662
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
55745: LD_ADDR_VAR 0 8
55749: PUSH
55750: LD_EXP 100
55754: PUSH
55755: LD_VAR 0 2
55759: ARRAY
55760: PPUSH
55761: LD_INT 25
55763: PUSH
55764: LD_INT 4
55766: PUSH
55767: EMPTY
55768: LIST
55769: LIST
55770: PUSH
55771: LD_INT 50
55773: PUSH
55774: EMPTY
55775: LIST
55776: PUSH
55777: LD_INT 3
55779: PUSH
55780: LD_INT 60
55782: PUSH
55783: EMPTY
55784: LIST
55785: PUSH
55786: EMPTY
55787: LIST
55788: LIST
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: PPUSH
55795: CALL_OW 72
55799: PUSH
55800: LD_EXP 104
55804: PUSH
55805: LD_VAR 0 2
55809: ARRAY
55810: DIFF
55811: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55812: LD_ADDR_VAR 0 9
55816: PUSH
55817: LD_EXP 100
55821: PUSH
55822: LD_VAR 0 2
55826: ARRAY
55827: PPUSH
55828: LD_INT 2
55830: PUSH
55831: LD_INT 30
55833: PUSH
55834: LD_INT 0
55836: PUSH
55837: EMPTY
55838: LIST
55839: LIST
55840: PUSH
55841: LD_INT 30
55843: PUSH
55844: LD_INT 1
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: LIST
55855: PPUSH
55856: CALL_OW 72
55860: ST_TO_ADDR
// if not tmp or not dep then
55861: LD_VAR 0 8
55865: NOT
55866: PUSH
55867: LD_VAR 0 9
55871: NOT
55872: OR
55873: IFFALSE 55877
// continue ;
55875: GO 55662
// side := GetSide ( tmp [ 1 ] ) ;
55877: LD_ADDR_VAR 0 11
55881: PUSH
55882: LD_VAR 0 8
55886: PUSH
55887: LD_INT 1
55889: ARRAY
55890: PPUSH
55891: CALL_OW 255
55895: ST_TO_ADDR
// dep := dep [ 1 ] ;
55896: LD_ADDR_VAR 0 9
55900: PUSH
55901: LD_VAR 0 9
55905: PUSH
55906: LD_INT 1
55908: ARRAY
55909: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
55910: LD_ADDR_VAR 0 7
55914: PUSH
55915: LD_EXP 128
55919: PUSH
55920: LD_VAR 0 2
55924: ARRAY
55925: PPUSH
55926: LD_INT 22
55928: PUSH
55929: LD_INT 0
55931: PUSH
55932: EMPTY
55933: LIST
55934: LIST
55935: PUSH
55936: LD_INT 25
55938: PUSH
55939: LD_INT 12
55941: PUSH
55942: EMPTY
55943: LIST
55944: LIST
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: PPUSH
55950: CALL_OW 70
55954: PUSH
55955: LD_INT 22
55957: PUSH
55958: LD_INT 0
55960: PUSH
55961: EMPTY
55962: LIST
55963: LIST
55964: PUSH
55965: LD_INT 25
55967: PUSH
55968: LD_INT 12
55970: PUSH
55971: EMPTY
55972: LIST
55973: LIST
55974: PUSH
55975: LD_INT 91
55977: PUSH
55978: LD_VAR 0 9
55982: PUSH
55983: LD_INT 20
55985: PUSH
55986: EMPTY
55987: LIST
55988: LIST
55989: LIST
55990: PUSH
55991: EMPTY
55992: LIST
55993: LIST
55994: LIST
55995: PPUSH
55996: CALL_OW 69
56000: UNION
56001: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
56002: LD_ADDR_VAR 0 10
56006: PUSH
56007: LD_EXP 128
56011: PUSH
56012: LD_VAR 0 2
56016: ARRAY
56017: PPUSH
56018: LD_INT 81
56020: PUSH
56021: LD_VAR 0 11
56025: PUSH
56026: EMPTY
56027: LIST
56028: LIST
56029: PPUSH
56030: CALL_OW 70
56034: ST_TO_ADDR
// if not apes or danger_at_area then
56035: LD_VAR 0 7
56039: NOT
56040: PUSH
56041: LD_VAR 0 10
56045: OR
56046: IFFALSE 56096
// begin if mc_taming [ i ] then
56048: LD_EXP 131
56052: PUSH
56053: LD_VAR 0 2
56057: ARRAY
56058: IFFALSE 56094
// begin MC_Reset ( i , 121 ) ;
56060: LD_VAR 0 2
56064: PPUSH
56065: LD_INT 121
56067: PPUSH
56068: CALL 41033 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56072: LD_ADDR_EXP 131
56076: PUSH
56077: LD_EXP 131
56081: PPUSH
56082: LD_VAR 0 2
56086: PPUSH
56087: EMPTY
56088: PPUSH
56089: CALL_OW 1
56093: ST_TO_ADDR
// end ; continue ;
56094: GO 55662
// end ; for j in tmp do
56096: LD_ADDR_VAR 0 3
56100: PUSH
56101: LD_VAR 0 8
56105: PUSH
56106: FOR_IN
56107: IFFALSE 56443
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
56109: LD_VAR 0 3
56113: PUSH
56114: LD_EXP 131
56118: PUSH
56119: LD_VAR 0 2
56123: ARRAY
56124: IN
56125: NOT
56126: PUSH
56127: LD_EXP 131
56131: PUSH
56132: LD_VAR 0 2
56136: ARRAY
56137: PUSH
56138: LD_INT 3
56140: LESS
56141: AND
56142: IFFALSE 56200
// begin SetTag ( j , 121 ) ;
56144: LD_VAR 0 3
56148: PPUSH
56149: LD_INT 121
56151: PPUSH
56152: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
56156: LD_ADDR_EXP 131
56160: PUSH
56161: LD_EXP 131
56165: PPUSH
56166: LD_VAR 0 2
56170: PUSH
56171: LD_EXP 131
56175: PUSH
56176: LD_VAR 0 2
56180: ARRAY
56181: PUSH
56182: LD_INT 1
56184: PLUS
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: PPUSH
56190: LD_VAR 0 3
56194: PPUSH
56195: CALL 72673 0 3
56199: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
56200: LD_VAR 0 3
56204: PUSH
56205: LD_EXP 131
56209: PUSH
56210: LD_VAR 0 2
56214: ARRAY
56215: IN
56216: IFFALSE 56441
// begin if GetClass ( j ) <> 4 then
56218: LD_VAR 0 3
56222: PPUSH
56223: CALL_OW 257
56227: PUSH
56228: LD_INT 4
56230: NONEQUAL
56231: IFFALSE 56284
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
56233: LD_ADDR_EXP 131
56237: PUSH
56238: LD_EXP 131
56242: PPUSH
56243: LD_VAR 0 2
56247: PPUSH
56248: LD_EXP 131
56252: PUSH
56253: LD_VAR 0 2
56257: ARRAY
56258: PUSH
56259: LD_VAR 0 3
56263: DIFF
56264: PPUSH
56265: CALL_OW 1
56269: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56270: LD_VAR 0 3
56274: PPUSH
56275: LD_INT 0
56277: PPUSH
56278: CALL_OW 109
// continue ;
56282: GO 56106
// end ; if IsInUnit ( j ) then
56284: LD_VAR 0 3
56288: PPUSH
56289: CALL_OW 310
56293: IFFALSE 56304
// ComExitBuilding ( j ) ;
56295: LD_VAR 0 3
56299: PPUSH
56300: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
56304: LD_ADDR_VAR 0 6
56308: PUSH
56309: LD_VAR 0 7
56313: PPUSH
56314: LD_VAR 0 3
56318: PPUSH
56319: CALL_OW 74
56323: ST_TO_ADDR
// if not ape then
56324: LD_VAR 0 6
56328: NOT
56329: IFFALSE 56333
// break ;
56331: GO 56443
// x := GetX ( ape ) ;
56333: LD_ADDR_VAR 0 4
56337: PUSH
56338: LD_VAR 0 6
56342: PPUSH
56343: CALL_OW 250
56347: ST_TO_ADDR
// y := GetY ( ape ) ;
56348: LD_ADDR_VAR 0 5
56352: PUSH
56353: LD_VAR 0 6
56357: PPUSH
56358: CALL_OW 251
56362: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56363: LD_VAR 0 4
56367: PPUSH
56368: LD_VAR 0 5
56372: PPUSH
56373: CALL_OW 488
56377: NOT
56378: PUSH
56379: LD_VAR 0 11
56383: PPUSH
56384: LD_VAR 0 4
56388: PPUSH
56389: LD_VAR 0 5
56393: PPUSH
56394: LD_INT 20
56396: PPUSH
56397: CALL 73569 0 4
56401: PUSH
56402: LD_INT 4
56404: ARRAY
56405: OR
56406: IFFALSE 56410
// break ;
56408: GO 56443
// if not HasTask ( j ) then
56410: LD_VAR 0 3
56414: PPUSH
56415: CALL_OW 314
56419: NOT
56420: IFFALSE 56441
// ComTameXY ( j , x , y ) ;
56422: LD_VAR 0 3
56426: PPUSH
56427: LD_VAR 0 4
56431: PPUSH
56432: LD_VAR 0 5
56436: PPUSH
56437: CALL_OW 131
// end ; end ;
56441: GO 56106
56443: POP
56444: POP
// end ;
56445: GO 55662
56447: POP
56448: POP
// end ;
56449: LD_VAR 0 1
56453: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56454: LD_INT 0
56456: PPUSH
56457: PPUSH
56458: PPUSH
56459: PPUSH
56460: PPUSH
56461: PPUSH
56462: PPUSH
56463: PPUSH
// if not mc_bases then
56464: LD_EXP 100
56468: NOT
56469: IFFALSE 56473
// exit ;
56471: GO 57099
// for i = 1 to mc_bases do
56473: LD_ADDR_VAR 0 2
56477: PUSH
56478: DOUBLE
56479: LD_INT 1
56481: DEC
56482: ST_TO_ADDR
56483: LD_EXP 100
56487: PUSH
56488: FOR_TO
56489: IFFALSE 57097
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56491: LD_EXP 129
56495: PUSH
56496: LD_VAR 0 2
56500: ARRAY
56501: NOT
56502: PUSH
56503: LD_EXP 129
56507: PUSH
56508: LD_VAR 0 2
56512: ARRAY
56513: PPUSH
56514: LD_INT 25
56516: PUSH
56517: LD_INT 12
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: PPUSH
56524: CALL_OW 72
56528: NOT
56529: OR
56530: IFFALSE 56534
// continue ;
56532: GO 56488
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56534: LD_ADDR_VAR 0 5
56538: PUSH
56539: LD_EXP 129
56543: PUSH
56544: LD_VAR 0 2
56548: ARRAY
56549: PUSH
56550: LD_INT 1
56552: ARRAY
56553: PPUSH
56554: CALL_OW 255
56558: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56559: LD_VAR 0 5
56563: PPUSH
56564: LD_INT 2
56566: PPUSH
56567: CALL_OW 325
56571: IFFALSE 56824
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56573: LD_ADDR_VAR 0 4
56577: PUSH
56578: LD_EXP 129
56582: PUSH
56583: LD_VAR 0 2
56587: ARRAY
56588: PPUSH
56589: LD_INT 25
56591: PUSH
56592: LD_INT 16
56594: PUSH
56595: EMPTY
56596: LIST
56597: LIST
56598: PPUSH
56599: CALL_OW 72
56603: ST_TO_ADDR
// if tmp < 6 then
56604: LD_VAR 0 4
56608: PUSH
56609: LD_INT 6
56611: LESS
56612: IFFALSE 56824
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56614: LD_ADDR_VAR 0 6
56618: PUSH
56619: LD_EXP 100
56623: PUSH
56624: LD_VAR 0 2
56628: ARRAY
56629: PPUSH
56630: LD_INT 2
56632: PUSH
56633: LD_INT 30
56635: PUSH
56636: LD_INT 0
56638: PUSH
56639: EMPTY
56640: LIST
56641: LIST
56642: PUSH
56643: LD_INT 30
56645: PUSH
56646: LD_INT 1
56648: PUSH
56649: EMPTY
56650: LIST
56651: LIST
56652: PUSH
56653: EMPTY
56654: LIST
56655: LIST
56656: LIST
56657: PPUSH
56658: CALL_OW 72
56662: ST_TO_ADDR
// if depot then
56663: LD_VAR 0 6
56667: IFFALSE 56824
// begin selected := 0 ;
56669: LD_ADDR_VAR 0 7
56673: PUSH
56674: LD_INT 0
56676: ST_TO_ADDR
// for j in depot do
56677: LD_ADDR_VAR 0 3
56681: PUSH
56682: LD_VAR 0 6
56686: PUSH
56687: FOR_IN
56688: IFFALSE 56719
// begin if UnitsInside ( j ) < 6 then
56690: LD_VAR 0 3
56694: PPUSH
56695: CALL_OW 313
56699: PUSH
56700: LD_INT 6
56702: LESS
56703: IFFALSE 56717
// begin selected := j ;
56705: LD_ADDR_VAR 0 7
56709: PUSH
56710: LD_VAR 0 3
56714: ST_TO_ADDR
// break ;
56715: GO 56719
// end ; end ;
56717: GO 56687
56719: POP
56720: POP
// if selected then
56721: LD_VAR 0 7
56725: IFFALSE 56824
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56727: LD_ADDR_VAR 0 3
56731: PUSH
56732: LD_EXP 129
56736: PUSH
56737: LD_VAR 0 2
56741: ARRAY
56742: PPUSH
56743: LD_INT 25
56745: PUSH
56746: LD_INT 12
56748: PUSH
56749: EMPTY
56750: LIST
56751: LIST
56752: PPUSH
56753: CALL_OW 72
56757: PUSH
56758: FOR_IN
56759: IFFALSE 56822
// if not HasTask ( j ) then
56761: LD_VAR 0 3
56765: PPUSH
56766: CALL_OW 314
56770: NOT
56771: IFFALSE 56820
// begin if not IsInUnit ( j ) then
56773: LD_VAR 0 3
56777: PPUSH
56778: CALL_OW 310
56782: NOT
56783: IFFALSE 56799
// ComEnterUnit ( j , selected ) ;
56785: LD_VAR 0 3
56789: PPUSH
56790: LD_VAR 0 7
56794: PPUSH
56795: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
56799: LD_VAR 0 3
56803: PPUSH
56804: LD_INT 16
56806: PPUSH
56807: CALL_OW 183
// AddComExitBuilding ( j ) ;
56811: LD_VAR 0 3
56815: PPUSH
56816: CALL_OW 182
// end ;
56820: GO 56758
56822: POP
56823: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
56824: LD_VAR 0 5
56828: PPUSH
56829: LD_INT 11
56831: PPUSH
56832: CALL_OW 325
56836: IFFALSE 57095
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56838: LD_ADDR_VAR 0 4
56842: PUSH
56843: LD_EXP 129
56847: PUSH
56848: LD_VAR 0 2
56852: ARRAY
56853: PPUSH
56854: LD_INT 25
56856: PUSH
56857: LD_INT 16
56859: PUSH
56860: EMPTY
56861: LIST
56862: LIST
56863: PPUSH
56864: CALL_OW 72
56868: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
56869: LD_VAR 0 4
56873: PUSH
56874: LD_INT 6
56876: GREATEREQUAL
56877: PUSH
56878: LD_VAR 0 5
56882: PPUSH
56883: LD_INT 2
56885: PPUSH
56886: CALL_OW 325
56890: NOT
56891: OR
56892: IFFALSE 57095
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56894: LD_ADDR_VAR 0 8
56898: PUSH
56899: LD_EXP 100
56903: PUSH
56904: LD_VAR 0 2
56908: ARRAY
56909: PPUSH
56910: LD_INT 2
56912: PUSH
56913: LD_INT 30
56915: PUSH
56916: LD_INT 4
56918: PUSH
56919: EMPTY
56920: LIST
56921: LIST
56922: PUSH
56923: LD_INT 30
56925: PUSH
56926: LD_INT 5
56928: PUSH
56929: EMPTY
56930: LIST
56931: LIST
56932: PUSH
56933: EMPTY
56934: LIST
56935: LIST
56936: LIST
56937: PPUSH
56938: CALL_OW 72
56942: ST_TO_ADDR
// if barracks then
56943: LD_VAR 0 8
56947: IFFALSE 57095
// begin selected := 0 ;
56949: LD_ADDR_VAR 0 7
56953: PUSH
56954: LD_INT 0
56956: ST_TO_ADDR
// for j in barracks do
56957: LD_ADDR_VAR 0 3
56961: PUSH
56962: LD_VAR 0 8
56966: PUSH
56967: FOR_IN
56968: IFFALSE 56999
// begin if UnitsInside ( j ) < 6 then
56970: LD_VAR 0 3
56974: PPUSH
56975: CALL_OW 313
56979: PUSH
56980: LD_INT 6
56982: LESS
56983: IFFALSE 56997
// begin selected := j ;
56985: LD_ADDR_VAR 0 7
56989: PUSH
56990: LD_VAR 0 3
56994: ST_TO_ADDR
// break ;
56995: GO 56999
// end ; end ;
56997: GO 56967
56999: POP
57000: POP
// if selected then
57001: LD_VAR 0 7
57005: IFFALSE 57095
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
57007: LD_ADDR_VAR 0 3
57011: PUSH
57012: LD_EXP 129
57016: PUSH
57017: LD_VAR 0 2
57021: ARRAY
57022: PPUSH
57023: LD_INT 25
57025: PUSH
57026: LD_INT 12
57028: PUSH
57029: EMPTY
57030: LIST
57031: LIST
57032: PPUSH
57033: CALL_OW 72
57037: PUSH
57038: FOR_IN
57039: IFFALSE 57093
// if not IsInUnit ( j ) and not HasTask ( j ) then
57041: LD_VAR 0 3
57045: PPUSH
57046: CALL_OW 310
57050: NOT
57051: PUSH
57052: LD_VAR 0 3
57056: PPUSH
57057: CALL_OW 314
57061: NOT
57062: AND
57063: IFFALSE 57091
// begin ComEnterUnit ( j , selected ) ;
57065: LD_VAR 0 3
57069: PPUSH
57070: LD_VAR 0 7
57074: PPUSH
57075: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
57079: LD_VAR 0 3
57083: PPUSH
57084: LD_INT 15
57086: PPUSH
57087: CALL_OW 183
// end ;
57091: GO 57038
57093: POP
57094: POP
// end ; end ; end ; end ; end ;
57095: GO 56488
57097: POP
57098: POP
// end ;
57099: LD_VAR 0 1
57103: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
57104: LD_INT 0
57106: PPUSH
57107: PPUSH
57108: PPUSH
57109: PPUSH
// if not mc_bases then
57110: LD_EXP 100
57114: NOT
57115: IFFALSE 57119
// exit ;
57117: GO 57297
// for i = 1 to mc_bases do
57119: LD_ADDR_VAR 0 2
57123: PUSH
57124: DOUBLE
57125: LD_INT 1
57127: DEC
57128: ST_TO_ADDR
57129: LD_EXP 100
57133: PUSH
57134: FOR_TO
57135: IFFALSE 57295
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
57137: LD_ADDR_VAR 0 4
57141: PUSH
57142: LD_EXP 100
57146: PUSH
57147: LD_VAR 0 2
57151: ARRAY
57152: PPUSH
57153: LD_INT 25
57155: PUSH
57156: LD_INT 9
57158: PUSH
57159: EMPTY
57160: LIST
57161: LIST
57162: PPUSH
57163: CALL_OW 72
57167: ST_TO_ADDR
// if not tmp then
57168: LD_VAR 0 4
57172: NOT
57173: IFFALSE 57177
// continue ;
57175: GO 57134
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
57177: LD_EXP 126
57181: PUSH
57182: LD_VAR 0 2
57186: ARRAY
57187: PPUSH
57188: LD_INT 29
57190: PPUSH
57191: CALL_OW 325
57195: NOT
57196: PUSH
57197: LD_EXP 126
57201: PUSH
57202: LD_VAR 0 2
57206: ARRAY
57207: PPUSH
57208: LD_INT 28
57210: PPUSH
57211: CALL_OW 325
57215: NOT
57216: AND
57217: IFFALSE 57221
// continue ;
57219: GO 57134
// for j in tmp do
57221: LD_ADDR_VAR 0 3
57225: PUSH
57226: LD_VAR 0 4
57230: PUSH
57231: FOR_IN
57232: IFFALSE 57291
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57234: LD_VAR 0 3
57238: PUSH
57239: LD_EXP 103
57243: PUSH
57244: LD_VAR 0 2
57248: ARRAY
57249: PUSH
57250: LD_INT 1
57252: ARRAY
57253: IN
57254: NOT
57255: PUSH
57256: LD_VAR 0 3
57260: PUSH
57261: LD_EXP 103
57265: PUSH
57266: LD_VAR 0 2
57270: ARRAY
57271: PUSH
57272: LD_INT 2
57274: ARRAY
57275: IN
57276: NOT
57277: AND
57278: IFFALSE 57289
// ComSpaceTimeShoot ( j ) ;
57280: LD_VAR 0 3
57284: PPUSH
57285: CALL 68483 0 1
57289: GO 57231
57291: POP
57292: POP
// end ;
57293: GO 57134
57295: POP
57296: POP
// end ;
57297: LD_VAR 0 1
57301: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
57302: LD_INT 0
57304: PPUSH
57305: PPUSH
57306: PPUSH
57307: PPUSH
57308: PPUSH
57309: PPUSH
57310: PPUSH
57311: PPUSH
57312: PPUSH
// if not mc_bases then
57313: LD_EXP 100
57317: NOT
57318: IFFALSE 57322
// exit ;
57320: GO 57944
// for i = 1 to mc_bases do
57322: LD_ADDR_VAR 0 2
57326: PUSH
57327: DOUBLE
57328: LD_INT 1
57330: DEC
57331: ST_TO_ADDR
57332: LD_EXP 100
57336: PUSH
57337: FOR_TO
57338: IFFALSE 57942
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
57340: LD_EXP 135
57344: PUSH
57345: LD_VAR 0 2
57349: ARRAY
57350: NOT
57351: PUSH
57352: LD_INT 38
57354: PPUSH
57355: LD_EXP 126
57359: PUSH
57360: LD_VAR 0 2
57364: ARRAY
57365: PPUSH
57366: CALL_OW 321
57370: PUSH
57371: LD_INT 2
57373: NONEQUAL
57374: OR
57375: IFFALSE 57379
// continue ;
57377: GO 57337
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57379: LD_ADDR_VAR 0 8
57383: PUSH
57384: LD_EXP 100
57388: PUSH
57389: LD_VAR 0 2
57393: ARRAY
57394: PPUSH
57395: LD_INT 30
57397: PUSH
57398: LD_INT 34
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: PPUSH
57405: CALL_OW 72
57409: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57410: LD_ADDR_VAR 0 9
57414: PUSH
57415: LD_EXP 100
57419: PUSH
57420: LD_VAR 0 2
57424: ARRAY
57425: PPUSH
57426: LD_INT 25
57428: PUSH
57429: LD_INT 4
57431: PUSH
57432: EMPTY
57433: LIST
57434: LIST
57435: PPUSH
57436: CALL_OW 72
57440: PPUSH
57441: LD_INT 0
57443: PPUSH
57444: CALL 102585 0 2
57448: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57449: LD_VAR 0 9
57453: NOT
57454: PUSH
57455: LD_VAR 0 8
57459: NOT
57460: OR
57461: PUSH
57462: LD_EXP 100
57466: PUSH
57467: LD_VAR 0 2
57471: ARRAY
57472: PPUSH
57473: LD_INT 124
57475: PPUSH
57476: CALL 102585 0 2
57480: OR
57481: IFFALSE 57485
// continue ;
57483: GO 57337
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57485: LD_EXP 136
57489: PUSH
57490: LD_VAR 0 2
57494: ARRAY
57495: PUSH
57496: LD_EXP 135
57500: PUSH
57501: LD_VAR 0 2
57505: ARRAY
57506: LESS
57507: PUSH
57508: LD_EXP 136
57512: PUSH
57513: LD_VAR 0 2
57517: ARRAY
57518: PUSH
57519: LD_VAR 0 8
57523: LESS
57524: AND
57525: IFFALSE 57940
// begin tmp := sci [ 1 ] ;
57527: LD_ADDR_VAR 0 7
57531: PUSH
57532: LD_VAR 0 9
57536: PUSH
57537: LD_INT 1
57539: ARRAY
57540: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57541: LD_VAR 0 7
57545: PPUSH
57546: LD_INT 124
57548: PPUSH
57549: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57553: LD_ADDR_VAR 0 3
57557: PUSH
57558: DOUBLE
57559: LD_EXP 135
57563: PUSH
57564: LD_VAR 0 2
57568: ARRAY
57569: INC
57570: ST_TO_ADDR
57571: LD_EXP 135
57575: PUSH
57576: LD_VAR 0 2
57580: ARRAY
57581: PUSH
57582: FOR_DOWNTO
57583: IFFALSE 57926
// begin if IsInUnit ( tmp ) then
57585: LD_VAR 0 7
57589: PPUSH
57590: CALL_OW 310
57594: IFFALSE 57605
// ComExitBuilding ( tmp ) ;
57596: LD_VAR 0 7
57600: PPUSH
57601: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
57605: LD_INT 35
57607: PPUSH
57608: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
57612: LD_VAR 0 7
57616: PPUSH
57617: CALL_OW 310
57621: NOT
57622: PUSH
57623: LD_VAR 0 7
57627: PPUSH
57628: CALL_OW 314
57632: NOT
57633: AND
57634: IFFALSE 57605
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
57636: LD_ADDR_VAR 0 6
57640: PUSH
57641: LD_VAR 0 7
57645: PPUSH
57646: CALL_OW 250
57650: PUSH
57651: LD_VAR 0 7
57655: PPUSH
57656: CALL_OW 251
57660: PUSH
57661: EMPTY
57662: LIST
57663: LIST
57664: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
57665: LD_INT 35
57667: PPUSH
57668: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
57672: LD_ADDR_VAR 0 4
57676: PUSH
57677: LD_EXP 135
57681: PUSH
57682: LD_VAR 0 2
57686: ARRAY
57687: PUSH
57688: LD_VAR 0 3
57692: ARRAY
57693: PUSH
57694: LD_INT 1
57696: ARRAY
57697: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
57698: LD_ADDR_VAR 0 5
57702: PUSH
57703: LD_EXP 135
57707: PUSH
57708: LD_VAR 0 2
57712: ARRAY
57713: PUSH
57714: LD_VAR 0 3
57718: ARRAY
57719: PUSH
57720: LD_INT 2
57722: ARRAY
57723: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
57724: LD_VAR 0 7
57728: PPUSH
57729: LD_INT 10
57731: PPUSH
57732: CALL 75270 0 2
57736: PUSH
57737: LD_INT 4
57739: ARRAY
57740: IFFALSE 57778
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
57742: LD_VAR 0 7
57746: PPUSH
57747: LD_VAR 0 6
57751: PUSH
57752: LD_INT 1
57754: ARRAY
57755: PPUSH
57756: LD_VAR 0 6
57760: PUSH
57761: LD_INT 2
57763: ARRAY
57764: PPUSH
57765: CALL_OW 111
// wait ( 0 0$10 ) ;
57769: LD_INT 350
57771: PPUSH
57772: CALL_OW 67
// end else
57776: GO 57804
// begin ComMoveXY ( tmp , x , y ) ;
57778: LD_VAR 0 7
57782: PPUSH
57783: LD_VAR 0 4
57787: PPUSH
57788: LD_VAR 0 5
57792: PPUSH
57793: CALL_OW 111
// wait ( 0 0$3 ) ;
57797: LD_INT 105
57799: PPUSH
57800: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
57804: LD_VAR 0 7
57808: PPUSH
57809: LD_VAR 0 4
57813: PPUSH
57814: LD_VAR 0 5
57818: PPUSH
57819: CALL_OW 307
57823: IFFALSE 57665
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
57825: LD_VAR 0 7
57829: PPUSH
57830: LD_VAR 0 4
57834: PPUSH
57835: LD_VAR 0 5
57839: PPUSH
57840: LD_VAR 0 8
57844: PUSH
57845: LD_VAR 0 3
57849: ARRAY
57850: PPUSH
57851: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
57855: LD_INT 35
57857: PPUSH
57858: CALL_OW 67
// until not HasTask ( tmp ) ;
57862: LD_VAR 0 7
57866: PPUSH
57867: CALL_OW 314
57871: NOT
57872: IFFALSE 57855
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
57874: LD_ADDR_EXP 136
57878: PUSH
57879: LD_EXP 136
57883: PPUSH
57884: LD_VAR 0 2
57888: PUSH
57889: LD_EXP 136
57893: PUSH
57894: LD_VAR 0 2
57898: ARRAY
57899: PUSH
57900: LD_INT 1
57902: PLUS
57903: PUSH
57904: EMPTY
57905: LIST
57906: LIST
57907: PPUSH
57908: LD_VAR 0 8
57912: PUSH
57913: LD_VAR 0 3
57917: ARRAY
57918: PPUSH
57919: CALL 72673 0 3
57923: ST_TO_ADDR
// end ;
57924: GO 57582
57926: POP
57927: POP
// MC_Reset ( i , 124 ) ;
57928: LD_VAR 0 2
57932: PPUSH
57933: LD_INT 124
57935: PPUSH
57936: CALL 41033 0 2
// end ; end ;
57940: GO 57337
57942: POP
57943: POP
// end ;
57944: LD_VAR 0 1
57948: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
57949: LD_INT 0
57951: PPUSH
57952: PPUSH
57953: PPUSH
// if not mc_bases then
57954: LD_EXP 100
57958: NOT
57959: IFFALSE 57963
// exit ;
57961: GO 58569
// for i = 1 to mc_bases do
57963: LD_ADDR_VAR 0 2
57967: PUSH
57968: DOUBLE
57969: LD_INT 1
57971: DEC
57972: ST_TO_ADDR
57973: LD_EXP 100
57977: PUSH
57978: FOR_TO
57979: IFFALSE 58567
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57981: LD_ADDR_VAR 0 3
57985: PUSH
57986: LD_EXP 100
57990: PUSH
57991: LD_VAR 0 2
57995: ARRAY
57996: PPUSH
57997: LD_INT 25
57999: PUSH
58000: LD_INT 4
58002: PUSH
58003: EMPTY
58004: LIST
58005: LIST
58006: PPUSH
58007: CALL_OW 72
58011: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58012: LD_VAR 0 3
58016: NOT
58017: PUSH
58018: LD_EXP 137
58022: PUSH
58023: LD_VAR 0 2
58027: ARRAY
58028: NOT
58029: OR
58030: PUSH
58031: LD_EXP 100
58035: PUSH
58036: LD_VAR 0 2
58040: ARRAY
58041: PPUSH
58042: LD_INT 2
58044: PUSH
58045: LD_INT 30
58047: PUSH
58048: LD_INT 0
58050: PUSH
58051: EMPTY
58052: LIST
58053: LIST
58054: PUSH
58055: LD_INT 30
58057: PUSH
58058: LD_INT 1
58060: PUSH
58061: EMPTY
58062: LIST
58063: LIST
58064: PUSH
58065: EMPTY
58066: LIST
58067: LIST
58068: LIST
58069: PPUSH
58070: CALL_OW 72
58074: NOT
58075: OR
58076: IFFALSE 58126
// begin if mc_deposits_finder [ i ] then
58078: LD_EXP 138
58082: PUSH
58083: LD_VAR 0 2
58087: ARRAY
58088: IFFALSE 58124
// begin MC_Reset ( i , 125 ) ;
58090: LD_VAR 0 2
58094: PPUSH
58095: LD_INT 125
58097: PPUSH
58098: CALL 41033 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58102: LD_ADDR_EXP 138
58106: PUSH
58107: LD_EXP 138
58111: PPUSH
58112: LD_VAR 0 2
58116: PPUSH
58117: EMPTY
58118: PPUSH
58119: CALL_OW 1
58123: ST_TO_ADDR
// end ; continue ;
58124: GO 57978
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
58126: LD_EXP 137
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: PUSH
58137: LD_INT 1
58139: ARRAY
58140: PUSH
58141: LD_INT 3
58143: ARRAY
58144: PUSH
58145: LD_INT 1
58147: EQUAL
58148: PUSH
58149: LD_INT 20
58151: PPUSH
58152: LD_EXP 126
58156: PUSH
58157: LD_VAR 0 2
58161: ARRAY
58162: PPUSH
58163: CALL_OW 321
58167: PUSH
58168: LD_INT 2
58170: NONEQUAL
58171: AND
58172: IFFALSE 58222
// begin if mc_deposits_finder [ i ] then
58174: LD_EXP 138
58178: PUSH
58179: LD_VAR 0 2
58183: ARRAY
58184: IFFALSE 58220
// begin MC_Reset ( i , 125 ) ;
58186: LD_VAR 0 2
58190: PPUSH
58191: LD_INT 125
58193: PPUSH
58194: CALL 41033 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58198: LD_ADDR_EXP 138
58202: PUSH
58203: LD_EXP 138
58207: PPUSH
58208: LD_VAR 0 2
58212: PPUSH
58213: EMPTY
58214: PPUSH
58215: CALL_OW 1
58219: ST_TO_ADDR
// end ; continue ;
58220: GO 57978
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
58222: LD_EXP 137
58226: PUSH
58227: LD_VAR 0 2
58231: ARRAY
58232: PUSH
58233: LD_INT 1
58235: ARRAY
58236: PUSH
58237: LD_INT 1
58239: ARRAY
58240: PPUSH
58241: LD_EXP 137
58245: PUSH
58246: LD_VAR 0 2
58250: ARRAY
58251: PUSH
58252: LD_INT 1
58254: ARRAY
58255: PUSH
58256: LD_INT 2
58258: ARRAY
58259: PPUSH
58260: LD_EXP 126
58264: PUSH
58265: LD_VAR 0 2
58269: ARRAY
58270: PPUSH
58271: CALL_OW 440
58275: IFFALSE 58318
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
58277: LD_ADDR_EXP 137
58281: PUSH
58282: LD_EXP 137
58286: PPUSH
58287: LD_VAR 0 2
58291: PPUSH
58292: LD_EXP 137
58296: PUSH
58297: LD_VAR 0 2
58301: ARRAY
58302: PPUSH
58303: LD_INT 1
58305: PPUSH
58306: CALL_OW 3
58310: PPUSH
58311: CALL_OW 1
58315: ST_TO_ADDR
58316: GO 58565
// begin if not mc_deposits_finder [ i ] then
58318: LD_EXP 138
58322: PUSH
58323: LD_VAR 0 2
58327: ARRAY
58328: NOT
58329: IFFALSE 58381
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
58331: LD_ADDR_EXP 138
58335: PUSH
58336: LD_EXP 138
58340: PPUSH
58341: LD_VAR 0 2
58345: PPUSH
58346: LD_VAR 0 3
58350: PUSH
58351: LD_INT 1
58353: ARRAY
58354: PUSH
58355: EMPTY
58356: LIST
58357: PPUSH
58358: CALL_OW 1
58362: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58363: LD_VAR 0 3
58367: PUSH
58368: LD_INT 1
58370: ARRAY
58371: PPUSH
58372: LD_INT 125
58374: PPUSH
58375: CALL_OW 109
// end else
58379: GO 58565
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58381: LD_EXP 138
58385: PUSH
58386: LD_VAR 0 2
58390: ARRAY
58391: PUSH
58392: LD_INT 1
58394: ARRAY
58395: PPUSH
58396: CALL_OW 310
58400: IFFALSE 58423
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58402: LD_EXP 138
58406: PUSH
58407: LD_VAR 0 2
58411: ARRAY
58412: PUSH
58413: LD_INT 1
58415: ARRAY
58416: PPUSH
58417: CALL_OW 122
58421: GO 58565
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58423: LD_EXP 138
58427: PUSH
58428: LD_VAR 0 2
58432: ARRAY
58433: PUSH
58434: LD_INT 1
58436: ARRAY
58437: PPUSH
58438: CALL_OW 314
58442: NOT
58443: PUSH
58444: LD_EXP 138
58448: PUSH
58449: LD_VAR 0 2
58453: ARRAY
58454: PUSH
58455: LD_INT 1
58457: ARRAY
58458: PPUSH
58459: LD_EXP 137
58463: PUSH
58464: LD_VAR 0 2
58468: ARRAY
58469: PUSH
58470: LD_INT 1
58472: ARRAY
58473: PUSH
58474: LD_INT 1
58476: ARRAY
58477: PPUSH
58478: LD_EXP 137
58482: PUSH
58483: LD_VAR 0 2
58487: ARRAY
58488: PUSH
58489: LD_INT 1
58491: ARRAY
58492: PUSH
58493: LD_INT 2
58495: ARRAY
58496: PPUSH
58497: CALL_OW 297
58501: PUSH
58502: LD_INT 6
58504: GREATER
58505: AND
58506: IFFALSE 58565
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58508: LD_EXP 138
58512: PUSH
58513: LD_VAR 0 2
58517: ARRAY
58518: PUSH
58519: LD_INT 1
58521: ARRAY
58522: PPUSH
58523: LD_EXP 137
58527: PUSH
58528: LD_VAR 0 2
58532: ARRAY
58533: PUSH
58534: LD_INT 1
58536: ARRAY
58537: PUSH
58538: LD_INT 1
58540: ARRAY
58541: PPUSH
58542: LD_EXP 137
58546: PUSH
58547: LD_VAR 0 2
58551: ARRAY
58552: PUSH
58553: LD_INT 1
58555: ARRAY
58556: PUSH
58557: LD_INT 2
58559: ARRAY
58560: PPUSH
58561: CALL_OW 111
// end ; end ; end ;
58565: GO 57978
58567: POP
58568: POP
// end ;
58569: LD_VAR 0 1
58573: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58574: LD_INT 0
58576: PPUSH
58577: PPUSH
58578: PPUSH
58579: PPUSH
58580: PPUSH
58581: PPUSH
58582: PPUSH
58583: PPUSH
58584: PPUSH
58585: PPUSH
58586: PPUSH
// if not mc_bases then
58587: LD_EXP 100
58591: NOT
58592: IFFALSE 58596
// exit ;
58594: GO 59536
// for i = 1 to mc_bases do
58596: LD_ADDR_VAR 0 2
58600: PUSH
58601: DOUBLE
58602: LD_INT 1
58604: DEC
58605: ST_TO_ADDR
58606: LD_EXP 100
58610: PUSH
58611: FOR_TO
58612: IFFALSE 59534
// begin if not mc_bases [ i ] or mc_scan [ i ] then
58614: LD_EXP 100
58618: PUSH
58619: LD_VAR 0 2
58623: ARRAY
58624: NOT
58625: PUSH
58626: LD_EXP 123
58630: PUSH
58631: LD_VAR 0 2
58635: ARRAY
58636: OR
58637: IFFALSE 58641
// continue ;
58639: GO 58611
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
58641: LD_ADDR_VAR 0 7
58645: PUSH
58646: LD_EXP 100
58650: PUSH
58651: LD_VAR 0 2
58655: ARRAY
58656: PUSH
58657: LD_INT 1
58659: ARRAY
58660: PPUSH
58661: CALL_OW 248
58665: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
58666: LD_VAR 0 7
58670: PUSH
58671: LD_INT 3
58673: EQUAL
58674: PUSH
58675: LD_EXP 119
58679: PUSH
58680: LD_VAR 0 2
58684: ARRAY
58685: PUSH
58686: LD_EXP 122
58690: PUSH
58691: LD_VAR 0 2
58695: ARRAY
58696: UNION
58697: PPUSH
58698: LD_INT 33
58700: PUSH
58701: LD_INT 2
58703: PUSH
58704: EMPTY
58705: LIST
58706: LIST
58707: PPUSH
58708: CALL_OW 72
58712: NOT
58713: OR
58714: IFFALSE 58718
// continue ;
58716: GO 58611
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
58718: LD_ADDR_VAR 0 9
58722: PUSH
58723: LD_EXP 100
58727: PUSH
58728: LD_VAR 0 2
58732: ARRAY
58733: PPUSH
58734: LD_INT 30
58736: PUSH
58737: LD_INT 36
58739: PUSH
58740: EMPTY
58741: LIST
58742: LIST
58743: PPUSH
58744: CALL_OW 72
58748: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
58749: LD_ADDR_VAR 0 10
58753: PUSH
58754: LD_EXP 119
58758: PUSH
58759: LD_VAR 0 2
58763: ARRAY
58764: PPUSH
58765: LD_INT 34
58767: PUSH
58768: LD_INT 31
58770: PUSH
58771: EMPTY
58772: LIST
58773: LIST
58774: PPUSH
58775: CALL_OW 72
58779: ST_TO_ADDR
// if not cts and not mcts then
58780: LD_VAR 0 9
58784: NOT
58785: PUSH
58786: LD_VAR 0 10
58790: NOT
58791: AND
58792: IFFALSE 58796
// continue ;
58794: GO 58611
// x := cts ;
58796: LD_ADDR_VAR 0 11
58800: PUSH
58801: LD_VAR 0 9
58805: ST_TO_ADDR
// if not x then
58806: LD_VAR 0 11
58810: NOT
58811: IFFALSE 58823
// x := mcts ;
58813: LD_ADDR_VAR 0 11
58817: PUSH
58818: LD_VAR 0 10
58822: ST_TO_ADDR
// if not x then
58823: LD_VAR 0 11
58827: NOT
58828: IFFALSE 58832
// continue ;
58830: GO 58611
// if mc_remote_driver [ i ] then
58832: LD_EXP 140
58836: PUSH
58837: LD_VAR 0 2
58841: ARRAY
58842: IFFALSE 59229
// for j in mc_remote_driver [ i ] do
58844: LD_ADDR_VAR 0 3
58848: PUSH
58849: LD_EXP 140
58853: PUSH
58854: LD_VAR 0 2
58858: ARRAY
58859: PUSH
58860: FOR_IN
58861: IFFALSE 59227
// begin if GetClass ( j ) <> 3 then
58863: LD_VAR 0 3
58867: PPUSH
58868: CALL_OW 257
58872: PUSH
58873: LD_INT 3
58875: NONEQUAL
58876: IFFALSE 58929
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
58878: LD_ADDR_EXP 140
58882: PUSH
58883: LD_EXP 140
58887: PPUSH
58888: LD_VAR 0 2
58892: PPUSH
58893: LD_EXP 140
58897: PUSH
58898: LD_VAR 0 2
58902: ARRAY
58903: PUSH
58904: LD_VAR 0 3
58908: DIFF
58909: PPUSH
58910: CALL_OW 1
58914: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58915: LD_VAR 0 3
58919: PPUSH
58920: LD_INT 0
58922: PPUSH
58923: CALL_OW 109
// continue ;
58927: GO 58860
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
58929: LD_EXP 119
58933: PUSH
58934: LD_VAR 0 2
58938: ARRAY
58939: PPUSH
58940: LD_INT 34
58942: PUSH
58943: LD_INT 31
58945: PUSH
58946: EMPTY
58947: LIST
58948: LIST
58949: PUSH
58950: LD_INT 58
58952: PUSH
58953: EMPTY
58954: LIST
58955: PUSH
58956: EMPTY
58957: LIST
58958: LIST
58959: PPUSH
58960: CALL_OW 72
58964: PUSH
58965: LD_VAR 0 3
58969: PPUSH
58970: CALL 102620 0 1
58974: NOT
58975: AND
58976: IFFALSE 59047
// begin if IsInUnit ( j ) then
58978: LD_VAR 0 3
58982: PPUSH
58983: CALL_OW 310
58987: IFFALSE 58998
// ComExitBuilding ( j ) ;
58989: LD_VAR 0 3
58993: PPUSH
58994: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
58998: LD_VAR 0 3
59002: PPUSH
59003: LD_EXP 119
59007: PUSH
59008: LD_VAR 0 2
59012: ARRAY
59013: PPUSH
59014: LD_INT 34
59016: PUSH
59017: LD_INT 31
59019: PUSH
59020: EMPTY
59021: LIST
59022: LIST
59023: PUSH
59024: LD_INT 58
59026: PUSH
59027: EMPTY
59028: LIST
59029: PUSH
59030: EMPTY
59031: LIST
59032: LIST
59033: PPUSH
59034: CALL_OW 72
59038: PUSH
59039: LD_INT 1
59041: ARRAY
59042: PPUSH
59043: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
59047: LD_VAR 0 3
59051: PPUSH
59052: CALL_OW 310
59056: NOT
59057: PUSH
59058: LD_VAR 0 3
59062: PPUSH
59063: CALL_OW 310
59067: PPUSH
59068: CALL_OW 266
59072: PUSH
59073: LD_INT 36
59075: NONEQUAL
59076: PUSH
59077: LD_VAR 0 3
59081: PPUSH
59082: CALL 102620 0 1
59086: NOT
59087: AND
59088: OR
59089: IFFALSE 59225
// begin if IsInUnit ( j ) then
59091: LD_VAR 0 3
59095: PPUSH
59096: CALL_OW 310
59100: IFFALSE 59111
// ComExitBuilding ( j ) ;
59102: LD_VAR 0 3
59106: PPUSH
59107: CALL_OW 122
// ct := 0 ;
59111: LD_ADDR_VAR 0 8
59115: PUSH
59116: LD_INT 0
59118: ST_TO_ADDR
// for k in x do
59119: LD_ADDR_VAR 0 4
59123: PUSH
59124: LD_VAR 0 11
59128: PUSH
59129: FOR_IN
59130: IFFALSE 59203
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
59132: LD_VAR 0 4
59136: PPUSH
59137: CALL_OW 264
59141: PUSH
59142: LD_INT 31
59144: EQUAL
59145: PUSH
59146: LD_VAR 0 4
59150: PPUSH
59151: CALL_OW 311
59155: NOT
59156: AND
59157: PUSH
59158: LD_VAR 0 4
59162: PPUSH
59163: CALL_OW 266
59167: PUSH
59168: LD_INT 36
59170: EQUAL
59171: PUSH
59172: LD_VAR 0 4
59176: PPUSH
59177: CALL_OW 313
59181: PUSH
59182: LD_INT 3
59184: LESS
59185: AND
59186: OR
59187: IFFALSE 59201
// begin ct := k ;
59189: LD_ADDR_VAR 0 8
59193: PUSH
59194: LD_VAR 0 4
59198: ST_TO_ADDR
// break ;
59199: GO 59203
// end ;
59201: GO 59129
59203: POP
59204: POP
// if ct then
59205: LD_VAR 0 8
59209: IFFALSE 59225
// ComEnterUnit ( j , ct ) ;
59211: LD_VAR 0 3
59215: PPUSH
59216: LD_VAR 0 8
59220: PPUSH
59221: CALL_OW 120
// end ; end ;
59225: GO 58860
59227: POP
59228: POP
// places := 0 ;
59229: LD_ADDR_VAR 0 5
59233: PUSH
59234: LD_INT 0
59236: ST_TO_ADDR
// for j = 1 to x do
59237: LD_ADDR_VAR 0 3
59241: PUSH
59242: DOUBLE
59243: LD_INT 1
59245: DEC
59246: ST_TO_ADDR
59247: LD_VAR 0 11
59251: PUSH
59252: FOR_TO
59253: IFFALSE 59329
// if GetWeapon ( x [ j ] ) = ar_control_tower then
59255: LD_VAR 0 11
59259: PUSH
59260: LD_VAR 0 3
59264: ARRAY
59265: PPUSH
59266: CALL_OW 264
59270: PUSH
59271: LD_INT 31
59273: EQUAL
59274: IFFALSE 59292
// places := places + 1 else
59276: LD_ADDR_VAR 0 5
59280: PUSH
59281: LD_VAR 0 5
59285: PUSH
59286: LD_INT 1
59288: PLUS
59289: ST_TO_ADDR
59290: GO 59327
// if GetBType ( x [ j ] ) = b_control_tower then
59292: LD_VAR 0 11
59296: PUSH
59297: LD_VAR 0 3
59301: ARRAY
59302: PPUSH
59303: CALL_OW 266
59307: PUSH
59308: LD_INT 36
59310: EQUAL
59311: IFFALSE 59327
// places := places + 3 ;
59313: LD_ADDR_VAR 0 5
59317: PUSH
59318: LD_VAR 0 5
59322: PUSH
59323: LD_INT 3
59325: PLUS
59326: ST_TO_ADDR
59327: GO 59252
59329: POP
59330: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
59331: LD_VAR 0 5
59335: PUSH
59336: LD_INT 0
59338: EQUAL
59339: PUSH
59340: LD_VAR 0 5
59344: PUSH
59345: LD_EXP 140
59349: PUSH
59350: LD_VAR 0 2
59354: ARRAY
59355: LESSEQUAL
59356: OR
59357: IFFALSE 59361
// continue ;
59359: GO 58611
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59361: LD_ADDR_VAR 0 6
59365: PUSH
59366: LD_EXP 100
59370: PUSH
59371: LD_VAR 0 2
59375: ARRAY
59376: PPUSH
59377: LD_INT 25
59379: PUSH
59380: LD_INT 3
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: PPUSH
59387: CALL_OW 72
59391: PUSH
59392: LD_EXP 140
59396: PUSH
59397: LD_VAR 0 2
59401: ARRAY
59402: DIFF
59403: PPUSH
59404: LD_INT 3
59406: PPUSH
59407: CALL 103520 0 2
59411: ST_TO_ADDR
// for j in tmp do
59412: LD_ADDR_VAR 0 3
59416: PUSH
59417: LD_VAR 0 6
59421: PUSH
59422: FOR_IN
59423: IFFALSE 59458
// if GetTag ( j ) > 0 then
59425: LD_VAR 0 3
59429: PPUSH
59430: CALL_OW 110
59434: PUSH
59435: LD_INT 0
59437: GREATER
59438: IFFALSE 59456
// tmp := tmp diff j ;
59440: LD_ADDR_VAR 0 6
59444: PUSH
59445: LD_VAR 0 6
59449: PUSH
59450: LD_VAR 0 3
59454: DIFF
59455: ST_TO_ADDR
59456: GO 59422
59458: POP
59459: POP
// if not tmp then
59460: LD_VAR 0 6
59464: NOT
59465: IFFALSE 59469
// continue ;
59467: GO 58611
// if places then
59469: LD_VAR 0 5
59473: IFFALSE 59532
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59475: LD_ADDR_EXP 140
59479: PUSH
59480: LD_EXP 140
59484: PPUSH
59485: LD_VAR 0 2
59489: PPUSH
59490: LD_EXP 140
59494: PUSH
59495: LD_VAR 0 2
59499: ARRAY
59500: PUSH
59501: LD_VAR 0 6
59505: PUSH
59506: LD_INT 1
59508: ARRAY
59509: UNION
59510: PPUSH
59511: CALL_OW 1
59515: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59516: LD_VAR 0 6
59520: PUSH
59521: LD_INT 1
59523: ARRAY
59524: PPUSH
59525: LD_INT 126
59527: PPUSH
59528: CALL_OW 109
// end ; end ;
59532: GO 58611
59534: POP
59535: POP
// end ;
59536: LD_VAR 0 1
59540: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59541: LD_INT 0
59543: PPUSH
59544: PPUSH
59545: PPUSH
59546: PPUSH
59547: PPUSH
59548: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59549: LD_VAR 0 1
59553: NOT
59554: PUSH
59555: LD_VAR 0 2
59559: NOT
59560: OR
59561: PUSH
59562: LD_VAR 0 3
59566: NOT
59567: OR
59568: PUSH
59569: LD_VAR 0 4
59573: PUSH
59574: LD_INT 1
59576: PUSH
59577: LD_INT 2
59579: PUSH
59580: LD_INT 3
59582: PUSH
59583: LD_INT 4
59585: PUSH
59586: LD_INT 5
59588: PUSH
59589: LD_INT 8
59591: PUSH
59592: LD_INT 9
59594: PUSH
59595: LD_INT 15
59597: PUSH
59598: LD_INT 16
59600: PUSH
59601: EMPTY
59602: LIST
59603: LIST
59604: LIST
59605: LIST
59606: LIST
59607: LIST
59608: LIST
59609: LIST
59610: LIST
59611: IN
59612: NOT
59613: OR
59614: IFFALSE 59618
// exit ;
59616: GO 60518
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
59618: LD_ADDR_VAR 0 2
59622: PUSH
59623: LD_VAR 0 2
59627: PPUSH
59628: LD_INT 21
59630: PUSH
59631: LD_INT 3
59633: PUSH
59634: EMPTY
59635: LIST
59636: LIST
59637: PUSH
59638: LD_INT 24
59640: PUSH
59641: LD_INT 250
59643: PUSH
59644: EMPTY
59645: LIST
59646: LIST
59647: PUSH
59648: EMPTY
59649: LIST
59650: LIST
59651: PPUSH
59652: CALL_OW 72
59656: ST_TO_ADDR
// case class of 1 , 15 :
59657: LD_VAR 0 4
59661: PUSH
59662: LD_INT 1
59664: DOUBLE
59665: EQUAL
59666: IFTRUE 59676
59668: LD_INT 15
59670: DOUBLE
59671: EQUAL
59672: IFTRUE 59676
59674: GO 59761
59676: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
59677: LD_ADDR_VAR 0 8
59681: PUSH
59682: LD_VAR 0 2
59686: PPUSH
59687: LD_INT 2
59689: PUSH
59690: LD_INT 30
59692: PUSH
59693: LD_INT 32
59695: PUSH
59696: EMPTY
59697: LIST
59698: LIST
59699: PUSH
59700: LD_INT 30
59702: PUSH
59703: LD_INT 31
59705: PUSH
59706: EMPTY
59707: LIST
59708: LIST
59709: PUSH
59710: EMPTY
59711: LIST
59712: LIST
59713: LIST
59714: PPUSH
59715: CALL_OW 72
59719: PUSH
59720: LD_VAR 0 2
59724: PPUSH
59725: LD_INT 2
59727: PUSH
59728: LD_INT 30
59730: PUSH
59731: LD_INT 4
59733: PUSH
59734: EMPTY
59735: LIST
59736: LIST
59737: PUSH
59738: LD_INT 30
59740: PUSH
59741: LD_INT 5
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: PUSH
59748: EMPTY
59749: LIST
59750: LIST
59751: LIST
59752: PPUSH
59753: CALL_OW 72
59757: ADD
59758: ST_TO_ADDR
59759: GO 60007
59761: LD_INT 2
59763: DOUBLE
59764: EQUAL
59765: IFTRUE 59775
59767: LD_INT 16
59769: DOUBLE
59770: EQUAL
59771: IFTRUE 59775
59773: GO 59821
59775: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
59776: LD_ADDR_VAR 0 8
59780: PUSH
59781: LD_VAR 0 2
59785: PPUSH
59786: LD_INT 2
59788: PUSH
59789: LD_INT 30
59791: PUSH
59792: LD_INT 0
59794: PUSH
59795: EMPTY
59796: LIST
59797: LIST
59798: PUSH
59799: LD_INT 30
59801: PUSH
59802: LD_INT 1
59804: PUSH
59805: EMPTY
59806: LIST
59807: LIST
59808: PUSH
59809: EMPTY
59810: LIST
59811: LIST
59812: LIST
59813: PPUSH
59814: CALL_OW 72
59818: ST_TO_ADDR
59819: GO 60007
59821: LD_INT 3
59823: DOUBLE
59824: EQUAL
59825: IFTRUE 59829
59827: GO 59875
59829: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
59830: LD_ADDR_VAR 0 8
59834: PUSH
59835: LD_VAR 0 2
59839: PPUSH
59840: LD_INT 2
59842: PUSH
59843: LD_INT 30
59845: PUSH
59846: LD_INT 2
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: PUSH
59853: LD_INT 30
59855: PUSH
59856: LD_INT 3
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: LIST
59867: PPUSH
59868: CALL_OW 72
59872: ST_TO_ADDR
59873: GO 60007
59875: LD_INT 4
59877: DOUBLE
59878: EQUAL
59879: IFTRUE 59883
59881: GO 59940
59883: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
59884: LD_ADDR_VAR 0 8
59888: PUSH
59889: LD_VAR 0 2
59893: PPUSH
59894: LD_INT 2
59896: PUSH
59897: LD_INT 30
59899: PUSH
59900: LD_INT 6
59902: PUSH
59903: EMPTY
59904: LIST
59905: LIST
59906: PUSH
59907: LD_INT 30
59909: PUSH
59910: LD_INT 7
59912: PUSH
59913: EMPTY
59914: LIST
59915: LIST
59916: PUSH
59917: LD_INT 30
59919: PUSH
59920: LD_INT 8
59922: PUSH
59923: EMPTY
59924: LIST
59925: LIST
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: LIST
59931: LIST
59932: PPUSH
59933: CALL_OW 72
59937: ST_TO_ADDR
59938: GO 60007
59940: LD_INT 5
59942: DOUBLE
59943: EQUAL
59944: IFTRUE 59960
59946: LD_INT 8
59948: DOUBLE
59949: EQUAL
59950: IFTRUE 59960
59952: LD_INT 9
59954: DOUBLE
59955: EQUAL
59956: IFTRUE 59960
59958: GO 60006
59960: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
59961: LD_ADDR_VAR 0 8
59965: PUSH
59966: LD_VAR 0 2
59970: PPUSH
59971: LD_INT 2
59973: PUSH
59974: LD_INT 30
59976: PUSH
59977: LD_INT 4
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: PUSH
59984: LD_INT 30
59986: PUSH
59987: LD_INT 5
59989: PUSH
59990: EMPTY
59991: LIST
59992: LIST
59993: PUSH
59994: EMPTY
59995: LIST
59996: LIST
59997: LIST
59998: PPUSH
59999: CALL_OW 72
60003: ST_TO_ADDR
60004: GO 60007
60006: POP
// if not tmp then
60007: LD_VAR 0 8
60011: NOT
60012: IFFALSE 60016
// exit ;
60014: GO 60518
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
60016: LD_VAR 0 4
60020: PUSH
60021: LD_INT 1
60023: PUSH
60024: LD_INT 15
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: IN
60031: PUSH
60032: LD_EXP 109
60036: PUSH
60037: LD_VAR 0 1
60041: ARRAY
60042: AND
60043: IFFALSE 60199
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
60045: LD_ADDR_VAR 0 9
60049: PUSH
60050: LD_EXP 109
60054: PUSH
60055: LD_VAR 0 1
60059: ARRAY
60060: PUSH
60061: LD_INT 1
60063: ARRAY
60064: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
60065: LD_VAR 0 9
60069: PUSH
60070: LD_EXP 110
60074: PUSH
60075: LD_VAR 0 1
60079: ARRAY
60080: IN
60081: NOT
60082: IFFALSE 60197
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
60084: LD_ADDR_EXP 110
60088: PUSH
60089: LD_EXP 110
60093: PPUSH
60094: LD_VAR 0 1
60098: PUSH
60099: LD_EXP 110
60103: PUSH
60104: LD_VAR 0 1
60108: ARRAY
60109: PUSH
60110: LD_INT 1
60112: PLUS
60113: PUSH
60114: EMPTY
60115: LIST
60116: LIST
60117: PPUSH
60118: LD_VAR 0 9
60122: PPUSH
60123: CALL 72673 0 3
60127: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
60128: LD_ADDR_EXP 109
60132: PUSH
60133: LD_EXP 109
60137: PPUSH
60138: LD_VAR 0 1
60142: PPUSH
60143: LD_EXP 109
60147: PUSH
60148: LD_VAR 0 1
60152: ARRAY
60153: PUSH
60154: LD_VAR 0 9
60158: DIFF
60159: PPUSH
60160: CALL_OW 1
60164: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
60165: LD_VAR 0 3
60169: PPUSH
60170: LD_EXP 110
60174: PUSH
60175: LD_VAR 0 1
60179: ARRAY
60180: PUSH
60181: LD_EXP 110
60185: PUSH
60186: LD_VAR 0 1
60190: ARRAY
60191: ARRAY
60192: PPUSH
60193: CALL_OW 120
// end ; exit ;
60197: GO 60518
// end ; if tmp > 1 then
60199: LD_VAR 0 8
60203: PUSH
60204: LD_INT 1
60206: GREATER
60207: IFFALSE 60311
// for i = 2 to tmp do
60209: LD_ADDR_VAR 0 6
60213: PUSH
60214: DOUBLE
60215: LD_INT 2
60217: DEC
60218: ST_TO_ADDR
60219: LD_VAR 0 8
60223: PUSH
60224: FOR_TO
60225: IFFALSE 60309
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
60227: LD_VAR 0 8
60231: PUSH
60232: LD_VAR 0 6
60236: ARRAY
60237: PPUSH
60238: CALL_OW 461
60242: PUSH
60243: LD_INT 6
60245: EQUAL
60246: IFFALSE 60307
// begin x := tmp [ i ] ;
60248: LD_ADDR_VAR 0 9
60252: PUSH
60253: LD_VAR 0 8
60257: PUSH
60258: LD_VAR 0 6
60262: ARRAY
60263: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
60264: LD_ADDR_VAR 0 8
60268: PUSH
60269: LD_VAR 0 8
60273: PPUSH
60274: LD_VAR 0 6
60278: PPUSH
60279: CALL_OW 3
60283: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
60284: LD_ADDR_VAR 0 8
60288: PUSH
60289: LD_VAR 0 8
60293: PPUSH
60294: LD_INT 1
60296: PPUSH
60297: LD_VAR 0 9
60301: PPUSH
60302: CALL_OW 2
60306: ST_TO_ADDR
// end ;
60307: GO 60224
60309: POP
60310: POP
// for i in tmp do
60311: LD_ADDR_VAR 0 6
60315: PUSH
60316: LD_VAR 0 8
60320: PUSH
60321: FOR_IN
60322: IFFALSE 60391
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
60324: LD_VAR 0 6
60328: PPUSH
60329: CALL_OW 313
60333: PUSH
60334: LD_INT 6
60336: LESS
60337: PUSH
60338: LD_VAR 0 6
60342: PPUSH
60343: CALL_OW 266
60347: PUSH
60348: LD_INT 31
60350: PUSH
60351: LD_INT 32
60353: PUSH
60354: EMPTY
60355: LIST
60356: LIST
60357: IN
60358: NOT
60359: AND
60360: PUSH
60361: LD_VAR 0 6
60365: PPUSH
60366: CALL_OW 313
60370: PUSH
60371: LD_INT 0
60373: EQUAL
60374: OR
60375: IFFALSE 60389
// begin j := i ;
60377: LD_ADDR_VAR 0 7
60381: PUSH
60382: LD_VAR 0 6
60386: ST_TO_ADDR
// break ;
60387: GO 60391
// end ; end ;
60389: GO 60321
60391: POP
60392: POP
// if j then
60393: LD_VAR 0 7
60397: IFFALSE 60415
// ComEnterUnit ( unit , j ) else
60399: LD_VAR 0 3
60403: PPUSH
60404: LD_VAR 0 7
60408: PPUSH
60409: CALL_OW 120
60413: GO 60518
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60415: LD_ADDR_VAR 0 10
60419: PUSH
60420: LD_VAR 0 2
60424: PPUSH
60425: LD_INT 2
60427: PUSH
60428: LD_INT 30
60430: PUSH
60431: LD_INT 0
60433: PUSH
60434: EMPTY
60435: LIST
60436: LIST
60437: PUSH
60438: LD_INT 30
60440: PUSH
60441: LD_INT 1
60443: PUSH
60444: EMPTY
60445: LIST
60446: LIST
60447: PUSH
60448: EMPTY
60449: LIST
60450: LIST
60451: LIST
60452: PPUSH
60453: CALL_OW 72
60457: ST_TO_ADDR
// if depot then
60458: LD_VAR 0 10
60462: IFFALSE 60518
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60464: LD_ADDR_VAR 0 10
60468: PUSH
60469: LD_VAR 0 10
60473: PPUSH
60474: LD_VAR 0 3
60478: PPUSH
60479: CALL_OW 74
60483: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60484: LD_VAR 0 3
60488: PPUSH
60489: LD_VAR 0 10
60493: PPUSH
60494: CALL_OW 296
60498: PUSH
60499: LD_INT 10
60501: GREATER
60502: IFFALSE 60518
// ComStandNearbyBuilding ( unit , depot ) ;
60504: LD_VAR 0 3
60508: PPUSH
60509: LD_VAR 0 10
60513: PPUSH
60514: CALL 69100 0 2
// end ; end ; end ;
60518: LD_VAR 0 5
60522: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60523: LD_INT 0
60525: PPUSH
60526: PPUSH
60527: PPUSH
60528: PPUSH
// if not mc_bases then
60529: LD_EXP 100
60533: NOT
60534: IFFALSE 60538
// exit ;
60536: GO 60777
// for i = 1 to mc_bases do
60538: LD_ADDR_VAR 0 2
60542: PUSH
60543: DOUBLE
60544: LD_INT 1
60546: DEC
60547: ST_TO_ADDR
60548: LD_EXP 100
60552: PUSH
60553: FOR_TO
60554: IFFALSE 60775
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60556: LD_ADDR_VAR 0 4
60560: PUSH
60561: LD_EXP 100
60565: PUSH
60566: LD_VAR 0 2
60570: ARRAY
60571: PPUSH
60572: LD_INT 21
60574: PUSH
60575: LD_INT 1
60577: PUSH
60578: EMPTY
60579: LIST
60580: LIST
60581: PPUSH
60582: CALL_OW 72
60586: PUSH
60587: LD_EXP 129
60591: PUSH
60592: LD_VAR 0 2
60596: ARRAY
60597: UNION
60598: ST_TO_ADDR
// if not tmp then
60599: LD_VAR 0 4
60603: NOT
60604: IFFALSE 60608
// continue ;
60606: GO 60553
// for j in tmp do
60608: LD_ADDR_VAR 0 3
60612: PUSH
60613: LD_VAR 0 4
60617: PUSH
60618: FOR_IN
60619: IFFALSE 60771
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
60621: LD_VAR 0 3
60625: PPUSH
60626: CALL_OW 110
60630: NOT
60631: PUSH
60632: LD_VAR 0 3
60636: PPUSH
60637: CALL_OW 314
60641: NOT
60642: AND
60643: PUSH
60644: LD_VAR 0 3
60648: PPUSH
60649: CALL_OW 311
60653: NOT
60654: AND
60655: PUSH
60656: LD_VAR 0 3
60660: PPUSH
60661: CALL_OW 310
60665: NOT
60666: AND
60667: PUSH
60668: LD_VAR 0 3
60672: PUSH
60673: LD_EXP 103
60677: PUSH
60678: LD_VAR 0 2
60682: ARRAY
60683: PUSH
60684: LD_INT 1
60686: ARRAY
60687: IN
60688: NOT
60689: AND
60690: PUSH
60691: LD_VAR 0 3
60695: PUSH
60696: LD_EXP 103
60700: PUSH
60701: LD_VAR 0 2
60705: ARRAY
60706: PUSH
60707: LD_INT 2
60709: ARRAY
60710: IN
60711: NOT
60712: AND
60713: PUSH
60714: LD_VAR 0 3
60718: PUSH
60719: LD_EXP 112
60723: PUSH
60724: LD_VAR 0 2
60728: ARRAY
60729: IN
60730: NOT
60731: AND
60732: IFFALSE 60769
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
60734: LD_VAR 0 2
60738: PPUSH
60739: LD_EXP 100
60743: PUSH
60744: LD_VAR 0 2
60748: ARRAY
60749: PPUSH
60750: LD_VAR 0 3
60754: PPUSH
60755: LD_VAR 0 3
60759: PPUSH
60760: CALL_OW 257
60764: PPUSH
60765: CALL 59541 0 4
// end ;
60769: GO 60618
60771: POP
60772: POP
// end ;
60773: GO 60553
60775: POP
60776: POP
// end ;
60777: LD_VAR 0 1
60781: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
60782: LD_INT 0
60784: PPUSH
60785: PPUSH
60786: PPUSH
60787: PPUSH
60788: PPUSH
60789: PPUSH
// if not mc_bases [ base ] then
60790: LD_EXP 100
60794: PUSH
60795: LD_VAR 0 1
60799: ARRAY
60800: NOT
60801: IFFALSE 60805
// exit ;
60803: GO 60987
// tmp := [ ] ;
60805: LD_ADDR_VAR 0 6
60809: PUSH
60810: EMPTY
60811: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
60812: LD_ADDR_VAR 0 7
60816: PUSH
60817: LD_VAR 0 3
60821: PPUSH
60822: LD_INT 0
60824: PPUSH
60825: CALL_OW 517
60829: ST_TO_ADDR
// if not list then
60830: LD_VAR 0 7
60834: NOT
60835: IFFALSE 60839
// exit ;
60837: GO 60987
// for i = 1 to amount do
60839: LD_ADDR_VAR 0 5
60843: PUSH
60844: DOUBLE
60845: LD_INT 1
60847: DEC
60848: ST_TO_ADDR
60849: LD_VAR 0 2
60853: PUSH
60854: FOR_TO
60855: IFFALSE 60935
// begin x := rand ( 1 , list [ 1 ] ) ;
60857: LD_ADDR_VAR 0 8
60861: PUSH
60862: LD_INT 1
60864: PPUSH
60865: LD_VAR 0 7
60869: PUSH
60870: LD_INT 1
60872: ARRAY
60873: PPUSH
60874: CALL_OW 12
60878: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
60879: LD_ADDR_VAR 0 6
60883: PUSH
60884: LD_VAR 0 6
60888: PPUSH
60889: LD_VAR 0 5
60893: PPUSH
60894: LD_VAR 0 7
60898: PUSH
60899: LD_INT 1
60901: ARRAY
60902: PUSH
60903: LD_VAR 0 8
60907: ARRAY
60908: PUSH
60909: LD_VAR 0 7
60913: PUSH
60914: LD_INT 2
60916: ARRAY
60917: PUSH
60918: LD_VAR 0 8
60922: ARRAY
60923: PUSH
60924: EMPTY
60925: LIST
60926: LIST
60927: PPUSH
60928: CALL_OW 1
60932: ST_TO_ADDR
// end ;
60933: GO 60854
60935: POP
60936: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
60937: LD_ADDR_EXP 113
60941: PUSH
60942: LD_EXP 113
60946: PPUSH
60947: LD_VAR 0 1
60951: PPUSH
60952: LD_VAR 0 6
60956: PPUSH
60957: CALL_OW 1
60961: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
60962: LD_ADDR_EXP 115
60966: PUSH
60967: LD_EXP 115
60971: PPUSH
60972: LD_VAR 0 1
60976: PPUSH
60977: LD_VAR 0 3
60981: PPUSH
60982: CALL_OW 1
60986: ST_TO_ADDR
// end ;
60987: LD_VAR 0 4
60991: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
60992: LD_INT 0
60994: PPUSH
// if not mc_bases [ base ] then
60995: LD_EXP 100
60999: PUSH
61000: LD_VAR 0 1
61004: ARRAY
61005: NOT
61006: IFFALSE 61010
// exit ;
61008: GO 61035
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
61010: LD_ADDR_EXP 105
61014: PUSH
61015: LD_EXP 105
61019: PPUSH
61020: LD_VAR 0 1
61024: PPUSH
61025: LD_VAR 0 2
61029: PPUSH
61030: CALL_OW 1
61034: ST_TO_ADDR
// end ;
61035: LD_VAR 0 3
61039: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
61040: LD_INT 0
61042: PPUSH
// if not mc_bases [ base ] then
61043: LD_EXP 100
61047: PUSH
61048: LD_VAR 0 1
61052: ARRAY
61053: NOT
61054: IFFALSE 61058
// exit ;
61056: GO 61095
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
61058: LD_ADDR_EXP 105
61062: PUSH
61063: LD_EXP 105
61067: PPUSH
61068: LD_VAR 0 1
61072: PPUSH
61073: LD_EXP 105
61077: PUSH
61078: LD_VAR 0 1
61082: ARRAY
61083: PUSH
61084: LD_VAR 0 2
61088: UNION
61089: PPUSH
61090: CALL_OW 1
61094: ST_TO_ADDR
// end ;
61095: LD_VAR 0 3
61099: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
61100: LD_INT 0
61102: PPUSH
// if not mc_bases [ base ] then
61103: LD_EXP 100
61107: PUSH
61108: LD_VAR 0 1
61112: ARRAY
61113: NOT
61114: IFFALSE 61118
// exit ;
61116: GO 61143
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
61118: LD_ADDR_EXP 121
61122: PUSH
61123: LD_EXP 121
61127: PPUSH
61128: LD_VAR 0 1
61132: PPUSH
61133: LD_VAR 0 2
61137: PPUSH
61138: CALL_OW 1
61142: ST_TO_ADDR
// end ;
61143: LD_VAR 0 3
61147: RET
// export function MC_InsertProduceList ( base , components ) ; begin
61148: LD_INT 0
61150: PPUSH
// if not mc_bases [ base ] then
61151: LD_EXP 100
61155: PUSH
61156: LD_VAR 0 1
61160: ARRAY
61161: NOT
61162: IFFALSE 61166
// exit ;
61164: GO 61203
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
61166: LD_ADDR_EXP 121
61170: PUSH
61171: LD_EXP 121
61175: PPUSH
61176: LD_VAR 0 1
61180: PPUSH
61181: LD_EXP 121
61185: PUSH
61186: LD_VAR 0 1
61190: ARRAY
61191: PUSH
61192: LD_VAR 0 2
61196: ADD
61197: PPUSH
61198: CALL_OW 1
61202: ST_TO_ADDR
// end ;
61203: LD_VAR 0 3
61207: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
61208: LD_INT 0
61210: PPUSH
// if not mc_bases [ base ] then
61211: LD_EXP 100
61215: PUSH
61216: LD_VAR 0 1
61220: ARRAY
61221: NOT
61222: IFFALSE 61226
// exit ;
61224: GO 61280
// mc_defender := Replace ( mc_defender , base , deflist ) ;
61226: LD_ADDR_EXP 122
61230: PUSH
61231: LD_EXP 122
61235: PPUSH
61236: LD_VAR 0 1
61240: PPUSH
61241: LD_VAR 0 2
61245: PPUSH
61246: CALL_OW 1
61250: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
61251: LD_ADDR_EXP 111
61255: PUSH
61256: LD_EXP 111
61260: PPUSH
61261: LD_VAR 0 1
61265: PPUSH
61266: LD_VAR 0 2
61270: PUSH
61271: LD_INT 0
61273: PLUS
61274: PPUSH
61275: CALL_OW 1
61279: ST_TO_ADDR
// end ;
61280: LD_VAR 0 3
61284: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
61285: LD_INT 0
61287: PPUSH
// if not mc_bases [ base ] then
61288: LD_EXP 100
61292: PUSH
61293: LD_VAR 0 1
61297: ARRAY
61298: NOT
61299: IFFALSE 61303
// exit ;
61301: GO 61328
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
61303: LD_ADDR_EXP 111
61307: PUSH
61308: LD_EXP 111
61312: PPUSH
61313: LD_VAR 0 1
61317: PPUSH
61318: LD_VAR 0 2
61322: PPUSH
61323: CALL_OW 1
61327: ST_TO_ADDR
// end ;
61328: LD_VAR 0 3
61332: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
61333: LD_INT 0
61335: PPUSH
61336: PPUSH
61337: PPUSH
61338: PPUSH
// if not mc_bases [ base ] then
61339: LD_EXP 100
61343: PUSH
61344: LD_VAR 0 1
61348: ARRAY
61349: NOT
61350: IFFALSE 61354
// exit ;
61352: GO 61419
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61354: LD_ADDR_EXP 120
61358: PUSH
61359: LD_EXP 120
61363: PPUSH
61364: LD_VAR 0 1
61368: PUSH
61369: LD_EXP 120
61373: PUSH
61374: LD_VAR 0 1
61378: ARRAY
61379: PUSH
61380: LD_INT 1
61382: PLUS
61383: PUSH
61384: EMPTY
61385: LIST
61386: LIST
61387: PPUSH
61388: LD_VAR 0 1
61392: PUSH
61393: LD_VAR 0 2
61397: PUSH
61398: LD_VAR 0 3
61402: PUSH
61403: LD_VAR 0 4
61407: PUSH
61408: EMPTY
61409: LIST
61410: LIST
61411: LIST
61412: LIST
61413: PPUSH
61414: CALL 72673 0 3
61418: ST_TO_ADDR
// end ;
61419: LD_VAR 0 5
61423: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61424: LD_INT 0
61426: PPUSH
// if not mc_bases [ base ] then
61427: LD_EXP 100
61431: PUSH
61432: LD_VAR 0 1
61436: ARRAY
61437: NOT
61438: IFFALSE 61442
// exit ;
61440: GO 61467
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61442: LD_ADDR_EXP 137
61446: PUSH
61447: LD_EXP 137
61451: PPUSH
61452: LD_VAR 0 1
61456: PPUSH
61457: LD_VAR 0 2
61461: PPUSH
61462: CALL_OW 1
61466: ST_TO_ADDR
// end ;
61467: LD_VAR 0 3
61471: RET
// export function MC_GetMinesField ( base ) ; begin
61472: LD_INT 0
61474: PPUSH
// result := mc_mines [ base ] ;
61475: LD_ADDR_VAR 0 2
61479: PUSH
61480: LD_EXP 113
61484: PUSH
61485: LD_VAR 0 1
61489: ARRAY
61490: ST_TO_ADDR
// end ;
61491: LD_VAR 0 2
61495: RET
// export function MC_GetProduceList ( base ) ; begin
61496: LD_INT 0
61498: PPUSH
// result := mc_produce [ base ] ;
61499: LD_ADDR_VAR 0 2
61503: PUSH
61504: LD_EXP 121
61508: PUSH
61509: LD_VAR 0 1
61513: ARRAY
61514: ST_TO_ADDR
// end ;
61515: LD_VAR 0 2
61519: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61520: LD_INT 0
61522: PPUSH
61523: PPUSH
// if not mc_bases then
61524: LD_EXP 100
61528: NOT
61529: IFFALSE 61533
// exit ;
61531: GO 61598
// if mc_bases [ base ] then
61533: LD_EXP 100
61537: PUSH
61538: LD_VAR 0 1
61542: ARRAY
61543: IFFALSE 61598
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61545: LD_ADDR_VAR 0 3
61549: PUSH
61550: LD_EXP 100
61554: PUSH
61555: LD_VAR 0 1
61559: ARRAY
61560: PPUSH
61561: LD_INT 30
61563: PUSH
61564: LD_VAR 0 2
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: PPUSH
61573: CALL_OW 72
61577: ST_TO_ADDR
// if result then
61578: LD_VAR 0 3
61582: IFFALSE 61598
// result := result [ 1 ] ;
61584: LD_ADDR_VAR 0 3
61588: PUSH
61589: LD_VAR 0 3
61593: PUSH
61594: LD_INT 1
61596: ARRAY
61597: ST_TO_ADDR
// end ; end ;
61598: LD_VAR 0 3
61602: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
61603: LD_INT 0
61605: PPUSH
61606: PPUSH
// if not mc_bases then
61607: LD_EXP 100
61611: NOT
61612: IFFALSE 61616
// exit ;
61614: GO 61661
// if mc_bases [ base ] then
61616: LD_EXP 100
61620: PUSH
61621: LD_VAR 0 1
61625: ARRAY
61626: IFFALSE 61661
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61628: LD_ADDR_VAR 0 3
61632: PUSH
61633: LD_EXP 100
61637: PUSH
61638: LD_VAR 0 1
61642: ARRAY
61643: PPUSH
61644: LD_INT 30
61646: PUSH
61647: LD_VAR 0 2
61651: PUSH
61652: EMPTY
61653: LIST
61654: LIST
61655: PPUSH
61656: CALL_OW 72
61660: ST_TO_ADDR
// end ;
61661: LD_VAR 0 3
61665: RET
// export function MC_SetTame ( base , area ) ; begin
61666: LD_INT 0
61668: PPUSH
// if not mc_bases or not base then
61669: LD_EXP 100
61673: NOT
61674: PUSH
61675: LD_VAR 0 1
61679: NOT
61680: OR
61681: IFFALSE 61685
// exit ;
61683: GO 61710
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
61685: LD_ADDR_EXP 128
61689: PUSH
61690: LD_EXP 128
61694: PPUSH
61695: LD_VAR 0 1
61699: PPUSH
61700: LD_VAR 0 2
61704: PPUSH
61705: CALL_OW 1
61709: ST_TO_ADDR
// end ;
61710: LD_VAR 0 3
61714: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
61715: LD_INT 0
61717: PPUSH
61718: PPUSH
// if not mc_bases or not base then
61719: LD_EXP 100
61723: NOT
61724: PUSH
61725: LD_VAR 0 1
61729: NOT
61730: OR
61731: IFFALSE 61735
// exit ;
61733: GO 61837
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61735: LD_ADDR_VAR 0 4
61739: PUSH
61740: LD_EXP 100
61744: PUSH
61745: LD_VAR 0 1
61749: ARRAY
61750: PPUSH
61751: LD_INT 30
61753: PUSH
61754: LD_VAR 0 2
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: PPUSH
61763: CALL_OW 72
61767: ST_TO_ADDR
// if not tmp then
61768: LD_VAR 0 4
61772: NOT
61773: IFFALSE 61777
// exit ;
61775: GO 61837
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
61777: LD_ADDR_EXP 132
61781: PUSH
61782: LD_EXP 132
61786: PPUSH
61787: LD_VAR 0 1
61791: PPUSH
61792: LD_EXP 132
61796: PUSH
61797: LD_VAR 0 1
61801: ARRAY
61802: PPUSH
61803: LD_EXP 132
61807: PUSH
61808: LD_VAR 0 1
61812: ARRAY
61813: PUSH
61814: LD_INT 1
61816: PLUS
61817: PPUSH
61818: LD_VAR 0 4
61822: PUSH
61823: LD_INT 1
61825: ARRAY
61826: PPUSH
61827: CALL_OW 2
61831: PPUSH
61832: CALL_OW 1
61836: ST_TO_ADDR
// end ;
61837: LD_VAR 0 3
61841: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
61842: LD_INT 0
61844: PPUSH
61845: PPUSH
// if not mc_bases or not base or not kinds then
61846: LD_EXP 100
61850: NOT
61851: PUSH
61852: LD_VAR 0 1
61856: NOT
61857: OR
61858: PUSH
61859: LD_VAR 0 2
61863: NOT
61864: OR
61865: IFFALSE 61869
// exit ;
61867: GO 61930
// for i in kinds do
61869: LD_ADDR_VAR 0 4
61873: PUSH
61874: LD_VAR 0 2
61878: PUSH
61879: FOR_IN
61880: IFFALSE 61928
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
61882: LD_ADDR_EXP 134
61886: PUSH
61887: LD_EXP 134
61891: PPUSH
61892: LD_VAR 0 1
61896: PUSH
61897: LD_EXP 134
61901: PUSH
61902: LD_VAR 0 1
61906: ARRAY
61907: PUSH
61908: LD_INT 1
61910: PLUS
61911: PUSH
61912: EMPTY
61913: LIST
61914: LIST
61915: PPUSH
61916: LD_VAR 0 4
61920: PPUSH
61921: CALL 72673 0 3
61925: ST_TO_ADDR
61926: GO 61879
61928: POP
61929: POP
// end ;
61930: LD_VAR 0 3
61934: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
61935: LD_INT 0
61937: PPUSH
// if not mc_bases or not base or not areas then
61938: LD_EXP 100
61942: NOT
61943: PUSH
61944: LD_VAR 0 1
61948: NOT
61949: OR
61950: PUSH
61951: LD_VAR 0 2
61955: NOT
61956: OR
61957: IFFALSE 61961
// exit ;
61959: GO 61986
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
61961: LD_ADDR_EXP 118
61965: PUSH
61966: LD_EXP 118
61970: PPUSH
61971: LD_VAR 0 1
61975: PPUSH
61976: LD_VAR 0 2
61980: PPUSH
61981: CALL_OW 1
61985: ST_TO_ADDR
// end ;
61986: LD_VAR 0 3
61990: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
61991: LD_INT 0
61993: PPUSH
// if not mc_bases or not base or not teleports_exit then
61994: LD_EXP 100
61998: NOT
61999: PUSH
62000: LD_VAR 0 1
62004: NOT
62005: OR
62006: PUSH
62007: LD_VAR 0 2
62011: NOT
62012: OR
62013: IFFALSE 62017
// exit ;
62015: GO 62042
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
62017: LD_ADDR_EXP 135
62021: PUSH
62022: LD_EXP 135
62026: PPUSH
62027: LD_VAR 0 1
62031: PPUSH
62032: LD_VAR 0 2
62036: PPUSH
62037: CALL_OW 1
62041: ST_TO_ADDR
// end ;
62042: LD_VAR 0 3
62046: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
62047: LD_INT 0
62049: PPUSH
62050: PPUSH
62051: PPUSH
// if not mc_bases or not base or not ext_list then
62052: LD_EXP 100
62056: NOT
62057: PUSH
62058: LD_VAR 0 1
62062: NOT
62063: OR
62064: PUSH
62065: LD_VAR 0 5
62069: NOT
62070: OR
62071: IFFALSE 62075
// exit ;
62073: GO 62248
// tmp := GetFacExtXYD ( x , y , d ) ;
62075: LD_ADDR_VAR 0 8
62079: PUSH
62080: LD_VAR 0 2
62084: PPUSH
62085: LD_VAR 0 3
62089: PPUSH
62090: LD_VAR 0 4
62094: PPUSH
62095: CALL 102650 0 3
62099: ST_TO_ADDR
// if not tmp then
62100: LD_VAR 0 8
62104: NOT
62105: IFFALSE 62109
// exit ;
62107: GO 62248
// for i in tmp do
62109: LD_ADDR_VAR 0 7
62113: PUSH
62114: LD_VAR 0 8
62118: PUSH
62119: FOR_IN
62120: IFFALSE 62246
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
62122: LD_ADDR_EXP 105
62126: PUSH
62127: LD_EXP 105
62131: PPUSH
62132: LD_VAR 0 1
62136: PPUSH
62137: LD_EXP 105
62141: PUSH
62142: LD_VAR 0 1
62146: ARRAY
62147: PPUSH
62148: LD_EXP 105
62152: PUSH
62153: LD_VAR 0 1
62157: ARRAY
62158: PUSH
62159: LD_INT 1
62161: PLUS
62162: PPUSH
62163: LD_VAR 0 5
62167: PUSH
62168: LD_INT 1
62170: ARRAY
62171: PUSH
62172: LD_VAR 0 7
62176: PUSH
62177: LD_INT 1
62179: ARRAY
62180: PUSH
62181: LD_VAR 0 7
62185: PUSH
62186: LD_INT 2
62188: ARRAY
62189: PUSH
62190: LD_VAR 0 7
62194: PUSH
62195: LD_INT 3
62197: ARRAY
62198: PUSH
62199: EMPTY
62200: LIST
62201: LIST
62202: LIST
62203: LIST
62204: PPUSH
62205: CALL_OW 2
62209: PPUSH
62210: CALL_OW 1
62214: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
62215: LD_ADDR_VAR 0 5
62219: PUSH
62220: LD_VAR 0 5
62224: PPUSH
62225: LD_INT 1
62227: PPUSH
62228: CALL_OW 3
62232: ST_TO_ADDR
// if not ext_list then
62233: LD_VAR 0 5
62237: NOT
62238: IFFALSE 62244
// exit ;
62240: POP
62241: POP
62242: GO 62248
// end ;
62244: GO 62119
62246: POP
62247: POP
// end ;
62248: LD_VAR 0 6
62252: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
62253: LD_INT 0
62255: PPUSH
// if not mc_bases or not base or not weapon_list then
62256: LD_EXP 100
62260: NOT
62261: PUSH
62262: LD_VAR 0 1
62266: NOT
62267: OR
62268: PUSH
62269: LD_VAR 0 2
62273: NOT
62274: OR
62275: IFFALSE 62279
// exit ;
62277: GO 62304
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
62279: LD_ADDR_EXP 139
62283: PUSH
62284: LD_EXP 139
62288: PPUSH
62289: LD_VAR 0 1
62293: PPUSH
62294: LD_VAR 0 2
62298: PPUSH
62299: CALL_OW 1
62303: ST_TO_ADDR
// end ;
62304: LD_VAR 0 3
62308: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
62309: LD_INT 0
62311: PPUSH
// if not mc_bases or not base or not tech_list then
62312: LD_EXP 100
62316: NOT
62317: PUSH
62318: LD_VAR 0 1
62322: NOT
62323: OR
62324: PUSH
62325: LD_VAR 0 2
62329: NOT
62330: OR
62331: IFFALSE 62335
// exit ;
62333: GO 62360
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
62335: LD_ADDR_EXP 127
62339: PUSH
62340: LD_EXP 127
62344: PPUSH
62345: LD_VAR 0 1
62349: PPUSH
62350: LD_VAR 0 2
62354: PPUSH
62355: CALL_OW 1
62359: ST_TO_ADDR
// end ;
62360: LD_VAR 0 3
62364: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62365: LD_INT 0
62367: PPUSH
// if not mc_bases or not parking_area or not base then
62368: LD_EXP 100
62372: NOT
62373: PUSH
62374: LD_VAR 0 2
62378: NOT
62379: OR
62380: PUSH
62381: LD_VAR 0 1
62385: NOT
62386: OR
62387: IFFALSE 62391
// exit ;
62389: GO 62416
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62391: LD_ADDR_EXP 124
62395: PUSH
62396: LD_EXP 124
62400: PPUSH
62401: LD_VAR 0 1
62405: PPUSH
62406: LD_VAR 0 2
62410: PPUSH
62411: CALL_OW 1
62415: ST_TO_ADDR
// end ;
62416: LD_VAR 0 3
62420: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62421: LD_INT 0
62423: PPUSH
// if not mc_bases or not base or not scan_area then
62424: LD_EXP 100
62428: NOT
62429: PUSH
62430: LD_VAR 0 1
62434: NOT
62435: OR
62436: PUSH
62437: LD_VAR 0 2
62441: NOT
62442: OR
62443: IFFALSE 62447
// exit ;
62445: GO 62472
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62447: LD_ADDR_EXP 125
62451: PUSH
62452: LD_EXP 125
62456: PPUSH
62457: LD_VAR 0 1
62461: PPUSH
62462: LD_VAR 0 2
62466: PPUSH
62467: CALL_OW 1
62471: ST_TO_ADDR
// end ;
62472: LD_VAR 0 3
62476: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62477: LD_INT 0
62479: PPUSH
62480: PPUSH
// if not mc_bases or not base then
62481: LD_EXP 100
62485: NOT
62486: PUSH
62487: LD_VAR 0 1
62491: NOT
62492: OR
62493: IFFALSE 62497
// exit ;
62495: GO 62561
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62497: LD_ADDR_VAR 0 3
62501: PUSH
62502: LD_INT 1
62504: PUSH
62505: LD_INT 2
62507: PUSH
62508: LD_INT 3
62510: PUSH
62511: LD_INT 4
62513: PUSH
62514: LD_INT 11
62516: PUSH
62517: EMPTY
62518: LIST
62519: LIST
62520: LIST
62521: LIST
62522: LIST
62523: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62524: LD_ADDR_EXP 127
62528: PUSH
62529: LD_EXP 127
62533: PPUSH
62534: LD_VAR 0 1
62538: PPUSH
62539: LD_EXP 127
62543: PUSH
62544: LD_VAR 0 1
62548: ARRAY
62549: PUSH
62550: LD_VAR 0 3
62554: DIFF
62555: PPUSH
62556: CALL_OW 1
62560: ST_TO_ADDR
// end ;
62561: LD_VAR 0 2
62565: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62566: LD_INT 0
62568: PPUSH
// result := mc_vehicles [ base ] ;
62569: LD_ADDR_VAR 0 3
62573: PUSH
62574: LD_EXP 119
62578: PUSH
62579: LD_VAR 0 1
62583: ARRAY
62584: ST_TO_ADDR
// if onlyCombat then
62585: LD_VAR 0 2
62589: IFFALSE 62761
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62591: LD_ADDR_VAR 0 3
62595: PUSH
62596: LD_VAR 0 3
62600: PUSH
62601: LD_VAR 0 3
62605: PPUSH
62606: LD_INT 2
62608: PUSH
62609: LD_INT 34
62611: PUSH
62612: LD_INT 12
62614: PUSH
62615: EMPTY
62616: LIST
62617: LIST
62618: PUSH
62619: LD_INT 34
62621: PUSH
62622: LD_INT 51
62624: PUSH
62625: EMPTY
62626: LIST
62627: LIST
62628: PUSH
62629: LD_INT 34
62631: PUSH
62632: LD_INT 89
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PUSH
62639: LD_INT 34
62641: PUSH
62642: LD_INT 32
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: PUSH
62649: LD_INT 34
62651: PUSH
62652: LD_INT 13
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: PUSH
62659: LD_INT 34
62661: PUSH
62662: LD_INT 52
62664: PUSH
62665: EMPTY
62666: LIST
62667: LIST
62668: PUSH
62669: LD_INT 34
62671: PUSH
62672: LD_INT 88
62674: PUSH
62675: EMPTY
62676: LIST
62677: LIST
62678: PUSH
62679: LD_INT 34
62681: PUSH
62682: LD_INT 14
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: PUSH
62689: LD_INT 34
62691: PUSH
62692: LD_INT 53
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PUSH
62699: LD_INT 34
62701: PUSH
62702: LD_INT 98
62704: PUSH
62705: EMPTY
62706: LIST
62707: LIST
62708: PUSH
62709: LD_INT 34
62711: PUSH
62712: LD_INT 31
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: PUSH
62719: LD_INT 34
62721: PUSH
62722: LD_INT 48
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PUSH
62729: LD_INT 34
62731: PUSH
62732: LD_INT 8
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: LIST
62743: LIST
62744: LIST
62745: LIST
62746: LIST
62747: LIST
62748: LIST
62749: LIST
62750: LIST
62751: LIST
62752: LIST
62753: LIST
62754: PPUSH
62755: CALL_OW 72
62759: DIFF
62760: ST_TO_ADDR
// end ; end_of_file
62761: LD_VAR 0 3
62765: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
62766: LD_INT 0
62768: PPUSH
62769: PPUSH
62770: PPUSH
// if not mc_bases or not skirmish then
62771: LD_EXP 100
62775: NOT
62776: PUSH
62777: LD_EXP 98
62781: NOT
62782: OR
62783: IFFALSE 62787
// exit ;
62785: GO 62952
// for i = 1 to mc_bases do
62787: LD_ADDR_VAR 0 4
62791: PUSH
62792: DOUBLE
62793: LD_INT 1
62795: DEC
62796: ST_TO_ADDR
62797: LD_EXP 100
62801: PUSH
62802: FOR_TO
62803: IFFALSE 62950
// begin if sci in mc_bases [ i ] then
62805: LD_VAR 0 2
62809: PUSH
62810: LD_EXP 100
62814: PUSH
62815: LD_VAR 0 4
62819: ARRAY
62820: IN
62821: IFFALSE 62948
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
62823: LD_ADDR_EXP 129
62827: PUSH
62828: LD_EXP 129
62832: PPUSH
62833: LD_VAR 0 4
62837: PUSH
62838: LD_EXP 129
62842: PUSH
62843: LD_VAR 0 4
62847: ARRAY
62848: PUSH
62849: LD_INT 1
62851: PLUS
62852: PUSH
62853: EMPTY
62854: LIST
62855: LIST
62856: PPUSH
62857: LD_VAR 0 1
62861: PPUSH
62862: CALL 72673 0 3
62866: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
62867: LD_ADDR_VAR 0 5
62871: PUSH
62872: LD_EXP 100
62876: PUSH
62877: LD_VAR 0 4
62881: ARRAY
62882: PPUSH
62883: LD_INT 2
62885: PUSH
62886: LD_INT 30
62888: PUSH
62889: LD_INT 0
62891: PUSH
62892: EMPTY
62893: LIST
62894: LIST
62895: PUSH
62896: LD_INT 30
62898: PUSH
62899: LD_INT 1
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: EMPTY
62907: LIST
62908: LIST
62909: LIST
62910: PPUSH
62911: CALL_OW 72
62915: PPUSH
62916: LD_VAR 0 1
62920: PPUSH
62921: CALL_OW 74
62925: ST_TO_ADDR
// if tmp then
62926: LD_VAR 0 5
62930: IFFALSE 62946
// ComStandNearbyBuilding ( ape , tmp ) ;
62932: LD_VAR 0 1
62936: PPUSH
62937: LD_VAR 0 5
62941: PPUSH
62942: CALL 69100 0 2
// break ;
62946: GO 62950
// end ; end ;
62948: GO 62802
62950: POP
62951: POP
// end ;
62952: LD_VAR 0 3
62956: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
62957: LD_INT 0
62959: PPUSH
62960: PPUSH
62961: PPUSH
// if not mc_bases or not skirmish then
62962: LD_EXP 100
62966: NOT
62967: PUSH
62968: LD_EXP 98
62972: NOT
62973: OR
62974: IFFALSE 62978
// exit ;
62976: GO 63067
// for i = 1 to mc_bases do
62978: LD_ADDR_VAR 0 4
62982: PUSH
62983: DOUBLE
62984: LD_INT 1
62986: DEC
62987: ST_TO_ADDR
62988: LD_EXP 100
62992: PUSH
62993: FOR_TO
62994: IFFALSE 63065
// begin if building in mc_busy_turret_list [ i ] then
62996: LD_VAR 0 1
63000: PUSH
63001: LD_EXP 110
63005: PUSH
63006: LD_VAR 0 4
63010: ARRAY
63011: IN
63012: IFFALSE 63063
// begin tmp := mc_busy_turret_list [ i ] diff building ;
63014: LD_ADDR_VAR 0 5
63018: PUSH
63019: LD_EXP 110
63023: PUSH
63024: LD_VAR 0 4
63028: ARRAY
63029: PUSH
63030: LD_VAR 0 1
63034: DIFF
63035: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
63036: LD_ADDR_EXP 110
63040: PUSH
63041: LD_EXP 110
63045: PPUSH
63046: LD_VAR 0 4
63050: PPUSH
63051: LD_VAR 0 5
63055: PPUSH
63056: CALL_OW 1
63060: ST_TO_ADDR
// break ;
63061: GO 63065
// end ; end ;
63063: GO 62993
63065: POP
63066: POP
// end ;
63067: LD_VAR 0 3
63071: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
63072: LD_INT 0
63074: PPUSH
63075: PPUSH
63076: PPUSH
// if not mc_bases or not skirmish then
63077: LD_EXP 100
63081: NOT
63082: PUSH
63083: LD_EXP 98
63087: NOT
63088: OR
63089: IFFALSE 63093
// exit ;
63091: GO 63292
// for i = 1 to mc_bases do
63093: LD_ADDR_VAR 0 5
63097: PUSH
63098: DOUBLE
63099: LD_INT 1
63101: DEC
63102: ST_TO_ADDR
63103: LD_EXP 100
63107: PUSH
63108: FOR_TO
63109: IFFALSE 63290
// if building in mc_bases [ i ] then
63111: LD_VAR 0 1
63115: PUSH
63116: LD_EXP 100
63120: PUSH
63121: LD_VAR 0 5
63125: ARRAY
63126: IN
63127: IFFALSE 63288
// begin tmp := mc_bases [ i ] diff building ;
63129: LD_ADDR_VAR 0 6
63133: PUSH
63134: LD_EXP 100
63138: PUSH
63139: LD_VAR 0 5
63143: ARRAY
63144: PUSH
63145: LD_VAR 0 1
63149: DIFF
63150: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
63151: LD_ADDR_EXP 100
63155: PUSH
63156: LD_EXP 100
63160: PPUSH
63161: LD_VAR 0 5
63165: PPUSH
63166: LD_VAR 0 6
63170: PPUSH
63171: CALL_OW 1
63175: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
63176: LD_VAR 0 1
63180: PUSH
63181: LD_EXP 108
63185: PUSH
63186: LD_VAR 0 5
63190: ARRAY
63191: IN
63192: IFFALSE 63231
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
63194: LD_ADDR_EXP 108
63198: PUSH
63199: LD_EXP 108
63203: PPUSH
63204: LD_VAR 0 5
63208: PPUSH
63209: LD_EXP 108
63213: PUSH
63214: LD_VAR 0 5
63218: ARRAY
63219: PUSH
63220: LD_VAR 0 1
63224: DIFF
63225: PPUSH
63226: CALL_OW 1
63230: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
63231: LD_VAR 0 1
63235: PUSH
63236: LD_EXP 109
63240: PUSH
63241: LD_VAR 0 5
63245: ARRAY
63246: IN
63247: IFFALSE 63286
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
63249: LD_ADDR_EXP 109
63253: PUSH
63254: LD_EXP 109
63258: PPUSH
63259: LD_VAR 0 5
63263: PPUSH
63264: LD_EXP 109
63268: PUSH
63269: LD_VAR 0 5
63273: ARRAY
63274: PUSH
63275: LD_VAR 0 1
63279: DIFF
63280: PPUSH
63281: CALL_OW 1
63285: ST_TO_ADDR
// break ;
63286: GO 63290
// end ;
63288: GO 63108
63290: POP
63291: POP
// end ;
63292: LD_VAR 0 4
63296: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
63297: LD_INT 0
63299: PPUSH
63300: PPUSH
63301: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
63302: LD_EXP 100
63306: NOT
63307: PUSH
63308: LD_EXP 98
63312: NOT
63313: OR
63314: PUSH
63315: LD_VAR 0 3
63319: PUSH
63320: LD_EXP 126
63324: IN
63325: NOT
63326: OR
63327: IFFALSE 63331
// exit ;
63329: GO 63454
// for i = 1 to mc_vehicles do
63331: LD_ADDR_VAR 0 6
63335: PUSH
63336: DOUBLE
63337: LD_INT 1
63339: DEC
63340: ST_TO_ADDR
63341: LD_EXP 119
63345: PUSH
63346: FOR_TO
63347: IFFALSE 63452
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63349: LD_VAR 0 2
63353: PUSH
63354: LD_EXP 119
63358: PUSH
63359: LD_VAR 0 6
63363: ARRAY
63364: IN
63365: PUSH
63366: LD_VAR 0 1
63370: PUSH
63371: LD_EXP 119
63375: PUSH
63376: LD_VAR 0 6
63380: ARRAY
63381: IN
63382: OR
63383: IFFALSE 63450
// begin tmp := mc_vehicles [ i ] diff old ;
63385: LD_ADDR_VAR 0 7
63389: PUSH
63390: LD_EXP 119
63394: PUSH
63395: LD_VAR 0 6
63399: ARRAY
63400: PUSH
63401: LD_VAR 0 2
63405: DIFF
63406: ST_TO_ADDR
// tmp := tmp diff new ;
63407: LD_ADDR_VAR 0 7
63411: PUSH
63412: LD_VAR 0 7
63416: PUSH
63417: LD_VAR 0 1
63421: DIFF
63422: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63423: LD_ADDR_EXP 119
63427: PUSH
63428: LD_EXP 119
63432: PPUSH
63433: LD_VAR 0 6
63437: PPUSH
63438: LD_VAR 0 7
63442: PPUSH
63443: CALL_OW 1
63447: ST_TO_ADDR
// break ;
63448: GO 63452
// end ;
63450: GO 63346
63452: POP
63453: POP
// end ;
63454: LD_VAR 0 5
63458: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63459: LD_INT 0
63461: PPUSH
63462: PPUSH
63463: PPUSH
63464: PPUSH
// if not mc_bases or not skirmish then
63465: LD_EXP 100
63469: NOT
63470: PUSH
63471: LD_EXP 98
63475: NOT
63476: OR
63477: IFFALSE 63481
// exit ;
63479: GO 63863
// side := GetSide ( vehicle ) ;
63481: LD_ADDR_VAR 0 5
63485: PUSH
63486: LD_VAR 0 1
63490: PPUSH
63491: CALL_OW 255
63495: ST_TO_ADDR
// for i = 1 to mc_bases do
63496: LD_ADDR_VAR 0 4
63500: PUSH
63501: DOUBLE
63502: LD_INT 1
63504: DEC
63505: ST_TO_ADDR
63506: LD_EXP 100
63510: PUSH
63511: FOR_TO
63512: IFFALSE 63861
// begin if factory in mc_bases [ i ] then
63514: LD_VAR 0 2
63518: PUSH
63519: LD_EXP 100
63523: PUSH
63524: LD_VAR 0 4
63528: ARRAY
63529: IN
63530: IFFALSE 63859
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63532: LD_EXP 122
63536: PUSH
63537: LD_VAR 0 4
63541: ARRAY
63542: PUSH
63543: LD_EXP 111
63547: PUSH
63548: LD_VAR 0 4
63552: ARRAY
63553: LESS
63554: PUSH
63555: LD_VAR 0 1
63559: PPUSH
63560: CALL_OW 264
63564: PUSH
63565: LD_INT 31
63567: PUSH
63568: LD_INT 32
63570: PUSH
63571: LD_INT 51
63573: PUSH
63574: LD_INT 89
63576: PUSH
63577: LD_INT 12
63579: PUSH
63580: LD_INT 30
63582: PUSH
63583: LD_INT 98
63585: PUSH
63586: LD_INT 11
63588: PUSH
63589: LD_INT 53
63591: PUSH
63592: LD_INT 14
63594: PUSH
63595: LD_INT 91
63597: PUSH
63598: LD_INT 29
63600: PUSH
63601: LD_INT 99
63603: PUSH
63604: LD_INT 13
63606: PUSH
63607: LD_INT 52
63609: PUSH
63610: LD_INT 88
63612: PUSH
63613: LD_INT 48
63615: PUSH
63616: LD_INT 8
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: LIST
63634: LIST
63635: LIST
63636: LIST
63637: LIST
63638: IN
63639: NOT
63640: AND
63641: IFFALSE 63689
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
63643: LD_ADDR_EXP 122
63647: PUSH
63648: LD_EXP 122
63652: PPUSH
63653: LD_VAR 0 4
63657: PUSH
63658: LD_EXP 122
63662: PUSH
63663: LD_VAR 0 4
63667: ARRAY
63668: PUSH
63669: LD_INT 1
63671: PLUS
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: PPUSH
63677: LD_VAR 0 1
63681: PPUSH
63682: CALL 72673 0 3
63686: ST_TO_ADDR
63687: GO 63733
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
63689: LD_ADDR_EXP 119
63693: PUSH
63694: LD_EXP 119
63698: PPUSH
63699: LD_VAR 0 4
63703: PUSH
63704: LD_EXP 119
63708: PUSH
63709: LD_VAR 0 4
63713: ARRAY
63714: PUSH
63715: LD_INT 1
63717: PLUS
63718: PUSH
63719: EMPTY
63720: LIST
63721: LIST
63722: PPUSH
63723: LD_VAR 0 1
63727: PPUSH
63728: CALL 72673 0 3
63732: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
63733: LD_VAR 0 1
63737: PPUSH
63738: CALL_OW 263
63742: PUSH
63743: LD_INT 2
63745: EQUAL
63746: IFFALSE 63775
// begin repeat wait ( 0 0$3 ) ;
63748: LD_INT 105
63750: PPUSH
63751: CALL_OW 67
// Connect ( vehicle ) ;
63755: LD_VAR 0 1
63759: PPUSH
63760: CALL 75642 0 1
// until IsControledBy ( vehicle ) ;
63764: LD_VAR 0 1
63768: PPUSH
63769: CALL_OW 312
63773: IFFALSE 63748
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
63775: LD_VAR 0 1
63779: PPUSH
63780: LD_EXP 124
63784: PUSH
63785: LD_VAR 0 4
63789: ARRAY
63790: PPUSH
63791: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
63795: LD_VAR 0 1
63799: PPUSH
63800: CALL_OW 263
63804: PUSH
63805: LD_INT 1
63807: NONEQUAL
63808: IFFALSE 63812
// break ;
63810: GO 63861
// repeat wait ( 0 0$1 ) ;
63812: LD_INT 35
63814: PPUSH
63815: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
63819: LD_VAR 0 1
63823: PPUSH
63824: LD_EXP 124
63828: PUSH
63829: LD_VAR 0 4
63833: ARRAY
63834: PPUSH
63835: CALL_OW 308
63839: IFFALSE 63812
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
63841: LD_VAR 0 1
63845: PPUSH
63846: CALL_OW 311
63850: PPUSH
63851: CALL_OW 121
// exit ;
63855: POP
63856: POP
63857: GO 63863
// end ; end ;
63859: GO 63511
63861: POP
63862: POP
// end ;
63863: LD_VAR 0 3
63867: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
63868: LD_INT 0
63870: PPUSH
63871: PPUSH
63872: PPUSH
63873: PPUSH
// if not mc_bases or not skirmish then
63874: LD_EXP 100
63878: NOT
63879: PUSH
63880: LD_EXP 98
63884: NOT
63885: OR
63886: IFFALSE 63890
// exit ;
63888: GO 64243
// repeat wait ( 0 0$1 ) ;
63890: LD_INT 35
63892: PPUSH
63893: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
63897: LD_VAR 0 2
63901: PPUSH
63902: LD_VAR 0 3
63906: PPUSH
63907: CALL_OW 284
63911: IFFALSE 63890
// if GetResourceTypeXY ( x , y ) = mat_artefact then
63913: LD_VAR 0 2
63917: PPUSH
63918: LD_VAR 0 3
63922: PPUSH
63923: CALL_OW 283
63927: PUSH
63928: LD_INT 4
63930: EQUAL
63931: IFFALSE 63935
// exit ;
63933: GO 64243
// for i = 1 to mc_bases do
63935: LD_ADDR_VAR 0 7
63939: PUSH
63940: DOUBLE
63941: LD_INT 1
63943: DEC
63944: ST_TO_ADDR
63945: LD_EXP 100
63949: PUSH
63950: FOR_TO
63951: IFFALSE 64241
// begin if mc_crates_area [ i ] then
63953: LD_EXP 118
63957: PUSH
63958: LD_VAR 0 7
63962: ARRAY
63963: IFFALSE 64074
// for j in mc_crates_area [ i ] do
63965: LD_ADDR_VAR 0 8
63969: PUSH
63970: LD_EXP 118
63974: PUSH
63975: LD_VAR 0 7
63979: ARRAY
63980: PUSH
63981: FOR_IN
63982: IFFALSE 64072
// if InArea ( x , y , j ) then
63984: LD_VAR 0 2
63988: PPUSH
63989: LD_VAR 0 3
63993: PPUSH
63994: LD_VAR 0 8
63998: PPUSH
63999: CALL_OW 309
64003: IFFALSE 64070
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
64005: LD_ADDR_EXP 116
64009: PUSH
64010: LD_EXP 116
64014: PPUSH
64015: LD_VAR 0 7
64019: PUSH
64020: LD_EXP 116
64024: PUSH
64025: LD_VAR 0 7
64029: ARRAY
64030: PUSH
64031: LD_INT 1
64033: PLUS
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: PPUSH
64039: LD_VAR 0 4
64043: PUSH
64044: LD_VAR 0 2
64048: PUSH
64049: LD_VAR 0 3
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: LIST
64058: PPUSH
64059: CALL 72673 0 3
64063: ST_TO_ADDR
// exit ;
64064: POP
64065: POP
64066: POP
64067: POP
64068: GO 64243
// end ;
64070: GO 63981
64072: POP
64073: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64074: LD_ADDR_VAR 0 9
64078: PUSH
64079: LD_EXP 100
64083: PUSH
64084: LD_VAR 0 7
64088: ARRAY
64089: PPUSH
64090: LD_INT 2
64092: PUSH
64093: LD_INT 30
64095: PUSH
64096: LD_INT 0
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: PUSH
64103: LD_INT 30
64105: PUSH
64106: LD_INT 1
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: LIST
64117: PPUSH
64118: CALL_OW 72
64122: ST_TO_ADDR
// if not depot then
64123: LD_VAR 0 9
64127: NOT
64128: IFFALSE 64132
// continue ;
64130: GO 63950
// for j in depot do
64132: LD_ADDR_VAR 0 8
64136: PUSH
64137: LD_VAR 0 9
64141: PUSH
64142: FOR_IN
64143: IFFALSE 64237
// if GetDistUnitXY ( j , x , y ) < 30 then
64145: LD_VAR 0 8
64149: PPUSH
64150: LD_VAR 0 2
64154: PPUSH
64155: LD_VAR 0 3
64159: PPUSH
64160: CALL_OW 297
64164: PUSH
64165: LD_INT 30
64167: LESS
64168: IFFALSE 64235
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
64170: LD_ADDR_EXP 116
64174: PUSH
64175: LD_EXP 116
64179: PPUSH
64180: LD_VAR 0 7
64184: PUSH
64185: LD_EXP 116
64189: PUSH
64190: LD_VAR 0 7
64194: ARRAY
64195: PUSH
64196: LD_INT 1
64198: PLUS
64199: PUSH
64200: EMPTY
64201: LIST
64202: LIST
64203: PPUSH
64204: LD_VAR 0 4
64208: PUSH
64209: LD_VAR 0 2
64213: PUSH
64214: LD_VAR 0 3
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: LIST
64223: PPUSH
64224: CALL 72673 0 3
64228: ST_TO_ADDR
// exit ;
64229: POP
64230: POP
64231: POP
64232: POP
64233: GO 64243
// end ;
64235: GO 64142
64237: POP
64238: POP
// end ;
64239: GO 63950
64241: POP
64242: POP
// end ;
64243: LD_VAR 0 6
64247: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
64248: LD_INT 0
64250: PPUSH
64251: PPUSH
64252: PPUSH
64253: PPUSH
// if not mc_bases or not skirmish then
64254: LD_EXP 100
64258: NOT
64259: PUSH
64260: LD_EXP 98
64264: NOT
64265: OR
64266: IFFALSE 64270
// exit ;
64268: GO 64547
// side := GetSide ( lab ) ;
64270: LD_ADDR_VAR 0 4
64274: PUSH
64275: LD_VAR 0 2
64279: PPUSH
64280: CALL_OW 255
64284: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
64285: LD_VAR 0 4
64289: PUSH
64290: LD_EXP 126
64294: IN
64295: NOT
64296: PUSH
64297: LD_EXP 127
64301: NOT
64302: OR
64303: PUSH
64304: LD_EXP 100
64308: NOT
64309: OR
64310: IFFALSE 64314
// exit ;
64312: GO 64547
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
64314: LD_ADDR_EXP 127
64318: PUSH
64319: LD_EXP 127
64323: PPUSH
64324: LD_VAR 0 4
64328: PPUSH
64329: LD_EXP 127
64333: PUSH
64334: LD_VAR 0 4
64338: ARRAY
64339: PUSH
64340: LD_VAR 0 1
64344: DIFF
64345: PPUSH
64346: CALL_OW 1
64350: ST_TO_ADDR
// for i = 1 to mc_bases do
64351: LD_ADDR_VAR 0 5
64355: PUSH
64356: DOUBLE
64357: LD_INT 1
64359: DEC
64360: ST_TO_ADDR
64361: LD_EXP 100
64365: PUSH
64366: FOR_TO
64367: IFFALSE 64545
// begin if lab in mc_bases [ i ] then
64369: LD_VAR 0 2
64373: PUSH
64374: LD_EXP 100
64378: PUSH
64379: LD_VAR 0 5
64383: ARRAY
64384: IN
64385: IFFALSE 64543
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64387: LD_VAR 0 1
64391: PUSH
64392: LD_INT 11
64394: PUSH
64395: LD_INT 4
64397: PUSH
64398: LD_INT 3
64400: PUSH
64401: LD_INT 2
64403: PUSH
64404: EMPTY
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: IN
64410: PUSH
64411: LD_EXP 130
64415: PUSH
64416: LD_VAR 0 5
64420: ARRAY
64421: AND
64422: IFFALSE 64543
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64424: LD_ADDR_VAR 0 6
64428: PUSH
64429: LD_EXP 130
64433: PUSH
64434: LD_VAR 0 5
64438: ARRAY
64439: PUSH
64440: LD_INT 1
64442: ARRAY
64443: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64444: LD_ADDR_EXP 130
64448: PUSH
64449: LD_EXP 130
64453: PPUSH
64454: LD_VAR 0 5
64458: PPUSH
64459: EMPTY
64460: PPUSH
64461: CALL_OW 1
64465: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64466: LD_VAR 0 6
64470: PPUSH
64471: LD_INT 0
64473: PPUSH
64474: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64478: LD_VAR 0 6
64482: PPUSH
64483: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64487: LD_ADDR_EXP 129
64491: PUSH
64492: LD_EXP 129
64496: PPUSH
64497: LD_VAR 0 5
64501: PPUSH
64502: LD_EXP 129
64506: PUSH
64507: LD_VAR 0 5
64511: ARRAY
64512: PPUSH
64513: LD_INT 1
64515: PPUSH
64516: LD_VAR 0 6
64520: PPUSH
64521: CALL_OW 2
64525: PPUSH
64526: CALL_OW 1
64530: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64531: LD_VAR 0 5
64535: PPUSH
64536: LD_INT 112
64538: PPUSH
64539: CALL 41033 0 2
// end ; end ; end ;
64543: GO 64366
64545: POP
64546: POP
// end ;
64547: LD_VAR 0 3
64551: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64552: LD_INT 0
64554: PPUSH
64555: PPUSH
64556: PPUSH
64557: PPUSH
64558: PPUSH
64559: PPUSH
64560: PPUSH
64561: PPUSH
// if not mc_bases or not skirmish then
64562: LD_EXP 100
64566: NOT
64567: PUSH
64568: LD_EXP 98
64572: NOT
64573: OR
64574: IFFALSE 64578
// exit ;
64576: GO 65947
// for i = 1 to mc_bases do
64578: LD_ADDR_VAR 0 3
64582: PUSH
64583: DOUBLE
64584: LD_INT 1
64586: DEC
64587: ST_TO_ADDR
64588: LD_EXP 100
64592: PUSH
64593: FOR_TO
64594: IFFALSE 65945
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
64596: LD_VAR 0 1
64600: PUSH
64601: LD_EXP 100
64605: PUSH
64606: LD_VAR 0 3
64610: ARRAY
64611: IN
64612: PUSH
64613: LD_VAR 0 1
64617: PUSH
64618: LD_EXP 107
64622: PUSH
64623: LD_VAR 0 3
64627: ARRAY
64628: IN
64629: OR
64630: PUSH
64631: LD_VAR 0 1
64635: PUSH
64636: LD_EXP 122
64640: PUSH
64641: LD_VAR 0 3
64645: ARRAY
64646: IN
64647: OR
64648: PUSH
64649: LD_VAR 0 1
64653: PUSH
64654: LD_EXP 119
64658: PUSH
64659: LD_VAR 0 3
64663: ARRAY
64664: IN
64665: OR
64666: PUSH
64667: LD_VAR 0 1
64671: PUSH
64672: LD_EXP 129
64676: PUSH
64677: LD_VAR 0 3
64681: ARRAY
64682: IN
64683: OR
64684: PUSH
64685: LD_VAR 0 1
64689: PUSH
64690: LD_EXP 130
64694: PUSH
64695: LD_VAR 0 3
64699: ARRAY
64700: IN
64701: OR
64702: IFFALSE 65943
// begin if un in mc_ape [ i ] then
64704: LD_VAR 0 1
64708: PUSH
64709: LD_EXP 129
64713: PUSH
64714: LD_VAR 0 3
64718: ARRAY
64719: IN
64720: IFFALSE 64759
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
64722: LD_ADDR_EXP 129
64726: PUSH
64727: LD_EXP 129
64731: PPUSH
64732: LD_VAR 0 3
64736: PPUSH
64737: LD_EXP 129
64741: PUSH
64742: LD_VAR 0 3
64746: ARRAY
64747: PUSH
64748: LD_VAR 0 1
64752: DIFF
64753: PPUSH
64754: CALL_OW 1
64758: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
64759: LD_VAR 0 1
64763: PUSH
64764: LD_EXP 130
64768: PUSH
64769: LD_VAR 0 3
64773: ARRAY
64774: IN
64775: IFFALSE 64799
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64777: LD_ADDR_EXP 130
64781: PUSH
64782: LD_EXP 130
64786: PPUSH
64787: LD_VAR 0 3
64791: PPUSH
64792: EMPTY
64793: PPUSH
64794: CALL_OW 1
64798: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
64799: LD_VAR 0 1
64803: PPUSH
64804: CALL_OW 247
64808: PUSH
64809: LD_INT 2
64811: EQUAL
64812: PUSH
64813: LD_VAR 0 1
64817: PPUSH
64818: CALL_OW 110
64822: PUSH
64823: LD_INT 20
64825: EQUAL
64826: PUSH
64827: LD_VAR 0 1
64831: PUSH
64832: LD_EXP 122
64836: PUSH
64837: LD_VAR 0 3
64841: ARRAY
64842: IN
64843: OR
64844: PUSH
64845: LD_VAR 0 1
64849: PPUSH
64850: CALL_OW 264
64854: PUSH
64855: LD_INT 12
64857: PUSH
64858: LD_INT 51
64860: PUSH
64861: LD_INT 89
64863: PUSH
64864: LD_INT 32
64866: PUSH
64867: LD_INT 13
64869: PUSH
64870: LD_INT 52
64872: PUSH
64873: LD_INT 31
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: LIST
64880: LIST
64881: LIST
64882: LIST
64883: LIST
64884: IN
64885: OR
64886: AND
64887: IFFALSE 65195
// begin if un in mc_defender [ i ] then
64889: LD_VAR 0 1
64893: PUSH
64894: LD_EXP 122
64898: PUSH
64899: LD_VAR 0 3
64903: ARRAY
64904: IN
64905: IFFALSE 64944
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64907: LD_ADDR_EXP 122
64911: PUSH
64912: LD_EXP 122
64916: PPUSH
64917: LD_VAR 0 3
64921: PPUSH
64922: LD_EXP 122
64926: PUSH
64927: LD_VAR 0 3
64931: ARRAY
64932: PUSH
64933: LD_VAR 0 1
64937: DIFF
64938: PPUSH
64939: CALL_OW 1
64943: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
64944: LD_ADDR_VAR 0 8
64948: PUSH
64949: LD_VAR 0 3
64953: PPUSH
64954: LD_INT 3
64956: PPUSH
64957: CALL 61603 0 2
64961: ST_TO_ADDR
// if fac then
64962: LD_VAR 0 8
64966: IFFALSE 65195
// begin for j in fac do
64968: LD_ADDR_VAR 0 4
64972: PUSH
64973: LD_VAR 0 8
64977: PUSH
64978: FOR_IN
64979: IFFALSE 65193
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
64981: LD_ADDR_VAR 0 9
64985: PUSH
64986: LD_VAR 0 8
64990: PPUSH
64991: LD_VAR 0 1
64995: PPUSH
64996: CALL_OW 265
65000: PPUSH
65001: LD_VAR 0 1
65005: PPUSH
65006: CALL_OW 262
65010: PPUSH
65011: LD_VAR 0 1
65015: PPUSH
65016: CALL_OW 263
65020: PPUSH
65021: LD_VAR 0 1
65025: PPUSH
65026: CALL_OW 264
65030: PPUSH
65031: CALL 70171 0 5
65035: ST_TO_ADDR
// if components then
65036: LD_VAR 0 9
65040: IFFALSE 65191
// begin if GetWeapon ( un ) = ar_control_tower then
65042: LD_VAR 0 1
65046: PPUSH
65047: CALL_OW 264
65051: PUSH
65052: LD_INT 31
65054: EQUAL
65055: IFFALSE 65172
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
65057: LD_VAR 0 1
65061: PPUSH
65062: CALL_OW 311
65066: PPUSH
65067: LD_INT 0
65069: PPUSH
65070: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
65074: LD_ADDR_EXP 140
65078: PUSH
65079: LD_EXP 140
65083: PPUSH
65084: LD_VAR 0 3
65088: PPUSH
65089: LD_EXP 140
65093: PUSH
65094: LD_VAR 0 3
65098: ARRAY
65099: PUSH
65100: LD_VAR 0 1
65104: PPUSH
65105: CALL_OW 311
65109: DIFF
65110: PPUSH
65111: CALL_OW 1
65115: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
65116: LD_ADDR_VAR 0 7
65120: PUSH
65121: LD_EXP 121
65125: PUSH
65126: LD_VAR 0 3
65130: ARRAY
65131: PPUSH
65132: LD_INT 1
65134: PPUSH
65135: LD_VAR 0 9
65139: PPUSH
65140: CALL_OW 2
65144: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65145: LD_ADDR_EXP 121
65149: PUSH
65150: LD_EXP 121
65154: PPUSH
65155: LD_VAR 0 3
65159: PPUSH
65160: LD_VAR 0 7
65164: PPUSH
65165: CALL_OW 1
65169: ST_TO_ADDR
// end else
65170: GO 65189
// MC_InsertProduceList ( i , [ components ] ) ;
65172: LD_VAR 0 3
65176: PPUSH
65177: LD_VAR 0 9
65181: PUSH
65182: EMPTY
65183: LIST
65184: PPUSH
65185: CALL 61148 0 2
// break ;
65189: GO 65193
// end ; end ;
65191: GO 64978
65193: POP
65194: POP
// end ; end ; if GetType ( un ) = unit_building then
65195: LD_VAR 0 1
65199: PPUSH
65200: CALL_OW 247
65204: PUSH
65205: LD_INT 3
65207: EQUAL
65208: IFFALSE 65611
// begin btype := GetBType ( un ) ;
65210: LD_ADDR_VAR 0 5
65214: PUSH
65215: LD_VAR 0 1
65219: PPUSH
65220: CALL_OW 266
65224: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
65225: LD_VAR 0 5
65229: PUSH
65230: LD_INT 29
65232: PUSH
65233: LD_INT 30
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: IN
65240: IFFALSE 65313
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
65242: LD_VAR 0 1
65246: PPUSH
65247: CALL_OW 250
65251: PPUSH
65252: LD_VAR 0 1
65256: PPUSH
65257: CALL_OW 251
65261: PPUSH
65262: LD_VAR 0 1
65266: PPUSH
65267: CALL_OW 255
65271: PPUSH
65272: CALL_OW 440
65276: NOT
65277: IFFALSE 65313
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
65279: LD_VAR 0 1
65283: PPUSH
65284: CALL_OW 250
65288: PPUSH
65289: LD_VAR 0 1
65293: PPUSH
65294: CALL_OW 251
65298: PPUSH
65299: LD_VAR 0 1
65303: PPUSH
65304: CALL_OW 255
65308: PPUSH
65309: CALL_OW 441
// end ; if btype = b_warehouse then
65313: LD_VAR 0 5
65317: PUSH
65318: LD_INT 1
65320: EQUAL
65321: IFFALSE 65339
// begin btype := b_depot ;
65323: LD_ADDR_VAR 0 5
65327: PUSH
65328: LD_INT 0
65330: ST_TO_ADDR
// pos := 1 ;
65331: LD_ADDR_VAR 0 6
65335: PUSH
65336: LD_INT 1
65338: ST_TO_ADDR
// end ; if btype = b_factory then
65339: LD_VAR 0 5
65343: PUSH
65344: LD_INT 3
65346: EQUAL
65347: IFFALSE 65365
// begin btype := b_workshop ;
65349: LD_ADDR_VAR 0 5
65353: PUSH
65354: LD_INT 2
65356: ST_TO_ADDR
// pos := 1 ;
65357: LD_ADDR_VAR 0 6
65361: PUSH
65362: LD_INT 1
65364: ST_TO_ADDR
// end ; if btype = b_barracks then
65365: LD_VAR 0 5
65369: PUSH
65370: LD_INT 5
65372: EQUAL
65373: IFFALSE 65383
// btype := b_armoury ;
65375: LD_ADDR_VAR 0 5
65379: PUSH
65380: LD_INT 4
65382: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65383: LD_VAR 0 5
65387: PUSH
65388: LD_INT 7
65390: PUSH
65391: LD_INT 8
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: IN
65398: IFFALSE 65408
// btype := b_lab ;
65400: LD_ADDR_VAR 0 5
65404: PUSH
65405: LD_INT 6
65407: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65408: LD_ADDR_EXP 105
65412: PUSH
65413: LD_EXP 105
65417: PPUSH
65418: LD_VAR 0 3
65422: PUSH
65423: LD_EXP 105
65427: PUSH
65428: LD_VAR 0 3
65432: ARRAY
65433: PUSH
65434: LD_INT 1
65436: PLUS
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: PPUSH
65442: LD_VAR 0 5
65446: PUSH
65447: LD_VAR 0 1
65451: PPUSH
65452: CALL_OW 250
65456: PUSH
65457: LD_VAR 0 1
65461: PPUSH
65462: CALL_OW 251
65466: PUSH
65467: LD_VAR 0 1
65471: PPUSH
65472: CALL_OW 254
65476: PUSH
65477: EMPTY
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: PPUSH
65483: CALL 72673 0 3
65487: ST_TO_ADDR
// if pos = 1 then
65488: LD_VAR 0 6
65492: PUSH
65493: LD_INT 1
65495: EQUAL
65496: IFFALSE 65611
// begin tmp := mc_build_list [ i ] ;
65498: LD_ADDR_VAR 0 7
65502: PUSH
65503: LD_EXP 105
65507: PUSH
65508: LD_VAR 0 3
65512: ARRAY
65513: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65514: LD_VAR 0 7
65518: PPUSH
65519: LD_INT 2
65521: PUSH
65522: LD_INT 30
65524: PUSH
65525: LD_INT 0
65527: PUSH
65528: EMPTY
65529: LIST
65530: LIST
65531: PUSH
65532: LD_INT 30
65534: PUSH
65535: LD_INT 1
65537: PUSH
65538: EMPTY
65539: LIST
65540: LIST
65541: PUSH
65542: EMPTY
65543: LIST
65544: LIST
65545: LIST
65546: PPUSH
65547: CALL_OW 72
65551: IFFALSE 65561
// pos := 2 ;
65553: LD_ADDR_VAR 0 6
65557: PUSH
65558: LD_INT 2
65560: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65561: LD_ADDR_VAR 0 7
65565: PUSH
65566: LD_VAR 0 7
65570: PPUSH
65571: LD_VAR 0 6
65575: PPUSH
65576: LD_VAR 0 7
65580: PPUSH
65581: CALL 72999 0 3
65585: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
65586: LD_ADDR_EXP 105
65590: PUSH
65591: LD_EXP 105
65595: PPUSH
65596: LD_VAR 0 3
65600: PPUSH
65601: LD_VAR 0 7
65605: PPUSH
65606: CALL_OW 1
65610: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
65611: LD_VAR 0 1
65615: PUSH
65616: LD_EXP 100
65620: PUSH
65621: LD_VAR 0 3
65625: ARRAY
65626: IN
65627: IFFALSE 65666
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
65629: LD_ADDR_EXP 100
65633: PUSH
65634: LD_EXP 100
65638: PPUSH
65639: LD_VAR 0 3
65643: PPUSH
65644: LD_EXP 100
65648: PUSH
65649: LD_VAR 0 3
65653: ARRAY
65654: PUSH
65655: LD_VAR 0 1
65659: DIFF
65660: PPUSH
65661: CALL_OW 1
65665: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
65666: LD_VAR 0 1
65670: PUSH
65671: LD_EXP 107
65675: PUSH
65676: LD_VAR 0 3
65680: ARRAY
65681: IN
65682: IFFALSE 65721
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
65684: LD_ADDR_EXP 107
65688: PUSH
65689: LD_EXP 107
65693: PPUSH
65694: LD_VAR 0 3
65698: PPUSH
65699: LD_EXP 107
65703: PUSH
65704: LD_VAR 0 3
65708: ARRAY
65709: PUSH
65710: LD_VAR 0 1
65714: DIFF
65715: PPUSH
65716: CALL_OW 1
65720: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
65721: LD_VAR 0 1
65725: PUSH
65726: LD_EXP 119
65730: PUSH
65731: LD_VAR 0 3
65735: ARRAY
65736: IN
65737: IFFALSE 65776
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
65739: LD_ADDR_EXP 119
65743: PUSH
65744: LD_EXP 119
65748: PPUSH
65749: LD_VAR 0 3
65753: PPUSH
65754: LD_EXP 119
65758: PUSH
65759: LD_VAR 0 3
65763: ARRAY
65764: PUSH
65765: LD_VAR 0 1
65769: DIFF
65770: PPUSH
65771: CALL_OW 1
65775: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
65776: LD_VAR 0 1
65780: PUSH
65781: LD_EXP 122
65785: PUSH
65786: LD_VAR 0 3
65790: ARRAY
65791: IN
65792: IFFALSE 65831
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65794: LD_ADDR_EXP 122
65798: PUSH
65799: LD_EXP 122
65803: PPUSH
65804: LD_VAR 0 3
65808: PPUSH
65809: LD_EXP 122
65813: PUSH
65814: LD_VAR 0 3
65818: ARRAY
65819: PUSH
65820: LD_VAR 0 1
65824: DIFF
65825: PPUSH
65826: CALL_OW 1
65830: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
65831: LD_VAR 0 1
65835: PUSH
65836: LD_EXP 109
65840: PUSH
65841: LD_VAR 0 3
65845: ARRAY
65846: IN
65847: IFFALSE 65886
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
65849: LD_ADDR_EXP 109
65853: PUSH
65854: LD_EXP 109
65858: PPUSH
65859: LD_VAR 0 3
65863: PPUSH
65864: LD_EXP 109
65868: PUSH
65869: LD_VAR 0 3
65873: ARRAY
65874: PUSH
65875: LD_VAR 0 1
65879: DIFF
65880: PPUSH
65881: CALL_OW 1
65885: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
65886: LD_VAR 0 1
65890: PUSH
65891: LD_EXP 108
65895: PUSH
65896: LD_VAR 0 3
65900: ARRAY
65901: IN
65902: IFFALSE 65941
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
65904: LD_ADDR_EXP 108
65908: PUSH
65909: LD_EXP 108
65913: PPUSH
65914: LD_VAR 0 3
65918: PPUSH
65919: LD_EXP 108
65923: PUSH
65924: LD_VAR 0 3
65928: ARRAY
65929: PUSH
65930: LD_VAR 0 1
65934: DIFF
65935: PPUSH
65936: CALL_OW 1
65940: ST_TO_ADDR
// end ; break ;
65941: GO 65945
// end ;
65943: GO 64593
65945: POP
65946: POP
// end ;
65947: LD_VAR 0 2
65951: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
65952: LD_INT 0
65954: PPUSH
65955: PPUSH
65956: PPUSH
// if not mc_bases or not skirmish then
65957: LD_EXP 100
65961: NOT
65962: PUSH
65963: LD_EXP 98
65967: NOT
65968: OR
65969: IFFALSE 65973
// exit ;
65971: GO 66188
// for i = 1 to mc_bases do
65973: LD_ADDR_VAR 0 3
65977: PUSH
65978: DOUBLE
65979: LD_INT 1
65981: DEC
65982: ST_TO_ADDR
65983: LD_EXP 100
65987: PUSH
65988: FOR_TO
65989: IFFALSE 66186
// begin if building in mc_construct_list [ i ] then
65991: LD_VAR 0 1
65995: PUSH
65996: LD_EXP 107
66000: PUSH
66001: LD_VAR 0 3
66005: ARRAY
66006: IN
66007: IFFALSE 66184
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66009: LD_ADDR_EXP 107
66013: PUSH
66014: LD_EXP 107
66018: PPUSH
66019: LD_VAR 0 3
66023: PPUSH
66024: LD_EXP 107
66028: PUSH
66029: LD_VAR 0 3
66033: ARRAY
66034: PUSH
66035: LD_VAR 0 1
66039: DIFF
66040: PPUSH
66041: CALL_OW 1
66045: ST_TO_ADDR
// if building in mc_lab [ i ] then
66046: LD_VAR 0 1
66050: PUSH
66051: LD_EXP 133
66055: PUSH
66056: LD_VAR 0 3
66060: ARRAY
66061: IN
66062: IFFALSE 66117
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
66064: LD_ADDR_EXP 134
66068: PUSH
66069: LD_EXP 134
66073: PPUSH
66074: LD_VAR 0 3
66078: PPUSH
66079: LD_EXP 134
66083: PUSH
66084: LD_VAR 0 3
66088: ARRAY
66089: PPUSH
66090: LD_INT 1
66092: PPUSH
66093: LD_EXP 134
66097: PUSH
66098: LD_VAR 0 3
66102: ARRAY
66103: PPUSH
66104: LD_INT 0
66106: PPUSH
66107: CALL 72091 0 4
66111: PPUSH
66112: CALL_OW 1
66116: ST_TO_ADDR
// if not building in mc_bases [ i ] then
66117: LD_VAR 0 1
66121: PUSH
66122: LD_EXP 100
66126: PUSH
66127: LD_VAR 0 3
66131: ARRAY
66132: IN
66133: NOT
66134: IFFALSE 66180
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66136: LD_ADDR_EXP 100
66140: PUSH
66141: LD_EXP 100
66145: PPUSH
66146: LD_VAR 0 3
66150: PUSH
66151: LD_EXP 100
66155: PUSH
66156: LD_VAR 0 3
66160: ARRAY
66161: PUSH
66162: LD_INT 1
66164: PLUS
66165: PUSH
66166: EMPTY
66167: LIST
66168: LIST
66169: PPUSH
66170: LD_VAR 0 1
66174: PPUSH
66175: CALL 72673 0 3
66179: ST_TO_ADDR
// exit ;
66180: POP
66181: POP
66182: GO 66188
// end ; end ;
66184: GO 65988
66186: POP
66187: POP
// end ;
66188: LD_VAR 0 2
66192: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
66193: LD_INT 0
66195: PPUSH
66196: PPUSH
66197: PPUSH
66198: PPUSH
66199: PPUSH
66200: PPUSH
66201: PPUSH
// if not mc_bases or not skirmish then
66202: LD_EXP 100
66206: NOT
66207: PUSH
66208: LD_EXP 98
66212: NOT
66213: OR
66214: IFFALSE 66218
// exit ;
66216: GO 66879
// for i = 1 to mc_bases do
66218: LD_ADDR_VAR 0 3
66222: PUSH
66223: DOUBLE
66224: LD_INT 1
66226: DEC
66227: ST_TO_ADDR
66228: LD_EXP 100
66232: PUSH
66233: FOR_TO
66234: IFFALSE 66877
// begin if building in mc_construct_list [ i ] then
66236: LD_VAR 0 1
66240: PUSH
66241: LD_EXP 107
66245: PUSH
66246: LD_VAR 0 3
66250: ARRAY
66251: IN
66252: IFFALSE 66875
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66254: LD_ADDR_EXP 107
66258: PUSH
66259: LD_EXP 107
66263: PPUSH
66264: LD_VAR 0 3
66268: PPUSH
66269: LD_EXP 107
66273: PUSH
66274: LD_VAR 0 3
66278: ARRAY
66279: PUSH
66280: LD_VAR 0 1
66284: DIFF
66285: PPUSH
66286: CALL_OW 1
66290: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66291: LD_ADDR_EXP 100
66295: PUSH
66296: LD_EXP 100
66300: PPUSH
66301: LD_VAR 0 3
66305: PUSH
66306: LD_EXP 100
66310: PUSH
66311: LD_VAR 0 3
66315: ARRAY
66316: PUSH
66317: LD_INT 1
66319: PLUS
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PPUSH
66325: LD_VAR 0 1
66329: PPUSH
66330: CALL 72673 0 3
66334: ST_TO_ADDR
// btype := GetBType ( building ) ;
66335: LD_ADDR_VAR 0 5
66339: PUSH
66340: LD_VAR 0 1
66344: PPUSH
66345: CALL_OW 266
66349: ST_TO_ADDR
// side := GetSide ( building ) ;
66350: LD_ADDR_VAR 0 8
66354: PUSH
66355: LD_VAR 0 1
66359: PPUSH
66360: CALL_OW 255
66364: ST_TO_ADDR
// if btype = b_lab then
66365: LD_VAR 0 5
66369: PUSH
66370: LD_INT 6
66372: EQUAL
66373: IFFALSE 66423
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66375: LD_ADDR_EXP 133
66379: PUSH
66380: LD_EXP 133
66384: PPUSH
66385: LD_VAR 0 3
66389: PUSH
66390: LD_EXP 133
66394: PUSH
66395: LD_VAR 0 3
66399: ARRAY
66400: PUSH
66401: LD_INT 1
66403: PLUS
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PPUSH
66409: LD_VAR 0 1
66413: PPUSH
66414: CALL 72673 0 3
66418: ST_TO_ADDR
// exit ;
66419: POP
66420: POP
66421: GO 66879
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66423: LD_VAR 0 5
66427: PUSH
66428: LD_INT 0
66430: PUSH
66431: LD_INT 2
66433: PUSH
66434: LD_INT 4
66436: PUSH
66437: EMPTY
66438: LIST
66439: LIST
66440: LIST
66441: IN
66442: IFFALSE 66566
// begin if btype = b_armoury then
66444: LD_VAR 0 5
66448: PUSH
66449: LD_INT 4
66451: EQUAL
66452: IFFALSE 66462
// btype := b_barracks ;
66454: LD_ADDR_VAR 0 5
66458: PUSH
66459: LD_INT 5
66461: ST_TO_ADDR
// if btype = b_depot then
66462: LD_VAR 0 5
66466: PUSH
66467: LD_INT 0
66469: EQUAL
66470: IFFALSE 66480
// btype := b_warehouse ;
66472: LD_ADDR_VAR 0 5
66476: PUSH
66477: LD_INT 1
66479: ST_TO_ADDR
// if btype = b_workshop then
66480: LD_VAR 0 5
66484: PUSH
66485: LD_INT 2
66487: EQUAL
66488: IFFALSE 66498
// btype := b_factory ;
66490: LD_ADDR_VAR 0 5
66494: PUSH
66495: LD_INT 3
66497: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66498: LD_VAR 0 5
66502: PPUSH
66503: LD_VAR 0 8
66507: PPUSH
66508: CALL_OW 323
66512: PUSH
66513: LD_INT 1
66515: EQUAL
66516: IFFALSE 66562
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66518: LD_ADDR_EXP 132
66522: PUSH
66523: LD_EXP 132
66527: PPUSH
66528: LD_VAR 0 3
66532: PUSH
66533: LD_EXP 132
66537: PUSH
66538: LD_VAR 0 3
66542: ARRAY
66543: PUSH
66544: LD_INT 1
66546: PLUS
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PPUSH
66552: LD_VAR 0 1
66556: PPUSH
66557: CALL 72673 0 3
66561: ST_TO_ADDR
// exit ;
66562: POP
66563: POP
66564: GO 66879
// end ; if btype in [ b_bunker , b_turret ] then
66566: LD_VAR 0 5
66570: PUSH
66571: LD_INT 32
66573: PUSH
66574: LD_INT 33
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: IN
66581: IFFALSE 66871
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
66583: LD_ADDR_EXP 108
66587: PUSH
66588: LD_EXP 108
66592: PPUSH
66593: LD_VAR 0 3
66597: PUSH
66598: LD_EXP 108
66602: PUSH
66603: LD_VAR 0 3
66607: ARRAY
66608: PUSH
66609: LD_INT 1
66611: PLUS
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PPUSH
66617: LD_VAR 0 1
66621: PPUSH
66622: CALL 72673 0 3
66626: ST_TO_ADDR
// if btype = b_bunker then
66627: LD_VAR 0 5
66631: PUSH
66632: LD_INT 32
66634: EQUAL
66635: IFFALSE 66871
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66637: LD_ADDR_EXP 109
66641: PUSH
66642: LD_EXP 109
66646: PPUSH
66647: LD_VAR 0 3
66651: PUSH
66652: LD_EXP 109
66656: PUSH
66657: LD_VAR 0 3
66661: ARRAY
66662: PUSH
66663: LD_INT 1
66665: PLUS
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PPUSH
66671: LD_VAR 0 1
66675: PPUSH
66676: CALL 72673 0 3
66680: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
66681: LD_ADDR_VAR 0 6
66685: PUSH
66686: LD_EXP 100
66690: PUSH
66691: LD_VAR 0 3
66695: ARRAY
66696: PPUSH
66697: LD_INT 25
66699: PUSH
66700: LD_INT 1
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: LD_INT 3
66709: PUSH
66710: LD_INT 54
66712: PUSH
66713: EMPTY
66714: LIST
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: EMPTY
66721: LIST
66722: LIST
66723: PPUSH
66724: CALL_OW 72
66728: ST_TO_ADDR
// if tmp then
66729: LD_VAR 0 6
66733: IFFALSE 66739
// exit ;
66735: POP
66736: POP
66737: GO 66879
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66739: LD_ADDR_VAR 0 6
66743: PUSH
66744: LD_EXP 100
66748: PUSH
66749: LD_VAR 0 3
66753: ARRAY
66754: PPUSH
66755: LD_INT 2
66757: PUSH
66758: LD_INT 30
66760: PUSH
66761: LD_INT 4
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: PUSH
66768: LD_INT 30
66770: PUSH
66771: LD_INT 5
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: LIST
66782: PPUSH
66783: CALL_OW 72
66787: ST_TO_ADDR
// if not tmp then
66788: LD_VAR 0 6
66792: NOT
66793: IFFALSE 66799
// exit ;
66795: POP
66796: POP
66797: GO 66879
// for j in tmp do
66799: LD_ADDR_VAR 0 4
66803: PUSH
66804: LD_VAR 0 6
66808: PUSH
66809: FOR_IN
66810: IFFALSE 66869
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
66812: LD_ADDR_VAR 0 7
66816: PUSH
66817: LD_VAR 0 4
66821: PPUSH
66822: CALL_OW 313
66826: PPUSH
66827: LD_INT 25
66829: PUSH
66830: LD_INT 1
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PPUSH
66837: CALL_OW 72
66841: ST_TO_ADDR
// if units then
66842: LD_VAR 0 7
66846: IFFALSE 66867
// begin ComExitBuilding ( units [ 1 ] ) ;
66848: LD_VAR 0 7
66852: PUSH
66853: LD_INT 1
66855: ARRAY
66856: PPUSH
66857: CALL_OW 122
// exit ;
66861: POP
66862: POP
66863: POP
66864: POP
66865: GO 66879
// end ; end ;
66867: GO 66809
66869: POP
66870: POP
// end ; end ; exit ;
66871: POP
66872: POP
66873: GO 66879
// end ; end ;
66875: GO 66233
66877: POP
66878: POP
// end ;
66879: LD_VAR 0 2
66883: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
66884: LD_INT 0
66886: PPUSH
66887: PPUSH
66888: PPUSH
66889: PPUSH
66890: PPUSH
66891: PPUSH
66892: PPUSH
// if not mc_bases or not skirmish then
66893: LD_EXP 100
66897: NOT
66898: PUSH
66899: LD_EXP 98
66903: NOT
66904: OR
66905: IFFALSE 66909
// exit ;
66907: GO 67174
// btype := GetBType ( building ) ;
66909: LD_ADDR_VAR 0 6
66913: PUSH
66914: LD_VAR 0 1
66918: PPUSH
66919: CALL_OW 266
66923: ST_TO_ADDR
// x := GetX ( building ) ;
66924: LD_ADDR_VAR 0 7
66928: PUSH
66929: LD_VAR 0 1
66933: PPUSH
66934: CALL_OW 250
66938: ST_TO_ADDR
// y := GetY ( building ) ;
66939: LD_ADDR_VAR 0 8
66943: PUSH
66944: LD_VAR 0 1
66948: PPUSH
66949: CALL_OW 251
66953: ST_TO_ADDR
// d := GetDir ( building ) ;
66954: LD_ADDR_VAR 0 9
66958: PUSH
66959: LD_VAR 0 1
66963: PPUSH
66964: CALL_OW 254
66968: ST_TO_ADDR
// for i = 1 to mc_bases do
66969: LD_ADDR_VAR 0 4
66973: PUSH
66974: DOUBLE
66975: LD_INT 1
66977: DEC
66978: ST_TO_ADDR
66979: LD_EXP 100
66983: PUSH
66984: FOR_TO
66985: IFFALSE 67172
// begin if not mc_build_list [ i ] then
66987: LD_EXP 105
66991: PUSH
66992: LD_VAR 0 4
66996: ARRAY
66997: NOT
66998: IFFALSE 67002
// continue ;
67000: GO 66984
// for j := 1 to mc_build_list [ i ] do
67002: LD_ADDR_VAR 0 5
67006: PUSH
67007: DOUBLE
67008: LD_INT 1
67010: DEC
67011: ST_TO_ADDR
67012: LD_EXP 105
67016: PUSH
67017: LD_VAR 0 4
67021: ARRAY
67022: PUSH
67023: FOR_TO
67024: IFFALSE 67168
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
67026: LD_VAR 0 6
67030: PUSH
67031: LD_VAR 0 7
67035: PUSH
67036: LD_VAR 0 8
67040: PUSH
67041: LD_VAR 0 9
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: PPUSH
67052: LD_EXP 105
67056: PUSH
67057: LD_VAR 0 4
67061: ARRAY
67062: PUSH
67063: LD_VAR 0 5
67067: ARRAY
67068: PPUSH
67069: CALL 78853 0 2
67073: IFFALSE 67166
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
67075: LD_ADDR_EXP 105
67079: PUSH
67080: LD_EXP 105
67084: PPUSH
67085: LD_VAR 0 4
67089: PPUSH
67090: LD_EXP 105
67094: PUSH
67095: LD_VAR 0 4
67099: ARRAY
67100: PPUSH
67101: LD_VAR 0 5
67105: PPUSH
67106: CALL_OW 3
67110: PPUSH
67111: CALL_OW 1
67115: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
67116: LD_ADDR_EXP 107
67120: PUSH
67121: LD_EXP 107
67125: PPUSH
67126: LD_VAR 0 4
67130: PUSH
67131: LD_EXP 107
67135: PUSH
67136: LD_VAR 0 4
67140: ARRAY
67141: PUSH
67142: LD_INT 1
67144: PLUS
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PPUSH
67150: LD_VAR 0 1
67154: PPUSH
67155: CALL 72673 0 3
67159: ST_TO_ADDR
// exit ;
67160: POP
67161: POP
67162: POP
67163: POP
67164: GO 67174
// end ;
67166: GO 67023
67168: POP
67169: POP
// end ;
67170: GO 66984
67172: POP
67173: POP
// end ;
67174: LD_VAR 0 3
67178: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
67179: LD_INT 0
67181: PPUSH
67182: PPUSH
67183: PPUSH
// if not mc_bases or not skirmish then
67184: LD_EXP 100
67188: NOT
67189: PUSH
67190: LD_EXP 98
67194: NOT
67195: OR
67196: IFFALSE 67200
// exit ;
67198: GO 67390
// for i = 1 to mc_bases do
67200: LD_ADDR_VAR 0 4
67204: PUSH
67205: DOUBLE
67206: LD_INT 1
67208: DEC
67209: ST_TO_ADDR
67210: LD_EXP 100
67214: PUSH
67215: FOR_TO
67216: IFFALSE 67303
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
67218: LD_VAR 0 1
67222: PUSH
67223: LD_EXP 108
67227: PUSH
67228: LD_VAR 0 4
67232: ARRAY
67233: IN
67234: PUSH
67235: LD_VAR 0 1
67239: PUSH
67240: LD_EXP 109
67244: PUSH
67245: LD_VAR 0 4
67249: ARRAY
67250: IN
67251: NOT
67252: AND
67253: IFFALSE 67301
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67255: LD_ADDR_EXP 109
67259: PUSH
67260: LD_EXP 109
67264: PPUSH
67265: LD_VAR 0 4
67269: PUSH
67270: LD_EXP 109
67274: PUSH
67275: LD_VAR 0 4
67279: ARRAY
67280: PUSH
67281: LD_INT 1
67283: PLUS
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: PPUSH
67289: LD_VAR 0 1
67293: PPUSH
67294: CALL 72673 0 3
67298: ST_TO_ADDR
// break ;
67299: GO 67303
// end ; end ;
67301: GO 67215
67303: POP
67304: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
67305: LD_VAR 0 1
67309: PPUSH
67310: CALL_OW 257
67314: PUSH
67315: LD_EXP 126
67319: IN
67320: PUSH
67321: LD_VAR 0 1
67325: PPUSH
67326: CALL_OW 266
67330: PUSH
67331: LD_INT 5
67333: EQUAL
67334: AND
67335: PUSH
67336: LD_VAR 0 2
67340: PPUSH
67341: CALL_OW 110
67345: PUSH
67346: LD_INT 18
67348: NONEQUAL
67349: AND
67350: IFFALSE 67390
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67352: LD_VAR 0 2
67356: PPUSH
67357: CALL_OW 257
67361: PUSH
67362: LD_INT 5
67364: PUSH
67365: LD_INT 8
67367: PUSH
67368: LD_INT 9
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: LIST
67375: IN
67376: IFFALSE 67390
// SetClass ( unit , 1 ) ;
67378: LD_VAR 0 2
67382: PPUSH
67383: LD_INT 1
67385: PPUSH
67386: CALL_OW 336
// end ;
67390: LD_VAR 0 3
67394: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67395: LD_INT 0
67397: PPUSH
67398: PPUSH
// if not mc_bases or not skirmish then
67399: LD_EXP 100
67403: NOT
67404: PUSH
67405: LD_EXP 98
67409: NOT
67410: OR
67411: IFFALSE 67415
// exit ;
67413: GO 67531
// if GetLives ( abandoned_vehicle ) > 250 then
67415: LD_VAR 0 2
67419: PPUSH
67420: CALL_OW 256
67424: PUSH
67425: LD_INT 250
67427: GREATER
67428: IFFALSE 67432
// exit ;
67430: GO 67531
// for i = 1 to mc_bases do
67432: LD_ADDR_VAR 0 6
67436: PUSH
67437: DOUBLE
67438: LD_INT 1
67440: DEC
67441: ST_TO_ADDR
67442: LD_EXP 100
67446: PUSH
67447: FOR_TO
67448: IFFALSE 67529
// begin if driver in mc_bases [ i ] then
67450: LD_VAR 0 1
67454: PUSH
67455: LD_EXP 100
67459: PUSH
67460: LD_VAR 0 6
67464: ARRAY
67465: IN
67466: IFFALSE 67527
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67468: LD_VAR 0 1
67472: PPUSH
67473: LD_EXP 100
67477: PUSH
67478: LD_VAR 0 6
67482: ARRAY
67483: PPUSH
67484: LD_INT 2
67486: PUSH
67487: LD_INT 30
67489: PUSH
67490: LD_INT 0
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PUSH
67497: LD_INT 30
67499: PUSH
67500: LD_INT 1
67502: PUSH
67503: EMPTY
67504: LIST
67505: LIST
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: LIST
67511: PPUSH
67512: CALL_OW 72
67516: PUSH
67517: LD_INT 1
67519: ARRAY
67520: PPUSH
67521: CALL 105881 0 2
// break ;
67525: GO 67529
// end ; end ;
67527: GO 67447
67529: POP
67530: POP
// end ; end_of_file
67531: LD_VAR 0 5
67535: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67536: LD_INT 0
67538: PPUSH
67539: PPUSH
// if exist_mode then
67540: LD_VAR 0 2
67544: IFFALSE 67569
// unit := CreateCharacter ( prefix & ident ) else
67546: LD_ADDR_VAR 0 5
67550: PUSH
67551: LD_VAR 0 3
67555: PUSH
67556: LD_VAR 0 1
67560: STR
67561: PPUSH
67562: CALL_OW 34
67566: ST_TO_ADDR
67567: GO 67584
// unit := NewCharacter ( ident ) ;
67569: LD_ADDR_VAR 0 5
67573: PUSH
67574: LD_VAR 0 1
67578: PPUSH
67579: CALL_OW 25
67583: ST_TO_ADDR
// result := unit ;
67584: LD_ADDR_VAR 0 4
67588: PUSH
67589: LD_VAR 0 5
67593: ST_TO_ADDR
// end ;
67594: LD_VAR 0 4
67598: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
67599: LD_INT 0
67601: PPUSH
67602: PPUSH
// if not side or not nation then
67603: LD_VAR 0 1
67607: NOT
67608: PUSH
67609: LD_VAR 0 2
67613: NOT
67614: OR
67615: IFFALSE 67619
// exit ;
67617: GO 68387
// case nation of nation_american :
67619: LD_VAR 0 2
67623: PUSH
67624: LD_INT 1
67626: DOUBLE
67627: EQUAL
67628: IFTRUE 67632
67630: GO 67846
67632: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
67633: LD_ADDR_VAR 0 4
67637: PUSH
67638: LD_INT 35
67640: PUSH
67641: LD_INT 45
67643: PUSH
67644: LD_INT 46
67646: PUSH
67647: LD_INT 47
67649: PUSH
67650: LD_INT 82
67652: PUSH
67653: LD_INT 83
67655: PUSH
67656: LD_INT 84
67658: PUSH
67659: LD_INT 85
67661: PUSH
67662: LD_INT 86
67664: PUSH
67665: LD_INT 1
67667: PUSH
67668: LD_INT 2
67670: PUSH
67671: LD_INT 6
67673: PUSH
67674: LD_INT 15
67676: PUSH
67677: LD_INT 16
67679: PUSH
67680: LD_INT 7
67682: PUSH
67683: LD_INT 12
67685: PUSH
67686: LD_INT 13
67688: PUSH
67689: LD_INT 10
67691: PUSH
67692: LD_INT 14
67694: PUSH
67695: LD_INT 20
67697: PUSH
67698: LD_INT 21
67700: PUSH
67701: LD_INT 22
67703: PUSH
67704: LD_INT 25
67706: PUSH
67707: LD_INT 32
67709: PUSH
67710: LD_INT 27
67712: PUSH
67713: LD_INT 36
67715: PUSH
67716: LD_INT 69
67718: PUSH
67719: LD_INT 39
67721: PUSH
67722: LD_INT 34
67724: PUSH
67725: LD_INT 40
67727: PUSH
67728: LD_INT 48
67730: PUSH
67731: LD_INT 49
67733: PUSH
67734: LD_INT 50
67736: PUSH
67737: LD_INT 51
67739: PUSH
67740: LD_INT 52
67742: PUSH
67743: LD_INT 53
67745: PUSH
67746: LD_INT 54
67748: PUSH
67749: LD_INT 55
67751: PUSH
67752: LD_INT 56
67754: PUSH
67755: LD_INT 57
67757: PUSH
67758: LD_INT 58
67760: PUSH
67761: LD_INT 59
67763: PUSH
67764: LD_INT 60
67766: PUSH
67767: LD_INT 61
67769: PUSH
67770: LD_INT 62
67772: PUSH
67773: LD_INT 80
67775: PUSH
67776: LD_INT 82
67778: PUSH
67779: LD_INT 83
67781: PUSH
67782: LD_INT 84
67784: PUSH
67785: LD_INT 85
67787: PUSH
67788: LD_INT 86
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: LIST
67795: LIST
67796: LIST
67797: LIST
67798: LIST
67799: LIST
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: LIST
67810: LIST
67811: LIST
67812: LIST
67813: LIST
67814: LIST
67815: LIST
67816: LIST
67817: LIST
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: LIST
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: ST_TO_ADDR
67844: GO 68311
67846: LD_INT 2
67848: DOUBLE
67849: EQUAL
67850: IFTRUE 67854
67852: GO 68080
67854: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
67855: LD_ADDR_VAR 0 4
67859: PUSH
67860: LD_INT 35
67862: PUSH
67863: LD_INT 45
67865: PUSH
67866: LD_INT 46
67868: PUSH
67869: LD_INT 47
67871: PUSH
67872: LD_INT 82
67874: PUSH
67875: LD_INT 83
67877: PUSH
67878: LD_INT 84
67880: PUSH
67881: LD_INT 85
67883: PUSH
67884: LD_INT 87
67886: PUSH
67887: LD_INT 70
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: LD_INT 11
67895: PUSH
67896: LD_INT 3
67898: PUSH
67899: LD_INT 4
67901: PUSH
67902: LD_INT 5
67904: PUSH
67905: LD_INT 6
67907: PUSH
67908: LD_INT 15
67910: PUSH
67911: LD_INT 18
67913: PUSH
67914: LD_INT 7
67916: PUSH
67917: LD_INT 17
67919: PUSH
67920: LD_INT 8
67922: PUSH
67923: LD_INT 20
67925: PUSH
67926: LD_INT 21
67928: PUSH
67929: LD_INT 22
67931: PUSH
67932: LD_INT 72
67934: PUSH
67935: LD_INT 26
67937: PUSH
67938: LD_INT 69
67940: PUSH
67941: LD_INT 39
67943: PUSH
67944: LD_INT 40
67946: PUSH
67947: LD_INT 41
67949: PUSH
67950: LD_INT 42
67952: PUSH
67953: LD_INT 43
67955: PUSH
67956: LD_INT 48
67958: PUSH
67959: LD_INT 49
67961: PUSH
67962: LD_INT 50
67964: PUSH
67965: LD_INT 51
67967: PUSH
67968: LD_INT 52
67970: PUSH
67971: LD_INT 53
67973: PUSH
67974: LD_INT 54
67976: PUSH
67977: LD_INT 55
67979: PUSH
67980: LD_INT 56
67982: PUSH
67983: LD_INT 60
67985: PUSH
67986: LD_INT 61
67988: PUSH
67989: LD_INT 62
67991: PUSH
67992: LD_INT 66
67994: PUSH
67995: LD_INT 67
67997: PUSH
67998: LD_INT 68
68000: PUSH
68001: LD_INT 81
68003: PUSH
68004: LD_INT 82
68006: PUSH
68007: LD_INT 83
68009: PUSH
68010: LD_INT 84
68012: PUSH
68013: LD_INT 85
68015: PUSH
68016: LD_INT 87
68018: PUSH
68019: LD_INT 88
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: LIST
68026: LIST
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: ST_TO_ADDR
68078: GO 68311
68080: LD_INT 3
68082: DOUBLE
68083: EQUAL
68084: IFTRUE 68088
68086: GO 68310
68088: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
68089: LD_ADDR_VAR 0 4
68093: PUSH
68094: LD_INT 46
68096: PUSH
68097: LD_INT 47
68099: PUSH
68100: LD_INT 1
68102: PUSH
68103: LD_INT 2
68105: PUSH
68106: LD_INT 82
68108: PUSH
68109: LD_INT 83
68111: PUSH
68112: LD_INT 84
68114: PUSH
68115: LD_INT 85
68117: PUSH
68118: LD_INT 86
68120: PUSH
68121: LD_INT 11
68123: PUSH
68124: LD_INT 9
68126: PUSH
68127: LD_INT 20
68129: PUSH
68130: LD_INT 19
68132: PUSH
68133: LD_INT 21
68135: PUSH
68136: LD_INT 24
68138: PUSH
68139: LD_INT 22
68141: PUSH
68142: LD_INT 25
68144: PUSH
68145: LD_INT 28
68147: PUSH
68148: LD_INT 29
68150: PUSH
68151: LD_INT 30
68153: PUSH
68154: LD_INT 31
68156: PUSH
68157: LD_INT 37
68159: PUSH
68160: LD_INT 38
68162: PUSH
68163: LD_INT 32
68165: PUSH
68166: LD_INT 27
68168: PUSH
68169: LD_INT 33
68171: PUSH
68172: LD_INT 69
68174: PUSH
68175: LD_INT 39
68177: PUSH
68178: LD_INT 34
68180: PUSH
68181: LD_INT 40
68183: PUSH
68184: LD_INT 71
68186: PUSH
68187: LD_INT 23
68189: PUSH
68190: LD_INT 44
68192: PUSH
68193: LD_INT 48
68195: PUSH
68196: LD_INT 49
68198: PUSH
68199: LD_INT 50
68201: PUSH
68202: LD_INT 51
68204: PUSH
68205: LD_INT 52
68207: PUSH
68208: LD_INT 53
68210: PUSH
68211: LD_INT 54
68213: PUSH
68214: LD_INT 55
68216: PUSH
68217: LD_INT 56
68219: PUSH
68220: LD_INT 57
68222: PUSH
68223: LD_INT 58
68225: PUSH
68226: LD_INT 59
68228: PUSH
68229: LD_INT 63
68231: PUSH
68232: LD_INT 64
68234: PUSH
68235: LD_INT 65
68237: PUSH
68238: LD_INT 82
68240: PUSH
68241: LD_INT 83
68243: PUSH
68244: LD_INT 84
68246: PUSH
68247: LD_INT 85
68249: PUSH
68250: LD_INT 86
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: LIST
68257: LIST
68258: LIST
68259: LIST
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: ST_TO_ADDR
68308: GO 68311
68310: POP
// if state > - 1 and state < 3 then
68311: LD_VAR 0 3
68315: PUSH
68316: LD_INT 1
68318: NEG
68319: GREATER
68320: PUSH
68321: LD_VAR 0 3
68325: PUSH
68326: LD_INT 3
68328: LESS
68329: AND
68330: IFFALSE 68387
// for i in result do
68332: LD_ADDR_VAR 0 5
68336: PUSH
68337: LD_VAR 0 4
68341: PUSH
68342: FOR_IN
68343: IFFALSE 68385
// if GetTech ( i , side ) <> state then
68345: LD_VAR 0 5
68349: PPUSH
68350: LD_VAR 0 1
68354: PPUSH
68355: CALL_OW 321
68359: PUSH
68360: LD_VAR 0 3
68364: NONEQUAL
68365: IFFALSE 68383
// result := result diff i ;
68367: LD_ADDR_VAR 0 4
68371: PUSH
68372: LD_VAR 0 4
68376: PUSH
68377: LD_VAR 0 5
68381: DIFF
68382: ST_TO_ADDR
68383: GO 68342
68385: POP
68386: POP
// end ;
68387: LD_VAR 0 4
68391: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68392: LD_INT 0
68394: PPUSH
68395: PPUSH
68396: PPUSH
// result := true ;
68397: LD_ADDR_VAR 0 3
68401: PUSH
68402: LD_INT 1
68404: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68405: LD_ADDR_VAR 0 5
68409: PUSH
68410: LD_VAR 0 2
68414: PPUSH
68415: CALL_OW 480
68419: ST_TO_ADDR
// if not tmp then
68420: LD_VAR 0 5
68424: NOT
68425: IFFALSE 68429
// exit ;
68427: GO 68478
// for i in tmp do
68429: LD_ADDR_VAR 0 4
68433: PUSH
68434: LD_VAR 0 5
68438: PUSH
68439: FOR_IN
68440: IFFALSE 68476
// if GetTech ( i , side ) <> state_researched then
68442: LD_VAR 0 4
68446: PPUSH
68447: LD_VAR 0 1
68451: PPUSH
68452: CALL_OW 321
68456: PUSH
68457: LD_INT 2
68459: NONEQUAL
68460: IFFALSE 68474
// begin result := false ;
68462: LD_ADDR_VAR 0 3
68466: PUSH
68467: LD_INT 0
68469: ST_TO_ADDR
// exit ;
68470: POP
68471: POP
68472: GO 68478
// end ;
68474: GO 68439
68476: POP
68477: POP
// end ;
68478: LD_VAR 0 3
68482: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68483: LD_INT 0
68485: PPUSH
68486: PPUSH
68487: PPUSH
68488: PPUSH
68489: PPUSH
68490: PPUSH
68491: PPUSH
68492: PPUSH
68493: PPUSH
68494: PPUSH
68495: PPUSH
68496: PPUSH
68497: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68498: LD_VAR 0 1
68502: NOT
68503: PUSH
68504: LD_VAR 0 1
68508: PPUSH
68509: CALL_OW 257
68513: PUSH
68514: LD_INT 9
68516: NONEQUAL
68517: OR
68518: IFFALSE 68522
// exit ;
68520: GO 69095
// side := GetSide ( unit ) ;
68522: LD_ADDR_VAR 0 9
68526: PUSH
68527: LD_VAR 0 1
68531: PPUSH
68532: CALL_OW 255
68536: ST_TO_ADDR
// tech_space := tech_spacanom ;
68537: LD_ADDR_VAR 0 12
68541: PUSH
68542: LD_INT 29
68544: ST_TO_ADDR
// tech_time := tech_taurad ;
68545: LD_ADDR_VAR 0 13
68549: PUSH
68550: LD_INT 28
68552: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68553: LD_ADDR_VAR 0 11
68557: PUSH
68558: LD_VAR 0 1
68562: PPUSH
68563: CALL_OW 310
68567: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
68568: LD_VAR 0 11
68572: PPUSH
68573: CALL_OW 247
68577: PUSH
68578: LD_INT 2
68580: EQUAL
68581: IFFALSE 68585
// exit ;
68583: GO 69095
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68585: LD_ADDR_VAR 0 8
68589: PUSH
68590: LD_INT 81
68592: PUSH
68593: LD_VAR 0 9
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 3
68604: PUSH
68605: LD_INT 21
68607: PUSH
68608: LD_INT 3
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PPUSH
68623: CALL_OW 69
68627: ST_TO_ADDR
// if not tmp then
68628: LD_VAR 0 8
68632: NOT
68633: IFFALSE 68637
// exit ;
68635: GO 69095
// if in_unit then
68637: LD_VAR 0 11
68641: IFFALSE 68665
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
68643: LD_ADDR_VAR 0 10
68647: PUSH
68648: LD_VAR 0 8
68652: PPUSH
68653: LD_VAR 0 11
68657: PPUSH
68658: CALL_OW 74
68662: ST_TO_ADDR
68663: GO 68685
// enemy := NearestUnitToUnit ( tmp , unit ) ;
68665: LD_ADDR_VAR 0 10
68669: PUSH
68670: LD_VAR 0 8
68674: PPUSH
68675: LD_VAR 0 1
68679: PPUSH
68680: CALL_OW 74
68684: ST_TO_ADDR
// if not enemy then
68685: LD_VAR 0 10
68689: NOT
68690: IFFALSE 68694
// exit ;
68692: GO 69095
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
68694: LD_VAR 0 11
68698: PUSH
68699: LD_VAR 0 11
68703: PPUSH
68704: LD_VAR 0 10
68708: PPUSH
68709: CALL_OW 296
68713: PUSH
68714: LD_INT 13
68716: GREATER
68717: AND
68718: PUSH
68719: LD_VAR 0 1
68723: PPUSH
68724: LD_VAR 0 10
68728: PPUSH
68729: CALL_OW 296
68733: PUSH
68734: LD_INT 12
68736: GREATER
68737: OR
68738: IFFALSE 68742
// exit ;
68740: GO 69095
// missile := [ 1 ] ;
68742: LD_ADDR_VAR 0 14
68746: PUSH
68747: LD_INT 1
68749: PUSH
68750: EMPTY
68751: LIST
68752: ST_TO_ADDR
// if Researched ( side , tech_space ) then
68753: LD_VAR 0 9
68757: PPUSH
68758: LD_VAR 0 12
68762: PPUSH
68763: CALL_OW 325
68767: IFFALSE 68796
// missile := Replace ( missile , missile + 1 , 2 ) ;
68769: LD_ADDR_VAR 0 14
68773: PUSH
68774: LD_VAR 0 14
68778: PPUSH
68779: LD_VAR 0 14
68783: PUSH
68784: LD_INT 1
68786: PLUS
68787: PPUSH
68788: LD_INT 2
68790: PPUSH
68791: CALL_OW 1
68795: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
68796: LD_VAR 0 9
68800: PPUSH
68801: LD_VAR 0 13
68805: PPUSH
68806: CALL_OW 325
68810: PUSH
68811: LD_VAR 0 10
68815: PPUSH
68816: CALL_OW 255
68820: PPUSH
68821: LD_VAR 0 13
68825: PPUSH
68826: CALL_OW 325
68830: NOT
68831: AND
68832: IFFALSE 68861
// missile := Replace ( missile , missile + 1 , 3 ) ;
68834: LD_ADDR_VAR 0 14
68838: PUSH
68839: LD_VAR 0 14
68843: PPUSH
68844: LD_VAR 0 14
68848: PUSH
68849: LD_INT 1
68851: PLUS
68852: PPUSH
68853: LD_INT 3
68855: PPUSH
68856: CALL_OW 1
68860: ST_TO_ADDR
// if missile < 2 then
68861: LD_VAR 0 14
68865: PUSH
68866: LD_INT 2
68868: LESS
68869: IFFALSE 68873
// exit ;
68871: GO 69095
// x := GetX ( enemy ) ;
68873: LD_ADDR_VAR 0 4
68877: PUSH
68878: LD_VAR 0 10
68882: PPUSH
68883: CALL_OW 250
68887: ST_TO_ADDR
// y := GetY ( enemy ) ;
68888: LD_ADDR_VAR 0 5
68892: PUSH
68893: LD_VAR 0 10
68897: PPUSH
68898: CALL_OW 251
68902: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
68903: LD_ADDR_VAR 0 6
68907: PUSH
68908: LD_VAR 0 4
68912: PUSH
68913: LD_INT 1
68915: NEG
68916: PPUSH
68917: LD_INT 1
68919: PPUSH
68920: CALL_OW 12
68924: PLUS
68925: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
68926: LD_ADDR_VAR 0 7
68930: PUSH
68931: LD_VAR 0 5
68935: PUSH
68936: LD_INT 1
68938: NEG
68939: PPUSH
68940: LD_INT 1
68942: PPUSH
68943: CALL_OW 12
68947: PLUS
68948: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68949: LD_VAR 0 6
68953: PPUSH
68954: LD_VAR 0 7
68958: PPUSH
68959: CALL_OW 488
68963: NOT
68964: IFFALSE 68986
// begin _x := x ;
68966: LD_ADDR_VAR 0 6
68970: PUSH
68971: LD_VAR 0 4
68975: ST_TO_ADDR
// _y := y ;
68976: LD_ADDR_VAR 0 7
68980: PUSH
68981: LD_VAR 0 5
68985: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
68986: LD_ADDR_VAR 0 3
68990: PUSH
68991: LD_INT 1
68993: PPUSH
68994: LD_VAR 0 14
68998: PPUSH
68999: CALL_OW 12
69003: ST_TO_ADDR
// case i of 1 :
69004: LD_VAR 0 3
69008: PUSH
69009: LD_INT 1
69011: DOUBLE
69012: EQUAL
69013: IFTRUE 69017
69015: GO 69034
69017: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
69018: LD_VAR 0 1
69022: PPUSH
69023: LD_VAR 0 10
69027: PPUSH
69028: CALL_OW 115
69032: GO 69095
69034: LD_INT 2
69036: DOUBLE
69037: EQUAL
69038: IFTRUE 69042
69040: GO 69064
69042: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
69043: LD_VAR 0 1
69047: PPUSH
69048: LD_VAR 0 6
69052: PPUSH
69053: LD_VAR 0 7
69057: PPUSH
69058: CALL_OW 153
69062: GO 69095
69064: LD_INT 3
69066: DOUBLE
69067: EQUAL
69068: IFTRUE 69072
69070: GO 69094
69072: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
69073: LD_VAR 0 1
69077: PPUSH
69078: LD_VAR 0 6
69082: PPUSH
69083: LD_VAR 0 7
69087: PPUSH
69088: CALL_OW 154
69092: GO 69095
69094: POP
// end ;
69095: LD_VAR 0 2
69099: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
69100: LD_INT 0
69102: PPUSH
69103: PPUSH
69104: PPUSH
69105: PPUSH
69106: PPUSH
69107: PPUSH
// if not unit or not building then
69108: LD_VAR 0 1
69112: NOT
69113: PUSH
69114: LD_VAR 0 2
69118: NOT
69119: OR
69120: IFFALSE 69124
// exit ;
69122: GO 69282
// x := GetX ( building ) ;
69124: LD_ADDR_VAR 0 5
69128: PUSH
69129: LD_VAR 0 2
69133: PPUSH
69134: CALL_OW 250
69138: ST_TO_ADDR
// y := GetY ( building ) ;
69139: LD_ADDR_VAR 0 6
69143: PUSH
69144: LD_VAR 0 2
69148: PPUSH
69149: CALL_OW 251
69153: ST_TO_ADDR
// for i = 0 to 5 do
69154: LD_ADDR_VAR 0 4
69158: PUSH
69159: DOUBLE
69160: LD_INT 0
69162: DEC
69163: ST_TO_ADDR
69164: LD_INT 5
69166: PUSH
69167: FOR_TO
69168: IFFALSE 69280
// begin _x := ShiftX ( x , i , 3 ) ;
69170: LD_ADDR_VAR 0 7
69174: PUSH
69175: LD_VAR 0 5
69179: PPUSH
69180: LD_VAR 0 4
69184: PPUSH
69185: LD_INT 3
69187: PPUSH
69188: CALL_OW 272
69192: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
69193: LD_ADDR_VAR 0 8
69197: PUSH
69198: LD_VAR 0 6
69202: PPUSH
69203: LD_VAR 0 4
69207: PPUSH
69208: LD_INT 3
69210: PPUSH
69211: CALL_OW 273
69215: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
69216: LD_VAR 0 7
69220: PPUSH
69221: LD_VAR 0 8
69225: PPUSH
69226: CALL_OW 488
69230: NOT
69231: IFFALSE 69235
// continue ;
69233: GO 69167
// if HexInfo ( _x , _y ) = 0 then
69235: LD_VAR 0 7
69239: PPUSH
69240: LD_VAR 0 8
69244: PPUSH
69245: CALL_OW 428
69249: PUSH
69250: LD_INT 0
69252: EQUAL
69253: IFFALSE 69278
// begin ComMoveXY ( unit , _x , _y ) ;
69255: LD_VAR 0 1
69259: PPUSH
69260: LD_VAR 0 7
69264: PPUSH
69265: LD_VAR 0 8
69269: PPUSH
69270: CALL_OW 111
// exit ;
69274: POP
69275: POP
69276: GO 69282
// end ; end ;
69278: GO 69167
69280: POP
69281: POP
// end ;
69282: LD_VAR 0 3
69286: RET
// export function ScanBase ( side , base_area ) ; begin
69287: LD_INT 0
69289: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
69290: LD_ADDR_VAR 0 3
69294: PUSH
69295: LD_VAR 0 2
69299: PPUSH
69300: LD_INT 81
69302: PUSH
69303: LD_VAR 0 1
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PPUSH
69312: CALL_OW 70
69316: ST_TO_ADDR
// end ;
69317: LD_VAR 0 3
69321: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69322: LD_INT 0
69324: PPUSH
69325: PPUSH
69326: PPUSH
69327: PPUSH
// result := false ;
69328: LD_ADDR_VAR 0 2
69332: PUSH
69333: LD_INT 0
69335: ST_TO_ADDR
// side := GetSide ( unit ) ;
69336: LD_ADDR_VAR 0 3
69340: PUSH
69341: LD_VAR 0 1
69345: PPUSH
69346: CALL_OW 255
69350: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69351: LD_ADDR_VAR 0 4
69355: PUSH
69356: LD_VAR 0 1
69360: PPUSH
69361: CALL_OW 248
69365: ST_TO_ADDR
// case nat of 1 :
69366: LD_VAR 0 4
69370: PUSH
69371: LD_INT 1
69373: DOUBLE
69374: EQUAL
69375: IFTRUE 69379
69377: GO 69390
69379: POP
// tech := tech_lassight ; 2 :
69380: LD_ADDR_VAR 0 5
69384: PUSH
69385: LD_INT 12
69387: ST_TO_ADDR
69388: GO 69429
69390: LD_INT 2
69392: DOUBLE
69393: EQUAL
69394: IFTRUE 69398
69396: GO 69409
69398: POP
// tech := tech_mortar ; 3 :
69399: LD_ADDR_VAR 0 5
69403: PUSH
69404: LD_INT 41
69406: ST_TO_ADDR
69407: GO 69429
69409: LD_INT 3
69411: DOUBLE
69412: EQUAL
69413: IFTRUE 69417
69415: GO 69428
69417: POP
// tech := tech_bazooka ; end ;
69418: LD_ADDR_VAR 0 5
69422: PUSH
69423: LD_INT 44
69425: ST_TO_ADDR
69426: GO 69429
69428: POP
// if Researched ( side , tech ) then
69429: LD_VAR 0 3
69433: PPUSH
69434: LD_VAR 0 5
69438: PPUSH
69439: CALL_OW 325
69443: IFFALSE 69470
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69445: LD_ADDR_VAR 0 2
69449: PUSH
69450: LD_INT 5
69452: PUSH
69453: LD_INT 8
69455: PUSH
69456: LD_INT 9
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: LIST
69463: PUSH
69464: LD_VAR 0 4
69468: ARRAY
69469: ST_TO_ADDR
// end ;
69470: LD_VAR 0 2
69474: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69475: LD_INT 0
69477: PPUSH
69478: PPUSH
69479: PPUSH
// if not mines then
69480: LD_VAR 0 2
69484: NOT
69485: IFFALSE 69489
// exit ;
69487: GO 69633
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69489: LD_ADDR_VAR 0 5
69493: PUSH
69494: LD_INT 81
69496: PUSH
69497: LD_VAR 0 1
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 3
69508: PUSH
69509: LD_INT 21
69511: PUSH
69512: LD_INT 3
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PPUSH
69527: CALL_OW 69
69531: ST_TO_ADDR
// for i in mines do
69532: LD_ADDR_VAR 0 4
69536: PUSH
69537: LD_VAR 0 2
69541: PUSH
69542: FOR_IN
69543: IFFALSE 69631
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69545: LD_VAR 0 4
69549: PUSH
69550: LD_INT 1
69552: ARRAY
69553: PPUSH
69554: LD_VAR 0 4
69558: PUSH
69559: LD_INT 2
69561: ARRAY
69562: PPUSH
69563: CALL_OW 458
69567: NOT
69568: IFFALSE 69572
// continue ;
69570: GO 69542
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69572: LD_VAR 0 4
69576: PUSH
69577: LD_INT 1
69579: ARRAY
69580: PPUSH
69581: LD_VAR 0 4
69585: PUSH
69586: LD_INT 2
69588: ARRAY
69589: PPUSH
69590: CALL_OW 428
69594: PUSH
69595: LD_VAR 0 5
69599: IN
69600: IFFALSE 69629
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69602: LD_VAR 0 4
69606: PUSH
69607: LD_INT 1
69609: ARRAY
69610: PPUSH
69611: LD_VAR 0 4
69615: PUSH
69616: LD_INT 2
69618: ARRAY
69619: PPUSH
69620: LD_VAR 0 1
69624: PPUSH
69625: CALL_OW 456
// end ;
69629: GO 69542
69631: POP
69632: POP
// end ;
69633: LD_VAR 0 3
69637: RET
// export function Count ( array ) ; var i ; begin
69638: LD_INT 0
69640: PPUSH
69641: PPUSH
// result := 0 ;
69642: LD_ADDR_VAR 0 2
69646: PUSH
69647: LD_INT 0
69649: ST_TO_ADDR
// for i in array do
69650: LD_ADDR_VAR 0 3
69654: PUSH
69655: LD_VAR 0 1
69659: PUSH
69660: FOR_IN
69661: IFFALSE 69685
// if i then
69663: LD_VAR 0 3
69667: IFFALSE 69683
// result := result + 1 ;
69669: LD_ADDR_VAR 0 2
69673: PUSH
69674: LD_VAR 0 2
69678: PUSH
69679: LD_INT 1
69681: PLUS
69682: ST_TO_ADDR
69683: GO 69660
69685: POP
69686: POP
// end ;
69687: LD_VAR 0 2
69691: RET
// export function IsEmpty ( building ) ; begin
69692: LD_INT 0
69694: PPUSH
// if not building then
69695: LD_VAR 0 1
69699: NOT
69700: IFFALSE 69704
// exit ;
69702: GO 69747
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69704: LD_ADDR_VAR 0 2
69708: PUSH
69709: LD_VAR 0 1
69713: PUSH
69714: LD_INT 22
69716: PUSH
69717: LD_VAR 0 1
69721: PPUSH
69722: CALL_OW 255
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 58
69733: PUSH
69734: EMPTY
69735: LIST
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PPUSH
69741: CALL_OW 69
69745: IN
69746: ST_TO_ADDR
// end ;
69747: LD_VAR 0 2
69751: RET
// export function IsNotFull ( building ) ; var places ; begin
69752: LD_INT 0
69754: PPUSH
69755: PPUSH
// if not building then
69756: LD_VAR 0 1
69760: NOT
69761: IFFALSE 69765
// exit ;
69763: GO 69936
// result := false ;
69765: LD_ADDR_VAR 0 2
69769: PUSH
69770: LD_INT 0
69772: ST_TO_ADDR
// places := 0 ;
69773: LD_ADDR_VAR 0 3
69777: PUSH
69778: LD_INT 0
69780: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
69781: LD_VAR 0 1
69785: PPUSH
69786: CALL_OW 266
69790: PUSH
69791: LD_INT 0
69793: DOUBLE
69794: EQUAL
69795: IFTRUE 69853
69797: LD_INT 1
69799: DOUBLE
69800: EQUAL
69801: IFTRUE 69853
69803: LD_INT 6
69805: DOUBLE
69806: EQUAL
69807: IFTRUE 69853
69809: LD_INT 7
69811: DOUBLE
69812: EQUAL
69813: IFTRUE 69853
69815: LD_INT 8
69817: DOUBLE
69818: EQUAL
69819: IFTRUE 69853
69821: LD_INT 4
69823: DOUBLE
69824: EQUAL
69825: IFTRUE 69853
69827: LD_INT 5
69829: DOUBLE
69830: EQUAL
69831: IFTRUE 69853
69833: LD_INT 2
69835: DOUBLE
69836: EQUAL
69837: IFTRUE 69853
69839: LD_INT 3
69841: DOUBLE
69842: EQUAL
69843: IFTRUE 69853
69845: LD_INT 35
69847: DOUBLE
69848: EQUAL
69849: IFTRUE 69853
69851: GO 69864
69853: POP
// places := 6 ; b_bunker , b_breastwork :
69854: LD_ADDR_VAR 0 3
69858: PUSH
69859: LD_INT 6
69861: ST_TO_ADDR
69862: GO 69909
69864: LD_INT 32
69866: DOUBLE
69867: EQUAL
69868: IFTRUE 69878
69870: LD_INT 31
69872: DOUBLE
69873: EQUAL
69874: IFTRUE 69878
69876: GO 69889
69878: POP
// places := 1 ; b_control_tower :
69879: LD_ADDR_VAR 0 3
69883: PUSH
69884: LD_INT 1
69886: ST_TO_ADDR
69887: GO 69909
69889: LD_INT 36
69891: DOUBLE
69892: EQUAL
69893: IFTRUE 69897
69895: GO 69908
69897: POP
// places := 3 ; end ;
69898: LD_ADDR_VAR 0 3
69902: PUSH
69903: LD_INT 3
69905: ST_TO_ADDR
69906: GO 69909
69908: POP
// if places then
69909: LD_VAR 0 3
69913: IFFALSE 69936
// result := UnitsInside ( building ) < places ;
69915: LD_ADDR_VAR 0 2
69919: PUSH
69920: LD_VAR 0 1
69924: PPUSH
69925: CALL_OW 313
69929: PUSH
69930: LD_VAR 0 3
69934: LESS
69935: ST_TO_ADDR
// end ;
69936: LD_VAR 0 2
69940: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69941: LD_INT 0
69943: PPUSH
69944: PPUSH
69945: PPUSH
69946: PPUSH
// tmp := [ ] ;
69947: LD_ADDR_VAR 0 3
69951: PUSH
69952: EMPTY
69953: ST_TO_ADDR
// list := [ ] ;
69954: LD_ADDR_VAR 0 5
69958: PUSH
69959: EMPTY
69960: ST_TO_ADDR
// for i = 16 to 25 do
69961: LD_ADDR_VAR 0 4
69965: PUSH
69966: DOUBLE
69967: LD_INT 16
69969: DEC
69970: ST_TO_ADDR
69971: LD_INT 25
69973: PUSH
69974: FOR_TO
69975: IFFALSE 70048
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69977: LD_ADDR_VAR 0 3
69981: PUSH
69982: LD_VAR 0 3
69986: PUSH
69987: LD_INT 22
69989: PUSH
69990: LD_VAR 0 1
69994: PPUSH
69995: CALL_OW 255
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: PUSH
70004: LD_INT 91
70006: PUSH
70007: LD_VAR 0 1
70011: PUSH
70012: LD_INT 6
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 30
70022: PUSH
70023: LD_VAR 0 4
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: LIST
70036: PUSH
70037: EMPTY
70038: LIST
70039: PPUSH
70040: CALL_OW 69
70044: ADD
70045: ST_TO_ADDR
70046: GO 69974
70048: POP
70049: POP
// for i = 1 to tmp do
70050: LD_ADDR_VAR 0 4
70054: PUSH
70055: DOUBLE
70056: LD_INT 1
70058: DEC
70059: ST_TO_ADDR
70060: LD_VAR 0 3
70064: PUSH
70065: FOR_TO
70066: IFFALSE 70154
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
70068: LD_ADDR_VAR 0 5
70072: PUSH
70073: LD_VAR 0 5
70077: PUSH
70078: LD_VAR 0 3
70082: PUSH
70083: LD_VAR 0 4
70087: ARRAY
70088: PPUSH
70089: CALL_OW 266
70093: PUSH
70094: LD_VAR 0 3
70098: PUSH
70099: LD_VAR 0 4
70103: ARRAY
70104: PPUSH
70105: CALL_OW 250
70109: PUSH
70110: LD_VAR 0 3
70114: PUSH
70115: LD_VAR 0 4
70119: ARRAY
70120: PPUSH
70121: CALL_OW 251
70125: PUSH
70126: LD_VAR 0 3
70130: PUSH
70131: LD_VAR 0 4
70135: ARRAY
70136: PPUSH
70137: CALL_OW 254
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: PUSH
70148: EMPTY
70149: LIST
70150: ADD
70151: ST_TO_ADDR
70152: GO 70065
70154: POP
70155: POP
// result := list ;
70156: LD_ADDR_VAR 0 2
70160: PUSH
70161: LD_VAR 0 5
70165: ST_TO_ADDR
// end ;
70166: LD_VAR 0 2
70170: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
70171: LD_INT 0
70173: PPUSH
70174: PPUSH
70175: PPUSH
70176: PPUSH
70177: PPUSH
70178: PPUSH
70179: PPUSH
// if not factory then
70180: LD_VAR 0 1
70184: NOT
70185: IFFALSE 70189
// exit ;
70187: GO 70782
// if control = control_apeman then
70189: LD_VAR 0 4
70193: PUSH
70194: LD_INT 5
70196: EQUAL
70197: IFFALSE 70306
// begin tmp := UnitsInside ( factory ) ;
70199: LD_ADDR_VAR 0 8
70203: PUSH
70204: LD_VAR 0 1
70208: PPUSH
70209: CALL_OW 313
70213: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
70214: LD_VAR 0 8
70218: PPUSH
70219: LD_INT 25
70221: PUSH
70222: LD_INT 12
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PPUSH
70229: CALL_OW 72
70233: NOT
70234: IFFALSE 70244
// control := control_manual ;
70236: LD_ADDR_VAR 0 4
70240: PUSH
70241: LD_INT 1
70243: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
70244: LD_ADDR_VAR 0 8
70248: PUSH
70249: LD_VAR 0 1
70253: PPUSH
70254: CALL 69941 0 1
70258: ST_TO_ADDR
// if tmp then
70259: LD_VAR 0 8
70263: IFFALSE 70306
// begin for i in tmp do
70265: LD_ADDR_VAR 0 7
70269: PUSH
70270: LD_VAR 0 8
70274: PUSH
70275: FOR_IN
70276: IFFALSE 70304
// if i [ 1 ] = b_ext_radio then
70278: LD_VAR 0 7
70282: PUSH
70283: LD_INT 1
70285: ARRAY
70286: PUSH
70287: LD_INT 22
70289: EQUAL
70290: IFFALSE 70302
// begin control := control_remote ;
70292: LD_ADDR_VAR 0 4
70296: PUSH
70297: LD_INT 2
70299: ST_TO_ADDR
// break ;
70300: GO 70304
// end ;
70302: GO 70275
70304: POP
70305: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70306: LD_VAR 0 1
70310: PPUSH
70311: LD_VAR 0 2
70315: PPUSH
70316: LD_VAR 0 3
70320: PPUSH
70321: LD_VAR 0 4
70325: PPUSH
70326: LD_VAR 0 5
70330: PPUSH
70331: CALL_OW 448
70335: IFFALSE 70370
// begin result := [ chassis , engine , control , weapon ] ;
70337: LD_ADDR_VAR 0 6
70341: PUSH
70342: LD_VAR 0 2
70346: PUSH
70347: LD_VAR 0 3
70351: PUSH
70352: LD_VAR 0 4
70356: PUSH
70357: LD_VAR 0 5
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: LIST
70366: LIST
70367: ST_TO_ADDR
// exit ;
70368: GO 70782
// end ; _chassis := AvailableChassisList ( factory ) ;
70370: LD_ADDR_VAR 0 9
70374: PUSH
70375: LD_VAR 0 1
70379: PPUSH
70380: CALL_OW 475
70384: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70385: LD_ADDR_VAR 0 11
70389: PUSH
70390: LD_VAR 0 1
70394: PPUSH
70395: CALL_OW 476
70399: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70400: LD_ADDR_VAR 0 12
70404: PUSH
70405: LD_VAR 0 1
70409: PPUSH
70410: CALL_OW 477
70414: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70415: LD_ADDR_VAR 0 10
70419: PUSH
70420: LD_VAR 0 1
70424: PPUSH
70425: CALL_OW 478
70429: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70430: LD_VAR 0 9
70434: NOT
70435: PUSH
70436: LD_VAR 0 11
70440: NOT
70441: OR
70442: PUSH
70443: LD_VAR 0 12
70447: NOT
70448: OR
70449: PUSH
70450: LD_VAR 0 10
70454: NOT
70455: OR
70456: IFFALSE 70491
// begin result := [ chassis , engine , control , weapon ] ;
70458: LD_ADDR_VAR 0 6
70462: PUSH
70463: LD_VAR 0 2
70467: PUSH
70468: LD_VAR 0 3
70472: PUSH
70473: LD_VAR 0 4
70477: PUSH
70478: LD_VAR 0 5
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: LIST
70487: LIST
70488: ST_TO_ADDR
// exit ;
70489: GO 70782
// end ; if not chassis in _chassis then
70491: LD_VAR 0 2
70495: PUSH
70496: LD_VAR 0 9
70500: IN
70501: NOT
70502: IFFALSE 70528
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70504: LD_ADDR_VAR 0 2
70508: PUSH
70509: LD_VAR 0 9
70513: PUSH
70514: LD_INT 1
70516: PPUSH
70517: LD_VAR 0 9
70521: PPUSH
70522: CALL_OW 12
70526: ARRAY
70527: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70528: LD_VAR 0 2
70532: PPUSH
70533: LD_VAR 0 3
70537: PPUSH
70538: CALL 70787 0 2
70542: NOT
70543: IFFALSE 70602
// repeat engine := _engine [ 1 ] ;
70545: LD_ADDR_VAR 0 3
70549: PUSH
70550: LD_VAR 0 11
70554: PUSH
70555: LD_INT 1
70557: ARRAY
70558: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70559: LD_ADDR_VAR 0 11
70563: PUSH
70564: LD_VAR 0 11
70568: PPUSH
70569: LD_INT 1
70571: PPUSH
70572: CALL_OW 3
70576: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70577: LD_VAR 0 2
70581: PPUSH
70582: LD_VAR 0 3
70586: PPUSH
70587: CALL 70787 0 2
70591: PUSH
70592: LD_VAR 0 11
70596: PUSH
70597: EMPTY
70598: EQUAL
70599: OR
70600: IFFALSE 70545
// if not control in _control then
70602: LD_VAR 0 4
70606: PUSH
70607: LD_VAR 0 12
70611: IN
70612: NOT
70613: IFFALSE 70639
// control := _control [ rand ( 1 , _control ) ] ;
70615: LD_ADDR_VAR 0 4
70619: PUSH
70620: LD_VAR 0 12
70624: PUSH
70625: LD_INT 1
70627: PPUSH
70628: LD_VAR 0 12
70632: PPUSH
70633: CALL_OW 12
70637: ARRAY
70638: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70639: LD_VAR 0 2
70643: PPUSH
70644: LD_VAR 0 5
70648: PPUSH
70649: CALL 71007 0 2
70653: NOT
70654: IFFALSE 70713
// repeat weapon := _weapon [ 1 ] ;
70656: LD_ADDR_VAR 0 5
70660: PUSH
70661: LD_VAR 0 10
70665: PUSH
70666: LD_INT 1
70668: ARRAY
70669: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70670: LD_ADDR_VAR 0 10
70674: PUSH
70675: LD_VAR 0 10
70679: PPUSH
70680: LD_INT 1
70682: PPUSH
70683: CALL_OW 3
70687: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70688: LD_VAR 0 2
70692: PPUSH
70693: LD_VAR 0 5
70697: PPUSH
70698: CALL 71007 0 2
70702: PUSH
70703: LD_VAR 0 10
70707: PUSH
70708: EMPTY
70709: EQUAL
70710: OR
70711: IFFALSE 70656
// result := [ ] ;
70713: LD_ADDR_VAR 0 6
70717: PUSH
70718: EMPTY
70719: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70720: LD_VAR 0 1
70724: PPUSH
70725: LD_VAR 0 2
70729: PPUSH
70730: LD_VAR 0 3
70734: PPUSH
70735: LD_VAR 0 4
70739: PPUSH
70740: LD_VAR 0 5
70744: PPUSH
70745: CALL_OW 448
70749: IFFALSE 70782
// result := [ chassis , engine , control , weapon ] ;
70751: LD_ADDR_VAR 0 6
70755: PUSH
70756: LD_VAR 0 2
70760: PUSH
70761: LD_VAR 0 3
70765: PUSH
70766: LD_VAR 0 4
70770: PUSH
70771: LD_VAR 0 5
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: ST_TO_ADDR
// end ;
70782: LD_VAR 0 6
70786: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70787: LD_INT 0
70789: PPUSH
// if not chassis or not engine then
70790: LD_VAR 0 1
70794: NOT
70795: PUSH
70796: LD_VAR 0 2
70800: NOT
70801: OR
70802: IFFALSE 70806
// exit ;
70804: GO 71002
// case engine of engine_solar :
70806: LD_VAR 0 2
70810: PUSH
70811: LD_INT 2
70813: DOUBLE
70814: EQUAL
70815: IFTRUE 70819
70817: GO 70857
70819: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70820: LD_ADDR_VAR 0 3
70824: PUSH
70825: LD_INT 11
70827: PUSH
70828: LD_INT 12
70830: PUSH
70831: LD_INT 13
70833: PUSH
70834: LD_INT 14
70836: PUSH
70837: LD_INT 1
70839: PUSH
70840: LD_INT 2
70842: PUSH
70843: LD_INT 3
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: LIST
70850: LIST
70851: LIST
70852: LIST
70853: LIST
70854: ST_TO_ADDR
70855: GO 70986
70857: LD_INT 1
70859: DOUBLE
70860: EQUAL
70861: IFTRUE 70865
70863: GO 70927
70865: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70866: LD_ADDR_VAR 0 3
70870: PUSH
70871: LD_INT 11
70873: PUSH
70874: LD_INT 12
70876: PUSH
70877: LD_INT 13
70879: PUSH
70880: LD_INT 14
70882: PUSH
70883: LD_INT 1
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 3
70891: PUSH
70892: LD_INT 4
70894: PUSH
70895: LD_INT 5
70897: PUSH
70898: LD_INT 21
70900: PUSH
70901: LD_INT 23
70903: PUSH
70904: LD_INT 22
70906: PUSH
70907: LD_INT 24
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: ST_TO_ADDR
70925: GO 70986
70927: LD_INT 3
70929: DOUBLE
70930: EQUAL
70931: IFTRUE 70935
70933: GO 70985
70935: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70936: LD_ADDR_VAR 0 3
70940: PUSH
70941: LD_INT 13
70943: PUSH
70944: LD_INT 14
70946: PUSH
70947: LD_INT 2
70949: PUSH
70950: LD_INT 3
70952: PUSH
70953: LD_INT 4
70955: PUSH
70956: LD_INT 5
70958: PUSH
70959: LD_INT 21
70961: PUSH
70962: LD_INT 22
70964: PUSH
70965: LD_INT 23
70967: PUSH
70968: LD_INT 24
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: ST_TO_ADDR
70983: GO 70986
70985: POP
// result := ( chassis in result ) ;
70986: LD_ADDR_VAR 0 3
70990: PUSH
70991: LD_VAR 0 1
70995: PUSH
70996: LD_VAR 0 3
71000: IN
71001: ST_TO_ADDR
// end ;
71002: LD_VAR 0 3
71006: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
71007: LD_INT 0
71009: PPUSH
// if not chassis or not weapon then
71010: LD_VAR 0 1
71014: NOT
71015: PUSH
71016: LD_VAR 0 2
71020: NOT
71021: OR
71022: IFFALSE 71026
// exit ;
71024: GO 72086
// case weapon of us_machine_gun :
71026: LD_VAR 0 2
71030: PUSH
71031: LD_INT 2
71033: DOUBLE
71034: EQUAL
71035: IFTRUE 71039
71037: GO 71069
71039: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
71040: LD_ADDR_VAR 0 3
71044: PUSH
71045: LD_INT 1
71047: PUSH
71048: LD_INT 2
71050: PUSH
71051: LD_INT 3
71053: PUSH
71054: LD_INT 4
71056: PUSH
71057: LD_INT 5
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: ST_TO_ADDR
71067: GO 72070
71069: LD_INT 3
71071: DOUBLE
71072: EQUAL
71073: IFTRUE 71077
71075: GO 71107
71077: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
71078: LD_ADDR_VAR 0 3
71082: PUSH
71083: LD_INT 1
71085: PUSH
71086: LD_INT 2
71088: PUSH
71089: LD_INT 3
71091: PUSH
71092: LD_INT 4
71094: PUSH
71095: LD_INT 5
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: LIST
71102: LIST
71103: LIST
71104: ST_TO_ADDR
71105: GO 72070
71107: LD_INT 11
71109: DOUBLE
71110: EQUAL
71111: IFTRUE 71115
71113: GO 71145
71115: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
71116: LD_ADDR_VAR 0 3
71120: PUSH
71121: LD_INT 1
71123: PUSH
71124: LD_INT 2
71126: PUSH
71127: LD_INT 3
71129: PUSH
71130: LD_INT 4
71132: PUSH
71133: LD_INT 5
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: ST_TO_ADDR
71143: GO 72070
71145: LD_INT 4
71147: DOUBLE
71148: EQUAL
71149: IFTRUE 71153
71151: GO 71179
71153: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
71154: LD_ADDR_VAR 0 3
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: LD_INT 3
71164: PUSH
71165: LD_INT 4
71167: PUSH
71168: LD_INT 5
71170: PUSH
71171: EMPTY
71172: LIST
71173: LIST
71174: LIST
71175: LIST
71176: ST_TO_ADDR
71177: GO 72070
71179: LD_INT 5
71181: DOUBLE
71182: EQUAL
71183: IFTRUE 71187
71185: GO 71213
71187: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
71188: LD_ADDR_VAR 0 3
71192: PUSH
71193: LD_INT 2
71195: PUSH
71196: LD_INT 3
71198: PUSH
71199: LD_INT 4
71201: PUSH
71202: LD_INT 5
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: LIST
71209: LIST
71210: ST_TO_ADDR
71211: GO 72070
71213: LD_INT 9
71215: DOUBLE
71216: EQUAL
71217: IFTRUE 71221
71219: GO 71247
71221: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
71222: LD_ADDR_VAR 0 3
71226: PUSH
71227: LD_INT 2
71229: PUSH
71230: LD_INT 3
71232: PUSH
71233: LD_INT 4
71235: PUSH
71236: LD_INT 5
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: LIST
71243: LIST
71244: ST_TO_ADDR
71245: GO 72070
71247: LD_INT 7
71249: DOUBLE
71250: EQUAL
71251: IFTRUE 71255
71253: GO 71281
71255: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
71256: LD_ADDR_VAR 0 3
71260: PUSH
71261: LD_INT 2
71263: PUSH
71264: LD_INT 3
71266: PUSH
71267: LD_INT 4
71269: PUSH
71270: LD_INT 5
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: ST_TO_ADDR
71279: GO 72070
71281: LD_INT 12
71283: DOUBLE
71284: EQUAL
71285: IFTRUE 71289
71287: GO 71315
71289: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
71290: LD_ADDR_VAR 0 3
71294: PUSH
71295: LD_INT 2
71297: PUSH
71298: LD_INT 3
71300: PUSH
71301: LD_INT 4
71303: PUSH
71304: LD_INT 5
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: ST_TO_ADDR
71313: GO 72070
71315: LD_INT 13
71317: DOUBLE
71318: EQUAL
71319: IFTRUE 71323
71321: GO 71349
71323: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71324: LD_ADDR_VAR 0 3
71328: PUSH
71329: LD_INT 2
71331: PUSH
71332: LD_INT 3
71334: PUSH
71335: LD_INT 4
71337: PUSH
71338: LD_INT 5
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: ST_TO_ADDR
71347: GO 72070
71349: LD_INT 14
71351: DOUBLE
71352: EQUAL
71353: IFTRUE 71357
71355: GO 71375
71357: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71358: LD_ADDR_VAR 0 3
71362: PUSH
71363: LD_INT 4
71365: PUSH
71366: LD_INT 5
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: ST_TO_ADDR
71373: GO 72070
71375: LD_INT 6
71377: DOUBLE
71378: EQUAL
71379: IFTRUE 71383
71381: GO 71401
71383: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71384: LD_ADDR_VAR 0 3
71388: PUSH
71389: LD_INT 4
71391: PUSH
71392: LD_INT 5
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: ST_TO_ADDR
71399: GO 72070
71401: LD_INT 10
71403: DOUBLE
71404: EQUAL
71405: IFTRUE 71409
71407: GO 71427
71409: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71410: LD_ADDR_VAR 0 3
71414: PUSH
71415: LD_INT 4
71417: PUSH
71418: LD_INT 5
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: ST_TO_ADDR
71425: GO 72070
71427: LD_INT 22
71429: DOUBLE
71430: EQUAL
71431: IFTRUE 71435
71433: GO 71461
71435: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71436: LD_ADDR_VAR 0 3
71440: PUSH
71441: LD_INT 11
71443: PUSH
71444: LD_INT 12
71446: PUSH
71447: LD_INT 13
71449: PUSH
71450: LD_INT 14
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: LIST
71457: LIST
71458: ST_TO_ADDR
71459: GO 72070
71461: LD_INT 23
71463: DOUBLE
71464: EQUAL
71465: IFTRUE 71469
71467: GO 71495
71469: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71470: LD_ADDR_VAR 0 3
71474: PUSH
71475: LD_INT 11
71477: PUSH
71478: LD_INT 12
71480: PUSH
71481: LD_INT 13
71483: PUSH
71484: LD_INT 14
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: ST_TO_ADDR
71493: GO 72070
71495: LD_INT 24
71497: DOUBLE
71498: EQUAL
71499: IFTRUE 71503
71501: GO 71529
71503: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71504: LD_ADDR_VAR 0 3
71508: PUSH
71509: LD_INT 11
71511: PUSH
71512: LD_INT 12
71514: PUSH
71515: LD_INT 13
71517: PUSH
71518: LD_INT 14
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: LIST
71525: LIST
71526: ST_TO_ADDR
71527: GO 72070
71529: LD_INT 30
71531: DOUBLE
71532: EQUAL
71533: IFTRUE 71537
71535: GO 71563
71537: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71538: LD_ADDR_VAR 0 3
71542: PUSH
71543: LD_INT 11
71545: PUSH
71546: LD_INT 12
71548: PUSH
71549: LD_INT 13
71551: PUSH
71552: LD_INT 14
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: LIST
71559: LIST
71560: ST_TO_ADDR
71561: GO 72070
71563: LD_INT 25
71565: DOUBLE
71566: EQUAL
71567: IFTRUE 71571
71569: GO 71589
71571: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71572: LD_ADDR_VAR 0 3
71576: PUSH
71577: LD_INT 13
71579: PUSH
71580: LD_INT 14
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: ST_TO_ADDR
71587: GO 72070
71589: LD_INT 27
71591: DOUBLE
71592: EQUAL
71593: IFTRUE 71597
71595: GO 71615
71597: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71598: LD_ADDR_VAR 0 3
71602: PUSH
71603: LD_INT 13
71605: PUSH
71606: LD_INT 14
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: ST_TO_ADDR
71613: GO 72070
71615: LD_INT 92
71617: DOUBLE
71618: EQUAL
71619: IFTRUE 71623
71621: GO 71649
71623: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71624: LD_ADDR_VAR 0 3
71628: PUSH
71629: LD_INT 11
71631: PUSH
71632: LD_INT 12
71634: PUSH
71635: LD_INT 13
71637: PUSH
71638: LD_INT 14
71640: PUSH
71641: EMPTY
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: ST_TO_ADDR
71647: GO 72070
71649: LD_INT 28
71651: DOUBLE
71652: EQUAL
71653: IFTRUE 71657
71655: GO 71675
71657: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71658: LD_ADDR_VAR 0 3
71662: PUSH
71663: LD_INT 13
71665: PUSH
71666: LD_INT 14
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: ST_TO_ADDR
71673: GO 72070
71675: LD_INT 29
71677: DOUBLE
71678: EQUAL
71679: IFTRUE 71683
71681: GO 71701
71683: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71684: LD_ADDR_VAR 0 3
71688: PUSH
71689: LD_INT 13
71691: PUSH
71692: LD_INT 14
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: ST_TO_ADDR
71699: GO 72070
71701: LD_INT 31
71703: DOUBLE
71704: EQUAL
71705: IFTRUE 71709
71707: GO 71727
71709: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71710: LD_ADDR_VAR 0 3
71714: PUSH
71715: LD_INT 13
71717: PUSH
71718: LD_INT 14
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: ST_TO_ADDR
71725: GO 72070
71727: LD_INT 26
71729: DOUBLE
71730: EQUAL
71731: IFTRUE 71735
71733: GO 71753
71735: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71736: LD_ADDR_VAR 0 3
71740: PUSH
71741: LD_INT 13
71743: PUSH
71744: LD_INT 14
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: ST_TO_ADDR
71751: GO 72070
71753: LD_INT 42
71755: DOUBLE
71756: EQUAL
71757: IFTRUE 71761
71759: GO 71787
71761: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71762: LD_ADDR_VAR 0 3
71766: PUSH
71767: LD_INT 21
71769: PUSH
71770: LD_INT 22
71772: PUSH
71773: LD_INT 23
71775: PUSH
71776: LD_INT 24
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: ST_TO_ADDR
71785: GO 72070
71787: LD_INT 43
71789: DOUBLE
71790: EQUAL
71791: IFTRUE 71795
71793: GO 71821
71795: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71796: LD_ADDR_VAR 0 3
71800: PUSH
71801: LD_INT 21
71803: PUSH
71804: LD_INT 22
71806: PUSH
71807: LD_INT 23
71809: PUSH
71810: LD_INT 24
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: ST_TO_ADDR
71819: GO 72070
71821: LD_INT 44
71823: DOUBLE
71824: EQUAL
71825: IFTRUE 71829
71827: GO 71855
71829: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71830: LD_ADDR_VAR 0 3
71834: PUSH
71835: LD_INT 21
71837: PUSH
71838: LD_INT 22
71840: PUSH
71841: LD_INT 23
71843: PUSH
71844: LD_INT 24
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: LIST
71851: LIST
71852: ST_TO_ADDR
71853: GO 72070
71855: LD_INT 45
71857: DOUBLE
71858: EQUAL
71859: IFTRUE 71863
71861: GO 71889
71863: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71864: LD_ADDR_VAR 0 3
71868: PUSH
71869: LD_INT 21
71871: PUSH
71872: LD_INT 22
71874: PUSH
71875: LD_INT 23
71877: PUSH
71878: LD_INT 24
71880: PUSH
71881: EMPTY
71882: LIST
71883: LIST
71884: LIST
71885: LIST
71886: ST_TO_ADDR
71887: GO 72070
71889: LD_INT 49
71891: DOUBLE
71892: EQUAL
71893: IFTRUE 71897
71895: GO 71923
71897: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71898: LD_ADDR_VAR 0 3
71902: PUSH
71903: LD_INT 21
71905: PUSH
71906: LD_INT 22
71908: PUSH
71909: LD_INT 23
71911: PUSH
71912: LD_INT 24
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: LIST
71919: LIST
71920: ST_TO_ADDR
71921: GO 72070
71923: LD_INT 51
71925: DOUBLE
71926: EQUAL
71927: IFTRUE 71931
71929: GO 71957
71931: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71932: LD_ADDR_VAR 0 3
71936: PUSH
71937: LD_INT 21
71939: PUSH
71940: LD_INT 22
71942: PUSH
71943: LD_INT 23
71945: PUSH
71946: LD_INT 24
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: ST_TO_ADDR
71955: GO 72070
71957: LD_INT 52
71959: DOUBLE
71960: EQUAL
71961: IFTRUE 71965
71963: GO 71991
71965: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71966: LD_ADDR_VAR 0 3
71970: PUSH
71971: LD_INT 21
71973: PUSH
71974: LD_INT 22
71976: PUSH
71977: LD_INT 23
71979: PUSH
71980: LD_INT 24
71982: PUSH
71983: EMPTY
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: ST_TO_ADDR
71989: GO 72070
71991: LD_INT 53
71993: DOUBLE
71994: EQUAL
71995: IFTRUE 71999
71997: GO 72017
71999: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
72000: LD_ADDR_VAR 0 3
72004: PUSH
72005: LD_INT 23
72007: PUSH
72008: LD_INT 24
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: ST_TO_ADDR
72015: GO 72070
72017: LD_INT 46
72019: DOUBLE
72020: EQUAL
72021: IFTRUE 72025
72023: GO 72043
72025: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
72026: LD_ADDR_VAR 0 3
72030: PUSH
72031: LD_INT 23
72033: PUSH
72034: LD_INT 24
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: ST_TO_ADDR
72041: GO 72070
72043: LD_INT 47
72045: DOUBLE
72046: EQUAL
72047: IFTRUE 72051
72049: GO 72069
72051: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72052: LD_ADDR_VAR 0 3
72056: PUSH
72057: LD_INT 23
72059: PUSH
72060: LD_INT 24
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: ST_TO_ADDR
72067: GO 72070
72069: POP
// result := ( chassis in result ) ;
72070: LD_ADDR_VAR 0 3
72074: PUSH
72075: LD_VAR 0 1
72079: PUSH
72080: LD_VAR 0 3
72084: IN
72085: ST_TO_ADDR
// end ;
72086: LD_VAR 0 3
72090: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
72091: LD_INT 0
72093: PPUSH
72094: PPUSH
72095: PPUSH
72096: PPUSH
72097: PPUSH
72098: PPUSH
72099: PPUSH
// result := array ;
72100: LD_ADDR_VAR 0 5
72104: PUSH
72105: LD_VAR 0 1
72109: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
72110: LD_VAR 0 1
72114: NOT
72115: PUSH
72116: LD_VAR 0 2
72120: NOT
72121: OR
72122: PUSH
72123: LD_VAR 0 3
72127: NOT
72128: OR
72129: PUSH
72130: LD_VAR 0 2
72134: PUSH
72135: LD_VAR 0 1
72139: GREATER
72140: OR
72141: PUSH
72142: LD_VAR 0 3
72146: PUSH
72147: LD_VAR 0 1
72151: GREATER
72152: OR
72153: IFFALSE 72157
// exit ;
72155: GO 72453
// if direction then
72157: LD_VAR 0 4
72161: IFFALSE 72225
// begin d := 1 ;
72163: LD_ADDR_VAR 0 9
72167: PUSH
72168: LD_INT 1
72170: ST_TO_ADDR
// if i_from > i_to then
72171: LD_VAR 0 2
72175: PUSH
72176: LD_VAR 0 3
72180: GREATER
72181: IFFALSE 72207
// length := ( array - i_from ) + i_to else
72183: LD_ADDR_VAR 0 11
72187: PUSH
72188: LD_VAR 0 1
72192: PUSH
72193: LD_VAR 0 2
72197: MINUS
72198: PUSH
72199: LD_VAR 0 3
72203: PLUS
72204: ST_TO_ADDR
72205: GO 72223
// length := i_to - i_from ;
72207: LD_ADDR_VAR 0 11
72211: PUSH
72212: LD_VAR 0 3
72216: PUSH
72217: LD_VAR 0 2
72221: MINUS
72222: ST_TO_ADDR
// end else
72223: GO 72286
// begin d := - 1 ;
72225: LD_ADDR_VAR 0 9
72229: PUSH
72230: LD_INT 1
72232: NEG
72233: ST_TO_ADDR
// if i_from > i_to then
72234: LD_VAR 0 2
72238: PUSH
72239: LD_VAR 0 3
72243: GREATER
72244: IFFALSE 72264
// length := i_from - i_to else
72246: LD_ADDR_VAR 0 11
72250: PUSH
72251: LD_VAR 0 2
72255: PUSH
72256: LD_VAR 0 3
72260: MINUS
72261: ST_TO_ADDR
72262: GO 72286
// length := ( array - i_to ) + i_from ;
72264: LD_ADDR_VAR 0 11
72268: PUSH
72269: LD_VAR 0 1
72273: PUSH
72274: LD_VAR 0 3
72278: MINUS
72279: PUSH
72280: LD_VAR 0 2
72284: PLUS
72285: ST_TO_ADDR
// end ; if not length then
72286: LD_VAR 0 11
72290: NOT
72291: IFFALSE 72295
// exit ;
72293: GO 72453
// tmp := array ;
72295: LD_ADDR_VAR 0 10
72299: PUSH
72300: LD_VAR 0 1
72304: ST_TO_ADDR
// for i = 1 to length do
72305: LD_ADDR_VAR 0 6
72309: PUSH
72310: DOUBLE
72311: LD_INT 1
72313: DEC
72314: ST_TO_ADDR
72315: LD_VAR 0 11
72319: PUSH
72320: FOR_TO
72321: IFFALSE 72441
// begin for j = 1 to array do
72323: LD_ADDR_VAR 0 7
72327: PUSH
72328: DOUBLE
72329: LD_INT 1
72331: DEC
72332: ST_TO_ADDR
72333: LD_VAR 0 1
72337: PUSH
72338: FOR_TO
72339: IFFALSE 72427
// begin k := j + d ;
72341: LD_ADDR_VAR 0 8
72345: PUSH
72346: LD_VAR 0 7
72350: PUSH
72351: LD_VAR 0 9
72355: PLUS
72356: ST_TO_ADDR
// if k > array then
72357: LD_VAR 0 8
72361: PUSH
72362: LD_VAR 0 1
72366: GREATER
72367: IFFALSE 72377
// k := 1 ;
72369: LD_ADDR_VAR 0 8
72373: PUSH
72374: LD_INT 1
72376: ST_TO_ADDR
// if not k then
72377: LD_VAR 0 8
72381: NOT
72382: IFFALSE 72394
// k := array ;
72384: LD_ADDR_VAR 0 8
72388: PUSH
72389: LD_VAR 0 1
72393: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72394: LD_ADDR_VAR 0 10
72398: PUSH
72399: LD_VAR 0 10
72403: PPUSH
72404: LD_VAR 0 8
72408: PPUSH
72409: LD_VAR 0 1
72413: PUSH
72414: LD_VAR 0 7
72418: ARRAY
72419: PPUSH
72420: CALL_OW 1
72424: ST_TO_ADDR
// end ;
72425: GO 72338
72427: POP
72428: POP
// array := tmp ;
72429: LD_ADDR_VAR 0 1
72433: PUSH
72434: LD_VAR 0 10
72438: ST_TO_ADDR
// end ;
72439: GO 72320
72441: POP
72442: POP
// result := array ;
72443: LD_ADDR_VAR 0 5
72447: PUSH
72448: LD_VAR 0 1
72452: ST_TO_ADDR
// end ;
72453: LD_VAR 0 5
72457: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72458: LD_INT 0
72460: PPUSH
72461: PPUSH
// result := 0 ;
72462: LD_ADDR_VAR 0 3
72466: PUSH
72467: LD_INT 0
72469: ST_TO_ADDR
// if not array or not value in array then
72470: LD_VAR 0 1
72474: NOT
72475: PUSH
72476: LD_VAR 0 2
72480: PUSH
72481: LD_VAR 0 1
72485: IN
72486: NOT
72487: OR
72488: IFFALSE 72492
// exit ;
72490: GO 72546
// for i = 1 to array do
72492: LD_ADDR_VAR 0 4
72496: PUSH
72497: DOUBLE
72498: LD_INT 1
72500: DEC
72501: ST_TO_ADDR
72502: LD_VAR 0 1
72506: PUSH
72507: FOR_TO
72508: IFFALSE 72544
// if value = array [ i ] then
72510: LD_VAR 0 2
72514: PUSH
72515: LD_VAR 0 1
72519: PUSH
72520: LD_VAR 0 4
72524: ARRAY
72525: EQUAL
72526: IFFALSE 72542
// begin result := i ;
72528: LD_ADDR_VAR 0 3
72532: PUSH
72533: LD_VAR 0 4
72537: ST_TO_ADDR
// exit ;
72538: POP
72539: POP
72540: GO 72546
// end ;
72542: GO 72507
72544: POP
72545: POP
// end ;
72546: LD_VAR 0 3
72550: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72551: LD_INT 0
72553: PPUSH
// vc_chassis := chassis ;
72554: LD_ADDR_OWVAR 37
72558: PUSH
72559: LD_VAR 0 1
72563: ST_TO_ADDR
// vc_engine := engine ;
72564: LD_ADDR_OWVAR 39
72568: PUSH
72569: LD_VAR 0 2
72573: ST_TO_ADDR
// vc_control := control ;
72574: LD_ADDR_OWVAR 38
72578: PUSH
72579: LD_VAR 0 3
72583: ST_TO_ADDR
// vc_weapon := weapon ;
72584: LD_ADDR_OWVAR 40
72588: PUSH
72589: LD_VAR 0 4
72593: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72594: LD_ADDR_OWVAR 41
72598: PUSH
72599: LD_VAR 0 5
72603: ST_TO_ADDR
// end ;
72604: LD_VAR 0 6
72608: RET
// export function WantPlant ( unit ) ; var task ; begin
72609: LD_INT 0
72611: PPUSH
72612: PPUSH
// result := false ;
72613: LD_ADDR_VAR 0 2
72617: PUSH
72618: LD_INT 0
72620: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72621: LD_ADDR_VAR 0 3
72625: PUSH
72626: LD_VAR 0 1
72630: PPUSH
72631: CALL_OW 437
72635: ST_TO_ADDR
// if task then
72636: LD_VAR 0 3
72640: IFFALSE 72668
// if task [ 1 ] [ 1 ] = p then
72642: LD_VAR 0 3
72646: PUSH
72647: LD_INT 1
72649: ARRAY
72650: PUSH
72651: LD_INT 1
72653: ARRAY
72654: PUSH
72655: LD_STRING p
72657: EQUAL
72658: IFFALSE 72668
// result := true ;
72660: LD_ADDR_VAR 0 2
72664: PUSH
72665: LD_INT 1
72667: ST_TO_ADDR
// end ;
72668: LD_VAR 0 2
72672: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72673: LD_INT 0
72675: PPUSH
72676: PPUSH
72677: PPUSH
72678: PPUSH
// if pos < 1 then
72679: LD_VAR 0 2
72683: PUSH
72684: LD_INT 1
72686: LESS
72687: IFFALSE 72691
// exit ;
72689: GO 72994
// if pos = 1 then
72691: LD_VAR 0 2
72695: PUSH
72696: LD_INT 1
72698: EQUAL
72699: IFFALSE 72732
// result := Replace ( arr , pos [ 1 ] , value ) else
72701: LD_ADDR_VAR 0 4
72705: PUSH
72706: LD_VAR 0 1
72710: PPUSH
72711: LD_VAR 0 2
72715: PUSH
72716: LD_INT 1
72718: ARRAY
72719: PPUSH
72720: LD_VAR 0 3
72724: PPUSH
72725: CALL_OW 1
72729: ST_TO_ADDR
72730: GO 72994
// begin tmp := arr ;
72732: LD_ADDR_VAR 0 6
72736: PUSH
72737: LD_VAR 0 1
72741: ST_TO_ADDR
// s_arr := [ tmp ] ;
72742: LD_ADDR_VAR 0 7
72746: PUSH
72747: LD_VAR 0 6
72751: PUSH
72752: EMPTY
72753: LIST
72754: ST_TO_ADDR
// for i = 1 to pos - 1 do
72755: LD_ADDR_VAR 0 5
72759: PUSH
72760: DOUBLE
72761: LD_INT 1
72763: DEC
72764: ST_TO_ADDR
72765: LD_VAR 0 2
72769: PUSH
72770: LD_INT 1
72772: MINUS
72773: PUSH
72774: FOR_TO
72775: IFFALSE 72820
// begin tmp := tmp [ pos [ i ] ] ;
72777: LD_ADDR_VAR 0 6
72781: PUSH
72782: LD_VAR 0 6
72786: PUSH
72787: LD_VAR 0 2
72791: PUSH
72792: LD_VAR 0 5
72796: ARRAY
72797: ARRAY
72798: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72799: LD_ADDR_VAR 0 7
72803: PUSH
72804: LD_VAR 0 7
72808: PUSH
72809: LD_VAR 0 6
72813: PUSH
72814: EMPTY
72815: LIST
72816: ADD
72817: ST_TO_ADDR
// end ;
72818: GO 72774
72820: POP
72821: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72822: LD_ADDR_VAR 0 6
72826: PUSH
72827: LD_VAR 0 6
72831: PPUSH
72832: LD_VAR 0 2
72836: PUSH
72837: LD_VAR 0 2
72841: ARRAY
72842: PPUSH
72843: LD_VAR 0 3
72847: PPUSH
72848: CALL_OW 1
72852: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72853: LD_ADDR_VAR 0 7
72857: PUSH
72858: LD_VAR 0 7
72862: PPUSH
72863: LD_VAR 0 7
72867: PPUSH
72868: LD_VAR 0 6
72872: PPUSH
72873: CALL_OW 1
72877: ST_TO_ADDR
// for i = s_arr downto 2 do
72878: LD_ADDR_VAR 0 5
72882: PUSH
72883: DOUBLE
72884: LD_VAR 0 7
72888: INC
72889: ST_TO_ADDR
72890: LD_INT 2
72892: PUSH
72893: FOR_DOWNTO
72894: IFFALSE 72978
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72896: LD_ADDR_VAR 0 6
72900: PUSH
72901: LD_VAR 0 7
72905: PUSH
72906: LD_VAR 0 5
72910: PUSH
72911: LD_INT 1
72913: MINUS
72914: ARRAY
72915: PPUSH
72916: LD_VAR 0 2
72920: PUSH
72921: LD_VAR 0 5
72925: PUSH
72926: LD_INT 1
72928: MINUS
72929: ARRAY
72930: PPUSH
72931: LD_VAR 0 7
72935: PUSH
72936: LD_VAR 0 5
72940: ARRAY
72941: PPUSH
72942: CALL_OW 1
72946: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72947: LD_ADDR_VAR 0 7
72951: PUSH
72952: LD_VAR 0 7
72956: PPUSH
72957: LD_VAR 0 5
72961: PUSH
72962: LD_INT 1
72964: MINUS
72965: PPUSH
72966: LD_VAR 0 6
72970: PPUSH
72971: CALL_OW 1
72975: ST_TO_ADDR
// end ;
72976: GO 72893
72978: POP
72979: POP
// result := s_arr [ 1 ] ;
72980: LD_ADDR_VAR 0 4
72984: PUSH
72985: LD_VAR 0 7
72989: PUSH
72990: LD_INT 1
72992: ARRAY
72993: ST_TO_ADDR
// end ; end ;
72994: LD_VAR 0 4
72998: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72999: LD_INT 0
73001: PPUSH
73002: PPUSH
// if not list then
73003: LD_VAR 0 1
73007: NOT
73008: IFFALSE 73012
// exit ;
73010: GO 73103
// i := list [ pos1 ] ;
73012: LD_ADDR_VAR 0 5
73016: PUSH
73017: LD_VAR 0 1
73021: PUSH
73022: LD_VAR 0 2
73026: ARRAY
73027: ST_TO_ADDR
// if not i then
73028: LD_VAR 0 5
73032: NOT
73033: IFFALSE 73037
// exit ;
73035: GO 73103
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
73037: LD_ADDR_VAR 0 1
73041: PUSH
73042: LD_VAR 0 1
73046: PPUSH
73047: LD_VAR 0 2
73051: PPUSH
73052: LD_VAR 0 1
73056: PUSH
73057: LD_VAR 0 3
73061: ARRAY
73062: PPUSH
73063: CALL_OW 1
73067: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
73068: LD_ADDR_VAR 0 1
73072: PUSH
73073: LD_VAR 0 1
73077: PPUSH
73078: LD_VAR 0 3
73082: PPUSH
73083: LD_VAR 0 5
73087: PPUSH
73088: CALL_OW 1
73092: ST_TO_ADDR
// result := list ;
73093: LD_ADDR_VAR 0 4
73097: PUSH
73098: LD_VAR 0 1
73102: ST_TO_ADDR
// end ;
73103: LD_VAR 0 4
73107: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
73108: LD_INT 0
73110: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
73111: LD_ADDR_VAR 0 5
73115: PUSH
73116: LD_VAR 0 1
73120: PPUSH
73121: CALL_OW 250
73125: PPUSH
73126: LD_VAR 0 1
73130: PPUSH
73131: CALL_OW 251
73135: PPUSH
73136: LD_VAR 0 2
73140: PPUSH
73141: LD_VAR 0 3
73145: PPUSH
73146: LD_VAR 0 4
73150: PPUSH
73151: CALL 73161 0 5
73155: ST_TO_ADDR
// end ;
73156: LD_VAR 0 5
73160: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
73161: LD_INT 0
73163: PPUSH
73164: PPUSH
73165: PPUSH
73166: PPUSH
// if not list then
73167: LD_VAR 0 3
73171: NOT
73172: IFFALSE 73176
// exit ;
73174: GO 73564
// result := [ ] ;
73176: LD_ADDR_VAR 0 6
73180: PUSH
73181: EMPTY
73182: ST_TO_ADDR
// for i in list do
73183: LD_ADDR_VAR 0 7
73187: PUSH
73188: LD_VAR 0 3
73192: PUSH
73193: FOR_IN
73194: IFFALSE 73396
// begin tmp := GetDistUnitXY ( i , x , y ) ;
73196: LD_ADDR_VAR 0 9
73200: PUSH
73201: LD_VAR 0 7
73205: PPUSH
73206: LD_VAR 0 1
73210: PPUSH
73211: LD_VAR 0 2
73215: PPUSH
73216: CALL_OW 297
73220: ST_TO_ADDR
// if not result then
73221: LD_VAR 0 6
73225: NOT
73226: IFFALSE 73252
// result := [ [ i , tmp ] ] else
73228: LD_ADDR_VAR 0 6
73232: PUSH
73233: LD_VAR 0 7
73237: PUSH
73238: LD_VAR 0 9
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: EMPTY
73248: LIST
73249: ST_TO_ADDR
73250: GO 73394
// begin if result [ result ] [ 2 ] < tmp then
73252: LD_VAR 0 6
73256: PUSH
73257: LD_VAR 0 6
73261: ARRAY
73262: PUSH
73263: LD_INT 2
73265: ARRAY
73266: PUSH
73267: LD_VAR 0 9
73271: LESS
73272: IFFALSE 73314
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
73274: LD_ADDR_VAR 0 6
73278: PUSH
73279: LD_VAR 0 6
73283: PPUSH
73284: LD_VAR 0 6
73288: PUSH
73289: LD_INT 1
73291: PLUS
73292: PPUSH
73293: LD_VAR 0 7
73297: PUSH
73298: LD_VAR 0 9
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: PPUSH
73307: CALL_OW 2
73311: ST_TO_ADDR
73312: GO 73394
// for j = 1 to result do
73314: LD_ADDR_VAR 0 8
73318: PUSH
73319: DOUBLE
73320: LD_INT 1
73322: DEC
73323: ST_TO_ADDR
73324: LD_VAR 0 6
73328: PUSH
73329: FOR_TO
73330: IFFALSE 73392
// begin if tmp < result [ j ] [ 2 ] then
73332: LD_VAR 0 9
73336: PUSH
73337: LD_VAR 0 6
73341: PUSH
73342: LD_VAR 0 8
73346: ARRAY
73347: PUSH
73348: LD_INT 2
73350: ARRAY
73351: LESS
73352: IFFALSE 73390
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73354: LD_ADDR_VAR 0 6
73358: PUSH
73359: LD_VAR 0 6
73363: PPUSH
73364: LD_VAR 0 8
73368: PPUSH
73369: LD_VAR 0 7
73373: PUSH
73374: LD_VAR 0 9
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PPUSH
73383: CALL_OW 2
73387: ST_TO_ADDR
// break ;
73388: GO 73392
// end ; end ;
73390: GO 73329
73392: POP
73393: POP
// end ; end ;
73394: GO 73193
73396: POP
73397: POP
// if result and not asc then
73398: LD_VAR 0 6
73402: PUSH
73403: LD_VAR 0 4
73407: NOT
73408: AND
73409: IFFALSE 73484
// begin tmp := result ;
73411: LD_ADDR_VAR 0 9
73415: PUSH
73416: LD_VAR 0 6
73420: ST_TO_ADDR
// for i = tmp downto 1 do
73421: LD_ADDR_VAR 0 7
73425: PUSH
73426: DOUBLE
73427: LD_VAR 0 9
73431: INC
73432: ST_TO_ADDR
73433: LD_INT 1
73435: PUSH
73436: FOR_DOWNTO
73437: IFFALSE 73482
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73439: LD_ADDR_VAR 0 6
73443: PUSH
73444: LD_VAR 0 6
73448: PPUSH
73449: LD_VAR 0 9
73453: PUSH
73454: LD_VAR 0 7
73458: MINUS
73459: PUSH
73460: LD_INT 1
73462: PLUS
73463: PPUSH
73464: LD_VAR 0 9
73468: PUSH
73469: LD_VAR 0 7
73473: ARRAY
73474: PPUSH
73475: CALL_OW 1
73479: ST_TO_ADDR
73480: GO 73436
73482: POP
73483: POP
// end ; tmp := [ ] ;
73484: LD_ADDR_VAR 0 9
73488: PUSH
73489: EMPTY
73490: ST_TO_ADDR
// if mode then
73491: LD_VAR 0 5
73495: IFFALSE 73564
// begin for i = 1 to result do
73497: LD_ADDR_VAR 0 7
73501: PUSH
73502: DOUBLE
73503: LD_INT 1
73505: DEC
73506: ST_TO_ADDR
73507: LD_VAR 0 6
73511: PUSH
73512: FOR_TO
73513: IFFALSE 73552
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73515: LD_ADDR_VAR 0 9
73519: PUSH
73520: LD_VAR 0 9
73524: PPUSH
73525: LD_VAR 0 7
73529: PPUSH
73530: LD_VAR 0 6
73534: PUSH
73535: LD_VAR 0 7
73539: ARRAY
73540: PUSH
73541: LD_INT 1
73543: ARRAY
73544: PPUSH
73545: CALL_OW 1
73549: ST_TO_ADDR
73550: GO 73512
73552: POP
73553: POP
// result := tmp ;
73554: LD_ADDR_VAR 0 6
73558: PUSH
73559: LD_VAR 0 9
73563: ST_TO_ADDR
// end ; end ;
73564: LD_VAR 0 6
73568: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73569: LD_INT 0
73571: PPUSH
73572: PPUSH
73573: PPUSH
73574: PPUSH
73575: PPUSH
73576: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73577: LD_ADDR_VAR 0 5
73581: PUSH
73582: LD_INT 0
73584: PUSH
73585: LD_INT 0
73587: PUSH
73588: LD_INT 0
73590: PUSH
73591: EMPTY
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: ST_TO_ADDR
// if not x or not y then
73599: LD_VAR 0 2
73603: NOT
73604: PUSH
73605: LD_VAR 0 3
73609: NOT
73610: OR
73611: IFFALSE 73615
// exit ;
73613: GO 75265
// if not range then
73615: LD_VAR 0 4
73619: NOT
73620: IFFALSE 73630
// range := 10 ;
73622: LD_ADDR_VAR 0 4
73626: PUSH
73627: LD_INT 10
73629: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73630: LD_ADDR_VAR 0 8
73634: PUSH
73635: LD_INT 81
73637: PUSH
73638: LD_VAR 0 1
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 92
73649: PUSH
73650: LD_VAR 0 2
73654: PUSH
73655: LD_VAR 0 3
73659: PUSH
73660: LD_VAR 0 4
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 3
73673: PUSH
73674: LD_INT 21
73676: PUSH
73677: LD_INT 3
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: LIST
73692: PPUSH
73693: CALL_OW 69
73697: ST_TO_ADDR
// if not tmp then
73698: LD_VAR 0 8
73702: NOT
73703: IFFALSE 73707
// exit ;
73705: GO 75265
// for i in tmp do
73707: LD_ADDR_VAR 0 6
73711: PUSH
73712: LD_VAR 0 8
73716: PUSH
73717: FOR_IN
73718: IFFALSE 75240
// begin points := [ 0 , 0 , 0 ] ;
73720: LD_ADDR_VAR 0 9
73724: PUSH
73725: LD_INT 0
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: LD_INT 0
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: LIST
73738: ST_TO_ADDR
// bpoints := 1 ;
73739: LD_ADDR_VAR 0 10
73743: PUSH
73744: LD_INT 1
73746: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73747: LD_VAR 0 6
73751: PPUSH
73752: CALL_OW 247
73756: PUSH
73757: LD_INT 1
73759: DOUBLE
73760: EQUAL
73761: IFTRUE 73765
73763: GO 74343
73765: POP
// begin if GetClass ( i ) = 1 then
73766: LD_VAR 0 6
73770: PPUSH
73771: CALL_OW 257
73775: PUSH
73776: LD_INT 1
73778: EQUAL
73779: IFFALSE 73800
// points := [ 10 , 5 , 3 ] ;
73781: LD_ADDR_VAR 0 9
73785: PUSH
73786: LD_INT 10
73788: PUSH
73789: LD_INT 5
73791: PUSH
73792: LD_INT 3
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: LIST
73799: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73800: LD_VAR 0 6
73804: PPUSH
73805: CALL_OW 257
73809: PUSH
73810: LD_INT 2
73812: PUSH
73813: LD_INT 3
73815: PUSH
73816: LD_INT 4
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: LIST
73823: IN
73824: IFFALSE 73845
// points := [ 3 , 2 , 1 ] ;
73826: LD_ADDR_VAR 0 9
73830: PUSH
73831: LD_INT 3
73833: PUSH
73834: LD_INT 2
73836: PUSH
73837: LD_INT 1
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: LIST
73844: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73845: LD_VAR 0 6
73849: PPUSH
73850: CALL_OW 257
73854: PUSH
73855: LD_INT 5
73857: EQUAL
73858: IFFALSE 73879
// points := [ 130 , 5 , 2 ] ;
73860: LD_ADDR_VAR 0 9
73864: PUSH
73865: LD_INT 130
73867: PUSH
73868: LD_INT 5
73870: PUSH
73871: LD_INT 2
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: LIST
73878: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73879: LD_VAR 0 6
73883: PPUSH
73884: CALL_OW 257
73888: PUSH
73889: LD_INT 8
73891: EQUAL
73892: IFFALSE 73913
// points := [ 35 , 35 , 30 ] ;
73894: LD_ADDR_VAR 0 9
73898: PUSH
73899: LD_INT 35
73901: PUSH
73902: LD_INT 35
73904: PUSH
73905: LD_INT 30
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: LIST
73912: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73913: LD_VAR 0 6
73917: PPUSH
73918: CALL_OW 257
73922: PUSH
73923: LD_INT 9
73925: EQUAL
73926: IFFALSE 73947
// points := [ 20 , 55 , 40 ] ;
73928: LD_ADDR_VAR 0 9
73932: PUSH
73933: LD_INT 20
73935: PUSH
73936: LD_INT 55
73938: PUSH
73939: LD_INT 40
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: LIST
73946: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73947: LD_VAR 0 6
73951: PPUSH
73952: CALL_OW 257
73956: PUSH
73957: LD_INT 12
73959: PUSH
73960: LD_INT 16
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: IN
73967: IFFALSE 73988
// points := [ 5 , 3 , 2 ] ;
73969: LD_ADDR_VAR 0 9
73973: PUSH
73974: LD_INT 5
73976: PUSH
73977: LD_INT 3
73979: PUSH
73980: LD_INT 2
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: LIST
73987: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73988: LD_VAR 0 6
73992: PPUSH
73993: CALL_OW 257
73997: PUSH
73998: LD_INT 17
74000: EQUAL
74001: IFFALSE 74022
// points := [ 100 , 50 , 75 ] ;
74003: LD_ADDR_VAR 0 9
74007: PUSH
74008: LD_INT 100
74010: PUSH
74011: LD_INT 50
74013: PUSH
74014: LD_INT 75
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: LIST
74021: ST_TO_ADDR
// if GetClass ( i ) = 15 then
74022: LD_VAR 0 6
74026: PPUSH
74027: CALL_OW 257
74031: PUSH
74032: LD_INT 15
74034: EQUAL
74035: IFFALSE 74056
// points := [ 10 , 5 , 3 ] ;
74037: LD_ADDR_VAR 0 9
74041: PUSH
74042: LD_INT 10
74044: PUSH
74045: LD_INT 5
74047: PUSH
74048: LD_INT 3
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: LIST
74055: ST_TO_ADDR
// if GetClass ( i ) = 14 then
74056: LD_VAR 0 6
74060: PPUSH
74061: CALL_OW 257
74065: PUSH
74066: LD_INT 14
74068: EQUAL
74069: IFFALSE 74090
// points := [ 10 , 0 , 0 ] ;
74071: LD_ADDR_VAR 0 9
74075: PUSH
74076: LD_INT 10
74078: PUSH
74079: LD_INT 0
74081: PUSH
74082: LD_INT 0
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: LIST
74089: ST_TO_ADDR
// if GetClass ( i ) = 11 then
74090: LD_VAR 0 6
74094: PPUSH
74095: CALL_OW 257
74099: PUSH
74100: LD_INT 11
74102: EQUAL
74103: IFFALSE 74124
// points := [ 30 , 10 , 5 ] ;
74105: LD_ADDR_VAR 0 9
74109: PUSH
74110: LD_INT 30
74112: PUSH
74113: LD_INT 10
74115: PUSH
74116: LD_INT 5
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: LIST
74123: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
74124: LD_VAR 0 1
74128: PPUSH
74129: LD_INT 5
74131: PPUSH
74132: CALL_OW 321
74136: PUSH
74137: LD_INT 2
74139: EQUAL
74140: IFFALSE 74157
// bpoints := bpoints * 1.8 ;
74142: LD_ADDR_VAR 0 10
74146: PUSH
74147: LD_VAR 0 10
74151: PUSH
74152: LD_REAL  1.80000000000000E+0000
74155: MUL
74156: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
74157: LD_VAR 0 6
74161: PPUSH
74162: CALL_OW 257
74166: PUSH
74167: LD_INT 1
74169: PUSH
74170: LD_INT 2
74172: PUSH
74173: LD_INT 3
74175: PUSH
74176: LD_INT 4
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: LIST
74183: LIST
74184: IN
74185: PUSH
74186: LD_VAR 0 1
74190: PPUSH
74191: LD_INT 51
74193: PPUSH
74194: CALL_OW 321
74198: PUSH
74199: LD_INT 2
74201: EQUAL
74202: AND
74203: IFFALSE 74220
// bpoints := bpoints * 1.2 ;
74205: LD_ADDR_VAR 0 10
74209: PUSH
74210: LD_VAR 0 10
74214: PUSH
74215: LD_REAL  1.20000000000000E+0000
74218: MUL
74219: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
74220: LD_VAR 0 6
74224: PPUSH
74225: CALL_OW 257
74229: PUSH
74230: LD_INT 5
74232: PUSH
74233: LD_INT 7
74235: PUSH
74236: LD_INT 9
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: LIST
74243: IN
74244: PUSH
74245: LD_VAR 0 1
74249: PPUSH
74250: LD_INT 52
74252: PPUSH
74253: CALL_OW 321
74257: PUSH
74258: LD_INT 2
74260: EQUAL
74261: AND
74262: IFFALSE 74279
// bpoints := bpoints * 1.5 ;
74264: LD_ADDR_VAR 0 10
74268: PUSH
74269: LD_VAR 0 10
74273: PUSH
74274: LD_REAL  1.50000000000000E+0000
74277: MUL
74278: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
74279: LD_VAR 0 1
74283: PPUSH
74284: LD_INT 66
74286: PPUSH
74287: CALL_OW 321
74291: PUSH
74292: LD_INT 2
74294: EQUAL
74295: IFFALSE 74312
// bpoints := bpoints * 1.1 ;
74297: LD_ADDR_VAR 0 10
74301: PUSH
74302: LD_VAR 0 10
74306: PUSH
74307: LD_REAL  1.10000000000000E+0000
74310: MUL
74311: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
74312: LD_ADDR_VAR 0 10
74316: PUSH
74317: LD_VAR 0 10
74321: PUSH
74322: LD_VAR 0 6
74326: PPUSH
74327: LD_INT 1
74329: PPUSH
74330: CALL_OW 259
74334: PUSH
74335: LD_REAL  1.15000000000000E+0000
74338: MUL
74339: MUL
74340: ST_TO_ADDR
// end ; unit_vehicle :
74341: GO 75169
74343: LD_INT 2
74345: DOUBLE
74346: EQUAL
74347: IFTRUE 74351
74349: GO 75157
74351: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74352: LD_VAR 0 6
74356: PPUSH
74357: CALL_OW 264
74361: PUSH
74362: LD_INT 2
74364: PUSH
74365: LD_INT 42
74367: PUSH
74368: LD_INT 24
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: LIST
74375: IN
74376: IFFALSE 74397
// points := [ 25 , 5 , 3 ] ;
74378: LD_ADDR_VAR 0 9
74382: PUSH
74383: LD_INT 25
74385: PUSH
74386: LD_INT 5
74388: PUSH
74389: LD_INT 3
74391: PUSH
74392: EMPTY
74393: LIST
74394: LIST
74395: LIST
74396: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74397: LD_VAR 0 6
74401: PPUSH
74402: CALL_OW 264
74406: PUSH
74407: LD_INT 4
74409: PUSH
74410: LD_INT 43
74412: PUSH
74413: LD_INT 25
74415: PUSH
74416: EMPTY
74417: LIST
74418: LIST
74419: LIST
74420: IN
74421: IFFALSE 74442
// points := [ 40 , 15 , 5 ] ;
74423: LD_ADDR_VAR 0 9
74427: PUSH
74428: LD_INT 40
74430: PUSH
74431: LD_INT 15
74433: PUSH
74434: LD_INT 5
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: LIST
74441: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74442: LD_VAR 0 6
74446: PPUSH
74447: CALL_OW 264
74451: PUSH
74452: LD_INT 3
74454: PUSH
74455: LD_INT 23
74457: PUSH
74458: EMPTY
74459: LIST
74460: LIST
74461: IN
74462: IFFALSE 74483
// points := [ 7 , 25 , 8 ] ;
74464: LD_ADDR_VAR 0 9
74468: PUSH
74469: LD_INT 7
74471: PUSH
74472: LD_INT 25
74474: PUSH
74475: LD_INT 8
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: LIST
74482: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74483: LD_VAR 0 6
74487: PPUSH
74488: CALL_OW 264
74492: PUSH
74493: LD_INT 5
74495: PUSH
74496: LD_INT 27
74498: PUSH
74499: LD_INT 44
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: LIST
74506: IN
74507: IFFALSE 74528
// points := [ 14 , 50 , 16 ] ;
74509: LD_ADDR_VAR 0 9
74513: PUSH
74514: LD_INT 14
74516: PUSH
74517: LD_INT 50
74519: PUSH
74520: LD_INT 16
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: LIST
74527: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74528: LD_VAR 0 6
74532: PPUSH
74533: CALL_OW 264
74537: PUSH
74538: LD_INT 6
74540: PUSH
74541: LD_INT 46
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: IN
74548: IFFALSE 74569
// points := [ 32 , 120 , 70 ] ;
74550: LD_ADDR_VAR 0 9
74554: PUSH
74555: LD_INT 32
74557: PUSH
74558: LD_INT 120
74560: PUSH
74561: LD_INT 70
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: LIST
74568: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74569: LD_VAR 0 6
74573: PPUSH
74574: CALL_OW 264
74578: PUSH
74579: LD_INT 7
74581: PUSH
74582: LD_INT 28
74584: PUSH
74585: LD_INT 45
74587: PUSH
74588: LD_INT 92
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: LIST
74595: LIST
74596: IN
74597: IFFALSE 74618
// points := [ 35 , 20 , 45 ] ;
74599: LD_ADDR_VAR 0 9
74603: PUSH
74604: LD_INT 35
74606: PUSH
74607: LD_INT 20
74609: PUSH
74610: LD_INT 45
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: LIST
74617: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74618: LD_VAR 0 6
74622: PPUSH
74623: CALL_OW 264
74627: PUSH
74628: LD_INT 47
74630: PUSH
74631: EMPTY
74632: LIST
74633: IN
74634: IFFALSE 74655
// points := [ 67 , 45 , 75 ] ;
74636: LD_ADDR_VAR 0 9
74640: PUSH
74641: LD_INT 67
74643: PUSH
74644: LD_INT 45
74646: PUSH
74647: LD_INT 75
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: LIST
74654: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74655: LD_VAR 0 6
74659: PPUSH
74660: CALL_OW 264
74664: PUSH
74665: LD_INT 26
74667: PUSH
74668: EMPTY
74669: LIST
74670: IN
74671: IFFALSE 74692
// points := [ 120 , 30 , 80 ] ;
74673: LD_ADDR_VAR 0 9
74677: PUSH
74678: LD_INT 120
74680: PUSH
74681: LD_INT 30
74683: PUSH
74684: LD_INT 80
74686: PUSH
74687: EMPTY
74688: LIST
74689: LIST
74690: LIST
74691: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74692: LD_VAR 0 6
74696: PPUSH
74697: CALL_OW 264
74701: PUSH
74702: LD_INT 22
74704: PUSH
74705: EMPTY
74706: LIST
74707: IN
74708: IFFALSE 74729
// points := [ 40 , 1 , 1 ] ;
74710: LD_ADDR_VAR 0 9
74714: PUSH
74715: LD_INT 40
74717: PUSH
74718: LD_INT 1
74720: PUSH
74721: LD_INT 1
74723: PUSH
74724: EMPTY
74725: LIST
74726: LIST
74727: LIST
74728: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74729: LD_VAR 0 6
74733: PPUSH
74734: CALL_OW 264
74738: PUSH
74739: LD_INT 29
74741: PUSH
74742: EMPTY
74743: LIST
74744: IN
74745: IFFALSE 74766
// points := [ 70 , 200 , 400 ] ;
74747: LD_ADDR_VAR 0 9
74751: PUSH
74752: LD_INT 70
74754: PUSH
74755: LD_INT 200
74757: PUSH
74758: LD_INT 400
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: LIST
74765: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74766: LD_VAR 0 6
74770: PPUSH
74771: CALL_OW 264
74775: PUSH
74776: LD_INT 14
74778: PUSH
74779: LD_INT 53
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: IN
74786: IFFALSE 74807
// points := [ 40 , 10 , 20 ] ;
74788: LD_ADDR_VAR 0 9
74792: PUSH
74793: LD_INT 40
74795: PUSH
74796: LD_INT 10
74798: PUSH
74799: LD_INT 20
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: LIST
74806: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74807: LD_VAR 0 6
74811: PPUSH
74812: CALL_OW 264
74816: PUSH
74817: LD_INT 9
74819: PUSH
74820: EMPTY
74821: LIST
74822: IN
74823: IFFALSE 74844
// points := [ 5 , 70 , 20 ] ;
74825: LD_ADDR_VAR 0 9
74829: PUSH
74830: LD_INT 5
74832: PUSH
74833: LD_INT 70
74835: PUSH
74836: LD_INT 20
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: LIST
74843: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74844: LD_VAR 0 6
74848: PPUSH
74849: CALL_OW 264
74853: PUSH
74854: LD_INT 10
74856: PUSH
74857: EMPTY
74858: LIST
74859: IN
74860: IFFALSE 74881
// points := [ 35 , 110 , 70 ] ;
74862: LD_ADDR_VAR 0 9
74866: PUSH
74867: LD_INT 35
74869: PUSH
74870: LD_INT 110
74872: PUSH
74873: LD_INT 70
74875: PUSH
74876: EMPTY
74877: LIST
74878: LIST
74879: LIST
74880: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74881: LD_VAR 0 6
74885: PPUSH
74886: CALL_OW 265
74890: PUSH
74891: LD_INT 25
74893: EQUAL
74894: IFFALSE 74915
// points := [ 80 , 65 , 100 ] ;
74896: LD_ADDR_VAR 0 9
74900: PUSH
74901: LD_INT 80
74903: PUSH
74904: LD_INT 65
74906: PUSH
74907: LD_INT 100
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: LIST
74914: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74915: LD_VAR 0 6
74919: PPUSH
74920: CALL_OW 263
74924: PUSH
74925: LD_INT 1
74927: EQUAL
74928: IFFALSE 74963
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74930: LD_ADDR_VAR 0 10
74934: PUSH
74935: LD_VAR 0 10
74939: PUSH
74940: LD_VAR 0 6
74944: PPUSH
74945: CALL_OW 311
74949: PPUSH
74950: LD_INT 3
74952: PPUSH
74953: CALL_OW 259
74957: PUSH
74958: LD_INT 4
74960: MUL
74961: MUL
74962: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74963: LD_VAR 0 6
74967: PPUSH
74968: CALL_OW 263
74972: PUSH
74973: LD_INT 2
74975: EQUAL
74976: IFFALSE 75027
// begin j := IsControledBy ( i ) ;
74978: LD_ADDR_VAR 0 7
74982: PUSH
74983: LD_VAR 0 6
74987: PPUSH
74988: CALL_OW 312
74992: ST_TO_ADDR
// if j then
74993: LD_VAR 0 7
74997: IFFALSE 75027
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74999: LD_ADDR_VAR 0 10
75003: PUSH
75004: LD_VAR 0 10
75008: PUSH
75009: LD_VAR 0 7
75013: PPUSH
75014: LD_INT 3
75016: PPUSH
75017: CALL_OW 259
75021: PUSH
75022: LD_INT 3
75024: MUL
75025: MUL
75026: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
75027: LD_VAR 0 6
75031: PPUSH
75032: CALL_OW 264
75036: PUSH
75037: LD_INT 5
75039: PUSH
75040: LD_INT 6
75042: PUSH
75043: LD_INT 46
75045: PUSH
75046: LD_INT 44
75048: PUSH
75049: LD_INT 47
75051: PUSH
75052: LD_INT 45
75054: PUSH
75055: LD_INT 28
75057: PUSH
75058: LD_INT 7
75060: PUSH
75061: LD_INT 27
75063: PUSH
75064: LD_INT 29
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: IN
75079: PUSH
75080: LD_VAR 0 1
75084: PPUSH
75085: LD_INT 52
75087: PPUSH
75088: CALL_OW 321
75092: PUSH
75093: LD_INT 2
75095: EQUAL
75096: AND
75097: IFFALSE 75114
// bpoints := bpoints * 1.2 ;
75099: LD_ADDR_VAR 0 10
75103: PUSH
75104: LD_VAR 0 10
75108: PUSH
75109: LD_REAL  1.20000000000000E+0000
75112: MUL
75113: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
75114: LD_VAR 0 6
75118: PPUSH
75119: CALL_OW 264
75123: PUSH
75124: LD_INT 6
75126: PUSH
75127: LD_INT 46
75129: PUSH
75130: LD_INT 47
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: LIST
75137: IN
75138: IFFALSE 75155
// bpoints := bpoints * 1.2 ;
75140: LD_ADDR_VAR 0 10
75144: PUSH
75145: LD_VAR 0 10
75149: PUSH
75150: LD_REAL  1.20000000000000E+0000
75153: MUL
75154: ST_TO_ADDR
// end ; unit_building :
75155: GO 75169
75157: LD_INT 3
75159: DOUBLE
75160: EQUAL
75161: IFTRUE 75165
75163: GO 75168
75165: POP
// ; end ;
75166: GO 75169
75168: POP
// for j = 1 to 3 do
75169: LD_ADDR_VAR 0 7
75173: PUSH
75174: DOUBLE
75175: LD_INT 1
75177: DEC
75178: ST_TO_ADDR
75179: LD_INT 3
75181: PUSH
75182: FOR_TO
75183: IFFALSE 75236
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
75185: LD_ADDR_VAR 0 5
75189: PUSH
75190: LD_VAR 0 5
75194: PPUSH
75195: LD_VAR 0 7
75199: PPUSH
75200: LD_VAR 0 5
75204: PUSH
75205: LD_VAR 0 7
75209: ARRAY
75210: PUSH
75211: LD_VAR 0 9
75215: PUSH
75216: LD_VAR 0 7
75220: ARRAY
75221: PUSH
75222: LD_VAR 0 10
75226: MUL
75227: PLUS
75228: PPUSH
75229: CALL_OW 1
75233: ST_TO_ADDR
75234: GO 75182
75236: POP
75237: POP
// end ;
75238: GO 73717
75240: POP
75241: POP
// result := Replace ( result , 4 , tmp ) ;
75242: LD_ADDR_VAR 0 5
75246: PUSH
75247: LD_VAR 0 5
75251: PPUSH
75252: LD_INT 4
75254: PPUSH
75255: LD_VAR 0 8
75259: PPUSH
75260: CALL_OW 1
75264: ST_TO_ADDR
// end ;
75265: LD_VAR 0 5
75269: RET
// export function DangerAtRange ( unit , range ) ; begin
75270: LD_INT 0
75272: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
75273: LD_ADDR_VAR 0 3
75277: PUSH
75278: LD_VAR 0 1
75282: PPUSH
75283: CALL_OW 255
75287: PPUSH
75288: LD_VAR 0 1
75292: PPUSH
75293: CALL_OW 250
75297: PPUSH
75298: LD_VAR 0 1
75302: PPUSH
75303: CALL_OW 251
75307: PPUSH
75308: LD_VAR 0 2
75312: PPUSH
75313: CALL 73569 0 4
75317: ST_TO_ADDR
// end ;
75318: LD_VAR 0 3
75322: RET
// export function DangerInArea ( side , area ) ; begin
75323: LD_INT 0
75325: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
75326: LD_ADDR_VAR 0 3
75330: PUSH
75331: LD_VAR 0 2
75335: PPUSH
75336: LD_INT 81
75338: PUSH
75339: LD_VAR 0 1
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PPUSH
75348: CALL_OW 70
75352: ST_TO_ADDR
// end ;
75353: LD_VAR 0 3
75357: RET
// export function IsExtension ( b ) ; begin
75358: LD_INT 0
75360: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75361: LD_ADDR_VAR 0 2
75365: PUSH
75366: LD_VAR 0 1
75370: PUSH
75371: LD_INT 23
75373: PUSH
75374: LD_INT 20
75376: PUSH
75377: LD_INT 22
75379: PUSH
75380: LD_INT 17
75382: PUSH
75383: LD_INT 24
75385: PUSH
75386: LD_INT 21
75388: PUSH
75389: LD_INT 19
75391: PUSH
75392: LD_INT 16
75394: PUSH
75395: LD_INT 25
75397: PUSH
75398: LD_INT 18
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: LIST
75409: LIST
75410: LIST
75411: LIST
75412: IN
75413: ST_TO_ADDR
// end ;
75414: LD_VAR 0 2
75418: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75419: LD_INT 0
75421: PPUSH
75422: PPUSH
75423: PPUSH
// result := [ ] ;
75424: LD_ADDR_VAR 0 4
75428: PUSH
75429: EMPTY
75430: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75431: LD_ADDR_VAR 0 5
75435: PUSH
75436: LD_VAR 0 2
75440: PPUSH
75441: LD_INT 21
75443: PUSH
75444: LD_INT 3
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PPUSH
75451: CALL_OW 70
75455: ST_TO_ADDR
// if not tmp then
75456: LD_VAR 0 5
75460: NOT
75461: IFFALSE 75465
// exit ;
75463: GO 75529
// if checkLink then
75465: LD_VAR 0 3
75469: IFFALSE 75519
// begin for i in tmp do
75471: LD_ADDR_VAR 0 6
75475: PUSH
75476: LD_VAR 0 5
75480: PUSH
75481: FOR_IN
75482: IFFALSE 75517
// if GetBase ( i ) <> base then
75484: LD_VAR 0 6
75488: PPUSH
75489: CALL_OW 274
75493: PUSH
75494: LD_VAR 0 1
75498: NONEQUAL
75499: IFFALSE 75515
// ComLinkToBase ( base , i ) ;
75501: LD_VAR 0 1
75505: PPUSH
75506: LD_VAR 0 6
75510: PPUSH
75511: CALL_OW 169
75515: GO 75481
75517: POP
75518: POP
// end ; result := tmp ;
75519: LD_ADDR_VAR 0 4
75523: PUSH
75524: LD_VAR 0 5
75528: ST_TO_ADDR
// end ;
75529: LD_VAR 0 4
75533: RET
// export function ComComplete ( units , b ) ; var i ; begin
75534: LD_INT 0
75536: PPUSH
75537: PPUSH
// if not units then
75538: LD_VAR 0 1
75542: NOT
75543: IFFALSE 75547
// exit ;
75545: GO 75637
// for i in units do
75547: LD_ADDR_VAR 0 4
75551: PUSH
75552: LD_VAR 0 1
75556: PUSH
75557: FOR_IN
75558: IFFALSE 75635
// if BuildingStatus ( b ) = bs_build then
75560: LD_VAR 0 2
75564: PPUSH
75565: CALL_OW 461
75569: PUSH
75570: LD_INT 1
75572: EQUAL
75573: IFFALSE 75633
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75575: LD_VAR 0 4
75579: PPUSH
75580: LD_STRING h
75582: PUSH
75583: LD_VAR 0 2
75587: PPUSH
75588: CALL_OW 250
75592: PUSH
75593: LD_VAR 0 2
75597: PPUSH
75598: CALL_OW 251
75602: PUSH
75603: LD_VAR 0 2
75607: PUSH
75608: LD_INT 0
75610: PUSH
75611: LD_INT 0
75613: PUSH
75614: LD_INT 0
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: LIST
75621: LIST
75622: LIST
75623: LIST
75624: LIST
75625: PUSH
75626: EMPTY
75627: LIST
75628: PPUSH
75629: CALL_OW 446
75633: GO 75557
75635: POP
75636: POP
// end ;
75637: LD_VAR 0 3
75641: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75642: LD_INT 0
75644: PPUSH
75645: PPUSH
75646: PPUSH
75647: PPUSH
75648: PPUSH
75649: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75650: LD_VAR 0 1
75654: NOT
75655: PUSH
75656: LD_VAR 0 1
75660: PPUSH
75661: CALL_OW 263
75665: PUSH
75666: LD_INT 2
75668: NONEQUAL
75669: OR
75670: IFFALSE 75674
// exit ;
75672: GO 75990
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75674: LD_ADDR_VAR 0 6
75678: PUSH
75679: LD_INT 22
75681: PUSH
75682: LD_VAR 0 1
75686: PPUSH
75687: CALL_OW 255
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: LD_INT 2
75698: PUSH
75699: LD_INT 30
75701: PUSH
75702: LD_INT 36
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 34
75711: PUSH
75712: LD_INT 31
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: LIST
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PPUSH
75728: CALL_OW 69
75732: ST_TO_ADDR
// if not tmp then
75733: LD_VAR 0 6
75737: NOT
75738: IFFALSE 75742
// exit ;
75740: GO 75990
// result := [ ] ;
75742: LD_ADDR_VAR 0 2
75746: PUSH
75747: EMPTY
75748: ST_TO_ADDR
// for i in tmp do
75749: LD_ADDR_VAR 0 3
75753: PUSH
75754: LD_VAR 0 6
75758: PUSH
75759: FOR_IN
75760: IFFALSE 75831
// begin t := UnitsInside ( i ) ;
75762: LD_ADDR_VAR 0 4
75766: PUSH
75767: LD_VAR 0 3
75771: PPUSH
75772: CALL_OW 313
75776: ST_TO_ADDR
// if t then
75777: LD_VAR 0 4
75781: IFFALSE 75829
// for j in t do
75783: LD_ADDR_VAR 0 7
75787: PUSH
75788: LD_VAR 0 4
75792: PUSH
75793: FOR_IN
75794: IFFALSE 75827
// result := Replace ( result , result + 1 , j ) ;
75796: LD_ADDR_VAR 0 2
75800: PUSH
75801: LD_VAR 0 2
75805: PPUSH
75806: LD_VAR 0 2
75810: PUSH
75811: LD_INT 1
75813: PLUS
75814: PPUSH
75815: LD_VAR 0 7
75819: PPUSH
75820: CALL_OW 1
75824: ST_TO_ADDR
75825: GO 75793
75827: POP
75828: POP
// end ;
75829: GO 75759
75831: POP
75832: POP
// if not result then
75833: LD_VAR 0 2
75837: NOT
75838: IFFALSE 75842
// exit ;
75840: GO 75990
// mech := result [ 1 ] ;
75842: LD_ADDR_VAR 0 5
75846: PUSH
75847: LD_VAR 0 2
75851: PUSH
75852: LD_INT 1
75854: ARRAY
75855: ST_TO_ADDR
// if result > 1 then
75856: LD_VAR 0 2
75860: PUSH
75861: LD_INT 1
75863: GREATER
75864: IFFALSE 75976
// begin for i = 2 to result do
75866: LD_ADDR_VAR 0 3
75870: PUSH
75871: DOUBLE
75872: LD_INT 2
75874: DEC
75875: ST_TO_ADDR
75876: LD_VAR 0 2
75880: PUSH
75881: FOR_TO
75882: IFFALSE 75974
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75884: LD_ADDR_VAR 0 4
75888: PUSH
75889: LD_VAR 0 2
75893: PUSH
75894: LD_VAR 0 3
75898: ARRAY
75899: PPUSH
75900: LD_INT 3
75902: PPUSH
75903: CALL_OW 259
75907: PUSH
75908: LD_VAR 0 2
75912: PUSH
75913: LD_VAR 0 3
75917: ARRAY
75918: PPUSH
75919: CALL_OW 432
75923: MINUS
75924: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75925: LD_VAR 0 4
75929: PUSH
75930: LD_VAR 0 5
75934: PPUSH
75935: LD_INT 3
75937: PPUSH
75938: CALL_OW 259
75942: PUSH
75943: LD_VAR 0 5
75947: PPUSH
75948: CALL_OW 432
75952: MINUS
75953: GREATEREQUAL
75954: IFFALSE 75972
// mech := result [ i ] ;
75956: LD_ADDR_VAR 0 5
75960: PUSH
75961: LD_VAR 0 2
75965: PUSH
75966: LD_VAR 0 3
75970: ARRAY
75971: ST_TO_ADDR
// end ;
75972: GO 75881
75974: POP
75975: POP
// end ; ComLinkTo ( vehicle , mech ) ;
75976: LD_VAR 0 1
75980: PPUSH
75981: LD_VAR 0 5
75985: PPUSH
75986: CALL_OW 135
// end ;
75990: LD_VAR 0 2
75994: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75995: LD_INT 0
75997: PPUSH
75998: PPUSH
75999: PPUSH
76000: PPUSH
76001: PPUSH
76002: PPUSH
76003: PPUSH
76004: PPUSH
76005: PPUSH
76006: PPUSH
76007: PPUSH
76008: PPUSH
76009: PPUSH
// result := [ ] ;
76010: LD_ADDR_VAR 0 7
76014: PUSH
76015: EMPTY
76016: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
76017: LD_VAR 0 1
76021: PPUSH
76022: CALL_OW 266
76026: PUSH
76027: LD_INT 0
76029: PUSH
76030: LD_INT 1
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: IN
76037: NOT
76038: IFFALSE 76042
// exit ;
76040: GO 77676
// if name then
76042: LD_VAR 0 3
76046: IFFALSE 76062
// SetBName ( base_dep , name ) ;
76048: LD_VAR 0 1
76052: PPUSH
76053: LD_VAR 0 3
76057: PPUSH
76058: CALL_OW 500
// base := GetBase ( base_dep ) ;
76062: LD_ADDR_VAR 0 15
76066: PUSH
76067: LD_VAR 0 1
76071: PPUSH
76072: CALL_OW 274
76076: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
76077: LD_ADDR_VAR 0 16
76081: PUSH
76082: LD_VAR 0 1
76086: PPUSH
76087: CALL_OW 255
76091: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
76092: LD_ADDR_VAR 0 17
76096: PUSH
76097: LD_VAR 0 1
76101: PPUSH
76102: CALL_OW 248
76106: ST_TO_ADDR
// if sources then
76107: LD_VAR 0 5
76111: IFFALSE 76158
// for i = 1 to 3 do
76113: LD_ADDR_VAR 0 8
76117: PUSH
76118: DOUBLE
76119: LD_INT 1
76121: DEC
76122: ST_TO_ADDR
76123: LD_INT 3
76125: PUSH
76126: FOR_TO
76127: IFFALSE 76156
// AddResourceType ( base , i , sources [ i ] ) ;
76129: LD_VAR 0 15
76133: PPUSH
76134: LD_VAR 0 8
76138: PPUSH
76139: LD_VAR 0 5
76143: PUSH
76144: LD_VAR 0 8
76148: ARRAY
76149: PPUSH
76150: CALL_OW 276
76154: GO 76126
76156: POP
76157: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
76158: LD_ADDR_VAR 0 18
76162: PUSH
76163: LD_VAR 0 15
76167: PPUSH
76168: LD_VAR 0 2
76172: PPUSH
76173: LD_INT 1
76175: PPUSH
76176: CALL 75419 0 3
76180: ST_TO_ADDR
// InitHc ;
76181: CALL_OW 19
// InitUc ;
76185: CALL_OW 18
// uc_side := side ;
76189: LD_ADDR_OWVAR 20
76193: PUSH
76194: LD_VAR 0 16
76198: ST_TO_ADDR
// uc_nation := nation ;
76199: LD_ADDR_OWVAR 21
76203: PUSH
76204: LD_VAR 0 17
76208: ST_TO_ADDR
// if buildings then
76209: LD_VAR 0 18
76213: IFFALSE 77535
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
76215: LD_ADDR_VAR 0 19
76219: PUSH
76220: LD_VAR 0 18
76224: PPUSH
76225: LD_INT 2
76227: PUSH
76228: LD_INT 30
76230: PUSH
76231: LD_INT 29
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: LD_INT 30
76240: PUSH
76241: LD_INT 30
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: LIST
76252: PPUSH
76253: CALL_OW 72
76257: ST_TO_ADDR
// if tmp then
76258: LD_VAR 0 19
76262: IFFALSE 76310
// for i in tmp do
76264: LD_ADDR_VAR 0 8
76268: PUSH
76269: LD_VAR 0 19
76273: PUSH
76274: FOR_IN
76275: IFFALSE 76308
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
76277: LD_VAR 0 8
76281: PPUSH
76282: CALL_OW 250
76286: PPUSH
76287: LD_VAR 0 8
76291: PPUSH
76292: CALL_OW 251
76296: PPUSH
76297: LD_VAR 0 16
76301: PPUSH
76302: CALL_OW 441
76306: GO 76274
76308: POP
76309: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
76310: LD_VAR 0 18
76314: PPUSH
76315: LD_INT 2
76317: PUSH
76318: LD_INT 30
76320: PUSH
76321: LD_INT 32
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PUSH
76328: LD_INT 30
76330: PUSH
76331: LD_INT 33
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: EMPTY
76339: LIST
76340: LIST
76341: LIST
76342: PPUSH
76343: CALL_OW 72
76347: IFFALSE 76435
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76349: LD_ADDR_VAR 0 8
76353: PUSH
76354: LD_VAR 0 18
76358: PPUSH
76359: LD_INT 2
76361: PUSH
76362: LD_INT 30
76364: PUSH
76365: LD_INT 32
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 30
76374: PUSH
76375: LD_INT 33
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: LIST
76386: PPUSH
76387: CALL_OW 72
76391: PUSH
76392: FOR_IN
76393: IFFALSE 76433
// begin if not GetBWeapon ( i ) then
76395: LD_VAR 0 8
76399: PPUSH
76400: CALL_OW 269
76404: NOT
76405: IFFALSE 76431
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76407: LD_VAR 0 8
76411: PPUSH
76412: LD_VAR 0 8
76416: PPUSH
76417: LD_VAR 0 2
76421: PPUSH
76422: CALL 77681 0 2
76426: PPUSH
76427: CALL_OW 431
// end ;
76431: GO 76392
76433: POP
76434: POP
// end ; for i = 1 to personel do
76435: LD_ADDR_VAR 0 8
76439: PUSH
76440: DOUBLE
76441: LD_INT 1
76443: DEC
76444: ST_TO_ADDR
76445: LD_VAR 0 6
76449: PUSH
76450: FOR_TO
76451: IFFALSE 77515
// begin if i > 4 then
76453: LD_VAR 0 8
76457: PUSH
76458: LD_INT 4
76460: GREATER
76461: IFFALSE 76465
// break ;
76463: GO 77515
// case i of 1 :
76465: LD_VAR 0 8
76469: PUSH
76470: LD_INT 1
76472: DOUBLE
76473: EQUAL
76474: IFTRUE 76478
76476: GO 76558
76478: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76479: LD_ADDR_VAR 0 12
76483: PUSH
76484: LD_VAR 0 18
76488: PPUSH
76489: LD_INT 22
76491: PUSH
76492: LD_VAR 0 16
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 58
76503: PUSH
76504: EMPTY
76505: LIST
76506: PUSH
76507: LD_INT 2
76509: PUSH
76510: LD_INT 30
76512: PUSH
76513: LD_INT 32
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 30
76522: PUSH
76523: LD_INT 4
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 30
76532: PUSH
76533: LD_INT 5
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: LIST
76544: LIST
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: LIST
76550: PPUSH
76551: CALL_OW 72
76555: ST_TO_ADDR
76556: GO 76780
76558: LD_INT 2
76560: DOUBLE
76561: EQUAL
76562: IFTRUE 76566
76564: GO 76628
76566: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76567: LD_ADDR_VAR 0 12
76571: PUSH
76572: LD_VAR 0 18
76576: PPUSH
76577: LD_INT 22
76579: PUSH
76580: LD_VAR 0 16
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: LD_INT 2
76591: PUSH
76592: LD_INT 30
76594: PUSH
76595: LD_INT 0
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 30
76604: PUSH
76605: LD_INT 1
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: LIST
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PPUSH
76621: CALL_OW 72
76625: ST_TO_ADDR
76626: GO 76780
76628: LD_INT 3
76630: DOUBLE
76631: EQUAL
76632: IFTRUE 76636
76634: GO 76698
76636: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76637: LD_ADDR_VAR 0 12
76641: PUSH
76642: LD_VAR 0 18
76646: PPUSH
76647: LD_INT 22
76649: PUSH
76650: LD_VAR 0 16
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: PUSH
76659: LD_INT 2
76661: PUSH
76662: LD_INT 30
76664: PUSH
76665: LD_INT 2
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: LD_INT 30
76674: PUSH
76675: LD_INT 3
76677: PUSH
76678: EMPTY
76679: LIST
76680: LIST
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: LIST
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: PPUSH
76691: CALL_OW 72
76695: ST_TO_ADDR
76696: GO 76780
76698: LD_INT 4
76700: DOUBLE
76701: EQUAL
76702: IFTRUE 76706
76704: GO 76779
76706: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76707: LD_ADDR_VAR 0 12
76711: PUSH
76712: LD_VAR 0 18
76716: PPUSH
76717: LD_INT 22
76719: PUSH
76720: LD_VAR 0 16
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 2
76731: PUSH
76732: LD_INT 30
76734: PUSH
76735: LD_INT 6
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: LD_INT 30
76744: PUSH
76745: LD_INT 7
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: PUSH
76752: LD_INT 30
76754: PUSH
76755: LD_INT 8
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: EMPTY
76763: LIST
76764: LIST
76765: LIST
76766: LIST
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PPUSH
76772: CALL_OW 72
76776: ST_TO_ADDR
76777: GO 76780
76779: POP
// if i = 1 then
76780: LD_VAR 0 8
76784: PUSH
76785: LD_INT 1
76787: EQUAL
76788: IFFALSE 76899
// begin tmp := [ ] ;
76790: LD_ADDR_VAR 0 19
76794: PUSH
76795: EMPTY
76796: ST_TO_ADDR
// for j in f do
76797: LD_ADDR_VAR 0 9
76801: PUSH
76802: LD_VAR 0 12
76806: PUSH
76807: FOR_IN
76808: IFFALSE 76881
// if GetBType ( j ) = b_bunker then
76810: LD_VAR 0 9
76814: PPUSH
76815: CALL_OW 266
76819: PUSH
76820: LD_INT 32
76822: EQUAL
76823: IFFALSE 76850
// tmp := Insert ( tmp , 1 , j ) else
76825: LD_ADDR_VAR 0 19
76829: PUSH
76830: LD_VAR 0 19
76834: PPUSH
76835: LD_INT 1
76837: PPUSH
76838: LD_VAR 0 9
76842: PPUSH
76843: CALL_OW 2
76847: ST_TO_ADDR
76848: GO 76879
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76850: LD_ADDR_VAR 0 19
76854: PUSH
76855: LD_VAR 0 19
76859: PPUSH
76860: LD_VAR 0 19
76864: PUSH
76865: LD_INT 1
76867: PLUS
76868: PPUSH
76869: LD_VAR 0 9
76873: PPUSH
76874: CALL_OW 2
76878: ST_TO_ADDR
76879: GO 76807
76881: POP
76882: POP
// if tmp then
76883: LD_VAR 0 19
76887: IFFALSE 76899
// f := tmp ;
76889: LD_ADDR_VAR 0 12
76893: PUSH
76894: LD_VAR 0 19
76898: ST_TO_ADDR
// end ; x := personel [ i ] ;
76899: LD_ADDR_VAR 0 13
76903: PUSH
76904: LD_VAR 0 6
76908: PUSH
76909: LD_VAR 0 8
76913: ARRAY
76914: ST_TO_ADDR
// if x = - 1 then
76915: LD_VAR 0 13
76919: PUSH
76920: LD_INT 1
76922: NEG
76923: EQUAL
76924: IFFALSE 77133
// begin for j in f do
76926: LD_ADDR_VAR 0 9
76930: PUSH
76931: LD_VAR 0 12
76935: PUSH
76936: FOR_IN
76937: IFFALSE 77129
// repeat InitHc ;
76939: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76943: LD_VAR 0 9
76947: PPUSH
76948: CALL_OW 266
76952: PUSH
76953: LD_INT 5
76955: EQUAL
76956: IFFALSE 77026
// begin if UnitsInside ( j ) < 3 then
76958: LD_VAR 0 9
76962: PPUSH
76963: CALL_OW 313
76967: PUSH
76968: LD_INT 3
76970: LESS
76971: IFFALSE 77007
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76973: LD_INT 0
76975: PPUSH
76976: LD_INT 5
76978: PUSH
76979: LD_INT 8
76981: PUSH
76982: LD_INT 9
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: LIST
76989: PUSH
76990: LD_VAR 0 17
76994: ARRAY
76995: PPUSH
76996: LD_VAR 0 4
77000: PPUSH
77001: CALL_OW 380
77005: GO 77024
// PrepareHuman ( false , i , skill ) ;
77007: LD_INT 0
77009: PPUSH
77010: LD_VAR 0 8
77014: PPUSH
77015: LD_VAR 0 4
77019: PPUSH
77020: CALL_OW 380
// end else
77024: GO 77043
// PrepareHuman ( false , i , skill ) ;
77026: LD_INT 0
77028: PPUSH
77029: LD_VAR 0 8
77033: PPUSH
77034: LD_VAR 0 4
77038: PPUSH
77039: CALL_OW 380
// un := CreateHuman ;
77043: LD_ADDR_VAR 0 14
77047: PUSH
77048: CALL_OW 44
77052: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77053: LD_ADDR_VAR 0 7
77057: PUSH
77058: LD_VAR 0 7
77062: PPUSH
77063: LD_INT 1
77065: PPUSH
77066: LD_VAR 0 14
77070: PPUSH
77071: CALL_OW 2
77075: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
77076: LD_VAR 0 14
77080: PPUSH
77081: LD_VAR 0 9
77085: PPUSH
77086: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
77090: LD_VAR 0 9
77094: PPUSH
77095: CALL_OW 313
77099: PUSH
77100: LD_INT 6
77102: EQUAL
77103: PUSH
77104: LD_VAR 0 9
77108: PPUSH
77109: CALL_OW 266
77113: PUSH
77114: LD_INT 32
77116: PUSH
77117: LD_INT 31
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: IN
77124: OR
77125: IFFALSE 76939
77127: GO 76936
77129: POP
77130: POP
// end else
77131: GO 77513
// for j = 1 to x do
77133: LD_ADDR_VAR 0 9
77137: PUSH
77138: DOUBLE
77139: LD_INT 1
77141: DEC
77142: ST_TO_ADDR
77143: LD_VAR 0 13
77147: PUSH
77148: FOR_TO
77149: IFFALSE 77511
// begin InitHc ;
77151: CALL_OW 19
// if not f then
77155: LD_VAR 0 12
77159: NOT
77160: IFFALSE 77249
// begin PrepareHuman ( false , i , skill ) ;
77162: LD_INT 0
77164: PPUSH
77165: LD_VAR 0 8
77169: PPUSH
77170: LD_VAR 0 4
77174: PPUSH
77175: CALL_OW 380
// un := CreateHuman ;
77179: LD_ADDR_VAR 0 14
77183: PUSH
77184: CALL_OW 44
77188: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77189: LD_ADDR_VAR 0 7
77193: PUSH
77194: LD_VAR 0 7
77198: PPUSH
77199: LD_INT 1
77201: PPUSH
77202: LD_VAR 0 14
77206: PPUSH
77207: CALL_OW 2
77211: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77212: LD_VAR 0 14
77216: PPUSH
77217: LD_VAR 0 1
77221: PPUSH
77222: CALL_OW 250
77226: PPUSH
77227: LD_VAR 0 1
77231: PPUSH
77232: CALL_OW 251
77236: PPUSH
77237: LD_INT 10
77239: PPUSH
77240: LD_INT 0
77242: PPUSH
77243: CALL_OW 50
// continue ;
77247: GO 77148
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
77249: LD_VAR 0 12
77253: PUSH
77254: LD_INT 1
77256: ARRAY
77257: PPUSH
77258: CALL_OW 313
77262: PUSH
77263: LD_VAR 0 12
77267: PUSH
77268: LD_INT 1
77270: ARRAY
77271: PPUSH
77272: CALL_OW 266
77276: PUSH
77277: LD_INT 32
77279: PUSH
77280: LD_INT 31
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: IN
77287: AND
77288: PUSH
77289: LD_VAR 0 12
77293: PUSH
77294: LD_INT 1
77296: ARRAY
77297: PPUSH
77298: CALL_OW 313
77302: PUSH
77303: LD_INT 6
77305: EQUAL
77306: OR
77307: IFFALSE 77327
// f := Delete ( f , 1 ) ;
77309: LD_ADDR_VAR 0 12
77313: PUSH
77314: LD_VAR 0 12
77318: PPUSH
77319: LD_INT 1
77321: PPUSH
77322: CALL_OW 3
77326: ST_TO_ADDR
// if not f then
77327: LD_VAR 0 12
77331: NOT
77332: IFFALSE 77350
// begin x := x + 2 ;
77334: LD_ADDR_VAR 0 13
77338: PUSH
77339: LD_VAR 0 13
77343: PUSH
77344: LD_INT 2
77346: PLUS
77347: ST_TO_ADDR
// continue ;
77348: GO 77148
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77350: LD_VAR 0 12
77354: PUSH
77355: LD_INT 1
77357: ARRAY
77358: PPUSH
77359: CALL_OW 266
77363: PUSH
77364: LD_INT 5
77366: EQUAL
77367: IFFALSE 77441
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77369: LD_VAR 0 12
77373: PUSH
77374: LD_INT 1
77376: ARRAY
77377: PPUSH
77378: CALL_OW 313
77382: PUSH
77383: LD_INT 3
77385: LESS
77386: IFFALSE 77422
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77388: LD_INT 0
77390: PPUSH
77391: LD_INT 5
77393: PUSH
77394: LD_INT 8
77396: PUSH
77397: LD_INT 9
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: LIST
77404: PUSH
77405: LD_VAR 0 17
77409: ARRAY
77410: PPUSH
77411: LD_VAR 0 4
77415: PPUSH
77416: CALL_OW 380
77420: GO 77439
// PrepareHuman ( false , i , skill ) ;
77422: LD_INT 0
77424: PPUSH
77425: LD_VAR 0 8
77429: PPUSH
77430: LD_VAR 0 4
77434: PPUSH
77435: CALL_OW 380
// end else
77439: GO 77458
// PrepareHuman ( false , i , skill ) ;
77441: LD_INT 0
77443: PPUSH
77444: LD_VAR 0 8
77448: PPUSH
77449: LD_VAR 0 4
77453: PPUSH
77454: CALL_OW 380
// un := CreateHuman ;
77458: LD_ADDR_VAR 0 14
77462: PUSH
77463: CALL_OW 44
77467: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77468: LD_ADDR_VAR 0 7
77472: PUSH
77473: LD_VAR 0 7
77477: PPUSH
77478: LD_INT 1
77480: PPUSH
77481: LD_VAR 0 14
77485: PPUSH
77486: CALL_OW 2
77490: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77491: LD_VAR 0 14
77495: PPUSH
77496: LD_VAR 0 12
77500: PUSH
77501: LD_INT 1
77503: ARRAY
77504: PPUSH
77505: CALL_OW 52
// end ;
77509: GO 77148
77511: POP
77512: POP
// end ;
77513: GO 76450
77515: POP
77516: POP
// result := result ^ buildings ;
77517: LD_ADDR_VAR 0 7
77521: PUSH
77522: LD_VAR 0 7
77526: PUSH
77527: LD_VAR 0 18
77531: ADD
77532: ST_TO_ADDR
// end else
77533: GO 77676
// begin for i = 1 to personel do
77535: LD_ADDR_VAR 0 8
77539: PUSH
77540: DOUBLE
77541: LD_INT 1
77543: DEC
77544: ST_TO_ADDR
77545: LD_VAR 0 6
77549: PUSH
77550: FOR_TO
77551: IFFALSE 77674
// begin if i > 4 then
77553: LD_VAR 0 8
77557: PUSH
77558: LD_INT 4
77560: GREATER
77561: IFFALSE 77565
// break ;
77563: GO 77674
// x := personel [ i ] ;
77565: LD_ADDR_VAR 0 13
77569: PUSH
77570: LD_VAR 0 6
77574: PUSH
77575: LD_VAR 0 8
77579: ARRAY
77580: ST_TO_ADDR
// if x = - 1 then
77581: LD_VAR 0 13
77585: PUSH
77586: LD_INT 1
77588: NEG
77589: EQUAL
77590: IFFALSE 77594
// continue ;
77592: GO 77550
// PrepareHuman ( false , i , skill ) ;
77594: LD_INT 0
77596: PPUSH
77597: LD_VAR 0 8
77601: PPUSH
77602: LD_VAR 0 4
77606: PPUSH
77607: CALL_OW 380
// un := CreateHuman ;
77611: LD_ADDR_VAR 0 14
77615: PUSH
77616: CALL_OW 44
77620: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77621: LD_VAR 0 14
77625: PPUSH
77626: LD_VAR 0 1
77630: PPUSH
77631: CALL_OW 250
77635: PPUSH
77636: LD_VAR 0 1
77640: PPUSH
77641: CALL_OW 251
77645: PPUSH
77646: LD_INT 10
77648: PPUSH
77649: LD_INT 0
77651: PPUSH
77652: CALL_OW 50
// result := result ^ un ;
77656: LD_ADDR_VAR 0 7
77660: PUSH
77661: LD_VAR 0 7
77665: PUSH
77666: LD_VAR 0 14
77670: ADD
77671: ST_TO_ADDR
// end ;
77672: GO 77550
77674: POP
77675: POP
// end ; end ;
77676: LD_VAR 0 7
77680: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77681: LD_INT 0
77683: PPUSH
77684: PPUSH
77685: PPUSH
77686: PPUSH
77687: PPUSH
77688: PPUSH
77689: PPUSH
77690: PPUSH
77691: PPUSH
77692: PPUSH
77693: PPUSH
77694: PPUSH
77695: PPUSH
77696: PPUSH
77697: PPUSH
77698: PPUSH
// result := false ;
77699: LD_ADDR_VAR 0 3
77703: PUSH
77704: LD_INT 0
77706: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77707: LD_VAR 0 1
77711: NOT
77712: PUSH
77713: LD_VAR 0 1
77717: PPUSH
77718: CALL_OW 266
77722: PUSH
77723: LD_INT 32
77725: PUSH
77726: LD_INT 33
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: IN
77733: NOT
77734: OR
77735: IFFALSE 77739
// exit ;
77737: GO 78848
// nat := GetNation ( tower ) ;
77739: LD_ADDR_VAR 0 12
77743: PUSH
77744: LD_VAR 0 1
77748: PPUSH
77749: CALL_OW 248
77753: ST_TO_ADDR
// side := GetSide ( tower ) ;
77754: LD_ADDR_VAR 0 16
77758: PUSH
77759: LD_VAR 0 1
77763: PPUSH
77764: CALL_OW 255
77768: ST_TO_ADDR
// x := GetX ( tower ) ;
77769: LD_ADDR_VAR 0 10
77773: PUSH
77774: LD_VAR 0 1
77778: PPUSH
77779: CALL_OW 250
77783: ST_TO_ADDR
// y := GetY ( tower ) ;
77784: LD_ADDR_VAR 0 11
77788: PUSH
77789: LD_VAR 0 1
77793: PPUSH
77794: CALL_OW 251
77798: ST_TO_ADDR
// if not x or not y then
77799: LD_VAR 0 10
77803: NOT
77804: PUSH
77805: LD_VAR 0 11
77809: NOT
77810: OR
77811: IFFALSE 77815
// exit ;
77813: GO 78848
// weapon := 0 ;
77815: LD_ADDR_VAR 0 18
77819: PUSH
77820: LD_INT 0
77822: ST_TO_ADDR
// fac_list := [ ] ;
77823: LD_ADDR_VAR 0 17
77827: PUSH
77828: EMPTY
77829: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
77830: LD_ADDR_VAR 0 6
77834: PUSH
77835: LD_VAR 0 1
77839: PPUSH
77840: CALL_OW 274
77844: PPUSH
77845: LD_VAR 0 2
77849: PPUSH
77850: LD_INT 0
77852: PPUSH
77853: CALL 75419 0 3
77857: PPUSH
77858: LD_INT 30
77860: PUSH
77861: LD_INT 3
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PPUSH
77868: CALL_OW 72
77872: ST_TO_ADDR
// if not factories then
77873: LD_VAR 0 6
77877: NOT
77878: IFFALSE 77882
// exit ;
77880: GO 78848
// for i in factories do
77882: LD_ADDR_VAR 0 8
77886: PUSH
77887: LD_VAR 0 6
77891: PUSH
77892: FOR_IN
77893: IFFALSE 77918
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77895: LD_ADDR_VAR 0 17
77899: PUSH
77900: LD_VAR 0 17
77904: PUSH
77905: LD_VAR 0 8
77909: PPUSH
77910: CALL_OW 478
77914: UNION
77915: ST_TO_ADDR
77916: GO 77892
77918: POP
77919: POP
// if not fac_list then
77920: LD_VAR 0 17
77924: NOT
77925: IFFALSE 77929
// exit ;
77927: GO 78848
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77929: LD_ADDR_VAR 0 5
77933: PUSH
77934: LD_INT 4
77936: PUSH
77937: LD_INT 5
77939: PUSH
77940: LD_INT 9
77942: PUSH
77943: LD_INT 10
77945: PUSH
77946: LD_INT 6
77948: PUSH
77949: LD_INT 7
77951: PUSH
77952: LD_INT 11
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 27
77966: PUSH
77967: LD_INT 28
77969: PUSH
77970: LD_INT 26
77972: PUSH
77973: LD_INT 30
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: PUSH
77982: LD_INT 43
77984: PUSH
77985: LD_INT 44
77987: PUSH
77988: LD_INT 46
77990: PUSH
77991: LD_INT 45
77993: PUSH
77994: LD_INT 47
77996: PUSH
77997: LD_INT 49
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: PUSH
78008: EMPTY
78009: LIST
78010: LIST
78011: LIST
78012: PUSH
78013: LD_VAR 0 12
78017: ARRAY
78018: ST_TO_ADDR
// list := list isect fac_list ;
78019: LD_ADDR_VAR 0 5
78023: PUSH
78024: LD_VAR 0 5
78028: PUSH
78029: LD_VAR 0 17
78033: ISECT
78034: ST_TO_ADDR
// if not list then
78035: LD_VAR 0 5
78039: NOT
78040: IFFALSE 78044
// exit ;
78042: GO 78848
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
78044: LD_VAR 0 12
78048: PUSH
78049: LD_INT 3
78051: EQUAL
78052: PUSH
78053: LD_INT 49
78055: PUSH
78056: LD_VAR 0 5
78060: IN
78061: AND
78062: PUSH
78063: LD_INT 31
78065: PPUSH
78066: LD_VAR 0 16
78070: PPUSH
78071: CALL_OW 321
78075: PUSH
78076: LD_INT 2
78078: EQUAL
78079: AND
78080: IFFALSE 78140
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
78082: LD_INT 22
78084: PUSH
78085: LD_VAR 0 16
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 35
78096: PUSH
78097: LD_INT 49
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 91
78106: PUSH
78107: LD_VAR 0 1
78111: PUSH
78112: LD_INT 10
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: LIST
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: LIST
78124: PPUSH
78125: CALL_OW 69
78129: NOT
78130: IFFALSE 78140
// weapon := ru_time_lapser ;
78132: LD_ADDR_VAR 0 18
78136: PUSH
78137: LD_INT 49
78139: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
78140: LD_VAR 0 12
78144: PUSH
78145: LD_INT 1
78147: PUSH
78148: LD_INT 2
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: IN
78155: PUSH
78156: LD_INT 11
78158: PUSH
78159: LD_VAR 0 5
78163: IN
78164: PUSH
78165: LD_INT 30
78167: PUSH
78168: LD_VAR 0 5
78172: IN
78173: OR
78174: AND
78175: PUSH
78176: LD_INT 6
78178: PPUSH
78179: LD_VAR 0 16
78183: PPUSH
78184: CALL_OW 321
78188: PUSH
78189: LD_INT 2
78191: EQUAL
78192: AND
78193: IFFALSE 78358
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
78195: LD_INT 22
78197: PUSH
78198: LD_VAR 0 16
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: PUSH
78207: LD_INT 2
78209: PUSH
78210: LD_INT 35
78212: PUSH
78213: LD_INT 11
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: LD_INT 35
78222: PUSH
78223: LD_INT 30
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 91
78237: PUSH
78238: LD_VAR 0 1
78242: PUSH
78243: LD_INT 18
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: LIST
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: LIST
78255: PPUSH
78256: CALL_OW 69
78260: NOT
78261: PUSH
78262: LD_INT 22
78264: PUSH
78265: LD_VAR 0 16
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 2
78276: PUSH
78277: LD_INT 30
78279: PUSH
78280: LD_INT 32
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PUSH
78287: LD_INT 30
78289: PUSH
78290: LD_INT 33
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 91
78304: PUSH
78305: LD_VAR 0 1
78309: PUSH
78310: LD_INT 12
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: LIST
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: LIST
78322: PUSH
78323: EMPTY
78324: LIST
78325: PPUSH
78326: CALL_OW 69
78330: PUSH
78331: LD_INT 2
78333: GREATER
78334: AND
78335: IFFALSE 78358
// weapon := [ us_radar , ar_radar ] [ nat ] ;
78337: LD_ADDR_VAR 0 18
78341: PUSH
78342: LD_INT 11
78344: PUSH
78345: LD_INT 30
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_VAR 0 12
78356: ARRAY
78357: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78358: LD_VAR 0 18
78362: NOT
78363: PUSH
78364: LD_INT 40
78366: PPUSH
78367: LD_VAR 0 16
78371: PPUSH
78372: CALL_OW 321
78376: PUSH
78377: LD_INT 2
78379: EQUAL
78380: AND
78381: PUSH
78382: LD_INT 7
78384: PUSH
78385: LD_VAR 0 5
78389: IN
78390: PUSH
78391: LD_INT 28
78393: PUSH
78394: LD_VAR 0 5
78398: IN
78399: OR
78400: PUSH
78401: LD_INT 45
78403: PUSH
78404: LD_VAR 0 5
78408: IN
78409: OR
78410: AND
78411: IFFALSE 78665
// begin hex := GetHexInfo ( x , y ) ;
78413: LD_ADDR_VAR 0 4
78417: PUSH
78418: LD_VAR 0 10
78422: PPUSH
78423: LD_VAR 0 11
78427: PPUSH
78428: CALL_OW 546
78432: ST_TO_ADDR
// if hex [ 1 ] then
78433: LD_VAR 0 4
78437: PUSH
78438: LD_INT 1
78440: ARRAY
78441: IFFALSE 78445
// exit ;
78443: GO 78848
// height := hex [ 2 ] ;
78445: LD_ADDR_VAR 0 15
78449: PUSH
78450: LD_VAR 0 4
78454: PUSH
78455: LD_INT 2
78457: ARRAY
78458: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78459: LD_ADDR_VAR 0 14
78463: PUSH
78464: LD_INT 0
78466: PUSH
78467: LD_INT 2
78469: PUSH
78470: LD_INT 3
78472: PUSH
78473: LD_INT 5
78475: PUSH
78476: EMPTY
78477: LIST
78478: LIST
78479: LIST
78480: LIST
78481: ST_TO_ADDR
// for i in tmp do
78482: LD_ADDR_VAR 0 8
78486: PUSH
78487: LD_VAR 0 14
78491: PUSH
78492: FOR_IN
78493: IFFALSE 78663
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78495: LD_ADDR_VAR 0 9
78499: PUSH
78500: LD_VAR 0 10
78504: PPUSH
78505: LD_VAR 0 8
78509: PPUSH
78510: LD_INT 5
78512: PPUSH
78513: CALL_OW 272
78517: PUSH
78518: LD_VAR 0 11
78522: PPUSH
78523: LD_VAR 0 8
78527: PPUSH
78528: LD_INT 5
78530: PPUSH
78531: CALL_OW 273
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78540: LD_VAR 0 9
78544: PUSH
78545: LD_INT 1
78547: ARRAY
78548: PPUSH
78549: LD_VAR 0 9
78553: PUSH
78554: LD_INT 2
78556: ARRAY
78557: PPUSH
78558: CALL_OW 488
78562: IFFALSE 78661
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78564: LD_ADDR_VAR 0 4
78568: PUSH
78569: LD_VAR 0 9
78573: PUSH
78574: LD_INT 1
78576: ARRAY
78577: PPUSH
78578: LD_VAR 0 9
78582: PUSH
78583: LD_INT 2
78585: ARRAY
78586: PPUSH
78587: CALL_OW 546
78591: ST_TO_ADDR
// if hex [ 1 ] then
78592: LD_VAR 0 4
78596: PUSH
78597: LD_INT 1
78599: ARRAY
78600: IFFALSE 78604
// continue ;
78602: GO 78492
// h := hex [ 2 ] ;
78604: LD_ADDR_VAR 0 13
78608: PUSH
78609: LD_VAR 0 4
78613: PUSH
78614: LD_INT 2
78616: ARRAY
78617: ST_TO_ADDR
// if h + 7 < height then
78618: LD_VAR 0 13
78622: PUSH
78623: LD_INT 7
78625: PLUS
78626: PUSH
78627: LD_VAR 0 15
78631: LESS
78632: IFFALSE 78661
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78634: LD_ADDR_VAR 0 18
78638: PUSH
78639: LD_INT 7
78641: PUSH
78642: LD_INT 28
78644: PUSH
78645: LD_INT 45
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: LIST
78652: PUSH
78653: LD_VAR 0 12
78657: ARRAY
78658: ST_TO_ADDR
// break ;
78659: GO 78663
// end ; end ; end ;
78661: GO 78492
78663: POP
78664: POP
// end ; if not weapon then
78665: LD_VAR 0 18
78669: NOT
78670: IFFALSE 78730
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78672: LD_ADDR_VAR 0 5
78676: PUSH
78677: LD_VAR 0 5
78681: PUSH
78682: LD_INT 11
78684: PUSH
78685: LD_INT 30
78687: PUSH
78688: LD_INT 49
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: LIST
78695: DIFF
78696: ST_TO_ADDR
// if not list then
78697: LD_VAR 0 5
78701: NOT
78702: IFFALSE 78706
// exit ;
78704: GO 78848
// weapon := list [ rand ( 1 , list ) ] ;
78706: LD_ADDR_VAR 0 18
78710: PUSH
78711: LD_VAR 0 5
78715: PUSH
78716: LD_INT 1
78718: PPUSH
78719: LD_VAR 0 5
78723: PPUSH
78724: CALL_OW 12
78728: ARRAY
78729: ST_TO_ADDR
// end ; if weapon then
78730: LD_VAR 0 18
78734: IFFALSE 78848
// begin tmp := CostOfWeapon ( weapon ) ;
78736: LD_ADDR_VAR 0 14
78740: PUSH
78741: LD_VAR 0 18
78745: PPUSH
78746: CALL_OW 451
78750: ST_TO_ADDR
// j := GetBase ( tower ) ;
78751: LD_ADDR_VAR 0 9
78755: PUSH
78756: LD_VAR 0 1
78760: PPUSH
78761: CALL_OW 274
78765: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78766: LD_VAR 0 9
78770: PPUSH
78771: LD_INT 1
78773: PPUSH
78774: CALL_OW 275
78778: PUSH
78779: LD_VAR 0 14
78783: PUSH
78784: LD_INT 1
78786: ARRAY
78787: GREATEREQUAL
78788: PUSH
78789: LD_VAR 0 9
78793: PPUSH
78794: LD_INT 2
78796: PPUSH
78797: CALL_OW 275
78801: PUSH
78802: LD_VAR 0 14
78806: PUSH
78807: LD_INT 2
78809: ARRAY
78810: GREATEREQUAL
78811: AND
78812: PUSH
78813: LD_VAR 0 9
78817: PPUSH
78818: LD_INT 3
78820: PPUSH
78821: CALL_OW 275
78825: PUSH
78826: LD_VAR 0 14
78830: PUSH
78831: LD_INT 3
78833: ARRAY
78834: GREATEREQUAL
78835: AND
78836: IFFALSE 78848
// result := weapon ;
78838: LD_ADDR_VAR 0 3
78842: PUSH
78843: LD_VAR 0 18
78847: ST_TO_ADDR
// end ; end ;
78848: LD_VAR 0 3
78852: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78853: LD_INT 0
78855: PPUSH
78856: PPUSH
// result := true ;
78857: LD_ADDR_VAR 0 3
78861: PUSH
78862: LD_INT 1
78864: ST_TO_ADDR
// if array1 = array2 then
78865: LD_VAR 0 1
78869: PUSH
78870: LD_VAR 0 2
78874: EQUAL
78875: IFFALSE 78935
// begin for i = 1 to array1 do
78877: LD_ADDR_VAR 0 4
78881: PUSH
78882: DOUBLE
78883: LD_INT 1
78885: DEC
78886: ST_TO_ADDR
78887: LD_VAR 0 1
78891: PUSH
78892: FOR_TO
78893: IFFALSE 78931
// if array1 [ i ] <> array2 [ i ] then
78895: LD_VAR 0 1
78899: PUSH
78900: LD_VAR 0 4
78904: ARRAY
78905: PUSH
78906: LD_VAR 0 2
78910: PUSH
78911: LD_VAR 0 4
78915: ARRAY
78916: NONEQUAL
78917: IFFALSE 78929
// begin result := false ;
78919: LD_ADDR_VAR 0 3
78923: PUSH
78924: LD_INT 0
78926: ST_TO_ADDR
// break ;
78927: GO 78931
// end ;
78929: GO 78892
78931: POP
78932: POP
// end else
78933: GO 78943
// result := false ;
78935: LD_ADDR_VAR 0 3
78939: PUSH
78940: LD_INT 0
78942: ST_TO_ADDR
// end ;
78943: LD_VAR 0 3
78947: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
78948: LD_INT 0
78950: PPUSH
78951: PPUSH
// if not array1 or not array2 then
78952: LD_VAR 0 1
78956: NOT
78957: PUSH
78958: LD_VAR 0 2
78962: NOT
78963: OR
78964: IFFALSE 78968
// exit ;
78966: GO 79032
// result := true ;
78968: LD_ADDR_VAR 0 3
78972: PUSH
78973: LD_INT 1
78975: ST_TO_ADDR
// for i = 1 to array1 do
78976: LD_ADDR_VAR 0 4
78980: PUSH
78981: DOUBLE
78982: LD_INT 1
78984: DEC
78985: ST_TO_ADDR
78986: LD_VAR 0 1
78990: PUSH
78991: FOR_TO
78992: IFFALSE 79030
// if array1 [ i ] <> array2 [ i ] then
78994: LD_VAR 0 1
78998: PUSH
78999: LD_VAR 0 4
79003: ARRAY
79004: PUSH
79005: LD_VAR 0 2
79009: PUSH
79010: LD_VAR 0 4
79014: ARRAY
79015: NONEQUAL
79016: IFFALSE 79028
// begin result := false ;
79018: LD_ADDR_VAR 0 3
79022: PUSH
79023: LD_INT 0
79025: ST_TO_ADDR
// break ;
79026: GO 79030
// end ;
79028: GO 78991
79030: POP
79031: POP
// end ;
79032: LD_VAR 0 3
79036: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
79037: LD_INT 0
79039: PPUSH
79040: PPUSH
79041: PPUSH
// pom := GetBase ( fac ) ;
79042: LD_ADDR_VAR 0 5
79046: PUSH
79047: LD_VAR 0 1
79051: PPUSH
79052: CALL_OW 274
79056: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
79057: LD_ADDR_VAR 0 4
79061: PUSH
79062: LD_VAR 0 2
79066: PUSH
79067: LD_INT 1
79069: ARRAY
79070: PPUSH
79071: LD_VAR 0 2
79075: PUSH
79076: LD_INT 2
79078: ARRAY
79079: PPUSH
79080: LD_VAR 0 2
79084: PUSH
79085: LD_INT 3
79087: ARRAY
79088: PPUSH
79089: LD_VAR 0 2
79093: PUSH
79094: LD_INT 4
79096: ARRAY
79097: PPUSH
79098: CALL_OW 449
79102: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79103: LD_ADDR_VAR 0 3
79107: PUSH
79108: LD_VAR 0 5
79112: PPUSH
79113: LD_INT 1
79115: PPUSH
79116: CALL_OW 275
79120: PUSH
79121: LD_VAR 0 4
79125: PUSH
79126: LD_INT 1
79128: ARRAY
79129: GREATEREQUAL
79130: PUSH
79131: LD_VAR 0 5
79135: PPUSH
79136: LD_INT 2
79138: PPUSH
79139: CALL_OW 275
79143: PUSH
79144: LD_VAR 0 4
79148: PUSH
79149: LD_INT 2
79151: ARRAY
79152: GREATEREQUAL
79153: AND
79154: PUSH
79155: LD_VAR 0 5
79159: PPUSH
79160: LD_INT 3
79162: PPUSH
79163: CALL_OW 275
79167: PUSH
79168: LD_VAR 0 4
79172: PUSH
79173: LD_INT 3
79175: ARRAY
79176: GREATEREQUAL
79177: AND
79178: ST_TO_ADDR
// end ;
79179: LD_VAR 0 3
79183: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
79184: LD_INT 0
79186: PPUSH
79187: PPUSH
79188: PPUSH
79189: PPUSH
// pom := GetBase ( building ) ;
79190: LD_ADDR_VAR 0 3
79194: PUSH
79195: LD_VAR 0 1
79199: PPUSH
79200: CALL_OW 274
79204: ST_TO_ADDR
// if not pom then
79205: LD_VAR 0 3
79209: NOT
79210: IFFALSE 79214
// exit ;
79212: GO 79384
// btype := GetBType ( building ) ;
79214: LD_ADDR_VAR 0 5
79218: PUSH
79219: LD_VAR 0 1
79223: PPUSH
79224: CALL_OW 266
79228: ST_TO_ADDR
// if btype = b_armoury then
79229: LD_VAR 0 5
79233: PUSH
79234: LD_INT 4
79236: EQUAL
79237: IFFALSE 79247
// btype := b_barracks ;
79239: LD_ADDR_VAR 0 5
79243: PUSH
79244: LD_INT 5
79246: ST_TO_ADDR
// if btype = b_depot then
79247: LD_VAR 0 5
79251: PUSH
79252: LD_INT 0
79254: EQUAL
79255: IFFALSE 79265
// btype := b_warehouse ;
79257: LD_ADDR_VAR 0 5
79261: PUSH
79262: LD_INT 1
79264: ST_TO_ADDR
// if btype = b_workshop then
79265: LD_VAR 0 5
79269: PUSH
79270: LD_INT 2
79272: EQUAL
79273: IFFALSE 79283
// btype := b_factory ;
79275: LD_ADDR_VAR 0 5
79279: PUSH
79280: LD_INT 3
79282: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79283: LD_ADDR_VAR 0 4
79287: PUSH
79288: LD_VAR 0 5
79292: PPUSH
79293: LD_VAR 0 1
79297: PPUSH
79298: CALL_OW 248
79302: PPUSH
79303: CALL_OW 450
79307: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79308: LD_ADDR_VAR 0 2
79312: PUSH
79313: LD_VAR 0 3
79317: PPUSH
79318: LD_INT 1
79320: PPUSH
79321: CALL_OW 275
79325: PUSH
79326: LD_VAR 0 4
79330: PUSH
79331: LD_INT 1
79333: ARRAY
79334: GREATEREQUAL
79335: PUSH
79336: LD_VAR 0 3
79340: PPUSH
79341: LD_INT 2
79343: PPUSH
79344: CALL_OW 275
79348: PUSH
79349: LD_VAR 0 4
79353: PUSH
79354: LD_INT 2
79356: ARRAY
79357: GREATEREQUAL
79358: AND
79359: PUSH
79360: LD_VAR 0 3
79364: PPUSH
79365: LD_INT 3
79367: PPUSH
79368: CALL_OW 275
79372: PUSH
79373: LD_VAR 0 4
79377: PUSH
79378: LD_INT 3
79380: ARRAY
79381: GREATEREQUAL
79382: AND
79383: ST_TO_ADDR
// end ;
79384: LD_VAR 0 2
79388: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79389: LD_INT 0
79391: PPUSH
79392: PPUSH
79393: PPUSH
// pom := GetBase ( building ) ;
79394: LD_ADDR_VAR 0 4
79398: PUSH
79399: LD_VAR 0 1
79403: PPUSH
79404: CALL_OW 274
79408: ST_TO_ADDR
// if not pom then
79409: LD_VAR 0 4
79413: NOT
79414: IFFALSE 79418
// exit ;
79416: GO 79519
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79418: LD_ADDR_VAR 0 5
79422: PUSH
79423: LD_VAR 0 2
79427: PPUSH
79428: LD_VAR 0 1
79432: PPUSH
79433: CALL_OW 248
79437: PPUSH
79438: CALL_OW 450
79442: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79443: LD_ADDR_VAR 0 3
79447: PUSH
79448: LD_VAR 0 4
79452: PPUSH
79453: LD_INT 1
79455: PPUSH
79456: CALL_OW 275
79460: PUSH
79461: LD_VAR 0 5
79465: PUSH
79466: LD_INT 1
79468: ARRAY
79469: GREATEREQUAL
79470: PUSH
79471: LD_VAR 0 4
79475: PPUSH
79476: LD_INT 2
79478: PPUSH
79479: CALL_OW 275
79483: PUSH
79484: LD_VAR 0 5
79488: PUSH
79489: LD_INT 2
79491: ARRAY
79492: GREATEREQUAL
79493: AND
79494: PUSH
79495: LD_VAR 0 4
79499: PPUSH
79500: LD_INT 3
79502: PPUSH
79503: CALL_OW 275
79507: PUSH
79508: LD_VAR 0 5
79512: PUSH
79513: LD_INT 3
79515: ARRAY
79516: GREATEREQUAL
79517: AND
79518: ST_TO_ADDR
// end ;
79519: LD_VAR 0 3
79523: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79524: LD_INT 0
79526: PPUSH
79527: PPUSH
79528: PPUSH
79529: PPUSH
79530: PPUSH
79531: PPUSH
79532: PPUSH
79533: PPUSH
79534: PPUSH
79535: PPUSH
79536: PPUSH
// result := false ;
79537: LD_ADDR_VAR 0 8
79541: PUSH
79542: LD_INT 0
79544: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79545: LD_VAR 0 5
79549: NOT
79550: PUSH
79551: LD_VAR 0 1
79555: NOT
79556: OR
79557: PUSH
79558: LD_VAR 0 2
79562: NOT
79563: OR
79564: PUSH
79565: LD_VAR 0 3
79569: NOT
79570: OR
79571: IFFALSE 79575
// exit ;
79573: GO 80389
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79575: LD_ADDR_VAR 0 14
79579: PUSH
79580: LD_VAR 0 1
79584: PPUSH
79585: LD_VAR 0 2
79589: PPUSH
79590: LD_VAR 0 3
79594: PPUSH
79595: LD_VAR 0 4
79599: PPUSH
79600: LD_VAR 0 5
79604: PUSH
79605: LD_INT 1
79607: ARRAY
79608: PPUSH
79609: CALL_OW 248
79613: PPUSH
79614: LD_INT 0
79616: PPUSH
79617: CALL 81622 0 6
79621: ST_TO_ADDR
// if not hexes then
79622: LD_VAR 0 14
79626: NOT
79627: IFFALSE 79631
// exit ;
79629: GO 80389
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79631: LD_ADDR_VAR 0 17
79635: PUSH
79636: LD_VAR 0 5
79640: PPUSH
79641: LD_INT 22
79643: PUSH
79644: LD_VAR 0 13
79648: PPUSH
79649: CALL_OW 255
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 2
79660: PUSH
79661: LD_INT 30
79663: PUSH
79664: LD_INT 0
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 30
79673: PUSH
79674: LD_INT 1
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: LIST
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PPUSH
79690: CALL_OW 72
79694: ST_TO_ADDR
// for i = 1 to hexes do
79695: LD_ADDR_VAR 0 9
79699: PUSH
79700: DOUBLE
79701: LD_INT 1
79703: DEC
79704: ST_TO_ADDR
79705: LD_VAR 0 14
79709: PUSH
79710: FOR_TO
79711: IFFALSE 80387
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79713: LD_ADDR_VAR 0 13
79717: PUSH
79718: LD_VAR 0 14
79722: PUSH
79723: LD_VAR 0 9
79727: ARRAY
79728: PUSH
79729: LD_INT 1
79731: ARRAY
79732: PPUSH
79733: LD_VAR 0 14
79737: PUSH
79738: LD_VAR 0 9
79742: ARRAY
79743: PUSH
79744: LD_INT 2
79746: ARRAY
79747: PPUSH
79748: CALL_OW 428
79752: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79753: LD_VAR 0 14
79757: PUSH
79758: LD_VAR 0 9
79762: ARRAY
79763: PUSH
79764: LD_INT 1
79766: ARRAY
79767: PPUSH
79768: LD_VAR 0 14
79772: PUSH
79773: LD_VAR 0 9
79777: ARRAY
79778: PUSH
79779: LD_INT 2
79781: ARRAY
79782: PPUSH
79783: CALL_OW 351
79787: PUSH
79788: LD_VAR 0 14
79792: PUSH
79793: LD_VAR 0 9
79797: ARRAY
79798: PUSH
79799: LD_INT 1
79801: ARRAY
79802: PPUSH
79803: LD_VAR 0 14
79807: PUSH
79808: LD_VAR 0 9
79812: ARRAY
79813: PUSH
79814: LD_INT 2
79816: ARRAY
79817: PPUSH
79818: CALL_OW 488
79822: NOT
79823: OR
79824: PUSH
79825: LD_VAR 0 13
79829: PPUSH
79830: CALL_OW 247
79834: PUSH
79835: LD_INT 3
79837: EQUAL
79838: OR
79839: IFFALSE 79845
// exit ;
79841: POP
79842: POP
79843: GO 80389
// if not tmp then
79845: LD_VAR 0 13
79849: NOT
79850: IFFALSE 79854
// continue ;
79852: GO 79710
// result := true ;
79854: LD_ADDR_VAR 0 8
79858: PUSH
79859: LD_INT 1
79861: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
79862: LD_VAR 0 6
79866: PUSH
79867: LD_VAR 0 13
79871: PPUSH
79872: CALL_OW 247
79876: PUSH
79877: LD_INT 2
79879: EQUAL
79880: AND
79881: PUSH
79882: LD_VAR 0 13
79886: PPUSH
79887: CALL_OW 263
79891: PUSH
79892: LD_INT 1
79894: EQUAL
79895: AND
79896: IFFALSE 80060
// begin if IsDrivenBy ( tmp ) then
79898: LD_VAR 0 13
79902: PPUSH
79903: CALL_OW 311
79907: IFFALSE 79911
// continue ;
79909: GO 79710
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
79911: LD_VAR 0 6
79915: PPUSH
79916: LD_INT 3
79918: PUSH
79919: LD_INT 60
79921: PUSH
79922: EMPTY
79923: LIST
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 3
79931: PUSH
79932: LD_INT 55
79934: PUSH
79935: EMPTY
79936: LIST
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PPUSH
79946: CALL_OW 72
79950: IFFALSE 80058
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
79952: LD_ADDR_VAR 0 18
79956: PUSH
79957: LD_VAR 0 6
79961: PPUSH
79962: LD_INT 3
79964: PUSH
79965: LD_INT 60
79967: PUSH
79968: EMPTY
79969: LIST
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 3
79977: PUSH
79978: LD_INT 55
79980: PUSH
79981: EMPTY
79982: LIST
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PPUSH
79992: CALL_OW 72
79996: PUSH
79997: LD_INT 1
79999: ARRAY
80000: ST_TO_ADDR
// if IsInUnit ( driver ) then
80001: LD_VAR 0 18
80005: PPUSH
80006: CALL_OW 310
80010: IFFALSE 80021
// ComExit ( driver ) ;
80012: LD_VAR 0 18
80016: PPUSH
80017: CALL 105402 0 1
// AddComEnterUnit ( driver , tmp ) ;
80021: LD_VAR 0 18
80025: PPUSH
80026: LD_VAR 0 13
80030: PPUSH
80031: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
80035: LD_VAR 0 18
80039: PPUSH
80040: LD_VAR 0 7
80044: PPUSH
80045: CALL_OW 173
// AddComExitVehicle ( driver ) ;
80049: LD_VAR 0 18
80053: PPUSH
80054: CALL_OW 181
// end ; continue ;
80058: GO 79710
// end ; if not cleaners or not tmp in cleaners then
80060: LD_VAR 0 6
80064: NOT
80065: PUSH
80066: LD_VAR 0 13
80070: PUSH
80071: LD_VAR 0 6
80075: IN
80076: NOT
80077: OR
80078: IFFALSE 80385
// begin if dep then
80080: LD_VAR 0 17
80084: IFFALSE 80220
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
80086: LD_ADDR_VAR 0 16
80090: PUSH
80091: LD_VAR 0 17
80095: PUSH
80096: LD_INT 1
80098: ARRAY
80099: PPUSH
80100: CALL_OW 250
80104: PPUSH
80105: LD_VAR 0 17
80109: PUSH
80110: LD_INT 1
80112: ARRAY
80113: PPUSH
80114: CALL_OW 254
80118: PPUSH
80119: LD_INT 5
80121: PPUSH
80122: CALL_OW 272
80126: PUSH
80127: LD_VAR 0 17
80131: PUSH
80132: LD_INT 1
80134: ARRAY
80135: PPUSH
80136: CALL_OW 251
80140: PPUSH
80141: LD_VAR 0 17
80145: PUSH
80146: LD_INT 1
80148: ARRAY
80149: PPUSH
80150: CALL_OW 254
80154: PPUSH
80155: LD_INT 5
80157: PPUSH
80158: CALL_OW 273
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
80167: LD_VAR 0 16
80171: PUSH
80172: LD_INT 1
80174: ARRAY
80175: PPUSH
80176: LD_VAR 0 16
80180: PUSH
80181: LD_INT 2
80183: ARRAY
80184: PPUSH
80185: CALL_OW 488
80189: IFFALSE 80220
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
80191: LD_VAR 0 13
80195: PPUSH
80196: LD_VAR 0 16
80200: PUSH
80201: LD_INT 1
80203: ARRAY
80204: PPUSH
80205: LD_VAR 0 16
80209: PUSH
80210: LD_INT 2
80212: ARRAY
80213: PPUSH
80214: CALL_OW 111
// continue ;
80218: GO 79710
// end ; end ; r := GetDir ( tmp ) ;
80220: LD_ADDR_VAR 0 15
80224: PUSH
80225: LD_VAR 0 13
80229: PPUSH
80230: CALL_OW 254
80234: ST_TO_ADDR
// if r = 5 then
80235: LD_VAR 0 15
80239: PUSH
80240: LD_INT 5
80242: EQUAL
80243: IFFALSE 80253
// r := 0 ;
80245: LD_ADDR_VAR 0 15
80249: PUSH
80250: LD_INT 0
80252: ST_TO_ADDR
// for j = r to 5 do
80253: LD_ADDR_VAR 0 10
80257: PUSH
80258: DOUBLE
80259: LD_VAR 0 15
80263: DEC
80264: ST_TO_ADDR
80265: LD_INT 5
80267: PUSH
80268: FOR_TO
80269: IFFALSE 80383
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
80271: LD_ADDR_VAR 0 11
80275: PUSH
80276: LD_VAR 0 13
80280: PPUSH
80281: CALL_OW 250
80285: PPUSH
80286: LD_VAR 0 10
80290: PPUSH
80291: LD_INT 2
80293: PPUSH
80294: CALL_OW 272
80298: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
80299: LD_ADDR_VAR 0 12
80303: PUSH
80304: LD_VAR 0 13
80308: PPUSH
80309: CALL_OW 251
80313: PPUSH
80314: LD_VAR 0 10
80318: PPUSH
80319: LD_INT 2
80321: PPUSH
80322: CALL_OW 273
80326: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
80327: LD_VAR 0 11
80331: PPUSH
80332: LD_VAR 0 12
80336: PPUSH
80337: CALL_OW 488
80341: PUSH
80342: LD_VAR 0 11
80346: PPUSH
80347: LD_VAR 0 12
80351: PPUSH
80352: CALL_OW 428
80356: NOT
80357: AND
80358: IFFALSE 80381
// begin ComMoveXY ( tmp , _x , _y ) ;
80360: LD_VAR 0 13
80364: PPUSH
80365: LD_VAR 0 11
80369: PPUSH
80370: LD_VAR 0 12
80374: PPUSH
80375: CALL_OW 111
// break ;
80379: GO 80383
// end ; end ;
80381: GO 80268
80383: POP
80384: POP
// end ; end ;
80385: GO 79710
80387: POP
80388: POP
// end ;
80389: LD_VAR 0 8
80393: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80394: LD_INT 0
80396: PPUSH
// result := true ;
80397: LD_ADDR_VAR 0 3
80401: PUSH
80402: LD_INT 1
80404: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80405: LD_VAR 0 2
80409: PUSH
80410: LD_INT 24
80412: DOUBLE
80413: EQUAL
80414: IFTRUE 80424
80416: LD_INT 33
80418: DOUBLE
80419: EQUAL
80420: IFTRUE 80424
80422: GO 80449
80424: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80425: LD_ADDR_VAR 0 3
80429: PUSH
80430: LD_INT 32
80432: PPUSH
80433: LD_VAR 0 1
80437: PPUSH
80438: CALL_OW 321
80442: PUSH
80443: LD_INT 2
80445: EQUAL
80446: ST_TO_ADDR
80447: GO 80765
80449: LD_INT 20
80451: DOUBLE
80452: EQUAL
80453: IFTRUE 80457
80455: GO 80482
80457: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80458: LD_ADDR_VAR 0 3
80462: PUSH
80463: LD_INT 6
80465: PPUSH
80466: LD_VAR 0 1
80470: PPUSH
80471: CALL_OW 321
80475: PUSH
80476: LD_INT 2
80478: EQUAL
80479: ST_TO_ADDR
80480: GO 80765
80482: LD_INT 22
80484: DOUBLE
80485: EQUAL
80486: IFTRUE 80496
80488: LD_INT 36
80490: DOUBLE
80491: EQUAL
80492: IFTRUE 80496
80494: GO 80521
80496: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80497: LD_ADDR_VAR 0 3
80501: PUSH
80502: LD_INT 15
80504: PPUSH
80505: LD_VAR 0 1
80509: PPUSH
80510: CALL_OW 321
80514: PUSH
80515: LD_INT 2
80517: EQUAL
80518: ST_TO_ADDR
80519: GO 80765
80521: LD_INT 30
80523: DOUBLE
80524: EQUAL
80525: IFTRUE 80529
80527: GO 80554
80529: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80530: LD_ADDR_VAR 0 3
80534: PUSH
80535: LD_INT 20
80537: PPUSH
80538: LD_VAR 0 1
80542: PPUSH
80543: CALL_OW 321
80547: PUSH
80548: LD_INT 2
80550: EQUAL
80551: ST_TO_ADDR
80552: GO 80765
80554: LD_INT 28
80556: DOUBLE
80557: EQUAL
80558: IFTRUE 80568
80560: LD_INT 21
80562: DOUBLE
80563: EQUAL
80564: IFTRUE 80568
80566: GO 80593
80568: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80569: LD_ADDR_VAR 0 3
80573: PUSH
80574: LD_INT 21
80576: PPUSH
80577: LD_VAR 0 1
80581: PPUSH
80582: CALL_OW 321
80586: PUSH
80587: LD_INT 2
80589: EQUAL
80590: ST_TO_ADDR
80591: GO 80765
80593: LD_INT 16
80595: DOUBLE
80596: EQUAL
80597: IFTRUE 80601
80599: GO 80626
80601: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80602: LD_ADDR_VAR 0 3
80606: PUSH
80607: LD_INT 84
80609: PPUSH
80610: LD_VAR 0 1
80614: PPUSH
80615: CALL_OW 321
80619: PUSH
80620: LD_INT 2
80622: EQUAL
80623: ST_TO_ADDR
80624: GO 80765
80626: LD_INT 19
80628: DOUBLE
80629: EQUAL
80630: IFTRUE 80640
80632: LD_INT 23
80634: DOUBLE
80635: EQUAL
80636: IFTRUE 80640
80638: GO 80665
80640: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80641: LD_ADDR_VAR 0 3
80645: PUSH
80646: LD_INT 83
80648: PPUSH
80649: LD_VAR 0 1
80653: PPUSH
80654: CALL_OW 321
80658: PUSH
80659: LD_INT 2
80661: EQUAL
80662: ST_TO_ADDR
80663: GO 80765
80665: LD_INT 17
80667: DOUBLE
80668: EQUAL
80669: IFTRUE 80673
80671: GO 80698
80673: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80674: LD_ADDR_VAR 0 3
80678: PUSH
80679: LD_INT 39
80681: PPUSH
80682: LD_VAR 0 1
80686: PPUSH
80687: CALL_OW 321
80691: PUSH
80692: LD_INT 2
80694: EQUAL
80695: ST_TO_ADDR
80696: GO 80765
80698: LD_INT 18
80700: DOUBLE
80701: EQUAL
80702: IFTRUE 80706
80704: GO 80731
80706: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80707: LD_ADDR_VAR 0 3
80711: PUSH
80712: LD_INT 40
80714: PPUSH
80715: LD_VAR 0 1
80719: PPUSH
80720: CALL_OW 321
80724: PUSH
80725: LD_INT 2
80727: EQUAL
80728: ST_TO_ADDR
80729: GO 80765
80731: LD_INT 27
80733: DOUBLE
80734: EQUAL
80735: IFTRUE 80739
80737: GO 80764
80739: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
80740: LD_ADDR_VAR 0 3
80744: PUSH
80745: LD_INT 35
80747: PPUSH
80748: LD_VAR 0 1
80752: PPUSH
80753: CALL_OW 321
80757: PUSH
80758: LD_INT 2
80760: EQUAL
80761: ST_TO_ADDR
80762: GO 80765
80764: POP
// end ;
80765: LD_VAR 0 3
80769: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
80770: LD_INT 0
80772: PPUSH
80773: PPUSH
80774: PPUSH
80775: PPUSH
80776: PPUSH
80777: PPUSH
80778: PPUSH
80779: PPUSH
80780: PPUSH
80781: PPUSH
80782: PPUSH
// result := false ;
80783: LD_ADDR_VAR 0 6
80787: PUSH
80788: LD_INT 0
80790: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
80791: LD_VAR 0 1
80795: NOT
80796: PUSH
80797: LD_VAR 0 1
80801: PPUSH
80802: CALL_OW 266
80806: PUSH
80807: LD_INT 0
80809: PUSH
80810: LD_INT 1
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: IN
80817: NOT
80818: OR
80819: PUSH
80820: LD_VAR 0 2
80824: NOT
80825: OR
80826: PUSH
80827: LD_VAR 0 5
80831: PUSH
80832: LD_INT 0
80834: PUSH
80835: LD_INT 1
80837: PUSH
80838: LD_INT 2
80840: PUSH
80841: LD_INT 3
80843: PUSH
80844: LD_INT 4
80846: PUSH
80847: LD_INT 5
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: IN
80858: NOT
80859: OR
80860: PUSH
80861: LD_VAR 0 3
80865: PPUSH
80866: LD_VAR 0 4
80870: PPUSH
80871: CALL_OW 488
80875: NOT
80876: OR
80877: IFFALSE 80881
// exit ;
80879: GO 81617
// side := GetSide ( depot ) ;
80881: LD_ADDR_VAR 0 9
80885: PUSH
80886: LD_VAR 0 1
80890: PPUSH
80891: CALL_OW 255
80895: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
80896: LD_VAR 0 9
80900: PPUSH
80901: LD_VAR 0 2
80905: PPUSH
80906: CALL 80394 0 2
80910: NOT
80911: IFFALSE 80915
// exit ;
80913: GO 81617
// pom := GetBase ( depot ) ;
80915: LD_ADDR_VAR 0 10
80919: PUSH
80920: LD_VAR 0 1
80924: PPUSH
80925: CALL_OW 274
80929: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
80930: LD_ADDR_VAR 0 11
80934: PUSH
80935: LD_VAR 0 2
80939: PPUSH
80940: LD_VAR 0 1
80944: PPUSH
80945: CALL_OW 248
80949: PPUSH
80950: CALL_OW 450
80954: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
80955: LD_VAR 0 10
80959: PPUSH
80960: LD_INT 1
80962: PPUSH
80963: CALL_OW 275
80967: PUSH
80968: LD_VAR 0 11
80972: PUSH
80973: LD_INT 1
80975: ARRAY
80976: GREATEREQUAL
80977: PUSH
80978: LD_VAR 0 10
80982: PPUSH
80983: LD_INT 2
80985: PPUSH
80986: CALL_OW 275
80990: PUSH
80991: LD_VAR 0 11
80995: PUSH
80996: LD_INT 2
80998: ARRAY
80999: GREATEREQUAL
81000: AND
81001: PUSH
81002: LD_VAR 0 10
81006: PPUSH
81007: LD_INT 3
81009: PPUSH
81010: CALL_OW 275
81014: PUSH
81015: LD_VAR 0 11
81019: PUSH
81020: LD_INT 3
81022: ARRAY
81023: GREATEREQUAL
81024: AND
81025: NOT
81026: IFFALSE 81030
// exit ;
81028: GO 81617
// if GetBType ( depot ) = b_depot then
81030: LD_VAR 0 1
81034: PPUSH
81035: CALL_OW 266
81039: PUSH
81040: LD_INT 0
81042: EQUAL
81043: IFFALSE 81055
// dist := 28 else
81045: LD_ADDR_VAR 0 14
81049: PUSH
81050: LD_INT 28
81052: ST_TO_ADDR
81053: GO 81063
// dist := 36 ;
81055: LD_ADDR_VAR 0 14
81059: PUSH
81060: LD_INT 36
81062: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
81063: LD_VAR 0 1
81067: PPUSH
81068: LD_VAR 0 3
81072: PPUSH
81073: LD_VAR 0 4
81077: PPUSH
81078: CALL_OW 297
81082: PUSH
81083: LD_VAR 0 14
81087: GREATER
81088: IFFALSE 81092
// exit ;
81090: GO 81617
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
81092: LD_ADDR_VAR 0 12
81096: PUSH
81097: LD_VAR 0 2
81101: PPUSH
81102: LD_VAR 0 3
81106: PPUSH
81107: LD_VAR 0 4
81111: PPUSH
81112: LD_VAR 0 5
81116: PPUSH
81117: LD_VAR 0 1
81121: PPUSH
81122: CALL_OW 248
81126: PPUSH
81127: LD_INT 0
81129: PPUSH
81130: CALL 81622 0 6
81134: ST_TO_ADDR
// if not hexes then
81135: LD_VAR 0 12
81139: NOT
81140: IFFALSE 81144
// exit ;
81142: GO 81617
// hex := GetHexInfo ( x , y ) ;
81144: LD_ADDR_VAR 0 15
81148: PUSH
81149: LD_VAR 0 3
81153: PPUSH
81154: LD_VAR 0 4
81158: PPUSH
81159: CALL_OW 546
81163: ST_TO_ADDR
// if hex [ 1 ] then
81164: LD_VAR 0 15
81168: PUSH
81169: LD_INT 1
81171: ARRAY
81172: IFFALSE 81176
// exit ;
81174: GO 81617
// height := hex [ 2 ] ;
81176: LD_ADDR_VAR 0 13
81180: PUSH
81181: LD_VAR 0 15
81185: PUSH
81186: LD_INT 2
81188: ARRAY
81189: ST_TO_ADDR
// for i = 1 to hexes do
81190: LD_ADDR_VAR 0 7
81194: PUSH
81195: DOUBLE
81196: LD_INT 1
81198: DEC
81199: ST_TO_ADDR
81200: LD_VAR 0 12
81204: PUSH
81205: FOR_TO
81206: IFFALSE 81536
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
81208: LD_VAR 0 12
81212: PUSH
81213: LD_VAR 0 7
81217: ARRAY
81218: PUSH
81219: LD_INT 1
81221: ARRAY
81222: PPUSH
81223: LD_VAR 0 12
81227: PUSH
81228: LD_VAR 0 7
81232: ARRAY
81233: PUSH
81234: LD_INT 2
81236: ARRAY
81237: PPUSH
81238: CALL_OW 488
81242: NOT
81243: PUSH
81244: LD_VAR 0 12
81248: PUSH
81249: LD_VAR 0 7
81253: ARRAY
81254: PUSH
81255: LD_INT 1
81257: ARRAY
81258: PPUSH
81259: LD_VAR 0 12
81263: PUSH
81264: LD_VAR 0 7
81268: ARRAY
81269: PUSH
81270: LD_INT 2
81272: ARRAY
81273: PPUSH
81274: CALL_OW 428
81278: PUSH
81279: LD_INT 0
81281: GREATER
81282: OR
81283: PUSH
81284: LD_VAR 0 12
81288: PUSH
81289: LD_VAR 0 7
81293: ARRAY
81294: PUSH
81295: LD_INT 1
81297: ARRAY
81298: PPUSH
81299: LD_VAR 0 12
81303: PUSH
81304: LD_VAR 0 7
81308: ARRAY
81309: PUSH
81310: LD_INT 2
81312: ARRAY
81313: PPUSH
81314: CALL_OW 351
81318: OR
81319: IFFALSE 81325
// exit ;
81321: POP
81322: POP
81323: GO 81617
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81325: LD_ADDR_VAR 0 8
81329: PUSH
81330: LD_VAR 0 12
81334: PUSH
81335: LD_VAR 0 7
81339: ARRAY
81340: PUSH
81341: LD_INT 1
81343: ARRAY
81344: PPUSH
81345: LD_VAR 0 12
81349: PUSH
81350: LD_VAR 0 7
81354: ARRAY
81355: PUSH
81356: LD_INT 2
81358: ARRAY
81359: PPUSH
81360: CALL_OW 546
81364: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81365: LD_VAR 0 8
81369: PUSH
81370: LD_INT 1
81372: ARRAY
81373: PUSH
81374: LD_VAR 0 8
81378: PUSH
81379: LD_INT 2
81381: ARRAY
81382: PUSH
81383: LD_VAR 0 13
81387: PUSH
81388: LD_INT 2
81390: PLUS
81391: GREATER
81392: OR
81393: PUSH
81394: LD_VAR 0 8
81398: PUSH
81399: LD_INT 2
81401: ARRAY
81402: PUSH
81403: LD_VAR 0 13
81407: PUSH
81408: LD_INT 2
81410: MINUS
81411: LESS
81412: OR
81413: PUSH
81414: LD_VAR 0 8
81418: PUSH
81419: LD_INT 3
81421: ARRAY
81422: PUSH
81423: LD_INT 0
81425: PUSH
81426: LD_INT 8
81428: PUSH
81429: LD_INT 9
81431: PUSH
81432: LD_INT 10
81434: PUSH
81435: LD_INT 11
81437: PUSH
81438: LD_INT 12
81440: PUSH
81441: LD_INT 13
81443: PUSH
81444: LD_INT 16
81446: PUSH
81447: LD_INT 17
81449: PUSH
81450: LD_INT 18
81452: PUSH
81453: LD_INT 19
81455: PUSH
81456: LD_INT 20
81458: PUSH
81459: LD_INT 21
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: IN
81477: NOT
81478: OR
81479: PUSH
81480: LD_VAR 0 8
81484: PUSH
81485: LD_INT 5
81487: ARRAY
81488: NOT
81489: OR
81490: PUSH
81491: LD_VAR 0 8
81495: PUSH
81496: LD_INT 6
81498: ARRAY
81499: PUSH
81500: LD_INT 1
81502: PUSH
81503: LD_INT 2
81505: PUSH
81506: LD_INT 7
81508: PUSH
81509: LD_INT 9
81511: PUSH
81512: LD_INT 10
81514: PUSH
81515: LD_INT 11
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: IN
81526: NOT
81527: OR
81528: IFFALSE 81534
// exit ;
81530: POP
81531: POP
81532: GO 81617
// end ;
81534: GO 81205
81536: POP
81537: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81538: LD_VAR 0 9
81542: PPUSH
81543: LD_VAR 0 3
81547: PPUSH
81548: LD_VAR 0 4
81552: PPUSH
81553: LD_INT 20
81555: PPUSH
81556: CALL 73569 0 4
81560: PUSH
81561: LD_INT 4
81563: ARRAY
81564: IFFALSE 81568
// exit ;
81566: GO 81617
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81568: LD_VAR 0 2
81572: PUSH
81573: LD_INT 29
81575: PUSH
81576: LD_INT 30
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: IN
81583: PUSH
81584: LD_VAR 0 3
81588: PPUSH
81589: LD_VAR 0 4
81593: PPUSH
81594: LD_VAR 0 9
81598: PPUSH
81599: CALL_OW 440
81603: NOT
81604: AND
81605: IFFALSE 81609
// exit ;
81607: GO 81617
// result := true ;
81609: LD_ADDR_VAR 0 6
81613: PUSH
81614: LD_INT 1
81616: ST_TO_ADDR
// end ;
81617: LD_VAR 0 6
81621: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81622: LD_INT 0
81624: PPUSH
81625: PPUSH
81626: PPUSH
81627: PPUSH
81628: PPUSH
81629: PPUSH
81630: PPUSH
81631: PPUSH
81632: PPUSH
81633: PPUSH
81634: PPUSH
81635: PPUSH
81636: PPUSH
81637: PPUSH
81638: PPUSH
81639: PPUSH
81640: PPUSH
81641: PPUSH
81642: PPUSH
81643: PPUSH
81644: PPUSH
81645: PPUSH
81646: PPUSH
81647: PPUSH
81648: PPUSH
81649: PPUSH
81650: PPUSH
81651: PPUSH
81652: PPUSH
81653: PPUSH
81654: PPUSH
81655: PPUSH
81656: PPUSH
81657: PPUSH
81658: PPUSH
81659: PPUSH
81660: PPUSH
81661: PPUSH
81662: PPUSH
81663: PPUSH
81664: PPUSH
81665: PPUSH
81666: PPUSH
81667: PPUSH
81668: PPUSH
81669: PPUSH
81670: PPUSH
81671: PPUSH
81672: PPUSH
81673: PPUSH
81674: PPUSH
81675: PPUSH
81676: PPUSH
81677: PPUSH
81678: PPUSH
81679: PPUSH
81680: PPUSH
81681: PPUSH
// result = [ ] ;
81682: LD_ADDR_VAR 0 7
81686: PUSH
81687: EMPTY
81688: ST_TO_ADDR
// temp_list = [ ] ;
81689: LD_ADDR_VAR 0 9
81693: PUSH
81694: EMPTY
81695: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81696: LD_VAR 0 4
81700: PUSH
81701: LD_INT 0
81703: PUSH
81704: LD_INT 1
81706: PUSH
81707: LD_INT 2
81709: PUSH
81710: LD_INT 3
81712: PUSH
81713: LD_INT 4
81715: PUSH
81716: LD_INT 5
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: IN
81727: NOT
81728: PUSH
81729: LD_VAR 0 1
81733: PUSH
81734: LD_INT 0
81736: PUSH
81737: LD_INT 1
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: IN
81744: PUSH
81745: LD_VAR 0 5
81749: PUSH
81750: LD_INT 1
81752: PUSH
81753: LD_INT 2
81755: PUSH
81756: LD_INT 3
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: LIST
81763: IN
81764: NOT
81765: AND
81766: OR
81767: IFFALSE 81771
// exit ;
81769: GO 100162
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
81771: LD_VAR 0 1
81775: PUSH
81776: LD_INT 6
81778: PUSH
81779: LD_INT 7
81781: PUSH
81782: LD_INT 8
81784: PUSH
81785: LD_INT 13
81787: PUSH
81788: LD_INT 12
81790: PUSH
81791: LD_INT 15
81793: PUSH
81794: LD_INT 11
81796: PUSH
81797: LD_INT 14
81799: PUSH
81800: LD_INT 10
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: IN
81814: IFFALSE 81824
// btype = b_lab ;
81816: LD_ADDR_VAR 0 1
81820: PUSH
81821: LD_INT 6
81823: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
81824: LD_VAR 0 6
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: LD_INT 1
81834: PUSH
81835: LD_INT 2
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: LIST
81842: IN
81843: NOT
81844: PUSH
81845: LD_VAR 0 1
81849: PUSH
81850: LD_INT 0
81852: PUSH
81853: LD_INT 1
81855: PUSH
81856: LD_INT 2
81858: PUSH
81859: LD_INT 3
81861: PUSH
81862: LD_INT 6
81864: PUSH
81865: LD_INT 36
81867: PUSH
81868: LD_INT 4
81870: PUSH
81871: LD_INT 5
81873: PUSH
81874: LD_INT 31
81876: PUSH
81877: LD_INT 32
81879: PUSH
81880: LD_INT 33
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: LIST
81887: LIST
81888: LIST
81889: LIST
81890: LIST
81891: LIST
81892: LIST
81893: LIST
81894: LIST
81895: IN
81896: NOT
81897: PUSH
81898: LD_VAR 0 6
81902: PUSH
81903: LD_INT 1
81905: EQUAL
81906: AND
81907: OR
81908: PUSH
81909: LD_VAR 0 1
81913: PUSH
81914: LD_INT 2
81916: PUSH
81917: LD_INT 3
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: IN
81924: NOT
81925: PUSH
81926: LD_VAR 0 6
81930: PUSH
81931: LD_INT 2
81933: EQUAL
81934: AND
81935: OR
81936: IFFALSE 81946
// mode = 0 ;
81938: LD_ADDR_VAR 0 6
81942: PUSH
81943: LD_INT 0
81945: ST_TO_ADDR
// case mode of 0 :
81946: LD_VAR 0 6
81950: PUSH
81951: LD_INT 0
81953: DOUBLE
81954: EQUAL
81955: IFTRUE 81959
81957: GO 93412
81959: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81960: LD_ADDR_VAR 0 11
81964: PUSH
81965: LD_INT 0
81967: PUSH
81968: LD_INT 0
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 0
81977: PUSH
81978: LD_INT 1
81980: NEG
81981: PUSH
81982: EMPTY
81983: LIST
81984: LIST
81985: PUSH
81986: LD_INT 1
81988: PUSH
81989: LD_INT 0
81991: PUSH
81992: EMPTY
81993: LIST
81994: LIST
81995: PUSH
81996: LD_INT 1
81998: PUSH
81999: LD_INT 1
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 0
82008: PUSH
82009: LD_INT 1
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 1
82018: NEG
82019: PUSH
82020: LD_INT 0
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 1
82029: NEG
82030: PUSH
82031: LD_INT 1
82033: NEG
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 1
82041: NEG
82042: PUSH
82043: LD_INT 2
82045: NEG
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: LD_INT 0
82053: PUSH
82054: LD_INT 2
82056: NEG
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 1
82064: PUSH
82065: LD_INT 1
82067: NEG
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 1
82075: PUSH
82076: LD_INT 2
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 0
82085: PUSH
82086: LD_INT 2
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 1
82095: NEG
82096: PUSH
82097: LD_INT 1
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 1
82106: PUSH
82107: LD_INT 3
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 0
82116: PUSH
82117: LD_INT 3
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: PUSH
82124: LD_INT 1
82126: NEG
82127: PUSH
82128: LD_INT 2
82130: PUSH
82131: EMPTY
82132: LIST
82133: LIST
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82153: LD_ADDR_VAR 0 12
82157: PUSH
82158: LD_INT 0
82160: PUSH
82161: LD_INT 0
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 1
82181: PUSH
82182: LD_INT 0
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 1
82191: PUSH
82192: LD_INT 1
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 0
82201: PUSH
82202: LD_INT 1
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 1
82211: NEG
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 1
82222: NEG
82223: PUSH
82224: LD_INT 1
82226: NEG
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 1
82234: PUSH
82235: LD_INT 1
82237: NEG
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 2
82245: PUSH
82246: LD_INT 0
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 2
82255: PUSH
82256: LD_INT 1
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 1
82265: NEG
82266: PUSH
82267: LD_INT 1
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 2
82276: NEG
82277: PUSH
82278: LD_INT 0
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: LD_INT 2
82287: NEG
82288: PUSH
82289: LD_INT 1
82291: NEG
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 2
82299: NEG
82300: PUSH
82301: LD_INT 1
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 3
82310: NEG
82311: PUSH
82312: LD_INT 0
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 3
82321: NEG
82322: PUSH
82323: LD_INT 1
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: LIST
82346: LIST
82347: LIST
82348: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82349: LD_ADDR_VAR 0 13
82353: PUSH
82354: LD_INT 0
82356: PUSH
82357: LD_INT 0
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 0
82366: PUSH
82367: LD_INT 1
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 1
82377: PUSH
82378: LD_INT 0
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: LD_INT 1
82387: PUSH
82388: LD_INT 1
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 0
82397: PUSH
82398: LD_INT 1
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 1
82407: NEG
82408: PUSH
82409: LD_INT 0
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 1
82418: NEG
82419: PUSH
82420: LD_INT 1
82422: NEG
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 1
82430: NEG
82431: PUSH
82432: LD_INT 2
82434: NEG
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 2
82442: PUSH
82443: LD_INT 1
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 2
82452: PUSH
82453: LD_INT 2
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 1
82462: PUSH
82463: LD_INT 2
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 2
82472: NEG
82473: PUSH
82474: LD_INT 1
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 2
82484: NEG
82485: PUSH
82486: LD_INT 2
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 2
82496: NEG
82497: PUSH
82498: LD_INT 3
82500: NEG
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 3
82508: NEG
82509: PUSH
82510: LD_INT 2
82512: NEG
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 3
82520: NEG
82521: PUSH
82522: LD_INT 3
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82548: LD_ADDR_VAR 0 14
82552: PUSH
82553: LD_INT 0
82555: PUSH
82556: LD_INT 0
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 0
82565: PUSH
82566: LD_INT 1
82568: NEG
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 1
82576: PUSH
82577: LD_INT 0
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: PUSH
82584: LD_INT 1
82586: PUSH
82587: LD_INT 1
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_INT 0
82596: PUSH
82597: LD_INT 1
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 1
82606: NEG
82607: PUSH
82608: LD_INT 0
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 1
82617: NEG
82618: PUSH
82619: LD_INT 1
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 1
82629: NEG
82630: PUSH
82631: LD_INT 2
82633: NEG
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 0
82641: PUSH
82642: LD_INT 2
82644: NEG
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 1
82652: PUSH
82653: LD_INT 1
82655: NEG
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 1
82663: PUSH
82664: LD_INT 2
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 0
82673: PUSH
82674: LD_INT 2
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 1
82683: NEG
82684: PUSH
82685: LD_INT 1
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 1
82694: NEG
82695: PUSH
82696: LD_INT 3
82698: NEG
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 0
82706: PUSH
82707: LD_INT 3
82709: NEG
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 1
82717: PUSH
82718: LD_INT 2
82720: NEG
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82744: LD_ADDR_VAR 0 15
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: LD_INT 0
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 0
82761: PUSH
82762: LD_INT 1
82764: NEG
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 1
82772: PUSH
82773: LD_INT 0
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 1
82782: PUSH
82783: LD_INT 1
82785: PUSH
82786: EMPTY
82787: LIST
82788: LIST
82789: PUSH
82790: LD_INT 0
82792: PUSH
82793: LD_INT 1
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 1
82802: NEG
82803: PUSH
82804: LD_INT 0
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 1
82813: NEG
82814: PUSH
82815: LD_INT 1
82817: NEG
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 1
82825: PUSH
82826: LD_INT 1
82828: NEG
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 2
82836: PUSH
82837: LD_INT 0
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 2
82846: PUSH
82847: LD_INT 1
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 1
82856: NEG
82857: PUSH
82858: LD_INT 1
82860: PUSH
82861: EMPTY
82862: LIST
82863: LIST
82864: PUSH
82865: LD_INT 2
82867: NEG
82868: PUSH
82869: LD_INT 0
82871: PUSH
82872: EMPTY
82873: LIST
82874: LIST
82875: PUSH
82876: LD_INT 2
82878: NEG
82879: PUSH
82880: LD_INT 1
82882: NEG
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 2
82890: PUSH
82891: LD_INT 1
82893: NEG
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 3
82901: PUSH
82902: LD_INT 0
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 3
82911: PUSH
82912: LD_INT 1
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: LIST
82936: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82937: LD_ADDR_VAR 0 16
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: LD_INT 0
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 0
82954: PUSH
82955: LD_INT 1
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: LD_INT 0
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 1
82975: PUSH
82976: LD_INT 1
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 0
82985: PUSH
82986: LD_INT 1
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 1
82995: NEG
82996: PUSH
82997: LD_INT 0
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 1
83006: NEG
83007: PUSH
83008: LD_INT 1
83010: NEG
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 1
83018: NEG
83019: PUSH
83020: LD_INT 2
83022: NEG
83023: PUSH
83024: EMPTY
83025: LIST
83026: LIST
83027: PUSH
83028: LD_INT 2
83030: PUSH
83031: LD_INT 1
83033: PUSH
83034: EMPTY
83035: LIST
83036: LIST
83037: PUSH
83038: LD_INT 2
83040: PUSH
83041: LD_INT 2
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: LD_INT 1
83050: PUSH
83051: LD_INT 2
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PUSH
83058: LD_INT 2
83060: NEG
83061: PUSH
83062: LD_INT 1
83064: NEG
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 2
83072: NEG
83073: PUSH
83074: LD_INT 2
83076: NEG
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 3
83084: PUSH
83085: LD_INT 2
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 3
83094: PUSH
83095: LD_INT 3
83097: PUSH
83098: EMPTY
83099: LIST
83100: LIST
83101: PUSH
83102: LD_INT 2
83104: PUSH
83105: LD_INT 3
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83130: LD_ADDR_VAR 0 17
83134: PUSH
83135: LD_INT 0
83137: PUSH
83138: LD_INT 0
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: PUSH
83145: LD_INT 0
83147: PUSH
83148: LD_INT 1
83150: NEG
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 1
83158: PUSH
83159: LD_INT 0
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 1
83168: PUSH
83169: LD_INT 1
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: LD_INT 0
83178: PUSH
83179: LD_INT 1
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PUSH
83186: LD_INT 1
83188: NEG
83189: PUSH
83190: LD_INT 0
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 1
83199: NEG
83200: PUSH
83201: LD_INT 1
83203: NEG
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 1
83211: NEG
83212: PUSH
83213: LD_INT 2
83215: NEG
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 0
83223: PUSH
83224: LD_INT 2
83226: NEG
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 1
83234: PUSH
83235: LD_INT 1
83237: NEG
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 2
83245: PUSH
83246: LD_INT 0
83248: PUSH
83249: EMPTY
83250: LIST
83251: LIST
83252: PUSH
83253: LD_INT 2
83255: PUSH
83256: LD_INT 1
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 2
83265: PUSH
83266: LD_INT 2
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 1
83275: PUSH
83276: LD_INT 2
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: LD_INT 0
83285: PUSH
83286: LD_INT 2
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 1
83295: NEG
83296: PUSH
83297: LD_INT 1
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: LD_INT 2
83306: NEG
83307: PUSH
83308: LD_INT 0
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 2
83317: NEG
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 2
83329: NEG
83330: PUSH
83331: LD_INT 2
83333: NEG
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: LIST
83346: LIST
83347: LIST
83348: LIST
83349: LIST
83350: LIST
83351: LIST
83352: LIST
83353: LIST
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83360: LD_ADDR_VAR 0 18
83364: PUSH
83365: LD_INT 0
83367: PUSH
83368: LD_INT 0
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 0
83377: PUSH
83378: LD_INT 1
83380: NEG
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 1
83388: PUSH
83389: LD_INT 0
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 1
83398: PUSH
83399: LD_INT 1
83401: PUSH
83402: EMPTY
83403: LIST
83404: LIST
83405: PUSH
83406: LD_INT 0
83408: PUSH
83409: LD_INT 1
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: LD_INT 1
83418: NEG
83419: PUSH
83420: LD_INT 0
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 1
83429: NEG
83430: PUSH
83431: LD_INT 1
83433: NEG
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 1
83441: NEG
83442: PUSH
83443: LD_INT 2
83445: NEG
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 0
83453: PUSH
83454: LD_INT 2
83456: NEG
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 1
83464: PUSH
83465: LD_INT 1
83467: NEG
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 2
83475: PUSH
83476: LD_INT 0
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: LD_INT 2
83485: PUSH
83486: LD_INT 1
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: PUSH
83493: LD_INT 2
83495: PUSH
83496: LD_INT 2
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 1
83505: PUSH
83506: LD_INT 2
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: LD_INT 0
83515: PUSH
83516: LD_INT 2
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 1
83525: NEG
83526: PUSH
83527: LD_INT 1
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 2
83536: NEG
83537: PUSH
83538: LD_INT 0
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 2
83547: NEG
83548: PUSH
83549: LD_INT 1
83551: NEG
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: PUSH
83557: LD_INT 2
83559: NEG
83560: PUSH
83561: LD_INT 2
83563: NEG
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83590: LD_ADDR_VAR 0 19
83594: PUSH
83595: LD_INT 0
83597: PUSH
83598: LD_INT 0
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 0
83607: PUSH
83608: LD_INT 1
83610: NEG
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: PUSH
83616: LD_INT 1
83618: PUSH
83619: LD_INT 0
83621: PUSH
83622: EMPTY
83623: LIST
83624: LIST
83625: PUSH
83626: LD_INT 1
83628: PUSH
83629: LD_INT 1
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 0
83638: PUSH
83639: LD_INT 1
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 1
83648: NEG
83649: PUSH
83650: LD_INT 0
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 1
83659: NEG
83660: PUSH
83661: LD_INT 1
83663: NEG
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 1
83671: NEG
83672: PUSH
83673: LD_INT 2
83675: NEG
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 0
83683: PUSH
83684: LD_INT 2
83686: NEG
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 1
83694: PUSH
83695: LD_INT 1
83697: NEG
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 2
83705: PUSH
83706: LD_INT 0
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: PUSH
83713: LD_INT 2
83715: PUSH
83716: LD_INT 1
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: PUSH
83723: LD_INT 2
83725: PUSH
83726: LD_INT 2
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: PUSH
83733: LD_INT 1
83735: PUSH
83736: LD_INT 2
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: LD_INT 0
83745: PUSH
83746: LD_INT 2
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 1
83755: NEG
83756: PUSH
83757: LD_INT 1
83759: PUSH
83760: EMPTY
83761: LIST
83762: LIST
83763: PUSH
83764: LD_INT 2
83766: NEG
83767: PUSH
83768: LD_INT 0
83770: PUSH
83771: EMPTY
83772: LIST
83773: LIST
83774: PUSH
83775: LD_INT 2
83777: NEG
83778: PUSH
83779: LD_INT 1
83781: NEG
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 2
83789: NEG
83790: PUSH
83791: LD_INT 2
83793: NEG
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83820: LD_ADDR_VAR 0 20
83824: PUSH
83825: LD_INT 0
83827: PUSH
83828: LD_INT 0
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 0
83837: PUSH
83838: LD_INT 1
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 1
83848: PUSH
83849: LD_INT 0
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: PUSH
83856: LD_INT 1
83858: PUSH
83859: LD_INT 1
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 0
83868: PUSH
83869: LD_INT 1
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: PUSH
83876: LD_INT 1
83878: NEG
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: PUSH
83887: LD_INT 1
83889: NEG
83890: PUSH
83891: LD_INT 1
83893: NEG
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: LD_INT 2
83905: NEG
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: LD_INT 2
83916: NEG
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 1
83924: PUSH
83925: LD_INT 1
83927: NEG
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 2
83935: PUSH
83936: LD_INT 0
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 2
83945: PUSH
83946: LD_INT 1
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 2
83955: PUSH
83956: LD_INT 2
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 1
83965: PUSH
83966: LD_INT 2
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 0
83975: PUSH
83976: LD_INT 2
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 1
83985: NEG
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 2
83996: NEG
83997: PUSH
83998: LD_INT 0
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 2
84007: NEG
84008: PUSH
84009: LD_INT 1
84011: NEG
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 2
84019: NEG
84020: PUSH
84021: LD_INT 2
84023: NEG
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: LIST
84048: LIST
84049: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84050: LD_ADDR_VAR 0 21
84054: PUSH
84055: LD_INT 0
84057: PUSH
84058: LD_INT 0
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 0
84067: PUSH
84068: LD_INT 1
84070: NEG
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 1
84078: PUSH
84079: LD_INT 0
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 1
84088: PUSH
84089: LD_INT 1
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 0
84098: PUSH
84099: LD_INT 1
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 1
84108: NEG
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 1
84119: NEG
84120: PUSH
84121: LD_INT 1
84123: NEG
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 1
84131: NEG
84132: PUSH
84133: LD_INT 2
84135: NEG
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PUSH
84141: LD_INT 0
84143: PUSH
84144: LD_INT 2
84146: NEG
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 1
84154: PUSH
84155: LD_INT 1
84157: NEG
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 2
84165: PUSH
84166: LD_INT 0
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: PUSH
84173: LD_INT 2
84175: PUSH
84176: LD_INT 1
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: LD_INT 2
84185: PUSH
84186: LD_INT 2
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 1
84195: PUSH
84196: LD_INT 2
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PUSH
84203: LD_INT 0
84205: PUSH
84206: LD_INT 2
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 1
84215: NEG
84216: PUSH
84217: LD_INT 1
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 2
84226: NEG
84227: PUSH
84228: LD_INT 0
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 2
84237: NEG
84238: PUSH
84239: LD_INT 1
84241: NEG
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 2
84249: NEG
84250: PUSH
84251: LD_INT 2
84253: NEG
84254: PUSH
84255: EMPTY
84256: LIST
84257: LIST
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: LIST
84263: LIST
84264: LIST
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84280: LD_ADDR_VAR 0 22
84284: PUSH
84285: LD_INT 0
84287: PUSH
84288: LD_INT 0
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 0
84297: PUSH
84298: LD_INT 1
84300: NEG
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: PUSH
84306: LD_INT 1
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 1
84318: PUSH
84319: LD_INT 1
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: LD_INT 0
84328: PUSH
84329: LD_INT 1
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: PUSH
84336: LD_INT 1
84338: NEG
84339: PUSH
84340: LD_INT 0
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 1
84349: NEG
84350: PUSH
84351: LD_INT 1
84353: NEG
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: LD_INT 2
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 0
84373: PUSH
84374: LD_INT 2
84376: NEG
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 1
84384: PUSH
84385: LD_INT 1
84387: NEG
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 2
84395: PUSH
84396: LD_INT 0
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 2
84405: PUSH
84406: LD_INT 1
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 2
84415: PUSH
84416: LD_INT 2
84418: PUSH
84419: EMPTY
84420: LIST
84421: LIST
84422: PUSH
84423: LD_INT 1
84425: PUSH
84426: LD_INT 2
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: PUSH
84433: LD_INT 0
84435: PUSH
84436: LD_INT 2
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: PUSH
84443: LD_INT 1
84445: NEG
84446: PUSH
84447: LD_INT 1
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: PUSH
84454: LD_INT 2
84456: NEG
84457: PUSH
84458: LD_INT 0
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 2
84467: NEG
84468: PUSH
84469: LD_INT 1
84471: NEG
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: LD_INT 2
84483: NEG
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: EMPTY
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84510: LD_ADDR_VAR 0 23
84514: PUSH
84515: LD_INT 0
84517: PUSH
84518: LD_INT 0
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: LD_INT 1
84530: NEG
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: PUSH
84536: LD_INT 1
84538: PUSH
84539: LD_INT 0
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: LD_INT 1
84551: PUSH
84552: EMPTY
84553: LIST
84554: LIST
84555: PUSH
84556: LD_INT 0
84558: PUSH
84559: LD_INT 1
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 1
84568: NEG
84569: PUSH
84570: LD_INT 0
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PUSH
84577: LD_INT 1
84579: NEG
84580: PUSH
84581: LD_INT 1
84583: NEG
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: PUSH
84589: LD_INT 1
84591: NEG
84592: PUSH
84593: LD_INT 2
84595: NEG
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 0
84603: PUSH
84604: LD_INT 2
84606: NEG
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 1
84614: PUSH
84615: LD_INT 1
84617: NEG
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 2
84625: PUSH
84626: LD_INT 0
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 2
84635: PUSH
84636: LD_INT 1
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 2
84645: PUSH
84646: LD_INT 2
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 1
84655: PUSH
84656: LD_INT 2
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: LD_INT 0
84665: PUSH
84666: LD_INT 2
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: PUSH
84673: LD_INT 1
84675: NEG
84676: PUSH
84677: LD_INT 1
84679: PUSH
84680: EMPTY
84681: LIST
84682: LIST
84683: PUSH
84684: LD_INT 2
84686: NEG
84687: PUSH
84688: LD_INT 0
84690: PUSH
84691: EMPTY
84692: LIST
84693: LIST
84694: PUSH
84695: LD_INT 2
84697: NEG
84698: PUSH
84699: LD_INT 1
84701: NEG
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 2
84709: NEG
84710: PUSH
84711: LD_INT 2
84713: NEG
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 2
84721: NEG
84722: PUSH
84723: LD_INT 3
84725: NEG
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 1
84733: NEG
84734: PUSH
84735: LD_INT 3
84737: NEG
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: LD_INT 1
84745: PUSH
84746: LD_INT 2
84748: NEG
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: PUSH
84754: LD_INT 2
84756: PUSH
84757: LD_INT 1
84759: NEG
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: LIST
84782: LIST
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: LIST
84789: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
84790: LD_ADDR_VAR 0 24
84794: PUSH
84795: LD_INT 0
84797: PUSH
84798: LD_INT 0
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 0
84807: PUSH
84808: LD_INT 1
84810: NEG
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: LD_INT 0
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 1
84828: PUSH
84829: LD_INT 1
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 0
84838: PUSH
84839: LD_INT 1
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 1
84848: NEG
84849: PUSH
84850: LD_INT 0
84852: PUSH
84853: EMPTY
84854: LIST
84855: LIST
84856: PUSH
84857: LD_INT 1
84859: NEG
84860: PUSH
84861: LD_INT 1
84863: NEG
84864: PUSH
84865: EMPTY
84866: LIST
84867: LIST
84868: PUSH
84869: LD_INT 1
84871: NEG
84872: PUSH
84873: LD_INT 2
84875: NEG
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 0
84883: PUSH
84884: LD_INT 2
84886: NEG
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 1
84894: PUSH
84895: LD_INT 1
84897: NEG
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: PUSH
84903: LD_INT 2
84905: PUSH
84906: LD_INT 0
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: PUSH
84913: LD_INT 2
84915: PUSH
84916: LD_INT 1
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: PUSH
84923: LD_INT 2
84925: PUSH
84926: LD_INT 2
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: PUSH
84933: LD_INT 1
84935: PUSH
84936: LD_INT 2
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: PUSH
84943: LD_INT 0
84945: PUSH
84946: LD_INT 2
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: PUSH
84953: LD_INT 1
84955: NEG
84956: PUSH
84957: LD_INT 1
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: PUSH
84964: LD_INT 2
84966: NEG
84967: PUSH
84968: LD_INT 0
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 2
84977: NEG
84978: PUSH
84979: LD_INT 1
84981: NEG
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 2
84989: NEG
84990: PUSH
84991: LD_INT 2
84993: NEG
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 1
85001: PUSH
85002: LD_INT 2
85004: NEG
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 2
85012: PUSH
85013: LD_INT 1
85015: NEG
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: LD_INT 3
85023: PUSH
85024: LD_INT 1
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: LD_INT 3
85033: PUSH
85034: LD_INT 2
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
85066: LD_ADDR_VAR 0 25
85070: PUSH
85071: LD_INT 0
85073: PUSH
85074: LD_INT 0
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: LD_INT 1
85086: NEG
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: PUSH
85092: LD_INT 1
85094: PUSH
85095: LD_INT 0
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 1
85104: PUSH
85105: LD_INT 1
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: LD_INT 0
85114: PUSH
85115: LD_INT 1
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: PUSH
85122: LD_INT 1
85124: NEG
85125: PUSH
85126: LD_INT 0
85128: PUSH
85129: EMPTY
85130: LIST
85131: LIST
85132: PUSH
85133: LD_INT 1
85135: NEG
85136: PUSH
85137: LD_INT 1
85139: NEG
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 1
85147: NEG
85148: PUSH
85149: LD_INT 2
85151: NEG
85152: PUSH
85153: EMPTY
85154: LIST
85155: LIST
85156: PUSH
85157: LD_INT 0
85159: PUSH
85160: LD_INT 2
85162: NEG
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: PUSH
85168: LD_INT 1
85170: PUSH
85171: LD_INT 1
85173: NEG
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 2
85181: PUSH
85182: LD_INT 0
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PUSH
85189: LD_INT 2
85191: PUSH
85192: LD_INT 1
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: PUSH
85199: LD_INT 2
85201: PUSH
85202: LD_INT 2
85204: PUSH
85205: EMPTY
85206: LIST
85207: LIST
85208: PUSH
85209: LD_INT 1
85211: PUSH
85212: LD_INT 2
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: PUSH
85219: LD_INT 0
85221: PUSH
85222: LD_INT 2
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: PUSH
85229: LD_INT 1
85231: NEG
85232: PUSH
85233: LD_INT 1
85235: PUSH
85236: EMPTY
85237: LIST
85238: LIST
85239: PUSH
85240: LD_INT 2
85242: NEG
85243: PUSH
85244: LD_INT 0
85246: PUSH
85247: EMPTY
85248: LIST
85249: LIST
85250: PUSH
85251: LD_INT 2
85253: NEG
85254: PUSH
85255: LD_INT 1
85257: NEG
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 2
85265: NEG
85266: PUSH
85267: LD_INT 2
85269: NEG
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 3
85277: PUSH
85278: LD_INT 1
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PUSH
85285: LD_INT 3
85287: PUSH
85288: LD_INT 2
85290: PUSH
85291: EMPTY
85292: LIST
85293: LIST
85294: PUSH
85295: LD_INT 2
85297: PUSH
85298: LD_INT 3
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: PUSH
85305: LD_INT 1
85307: PUSH
85308: LD_INT 3
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85340: LD_ADDR_VAR 0 26
85344: PUSH
85345: LD_INT 0
85347: PUSH
85348: LD_INT 0
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: LD_INT 0
85357: PUSH
85358: LD_INT 1
85360: NEG
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: LD_INT 0
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 1
85378: PUSH
85379: LD_INT 1
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 0
85388: PUSH
85389: LD_INT 1
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: LD_INT 0
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 1
85409: NEG
85410: PUSH
85411: LD_INT 1
85413: NEG
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 1
85421: NEG
85422: PUSH
85423: LD_INT 2
85425: NEG
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 0
85433: PUSH
85434: LD_INT 2
85436: NEG
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: PUSH
85445: LD_INT 1
85447: NEG
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 2
85455: PUSH
85456: LD_INT 0
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 2
85465: PUSH
85466: LD_INT 1
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 2
85475: PUSH
85476: LD_INT 2
85478: PUSH
85479: EMPTY
85480: LIST
85481: LIST
85482: PUSH
85483: LD_INT 1
85485: PUSH
85486: LD_INT 2
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 0
85495: PUSH
85496: LD_INT 2
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: LD_INT 1
85505: NEG
85506: PUSH
85507: LD_INT 1
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: PUSH
85514: LD_INT 2
85516: NEG
85517: PUSH
85518: LD_INT 0
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PUSH
85525: LD_INT 2
85527: NEG
85528: PUSH
85529: LD_INT 1
85531: NEG
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 2
85539: NEG
85540: PUSH
85541: LD_INT 2
85543: NEG
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 2
85551: PUSH
85552: LD_INT 3
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: PUSH
85559: LD_INT 1
85561: PUSH
85562: LD_INT 3
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 1
85571: NEG
85572: PUSH
85573: LD_INT 2
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 2
85582: NEG
85583: PUSH
85584: LD_INT 1
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: PUSH
85591: EMPTY
85592: LIST
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85616: LD_ADDR_VAR 0 27
85620: PUSH
85621: LD_INT 0
85623: PUSH
85624: LD_INT 0
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 0
85633: PUSH
85634: LD_INT 1
85636: NEG
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 1
85644: PUSH
85645: LD_INT 0
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PUSH
85652: LD_INT 1
85654: PUSH
85655: LD_INT 1
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: LD_INT 1
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 1
85674: NEG
85675: PUSH
85676: LD_INT 0
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: NEG
85686: PUSH
85687: LD_INT 1
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 1
85697: NEG
85698: PUSH
85699: LD_INT 2
85701: NEG
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: PUSH
85707: LD_INT 0
85709: PUSH
85710: LD_INT 2
85712: NEG
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 1
85720: PUSH
85721: LD_INT 1
85723: NEG
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 2
85731: PUSH
85732: LD_INT 0
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 2
85741: PUSH
85742: LD_INT 1
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 2
85751: PUSH
85752: LD_INT 2
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 1
85761: PUSH
85762: LD_INT 2
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 0
85771: PUSH
85772: LD_INT 2
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 1
85781: NEG
85782: PUSH
85783: LD_INT 1
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 2
85792: NEG
85793: PUSH
85794: LD_INT 0
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: LD_INT 2
85803: NEG
85804: PUSH
85805: LD_INT 1
85807: NEG
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: PUSH
85813: LD_INT 2
85815: NEG
85816: PUSH
85817: LD_INT 2
85819: NEG
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: LD_INT 2
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 2
85838: NEG
85839: PUSH
85840: LD_INT 1
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 3
85849: NEG
85850: PUSH
85851: LD_INT 1
85853: NEG
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 3
85861: NEG
85862: PUSH
85863: LD_INT 2
85865: NEG
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85896: LD_ADDR_VAR 0 28
85900: PUSH
85901: LD_INT 0
85903: PUSH
85904: LD_INT 0
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 0
85913: PUSH
85914: LD_INT 1
85916: NEG
85917: PUSH
85918: EMPTY
85919: LIST
85920: LIST
85921: PUSH
85922: LD_INT 1
85924: PUSH
85925: LD_INT 0
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: PUSH
85932: LD_INT 1
85934: PUSH
85935: LD_INT 1
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 0
85944: PUSH
85945: LD_INT 1
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: LD_INT 1
85954: NEG
85955: PUSH
85956: LD_INT 0
85958: PUSH
85959: EMPTY
85960: LIST
85961: LIST
85962: PUSH
85963: LD_INT 1
85965: NEG
85966: PUSH
85967: LD_INT 1
85969: NEG
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 1
85977: NEG
85978: PUSH
85979: LD_INT 2
85981: NEG
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 0
85989: PUSH
85990: LD_INT 2
85992: NEG
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 1
86000: PUSH
86001: LD_INT 1
86003: NEG
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 2
86011: PUSH
86012: LD_INT 0
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_INT 2
86021: PUSH
86022: LD_INT 1
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: LD_INT 2
86031: PUSH
86032: LD_INT 2
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 1
86041: PUSH
86042: LD_INT 2
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 0
86051: PUSH
86052: LD_INT 2
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: LD_INT 1
86061: NEG
86062: PUSH
86063: LD_INT 1
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 2
86072: NEG
86073: PUSH
86074: LD_INT 0
86076: PUSH
86077: EMPTY
86078: LIST
86079: LIST
86080: PUSH
86081: LD_INT 2
86083: NEG
86084: PUSH
86085: LD_INT 1
86087: NEG
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 2
86095: NEG
86096: PUSH
86097: LD_INT 2
86099: NEG
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 2
86107: NEG
86108: PUSH
86109: LD_INT 3
86111: NEG
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 1
86119: NEG
86120: PUSH
86121: LD_INT 3
86123: NEG
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: PUSH
86129: LD_INT 3
86131: NEG
86132: PUSH
86133: LD_INT 1
86135: NEG
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 3
86143: NEG
86144: PUSH
86145: LD_INT 2
86147: NEG
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86178: LD_ADDR_VAR 0 29
86182: PUSH
86183: LD_INT 0
86185: PUSH
86186: LD_INT 0
86188: PUSH
86189: EMPTY
86190: LIST
86191: LIST
86192: PUSH
86193: LD_INT 0
86195: PUSH
86196: LD_INT 1
86198: NEG
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 1
86206: PUSH
86207: LD_INT 0
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 1
86216: PUSH
86217: LD_INT 1
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: LD_INT 1
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: LD_INT 1
86236: NEG
86237: PUSH
86238: LD_INT 0
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: NEG
86248: PUSH
86249: LD_INT 1
86251: NEG
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 1
86259: NEG
86260: PUSH
86261: LD_INT 2
86263: NEG
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 0
86271: PUSH
86272: LD_INT 2
86274: NEG
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: PUSH
86283: LD_INT 1
86285: NEG
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 2
86293: PUSH
86294: LD_INT 0
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 2
86303: PUSH
86304: LD_INT 1
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PUSH
86311: LD_INT 1
86313: PUSH
86314: LD_INT 2
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 0
86323: PUSH
86324: LD_INT 2
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: PUSH
86331: LD_INT 1
86333: NEG
86334: PUSH
86335: LD_INT 1
86337: PUSH
86338: EMPTY
86339: LIST
86340: LIST
86341: PUSH
86342: LD_INT 2
86344: NEG
86345: PUSH
86346: LD_INT 1
86348: NEG
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 2
86356: NEG
86357: PUSH
86358: LD_INT 2
86360: NEG
86361: PUSH
86362: EMPTY
86363: LIST
86364: LIST
86365: PUSH
86366: LD_INT 2
86368: NEG
86369: PUSH
86370: LD_INT 3
86372: NEG
86373: PUSH
86374: EMPTY
86375: LIST
86376: LIST
86377: PUSH
86378: LD_INT 2
86380: PUSH
86381: LD_INT 1
86383: NEG
86384: PUSH
86385: EMPTY
86386: LIST
86387: LIST
86388: PUSH
86389: LD_INT 3
86391: PUSH
86392: LD_INT 1
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: LD_INT 1
86401: PUSH
86402: LD_INT 3
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 1
86411: NEG
86412: PUSH
86413: LD_INT 2
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: PUSH
86420: LD_INT 3
86422: NEG
86423: PUSH
86424: LD_INT 2
86426: NEG
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86457: LD_ADDR_VAR 0 30
86461: PUSH
86462: LD_INT 0
86464: PUSH
86465: LD_INT 0
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: PUSH
86472: LD_INT 0
86474: PUSH
86475: LD_INT 1
86477: NEG
86478: PUSH
86479: EMPTY
86480: LIST
86481: LIST
86482: PUSH
86483: LD_INT 1
86485: PUSH
86486: LD_INT 0
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: PUSH
86493: LD_INT 1
86495: PUSH
86496: LD_INT 1
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: LD_INT 0
86505: PUSH
86506: LD_INT 1
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: LD_INT 0
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: PUSH
86524: LD_INT 1
86526: NEG
86527: PUSH
86528: LD_INT 1
86530: NEG
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: LD_INT 1
86538: NEG
86539: PUSH
86540: LD_INT 2
86542: NEG
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 0
86550: PUSH
86551: LD_INT 2
86553: NEG
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 1
86561: PUSH
86562: LD_INT 1
86564: NEG
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: PUSH
86570: LD_INT 2
86572: PUSH
86573: LD_INT 0
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: PUSH
86580: LD_INT 2
86582: PUSH
86583: LD_INT 1
86585: PUSH
86586: EMPTY
86587: LIST
86588: LIST
86589: PUSH
86590: LD_INT 2
86592: PUSH
86593: LD_INT 2
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 1
86602: PUSH
86603: LD_INT 2
86605: PUSH
86606: EMPTY
86607: LIST
86608: LIST
86609: PUSH
86610: LD_INT 1
86612: NEG
86613: PUSH
86614: LD_INT 1
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 2
86623: NEG
86624: PUSH
86625: LD_INT 0
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: LD_INT 2
86634: NEG
86635: PUSH
86636: LD_INT 1
86638: NEG
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: LD_INT 1
86646: NEG
86647: PUSH
86648: LD_INT 3
86650: NEG
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 1
86658: PUSH
86659: LD_INT 2
86661: NEG
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 3
86669: PUSH
86670: LD_INT 2
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 2
86679: PUSH
86680: LD_INT 3
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 2
86689: NEG
86690: PUSH
86691: LD_INT 1
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 3
86700: NEG
86701: PUSH
86702: LD_INT 1
86704: NEG
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: LIST
86732: LIST
86733: LIST
86734: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86735: LD_ADDR_VAR 0 31
86739: PUSH
86740: LD_INT 0
86742: PUSH
86743: LD_INT 0
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: PUSH
86750: LD_INT 0
86752: PUSH
86753: LD_INT 1
86755: NEG
86756: PUSH
86757: EMPTY
86758: LIST
86759: LIST
86760: PUSH
86761: LD_INT 1
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 1
86773: PUSH
86774: LD_INT 1
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 0
86783: PUSH
86784: LD_INT 1
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 1
86793: NEG
86794: PUSH
86795: LD_INT 0
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 1
86804: NEG
86805: PUSH
86806: LD_INT 1
86808: NEG
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: LD_INT 1
86816: NEG
86817: PUSH
86818: LD_INT 2
86820: NEG
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 1
86828: PUSH
86829: LD_INT 1
86831: NEG
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 2
86839: PUSH
86840: LD_INT 0
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 2
86849: PUSH
86850: LD_INT 1
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 2
86859: PUSH
86860: LD_INT 2
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PUSH
86867: LD_INT 1
86869: PUSH
86870: LD_INT 2
86872: PUSH
86873: EMPTY
86874: LIST
86875: LIST
86876: PUSH
86877: LD_INT 0
86879: PUSH
86880: LD_INT 2
86882: PUSH
86883: EMPTY
86884: LIST
86885: LIST
86886: PUSH
86887: LD_INT 1
86889: NEG
86890: PUSH
86891: LD_INT 1
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 2
86900: NEG
86901: PUSH
86902: LD_INT 1
86904: NEG
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_INT 2
86912: NEG
86913: PUSH
86914: LD_INT 2
86916: NEG
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PUSH
86922: LD_INT 2
86924: NEG
86925: PUSH
86926: LD_INT 3
86928: NEG
86929: PUSH
86930: EMPTY
86931: LIST
86932: LIST
86933: PUSH
86934: LD_INT 2
86936: PUSH
86937: LD_INT 1
86939: NEG
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: PUSH
86945: LD_INT 3
86947: PUSH
86948: LD_INT 1
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 1
86957: PUSH
86958: LD_INT 3
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 1
86967: NEG
86968: PUSH
86969: LD_INT 2
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PUSH
86976: LD_INT 3
86978: NEG
86979: PUSH
86980: LD_INT 2
86982: NEG
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87013: LD_ADDR_VAR 0 32
87017: PUSH
87018: LD_INT 0
87020: PUSH
87021: LD_INT 0
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PUSH
87028: LD_INT 0
87030: PUSH
87031: LD_INT 1
87033: NEG
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 1
87041: PUSH
87042: LD_INT 0
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 1
87051: PUSH
87052: LD_INT 1
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 0
87061: PUSH
87062: LD_INT 1
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 1
87071: NEG
87072: PUSH
87073: LD_INT 0
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 1
87082: NEG
87083: PUSH
87084: LD_INT 1
87086: NEG
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 1
87094: NEG
87095: PUSH
87096: LD_INT 2
87098: NEG
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 0
87106: PUSH
87107: LD_INT 2
87109: NEG
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: PUSH
87115: LD_INT 1
87117: PUSH
87118: LD_INT 1
87120: NEG
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 2
87128: PUSH
87129: LD_INT 1
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 2
87138: PUSH
87139: LD_INT 2
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: PUSH
87146: LD_INT 1
87148: PUSH
87149: LD_INT 2
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: PUSH
87156: LD_INT 0
87158: PUSH
87159: LD_INT 2
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: PUSH
87166: LD_INT 1
87168: NEG
87169: PUSH
87170: LD_INT 1
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 2
87179: NEG
87180: PUSH
87181: LD_INT 0
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PUSH
87188: LD_INT 2
87190: NEG
87191: PUSH
87192: LD_INT 1
87194: NEG
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 1
87202: NEG
87203: PUSH
87204: LD_INT 3
87206: NEG
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 1
87214: PUSH
87215: LD_INT 2
87217: NEG
87218: PUSH
87219: EMPTY
87220: LIST
87221: LIST
87222: PUSH
87223: LD_INT 3
87225: PUSH
87226: LD_INT 2
87228: PUSH
87229: EMPTY
87230: LIST
87231: LIST
87232: PUSH
87233: LD_INT 2
87235: PUSH
87236: LD_INT 3
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: PUSH
87243: LD_INT 2
87245: NEG
87246: PUSH
87247: LD_INT 1
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_INT 3
87256: NEG
87257: PUSH
87258: LD_INT 1
87260: NEG
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: LIST
87285: LIST
87286: LIST
87287: LIST
87288: LIST
87289: LIST
87290: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87291: LD_ADDR_VAR 0 33
87295: PUSH
87296: LD_INT 0
87298: PUSH
87299: LD_INT 0
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 0
87308: PUSH
87309: LD_INT 1
87311: NEG
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 1
87319: PUSH
87320: LD_INT 0
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 1
87329: PUSH
87330: LD_INT 1
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 0
87339: PUSH
87340: LD_INT 1
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 1
87349: NEG
87350: PUSH
87351: LD_INT 0
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: PUSH
87358: LD_INT 1
87360: NEG
87361: PUSH
87362: LD_INT 1
87364: NEG
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 1
87372: NEG
87373: PUSH
87374: LD_INT 2
87376: NEG
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: LD_INT 1
87384: PUSH
87385: LD_INT 1
87387: NEG
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 2
87395: PUSH
87396: LD_INT 0
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: LD_INT 2
87405: PUSH
87406: LD_INT 1
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 1
87415: PUSH
87416: LD_INT 2
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PUSH
87423: LD_INT 0
87425: PUSH
87426: LD_INT 2
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 1
87435: NEG
87436: PUSH
87437: LD_INT 1
87439: PUSH
87440: EMPTY
87441: LIST
87442: LIST
87443: PUSH
87444: LD_INT 2
87446: NEG
87447: PUSH
87448: LD_INT 0
87450: PUSH
87451: EMPTY
87452: LIST
87453: LIST
87454: PUSH
87455: LD_INT 2
87457: NEG
87458: PUSH
87459: LD_INT 1
87461: NEG
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 2
87469: NEG
87470: PUSH
87471: LD_INT 2
87473: NEG
87474: PUSH
87475: EMPTY
87476: LIST
87477: LIST
87478: PUSH
87479: LD_INT 2
87481: NEG
87482: PUSH
87483: LD_INT 3
87485: NEG
87486: PUSH
87487: EMPTY
87488: LIST
87489: LIST
87490: PUSH
87491: LD_INT 2
87493: PUSH
87494: LD_INT 1
87496: NEG
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 3
87504: PUSH
87505: LD_INT 1
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 1
87514: PUSH
87515: LD_INT 3
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 1
87524: NEG
87525: PUSH
87526: LD_INT 2
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 3
87535: NEG
87536: PUSH
87537: LD_INT 2
87539: NEG
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87570: LD_ADDR_VAR 0 34
87574: PUSH
87575: LD_INT 0
87577: PUSH
87578: LD_INT 0
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: PUSH
87585: LD_INT 0
87587: PUSH
87588: LD_INT 1
87590: NEG
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 1
87598: PUSH
87599: LD_INT 0
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: PUSH
87606: LD_INT 1
87608: PUSH
87609: LD_INT 1
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: PUSH
87616: LD_INT 0
87618: PUSH
87619: LD_INT 1
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: PUSH
87626: LD_INT 1
87628: NEG
87629: PUSH
87630: LD_INT 0
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 1
87639: NEG
87640: PUSH
87641: LD_INT 1
87643: NEG
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: LD_INT 1
87651: NEG
87652: PUSH
87653: LD_INT 2
87655: NEG
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: PUSH
87661: LD_INT 0
87663: PUSH
87664: LD_INT 2
87666: NEG
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: PUSH
87672: LD_INT 1
87674: PUSH
87675: LD_INT 1
87677: NEG
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 2
87685: PUSH
87686: LD_INT 1
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: PUSH
87693: LD_INT 2
87695: PUSH
87696: LD_INT 2
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: PUSH
87703: LD_INT 1
87705: PUSH
87706: LD_INT 2
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: PUSH
87713: LD_INT 1
87715: NEG
87716: PUSH
87717: LD_INT 1
87719: PUSH
87720: EMPTY
87721: LIST
87722: LIST
87723: PUSH
87724: LD_INT 2
87726: NEG
87727: PUSH
87728: LD_INT 0
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 2
87737: NEG
87738: PUSH
87739: LD_INT 1
87741: NEG
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PUSH
87747: LD_INT 2
87749: NEG
87750: PUSH
87751: LD_INT 2
87753: NEG
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 1
87761: NEG
87762: PUSH
87763: LD_INT 3
87765: NEG
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 1
87773: PUSH
87774: LD_INT 2
87776: NEG
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 3
87784: PUSH
87785: LD_INT 2
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PUSH
87792: LD_INT 2
87794: PUSH
87795: LD_INT 3
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 2
87804: NEG
87805: PUSH
87806: LD_INT 1
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: PUSH
87813: LD_INT 3
87815: NEG
87816: PUSH
87817: LD_INT 1
87819: NEG
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: EMPTY
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87850: LD_ADDR_VAR 0 35
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: LD_INT 0
87860: PUSH
87861: EMPTY
87862: LIST
87863: LIST
87864: PUSH
87865: LD_INT 0
87867: PUSH
87868: LD_INT 1
87870: NEG
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 1
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 1
87888: PUSH
87889: LD_INT 1
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: LD_INT 0
87898: PUSH
87899: LD_INT 1
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 1
87908: NEG
87909: PUSH
87910: LD_INT 0
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: PUSH
87917: LD_INT 1
87919: NEG
87920: PUSH
87921: LD_INT 1
87923: NEG
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 2
87931: PUSH
87932: LD_INT 1
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: PUSH
87939: LD_INT 2
87941: NEG
87942: PUSH
87943: LD_INT 1
87945: NEG
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87962: LD_ADDR_VAR 0 36
87966: PUSH
87967: LD_INT 0
87969: PUSH
87970: LD_INT 0
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 0
87979: PUSH
87980: LD_INT 1
87982: NEG
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 1
87990: PUSH
87991: LD_INT 0
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 1
88000: PUSH
88001: LD_INT 1
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 0
88010: PUSH
88011: LD_INT 1
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 1
88020: NEG
88021: PUSH
88022: LD_INT 0
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: PUSH
88029: LD_INT 1
88031: NEG
88032: PUSH
88033: LD_INT 1
88035: NEG
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 1
88043: NEG
88044: PUSH
88045: LD_INT 2
88047: NEG
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 1
88055: PUSH
88056: LD_INT 2
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: LIST
88071: LIST
88072: LIST
88073: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88074: LD_ADDR_VAR 0 37
88078: PUSH
88079: LD_INT 0
88081: PUSH
88082: LD_INT 0
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 0
88091: PUSH
88092: LD_INT 1
88094: NEG
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 1
88102: PUSH
88103: LD_INT 0
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PUSH
88110: LD_INT 1
88112: PUSH
88113: LD_INT 1
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: PUSH
88120: LD_INT 0
88122: PUSH
88123: LD_INT 1
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: LD_INT 1
88132: NEG
88133: PUSH
88134: LD_INT 0
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 1
88143: NEG
88144: PUSH
88145: LD_INT 1
88147: NEG
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 1
88155: PUSH
88156: LD_INT 1
88158: NEG
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 1
88166: NEG
88167: PUSH
88168: LD_INT 1
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
88186: LD_ADDR_VAR 0 38
88190: PUSH
88191: LD_INT 0
88193: PUSH
88194: LD_INT 0
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: LD_INT 0
88203: PUSH
88204: LD_INT 1
88206: NEG
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: PUSH
88212: LD_INT 1
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: EMPTY
88219: LIST
88220: LIST
88221: PUSH
88222: LD_INT 1
88224: PUSH
88225: LD_INT 1
88227: PUSH
88228: EMPTY
88229: LIST
88230: LIST
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: LD_INT 1
88237: PUSH
88238: EMPTY
88239: LIST
88240: LIST
88241: PUSH
88242: LD_INT 1
88244: NEG
88245: PUSH
88246: LD_INT 0
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: PUSH
88253: LD_INT 1
88255: NEG
88256: PUSH
88257: LD_INT 1
88259: NEG
88260: PUSH
88261: EMPTY
88262: LIST
88263: LIST
88264: PUSH
88265: LD_INT 2
88267: PUSH
88268: LD_INT 1
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: LD_INT 2
88277: NEG
88278: PUSH
88279: LD_INT 1
88281: NEG
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88298: LD_ADDR_VAR 0 39
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: LD_INT 0
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 0
88315: PUSH
88316: LD_INT 1
88318: NEG
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 1
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 1
88336: PUSH
88337: LD_INT 1
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 0
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 1
88356: NEG
88357: PUSH
88358: LD_INT 0
88360: PUSH
88361: EMPTY
88362: LIST
88363: LIST
88364: PUSH
88365: LD_INT 1
88367: NEG
88368: PUSH
88369: LD_INT 1
88371: NEG
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 1
88379: NEG
88380: PUSH
88381: LD_INT 2
88383: NEG
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PUSH
88389: LD_INT 1
88391: PUSH
88392: LD_INT 2
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: EMPTY
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88410: LD_ADDR_VAR 0 40
88414: PUSH
88415: LD_INT 0
88417: PUSH
88418: LD_INT 0
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 0
88427: PUSH
88428: LD_INT 1
88430: NEG
88431: PUSH
88432: EMPTY
88433: LIST
88434: LIST
88435: PUSH
88436: LD_INT 1
88438: PUSH
88439: LD_INT 0
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 1
88448: PUSH
88449: LD_INT 1
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: PUSH
88456: LD_INT 0
88458: PUSH
88459: LD_INT 1
88461: PUSH
88462: EMPTY
88463: LIST
88464: LIST
88465: PUSH
88466: LD_INT 1
88468: NEG
88469: PUSH
88470: LD_INT 0
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: PUSH
88477: LD_INT 1
88479: NEG
88480: PUSH
88481: LD_INT 1
88483: NEG
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 1
88491: PUSH
88492: LD_INT 1
88494: NEG
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 1
88502: NEG
88503: PUSH
88504: LD_INT 1
88506: PUSH
88507: EMPTY
88508: LIST
88509: LIST
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88522: LD_ADDR_VAR 0 41
88526: PUSH
88527: LD_INT 0
88529: PUSH
88530: LD_INT 0
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: PUSH
88537: LD_INT 0
88539: PUSH
88540: LD_INT 1
88542: NEG
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 1
88550: PUSH
88551: LD_INT 0
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 1
88560: PUSH
88561: LD_INT 1
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 0
88570: PUSH
88571: LD_INT 1
88573: PUSH
88574: EMPTY
88575: LIST
88576: LIST
88577: PUSH
88578: LD_INT 1
88580: NEG
88581: PUSH
88582: LD_INT 0
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: LD_INT 1
88591: NEG
88592: PUSH
88593: LD_INT 1
88595: NEG
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PUSH
88601: LD_INT 1
88603: NEG
88604: PUSH
88605: LD_INT 2
88607: NEG
88608: PUSH
88609: EMPTY
88610: LIST
88611: LIST
88612: PUSH
88613: LD_INT 1
88615: PUSH
88616: LD_INT 1
88618: NEG
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: PUSH
88624: LD_INT 2
88626: PUSH
88627: LD_INT 0
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: PUSH
88634: LD_INT 2
88636: PUSH
88637: LD_INT 1
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: PUSH
88644: LD_INT 2
88646: PUSH
88647: LD_INT 2
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PUSH
88654: LD_INT 1
88656: PUSH
88657: LD_INT 2
88659: PUSH
88660: EMPTY
88661: LIST
88662: LIST
88663: PUSH
88664: LD_INT 1
88666: NEG
88667: PUSH
88668: LD_INT 1
88670: PUSH
88671: EMPTY
88672: LIST
88673: LIST
88674: PUSH
88675: LD_INT 2
88677: NEG
88678: PUSH
88679: LD_INT 0
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: PUSH
88686: LD_INT 2
88688: NEG
88689: PUSH
88690: LD_INT 1
88692: NEG
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 2
88700: NEG
88701: PUSH
88702: LD_INT 2
88704: NEG
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 2
88712: NEG
88713: PUSH
88714: LD_INT 3
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 2
88724: PUSH
88725: LD_INT 1
88727: NEG
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 3
88735: PUSH
88736: LD_INT 0
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 3
88745: PUSH
88746: LD_INT 1
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 3
88755: PUSH
88756: LD_INT 2
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 3
88765: PUSH
88766: LD_INT 3
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 2
88775: PUSH
88776: LD_INT 3
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 2
88785: NEG
88786: PUSH
88787: LD_INT 1
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 3
88796: NEG
88797: PUSH
88798: LD_INT 0
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 3
88807: NEG
88808: PUSH
88809: LD_INT 1
88811: NEG
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 3
88819: NEG
88820: PUSH
88821: LD_INT 2
88823: NEG
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 3
88831: NEG
88832: PUSH
88833: LD_INT 3
88835: NEG
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88872: LD_ADDR_VAR 0 42
88876: PUSH
88877: LD_INT 0
88879: PUSH
88880: LD_INT 0
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 0
88889: PUSH
88890: LD_INT 1
88892: NEG
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: LD_INT 1
88900: PUSH
88901: LD_INT 0
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 1
88910: PUSH
88911: LD_INT 1
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 0
88920: PUSH
88921: LD_INT 1
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 1
88930: NEG
88931: PUSH
88932: LD_INT 0
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: PUSH
88939: LD_INT 1
88941: NEG
88942: PUSH
88943: LD_INT 1
88945: NEG
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: PUSH
88951: LD_INT 1
88953: NEG
88954: PUSH
88955: LD_INT 2
88957: NEG
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: PUSH
88963: LD_INT 0
88965: PUSH
88966: LD_INT 2
88968: NEG
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PUSH
88974: LD_INT 1
88976: PUSH
88977: LD_INT 1
88979: NEG
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: PUSH
88985: LD_INT 2
88987: PUSH
88988: LD_INT 1
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 2
88997: PUSH
88998: LD_INT 2
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 1
89007: PUSH
89008: LD_INT 2
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 0
89017: PUSH
89018: LD_INT 2
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: LD_INT 1
89027: NEG
89028: PUSH
89029: LD_INT 1
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 2
89038: NEG
89039: PUSH
89040: LD_INT 1
89042: NEG
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: LD_INT 2
89050: NEG
89051: PUSH
89052: LD_INT 2
89054: NEG
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 2
89062: NEG
89063: PUSH
89064: LD_INT 3
89066: NEG
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 1
89074: NEG
89075: PUSH
89076: LD_INT 3
89078: NEG
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 0
89086: PUSH
89087: LD_INT 3
89089: NEG
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 1
89097: PUSH
89098: LD_INT 2
89100: NEG
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 3
89108: PUSH
89109: LD_INT 2
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: PUSH
89116: LD_INT 3
89118: PUSH
89119: LD_INT 3
89121: PUSH
89122: EMPTY
89123: LIST
89124: LIST
89125: PUSH
89126: LD_INT 2
89128: PUSH
89129: LD_INT 3
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: PUSH
89136: LD_INT 1
89138: PUSH
89139: LD_INT 3
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 0
89148: PUSH
89149: LD_INT 3
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 1
89158: NEG
89159: PUSH
89160: LD_INT 2
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: PUSH
89167: LD_INT 3
89169: NEG
89170: PUSH
89171: LD_INT 2
89173: NEG
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 3
89181: NEG
89182: PUSH
89183: LD_INT 3
89185: NEG
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: PUSH
89191: EMPTY
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89222: LD_ADDR_VAR 0 43
89226: PUSH
89227: LD_INT 0
89229: PUSH
89230: LD_INT 0
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: LD_INT 1
89242: NEG
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 1
89250: PUSH
89251: LD_INT 0
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: PUSH
89258: LD_INT 1
89260: PUSH
89261: LD_INT 1
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 0
89270: PUSH
89271: LD_INT 1
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: LD_INT 1
89280: NEG
89281: PUSH
89282: LD_INT 0
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 1
89291: NEG
89292: PUSH
89293: LD_INT 1
89295: NEG
89296: PUSH
89297: EMPTY
89298: LIST
89299: LIST
89300: PUSH
89301: LD_INT 1
89303: NEG
89304: PUSH
89305: LD_INT 2
89307: NEG
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: LD_INT 0
89315: PUSH
89316: LD_INT 2
89318: NEG
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 1
89326: PUSH
89327: LD_INT 1
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 2
89337: PUSH
89338: LD_INT 0
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: LD_INT 2
89347: PUSH
89348: LD_INT 1
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: LD_INT 1
89357: PUSH
89358: LD_INT 2
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: LD_INT 0
89367: PUSH
89368: LD_INT 2
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 1
89377: NEG
89378: PUSH
89379: LD_INT 1
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: LD_INT 2
89388: NEG
89389: PUSH
89390: LD_INT 0
89392: PUSH
89393: EMPTY
89394: LIST
89395: LIST
89396: PUSH
89397: LD_INT 2
89399: NEG
89400: PUSH
89401: LD_INT 1
89403: NEG
89404: PUSH
89405: EMPTY
89406: LIST
89407: LIST
89408: PUSH
89409: LD_INT 1
89411: NEG
89412: PUSH
89413: LD_INT 3
89415: NEG
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PUSH
89421: LD_INT 0
89423: PUSH
89424: LD_INT 3
89426: NEG
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: PUSH
89432: LD_INT 1
89434: PUSH
89435: LD_INT 2
89437: NEG
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PUSH
89443: LD_INT 2
89445: PUSH
89446: LD_INT 1
89448: NEG
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 3
89456: PUSH
89457: LD_INT 0
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 3
89466: PUSH
89467: LD_INT 1
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: PUSH
89474: LD_INT 1
89476: PUSH
89477: LD_INT 3
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: LD_INT 0
89486: PUSH
89487: LD_INT 3
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PUSH
89494: LD_INT 1
89496: NEG
89497: PUSH
89498: LD_INT 2
89500: PUSH
89501: EMPTY
89502: LIST
89503: LIST
89504: PUSH
89505: LD_INT 2
89507: NEG
89508: PUSH
89509: LD_INT 1
89511: PUSH
89512: EMPTY
89513: LIST
89514: LIST
89515: PUSH
89516: LD_INT 3
89518: NEG
89519: PUSH
89520: LD_INT 0
89522: PUSH
89523: EMPTY
89524: LIST
89525: LIST
89526: PUSH
89527: LD_INT 3
89529: NEG
89530: PUSH
89531: LD_INT 1
89533: NEG
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: EMPTY
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89570: LD_ADDR_VAR 0 44
89574: PUSH
89575: LD_INT 0
89577: PUSH
89578: LD_INT 0
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: PUSH
89585: LD_INT 0
89587: PUSH
89588: LD_INT 1
89590: NEG
89591: PUSH
89592: EMPTY
89593: LIST
89594: LIST
89595: PUSH
89596: LD_INT 1
89598: PUSH
89599: LD_INT 0
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 1
89608: PUSH
89609: LD_INT 1
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 0
89618: PUSH
89619: LD_INT 1
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 1
89628: NEG
89629: PUSH
89630: LD_INT 0
89632: PUSH
89633: EMPTY
89634: LIST
89635: LIST
89636: PUSH
89637: LD_INT 1
89639: NEG
89640: PUSH
89641: LD_INT 1
89643: NEG
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: LD_INT 1
89651: NEG
89652: PUSH
89653: LD_INT 2
89655: NEG
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 1
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 2
89674: PUSH
89675: LD_INT 0
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: PUSH
89682: LD_INT 2
89684: PUSH
89685: LD_INT 1
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: PUSH
89692: LD_INT 2
89694: PUSH
89695: LD_INT 2
89697: PUSH
89698: EMPTY
89699: LIST
89700: LIST
89701: PUSH
89702: LD_INT 1
89704: PUSH
89705: LD_INT 2
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: LD_INT 1
89714: NEG
89715: PUSH
89716: LD_INT 1
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: LD_INT 2
89725: NEG
89726: PUSH
89727: LD_INT 0
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: LD_INT 2
89736: NEG
89737: PUSH
89738: LD_INT 1
89740: NEG
89741: PUSH
89742: EMPTY
89743: LIST
89744: LIST
89745: PUSH
89746: LD_INT 2
89748: NEG
89749: PUSH
89750: LD_INT 2
89752: NEG
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 2
89760: NEG
89761: PUSH
89762: LD_INT 3
89764: NEG
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 2
89772: PUSH
89773: LD_INT 1
89775: NEG
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: PUSH
89781: LD_INT 3
89783: PUSH
89784: LD_INT 0
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 3
89793: PUSH
89794: LD_INT 1
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 3
89803: PUSH
89804: LD_INT 2
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 3
89813: PUSH
89814: LD_INT 3
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 2
89823: PUSH
89824: LD_INT 3
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 2
89833: NEG
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 3
89844: NEG
89845: PUSH
89846: LD_INT 0
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 3
89855: NEG
89856: PUSH
89857: LD_INT 1
89859: NEG
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 3
89867: NEG
89868: PUSH
89869: LD_INT 2
89871: NEG
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 3
89879: NEG
89880: PUSH
89881: LD_INT 3
89883: NEG
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89920: LD_ADDR_VAR 0 45
89924: PUSH
89925: LD_INT 0
89927: PUSH
89928: LD_INT 0
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 0
89937: PUSH
89938: LD_INT 1
89940: NEG
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: LD_INT 1
89948: PUSH
89949: LD_INT 0
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 1
89958: PUSH
89959: LD_INT 1
89961: PUSH
89962: EMPTY
89963: LIST
89964: LIST
89965: PUSH
89966: LD_INT 0
89968: PUSH
89969: LD_INT 1
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 1
89978: NEG
89979: PUSH
89980: LD_INT 0
89982: PUSH
89983: EMPTY
89984: LIST
89985: LIST
89986: PUSH
89987: LD_INT 1
89989: NEG
89990: PUSH
89991: LD_INT 1
89993: NEG
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: LD_INT 1
90001: NEG
90002: PUSH
90003: LD_INT 2
90005: NEG
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: LD_INT 0
90013: PUSH
90014: LD_INT 2
90016: NEG
90017: PUSH
90018: EMPTY
90019: LIST
90020: LIST
90021: PUSH
90022: LD_INT 1
90024: PUSH
90025: LD_INT 1
90027: NEG
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 2
90035: PUSH
90036: LD_INT 1
90038: PUSH
90039: EMPTY
90040: LIST
90041: LIST
90042: PUSH
90043: LD_INT 2
90045: PUSH
90046: LD_INT 2
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: LD_INT 1
90055: PUSH
90056: LD_INT 2
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: PUSH
90063: LD_INT 0
90065: PUSH
90066: LD_INT 2
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: PUSH
90073: LD_INT 1
90075: NEG
90076: PUSH
90077: LD_INT 1
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PUSH
90084: LD_INT 2
90086: NEG
90087: PUSH
90088: LD_INT 1
90090: NEG
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: LD_INT 2
90098: NEG
90099: PUSH
90100: LD_INT 2
90102: NEG
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: PUSH
90108: LD_INT 2
90110: NEG
90111: PUSH
90112: LD_INT 3
90114: NEG
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 1
90122: NEG
90123: PUSH
90124: LD_INT 3
90126: NEG
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 0
90134: PUSH
90135: LD_INT 3
90137: NEG
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 1
90145: PUSH
90146: LD_INT 2
90148: NEG
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: LD_INT 3
90156: PUSH
90157: LD_INT 2
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 3
90166: PUSH
90167: LD_INT 3
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: PUSH
90174: LD_INT 2
90176: PUSH
90177: LD_INT 3
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 1
90186: PUSH
90187: LD_INT 3
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 0
90196: PUSH
90197: LD_INT 3
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 1
90206: NEG
90207: PUSH
90208: LD_INT 2
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: LD_INT 3
90217: NEG
90218: PUSH
90219: LD_INT 2
90221: NEG
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: PUSH
90227: LD_INT 3
90229: NEG
90230: PUSH
90231: LD_INT 3
90233: NEG
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90270: LD_ADDR_VAR 0 46
90274: PUSH
90275: LD_INT 0
90277: PUSH
90278: LD_INT 0
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 0
90287: PUSH
90288: LD_INT 1
90290: NEG
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 1
90298: PUSH
90299: LD_INT 0
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 1
90308: PUSH
90309: LD_INT 1
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 0
90318: PUSH
90319: LD_INT 1
90321: PUSH
90322: EMPTY
90323: LIST
90324: LIST
90325: PUSH
90326: LD_INT 1
90328: NEG
90329: PUSH
90330: LD_INT 0
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 1
90339: NEG
90340: PUSH
90341: LD_INT 1
90343: NEG
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: PUSH
90349: LD_INT 1
90351: NEG
90352: PUSH
90353: LD_INT 2
90355: NEG
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 0
90363: PUSH
90364: LD_INT 2
90366: NEG
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 1
90374: PUSH
90375: LD_INT 1
90377: NEG
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 2
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 2
90395: PUSH
90396: LD_INT 1
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: PUSH
90403: LD_INT 1
90405: PUSH
90406: LD_INT 2
90408: PUSH
90409: EMPTY
90410: LIST
90411: LIST
90412: PUSH
90413: LD_INT 0
90415: PUSH
90416: LD_INT 2
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: LD_INT 1
90425: NEG
90426: PUSH
90427: LD_INT 1
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 2
90436: NEG
90437: PUSH
90438: LD_INT 0
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 2
90447: NEG
90448: PUSH
90449: LD_INT 1
90451: NEG
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: LD_INT 1
90459: NEG
90460: PUSH
90461: LD_INT 3
90463: NEG
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 0
90471: PUSH
90472: LD_INT 3
90474: NEG
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 1
90482: PUSH
90483: LD_INT 2
90485: NEG
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: LD_INT 2
90493: PUSH
90494: LD_INT 1
90496: NEG
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 3
90504: PUSH
90505: LD_INT 0
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 3
90514: PUSH
90515: LD_INT 1
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: LD_INT 1
90524: PUSH
90525: LD_INT 3
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: LD_INT 0
90534: PUSH
90535: LD_INT 3
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 1
90544: NEG
90545: PUSH
90546: LD_INT 2
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 2
90555: NEG
90556: PUSH
90557: LD_INT 1
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 3
90566: NEG
90567: PUSH
90568: LD_INT 0
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: LD_INT 3
90577: NEG
90578: PUSH
90579: LD_INT 1
90581: NEG
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90618: LD_ADDR_VAR 0 47
90622: PUSH
90623: LD_INT 0
90625: PUSH
90626: LD_INT 0
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: PUSH
90633: LD_INT 0
90635: PUSH
90636: LD_INT 1
90638: NEG
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: PUSH
90644: LD_INT 1
90646: PUSH
90647: LD_INT 0
90649: PUSH
90650: EMPTY
90651: LIST
90652: LIST
90653: PUSH
90654: LD_INT 1
90656: PUSH
90657: LD_INT 1
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: LD_INT 1
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 1
90676: NEG
90677: PUSH
90678: LD_INT 0
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 1
90687: NEG
90688: PUSH
90689: LD_INT 1
90691: NEG
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: LD_INT 2
90703: NEG
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 0
90711: PUSH
90712: LD_INT 2
90714: NEG
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: PUSH
90723: LD_INT 1
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 2
90733: NEG
90734: PUSH
90735: LD_INT 1
90737: NEG
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 2
90745: NEG
90746: PUSH
90747: LD_INT 2
90749: NEG
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90769: LD_ADDR_VAR 0 48
90773: PUSH
90774: LD_INT 0
90776: PUSH
90777: LD_INT 0
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 0
90786: PUSH
90787: LD_INT 1
90789: NEG
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: PUSH
90795: LD_INT 1
90797: PUSH
90798: LD_INT 0
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: PUSH
90805: LD_INT 1
90807: PUSH
90808: LD_INT 1
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 0
90817: PUSH
90818: LD_INT 1
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 1
90827: NEG
90828: PUSH
90829: LD_INT 0
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 1
90838: NEG
90839: PUSH
90840: LD_INT 1
90842: NEG
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 1
90850: NEG
90851: PUSH
90852: LD_INT 2
90854: NEG
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 0
90862: PUSH
90863: LD_INT 2
90865: NEG
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 1
90873: PUSH
90874: LD_INT 1
90876: NEG
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 2
90884: PUSH
90885: LD_INT 0
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 2
90894: PUSH
90895: LD_INT 1
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90916: LD_ADDR_VAR 0 49
90920: PUSH
90921: LD_INT 0
90923: PUSH
90924: LD_INT 0
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: LD_INT 0
90933: PUSH
90934: LD_INT 1
90936: NEG
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 1
90944: PUSH
90945: LD_INT 0
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 1
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 0
90964: PUSH
90965: LD_INT 1
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: LD_INT 1
90974: NEG
90975: PUSH
90976: LD_INT 0
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: LD_INT 1
90985: NEG
90986: PUSH
90987: LD_INT 1
90989: NEG
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: PUSH
90995: LD_INT 1
90997: PUSH
90998: LD_INT 1
91000: NEG
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 2
91008: PUSH
91009: LD_INT 0
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: PUSH
91016: LD_INT 2
91018: PUSH
91019: LD_INT 1
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 2
91028: PUSH
91029: LD_INT 2
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 1
91038: PUSH
91039: LD_INT 2
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91060: LD_ADDR_VAR 0 50
91064: PUSH
91065: LD_INT 0
91067: PUSH
91068: LD_INT 0
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: PUSH
91075: LD_INT 0
91077: PUSH
91078: LD_INT 1
91080: NEG
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 1
91088: PUSH
91089: LD_INT 0
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 1
91098: PUSH
91099: LD_INT 1
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: LD_INT 0
91108: PUSH
91109: LD_INT 1
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 1
91118: NEG
91119: PUSH
91120: LD_INT 0
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: LD_INT 1
91133: NEG
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: PUSH
91139: LD_INT 2
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: LD_INT 2
91151: PUSH
91152: LD_INT 2
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: LD_INT 1
91161: PUSH
91162: LD_INT 2
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: LD_INT 2
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: PUSH
91179: LD_INT 1
91181: NEG
91182: PUSH
91183: LD_INT 1
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: EMPTY
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91204: LD_ADDR_VAR 0 51
91208: PUSH
91209: LD_INT 0
91211: PUSH
91212: LD_INT 0
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: LD_INT 0
91221: PUSH
91222: LD_INT 1
91224: NEG
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 1
91232: PUSH
91233: LD_INT 0
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 1
91242: PUSH
91243: LD_INT 1
91245: PUSH
91246: EMPTY
91247: LIST
91248: LIST
91249: PUSH
91250: LD_INT 0
91252: PUSH
91253: LD_INT 1
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 1
91262: NEG
91263: PUSH
91264: LD_INT 0
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PUSH
91271: LD_INT 1
91273: NEG
91274: PUSH
91275: LD_INT 1
91277: NEG
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: LD_INT 1
91285: PUSH
91286: LD_INT 2
91288: PUSH
91289: EMPTY
91290: LIST
91291: LIST
91292: PUSH
91293: LD_INT 0
91295: PUSH
91296: LD_INT 2
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: LD_INT 1
91305: NEG
91306: PUSH
91307: LD_INT 1
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 2
91316: NEG
91317: PUSH
91318: LD_INT 0
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: LD_INT 2
91327: NEG
91328: PUSH
91329: LD_INT 1
91331: NEG
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91351: LD_ADDR_VAR 0 52
91355: PUSH
91356: LD_INT 0
91358: PUSH
91359: LD_INT 0
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: LD_INT 0
91368: PUSH
91369: LD_INT 1
91371: NEG
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 1
91379: PUSH
91380: LD_INT 0
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: LD_INT 1
91389: PUSH
91390: LD_INT 1
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 0
91399: PUSH
91400: LD_INT 1
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: PUSH
91407: LD_INT 1
91409: NEG
91410: PUSH
91411: LD_INT 0
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 1
91420: NEG
91421: PUSH
91422: LD_INT 1
91424: NEG
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: PUSH
91430: LD_INT 1
91432: NEG
91433: PUSH
91434: LD_INT 2
91436: NEG
91437: PUSH
91438: EMPTY
91439: LIST
91440: LIST
91441: PUSH
91442: LD_INT 1
91444: NEG
91445: PUSH
91446: LD_INT 1
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: PUSH
91453: LD_INT 2
91455: NEG
91456: PUSH
91457: LD_INT 0
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 2
91466: NEG
91467: PUSH
91468: LD_INT 1
91470: NEG
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 2
91478: NEG
91479: PUSH
91480: LD_INT 2
91482: NEG
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91502: LD_ADDR_VAR 0 53
91506: PUSH
91507: LD_INT 0
91509: PUSH
91510: LD_INT 0
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: LD_INT 0
91519: PUSH
91520: LD_INT 1
91522: NEG
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 1
91530: PUSH
91531: LD_INT 0
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: PUSH
91538: LD_INT 1
91540: PUSH
91541: LD_INT 1
91543: PUSH
91544: EMPTY
91545: LIST
91546: LIST
91547: PUSH
91548: LD_INT 0
91550: PUSH
91551: LD_INT 1
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: PUSH
91558: LD_INT 1
91560: NEG
91561: PUSH
91562: LD_INT 0
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: LD_INT 1
91571: NEG
91572: PUSH
91573: LD_INT 1
91575: NEG
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 1
91583: NEG
91584: PUSH
91585: LD_INT 2
91587: NEG
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 0
91595: PUSH
91596: LD_INT 2
91598: NEG
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 1
91606: PUSH
91607: LD_INT 1
91609: NEG
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: PUSH
91615: LD_INT 2
91617: PUSH
91618: LD_INT 0
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: PUSH
91625: LD_INT 2
91627: PUSH
91628: LD_INT 1
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PUSH
91635: LD_INT 2
91637: PUSH
91638: LD_INT 2
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: LD_INT 1
91647: PUSH
91648: LD_INT 2
91650: PUSH
91651: EMPTY
91652: LIST
91653: LIST
91654: PUSH
91655: LD_INT 0
91657: PUSH
91658: LD_INT 2
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: PUSH
91665: LD_INT 1
91667: NEG
91668: PUSH
91669: LD_INT 1
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 2
91678: NEG
91679: PUSH
91680: LD_INT 0
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: LD_INT 2
91689: NEG
91690: PUSH
91691: LD_INT 1
91693: NEG
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: PUSH
91699: LD_INT 2
91701: NEG
91702: PUSH
91703: LD_INT 2
91705: NEG
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: PUSH
91711: EMPTY
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91732: LD_ADDR_VAR 0 54
91736: PUSH
91737: LD_INT 0
91739: PUSH
91740: LD_INT 0
91742: PUSH
91743: EMPTY
91744: LIST
91745: LIST
91746: PUSH
91747: LD_INT 0
91749: PUSH
91750: LD_INT 1
91752: NEG
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: LD_INT 1
91760: PUSH
91761: LD_INT 0
91763: PUSH
91764: EMPTY
91765: LIST
91766: LIST
91767: PUSH
91768: LD_INT 1
91770: PUSH
91771: LD_INT 1
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 0
91780: PUSH
91781: LD_INT 1
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 1
91790: NEG
91791: PUSH
91792: LD_INT 0
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 1
91801: NEG
91802: PUSH
91803: LD_INT 1
91805: NEG
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: LD_INT 1
91813: NEG
91814: PUSH
91815: LD_INT 2
91817: NEG
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 0
91825: PUSH
91826: LD_INT 2
91828: NEG
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: LD_INT 1
91836: PUSH
91837: LD_INT 1
91839: NEG
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 2
91847: PUSH
91848: LD_INT 0
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: PUSH
91855: LD_INT 2
91857: PUSH
91858: LD_INT 1
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: LD_INT 2
91867: PUSH
91868: LD_INT 2
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: PUSH
91875: LD_INT 1
91877: PUSH
91878: LD_INT 2
91880: PUSH
91881: EMPTY
91882: LIST
91883: LIST
91884: PUSH
91885: LD_INT 0
91887: PUSH
91888: LD_INT 2
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: PUSH
91895: LD_INT 1
91897: NEG
91898: PUSH
91899: LD_INT 1
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: PUSH
91906: LD_INT 2
91908: NEG
91909: PUSH
91910: LD_INT 0
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: PUSH
91917: LD_INT 2
91919: NEG
91920: PUSH
91921: LD_INT 1
91923: NEG
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: LD_INT 2
91931: NEG
91932: PUSH
91933: LD_INT 2
91935: NEG
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: LIST
91952: LIST
91953: LIST
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91962: LD_ADDR_VAR 0 55
91966: PUSH
91967: LD_INT 0
91969: PUSH
91970: LD_INT 0
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: PUSH
91977: LD_INT 0
91979: PUSH
91980: LD_INT 1
91982: NEG
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: PUSH
91988: LD_INT 1
91990: PUSH
91991: LD_INT 0
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: PUSH
91998: LD_INT 1
92000: PUSH
92001: LD_INT 1
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: LD_INT 0
92010: PUSH
92011: LD_INT 1
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 1
92020: NEG
92021: PUSH
92022: LD_INT 0
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PUSH
92029: LD_INT 1
92031: NEG
92032: PUSH
92033: LD_INT 1
92035: NEG
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 1
92043: NEG
92044: PUSH
92045: LD_INT 2
92047: NEG
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: PUSH
92053: LD_INT 0
92055: PUSH
92056: LD_INT 2
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 1
92066: PUSH
92067: LD_INT 1
92069: NEG
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 2
92077: PUSH
92078: LD_INT 0
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 2
92087: PUSH
92088: LD_INT 1
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: PUSH
92095: LD_INT 2
92097: PUSH
92098: LD_INT 2
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: PUSH
92105: LD_INT 1
92107: PUSH
92108: LD_INT 2
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: LD_INT 0
92117: PUSH
92118: LD_INT 2
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: LD_INT 1
92127: NEG
92128: PUSH
92129: LD_INT 1
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: PUSH
92136: LD_INT 2
92138: NEG
92139: PUSH
92140: LD_INT 0
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 2
92149: NEG
92150: PUSH
92151: LD_INT 1
92153: NEG
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 2
92161: NEG
92162: PUSH
92163: LD_INT 2
92165: NEG
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92192: LD_ADDR_VAR 0 56
92196: PUSH
92197: LD_INT 0
92199: PUSH
92200: LD_INT 0
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: LD_INT 0
92209: PUSH
92210: LD_INT 1
92212: NEG
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 1
92220: PUSH
92221: LD_INT 0
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: PUSH
92228: LD_INT 1
92230: PUSH
92231: LD_INT 1
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PUSH
92238: LD_INT 0
92240: PUSH
92241: LD_INT 1
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: PUSH
92248: LD_INT 1
92250: NEG
92251: PUSH
92252: LD_INT 0
92254: PUSH
92255: EMPTY
92256: LIST
92257: LIST
92258: PUSH
92259: LD_INT 1
92261: NEG
92262: PUSH
92263: LD_INT 1
92265: NEG
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: LD_INT 1
92273: NEG
92274: PUSH
92275: LD_INT 2
92277: NEG
92278: PUSH
92279: EMPTY
92280: LIST
92281: LIST
92282: PUSH
92283: LD_INT 0
92285: PUSH
92286: LD_INT 2
92288: NEG
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 1
92296: PUSH
92297: LD_INT 1
92299: NEG
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: PUSH
92305: LD_INT 2
92307: PUSH
92308: LD_INT 0
92310: PUSH
92311: EMPTY
92312: LIST
92313: LIST
92314: PUSH
92315: LD_INT 2
92317: PUSH
92318: LD_INT 1
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: PUSH
92325: LD_INT 2
92327: PUSH
92328: LD_INT 2
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: PUSH
92335: LD_INT 1
92337: PUSH
92338: LD_INT 2
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 0
92347: PUSH
92348: LD_INT 2
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: LD_INT 1
92357: NEG
92358: PUSH
92359: LD_INT 1
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: PUSH
92366: LD_INT 2
92368: NEG
92369: PUSH
92370: LD_INT 0
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: LD_INT 2
92379: NEG
92380: PUSH
92381: LD_INT 1
92383: NEG
92384: PUSH
92385: EMPTY
92386: LIST
92387: LIST
92388: PUSH
92389: LD_INT 2
92391: NEG
92392: PUSH
92393: LD_INT 2
92395: NEG
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92422: LD_ADDR_VAR 0 57
92426: PUSH
92427: LD_INT 0
92429: PUSH
92430: LD_INT 0
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: LD_INT 0
92439: PUSH
92440: LD_INT 1
92442: NEG
92443: PUSH
92444: EMPTY
92445: LIST
92446: LIST
92447: PUSH
92448: LD_INT 1
92450: PUSH
92451: LD_INT 0
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 1
92460: PUSH
92461: LD_INT 1
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: PUSH
92468: LD_INT 0
92470: PUSH
92471: LD_INT 1
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: LD_INT 1
92480: NEG
92481: PUSH
92482: LD_INT 0
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 1
92491: NEG
92492: PUSH
92493: LD_INT 1
92495: NEG
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: LD_INT 1
92503: NEG
92504: PUSH
92505: LD_INT 2
92507: NEG
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: PUSH
92513: LD_INT 0
92515: PUSH
92516: LD_INT 2
92518: NEG
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 1
92526: PUSH
92527: LD_INT 1
92529: NEG
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 2
92537: PUSH
92538: LD_INT 0
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 2
92547: PUSH
92548: LD_INT 1
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: LD_INT 2
92557: PUSH
92558: LD_INT 2
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PUSH
92565: LD_INT 1
92567: PUSH
92568: LD_INT 2
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 0
92577: PUSH
92578: LD_INT 2
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: PUSH
92585: LD_INT 1
92587: NEG
92588: PUSH
92589: LD_INT 1
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PUSH
92596: LD_INT 2
92598: NEG
92599: PUSH
92600: LD_INT 0
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 2
92609: NEG
92610: PUSH
92611: LD_INT 1
92613: NEG
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 2
92621: NEG
92622: PUSH
92623: LD_INT 2
92625: NEG
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92652: LD_ADDR_VAR 0 58
92656: PUSH
92657: LD_INT 0
92659: PUSH
92660: LD_INT 0
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 0
92669: PUSH
92670: LD_INT 1
92672: NEG
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: PUSH
92678: LD_INT 1
92680: PUSH
92681: LD_INT 0
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 1
92690: PUSH
92691: LD_INT 1
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 0
92700: PUSH
92701: LD_INT 1
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: LD_INT 1
92710: NEG
92711: PUSH
92712: LD_INT 0
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PUSH
92719: LD_INT 1
92721: NEG
92722: PUSH
92723: LD_INT 1
92725: NEG
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 1
92733: NEG
92734: PUSH
92735: LD_INT 2
92737: NEG
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: LD_INT 0
92745: PUSH
92746: LD_INT 2
92748: NEG
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 1
92756: PUSH
92757: LD_INT 1
92759: NEG
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 2
92767: PUSH
92768: LD_INT 0
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PUSH
92775: LD_INT 2
92777: PUSH
92778: LD_INT 1
92780: PUSH
92781: EMPTY
92782: LIST
92783: LIST
92784: PUSH
92785: LD_INT 2
92787: PUSH
92788: LD_INT 2
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: PUSH
92795: LD_INT 1
92797: PUSH
92798: LD_INT 2
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 0
92807: PUSH
92808: LD_INT 2
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: LD_INT 1
92817: NEG
92818: PUSH
92819: LD_INT 1
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: LD_INT 2
92828: NEG
92829: PUSH
92830: LD_INT 0
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 2
92839: NEG
92840: PUSH
92841: LD_INT 1
92843: NEG
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 2
92851: NEG
92852: PUSH
92853: LD_INT 2
92855: NEG
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92882: LD_ADDR_VAR 0 59
92886: PUSH
92887: LD_INT 0
92889: PUSH
92890: LD_INT 0
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 0
92899: PUSH
92900: LD_INT 1
92902: NEG
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 1
92910: PUSH
92911: LD_INT 0
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 1
92920: PUSH
92921: LD_INT 1
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: LD_INT 0
92930: PUSH
92931: LD_INT 1
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: PUSH
92938: LD_INT 1
92940: NEG
92941: PUSH
92942: LD_INT 0
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 1
92951: NEG
92952: PUSH
92953: LD_INT 1
92955: NEG
92956: PUSH
92957: EMPTY
92958: LIST
92959: LIST
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92970: LD_ADDR_VAR 0 60
92974: PUSH
92975: LD_INT 0
92977: PUSH
92978: LD_INT 0
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 0
92987: PUSH
92988: LD_INT 1
92990: NEG
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: PUSH
92996: LD_INT 1
92998: PUSH
92999: LD_INT 0
93001: PUSH
93002: EMPTY
93003: LIST
93004: LIST
93005: PUSH
93006: LD_INT 1
93008: PUSH
93009: LD_INT 1
93011: PUSH
93012: EMPTY
93013: LIST
93014: LIST
93015: PUSH
93016: LD_INT 0
93018: PUSH
93019: LD_INT 1
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PUSH
93026: LD_INT 1
93028: NEG
93029: PUSH
93030: LD_INT 0
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: LD_INT 1
93039: NEG
93040: PUSH
93041: LD_INT 1
93043: NEG
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93058: LD_ADDR_VAR 0 61
93062: PUSH
93063: LD_INT 0
93065: PUSH
93066: LD_INT 0
93068: PUSH
93069: EMPTY
93070: LIST
93071: LIST
93072: PUSH
93073: LD_INT 0
93075: PUSH
93076: LD_INT 1
93078: NEG
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: LD_INT 1
93086: PUSH
93087: LD_INT 0
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 1
93096: PUSH
93097: LD_INT 1
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PUSH
93104: LD_INT 0
93106: PUSH
93107: LD_INT 1
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: LD_INT 1
93116: NEG
93117: PUSH
93118: LD_INT 0
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 1
93127: NEG
93128: PUSH
93129: LD_INT 1
93131: NEG
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93146: LD_ADDR_VAR 0 62
93150: PUSH
93151: LD_INT 0
93153: PUSH
93154: LD_INT 0
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 0
93163: PUSH
93164: LD_INT 1
93166: NEG
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PUSH
93172: LD_INT 1
93174: PUSH
93175: LD_INT 0
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 1
93184: PUSH
93185: LD_INT 1
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: PUSH
93192: LD_INT 0
93194: PUSH
93195: LD_INT 1
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 1
93204: NEG
93205: PUSH
93206: LD_INT 0
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: PUSH
93213: LD_INT 1
93215: NEG
93216: PUSH
93217: LD_INT 1
93219: NEG
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93234: LD_ADDR_VAR 0 63
93238: PUSH
93239: LD_INT 0
93241: PUSH
93242: LD_INT 0
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: LD_INT 0
93251: PUSH
93252: LD_INT 1
93254: NEG
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 1
93262: PUSH
93263: LD_INT 0
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 1
93272: PUSH
93273: LD_INT 1
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: LD_INT 0
93282: PUSH
93283: LD_INT 1
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 1
93292: NEG
93293: PUSH
93294: LD_INT 0
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 1
93303: NEG
93304: PUSH
93305: LD_INT 1
93307: NEG
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93322: LD_ADDR_VAR 0 64
93326: PUSH
93327: LD_INT 0
93329: PUSH
93330: LD_INT 0
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 0
93339: PUSH
93340: LD_INT 1
93342: NEG
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: LD_INT 1
93350: PUSH
93351: LD_INT 0
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 1
93360: PUSH
93361: LD_INT 1
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 0
93370: PUSH
93371: LD_INT 1
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 1
93380: NEG
93381: PUSH
93382: LD_INT 0
93384: PUSH
93385: EMPTY
93386: LIST
93387: LIST
93388: PUSH
93389: LD_INT 1
93391: NEG
93392: PUSH
93393: LD_INT 1
93395: NEG
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: ST_TO_ADDR
// end ; 1 :
93410: GO 99307
93412: LD_INT 1
93414: DOUBLE
93415: EQUAL
93416: IFTRUE 93420
93418: GO 96043
93420: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93421: LD_ADDR_VAR 0 11
93425: PUSH
93426: LD_INT 1
93428: NEG
93429: PUSH
93430: LD_INT 3
93432: NEG
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: PUSH
93438: LD_INT 0
93440: PUSH
93441: LD_INT 3
93443: NEG
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: LD_INT 1
93451: PUSH
93452: LD_INT 2
93454: NEG
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: LIST
93464: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93465: LD_ADDR_VAR 0 12
93469: PUSH
93470: LD_INT 2
93472: PUSH
93473: LD_INT 1
93475: NEG
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 3
93483: PUSH
93484: LD_INT 0
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 3
93493: PUSH
93494: LD_INT 1
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: LIST
93505: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93506: LD_ADDR_VAR 0 13
93510: PUSH
93511: LD_INT 3
93513: PUSH
93514: LD_INT 2
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: PUSH
93521: LD_INT 3
93523: PUSH
93524: LD_INT 3
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 2
93533: PUSH
93534: LD_INT 3
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: LIST
93545: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93546: LD_ADDR_VAR 0 14
93550: PUSH
93551: LD_INT 1
93553: PUSH
93554: LD_INT 3
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: PUSH
93561: LD_INT 0
93563: PUSH
93564: LD_INT 3
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PUSH
93571: LD_INT 1
93573: NEG
93574: PUSH
93575: LD_INT 2
93577: PUSH
93578: EMPTY
93579: LIST
93580: LIST
93581: PUSH
93582: EMPTY
93583: LIST
93584: LIST
93585: LIST
93586: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93587: LD_ADDR_VAR 0 15
93591: PUSH
93592: LD_INT 2
93594: NEG
93595: PUSH
93596: LD_INT 1
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: PUSH
93603: LD_INT 3
93605: NEG
93606: PUSH
93607: LD_INT 0
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: LD_INT 3
93616: NEG
93617: PUSH
93618: LD_INT 1
93620: NEG
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: LIST
93630: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93631: LD_ADDR_VAR 0 16
93635: PUSH
93636: LD_INT 2
93638: NEG
93639: PUSH
93640: LD_INT 3
93642: NEG
93643: PUSH
93644: EMPTY
93645: LIST
93646: LIST
93647: PUSH
93648: LD_INT 3
93650: NEG
93651: PUSH
93652: LD_INT 2
93654: NEG
93655: PUSH
93656: EMPTY
93657: LIST
93658: LIST
93659: PUSH
93660: LD_INT 3
93662: NEG
93663: PUSH
93664: LD_INT 3
93666: NEG
93667: PUSH
93668: EMPTY
93669: LIST
93670: LIST
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: LIST
93676: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93677: LD_ADDR_VAR 0 17
93681: PUSH
93682: LD_INT 1
93684: NEG
93685: PUSH
93686: LD_INT 3
93688: NEG
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 0
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: EMPTY
93702: LIST
93703: LIST
93704: PUSH
93705: LD_INT 1
93707: PUSH
93708: LD_INT 2
93710: NEG
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: LIST
93720: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93721: LD_ADDR_VAR 0 18
93725: PUSH
93726: LD_INT 2
93728: PUSH
93729: LD_INT 1
93731: NEG
93732: PUSH
93733: EMPTY
93734: LIST
93735: LIST
93736: PUSH
93737: LD_INT 3
93739: PUSH
93740: LD_INT 0
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 3
93749: PUSH
93750: LD_INT 1
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: LIST
93761: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93762: LD_ADDR_VAR 0 19
93766: PUSH
93767: LD_INT 3
93769: PUSH
93770: LD_INT 2
93772: PUSH
93773: EMPTY
93774: LIST
93775: LIST
93776: PUSH
93777: LD_INT 3
93779: PUSH
93780: LD_INT 3
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 2
93789: PUSH
93790: LD_INT 3
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: LIST
93801: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93802: LD_ADDR_VAR 0 20
93806: PUSH
93807: LD_INT 1
93809: PUSH
93810: LD_INT 3
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 0
93819: PUSH
93820: LD_INT 3
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 1
93829: NEG
93830: PUSH
93831: LD_INT 2
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: LIST
93842: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93843: LD_ADDR_VAR 0 21
93847: PUSH
93848: LD_INT 2
93850: NEG
93851: PUSH
93852: LD_INT 1
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 3
93861: NEG
93862: PUSH
93863: LD_INT 0
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 3
93872: NEG
93873: PUSH
93874: LD_INT 1
93876: NEG
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: LIST
93886: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93887: LD_ADDR_VAR 0 22
93891: PUSH
93892: LD_INT 2
93894: NEG
93895: PUSH
93896: LD_INT 3
93898: NEG
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 3
93906: NEG
93907: PUSH
93908: LD_INT 2
93910: NEG
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 3
93918: NEG
93919: PUSH
93920: LD_INT 3
93922: NEG
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: LIST
93932: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
93933: LD_ADDR_VAR 0 23
93937: PUSH
93938: LD_INT 0
93940: PUSH
93941: LD_INT 3
93943: NEG
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: PUSH
93949: LD_INT 1
93951: NEG
93952: PUSH
93953: LD_INT 4
93955: NEG
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: PUSH
93961: LD_INT 1
93963: PUSH
93964: LD_INT 3
93966: NEG
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: LIST
93976: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
93977: LD_ADDR_VAR 0 24
93981: PUSH
93982: LD_INT 3
93984: PUSH
93985: LD_INT 0
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PUSH
93992: LD_INT 3
93994: PUSH
93995: LD_INT 1
93997: NEG
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: PUSH
94003: LD_INT 4
94005: PUSH
94006: LD_INT 1
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: LIST
94017: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
94018: LD_ADDR_VAR 0 25
94022: PUSH
94023: LD_INT 3
94025: PUSH
94026: LD_INT 3
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 4
94035: PUSH
94036: LD_INT 3
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 3
94045: PUSH
94046: LD_INT 4
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: LIST
94057: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
94058: LD_ADDR_VAR 0 26
94062: PUSH
94063: LD_INT 0
94065: PUSH
94066: LD_INT 3
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: PUSH
94073: LD_INT 1
94075: PUSH
94076: LD_INT 4
94078: PUSH
94079: EMPTY
94080: LIST
94081: LIST
94082: PUSH
94083: LD_INT 1
94085: NEG
94086: PUSH
94087: LD_INT 3
94089: PUSH
94090: EMPTY
94091: LIST
94092: LIST
94093: PUSH
94094: EMPTY
94095: LIST
94096: LIST
94097: LIST
94098: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
94099: LD_ADDR_VAR 0 27
94103: PUSH
94104: LD_INT 3
94106: NEG
94107: PUSH
94108: LD_INT 0
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 3
94117: NEG
94118: PUSH
94119: LD_INT 1
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 4
94128: NEG
94129: PUSH
94130: LD_INT 1
94132: NEG
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: LIST
94142: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
94143: LD_ADDR_VAR 0 28
94147: PUSH
94148: LD_INT 3
94150: NEG
94151: PUSH
94152: LD_INT 3
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 3
94162: NEG
94163: PUSH
94164: LD_INT 4
94166: NEG
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 4
94174: NEG
94175: PUSH
94176: LD_INT 3
94178: NEG
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: LIST
94188: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
94189: LD_ADDR_VAR 0 29
94193: PUSH
94194: LD_INT 1
94196: NEG
94197: PUSH
94198: LD_INT 3
94200: NEG
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: PUSH
94206: LD_INT 0
94208: PUSH
94209: LD_INT 3
94211: NEG
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PUSH
94217: LD_INT 1
94219: PUSH
94220: LD_INT 2
94222: NEG
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 1
94230: NEG
94231: PUSH
94232: LD_INT 4
94234: NEG
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: PUSH
94240: LD_INT 0
94242: PUSH
94243: LD_INT 4
94245: NEG
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 1
94253: PUSH
94254: LD_INT 3
94256: NEG
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 1
94264: NEG
94265: PUSH
94266: LD_INT 5
94268: NEG
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 0
94276: PUSH
94277: LD_INT 5
94279: NEG
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 1
94287: PUSH
94288: LD_INT 4
94290: NEG
94291: PUSH
94292: EMPTY
94293: LIST
94294: LIST
94295: PUSH
94296: LD_INT 1
94298: NEG
94299: PUSH
94300: LD_INT 6
94302: NEG
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PUSH
94308: LD_INT 0
94310: PUSH
94311: LD_INT 6
94313: NEG
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 1
94321: PUSH
94322: LD_INT 5
94324: NEG
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94344: LD_ADDR_VAR 0 30
94348: PUSH
94349: LD_INT 2
94351: PUSH
94352: LD_INT 1
94354: NEG
94355: PUSH
94356: EMPTY
94357: LIST
94358: LIST
94359: PUSH
94360: LD_INT 3
94362: PUSH
94363: LD_INT 0
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: PUSH
94370: LD_INT 3
94372: PUSH
94373: LD_INT 1
94375: PUSH
94376: EMPTY
94377: LIST
94378: LIST
94379: PUSH
94380: LD_INT 3
94382: PUSH
94383: LD_INT 1
94385: NEG
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 4
94393: PUSH
94394: LD_INT 0
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 4
94403: PUSH
94404: LD_INT 1
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 4
94413: PUSH
94414: LD_INT 1
94416: NEG
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 5
94424: PUSH
94425: LD_INT 0
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: LD_INT 5
94434: PUSH
94435: LD_INT 1
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 5
94444: PUSH
94445: LD_INT 1
94447: NEG
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 6
94455: PUSH
94456: LD_INT 0
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 6
94465: PUSH
94466: LD_INT 1
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94487: LD_ADDR_VAR 0 31
94491: PUSH
94492: LD_INT 3
94494: PUSH
94495: LD_INT 2
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: PUSH
94502: LD_INT 3
94504: PUSH
94505: LD_INT 3
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 2
94514: PUSH
94515: LD_INT 3
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: PUSH
94522: LD_INT 4
94524: PUSH
94525: LD_INT 3
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: PUSH
94532: LD_INT 4
94534: PUSH
94535: LD_INT 4
94537: PUSH
94538: EMPTY
94539: LIST
94540: LIST
94541: PUSH
94542: LD_INT 3
94544: PUSH
94545: LD_INT 4
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PUSH
94552: LD_INT 5
94554: PUSH
94555: LD_INT 4
94557: PUSH
94558: EMPTY
94559: LIST
94560: LIST
94561: PUSH
94562: LD_INT 5
94564: PUSH
94565: LD_INT 5
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 4
94574: PUSH
94575: LD_INT 5
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 6
94584: PUSH
94585: LD_INT 5
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: PUSH
94592: LD_INT 6
94594: PUSH
94595: LD_INT 6
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: LD_INT 5
94604: PUSH
94605: LD_INT 6
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94626: LD_ADDR_VAR 0 32
94630: PUSH
94631: LD_INT 1
94633: PUSH
94634: LD_INT 3
94636: PUSH
94637: EMPTY
94638: LIST
94639: LIST
94640: PUSH
94641: LD_INT 0
94643: PUSH
94644: LD_INT 3
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 1
94653: NEG
94654: PUSH
94655: LD_INT 2
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: PUSH
94662: LD_INT 1
94664: PUSH
94665: LD_INT 4
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 0
94674: PUSH
94675: LD_INT 4
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: PUSH
94682: LD_INT 1
94684: NEG
94685: PUSH
94686: LD_INT 3
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: PUSH
94693: LD_INT 1
94695: PUSH
94696: LD_INT 5
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: LD_INT 0
94705: PUSH
94706: LD_INT 5
94708: PUSH
94709: EMPTY
94710: LIST
94711: LIST
94712: PUSH
94713: LD_INT 1
94715: NEG
94716: PUSH
94717: LD_INT 4
94719: PUSH
94720: EMPTY
94721: LIST
94722: LIST
94723: PUSH
94724: LD_INT 1
94726: PUSH
94727: LD_INT 6
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 0
94736: PUSH
94737: LD_INT 6
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 1
94746: NEG
94747: PUSH
94748: LD_INT 5
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
94769: LD_ADDR_VAR 0 33
94773: PUSH
94774: LD_INT 2
94776: NEG
94777: PUSH
94778: LD_INT 1
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: PUSH
94785: LD_INT 3
94787: NEG
94788: PUSH
94789: LD_INT 0
94791: PUSH
94792: EMPTY
94793: LIST
94794: LIST
94795: PUSH
94796: LD_INT 3
94798: NEG
94799: PUSH
94800: LD_INT 1
94802: NEG
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PUSH
94808: LD_INT 3
94810: NEG
94811: PUSH
94812: LD_INT 1
94814: PUSH
94815: EMPTY
94816: LIST
94817: LIST
94818: PUSH
94819: LD_INT 4
94821: NEG
94822: PUSH
94823: LD_INT 0
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 4
94832: NEG
94833: PUSH
94834: LD_INT 1
94836: NEG
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 4
94844: NEG
94845: PUSH
94846: LD_INT 1
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: PUSH
94853: LD_INT 5
94855: NEG
94856: PUSH
94857: LD_INT 0
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 5
94866: NEG
94867: PUSH
94868: LD_INT 1
94870: NEG
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: PUSH
94876: LD_INT 5
94878: NEG
94879: PUSH
94880: LD_INT 1
94882: PUSH
94883: EMPTY
94884: LIST
94885: LIST
94886: PUSH
94887: LD_INT 6
94889: NEG
94890: PUSH
94891: LD_INT 0
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: PUSH
94898: LD_INT 6
94900: NEG
94901: PUSH
94902: LD_INT 1
94904: NEG
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
94924: LD_ADDR_VAR 0 34
94928: PUSH
94929: LD_INT 2
94931: NEG
94932: PUSH
94933: LD_INT 3
94935: NEG
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: PUSH
94941: LD_INT 3
94943: NEG
94944: PUSH
94945: LD_INT 2
94947: NEG
94948: PUSH
94949: EMPTY
94950: LIST
94951: LIST
94952: PUSH
94953: LD_INT 3
94955: NEG
94956: PUSH
94957: LD_INT 3
94959: NEG
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: PUSH
94965: LD_INT 3
94967: NEG
94968: PUSH
94969: LD_INT 4
94971: NEG
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: PUSH
94977: LD_INT 4
94979: NEG
94980: PUSH
94981: LD_INT 3
94983: NEG
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PUSH
94989: LD_INT 4
94991: NEG
94992: PUSH
94993: LD_INT 4
94995: NEG
94996: PUSH
94997: EMPTY
94998: LIST
94999: LIST
95000: PUSH
95001: LD_INT 4
95003: NEG
95004: PUSH
95005: LD_INT 5
95007: NEG
95008: PUSH
95009: EMPTY
95010: LIST
95011: LIST
95012: PUSH
95013: LD_INT 5
95015: NEG
95016: PUSH
95017: LD_INT 4
95019: NEG
95020: PUSH
95021: EMPTY
95022: LIST
95023: LIST
95024: PUSH
95025: LD_INT 5
95027: NEG
95028: PUSH
95029: LD_INT 5
95031: NEG
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: PUSH
95037: LD_INT 5
95039: NEG
95040: PUSH
95041: LD_INT 6
95043: NEG
95044: PUSH
95045: EMPTY
95046: LIST
95047: LIST
95048: PUSH
95049: LD_INT 6
95051: NEG
95052: PUSH
95053: LD_INT 5
95055: NEG
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 6
95063: NEG
95064: PUSH
95065: LD_INT 6
95067: NEG
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
95087: LD_ADDR_VAR 0 41
95091: PUSH
95092: LD_INT 0
95094: PUSH
95095: LD_INT 2
95097: NEG
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 1
95105: NEG
95106: PUSH
95107: LD_INT 3
95109: NEG
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 1
95117: PUSH
95118: LD_INT 2
95120: NEG
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: PUSH
95126: EMPTY
95127: LIST
95128: LIST
95129: LIST
95130: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
95131: LD_ADDR_VAR 0 42
95135: PUSH
95136: LD_INT 2
95138: PUSH
95139: LD_INT 0
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: LD_INT 2
95148: PUSH
95149: LD_INT 1
95151: NEG
95152: PUSH
95153: EMPTY
95154: LIST
95155: LIST
95156: PUSH
95157: LD_INT 3
95159: PUSH
95160: LD_INT 1
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: LIST
95171: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
95172: LD_ADDR_VAR 0 43
95176: PUSH
95177: LD_INT 2
95179: PUSH
95180: LD_INT 2
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 3
95189: PUSH
95190: LD_INT 2
95192: PUSH
95193: EMPTY
95194: LIST
95195: LIST
95196: PUSH
95197: LD_INT 2
95199: PUSH
95200: LD_INT 3
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: PUSH
95207: EMPTY
95208: LIST
95209: LIST
95210: LIST
95211: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
95212: LD_ADDR_VAR 0 44
95216: PUSH
95217: LD_INT 0
95219: PUSH
95220: LD_INT 2
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 1
95229: PUSH
95230: LD_INT 3
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 1
95239: NEG
95240: PUSH
95241: LD_INT 2
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: PUSH
95248: EMPTY
95249: LIST
95250: LIST
95251: LIST
95252: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
95253: LD_ADDR_VAR 0 45
95257: PUSH
95258: LD_INT 2
95260: NEG
95261: PUSH
95262: LD_INT 0
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: PUSH
95269: LD_INT 2
95271: NEG
95272: PUSH
95273: LD_INT 1
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: PUSH
95280: LD_INT 3
95282: NEG
95283: PUSH
95284: LD_INT 1
95286: NEG
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: PUSH
95292: EMPTY
95293: LIST
95294: LIST
95295: LIST
95296: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
95297: LD_ADDR_VAR 0 46
95301: PUSH
95302: LD_INT 2
95304: NEG
95305: PUSH
95306: LD_INT 2
95308: NEG
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 2
95316: NEG
95317: PUSH
95318: LD_INT 3
95320: NEG
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PUSH
95326: LD_INT 3
95328: NEG
95329: PUSH
95330: LD_INT 2
95332: NEG
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: EMPTY
95339: LIST
95340: LIST
95341: LIST
95342: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95343: LD_ADDR_VAR 0 47
95347: PUSH
95348: LD_INT 2
95350: NEG
95351: PUSH
95352: LD_INT 3
95354: NEG
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: LD_INT 1
95362: NEG
95363: PUSH
95364: LD_INT 3
95366: NEG
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95376: LD_ADDR_VAR 0 48
95380: PUSH
95381: LD_INT 1
95383: PUSH
95384: LD_INT 2
95386: NEG
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 2
95394: PUSH
95395: LD_INT 1
95397: NEG
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95407: LD_ADDR_VAR 0 49
95411: PUSH
95412: LD_INT 3
95414: PUSH
95415: LD_INT 1
95417: PUSH
95418: EMPTY
95419: LIST
95420: LIST
95421: PUSH
95422: LD_INT 3
95424: PUSH
95425: LD_INT 2
95427: PUSH
95428: EMPTY
95429: LIST
95430: LIST
95431: PUSH
95432: EMPTY
95433: LIST
95434: LIST
95435: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95436: LD_ADDR_VAR 0 50
95440: PUSH
95441: LD_INT 2
95443: PUSH
95444: LD_INT 3
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 1
95453: PUSH
95454: LD_INT 3
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95465: LD_ADDR_VAR 0 51
95469: PUSH
95470: LD_INT 1
95472: NEG
95473: PUSH
95474: LD_INT 2
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 2
95483: NEG
95484: PUSH
95485: LD_INT 1
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95496: LD_ADDR_VAR 0 52
95500: PUSH
95501: LD_INT 3
95503: NEG
95504: PUSH
95505: LD_INT 1
95507: NEG
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: LD_INT 3
95515: NEG
95516: PUSH
95517: LD_INT 2
95519: NEG
95520: PUSH
95521: EMPTY
95522: LIST
95523: LIST
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95529: LD_ADDR_VAR 0 53
95533: PUSH
95534: LD_INT 1
95536: NEG
95537: PUSH
95538: LD_INT 3
95540: NEG
95541: PUSH
95542: EMPTY
95543: LIST
95544: LIST
95545: PUSH
95546: LD_INT 0
95548: PUSH
95549: LD_INT 3
95551: NEG
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 1
95559: PUSH
95560: LD_INT 2
95562: NEG
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: LIST
95572: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95573: LD_ADDR_VAR 0 54
95577: PUSH
95578: LD_INT 2
95580: PUSH
95581: LD_INT 1
95583: NEG
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: PUSH
95589: LD_INT 3
95591: PUSH
95592: LD_INT 0
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: PUSH
95599: LD_INT 3
95601: PUSH
95602: LD_INT 1
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: LIST
95613: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95614: LD_ADDR_VAR 0 55
95618: PUSH
95619: LD_INT 3
95621: PUSH
95622: LD_INT 2
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: LD_INT 3
95631: PUSH
95632: LD_INT 3
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 2
95641: PUSH
95642: LD_INT 3
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: LIST
95653: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95654: LD_ADDR_VAR 0 56
95658: PUSH
95659: LD_INT 1
95661: PUSH
95662: LD_INT 3
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: PUSH
95669: LD_INT 0
95671: PUSH
95672: LD_INT 3
95674: PUSH
95675: EMPTY
95676: LIST
95677: LIST
95678: PUSH
95679: LD_INT 1
95681: NEG
95682: PUSH
95683: LD_INT 2
95685: PUSH
95686: EMPTY
95687: LIST
95688: LIST
95689: PUSH
95690: EMPTY
95691: LIST
95692: LIST
95693: LIST
95694: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95695: LD_ADDR_VAR 0 57
95699: PUSH
95700: LD_INT 2
95702: NEG
95703: PUSH
95704: LD_INT 1
95706: PUSH
95707: EMPTY
95708: LIST
95709: LIST
95710: PUSH
95711: LD_INT 3
95713: NEG
95714: PUSH
95715: LD_INT 0
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 3
95724: NEG
95725: PUSH
95726: LD_INT 1
95728: NEG
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: LIST
95738: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95739: LD_ADDR_VAR 0 58
95743: PUSH
95744: LD_INT 2
95746: NEG
95747: PUSH
95748: LD_INT 3
95750: NEG
95751: PUSH
95752: EMPTY
95753: LIST
95754: LIST
95755: PUSH
95756: LD_INT 3
95758: NEG
95759: PUSH
95760: LD_INT 2
95762: NEG
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: LD_INT 3
95770: NEG
95771: PUSH
95772: LD_INT 3
95774: NEG
95775: PUSH
95776: EMPTY
95777: LIST
95778: LIST
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: LIST
95784: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
95785: LD_ADDR_VAR 0 59
95789: PUSH
95790: LD_INT 1
95792: NEG
95793: PUSH
95794: LD_INT 2
95796: NEG
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 0
95804: PUSH
95805: LD_INT 2
95807: NEG
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: PUSH
95813: LD_INT 1
95815: PUSH
95816: LD_INT 1
95818: NEG
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: PUSH
95824: EMPTY
95825: LIST
95826: LIST
95827: LIST
95828: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
95829: LD_ADDR_VAR 0 60
95833: PUSH
95834: LD_INT 1
95836: PUSH
95837: LD_INT 1
95839: NEG
95840: PUSH
95841: EMPTY
95842: LIST
95843: LIST
95844: PUSH
95845: LD_INT 2
95847: PUSH
95848: LD_INT 0
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: PUSH
95855: LD_INT 2
95857: PUSH
95858: LD_INT 1
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: LIST
95869: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
95870: LD_ADDR_VAR 0 61
95874: PUSH
95875: LD_INT 2
95877: PUSH
95878: LD_INT 1
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: PUSH
95885: LD_INT 2
95887: PUSH
95888: LD_INT 2
95890: PUSH
95891: EMPTY
95892: LIST
95893: LIST
95894: PUSH
95895: LD_INT 1
95897: PUSH
95898: LD_INT 2
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: LIST
95909: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
95910: LD_ADDR_VAR 0 62
95914: PUSH
95915: LD_INT 1
95917: PUSH
95918: LD_INT 2
95920: PUSH
95921: EMPTY
95922: LIST
95923: LIST
95924: PUSH
95925: LD_INT 0
95927: PUSH
95928: LD_INT 2
95930: PUSH
95931: EMPTY
95932: LIST
95933: LIST
95934: PUSH
95935: LD_INT 1
95937: NEG
95938: PUSH
95939: LD_INT 1
95941: PUSH
95942: EMPTY
95943: LIST
95944: LIST
95945: PUSH
95946: EMPTY
95947: LIST
95948: LIST
95949: LIST
95950: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95951: LD_ADDR_VAR 0 63
95955: PUSH
95956: LD_INT 1
95958: NEG
95959: PUSH
95960: LD_INT 1
95962: PUSH
95963: EMPTY
95964: LIST
95965: LIST
95966: PUSH
95967: LD_INT 2
95969: NEG
95970: PUSH
95971: LD_INT 0
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 2
95980: NEG
95981: PUSH
95982: LD_INT 1
95984: NEG
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: LIST
95994: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95995: LD_ADDR_VAR 0 64
95999: PUSH
96000: LD_INT 1
96002: NEG
96003: PUSH
96004: LD_INT 2
96006: NEG
96007: PUSH
96008: EMPTY
96009: LIST
96010: LIST
96011: PUSH
96012: LD_INT 2
96014: NEG
96015: PUSH
96016: LD_INT 1
96018: NEG
96019: PUSH
96020: EMPTY
96021: LIST
96022: LIST
96023: PUSH
96024: LD_INT 2
96026: NEG
96027: PUSH
96028: LD_INT 2
96030: NEG
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: LIST
96040: ST_TO_ADDR
// end ; 2 :
96041: GO 99307
96043: LD_INT 2
96045: DOUBLE
96046: EQUAL
96047: IFTRUE 96051
96049: GO 99306
96051: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
96052: LD_ADDR_VAR 0 29
96056: PUSH
96057: LD_INT 4
96059: PUSH
96060: LD_INT 0
96062: PUSH
96063: EMPTY
96064: LIST
96065: LIST
96066: PUSH
96067: LD_INT 4
96069: PUSH
96070: LD_INT 1
96072: NEG
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: PUSH
96078: LD_INT 5
96080: PUSH
96081: LD_INT 0
96083: PUSH
96084: EMPTY
96085: LIST
96086: LIST
96087: PUSH
96088: LD_INT 5
96090: PUSH
96091: LD_INT 1
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: LD_INT 4
96100: PUSH
96101: LD_INT 1
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: PUSH
96108: LD_INT 3
96110: PUSH
96111: LD_INT 0
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 3
96120: PUSH
96121: LD_INT 1
96123: NEG
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 3
96131: PUSH
96132: LD_INT 2
96134: NEG
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 5
96142: PUSH
96143: LD_INT 2
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 3
96152: PUSH
96153: LD_INT 3
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 3
96162: PUSH
96163: LD_INT 2
96165: PUSH
96166: EMPTY
96167: LIST
96168: LIST
96169: PUSH
96170: LD_INT 4
96172: PUSH
96173: LD_INT 3
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: PUSH
96180: LD_INT 4
96182: PUSH
96183: LD_INT 4
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: PUSH
96190: LD_INT 3
96192: PUSH
96193: LD_INT 4
96195: PUSH
96196: EMPTY
96197: LIST
96198: LIST
96199: PUSH
96200: LD_INT 2
96202: PUSH
96203: LD_INT 3
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: LD_INT 2
96212: PUSH
96213: LD_INT 2
96215: PUSH
96216: EMPTY
96217: LIST
96218: LIST
96219: PUSH
96220: LD_INT 4
96222: PUSH
96223: LD_INT 2
96225: PUSH
96226: EMPTY
96227: LIST
96228: LIST
96229: PUSH
96230: LD_INT 2
96232: PUSH
96233: LD_INT 4
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: PUSH
96240: LD_INT 0
96242: PUSH
96243: LD_INT 4
96245: PUSH
96246: EMPTY
96247: LIST
96248: LIST
96249: PUSH
96250: LD_INT 0
96252: PUSH
96253: LD_INT 3
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: PUSH
96260: LD_INT 1
96262: PUSH
96263: LD_INT 4
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 1
96272: PUSH
96273: LD_INT 5
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 0
96282: PUSH
96283: LD_INT 5
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: PUSH
96290: LD_INT 1
96292: NEG
96293: PUSH
96294: LD_INT 4
96296: PUSH
96297: EMPTY
96298: LIST
96299: LIST
96300: PUSH
96301: LD_INT 1
96303: NEG
96304: PUSH
96305: LD_INT 3
96307: PUSH
96308: EMPTY
96309: LIST
96310: LIST
96311: PUSH
96312: LD_INT 2
96314: PUSH
96315: LD_INT 5
96317: PUSH
96318: EMPTY
96319: LIST
96320: LIST
96321: PUSH
96322: LD_INT 2
96324: NEG
96325: PUSH
96326: LD_INT 3
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 3
96335: NEG
96336: PUSH
96337: LD_INT 0
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 3
96346: NEG
96347: PUSH
96348: LD_INT 1
96350: NEG
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: LD_INT 2
96358: NEG
96359: PUSH
96360: LD_INT 0
96362: PUSH
96363: EMPTY
96364: LIST
96365: LIST
96366: PUSH
96367: LD_INT 2
96369: NEG
96370: PUSH
96371: LD_INT 1
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: PUSH
96378: LD_INT 3
96380: NEG
96381: PUSH
96382: LD_INT 1
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: PUSH
96389: LD_INT 4
96391: NEG
96392: PUSH
96393: LD_INT 0
96395: PUSH
96396: EMPTY
96397: LIST
96398: LIST
96399: PUSH
96400: LD_INT 4
96402: NEG
96403: PUSH
96404: LD_INT 1
96406: NEG
96407: PUSH
96408: EMPTY
96409: LIST
96410: LIST
96411: PUSH
96412: LD_INT 4
96414: NEG
96415: PUSH
96416: LD_INT 2
96418: NEG
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 2
96426: NEG
96427: PUSH
96428: LD_INT 2
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: LD_INT 4
96437: NEG
96438: PUSH
96439: LD_INT 4
96441: NEG
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 4
96449: NEG
96450: PUSH
96451: LD_INT 5
96453: NEG
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: LD_INT 3
96461: NEG
96462: PUSH
96463: LD_INT 4
96465: NEG
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: LD_INT 3
96477: NEG
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: LD_INT 4
96485: NEG
96486: PUSH
96487: LD_INT 3
96489: NEG
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: PUSH
96495: LD_INT 5
96497: NEG
96498: PUSH
96499: LD_INT 4
96501: NEG
96502: PUSH
96503: EMPTY
96504: LIST
96505: LIST
96506: PUSH
96507: LD_INT 5
96509: NEG
96510: PUSH
96511: LD_INT 5
96513: NEG
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 3
96521: NEG
96522: PUSH
96523: LD_INT 5
96525: NEG
96526: PUSH
96527: EMPTY
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 5
96533: NEG
96534: PUSH
96535: LD_INT 3
96537: NEG
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96590: LD_ADDR_VAR 0 30
96594: PUSH
96595: LD_INT 4
96597: PUSH
96598: LD_INT 4
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: PUSH
96605: LD_INT 4
96607: PUSH
96608: LD_INT 3
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: PUSH
96615: LD_INT 5
96617: PUSH
96618: LD_INT 4
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 5
96627: PUSH
96628: LD_INT 5
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: LD_INT 4
96637: PUSH
96638: LD_INT 5
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 3
96647: PUSH
96648: LD_INT 4
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 3
96657: PUSH
96658: LD_INT 3
96660: PUSH
96661: EMPTY
96662: LIST
96663: LIST
96664: PUSH
96665: LD_INT 5
96667: PUSH
96668: LD_INT 3
96670: PUSH
96671: EMPTY
96672: LIST
96673: LIST
96674: PUSH
96675: LD_INT 3
96677: PUSH
96678: LD_INT 5
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: PUSH
96685: LD_INT 0
96687: PUSH
96688: LD_INT 3
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: LD_INT 0
96697: PUSH
96698: LD_INT 2
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 1
96707: PUSH
96708: LD_INT 3
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 1
96717: PUSH
96718: LD_INT 4
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 0
96727: PUSH
96728: LD_INT 4
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: LD_INT 1
96737: NEG
96738: PUSH
96739: LD_INT 3
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 1
96748: NEG
96749: PUSH
96750: LD_INT 2
96752: PUSH
96753: EMPTY
96754: LIST
96755: LIST
96756: PUSH
96757: LD_INT 2
96759: PUSH
96760: LD_INT 4
96762: PUSH
96763: EMPTY
96764: LIST
96765: LIST
96766: PUSH
96767: LD_INT 2
96769: NEG
96770: PUSH
96771: LD_INT 2
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PUSH
96778: LD_INT 4
96780: NEG
96781: PUSH
96782: LD_INT 0
96784: PUSH
96785: EMPTY
96786: LIST
96787: LIST
96788: PUSH
96789: LD_INT 4
96791: NEG
96792: PUSH
96793: LD_INT 1
96795: NEG
96796: PUSH
96797: EMPTY
96798: LIST
96799: LIST
96800: PUSH
96801: LD_INT 3
96803: NEG
96804: PUSH
96805: LD_INT 0
96807: PUSH
96808: EMPTY
96809: LIST
96810: LIST
96811: PUSH
96812: LD_INT 3
96814: NEG
96815: PUSH
96816: LD_INT 1
96818: PUSH
96819: EMPTY
96820: LIST
96821: LIST
96822: PUSH
96823: LD_INT 4
96825: NEG
96826: PUSH
96827: LD_INT 1
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: PUSH
96834: LD_INT 5
96836: NEG
96837: PUSH
96838: LD_INT 0
96840: PUSH
96841: EMPTY
96842: LIST
96843: LIST
96844: PUSH
96845: LD_INT 5
96847: NEG
96848: PUSH
96849: LD_INT 1
96851: NEG
96852: PUSH
96853: EMPTY
96854: LIST
96855: LIST
96856: PUSH
96857: LD_INT 5
96859: NEG
96860: PUSH
96861: LD_INT 2
96863: NEG
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: PUSH
96869: LD_INT 3
96871: NEG
96872: PUSH
96873: LD_INT 2
96875: PUSH
96876: EMPTY
96877: LIST
96878: LIST
96879: PUSH
96880: LD_INT 3
96882: NEG
96883: PUSH
96884: LD_INT 3
96886: NEG
96887: PUSH
96888: EMPTY
96889: LIST
96890: LIST
96891: PUSH
96892: LD_INT 3
96894: NEG
96895: PUSH
96896: LD_INT 4
96898: NEG
96899: PUSH
96900: EMPTY
96901: LIST
96902: LIST
96903: PUSH
96904: LD_INT 2
96906: NEG
96907: PUSH
96908: LD_INT 3
96910: NEG
96911: PUSH
96912: EMPTY
96913: LIST
96914: LIST
96915: PUSH
96916: LD_INT 2
96918: NEG
96919: PUSH
96920: LD_INT 2
96922: NEG
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 3
96930: NEG
96931: PUSH
96932: LD_INT 2
96934: NEG
96935: PUSH
96936: EMPTY
96937: LIST
96938: LIST
96939: PUSH
96940: LD_INT 4
96942: NEG
96943: PUSH
96944: LD_INT 3
96946: NEG
96947: PUSH
96948: EMPTY
96949: LIST
96950: LIST
96951: PUSH
96952: LD_INT 4
96954: NEG
96955: PUSH
96956: LD_INT 4
96958: NEG
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: PUSH
96964: LD_INT 2
96966: NEG
96967: PUSH
96968: LD_INT 4
96970: NEG
96971: PUSH
96972: EMPTY
96973: LIST
96974: LIST
96975: PUSH
96976: LD_INT 4
96978: NEG
96979: PUSH
96980: LD_INT 2
96982: NEG
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: PUSH
96988: LD_INT 0
96990: PUSH
96991: LD_INT 4
96993: NEG
96994: PUSH
96995: EMPTY
96996: LIST
96997: LIST
96998: PUSH
96999: LD_INT 0
97001: PUSH
97002: LD_INT 5
97004: NEG
97005: PUSH
97006: EMPTY
97007: LIST
97008: LIST
97009: PUSH
97010: LD_INT 1
97012: PUSH
97013: LD_INT 4
97015: NEG
97016: PUSH
97017: EMPTY
97018: LIST
97019: LIST
97020: PUSH
97021: LD_INT 1
97023: PUSH
97024: LD_INT 3
97026: NEG
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: PUSH
97032: LD_INT 0
97034: PUSH
97035: LD_INT 3
97037: NEG
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PUSH
97043: LD_INT 1
97045: NEG
97046: PUSH
97047: LD_INT 4
97049: NEG
97050: PUSH
97051: EMPTY
97052: LIST
97053: LIST
97054: PUSH
97055: LD_INT 1
97057: NEG
97058: PUSH
97059: LD_INT 5
97061: NEG
97062: PUSH
97063: EMPTY
97064: LIST
97065: LIST
97066: PUSH
97067: LD_INT 2
97069: PUSH
97070: LD_INT 3
97072: NEG
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_INT 2
97080: NEG
97081: PUSH
97082: LD_INT 5
97084: NEG
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: PUSH
97090: EMPTY
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
97137: LD_ADDR_VAR 0 31
97141: PUSH
97142: LD_INT 0
97144: PUSH
97145: LD_INT 4
97147: PUSH
97148: EMPTY
97149: LIST
97150: LIST
97151: PUSH
97152: LD_INT 0
97154: PUSH
97155: LD_INT 3
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PUSH
97162: LD_INT 1
97164: PUSH
97165: LD_INT 4
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: PUSH
97172: LD_INT 1
97174: PUSH
97175: LD_INT 5
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: PUSH
97182: LD_INT 0
97184: PUSH
97185: LD_INT 5
97187: PUSH
97188: EMPTY
97189: LIST
97190: LIST
97191: PUSH
97192: LD_INT 1
97194: NEG
97195: PUSH
97196: LD_INT 4
97198: PUSH
97199: EMPTY
97200: LIST
97201: LIST
97202: PUSH
97203: LD_INT 1
97205: NEG
97206: PUSH
97207: LD_INT 3
97209: PUSH
97210: EMPTY
97211: LIST
97212: LIST
97213: PUSH
97214: LD_INT 2
97216: PUSH
97217: LD_INT 5
97219: PUSH
97220: EMPTY
97221: LIST
97222: LIST
97223: PUSH
97224: LD_INT 2
97226: NEG
97227: PUSH
97228: LD_INT 3
97230: PUSH
97231: EMPTY
97232: LIST
97233: LIST
97234: PUSH
97235: LD_INT 3
97237: NEG
97238: PUSH
97239: LD_INT 0
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 3
97248: NEG
97249: PUSH
97250: LD_INT 1
97252: NEG
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PUSH
97258: LD_INT 2
97260: NEG
97261: PUSH
97262: LD_INT 0
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: PUSH
97269: LD_INT 2
97271: NEG
97272: PUSH
97273: LD_INT 1
97275: PUSH
97276: EMPTY
97277: LIST
97278: LIST
97279: PUSH
97280: LD_INT 3
97282: NEG
97283: PUSH
97284: LD_INT 1
97286: PUSH
97287: EMPTY
97288: LIST
97289: LIST
97290: PUSH
97291: LD_INT 4
97293: NEG
97294: PUSH
97295: LD_INT 0
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: PUSH
97302: LD_INT 4
97304: NEG
97305: PUSH
97306: LD_INT 1
97308: NEG
97309: PUSH
97310: EMPTY
97311: LIST
97312: LIST
97313: PUSH
97314: LD_INT 4
97316: NEG
97317: PUSH
97318: LD_INT 2
97320: NEG
97321: PUSH
97322: EMPTY
97323: LIST
97324: LIST
97325: PUSH
97326: LD_INT 2
97328: NEG
97329: PUSH
97330: LD_INT 2
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: LD_INT 4
97339: NEG
97340: PUSH
97341: LD_INT 4
97343: NEG
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: PUSH
97349: LD_INT 4
97351: NEG
97352: PUSH
97353: LD_INT 5
97355: NEG
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: PUSH
97361: LD_INT 3
97363: NEG
97364: PUSH
97365: LD_INT 4
97367: NEG
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PUSH
97373: LD_INT 3
97375: NEG
97376: PUSH
97377: LD_INT 3
97379: NEG
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: PUSH
97385: LD_INT 4
97387: NEG
97388: PUSH
97389: LD_INT 3
97391: NEG
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: PUSH
97397: LD_INT 5
97399: NEG
97400: PUSH
97401: LD_INT 4
97403: NEG
97404: PUSH
97405: EMPTY
97406: LIST
97407: LIST
97408: PUSH
97409: LD_INT 5
97411: NEG
97412: PUSH
97413: LD_INT 5
97415: NEG
97416: PUSH
97417: EMPTY
97418: LIST
97419: LIST
97420: PUSH
97421: LD_INT 3
97423: NEG
97424: PUSH
97425: LD_INT 5
97427: NEG
97428: PUSH
97429: EMPTY
97430: LIST
97431: LIST
97432: PUSH
97433: LD_INT 5
97435: NEG
97436: PUSH
97437: LD_INT 3
97439: NEG
97440: PUSH
97441: EMPTY
97442: LIST
97443: LIST
97444: PUSH
97445: LD_INT 0
97447: PUSH
97448: LD_INT 3
97450: NEG
97451: PUSH
97452: EMPTY
97453: LIST
97454: LIST
97455: PUSH
97456: LD_INT 0
97458: PUSH
97459: LD_INT 4
97461: NEG
97462: PUSH
97463: EMPTY
97464: LIST
97465: LIST
97466: PUSH
97467: LD_INT 1
97469: PUSH
97470: LD_INT 3
97472: NEG
97473: PUSH
97474: EMPTY
97475: LIST
97476: LIST
97477: PUSH
97478: LD_INT 1
97480: PUSH
97481: LD_INT 2
97483: NEG
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: PUSH
97489: LD_INT 0
97491: PUSH
97492: LD_INT 2
97494: NEG
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: LD_INT 1
97502: NEG
97503: PUSH
97504: LD_INT 3
97506: NEG
97507: PUSH
97508: EMPTY
97509: LIST
97510: LIST
97511: PUSH
97512: LD_INT 1
97514: NEG
97515: PUSH
97516: LD_INT 4
97518: NEG
97519: PUSH
97520: EMPTY
97521: LIST
97522: LIST
97523: PUSH
97524: LD_INT 2
97526: PUSH
97527: LD_INT 2
97529: NEG
97530: PUSH
97531: EMPTY
97532: LIST
97533: LIST
97534: PUSH
97535: LD_INT 2
97537: NEG
97538: PUSH
97539: LD_INT 4
97541: NEG
97542: PUSH
97543: EMPTY
97544: LIST
97545: LIST
97546: PUSH
97547: LD_INT 4
97549: PUSH
97550: LD_INT 0
97552: PUSH
97553: EMPTY
97554: LIST
97555: LIST
97556: PUSH
97557: LD_INT 4
97559: PUSH
97560: LD_INT 1
97562: NEG
97563: PUSH
97564: EMPTY
97565: LIST
97566: LIST
97567: PUSH
97568: LD_INT 5
97570: PUSH
97571: LD_INT 0
97573: PUSH
97574: EMPTY
97575: LIST
97576: LIST
97577: PUSH
97578: LD_INT 5
97580: PUSH
97581: LD_INT 1
97583: PUSH
97584: EMPTY
97585: LIST
97586: LIST
97587: PUSH
97588: LD_INT 4
97590: PUSH
97591: LD_INT 1
97593: PUSH
97594: EMPTY
97595: LIST
97596: LIST
97597: PUSH
97598: LD_INT 3
97600: PUSH
97601: LD_INT 0
97603: PUSH
97604: EMPTY
97605: LIST
97606: LIST
97607: PUSH
97608: LD_INT 3
97610: PUSH
97611: LD_INT 1
97613: NEG
97614: PUSH
97615: EMPTY
97616: LIST
97617: LIST
97618: PUSH
97619: LD_INT 3
97621: PUSH
97622: LD_INT 2
97624: NEG
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: PUSH
97630: LD_INT 5
97632: PUSH
97633: LD_INT 2
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: PUSH
97640: EMPTY
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97687: LD_ADDR_VAR 0 32
97691: PUSH
97692: LD_INT 4
97694: NEG
97695: PUSH
97696: LD_INT 0
97698: PUSH
97699: EMPTY
97700: LIST
97701: LIST
97702: PUSH
97703: LD_INT 4
97705: NEG
97706: PUSH
97707: LD_INT 1
97709: NEG
97710: PUSH
97711: EMPTY
97712: LIST
97713: LIST
97714: PUSH
97715: LD_INT 3
97717: NEG
97718: PUSH
97719: LD_INT 0
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: LD_INT 3
97728: NEG
97729: PUSH
97730: LD_INT 1
97732: PUSH
97733: EMPTY
97734: LIST
97735: LIST
97736: PUSH
97737: LD_INT 4
97739: NEG
97740: PUSH
97741: LD_INT 1
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: PUSH
97748: LD_INT 5
97750: NEG
97751: PUSH
97752: LD_INT 0
97754: PUSH
97755: EMPTY
97756: LIST
97757: LIST
97758: PUSH
97759: LD_INT 5
97761: NEG
97762: PUSH
97763: LD_INT 1
97765: NEG
97766: PUSH
97767: EMPTY
97768: LIST
97769: LIST
97770: PUSH
97771: LD_INT 5
97773: NEG
97774: PUSH
97775: LD_INT 2
97777: NEG
97778: PUSH
97779: EMPTY
97780: LIST
97781: LIST
97782: PUSH
97783: LD_INT 3
97785: NEG
97786: PUSH
97787: LD_INT 2
97789: PUSH
97790: EMPTY
97791: LIST
97792: LIST
97793: PUSH
97794: LD_INT 3
97796: NEG
97797: PUSH
97798: LD_INT 3
97800: NEG
97801: PUSH
97802: EMPTY
97803: LIST
97804: LIST
97805: PUSH
97806: LD_INT 3
97808: NEG
97809: PUSH
97810: LD_INT 4
97812: NEG
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 2
97820: NEG
97821: PUSH
97822: LD_INT 3
97824: NEG
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: PUSH
97830: LD_INT 2
97832: NEG
97833: PUSH
97834: LD_INT 2
97836: NEG
97837: PUSH
97838: EMPTY
97839: LIST
97840: LIST
97841: PUSH
97842: LD_INT 3
97844: NEG
97845: PUSH
97846: LD_INT 2
97848: NEG
97849: PUSH
97850: EMPTY
97851: LIST
97852: LIST
97853: PUSH
97854: LD_INT 4
97856: NEG
97857: PUSH
97858: LD_INT 3
97860: NEG
97861: PUSH
97862: EMPTY
97863: LIST
97864: LIST
97865: PUSH
97866: LD_INT 4
97868: NEG
97869: PUSH
97870: LD_INT 4
97872: NEG
97873: PUSH
97874: EMPTY
97875: LIST
97876: LIST
97877: PUSH
97878: LD_INT 2
97880: NEG
97881: PUSH
97882: LD_INT 4
97884: NEG
97885: PUSH
97886: EMPTY
97887: LIST
97888: LIST
97889: PUSH
97890: LD_INT 4
97892: NEG
97893: PUSH
97894: LD_INT 2
97896: NEG
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PUSH
97902: LD_INT 0
97904: PUSH
97905: LD_INT 4
97907: NEG
97908: PUSH
97909: EMPTY
97910: LIST
97911: LIST
97912: PUSH
97913: LD_INT 0
97915: PUSH
97916: LD_INT 5
97918: NEG
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: PUSH
97924: LD_INT 1
97926: PUSH
97927: LD_INT 4
97929: NEG
97930: PUSH
97931: EMPTY
97932: LIST
97933: LIST
97934: PUSH
97935: LD_INT 1
97937: PUSH
97938: LD_INT 3
97940: NEG
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: PUSH
97946: LD_INT 0
97948: PUSH
97949: LD_INT 3
97951: NEG
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: PUSH
97957: LD_INT 1
97959: NEG
97960: PUSH
97961: LD_INT 4
97963: NEG
97964: PUSH
97965: EMPTY
97966: LIST
97967: LIST
97968: PUSH
97969: LD_INT 1
97971: NEG
97972: PUSH
97973: LD_INT 5
97975: NEG
97976: PUSH
97977: EMPTY
97978: LIST
97979: LIST
97980: PUSH
97981: LD_INT 2
97983: PUSH
97984: LD_INT 3
97986: NEG
97987: PUSH
97988: EMPTY
97989: LIST
97990: LIST
97991: PUSH
97992: LD_INT 2
97994: NEG
97995: PUSH
97996: LD_INT 5
97998: NEG
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: PUSH
98004: LD_INT 3
98006: PUSH
98007: LD_INT 0
98009: PUSH
98010: EMPTY
98011: LIST
98012: LIST
98013: PUSH
98014: LD_INT 3
98016: PUSH
98017: LD_INT 1
98019: NEG
98020: PUSH
98021: EMPTY
98022: LIST
98023: LIST
98024: PUSH
98025: LD_INT 4
98027: PUSH
98028: LD_INT 0
98030: PUSH
98031: EMPTY
98032: LIST
98033: LIST
98034: PUSH
98035: LD_INT 4
98037: PUSH
98038: LD_INT 1
98040: PUSH
98041: EMPTY
98042: LIST
98043: LIST
98044: PUSH
98045: LD_INT 3
98047: PUSH
98048: LD_INT 1
98050: PUSH
98051: EMPTY
98052: LIST
98053: LIST
98054: PUSH
98055: LD_INT 2
98057: PUSH
98058: LD_INT 0
98060: PUSH
98061: EMPTY
98062: LIST
98063: LIST
98064: PUSH
98065: LD_INT 2
98067: PUSH
98068: LD_INT 1
98070: NEG
98071: PUSH
98072: EMPTY
98073: LIST
98074: LIST
98075: PUSH
98076: LD_INT 2
98078: PUSH
98079: LD_INT 2
98081: NEG
98082: PUSH
98083: EMPTY
98084: LIST
98085: LIST
98086: PUSH
98087: LD_INT 4
98089: PUSH
98090: LD_INT 2
98092: PUSH
98093: EMPTY
98094: LIST
98095: LIST
98096: PUSH
98097: LD_INT 4
98099: PUSH
98100: LD_INT 4
98102: PUSH
98103: EMPTY
98104: LIST
98105: LIST
98106: PUSH
98107: LD_INT 4
98109: PUSH
98110: LD_INT 3
98112: PUSH
98113: EMPTY
98114: LIST
98115: LIST
98116: PUSH
98117: LD_INT 5
98119: PUSH
98120: LD_INT 4
98122: PUSH
98123: EMPTY
98124: LIST
98125: LIST
98126: PUSH
98127: LD_INT 5
98129: PUSH
98130: LD_INT 5
98132: PUSH
98133: EMPTY
98134: LIST
98135: LIST
98136: PUSH
98137: LD_INT 4
98139: PUSH
98140: LD_INT 5
98142: PUSH
98143: EMPTY
98144: LIST
98145: LIST
98146: PUSH
98147: LD_INT 3
98149: PUSH
98150: LD_INT 4
98152: PUSH
98153: EMPTY
98154: LIST
98155: LIST
98156: PUSH
98157: LD_INT 3
98159: PUSH
98160: LD_INT 3
98162: PUSH
98163: EMPTY
98164: LIST
98165: LIST
98166: PUSH
98167: LD_INT 5
98169: PUSH
98170: LD_INT 3
98172: PUSH
98173: EMPTY
98174: LIST
98175: LIST
98176: PUSH
98177: LD_INT 3
98179: PUSH
98180: LD_INT 5
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: PUSH
98187: EMPTY
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: LIST
98206: LIST
98207: LIST
98208: LIST
98209: LIST
98210: LIST
98211: LIST
98212: LIST
98213: LIST
98214: LIST
98215: LIST
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: LIST
98221: LIST
98222: LIST
98223: LIST
98224: LIST
98225: LIST
98226: LIST
98227: LIST
98228: LIST
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
98234: LD_ADDR_VAR 0 33
98238: PUSH
98239: LD_INT 4
98241: NEG
98242: PUSH
98243: LD_INT 4
98245: NEG
98246: PUSH
98247: EMPTY
98248: LIST
98249: LIST
98250: PUSH
98251: LD_INT 4
98253: NEG
98254: PUSH
98255: LD_INT 5
98257: NEG
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: PUSH
98263: LD_INT 3
98265: NEG
98266: PUSH
98267: LD_INT 4
98269: NEG
98270: PUSH
98271: EMPTY
98272: LIST
98273: LIST
98274: PUSH
98275: LD_INT 3
98277: NEG
98278: PUSH
98279: LD_INT 3
98281: NEG
98282: PUSH
98283: EMPTY
98284: LIST
98285: LIST
98286: PUSH
98287: LD_INT 4
98289: NEG
98290: PUSH
98291: LD_INT 3
98293: NEG
98294: PUSH
98295: EMPTY
98296: LIST
98297: LIST
98298: PUSH
98299: LD_INT 5
98301: NEG
98302: PUSH
98303: LD_INT 4
98305: NEG
98306: PUSH
98307: EMPTY
98308: LIST
98309: LIST
98310: PUSH
98311: LD_INT 5
98313: NEG
98314: PUSH
98315: LD_INT 5
98317: NEG
98318: PUSH
98319: EMPTY
98320: LIST
98321: LIST
98322: PUSH
98323: LD_INT 3
98325: NEG
98326: PUSH
98327: LD_INT 5
98329: NEG
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: PUSH
98335: LD_INT 5
98337: NEG
98338: PUSH
98339: LD_INT 3
98341: NEG
98342: PUSH
98343: EMPTY
98344: LIST
98345: LIST
98346: PUSH
98347: LD_INT 0
98349: PUSH
98350: LD_INT 3
98352: NEG
98353: PUSH
98354: EMPTY
98355: LIST
98356: LIST
98357: PUSH
98358: LD_INT 0
98360: PUSH
98361: LD_INT 4
98363: NEG
98364: PUSH
98365: EMPTY
98366: LIST
98367: LIST
98368: PUSH
98369: LD_INT 1
98371: PUSH
98372: LD_INT 3
98374: NEG
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PUSH
98380: LD_INT 1
98382: PUSH
98383: LD_INT 2
98385: NEG
98386: PUSH
98387: EMPTY
98388: LIST
98389: LIST
98390: PUSH
98391: LD_INT 0
98393: PUSH
98394: LD_INT 2
98396: NEG
98397: PUSH
98398: EMPTY
98399: LIST
98400: LIST
98401: PUSH
98402: LD_INT 1
98404: NEG
98405: PUSH
98406: LD_INT 3
98408: NEG
98409: PUSH
98410: EMPTY
98411: LIST
98412: LIST
98413: PUSH
98414: LD_INT 1
98416: NEG
98417: PUSH
98418: LD_INT 4
98420: NEG
98421: PUSH
98422: EMPTY
98423: LIST
98424: LIST
98425: PUSH
98426: LD_INT 2
98428: PUSH
98429: LD_INT 2
98431: NEG
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: PUSH
98437: LD_INT 2
98439: NEG
98440: PUSH
98441: LD_INT 4
98443: NEG
98444: PUSH
98445: EMPTY
98446: LIST
98447: LIST
98448: PUSH
98449: LD_INT 4
98451: PUSH
98452: LD_INT 0
98454: PUSH
98455: EMPTY
98456: LIST
98457: LIST
98458: PUSH
98459: LD_INT 4
98461: PUSH
98462: LD_INT 1
98464: NEG
98465: PUSH
98466: EMPTY
98467: LIST
98468: LIST
98469: PUSH
98470: LD_INT 5
98472: PUSH
98473: LD_INT 0
98475: PUSH
98476: EMPTY
98477: LIST
98478: LIST
98479: PUSH
98480: LD_INT 5
98482: PUSH
98483: LD_INT 1
98485: PUSH
98486: EMPTY
98487: LIST
98488: LIST
98489: PUSH
98490: LD_INT 4
98492: PUSH
98493: LD_INT 1
98495: PUSH
98496: EMPTY
98497: LIST
98498: LIST
98499: PUSH
98500: LD_INT 3
98502: PUSH
98503: LD_INT 0
98505: PUSH
98506: EMPTY
98507: LIST
98508: LIST
98509: PUSH
98510: LD_INT 3
98512: PUSH
98513: LD_INT 1
98515: NEG
98516: PUSH
98517: EMPTY
98518: LIST
98519: LIST
98520: PUSH
98521: LD_INT 3
98523: PUSH
98524: LD_INT 2
98526: NEG
98527: PUSH
98528: EMPTY
98529: LIST
98530: LIST
98531: PUSH
98532: LD_INT 5
98534: PUSH
98535: LD_INT 2
98537: PUSH
98538: EMPTY
98539: LIST
98540: LIST
98541: PUSH
98542: LD_INT 3
98544: PUSH
98545: LD_INT 3
98547: PUSH
98548: EMPTY
98549: LIST
98550: LIST
98551: PUSH
98552: LD_INT 3
98554: PUSH
98555: LD_INT 2
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: PUSH
98562: LD_INT 4
98564: PUSH
98565: LD_INT 3
98567: PUSH
98568: EMPTY
98569: LIST
98570: LIST
98571: PUSH
98572: LD_INT 4
98574: PUSH
98575: LD_INT 4
98577: PUSH
98578: EMPTY
98579: LIST
98580: LIST
98581: PUSH
98582: LD_INT 3
98584: PUSH
98585: LD_INT 4
98587: PUSH
98588: EMPTY
98589: LIST
98590: LIST
98591: PUSH
98592: LD_INT 2
98594: PUSH
98595: LD_INT 3
98597: PUSH
98598: EMPTY
98599: LIST
98600: LIST
98601: PUSH
98602: LD_INT 2
98604: PUSH
98605: LD_INT 2
98607: PUSH
98608: EMPTY
98609: LIST
98610: LIST
98611: PUSH
98612: LD_INT 4
98614: PUSH
98615: LD_INT 2
98617: PUSH
98618: EMPTY
98619: LIST
98620: LIST
98621: PUSH
98622: LD_INT 2
98624: PUSH
98625: LD_INT 4
98627: PUSH
98628: EMPTY
98629: LIST
98630: LIST
98631: PUSH
98632: LD_INT 0
98634: PUSH
98635: LD_INT 4
98637: PUSH
98638: EMPTY
98639: LIST
98640: LIST
98641: PUSH
98642: LD_INT 0
98644: PUSH
98645: LD_INT 3
98647: PUSH
98648: EMPTY
98649: LIST
98650: LIST
98651: PUSH
98652: LD_INT 1
98654: PUSH
98655: LD_INT 4
98657: PUSH
98658: EMPTY
98659: LIST
98660: LIST
98661: PUSH
98662: LD_INT 1
98664: PUSH
98665: LD_INT 5
98667: PUSH
98668: EMPTY
98669: LIST
98670: LIST
98671: PUSH
98672: LD_INT 0
98674: PUSH
98675: LD_INT 5
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: PUSH
98682: LD_INT 1
98684: NEG
98685: PUSH
98686: LD_INT 4
98688: PUSH
98689: EMPTY
98690: LIST
98691: LIST
98692: PUSH
98693: LD_INT 1
98695: NEG
98696: PUSH
98697: LD_INT 3
98699: PUSH
98700: EMPTY
98701: LIST
98702: LIST
98703: PUSH
98704: LD_INT 2
98706: PUSH
98707: LD_INT 5
98709: PUSH
98710: EMPTY
98711: LIST
98712: LIST
98713: PUSH
98714: LD_INT 2
98716: NEG
98717: PUSH
98718: LD_INT 3
98720: PUSH
98721: EMPTY
98722: LIST
98723: LIST
98724: PUSH
98725: EMPTY
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: LIST
98764: LIST
98765: LIST
98766: LIST
98767: LIST
98768: LIST
98769: LIST
98770: LIST
98771: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
98772: LD_ADDR_VAR 0 34
98776: PUSH
98777: LD_INT 0
98779: PUSH
98780: LD_INT 4
98782: NEG
98783: PUSH
98784: EMPTY
98785: LIST
98786: LIST
98787: PUSH
98788: LD_INT 0
98790: PUSH
98791: LD_INT 5
98793: NEG
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: PUSH
98799: LD_INT 1
98801: PUSH
98802: LD_INT 4
98804: NEG
98805: PUSH
98806: EMPTY
98807: LIST
98808: LIST
98809: PUSH
98810: LD_INT 1
98812: PUSH
98813: LD_INT 3
98815: NEG
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: PUSH
98821: LD_INT 0
98823: PUSH
98824: LD_INT 3
98826: NEG
98827: PUSH
98828: EMPTY
98829: LIST
98830: LIST
98831: PUSH
98832: LD_INT 1
98834: NEG
98835: PUSH
98836: LD_INT 4
98838: NEG
98839: PUSH
98840: EMPTY
98841: LIST
98842: LIST
98843: PUSH
98844: LD_INT 1
98846: NEG
98847: PUSH
98848: LD_INT 5
98850: NEG
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: PUSH
98856: LD_INT 2
98858: PUSH
98859: LD_INT 3
98861: NEG
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: PUSH
98867: LD_INT 2
98869: NEG
98870: PUSH
98871: LD_INT 5
98873: NEG
98874: PUSH
98875: EMPTY
98876: LIST
98877: LIST
98878: PUSH
98879: LD_INT 3
98881: PUSH
98882: LD_INT 0
98884: PUSH
98885: EMPTY
98886: LIST
98887: LIST
98888: PUSH
98889: LD_INT 3
98891: PUSH
98892: LD_INT 1
98894: NEG
98895: PUSH
98896: EMPTY
98897: LIST
98898: LIST
98899: PUSH
98900: LD_INT 4
98902: PUSH
98903: LD_INT 0
98905: PUSH
98906: EMPTY
98907: LIST
98908: LIST
98909: PUSH
98910: LD_INT 4
98912: PUSH
98913: LD_INT 1
98915: PUSH
98916: EMPTY
98917: LIST
98918: LIST
98919: PUSH
98920: LD_INT 3
98922: PUSH
98923: LD_INT 1
98925: PUSH
98926: EMPTY
98927: LIST
98928: LIST
98929: PUSH
98930: LD_INT 2
98932: PUSH
98933: LD_INT 0
98935: PUSH
98936: EMPTY
98937: LIST
98938: LIST
98939: PUSH
98940: LD_INT 2
98942: PUSH
98943: LD_INT 1
98945: NEG
98946: PUSH
98947: EMPTY
98948: LIST
98949: LIST
98950: PUSH
98951: LD_INT 2
98953: PUSH
98954: LD_INT 2
98956: NEG
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: PUSH
98962: LD_INT 4
98964: PUSH
98965: LD_INT 2
98967: PUSH
98968: EMPTY
98969: LIST
98970: LIST
98971: PUSH
98972: LD_INT 4
98974: PUSH
98975: LD_INT 4
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: PUSH
98982: LD_INT 4
98984: PUSH
98985: LD_INT 3
98987: PUSH
98988: EMPTY
98989: LIST
98990: LIST
98991: PUSH
98992: LD_INT 5
98994: PUSH
98995: LD_INT 4
98997: PUSH
98998: EMPTY
98999: LIST
99000: LIST
99001: PUSH
99002: LD_INT 5
99004: PUSH
99005: LD_INT 5
99007: PUSH
99008: EMPTY
99009: LIST
99010: LIST
99011: PUSH
99012: LD_INT 4
99014: PUSH
99015: LD_INT 5
99017: PUSH
99018: EMPTY
99019: LIST
99020: LIST
99021: PUSH
99022: LD_INT 3
99024: PUSH
99025: LD_INT 4
99027: PUSH
99028: EMPTY
99029: LIST
99030: LIST
99031: PUSH
99032: LD_INT 3
99034: PUSH
99035: LD_INT 3
99037: PUSH
99038: EMPTY
99039: LIST
99040: LIST
99041: PUSH
99042: LD_INT 5
99044: PUSH
99045: LD_INT 3
99047: PUSH
99048: EMPTY
99049: LIST
99050: LIST
99051: PUSH
99052: LD_INT 3
99054: PUSH
99055: LD_INT 5
99057: PUSH
99058: EMPTY
99059: LIST
99060: LIST
99061: PUSH
99062: LD_INT 0
99064: PUSH
99065: LD_INT 3
99067: PUSH
99068: EMPTY
99069: LIST
99070: LIST
99071: PUSH
99072: LD_INT 0
99074: PUSH
99075: LD_INT 2
99077: PUSH
99078: EMPTY
99079: LIST
99080: LIST
99081: PUSH
99082: LD_INT 1
99084: PUSH
99085: LD_INT 3
99087: PUSH
99088: EMPTY
99089: LIST
99090: LIST
99091: PUSH
99092: LD_INT 1
99094: PUSH
99095: LD_INT 4
99097: PUSH
99098: EMPTY
99099: LIST
99100: LIST
99101: PUSH
99102: LD_INT 0
99104: PUSH
99105: LD_INT 4
99107: PUSH
99108: EMPTY
99109: LIST
99110: LIST
99111: PUSH
99112: LD_INT 1
99114: NEG
99115: PUSH
99116: LD_INT 3
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: PUSH
99123: LD_INT 1
99125: NEG
99126: PUSH
99127: LD_INT 2
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: PUSH
99134: LD_INT 2
99136: PUSH
99137: LD_INT 4
99139: PUSH
99140: EMPTY
99141: LIST
99142: LIST
99143: PUSH
99144: LD_INT 2
99146: NEG
99147: PUSH
99148: LD_INT 2
99150: PUSH
99151: EMPTY
99152: LIST
99153: LIST
99154: PUSH
99155: LD_INT 4
99157: NEG
99158: PUSH
99159: LD_INT 0
99161: PUSH
99162: EMPTY
99163: LIST
99164: LIST
99165: PUSH
99166: LD_INT 4
99168: NEG
99169: PUSH
99170: LD_INT 1
99172: NEG
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: PUSH
99178: LD_INT 3
99180: NEG
99181: PUSH
99182: LD_INT 0
99184: PUSH
99185: EMPTY
99186: LIST
99187: LIST
99188: PUSH
99189: LD_INT 3
99191: NEG
99192: PUSH
99193: LD_INT 1
99195: PUSH
99196: EMPTY
99197: LIST
99198: LIST
99199: PUSH
99200: LD_INT 4
99202: NEG
99203: PUSH
99204: LD_INT 1
99206: PUSH
99207: EMPTY
99208: LIST
99209: LIST
99210: PUSH
99211: LD_INT 5
99213: NEG
99214: PUSH
99215: LD_INT 0
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: PUSH
99222: LD_INT 5
99224: NEG
99225: PUSH
99226: LD_INT 1
99228: NEG
99229: PUSH
99230: EMPTY
99231: LIST
99232: LIST
99233: PUSH
99234: LD_INT 5
99236: NEG
99237: PUSH
99238: LD_INT 2
99240: NEG
99241: PUSH
99242: EMPTY
99243: LIST
99244: LIST
99245: PUSH
99246: LD_INT 3
99248: NEG
99249: PUSH
99250: LD_INT 2
99252: PUSH
99253: EMPTY
99254: LIST
99255: LIST
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: LIST
99277: LIST
99278: LIST
99279: LIST
99280: LIST
99281: LIST
99282: LIST
99283: LIST
99284: LIST
99285: LIST
99286: LIST
99287: LIST
99288: LIST
99289: LIST
99290: LIST
99291: LIST
99292: LIST
99293: LIST
99294: LIST
99295: LIST
99296: LIST
99297: LIST
99298: LIST
99299: LIST
99300: LIST
99301: LIST
99302: LIST
99303: ST_TO_ADDR
// end ; end ;
99304: GO 99307
99306: POP
// case btype of b_depot , b_warehouse :
99307: LD_VAR 0 1
99311: PUSH
99312: LD_INT 0
99314: DOUBLE
99315: EQUAL
99316: IFTRUE 99326
99318: LD_INT 1
99320: DOUBLE
99321: EQUAL
99322: IFTRUE 99326
99324: GO 99527
99326: POP
// case nation of nation_american :
99327: LD_VAR 0 5
99331: PUSH
99332: LD_INT 1
99334: DOUBLE
99335: EQUAL
99336: IFTRUE 99340
99338: GO 99396
99340: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99341: LD_ADDR_VAR 0 9
99345: PUSH
99346: LD_VAR 0 11
99350: PUSH
99351: LD_VAR 0 12
99355: PUSH
99356: LD_VAR 0 13
99360: PUSH
99361: LD_VAR 0 14
99365: PUSH
99366: LD_VAR 0 15
99370: PUSH
99371: LD_VAR 0 16
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: PUSH
99384: LD_VAR 0 4
99388: PUSH
99389: LD_INT 1
99391: PLUS
99392: ARRAY
99393: ST_TO_ADDR
99394: GO 99525
99396: LD_INT 2
99398: DOUBLE
99399: EQUAL
99400: IFTRUE 99404
99402: GO 99460
99404: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99405: LD_ADDR_VAR 0 9
99409: PUSH
99410: LD_VAR 0 17
99414: PUSH
99415: LD_VAR 0 18
99419: PUSH
99420: LD_VAR 0 19
99424: PUSH
99425: LD_VAR 0 20
99429: PUSH
99430: LD_VAR 0 21
99434: PUSH
99435: LD_VAR 0 22
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: LIST
99444: LIST
99445: LIST
99446: LIST
99447: PUSH
99448: LD_VAR 0 4
99452: PUSH
99453: LD_INT 1
99455: PLUS
99456: ARRAY
99457: ST_TO_ADDR
99458: GO 99525
99460: LD_INT 3
99462: DOUBLE
99463: EQUAL
99464: IFTRUE 99468
99466: GO 99524
99468: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99469: LD_ADDR_VAR 0 9
99473: PUSH
99474: LD_VAR 0 23
99478: PUSH
99479: LD_VAR 0 24
99483: PUSH
99484: LD_VAR 0 25
99488: PUSH
99489: LD_VAR 0 26
99493: PUSH
99494: LD_VAR 0 27
99498: PUSH
99499: LD_VAR 0 28
99503: PUSH
99504: EMPTY
99505: LIST
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: PUSH
99512: LD_VAR 0 4
99516: PUSH
99517: LD_INT 1
99519: PLUS
99520: ARRAY
99521: ST_TO_ADDR
99522: GO 99525
99524: POP
99525: GO 100080
99527: LD_INT 2
99529: DOUBLE
99530: EQUAL
99531: IFTRUE 99541
99533: LD_INT 3
99535: DOUBLE
99536: EQUAL
99537: IFTRUE 99541
99539: GO 99597
99541: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99542: LD_ADDR_VAR 0 9
99546: PUSH
99547: LD_VAR 0 29
99551: PUSH
99552: LD_VAR 0 30
99556: PUSH
99557: LD_VAR 0 31
99561: PUSH
99562: LD_VAR 0 32
99566: PUSH
99567: LD_VAR 0 33
99571: PUSH
99572: LD_VAR 0 34
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: LIST
99584: PUSH
99585: LD_VAR 0 4
99589: PUSH
99590: LD_INT 1
99592: PLUS
99593: ARRAY
99594: ST_TO_ADDR
99595: GO 100080
99597: LD_INT 16
99599: DOUBLE
99600: EQUAL
99601: IFTRUE 99659
99603: LD_INT 17
99605: DOUBLE
99606: EQUAL
99607: IFTRUE 99659
99609: LD_INT 18
99611: DOUBLE
99612: EQUAL
99613: IFTRUE 99659
99615: LD_INT 19
99617: DOUBLE
99618: EQUAL
99619: IFTRUE 99659
99621: LD_INT 22
99623: DOUBLE
99624: EQUAL
99625: IFTRUE 99659
99627: LD_INT 20
99629: DOUBLE
99630: EQUAL
99631: IFTRUE 99659
99633: LD_INT 21
99635: DOUBLE
99636: EQUAL
99637: IFTRUE 99659
99639: LD_INT 23
99641: DOUBLE
99642: EQUAL
99643: IFTRUE 99659
99645: LD_INT 24
99647: DOUBLE
99648: EQUAL
99649: IFTRUE 99659
99651: LD_INT 25
99653: DOUBLE
99654: EQUAL
99655: IFTRUE 99659
99657: GO 99715
99659: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99660: LD_ADDR_VAR 0 9
99664: PUSH
99665: LD_VAR 0 35
99669: PUSH
99670: LD_VAR 0 36
99674: PUSH
99675: LD_VAR 0 37
99679: PUSH
99680: LD_VAR 0 38
99684: PUSH
99685: LD_VAR 0 39
99689: PUSH
99690: LD_VAR 0 40
99694: PUSH
99695: EMPTY
99696: LIST
99697: LIST
99698: LIST
99699: LIST
99700: LIST
99701: LIST
99702: PUSH
99703: LD_VAR 0 4
99707: PUSH
99708: LD_INT 1
99710: PLUS
99711: ARRAY
99712: ST_TO_ADDR
99713: GO 100080
99715: LD_INT 6
99717: DOUBLE
99718: EQUAL
99719: IFTRUE 99771
99721: LD_INT 7
99723: DOUBLE
99724: EQUAL
99725: IFTRUE 99771
99727: LD_INT 8
99729: DOUBLE
99730: EQUAL
99731: IFTRUE 99771
99733: LD_INT 13
99735: DOUBLE
99736: EQUAL
99737: IFTRUE 99771
99739: LD_INT 12
99741: DOUBLE
99742: EQUAL
99743: IFTRUE 99771
99745: LD_INT 15
99747: DOUBLE
99748: EQUAL
99749: IFTRUE 99771
99751: LD_INT 11
99753: DOUBLE
99754: EQUAL
99755: IFTRUE 99771
99757: LD_INT 14
99759: DOUBLE
99760: EQUAL
99761: IFTRUE 99771
99763: LD_INT 10
99765: DOUBLE
99766: EQUAL
99767: IFTRUE 99771
99769: GO 99827
99771: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
99772: LD_ADDR_VAR 0 9
99776: PUSH
99777: LD_VAR 0 41
99781: PUSH
99782: LD_VAR 0 42
99786: PUSH
99787: LD_VAR 0 43
99791: PUSH
99792: LD_VAR 0 44
99796: PUSH
99797: LD_VAR 0 45
99801: PUSH
99802: LD_VAR 0 46
99806: PUSH
99807: EMPTY
99808: LIST
99809: LIST
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: PUSH
99815: LD_VAR 0 4
99819: PUSH
99820: LD_INT 1
99822: PLUS
99823: ARRAY
99824: ST_TO_ADDR
99825: GO 100080
99827: LD_INT 36
99829: DOUBLE
99830: EQUAL
99831: IFTRUE 99835
99833: GO 99891
99835: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
99836: LD_ADDR_VAR 0 9
99840: PUSH
99841: LD_VAR 0 47
99845: PUSH
99846: LD_VAR 0 48
99850: PUSH
99851: LD_VAR 0 49
99855: PUSH
99856: LD_VAR 0 50
99860: PUSH
99861: LD_VAR 0 51
99865: PUSH
99866: LD_VAR 0 52
99870: PUSH
99871: EMPTY
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: PUSH
99879: LD_VAR 0 4
99883: PUSH
99884: LD_INT 1
99886: PLUS
99887: ARRAY
99888: ST_TO_ADDR
99889: GO 100080
99891: LD_INT 4
99893: DOUBLE
99894: EQUAL
99895: IFTRUE 99917
99897: LD_INT 5
99899: DOUBLE
99900: EQUAL
99901: IFTRUE 99917
99903: LD_INT 34
99905: DOUBLE
99906: EQUAL
99907: IFTRUE 99917
99909: LD_INT 37
99911: DOUBLE
99912: EQUAL
99913: IFTRUE 99917
99915: GO 99973
99917: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
99918: LD_ADDR_VAR 0 9
99922: PUSH
99923: LD_VAR 0 53
99927: PUSH
99928: LD_VAR 0 54
99932: PUSH
99933: LD_VAR 0 55
99937: PUSH
99938: LD_VAR 0 56
99942: PUSH
99943: LD_VAR 0 57
99947: PUSH
99948: LD_VAR 0 58
99952: PUSH
99953: EMPTY
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: PUSH
99961: LD_VAR 0 4
99965: PUSH
99966: LD_INT 1
99968: PLUS
99969: ARRAY
99970: ST_TO_ADDR
99971: GO 100080
99973: LD_INT 31
99975: DOUBLE
99976: EQUAL
99977: IFTRUE 100023
99979: LD_INT 32
99981: DOUBLE
99982: EQUAL
99983: IFTRUE 100023
99985: LD_INT 33
99987: DOUBLE
99988: EQUAL
99989: IFTRUE 100023
99991: LD_INT 27
99993: DOUBLE
99994: EQUAL
99995: IFTRUE 100023
99997: LD_INT 26
99999: DOUBLE
100000: EQUAL
100001: IFTRUE 100023
100003: LD_INT 28
100005: DOUBLE
100006: EQUAL
100007: IFTRUE 100023
100009: LD_INT 29
100011: DOUBLE
100012: EQUAL
100013: IFTRUE 100023
100015: LD_INT 30
100017: DOUBLE
100018: EQUAL
100019: IFTRUE 100023
100021: GO 100079
100023: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
100024: LD_ADDR_VAR 0 9
100028: PUSH
100029: LD_VAR 0 59
100033: PUSH
100034: LD_VAR 0 60
100038: PUSH
100039: LD_VAR 0 61
100043: PUSH
100044: LD_VAR 0 62
100048: PUSH
100049: LD_VAR 0 63
100053: PUSH
100054: LD_VAR 0 64
100058: PUSH
100059: EMPTY
100060: LIST
100061: LIST
100062: LIST
100063: LIST
100064: LIST
100065: LIST
100066: PUSH
100067: LD_VAR 0 4
100071: PUSH
100072: LD_INT 1
100074: PLUS
100075: ARRAY
100076: ST_TO_ADDR
100077: GO 100080
100079: POP
// temp_list2 = [ ] ;
100080: LD_ADDR_VAR 0 10
100084: PUSH
100085: EMPTY
100086: ST_TO_ADDR
// for i in temp_list do
100087: LD_ADDR_VAR 0 8
100091: PUSH
100092: LD_VAR 0 9
100096: PUSH
100097: FOR_IN
100098: IFFALSE 100150
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
100100: LD_ADDR_VAR 0 10
100104: PUSH
100105: LD_VAR 0 10
100109: PUSH
100110: LD_VAR 0 8
100114: PUSH
100115: LD_INT 1
100117: ARRAY
100118: PUSH
100119: LD_VAR 0 2
100123: PLUS
100124: PUSH
100125: LD_VAR 0 8
100129: PUSH
100130: LD_INT 2
100132: ARRAY
100133: PUSH
100134: LD_VAR 0 3
100138: PLUS
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: PUSH
100144: EMPTY
100145: LIST
100146: ADD
100147: ST_TO_ADDR
100148: GO 100097
100150: POP
100151: POP
// result = temp_list2 ;
100152: LD_ADDR_VAR 0 7
100156: PUSH
100157: LD_VAR 0 10
100161: ST_TO_ADDR
// end ;
100162: LD_VAR 0 7
100166: RET
// export function EnemyInRange ( unit , dist ) ; begin
100167: LD_INT 0
100169: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
100170: LD_ADDR_VAR 0 3
100174: PUSH
100175: LD_VAR 0 1
100179: PPUSH
100180: CALL_OW 255
100184: PPUSH
100185: LD_VAR 0 1
100189: PPUSH
100190: CALL_OW 250
100194: PPUSH
100195: LD_VAR 0 1
100199: PPUSH
100200: CALL_OW 251
100204: PPUSH
100205: LD_VAR 0 2
100209: PPUSH
100210: CALL 73569 0 4
100214: PUSH
100215: LD_INT 4
100217: ARRAY
100218: ST_TO_ADDR
// end ;
100219: LD_VAR 0 3
100223: RET
// export function PlayerSeeMe ( unit ) ; begin
100224: LD_INT 0
100226: PPUSH
// result := See ( your_side , unit ) ;
100227: LD_ADDR_VAR 0 2
100231: PUSH
100232: LD_OWVAR 2
100236: PPUSH
100237: LD_VAR 0 1
100241: PPUSH
100242: CALL_OW 292
100246: ST_TO_ADDR
// end ;
100247: LD_VAR 0 2
100251: RET
// export function ReverseDir ( unit ) ; begin
100252: LD_INT 0
100254: PPUSH
// if not unit then
100255: LD_VAR 0 1
100259: NOT
100260: IFFALSE 100264
// exit ;
100262: GO 100287
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
100264: LD_ADDR_VAR 0 2
100268: PUSH
100269: LD_VAR 0 1
100273: PPUSH
100274: CALL_OW 254
100278: PUSH
100279: LD_INT 3
100281: PLUS
100282: PUSH
100283: LD_INT 6
100285: MOD
100286: ST_TO_ADDR
// end ;
100287: LD_VAR 0 2
100291: RET
// export function ReverseArray ( array ) ; var i ; begin
100292: LD_INT 0
100294: PPUSH
100295: PPUSH
// if not array then
100296: LD_VAR 0 1
100300: NOT
100301: IFFALSE 100305
// exit ;
100303: GO 100360
// result := [ ] ;
100305: LD_ADDR_VAR 0 2
100309: PUSH
100310: EMPTY
100311: ST_TO_ADDR
// for i := array downto 1 do
100312: LD_ADDR_VAR 0 3
100316: PUSH
100317: DOUBLE
100318: LD_VAR 0 1
100322: INC
100323: ST_TO_ADDR
100324: LD_INT 1
100326: PUSH
100327: FOR_DOWNTO
100328: IFFALSE 100358
// result := Join ( result , array [ i ] ) ;
100330: LD_ADDR_VAR 0 2
100334: PUSH
100335: LD_VAR 0 2
100339: PPUSH
100340: LD_VAR 0 1
100344: PUSH
100345: LD_VAR 0 3
100349: ARRAY
100350: PPUSH
100351: CALL 105004 0 2
100355: ST_TO_ADDR
100356: GO 100327
100358: POP
100359: POP
// end ;
100360: LD_VAR 0 2
100364: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100365: LD_INT 0
100367: PPUSH
100368: PPUSH
100369: PPUSH
100370: PPUSH
100371: PPUSH
100372: PPUSH
// if not unit or not hexes then
100373: LD_VAR 0 1
100377: NOT
100378: PUSH
100379: LD_VAR 0 2
100383: NOT
100384: OR
100385: IFFALSE 100389
// exit ;
100387: GO 100512
// dist := 9999 ;
100389: LD_ADDR_VAR 0 5
100393: PUSH
100394: LD_INT 9999
100396: ST_TO_ADDR
// for i = 1 to hexes do
100397: LD_ADDR_VAR 0 4
100401: PUSH
100402: DOUBLE
100403: LD_INT 1
100405: DEC
100406: ST_TO_ADDR
100407: LD_VAR 0 2
100411: PUSH
100412: FOR_TO
100413: IFFALSE 100500
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100415: LD_ADDR_VAR 0 6
100419: PUSH
100420: LD_VAR 0 1
100424: PPUSH
100425: LD_VAR 0 2
100429: PUSH
100430: LD_VAR 0 4
100434: ARRAY
100435: PUSH
100436: LD_INT 1
100438: ARRAY
100439: PPUSH
100440: LD_VAR 0 2
100444: PUSH
100445: LD_VAR 0 4
100449: ARRAY
100450: PUSH
100451: LD_INT 2
100453: ARRAY
100454: PPUSH
100455: CALL_OW 297
100459: ST_TO_ADDR
// if tdist < dist then
100460: LD_VAR 0 6
100464: PUSH
100465: LD_VAR 0 5
100469: LESS
100470: IFFALSE 100498
// begin hex := hexes [ i ] ;
100472: LD_ADDR_VAR 0 8
100476: PUSH
100477: LD_VAR 0 2
100481: PUSH
100482: LD_VAR 0 4
100486: ARRAY
100487: ST_TO_ADDR
// dist := tdist ;
100488: LD_ADDR_VAR 0 5
100492: PUSH
100493: LD_VAR 0 6
100497: ST_TO_ADDR
// end ; end ;
100498: GO 100412
100500: POP
100501: POP
// result := hex ;
100502: LD_ADDR_VAR 0 3
100506: PUSH
100507: LD_VAR 0 8
100511: ST_TO_ADDR
// end ;
100512: LD_VAR 0 3
100516: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100517: LD_INT 0
100519: PPUSH
100520: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100521: LD_VAR 0 1
100525: NOT
100526: PUSH
100527: LD_VAR 0 1
100531: PUSH
100532: LD_INT 21
100534: PUSH
100535: LD_INT 2
100537: PUSH
100538: EMPTY
100539: LIST
100540: LIST
100541: PUSH
100542: LD_INT 23
100544: PUSH
100545: LD_INT 2
100547: PUSH
100548: EMPTY
100549: LIST
100550: LIST
100551: PUSH
100552: EMPTY
100553: LIST
100554: LIST
100555: PPUSH
100556: CALL_OW 69
100560: IN
100561: NOT
100562: OR
100563: IFFALSE 100567
// exit ;
100565: GO 100614
// for i = 1 to 3 do
100567: LD_ADDR_VAR 0 3
100571: PUSH
100572: DOUBLE
100573: LD_INT 1
100575: DEC
100576: ST_TO_ADDR
100577: LD_INT 3
100579: PUSH
100580: FOR_TO
100581: IFFALSE 100612
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100583: LD_VAR 0 1
100587: PPUSH
100588: CALL_OW 250
100592: PPUSH
100593: LD_VAR 0 1
100597: PPUSH
100598: CALL_OW 251
100602: PPUSH
100603: LD_INT 1
100605: PPUSH
100606: CALL_OW 453
100610: GO 100580
100612: POP
100613: POP
// end ;
100614: LD_VAR 0 2
100618: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100619: LD_INT 0
100621: PPUSH
100622: PPUSH
100623: PPUSH
100624: PPUSH
100625: PPUSH
100626: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100627: LD_VAR 0 1
100631: NOT
100632: PUSH
100633: LD_VAR 0 2
100637: NOT
100638: OR
100639: PUSH
100640: LD_VAR 0 1
100644: PPUSH
100645: CALL_OW 314
100649: OR
100650: IFFALSE 100654
// exit ;
100652: GO 101121
// if GetLives ( i ) < 250 then
100654: LD_VAR 0 4
100658: PPUSH
100659: CALL_OW 256
100663: PUSH
100664: LD_INT 250
100666: LESS
100667: IFFALSE 100680
// begin ComAutodestruct ( i ) ;
100669: LD_VAR 0 4
100673: PPUSH
100674: CALL 100517 0 1
// exit ;
100678: GO 101121
// end ; x := GetX ( enemy_unit ) ;
100680: LD_ADDR_VAR 0 7
100684: PUSH
100685: LD_VAR 0 2
100689: PPUSH
100690: CALL_OW 250
100694: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100695: LD_ADDR_VAR 0 8
100699: PUSH
100700: LD_VAR 0 2
100704: PPUSH
100705: CALL_OW 251
100709: ST_TO_ADDR
// if not x or not y then
100710: LD_VAR 0 7
100714: NOT
100715: PUSH
100716: LD_VAR 0 8
100720: NOT
100721: OR
100722: IFFALSE 100726
// exit ;
100724: GO 101121
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100726: LD_ADDR_VAR 0 6
100730: PUSH
100731: LD_VAR 0 7
100735: PPUSH
100736: LD_INT 0
100738: PPUSH
100739: LD_INT 4
100741: PPUSH
100742: CALL_OW 272
100746: PUSH
100747: LD_VAR 0 8
100751: PPUSH
100752: LD_INT 0
100754: PPUSH
100755: LD_INT 4
100757: PPUSH
100758: CALL_OW 273
100762: PUSH
100763: EMPTY
100764: LIST
100765: LIST
100766: PUSH
100767: LD_VAR 0 7
100771: PPUSH
100772: LD_INT 1
100774: PPUSH
100775: LD_INT 4
100777: PPUSH
100778: CALL_OW 272
100782: PUSH
100783: LD_VAR 0 8
100787: PPUSH
100788: LD_INT 1
100790: PPUSH
100791: LD_INT 4
100793: PPUSH
100794: CALL_OW 273
100798: PUSH
100799: EMPTY
100800: LIST
100801: LIST
100802: PUSH
100803: LD_VAR 0 7
100807: PPUSH
100808: LD_INT 2
100810: PPUSH
100811: LD_INT 4
100813: PPUSH
100814: CALL_OW 272
100818: PUSH
100819: LD_VAR 0 8
100823: PPUSH
100824: LD_INT 2
100826: PPUSH
100827: LD_INT 4
100829: PPUSH
100830: CALL_OW 273
100834: PUSH
100835: EMPTY
100836: LIST
100837: LIST
100838: PUSH
100839: LD_VAR 0 7
100843: PPUSH
100844: LD_INT 3
100846: PPUSH
100847: LD_INT 4
100849: PPUSH
100850: CALL_OW 272
100854: PUSH
100855: LD_VAR 0 8
100859: PPUSH
100860: LD_INT 3
100862: PPUSH
100863: LD_INT 4
100865: PPUSH
100866: CALL_OW 273
100870: PUSH
100871: EMPTY
100872: LIST
100873: LIST
100874: PUSH
100875: LD_VAR 0 7
100879: PPUSH
100880: LD_INT 4
100882: PPUSH
100883: LD_INT 4
100885: PPUSH
100886: CALL_OW 272
100890: PUSH
100891: LD_VAR 0 8
100895: PPUSH
100896: LD_INT 4
100898: PPUSH
100899: LD_INT 4
100901: PPUSH
100902: CALL_OW 273
100906: PUSH
100907: EMPTY
100908: LIST
100909: LIST
100910: PUSH
100911: LD_VAR 0 7
100915: PPUSH
100916: LD_INT 5
100918: PPUSH
100919: LD_INT 4
100921: PPUSH
100922: CALL_OW 272
100926: PUSH
100927: LD_VAR 0 8
100931: PPUSH
100932: LD_INT 5
100934: PPUSH
100935: LD_INT 4
100937: PPUSH
100938: CALL_OW 273
100942: PUSH
100943: EMPTY
100944: LIST
100945: LIST
100946: PUSH
100947: EMPTY
100948: LIST
100949: LIST
100950: LIST
100951: LIST
100952: LIST
100953: LIST
100954: ST_TO_ADDR
// for i = tmp downto 1 do
100955: LD_ADDR_VAR 0 4
100959: PUSH
100960: DOUBLE
100961: LD_VAR 0 6
100965: INC
100966: ST_TO_ADDR
100967: LD_INT 1
100969: PUSH
100970: FOR_DOWNTO
100971: IFFALSE 101072
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
100973: LD_VAR 0 6
100977: PUSH
100978: LD_VAR 0 4
100982: ARRAY
100983: PUSH
100984: LD_INT 1
100986: ARRAY
100987: PPUSH
100988: LD_VAR 0 6
100992: PUSH
100993: LD_VAR 0 4
100997: ARRAY
100998: PUSH
100999: LD_INT 2
101001: ARRAY
101002: PPUSH
101003: CALL_OW 488
101007: NOT
101008: PUSH
101009: LD_VAR 0 6
101013: PUSH
101014: LD_VAR 0 4
101018: ARRAY
101019: PUSH
101020: LD_INT 1
101022: ARRAY
101023: PPUSH
101024: LD_VAR 0 6
101028: PUSH
101029: LD_VAR 0 4
101033: ARRAY
101034: PUSH
101035: LD_INT 2
101037: ARRAY
101038: PPUSH
101039: CALL_OW 428
101043: PUSH
101044: LD_INT 0
101046: NONEQUAL
101047: OR
101048: IFFALSE 101070
// tmp := Delete ( tmp , i ) ;
101050: LD_ADDR_VAR 0 6
101054: PUSH
101055: LD_VAR 0 6
101059: PPUSH
101060: LD_VAR 0 4
101064: PPUSH
101065: CALL_OW 3
101069: ST_TO_ADDR
101070: GO 100970
101072: POP
101073: POP
// j := GetClosestHex ( unit , tmp ) ;
101074: LD_ADDR_VAR 0 5
101078: PUSH
101079: LD_VAR 0 1
101083: PPUSH
101084: LD_VAR 0 6
101088: PPUSH
101089: CALL 100365 0 2
101093: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
101094: LD_VAR 0 1
101098: PPUSH
101099: LD_VAR 0 5
101103: PUSH
101104: LD_INT 1
101106: ARRAY
101107: PPUSH
101108: LD_VAR 0 5
101112: PUSH
101113: LD_INT 2
101115: ARRAY
101116: PPUSH
101117: CALL_OW 111
// end ;
101121: LD_VAR 0 3
101125: RET
// export function PrepareApemanSoldier ( ) ; begin
101126: LD_INT 0
101128: PPUSH
// uc_nation := 0 ;
101129: LD_ADDR_OWVAR 21
101133: PUSH
101134: LD_INT 0
101136: ST_TO_ADDR
// hc_sex := sex_male ;
101137: LD_ADDR_OWVAR 27
101141: PUSH
101142: LD_INT 1
101144: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
101145: LD_ADDR_OWVAR 28
101149: PUSH
101150: LD_INT 15
101152: ST_TO_ADDR
// hc_gallery :=  ;
101153: LD_ADDR_OWVAR 33
101157: PUSH
101158: LD_STRING 
101160: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101161: LD_ADDR_OWVAR 31
101165: PUSH
101166: LD_INT 0
101168: PPUSH
101169: LD_INT 3
101171: PPUSH
101172: CALL_OW 12
101176: PUSH
101177: LD_INT 0
101179: PPUSH
101180: LD_INT 3
101182: PPUSH
101183: CALL_OW 12
101187: PUSH
101188: LD_INT 0
101190: PUSH
101191: LD_INT 0
101193: PUSH
101194: EMPTY
101195: LIST
101196: LIST
101197: LIST
101198: LIST
101199: ST_TO_ADDR
// end ;
101200: LD_VAR 0 1
101204: RET
// export function PrepareApemanEngineer ( ) ; begin
101205: LD_INT 0
101207: PPUSH
// uc_nation := 0 ;
101208: LD_ADDR_OWVAR 21
101212: PUSH
101213: LD_INT 0
101215: ST_TO_ADDR
// hc_sex := sex_male ;
101216: LD_ADDR_OWVAR 27
101220: PUSH
101221: LD_INT 1
101223: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
101224: LD_ADDR_OWVAR 28
101228: PUSH
101229: LD_INT 16
101231: ST_TO_ADDR
// hc_gallery :=  ;
101232: LD_ADDR_OWVAR 33
101236: PUSH
101237: LD_STRING 
101239: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101240: LD_ADDR_OWVAR 31
101244: PUSH
101245: LD_INT 0
101247: PPUSH
101248: LD_INT 3
101250: PPUSH
101251: CALL_OW 12
101255: PUSH
101256: LD_INT 0
101258: PPUSH
101259: LD_INT 3
101261: PPUSH
101262: CALL_OW 12
101266: PUSH
101267: LD_INT 0
101269: PUSH
101270: LD_INT 0
101272: PUSH
101273: EMPTY
101274: LIST
101275: LIST
101276: LIST
101277: LIST
101278: ST_TO_ADDR
// end ;
101279: LD_VAR 0 1
101283: RET
// export function PrepareApeman ( agressivity ) ; begin
101284: LD_INT 0
101286: PPUSH
// uc_side := 0 ;
101287: LD_ADDR_OWVAR 20
101291: PUSH
101292: LD_INT 0
101294: ST_TO_ADDR
// uc_nation := 0 ;
101295: LD_ADDR_OWVAR 21
101299: PUSH
101300: LD_INT 0
101302: ST_TO_ADDR
// hc_sex := sex_male ;
101303: LD_ADDR_OWVAR 27
101307: PUSH
101308: LD_INT 1
101310: ST_TO_ADDR
// hc_class := class_apeman ;
101311: LD_ADDR_OWVAR 28
101315: PUSH
101316: LD_INT 12
101318: ST_TO_ADDR
// hc_gallery :=  ;
101319: LD_ADDR_OWVAR 33
101323: PUSH
101324: LD_STRING 
101326: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101327: LD_ADDR_OWVAR 35
101331: PUSH
101332: LD_VAR 0 1
101336: NEG
101337: PPUSH
101338: LD_VAR 0 1
101342: PPUSH
101343: CALL_OW 12
101347: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101348: LD_ADDR_OWVAR 31
101352: PUSH
101353: LD_INT 0
101355: PPUSH
101356: LD_INT 3
101358: PPUSH
101359: CALL_OW 12
101363: PUSH
101364: LD_INT 0
101366: PPUSH
101367: LD_INT 3
101369: PPUSH
101370: CALL_OW 12
101374: PUSH
101375: LD_INT 0
101377: PUSH
101378: LD_INT 0
101380: PUSH
101381: EMPTY
101382: LIST
101383: LIST
101384: LIST
101385: LIST
101386: ST_TO_ADDR
// end ;
101387: LD_VAR 0 2
101391: RET
// export function PrepareTiger ( agressivity ) ; begin
101392: LD_INT 0
101394: PPUSH
// uc_side := 0 ;
101395: LD_ADDR_OWVAR 20
101399: PUSH
101400: LD_INT 0
101402: ST_TO_ADDR
// uc_nation := 0 ;
101403: LD_ADDR_OWVAR 21
101407: PUSH
101408: LD_INT 0
101410: ST_TO_ADDR
// hc_class := class_tiger ;
101411: LD_ADDR_OWVAR 28
101415: PUSH
101416: LD_INT 14
101418: ST_TO_ADDR
// hc_gallery :=  ;
101419: LD_ADDR_OWVAR 33
101423: PUSH
101424: LD_STRING 
101426: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101427: LD_ADDR_OWVAR 35
101431: PUSH
101432: LD_VAR 0 1
101436: NEG
101437: PPUSH
101438: LD_VAR 0 1
101442: PPUSH
101443: CALL_OW 12
101447: ST_TO_ADDR
// end ;
101448: LD_VAR 0 2
101452: RET
// export function PrepareEnchidna ( ) ; begin
101453: LD_INT 0
101455: PPUSH
// uc_side := 0 ;
101456: LD_ADDR_OWVAR 20
101460: PUSH
101461: LD_INT 0
101463: ST_TO_ADDR
// uc_nation := 0 ;
101464: LD_ADDR_OWVAR 21
101468: PUSH
101469: LD_INT 0
101471: ST_TO_ADDR
// hc_class := class_baggie ;
101472: LD_ADDR_OWVAR 28
101476: PUSH
101477: LD_INT 13
101479: ST_TO_ADDR
// hc_gallery :=  ;
101480: LD_ADDR_OWVAR 33
101484: PUSH
101485: LD_STRING 
101487: ST_TO_ADDR
// end ;
101488: LD_VAR 0 1
101492: RET
// export function PrepareFrog ( ) ; begin
101493: LD_INT 0
101495: PPUSH
// uc_side := 0 ;
101496: LD_ADDR_OWVAR 20
101500: PUSH
101501: LD_INT 0
101503: ST_TO_ADDR
// uc_nation := 0 ;
101504: LD_ADDR_OWVAR 21
101508: PUSH
101509: LD_INT 0
101511: ST_TO_ADDR
// hc_class := class_frog ;
101512: LD_ADDR_OWVAR 28
101516: PUSH
101517: LD_INT 19
101519: ST_TO_ADDR
// hc_gallery :=  ;
101520: LD_ADDR_OWVAR 33
101524: PUSH
101525: LD_STRING 
101527: ST_TO_ADDR
// end ;
101528: LD_VAR 0 1
101532: RET
// export function PrepareFish ( ) ; begin
101533: LD_INT 0
101535: PPUSH
// uc_side := 0 ;
101536: LD_ADDR_OWVAR 20
101540: PUSH
101541: LD_INT 0
101543: ST_TO_ADDR
// uc_nation := 0 ;
101544: LD_ADDR_OWVAR 21
101548: PUSH
101549: LD_INT 0
101551: ST_TO_ADDR
// hc_class := class_fish ;
101552: LD_ADDR_OWVAR 28
101556: PUSH
101557: LD_INT 20
101559: ST_TO_ADDR
// hc_gallery :=  ;
101560: LD_ADDR_OWVAR 33
101564: PUSH
101565: LD_STRING 
101567: ST_TO_ADDR
// end ;
101568: LD_VAR 0 1
101572: RET
// export function PrepareBird ( ) ; begin
101573: LD_INT 0
101575: PPUSH
// uc_side := 0 ;
101576: LD_ADDR_OWVAR 20
101580: PUSH
101581: LD_INT 0
101583: ST_TO_ADDR
// uc_nation := 0 ;
101584: LD_ADDR_OWVAR 21
101588: PUSH
101589: LD_INT 0
101591: ST_TO_ADDR
// hc_class := class_phororhacos ;
101592: LD_ADDR_OWVAR 28
101596: PUSH
101597: LD_INT 18
101599: ST_TO_ADDR
// hc_gallery :=  ;
101600: LD_ADDR_OWVAR 33
101604: PUSH
101605: LD_STRING 
101607: ST_TO_ADDR
// end ;
101608: LD_VAR 0 1
101612: RET
// export function PrepareHorse ( ) ; begin
101613: LD_INT 0
101615: PPUSH
// uc_side := 0 ;
101616: LD_ADDR_OWVAR 20
101620: PUSH
101621: LD_INT 0
101623: ST_TO_ADDR
// uc_nation := 0 ;
101624: LD_ADDR_OWVAR 21
101628: PUSH
101629: LD_INT 0
101631: ST_TO_ADDR
// hc_class := class_horse ;
101632: LD_ADDR_OWVAR 28
101636: PUSH
101637: LD_INT 21
101639: ST_TO_ADDR
// hc_gallery :=  ;
101640: LD_ADDR_OWVAR 33
101644: PUSH
101645: LD_STRING 
101647: ST_TO_ADDR
// end ;
101648: LD_VAR 0 1
101652: RET
// export function PrepareMastodont ( ) ; begin
101653: LD_INT 0
101655: PPUSH
// uc_side := 0 ;
101656: LD_ADDR_OWVAR 20
101660: PUSH
101661: LD_INT 0
101663: ST_TO_ADDR
// uc_nation := 0 ;
101664: LD_ADDR_OWVAR 21
101668: PUSH
101669: LD_INT 0
101671: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101672: LD_ADDR_OWVAR 37
101676: PUSH
101677: LD_INT 31
101679: ST_TO_ADDR
// vc_control := control_rider ;
101680: LD_ADDR_OWVAR 38
101684: PUSH
101685: LD_INT 4
101687: ST_TO_ADDR
// end ;
101688: LD_VAR 0 1
101692: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101693: LD_INT 0
101695: PPUSH
101696: PPUSH
101697: PPUSH
// uc_side = 0 ;
101698: LD_ADDR_OWVAR 20
101702: PUSH
101703: LD_INT 0
101705: ST_TO_ADDR
// uc_nation = 0 ;
101706: LD_ADDR_OWVAR 21
101710: PUSH
101711: LD_INT 0
101713: ST_TO_ADDR
// InitHc_All ( ) ;
101714: CALL_OW 584
// InitVc ;
101718: CALL_OW 20
// if mastodonts then
101722: LD_VAR 0 6
101726: IFFALSE 101793
// for i = 1 to mastodonts do
101728: LD_ADDR_VAR 0 11
101732: PUSH
101733: DOUBLE
101734: LD_INT 1
101736: DEC
101737: ST_TO_ADDR
101738: LD_VAR 0 6
101742: PUSH
101743: FOR_TO
101744: IFFALSE 101791
// begin vc_chassis := 31 ;
101746: LD_ADDR_OWVAR 37
101750: PUSH
101751: LD_INT 31
101753: ST_TO_ADDR
// vc_control := control_rider ;
101754: LD_ADDR_OWVAR 38
101758: PUSH
101759: LD_INT 4
101761: ST_TO_ADDR
// animal := CreateVehicle ;
101762: LD_ADDR_VAR 0 12
101766: PUSH
101767: CALL_OW 45
101771: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101772: LD_VAR 0 12
101776: PPUSH
101777: LD_VAR 0 8
101781: PPUSH
101782: LD_INT 0
101784: PPUSH
101785: CALL 103921 0 3
// end ;
101789: GO 101743
101791: POP
101792: POP
// if horses then
101793: LD_VAR 0 5
101797: IFFALSE 101864
// for i = 1 to horses do
101799: LD_ADDR_VAR 0 11
101803: PUSH
101804: DOUBLE
101805: LD_INT 1
101807: DEC
101808: ST_TO_ADDR
101809: LD_VAR 0 5
101813: PUSH
101814: FOR_TO
101815: IFFALSE 101862
// begin hc_class := 21 ;
101817: LD_ADDR_OWVAR 28
101821: PUSH
101822: LD_INT 21
101824: ST_TO_ADDR
// hc_gallery :=  ;
101825: LD_ADDR_OWVAR 33
101829: PUSH
101830: LD_STRING 
101832: ST_TO_ADDR
// animal := CreateHuman ;
101833: LD_ADDR_VAR 0 12
101837: PUSH
101838: CALL_OW 44
101842: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101843: LD_VAR 0 12
101847: PPUSH
101848: LD_VAR 0 8
101852: PPUSH
101853: LD_INT 0
101855: PPUSH
101856: CALL 103921 0 3
// end ;
101860: GO 101814
101862: POP
101863: POP
// if birds then
101864: LD_VAR 0 1
101868: IFFALSE 101935
// for i = 1 to birds do
101870: LD_ADDR_VAR 0 11
101874: PUSH
101875: DOUBLE
101876: LD_INT 1
101878: DEC
101879: ST_TO_ADDR
101880: LD_VAR 0 1
101884: PUSH
101885: FOR_TO
101886: IFFALSE 101933
// begin hc_class = 18 ;
101888: LD_ADDR_OWVAR 28
101892: PUSH
101893: LD_INT 18
101895: ST_TO_ADDR
// hc_gallery =  ;
101896: LD_ADDR_OWVAR 33
101900: PUSH
101901: LD_STRING 
101903: ST_TO_ADDR
// animal := CreateHuman ;
101904: LD_ADDR_VAR 0 12
101908: PUSH
101909: CALL_OW 44
101913: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101914: LD_VAR 0 12
101918: PPUSH
101919: LD_VAR 0 8
101923: PPUSH
101924: LD_INT 0
101926: PPUSH
101927: CALL 103921 0 3
// end ;
101931: GO 101885
101933: POP
101934: POP
// if tigers then
101935: LD_VAR 0 2
101939: IFFALSE 102023
// for i = 1 to tigers do
101941: LD_ADDR_VAR 0 11
101945: PUSH
101946: DOUBLE
101947: LD_INT 1
101949: DEC
101950: ST_TO_ADDR
101951: LD_VAR 0 2
101955: PUSH
101956: FOR_TO
101957: IFFALSE 102021
// begin hc_class = class_tiger ;
101959: LD_ADDR_OWVAR 28
101963: PUSH
101964: LD_INT 14
101966: ST_TO_ADDR
// hc_gallery =  ;
101967: LD_ADDR_OWVAR 33
101971: PUSH
101972: LD_STRING 
101974: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
101975: LD_ADDR_OWVAR 35
101979: PUSH
101980: LD_INT 7
101982: NEG
101983: PPUSH
101984: LD_INT 7
101986: PPUSH
101987: CALL_OW 12
101991: ST_TO_ADDR
// animal := CreateHuman ;
101992: LD_ADDR_VAR 0 12
101996: PUSH
101997: CALL_OW 44
102001: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102002: LD_VAR 0 12
102006: PPUSH
102007: LD_VAR 0 8
102011: PPUSH
102012: LD_INT 0
102014: PPUSH
102015: CALL 103921 0 3
// end ;
102019: GO 101956
102021: POP
102022: POP
// if apemans then
102023: LD_VAR 0 3
102027: IFFALSE 102150
// for i = 1 to apemans do
102029: LD_ADDR_VAR 0 11
102033: PUSH
102034: DOUBLE
102035: LD_INT 1
102037: DEC
102038: ST_TO_ADDR
102039: LD_VAR 0 3
102043: PUSH
102044: FOR_TO
102045: IFFALSE 102148
// begin hc_class = class_apeman ;
102047: LD_ADDR_OWVAR 28
102051: PUSH
102052: LD_INT 12
102054: ST_TO_ADDR
// hc_gallery =  ;
102055: LD_ADDR_OWVAR 33
102059: PUSH
102060: LD_STRING 
102062: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
102063: LD_ADDR_OWVAR 35
102067: PUSH
102068: LD_INT 2
102070: NEG
102071: PPUSH
102072: LD_INT 2
102074: PPUSH
102075: CALL_OW 12
102079: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
102080: LD_ADDR_OWVAR 31
102084: PUSH
102085: LD_INT 1
102087: PPUSH
102088: LD_INT 3
102090: PPUSH
102091: CALL_OW 12
102095: PUSH
102096: LD_INT 1
102098: PPUSH
102099: LD_INT 3
102101: PPUSH
102102: CALL_OW 12
102106: PUSH
102107: LD_INT 0
102109: PUSH
102110: LD_INT 0
102112: PUSH
102113: EMPTY
102114: LIST
102115: LIST
102116: LIST
102117: LIST
102118: ST_TO_ADDR
// animal := CreateHuman ;
102119: LD_ADDR_VAR 0 12
102123: PUSH
102124: CALL_OW 44
102128: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102129: LD_VAR 0 12
102133: PPUSH
102134: LD_VAR 0 8
102138: PPUSH
102139: LD_INT 0
102141: PPUSH
102142: CALL 103921 0 3
// end ;
102146: GO 102044
102148: POP
102149: POP
// if enchidnas then
102150: LD_VAR 0 4
102154: IFFALSE 102221
// for i = 1 to enchidnas do
102156: LD_ADDR_VAR 0 11
102160: PUSH
102161: DOUBLE
102162: LD_INT 1
102164: DEC
102165: ST_TO_ADDR
102166: LD_VAR 0 4
102170: PUSH
102171: FOR_TO
102172: IFFALSE 102219
// begin hc_class = 13 ;
102174: LD_ADDR_OWVAR 28
102178: PUSH
102179: LD_INT 13
102181: ST_TO_ADDR
// hc_gallery =  ;
102182: LD_ADDR_OWVAR 33
102186: PUSH
102187: LD_STRING 
102189: ST_TO_ADDR
// animal := CreateHuman ;
102190: LD_ADDR_VAR 0 12
102194: PUSH
102195: CALL_OW 44
102199: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102200: LD_VAR 0 12
102204: PPUSH
102205: LD_VAR 0 8
102209: PPUSH
102210: LD_INT 0
102212: PPUSH
102213: CALL 103921 0 3
// end ;
102217: GO 102171
102219: POP
102220: POP
// if fishes then
102221: LD_VAR 0 7
102225: IFFALSE 102292
// for i = 1 to fishes do
102227: LD_ADDR_VAR 0 11
102231: PUSH
102232: DOUBLE
102233: LD_INT 1
102235: DEC
102236: ST_TO_ADDR
102237: LD_VAR 0 7
102241: PUSH
102242: FOR_TO
102243: IFFALSE 102290
// begin hc_class = 20 ;
102245: LD_ADDR_OWVAR 28
102249: PUSH
102250: LD_INT 20
102252: ST_TO_ADDR
// hc_gallery =  ;
102253: LD_ADDR_OWVAR 33
102257: PUSH
102258: LD_STRING 
102260: ST_TO_ADDR
// animal := CreateHuman ;
102261: LD_ADDR_VAR 0 12
102265: PUSH
102266: CALL_OW 44
102270: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
102271: LD_VAR 0 12
102275: PPUSH
102276: LD_VAR 0 9
102280: PPUSH
102281: LD_INT 0
102283: PPUSH
102284: CALL 103921 0 3
// end ;
102288: GO 102242
102290: POP
102291: POP
// end ;
102292: LD_VAR 0 10
102296: RET
// export function WantHeal ( sci , unit ) ; begin
102297: LD_INT 0
102299: PPUSH
// if GetTaskList ( sci ) > 0 then
102300: LD_VAR 0 1
102304: PPUSH
102305: CALL_OW 437
102309: PUSH
102310: LD_INT 0
102312: GREATER
102313: IFFALSE 102383
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
102315: LD_VAR 0 1
102319: PPUSH
102320: CALL_OW 437
102324: PUSH
102325: LD_INT 1
102327: ARRAY
102328: PUSH
102329: LD_INT 1
102331: ARRAY
102332: PUSH
102333: LD_STRING l
102335: EQUAL
102336: PUSH
102337: LD_VAR 0 1
102341: PPUSH
102342: CALL_OW 437
102346: PUSH
102347: LD_INT 1
102349: ARRAY
102350: PUSH
102351: LD_INT 4
102353: ARRAY
102354: PUSH
102355: LD_VAR 0 2
102359: EQUAL
102360: AND
102361: IFFALSE 102373
// result := true else
102363: LD_ADDR_VAR 0 3
102367: PUSH
102368: LD_INT 1
102370: ST_TO_ADDR
102371: GO 102381
// result := false ;
102373: LD_ADDR_VAR 0 3
102377: PUSH
102378: LD_INT 0
102380: ST_TO_ADDR
// end else
102381: GO 102391
// result := false ;
102383: LD_ADDR_VAR 0 3
102387: PUSH
102388: LD_INT 0
102390: ST_TO_ADDR
// end ;
102391: LD_VAR 0 3
102395: RET
// export function HealTarget ( sci ) ; begin
102396: LD_INT 0
102398: PPUSH
// if not sci then
102399: LD_VAR 0 1
102403: NOT
102404: IFFALSE 102408
// exit ;
102406: GO 102473
// result := 0 ;
102408: LD_ADDR_VAR 0 2
102412: PUSH
102413: LD_INT 0
102415: ST_TO_ADDR
// if GetTaskList ( sci ) then
102416: LD_VAR 0 1
102420: PPUSH
102421: CALL_OW 437
102425: IFFALSE 102473
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102427: LD_VAR 0 1
102431: PPUSH
102432: CALL_OW 437
102436: PUSH
102437: LD_INT 1
102439: ARRAY
102440: PUSH
102441: LD_INT 1
102443: ARRAY
102444: PUSH
102445: LD_STRING l
102447: EQUAL
102448: IFFALSE 102473
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102450: LD_ADDR_VAR 0 2
102454: PUSH
102455: LD_VAR 0 1
102459: PPUSH
102460: CALL_OW 437
102464: PUSH
102465: LD_INT 1
102467: ARRAY
102468: PUSH
102469: LD_INT 4
102471: ARRAY
102472: ST_TO_ADDR
// end ;
102473: LD_VAR 0 2
102477: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102478: LD_INT 0
102480: PPUSH
102481: PPUSH
102482: PPUSH
102483: PPUSH
// if not base_units then
102484: LD_VAR 0 1
102488: NOT
102489: IFFALSE 102493
// exit ;
102491: GO 102580
// result := false ;
102493: LD_ADDR_VAR 0 2
102497: PUSH
102498: LD_INT 0
102500: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102501: LD_ADDR_VAR 0 5
102505: PUSH
102506: LD_VAR 0 1
102510: PPUSH
102511: LD_INT 21
102513: PUSH
102514: LD_INT 3
102516: PUSH
102517: EMPTY
102518: LIST
102519: LIST
102520: PPUSH
102521: CALL_OW 72
102525: ST_TO_ADDR
// if not tmp then
102526: LD_VAR 0 5
102530: NOT
102531: IFFALSE 102535
// exit ;
102533: GO 102580
// for i in tmp do
102535: LD_ADDR_VAR 0 3
102539: PUSH
102540: LD_VAR 0 5
102544: PUSH
102545: FOR_IN
102546: IFFALSE 102578
// begin result := EnemyInRange ( i , 22 ) ;
102548: LD_ADDR_VAR 0 2
102552: PUSH
102553: LD_VAR 0 3
102557: PPUSH
102558: LD_INT 22
102560: PPUSH
102561: CALL 100167 0 2
102565: ST_TO_ADDR
// if result then
102566: LD_VAR 0 2
102570: IFFALSE 102576
// exit ;
102572: POP
102573: POP
102574: GO 102580
// end ;
102576: GO 102545
102578: POP
102579: POP
// end ;
102580: LD_VAR 0 2
102584: RET
// export function FilterByTag ( units , tag ) ; begin
102585: LD_INT 0
102587: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102588: LD_ADDR_VAR 0 3
102592: PUSH
102593: LD_VAR 0 1
102597: PPUSH
102598: LD_INT 120
102600: PUSH
102601: LD_VAR 0 2
102605: PUSH
102606: EMPTY
102607: LIST
102608: LIST
102609: PPUSH
102610: CALL_OW 72
102614: ST_TO_ADDR
// end ;
102615: LD_VAR 0 3
102619: RET
// export function IsDriver ( un ) ; begin
102620: LD_INT 0
102622: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102623: LD_ADDR_VAR 0 2
102627: PUSH
102628: LD_VAR 0 1
102632: PUSH
102633: LD_INT 55
102635: PUSH
102636: EMPTY
102637: LIST
102638: PPUSH
102639: CALL_OW 69
102643: IN
102644: ST_TO_ADDR
// end ;
102645: LD_VAR 0 2
102649: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102650: LD_INT 0
102652: PPUSH
102653: PPUSH
// list := [ ] ;
102654: LD_ADDR_VAR 0 5
102658: PUSH
102659: EMPTY
102660: ST_TO_ADDR
// case d of 0 :
102661: LD_VAR 0 3
102665: PUSH
102666: LD_INT 0
102668: DOUBLE
102669: EQUAL
102670: IFTRUE 102674
102672: GO 102807
102674: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102675: LD_ADDR_VAR 0 5
102679: PUSH
102680: LD_VAR 0 1
102684: PUSH
102685: LD_INT 4
102687: MINUS
102688: PUSH
102689: LD_VAR 0 2
102693: PUSH
102694: LD_INT 4
102696: MINUS
102697: PUSH
102698: LD_INT 2
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: LIST
102705: PUSH
102706: LD_VAR 0 1
102710: PUSH
102711: LD_INT 3
102713: MINUS
102714: PUSH
102715: LD_VAR 0 2
102719: PUSH
102720: LD_INT 1
102722: PUSH
102723: EMPTY
102724: LIST
102725: LIST
102726: LIST
102727: PUSH
102728: LD_VAR 0 1
102732: PUSH
102733: LD_INT 4
102735: PLUS
102736: PUSH
102737: LD_VAR 0 2
102741: PUSH
102742: LD_INT 4
102744: PUSH
102745: EMPTY
102746: LIST
102747: LIST
102748: LIST
102749: PUSH
102750: LD_VAR 0 1
102754: PUSH
102755: LD_INT 3
102757: PLUS
102758: PUSH
102759: LD_VAR 0 2
102763: PUSH
102764: LD_INT 3
102766: PLUS
102767: PUSH
102768: LD_INT 5
102770: PUSH
102771: EMPTY
102772: LIST
102773: LIST
102774: LIST
102775: PUSH
102776: LD_VAR 0 1
102780: PUSH
102781: LD_VAR 0 2
102785: PUSH
102786: LD_INT 4
102788: PLUS
102789: PUSH
102790: LD_INT 0
102792: PUSH
102793: EMPTY
102794: LIST
102795: LIST
102796: LIST
102797: PUSH
102798: EMPTY
102799: LIST
102800: LIST
102801: LIST
102802: LIST
102803: LIST
102804: ST_TO_ADDR
// end ; 1 :
102805: GO 103505
102807: LD_INT 1
102809: DOUBLE
102810: EQUAL
102811: IFTRUE 102815
102813: GO 102948
102815: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102816: LD_ADDR_VAR 0 5
102820: PUSH
102821: LD_VAR 0 1
102825: PUSH
102826: LD_VAR 0 2
102830: PUSH
102831: LD_INT 4
102833: MINUS
102834: PUSH
102835: LD_INT 3
102837: PUSH
102838: EMPTY
102839: LIST
102840: LIST
102841: LIST
102842: PUSH
102843: LD_VAR 0 1
102847: PUSH
102848: LD_INT 3
102850: MINUS
102851: PUSH
102852: LD_VAR 0 2
102856: PUSH
102857: LD_INT 3
102859: MINUS
102860: PUSH
102861: LD_INT 2
102863: PUSH
102864: EMPTY
102865: LIST
102866: LIST
102867: LIST
102868: PUSH
102869: LD_VAR 0 1
102873: PUSH
102874: LD_INT 4
102876: MINUS
102877: PUSH
102878: LD_VAR 0 2
102882: PUSH
102883: LD_INT 1
102885: PUSH
102886: EMPTY
102887: LIST
102888: LIST
102889: LIST
102890: PUSH
102891: LD_VAR 0 1
102895: PUSH
102896: LD_VAR 0 2
102900: PUSH
102901: LD_INT 3
102903: PLUS
102904: PUSH
102905: LD_INT 0
102907: PUSH
102908: EMPTY
102909: LIST
102910: LIST
102911: LIST
102912: PUSH
102913: LD_VAR 0 1
102917: PUSH
102918: LD_INT 4
102920: PLUS
102921: PUSH
102922: LD_VAR 0 2
102926: PUSH
102927: LD_INT 4
102929: PLUS
102930: PUSH
102931: LD_INT 5
102933: PUSH
102934: EMPTY
102935: LIST
102936: LIST
102937: LIST
102938: PUSH
102939: EMPTY
102940: LIST
102941: LIST
102942: LIST
102943: LIST
102944: LIST
102945: ST_TO_ADDR
// end ; 2 :
102946: GO 103505
102948: LD_INT 2
102950: DOUBLE
102951: EQUAL
102952: IFTRUE 102956
102954: GO 103085
102956: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102957: LD_ADDR_VAR 0 5
102961: PUSH
102962: LD_VAR 0 1
102966: PUSH
102967: LD_VAR 0 2
102971: PUSH
102972: LD_INT 3
102974: MINUS
102975: PUSH
102976: LD_INT 3
102978: PUSH
102979: EMPTY
102980: LIST
102981: LIST
102982: LIST
102983: PUSH
102984: LD_VAR 0 1
102988: PUSH
102989: LD_INT 4
102991: PLUS
102992: PUSH
102993: LD_VAR 0 2
102997: PUSH
102998: LD_INT 4
103000: PUSH
103001: EMPTY
103002: LIST
103003: LIST
103004: LIST
103005: PUSH
103006: LD_VAR 0 1
103010: PUSH
103011: LD_VAR 0 2
103015: PUSH
103016: LD_INT 4
103018: PLUS
103019: PUSH
103020: LD_INT 0
103022: PUSH
103023: EMPTY
103024: LIST
103025: LIST
103026: LIST
103027: PUSH
103028: LD_VAR 0 1
103032: PUSH
103033: LD_INT 3
103035: MINUS
103036: PUSH
103037: LD_VAR 0 2
103041: PUSH
103042: LD_INT 1
103044: PUSH
103045: EMPTY
103046: LIST
103047: LIST
103048: LIST
103049: PUSH
103050: LD_VAR 0 1
103054: PUSH
103055: LD_INT 4
103057: MINUS
103058: PUSH
103059: LD_VAR 0 2
103063: PUSH
103064: LD_INT 4
103066: MINUS
103067: PUSH
103068: LD_INT 2
103070: PUSH
103071: EMPTY
103072: LIST
103073: LIST
103074: LIST
103075: PUSH
103076: EMPTY
103077: LIST
103078: LIST
103079: LIST
103080: LIST
103081: LIST
103082: ST_TO_ADDR
// end ; 3 :
103083: GO 103505
103085: LD_INT 3
103087: DOUBLE
103088: EQUAL
103089: IFTRUE 103093
103091: GO 103226
103093: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103094: LD_ADDR_VAR 0 5
103098: PUSH
103099: LD_VAR 0 1
103103: PUSH
103104: LD_INT 3
103106: PLUS
103107: PUSH
103108: LD_VAR 0 2
103112: PUSH
103113: LD_INT 4
103115: PUSH
103116: EMPTY
103117: LIST
103118: LIST
103119: LIST
103120: PUSH
103121: LD_VAR 0 1
103125: PUSH
103126: LD_INT 4
103128: PLUS
103129: PUSH
103130: LD_VAR 0 2
103134: PUSH
103135: LD_INT 4
103137: PLUS
103138: PUSH
103139: LD_INT 5
103141: PUSH
103142: EMPTY
103143: LIST
103144: LIST
103145: LIST
103146: PUSH
103147: LD_VAR 0 1
103151: PUSH
103152: LD_INT 4
103154: MINUS
103155: PUSH
103156: LD_VAR 0 2
103160: PUSH
103161: LD_INT 1
103163: PUSH
103164: EMPTY
103165: LIST
103166: LIST
103167: LIST
103168: PUSH
103169: LD_VAR 0 1
103173: PUSH
103174: LD_VAR 0 2
103178: PUSH
103179: LD_INT 4
103181: MINUS
103182: PUSH
103183: LD_INT 3
103185: PUSH
103186: EMPTY
103187: LIST
103188: LIST
103189: LIST
103190: PUSH
103191: LD_VAR 0 1
103195: PUSH
103196: LD_INT 3
103198: MINUS
103199: PUSH
103200: LD_VAR 0 2
103204: PUSH
103205: LD_INT 3
103207: MINUS
103208: PUSH
103209: LD_INT 2
103211: PUSH
103212: EMPTY
103213: LIST
103214: LIST
103215: LIST
103216: PUSH
103217: EMPTY
103218: LIST
103219: LIST
103220: LIST
103221: LIST
103222: LIST
103223: ST_TO_ADDR
// end ; 4 :
103224: GO 103505
103226: LD_INT 4
103228: DOUBLE
103229: EQUAL
103230: IFTRUE 103234
103232: GO 103367
103234: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103235: LD_ADDR_VAR 0 5
103239: PUSH
103240: LD_VAR 0 1
103244: PUSH
103245: LD_VAR 0 2
103249: PUSH
103250: LD_INT 4
103252: PLUS
103253: PUSH
103254: LD_INT 0
103256: PUSH
103257: EMPTY
103258: LIST
103259: LIST
103260: LIST
103261: PUSH
103262: LD_VAR 0 1
103266: PUSH
103267: LD_INT 3
103269: PLUS
103270: PUSH
103271: LD_VAR 0 2
103275: PUSH
103276: LD_INT 3
103278: PLUS
103279: PUSH
103280: LD_INT 5
103282: PUSH
103283: EMPTY
103284: LIST
103285: LIST
103286: LIST
103287: PUSH
103288: LD_VAR 0 1
103292: PUSH
103293: LD_INT 4
103295: PLUS
103296: PUSH
103297: LD_VAR 0 2
103301: PUSH
103302: LD_INT 4
103304: PUSH
103305: EMPTY
103306: LIST
103307: LIST
103308: LIST
103309: PUSH
103310: LD_VAR 0 1
103314: PUSH
103315: LD_VAR 0 2
103319: PUSH
103320: LD_INT 3
103322: MINUS
103323: PUSH
103324: LD_INT 3
103326: PUSH
103327: EMPTY
103328: LIST
103329: LIST
103330: LIST
103331: PUSH
103332: LD_VAR 0 1
103336: PUSH
103337: LD_INT 4
103339: MINUS
103340: PUSH
103341: LD_VAR 0 2
103345: PUSH
103346: LD_INT 4
103348: MINUS
103349: PUSH
103350: LD_INT 2
103352: PUSH
103353: EMPTY
103354: LIST
103355: LIST
103356: LIST
103357: PUSH
103358: EMPTY
103359: LIST
103360: LIST
103361: LIST
103362: LIST
103363: LIST
103364: ST_TO_ADDR
// end ; 5 :
103365: GO 103505
103367: LD_INT 5
103369: DOUBLE
103370: EQUAL
103371: IFTRUE 103375
103373: GO 103504
103375: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103376: LD_ADDR_VAR 0 5
103380: PUSH
103381: LD_VAR 0 1
103385: PUSH
103386: LD_INT 4
103388: MINUS
103389: PUSH
103390: LD_VAR 0 2
103394: PUSH
103395: LD_INT 1
103397: PUSH
103398: EMPTY
103399: LIST
103400: LIST
103401: LIST
103402: PUSH
103403: LD_VAR 0 1
103407: PUSH
103408: LD_VAR 0 2
103412: PUSH
103413: LD_INT 4
103415: MINUS
103416: PUSH
103417: LD_INT 3
103419: PUSH
103420: EMPTY
103421: LIST
103422: LIST
103423: LIST
103424: PUSH
103425: LD_VAR 0 1
103429: PUSH
103430: LD_INT 4
103432: PLUS
103433: PUSH
103434: LD_VAR 0 2
103438: PUSH
103439: LD_INT 4
103441: PLUS
103442: PUSH
103443: LD_INT 5
103445: PUSH
103446: EMPTY
103447: LIST
103448: LIST
103449: LIST
103450: PUSH
103451: LD_VAR 0 1
103455: PUSH
103456: LD_INT 3
103458: PLUS
103459: PUSH
103460: LD_VAR 0 2
103464: PUSH
103465: LD_INT 4
103467: PUSH
103468: EMPTY
103469: LIST
103470: LIST
103471: LIST
103472: PUSH
103473: LD_VAR 0 1
103477: PUSH
103478: LD_VAR 0 2
103482: PUSH
103483: LD_INT 3
103485: PLUS
103486: PUSH
103487: LD_INT 0
103489: PUSH
103490: EMPTY
103491: LIST
103492: LIST
103493: LIST
103494: PUSH
103495: EMPTY
103496: LIST
103497: LIST
103498: LIST
103499: LIST
103500: LIST
103501: ST_TO_ADDR
// end ; end ;
103502: GO 103505
103504: POP
// result := list ;
103505: LD_ADDR_VAR 0 4
103509: PUSH
103510: LD_VAR 0 5
103514: ST_TO_ADDR
// end ;
103515: LD_VAR 0 4
103519: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103520: LD_INT 0
103522: PPUSH
103523: PPUSH
103524: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103525: LD_VAR 0 1
103529: NOT
103530: PUSH
103531: LD_VAR 0 2
103535: PUSH
103536: LD_INT 1
103538: PUSH
103539: LD_INT 2
103541: PUSH
103542: LD_INT 3
103544: PUSH
103545: LD_INT 4
103547: PUSH
103548: EMPTY
103549: LIST
103550: LIST
103551: LIST
103552: LIST
103553: IN
103554: NOT
103555: OR
103556: IFFALSE 103560
// exit ;
103558: GO 103643
// tmp := [ ] ;
103560: LD_ADDR_VAR 0 5
103564: PUSH
103565: EMPTY
103566: ST_TO_ADDR
// for i in units do
103567: LD_ADDR_VAR 0 4
103571: PUSH
103572: LD_VAR 0 1
103576: PUSH
103577: FOR_IN
103578: IFFALSE 103612
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
103580: LD_ADDR_VAR 0 5
103584: PUSH
103585: LD_VAR 0 5
103589: PPUSH
103590: LD_VAR 0 4
103594: PPUSH
103595: LD_VAR 0 2
103599: PPUSH
103600: CALL_OW 259
103604: PPUSH
103605: CALL 105004 0 2
103609: ST_TO_ADDR
103610: GO 103577
103612: POP
103613: POP
// if not tmp then
103614: LD_VAR 0 5
103618: NOT
103619: IFFALSE 103623
// exit ;
103621: GO 103643
// result := SortListByListDesc ( units , tmp ) ;
103623: LD_ADDR_VAR 0 3
103627: PUSH
103628: LD_VAR 0 1
103632: PPUSH
103633: LD_VAR 0 5
103637: PPUSH
103638: CALL_OW 77
103642: ST_TO_ADDR
// end ;
103643: LD_VAR 0 3
103647: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103648: LD_INT 0
103650: PPUSH
103651: PPUSH
103652: PPUSH
// result := false ;
103653: LD_ADDR_VAR 0 3
103657: PUSH
103658: LD_INT 0
103660: ST_TO_ADDR
// if not building then
103661: LD_VAR 0 2
103665: NOT
103666: IFFALSE 103670
// exit ;
103668: GO 103808
// x := GetX ( building ) ;
103670: LD_ADDR_VAR 0 4
103674: PUSH
103675: LD_VAR 0 2
103679: PPUSH
103680: CALL_OW 250
103684: ST_TO_ADDR
// y := GetY ( building ) ;
103685: LD_ADDR_VAR 0 5
103689: PUSH
103690: LD_VAR 0 2
103694: PPUSH
103695: CALL_OW 251
103699: ST_TO_ADDR
// if not x or not y then
103700: LD_VAR 0 4
103704: NOT
103705: PUSH
103706: LD_VAR 0 5
103710: NOT
103711: OR
103712: IFFALSE 103716
// exit ;
103714: GO 103808
// if GetTaskList ( unit ) then
103716: LD_VAR 0 1
103720: PPUSH
103721: CALL_OW 437
103725: IFFALSE 103808
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103727: LD_STRING e
103729: PUSH
103730: LD_VAR 0 1
103734: PPUSH
103735: CALL_OW 437
103739: PUSH
103740: LD_INT 1
103742: ARRAY
103743: PUSH
103744: LD_INT 1
103746: ARRAY
103747: EQUAL
103748: PUSH
103749: LD_VAR 0 4
103753: PUSH
103754: LD_VAR 0 1
103758: PPUSH
103759: CALL_OW 437
103763: PUSH
103764: LD_INT 1
103766: ARRAY
103767: PUSH
103768: LD_INT 2
103770: ARRAY
103771: EQUAL
103772: AND
103773: PUSH
103774: LD_VAR 0 5
103778: PUSH
103779: LD_VAR 0 1
103783: PPUSH
103784: CALL_OW 437
103788: PUSH
103789: LD_INT 1
103791: ARRAY
103792: PUSH
103793: LD_INT 3
103795: ARRAY
103796: EQUAL
103797: AND
103798: IFFALSE 103808
// result := true end ;
103800: LD_ADDR_VAR 0 3
103804: PUSH
103805: LD_INT 1
103807: ST_TO_ADDR
// end ;
103808: LD_VAR 0 3
103812: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
103813: LD_INT 0
103815: PPUSH
// result := false ;
103816: LD_ADDR_VAR 0 4
103820: PUSH
103821: LD_INT 0
103823: ST_TO_ADDR
// if GetTaskList ( unit ) then
103824: LD_VAR 0 1
103828: PPUSH
103829: CALL_OW 437
103833: IFFALSE 103916
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103835: LD_STRING M
103837: PUSH
103838: LD_VAR 0 1
103842: PPUSH
103843: CALL_OW 437
103847: PUSH
103848: LD_INT 1
103850: ARRAY
103851: PUSH
103852: LD_INT 1
103854: ARRAY
103855: EQUAL
103856: PUSH
103857: LD_VAR 0 2
103861: PUSH
103862: LD_VAR 0 1
103866: PPUSH
103867: CALL_OW 437
103871: PUSH
103872: LD_INT 1
103874: ARRAY
103875: PUSH
103876: LD_INT 2
103878: ARRAY
103879: EQUAL
103880: AND
103881: PUSH
103882: LD_VAR 0 3
103886: PUSH
103887: LD_VAR 0 1
103891: PPUSH
103892: CALL_OW 437
103896: PUSH
103897: LD_INT 1
103899: ARRAY
103900: PUSH
103901: LD_INT 3
103903: ARRAY
103904: EQUAL
103905: AND
103906: IFFALSE 103916
// result := true ;
103908: LD_ADDR_VAR 0 4
103912: PUSH
103913: LD_INT 1
103915: ST_TO_ADDR
// end ; end ;
103916: LD_VAR 0 4
103920: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103921: LD_INT 0
103923: PPUSH
103924: PPUSH
103925: PPUSH
103926: PPUSH
// if not unit or not area then
103927: LD_VAR 0 1
103931: NOT
103932: PUSH
103933: LD_VAR 0 2
103937: NOT
103938: OR
103939: IFFALSE 103943
// exit ;
103941: GO 104107
// tmp := AreaToList ( area , i ) ;
103943: LD_ADDR_VAR 0 6
103947: PUSH
103948: LD_VAR 0 2
103952: PPUSH
103953: LD_VAR 0 5
103957: PPUSH
103958: CALL_OW 517
103962: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
103963: LD_ADDR_VAR 0 5
103967: PUSH
103968: DOUBLE
103969: LD_INT 1
103971: DEC
103972: ST_TO_ADDR
103973: LD_VAR 0 6
103977: PUSH
103978: LD_INT 1
103980: ARRAY
103981: PUSH
103982: FOR_TO
103983: IFFALSE 104105
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
103985: LD_ADDR_VAR 0 7
103989: PUSH
103990: LD_VAR 0 6
103994: PUSH
103995: LD_INT 1
103997: ARRAY
103998: PUSH
103999: LD_VAR 0 5
104003: ARRAY
104004: PUSH
104005: LD_VAR 0 6
104009: PUSH
104010: LD_INT 2
104012: ARRAY
104013: PUSH
104014: LD_VAR 0 5
104018: ARRAY
104019: PUSH
104020: EMPTY
104021: LIST
104022: LIST
104023: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
104024: LD_VAR 0 7
104028: PUSH
104029: LD_INT 1
104031: ARRAY
104032: PPUSH
104033: LD_VAR 0 7
104037: PUSH
104038: LD_INT 2
104040: ARRAY
104041: PPUSH
104042: CALL_OW 428
104046: PUSH
104047: LD_INT 0
104049: EQUAL
104050: IFFALSE 104103
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
104052: LD_VAR 0 1
104056: PPUSH
104057: LD_VAR 0 7
104061: PUSH
104062: LD_INT 1
104064: ARRAY
104065: PPUSH
104066: LD_VAR 0 7
104070: PUSH
104071: LD_INT 2
104073: ARRAY
104074: PPUSH
104075: LD_VAR 0 3
104079: PPUSH
104080: CALL_OW 48
// result := IsPlaced ( unit ) ;
104084: LD_ADDR_VAR 0 4
104088: PUSH
104089: LD_VAR 0 1
104093: PPUSH
104094: CALL_OW 305
104098: ST_TO_ADDR
// exit ;
104099: POP
104100: POP
104101: GO 104107
// end ; end ;
104103: GO 103982
104105: POP
104106: POP
// end ;
104107: LD_VAR 0 4
104111: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104112: LD_INT 0
104114: PPUSH
104115: PPUSH
104116: PPUSH
// if not side or side > 8 then
104117: LD_VAR 0 1
104121: NOT
104122: PUSH
104123: LD_VAR 0 1
104127: PUSH
104128: LD_INT 8
104130: GREATER
104131: OR
104132: IFFALSE 104136
// exit ;
104134: GO 104323
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104136: LD_ADDR_VAR 0 4
104140: PUSH
104141: LD_INT 22
104143: PUSH
104144: LD_VAR 0 1
104148: PUSH
104149: EMPTY
104150: LIST
104151: LIST
104152: PUSH
104153: LD_INT 21
104155: PUSH
104156: LD_INT 3
104158: PUSH
104159: EMPTY
104160: LIST
104161: LIST
104162: PUSH
104163: EMPTY
104164: LIST
104165: LIST
104166: PPUSH
104167: CALL_OW 69
104171: ST_TO_ADDR
// if not tmp then
104172: LD_VAR 0 4
104176: NOT
104177: IFFALSE 104181
// exit ;
104179: GO 104323
// enable_addtolog := true ;
104181: LD_ADDR_OWVAR 81
104185: PUSH
104186: LD_INT 1
104188: ST_TO_ADDR
// AddToLog ( [ ) ;
104189: LD_STRING [
104191: PPUSH
104192: CALL_OW 561
// for i in tmp do
104196: LD_ADDR_VAR 0 3
104200: PUSH
104201: LD_VAR 0 4
104205: PUSH
104206: FOR_IN
104207: IFFALSE 104314
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104209: LD_STRING [
104211: PUSH
104212: LD_VAR 0 3
104216: PPUSH
104217: CALL_OW 266
104221: STR
104222: PUSH
104223: LD_STRING , 
104225: STR
104226: PUSH
104227: LD_VAR 0 3
104231: PPUSH
104232: CALL_OW 250
104236: STR
104237: PUSH
104238: LD_STRING , 
104240: STR
104241: PUSH
104242: LD_VAR 0 3
104246: PPUSH
104247: CALL_OW 251
104251: STR
104252: PUSH
104253: LD_STRING , 
104255: STR
104256: PUSH
104257: LD_VAR 0 3
104261: PPUSH
104262: CALL_OW 254
104266: STR
104267: PUSH
104268: LD_STRING , 
104270: STR
104271: PUSH
104272: LD_VAR 0 3
104276: PPUSH
104277: LD_INT 1
104279: PPUSH
104280: CALL_OW 268
104284: STR
104285: PUSH
104286: LD_STRING , 
104288: STR
104289: PUSH
104290: LD_VAR 0 3
104294: PPUSH
104295: LD_INT 2
104297: PPUSH
104298: CALL_OW 268
104302: STR
104303: PUSH
104304: LD_STRING ],
104306: STR
104307: PPUSH
104308: CALL_OW 561
// end ;
104312: GO 104206
104314: POP
104315: POP
// AddToLog ( ]; ) ;
104316: LD_STRING ];
104318: PPUSH
104319: CALL_OW 561
// end ;
104323: LD_VAR 0 2
104327: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104328: LD_INT 0
104330: PPUSH
104331: PPUSH
104332: PPUSH
104333: PPUSH
104334: PPUSH
// if not area or not rate or not max then
104335: LD_VAR 0 1
104339: NOT
104340: PUSH
104341: LD_VAR 0 2
104345: NOT
104346: OR
104347: PUSH
104348: LD_VAR 0 4
104352: NOT
104353: OR
104354: IFFALSE 104358
// exit ;
104356: GO 104547
// while 1 do
104358: LD_INT 1
104360: IFFALSE 104547
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104362: LD_ADDR_VAR 0 9
104366: PUSH
104367: LD_VAR 0 1
104371: PPUSH
104372: LD_INT 1
104374: PPUSH
104375: CALL_OW 287
104379: PUSH
104380: LD_INT 10
104382: MUL
104383: ST_TO_ADDR
// r := rate / 10 ;
104384: LD_ADDR_VAR 0 7
104388: PUSH
104389: LD_VAR 0 2
104393: PUSH
104394: LD_INT 10
104396: DIVREAL
104397: ST_TO_ADDR
// time := 1 1$00 ;
104398: LD_ADDR_VAR 0 8
104402: PUSH
104403: LD_INT 2100
104405: ST_TO_ADDR
// if amount < min then
104406: LD_VAR 0 9
104410: PUSH
104411: LD_VAR 0 3
104415: LESS
104416: IFFALSE 104434
// r := r * 2 else
104418: LD_ADDR_VAR 0 7
104422: PUSH
104423: LD_VAR 0 7
104427: PUSH
104428: LD_INT 2
104430: MUL
104431: ST_TO_ADDR
104432: GO 104460
// if amount > max then
104434: LD_VAR 0 9
104438: PUSH
104439: LD_VAR 0 4
104443: GREATER
104444: IFFALSE 104460
// r := r / 2 ;
104446: LD_ADDR_VAR 0 7
104450: PUSH
104451: LD_VAR 0 7
104455: PUSH
104456: LD_INT 2
104458: DIVREAL
104459: ST_TO_ADDR
// time := time / r ;
104460: LD_ADDR_VAR 0 8
104464: PUSH
104465: LD_VAR 0 8
104469: PUSH
104470: LD_VAR 0 7
104474: DIVREAL
104475: ST_TO_ADDR
// if time < 0 then
104476: LD_VAR 0 8
104480: PUSH
104481: LD_INT 0
104483: LESS
104484: IFFALSE 104501
// time := time * - 1 ;
104486: LD_ADDR_VAR 0 8
104490: PUSH
104491: LD_VAR 0 8
104495: PUSH
104496: LD_INT 1
104498: NEG
104499: MUL
104500: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104501: LD_VAR 0 8
104505: PUSH
104506: LD_INT 35
104508: PPUSH
104509: LD_INT 875
104511: PPUSH
104512: CALL_OW 12
104516: PLUS
104517: PPUSH
104518: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104522: LD_INT 1
104524: PPUSH
104525: LD_INT 5
104527: PPUSH
104528: CALL_OW 12
104532: PPUSH
104533: LD_VAR 0 1
104537: PPUSH
104538: LD_INT 1
104540: PPUSH
104541: CALL_OW 55
// end ;
104545: GO 104358
// end ;
104547: LD_VAR 0 5
104551: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104552: LD_INT 0
104554: PPUSH
104555: PPUSH
104556: PPUSH
104557: PPUSH
104558: PPUSH
104559: PPUSH
104560: PPUSH
104561: PPUSH
// if not turrets or not factories then
104562: LD_VAR 0 1
104566: NOT
104567: PUSH
104568: LD_VAR 0 2
104572: NOT
104573: OR
104574: IFFALSE 104578
// exit ;
104576: GO 104885
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104578: LD_ADDR_VAR 0 10
104582: PUSH
104583: LD_INT 5
104585: PUSH
104586: LD_INT 6
104588: PUSH
104589: EMPTY
104590: LIST
104591: LIST
104592: PUSH
104593: LD_INT 2
104595: PUSH
104596: LD_INT 4
104598: PUSH
104599: EMPTY
104600: LIST
104601: LIST
104602: PUSH
104603: LD_INT 3
104605: PUSH
104606: LD_INT 5
104608: PUSH
104609: EMPTY
104610: LIST
104611: LIST
104612: PUSH
104613: EMPTY
104614: LIST
104615: LIST
104616: LIST
104617: PUSH
104618: LD_INT 24
104620: PUSH
104621: LD_INT 25
104623: PUSH
104624: EMPTY
104625: LIST
104626: LIST
104627: PUSH
104628: LD_INT 23
104630: PUSH
104631: LD_INT 27
104633: PUSH
104634: EMPTY
104635: LIST
104636: LIST
104637: PUSH
104638: EMPTY
104639: LIST
104640: LIST
104641: PUSH
104642: LD_INT 42
104644: PUSH
104645: LD_INT 43
104647: PUSH
104648: EMPTY
104649: LIST
104650: LIST
104651: PUSH
104652: LD_INT 44
104654: PUSH
104655: LD_INT 46
104657: PUSH
104658: EMPTY
104659: LIST
104660: LIST
104661: PUSH
104662: LD_INT 45
104664: PUSH
104665: LD_INT 47
104667: PUSH
104668: EMPTY
104669: LIST
104670: LIST
104671: PUSH
104672: EMPTY
104673: LIST
104674: LIST
104675: LIST
104676: PUSH
104677: EMPTY
104678: LIST
104679: LIST
104680: LIST
104681: ST_TO_ADDR
// result := [ ] ;
104682: LD_ADDR_VAR 0 3
104686: PUSH
104687: EMPTY
104688: ST_TO_ADDR
// for i in turrets do
104689: LD_ADDR_VAR 0 4
104693: PUSH
104694: LD_VAR 0 1
104698: PUSH
104699: FOR_IN
104700: IFFALSE 104883
// begin nat := GetNation ( i ) ;
104702: LD_ADDR_VAR 0 7
104706: PUSH
104707: LD_VAR 0 4
104711: PPUSH
104712: CALL_OW 248
104716: ST_TO_ADDR
// weapon := 0 ;
104717: LD_ADDR_VAR 0 8
104721: PUSH
104722: LD_INT 0
104724: ST_TO_ADDR
// if not nat then
104725: LD_VAR 0 7
104729: NOT
104730: IFFALSE 104734
// continue ;
104732: GO 104699
// for j in list [ nat ] do
104734: LD_ADDR_VAR 0 5
104738: PUSH
104739: LD_VAR 0 10
104743: PUSH
104744: LD_VAR 0 7
104748: ARRAY
104749: PUSH
104750: FOR_IN
104751: IFFALSE 104792
// if GetBWeapon ( i ) = j [ 1 ] then
104753: LD_VAR 0 4
104757: PPUSH
104758: CALL_OW 269
104762: PUSH
104763: LD_VAR 0 5
104767: PUSH
104768: LD_INT 1
104770: ARRAY
104771: EQUAL
104772: IFFALSE 104790
// begin weapon := j [ 2 ] ;
104774: LD_ADDR_VAR 0 8
104778: PUSH
104779: LD_VAR 0 5
104783: PUSH
104784: LD_INT 2
104786: ARRAY
104787: ST_TO_ADDR
// break ;
104788: GO 104792
// end ;
104790: GO 104750
104792: POP
104793: POP
// if not weapon then
104794: LD_VAR 0 8
104798: NOT
104799: IFFALSE 104803
// continue ;
104801: GO 104699
// for k in factories do
104803: LD_ADDR_VAR 0 6
104807: PUSH
104808: LD_VAR 0 2
104812: PUSH
104813: FOR_IN
104814: IFFALSE 104879
// begin weapons := AvailableWeaponList ( k ) ;
104816: LD_ADDR_VAR 0 9
104820: PUSH
104821: LD_VAR 0 6
104825: PPUSH
104826: CALL_OW 478
104830: ST_TO_ADDR
// if not weapons then
104831: LD_VAR 0 9
104835: NOT
104836: IFFALSE 104840
// continue ;
104838: GO 104813
// if weapon in weapons then
104840: LD_VAR 0 8
104844: PUSH
104845: LD_VAR 0 9
104849: IN
104850: IFFALSE 104877
// begin result := [ i , weapon ] ;
104852: LD_ADDR_VAR 0 3
104856: PUSH
104857: LD_VAR 0 4
104861: PUSH
104862: LD_VAR 0 8
104866: PUSH
104867: EMPTY
104868: LIST
104869: LIST
104870: ST_TO_ADDR
// exit ;
104871: POP
104872: POP
104873: POP
104874: POP
104875: GO 104885
// end ; end ;
104877: GO 104813
104879: POP
104880: POP
// end ;
104881: GO 104699
104883: POP
104884: POP
// end ;
104885: LD_VAR 0 3
104889: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104890: LD_INT 0
104892: PPUSH
// if not side or side > 8 then
104893: LD_VAR 0 3
104897: NOT
104898: PUSH
104899: LD_VAR 0 3
104903: PUSH
104904: LD_INT 8
104906: GREATER
104907: OR
104908: IFFALSE 104912
// exit ;
104910: GO 104971
// if not range then
104912: LD_VAR 0 4
104916: NOT
104917: IFFALSE 104928
// range := - 12 ;
104919: LD_ADDR_VAR 0 4
104923: PUSH
104924: LD_INT 12
104926: NEG
104927: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104928: LD_VAR 0 1
104932: PPUSH
104933: LD_VAR 0 2
104937: PPUSH
104938: LD_VAR 0 3
104942: PPUSH
104943: LD_VAR 0 4
104947: PPUSH
104948: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104952: LD_VAR 0 1
104956: PPUSH
104957: LD_VAR 0 2
104961: PPUSH
104962: LD_VAR 0 3
104966: PPUSH
104967: CALL_OW 331
// end ;
104971: LD_VAR 0 5
104975: RET
// export function Video ( mode ) ; begin
104976: LD_INT 0
104978: PPUSH
// ingame_video = mode ;
104979: LD_ADDR_OWVAR 52
104983: PUSH
104984: LD_VAR 0 1
104988: ST_TO_ADDR
// interface_hidden = mode ;
104989: LD_ADDR_OWVAR 54
104993: PUSH
104994: LD_VAR 0 1
104998: ST_TO_ADDR
// end ;
104999: LD_VAR 0 2
105003: RET
// export function Join ( array , element ) ; begin
105004: LD_INT 0
105006: PPUSH
// result := Replace ( array , array + 1 , element ) ;
105007: LD_ADDR_VAR 0 3
105011: PUSH
105012: LD_VAR 0 1
105016: PPUSH
105017: LD_VAR 0 1
105021: PUSH
105022: LD_INT 1
105024: PLUS
105025: PPUSH
105026: LD_VAR 0 2
105030: PPUSH
105031: CALL_OW 1
105035: ST_TO_ADDR
// end ;
105036: LD_VAR 0 3
105040: RET
// export function JoinUnion ( array , element ) ; begin
105041: LD_INT 0
105043: PPUSH
// result := array union element ;
105044: LD_ADDR_VAR 0 3
105048: PUSH
105049: LD_VAR 0 1
105053: PUSH
105054: LD_VAR 0 2
105058: UNION
105059: ST_TO_ADDR
// end ;
105060: LD_VAR 0 3
105064: RET
// export function GetBehemoths ( side ) ; begin
105065: LD_INT 0
105067: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
105068: LD_ADDR_VAR 0 2
105072: PUSH
105073: LD_INT 22
105075: PUSH
105076: LD_VAR 0 1
105080: PUSH
105081: EMPTY
105082: LIST
105083: LIST
105084: PUSH
105085: LD_INT 31
105087: PUSH
105088: LD_INT 25
105090: PUSH
105091: EMPTY
105092: LIST
105093: LIST
105094: PUSH
105095: EMPTY
105096: LIST
105097: LIST
105098: PPUSH
105099: CALL_OW 69
105103: ST_TO_ADDR
// end ;
105104: LD_VAR 0 2
105108: RET
// export function Shuffle ( array ) ; var i , index ; begin
105109: LD_INT 0
105111: PPUSH
105112: PPUSH
105113: PPUSH
// result := [ ] ;
105114: LD_ADDR_VAR 0 2
105118: PUSH
105119: EMPTY
105120: ST_TO_ADDR
// if not array then
105121: LD_VAR 0 1
105125: NOT
105126: IFFALSE 105130
// exit ;
105128: GO 105229
// Randomize ;
105130: CALL_OW 10
// for i = array downto 1 do
105134: LD_ADDR_VAR 0 3
105138: PUSH
105139: DOUBLE
105140: LD_VAR 0 1
105144: INC
105145: ST_TO_ADDR
105146: LD_INT 1
105148: PUSH
105149: FOR_DOWNTO
105150: IFFALSE 105227
// begin index := rand ( 1 , array ) ;
105152: LD_ADDR_VAR 0 4
105156: PUSH
105157: LD_INT 1
105159: PPUSH
105160: LD_VAR 0 1
105164: PPUSH
105165: CALL_OW 12
105169: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105170: LD_ADDR_VAR 0 2
105174: PUSH
105175: LD_VAR 0 2
105179: PPUSH
105180: LD_VAR 0 2
105184: PUSH
105185: LD_INT 1
105187: PLUS
105188: PPUSH
105189: LD_VAR 0 1
105193: PUSH
105194: LD_VAR 0 4
105198: ARRAY
105199: PPUSH
105200: CALL_OW 2
105204: ST_TO_ADDR
// array := Delete ( array , index ) ;
105205: LD_ADDR_VAR 0 1
105209: PUSH
105210: LD_VAR 0 1
105214: PPUSH
105215: LD_VAR 0 4
105219: PPUSH
105220: CALL_OW 3
105224: ST_TO_ADDR
// end ;
105225: GO 105149
105227: POP
105228: POP
// end ;
105229: LD_VAR 0 2
105233: RET
// export function GetBaseMaterials ( base ) ; begin
105234: LD_INT 0
105236: PPUSH
// result := [ 0 , 0 , 0 ] ;
105237: LD_ADDR_VAR 0 2
105241: PUSH
105242: LD_INT 0
105244: PUSH
105245: LD_INT 0
105247: PUSH
105248: LD_INT 0
105250: PUSH
105251: EMPTY
105252: LIST
105253: LIST
105254: LIST
105255: ST_TO_ADDR
// if not base then
105256: LD_VAR 0 1
105260: NOT
105261: IFFALSE 105265
// exit ;
105263: GO 105314
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
105265: LD_ADDR_VAR 0 2
105269: PUSH
105270: LD_VAR 0 1
105274: PPUSH
105275: LD_INT 1
105277: PPUSH
105278: CALL_OW 275
105282: PUSH
105283: LD_VAR 0 1
105287: PPUSH
105288: LD_INT 2
105290: PPUSH
105291: CALL_OW 275
105295: PUSH
105296: LD_VAR 0 1
105300: PPUSH
105301: LD_INT 3
105303: PPUSH
105304: CALL_OW 275
105308: PUSH
105309: EMPTY
105310: LIST
105311: LIST
105312: LIST
105313: ST_TO_ADDR
// end ;
105314: LD_VAR 0 2
105318: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
105319: LD_INT 0
105321: PPUSH
105322: PPUSH
// result := array ;
105323: LD_ADDR_VAR 0 3
105327: PUSH
105328: LD_VAR 0 1
105332: ST_TO_ADDR
// if size >= result then
105333: LD_VAR 0 2
105337: PUSH
105338: LD_VAR 0 3
105342: GREATEREQUAL
105343: IFFALSE 105347
// exit ;
105345: GO 105397
// if size then
105347: LD_VAR 0 2
105351: IFFALSE 105397
// for i := array downto size do
105353: LD_ADDR_VAR 0 4
105357: PUSH
105358: DOUBLE
105359: LD_VAR 0 1
105363: INC
105364: ST_TO_ADDR
105365: LD_VAR 0 2
105369: PUSH
105370: FOR_DOWNTO
105371: IFFALSE 105395
// result := Delete ( result , result ) ;
105373: LD_ADDR_VAR 0 3
105377: PUSH
105378: LD_VAR 0 3
105382: PPUSH
105383: LD_VAR 0 3
105387: PPUSH
105388: CALL_OW 3
105392: ST_TO_ADDR
105393: GO 105370
105395: POP
105396: POP
// end ;
105397: LD_VAR 0 3
105401: RET
// export function ComExit ( unit ) ; var tmp ; begin
105402: LD_INT 0
105404: PPUSH
105405: PPUSH
// if not IsInUnit ( unit ) then
105406: LD_VAR 0 1
105410: PPUSH
105411: CALL_OW 310
105415: NOT
105416: IFFALSE 105420
// exit ;
105418: GO 105480
// tmp := IsInUnit ( unit ) ;
105420: LD_ADDR_VAR 0 3
105424: PUSH
105425: LD_VAR 0 1
105429: PPUSH
105430: CALL_OW 310
105434: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105435: LD_VAR 0 3
105439: PPUSH
105440: CALL_OW 247
105444: PUSH
105445: LD_INT 2
105447: EQUAL
105448: IFFALSE 105461
// ComExitVehicle ( unit ) else
105450: LD_VAR 0 1
105454: PPUSH
105455: CALL_OW 121
105459: GO 105470
// ComExitBuilding ( unit ) ;
105461: LD_VAR 0 1
105465: PPUSH
105466: CALL_OW 122
// result := tmp ;
105470: LD_ADDR_VAR 0 2
105474: PUSH
105475: LD_VAR 0 3
105479: ST_TO_ADDR
// end ;
105480: LD_VAR 0 2
105484: RET
// export function ComExitAll ( units ) ; var i ; begin
105485: LD_INT 0
105487: PPUSH
105488: PPUSH
// if not units then
105489: LD_VAR 0 1
105493: NOT
105494: IFFALSE 105498
// exit ;
105496: GO 105524
// for i in units do
105498: LD_ADDR_VAR 0 3
105502: PUSH
105503: LD_VAR 0 1
105507: PUSH
105508: FOR_IN
105509: IFFALSE 105522
// ComExit ( i ) ;
105511: LD_VAR 0 3
105515: PPUSH
105516: CALL 105402 0 1
105520: GO 105508
105522: POP
105523: POP
// end ;
105524: LD_VAR 0 2
105528: RET
// export function ResetHc ; begin
105529: LD_INT 0
105531: PPUSH
// InitHc ;
105532: CALL_OW 19
// hc_importance := 0 ;
105536: LD_ADDR_OWVAR 32
105540: PUSH
105541: LD_INT 0
105543: ST_TO_ADDR
// end ;
105544: LD_VAR 0 1
105548: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105549: LD_INT 0
105551: PPUSH
105552: PPUSH
105553: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105554: LD_ADDR_VAR 0 6
105558: PUSH
105559: LD_VAR 0 1
105563: PUSH
105564: LD_VAR 0 3
105568: PLUS
105569: PUSH
105570: LD_INT 2
105572: DIV
105573: ST_TO_ADDR
// if _x < 0 then
105574: LD_VAR 0 6
105578: PUSH
105579: LD_INT 0
105581: LESS
105582: IFFALSE 105599
// _x := _x * - 1 ;
105584: LD_ADDR_VAR 0 6
105588: PUSH
105589: LD_VAR 0 6
105593: PUSH
105594: LD_INT 1
105596: NEG
105597: MUL
105598: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105599: LD_ADDR_VAR 0 7
105603: PUSH
105604: LD_VAR 0 2
105608: PUSH
105609: LD_VAR 0 4
105613: PLUS
105614: PUSH
105615: LD_INT 2
105617: DIV
105618: ST_TO_ADDR
// if _y < 0 then
105619: LD_VAR 0 7
105623: PUSH
105624: LD_INT 0
105626: LESS
105627: IFFALSE 105644
// _y := _y * - 1 ;
105629: LD_ADDR_VAR 0 7
105633: PUSH
105634: LD_VAR 0 7
105638: PUSH
105639: LD_INT 1
105641: NEG
105642: MUL
105643: ST_TO_ADDR
// result := [ _x , _y ] ;
105644: LD_ADDR_VAR 0 5
105648: PUSH
105649: LD_VAR 0 6
105653: PUSH
105654: LD_VAR 0 7
105658: PUSH
105659: EMPTY
105660: LIST
105661: LIST
105662: ST_TO_ADDR
// end ;
105663: LD_VAR 0 5
105667: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105668: LD_INT 0
105670: PPUSH
105671: PPUSH
105672: PPUSH
105673: PPUSH
// task := GetTaskList ( unit ) ;
105674: LD_ADDR_VAR 0 7
105678: PUSH
105679: LD_VAR 0 1
105683: PPUSH
105684: CALL_OW 437
105688: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105689: LD_VAR 0 7
105693: NOT
105694: PUSH
105695: LD_VAR 0 1
105699: PPUSH
105700: LD_VAR 0 2
105704: PPUSH
105705: CALL_OW 308
105709: NOT
105710: AND
105711: IFFALSE 105715
// exit ;
105713: GO 105833
// if IsInArea ( unit , area ) then
105715: LD_VAR 0 1
105719: PPUSH
105720: LD_VAR 0 2
105724: PPUSH
105725: CALL_OW 308
105729: IFFALSE 105747
// begin ComMoveToArea ( unit , goAway ) ;
105731: LD_VAR 0 1
105735: PPUSH
105736: LD_VAR 0 3
105740: PPUSH
105741: CALL_OW 113
// exit ;
105745: GO 105833
// end ; if task [ 1 ] [ 1 ] <> M then
105747: LD_VAR 0 7
105751: PUSH
105752: LD_INT 1
105754: ARRAY
105755: PUSH
105756: LD_INT 1
105758: ARRAY
105759: PUSH
105760: LD_STRING M
105762: NONEQUAL
105763: IFFALSE 105767
// exit ;
105765: GO 105833
// x := task [ 1 ] [ 2 ] ;
105767: LD_ADDR_VAR 0 5
105771: PUSH
105772: LD_VAR 0 7
105776: PUSH
105777: LD_INT 1
105779: ARRAY
105780: PUSH
105781: LD_INT 2
105783: ARRAY
105784: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
105785: LD_ADDR_VAR 0 6
105789: PUSH
105790: LD_VAR 0 7
105794: PUSH
105795: LD_INT 1
105797: ARRAY
105798: PUSH
105799: LD_INT 3
105801: ARRAY
105802: ST_TO_ADDR
// if InArea ( x , y , area ) then
105803: LD_VAR 0 5
105807: PPUSH
105808: LD_VAR 0 6
105812: PPUSH
105813: LD_VAR 0 2
105817: PPUSH
105818: CALL_OW 309
105822: IFFALSE 105833
// ComStop ( unit ) ;
105824: LD_VAR 0 1
105828: PPUSH
105829: CALL_OW 141
// end ;
105833: LD_VAR 0 4
105837: RET
// export function Abs ( value ) ; begin
105838: LD_INT 0
105840: PPUSH
// result := value ;
105841: LD_ADDR_VAR 0 2
105845: PUSH
105846: LD_VAR 0 1
105850: ST_TO_ADDR
// if value < 0 then
105851: LD_VAR 0 1
105855: PUSH
105856: LD_INT 0
105858: LESS
105859: IFFALSE 105876
// result := value * - 1 ;
105861: LD_ADDR_VAR 0 2
105865: PUSH
105866: LD_VAR 0 1
105870: PUSH
105871: LD_INT 1
105873: NEG
105874: MUL
105875: ST_TO_ADDR
// end ;
105876: LD_VAR 0 2
105880: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
105881: LD_INT 0
105883: PPUSH
105884: PPUSH
105885: PPUSH
105886: PPUSH
105887: PPUSH
105888: PPUSH
105889: PPUSH
105890: PPUSH
// if not unit or not building then
105891: LD_VAR 0 1
105895: NOT
105896: PUSH
105897: LD_VAR 0 2
105901: NOT
105902: OR
105903: IFFALSE 105907
// exit ;
105905: GO 106133
// x := GetX ( building ) ;
105907: LD_ADDR_VAR 0 4
105911: PUSH
105912: LD_VAR 0 2
105916: PPUSH
105917: CALL_OW 250
105921: ST_TO_ADDR
// y := GetY ( building ) ;
105922: LD_ADDR_VAR 0 6
105926: PUSH
105927: LD_VAR 0 2
105931: PPUSH
105932: CALL_OW 251
105936: ST_TO_ADDR
// d := GetDir ( building ) ;
105937: LD_ADDR_VAR 0 8
105941: PUSH
105942: LD_VAR 0 2
105946: PPUSH
105947: CALL_OW 254
105951: ST_TO_ADDR
// r := 4 ;
105952: LD_ADDR_VAR 0 9
105956: PUSH
105957: LD_INT 4
105959: ST_TO_ADDR
// for i := 1 to 5 do
105960: LD_ADDR_VAR 0 10
105964: PUSH
105965: DOUBLE
105966: LD_INT 1
105968: DEC
105969: ST_TO_ADDR
105970: LD_INT 5
105972: PUSH
105973: FOR_TO
105974: IFFALSE 106131
// begin _x := ShiftX ( x , d , r + i ) ;
105976: LD_ADDR_VAR 0 5
105980: PUSH
105981: LD_VAR 0 4
105985: PPUSH
105986: LD_VAR 0 8
105990: PPUSH
105991: LD_VAR 0 9
105995: PUSH
105996: LD_VAR 0 10
106000: PLUS
106001: PPUSH
106002: CALL_OW 272
106006: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
106007: LD_ADDR_VAR 0 7
106011: PUSH
106012: LD_VAR 0 6
106016: PPUSH
106017: LD_VAR 0 8
106021: PPUSH
106022: LD_VAR 0 9
106026: PUSH
106027: LD_VAR 0 10
106031: PLUS
106032: PPUSH
106033: CALL_OW 273
106037: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
106038: LD_VAR 0 5
106042: PPUSH
106043: LD_VAR 0 7
106047: PPUSH
106048: CALL_OW 488
106052: PUSH
106053: LD_VAR 0 5
106057: PPUSH
106058: LD_VAR 0 7
106062: PPUSH
106063: CALL_OW 428
106067: PPUSH
106068: CALL_OW 247
106072: PUSH
106073: LD_INT 3
106075: PUSH
106076: LD_INT 2
106078: PUSH
106079: EMPTY
106080: LIST
106081: LIST
106082: IN
106083: NOT
106084: AND
106085: IFFALSE 106129
// begin ComMoveXY ( unit , _x , _y ) ;
106087: LD_VAR 0 1
106091: PPUSH
106092: LD_VAR 0 5
106096: PPUSH
106097: LD_VAR 0 7
106101: PPUSH
106102: CALL_OW 111
// result := [ _x , _y ] ;
106106: LD_ADDR_VAR 0 3
106110: PUSH
106111: LD_VAR 0 5
106115: PUSH
106116: LD_VAR 0 7
106120: PUSH
106121: EMPTY
106122: LIST
106123: LIST
106124: ST_TO_ADDR
// exit ;
106125: POP
106126: POP
106127: GO 106133
// end ; end ;
106129: GO 105973
106131: POP
106132: POP
// end ;
106133: LD_VAR 0 3
106137: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
106138: LD_INT 0
106140: PPUSH
106141: PPUSH
106142: PPUSH
// result := 0 ;
106143: LD_ADDR_VAR 0 3
106147: PUSH
106148: LD_INT 0
106150: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
106151: LD_VAR 0 1
106155: PUSH
106156: LD_INT 0
106158: LESS
106159: PUSH
106160: LD_VAR 0 1
106164: PUSH
106165: LD_INT 8
106167: GREATER
106168: OR
106169: PUSH
106170: LD_VAR 0 2
106174: PUSH
106175: LD_INT 0
106177: LESS
106178: OR
106179: PUSH
106180: LD_VAR 0 2
106184: PUSH
106185: LD_INT 8
106187: GREATER
106188: OR
106189: IFFALSE 106193
// exit ;
106191: GO 106268
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
106193: LD_ADDR_VAR 0 4
106197: PUSH
106198: LD_INT 22
106200: PUSH
106201: LD_VAR 0 2
106205: PUSH
106206: EMPTY
106207: LIST
106208: LIST
106209: PPUSH
106210: CALL_OW 69
106214: PUSH
106215: FOR_IN
106216: IFFALSE 106266
// begin un := UnitShoot ( i ) ;
106218: LD_ADDR_VAR 0 5
106222: PUSH
106223: LD_VAR 0 4
106227: PPUSH
106228: CALL_OW 504
106232: ST_TO_ADDR
// if GetSide ( un ) = side1 then
106233: LD_VAR 0 5
106237: PPUSH
106238: CALL_OW 255
106242: PUSH
106243: LD_VAR 0 1
106247: EQUAL
106248: IFFALSE 106264
// begin result := un ;
106250: LD_ADDR_VAR 0 3
106254: PUSH
106255: LD_VAR 0 5
106259: ST_TO_ADDR
// exit ;
106260: POP
106261: POP
106262: GO 106268
// end ; end ;
106264: GO 106215
106266: POP
106267: POP
// end ;
106268: LD_VAR 0 3
106272: RET
// export function GetCargoBay ( units ) ; begin
106273: LD_INT 0
106275: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
106276: LD_ADDR_VAR 0 2
106280: PUSH
106281: LD_VAR 0 1
106285: PPUSH
106286: LD_INT 2
106288: PUSH
106289: LD_INT 34
106291: PUSH
106292: LD_INT 12
106294: PUSH
106295: EMPTY
106296: LIST
106297: LIST
106298: PUSH
106299: LD_INT 34
106301: PUSH
106302: LD_INT 51
106304: PUSH
106305: EMPTY
106306: LIST
106307: LIST
106308: PUSH
106309: LD_INT 34
106311: PUSH
106312: LD_INT 32
106314: PUSH
106315: EMPTY
106316: LIST
106317: LIST
106318: PUSH
106319: LD_INT 34
106321: PUSH
106322: LD_INT 89
106324: PUSH
106325: EMPTY
106326: LIST
106327: LIST
106328: PUSH
106329: EMPTY
106330: LIST
106331: LIST
106332: LIST
106333: LIST
106334: LIST
106335: PPUSH
106336: CALL_OW 72
106340: ST_TO_ADDR
// end ;
106341: LD_VAR 0 2
106345: RET
// export function Negate ( value ) ; begin
106346: LD_INT 0
106348: PPUSH
// result := not value ;
106349: LD_ADDR_VAR 0 2
106353: PUSH
106354: LD_VAR 0 1
106358: NOT
106359: ST_TO_ADDR
// end ;
106360: LD_VAR 0 2
106364: RET
// export function Inc ( value ) ; begin
106365: LD_INT 0
106367: PPUSH
// result := value + 1 ;
106368: LD_ADDR_VAR 0 2
106372: PUSH
106373: LD_VAR 0 1
106377: PUSH
106378: LD_INT 1
106380: PLUS
106381: ST_TO_ADDR
// end ;
106382: LD_VAR 0 2
106386: RET
// export function Dec ( value ) ; begin
106387: LD_INT 0
106389: PPUSH
// result := value - 1 ;
106390: LD_ADDR_VAR 0 2
106394: PUSH
106395: LD_VAR 0 1
106399: PUSH
106400: LD_INT 1
106402: MINUS
106403: ST_TO_ADDR
// end ;
106404: LD_VAR 0 2
106408: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106409: LD_INT 0
106411: PPUSH
106412: PPUSH
106413: PPUSH
106414: PPUSH
106415: PPUSH
106416: PPUSH
106417: PPUSH
106418: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106419: LD_VAR 0 1
106423: PPUSH
106424: LD_VAR 0 2
106428: PPUSH
106429: CALL_OW 488
106433: NOT
106434: PUSH
106435: LD_VAR 0 3
106439: PPUSH
106440: LD_VAR 0 4
106444: PPUSH
106445: CALL_OW 488
106449: NOT
106450: OR
106451: IFFALSE 106464
// begin result := - 1 ;
106453: LD_ADDR_VAR 0 5
106457: PUSH
106458: LD_INT 1
106460: NEG
106461: ST_TO_ADDR
// exit ;
106462: GO 106699
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106464: LD_ADDR_VAR 0 12
106468: PUSH
106469: LD_VAR 0 1
106473: PPUSH
106474: LD_VAR 0 2
106478: PPUSH
106479: LD_VAR 0 3
106483: PPUSH
106484: LD_VAR 0 4
106488: PPUSH
106489: CALL 105549 0 4
106493: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106494: LD_ADDR_VAR 0 11
106498: PUSH
106499: LD_VAR 0 1
106503: PPUSH
106504: LD_VAR 0 2
106508: PPUSH
106509: LD_VAR 0 12
106513: PUSH
106514: LD_INT 1
106516: ARRAY
106517: PPUSH
106518: LD_VAR 0 12
106522: PUSH
106523: LD_INT 2
106525: ARRAY
106526: PPUSH
106527: CALL_OW 298
106531: ST_TO_ADDR
// distance := 9999 ;
106532: LD_ADDR_VAR 0 10
106536: PUSH
106537: LD_INT 9999
106539: ST_TO_ADDR
// for i := 0 to 5 do
106540: LD_ADDR_VAR 0 6
106544: PUSH
106545: DOUBLE
106546: LD_INT 0
106548: DEC
106549: ST_TO_ADDR
106550: LD_INT 5
106552: PUSH
106553: FOR_TO
106554: IFFALSE 106697
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106556: LD_ADDR_VAR 0 7
106560: PUSH
106561: LD_VAR 0 1
106565: PPUSH
106566: LD_VAR 0 6
106570: PPUSH
106571: LD_VAR 0 11
106575: PPUSH
106576: CALL_OW 272
106580: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106581: LD_ADDR_VAR 0 8
106585: PUSH
106586: LD_VAR 0 2
106590: PPUSH
106591: LD_VAR 0 6
106595: PPUSH
106596: LD_VAR 0 11
106600: PPUSH
106601: CALL_OW 273
106605: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106606: LD_VAR 0 7
106610: PPUSH
106611: LD_VAR 0 8
106615: PPUSH
106616: CALL_OW 488
106620: NOT
106621: IFFALSE 106625
// continue ;
106623: GO 106553
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106625: LD_ADDR_VAR 0 9
106629: PUSH
106630: LD_VAR 0 12
106634: PUSH
106635: LD_INT 1
106637: ARRAY
106638: PPUSH
106639: LD_VAR 0 12
106643: PUSH
106644: LD_INT 2
106646: ARRAY
106647: PPUSH
106648: LD_VAR 0 7
106652: PPUSH
106653: LD_VAR 0 8
106657: PPUSH
106658: CALL_OW 298
106662: ST_TO_ADDR
// if tmp < distance then
106663: LD_VAR 0 9
106667: PUSH
106668: LD_VAR 0 10
106672: LESS
106673: IFFALSE 106695
// begin result := i ;
106675: LD_ADDR_VAR 0 5
106679: PUSH
106680: LD_VAR 0 6
106684: ST_TO_ADDR
// distance := tmp ;
106685: LD_ADDR_VAR 0 10
106689: PUSH
106690: LD_VAR 0 9
106694: ST_TO_ADDR
// end ; end ;
106695: GO 106553
106697: POP
106698: POP
// end ;
106699: LD_VAR 0 5
106703: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106704: LD_INT 0
106706: PPUSH
106707: PPUSH
// if not driver or not IsInUnit ( driver ) then
106708: LD_VAR 0 1
106712: NOT
106713: PUSH
106714: LD_VAR 0 1
106718: PPUSH
106719: CALL_OW 310
106723: NOT
106724: OR
106725: IFFALSE 106729
// exit ;
106727: GO 106819
// vehicle := IsInUnit ( driver ) ;
106729: LD_ADDR_VAR 0 3
106733: PUSH
106734: LD_VAR 0 1
106738: PPUSH
106739: CALL_OW 310
106743: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106744: LD_VAR 0 1
106748: PPUSH
106749: LD_STRING \
106751: PUSH
106752: LD_INT 0
106754: PUSH
106755: LD_INT 0
106757: PUSH
106758: LD_INT 0
106760: PUSH
106761: LD_INT 0
106763: PUSH
106764: LD_INT 0
106766: PUSH
106767: LD_INT 0
106769: PUSH
106770: EMPTY
106771: LIST
106772: LIST
106773: LIST
106774: LIST
106775: LIST
106776: LIST
106777: LIST
106778: PUSH
106779: LD_STRING E
106781: PUSH
106782: LD_INT 0
106784: PUSH
106785: LD_INT 0
106787: PUSH
106788: LD_VAR 0 3
106792: PUSH
106793: LD_INT 0
106795: PUSH
106796: LD_INT 0
106798: PUSH
106799: LD_INT 0
106801: PUSH
106802: EMPTY
106803: LIST
106804: LIST
106805: LIST
106806: LIST
106807: LIST
106808: LIST
106809: LIST
106810: PUSH
106811: EMPTY
106812: LIST
106813: LIST
106814: PPUSH
106815: CALL_OW 446
// end ;
106819: LD_VAR 0 2
106823: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106824: LD_INT 0
106826: PPUSH
106827: PPUSH
// if not driver or not IsInUnit ( driver ) then
106828: LD_VAR 0 1
106832: NOT
106833: PUSH
106834: LD_VAR 0 1
106838: PPUSH
106839: CALL_OW 310
106843: NOT
106844: OR
106845: IFFALSE 106849
// exit ;
106847: GO 106939
// vehicle := IsInUnit ( driver ) ;
106849: LD_ADDR_VAR 0 3
106853: PUSH
106854: LD_VAR 0 1
106858: PPUSH
106859: CALL_OW 310
106863: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106864: LD_VAR 0 1
106868: PPUSH
106869: LD_STRING \
106871: PUSH
106872: LD_INT 0
106874: PUSH
106875: LD_INT 0
106877: PUSH
106878: LD_INT 0
106880: PUSH
106881: LD_INT 0
106883: PUSH
106884: LD_INT 0
106886: PUSH
106887: LD_INT 0
106889: PUSH
106890: EMPTY
106891: LIST
106892: LIST
106893: LIST
106894: LIST
106895: LIST
106896: LIST
106897: LIST
106898: PUSH
106899: LD_STRING E
106901: PUSH
106902: LD_INT 0
106904: PUSH
106905: LD_INT 0
106907: PUSH
106908: LD_VAR 0 3
106912: PUSH
106913: LD_INT 0
106915: PUSH
106916: LD_INT 0
106918: PUSH
106919: LD_INT 0
106921: PUSH
106922: EMPTY
106923: LIST
106924: LIST
106925: LIST
106926: LIST
106927: LIST
106928: LIST
106929: LIST
106930: PUSH
106931: EMPTY
106932: LIST
106933: LIST
106934: PPUSH
106935: CALL_OW 447
// end ;
106939: LD_VAR 0 2
106943: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
106944: LD_INT 0
106946: PPUSH
106947: PPUSH
106948: PPUSH
// tmp := [ ] ;
106949: LD_ADDR_VAR 0 5
106953: PUSH
106954: EMPTY
106955: ST_TO_ADDR
// for i in units do
106956: LD_ADDR_VAR 0 4
106960: PUSH
106961: LD_VAR 0 1
106965: PUSH
106966: FOR_IN
106967: IFFALSE 107005
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
106969: LD_ADDR_VAR 0 5
106973: PUSH
106974: LD_VAR 0 5
106978: PPUSH
106979: LD_VAR 0 5
106983: PUSH
106984: LD_INT 1
106986: PLUS
106987: PPUSH
106988: LD_VAR 0 4
106992: PPUSH
106993: CALL_OW 256
106997: PPUSH
106998: CALL_OW 2
107002: ST_TO_ADDR
107003: GO 106966
107005: POP
107006: POP
// if not tmp then
107007: LD_VAR 0 5
107011: NOT
107012: IFFALSE 107016
// exit ;
107014: GO 107064
// if asc then
107016: LD_VAR 0 2
107020: IFFALSE 107044
// result := SortListByListAsc ( units , tmp ) else
107022: LD_ADDR_VAR 0 3
107026: PUSH
107027: LD_VAR 0 1
107031: PPUSH
107032: LD_VAR 0 5
107036: PPUSH
107037: CALL_OW 76
107041: ST_TO_ADDR
107042: GO 107064
// result := SortListByListDesc ( units , tmp ) ;
107044: LD_ADDR_VAR 0 3
107048: PUSH
107049: LD_VAR 0 1
107053: PPUSH
107054: LD_VAR 0 5
107058: PPUSH
107059: CALL_OW 77
107063: ST_TO_ADDR
// end ;
107064: LD_VAR 0 3
107068: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
107069: LD_INT 0
107071: PPUSH
107072: PPUSH
// task := GetTaskList ( mech ) ;
107073: LD_ADDR_VAR 0 4
107077: PUSH
107078: LD_VAR 0 1
107082: PPUSH
107083: CALL_OW 437
107087: ST_TO_ADDR
// if not task then
107088: LD_VAR 0 4
107092: NOT
107093: IFFALSE 107097
// exit ;
107095: GO 107139
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
107097: LD_ADDR_VAR 0 3
107101: PUSH
107102: LD_VAR 0 4
107106: PUSH
107107: LD_INT 1
107109: ARRAY
107110: PUSH
107111: LD_INT 1
107113: ARRAY
107114: PUSH
107115: LD_STRING r
107117: EQUAL
107118: PUSH
107119: LD_VAR 0 4
107123: PUSH
107124: LD_INT 1
107126: ARRAY
107127: PUSH
107128: LD_INT 4
107130: ARRAY
107131: PUSH
107132: LD_VAR 0 2
107136: EQUAL
107137: AND
107138: ST_TO_ADDR
// end ;
107139: LD_VAR 0 3
107143: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
107144: LD_INT 0
107146: PPUSH
// SetDir ( unit , d ) ;
107147: LD_VAR 0 1
107151: PPUSH
107152: LD_VAR 0 4
107156: PPUSH
107157: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
107161: LD_VAR 0 1
107165: PPUSH
107166: LD_VAR 0 2
107170: PPUSH
107171: LD_VAR 0 3
107175: PPUSH
107176: LD_VAR 0 5
107180: PPUSH
107181: CALL_OW 48
// end ;
107185: LD_VAR 0 6
107189: RET
// export function ToNaturalNumber ( number ) ; begin
107190: LD_INT 0
107192: PPUSH
// result := number div 1 ;
107193: LD_ADDR_VAR 0 2
107197: PUSH
107198: LD_VAR 0 1
107202: PUSH
107203: LD_INT 1
107205: DIV
107206: ST_TO_ADDR
// if number < 0 then
107207: LD_VAR 0 1
107211: PUSH
107212: LD_INT 0
107214: LESS
107215: IFFALSE 107225
// result := 0 ;
107217: LD_ADDR_VAR 0 2
107221: PUSH
107222: LD_INT 0
107224: ST_TO_ADDR
// end ;
107225: LD_VAR 0 2
107229: RET
// export function SortByClass ( units , class ) ; var un ; begin
107230: LD_INT 0
107232: PPUSH
107233: PPUSH
// if not units or not class then
107234: LD_VAR 0 1
107238: NOT
107239: PUSH
107240: LD_VAR 0 2
107244: NOT
107245: OR
107246: IFFALSE 107250
// exit ;
107248: GO 107345
// result := [ ] ;
107250: LD_ADDR_VAR 0 3
107254: PUSH
107255: EMPTY
107256: ST_TO_ADDR
// for un in units do
107257: LD_ADDR_VAR 0 4
107261: PUSH
107262: LD_VAR 0 1
107266: PUSH
107267: FOR_IN
107268: IFFALSE 107343
// if GetClass ( un ) = class then
107270: LD_VAR 0 4
107274: PPUSH
107275: CALL_OW 257
107279: PUSH
107280: LD_VAR 0 2
107284: EQUAL
107285: IFFALSE 107312
// result := Insert ( result , 1 , un ) else
107287: LD_ADDR_VAR 0 3
107291: PUSH
107292: LD_VAR 0 3
107296: PPUSH
107297: LD_INT 1
107299: PPUSH
107300: LD_VAR 0 4
107304: PPUSH
107305: CALL_OW 2
107309: ST_TO_ADDR
107310: GO 107341
// result := Replace ( result , result + 1 , un ) ;
107312: LD_ADDR_VAR 0 3
107316: PUSH
107317: LD_VAR 0 3
107321: PPUSH
107322: LD_VAR 0 3
107326: PUSH
107327: LD_INT 1
107329: PLUS
107330: PPUSH
107331: LD_VAR 0 4
107335: PPUSH
107336: CALL_OW 1
107340: ST_TO_ADDR
107341: GO 107267
107343: POP
107344: POP
// end ;
107345: LD_VAR 0 3
107349: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
107350: LD_INT 0
107352: PPUSH
107353: PPUSH
107354: PPUSH
107355: PPUSH
107356: PPUSH
107357: PPUSH
107358: PPUSH
// result := [ ] ;
107359: LD_ADDR_VAR 0 4
107363: PUSH
107364: EMPTY
107365: ST_TO_ADDR
// if x - r < 0 then
107366: LD_VAR 0 1
107370: PUSH
107371: LD_VAR 0 3
107375: MINUS
107376: PUSH
107377: LD_INT 0
107379: LESS
107380: IFFALSE 107392
// min_x := 0 else
107382: LD_ADDR_VAR 0 8
107386: PUSH
107387: LD_INT 0
107389: ST_TO_ADDR
107390: GO 107408
// min_x := x - r ;
107392: LD_ADDR_VAR 0 8
107396: PUSH
107397: LD_VAR 0 1
107401: PUSH
107402: LD_VAR 0 3
107406: MINUS
107407: ST_TO_ADDR
// if y - r < 0 then
107408: LD_VAR 0 2
107412: PUSH
107413: LD_VAR 0 3
107417: MINUS
107418: PUSH
107419: LD_INT 0
107421: LESS
107422: IFFALSE 107434
// min_y := 0 else
107424: LD_ADDR_VAR 0 7
107428: PUSH
107429: LD_INT 0
107431: ST_TO_ADDR
107432: GO 107450
// min_y := y - r ;
107434: LD_ADDR_VAR 0 7
107438: PUSH
107439: LD_VAR 0 2
107443: PUSH
107444: LD_VAR 0 3
107448: MINUS
107449: ST_TO_ADDR
// max_x := x + r ;
107450: LD_ADDR_VAR 0 9
107454: PUSH
107455: LD_VAR 0 1
107459: PUSH
107460: LD_VAR 0 3
107464: PLUS
107465: ST_TO_ADDR
// max_y := y + r ;
107466: LD_ADDR_VAR 0 10
107470: PUSH
107471: LD_VAR 0 2
107475: PUSH
107476: LD_VAR 0 3
107480: PLUS
107481: ST_TO_ADDR
// for _x = min_x to max_x do
107482: LD_ADDR_VAR 0 5
107486: PUSH
107487: DOUBLE
107488: LD_VAR 0 8
107492: DEC
107493: ST_TO_ADDR
107494: LD_VAR 0 9
107498: PUSH
107499: FOR_TO
107500: IFFALSE 107601
// for _y = min_y to max_y do
107502: LD_ADDR_VAR 0 6
107506: PUSH
107507: DOUBLE
107508: LD_VAR 0 7
107512: DEC
107513: ST_TO_ADDR
107514: LD_VAR 0 10
107518: PUSH
107519: FOR_TO
107520: IFFALSE 107597
// begin if not ValidHex ( _x , _y ) then
107522: LD_VAR 0 5
107526: PPUSH
107527: LD_VAR 0 6
107531: PPUSH
107532: CALL_OW 488
107536: NOT
107537: IFFALSE 107541
// continue ;
107539: GO 107519
// if GetResourceTypeXY ( _x , _y ) then
107541: LD_VAR 0 5
107545: PPUSH
107546: LD_VAR 0 6
107550: PPUSH
107551: CALL_OW 283
107555: IFFALSE 107595
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107557: LD_ADDR_VAR 0 4
107561: PUSH
107562: LD_VAR 0 4
107566: PPUSH
107567: LD_VAR 0 4
107571: PUSH
107572: LD_INT 1
107574: PLUS
107575: PPUSH
107576: LD_VAR 0 5
107580: PUSH
107581: LD_VAR 0 6
107585: PUSH
107586: EMPTY
107587: LIST
107588: LIST
107589: PPUSH
107590: CALL_OW 1
107594: ST_TO_ADDR
// end ;
107595: GO 107519
107597: POP
107598: POP
107599: GO 107499
107601: POP
107602: POP
// end ;
107603: LD_VAR 0 4
107607: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107608: LD_INT 0
107610: PPUSH
107611: PPUSH
107612: PPUSH
107613: PPUSH
107614: PPUSH
107615: PPUSH
107616: PPUSH
107617: PPUSH
// if not units then
107618: LD_VAR 0 1
107622: NOT
107623: IFFALSE 107627
// exit ;
107625: GO 108151
// result := UnitFilter ( units , [ f_ok ] ) ;
107627: LD_ADDR_VAR 0 3
107631: PUSH
107632: LD_VAR 0 1
107636: PPUSH
107637: LD_INT 50
107639: PUSH
107640: EMPTY
107641: LIST
107642: PPUSH
107643: CALL_OW 72
107647: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107648: LD_ADDR_VAR 0 8
107652: PUSH
107653: LD_VAR 0 1
107657: PUSH
107658: LD_INT 1
107660: ARRAY
107661: PPUSH
107662: CALL_OW 255
107666: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107667: LD_ADDR_VAR 0 10
107671: PUSH
107672: LD_INT 29
107674: PUSH
107675: LD_INT 91
107677: PUSH
107678: LD_INT 49
107680: PUSH
107681: EMPTY
107682: LIST
107683: LIST
107684: LIST
107685: ST_TO_ADDR
// if not result then
107686: LD_VAR 0 3
107690: NOT
107691: IFFALSE 107695
// exit ;
107693: GO 108151
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107695: LD_ADDR_VAR 0 5
107699: PUSH
107700: LD_INT 81
107702: PUSH
107703: LD_VAR 0 8
107707: PUSH
107708: EMPTY
107709: LIST
107710: LIST
107711: PPUSH
107712: CALL_OW 69
107716: ST_TO_ADDR
// for i in result do
107717: LD_ADDR_VAR 0 4
107721: PUSH
107722: LD_VAR 0 3
107726: PUSH
107727: FOR_IN
107728: IFFALSE 108149
// begin tag := GetTag ( i ) + 1 ;
107730: LD_ADDR_VAR 0 9
107734: PUSH
107735: LD_VAR 0 4
107739: PPUSH
107740: CALL_OW 110
107744: PUSH
107745: LD_INT 1
107747: PLUS
107748: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
107749: LD_ADDR_VAR 0 7
107753: PUSH
107754: LD_VAR 0 4
107758: PPUSH
107759: CALL_OW 250
107763: PPUSH
107764: LD_VAR 0 4
107768: PPUSH
107769: CALL_OW 251
107773: PPUSH
107774: LD_INT 6
107776: PPUSH
107777: CALL 107350 0 3
107781: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
107782: LD_VAR 0 4
107786: PPUSH
107787: CALL_OW 247
107791: PUSH
107792: LD_INT 2
107794: EQUAL
107795: PUSH
107796: LD_VAR 0 7
107800: AND
107801: PUSH
107802: LD_VAR 0 4
107806: PPUSH
107807: CALL_OW 264
107811: PUSH
107812: LD_VAR 0 10
107816: IN
107817: NOT
107818: AND
107819: IFFALSE 107858
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
107821: LD_VAR 0 4
107825: PPUSH
107826: LD_VAR 0 7
107830: PUSH
107831: LD_INT 1
107833: ARRAY
107834: PUSH
107835: LD_INT 1
107837: ARRAY
107838: PPUSH
107839: LD_VAR 0 7
107843: PUSH
107844: LD_INT 1
107846: ARRAY
107847: PUSH
107848: LD_INT 2
107850: ARRAY
107851: PPUSH
107852: CALL_OW 116
107856: GO 108147
// if path > tag then
107858: LD_VAR 0 2
107862: PUSH
107863: LD_VAR 0 9
107867: GREATER
107868: IFFALSE 108076
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
107870: LD_ADDR_VAR 0 6
107874: PUSH
107875: LD_VAR 0 5
107879: PPUSH
107880: LD_INT 91
107882: PUSH
107883: LD_VAR 0 4
107887: PUSH
107888: LD_INT 8
107890: PUSH
107891: EMPTY
107892: LIST
107893: LIST
107894: LIST
107895: PPUSH
107896: CALL_OW 72
107900: ST_TO_ADDR
// if nearEnemy then
107901: LD_VAR 0 6
107905: IFFALSE 107974
// begin if GetWeapon ( i ) = ru_time_lapser then
107907: LD_VAR 0 4
107911: PPUSH
107912: CALL_OW 264
107916: PUSH
107917: LD_INT 49
107919: EQUAL
107920: IFFALSE 107948
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
107922: LD_VAR 0 4
107926: PPUSH
107927: LD_VAR 0 6
107931: PPUSH
107932: LD_VAR 0 4
107936: PPUSH
107937: CALL_OW 74
107941: PPUSH
107942: CALL_OW 112
107946: GO 107972
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
107948: LD_VAR 0 4
107952: PPUSH
107953: LD_VAR 0 6
107957: PPUSH
107958: LD_VAR 0 4
107962: PPUSH
107963: CALL_OW 74
107967: PPUSH
107968: CALL_OW 115
// end else
107972: GO 108074
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
107974: LD_VAR 0 4
107978: PPUSH
107979: LD_VAR 0 2
107983: PUSH
107984: LD_VAR 0 9
107988: ARRAY
107989: PUSH
107990: LD_INT 1
107992: ARRAY
107993: PPUSH
107994: LD_VAR 0 2
107998: PUSH
107999: LD_VAR 0 9
108003: ARRAY
108004: PUSH
108005: LD_INT 2
108007: ARRAY
108008: PPUSH
108009: CALL_OW 297
108013: PUSH
108014: LD_INT 6
108016: GREATER
108017: IFFALSE 108060
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
108019: LD_VAR 0 4
108023: PPUSH
108024: LD_VAR 0 2
108028: PUSH
108029: LD_VAR 0 9
108033: ARRAY
108034: PUSH
108035: LD_INT 1
108037: ARRAY
108038: PPUSH
108039: LD_VAR 0 2
108043: PUSH
108044: LD_VAR 0 9
108048: ARRAY
108049: PUSH
108050: LD_INT 2
108052: ARRAY
108053: PPUSH
108054: CALL_OW 114
108058: GO 108074
// SetTag ( i , tag ) ;
108060: LD_VAR 0 4
108064: PPUSH
108065: LD_VAR 0 9
108069: PPUSH
108070: CALL_OW 109
// end else
108074: GO 108147
// if enemy then
108076: LD_VAR 0 5
108080: IFFALSE 108147
// begin if GetWeapon ( i ) = ru_time_lapser then
108082: LD_VAR 0 4
108086: PPUSH
108087: CALL_OW 264
108091: PUSH
108092: LD_INT 49
108094: EQUAL
108095: IFFALSE 108123
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
108097: LD_VAR 0 4
108101: PPUSH
108102: LD_VAR 0 5
108106: PPUSH
108107: LD_VAR 0 4
108111: PPUSH
108112: CALL_OW 74
108116: PPUSH
108117: CALL_OW 112
108121: GO 108147
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
108123: LD_VAR 0 4
108127: PPUSH
108128: LD_VAR 0 5
108132: PPUSH
108133: LD_VAR 0 4
108137: PPUSH
108138: CALL_OW 74
108142: PPUSH
108143: CALL_OW 115
// end ; end ;
108147: GO 107727
108149: POP
108150: POP
// end ;
108151: LD_VAR 0 3
108155: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
108156: LD_INT 0
108158: PPUSH
108159: PPUSH
108160: PPUSH
// if not unit or IsInUnit ( unit ) then
108161: LD_VAR 0 1
108165: NOT
108166: PUSH
108167: LD_VAR 0 1
108171: PPUSH
108172: CALL_OW 310
108176: OR
108177: IFFALSE 108181
// exit ;
108179: GO 108272
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
108181: LD_ADDR_VAR 0 4
108185: PUSH
108186: LD_VAR 0 1
108190: PPUSH
108191: CALL_OW 250
108195: PPUSH
108196: LD_VAR 0 2
108200: PPUSH
108201: LD_INT 1
108203: PPUSH
108204: CALL_OW 272
108208: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
108209: LD_ADDR_VAR 0 5
108213: PUSH
108214: LD_VAR 0 1
108218: PPUSH
108219: CALL_OW 251
108223: PPUSH
108224: LD_VAR 0 2
108228: PPUSH
108229: LD_INT 1
108231: PPUSH
108232: CALL_OW 273
108236: ST_TO_ADDR
// if ValidHex ( x , y ) then
108237: LD_VAR 0 4
108241: PPUSH
108242: LD_VAR 0 5
108246: PPUSH
108247: CALL_OW 488
108251: IFFALSE 108272
// ComTurnXY ( unit , x , y ) ;
108253: LD_VAR 0 1
108257: PPUSH
108258: LD_VAR 0 4
108262: PPUSH
108263: LD_VAR 0 5
108267: PPUSH
108268: CALL_OW 118
// end ;
108272: LD_VAR 0 3
108276: RET
// export function SeeUnits ( side , units ) ; var i ; begin
108277: LD_INT 0
108279: PPUSH
108280: PPUSH
// result := false ;
108281: LD_ADDR_VAR 0 3
108285: PUSH
108286: LD_INT 0
108288: ST_TO_ADDR
// if not units then
108289: LD_VAR 0 2
108293: NOT
108294: IFFALSE 108298
// exit ;
108296: GO 108343
// for i in units do
108298: LD_ADDR_VAR 0 4
108302: PUSH
108303: LD_VAR 0 2
108307: PUSH
108308: FOR_IN
108309: IFFALSE 108341
// if See ( side , i ) then
108311: LD_VAR 0 1
108315: PPUSH
108316: LD_VAR 0 4
108320: PPUSH
108321: CALL_OW 292
108325: IFFALSE 108339
// begin result := true ;
108327: LD_ADDR_VAR 0 3
108331: PUSH
108332: LD_INT 1
108334: ST_TO_ADDR
// exit ;
108335: POP
108336: POP
108337: GO 108343
// end ;
108339: GO 108308
108341: POP
108342: POP
// end ;
108343: LD_VAR 0 3
108347: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
108348: LD_INT 0
108350: PPUSH
108351: PPUSH
108352: PPUSH
108353: PPUSH
// if not unit or not points then
108354: LD_VAR 0 1
108358: NOT
108359: PUSH
108360: LD_VAR 0 2
108364: NOT
108365: OR
108366: IFFALSE 108370
// exit ;
108368: GO 108460
// dist := 99999 ;
108370: LD_ADDR_VAR 0 5
108374: PUSH
108375: LD_INT 99999
108377: ST_TO_ADDR
// for i in points do
108378: LD_ADDR_VAR 0 4
108382: PUSH
108383: LD_VAR 0 2
108387: PUSH
108388: FOR_IN
108389: IFFALSE 108458
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108391: LD_ADDR_VAR 0 6
108395: PUSH
108396: LD_VAR 0 1
108400: PPUSH
108401: LD_VAR 0 4
108405: PUSH
108406: LD_INT 1
108408: ARRAY
108409: PPUSH
108410: LD_VAR 0 4
108414: PUSH
108415: LD_INT 2
108417: ARRAY
108418: PPUSH
108419: CALL_OW 297
108423: ST_TO_ADDR
// if tmpDist < dist then
108424: LD_VAR 0 6
108428: PUSH
108429: LD_VAR 0 5
108433: LESS
108434: IFFALSE 108456
// begin result := i ;
108436: LD_ADDR_VAR 0 3
108440: PUSH
108441: LD_VAR 0 4
108445: ST_TO_ADDR
// dist := tmpDist ;
108446: LD_ADDR_VAR 0 5
108450: PUSH
108451: LD_VAR 0 6
108455: ST_TO_ADDR
// end ; end ;
108456: GO 108388
108458: POP
108459: POP
// end ;
108460: LD_VAR 0 3
108464: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108465: LD_INT 0
108467: PPUSH
// uc_side := side ;
108468: LD_ADDR_OWVAR 20
108472: PUSH
108473: LD_VAR 0 1
108477: ST_TO_ADDR
// uc_nation := 3 ;
108478: LD_ADDR_OWVAR 21
108482: PUSH
108483: LD_INT 3
108485: ST_TO_ADDR
// vc_chassis := 25 ;
108486: LD_ADDR_OWVAR 37
108490: PUSH
108491: LD_INT 25
108493: ST_TO_ADDR
// vc_engine := engine_siberite ;
108494: LD_ADDR_OWVAR 39
108498: PUSH
108499: LD_INT 3
108501: ST_TO_ADDR
// vc_control := control_computer ;
108502: LD_ADDR_OWVAR 38
108506: PUSH
108507: LD_INT 3
108509: ST_TO_ADDR
// vc_weapon := 59 ;
108510: LD_ADDR_OWVAR 40
108514: PUSH
108515: LD_INT 59
108517: ST_TO_ADDR
// result := CreateVehicle ;
108518: LD_ADDR_VAR 0 5
108522: PUSH
108523: CALL_OW 45
108527: ST_TO_ADDR
// SetDir ( result , d ) ;
108528: LD_VAR 0 5
108532: PPUSH
108533: LD_VAR 0 4
108537: PPUSH
108538: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108542: LD_VAR 0 5
108546: PPUSH
108547: LD_VAR 0 2
108551: PPUSH
108552: LD_VAR 0 3
108556: PPUSH
108557: LD_INT 0
108559: PPUSH
108560: CALL_OW 48
// end ;
108564: LD_VAR 0 5
108568: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108569: LD_INT 0
108571: PPUSH
108572: PPUSH
108573: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108574: LD_ADDR_VAR 0 2
108578: PUSH
108579: LD_INT 0
108581: PUSH
108582: LD_INT 0
108584: PUSH
108585: LD_INT 0
108587: PUSH
108588: LD_INT 0
108590: PUSH
108591: EMPTY
108592: LIST
108593: LIST
108594: LIST
108595: LIST
108596: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108597: LD_VAR 0 1
108601: NOT
108602: PUSH
108603: LD_VAR 0 1
108607: PPUSH
108608: CALL_OW 264
108612: PUSH
108613: LD_INT 12
108615: PUSH
108616: LD_INT 51
108618: PUSH
108619: LD_INT 32
108621: PUSH
108622: LD_INT 89
108624: PUSH
108625: EMPTY
108626: LIST
108627: LIST
108628: LIST
108629: LIST
108630: IN
108631: NOT
108632: OR
108633: IFFALSE 108637
// exit ;
108635: GO 108735
// for i := 1 to 3 do
108637: LD_ADDR_VAR 0 3
108641: PUSH
108642: DOUBLE
108643: LD_INT 1
108645: DEC
108646: ST_TO_ADDR
108647: LD_INT 3
108649: PUSH
108650: FOR_TO
108651: IFFALSE 108733
// begin tmp := GetCargo ( cargo , i ) ;
108653: LD_ADDR_VAR 0 4
108657: PUSH
108658: LD_VAR 0 1
108662: PPUSH
108663: LD_VAR 0 3
108667: PPUSH
108668: CALL_OW 289
108672: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108673: LD_ADDR_VAR 0 2
108677: PUSH
108678: LD_VAR 0 2
108682: PPUSH
108683: LD_VAR 0 3
108687: PPUSH
108688: LD_VAR 0 4
108692: PPUSH
108693: CALL_OW 1
108697: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108698: LD_ADDR_VAR 0 2
108702: PUSH
108703: LD_VAR 0 2
108707: PPUSH
108708: LD_INT 4
108710: PPUSH
108711: LD_VAR 0 2
108715: PUSH
108716: LD_INT 4
108718: ARRAY
108719: PUSH
108720: LD_VAR 0 4
108724: PLUS
108725: PPUSH
108726: CALL_OW 1
108730: ST_TO_ADDR
// end ;
108731: GO 108650
108733: POP
108734: POP
// end ;
108735: LD_VAR 0 2
108739: RET
// export function Length ( array ) ; begin
108740: LD_INT 0
108742: PPUSH
// result := array + 0 ;
108743: LD_ADDR_VAR 0 2
108747: PUSH
108748: LD_VAR 0 1
108752: PUSH
108753: LD_INT 0
108755: PLUS
108756: ST_TO_ADDR
// end ;
108757: LD_VAR 0 2
108761: RET
// export function PrepareArray ( array ) ; begin
108762: LD_INT 0
108764: PPUSH
// result := array diff 0 ;
108765: LD_ADDR_VAR 0 2
108769: PUSH
108770: LD_VAR 0 1
108774: PUSH
108775: LD_INT 0
108777: DIFF
108778: ST_TO_ADDR
// if not result [ 1 ] then
108779: LD_VAR 0 2
108783: PUSH
108784: LD_INT 1
108786: ARRAY
108787: NOT
108788: IFFALSE 108808
// result := Delete ( result , 1 ) ;
108790: LD_ADDR_VAR 0 2
108794: PUSH
108795: LD_VAR 0 2
108799: PPUSH
108800: LD_INT 1
108802: PPUSH
108803: CALL_OW 3
108807: ST_TO_ADDR
// end ;
108808: LD_VAR 0 2
108812: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
108813: LD_INT 0
108815: PPUSH
108816: PPUSH
108817: PPUSH
108818: PPUSH
// sibRocketRange := 25 ;
108819: LD_ADDR_VAR 0 6
108823: PUSH
108824: LD_INT 25
108826: ST_TO_ADDR
// result := false ;
108827: LD_ADDR_VAR 0 4
108831: PUSH
108832: LD_INT 0
108834: ST_TO_ADDR
// for i := 0 to 5 do
108835: LD_ADDR_VAR 0 5
108839: PUSH
108840: DOUBLE
108841: LD_INT 0
108843: DEC
108844: ST_TO_ADDR
108845: LD_INT 5
108847: PUSH
108848: FOR_TO
108849: IFFALSE 108916
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
108851: LD_VAR 0 1
108855: PPUSH
108856: LD_VAR 0 5
108860: PPUSH
108861: LD_VAR 0 6
108865: PPUSH
108866: CALL_OW 272
108870: PPUSH
108871: LD_VAR 0 2
108875: PPUSH
108876: LD_VAR 0 5
108880: PPUSH
108881: LD_VAR 0 6
108885: PPUSH
108886: CALL_OW 273
108890: PPUSH
108891: LD_VAR 0 3
108895: PPUSH
108896: CALL_OW 309
108900: IFFALSE 108914
// begin result := true ;
108902: LD_ADDR_VAR 0 4
108906: PUSH
108907: LD_INT 1
108909: ST_TO_ADDR
// exit ;
108910: POP
108911: POP
108912: GO 108918
// end ;
108914: GO 108848
108916: POP
108917: POP
// end ;
108918: LD_VAR 0 4
108922: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
108923: LD_INT 0
108925: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
108926: LD_VAR 0 1
108930: PPUSH
108931: LD_VAR 0 2
108935: PPUSH
108936: LD_INT 0
108938: PPUSH
108939: LD_INT 0
108941: PPUSH
108942: LD_INT 1
108944: PPUSH
108945: LD_INT 0
108947: PPUSH
108948: CALL_OW 587
// end ; end_of_file end_of_file
108952: LD_VAR 0 3
108956: RET
// every 0 0$1 do
108957: GO 108959
108959: DISABLE
// begin enable ;
108960: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
108961: LD_STRING updateTimer(
108963: PUSH
108964: LD_OWVAR 1
108968: STR
108969: PUSH
108970: LD_STRING );
108972: STR
108973: PPUSH
108974: CALL_OW 559
// end ;
108978: END
// export function SOS_MapStart ( ) ; begin
108979: LD_INT 0
108981: PPUSH
// if streamModeActive then
108982: LD_EXP 145
108986: IFFALSE 108995
// DefineStreamItems ( true ) ;
108988: LD_INT 1
108990: PPUSH
108991: CALL 110799 0 1
// UpdateLuaVariables ( ) ;
108995: CALL 109012 0 0
// UpdateFactoryWaypoints ( ) ;
108999: CALL 123660 0 0
// UpdateWarehouseGatheringPoints ( ) ;
109003: CALL 123917 0 0
// end ;
109007: LD_VAR 0 1
109011: RET
// export globalGameSaveCounter ; function UpdateLuaVariables ( ) ; begin
109012: LD_INT 0
109014: PPUSH
// if not globalGameSaveCounter then
109015: LD_EXP 144
109019: NOT
109020: IFFALSE 109031
// ToLua ( setGameSaveCounter(0) ) else
109022: LD_STRING setGameSaveCounter(0)
109024: PPUSH
109025: CALL_OW 559
109029: GO 109063
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
109031: LD_ADDR_EXP 144
109035: PUSH
109036: LD_EXP 144
109040: PPUSH
109041: CALL 106365 0 1
109045: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
109046: LD_STRING setGameSaveCounter(
109048: PUSH
109049: LD_EXP 144
109053: STR
109054: PUSH
109055: LD_STRING )
109057: STR
109058: PPUSH
109059: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
109063: LD_STRING setGameDifficulty(
109065: PUSH
109066: LD_OWVAR 67
109070: STR
109071: PUSH
109072: LD_STRING )
109074: STR
109075: PPUSH
109076: CALL_OW 559
// end ;
109080: LD_VAR 0 1
109084: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
109085: LD_INT 0
109087: PPUSH
// if p2 = stream_mode then
109088: LD_VAR 0 2
109092: PUSH
109093: LD_INT 100
109095: EQUAL
109096: IFFALSE 110099
// begin if not StreamModeActive then
109098: LD_EXP 145
109102: NOT
109103: IFFALSE 109113
// StreamModeActive := true ;
109105: LD_ADDR_EXP 145
109109: PUSH
109110: LD_INT 1
109112: ST_TO_ADDR
// if p3 = 0 then
109113: LD_VAR 0 3
109117: PUSH
109118: LD_INT 0
109120: EQUAL
109121: IFFALSE 109127
// InitStreamMode ;
109123: CALL 110335 0 0
// if p3 = 1 then
109127: LD_VAR 0 3
109131: PUSH
109132: LD_INT 1
109134: EQUAL
109135: IFFALSE 109145
// sRocket := true ;
109137: LD_ADDR_EXP 150
109141: PUSH
109142: LD_INT 1
109144: ST_TO_ADDR
// if p3 = 2 then
109145: LD_VAR 0 3
109149: PUSH
109150: LD_INT 2
109152: EQUAL
109153: IFFALSE 109163
// sSpeed := true ;
109155: LD_ADDR_EXP 149
109159: PUSH
109160: LD_INT 1
109162: ST_TO_ADDR
// if p3 = 3 then
109163: LD_VAR 0 3
109167: PUSH
109168: LD_INT 3
109170: EQUAL
109171: IFFALSE 109181
// sEngine := true ;
109173: LD_ADDR_EXP 151
109177: PUSH
109178: LD_INT 1
109180: ST_TO_ADDR
// if p3 = 4 then
109181: LD_VAR 0 3
109185: PUSH
109186: LD_INT 4
109188: EQUAL
109189: IFFALSE 109199
// sSpec := true ;
109191: LD_ADDR_EXP 148
109195: PUSH
109196: LD_INT 1
109198: ST_TO_ADDR
// if p3 = 5 then
109199: LD_VAR 0 3
109203: PUSH
109204: LD_INT 5
109206: EQUAL
109207: IFFALSE 109217
// sLevel := true ;
109209: LD_ADDR_EXP 152
109213: PUSH
109214: LD_INT 1
109216: ST_TO_ADDR
// if p3 = 6 then
109217: LD_VAR 0 3
109221: PUSH
109222: LD_INT 6
109224: EQUAL
109225: IFFALSE 109235
// sArmoury := true ;
109227: LD_ADDR_EXP 153
109231: PUSH
109232: LD_INT 1
109234: ST_TO_ADDR
// if p3 = 7 then
109235: LD_VAR 0 3
109239: PUSH
109240: LD_INT 7
109242: EQUAL
109243: IFFALSE 109253
// sRadar := true ;
109245: LD_ADDR_EXP 154
109249: PUSH
109250: LD_INT 1
109252: ST_TO_ADDR
// if p3 = 8 then
109253: LD_VAR 0 3
109257: PUSH
109258: LD_INT 8
109260: EQUAL
109261: IFFALSE 109271
// sBunker := true ;
109263: LD_ADDR_EXP 155
109267: PUSH
109268: LD_INT 1
109270: ST_TO_ADDR
// if p3 = 9 then
109271: LD_VAR 0 3
109275: PUSH
109276: LD_INT 9
109278: EQUAL
109279: IFFALSE 109289
// sHack := true ;
109281: LD_ADDR_EXP 156
109285: PUSH
109286: LD_INT 1
109288: ST_TO_ADDR
// if p3 = 10 then
109289: LD_VAR 0 3
109293: PUSH
109294: LD_INT 10
109296: EQUAL
109297: IFFALSE 109307
// sFire := true ;
109299: LD_ADDR_EXP 157
109303: PUSH
109304: LD_INT 1
109306: ST_TO_ADDR
// if p3 = 11 then
109307: LD_VAR 0 3
109311: PUSH
109312: LD_INT 11
109314: EQUAL
109315: IFFALSE 109325
// sRefresh := true ;
109317: LD_ADDR_EXP 158
109321: PUSH
109322: LD_INT 1
109324: ST_TO_ADDR
// if p3 = 12 then
109325: LD_VAR 0 3
109329: PUSH
109330: LD_INT 12
109332: EQUAL
109333: IFFALSE 109343
// sExp := true ;
109335: LD_ADDR_EXP 159
109339: PUSH
109340: LD_INT 1
109342: ST_TO_ADDR
// if p3 = 13 then
109343: LD_VAR 0 3
109347: PUSH
109348: LD_INT 13
109350: EQUAL
109351: IFFALSE 109361
// sDepot := true ;
109353: LD_ADDR_EXP 160
109357: PUSH
109358: LD_INT 1
109360: ST_TO_ADDR
// if p3 = 14 then
109361: LD_VAR 0 3
109365: PUSH
109366: LD_INT 14
109368: EQUAL
109369: IFFALSE 109379
// sFlag := true ;
109371: LD_ADDR_EXP 161
109375: PUSH
109376: LD_INT 1
109378: ST_TO_ADDR
// if p3 = 15 then
109379: LD_VAR 0 3
109383: PUSH
109384: LD_INT 15
109386: EQUAL
109387: IFFALSE 109397
// sKamikadze := true ;
109389: LD_ADDR_EXP 169
109393: PUSH
109394: LD_INT 1
109396: ST_TO_ADDR
// if p3 = 16 then
109397: LD_VAR 0 3
109401: PUSH
109402: LD_INT 16
109404: EQUAL
109405: IFFALSE 109415
// sTroll := true ;
109407: LD_ADDR_EXP 170
109411: PUSH
109412: LD_INT 1
109414: ST_TO_ADDR
// if p3 = 17 then
109415: LD_VAR 0 3
109419: PUSH
109420: LD_INT 17
109422: EQUAL
109423: IFFALSE 109433
// sSlow := true ;
109425: LD_ADDR_EXP 171
109429: PUSH
109430: LD_INT 1
109432: ST_TO_ADDR
// if p3 = 18 then
109433: LD_VAR 0 3
109437: PUSH
109438: LD_INT 18
109440: EQUAL
109441: IFFALSE 109451
// sLack := true ;
109443: LD_ADDR_EXP 172
109447: PUSH
109448: LD_INT 1
109450: ST_TO_ADDR
// if p3 = 19 then
109451: LD_VAR 0 3
109455: PUSH
109456: LD_INT 19
109458: EQUAL
109459: IFFALSE 109469
// sTank := true ;
109461: LD_ADDR_EXP 174
109465: PUSH
109466: LD_INT 1
109468: ST_TO_ADDR
// if p3 = 20 then
109469: LD_VAR 0 3
109473: PUSH
109474: LD_INT 20
109476: EQUAL
109477: IFFALSE 109487
// sRemote := true ;
109479: LD_ADDR_EXP 175
109483: PUSH
109484: LD_INT 1
109486: ST_TO_ADDR
// if p3 = 21 then
109487: LD_VAR 0 3
109491: PUSH
109492: LD_INT 21
109494: EQUAL
109495: IFFALSE 109505
// sPowell := true ;
109497: LD_ADDR_EXP 176
109501: PUSH
109502: LD_INT 1
109504: ST_TO_ADDR
// if p3 = 22 then
109505: LD_VAR 0 3
109509: PUSH
109510: LD_INT 22
109512: EQUAL
109513: IFFALSE 109523
// sTeleport := true ;
109515: LD_ADDR_EXP 179
109519: PUSH
109520: LD_INT 1
109522: ST_TO_ADDR
// if p3 = 23 then
109523: LD_VAR 0 3
109527: PUSH
109528: LD_INT 23
109530: EQUAL
109531: IFFALSE 109541
// sOilTower := true ;
109533: LD_ADDR_EXP 181
109537: PUSH
109538: LD_INT 1
109540: ST_TO_ADDR
// if p3 = 24 then
109541: LD_VAR 0 3
109545: PUSH
109546: LD_INT 24
109548: EQUAL
109549: IFFALSE 109559
// sShovel := true ;
109551: LD_ADDR_EXP 182
109555: PUSH
109556: LD_INT 1
109558: ST_TO_ADDR
// if p3 = 25 then
109559: LD_VAR 0 3
109563: PUSH
109564: LD_INT 25
109566: EQUAL
109567: IFFALSE 109577
// sSheik := true ;
109569: LD_ADDR_EXP 183
109573: PUSH
109574: LD_INT 1
109576: ST_TO_ADDR
// if p3 = 26 then
109577: LD_VAR 0 3
109581: PUSH
109582: LD_INT 26
109584: EQUAL
109585: IFFALSE 109595
// sEarthquake := true ;
109587: LD_ADDR_EXP 185
109591: PUSH
109592: LD_INT 1
109594: ST_TO_ADDR
// if p3 = 27 then
109595: LD_VAR 0 3
109599: PUSH
109600: LD_INT 27
109602: EQUAL
109603: IFFALSE 109613
// sAI := true ;
109605: LD_ADDR_EXP 186
109609: PUSH
109610: LD_INT 1
109612: ST_TO_ADDR
// if p3 = 28 then
109613: LD_VAR 0 3
109617: PUSH
109618: LD_INT 28
109620: EQUAL
109621: IFFALSE 109631
// sCargo := true ;
109623: LD_ADDR_EXP 189
109627: PUSH
109628: LD_INT 1
109630: ST_TO_ADDR
// if p3 = 29 then
109631: LD_VAR 0 3
109635: PUSH
109636: LD_INT 29
109638: EQUAL
109639: IFFALSE 109649
// sDLaser := true ;
109641: LD_ADDR_EXP 190
109645: PUSH
109646: LD_INT 1
109648: ST_TO_ADDR
// if p3 = 30 then
109649: LD_VAR 0 3
109653: PUSH
109654: LD_INT 30
109656: EQUAL
109657: IFFALSE 109667
// sExchange := true ;
109659: LD_ADDR_EXP 191
109663: PUSH
109664: LD_INT 1
109666: ST_TO_ADDR
// if p3 = 31 then
109667: LD_VAR 0 3
109671: PUSH
109672: LD_INT 31
109674: EQUAL
109675: IFFALSE 109685
// sFac := true ;
109677: LD_ADDR_EXP 192
109681: PUSH
109682: LD_INT 1
109684: ST_TO_ADDR
// if p3 = 32 then
109685: LD_VAR 0 3
109689: PUSH
109690: LD_INT 32
109692: EQUAL
109693: IFFALSE 109703
// sPower := true ;
109695: LD_ADDR_EXP 193
109699: PUSH
109700: LD_INT 1
109702: ST_TO_ADDR
// if p3 = 33 then
109703: LD_VAR 0 3
109707: PUSH
109708: LD_INT 33
109710: EQUAL
109711: IFFALSE 109721
// sRandom := true ;
109713: LD_ADDR_EXP 194
109717: PUSH
109718: LD_INT 1
109720: ST_TO_ADDR
// if p3 = 34 then
109721: LD_VAR 0 3
109725: PUSH
109726: LD_INT 34
109728: EQUAL
109729: IFFALSE 109739
// sShield := true ;
109731: LD_ADDR_EXP 195
109735: PUSH
109736: LD_INT 1
109738: ST_TO_ADDR
// if p3 = 35 then
109739: LD_VAR 0 3
109743: PUSH
109744: LD_INT 35
109746: EQUAL
109747: IFFALSE 109757
// sTime := true ;
109749: LD_ADDR_EXP 196
109753: PUSH
109754: LD_INT 1
109756: ST_TO_ADDR
// if p3 = 36 then
109757: LD_VAR 0 3
109761: PUSH
109762: LD_INT 36
109764: EQUAL
109765: IFFALSE 109775
// sTools := true ;
109767: LD_ADDR_EXP 197
109771: PUSH
109772: LD_INT 1
109774: ST_TO_ADDR
// if p3 = 101 then
109775: LD_VAR 0 3
109779: PUSH
109780: LD_INT 101
109782: EQUAL
109783: IFFALSE 109793
// sSold := true ;
109785: LD_ADDR_EXP 162
109789: PUSH
109790: LD_INT 1
109792: ST_TO_ADDR
// if p3 = 102 then
109793: LD_VAR 0 3
109797: PUSH
109798: LD_INT 102
109800: EQUAL
109801: IFFALSE 109811
// sDiff := true ;
109803: LD_ADDR_EXP 163
109807: PUSH
109808: LD_INT 1
109810: ST_TO_ADDR
// if p3 = 103 then
109811: LD_VAR 0 3
109815: PUSH
109816: LD_INT 103
109818: EQUAL
109819: IFFALSE 109829
// sFog := true ;
109821: LD_ADDR_EXP 166
109825: PUSH
109826: LD_INT 1
109828: ST_TO_ADDR
// if p3 = 104 then
109829: LD_VAR 0 3
109833: PUSH
109834: LD_INT 104
109836: EQUAL
109837: IFFALSE 109847
// sReset := true ;
109839: LD_ADDR_EXP 167
109843: PUSH
109844: LD_INT 1
109846: ST_TO_ADDR
// if p3 = 105 then
109847: LD_VAR 0 3
109851: PUSH
109852: LD_INT 105
109854: EQUAL
109855: IFFALSE 109865
// sSun := true ;
109857: LD_ADDR_EXP 168
109861: PUSH
109862: LD_INT 1
109864: ST_TO_ADDR
// if p3 = 106 then
109865: LD_VAR 0 3
109869: PUSH
109870: LD_INT 106
109872: EQUAL
109873: IFFALSE 109883
// sTiger := true ;
109875: LD_ADDR_EXP 164
109879: PUSH
109880: LD_INT 1
109882: ST_TO_ADDR
// if p3 = 107 then
109883: LD_VAR 0 3
109887: PUSH
109888: LD_INT 107
109890: EQUAL
109891: IFFALSE 109901
// sBomb := true ;
109893: LD_ADDR_EXP 165
109897: PUSH
109898: LD_INT 1
109900: ST_TO_ADDR
// if p3 = 108 then
109901: LD_VAR 0 3
109905: PUSH
109906: LD_INT 108
109908: EQUAL
109909: IFFALSE 109919
// sWound := true ;
109911: LD_ADDR_EXP 173
109915: PUSH
109916: LD_INT 1
109918: ST_TO_ADDR
// if p3 = 109 then
109919: LD_VAR 0 3
109923: PUSH
109924: LD_INT 109
109926: EQUAL
109927: IFFALSE 109937
// sBetray := true ;
109929: LD_ADDR_EXP 177
109933: PUSH
109934: LD_INT 1
109936: ST_TO_ADDR
// if p3 = 110 then
109937: LD_VAR 0 3
109941: PUSH
109942: LD_INT 110
109944: EQUAL
109945: IFFALSE 109955
// sContamin := true ;
109947: LD_ADDR_EXP 178
109951: PUSH
109952: LD_INT 1
109954: ST_TO_ADDR
// if p3 = 111 then
109955: LD_VAR 0 3
109959: PUSH
109960: LD_INT 111
109962: EQUAL
109963: IFFALSE 109973
// sOil := true ;
109965: LD_ADDR_EXP 180
109969: PUSH
109970: LD_INT 1
109972: ST_TO_ADDR
// if p3 = 112 then
109973: LD_VAR 0 3
109977: PUSH
109978: LD_INT 112
109980: EQUAL
109981: IFFALSE 109991
// sStu := true ;
109983: LD_ADDR_EXP 184
109987: PUSH
109988: LD_INT 1
109990: ST_TO_ADDR
// if p3 = 113 then
109991: LD_VAR 0 3
109995: PUSH
109996: LD_INT 113
109998: EQUAL
109999: IFFALSE 110009
// sBazooka := true ;
110001: LD_ADDR_EXP 187
110005: PUSH
110006: LD_INT 1
110008: ST_TO_ADDR
// if p3 = 114 then
110009: LD_VAR 0 3
110013: PUSH
110014: LD_INT 114
110016: EQUAL
110017: IFFALSE 110027
// sMortar := true ;
110019: LD_ADDR_EXP 188
110023: PUSH
110024: LD_INT 1
110026: ST_TO_ADDR
// if p3 = 115 then
110027: LD_VAR 0 3
110031: PUSH
110032: LD_INT 115
110034: EQUAL
110035: IFFALSE 110045
// sRanger := true ;
110037: LD_ADDR_EXP 198
110041: PUSH
110042: LD_INT 1
110044: ST_TO_ADDR
// if p3 = 116 then
110045: LD_VAR 0 3
110049: PUSH
110050: LD_INT 116
110052: EQUAL
110053: IFFALSE 110063
// sComputer := true ;
110055: LD_ADDR_EXP 199
110059: PUSH
110060: LD_INT 1
110062: ST_TO_ADDR
// if p3 = 117 then
110063: LD_VAR 0 3
110067: PUSH
110068: LD_INT 117
110070: EQUAL
110071: IFFALSE 110081
// s30 := true ;
110073: LD_ADDR_EXP 200
110077: PUSH
110078: LD_INT 1
110080: ST_TO_ADDR
// if p3 = 118 then
110081: LD_VAR 0 3
110085: PUSH
110086: LD_INT 118
110088: EQUAL
110089: IFFALSE 110099
// s60 := true ;
110091: LD_ADDR_EXP 201
110095: PUSH
110096: LD_INT 1
110098: ST_TO_ADDR
// end ; if p2 = hack_mode then
110099: LD_VAR 0 2
110103: PUSH
110104: LD_INT 101
110106: EQUAL
110107: IFFALSE 110235
// begin case p3 of 1 :
110109: LD_VAR 0 3
110113: PUSH
110114: LD_INT 1
110116: DOUBLE
110117: EQUAL
110118: IFTRUE 110122
110120: GO 110129
110122: POP
// hHackUnlimitedResources ; 2 :
110123: CALL 122406 0 0
110127: GO 110235
110129: LD_INT 2
110131: DOUBLE
110132: EQUAL
110133: IFTRUE 110137
110135: GO 110144
110137: POP
// hHackSetLevel10 ; 3 :
110138: CALL 122539 0 0
110142: GO 110235
110144: LD_INT 3
110146: DOUBLE
110147: EQUAL
110148: IFTRUE 110152
110150: GO 110159
110152: POP
// hHackSetLevel10YourUnits ; 4 :
110153: CALL 122624 0 0
110157: GO 110235
110159: LD_INT 4
110161: DOUBLE
110162: EQUAL
110163: IFTRUE 110167
110165: GO 110174
110167: POP
// hHackInvincible ; 5 :
110168: CALL 123072 0 0
110172: GO 110235
110174: LD_INT 5
110176: DOUBLE
110177: EQUAL
110178: IFTRUE 110182
110180: GO 110189
110182: POP
// hHackInvisible ; 6 :
110183: CALL 123183 0 0
110187: GO 110235
110189: LD_INT 6
110191: DOUBLE
110192: EQUAL
110193: IFTRUE 110197
110195: GO 110204
110197: POP
// hHackChangeYourSide ; 7 :
110198: CALL 123240 0 0
110202: GO 110235
110204: LD_INT 7
110206: DOUBLE
110207: EQUAL
110208: IFTRUE 110212
110210: GO 110219
110212: POP
// hHackChangeUnitSide ; 8 :
110213: CALL 123282 0 0
110217: GO 110235
110219: LD_INT 8
110221: DOUBLE
110222: EQUAL
110223: IFTRUE 110227
110225: GO 110234
110227: POP
// hHackFog ; end ;
110228: CALL 123383 0 0
110232: GO 110235
110234: POP
// end ; if p2 = game_save_mode then
110235: LD_VAR 0 2
110239: PUSH
110240: LD_INT 102
110242: EQUAL
110243: IFFALSE 110308
// begin if p3 = 1 then
110245: LD_VAR 0 3
110249: PUSH
110250: LD_INT 1
110252: EQUAL
110253: IFFALSE 110265
// globalGameSaveCounter := p4 ;
110255: LD_ADDR_EXP 144
110259: PUSH
110260: LD_VAR 0 4
110264: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
110265: LD_VAR 0 3
110269: PUSH
110270: LD_INT 2
110272: EQUAL
110273: PUSH
110274: LD_EXP 144
110278: AND
110279: IFFALSE 110298
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
110281: LD_STRING setGameSaveCounter(
110283: PUSH
110284: LD_EXP 144
110288: STR
110289: PUSH
110290: LD_STRING )
110292: STR
110293: PPUSH
110294: CALL_OW 559
// display_strings := globalGameSaveCounter ;
110298: LD_ADDR_OWVAR 47
110302: PUSH
110303: LD_EXP 144
110307: ST_TO_ADDR
// end ; end ;
110308: LD_VAR 0 7
110312: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
110313: GO 110315
110315: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
110316: LD_STRING initStreamRollete();
110318: PPUSH
110319: CALL_OW 559
// InitStreamMode ;
110323: CALL 110335 0 0
// DefineStreamItems ( false ) ;
110327: LD_INT 0
110329: PPUSH
110330: CALL 110799 0 1
// end ;
110334: END
// function InitStreamMode ; begin
110335: LD_INT 0
110337: PPUSH
// streamModeActive := false ;
110338: LD_ADDR_EXP 145
110342: PUSH
110343: LD_INT 0
110345: ST_TO_ADDR
// normalCounter := 36 ;
110346: LD_ADDR_EXP 146
110350: PUSH
110351: LD_INT 36
110353: ST_TO_ADDR
// hardcoreCounter := 18 ;
110354: LD_ADDR_EXP 147
110358: PUSH
110359: LD_INT 18
110361: ST_TO_ADDR
// sRocket := false ;
110362: LD_ADDR_EXP 150
110366: PUSH
110367: LD_INT 0
110369: ST_TO_ADDR
// sSpeed := false ;
110370: LD_ADDR_EXP 149
110374: PUSH
110375: LD_INT 0
110377: ST_TO_ADDR
// sEngine := false ;
110378: LD_ADDR_EXP 151
110382: PUSH
110383: LD_INT 0
110385: ST_TO_ADDR
// sSpec := false ;
110386: LD_ADDR_EXP 148
110390: PUSH
110391: LD_INT 0
110393: ST_TO_ADDR
// sLevel := false ;
110394: LD_ADDR_EXP 152
110398: PUSH
110399: LD_INT 0
110401: ST_TO_ADDR
// sArmoury := false ;
110402: LD_ADDR_EXP 153
110406: PUSH
110407: LD_INT 0
110409: ST_TO_ADDR
// sRadar := false ;
110410: LD_ADDR_EXP 154
110414: PUSH
110415: LD_INT 0
110417: ST_TO_ADDR
// sBunker := false ;
110418: LD_ADDR_EXP 155
110422: PUSH
110423: LD_INT 0
110425: ST_TO_ADDR
// sHack := false ;
110426: LD_ADDR_EXP 156
110430: PUSH
110431: LD_INT 0
110433: ST_TO_ADDR
// sFire := false ;
110434: LD_ADDR_EXP 157
110438: PUSH
110439: LD_INT 0
110441: ST_TO_ADDR
// sRefresh := false ;
110442: LD_ADDR_EXP 158
110446: PUSH
110447: LD_INT 0
110449: ST_TO_ADDR
// sExp := false ;
110450: LD_ADDR_EXP 159
110454: PUSH
110455: LD_INT 0
110457: ST_TO_ADDR
// sDepot := false ;
110458: LD_ADDR_EXP 160
110462: PUSH
110463: LD_INT 0
110465: ST_TO_ADDR
// sFlag := false ;
110466: LD_ADDR_EXP 161
110470: PUSH
110471: LD_INT 0
110473: ST_TO_ADDR
// sKamikadze := false ;
110474: LD_ADDR_EXP 169
110478: PUSH
110479: LD_INT 0
110481: ST_TO_ADDR
// sTroll := false ;
110482: LD_ADDR_EXP 170
110486: PUSH
110487: LD_INT 0
110489: ST_TO_ADDR
// sSlow := false ;
110490: LD_ADDR_EXP 171
110494: PUSH
110495: LD_INT 0
110497: ST_TO_ADDR
// sLack := false ;
110498: LD_ADDR_EXP 172
110502: PUSH
110503: LD_INT 0
110505: ST_TO_ADDR
// sTank := false ;
110506: LD_ADDR_EXP 174
110510: PUSH
110511: LD_INT 0
110513: ST_TO_ADDR
// sRemote := false ;
110514: LD_ADDR_EXP 175
110518: PUSH
110519: LD_INT 0
110521: ST_TO_ADDR
// sPowell := false ;
110522: LD_ADDR_EXP 176
110526: PUSH
110527: LD_INT 0
110529: ST_TO_ADDR
// sTeleport := false ;
110530: LD_ADDR_EXP 179
110534: PUSH
110535: LD_INT 0
110537: ST_TO_ADDR
// sOilTower := false ;
110538: LD_ADDR_EXP 181
110542: PUSH
110543: LD_INT 0
110545: ST_TO_ADDR
// sShovel := false ;
110546: LD_ADDR_EXP 182
110550: PUSH
110551: LD_INT 0
110553: ST_TO_ADDR
// sSheik := false ;
110554: LD_ADDR_EXP 183
110558: PUSH
110559: LD_INT 0
110561: ST_TO_ADDR
// sEarthquake := false ;
110562: LD_ADDR_EXP 185
110566: PUSH
110567: LD_INT 0
110569: ST_TO_ADDR
// sAI := false ;
110570: LD_ADDR_EXP 186
110574: PUSH
110575: LD_INT 0
110577: ST_TO_ADDR
// sCargo := false ;
110578: LD_ADDR_EXP 189
110582: PUSH
110583: LD_INT 0
110585: ST_TO_ADDR
// sDLaser := false ;
110586: LD_ADDR_EXP 190
110590: PUSH
110591: LD_INT 0
110593: ST_TO_ADDR
// sExchange := false ;
110594: LD_ADDR_EXP 191
110598: PUSH
110599: LD_INT 0
110601: ST_TO_ADDR
// sFac := false ;
110602: LD_ADDR_EXP 192
110606: PUSH
110607: LD_INT 0
110609: ST_TO_ADDR
// sPower := false ;
110610: LD_ADDR_EXP 193
110614: PUSH
110615: LD_INT 0
110617: ST_TO_ADDR
// sRandom := false ;
110618: LD_ADDR_EXP 194
110622: PUSH
110623: LD_INT 0
110625: ST_TO_ADDR
// sShield := false ;
110626: LD_ADDR_EXP 195
110630: PUSH
110631: LD_INT 0
110633: ST_TO_ADDR
// sTime := false ;
110634: LD_ADDR_EXP 196
110638: PUSH
110639: LD_INT 0
110641: ST_TO_ADDR
// sTools := false ;
110642: LD_ADDR_EXP 197
110646: PUSH
110647: LD_INT 0
110649: ST_TO_ADDR
// sSold := false ;
110650: LD_ADDR_EXP 162
110654: PUSH
110655: LD_INT 0
110657: ST_TO_ADDR
// sDiff := false ;
110658: LD_ADDR_EXP 163
110662: PUSH
110663: LD_INT 0
110665: ST_TO_ADDR
// sFog := false ;
110666: LD_ADDR_EXP 166
110670: PUSH
110671: LD_INT 0
110673: ST_TO_ADDR
// sReset := false ;
110674: LD_ADDR_EXP 167
110678: PUSH
110679: LD_INT 0
110681: ST_TO_ADDR
// sSun := false ;
110682: LD_ADDR_EXP 168
110686: PUSH
110687: LD_INT 0
110689: ST_TO_ADDR
// sTiger := false ;
110690: LD_ADDR_EXP 164
110694: PUSH
110695: LD_INT 0
110697: ST_TO_ADDR
// sBomb := false ;
110698: LD_ADDR_EXP 165
110702: PUSH
110703: LD_INT 0
110705: ST_TO_ADDR
// sWound := false ;
110706: LD_ADDR_EXP 173
110710: PUSH
110711: LD_INT 0
110713: ST_TO_ADDR
// sBetray := false ;
110714: LD_ADDR_EXP 177
110718: PUSH
110719: LD_INT 0
110721: ST_TO_ADDR
// sContamin := false ;
110722: LD_ADDR_EXP 178
110726: PUSH
110727: LD_INT 0
110729: ST_TO_ADDR
// sOil := false ;
110730: LD_ADDR_EXP 180
110734: PUSH
110735: LD_INT 0
110737: ST_TO_ADDR
// sStu := false ;
110738: LD_ADDR_EXP 184
110742: PUSH
110743: LD_INT 0
110745: ST_TO_ADDR
// sBazooka := false ;
110746: LD_ADDR_EXP 187
110750: PUSH
110751: LD_INT 0
110753: ST_TO_ADDR
// sMortar := false ;
110754: LD_ADDR_EXP 188
110758: PUSH
110759: LD_INT 0
110761: ST_TO_ADDR
// sRanger := false ;
110762: LD_ADDR_EXP 198
110766: PUSH
110767: LD_INT 0
110769: ST_TO_ADDR
// sComputer := false ;
110770: LD_ADDR_EXP 199
110774: PUSH
110775: LD_INT 0
110777: ST_TO_ADDR
// s30 := false ;
110778: LD_ADDR_EXP 200
110782: PUSH
110783: LD_INT 0
110785: ST_TO_ADDR
// s60 := false ;
110786: LD_ADDR_EXP 201
110790: PUSH
110791: LD_INT 0
110793: ST_TO_ADDR
// end ;
110794: LD_VAR 0 1
110798: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
110799: LD_INT 0
110801: PPUSH
110802: PPUSH
110803: PPUSH
110804: PPUSH
110805: PPUSH
110806: PPUSH
110807: PPUSH
// result := [ ] ;
110808: LD_ADDR_VAR 0 2
110812: PUSH
110813: EMPTY
110814: ST_TO_ADDR
// if campaign_id = 1 then
110815: LD_OWVAR 69
110819: PUSH
110820: LD_INT 1
110822: EQUAL
110823: IFFALSE 113989
// begin case mission_number of 1 :
110825: LD_OWVAR 70
110829: PUSH
110830: LD_INT 1
110832: DOUBLE
110833: EQUAL
110834: IFTRUE 110838
110836: GO 110914
110838: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
110839: LD_ADDR_VAR 0 2
110843: PUSH
110844: LD_INT 2
110846: PUSH
110847: LD_INT 4
110849: PUSH
110850: LD_INT 11
110852: PUSH
110853: LD_INT 12
110855: PUSH
110856: LD_INT 15
110858: PUSH
110859: LD_INT 16
110861: PUSH
110862: LD_INT 22
110864: PUSH
110865: LD_INT 23
110867: PUSH
110868: LD_INT 26
110870: PUSH
110871: EMPTY
110872: LIST
110873: LIST
110874: LIST
110875: LIST
110876: LIST
110877: LIST
110878: LIST
110879: LIST
110880: LIST
110881: PUSH
110882: LD_INT 101
110884: PUSH
110885: LD_INT 102
110887: PUSH
110888: LD_INT 106
110890: PUSH
110891: LD_INT 116
110893: PUSH
110894: LD_INT 117
110896: PUSH
110897: LD_INT 118
110899: PUSH
110900: EMPTY
110901: LIST
110902: LIST
110903: LIST
110904: LIST
110905: LIST
110906: LIST
110907: PUSH
110908: EMPTY
110909: LIST
110910: LIST
110911: ST_TO_ADDR
110912: GO 113987
110914: LD_INT 2
110916: DOUBLE
110917: EQUAL
110918: IFTRUE 110922
110920: GO 111006
110922: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
110923: LD_ADDR_VAR 0 2
110927: PUSH
110928: LD_INT 2
110930: PUSH
110931: LD_INT 4
110933: PUSH
110934: LD_INT 11
110936: PUSH
110937: LD_INT 12
110939: PUSH
110940: LD_INT 15
110942: PUSH
110943: LD_INT 16
110945: PUSH
110946: LD_INT 22
110948: PUSH
110949: LD_INT 23
110951: PUSH
110952: LD_INT 26
110954: PUSH
110955: EMPTY
110956: LIST
110957: LIST
110958: LIST
110959: LIST
110960: LIST
110961: LIST
110962: LIST
110963: LIST
110964: LIST
110965: PUSH
110966: LD_INT 101
110968: PUSH
110969: LD_INT 102
110971: PUSH
110972: LD_INT 105
110974: PUSH
110975: LD_INT 106
110977: PUSH
110978: LD_INT 108
110980: PUSH
110981: LD_INT 116
110983: PUSH
110984: LD_INT 117
110986: PUSH
110987: LD_INT 118
110989: PUSH
110990: EMPTY
110991: LIST
110992: LIST
110993: LIST
110994: LIST
110995: LIST
110996: LIST
110997: LIST
110998: LIST
110999: PUSH
111000: EMPTY
111001: LIST
111002: LIST
111003: ST_TO_ADDR
111004: GO 113987
111006: LD_INT 3
111008: DOUBLE
111009: EQUAL
111010: IFTRUE 111014
111012: GO 111102
111014: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
111015: LD_ADDR_VAR 0 2
111019: PUSH
111020: LD_INT 2
111022: PUSH
111023: LD_INT 4
111025: PUSH
111026: LD_INT 5
111028: PUSH
111029: LD_INT 11
111031: PUSH
111032: LD_INT 12
111034: PUSH
111035: LD_INT 15
111037: PUSH
111038: LD_INT 16
111040: PUSH
111041: LD_INT 22
111043: PUSH
111044: LD_INT 26
111046: PUSH
111047: LD_INT 36
111049: PUSH
111050: EMPTY
111051: LIST
111052: LIST
111053: LIST
111054: LIST
111055: LIST
111056: LIST
111057: LIST
111058: LIST
111059: LIST
111060: LIST
111061: PUSH
111062: LD_INT 101
111064: PUSH
111065: LD_INT 102
111067: PUSH
111068: LD_INT 105
111070: PUSH
111071: LD_INT 106
111073: PUSH
111074: LD_INT 108
111076: PUSH
111077: LD_INT 116
111079: PUSH
111080: LD_INT 117
111082: PUSH
111083: LD_INT 118
111085: PUSH
111086: EMPTY
111087: LIST
111088: LIST
111089: LIST
111090: LIST
111091: LIST
111092: LIST
111093: LIST
111094: LIST
111095: PUSH
111096: EMPTY
111097: LIST
111098: LIST
111099: ST_TO_ADDR
111100: GO 113987
111102: LD_INT 4
111104: DOUBLE
111105: EQUAL
111106: IFTRUE 111110
111108: GO 111206
111110: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
111111: LD_ADDR_VAR 0 2
111115: PUSH
111116: LD_INT 2
111118: PUSH
111119: LD_INT 4
111121: PUSH
111122: LD_INT 5
111124: PUSH
111125: LD_INT 8
111127: PUSH
111128: LD_INT 11
111130: PUSH
111131: LD_INT 12
111133: PUSH
111134: LD_INT 15
111136: PUSH
111137: LD_INT 16
111139: PUSH
111140: LD_INT 22
111142: PUSH
111143: LD_INT 23
111145: PUSH
111146: LD_INT 26
111148: PUSH
111149: LD_INT 36
111151: PUSH
111152: EMPTY
111153: LIST
111154: LIST
111155: LIST
111156: LIST
111157: LIST
111158: LIST
111159: LIST
111160: LIST
111161: LIST
111162: LIST
111163: LIST
111164: LIST
111165: PUSH
111166: LD_INT 101
111168: PUSH
111169: LD_INT 102
111171: PUSH
111172: LD_INT 105
111174: PUSH
111175: LD_INT 106
111177: PUSH
111178: LD_INT 108
111180: PUSH
111181: LD_INT 116
111183: PUSH
111184: LD_INT 117
111186: PUSH
111187: LD_INT 118
111189: PUSH
111190: EMPTY
111191: LIST
111192: LIST
111193: LIST
111194: LIST
111195: LIST
111196: LIST
111197: LIST
111198: LIST
111199: PUSH
111200: EMPTY
111201: LIST
111202: LIST
111203: ST_TO_ADDR
111204: GO 113987
111206: LD_INT 5
111208: DOUBLE
111209: EQUAL
111210: IFTRUE 111214
111212: GO 111326
111214: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
111215: LD_ADDR_VAR 0 2
111219: PUSH
111220: LD_INT 2
111222: PUSH
111223: LD_INT 4
111225: PUSH
111226: LD_INT 5
111228: PUSH
111229: LD_INT 6
111231: PUSH
111232: LD_INT 8
111234: PUSH
111235: LD_INT 11
111237: PUSH
111238: LD_INT 12
111240: PUSH
111241: LD_INT 15
111243: PUSH
111244: LD_INT 16
111246: PUSH
111247: LD_INT 22
111249: PUSH
111250: LD_INT 23
111252: PUSH
111253: LD_INT 25
111255: PUSH
111256: LD_INT 26
111258: PUSH
111259: LD_INT 36
111261: PUSH
111262: EMPTY
111263: LIST
111264: LIST
111265: LIST
111266: LIST
111267: LIST
111268: LIST
111269: LIST
111270: LIST
111271: LIST
111272: LIST
111273: LIST
111274: LIST
111275: LIST
111276: LIST
111277: PUSH
111278: LD_INT 101
111280: PUSH
111281: LD_INT 102
111283: PUSH
111284: LD_INT 105
111286: PUSH
111287: LD_INT 106
111289: PUSH
111290: LD_INT 108
111292: PUSH
111293: LD_INT 109
111295: PUSH
111296: LD_INT 112
111298: PUSH
111299: LD_INT 116
111301: PUSH
111302: LD_INT 117
111304: PUSH
111305: LD_INT 118
111307: PUSH
111308: EMPTY
111309: LIST
111310: LIST
111311: LIST
111312: LIST
111313: LIST
111314: LIST
111315: LIST
111316: LIST
111317: LIST
111318: LIST
111319: PUSH
111320: EMPTY
111321: LIST
111322: LIST
111323: ST_TO_ADDR
111324: GO 113987
111326: LD_INT 6
111328: DOUBLE
111329: EQUAL
111330: IFTRUE 111334
111332: GO 111466
111334: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
111335: LD_ADDR_VAR 0 2
111339: PUSH
111340: LD_INT 2
111342: PUSH
111343: LD_INT 4
111345: PUSH
111346: LD_INT 5
111348: PUSH
111349: LD_INT 6
111351: PUSH
111352: LD_INT 8
111354: PUSH
111355: LD_INT 11
111357: PUSH
111358: LD_INT 12
111360: PUSH
111361: LD_INT 15
111363: PUSH
111364: LD_INT 16
111366: PUSH
111367: LD_INT 20
111369: PUSH
111370: LD_INT 21
111372: PUSH
111373: LD_INT 22
111375: PUSH
111376: LD_INT 23
111378: PUSH
111379: LD_INT 25
111381: PUSH
111382: LD_INT 26
111384: PUSH
111385: LD_INT 30
111387: PUSH
111388: LD_INT 31
111390: PUSH
111391: LD_INT 32
111393: PUSH
111394: LD_INT 36
111396: PUSH
111397: EMPTY
111398: LIST
111399: LIST
111400: LIST
111401: LIST
111402: LIST
111403: LIST
111404: LIST
111405: LIST
111406: LIST
111407: LIST
111408: LIST
111409: LIST
111410: LIST
111411: LIST
111412: LIST
111413: LIST
111414: LIST
111415: LIST
111416: LIST
111417: PUSH
111418: LD_INT 101
111420: PUSH
111421: LD_INT 102
111423: PUSH
111424: LD_INT 105
111426: PUSH
111427: LD_INT 106
111429: PUSH
111430: LD_INT 108
111432: PUSH
111433: LD_INT 109
111435: PUSH
111436: LD_INT 112
111438: PUSH
111439: LD_INT 116
111441: PUSH
111442: LD_INT 117
111444: PUSH
111445: LD_INT 118
111447: PUSH
111448: EMPTY
111449: LIST
111450: LIST
111451: LIST
111452: LIST
111453: LIST
111454: LIST
111455: LIST
111456: LIST
111457: LIST
111458: LIST
111459: PUSH
111460: EMPTY
111461: LIST
111462: LIST
111463: ST_TO_ADDR
111464: GO 113987
111466: LD_INT 7
111468: DOUBLE
111469: EQUAL
111470: IFTRUE 111474
111472: GO 111586
111474: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
111475: LD_ADDR_VAR 0 2
111479: PUSH
111480: LD_INT 2
111482: PUSH
111483: LD_INT 4
111485: PUSH
111486: LD_INT 5
111488: PUSH
111489: LD_INT 7
111491: PUSH
111492: LD_INT 11
111494: PUSH
111495: LD_INT 12
111497: PUSH
111498: LD_INT 15
111500: PUSH
111501: LD_INT 16
111503: PUSH
111504: LD_INT 20
111506: PUSH
111507: LD_INT 21
111509: PUSH
111510: LD_INT 22
111512: PUSH
111513: LD_INT 23
111515: PUSH
111516: LD_INT 25
111518: PUSH
111519: LD_INT 26
111521: PUSH
111522: EMPTY
111523: LIST
111524: LIST
111525: LIST
111526: LIST
111527: LIST
111528: LIST
111529: LIST
111530: LIST
111531: LIST
111532: LIST
111533: LIST
111534: LIST
111535: LIST
111536: LIST
111537: PUSH
111538: LD_INT 101
111540: PUSH
111541: LD_INT 102
111543: PUSH
111544: LD_INT 103
111546: PUSH
111547: LD_INT 105
111549: PUSH
111550: LD_INT 106
111552: PUSH
111553: LD_INT 108
111555: PUSH
111556: LD_INT 112
111558: PUSH
111559: LD_INT 116
111561: PUSH
111562: LD_INT 117
111564: PUSH
111565: LD_INT 118
111567: PUSH
111568: EMPTY
111569: LIST
111570: LIST
111571: LIST
111572: LIST
111573: LIST
111574: LIST
111575: LIST
111576: LIST
111577: LIST
111578: LIST
111579: PUSH
111580: EMPTY
111581: LIST
111582: LIST
111583: ST_TO_ADDR
111584: GO 113987
111586: LD_INT 8
111588: DOUBLE
111589: EQUAL
111590: IFTRUE 111594
111592: GO 111734
111594: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
111595: LD_ADDR_VAR 0 2
111599: PUSH
111600: LD_INT 2
111602: PUSH
111603: LD_INT 4
111605: PUSH
111606: LD_INT 5
111608: PUSH
111609: LD_INT 6
111611: PUSH
111612: LD_INT 7
111614: PUSH
111615: LD_INT 8
111617: PUSH
111618: LD_INT 11
111620: PUSH
111621: LD_INT 12
111623: PUSH
111624: LD_INT 15
111626: PUSH
111627: LD_INT 16
111629: PUSH
111630: LD_INT 20
111632: PUSH
111633: LD_INT 21
111635: PUSH
111636: LD_INT 22
111638: PUSH
111639: LD_INT 23
111641: PUSH
111642: LD_INT 25
111644: PUSH
111645: LD_INT 26
111647: PUSH
111648: LD_INT 30
111650: PUSH
111651: LD_INT 31
111653: PUSH
111654: LD_INT 32
111656: PUSH
111657: LD_INT 36
111659: PUSH
111660: EMPTY
111661: LIST
111662: LIST
111663: LIST
111664: LIST
111665: LIST
111666: LIST
111667: LIST
111668: LIST
111669: LIST
111670: LIST
111671: LIST
111672: LIST
111673: LIST
111674: LIST
111675: LIST
111676: LIST
111677: LIST
111678: LIST
111679: LIST
111680: LIST
111681: PUSH
111682: LD_INT 101
111684: PUSH
111685: LD_INT 102
111687: PUSH
111688: LD_INT 103
111690: PUSH
111691: LD_INT 105
111693: PUSH
111694: LD_INT 106
111696: PUSH
111697: LD_INT 108
111699: PUSH
111700: LD_INT 109
111702: PUSH
111703: LD_INT 112
111705: PUSH
111706: LD_INT 116
111708: PUSH
111709: LD_INT 117
111711: PUSH
111712: LD_INT 118
111714: PUSH
111715: EMPTY
111716: LIST
111717: LIST
111718: LIST
111719: LIST
111720: LIST
111721: LIST
111722: LIST
111723: LIST
111724: LIST
111725: LIST
111726: LIST
111727: PUSH
111728: EMPTY
111729: LIST
111730: LIST
111731: ST_TO_ADDR
111732: GO 113987
111734: LD_INT 9
111736: DOUBLE
111737: EQUAL
111738: IFTRUE 111742
111740: GO 111890
111742: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
111743: LD_ADDR_VAR 0 2
111747: PUSH
111748: LD_INT 2
111750: PUSH
111751: LD_INT 4
111753: PUSH
111754: LD_INT 5
111756: PUSH
111757: LD_INT 6
111759: PUSH
111760: LD_INT 7
111762: PUSH
111763: LD_INT 8
111765: PUSH
111766: LD_INT 11
111768: PUSH
111769: LD_INT 12
111771: PUSH
111772: LD_INT 15
111774: PUSH
111775: LD_INT 16
111777: PUSH
111778: LD_INT 20
111780: PUSH
111781: LD_INT 21
111783: PUSH
111784: LD_INT 22
111786: PUSH
111787: LD_INT 23
111789: PUSH
111790: LD_INT 25
111792: PUSH
111793: LD_INT 26
111795: PUSH
111796: LD_INT 28
111798: PUSH
111799: LD_INT 30
111801: PUSH
111802: LD_INT 31
111804: PUSH
111805: LD_INT 32
111807: PUSH
111808: LD_INT 36
111810: PUSH
111811: EMPTY
111812: LIST
111813: LIST
111814: LIST
111815: LIST
111816: LIST
111817: LIST
111818: LIST
111819: LIST
111820: LIST
111821: LIST
111822: LIST
111823: LIST
111824: LIST
111825: LIST
111826: LIST
111827: LIST
111828: LIST
111829: LIST
111830: LIST
111831: LIST
111832: LIST
111833: PUSH
111834: LD_INT 101
111836: PUSH
111837: LD_INT 102
111839: PUSH
111840: LD_INT 103
111842: PUSH
111843: LD_INT 105
111845: PUSH
111846: LD_INT 106
111848: PUSH
111849: LD_INT 108
111851: PUSH
111852: LD_INT 109
111854: PUSH
111855: LD_INT 112
111857: PUSH
111858: LD_INT 114
111860: PUSH
111861: LD_INT 116
111863: PUSH
111864: LD_INT 117
111866: PUSH
111867: LD_INT 118
111869: PUSH
111870: EMPTY
111871: LIST
111872: LIST
111873: LIST
111874: LIST
111875: LIST
111876: LIST
111877: LIST
111878: LIST
111879: LIST
111880: LIST
111881: LIST
111882: LIST
111883: PUSH
111884: EMPTY
111885: LIST
111886: LIST
111887: ST_TO_ADDR
111888: GO 113987
111890: LD_INT 10
111892: DOUBLE
111893: EQUAL
111894: IFTRUE 111898
111896: GO 112094
111898: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
111899: LD_ADDR_VAR 0 2
111903: PUSH
111904: LD_INT 2
111906: PUSH
111907: LD_INT 4
111909: PUSH
111910: LD_INT 5
111912: PUSH
111913: LD_INT 6
111915: PUSH
111916: LD_INT 7
111918: PUSH
111919: LD_INT 8
111921: PUSH
111922: LD_INT 9
111924: PUSH
111925: LD_INT 10
111927: PUSH
111928: LD_INT 11
111930: PUSH
111931: LD_INT 12
111933: PUSH
111934: LD_INT 13
111936: PUSH
111937: LD_INT 14
111939: PUSH
111940: LD_INT 15
111942: PUSH
111943: LD_INT 16
111945: PUSH
111946: LD_INT 17
111948: PUSH
111949: LD_INT 18
111951: PUSH
111952: LD_INT 19
111954: PUSH
111955: LD_INT 20
111957: PUSH
111958: LD_INT 21
111960: PUSH
111961: LD_INT 22
111963: PUSH
111964: LD_INT 23
111966: PUSH
111967: LD_INT 24
111969: PUSH
111970: LD_INT 25
111972: PUSH
111973: LD_INT 26
111975: PUSH
111976: LD_INT 28
111978: PUSH
111979: LD_INT 30
111981: PUSH
111982: LD_INT 31
111984: PUSH
111985: LD_INT 32
111987: PUSH
111988: LD_INT 36
111990: PUSH
111991: EMPTY
111992: LIST
111993: LIST
111994: LIST
111995: LIST
111996: LIST
111997: LIST
111998: LIST
111999: LIST
112000: LIST
112001: LIST
112002: LIST
112003: LIST
112004: LIST
112005: LIST
112006: LIST
112007: LIST
112008: LIST
112009: LIST
112010: LIST
112011: LIST
112012: LIST
112013: LIST
112014: LIST
112015: LIST
112016: LIST
112017: LIST
112018: LIST
112019: LIST
112020: LIST
112021: PUSH
112022: LD_INT 101
112024: PUSH
112025: LD_INT 102
112027: PUSH
112028: LD_INT 103
112030: PUSH
112031: LD_INT 104
112033: PUSH
112034: LD_INT 105
112036: PUSH
112037: LD_INT 106
112039: PUSH
112040: LD_INT 107
112042: PUSH
112043: LD_INT 108
112045: PUSH
112046: LD_INT 109
112048: PUSH
112049: LD_INT 110
112051: PUSH
112052: LD_INT 111
112054: PUSH
112055: LD_INT 112
112057: PUSH
112058: LD_INT 114
112060: PUSH
112061: LD_INT 116
112063: PUSH
112064: LD_INT 117
112066: PUSH
112067: LD_INT 118
112069: PUSH
112070: EMPTY
112071: LIST
112072: LIST
112073: LIST
112074: LIST
112075: LIST
112076: LIST
112077: LIST
112078: LIST
112079: LIST
112080: LIST
112081: LIST
112082: LIST
112083: LIST
112084: LIST
112085: LIST
112086: LIST
112087: PUSH
112088: EMPTY
112089: LIST
112090: LIST
112091: ST_TO_ADDR
112092: GO 113987
112094: LD_INT 11
112096: DOUBLE
112097: EQUAL
112098: IFTRUE 112102
112100: GO 112306
112102: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
112103: LD_ADDR_VAR 0 2
112107: PUSH
112108: LD_INT 2
112110: PUSH
112111: LD_INT 3
112113: PUSH
112114: LD_INT 4
112116: PUSH
112117: LD_INT 5
112119: PUSH
112120: LD_INT 6
112122: PUSH
112123: LD_INT 7
112125: PUSH
112126: LD_INT 8
112128: PUSH
112129: LD_INT 9
112131: PUSH
112132: LD_INT 10
112134: PUSH
112135: LD_INT 11
112137: PUSH
112138: LD_INT 12
112140: PUSH
112141: LD_INT 13
112143: PUSH
112144: LD_INT 14
112146: PUSH
112147: LD_INT 15
112149: PUSH
112150: LD_INT 16
112152: PUSH
112153: LD_INT 17
112155: PUSH
112156: LD_INT 18
112158: PUSH
112159: LD_INT 19
112161: PUSH
112162: LD_INT 20
112164: PUSH
112165: LD_INT 21
112167: PUSH
112168: LD_INT 22
112170: PUSH
112171: LD_INT 23
112173: PUSH
112174: LD_INT 24
112176: PUSH
112177: LD_INT 25
112179: PUSH
112180: LD_INT 26
112182: PUSH
112183: LD_INT 28
112185: PUSH
112186: LD_INT 30
112188: PUSH
112189: LD_INT 31
112191: PUSH
112192: LD_INT 32
112194: PUSH
112195: LD_INT 34
112197: PUSH
112198: LD_INT 36
112200: PUSH
112201: EMPTY
112202: LIST
112203: LIST
112204: LIST
112205: LIST
112206: LIST
112207: LIST
112208: LIST
112209: LIST
112210: LIST
112211: LIST
112212: LIST
112213: LIST
112214: LIST
112215: LIST
112216: LIST
112217: LIST
112218: LIST
112219: LIST
112220: LIST
112221: LIST
112222: LIST
112223: LIST
112224: LIST
112225: LIST
112226: LIST
112227: LIST
112228: LIST
112229: LIST
112230: LIST
112231: LIST
112232: LIST
112233: PUSH
112234: LD_INT 101
112236: PUSH
112237: LD_INT 102
112239: PUSH
112240: LD_INT 103
112242: PUSH
112243: LD_INT 104
112245: PUSH
112246: LD_INT 105
112248: PUSH
112249: LD_INT 106
112251: PUSH
112252: LD_INT 107
112254: PUSH
112255: LD_INT 108
112257: PUSH
112258: LD_INT 109
112260: PUSH
112261: LD_INT 110
112263: PUSH
112264: LD_INT 111
112266: PUSH
112267: LD_INT 112
112269: PUSH
112270: LD_INT 114
112272: PUSH
112273: LD_INT 116
112275: PUSH
112276: LD_INT 117
112278: PUSH
112279: LD_INT 118
112281: PUSH
112282: EMPTY
112283: LIST
112284: LIST
112285: LIST
112286: LIST
112287: LIST
112288: LIST
112289: LIST
112290: LIST
112291: LIST
112292: LIST
112293: LIST
112294: LIST
112295: LIST
112296: LIST
112297: LIST
112298: LIST
112299: PUSH
112300: EMPTY
112301: LIST
112302: LIST
112303: ST_TO_ADDR
112304: GO 113987
112306: LD_INT 12
112308: DOUBLE
112309: EQUAL
112310: IFTRUE 112314
112312: GO 112534
112314: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
112315: LD_ADDR_VAR 0 2
112319: PUSH
112320: LD_INT 1
112322: PUSH
112323: LD_INT 2
112325: PUSH
112326: LD_INT 3
112328: PUSH
112329: LD_INT 4
112331: PUSH
112332: LD_INT 5
112334: PUSH
112335: LD_INT 6
112337: PUSH
112338: LD_INT 7
112340: PUSH
112341: LD_INT 8
112343: PUSH
112344: LD_INT 9
112346: PUSH
112347: LD_INT 10
112349: PUSH
112350: LD_INT 11
112352: PUSH
112353: LD_INT 12
112355: PUSH
112356: LD_INT 13
112358: PUSH
112359: LD_INT 14
112361: PUSH
112362: LD_INT 15
112364: PUSH
112365: LD_INT 16
112367: PUSH
112368: LD_INT 17
112370: PUSH
112371: LD_INT 18
112373: PUSH
112374: LD_INT 19
112376: PUSH
112377: LD_INT 20
112379: PUSH
112380: LD_INT 21
112382: PUSH
112383: LD_INT 22
112385: PUSH
112386: LD_INT 23
112388: PUSH
112389: LD_INT 24
112391: PUSH
112392: LD_INT 25
112394: PUSH
112395: LD_INT 26
112397: PUSH
112398: LD_INT 27
112400: PUSH
112401: LD_INT 28
112403: PUSH
112404: LD_INT 30
112406: PUSH
112407: LD_INT 31
112409: PUSH
112410: LD_INT 32
112412: PUSH
112413: LD_INT 33
112415: PUSH
112416: LD_INT 34
112418: PUSH
112419: LD_INT 36
112421: PUSH
112422: EMPTY
112423: LIST
112424: LIST
112425: LIST
112426: LIST
112427: LIST
112428: LIST
112429: LIST
112430: LIST
112431: LIST
112432: LIST
112433: LIST
112434: LIST
112435: LIST
112436: LIST
112437: LIST
112438: LIST
112439: LIST
112440: LIST
112441: LIST
112442: LIST
112443: LIST
112444: LIST
112445: LIST
112446: LIST
112447: LIST
112448: LIST
112449: LIST
112450: LIST
112451: LIST
112452: LIST
112453: LIST
112454: LIST
112455: LIST
112456: LIST
112457: PUSH
112458: LD_INT 101
112460: PUSH
112461: LD_INT 102
112463: PUSH
112464: LD_INT 103
112466: PUSH
112467: LD_INT 104
112469: PUSH
112470: LD_INT 105
112472: PUSH
112473: LD_INT 106
112475: PUSH
112476: LD_INT 107
112478: PUSH
112479: LD_INT 108
112481: PUSH
112482: LD_INT 109
112484: PUSH
112485: LD_INT 110
112487: PUSH
112488: LD_INT 111
112490: PUSH
112491: LD_INT 112
112493: PUSH
112494: LD_INT 113
112496: PUSH
112497: LD_INT 114
112499: PUSH
112500: LD_INT 116
112502: PUSH
112503: LD_INT 117
112505: PUSH
112506: LD_INT 118
112508: PUSH
112509: EMPTY
112510: LIST
112511: LIST
112512: LIST
112513: LIST
112514: LIST
112515: LIST
112516: LIST
112517: LIST
112518: LIST
112519: LIST
112520: LIST
112521: LIST
112522: LIST
112523: LIST
112524: LIST
112525: LIST
112526: LIST
112527: PUSH
112528: EMPTY
112529: LIST
112530: LIST
112531: ST_TO_ADDR
112532: GO 113987
112534: LD_INT 13
112536: DOUBLE
112537: EQUAL
112538: IFTRUE 112542
112540: GO 112750
112542: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
112543: LD_ADDR_VAR 0 2
112547: PUSH
112548: LD_INT 1
112550: PUSH
112551: LD_INT 2
112553: PUSH
112554: LD_INT 3
112556: PUSH
112557: LD_INT 4
112559: PUSH
112560: LD_INT 5
112562: PUSH
112563: LD_INT 8
112565: PUSH
112566: LD_INT 9
112568: PUSH
112569: LD_INT 10
112571: PUSH
112572: LD_INT 11
112574: PUSH
112575: LD_INT 12
112577: PUSH
112578: LD_INT 14
112580: PUSH
112581: LD_INT 15
112583: PUSH
112584: LD_INT 16
112586: PUSH
112587: LD_INT 17
112589: PUSH
112590: LD_INT 18
112592: PUSH
112593: LD_INT 19
112595: PUSH
112596: LD_INT 20
112598: PUSH
112599: LD_INT 21
112601: PUSH
112602: LD_INT 22
112604: PUSH
112605: LD_INT 23
112607: PUSH
112608: LD_INT 24
112610: PUSH
112611: LD_INT 25
112613: PUSH
112614: LD_INT 26
112616: PUSH
112617: LD_INT 27
112619: PUSH
112620: LD_INT 28
112622: PUSH
112623: LD_INT 30
112625: PUSH
112626: LD_INT 31
112628: PUSH
112629: LD_INT 32
112631: PUSH
112632: LD_INT 33
112634: PUSH
112635: LD_INT 34
112637: PUSH
112638: LD_INT 36
112640: PUSH
112641: EMPTY
112642: LIST
112643: LIST
112644: LIST
112645: LIST
112646: LIST
112647: LIST
112648: LIST
112649: LIST
112650: LIST
112651: LIST
112652: LIST
112653: LIST
112654: LIST
112655: LIST
112656: LIST
112657: LIST
112658: LIST
112659: LIST
112660: LIST
112661: LIST
112662: LIST
112663: LIST
112664: LIST
112665: LIST
112666: LIST
112667: LIST
112668: LIST
112669: LIST
112670: LIST
112671: LIST
112672: LIST
112673: PUSH
112674: LD_INT 101
112676: PUSH
112677: LD_INT 102
112679: PUSH
112680: LD_INT 103
112682: PUSH
112683: LD_INT 104
112685: PUSH
112686: LD_INT 105
112688: PUSH
112689: LD_INT 106
112691: PUSH
112692: LD_INT 107
112694: PUSH
112695: LD_INT 108
112697: PUSH
112698: LD_INT 109
112700: PUSH
112701: LD_INT 110
112703: PUSH
112704: LD_INT 111
112706: PUSH
112707: LD_INT 112
112709: PUSH
112710: LD_INT 113
112712: PUSH
112713: LD_INT 114
112715: PUSH
112716: LD_INT 116
112718: PUSH
112719: LD_INT 117
112721: PUSH
112722: LD_INT 118
112724: PUSH
112725: EMPTY
112726: LIST
112727: LIST
112728: LIST
112729: LIST
112730: LIST
112731: LIST
112732: LIST
112733: LIST
112734: LIST
112735: LIST
112736: LIST
112737: LIST
112738: LIST
112739: LIST
112740: LIST
112741: LIST
112742: LIST
112743: PUSH
112744: EMPTY
112745: LIST
112746: LIST
112747: ST_TO_ADDR
112748: GO 113987
112750: LD_INT 14
112752: DOUBLE
112753: EQUAL
112754: IFTRUE 112758
112756: GO 112982
112758: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
112759: LD_ADDR_VAR 0 2
112763: PUSH
112764: LD_INT 1
112766: PUSH
112767: LD_INT 2
112769: PUSH
112770: LD_INT 3
112772: PUSH
112773: LD_INT 4
112775: PUSH
112776: LD_INT 5
112778: PUSH
112779: LD_INT 6
112781: PUSH
112782: LD_INT 7
112784: PUSH
112785: LD_INT 8
112787: PUSH
112788: LD_INT 9
112790: PUSH
112791: LD_INT 10
112793: PUSH
112794: LD_INT 11
112796: PUSH
112797: LD_INT 12
112799: PUSH
112800: LD_INT 13
112802: PUSH
112803: LD_INT 14
112805: PUSH
112806: LD_INT 15
112808: PUSH
112809: LD_INT 16
112811: PUSH
112812: LD_INT 17
112814: PUSH
112815: LD_INT 18
112817: PUSH
112818: LD_INT 19
112820: PUSH
112821: LD_INT 20
112823: PUSH
112824: LD_INT 21
112826: PUSH
112827: LD_INT 22
112829: PUSH
112830: LD_INT 23
112832: PUSH
112833: LD_INT 24
112835: PUSH
112836: LD_INT 25
112838: PUSH
112839: LD_INT 26
112841: PUSH
112842: LD_INT 27
112844: PUSH
112845: LD_INT 28
112847: PUSH
112848: LD_INT 29
112850: PUSH
112851: LD_INT 30
112853: PUSH
112854: LD_INT 31
112856: PUSH
112857: LD_INT 32
112859: PUSH
112860: LD_INT 33
112862: PUSH
112863: LD_INT 34
112865: PUSH
112866: LD_INT 36
112868: PUSH
112869: EMPTY
112870: LIST
112871: LIST
112872: LIST
112873: LIST
112874: LIST
112875: LIST
112876: LIST
112877: LIST
112878: LIST
112879: LIST
112880: LIST
112881: LIST
112882: LIST
112883: LIST
112884: LIST
112885: LIST
112886: LIST
112887: LIST
112888: LIST
112889: LIST
112890: LIST
112891: LIST
112892: LIST
112893: LIST
112894: LIST
112895: LIST
112896: LIST
112897: LIST
112898: LIST
112899: LIST
112900: LIST
112901: LIST
112902: LIST
112903: LIST
112904: LIST
112905: PUSH
112906: LD_INT 101
112908: PUSH
112909: LD_INT 102
112911: PUSH
112912: LD_INT 103
112914: PUSH
112915: LD_INT 104
112917: PUSH
112918: LD_INT 105
112920: PUSH
112921: LD_INT 106
112923: PUSH
112924: LD_INT 107
112926: PUSH
112927: LD_INT 108
112929: PUSH
112930: LD_INT 109
112932: PUSH
112933: LD_INT 110
112935: PUSH
112936: LD_INT 111
112938: PUSH
112939: LD_INT 112
112941: PUSH
112942: LD_INT 113
112944: PUSH
112945: LD_INT 114
112947: PUSH
112948: LD_INT 116
112950: PUSH
112951: LD_INT 117
112953: PUSH
112954: LD_INT 118
112956: PUSH
112957: EMPTY
112958: LIST
112959: LIST
112960: LIST
112961: LIST
112962: LIST
112963: LIST
112964: LIST
112965: LIST
112966: LIST
112967: LIST
112968: LIST
112969: LIST
112970: LIST
112971: LIST
112972: LIST
112973: LIST
112974: LIST
112975: PUSH
112976: EMPTY
112977: LIST
112978: LIST
112979: ST_TO_ADDR
112980: GO 113987
112982: LD_INT 15
112984: DOUBLE
112985: EQUAL
112986: IFTRUE 112990
112988: GO 113214
112990: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
112991: LD_ADDR_VAR 0 2
112995: PUSH
112996: LD_INT 1
112998: PUSH
112999: LD_INT 2
113001: PUSH
113002: LD_INT 3
113004: PUSH
113005: LD_INT 4
113007: PUSH
113008: LD_INT 5
113010: PUSH
113011: LD_INT 6
113013: PUSH
113014: LD_INT 7
113016: PUSH
113017: LD_INT 8
113019: PUSH
113020: LD_INT 9
113022: PUSH
113023: LD_INT 10
113025: PUSH
113026: LD_INT 11
113028: PUSH
113029: LD_INT 12
113031: PUSH
113032: LD_INT 13
113034: PUSH
113035: LD_INT 14
113037: PUSH
113038: LD_INT 15
113040: PUSH
113041: LD_INT 16
113043: PUSH
113044: LD_INT 17
113046: PUSH
113047: LD_INT 18
113049: PUSH
113050: LD_INT 19
113052: PUSH
113053: LD_INT 20
113055: PUSH
113056: LD_INT 21
113058: PUSH
113059: LD_INT 22
113061: PUSH
113062: LD_INT 23
113064: PUSH
113065: LD_INT 24
113067: PUSH
113068: LD_INT 25
113070: PUSH
113071: LD_INT 26
113073: PUSH
113074: LD_INT 27
113076: PUSH
113077: LD_INT 28
113079: PUSH
113080: LD_INT 29
113082: PUSH
113083: LD_INT 30
113085: PUSH
113086: LD_INT 31
113088: PUSH
113089: LD_INT 32
113091: PUSH
113092: LD_INT 33
113094: PUSH
113095: LD_INT 34
113097: PUSH
113098: LD_INT 36
113100: PUSH
113101: EMPTY
113102: LIST
113103: LIST
113104: LIST
113105: LIST
113106: LIST
113107: LIST
113108: LIST
113109: LIST
113110: LIST
113111: LIST
113112: LIST
113113: LIST
113114: LIST
113115: LIST
113116: LIST
113117: LIST
113118: LIST
113119: LIST
113120: LIST
113121: LIST
113122: LIST
113123: LIST
113124: LIST
113125: LIST
113126: LIST
113127: LIST
113128: LIST
113129: LIST
113130: LIST
113131: LIST
113132: LIST
113133: LIST
113134: LIST
113135: LIST
113136: LIST
113137: PUSH
113138: LD_INT 101
113140: PUSH
113141: LD_INT 102
113143: PUSH
113144: LD_INT 103
113146: PUSH
113147: LD_INT 104
113149: PUSH
113150: LD_INT 105
113152: PUSH
113153: LD_INT 106
113155: PUSH
113156: LD_INT 107
113158: PUSH
113159: LD_INT 108
113161: PUSH
113162: LD_INT 109
113164: PUSH
113165: LD_INT 110
113167: PUSH
113168: LD_INT 111
113170: PUSH
113171: LD_INT 112
113173: PUSH
113174: LD_INT 113
113176: PUSH
113177: LD_INT 114
113179: PUSH
113180: LD_INT 116
113182: PUSH
113183: LD_INT 117
113185: PUSH
113186: LD_INT 118
113188: PUSH
113189: EMPTY
113190: LIST
113191: LIST
113192: LIST
113193: LIST
113194: LIST
113195: LIST
113196: LIST
113197: LIST
113198: LIST
113199: LIST
113200: LIST
113201: LIST
113202: LIST
113203: LIST
113204: LIST
113205: LIST
113206: LIST
113207: PUSH
113208: EMPTY
113209: LIST
113210: LIST
113211: ST_TO_ADDR
113212: GO 113987
113214: LD_INT 16
113216: DOUBLE
113217: EQUAL
113218: IFTRUE 113222
113220: GO 113358
113222: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
113223: LD_ADDR_VAR 0 2
113227: PUSH
113228: LD_INT 2
113230: PUSH
113231: LD_INT 4
113233: PUSH
113234: LD_INT 5
113236: PUSH
113237: LD_INT 7
113239: PUSH
113240: LD_INT 11
113242: PUSH
113243: LD_INT 12
113245: PUSH
113246: LD_INT 15
113248: PUSH
113249: LD_INT 16
113251: PUSH
113252: LD_INT 20
113254: PUSH
113255: LD_INT 21
113257: PUSH
113258: LD_INT 22
113260: PUSH
113261: LD_INT 23
113263: PUSH
113264: LD_INT 25
113266: PUSH
113267: LD_INT 26
113269: PUSH
113270: LD_INT 30
113272: PUSH
113273: LD_INT 31
113275: PUSH
113276: LD_INT 32
113278: PUSH
113279: LD_INT 33
113281: PUSH
113282: LD_INT 34
113284: PUSH
113285: EMPTY
113286: LIST
113287: LIST
113288: LIST
113289: LIST
113290: LIST
113291: LIST
113292: LIST
113293: LIST
113294: LIST
113295: LIST
113296: LIST
113297: LIST
113298: LIST
113299: LIST
113300: LIST
113301: LIST
113302: LIST
113303: LIST
113304: LIST
113305: PUSH
113306: LD_INT 101
113308: PUSH
113309: LD_INT 102
113311: PUSH
113312: LD_INT 103
113314: PUSH
113315: LD_INT 106
113317: PUSH
113318: LD_INT 108
113320: PUSH
113321: LD_INT 112
113323: PUSH
113324: LD_INT 113
113326: PUSH
113327: LD_INT 114
113329: PUSH
113330: LD_INT 116
113332: PUSH
113333: LD_INT 117
113335: PUSH
113336: LD_INT 118
113338: PUSH
113339: EMPTY
113340: LIST
113341: LIST
113342: LIST
113343: LIST
113344: LIST
113345: LIST
113346: LIST
113347: LIST
113348: LIST
113349: LIST
113350: LIST
113351: PUSH
113352: EMPTY
113353: LIST
113354: LIST
113355: ST_TO_ADDR
113356: GO 113987
113358: LD_INT 17
113360: DOUBLE
113361: EQUAL
113362: IFTRUE 113366
113364: GO 113590
113366: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
113367: LD_ADDR_VAR 0 2
113371: PUSH
113372: LD_INT 1
113374: PUSH
113375: LD_INT 2
113377: PUSH
113378: LD_INT 3
113380: PUSH
113381: LD_INT 4
113383: PUSH
113384: LD_INT 5
113386: PUSH
113387: LD_INT 6
113389: PUSH
113390: LD_INT 7
113392: PUSH
113393: LD_INT 8
113395: PUSH
113396: LD_INT 9
113398: PUSH
113399: LD_INT 10
113401: PUSH
113402: LD_INT 11
113404: PUSH
113405: LD_INT 12
113407: PUSH
113408: LD_INT 13
113410: PUSH
113411: LD_INT 14
113413: PUSH
113414: LD_INT 15
113416: PUSH
113417: LD_INT 16
113419: PUSH
113420: LD_INT 17
113422: PUSH
113423: LD_INT 18
113425: PUSH
113426: LD_INT 19
113428: PUSH
113429: LD_INT 20
113431: PUSH
113432: LD_INT 21
113434: PUSH
113435: LD_INT 22
113437: PUSH
113438: LD_INT 23
113440: PUSH
113441: LD_INT 24
113443: PUSH
113444: LD_INT 25
113446: PUSH
113447: LD_INT 26
113449: PUSH
113450: LD_INT 27
113452: PUSH
113453: LD_INT 28
113455: PUSH
113456: LD_INT 29
113458: PUSH
113459: LD_INT 30
113461: PUSH
113462: LD_INT 31
113464: PUSH
113465: LD_INT 32
113467: PUSH
113468: LD_INT 33
113470: PUSH
113471: LD_INT 34
113473: PUSH
113474: LD_INT 36
113476: PUSH
113477: EMPTY
113478: LIST
113479: LIST
113480: LIST
113481: LIST
113482: LIST
113483: LIST
113484: LIST
113485: LIST
113486: LIST
113487: LIST
113488: LIST
113489: LIST
113490: LIST
113491: LIST
113492: LIST
113493: LIST
113494: LIST
113495: LIST
113496: LIST
113497: LIST
113498: LIST
113499: LIST
113500: LIST
113501: LIST
113502: LIST
113503: LIST
113504: LIST
113505: LIST
113506: LIST
113507: LIST
113508: LIST
113509: LIST
113510: LIST
113511: LIST
113512: LIST
113513: PUSH
113514: LD_INT 101
113516: PUSH
113517: LD_INT 102
113519: PUSH
113520: LD_INT 103
113522: PUSH
113523: LD_INT 104
113525: PUSH
113526: LD_INT 105
113528: PUSH
113529: LD_INT 106
113531: PUSH
113532: LD_INT 107
113534: PUSH
113535: LD_INT 108
113537: PUSH
113538: LD_INT 109
113540: PUSH
113541: LD_INT 110
113543: PUSH
113544: LD_INT 111
113546: PUSH
113547: LD_INT 112
113549: PUSH
113550: LD_INT 113
113552: PUSH
113553: LD_INT 114
113555: PUSH
113556: LD_INT 116
113558: PUSH
113559: LD_INT 117
113561: PUSH
113562: LD_INT 118
113564: PUSH
113565: EMPTY
113566: LIST
113567: LIST
113568: LIST
113569: LIST
113570: LIST
113571: LIST
113572: LIST
113573: LIST
113574: LIST
113575: LIST
113576: LIST
113577: LIST
113578: LIST
113579: LIST
113580: LIST
113581: LIST
113582: LIST
113583: PUSH
113584: EMPTY
113585: LIST
113586: LIST
113587: ST_TO_ADDR
113588: GO 113987
113590: LD_INT 18
113592: DOUBLE
113593: EQUAL
113594: IFTRUE 113598
113596: GO 113746
113598: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
113599: LD_ADDR_VAR 0 2
113603: PUSH
113604: LD_INT 2
113606: PUSH
113607: LD_INT 4
113609: PUSH
113610: LD_INT 5
113612: PUSH
113613: LD_INT 7
113615: PUSH
113616: LD_INT 11
113618: PUSH
113619: LD_INT 12
113621: PUSH
113622: LD_INT 15
113624: PUSH
113625: LD_INT 16
113627: PUSH
113628: LD_INT 20
113630: PUSH
113631: LD_INT 21
113633: PUSH
113634: LD_INT 22
113636: PUSH
113637: LD_INT 23
113639: PUSH
113640: LD_INT 25
113642: PUSH
113643: LD_INT 26
113645: PUSH
113646: LD_INT 30
113648: PUSH
113649: LD_INT 31
113651: PUSH
113652: LD_INT 32
113654: PUSH
113655: LD_INT 33
113657: PUSH
113658: LD_INT 34
113660: PUSH
113661: LD_INT 35
113663: PUSH
113664: LD_INT 36
113666: PUSH
113667: EMPTY
113668: LIST
113669: LIST
113670: LIST
113671: LIST
113672: LIST
113673: LIST
113674: LIST
113675: LIST
113676: LIST
113677: LIST
113678: LIST
113679: LIST
113680: LIST
113681: LIST
113682: LIST
113683: LIST
113684: LIST
113685: LIST
113686: LIST
113687: LIST
113688: LIST
113689: PUSH
113690: LD_INT 101
113692: PUSH
113693: LD_INT 102
113695: PUSH
113696: LD_INT 103
113698: PUSH
113699: LD_INT 106
113701: PUSH
113702: LD_INT 108
113704: PUSH
113705: LD_INT 112
113707: PUSH
113708: LD_INT 113
113710: PUSH
113711: LD_INT 114
113713: PUSH
113714: LD_INT 115
113716: PUSH
113717: LD_INT 116
113719: PUSH
113720: LD_INT 117
113722: PUSH
113723: LD_INT 118
113725: PUSH
113726: EMPTY
113727: LIST
113728: LIST
113729: LIST
113730: LIST
113731: LIST
113732: LIST
113733: LIST
113734: LIST
113735: LIST
113736: LIST
113737: LIST
113738: LIST
113739: PUSH
113740: EMPTY
113741: LIST
113742: LIST
113743: ST_TO_ADDR
113744: GO 113987
113746: LD_INT 19
113748: DOUBLE
113749: EQUAL
113750: IFTRUE 113754
113752: GO 113986
113754: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
113755: LD_ADDR_VAR 0 2
113759: PUSH
113760: LD_INT 1
113762: PUSH
113763: LD_INT 2
113765: PUSH
113766: LD_INT 3
113768: PUSH
113769: LD_INT 4
113771: PUSH
113772: LD_INT 5
113774: PUSH
113775: LD_INT 6
113777: PUSH
113778: LD_INT 7
113780: PUSH
113781: LD_INT 8
113783: PUSH
113784: LD_INT 9
113786: PUSH
113787: LD_INT 10
113789: PUSH
113790: LD_INT 11
113792: PUSH
113793: LD_INT 12
113795: PUSH
113796: LD_INT 13
113798: PUSH
113799: LD_INT 14
113801: PUSH
113802: LD_INT 15
113804: PUSH
113805: LD_INT 16
113807: PUSH
113808: LD_INT 17
113810: PUSH
113811: LD_INT 18
113813: PUSH
113814: LD_INT 19
113816: PUSH
113817: LD_INT 20
113819: PUSH
113820: LD_INT 21
113822: PUSH
113823: LD_INT 22
113825: PUSH
113826: LD_INT 23
113828: PUSH
113829: LD_INT 24
113831: PUSH
113832: LD_INT 25
113834: PUSH
113835: LD_INT 26
113837: PUSH
113838: LD_INT 27
113840: PUSH
113841: LD_INT 28
113843: PUSH
113844: LD_INT 29
113846: PUSH
113847: LD_INT 30
113849: PUSH
113850: LD_INT 31
113852: PUSH
113853: LD_INT 32
113855: PUSH
113856: LD_INT 33
113858: PUSH
113859: LD_INT 34
113861: PUSH
113862: LD_INT 35
113864: PUSH
113865: LD_INT 36
113867: PUSH
113868: EMPTY
113869: LIST
113870: LIST
113871: LIST
113872: LIST
113873: LIST
113874: LIST
113875: LIST
113876: LIST
113877: LIST
113878: LIST
113879: LIST
113880: LIST
113881: LIST
113882: LIST
113883: LIST
113884: LIST
113885: LIST
113886: LIST
113887: LIST
113888: LIST
113889: LIST
113890: LIST
113891: LIST
113892: LIST
113893: LIST
113894: LIST
113895: LIST
113896: LIST
113897: LIST
113898: LIST
113899: LIST
113900: LIST
113901: LIST
113902: LIST
113903: LIST
113904: LIST
113905: PUSH
113906: LD_INT 101
113908: PUSH
113909: LD_INT 102
113911: PUSH
113912: LD_INT 103
113914: PUSH
113915: LD_INT 104
113917: PUSH
113918: LD_INT 105
113920: PUSH
113921: LD_INT 106
113923: PUSH
113924: LD_INT 107
113926: PUSH
113927: LD_INT 108
113929: PUSH
113930: LD_INT 109
113932: PUSH
113933: LD_INT 110
113935: PUSH
113936: LD_INT 111
113938: PUSH
113939: LD_INT 112
113941: PUSH
113942: LD_INT 113
113944: PUSH
113945: LD_INT 114
113947: PUSH
113948: LD_INT 115
113950: PUSH
113951: LD_INT 116
113953: PUSH
113954: LD_INT 117
113956: PUSH
113957: LD_INT 118
113959: PUSH
113960: EMPTY
113961: LIST
113962: LIST
113963: LIST
113964: LIST
113965: LIST
113966: LIST
113967: LIST
113968: LIST
113969: LIST
113970: LIST
113971: LIST
113972: LIST
113973: LIST
113974: LIST
113975: LIST
113976: LIST
113977: LIST
113978: LIST
113979: PUSH
113980: EMPTY
113981: LIST
113982: LIST
113983: ST_TO_ADDR
113984: GO 113987
113986: POP
// end else
113987: GO 114218
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
113989: LD_ADDR_VAR 0 2
113993: PUSH
113994: LD_INT 1
113996: PUSH
113997: LD_INT 2
113999: PUSH
114000: LD_INT 3
114002: PUSH
114003: LD_INT 4
114005: PUSH
114006: LD_INT 5
114008: PUSH
114009: LD_INT 6
114011: PUSH
114012: LD_INT 7
114014: PUSH
114015: LD_INT 8
114017: PUSH
114018: LD_INT 9
114020: PUSH
114021: LD_INT 10
114023: PUSH
114024: LD_INT 11
114026: PUSH
114027: LD_INT 12
114029: PUSH
114030: LD_INT 13
114032: PUSH
114033: LD_INT 14
114035: PUSH
114036: LD_INT 15
114038: PUSH
114039: LD_INT 16
114041: PUSH
114042: LD_INT 17
114044: PUSH
114045: LD_INT 18
114047: PUSH
114048: LD_INT 19
114050: PUSH
114051: LD_INT 20
114053: PUSH
114054: LD_INT 21
114056: PUSH
114057: LD_INT 22
114059: PUSH
114060: LD_INT 23
114062: PUSH
114063: LD_INT 24
114065: PUSH
114066: LD_INT 25
114068: PUSH
114069: LD_INT 26
114071: PUSH
114072: LD_INT 27
114074: PUSH
114075: LD_INT 28
114077: PUSH
114078: LD_INT 29
114080: PUSH
114081: LD_INT 30
114083: PUSH
114084: LD_INT 31
114086: PUSH
114087: LD_INT 32
114089: PUSH
114090: LD_INT 33
114092: PUSH
114093: LD_INT 34
114095: PUSH
114096: LD_INT 35
114098: PUSH
114099: LD_INT 36
114101: PUSH
114102: EMPTY
114103: LIST
114104: LIST
114105: LIST
114106: LIST
114107: LIST
114108: LIST
114109: LIST
114110: LIST
114111: LIST
114112: LIST
114113: LIST
114114: LIST
114115: LIST
114116: LIST
114117: LIST
114118: LIST
114119: LIST
114120: LIST
114121: LIST
114122: LIST
114123: LIST
114124: LIST
114125: LIST
114126: LIST
114127: LIST
114128: LIST
114129: LIST
114130: LIST
114131: LIST
114132: LIST
114133: LIST
114134: LIST
114135: LIST
114136: LIST
114137: LIST
114138: LIST
114139: PUSH
114140: LD_INT 101
114142: PUSH
114143: LD_INT 102
114145: PUSH
114146: LD_INT 103
114148: PUSH
114149: LD_INT 104
114151: PUSH
114152: LD_INT 105
114154: PUSH
114155: LD_INT 106
114157: PUSH
114158: LD_INT 107
114160: PUSH
114161: LD_INT 108
114163: PUSH
114164: LD_INT 109
114166: PUSH
114167: LD_INT 110
114169: PUSH
114170: LD_INT 111
114172: PUSH
114173: LD_INT 112
114175: PUSH
114176: LD_INT 113
114178: PUSH
114179: LD_INT 114
114181: PUSH
114182: LD_INT 115
114184: PUSH
114185: LD_INT 116
114187: PUSH
114188: LD_INT 117
114190: PUSH
114191: LD_INT 118
114193: PUSH
114194: EMPTY
114195: LIST
114196: LIST
114197: LIST
114198: LIST
114199: LIST
114200: LIST
114201: LIST
114202: LIST
114203: LIST
114204: LIST
114205: LIST
114206: LIST
114207: LIST
114208: LIST
114209: LIST
114210: LIST
114211: LIST
114212: LIST
114213: PUSH
114214: EMPTY
114215: LIST
114216: LIST
114217: ST_TO_ADDR
// if result then
114218: LD_VAR 0 2
114222: IFFALSE 115008
// begin normal :=  ;
114224: LD_ADDR_VAR 0 5
114228: PUSH
114229: LD_STRING 
114231: ST_TO_ADDR
// hardcore :=  ;
114232: LD_ADDR_VAR 0 6
114236: PUSH
114237: LD_STRING 
114239: ST_TO_ADDR
// active :=  ;
114240: LD_ADDR_VAR 0 7
114244: PUSH
114245: LD_STRING 
114247: ST_TO_ADDR
// for i = 1 to normalCounter do
114248: LD_ADDR_VAR 0 8
114252: PUSH
114253: DOUBLE
114254: LD_INT 1
114256: DEC
114257: ST_TO_ADDR
114258: LD_EXP 146
114262: PUSH
114263: FOR_TO
114264: IFFALSE 114365
// begin tmp := 0 ;
114266: LD_ADDR_VAR 0 3
114270: PUSH
114271: LD_STRING 0
114273: ST_TO_ADDR
// if result [ 1 ] then
114274: LD_VAR 0 2
114278: PUSH
114279: LD_INT 1
114281: ARRAY
114282: IFFALSE 114347
// if result [ 1 ] [ 1 ] = i then
114284: LD_VAR 0 2
114288: PUSH
114289: LD_INT 1
114291: ARRAY
114292: PUSH
114293: LD_INT 1
114295: ARRAY
114296: PUSH
114297: LD_VAR 0 8
114301: EQUAL
114302: IFFALSE 114347
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
114304: LD_ADDR_VAR 0 2
114308: PUSH
114309: LD_VAR 0 2
114313: PPUSH
114314: LD_INT 1
114316: PPUSH
114317: LD_VAR 0 2
114321: PUSH
114322: LD_INT 1
114324: ARRAY
114325: PPUSH
114326: LD_INT 1
114328: PPUSH
114329: CALL_OW 3
114333: PPUSH
114334: CALL_OW 1
114338: ST_TO_ADDR
// tmp := 1 ;
114339: LD_ADDR_VAR 0 3
114343: PUSH
114344: LD_STRING 1
114346: ST_TO_ADDR
// end ; normal := normal & tmp ;
114347: LD_ADDR_VAR 0 5
114351: PUSH
114352: LD_VAR 0 5
114356: PUSH
114357: LD_VAR 0 3
114361: STR
114362: ST_TO_ADDR
// end ;
114363: GO 114263
114365: POP
114366: POP
// for i = 1 to hardcoreCounter do
114367: LD_ADDR_VAR 0 8
114371: PUSH
114372: DOUBLE
114373: LD_INT 1
114375: DEC
114376: ST_TO_ADDR
114377: LD_EXP 147
114381: PUSH
114382: FOR_TO
114383: IFFALSE 114488
// begin tmp := 0 ;
114385: LD_ADDR_VAR 0 3
114389: PUSH
114390: LD_STRING 0
114392: ST_TO_ADDR
// if result [ 2 ] then
114393: LD_VAR 0 2
114397: PUSH
114398: LD_INT 2
114400: ARRAY
114401: IFFALSE 114470
// if result [ 2 ] [ 1 ] = 100 + i then
114403: LD_VAR 0 2
114407: PUSH
114408: LD_INT 2
114410: ARRAY
114411: PUSH
114412: LD_INT 1
114414: ARRAY
114415: PUSH
114416: LD_INT 100
114418: PUSH
114419: LD_VAR 0 8
114423: PLUS
114424: EQUAL
114425: IFFALSE 114470
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
114427: LD_ADDR_VAR 0 2
114431: PUSH
114432: LD_VAR 0 2
114436: PPUSH
114437: LD_INT 2
114439: PPUSH
114440: LD_VAR 0 2
114444: PUSH
114445: LD_INT 2
114447: ARRAY
114448: PPUSH
114449: LD_INT 1
114451: PPUSH
114452: CALL_OW 3
114456: PPUSH
114457: CALL_OW 1
114461: ST_TO_ADDR
// tmp := 1 ;
114462: LD_ADDR_VAR 0 3
114466: PUSH
114467: LD_STRING 1
114469: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
114470: LD_ADDR_VAR 0 6
114474: PUSH
114475: LD_VAR 0 6
114479: PUSH
114480: LD_VAR 0 3
114484: STR
114485: ST_TO_ADDR
// end ;
114486: GO 114382
114488: POP
114489: POP
// if isGameLoad then
114490: LD_VAR 0 1
114494: IFFALSE 114969
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
114496: LD_ADDR_VAR 0 4
114500: PUSH
114501: LD_EXP 150
114505: PUSH
114506: LD_EXP 149
114510: PUSH
114511: LD_EXP 151
114515: PUSH
114516: LD_EXP 148
114520: PUSH
114521: LD_EXP 152
114525: PUSH
114526: LD_EXP 153
114530: PUSH
114531: LD_EXP 154
114535: PUSH
114536: LD_EXP 155
114540: PUSH
114541: LD_EXP 156
114545: PUSH
114546: LD_EXP 157
114550: PUSH
114551: LD_EXP 158
114555: PUSH
114556: LD_EXP 159
114560: PUSH
114561: LD_EXP 160
114565: PUSH
114566: LD_EXP 161
114570: PUSH
114571: LD_EXP 169
114575: PUSH
114576: LD_EXP 170
114580: PUSH
114581: LD_EXP 171
114585: PUSH
114586: LD_EXP 172
114590: PUSH
114591: LD_EXP 174
114595: PUSH
114596: LD_EXP 175
114600: PUSH
114601: LD_EXP 176
114605: PUSH
114606: LD_EXP 179
114610: PUSH
114611: LD_EXP 181
114615: PUSH
114616: LD_EXP 182
114620: PUSH
114621: LD_EXP 183
114625: PUSH
114626: LD_EXP 185
114630: PUSH
114631: LD_EXP 186
114635: PUSH
114636: LD_EXP 189
114640: PUSH
114641: LD_EXP 190
114645: PUSH
114646: LD_EXP 191
114650: PUSH
114651: LD_EXP 192
114655: PUSH
114656: LD_EXP 193
114660: PUSH
114661: LD_EXP 194
114665: PUSH
114666: LD_EXP 195
114670: PUSH
114671: LD_EXP 196
114675: PUSH
114676: LD_EXP 197
114680: PUSH
114681: LD_EXP 162
114685: PUSH
114686: LD_EXP 163
114690: PUSH
114691: LD_EXP 166
114695: PUSH
114696: LD_EXP 167
114700: PUSH
114701: LD_EXP 168
114705: PUSH
114706: LD_EXP 164
114710: PUSH
114711: LD_EXP 165
114715: PUSH
114716: LD_EXP 173
114720: PUSH
114721: LD_EXP 177
114725: PUSH
114726: LD_EXP 178
114730: PUSH
114731: LD_EXP 180
114735: PUSH
114736: LD_EXP 184
114740: PUSH
114741: LD_EXP 187
114745: PUSH
114746: LD_EXP 188
114750: PUSH
114751: LD_EXP 198
114755: PUSH
114756: LD_EXP 199
114760: PUSH
114761: LD_EXP 200
114765: PUSH
114766: LD_EXP 201
114770: PUSH
114771: EMPTY
114772: LIST
114773: LIST
114774: LIST
114775: LIST
114776: LIST
114777: LIST
114778: LIST
114779: LIST
114780: LIST
114781: LIST
114782: LIST
114783: LIST
114784: LIST
114785: LIST
114786: LIST
114787: LIST
114788: LIST
114789: LIST
114790: LIST
114791: LIST
114792: LIST
114793: LIST
114794: LIST
114795: LIST
114796: LIST
114797: LIST
114798: LIST
114799: LIST
114800: LIST
114801: LIST
114802: LIST
114803: LIST
114804: LIST
114805: LIST
114806: LIST
114807: LIST
114808: LIST
114809: LIST
114810: LIST
114811: LIST
114812: LIST
114813: LIST
114814: LIST
114815: LIST
114816: LIST
114817: LIST
114818: LIST
114819: LIST
114820: LIST
114821: LIST
114822: LIST
114823: LIST
114824: LIST
114825: LIST
114826: ST_TO_ADDR
// tmp :=  ;
114827: LD_ADDR_VAR 0 3
114831: PUSH
114832: LD_STRING 
114834: ST_TO_ADDR
// for i = 1 to normalCounter do
114835: LD_ADDR_VAR 0 8
114839: PUSH
114840: DOUBLE
114841: LD_INT 1
114843: DEC
114844: ST_TO_ADDR
114845: LD_EXP 146
114849: PUSH
114850: FOR_TO
114851: IFFALSE 114887
// begin if flags [ i ] then
114853: LD_VAR 0 4
114857: PUSH
114858: LD_VAR 0 8
114862: ARRAY
114863: IFFALSE 114885
// tmp := tmp & i & ; ;
114865: LD_ADDR_VAR 0 3
114869: PUSH
114870: LD_VAR 0 3
114874: PUSH
114875: LD_VAR 0 8
114879: STR
114880: PUSH
114881: LD_STRING ;
114883: STR
114884: ST_TO_ADDR
// end ;
114885: GO 114850
114887: POP
114888: POP
// for i = 1 to hardcoreCounter do
114889: LD_ADDR_VAR 0 8
114893: PUSH
114894: DOUBLE
114895: LD_INT 1
114897: DEC
114898: ST_TO_ADDR
114899: LD_EXP 147
114903: PUSH
114904: FOR_TO
114905: IFFALSE 114951
// begin if flags [ normalCounter + i ] then
114907: LD_VAR 0 4
114911: PUSH
114912: LD_EXP 146
114916: PUSH
114917: LD_VAR 0 8
114921: PLUS
114922: ARRAY
114923: IFFALSE 114949
// tmp := tmp & ( 100 + i ) & ; ;
114925: LD_ADDR_VAR 0 3
114929: PUSH
114930: LD_VAR 0 3
114934: PUSH
114935: LD_INT 100
114937: PUSH
114938: LD_VAR 0 8
114942: PLUS
114943: STR
114944: PUSH
114945: LD_STRING ;
114947: STR
114948: ST_TO_ADDR
// end ;
114949: GO 114904
114951: POP
114952: POP
// if tmp then
114953: LD_VAR 0 3
114957: IFFALSE 114969
// active := tmp ;
114959: LD_ADDR_VAR 0 7
114963: PUSH
114964: LD_VAR 0 3
114968: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
114969: LD_STRING getStreamItemsFromMission("
114971: PUSH
114972: LD_VAR 0 5
114976: STR
114977: PUSH
114978: LD_STRING ","
114980: STR
114981: PUSH
114982: LD_VAR 0 6
114986: STR
114987: PUSH
114988: LD_STRING ","
114990: STR
114991: PUSH
114992: LD_VAR 0 7
114996: STR
114997: PUSH
114998: LD_STRING ")
115000: STR
115001: PPUSH
115002: CALL_OW 559
// end else
115006: GO 115015
// ToLua ( getStreamItemsFromMission("","","") ) ;
115008: LD_STRING getStreamItemsFromMission("","","")
115010: PPUSH
115011: CALL_OW 559
// end ;
115015: LD_VAR 0 2
115019: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
115020: LD_EXP 145
115024: PUSH
115025: LD_EXP 150
115029: AND
115030: IFFALSE 115154
115032: GO 115034
115034: DISABLE
115035: LD_INT 0
115037: PPUSH
115038: PPUSH
// begin enable ;
115039: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
115040: LD_ADDR_VAR 0 2
115044: PUSH
115045: LD_INT 22
115047: PUSH
115048: LD_OWVAR 2
115052: PUSH
115053: EMPTY
115054: LIST
115055: LIST
115056: PUSH
115057: LD_INT 2
115059: PUSH
115060: LD_INT 34
115062: PUSH
115063: LD_INT 7
115065: PUSH
115066: EMPTY
115067: LIST
115068: LIST
115069: PUSH
115070: LD_INT 34
115072: PUSH
115073: LD_INT 45
115075: PUSH
115076: EMPTY
115077: LIST
115078: LIST
115079: PUSH
115080: LD_INT 34
115082: PUSH
115083: LD_INT 28
115085: PUSH
115086: EMPTY
115087: LIST
115088: LIST
115089: PUSH
115090: LD_INT 34
115092: PUSH
115093: LD_INT 47
115095: PUSH
115096: EMPTY
115097: LIST
115098: LIST
115099: PUSH
115100: EMPTY
115101: LIST
115102: LIST
115103: LIST
115104: LIST
115105: LIST
115106: PUSH
115107: EMPTY
115108: LIST
115109: LIST
115110: PPUSH
115111: CALL_OW 69
115115: ST_TO_ADDR
// if not tmp then
115116: LD_VAR 0 2
115120: NOT
115121: IFFALSE 115125
// exit ;
115123: GO 115154
// for i in tmp do
115125: LD_ADDR_VAR 0 1
115129: PUSH
115130: LD_VAR 0 2
115134: PUSH
115135: FOR_IN
115136: IFFALSE 115152
// begin SetLives ( i , 0 ) ;
115138: LD_VAR 0 1
115142: PPUSH
115143: LD_INT 0
115145: PPUSH
115146: CALL_OW 234
// end ;
115150: GO 115135
115152: POP
115153: POP
// end ;
115154: PPOPN 2
115156: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
115157: LD_EXP 145
115161: PUSH
115162: LD_EXP 151
115166: AND
115167: IFFALSE 115251
115169: GO 115171
115171: DISABLE
115172: LD_INT 0
115174: PPUSH
115175: PPUSH
// begin enable ;
115176: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
115177: LD_ADDR_VAR 0 2
115181: PUSH
115182: LD_INT 22
115184: PUSH
115185: LD_OWVAR 2
115189: PUSH
115190: EMPTY
115191: LIST
115192: LIST
115193: PUSH
115194: LD_INT 32
115196: PUSH
115197: LD_INT 3
115199: PUSH
115200: EMPTY
115201: LIST
115202: LIST
115203: PUSH
115204: EMPTY
115205: LIST
115206: LIST
115207: PPUSH
115208: CALL_OW 69
115212: ST_TO_ADDR
// if not tmp then
115213: LD_VAR 0 2
115217: NOT
115218: IFFALSE 115222
// exit ;
115220: GO 115251
// for i in tmp do
115222: LD_ADDR_VAR 0 1
115226: PUSH
115227: LD_VAR 0 2
115231: PUSH
115232: FOR_IN
115233: IFFALSE 115249
// begin SetLives ( i , 0 ) ;
115235: LD_VAR 0 1
115239: PPUSH
115240: LD_INT 0
115242: PPUSH
115243: CALL_OW 234
// end ;
115247: GO 115232
115249: POP
115250: POP
// end ;
115251: PPOPN 2
115253: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
115254: LD_EXP 145
115258: PUSH
115259: LD_EXP 148
115263: AND
115264: IFFALSE 115357
115266: GO 115268
115268: DISABLE
115269: LD_INT 0
115271: PPUSH
// begin enable ;
115272: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
115273: LD_ADDR_VAR 0 1
115277: PUSH
115278: LD_INT 22
115280: PUSH
115281: LD_OWVAR 2
115285: PUSH
115286: EMPTY
115287: LIST
115288: LIST
115289: PUSH
115290: LD_INT 2
115292: PUSH
115293: LD_INT 25
115295: PUSH
115296: LD_INT 5
115298: PUSH
115299: EMPTY
115300: LIST
115301: LIST
115302: PUSH
115303: LD_INT 25
115305: PUSH
115306: LD_INT 9
115308: PUSH
115309: EMPTY
115310: LIST
115311: LIST
115312: PUSH
115313: LD_INT 25
115315: PUSH
115316: LD_INT 8
115318: PUSH
115319: EMPTY
115320: LIST
115321: LIST
115322: PUSH
115323: EMPTY
115324: LIST
115325: LIST
115326: LIST
115327: LIST
115328: PUSH
115329: EMPTY
115330: LIST
115331: LIST
115332: PPUSH
115333: CALL_OW 69
115337: PUSH
115338: FOR_IN
115339: IFFALSE 115355
// begin SetClass ( i , 1 ) ;
115341: LD_VAR 0 1
115345: PPUSH
115346: LD_INT 1
115348: PPUSH
115349: CALL_OW 336
// end ;
115353: GO 115338
115355: POP
115356: POP
// end ;
115357: PPOPN 1
115359: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
115360: LD_EXP 145
115364: PUSH
115365: LD_EXP 149
115369: AND
115370: PUSH
115371: LD_OWVAR 65
115375: PUSH
115376: LD_INT 7
115378: LESS
115379: AND
115380: IFFALSE 115394
115382: GO 115384
115384: DISABLE
// begin enable ;
115385: ENABLE
// game_speed := 7 ;
115386: LD_ADDR_OWVAR 65
115390: PUSH
115391: LD_INT 7
115393: ST_TO_ADDR
// end ;
115394: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
115395: LD_EXP 145
115399: PUSH
115400: LD_EXP 152
115404: AND
115405: IFFALSE 115607
115407: GO 115409
115409: DISABLE
115410: LD_INT 0
115412: PPUSH
115413: PPUSH
115414: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
115415: LD_ADDR_VAR 0 3
115419: PUSH
115420: LD_INT 81
115422: PUSH
115423: LD_OWVAR 2
115427: PUSH
115428: EMPTY
115429: LIST
115430: LIST
115431: PUSH
115432: LD_INT 21
115434: PUSH
115435: LD_INT 1
115437: PUSH
115438: EMPTY
115439: LIST
115440: LIST
115441: PUSH
115442: EMPTY
115443: LIST
115444: LIST
115445: PPUSH
115446: CALL_OW 69
115450: ST_TO_ADDR
// if not tmp then
115451: LD_VAR 0 3
115455: NOT
115456: IFFALSE 115460
// exit ;
115458: GO 115607
// if tmp > 5 then
115460: LD_VAR 0 3
115464: PUSH
115465: LD_INT 5
115467: GREATER
115468: IFFALSE 115480
// k := 5 else
115470: LD_ADDR_VAR 0 2
115474: PUSH
115475: LD_INT 5
115477: ST_TO_ADDR
115478: GO 115490
// k := tmp ;
115480: LD_ADDR_VAR 0 2
115484: PUSH
115485: LD_VAR 0 3
115489: ST_TO_ADDR
// for i := 1 to k do
115490: LD_ADDR_VAR 0 1
115494: PUSH
115495: DOUBLE
115496: LD_INT 1
115498: DEC
115499: ST_TO_ADDR
115500: LD_VAR 0 2
115504: PUSH
115505: FOR_TO
115506: IFFALSE 115605
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
115508: LD_VAR 0 3
115512: PUSH
115513: LD_VAR 0 1
115517: ARRAY
115518: PPUSH
115519: LD_VAR 0 1
115523: PUSH
115524: LD_INT 4
115526: MOD
115527: PUSH
115528: LD_INT 1
115530: PLUS
115531: PPUSH
115532: CALL_OW 259
115536: PUSH
115537: LD_INT 10
115539: LESS
115540: IFFALSE 115603
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
115542: LD_VAR 0 3
115546: PUSH
115547: LD_VAR 0 1
115551: ARRAY
115552: PPUSH
115553: LD_VAR 0 1
115557: PUSH
115558: LD_INT 4
115560: MOD
115561: PUSH
115562: LD_INT 1
115564: PLUS
115565: PPUSH
115566: LD_VAR 0 3
115570: PUSH
115571: LD_VAR 0 1
115575: ARRAY
115576: PPUSH
115577: LD_VAR 0 1
115581: PUSH
115582: LD_INT 4
115584: MOD
115585: PUSH
115586: LD_INT 1
115588: PLUS
115589: PPUSH
115590: CALL_OW 259
115594: PUSH
115595: LD_INT 1
115597: PLUS
115598: PPUSH
115599: CALL_OW 237
115603: GO 115505
115605: POP
115606: POP
// end ;
115607: PPOPN 3
115609: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
115610: LD_EXP 145
115614: PUSH
115615: LD_EXP 153
115619: AND
115620: IFFALSE 115640
115622: GO 115624
115624: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
115625: LD_INT 4
115627: PPUSH
115628: LD_OWVAR 2
115632: PPUSH
115633: LD_INT 0
115635: PPUSH
115636: CALL_OW 324
115640: END
// every 0 0$1 trigger StreamModeActive and sShovel do
115641: LD_EXP 145
115645: PUSH
115646: LD_EXP 182
115650: AND
115651: IFFALSE 115671
115653: GO 115655
115655: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
115656: LD_INT 19
115658: PPUSH
115659: LD_OWVAR 2
115663: PPUSH
115664: LD_INT 0
115666: PPUSH
115667: CALL_OW 324
115671: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
115672: LD_EXP 145
115676: PUSH
115677: LD_EXP 154
115681: AND
115682: IFFALSE 115784
115684: GO 115686
115686: DISABLE
115687: LD_INT 0
115689: PPUSH
115690: PPUSH
// begin enable ;
115691: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
115692: LD_ADDR_VAR 0 2
115696: PUSH
115697: LD_INT 22
115699: PUSH
115700: LD_OWVAR 2
115704: PUSH
115705: EMPTY
115706: LIST
115707: LIST
115708: PUSH
115709: LD_INT 2
115711: PUSH
115712: LD_INT 34
115714: PUSH
115715: LD_INT 11
115717: PUSH
115718: EMPTY
115719: LIST
115720: LIST
115721: PUSH
115722: LD_INT 34
115724: PUSH
115725: LD_INT 30
115727: PUSH
115728: EMPTY
115729: LIST
115730: LIST
115731: PUSH
115732: EMPTY
115733: LIST
115734: LIST
115735: LIST
115736: PUSH
115737: EMPTY
115738: LIST
115739: LIST
115740: PPUSH
115741: CALL_OW 69
115745: ST_TO_ADDR
// if not tmp then
115746: LD_VAR 0 2
115750: NOT
115751: IFFALSE 115755
// exit ;
115753: GO 115784
// for i in tmp do
115755: LD_ADDR_VAR 0 1
115759: PUSH
115760: LD_VAR 0 2
115764: PUSH
115765: FOR_IN
115766: IFFALSE 115782
// begin SetLives ( i , 0 ) ;
115768: LD_VAR 0 1
115772: PPUSH
115773: LD_INT 0
115775: PPUSH
115776: CALL_OW 234
// end ;
115780: GO 115765
115782: POP
115783: POP
// end ;
115784: PPOPN 2
115786: END
// every 0 0$1 trigger StreamModeActive and sBunker do
115787: LD_EXP 145
115791: PUSH
115792: LD_EXP 155
115796: AND
115797: IFFALSE 115817
115799: GO 115801
115801: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
115802: LD_INT 32
115804: PPUSH
115805: LD_OWVAR 2
115809: PPUSH
115810: LD_INT 0
115812: PPUSH
115813: CALL_OW 324
115817: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
115818: LD_EXP 145
115822: PUSH
115823: LD_EXP 156
115827: AND
115828: IFFALSE 116009
115830: GO 115832
115832: DISABLE
115833: LD_INT 0
115835: PPUSH
115836: PPUSH
115837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
115838: LD_ADDR_VAR 0 2
115842: PUSH
115843: LD_INT 22
115845: PUSH
115846: LD_OWVAR 2
115850: PUSH
115851: EMPTY
115852: LIST
115853: LIST
115854: PUSH
115855: LD_INT 33
115857: PUSH
115858: LD_INT 3
115860: PUSH
115861: EMPTY
115862: LIST
115863: LIST
115864: PUSH
115865: EMPTY
115866: LIST
115867: LIST
115868: PPUSH
115869: CALL_OW 69
115873: ST_TO_ADDR
// if not tmp then
115874: LD_VAR 0 2
115878: NOT
115879: IFFALSE 115883
// exit ;
115881: GO 116009
// side := 0 ;
115883: LD_ADDR_VAR 0 3
115887: PUSH
115888: LD_INT 0
115890: ST_TO_ADDR
// for i := 1 to 8 do
115891: LD_ADDR_VAR 0 1
115895: PUSH
115896: DOUBLE
115897: LD_INT 1
115899: DEC
115900: ST_TO_ADDR
115901: LD_INT 8
115903: PUSH
115904: FOR_TO
115905: IFFALSE 115953
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
115907: LD_OWVAR 2
115911: PUSH
115912: LD_VAR 0 1
115916: NONEQUAL
115917: PUSH
115918: LD_OWVAR 2
115922: PPUSH
115923: LD_VAR 0 1
115927: PPUSH
115928: CALL_OW 81
115932: PUSH
115933: LD_INT 2
115935: EQUAL
115936: AND
115937: IFFALSE 115951
// begin side := i ;
115939: LD_ADDR_VAR 0 3
115943: PUSH
115944: LD_VAR 0 1
115948: ST_TO_ADDR
// break ;
115949: GO 115953
// end ;
115951: GO 115904
115953: POP
115954: POP
// if not side then
115955: LD_VAR 0 3
115959: NOT
115960: IFFALSE 115964
// exit ;
115962: GO 116009
// for i := 1 to tmp do
115964: LD_ADDR_VAR 0 1
115968: PUSH
115969: DOUBLE
115970: LD_INT 1
115972: DEC
115973: ST_TO_ADDR
115974: LD_VAR 0 2
115978: PUSH
115979: FOR_TO
115980: IFFALSE 116007
// if Prob ( 60 ) then
115982: LD_INT 60
115984: PPUSH
115985: CALL_OW 13
115989: IFFALSE 116005
// SetSide ( i , side ) ;
115991: LD_VAR 0 1
115995: PPUSH
115996: LD_VAR 0 3
116000: PPUSH
116001: CALL_OW 235
116005: GO 115979
116007: POP
116008: POP
// end ;
116009: PPOPN 3
116011: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
116012: LD_EXP 145
116016: PUSH
116017: LD_EXP 158
116021: AND
116022: IFFALSE 116141
116024: GO 116026
116026: DISABLE
116027: LD_INT 0
116029: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
116030: LD_ADDR_VAR 0 1
116034: PUSH
116035: LD_INT 22
116037: PUSH
116038: LD_OWVAR 2
116042: PUSH
116043: EMPTY
116044: LIST
116045: LIST
116046: PUSH
116047: LD_INT 21
116049: PUSH
116050: LD_INT 1
116052: PUSH
116053: EMPTY
116054: LIST
116055: LIST
116056: PUSH
116057: LD_INT 3
116059: PUSH
116060: LD_INT 23
116062: PUSH
116063: LD_INT 0
116065: PUSH
116066: EMPTY
116067: LIST
116068: LIST
116069: PUSH
116070: EMPTY
116071: LIST
116072: LIST
116073: PUSH
116074: EMPTY
116075: LIST
116076: LIST
116077: LIST
116078: PPUSH
116079: CALL_OW 69
116083: PUSH
116084: FOR_IN
116085: IFFALSE 116139
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
116087: LD_VAR 0 1
116091: PPUSH
116092: CALL_OW 257
116096: PUSH
116097: LD_INT 1
116099: PUSH
116100: LD_INT 2
116102: PUSH
116103: LD_INT 3
116105: PUSH
116106: LD_INT 4
116108: PUSH
116109: EMPTY
116110: LIST
116111: LIST
116112: LIST
116113: LIST
116114: IN
116115: IFFALSE 116137
// SetClass ( un , rand ( 1 , 4 ) ) ;
116117: LD_VAR 0 1
116121: PPUSH
116122: LD_INT 1
116124: PPUSH
116125: LD_INT 4
116127: PPUSH
116128: CALL_OW 12
116132: PPUSH
116133: CALL_OW 336
116137: GO 116084
116139: POP
116140: POP
// end ;
116141: PPOPN 1
116143: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
116144: LD_EXP 145
116148: PUSH
116149: LD_EXP 157
116153: AND
116154: IFFALSE 116233
116156: GO 116158
116158: DISABLE
116159: LD_INT 0
116161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
116162: LD_ADDR_VAR 0 1
116166: PUSH
116167: LD_INT 22
116169: PUSH
116170: LD_OWVAR 2
116174: PUSH
116175: EMPTY
116176: LIST
116177: LIST
116178: PUSH
116179: LD_INT 21
116181: PUSH
116182: LD_INT 3
116184: PUSH
116185: EMPTY
116186: LIST
116187: LIST
116188: PUSH
116189: EMPTY
116190: LIST
116191: LIST
116192: PPUSH
116193: CALL_OW 69
116197: ST_TO_ADDR
// if not tmp then
116198: LD_VAR 0 1
116202: NOT
116203: IFFALSE 116207
// exit ;
116205: GO 116233
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
116207: LD_VAR 0 1
116211: PUSH
116212: LD_INT 1
116214: PPUSH
116215: LD_VAR 0 1
116219: PPUSH
116220: CALL_OW 12
116224: ARRAY
116225: PPUSH
116226: LD_INT 100
116228: PPUSH
116229: CALL_OW 234
// end ;
116233: PPOPN 1
116235: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
116236: LD_EXP 145
116240: PUSH
116241: LD_EXP 159
116245: AND
116246: IFFALSE 116344
116248: GO 116250
116250: DISABLE
116251: LD_INT 0
116253: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116254: LD_ADDR_VAR 0 1
116258: PUSH
116259: LD_INT 22
116261: PUSH
116262: LD_OWVAR 2
116266: PUSH
116267: EMPTY
116268: LIST
116269: LIST
116270: PUSH
116271: LD_INT 21
116273: PUSH
116274: LD_INT 1
116276: PUSH
116277: EMPTY
116278: LIST
116279: LIST
116280: PUSH
116281: EMPTY
116282: LIST
116283: LIST
116284: PPUSH
116285: CALL_OW 69
116289: ST_TO_ADDR
// if not tmp then
116290: LD_VAR 0 1
116294: NOT
116295: IFFALSE 116299
// exit ;
116297: GO 116344
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
116299: LD_VAR 0 1
116303: PUSH
116304: LD_INT 1
116306: PPUSH
116307: LD_VAR 0 1
116311: PPUSH
116312: CALL_OW 12
116316: ARRAY
116317: PPUSH
116318: LD_INT 1
116320: PPUSH
116321: LD_INT 4
116323: PPUSH
116324: CALL_OW 12
116328: PPUSH
116329: LD_INT 3000
116331: PPUSH
116332: LD_INT 9000
116334: PPUSH
116335: CALL_OW 12
116339: PPUSH
116340: CALL_OW 492
// end ;
116344: PPOPN 1
116346: END
// every 0 0$1 trigger StreamModeActive and sDepot do
116347: LD_EXP 145
116351: PUSH
116352: LD_EXP 160
116356: AND
116357: IFFALSE 116377
116359: GO 116361
116361: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
116362: LD_INT 1
116364: PPUSH
116365: LD_OWVAR 2
116369: PPUSH
116370: LD_INT 0
116372: PPUSH
116373: CALL_OW 324
116377: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
116378: LD_EXP 145
116382: PUSH
116383: LD_EXP 161
116387: AND
116388: IFFALSE 116471
116390: GO 116392
116392: DISABLE
116393: LD_INT 0
116395: PPUSH
116396: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
116397: LD_ADDR_VAR 0 2
116401: PUSH
116402: LD_INT 22
116404: PUSH
116405: LD_OWVAR 2
116409: PUSH
116410: EMPTY
116411: LIST
116412: LIST
116413: PUSH
116414: LD_INT 21
116416: PUSH
116417: LD_INT 3
116419: PUSH
116420: EMPTY
116421: LIST
116422: LIST
116423: PUSH
116424: EMPTY
116425: LIST
116426: LIST
116427: PPUSH
116428: CALL_OW 69
116432: ST_TO_ADDR
// if not tmp then
116433: LD_VAR 0 2
116437: NOT
116438: IFFALSE 116442
// exit ;
116440: GO 116471
// for i in tmp do
116442: LD_ADDR_VAR 0 1
116446: PUSH
116447: LD_VAR 0 2
116451: PUSH
116452: FOR_IN
116453: IFFALSE 116469
// SetBLevel ( i , 10 ) ;
116455: LD_VAR 0 1
116459: PPUSH
116460: LD_INT 10
116462: PPUSH
116463: CALL_OW 241
116467: GO 116452
116469: POP
116470: POP
// end ;
116471: PPOPN 2
116473: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
116474: LD_EXP 145
116478: PUSH
116479: LD_EXP 162
116483: AND
116484: IFFALSE 116595
116486: GO 116488
116488: DISABLE
116489: LD_INT 0
116491: PPUSH
116492: PPUSH
116493: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116494: LD_ADDR_VAR 0 3
116498: PUSH
116499: LD_INT 22
116501: PUSH
116502: LD_OWVAR 2
116506: PUSH
116507: EMPTY
116508: LIST
116509: LIST
116510: PUSH
116511: LD_INT 25
116513: PUSH
116514: LD_INT 1
116516: PUSH
116517: EMPTY
116518: LIST
116519: LIST
116520: PUSH
116521: EMPTY
116522: LIST
116523: LIST
116524: PPUSH
116525: CALL_OW 69
116529: ST_TO_ADDR
// if not tmp then
116530: LD_VAR 0 3
116534: NOT
116535: IFFALSE 116539
// exit ;
116537: GO 116595
// un := tmp [ rand ( 1 , tmp ) ] ;
116539: LD_ADDR_VAR 0 2
116543: PUSH
116544: LD_VAR 0 3
116548: PUSH
116549: LD_INT 1
116551: PPUSH
116552: LD_VAR 0 3
116556: PPUSH
116557: CALL_OW 12
116561: ARRAY
116562: ST_TO_ADDR
// if Crawls ( un ) then
116563: LD_VAR 0 2
116567: PPUSH
116568: CALL_OW 318
116572: IFFALSE 116583
// ComWalk ( un ) ;
116574: LD_VAR 0 2
116578: PPUSH
116579: CALL_OW 138
// SetClass ( un , class_sniper ) ;
116583: LD_VAR 0 2
116587: PPUSH
116588: LD_INT 5
116590: PPUSH
116591: CALL_OW 336
// end ;
116595: PPOPN 3
116597: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
116598: LD_EXP 145
116602: PUSH
116603: LD_EXP 163
116607: AND
116608: PUSH
116609: LD_OWVAR 67
116613: PUSH
116614: LD_INT 4
116616: LESS
116617: AND
116618: IFFALSE 116637
116620: GO 116622
116622: DISABLE
// begin Difficulty := Difficulty + 1 ;
116623: LD_ADDR_OWVAR 67
116627: PUSH
116628: LD_OWVAR 67
116632: PUSH
116633: LD_INT 1
116635: PLUS
116636: ST_TO_ADDR
// end ;
116637: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
116638: LD_EXP 145
116642: PUSH
116643: LD_EXP 164
116647: AND
116648: IFFALSE 116751
116650: GO 116652
116652: DISABLE
116653: LD_INT 0
116655: PPUSH
// begin for i := 1 to 5 do
116656: LD_ADDR_VAR 0 1
116660: PUSH
116661: DOUBLE
116662: LD_INT 1
116664: DEC
116665: ST_TO_ADDR
116666: LD_INT 5
116668: PUSH
116669: FOR_TO
116670: IFFALSE 116749
// begin uc_nation := nation_nature ;
116672: LD_ADDR_OWVAR 21
116676: PUSH
116677: LD_INT 0
116679: ST_TO_ADDR
// uc_side := 0 ;
116680: LD_ADDR_OWVAR 20
116684: PUSH
116685: LD_INT 0
116687: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116688: LD_ADDR_OWVAR 29
116692: PUSH
116693: LD_INT 12
116695: PUSH
116696: LD_INT 12
116698: PUSH
116699: EMPTY
116700: LIST
116701: LIST
116702: ST_TO_ADDR
// hc_agressivity := 20 ;
116703: LD_ADDR_OWVAR 35
116707: PUSH
116708: LD_INT 20
116710: ST_TO_ADDR
// hc_class := class_tiger ;
116711: LD_ADDR_OWVAR 28
116715: PUSH
116716: LD_INT 14
116718: ST_TO_ADDR
// hc_gallery :=  ;
116719: LD_ADDR_OWVAR 33
116723: PUSH
116724: LD_STRING 
116726: ST_TO_ADDR
// hc_name :=  ;
116727: LD_ADDR_OWVAR 26
116731: PUSH
116732: LD_STRING 
116734: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
116735: CALL_OW 44
116739: PPUSH
116740: LD_INT 0
116742: PPUSH
116743: CALL_OW 51
// end ;
116747: GO 116669
116749: POP
116750: POP
// end ;
116751: PPOPN 1
116753: END
// every 0 0$1 trigger StreamModeActive and sBomb do
116754: LD_EXP 145
116758: PUSH
116759: LD_EXP 165
116763: AND
116764: IFFALSE 116773
116766: GO 116768
116768: DISABLE
// StreamSibBomb ;
116769: CALL 116774 0 0
116773: END
// export function StreamSibBomb ; var i , x , y ; begin
116774: LD_INT 0
116776: PPUSH
116777: PPUSH
116778: PPUSH
116779: PPUSH
// result := false ;
116780: LD_ADDR_VAR 0 1
116784: PUSH
116785: LD_INT 0
116787: ST_TO_ADDR
// for i := 1 to 16 do
116788: LD_ADDR_VAR 0 2
116792: PUSH
116793: DOUBLE
116794: LD_INT 1
116796: DEC
116797: ST_TO_ADDR
116798: LD_INT 16
116800: PUSH
116801: FOR_TO
116802: IFFALSE 117001
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116804: LD_ADDR_VAR 0 3
116808: PUSH
116809: LD_INT 10
116811: PUSH
116812: LD_INT 20
116814: PUSH
116815: LD_INT 30
116817: PUSH
116818: LD_INT 40
116820: PUSH
116821: LD_INT 50
116823: PUSH
116824: LD_INT 60
116826: PUSH
116827: LD_INT 70
116829: PUSH
116830: LD_INT 80
116832: PUSH
116833: LD_INT 90
116835: PUSH
116836: LD_INT 100
116838: PUSH
116839: LD_INT 110
116841: PUSH
116842: LD_INT 120
116844: PUSH
116845: LD_INT 130
116847: PUSH
116848: LD_INT 140
116850: PUSH
116851: LD_INT 150
116853: PUSH
116854: EMPTY
116855: LIST
116856: LIST
116857: LIST
116858: LIST
116859: LIST
116860: LIST
116861: LIST
116862: LIST
116863: LIST
116864: LIST
116865: LIST
116866: LIST
116867: LIST
116868: LIST
116869: LIST
116870: PUSH
116871: LD_INT 1
116873: PPUSH
116874: LD_INT 15
116876: PPUSH
116877: CALL_OW 12
116881: ARRAY
116882: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116883: LD_ADDR_VAR 0 4
116887: PUSH
116888: LD_INT 10
116890: PUSH
116891: LD_INT 20
116893: PUSH
116894: LD_INT 30
116896: PUSH
116897: LD_INT 40
116899: PUSH
116900: LD_INT 50
116902: PUSH
116903: LD_INT 60
116905: PUSH
116906: LD_INT 70
116908: PUSH
116909: LD_INT 80
116911: PUSH
116912: LD_INT 90
116914: PUSH
116915: LD_INT 100
116917: PUSH
116918: LD_INT 110
116920: PUSH
116921: LD_INT 120
116923: PUSH
116924: LD_INT 130
116926: PUSH
116927: LD_INT 140
116929: PUSH
116930: LD_INT 150
116932: PUSH
116933: EMPTY
116934: LIST
116935: LIST
116936: LIST
116937: LIST
116938: LIST
116939: LIST
116940: LIST
116941: LIST
116942: LIST
116943: LIST
116944: LIST
116945: LIST
116946: LIST
116947: LIST
116948: LIST
116949: PUSH
116950: LD_INT 1
116952: PPUSH
116953: LD_INT 15
116955: PPUSH
116956: CALL_OW 12
116960: ARRAY
116961: ST_TO_ADDR
// if ValidHex ( x , y ) then
116962: LD_VAR 0 3
116966: PPUSH
116967: LD_VAR 0 4
116971: PPUSH
116972: CALL_OW 488
116976: IFFALSE 116999
// begin result := [ x , y ] ;
116978: LD_ADDR_VAR 0 1
116982: PUSH
116983: LD_VAR 0 3
116987: PUSH
116988: LD_VAR 0 4
116992: PUSH
116993: EMPTY
116994: LIST
116995: LIST
116996: ST_TO_ADDR
// break ;
116997: GO 117001
// end ; end ;
116999: GO 116801
117001: POP
117002: POP
// if result then
117003: LD_VAR 0 1
117007: IFFALSE 117067
// begin ToLua ( playSibBomb() ) ;
117009: LD_STRING playSibBomb()
117011: PPUSH
117012: CALL_OW 559
// wait ( 0 0$14 ) ;
117016: LD_INT 490
117018: PPUSH
117019: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
117023: LD_VAR 0 1
117027: PUSH
117028: LD_INT 1
117030: ARRAY
117031: PPUSH
117032: LD_VAR 0 1
117036: PUSH
117037: LD_INT 2
117039: ARRAY
117040: PPUSH
117041: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
117045: LD_VAR 0 1
117049: PUSH
117050: LD_INT 1
117052: ARRAY
117053: PPUSH
117054: LD_VAR 0 1
117058: PUSH
117059: LD_INT 2
117061: ARRAY
117062: PPUSH
117063: CALL_OW 429
// end ; end ;
117067: LD_VAR 0 1
117071: RET
// every 0 0$1 trigger StreamModeActive and sReset do
117072: LD_EXP 145
117076: PUSH
117077: LD_EXP 167
117081: AND
117082: IFFALSE 117094
117084: GO 117086
117086: DISABLE
// YouLost (  ) ;
117087: LD_STRING 
117089: PPUSH
117090: CALL_OW 104
117094: END
// every 0 0$1 trigger StreamModeActive and sFog do
117095: LD_EXP 145
117099: PUSH
117100: LD_EXP 166
117104: AND
117105: IFFALSE 117119
117107: GO 117109
117109: DISABLE
// FogOff ( your_side ) ;
117110: LD_OWVAR 2
117114: PPUSH
117115: CALL_OW 344
117119: END
// every 0 0$1 trigger StreamModeActive and sSun do
117120: LD_EXP 145
117124: PUSH
117125: LD_EXP 168
117129: AND
117130: IFFALSE 117158
117132: GO 117134
117134: DISABLE
// begin solar_recharge_percent := 0 ;
117135: LD_ADDR_OWVAR 79
117139: PUSH
117140: LD_INT 0
117142: ST_TO_ADDR
// wait ( 5 5$00 ) ;
117143: LD_INT 10500
117145: PPUSH
117146: CALL_OW 67
// solar_recharge_percent := 100 ;
117150: LD_ADDR_OWVAR 79
117154: PUSH
117155: LD_INT 100
117157: ST_TO_ADDR
// end ;
117158: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
117159: LD_EXP 145
117163: PUSH
117164: LD_EXP 169
117168: AND
117169: IFFALSE 117408
117171: GO 117173
117173: DISABLE
117174: LD_INT 0
117176: PPUSH
117177: PPUSH
117178: PPUSH
// begin tmp := [ ] ;
117179: LD_ADDR_VAR 0 3
117183: PUSH
117184: EMPTY
117185: ST_TO_ADDR
// for i := 1 to 6 do
117186: LD_ADDR_VAR 0 1
117190: PUSH
117191: DOUBLE
117192: LD_INT 1
117194: DEC
117195: ST_TO_ADDR
117196: LD_INT 6
117198: PUSH
117199: FOR_TO
117200: IFFALSE 117305
// begin uc_nation := nation_nature ;
117202: LD_ADDR_OWVAR 21
117206: PUSH
117207: LD_INT 0
117209: ST_TO_ADDR
// uc_side := 0 ;
117210: LD_ADDR_OWVAR 20
117214: PUSH
117215: LD_INT 0
117217: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
117218: LD_ADDR_OWVAR 29
117222: PUSH
117223: LD_INT 12
117225: PUSH
117226: LD_INT 12
117228: PUSH
117229: EMPTY
117230: LIST
117231: LIST
117232: ST_TO_ADDR
// hc_agressivity := 20 ;
117233: LD_ADDR_OWVAR 35
117237: PUSH
117238: LD_INT 20
117240: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
117241: LD_ADDR_OWVAR 28
117245: PUSH
117246: LD_INT 17
117248: ST_TO_ADDR
// hc_gallery :=  ;
117249: LD_ADDR_OWVAR 33
117253: PUSH
117254: LD_STRING 
117256: ST_TO_ADDR
// hc_name :=  ;
117257: LD_ADDR_OWVAR 26
117261: PUSH
117262: LD_STRING 
117264: ST_TO_ADDR
// un := CreateHuman ;
117265: LD_ADDR_VAR 0 2
117269: PUSH
117270: CALL_OW 44
117274: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
117275: LD_VAR 0 2
117279: PPUSH
117280: LD_INT 1
117282: PPUSH
117283: CALL_OW 51
// tmp := tmp ^ un ;
117287: LD_ADDR_VAR 0 3
117291: PUSH
117292: LD_VAR 0 3
117296: PUSH
117297: LD_VAR 0 2
117301: ADD
117302: ST_TO_ADDR
// end ;
117303: GO 117199
117305: POP
117306: POP
// repeat wait ( 0 0$1 ) ;
117307: LD_INT 35
117309: PPUSH
117310: CALL_OW 67
// for un in tmp do
117314: LD_ADDR_VAR 0 2
117318: PUSH
117319: LD_VAR 0 3
117323: PUSH
117324: FOR_IN
117325: IFFALSE 117399
// begin if IsDead ( un ) then
117327: LD_VAR 0 2
117331: PPUSH
117332: CALL_OW 301
117336: IFFALSE 117356
// begin tmp := tmp diff un ;
117338: LD_ADDR_VAR 0 3
117342: PUSH
117343: LD_VAR 0 3
117347: PUSH
117348: LD_VAR 0 2
117352: DIFF
117353: ST_TO_ADDR
// continue ;
117354: GO 117324
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
117356: LD_VAR 0 2
117360: PPUSH
117361: LD_INT 3
117363: PUSH
117364: LD_INT 22
117366: PUSH
117367: LD_INT 0
117369: PUSH
117370: EMPTY
117371: LIST
117372: LIST
117373: PUSH
117374: EMPTY
117375: LIST
117376: LIST
117377: PPUSH
117378: CALL_OW 69
117382: PPUSH
117383: LD_VAR 0 2
117387: PPUSH
117388: CALL_OW 74
117392: PPUSH
117393: CALL_OW 115
// end ;
117397: GO 117324
117399: POP
117400: POP
// until not tmp ;
117401: LD_VAR 0 3
117405: NOT
117406: IFFALSE 117307
// end ;
117408: PPOPN 3
117410: END
// every 0 0$1 trigger StreamModeActive and sTroll do
117411: LD_EXP 145
117415: PUSH
117416: LD_EXP 170
117420: AND
117421: IFFALSE 117475
117423: GO 117425
117425: DISABLE
// begin ToLua ( displayTroll(); ) ;
117426: LD_STRING displayTroll();
117428: PPUSH
117429: CALL_OW 559
// wait ( 3 3$00 ) ;
117433: LD_INT 6300
117435: PPUSH
117436: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117440: LD_STRING hideTroll();
117442: PPUSH
117443: CALL_OW 559
// wait ( 1 1$00 ) ;
117447: LD_INT 2100
117449: PPUSH
117450: CALL_OW 67
// ToLua ( displayTroll(); ) ;
117454: LD_STRING displayTroll();
117456: PPUSH
117457: CALL_OW 559
// wait ( 1 1$00 ) ;
117461: LD_INT 2100
117463: PPUSH
117464: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117468: LD_STRING hideTroll();
117470: PPUSH
117471: CALL_OW 559
// end ;
117475: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
117476: LD_EXP 145
117480: PUSH
117481: LD_EXP 171
117485: AND
117486: IFFALSE 117549
117488: GO 117490
117490: DISABLE
117491: LD_INT 0
117493: PPUSH
// begin p := 0 ;
117494: LD_ADDR_VAR 0 1
117498: PUSH
117499: LD_INT 0
117501: ST_TO_ADDR
// repeat game_speed := 1 ;
117502: LD_ADDR_OWVAR 65
117506: PUSH
117507: LD_INT 1
117509: ST_TO_ADDR
// wait ( 0 0$1 ) ;
117510: LD_INT 35
117512: PPUSH
117513: CALL_OW 67
// p := p + 1 ;
117517: LD_ADDR_VAR 0 1
117521: PUSH
117522: LD_VAR 0 1
117526: PUSH
117527: LD_INT 1
117529: PLUS
117530: ST_TO_ADDR
// until p >= 60 ;
117531: LD_VAR 0 1
117535: PUSH
117536: LD_INT 60
117538: GREATEREQUAL
117539: IFFALSE 117502
// game_speed := 4 ;
117541: LD_ADDR_OWVAR 65
117545: PUSH
117546: LD_INT 4
117548: ST_TO_ADDR
// end ;
117549: PPOPN 1
117551: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
117552: LD_EXP 145
117556: PUSH
117557: LD_EXP 172
117561: AND
117562: IFFALSE 117708
117564: GO 117566
117566: DISABLE
117567: LD_INT 0
117569: PPUSH
117570: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117571: LD_ADDR_VAR 0 1
117575: PUSH
117576: LD_INT 22
117578: PUSH
117579: LD_OWVAR 2
117583: PUSH
117584: EMPTY
117585: LIST
117586: LIST
117587: PUSH
117588: LD_INT 2
117590: PUSH
117591: LD_INT 30
117593: PUSH
117594: LD_INT 0
117596: PUSH
117597: EMPTY
117598: LIST
117599: LIST
117600: PUSH
117601: LD_INT 30
117603: PUSH
117604: LD_INT 1
117606: PUSH
117607: EMPTY
117608: LIST
117609: LIST
117610: PUSH
117611: EMPTY
117612: LIST
117613: LIST
117614: LIST
117615: PUSH
117616: EMPTY
117617: LIST
117618: LIST
117619: PPUSH
117620: CALL_OW 69
117624: ST_TO_ADDR
// if not depot then
117625: LD_VAR 0 1
117629: NOT
117630: IFFALSE 117634
// exit ;
117632: GO 117708
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
117634: LD_ADDR_VAR 0 2
117638: PUSH
117639: LD_VAR 0 1
117643: PUSH
117644: LD_INT 1
117646: PPUSH
117647: LD_VAR 0 1
117651: PPUSH
117652: CALL_OW 12
117656: ARRAY
117657: PPUSH
117658: CALL_OW 274
117662: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
117663: LD_VAR 0 2
117667: PPUSH
117668: LD_INT 1
117670: PPUSH
117671: LD_INT 0
117673: PPUSH
117674: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
117678: LD_VAR 0 2
117682: PPUSH
117683: LD_INT 2
117685: PPUSH
117686: LD_INT 0
117688: PPUSH
117689: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
117693: LD_VAR 0 2
117697: PPUSH
117698: LD_INT 3
117700: PPUSH
117701: LD_INT 0
117703: PPUSH
117704: CALL_OW 277
// end ;
117708: PPOPN 2
117710: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
117711: LD_EXP 145
117715: PUSH
117716: LD_EXP 173
117720: AND
117721: IFFALSE 117818
117723: GO 117725
117725: DISABLE
117726: LD_INT 0
117728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117729: LD_ADDR_VAR 0 1
117733: PUSH
117734: LD_INT 22
117736: PUSH
117737: LD_OWVAR 2
117741: PUSH
117742: EMPTY
117743: LIST
117744: LIST
117745: PUSH
117746: LD_INT 21
117748: PUSH
117749: LD_INT 1
117751: PUSH
117752: EMPTY
117753: LIST
117754: LIST
117755: PUSH
117756: LD_INT 3
117758: PUSH
117759: LD_INT 23
117761: PUSH
117762: LD_INT 0
117764: PUSH
117765: EMPTY
117766: LIST
117767: LIST
117768: PUSH
117769: EMPTY
117770: LIST
117771: LIST
117772: PUSH
117773: EMPTY
117774: LIST
117775: LIST
117776: LIST
117777: PPUSH
117778: CALL_OW 69
117782: ST_TO_ADDR
// if not tmp then
117783: LD_VAR 0 1
117787: NOT
117788: IFFALSE 117792
// exit ;
117790: GO 117818
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
117792: LD_VAR 0 1
117796: PUSH
117797: LD_INT 1
117799: PPUSH
117800: LD_VAR 0 1
117804: PPUSH
117805: CALL_OW 12
117809: ARRAY
117810: PPUSH
117811: LD_INT 200
117813: PPUSH
117814: CALL_OW 234
// end ;
117818: PPOPN 1
117820: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
117821: LD_EXP 145
117825: PUSH
117826: LD_EXP 174
117830: AND
117831: IFFALSE 117910
117833: GO 117835
117835: DISABLE
117836: LD_INT 0
117838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
117839: LD_ADDR_VAR 0 1
117843: PUSH
117844: LD_INT 22
117846: PUSH
117847: LD_OWVAR 2
117851: PUSH
117852: EMPTY
117853: LIST
117854: LIST
117855: PUSH
117856: LD_INT 21
117858: PUSH
117859: LD_INT 2
117861: PUSH
117862: EMPTY
117863: LIST
117864: LIST
117865: PUSH
117866: EMPTY
117867: LIST
117868: LIST
117869: PPUSH
117870: CALL_OW 69
117874: ST_TO_ADDR
// if not tmp then
117875: LD_VAR 0 1
117879: NOT
117880: IFFALSE 117884
// exit ;
117882: GO 117910
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
117884: LD_VAR 0 1
117888: PUSH
117889: LD_INT 1
117891: PPUSH
117892: LD_VAR 0 1
117896: PPUSH
117897: CALL_OW 12
117901: ARRAY
117902: PPUSH
117903: LD_INT 60
117905: PPUSH
117906: CALL_OW 234
// end ;
117910: PPOPN 1
117912: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
117913: LD_EXP 145
117917: PUSH
117918: LD_EXP 175
117922: AND
117923: IFFALSE 118022
117925: GO 117927
117927: DISABLE
117928: LD_INT 0
117930: PPUSH
117931: PPUSH
// begin enable ;
117932: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
117933: LD_ADDR_VAR 0 1
117937: PUSH
117938: LD_INT 22
117940: PUSH
117941: LD_OWVAR 2
117945: PUSH
117946: EMPTY
117947: LIST
117948: LIST
117949: PUSH
117950: LD_INT 61
117952: PUSH
117953: EMPTY
117954: LIST
117955: PUSH
117956: LD_INT 33
117958: PUSH
117959: LD_INT 2
117961: PUSH
117962: EMPTY
117963: LIST
117964: LIST
117965: PUSH
117966: EMPTY
117967: LIST
117968: LIST
117969: LIST
117970: PPUSH
117971: CALL_OW 69
117975: ST_TO_ADDR
// if not tmp then
117976: LD_VAR 0 1
117980: NOT
117981: IFFALSE 117985
// exit ;
117983: GO 118022
// for i in tmp do
117985: LD_ADDR_VAR 0 2
117989: PUSH
117990: LD_VAR 0 1
117994: PUSH
117995: FOR_IN
117996: IFFALSE 118020
// if IsControledBy ( i ) then
117998: LD_VAR 0 2
118002: PPUSH
118003: CALL_OW 312
118007: IFFALSE 118018
// ComUnlink ( i ) ;
118009: LD_VAR 0 2
118013: PPUSH
118014: CALL_OW 136
118018: GO 117995
118020: POP
118021: POP
// end ;
118022: PPOPN 2
118024: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
118025: LD_EXP 145
118029: PUSH
118030: LD_EXP 176
118034: AND
118035: IFFALSE 118175
118037: GO 118039
118039: DISABLE
118040: LD_INT 0
118042: PPUSH
118043: PPUSH
// begin ToLua ( displayPowell(); ) ;
118044: LD_STRING displayPowell();
118046: PPUSH
118047: CALL_OW 559
// uc_side := 0 ;
118051: LD_ADDR_OWVAR 20
118055: PUSH
118056: LD_INT 0
118058: ST_TO_ADDR
// uc_nation := 2 ;
118059: LD_ADDR_OWVAR 21
118063: PUSH
118064: LD_INT 2
118066: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
118067: LD_ADDR_OWVAR 37
118071: PUSH
118072: LD_INT 14
118074: ST_TO_ADDR
// vc_engine := engine_siberite ;
118075: LD_ADDR_OWVAR 39
118079: PUSH
118080: LD_INT 3
118082: ST_TO_ADDR
// vc_control := control_apeman ;
118083: LD_ADDR_OWVAR 38
118087: PUSH
118088: LD_INT 5
118090: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
118091: LD_ADDR_OWVAR 40
118095: PUSH
118096: LD_INT 29
118098: ST_TO_ADDR
// un := CreateVehicle ;
118099: LD_ADDR_VAR 0 2
118103: PUSH
118104: CALL_OW 45
118108: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118109: LD_VAR 0 2
118113: PPUSH
118114: LD_INT 1
118116: PPUSH
118117: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118121: LD_INT 35
118123: PPUSH
118124: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118128: LD_VAR 0 2
118132: PPUSH
118133: LD_INT 22
118135: PUSH
118136: LD_OWVAR 2
118140: PUSH
118141: EMPTY
118142: LIST
118143: LIST
118144: PPUSH
118145: CALL_OW 69
118149: PPUSH
118150: LD_VAR 0 2
118154: PPUSH
118155: CALL_OW 74
118159: PPUSH
118160: CALL_OW 115
// until IsDead ( un ) ;
118164: LD_VAR 0 2
118168: PPUSH
118169: CALL_OW 301
118173: IFFALSE 118121
// end ;
118175: PPOPN 2
118177: END
// every 0 0$1 trigger StreamModeActive and sStu do
118178: LD_EXP 145
118182: PUSH
118183: LD_EXP 184
118187: AND
118188: IFFALSE 118204
118190: GO 118192
118192: DISABLE
// begin ToLua ( displayStucuk(); ) ;
118193: LD_STRING displayStucuk();
118195: PPUSH
118196: CALL_OW 559
// ResetFog ;
118200: CALL_OW 335
// end ;
118204: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
118205: LD_EXP 145
118209: PUSH
118210: LD_EXP 177
118214: AND
118215: IFFALSE 118356
118217: GO 118219
118219: DISABLE
118220: LD_INT 0
118222: PPUSH
118223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118224: LD_ADDR_VAR 0 2
118228: PUSH
118229: LD_INT 22
118231: PUSH
118232: LD_OWVAR 2
118236: PUSH
118237: EMPTY
118238: LIST
118239: LIST
118240: PUSH
118241: LD_INT 21
118243: PUSH
118244: LD_INT 1
118246: PUSH
118247: EMPTY
118248: LIST
118249: LIST
118250: PUSH
118251: EMPTY
118252: LIST
118253: LIST
118254: PPUSH
118255: CALL_OW 69
118259: ST_TO_ADDR
// if not tmp then
118260: LD_VAR 0 2
118264: NOT
118265: IFFALSE 118269
// exit ;
118267: GO 118356
// un := tmp [ rand ( 1 , tmp ) ] ;
118269: LD_ADDR_VAR 0 1
118273: PUSH
118274: LD_VAR 0 2
118278: PUSH
118279: LD_INT 1
118281: PPUSH
118282: LD_VAR 0 2
118286: PPUSH
118287: CALL_OW 12
118291: ARRAY
118292: ST_TO_ADDR
// SetSide ( un , 0 ) ;
118293: LD_VAR 0 1
118297: PPUSH
118298: LD_INT 0
118300: PPUSH
118301: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
118305: LD_VAR 0 1
118309: PPUSH
118310: LD_OWVAR 3
118314: PUSH
118315: LD_VAR 0 1
118319: DIFF
118320: PPUSH
118321: LD_VAR 0 1
118325: PPUSH
118326: CALL_OW 74
118330: PPUSH
118331: CALL_OW 115
// wait ( 0 0$20 ) ;
118335: LD_INT 700
118337: PPUSH
118338: CALL_OW 67
// SetSide ( un , your_side ) ;
118342: LD_VAR 0 1
118346: PPUSH
118347: LD_OWVAR 2
118351: PPUSH
118352: CALL_OW 235
// end ;
118356: PPOPN 2
118358: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
118359: LD_EXP 145
118363: PUSH
118364: LD_EXP 178
118368: AND
118369: IFFALSE 118475
118371: GO 118373
118373: DISABLE
118374: LD_INT 0
118376: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118377: LD_ADDR_VAR 0 1
118381: PUSH
118382: LD_INT 22
118384: PUSH
118385: LD_OWVAR 2
118389: PUSH
118390: EMPTY
118391: LIST
118392: LIST
118393: PUSH
118394: LD_INT 2
118396: PUSH
118397: LD_INT 30
118399: PUSH
118400: LD_INT 0
118402: PUSH
118403: EMPTY
118404: LIST
118405: LIST
118406: PUSH
118407: LD_INT 30
118409: PUSH
118410: LD_INT 1
118412: PUSH
118413: EMPTY
118414: LIST
118415: LIST
118416: PUSH
118417: EMPTY
118418: LIST
118419: LIST
118420: LIST
118421: PUSH
118422: EMPTY
118423: LIST
118424: LIST
118425: PPUSH
118426: CALL_OW 69
118430: ST_TO_ADDR
// if not depot then
118431: LD_VAR 0 1
118435: NOT
118436: IFFALSE 118440
// exit ;
118438: GO 118475
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
118440: LD_VAR 0 1
118444: PUSH
118445: LD_INT 1
118447: ARRAY
118448: PPUSH
118449: CALL_OW 250
118453: PPUSH
118454: LD_VAR 0 1
118458: PUSH
118459: LD_INT 1
118461: ARRAY
118462: PPUSH
118463: CALL_OW 251
118467: PPUSH
118468: LD_INT 70
118470: PPUSH
118471: CALL_OW 495
// end ;
118475: PPOPN 1
118477: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
118478: LD_EXP 145
118482: PUSH
118483: LD_EXP 179
118487: AND
118488: IFFALSE 118699
118490: GO 118492
118492: DISABLE
118493: LD_INT 0
118495: PPUSH
118496: PPUSH
118497: PPUSH
118498: PPUSH
118499: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118500: LD_ADDR_VAR 0 5
118504: PUSH
118505: LD_INT 22
118507: PUSH
118508: LD_OWVAR 2
118512: PUSH
118513: EMPTY
118514: LIST
118515: LIST
118516: PUSH
118517: LD_INT 21
118519: PUSH
118520: LD_INT 1
118522: PUSH
118523: EMPTY
118524: LIST
118525: LIST
118526: PUSH
118527: EMPTY
118528: LIST
118529: LIST
118530: PPUSH
118531: CALL_OW 69
118535: ST_TO_ADDR
// if not tmp then
118536: LD_VAR 0 5
118540: NOT
118541: IFFALSE 118545
// exit ;
118543: GO 118699
// for i in tmp do
118545: LD_ADDR_VAR 0 1
118549: PUSH
118550: LD_VAR 0 5
118554: PUSH
118555: FOR_IN
118556: IFFALSE 118697
// begin d := rand ( 0 , 5 ) ;
118558: LD_ADDR_VAR 0 4
118562: PUSH
118563: LD_INT 0
118565: PPUSH
118566: LD_INT 5
118568: PPUSH
118569: CALL_OW 12
118573: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
118574: LD_ADDR_VAR 0 2
118578: PUSH
118579: LD_VAR 0 1
118583: PPUSH
118584: CALL_OW 250
118588: PPUSH
118589: LD_VAR 0 4
118593: PPUSH
118594: LD_INT 3
118596: PPUSH
118597: LD_INT 12
118599: PPUSH
118600: CALL_OW 12
118604: PPUSH
118605: CALL_OW 272
118609: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
118610: LD_ADDR_VAR 0 3
118614: PUSH
118615: LD_VAR 0 1
118619: PPUSH
118620: CALL_OW 251
118624: PPUSH
118625: LD_VAR 0 4
118629: PPUSH
118630: LD_INT 3
118632: PPUSH
118633: LD_INT 12
118635: PPUSH
118636: CALL_OW 12
118640: PPUSH
118641: CALL_OW 273
118645: ST_TO_ADDR
// if ValidHex ( x , y ) then
118646: LD_VAR 0 2
118650: PPUSH
118651: LD_VAR 0 3
118655: PPUSH
118656: CALL_OW 488
118660: IFFALSE 118695
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
118662: LD_VAR 0 1
118666: PPUSH
118667: LD_VAR 0 2
118671: PPUSH
118672: LD_VAR 0 3
118676: PPUSH
118677: LD_INT 3
118679: PPUSH
118680: LD_INT 6
118682: PPUSH
118683: CALL_OW 12
118687: PPUSH
118688: LD_INT 1
118690: PPUSH
118691: CALL_OW 483
// end ;
118695: GO 118555
118697: POP
118698: POP
// end ;
118699: PPOPN 5
118701: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
118702: LD_EXP 145
118706: PUSH
118707: LD_EXP 180
118711: AND
118712: IFFALSE 118806
118714: GO 118716
118716: DISABLE
118717: LD_INT 0
118719: PPUSH
118720: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
118721: LD_ADDR_VAR 0 2
118725: PUSH
118726: LD_INT 22
118728: PUSH
118729: LD_OWVAR 2
118733: PUSH
118734: EMPTY
118735: LIST
118736: LIST
118737: PUSH
118738: LD_INT 32
118740: PUSH
118741: LD_INT 1
118743: PUSH
118744: EMPTY
118745: LIST
118746: LIST
118747: PUSH
118748: LD_INT 21
118750: PUSH
118751: LD_INT 2
118753: PUSH
118754: EMPTY
118755: LIST
118756: LIST
118757: PUSH
118758: EMPTY
118759: LIST
118760: LIST
118761: LIST
118762: PPUSH
118763: CALL_OW 69
118767: ST_TO_ADDR
// if not tmp then
118768: LD_VAR 0 2
118772: NOT
118773: IFFALSE 118777
// exit ;
118775: GO 118806
// for i in tmp do
118777: LD_ADDR_VAR 0 1
118781: PUSH
118782: LD_VAR 0 2
118786: PUSH
118787: FOR_IN
118788: IFFALSE 118804
// SetFuel ( i , 0 ) ;
118790: LD_VAR 0 1
118794: PPUSH
118795: LD_INT 0
118797: PPUSH
118798: CALL_OW 240
118802: GO 118787
118804: POP
118805: POP
// end ;
118806: PPOPN 2
118808: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
118809: LD_EXP 145
118813: PUSH
118814: LD_EXP 181
118818: AND
118819: IFFALSE 118885
118821: GO 118823
118823: DISABLE
118824: LD_INT 0
118826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118827: LD_ADDR_VAR 0 1
118831: PUSH
118832: LD_INT 22
118834: PUSH
118835: LD_OWVAR 2
118839: PUSH
118840: EMPTY
118841: LIST
118842: LIST
118843: PUSH
118844: LD_INT 30
118846: PUSH
118847: LD_INT 29
118849: PUSH
118850: EMPTY
118851: LIST
118852: LIST
118853: PUSH
118854: EMPTY
118855: LIST
118856: LIST
118857: PPUSH
118858: CALL_OW 69
118862: ST_TO_ADDR
// if not tmp then
118863: LD_VAR 0 1
118867: NOT
118868: IFFALSE 118872
// exit ;
118870: GO 118885
// DestroyUnit ( tmp [ 1 ] ) ;
118872: LD_VAR 0 1
118876: PUSH
118877: LD_INT 1
118879: ARRAY
118880: PPUSH
118881: CALL_OW 65
// end ;
118885: PPOPN 1
118887: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
118888: LD_EXP 145
118892: PUSH
118893: LD_EXP 183
118897: AND
118898: IFFALSE 119027
118900: GO 118902
118902: DISABLE
118903: LD_INT 0
118905: PPUSH
// begin uc_side := 0 ;
118906: LD_ADDR_OWVAR 20
118910: PUSH
118911: LD_INT 0
118913: ST_TO_ADDR
// uc_nation := nation_arabian ;
118914: LD_ADDR_OWVAR 21
118918: PUSH
118919: LD_INT 2
118921: ST_TO_ADDR
// hc_gallery :=  ;
118922: LD_ADDR_OWVAR 33
118926: PUSH
118927: LD_STRING 
118929: ST_TO_ADDR
// hc_name :=  ;
118930: LD_ADDR_OWVAR 26
118934: PUSH
118935: LD_STRING 
118937: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
118938: LD_INT 1
118940: PPUSH
118941: LD_INT 11
118943: PPUSH
118944: LD_INT 10
118946: PPUSH
118947: CALL_OW 380
// un := CreateHuman ;
118951: LD_ADDR_VAR 0 1
118955: PUSH
118956: CALL_OW 44
118960: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118961: LD_VAR 0 1
118965: PPUSH
118966: LD_INT 1
118968: PPUSH
118969: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118973: LD_INT 35
118975: PPUSH
118976: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118980: LD_VAR 0 1
118984: PPUSH
118985: LD_INT 22
118987: PUSH
118988: LD_OWVAR 2
118992: PUSH
118993: EMPTY
118994: LIST
118995: LIST
118996: PPUSH
118997: CALL_OW 69
119001: PPUSH
119002: LD_VAR 0 1
119006: PPUSH
119007: CALL_OW 74
119011: PPUSH
119012: CALL_OW 115
// until IsDead ( un ) ;
119016: LD_VAR 0 1
119020: PPUSH
119021: CALL_OW 301
119025: IFFALSE 118973
// end ;
119027: PPOPN 1
119029: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
119030: LD_EXP 145
119034: PUSH
119035: LD_EXP 185
119039: AND
119040: IFFALSE 119052
119042: GO 119044
119044: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
119045: LD_STRING earthquake(getX(game), 0, 32)
119047: PPUSH
119048: CALL_OW 559
119052: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
119053: LD_EXP 145
119057: PUSH
119058: LD_EXP 186
119062: AND
119063: IFFALSE 119154
119065: GO 119067
119067: DISABLE
119068: LD_INT 0
119070: PPUSH
// begin enable ;
119071: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
119072: LD_ADDR_VAR 0 1
119076: PUSH
119077: LD_INT 22
119079: PUSH
119080: LD_OWVAR 2
119084: PUSH
119085: EMPTY
119086: LIST
119087: LIST
119088: PUSH
119089: LD_INT 21
119091: PUSH
119092: LD_INT 2
119094: PUSH
119095: EMPTY
119096: LIST
119097: LIST
119098: PUSH
119099: LD_INT 33
119101: PUSH
119102: LD_INT 3
119104: PUSH
119105: EMPTY
119106: LIST
119107: LIST
119108: PUSH
119109: EMPTY
119110: LIST
119111: LIST
119112: LIST
119113: PPUSH
119114: CALL_OW 69
119118: ST_TO_ADDR
// if not tmp then
119119: LD_VAR 0 1
119123: NOT
119124: IFFALSE 119128
// exit ;
119126: GO 119154
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119128: LD_VAR 0 1
119132: PUSH
119133: LD_INT 1
119135: PPUSH
119136: LD_VAR 0 1
119140: PPUSH
119141: CALL_OW 12
119145: ARRAY
119146: PPUSH
119147: LD_INT 1
119149: PPUSH
119150: CALL_OW 234
// end ;
119154: PPOPN 1
119156: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
119157: LD_EXP 145
119161: PUSH
119162: LD_EXP 187
119166: AND
119167: IFFALSE 119308
119169: GO 119171
119171: DISABLE
119172: LD_INT 0
119174: PPUSH
119175: PPUSH
119176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119177: LD_ADDR_VAR 0 3
119181: PUSH
119182: LD_INT 22
119184: PUSH
119185: LD_OWVAR 2
119189: PUSH
119190: EMPTY
119191: LIST
119192: LIST
119193: PUSH
119194: LD_INT 25
119196: PUSH
119197: LD_INT 1
119199: PUSH
119200: EMPTY
119201: LIST
119202: LIST
119203: PUSH
119204: EMPTY
119205: LIST
119206: LIST
119207: PPUSH
119208: CALL_OW 69
119212: ST_TO_ADDR
// if not tmp then
119213: LD_VAR 0 3
119217: NOT
119218: IFFALSE 119222
// exit ;
119220: GO 119308
// un := tmp [ rand ( 1 , tmp ) ] ;
119222: LD_ADDR_VAR 0 2
119226: PUSH
119227: LD_VAR 0 3
119231: PUSH
119232: LD_INT 1
119234: PPUSH
119235: LD_VAR 0 3
119239: PPUSH
119240: CALL_OW 12
119244: ARRAY
119245: ST_TO_ADDR
// if Crawls ( un ) then
119246: LD_VAR 0 2
119250: PPUSH
119251: CALL_OW 318
119255: IFFALSE 119266
// ComWalk ( un ) ;
119257: LD_VAR 0 2
119261: PPUSH
119262: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
119266: LD_VAR 0 2
119270: PPUSH
119271: LD_INT 9
119273: PPUSH
119274: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
119278: LD_INT 28
119280: PPUSH
119281: LD_OWVAR 2
119285: PPUSH
119286: LD_INT 2
119288: PPUSH
119289: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
119293: LD_INT 29
119295: PPUSH
119296: LD_OWVAR 2
119300: PPUSH
119301: LD_INT 2
119303: PPUSH
119304: CALL_OW 322
// end ;
119308: PPOPN 3
119310: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
119311: LD_EXP 145
119315: PUSH
119316: LD_EXP 188
119320: AND
119321: IFFALSE 119432
119323: GO 119325
119325: DISABLE
119326: LD_INT 0
119328: PPUSH
119329: PPUSH
119330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119331: LD_ADDR_VAR 0 3
119335: PUSH
119336: LD_INT 22
119338: PUSH
119339: LD_OWVAR 2
119343: PUSH
119344: EMPTY
119345: LIST
119346: LIST
119347: PUSH
119348: LD_INT 25
119350: PUSH
119351: LD_INT 1
119353: PUSH
119354: EMPTY
119355: LIST
119356: LIST
119357: PUSH
119358: EMPTY
119359: LIST
119360: LIST
119361: PPUSH
119362: CALL_OW 69
119366: ST_TO_ADDR
// if not tmp then
119367: LD_VAR 0 3
119371: NOT
119372: IFFALSE 119376
// exit ;
119374: GO 119432
// un := tmp [ rand ( 1 , tmp ) ] ;
119376: LD_ADDR_VAR 0 2
119380: PUSH
119381: LD_VAR 0 3
119385: PUSH
119386: LD_INT 1
119388: PPUSH
119389: LD_VAR 0 3
119393: PPUSH
119394: CALL_OW 12
119398: ARRAY
119399: ST_TO_ADDR
// if Crawls ( un ) then
119400: LD_VAR 0 2
119404: PPUSH
119405: CALL_OW 318
119409: IFFALSE 119420
// ComWalk ( un ) ;
119411: LD_VAR 0 2
119415: PPUSH
119416: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119420: LD_VAR 0 2
119424: PPUSH
119425: LD_INT 8
119427: PPUSH
119428: CALL_OW 336
// end ;
119432: PPOPN 3
119434: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
119435: LD_EXP 145
119439: PUSH
119440: LD_EXP 189
119444: AND
119445: IFFALSE 119589
119447: GO 119449
119449: DISABLE
119450: LD_INT 0
119452: PPUSH
119453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
119454: LD_ADDR_VAR 0 2
119458: PUSH
119459: LD_INT 22
119461: PUSH
119462: LD_OWVAR 2
119466: PUSH
119467: EMPTY
119468: LIST
119469: LIST
119470: PUSH
119471: LD_INT 21
119473: PUSH
119474: LD_INT 2
119476: PUSH
119477: EMPTY
119478: LIST
119479: LIST
119480: PUSH
119481: LD_INT 2
119483: PUSH
119484: LD_INT 34
119486: PUSH
119487: LD_INT 12
119489: PUSH
119490: EMPTY
119491: LIST
119492: LIST
119493: PUSH
119494: LD_INT 34
119496: PUSH
119497: LD_INT 51
119499: PUSH
119500: EMPTY
119501: LIST
119502: LIST
119503: PUSH
119504: LD_INT 34
119506: PUSH
119507: LD_INT 32
119509: PUSH
119510: EMPTY
119511: LIST
119512: LIST
119513: PUSH
119514: EMPTY
119515: LIST
119516: LIST
119517: LIST
119518: LIST
119519: PUSH
119520: EMPTY
119521: LIST
119522: LIST
119523: LIST
119524: PPUSH
119525: CALL_OW 69
119529: ST_TO_ADDR
// if not tmp then
119530: LD_VAR 0 2
119534: NOT
119535: IFFALSE 119539
// exit ;
119537: GO 119589
// for i in tmp do
119539: LD_ADDR_VAR 0 1
119543: PUSH
119544: LD_VAR 0 2
119548: PUSH
119549: FOR_IN
119550: IFFALSE 119587
// if GetCargo ( i , mat_artifact ) = 0 then
119552: LD_VAR 0 1
119556: PPUSH
119557: LD_INT 4
119559: PPUSH
119560: CALL_OW 289
119564: PUSH
119565: LD_INT 0
119567: EQUAL
119568: IFFALSE 119585
// SetCargo ( i , mat_siberit , 100 ) ;
119570: LD_VAR 0 1
119574: PPUSH
119575: LD_INT 3
119577: PPUSH
119578: LD_INT 100
119580: PPUSH
119581: CALL_OW 290
119585: GO 119549
119587: POP
119588: POP
// end ;
119589: PPOPN 2
119591: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
119592: LD_EXP 145
119596: PUSH
119597: LD_EXP 190
119601: AND
119602: IFFALSE 119785
119604: GO 119606
119606: DISABLE
119607: LD_INT 0
119609: PPUSH
119610: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119611: LD_ADDR_VAR 0 2
119615: PUSH
119616: LD_INT 22
119618: PUSH
119619: LD_OWVAR 2
119623: PUSH
119624: EMPTY
119625: LIST
119626: LIST
119627: PPUSH
119628: CALL_OW 69
119632: ST_TO_ADDR
// if not tmp then
119633: LD_VAR 0 2
119637: NOT
119638: IFFALSE 119642
// exit ;
119640: GO 119785
// for i := 1 to 2 do
119642: LD_ADDR_VAR 0 1
119646: PUSH
119647: DOUBLE
119648: LD_INT 1
119650: DEC
119651: ST_TO_ADDR
119652: LD_INT 2
119654: PUSH
119655: FOR_TO
119656: IFFALSE 119783
// begin uc_side := your_side ;
119658: LD_ADDR_OWVAR 20
119662: PUSH
119663: LD_OWVAR 2
119667: ST_TO_ADDR
// uc_nation := nation_american ;
119668: LD_ADDR_OWVAR 21
119672: PUSH
119673: LD_INT 1
119675: ST_TO_ADDR
// vc_chassis := us_morphling ;
119676: LD_ADDR_OWVAR 37
119680: PUSH
119681: LD_INT 5
119683: ST_TO_ADDR
// vc_engine := engine_siberite ;
119684: LD_ADDR_OWVAR 39
119688: PUSH
119689: LD_INT 3
119691: ST_TO_ADDR
// vc_control := control_computer ;
119692: LD_ADDR_OWVAR 38
119696: PUSH
119697: LD_INT 3
119699: ST_TO_ADDR
// vc_weapon := us_double_laser ;
119700: LD_ADDR_OWVAR 40
119704: PUSH
119705: LD_INT 10
119707: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
119708: LD_VAR 0 2
119712: PUSH
119713: LD_INT 1
119715: ARRAY
119716: PPUSH
119717: CALL_OW 310
119721: NOT
119722: IFFALSE 119769
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
119724: CALL_OW 45
119728: PPUSH
119729: LD_VAR 0 2
119733: PUSH
119734: LD_INT 1
119736: ARRAY
119737: PPUSH
119738: CALL_OW 250
119742: PPUSH
119743: LD_VAR 0 2
119747: PUSH
119748: LD_INT 1
119750: ARRAY
119751: PPUSH
119752: CALL_OW 251
119756: PPUSH
119757: LD_INT 12
119759: PPUSH
119760: LD_INT 1
119762: PPUSH
119763: CALL_OW 50
119767: GO 119781
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
119769: CALL_OW 45
119773: PPUSH
119774: LD_INT 1
119776: PPUSH
119777: CALL_OW 51
// end ;
119781: GO 119655
119783: POP
119784: POP
// end ;
119785: PPOPN 2
119787: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
119788: LD_EXP 145
119792: PUSH
119793: LD_EXP 191
119797: AND
119798: IFFALSE 120020
119800: GO 119802
119802: DISABLE
119803: LD_INT 0
119805: PPUSH
119806: PPUSH
119807: PPUSH
119808: PPUSH
119809: PPUSH
119810: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119811: LD_ADDR_VAR 0 6
119815: PUSH
119816: LD_INT 22
119818: PUSH
119819: LD_OWVAR 2
119823: PUSH
119824: EMPTY
119825: LIST
119826: LIST
119827: PUSH
119828: LD_INT 21
119830: PUSH
119831: LD_INT 1
119833: PUSH
119834: EMPTY
119835: LIST
119836: LIST
119837: PUSH
119838: LD_INT 3
119840: PUSH
119841: LD_INT 23
119843: PUSH
119844: LD_INT 0
119846: PUSH
119847: EMPTY
119848: LIST
119849: LIST
119850: PUSH
119851: EMPTY
119852: LIST
119853: LIST
119854: PUSH
119855: EMPTY
119856: LIST
119857: LIST
119858: LIST
119859: PPUSH
119860: CALL_OW 69
119864: ST_TO_ADDR
// if not tmp then
119865: LD_VAR 0 6
119869: NOT
119870: IFFALSE 119874
// exit ;
119872: GO 120020
// s1 := rand ( 1 , 4 ) ;
119874: LD_ADDR_VAR 0 2
119878: PUSH
119879: LD_INT 1
119881: PPUSH
119882: LD_INT 4
119884: PPUSH
119885: CALL_OW 12
119889: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
119890: LD_ADDR_VAR 0 4
119894: PUSH
119895: LD_VAR 0 6
119899: PUSH
119900: LD_INT 1
119902: ARRAY
119903: PPUSH
119904: LD_VAR 0 2
119908: PPUSH
119909: CALL_OW 259
119913: ST_TO_ADDR
// if s1 = 1 then
119914: LD_VAR 0 2
119918: PUSH
119919: LD_INT 1
119921: EQUAL
119922: IFFALSE 119942
// s2 := rand ( 2 , 4 ) else
119924: LD_ADDR_VAR 0 3
119928: PUSH
119929: LD_INT 2
119931: PPUSH
119932: LD_INT 4
119934: PPUSH
119935: CALL_OW 12
119939: ST_TO_ADDR
119940: GO 119950
// s2 := 1 ;
119942: LD_ADDR_VAR 0 3
119946: PUSH
119947: LD_INT 1
119949: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
119950: LD_ADDR_VAR 0 5
119954: PUSH
119955: LD_VAR 0 6
119959: PUSH
119960: LD_INT 1
119962: ARRAY
119963: PPUSH
119964: LD_VAR 0 3
119968: PPUSH
119969: CALL_OW 259
119973: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
119974: LD_VAR 0 6
119978: PUSH
119979: LD_INT 1
119981: ARRAY
119982: PPUSH
119983: LD_VAR 0 2
119987: PPUSH
119988: LD_VAR 0 5
119992: PPUSH
119993: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
119997: LD_VAR 0 6
120001: PUSH
120002: LD_INT 1
120004: ARRAY
120005: PPUSH
120006: LD_VAR 0 3
120010: PPUSH
120011: LD_VAR 0 4
120015: PPUSH
120016: CALL_OW 237
// end ;
120020: PPOPN 6
120022: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
120023: LD_EXP 145
120027: PUSH
120028: LD_EXP 192
120032: AND
120033: IFFALSE 120112
120035: GO 120037
120037: DISABLE
120038: LD_INT 0
120040: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
120041: LD_ADDR_VAR 0 1
120045: PUSH
120046: LD_INT 22
120048: PUSH
120049: LD_OWVAR 2
120053: PUSH
120054: EMPTY
120055: LIST
120056: LIST
120057: PUSH
120058: LD_INT 30
120060: PUSH
120061: LD_INT 3
120063: PUSH
120064: EMPTY
120065: LIST
120066: LIST
120067: PUSH
120068: EMPTY
120069: LIST
120070: LIST
120071: PPUSH
120072: CALL_OW 69
120076: ST_TO_ADDR
// if not tmp then
120077: LD_VAR 0 1
120081: NOT
120082: IFFALSE 120086
// exit ;
120084: GO 120112
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
120086: LD_VAR 0 1
120090: PUSH
120091: LD_INT 1
120093: PPUSH
120094: LD_VAR 0 1
120098: PPUSH
120099: CALL_OW 12
120103: ARRAY
120104: PPUSH
120105: LD_INT 1
120107: PPUSH
120108: CALL_OW 234
// end ;
120112: PPOPN 1
120114: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
120115: LD_EXP 145
120119: PUSH
120120: LD_EXP 193
120124: AND
120125: IFFALSE 120237
120127: GO 120129
120129: DISABLE
120130: LD_INT 0
120132: PPUSH
120133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
120134: LD_ADDR_VAR 0 2
120138: PUSH
120139: LD_INT 22
120141: PUSH
120142: LD_OWVAR 2
120146: PUSH
120147: EMPTY
120148: LIST
120149: LIST
120150: PUSH
120151: LD_INT 2
120153: PUSH
120154: LD_INT 30
120156: PUSH
120157: LD_INT 27
120159: PUSH
120160: EMPTY
120161: LIST
120162: LIST
120163: PUSH
120164: LD_INT 30
120166: PUSH
120167: LD_INT 26
120169: PUSH
120170: EMPTY
120171: LIST
120172: LIST
120173: PUSH
120174: LD_INT 30
120176: PUSH
120177: LD_INT 28
120179: PUSH
120180: EMPTY
120181: LIST
120182: LIST
120183: PUSH
120184: EMPTY
120185: LIST
120186: LIST
120187: LIST
120188: LIST
120189: PUSH
120190: EMPTY
120191: LIST
120192: LIST
120193: PPUSH
120194: CALL_OW 69
120198: ST_TO_ADDR
// if not tmp then
120199: LD_VAR 0 2
120203: NOT
120204: IFFALSE 120208
// exit ;
120206: GO 120237
// for i in tmp do
120208: LD_ADDR_VAR 0 1
120212: PUSH
120213: LD_VAR 0 2
120217: PUSH
120218: FOR_IN
120219: IFFALSE 120235
// SetLives ( i , 1 ) ;
120221: LD_VAR 0 1
120225: PPUSH
120226: LD_INT 1
120228: PPUSH
120229: CALL_OW 234
120233: GO 120218
120235: POP
120236: POP
// end ;
120237: PPOPN 2
120239: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
120240: LD_EXP 145
120244: PUSH
120245: LD_EXP 194
120249: AND
120250: IFFALSE 120537
120252: GO 120254
120254: DISABLE
120255: LD_INT 0
120257: PPUSH
120258: PPUSH
120259: PPUSH
// begin i := rand ( 1 , 7 ) ;
120260: LD_ADDR_VAR 0 1
120264: PUSH
120265: LD_INT 1
120267: PPUSH
120268: LD_INT 7
120270: PPUSH
120271: CALL_OW 12
120275: ST_TO_ADDR
// case i of 1 :
120276: LD_VAR 0 1
120280: PUSH
120281: LD_INT 1
120283: DOUBLE
120284: EQUAL
120285: IFTRUE 120289
120287: GO 120299
120289: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
120290: LD_STRING earthquake(getX(game), 0, 32)
120292: PPUSH
120293: CALL_OW 559
120297: GO 120537
120299: LD_INT 2
120301: DOUBLE
120302: EQUAL
120303: IFTRUE 120307
120305: GO 120321
120307: POP
// begin ToLua ( displayStucuk(); ) ;
120308: LD_STRING displayStucuk();
120310: PPUSH
120311: CALL_OW 559
// ResetFog ;
120315: CALL_OW 335
// end ; 3 :
120319: GO 120537
120321: LD_INT 3
120323: DOUBLE
120324: EQUAL
120325: IFTRUE 120329
120327: GO 120433
120329: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120330: LD_ADDR_VAR 0 2
120334: PUSH
120335: LD_INT 22
120337: PUSH
120338: LD_OWVAR 2
120342: PUSH
120343: EMPTY
120344: LIST
120345: LIST
120346: PUSH
120347: LD_INT 25
120349: PUSH
120350: LD_INT 1
120352: PUSH
120353: EMPTY
120354: LIST
120355: LIST
120356: PUSH
120357: EMPTY
120358: LIST
120359: LIST
120360: PPUSH
120361: CALL_OW 69
120365: ST_TO_ADDR
// if not tmp then
120366: LD_VAR 0 2
120370: NOT
120371: IFFALSE 120375
// exit ;
120373: GO 120537
// un := tmp [ rand ( 1 , tmp ) ] ;
120375: LD_ADDR_VAR 0 3
120379: PUSH
120380: LD_VAR 0 2
120384: PUSH
120385: LD_INT 1
120387: PPUSH
120388: LD_VAR 0 2
120392: PPUSH
120393: CALL_OW 12
120397: ARRAY
120398: ST_TO_ADDR
// if Crawls ( un ) then
120399: LD_VAR 0 3
120403: PPUSH
120404: CALL_OW 318
120408: IFFALSE 120419
// ComWalk ( un ) ;
120410: LD_VAR 0 3
120414: PPUSH
120415: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120419: LD_VAR 0 3
120423: PPUSH
120424: LD_INT 8
120426: PPUSH
120427: CALL_OW 336
// end ; 4 :
120431: GO 120537
120433: LD_INT 4
120435: DOUBLE
120436: EQUAL
120437: IFTRUE 120441
120439: GO 120515
120441: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120442: LD_ADDR_VAR 0 2
120446: PUSH
120447: LD_INT 22
120449: PUSH
120450: LD_OWVAR 2
120454: PUSH
120455: EMPTY
120456: LIST
120457: LIST
120458: PUSH
120459: LD_INT 30
120461: PUSH
120462: LD_INT 29
120464: PUSH
120465: EMPTY
120466: LIST
120467: LIST
120468: PUSH
120469: EMPTY
120470: LIST
120471: LIST
120472: PPUSH
120473: CALL_OW 69
120477: ST_TO_ADDR
// if not tmp then
120478: LD_VAR 0 2
120482: NOT
120483: IFFALSE 120487
// exit ;
120485: GO 120537
// CenterNowOnUnits ( tmp [ 1 ] ) ;
120487: LD_VAR 0 2
120491: PUSH
120492: LD_INT 1
120494: ARRAY
120495: PPUSH
120496: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
120500: LD_VAR 0 2
120504: PUSH
120505: LD_INT 1
120507: ARRAY
120508: PPUSH
120509: CALL_OW 65
// end ; 5 .. 7 :
120513: GO 120537
120515: LD_INT 5
120517: DOUBLE
120518: GREATEREQUAL
120519: IFFALSE 120527
120521: LD_INT 7
120523: DOUBLE
120524: LESSEQUAL
120525: IFTRUE 120529
120527: GO 120536
120529: POP
// StreamSibBomb ; end ;
120530: CALL 116774 0 0
120534: GO 120537
120536: POP
// end ;
120537: PPOPN 3
120539: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
120540: LD_EXP 145
120544: PUSH
120545: LD_EXP 195
120549: AND
120550: IFFALSE 120706
120552: GO 120554
120554: DISABLE
120555: LD_INT 0
120557: PPUSH
120558: PPUSH
120559: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
120560: LD_ADDR_VAR 0 2
120564: PUSH
120565: LD_INT 81
120567: PUSH
120568: LD_OWVAR 2
120572: PUSH
120573: EMPTY
120574: LIST
120575: LIST
120576: PUSH
120577: LD_INT 2
120579: PUSH
120580: LD_INT 21
120582: PUSH
120583: LD_INT 1
120585: PUSH
120586: EMPTY
120587: LIST
120588: LIST
120589: PUSH
120590: LD_INT 21
120592: PUSH
120593: LD_INT 2
120595: PUSH
120596: EMPTY
120597: LIST
120598: LIST
120599: PUSH
120600: EMPTY
120601: LIST
120602: LIST
120603: LIST
120604: PUSH
120605: EMPTY
120606: LIST
120607: LIST
120608: PPUSH
120609: CALL_OW 69
120613: ST_TO_ADDR
// if not tmp then
120614: LD_VAR 0 2
120618: NOT
120619: IFFALSE 120623
// exit ;
120621: GO 120706
// p := 0 ;
120623: LD_ADDR_VAR 0 3
120627: PUSH
120628: LD_INT 0
120630: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120631: LD_INT 35
120633: PPUSH
120634: CALL_OW 67
// p := p + 1 ;
120638: LD_ADDR_VAR 0 3
120642: PUSH
120643: LD_VAR 0 3
120647: PUSH
120648: LD_INT 1
120650: PLUS
120651: ST_TO_ADDR
// for i in tmp do
120652: LD_ADDR_VAR 0 1
120656: PUSH
120657: LD_VAR 0 2
120661: PUSH
120662: FOR_IN
120663: IFFALSE 120694
// if GetLives ( i ) < 1000 then
120665: LD_VAR 0 1
120669: PPUSH
120670: CALL_OW 256
120674: PUSH
120675: LD_INT 1000
120677: LESS
120678: IFFALSE 120692
// SetLives ( i , 1000 ) ;
120680: LD_VAR 0 1
120684: PPUSH
120685: LD_INT 1000
120687: PPUSH
120688: CALL_OW 234
120692: GO 120662
120694: POP
120695: POP
// until p > 20 ;
120696: LD_VAR 0 3
120700: PUSH
120701: LD_INT 20
120703: GREATER
120704: IFFALSE 120631
// end ;
120706: PPOPN 3
120708: END
// every 0 0$1 trigger StreamModeActive and sTime do
120709: LD_EXP 145
120713: PUSH
120714: LD_EXP 196
120718: AND
120719: IFFALSE 120754
120721: GO 120723
120723: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
120724: LD_INT 28
120726: PPUSH
120727: LD_OWVAR 2
120731: PPUSH
120732: LD_INT 2
120734: PPUSH
120735: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
120739: LD_INT 30
120741: PPUSH
120742: LD_OWVAR 2
120746: PPUSH
120747: LD_INT 2
120749: PPUSH
120750: CALL_OW 322
// end ;
120754: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
120755: LD_EXP 145
120759: PUSH
120760: LD_EXP 197
120764: AND
120765: IFFALSE 120886
120767: GO 120769
120769: DISABLE
120770: LD_INT 0
120772: PPUSH
120773: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120774: LD_ADDR_VAR 0 2
120778: PUSH
120779: LD_INT 22
120781: PUSH
120782: LD_OWVAR 2
120786: PUSH
120787: EMPTY
120788: LIST
120789: LIST
120790: PUSH
120791: LD_INT 21
120793: PUSH
120794: LD_INT 1
120796: PUSH
120797: EMPTY
120798: LIST
120799: LIST
120800: PUSH
120801: LD_INT 3
120803: PUSH
120804: LD_INT 23
120806: PUSH
120807: LD_INT 0
120809: PUSH
120810: EMPTY
120811: LIST
120812: LIST
120813: PUSH
120814: EMPTY
120815: LIST
120816: LIST
120817: PUSH
120818: EMPTY
120819: LIST
120820: LIST
120821: LIST
120822: PPUSH
120823: CALL_OW 69
120827: ST_TO_ADDR
// if not tmp then
120828: LD_VAR 0 2
120832: NOT
120833: IFFALSE 120837
// exit ;
120835: GO 120886
// for i in tmp do
120837: LD_ADDR_VAR 0 1
120841: PUSH
120842: LD_VAR 0 2
120846: PUSH
120847: FOR_IN
120848: IFFALSE 120884
// begin if Crawls ( i ) then
120850: LD_VAR 0 1
120854: PPUSH
120855: CALL_OW 318
120859: IFFALSE 120870
// ComWalk ( i ) ;
120861: LD_VAR 0 1
120865: PPUSH
120866: CALL_OW 138
// SetClass ( i , 2 ) ;
120870: LD_VAR 0 1
120874: PPUSH
120875: LD_INT 2
120877: PPUSH
120878: CALL_OW 336
// end ;
120882: GO 120847
120884: POP
120885: POP
// end ;
120886: PPOPN 2
120888: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
120889: LD_EXP 145
120893: PUSH
120894: LD_EXP 198
120898: AND
120899: IFFALSE 121187
120901: GO 120903
120903: DISABLE
120904: LD_INT 0
120906: PPUSH
120907: PPUSH
120908: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
120909: LD_OWVAR 2
120913: PPUSH
120914: LD_INT 9
120916: PPUSH
120917: LD_INT 1
120919: PPUSH
120920: LD_INT 1
120922: PPUSH
120923: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
120927: LD_INT 9
120929: PPUSH
120930: LD_OWVAR 2
120934: PPUSH
120935: CALL_OW 343
// uc_side := 9 ;
120939: LD_ADDR_OWVAR 20
120943: PUSH
120944: LD_INT 9
120946: ST_TO_ADDR
// uc_nation := 2 ;
120947: LD_ADDR_OWVAR 21
120951: PUSH
120952: LD_INT 2
120954: ST_TO_ADDR
// hc_name := Dark Warrior ;
120955: LD_ADDR_OWVAR 26
120959: PUSH
120960: LD_STRING Dark Warrior
120962: ST_TO_ADDR
// hc_gallery :=  ;
120963: LD_ADDR_OWVAR 33
120967: PUSH
120968: LD_STRING 
120970: ST_TO_ADDR
// hc_noskilllimit := true ;
120971: LD_ADDR_OWVAR 76
120975: PUSH
120976: LD_INT 1
120978: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
120979: LD_ADDR_OWVAR 31
120983: PUSH
120984: LD_INT 30
120986: PUSH
120987: LD_INT 30
120989: PUSH
120990: LD_INT 30
120992: PUSH
120993: LD_INT 30
120995: PUSH
120996: EMPTY
120997: LIST
120998: LIST
120999: LIST
121000: LIST
121001: ST_TO_ADDR
// un := CreateHuman ;
121002: LD_ADDR_VAR 0 3
121006: PUSH
121007: CALL_OW 44
121011: ST_TO_ADDR
// hc_noskilllimit := false ;
121012: LD_ADDR_OWVAR 76
121016: PUSH
121017: LD_INT 0
121019: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121020: LD_VAR 0 3
121024: PPUSH
121025: LD_INT 1
121027: PPUSH
121028: CALL_OW 51
// ToLua ( playRanger() ) ;
121032: LD_STRING playRanger()
121034: PPUSH
121035: CALL_OW 559
// p := 0 ;
121039: LD_ADDR_VAR 0 2
121043: PUSH
121044: LD_INT 0
121046: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
121047: LD_INT 35
121049: PPUSH
121050: CALL_OW 67
// p := p + 1 ;
121054: LD_ADDR_VAR 0 2
121058: PUSH
121059: LD_VAR 0 2
121063: PUSH
121064: LD_INT 1
121066: PLUS
121067: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
121068: LD_VAR 0 3
121072: PPUSH
121073: CALL_OW 256
121077: PUSH
121078: LD_INT 1000
121080: LESS
121081: IFFALSE 121095
// SetLives ( un , 1000 ) ;
121083: LD_VAR 0 3
121087: PPUSH
121088: LD_INT 1000
121090: PPUSH
121091: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
121095: LD_VAR 0 3
121099: PPUSH
121100: LD_INT 81
121102: PUSH
121103: LD_OWVAR 2
121107: PUSH
121108: EMPTY
121109: LIST
121110: LIST
121111: PUSH
121112: LD_INT 91
121114: PUSH
121115: LD_VAR 0 3
121119: PUSH
121120: LD_INT 30
121122: PUSH
121123: EMPTY
121124: LIST
121125: LIST
121126: LIST
121127: PUSH
121128: EMPTY
121129: LIST
121130: LIST
121131: PPUSH
121132: CALL_OW 69
121136: PPUSH
121137: LD_VAR 0 3
121141: PPUSH
121142: CALL_OW 74
121146: PPUSH
121147: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
121151: LD_VAR 0 2
121155: PUSH
121156: LD_INT 80
121158: GREATER
121159: PUSH
121160: LD_VAR 0 3
121164: PPUSH
121165: CALL_OW 301
121169: OR
121170: IFFALSE 121047
// if un then
121172: LD_VAR 0 3
121176: IFFALSE 121187
// RemoveUnit ( un ) ;
121178: LD_VAR 0 3
121182: PPUSH
121183: CALL_OW 64
// end ;
121187: PPOPN 3
121189: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
121190: LD_EXP 199
121194: IFFALSE 121310
121196: GO 121198
121198: DISABLE
121199: LD_INT 0
121201: PPUSH
121202: PPUSH
121203: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
121204: LD_ADDR_VAR 0 2
121208: PUSH
121209: LD_INT 81
121211: PUSH
121212: LD_OWVAR 2
121216: PUSH
121217: EMPTY
121218: LIST
121219: LIST
121220: PUSH
121221: LD_INT 21
121223: PUSH
121224: LD_INT 1
121226: PUSH
121227: EMPTY
121228: LIST
121229: LIST
121230: PUSH
121231: EMPTY
121232: LIST
121233: LIST
121234: PPUSH
121235: CALL_OW 69
121239: ST_TO_ADDR
// ToLua ( playComputer() ) ;
121240: LD_STRING playComputer()
121242: PPUSH
121243: CALL_OW 559
// if not tmp then
121247: LD_VAR 0 2
121251: NOT
121252: IFFALSE 121256
// exit ;
121254: GO 121310
// for i in tmp do
121256: LD_ADDR_VAR 0 1
121260: PUSH
121261: LD_VAR 0 2
121265: PUSH
121266: FOR_IN
121267: IFFALSE 121308
// for j := 1 to 4 do
121269: LD_ADDR_VAR 0 3
121273: PUSH
121274: DOUBLE
121275: LD_INT 1
121277: DEC
121278: ST_TO_ADDR
121279: LD_INT 4
121281: PUSH
121282: FOR_TO
121283: IFFALSE 121304
// SetSkill ( i , j , 10 ) ;
121285: LD_VAR 0 1
121289: PPUSH
121290: LD_VAR 0 3
121294: PPUSH
121295: LD_INT 10
121297: PPUSH
121298: CALL_OW 237
121302: GO 121282
121304: POP
121305: POP
121306: GO 121266
121308: POP
121309: POP
// end ;
121310: PPOPN 3
121312: END
// every 0 0$1 trigger s30 do var i , tmp ;
121313: LD_EXP 200
121317: IFFALSE 121386
121319: GO 121321
121321: DISABLE
121322: LD_INT 0
121324: PPUSH
121325: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121326: LD_ADDR_VAR 0 2
121330: PUSH
121331: LD_INT 22
121333: PUSH
121334: LD_OWVAR 2
121338: PUSH
121339: EMPTY
121340: LIST
121341: LIST
121342: PPUSH
121343: CALL_OW 69
121347: ST_TO_ADDR
// if not tmp then
121348: LD_VAR 0 2
121352: NOT
121353: IFFALSE 121357
// exit ;
121355: GO 121386
// for i in tmp do
121357: LD_ADDR_VAR 0 1
121361: PUSH
121362: LD_VAR 0 2
121366: PUSH
121367: FOR_IN
121368: IFFALSE 121384
// SetLives ( i , 300 ) ;
121370: LD_VAR 0 1
121374: PPUSH
121375: LD_INT 300
121377: PPUSH
121378: CALL_OW 234
121382: GO 121367
121384: POP
121385: POP
// end ;
121386: PPOPN 2
121388: END
// every 0 0$1 trigger s60 do var i , tmp ;
121389: LD_EXP 201
121393: IFFALSE 121462
121395: GO 121397
121397: DISABLE
121398: LD_INT 0
121400: PPUSH
121401: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121402: LD_ADDR_VAR 0 2
121406: PUSH
121407: LD_INT 22
121409: PUSH
121410: LD_OWVAR 2
121414: PUSH
121415: EMPTY
121416: LIST
121417: LIST
121418: PPUSH
121419: CALL_OW 69
121423: ST_TO_ADDR
// if not tmp then
121424: LD_VAR 0 2
121428: NOT
121429: IFFALSE 121433
// exit ;
121431: GO 121462
// for i in tmp do
121433: LD_ADDR_VAR 0 1
121437: PUSH
121438: LD_VAR 0 2
121442: PUSH
121443: FOR_IN
121444: IFFALSE 121460
// SetLives ( i , 600 ) ;
121446: LD_VAR 0 1
121450: PPUSH
121451: LD_INT 600
121453: PPUSH
121454: CALL_OW 234
121458: GO 121443
121460: POP
121461: POP
// end ;
121462: PPOPN 2
121464: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
121465: LD_INT 0
121467: PPUSH
// case cmd of 301 :
121468: LD_VAR 0 1
121472: PUSH
121473: LD_INT 301
121475: DOUBLE
121476: EQUAL
121477: IFTRUE 121481
121479: GO 121513
121481: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
121482: LD_VAR 0 6
121486: PPUSH
121487: LD_VAR 0 7
121491: PPUSH
121492: LD_VAR 0 8
121496: PPUSH
121497: LD_VAR 0 4
121501: PPUSH
121502: LD_VAR 0 5
121506: PPUSH
121507: CALL 122714 0 5
121511: GO 121634
121513: LD_INT 302
121515: DOUBLE
121516: EQUAL
121517: IFTRUE 121521
121519: GO 121558
121521: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
121522: LD_VAR 0 6
121526: PPUSH
121527: LD_VAR 0 7
121531: PPUSH
121532: LD_VAR 0 8
121536: PPUSH
121537: LD_VAR 0 9
121541: PPUSH
121542: LD_VAR 0 4
121546: PPUSH
121547: LD_VAR 0 5
121551: PPUSH
121552: CALL 122805 0 6
121556: GO 121634
121558: LD_INT 303
121560: DOUBLE
121561: EQUAL
121562: IFTRUE 121566
121564: GO 121603
121566: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
121567: LD_VAR 0 6
121571: PPUSH
121572: LD_VAR 0 7
121576: PPUSH
121577: LD_VAR 0 8
121581: PPUSH
121582: LD_VAR 0 9
121586: PPUSH
121587: LD_VAR 0 4
121591: PPUSH
121592: LD_VAR 0 5
121596: PPUSH
121597: CALL 121639 0 6
121601: GO 121634
121603: LD_INT 304
121605: DOUBLE
121606: EQUAL
121607: IFTRUE 121611
121609: GO 121633
121611: POP
// hHackTeleport ( unit , x , y ) ; end ;
121612: LD_VAR 0 2
121616: PPUSH
121617: LD_VAR 0 4
121621: PPUSH
121622: LD_VAR 0 5
121626: PPUSH
121627: CALL 123398 0 3
121631: GO 121634
121633: POP
// end ;
121634: LD_VAR 0 12
121638: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
121639: LD_INT 0
121641: PPUSH
121642: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
121643: LD_VAR 0 1
121647: PUSH
121648: LD_INT 1
121650: LESS
121651: PUSH
121652: LD_VAR 0 1
121656: PUSH
121657: LD_INT 3
121659: GREATER
121660: OR
121661: PUSH
121662: LD_VAR 0 5
121666: PPUSH
121667: LD_VAR 0 6
121671: PPUSH
121672: CALL_OW 428
121676: OR
121677: IFFALSE 121681
// exit ;
121679: GO 122401
// uc_side := your_side ;
121681: LD_ADDR_OWVAR 20
121685: PUSH
121686: LD_OWVAR 2
121690: ST_TO_ADDR
// uc_nation := nation ;
121691: LD_ADDR_OWVAR 21
121695: PUSH
121696: LD_VAR 0 1
121700: ST_TO_ADDR
// bc_level = 1 ;
121701: LD_ADDR_OWVAR 43
121705: PUSH
121706: LD_INT 1
121708: ST_TO_ADDR
// case btype of 1 :
121709: LD_VAR 0 2
121713: PUSH
121714: LD_INT 1
121716: DOUBLE
121717: EQUAL
121718: IFTRUE 121722
121720: GO 121733
121722: POP
// bc_type := b_depot ; 2 :
121723: LD_ADDR_OWVAR 42
121727: PUSH
121728: LD_INT 0
121730: ST_TO_ADDR
121731: GO 122345
121733: LD_INT 2
121735: DOUBLE
121736: EQUAL
121737: IFTRUE 121741
121739: GO 121752
121741: POP
// bc_type := b_warehouse ; 3 :
121742: LD_ADDR_OWVAR 42
121746: PUSH
121747: LD_INT 1
121749: ST_TO_ADDR
121750: GO 122345
121752: LD_INT 3
121754: DOUBLE
121755: EQUAL
121756: IFTRUE 121760
121758: GO 121771
121760: POP
// bc_type := b_lab ; 4 .. 9 :
121761: LD_ADDR_OWVAR 42
121765: PUSH
121766: LD_INT 6
121768: ST_TO_ADDR
121769: GO 122345
121771: LD_INT 4
121773: DOUBLE
121774: GREATEREQUAL
121775: IFFALSE 121783
121777: LD_INT 9
121779: DOUBLE
121780: LESSEQUAL
121781: IFTRUE 121785
121783: GO 121837
121785: POP
// begin bc_type := b_lab_half ;
121786: LD_ADDR_OWVAR 42
121790: PUSH
121791: LD_INT 7
121793: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
121794: LD_ADDR_OWVAR 44
121798: PUSH
121799: LD_INT 10
121801: PUSH
121802: LD_INT 11
121804: PUSH
121805: LD_INT 12
121807: PUSH
121808: LD_INT 15
121810: PUSH
121811: LD_INT 14
121813: PUSH
121814: LD_INT 13
121816: PUSH
121817: EMPTY
121818: LIST
121819: LIST
121820: LIST
121821: LIST
121822: LIST
121823: LIST
121824: PUSH
121825: LD_VAR 0 2
121829: PUSH
121830: LD_INT 3
121832: MINUS
121833: ARRAY
121834: ST_TO_ADDR
// end ; 10 .. 13 :
121835: GO 122345
121837: LD_INT 10
121839: DOUBLE
121840: GREATEREQUAL
121841: IFFALSE 121849
121843: LD_INT 13
121845: DOUBLE
121846: LESSEQUAL
121847: IFTRUE 121851
121849: GO 121928
121851: POP
// begin bc_type := b_lab_full ;
121852: LD_ADDR_OWVAR 42
121856: PUSH
121857: LD_INT 8
121859: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
121860: LD_ADDR_OWVAR 44
121864: PUSH
121865: LD_INT 10
121867: PUSH
121868: LD_INT 12
121870: PUSH
121871: LD_INT 14
121873: PUSH
121874: LD_INT 13
121876: PUSH
121877: EMPTY
121878: LIST
121879: LIST
121880: LIST
121881: LIST
121882: PUSH
121883: LD_VAR 0 2
121887: PUSH
121888: LD_INT 9
121890: MINUS
121891: ARRAY
121892: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
121893: LD_ADDR_OWVAR 45
121897: PUSH
121898: LD_INT 11
121900: PUSH
121901: LD_INT 15
121903: PUSH
121904: LD_INT 12
121906: PUSH
121907: LD_INT 15
121909: PUSH
121910: EMPTY
121911: LIST
121912: LIST
121913: LIST
121914: LIST
121915: PUSH
121916: LD_VAR 0 2
121920: PUSH
121921: LD_INT 9
121923: MINUS
121924: ARRAY
121925: ST_TO_ADDR
// end ; 14 :
121926: GO 122345
121928: LD_INT 14
121930: DOUBLE
121931: EQUAL
121932: IFTRUE 121936
121934: GO 121947
121936: POP
// bc_type := b_workshop ; 15 :
121937: LD_ADDR_OWVAR 42
121941: PUSH
121942: LD_INT 2
121944: ST_TO_ADDR
121945: GO 122345
121947: LD_INT 15
121949: DOUBLE
121950: EQUAL
121951: IFTRUE 121955
121953: GO 121966
121955: POP
// bc_type := b_factory ; 16 :
121956: LD_ADDR_OWVAR 42
121960: PUSH
121961: LD_INT 3
121963: ST_TO_ADDR
121964: GO 122345
121966: LD_INT 16
121968: DOUBLE
121969: EQUAL
121970: IFTRUE 121974
121972: GO 121985
121974: POP
// bc_type := b_ext_gun ; 17 :
121975: LD_ADDR_OWVAR 42
121979: PUSH
121980: LD_INT 17
121982: ST_TO_ADDR
121983: GO 122345
121985: LD_INT 17
121987: DOUBLE
121988: EQUAL
121989: IFTRUE 121993
121991: GO 122021
121993: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
121994: LD_ADDR_OWVAR 42
121998: PUSH
121999: LD_INT 19
122001: PUSH
122002: LD_INT 23
122004: PUSH
122005: LD_INT 19
122007: PUSH
122008: EMPTY
122009: LIST
122010: LIST
122011: LIST
122012: PUSH
122013: LD_VAR 0 1
122017: ARRAY
122018: ST_TO_ADDR
122019: GO 122345
122021: LD_INT 18
122023: DOUBLE
122024: EQUAL
122025: IFTRUE 122029
122027: GO 122040
122029: POP
// bc_type := b_ext_radar ; 19 :
122030: LD_ADDR_OWVAR 42
122034: PUSH
122035: LD_INT 20
122037: ST_TO_ADDR
122038: GO 122345
122040: LD_INT 19
122042: DOUBLE
122043: EQUAL
122044: IFTRUE 122048
122046: GO 122059
122048: POP
// bc_type := b_ext_radio ; 20 :
122049: LD_ADDR_OWVAR 42
122053: PUSH
122054: LD_INT 22
122056: ST_TO_ADDR
122057: GO 122345
122059: LD_INT 20
122061: DOUBLE
122062: EQUAL
122063: IFTRUE 122067
122065: GO 122078
122067: POP
// bc_type := b_ext_siberium ; 21 :
122068: LD_ADDR_OWVAR 42
122072: PUSH
122073: LD_INT 21
122075: ST_TO_ADDR
122076: GO 122345
122078: LD_INT 21
122080: DOUBLE
122081: EQUAL
122082: IFTRUE 122086
122084: GO 122097
122086: POP
// bc_type := b_ext_computer ; 22 :
122087: LD_ADDR_OWVAR 42
122091: PUSH
122092: LD_INT 24
122094: ST_TO_ADDR
122095: GO 122345
122097: LD_INT 22
122099: DOUBLE
122100: EQUAL
122101: IFTRUE 122105
122103: GO 122116
122105: POP
// bc_type := b_ext_track ; 23 :
122106: LD_ADDR_OWVAR 42
122110: PUSH
122111: LD_INT 16
122113: ST_TO_ADDR
122114: GO 122345
122116: LD_INT 23
122118: DOUBLE
122119: EQUAL
122120: IFTRUE 122124
122122: GO 122135
122124: POP
// bc_type := b_ext_laser ; 24 :
122125: LD_ADDR_OWVAR 42
122129: PUSH
122130: LD_INT 25
122132: ST_TO_ADDR
122133: GO 122345
122135: LD_INT 24
122137: DOUBLE
122138: EQUAL
122139: IFTRUE 122143
122141: GO 122154
122143: POP
// bc_type := b_control_tower ; 25 :
122144: LD_ADDR_OWVAR 42
122148: PUSH
122149: LD_INT 36
122151: ST_TO_ADDR
122152: GO 122345
122154: LD_INT 25
122156: DOUBLE
122157: EQUAL
122158: IFTRUE 122162
122160: GO 122173
122162: POP
// bc_type := b_breastwork ; 26 :
122163: LD_ADDR_OWVAR 42
122167: PUSH
122168: LD_INT 31
122170: ST_TO_ADDR
122171: GO 122345
122173: LD_INT 26
122175: DOUBLE
122176: EQUAL
122177: IFTRUE 122181
122179: GO 122192
122181: POP
// bc_type := b_bunker ; 27 :
122182: LD_ADDR_OWVAR 42
122186: PUSH
122187: LD_INT 32
122189: ST_TO_ADDR
122190: GO 122345
122192: LD_INT 27
122194: DOUBLE
122195: EQUAL
122196: IFTRUE 122200
122198: GO 122211
122200: POP
// bc_type := b_turret ; 28 :
122201: LD_ADDR_OWVAR 42
122205: PUSH
122206: LD_INT 33
122208: ST_TO_ADDR
122209: GO 122345
122211: LD_INT 28
122213: DOUBLE
122214: EQUAL
122215: IFTRUE 122219
122217: GO 122230
122219: POP
// bc_type := b_armoury ; 29 :
122220: LD_ADDR_OWVAR 42
122224: PUSH
122225: LD_INT 4
122227: ST_TO_ADDR
122228: GO 122345
122230: LD_INT 29
122232: DOUBLE
122233: EQUAL
122234: IFTRUE 122238
122236: GO 122249
122238: POP
// bc_type := b_barracks ; 30 :
122239: LD_ADDR_OWVAR 42
122243: PUSH
122244: LD_INT 5
122246: ST_TO_ADDR
122247: GO 122345
122249: LD_INT 30
122251: DOUBLE
122252: EQUAL
122253: IFTRUE 122257
122255: GO 122268
122257: POP
// bc_type := b_solar_power ; 31 :
122258: LD_ADDR_OWVAR 42
122262: PUSH
122263: LD_INT 27
122265: ST_TO_ADDR
122266: GO 122345
122268: LD_INT 31
122270: DOUBLE
122271: EQUAL
122272: IFTRUE 122276
122274: GO 122287
122276: POP
// bc_type := b_oil_power ; 32 :
122277: LD_ADDR_OWVAR 42
122281: PUSH
122282: LD_INT 26
122284: ST_TO_ADDR
122285: GO 122345
122287: LD_INT 32
122289: DOUBLE
122290: EQUAL
122291: IFTRUE 122295
122293: GO 122306
122295: POP
// bc_type := b_siberite_power ; 33 :
122296: LD_ADDR_OWVAR 42
122300: PUSH
122301: LD_INT 28
122303: ST_TO_ADDR
122304: GO 122345
122306: LD_INT 33
122308: DOUBLE
122309: EQUAL
122310: IFTRUE 122314
122312: GO 122325
122314: POP
// bc_type := b_oil_mine ; 34 :
122315: LD_ADDR_OWVAR 42
122319: PUSH
122320: LD_INT 29
122322: ST_TO_ADDR
122323: GO 122345
122325: LD_INT 34
122327: DOUBLE
122328: EQUAL
122329: IFTRUE 122333
122331: GO 122344
122333: POP
// bc_type := b_siberite_mine ; end ;
122334: LD_ADDR_OWVAR 42
122338: PUSH
122339: LD_INT 30
122341: ST_TO_ADDR
122342: GO 122345
122344: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
122345: LD_ADDR_VAR 0 8
122349: PUSH
122350: LD_VAR 0 5
122354: PPUSH
122355: LD_VAR 0 6
122359: PPUSH
122360: LD_VAR 0 3
122364: PPUSH
122365: CALL_OW 47
122369: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
122370: LD_OWVAR 42
122374: PUSH
122375: LD_INT 32
122377: PUSH
122378: LD_INT 33
122380: PUSH
122381: EMPTY
122382: LIST
122383: LIST
122384: IN
122385: IFFALSE 122401
// PlaceWeaponTurret ( b , weapon ) ;
122387: LD_VAR 0 8
122391: PPUSH
122392: LD_VAR 0 4
122396: PPUSH
122397: CALL_OW 431
// end ;
122401: LD_VAR 0 7
122405: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
122406: LD_INT 0
122408: PPUSH
122409: PPUSH
122410: PPUSH
122411: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122412: LD_ADDR_VAR 0 4
122416: PUSH
122417: LD_INT 22
122419: PUSH
122420: LD_OWVAR 2
122424: PUSH
122425: EMPTY
122426: LIST
122427: LIST
122428: PUSH
122429: LD_INT 2
122431: PUSH
122432: LD_INT 30
122434: PUSH
122435: LD_INT 0
122437: PUSH
122438: EMPTY
122439: LIST
122440: LIST
122441: PUSH
122442: LD_INT 30
122444: PUSH
122445: LD_INT 1
122447: PUSH
122448: EMPTY
122449: LIST
122450: LIST
122451: PUSH
122452: EMPTY
122453: LIST
122454: LIST
122455: LIST
122456: PUSH
122457: EMPTY
122458: LIST
122459: LIST
122460: PPUSH
122461: CALL_OW 69
122465: ST_TO_ADDR
// if not tmp then
122466: LD_VAR 0 4
122470: NOT
122471: IFFALSE 122475
// exit ;
122473: GO 122534
// for i in tmp do
122475: LD_ADDR_VAR 0 2
122479: PUSH
122480: LD_VAR 0 4
122484: PUSH
122485: FOR_IN
122486: IFFALSE 122532
// for j = 1 to 3 do
122488: LD_ADDR_VAR 0 3
122492: PUSH
122493: DOUBLE
122494: LD_INT 1
122496: DEC
122497: ST_TO_ADDR
122498: LD_INT 3
122500: PUSH
122501: FOR_TO
122502: IFFALSE 122528
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
122504: LD_VAR 0 2
122508: PPUSH
122509: CALL_OW 274
122513: PPUSH
122514: LD_VAR 0 3
122518: PPUSH
122519: LD_INT 99999
122521: PPUSH
122522: CALL_OW 277
122526: GO 122501
122528: POP
122529: POP
122530: GO 122485
122532: POP
122533: POP
// end ;
122534: LD_VAR 0 1
122538: RET
// export function hHackSetLevel10 ; var i , j ; begin
122539: LD_INT 0
122541: PPUSH
122542: PPUSH
122543: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122544: LD_ADDR_VAR 0 2
122548: PUSH
122549: LD_INT 21
122551: PUSH
122552: LD_INT 1
122554: PUSH
122555: EMPTY
122556: LIST
122557: LIST
122558: PPUSH
122559: CALL_OW 69
122563: PUSH
122564: FOR_IN
122565: IFFALSE 122617
// if IsSelected ( i ) then
122567: LD_VAR 0 2
122571: PPUSH
122572: CALL_OW 306
122576: IFFALSE 122615
// begin for j := 1 to 4 do
122578: LD_ADDR_VAR 0 3
122582: PUSH
122583: DOUBLE
122584: LD_INT 1
122586: DEC
122587: ST_TO_ADDR
122588: LD_INT 4
122590: PUSH
122591: FOR_TO
122592: IFFALSE 122613
// SetSkill ( i , j , 10 ) ;
122594: LD_VAR 0 2
122598: PPUSH
122599: LD_VAR 0 3
122603: PPUSH
122604: LD_INT 10
122606: PPUSH
122607: CALL_OW 237
122611: GO 122591
122613: POP
122614: POP
// end ;
122615: GO 122564
122617: POP
122618: POP
// end ;
122619: LD_VAR 0 1
122623: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
122624: LD_INT 0
122626: PPUSH
122627: PPUSH
122628: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
122629: LD_ADDR_VAR 0 2
122633: PUSH
122634: LD_INT 22
122636: PUSH
122637: LD_OWVAR 2
122641: PUSH
122642: EMPTY
122643: LIST
122644: LIST
122645: PUSH
122646: LD_INT 21
122648: PUSH
122649: LD_INT 1
122651: PUSH
122652: EMPTY
122653: LIST
122654: LIST
122655: PUSH
122656: EMPTY
122657: LIST
122658: LIST
122659: PPUSH
122660: CALL_OW 69
122664: PUSH
122665: FOR_IN
122666: IFFALSE 122707
// begin for j := 1 to 4 do
122668: LD_ADDR_VAR 0 3
122672: PUSH
122673: DOUBLE
122674: LD_INT 1
122676: DEC
122677: ST_TO_ADDR
122678: LD_INT 4
122680: PUSH
122681: FOR_TO
122682: IFFALSE 122703
// SetSkill ( i , j , 10 ) ;
122684: LD_VAR 0 2
122688: PPUSH
122689: LD_VAR 0 3
122693: PPUSH
122694: LD_INT 10
122696: PPUSH
122697: CALL_OW 237
122701: GO 122681
122703: POP
122704: POP
// end ;
122705: GO 122665
122707: POP
122708: POP
// end ;
122709: LD_VAR 0 1
122713: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
122714: LD_INT 0
122716: PPUSH
// uc_side := your_side ;
122717: LD_ADDR_OWVAR 20
122721: PUSH
122722: LD_OWVAR 2
122726: ST_TO_ADDR
// uc_nation := nation ;
122727: LD_ADDR_OWVAR 21
122731: PUSH
122732: LD_VAR 0 1
122736: ST_TO_ADDR
// InitHc ;
122737: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
122741: LD_INT 0
122743: PPUSH
122744: LD_VAR 0 2
122748: PPUSH
122749: LD_VAR 0 3
122753: PPUSH
122754: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
122758: LD_VAR 0 4
122762: PPUSH
122763: LD_VAR 0 5
122767: PPUSH
122768: CALL_OW 428
122772: PUSH
122773: LD_INT 0
122775: EQUAL
122776: IFFALSE 122800
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
122778: CALL_OW 44
122782: PPUSH
122783: LD_VAR 0 4
122787: PPUSH
122788: LD_VAR 0 5
122792: PPUSH
122793: LD_INT 1
122795: PPUSH
122796: CALL_OW 48
// end ;
122800: LD_VAR 0 6
122804: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
122805: LD_INT 0
122807: PPUSH
122808: PPUSH
// uc_side := your_side ;
122809: LD_ADDR_OWVAR 20
122813: PUSH
122814: LD_OWVAR 2
122818: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
122819: LD_VAR 0 1
122823: PUSH
122824: LD_INT 1
122826: PUSH
122827: LD_INT 2
122829: PUSH
122830: LD_INT 3
122832: PUSH
122833: LD_INT 4
122835: PUSH
122836: LD_INT 5
122838: PUSH
122839: EMPTY
122840: LIST
122841: LIST
122842: LIST
122843: LIST
122844: LIST
122845: IN
122846: IFFALSE 122858
// uc_nation := nation_american else
122848: LD_ADDR_OWVAR 21
122852: PUSH
122853: LD_INT 1
122855: ST_TO_ADDR
122856: GO 122901
// if chassis in [ 11 , 12 , 13 , 14 ] then
122858: LD_VAR 0 1
122862: PUSH
122863: LD_INT 11
122865: PUSH
122866: LD_INT 12
122868: PUSH
122869: LD_INT 13
122871: PUSH
122872: LD_INT 14
122874: PUSH
122875: EMPTY
122876: LIST
122877: LIST
122878: LIST
122879: LIST
122880: IN
122881: IFFALSE 122893
// uc_nation := nation_arabian else
122883: LD_ADDR_OWVAR 21
122887: PUSH
122888: LD_INT 2
122890: ST_TO_ADDR
122891: GO 122901
// uc_nation := nation_russian ;
122893: LD_ADDR_OWVAR 21
122897: PUSH
122898: LD_INT 3
122900: ST_TO_ADDR
// vc_chassis := chassis ;
122901: LD_ADDR_OWVAR 37
122905: PUSH
122906: LD_VAR 0 1
122910: ST_TO_ADDR
// vc_engine := engine ;
122911: LD_ADDR_OWVAR 39
122915: PUSH
122916: LD_VAR 0 2
122920: ST_TO_ADDR
// vc_control := control ;
122921: LD_ADDR_OWVAR 38
122925: PUSH
122926: LD_VAR 0 3
122930: ST_TO_ADDR
// vc_weapon := weapon ;
122931: LD_ADDR_OWVAR 40
122935: PUSH
122936: LD_VAR 0 4
122940: ST_TO_ADDR
// un := CreateVehicle ;
122941: LD_ADDR_VAR 0 8
122945: PUSH
122946: CALL_OW 45
122950: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
122951: LD_VAR 0 8
122955: PPUSH
122956: LD_INT 0
122958: PPUSH
122959: LD_INT 5
122961: PPUSH
122962: CALL_OW 12
122966: PPUSH
122967: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
122971: LD_VAR 0 8
122975: PPUSH
122976: LD_VAR 0 5
122980: PPUSH
122981: LD_VAR 0 6
122985: PPUSH
122986: LD_INT 1
122988: PPUSH
122989: CALL_OW 48
// end ;
122993: LD_VAR 0 7
122997: RET
// export hInvincible ; every 1 do
122998: GO 123000
123000: DISABLE
// hInvincible := [ ] ;
123001: LD_ADDR_EXP 202
123005: PUSH
123006: EMPTY
123007: ST_TO_ADDR
123008: END
// every 10 do var i ;
123009: GO 123011
123011: DISABLE
123012: LD_INT 0
123014: PPUSH
// begin enable ;
123015: ENABLE
// if not hInvincible then
123016: LD_EXP 202
123020: NOT
123021: IFFALSE 123025
// exit ;
123023: GO 123069
// for i in hInvincible do
123025: LD_ADDR_VAR 0 1
123029: PUSH
123030: LD_EXP 202
123034: PUSH
123035: FOR_IN
123036: IFFALSE 123067
// if GetLives ( i ) < 1000 then
123038: LD_VAR 0 1
123042: PPUSH
123043: CALL_OW 256
123047: PUSH
123048: LD_INT 1000
123050: LESS
123051: IFFALSE 123065
// SetLives ( i , 1000 ) ;
123053: LD_VAR 0 1
123057: PPUSH
123058: LD_INT 1000
123060: PPUSH
123061: CALL_OW 234
123065: GO 123035
123067: POP
123068: POP
// end ;
123069: PPOPN 1
123071: END
// export function hHackInvincible ; var i ; begin
123072: LD_INT 0
123074: PPUSH
123075: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
123076: LD_ADDR_VAR 0 2
123080: PUSH
123081: LD_INT 2
123083: PUSH
123084: LD_INT 21
123086: PUSH
123087: LD_INT 1
123089: PUSH
123090: EMPTY
123091: LIST
123092: LIST
123093: PUSH
123094: LD_INT 21
123096: PUSH
123097: LD_INT 2
123099: PUSH
123100: EMPTY
123101: LIST
123102: LIST
123103: PUSH
123104: EMPTY
123105: LIST
123106: LIST
123107: LIST
123108: PPUSH
123109: CALL_OW 69
123113: PUSH
123114: FOR_IN
123115: IFFALSE 123176
// if IsSelected ( i ) then
123117: LD_VAR 0 2
123121: PPUSH
123122: CALL_OW 306
123126: IFFALSE 123174
// begin if i in hInvincible then
123128: LD_VAR 0 2
123132: PUSH
123133: LD_EXP 202
123137: IN
123138: IFFALSE 123158
// hInvincible := hInvincible diff i else
123140: LD_ADDR_EXP 202
123144: PUSH
123145: LD_EXP 202
123149: PUSH
123150: LD_VAR 0 2
123154: DIFF
123155: ST_TO_ADDR
123156: GO 123174
// hInvincible := hInvincible union i ;
123158: LD_ADDR_EXP 202
123162: PUSH
123163: LD_EXP 202
123167: PUSH
123168: LD_VAR 0 2
123172: UNION
123173: ST_TO_ADDR
// end ;
123174: GO 123114
123176: POP
123177: POP
// end ;
123178: LD_VAR 0 1
123182: RET
// export function hHackInvisible ; var i , j ; begin
123183: LD_INT 0
123185: PPUSH
123186: PPUSH
123187: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
123188: LD_ADDR_VAR 0 2
123192: PUSH
123193: LD_INT 21
123195: PUSH
123196: LD_INT 1
123198: PUSH
123199: EMPTY
123200: LIST
123201: LIST
123202: PPUSH
123203: CALL_OW 69
123207: PUSH
123208: FOR_IN
123209: IFFALSE 123233
// if IsSelected ( i ) then
123211: LD_VAR 0 2
123215: PPUSH
123216: CALL_OW 306
123220: IFFALSE 123231
// ComForceInvisible ( i ) ;
123222: LD_VAR 0 2
123226: PPUSH
123227: CALL_OW 496
123231: GO 123208
123233: POP
123234: POP
// end ;
123235: LD_VAR 0 1
123239: RET
// export function hHackChangeYourSide ; begin
123240: LD_INT 0
123242: PPUSH
// if your_side = 8 then
123243: LD_OWVAR 2
123247: PUSH
123248: LD_INT 8
123250: EQUAL
123251: IFFALSE 123263
// your_side := 0 else
123253: LD_ADDR_OWVAR 2
123257: PUSH
123258: LD_INT 0
123260: ST_TO_ADDR
123261: GO 123277
// your_side := your_side + 1 ;
123263: LD_ADDR_OWVAR 2
123267: PUSH
123268: LD_OWVAR 2
123272: PUSH
123273: LD_INT 1
123275: PLUS
123276: ST_TO_ADDR
// end ;
123277: LD_VAR 0 1
123281: RET
// export function hHackChangeUnitSide ; var i , j ; begin
123282: LD_INT 0
123284: PPUSH
123285: PPUSH
123286: PPUSH
// for i in all_units do
123287: LD_ADDR_VAR 0 2
123291: PUSH
123292: LD_OWVAR 3
123296: PUSH
123297: FOR_IN
123298: IFFALSE 123376
// if IsSelected ( i ) then
123300: LD_VAR 0 2
123304: PPUSH
123305: CALL_OW 306
123309: IFFALSE 123374
// begin j := GetSide ( i ) ;
123311: LD_ADDR_VAR 0 3
123315: PUSH
123316: LD_VAR 0 2
123320: PPUSH
123321: CALL_OW 255
123325: ST_TO_ADDR
// if j = 8 then
123326: LD_VAR 0 3
123330: PUSH
123331: LD_INT 8
123333: EQUAL
123334: IFFALSE 123346
// j := 0 else
123336: LD_ADDR_VAR 0 3
123340: PUSH
123341: LD_INT 0
123343: ST_TO_ADDR
123344: GO 123360
// j := j + 1 ;
123346: LD_ADDR_VAR 0 3
123350: PUSH
123351: LD_VAR 0 3
123355: PUSH
123356: LD_INT 1
123358: PLUS
123359: ST_TO_ADDR
// SetSide ( i , j ) ;
123360: LD_VAR 0 2
123364: PPUSH
123365: LD_VAR 0 3
123369: PPUSH
123370: CALL_OW 235
// end ;
123374: GO 123297
123376: POP
123377: POP
// end ;
123378: LD_VAR 0 1
123382: RET
// export function hHackFog ; begin
123383: LD_INT 0
123385: PPUSH
// FogOff ( true ) ;
123386: LD_INT 1
123388: PPUSH
123389: CALL_OW 344
// end ;
123393: LD_VAR 0 1
123397: RET
// export function hHackTeleport ( unit , x , y ) ; begin
123398: LD_INT 0
123400: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
123401: LD_VAR 0 1
123405: PPUSH
123406: LD_VAR 0 2
123410: PPUSH
123411: LD_VAR 0 3
123415: PPUSH
123416: LD_INT 1
123418: PPUSH
123419: LD_INT 1
123421: PPUSH
123422: CALL_OW 483
// CenterOnXY ( x , y ) ;
123426: LD_VAR 0 2
123430: PPUSH
123431: LD_VAR 0 3
123435: PPUSH
123436: CALL_OW 84
// end ;
123440: LD_VAR 0 4
123444: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
123445: LD_INT 0
123447: PPUSH
123448: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
123449: LD_VAR 0 1
123453: NOT
123454: PUSH
123455: LD_VAR 0 2
123459: PPUSH
123460: LD_VAR 0 3
123464: PPUSH
123465: CALL_OW 488
123469: NOT
123470: OR
123471: PUSH
123472: LD_VAR 0 1
123476: PPUSH
123477: CALL_OW 266
123481: PUSH
123482: LD_INT 3
123484: NONEQUAL
123485: PUSH
123486: LD_VAR 0 1
123490: PPUSH
123491: CALL_OW 247
123495: PUSH
123496: LD_INT 1
123498: EQUAL
123499: NOT
123500: AND
123501: OR
123502: IFFALSE 123506
// exit ;
123504: GO 123655
// if GetType ( factory ) = unit_human then
123506: LD_VAR 0 1
123510: PPUSH
123511: CALL_OW 247
123515: PUSH
123516: LD_INT 1
123518: EQUAL
123519: IFFALSE 123536
// factory := IsInUnit ( factory ) ;
123521: LD_ADDR_VAR 0 1
123525: PUSH
123526: LD_VAR 0 1
123530: PPUSH
123531: CALL_OW 310
123535: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
123536: LD_VAR 0 1
123540: PPUSH
123541: CALL_OW 266
123545: PUSH
123546: LD_INT 3
123548: NONEQUAL
123549: IFFALSE 123553
// exit ;
123551: GO 123655
// if HexInfo ( x , y ) = factory then
123553: LD_VAR 0 2
123557: PPUSH
123558: LD_VAR 0 3
123562: PPUSH
123563: CALL_OW 428
123567: PUSH
123568: LD_VAR 0 1
123572: EQUAL
123573: IFFALSE 123600
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
123575: LD_ADDR_EXP 203
123579: PUSH
123580: LD_EXP 203
123584: PPUSH
123585: LD_VAR 0 1
123589: PPUSH
123590: LD_INT 0
123592: PPUSH
123593: CALL_OW 1
123597: ST_TO_ADDR
123598: GO 123651
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
123600: LD_ADDR_EXP 203
123604: PUSH
123605: LD_EXP 203
123609: PPUSH
123610: LD_VAR 0 1
123614: PPUSH
123615: LD_VAR 0 1
123619: PPUSH
123620: CALL_OW 255
123624: PUSH
123625: LD_VAR 0 1
123629: PUSH
123630: LD_VAR 0 2
123634: PUSH
123635: LD_VAR 0 3
123639: PUSH
123640: EMPTY
123641: LIST
123642: LIST
123643: LIST
123644: LIST
123645: PPUSH
123646: CALL_OW 1
123650: ST_TO_ADDR
// UpdateFactoryWaypoints ;
123651: CALL 123660 0 0
// end ;
123655: LD_VAR 0 4
123659: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
123660: LD_INT 0
123662: PPUSH
123663: PPUSH
123664: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
123665: LD_STRING resetFactoryWaypoint();
123667: PPUSH
123668: CALL_OW 559
// if factoryWaypoints then
123672: LD_EXP 203
123676: IFFALSE 123802
// begin list := PrepareArray ( factoryWaypoints ) ;
123678: LD_ADDR_VAR 0 3
123682: PUSH
123683: LD_EXP 203
123687: PPUSH
123688: CALL 108762 0 1
123692: ST_TO_ADDR
// for i := 1 to list do
123693: LD_ADDR_VAR 0 2
123697: PUSH
123698: DOUBLE
123699: LD_INT 1
123701: DEC
123702: ST_TO_ADDR
123703: LD_VAR 0 3
123707: PUSH
123708: FOR_TO
123709: IFFALSE 123800
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123711: LD_STRING setFactoryWaypointXY(
123713: PUSH
123714: LD_VAR 0 3
123718: PUSH
123719: LD_VAR 0 2
123723: ARRAY
123724: PUSH
123725: LD_INT 1
123727: ARRAY
123728: STR
123729: PUSH
123730: LD_STRING ,
123732: STR
123733: PUSH
123734: LD_VAR 0 3
123738: PUSH
123739: LD_VAR 0 2
123743: ARRAY
123744: PUSH
123745: LD_INT 2
123747: ARRAY
123748: STR
123749: PUSH
123750: LD_STRING ,
123752: STR
123753: PUSH
123754: LD_VAR 0 3
123758: PUSH
123759: LD_VAR 0 2
123763: ARRAY
123764: PUSH
123765: LD_INT 3
123767: ARRAY
123768: STR
123769: PUSH
123770: LD_STRING ,
123772: STR
123773: PUSH
123774: LD_VAR 0 3
123778: PUSH
123779: LD_VAR 0 2
123783: ARRAY
123784: PUSH
123785: LD_INT 4
123787: ARRAY
123788: STR
123789: PUSH
123790: LD_STRING )
123792: STR
123793: PPUSH
123794: CALL_OW 559
123798: GO 123708
123800: POP
123801: POP
// end ; end ;
123802: LD_VAR 0 1
123806: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
123807: LD_INT 0
123809: PPUSH
// if HexInfo ( x , y ) = warehouse then
123810: LD_VAR 0 2
123814: PPUSH
123815: LD_VAR 0 3
123819: PPUSH
123820: CALL_OW 428
123824: PUSH
123825: LD_VAR 0 1
123829: EQUAL
123830: IFFALSE 123857
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
123832: LD_ADDR_EXP 204
123836: PUSH
123837: LD_EXP 204
123841: PPUSH
123842: LD_VAR 0 1
123846: PPUSH
123847: LD_INT 0
123849: PPUSH
123850: CALL_OW 1
123854: ST_TO_ADDR
123855: GO 123908
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
123857: LD_ADDR_EXP 204
123861: PUSH
123862: LD_EXP 204
123866: PPUSH
123867: LD_VAR 0 1
123871: PPUSH
123872: LD_VAR 0 1
123876: PPUSH
123877: CALL_OW 255
123881: PUSH
123882: LD_VAR 0 1
123886: PUSH
123887: LD_VAR 0 2
123891: PUSH
123892: LD_VAR 0 3
123896: PUSH
123897: EMPTY
123898: LIST
123899: LIST
123900: LIST
123901: LIST
123902: PPUSH
123903: CALL_OW 1
123907: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
123908: CALL 123917 0 0
// end ;
123912: LD_VAR 0 4
123916: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
123917: LD_INT 0
123919: PPUSH
123920: PPUSH
123921: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
123922: LD_STRING resetWarehouseGatheringPoints();
123924: PPUSH
123925: CALL_OW 559
// if warehouseGatheringPoints then
123929: LD_EXP 204
123933: IFFALSE 124059
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
123935: LD_ADDR_VAR 0 3
123939: PUSH
123940: LD_EXP 204
123944: PPUSH
123945: CALL 108762 0 1
123949: ST_TO_ADDR
// for i := 1 to list do
123950: LD_ADDR_VAR 0 2
123954: PUSH
123955: DOUBLE
123956: LD_INT 1
123958: DEC
123959: ST_TO_ADDR
123960: LD_VAR 0 3
123964: PUSH
123965: FOR_TO
123966: IFFALSE 124057
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123968: LD_STRING setWarehouseGatheringPointXY(
123970: PUSH
123971: LD_VAR 0 3
123975: PUSH
123976: LD_VAR 0 2
123980: ARRAY
123981: PUSH
123982: LD_INT 1
123984: ARRAY
123985: STR
123986: PUSH
123987: LD_STRING ,
123989: STR
123990: PUSH
123991: LD_VAR 0 3
123995: PUSH
123996: LD_VAR 0 2
124000: ARRAY
124001: PUSH
124002: LD_INT 2
124004: ARRAY
124005: STR
124006: PUSH
124007: LD_STRING ,
124009: STR
124010: PUSH
124011: LD_VAR 0 3
124015: PUSH
124016: LD_VAR 0 2
124020: ARRAY
124021: PUSH
124022: LD_INT 3
124024: ARRAY
124025: STR
124026: PUSH
124027: LD_STRING ,
124029: STR
124030: PUSH
124031: LD_VAR 0 3
124035: PUSH
124036: LD_VAR 0 2
124040: ARRAY
124041: PUSH
124042: LD_INT 4
124044: ARRAY
124045: STR
124046: PUSH
124047: LD_STRING )
124049: STR
124050: PPUSH
124051: CALL_OW 559
124055: GO 123965
124057: POP
124058: POP
// end ; end ;
124059: LD_VAR 0 1
124063: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
124064: LD_EXP 204
124068: IFFALSE 124753
124070: GO 124072
124072: DISABLE
124073: LD_INT 0
124075: PPUSH
124076: PPUSH
124077: PPUSH
124078: PPUSH
124079: PPUSH
124080: PPUSH
124081: PPUSH
124082: PPUSH
124083: PPUSH
// begin enable ;
124084: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
124085: LD_ADDR_VAR 0 3
124089: PUSH
124090: LD_EXP 204
124094: PPUSH
124095: CALL 108762 0 1
124099: ST_TO_ADDR
// if not list then
124100: LD_VAR 0 3
124104: NOT
124105: IFFALSE 124109
// exit ;
124107: GO 124753
// for i := 1 to list do
124109: LD_ADDR_VAR 0 1
124113: PUSH
124114: DOUBLE
124115: LD_INT 1
124117: DEC
124118: ST_TO_ADDR
124119: LD_VAR 0 3
124123: PUSH
124124: FOR_TO
124125: IFFALSE 124751
// begin depot := list [ i ] [ 2 ] ;
124127: LD_ADDR_VAR 0 8
124131: PUSH
124132: LD_VAR 0 3
124136: PUSH
124137: LD_VAR 0 1
124141: ARRAY
124142: PUSH
124143: LD_INT 2
124145: ARRAY
124146: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
124147: LD_ADDR_VAR 0 5
124151: PUSH
124152: LD_VAR 0 3
124156: PUSH
124157: LD_VAR 0 1
124161: ARRAY
124162: PUSH
124163: LD_INT 1
124165: ARRAY
124166: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
124167: LD_VAR 0 8
124171: PPUSH
124172: CALL_OW 301
124176: PUSH
124177: LD_VAR 0 5
124181: PUSH
124182: LD_VAR 0 8
124186: PPUSH
124187: CALL_OW 255
124191: NONEQUAL
124192: OR
124193: IFFALSE 124222
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
124195: LD_ADDR_EXP 204
124199: PUSH
124200: LD_EXP 204
124204: PPUSH
124205: LD_VAR 0 8
124209: PPUSH
124210: LD_INT 0
124212: PPUSH
124213: CALL_OW 1
124217: ST_TO_ADDR
// exit ;
124218: POP
124219: POP
124220: GO 124753
// end ; x := list [ i ] [ 3 ] ;
124222: LD_ADDR_VAR 0 6
124226: PUSH
124227: LD_VAR 0 3
124231: PUSH
124232: LD_VAR 0 1
124236: ARRAY
124237: PUSH
124238: LD_INT 3
124240: ARRAY
124241: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
124242: LD_ADDR_VAR 0 7
124246: PUSH
124247: LD_VAR 0 3
124251: PUSH
124252: LD_VAR 0 1
124256: ARRAY
124257: PUSH
124258: LD_INT 4
124260: ARRAY
124261: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
124262: LD_ADDR_VAR 0 9
124266: PUSH
124267: LD_VAR 0 6
124271: PPUSH
124272: LD_VAR 0 7
124276: PPUSH
124277: LD_INT 16
124279: PPUSH
124280: CALL 107350 0 3
124284: ST_TO_ADDR
// if not cratesNearbyPoint then
124285: LD_VAR 0 9
124289: NOT
124290: IFFALSE 124296
// exit ;
124292: POP
124293: POP
124294: GO 124753
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
124296: LD_ADDR_VAR 0 4
124300: PUSH
124301: LD_INT 22
124303: PUSH
124304: LD_VAR 0 5
124308: PUSH
124309: EMPTY
124310: LIST
124311: LIST
124312: PUSH
124313: LD_INT 3
124315: PUSH
124316: LD_INT 60
124318: PUSH
124319: EMPTY
124320: LIST
124321: PUSH
124322: EMPTY
124323: LIST
124324: LIST
124325: PUSH
124326: LD_INT 91
124328: PUSH
124329: LD_VAR 0 8
124333: PUSH
124334: LD_INT 6
124336: PUSH
124337: EMPTY
124338: LIST
124339: LIST
124340: LIST
124341: PUSH
124342: LD_INT 2
124344: PUSH
124345: LD_INT 25
124347: PUSH
124348: LD_INT 2
124350: PUSH
124351: EMPTY
124352: LIST
124353: LIST
124354: PUSH
124355: LD_INT 25
124357: PUSH
124358: LD_INT 16
124360: PUSH
124361: EMPTY
124362: LIST
124363: LIST
124364: PUSH
124365: EMPTY
124366: LIST
124367: LIST
124368: LIST
124369: PUSH
124370: EMPTY
124371: LIST
124372: LIST
124373: LIST
124374: LIST
124375: PPUSH
124376: CALL_OW 69
124380: PUSH
124381: LD_VAR 0 8
124385: PPUSH
124386: CALL_OW 313
124390: PPUSH
124391: LD_INT 3
124393: PUSH
124394: LD_INT 60
124396: PUSH
124397: EMPTY
124398: LIST
124399: PUSH
124400: EMPTY
124401: LIST
124402: LIST
124403: PUSH
124404: LD_INT 2
124406: PUSH
124407: LD_INT 25
124409: PUSH
124410: LD_INT 2
124412: PUSH
124413: EMPTY
124414: LIST
124415: LIST
124416: PUSH
124417: LD_INT 25
124419: PUSH
124420: LD_INT 16
124422: PUSH
124423: EMPTY
124424: LIST
124425: LIST
124426: PUSH
124427: EMPTY
124428: LIST
124429: LIST
124430: LIST
124431: PUSH
124432: EMPTY
124433: LIST
124434: LIST
124435: PPUSH
124436: CALL_OW 72
124440: UNION
124441: ST_TO_ADDR
// if tmp then
124442: LD_VAR 0 4
124446: IFFALSE 124526
// begin tmp := ShrinkArray ( tmp , 3 ) ;
124448: LD_ADDR_VAR 0 4
124452: PUSH
124453: LD_VAR 0 4
124457: PPUSH
124458: LD_INT 3
124460: PPUSH
124461: CALL 105319 0 2
124465: ST_TO_ADDR
// for j in tmp do
124466: LD_ADDR_VAR 0 2
124470: PUSH
124471: LD_VAR 0 4
124475: PUSH
124476: FOR_IN
124477: IFFALSE 124520
// begin if IsInUnit ( j ) then
124479: LD_VAR 0 2
124483: PPUSH
124484: CALL_OW 310
124488: IFFALSE 124499
// ComExit ( j ) ;
124490: LD_VAR 0 2
124494: PPUSH
124495: CALL 105402 0 1
// AddComCollect ( j , x , y ) ;
124499: LD_VAR 0 2
124503: PPUSH
124504: LD_VAR 0 6
124508: PPUSH
124509: LD_VAR 0 7
124513: PPUSH
124514: CALL_OW 177
// end ;
124518: GO 124476
124520: POP
124521: POP
// exit ;
124522: POP
124523: POP
124524: GO 124753
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
124526: LD_ADDR_VAR 0 4
124530: PUSH
124531: LD_INT 22
124533: PUSH
124534: LD_VAR 0 5
124538: PUSH
124539: EMPTY
124540: LIST
124541: LIST
124542: PUSH
124543: LD_INT 91
124545: PUSH
124546: LD_VAR 0 8
124550: PUSH
124551: LD_INT 8
124553: PUSH
124554: EMPTY
124555: LIST
124556: LIST
124557: LIST
124558: PUSH
124559: LD_INT 2
124561: PUSH
124562: LD_INT 34
124564: PUSH
124565: LD_INT 12
124567: PUSH
124568: EMPTY
124569: LIST
124570: LIST
124571: PUSH
124572: LD_INT 34
124574: PUSH
124575: LD_INT 51
124577: PUSH
124578: EMPTY
124579: LIST
124580: LIST
124581: PUSH
124582: LD_INT 34
124584: PUSH
124585: LD_INT 32
124587: PUSH
124588: EMPTY
124589: LIST
124590: LIST
124591: PUSH
124592: LD_INT 34
124594: PUSH
124595: LD_INT 89
124597: PUSH
124598: EMPTY
124599: LIST
124600: LIST
124601: PUSH
124602: EMPTY
124603: LIST
124604: LIST
124605: LIST
124606: LIST
124607: LIST
124608: PUSH
124609: EMPTY
124610: LIST
124611: LIST
124612: LIST
124613: PPUSH
124614: CALL_OW 69
124618: ST_TO_ADDR
// if tmp then
124619: LD_VAR 0 4
124623: IFFALSE 124749
// begin for j in tmp do
124625: LD_ADDR_VAR 0 2
124629: PUSH
124630: LD_VAR 0 4
124634: PUSH
124635: FOR_IN
124636: IFFALSE 124747
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
124638: LD_VAR 0 2
124642: PPUSH
124643: CALL_OW 262
124647: PUSH
124648: LD_INT 3
124650: EQUAL
124651: PUSH
124652: LD_VAR 0 2
124656: PPUSH
124657: CALL_OW 261
124661: PUSH
124662: LD_INT 20
124664: GREATER
124665: OR
124666: PUSH
124667: LD_VAR 0 2
124671: PPUSH
124672: CALL_OW 314
124676: NOT
124677: AND
124678: PUSH
124679: LD_VAR 0 2
124683: PPUSH
124684: CALL_OW 263
124688: PUSH
124689: LD_INT 1
124691: NONEQUAL
124692: PUSH
124693: LD_VAR 0 2
124697: PPUSH
124698: CALL_OW 311
124702: OR
124703: AND
124704: IFFALSE 124745
// begin ComCollect ( j , x , y ) ;
124706: LD_VAR 0 2
124710: PPUSH
124711: LD_VAR 0 6
124715: PPUSH
124716: LD_VAR 0 7
124720: PPUSH
124721: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
124725: LD_VAR 0 2
124729: PPUSH
124730: LD_VAR 0 8
124734: PPUSH
124735: CALL_OW 172
// exit ;
124739: POP
124740: POP
124741: POP
124742: POP
124743: GO 124753
// end ;
124745: GO 124635
124747: POP
124748: POP
// end ; end ;
124749: GO 124124
124751: POP
124752: POP
// end ; end_of_file
124753: PPOPN 9
124755: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
124756: LD_INT 0
124758: PPUSH
124759: PPUSH
124760: PPUSH
124761: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
124762: LD_VAR 0 1
124766: PPUSH
124767: CALL_OW 264
124771: PUSH
124772: LD_INT 91
124774: EQUAL
124775: IFFALSE 124847
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
124777: LD_INT 68
124779: PPUSH
124780: LD_VAR 0 1
124784: PPUSH
124785: CALL_OW 255
124789: PPUSH
124790: CALL_OW 321
124794: PUSH
124795: LD_INT 2
124797: EQUAL
124798: IFFALSE 124810
// eff := 70 else
124800: LD_ADDR_VAR 0 4
124804: PUSH
124805: LD_INT 70
124807: ST_TO_ADDR
124808: GO 124818
// eff := 30 ;
124810: LD_ADDR_VAR 0 4
124814: PUSH
124815: LD_INT 30
124817: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
124818: LD_VAR 0 1
124822: PPUSH
124823: CALL_OW 250
124827: PPUSH
124828: LD_VAR 0 1
124832: PPUSH
124833: CALL_OW 251
124837: PPUSH
124838: LD_VAR 0 4
124842: PPUSH
124843: CALL_OW 495
// end ; end ;
124847: LD_VAR 0 2
124851: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
124852: LD_INT 0
124854: PPUSH
// end ;
124855: LD_VAR 0 4
124859: RET
// export function SOS_Command ( cmd ) ; begin
124860: LD_INT 0
124862: PPUSH
// end ;
124863: LD_VAR 0 2
124867: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
124868: LD_INT 0
124870: PPUSH
// end ;
124871: LD_VAR 0 6
124875: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
124876: LD_INT 0
124878: PPUSH
124879: PPUSH
// if not vehicle or not factory then
124880: LD_VAR 0 1
124884: NOT
124885: PUSH
124886: LD_VAR 0 2
124890: NOT
124891: OR
124892: IFFALSE 124896
// exit ;
124894: GO 125127
// if factoryWaypoints >= factory then
124896: LD_EXP 203
124900: PUSH
124901: LD_VAR 0 2
124905: GREATEREQUAL
124906: IFFALSE 125127
// if factoryWaypoints [ factory ] then
124908: LD_EXP 203
124912: PUSH
124913: LD_VAR 0 2
124917: ARRAY
124918: IFFALSE 125127
// begin if GetControl ( vehicle ) = control_manual then
124920: LD_VAR 0 1
124924: PPUSH
124925: CALL_OW 263
124929: PUSH
124930: LD_INT 1
124932: EQUAL
124933: IFFALSE 125014
// begin driver := IsDrivenBy ( vehicle ) ;
124935: LD_ADDR_VAR 0 4
124939: PUSH
124940: LD_VAR 0 1
124944: PPUSH
124945: CALL_OW 311
124949: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124950: LD_VAR 0 4
124954: PPUSH
124955: LD_EXP 203
124959: PUSH
124960: LD_VAR 0 2
124964: ARRAY
124965: PUSH
124966: LD_INT 3
124968: ARRAY
124969: PPUSH
124970: LD_EXP 203
124974: PUSH
124975: LD_VAR 0 2
124979: ARRAY
124980: PUSH
124981: LD_INT 4
124983: ARRAY
124984: PPUSH
124985: CALL_OW 171
// AddComExitVehicle ( driver ) ;
124989: LD_VAR 0 4
124993: PPUSH
124994: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
124998: LD_VAR 0 4
125002: PPUSH
125003: LD_VAR 0 2
125007: PPUSH
125008: CALL_OW 180
// end else
125012: GO 125127
// if GetControl ( vehicle ) = control_remote then
125014: LD_VAR 0 1
125018: PPUSH
125019: CALL_OW 263
125023: PUSH
125024: LD_INT 2
125026: EQUAL
125027: IFFALSE 125088
// begin wait ( 0 0$2 ) ;
125029: LD_INT 70
125031: PPUSH
125032: CALL_OW 67
// if Connect ( vehicle ) then
125036: LD_VAR 0 1
125040: PPUSH
125041: CALL 75642 0 1
125045: IFFALSE 125086
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
125047: LD_VAR 0 1
125051: PPUSH
125052: LD_EXP 203
125056: PUSH
125057: LD_VAR 0 2
125061: ARRAY
125062: PUSH
125063: LD_INT 3
125065: ARRAY
125066: PPUSH
125067: LD_EXP 203
125071: PUSH
125072: LD_VAR 0 2
125076: ARRAY
125077: PUSH
125078: LD_INT 4
125080: ARRAY
125081: PPUSH
125082: CALL_OW 171
// end else
125086: GO 125127
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
125088: LD_VAR 0 1
125092: PPUSH
125093: LD_EXP 203
125097: PUSH
125098: LD_VAR 0 2
125102: ARRAY
125103: PUSH
125104: LD_INT 3
125106: ARRAY
125107: PPUSH
125108: LD_EXP 203
125112: PUSH
125113: LD_VAR 0 2
125117: ARRAY
125118: PUSH
125119: LD_INT 4
125121: ARRAY
125122: PPUSH
125123: CALL_OW 171
// end ; end ;
125127: LD_VAR 0 3
125131: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
125132: LD_INT 0
125134: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
125135: LD_VAR 0 1
125139: PUSH
125140: LD_INT 250
125142: EQUAL
125143: PUSH
125144: LD_VAR 0 2
125148: PPUSH
125149: CALL_OW 264
125153: PUSH
125154: LD_INT 81
125156: EQUAL
125157: AND
125158: IFFALSE 125179
// MinerPlaceMine ( unit , x , y ) ;
125160: LD_VAR 0 2
125164: PPUSH
125165: LD_VAR 0 4
125169: PPUSH
125170: LD_VAR 0 5
125174: PPUSH
125175: CALL 127564 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
125179: LD_VAR 0 1
125183: PUSH
125184: LD_INT 251
125186: EQUAL
125187: PUSH
125188: LD_VAR 0 2
125192: PPUSH
125193: CALL_OW 264
125197: PUSH
125198: LD_INT 81
125200: EQUAL
125201: AND
125202: IFFALSE 125223
// MinerDetonateMine ( unit , x , y ) ;
125204: LD_VAR 0 2
125208: PPUSH
125209: LD_VAR 0 4
125213: PPUSH
125214: LD_VAR 0 5
125218: PPUSH
125219: CALL 127839 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
125223: LD_VAR 0 1
125227: PUSH
125228: LD_INT 252
125230: EQUAL
125231: PUSH
125232: LD_VAR 0 2
125236: PPUSH
125237: CALL_OW 264
125241: PUSH
125242: LD_INT 81
125244: EQUAL
125245: AND
125246: IFFALSE 125267
// MinerCreateMinefield ( unit , x , y ) ;
125248: LD_VAR 0 2
125252: PPUSH
125253: LD_VAR 0 4
125257: PPUSH
125258: LD_VAR 0 5
125262: PPUSH
125263: CALL 128256 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
125267: LD_VAR 0 1
125271: PUSH
125272: LD_INT 253
125274: EQUAL
125275: PUSH
125276: LD_VAR 0 2
125280: PPUSH
125281: CALL_OW 257
125285: PUSH
125286: LD_INT 5
125288: EQUAL
125289: AND
125290: IFFALSE 125311
// ComBinocular ( unit , x , y ) ;
125292: LD_VAR 0 2
125296: PPUSH
125297: LD_VAR 0 4
125301: PPUSH
125302: LD_VAR 0 5
125306: PPUSH
125307: CALL 128625 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
125311: LD_VAR 0 1
125315: PUSH
125316: LD_INT 254
125318: EQUAL
125319: PUSH
125320: LD_VAR 0 2
125324: PPUSH
125325: CALL_OW 264
125329: PUSH
125330: LD_INT 99
125332: EQUAL
125333: AND
125334: PUSH
125335: LD_VAR 0 3
125339: PPUSH
125340: CALL_OW 263
125344: PUSH
125345: LD_INT 3
125347: EQUAL
125348: AND
125349: IFFALSE 125365
// HackDestroyVehicle ( unit , selectedUnit ) ;
125351: LD_VAR 0 2
125355: PPUSH
125356: LD_VAR 0 3
125360: PPUSH
125361: CALL 126928 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
125365: LD_VAR 0 1
125369: PUSH
125370: LD_INT 255
125372: EQUAL
125373: PUSH
125374: LD_VAR 0 2
125378: PPUSH
125379: CALL_OW 264
125383: PUSH
125384: LD_INT 14
125386: PUSH
125387: LD_INT 53
125389: PUSH
125390: EMPTY
125391: LIST
125392: LIST
125393: IN
125394: AND
125395: PUSH
125396: LD_VAR 0 4
125400: PPUSH
125401: LD_VAR 0 5
125405: PPUSH
125406: CALL_OW 488
125410: AND
125411: IFFALSE 125435
// CutTreeXYR ( unit , x , y , 12 ) ;
125413: LD_VAR 0 2
125417: PPUSH
125418: LD_VAR 0 4
125422: PPUSH
125423: LD_VAR 0 5
125427: PPUSH
125428: LD_INT 12
125430: PPUSH
125431: CALL 125498 0 4
// if cmd = 256 then
125435: LD_VAR 0 1
125439: PUSH
125440: LD_INT 256
125442: EQUAL
125443: IFFALSE 125464
// SetFactoryWaypoint ( unit , x , y ) ;
125445: LD_VAR 0 2
125449: PPUSH
125450: LD_VAR 0 4
125454: PPUSH
125455: LD_VAR 0 5
125459: PPUSH
125460: CALL 123445 0 3
// if cmd = 257 then
125464: LD_VAR 0 1
125468: PUSH
125469: LD_INT 257
125471: EQUAL
125472: IFFALSE 125493
// SetWarehouseGatheringPoint ( unit , x , y ) ;
125474: LD_VAR 0 2
125478: PPUSH
125479: LD_VAR 0 4
125483: PPUSH
125484: LD_VAR 0 5
125488: PPUSH
125489: CALL 123807 0 3
// end ;
125493: LD_VAR 0 6
125497: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
125498: LD_INT 0
125500: PPUSH
125501: PPUSH
125502: PPUSH
125503: PPUSH
125504: PPUSH
125505: PPUSH
125506: PPUSH
125507: PPUSH
125508: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
125509: LD_VAR 0 1
125513: NOT
125514: PUSH
125515: LD_VAR 0 2
125519: PPUSH
125520: LD_VAR 0 3
125524: PPUSH
125525: CALL_OW 488
125529: NOT
125530: OR
125531: PUSH
125532: LD_VAR 0 4
125536: NOT
125537: OR
125538: IFFALSE 125542
// exit ;
125540: GO 125882
// list := [ ] ;
125542: LD_ADDR_VAR 0 13
125546: PUSH
125547: EMPTY
125548: ST_TO_ADDR
// if x - r < 0 then
125549: LD_VAR 0 2
125553: PUSH
125554: LD_VAR 0 4
125558: MINUS
125559: PUSH
125560: LD_INT 0
125562: LESS
125563: IFFALSE 125575
// min_x := 0 else
125565: LD_ADDR_VAR 0 7
125569: PUSH
125570: LD_INT 0
125572: ST_TO_ADDR
125573: GO 125591
// min_x := x - r ;
125575: LD_ADDR_VAR 0 7
125579: PUSH
125580: LD_VAR 0 2
125584: PUSH
125585: LD_VAR 0 4
125589: MINUS
125590: ST_TO_ADDR
// if y - r < 0 then
125591: LD_VAR 0 3
125595: PUSH
125596: LD_VAR 0 4
125600: MINUS
125601: PUSH
125602: LD_INT 0
125604: LESS
125605: IFFALSE 125617
// min_y := 0 else
125607: LD_ADDR_VAR 0 8
125611: PUSH
125612: LD_INT 0
125614: ST_TO_ADDR
125615: GO 125633
// min_y := y - r ;
125617: LD_ADDR_VAR 0 8
125621: PUSH
125622: LD_VAR 0 3
125626: PUSH
125627: LD_VAR 0 4
125631: MINUS
125632: ST_TO_ADDR
// max_x := x + r ;
125633: LD_ADDR_VAR 0 9
125637: PUSH
125638: LD_VAR 0 2
125642: PUSH
125643: LD_VAR 0 4
125647: PLUS
125648: ST_TO_ADDR
// max_y := y + r ;
125649: LD_ADDR_VAR 0 10
125653: PUSH
125654: LD_VAR 0 3
125658: PUSH
125659: LD_VAR 0 4
125663: PLUS
125664: ST_TO_ADDR
// for _x = min_x to max_x do
125665: LD_ADDR_VAR 0 11
125669: PUSH
125670: DOUBLE
125671: LD_VAR 0 7
125675: DEC
125676: ST_TO_ADDR
125677: LD_VAR 0 9
125681: PUSH
125682: FOR_TO
125683: IFFALSE 125800
// for _y = min_y to max_y do
125685: LD_ADDR_VAR 0 12
125689: PUSH
125690: DOUBLE
125691: LD_VAR 0 8
125695: DEC
125696: ST_TO_ADDR
125697: LD_VAR 0 10
125701: PUSH
125702: FOR_TO
125703: IFFALSE 125796
// begin if not ValidHex ( _x , _y ) then
125705: LD_VAR 0 11
125709: PPUSH
125710: LD_VAR 0 12
125714: PPUSH
125715: CALL_OW 488
125719: NOT
125720: IFFALSE 125724
// continue ;
125722: GO 125702
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
125724: LD_VAR 0 11
125728: PPUSH
125729: LD_VAR 0 12
125733: PPUSH
125734: CALL_OW 351
125738: PUSH
125739: LD_VAR 0 11
125743: PPUSH
125744: LD_VAR 0 12
125748: PPUSH
125749: CALL_OW 554
125753: AND
125754: IFFALSE 125794
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
125756: LD_ADDR_VAR 0 13
125760: PUSH
125761: LD_VAR 0 13
125765: PPUSH
125766: LD_VAR 0 13
125770: PUSH
125771: LD_INT 1
125773: PLUS
125774: PPUSH
125775: LD_VAR 0 11
125779: PUSH
125780: LD_VAR 0 12
125784: PUSH
125785: EMPTY
125786: LIST
125787: LIST
125788: PPUSH
125789: CALL_OW 2
125793: ST_TO_ADDR
// end ;
125794: GO 125702
125796: POP
125797: POP
125798: GO 125682
125800: POP
125801: POP
// if not list then
125802: LD_VAR 0 13
125806: NOT
125807: IFFALSE 125811
// exit ;
125809: GO 125882
// for i in list do
125811: LD_ADDR_VAR 0 6
125815: PUSH
125816: LD_VAR 0 13
125820: PUSH
125821: FOR_IN
125822: IFFALSE 125880
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
125824: LD_VAR 0 1
125828: PPUSH
125829: LD_STRING M
125831: PUSH
125832: LD_VAR 0 6
125836: PUSH
125837: LD_INT 1
125839: ARRAY
125840: PUSH
125841: LD_VAR 0 6
125845: PUSH
125846: LD_INT 2
125848: ARRAY
125849: PUSH
125850: LD_INT 0
125852: PUSH
125853: LD_INT 0
125855: PUSH
125856: LD_INT 0
125858: PUSH
125859: LD_INT 0
125861: PUSH
125862: EMPTY
125863: LIST
125864: LIST
125865: LIST
125866: LIST
125867: LIST
125868: LIST
125869: LIST
125870: PUSH
125871: EMPTY
125872: LIST
125873: PPUSH
125874: CALL_OW 447
125878: GO 125821
125880: POP
125881: POP
// end ;
125882: LD_VAR 0 5
125886: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
125887: LD_EXP 206
125891: NOT
125892: IFFALSE 125942
125894: GO 125896
125896: DISABLE
// begin initHack := true ;
125897: LD_ADDR_EXP 206
125901: PUSH
125902: LD_INT 1
125904: ST_TO_ADDR
// hackTanks := [ ] ;
125905: LD_ADDR_EXP 207
125909: PUSH
125910: EMPTY
125911: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
125912: LD_ADDR_EXP 208
125916: PUSH
125917: EMPTY
125918: ST_TO_ADDR
// hackLimit := 3 ;
125919: LD_ADDR_EXP 209
125923: PUSH
125924: LD_INT 3
125926: ST_TO_ADDR
// hackDist := 12 ;
125927: LD_ADDR_EXP 210
125931: PUSH
125932: LD_INT 12
125934: ST_TO_ADDR
// hackCounter := [ ] ;
125935: LD_ADDR_EXP 211
125939: PUSH
125940: EMPTY
125941: ST_TO_ADDR
// end ;
125942: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
125943: LD_EXP 206
125947: PUSH
125948: LD_INT 34
125950: PUSH
125951: LD_INT 99
125953: PUSH
125954: EMPTY
125955: LIST
125956: LIST
125957: PPUSH
125958: CALL_OW 69
125962: AND
125963: IFFALSE 126216
125965: GO 125967
125967: DISABLE
125968: LD_INT 0
125970: PPUSH
125971: PPUSH
// begin enable ;
125972: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
125973: LD_ADDR_VAR 0 1
125977: PUSH
125978: LD_INT 34
125980: PUSH
125981: LD_INT 99
125983: PUSH
125984: EMPTY
125985: LIST
125986: LIST
125987: PPUSH
125988: CALL_OW 69
125992: PUSH
125993: FOR_IN
125994: IFFALSE 126214
// begin if not i in hackTanks then
125996: LD_VAR 0 1
126000: PUSH
126001: LD_EXP 207
126005: IN
126006: NOT
126007: IFFALSE 126090
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
126009: LD_ADDR_EXP 207
126013: PUSH
126014: LD_EXP 207
126018: PPUSH
126019: LD_EXP 207
126023: PUSH
126024: LD_INT 1
126026: PLUS
126027: PPUSH
126028: LD_VAR 0 1
126032: PPUSH
126033: CALL_OW 1
126037: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
126038: LD_ADDR_EXP 208
126042: PUSH
126043: LD_EXP 208
126047: PPUSH
126048: LD_EXP 208
126052: PUSH
126053: LD_INT 1
126055: PLUS
126056: PPUSH
126057: EMPTY
126058: PPUSH
126059: CALL_OW 1
126063: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
126064: LD_ADDR_EXP 211
126068: PUSH
126069: LD_EXP 211
126073: PPUSH
126074: LD_EXP 211
126078: PUSH
126079: LD_INT 1
126081: PLUS
126082: PPUSH
126083: EMPTY
126084: PPUSH
126085: CALL_OW 1
126089: ST_TO_ADDR
// end ; if not IsOk ( i ) then
126090: LD_VAR 0 1
126094: PPUSH
126095: CALL_OW 302
126099: NOT
126100: IFFALSE 126113
// begin HackUnlinkAll ( i ) ;
126102: LD_VAR 0 1
126106: PPUSH
126107: CALL 126219 0 1
// continue ;
126111: GO 125993
// end ; HackCheckCapturedStatus ( i ) ;
126113: LD_VAR 0 1
126117: PPUSH
126118: CALL 126662 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
126122: LD_ADDR_VAR 0 2
126126: PUSH
126127: LD_INT 81
126129: PUSH
126130: LD_VAR 0 1
126134: PPUSH
126135: CALL_OW 255
126139: PUSH
126140: EMPTY
126141: LIST
126142: LIST
126143: PUSH
126144: LD_INT 33
126146: PUSH
126147: LD_INT 3
126149: PUSH
126150: EMPTY
126151: LIST
126152: LIST
126153: PUSH
126154: LD_INT 91
126156: PUSH
126157: LD_VAR 0 1
126161: PUSH
126162: LD_EXP 210
126166: PUSH
126167: EMPTY
126168: LIST
126169: LIST
126170: LIST
126171: PUSH
126172: LD_INT 50
126174: PUSH
126175: EMPTY
126176: LIST
126177: PUSH
126178: EMPTY
126179: LIST
126180: LIST
126181: LIST
126182: LIST
126183: PPUSH
126184: CALL_OW 69
126188: ST_TO_ADDR
// if not tmp then
126189: LD_VAR 0 2
126193: NOT
126194: IFFALSE 126198
// continue ;
126196: GO 125993
// HackLink ( i , tmp ) ;
126198: LD_VAR 0 1
126202: PPUSH
126203: LD_VAR 0 2
126207: PPUSH
126208: CALL 126355 0 2
// end ;
126212: GO 125993
126214: POP
126215: POP
// end ;
126216: PPOPN 2
126218: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
126219: LD_INT 0
126221: PPUSH
126222: PPUSH
126223: PPUSH
// if not hack in hackTanks then
126224: LD_VAR 0 1
126228: PUSH
126229: LD_EXP 207
126233: IN
126234: NOT
126235: IFFALSE 126239
// exit ;
126237: GO 126350
// index := GetElementIndex ( hackTanks , hack ) ;
126239: LD_ADDR_VAR 0 4
126243: PUSH
126244: LD_EXP 207
126248: PPUSH
126249: LD_VAR 0 1
126253: PPUSH
126254: CALL 72458 0 2
126258: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
126259: LD_EXP 208
126263: PUSH
126264: LD_VAR 0 4
126268: ARRAY
126269: IFFALSE 126350
// begin for i in hackTanksCaptured [ index ] do
126271: LD_ADDR_VAR 0 3
126275: PUSH
126276: LD_EXP 208
126280: PUSH
126281: LD_VAR 0 4
126285: ARRAY
126286: PUSH
126287: FOR_IN
126288: IFFALSE 126314
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
126290: LD_VAR 0 3
126294: PUSH
126295: LD_INT 1
126297: ARRAY
126298: PPUSH
126299: LD_VAR 0 3
126303: PUSH
126304: LD_INT 2
126306: ARRAY
126307: PPUSH
126308: CALL_OW 235
126312: GO 126287
126314: POP
126315: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
126316: LD_ADDR_EXP 208
126320: PUSH
126321: LD_EXP 208
126325: PPUSH
126326: LD_VAR 0 4
126330: PPUSH
126331: EMPTY
126332: PPUSH
126333: CALL_OW 1
126337: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
126338: LD_VAR 0 1
126342: PPUSH
126343: LD_INT 0
126345: PPUSH
126346: CALL_OW 505
// end ; end ;
126350: LD_VAR 0 2
126354: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
126355: LD_INT 0
126357: PPUSH
126358: PPUSH
126359: PPUSH
// if not hack in hackTanks or not vehicles then
126360: LD_VAR 0 1
126364: PUSH
126365: LD_EXP 207
126369: IN
126370: NOT
126371: PUSH
126372: LD_VAR 0 2
126376: NOT
126377: OR
126378: IFFALSE 126382
// exit ;
126380: GO 126657
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
126382: LD_ADDR_VAR 0 2
126386: PUSH
126387: LD_VAR 0 1
126391: PPUSH
126392: LD_VAR 0 2
126396: PPUSH
126397: LD_INT 1
126399: PPUSH
126400: LD_INT 1
126402: PPUSH
126403: CALL 73108 0 4
126407: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
126408: LD_ADDR_VAR 0 5
126412: PUSH
126413: LD_EXP 207
126417: PPUSH
126418: LD_VAR 0 1
126422: PPUSH
126423: CALL 72458 0 2
126427: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
126428: LD_EXP 208
126432: PUSH
126433: LD_VAR 0 5
126437: ARRAY
126438: PUSH
126439: LD_EXP 209
126443: LESS
126444: IFFALSE 126633
// begin for i := 1 to vehicles do
126446: LD_ADDR_VAR 0 4
126450: PUSH
126451: DOUBLE
126452: LD_INT 1
126454: DEC
126455: ST_TO_ADDR
126456: LD_VAR 0 2
126460: PUSH
126461: FOR_TO
126462: IFFALSE 126631
// begin if hackTanksCaptured [ index ] = hackLimit then
126464: LD_EXP 208
126468: PUSH
126469: LD_VAR 0 5
126473: ARRAY
126474: PUSH
126475: LD_EXP 209
126479: EQUAL
126480: IFFALSE 126484
// break ;
126482: GO 126631
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
126484: LD_ADDR_EXP 211
126488: PUSH
126489: LD_EXP 211
126493: PPUSH
126494: LD_VAR 0 5
126498: PPUSH
126499: LD_EXP 211
126503: PUSH
126504: LD_VAR 0 5
126508: ARRAY
126509: PUSH
126510: LD_INT 1
126512: PLUS
126513: PPUSH
126514: CALL_OW 1
126518: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
126519: LD_ADDR_EXP 208
126523: PUSH
126524: LD_EXP 208
126528: PPUSH
126529: LD_VAR 0 5
126533: PUSH
126534: LD_EXP 208
126538: PUSH
126539: LD_VAR 0 5
126543: ARRAY
126544: PUSH
126545: LD_INT 1
126547: PLUS
126548: PUSH
126549: EMPTY
126550: LIST
126551: LIST
126552: PPUSH
126553: LD_VAR 0 2
126557: PUSH
126558: LD_VAR 0 4
126562: ARRAY
126563: PUSH
126564: LD_VAR 0 2
126568: PUSH
126569: LD_VAR 0 4
126573: ARRAY
126574: PPUSH
126575: CALL_OW 255
126579: PUSH
126580: EMPTY
126581: LIST
126582: LIST
126583: PPUSH
126584: CALL 72673 0 3
126588: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
126589: LD_VAR 0 2
126593: PUSH
126594: LD_VAR 0 4
126598: ARRAY
126599: PPUSH
126600: LD_VAR 0 1
126604: PPUSH
126605: CALL_OW 255
126609: PPUSH
126610: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
126614: LD_VAR 0 2
126618: PUSH
126619: LD_VAR 0 4
126623: ARRAY
126624: PPUSH
126625: CALL_OW 141
// end ;
126629: GO 126461
126631: POP
126632: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126633: LD_VAR 0 1
126637: PPUSH
126638: LD_EXP 208
126642: PUSH
126643: LD_VAR 0 5
126647: ARRAY
126648: PUSH
126649: LD_INT 0
126651: PLUS
126652: PPUSH
126653: CALL_OW 505
// end ;
126657: LD_VAR 0 3
126661: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
126662: LD_INT 0
126664: PPUSH
126665: PPUSH
126666: PPUSH
126667: PPUSH
// if not hack in hackTanks then
126668: LD_VAR 0 1
126672: PUSH
126673: LD_EXP 207
126677: IN
126678: NOT
126679: IFFALSE 126683
// exit ;
126681: GO 126923
// index := GetElementIndex ( hackTanks , hack ) ;
126683: LD_ADDR_VAR 0 4
126687: PUSH
126688: LD_EXP 207
126692: PPUSH
126693: LD_VAR 0 1
126697: PPUSH
126698: CALL 72458 0 2
126702: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
126703: LD_ADDR_VAR 0 3
126707: PUSH
126708: DOUBLE
126709: LD_EXP 208
126713: PUSH
126714: LD_VAR 0 4
126718: ARRAY
126719: INC
126720: ST_TO_ADDR
126721: LD_INT 1
126723: PUSH
126724: FOR_DOWNTO
126725: IFFALSE 126897
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
126727: LD_ADDR_VAR 0 5
126731: PUSH
126732: LD_EXP 208
126736: PUSH
126737: LD_VAR 0 4
126741: ARRAY
126742: PUSH
126743: LD_VAR 0 3
126747: ARRAY
126748: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
126749: LD_VAR 0 5
126753: PUSH
126754: LD_INT 1
126756: ARRAY
126757: PPUSH
126758: CALL_OW 302
126762: NOT
126763: PUSH
126764: LD_VAR 0 5
126768: PUSH
126769: LD_INT 1
126771: ARRAY
126772: PPUSH
126773: CALL_OW 255
126777: PUSH
126778: LD_VAR 0 1
126782: PPUSH
126783: CALL_OW 255
126787: NONEQUAL
126788: OR
126789: IFFALSE 126895
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
126791: LD_VAR 0 5
126795: PUSH
126796: LD_INT 1
126798: ARRAY
126799: PPUSH
126800: CALL_OW 305
126804: PUSH
126805: LD_VAR 0 5
126809: PUSH
126810: LD_INT 1
126812: ARRAY
126813: PPUSH
126814: CALL_OW 255
126818: PUSH
126819: LD_VAR 0 1
126823: PPUSH
126824: CALL_OW 255
126828: EQUAL
126829: AND
126830: IFFALSE 126854
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
126832: LD_VAR 0 5
126836: PUSH
126837: LD_INT 1
126839: ARRAY
126840: PPUSH
126841: LD_VAR 0 5
126845: PUSH
126846: LD_INT 2
126848: ARRAY
126849: PPUSH
126850: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
126854: LD_ADDR_EXP 208
126858: PUSH
126859: LD_EXP 208
126863: PPUSH
126864: LD_VAR 0 4
126868: PPUSH
126869: LD_EXP 208
126873: PUSH
126874: LD_VAR 0 4
126878: ARRAY
126879: PPUSH
126880: LD_VAR 0 3
126884: PPUSH
126885: CALL_OW 3
126889: PPUSH
126890: CALL_OW 1
126894: ST_TO_ADDR
// end ; end ;
126895: GO 126724
126897: POP
126898: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126899: LD_VAR 0 1
126903: PPUSH
126904: LD_EXP 208
126908: PUSH
126909: LD_VAR 0 4
126913: ARRAY
126914: PUSH
126915: LD_INT 0
126917: PLUS
126918: PPUSH
126919: CALL_OW 505
// end ;
126923: LD_VAR 0 2
126927: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
126928: LD_INT 0
126930: PPUSH
126931: PPUSH
126932: PPUSH
126933: PPUSH
// if not hack in hackTanks then
126934: LD_VAR 0 1
126938: PUSH
126939: LD_EXP 207
126943: IN
126944: NOT
126945: IFFALSE 126949
// exit ;
126947: GO 127034
// index := GetElementIndex ( hackTanks , hack ) ;
126949: LD_ADDR_VAR 0 5
126953: PUSH
126954: LD_EXP 207
126958: PPUSH
126959: LD_VAR 0 1
126963: PPUSH
126964: CALL 72458 0 2
126968: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
126969: LD_ADDR_VAR 0 4
126973: PUSH
126974: DOUBLE
126975: LD_INT 1
126977: DEC
126978: ST_TO_ADDR
126979: LD_EXP 208
126983: PUSH
126984: LD_VAR 0 5
126988: ARRAY
126989: PUSH
126990: FOR_TO
126991: IFFALSE 127032
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
126993: LD_EXP 208
126997: PUSH
126998: LD_VAR 0 5
127002: ARRAY
127003: PUSH
127004: LD_VAR 0 4
127008: ARRAY
127009: PUSH
127010: LD_INT 1
127012: ARRAY
127013: PUSH
127014: LD_VAR 0 2
127018: EQUAL
127019: IFFALSE 127030
// KillUnit ( vehicle ) ;
127021: LD_VAR 0 2
127025: PPUSH
127026: CALL_OW 66
127030: GO 126990
127032: POP
127033: POP
// end ;
127034: LD_VAR 0 3
127038: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
127039: LD_EXP 212
127043: NOT
127044: IFFALSE 127079
127046: GO 127048
127048: DISABLE
// begin initMiner := true ;
127049: LD_ADDR_EXP 212
127053: PUSH
127054: LD_INT 1
127056: ST_TO_ADDR
// minersList := [ ] ;
127057: LD_ADDR_EXP 213
127061: PUSH
127062: EMPTY
127063: ST_TO_ADDR
// minerMinesList := [ ] ;
127064: LD_ADDR_EXP 214
127068: PUSH
127069: EMPTY
127070: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
127071: LD_ADDR_EXP 215
127075: PUSH
127076: LD_INT 5
127078: ST_TO_ADDR
// end ;
127079: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
127080: LD_EXP 212
127084: PUSH
127085: LD_INT 34
127087: PUSH
127088: LD_INT 81
127090: PUSH
127091: EMPTY
127092: LIST
127093: LIST
127094: PPUSH
127095: CALL_OW 69
127099: AND
127100: IFFALSE 127561
127102: GO 127104
127104: DISABLE
127105: LD_INT 0
127107: PPUSH
127108: PPUSH
127109: PPUSH
127110: PPUSH
// begin enable ;
127111: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
127112: LD_ADDR_VAR 0 1
127116: PUSH
127117: LD_INT 34
127119: PUSH
127120: LD_INT 81
127122: PUSH
127123: EMPTY
127124: LIST
127125: LIST
127126: PPUSH
127127: CALL_OW 69
127131: PUSH
127132: FOR_IN
127133: IFFALSE 127205
// begin if not i in minersList then
127135: LD_VAR 0 1
127139: PUSH
127140: LD_EXP 213
127144: IN
127145: NOT
127146: IFFALSE 127203
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
127148: LD_ADDR_EXP 213
127152: PUSH
127153: LD_EXP 213
127157: PPUSH
127158: LD_EXP 213
127162: PUSH
127163: LD_INT 1
127165: PLUS
127166: PPUSH
127167: LD_VAR 0 1
127171: PPUSH
127172: CALL_OW 1
127176: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
127177: LD_ADDR_EXP 214
127181: PUSH
127182: LD_EXP 214
127186: PPUSH
127187: LD_EXP 214
127191: PUSH
127192: LD_INT 1
127194: PLUS
127195: PPUSH
127196: EMPTY
127197: PPUSH
127198: CALL_OW 1
127202: ST_TO_ADDR
// end end ;
127203: GO 127132
127205: POP
127206: POP
// for i := minerMinesList downto 1 do
127207: LD_ADDR_VAR 0 1
127211: PUSH
127212: DOUBLE
127213: LD_EXP 214
127217: INC
127218: ST_TO_ADDR
127219: LD_INT 1
127221: PUSH
127222: FOR_DOWNTO
127223: IFFALSE 127559
// begin if IsLive ( minersList [ i ] ) then
127225: LD_EXP 213
127229: PUSH
127230: LD_VAR 0 1
127234: ARRAY
127235: PPUSH
127236: CALL_OW 300
127240: IFFALSE 127268
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
127242: LD_EXP 213
127246: PUSH
127247: LD_VAR 0 1
127251: ARRAY
127252: PPUSH
127253: LD_EXP 214
127257: PUSH
127258: LD_VAR 0 1
127262: ARRAY
127263: PPUSH
127264: CALL_OW 505
// if not minerMinesList [ i ] then
127268: LD_EXP 214
127272: PUSH
127273: LD_VAR 0 1
127277: ARRAY
127278: NOT
127279: IFFALSE 127283
// continue ;
127281: GO 127222
// for j := minerMinesList [ i ] downto 1 do
127283: LD_ADDR_VAR 0 2
127287: PUSH
127288: DOUBLE
127289: LD_EXP 214
127293: PUSH
127294: LD_VAR 0 1
127298: ARRAY
127299: INC
127300: ST_TO_ADDR
127301: LD_INT 1
127303: PUSH
127304: FOR_DOWNTO
127305: IFFALSE 127555
// begin side := GetSide ( minersList [ i ] ) ;
127307: LD_ADDR_VAR 0 3
127311: PUSH
127312: LD_EXP 213
127316: PUSH
127317: LD_VAR 0 1
127321: ARRAY
127322: PPUSH
127323: CALL_OW 255
127327: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
127328: LD_ADDR_VAR 0 4
127332: PUSH
127333: LD_EXP 214
127337: PUSH
127338: LD_VAR 0 1
127342: ARRAY
127343: PUSH
127344: LD_VAR 0 2
127348: ARRAY
127349: PUSH
127350: LD_INT 1
127352: ARRAY
127353: PPUSH
127354: LD_EXP 214
127358: PUSH
127359: LD_VAR 0 1
127363: ARRAY
127364: PUSH
127365: LD_VAR 0 2
127369: ARRAY
127370: PUSH
127371: LD_INT 2
127373: ARRAY
127374: PPUSH
127375: CALL_OW 428
127379: ST_TO_ADDR
// if not tmp then
127380: LD_VAR 0 4
127384: NOT
127385: IFFALSE 127389
// continue ;
127387: GO 127304
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
127389: LD_VAR 0 4
127393: PUSH
127394: LD_INT 81
127396: PUSH
127397: LD_VAR 0 3
127401: PUSH
127402: EMPTY
127403: LIST
127404: LIST
127405: PPUSH
127406: CALL_OW 69
127410: IN
127411: PUSH
127412: LD_EXP 214
127416: PUSH
127417: LD_VAR 0 1
127421: ARRAY
127422: PUSH
127423: LD_VAR 0 2
127427: ARRAY
127428: PUSH
127429: LD_INT 1
127431: ARRAY
127432: PPUSH
127433: LD_EXP 214
127437: PUSH
127438: LD_VAR 0 1
127442: ARRAY
127443: PUSH
127444: LD_VAR 0 2
127448: ARRAY
127449: PUSH
127450: LD_INT 2
127452: ARRAY
127453: PPUSH
127454: CALL_OW 458
127458: AND
127459: IFFALSE 127553
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
127461: LD_EXP 214
127465: PUSH
127466: LD_VAR 0 1
127470: ARRAY
127471: PUSH
127472: LD_VAR 0 2
127476: ARRAY
127477: PUSH
127478: LD_INT 1
127480: ARRAY
127481: PPUSH
127482: LD_EXP 214
127486: PUSH
127487: LD_VAR 0 1
127491: ARRAY
127492: PUSH
127493: LD_VAR 0 2
127497: ARRAY
127498: PUSH
127499: LD_INT 2
127501: ARRAY
127502: PPUSH
127503: LD_VAR 0 3
127507: PPUSH
127508: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
127512: LD_ADDR_EXP 214
127516: PUSH
127517: LD_EXP 214
127521: PPUSH
127522: LD_VAR 0 1
127526: PPUSH
127527: LD_EXP 214
127531: PUSH
127532: LD_VAR 0 1
127536: ARRAY
127537: PPUSH
127538: LD_VAR 0 2
127542: PPUSH
127543: CALL_OW 3
127547: PPUSH
127548: CALL_OW 1
127552: ST_TO_ADDR
// end ; end ;
127553: GO 127304
127555: POP
127556: POP
// end ;
127557: GO 127222
127559: POP
127560: POP
// end ;
127561: PPOPN 4
127563: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
127564: LD_INT 0
127566: PPUSH
127567: PPUSH
// result := false ;
127568: LD_ADDR_VAR 0 4
127572: PUSH
127573: LD_INT 0
127575: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
127576: LD_VAR 0 1
127580: PPUSH
127581: CALL_OW 264
127585: PUSH
127586: LD_INT 81
127588: EQUAL
127589: NOT
127590: IFFALSE 127594
// exit ;
127592: GO 127834
// index := GetElementIndex ( minersList , unit ) ;
127594: LD_ADDR_VAR 0 5
127598: PUSH
127599: LD_EXP 213
127603: PPUSH
127604: LD_VAR 0 1
127608: PPUSH
127609: CALL 72458 0 2
127613: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
127614: LD_EXP 214
127618: PUSH
127619: LD_VAR 0 5
127623: ARRAY
127624: PUSH
127625: LD_EXP 215
127629: GREATEREQUAL
127630: IFFALSE 127634
// exit ;
127632: GO 127834
// ComMoveXY ( unit , x , y ) ;
127634: LD_VAR 0 1
127638: PPUSH
127639: LD_VAR 0 2
127643: PPUSH
127644: LD_VAR 0 3
127648: PPUSH
127649: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
127653: LD_INT 35
127655: PPUSH
127656: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
127660: LD_VAR 0 1
127664: PPUSH
127665: LD_VAR 0 2
127669: PPUSH
127670: LD_VAR 0 3
127674: PPUSH
127675: CALL 103813 0 3
127679: NOT
127680: PUSH
127681: LD_VAR 0 1
127685: PPUSH
127686: CALL_OW 314
127690: AND
127691: IFFALSE 127695
// exit ;
127693: GO 127834
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
127695: LD_VAR 0 2
127699: PPUSH
127700: LD_VAR 0 3
127704: PPUSH
127705: CALL_OW 428
127709: PUSH
127710: LD_VAR 0 1
127714: EQUAL
127715: PUSH
127716: LD_VAR 0 1
127720: PPUSH
127721: CALL_OW 314
127725: NOT
127726: AND
127727: IFFALSE 127653
// PlaySoundXY ( x , y , PlantMine ) ;
127729: LD_VAR 0 2
127733: PPUSH
127734: LD_VAR 0 3
127738: PPUSH
127739: LD_STRING PlantMine
127741: PPUSH
127742: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
127746: LD_VAR 0 2
127750: PPUSH
127751: LD_VAR 0 3
127755: PPUSH
127756: LD_VAR 0 1
127760: PPUSH
127761: CALL_OW 255
127765: PPUSH
127766: LD_INT 0
127768: PPUSH
127769: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
127773: LD_ADDR_EXP 214
127777: PUSH
127778: LD_EXP 214
127782: PPUSH
127783: LD_VAR 0 5
127787: PUSH
127788: LD_EXP 214
127792: PUSH
127793: LD_VAR 0 5
127797: ARRAY
127798: PUSH
127799: LD_INT 1
127801: PLUS
127802: PUSH
127803: EMPTY
127804: LIST
127805: LIST
127806: PPUSH
127807: LD_VAR 0 2
127811: PUSH
127812: LD_VAR 0 3
127816: PUSH
127817: EMPTY
127818: LIST
127819: LIST
127820: PPUSH
127821: CALL 72673 0 3
127825: ST_TO_ADDR
// result := true ;
127826: LD_ADDR_VAR 0 4
127830: PUSH
127831: LD_INT 1
127833: ST_TO_ADDR
// end ;
127834: LD_VAR 0 4
127838: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
127839: LD_INT 0
127841: PPUSH
127842: PPUSH
127843: PPUSH
// if not unit in minersList then
127844: LD_VAR 0 1
127848: PUSH
127849: LD_EXP 213
127853: IN
127854: NOT
127855: IFFALSE 127859
// exit ;
127857: GO 128251
// index := GetElementIndex ( minersList , unit ) ;
127859: LD_ADDR_VAR 0 6
127863: PUSH
127864: LD_EXP 213
127868: PPUSH
127869: LD_VAR 0 1
127873: PPUSH
127874: CALL 72458 0 2
127878: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
127879: LD_ADDR_VAR 0 5
127883: PUSH
127884: DOUBLE
127885: LD_EXP 214
127889: PUSH
127890: LD_VAR 0 6
127894: ARRAY
127895: INC
127896: ST_TO_ADDR
127897: LD_INT 1
127899: PUSH
127900: FOR_DOWNTO
127901: IFFALSE 128062
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
127903: LD_EXP 214
127907: PUSH
127908: LD_VAR 0 6
127912: ARRAY
127913: PUSH
127914: LD_VAR 0 5
127918: ARRAY
127919: PUSH
127920: LD_INT 1
127922: ARRAY
127923: PUSH
127924: LD_VAR 0 2
127928: EQUAL
127929: PUSH
127930: LD_EXP 214
127934: PUSH
127935: LD_VAR 0 6
127939: ARRAY
127940: PUSH
127941: LD_VAR 0 5
127945: ARRAY
127946: PUSH
127947: LD_INT 2
127949: ARRAY
127950: PUSH
127951: LD_VAR 0 3
127955: EQUAL
127956: AND
127957: IFFALSE 128060
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127959: LD_EXP 214
127963: PUSH
127964: LD_VAR 0 6
127968: ARRAY
127969: PUSH
127970: LD_VAR 0 5
127974: ARRAY
127975: PUSH
127976: LD_INT 1
127978: ARRAY
127979: PPUSH
127980: LD_EXP 214
127984: PUSH
127985: LD_VAR 0 6
127989: ARRAY
127990: PUSH
127991: LD_VAR 0 5
127995: ARRAY
127996: PUSH
127997: LD_INT 2
127999: ARRAY
128000: PPUSH
128001: LD_VAR 0 1
128005: PPUSH
128006: CALL_OW 255
128010: PPUSH
128011: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
128015: LD_ADDR_EXP 214
128019: PUSH
128020: LD_EXP 214
128024: PPUSH
128025: LD_VAR 0 6
128029: PPUSH
128030: LD_EXP 214
128034: PUSH
128035: LD_VAR 0 6
128039: ARRAY
128040: PPUSH
128041: LD_VAR 0 5
128045: PPUSH
128046: CALL_OW 3
128050: PPUSH
128051: CALL_OW 1
128055: ST_TO_ADDR
// exit ;
128056: POP
128057: POP
128058: GO 128251
// end ; end ;
128060: GO 127900
128062: POP
128063: POP
// for i := minerMinesList [ index ] downto 1 do
128064: LD_ADDR_VAR 0 5
128068: PUSH
128069: DOUBLE
128070: LD_EXP 214
128074: PUSH
128075: LD_VAR 0 6
128079: ARRAY
128080: INC
128081: ST_TO_ADDR
128082: LD_INT 1
128084: PUSH
128085: FOR_DOWNTO
128086: IFFALSE 128249
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
128088: LD_EXP 214
128092: PUSH
128093: LD_VAR 0 6
128097: ARRAY
128098: PUSH
128099: LD_VAR 0 5
128103: ARRAY
128104: PUSH
128105: LD_INT 1
128107: ARRAY
128108: PPUSH
128109: LD_EXP 214
128113: PUSH
128114: LD_VAR 0 6
128118: ARRAY
128119: PUSH
128120: LD_VAR 0 5
128124: ARRAY
128125: PUSH
128126: LD_INT 2
128128: ARRAY
128129: PPUSH
128130: LD_VAR 0 2
128134: PPUSH
128135: LD_VAR 0 3
128139: PPUSH
128140: CALL_OW 298
128144: PUSH
128145: LD_INT 6
128147: LESS
128148: IFFALSE 128247
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
128150: LD_EXP 214
128154: PUSH
128155: LD_VAR 0 6
128159: ARRAY
128160: PUSH
128161: LD_VAR 0 5
128165: ARRAY
128166: PUSH
128167: LD_INT 1
128169: ARRAY
128170: PPUSH
128171: LD_EXP 214
128175: PUSH
128176: LD_VAR 0 6
128180: ARRAY
128181: PUSH
128182: LD_VAR 0 5
128186: ARRAY
128187: PUSH
128188: LD_INT 2
128190: ARRAY
128191: PPUSH
128192: LD_VAR 0 1
128196: PPUSH
128197: CALL_OW 255
128201: PPUSH
128202: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
128206: LD_ADDR_EXP 214
128210: PUSH
128211: LD_EXP 214
128215: PPUSH
128216: LD_VAR 0 6
128220: PPUSH
128221: LD_EXP 214
128225: PUSH
128226: LD_VAR 0 6
128230: ARRAY
128231: PPUSH
128232: LD_VAR 0 5
128236: PPUSH
128237: CALL_OW 3
128241: PPUSH
128242: CALL_OW 1
128246: ST_TO_ADDR
// end ; end ;
128247: GO 128085
128249: POP
128250: POP
// end ;
128251: LD_VAR 0 4
128255: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
128256: LD_INT 0
128258: PPUSH
128259: PPUSH
128260: PPUSH
128261: PPUSH
128262: PPUSH
128263: PPUSH
128264: PPUSH
128265: PPUSH
128266: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
128267: LD_VAR 0 1
128271: PPUSH
128272: CALL_OW 264
128276: PUSH
128277: LD_INT 81
128279: EQUAL
128280: NOT
128281: PUSH
128282: LD_VAR 0 1
128286: PUSH
128287: LD_EXP 213
128291: IN
128292: NOT
128293: OR
128294: IFFALSE 128298
// exit ;
128296: GO 128620
// index := GetElementIndex ( minersList , unit ) ;
128298: LD_ADDR_VAR 0 6
128302: PUSH
128303: LD_EXP 213
128307: PPUSH
128308: LD_VAR 0 1
128312: PPUSH
128313: CALL 72458 0 2
128317: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
128318: LD_ADDR_VAR 0 8
128322: PUSH
128323: LD_EXP 215
128327: PUSH
128328: LD_EXP 214
128332: PUSH
128333: LD_VAR 0 6
128337: ARRAY
128338: MINUS
128339: ST_TO_ADDR
// if not minesFreeAmount then
128340: LD_VAR 0 8
128344: NOT
128345: IFFALSE 128349
// exit ;
128347: GO 128620
// tmp := [ ] ;
128349: LD_ADDR_VAR 0 7
128353: PUSH
128354: EMPTY
128355: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
128356: LD_ADDR_VAR 0 5
128360: PUSH
128361: DOUBLE
128362: LD_INT 1
128364: DEC
128365: ST_TO_ADDR
128366: LD_VAR 0 8
128370: PUSH
128371: FOR_TO
128372: IFFALSE 128567
// begin _d := rand ( 0 , 5 ) ;
128374: LD_ADDR_VAR 0 11
128378: PUSH
128379: LD_INT 0
128381: PPUSH
128382: LD_INT 5
128384: PPUSH
128385: CALL_OW 12
128389: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
128390: LD_ADDR_VAR 0 12
128394: PUSH
128395: LD_INT 2
128397: PPUSH
128398: LD_INT 6
128400: PPUSH
128401: CALL_OW 12
128405: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
128406: LD_ADDR_VAR 0 9
128410: PUSH
128411: LD_VAR 0 2
128415: PPUSH
128416: LD_VAR 0 11
128420: PPUSH
128421: LD_VAR 0 12
128425: PPUSH
128426: CALL_OW 272
128430: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
128431: LD_ADDR_VAR 0 10
128435: PUSH
128436: LD_VAR 0 3
128440: PPUSH
128441: LD_VAR 0 11
128445: PPUSH
128446: LD_VAR 0 12
128450: PPUSH
128451: CALL_OW 273
128455: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
128456: LD_VAR 0 9
128460: PPUSH
128461: LD_VAR 0 10
128465: PPUSH
128466: CALL_OW 488
128470: PUSH
128471: LD_VAR 0 9
128475: PUSH
128476: LD_VAR 0 10
128480: PUSH
128481: EMPTY
128482: LIST
128483: LIST
128484: PUSH
128485: LD_VAR 0 7
128489: IN
128490: NOT
128491: AND
128492: PUSH
128493: LD_VAR 0 9
128497: PPUSH
128498: LD_VAR 0 10
128502: PPUSH
128503: CALL_OW 458
128507: NOT
128508: AND
128509: IFFALSE 128551
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
128511: LD_ADDR_VAR 0 7
128515: PUSH
128516: LD_VAR 0 7
128520: PPUSH
128521: LD_VAR 0 7
128525: PUSH
128526: LD_INT 1
128528: PLUS
128529: PPUSH
128530: LD_VAR 0 9
128534: PUSH
128535: LD_VAR 0 10
128539: PUSH
128540: EMPTY
128541: LIST
128542: LIST
128543: PPUSH
128544: CALL_OW 1
128548: ST_TO_ADDR
128549: GO 128565
// i := i - 1 ;
128551: LD_ADDR_VAR 0 5
128555: PUSH
128556: LD_VAR 0 5
128560: PUSH
128561: LD_INT 1
128563: MINUS
128564: ST_TO_ADDR
// end ;
128565: GO 128371
128567: POP
128568: POP
// for i in tmp do
128569: LD_ADDR_VAR 0 5
128573: PUSH
128574: LD_VAR 0 7
128578: PUSH
128579: FOR_IN
128580: IFFALSE 128618
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
128582: LD_VAR 0 1
128586: PPUSH
128587: LD_VAR 0 5
128591: PUSH
128592: LD_INT 1
128594: ARRAY
128595: PPUSH
128596: LD_VAR 0 5
128600: PUSH
128601: LD_INT 2
128603: ARRAY
128604: PPUSH
128605: CALL 127564 0 3
128609: NOT
128610: IFFALSE 128616
// exit ;
128612: POP
128613: POP
128614: GO 128620
128616: GO 128579
128618: POP
128619: POP
// end ;
128620: LD_VAR 0 4
128624: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
128625: LD_INT 0
128627: PPUSH
128628: PPUSH
128629: PPUSH
128630: PPUSH
128631: PPUSH
128632: PPUSH
128633: PPUSH
// if not GetClass ( unit ) = class_sniper then
128634: LD_VAR 0 1
128638: PPUSH
128639: CALL_OW 257
128643: PUSH
128644: LD_INT 5
128646: EQUAL
128647: NOT
128648: IFFALSE 128652
// exit ;
128650: GO 129040
// dist := 8 ;
128652: LD_ADDR_VAR 0 5
128656: PUSH
128657: LD_INT 8
128659: ST_TO_ADDR
// viewRange := 12 ;
128660: LD_ADDR_VAR 0 7
128664: PUSH
128665: LD_INT 12
128667: ST_TO_ADDR
// side := GetSide ( unit ) ;
128668: LD_ADDR_VAR 0 6
128672: PUSH
128673: LD_VAR 0 1
128677: PPUSH
128678: CALL_OW 255
128682: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
128683: LD_INT 61
128685: PPUSH
128686: LD_VAR 0 6
128690: PPUSH
128691: CALL_OW 321
128695: PUSH
128696: LD_INT 2
128698: EQUAL
128699: IFFALSE 128709
// viewRange := 16 ;
128701: LD_ADDR_VAR 0 7
128705: PUSH
128706: LD_INT 16
128708: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
128709: LD_VAR 0 1
128713: PPUSH
128714: LD_VAR 0 2
128718: PPUSH
128719: LD_VAR 0 3
128723: PPUSH
128724: CALL_OW 297
128728: PUSH
128729: LD_VAR 0 5
128733: GREATER
128734: IFFALSE 128813
// begin ComMoveXY ( unit , x , y ) ;
128736: LD_VAR 0 1
128740: PPUSH
128741: LD_VAR 0 2
128745: PPUSH
128746: LD_VAR 0 3
128750: PPUSH
128751: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128755: LD_INT 35
128757: PPUSH
128758: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
128762: LD_VAR 0 1
128766: PPUSH
128767: LD_VAR 0 2
128771: PPUSH
128772: LD_VAR 0 3
128776: PPUSH
128777: CALL 103813 0 3
128781: NOT
128782: IFFALSE 128786
// exit ;
128784: GO 129040
// until GetDistUnitXY ( unit , x , y ) < dist ;
128786: LD_VAR 0 1
128790: PPUSH
128791: LD_VAR 0 2
128795: PPUSH
128796: LD_VAR 0 3
128800: PPUSH
128801: CALL_OW 297
128805: PUSH
128806: LD_VAR 0 5
128810: LESS
128811: IFFALSE 128755
// end ; ComTurnXY ( unit , x , y ) ;
128813: LD_VAR 0 1
128817: PPUSH
128818: LD_VAR 0 2
128822: PPUSH
128823: LD_VAR 0 3
128827: PPUSH
128828: CALL_OW 118
// wait ( 5 ) ;
128832: LD_INT 5
128834: PPUSH
128835: CALL_OW 67
// _d := GetDir ( unit ) ;
128839: LD_ADDR_VAR 0 10
128843: PUSH
128844: LD_VAR 0 1
128848: PPUSH
128849: CALL_OW 254
128853: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
128854: LD_ADDR_VAR 0 8
128858: PUSH
128859: LD_VAR 0 1
128863: PPUSH
128864: CALL_OW 250
128868: PPUSH
128869: LD_VAR 0 10
128873: PPUSH
128874: LD_VAR 0 5
128878: PPUSH
128879: CALL_OW 272
128883: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
128884: LD_ADDR_VAR 0 9
128888: PUSH
128889: LD_VAR 0 1
128893: PPUSH
128894: CALL_OW 251
128898: PPUSH
128899: LD_VAR 0 10
128903: PPUSH
128904: LD_VAR 0 5
128908: PPUSH
128909: CALL_OW 273
128913: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
128914: LD_VAR 0 8
128918: PPUSH
128919: LD_VAR 0 9
128923: PPUSH
128924: CALL_OW 488
128928: NOT
128929: IFFALSE 128933
// exit ;
128931: GO 129040
// ComAnimCustom ( unit , 1 ) ;
128933: LD_VAR 0 1
128937: PPUSH
128938: LD_INT 1
128940: PPUSH
128941: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
128945: LD_VAR 0 8
128949: PPUSH
128950: LD_VAR 0 9
128954: PPUSH
128955: LD_VAR 0 6
128959: PPUSH
128960: LD_VAR 0 7
128964: PPUSH
128965: CALL_OW 330
// repeat wait ( 1 ) ;
128969: LD_INT 1
128971: PPUSH
128972: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
128976: LD_VAR 0 1
128980: PPUSH
128981: CALL_OW 316
128985: PUSH
128986: LD_VAR 0 1
128990: PPUSH
128991: CALL_OW 314
128995: OR
128996: PUSH
128997: LD_VAR 0 1
129001: PPUSH
129002: CALL_OW 302
129006: NOT
129007: OR
129008: PUSH
129009: LD_VAR 0 1
129013: PPUSH
129014: CALL_OW 301
129018: OR
129019: IFFALSE 128969
// RemoveSeeing ( _x , _y , side ) ;
129021: LD_VAR 0 8
129025: PPUSH
129026: LD_VAR 0 9
129030: PPUSH
129031: LD_VAR 0 6
129035: PPUSH
129036: CALL_OW 331
// end ; end_of_file
129040: LD_VAR 0 4
129044: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
129045: LD_INT 0
129047: PPUSH
129048: PPUSH
129049: PPUSH
129050: PPUSH
129051: PPUSH
129052: PPUSH
129053: PPUSH
129054: PPUSH
129055: PPUSH
129056: PPUSH
129057: PPUSH
129058: PPUSH
129059: PPUSH
129060: PPUSH
129061: PPUSH
129062: PPUSH
129063: PPUSH
129064: PPUSH
129065: PPUSH
129066: PPUSH
129067: PPUSH
129068: PPUSH
129069: PPUSH
129070: PPUSH
129071: PPUSH
129072: PPUSH
129073: PPUSH
129074: PPUSH
129075: PPUSH
129076: PPUSH
129077: PPUSH
129078: PPUSH
129079: PPUSH
129080: PPUSH
// if not list then
129081: LD_VAR 0 1
129085: NOT
129086: IFFALSE 129090
// exit ;
129088: GO 133749
// base := list [ 1 ] ;
129090: LD_ADDR_VAR 0 3
129094: PUSH
129095: LD_VAR 0 1
129099: PUSH
129100: LD_INT 1
129102: ARRAY
129103: ST_TO_ADDR
// group := list [ 2 ] ;
129104: LD_ADDR_VAR 0 4
129108: PUSH
129109: LD_VAR 0 1
129113: PUSH
129114: LD_INT 2
129116: ARRAY
129117: ST_TO_ADDR
// path := list [ 3 ] ;
129118: LD_ADDR_VAR 0 5
129122: PUSH
129123: LD_VAR 0 1
129127: PUSH
129128: LD_INT 3
129130: ARRAY
129131: ST_TO_ADDR
// flags := list [ 4 ] ;
129132: LD_ADDR_VAR 0 6
129136: PUSH
129137: LD_VAR 0 1
129141: PUSH
129142: LD_INT 4
129144: ARRAY
129145: ST_TO_ADDR
// mined := [ ] ;
129146: LD_ADDR_VAR 0 27
129150: PUSH
129151: EMPTY
129152: ST_TO_ADDR
// bombed := [ ] ;
129153: LD_ADDR_VAR 0 28
129157: PUSH
129158: EMPTY
129159: ST_TO_ADDR
// healers := [ ] ;
129160: LD_ADDR_VAR 0 31
129164: PUSH
129165: EMPTY
129166: ST_TO_ADDR
// to_heal := [ ] ;
129167: LD_ADDR_VAR 0 30
129171: PUSH
129172: EMPTY
129173: ST_TO_ADDR
// repairs := [ ] ;
129174: LD_ADDR_VAR 0 33
129178: PUSH
129179: EMPTY
129180: ST_TO_ADDR
// to_repair := [ ] ;
129181: LD_ADDR_VAR 0 32
129185: PUSH
129186: EMPTY
129187: ST_TO_ADDR
// if not group or not path then
129188: LD_VAR 0 4
129192: NOT
129193: PUSH
129194: LD_VAR 0 5
129198: NOT
129199: OR
129200: IFFALSE 129204
// exit ;
129202: GO 133749
// side := GetSide ( group [ 1 ] ) ;
129204: LD_ADDR_VAR 0 35
129208: PUSH
129209: LD_VAR 0 4
129213: PUSH
129214: LD_INT 1
129216: ARRAY
129217: PPUSH
129218: CALL_OW 255
129222: ST_TO_ADDR
// if flags then
129223: LD_VAR 0 6
129227: IFFALSE 129371
// begin f_ignore_area := flags [ 1 ] ;
129229: LD_ADDR_VAR 0 17
129233: PUSH
129234: LD_VAR 0 6
129238: PUSH
129239: LD_INT 1
129241: ARRAY
129242: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
129243: LD_ADDR_VAR 0 18
129247: PUSH
129248: LD_VAR 0 6
129252: PUSH
129253: LD_INT 2
129255: ARRAY
129256: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
129257: LD_ADDR_VAR 0 19
129261: PUSH
129262: LD_VAR 0 6
129266: PUSH
129267: LD_INT 3
129269: ARRAY
129270: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
129271: LD_ADDR_VAR 0 20
129275: PUSH
129276: LD_VAR 0 6
129280: PUSH
129281: LD_INT 4
129283: ARRAY
129284: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
129285: LD_ADDR_VAR 0 21
129289: PUSH
129290: LD_VAR 0 6
129294: PUSH
129295: LD_INT 5
129297: ARRAY
129298: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
129299: LD_ADDR_VAR 0 22
129303: PUSH
129304: LD_VAR 0 6
129308: PUSH
129309: LD_INT 6
129311: ARRAY
129312: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
129313: LD_ADDR_VAR 0 23
129317: PUSH
129318: LD_VAR 0 6
129322: PUSH
129323: LD_INT 7
129325: ARRAY
129326: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
129327: LD_ADDR_VAR 0 24
129331: PUSH
129332: LD_VAR 0 6
129336: PUSH
129337: LD_INT 8
129339: ARRAY
129340: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
129341: LD_ADDR_VAR 0 25
129345: PUSH
129346: LD_VAR 0 6
129350: PUSH
129351: LD_INT 9
129353: ARRAY
129354: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
129355: LD_ADDR_VAR 0 26
129359: PUSH
129360: LD_VAR 0 6
129364: PUSH
129365: LD_INT 10
129367: ARRAY
129368: ST_TO_ADDR
// end else
129369: GO 129451
// begin f_ignore_area := false ;
129371: LD_ADDR_VAR 0 17
129375: PUSH
129376: LD_INT 0
129378: ST_TO_ADDR
// f_capture := false ;
129379: LD_ADDR_VAR 0 18
129383: PUSH
129384: LD_INT 0
129386: ST_TO_ADDR
// f_ignore_civ := false ;
129387: LD_ADDR_VAR 0 19
129391: PUSH
129392: LD_INT 0
129394: ST_TO_ADDR
// f_murder := false ;
129395: LD_ADDR_VAR 0 20
129399: PUSH
129400: LD_INT 0
129402: ST_TO_ADDR
// f_mines := false ;
129403: LD_ADDR_VAR 0 21
129407: PUSH
129408: LD_INT 0
129410: ST_TO_ADDR
// f_repair := false ;
129411: LD_ADDR_VAR 0 22
129415: PUSH
129416: LD_INT 0
129418: ST_TO_ADDR
// f_heal := false ;
129419: LD_ADDR_VAR 0 23
129423: PUSH
129424: LD_INT 0
129426: ST_TO_ADDR
// f_spacetime := false ;
129427: LD_ADDR_VAR 0 24
129431: PUSH
129432: LD_INT 0
129434: ST_TO_ADDR
// f_attack_depot := false ;
129435: LD_ADDR_VAR 0 25
129439: PUSH
129440: LD_INT 0
129442: ST_TO_ADDR
// f_crawl := false ;
129443: LD_ADDR_VAR 0 26
129447: PUSH
129448: LD_INT 0
129450: ST_TO_ADDR
// end ; if f_heal then
129451: LD_VAR 0 23
129455: IFFALSE 129482
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
129457: LD_ADDR_VAR 0 31
129461: PUSH
129462: LD_VAR 0 4
129466: PPUSH
129467: LD_INT 25
129469: PUSH
129470: LD_INT 4
129472: PUSH
129473: EMPTY
129474: LIST
129475: LIST
129476: PPUSH
129477: CALL_OW 72
129481: ST_TO_ADDR
// if f_repair then
129482: LD_VAR 0 22
129486: IFFALSE 129513
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
129488: LD_ADDR_VAR 0 33
129492: PUSH
129493: LD_VAR 0 4
129497: PPUSH
129498: LD_INT 25
129500: PUSH
129501: LD_INT 3
129503: PUSH
129504: EMPTY
129505: LIST
129506: LIST
129507: PPUSH
129508: CALL_OW 72
129512: ST_TO_ADDR
// units_path := [ ] ;
129513: LD_ADDR_VAR 0 16
129517: PUSH
129518: EMPTY
129519: ST_TO_ADDR
// for i = 1 to group do
129520: LD_ADDR_VAR 0 7
129524: PUSH
129525: DOUBLE
129526: LD_INT 1
129528: DEC
129529: ST_TO_ADDR
129530: LD_VAR 0 4
129534: PUSH
129535: FOR_TO
129536: IFFALSE 129565
// units_path := Replace ( units_path , i , path ) ;
129538: LD_ADDR_VAR 0 16
129542: PUSH
129543: LD_VAR 0 16
129547: PPUSH
129548: LD_VAR 0 7
129552: PPUSH
129553: LD_VAR 0 5
129557: PPUSH
129558: CALL_OW 1
129562: ST_TO_ADDR
129563: GO 129535
129565: POP
129566: POP
// repeat for i = group downto 1 do
129567: LD_ADDR_VAR 0 7
129571: PUSH
129572: DOUBLE
129573: LD_VAR 0 4
129577: INC
129578: ST_TO_ADDR
129579: LD_INT 1
129581: PUSH
129582: FOR_DOWNTO
129583: IFFALSE 133705
// begin wait ( 5 ) ;
129585: LD_INT 5
129587: PPUSH
129588: CALL_OW 67
// tmp := [ ] ;
129592: LD_ADDR_VAR 0 14
129596: PUSH
129597: EMPTY
129598: ST_TO_ADDR
// attacking := false ;
129599: LD_ADDR_VAR 0 29
129603: PUSH
129604: LD_INT 0
129606: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
129607: LD_VAR 0 4
129611: PUSH
129612: LD_VAR 0 7
129616: ARRAY
129617: PPUSH
129618: CALL_OW 301
129622: PUSH
129623: LD_VAR 0 4
129627: PUSH
129628: LD_VAR 0 7
129632: ARRAY
129633: NOT
129634: OR
129635: IFFALSE 129744
// begin if GetType ( group [ i ] ) = unit_human then
129637: LD_VAR 0 4
129641: PUSH
129642: LD_VAR 0 7
129646: ARRAY
129647: PPUSH
129648: CALL_OW 247
129652: PUSH
129653: LD_INT 1
129655: EQUAL
129656: IFFALSE 129702
// begin to_heal := to_heal diff group [ i ] ;
129658: LD_ADDR_VAR 0 30
129662: PUSH
129663: LD_VAR 0 30
129667: PUSH
129668: LD_VAR 0 4
129672: PUSH
129673: LD_VAR 0 7
129677: ARRAY
129678: DIFF
129679: ST_TO_ADDR
// healers := healers diff group [ i ] ;
129680: LD_ADDR_VAR 0 31
129684: PUSH
129685: LD_VAR 0 31
129689: PUSH
129690: LD_VAR 0 4
129694: PUSH
129695: LD_VAR 0 7
129699: ARRAY
129700: DIFF
129701: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
129702: LD_ADDR_VAR 0 4
129706: PUSH
129707: LD_VAR 0 4
129711: PPUSH
129712: LD_VAR 0 7
129716: PPUSH
129717: CALL_OW 3
129721: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
129722: LD_ADDR_VAR 0 16
129726: PUSH
129727: LD_VAR 0 16
129731: PPUSH
129732: LD_VAR 0 7
129736: PPUSH
129737: CALL_OW 3
129741: ST_TO_ADDR
// continue ;
129742: GO 129582
// end ; if f_repair then
129744: LD_VAR 0 22
129748: IFFALSE 130237
// begin if GetType ( group [ i ] ) = unit_vehicle then
129750: LD_VAR 0 4
129754: PUSH
129755: LD_VAR 0 7
129759: ARRAY
129760: PPUSH
129761: CALL_OW 247
129765: PUSH
129766: LD_INT 2
129768: EQUAL
129769: IFFALSE 129959
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
129771: LD_VAR 0 4
129775: PUSH
129776: LD_VAR 0 7
129780: ARRAY
129781: PPUSH
129782: CALL_OW 256
129786: PUSH
129787: LD_INT 700
129789: LESS
129790: PUSH
129791: LD_VAR 0 4
129795: PUSH
129796: LD_VAR 0 7
129800: ARRAY
129801: PUSH
129802: LD_VAR 0 32
129806: IN
129807: NOT
129808: AND
129809: IFFALSE 129833
// to_repair := to_repair union group [ i ] ;
129811: LD_ADDR_VAR 0 32
129815: PUSH
129816: LD_VAR 0 32
129820: PUSH
129821: LD_VAR 0 4
129825: PUSH
129826: LD_VAR 0 7
129830: ARRAY
129831: UNION
129832: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
129833: LD_VAR 0 4
129837: PUSH
129838: LD_VAR 0 7
129842: ARRAY
129843: PPUSH
129844: CALL_OW 256
129848: PUSH
129849: LD_INT 1000
129851: EQUAL
129852: PUSH
129853: LD_VAR 0 4
129857: PUSH
129858: LD_VAR 0 7
129862: ARRAY
129863: PUSH
129864: LD_VAR 0 32
129868: IN
129869: AND
129870: IFFALSE 129894
// to_repair := to_repair diff group [ i ] ;
129872: LD_ADDR_VAR 0 32
129876: PUSH
129877: LD_VAR 0 32
129881: PUSH
129882: LD_VAR 0 4
129886: PUSH
129887: LD_VAR 0 7
129891: ARRAY
129892: DIFF
129893: ST_TO_ADDR
// if group [ i ] in to_repair then
129894: LD_VAR 0 4
129898: PUSH
129899: LD_VAR 0 7
129903: ARRAY
129904: PUSH
129905: LD_VAR 0 32
129909: IN
129910: IFFALSE 129957
// begin if not IsInArea ( group [ i ] , f_repair ) then
129912: LD_VAR 0 4
129916: PUSH
129917: LD_VAR 0 7
129921: ARRAY
129922: PPUSH
129923: LD_VAR 0 22
129927: PPUSH
129928: CALL_OW 308
129932: NOT
129933: IFFALSE 129955
// ComMoveToArea ( group [ i ] , f_repair ) ;
129935: LD_VAR 0 4
129939: PUSH
129940: LD_VAR 0 7
129944: ARRAY
129945: PPUSH
129946: LD_VAR 0 22
129950: PPUSH
129951: CALL_OW 113
// continue ;
129955: GO 129582
// end ; end else
129957: GO 130237
// if group [ i ] in repairs then
129959: LD_VAR 0 4
129963: PUSH
129964: LD_VAR 0 7
129968: ARRAY
129969: PUSH
129970: LD_VAR 0 33
129974: IN
129975: IFFALSE 130237
// begin if IsInUnit ( group [ i ] ) then
129977: LD_VAR 0 4
129981: PUSH
129982: LD_VAR 0 7
129986: ARRAY
129987: PPUSH
129988: CALL_OW 310
129992: IFFALSE 130060
// begin z := IsInUnit ( group [ i ] ) ;
129994: LD_ADDR_VAR 0 13
129998: PUSH
129999: LD_VAR 0 4
130003: PUSH
130004: LD_VAR 0 7
130008: ARRAY
130009: PPUSH
130010: CALL_OW 310
130014: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
130015: LD_VAR 0 13
130019: PUSH
130020: LD_VAR 0 32
130024: IN
130025: PUSH
130026: LD_VAR 0 13
130030: PPUSH
130031: LD_VAR 0 22
130035: PPUSH
130036: CALL_OW 308
130040: AND
130041: IFFALSE 130058
// ComExitVehicle ( group [ i ] ) ;
130043: LD_VAR 0 4
130047: PUSH
130048: LD_VAR 0 7
130052: ARRAY
130053: PPUSH
130054: CALL_OW 121
// end else
130058: GO 130237
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
130060: LD_ADDR_VAR 0 13
130064: PUSH
130065: LD_VAR 0 4
130069: PPUSH
130070: LD_INT 95
130072: PUSH
130073: LD_VAR 0 22
130077: PUSH
130078: EMPTY
130079: LIST
130080: LIST
130081: PUSH
130082: LD_INT 58
130084: PUSH
130085: EMPTY
130086: LIST
130087: PUSH
130088: EMPTY
130089: LIST
130090: LIST
130091: PPUSH
130092: CALL_OW 72
130096: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
130097: LD_VAR 0 4
130101: PUSH
130102: LD_VAR 0 7
130106: ARRAY
130107: PPUSH
130108: CALL_OW 314
130112: NOT
130113: IFFALSE 130235
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
130115: LD_ADDR_VAR 0 10
130119: PUSH
130120: LD_VAR 0 13
130124: PPUSH
130125: LD_VAR 0 4
130129: PUSH
130130: LD_VAR 0 7
130134: ARRAY
130135: PPUSH
130136: CALL_OW 74
130140: ST_TO_ADDR
// if not x then
130141: LD_VAR 0 10
130145: NOT
130146: IFFALSE 130150
// continue ;
130148: GO 129582
// if GetLives ( x ) < 1000 then
130150: LD_VAR 0 10
130154: PPUSH
130155: CALL_OW 256
130159: PUSH
130160: LD_INT 1000
130162: LESS
130163: IFFALSE 130187
// ComRepairVehicle ( group [ i ] , x ) else
130165: LD_VAR 0 4
130169: PUSH
130170: LD_VAR 0 7
130174: ARRAY
130175: PPUSH
130176: LD_VAR 0 10
130180: PPUSH
130181: CALL_OW 129
130185: GO 130235
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
130187: LD_VAR 0 23
130191: PUSH
130192: LD_VAR 0 4
130196: PUSH
130197: LD_VAR 0 7
130201: ARRAY
130202: PPUSH
130203: CALL_OW 256
130207: PUSH
130208: LD_INT 1000
130210: LESS
130211: AND
130212: NOT
130213: IFFALSE 130235
// ComEnterUnit ( group [ i ] , x ) ;
130215: LD_VAR 0 4
130219: PUSH
130220: LD_VAR 0 7
130224: ARRAY
130225: PPUSH
130226: LD_VAR 0 10
130230: PPUSH
130231: CALL_OW 120
// end ; continue ;
130235: GO 129582
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
130237: LD_VAR 0 23
130241: PUSH
130242: LD_VAR 0 4
130246: PUSH
130247: LD_VAR 0 7
130251: ARRAY
130252: PPUSH
130253: CALL_OW 247
130257: PUSH
130258: LD_INT 1
130260: EQUAL
130261: AND
130262: IFFALSE 130740
// begin if group [ i ] in healers then
130264: LD_VAR 0 4
130268: PUSH
130269: LD_VAR 0 7
130273: ARRAY
130274: PUSH
130275: LD_VAR 0 31
130279: IN
130280: IFFALSE 130553
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
130282: LD_VAR 0 4
130286: PUSH
130287: LD_VAR 0 7
130291: ARRAY
130292: PPUSH
130293: LD_VAR 0 23
130297: PPUSH
130298: CALL_OW 308
130302: NOT
130303: PUSH
130304: LD_VAR 0 4
130308: PUSH
130309: LD_VAR 0 7
130313: ARRAY
130314: PPUSH
130315: CALL_OW 314
130319: NOT
130320: AND
130321: IFFALSE 130345
// ComMoveToArea ( group [ i ] , f_heal ) else
130323: LD_VAR 0 4
130327: PUSH
130328: LD_VAR 0 7
130332: ARRAY
130333: PPUSH
130334: LD_VAR 0 23
130338: PPUSH
130339: CALL_OW 113
130343: GO 130551
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
130345: LD_VAR 0 4
130349: PUSH
130350: LD_VAR 0 7
130354: ARRAY
130355: PPUSH
130356: CALL 102396 0 1
130360: PPUSH
130361: CALL_OW 256
130365: PUSH
130366: LD_INT 1000
130368: EQUAL
130369: IFFALSE 130388
// ComStop ( group [ i ] ) else
130371: LD_VAR 0 4
130375: PUSH
130376: LD_VAR 0 7
130380: ARRAY
130381: PPUSH
130382: CALL_OW 141
130386: GO 130551
// if not HasTask ( group [ i ] ) and to_heal then
130388: LD_VAR 0 4
130392: PUSH
130393: LD_VAR 0 7
130397: ARRAY
130398: PPUSH
130399: CALL_OW 314
130403: NOT
130404: PUSH
130405: LD_VAR 0 30
130409: AND
130410: IFFALSE 130551
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
130412: LD_ADDR_VAR 0 13
130416: PUSH
130417: LD_VAR 0 30
130421: PPUSH
130422: LD_INT 3
130424: PUSH
130425: LD_INT 54
130427: PUSH
130428: EMPTY
130429: LIST
130430: PUSH
130431: EMPTY
130432: LIST
130433: LIST
130434: PPUSH
130435: CALL_OW 72
130439: PPUSH
130440: LD_VAR 0 4
130444: PUSH
130445: LD_VAR 0 7
130449: ARRAY
130450: PPUSH
130451: CALL_OW 74
130455: ST_TO_ADDR
// if z then
130456: LD_VAR 0 13
130460: IFFALSE 130551
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
130462: LD_INT 91
130464: PUSH
130465: LD_VAR 0 13
130469: PUSH
130470: LD_INT 10
130472: PUSH
130473: EMPTY
130474: LIST
130475: LIST
130476: LIST
130477: PUSH
130478: LD_INT 81
130480: PUSH
130481: LD_VAR 0 13
130485: PPUSH
130486: CALL_OW 255
130490: PUSH
130491: EMPTY
130492: LIST
130493: LIST
130494: PUSH
130495: EMPTY
130496: LIST
130497: LIST
130498: PPUSH
130499: CALL_OW 69
130503: PUSH
130504: LD_INT 0
130506: EQUAL
130507: IFFALSE 130531
// ComHeal ( group [ i ] , z ) else
130509: LD_VAR 0 4
130513: PUSH
130514: LD_VAR 0 7
130518: ARRAY
130519: PPUSH
130520: LD_VAR 0 13
130524: PPUSH
130525: CALL_OW 128
130529: GO 130551
// ComMoveToArea ( group [ i ] , f_heal ) ;
130531: LD_VAR 0 4
130535: PUSH
130536: LD_VAR 0 7
130540: ARRAY
130541: PPUSH
130542: LD_VAR 0 23
130546: PPUSH
130547: CALL_OW 113
// end ; continue ;
130551: GO 129582
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
130553: LD_VAR 0 4
130557: PUSH
130558: LD_VAR 0 7
130562: ARRAY
130563: PPUSH
130564: CALL_OW 256
130568: PUSH
130569: LD_INT 700
130571: LESS
130572: PUSH
130573: LD_VAR 0 4
130577: PUSH
130578: LD_VAR 0 7
130582: ARRAY
130583: PUSH
130584: LD_VAR 0 30
130588: IN
130589: NOT
130590: AND
130591: IFFALSE 130615
// to_heal := to_heal union group [ i ] ;
130593: LD_ADDR_VAR 0 30
130597: PUSH
130598: LD_VAR 0 30
130602: PUSH
130603: LD_VAR 0 4
130607: PUSH
130608: LD_VAR 0 7
130612: ARRAY
130613: UNION
130614: ST_TO_ADDR
// if group [ i ] in to_heal then
130615: LD_VAR 0 4
130619: PUSH
130620: LD_VAR 0 7
130624: ARRAY
130625: PUSH
130626: LD_VAR 0 30
130630: IN
130631: IFFALSE 130740
// begin if GetLives ( group [ i ] ) = 1000 then
130633: LD_VAR 0 4
130637: PUSH
130638: LD_VAR 0 7
130642: ARRAY
130643: PPUSH
130644: CALL_OW 256
130648: PUSH
130649: LD_INT 1000
130651: EQUAL
130652: IFFALSE 130678
// to_heal := to_heal diff group [ i ] else
130654: LD_ADDR_VAR 0 30
130658: PUSH
130659: LD_VAR 0 30
130663: PUSH
130664: LD_VAR 0 4
130668: PUSH
130669: LD_VAR 0 7
130673: ARRAY
130674: DIFF
130675: ST_TO_ADDR
130676: GO 130740
// begin if not IsInArea ( group [ i ] , to_heal ) then
130678: LD_VAR 0 4
130682: PUSH
130683: LD_VAR 0 7
130687: ARRAY
130688: PPUSH
130689: LD_VAR 0 30
130693: PPUSH
130694: CALL_OW 308
130698: NOT
130699: IFFALSE 130723
// ComMoveToArea ( group [ i ] , f_heal ) else
130701: LD_VAR 0 4
130705: PUSH
130706: LD_VAR 0 7
130710: ARRAY
130711: PPUSH
130712: LD_VAR 0 23
130716: PPUSH
130717: CALL_OW 113
130721: GO 130738
// ComHold ( group [ i ] ) ;
130723: LD_VAR 0 4
130727: PUSH
130728: LD_VAR 0 7
130732: ARRAY
130733: PPUSH
130734: CALL_OW 140
// continue ;
130738: GO 129582
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
130740: LD_VAR 0 4
130744: PUSH
130745: LD_VAR 0 7
130749: ARRAY
130750: PPUSH
130751: LD_INT 10
130753: PPUSH
130754: CALL 100167 0 2
130758: NOT
130759: PUSH
130760: LD_VAR 0 16
130764: PUSH
130765: LD_VAR 0 7
130769: ARRAY
130770: PUSH
130771: EMPTY
130772: EQUAL
130773: NOT
130774: AND
130775: IFFALSE 131041
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
130777: LD_VAR 0 4
130781: PUSH
130782: LD_VAR 0 7
130786: ARRAY
130787: PPUSH
130788: CALL_OW 262
130792: PUSH
130793: LD_INT 1
130795: PUSH
130796: LD_INT 2
130798: PUSH
130799: EMPTY
130800: LIST
130801: LIST
130802: IN
130803: IFFALSE 130844
// if GetFuel ( group [ i ] ) < 10 then
130805: LD_VAR 0 4
130809: PUSH
130810: LD_VAR 0 7
130814: ARRAY
130815: PPUSH
130816: CALL_OW 261
130820: PUSH
130821: LD_INT 10
130823: LESS
130824: IFFALSE 130844
// SetFuel ( group [ i ] , 12 ) ;
130826: LD_VAR 0 4
130830: PUSH
130831: LD_VAR 0 7
130835: ARRAY
130836: PPUSH
130837: LD_INT 12
130839: PPUSH
130840: CALL_OW 240
// if units_path [ i ] then
130844: LD_VAR 0 16
130848: PUSH
130849: LD_VAR 0 7
130853: ARRAY
130854: IFFALSE 131039
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
130856: LD_VAR 0 4
130860: PUSH
130861: LD_VAR 0 7
130865: ARRAY
130866: PPUSH
130867: LD_VAR 0 16
130871: PUSH
130872: LD_VAR 0 7
130876: ARRAY
130877: PUSH
130878: LD_INT 1
130880: ARRAY
130881: PUSH
130882: LD_INT 1
130884: ARRAY
130885: PPUSH
130886: LD_VAR 0 16
130890: PUSH
130891: LD_VAR 0 7
130895: ARRAY
130896: PUSH
130897: LD_INT 1
130899: ARRAY
130900: PUSH
130901: LD_INT 2
130903: ARRAY
130904: PPUSH
130905: CALL_OW 297
130909: PUSH
130910: LD_INT 6
130912: GREATER
130913: IFFALSE 130988
// begin if not HasTask ( group [ i ] ) then
130915: LD_VAR 0 4
130919: PUSH
130920: LD_VAR 0 7
130924: ARRAY
130925: PPUSH
130926: CALL_OW 314
130930: NOT
130931: IFFALSE 130986
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
130933: LD_VAR 0 4
130937: PUSH
130938: LD_VAR 0 7
130942: ARRAY
130943: PPUSH
130944: LD_VAR 0 16
130948: PUSH
130949: LD_VAR 0 7
130953: ARRAY
130954: PUSH
130955: LD_INT 1
130957: ARRAY
130958: PUSH
130959: LD_INT 1
130961: ARRAY
130962: PPUSH
130963: LD_VAR 0 16
130967: PUSH
130968: LD_VAR 0 7
130972: ARRAY
130973: PUSH
130974: LD_INT 1
130976: ARRAY
130977: PUSH
130978: LD_INT 2
130980: ARRAY
130981: PPUSH
130982: CALL_OW 114
// end else
130986: GO 131039
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
130988: LD_ADDR_VAR 0 15
130992: PUSH
130993: LD_VAR 0 16
130997: PUSH
130998: LD_VAR 0 7
131002: ARRAY
131003: PPUSH
131004: LD_INT 1
131006: PPUSH
131007: CALL_OW 3
131011: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
131012: LD_ADDR_VAR 0 16
131016: PUSH
131017: LD_VAR 0 16
131021: PPUSH
131022: LD_VAR 0 7
131026: PPUSH
131027: LD_VAR 0 15
131031: PPUSH
131032: CALL_OW 1
131036: ST_TO_ADDR
// continue ;
131037: GO 129582
// end ; end ; end else
131039: GO 133703
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
131041: LD_ADDR_VAR 0 14
131045: PUSH
131046: LD_INT 81
131048: PUSH
131049: LD_VAR 0 4
131053: PUSH
131054: LD_VAR 0 7
131058: ARRAY
131059: PPUSH
131060: CALL_OW 255
131064: PUSH
131065: EMPTY
131066: LIST
131067: LIST
131068: PPUSH
131069: CALL_OW 69
131073: ST_TO_ADDR
// if not tmp then
131074: LD_VAR 0 14
131078: NOT
131079: IFFALSE 131083
// continue ;
131081: GO 129582
// if f_ignore_area then
131083: LD_VAR 0 17
131087: IFFALSE 131175
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
131089: LD_ADDR_VAR 0 15
131093: PUSH
131094: LD_VAR 0 14
131098: PPUSH
131099: LD_INT 3
131101: PUSH
131102: LD_INT 92
131104: PUSH
131105: LD_VAR 0 17
131109: PUSH
131110: LD_INT 1
131112: ARRAY
131113: PUSH
131114: LD_VAR 0 17
131118: PUSH
131119: LD_INT 2
131121: ARRAY
131122: PUSH
131123: LD_VAR 0 17
131127: PUSH
131128: LD_INT 3
131130: ARRAY
131131: PUSH
131132: EMPTY
131133: LIST
131134: LIST
131135: LIST
131136: LIST
131137: PUSH
131138: EMPTY
131139: LIST
131140: LIST
131141: PPUSH
131142: CALL_OW 72
131146: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
131147: LD_VAR 0 14
131151: PUSH
131152: LD_VAR 0 15
131156: DIFF
131157: IFFALSE 131175
// tmp := tmp diff tmp2 ;
131159: LD_ADDR_VAR 0 14
131163: PUSH
131164: LD_VAR 0 14
131168: PUSH
131169: LD_VAR 0 15
131173: DIFF
131174: ST_TO_ADDR
// end ; if not f_murder then
131175: LD_VAR 0 20
131179: NOT
131180: IFFALSE 131238
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
131182: LD_ADDR_VAR 0 15
131186: PUSH
131187: LD_VAR 0 14
131191: PPUSH
131192: LD_INT 3
131194: PUSH
131195: LD_INT 50
131197: PUSH
131198: EMPTY
131199: LIST
131200: PUSH
131201: EMPTY
131202: LIST
131203: LIST
131204: PPUSH
131205: CALL_OW 72
131209: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
131210: LD_VAR 0 14
131214: PUSH
131215: LD_VAR 0 15
131219: DIFF
131220: IFFALSE 131238
// tmp := tmp diff tmp2 ;
131222: LD_ADDR_VAR 0 14
131226: PUSH
131227: LD_VAR 0 14
131231: PUSH
131232: LD_VAR 0 15
131236: DIFF
131237: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
131238: LD_ADDR_VAR 0 14
131242: PUSH
131243: LD_VAR 0 4
131247: PUSH
131248: LD_VAR 0 7
131252: ARRAY
131253: PPUSH
131254: LD_VAR 0 14
131258: PPUSH
131259: LD_INT 1
131261: PPUSH
131262: LD_INT 1
131264: PPUSH
131265: CALL 73108 0 4
131269: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
131270: LD_VAR 0 4
131274: PUSH
131275: LD_VAR 0 7
131279: ARRAY
131280: PPUSH
131281: CALL_OW 257
131285: PUSH
131286: LD_INT 1
131288: EQUAL
131289: IFFALSE 131737
// begin if WantPlant ( group [ i ] ) then
131291: LD_VAR 0 4
131295: PUSH
131296: LD_VAR 0 7
131300: ARRAY
131301: PPUSH
131302: CALL 72609 0 1
131306: IFFALSE 131310
// continue ;
131308: GO 129582
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
131310: LD_VAR 0 18
131314: PUSH
131315: LD_VAR 0 4
131319: PUSH
131320: LD_VAR 0 7
131324: ARRAY
131325: PPUSH
131326: CALL_OW 310
131330: NOT
131331: AND
131332: PUSH
131333: LD_VAR 0 14
131337: PUSH
131338: LD_INT 1
131340: ARRAY
131341: PUSH
131342: LD_VAR 0 14
131346: PPUSH
131347: LD_INT 21
131349: PUSH
131350: LD_INT 2
131352: PUSH
131353: EMPTY
131354: LIST
131355: LIST
131356: PUSH
131357: LD_INT 58
131359: PUSH
131360: EMPTY
131361: LIST
131362: PUSH
131363: EMPTY
131364: LIST
131365: LIST
131366: PPUSH
131367: CALL_OW 72
131371: IN
131372: AND
131373: IFFALSE 131409
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
131375: LD_VAR 0 4
131379: PUSH
131380: LD_VAR 0 7
131384: ARRAY
131385: PPUSH
131386: LD_VAR 0 14
131390: PUSH
131391: LD_INT 1
131393: ARRAY
131394: PPUSH
131395: CALL_OW 120
// attacking := true ;
131399: LD_ADDR_VAR 0 29
131403: PUSH
131404: LD_INT 1
131406: ST_TO_ADDR
// continue ;
131407: GO 129582
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
131409: LD_VAR 0 26
131413: PUSH
131414: LD_VAR 0 4
131418: PUSH
131419: LD_VAR 0 7
131423: ARRAY
131424: PPUSH
131425: CALL_OW 257
131429: PUSH
131430: LD_INT 1
131432: EQUAL
131433: AND
131434: PUSH
131435: LD_VAR 0 4
131439: PUSH
131440: LD_VAR 0 7
131444: ARRAY
131445: PPUSH
131446: CALL_OW 256
131450: PUSH
131451: LD_INT 800
131453: LESS
131454: AND
131455: PUSH
131456: LD_VAR 0 4
131460: PUSH
131461: LD_VAR 0 7
131465: ARRAY
131466: PPUSH
131467: CALL_OW 318
131471: NOT
131472: AND
131473: IFFALSE 131490
// ComCrawl ( group [ i ] ) ;
131475: LD_VAR 0 4
131479: PUSH
131480: LD_VAR 0 7
131484: ARRAY
131485: PPUSH
131486: CALL_OW 137
// if f_mines then
131490: LD_VAR 0 21
131494: IFFALSE 131737
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
131496: LD_VAR 0 14
131500: PUSH
131501: LD_INT 1
131503: ARRAY
131504: PPUSH
131505: CALL_OW 247
131509: PUSH
131510: LD_INT 3
131512: EQUAL
131513: PUSH
131514: LD_VAR 0 14
131518: PUSH
131519: LD_INT 1
131521: ARRAY
131522: PUSH
131523: LD_VAR 0 27
131527: IN
131528: NOT
131529: AND
131530: IFFALSE 131737
// begin x := GetX ( tmp [ 1 ] ) ;
131532: LD_ADDR_VAR 0 10
131536: PUSH
131537: LD_VAR 0 14
131541: PUSH
131542: LD_INT 1
131544: ARRAY
131545: PPUSH
131546: CALL_OW 250
131550: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
131551: LD_ADDR_VAR 0 11
131555: PUSH
131556: LD_VAR 0 14
131560: PUSH
131561: LD_INT 1
131563: ARRAY
131564: PPUSH
131565: CALL_OW 251
131569: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
131570: LD_ADDR_VAR 0 12
131574: PUSH
131575: LD_VAR 0 4
131579: PUSH
131580: LD_VAR 0 7
131584: ARRAY
131585: PPUSH
131586: CALL 100252 0 1
131590: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
131591: LD_VAR 0 4
131595: PUSH
131596: LD_VAR 0 7
131600: ARRAY
131601: PPUSH
131602: LD_VAR 0 10
131606: PPUSH
131607: LD_VAR 0 11
131611: PPUSH
131612: LD_VAR 0 14
131616: PUSH
131617: LD_INT 1
131619: ARRAY
131620: PPUSH
131621: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
131625: LD_VAR 0 4
131629: PUSH
131630: LD_VAR 0 7
131634: ARRAY
131635: PPUSH
131636: LD_VAR 0 10
131640: PPUSH
131641: LD_VAR 0 12
131645: PPUSH
131646: LD_INT 7
131648: PPUSH
131649: CALL_OW 272
131653: PPUSH
131654: LD_VAR 0 11
131658: PPUSH
131659: LD_VAR 0 12
131663: PPUSH
131664: LD_INT 7
131666: PPUSH
131667: CALL_OW 273
131671: PPUSH
131672: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
131676: LD_VAR 0 4
131680: PUSH
131681: LD_VAR 0 7
131685: ARRAY
131686: PPUSH
131687: LD_INT 71
131689: PPUSH
131690: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
131694: LD_ADDR_VAR 0 27
131698: PUSH
131699: LD_VAR 0 27
131703: PPUSH
131704: LD_VAR 0 27
131708: PUSH
131709: LD_INT 1
131711: PLUS
131712: PPUSH
131713: LD_VAR 0 14
131717: PUSH
131718: LD_INT 1
131720: ARRAY
131721: PPUSH
131722: CALL_OW 1
131726: ST_TO_ADDR
// attacking := true ;
131727: LD_ADDR_VAR 0 29
131731: PUSH
131732: LD_INT 1
131734: ST_TO_ADDR
// continue ;
131735: GO 129582
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
131737: LD_VAR 0 4
131741: PUSH
131742: LD_VAR 0 7
131746: ARRAY
131747: PPUSH
131748: CALL_OW 257
131752: PUSH
131753: LD_INT 17
131755: EQUAL
131756: PUSH
131757: LD_VAR 0 4
131761: PUSH
131762: LD_VAR 0 7
131766: ARRAY
131767: PPUSH
131768: CALL_OW 110
131772: PUSH
131773: LD_INT 71
131775: EQUAL
131776: NOT
131777: AND
131778: IFFALSE 131924
// begin attacking := false ;
131780: LD_ADDR_VAR 0 29
131784: PUSH
131785: LD_INT 0
131787: ST_TO_ADDR
// k := 5 ;
131788: LD_ADDR_VAR 0 9
131792: PUSH
131793: LD_INT 5
131795: ST_TO_ADDR
// if tmp < k then
131796: LD_VAR 0 14
131800: PUSH
131801: LD_VAR 0 9
131805: LESS
131806: IFFALSE 131818
// k := tmp ;
131808: LD_ADDR_VAR 0 9
131812: PUSH
131813: LD_VAR 0 14
131817: ST_TO_ADDR
// for j = 1 to k do
131818: LD_ADDR_VAR 0 8
131822: PUSH
131823: DOUBLE
131824: LD_INT 1
131826: DEC
131827: ST_TO_ADDR
131828: LD_VAR 0 9
131832: PUSH
131833: FOR_TO
131834: IFFALSE 131922
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
131836: LD_VAR 0 14
131840: PUSH
131841: LD_VAR 0 8
131845: ARRAY
131846: PUSH
131847: LD_VAR 0 14
131851: PPUSH
131852: LD_INT 58
131854: PUSH
131855: EMPTY
131856: LIST
131857: PPUSH
131858: CALL_OW 72
131862: IN
131863: NOT
131864: IFFALSE 131920
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131866: LD_VAR 0 4
131870: PUSH
131871: LD_VAR 0 7
131875: ARRAY
131876: PPUSH
131877: LD_VAR 0 14
131881: PUSH
131882: LD_VAR 0 8
131886: ARRAY
131887: PPUSH
131888: CALL_OW 115
// attacking := true ;
131892: LD_ADDR_VAR 0 29
131896: PUSH
131897: LD_INT 1
131899: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
131900: LD_VAR 0 4
131904: PUSH
131905: LD_VAR 0 7
131909: ARRAY
131910: PPUSH
131911: LD_INT 71
131913: PPUSH
131914: CALL_OW 109
// continue ;
131918: GO 131833
// end ; end ;
131920: GO 131833
131922: POP
131923: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
131924: LD_VAR 0 4
131928: PUSH
131929: LD_VAR 0 7
131933: ARRAY
131934: PPUSH
131935: CALL_OW 257
131939: PUSH
131940: LD_INT 8
131942: EQUAL
131943: PUSH
131944: LD_VAR 0 4
131948: PUSH
131949: LD_VAR 0 7
131953: ARRAY
131954: PPUSH
131955: CALL_OW 264
131959: PUSH
131960: LD_INT 28
131962: PUSH
131963: LD_INT 45
131965: PUSH
131966: LD_INT 7
131968: PUSH
131969: LD_INT 47
131971: PUSH
131972: EMPTY
131973: LIST
131974: LIST
131975: LIST
131976: LIST
131977: IN
131978: OR
131979: IFFALSE 132235
// begin attacking := false ;
131981: LD_ADDR_VAR 0 29
131985: PUSH
131986: LD_INT 0
131988: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
131989: LD_VAR 0 14
131993: PUSH
131994: LD_INT 1
131996: ARRAY
131997: PPUSH
131998: CALL_OW 266
132002: PUSH
132003: LD_INT 32
132005: PUSH
132006: LD_INT 31
132008: PUSH
132009: LD_INT 33
132011: PUSH
132012: LD_INT 4
132014: PUSH
132015: LD_INT 5
132017: PUSH
132018: EMPTY
132019: LIST
132020: LIST
132021: LIST
132022: LIST
132023: LIST
132024: IN
132025: IFFALSE 132211
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
132027: LD_ADDR_VAR 0 9
132031: PUSH
132032: LD_VAR 0 14
132036: PUSH
132037: LD_INT 1
132039: ARRAY
132040: PPUSH
132041: CALL_OW 266
132045: PPUSH
132046: LD_VAR 0 14
132050: PUSH
132051: LD_INT 1
132053: ARRAY
132054: PPUSH
132055: CALL_OW 250
132059: PPUSH
132060: LD_VAR 0 14
132064: PUSH
132065: LD_INT 1
132067: ARRAY
132068: PPUSH
132069: CALL_OW 251
132073: PPUSH
132074: LD_VAR 0 14
132078: PUSH
132079: LD_INT 1
132081: ARRAY
132082: PPUSH
132083: CALL_OW 254
132087: PPUSH
132088: LD_VAR 0 14
132092: PUSH
132093: LD_INT 1
132095: ARRAY
132096: PPUSH
132097: CALL_OW 248
132101: PPUSH
132102: LD_INT 0
132104: PPUSH
132105: CALL 81622 0 6
132109: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
132110: LD_ADDR_VAR 0 8
132114: PUSH
132115: LD_VAR 0 4
132119: PUSH
132120: LD_VAR 0 7
132124: ARRAY
132125: PPUSH
132126: LD_VAR 0 9
132130: PPUSH
132131: CALL 100365 0 2
132135: ST_TO_ADDR
// if j then
132136: LD_VAR 0 8
132140: IFFALSE 132209
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
132142: LD_VAR 0 8
132146: PUSH
132147: LD_INT 1
132149: ARRAY
132150: PPUSH
132151: LD_VAR 0 8
132155: PUSH
132156: LD_INT 2
132158: ARRAY
132159: PPUSH
132160: CALL_OW 488
132164: IFFALSE 132209
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
132166: LD_VAR 0 4
132170: PUSH
132171: LD_VAR 0 7
132175: ARRAY
132176: PPUSH
132177: LD_VAR 0 8
132181: PUSH
132182: LD_INT 1
132184: ARRAY
132185: PPUSH
132186: LD_VAR 0 8
132190: PUSH
132191: LD_INT 2
132193: ARRAY
132194: PPUSH
132195: CALL_OW 116
// attacking := true ;
132199: LD_ADDR_VAR 0 29
132203: PUSH
132204: LD_INT 1
132206: ST_TO_ADDR
// continue ;
132207: GO 129582
// end ; end else
132209: GO 132235
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132211: LD_VAR 0 4
132215: PUSH
132216: LD_VAR 0 7
132220: ARRAY
132221: PPUSH
132222: LD_VAR 0 14
132226: PUSH
132227: LD_INT 1
132229: ARRAY
132230: PPUSH
132231: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
132235: LD_VAR 0 4
132239: PUSH
132240: LD_VAR 0 7
132244: ARRAY
132245: PPUSH
132246: CALL_OW 265
132250: PUSH
132251: LD_INT 11
132253: EQUAL
132254: IFFALSE 132532
// begin k := 10 ;
132256: LD_ADDR_VAR 0 9
132260: PUSH
132261: LD_INT 10
132263: ST_TO_ADDR
// x := 0 ;
132264: LD_ADDR_VAR 0 10
132268: PUSH
132269: LD_INT 0
132271: ST_TO_ADDR
// if tmp < k then
132272: LD_VAR 0 14
132276: PUSH
132277: LD_VAR 0 9
132281: LESS
132282: IFFALSE 132294
// k := tmp ;
132284: LD_ADDR_VAR 0 9
132288: PUSH
132289: LD_VAR 0 14
132293: ST_TO_ADDR
// for j = k downto 1 do
132294: LD_ADDR_VAR 0 8
132298: PUSH
132299: DOUBLE
132300: LD_VAR 0 9
132304: INC
132305: ST_TO_ADDR
132306: LD_INT 1
132308: PUSH
132309: FOR_DOWNTO
132310: IFFALSE 132385
// begin if GetType ( tmp [ j ] ) = unit_human then
132312: LD_VAR 0 14
132316: PUSH
132317: LD_VAR 0 8
132321: ARRAY
132322: PPUSH
132323: CALL_OW 247
132327: PUSH
132328: LD_INT 1
132330: EQUAL
132331: IFFALSE 132383
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
132333: LD_VAR 0 4
132337: PUSH
132338: LD_VAR 0 7
132342: ARRAY
132343: PPUSH
132344: LD_VAR 0 14
132348: PUSH
132349: LD_VAR 0 8
132353: ARRAY
132354: PPUSH
132355: CALL 100619 0 2
// x := tmp [ j ] ;
132359: LD_ADDR_VAR 0 10
132363: PUSH
132364: LD_VAR 0 14
132368: PUSH
132369: LD_VAR 0 8
132373: ARRAY
132374: ST_TO_ADDR
// attacking := true ;
132375: LD_ADDR_VAR 0 29
132379: PUSH
132380: LD_INT 1
132382: ST_TO_ADDR
// end ; end ;
132383: GO 132309
132385: POP
132386: POP
// if not x then
132387: LD_VAR 0 10
132391: NOT
132392: IFFALSE 132532
// begin attacking := true ;
132394: LD_ADDR_VAR 0 29
132398: PUSH
132399: LD_INT 1
132401: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
132402: LD_VAR 0 4
132406: PUSH
132407: LD_VAR 0 7
132411: ARRAY
132412: PPUSH
132413: CALL_OW 250
132417: PPUSH
132418: LD_VAR 0 4
132422: PUSH
132423: LD_VAR 0 7
132427: ARRAY
132428: PPUSH
132429: CALL_OW 251
132433: PPUSH
132434: CALL_OW 546
132438: PUSH
132439: LD_INT 2
132441: ARRAY
132442: PUSH
132443: LD_VAR 0 14
132447: PUSH
132448: LD_INT 1
132450: ARRAY
132451: PPUSH
132452: CALL_OW 250
132456: PPUSH
132457: LD_VAR 0 14
132461: PUSH
132462: LD_INT 1
132464: ARRAY
132465: PPUSH
132466: CALL_OW 251
132470: PPUSH
132471: CALL_OW 546
132475: PUSH
132476: LD_INT 2
132478: ARRAY
132479: EQUAL
132480: IFFALSE 132508
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
132482: LD_VAR 0 4
132486: PUSH
132487: LD_VAR 0 7
132491: ARRAY
132492: PPUSH
132493: LD_VAR 0 14
132497: PUSH
132498: LD_INT 1
132500: ARRAY
132501: PPUSH
132502: CALL 100619 0 2
132506: GO 132532
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132508: LD_VAR 0 4
132512: PUSH
132513: LD_VAR 0 7
132517: ARRAY
132518: PPUSH
132519: LD_VAR 0 14
132523: PUSH
132524: LD_INT 1
132526: ARRAY
132527: PPUSH
132528: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
132532: LD_VAR 0 4
132536: PUSH
132537: LD_VAR 0 7
132541: ARRAY
132542: PPUSH
132543: CALL_OW 264
132547: PUSH
132548: LD_INT 29
132550: EQUAL
132551: IFFALSE 132917
// begin if WantsToAttack ( group [ i ] ) in bombed then
132553: LD_VAR 0 4
132557: PUSH
132558: LD_VAR 0 7
132562: ARRAY
132563: PPUSH
132564: CALL_OW 319
132568: PUSH
132569: LD_VAR 0 28
132573: IN
132574: IFFALSE 132578
// continue ;
132576: GO 129582
// k := 8 ;
132578: LD_ADDR_VAR 0 9
132582: PUSH
132583: LD_INT 8
132585: ST_TO_ADDR
// x := 0 ;
132586: LD_ADDR_VAR 0 10
132590: PUSH
132591: LD_INT 0
132593: ST_TO_ADDR
// if tmp < k then
132594: LD_VAR 0 14
132598: PUSH
132599: LD_VAR 0 9
132603: LESS
132604: IFFALSE 132616
// k := tmp ;
132606: LD_ADDR_VAR 0 9
132610: PUSH
132611: LD_VAR 0 14
132615: ST_TO_ADDR
// for j = 1 to k do
132616: LD_ADDR_VAR 0 8
132620: PUSH
132621: DOUBLE
132622: LD_INT 1
132624: DEC
132625: ST_TO_ADDR
132626: LD_VAR 0 9
132630: PUSH
132631: FOR_TO
132632: IFFALSE 132764
// begin if GetType ( tmp [ j ] ) = unit_building then
132634: LD_VAR 0 14
132638: PUSH
132639: LD_VAR 0 8
132643: ARRAY
132644: PPUSH
132645: CALL_OW 247
132649: PUSH
132650: LD_INT 3
132652: EQUAL
132653: IFFALSE 132762
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
132655: LD_VAR 0 14
132659: PUSH
132660: LD_VAR 0 8
132664: ARRAY
132665: PUSH
132666: LD_VAR 0 28
132670: IN
132671: NOT
132672: PUSH
132673: LD_VAR 0 14
132677: PUSH
132678: LD_VAR 0 8
132682: ARRAY
132683: PPUSH
132684: CALL_OW 313
132688: AND
132689: IFFALSE 132762
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132691: LD_VAR 0 4
132695: PUSH
132696: LD_VAR 0 7
132700: ARRAY
132701: PPUSH
132702: LD_VAR 0 14
132706: PUSH
132707: LD_VAR 0 8
132711: ARRAY
132712: PPUSH
132713: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
132717: LD_ADDR_VAR 0 28
132721: PUSH
132722: LD_VAR 0 28
132726: PPUSH
132727: LD_VAR 0 28
132731: PUSH
132732: LD_INT 1
132734: PLUS
132735: PPUSH
132736: LD_VAR 0 14
132740: PUSH
132741: LD_VAR 0 8
132745: ARRAY
132746: PPUSH
132747: CALL_OW 1
132751: ST_TO_ADDR
// attacking := true ;
132752: LD_ADDR_VAR 0 29
132756: PUSH
132757: LD_INT 1
132759: ST_TO_ADDR
// break ;
132760: GO 132764
// end ; end ;
132762: GO 132631
132764: POP
132765: POP
// if not attacking and f_attack_depot then
132766: LD_VAR 0 29
132770: NOT
132771: PUSH
132772: LD_VAR 0 25
132776: AND
132777: IFFALSE 132872
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132779: LD_ADDR_VAR 0 13
132783: PUSH
132784: LD_VAR 0 14
132788: PPUSH
132789: LD_INT 2
132791: PUSH
132792: LD_INT 30
132794: PUSH
132795: LD_INT 0
132797: PUSH
132798: EMPTY
132799: LIST
132800: LIST
132801: PUSH
132802: LD_INT 30
132804: PUSH
132805: LD_INT 1
132807: PUSH
132808: EMPTY
132809: LIST
132810: LIST
132811: PUSH
132812: EMPTY
132813: LIST
132814: LIST
132815: LIST
132816: PPUSH
132817: CALL_OW 72
132821: ST_TO_ADDR
// if z then
132822: LD_VAR 0 13
132826: IFFALSE 132872
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
132828: LD_VAR 0 4
132832: PUSH
132833: LD_VAR 0 7
132837: ARRAY
132838: PPUSH
132839: LD_VAR 0 13
132843: PPUSH
132844: LD_VAR 0 4
132848: PUSH
132849: LD_VAR 0 7
132853: ARRAY
132854: PPUSH
132855: CALL_OW 74
132859: PPUSH
132860: CALL_OW 115
// attacking := true ;
132864: LD_ADDR_VAR 0 29
132868: PUSH
132869: LD_INT 1
132871: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
132872: LD_VAR 0 4
132876: PUSH
132877: LD_VAR 0 7
132881: ARRAY
132882: PPUSH
132883: CALL_OW 256
132887: PUSH
132888: LD_INT 500
132890: LESS
132891: IFFALSE 132917
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132893: LD_VAR 0 4
132897: PUSH
132898: LD_VAR 0 7
132902: ARRAY
132903: PPUSH
132904: LD_VAR 0 14
132908: PUSH
132909: LD_INT 1
132911: ARRAY
132912: PPUSH
132913: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
132917: LD_VAR 0 4
132921: PUSH
132922: LD_VAR 0 7
132926: ARRAY
132927: PPUSH
132928: CALL_OW 264
132932: PUSH
132933: LD_INT 49
132935: EQUAL
132936: IFFALSE 133057
// begin if not HasTask ( group [ i ] ) then
132938: LD_VAR 0 4
132942: PUSH
132943: LD_VAR 0 7
132947: ARRAY
132948: PPUSH
132949: CALL_OW 314
132953: NOT
132954: IFFALSE 133057
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
132956: LD_ADDR_VAR 0 9
132960: PUSH
132961: LD_INT 81
132963: PUSH
132964: LD_VAR 0 4
132968: PUSH
132969: LD_VAR 0 7
132973: ARRAY
132974: PPUSH
132975: CALL_OW 255
132979: PUSH
132980: EMPTY
132981: LIST
132982: LIST
132983: PPUSH
132984: CALL_OW 69
132988: PPUSH
132989: LD_VAR 0 4
132993: PUSH
132994: LD_VAR 0 7
132998: ARRAY
132999: PPUSH
133000: CALL_OW 74
133004: ST_TO_ADDR
// if k then
133005: LD_VAR 0 9
133009: IFFALSE 133057
// if GetDistUnits ( group [ i ] , k ) > 10 then
133011: LD_VAR 0 4
133015: PUSH
133016: LD_VAR 0 7
133020: ARRAY
133021: PPUSH
133022: LD_VAR 0 9
133026: PPUSH
133027: CALL_OW 296
133031: PUSH
133032: LD_INT 10
133034: GREATER
133035: IFFALSE 133057
// ComMoveUnit ( group [ i ] , k ) ;
133037: LD_VAR 0 4
133041: PUSH
133042: LD_VAR 0 7
133046: ARRAY
133047: PPUSH
133048: LD_VAR 0 9
133052: PPUSH
133053: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
133057: LD_VAR 0 4
133061: PUSH
133062: LD_VAR 0 7
133066: ARRAY
133067: PPUSH
133068: CALL_OW 256
133072: PUSH
133073: LD_INT 250
133075: LESS
133076: PUSH
133077: LD_VAR 0 4
133081: PUSH
133082: LD_VAR 0 7
133086: ARRAY
133087: PUSH
133088: LD_INT 21
133090: PUSH
133091: LD_INT 2
133093: PUSH
133094: EMPTY
133095: LIST
133096: LIST
133097: PUSH
133098: LD_INT 23
133100: PUSH
133101: LD_INT 2
133103: PUSH
133104: EMPTY
133105: LIST
133106: LIST
133107: PUSH
133108: EMPTY
133109: LIST
133110: LIST
133111: PPUSH
133112: CALL_OW 69
133116: IN
133117: AND
133118: IFFALSE 133243
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
133120: LD_ADDR_VAR 0 9
133124: PUSH
133125: LD_OWVAR 3
133129: PUSH
133130: LD_VAR 0 4
133134: PUSH
133135: LD_VAR 0 7
133139: ARRAY
133140: DIFF
133141: PPUSH
133142: LD_VAR 0 4
133146: PUSH
133147: LD_VAR 0 7
133151: ARRAY
133152: PPUSH
133153: CALL_OW 74
133157: ST_TO_ADDR
// if not k then
133158: LD_VAR 0 9
133162: NOT
133163: IFFALSE 133167
// continue ;
133165: GO 129582
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
133167: LD_VAR 0 9
133171: PUSH
133172: LD_INT 81
133174: PUSH
133175: LD_VAR 0 4
133179: PUSH
133180: LD_VAR 0 7
133184: ARRAY
133185: PPUSH
133186: CALL_OW 255
133190: PUSH
133191: EMPTY
133192: LIST
133193: LIST
133194: PPUSH
133195: CALL_OW 69
133199: IN
133200: PUSH
133201: LD_VAR 0 9
133205: PPUSH
133206: LD_VAR 0 4
133210: PUSH
133211: LD_VAR 0 7
133215: ARRAY
133216: PPUSH
133217: CALL_OW 296
133221: PUSH
133222: LD_INT 5
133224: LESS
133225: AND
133226: IFFALSE 133243
// ComAutodestruct ( group [ i ] ) ;
133228: LD_VAR 0 4
133232: PUSH
133233: LD_VAR 0 7
133237: ARRAY
133238: PPUSH
133239: CALL 100517 0 1
// end ; if f_attack_depot then
133243: LD_VAR 0 25
133247: IFFALSE 133359
// begin k := 6 ;
133249: LD_ADDR_VAR 0 9
133253: PUSH
133254: LD_INT 6
133256: ST_TO_ADDR
// if tmp < k then
133257: LD_VAR 0 14
133261: PUSH
133262: LD_VAR 0 9
133266: LESS
133267: IFFALSE 133279
// k := tmp ;
133269: LD_ADDR_VAR 0 9
133273: PUSH
133274: LD_VAR 0 14
133278: ST_TO_ADDR
// for j = 1 to k do
133279: LD_ADDR_VAR 0 8
133283: PUSH
133284: DOUBLE
133285: LD_INT 1
133287: DEC
133288: ST_TO_ADDR
133289: LD_VAR 0 9
133293: PUSH
133294: FOR_TO
133295: IFFALSE 133357
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
133297: LD_VAR 0 8
133301: PPUSH
133302: CALL_OW 266
133306: PUSH
133307: LD_INT 0
133309: PUSH
133310: LD_INT 1
133312: PUSH
133313: EMPTY
133314: LIST
133315: LIST
133316: IN
133317: IFFALSE 133355
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133319: LD_VAR 0 4
133323: PUSH
133324: LD_VAR 0 7
133328: ARRAY
133329: PPUSH
133330: LD_VAR 0 14
133334: PUSH
133335: LD_VAR 0 8
133339: ARRAY
133340: PPUSH
133341: CALL_OW 115
// attacking := true ;
133345: LD_ADDR_VAR 0 29
133349: PUSH
133350: LD_INT 1
133352: ST_TO_ADDR
// break ;
133353: GO 133357
// end ;
133355: GO 133294
133357: POP
133358: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
133359: LD_VAR 0 4
133363: PUSH
133364: LD_VAR 0 7
133368: ARRAY
133369: PPUSH
133370: CALL_OW 302
133374: PUSH
133375: LD_VAR 0 29
133379: NOT
133380: AND
133381: IFFALSE 133703
// begin if GetTag ( group [ i ] ) = 71 then
133383: LD_VAR 0 4
133387: PUSH
133388: LD_VAR 0 7
133392: ARRAY
133393: PPUSH
133394: CALL_OW 110
133398: PUSH
133399: LD_INT 71
133401: EQUAL
133402: IFFALSE 133443
// begin if HasTask ( group [ i ] ) then
133404: LD_VAR 0 4
133408: PUSH
133409: LD_VAR 0 7
133413: ARRAY
133414: PPUSH
133415: CALL_OW 314
133419: IFFALSE 133425
// continue else
133421: GO 129582
133423: GO 133443
// SetTag ( group [ i ] , 0 ) ;
133425: LD_VAR 0 4
133429: PUSH
133430: LD_VAR 0 7
133434: ARRAY
133435: PPUSH
133436: LD_INT 0
133438: PPUSH
133439: CALL_OW 109
// end ; k := 8 ;
133443: LD_ADDR_VAR 0 9
133447: PUSH
133448: LD_INT 8
133450: ST_TO_ADDR
// x := 0 ;
133451: LD_ADDR_VAR 0 10
133455: PUSH
133456: LD_INT 0
133458: ST_TO_ADDR
// if tmp < k then
133459: LD_VAR 0 14
133463: PUSH
133464: LD_VAR 0 9
133468: LESS
133469: IFFALSE 133481
// k := tmp ;
133471: LD_ADDR_VAR 0 9
133475: PUSH
133476: LD_VAR 0 14
133480: ST_TO_ADDR
// for j = 1 to k do
133481: LD_ADDR_VAR 0 8
133485: PUSH
133486: DOUBLE
133487: LD_INT 1
133489: DEC
133490: ST_TO_ADDR
133491: LD_VAR 0 9
133495: PUSH
133496: FOR_TO
133497: IFFALSE 133595
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
133499: LD_VAR 0 14
133503: PUSH
133504: LD_VAR 0 8
133508: ARRAY
133509: PPUSH
133510: CALL_OW 247
133514: PUSH
133515: LD_INT 1
133517: EQUAL
133518: PUSH
133519: LD_VAR 0 14
133523: PUSH
133524: LD_VAR 0 8
133528: ARRAY
133529: PPUSH
133530: CALL_OW 256
133534: PUSH
133535: LD_INT 250
133537: LESS
133538: PUSH
133539: LD_VAR 0 20
133543: AND
133544: PUSH
133545: LD_VAR 0 20
133549: NOT
133550: PUSH
133551: LD_VAR 0 14
133555: PUSH
133556: LD_VAR 0 8
133560: ARRAY
133561: PPUSH
133562: CALL_OW 256
133566: PUSH
133567: LD_INT 250
133569: GREATEREQUAL
133570: AND
133571: OR
133572: AND
133573: IFFALSE 133593
// begin x := tmp [ j ] ;
133575: LD_ADDR_VAR 0 10
133579: PUSH
133580: LD_VAR 0 14
133584: PUSH
133585: LD_VAR 0 8
133589: ARRAY
133590: ST_TO_ADDR
// break ;
133591: GO 133595
// end ;
133593: GO 133496
133595: POP
133596: POP
// if x then
133597: LD_VAR 0 10
133601: IFFALSE 133625
// ComAttackUnit ( group [ i ] , x ) else
133603: LD_VAR 0 4
133607: PUSH
133608: LD_VAR 0 7
133612: ARRAY
133613: PPUSH
133614: LD_VAR 0 10
133618: PPUSH
133619: CALL_OW 115
133623: GO 133649
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133625: LD_VAR 0 4
133629: PUSH
133630: LD_VAR 0 7
133634: ARRAY
133635: PPUSH
133636: LD_VAR 0 14
133640: PUSH
133641: LD_INT 1
133643: ARRAY
133644: PPUSH
133645: CALL_OW 115
// if not HasTask ( group [ i ] ) then
133649: LD_VAR 0 4
133653: PUSH
133654: LD_VAR 0 7
133658: ARRAY
133659: PPUSH
133660: CALL_OW 314
133664: NOT
133665: IFFALSE 133703
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
133667: LD_VAR 0 4
133671: PUSH
133672: LD_VAR 0 7
133676: ARRAY
133677: PPUSH
133678: LD_VAR 0 14
133682: PPUSH
133683: LD_VAR 0 4
133687: PUSH
133688: LD_VAR 0 7
133692: ARRAY
133693: PPUSH
133694: CALL_OW 74
133698: PPUSH
133699: CALL_OW 115
// end ; end ; end ;
133703: GO 129582
133705: POP
133706: POP
// wait ( 0 0$2 ) ;
133707: LD_INT 70
133709: PPUSH
133710: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
133714: LD_VAR 0 4
133718: NOT
133719: PUSH
133720: LD_VAR 0 4
133724: PUSH
133725: EMPTY
133726: EQUAL
133727: OR
133728: PUSH
133729: LD_INT 81
133731: PUSH
133732: LD_VAR 0 35
133736: PUSH
133737: EMPTY
133738: LIST
133739: LIST
133740: PPUSH
133741: CALL_OW 69
133745: NOT
133746: OR
133747: IFFALSE 129567
// end ;
133749: LD_VAR 0 2
133753: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
133754: LD_INT 0
133756: PPUSH
133757: PPUSH
133758: PPUSH
133759: PPUSH
133760: PPUSH
133761: PPUSH
// if not base or not mc_bases [ base ] or not solds then
133762: LD_VAR 0 1
133766: NOT
133767: PUSH
133768: LD_EXP 100
133772: PUSH
133773: LD_VAR 0 1
133777: ARRAY
133778: NOT
133779: OR
133780: PUSH
133781: LD_VAR 0 2
133785: NOT
133786: OR
133787: IFFALSE 133791
// exit ;
133789: GO 134345
// side := mc_sides [ base ] ;
133791: LD_ADDR_VAR 0 6
133795: PUSH
133796: LD_EXP 126
133800: PUSH
133801: LD_VAR 0 1
133805: ARRAY
133806: ST_TO_ADDR
// if not side then
133807: LD_VAR 0 6
133811: NOT
133812: IFFALSE 133816
// exit ;
133814: GO 134345
// for i in solds do
133816: LD_ADDR_VAR 0 7
133820: PUSH
133821: LD_VAR 0 2
133825: PUSH
133826: FOR_IN
133827: IFFALSE 133888
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
133829: LD_VAR 0 7
133833: PPUSH
133834: CALL_OW 310
133838: PPUSH
133839: CALL_OW 266
133843: PUSH
133844: LD_INT 32
133846: PUSH
133847: LD_INT 31
133849: PUSH
133850: EMPTY
133851: LIST
133852: LIST
133853: IN
133854: IFFALSE 133874
// solds := solds diff i else
133856: LD_ADDR_VAR 0 2
133860: PUSH
133861: LD_VAR 0 2
133865: PUSH
133866: LD_VAR 0 7
133870: DIFF
133871: ST_TO_ADDR
133872: GO 133886
// SetTag ( i , 18 ) ;
133874: LD_VAR 0 7
133878: PPUSH
133879: LD_INT 18
133881: PPUSH
133882: CALL_OW 109
133886: GO 133826
133888: POP
133889: POP
// if not solds then
133890: LD_VAR 0 2
133894: NOT
133895: IFFALSE 133899
// exit ;
133897: GO 134345
// repeat wait ( 0 0$2 ) ;
133899: LD_INT 70
133901: PPUSH
133902: CALL_OW 67
// enemy := mc_scan [ base ] ;
133906: LD_ADDR_VAR 0 4
133910: PUSH
133911: LD_EXP 123
133915: PUSH
133916: LD_VAR 0 1
133920: ARRAY
133921: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133922: LD_EXP 100
133926: PUSH
133927: LD_VAR 0 1
133931: ARRAY
133932: NOT
133933: PUSH
133934: LD_EXP 100
133938: PUSH
133939: LD_VAR 0 1
133943: ARRAY
133944: PUSH
133945: EMPTY
133946: EQUAL
133947: OR
133948: IFFALSE 133985
// begin for i in solds do
133950: LD_ADDR_VAR 0 7
133954: PUSH
133955: LD_VAR 0 2
133959: PUSH
133960: FOR_IN
133961: IFFALSE 133974
// ComStop ( i ) ;
133963: LD_VAR 0 7
133967: PPUSH
133968: CALL_OW 141
133972: GO 133960
133974: POP
133975: POP
// solds := [ ] ;
133976: LD_ADDR_VAR 0 2
133980: PUSH
133981: EMPTY
133982: ST_TO_ADDR
// exit ;
133983: GO 134345
// end ; for i in solds do
133985: LD_ADDR_VAR 0 7
133989: PUSH
133990: LD_VAR 0 2
133994: PUSH
133995: FOR_IN
133996: IFFALSE 134317
// begin if IsInUnit ( i ) then
133998: LD_VAR 0 7
134002: PPUSH
134003: CALL_OW 310
134007: IFFALSE 134018
// ComExitBuilding ( i ) ;
134009: LD_VAR 0 7
134013: PPUSH
134014: CALL_OW 122
// if GetLives ( i ) > 500 then
134018: LD_VAR 0 7
134022: PPUSH
134023: CALL_OW 256
134027: PUSH
134028: LD_INT 500
134030: GREATER
134031: IFFALSE 134084
// begin e := NearestUnitToUnit ( enemy , i ) ;
134033: LD_ADDR_VAR 0 5
134037: PUSH
134038: LD_VAR 0 4
134042: PPUSH
134043: LD_VAR 0 7
134047: PPUSH
134048: CALL_OW 74
134052: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
134053: LD_VAR 0 7
134057: PPUSH
134058: LD_VAR 0 5
134062: PPUSH
134063: CALL_OW 250
134067: PPUSH
134068: LD_VAR 0 5
134072: PPUSH
134073: CALL_OW 251
134077: PPUSH
134078: CALL_OW 114
// end else
134082: GO 134315
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
134084: LD_VAR 0 7
134088: PPUSH
134089: LD_EXP 100
134093: PUSH
134094: LD_VAR 0 1
134098: ARRAY
134099: PPUSH
134100: LD_INT 2
134102: PUSH
134103: LD_INT 30
134105: PUSH
134106: LD_INT 0
134108: PUSH
134109: EMPTY
134110: LIST
134111: LIST
134112: PUSH
134113: LD_INT 30
134115: PUSH
134116: LD_INT 1
134118: PUSH
134119: EMPTY
134120: LIST
134121: LIST
134122: PUSH
134123: LD_INT 30
134125: PUSH
134126: LD_INT 6
134128: PUSH
134129: EMPTY
134130: LIST
134131: LIST
134132: PUSH
134133: EMPTY
134134: LIST
134135: LIST
134136: LIST
134137: LIST
134138: PPUSH
134139: CALL_OW 72
134143: PPUSH
134144: LD_VAR 0 7
134148: PPUSH
134149: CALL_OW 74
134153: PPUSH
134154: CALL_OW 296
134158: PUSH
134159: LD_INT 10
134161: GREATER
134162: IFFALSE 134315
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
134164: LD_ADDR_VAR 0 8
134168: PUSH
134169: LD_EXP 100
134173: PUSH
134174: LD_VAR 0 1
134178: ARRAY
134179: PPUSH
134180: LD_INT 2
134182: PUSH
134183: LD_INT 30
134185: PUSH
134186: LD_INT 0
134188: PUSH
134189: EMPTY
134190: LIST
134191: LIST
134192: PUSH
134193: LD_INT 30
134195: PUSH
134196: LD_INT 1
134198: PUSH
134199: EMPTY
134200: LIST
134201: LIST
134202: PUSH
134203: LD_INT 30
134205: PUSH
134206: LD_INT 6
134208: PUSH
134209: EMPTY
134210: LIST
134211: LIST
134212: PUSH
134213: EMPTY
134214: LIST
134215: LIST
134216: LIST
134217: LIST
134218: PPUSH
134219: CALL_OW 72
134223: PPUSH
134224: LD_VAR 0 7
134228: PPUSH
134229: CALL_OW 74
134233: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
134234: LD_VAR 0 7
134238: PPUSH
134239: LD_VAR 0 8
134243: PPUSH
134244: CALL_OW 250
134248: PPUSH
134249: LD_INT 3
134251: PPUSH
134252: LD_INT 5
134254: PPUSH
134255: CALL_OW 272
134259: PPUSH
134260: LD_VAR 0 8
134264: PPUSH
134265: CALL_OW 251
134269: PPUSH
134270: LD_INT 3
134272: PPUSH
134273: LD_INT 5
134275: PPUSH
134276: CALL_OW 273
134280: PPUSH
134281: CALL_OW 111
// SetTag ( i , 0 ) ;
134285: LD_VAR 0 7
134289: PPUSH
134290: LD_INT 0
134292: PPUSH
134293: CALL_OW 109
// solds := solds diff i ;
134297: LD_ADDR_VAR 0 2
134301: PUSH
134302: LD_VAR 0 2
134306: PUSH
134307: LD_VAR 0 7
134311: DIFF
134312: ST_TO_ADDR
// continue ;
134313: GO 133995
// end ; end ;
134315: GO 133995
134317: POP
134318: POP
// until not solds or not enemy ;
134319: LD_VAR 0 2
134323: NOT
134324: PUSH
134325: LD_VAR 0 4
134329: NOT
134330: OR
134331: IFFALSE 133899
// MC_Reset ( base , 18 ) ;
134333: LD_VAR 0 1
134337: PPUSH
134338: LD_INT 18
134340: PPUSH
134341: CALL 41033 0 2
// end ;
134345: LD_VAR 0 3
134349: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
134350: LD_INT 0
134352: PPUSH
134353: PPUSH
134354: PPUSH
134355: PPUSH
134356: PPUSH
134357: PPUSH
134358: PPUSH
134359: PPUSH
134360: PPUSH
134361: PPUSH
134362: PPUSH
134363: PPUSH
134364: PPUSH
134365: PPUSH
134366: PPUSH
134367: PPUSH
134368: PPUSH
134369: PPUSH
134370: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
134371: LD_ADDR_VAR 0 12
134375: PUSH
134376: LD_EXP 100
134380: PUSH
134381: LD_VAR 0 1
134385: ARRAY
134386: PPUSH
134387: LD_INT 25
134389: PUSH
134390: LD_INT 3
134392: PUSH
134393: EMPTY
134394: LIST
134395: LIST
134396: PPUSH
134397: CALL_OW 72
134401: ST_TO_ADDR
// if mc_remote_driver [ base ] then
134402: LD_EXP 140
134406: PUSH
134407: LD_VAR 0 1
134411: ARRAY
134412: IFFALSE 134436
// mechs := mechs diff mc_remote_driver [ base ] ;
134414: LD_ADDR_VAR 0 12
134418: PUSH
134419: LD_VAR 0 12
134423: PUSH
134424: LD_EXP 140
134428: PUSH
134429: LD_VAR 0 1
134433: ARRAY
134434: DIFF
134435: ST_TO_ADDR
// for i in mechs do
134436: LD_ADDR_VAR 0 4
134440: PUSH
134441: LD_VAR 0 12
134445: PUSH
134446: FOR_IN
134447: IFFALSE 134482
// if GetTag ( i ) > 0 then
134449: LD_VAR 0 4
134453: PPUSH
134454: CALL_OW 110
134458: PUSH
134459: LD_INT 0
134461: GREATER
134462: IFFALSE 134480
// mechs := mechs diff i ;
134464: LD_ADDR_VAR 0 12
134468: PUSH
134469: LD_VAR 0 12
134473: PUSH
134474: LD_VAR 0 4
134478: DIFF
134479: ST_TO_ADDR
134480: GO 134446
134482: POP
134483: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
134484: LD_ADDR_VAR 0 8
134488: PUSH
134489: LD_EXP 100
134493: PUSH
134494: LD_VAR 0 1
134498: ARRAY
134499: PPUSH
134500: LD_INT 2
134502: PUSH
134503: LD_INT 25
134505: PUSH
134506: LD_INT 1
134508: PUSH
134509: EMPTY
134510: LIST
134511: LIST
134512: PUSH
134513: LD_INT 25
134515: PUSH
134516: LD_INT 5
134518: PUSH
134519: EMPTY
134520: LIST
134521: LIST
134522: PUSH
134523: LD_INT 25
134525: PUSH
134526: LD_INT 8
134528: PUSH
134529: EMPTY
134530: LIST
134531: LIST
134532: PUSH
134533: LD_INT 25
134535: PUSH
134536: LD_INT 9
134538: PUSH
134539: EMPTY
134540: LIST
134541: LIST
134542: PUSH
134543: EMPTY
134544: LIST
134545: LIST
134546: LIST
134547: LIST
134548: LIST
134549: PPUSH
134550: CALL_OW 72
134554: ST_TO_ADDR
// if not defenders and not solds then
134555: LD_VAR 0 2
134559: NOT
134560: PUSH
134561: LD_VAR 0 8
134565: NOT
134566: AND
134567: IFFALSE 134571
// exit ;
134569: GO 136341
// depot_under_attack := false ;
134571: LD_ADDR_VAR 0 16
134575: PUSH
134576: LD_INT 0
134578: ST_TO_ADDR
// sold_defenders := [ ] ;
134579: LD_ADDR_VAR 0 17
134583: PUSH
134584: EMPTY
134585: ST_TO_ADDR
// if mechs then
134586: LD_VAR 0 12
134590: IFFALSE 134743
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
134592: LD_ADDR_VAR 0 4
134596: PUSH
134597: LD_VAR 0 2
134601: PPUSH
134602: LD_INT 21
134604: PUSH
134605: LD_INT 2
134607: PUSH
134608: EMPTY
134609: LIST
134610: LIST
134611: PPUSH
134612: CALL_OW 72
134616: PUSH
134617: FOR_IN
134618: IFFALSE 134741
// begin if GetTag ( i ) <> 20 then
134620: LD_VAR 0 4
134624: PPUSH
134625: CALL_OW 110
134629: PUSH
134630: LD_INT 20
134632: NONEQUAL
134633: IFFALSE 134647
// SetTag ( i , 20 ) ;
134635: LD_VAR 0 4
134639: PPUSH
134640: LD_INT 20
134642: PPUSH
134643: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
134647: LD_VAR 0 4
134651: PPUSH
134652: CALL_OW 263
134656: PUSH
134657: LD_INT 1
134659: EQUAL
134660: PUSH
134661: LD_VAR 0 4
134665: PPUSH
134666: CALL_OW 311
134670: NOT
134671: AND
134672: IFFALSE 134739
// begin un := mechs [ 1 ] ;
134674: LD_ADDR_VAR 0 10
134678: PUSH
134679: LD_VAR 0 12
134683: PUSH
134684: LD_INT 1
134686: ARRAY
134687: ST_TO_ADDR
// ComExit ( un ) ;
134688: LD_VAR 0 10
134692: PPUSH
134693: CALL 105402 0 1
// AddComEnterUnit ( un , i ) ;
134697: LD_VAR 0 10
134701: PPUSH
134702: LD_VAR 0 4
134706: PPUSH
134707: CALL_OW 180
// SetTag ( un , 19 ) ;
134711: LD_VAR 0 10
134715: PPUSH
134716: LD_INT 19
134718: PPUSH
134719: CALL_OW 109
// mechs := mechs diff un ;
134723: LD_ADDR_VAR 0 12
134727: PUSH
134728: LD_VAR 0 12
134732: PUSH
134733: LD_VAR 0 10
134737: DIFF
134738: ST_TO_ADDR
// end ; end ;
134739: GO 134617
134741: POP
134742: POP
// if solds then
134743: LD_VAR 0 8
134747: IFFALSE 134806
// for i in solds do
134749: LD_ADDR_VAR 0 4
134753: PUSH
134754: LD_VAR 0 8
134758: PUSH
134759: FOR_IN
134760: IFFALSE 134804
// if not GetTag ( i ) then
134762: LD_VAR 0 4
134766: PPUSH
134767: CALL_OW 110
134771: NOT
134772: IFFALSE 134802
// begin defenders := defenders union i ;
134774: LD_ADDR_VAR 0 2
134778: PUSH
134779: LD_VAR 0 2
134783: PUSH
134784: LD_VAR 0 4
134788: UNION
134789: ST_TO_ADDR
// SetTag ( i , 18 ) ;
134790: LD_VAR 0 4
134794: PPUSH
134795: LD_INT 18
134797: PPUSH
134798: CALL_OW 109
// end ;
134802: GO 134759
134804: POP
134805: POP
// repeat wait ( 0 0$2 ) ;
134806: LD_INT 70
134808: PPUSH
134809: CALL_OW 67
// enemy := mc_scan [ base ] ;
134813: LD_ADDR_VAR 0 21
134817: PUSH
134818: LD_EXP 123
134822: PUSH
134823: LD_VAR 0 1
134827: ARRAY
134828: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134829: LD_EXP 100
134833: PUSH
134834: LD_VAR 0 1
134838: ARRAY
134839: NOT
134840: PUSH
134841: LD_EXP 100
134845: PUSH
134846: LD_VAR 0 1
134850: ARRAY
134851: PUSH
134852: EMPTY
134853: EQUAL
134854: OR
134855: IFFALSE 134892
// begin for i in defenders do
134857: LD_ADDR_VAR 0 4
134861: PUSH
134862: LD_VAR 0 2
134866: PUSH
134867: FOR_IN
134868: IFFALSE 134881
// ComStop ( i ) ;
134870: LD_VAR 0 4
134874: PPUSH
134875: CALL_OW 141
134879: GO 134867
134881: POP
134882: POP
// defenders := [ ] ;
134883: LD_ADDR_VAR 0 2
134887: PUSH
134888: EMPTY
134889: ST_TO_ADDR
// exit ;
134890: GO 136341
// end ; for i in defenders do
134892: LD_ADDR_VAR 0 4
134896: PUSH
134897: LD_VAR 0 2
134901: PUSH
134902: FOR_IN
134903: IFFALSE 135801
// begin e := NearestUnitToUnit ( enemy , i ) ;
134905: LD_ADDR_VAR 0 13
134909: PUSH
134910: LD_VAR 0 21
134914: PPUSH
134915: LD_VAR 0 4
134919: PPUSH
134920: CALL_OW 74
134924: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134925: LD_ADDR_VAR 0 7
134929: PUSH
134930: LD_EXP 100
134934: PUSH
134935: LD_VAR 0 1
134939: ARRAY
134940: PPUSH
134941: LD_INT 2
134943: PUSH
134944: LD_INT 30
134946: PUSH
134947: LD_INT 0
134949: PUSH
134950: EMPTY
134951: LIST
134952: LIST
134953: PUSH
134954: LD_INT 30
134956: PUSH
134957: LD_INT 1
134959: PUSH
134960: EMPTY
134961: LIST
134962: LIST
134963: PUSH
134964: EMPTY
134965: LIST
134966: LIST
134967: LIST
134968: PPUSH
134969: CALL_OW 72
134973: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
134974: LD_ADDR_VAR 0 16
134978: PUSH
134979: LD_VAR 0 7
134983: NOT
134984: PUSH
134985: LD_VAR 0 7
134989: PPUSH
134990: LD_INT 3
134992: PUSH
134993: LD_INT 24
134995: PUSH
134996: LD_INT 600
134998: PUSH
134999: EMPTY
135000: LIST
135001: LIST
135002: PUSH
135003: EMPTY
135004: LIST
135005: LIST
135006: PPUSH
135007: CALL_OW 72
135011: OR
135012: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
135013: LD_VAR 0 4
135017: PPUSH
135018: CALL_OW 247
135022: PUSH
135023: LD_INT 2
135025: DOUBLE
135026: EQUAL
135027: IFTRUE 135031
135029: GO 135427
135031: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
135032: LD_VAR 0 4
135036: PPUSH
135037: CALL_OW 256
135041: PUSH
135042: LD_INT 1000
135044: EQUAL
135045: PUSH
135046: LD_VAR 0 4
135050: PPUSH
135051: LD_VAR 0 13
135055: PPUSH
135056: CALL_OW 296
135060: PUSH
135061: LD_INT 40
135063: LESS
135064: PUSH
135065: LD_VAR 0 13
135069: PPUSH
135070: LD_EXP 125
135074: PUSH
135075: LD_VAR 0 1
135079: ARRAY
135080: PPUSH
135081: CALL_OW 308
135085: OR
135086: AND
135087: IFFALSE 135209
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
135089: LD_VAR 0 4
135093: PPUSH
135094: CALL_OW 262
135098: PUSH
135099: LD_INT 1
135101: EQUAL
135102: PUSH
135103: LD_VAR 0 4
135107: PPUSH
135108: CALL_OW 261
135112: PUSH
135113: LD_INT 30
135115: LESS
135116: AND
135117: PUSH
135118: LD_VAR 0 7
135122: AND
135123: IFFALSE 135193
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
135125: LD_VAR 0 4
135129: PPUSH
135130: LD_VAR 0 7
135134: PPUSH
135135: LD_VAR 0 4
135139: PPUSH
135140: CALL_OW 74
135144: PPUSH
135145: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
135149: LD_VAR 0 4
135153: PPUSH
135154: LD_VAR 0 7
135158: PPUSH
135159: LD_VAR 0 4
135163: PPUSH
135164: CALL_OW 74
135168: PPUSH
135169: CALL_OW 296
135173: PUSH
135174: LD_INT 6
135176: LESS
135177: IFFALSE 135191
// SetFuel ( i , 100 ) ;
135179: LD_VAR 0 4
135183: PPUSH
135184: LD_INT 100
135186: PPUSH
135187: CALL_OW 240
// end else
135191: GO 135207
// ComAttackUnit ( i , e ) ;
135193: LD_VAR 0 4
135197: PPUSH
135198: LD_VAR 0 13
135202: PPUSH
135203: CALL_OW 115
// end else
135207: GO 135310
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
135209: LD_VAR 0 13
135213: PPUSH
135214: LD_EXP 125
135218: PUSH
135219: LD_VAR 0 1
135223: ARRAY
135224: PPUSH
135225: CALL_OW 308
135229: NOT
135230: PUSH
135231: LD_VAR 0 4
135235: PPUSH
135236: LD_VAR 0 13
135240: PPUSH
135241: CALL_OW 296
135245: PUSH
135246: LD_INT 40
135248: GREATEREQUAL
135249: AND
135250: PUSH
135251: LD_VAR 0 4
135255: PPUSH
135256: CALL_OW 256
135260: PUSH
135261: LD_INT 650
135263: LESSEQUAL
135264: OR
135265: PUSH
135266: LD_VAR 0 4
135270: PPUSH
135271: LD_EXP 124
135275: PUSH
135276: LD_VAR 0 1
135280: ARRAY
135281: PPUSH
135282: CALL_OW 308
135286: NOT
135287: AND
135288: IFFALSE 135310
// ComMoveToArea ( i , mc_parking [ base ] ) ;
135290: LD_VAR 0 4
135294: PPUSH
135295: LD_EXP 124
135299: PUSH
135300: LD_VAR 0 1
135304: ARRAY
135305: PPUSH
135306: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
135310: LD_VAR 0 4
135314: PPUSH
135315: CALL_OW 256
135319: PUSH
135320: LD_INT 1000
135322: LESS
135323: PUSH
135324: LD_VAR 0 4
135328: PPUSH
135329: CALL_OW 263
135333: PUSH
135334: LD_INT 1
135336: EQUAL
135337: AND
135338: PUSH
135339: LD_VAR 0 4
135343: PPUSH
135344: CALL_OW 311
135348: AND
135349: PUSH
135350: LD_VAR 0 4
135354: PPUSH
135355: LD_EXP 124
135359: PUSH
135360: LD_VAR 0 1
135364: ARRAY
135365: PPUSH
135366: CALL_OW 308
135370: AND
135371: IFFALSE 135425
// begin mech := IsDrivenBy ( i ) ;
135373: LD_ADDR_VAR 0 9
135377: PUSH
135378: LD_VAR 0 4
135382: PPUSH
135383: CALL_OW 311
135387: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
135388: LD_VAR 0 9
135392: PPUSH
135393: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
135397: LD_VAR 0 9
135401: PPUSH
135402: LD_VAR 0 4
135406: PPUSH
135407: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
135411: LD_VAR 0 9
135415: PPUSH
135416: LD_VAR 0 4
135420: PPUSH
135421: CALL_OW 180
// end ; end ; unit_human :
135425: GO 135772
135427: LD_INT 1
135429: DOUBLE
135430: EQUAL
135431: IFTRUE 135435
135433: GO 135771
135435: POP
// begin b := IsInUnit ( i ) ;
135436: LD_ADDR_VAR 0 18
135440: PUSH
135441: LD_VAR 0 4
135445: PPUSH
135446: CALL_OW 310
135450: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
135451: LD_ADDR_VAR 0 19
135455: PUSH
135456: LD_VAR 0 18
135460: NOT
135461: PUSH
135462: LD_VAR 0 18
135466: PPUSH
135467: CALL_OW 266
135471: PUSH
135472: LD_INT 32
135474: PUSH
135475: LD_INT 31
135477: PUSH
135478: EMPTY
135479: LIST
135480: LIST
135481: IN
135482: OR
135483: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
135484: LD_VAR 0 18
135488: PPUSH
135489: CALL_OW 266
135493: PUSH
135494: LD_INT 5
135496: EQUAL
135497: PUSH
135498: LD_VAR 0 4
135502: PPUSH
135503: CALL_OW 257
135507: PUSH
135508: LD_INT 1
135510: PUSH
135511: LD_INT 2
135513: PUSH
135514: LD_INT 3
135516: PUSH
135517: LD_INT 4
135519: PUSH
135520: EMPTY
135521: LIST
135522: LIST
135523: LIST
135524: LIST
135525: IN
135526: AND
135527: IFFALSE 135564
// begin class := AllowSpecClass ( i ) ;
135529: LD_ADDR_VAR 0 20
135533: PUSH
135534: LD_VAR 0 4
135538: PPUSH
135539: CALL 69322 0 1
135543: ST_TO_ADDR
// if class then
135544: LD_VAR 0 20
135548: IFFALSE 135564
// ComChangeProfession ( i , class ) ;
135550: LD_VAR 0 4
135554: PPUSH
135555: LD_VAR 0 20
135559: PPUSH
135560: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
135564: LD_VAR 0 16
135568: PUSH
135569: LD_VAR 0 2
135573: PPUSH
135574: LD_INT 21
135576: PUSH
135577: LD_INT 2
135579: PUSH
135580: EMPTY
135581: LIST
135582: LIST
135583: PPUSH
135584: CALL_OW 72
135588: PUSH
135589: LD_INT 1
135591: LESSEQUAL
135592: OR
135593: PUSH
135594: LD_VAR 0 19
135598: AND
135599: PUSH
135600: LD_VAR 0 4
135604: PUSH
135605: LD_VAR 0 17
135609: IN
135610: NOT
135611: AND
135612: IFFALSE 135705
// begin if b then
135614: LD_VAR 0 18
135618: IFFALSE 135667
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
135620: LD_VAR 0 18
135624: PPUSH
135625: LD_VAR 0 21
135629: PPUSH
135630: LD_VAR 0 18
135634: PPUSH
135635: CALL_OW 74
135639: PPUSH
135640: CALL_OW 296
135644: PUSH
135645: LD_INT 10
135647: LESS
135648: PUSH
135649: LD_VAR 0 18
135653: PPUSH
135654: CALL_OW 461
135658: PUSH
135659: LD_INT 7
135661: NONEQUAL
135662: AND
135663: IFFALSE 135667
// continue ;
135665: GO 134902
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
135667: LD_ADDR_VAR 0 17
135671: PUSH
135672: LD_VAR 0 17
135676: PPUSH
135677: LD_VAR 0 17
135681: PUSH
135682: LD_INT 1
135684: PLUS
135685: PPUSH
135686: LD_VAR 0 4
135690: PPUSH
135691: CALL_OW 1
135695: ST_TO_ADDR
// ComExitBuilding ( i ) ;
135696: LD_VAR 0 4
135700: PPUSH
135701: CALL_OW 122
// end ; if sold_defenders then
135705: LD_VAR 0 17
135709: IFFALSE 135769
// if i in sold_defenders then
135711: LD_VAR 0 4
135715: PUSH
135716: LD_VAR 0 17
135720: IN
135721: IFFALSE 135769
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
135723: LD_VAR 0 4
135727: PPUSH
135728: CALL_OW 314
135732: NOT
135733: PUSH
135734: LD_VAR 0 4
135738: PPUSH
135739: LD_VAR 0 13
135743: PPUSH
135744: CALL_OW 296
135748: PUSH
135749: LD_INT 30
135751: LESS
135752: AND
135753: IFFALSE 135769
// ComAttackUnit ( i , e ) ;
135755: LD_VAR 0 4
135759: PPUSH
135760: LD_VAR 0 13
135764: PPUSH
135765: CALL_OW 115
// end ; end ; end ;
135769: GO 135772
135771: POP
// if IsDead ( i ) then
135772: LD_VAR 0 4
135776: PPUSH
135777: CALL_OW 301
135781: IFFALSE 135799
// defenders := defenders diff i ;
135783: LD_ADDR_VAR 0 2
135787: PUSH
135788: LD_VAR 0 2
135792: PUSH
135793: LD_VAR 0 4
135797: DIFF
135798: ST_TO_ADDR
// end ;
135799: GO 134902
135801: POP
135802: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
135803: LD_VAR 0 21
135807: NOT
135808: PUSH
135809: LD_VAR 0 2
135813: NOT
135814: OR
135815: PUSH
135816: LD_EXP 100
135820: PUSH
135821: LD_VAR 0 1
135825: ARRAY
135826: NOT
135827: OR
135828: IFFALSE 134806
// MC_Reset ( base , 18 ) ;
135830: LD_VAR 0 1
135834: PPUSH
135835: LD_INT 18
135837: PPUSH
135838: CALL 41033 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135842: LD_ADDR_VAR 0 2
135846: PUSH
135847: LD_VAR 0 2
135851: PUSH
135852: LD_VAR 0 2
135856: PPUSH
135857: LD_INT 2
135859: PUSH
135860: LD_INT 25
135862: PUSH
135863: LD_INT 1
135865: PUSH
135866: EMPTY
135867: LIST
135868: LIST
135869: PUSH
135870: LD_INT 25
135872: PUSH
135873: LD_INT 5
135875: PUSH
135876: EMPTY
135877: LIST
135878: LIST
135879: PUSH
135880: LD_INT 25
135882: PUSH
135883: LD_INT 8
135885: PUSH
135886: EMPTY
135887: LIST
135888: LIST
135889: PUSH
135890: LD_INT 25
135892: PUSH
135893: LD_INT 9
135895: PUSH
135896: EMPTY
135897: LIST
135898: LIST
135899: PUSH
135900: EMPTY
135901: LIST
135902: LIST
135903: LIST
135904: LIST
135905: LIST
135906: PPUSH
135907: CALL_OW 72
135911: DIFF
135912: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
135913: LD_VAR 0 21
135917: NOT
135918: PUSH
135919: LD_VAR 0 2
135923: PPUSH
135924: LD_INT 21
135926: PUSH
135927: LD_INT 2
135929: PUSH
135930: EMPTY
135931: LIST
135932: LIST
135933: PPUSH
135934: CALL_OW 72
135938: AND
135939: IFFALSE 136277
// begin tmp := FilterByTag ( defenders , 19 ) ;
135941: LD_ADDR_VAR 0 11
135945: PUSH
135946: LD_VAR 0 2
135950: PPUSH
135951: LD_INT 19
135953: PPUSH
135954: CALL 102585 0 2
135958: ST_TO_ADDR
// if tmp then
135959: LD_VAR 0 11
135963: IFFALSE 136033
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
135965: LD_ADDR_VAR 0 11
135969: PUSH
135970: LD_VAR 0 11
135974: PPUSH
135975: LD_INT 25
135977: PUSH
135978: LD_INT 3
135980: PUSH
135981: EMPTY
135982: LIST
135983: LIST
135984: PPUSH
135985: CALL_OW 72
135989: ST_TO_ADDR
// if tmp then
135990: LD_VAR 0 11
135994: IFFALSE 136033
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
135996: LD_ADDR_EXP 112
136000: PUSH
136001: LD_EXP 112
136005: PPUSH
136006: LD_VAR 0 1
136010: PPUSH
136011: LD_EXP 112
136015: PUSH
136016: LD_VAR 0 1
136020: ARRAY
136021: PUSH
136022: LD_VAR 0 11
136026: UNION
136027: PPUSH
136028: CALL_OW 1
136032: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
136033: LD_VAR 0 1
136037: PPUSH
136038: LD_INT 19
136040: PPUSH
136041: CALL 41033 0 2
// repeat wait ( 0 0$1 ) ;
136045: LD_INT 35
136047: PPUSH
136048: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
136052: LD_EXP 100
136056: PUSH
136057: LD_VAR 0 1
136061: ARRAY
136062: NOT
136063: PUSH
136064: LD_EXP 100
136068: PUSH
136069: LD_VAR 0 1
136073: ARRAY
136074: PUSH
136075: EMPTY
136076: EQUAL
136077: OR
136078: IFFALSE 136115
// begin for i in defenders do
136080: LD_ADDR_VAR 0 4
136084: PUSH
136085: LD_VAR 0 2
136089: PUSH
136090: FOR_IN
136091: IFFALSE 136104
// ComStop ( i ) ;
136093: LD_VAR 0 4
136097: PPUSH
136098: CALL_OW 141
136102: GO 136090
136104: POP
136105: POP
// defenders := [ ] ;
136106: LD_ADDR_VAR 0 2
136110: PUSH
136111: EMPTY
136112: ST_TO_ADDR
// exit ;
136113: GO 136341
// end ; for i in defenders do
136115: LD_ADDR_VAR 0 4
136119: PUSH
136120: LD_VAR 0 2
136124: PUSH
136125: FOR_IN
136126: IFFALSE 136215
// begin if not IsInArea ( i , mc_parking [ base ] ) then
136128: LD_VAR 0 4
136132: PPUSH
136133: LD_EXP 124
136137: PUSH
136138: LD_VAR 0 1
136142: ARRAY
136143: PPUSH
136144: CALL_OW 308
136148: NOT
136149: IFFALSE 136173
// ComMoveToArea ( i , mc_parking [ base ] ) else
136151: LD_VAR 0 4
136155: PPUSH
136156: LD_EXP 124
136160: PUSH
136161: LD_VAR 0 1
136165: ARRAY
136166: PPUSH
136167: CALL_OW 113
136171: GO 136213
// if GetControl ( i ) = control_manual then
136173: LD_VAR 0 4
136177: PPUSH
136178: CALL_OW 263
136182: PUSH
136183: LD_INT 1
136185: EQUAL
136186: IFFALSE 136213
// if IsDrivenBy ( i ) then
136188: LD_VAR 0 4
136192: PPUSH
136193: CALL_OW 311
136197: IFFALSE 136213
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
136199: LD_VAR 0 4
136203: PPUSH
136204: CALL_OW 311
136208: PPUSH
136209: CALL_OW 121
// end ;
136213: GO 136125
136215: POP
136216: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
136217: LD_VAR 0 2
136221: PPUSH
136222: LD_INT 95
136224: PUSH
136225: LD_EXP 124
136229: PUSH
136230: LD_VAR 0 1
136234: ARRAY
136235: PUSH
136236: EMPTY
136237: LIST
136238: LIST
136239: PPUSH
136240: CALL_OW 72
136244: PUSH
136245: LD_VAR 0 2
136249: EQUAL
136250: PUSH
136251: LD_EXP 123
136255: PUSH
136256: LD_VAR 0 1
136260: ARRAY
136261: OR
136262: PUSH
136263: LD_EXP 100
136267: PUSH
136268: LD_VAR 0 1
136272: ARRAY
136273: NOT
136274: OR
136275: IFFALSE 136045
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
136277: LD_ADDR_EXP 122
136281: PUSH
136282: LD_EXP 122
136286: PPUSH
136287: LD_VAR 0 1
136291: PPUSH
136292: LD_VAR 0 2
136296: PPUSH
136297: LD_INT 21
136299: PUSH
136300: LD_INT 2
136302: PUSH
136303: EMPTY
136304: LIST
136305: LIST
136306: PPUSH
136307: CALL_OW 72
136311: PPUSH
136312: CALL_OW 1
136316: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
136317: LD_VAR 0 1
136321: PPUSH
136322: LD_INT 19
136324: PPUSH
136325: CALL 41033 0 2
// MC_Reset ( base , 20 ) ;
136329: LD_VAR 0 1
136333: PPUSH
136334: LD_INT 20
136336: PPUSH
136337: CALL 41033 0 2
// end ; end_of_file
136341: LD_VAR 0 3
136345: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
136346: LD_VAR 0 1
136350: PUSH
136351: LD_INT 200
136353: DOUBLE
136354: GREATEREQUAL
136355: IFFALSE 136363
136357: LD_INT 299
136359: DOUBLE
136360: LESSEQUAL
136361: IFTRUE 136365
136363: GO 136397
136365: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
136366: LD_VAR 0 1
136370: PPUSH
136371: LD_VAR 0 2
136375: PPUSH
136376: LD_VAR 0 3
136380: PPUSH
136381: LD_VAR 0 4
136385: PPUSH
136386: LD_VAR 0 5
136390: PPUSH
136391: CALL 125132 0 5
136395: GO 136474
136397: LD_INT 300
136399: DOUBLE
136400: GREATEREQUAL
136401: IFFALSE 136409
136403: LD_INT 399
136405: DOUBLE
136406: LESSEQUAL
136407: IFTRUE 136411
136409: GO 136473
136411: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
136412: LD_VAR 0 1
136416: PPUSH
136417: LD_VAR 0 2
136421: PPUSH
136422: LD_VAR 0 3
136426: PPUSH
136427: LD_VAR 0 4
136431: PPUSH
136432: LD_VAR 0 5
136436: PPUSH
136437: LD_VAR 0 6
136441: PPUSH
136442: LD_VAR 0 7
136446: PPUSH
136447: LD_VAR 0 8
136451: PPUSH
136452: LD_VAR 0 9
136456: PPUSH
136457: LD_VAR 0 10
136461: PPUSH
136462: LD_VAR 0 11
136466: PPUSH
136467: CALL 121465 0 11
136471: GO 136474
136473: POP
// end ;
136474: PPOPN 11
136476: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
136477: LD_VAR 0 1
136481: PPUSH
136482: LD_VAR 0 2
136486: PPUSH
136487: LD_VAR 0 3
136491: PPUSH
136492: LD_VAR 0 4
136496: PPUSH
136497: LD_VAR 0 5
136501: PPUSH
136502: CALL 124868 0 5
// end ; end_of_file
136506: PPOPN 5
136508: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
136509: LD_VAR 0 1
136513: PPUSH
136514: LD_VAR 0 2
136518: PPUSH
136519: LD_VAR 0 3
136523: PPUSH
136524: LD_VAR 0 4
136528: PPUSH
136529: LD_VAR 0 5
136533: PPUSH
136534: LD_VAR 0 6
136538: PPUSH
136539: CALL 109085 0 6
// end ;
136543: PPOPN 6
136545: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
136546: LD_INT 0
136548: PPUSH
// begin if not units then
136549: LD_VAR 0 1
136553: NOT
136554: IFFALSE 136558
// exit ;
136556: GO 136558
// end ;
136558: PPOPN 7
136560: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
136561: CALL 108979 0 0
// end ;
136565: PPOPN 1
136567: END
