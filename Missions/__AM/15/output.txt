// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34234 0 0
// InitNature ;
  19: CALL 34058 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10934 0 0
// PrepareRussian ;
  40: CALL 6917 0 0
// PrepareLegion ;
  44: CALL 4157 0 0
// PreparePowell ;
  48: CALL 2911 0 0
// PrepareAmerican ;
  52: CALL 1683 0 0
// Action ;
  56: CALL 14828 0 0
// MC_Start ( ) ;
  60: CALL 36346 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// end ;
 455: LD_VAR 0 1
 459: RET
// export function CustomInitMacro ( ) ; begin
 460: LD_INT 0
 462: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 463: LD_ADDR_EXP 125
 467: PUSH
 468: LD_INT 2
 470: PUSH
 471: LD_INT 3
 473: PUSH
 474: LD_INT 6
 476: PUSH
 477: LD_INT 10
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 486: LD_ADDR_EXP 126
 490: PUSH
 491: LD_INT 1
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: LD_INT 5
 499: PUSH
 500: LD_INT 9
 502: PUSH
 503: EMPTY
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 509: LD_INT 1
 511: PPUSH
 512: LD_INT 10
 514: PUSH
 515: LD_INT 11
 517: PUSH
 518: LD_INT 12
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: LIST
 525: PPUSH
 526: CALL 58623 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 530: LD_INT 1
 532: PPUSH
 533: LD_INT 17
 535: PUSH
 536: EMPTY
 537: LIST
 538: PPUSH
 539: CALL 58716 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 5
 548: PPUSH
 549: CALL 58066 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 553: LD_INT 1
 555: PPUSH
 556: LD_INT 24
 558: PUSH
 559: LD_INT 3
 561: PUSH
 562: LD_INT 3
 564: PUSH
 565: LD_INT 47
 567: PUSH
 568: EMPTY
 569: LIST
 570: LIST
 571: LIST
 572: LIST
 573: PUSH
 574: LD_INT 24
 576: PUSH
 577: LD_INT 3
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 47
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: PUSH
 592: LD_INT 24
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 47
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: PUSH
 610: LD_INT 24
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 47
 621: PUSH
 622: EMPTY
 623: LIST
 624: LIST
 625: LIST
 626: LIST
 627: PUSH
 628: LD_INT 24
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 1
 636: PUSH
 637: LD_INT 47
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: LIST
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PPUSH
 653: CALL 57881 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 657: LD_INT 2
 659: PPUSH
 660: LD_INT 10
 662: PUSH
 663: LD_INT 11
 665: PUSH
 666: LD_INT 12
 668: PUSH
 669: LD_INT 14
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: PPUSH
 678: CALL 58623 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 682: LD_INT 2
 684: PPUSH
 685: LD_INT 16
 687: PUSH
 688: EMPTY
 689: LIST
 690: PPUSH
 691: CALL 58716 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 21
 700: PUSH
 701: LD_INT 3
 703: PUSH
 704: LD_INT 3
 706: PUSH
 707: LD_INT 51
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: LIST
 715: PUSH
 716: LD_INT 22
 718: PUSH
 719: LD_INT 3
 721: PUSH
 722: LD_INT 3
 724: PUSH
 725: LD_INT 52
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 22
 736: PUSH
 737: LD_INT 3
 739: PUSH
 740: LD_INT 3
 742: PUSH
 743: LD_INT 52
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 24
 754: PUSH
 755: LD_INT 3
 757: PUSH
 758: LD_INT 3
 760: PUSH
 761: LD_INT 47
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 24
 772: PUSH
 773: LD_INT 3
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 47
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 24
 790: PUSH
 791: LD_INT 3
 793: PUSH
 794: LD_INT 3
 796: PUSH
 797: LD_INT 47
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 24
 808: PUSH
 809: LD_INT 3
 811: PUSH
 812: LD_INT 3
 814: PUSH
 815: LD_INT 47
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 24
 826: PUSH
 827: LD_INT 3
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: LD_INT 47
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: PPUSH
 852: CALL 57881 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 856: LD_INT 2
 858: PPUSH
 859: LD_INT 5
 861: PPUSH
 862: CALL 58066 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 866: LD_INT 2
 868: PPUSH
 869: LD_INT 0
 871: PPUSH
 872: CALL 58496 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 876: LD_INT 3
 878: PPUSH
 879: LD_INT 10
 881: PUSH
 882: LD_INT 12
 884: PUSH
 885: LD_INT 15
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: LIST
 892: PUSH
 893: LD_OWVAR 67
 897: ARRAY
 898: PPUSH
 899: LD_INT 27
 901: PPUSH
 902: CALL 57563 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 906: LD_INT 3
 908: PPUSH
 909: LD_INT 10
 911: PUSH
 912: LD_INT 11
 914: PUSH
 915: LD_INT 13
 917: PUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL 58623 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 931: LD_INT 3
 933: PPUSH
 934: LD_INT 15
 936: PUSH
 937: EMPTY
 938: LIST
 939: PPUSH
 940: CALL 58716 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 944: LD_ADDR_EXP 130
 948: PUSH
 949: LD_EXP 130
 953: PPUSH
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 22
 959: PUSH
 960: LD_INT 8
 962: PUSH
 963: EMPTY
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 25
 969: PUSH
 970: LD_INT 15
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: PPUSH
 981: CALL_OW 69
 985: PPUSH
 986: CALL_OW 1
 990: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 991: LD_INT 3
 993: PPUSH
 994: LD_INT 13
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 31
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: PUSH
1012: LD_INT 13
1014: PUSH
1015: LD_INT 2
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 31
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: LIST
1028: LIST
1029: PUSH
1030: LD_INT 13
1032: PUSH
1033: LD_INT 3
1035: PUSH
1036: LD_INT 2
1038: PUSH
1039: LD_INT 32
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PPUSH
1053: CALL 57881 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: PPUSH
1070: CALL 58623 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1074: LD_INT 4
1076: PPUSH
1077: LD_INT 9
1079: PUSH
1080: EMPTY
1081: LIST
1082: PPUSH
1083: CALL 58716 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1087: LD_INT 4
1089: PPUSH
1090: LD_INT 26
1092: PUSH
1093: LD_INT 74
1095: PUSH
1096: LD_INT 107
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 32
1110: PUSH
1111: LD_INT 77
1113: PUSH
1114: LD_INT 101
1116: PUSH
1117: LD_INT 4
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 32
1128: PUSH
1129: LD_INT 69
1131: PUSH
1132: LD_INT 86
1134: PUSH
1135: LD_INT 4
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 27
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 110
1152: PUSH
1153: LD_INT 3
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 42
1167: PUSH
1168: LD_INT 79
1170: PUSH
1171: LD_INT 5
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 29
1182: PUSH
1183: LD_INT 86
1185: PUSH
1186: LD_INT 105
1188: PUSH
1189: LD_INT 2
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 40
1203: PUSH
1204: LD_INT 75
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 80
1221: PUSH
1222: LD_INT 106
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 32
1236: PUSH
1237: LD_INT 75
1239: PUSH
1240: LD_INT 114
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 82
1257: PUSH
1258: LD_INT 110
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 62
1275: PUSH
1276: LD_INT 78
1278: PUSH
1279: LD_INT 4
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 4
1290: PUSH
1291: LD_INT 39
1293: PUSH
1294: LD_INT 61
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL 57773 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1324: LD_INT 4
1326: PPUSH
1327: LD_INT 5
1329: PUSH
1330: LD_INT 6
1332: PUSH
1333: LD_INT 7
1335: PUSH
1336: LD_INT 9
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 59034 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 58205 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 58496 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 58496 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 58828 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 57881 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 58447 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$1 trigger debug do var i , tmp ;
1542: LD_EXP 1
1546: IFFALSE 1653
1548: GO 1550
1550: DISABLE
1551: LD_INT 0
1553: PPUSH
1554: PPUSH
// begin enable ;
1555: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1556: LD_ADDR_VAR 0 2
1560: PUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: LD_INT 3
1573: PUSH
1574: LD_INT 21
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: PUSH
1588: LD_INT 3
1590: PUSH
1591: LD_INT 24
1593: PUSH
1594: LD_INT 999
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: LIST
1609: PPUSH
1610: CALL_OW 69
1614: ST_TO_ADDR
// if not tmp then
1615: LD_VAR 0 2
1619: NOT
1620: IFFALSE 1624
// exit ;
1622: GO 1653
// for i in tmp do
1624: LD_ADDR_VAR 0 1
1628: PUSH
1629: LD_VAR 0 2
1633: PUSH
1634: FOR_IN
1635: IFFALSE 1651
// SetLives ( i , 1000 ) ;
1637: LD_VAR 0 1
1641: PPUSH
1642: LD_INT 1000
1644: PPUSH
1645: CALL_OW 234
1649: GO 1634
1651: POP
1652: POP
// end ;
1653: PPOPN 2
1655: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1656: LD_EXP 36
1660: PUSH
1661: LD_EXP 17
1665: PUSH
1666: LD_INT 2
1668: GREATEREQUAL
1669: AND
1670: IFFALSE 1682
1672: GO 1674
1674: DISABLE
// SetAchievement ( ACH_POWELL ) ; end_of_file
1675: LD_STRING ACH_POWELL
1677: PPUSH
1678: CALL_OW 543
1682: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1683: LD_INT 0
1685: PPUSH
// uc_side := 1 ;
1686: LD_ADDR_OWVAR 20
1690: PUSH
1691: LD_INT 1
1693: ST_TO_ADDR
// uc_nation := 1 ;
1694: LD_ADDR_OWVAR 21
1698: PUSH
1699: LD_INT 1
1701: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1702: LD_ADDR_EXP 38
1706: PUSH
1707: LD_STRING JMM
1709: PPUSH
1710: LD_EXP 1
1714: NOT
1715: PPUSH
1716: LD_STRING 14_
1718: PPUSH
1719: CALL 64273 0 3
1723: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1724: LD_EXP 4
1728: NOT
1729: PUSH
1730: LD_EXP 4
1734: PUSH
1735: LD_INT 1
1737: ARRAY
1738: PUSH
1739: LD_INT 1
1741: ARRAY
1742: NOT
1743: OR
1744: IFFALSE 1767
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1746: LD_INT 3
1748: PPUSH
1749: LD_INT 3
1751: PPUSH
1752: LD_INT 1
1754: PPUSH
1755: LD_INT 5
1757: PPUSH
1758: LD_INT 100
1760: PPUSH
1761: CALL 71388 0 5
1765: GO 1826
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1767: LD_EXP 4
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PUSH
1776: LD_INT 1
1778: ARRAY
1779: PPUSH
1780: LD_EXP 4
1784: PUSH
1785: LD_INT 2
1787: ARRAY
1788: PUSH
1789: LD_INT 1
1791: ARRAY
1792: PPUSH
1793: LD_EXP 4
1797: PUSH
1798: LD_INT 3
1800: ARRAY
1801: PUSH
1802: LD_INT 1
1804: ARRAY
1805: PPUSH
1806: LD_EXP 4
1810: PUSH
1811: LD_INT 4
1813: ARRAY
1814: PUSH
1815: LD_INT 1
1817: ARRAY
1818: PPUSH
1819: LD_INT 30
1821: PPUSH
1822: CALL 71388 0 5
// JMMNewVeh := CreateVehicle ;
1826: LD_ADDR_EXP 55
1830: PUSH
1831: CALL_OW 45
1835: ST_TO_ADDR
// if not JMMNewVeh then
1836: LD_EXP 55
1840: NOT
1841: IFFALSE 1872
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1843: LD_INT 3
1845: PPUSH
1846: LD_INT 3
1848: PPUSH
1849: LD_INT 1
1851: PPUSH
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 100
1857: PPUSH
1858: CALL 71388 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 55
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1872: LD_EXP 55
1876: PPUSH
1877: LD_INT 4
1879: PPUSH
1880: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1884: LD_EXP 55
1888: PPUSH
1889: LD_INT 79
1891: PPUSH
1892: LD_INT 91
1894: PPUSH
1895: LD_INT 0
1897: PPUSH
1898: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1902: LD_EXP 38
1906: PPUSH
1907: LD_EXP 55
1911: PPUSH
1912: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1916: LD_EXP 6
1920: PUSH
1921: LD_EXP 2
1925: NOT
1926: AND
1927: IFFALSE 2185
// begin if not JMMGirlVeh then
1929: LD_EXP 5
1933: NOT
1934: IFFALSE 1957
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1936: LD_INT 3
1938: PPUSH
1939: LD_INT 3
1941: PPUSH
1942: LD_INT 1
1944: PPUSH
1945: LD_INT 9
1947: PPUSH
1948: LD_INT 100
1950: PPUSH
1951: CALL 71388 0 5
1955: GO 2016
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1957: LD_EXP 5
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PUSH
1966: LD_INT 1
1968: ARRAY
1969: PPUSH
1970: LD_EXP 5
1974: PUSH
1975: LD_INT 2
1977: ARRAY
1978: PUSH
1979: LD_INT 1
1981: ARRAY
1982: PPUSH
1983: LD_EXP 5
1987: PUSH
1988: LD_INT 3
1990: ARRAY
1991: PUSH
1992: LD_INT 1
1994: ARRAY
1995: PPUSH
1996: LD_EXP 5
2000: PUSH
2001: LD_INT 4
2003: ARRAY
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PPUSH
2009: LD_INT 30
2011: PPUSH
2012: CALL 71388 0 5
// GirlNewVeh := CreateVehicle ;
2016: LD_ADDR_EXP 56
2020: PUSH
2021: CALL_OW 45
2025: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2026: LD_EXP 56
2030: PPUSH
2031: LD_INT 4
2033: PPUSH
2034: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2038: LD_EXP 56
2042: PPUSH
2043: LD_INT 82
2045: PPUSH
2046: LD_INT 96
2048: PPUSH
2049: LD_INT 0
2051: PPUSH
2052: CALL_OW 48
// if JMMGirl = 1 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 1
2063: EQUAL
2064: IFFALSE 2099
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Joan
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 64273 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 56
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 2 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 2
2106: EQUAL
2107: IFFALSE 2142
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2109: LD_ADDR_EXP 41
2113: PUSH
2114: LD_STRING Lisa
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 64273 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2128: LD_EXP 41
2132: PPUSH
2133: LD_EXP 56
2137: PPUSH
2138: CALL_OW 52
// end ; if JMMGirl = 3 then
2142: LD_EXP 7
2146: PUSH
2147: LD_INT 3
2149: EQUAL
2150: IFFALSE 2185
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2152: LD_ADDR_EXP 53
2156: PUSH
2157: LD_STRING Connie
2159: PPUSH
2160: LD_INT 1
2162: PPUSH
2163: LD_STRING 14_
2165: PPUSH
2166: CALL 64273 0 3
2170: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2171: LD_EXP 53
2175: PPUSH
2176: LD_EXP 56
2180: PPUSH
2181: CALL_OW 52
// end ; end ; end ;
2185: LD_VAR 0 1
2189: RET
// export function PrepareStevensSquad ; var tmp ; begin
2190: LD_INT 0
2192: PPUSH
2193: PPUSH
// uc_side := 1 ;
2194: LD_ADDR_OWVAR 20
2198: PUSH
2199: LD_INT 1
2201: ST_TO_ADDR
// uc_nation := 1 ;
2202: LD_ADDR_OWVAR 21
2206: PUSH
2207: LD_INT 1
2209: ST_TO_ADDR
// tmp := [ ] ;
2210: LD_ADDR_VAR 0 2
2214: PUSH
2215: EMPTY
2216: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2217: LD_ADDR_EXP 40
2221: PUSH
2222: LD_STRING Stevens
2224: PPUSH
2225: LD_EXP 1
2229: NOT
2230: PPUSH
2231: LD_STRING 13f_
2233: PPUSH
2234: CALL 64273 0 3
2238: ST_TO_ADDR
// if not Stevens then
2239: LD_EXP 40
2243: NOT
2244: IFFALSE 2300
// begin hc_name = Baker Smith ;
2246: LD_ADDR_OWVAR 26
2250: PUSH
2251: LD_STRING Baker Smith
2253: ST_TO_ADDR
// hc_gallery =  ;
2254: LD_ADDR_OWVAR 33
2258: PUSH
2259: LD_STRING 
2261: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 10
2267: PPUSH
2268: CALL_OW 384
// Baker = CreateHuman ;
2272: LD_ADDR_EXP 54
2276: PUSH
2277: CALL_OW 44
2281: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2282: LD_ADDR_VAR 0 2
2286: PUSH
2287: LD_VAR 0 2
2291: PUSH
2292: LD_EXP 54
2296: ADD
2297: ST_TO_ADDR
// end else
2298: GO 2316
// tmp := tmp ^ Stevens ;
2300: LD_ADDR_VAR 0 2
2304: PUSH
2305: LD_VAR 0 2
2309: PUSH
2310: LD_EXP 40
2314: ADD
2315: ST_TO_ADDR
// if not Lisa then
2316: LD_EXP 41
2320: NOT
2321: IFFALSE 2367
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2323: LD_ADDR_EXP 41
2327: PUSH
2328: LD_STRING Lisa
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13f_
2339: PPUSH
2340: CALL 64273 0 3
2344: ST_TO_ADDR
// if Lisa then
2345: LD_EXP 41
2349: IFFALSE 2367
// tmp := tmp ^ Lisa ;
2351: LD_ADDR_VAR 0 2
2355: PUSH
2356: LD_VAR 0 2
2360: PUSH
2361: LD_EXP 41
2365: ADD
2366: ST_TO_ADDR
// end ; if not Donaldson then
2367: LD_EXP 42
2371: NOT
2372: IFFALSE 2418
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2374: LD_ADDR_EXP 42
2378: PUSH
2379: LD_STRING Donaldson
2381: PPUSH
2382: LD_EXP 1
2386: NOT
2387: PPUSH
2388: LD_STRING 13f_
2390: PPUSH
2391: CALL 64273 0 3
2395: ST_TO_ADDR
// if Donaldson then
2396: LD_EXP 42
2400: IFFALSE 2418
// tmp := tmp ^ Donaldson ;
2402: LD_ADDR_VAR 0 2
2406: PUSH
2407: LD_VAR 0 2
2411: PUSH
2412: LD_EXP 42
2416: ADD
2417: ST_TO_ADDR
// end ; if not Bobby then
2418: LD_EXP 43
2422: NOT
2423: IFFALSE 2469
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2425: LD_ADDR_EXP 43
2429: PUSH
2430: LD_STRING Bobby
2432: PPUSH
2433: LD_EXP 1
2437: NOT
2438: PPUSH
2439: LD_STRING 13f_
2441: PPUSH
2442: CALL 64273 0 3
2446: ST_TO_ADDR
// if Bobby then
2447: LD_EXP 43
2451: IFFALSE 2469
// tmp := tmp ^ Bobby ;
2453: LD_ADDR_VAR 0 2
2457: PUSH
2458: LD_VAR 0 2
2462: PUSH
2463: LD_EXP 43
2467: ADD
2468: ST_TO_ADDR
// end ; if not Cyrus then
2469: LD_EXP 44
2473: NOT
2474: IFFALSE 2520
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2476: LD_ADDR_EXP 44
2480: PUSH
2481: LD_STRING Cyrus
2483: PPUSH
2484: LD_EXP 1
2488: NOT
2489: PPUSH
2490: LD_STRING 13f_
2492: PPUSH
2493: CALL 64273 0 3
2497: ST_TO_ADDR
// if Cyrus then
2498: LD_EXP 44
2502: IFFALSE 2520
// tmp := tmp ^ Cyrus ;
2504: LD_ADDR_VAR 0 2
2508: PUSH
2509: LD_VAR 0 2
2513: PUSH
2514: LD_EXP 44
2518: ADD
2519: ST_TO_ADDR
// end ; if not Brown then
2520: LD_EXP 46
2524: NOT
2525: IFFALSE 2571
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2527: LD_ADDR_EXP 46
2531: PUSH
2532: LD_STRING Brown
2534: PPUSH
2535: LD_EXP 1
2539: NOT
2540: PPUSH
2541: LD_STRING 13f_
2543: PPUSH
2544: CALL 64273 0 3
2548: ST_TO_ADDR
// if Brown then
2549: LD_EXP 46
2553: IFFALSE 2571
// tmp := tmp ^ Brown ;
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: LD_VAR 0 2
2564: PUSH
2565: LD_EXP 46
2569: ADD
2570: ST_TO_ADDR
// end ; if not Gladstone then
2571: LD_EXP 47
2575: NOT
2576: IFFALSE 2622
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2578: LD_ADDR_EXP 47
2582: PUSH
2583: LD_STRING Gladstone
2585: PPUSH
2586: LD_EXP 1
2590: NOT
2591: PPUSH
2592: LD_STRING 13f_
2594: PPUSH
2595: CALL 64273 0 3
2599: ST_TO_ADDR
// if Gladstone then
2600: LD_EXP 47
2604: IFFALSE 2622
// tmp := tmp ^ Gladstone ;
2606: LD_ADDR_VAR 0 2
2610: PUSH
2611: LD_VAR 0 2
2615: PUSH
2616: LD_EXP 47
2620: ADD
2621: ST_TO_ADDR
// end ; if not Houten then
2622: LD_EXP 48
2626: NOT
2627: IFFALSE 2673
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2629: LD_ADDR_EXP 48
2633: PUSH
2634: LD_STRING Houten
2636: PPUSH
2637: LD_EXP 1
2641: NOT
2642: PPUSH
2643: LD_STRING 13f_
2645: PPUSH
2646: CALL 64273 0 3
2650: ST_TO_ADDR
// if Houten then
2651: LD_EXP 48
2655: IFFALSE 2673
// tmp := tmp ^ Houten ;
2657: LD_ADDR_VAR 0 2
2661: PUSH
2662: LD_VAR 0 2
2666: PUSH
2667: LD_EXP 48
2671: ADD
2672: ST_TO_ADDR
// end ; if not Cornel then
2673: LD_EXP 49
2677: NOT
2678: IFFALSE 2724
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2680: LD_ADDR_EXP 49
2684: PUSH
2685: LD_STRING Cornell
2687: PPUSH
2688: LD_EXP 1
2692: NOT
2693: PPUSH
2694: LD_STRING 13f_
2696: PPUSH
2697: CALL 64273 0 3
2701: ST_TO_ADDR
// if Cornel then
2702: LD_EXP 49
2706: IFFALSE 2724
// tmp := tmp ^ Cornel ;
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: LD_VAR 0 2
2717: PUSH
2718: LD_EXP 49
2722: ADD
2723: ST_TO_ADDR
// end ; if not Gary then
2724: LD_EXP 50
2728: NOT
2729: IFFALSE 2775
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2731: LD_ADDR_EXP 50
2735: PUSH
2736: LD_STRING Gary
2738: PPUSH
2739: LD_EXP 1
2743: NOT
2744: PPUSH
2745: LD_STRING 13f_
2747: PPUSH
2748: CALL 64273 0 3
2752: ST_TO_ADDR
// if Gary then
2753: LD_EXP 50
2757: IFFALSE 2775
// tmp := tmp ^ Gary ;
2759: LD_ADDR_VAR 0 2
2763: PUSH
2764: LD_VAR 0 2
2768: PUSH
2769: LD_EXP 50
2773: ADD
2774: ST_TO_ADDR
// end ; if not Frank then
2775: LD_EXP 51
2779: NOT
2780: IFFALSE 2826
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2782: LD_ADDR_EXP 51
2786: PUSH
2787: LD_STRING Frank
2789: PPUSH
2790: LD_EXP 1
2794: NOT
2795: PPUSH
2796: LD_STRING 13f_
2798: PPUSH
2799: CALL 64273 0 3
2803: ST_TO_ADDR
// if Frank then
2804: LD_EXP 51
2808: IFFALSE 2826
// tmp := tmp ^ Frank ;
2810: LD_ADDR_VAR 0 2
2814: PUSH
2815: LD_VAR 0 2
2819: PUSH
2820: LD_EXP 51
2824: ADD
2825: ST_TO_ADDR
// end ; if not Kikuchi then
2826: LD_EXP 52
2830: NOT
2831: IFFALSE 2877
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2833: LD_ADDR_EXP 52
2837: PUSH
2838: LD_STRING Kikuchi
2840: PPUSH
2841: LD_EXP 1
2845: NOT
2846: PPUSH
2847: LD_STRING 13f_
2849: PPUSH
2850: CALL 64273 0 3
2854: ST_TO_ADDR
// if Kikuchi then
2855: LD_EXP 52
2859: IFFALSE 2877
// tmp := tmp ^ Kikuchi ;
2861: LD_ADDR_VAR 0 2
2865: PUSH
2866: LD_VAR 0 2
2870: PUSH
2871: LD_EXP 52
2875: ADD
2876: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2877: LD_ADDR_VAR 0 2
2881: PUSH
2882: LD_VAR 0 2
2886: PUSH
2887: LD_STRING 13_other_survivors
2889: PPUSH
2890: CALL_OW 31
2894: UNION
2895: ST_TO_ADDR
// result := tmp ;
2896: LD_ADDR_VAR 0 1
2900: PUSH
2901: LD_VAR 0 2
2905: ST_TO_ADDR
// end ; end_of_file
2906: LD_VAR 0 1
2910: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
2918: PPUSH
2919: PPUSH
2920: PPUSH
2921: PPUSH
2922: PPUSH
// uc_side := 4 ;
2923: LD_ADDR_OWVAR 20
2927: PUSH
2928: LD_INT 4
2930: ST_TO_ADDR
// uc_nation := 1 ;
2931: LD_ADDR_OWVAR 21
2935: PUSH
2936: LD_INT 1
2938: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2939: LD_INT 387
2941: PPUSH
2942: CALL_OW 274
2946: PPUSH
2947: LD_INT 1
2949: PPUSH
2950: LD_INT 2500
2952: PPUSH
2953: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2957: LD_INT 387
2959: PPUSH
2960: CALL_OW 274
2964: PPUSH
2965: LD_INT 2
2967: PPUSH
2968: LD_INT 400
2970: PPUSH
2971: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 3
2985: PPUSH
2986: LD_INT 10
2988: PPUSH
2989: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2993: LD_ADDR_EXP 57
2997: PUSH
2998: LD_STRING Powell
3000: PPUSH
3001: CALL_OW 25
3005: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3006: LD_EXP 57
3010: PPUSH
3011: LD_INT 57
3013: PPUSH
3014: LD_INT 94
3016: PPUSH
3017: LD_INT 0
3019: PPUSH
3020: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3024: LD_EXP 57
3028: PPUSH
3029: LD_INT 58
3031: PPUSH
3032: LD_INT 94
3034: PPUSH
3035: CALL_OW 118
// vip := [ ] ;
3039: LD_ADDR_EXP 58
3043: PUSH
3044: EMPTY
3045: ST_TO_ADDR
// tmp := [ ] ;
3046: LD_ADDR_VAR 0 6
3050: PUSH
3051: EMPTY
3052: ST_TO_ADDR
// if JMMGirl <> 2 then
3053: LD_EXP 7
3057: PUSH
3058: LD_INT 2
3060: NONEQUAL
3061: IFFALSE 3085
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3063: LD_ADDR_EXP 41
3067: PUSH
3068: LD_STRING Lisa
3070: PPUSH
3071: LD_EXP 1
3075: NOT
3076: PPUSH
3077: LD_STRING 13s_
3079: PPUSH
3080: CALL 64273 0 3
3084: ST_TO_ADDR
// if Lisa then
3085: LD_EXP 41
3089: IFFALSE 3107
// tmp := tmp ^ Lisa ;
3091: LD_ADDR_VAR 0 6
3095: PUSH
3096: LD_VAR 0 6
3100: PUSH
3101: LD_EXP 41
3105: ADD
3106: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3107: LD_ADDR_EXP 42
3111: PUSH
3112: LD_STRING Donaldson
3114: PPUSH
3115: LD_EXP 1
3119: NOT
3120: PPUSH
3121: LD_STRING 13s_
3123: PPUSH
3124: CALL 64273 0 3
3128: ST_TO_ADDR
// if Donaldson then
3129: LD_EXP 42
3133: IFFALSE 3151
// tmp := tmp ^ Donaldson ;
3135: LD_ADDR_VAR 0 6
3139: PUSH
3140: LD_VAR 0 6
3144: PUSH
3145: LD_EXP 42
3149: ADD
3150: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3151: LD_ADDR_EXP 43
3155: PUSH
3156: LD_STRING Bobby
3158: PPUSH
3159: LD_EXP 1
3163: NOT
3164: PPUSH
3165: LD_STRING 13s_
3167: PPUSH
3168: CALL 64273 0 3
3172: ST_TO_ADDR
// if Bobby then
3173: LD_EXP 43
3177: IFFALSE 3195
// tmp := tmp ^ Bobby ;
3179: LD_ADDR_VAR 0 6
3183: PUSH
3184: LD_VAR 0 6
3188: PUSH
3189: LD_EXP 43
3193: ADD
3194: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3195: LD_ADDR_EXP 44
3199: PUSH
3200: LD_STRING Cyrus
3202: PPUSH
3203: LD_EXP 1
3207: NOT
3208: PPUSH
3209: LD_STRING 13s_
3211: PPUSH
3212: CALL 64273 0 3
3216: ST_TO_ADDR
// if Cyrus then
3217: LD_EXP 44
3221: IFFALSE 3239
// tmp := tmp ^ Cyrus ;
3223: LD_ADDR_VAR 0 6
3227: PUSH
3228: LD_VAR 0 6
3232: PUSH
3233: LD_EXP 44
3237: ADD
3238: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3239: LD_ADDR_EXP 45
3243: PUSH
3244: LD_STRING Denis
3246: PPUSH
3247: LD_EXP 1
3251: NOT
3252: PPUSH
3253: LD_STRING 13s_
3255: PPUSH
3256: CALL 64273 0 3
3260: ST_TO_ADDR
// if not Denis then
3261: LD_EXP 45
3265: NOT
3266: IFFALSE 3290
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3268: LD_ADDR_EXP 45
3272: PUSH
3273: LD_STRING Denis
3275: PPUSH
3276: LD_EXP 1
3280: NOT
3281: PPUSH
3282: LD_STRING 13f_
3284: PPUSH
3285: CALL 64273 0 3
3289: ST_TO_ADDR
// if Denis then
3290: LD_EXP 45
3294: IFFALSE 3312
// tmp := tmp ^ Denis ;
3296: LD_ADDR_VAR 0 6
3300: PUSH
3301: LD_VAR 0 6
3305: PUSH
3306: LD_EXP 45
3310: ADD
3311: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 46
3316: PUSH
3317: LD_STRING Brown
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 64273 0 3
3333: ST_TO_ADDR
// if Brown then
3334: LD_EXP 46
3338: IFFALSE 3356
// tmp := tmp ^ Brown ;
3340: LD_ADDR_VAR 0 6
3344: PUSH
3345: LD_VAR 0 6
3349: PUSH
3350: LD_EXP 46
3354: ADD
3355: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 47
3360: PUSH
3361: LD_STRING Gladstone
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 64273 0 3
3377: ST_TO_ADDR
// if Gladstone then
3378: LD_EXP 47
3382: IFFALSE 3400
// tmp := tmp ^ Gladstone ;
3384: LD_ADDR_VAR 0 6
3388: PUSH
3389: LD_VAR 0 6
3393: PUSH
3394: LD_EXP 47
3398: ADD
3399: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 48
3404: PUSH
3405: LD_STRING Houten
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 64273 0 3
3421: ST_TO_ADDR
// if Houten then
3422: LD_EXP 48
3426: IFFALSE 3444
// tmp := tmp ^ Houten ;
3428: LD_ADDR_VAR 0 6
3432: PUSH
3433: LD_VAR 0 6
3437: PUSH
3438: LD_EXP 48
3442: ADD
3443: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 49
3448: PUSH
3449: LD_STRING Cornel
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 64273 0 3
3465: ST_TO_ADDR
// if Cornel then
3466: LD_EXP 49
3470: IFFALSE 3488
// tmp := tmp ^ Cornel ;
3472: LD_ADDR_VAR 0 6
3476: PUSH
3477: LD_VAR 0 6
3481: PUSH
3482: LD_EXP 49
3486: ADD
3487: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3488: LD_ADDR_EXP 50
3492: PUSH
3493: LD_STRING Gary
3495: PPUSH
3496: LD_EXP 1
3500: NOT
3501: PPUSH
3502: LD_STRING 13s_
3504: PPUSH
3505: CALL 64273 0 3
3509: ST_TO_ADDR
// if Gary then
3510: LD_EXP 50
3514: IFFALSE 3532
// tmp := tmp ^ Gary ;
3516: LD_ADDR_VAR 0 6
3520: PUSH
3521: LD_VAR 0 6
3525: PUSH
3526: LD_EXP 50
3530: ADD
3531: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3532: LD_ADDR_EXP 51
3536: PUSH
3537: LD_STRING Frank
3539: PPUSH
3540: LD_EXP 1
3544: NOT
3545: PPUSH
3546: LD_STRING 13s_
3548: PPUSH
3549: CALL 64273 0 3
3553: ST_TO_ADDR
// if Frank then
3554: LD_EXP 51
3558: IFFALSE 3576
// tmp := tmp ^ Frank ;
3560: LD_ADDR_VAR 0 6
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: LD_EXP 51
3574: ADD
3575: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3576: LD_ADDR_EXP 52
3580: PUSH
3581: LD_STRING Kikuchi
3583: PPUSH
3584: LD_EXP 1
3588: NOT
3589: PPUSH
3590: LD_STRING 13s_
3592: PPUSH
3593: CALL 64273 0 3
3597: ST_TO_ADDR
// if Kikuchi then
3598: LD_EXP 52
3602: IFFALSE 3620
// tmp := tmp ^ Kikuchi ;
3604: LD_ADDR_VAR 0 6
3608: PUSH
3609: LD_VAR 0 6
3613: PUSH
3614: LD_EXP 52
3618: ADD
3619: ST_TO_ADDR
// vip := tmp ;
3620: LD_ADDR_EXP 58
3624: PUSH
3625: LD_VAR 0 6
3629: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3630: LD_ADDR_VAR 0 6
3634: PUSH
3635: LD_VAR 0 6
3639: PUSH
3640: LD_STRING 13s_others
3642: PPUSH
3643: CALL_OW 31
3647: UNION
3648: ST_TO_ADDR
// if tmp < 20 then
3649: LD_VAR 0 6
3653: PUSH
3654: LD_INT 20
3656: LESS
3657: IFFALSE 3724
// for i = 1 to 20 - tmp do
3659: LD_ADDR_VAR 0 2
3663: PUSH
3664: DOUBLE
3665: LD_INT 1
3667: DEC
3668: ST_TO_ADDR
3669: LD_INT 20
3671: PUSH
3672: LD_VAR 0 6
3676: MINUS
3677: PUSH
3678: FOR_TO
3679: IFFALSE 3722
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3681: LD_INT 1
3683: PPUSH
3684: LD_VAR 0 2
3688: PUSH
3689: LD_INT 4
3691: MOD
3692: PUSH
3693: LD_INT 1
3695: PLUS
3696: PPUSH
3697: LD_INT 5
3699: PPUSH
3700: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3704: LD_ADDR_VAR 0 6
3708: PUSH
3709: LD_VAR 0 6
3713: PUSH
3714: CALL_OW 44
3718: ADD
3719: ST_TO_ADDR
// end ;
3720: GO 3678
3722: POP
3723: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3724: LD_ADDR_VAR 0 7
3728: PUSH
3729: LD_INT 22
3731: PUSH
3732: LD_INT 4
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PUSH
3739: LD_INT 30
3741: PUSH
3742: LD_INT 0
3744: PUSH
3745: EMPTY
3746: LIST
3747: LIST
3748: PUSH
3749: EMPTY
3750: LIST
3751: LIST
3752: PPUSH
3753: CALL_OW 69
3757: PUSH
3758: LD_INT 1
3760: ARRAY
3761: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3762: LD_ADDR_VAR 0 8
3766: PUSH
3767: LD_INT 22
3769: PUSH
3770: LD_INT 4
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 30
3779: PUSH
3780: LD_INT 6
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PPUSH
3791: CALL_OW 69
3795: PUSH
3796: LD_INT 1
3798: ARRAY
3799: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3800: LD_ADDR_VAR 0 9
3804: PUSH
3805: LD_INT 22
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PUSH
3815: LD_INT 30
3817: PUSH
3818: LD_INT 4
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PUSH
3825: EMPTY
3826: LIST
3827: LIST
3828: PPUSH
3829: CALL_OW 69
3833: PUSH
3834: LD_INT 1
3836: ARRAY
3837: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3838: LD_ADDR_VAR 0 10
3842: PUSH
3843: LD_INT 22
3845: PUSH
3846: LD_INT 4
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PUSH
3853: LD_INT 30
3855: PUSH
3856: LD_INT 2
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: PPUSH
3867: CALL_OW 69
3871: PUSH
3872: LD_INT 1
3874: ARRAY
3875: ST_TO_ADDR
// for i in tmp do
3876: LD_ADDR_VAR 0 2
3880: PUSH
3881: LD_VAR 0 6
3885: PUSH
3886: FOR_IN
3887: IFFALSE 4013
// begin cl := GetClass ( i ) ;
3889: LD_ADDR_VAR 0 5
3893: PUSH
3894: LD_VAR 0 2
3898: PPUSH
3899: CALL_OW 257
3903: ST_TO_ADDR
// if cl > 4 then
3904: LD_VAR 0 5
3908: PUSH
3909: LD_INT 4
3911: GREATER
3912: IFFALSE 3922
// cl := 1 ;
3914: LD_ADDR_VAR 0 5
3918: PUSH
3919: LD_INT 1
3921: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3922: LD_ADDR_VAR 0 3
3926: PUSH
3927: LD_VAR 0 9
3931: PUSH
3932: LD_VAR 0 7
3936: PUSH
3937: LD_VAR 0 10
3941: PUSH
3942: LD_VAR 0 8
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: PUSH
3953: LD_VAR 0 5
3957: ARRAY
3958: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3959: LD_VAR 0 3
3963: PPUSH
3964: CALL_OW 313
3968: PUSH
3969: LD_INT 5
3971: LESS
3972: IFFALSE 3990
// PlaceHumanInUnit ( i , b ) else
3974: LD_VAR 0 2
3978: PPUSH
3979: LD_VAR 0 3
3983: PPUSH
3984: CALL_OW 52
3988: GO 4011
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3990: LD_VAR 0 2
3994: PPUSH
3995: LD_INT 58
3997: PPUSH
3998: LD_INT 91
4000: PPUSH
4001: LD_INT 6
4003: PPUSH
4004: LD_INT 0
4006: PPUSH
4007: CALL_OW 50
// end ;
4011: GO 3886
4013: POP
4014: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4015: LD_INT 2
4017: PPUSH
4018: LD_INT 1
4020: PPUSH
4021: LD_INT 1
4023: PPUSH
4024: LD_INT 12
4026: PPUSH
4027: LD_INT 100
4029: PPUSH
4030: CALL 71388 0 5
// veh := CreateVehicle ;
4034: LD_ADDR_VAR 0 4
4038: PUSH
4039: CALL_OW 45
4043: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4044: LD_VAR 0 4
4048: PPUSH
4049: LD_INT 4
4051: PPUSH
4052: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 49
4063: PPUSH
4064: LD_INT 88
4066: PPUSH
4067: LD_INT 0
4069: PPUSH
4070: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4074: LD_VAR 0 4
4078: PPUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 100
4084: PPUSH
4085: CALL_OW 290
// uc_side := 0 ;
4089: LD_ADDR_OWVAR 20
4093: PUSH
4094: LD_INT 0
4096: ST_TO_ADDR
// uc_nation := 0 ;
4097: LD_ADDR_OWVAR 21
4101: PUSH
4102: LD_INT 0
4104: ST_TO_ADDR
// for i = 1 to 4 do
4105: LD_ADDR_VAR 0 2
4109: PUSH
4110: DOUBLE
4111: LD_INT 1
4113: DEC
4114: ST_TO_ADDR
4115: LD_INT 4
4117: PUSH
4118: FOR_TO
4119: IFFALSE 4150
// begin InitHc ;
4121: CALL_OW 19
// hc_class := class_apeman ;
4125: LD_ADDR_OWVAR 28
4129: PUSH
4130: LD_INT 12
4132: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4133: CALL_OW 44
4137: PPUSH
4138: LD_INT 13
4140: PPUSH
4141: LD_INT 0
4143: PPUSH
4144: CALL_OW 49
// end ;
4148: GO 4118
4150: POP
4151: POP
// end ; end_of_file
4152: LD_VAR 0 1
4156: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4157: LD_INT 0
4159: PPUSH
4160: PPUSH
4161: PPUSH
4162: PPUSH
4163: PPUSH
// side := 8 ;
4164: LD_ADDR_VAR 0 3
4168: PUSH
4169: LD_INT 8
4171: ST_TO_ADDR
// uc_side := side ;
4172: LD_ADDR_OWVAR 20
4176: PUSH
4177: LD_VAR 0 3
4181: ST_TO_ADDR
// uc_nation := 2 ;
4182: LD_ADDR_OWVAR 21
4186: PUSH
4187: LD_INT 2
4189: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: LD_INT 22
4197: PUSH
4198: LD_VAR 0 3
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 21
4209: PUSH
4210: LD_INT 3
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PPUSH
4221: CALL_OW 69
4225: PUSH
4226: FOR_IN
4227: IFFALSE 4243
// SetBLevel ( i , 10 ) ;
4229: LD_VAR 0 2
4233: PPUSH
4234: LD_INT 10
4236: PPUSH
4237: CALL_OW 241
4241: GO 4226
4243: POP
4244: POP
// if KurtStatus then
4245: LD_EXP 3
4249: IFFALSE 4272
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4251: LD_ADDR_EXP 59
4255: PUSH
4256: LD_STRING Kurt
4258: PPUSH
4259: LD_INT 0
4261: PPUSH
4262: LD_STRING 
4264: PPUSH
4265: CALL 64273 0 3
4269: ST_TO_ADDR
4270: GO 4294
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4272: LD_ADDR_EXP 59
4276: PUSH
4277: LD_STRING AltKurt
4279: PPUSH
4280: LD_EXP 1
4284: NOT
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64273 0 3
4293: ST_TO_ADDR
// if not Kurt then
4294: LD_EXP 59
4298: NOT
4299: IFFALSE 4325
// begin InitHc ;
4301: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4305: LD_INT 1
4307: PPUSH
4308: LD_INT 10
4310: PPUSH
4311: CALL_OW 381
// Kurt := CreateHuman ;
4315: LD_ADDR_EXP 59
4319: PUSH
4320: CALL_OW 44
4324: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4325: LD_EXP 59
4329: PPUSH
4330: LD_INT 324
4332: PPUSH
4333: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4337: LD_ADDR_EXP 60
4341: PUSH
4342: LD_STRING Kozlov
4344: PPUSH
4345: LD_INT 0
4347: PPUSH
4348: LD_STRING 
4350: PPUSH
4351: CALL 64273 0 3
4355: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4356: LD_EXP 60
4360: PPUSH
4361: LD_INT 22
4363: PUSH
4364: LD_INT 8
4366: PUSH
4367: EMPTY
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 23
4373: PUSH
4374: LD_INT 3
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PUSH
4381: LD_INT 30
4383: PUSH
4384: LD_INT 8
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: PPUSH
4396: CALL_OW 69
4400: PUSH
4401: LD_INT 1
4403: ARRAY
4404: PPUSH
4405: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4409: LD_EXP 60
4413: PPUSH
4414: LD_INT 3
4416: PPUSH
4417: LD_INT 10
4419: PPUSH
4420: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4424: LD_ADDR_VAR 0 5
4428: PUSH
4429: LD_INT 22
4431: PUSH
4432: LD_VAR 0 3
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: LD_INT 30
4443: PUSH
4444: LD_INT 32
4446: PUSH
4447: EMPTY
4448: LIST
4449: LIST
4450: PUSH
4451: LD_INT 58
4453: PUSH
4454: EMPTY
4455: LIST
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: LIST
4461: PPUSH
4462: CALL_OW 69
4466: ST_TO_ADDR
// for i = 1 to 10 do
4467: LD_ADDR_VAR 0 2
4471: PUSH
4472: DOUBLE
4473: LD_INT 1
4475: DEC
4476: ST_TO_ADDR
4477: LD_INT 10
4479: PUSH
4480: FOR_TO
4481: IFFALSE 4553
// begin uc_nation := nation_nature ;
4483: LD_ADDR_OWVAR 21
4487: PUSH
4488: LD_INT 0
4490: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4491: LD_ADDR_OWVAR 28
4495: PUSH
4496: LD_INT 15
4498: ST_TO_ADDR
// hc_gallery :=  ;
4499: LD_ADDR_OWVAR 33
4503: PUSH
4504: LD_STRING 
4506: ST_TO_ADDR
// hc_name :=  ;
4507: LD_ADDR_OWVAR 26
4511: PUSH
4512: LD_STRING 
4514: ST_TO_ADDR
// un := CreateHuman ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: CALL_OW 44
4524: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4525: LD_VAR 0 4
4529: PPUSH
4530: LD_VAR 0 5
4534: PUSH
4535: LD_VAR 0 5
4539: PUSH
4540: LD_VAR 0 2
4544: MINUS
4545: ARRAY
4546: PPUSH
4547: CALL_OW 52
// end ;
4551: GO 4480
4553: POP
4554: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4555: LD_ADDR_VAR 0 5
4559: PUSH
4560: LD_STRING 12_kurt_squad
4562: PPUSH
4563: CALL_OW 31
4567: ST_TO_ADDR
// if tmp then
4568: LD_VAR 0 5
4572: IFFALSE 4606
// for i in tmp do
4574: LD_ADDR_VAR 0 2
4578: PUSH
4579: LD_VAR 0 5
4583: PUSH
4584: FOR_IN
4585: IFFALSE 4604
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4587: LD_VAR 0 2
4591: PPUSH
4592: LD_INT 5
4594: PPUSH
4595: LD_INT 0
4597: PPUSH
4598: CALL_OW 49
4602: GO 4584
4604: POP
4605: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4606: LD_INT 324
4608: PPUSH
4609: LD_INT 5
4611: PPUSH
4612: LD_STRING 
4614: PPUSH
4615: LD_INT 8
4617: PUSH
4618: LD_INT 9
4620: PUSH
4621: LD_INT 10
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: LIST
4628: PUSH
4629: LD_OWVAR 67
4633: ARRAY
4634: PPUSH
4635: LD_INT 3000
4637: PUSH
4638: LD_INT 500
4640: PUSH
4641: LD_INT 150
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: LIST
4648: PPUSH
4649: LD_INT 16
4651: PUSH
4652: LD_INT 6
4654: PUSH
4655: LD_INT 6
4657: PUSH
4658: LD_INT 8
4660: PUSH
4661: EMPTY
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: PPUSH
4667: CALL 74797 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4671: LD_ADDR_EXP 101
4675: PUSH
4676: LD_EXP 101
4680: PPUSH
4681: LD_INT 3
4683: PPUSH
4684: LD_INT 22
4686: PUSH
4687: LD_VAR 0 3
4691: PUSH
4692: EMPTY
4693: LIST
4694: LIST
4695: PUSH
4696: LD_INT 23
4698: PUSH
4699: LD_INT 2
4701: PUSH
4702: EMPTY
4703: LIST
4704: LIST
4705: PUSH
4706: LD_INT 3
4708: PUSH
4709: LD_INT 21
4711: PUSH
4712: LD_INT 2
4714: PUSH
4715: EMPTY
4716: LIST
4717: LIST
4718: PUSH
4719: EMPTY
4720: LIST
4721: LIST
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: LIST
4727: PPUSH
4728: CALL_OW 69
4732: PUSH
4733: LD_EXP 59
4737: DIFF
4738: PPUSH
4739: CALL_OW 1
4743: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4744: LD_INT 1
4746: PPUSH
4747: LD_INT 7
4749: PPUSH
4750: CALL_OW 383
// Friend := CreateHuman ;
4754: LD_ADDR_EXP 61
4758: PUSH
4759: CALL_OW 44
4763: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4764: LD_INT 14
4766: PPUSH
4767: LD_INT 3
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 29
4775: PPUSH
4776: LD_INT 100
4778: PPUSH
4779: CALL 71388 0 5
// powellBomb := CreateVehicle ;
4783: LD_ADDR_EXP 62
4787: PUSH
4788: CALL_OW 45
4792: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4793: LD_EXP 62
4797: PPUSH
4798: LD_INT 90
4800: PPUSH
4801: LD_INT 51
4803: PPUSH
4804: LD_INT 0
4806: PPUSH
4807: CALL_OW 48
// end ;
4811: LD_VAR 0 1
4815: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4816: LD_INT 0
4818: PPUSH
4819: PPUSH
4820: PPUSH
// if IsLive ( kozlov_fac ) then
4821: LD_INT 332
4823: PPUSH
4824: CALL_OW 300
4828: IFFALSE 4832
// exit ;
4830: GO 5399
// ComExitBuilding ( Kozlov ) ;
4832: LD_EXP 60
4836: PPUSH
4837: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4841: LD_EXP 60
4845: PPUSH
4846: CALL_OW 257
4850: PUSH
4851: LD_INT 2
4853: NONEQUAL
4854: IFFALSE 4889
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4856: LD_EXP 60
4860: PPUSH
4861: LD_INT 324
4863: PPUSH
4864: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4868: LD_EXP 60
4872: PPUSH
4873: LD_INT 2
4875: PPUSH
4876: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4880: LD_EXP 60
4884: PPUSH
4885: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4889: LD_EXP 60
4893: PPUSH
4894: LD_INT 2
4896: PPUSH
4897: LD_INT 93
4899: PPUSH
4900: LD_INT 32
4902: PPUSH
4903: LD_INT 3
4905: PPUSH
4906: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4910: LD_INT 35
4912: PPUSH
4913: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4917: LD_INT 22
4919: PUSH
4920: LD_INT 8
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PUSH
4927: LD_INT 30
4929: PUSH
4930: LD_INT 3
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 23
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 57
4949: PUSH
4950: EMPTY
4951: LIST
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: LIST
4957: LIST
4958: PPUSH
4959: CALL_OW 69
4963: IFFALSE 4910
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4965: LD_ADDR_VAR 0 2
4969: PUSH
4970: LD_INT 22
4972: PUSH
4973: LD_INT 8
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: PUSH
4980: LD_INT 30
4982: PUSH
4983: LD_INT 3
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: PUSH
4990: LD_INT 23
4992: PUSH
4993: LD_INT 3
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: PUSH
5000: LD_INT 57
5002: PUSH
5003: EMPTY
5004: LIST
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: PPUSH
5012: CALL_OW 69
5016: PUSH
5017: LD_INT 1
5019: ARRAY
5020: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5021: LD_INT 22
5023: PUSH
5024: LD_INT 8
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 23
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 30
5043: PUSH
5044: LD_INT 21
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: LIST
5055: PPUSH
5056: CALL_OW 69
5060: NOT
5061: IFFALSE 5139
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5063: LD_EXP 60
5067: PPUSH
5068: LD_INT 21
5070: PPUSH
5071: LD_INT 97
5073: PPUSH
5074: LD_INT 36
5076: PPUSH
5077: LD_INT 5
5079: PPUSH
5080: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5091: LD_INT 22
5093: PUSH
5094: LD_INT 8
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: LD_INT 23
5103: PUSH
5104: LD_INT 3
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 30
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: PUSH
5121: LD_INT 57
5123: PUSH
5124: EMPTY
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: LIST
5132: PPUSH
5133: CALL_OW 69
5137: IFFALSE 5084
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5139: LD_INT 22
5141: PUSH
5142: LD_INT 8
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PUSH
5149: LD_INT 23
5151: PUSH
5152: LD_INT 3
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 30
5161: PUSH
5162: LD_INT 18
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: NOT
5179: IFFALSE 5257
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5181: LD_EXP 60
5185: PPUSH
5186: LD_INT 18
5188: PPUSH
5189: LD_INT 89
5191: PPUSH
5192: LD_INT 32
5194: PPUSH
5195: LD_INT 1
5197: PPUSH
5198: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5202: LD_INT 35
5204: PPUSH
5205: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5209: LD_INT 22
5211: PUSH
5212: LD_INT 8
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: PUSH
5219: LD_INT 23
5221: PUSH
5222: LD_INT 3
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: PUSH
5229: LD_INT 30
5231: PUSH
5232: LD_INT 18
5234: PUSH
5235: EMPTY
5236: LIST
5237: LIST
5238: PUSH
5239: LD_INT 57
5241: PUSH
5242: EMPTY
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: PPUSH
5251: CALL_OW 69
5255: IFFALSE 5202
// end ; lab := kozlov_lab ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: LD_INT 336
5264: ST_TO_ADDR
// if not lab then
5265: LD_VAR 0 3
5269: NOT
5270: IFFALSE 5274
// exit ;
5272: GO 5399
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5274: LD_EXP 60
5278: PPUSH
5279: LD_VAR 0 3
5283: PUSH
5284: LD_INT 1
5286: ARRAY
5287: PPUSH
5288: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5292: LD_EXP 60
5296: PPUSH
5297: LD_INT 4
5299: PPUSH
5300: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5304: LD_VAR 0 3
5308: PUSH
5309: LD_INT 1
5311: ARRAY
5312: PPUSH
5313: LD_INT 25
5315: PPUSH
5316: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5320: LD_INT 35
5322: PPUSH
5323: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5327: LD_INT 25
5329: PPUSH
5330: LD_INT 8
5332: PPUSH
5333: CALL_OW 321
5337: PUSH
5338: LD_INT 2
5340: EQUAL
5341: IFFALSE 5320
// ComExitBuilding ( Kozlov ) ;
5343: LD_EXP 60
5347: PPUSH
5348: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5352: LD_EXP 60
5356: PPUSH
5357: LD_VAR 0 2
5361: PPUSH
5362: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5366: LD_EXP 60
5370: PPUSH
5371: LD_INT 3
5373: PPUSH
5374: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5378: LD_VAR 0 2
5382: PPUSH
5383: LD_INT 23
5385: PPUSH
5386: LD_INT 3
5388: PPUSH
5389: LD_INT 1
5391: PPUSH
5392: LD_INT 48
5394: PPUSH
5395: CALL_OW 125
// end ;
5399: LD_VAR 0 1
5403: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5404: LD_EXP 22
5408: NOT
5409: PUSH
5410: LD_EXP 15
5414: PUSH
5415: LD_INT 6
5417: GREATEREQUAL
5418: AND
5419: IFFALSE 5500
5421: GO 5423
5423: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5424: LD_INT 3
5426: PPUSH
5427: LD_INT 3
5429: PPUSH
5430: CALL 58066 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5434: LD_INT 3
5436: PPUSH
5437: LD_INT 14
5439: PUSH
5440: LD_INT 1
5442: PUSH
5443: LD_INT 1
5445: PUSH
5446: LD_INT 28
5448: PUSH
5449: EMPTY
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 14
5457: PUSH
5458: LD_INT 1
5460: PUSH
5461: LD_INT 1
5463: PUSH
5464: LD_INT 28
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_INT 14
5475: PUSH
5476: LD_INT 1
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 28
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PPUSH
5496: CALL 57929 0 2
// end ;
5500: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5501: LD_EXP 22
5505: NOT
5506: PUSH
5507: LD_EXP 15
5511: PUSH
5512: LD_INT 6
5514: GREATEREQUAL
5515: AND
5516: PUSH
5517: LD_INT 3
5519: PPUSH
5520: LD_INT 1
5522: PPUSH
5523: CALL 59347 0 2
5527: NOT
5528: AND
5529: IFFALSE 6369
5531: GO 5533
5533: DISABLE
5534: LD_INT 0
5536: PPUSH
5537: PPUSH
5538: PPUSH
// begin enable ;
5539: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5540: LD_INT 22
5542: PUSH
5543: LD_INT 8
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 23
5552: PUSH
5553: LD_INT 2
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: LD_INT 30
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: PPUSH
5575: CALL_OW 69
5579: NOT
5580: IFFALSE 5584
// exit ;
5582: GO 6369
// if Prob ( 40 ) then
5584: LD_INT 40
5586: PPUSH
5587: CALL_OW 13
5591: IFFALSE 5718
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 14
5598: PUSH
5599: LD_INT 1
5601: PUSH
5602: LD_INT 2
5604: PUSH
5605: LD_INT 28
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 14
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 28
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 14
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 28
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 14
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 28
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 14
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 28
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 14
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 26
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: LIST
5711: PPUSH
5712: CALL 57929 0 2
// end else
5716: GO 5909
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5718: LD_INT 3
5720: PPUSH
5721: LD_INT 14
5723: PUSH
5724: LD_INT 1
5726: PUSH
5727: LD_INT 2
5729: PUSH
5730: LD_INT 27
5732: PUSH
5733: LD_INT 26
5735: PUSH
5736: LD_INT 26
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: PUSH
5750: EMPTY
5751: LIST
5752: LIST
5753: LIST
5754: LIST
5755: PUSH
5756: LD_INT 14
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: LD_INT 2
5764: PUSH
5765: LD_INT 27
5767: PUSH
5768: LD_INT 26
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: PUSH
5779: LD_OWVAR 67
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 14
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: LD_INT 26
5805: PUSH
5806: LD_INT 29
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: PUSH
5814: LD_OWVAR 67
5818: ARRAY
5819: PUSH
5820: EMPTY
5821: LIST
5822: LIST
5823: LIST
5824: LIST
5825: PUSH
5826: LD_INT 13
5828: PUSH
5829: LD_INT 1
5831: PUSH
5832: LD_INT 2
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: LD_INT 29
5840: PUSH
5841: LD_INT 29
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_OWVAR 67
5853: ARRAY
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 13
5863: PUSH
5864: LD_INT 1
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 14
5881: PUSH
5882: LD_INT 1
5884: PUSH
5885: LD_INT 2
5887: PUSH
5888: LD_INT 26
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PPUSH
5905: CALL 57929 0 2
// end ; repeat wait ( 0 0$1 ) ;
5909: LD_INT 35
5911: PPUSH
5912: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5916: LD_INT 3
5918: PPUSH
5919: LD_INT 1
5921: PPUSH
5922: CALL 59347 0 2
5926: PUSH
5927: LD_INT 6
5929: GREATEREQUAL
5930: IFFALSE 5909
// wait ( 0 0$30 ) ;
5932: LD_INT 1050
5934: PPUSH
5935: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5939: LD_ADDR_VAR 0 2
5943: PUSH
5944: LD_INT 3
5946: PPUSH
5947: LD_INT 1
5949: PPUSH
5950: CALL 59347 0 2
5954: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5955: LD_ADDR_EXP 120
5959: PUSH
5960: LD_EXP 120
5964: PPUSH
5965: LD_INT 3
5967: PPUSH
5968: LD_EXP 120
5972: PUSH
5973: LD_INT 3
5975: ARRAY
5976: PUSH
5977: LD_VAR 0 2
5981: DIFF
5982: PPUSH
5983: CALL_OW 1
5987: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5988: LD_ADDR_VAR 0 3
5992: PUSH
5993: LD_INT 0
5995: PPUSH
5996: LD_INT 2
5998: PPUSH
5999: CALL_OW 12
6003: ST_TO_ADDR
// if target then
6004: LD_VAR 0 3
6008: IFFALSE 6136
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6010: LD_ADDR_VAR 0 2
6014: PUSH
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_INT 24
6022: PUSH
6023: LD_INT 250
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PPUSH
6030: CALL_OW 72
6034: ST_TO_ADDR
// for i in tmp do
6035: LD_ADDR_VAR 0 1
6039: PUSH
6040: LD_VAR 0 2
6044: PUSH
6045: FOR_IN
6046: IFFALSE 6086
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6048: LD_VAR 0 1
6052: PPUSH
6053: LD_INT 89
6055: PPUSH
6056: LD_INT 71
6058: PPUSH
6059: CALL_OW 297
6063: PUSH
6064: LD_INT 9
6066: GREATER
6067: IFFALSE 6084
// ComMoveXY ( i , 89 , 71 ) ;
6069: LD_VAR 0 1
6073: PPUSH
6074: LD_INT 89
6076: PPUSH
6077: LD_INT 71
6079: PPUSH
6080: CALL_OW 111
6084: GO 6045
6086: POP
6087: POP
// wait ( 0 0$1 ) ;
6088: LD_INT 35
6090: PPUSH
6091: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6095: LD_VAR 0 2
6099: PPUSH
6100: LD_INT 92
6102: PUSH
6103: LD_INT 89
6105: PUSH
6106: LD_INT 71
6108: PUSH
6109: LD_INT 9
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: PPUSH
6118: CALL_OW 72
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: LD_INT 1
6130: MINUS
6131: GREATEREQUAL
6132: IFFALSE 6010
// end else
6134: GO 6260
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6136: LD_ADDR_VAR 0 2
6140: PUSH
6141: LD_VAR 0 2
6145: PPUSH
6146: LD_INT 24
6148: PUSH
6149: LD_INT 250
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: PPUSH
6156: CALL_OW 72
6160: ST_TO_ADDR
// for i in tmp do
6161: LD_ADDR_VAR 0 1
6165: PUSH
6166: LD_VAR 0 2
6170: PUSH
6171: FOR_IN
6172: IFFALSE 6212
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 125
6181: PPUSH
6182: LD_INT 129
6184: PPUSH
6185: CALL_OW 297
6189: PUSH
6190: LD_INT 9
6192: GREATER
6193: IFFALSE 6210
// ComMoveXY ( i , 125 , 129 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 125
6202: PPUSH
6203: LD_INT 129
6205: PPUSH
6206: CALL_OW 111
6210: GO 6171
6212: POP
6213: POP
// wait ( 0 0$1 ) ;
6214: LD_INT 35
6216: PPUSH
6217: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6221: LD_VAR 0 2
6225: PPUSH
6226: LD_INT 92
6228: PUSH
6229: LD_INT 125
6231: PUSH
6232: LD_INT 129
6234: PUSH
6235: LD_INT 9
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: PPUSH
6244: CALL_OW 72
6248: PUSH
6249: LD_VAR 0 2
6253: PUSH
6254: LD_INT 1
6256: MINUS
6257: GREATEREQUAL
6258: IFFALSE 6136
// end ; repeat wait ( 0 0$1 ) ;
6260: LD_INT 35
6262: PPUSH
6263: CALL_OW 67
// for i in tmp do
6267: LD_ADDR_VAR 0 1
6271: PUSH
6272: LD_VAR 0 2
6276: PUSH
6277: FOR_IN
6278: IFFALSE 6360
// begin if GetLives ( i ) > 251 then
6280: LD_VAR 0 1
6284: PPUSH
6285: CALL_OW 256
6289: PUSH
6290: LD_INT 251
6292: GREATER
6293: IFFALSE 6331
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6295: LD_VAR 0 1
6299: PPUSH
6300: LD_INT 81
6302: PUSH
6303: LD_INT 8
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: PPUSH
6310: CALL_OW 69
6314: PPUSH
6315: LD_VAR 0 1
6319: PPUSH
6320: CALL_OW 74
6324: PPUSH
6325: CALL_OW 115
6329: GO 6358
// if IsDead ( i ) then
6331: LD_VAR 0 1
6335: PPUSH
6336: CALL_OW 301
6340: IFFALSE 6358
// tmp := tmp diff i ;
6342: LD_ADDR_VAR 0 2
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: LD_VAR 0 1
6356: DIFF
6357: ST_TO_ADDR
// end ;
6358: GO 6277
6360: POP
6361: POP
// until not tmp ;
6362: LD_VAR 0 2
6366: NOT
6367: IFFALSE 6260
// end ;
6369: PPOPN 3
6371: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6372: LD_EXP 22
6376: NOT
6377: PUSH
6378: LD_EXP 15
6382: PUSH
6383: LD_INT 6
6385: GREATEREQUAL
6386: AND
6387: PUSH
6388: LD_OWVAR 67
6392: PUSH
6393: LD_INT 1
6395: GREATER
6396: AND
6397: IFFALSE 6914
6399: GO 6401
6401: DISABLE
6402: LD_INT 0
6404: PPUSH
6405: PPUSH
6406: PPUSH
// begin enable ;
6407: ENABLE
// tmp := [ ] ;
6408: LD_ADDR_VAR 0 3
6412: PUSH
6413: EMPTY
6414: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: DOUBLE
6421: LD_INT 1
6423: DEC
6424: ST_TO_ADDR
6425: LD_INT 4
6427: PUSH
6428: LD_INT 6
6430: PUSH
6431: LD_INT 7
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: LIST
6438: PUSH
6439: LD_OWVAR 67
6443: ARRAY
6444: PUSH
6445: FOR_TO
6446: IFFALSE 6606
// begin uc_side := 8 ;
6448: LD_ADDR_OWVAR 20
6452: PUSH
6453: LD_INT 8
6455: ST_TO_ADDR
// uc_nation := 2 ;
6456: LD_ADDR_OWVAR 21
6460: PUSH
6461: LD_INT 2
6463: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6464: LD_INT 13
6466: PUSH
6467: LD_INT 14
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 1
6476: PPUSH
6477: LD_INT 2
6479: PPUSH
6480: CALL_OW 12
6484: ARRAY
6485: PPUSH
6486: LD_INT 1
6488: PPUSH
6489: LD_INT 5
6491: PPUSH
6492: LD_INT 27
6494: PUSH
6495: LD_INT 28
6497: PUSH
6498: LD_INT 26
6500: PUSH
6501: LD_INT 25
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 4
6515: PPUSH
6516: CALL_OW 12
6520: ARRAY
6521: PPUSH
6522: LD_INT 88
6524: PPUSH
6525: CALL 71388 0 5
// un := CreateVehicle ;
6529: LD_ADDR_VAR 0 2
6533: PUSH
6534: CALL_OW 45
6538: ST_TO_ADDR
// tmp := tmp ^ un ;
6539: LD_ADDR_VAR 0 3
6543: PUSH
6544: LD_VAR 0 3
6548: PUSH
6549: LD_VAR 0 2
6553: ADD
6554: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6555: LD_VAR 0 2
6559: PPUSH
6560: LD_INT 3
6562: PPUSH
6563: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6567: LD_VAR 0 2
6571: PPUSH
6572: LD_INT 30
6574: PPUSH
6575: LD_INT 0
6577: PPUSH
6578: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6582: LD_VAR 0 2
6586: PPUSH
6587: LD_INT 16
6589: PPUSH
6590: LD_INT 11
6592: PPUSH
6593: CALL_OW 111
// wait ( 0 0$2 ) ;
6597: LD_INT 70
6599: PPUSH
6600: CALL_OW 67
// end ;
6604: GO 6445
6606: POP
6607: POP
// for i = 1 to Difficulty do
6608: LD_ADDR_VAR 0 1
6612: PUSH
6613: DOUBLE
6614: LD_INT 1
6616: DEC
6617: ST_TO_ADDR
6618: LD_OWVAR 67
6622: PUSH
6623: FOR_TO
6624: IFFALSE 6749
// begin uc_side := 8 ;
6626: LD_ADDR_OWVAR 20
6630: PUSH
6631: LD_INT 8
6633: ST_TO_ADDR
// uc_nation := 2 ;
6634: LD_ADDR_OWVAR 21
6638: PUSH
6639: LD_INT 2
6641: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6642: LD_INT 0
6644: PPUSH
6645: LD_INT 8
6647: PPUSH
6648: LD_INT 8
6650: PUSH
6651: LD_INT 8
6653: PUSH
6654: LD_INT 9
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: PUSH
6662: LD_OWVAR 67
6666: ARRAY
6667: PPUSH
6668: CALL_OW 380
// un := CreateHuman ;
6672: LD_ADDR_VAR 0 2
6676: PUSH
6677: CALL_OW 44
6681: ST_TO_ADDR
// tmp := tmp ^ un ;
6682: LD_ADDR_VAR 0 3
6686: PUSH
6687: LD_VAR 0 3
6691: PUSH
6692: LD_VAR 0 2
6696: ADD
6697: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6698: LD_VAR 0 2
6702: PPUSH
6703: LD_INT 3
6705: PPUSH
6706: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6710: LD_VAR 0 2
6714: PPUSH
6715: LD_INT 30
6717: PPUSH
6718: LD_INT 0
6720: PPUSH
6721: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6725: LD_VAR 0 2
6729: PPUSH
6730: LD_INT 16
6732: PPUSH
6733: LD_INT 11
6735: PPUSH
6736: CALL_OW 111
// wait ( 0 0$2 ) ;
6740: LD_INT 70
6742: PPUSH
6743: CALL_OW 67
// end ;
6747: GO 6623
6749: POP
6750: POP
// repeat wait ( 0 0$1 ) ;
6751: LD_INT 35
6753: PPUSH
6754: CALL_OW 67
// for i in tmp do
6758: LD_ADDR_VAR 0 1
6762: PUSH
6763: LD_VAR 0 3
6767: PUSH
6768: FOR_IN
6769: IFFALSE 6905
// begin if GetLives ( i ) > 250 then
6771: LD_VAR 0 1
6775: PPUSH
6776: CALL_OW 256
6780: PUSH
6781: LD_INT 250
6783: GREATER
6784: IFFALSE 6876
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6786: LD_INT 81
6788: PUSH
6789: LD_INT 8
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 91
6798: PUSH
6799: LD_VAR 0 1
6803: PUSH
6804: LD_INT 10
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: NOT
6821: IFFALSE 6840
// ComAgressiveMove ( i , 67 , 110 ) else
6823: LD_VAR 0 1
6827: PPUSH
6828: LD_INT 67
6830: PPUSH
6831: LD_INT 110
6833: PPUSH
6834: CALL_OW 114
6838: GO 6874
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6840: LD_VAR 0 1
6844: PPUSH
6845: LD_INT 81
6847: PUSH
6848: LD_INT 8
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 69
6859: PPUSH
6860: LD_VAR 0 1
6864: PPUSH
6865: CALL_OW 74
6869: PPUSH
6870: CALL_OW 115
// end else
6874: GO 6903
// if IsDead ( i ) then
6876: LD_VAR 0 1
6880: PPUSH
6881: CALL_OW 301
6885: IFFALSE 6903
// tmp := tmp diff i ;
6887: LD_ADDR_VAR 0 3
6891: PUSH
6892: LD_VAR 0 3
6896: PUSH
6897: LD_VAR 0 1
6901: DIFF
6902: ST_TO_ADDR
// end ;
6903: GO 6768
6905: POP
6906: POP
// until not tmp ;
6907: LD_VAR 0 3
6911: NOT
6912: IFFALSE 6751
// end ; end_of_file
6914: PPOPN 3
6916: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6917: LD_INT 0
6919: PPUSH
6920: PPUSH
6921: PPUSH
6922: PPUSH
6923: PPUSH
6924: PPUSH
6925: PPUSH
6926: PPUSH
6927: PPUSH
// side := 3 ;
6928: LD_ADDR_VAR 0 6
6932: PUSH
6933: LD_INT 3
6935: ST_TO_ADDR
// uc_side := side ;
6936: LD_ADDR_OWVAR 20
6940: PUSH
6941: LD_VAR 0 6
6945: ST_TO_ADDR
// uc_nation := 3 ;
6946: LD_ADDR_OWVAR 21
6950: PUSH
6951: LD_INT 3
6953: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_INT 22
6961: PUSH
6962: LD_VAR 0 6
6966: PUSH
6967: EMPTY
6968: LIST
6969: LIST
6970: PUSH
6971: LD_INT 21
6973: PUSH
6974: LD_INT 3
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: FOR_IN
6991: IFFALSE 7007
// SetBLevel ( i , 10 ) ;
6993: LD_VAR 0 2
6997: PPUSH
6998: LD_INT 10
7000: PPUSH
7001: CALL_OW 241
7005: GO 6990
7007: POP
7008: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7009: LD_ADDR_VAR 0 9
7013: PUSH
7014: LD_INT 22
7016: PUSH
7017: LD_VAR 0 6
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 30
7028: PUSH
7029: LD_INT 34
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PPUSH
7040: CALL_OW 69
7044: ST_TO_ADDR
// if teleport then
7045: LD_VAR 0 9
7049: IFFALSE 7070
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7051: LD_VAR 0 9
7055: PUSH
7056: LD_INT 1
7058: ARRAY
7059: PPUSH
7060: LD_INT 123
7062: PPUSH
7063: LD_INT 122
7065: PPUSH
7066: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7070: LD_ADDR_EXP 63
7074: PUSH
7075: LD_STRING Platonov
7077: PPUSH
7078: CALL_OW 25
7082: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7083: LD_ADDR_EXP 64
7087: PUSH
7088: LD_STRING Kovalyuk
7090: PPUSH
7091: CALL_OW 25
7095: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7096: LD_ADDR_EXP 66
7100: PUSH
7101: LD_STRING Yakotich
7103: PPUSH
7104: CALL_OW 25
7108: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7109: LD_ADDR_EXP 65
7113: PUSH
7114: LD_STRING Bystrov
7116: PPUSH
7117: CALL_OW 25
7121: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7122: LD_ADDR_EXP 67
7126: PUSH
7127: LD_STRING Gleb
7129: PPUSH
7130: CALL_OW 25
7134: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7135: LD_STRING 03_Cornel
7137: PPUSH
7138: CALL_OW 28
7142: IFFALSE 7190
// begin Bierezov := NewCharacter ( Mikhail ) ;
7144: LD_ADDR_EXP 68
7148: PUSH
7149: LD_STRING Mikhail
7151: PPUSH
7152: CALL_OW 25
7156: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7157: LD_EXP 68
7161: PPUSH
7162: LD_INT 197
7164: PPUSH
7165: LD_INT 111
7167: PPUSH
7168: LD_INT 9
7170: PPUSH
7171: LD_INT 0
7173: PPUSH
7174: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7178: LD_EXP 68
7182: PPUSH
7183: LD_INT 3
7185: PPUSH
7186: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7190: LD_EXP 63
7194: PPUSH
7195: LD_INT 126
7197: PPUSH
7198: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7202: LD_EXP 64
7206: PPUSH
7207: LD_INT 134
7209: PPUSH
7210: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7214: LD_EXP 66
7218: PPUSH
7219: LD_INT 197
7221: PPUSH
7222: LD_INT 111
7224: PPUSH
7225: LD_INT 9
7227: PPUSH
7228: LD_INT 0
7230: PPUSH
7231: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7235: LD_EXP 65
7239: PPUSH
7240: LD_INT 197
7242: PPUSH
7243: LD_INT 111
7245: PPUSH
7246: LD_INT 9
7248: PPUSH
7249: LD_INT 0
7251: PPUSH
7252: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7256: LD_EXP 67
7260: PPUSH
7261: LD_INT 197
7263: PPUSH
7264: LD_INT 111
7266: PPUSH
7267: LD_INT 9
7269: PPUSH
7270: LD_INT 0
7272: PPUSH
7273: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7277: LD_ADDR_VAR 0 5
7281: PUSH
7282: LD_INT 126
7284: PPUSH
7285: LD_INT 4
7287: PPUSH
7288: LD_STRING zhukov
7290: PPUSH
7291: LD_INT 9
7293: PUSH
7294: LD_INT 10
7296: PUSH
7297: LD_INT 10
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: LIST
7304: PUSH
7305: LD_OWVAR 67
7309: ARRAY
7310: PPUSH
7311: LD_INT 90000
7313: PUSH
7314: LD_INT 1000
7316: PUSH
7317: LD_INT 300
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: PPUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 8
7330: PUSH
7331: LD_INT 13
7333: PUSH
7334: LD_INT 8
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL 74797 0 6
7347: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7348: LD_ADDR_VAR 0 4
7352: PUSH
7353: LD_INT 267
7355: PPUSH
7356: CALL_OW 274
7360: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7361: LD_VAR 0 4
7365: PPUSH
7366: LD_INT 1
7368: PPUSH
7369: LD_INT 5000
7371: PPUSH
7372: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7376: LD_VAR 0 4
7380: PPUSH
7381: LD_INT 2
7383: PPUSH
7384: LD_INT 200
7386: PPUSH
7387: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7391: LD_VAR 0 4
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 200
7401: PPUSH
7402: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7406: LD_ADDR_EXP 101
7410: PUSH
7411: LD_EXP 101
7415: PPUSH
7416: LD_INT 2
7418: PPUSH
7419: LD_VAR 0 5
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_VAR 0 6
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PUSH
7436: LD_INT 3
7438: PUSH
7439: LD_INT 21
7441: PUSH
7442: LD_INT 2
7444: PUSH
7445: EMPTY
7446: LIST
7447: LIST
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PPUSH
7457: CALL_OW 69
7461: UNION
7462: PUSH
7463: LD_EXP 63
7467: DIFF
7468: PPUSH
7469: CALL_OW 1
7473: ST_TO_ADDR
// behemoths := [ ] ;
7474: LD_ADDR_EXP 71
7478: PUSH
7479: EMPTY
7480: ST_TO_ADDR
// behemothBuilders := [ ] ;
7481: LD_ADDR_EXP 72
7485: PUSH
7486: EMPTY
7487: ST_TO_ADDR
// if Kovalyuk then
7488: LD_EXP 64
7492: IFFALSE 7514
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7494: LD_ADDR_EXP 72
7498: PUSH
7499: LD_EXP 72
7503: PPUSH
7504: LD_EXP 64
7508: PPUSH
7509: CALL 107136 0 2
7513: ST_TO_ADDR
// j := 3 ;
7514: LD_ADDR_VAR 0 3
7518: PUSH
7519: LD_INT 3
7521: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_INT 22
7529: PUSH
7530: LD_INT 3
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 25
7539: PUSH
7540: LD_INT 3
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PPUSH
7551: CALL_OW 69
7555: PUSH
7556: LD_EXP 64
7560: DIFF
7561: PUSH
7562: FOR_IN
7563: IFFALSE 7613
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7565: LD_ADDR_EXP 72
7569: PUSH
7570: LD_EXP 72
7574: PPUSH
7575: LD_VAR 0 2
7579: PPUSH
7580: CALL 107136 0 2
7584: ST_TO_ADDR
// j := j - 1 ;
7585: LD_ADDR_VAR 0 3
7589: PUSH
7590: LD_VAR 0 3
7594: PUSH
7595: LD_INT 1
7597: MINUS
7598: ST_TO_ADDR
// if j = 0 then
7599: LD_VAR 0 3
7603: PUSH
7604: LD_INT 0
7606: EQUAL
7607: IFFALSE 7611
// break ;
7609: GO 7613
// end ;
7611: GO 7562
7613: POP
7614: POP
// end ;
7615: LD_VAR 0 1
7619: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7620: LD_INT 0
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
7626: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7627: LD_ADDR_VAR 0 4
7631: PUSH
7632: LD_INT 209
7634: PUSH
7635: LD_INT 149
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PUSH
7642: LD_INT 219
7644: PUSH
7645: LD_INT 154
7647: PUSH
7648: EMPTY
7649: LIST
7650: LIST
7651: PUSH
7652: LD_INT 223
7654: PUSH
7655: LD_INT 149
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 232
7664: PUSH
7665: LD_INT 155
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: ST_TO_ADDR
// if not behemothBuilders then
7678: LD_EXP 72
7682: NOT
7683: IFFALSE 7687
// exit ;
7685: GO 7791
// j := 1 ;
7687: LD_ADDR_VAR 0 3
7691: PUSH
7692: LD_INT 1
7694: ST_TO_ADDR
// for i in behemothBuilders do
7695: LD_ADDR_VAR 0 2
7699: PUSH
7700: LD_EXP 72
7704: PUSH
7705: FOR_IN
7706: IFFALSE 7789
// begin if IsInUnit ( i ) then
7708: LD_VAR 0 2
7712: PPUSH
7713: CALL_OW 310
7717: IFFALSE 7728
// ComExitBuilding ( i ) ;
7719: LD_VAR 0 2
7723: PPUSH
7724: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7728: LD_VAR 0 2
7732: PPUSH
7733: LD_INT 37
7735: PPUSH
7736: LD_VAR 0 4
7740: PUSH
7741: LD_VAR 0 3
7745: ARRAY
7746: PUSH
7747: LD_INT 1
7749: ARRAY
7750: PPUSH
7751: LD_VAR 0 4
7755: PUSH
7756: LD_VAR 0 3
7760: ARRAY
7761: PUSH
7762: LD_INT 2
7764: ARRAY
7765: PPUSH
7766: LD_INT 0
7768: PPUSH
7769: CALL_OW 230
// j := j + 1 ;
7773: LD_ADDR_VAR 0 3
7777: PUSH
7778: LD_VAR 0 3
7782: PUSH
7783: LD_INT 1
7785: PLUS
7786: ST_TO_ADDR
// end ;
7787: GO 7705
7789: POP
7790: POP
// end ;
7791: LD_VAR 0 1
7795: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7796: LD_INT 24
7798: PPUSH
7799: LD_INT 30
7801: PUSH
7802: LD_INT 37
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PPUSH
7809: CALL_OW 70
7813: IFFALSE 7826
7815: GO 7817
7817: DISABLE
// behemothUnderConstruct := true ;
7818: LD_ADDR_EXP 26
7822: PUSH
7823: LD_INT 1
7825: ST_TO_ADDR
7826: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7827: LD_INT 3
7829: PPUSH
7830: CALL 107184 0 1
7834: PUSH
7835: LD_INT 22
7837: PUSH
7838: LD_INT 3
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: LD_INT 30
7847: PUSH
7848: LD_INT 37
7850: PUSH
7851: EMPTY
7852: LIST
7853: LIST
7854: PUSH
7855: EMPTY
7856: LIST
7857: LIST
7858: PPUSH
7859: CALL_OW 69
7863: NOT
7864: AND
7865: IFFALSE 8051
7867: GO 7869
7869: DISABLE
7870: LD_INT 0
7872: PPUSH
7873: PPUSH
// begin enable ;
7874: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7875: LD_ADDR_VAR 0 2
7879: PUSH
7880: LD_INT 3
7882: PPUSH
7883: CALL 107184 0 1
7887: ST_TO_ADDR
// for i in tmp do
7888: LD_ADDR_VAR 0 1
7892: PUSH
7893: LD_VAR 0 2
7897: PUSH
7898: FOR_IN
7899: IFFALSE 8049
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7901: LD_VAR 0 1
7905: PPUSH
7906: LD_INT 9
7908: PPUSH
7909: CALL_OW 308
7913: PUSH
7914: LD_VAR 0 1
7918: PPUSH
7919: CALL_OW 110
7923: PUSH
7924: LD_INT 2
7926: EQUAL
7927: NOT
7928: AND
7929: IFFALSE 7943
// SetTag ( i , 2 ) ;
7931: LD_VAR 0 1
7935: PPUSH
7936: LD_INT 2
7938: PPUSH
7939: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7943: LD_INT 81
7945: PUSH
7946: LD_INT 3
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PUSH
7953: LD_INT 91
7955: PUSH
7956: LD_VAR 0 1
7960: PUSH
7961: LD_INT 12
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: LIST
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PPUSH
7973: CALL_OW 69
7977: NOT
7978: PUSH
7979: LD_VAR 0 1
7983: PPUSH
7984: CALL_OW 110
7988: PUSH
7989: LD_INT 2
7991: EQUAL
7992: NOT
7993: AND
7994: IFFALSE 8013
// ComAgressiveMove ( i , 64 , 93 ) else
7996: LD_VAR 0 1
8000: PPUSH
8001: LD_INT 64
8003: PPUSH
8004: LD_INT 93
8006: PPUSH
8007: CALL_OW 114
8011: GO 8047
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8013: LD_VAR 0 1
8017: PPUSH
8018: LD_INT 81
8020: PUSH
8021: LD_INT 3
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PPUSH
8028: CALL_OW 69
8032: PPUSH
8033: LD_VAR 0 1
8037: PPUSH
8038: CALL_OW 74
8042: PPUSH
8043: CALL_OW 115
// end ;
8047: GO 7898
8049: POP
8050: POP
// end ;
8051: PPOPN 2
8053: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8054: LD_INT 0
8056: PPUSH
8057: PPUSH
8058: PPUSH
// result := [ ] ;
8059: LD_ADDR_VAR 0 2
8063: PUSH
8064: EMPTY
8065: ST_TO_ADDR
// uc_side := 6 ;
8066: LD_ADDR_OWVAR 20
8070: PUSH
8071: LD_INT 6
8073: ST_TO_ADDR
// uc_nation := 3 ;
8074: LD_ADDR_OWVAR 21
8078: PUSH
8079: LD_INT 3
8081: ST_TO_ADDR
// case strength of 1 :
8082: LD_VAR 0 1
8086: PUSH
8087: LD_INT 1
8089: DOUBLE
8090: EQUAL
8091: IFTRUE 8095
8093: GO 8233
8095: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8096: LD_ADDR_VAR 0 3
8100: PUSH
8101: DOUBLE
8102: LD_INT 1
8104: DEC
8105: ST_TO_ADDR
8106: LD_INT 4
8108: PUSH
8109: LD_INT 5
8111: PUSH
8112: LD_INT 6
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PUSH
8126: FOR_TO
8127: IFFALSE 8229
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8129: LD_INT 22
8131: PUSH
8132: LD_INT 24
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: PUSH
8139: LD_VAR 0 3
8143: PUSH
8144: LD_INT 2
8146: MOD
8147: PUSH
8148: LD_INT 1
8150: PLUS
8151: ARRAY
8152: PPUSH
8153: LD_INT 1
8155: PUSH
8156: LD_INT 3
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PUSH
8163: LD_INT 1
8165: PPUSH
8166: LD_INT 2
8168: PPUSH
8169: CALL_OW 12
8173: ARRAY
8174: PPUSH
8175: LD_INT 3
8177: PPUSH
8178: LD_INT 43
8180: PUSH
8181: LD_INT 44
8183: PUSH
8184: LD_INT 45
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: LIST
8191: PUSH
8192: LD_INT 1
8194: PPUSH
8195: LD_INT 3
8197: PPUSH
8198: CALL_OW 12
8202: ARRAY
8203: PPUSH
8204: LD_INT 80
8206: PPUSH
8207: CALL 71388 0 5
// result := result union CreateVehicle ;
8211: LD_ADDR_VAR 0 2
8215: PUSH
8216: LD_VAR 0 2
8220: PUSH
8221: CALL_OW 45
8225: UNION
8226: ST_TO_ADDR
// end ;
8227: GO 8126
8229: POP
8230: POP
// end ; 2 :
8231: GO 9177
8233: LD_INT 2
8235: DOUBLE
8236: EQUAL
8237: IFTRUE 8241
8239: GO 8397
8241: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8242: LD_ADDR_VAR 0 3
8246: PUSH
8247: DOUBLE
8248: LD_INT 1
8250: DEC
8251: ST_TO_ADDR
8252: LD_INT 5
8254: PUSH
8255: LD_INT 6
8257: PUSH
8258: LD_INT 7
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: LIST
8265: PUSH
8266: LD_OWVAR 67
8270: ARRAY
8271: PUSH
8272: FOR_TO
8273: IFFALSE 8393
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8275: LD_INT 22
8277: PUSH
8278: LD_INT 24
8280: PUSH
8281: LD_INT 24
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: LIST
8288: PUSH
8289: LD_VAR 0 3
8293: PUSH
8294: LD_INT 3
8296: MOD
8297: PUSH
8298: LD_INT 1
8300: PLUS
8301: ARRAY
8302: PPUSH
8303: LD_INT 1
8305: PUSH
8306: LD_INT 3
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: PUSH
8313: LD_INT 1
8315: PPUSH
8316: LD_INT 2
8318: PPUSH
8319: CALL_OW 12
8323: ARRAY
8324: PPUSH
8325: LD_INT 3
8327: PPUSH
8328: LD_INT 43
8330: PUSH
8331: LD_INT 44
8333: PUSH
8334: LD_INT 45
8336: PUSH
8337: LD_INT 44
8339: PUSH
8340: LD_INT 46
8342: PUSH
8343: LD_INT 46
8345: PUSH
8346: EMPTY
8347: LIST
8348: LIST
8349: LIST
8350: LIST
8351: LIST
8352: LIST
8353: PUSH
8354: LD_VAR 0 3
8358: PUSH
8359: LD_INT 6
8361: MOD
8362: PUSH
8363: LD_INT 1
8365: PLUS
8366: ARRAY
8367: PPUSH
8368: LD_INT 80
8370: PPUSH
8371: CALL 71388 0 5
// result := result union CreateVehicle ;
8375: LD_ADDR_VAR 0 2
8379: PUSH
8380: LD_VAR 0 2
8384: PUSH
8385: CALL_OW 45
8389: UNION
8390: ST_TO_ADDR
// end ;
8391: GO 8272
8393: POP
8394: POP
// end ; 3 :
8395: GO 9177
8397: LD_INT 3
8399: DOUBLE
8400: EQUAL
8401: IFTRUE 8405
8403: GO 8561
8405: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8406: LD_ADDR_VAR 0 3
8410: PUSH
8411: DOUBLE
8412: LD_INT 1
8414: DEC
8415: ST_TO_ADDR
8416: LD_INT 5
8418: PUSH
8419: LD_INT 7
8421: PUSH
8422: LD_INT 8
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: LIST
8429: PUSH
8430: LD_OWVAR 67
8434: ARRAY
8435: PUSH
8436: FOR_TO
8437: IFFALSE 8557
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8439: LD_INT 22
8441: PUSH
8442: LD_INT 24
8444: PUSH
8445: LD_INT 24
8447: PUSH
8448: EMPTY
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_VAR 0 3
8457: PUSH
8458: LD_INT 3
8460: MOD
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: ARRAY
8466: PPUSH
8467: LD_INT 1
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 1
8479: PPUSH
8480: LD_INT 2
8482: PPUSH
8483: CALL_OW 12
8487: ARRAY
8488: PPUSH
8489: LD_INT 3
8491: PPUSH
8492: LD_INT 43
8494: PUSH
8495: LD_INT 47
8497: PUSH
8498: LD_INT 45
8500: PUSH
8501: LD_INT 45
8503: PUSH
8504: LD_INT 46
8506: PUSH
8507: LD_INT 46
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: LIST
8514: LIST
8515: LIST
8516: LIST
8517: PUSH
8518: LD_VAR 0 3
8522: PUSH
8523: LD_INT 6
8525: MOD
8526: PUSH
8527: LD_INT 1
8529: PLUS
8530: ARRAY
8531: PPUSH
8532: LD_INT 80
8534: PPUSH
8535: CALL 71388 0 5
// result := result union CreateVehicle ;
8539: LD_ADDR_VAR 0 2
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: CALL_OW 45
8553: UNION
8554: ST_TO_ADDR
// end ;
8555: GO 8436
8557: POP
8558: POP
// end ; 4 :
8559: GO 9177
8561: LD_INT 4
8563: DOUBLE
8564: EQUAL
8565: IFTRUE 8569
8567: GO 9176
8569: POP
// begin uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8578: LD_ADDR_VAR 0 3
8582: PUSH
8583: DOUBLE
8584: LD_INT 1
8586: DEC
8587: ST_TO_ADDR
8588: LD_INT 6
8590: PUSH
8591: LD_INT 8
8593: PUSH
8594: LD_INT 9
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: LIST
8601: PUSH
8602: LD_OWVAR 67
8606: ARRAY
8607: PUSH
8608: FOR_TO
8609: IFFALSE 8729
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8611: LD_INT 22
8613: PUSH
8614: LD_INT 24
8616: PUSH
8617: LD_INT 24
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: LIST
8624: PUSH
8625: LD_VAR 0 3
8629: PUSH
8630: LD_INT 3
8632: MOD
8633: PUSH
8634: LD_INT 1
8636: PLUS
8637: ARRAY
8638: PPUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PUSH
8649: LD_INT 1
8651: PPUSH
8652: LD_INT 2
8654: PPUSH
8655: CALL_OW 12
8659: ARRAY
8660: PPUSH
8661: LD_INT 3
8663: PPUSH
8664: LD_INT 45
8666: PUSH
8667: LD_INT 47
8669: PUSH
8670: LD_INT 47
8672: PUSH
8673: LD_INT 45
8675: PUSH
8676: LD_INT 46
8678: PUSH
8679: LD_INT 46
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_VAR 0 3
8694: PUSH
8695: LD_INT 6
8697: MOD
8698: PUSH
8699: LD_INT 1
8701: PLUS
8702: ARRAY
8703: PPUSH
8704: LD_INT 80
8706: PPUSH
8707: CALL 71388 0 5
// result := result union CreateVehicle ;
8711: LD_ADDR_VAR 0 2
8715: PUSH
8716: LD_VAR 0 2
8720: PUSH
8721: CALL_OW 45
8725: UNION
8726: ST_TO_ADDR
// end ;
8727: GO 8608
8729: POP
8730: POP
// if not KappaStatus then
8731: LD_EXP 2
8735: NOT
8736: IFFALSE 8971
// begin uc_nation := 1 ;
8738: LD_ADDR_OWVAR 21
8742: PUSH
8743: LD_INT 1
8745: ST_TO_ADDR
// for i = 1 to 3 do
8746: LD_ADDR_VAR 0 3
8750: PUSH
8751: DOUBLE
8752: LD_INT 1
8754: DEC
8755: ST_TO_ADDR
8756: LD_INT 3
8758: PUSH
8759: FOR_TO
8760: IFFALSE 8896
// begin j := rand ( 0 , 1 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 0
8769: PPUSH
8770: LD_INT 1
8772: PPUSH
8773: CALL_OW 12
8777: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8778: LD_INT 3
8780: PUSH
8781: LD_INT 5
8783: PUSH
8784: LD_INT 5
8786: PUSH
8787: LD_INT 4
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: LIST
8794: LIST
8795: PUSH
8796: LD_VAR 0 4
8800: PUSH
8801: LD_INT 1
8803: PPUSH
8804: LD_INT 3
8806: PPUSH
8807: CALL_OW 12
8811: PLUS
8812: ARRAY
8813: PPUSH
8814: LD_INT 1
8816: PUSH
8817: LD_INT 3
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: LD_INT 1
8826: PPUSH
8827: LD_INT 2
8829: PPUSH
8830: CALL_OW 12
8834: ARRAY
8835: PPUSH
8836: LD_INT 3
8838: PPUSH
8839: LD_INT 9
8841: PUSH
8842: LD_INT 7
8844: PUSH
8845: LD_INT 6
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: LD_VAR 0 4
8857: PUSH
8858: LD_INT 1
8860: PPUSH
8861: LD_INT 2
8863: PPUSH
8864: CALL_OW 12
8868: PLUS
8869: ARRAY
8870: PPUSH
8871: LD_INT 85
8873: PPUSH
8874: CALL 71388 0 5
// result := result union CreateVehicle ;
8878: LD_ADDR_VAR 0 2
8882: PUSH
8883: LD_VAR 0 2
8887: PUSH
8888: CALL_OW 45
8892: UNION
8893: ST_TO_ADDR
// end ;
8894: GO 8759
8896: POP
8897: POP
// if vsevolodFirstAttack then
8898: LD_EXP 24
8902: IFFALSE 8969
// begin vsevolodFirstAttack := false ;
8904: LD_ADDR_EXP 24
8908: PUSH
8909: LD_INT 0
8911: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8912: LD_INT 5
8914: PPUSH
8915: LD_INT 3
8917: PPUSH
8918: LD_INT 1
8920: PPUSH
8921: LD_INT 6
8923: PPUSH
8924: LD_INT 100
8926: PPUSH
8927: CALL 71388 0 5
// sewiVeh := CreateVehicle ;
8931: LD_ADDR_EXP 70
8935: PUSH
8936: CALL_OW 45
8940: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8941: LD_EXP 70
8945: PPUSH
8946: LD_INT 1
8948: PPUSH
8949: CALL_OW 242
// result := result union sewiVeh ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_VAR 0 2
8962: PUSH
8963: LD_EXP 70
8967: UNION
8968: ST_TO_ADDR
// end ; end else
8969: GO 9174
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9174
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// uc_nation := 3 ;
8985: LD_ADDR_OWVAR 21
8989: PUSH
8990: LD_INT 3
8992: ST_TO_ADDR
// for i = 1 to 3 do
8993: LD_ADDR_VAR 0 3
8997: PUSH
8998: DOUBLE
8999: LD_INT 1
9001: DEC
9002: ST_TO_ADDR
9003: LD_INT 3
9005: PUSH
9006: FOR_TO
9007: IFFALSE 9115
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9009: LD_INT 22
9011: PUSH
9012: LD_INT 24
9014: PUSH
9015: LD_INT 24
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: LIST
9022: PUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 3
9030: MOD
9031: PUSH
9032: LD_INT 1
9034: PLUS
9035: ARRAY
9036: PPUSH
9037: LD_INT 1
9039: PUSH
9040: LD_INT 3
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: LD_INT 1
9049: PPUSH
9050: LD_INT 2
9052: PPUSH
9053: CALL_OW 12
9057: ARRAY
9058: PPUSH
9059: LD_INT 3
9061: PPUSH
9062: LD_INT 45
9064: PUSH
9065: LD_INT 47
9067: PUSH
9068: LD_INT 47
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: LIST
9075: PUSH
9076: LD_VAR 0 3
9080: PUSH
9081: LD_INT 3
9083: MOD
9084: PUSH
9085: LD_INT 1
9087: PLUS
9088: ARRAY
9089: PPUSH
9090: LD_INT 80
9092: PPUSH
9093: CALL 71388 0 5
// result := result union CreateVehicle ;
9097: LD_ADDR_VAR 0 2
9101: PUSH
9102: LD_VAR 0 2
9106: PUSH
9107: CALL_OW 45
9111: UNION
9112: ST_TO_ADDR
// end ;
9113: GO 9006
9115: POP
9116: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9117: LD_INT 24
9119: PPUSH
9120: LD_INT 3
9122: PPUSH
9123: LD_INT 1
9125: PPUSH
9126: LD_INT 47
9128: PPUSH
9129: LD_INT 100
9131: PPUSH
9132: CALL 71388 0 5
// sewiVeh := CreateVehicle ;
9136: LD_ADDR_EXP 70
9140: PUSH
9141: CALL_OW 45
9145: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9146: LD_EXP 70
9150: PPUSH
9151: LD_INT 1
9153: PPUSH
9154: CALL_OW 242
// result := result union sewiVeh ;
9158: LD_ADDR_VAR 0 2
9162: PUSH
9163: LD_VAR 0 2
9167: PUSH
9168: LD_EXP 70
9172: UNION
9173: ST_TO_ADDR
// end ; end ; end ;
9174: GO 9177
9176: POP
// end ;
9177: LD_VAR 0 2
9181: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9182: LD_EXP 16
9186: IFFALSE 9944
9188: GO 9190
9190: DISABLE
9191: LD_INT 0
9193: PPUSH
9194: PPUSH
9195: PPUSH
9196: PPUSH
9197: PPUSH
9198: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9199: LD_ADDR_VAR 0 4
9203: PUSH
9204: LD_INT 11
9206: PUSH
9207: LD_INT 12
9209: PUSH
9210: EMPTY
9211: LIST
9212: LIST
9213: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$40 , 4 4$10 ] [ Difficulty ] ;
9214: LD_ADDR_VAR 0 3
9218: PUSH
9219: LD_INT 11550
9221: PUSH
9222: LD_INT 9800
9224: PUSH
9225: LD_INT 8750
9227: PUSH
9228: EMPTY
9229: LIST
9230: LIST
9231: LIST
9232: PUSH
9233: LD_OWVAR 67
9237: ARRAY
9238: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9239: LD_ADDR_VAR 0 6
9243: PUSH
9244: LD_INT 70
9246: PUSH
9247: LD_INT 118
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: LD_INT 78
9256: PUSH
9257: LD_INT 31
9259: PUSH
9260: EMPTY
9261: LIST
9262: LIST
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: ST_TO_ADDR
// repeat if missionStage = 2 then
9268: LD_EXP 15
9272: PUSH
9273: LD_INT 2
9275: EQUAL
9276: IFFALSE 9287
// wait ( 1 1$30 ) else
9278: LD_INT 3150
9280: PPUSH
9281: CALL_OW 67
9285: GO 9296
// wait ( time ) ;
9287: LD_VAR 0 3
9291: PPUSH
9292: CALL_OW 67
// if missionStage = 6 then
9296: LD_EXP 15
9300: PUSH
9301: LD_INT 6
9303: EQUAL
9304: IFFALSE 9332
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9306: LD_INT 51
9308: PPUSH
9309: LD_INT 6
9311: PPUSH
9312: LD_INT 2
9314: PPUSH
9315: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9319: LD_INT 57
9321: PPUSH
9322: LD_INT 6
9324: PPUSH
9325: LD_INT 2
9327: PPUSH
9328: CALL_OW 322
// end ; if missionStage = 8 then
9332: LD_EXP 15
9336: PUSH
9337: LD_INT 8
9339: EQUAL
9340: IFFALSE 9368
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9342: LD_INT 52
9344: PPUSH
9345: LD_INT 6
9347: PPUSH
9348: LD_INT 2
9350: PPUSH
9351: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9355: LD_INT 58
9357: PPUSH
9358: LD_INT 6
9360: PPUSH
9361: LD_INT 2
9363: PPUSH
9364: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9368: LD_EXP 15
9372: PUSH
9373: LD_INT 10
9375: EQUAL
9376: PUSH
9377: LD_OWVAR 67
9381: PUSH
9382: LD_INT 1
9384: GREATER
9385: AND
9386: IFFALSE 9414
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9388: LD_INT 53
9390: PPUSH
9391: LD_INT 6
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9401: LD_INT 59
9403: PPUSH
9404: LD_INT 6
9406: PPUSH
9407: LD_INT 2
9409: PPUSH
9410: CALL_OW 322
// end ; if activeAttacks then
9414: LD_EXP 16
9418: IFFALSE 9938
// begin if missionStage = 2 then
9420: LD_EXP 15
9424: PUSH
9425: LD_INT 2
9427: EQUAL
9428: IFFALSE 9438
// strength := 1 ;
9430: LD_ADDR_VAR 0 5
9434: PUSH
9435: LD_INT 1
9437: ST_TO_ADDR
// if missionStage > 2 then
9438: LD_EXP 15
9442: PUSH
9443: LD_INT 2
9445: GREATER
9446: IFFALSE 9456
// strength := 2 ;
9448: LD_ADDR_VAR 0 5
9452: PUSH
9453: LD_INT 2
9455: ST_TO_ADDR
// if missionStage > 6 then
9456: LD_EXP 15
9460: PUSH
9461: LD_INT 6
9463: GREATER
9464: IFFALSE 9474
// strength := 3 ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 3
9473: ST_TO_ADDR
// if missionStage > 10 then
9474: LD_EXP 15
9478: PUSH
9479: LD_INT 10
9481: GREATER
9482: IFFALSE 9492
// strength := 4 ;
9484: LD_ADDR_VAR 0 5
9488: PUSH
9489: LD_INT 4
9491: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9492: LD_ADDR_VAR 0 2
9496: PUSH
9497: LD_VAR 0 5
9501: PPUSH
9502: CALL 8054 0 1
9506: ST_TO_ADDR
// for i in tmp do
9507: LD_ADDR_VAR 0 1
9511: PUSH
9512: LD_VAR 0 2
9516: PUSH
9517: FOR_IN
9518: IFFALSE 9618
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9520: LD_VAR 0 1
9524: PPUSH
9525: LD_VAR 0 4
9529: PUSH
9530: LD_INT 1
9532: PPUSH
9533: LD_INT 2
9535: PPUSH
9536: CALL_OW 12
9540: ARRAY
9541: PPUSH
9542: LD_INT 0
9544: PPUSH
9545: CALL_OW 49
// if i = sewiVeh then
9549: LD_VAR 0 1
9553: PUSH
9554: LD_EXP 70
9558: EQUAL
9559: IFFALSE 9594
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9561: LD_ADDR_EXP 69
9565: PUSH
9566: LD_STRING Vsevolod
9568: PPUSH
9569: LD_INT 0
9571: PPUSH
9572: LD_STRING 
9574: PPUSH
9575: CALL 64273 0 3
9579: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9580: LD_EXP 69
9584: PPUSH
9585: LD_VAR 0 1
9589: PPUSH
9590: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9594: LD_VAR 0 1
9598: PPUSH
9599: LD_INT 111
9601: PPUSH
9602: LD_INT 197
9604: PPUSH
9605: CALL_OW 111
// wait ( 0 0$2 ) ;
9609: LD_INT 70
9611: PPUSH
9612: CALL_OW 67
// end ;
9616: GO 9517
9618: POP
9619: POP
// repeat wait ( 0 0$1 ) ;
9620: LD_INT 35
9622: PPUSH
9623: CALL_OW 67
// for i in tmp do
9627: LD_ADDR_VAR 0 1
9631: PUSH
9632: LD_VAR 0 2
9636: PUSH
9637: FOR_IN
9638: IFFALSE 9919
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9640: LD_INT 81
9642: PUSH
9643: LD_INT 6
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 91
9652: PUSH
9653: LD_VAR 0 1
9657: PUSH
9658: LD_INT 12
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: LIST
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PPUSH
9670: CALL_OW 69
9674: IFFALSE 9732
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9676: LD_VAR 0 1
9680: PPUSH
9681: LD_INT 81
9683: PUSH
9684: LD_INT 6
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PUSH
9691: LD_INT 91
9693: PUSH
9694: LD_VAR 0 1
9698: PUSH
9699: LD_INT 12
9701: PUSH
9702: EMPTY
9703: LIST
9704: LIST
9705: LIST
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PPUSH
9711: CALL_OW 69
9715: PPUSH
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 74
9725: PPUSH
9726: CALL_OW 115
9730: GO 9917
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9732: LD_INT 9
9734: PPUSH
9735: LD_INT 81
9737: PUSH
9738: LD_INT 6
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: PPUSH
9745: CALL_OW 70
9749: IFFALSE 9883
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9751: LD_VAR 0 1
9755: PPUSH
9756: LD_VAR 0 6
9760: PUSH
9761: LD_INT 1
9763: ARRAY
9764: PUSH
9765: LD_INT 1
9767: ARRAY
9768: PPUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 1
9776: ARRAY
9777: PUSH
9778: LD_INT 2
9780: ARRAY
9781: PPUSH
9782: CALL_OW 297
9786: PUSH
9787: LD_INT 10
9789: GREATER
9790: PUSH
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_INT 9
9798: PPUSH
9799: CALL_OW 308
9803: NOT
9804: AND
9805: IFFALSE 9844
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9807: LD_VAR 0 1
9811: PPUSH
9812: LD_VAR 0 6
9816: PUSH
9817: LD_INT 1
9819: ARRAY
9820: PUSH
9821: LD_INT 1
9823: ARRAY
9824: PPUSH
9825: LD_VAR 0 6
9829: PUSH
9830: LD_INT 1
9832: ARRAY
9833: PUSH
9834: LD_INT 2
9836: ARRAY
9837: PPUSH
9838: CALL_OW 114
9842: GO 9881
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9844: LD_VAR 0 1
9848: PPUSH
9849: LD_INT 9
9851: PPUSH
9852: LD_INT 81
9854: PUSH
9855: LD_INT 6
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: PPUSH
9862: CALL_OW 70
9866: PPUSH
9867: LD_VAR 0 1
9871: PPUSH
9872: CALL_OW 74
9876: PPUSH
9877: CALL_OW 115
// end else
9881: GO 9917
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9883: LD_VAR 0 1
9887: PPUSH
9888: LD_INT 81
9890: PUSH
9891: LD_INT 6
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PPUSH
9898: CALL_OW 69
9902: PPUSH
9903: LD_VAR 0 1
9907: PPUSH
9908: CALL_OW 74
9912: PPUSH
9913: CALL_OW 115
// end ;
9917: GO 9637
9919: POP
9920: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9921: LD_INT 22
9923: PUSH
9924: LD_INT 6
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: PPUSH
9931: CALL_OW 69
9935: NOT
9936: IFFALSE 9620
// end ; until russianDestroyed ;
9938: LD_EXP 21
9942: IFFALSE 9268
// end ;
9944: PPOPN 6
9946: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9947: LD_EXP 21
9951: NOT
9952: PUSH
9953: LD_EXP 15
9957: PUSH
9958: LD_INT 6
9960: GREATEREQUAL
9961: AND
9962: PUSH
9963: LD_INT 2
9965: PPUSH
9966: LD_INT 1
9968: PPUSH
9969: CALL 59347 0 2
9973: NOT
9974: AND
9975: IFFALSE 10931
9977: GO 9979
9979: DISABLE
9980: LD_INT 0
9982: PPUSH
9983: PPUSH
9984: PPUSH
9985: PPUSH
// begin enable ;
9986: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9987: LD_INT 22
9989: PUSH
9990: LD_INT 3
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PUSH
9997: LD_INT 30
9999: PUSH
10000: LD_INT 3
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PPUSH
10011: CALL_OW 69
10015: NOT
10016: IFFALSE 10020
// exit ;
10018: GO 10931
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10020: LD_ADDR_VAR 0 4
10024: PUSH
10025: LD_INT 22
10027: PUSH
10028: LD_INT 3
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 30
10037: PUSH
10038: LD_INT 34
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: PPUSH
10049: CALL_OW 69
10053: ST_TO_ADDR
// if Prob ( 40 ) then
10054: LD_INT 40
10056: PPUSH
10057: CALL_OW 13
10061: IFFALSE 10188
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10063: LD_INT 2
10065: PPUSH
10066: LD_INT 22
10068: PUSH
10069: LD_INT 3
10071: PUSH
10072: LD_INT 3
10074: PUSH
10075: LD_INT 49
10077: PUSH
10078: EMPTY
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 22
10086: PUSH
10087: LD_INT 3
10089: PUSH
10090: LD_INT 3
10092: PUSH
10093: LD_INT 49
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: PUSH
10102: LD_INT 22
10104: PUSH
10105: LD_INT 3
10107: PUSH
10108: LD_INT 3
10110: PUSH
10111: LD_INT 49
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 24
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: LD_INT 3
10128: PUSH
10129: LD_INT 46
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 46
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 46
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: PPUSH
10182: CALL 57929 0 2
// end else
10186: GO 10311
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10188: LD_INT 2
10190: PPUSH
10191: LD_INT 24
10193: PUSH
10194: LD_INT 3
10196: PUSH
10197: LD_INT 3
10199: PUSH
10200: LD_INT 47
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: PUSH
10209: LD_INT 24
10211: PUSH
10212: LD_INT 3
10214: PUSH
10215: LD_INT 3
10217: PUSH
10218: LD_INT 47
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: PUSH
10227: LD_INT 24
10229: PUSH
10230: LD_INT 3
10232: PUSH
10233: LD_INT 3
10235: PUSH
10236: LD_INT 47
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 24
10247: PUSH
10248: LD_INT 3
10250: PUSH
10251: LD_INT 3
10253: PUSH
10254: LD_INT 46
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: PUSH
10263: LD_INT 24
10265: PUSH
10266: LD_INT 3
10268: PUSH
10269: LD_INT 3
10271: PUSH
10272: LD_INT 46
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: PUSH
10281: LD_INT 24
10283: PUSH
10284: LD_INT 3
10286: PUSH
10287: LD_INT 3
10289: PUSH
10290: LD_INT 46
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PPUSH
10307: CALL 57929 0 2
// end ; if Difficulty > 1 then
10311: LD_OWVAR 67
10315: PUSH
10316: LD_INT 1
10318: GREATER
10319: IFFALSE 10349
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10321: LD_INT 2
10323: PPUSH
10324: LD_INT 24
10326: PUSH
10327: LD_INT 3
10329: PUSH
10330: LD_INT 3
10332: PUSH
10333: LD_INT 47
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: EMPTY
10343: LIST
10344: PPUSH
10345: CALL 57929 0 2
// repeat wait ( 0 0$1 ) ;
10349: LD_INT 35
10351: PPUSH
10352: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10356: LD_INT 2
10358: PPUSH
10359: LD_INT 1
10361: PPUSH
10362: CALL 59347 0 2
10366: PUSH
10367: LD_INT 6
10369: PUSH
10370: LD_INT 7
10372: PUSH
10373: LD_INT 7
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: LIST
10380: PUSH
10381: LD_OWVAR 67
10385: ARRAY
10386: GREATEREQUAL
10387: IFFALSE 10349
// wait ( 0 0$30 ) ;
10389: LD_INT 1050
10391: PPUSH
10392: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10396: LD_ADDR_VAR 0 2
10400: PUSH
10401: LD_INT 2
10403: PPUSH
10404: LD_INT 1
10406: PPUSH
10407: CALL 59347 0 2
10411: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10412: LD_ADDR_EXP 120
10416: PUSH
10417: LD_EXP 120
10421: PPUSH
10422: LD_INT 2
10424: PPUSH
10425: LD_EXP 120
10429: PUSH
10430: LD_INT 2
10432: ARRAY
10433: PUSH
10434: LD_VAR 0 2
10438: DIFF
10439: PPUSH
10440: CALL_OW 1
10444: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10445: LD_ADDR_VAR 0 3
10449: PUSH
10450: LD_INT 0
10452: PPUSH
10453: LD_INT 1
10455: PPUSH
10456: CALL_OW 12
10460: ST_TO_ADDR
// if target then
10461: LD_VAR 0 3
10465: IFFALSE 10593
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10467: LD_ADDR_VAR 0 2
10471: PUSH
10472: LD_VAR 0 2
10476: PPUSH
10477: LD_INT 24
10479: PUSH
10480: LD_INT 250
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: PPUSH
10487: CALL_OW 72
10491: ST_TO_ADDR
// for i in tmp do
10492: LD_ADDR_VAR 0 1
10496: PUSH
10497: LD_VAR 0 2
10501: PUSH
10502: FOR_IN
10503: IFFALSE 10543
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10505: LD_VAR 0 1
10509: PPUSH
10510: LD_INT 139
10512: PPUSH
10513: LD_INT 89
10515: PPUSH
10516: CALL_OW 297
10520: PUSH
10521: LD_INT 9
10523: GREATER
10524: IFFALSE 10541
// ComMoveXY ( i , 139 , 89 ) ;
10526: LD_VAR 0 1
10530: PPUSH
10531: LD_INT 139
10533: PPUSH
10534: LD_INT 89
10536: PPUSH
10537: CALL_OW 111
10541: GO 10502
10543: POP
10544: POP
// wait ( 0 0$1 ) ;
10545: LD_INT 35
10547: PPUSH
10548: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10552: LD_VAR 0 2
10556: PPUSH
10557: LD_INT 92
10559: PUSH
10560: LD_INT 139
10562: PUSH
10563: LD_INT 89
10565: PUSH
10566: LD_INT 9
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: PPUSH
10575: CALL_OW 72
10579: PUSH
10580: LD_VAR 0 2
10584: PUSH
10585: LD_INT 1
10587: MINUS
10588: GREATEREQUAL
10589: IFFALSE 10467
// end else
10591: GO 10735
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10593: LD_VAR 0 2
10597: PPUSH
10598: LD_VAR 0 4
10602: PUSH
10603: LD_INT 1
10605: ARRAY
10606: PPUSH
10607: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10611: LD_ADDR_VAR 0 2
10615: PUSH
10616: LD_VAR 0 2
10620: PPUSH
10621: LD_INT 24
10623: PUSH
10624: LD_INT 250
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PPUSH
10631: CALL_OW 72
10635: ST_TO_ADDR
// for i in tmp do
10636: LD_ADDR_VAR 0 1
10640: PUSH
10641: LD_VAR 0 2
10645: PUSH
10646: FOR_IN
10647: IFFALSE 10687
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 124
10656: PPUSH
10657: LD_INT 139
10659: PPUSH
10660: CALL_OW 297
10664: PUSH
10665: LD_INT 9
10667: GREATER
10668: IFFALSE 10685
// ComMoveXY ( i , 124 , 139 ) ;
10670: LD_VAR 0 1
10674: PPUSH
10675: LD_INT 124
10677: PPUSH
10678: LD_INT 139
10680: PPUSH
10681: CALL_OW 111
10685: GO 10646
10687: POP
10688: POP
// wait ( 0 0$1 ) ;
10689: LD_INT 35
10691: PPUSH
10692: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10696: LD_VAR 0 2
10700: PPUSH
10701: LD_INT 92
10703: PUSH
10704: LD_INT 124
10706: PUSH
10707: LD_INT 139
10709: PUSH
10710: LD_INT 9
10712: PUSH
10713: EMPTY
10714: LIST
10715: LIST
10716: LIST
10717: LIST
10718: PPUSH
10719: CALL_OW 72
10723: PUSH
10724: LD_VAR 0 2
10728: PUSH
10729: LD_INT 1
10731: MINUS
10732: GREATEREQUAL
10733: IFFALSE 10611
// end ; repeat wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// for i in tmp do
10742: LD_ADDR_VAR 0 1
10746: PUSH
10747: LD_VAR 0 2
10751: PUSH
10752: FOR_IN
10753: IFFALSE 10922
// begin if GetLives ( i ) > 251 then
10755: LD_VAR 0 1
10759: PPUSH
10760: CALL_OW 256
10764: PUSH
10765: LD_INT 251
10767: GREATER
10768: IFFALSE 10893
// begin if GetWeapon ( i ) = ru_time_lapser then
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL_OW 264
10779: PUSH
10780: LD_INT 49
10782: EQUAL
10783: IFFALSE 10839
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_INT 2
10792: PUSH
10793: LD_INT 22
10795: PUSH
10796: LD_INT 1
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PUSH
10803: LD_INT 22
10805: PUSH
10806: LD_INT 8
10808: PUSH
10809: EMPTY
10810: LIST
10811: LIST
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 69
10822: PPUSH
10823: LD_VAR 0 1
10827: PPUSH
10828: CALL_OW 74
10832: PPUSH
10833: CALL_OW 112
10837: GO 10891
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10839: LD_VAR 0 1
10843: PPUSH
10844: LD_INT 2
10846: PUSH
10847: LD_INT 22
10849: PUSH
10850: LD_INT 1
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PUSH
10857: LD_INT 22
10859: PUSH
10860: LD_INT 8
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: LIST
10871: PPUSH
10872: CALL_OW 69
10876: PPUSH
10877: LD_VAR 0 1
10881: PPUSH
10882: CALL_OW 74
10886: PPUSH
10887: CALL_OW 115
// end else
10891: GO 10920
// if IsDead ( i ) then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 301
10902: IFFALSE 10920
// tmp := tmp diff i ;
10904: LD_ADDR_VAR 0 2
10908: PUSH
10909: LD_VAR 0 2
10913: PUSH
10914: LD_VAR 0 1
10918: DIFF
10919: ST_TO_ADDR
// end ;
10920: GO 10752
10922: POP
10923: POP
// until not tmp ;
10924: LD_VAR 0 2
10928: NOT
10929: IFFALSE 10735
// end ; end_of_file
10931: PPOPN 4
10933: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10934: LD_INT 0
10936: PPUSH
10937: PPUSH
10938: PPUSH
10939: PPUSH
10940: PPUSH
10941: PPUSH
// side := 7 ;
10942: LD_ADDR_VAR 0 5
10946: PUSH
10947: LD_INT 7
10949: ST_TO_ADDR
// uc_side := side ;
10950: LD_ADDR_OWVAR 20
10954: PUSH
10955: LD_VAR 0 5
10959: ST_TO_ADDR
// uc_nation := 1 ;
10960: LD_ADDR_OWVAR 21
10964: PUSH
10965: LD_INT 1
10967: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10968: LD_ADDR_VAR 0 2
10972: PUSH
10973: LD_INT 22
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 21
10987: PUSH
10988: LD_INT 3
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: PPUSH
10999: CALL_OW 69
11003: PUSH
11004: FOR_IN
11005: IFFALSE 11021
// SetBLevel ( i , 10 ) ;
11007: LD_VAR 0 2
11011: PPUSH
11012: LD_INT 10
11014: PPUSH
11015: CALL_OW 241
11019: GO 11004
11021: POP
11022: POP
// base := GetBase ( al_depot ) ;
11023: LD_ADDR_VAR 0 4
11027: PUSH
11028: LD_INT 2
11030: PPUSH
11031: CALL_OW 274
11035: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11036: LD_ADDR_VAR 0 6
11040: PUSH
11041: LD_INT 22
11043: PUSH
11044: LD_VAR 0 5
11048: PUSH
11049: EMPTY
11050: LIST
11051: LIST
11052: PUSH
11053: LD_INT 30
11055: PUSH
11056: LD_INT 34
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PPUSH
11067: CALL_OW 69
11071: ST_TO_ADDR
// if teleport then
11072: LD_VAR 0 6
11076: IFFALSE 11097
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11078: LD_VAR 0 6
11082: PUSH
11083: LD_INT 1
11085: ARRAY
11086: PPUSH
11087: LD_INT 262
11089: PPUSH
11090: LD_INT 119
11092: PPUSH
11093: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11097: LD_VAR 0 4
11101: PPUSH
11102: LD_INT 1
11104: PPUSH
11105: LD_INT 19500
11107: PPUSH
11108: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11112: LD_VAR 0 4
11116: PPUSH
11117: LD_INT 2
11119: PPUSH
11120: LD_INT 200
11122: PPUSH
11123: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11127: LD_VAR 0 4
11131: PPUSH
11132: LD_INT 3
11134: PPUSH
11135: LD_INT 650
11137: PPUSH
11138: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11142: LD_ADDR_EXP 73
11146: PUSH
11147: LD_STRING Roth
11149: PPUSH
11150: CALL_OW 25
11154: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11155: LD_ADDR_EXP 74
11159: PUSH
11160: LD_STRING Simms
11162: PPUSH
11163: LD_EXP 1
11167: NOT
11168: PPUSH
11169: LD_STRING 10c_
11171: PPUSH
11172: CALL 64273 0 3
11176: ST_TO_ADDR
// if not Simms then
11177: LD_EXP 74
11181: NOT
11182: IFFALSE 11212
// begin uc_nation := 1 ;
11184: LD_ADDR_OWVAR 21
11188: PUSH
11189: LD_INT 1
11191: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11192: LD_INT 2
11194: PPUSH
11195: LD_INT 10
11197: PPUSH
11198: CALL_OW 384
// Simms := CreateHuman ;
11202: LD_ADDR_EXP 74
11206: PUSH
11207: CALL_OW 44
11211: ST_TO_ADDR
// end ; uc_nation := 3 ;
11212: LD_ADDR_OWVAR 21
11216: PUSH
11217: LD_INT 3
11219: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11220: LD_ADDR_EXP 75
11224: PUSH
11225: LD_STRING Kirilenkova
11227: PPUSH
11228: CALL_OW 25
11232: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11233: LD_ADDR_EXP 89
11237: PUSH
11238: LD_STRING Oblukov
11240: PPUSH
11241: CALL_OW 25
11245: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11246: LD_ADDR_EXP 76
11250: PUSH
11251: LD_STRING Dolgov
11253: PPUSH
11254: CALL_OW 25
11258: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11259: LD_ADDR_EXP 77
11263: PUSH
11264: LD_STRING Petrosyan
11266: PPUSH
11267: CALL_OW 25
11271: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11272: LD_ADDR_EXP 88
11276: PUSH
11277: LD_STRING Scholtze
11279: PPUSH
11280: CALL_OW 25
11284: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11285: LD_ADDR_EXP 87
11289: PUSH
11290: LD_STRING Kapitsova
11292: PPUSH
11293: CALL_OW 25
11297: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11298: LD_ADDR_EXP 78
11302: PUSH
11303: LD_STRING Petrovova
11305: PPUSH
11306: CALL_OW 25
11310: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11311: LD_ADDR_EXP 79
11315: PUSH
11316: LD_STRING Kuzmov
11318: PPUSH
11319: CALL_OW 25
11323: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11324: LD_ADDR_EXP 86
11328: PUSH
11329: LD_STRING Karamazov
11331: PPUSH
11332: CALL_OW 25
11336: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11337: LD_STRING 13_Lipshchin_1
11339: PPUSH
11340: LD_INT 0
11342: PPUSH
11343: CALL_OW 30
11347: IFFALSE 11362
// Lipshchin := NewCharacter ( Lipshchin ) ;
11349: LD_ADDR_EXP 80
11353: PUSH
11354: LD_STRING Lipshchin
11356: PPUSH
11357: CALL_OW 25
11361: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11362: LD_STRING 13_Titov_1
11364: PPUSH
11365: LD_INT 0
11367: PPUSH
11368: CALL_OW 30
11372: IFFALSE 11387
// Titov := NewCharacter ( Titov ) ;
11374: LD_ADDR_EXP 82
11378: PUSH
11379: LD_STRING Titov
11381: PPUSH
11382: CALL_OW 25
11386: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11387: LD_STRING 13_Gnyevko_1
11389: PPUSH
11390: LD_INT 0
11392: PPUSH
11393: CALL_OW 30
11397: IFFALSE 11412
// Gnyevko := NewCharacter ( Gnyevko ) ;
11399: LD_ADDR_EXP 81
11403: PUSH
11404: LD_STRING Gnyevko
11406: PPUSH
11407: CALL_OW 25
11411: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11412: LD_STRING 13_Xavier_1
11414: PPUSH
11415: LD_INT 0
11417: PPUSH
11418: CALL_OW 30
11422: IFFALSE 11437
// Xavier := NewCharacter ( Xavier2 ) ;
11424: LD_ADDR_EXP 83
11428: PUSH
11429: LD_STRING Xavier2
11431: PPUSH
11432: CALL_OW 25
11436: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11437: LD_STRING 13_Belkov_1
11439: PPUSH
11440: LD_INT 0
11442: PPUSH
11443: CALL_OW 30
11447: IFFALSE 11462
// Belkov := NewCharacter ( Belkov ) ;
11449: LD_ADDR_EXP 84
11453: PUSH
11454: LD_STRING Belkov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// if not BurlakStatus then
11462: LD_EXP 9
11466: NOT
11467: IFFALSE 11482
// Burlak = NewCharacter ( Burlak ) ;
11469: LD_ADDR_EXP 85
11473: PUSH
11474: LD_STRING Burlak
11476: PPUSH
11477: CALL_OW 25
11481: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11482: LD_ADDR_VAR 0 3
11486: PUSH
11487: LD_EXP 73
11491: PUSH
11492: LD_EXP 75
11496: PUSH
11497: LD_EXP 89
11501: PUSH
11502: LD_EXP 76
11506: PUSH
11507: LD_EXP 77
11511: PUSH
11512: LD_EXP 88
11516: PUSH
11517: LD_EXP 87
11521: PUSH
11522: LD_EXP 78
11526: PUSH
11527: LD_EXP 79
11531: PUSH
11532: LD_EXP 86
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: ST_TO_ADDR
// if Simms then
11549: LD_EXP 74
11553: IFFALSE 11571
// tmp := tmp ^ Simms ;
11555: LD_ADDR_VAR 0 3
11559: PUSH
11560: LD_VAR 0 3
11564: PUSH
11565: LD_EXP 74
11569: ADD
11570: ST_TO_ADDR
// if Titov then
11571: LD_EXP 82
11575: IFFALSE 11593
// tmp := tmp ^ Titov ;
11577: LD_ADDR_VAR 0 3
11581: PUSH
11582: LD_VAR 0 3
11586: PUSH
11587: LD_EXP 82
11591: ADD
11592: ST_TO_ADDR
// if Lipshchin then
11593: LD_EXP 80
11597: IFFALSE 11615
// tmp := tmp ^ Lipshchin ;
11599: LD_ADDR_VAR 0 3
11603: PUSH
11604: LD_VAR 0 3
11608: PUSH
11609: LD_EXP 80
11613: ADD
11614: ST_TO_ADDR
// if Gnyevko then
11615: LD_EXP 81
11619: IFFALSE 11637
// tmp := tmp ^ Gnyevko ;
11621: LD_ADDR_VAR 0 3
11625: PUSH
11626: LD_VAR 0 3
11630: PUSH
11631: LD_EXP 81
11635: ADD
11636: ST_TO_ADDR
// if Xavier then
11637: LD_EXP 83
11641: IFFALSE 11659
// tmp := tmp ^ Xavier ;
11643: LD_ADDR_VAR 0 3
11647: PUSH
11648: LD_VAR 0 3
11652: PUSH
11653: LD_EXP 83
11657: ADD
11658: ST_TO_ADDR
// if Belkov then
11659: LD_EXP 84
11663: IFFALSE 11681
// tmp := tmp ^ Belkov ;
11665: LD_ADDR_VAR 0 3
11669: PUSH
11670: LD_VAR 0 3
11674: PUSH
11675: LD_EXP 84
11679: ADD
11680: ST_TO_ADDR
// if Burlak then
11681: LD_EXP 85
11685: IFFALSE 11703
// tmp := tmp ^ Burlak ;
11687: LD_ADDR_VAR 0 3
11691: PUSH
11692: LD_VAR 0 3
11696: PUSH
11697: LD_EXP 85
11701: ADD
11702: ST_TO_ADDR
// for i = 1 to 8 do
11703: LD_ADDR_VAR 0 2
11707: PUSH
11708: DOUBLE
11709: LD_INT 1
11711: DEC
11712: ST_TO_ADDR
11713: LD_INT 8
11715: PUSH
11716: FOR_TO
11717: IFFALSE 11783
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11719: LD_ADDR_OWVAR 21
11723: PUSH
11724: LD_INT 1
11726: PUSH
11727: LD_INT 3
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 1
11736: PPUSH
11737: LD_INT 2
11739: PPUSH
11740: CALL_OW 12
11744: ARRAY
11745: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11746: LD_INT 0
11748: PPUSH
11749: LD_VAR 0 2
11753: PUSH
11754: LD_INT 2
11756: DIV
11757: PPUSH
11758: LD_INT 10
11760: PPUSH
11761: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11765: LD_ADDR_VAR 0 3
11769: PUSH
11770: LD_VAR 0 3
11774: PUSH
11775: CALL_OW 44
11779: ADD
11780: ST_TO_ADDR
// end ;
11781: GO 11716
11783: POP
11784: POP
// for i in tmp do
11785: LD_ADDR_VAR 0 2
11789: PUSH
11790: LD_VAR 0 3
11794: PUSH
11795: FOR_IN
11796: IFFALSE 11821
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11798: LD_VAR 0 2
11802: PPUSH
11803: LD_INT 260
11805: PPUSH
11806: LD_INT 235
11808: PPUSH
11809: LD_INT 8
11811: PPUSH
11812: LD_INT 0
11814: PPUSH
11815: CALL_OW 50
11819: GO 11795
11821: POP
11822: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11823: LD_ADDR_EXP 101
11827: PUSH
11828: LD_EXP 101
11832: PPUSH
11833: LD_INT 1
11835: PPUSH
11836: LD_INT 22
11838: PUSH
11839: LD_VAR 0 5
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: LD_INT 21
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: EMPTY
11858: LIST
11859: LIST
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: PPUSH
11869: CALL_OW 69
11873: PUSH
11874: LD_EXP 73
11878: PUSH
11879: LD_EXP 74
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: DIFF
11888: PPUSH
11889: CALL_OW 1
11893: ST_TO_ADDR
// uc_side := 0 ;
11894: LD_ADDR_OWVAR 20
11898: PUSH
11899: LD_INT 0
11901: ST_TO_ADDR
// uc_nation := 0 ;
11902: LD_ADDR_OWVAR 21
11906: PUSH
11907: LD_INT 0
11909: ST_TO_ADDR
// for i = 1 to 5 do
11910: LD_ADDR_VAR 0 2
11914: PUSH
11915: DOUBLE
11916: LD_INT 1
11918: DEC
11919: ST_TO_ADDR
11920: LD_INT 5
11922: PUSH
11923: FOR_TO
11924: IFFALSE 11961
// begin InitHc ;
11926: CALL_OW 19
// hc_class := class_apeman ;
11930: LD_ADDR_OWVAR 28
11934: PUSH
11935: LD_INT 12
11937: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11938: CALL_OW 44
11942: PPUSH
11943: LD_INT 299
11945: PPUSH
11946: LD_INT 229
11948: PPUSH
11949: LD_INT 10
11951: PPUSH
11952: LD_INT 0
11954: PPUSH
11955: CALL_OW 50
// end ;
11959: GO 11923
11961: POP
11962: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11963: LD_EXP 73
11967: PPUSH
11968: LD_INT 259
11970: PPUSH
11971: LD_INT 235
11973: PPUSH
11974: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11978: LD_EXP 73
11982: PPUSH
11983: LD_INT 262
11985: PPUSH
11986: LD_INT 235
11988: PPUSH
11989: CALL_OW 178
// if Simms then
11993: LD_EXP 74
11997: IFFALSE 12028
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11999: LD_EXP 74
12003: PPUSH
12004: LD_INT 262
12006: PPUSH
12007: LD_INT 235
12009: PPUSH
12010: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12014: LD_EXP 74
12018: PPUSH
12019: LD_EXP 73
12023: PPUSH
12024: CALL_OW 179
// end ; end ;
12028: LD_VAR 0 1
12032: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12033: LD_EXP 31
12037: PUSH
12038: LD_EXP 23
12042: NOT
12043: AND
12044: IFFALSE 12220
12046: GO 12048
12048: DISABLE
12049: LD_INT 0
12051: PPUSH
12052: PPUSH
12053: PPUSH
// begin enable ;
12054: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12055: LD_ADDR_VAR 0 2
12059: PUSH
12060: LD_INT 81
12062: PUSH
12063: LD_INT 7
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 2
12072: PUSH
12073: LD_INT 32
12075: PUSH
12076: LD_INT 3
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 30
12085: PUSH
12086: LD_INT 30
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 30
12095: PUSH
12096: LD_INT 28
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 34
12105: PUSH
12106: LD_INT 49
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 34
12115: PUSH
12116: LD_INT 10
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 34
12125: PUSH
12126: LD_INT 8
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: LIST
12139: LIST
12140: LIST
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: PPUSH
12146: CALL_OW 69
12150: ST_TO_ADDR
// if not tmp then
12151: LD_VAR 0 2
12155: NOT
12156: IFFALSE 12160
// exit ;
12158: GO 12220
// target := tmp [ rand ( 1 , tmp ) ] ;
12160: LD_ADDR_VAR 0 3
12164: PUSH
12165: LD_VAR 0 2
12169: PUSH
12170: LD_INT 1
12172: PPUSH
12173: LD_VAR 0 2
12177: PPUSH
12178: CALL_OW 12
12182: ARRAY
12183: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12184: LD_VAR 0 3
12188: PPUSH
12189: CALL_OW 255
12193: PUSH
12194: LD_INT 1
12196: EQUAL
12197: IFFALSE 12208
// CenterNowOnUnits ( target ) ;
12199: LD_VAR 0 3
12203: PPUSH
12204: CALL_OW 87
// SetLives ( target , 0 ) ;
12208: LD_VAR 0 3
12212: PPUSH
12213: LD_INT 0
12215: PPUSH
12216: CALL_OW 234
// end ;
12220: PPOPN 3
12222: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12223: LD_EXP 23
12227: NOT
12228: PUSH
12229: LD_EXP 31
12233: AND
12234: IFFALSE 12756
12236: GO 12238
12238: DISABLE
12239: LD_INT 0
12241: PPUSH
12242: PPUSH
12243: PPUSH
// begin uc_side := 7 ;
12244: LD_ADDR_OWVAR 20
12248: PUSH
12249: LD_INT 7
12251: ST_TO_ADDR
// uc_nation := 1 ;
12252: LD_ADDR_OWVAR 21
12256: PUSH
12257: LD_INT 1
12259: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12260: LD_ADDR_VAR 0 3
12264: PUSH
12265: LD_INT 125
12267: PUSH
12268: LD_INT 163
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 185
12277: PUSH
12278: LD_INT 168
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 111
12287: PUSH
12288: LD_INT 97
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: LIST
12299: PPUSH
12300: CALL 107228 0 1
12304: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12305: LD_ADDR_EXP 90
12309: PUSH
12310: EMPTY
12311: ST_TO_ADDR
// for i = 1 to Difficulty do
12312: LD_ADDR_VAR 0 1
12316: PUSH
12317: DOUBLE
12318: LD_INT 1
12320: DEC
12321: ST_TO_ADDR
12322: LD_OWVAR 67
12326: PUSH
12327: FOR_TO
12328: IFFALSE 12486
// begin InitHc ;
12330: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12334: LD_INT 0
12336: PPUSH
12337: LD_INT 8
12339: PPUSH
12340: CALL_OW 381
// un := CreateHuman ;
12344: LD_ADDR_VAR 0 2
12348: PUSH
12349: CALL_OW 44
12353: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12354: LD_VAR 0 2
12358: PPUSH
12359: LD_INT 258
12361: PPUSH
12362: LD_INT 267
12364: PPUSH
12365: LD_INT 4
12367: PPUSH
12368: LD_INT 0
12370: PPUSH
12371: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12375: LD_ADDR_EXP 90
12379: PUSH
12380: LD_EXP 90
12384: PUSH
12385: LD_VAR 0 2
12389: UNION
12390: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12391: LD_VAR 0 2
12395: PPUSH
12396: LD_VAR 0 3
12400: PUSH
12401: LD_VAR 0 1
12405: ARRAY
12406: PUSH
12407: LD_INT 1
12409: ARRAY
12410: PPUSH
12411: LD_VAR 0 3
12415: PUSH
12416: LD_VAR 0 1
12420: ARRAY
12421: PUSH
12422: LD_INT 2
12424: ARRAY
12425: PPUSH
12426: LD_INT 4
12428: PPUSH
12429: LD_INT 1
12431: PPUSH
12432: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12436: LD_VAR 0 2
12440: PPUSH
12441: LD_VAR 0 3
12445: PUSH
12446: LD_VAR 0 1
12450: ARRAY
12451: PUSH
12452: LD_INT 1
12454: ARRAY
12455: PPUSH
12456: LD_VAR 0 3
12460: PUSH
12461: LD_VAR 0 1
12465: ARRAY
12466: PUSH
12467: LD_INT 2
12469: ARRAY
12470: PPUSH
12471: CALL_OW 171
// AddComInvisible ( un ) ;
12475: LD_VAR 0 2
12479: PPUSH
12480: CALL_OW 212
// end ;
12484: GO 12327
12486: POP
12487: POP
// repeat wait ( 0 0$20 ) ;
12488: LD_INT 700
12490: PPUSH
12491: CALL_OW 67
// for i in allianceSpecialForce do
12495: LD_ADDR_VAR 0 1
12499: PUSH
12500: LD_EXP 90
12504: PUSH
12505: FOR_IN
12506: IFFALSE 12741
// begin if IsInvisible ( i ) then
12508: LD_VAR 0 1
12512: PPUSH
12513: CALL_OW 571
12517: IFFALSE 12710
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12519: LD_ADDR_VAR 0 3
12523: PUSH
12524: LD_INT 22
12526: PUSH
12527: LD_INT 1
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: PUSH
12534: LD_INT 50
12536: PUSH
12537: EMPTY
12538: LIST
12539: PUSH
12540: LD_INT 56
12542: PUSH
12543: EMPTY
12544: LIST
12545: PUSH
12546: LD_INT 91
12548: PUSH
12549: LD_VAR 0 1
12553: PUSH
12554: LD_INT 25
12556: PUSH
12557: LD_INT 30
12559: PUSH
12560: LD_INT 35
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: LIST
12567: PUSH
12568: LD_OWVAR 67
12572: ARRAY
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 2
12581: PUSH
12582: LD_INT 25
12584: PUSH
12585: LD_INT 1
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 25
12594: PUSH
12595: LD_INT 2
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 25
12604: PUSH
12605: LD_INT 3
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: LD_INT 25
12614: PUSH
12615: LD_INT 4
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 25
12624: PUSH
12625: LD_INT 5
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 25
12634: PUSH
12635: LD_INT 8
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: LIST
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: PUSH
12651: EMPTY
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: PPUSH
12658: CALL_OW 69
12662: ST_TO_ADDR
// if not tmp then
12663: LD_VAR 0 3
12667: NOT
12668: IFFALSE 12672
// continue ;
12670: GO 12505
// if Prob ( 30 * Difficulty ) then
12672: LD_INT 30
12674: PUSH
12675: LD_OWVAR 67
12679: MUL
12680: PPUSH
12681: CALL_OW 13
12685: IFFALSE 12710
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12687: LD_VAR 0 3
12691: PUSH
12692: LD_INT 1
12694: PPUSH
12695: LD_VAR 0 3
12699: PPUSH
12700: CALL_OW 12
12704: ARRAY
12705: PPUSH
12706: CALL 30379 0 1
// end ; if IsDead ( i ) then
12710: LD_VAR 0 1
12714: PPUSH
12715: CALL_OW 301
12719: IFFALSE 12739
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12721: LD_ADDR_EXP 90
12725: PUSH
12726: LD_EXP 90
12730: PUSH
12731: LD_VAR 0 1
12735: DIFF
12736: ST_TO_ADDR
// continue ;
12737: GO 12505
// end ; end ;
12739: GO 12505
12741: POP
12742: POP
// until allianceDestroyed or not allianceSpecialForce ;
12743: LD_EXP 23
12747: PUSH
12748: LD_EXP 90
12752: NOT
12753: OR
12754: IFFALSE 12488
// end ;
12756: PPOPN 3
12758: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12759: LD_EXP 23
12763: NOT
12764: PUSH
12765: LD_EXP 31
12769: AND
12770: IFFALSE 13737
12772: GO 12774
12774: DISABLE
12775: LD_INT 0
12777: PPUSH
12778: PPUSH
12779: PPUSH
12780: PPUSH
// begin enable ;
12781: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12782: LD_INT 22
12784: PUSH
12785: LD_INT 7
12787: PUSH
12788: EMPTY
12789: LIST
12790: LIST
12791: PUSH
12792: LD_INT 30
12794: PUSH
12795: LD_INT 3
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PPUSH
12806: CALL_OW 69
12810: NOT
12811: IFFALSE 12815
// exit ;
12813: GO 13737
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12815: LD_ADDR_VAR 0 4
12819: PUSH
12820: LD_INT 22
12822: PUSH
12823: LD_INT 7
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: PUSH
12830: LD_INT 30
12832: PUSH
12833: LD_INT 34
12835: PUSH
12836: EMPTY
12837: LIST
12838: LIST
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PPUSH
12844: CALL_OW 69
12848: ST_TO_ADDR
// if Prob ( 40 ) then
12849: LD_INT 40
12851: PPUSH
12852: CALL_OW 13
12856: IFFALSE 12983
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12858: LD_INT 1
12860: PPUSH
12861: LD_INT 5
12863: PUSH
12864: LD_INT 3
12866: PUSH
12867: LD_INT 2
12869: PUSH
12870: LD_INT 6
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: PUSH
12879: LD_INT 5
12881: PUSH
12882: LD_INT 3
12884: PUSH
12885: LD_INT 2
12887: PUSH
12888: LD_INT 6
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: PUSH
12897: LD_INT 5
12899: PUSH
12900: LD_INT 3
12902: PUSH
12903: LD_INT 2
12905: PUSH
12906: LD_INT 6
12908: PUSH
12909: EMPTY
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: PUSH
12915: LD_INT 24
12917: PUSH
12918: LD_INT 3
12920: PUSH
12921: LD_INT 3
12923: PUSH
12924: LD_INT 45
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: LIST
12931: LIST
12932: PUSH
12933: LD_INT 24
12935: PUSH
12936: LD_INT 3
12938: PUSH
12939: LD_INT 3
12941: PUSH
12942: LD_INT 47
12944: PUSH
12945: EMPTY
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 24
12953: PUSH
12954: LD_INT 3
12956: PUSH
12957: LD_INT 3
12959: PUSH
12960: LD_INT 45
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: PUSH
12969: EMPTY
12970: LIST
12971: LIST
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL 57929 0 2
// end else
12981: GO 13106
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12983: LD_INT 1
12985: PPUSH
12986: LD_INT 24
12988: PUSH
12989: LD_INT 3
12991: PUSH
12992: LD_INT 3
12994: PUSH
12995: LD_INT 47
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: PUSH
13004: LD_INT 24
13006: PUSH
13007: LD_INT 3
13009: PUSH
13010: LD_INT 3
13012: PUSH
13013: LD_INT 47
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: PUSH
13022: LD_INT 5
13024: PUSH
13025: LD_INT 3
13027: PUSH
13028: LD_INT 2
13030: PUSH
13031: LD_INT 9
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 5
13042: PUSH
13043: LD_INT 3
13045: PUSH
13046: LD_INT 2
13048: PUSH
13049: LD_INT 9
13051: PUSH
13052: EMPTY
13053: LIST
13054: LIST
13055: LIST
13056: LIST
13057: PUSH
13058: LD_INT 24
13060: PUSH
13061: LD_INT 1
13063: PUSH
13064: LD_INT 3
13066: PUSH
13067: LD_INT 45
13069: PUSH
13070: EMPTY
13071: LIST
13072: LIST
13073: LIST
13074: LIST
13075: PUSH
13076: LD_INT 24
13078: PUSH
13079: LD_INT 1
13081: PUSH
13082: LD_INT 3
13084: PUSH
13085: LD_INT 45
13087: PUSH
13088: EMPTY
13089: LIST
13090: LIST
13091: LIST
13092: LIST
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: LIST
13100: LIST
13101: PPUSH
13102: CALL 57929 0 2
// end ; if Difficulty > 1 then
13106: LD_OWVAR 67
13110: PUSH
13111: LD_INT 1
13113: GREATER
13114: IFFALSE 13144
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13116: LD_INT 1
13118: PPUSH
13119: LD_INT 24
13121: PUSH
13122: LD_INT 3
13124: PUSH
13125: LD_INT 3
13127: PUSH
13128: LD_INT 47
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: PUSH
13137: EMPTY
13138: LIST
13139: PPUSH
13140: CALL 57929 0 2
// repeat wait ( 0 0$1 ) ;
13144: LD_INT 35
13146: PPUSH
13147: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13151: LD_INT 1
13153: PPUSH
13154: LD_INT 1
13156: PPUSH
13157: CALL 59347 0 2
13161: PUSH
13162: LD_INT 6
13164: PUSH
13165: LD_INT 7
13167: PUSH
13168: LD_INT 7
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: LIST
13175: PUSH
13176: LD_OWVAR 67
13180: ARRAY
13181: GREATEREQUAL
13182: IFFALSE 13144
// wait ( 0 0$40 ) ;
13184: LD_INT 1400
13186: PPUSH
13187: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13191: LD_ADDR_VAR 0 2
13195: PUSH
13196: LD_INT 1
13198: PPUSH
13199: LD_INT 1
13201: PPUSH
13202: CALL 59347 0 2
13206: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13207: LD_ADDR_EXP 120
13211: PUSH
13212: LD_EXP 120
13216: PPUSH
13217: LD_INT 1
13219: PPUSH
13220: LD_EXP 120
13224: PUSH
13225: LD_INT 1
13227: ARRAY
13228: PUSH
13229: LD_VAR 0 2
13233: DIFF
13234: PPUSH
13235: CALL_OW 1
13239: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13240: LD_ADDR_VAR 0 3
13244: PUSH
13245: LD_INT 0
13247: PPUSH
13248: LD_INT 1
13250: PPUSH
13251: CALL_OW 12
13255: ST_TO_ADDR
// if target then
13256: LD_VAR 0 3
13260: IFFALSE 13426
// begin for i in tmp do
13262: LD_ADDR_VAR 0 1
13266: PUSH
13267: LD_VAR 0 2
13271: PUSH
13272: FOR_IN
13273: IFFALSE 13298
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13275: LD_VAR 0 1
13279: PPUSH
13280: LD_INT 179
13282: PPUSH
13283: LD_INT 209
13285: PPUSH
13286: LD_INT 8
13288: PPUSH
13289: LD_INT 1
13291: PPUSH
13292: CALL_OW 483
13296: GO 13272
13298: POP
13299: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13300: LD_ADDR_VAR 0 2
13304: PUSH
13305: LD_VAR 0 2
13309: PPUSH
13310: LD_INT 24
13312: PUSH
13313: LD_INT 250
13315: PUSH
13316: EMPTY
13317: LIST
13318: LIST
13319: PPUSH
13320: CALL_OW 72
13324: ST_TO_ADDR
// for i in tmp do
13325: LD_ADDR_VAR 0 1
13329: PUSH
13330: LD_VAR 0 2
13334: PUSH
13335: FOR_IN
13336: IFFALSE 13376
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13338: LD_VAR 0 1
13342: PPUSH
13343: LD_INT 179
13345: PPUSH
13346: LD_INT 209
13348: PPUSH
13349: CALL_OW 297
13353: PUSH
13354: LD_INT 9
13356: GREATER
13357: IFFALSE 13374
// ComMoveXY ( i , 179 , 209 ) ;
13359: LD_VAR 0 1
13363: PPUSH
13364: LD_INT 179
13366: PPUSH
13367: LD_INT 209
13369: PPUSH
13370: CALL_OW 111
13374: GO 13335
13376: POP
13377: POP
// wait ( 0 0$1 ) ;
13378: LD_INT 35
13380: PPUSH
13381: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13385: LD_VAR 0 2
13389: PPUSH
13390: LD_INT 92
13392: PUSH
13393: LD_INT 179
13395: PUSH
13396: LD_INT 209
13398: PUSH
13399: LD_INT 9
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: LIST
13406: LIST
13407: PPUSH
13408: CALL_OW 72
13412: PUSH
13413: LD_VAR 0 2
13417: PUSH
13418: LD_INT 1
13420: MINUS
13421: GREATEREQUAL
13422: IFFALSE 13300
// end else
13424: GO 13588
// begin for i in tmp do
13426: LD_ADDR_VAR 0 1
13430: PUSH
13431: LD_VAR 0 2
13435: PUSH
13436: FOR_IN
13437: IFFALSE 13462
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13439: LD_VAR 0 1
13443: PPUSH
13444: LD_INT 285
13446: PPUSH
13447: LD_INT 163
13449: PPUSH
13450: LD_INT 8
13452: PPUSH
13453: LD_INT 1
13455: PPUSH
13456: CALL_OW 483
13460: GO 13436
13462: POP
13463: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13464: LD_ADDR_VAR 0 2
13468: PUSH
13469: LD_VAR 0 2
13473: PPUSH
13474: LD_INT 24
13476: PUSH
13477: LD_INT 250
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PPUSH
13484: CALL_OW 72
13488: ST_TO_ADDR
// for i in tmp do
13489: LD_ADDR_VAR 0 1
13493: PUSH
13494: LD_VAR 0 2
13498: PUSH
13499: FOR_IN
13500: IFFALSE 13540
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13502: LD_VAR 0 1
13506: PPUSH
13507: LD_INT 285
13509: PPUSH
13510: LD_INT 163
13512: PPUSH
13513: CALL_OW 297
13517: PUSH
13518: LD_INT 9
13520: GREATER
13521: IFFALSE 13538
// ComMoveXY ( i , 285 , 163 ) ;
13523: LD_VAR 0 1
13527: PPUSH
13528: LD_INT 285
13530: PPUSH
13531: LD_INT 163
13533: PPUSH
13534: CALL_OW 111
13538: GO 13499
13540: POP
13541: POP
// wait ( 0 0$1 ) ;
13542: LD_INT 35
13544: PPUSH
13545: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13549: LD_VAR 0 2
13553: PPUSH
13554: LD_INT 92
13556: PUSH
13557: LD_INT 285
13559: PUSH
13560: LD_INT 163
13562: PUSH
13563: LD_INT 9
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: LIST
13570: LIST
13571: PPUSH
13572: CALL_OW 72
13576: PUSH
13577: LD_VAR 0 2
13581: PUSH
13582: LD_INT 1
13584: MINUS
13585: GREATEREQUAL
13586: IFFALSE 13464
// end ; repeat wait ( 0 0$1 ) ;
13588: LD_INT 35
13590: PPUSH
13591: CALL_OW 67
// for i in tmp do
13595: LD_ADDR_VAR 0 1
13599: PUSH
13600: LD_VAR 0 2
13604: PUSH
13605: FOR_IN
13606: IFFALSE 13728
// if GetLives ( i ) > 251 then
13608: LD_VAR 0 1
13612: PPUSH
13613: CALL_OW 256
13617: PUSH
13618: LD_INT 251
13620: GREATER
13621: IFFALSE 13710
// begin if GetWeapon ( i ) = ru_time_lapser then
13623: LD_VAR 0 1
13627: PPUSH
13628: CALL_OW 264
13632: PUSH
13633: LD_INT 49
13635: EQUAL
13636: IFFALSE 13674
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13638: LD_VAR 0 1
13642: PPUSH
13643: LD_INT 81
13645: PUSH
13646: LD_INT 7
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: PPUSH
13653: CALL_OW 69
13657: PPUSH
13658: LD_VAR 0 1
13662: PPUSH
13663: CALL_OW 74
13667: PPUSH
13668: CALL_OW 112
13672: GO 13708
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13674: LD_VAR 0 1
13678: PPUSH
13679: LD_INT 81
13681: PUSH
13682: LD_INT 7
13684: PUSH
13685: EMPTY
13686: LIST
13687: LIST
13688: PPUSH
13689: CALL_OW 69
13693: PPUSH
13694: LD_VAR 0 1
13698: PPUSH
13699: CALL_OW 74
13703: PPUSH
13704: CALL_OW 115
// end else
13708: GO 13726
// tmp := tmp diff i ;
13710: LD_ADDR_VAR 0 2
13714: PUSH
13715: LD_VAR 0 2
13719: PUSH
13720: LD_VAR 0 1
13724: DIFF
13725: ST_TO_ADDR
13726: GO 13605
13728: POP
13729: POP
// until not tmp ;
13730: LD_VAR 0 2
13734: NOT
13735: IFFALSE 13588
// end ; end_of_file
13737: PPOPN 4
13739: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13740: LD_INT 0
13742: PPUSH
13743: PPUSH
13744: PPUSH
13745: PPUSH
// missionStage := 13 ;
13746: LD_ADDR_EXP 15
13750: PUSH
13751: LD_INT 13
13753: ST_TO_ADDR
// uc_side := 2 ;
13754: LD_ADDR_OWVAR 20
13758: PUSH
13759: LD_INT 2
13761: ST_TO_ADDR
// uc_nation := 2 ;
13762: LD_ADDR_OWVAR 21
13766: PUSH
13767: LD_INT 2
13769: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13770: LD_ADDR_EXP 91
13774: PUSH
13775: LD_STRING Omar
13777: PPUSH
13778: CALL_OW 25
13782: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13783: LD_EXP 91
13787: PPUSH
13788: LD_INT 4
13790: PPUSH
13791: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13795: LD_EXP 91
13799: PPUSH
13800: LD_INT 242
13802: PPUSH
13803: LD_INT 75
13805: PPUSH
13806: LD_INT 0
13808: PPUSH
13809: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13813: LD_ADDR_EXP 92
13817: PUSH
13818: LD_STRING Heike
13820: PPUSH
13821: CALL_OW 25
13825: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13826: LD_INT 14
13828: PPUSH
13829: LD_INT 3
13831: PPUSH
13832: LD_INT 1
13834: PPUSH
13835: LD_INT 27
13837: PPUSH
13838: LD_INT 100
13840: PPUSH
13841: CALL 71388 0 5
// veh := CreateVehicle ;
13845: LD_ADDR_VAR 0 3
13849: PUSH
13850: CALL_OW 45
13854: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13855: LD_VAR 0 3
13859: PPUSH
13860: LD_INT 1
13862: PPUSH
13863: CALL_OW 242
// SetDir ( veh , 4 ) ;
13867: LD_VAR 0 3
13871: PPUSH
13872: LD_INT 4
13874: PPUSH
13875: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13879: LD_VAR 0 3
13883: PPUSH
13884: LD_INT 241
13886: PPUSH
13887: LD_INT 72
13889: PPUSH
13890: LD_INT 0
13892: PPUSH
13893: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13897: LD_EXP 92
13901: PPUSH
13902: LD_VAR 0 3
13906: PPUSH
13907: CALL_OW 52
// if KhatamStatus then
13911: LD_EXP 8
13915: IFFALSE 13966
// begin Khatam := NewCharacter ( Khatam ) ;
13917: LD_ADDR_EXP 93
13921: PUSH
13922: LD_STRING Khatam
13924: PPUSH
13925: CALL_OW 25
13929: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13930: LD_EXP 93
13934: PPUSH
13935: LD_INT 245
13937: PPUSH
13938: LD_INT 78
13940: PPUSH
13941: LD_INT 3
13943: PPUSH
13944: LD_INT 0
13946: PPUSH
13947: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13951: LD_EXP 93
13955: PPUSH
13956: LD_INT 4
13958: PPUSH
13959: LD_INT 10
13961: PPUSH
13962: CALL_OW 237
// end ; for i = 1 to Difficulty do
13966: LD_ADDR_VAR 0 2
13970: PUSH
13971: DOUBLE
13972: LD_INT 1
13974: DEC
13975: ST_TO_ADDR
13976: LD_OWVAR 67
13980: PUSH
13981: FOR_TO
13982: IFFALSE 14048
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13984: LD_INT 0
13986: PPUSH
13987: LD_INT 7
13989: PUSH
13990: LD_OWVAR 67
13994: PLUS
13995: PPUSH
13996: CALL_OW 384
// un := CreateHuman ;
14000: LD_ADDR_VAR 0 4
14004: PUSH
14005: CALL_OW 44
14009: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14010: LD_VAR 0 4
14014: PPUSH
14015: LD_INT 28
14017: PUSH
14018: LD_INT 29
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: PUSH
14025: LD_VAR 0 2
14029: PUSH
14030: LD_INT 2
14032: MOD
14033: PUSH
14034: LD_INT 1
14036: PLUS
14037: ARRAY
14038: PPUSH
14039: LD_INT 0
14041: PPUSH
14042: CALL_OW 49
// end ;
14046: GO 13981
14048: POP
14049: POP
// for i = 1 to 6 do
14050: LD_ADDR_VAR 0 2
14054: PUSH
14055: DOUBLE
14056: LD_INT 1
14058: DEC
14059: ST_TO_ADDR
14060: LD_INT 6
14062: PUSH
14063: FOR_TO
14064: IFFALSE 14109
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14066: LD_INT 0
14068: PPUSH
14069: LD_INT 7
14071: PUSH
14072: LD_OWVAR 67
14076: PLUS
14077: PPUSH
14078: CALL_OW 381
// un := CreateHuman ;
14082: LD_ADDR_VAR 0 4
14086: PUSH
14087: CALL_OW 44
14091: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14092: LD_VAR 0 4
14096: PPUSH
14097: LD_INT 28
14099: PPUSH
14100: LD_INT 0
14102: PPUSH
14103: CALL_OW 49
// end ;
14107: GO 14063
14109: POP
14110: POP
// for i = 1 to 3 do
14111: LD_ADDR_VAR 0 2
14115: PUSH
14116: DOUBLE
14117: LD_INT 1
14119: DEC
14120: ST_TO_ADDR
14121: LD_INT 3
14123: PUSH
14124: FOR_TO
14125: IFFALSE 14173
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14127: LD_INT 0
14129: PPUSH
14130: LD_INT 8
14132: PPUSH
14133: LD_INT 7
14135: PUSH
14136: LD_OWVAR 67
14140: PLUS
14141: PPUSH
14142: CALL_OW 380
// un := CreateHuman ;
14146: LD_ADDR_VAR 0 4
14150: PUSH
14151: CALL_OW 44
14155: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14156: LD_VAR 0 4
14160: PPUSH
14161: LD_INT 28
14163: PPUSH
14164: LD_INT 0
14166: PPUSH
14167: CALL_OW 49
// end ;
14171: GO 14124
14173: POP
14174: POP
// for i = 1 to 3 do
14175: LD_ADDR_VAR 0 2
14179: PUSH
14180: DOUBLE
14181: LD_INT 1
14183: DEC
14184: ST_TO_ADDR
14185: LD_INT 3
14187: PUSH
14188: FOR_TO
14189: IFFALSE 14279
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14191: LD_INT 14
14193: PPUSH
14194: LD_INT 2
14196: PPUSH
14197: LD_INT 1
14199: PPUSH
14200: LD_INT 28
14202: PPUSH
14203: LD_INT 80
14205: PPUSH
14206: CALL 71388 0 5
// veh := CreateVehicle ;
14210: LD_ADDR_VAR 0 3
14214: PUSH
14215: CALL_OW 45
14219: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14220: LD_VAR 0 3
14224: PPUSH
14225: LD_INT 3
14227: PPUSH
14228: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14232: LD_VAR 0 3
14236: PPUSH
14237: LD_INT 29
14239: PPUSH
14240: LD_INT 0
14242: PPUSH
14243: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14247: LD_INT 0
14249: PPUSH
14250: LD_INT 7
14252: PUSH
14253: LD_OWVAR 67
14257: PLUS
14258: PPUSH
14259: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14263: CALL_OW 44
14267: PPUSH
14268: LD_VAR 0 3
14272: PPUSH
14273: CALL_OW 52
// end ;
14277: GO 14188
14279: POP
14280: POP
// for i = 1 to 5 + Difficulty do
14281: LD_ADDR_VAR 0 2
14285: PUSH
14286: DOUBLE
14287: LD_INT 1
14289: DEC
14290: ST_TO_ADDR
14291: LD_INT 5
14293: PUSH
14294: LD_OWVAR 67
14298: PLUS
14299: PUSH
14300: FOR_TO
14301: IFFALSE 14428
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14303: LD_INT 14
14305: PPUSH
14306: LD_INT 1
14308: PPUSH
14309: LD_INT 3
14311: PPUSH
14312: CALL_OW 12
14316: PPUSH
14317: LD_INT 1
14319: PPUSH
14320: LD_INT 28
14322: PUSH
14323: LD_INT 26
14325: PUSH
14326: LD_INT 27
14328: PUSH
14329: LD_INT 25
14331: PUSH
14332: EMPTY
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: PUSH
14338: LD_VAR 0 2
14342: PUSH
14343: LD_INT 4
14345: MOD
14346: PUSH
14347: LD_INT 1
14349: PLUS
14350: ARRAY
14351: PPUSH
14352: LD_INT 80
14354: PPUSH
14355: CALL 71388 0 5
// veh := CreateVehicle ;
14359: LD_ADDR_VAR 0 3
14363: PUSH
14364: CALL_OW 45
14368: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14369: LD_VAR 0 3
14373: PPUSH
14374: LD_INT 4
14376: PPUSH
14377: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14381: LD_VAR 0 3
14385: PPUSH
14386: LD_INT 28
14388: PPUSH
14389: LD_INT 0
14391: PPUSH
14392: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14396: LD_INT 0
14398: PPUSH
14399: LD_INT 7
14401: PUSH
14402: LD_OWVAR 67
14406: PLUS
14407: PPUSH
14408: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14412: CALL_OW 44
14416: PPUSH
14417: LD_VAR 0 3
14421: PPUSH
14422: CALL_OW 52
// end ;
14426: GO 14300
14428: POP
14429: POP
// for i = 1 to 3 do
14430: LD_ADDR_VAR 0 2
14434: PUSH
14435: DOUBLE
14436: LD_INT 1
14438: DEC
14439: ST_TO_ADDR
14440: LD_INT 3
14442: PUSH
14443: FOR_TO
14444: IFFALSE 14504
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14446: LD_INT 14
14448: PPUSH
14449: LD_INT 3
14451: PPUSH
14452: LD_INT 5
14454: PPUSH
14455: LD_INT 29
14457: PPUSH
14458: LD_INT 80
14460: PPUSH
14461: CALL 71388 0 5
// veh := CreateVehicle ;
14465: LD_ADDR_VAR 0 3
14469: PUSH
14470: CALL_OW 45
14474: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14475: LD_VAR 0 3
14479: PPUSH
14480: LD_INT 4
14482: PPUSH
14483: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14487: LD_VAR 0 3
14491: PPUSH
14492: LD_INT 28
14494: PPUSH
14495: LD_INT 0
14497: PPUSH
14498: CALL_OW 49
// end ;
14502: GO 14443
14504: POP
14505: POP
// end ;
14506: LD_VAR 0 1
14510: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14511: LD_INT 22
14513: PUSH
14514: LD_INT 2
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PPUSH
14521: CALL_OW 69
14525: IFFALSE 14825
14527: GO 14529
14529: DISABLE
14530: LD_INT 0
14532: PPUSH
14533: PPUSH
14534: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14535: LD_ADDR_VAR 0 3
14539: PUSH
14540: LD_INT 22
14542: PUSH
14543: LD_INT 2
14545: PUSH
14546: EMPTY
14547: LIST
14548: LIST
14549: PUSH
14550: LD_INT 25
14552: PUSH
14553: LD_INT 4
14555: PUSH
14556: EMPTY
14557: LIST
14558: LIST
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: PPUSH
14564: CALL_OW 69
14568: PUSH
14569: LD_EXP 93
14573: DIFF
14574: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14575: LD_ADDR_VAR 0 2
14579: PUSH
14580: LD_INT 22
14582: PUSH
14583: LD_INT 2
14585: PUSH
14586: EMPTY
14587: LIST
14588: LIST
14589: PPUSH
14590: CALL_OW 69
14594: PUSH
14595: LD_EXP 93
14599: PUSH
14600: LD_VAR 0 3
14604: UNION
14605: DIFF
14606: ST_TO_ADDR
// if Khatam then
14607: LD_EXP 93
14611: IFFALSE 14628
// ComMoveXY ( Khatam , 211 , 92 ) ;
14613: LD_EXP 93
14617: PPUSH
14618: LD_INT 211
14620: PPUSH
14621: LD_INT 92
14623: PPUSH
14624: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14628: LD_INT 197
14630: PPUSH
14631: LD_INT 80
14633: PPUSH
14634: LD_INT 2
14636: PPUSH
14637: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14641: LD_INT 213
14643: PPUSH
14644: LD_INT 90
14646: PPUSH
14647: LD_INT 2
14649: PPUSH
14650: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14654: LD_INT 215
14656: PPUSH
14657: LD_INT 129
14659: PPUSH
14660: LD_INT 2
14662: PPUSH
14663: CALL_OW 441
// if sci then
14667: LD_VAR 0 3
14671: IFFALSE 14692
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14673: LD_VAR 0 3
14677: PUSH
14678: LD_INT 1
14680: ARRAY
14681: PPUSH
14682: LD_INT 197
14684: PPUSH
14685: LD_INT 80
14687: PPUSH
14688: CALL_OW 158
// if sci > 1 then
14692: LD_VAR 0 3
14696: PUSH
14697: LD_INT 1
14699: GREATER
14700: IFFALSE 14721
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14702: LD_VAR 0 3
14706: PUSH
14707: LD_INT 2
14709: ARRAY
14710: PPUSH
14711: LD_INT 213
14713: PPUSH
14714: LD_INT 90
14716: PPUSH
14717: CALL_OW 158
// if sci > 2 then
14721: LD_VAR 0 3
14725: PUSH
14726: LD_INT 2
14728: GREATER
14729: IFFALSE 14750
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14731: LD_VAR 0 3
14735: PUSH
14736: LD_INT 3
14738: ARRAY
14739: PPUSH
14740: LD_INT 215
14742: PPUSH
14743: LD_INT 129
14745: PPUSH
14746: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14750: LD_INT 35
14752: PPUSH
14753: CALL_OW 67
// for i in tmp do
14757: LD_ADDR_VAR 0 1
14761: PUSH
14762: LD_VAR 0 2
14766: PUSH
14767: FOR_IN
14768: IFFALSE 14806
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14770: LD_VAR 0 1
14774: PPUSH
14775: LD_INT 81
14777: PUSH
14778: LD_INT 2
14780: PUSH
14781: EMPTY
14782: LIST
14783: LIST
14784: PPUSH
14785: CALL_OW 69
14789: PPUSH
14790: LD_VAR 0 1
14794: PPUSH
14795: CALL_OW 74
14799: PPUSH
14800: CALL_OW 115
14804: GO 14767
14806: POP
14807: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14808: LD_INT 22
14810: PUSH
14811: LD_INT 2
14813: PUSH
14814: EMPTY
14815: LIST
14816: LIST
14817: PPUSH
14818: CALL_OW 69
14822: NOT
14823: IFFALSE 14750
// end ; end_of_file
14825: PPOPN 3
14827: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14828: LD_INT 0
14830: PPUSH
14831: PPUSH
14832: PPUSH
14833: PPUSH
14834: PPUSH
14835: PPUSH
14836: PPUSH
14837: PPUSH
14838: PPUSH
// Video ( true ) ;
14839: LD_INT 1
14841: PPUSH
14842: CALL 107108 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14846: LD_ADDR_VAR 0 5
14850: PUSH
14851: LD_INT 7
14853: PPUSH
14854: LD_INT 0
14856: PPUSH
14857: CALL_OW 517
14861: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14862: LD_ADDR_VAR 0 2
14866: PUSH
14867: DOUBLE
14868: LD_INT 1
14870: DEC
14871: ST_TO_ADDR
14872: LD_VAR 0 5
14876: PUSH
14877: LD_INT 1
14879: ARRAY
14880: PUSH
14881: FOR_TO
14882: IFFALSE 14927
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14884: LD_VAR 0 5
14888: PUSH
14889: LD_INT 1
14891: ARRAY
14892: PUSH
14893: LD_VAR 0 2
14897: ARRAY
14898: PPUSH
14899: LD_VAR 0 5
14903: PUSH
14904: LD_INT 2
14906: ARRAY
14907: PUSH
14908: LD_VAR 0 2
14912: ARRAY
14913: PPUSH
14914: LD_INT 1
14916: PPUSH
14917: LD_INT 15
14919: NEG
14920: PPUSH
14921: CALL 107022 0 4
14925: GO 14881
14927: POP
14928: POP
// CenterNowOnUnits ( Powell ) ;
14929: LD_EXP 57
14933: PPUSH
14934: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14938: LD_ADDR_VAR 0 5
14942: PUSH
14943: LD_EXP 55
14947: PUSH
14948: EMPTY
14949: LIST
14950: ST_TO_ADDR
// if GirlNewVeh then
14951: LD_EXP 56
14955: IFFALSE 14973
// tmp := tmp ^ GirlNewVeh ;
14957: LD_ADDR_VAR 0 5
14961: PUSH
14962: LD_VAR 0 5
14966: PUSH
14967: LD_EXP 56
14971: ADD
14972: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14973: LD_VAR 0 5
14977: PPUSH
14978: LD_INT 60
14980: PPUSH
14981: LD_INT 109
14983: PPUSH
14984: CALL_OW 111
// if KappaStatus then
14988: LD_EXP 2
14992: IFFALSE 15044
// begin Say ( JMM , D1nT-JMM-1 ) ;
14994: LD_EXP 38
14998: PPUSH
14999: LD_STRING D1nT-JMM-1
15001: PPUSH
15002: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15006: LD_EXP 57
15010: PPUSH
15011: LD_STRING D1T-Pow-1
15013: PPUSH
15014: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15018: LD_EXP 38
15022: PPUSH
15023: LD_STRING D1T-JMM-2
15025: PPUSH
15026: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15030: LD_EXP 57
15034: PPUSH
15035: LD_STRING D1T-Pow-2
15037: PPUSH
15038: CALL_OW 88
// end else
15042: GO 15250
// if JMMGirlStatus then
15044: LD_EXP 6
15048: IFFALSE 15193
// begin Say ( JMM , D1T-JMM-1 ) ;
15050: LD_EXP 38
15054: PPUSH
15055: LD_STRING D1T-JMM-1
15057: PPUSH
15058: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15062: LD_EXP 57
15066: PPUSH
15067: LD_STRING D1T-Pow-1
15069: PPUSH
15070: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15074: LD_EXP 38
15078: PPUSH
15079: LD_STRING D1T-JMM-3
15081: PPUSH
15082: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15086: LD_EXP 57
15090: PPUSH
15091: LD_STRING D1T-Pow-3
15093: PPUSH
15094: CALL_OW 88
// if JMMGirl then
15098: LD_EXP 7
15102: IFFALSE 15191
// begin case JMMGirl of 1 :
15104: LD_EXP 7
15108: PUSH
15109: LD_INT 1
15111: DOUBLE
15112: EQUAL
15113: IFTRUE 15117
15115: GO 15132
15117: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15118: LD_EXP 39
15122: PPUSH
15123: LD_STRING D1T-Joan-3
15125: PPUSH
15126: CALL_OW 88
15130: GO 15179
15132: LD_INT 2
15134: DOUBLE
15135: EQUAL
15136: IFTRUE 15140
15138: GO 15155
15140: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15141: LD_EXP 41
15145: PPUSH
15146: LD_STRING D1T-Lisa-3
15148: PPUSH
15149: CALL_OW 88
15153: GO 15179
15155: LD_INT 3
15157: DOUBLE
15158: EQUAL
15159: IFTRUE 15163
15161: GO 15178
15163: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15164: LD_EXP 53
15168: PPUSH
15169: LD_STRING D1T-Con-3
15171: PPUSH
15172: CALL_OW 88
15176: GO 15179
15178: POP
// Say ( Powell , D1T-Pow-4 ) ;
15179: LD_EXP 57
15183: PPUSH
15184: LD_STRING D1T-Pow-4
15186: PPUSH
15187: CALL_OW 88
// end ; end else
15191: GO 15250
// if not FastEnd then
15193: LD_EXP 11
15197: NOT
15198: IFFALSE 15226
// begin Say ( JMM , D1T-JMM-4 ) ;
15200: LD_EXP 38
15204: PPUSH
15205: LD_STRING D1T-JMM-4
15207: PPUSH
15208: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15212: LD_EXP 57
15216: PPUSH
15217: LD_STRING D1T-Pow-5
15219: PPUSH
15220: CALL_OW 88
// end else
15224: GO 15250
// begin Say ( JMM , D1nT-JMM-1 ) ;
15226: LD_EXP 38
15230: PPUSH
15231: LD_STRING D1nT-JMM-1
15233: PPUSH
15234: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15238: LD_EXP 57
15242: PPUSH
15243: LD_STRING D1nT-Pow-1
15245: PPUSH
15246: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15250: LD_INT 35
15252: PPUSH
15253: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15257: LD_EXP 55
15261: PPUSH
15262: CALL_OW 314
15266: NOT
15267: IFFALSE 15250
// ComExitVehicle ( JMM ) ;
15269: LD_EXP 38
15273: PPUSH
15274: CALL_OW 121
// wait ( 3 ) ;
15278: LD_INT 3
15280: PPUSH
15281: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15285: LD_EXP 38
15289: PPUSH
15290: LD_INT 60
15292: PPUSH
15293: LD_INT 94
15295: PPUSH
15296: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15300: LD_EXP 38
15304: PPUSH
15305: LD_EXP 57
15309: PPUSH
15310: CALL_OW 179
// if Joan then
15314: LD_EXP 39
15318: IFFALSE 15372
// begin ComExitVehicle ( Joan ) ;
15320: LD_EXP 39
15324: PPUSH
15325: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15329: LD_EXP 39
15333: PPUSH
15334: LD_INT 35
15336: PPUSH
15337: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15341: LD_EXP 39
15345: PPUSH
15346: LD_INT 65
15348: PPUSH
15349: LD_INT 104
15351: PPUSH
15352: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15356: LD_EXP 39
15360: PPUSH
15361: LD_EXP 38
15365: PPUSH
15366: CALL_OW 179
// end else
15370: GO 15506
// if Lisa and JMMGirl = 2 then
15372: LD_EXP 41
15376: PUSH
15377: LD_EXP 7
15381: PUSH
15382: LD_INT 2
15384: EQUAL
15385: AND
15386: IFFALSE 15440
// begin ComExitVehicle ( Lisa ) ;
15388: LD_EXP 41
15392: PPUSH
15393: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15397: LD_EXP 41
15401: PPUSH
15402: LD_INT 35
15404: PPUSH
15405: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15409: LD_EXP 41
15413: PPUSH
15414: LD_INT 65
15416: PPUSH
15417: LD_INT 104
15419: PPUSH
15420: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15424: LD_EXP 41
15428: PPUSH
15429: LD_EXP 38
15433: PPUSH
15434: CALL_OW 179
// end else
15438: GO 15506
// if Connie and JMMGirl = 3 then
15440: LD_EXP 53
15444: PUSH
15445: LD_EXP 7
15449: PUSH
15450: LD_INT 3
15452: EQUAL
15453: AND
15454: IFFALSE 15506
// begin ComExitVehicle ( Connie ) ;
15456: LD_EXP 53
15460: PPUSH
15461: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15465: LD_EXP 53
15469: PPUSH
15470: LD_INT 35
15472: PPUSH
15473: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15477: LD_EXP 53
15481: PPUSH
15482: LD_INT 65
15484: PPUSH
15485: LD_INT 104
15487: PPUSH
15488: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15492: LD_EXP 53
15496: PPUSH
15497: LD_EXP 38
15501: PPUSH
15502: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15506: LD_INT 35
15508: PPUSH
15509: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15513: LD_EXP 38
15517: PPUSH
15518: LD_EXP 57
15522: PPUSH
15523: CALL_OW 296
15527: PUSH
15528: LD_INT 6
15530: LESS
15531: IFFALSE 15506
// wait ( 0 0$0.5 ) ;
15533: LD_INT 18
15535: PPUSH
15536: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15540: LD_EXP 38
15544: PPUSH
15545: LD_STRING D1-JMM-1
15547: PPUSH
15548: CALL_OW 88
// async ;
15552: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15553: LD_EXP 57
15557: PPUSH
15558: LD_STRING D1-Pow-1
15560: PPUSH
15561: CALL_OW 88
// if not dialogue_skipped then
15565: LD_OWVAR 59
15569: NOT
15570: IFFALSE 15579
// wait ( 0 0$2 ) ;
15572: LD_INT 70
15574: PPUSH
15575: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15579: LD_INT 170
15581: PPUSH
15582: LD_INT 99
15584: PPUSH
15585: LD_INT 1
15587: PPUSH
15588: LD_INT 6
15590: NEG
15591: PPUSH
15592: CALL 107022 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15596: LD_INT 174
15598: PPUSH
15599: LD_INT 115
15601: PPUSH
15602: LD_INT 1
15604: PPUSH
15605: LD_INT 6
15607: NEG
15608: PPUSH
15609: CALL 107022 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15613: LD_INT 169
15615: PPUSH
15616: LD_INT 71
15618: PPUSH
15619: LD_INT 1
15621: PPUSH
15622: LD_INT 6
15624: NEG
15625: PPUSH
15626: CALL 107022 0 4
// if not dialogue_skipped then
15630: LD_OWVAR 59
15634: NOT
15635: IFFALSE 15654
// begin CenterOnXY ( 170 , 99 ) ;
15637: LD_INT 170
15639: PPUSH
15640: LD_INT 99
15642: PPUSH
15643: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15647: LD_INT 80
15649: PPUSH
15650: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15654: LD_INT 75
15656: PPUSH
15657: LD_INT 53
15659: PPUSH
15660: LD_INT 1
15662: PPUSH
15663: LD_INT 9
15665: NEG
15666: PPUSH
15667: CALL 107022 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15671: LD_INT 54
15673: PPUSH
15674: LD_INT 42
15676: PPUSH
15677: LD_INT 1
15679: PPUSH
15680: LD_INT 9
15682: NEG
15683: PPUSH
15684: CALL 107022 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15688: LD_INT 62
15690: PPUSH
15691: LD_INT 51
15693: PPUSH
15694: LD_INT 1
15696: PPUSH
15697: LD_INT 9
15699: NEG
15700: PPUSH
15701: CALL 107022 0 4
// if not dialogue_skipped then
15705: LD_OWVAR 59
15709: NOT
15710: IFFALSE 15729
// begin CenterOnXY ( 75 , 53 ) ;
15712: LD_INT 75
15714: PPUSH
15715: LD_INT 53
15717: PPUSH
15718: CALL_OW 84
// wait ( 0 0$4 ) ;
15722: LD_INT 140
15724: PPUSH
15725: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15729: LD_EXP 57
15733: PPUSH
15734: CALL_OW 87
// if not dialogue_skipped then
15738: LD_OWVAR 59
15742: NOT
15743: IFFALSE 15752
// wait ( 0 0$2 ) ;
15745: LD_INT 70
15747: PPUSH
15748: CALL_OW 67
// sync ;
15752: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15753: LD_EXP 38
15757: PPUSH
15758: LD_STRING D1-JMM-2
15760: PPUSH
15761: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15765: LD_EXP 57
15769: PPUSH
15770: LD_STRING D1-Pow-2
15772: PPUSH
15773: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15777: LD_EXP 38
15781: PPUSH
15782: LD_STRING D1-JMM-3
15784: PPUSH
15785: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15789: LD_EXP 57
15793: PPUSH
15794: LD_STRING D1-Pow-3
15796: PPUSH
15797: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15801: LD_EXP 38
15805: PPUSH
15806: LD_STRING D1-JMM-4
15808: PPUSH
15809: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15813: LD_EXP 57
15817: PPUSH
15818: LD_STRING D1-Pow-4
15820: PPUSH
15821: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15825: LD_EXP 38
15829: PPUSH
15830: LD_STRING D1-JMM-5
15832: PPUSH
15833: CALL_OW 88
// async ;
15837: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15838: LD_EXP 57
15842: PPUSH
15843: LD_STRING D1-Pow-5
15845: PPUSH
15846: CALL_OW 88
// if not dialogue_skipped then
15850: LD_OWVAR 59
15854: NOT
15855: IFFALSE 15864
// wait ( 0 0$3.6 ) ;
15857: LD_INT 126
15859: PPUSH
15860: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15864: LD_INT 134
15866: PPUSH
15867: LD_INT 210
15869: PPUSH
15870: LD_INT 1
15872: PPUSH
15873: LD_INT 11
15875: NEG
15876: PPUSH
15877: CALL 107022 0 4
// if not dialogue_skipped then
15881: LD_OWVAR 59
15885: NOT
15886: IFFALSE 15905
// begin CenterOnXY ( 134 , 210 ) ;
15888: LD_INT 134
15890: PPUSH
15891: LD_INT 210
15893: PPUSH
15894: CALL_OW 84
// wait ( 0 0$2 ) ;
15898: LD_INT 70
15900: PPUSH
15901: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15905: LD_INT 101
15907: PPUSH
15908: LD_INT 159
15910: PPUSH
15911: LD_INT 1
15913: PPUSH
15914: LD_INT 10
15916: NEG
15917: PPUSH
15918: CALL 107022 0 4
// if not dialogue_skipped then
15922: LD_OWVAR 59
15926: NOT
15927: IFFALSE 15946
// begin CenterOnXY ( 101 , 159 ) ;
15929: LD_INT 101
15931: PPUSH
15932: LD_INT 159
15934: PPUSH
15935: CALL_OW 84
// wait ( 0 0$2 ) ;
15939: LD_INT 70
15941: PPUSH
15942: CALL_OW 67
// end ; sync ;
15946: SYNC
// CenterNowOnUnits ( Powell ) ;
15947: LD_EXP 57
15951: PPUSH
15952: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15956: LD_ADDR_VAR 0 6
15960: PUSH
15961: LD_INT 1
15963: PUSH
15964: LD_INT 2
15966: PUSH
15967: LD_INT 3
15969: PUSH
15970: LD_INT 4
15972: PUSH
15973: LD_INT 5
15975: PUSH
15976: LD_INT 6
15978: PUSH
15979: EMPTY
15980: LIST
15981: LIST
15982: LIST
15983: LIST
15984: LIST
15985: LIST
15986: ST_TO_ADDR
// if not dialogue_skipped then
15987: LD_OWVAR 59
15991: NOT
15992: IFFALSE 16161
// begin game_speed := 4 ;
15994: LD_ADDR_OWVAR 65
15998: PUSH
15999: LD_INT 4
16001: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16002: LD_INT 210
16004: PPUSH
16005: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16009: LD_ADDR_VAR 0 7
16013: PUSH
16014: LD_STRING Q1
16016: PPUSH
16017: LD_VAR 0 6
16021: PPUSH
16022: CALL_OW 98
16026: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16027: LD_ADDR_VAR 0 7
16031: PUSH
16032: LD_STRING Q1
16034: PPUSH
16035: LD_VAR 0 6
16039: PPUSH
16040: CALL_OW 98
16044: ST_TO_ADDR
// options = options diff dec ;
16045: LD_ADDR_VAR 0 6
16049: PUSH
16050: LD_VAR 0 6
16054: PUSH
16055: LD_VAR 0 7
16059: DIFF
16060: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16061: LD_VAR 0 7
16065: PPUSH
16066: LD_VAR 0 6
16070: PPUSH
16071: CALL 17633 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16075: LD_VAR 0 7
16079: PUSH
16080: LD_INT 5
16082: PUSH
16083: LD_INT 6
16085: PUSH
16086: EMPTY
16087: LIST
16088: LIST
16089: IN
16090: PUSH
16091: LD_VAR 0 6
16095: PUSH
16096: LD_INT 2
16098: EQUAL
16099: OR
16100: IFFALSE 16027
// if not ( dec in [ 5 , 6 ] ) then
16102: LD_VAR 0 7
16106: PUSH
16107: LD_INT 5
16109: PUSH
16110: LD_INT 6
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: IN
16117: NOT
16118: IFFALSE 16161
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16120: LD_ADDR_VAR 0 7
16124: PUSH
16125: LD_STRING Q1a
16127: PPUSH
16128: LD_INT 1
16130: PUSH
16131: LD_INT 2
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PPUSH
16138: CALL_OW 98
16142: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16143: LD_VAR 0 7
16147: PUSH
16148: LD_INT 4
16150: PLUS
16151: PPUSH
16152: LD_VAR 0 6
16156: PPUSH
16157: CALL 17633 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16161: LD_INT 81
16163: PPUSH
16164: LD_INT 127
16166: PPUSH
16167: CALL_OW 84
// amount := 5 ;
16171: LD_ADDR_VAR 0 8
16175: PUSH
16176: LD_INT 5
16178: ST_TO_ADDR
// macmilan_squad := [ ] ;
16179: LD_ADDR_VAR 0 9
16183: PUSH
16184: EMPTY
16185: ST_TO_ADDR
// if vip < amount then
16186: LD_EXP 58
16190: PUSH
16191: LD_VAR 0 8
16195: LESS
16196: IFFALSE 16240
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16198: LD_ADDR_VAR 0 5
16202: PUSH
16203: LD_EXP 58
16207: PUSH
16208: LD_INT 22
16210: PUSH
16211: LD_INT 4
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: PUSH
16218: LD_INT 21
16220: PUSH
16221: LD_INT 1
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: PUSH
16228: EMPTY
16229: LIST
16230: LIST
16231: PPUSH
16232: CALL_OW 69
16236: UNION
16237: ST_TO_ADDR
16238: GO 16250
// tmp := vip ;
16240: LD_ADDR_VAR 0 5
16244: PUSH
16245: LD_EXP 58
16249: ST_TO_ADDR
// tmp := tmp diff Powell ;
16250: LD_ADDR_VAR 0 5
16254: PUSH
16255: LD_VAR 0 5
16259: PUSH
16260: LD_EXP 57
16264: DIFF
16265: ST_TO_ADDR
// if tmp < amount then
16266: LD_VAR 0 5
16270: PUSH
16271: LD_VAR 0 8
16275: LESS
16276: IFFALSE 16288
// amount := tmp ;
16278: LD_ADDR_VAR 0 8
16282: PUSH
16283: LD_VAR 0 5
16287: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16288: LD_VAR 0 5
16292: PUSH
16293: LD_INT 1
16295: ARRAY
16296: PPUSH
16297: CALL_OW 257
16301: PUSH
16302: LD_INT 2
16304: NONEQUAL
16305: IFFALSE 16367
// begin if IsInUnit ( tmp [ 1 ] ) then
16307: LD_VAR 0 5
16311: PUSH
16312: LD_INT 1
16314: ARRAY
16315: PPUSH
16316: CALL_OW 310
16320: IFFALSE 16335
// ComExitBuilding ( tmp [ 1 ] ) ;
16322: LD_VAR 0 5
16326: PUSH
16327: LD_INT 1
16329: ARRAY
16330: PPUSH
16331: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16335: LD_VAR 0 5
16339: PUSH
16340: LD_INT 1
16342: ARRAY
16343: PPUSH
16344: LD_INT 387
16346: PPUSH
16347: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16351: LD_VAR 0 5
16355: PUSH
16356: LD_INT 1
16358: ARRAY
16359: PPUSH
16360: LD_INT 2
16362: PPUSH
16363: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16367: LD_EXP 38
16371: PPUSH
16372: LD_INT 82
16374: PPUSH
16375: LD_INT 129
16377: PPUSH
16378: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16382: LD_EXP 38
16386: PPUSH
16387: LD_EXP 57
16391: PPUSH
16392: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16396: LD_INT 22
16398: PUSH
16399: LD_INT 1
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PPUSH
16406: CALL_OW 69
16410: PUSH
16411: LD_EXP 38
16415: DIFF
16416: PPUSH
16417: LD_INT 84
16419: PPUSH
16420: LD_INT 128
16422: PPUSH
16423: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16427: LD_INT 22
16429: PUSH
16430: LD_INT 1
16432: PUSH
16433: EMPTY
16434: LIST
16435: LIST
16436: PPUSH
16437: CALL_OW 69
16441: PUSH
16442: LD_EXP 38
16446: DIFF
16447: PPUSH
16448: LD_EXP 38
16452: PPUSH
16453: CALL_OW 179
// for i = 1 to amount do
16457: LD_ADDR_VAR 0 2
16461: PUSH
16462: DOUBLE
16463: LD_INT 1
16465: DEC
16466: ST_TO_ADDR
16467: LD_VAR 0 8
16471: PUSH
16472: FOR_TO
16473: IFFALSE 16641
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16475: LD_ADDR_VAR 0 9
16479: PUSH
16480: LD_VAR 0 9
16484: PUSH
16485: LD_VAR 0 5
16489: PUSH
16490: LD_VAR 0 2
16494: ARRAY
16495: ADD
16496: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16497: LD_VAR 0 5
16501: PUSH
16502: LD_VAR 0 2
16506: ARRAY
16507: PPUSH
16508: CALL_OW 310
16512: IFFALSE 16529
// AddComExitBuilding ( tmp [ i ] ) ;
16514: LD_VAR 0 5
16518: PUSH
16519: LD_VAR 0 2
16523: ARRAY
16524: PPUSH
16525: CALL_OW 182
// if i = 2 and JMMNewVeh then
16529: LD_VAR 0 2
16533: PUSH
16534: LD_INT 2
16536: EQUAL
16537: PUSH
16538: LD_EXP 55
16542: AND
16543: IFFALSE 16601
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16545: LD_VAR 0 5
16549: PUSH
16550: LD_VAR 0 2
16554: ARRAY
16555: PPUSH
16556: LD_EXP 55
16560: PPUSH
16561: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16565: LD_VAR 0 5
16569: PUSH
16570: LD_VAR 0 2
16574: ARRAY
16575: PPUSH
16576: LD_INT 86
16578: PPUSH
16579: LD_INT 133
16581: PPUSH
16582: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16586: LD_VAR 0 5
16590: PUSH
16591: LD_VAR 0 2
16595: ARRAY
16596: PPUSH
16597: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16601: LD_VAR 0 5
16605: PUSH
16606: LD_VAR 0 2
16610: ARRAY
16611: PPUSH
16612: LD_INT 8
16614: PPUSH
16615: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16619: LD_VAR 0 5
16623: PUSH
16624: LD_VAR 0 2
16628: ARRAY
16629: PPUSH
16630: LD_EXP 38
16634: PPUSH
16635: CALL_OW 179
// end ;
16639: GO 16472
16641: POP
16642: POP
// if GirlNewVeh then
16643: LD_EXP 56
16647: IFFALSE 16661
// SetSide ( GirlNewVeh , 4 ) ;
16649: LD_EXP 56
16653: PPUSH
16654: LD_INT 4
16656: PPUSH
16657: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16661: LD_INT 35
16663: PPUSH
16664: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16668: LD_VAR 0 9
16672: PPUSH
16673: LD_INT 95
16675: PUSH
16676: LD_INT 9
16678: PUSH
16679: EMPTY
16680: LIST
16681: LIST
16682: PPUSH
16683: CALL_OW 72
16687: PUSH
16688: LD_INT 0
16690: EQUAL
16691: PUSH
16692: LD_EXP 38
16696: PPUSH
16697: LD_INT 9
16699: PPUSH
16700: CALL_OW 308
16704: NOT
16705: AND
16706: IFFALSE 16661
// wait ( 0 0$2 ) ;
16708: LD_INT 70
16710: PPUSH
16711: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16715: LD_VAR 0 9
16719: PPUSH
16720: LD_INT 1
16722: PPUSH
16723: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16727: LD_INT 21
16729: PUSH
16730: LD_INT 2
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: PUSH
16737: LD_INT 92
16739: PUSH
16740: LD_INT 83
16742: PUSH
16743: LD_INT 130
16745: PUSH
16746: LD_INT 10
16748: PUSH
16749: EMPTY
16750: LIST
16751: LIST
16752: LIST
16753: LIST
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: PPUSH
16759: CALL_OW 69
16763: PPUSH
16764: LD_INT 1
16766: PPUSH
16767: CALL_OW 235
// Video ( false ) ;
16771: LD_INT 0
16773: PPUSH
16774: CALL 107108 0 1
// ChangeMissionObjectives ( M1 ) ;
16778: LD_STRING M1
16780: PPUSH
16781: CALL_OW 337
// SaveForQuickRestart ;
16785: CALL_OW 22
// missionStart := true ;
16789: LD_ADDR_EXP 13
16793: PUSH
16794: LD_INT 1
16796: ST_TO_ADDR
// missionStage := 2 ;
16797: LD_ADDR_EXP 15
16801: PUSH
16802: LD_INT 2
16804: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16805: LD_INT 105
16807: PPUSH
16808: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16812: LD_ADDR_VAR 0 5
16816: PUSH
16817: LD_INT 22
16819: PUSH
16820: LD_INT 4
16822: PUSH
16823: EMPTY
16824: LIST
16825: LIST
16826: PUSH
16827: LD_INT 21
16829: PUSH
16830: LD_INT 1
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: PPUSH
16841: CALL_OW 69
16845: PUSH
16846: LD_EXP 57
16850: DIFF
16851: ST_TO_ADDR
// if not tmp then
16852: LD_VAR 0 5
16856: NOT
16857: IFFALSE 16872
// tmp := [ Powell ] ;
16859: LD_ADDR_VAR 0 5
16863: PUSH
16864: LD_EXP 57
16868: PUSH
16869: EMPTY
16870: LIST
16871: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16872: LD_ADDR_EXP 101
16876: PUSH
16877: LD_EXP 101
16881: PPUSH
16882: LD_INT 4
16884: PPUSH
16885: LD_INT 22
16887: PUSH
16888: LD_INT 4
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: PUSH
16895: LD_INT 23
16897: PUSH
16898: LD_INT 1
16900: PUSH
16901: EMPTY
16902: LIST
16903: LIST
16904: PUSH
16905: LD_INT 3
16907: PUSH
16908: LD_INT 21
16910: PUSH
16911: LD_INT 2
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: LIST
16926: PPUSH
16927: CALL_OW 69
16931: PUSH
16932: LD_EXP 57
16936: DIFF
16937: PPUSH
16938: CALL_OW 1
16942: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16943: LD_ADDR_VAR 0 4
16947: PUSH
16948: LD_INT 22
16950: PUSH
16951: LD_INT 4
16953: PUSH
16954: EMPTY
16955: LIST
16956: LIST
16957: PUSH
16958: LD_INT 34
16960: PUSH
16961: LD_INT 12
16963: PUSH
16964: EMPTY
16965: LIST
16966: LIST
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: PPUSH
16972: CALL_OW 69
16976: PUSH
16977: LD_INT 1
16979: ARRAY
16980: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16981: LD_VAR 0 5
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: PPUSH
16990: CALL_OW 310
16994: IFFALSE 17009
// ComExitBuilding ( tmp [ 1 ] ) ;
16996: LD_VAR 0 5
17000: PUSH
17001: LD_INT 1
17003: ARRAY
17004: PPUSH
17005: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17009: LD_VAR 0 5
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: PPUSH
17018: LD_VAR 0 4
17022: PPUSH
17023: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17027: LD_VAR 0 5
17031: PUSH
17032: LD_INT 1
17034: ARRAY
17035: PPUSH
17036: LD_INT 80
17038: PPUSH
17039: LD_INT 136
17041: PPUSH
17042: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17046: LD_VAR 0 5
17050: PUSH
17051: LD_INT 1
17053: ARRAY
17054: PPUSH
17055: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17059: LD_VAR 0 5
17063: PUSH
17064: LD_INT 1
17066: ARRAY
17067: PPUSH
17068: LD_INT 59
17070: PPUSH
17071: LD_INT 112
17073: PPUSH
17074: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17078: LD_VAR 0 5
17082: PUSH
17083: LD_INT 1
17085: ARRAY
17086: PPUSH
17087: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17091: LD_EXP 39
17095: PUSH
17096: LD_EXP 39
17100: PPUSH
17101: CALL_OW 255
17105: PUSH
17106: LD_INT 1
17108: EQUAL
17109: AND
17110: IFFALSE 17136
// begin Say ( Joan , D3W-Joan-1 ) ;
17112: LD_EXP 39
17116: PPUSH
17117: LD_STRING D3W-Joan-1
17119: PPUSH
17120: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17124: LD_EXP 38
17128: PPUSH
17129: LD_STRING D3W-JMM-1
17131: PPUSH
17132: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17136: LD_EXP 41
17140: PUSH
17141: LD_EXP 41
17145: PPUSH
17146: CALL_OW 255
17150: PUSH
17151: LD_INT 1
17153: EQUAL
17154: AND
17155: PUSH
17156: LD_EXP 41
17160: PUSH
17161: LD_EXP 58
17165: IN
17166: NOT
17167: AND
17168: IFFALSE 17194
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17170: LD_EXP 41
17174: PPUSH
17175: LD_STRING D3W-Lisa-1
17177: PPUSH
17178: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17182: LD_EXP 38
17186: PPUSH
17187: LD_STRING D3W-JMM-1
17189: PPUSH
17190: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17194: LD_EXP 53
17198: PUSH
17199: LD_EXP 53
17203: PPUSH
17204: CALL_OW 255
17208: PUSH
17209: LD_INT 1
17211: EQUAL
17212: AND
17213: IFFALSE 17239
// begin Say ( Connie , D3W-Con-1 ) ;
17215: LD_EXP 53
17219: PPUSH
17220: LD_STRING D3W-Con-1
17222: PPUSH
17223: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17227: LD_EXP 38
17231: PPUSH
17232: LD_STRING D3W-JMM-1
17234: PPUSH
17235: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17239: LD_EXP 41
17243: PUSH
17244: LD_EXP 58
17248: IN
17249: PUSH
17250: LD_EXP 41
17254: PPUSH
17255: CALL_OW 255
17259: PUSH
17260: LD_INT 1
17262: EQUAL
17263: AND
17264: IFFALSE 17280
// Say ( Lisa , D3nW-Lisa-1 ) else
17266: LD_EXP 41
17270: PPUSH
17271: LD_STRING D3nW-Lisa-1
17273: PPUSH
17274: CALL_OW 88
17278: GO 17524
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17280: LD_EXP 44
17284: PUSH
17285: LD_EXP 58
17289: IN
17290: PUSH
17291: LD_EXP 44
17295: PPUSH
17296: CALL_OW 255
17300: PUSH
17301: LD_INT 1
17303: EQUAL
17304: AND
17305: IFFALSE 17321
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17307: LD_EXP 44
17311: PPUSH
17312: LD_STRING D3nW-Cyrus-1
17314: PPUSH
17315: CALL_OW 88
17319: GO 17524
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17321: LD_EXP 43
17325: PUSH
17326: LD_EXP 58
17330: IN
17331: PUSH
17332: LD_EXP 43
17336: PPUSH
17337: CALL_OW 255
17341: PUSH
17342: LD_INT 1
17344: EQUAL
17345: AND
17346: IFFALSE 17362
// Say ( Bobby , D3nW-Bobby-1 ) else
17348: LD_EXP 43
17352: PPUSH
17353: LD_STRING D3nW-Bobby-1
17355: PPUSH
17356: CALL_OW 88
17360: GO 17524
// if Gary in vip and GetSide ( Gary ) = 1 then
17362: LD_EXP 50
17366: PUSH
17367: LD_EXP 58
17371: IN
17372: PUSH
17373: LD_EXP 50
17377: PPUSH
17378: CALL_OW 255
17382: PUSH
17383: LD_INT 1
17385: EQUAL
17386: AND
17387: IFFALSE 17403
// Say ( Gary , D3nW-Gary-1 ) else
17389: LD_EXP 50
17393: PPUSH
17394: LD_STRING D3nW-Gary-1
17396: PPUSH
17397: CALL_OW 88
17401: GO 17524
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17403: LD_EXP 42
17407: PUSH
17408: LD_EXP 58
17412: IN
17413: PUSH
17414: LD_EXP 42
17418: PPUSH
17419: CALL_OW 255
17423: PUSH
17424: LD_INT 1
17426: EQUAL
17427: AND
17428: IFFALSE 17444
// Say ( Donaldson , D3nW-Don-1 ) else
17430: LD_EXP 42
17434: PPUSH
17435: LD_STRING D3nW-Don-1
17437: PPUSH
17438: CALL_OW 88
17442: GO 17524
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17444: LD_EXP 49
17448: PUSH
17449: LD_EXP 58
17453: IN
17454: PUSH
17455: LD_EXP 49
17459: PPUSH
17460: CALL_OW 255
17464: PUSH
17465: LD_INT 1
17467: EQUAL
17468: AND
17469: IFFALSE 17485
// Say ( Cornel , D3nW-Corn-1 ) else
17471: LD_EXP 49
17475: PPUSH
17476: LD_STRING D3nW-Corn-1
17478: PPUSH
17479: CALL_OW 88
17483: GO 17524
// if Frank in vip and GetSide ( Frank ) = 1 then
17485: LD_EXP 51
17489: PUSH
17490: LD_EXP 58
17494: IN
17495: PUSH
17496: LD_EXP 51
17500: PPUSH
17501: CALL_OW 255
17505: PUSH
17506: LD_INT 1
17508: EQUAL
17509: AND
17510: IFFALSE 17524
// Say ( Frank , D3nW-Frank-1 ) ;
17512: LD_EXP 51
17516: PPUSH
17517: LD_STRING D3nW-Frank-1
17519: PPUSH
17520: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17524: LD_EXP 58
17528: PPUSH
17529: LD_INT 22
17531: PUSH
17532: LD_INT 1
17534: PUSH
17535: EMPTY
17536: LIST
17537: LIST
17538: PPUSH
17539: CALL_OW 72
17543: IFFALSE 17569
// begin Say ( JMM , D3nW-JMM-1 ) ;
17545: LD_EXP 38
17549: PPUSH
17550: LD_STRING D3nW-JMM-1
17552: PPUSH
17553: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17557: LD_EXP 38
17561: PPUSH
17562: LD_STRING D3nW-JMM-1a
17564: PPUSH
17565: CALL_OW 88
// end ; t := 0 0$00 ;
17569: LD_ADDR_VAR 0 3
17573: PUSH
17574: LD_INT 0
17576: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17577: LD_INT 35
17579: PPUSH
17580: CALL_OW 67
// t := t + 0 0$1 ;
17584: LD_ADDR_VAR 0 3
17588: PUSH
17589: LD_VAR 0 3
17593: PUSH
17594: LD_INT 35
17596: PLUS
17597: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17598: LD_INT 59
17600: PPUSH
17601: LD_INT 112
17603: PPUSH
17604: CALL_OW 428
17608: PUSH
17609: LD_VAR 0 3
17613: PUSH
17614: LD_INT 2100
17616: GREATER
17617: OR
17618: IFFALSE 17577
// activeAttacks := true ;
17620: LD_ADDR_EXP 16
17624: PUSH
17625: LD_INT 1
17627: ST_TO_ADDR
// end ;
17628: LD_VAR 0 1
17632: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17633: LD_INT 0
17635: PPUSH
// case question of 1 :
17636: LD_VAR 0 1
17640: PUSH
17641: LD_INT 1
17643: DOUBLE
17644: EQUAL
17645: IFTRUE 17649
17647: GO 17700
17649: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17650: LD_EXP 38
17654: PPUSH
17655: LD_STRING D2Mot-JMM-1
17657: PPUSH
17658: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17662: LD_EXP 57
17666: PPUSH
17667: LD_STRING D2Mot-Pow-1
17669: PPUSH
17670: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17674: LD_EXP 38
17678: PPUSH
17679: LD_STRING D2Mot-JMM-2
17681: PPUSH
17682: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17686: LD_EXP 57
17690: PPUSH
17691: LD_STRING D2Mot-Pow-2
17693: PPUSH
17694: CALL_OW 88
// end ; 2 :
17698: GO 18051
17700: LD_INT 2
17702: DOUBLE
17703: EQUAL
17704: IFTRUE 17708
17706: GO 17784
17708: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17709: LD_EXP 38
17713: PPUSH
17714: LD_STRING D2Rus-JMM-1
17716: PPUSH
17717: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17721: LD_EXP 57
17725: PPUSH
17726: LD_STRING D2Rus-Pow-1
17728: PPUSH
17729: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17733: LD_EXP 38
17737: PPUSH
17738: LD_STRING D2Rus-JMM-2
17740: PPUSH
17741: CALL_OW 88
// if not ( 3 in list_of_q ) then
17745: LD_INT 3
17747: PUSH
17748: LD_VAR 0 2
17752: IN
17753: NOT
17754: IFFALSE 17770
// Say ( Powell , D2Rus-Pow-2 ) else
17756: LD_EXP 57
17760: PPUSH
17761: LD_STRING D2Rus-Pow-2
17763: PPUSH
17764: CALL_OW 88
17768: GO 17782
// Say ( Powell , D2Rus-Pow-2a ) ;
17770: LD_EXP 57
17774: PPUSH
17775: LD_STRING D2Rus-Pow-2a
17777: PPUSH
17778: CALL_OW 88
// end ; 3 :
17782: GO 18051
17784: LD_INT 3
17786: DOUBLE
17787: EQUAL
17788: IFTRUE 17792
17790: GO 17877
17792: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17793: LD_EXP 38
17797: PPUSH
17798: LD_STRING D2Leg-JMM-1
17800: PPUSH
17801: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17805: LD_EXP 57
17809: PPUSH
17810: LD_STRING D2Leg-Pow-1
17812: PPUSH
17813: CALL_OW 88
// if 2 in list_of_q then
17817: LD_INT 2
17819: PUSH
17820: LD_VAR 0 2
17824: IN
17825: IFFALSE 17851
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17827: LD_EXP 38
17831: PPUSH
17832: LD_STRING D2Leg-JMM-2
17834: PPUSH
17835: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17839: LD_EXP 57
17843: PPUSH
17844: LD_STRING D2Leg-Pow-2
17846: PPUSH
17847: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17851: LD_EXP 38
17855: PPUSH
17856: LD_STRING D2Leg-JMM-3
17858: PPUSH
17859: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17863: LD_EXP 57
17867: PPUSH
17868: LD_STRING D2Leg-Pow-3
17870: PPUSH
17871: CALL_OW 88
// end ; 4 :
17875: GO 18051
17877: LD_INT 4
17879: DOUBLE
17880: EQUAL
17881: IFTRUE 17885
17883: GO 17960
17885: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17886: LD_EXP 38
17890: PPUSH
17891: LD_STRING D2Ar-JMM-1
17893: PPUSH
17894: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17898: LD_EXP 57
17902: PPUSH
17903: LD_STRING D2Ar-Pow-1
17905: PPUSH
17906: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17910: LD_EXP 38
17914: PPUSH
17915: LD_STRING D2Ar-JMM-2
17917: PPUSH
17918: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17922: LD_EXP 57
17926: PPUSH
17927: LD_STRING D2Ar-Pow-2
17929: PPUSH
17930: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17934: LD_EXP 38
17938: PPUSH
17939: LD_STRING D2Ar-JMM-3
17941: PPUSH
17942: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17946: LD_EXP 57
17950: PPUSH
17951: LD_STRING D2Ar-Pow-3
17953: PPUSH
17954: CALL_OW 88
// end ; 5 :
17958: GO 18051
17960: LD_INT 5
17962: DOUBLE
17963: EQUAL
17964: IFTRUE 17968
17966: GO 17983
17968: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17969: LD_EXP 38
17973: PPUSH
17974: LD_STRING D2Conf-JMM-1
17976: PPUSH
17977: CALL_OW 88
17981: GO 18051
17983: LD_INT 6
17985: DOUBLE
17986: EQUAL
17987: IFTRUE 17991
17989: GO 18050
17991: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17992: LD_EXP 38
17996: PPUSH
17997: LD_STRING D2Com-JMM-1
17999: PPUSH
18000: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18004: LD_EXP 57
18008: PPUSH
18009: LD_STRING D2Com-Pow-1
18011: PPUSH
18012: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18016: LD_EXP 38
18020: PPUSH
18021: LD_STRING D2Com-JMM-2
18023: PPUSH
18024: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18028: LD_EXP 57
18032: PPUSH
18033: LD_STRING D2Com-Pow-2
18035: PPUSH
18036: CALL_OW 88
// powellAngerQuery := true ;
18040: LD_ADDR_EXP 36
18044: PUSH
18045: LD_INT 1
18047: ST_TO_ADDR
// end ; end ;
18048: GO 18051
18050: POP
// end ;
18051: LD_VAR 0 3
18055: RET
// every 0 0$5 trigger missionStart do var tmp ;
18056: LD_EXP 13
18060: IFFALSE 18343
18062: GO 18064
18064: DISABLE
18065: LD_INT 0
18067: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18068: LD_INT 35
18070: PPUSH
18071: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18075: LD_INT 14
18077: PPUSH
18078: LD_INT 22
18080: PUSH
18081: LD_INT 1
18083: PUSH
18084: EMPTY
18085: LIST
18086: LIST
18087: PPUSH
18088: CALL_OW 70
18092: PUSH
18093: LD_EXP 15
18097: PUSH
18098: LD_INT 2
18100: PUSH
18101: LD_INT 3
18103: PUSH
18104: LD_INT 4
18106: PUSH
18107: LD_INT 5
18109: PUSH
18110: EMPTY
18111: LIST
18112: LIST
18113: LIST
18114: LIST
18115: IN
18116: AND
18117: IFFALSE 18333
// begin powellAnger := powellAnger + 1 ;
18119: LD_ADDR_EXP 17
18123: PUSH
18124: LD_EXP 17
18128: PUSH
18129: LD_INT 1
18131: PLUS
18132: ST_TO_ADDR
// Video ( true ) ;
18133: LD_INT 1
18135: PPUSH
18136: CALL 107108 0 1
// CenterNowOnUnits ( tmp ) ;
18140: LD_VAR 0 1
18144: PPUSH
18145: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18149: LD_INT 14
18151: PPUSH
18152: LD_INT 22
18154: PUSH
18155: LD_INT 1
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: PPUSH
18162: CALL_OW 70
18166: PPUSH
18167: LD_INT 86
18169: PPUSH
18170: LD_INT 133
18172: PPUSH
18173: CALL_OW 111
// async ;
18177: ASYNC
// case powellAnger of 1 :
18178: LD_EXP 17
18182: PUSH
18183: LD_INT 1
18185: DOUBLE
18186: EQUAL
18187: IFTRUE 18191
18189: GO 18206
18191: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18192: LD_EXP 57
18196: PPUSH
18197: LD_STRING DBack1-Pow-1
18199: PPUSH
18200: CALL_OW 88
18204: GO 18253
18206: LD_INT 2
18208: DOUBLE
18209: EQUAL
18210: IFTRUE 18214
18212: GO 18229
18214: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18215: LD_EXP 57
18219: PPUSH
18220: LD_STRING DBack2-Pow-1
18222: PPUSH
18223: CALL_OW 88
18227: GO 18253
18229: LD_INT 3
18231: DOUBLE
18232: EQUAL
18233: IFTRUE 18237
18235: GO 18252
18237: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18238: LD_EXP 57
18242: PPUSH
18243: LD_STRING DBack3-Pow-1
18245: PPUSH
18246: CALL_OW 88
18250: GO 18253
18252: POP
// sync ;
18253: SYNC
// repeat wait ( 0 0$1 ) ;
18254: LD_INT 35
18256: PPUSH
18257: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18261: LD_INT 14
18263: PPUSH
18264: LD_INT 22
18266: PUSH
18267: LD_INT 1
18269: PUSH
18270: EMPTY
18271: LIST
18272: LIST
18273: PPUSH
18274: CALL_OW 70
18278: PPUSH
18279: LD_INT 86
18281: PPUSH
18282: LD_INT 133
18284: PPUSH
18285: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18289: LD_INT 14
18291: PPUSH
18292: LD_INT 22
18294: PUSH
18295: LD_INT 1
18297: PUSH
18298: EMPTY
18299: LIST
18300: LIST
18301: PPUSH
18302: CALL_OW 70
18306: NOT
18307: IFFALSE 18254
// if powellAnger >= 3 then
18309: LD_EXP 17
18313: PUSH
18314: LD_INT 3
18316: GREATEREQUAL
18317: IFFALSE 18326
// YouLost ( Dismissed ) ;
18319: LD_STRING Dismissed
18321: PPUSH
18322: CALL_OW 104
// Video ( false ) ;
18326: LD_INT 0
18328: PPUSH
18329: CALL 107108 0 1
// end ; until missionStage > 5 ;
18333: LD_EXP 15
18337: PUSH
18338: LD_INT 5
18340: GREATER
18341: IFFALSE 18068
// end ;
18343: PPOPN 1
18345: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18346: LD_EXP 13
18350: PUSH
18351: LD_INT 22
18353: PUSH
18354: LD_INT 4
18356: PUSH
18357: EMPTY
18358: LIST
18359: LIST
18360: PUSH
18361: LD_INT 21
18363: PUSH
18364: LD_INT 2
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PPUSH
18375: CALL_OW 69
18379: PUSH
18380: LD_INT 4
18382: GREATEREQUAL
18383: AND
18384: PUSH
18385: LD_EXP 15
18389: PUSH
18390: LD_INT 2
18392: EQUAL
18393: AND
18394: IFFALSE 20217
18396: GO 18398
18398: DISABLE
18399: LD_INT 0
18401: PPUSH
18402: PPUSH
18403: PPUSH
18404: PPUSH
18405: PPUSH
18406: PPUSH
18407: PPUSH
18408: PPUSH
// begin missionStage := 3 ;
18409: LD_ADDR_EXP 15
18413: PUSH
18414: LD_INT 3
18416: ST_TO_ADDR
// retreat := false ;
18417: LD_ADDR_VAR 0 4
18421: PUSH
18422: LD_INT 0
18424: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18425: LD_ADDR_VAR 0 5
18429: PUSH
18430: LD_INT 22
18432: PUSH
18433: LD_INT 4
18435: PUSH
18436: EMPTY
18437: LIST
18438: LIST
18439: PUSH
18440: LD_INT 30
18442: PUSH
18443: LD_INT 4
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: PUSH
18450: EMPTY
18451: LIST
18452: LIST
18453: PPUSH
18454: CALL_OW 69
18458: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18459: LD_ADDR_VAR 0 6
18463: PUSH
18464: LD_INT 22
18466: PUSH
18467: LD_INT 4
18469: PUSH
18470: EMPTY
18471: LIST
18472: LIST
18473: PUSH
18474: LD_INT 30
18476: PUSH
18477: LD_INT 5
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: PUSH
18484: EMPTY
18485: LIST
18486: LIST
18487: PPUSH
18488: CALL_OW 69
18492: ST_TO_ADDR
// if not bar then
18493: LD_VAR 0 6
18497: NOT
18498: IFFALSE 18551
// begin repeat wait ( 0 0$1 ) ;
18500: LD_INT 35
18502: PPUSH
18503: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18507: LD_INT 22
18509: PUSH
18510: LD_INT 4
18512: PUSH
18513: EMPTY
18514: LIST
18515: LIST
18516: PUSH
18517: LD_INT 3
18519: PUSH
18520: LD_INT 57
18522: PUSH
18523: EMPTY
18524: LIST
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PUSH
18530: LD_INT 30
18532: PUSH
18533: LD_INT 5
18535: PUSH
18536: EMPTY
18537: LIST
18538: LIST
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: LIST
18544: PPUSH
18545: CALL_OW 69
18549: IFFALSE 18500
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18551: LD_ADDR_VAR 0 6
18555: PUSH
18556: LD_INT 22
18558: PUSH
18559: LD_INT 4
18561: PUSH
18562: EMPTY
18563: LIST
18564: LIST
18565: PUSH
18566: LD_INT 30
18568: PUSH
18569: LD_INT 5
18571: PUSH
18572: EMPTY
18573: LIST
18574: LIST
18575: PUSH
18576: EMPTY
18577: LIST
18578: LIST
18579: PPUSH
18580: CALL_OW 69
18584: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18585: LD_INT 35
18587: PPUSH
18588: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18592: LD_EXP 120
18596: PUSH
18597: LD_INT 4
18599: ARRAY
18600: PUSH
18601: LD_INT 4
18603: GREATEREQUAL
18604: IFFALSE 18585
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18606: LD_ADDR_VAR 0 2
18610: PUSH
18611: LD_INT 22
18613: PUSH
18614: LD_INT 4
18616: PUSH
18617: EMPTY
18618: LIST
18619: LIST
18620: PUSH
18621: LD_INT 2
18623: PUSH
18624: LD_INT 25
18626: PUSH
18627: LD_INT 1
18629: PUSH
18630: EMPTY
18631: LIST
18632: LIST
18633: PUSH
18634: LD_INT 25
18636: PUSH
18637: LD_INT 2
18639: PUSH
18640: EMPTY
18641: LIST
18642: LIST
18643: PUSH
18644: LD_INT 25
18646: PUSH
18647: LD_INT 3
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: PUSH
18654: LD_INT 25
18656: PUSH
18657: LD_INT 4
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: PUSH
18664: LD_INT 25
18666: PUSH
18667: LD_INT 5
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: LIST
18678: LIST
18679: LIST
18680: LIST
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: PPUSH
18686: CALL_OW 69
18690: PUSH
18691: LD_EXP 57
18695: PUSH
18696: LD_EXP 58
18700: ADD
18701: DIFF
18702: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18703: LD_ADDR_VAR 0 3
18707: PUSH
18708: LD_VAR 0 2
18712: PPUSH
18713: LD_INT 26
18715: PUSH
18716: LD_INT 1
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PPUSH
18723: CALL_OW 72
18727: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18728: LD_ADDR_VAR 0 2
18732: PUSH
18733: LD_VAR 0 2
18737: PUSH
18738: LD_VAR 0 3
18742: DIFF
18743: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18744: LD_ADDR_VAR 0 2
18748: PUSH
18749: LD_VAR 0 2
18753: PPUSH
18754: LD_INT 1
18756: PPUSH
18757: CALL 105761 0 2
18761: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18762: LD_ADDR_VAR 0 3
18766: PUSH
18767: LD_VAR 0 3
18771: PPUSH
18772: LD_INT 1
18774: PPUSH
18775: CALL 105761 0 2
18779: ST_TO_ADDR
// for i = 1 to 4 do
18780: LD_ADDR_VAR 0 1
18784: PUSH
18785: DOUBLE
18786: LD_INT 1
18788: DEC
18789: ST_TO_ADDR
18790: LD_INT 4
18792: PUSH
18793: FOR_TO
18794: IFFALSE 18960
// begin if tmp2 then
18796: LD_VAR 0 3
18800: IFFALSE 18881
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18802: LD_ADDR_EXP 18
18806: PUSH
18807: LD_EXP 18
18811: PPUSH
18812: LD_INT 1
18814: PPUSH
18815: LD_EXP 18
18819: PUSH
18820: LD_INT 1
18822: ARRAY
18823: PUSH
18824: LD_VAR 0 3
18828: PUSH
18829: LD_VAR 0 3
18833: ARRAY
18834: ADD
18835: PPUSH
18836: CALL_OW 1
18840: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18841: LD_VAR 0 3
18845: PUSH
18846: LD_VAR 0 3
18850: ARRAY
18851: PPUSH
18852: LD_INT 1
18854: PPUSH
18855: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18859: LD_ADDR_VAR 0 3
18863: PUSH
18864: LD_VAR 0 3
18868: PPUSH
18869: LD_VAR 0 3
18873: PPUSH
18874: CALL_OW 3
18878: ST_TO_ADDR
// end else
18879: GO 18958
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18881: LD_ADDR_EXP 18
18885: PUSH
18886: LD_EXP 18
18890: PPUSH
18891: LD_INT 1
18893: PPUSH
18894: LD_EXP 18
18898: PUSH
18899: LD_INT 1
18901: ARRAY
18902: PUSH
18903: LD_VAR 0 2
18907: PUSH
18908: LD_VAR 0 2
18912: ARRAY
18913: ADD
18914: PPUSH
18915: CALL_OW 1
18919: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18920: LD_VAR 0 2
18924: PUSH
18925: LD_VAR 0 2
18929: ARRAY
18930: PPUSH
18931: LD_INT 1
18933: PPUSH
18934: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18938: LD_ADDR_VAR 0 2
18942: PUSH
18943: LD_VAR 0 2
18947: PPUSH
18948: LD_VAR 0 2
18952: PPUSH
18953: CALL_OW 3
18957: ST_TO_ADDR
// end ; end ;
18958: GO 18793
18960: POP
18961: POP
// if tmp2 then
18962: LD_VAR 0 3
18966: IFFALSE 18984
// tmp := tmp union tmp2 ;
18968: LD_ADDR_VAR 0 2
18972: PUSH
18973: LD_VAR 0 2
18977: PUSH
18978: LD_VAR 0 3
18982: UNION
18983: ST_TO_ADDR
// for i = 1 to 4 do
18984: LD_ADDR_VAR 0 1
18988: PUSH
18989: DOUBLE
18990: LD_INT 1
18992: DEC
18993: ST_TO_ADDR
18994: LD_INT 4
18996: PUSH
18997: FOR_TO
18998: IFFALSE 19047
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19000: LD_ADDR_EXP 18
19004: PUSH
19005: LD_EXP 18
19009: PPUSH
19010: LD_INT 2
19012: PPUSH
19013: LD_EXP 18
19017: PUSH
19018: LD_INT 2
19020: ARRAY
19021: PUSH
19022: LD_VAR 0 2
19026: PUSH
19027: LD_VAR 0 2
19031: PUSH
19032: LD_VAR 0 1
19036: MINUS
19037: ARRAY
19038: ADD
19039: PPUSH
19040: CALL_OW 1
19044: ST_TO_ADDR
19045: GO 18997
19047: POP
19048: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19049: LD_ADDR_EXP 101
19053: PUSH
19054: LD_EXP 101
19058: PPUSH
19059: LD_INT 4
19061: PPUSH
19062: LD_EXP 101
19066: PUSH
19067: LD_INT 4
19069: ARRAY
19070: PUSH
19071: LD_EXP 18
19075: PUSH
19076: LD_INT 1
19078: ARRAY
19079: DIFF
19080: PPUSH
19081: CALL_OW 1
19085: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19086: LD_VAR 0 5
19090: PUSH
19091: LD_INT 1
19093: ARRAY
19094: PPUSH
19095: CALL_OW 313
19099: IFFALSE 19154
// begin for i in UnitsInside ( arm [ 1 ] ) do
19101: LD_ADDR_VAR 0 1
19105: PUSH
19106: LD_VAR 0 5
19110: PUSH
19111: LD_INT 1
19113: ARRAY
19114: PPUSH
19115: CALL_OW 313
19119: PUSH
19120: FOR_IN
19121: IFFALSE 19152
// begin ComExitBuilding ( i ) ;
19123: LD_VAR 0 1
19127: PPUSH
19128: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19132: LD_VAR 0 1
19136: PPUSH
19137: LD_VAR 0 6
19141: PUSH
19142: LD_INT 1
19144: ARRAY
19145: PPUSH
19146: CALL_OW 180
// end ;
19150: GO 19120
19152: POP
19153: POP
// end ; wait ( 0 0$3 ) ;
19154: LD_INT 105
19156: PPUSH
19157: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19161: LD_ADDR_VAR 0 1
19165: PUSH
19166: LD_EXP 18
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: PUSH
19175: FOR_IN
19176: IFFALSE 19283
// begin if IsInUnit ( i ) then
19178: LD_VAR 0 1
19182: PPUSH
19183: CALL_OW 310
19187: IFFALSE 19198
// ComExitBuilding ( i ) ;
19189: LD_VAR 0 1
19193: PPUSH
19194: CALL_OW 122
// if GetClass ( i ) <> 1 then
19198: LD_VAR 0 1
19202: PPUSH
19203: CALL_OW 257
19207: PUSH
19208: LD_INT 1
19210: NONEQUAL
19211: IFFALSE 19252
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19213: LD_VAR 0 1
19217: PPUSH
19218: LD_VAR 0 5
19222: PUSH
19223: LD_INT 1
19225: ARRAY
19226: PPUSH
19227: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19231: LD_VAR 0 1
19235: PPUSH
19236: LD_INT 1
19238: PPUSH
19239: CALL_OW 183
// AddComExitBuilding ( i ) ;
19243: LD_VAR 0 1
19247: PPUSH
19248: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19252: LD_VAR 0 1
19256: PPUSH
19257: LD_INT 60
19259: PPUSH
19260: LD_INT 94
19262: PPUSH
19263: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19267: LD_VAR 0 1
19271: PPUSH
19272: LD_EXP 57
19276: PPUSH
19277: CALL_OW 179
// end ;
19281: GO 19175
19283: POP
19284: POP
// wait ( 0 0$15 ) ;
19285: LD_INT 525
19287: PPUSH
19288: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19292: LD_EXP 57
19296: PPUSH
19297: LD_STRING D4-Pow-1
19299: PPUSH
19300: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19304: LD_ADDR_VAR 0 2
19308: PUSH
19309: LD_EXP 18
19313: PUSH
19314: LD_INT 1
19316: ARRAY
19317: PPUSH
19318: LD_INT 26
19320: PUSH
19321: LD_INT 1
19323: PUSH
19324: EMPTY
19325: LIST
19326: LIST
19327: PPUSH
19328: CALL_OW 72
19332: ST_TO_ADDR
// if tmp then
19333: LD_VAR 0 2
19337: IFFALSE 19355
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19339: LD_VAR 0 2
19343: PUSH
19344: LD_INT 1
19346: ARRAY
19347: PPUSH
19348: LD_STRING D4-Sol1-1
19350: PPUSH
19351: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19355: LD_EXP 57
19359: PPUSH
19360: LD_STRING D4-Pow-2
19362: PPUSH
19363: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19367: LD_ADDR_VAR 0 1
19371: PUSH
19372: DOUBLE
19373: LD_INT 1
19375: DEC
19376: ST_TO_ADDR
19377: LD_EXP 18
19381: PUSH
19382: LD_INT 1
19384: ARRAY
19385: PUSH
19386: FOR_TO
19387: IFFALSE 19480
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19389: LD_EXP 18
19393: PUSH
19394: LD_INT 1
19396: ARRAY
19397: PUSH
19398: LD_VAR 0 1
19402: ARRAY
19403: PPUSH
19404: LD_EXP 120
19408: PUSH
19409: LD_INT 4
19411: ARRAY
19412: PUSH
19413: LD_INT 1
19415: ARRAY
19416: PPUSH
19417: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19421: LD_ADDR_EXP 120
19425: PUSH
19426: LD_EXP 120
19430: PPUSH
19431: LD_INT 4
19433: PPUSH
19434: LD_EXP 120
19438: PUSH
19439: LD_INT 4
19441: ARRAY
19442: PPUSH
19443: LD_INT 1
19445: PPUSH
19446: CALL_OW 3
19450: PPUSH
19451: CALL_OW 1
19455: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19456: LD_INT 8
19458: PPUSH
19459: LD_EXP 18
19463: PUSH
19464: LD_INT 1
19466: ARRAY
19467: PUSH
19468: LD_VAR 0 1
19472: ARRAY
19473: PPUSH
19474: CALL_OW 471
// end ;
19478: GO 19386
19480: POP
19481: POP
// repeat wait ( 0 0$1 ) ;
19482: LD_INT 35
19484: PPUSH
19485: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19489: LD_EXP 18
19493: PUSH
19494: LD_INT 1
19496: ARRAY
19497: PPUSH
19498: LD_INT 55
19500: PUSH
19501: EMPTY
19502: LIST
19503: PPUSH
19504: CALL_OW 72
19508: PUSH
19509: LD_INT 4
19511: GREATEREQUAL
19512: IFFALSE 19482
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19514: LD_EXP 18
19518: PUSH
19519: LD_INT 1
19521: ARRAY
19522: PPUSH
19523: LD_INT 69
19525: PPUSH
19526: LD_INT 94
19528: PPUSH
19529: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19533: LD_EXP 18
19537: PUSH
19538: LD_INT 1
19540: ARRAY
19541: PPUSH
19542: LD_INT 82
19544: PPUSH
19545: LD_INT 83
19547: PPUSH
19548: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PPUSH
19561: LD_INT 77
19563: PPUSH
19564: LD_INT 69
19566: PPUSH
19567: CALL_OW 174
// repeat wait ( 3 ) ;
19571: LD_INT 3
19573: PPUSH
19574: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19578: LD_ADDR_VAR 0 1
19582: PUSH
19583: LD_EXP 18
19587: PUSH
19588: LD_INT 1
19590: ARRAY
19591: PUSH
19592: FOR_IN
19593: IFFALSE 19729
// begin if GetLives ( i ) < 990 then
19595: LD_VAR 0 1
19599: PPUSH
19600: CALL_OW 256
19604: PUSH
19605: LD_INT 990
19607: LESS
19608: IFFALSE 19622
// SetLives ( i , 1000 ) ;
19610: LD_VAR 0 1
19614: PPUSH
19615: LD_INT 1000
19617: PPUSH
19618: CALL_OW 234
// if not IsInUnit ( i ) then
19622: LD_VAR 0 1
19626: PPUSH
19627: CALL_OW 310
19631: NOT
19632: IFFALSE 19727
// begin if not HasTask ( i ) then
19634: LD_VAR 0 1
19638: PPUSH
19639: CALL_OW 314
19643: NOT
19644: IFFALSE 19661
// ComMoveXY ( i , 64 , 93 ) ;
19646: LD_VAR 0 1
19650: PPUSH
19651: LD_INT 64
19653: PPUSH
19654: LD_INT 93
19656: PPUSH
19657: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19661: LD_VAR 0 4
19665: NOT
19666: PUSH
19667: LD_VAR 0 1
19671: PPUSH
19672: CALL_OW 258
19676: PUSH
19677: LD_INT 1
19679: EQUAL
19680: AND
19681: IFFALSE 19727
// begin retreat := true ;
19683: LD_ADDR_VAR 0 4
19687: PUSH
19688: LD_INT 1
19690: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19691: LD_VAR 0 1
19695: PPUSH
19696: LD_INT 2
19698: PPUSH
19699: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19703: LD_VAR 0 1
19707: PPUSH
19708: LD_STRING D4a-Sol1-1
19710: PPUSH
19711: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19715: LD_EXP 57
19719: PPUSH
19720: LD_STRING D4a-Pow-1
19722: PPUSH
19723: CALL_OW 88
// end ; end ; end ;
19727: GO 19592
19729: POP
19730: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19731: LD_EXP 18
19735: PUSH
19736: LD_INT 1
19738: ARRAY
19739: PPUSH
19740: LD_INT 95
19742: PUSH
19743: LD_INT 9
19745: PUSH
19746: EMPTY
19747: LIST
19748: LIST
19749: PUSH
19750: LD_INT 3
19752: PUSH
19753: LD_INT 55
19755: PUSH
19756: EMPTY
19757: LIST
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: PPUSH
19767: CALL_OW 72
19771: PUSH
19772: LD_INT 4
19774: GREATEREQUAL
19775: IFFALSE 19571
// for i in powellSquadAttack [ 1 ] do
19777: LD_ADDR_VAR 0 1
19781: PUSH
19782: LD_EXP 18
19786: PUSH
19787: LD_INT 1
19789: ARRAY
19790: PUSH
19791: FOR_IN
19792: IFFALSE 19928
// begin if GetTag ( i ) = 2 then
19794: LD_VAR 0 1
19798: PPUSH
19799: CALL_OW 110
19803: PUSH
19804: LD_INT 2
19806: EQUAL
19807: IFFALSE 19869
// begin ComMoveXY ( i , 60 , 94 ) ;
19809: LD_VAR 0 1
19813: PPUSH
19814: LD_INT 60
19816: PPUSH
19817: LD_INT 94
19819: PPUSH
19820: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19824: LD_VAR 0 1
19828: PPUSH
19829: LD_EXP 57
19833: PPUSH
19834: CALL_OW 179
// wait ( 0 0$3 ) ;
19838: LD_INT 105
19840: PPUSH
19841: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19845: LD_VAR 0 1
19849: PPUSH
19850: LD_STRING D4a-Sol1-2
19852: PPUSH
19853: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19857: LD_EXP 57
19861: PPUSH
19862: LD_STRING D4a-Pow-2
19864: PPUSH
19865: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19869: LD_VAR 0 1
19873: PPUSH
19874: LD_INT 0
19876: PPUSH
19877: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19881: LD_ADDR_EXP 101
19885: PUSH
19886: LD_EXP 101
19890: PPUSH
19891: LD_INT 4
19893: PPUSH
19894: LD_EXP 101
19898: PUSH
19899: LD_INT 4
19901: ARRAY
19902: PUSH
19903: LD_VAR 0 1
19907: UNION
19908: PPUSH
19909: CALL_OW 1
19913: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19914: LD_INT 8
19916: PPUSH
19917: LD_VAR 0 1
19921: PPUSH
19922: CALL_OW 472
// end ;
19926: GO 19791
19928: POP
19929: POP
// wait ( 4 4$00 ) ;
19930: LD_INT 8400
19932: PPUSH
19933: CALL_OW 67
// uc_side := 6 ;
19937: LD_ADDR_OWVAR 20
19941: PUSH
19942: LD_INT 6
19944: ST_TO_ADDR
// uc_nation := 3 ;
19945: LD_ADDR_OWVAR 21
19949: PUSH
19950: LD_INT 3
19952: ST_TO_ADDR
// ru := [ ] ;
19953: LD_ADDR_VAR 0 7
19957: PUSH
19958: EMPTY
19959: ST_TO_ADDR
// for i = 1 to 4 do
19960: LD_ADDR_VAR 0 1
19964: PUSH
19965: DOUBLE
19966: LD_INT 1
19968: DEC
19969: ST_TO_ADDR
19970: LD_INT 4
19972: PUSH
19973: FOR_TO
19974: IFFALSE 20075
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19976: LD_INT 22
19978: PPUSH
19979: LD_INT 1
19981: PPUSH
19982: LD_INT 3
19984: PPUSH
19985: LD_INT 43
19987: PUSH
19988: LD_INT 44
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: PUSH
19995: LD_INT 1
19997: PPUSH
19998: LD_INT 2
20000: PPUSH
20001: CALL_OW 12
20005: ARRAY
20006: PPUSH
20007: LD_INT 89
20009: PPUSH
20010: CALL 71388 0 5
// un := CreateVehicle ;
20014: LD_ADDR_VAR 0 8
20018: PUSH
20019: CALL_OW 45
20023: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20024: LD_VAR 0 8
20028: PPUSH
20029: LD_INT 4
20031: PPUSH
20032: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20036: LD_VAR 0 8
20040: PPUSH
20041: LD_INT 136
20043: PPUSH
20044: LD_INT 90
20046: PPUSH
20047: LD_INT 8
20049: PPUSH
20050: LD_INT 0
20052: PPUSH
20053: CALL_OW 50
// ru := ru ^ un ;
20057: LD_ADDR_VAR 0 7
20061: PUSH
20062: LD_VAR 0 7
20066: PUSH
20067: LD_VAR 0 8
20071: ADD
20072: ST_TO_ADDR
// end ;
20073: GO 19973
20075: POP
20076: POP
// if ru then
20077: LD_VAR 0 7
20081: IFFALSE 20098
// ComAgressiveMove ( ru , 80 , 92 ) ;
20083: LD_VAR 0 7
20087: PPUSH
20088: LD_INT 80
20090: PPUSH
20091: LD_INT 92
20093: PPUSH
20094: CALL_OW 114
// wait ( 8 8$00 ) ;
20098: LD_INT 16800
20100: PPUSH
20101: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20105: LD_INT 4
20107: PPUSH
20108: LD_INT 3
20110: PUSH
20111: LD_INT 1
20113: PUSH
20114: LD_INT 1
20116: PUSH
20117: LD_INT 5
20119: PUSH
20120: EMPTY
20121: LIST
20122: LIST
20123: LIST
20124: LIST
20125: PUSH
20126: LD_INT 4
20128: PUSH
20129: LD_INT 1
20131: PUSH
20132: LD_INT 1
20134: PUSH
20135: LD_INT 6
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: LIST
20142: LIST
20143: PUSH
20144: LD_INT 4
20146: PUSH
20147: LD_INT 1
20149: PUSH
20150: LD_INT 1
20152: PUSH
20153: LD_INT 7
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: LIST
20160: LIST
20161: PUSH
20162: LD_INT 3
20164: PUSH
20165: LD_INT 1
20167: PUSH
20168: LD_INT 1
20170: PUSH
20171: LD_INT 7
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: PUSH
20180: LD_INT 3
20182: PUSH
20183: LD_INT 1
20185: PUSH
20186: LD_INT 1
20188: PUSH
20189: LD_INT 5
20191: PUSH
20192: EMPTY
20193: LIST
20194: LIST
20195: LIST
20196: LIST
20197: PUSH
20198: EMPTY
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: PPUSH
20205: CALL 57881 0 2
// missionStage := 4 ;
20209: LD_ADDR_EXP 15
20213: PUSH
20214: LD_INT 4
20216: ST_TO_ADDR
// end ;
20217: PPOPN 8
20219: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20220: LD_EXP 15
20224: PUSH
20225: LD_INT 4
20227: EQUAL
20228: PUSH
20229: LD_INT 22
20231: PUSH
20232: LD_INT 4
20234: PUSH
20235: EMPTY
20236: LIST
20237: LIST
20238: PUSH
20239: LD_INT 21
20241: PUSH
20242: LD_INT 2
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PPUSH
20253: CALL_OW 69
20257: PUSH
20258: LD_INT 5
20260: GREATEREQUAL
20261: AND
20262: IFFALSE 24367
20264: GO 20266
20266: DISABLE
20267: LD_INT 0
20269: PPUSH
20270: PPUSH
20271: PPUSH
20272: PPUSH
20273: PPUSH
20274: PPUSH
20275: PPUSH
20276: PPUSH
20277: PPUSH
20278: PPUSH
20279: PPUSH
20280: PPUSH
20281: PPUSH
// begin missionStage := 5 ;
20282: LD_ADDR_EXP 15
20286: PUSH
20287: LD_INT 5
20289: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20290: LD_ADDR_VAR 0 10
20294: PUSH
20295: LD_INT 22
20297: PUSH
20298: LD_INT 4
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: PUSH
20305: LD_INT 2
20307: PUSH
20308: LD_INT 30
20310: PUSH
20311: LD_INT 4
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 30
20320: PUSH
20321: LD_INT 5
20323: PUSH
20324: EMPTY
20325: LIST
20326: LIST
20327: PUSH
20328: EMPTY
20329: LIST
20330: LIST
20331: LIST
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: PPUSH
20337: CALL_OW 69
20341: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20342: LD_ADDR_VAR 0 6
20346: PUSH
20347: LD_INT 22
20349: PUSH
20350: LD_INT 4
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: PUSH
20357: LD_INT 21
20359: PUSH
20360: LD_INT 1
20362: PUSH
20363: EMPTY
20364: LIST
20365: LIST
20366: PUSH
20367: LD_INT 3
20369: PUSH
20370: LD_INT 25
20372: PUSH
20373: LD_INT 16
20375: PUSH
20376: EMPTY
20377: LIST
20378: LIST
20379: PUSH
20380: EMPTY
20381: LIST
20382: LIST
20383: PUSH
20384: LD_INT 3
20386: PUSH
20387: LD_INT 25
20389: PUSH
20390: LD_INT 12
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: EMPTY
20398: LIST
20399: LIST
20400: PUSH
20401: EMPTY
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: PPUSH
20407: CALL_OW 69
20411: PUSH
20412: LD_EXP 57
20416: DIFF
20417: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20418: LD_ADDR_VAR 0 9
20422: PUSH
20423: LD_INT 22
20425: PUSH
20426: LD_INT 4
20428: PUSH
20429: EMPTY
20430: LIST
20431: LIST
20432: PUSH
20433: LD_INT 30
20435: PUSH
20436: LD_INT 3
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: PUSH
20443: EMPTY
20444: LIST
20445: LIST
20446: PPUSH
20447: CALL_OW 69
20451: PUSH
20452: LD_INT 1
20454: ARRAY
20455: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20456: LD_INT 35
20458: PPUSH
20459: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20463: LD_EXP 120
20467: PUSH
20468: LD_INT 4
20470: ARRAY
20471: PUSH
20472: LD_INT 5
20474: GREATEREQUAL
20475: PUSH
20476: LD_EXP 120
20480: PUSH
20481: LD_INT 4
20483: ARRAY
20484: PPUSH
20485: LD_INT 58
20487: PUSH
20488: EMPTY
20489: LIST
20490: PPUSH
20491: CALL_OW 72
20495: PUSH
20496: LD_INT 5
20498: GREATEREQUAL
20499: AND
20500: IFFALSE 20456
// powellAllowRetreat := false ;
20502: LD_ADDR_EXP 19
20506: PUSH
20507: LD_INT 0
20509: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20510: LD_INT 700
20512: PPUSH
20513: CALL_OW 67
// activeAttacks := false ;
20517: LD_ADDR_EXP 16
20521: PUSH
20522: LD_INT 0
20524: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20525: LD_INT 35
20527: PPUSH
20528: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20532: LD_INT 22
20534: PUSH
20535: LD_INT 6
20537: PUSH
20538: EMPTY
20539: LIST
20540: LIST
20541: PPUSH
20542: CALL_OW 69
20546: PUSH
20547: LD_INT 0
20549: EQUAL
20550: IFFALSE 20525
// tmp := mc_vehicles [ 4 ] ;
20552: LD_ADDR_VAR 0 3
20556: PUSH
20557: LD_EXP 120
20561: PUSH
20562: LD_INT 4
20564: ARRAY
20565: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20566: LD_ADDR_VAR 0 1
20570: PUSH
20571: DOUBLE
20572: LD_INT 1
20574: DEC
20575: ST_TO_ADDR
20576: LD_EXP 18
20580: PUSH
20581: FOR_TO
20582: IFFALSE 20843
// begin for j in powellSquadAttack [ i ] do
20584: LD_ADDR_VAR 0 2
20588: PUSH
20589: LD_EXP 18
20593: PUSH
20594: LD_VAR 0 1
20598: ARRAY
20599: PUSH
20600: FOR_IN
20601: IFFALSE 20839
// begin forces := forces diff j ;
20603: LD_ADDR_VAR 0 6
20607: PUSH
20608: LD_VAR 0 6
20612: PUSH
20613: LD_VAR 0 2
20617: DIFF
20618: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20619: LD_VAR 0 2
20623: PPUSH
20624: LD_INT 1
20626: PPUSH
20627: CALL_OW 109
// wait ( 0 0$2 ) ;
20631: LD_INT 70
20633: PPUSH
20634: CALL_OW 67
// if IsInUnit ( j ) then
20638: LD_VAR 0 2
20642: PPUSH
20643: CALL_OW 310
20647: IFFALSE 20658
// ComExitBuilding ( j ) ;
20649: LD_VAR 0 2
20653: PPUSH
20654: CALL_OW 122
// if GetClass ( j ) <> 1 then
20658: LD_VAR 0 2
20662: PPUSH
20663: CALL_OW 257
20667: PUSH
20668: LD_INT 1
20670: NONEQUAL
20671: IFFALSE 20751
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20673: LD_VAR 0 10
20677: PUSH
20678: LD_INT 1
20680: ARRAY
20681: PPUSH
20682: CALL_OW 313
20686: PUSH
20687: LD_INT 5
20689: GREATEREQUAL
20690: IFFALSE 20712
// AddComEnterUnit ( j , arm [ 2 ] ) else
20692: LD_VAR 0 2
20696: PPUSH
20697: LD_VAR 0 10
20701: PUSH
20702: LD_INT 2
20704: ARRAY
20705: PPUSH
20706: CALL_OW 180
20710: GO 20730
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20712: LD_VAR 0 2
20716: PPUSH
20717: LD_VAR 0 10
20721: PUSH
20722: LD_INT 1
20724: ARRAY
20725: PPUSH
20726: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20730: LD_VAR 0 2
20734: PPUSH
20735: LD_INT 1
20737: PPUSH
20738: CALL_OW 183
// AddComExitBuilding ( j ) ;
20742: LD_VAR 0 2
20746: PPUSH
20747: CALL_OW 182
// end ; if i = 2 then
20751: LD_VAR 0 1
20755: PUSH
20756: LD_INT 2
20758: EQUAL
20759: IFFALSE 20776
// AddComMoveXY ( j , 61 , 93 ) ;
20761: LD_VAR 0 2
20765: PPUSH
20766: LD_INT 61
20768: PPUSH
20769: LD_INT 93
20771: PPUSH
20772: CALL_OW 171
// if i = 1 then
20776: LD_VAR 0 1
20780: PUSH
20781: LD_INT 1
20783: EQUAL
20784: IFFALSE 20837
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20786: LD_VAR 0 2
20790: PPUSH
20791: LD_VAR 0 3
20795: PUSH
20796: LD_INT 1
20798: ARRAY
20799: PPUSH
20800: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20804: LD_ADDR_VAR 0 3
20808: PUSH
20809: LD_VAR 0 3
20813: PPUSH
20814: LD_INT 1
20816: PPUSH
20817: CALL_OW 3
20821: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20822: LD_VAR 0 2
20826: PPUSH
20827: LD_INT 69
20829: PPUSH
20830: LD_INT 94
20832: PPUSH
20833: CALL_OW 171
// end ; end ;
20837: GO 20600
20839: POP
20840: POP
// end ;
20841: GO 20581
20843: POP
20844: POP
// wait ( 0 0$55 ) ;
20845: LD_INT 1925
20847: PPUSH
20848: CALL_OW 67
// MC_Kill ( 4 ) ;
20852: LD_INT 4
20854: PPUSH
20855: CALL 34469 0 1
// tmp := UnitsInside ( fac ) ;
20859: LD_ADDR_VAR 0 3
20863: PUSH
20864: LD_VAR 0 9
20868: PPUSH
20869: CALL_OW 313
20873: ST_TO_ADDR
// if tmp then
20874: LD_VAR 0 3
20878: IFFALSE 20999
// for i in tmp do
20880: LD_ADDR_VAR 0 1
20884: PUSH
20885: LD_VAR 0 3
20889: PUSH
20890: FOR_IN
20891: IFFALSE 20997
// begin ComExitBuilding ( i ) ;
20893: LD_VAR 0 1
20897: PPUSH
20898: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20902: LD_VAR 0 10
20906: PUSH
20907: LD_INT 2
20909: ARRAY
20910: PPUSH
20911: CALL_OW 313
20915: PUSH
20916: LD_INT 6
20918: LESS
20919: IFFALSE 20941
// AddComEnterUnit ( i , arm [ 2 ] ) else
20921: LD_VAR 0 1
20925: PPUSH
20926: LD_VAR 0 10
20930: PUSH
20931: LD_INT 2
20933: ARRAY
20934: PPUSH
20935: CALL_OW 180
20939: GO 20995
// if UnitsInside ( arm [ 1 ] ) < 6 then
20941: LD_VAR 0 10
20945: PUSH
20946: LD_INT 1
20948: ARRAY
20949: PPUSH
20950: CALL_OW 313
20954: PUSH
20955: LD_INT 6
20957: LESS
20958: IFFALSE 20980
// AddComEnterUnit ( i , arm [ 1 ] ) else
20960: LD_VAR 0 1
20964: PPUSH
20965: LD_VAR 0 10
20969: PUSH
20970: LD_INT 1
20972: ARRAY
20973: PPUSH
20974: CALL_OW 180
20978: GO 20995
// AddComMoveXY ( i , 37 , 68 ) ;
20980: LD_VAR 0 1
20984: PPUSH
20985: LD_INT 37
20987: PPUSH
20988: LD_INT 68
20990: PPUSH
20991: CALL_OW 171
// end ;
20995: GO 20890
20997: POP
20998: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20999: LD_ADDR_VAR 0 11
21003: PUSH
21004: LD_VAR 0 6
21008: PPUSH
21009: LD_INT 26
21011: PUSH
21012: LD_INT 1
21014: PUSH
21015: EMPTY
21016: LIST
21017: LIST
21018: PPUSH
21019: CALL_OW 72
21023: PUSH
21024: LD_EXP 58
21028: DIFF
21029: ST_TO_ADDR
// if not speaker then
21030: LD_VAR 0 11
21034: NOT
21035: IFFALSE 21062
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21037: LD_ADDR_VAR 0 11
21041: PUSH
21042: LD_VAR 0 6
21046: PPUSH
21047: LD_INT 26
21049: PUSH
21050: LD_INT 1
21052: PUSH
21053: EMPTY
21054: LIST
21055: LIST
21056: PPUSH
21057: CALL_OW 72
21061: ST_TO_ADDR
// if speaker then
21062: LD_VAR 0 11
21066: IFFALSE 21082
// speaker := speaker [ 1 ] ;
21068: LD_ADDR_VAR 0 11
21072: PUSH
21073: LD_VAR 0 11
21077: PUSH
21078: LD_INT 1
21080: ARRAY
21081: ST_TO_ADDR
// Video ( true ) ;
21082: LD_INT 1
21084: PPUSH
21085: CALL 107108 0 1
// CenterNowOnUnits ( Powell ) ;
21089: LD_EXP 57
21093: PPUSH
21094: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21098: LD_ADDR_VAR 0 3
21102: PUSH
21103: LD_VAR 0 6
21107: PPUSH
21108: LD_INT 3
21110: PUSH
21111: LD_INT 25
21113: PUSH
21114: LD_INT 1
21116: PUSH
21117: EMPTY
21118: LIST
21119: LIST
21120: PUSH
21121: EMPTY
21122: LIST
21123: LIST
21124: PPUSH
21125: CALL_OW 72
21129: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21130: LD_ADDR_VAR 0 12
21134: PUSH
21135: LD_INT 22
21137: PUSH
21138: LD_INT 4
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: PUSH
21145: LD_INT 30
21147: PUSH
21148: LD_INT 32
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: PUSH
21155: LD_INT 58
21157: PUSH
21158: EMPTY
21159: LIST
21160: PUSH
21161: EMPTY
21162: LIST
21163: LIST
21164: LIST
21165: PPUSH
21166: CALL_OW 69
21170: ST_TO_ADDR
// for i = 1 to 6 do
21171: LD_ADDR_VAR 0 1
21175: PUSH
21176: DOUBLE
21177: LD_INT 1
21179: DEC
21180: ST_TO_ADDR
21181: LD_INT 6
21183: PUSH
21184: FOR_TO
21185: IFFALSE 21326
// begin if IsInUnit ( tmp [ i ] ) then
21187: LD_VAR 0 3
21191: PUSH
21192: LD_VAR 0 1
21196: ARRAY
21197: PPUSH
21198: CALL_OW 310
21202: IFFALSE 21219
// ComExitBuilding ( tmp [ i ] ) ;
21204: LD_VAR 0 3
21208: PUSH
21209: LD_VAR 0 1
21213: ARRAY
21214: PPUSH
21215: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21219: LD_VAR 0 3
21223: PUSH
21224: LD_VAR 0 1
21228: ARRAY
21229: PPUSH
21230: LD_VAR 0 10
21234: PUSH
21235: LD_INT 1
21237: ARRAY
21238: PPUSH
21239: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21243: LD_VAR 0 3
21247: PUSH
21248: LD_VAR 0 1
21252: ARRAY
21253: PPUSH
21254: LD_INT 1
21256: PPUSH
21257: CALL_OW 183
// if emp_towers then
21261: LD_VAR 0 12
21265: IFFALSE 21324
// begin AddComExitBuilding ( tmp [ i ] ) ;
21267: LD_VAR 0 3
21271: PUSH
21272: LD_VAR 0 1
21276: ARRAY
21277: PPUSH
21278: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21282: LD_VAR 0 3
21286: PUSH
21287: LD_VAR 0 1
21291: ARRAY
21292: PPUSH
21293: LD_VAR 0 12
21297: PUSH
21298: LD_INT 1
21300: ARRAY
21301: PPUSH
21302: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21306: LD_ADDR_VAR 0 12
21310: PUSH
21311: LD_VAR 0 12
21315: PPUSH
21316: LD_INT 1
21318: PPUSH
21319: CALL_OW 3
21323: ST_TO_ADDR
// end ; end ;
21324: GO 21184
21326: POP
21327: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21328: LD_ADDR_VAR 0 3
21332: PUSH
21333: LD_EXP 18
21337: PUSH
21338: LD_INT 1
21340: ARRAY
21341: PUSH
21342: LD_EXP 18
21346: PUSH
21347: LD_INT 2
21349: ARRAY
21350: ADD
21351: PPUSH
21352: LD_INT 26
21354: PUSH
21355: LD_INT 1
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: PPUSH
21362: CALL_OW 72
21366: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21367: LD_ADDR_VAR 0 1
21371: PUSH
21372: LD_EXP 18
21376: PUSH
21377: LD_INT 2
21379: ARRAY
21380: PUSH
21381: FOR_IN
21382: IFFALSE 21400
// ComTurnUnit ( i , Powell ) ;
21384: LD_VAR 0 1
21388: PPUSH
21389: LD_EXP 57
21393: PPUSH
21394: CALL_OW 119
21398: GO 21381
21400: POP
21401: POP
// Say ( Powell , D5-Pow-1 ) ;
21402: LD_EXP 57
21406: PPUSH
21407: LD_STRING D5-Pow-1
21409: PPUSH
21410: CALL_OW 88
// if tmp then
21414: LD_VAR 0 3
21418: IFFALSE 21436
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21420: LD_VAR 0 3
21424: PUSH
21425: LD_INT 1
21427: ARRAY
21428: PPUSH
21429: LD_STRING D5-Sol2-1
21431: PPUSH
21432: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21436: LD_EXP 57
21440: PPUSH
21441: LD_STRING D5-Pow-2
21443: PPUSH
21444: CALL_OW 88
// if tmp > 1 then
21448: LD_VAR 0 3
21452: PUSH
21453: LD_INT 1
21455: GREATER
21456: IFFALSE 21474
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21458: LD_VAR 0 3
21462: PUSH
21463: LD_INT 2
21465: ARRAY
21466: PPUSH
21467: LD_STRING D5-Sol2-2
21469: PPUSH
21470: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21474: LD_EXP 57
21478: PPUSH
21479: LD_STRING D5-Pow-3
21481: PPUSH
21482: CALL_OW 88
// wait ( 0 0$1 ) ;
21486: LD_INT 35
21488: PPUSH
21489: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21493: LD_ADDR_VAR 0 3
21497: PUSH
21498: LD_EXP 18
21502: PUSH
21503: LD_INT 1
21505: ARRAY
21506: PUSH
21507: LD_EXP 18
21511: PUSH
21512: LD_INT 2
21514: ARRAY
21515: UNION
21516: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21517: LD_VAR 0 3
21521: PPUSH
21522: LD_INT 80
21524: PPUSH
21525: LD_INT 67
21527: PPUSH
21528: CALL_OW 114
// wait ( 0 0$2 ) ;
21532: LD_INT 70
21534: PPUSH
21535: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21539: LD_INT 79
21541: PPUSH
21542: LD_INT 72
21544: PPUSH
21545: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21549: LD_INT 35
21551: PPUSH
21552: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21556: LD_VAR 0 3
21560: PPUSH
21561: LD_INT 3
21563: PUSH
21564: LD_INT 24
21566: PUSH
21567: LD_INT 1000
21569: PUSH
21570: EMPTY
21571: LIST
21572: LIST
21573: PUSH
21574: EMPTY
21575: LIST
21576: LIST
21577: PPUSH
21578: CALL_OW 72
21582: IFFALSE 21549
// Say ( Powell , D5a-Pow-1 ) ;
21584: LD_EXP 57
21588: PPUSH
21589: LD_STRING D5a-Pow-1
21591: PPUSH
21592: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21596: LD_EXP 57
21600: PPUSH
21601: LD_STRING D5a-Pow-1a
21603: PPUSH
21604: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21608: LD_INT 10
21610: PPUSH
21611: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21615: LD_EXP 57
21619: PPUSH
21620: LD_STRING D5a-Pow-1b
21622: PPUSH
21623: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21627: LD_EXP 57
21631: PPUSH
21632: LD_STRING D5a-Pow-1c
21634: PPUSH
21635: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21639: LD_EXP 57
21643: PPUSH
21644: LD_STRING D5a-Pow-1d
21646: PPUSH
21647: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21651: LD_INT 35
21653: PPUSH
21654: CALL_OW 67
// if not HasTask ( tmp ) then
21658: LD_VAR 0 3
21662: PPUSH
21663: CALL_OW 314
21667: NOT
21668: IFFALSE 21685
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21670: LD_VAR 0 3
21674: PPUSH
21675: LD_INT 80
21677: PPUSH
21678: LD_INT 67
21680: PPUSH
21681: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21685: LD_VAR 0 3
21689: PPUSH
21690: LD_INT 24
21692: PUSH
21693: LD_INT 1
21695: PUSH
21696: EMPTY
21697: LIST
21698: LIST
21699: PPUSH
21700: CALL_OW 72
21704: NOT
21705: IFFALSE 21651
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21707: LD_ADDR_VAR 0 3
21711: PUSH
21712: LD_INT 22
21714: PUSH
21715: LD_INT 4
21717: PUSH
21718: EMPTY
21719: LIST
21720: LIST
21721: PUSH
21722: LD_INT 92
21724: PUSH
21725: LD_INT 60
21727: PUSH
21728: LD_INT 93
21730: PUSH
21731: LD_INT 10
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: LIST
21738: LIST
21739: PUSH
21740: LD_INT 3
21742: PUSH
21743: LD_INT 54
21745: PUSH
21746: EMPTY
21747: LIST
21748: PUSH
21749: EMPTY
21750: LIST
21751: LIST
21752: PUSH
21753: EMPTY
21754: LIST
21755: LIST
21756: LIST
21757: PPUSH
21758: CALL_OW 69
21762: PUSH
21763: LD_EXP 57
21767: DIFF
21768: ST_TO_ADDR
// if tmp then
21769: LD_VAR 0 3
21773: IFFALSE 21807
// for i in tmp do
21775: LD_ADDR_VAR 0 1
21779: PUSH
21780: LD_VAR 0 3
21784: PUSH
21785: FOR_IN
21786: IFFALSE 21805
// ComMoveXY ( i , 36 , 67 ) ;
21788: LD_VAR 0 1
21792: PPUSH
21793: LD_INT 36
21795: PPUSH
21796: LD_INT 67
21798: PPUSH
21799: CALL_OW 111
21803: GO 21785
21805: POP
21806: POP
// wait ( 0 0$3 ) ;
21807: LD_INT 105
21809: PPUSH
21810: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21814: LD_VAR 0 11
21818: PPUSH
21819: LD_STRING D6-Sol3-1
21821: PPUSH
21822: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21826: LD_EXP 57
21830: PPUSH
21831: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21835: LD_EXP 57
21839: PPUSH
21840: LD_STRING D6-Pow-1
21842: PPUSH
21843: CALL_OW 88
// tmp := [ ] ;
21847: LD_ADDR_VAR 0 3
21851: PUSH
21852: EMPTY
21853: ST_TO_ADDR
// for i = 1 to 2 do
21854: LD_ADDR_VAR 0 1
21858: PUSH
21859: DOUBLE
21860: LD_INT 1
21862: DEC
21863: ST_TO_ADDR
21864: LD_INT 2
21866: PUSH
21867: FOR_TO
21868: IFFALSE 21982
// begin uc_side := 8 ;
21870: LD_ADDR_OWVAR 20
21874: PUSH
21875: LD_INT 8
21877: ST_TO_ADDR
// uc_nation := 2 ;
21878: LD_ADDR_OWVAR 21
21882: PUSH
21883: LD_INT 2
21885: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21886: LD_INT 14
21888: PPUSH
21889: LD_INT 3
21891: PPUSH
21892: LD_INT 2
21894: PPUSH
21895: LD_INT 29
21897: PPUSH
21898: LD_INT 100
21900: PPUSH
21901: CALL 71388 0 5
// veh := CreateVehicle ;
21905: LD_ADDR_VAR 0 13
21909: PUSH
21910: CALL_OW 45
21914: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21915: LD_VAR 0 13
21919: PPUSH
21920: LD_INT 4
21922: PPUSH
21923: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21927: LD_VAR 0 13
21931: PPUSH
21932: LD_INT 99
21934: PPUSH
21935: LD_INT 83
21937: PPUSH
21938: LD_INT 6
21940: PPUSH
21941: LD_INT 0
21943: PPUSH
21944: CALL_OW 50
// wait ( 3 ) ;
21948: LD_INT 3
21950: PPUSH
21951: CALL_OW 67
// Connect ( veh ) ;
21955: LD_VAR 0 13
21959: PPUSH
21960: CALL 74443 0 1
// tmp := tmp ^ veh ;
21964: LD_ADDR_VAR 0 3
21968: PUSH
21969: LD_VAR 0 3
21973: PUSH
21974: LD_VAR 0 13
21978: ADD
21979: ST_TO_ADDR
// end ;
21980: GO 21867
21982: POP
21983: POP
// wait ( 0 0$1 ) ;
21984: LD_INT 35
21986: PPUSH
21987: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21991: LD_INT 99
21993: PPUSH
21994: LD_INT 83
21996: PPUSH
21997: LD_INT 1
21999: PPUSH
22000: LD_INT 10
22002: PPUSH
22003: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22007: LD_INT 99
22009: PPUSH
22010: LD_INT 83
22012: PPUSH
22013: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22017: LD_VAR 0 11
22021: PPUSH
22022: LD_STRING D6-Sol3-2
22024: PPUSH
22025: CALL_OW 88
// async ;
22029: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22030: LD_EXP 57
22034: PPUSH
22035: LD_STRING D6-Pow-2
22037: PPUSH
22038: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22042: LD_VAR 0 3
22046: PUSH
22047: LD_INT 1
22049: ARRAY
22050: PPUSH
22051: LD_VAR 0 9
22055: PPUSH
22056: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22060: LD_VAR 0 3
22064: PUSH
22065: LD_INT 2
22067: ARRAY
22068: PPUSH
22069: LD_INT 22
22071: PUSH
22072: LD_INT 4
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: PUSH
22079: LD_INT 21
22081: PUSH
22082: LD_INT 3
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: PUSH
22089: EMPTY
22090: LIST
22091: LIST
22092: PPUSH
22093: CALL_OW 69
22097: PPUSH
22098: LD_VAR 0 3
22102: PUSH
22103: LD_INT 2
22105: ARRAY
22106: PPUSH
22107: CALL_OW 74
22111: PPUSH
22112: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22116: LD_EXP 57
22120: PPUSH
22121: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22125: LD_INT 99
22127: PPUSH
22128: LD_INT 83
22130: PPUSH
22131: LD_INT 1
22133: PPUSH
22134: CALL_OW 331
// repeat wait ( 4 ) ;
22138: LD_INT 4
22140: PPUSH
22141: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22145: LD_VAR 0 3
22149: PUSH
22150: LD_INT 1
22152: ARRAY
22153: PPUSH
22154: CALL_OW 256
22158: PUSH
22159: LD_INT 1000
22161: LESS
22162: IFFALSE 22180
// SetLives ( tmp [ 1 ] , 1000 ) ;
22164: LD_VAR 0 3
22168: PUSH
22169: LD_INT 1
22171: ARRAY
22172: PPUSH
22173: LD_INT 1000
22175: PPUSH
22176: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22180: LD_INT 22
22182: PUSH
22183: LD_INT 4
22185: PUSH
22186: EMPTY
22187: LIST
22188: LIST
22189: PUSH
22190: LD_INT 30
22192: PUSH
22193: LD_INT 3
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: PUSH
22200: EMPTY
22201: LIST
22202: LIST
22203: PPUSH
22204: CALL_OW 69
22208: PUSH
22209: LD_INT 0
22211: EQUAL
22212: IFFALSE 22138
// sync ;
22214: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22215: LD_EXP 57
22219: PPUSH
22220: LD_STRING D6a-Pow-1
22222: PPUSH
22223: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22227: LD_VAR 0 11
22231: PPUSH
22232: LD_STRING D6a-Sol3-1
22234: PPUSH
22235: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22239: LD_EXP 57
22243: PPUSH
22244: LD_STRING D6a-Pow-2
22246: PPUSH
22247: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22251: LD_VAR 0 11
22255: PPUSH
22256: LD_STRING D6a-Sol3-2
22258: PPUSH
22259: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22263: LD_EXP 57
22267: PPUSH
22268: LD_STRING D6a-Pow-3
22270: PPUSH
22271: CALL_OW 88
// powellCenterCameraMode := true ;
22275: LD_ADDR_EXP 20
22279: PUSH
22280: LD_INT 1
22282: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22283: LD_ADDR_VAR 0 1
22287: PUSH
22288: LD_INT 22
22290: PUSH
22291: LD_INT 8
22293: PUSH
22294: EMPTY
22295: LIST
22296: LIST
22297: PUSH
22298: LD_INT 25
22300: PUSH
22301: LD_INT 2
22303: PUSH
22304: EMPTY
22305: LIST
22306: LIST
22307: PUSH
22308: EMPTY
22309: LIST
22310: LIST
22311: PPUSH
22312: CALL_OW 69
22316: PUSH
22317: FOR_IN
22318: IFFALSE 22373
// begin SetTag ( i , 1 ) ;
22320: LD_VAR 0 1
22324: PPUSH
22325: LD_INT 1
22327: PPUSH
22328: CALL_OW 109
// ComExitBuilding ( i ) ;
22332: LD_VAR 0 1
22336: PPUSH
22337: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22341: LD_VAR 0 1
22345: PPUSH
22346: LD_INT 35
22348: PPUSH
22349: LD_INT 6
22351: PPUSH
22352: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22356: LD_VAR 0 1
22360: PPUSH
22361: LD_INT 53
22363: PPUSH
22364: LD_INT 4
22366: PPUSH
22367: CALL_OW 171
// end ;
22371: GO 22317
22373: POP
22374: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22375: LD_ADDR_VAR 0 3
22379: PUSH
22380: LD_INT 22
22382: PUSH
22383: LD_INT 4
22385: PUSH
22386: EMPTY
22387: LIST
22388: LIST
22389: PUSH
22390: LD_INT 21
22392: PUSH
22393: LD_INT 2
22395: PUSH
22396: EMPTY
22397: LIST
22398: LIST
22399: PUSH
22400: LD_INT 3
22402: PUSH
22403: LD_INT 34
22405: PUSH
22406: LD_INT 12
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: LIST
22421: PPUSH
22422: CALL_OW 69
22426: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22427: LD_EXP 57
22431: PPUSH
22432: LD_VAR 0 3
22436: PPUSH
22437: LD_EXP 57
22441: PPUSH
22442: CALL_OW 74
22446: PPUSH
22447: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22451: LD_EXP 57
22455: PPUSH
22456: LD_INT 100
22458: PPUSH
22459: LD_INT 88
22461: PPUSH
22462: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22466: LD_EXP 57
22470: PPUSH
22471: LD_INT 100
22473: PPUSH
22474: LD_INT 75
22476: PPUSH
22477: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22481: LD_EXP 57
22485: PPUSH
22486: LD_INT 88
22488: PPUSH
22489: LD_INT 53
22491: PPUSH
22492: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22496: LD_INT 8
22498: PPUSH
22499: LD_EXP 57
22503: PPUSH
22504: CALL_OW 471
// repeat wait ( 3 ) ;
22508: LD_INT 3
22510: PPUSH
22511: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22515: LD_INT 22
22517: PUSH
22518: LD_INT 4
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: PUSH
22525: LD_INT 92
22527: PUSH
22528: LD_INT 100
22530: PUSH
22531: LD_INT 75
22533: PUSH
22534: LD_INT 6
22536: PUSH
22537: EMPTY
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: PUSH
22543: EMPTY
22544: LIST
22545: LIST
22546: PPUSH
22547: CALL_OW 69
22551: IFFALSE 22508
// async ;
22553: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22554: LD_EXP 57
22558: PPUSH
22559: LD_STRING D6b-Pow-1
22561: PPUSH
22562: CALL_OW 88
// repeat wait ( 3 ) ;
22566: LD_INT 3
22568: PPUSH
22569: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22573: LD_EXP 57
22577: PPUSH
22578: CALL_OW 310
22582: PPUSH
22583: CALL_OW 256
22587: PUSH
22588: LD_INT 1000
22590: LESS
22591: IFFALSE 22610
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22593: LD_EXP 57
22597: PPUSH
22598: CALL_OW 310
22602: PPUSH
22603: LD_INT 1000
22605: PPUSH
22606: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22610: LD_EXP 57
22614: PPUSH
22615: CALL_OW 256
22619: PUSH
22620: LD_INT 1000
22622: LESS
22623: IFFALSE 22637
// SetLives ( Powell , 1000 ) ;
22625: LD_EXP 57
22629: PPUSH
22630: LD_INT 1000
22632: PPUSH
22633: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22637: LD_EXP 57
22641: PPUSH
22642: LD_EXP 62
22646: PPUSH
22647: CALL_OW 296
22651: PUSH
22652: LD_INT 5
22654: LESS
22655: PUSH
22656: LD_EXP 57
22660: PPUSH
22661: CALL_OW 310
22665: PPUSH
22666: LD_EXP 62
22670: PPUSH
22671: CALL_OW 296
22675: PUSH
22676: LD_INT 5
22678: LESS
22679: OR
22680: IFFALSE 22699
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22682: LD_EXP 57
22686: PPUSH
22687: CALL_OW 310
22691: PPUSH
22692: LD_INT 100
22694: PPUSH
22695: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22699: LD_EXP 57
22703: PPUSH
22704: CALL_OW 310
22708: NOT
22709: IFFALSE 22566
// DoNotAttack ( 8 , powellBomb ) ;
22711: LD_INT 8
22713: PPUSH
22714: LD_EXP 62
22718: PPUSH
22719: CALL_OW 471
// game_speed := 4 ;
22723: LD_ADDR_OWVAR 65
22727: PUSH
22728: LD_INT 4
22730: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22731: LD_EXP 57
22735: PPUSH
22736: LD_STRING D6b-Pow-1a
22738: PPUSH
22739: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22743: LD_EXP 57
22747: PPUSH
22748: LD_EXP 62
22752: PPUSH
22753: CALL_OW 180
// sync ;
22757: SYNC
// repeat wait ( 0 0$1 ) ;
22758: LD_INT 35
22760: PPUSH
22761: CALL_OW 67
// until IsInUnit ( Powell ) ;
22765: LD_EXP 57
22769: PPUSH
22770: CALL_OW 310
22774: IFFALSE 22758
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22776: LD_INT 8
22778: PPUSH
22779: LD_EXP 57
22783: PPUSH
22784: CALL_OW 310
22788: PPUSH
22789: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22793: LD_EXP 57
22797: PPUSH
22798: LD_INT 91
22800: PPUSH
22801: LD_INT 44
22803: PPUSH
22804: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22808: LD_EXP 57
22812: PPUSH
22813: LD_INT 96
22815: PPUSH
22816: LD_INT 44
22818: PPUSH
22819: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22823: LD_EXP 57
22827: PPUSH
22828: LD_INT 96
22830: PPUSH
22831: LD_INT 41
22833: PPUSH
22834: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22838: LD_EXP 57
22842: PPUSH
22843: LD_INT 92
22845: PPUSH
22846: LD_INT 39
22848: PPUSH
22849: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22853: LD_EXP 57
22857: PPUSH
22858: LD_INT 88
22860: PPUSH
22861: LD_INT 41
22863: PPUSH
22864: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22868: LD_EXP 57
22872: PPUSH
22873: LD_INT 91
22875: PPUSH
22876: LD_INT 44
22878: PPUSH
22879: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22883: LD_EXP 57
22887: PPUSH
22888: LD_INT 96
22890: PPUSH
22891: LD_INT 44
22893: PPUSH
22894: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22898: LD_EXP 57
22902: PPUSH
22903: LD_INT 96
22905: PPUSH
22906: LD_INT 41
22908: PPUSH
22909: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22913: LD_EXP 57
22917: PPUSH
22918: LD_INT 92
22920: PPUSH
22921: LD_INT 39
22923: PPUSH
22924: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22928: LD_EXP 57
22932: PPUSH
22933: LD_INT 88
22935: PPUSH
22936: LD_INT 41
22938: PPUSH
22939: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22943: LD_EXP 57
22947: PPUSH
22948: LD_INT 91
22950: PPUSH
22951: LD_INT 44
22953: PPUSH
22954: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22958: LD_EXP 57
22962: PPUSH
22963: LD_INT 93
22965: PPUSH
22966: LD_INT 39
22968: PPUSH
22969: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22973: LD_EXP 57
22977: PPUSH
22978: LD_INT 93
22980: PPUSH
22981: LD_INT 36
22983: PPUSH
22984: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22988: LD_INT 122
22990: PPUSH
22991: CALL_OW 67
// game_speed := 4 ;
22995: LD_ADDR_OWVAR 65
22999: PUSH
23000: LD_INT 4
23002: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23003: LD_EXP 57
23007: PPUSH
23008: LD_STRING D6b-Pow-1b
23010: PPUSH
23011: CALL_OW 88
// tmp := [ ] ;
23015: LD_ADDR_VAR 0 3
23019: PUSH
23020: EMPTY
23021: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23022: LD_ADDR_VAR 0 5
23026: PUSH
23027: LD_INT 78
23029: PUSH
23030: LD_INT 47
23032: PUSH
23033: EMPTY
23034: LIST
23035: LIST
23036: PUSH
23037: LD_INT 106
23039: PUSH
23040: LD_INT 53
23042: PUSH
23043: EMPTY
23044: LIST
23045: LIST
23046: PUSH
23047: EMPTY
23048: LIST
23049: LIST
23050: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23051: LD_ADDR_VAR 0 1
23055: PUSH
23056: LD_INT 22
23058: PUSH
23059: LD_INT 8
23061: PUSH
23062: EMPTY
23063: LIST
23064: LIST
23065: PUSH
23066: LD_INT 21
23068: PUSH
23069: LD_INT 3
23071: PUSH
23072: EMPTY
23073: LIST
23074: LIST
23075: PUSH
23076: LD_INT 92
23078: PUSH
23079: LD_INT 90
23081: PUSH
23082: LD_INT 52
23084: PUSH
23085: LD_INT 12
23087: PUSH
23088: EMPTY
23089: LIST
23090: LIST
23091: LIST
23092: LIST
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: LIST
23098: PPUSH
23099: CALL_OW 69
23103: PUSH
23104: FOR_IN
23105: IFFALSE 23130
// tmp := tmp ^ UnitsInside ( i ) ;
23107: LD_ADDR_VAR 0 3
23111: PUSH
23112: LD_VAR 0 3
23116: PUSH
23117: LD_VAR 0 1
23121: PPUSH
23122: CALL_OW 313
23126: ADD
23127: ST_TO_ADDR
23128: GO 23104
23130: POP
23131: POP
// for i in tmp do
23132: LD_ADDR_VAR 0 1
23136: PUSH
23137: LD_VAR 0 3
23141: PUSH
23142: FOR_IN
23143: IFFALSE 23305
// begin dist := 9999 ;
23145: LD_ADDR_VAR 0 8
23149: PUSH
23150: LD_INT 9999
23152: ST_TO_ADDR
// _xy := [ ] ;
23153: LD_ADDR_VAR 0 7
23157: PUSH
23158: EMPTY
23159: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23160: LD_VAR 0 1
23164: PPUSH
23165: LD_INT 1
23167: PPUSH
23168: CALL_OW 109
// ComExitBuilding ( i ) ;
23172: LD_VAR 0 1
23176: PPUSH
23177: CALL_OW 122
// for j in xy do
23181: LD_ADDR_VAR 0 2
23185: PUSH
23186: LD_VAR 0 5
23190: PUSH
23191: FOR_IN
23192: IFFALSE 23274
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23194: LD_VAR 0 1
23198: PPUSH
23199: LD_VAR 0 2
23203: PUSH
23204: LD_INT 1
23206: ARRAY
23207: PPUSH
23208: LD_VAR 0 2
23212: PUSH
23213: LD_INT 2
23215: ARRAY
23216: PPUSH
23217: CALL_OW 297
23221: PUSH
23222: LD_VAR 0 8
23226: LESS
23227: IFFALSE 23272
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23229: LD_ADDR_VAR 0 8
23233: PUSH
23234: LD_VAR 0 1
23238: PPUSH
23239: LD_VAR 0 2
23243: PUSH
23244: LD_INT 1
23246: ARRAY
23247: PPUSH
23248: LD_VAR 0 2
23252: PUSH
23253: LD_INT 2
23255: ARRAY
23256: PPUSH
23257: CALL_OW 297
23261: ST_TO_ADDR
// _xy := j ;
23262: LD_ADDR_VAR 0 7
23266: PUSH
23267: LD_VAR 0 2
23271: ST_TO_ADDR
// end ;
23272: GO 23191
23274: POP
23275: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23276: LD_VAR 0 1
23280: PPUSH
23281: LD_VAR 0 7
23285: PUSH
23286: LD_INT 1
23288: ARRAY
23289: PPUSH
23290: LD_VAR 0 7
23294: PUSH
23295: LD_INT 2
23297: ARRAY
23298: PPUSH
23299: CALL_OW 171
// end ;
23303: GO 23142
23305: POP
23306: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23307: LD_ADDR_VAR 0 4
23311: PUSH
23312: LD_VAR 0 3
23316: PPUSH
23317: LD_INT 26
23319: PUSH
23320: LD_INT 1
23322: PUSH
23323: EMPTY
23324: LIST
23325: LIST
23326: PUSH
23327: LD_INT 25
23329: PUSH
23330: LD_INT 1
23332: PUSH
23333: EMPTY
23334: LIST
23335: LIST
23336: PUSH
23337: EMPTY
23338: LIST
23339: LIST
23340: PPUSH
23341: CALL_OW 72
23345: ST_TO_ADDR
// if tmp2 < 2 then
23346: LD_VAR 0 4
23350: PUSH
23351: LD_INT 2
23353: LESS
23354: IFFALSE 23423
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23356: LD_ADDR_VAR 0 4
23360: PUSH
23361: LD_INT 22
23363: PUSH
23364: LD_INT 8
23366: PUSH
23367: EMPTY
23368: LIST
23369: LIST
23370: PUSH
23371: LD_INT 26
23373: PUSH
23374: LD_INT 1
23376: PUSH
23377: EMPTY
23378: LIST
23379: LIST
23380: PUSH
23381: LD_INT 3
23383: PUSH
23384: LD_INT 25
23386: PUSH
23387: LD_INT 15
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PUSH
23394: EMPTY
23395: LIST
23396: LIST
23397: PUSH
23398: EMPTY
23399: LIST
23400: LIST
23401: LIST
23402: PPUSH
23403: CALL_OW 69
23407: PUSH
23408: LD_EXP 59
23412: PUSH
23413: LD_EXP 60
23417: PUSH
23418: EMPTY
23419: LIST
23420: LIST
23421: DIFF
23422: ST_TO_ADDR
// if tmp2 then
23423: LD_VAR 0 4
23427: IFFALSE 23445
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23429: LD_VAR 0 4
23433: PUSH
23434: LD_INT 1
23436: ARRAY
23437: PPUSH
23438: LD_STRING D6b-ArSol1-1
23440: PPUSH
23441: CALL_OW 88
// async ;
23445: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23446: LD_EXP 57
23450: PPUSH
23451: LD_STRING D6b-Pow-2
23453: PPUSH
23454: CALL_OW 88
// wait ( 0 0$1 ) ;
23458: LD_INT 35
23460: PPUSH
23461: CALL_OW 67
// if tmp2 > 1 then
23465: LD_VAR 0 4
23469: PUSH
23470: LD_INT 1
23472: GREATER
23473: IFFALSE 23491
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23475: LD_VAR 0 4
23479: PUSH
23480: LD_INT 2
23482: ARRAY
23483: PPUSH
23484: LD_STRING D6b-ArSol2-1
23486: PPUSH
23487: CALL_OW 88
// sync ;
23491: SYNC
// repeat wait ( 5 ) ;
23492: LD_INT 5
23494: PPUSH
23495: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23499: LD_INT 93
23501: PPUSH
23502: LD_INT 36
23504: PPUSH
23505: CALL_OW 428
23509: PPUSH
23510: CALL_OW 255
23514: PUSH
23515: LD_INT 4
23517: EQUAL
23518: IFFALSE 23492
// DialogueOn ;
23520: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23524: LD_INT 10
23526: PPUSH
23527: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23531: LD_EXP 57
23535: PPUSH
23536: LD_STRING D6b-Pow-2a
23538: PPUSH
23539: CALL_OW 88
// DialogueOff ;
23543: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23547: LD_EXP 57
23551: PPUSH
23552: CALL_OW 310
23556: PPUSH
23557: LD_INT 332
23559: PPUSH
23560: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23564: LD_INT 93
23566: PPUSH
23567: LD_INT 35
23569: PPUSH
23570: LD_INT 1
23572: PPUSH
23573: LD_INT 6
23575: NEG
23576: PPUSH
23577: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23581: LD_INT 35
23583: PPUSH
23584: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23588: LD_INT 332
23590: PPUSH
23591: CALL_OW 256
23595: PUSH
23596: LD_INT 1000
23598: LESS
23599: PUSH
23600: LD_INT 332
23602: PPUSH
23603: CALL_OW 300
23607: AND
23608: IFFALSE 23620
// SetLives ( kozlov_fac , 0 ) ;
23610: LD_INT 332
23612: PPUSH
23613: LD_INT 0
23615: PPUSH
23616: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23620: LD_INT 332
23622: PPUSH
23623: CALL_OW 301
23627: PUSH
23628: LD_EXP 57
23632: PPUSH
23633: CALL_OW 301
23637: OR
23638: IFFALSE 23581
// game_speed := 4 ;
23640: LD_ADDR_OWVAR 65
23644: PUSH
23645: LD_INT 4
23647: ST_TO_ADDR
// powellCenterCameraMode := false ;
23648: LD_ADDR_EXP 20
23652: PUSH
23653: LD_INT 0
23655: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23656: LD_ADDR_VAR 0 1
23660: PUSH
23661: LD_VAR 0 3
23665: PUSH
23666: LD_INT 22
23668: PUSH
23669: LD_INT 8
23671: PUSH
23672: EMPTY
23673: LIST
23674: LIST
23675: PUSH
23676: LD_INT 25
23678: PUSH
23679: LD_INT 2
23681: PUSH
23682: EMPTY
23683: LIST
23684: LIST
23685: PUSH
23686: EMPTY
23687: LIST
23688: LIST
23689: PPUSH
23690: CALL_OW 69
23694: UNION
23695: PUSH
23696: FOR_IN
23697: IFFALSE 23713
// SetTag ( i , 0 ) ;
23699: LD_VAR 0 1
23703: PPUSH
23704: LD_INT 0
23706: PPUSH
23707: CALL_OW 109
23711: GO 23696
23713: POP
23714: POP
// wait ( 0 0$3 ) ;
23715: LD_INT 105
23717: PPUSH
23718: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23722: LD_INT 93
23724: PPUSH
23725: LD_INT 35
23727: PPUSH
23728: LD_INT 1
23730: PPUSH
23731: CALL_OW 331
// DialogueOn ;
23735: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23739: LD_VAR 0 11
23743: PPUSH
23744: LD_STRING D6c-Sol3-1
23746: PPUSH
23747: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23751: LD_INT 10
23753: PPUSH
23754: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23758: LD_EXP 38
23762: PPUSH
23763: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23767: LD_EXP 38
23771: PPUSH
23772: LD_STRING D6c-JMM-1
23774: PPUSH
23775: CALL_OW 88
// if Cyrus then
23779: LD_EXP 44
23783: IFFALSE 23797
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23785: LD_EXP 44
23789: PPUSH
23790: LD_STRING D6c-Cyrus-1
23792: PPUSH
23793: CALL_OW 88
// if Bobby then
23797: LD_EXP 43
23801: IFFALSE 23815
// Say ( Bobby , D6c-Bobby-1 ) ;
23803: LD_EXP 43
23807: PPUSH
23808: LD_STRING D6c-Bobby-1
23810: PPUSH
23811: CALL_OW 88
// if Cornel then
23815: LD_EXP 49
23819: IFFALSE 23833
// Say ( Cornel , D6c-Corn-1 ) ;
23821: LD_EXP 49
23825: PPUSH
23826: LD_STRING D6c-Corn-1
23828: PPUSH
23829: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23833: LD_ADDR_VAR 0 4
23837: PUSH
23838: LD_INT 2
23840: PUSH
23841: LD_INT 22
23843: PUSH
23844: LD_INT 1
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: PUSH
23851: LD_INT 22
23853: PUSH
23854: LD_INT 4
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: PUSH
23861: EMPTY
23862: LIST
23863: LIST
23864: LIST
23865: PUSH
23866: LD_INT 26
23868: PUSH
23869: LD_INT 1
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: LD_INT 3
23878: PUSH
23879: LD_INT 25
23881: PUSH
23882: LD_INT 16
23884: PUSH
23885: EMPTY
23886: LIST
23887: LIST
23888: PUSH
23889: LD_INT 25
23891: PUSH
23892: LD_INT 12
23894: PUSH
23895: EMPTY
23896: LIST
23897: LIST
23898: PUSH
23899: EMPTY
23900: LIST
23901: LIST
23902: LIST
23903: PUSH
23904: EMPTY
23905: LIST
23906: LIST
23907: LIST
23908: PPUSH
23909: CALL_OW 69
23913: PUSH
23914: LD_VAR 0 11
23918: PUSH
23919: LD_EXP 38
23923: UNION
23924: PUSH
23925: LD_EXP 58
23929: UNION
23930: PUSH
23931: EMPTY
23932: LIST
23933: DIFF
23934: ST_TO_ADDR
// if tmp2 then
23935: LD_VAR 0 4
23939: IFFALSE 23957
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23941: LD_VAR 0 4
23945: PUSH
23946: LD_INT 1
23948: ARRAY
23949: PPUSH
23950: LD_STRING D6c-Sol1-1
23952: PPUSH
23953: CALL_OW 88
// if Lisa then
23957: LD_EXP 41
23961: IFFALSE 23975
// Say ( Lisa , D6c-Lisa-1 ) ;
23963: LD_EXP 41
23967: PPUSH
23968: LD_STRING D6c-Lisa-1
23970: PPUSH
23971: CALL_OW 88
// if Gary then
23975: LD_EXP 50
23979: IFFALSE 23993
// Say ( Gary , D6c-Gary-1 ) ;
23981: LD_EXP 50
23985: PPUSH
23986: LD_STRING D6c-Gary-1
23988: PPUSH
23989: CALL_OW 88
// if Donaldson then
23993: LD_EXP 42
23997: IFFALSE 24011
// Say ( Donaldson , D6c-Don-1 ) ;
23999: LD_EXP 42
24003: PPUSH
24004: LD_STRING D6c-Don-1
24006: PPUSH
24007: CALL_OW 88
// if tmp2 > 1 then
24011: LD_VAR 0 4
24015: PUSH
24016: LD_INT 1
24018: GREATER
24019: IFFALSE 24037
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24021: LD_VAR 0 4
24025: PUSH
24026: LD_INT 2
24028: ARRAY
24029: PPUSH
24030: LD_STRING D6c-Sol2-1
24032: PPUSH
24033: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24037: LD_VAR 0 11
24041: PPUSH
24042: LD_STRING D6c-Sol3-2
24044: PPUSH
24045: CALL_OW 88
// dwait ( 0 0$1 ) ;
24049: LD_INT 35
24051: PPUSH
24052: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24056: LD_EXP 38
24060: PPUSH
24061: LD_STRING D6c-JMM-2
24063: PPUSH
24064: CALL_OW 88
// DialogueOff ;
24068: CALL_OW 7
// Video ( false ) ;
24072: LD_INT 0
24074: PPUSH
24075: CALL 107108 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24079: LD_INT 22
24081: PUSH
24082: LD_INT 4
24084: PUSH
24085: EMPTY
24086: LIST
24087: LIST
24088: PPUSH
24089: CALL_OW 69
24093: PPUSH
24094: LD_INT 1
24096: PPUSH
24097: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24101: LD_INT 4
24103: PPUSH
24104: LD_INT 4
24106: PPUSH
24107: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24111: LD_ADDR_VAR 0 1
24115: PUSH
24116: LD_INT 4
24118: PPUSH
24119: LD_INT 1
24121: PPUSH
24122: LD_INT 2
24124: PPUSH
24125: CALL 64336 0 3
24129: PUSH
24130: FOR_IN
24131: IFFALSE 24168
// if GetTech ( i , 1 ) <> state_researched then
24133: LD_VAR 0 1
24137: PPUSH
24138: LD_INT 1
24140: PPUSH
24141: CALL_OW 321
24145: PUSH
24146: LD_INT 2
24148: NONEQUAL
24149: IFFALSE 24166
// SetTech ( i , 1 , state_researched ) ;
24151: LD_VAR 0 1
24155: PPUSH
24156: LD_INT 1
24158: PPUSH
24159: LD_INT 2
24161: PPUSH
24162: CALL_OW 322
24166: GO 24130
24168: POP
24169: POP
// missionStage := 6 ;
24170: LD_ADDR_EXP 15
24174: PUSH
24175: LD_INT 6
24177: ST_TO_ADDR
// activeAttacks := true ;
24178: LD_ADDR_EXP 16
24182: PUSH
24183: LD_INT 1
24185: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24186: LD_STRING M2
24188: PPUSH
24189: CALL_OW 337
// SaveForQuickRestart ;
24193: CALL_OW 22
// wait ( 0 0$40 ) ;
24197: LD_INT 1400
24199: PPUSH
24200: CALL_OW 67
// DialogueOn ;
24204: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24208: LD_EXP 61
24212: PPUSH
24213: LD_STRING D7-Friend-1
24215: PPUSH
24216: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24220: LD_EXP 38
24224: PPUSH
24225: LD_STRING D7-JMM-1
24227: PPUSH
24228: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24232: LD_EXP 61
24236: PPUSH
24237: LD_STRING D7-Friend-2
24239: PPUSH
24240: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24244: LD_EXP 38
24248: PPUSH
24249: LD_STRING D7-JMM-2
24251: PPUSH
24252: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24256: LD_EXP 61
24260: PPUSH
24261: LD_STRING D7-Friend-3
24263: PPUSH
24264: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24268: LD_EXP 38
24272: PPUSH
24273: LD_STRING D7-JMM-3
24275: PPUSH
24276: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24280: LD_EXP 61
24284: PPUSH
24285: LD_STRING D7-Friend-4
24287: PPUSH
24288: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24292: LD_EXP 38
24296: PPUSH
24297: LD_STRING D7-JMM-4
24299: PPUSH
24300: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24304: LD_EXP 61
24308: PPUSH
24309: LD_STRING D7-Friend-5
24311: PPUSH
24312: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24316: LD_EXP 38
24320: PPUSH
24321: LD_STRING D7-JMM-5
24323: PPUSH
24324: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24328: LD_EXP 61
24332: PPUSH
24333: LD_STRING D7-Friend-6
24335: PPUSH
24336: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24340: LD_EXP 38
24344: PPUSH
24345: LD_STRING D7-JMM-6
24347: PPUSH
24348: CALL_OW 88
// DialogueOff ;
24352: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24356: LD_STRING Mlegion
24358: PPUSH
24359: CALL_OW 337
// RebuildKozlovFactory ;
24363: CALL 4816 0 0
// end ;
24367: PPOPN 13
24369: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24370: LD_EXP 20
24374: PUSH
24375: LD_EXP 57
24379: PPUSH
24380: CALL_OW 300
24384: AND
24385: IFFALSE 24427
24387: GO 24389
24389: DISABLE
// begin enable ;
24390: ENABLE
// if IsInUnit ( Powell ) then
24391: LD_EXP 57
24395: PPUSH
24396: CALL_OW 310
24400: IFFALSE 24418
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24402: LD_EXP 57
24406: PPUSH
24407: CALL_OW 310
24411: PPUSH
24412: CALL_OW 85
24416: GO 24427
// CenterOnUnits ( Powell ) ;
24418: LD_EXP 57
24422: PPUSH
24423: CALL_OW 85
// end ;
24427: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24428: LD_INT 22
24430: PUSH
24431: LD_INT 8
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: PUSH
24438: LD_INT 34
24440: PUSH
24441: LD_INT 48
24443: PUSH
24444: EMPTY
24445: LIST
24446: LIST
24447: PUSH
24448: EMPTY
24449: LIST
24450: LIST
24451: PPUSH
24452: CALL_OW 69
24456: IFFALSE 24719
24458: GO 24460
24460: DISABLE
24461: LD_INT 0
24463: PPUSH
24464: PPUSH
// begin if missionStage < 9 then
24465: LD_EXP 15
24469: PUSH
24470: LD_INT 9
24472: LESS
24473: IFFALSE 24483
// missionStage := 9 ;
24475: LD_ADDR_EXP 15
24479: PUSH
24480: LD_INT 9
24482: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24483: LD_ADDR_VAR 0 1
24487: PUSH
24488: LD_INT 22
24490: PUSH
24491: LD_INT 8
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: PUSH
24498: LD_INT 34
24500: PUSH
24501: LD_INT 48
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: PUSH
24508: EMPTY
24509: LIST
24510: LIST
24511: PPUSH
24512: CALL_OW 69
24516: PUSH
24517: LD_INT 1
24519: ARRAY
24520: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24521: LD_INT 175
24523: PPUSH
24524: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24528: LD_EXP 12
24532: PUSH
24533: LD_EXP 3
24537: PUSH
24538: LD_INT 0
24540: PUSH
24541: LD_INT 2
24543: PUSH
24544: EMPTY
24545: LIST
24546: LIST
24547: IN
24548: OR
24549: IFFALSE 24572
// target := [ 68 , 108 , 1 ] else
24551: LD_ADDR_VAR 0 2
24555: PUSH
24556: LD_INT 68
24558: PUSH
24559: LD_INT 108
24561: PUSH
24562: LD_INT 1
24564: PUSH
24565: EMPTY
24566: LIST
24567: LIST
24568: LIST
24569: ST_TO_ADDR
24570: GO 24591
// target := [ 181 , 88 , 2 ] ;
24572: LD_ADDR_VAR 0 2
24576: PUSH
24577: LD_INT 181
24579: PUSH
24580: LD_INT 88
24582: PUSH
24583: LD_INT 2
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: LIST
24590: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24591: LD_VAR 0 1
24595: PPUSH
24596: LD_VAR 0 2
24600: PUSH
24601: LD_INT 1
24603: ARRAY
24604: PPUSH
24605: LD_VAR 0 2
24609: PUSH
24610: LD_INT 2
24612: ARRAY
24613: PPUSH
24614: CALL_OW 176
// if target [ 3 ] = 1 then
24618: LD_VAR 0 2
24622: PUSH
24623: LD_INT 3
24625: ARRAY
24626: PUSH
24627: LD_INT 1
24629: EQUAL
24630: IFFALSE 24646
// SayRadio ( Kurt , D12-Kurt-1 ) else
24632: LD_EXP 59
24636: PPUSH
24637: LD_STRING D12-Kurt-1
24639: PPUSH
24640: CALL_OW 94
24644: GO 24670
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24646: LD_EXP 59
24650: PPUSH
24651: LD_STRING D12a-Kurt-1
24653: PPUSH
24654: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24658: LD_EXP 73
24662: PPUSH
24663: LD_STRING D12a-Roth-1
24665: PPUSH
24666: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24670: LD_INT 350
24672: PPUSH
24673: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24677: LD_VAR 0 1
24681: PPUSH
24682: LD_INT 22
24684: PUSH
24685: LD_INT 8
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: PUSH
24692: LD_INT 30
24694: PUSH
24695: LD_INT 3
24697: PUSH
24698: EMPTY
24699: LIST
24700: LIST
24701: PUSH
24702: EMPTY
24703: LIST
24704: LIST
24705: PPUSH
24706: CALL_OW 69
24710: PUSH
24711: LD_INT 1
24713: ARRAY
24714: PPUSH
24715: CALL_OW 228
// end ;
24719: PPOPN 2
24721: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24722: LD_INT 22
24724: PUSH
24725: LD_INT 8
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: PUSH
24732: LD_INT 21
24734: PUSH
24735: LD_INT 1
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: PUSH
24742: LD_INT 23
24744: PUSH
24745: LD_INT 2
24747: PUSH
24748: EMPTY
24749: LIST
24750: LIST
24751: PUSH
24752: EMPTY
24753: LIST
24754: LIST
24755: LIST
24756: PPUSH
24757: CALL_OW 69
24761: PUSH
24762: LD_INT 9
24764: PUSH
24765: LD_INT 8
24767: PUSH
24768: LD_INT 7
24770: PUSH
24771: EMPTY
24772: LIST
24773: LIST
24774: LIST
24775: PUSH
24776: LD_OWVAR 67
24780: ARRAY
24781: LESSEQUAL
24782: PUSH
24783: LD_INT 22
24785: PUSH
24786: LD_INT 8
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: PUSH
24793: LD_INT 34
24795: PUSH
24796: LD_INT 48
24798: PUSH
24799: EMPTY
24800: LIST
24801: LIST
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PPUSH
24807: CALL_OW 69
24811: NOT
24812: AND
24813: PUSH
24814: LD_EXP 59
24818: PPUSH
24819: CALL_OW 302
24823: AND
24824: IFFALSE 25129
24826: GO 24828
24828: DISABLE
// begin DialogueOn ;
24829: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24833: LD_EXP 38
24837: PPUSH
24838: LD_STRING D13-JMM-1
24840: PPUSH
24841: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24845: LD_EXP 59
24849: PPUSH
24850: LD_STRING D13-Kurt-1
24852: PPUSH
24853: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24857: LD_EXP 38
24861: PPUSH
24862: LD_STRING D13-JMM-2
24864: PPUSH
24865: CALL_OW 88
// if FakeInfo then
24869: LD_EXP 12
24873: IFFALSE 24893
// begin Say ( Kurt , D13-Kurt-2 ) ;
24875: LD_EXP 59
24879: PPUSH
24880: LD_STRING D13-Kurt-2
24882: PPUSH
24883: CALL_OW 88
// DialogueOff ;
24887: CALL_OW 7
// exit ;
24891: GO 25129
// end ; if not KurtStatus then
24893: LD_EXP 3
24897: NOT
24898: IFFALSE 24914
// Say ( Kurt , D13-Kurt-2b ) else
24900: LD_EXP 59
24904: PPUSH
24905: LD_STRING D13-Kurt-2b
24907: PPUSH
24908: CALL_OW 88
24912: GO 24926
// Say ( Kurt , D13-Kurt-2a ) ;
24914: LD_EXP 59
24918: PPUSH
24919: LD_STRING D13-Kurt-2a
24921: PPUSH
24922: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24926: LD_EXP 38
24930: PPUSH
24931: LD_STRING D13-JMM-3
24933: PPUSH
24934: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24938: LD_EXP 59
24942: PPUSH
24943: LD_STRING D13-Kurt-3
24945: PPUSH
24946: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24950: LD_EXP 38
24954: PPUSH
24955: LD_STRING D13-JMM-4
24957: PPUSH
24958: CALL_OW 88
// DialogueOff ;
24962: CALL_OW 7
// MC_Kill ( 3 ) ;
24966: LD_INT 3
24968: PPUSH
24969: CALL 34469 0 1
// KillUnit ( Kozlov ) ;
24973: LD_EXP 60
24977: PPUSH
24978: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24982: LD_INT 22
24984: PUSH
24985: LD_INT 8
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: LD_INT 21
24994: PUSH
24995: LD_INT 3
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: PUSH
25002: LD_INT 23
25004: PUSH
25005: LD_INT 3
25007: PUSH
25008: EMPTY
25009: LIST
25010: LIST
25011: PUSH
25012: LD_INT 30
25014: PUSH
25015: LD_INT 3
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: LIST
25026: LIST
25027: PPUSH
25028: CALL_OW 69
25032: PUSH
25033: LD_INT 1
25035: ARRAY
25036: PPUSH
25037: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
25041: LD_INT 8
25043: PPUSH
25044: LD_INT 1
25046: PPUSH
25047: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
25051: LD_INT 22
25053: PUSH
25054: LD_INT 8
25056: PUSH
25057: EMPTY
25058: LIST
25059: LIST
25060: PPUSH
25061: CALL_OW 69
25065: PPUSH
25066: LD_INT 1
25068: PPUSH
25069: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25073: LD_INT 8
25075: PPUSH
25076: LD_INT 1
25078: PPUSH
25079: LD_INT 1
25081: PPUSH
25082: LD_INT 1
25084: PPUSH
25085: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25089: LD_EXP 61
25093: PPUSH
25094: LD_INT 37
25096: PPUSH
25097: LD_INT 1
25099: PPUSH
25100: LD_INT 0
25102: PPUSH
25103: CALL_OW 48
// wait ( 0 0$1 ) ;
25107: LD_INT 35
25109: PPUSH
25110: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25114: LD_EXP 61
25118: PPUSH
25119: LD_INT 60
25121: PPUSH
25122: LD_INT 95
25124: PPUSH
25125: CALL_OW 111
// end ;
25129: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25130: LD_INT 22
25132: PUSH
25133: LD_INT 8
25135: PUSH
25136: EMPTY
25137: LIST
25138: LIST
25139: PUSH
25140: LD_INT 21
25142: PUSH
25143: LD_INT 1
25145: PUSH
25146: EMPTY
25147: LIST
25148: LIST
25149: PUSH
25150: EMPTY
25151: LIST
25152: LIST
25153: PPUSH
25154: CALL_OW 69
25158: PUSH
25159: LD_INT 0
25161: EQUAL
25162: IFFALSE 25182
25164: GO 25166
25166: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25167: LD_STRING MlegionOut
25169: PPUSH
25170: CALL_OW 337
// legionDestroyed := true ;
25174: LD_ADDR_EXP 22
25178: PUSH
25179: LD_INT 1
25181: ST_TO_ADDR
// end ;
25182: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25183: LD_INT 1
25185: PPUSH
25186: LD_EXP 61
25190: PPUSH
25191: CALL_OW 292
25195: IFFALSE 25509
25197: GO 25199
25199: DISABLE
25200: LD_INT 0
25202: PPUSH
// begin wait ( 0 0$2 ) ;
25203: LD_INT 70
25205: PPUSH
25206: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25210: LD_EXP 61
25214: PPUSH
25215: CALL_OW 87
// DialogueOn ;
25219: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25223: LD_EXP 38
25227: PPUSH
25228: LD_STRING D14-JMM-1
25230: PPUSH
25231: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25235: LD_EXP 61
25239: PPUSH
25240: LD_STRING D14-Friend-1
25242: PPUSH
25243: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25247: LD_EXP 38
25251: PPUSH
25252: LD_STRING D14-JMM-2
25254: PPUSH
25255: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25259: LD_EXP 61
25263: PPUSH
25264: LD_STRING D14-Friend-2
25266: PPUSH
25267: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25271: LD_EXP 38
25275: PPUSH
25276: LD_STRING D14-JMM-3
25278: PPUSH
25279: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25283: LD_EXP 61
25287: PPUSH
25288: LD_STRING D14-Friend-3
25290: PPUSH
25291: CALL_OW 88
// DialogueOff ;
25295: CALL_OW 7
// dec = Query ( Q14 ) ;
25299: LD_ADDR_VAR 0 1
25303: PUSH
25304: LD_STRING Q14
25306: PPUSH
25307: CALL_OW 97
25311: ST_TO_ADDR
// if dec = 1 then
25312: LD_VAR 0 1
25316: PUSH
25317: LD_INT 1
25319: EQUAL
25320: IFFALSE 25354
// begin DialogueOn ;
25322: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25326: LD_EXP 38
25330: PPUSH
25331: LD_STRING D14a-JMM-1
25333: PPUSH
25334: CALL_OW 88
// DialogueOff ;
25338: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25342: LD_EXP 61
25346: PPUSH
25347: LD_INT 1
25349: PPUSH
25350: CALL_OW 235
// end ; if dec = 2 then
25354: LD_VAR 0 1
25358: PUSH
25359: LD_INT 2
25361: EQUAL
25362: IFFALSE 25415
// begin DialogueOn ;
25364: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25368: LD_EXP 38
25372: PPUSH
25373: LD_STRING D14b-JMM-1
25375: PPUSH
25376: CALL_OW 88
// DialogueOff ;
25380: CALL_OW 7
// wait ( 0 0$1 ) ;
25384: LD_INT 35
25386: PPUSH
25387: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
25391: LD_EXP 61
25395: PPUSH
25396: LD_INT 9
25398: PPUSH
25399: LD_INT 2
25401: PPUSH
25402: CALL_OW 111
// AddComHold ( Friend ) ;
25406: LD_EXP 61
25410: PPUSH
25411: CALL_OW 200
// end ; if dec = 3 then
25415: LD_VAR 0 1
25419: PUSH
25420: LD_INT 3
25422: EQUAL
25423: IFFALSE 25509
// begin DialogueOn ;
25425: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25429: LD_EXP 38
25433: PPUSH
25434: LD_STRING D14c-JMM-1
25436: PPUSH
25437: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25441: LD_EXP 61
25445: PPUSH
25446: LD_STRING D14c-Friend-1
25448: PPUSH
25449: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25453: LD_EXP 38
25457: PPUSH
25458: LD_STRING D14c-JMM-2
25460: PPUSH
25461: CALL_OW 88
// DialogueOff ;
25465: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25469: LD_INT 8
25471: PPUSH
25472: LD_INT 1
25474: PPUSH
25475: LD_INT 2
25477: PPUSH
25478: LD_INT 1
25480: PPUSH
25481: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25485: LD_EXP 61
25489: PPUSH
25490: LD_INT 9
25492: PPUSH
25493: LD_INT 2
25495: PPUSH
25496: CALL_OW 111
// AddComHold ( Friend ) ;
25500: LD_EXP 61
25504: PPUSH
25505: CALL_OW 200
// end ; end ;
25509: PPOPN 1
25511: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25512: LD_INT 9
25514: PPUSH
25515: LD_INT 2
25517: PPUSH
25518: CALL_OW 428
25522: PUSH
25523: LD_EXP 61
25527: EQUAL
25528: PUSH
25529: LD_EXP 61
25533: PPUSH
25534: CALL_OW 255
25538: PUSH
25539: LD_INT 8
25541: EQUAL
25542: AND
25543: IFFALSE 25557
25545: GO 25547
25547: DISABLE
// RemoveUnit ( Friend ) ;
25548: LD_EXP 61
25552: PPUSH
25553: CALL_OW 64
25557: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25558: LD_EXP 14
25562: PUSH
25563: LD_INT 31500
25565: GREATEREQUAL
25566: PUSH
25567: LD_EXP 7
25571: AND
25572: PUSH
25573: LD_EXP 2
25577: AND
25578: IFFALSE 26008
25580: GO 25582
25582: DISABLE
25583: LD_INT 0
25585: PPUSH
25586: PPUSH
25587: PPUSH
// begin missionStage := 7 ;
25588: LD_ADDR_EXP 15
25592: PUSH
25593: LD_INT 7
25595: ST_TO_ADDR
// uc_side = 1 ;
25596: LD_ADDR_OWVAR 20
25600: PUSH
25601: LD_INT 1
25603: ST_TO_ADDR
// uc_nation = 1 ;
25604: LD_ADDR_OWVAR 21
25608: PUSH
25609: LD_INT 1
25611: ST_TO_ADDR
// for i = 1 to 5 do
25612: LD_ADDR_VAR 0 1
25616: PUSH
25617: DOUBLE
25618: LD_INT 1
25620: DEC
25621: ST_TO_ADDR
25622: LD_INT 5
25624: PUSH
25625: FOR_TO
25626: IFFALSE 25722
// begin vc_engine = 3 ;
25628: LD_ADDR_OWVAR 39
25632: PUSH
25633: LD_INT 3
25635: ST_TO_ADDR
// vc_control = 3 ;
25636: LD_ADDR_OWVAR 38
25640: PUSH
25641: LD_INT 3
25643: ST_TO_ADDR
// vc_chassis = 3 ;
25644: LD_ADDR_OWVAR 37
25648: PUSH
25649: LD_INT 3
25651: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25652: LD_ADDR_OWVAR 40
25656: PUSH
25657: LD_INT 5
25659: PUSH
25660: LD_INT 9
25662: PUSH
25663: LD_INT 7
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: LIST
25670: PUSH
25671: LD_INT 1
25673: PPUSH
25674: LD_INT 3
25676: PPUSH
25677: CALL_OW 12
25681: ARRAY
25682: ST_TO_ADDR
// veh = CreateVehicle ;
25683: LD_ADDR_VAR 0 2
25687: PUSH
25688: CALL_OW 45
25692: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25693: LD_VAR 0 2
25697: PPUSH
25698: LD_INT 1
25700: PPUSH
25701: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25705: LD_VAR 0 2
25709: PPUSH
25710: LD_INT 19
25712: PPUSH
25713: LD_INT 0
25715: PPUSH
25716: CALL_OW 49
// end ;
25720: GO 25625
25722: POP
25723: POP
// vc_engine = 3 ;
25724: LD_ADDR_OWVAR 39
25728: PUSH
25729: LD_INT 3
25731: ST_TO_ADDR
// vc_control = 1 ;
25732: LD_ADDR_OWVAR 38
25736: PUSH
25737: LD_INT 1
25739: ST_TO_ADDR
// vc_chassis = 3 ;
25740: LD_ADDR_OWVAR 37
25744: PUSH
25745: LD_INT 3
25747: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25748: LD_ADDR_OWVAR 40
25752: PUSH
25753: LD_INT 5
25755: PUSH
25756: LD_INT 9
25758: PUSH
25759: LD_INT 7
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: LIST
25766: PUSH
25767: LD_INT 1
25769: PPUSH
25770: LD_INT 3
25772: PPUSH
25773: CALL_OW 12
25777: ARRAY
25778: ST_TO_ADDR
// vehG = CreateVehicle ;
25779: LD_ADDR_VAR 0 3
25783: PUSH
25784: CALL_OW 45
25788: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25789: LD_VAR 0 3
25793: PPUSH
25794: LD_INT 1
25796: PPUSH
25797: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25801: LD_VAR 0 3
25805: PPUSH
25806: LD_INT 19
25808: PPUSH
25809: LD_INT 0
25811: PPUSH
25812: CALL_OW 49
// if JMMGirl = 1 then
25816: LD_EXP 7
25820: PUSH
25821: LD_INT 1
25823: EQUAL
25824: IFFALSE 25880
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25826: LD_ADDR_EXP 39
25830: PUSH
25831: LD_STRING Joan
25833: PPUSH
25834: LD_INT 1
25836: PPUSH
25837: LD_STRING 14_
25839: PPUSH
25840: CALL 64273 0 3
25844: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25845: LD_EXP 39
25849: PPUSH
25850: LD_VAR 0 3
25854: PPUSH
25855: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25859: LD_VAR 0 3
25863: PPUSH
25864: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25868: LD_EXP 39
25872: PPUSH
25873: LD_STRING D10BW-Joan-1
25875: PPUSH
25876: CALL_OW 94
// end ; if JMMGirl = 2 then
25880: LD_EXP 7
25884: PUSH
25885: LD_INT 2
25887: EQUAL
25888: IFFALSE 25944
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25890: LD_ADDR_EXP 41
25894: PUSH
25895: LD_STRING Lisa
25897: PPUSH
25898: LD_INT 1
25900: PPUSH
25901: LD_STRING 14_
25903: PPUSH
25904: CALL 64273 0 3
25908: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25909: LD_EXP 41
25913: PPUSH
25914: LD_VAR 0 3
25918: PPUSH
25919: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25923: LD_VAR 0 3
25927: PPUSH
25928: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25932: LD_EXP 41
25936: PPUSH
25937: LD_STRING D10BW-Lisa-1
25939: PPUSH
25940: CALL_OW 94
// end ; if JMMGirl = 3 then
25944: LD_EXP 7
25948: PUSH
25949: LD_INT 3
25951: EQUAL
25952: IFFALSE 26008
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25954: LD_ADDR_EXP 53
25958: PUSH
25959: LD_STRING Connie
25961: PPUSH
25962: LD_INT 1
25964: PPUSH
25965: LD_STRING 14_
25967: PPUSH
25968: CALL 64273 0 3
25972: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25973: LD_EXP 53
25977: PPUSH
25978: LD_VAR 0 3
25982: PPUSH
25983: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25987: LD_VAR 0 3
25991: PPUSH
25992: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
25996: LD_EXP 53
26000: PPUSH
26001: LD_STRING D10BW-Con-1
26003: PPUSH
26004: CALL_OW 94
// end ; end ;
26008: PPOPN 3
26010: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26011: LD_EXP 14
26015: PUSH
26016: LD_INT 94500
26018: GREATEREQUAL
26019: IFFALSE 26431
26021: GO 26023
26023: DISABLE
26024: LD_INT 0
26026: PPUSH
26027: PPUSH
26028: PPUSH
// begin tmp := PrepareStevensSquad ;
26029: LD_ADDR_VAR 0 3
26033: PUSH
26034: CALL 2190 0 0
26038: ST_TO_ADDR
// if not tmp then
26039: LD_VAR 0 3
26043: NOT
26044: IFFALSE 26048
// exit ;
26046: GO 26431
// uc_side := 1 ;
26048: LD_ADDR_OWVAR 20
26052: PUSH
26053: LD_INT 1
26055: ST_TO_ADDR
// uc_nation := 1 ;
26056: LD_ADDR_OWVAR 21
26060: PUSH
26061: LD_INT 1
26063: ST_TO_ADDR
// for i in tmp do
26064: LD_ADDR_VAR 0 1
26068: PUSH
26069: LD_VAR 0 3
26073: PUSH
26074: FOR_IN
26075: IFFALSE 26172
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26077: LD_INT 3
26079: PPUSH
26080: LD_INT 3
26082: PPUSH
26083: LD_INT 1
26085: PPUSH
26086: LD_INT 5
26088: PUSH
26089: LD_INT 9
26091: PUSH
26092: LD_INT 7
26094: PUSH
26095: EMPTY
26096: LIST
26097: LIST
26098: LIST
26099: PUSH
26100: LD_INT 1
26102: PPUSH
26103: LD_INT 3
26105: PPUSH
26106: CALL_OW 12
26110: ARRAY
26111: PPUSH
26112: LD_INT 40
26114: PPUSH
26115: CALL 71388 0 5
// veh := CreateVehicle ;
26119: LD_ADDR_VAR 0 2
26123: PUSH
26124: CALL_OW 45
26128: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26129: LD_VAR 0 2
26133: PPUSH
26134: LD_INT 1
26136: PPUSH
26137: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26141: LD_VAR 0 2
26145: PPUSH
26146: LD_INT 19
26148: PPUSH
26149: LD_INT 0
26151: PPUSH
26152: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26156: LD_VAR 0 1
26160: PPUSH
26161: LD_VAR 0 2
26165: PPUSH
26166: CALL_OW 52
// end ;
26170: GO 26074
26172: POP
26173: POP
// missionStage := 8 ;
26174: LD_ADDR_EXP 15
26178: PUSH
26179: LD_INT 8
26181: ST_TO_ADDR
// DialogueOn ;
26182: CALL_OW 6
// if Stevens then
26186: LD_EXP 40
26190: IFFALSE 26304
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26192: LD_EXP 40
26196: PPUSH
26197: CALL_OW 310
26201: PPUSH
26202: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26206: LD_EXP 40
26210: PPUSH
26211: LD_STRING D8-Huck-1
26213: PPUSH
26214: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26218: LD_EXP 38
26222: PPUSH
26223: LD_STRING D8-JMM-1
26225: PPUSH
26226: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26230: LD_EXP 40
26234: PPUSH
26235: LD_STRING D8-Huck-2
26237: PPUSH
26238: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26242: LD_EXP 38
26246: PPUSH
26247: LD_STRING D8-JMM-2
26249: PPUSH
26250: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26254: LD_EXP 40
26258: PPUSH
26259: LD_STRING D8-Huck-3
26261: PPUSH
26262: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26266: LD_EXP 38
26270: PPUSH
26271: LD_STRING D8-JMM-3
26273: PPUSH
26274: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26278: LD_EXP 40
26282: PPUSH
26283: LD_STRING D8-Huck-4
26285: PPUSH
26286: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26290: LD_EXP 38
26294: PPUSH
26295: LD_STRING D8-JMM-4
26297: PPUSH
26298: CALL_OW 88
// end else
26302: GO 26414
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26304: LD_EXP 54
26308: PPUSH
26309: CALL_OW 310
26313: PPUSH
26314: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26318: LD_EXP 54
26322: PPUSH
26323: LD_STRING D8-Huck-1
26325: PPUSH
26326: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26330: LD_EXP 38
26334: PPUSH
26335: LD_STRING D8-JMM-1a
26337: PPUSH
26338: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26342: LD_EXP 54
26346: PPUSH
26347: LD_STRING D8-Huck-2
26349: PPUSH
26350: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26354: LD_EXP 38
26358: PPUSH
26359: LD_STRING D8-JMM-2
26361: PPUSH
26362: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26366: LD_EXP 54
26370: PPUSH
26371: LD_STRING D8-Huck-3
26373: PPUSH
26374: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26378: LD_EXP 38
26382: PPUSH
26383: LD_STRING D8-JMM-3
26385: PPUSH
26386: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26390: LD_EXP 54
26394: PPUSH
26395: LD_STRING D8-Huck-4
26397: PPUSH
26398: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26402: LD_EXP 38
26406: PPUSH
26407: LD_STRING D8-JMM-4
26409: PPUSH
26410: CALL_OW 88
// end ; DialogueOff ;
26414: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26418: LD_INT 25
26420: PPUSH
26421: LD_INT 1
26423: PPUSH
26424: LD_INT 1
26426: PPUSH
26427: CALL_OW 322
// end ;
26431: PPOPN 3
26433: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26434: LD_INT 1
26436: PPUSH
26437: LD_EXP 70
26441: PPUSH
26442: CALL_OW 292
26446: IFFALSE 26697
26448: GO 26450
26450: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26451: LD_EXP 70
26455: PPUSH
26456: CALL_OW 87
// DialogueOn ;
26460: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26464: LD_EXP 38
26468: PPUSH
26469: LD_STRING D10nB-JMM-1
26471: PPUSH
26472: CALL_OW 88
// if BurlakStatus = 1 then
26476: LD_EXP 9
26480: PUSH
26481: LD_INT 1
26483: EQUAL
26484: IFFALSE 26498
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26486: LD_EXP 69
26490: PPUSH
26491: LD_STRING D10nB-Vse-1a
26493: PPUSH
26494: CALL_OW 94
// end ; if BurlakStatus = 0 then
26498: LD_EXP 9
26502: PUSH
26503: LD_INT 0
26505: EQUAL
26506: IFFALSE 26520
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26508: LD_EXP 69
26512: PPUSH
26513: LD_STRING D10nB-Vse-1
26515: PPUSH
26516: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26520: LD_EXP 38
26524: PPUSH
26525: LD_STRING D10nB-JMM-2
26527: PPUSH
26528: CALL_OW 88
// if KappaStatus then
26532: LD_EXP 2
26536: IFFALSE 26550
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26538: LD_EXP 69
26542: PPUSH
26543: LD_STRING D10nB-Vse-5a
26545: PPUSH
26546: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26550: LD_EXP 2
26554: NOT
26555: PUSH
26556: LD_EXP 6
26560: PUSH
26561: LD_INT 0
26563: EQUAL
26564: AND
26565: IFFALSE 26693
// begin if JMMGirl = 1 then
26567: LD_EXP 7
26571: PUSH
26572: LD_INT 1
26574: EQUAL
26575: IFFALSE 26625
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26577: LD_EXP 69
26581: PPUSH
26582: LD_STRING D10nB-Vse-2
26584: PPUSH
26585: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26589: LD_EXP 38
26593: PPUSH
26594: LD_STRING D10nB-JMM-3
26596: PPUSH
26597: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26601: LD_EXP 69
26605: PPUSH
26606: LD_STRING D10nB-Vse-3
26608: PPUSH
26609: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26613: LD_EXP 38
26617: PPUSH
26618: LD_STRING D10nB-JMM-4
26620: PPUSH
26621: CALL_OW 88
// end ; if JMMGirl = 2 then
26625: LD_EXP 7
26629: PUSH
26630: LD_INT 2
26632: EQUAL
26633: IFFALSE 26659
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26635: LD_EXP 69
26639: PPUSH
26640: LD_STRING D10nB-Vse-4
26642: PPUSH
26643: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26647: LD_EXP 38
26651: PPUSH
26652: LD_STRING D10nB-JMM-5
26654: PPUSH
26655: CALL_OW 88
// end ; if JMMGirl = 3 then
26659: LD_EXP 7
26663: PUSH
26664: LD_INT 3
26666: EQUAL
26667: IFFALSE 26693
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26669: LD_EXP 69
26673: PPUSH
26674: LD_STRING D10nB-Vse-5
26676: PPUSH
26677: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26681: LD_EXP 38
26685: PPUSH
26686: LD_STRING D10nB-JMM-6
26688: PPUSH
26689: CALL_OW 88
// end ; end ; DialogueOff ;
26693: CALL_OW 7
// end ;
26697: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26698: LD_EXP 14
26702: PUSH
26703: LD_INT 115500
26705: GREATEREQUAL
26706: IFFALSE 27082
26708: GO 26710
26710: DISABLE
26711: LD_INT 0
26713: PPUSH
// begin missionStage := 10 ;
26714: LD_ADDR_EXP 15
26718: PUSH
26719: LD_INT 10
26721: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26722: LD_ADDR_VAR 0 1
26726: PUSH
26727: LD_INT 22
26729: PUSH
26730: LD_INT 1
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: PUSH
26737: LD_INT 23
26739: PUSH
26740: LD_INT 1
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: PUSH
26747: LD_INT 26
26749: PUSH
26750: LD_INT 1
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: PUSH
26757: LD_INT 3
26759: PUSH
26760: LD_INT 25
26762: PUSH
26763: LD_INT 12
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: PUSH
26774: LD_INT 3
26776: PUSH
26777: LD_INT 25
26779: PUSH
26780: LD_INT 16
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: PUSH
26787: EMPTY
26788: LIST
26789: LIST
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: LIST
26795: LIST
26796: LIST
26797: PPUSH
26798: CALL_OW 69
26802: PUSH
26803: LD_EXP 38
26807: PUSH
26808: LD_EXP 59
26812: PUSH
26813: LD_EXP 40
26817: PUSH
26818: LD_EXP 54
26822: PUSH
26823: LD_EXP 41
26827: PUSH
26828: LD_EXP 42
26832: PUSH
26833: LD_EXP 43
26837: PUSH
26838: LD_EXP 44
26842: PUSH
26843: LD_EXP 45
26847: PUSH
26848: LD_EXP 46
26852: PUSH
26853: LD_EXP 47
26857: PUSH
26858: LD_EXP 48
26862: PUSH
26863: LD_EXP 49
26867: PUSH
26868: LD_EXP 50
26872: PUSH
26873: LD_EXP 51
26877: PUSH
26878: LD_EXP 52
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: LIST
26887: LIST
26888: LIST
26889: LIST
26890: LIST
26891: LIST
26892: LIST
26893: LIST
26894: LIST
26895: LIST
26896: LIST
26897: LIST
26898: LIST
26899: LIST
26900: DIFF
26901: ST_TO_ADDR
// if not tmp and Brown then
26902: LD_VAR 0 1
26906: NOT
26907: PUSH
26908: LD_EXP 46
26912: AND
26913: IFFALSE 26928
// tmp := [ Brown ] ;
26915: LD_ADDR_VAR 0 1
26919: PUSH
26920: LD_EXP 46
26924: PUSH
26925: EMPTY
26926: LIST
26927: ST_TO_ADDR
// DialogueOn ;
26928: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26932: LD_VAR 0 1
26936: PUSH
26937: LD_INT 1
26939: ARRAY
26940: PPUSH
26941: LD_STRING D11-Sol1-1
26943: PPUSH
26944: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26948: LD_EXP 63
26952: PPUSH
26953: LD_STRING D11-Pla-1
26955: PPUSH
26956: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26960: LD_EXP 64
26964: PPUSH
26965: LD_STRING D11-Kov-1
26967: PPUSH
26968: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26972: LD_EXP 63
26976: PPUSH
26977: LD_STRING D11-Pla-2
26979: PPUSH
26980: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26984: LD_VAR 0 1
26988: PUSH
26989: LD_INT 1
26991: ARRAY
26992: PPUSH
26993: LD_STRING D11-Sol1-2
26995: PPUSH
26996: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27000: LD_EXP 38
27004: PPUSH
27005: LD_STRING D11-JMM-2
27007: PPUSH
27008: CALL_OW 88
// DialogueOff ;
27012: CALL_OW 7
// allowBehemothConstruct := true ;
27016: LD_ADDR_EXP 25
27020: PUSH
27021: LD_INT 1
27023: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27024: LD_STRING M4
27026: PPUSH
27027: CALL_OW 337
// BuildBehemoths ;
27031: CALL 7620 0 0
// repeat wait ( 15 15$00 ) ;
27035: LD_INT 31500
27037: PPUSH
27038: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27042: LD_EXP 27
27046: IFFALSE 27050
// break ;
27048: GO 27082
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27050: LD_INT 267
27052: PPUSH
27053: CALL_OW 274
27057: PPUSH
27058: LD_INT 1
27060: PPUSH
27061: CALL_OW 275
27065: PUSH
27066: LD_INT 1000
27068: GREATEREQUAL
27069: IFFALSE 27075
// BuildBehemoths ;
27071: CALL 7620 0 0
// until not behemothBuilders ;
27075: LD_EXP 72
27079: NOT
27080: IFFALSE 27035
// end ;
27082: PPOPN 1
27084: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27085: LD_EXP 72
27089: NOT
27090: PUSH
27091: LD_EXP 28
27095: NOT
27096: AND
27097: PUSH
27098: LD_EXP 25
27102: AND
27103: IFFALSE 27123
27105: GO 27107
27107: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27108: LD_STRING M4a
27110: PPUSH
27111: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27115: LD_ADDR_EXP 27
27119: PUSH
27120: LD_INT 1
27122: ST_TO_ADDR
// end ;
27123: END
// every 0 0$1 trigger behemothDone do
27124: LD_EXP 28
27128: IFFALSE 27140
27130: GO 27132
27132: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27133: LD_STRING M4b
27135: PPUSH
27136: CALL_OW 337
27140: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27141: LD_EXP 29
27145: NOT
27146: IFFALSE 27342
27148: GO 27150
27150: DISABLE
27151: LD_INT 0
27153: PPUSH
27154: PPUSH
// begin enable ;
27155: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27156: LD_ADDR_VAR 0 1
27160: PUSH
27161: LD_INT 3
27163: PPUSH
27164: CALL 107184 0 1
27168: ST_TO_ADDR
// if not tmp and not behemothDone then
27169: LD_VAR 0 1
27173: NOT
27174: PUSH
27175: LD_EXP 28
27179: NOT
27180: AND
27181: IFFALSE 27217
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27183: LD_ADDR_VAR 0 1
27187: PUSH
27188: LD_INT 22
27190: PUSH
27191: LD_INT 3
27193: PUSH
27194: EMPTY
27195: LIST
27196: LIST
27197: PUSH
27198: LD_INT 30
27200: PUSH
27201: LD_INT 37
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PPUSH
27212: CALL_OW 69
27216: ST_TO_ADDR
// if not tmp then
27217: LD_VAR 0 1
27221: NOT
27222: IFFALSE 27226
// exit ;
27224: GO 27342
// for i in tmp do
27226: LD_ADDR_VAR 0 2
27230: PUSH
27231: LD_VAR 0 1
27235: PUSH
27236: FOR_IN
27237: IFFALSE 27340
// if See ( 1 , i ) then
27239: LD_INT 1
27241: PPUSH
27242: LD_VAR 0 2
27246: PPUSH
27247: CALL_OW 292
27251: IFFALSE 27338
// begin if GetType ( i ) = unit_building then
27253: LD_VAR 0 2
27257: PPUSH
27258: CALL_OW 247
27262: PUSH
27263: LD_INT 3
27265: EQUAL
27266: IFFALSE 27304
// begin CenterNowOnUnits ( i ) ;
27268: LD_VAR 0 2
27272: PPUSH
27273: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27277: LD_EXP 38
27281: PPUSH
27282: LD_STRING D17a-JMM-1
27284: PPUSH
27285: CALL_OW 88
// seeBehemoth := true ;
27289: LD_ADDR_EXP 29
27293: PUSH
27294: LD_INT 1
27296: ST_TO_ADDR
// disable ;
27297: DISABLE
// exit ;
27298: POP
27299: POP
27300: GO 27342
// end else
27302: GO 27338
// begin CenterNowOnUnits ( i ) ;
27304: LD_VAR 0 2
27308: PPUSH
27309: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27313: LD_EXP 38
27317: PPUSH
27318: LD_STRING D17b-JMM-1
27320: PPUSH
27321: CALL_OW 88
// seeBehemoth := true ;
27325: LD_ADDR_EXP 29
27329: PUSH
27330: LD_INT 1
27332: ST_TO_ADDR
// disable ;
27333: DISABLE
// exit ;
27334: POP
27335: POP
27336: GO 27342
// end ; end ;
27338: GO 27236
27340: POP
27341: POP
// end ;
27342: PPOPN 2
27344: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27345: LD_EXP 14
27349: PUSH
27350: LD_INT 116550
27352: GREATEREQUAL
27353: IFFALSE 28529
27355: GO 27357
27357: DISABLE
27358: LD_INT 0
27360: PPUSH
27361: PPUSH
27362: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27363: LD_INT 2
27365: PPUSH
27366: LD_INT 23
27368: PUSH
27369: LD_INT 3
27371: PUSH
27372: LD_INT 3
27374: PUSH
27375: LD_INT 48
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: LIST
27382: LIST
27383: PUSH
27384: EMPTY
27385: LIST
27386: PPUSH
27387: CALL 57929 0 2
// repeat wait ( 0 0$1 ) ;
27391: LD_INT 35
27393: PPUSH
27394: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27398: LD_INT 22
27400: PUSH
27401: LD_INT 3
27403: PUSH
27404: EMPTY
27405: LIST
27406: LIST
27407: PUSH
27408: LD_INT 34
27410: PUSH
27411: LD_INT 48
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: PPUSH
27422: CALL_OW 69
27426: IFFALSE 27391
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27428: LD_ADDR_VAR 0 1
27432: PUSH
27433: LD_INT 22
27435: PUSH
27436: LD_INT 3
27438: PUSH
27439: EMPTY
27440: LIST
27441: LIST
27442: PUSH
27443: LD_INT 34
27445: PUSH
27446: LD_INT 48
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PPUSH
27457: CALL_OW 69
27461: PUSH
27462: LD_INT 1
27464: ARRAY
27465: ST_TO_ADDR
// missionStage := 12 ;
27466: LD_ADDR_EXP 15
27470: PUSH
27471: LD_INT 12
27473: ST_TO_ADDR
// platonovHasBomb := true ;
27474: LD_ADDR_EXP 30
27478: PUSH
27479: LD_INT 1
27481: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27482: LD_VAR 0 1
27486: PPUSH
27487: LD_INT 181
27489: PPUSH
27490: LD_INT 86
27492: PPUSH
27493: CALL_OW 171
// AddComHold ( bomb ) ;
27497: LD_VAR 0 1
27501: PPUSH
27502: CALL_OW 200
// wait ( 0 0$10 ) ;
27506: LD_INT 350
27508: PPUSH
27509: CALL_OW 67
// DialogueOn ;
27513: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27517: LD_EXP 63
27521: PPUSH
27522: LD_STRING D15-Pla-1
27524: PPUSH
27525: CALL_OW 94
// dec = Query ( Q15a ) ;
27529: LD_ADDR_VAR 0 2
27533: PUSH
27534: LD_STRING Q15a
27536: PPUSH
27537: CALL_OW 97
27541: ST_TO_ADDR
// if dec = 1 then
27542: LD_VAR 0 2
27546: PUSH
27547: LD_INT 1
27549: EQUAL
27550: IFFALSE 27573
// begin Say ( JMM , D15a-JMM-1 ) ;
27552: LD_EXP 38
27556: PPUSH
27557: LD_STRING D15a-JMM-1
27559: PPUSH
27560: CALL_OW 88
// YouLost ( Surrender ) ;
27564: LD_STRING Surrender
27566: PPUSH
27567: CALL_OW 104
// exit ;
27571: GO 28529
// end ; if dec = 2 then
27573: LD_VAR 0 2
27577: PUSH
27578: LD_INT 2
27580: EQUAL
27581: IFFALSE 27650
// begin Say ( JMM , D15b-JMM-1 ) ;
27583: LD_EXP 38
27587: PPUSH
27588: LD_STRING D15b-JMM-1
27590: PPUSH
27591: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27595: LD_EXP 63
27599: PPUSH
27600: LD_STRING D15b-Pla-1
27602: PPUSH
27603: CALL_OW 94
// DialogueOff ;
27607: CALL_OW 7
// wait ( 3 3$00 ) ;
27611: LD_INT 6300
27613: PPUSH
27614: CALL_OW 67
// DialogueOn ;
27618: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27622: LD_EXP 38
27626: PPUSH
27627: LD_STRING D15d-JMM-1a
27629: PPUSH
27630: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27634: LD_EXP 63
27638: PPUSH
27639: LD_STRING D15d-Pla-1
27641: PPUSH
27642: CALL_OW 94
// DialogueOff ;
27646: CALL_OW 7
// end ; if dec = 3 then
27650: LD_VAR 0 2
27654: PUSH
27655: LD_INT 3
27657: EQUAL
27658: IFFALSE 27712
// begin Say ( JMM , D15c-JMM-1 ) ;
27660: LD_EXP 38
27664: PPUSH
27665: LD_STRING D15c-JMM-1
27667: PPUSH
27668: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27672: LD_EXP 63
27676: PPUSH
27677: LD_STRING D15c-Pla-1
27679: PPUSH
27680: CALL_OW 94
// DialogueOff ;
27684: CALL_OW 7
// wait ( 0 0$15 ) ;
27688: LD_INT 525
27690: PPUSH
27691: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27695: LD_VAR 0 1
27699: PPUSH
27700: LD_INT 60
27702: PPUSH
27703: LD_INT 95
27705: PPUSH
27706: CALL_OW 116
// exit ;
27710: GO 28529
// end ; if dec = 4 then
27712: LD_VAR 0 2
27716: PUSH
27717: LD_INT 4
27719: EQUAL
27720: IFFALSE 27750
// begin Say ( JMM , D15d-JMM-1 ) ;
27722: LD_EXP 38
27726: PPUSH
27727: LD_STRING D15d-JMM-1
27729: PPUSH
27730: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27734: LD_EXP 63
27738: PPUSH
27739: LD_STRING D15d-Pla-1
27741: PPUSH
27742: CALL_OW 94
// DialogueOff ;
27746: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27750: LD_EXP 61
27754: PPUSH
27755: CALL_OW 302
27759: PUSH
27760: LD_EXP 61
27764: PPUSH
27765: CALL_OW 255
27769: PUSH
27770: LD_INT 1
27772: EQUAL
27773: AND
27774: PUSH
27775: LD_INT 22
27777: PUSH
27778: LD_INT 1
27780: PUSH
27781: EMPTY
27782: LIST
27783: LIST
27784: PUSH
27785: LD_INT 34
27787: PUSH
27788: LD_INT 8
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PPUSH
27799: CALL_OW 69
27803: NOT
27804: AND
27805: IFFALSE 28430
// begin SetSide ( Friend , 8 ) ;
27807: LD_EXP 61
27811: PPUSH
27812: LD_INT 8
27814: PPUSH
27815: CALL_OW 235
// if IsInUnit ( Friend ) then
27819: LD_EXP 61
27823: PPUSH
27824: CALL_OW 310
27828: IFFALSE 27839
// ComExitBuilding ( Friend ) ;
27830: LD_EXP 61
27834: PPUSH
27835: CALL_OW 122
// if IsDriver ( Friend ) then
27839: LD_EXP 61
27843: PPUSH
27844: CALL 104861 0 1
27848: IFFALSE 27859
// ComExitVehicle ( Friend ) ;
27850: LD_EXP 61
27854: PPUSH
27855: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27859: LD_EXP 61
27863: PPUSH
27864: LD_INT 9
27866: PPUSH
27867: LD_INT 2
27869: PPUSH
27870: CALL_OW 171
// wait ( 0 0$05 ) ;
27874: LD_INT 175
27876: PPUSH
27877: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27881: LD_EXP 61
27885: PPUSH
27886: CALL_OW 87
// DialogueOn ;
27890: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27894: LD_EXP 38
27898: PPUSH
27899: LD_STRING D16-JMM-1
27901: PPUSH
27902: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27906: LD_EXP 61
27910: PPUSH
27911: LD_STRING D16-Friend-1
27913: PPUSH
27914: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27918: LD_EXP 38
27922: PPUSH
27923: LD_STRING D16-JMM-2
27925: PPUSH
27926: CALL_OW 88
// DialogueOff ;
27930: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27934: LD_EXP 61
27938: PPUSH
27939: LD_INT 1
27941: PPUSH
27942: CALL_OW 235
// ComHold ( Friend ) ;
27946: LD_EXP 61
27950: PPUSH
27951: CALL_OW 140
// wait ( 0 0$20 ) ;
27955: LD_INT 700
27957: PPUSH
27958: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27962: LD_EXP 61
27966: PPUSH
27967: LD_INT 9
27969: PPUSH
27970: LD_INT 2
27972: PPUSH
27973: CALL_OW 297
27977: PUSH
27978: LD_INT 30
27980: LESS
27981: IFFALSE 28050
// begin SetSide ( Friend , 8 ) ;
27983: LD_EXP 61
27987: PPUSH
27988: LD_INT 8
27990: PPUSH
27991: CALL_OW 235
// if IsInUnit ( Friend ) then
27995: LD_EXP 61
27999: PPUSH
28000: CALL_OW 310
28004: IFFALSE 28015
// ComExitBuilding ( Friend ) ;
28006: LD_EXP 61
28010: PPUSH
28011: CALL_OW 122
// if IsDriver ( Friend ) then
28015: LD_EXP 61
28019: PPUSH
28020: CALL 104861 0 1
28024: IFFALSE 28035
// ComExitVehicle ( Friend ) ;
28026: LD_EXP 61
28030: PPUSH
28031: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28035: LD_EXP 61
28039: PPUSH
28040: LD_INT 9
28042: PPUSH
28043: LD_INT 2
28045: PPUSH
28046: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28050: LD_INT 1050
28052: PPUSH
28053: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28057: LD_INT 22
28059: PUSH
28060: LD_INT 1
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: LD_INT 34
28069: PUSH
28070: LD_INT 8
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PPUSH
28081: CALL_OW 69
28085: NOT
28086: IFFALSE 28408
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28088: LD_ADDR_VAR 0 3
28092: PUSH
28093: LD_INT 22
28095: PUSH
28096: LD_INT 1
28098: PUSH
28099: EMPTY
28100: LIST
28101: LIST
28102: PUSH
28103: LD_INT 26
28105: PUSH
28106: LD_INT 1
28108: PUSH
28109: EMPTY
28110: LIST
28111: LIST
28112: PUSH
28113: LD_INT 3
28115: PUSH
28116: LD_INT 25
28118: PUSH
28119: LD_INT 12
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 25
28128: PUSH
28129: LD_INT 16
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: LIST
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: LIST
28145: PPUSH
28146: CALL_OW 69
28150: PUSH
28151: LD_EXP 38
28155: PUSH
28156: LD_EXP 40
28160: PUSH
28161: LD_EXP 54
28165: PUSH
28166: LD_EXP 41
28170: PUSH
28171: LD_EXP 42
28175: PUSH
28176: LD_EXP 43
28180: PUSH
28181: LD_EXP 44
28185: PUSH
28186: LD_EXP 45
28190: PUSH
28191: LD_EXP 46
28195: PUSH
28196: LD_EXP 47
28200: PUSH
28201: LD_EXP 48
28205: PUSH
28206: LD_EXP 49
28210: PUSH
28211: LD_EXP 50
28215: PUSH
28216: LD_EXP 51
28220: PUSH
28221: LD_EXP 52
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: LIST
28234: LIST
28235: LIST
28236: LIST
28237: LIST
28238: LIST
28239: LIST
28240: LIST
28241: LIST
28242: DIFF
28243: ST_TO_ADDR
// DialogueOn ;
28244: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28248: LD_EXP 63
28252: PPUSH
28253: LD_STRING D16a-Pla-1
28255: PPUSH
28256: CALL_OW 94
// if Stevens then
28260: LD_EXP 40
28264: IFFALSE 28280
// Say ( Stevens , D16a-Huck-1 ) else
28266: LD_EXP 40
28270: PPUSH
28271: LD_STRING D16a-Huck-1
28273: PPUSH
28274: CALL_OW 88
28278: GO 28322
// if Baker then
28280: LD_EXP 54
28284: IFFALSE 28300
// Say ( Baker , D16a-Huck-1 ) else
28286: LD_EXP 54
28290: PPUSH
28291: LD_STRING D16a-Huck-1
28293: PPUSH
28294: CALL_OW 88
28298: GO 28322
// if tmp then
28300: LD_VAR 0 3
28304: IFFALSE 28322
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28306: LD_VAR 0 3
28310: PUSH
28311: LD_INT 1
28313: ARRAY
28314: PPUSH
28315: LD_STRING D16a-Sol1-1
28317: PPUSH
28318: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28322: LD_EXP 61
28326: PPUSH
28327: CALL_OW 255
28331: PUSH
28332: LD_INT 8
28334: EQUAL
28335: IFFALSE 28351
// Say ( JMM , D16a-JMM-1 ) else
28337: LD_EXP 38
28341: PPUSH
28342: LD_STRING D16a-JMM-1
28344: PPUSH
28345: CALL_OW 88
28349: GO 28387
// begin Say ( JMM , D16a-JMM-1a ) ;
28351: LD_EXP 38
28355: PPUSH
28356: LD_STRING D16a-JMM-1a
28358: PPUSH
28359: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28363: LD_EXP 61
28367: PPUSH
28368: LD_STRING D16a-Friend-1
28370: PPUSH
28371: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28375: LD_EXP 61
28379: PPUSH
28380: LD_INT 3
28382: PPUSH
28383: CALL_OW 235
// end ; DialogueOff ;
28387: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28391: LD_VAR 0 1
28395: PPUSH
28396: LD_INT 60
28398: PPUSH
28399: LD_INT 95
28401: PPUSH
28402: CALL_OW 116
// end else
28406: GO 28428
// begin DialogueOn ;
28408: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28412: LD_EXP 63
28416: PPUSH
28417: LD_STRING D16c-Pla-
28419: PPUSH
28420: CALL_OW 94
// DialogueOff ;
28424: CALL_OW 7
// end ; end else
28428: GO 28529
// begin wait ( 3 3$00 ) ;
28430: LD_INT 6300
28432: PPUSH
28433: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28437: LD_INT 22
28439: PUSH
28440: LD_INT 1
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 34
28449: PUSH
28450: LD_INT 8
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PPUSH
28461: CALL_OW 69
28465: NOT
28466: IFFALSE 28509
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28468: LD_EXP 63
28472: PPUSH
28473: LD_STRING D16b-Pla-1
28475: PPUSH
28476: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28480: LD_EXP 38
28484: PPUSH
28485: LD_STRING D16b-JMM-
28487: PPUSH
28488: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28492: LD_VAR 0 1
28496: PPUSH
28497: LD_INT 60
28499: PPUSH
28500: LD_INT 95
28502: PPUSH
28503: CALL_OW 116
// end else
28507: GO 28529
// begin DialogueOn ;
28509: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28513: LD_EXP 63
28517: PPUSH
28518: LD_STRING D16c-Pla-
28520: PPUSH
28521: CALL_OW 94
// DialogueOff ;
28525: CALL_OW 7
// end ; end ; end ;
28529: PPOPN 3
28531: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28532: LD_EXP 14
28536: PUSH
28537: LD_INT 126000
28539: GREATEREQUAL
28540: PUSH
28541: LD_EXP 23
28545: NOT
28546: AND
28547: PUSH
28548: LD_EXP 73
28552: PPUSH
28553: CALL_OW 302
28557: AND
28558: IFFALSE 28916
28560: GO 28562
28562: DISABLE
28563: LD_INT 0
28565: PPUSH
// begin missionStage = 11 ;
28566: LD_ADDR_EXP 15
28570: PUSH
28571: LD_INT 11
28573: ST_TO_ADDR
// DialogueOn ;
28574: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28578: LD_EXP 73
28582: PPUSH
28583: LD_STRING D9-Roth-1
28585: PPUSH
28586: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28590: LD_EXP 38
28594: PPUSH
28595: LD_STRING D9-JMM-1
28597: PPUSH
28598: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28602: LD_EXP 73
28606: PPUSH
28607: LD_STRING D9-Roth-2
28609: PPUSH
28610: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28614: LD_EXP 73
28618: PPUSH
28619: LD_STRING D9-Roth-2a
28621: PPUSH
28622: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28626: LD_EXP 63
28630: PPUSH
28631: LD_STRING D9-Pla-2
28633: PPUSH
28634: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28638: LD_EXP 73
28642: PPUSH
28643: LD_STRING D9-Roth-3
28645: PPUSH
28646: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28650: LD_EXP 63
28654: PPUSH
28655: LD_STRING D9-Pla-3
28657: PPUSH
28658: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28662: LD_EXP 73
28666: PPUSH
28667: LD_STRING D9-Roth-4
28669: PPUSH
28670: CALL_OW 94
// dec = Query ( Q9 ) ;
28674: LD_ADDR_VAR 0 1
28678: PUSH
28679: LD_STRING Q9
28681: PPUSH
28682: CALL_OW 97
28686: ST_TO_ADDR
// if dec = 1 then
28687: LD_VAR 0 1
28691: PUSH
28692: LD_INT 1
28694: EQUAL
28695: IFFALSE 28709
// SayRadio ( Roth , D9a-Roth-1 ) ;
28697: LD_EXP 73
28701: PPUSH
28702: LD_STRING D9a-Roth-1
28704: PPUSH
28705: CALL_OW 94
// if dec = 2 then
28709: LD_VAR 0 1
28713: PUSH
28714: LD_INT 2
28716: EQUAL
28717: IFFALSE 28743
// begin Say ( JMM , D9b-JMM-1 ) ;
28719: LD_EXP 38
28723: PPUSH
28724: LD_STRING D9b-JMM-1
28726: PPUSH
28727: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28731: LD_EXP 73
28735: PPUSH
28736: LD_STRING D9b-Roth-1
28738: PPUSH
28739: CALL_OW 94
// end ; if dec = 3 then
28743: LD_VAR 0 1
28747: PUSH
28748: LD_INT 3
28750: EQUAL
28751: IFFALSE 28813
// begin Say ( JMM , D9c-JMM-1 ) ;
28753: LD_EXP 38
28757: PPUSH
28758: LD_STRING D9c-JMM-1
28760: PPUSH
28761: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28765: LD_EXP 73
28769: PPUSH
28770: LD_STRING D9c-Roth-1
28772: PPUSH
28773: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28777: LD_EXP 38
28781: PPUSH
28782: LD_STRING D9c-JMM-2
28784: PPUSH
28785: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28789: LD_EXP 73
28793: PPUSH
28794: LD_STRING D9c-Roth-2
28796: PPUSH
28797: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28801: LD_EXP 38
28805: PPUSH
28806: LD_STRING D9c-JMM-3
28808: PPUSH
28809: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28813: LD_EXP 73
28817: PPUSH
28818: LD_STRING D9c-Roth-3
28820: PPUSH
28821: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28825: LD_EXP 73
28829: PPUSH
28830: LD_STRING D9cont-Roth-1
28832: PPUSH
28833: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28837: LD_EXP 38
28841: PPUSH
28842: LD_STRING D9cont-JMM-1
28844: PPUSH
28845: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28849: LD_EXP 73
28853: PPUSH
28854: LD_STRING D9cont-Roth-2
28856: PPUSH
28857: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28861: LD_EXP 38
28865: PPUSH
28866: LD_STRING D9cont-JMM-2
28868: PPUSH
28869: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28873: LD_EXP 73
28877: PPUSH
28878: LD_STRING D9cont-Roth-3
28880: PPUSH
28881: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28885: LD_EXP 38
28889: PPUSH
28890: LD_STRING D9cont-JMM-3
28892: PPUSH
28893: CALL_OW 88
// DialogueOff ;
28897: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28901: LD_STRING M3
28903: PPUSH
28904: CALL_OW 337
// allianceActive := true ;
28908: LD_ADDR_EXP 31
28912: PUSH
28913: LD_INT 1
28915: ST_TO_ADDR
// end ;
28916: PPOPN 1
28918: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28919: LD_EXP 63
28923: PPUSH
28924: CALL_OW 301
28928: PUSH
28929: LD_EXP 66
28933: PPUSH
28934: CALL_OW 301
28938: AND
28939: PUSH
28940: LD_INT 22
28942: PUSH
28943: LD_INT 3
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 21
28952: PUSH
28953: LD_INT 1
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 50
28962: PUSH
28963: EMPTY
28964: LIST
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: LIST
28970: PPUSH
28971: CALL_OW 69
28975: PUSH
28976: LD_INT 7
28978: PUSH
28979: LD_INT 8
28981: PUSH
28982: LD_INT 9
28984: PUSH
28985: EMPTY
28986: LIST
28987: LIST
28988: LIST
28989: PUSH
28990: LD_OWVAR 67
28994: ARRAY
28995: LESS
28996: AND
28997: IFFALSE 29768
28999: GO 29001
29001: DISABLE
29002: LD_INT 0
29004: PPUSH
29005: PPUSH
29006: PPUSH
29007: PPUSH
// begin MC_Kill ( 1 ) ;
29008: LD_INT 1
29010: PPUSH
29011: CALL 34469 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29015: LD_INT 1
29017: PPUSH
29018: LD_INT 3
29020: PPUSH
29021: LD_INT 1
29023: PPUSH
29024: LD_INT 1
29026: PPUSH
29027: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29031: LD_ADDR_VAR 0 1
29035: PUSH
29036: LD_INT 22
29038: PUSH
29039: LD_INT 3
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 21
29048: PUSH
29049: LD_INT 1
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 24
29058: PUSH
29059: LD_INT 900
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: EMPTY
29067: LIST
29068: LIST
29069: LIST
29070: PPUSH
29071: CALL_OW 69
29075: PUSH
29076: FOR_IN
29077: IFFALSE 29108
// if GetSex ( i ) = sex_male then
29079: LD_VAR 0 1
29083: PPUSH
29084: CALL_OW 258
29088: PUSH
29089: LD_INT 1
29091: EQUAL
29092: IFFALSE 29106
// begin tmp = i ;
29094: LD_ADDR_VAR 0 2
29098: PUSH
29099: LD_VAR 0 1
29103: ST_TO_ADDR
// break ;
29104: GO 29108
// end ;
29106: GO 29076
29108: POP
29109: POP
// if tmp = 0 then
29110: LD_VAR 0 2
29114: PUSH
29115: LD_INT 0
29117: EQUAL
29118: IFFALSE 29172
// begin uc_side = 3 ;
29120: LD_ADDR_OWVAR 20
29124: PUSH
29125: LD_INT 3
29127: ST_TO_ADDR
// uc_nation = 3 ;
29128: LD_ADDR_OWVAR 21
29132: PUSH
29133: LD_INT 3
29135: ST_TO_ADDR
// hc_name =  ;
29136: LD_ADDR_OWVAR 26
29140: PUSH
29141: LD_STRING 
29143: ST_TO_ADDR
// hc_gallery =  ;
29144: LD_ADDR_OWVAR 33
29148: PUSH
29149: LD_STRING 
29151: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29152: LD_INT 1
29154: PPUSH
29155: LD_INT 10
29157: PPUSH
29158: CALL_OW 381
// tmp = CreateHuman ;
29162: LD_ADDR_VAR 0 2
29166: PUSH
29167: CALL_OW 44
29171: ST_TO_ADDR
// end ; DialogueOn ;
29172: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29176: LD_VAR 0 2
29180: PPUSH
29181: LD_STRING DSurrenderRussians-RSol1-1a
29183: PPUSH
29184: CALL_OW 94
// DialogueOff ;
29188: CALL_OW 7
// russianDestroyed := true ;
29192: LD_ADDR_EXP 21
29196: PUSH
29197: LD_INT 1
29199: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29200: LD_INT 22
29202: PUSH
29203: LD_INT 3
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 21
29212: PUSH
29213: LD_INT 1
29215: PUSH
29216: EMPTY
29217: LIST
29218: LIST
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PPUSH
29224: CALL_OW 69
29228: PPUSH
29229: CALL_OW 122
// wait ( 0 0$1 ) ;
29233: LD_INT 35
29235: PPUSH
29236: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29240: LD_INT 22
29242: PUSH
29243: LD_INT 3
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: PUSH
29250: LD_INT 21
29252: PUSH
29253: LD_INT 1
29255: PUSH
29256: EMPTY
29257: LIST
29258: LIST
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: PPUSH
29264: CALL_OW 69
29268: PPUSH
29269: LD_INT 25
29271: PPUSH
29272: CALL_OW 173
// wait ( 0 0$10 ) ;
29276: LD_INT 350
29278: PPUSH
29279: CALL_OW 67
// PrepareOmarInvasion ;
29283: CALL 13740 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29287: LD_ADDR_VAR 0 2
29291: PUSH
29292: LD_EXP 91
29296: PPUSH
29297: CALL_OW 250
29301: PUSH
29302: LD_EXP 91
29306: PPUSH
29307: CALL_OW 251
29311: PUSH
29312: EMPTY
29313: LIST
29314: LIST
29315: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29316: LD_VAR 0 2
29320: PUSH
29321: LD_INT 1
29323: ARRAY
29324: PPUSH
29325: LD_VAR 0 2
29329: PUSH
29330: LD_INT 2
29332: ARRAY
29333: PPUSH
29334: LD_INT 1
29336: PPUSH
29337: LD_INT 8
29339: NEG
29340: PPUSH
29341: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29345: LD_EXP 91
29349: PPUSH
29350: CALL_OW 87
// DialogueOn ;
29354: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29358: LD_EXP 38
29362: PPUSH
29363: LD_STRING D19-JMM-1
29365: PPUSH
29366: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29370: LD_ADDR_VAR 0 3
29374: PUSH
29375: LD_INT 22
29377: PUSH
29378: LD_INT 1
29380: PUSH
29381: EMPTY
29382: LIST
29383: LIST
29384: PUSH
29385: LD_INT 26
29387: PUSH
29388: LD_INT 1
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 2
29397: PUSH
29398: LD_INT 25
29400: PUSH
29401: LD_INT 1
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 25
29410: PUSH
29411: LD_INT 2
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 25
29420: PUSH
29421: LD_INT 3
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 25
29430: PUSH
29431: LD_INT 4
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: LD_INT 25
29440: PUSH
29441: LD_INT 5
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: LD_INT 25
29450: PUSH
29451: LD_INT 8
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: EMPTY
29459: LIST
29460: LIST
29461: LIST
29462: LIST
29463: LIST
29464: LIST
29465: LIST
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: LIST
29471: PPUSH
29472: CALL_OW 69
29476: PUSH
29477: LD_EXP 38
29481: PUSH
29482: LD_EXP 39
29486: PUSH
29487: LD_EXP 40
29491: PUSH
29492: LD_EXP 41
29496: PUSH
29497: LD_EXP 42
29501: PUSH
29502: LD_EXP 43
29506: PUSH
29507: LD_EXP 44
29511: PUSH
29512: LD_EXP 45
29516: PUSH
29517: LD_EXP 46
29521: PUSH
29522: LD_EXP 47
29526: PUSH
29527: LD_EXP 48
29531: PUSH
29532: LD_EXP 49
29536: PUSH
29537: LD_EXP 50
29541: PUSH
29542: LD_EXP 51
29546: PUSH
29547: LD_EXP 52
29551: PUSH
29552: LD_EXP 53
29556: PUSH
29557: LD_EXP 54
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: LIST
29566: LIST
29567: LIST
29568: LIST
29569: LIST
29570: LIST
29571: LIST
29572: LIST
29573: LIST
29574: LIST
29575: LIST
29576: LIST
29577: LIST
29578: LIST
29579: LIST
29580: DIFF
29581: ST_TO_ADDR
// if tmp2 then
29582: LD_VAR 0 3
29586: IFFALSE 29604
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29588: LD_VAR 0 3
29592: PUSH
29593: LD_INT 1
29595: ARRAY
29596: PPUSH
29597: LD_STRING D19-Sol1-1
29599: PPUSH
29600: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29604: LD_EXP 38
29608: PPUSH
29609: LD_STRING D19-JMM-2
29611: PPUSH
29612: CALL_OW 88
// DialogueOff ;
29616: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29620: LD_VAR 0 2
29624: PUSH
29625: LD_INT 1
29627: ARRAY
29628: PPUSH
29629: LD_VAR 0 2
29633: PUSH
29634: LD_INT 2
29636: ARRAY
29637: PPUSH
29638: LD_INT 1
29640: PPUSH
29641: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29645: LD_STRING M5
29647: PPUSH
29648: CALL_OW 337
// omarOnMotherLode := false ;
29652: LD_ADDR_VAR 0 4
29656: PUSH
29657: LD_INT 0
29659: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29660: LD_INT 35
29662: PPUSH
29663: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29667: LD_EXP 91
29671: PPUSH
29672: LD_INT 215
29674: PPUSH
29675: LD_INT 100
29677: PPUSH
29678: CALL_OW 297
29682: PUSH
29683: LD_INT 10
29685: LESS
29686: PUSH
29687: LD_VAR 0 4
29691: NOT
29692: AND
29693: IFFALSE 29727
// begin omarOnMotherLode := true ;
29695: LD_ADDR_VAR 0 4
29699: PUSH
29700: LD_INT 1
29702: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29703: LD_EXP 38
29707: PPUSH
29708: LD_STRING D19b-JMM-1
29710: PPUSH
29711: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29715: LD_EXP 91
29719: PPUSH
29720: LD_STRING DOmarContam-Omar-1
29722: PPUSH
29723: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29727: LD_EXP 91
29731: PPUSH
29732: CALL_OW 301
29736: IFFALSE 29660
// Say ( JMM , D19a-JMM-1 ) ;
29738: LD_EXP 38
29742: PPUSH
29743: LD_STRING D19a-JMM-1
29745: PPUSH
29746: CALL_OW 88
// if Heike then
29750: LD_EXP 92
29754: IFFALSE 29768
// Say ( Heike , D19a-Hke-1 ) ;
29756: LD_EXP 92
29760: PPUSH
29761: LD_STRING D19a-Hke-1
29763: PPUSH
29764: CALL_OW 88
// end ;
29768: PPOPN 4
29770: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29771: LD_INT 22
29773: PUSH
29774: LD_INT 3
29776: PUSH
29777: EMPTY
29778: LIST
29779: LIST
29780: PUSH
29781: LD_INT 21
29783: PUSH
29784: LD_INT 1
29786: PUSH
29787: EMPTY
29788: LIST
29789: LIST
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PPUSH
29795: CALL_OW 69
29799: PUSH
29800: LD_EXP 21
29804: AND
29805: IFFALSE 29873
29807: GO 29809
29809: DISABLE
29810: LD_INT 0
29812: PPUSH
29813: PPUSH
// begin enable ;
29814: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29815: LD_ADDR_VAR 0 2
29819: PUSH
29820: LD_INT 25
29822: PPUSH
29823: LD_INT 22
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PPUSH
29833: CALL_OW 70
29837: ST_TO_ADDR
// if not tmp then
29838: LD_VAR 0 2
29842: NOT
29843: IFFALSE 29847
// exit ;
29845: GO 29873
// for i in tmp do
29847: LD_ADDR_VAR 0 1
29851: PUSH
29852: LD_VAR 0 2
29856: PUSH
29857: FOR_IN
29858: IFFALSE 29871
// RemoveUnit ( i ) ;
29860: LD_VAR 0 1
29864: PPUSH
29865: CALL_OW 64
29869: GO 29857
29871: POP
29872: POP
// end ;
29873: PPOPN 2
29875: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29876: LD_INT 22
29878: PUSH
29879: LD_INT 7
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: PUSH
29886: LD_INT 21
29888: PUSH
29889: LD_INT 1
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: PPUSH
29900: CALL_OW 69
29904: PUSH
29905: LD_INT 6
29907: LESS
29908: IFFALSE 30376
29910: GO 29912
29912: DISABLE
29913: LD_INT 0
29915: PPUSH
29916: PPUSH
// begin MC_Kill ( 1 ) ;
29917: LD_INT 1
29919: PPUSH
29920: CALL 34469 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29924: LD_INT 7
29926: PPUSH
29927: LD_INT 1
29929: PPUSH
29930: LD_INT 1
29932: PPUSH
29933: LD_INT 1
29935: PPUSH
29936: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29940: LD_ADDR_VAR 0 1
29944: PUSH
29945: LD_INT 22
29947: PUSH
29948: LD_INT 7
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 26
29957: PUSH
29958: LD_INT 1
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PPUSH
29969: CALL_OW 69
29973: PUSH
29974: LD_EXP 73
29978: DIFF
29979: ST_TO_ADDR
// if tmp then
29980: LD_VAR 0 1
29984: IFFALSE 30002
// tmp := tmp [ 1 ] else
29986: LD_ADDR_VAR 0 1
29990: PUSH
29991: LD_VAR 0 1
29995: PUSH
29996: LD_INT 1
29998: ARRAY
29999: ST_TO_ADDR
30000: GO 30038
// begin uc_side := 7 ;
30002: LD_ADDR_OWVAR 20
30006: PUSH
30007: LD_INT 7
30009: ST_TO_ADDR
// uc_nation := 1 ;
30010: LD_ADDR_OWVAR 21
30014: PUSH
30015: LD_INT 1
30017: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30018: LD_INT 1
30020: PPUSH
30021: LD_INT 8
30023: PPUSH
30024: CALL_OW 384
// tmp := CreateHuman ;
30028: LD_ADDR_VAR 0 1
30032: PUSH
30033: CALL_OW 44
30037: ST_TO_ADDR
// end ; DialogueOn ;
30038: CALL_OW 6
// if IsOK ( Roth ) then
30042: LD_EXP 73
30046: PPUSH
30047: CALL_OW 302
30051: IFFALSE 30065
// Say ( JMM , DAb-JMM-1 ) ;
30053: LD_EXP 38
30057: PPUSH
30058: LD_STRING DAb-JMM-1
30060: PPUSH
30061: CALL_OW 88
// if IsOK ( Roth ) then
30065: LD_EXP 73
30069: PPUSH
30070: CALL_OW 302
30074: IFFALSE 30098
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30076: LD_EXP 73
30080: PPUSH
30081: LD_STRING DSurrenderAlliance-Roth-1
30083: PPUSH
30084: CALL_OW 88
// RothCaptured := true ;
30088: LD_ADDR_EXP 33
30092: PUSH
30093: LD_INT 1
30095: ST_TO_ADDR
// end else
30096: GO 30110
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30098: LD_VAR 0 1
30102: PPUSH
30103: LD_STRING DSurrenderAlliance-Sci1-1
30105: PPUSH
30106: CALL_OW 88
// DialogueOff ;
30110: CALL_OW 7
// allianceDestroyed := true ;
30114: LD_ADDR_EXP 23
30118: PUSH
30119: LD_INT 1
30121: ST_TO_ADDR
// if capturedUnit = 0 then
30122: LD_EXP 34
30126: PUSH
30127: LD_INT 0
30129: EQUAL
30130: IFFALSE 30139
// SetAchievement ( ACH_ALLIANCE ) ;
30132: LD_STRING ACH_ALLIANCE
30134: PPUSH
30135: CALL_OW 543
// if trueAmericans then
30139: LD_EXP 35
30143: IFFALSE 30219
// begin if trueAmericans = 1 then
30145: LD_EXP 35
30149: PUSH
30150: LD_INT 1
30152: EQUAL
30153: IFFALSE 30169
// Say ( JMM , DAb-JMM-1a ) else
30155: LD_EXP 38
30159: PPUSH
30160: LD_STRING DAb-JMM-1a
30162: PPUSH
30163: CALL_OW 88
30167: GO 30181
// Say ( JMM , DAb-JMM-1b ) ;
30169: LD_EXP 38
30173: PPUSH
30174: LD_STRING DAb-JMM-1b
30176: PPUSH
30177: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30181: LD_EXP 35
30185: PPUSH
30186: CALL_OW 87
// for i in trueAmericans do
30190: LD_ADDR_VAR 0 2
30194: PUSH
30195: LD_EXP 35
30199: PUSH
30200: FOR_IN
30201: IFFALSE 30217
// SetSide ( i , 1 ) ;
30203: LD_VAR 0 2
30207: PPUSH
30208: LD_INT 1
30210: PPUSH
30211: CALL_OW 235
30215: GO 30200
30217: POP
30218: POP
// end ; repeat wait ( 0 0$1 ) ;
30219: LD_INT 35
30221: PPUSH
30222: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30226: LD_ADDR_VAR 0 2
30230: PUSH
30231: LD_INT 22
30233: PUSH
30234: LD_INT 7
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: PUSH
30241: LD_INT 21
30243: PUSH
30244: LD_INT 1
30246: PUSH
30247: EMPTY
30248: LIST
30249: LIST
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PPUSH
30255: CALL_OW 69
30259: PUSH
30260: FOR_IN
30261: IFFALSE 30343
// begin if IsInUnit ( i ) then
30263: LD_VAR 0 2
30267: PPUSH
30268: CALL_OW 310
30272: IFFALSE 30283
// ComExitBuilding ( i ) ;
30274: LD_VAR 0 2
30278: PPUSH
30279: CALL_OW 122
// if IsDriver ( i ) then
30283: LD_VAR 0 2
30287: PPUSH
30288: CALL 104861 0 1
30292: IFFALSE 30303
// ComExitVehicle ( i ) ;
30294: LD_VAR 0 2
30298: PPUSH
30299: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30303: LD_VAR 0 2
30307: PPUSH
30308: LD_INT 26
30310: PPUSH
30311: CALL_OW 308
30315: NOT
30316: IFFALSE 30332
// AddComMoveToArea ( i , allianceEscapeArea ) else
30318: LD_VAR 0 2
30322: PPUSH
30323: LD_INT 26
30325: PPUSH
30326: CALL_OW 173
30330: GO 30341
// RemoveUnit ( i ) ;
30332: LD_VAR 0 2
30336: PPUSH
30337: CALL_OW 64
// end ;
30341: GO 30260
30343: POP
30344: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30345: LD_INT 22
30347: PUSH
30348: LD_INT 7
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 21
30357: PUSH
30358: LD_INT 1
30360: PUSH
30361: EMPTY
30362: LIST
30363: LIST
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: PPUSH
30369: CALL_OW 69
30373: NOT
30374: IFFALSE 30219
// end ;
30376: PPOPN 2
30378: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30379: LD_INT 0
30381: PPUSH
30382: PPUSH
// if not unit then
30383: LD_VAR 0 1
30387: NOT
30388: IFFALSE 30392
// exit ;
30390: GO 31890
// DoNotAttack ( 7 , unit ) ;
30392: LD_INT 7
30394: PPUSH
30395: LD_VAR 0 1
30399: PPUSH
30400: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30404: LD_VAR 0 1
30408: PPUSH
30409: LD_INT 260
30411: PPUSH
30412: LD_INT 235
30414: PPUSH
30415: LD_INT 3
30417: PPUSH
30418: LD_INT 1
30420: PPUSH
30421: CALL_OW 483
// SetSide ( unit , 4 ) ;
30425: LD_VAR 0 1
30429: PPUSH
30430: LD_INT 4
30432: PPUSH
30433: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30437: LD_ADDR_EXP 34
30441: PUSH
30442: LD_EXP 34
30446: PUSH
30447: LD_INT 1
30449: PLUS
30450: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30451: LD_INT 70
30453: PPUSH
30454: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30458: LD_INT 260
30460: PPUSH
30461: LD_INT 235
30463: PPUSH
30464: LD_INT 1
30466: PPUSH
30467: LD_INT 8
30469: NEG
30470: PPUSH
30471: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30475: LD_VAR 0 1
30479: PPUSH
30480: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30484: LD_VAR 0 1
30488: PPUSH
30489: LD_EXP 73
30493: PPUSH
30494: CALL_OW 119
// DialogueOn ;
30498: CALL_OW 6
// case unit of JMM :
30502: LD_VAR 0 1
30506: PUSH
30507: LD_EXP 38
30511: DOUBLE
30512: EQUAL
30513: IFTRUE 30517
30515: GO 30532
30517: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30518: LD_EXP 38
30522: PPUSH
30523: LD_STRING DA1-JMM-1
30525: PPUSH
30526: CALL_OW 91
30530: GO 30974
30532: LD_EXP 39
30536: DOUBLE
30537: EQUAL
30538: IFTRUE 30542
30540: GO 30557
30542: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30543: LD_EXP 39
30547: PPUSH
30548: LD_STRING DA1-Joan-1
30550: PPUSH
30551: CALL_OW 91
30555: GO 30974
30557: LD_EXP 41
30561: DOUBLE
30562: EQUAL
30563: IFTRUE 30567
30565: GO 30582
30567: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30568: LD_EXP 41
30572: PPUSH
30573: LD_STRING DA1-Lisa-1
30575: PPUSH
30576: CALL_OW 91
30580: GO 30974
30582: LD_EXP 42
30586: DOUBLE
30587: EQUAL
30588: IFTRUE 30592
30590: GO 30607
30592: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30593: LD_EXP 42
30597: PPUSH
30598: LD_STRING DA1-Don-1
30600: PPUSH
30601: CALL_OW 91
30605: GO 30974
30607: LD_EXP 49
30611: DOUBLE
30612: EQUAL
30613: IFTRUE 30617
30615: GO 30632
30617: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30618: LD_EXP 49
30622: PPUSH
30623: LD_STRING DA1-Corn-1
30625: PPUSH
30626: CALL_OW 91
30630: GO 30974
30632: LD_EXP 45
30636: DOUBLE
30637: EQUAL
30638: IFTRUE 30642
30640: GO 30657
30642: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30643: LD_EXP 45
30647: PPUSH
30648: LD_STRING DA1-Den-1
30650: PPUSH
30651: CALL_OW 91
30655: GO 30974
30657: LD_EXP 43
30661: DOUBLE
30662: EQUAL
30663: IFTRUE 30667
30665: GO 30682
30667: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30668: LD_EXP 43
30672: PPUSH
30673: LD_STRING DA1-Bobby-1
30675: PPUSH
30676: CALL_OW 91
30680: GO 30974
30682: LD_EXP 47
30686: DOUBLE
30687: EQUAL
30688: IFTRUE 30692
30690: GO 30707
30692: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30693: LD_EXP 47
30697: PPUSH
30698: LD_STRING DA1-Glad-1
30700: PPUSH
30701: CALL_OW 91
30705: GO 30974
30707: LD_EXP 44
30711: DOUBLE
30712: EQUAL
30713: IFTRUE 30717
30715: GO 30732
30717: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30718: LD_EXP 44
30722: PPUSH
30723: LD_STRING DA1-Cyrus-1
30725: PPUSH
30726: CALL_OW 91
30730: GO 30974
30732: LD_EXP 40
30736: DOUBLE
30737: EQUAL
30738: IFTRUE 30742
30740: GO 30757
30742: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30743: LD_EXP 40
30747: PPUSH
30748: LD_STRING DA1-Huck-1
30750: PPUSH
30751: CALL_OW 91
30755: GO 30974
30757: LD_EXP 54
30761: DOUBLE
30762: EQUAL
30763: IFTRUE 30767
30765: GO 30782
30767: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30768: LD_EXP 54
30772: PPUSH
30773: LD_STRING DA1-Huck-1
30775: PPUSH
30776: CALL_OW 91
30780: GO 30974
30782: LD_EXP 46
30786: DOUBLE
30787: EQUAL
30788: IFTRUE 30792
30790: GO 30807
30792: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30793: LD_EXP 46
30797: PPUSH
30798: LD_STRING DA1-Brown-1
30800: PPUSH
30801: CALL_OW 91
30805: GO 30974
30807: LD_EXP 50
30811: DOUBLE
30812: EQUAL
30813: IFTRUE 30817
30815: GO 30832
30817: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30818: LD_EXP 50
30822: PPUSH
30823: LD_STRING DA1-Gary-1
30825: PPUSH
30826: CALL_OW 91
30830: GO 30974
30832: LD_EXP 53
30836: DOUBLE
30837: EQUAL
30838: IFTRUE 30842
30840: GO 30857
30842: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30843: LD_EXP 53
30847: PPUSH
30848: LD_STRING DA1-Con-1
30850: PPUSH
30851: CALL_OW 91
30855: GO 30974
30857: LD_EXP 59
30861: DOUBLE
30862: EQUAL
30863: IFTRUE 30867
30865: GO 30882
30867: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30868: LD_EXP 59
30872: PPUSH
30873: LD_STRING DA1-Kurt-1
30875: PPUSH
30876: CALL_OW 91
30880: GO 30974
30882: LD_EXP 52
30886: DOUBLE
30887: EQUAL
30888: IFTRUE 30892
30890: GO 30907
30892: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30893: LD_EXP 52
30897: PPUSH
30898: LD_STRING DA1-Yam-1
30900: PPUSH
30901: CALL_OW 91
30905: GO 30974
30907: LD_EXP 51
30911: DOUBLE
30912: EQUAL
30913: IFTRUE 30917
30915: GO 30932
30917: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30918: LD_EXP 51
30922: PPUSH
30923: LD_STRING DA1-Frank-1
30925: PPUSH
30926: CALL_OW 91
30930: GO 30974
30932: POP
// begin if GetSex ( unit ) = sex_male then
30933: LD_VAR 0 1
30937: PPUSH
30938: CALL_OW 258
30942: PUSH
30943: LD_INT 1
30945: EQUAL
30946: IFFALSE 30962
// ForceSay ( unit , DA1-Sol1-1 ) else
30948: LD_VAR 0 1
30952: PPUSH
30953: LD_STRING DA1-Sol1-1
30955: PPUSH
30956: CALL_OW 91
30960: GO 30974
// ForceSay ( unit , DA1-FSol1-1 ) ;
30962: LD_VAR 0 1
30966: PPUSH
30967: LD_STRING DA1-FSol1-1
30969: PPUSH
30970: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30974: LD_EXP 73
30978: PPUSH
30979: LD_STRING DA-Roth-1
30981: PPUSH
30982: CALL_OW 88
// if capturedUnit = 1 then
30986: LD_EXP 34
30990: PUSH
30991: LD_INT 1
30993: EQUAL
30994: IFFALSE 31022
// begin Say ( Simms , DA-Sim-1 ) ;
30996: LD_EXP 74
31000: PPUSH
31001: LD_STRING DA-Sim-1
31003: PPUSH
31004: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31008: LD_EXP 73
31012: PPUSH
31013: LD_STRING DA-Roth-2
31015: PPUSH
31016: CALL_OW 88
// end else
31020: GO 31034
// Say ( Simms , DA-Sim-2 ) ;
31022: LD_EXP 74
31026: PPUSH
31027: LD_STRING DA-Sim-2
31029: PPUSH
31030: CALL_OW 88
// case unit of JMM :
31034: LD_VAR 0 1
31038: PUSH
31039: LD_EXP 38
31043: DOUBLE
31044: EQUAL
31045: IFTRUE 31049
31047: GO 31064
31049: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31050: LD_EXP 38
31054: PPUSH
31055: LD_STRING DA1-JMM-1a
31057: PPUSH
31058: CALL_OW 91
31062: GO 31571
31064: LD_EXP 39
31068: DOUBLE
31069: EQUAL
31070: IFTRUE 31074
31072: GO 31089
31074: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31075: LD_EXP 39
31079: PPUSH
31080: LD_STRING DA1-Joan-1a
31082: PPUSH
31083: CALL_OW 91
31087: GO 31571
31089: LD_EXP 41
31093: DOUBLE
31094: EQUAL
31095: IFTRUE 31099
31097: GO 31114
31099: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31100: LD_EXP 41
31104: PPUSH
31105: LD_STRING DA1-Lisa-1a
31107: PPUSH
31108: CALL_OW 91
31112: GO 31571
31114: LD_EXP 42
31118: DOUBLE
31119: EQUAL
31120: IFTRUE 31124
31122: GO 31139
31124: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31125: LD_EXP 42
31129: PPUSH
31130: LD_STRING DA1-Don-1a
31132: PPUSH
31133: CALL_OW 91
31137: GO 31571
31139: LD_EXP 49
31143: DOUBLE
31144: EQUAL
31145: IFTRUE 31149
31147: GO 31164
31149: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31150: LD_EXP 49
31154: PPUSH
31155: LD_STRING DA1-Corn-1a
31157: PPUSH
31158: CALL_OW 91
31162: GO 31571
31164: LD_EXP 45
31168: DOUBLE
31169: EQUAL
31170: IFTRUE 31174
31172: GO 31189
31174: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31175: LD_EXP 45
31179: PPUSH
31180: LD_STRING DA1-Den-1a
31182: PPUSH
31183: CALL_OW 91
31187: GO 31571
31189: LD_EXP 43
31193: DOUBLE
31194: EQUAL
31195: IFTRUE 31199
31197: GO 31214
31199: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31200: LD_EXP 43
31204: PPUSH
31205: LD_STRING DA1-Bobby-1a
31207: PPUSH
31208: CALL_OW 91
31212: GO 31571
31214: LD_EXP 47
31218: DOUBLE
31219: EQUAL
31220: IFTRUE 31224
31222: GO 31239
31224: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31225: LD_EXP 47
31229: PPUSH
31230: LD_STRING DA1-Glad-1a
31232: PPUSH
31233: CALL_OW 91
31237: GO 31571
31239: LD_EXP 44
31243: DOUBLE
31244: EQUAL
31245: IFTRUE 31249
31247: GO 31264
31249: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31250: LD_EXP 44
31254: PPUSH
31255: LD_STRING DA1-Cyrus-1a
31257: PPUSH
31258: CALL_OW 91
31262: GO 31571
31264: LD_EXP 40
31268: DOUBLE
31269: EQUAL
31270: IFTRUE 31274
31272: GO 31289
31274: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31275: LD_EXP 40
31279: PPUSH
31280: LD_STRING DA1-Huck-1a
31282: PPUSH
31283: CALL_OW 91
31287: GO 31571
31289: LD_EXP 54
31293: DOUBLE
31294: EQUAL
31295: IFTRUE 31299
31297: GO 31314
31299: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31300: LD_EXP 54
31304: PPUSH
31305: LD_STRING DA1-Huck-1a
31307: PPUSH
31308: CALL_OW 91
31312: GO 31571
31314: LD_EXP 46
31318: DOUBLE
31319: EQUAL
31320: IFTRUE 31324
31322: GO 31339
31324: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31325: LD_EXP 46
31329: PPUSH
31330: LD_STRING DA1-Brown-1a
31332: PPUSH
31333: CALL_OW 91
31337: GO 31571
31339: LD_EXP 50
31343: DOUBLE
31344: EQUAL
31345: IFTRUE 31349
31347: GO 31364
31349: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31350: LD_EXP 50
31354: PPUSH
31355: LD_STRING DA1-Gary-1a
31357: PPUSH
31358: CALL_OW 91
31362: GO 31571
31364: LD_EXP 53
31368: DOUBLE
31369: EQUAL
31370: IFTRUE 31374
31372: GO 31389
31374: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31375: LD_EXP 53
31379: PPUSH
31380: LD_STRING DA1-Con-1a
31382: PPUSH
31383: CALL_OW 91
31387: GO 31571
31389: LD_EXP 59
31393: DOUBLE
31394: EQUAL
31395: IFTRUE 31399
31397: GO 31414
31399: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31400: LD_EXP 59
31404: PPUSH
31405: LD_STRING DA1-Kurt-1a
31407: PPUSH
31408: CALL_OW 91
31412: GO 31571
31414: LD_EXP 52
31418: DOUBLE
31419: EQUAL
31420: IFTRUE 31424
31422: GO 31439
31424: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31425: LD_EXP 52
31429: PPUSH
31430: LD_STRING DA1-Yam-1a
31432: PPUSH
31433: CALL_OW 91
31437: GO 31571
31439: LD_EXP 51
31443: DOUBLE
31444: EQUAL
31445: IFTRUE 31449
31447: GO 31464
31449: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31450: LD_EXP 51
31454: PPUSH
31455: LD_STRING DA1-Frank-1a
31457: PPUSH
31458: CALL_OW 91
31462: GO 31571
31464: POP
// begin join := rand ( 0 , 1 ) ;
31465: LD_ADDR_VAR 0 3
31469: PUSH
31470: LD_INT 0
31472: PPUSH
31473: LD_INT 1
31475: PPUSH
31476: CALL_OW 12
31480: ST_TO_ADDR
// if join then
31481: LD_VAR 0 3
31485: IFFALSE 31530
// begin if GetSex ( unit ) = sex_male then
31487: LD_VAR 0 1
31491: PPUSH
31492: CALL_OW 258
31496: PUSH
31497: LD_INT 1
31499: EQUAL
31500: IFFALSE 31516
// ForceSay ( unit , DA1-Sol1-1b ) else
31502: LD_VAR 0 1
31506: PPUSH
31507: LD_STRING DA1-Sol1-1b
31509: PPUSH
31510: CALL_OW 91
31514: GO 31528
// ForceSay ( unit , DA1-FSol1-1b ) ;
31516: LD_VAR 0 1
31520: PPUSH
31521: LD_STRING DA1-FSol1-1b
31523: PPUSH
31524: CALL_OW 91
// end else
31528: GO 31571
// begin if GetSex ( unit ) = sex_male then
31530: LD_VAR 0 1
31534: PPUSH
31535: CALL_OW 258
31539: PUSH
31540: LD_INT 1
31542: EQUAL
31543: IFFALSE 31559
// ForceSay ( unit , DA1-Sol1-1a ) else
31545: LD_VAR 0 1
31549: PPUSH
31550: LD_STRING DA1-Sol1-1a
31552: PPUSH
31553: CALL_OW 91
31557: GO 31571
// ForceSay ( unit , DA1-FSol1-1a ) ;
31559: LD_VAR 0 1
31563: PPUSH
31564: LD_STRING DA1-FSol1-1a
31566: PPUSH
31567: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31571: LD_VAR 0 1
31575: PUSH
31576: LD_EXP 38
31580: EQUAL
31581: IFFALSE 31592
// begin YouLost ( JMMCaptured ) ;
31583: LD_STRING JMMCaptured
31585: PPUSH
31586: CALL_OW 104
// exit ;
31590: GO 31890
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31592: LD_VAR 0 1
31596: PUSH
31597: LD_EXP 42
31601: PUSH
31602: LD_EXP 45
31606: PUSH
31607: LD_EXP 43
31611: PUSH
31612: LD_EXP 40
31616: PUSH
31617: LD_EXP 54
31621: PUSH
31622: LD_EXP 46
31626: PUSH
31627: LD_EXP 52
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: IN
31641: PUSH
31642: LD_VAR 0 3
31646: OR
31647: IFFALSE 31746
// begin Say ( Roth , DA-Roth-3 ) ;
31649: LD_EXP 73
31653: PPUSH
31654: LD_STRING DA-Roth-3
31656: PPUSH
31657: CALL_OW 88
// SetSide ( unit , 7 ) ;
31661: LD_VAR 0 1
31665: PPUSH
31666: LD_INT 7
31668: PPUSH
31669: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31673: LD_ADDR_EXP 101
31677: PUSH
31678: LD_EXP 101
31682: PPUSH
31683: LD_INT 1
31685: PPUSH
31686: LD_EXP 101
31690: PUSH
31691: LD_INT 1
31693: ARRAY
31694: PUSH
31695: LD_VAR 0 1
31699: ADD
31700: PPUSH
31701: CALL_OW 1
31705: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31706: LD_INT 260
31708: PPUSH
31709: LD_INT 235
31711: PPUSH
31712: LD_INT 1
31714: PPUSH
31715: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31719: LD_VAR 0 1
31723: PPUSH
31724: LD_INT 1000
31726: PPUSH
31727: CALL_OW 234
// DialogueOff ;
31731: CALL_OW 7
// ComFree ( unit ) ;
31735: LD_VAR 0 1
31739: PPUSH
31740: CALL_OW 139
// end else
31744: GO 31827
// begin Say ( Roth , DA-Roth-3a ) ;
31746: LD_EXP 73
31750: PPUSH
31751: LD_STRING DA-Roth-3a
31753: PPUSH
31754: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31758: LD_ADDR_EXP 35
31762: PUSH
31763: LD_EXP 35
31767: PUSH
31768: LD_VAR 0 1
31772: ADD
31773: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31774: LD_INT 260
31776: PPUSH
31777: LD_INT 235
31779: PPUSH
31780: LD_INT 1
31782: PPUSH
31783: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31787: LD_VAR 0 1
31791: PPUSH
31792: LD_INT 1000
31794: PPUSH
31795: CALL_OW 234
// DialogueOff ;
31799: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31803: LD_VAR 0 1
31807: PPUSH
31808: LD_INT 272
31810: PPUSH
31811: LD_INT 254
31813: PPUSH
31814: CALL_OW 111
// AddComHold ( unit ) ;
31818: LD_VAR 0 1
31822: PPUSH
31823: CALL_OW 200
// end ; if capturedUnit = 1 then
31827: LD_EXP 34
31831: PUSH
31832: LD_INT 1
31834: EQUAL
31835: IFFALSE 31890
// begin DialogueOn ;
31837: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31841: LD_EXP 38
31845: PPUSH
31846: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31850: LD_EXP 38
31854: PPUSH
31855: LD_STRING DAa-JMM-1
31857: PPUSH
31858: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31862: LD_EXP 38
31866: PPUSH
31867: LD_STRING DAa-JMM-1a
31869: PPUSH
31870: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31874: LD_EXP 38
31878: PPUSH
31879: LD_STRING DAa-JMM-1b
31881: PPUSH
31882: CALL_OW 88
// DialogueOff ;
31886: CALL_OW 7
// end ; end ;
31890: LD_VAR 0 2
31894: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31895: LD_EXP 15
31899: PUSH
31900: LD_INT 13
31902: GREATEREQUAL
31903: PUSH
31904: LD_INT 22
31906: PUSH
31907: LD_INT 2
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 21
31916: PUSH
31917: LD_INT 1
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PPUSH
31928: CALL_OW 69
31932: PUSH
31933: LD_INT 0
31935: EQUAL
31936: AND
31937: PUSH
31938: LD_INT 22
31940: PUSH
31941: LD_INT 2
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 21
31950: PUSH
31951: LD_INT 2
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 50
31960: PUSH
31961: EMPTY
31962: LIST
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: LIST
31968: PPUSH
31969: CALL_OW 69
31973: PUSH
31974: LD_INT 0
31976: EQUAL
31977: AND
31978: PUSH
31979: LD_EXP 21
31983: AND
31984: PUSH
31985: LD_EXP 22
31989: AND
31990: PUSH
31991: LD_EXP 23
31995: AND
31996: IFFALSE 32638
31998: GO 32000
32000: DISABLE
32001: LD_INT 0
32003: PPUSH
32004: PPUSH
32005: PPUSH
// begin m1 := false ;
32006: LD_ADDR_VAR 0 1
32010: PUSH
32011: LD_INT 0
32013: ST_TO_ADDR
// m2 := false ;
32014: LD_ADDR_VAR 0 2
32018: PUSH
32019: LD_INT 0
32021: ST_TO_ADDR
// m3 := false ;
32022: LD_ADDR_VAR 0 3
32026: PUSH
32027: LD_INT 0
32029: ST_TO_ADDR
// if not bombExploded then
32030: LD_EXP 37
32034: NOT
32035: IFFALSE 32044
// SetAchievement ( ACH_SIBROCKET ) ;
32037: LD_STRING ACH_SIBROCKET
32039: PPUSH
32040: CALL_OW 543
// if tick <= 120 120$00 then
32044: LD_OWVAR 1
32048: PUSH
32049: LD_INT 252000
32051: LESSEQUAL
32052: IFFALSE 32068
// begin wait ( 3 ) ;
32054: LD_INT 3
32056: PPUSH
32057: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32061: LD_STRING ACH_ASPEED_15
32063: PPUSH
32064: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32068: LD_EXP 38
32072: PPUSH
32073: CALL_OW 87
// music_class := 5 ;
32077: LD_ADDR_OWVAR 72
32081: PUSH
32082: LD_INT 5
32084: ST_TO_ADDR
// music_nat := 5 ;
32085: LD_ADDR_OWVAR 71
32089: PUSH
32090: LD_INT 5
32092: ST_TO_ADDR
// DialogueOn ;
32093: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32097: LD_EXP 38
32101: PPUSH
32102: LD_STRING D20-JMM-1
32104: PPUSH
32105: CALL_OW 88
// if IsOK ( Joan ) then
32109: LD_EXP 39
32113: PPUSH
32114: CALL_OW 302
32118: IFFALSE 32132
// Say ( Joan , D20-Joan-1 ) ;
32120: LD_EXP 39
32124: PPUSH
32125: LD_STRING D20-Joan-1
32127: PPUSH
32128: CALL_OW 88
// if IsOk ( Lisa ) then
32132: LD_EXP 41
32136: PPUSH
32137: CALL_OW 302
32141: IFFALSE 32155
// Say ( Lisa , D20-Lisa-1 ) ;
32143: LD_EXP 41
32147: PPUSH
32148: LD_STRING D20-Lisa-1
32150: PPUSH
32151: CALL_OW 88
// if IsOk ( Donaldson ) then
32155: LD_EXP 42
32159: PPUSH
32160: CALL_OW 302
32164: IFFALSE 32178
// Say ( Donaldson , D20-Don-1 ) ;
32166: LD_EXP 42
32170: PPUSH
32171: LD_STRING D20-Don-1
32173: PPUSH
32174: CALL_OW 88
// if IsOK ( Cornel ) then
32178: LD_EXP 49
32182: PPUSH
32183: CALL_OW 302
32187: IFFALSE 32201
// Say ( Cornel , D20-Corn-1 ) ;
32189: LD_EXP 49
32193: PPUSH
32194: LD_STRING D20-Corn-1
32196: PPUSH
32197: CALL_OW 88
// if IsOk ( Denis ) then
32201: LD_EXP 45
32205: PPUSH
32206: CALL_OW 302
32210: IFFALSE 32224
// Say ( Denis , D20-Den-1 ) ;
32212: LD_EXP 45
32216: PPUSH
32217: LD_STRING D20-Den-1
32219: PPUSH
32220: CALL_OW 88
// if IsOk ( Bobby ) then
32224: LD_EXP 43
32228: PPUSH
32229: CALL_OW 302
32233: IFFALSE 32247
// Say ( Bobby , D20-Bobby-1 ) ;
32235: LD_EXP 43
32239: PPUSH
32240: LD_STRING D20-Bobby-1
32242: PPUSH
32243: CALL_OW 88
// if IsOk ( Gladstone ) then
32247: LD_EXP 47
32251: PPUSH
32252: CALL_OW 302
32256: IFFALSE 32270
// Say ( Gladstone , D20-Glad-1 ) ;
32258: LD_EXP 47
32262: PPUSH
32263: LD_STRING D20-Glad-1
32265: PPUSH
32266: CALL_OW 88
// if IsOk ( Cyrus ) then
32270: LD_EXP 44
32274: PPUSH
32275: CALL_OW 302
32279: IFFALSE 32293
// Say ( Cyrus , D20-Cyrus-1 ) ;
32281: LD_EXP 44
32285: PPUSH
32286: LD_STRING D20-Cyrus-1
32288: PPUSH
32289: CALL_OW 88
// if IsOk ( Stevens ) then
32293: LD_EXP 40
32297: PPUSH
32298: CALL_OW 302
32302: IFFALSE 32316
// Say ( Stevens , D20-Huck-1 ) ;
32304: LD_EXP 40
32308: PPUSH
32309: LD_STRING D20-Huck-1
32311: PPUSH
32312: CALL_OW 88
// if IsOk ( Brown ) then
32316: LD_EXP 46
32320: PPUSH
32321: CALL_OW 302
32325: IFFALSE 32339
// Say ( Brown , D20-Brown-1 ) ;
32327: LD_EXP 46
32331: PPUSH
32332: LD_STRING D20-Brown-1
32334: PPUSH
32335: CALL_OW 88
// if IsOk ( Gary ) then
32339: LD_EXP 50
32343: PPUSH
32344: CALL_OW 302
32348: IFFALSE 32362
// Say ( Gary , D20-Gary-1 ) ;
32350: LD_EXP 50
32354: PPUSH
32355: LD_STRING D20-Gary-1
32357: PPUSH
32358: CALL_OW 88
// if IsOk ( Connie ) then
32362: LD_EXP 53
32366: PPUSH
32367: CALL_OW 302
32371: IFFALSE 32385
// Say ( Connie , D20-Con-1 ) ;
32373: LD_EXP 53
32377: PPUSH
32378: LD_STRING D20-Con-1
32380: PPUSH
32381: CALL_OW 88
// if IsOk ( Kurt ) then
32385: LD_EXP 59
32389: PPUSH
32390: CALL_OW 302
32394: IFFALSE 32408
// Say ( Kurt , D20-Kurt-1 ) ;
32396: LD_EXP 59
32400: PPUSH
32401: LD_STRING D20-Kurt-1
32403: PPUSH
32404: CALL_OW 88
// if IsOk ( Kikuchi ) then
32408: LD_EXP 52
32412: PPUSH
32413: CALL_OW 302
32417: IFFALSE 32431
// Say ( Kikuchi , D20-Yam-1 ) ;
32419: LD_EXP 52
32423: PPUSH
32424: LD_STRING D20-Yam-1
32426: PPUSH
32427: CALL_OW 88
// if IsOk ( Frank ) then
32431: LD_EXP 51
32435: PPUSH
32436: CALL_OW 302
32440: IFFALSE 32454
// Say ( Frank , D20-Frank-1 ) ;
32442: LD_EXP 51
32446: PPUSH
32447: LD_STRING D20-Frank-1
32449: PPUSH
32450: CALL_OW 88
// DialogueOff ;
32454: CALL_OW 7
// if RothCaptured then
32458: LD_EXP 33
32462: IFFALSE 32484
// begin m1 := true ;
32464: LD_ADDR_VAR 0 1
32468: PUSH
32469: LD_INT 1
32471: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32472: LD_STRING Roth
32474: PPUSH
32475: LD_INT 1
32477: PPUSH
32478: CALL_OW 101
// end else
32482: GO 32495
// AddMedal ( Roth , - 1 ) ;
32484: LD_STRING Roth
32486: PPUSH
32487: LD_INT 1
32489: NEG
32490: PPUSH
32491: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32495: LD_EXP 27
32499: IFFALSE 32521
// begin m2 := true ;
32501: LD_ADDR_VAR 0 2
32505: PUSH
32506: LD_INT 1
32508: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32509: LD_STRING Project
32511: PPUSH
32512: LD_INT 1
32514: PPUSH
32515: CALL_OW 101
// end else
32519: GO 32532
// AddMedal ( Project , - 1 ) ;
32521: LD_STRING Project
32523: PPUSH
32524: LD_INT 1
32526: NEG
32527: PPUSH
32528: CALL_OW 101
// if lostCounter = 0 then
32532: LD_EXP 32
32536: PUSH
32537: LD_INT 0
32539: EQUAL
32540: IFFALSE 32562
// begin m3 := true ;
32542: LD_ADDR_VAR 0 3
32546: PUSH
32547: LD_INT 1
32549: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32550: LD_STRING NoLosses
32552: PPUSH
32553: LD_INT 1
32555: PPUSH
32556: CALL_OW 101
// end else
32560: GO 32573
// AddMedal ( NoLosses , - 1 ) ;
32562: LD_STRING NoLosses
32564: PPUSH
32565: LD_INT 1
32567: NEG
32568: PPUSH
32569: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32573: LD_VAR 0 1
32577: PUSH
32578: LD_VAR 0 2
32582: AND
32583: PUSH
32584: LD_VAR 0 3
32588: AND
32589: PUSH
32590: LD_OWVAR 67
32594: PUSH
32595: LD_INT 3
32597: EQUAL
32598: AND
32599: IFFALSE 32611
// SetAchievementEX ( ACH_AMER , 15 ) ;
32601: LD_STRING ACH_AMER
32603: PPUSH
32604: LD_INT 15
32606: PPUSH
32607: CALL_OW 564
// GiveMedals ( MAIN ) ;
32611: LD_STRING MAIN
32613: PPUSH
32614: CALL_OW 102
// music_class := 4 ;
32618: LD_ADDR_OWVAR 72
32622: PUSH
32623: LD_INT 4
32625: ST_TO_ADDR
// music_nat := 1 ;
32626: LD_ADDR_OWVAR 71
32630: PUSH
32631: LD_INT 1
32633: ST_TO_ADDR
// YouWin ;
32634: CALL_OW 103
// end ; end_of_file
32638: PPOPN 3
32640: END
// export function CustomEvent ( event ) ; begin
32641: LD_INT 0
32643: PPUSH
// end ;
32644: LD_VAR 0 2
32648: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32649: LD_VAR 0 1
32653: PUSH
32654: LD_INT 1
32656: EQUAL
32657: PUSH
32658: LD_VAR 0 2
32662: PUSH
32663: LD_INT 4
32665: EQUAL
32666: AND
32667: PUSH
32668: LD_EXP 57
32672: PPUSH
32673: CALL_OW 300
32677: AND
32678: IFFALSE 32694
// begin wait ( 0 0$2 ) ;
32680: LD_INT 70
32682: PPUSH
32683: CALL_OW 67
// YouLost ( Dismissed ) ;
32687: LD_STRING Dismissed
32689: PPUSH
32690: CALL_OW 104
// end ; end ;
32694: PPOPN 2
32696: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32697: LD_VAR 0 2
32701: PPUSH
32702: LD_VAR 0 3
32706: PPUSH
32707: LD_INT 18
32709: PPUSH
32710: CALL_OW 309
32714: IFFALSE 32723
// YouLost ( Motherlode3 ) ;
32716: LD_STRING Motherlode3
32718: PPUSH
32719: CALL_OW 104
// end ;
32723: PPOPN 3
32725: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32726: LD_EXP 27
32730: NOT
32731: IFFALSE 32741
// behemothDone := true ;
32733: LD_ADDR_EXP 28
32737: PUSH
32738: LD_INT 1
32740: ST_TO_ADDR
// end ;
32741: PPOPN 1
32743: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
32744: LD_VAR 0 1
32748: PPUSH
32749: CALL_OW 255
32753: PUSH
32754: LD_INT 1
32756: EQUAL
32757: IFFALSE 32767
// bombExploded := true ;
32759: LD_ADDR_EXP 37
32763: PUSH
32764: LD_INT 1
32766: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32767: LD_VAR 0 1
32771: PPUSH
32772: CALL_OW 255
32776: PUSH
32777: LD_INT 1
32779: EQUAL
32780: PUSH
32781: LD_EXP 30
32785: AND
32786: PUSH
32787: LD_INT 22
32789: PUSH
32790: LD_INT 3
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 34
32799: PUSH
32800: LD_INT 48
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PPUSH
32811: CALL_OW 69
32815: AND
32816: PUSH
32817: LD_INT 22
32819: PUSH
32820: LD_INT 1
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 34
32829: PUSH
32830: LD_INT 8
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PPUSH
32841: CALL_OW 69
32845: NOT
32846: AND
32847: IFFALSE 32899
// begin wait ( 0 0$5 ) ;
32849: LD_INT 175
32851: PPUSH
32852: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32856: LD_INT 22
32858: PUSH
32859: LD_INT 3
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 34
32868: PUSH
32869: LD_INT 48
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PPUSH
32880: CALL_OW 69
32884: PUSH
32885: LD_INT 1
32887: ARRAY
32888: PPUSH
32889: LD_INT 60
32891: PPUSH
32892: LD_INT 95
32894: PPUSH
32895: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32899: LD_VAR 0 2
32903: PPUSH
32904: LD_VAR 0 3
32908: PPUSH
32909: LD_INT 18
32911: PPUSH
32912: CALL_OW 309
32916: IFFALSE 32976
// begin if GetSide ( unit ) = 1 then
32918: LD_VAR 0 1
32922: PPUSH
32923: CALL_OW 255
32927: PUSH
32928: LD_INT 1
32930: EQUAL
32931: IFFALSE 32947
// begin wait ( 0 0$6 ) ;
32933: LD_INT 210
32935: PPUSH
32936: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32940: LD_STRING Motherlode2
32942: PPUSH
32943: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32947: LD_VAR 0 1
32951: PPUSH
32952: CALL_OW 255
32956: PUSH
32957: LD_INT 8
32959: EQUAL
32960: IFFALSE 32976
// begin wait ( 0 0$6 ) ;
32962: LD_INT 210
32964: PPUSH
32965: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32969: LD_STRING Motherlode1
32971: PPUSH
32972: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32976: LD_VAR 0 1
32980: PPUSH
32981: CALL_OW 255
32985: PUSH
32986: LD_INT 3
32988: EQUAL
32989: IFFALSE 33010
// begin wait ( 0 0$5 ) ;
32991: LD_INT 175
32993: PPUSH
32994: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32998: LD_EXP 63
33002: PPUSH
33003: LD_STRING D18-Pla-1
33005: PPUSH
33006: CALL_OW 94
// end ; end ;
33010: PPOPN 3
33012: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33013: LD_VAR 0 1
33017: PUSH
33018: LD_EXP 72
33022: IN
33023: IFFALSE 33043
// begin behemothBuilders := behemothBuilders diff un ;
33025: LD_ADDR_EXP 72
33029: PUSH
33030: LD_EXP 72
33034: PUSH
33035: LD_VAR 0 1
33039: DIFF
33040: ST_TO_ADDR
// exit ;
33041: GO 33141
// end ; if un = JMM then
33043: LD_VAR 0 1
33047: PUSH
33048: LD_EXP 38
33052: EQUAL
33053: IFFALSE 33064
// begin YouLost ( JMM ) ;
33055: LD_STRING JMM
33057: PPUSH
33058: CALL_OW 104
// exit ;
33062: GO 33141
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33064: LD_VAR 0 1
33068: PUSH
33069: LD_INT 22
33071: PUSH
33072: LD_INT 1
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 3
33081: PUSH
33082: LD_INT 25
33084: PUSH
33085: LD_INT 16
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 25
33094: PUSH
33095: LD_INT 12
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: LIST
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PPUSH
33111: CALL_OW 69
33115: IN
33116: IFFALSE 33132
// lostCounter := lostCounter + 1 ;
33118: LD_ADDR_EXP 32
33122: PUSH
33123: LD_EXP 32
33127: PUSH
33128: LD_INT 1
33130: PLUS
33131: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33132: LD_VAR 0 1
33136: PPUSH
33137: CALL 61321 0 1
// end ;
33141: PPOPN 1
33143: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33144: LD_VAR 0 1
33148: PPUSH
33149: LD_VAR 0 2
33153: PPUSH
33154: CALL 63655 0 2
// end ;
33158: PPOPN 2
33160: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33161: LD_VAR 0 1
33165: PPUSH
33166: CALL 62723 0 1
// end ;
33170: PPOPN 1
33172: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33173: LD_VAR 0 1
33177: PUSH
33178: LD_INT 22
33180: PUSH
33181: LD_INT 8
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 30
33190: PUSH
33191: LD_INT 2
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 23
33200: PUSH
33201: LD_INT 3
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: LIST
33212: PPUSH
33213: CALL_OW 69
33217: IN
33218: IFFALSE 33245
// begin ComUpgrade ( building ) ;
33220: LD_VAR 0 1
33224: PPUSH
33225: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33229: LD_EXP 60
33233: PPUSH
33234: LD_VAR 0 1
33238: PPUSH
33239: CALL 74361 0 2
// exit ;
33243: GO 33254
// end ; MCE_BuildingComplete ( building ) ;
33245: LD_VAR 0 1
33249: PPUSH
33250: CALL 62964 0 1
// end ;
33254: PPOPN 1
33256: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33257: LD_VAR 0 1
33261: PPUSH
33262: LD_VAR 0 2
33266: PPUSH
33267: CALL 61017 0 2
// end ;
33271: PPOPN 2
33273: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33274: LD_VAR 0 1
33278: PPUSH
33279: LD_VAR 0 2
33283: PPUSH
33284: LD_VAR 0 3
33288: PPUSH
33289: LD_VAR 0 4
33293: PPUSH
33294: LD_VAR 0 5
33298: PPUSH
33299: CALL 60637 0 5
// end ;
33303: PPOPN 5
33305: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33306: LD_VAR 0 1
33310: PPUSH
33311: LD_VAR 0 2
33315: PPUSH
33316: CALL 60233 0 2
// end ;
33320: PPOPN 2
33322: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33323: LD_VAR 0 1
33327: PPUSH
33328: LD_VAR 0 2
33332: PPUSH
33333: LD_VAR 0 3
33337: PPUSH
33338: LD_VAR 0 4
33342: PPUSH
33343: CALL 60071 0 4
// end ;
33347: PPOPN 4
33349: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33350: LD_VAR 0 1
33354: PPUSH
33355: LD_VAR 0 2
33359: PPUSH
33360: LD_VAR 0 3
33364: PPUSH
33365: CALL 59846 0 3
// end ;
33369: PPOPN 3
33371: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33372: LD_VAR 0 1
33376: PPUSH
33377: LD_VAR 0 2
33381: PPUSH
33382: CALL 59731 0 2
// end ;
33386: PPOPN 2
33388: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33389: LD_VAR 0 1
33393: PPUSH
33394: LD_VAR 0 2
33398: PPUSH
33399: CALL 63916 0 2
// end ;
33403: PPOPN 2
33405: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33406: LD_VAR 0 1
33410: PPUSH
33411: CALL_OW 255
33415: PUSH
33416: LD_INT 4
33418: EQUAL
33419: PUSH
33420: LD_VAR 0 1
33424: PUSH
33425: LD_EXP 18
33429: PUSH
33430: LD_INT 1
33432: ARRAY
33433: IN
33434: AND
33435: PUSH
33436: LD_EXP 19
33440: AND
33441: IFFALSE 33460
// begin ComMoveXY ( driver , 61 , 93 ) ;
33443: LD_VAR 0 1
33447: PPUSH
33448: LD_INT 61
33450: PPUSH
33451: LD_INT 93
33453: PPUSH
33454: CALL_OW 111
// exit ;
33458: GO 33484
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33460: LD_VAR 0 1
33464: PPUSH
33465: LD_VAR 0 2
33469: PPUSH
33470: LD_VAR 0 3
33474: PPUSH
33475: LD_VAR 0 4
33479: PPUSH
33480: CALL 64132 0 4
// end ;
33484: PPOPN 4
33486: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33487: LD_VAR 0 1
33491: PPUSH
33492: LD_VAR 0 2
33496: PPUSH
33497: CALL 59540 0 2
// end ;
33501: PPOPN 2
33503: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33504: LD_VAR 0 1
33508: PPUSH
33509: CALL 107536 0 1
// end ; end_of_file
33513: PPOPN 1
33515: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33516: LD_EXP 15
33520: PUSH
33521: LD_INT 2
33523: EQUAL
33524: IFFALSE 34003
33526: GO 33528
33528: DISABLE
33529: LD_INT 0
33531: PPUSH
// begin time := 0 0$40 ;
33532: LD_ADDR_VAR 0 1
33536: PUSH
33537: LD_INT 1400
33539: ST_TO_ADDR
// repeat wait ( time ) ;
33540: LD_VAR 0 1
33544: PPUSH
33545: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33549: LD_INT 1
33551: PPUSH
33552: LD_INT 5
33554: PPUSH
33555: CALL_OW 12
33559: PPUSH
33560: LD_INT 106
33562: PPUSH
33563: LD_INT 150
33565: PPUSH
33566: LD_INT 19
33568: PPUSH
33569: LD_INT 1
33571: PPUSH
33572: CALL_OW 56
// time := time + 0 0$9 ;
33576: LD_ADDR_VAR 0 1
33580: PUSH
33581: LD_VAR 0 1
33585: PUSH
33586: LD_INT 315
33588: PLUS
33589: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33590: LD_INT 455
33592: PPUSH
33593: LD_INT 840
33595: PPUSH
33596: CALL_OW 12
33600: PPUSH
33601: CALL_OW 67
// if Prob ( 50 ) then
33605: LD_INT 50
33607: PPUSH
33608: CALL_OW 13
33612: IFFALSE 33641
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33614: LD_INT 1
33616: PPUSH
33617: LD_INT 5
33619: PPUSH
33620: CALL_OW 12
33624: PPUSH
33625: LD_INT 62
33627: PPUSH
33628: LD_INT 108
33630: PPUSH
33631: LD_INT 10
33633: PPUSH
33634: LD_INT 1
33636: PPUSH
33637: CALL_OW 56
// until missionStage > 4 ;
33641: LD_EXP 15
33645: PUSH
33646: LD_INT 4
33648: GREATER
33649: IFFALSE 33540
// repeat wait ( 0 0$1 ) ;
33651: LD_INT 35
33653: PPUSH
33654: CALL_OW 67
// until missionStage = 6 ;
33658: LD_EXP 15
33662: PUSH
33663: LD_INT 6
33665: EQUAL
33666: IFFALSE 33651
// time := 0 0$50 ;
33668: LD_ADDR_VAR 0 1
33672: PUSH
33673: LD_INT 1750
33675: ST_TO_ADDR
// repeat wait ( time ) ;
33676: LD_VAR 0 1
33680: PPUSH
33681: CALL_OW 67
// if Prob ( 50 ) then
33685: LD_INT 50
33687: PPUSH
33688: CALL_OW 13
33692: IFFALSE 33721
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33694: LD_INT 1
33696: PPUSH
33697: LD_INT 5
33699: PPUSH
33700: CALL_OW 12
33704: PPUSH
33705: LD_INT 106
33707: PPUSH
33708: LD_INT 89
33710: PPUSH
33711: LD_INT 45
33713: PPUSH
33714: LD_INT 1
33716: PPUSH
33717: CALL_OW 56
// time := time + 0 0$3 ;
33721: LD_ADDR_VAR 0 1
33725: PUSH
33726: LD_VAR 0 1
33730: PUSH
33731: LD_INT 105
33733: PLUS
33734: ST_TO_ADDR
// if Prob ( 30 ) then
33735: LD_INT 30
33737: PPUSH
33738: CALL_OW 13
33742: IFFALSE 33788
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33744: LD_INT 525
33746: PPUSH
33747: LD_INT 735
33749: PPUSH
33750: CALL_OW 12
33754: PPUSH
33755: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33759: LD_INT 1
33761: PPUSH
33762: LD_INT 5
33764: PPUSH
33765: CALL_OW 12
33769: PPUSH
33770: LD_INT 21
33772: PPUSH
33773: LD_INT 26
33775: PPUSH
33776: LD_INT 12
33778: PPUSH
33779: LD_INT 1
33781: PPUSH
33782: CALL_OW 56
// end else
33786: GO 33824
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33788: LD_INT 700
33790: PPUSH
33791: LD_INT 1225
33793: PPUSH
33794: CALL_OW 12
33798: PPUSH
33799: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33803: LD_INT 1
33805: PPUSH
33806: LD_INT 5
33808: PPUSH
33809: CALL_OW 12
33813: PPUSH
33814: LD_INT 16
33816: PPUSH
33817: LD_INT 1
33819: PPUSH
33820: CALL_OW 55
// end ; if Prob ( 50 ) then
33824: LD_INT 50
33826: PPUSH
33827: CALL_OW 13
33831: IFFALSE 33877
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33833: LD_INT 700
33835: PPUSH
33836: LD_INT 1050
33838: PPUSH
33839: CALL_OW 12
33843: PPUSH
33844: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33848: LD_INT 1
33850: PPUSH
33851: LD_INT 5
33853: PPUSH
33854: CALL_OW 12
33858: PPUSH
33859: LD_INT 181
33861: PPUSH
33862: LD_INT 218
33864: PPUSH
33865: LD_INT 16
33867: PPUSH
33868: LD_INT 1
33870: PPUSH
33871: CALL_OW 56
// end else
33875: GO 33913
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33877: LD_INT 350
33879: PPUSH
33880: LD_INT 525
33882: PPUSH
33883: CALL_OW 12
33887: PPUSH
33888: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33892: LD_INT 1
33894: PPUSH
33895: LD_INT 5
33897: PPUSH
33898: CALL_OW 12
33902: PPUSH
33903: LD_INT 15
33905: PPUSH
33906: LD_INT 1
33908: PPUSH
33909: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33913: LD_INT 45
33915: PUSH
33916: LD_INT 32
33918: PUSH
33919: LD_INT 25
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: LIST
33926: PUSH
33927: LD_OWVAR 67
33931: ARRAY
33932: PPUSH
33933: CALL_OW 13
33937: IFFALSE 33981
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33939: LD_INT 525
33941: PPUSH
33942: LD_INT 875
33944: PPUSH
33945: CALL_OW 12
33949: PPUSH
33950: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33954: LD_INT 1
33956: PPUSH
33957: LD_INT 5
33959: PPUSH
33960: CALL_OW 12
33964: PPUSH
33965: LD_INT 103
33967: PPUSH
33968: LD_INT 140
33970: PPUSH
33971: LD_INT 20
33973: PPUSH
33974: LD_INT 1
33976: PPUSH
33977: CALL_OW 56
// end ; if time > 2 2$20 then
33981: LD_VAR 0 1
33985: PUSH
33986: LD_INT 4900
33988: GREATER
33989: IFFALSE 33999
// time := 0 0$50 ;
33991: LD_ADDR_VAR 0 1
33995: PUSH
33996: LD_INT 1750
33998: ST_TO_ADDR
// until false ;
33999: LD_INT 0
34001: IFFALSE 33676
// end ; end_of_file
34003: PPOPN 1
34005: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34006: LD_EXP 13
34010: PUSH
34011: LD_EXP 15
34015: PUSH
34016: LD_INT 6
34018: GREATEREQUAL
34019: AND
34020: IFFALSE 34057
34022: GO 34024
34024: DISABLE
// begin enable ;
34025: ENABLE
// missionTime := missionTime + 0 0$1 ;
34026: LD_ADDR_EXP 14
34030: PUSH
34031: LD_EXP 14
34035: PUSH
34036: LD_INT 35
34038: PLUS
34039: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34040: LD_ADDR_OWVAR 47
34044: PUSH
34045: LD_STRING #Am15-1
34047: PUSH
34048: LD_EXP 14
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: ST_TO_ADDR
// end ; end_of_file
34057: END
// export function InitNature ; begin
34058: LD_INT 0
34060: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34061: LD_INT 3
34063: PPUSH
34064: LD_INT 3
34066: PPUSH
34067: LD_INT 2
34069: PPUSH
34070: LD_INT 1
34072: PPUSH
34073: LD_INT 1
34075: PPUSH
34076: LD_INT 0
34078: PPUSH
34079: LD_INT 0
34081: PPUSH
34082: LD_INT 20
34084: PPUSH
34085: LD_INT 0
34087: PPUSH
34088: CALL 99179 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34092: LD_INT 2
34094: PPUSH
34095: LD_INT 1
34097: PPUSH
34098: LD_INT 1
34100: PPUSH
34101: LD_INT 1
34103: PPUSH
34104: LD_INT 1
34106: PPUSH
34107: LD_INT 0
34109: PPUSH
34110: LD_INT 0
34112: PPUSH
34113: LD_INT 21
34115: PPUSH
34116: LD_INT 0
34118: PPUSH
34119: CALL 99179 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34123: LD_INT 4
34125: PPUSH
34126: LD_INT 1
34128: PPUSH
34129: LD_INT 2
34131: PPUSH
34132: LD_INT 4
34134: PPUSH
34135: LD_INT 2
34137: PPUSH
34138: LD_INT 1
34140: PPUSH
34141: LD_INT 0
34143: PPUSH
34144: LD_INT 22
34146: PPUSH
34147: LD_INT 0
34149: PPUSH
34150: CALL 99179 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34154: LD_INT 0
34156: PPUSH
34157: LD_INT 0
34159: PPUSH
34160: LD_INT 0
34162: PPUSH
34163: LD_INT 0
34165: PPUSH
34166: LD_INT 0
34168: PPUSH
34169: LD_INT 0
34171: PPUSH
34172: LD_INT 9
34174: PPUSH
34175: LD_INT 0
34177: PPUSH
34178: LD_INT 23
34180: PPUSH
34181: CALL 99179 0 9
// end ; end_of_file
34185: LD_VAR 0 1
34189: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34190: GO 34192
34192: DISABLE
// begin ru_radar := 98 ;
34193: LD_ADDR_EXP 94
34197: PUSH
34198: LD_INT 98
34200: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34201: LD_ADDR_EXP 95
34205: PUSH
34206: LD_INT 89
34208: ST_TO_ADDR
// us_hack := 99 ;
34209: LD_ADDR_EXP 96
34213: PUSH
34214: LD_INT 99
34216: ST_TO_ADDR
// us_artillery := 97 ;
34217: LD_ADDR_EXP 97
34221: PUSH
34222: LD_INT 97
34224: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34225: LD_ADDR_EXP 98
34229: PUSH
34230: LD_INT 91
34232: ST_TO_ADDR
// end ; end_of_file
34233: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34234: LD_INT 0
34236: PPUSH
34237: PPUSH
// skirmish := false ;
34238: LD_ADDR_EXP 99
34242: PUSH
34243: LD_INT 0
34245: ST_TO_ADDR
// debug_mc := false ;
34246: LD_ADDR_EXP 100
34250: PUSH
34251: LD_INT 0
34253: ST_TO_ADDR
// mc_bases := [ ] ;
34254: LD_ADDR_EXP 101
34258: PUSH
34259: EMPTY
34260: ST_TO_ADDR
// mc_sides := [ ] ;
34261: LD_ADDR_EXP 127
34265: PUSH
34266: EMPTY
34267: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34268: LD_ADDR_EXP 102
34272: PUSH
34273: EMPTY
34274: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34275: LD_ADDR_EXP 103
34279: PUSH
34280: EMPTY
34281: ST_TO_ADDR
// mc_need_heal := [ ] ;
34282: LD_ADDR_EXP 104
34286: PUSH
34287: EMPTY
34288: ST_TO_ADDR
// mc_healers := [ ] ;
34289: LD_ADDR_EXP 105
34293: PUSH
34294: EMPTY
34295: ST_TO_ADDR
// mc_build_list := [ ] ;
34296: LD_ADDR_EXP 106
34300: PUSH
34301: EMPTY
34302: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34303: LD_ADDR_EXP 133
34307: PUSH
34308: EMPTY
34309: ST_TO_ADDR
// mc_builders := [ ] ;
34310: LD_ADDR_EXP 107
34314: PUSH
34315: EMPTY
34316: ST_TO_ADDR
// mc_construct_list := [ ] ;
34317: LD_ADDR_EXP 108
34321: PUSH
34322: EMPTY
34323: ST_TO_ADDR
// mc_turret_list := [ ] ;
34324: LD_ADDR_EXP 109
34328: PUSH
34329: EMPTY
34330: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34331: LD_ADDR_EXP 110
34335: PUSH
34336: EMPTY
34337: ST_TO_ADDR
// mc_miners := [ ] ;
34338: LD_ADDR_EXP 115
34342: PUSH
34343: EMPTY
34344: ST_TO_ADDR
// mc_mines := [ ] ;
34345: LD_ADDR_EXP 114
34349: PUSH
34350: EMPTY
34351: ST_TO_ADDR
// mc_minefields := [ ] ;
34352: LD_ADDR_EXP 116
34356: PUSH
34357: EMPTY
34358: ST_TO_ADDR
// mc_crates := [ ] ;
34359: LD_ADDR_EXP 117
34363: PUSH
34364: EMPTY
34365: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34366: LD_ADDR_EXP 118
34370: PUSH
34371: EMPTY
34372: ST_TO_ADDR
// mc_crates_area := [ ] ;
34373: LD_ADDR_EXP 119
34377: PUSH
34378: EMPTY
34379: ST_TO_ADDR
// mc_vehicles := [ ] ;
34380: LD_ADDR_EXP 120
34384: PUSH
34385: EMPTY
34386: ST_TO_ADDR
// mc_attack := [ ] ;
34387: LD_ADDR_EXP 121
34391: PUSH
34392: EMPTY
34393: ST_TO_ADDR
// mc_produce := [ ] ;
34394: LD_ADDR_EXP 122
34398: PUSH
34399: EMPTY
34400: ST_TO_ADDR
// mc_defender := [ ] ;
34401: LD_ADDR_EXP 123
34405: PUSH
34406: EMPTY
34407: ST_TO_ADDR
// mc_parking := [ ] ;
34408: LD_ADDR_EXP 125
34412: PUSH
34413: EMPTY
34414: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34415: LD_ADDR_EXP 111
34419: PUSH
34420: EMPTY
34421: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34422: LD_ADDR_EXP 113
34426: PUSH
34427: EMPTY
34428: ST_TO_ADDR
// mc_scan := [ ] ;
34429: LD_ADDR_EXP 124
34433: PUSH
34434: EMPTY
34435: ST_TO_ADDR
// mc_scan_area := [ ] ;
34436: LD_ADDR_EXP 126
34440: PUSH
34441: EMPTY
34442: ST_TO_ADDR
// mc_tech := [ ] ;
34443: LD_ADDR_EXP 128
34447: PUSH
34448: EMPTY
34449: ST_TO_ADDR
// mc_class := [ ] ;
34450: LD_ADDR_EXP 142
34454: PUSH
34455: EMPTY
34456: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34457: LD_ADDR_EXP 143
34461: PUSH
34462: EMPTY
34463: ST_TO_ADDR
// end ;
34464: LD_VAR 0 1
34468: RET
// export function MC_Kill ( base ) ; begin
34469: LD_INT 0
34471: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34472: LD_ADDR_EXP 101
34476: PUSH
34477: LD_EXP 101
34481: PPUSH
34482: LD_VAR 0 1
34486: PPUSH
34487: EMPTY
34488: PPUSH
34489: CALL_OW 1
34493: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34494: LD_ADDR_EXP 102
34498: PUSH
34499: LD_EXP 102
34503: PPUSH
34504: LD_VAR 0 1
34508: PPUSH
34509: EMPTY
34510: PPUSH
34511: CALL_OW 1
34515: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34516: LD_ADDR_EXP 103
34520: PUSH
34521: LD_EXP 103
34525: PPUSH
34526: LD_VAR 0 1
34530: PPUSH
34531: EMPTY
34532: PPUSH
34533: CALL_OW 1
34537: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34538: LD_ADDR_EXP 104
34542: PUSH
34543: LD_EXP 104
34547: PPUSH
34548: LD_VAR 0 1
34552: PPUSH
34553: EMPTY
34554: PPUSH
34555: CALL_OW 1
34559: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34560: LD_ADDR_EXP 105
34564: PUSH
34565: LD_EXP 105
34569: PPUSH
34570: LD_VAR 0 1
34574: PPUSH
34575: EMPTY
34576: PPUSH
34577: CALL_OW 1
34581: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34582: LD_ADDR_EXP 106
34586: PUSH
34587: LD_EXP 106
34591: PPUSH
34592: LD_VAR 0 1
34596: PPUSH
34597: EMPTY
34598: PPUSH
34599: CALL_OW 1
34603: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34604: LD_ADDR_EXP 107
34608: PUSH
34609: LD_EXP 107
34613: PPUSH
34614: LD_VAR 0 1
34618: PPUSH
34619: EMPTY
34620: PPUSH
34621: CALL_OW 1
34625: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34626: LD_ADDR_EXP 108
34630: PUSH
34631: LD_EXP 108
34635: PPUSH
34636: LD_VAR 0 1
34640: PPUSH
34641: EMPTY
34642: PPUSH
34643: CALL_OW 1
34647: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34648: LD_ADDR_EXP 109
34652: PUSH
34653: LD_EXP 109
34657: PPUSH
34658: LD_VAR 0 1
34662: PPUSH
34663: EMPTY
34664: PPUSH
34665: CALL_OW 1
34669: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34670: LD_ADDR_EXP 110
34674: PUSH
34675: LD_EXP 110
34679: PPUSH
34680: LD_VAR 0 1
34684: PPUSH
34685: EMPTY
34686: PPUSH
34687: CALL_OW 1
34691: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34692: LD_ADDR_EXP 111
34696: PUSH
34697: LD_EXP 111
34701: PPUSH
34702: LD_VAR 0 1
34706: PPUSH
34707: EMPTY
34708: PPUSH
34709: CALL_OW 1
34713: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34714: LD_ADDR_EXP 112
34718: PUSH
34719: LD_EXP 112
34723: PPUSH
34724: LD_VAR 0 1
34728: PPUSH
34729: LD_INT 0
34731: PPUSH
34732: CALL_OW 1
34736: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34737: LD_ADDR_EXP 113
34741: PUSH
34742: LD_EXP 113
34746: PPUSH
34747: LD_VAR 0 1
34751: PPUSH
34752: EMPTY
34753: PPUSH
34754: CALL_OW 1
34758: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34759: LD_ADDR_EXP 114
34763: PUSH
34764: LD_EXP 114
34768: PPUSH
34769: LD_VAR 0 1
34773: PPUSH
34774: EMPTY
34775: PPUSH
34776: CALL_OW 1
34780: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34781: LD_ADDR_EXP 115
34785: PUSH
34786: LD_EXP 115
34790: PPUSH
34791: LD_VAR 0 1
34795: PPUSH
34796: EMPTY
34797: PPUSH
34798: CALL_OW 1
34802: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34803: LD_ADDR_EXP 116
34807: PUSH
34808: LD_EXP 116
34812: PPUSH
34813: LD_VAR 0 1
34817: PPUSH
34818: EMPTY
34819: PPUSH
34820: CALL_OW 1
34824: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34825: LD_ADDR_EXP 117
34829: PUSH
34830: LD_EXP 117
34834: PPUSH
34835: LD_VAR 0 1
34839: PPUSH
34840: EMPTY
34841: PPUSH
34842: CALL_OW 1
34846: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34847: LD_ADDR_EXP 118
34851: PUSH
34852: LD_EXP 118
34856: PPUSH
34857: LD_VAR 0 1
34861: PPUSH
34862: EMPTY
34863: PPUSH
34864: CALL_OW 1
34868: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34869: LD_ADDR_EXP 119
34873: PUSH
34874: LD_EXP 119
34878: PPUSH
34879: LD_VAR 0 1
34883: PPUSH
34884: EMPTY
34885: PPUSH
34886: CALL_OW 1
34890: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34891: LD_ADDR_EXP 120
34895: PUSH
34896: LD_EXP 120
34900: PPUSH
34901: LD_VAR 0 1
34905: PPUSH
34906: EMPTY
34907: PPUSH
34908: CALL_OW 1
34912: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34913: LD_ADDR_EXP 121
34917: PUSH
34918: LD_EXP 121
34922: PPUSH
34923: LD_VAR 0 1
34927: PPUSH
34928: EMPTY
34929: PPUSH
34930: CALL_OW 1
34934: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34935: LD_ADDR_EXP 122
34939: PUSH
34940: LD_EXP 122
34944: PPUSH
34945: LD_VAR 0 1
34949: PPUSH
34950: EMPTY
34951: PPUSH
34952: CALL_OW 1
34956: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34957: LD_ADDR_EXP 123
34961: PUSH
34962: LD_EXP 123
34966: PPUSH
34967: LD_VAR 0 1
34971: PPUSH
34972: EMPTY
34973: PPUSH
34974: CALL_OW 1
34978: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34979: LD_ADDR_EXP 124
34983: PUSH
34984: LD_EXP 124
34988: PPUSH
34989: LD_VAR 0 1
34993: PPUSH
34994: EMPTY
34995: PPUSH
34996: CALL_OW 1
35000: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35001: LD_ADDR_EXP 125
35005: PUSH
35006: LD_EXP 125
35010: PPUSH
35011: LD_VAR 0 1
35015: PPUSH
35016: EMPTY
35017: PPUSH
35018: CALL_OW 1
35022: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35023: LD_ADDR_EXP 126
35027: PUSH
35028: LD_EXP 126
35032: PPUSH
35033: LD_VAR 0 1
35037: PPUSH
35038: EMPTY
35039: PPUSH
35040: CALL_OW 1
35044: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35045: LD_ADDR_EXP 128
35049: PUSH
35050: LD_EXP 128
35054: PPUSH
35055: LD_VAR 0 1
35059: PPUSH
35060: EMPTY
35061: PPUSH
35062: CALL_OW 1
35066: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35067: LD_ADDR_EXP 130
35071: PUSH
35072: LD_EXP 130
35076: PPUSH
35077: LD_VAR 0 1
35081: PPUSH
35082: EMPTY
35083: PPUSH
35084: CALL_OW 1
35088: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35089: LD_ADDR_EXP 131
35093: PUSH
35094: LD_EXP 131
35098: PPUSH
35099: LD_VAR 0 1
35103: PPUSH
35104: EMPTY
35105: PPUSH
35106: CALL_OW 1
35110: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35111: LD_ADDR_EXP 132
35115: PUSH
35116: LD_EXP 132
35120: PPUSH
35121: LD_VAR 0 1
35125: PPUSH
35126: EMPTY
35127: PPUSH
35128: CALL_OW 1
35132: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35133: LD_ADDR_EXP 133
35137: PUSH
35138: LD_EXP 133
35142: PPUSH
35143: LD_VAR 0 1
35147: PPUSH
35148: EMPTY
35149: PPUSH
35150: CALL_OW 1
35154: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35155: LD_ADDR_EXP 134
35159: PUSH
35160: LD_EXP 134
35164: PPUSH
35165: LD_VAR 0 1
35169: PPUSH
35170: EMPTY
35171: PPUSH
35172: CALL_OW 1
35176: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35177: LD_ADDR_EXP 135
35181: PUSH
35182: LD_EXP 135
35186: PPUSH
35187: LD_VAR 0 1
35191: PPUSH
35192: EMPTY
35193: PPUSH
35194: CALL_OW 1
35198: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35199: LD_ADDR_EXP 136
35203: PUSH
35204: LD_EXP 136
35208: PPUSH
35209: LD_VAR 0 1
35213: PPUSH
35214: EMPTY
35215: PPUSH
35216: CALL_OW 1
35220: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35221: LD_ADDR_EXP 137
35225: PUSH
35226: LD_EXP 137
35230: PPUSH
35231: LD_VAR 0 1
35235: PPUSH
35236: EMPTY
35237: PPUSH
35238: CALL_OW 1
35242: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35243: LD_ADDR_EXP 138
35247: PUSH
35248: LD_EXP 138
35252: PPUSH
35253: LD_VAR 0 1
35257: PPUSH
35258: EMPTY
35259: PPUSH
35260: CALL_OW 1
35264: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35265: LD_ADDR_EXP 139
35269: PUSH
35270: LD_EXP 139
35274: PPUSH
35275: LD_VAR 0 1
35279: PPUSH
35280: EMPTY
35281: PPUSH
35282: CALL_OW 1
35286: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35287: LD_ADDR_EXP 140
35291: PUSH
35292: LD_EXP 140
35296: PPUSH
35297: LD_VAR 0 1
35301: PPUSH
35302: EMPTY
35303: PPUSH
35304: CALL_OW 1
35308: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35309: LD_ADDR_EXP 141
35313: PUSH
35314: LD_EXP 141
35318: PPUSH
35319: LD_VAR 0 1
35323: PPUSH
35324: EMPTY
35325: PPUSH
35326: CALL_OW 1
35330: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35331: LD_ADDR_EXP 142
35335: PUSH
35336: LD_EXP 142
35340: PPUSH
35341: LD_VAR 0 1
35345: PPUSH
35346: EMPTY
35347: PPUSH
35348: CALL_OW 1
35352: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35353: LD_ADDR_EXP 143
35357: PUSH
35358: LD_EXP 143
35362: PPUSH
35363: LD_VAR 0 1
35367: PPUSH
35368: LD_INT 0
35370: PPUSH
35371: CALL_OW 1
35375: ST_TO_ADDR
// end ;
35376: LD_VAR 0 2
35380: RET
// export function MC_Add ( side , units ) ; var base ; begin
35381: LD_INT 0
35383: PPUSH
35384: PPUSH
// base := mc_bases + 1 ;
35385: LD_ADDR_VAR 0 4
35389: PUSH
35390: LD_EXP 101
35394: PUSH
35395: LD_INT 1
35397: PLUS
35398: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35399: LD_ADDR_EXP 127
35403: PUSH
35404: LD_EXP 127
35408: PPUSH
35409: LD_VAR 0 4
35413: PPUSH
35414: LD_VAR 0 1
35418: PPUSH
35419: CALL_OW 1
35423: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35424: LD_ADDR_EXP 101
35428: PUSH
35429: LD_EXP 101
35433: PPUSH
35434: LD_VAR 0 4
35438: PPUSH
35439: LD_VAR 0 2
35443: PPUSH
35444: CALL_OW 1
35448: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35449: LD_ADDR_EXP 102
35453: PUSH
35454: LD_EXP 102
35458: PPUSH
35459: LD_VAR 0 4
35463: PPUSH
35464: EMPTY
35465: PPUSH
35466: CALL_OW 1
35470: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35471: LD_ADDR_EXP 103
35475: PUSH
35476: LD_EXP 103
35480: PPUSH
35481: LD_VAR 0 4
35485: PPUSH
35486: EMPTY
35487: PPUSH
35488: CALL_OW 1
35492: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35493: LD_ADDR_EXP 104
35497: PUSH
35498: LD_EXP 104
35502: PPUSH
35503: LD_VAR 0 4
35507: PPUSH
35508: EMPTY
35509: PPUSH
35510: CALL_OW 1
35514: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35515: LD_ADDR_EXP 105
35519: PUSH
35520: LD_EXP 105
35524: PPUSH
35525: LD_VAR 0 4
35529: PPUSH
35530: EMPTY
35531: PPUSH
35532: CALL_OW 1
35536: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35537: LD_ADDR_EXP 106
35541: PUSH
35542: LD_EXP 106
35546: PPUSH
35547: LD_VAR 0 4
35551: PPUSH
35552: EMPTY
35553: PPUSH
35554: CALL_OW 1
35558: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35559: LD_ADDR_EXP 107
35563: PUSH
35564: LD_EXP 107
35568: PPUSH
35569: LD_VAR 0 4
35573: PPUSH
35574: EMPTY
35575: PPUSH
35576: CALL_OW 1
35580: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35581: LD_ADDR_EXP 108
35585: PUSH
35586: LD_EXP 108
35590: PPUSH
35591: LD_VAR 0 4
35595: PPUSH
35596: EMPTY
35597: PPUSH
35598: CALL_OW 1
35602: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35603: LD_ADDR_EXP 109
35607: PUSH
35608: LD_EXP 109
35612: PPUSH
35613: LD_VAR 0 4
35617: PPUSH
35618: EMPTY
35619: PPUSH
35620: CALL_OW 1
35624: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35625: LD_ADDR_EXP 110
35629: PUSH
35630: LD_EXP 110
35634: PPUSH
35635: LD_VAR 0 4
35639: PPUSH
35640: EMPTY
35641: PPUSH
35642: CALL_OW 1
35646: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35647: LD_ADDR_EXP 111
35651: PUSH
35652: LD_EXP 111
35656: PPUSH
35657: LD_VAR 0 4
35661: PPUSH
35662: EMPTY
35663: PPUSH
35664: CALL_OW 1
35668: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35669: LD_ADDR_EXP 112
35673: PUSH
35674: LD_EXP 112
35678: PPUSH
35679: LD_VAR 0 4
35683: PPUSH
35684: LD_INT 0
35686: PPUSH
35687: CALL_OW 1
35691: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35692: LD_ADDR_EXP 113
35696: PUSH
35697: LD_EXP 113
35701: PPUSH
35702: LD_VAR 0 4
35706: PPUSH
35707: EMPTY
35708: PPUSH
35709: CALL_OW 1
35713: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35714: LD_ADDR_EXP 114
35718: PUSH
35719: LD_EXP 114
35723: PPUSH
35724: LD_VAR 0 4
35728: PPUSH
35729: EMPTY
35730: PPUSH
35731: CALL_OW 1
35735: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35736: LD_ADDR_EXP 115
35740: PUSH
35741: LD_EXP 115
35745: PPUSH
35746: LD_VAR 0 4
35750: PPUSH
35751: EMPTY
35752: PPUSH
35753: CALL_OW 1
35757: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35758: LD_ADDR_EXP 116
35762: PUSH
35763: LD_EXP 116
35767: PPUSH
35768: LD_VAR 0 4
35772: PPUSH
35773: EMPTY
35774: PPUSH
35775: CALL_OW 1
35779: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35780: LD_ADDR_EXP 117
35784: PUSH
35785: LD_EXP 117
35789: PPUSH
35790: LD_VAR 0 4
35794: PPUSH
35795: EMPTY
35796: PPUSH
35797: CALL_OW 1
35801: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35802: LD_ADDR_EXP 118
35806: PUSH
35807: LD_EXP 118
35811: PPUSH
35812: LD_VAR 0 4
35816: PPUSH
35817: EMPTY
35818: PPUSH
35819: CALL_OW 1
35823: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35824: LD_ADDR_EXP 119
35828: PUSH
35829: LD_EXP 119
35833: PPUSH
35834: LD_VAR 0 4
35838: PPUSH
35839: EMPTY
35840: PPUSH
35841: CALL_OW 1
35845: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35846: LD_ADDR_EXP 120
35850: PUSH
35851: LD_EXP 120
35855: PPUSH
35856: LD_VAR 0 4
35860: PPUSH
35861: EMPTY
35862: PPUSH
35863: CALL_OW 1
35867: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35868: LD_ADDR_EXP 121
35872: PUSH
35873: LD_EXP 121
35877: PPUSH
35878: LD_VAR 0 4
35882: PPUSH
35883: EMPTY
35884: PPUSH
35885: CALL_OW 1
35889: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35890: LD_ADDR_EXP 122
35894: PUSH
35895: LD_EXP 122
35899: PPUSH
35900: LD_VAR 0 4
35904: PPUSH
35905: EMPTY
35906: PPUSH
35907: CALL_OW 1
35911: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35912: LD_ADDR_EXP 123
35916: PUSH
35917: LD_EXP 123
35921: PPUSH
35922: LD_VAR 0 4
35926: PPUSH
35927: EMPTY
35928: PPUSH
35929: CALL_OW 1
35933: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35934: LD_ADDR_EXP 124
35938: PUSH
35939: LD_EXP 124
35943: PPUSH
35944: LD_VAR 0 4
35948: PPUSH
35949: EMPTY
35950: PPUSH
35951: CALL_OW 1
35955: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35956: LD_ADDR_EXP 125
35960: PUSH
35961: LD_EXP 125
35965: PPUSH
35966: LD_VAR 0 4
35970: PPUSH
35971: EMPTY
35972: PPUSH
35973: CALL_OW 1
35977: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35978: LD_ADDR_EXP 126
35982: PUSH
35983: LD_EXP 126
35987: PPUSH
35988: LD_VAR 0 4
35992: PPUSH
35993: EMPTY
35994: PPUSH
35995: CALL_OW 1
35999: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36000: LD_ADDR_EXP 128
36004: PUSH
36005: LD_EXP 128
36009: PPUSH
36010: LD_VAR 0 4
36014: PPUSH
36015: EMPTY
36016: PPUSH
36017: CALL_OW 1
36021: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36022: LD_ADDR_EXP 130
36026: PUSH
36027: LD_EXP 130
36031: PPUSH
36032: LD_VAR 0 4
36036: PPUSH
36037: EMPTY
36038: PPUSH
36039: CALL_OW 1
36043: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36044: LD_ADDR_EXP 131
36048: PUSH
36049: LD_EXP 131
36053: PPUSH
36054: LD_VAR 0 4
36058: PPUSH
36059: EMPTY
36060: PPUSH
36061: CALL_OW 1
36065: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36066: LD_ADDR_EXP 132
36070: PUSH
36071: LD_EXP 132
36075: PPUSH
36076: LD_VAR 0 4
36080: PPUSH
36081: EMPTY
36082: PPUSH
36083: CALL_OW 1
36087: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36088: LD_ADDR_EXP 133
36092: PUSH
36093: LD_EXP 133
36097: PPUSH
36098: LD_VAR 0 4
36102: PPUSH
36103: EMPTY
36104: PPUSH
36105: CALL_OW 1
36109: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36110: LD_ADDR_EXP 134
36114: PUSH
36115: LD_EXP 134
36119: PPUSH
36120: LD_VAR 0 4
36124: PPUSH
36125: EMPTY
36126: PPUSH
36127: CALL_OW 1
36131: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36132: LD_ADDR_EXP 135
36136: PUSH
36137: LD_EXP 135
36141: PPUSH
36142: LD_VAR 0 4
36146: PPUSH
36147: EMPTY
36148: PPUSH
36149: CALL_OW 1
36153: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36154: LD_ADDR_EXP 136
36158: PUSH
36159: LD_EXP 136
36163: PPUSH
36164: LD_VAR 0 4
36168: PPUSH
36169: EMPTY
36170: PPUSH
36171: CALL_OW 1
36175: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36176: LD_ADDR_EXP 137
36180: PUSH
36181: LD_EXP 137
36185: PPUSH
36186: LD_VAR 0 4
36190: PPUSH
36191: EMPTY
36192: PPUSH
36193: CALL_OW 1
36197: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36198: LD_ADDR_EXP 138
36202: PUSH
36203: LD_EXP 138
36207: PPUSH
36208: LD_VAR 0 4
36212: PPUSH
36213: EMPTY
36214: PPUSH
36215: CALL_OW 1
36219: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36220: LD_ADDR_EXP 139
36224: PUSH
36225: LD_EXP 139
36229: PPUSH
36230: LD_VAR 0 4
36234: PPUSH
36235: EMPTY
36236: PPUSH
36237: CALL_OW 1
36241: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36242: LD_ADDR_EXP 140
36246: PUSH
36247: LD_EXP 140
36251: PPUSH
36252: LD_VAR 0 4
36256: PPUSH
36257: EMPTY
36258: PPUSH
36259: CALL_OW 1
36263: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36264: LD_ADDR_EXP 141
36268: PUSH
36269: LD_EXP 141
36273: PPUSH
36274: LD_VAR 0 4
36278: PPUSH
36279: EMPTY
36280: PPUSH
36281: CALL_OW 1
36285: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36286: LD_ADDR_EXP 142
36290: PUSH
36291: LD_EXP 142
36295: PPUSH
36296: LD_VAR 0 4
36300: PPUSH
36301: EMPTY
36302: PPUSH
36303: CALL_OW 1
36307: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36308: LD_ADDR_EXP 143
36312: PUSH
36313: LD_EXP 143
36317: PPUSH
36318: LD_VAR 0 4
36322: PPUSH
36323: LD_INT 0
36325: PPUSH
36326: CALL_OW 1
36330: ST_TO_ADDR
// result := base ;
36331: LD_ADDR_VAR 0 3
36335: PUSH
36336: LD_VAR 0 4
36340: ST_TO_ADDR
// end ;
36341: LD_VAR 0 3
36345: RET
// export function MC_Start ( ) ; var i ; begin
36346: LD_INT 0
36348: PPUSH
36349: PPUSH
// for i = 1 to mc_bases do
36350: LD_ADDR_VAR 0 2
36354: PUSH
36355: DOUBLE
36356: LD_INT 1
36358: DEC
36359: ST_TO_ADDR
36360: LD_EXP 101
36364: PUSH
36365: FOR_TO
36366: IFFALSE 37443
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36368: LD_ADDR_EXP 101
36372: PUSH
36373: LD_EXP 101
36377: PPUSH
36378: LD_VAR 0 2
36382: PPUSH
36383: LD_EXP 101
36387: PUSH
36388: LD_VAR 0 2
36392: ARRAY
36393: PUSH
36394: LD_INT 0
36396: DIFF
36397: PPUSH
36398: CALL_OW 1
36402: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36403: LD_ADDR_EXP 102
36407: PUSH
36408: LD_EXP 102
36412: PPUSH
36413: LD_VAR 0 2
36417: PPUSH
36418: EMPTY
36419: PPUSH
36420: CALL_OW 1
36424: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36425: LD_ADDR_EXP 103
36429: PUSH
36430: LD_EXP 103
36434: PPUSH
36435: LD_VAR 0 2
36439: PPUSH
36440: EMPTY
36441: PPUSH
36442: CALL_OW 1
36446: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36447: LD_ADDR_EXP 104
36451: PUSH
36452: LD_EXP 104
36456: PPUSH
36457: LD_VAR 0 2
36461: PPUSH
36462: EMPTY
36463: PPUSH
36464: CALL_OW 1
36468: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36469: LD_ADDR_EXP 105
36473: PUSH
36474: LD_EXP 105
36478: PPUSH
36479: LD_VAR 0 2
36483: PPUSH
36484: EMPTY
36485: PUSH
36486: EMPTY
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PPUSH
36492: CALL_OW 1
36496: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36497: LD_ADDR_EXP 106
36501: PUSH
36502: LD_EXP 106
36506: PPUSH
36507: LD_VAR 0 2
36511: PPUSH
36512: EMPTY
36513: PPUSH
36514: CALL_OW 1
36518: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36519: LD_ADDR_EXP 133
36523: PUSH
36524: LD_EXP 133
36528: PPUSH
36529: LD_VAR 0 2
36533: PPUSH
36534: EMPTY
36535: PPUSH
36536: CALL_OW 1
36540: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36541: LD_ADDR_EXP 107
36545: PUSH
36546: LD_EXP 107
36550: PPUSH
36551: LD_VAR 0 2
36555: PPUSH
36556: EMPTY
36557: PPUSH
36558: CALL_OW 1
36562: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36563: LD_ADDR_EXP 108
36567: PUSH
36568: LD_EXP 108
36572: PPUSH
36573: LD_VAR 0 2
36577: PPUSH
36578: EMPTY
36579: PPUSH
36580: CALL_OW 1
36584: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36585: LD_ADDR_EXP 109
36589: PUSH
36590: LD_EXP 109
36594: PPUSH
36595: LD_VAR 0 2
36599: PPUSH
36600: LD_EXP 101
36604: PUSH
36605: LD_VAR 0 2
36609: ARRAY
36610: PPUSH
36611: LD_INT 2
36613: PUSH
36614: LD_INT 30
36616: PUSH
36617: LD_INT 32
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 30
36626: PUSH
36627: LD_INT 33
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: EMPTY
36635: LIST
36636: LIST
36637: LIST
36638: PPUSH
36639: CALL_OW 72
36643: PPUSH
36644: CALL_OW 1
36648: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36649: LD_ADDR_EXP 110
36653: PUSH
36654: LD_EXP 110
36658: PPUSH
36659: LD_VAR 0 2
36663: PPUSH
36664: LD_EXP 101
36668: PUSH
36669: LD_VAR 0 2
36673: ARRAY
36674: PPUSH
36675: LD_INT 2
36677: PUSH
36678: LD_INT 30
36680: PUSH
36681: LD_INT 32
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 30
36690: PUSH
36691: LD_INT 31
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 58
36705: PUSH
36706: EMPTY
36707: LIST
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PPUSH
36713: CALL_OW 72
36717: PPUSH
36718: CALL_OW 1
36722: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36723: LD_ADDR_EXP 111
36727: PUSH
36728: LD_EXP 111
36732: PPUSH
36733: LD_VAR 0 2
36737: PPUSH
36738: EMPTY
36739: PPUSH
36740: CALL_OW 1
36744: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36745: LD_ADDR_EXP 115
36749: PUSH
36750: LD_EXP 115
36754: PPUSH
36755: LD_VAR 0 2
36759: PPUSH
36760: EMPTY
36761: PPUSH
36762: CALL_OW 1
36766: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36767: LD_ADDR_EXP 114
36771: PUSH
36772: LD_EXP 114
36776: PPUSH
36777: LD_VAR 0 2
36781: PPUSH
36782: EMPTY
36783: PPUSH
36784: CALL_OW 1
36788: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36789: LD_ADDR_EXP 116
36793: PUSH
36794: LD_EXP 116
36798: PPUSH
36799: LD_VAR 0 2
36803: PPUSH
36804: EMPTY
36805: PPUSH
36806: CALL_OW 1
36810: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36811: LD_ADDR_EXP 117
36815: PUSH
36816: LD_EXP 117
36820: PPUSH
36821: LD_VAR 0 2
36825: PPUSH
36826: EMPTY
36827: PPUSH
36828: CALL_OW 1
36832: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36833: LD_ADDR_EXP 118
36837: PUSH
36838: LD_EXP 118
36842: PPUSH
36843: LD_VAR 0 2
36847: PPUSH
36848: EMPTY
36849: PPUSH
36850: CALL_OW 1
36854: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36855: LD_ADDR_EXP 119
36859: PUSH
36860: LD_EXP 119
36864: PPUSH
36865: LD_VAR 0 2
36869: PPUSH
36870: EMPTY
36871: PPUSH
36872: CALL_OW 1
36876: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36877: LD_ADDR_EXP 120
36881: PUSH
36882: LD_EXP 120
36886: PPUSH
36887: LD_VAR 0 2
36891: PPUSH
36892: EMPTY
36893: PPUSH
36894: CALL_OW 1
36898: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36899: LD_ADDR_EXP 121
36903: PUSH
36904: LD_EXP 121
36908: PPUSH
36909: LD_VAR 0 2
36913: PPUSH
36914: EMPTY
36915: PPUSH
36916: CALL_OW 1
36920: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36921: LD_ADDR_EXP 122
36925: PUSH
36926: LD_EXP 122
36930: PPUSH
36931: LD_VAR 0 2
36935: PPUSH
36936: EMPTY
36937: PPUSH
36938: CALL_OW 1
36942: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36943: LD_ADDR_EXP 123
36947: PUSH
36948: LD_EXP 123
36952: PPUSH
36953: LD_VAR 0 2
36957: PPUSH
36958: EMPTY
36959: PPUSH
36960: CALL_OW 1
36964: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36965: LD_ADDR_EXP 112
36969: PUSH
36970: LD_EXP 112
36974: PPUSH
36975: LD_VAR 0 2
36979: PPUSH
36980: LD_INT 0
36982: PPUSH
36983: CALL_OW 1
36987: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36988: LD_ADDR_EXP 125
36992: PUSH
36993: LD_EXP 125
36997: PPUSH
36998: LD_VAR 0 2
37002: PPUSH
37003: LD_INT 0
37005: PPUSH
37006: CALL_OW 1
37010: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37011: LD_ADDR_EXP 113
37015: PUSH
37016: LD_EXP 113
37020: PPUSH
37021: LD_VAR 0 2
37025: PPUSH
37026: EMPTY
37027: PPUSH
37028: CALL_OW 1
37032: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37033: LD_ADDR_EXP 124
37037: PUSH
37038: LD_EXP 124
37042: PPUSH
37043: LD_VAR 0 2
37047: PPUSH
37048: LD_INT 0
37050: PPUSH
37051: CALL_OW 1
37055: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37056: LD_ADDR_EXP 126
37060: PUSH
37061: LD_EXP 126
37065: PPUSH
37066: LD_VAR 0 2
37070: PPUSH
37071: EMPTY
37072: PPUSH
37073: CALL_OW 1
37077: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37078: LD_ADDR_EXP 129
37082: PUSH
37083: LD_EXP 129
37087: PPUSH
37088: LD_VAR 0 2
37092: PPUSH
37093: LD_INT 0
37095: PPUSH
37096: CALL_OW 1
37100: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37101: LD_ADDR_EXP 130
37105: PUSH
37106: LD_EXP 130
37110: PPUSH
37111: LD_VAR 0 2
37115: PPUSH
37116: EMPTY
37117: PPUSH
37118: CALL_OW 1
37122: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37123: LD_ADDR_EXP 131
37127: PUSH
37128: LD_EXP 131
37132: PPUSH
37133: LD_VAR 0 2
37137: PPUSH
37138: EMPTY
37139: PPUSH
37140: CALL_OW 1
37144: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37145: LD_ADDR_EXP 132
37149: PUSH
37150: LD_EXP 132
37154: PPUSH
37155: LD_VAR 0 2
37159: PPUSH
37160: EMPTY
37161: PPUSH
37162: CALL_OW 1
37166: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37167: LD_ADDR_EXP 134
37171: PUSH
37172: LD_EXP 134
37176: PPUSH
37177: LD_VAR 0 2
37181: PPUSH
37182: LD_EXP 101
37186: PUSH
37187: LD_VAR 0 2
37191: ARRAY
37192: PPUSH
37193: LD_INT 2
37195: PUSH
37196: LD_INT 30
37198: PUSH
37199: LD_INT 6
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PUSH
37206: LD_INT 30
37208: PUSH
37209: LD_INT 7
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: LD_INT 30
37218: PUSH
37219: LD_INT 8
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: PPUSH
37232: CALL_OW 72
37236: PPUSH
37237: CALL_OW 1
37241: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37242: LD_ADDR_EXP 135
37246: PUSH
37247: LD_EXP 135
37251: PPUSH
37252: LD_VAR 0 2
37256: PPUSH
37257: EMPTY
37258: PPUSH
37259: CALL_OW 1
37263: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37264: LD_ADDR_EXP 136
37268: PUSH
37269: LD_EXP 136
37273: PPUSH
37274: LD_VAR 0 2
37278: PPUSH
37279: EMPTY
37280: PPUSH
37281: CALL_OW 1
37285: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37286: LD_ADDR_EXP 137
37290: PUSH
37291: LD_EXP 137
37295: PPUSH
37296: LD_VAR 0 2
37300: PPUSH
37301: EMPTY
37302: PPUSH
37303: CALL_OW 1
37307: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37308: LD_ADDR_EXP 138
37312: PUSH
37313: LD_EXP 138
37317: PPUSH
37318: LD_VAR 0 2
37322: PPUSH
37323: EMPTY
37324: PPUSH
37325: CALL_OW 1
37329: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37330: LD_ADDR_EXP 139
37334: PUSH
37335: LD_EXP 139
37339: PPUSH
37340: LD_VAR 0 2
37344: PPUSH
37345: EMPTY
37346: PPUSH
37347: CALL_OW 1
37351: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37352: LD_ADDR_EXP 140
37356: PUSH
37357: LD_EXP 140
37361: PPUSH
37362: LD_VAR 0 2
37366: PPUSH
37367: EMPTY
37368: PPUSH
37369: CALL_OW 1
37373: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37374: LD_ADDR_EXP 141
37378: PUSH
37379: LD_EXP 141
37383: PPUSH
37384: LD_VAR 0 2
37388: PPUSH
37389: EMPTY
37390: PPUSH
37391: CALL_OW 1
37395: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37396: LD_ADDR_EXP 142
37400: PUSH
37401: LD_EXP 142
37405: PPUSH
37406: LD_VAR 0 2
37410: PPUSH
37411: EMPTY
37412: PPUSH
37413: CALL_OW 1
37417: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37418: LD_ADDR_EXP 143
37422: PUSH
37423: LD_EXP 143
37427: PPUSH
37428: LD_VAR 0 2
37432: PPUSH
37433: LD_INT 0
37435: PPUSH
37436: CALL_OW 1
37440: ST_TO_ADDR
// end ;
37441: GO 36365
37443: POP
37444: POP
// MC_InitSides ( ) ;
37445: CALL 37731 0 0
// MC_InitResearch ( ) ;
37449: CALL 37470 0 0
// CustomInitMacro ( ) ;
37453: CALL 460 0 0
// skirmish := true ;
37457: LD_ADDR_EXP 99
37461: PUSH
37462: LD_INT 1
37464: ST_TO_ADDR
// end ;
37465: LD_VAR 0 1
37469: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37470: LD_INT 0
37472: PPUSH
37473: PPUSH
37474: PPUSH
37475: PPUSH
37476: PPUSH
37477: PPUSH
// if not mc_bases then
37478: LD_EXP 101
37482: NOT
37483: IFFALSE 37487
// exit ;
37485: GO 37726
// for i = 1 to 8 do
37487: LD_ADDR_VAR 0 2
37491: PUSH
37492: DOUBLE
37493: LD_INT 1
37495: DEC
37496: ST_TO_ADDR
37497: LD_INT 8
37499: PUSH
37500: FOR_TO
37501: IFFALSE 37527
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37503: LD_ADDR_EXP 128
37507: PUSH
37508: LD_EXP 128
37512: PPUSH
37513: LD_VAR 0 2
37517: PPUSH
37518: EMPTY
37519: PPUSH
37520: CALL_OW 1
37524: ST_TO_ADDR
37525: GO 37500
37527: POP
37528: POP
// tmp := [ ] ;
37529: LD_ADDR_VAR 0 5
37533: PUSH
37534: EMPTY
37535: ST_TO_ADDR
// for i = 1 to mc_sides do
37536: LD_ADDR_VAR 0 2
37540: PUSH
37541: DOUBLE
37542: LD_INT 1
37544: DEC
37545: ST_TO_ADDR
37546: LD_EXP 127
37550: PUSH
37551: FOR_TO
37552: IFFALSE 37610
// if not mc_sides [ i ] in tmp then
37554: LD_EXP 127
37558: PUSH
37559: LD_VAR 0 2
37563: ARRAY
37564: PUSH
37565: LD_VAR 0 5
37569: IN
37570: NOT
37571: IFFALSE 37608
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37573: LD_ADDR_VAR 0 5
37577: PUSH
37578: LD_VAR 0 5
37582: PPUSH
37583: LD_VAR 0 5
37587: PUSH
37588: LD_INT 1
37590: PLUS
37591: PPUSH
37592: LD_EXP 127
37596: PUSH
37597: LD_VAR 0 2
37601: ARRAY
37602: PPUSH
37603: CALL_OW 2
37607: ST_TO_ADDR
37608: GO 37551
37610: POP
37611: POP
// if not tmp then
37612: LD_VAR 0 5
37616: NOT
37617: IFFALSE 37621
// exit ;
37619: GO 37726
// for j in tmp do
37621: LD_ADDR_VAR 0 3
37625: PUSH
37626: LD_VAR 0 5
37630: PUSH
37631: FOR_IN
37632: IFFALSE 37724
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37634: LD_ADDR_VAR 0 6
37638: PUSH
37639: LD_INT 22
37641: PUSH
37642: LD_VAR 0 3
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PPUSH
37651: CALL_OW 69
37655: ST_TO_ADDR
// if not un then
37656: LD_VAR 0 6
37660: NOT
37661: IFFALSE 37665
// continue ;
37663: GO 37631
// nation := GetNation ( un [ 1 ] ) ;
37665: LD_ADDR_VAR 0 4
37669: PUSH
37670: LD_VAR 0 6
37674: PUSH
37675: LD_INT 1
37677: ARRAY
37678: PPUSH
37679: CALL_OW 248
37683: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37684: LD_ADDR_EXP 128
37688: PUSH
37689: LD_EXP 128
37693: PPUSH
37694: LD_VAR 0 3
37698: PPUSH
37699: LD_VAR 0 3
37703: PPUSH
37704: LD_VAR 0 4
37708: PPUSH
37709: LD_INT 1
37711: PPUSH
37712: CALL 64336 0 3
37716: PPUSH
37717: CALL_OW 1
37721: ST_TO_ADDR
// end ;
37722: GO 37631
37724: POP
37725: POP
// end ;
37726: LD_VAR 0 1
37730: RET
// export function MC_InitSides ( ) ; var i ; begin
37731: LD_INT 0
37733: PPUSH
37734: PPUSH
// if not mc_bases then
37735: LD_EXP 101
37739: NOT
37740: IFFALSE 37744
// exit ;
37742: GO 37818
// for i = 1 to mc_bases do
37744: LD_ADDR_VAR 0 2
37748: PUSH
37749: DOUBLE
37750: LD_INT 1
37752: DEC
37753: ST_TO_ADDR
37754: LD_EXP 101
37758: PUSH
37759: FOR_TO
37760: IFFALSE 37816
// if mc_bases [ i ] then
37762: LD_EXP 101
37766: PUSH
37767: LD_VAR 0 2
37771: ARRAY
37772: IFFALSE 37814
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37774: LD_ADDR_EXP 127
37778: PUSH
37779: LD_EXP 127
37783: PPUSH
37784: LD_VAR 0 2
37788: PPUSH
37789: LD_EXP 101
37793: PUSH
37794: LD_VAR 0 2
37798: ARRAY
37799: PUSH
37800: LD_INT 1
37802: ARRAY
37803: PPUSH
37804: CALL_OW 255
37808: PPUSH
37809: CALL_OW 1
37813: ST_TO_ADDR
37814: GO 37759
37816: POP
37817: POP
// end ;
37818: LD_VAR 0 1
37822: RET
// every 0 0$01 trigger skirmish do
37823: LD_EXP 99
37827: IFFALSE 37981
37829: GO 37831
37831: DISABLE
// begin enable ;
37832: ENABLE
// MC_CheckBuildings ( ) ;
37833: CALL 42479 0 0
// MC_CheckPeopleLife ( ) ;
37837: CALL 42604 0 0
// RaiseSailEvent ( 100 ) ;
37841: LD_INT 100
37843: PPUSH
37844: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37848: LD_INT 103
37850: PPUSH
37851: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37855: LD_INT 104
37857: PPUSH
37858: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37862: LD_INT 105
37864: PPUSH
37865: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37869: LD_INT 106
37871: PPUSH
37872: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37876: LD_INT 107
37878: PPUSH
37879: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37883: LD_INT 108
37885: PPUSH
37886: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37890: LD_INT 109
37892: PPUSH
37893: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37897: LD_INT 110
37899: PPUSH
37900: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37904: LD_INT 111
37906: PPUSH
37907: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37911: LD_INT 112
37913: PPUSH
37914: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37918: LD_INT 113
37920: PPUSH
37921: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37925: LD_INT 120
37927: PPUSH
37928: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37932: LD_INT 121
37934: PPUSH
37935: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37939: LD_INT 122
37941: PPUSH
37942: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37946: LD_INT 123
37948: PPUSH
37949: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37953: LD_INT 124
37955: PPUSH
37956: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37960: LD_INT 125
37962: PPUSH
37963: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37967: LD_INT 126
37969: PPUSH
37970: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37974: LD_INT 200
37976: PPUSH
37977: CALL_OW 427
// end ;
37981: END
// on SailEvent ( event ) do begin if event < 100 then
37982: LD_VAR 0 1
37986: PUSH
37987: LD_INT 100
37989: LESS
37990: IFFALSE 38001
// CustomEvent ( event ) ;
37992: LD_VAR 0 1
37996: PPUSH
37997: CALL 32641 0 1
// if event = 100 then
38001: LD_VAR 0 1
38005: PUSH
38006: LD_INT 100
38008: EQUAL
38009: IFFALSE 38015
// MC_ClassManager ( ) ;
38011: CALL 38407 0 0
// if event = 101 then
38015: LD_VAR 0 1
38019: PUSH
38020: LD_INT 101
38022: EQUAL
38023: IFFALSE 38029
// MC_RepairBuildings ( ) ;
38025: CALL 43200 0 0
// if event = 102 then
38029: LD_VAR 0 1
38033: PUSH
38034: LD_INT 102
38036: EQUAL
38037: IFFALSE 38043
// MC_Heal ( ) ;
38039: CALL 44064 0 0
// if event = 103 then
38043: LD_VAR 0 1
38047: PUSH
38048: LD_INT 103
38050: EQUAL
38051: IFFALSE 38057
// MC_Build ( ) ;
38053: CALL 44486 0 0
// if event = 104 then
38057: LD_VAR 0 1
38061: PUSH
38062: LD_INT 104
38064: EQUAL
38065: IFFALSE 38071
// MC_TurretWeapon ( ) ;
38067: CALL 46099 0 0
// if event = 105 then
38071: LD_VAR 0 1
38075: PUSH
38076: LD_INT 105
38078: EQUAL
38079: IFFALSE 38085
// MC_BuildUpgrade ( ) ;
38081: CALL 45650 0 0
// if event = 106 then
38085: LD_VAR 0 1
38089: PUSH
38090: LD_INT 106
38092: EQUAL
38093: IFFALSE 38099
// MC_PlantMines ( ) ;
38095: CALL 46529 0 0
// if event = 107 then
38099: LD_VAR 0 1
38103: PUSH
38104: LD_INT 107
38106: EQUAL
38107: IFFALSE 38113
// MC_CollectCrates ( ) ;
38109: CALL 47327 0 0
// if event = 108 then
38113: LD_VAR 0 1
38117: PUSH
38118: LD_INT 108
38120: EQUAL
38121: IFFALSE 38127
// MC_LinkRemoteControl ( ) ;
38123: CALL 49103 0 0
// if event = 109 then
38127: LD_VAR 0 1
38131: PUSH
38132: LD_INT 109
38134: EQUAL
38135: IFFALSE 38141
// MC_ProduceVehicle ( ) ;
38137: CALL 49284 0 0
// if event = 110 then
38141: LD_VAR 0 1
38145: PUSH
38146: LD_INT 110
38148: EQUAL
38149: IFFALSE 38155
// MC_SendAttack ( ) ;
38151: CALL 49750 0 0
// if event = 111 then
38155: LD_VAR 0 1
38159: PUSH
38160: LD_INT 111
38162: EQUAL
38163: IFFALSE 38169
// MC_Defend ( ) ;
38165: CALL 49858 0 0
// if event = 112 then
38169: LD_VAR 0 1
38173: PUSH
38174: LD_INT 112
38176: EQUAL
38177: IFFALSE 38183
// MC_Research ( ) ;
38179: CALL 50463 0 0
// if event = 113 then
38183: LD_VAR 0 1
38187: PUSH
38188: LD_INT 113
38190: EQUAL
38191: IFFALSE 38197
// MC_MinesTrigger ( ) ;
38193: CALL 51577 0 0
// if event = 120 then
38197: LD_VAR 0 1
38201: PUSH
38202: LD_INT 120
38204: EQUAL
38205: IFFALSE 38211
// MC_RepairVehicle ( ) ;
38207: CALL 51676 0 0
// if event = 121 then
38211: LD_VAR 0 1
38215: PUSH
38216: LD_INT 121
38218: EQUAL
38219: IFFALSE 38225
// MC_TameApe ( ) ;
38221: CALL 52406 0 0
// if event = 122 then
38225: LD_VAR 0 1
38229: PUSH
38230: LD_INT 122
38232: EQUAL
38233: IFFALSE 38239
// MC_ChangeApeClass ( ) ;
38235: CALL 53235 0 0
// if event = 123 then
38239: LD_VAR 0 1
38243: PUSH
38244: LD_INT 123
38246: EQUAL
38247: IFFALSE 38253
// MC_Bazooka ( ) ;
38249: CALL 53885 0 0
// if event = 124 then
38253: LD_VAR 0 1
38257: PUSH
38258: LD_INT 124
38260: EQUAL
38261: IFFALSE 38267
// MC_TeleportExit ( ) ;
38263: CALL 54083 0 0
// if event = 125 then
38267: LD_VAR 0 1
38271: PUSH
38272: LD_INT 125
38274: EQUAL
38275: IFFALSE 38281
// MC_Deposits ( ) ;
38277: CALL 54730 0 0
// if event = 126 then
38281: LD_VAR 0 1
38285: PUSH
38286: LD_INT 126
38288: EQUAL
38289: IFFALSE 38295
// MC_RemoteDriver ( ) ;
38291: CALL 55355 0 0
// if event = 200 then
38295: LD_VAR 0 1
38299: PUSH
38300: LD_INT 200
38302: EQUAL
38303: IFFALSE 38309
// MC_Idle ( ) ;
38305: CALL 57304 0 0
// end ;
38309: PPOPN 1
38311: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38312: LD_INT 0
38314: PPUSH
38315: PPUSH
// if not mc_bases [ base ] or not tag then
38316: LD_EXP 101
38320: PUSH
38321: LD_VAR 0 1
38325: ARRAY
38326: NOT
38327: PUSH
38328: LD_VAR 0 2
38332: NOT
38333: OR
38334: IFFALSE 38338
// exit ;
38336: GO 38402
// for i in mc_bases [ base ] union mc_ape [ base ] do
38338: LD_ADDR_VAR 0 4
38342: PUSH
38343: LD_EXP 101
38347: PUSH
38348: LD_VAR 0 1
38352: ARRAY
38353: PUSH
38354: LD_EXP 130
38358: PUSH
38359: LD_VAR 0 1
38363: ARRAY
38364: UNION
38365: PUSH
38366: FOR_IN
38367: IFFALSE 38400
// if GetTag ( i ) = tag then
38369: LD_VAR 0 4
38373: PPUSH
38374: CALL_OW 110
38378: PUSH
38379: LD_VAR 0 2
38383: EQUAL
38384: IFFALSE 38398
// SetTag ( i , 0 ) ;
38386: LD_VAR 0 4
38390: PPUSH
38391: LD_INT 0
38393: PPUSH
38394: CALL_OW 109
38398: GO 38366
38400: POP
38401: POP
// end ;
38402: LD_VAR 0 3
38406: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38407: LD_INT 0
38409: PPUSH
38410: PPUSH
38411: PPUSH
38412: PPUSH
38413: PPUSH
38414: PPUSH
38415: PPUSH
38416: PPUSH
// if not mc_bases then
38417: LD_EXP 101
38421: NOT
38422: IFFALSE 38426
// exit ;
38424: GO 38884
// for i = 1 to mc_bases do
38426: LD_ADDR_VAR 0 2
38430: PUSH
38431: DOUBLE
38432: LD_INT 1
38434: DEC
38435: ST_TO_ADDR
38436: LD_EXP 101
38440: PUSH
38441: FOR_TO
38442: IFFALSE 38882
// begin tmp := MC_ClassCheckReq ( i ) ;
38444: LD_ADDR_VAR 0 4
38448: PUSH
38449: LD_VAR 0 2
38453: PPUSH
38454: CALL 38889 0 1
38458: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38459: LD_ADDR_EXP 142
38463: PUSH
38464: LD_EXP 142
38468: PPUSH
38469: LD_VAR 0 2
38473: PPUSH
38474: LD_VAR 0 4
38478: PPUSH
38479: CALL_OW 1
38483: ST_TO_ADDR
// if not tmp then
38484: LD_VAR 0 4
38488: NOT
38489: IFFALSE 38493
// continue ;
38491: GO 38441
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38493: LD_ADDR_VAR 0 6
38497: PUSH
38498: LD_EXP 101
38502: PUSH
38503: LD_VAR 0 2
38507: ARRAY
38508: PPUSH
38509: LD_INT 2
38511: PUSH
38512: LD_INT 30
38514: PUSH
38515: LD_INT 4
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 30
38524: PUSH
38525: LD_INT 5
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: LIST
38536: PPUSH
38537: CALL_OW 72
38541: PUSH
38542: LD_EXP 101
38546: PUSH
38547: LD_VAR 0 2
38551: ARRAY
38552: PPUSH
38553: LD_INT 2
38555: PUSH
38556: LD_INT 30
38558: PUSH
38559: LD_INT 0
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 30
38568: PUSH
38569: LD_INT 1
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: LIST
38580: PPUSH
38581: CALL_OW 72
38585: PUSH
38586: LD_EXP 101
38590: PUSH
38591: LD_VAR 0 2
38595: ARRAY
38596: PPUSH
38597: LD_INT 30
38599: PUSH
38600: LD_INT 3
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PPUSH
38607: CALL_OW 72
38611: PUSH
38612: LD_EXP 101
38616: PUSH
38617: LD_VAR 0 2
38621: ARRAY
38622: PPUSH
38623: LD_INT 2
38625: PUSH
38626: LD_INT 30
38628: PUSH
38629: LD_INT 6
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 30
38638: PUSH
38639: LD_INT 7
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: LD_INT 30
38648: PUSH
38649: LD_INT 8
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: LIST
38660: LIST
38661: PPUSH
38662: CALL_OW 72
38666: PUSH
38667: EMPTY
38668: LIST
38669: LIST
38670: LIST
38671: LIST
38672: ST_TO_ADDR
// for j = 1 to 4 do
38673: LD_ADDR_VAR 0 3
38677: PUSH
38678: DOUBLE
38679: LD_INT 1
38681: DEC
38682: ST_TO_ADDR
38683: LD_INT 4
38685: PUSH
38686: FOR_TO
38687: IFFALSE 38878
// begin if not tmp [ j ] then
38689: LD_VAR 0 4
38693: PUSH
38694: LD_VAR 0 3
38698: ARRAY
38699: NOT
38700: IFFALSE 38704
// continue ;
38702: GO 38686
// for p in tmp [ j ] do
38704: LD_ADDR_VAR 0 5
38708: PUSH
38709: LD_VAR 0 4
38713: PUSH
38714: LD_VAR 0 3
38718: ARRAY
38719: PUSH
38720: FOR_IN
38721: IFFALSE 38874
// begin if not b [ j ] then
38723: LD_VAR 0 6
38727: PUSH
38728: LD_VAR 0 3
38732: ARRAY
38733: NOT
38734: IFFALSE 38738
// break ;
38736: GO 38874
// e := 0 ;
38738: LD_ADDR_VAR 0 7
38742: PUSH
38743: LD_INT 0
38745: ST_TO_ADDR
// for k in b [ j ] do
38746: LD_ADDR_VAR 0 8
38750: PUSH
38751: LD_VAR 0 6
38755: PUSH
38756: LD_VAR 0 3
38760: ARRAY
38761: PUSH
38762: FOR_IN
38763: IFFALSE 38790
// if IsNotFull ( k ) then
38765: LD_VAR 0 8
38769: PPUSH
38770: CALL 68776 0 1
38774: IFFALSE 38788
// begin e := k ;
38776: LD_ADDR_VAR 0 7
38780: PUSH
38781: LD_VAR 0 8
38785: ST_TO_ADDR
// break ;
38786: GO 38790
// end ;
38788: GO 38762
38790: POP
38791: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38792: LD_VAR 0 7
38796: PUSH
38797: LD_VAR 0 5
38801: PPUSH
38802: LD_VAR 0 7
38806: PPUSH
38807: CALL 105898 0 2
38811: NOT
38812: AND
38813: IFFALSE 38872
// begin if IsInUnit ( p ) then
38815: LD_VAR 0 5
38819: PPUSH
38820: CALL_OW 310
38824: IFFALSE 38835
// ComExitBuilding ( p ) ;
38826: LD_VAR 0 5
38830: PPUSH
38831: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38835: LD_VAR 0 5
38839: PPUSH
38840: LD_VAR 0 7
38844: PPUSH
38845: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38849: LD_VAR 0 5
38853: PPUSH
38854: LD_VAR 0 3
38858: PPUSH
38859: CALL_OW 183
// AddComExitBuilding ( p ) ;
38863: LD_VAR 0 5
38867: PPUSH
38868: CALL_OW 182
// end ; end ;
38872: GO 38720
38874: POP
38875: POP
// end ;
38876: GO 38686
38878: POP
38879: POP
// end ;
38880: GO 38441
38882: POP
38883: POP
// end ;
38884: LD_VAR 0 1
38888: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38889: LD_INT 0
38891: PPUSH
38892: PPUSH
38893: PPUSH
38894: PPUSH
38895: PPUSH
38896: PPUSH
38897: PPUSH
38898: PPUSH
38899: PPUSH
38900: PPUSH
38901: PPUSH
38902: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38903: LD_VAR 0 1
38907: NOT
38908: PUSH
38909: LD_EXP 101
38913: PUSH
38914: LD_VAR 0 1
38918: ARRAY
38919: NOT
38920: OR
38921: PUSH
38922: LD_EXP 101
38926: PUSH
38927: LD_VAR 0 1
38931: ARRAY
38932: PPUSH
38933: LD_INT 2
38935: PUSH
38936: LD_INT 30
38938: PUSH
38939: LD_INT 0
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 30
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: LIST
38960: PPUSH
38961: CALL_OW 72
38965: NOT
38966: OR
38967: IFFALSE 38971
// exit ;
38969: GO 42474
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38971: LD_ADDR_VAR 0 4
38975: PUSH
38976: LD_EXP 101
38980: PUSH
38981: LD_VAR 0 1
38985: ARRAY
38986: PPUSH
38987: LD_INT 2
38989: PUSH
38990: LD_INT 25
38992: PUSH
38993: LD_INT 1
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: LD_INT 25
39002: PUSH
39003: LD_INT 2
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 25
39012: PUSH
39013: LD_INT 3
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 25
39022: PUSH
39023: LD_INT 4
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 25
39032: PUSH
39033: LD_INT 5
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 25
39042: PUSH
39043: LD_INT 8
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 25
39052: PUSH
39053: LD_INT 9
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: PPUSH
39070: CALL_OW 72
39074: ST_TO_ADDR
// if not tmp then
39075: LD_VAR 0 4
39079: NOT
39080: IFFALSE 39084
// exit ;
39082: GO 42474
// for i in tmp do
39084: LD_ADDR_VAR 0 3
39088: PUSH
39089: LD_VAR 0 4
39093: PUSH
39094: FOR_IN
39095: IFFALSE 39126
// if GetTag ( i ) then
39097: LD_VAR 0 3
39101: PPUSH
39102: CALL_OW 110
39106: IFFALSE 39124
// tmp := tmp diff i ;
39108: LD_ADDR_VAR 0 4
39112: PUSH
39113: LD_VAR 0 4
39117: PUSH
39118: LD_VAR 0 3
39122: DIFF
39123: ST_TO_ADDR
39124: GO 39094
39126: POP
39127: POP
// if not tmp then
39128: LD_VAR 0 4
39132: NOT
39133: IFFALSE 39137
// exit ;
39135: GO 42474
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39137: LD_ADDR_VAR 0 5
39141: PUSH
39142: LD_EXP 101
39146: PUSH
39147: LD_VAR 0 1
39151: ARRAY
39152: PPUSH
39153: LD_INT 2
39155: PUSH
39156: LD_INT 25
39158: PUSH
39159: LD_INT 1
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 25
39168: PUSH
39169: LD_INT 5
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 25
39178: PUSH
39179: LD_INT 8
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: LD_INT 25
39188: PUSH
39189: LD_INT 9
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: LIST
39202: PPUSH
39203: CALL_OW 72
39207: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39208: LD_ADDR_VAR 0 6
39212: PUSH
39213: LD_EXP 101
39217: PUSH
39218: LD_VAR 0 1
39222: ARRAY
39223: PPUSH
39224: LD_INT 25
39226: PUSH
39227: LD_INT 2
39229: PUSH
39230: EMPTY
39231: LIST
39232: LIST
39233: PPUSH
39234: CALL_OW 72
39238: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39239: LD_ADDR_VAR 0 7
39243: PUSH
39244: LD_EXP 101
39248: PUSH
39249: LD_VAR 0 1
39253: ARRAY
39254: PPUSH
39255: LD_INT 25
39257: PUSH
39258: LD_INT 3
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PPUSH
39265: CALL_OW 72
39269: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39270: LD_ADDR_VAR 0 8
39274: PUSH
39275: LD_EXP 101
39279: PUSH
39280: LD_VAR 0 1
39284: ARRAY
39285: PPUSH
39286: LD_INT 25
39288: PUSH
39289: LD_INT 4
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 24
39298: PUSH
39299: LD_INT 251
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PPUSH
39310: CALL_OW 72
39314: ST_TO_ADDR
// if mc_scan [ base ] then
39315: LD_EXP 124
39319: PUSH
39320: LD_VAR 0 1
39324: ARRAY
39325: IFFALSE 39786
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39327: LD_ADDR_EXP 143
39331: PUSH
39332: LD_EXP 143
39336: PPUSH
39337: LD_VAR 0 1
39341: PPUSH
39342: LD_INT 4
39344: PPUSH
39345: CALL_OW 1
39349: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39350: LD_ADDR_VAR 0 12
39354: PUSH
39355: LD_EXP 101
39359: PUSH
39360: LD_VAR 0 1
39364: ARRAY
39365: PPUSH
39366: LD_INT 2
39368: PUSH
39369: LD_INT 30
39371: PUSH
39372: LD_INT 4
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 30
39381: PUSH
39382: LD_INT 5
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: LIST
39393: PPUSH
39394: CALL_OW 72
39398: ST_TO_ADDR
// if not b then
39399: LD_VAR 0 12
39403: NOT
39404: IFFALSE 39408
// exit ;
39406: GO 42474
// p := [ ] ;
39408: LD_ADDR_VAR 0 11
39412: PUSH
39413: EMPTY
39414: ST_TO_ADDR
// if sci >= 2 then
39415: LD_VAR 0 8
39419: PUSH
39420: LD_INT 2
39422: GREATEREQUAL
39423: IFFALSE 39454
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39425: LD_ADDR_VAR 0 8
39429: PUSH
39430: LD_VAR 0 8
39434: PUSH
39435: LD_INT 1
39437: ARRAY
39438: PUSH
39439: LD_VAR 0 8
39443: PUSH
39444: LD_INT 2
39446: ARRAY
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: ST_TO_ADDR
39452: GO 39515
// if sci = 1 then
39454: LD_VAR 0 8
39458: PUSH
39459: LD_INT 1
39461: EQUAL
39462: IFFALSE 39483
// sci := [ sci [ 1 ] ] else
39464: LD_ADDR_VAR 0 8
39468: PUSH
39469: LD_VAR 0 8
39473: PUSH
39474: LD_INT 1
39476: ARRAY
39477: PUSH
39478: EMPTY
39479: LIST
39480: ST_TO_ADDR
39481: GO 39515
// if sci = 0 then
39483: LD_VAR 0 8
39487: PUSH
39488: LD_INT 0
39490: EQUAL
39491: IFFALSE 39515
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39493: LD_ADDR_VAR 0 11
39497: PUSH
39498: LD_VAR 0 4
39502: PPUSH
39503: LD_INT 4
39505: PPUSH
39506: CALL 105761 0 2
39510: PUSH
39511: LD_INT 1
39513: ARRAY
39514: ST_TO_ADDR
// if eng > 4 then
39515: LD_VAR 0 6
39519: PUSH
39520: LD_INT 4
39522: GREATER
39523: IFFALSE 39569
// for i = eng downto 4 do
39525: LD_ADDR_VAR 0 3
39529: PUSH
39530: DOUBLE
39531: LD_VAR 0 6
39535: INC
39536: ST_TO_ADDR
39537: LD_INT 4
39539: PUSH
39540: FOR_DOWNTO
39541: IFFALSE 39567
// eng := eng diff eng [ i ] ;
39543: LD_ADDR_VAR 0 6
39547: PUSH
39548: LD_VAR 0 6
39552: PUSH
39553: LD_VAR 0 6
39557: PUSH
39558: LD_VAR 0 3
39562: ARRAY
39563: DIFF
39564: ST_TO_ADDR
39565: GO 39540
39567: POP
39568: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39569: LD_ADDR_VAR 0 4
39573: PUSH
39574: LD_VAR 0 4
39578: PUSH
39579: LD_VAR 0 5
39583: PUSH
39584: LD_VAR 0 6
39588: UNION
39589: PUSH
39590: LD_VAR 0 7
39594: UNION
39595: PUSH
39596: LD_VAR 0 8
39600: UNION
39601: DIFF
39602: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39603: LD_ADDR_VAR 0 13
39607: PUSH
39608: LD_EXP 101
39612: PUSH
39613: LD_VAR 0 1
39617: ARRAY
39618: PPUSH
39619: LD_INT 2
39621: PUSH
39622: LD_INT 30
39624: PUSH
39625: LD_INT 32
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 30
39634: PUSH
39635: LD_INT 31
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: LIST
39646: PPUSH
39647: CALL_OW 72
39651: PUSH
39652: LD_EXP 101
39656: PUSH
39657: LD_VAR 0 1
39661: ARRAY
39662: PPUSH
39663: LD_INT 2
39665: PUSH
39666: LD_INT 30
39668: PUSH
39669: LD_INT 4
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: LD_INT 30
39678: PUSH
39679: LD_INT 5
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: LIST
39690: PPUSH
39691: CALL_OW 72
39695: PUSH
39696: LD_INT 6
39698: MUL
39699: PLUS
39700: ST_TO_ADDR
// if bcount < tmp then
39701: LD_VAR 0 13
39705: PUSH
39706: LD_VAR 0 4
39710: LESS
39711: IFFALSE 39757
// for i = tmp downto bcount do
39713: LD_ADDR_VAR 0 3
39717: PUSH
39718: DOUBLE
39719: LD_VAR 0 4
39723: INC
39724: ST_TO_ADDR
39725: LD_VAR 0 13
39729: PUSH
39730: FOR_DOWNTO
39731: IFFALSE 39755
// tmp := Delete ( tmp , tmp ) ;
39733: LD_ADDR_VAR 0 4
39737: PUSH
39738: LD_VAR 0 4
39742: PPUSH
39743: LD_VAR 0 4
39747: PPUSH
39748: CALL_OW 3
39752: ST_TO_ADDR
39753: GO 39730
39755: POP
39756: POP
// result := [ tmp , 0 , 0 , p ] ;
39757: LD_ADDR_VAR 0 2
39761: PUSH
39762: LD_VAR 0 4
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: LD_INT 0
39772: PUSH
39773: LD_VAR 0 11
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: LIST
39782: LIST
39783: ST_TO_ADDR
// exit ;
39784: GO 42474
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39786: LD_EXP 101
39790: PUSH
39791: LD_VAR 0 1
39795: ARRAY
39796: PPUSH
39797: LD_INT 2
39799: PUSH
39800: LD_INT 30
39802: PUSH
39803: LD_INT 6
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: LD_INT 30
39812: PUSH
39813: LD_INT 7
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 30
39822: PUSH
39823: LD_INT 8
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: PPUSH
39836: CALL_OW 72
39840: NOT
39841: PUSH
39842: LD_EXP 101
39846: PUSH
39847: LD_VAR 0 1
39851: ARRAY
39852: PPUSH
39853: LD_INT 30
39855: PUSH
39856: LD_INT 3
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PPUSH
39863: CALL_OW 72
39867: NOT
39868: AND
39869: IFFALSE 39941
// begin if eng = tmp then
39871: LD_VAR 0 6
39875: PUSH
39876: LD_VAR 0 4
39880: EQUAL
39881: IFFALSE 39885
// exit ;
39883: GO 42474
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39885: LD_ADDR_EXP 143
39889: PUSH
39890: LD_EXP 143
39894: PPUSH
39895: LD_VAR 0 1
39899: PPUSH
39900: LD_INT 1
39902: PPUSH
39903: CALL_OW 1
39907: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39908: LD_ADDR_VAR 0 2
39912: PUSH
39913: LD_INT 0
39915: PUSH
39916: LD_VAR 0 4
39920: PUSH
39921: LD_VAR 0 6
39925: DIFF
39926: PUSH
39927: LD_INT 0
39929: PUSH
39930: LD_INT 0
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: ST_TO_ADDR
// exit ;
39939: GO 42474
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39941: LD_EXP 128
39945: PUSH
39946: LD_EXP 127
39950: PUSH
39951: LD_VAR 0 1
39955: ARRAY
39956: ARRAY
39957: PUSH
39958: LD_EXP 101
39962: PUSH
39963: LD_VAR 0 1
39967: ARRAY
39968: PPUSH
39969: LD_INT 2
39971: PUSH
39972: LD_INT 30
39974: PUSH
39975: LD_INT 6
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 30
39984: PUSH
39985: LD_INT 7
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 30
39994: PUSH
39995: LD_INT 8
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: PPUSH
40008: CALL_OW 72
40012: AND
40013: PUSH
40014: LD_EXP 101
40018: PUSH
40019: LD_VAR 0 1
40023: ARRAY
40024: PPUSH
40025: LD_INT 30
40027: PUSH
40028: LD_INT 3
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PPUSH
40035: CALL_OW 72
40039: NOT
40040: AND
40041: IFFALSE 40255
// begin if sci >= 6 then
40043: LD_VAR 0 8
40047: PUSH
40048: LD_INT 6
40050: GREATEREQUAL
40051: IFFALSE 40055
// exit ;
40053: GO 42474
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40055: LD_ADDR_EXP 143
40059: PUSH
40060: LD_EXP 143
40064: PPUSH
40065: LD_VAR 0 1
40069: PPUSH
40070: LD_INT 2
40072: PPUSH
40073: CALL_OW 1
40077: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40078: LD_ADDR_VAR 0 9
40082: PUSH
40083: LD_VAR 0 4
40087: PUSH
40088: LD_VAR 0 8
40092: DIFF
40093: PPUSH
40094: LD_INT 4
40096: PPUSH
40097: CALL 105761 0 2
40101: ST_TO_ADDR
// p := [ ] ;
40102: LD_ADDR_VAR 0 11
40106: PUSH
40107: EMPTY
40108: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40109: LD_VAR 0 8
40113: PUSH
40114: LD_INT 6
40116: LESS
40117: PUSH
40118: LD_VAR 0 9
40122: PUSH
40123: LD_INT 6
40125: GREATER
40126: AND
40127: IFFALSE 40208
// begin for i = 1 to 6 - sci do
40129: LD_ADDR_VAR 0 3
40133: PUSH
40134: DOUBLE
40135: LD_INT 1
40137: DEC
40138: ST_TO_ADDR
40139: LD_INT 6
40141: PUSH
40142: LD_VAR 0 8
40146: MINUS
40147: PUSH
40148: FOR_TO
40149: IFFALSE 40204
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40151: LD_ADDR_VAR 0 11
40155: PUSH
40156: LD_VAR 0 11
40160: PPUSH
40161: LD_VAR 0 11
40165: PUSH
40166: LD_INT 1
40168: PLUS
40169: PPUSH
40170: LD_VAR 0 9
40174: PUSH
40175: LD_INT 1
40177: ARRAY
40178: PPUSH
40179: CALL_OW 2
40183: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40184: LD_ADDR_VAR 0 9
40188: PUSH
40189: LD_VAR 0 9
40193: PPUSH
40194: LD_INT 1
40196: PPUSH
40197: CALL_OW 3
40201: ST_TO_ADDR
// end ;
40202: GO 40148
40204: POP
40205: POP
// end else
40206: GO 40228
// if sort then
40208: LD_VAR 0 9
40212: IFFALSE 40228
// p := sort [ 1 ] ;
40214: LD_ADDR_VAR 0 11
40218: PUSH
40219: LD_VAR 0 9
40223: PUSH
40224: LD_INT 1
40226: ARRAY
40227: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40228: LD_ADDR_VAR 0 2
40232: PUSH
40233: LD_INT 0
40235: PUSH
40236: LD_INT 0
40238: PUSH
40239: LD_INT 0
40241: PUSH
40242: LD_VAR 0 11
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: LIST
40251: LIST
40252: ST_TO_ADDR
// exit ;
40253: GO 42474
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40255: LD_EXP 128
40259: PUSH
40260: LD_EXP 127
40264: PUSH
40265: LD_VAR 0 1
40269: ARRAY
40270: ARRAY
40271: PUSH
40272: LD_EXP 101
40276: PUSH
40277: LD_VAR 0 1
40281: ARRAY
40282: PPUSH
40283: LD_INT 2
40285: PUSH
40286: LD_INT 30
40288: PUSH
40289: LD_INT 6
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 30
40298: PUSH
40299: LD_INT 7
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 30
40308: PUSH
40309: LD_INT 8
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: LIST
40320: LIST
40321: PPUSH
40322: CALL_OW 72
40326: AND
40327: PUSH
40328: LD_EXP 101
40332: PUSH
40333: LD_VAR 0 1
40337: ARRAY
40338: PPUSH
40339: LD_INT 30
40341: PUSH
40342: LD_INT 3
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PPUSH
40349: CALL_OW 72
40353: AND
40354: IFFALSE 41088
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40356: LD_ADDR_EXP 143
40360: PUSH
40361: LD_EXP 143
40365: PPUSH
40366: LD_VAR 0 1
40370: PPUSH
40371: LD_INT 3
40373: PPUSH
40374: CALL_OW 1
40378: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40379: LD_ADDR_VAR 0 2
40383: PUSH
40384: LD_INT 0
40386: PUSH
40387: LD_INT 0
40389: PUSH
40390: LD_INT 0
40392: PUSH
40393: LD_INT 0
40395: PUSH
40396: EMPTY
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: ST_TO_ADDR
// if not eng then
40402: LD_VAR 0 6
40406: NOT
40407: IFFALSE 40470
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40409: LD_ADDR_VAR 0 11
40413: PUSH
40414: LD_VAR 0 4
40418: PPUSH
40419: LD_INT 2
40421: PPUSH
40422: CALL 105761 0 2
40426: PUSH
40427: LD_INT 1
40429: ARRAY
40430: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40431: LD_ADDR_VAR 0 2
40435: PUSH
40436: LD_VAR 0 2
40440: PPUSH
40441: LD_INT 2
40443: PPUSH
40444: LD_VAR 0 11
40448: PPUSH
40449: CALL_OW 1
40453: ST_TO_ADDR
// tmp := tmp diff p ;
40454: LD_ADDR_VAR 0 4
40458: PUSH
40459: LD_VAR 0 4
40463: PUSH
40464: LD_VAR 0 11
40468: DIFF
40469: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40470: LD_VAR 0 4
40474: PUSH
40475: LD_VAR 0 8
40479: PUSH
40480: LD_INT 6
40482: LESS
40483: AND
40484: IFFALSE 40672
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40486: LD_ADDR_VAR 0 9
40490: PUSH
40491: LD_VAR 0 4
40495: PUSH
40496: LD_VAR 0 8
40500: PUSH
40501: LD_VAR 0 7
40505: UNION
40506: DIFF
40507: PPUSH
40508: LD_INT 4
40510: PPUSH
40511: CALL 105761 0 2
40515: ST_TO_ADDR
// p := [ ] ;
40516: LD_ADDR_VAR 0 11
40520: PUSH
40521: EMPTY
40522: ST_TO_ADDR
// if sort then
40523: LD_VAR 0 9
40527: IFFALSE 40643
// for i = 1 to 6 - sci do
40529: LD_ADDR_VAR 0 3
40533: PUSH
40534: DOUBLE
40535: LD_INT 1
40537: DEC
40538: ST_TO_ADDR
40539: LD_INT 6
40541: PUSH
40542: LD_VAR 0 8
40546: MINUS
40547: PUSH
40548: FOR_TO
40549: IFFALSE 40641
// begin if i = sort then
40551: LD_VAR 0 3
40555: PUSH
40556: LD_VAR 0 9
40560: EQUAL
40561: IFFALSE 40565
// break ;
40563: GO 40641
// if GetClass ( i ) = 4 then
40565: LD_VAR 0 3
40569: PPUSH
40570: CALL_OW 257
40574: PUSH
40575: LD_INT 4
40577: EQUAL
40578: IFFALSE 40582
// continue ;
40580: GO 40548
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40582: LD_ADDR_VAR 0 11
40586: PUSH
40587: LD_VAR 0 11
40591: PPUSH
40592: LD_VAR 0 11
40596: PUSH
40597: LD_INT 1
40599: PLUS
40600: PPUSH
40601: LD_VAR 0 9
40605: PUSH
40606: LD_VAR 0 3
40610: ARRAY
40611: PPUSH
40612: CALL_OW 2
40616: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40617: LD_ADDR_VAR 0 4
40621: PUSH
40622: LD_VAR 0 4
40626: PUSH
40627: LD_VAR 0 9
40631: PUSH
40632: LD_VAR 0 3
40636: ARRAY
40637: DIFF
40638: ST_TO_ADDR
// end ;
40639: GO 40548
40641: POP
40642: POP
// if p then
40643: LD_VAR 0 11
40647: IFFALSE 40672
// result := Replace ( result , 4 , p ) ;
40649: LD_ADDR_VAR 0 2
40653: PUSH
40654: LD_VAR 0 2
40658: PPUSH
40659: LD_INT 4
40661: PPUSH
40662: LD_VAR 0 11
40666: PPUSH
40667: CALL_OW 1
40671: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40672: LD_VAR 0 4
40676: PUSH
40677: LD_VAR 0 7
40681: PUSH
40682: LD_INT 6
40684: LESS
40685: AND
40686: IFFALSE 40874
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40688: LD_ADDR_VAR 0 9
40692: PUSH
40693: LD_VAR 0 4
40697: PUSH
40698: LD_VAR 0 8
40702: PUSH
40703: LD_VAR 0 7
40707: UNION
40708: DIFF
40709: PPUSH
40710: LD_INT 3
40712: PPUSH
40713: CALL 105761 0 2
40717: ST_TO_ADDR
// p := [ ] ;
40718: LD_ADDR_VAR 0 11
40722: PUSH
40723: EMPTY
40724: ST_TO_ADDR
// if sort then
40725: LD_VAR 0 9
40729: IFFALSE 40845
// for i = 1 to 6 - mech do
40731: LD_ADDR_VAR 0 3
40735: PUSH
40736: DOUBLE
40737: LD_INT 1
40739: DEC
40740: ST_TO_ADDR
40741: LD_INT 6
40743: PUSH
40744: LD_VAR 0 7
40748: MINUS
40749: PUSH
40750: FOR_TO
40751: IFFALSE 40843
// begin if i = sort then
40753: LD_VAR 0 3
40757: PUSH
40758: LD_VAR 0 9
40762: EQUAL
40763: IFFALSE 40767
// break ;
40765: GO 40843
// if GetClass ( i ) = 3 then
40767: LD_VAR 0 3
40771: PPUSH
40772: CALL_OW 257
40776: PUSH
40777: LD_INT 3
40779: EQUAL
40780: IFFALSE 40784
// continue ;
40782: GO 40750
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40784: LD_ADDR_VAR 0 11
40788: PUSH
40789: LD_VAR 0 11
40793: PPUSH
40794: LD_VAR 0 11
40798: PUSH
40799: LD_INT 1
40801: PLUS
40802: PPUSH
40803: LD_VAR 0 9
40807: PUSH
40808: LD_VAR 0 3
40812: ARRAY
40813: PPUSH
40814: CALL_OW 2
40818: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40819: LD_ADDR_VAR 0 4
40823: PUSH
40824: LD_VAR 0 4
40828: PUSH
40829: LD_VAR 0 9
40833: PUSH
40834: LD_VAR 0 3
40838: ARRAY
40839: DIFF
40840: ST_TO_ADDR
// end ;
40841: GO 40750
40843: POP
40844: POP
// if p then
40845: LD_VAR 0 11
40849: IFFALSE 40874
// result := Replace ( result , 3 , p ) ;
40851: LD_ADDR_VAR 0 2
40855: PUSH
40856: LD_VAR 0 2
40860: PPUSH
40861: LD_INT 3
40863: PPUSH
40864: LD_VAR 0 11
40868: PPUSH
40869: CALL_OW 1
40873: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40874: LD_VAR 0 4
40878: PUSH
40879: LD_INT 6
40881: GREATER
40882: PUSH
40883: LD_VAR 0 6
40887: PUSH
40888: LD_INT 6
40890: LESS
40891: AND
40892: IFFALSE 41086
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40894: LD_ADDR_VAR 0 9
40898: PUSH
40899: LD_VAR 0 4
40903: PUSH
40904: LD_VAR 0 8
40908: PUSH
40909: LD_VAR 0 7
40913: UNION
40914: PUSH
40915: LD_VAR 0 6
40919: UNION
40920: DIFF
40921: PPUSH
40922: LD_INT 2
40924: PPUSH
40925: CALL 105761 0 2
40929: ST_TO_ADDR
// p := [ ] ;
40930: LD_ADDR_VAR 0 11
40934: PUSH
40935: EMPTY
40936: ST_TO_ADDR
// if sort then
40937: LD_VAR 0 9
40941: IFFALSE 41057
// for i = 1 to 6 - eng do
40943: LD_ADDR_VAR 0 3
40947: PUSH
40948: DOUBLE
40949: LD_INT 1
40951: DEC
40952: ST_TO_ADDR
40953: LD_INT 6
40955: PUSH
40956: LD_VAR 0 6
40960: MINUS
40961: PUSH
40962: FOR_TO
40963: IFFALSE 41055
// begin if i = sort then
40965: LD_VAR 0 3
40969: PUSH
40970: LD_VAR 0 9
40974: EQUAL
40975: IFFALSE 40979
// break ;
40977: GO 41055
// if GetClass ( i ) = 2 then
40979: LD_VAR 0 3
40983: PPUSH
40984: CALL_OW 257
40988: PUSH
40989: LD_INT 2
40991: EQUAL
40992: IFFALSE 40996
// continue ;
40994: GO 40962
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40996: LD_ADDR_VAR 0 11
41000: PUSH
41001: LD_VAR 0 11
41005: PPUSH
41006: LD_VAR 0 11
41010: PUSH
41011: LD_INT 1
41013: PLUS
41014: PPUSH
41015: LD_VAR 0 9
41019: PUSH
41020: LD_VAR 0 3
41024: ARRAY
41025: PPUSH
41026: CALL_OW 2
41030: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41031: LD_ADDR_VAR 0 4
41035: PUSH
41036: LD_VAR 0 4
41040: PUSH
41041: LD_VAR 0 9
41045: PUSH
41046: LD_VAR 0 3
41050: ARRAY
41051: DIFF
41052: ST_TO_ADDR
// end ;
41053: GO 40962
41055: POP
41056: POP
// if p then
41057: LD_VAR 0 11
41061: IFFALSE 41086
// result := Replace ( result , 2 , p ) ;
41063: LD_ADDR_VAR 0 2
41067: PUSH
41068: LD_VAR 0 2
41072: PPUSH
41073: LD_INT 2
41075: PPUSH
41076: LD_VAR 0 11
41080: PPUSH
41081: CALL_OW 1
41085: ST_TO_ADDR
// end ; exit ;
41086: GO 42474
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41088: LD_EXP 128
41092: PUSH
41093: LD_EXP 127
41097: PUSH
41098: LD_VAR 0 1
41102: ARRAY
41103: ARRAY
41104: NOT
41105: PUSH
41106: LD_EXP 101
41110: PUSH
41111: LD_VAR 0 1
41115: ARRAY
41116: PPUSH
41117: LD_INT 30
41119: PUSH
41120: LD_INT 3
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PPUSH
41127: CALL_OW 72
41131: AND
41132: PUSH
41133: LD_EXP 106
41137: PUSH
41138: LD_VAR 0 1
41142: ARRAY
41143: AND
41144: IFFALSE 41752
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41146: LD_ADDR_EXP 143
41150: PUSH
41151: LD_EXP 143
41155: PPUSH
41156: LD_VAR 0 1
41160: PPUSH
41161: LD_INT 5
41163: PPUSH
41164: CALL_OW 1
41168: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41169: LD_ADDR_VAR 0 2
41173: PUSH
41174: LD_INT 0
41176: PUSH
41177: LD_INT 0
41179: PUSH
41180: LD_INT 0
41182: PUSH
41183: LD_INT 0
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: LIST
41190: LIST
41191: ST_TO_ADDR
// if sci > 1 then
41192: LD_VAR 0 8
41196: PUSH
41197: LD_INT 1
41199: GREATER
41200: IFFALSE 41228
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41202: LD_ADDR_VAR 0 4
41206: PUSH
41207: LD_VAR 0 4
41211: PUSH
41212: LD_VAR 0 8
41216: PUSH
41217: LD_VAR 0 8
41221: PUSH
41222: LD_INT 1
41224: ARRAY
41225: DIFF
41226: DIFF
41227: ST_TO_ADDR
// if tmp and not sci then
41228: LD_VAR 0 4
41232: PUSH
41233: LD_VAR 0 8
41237: NOT
41238: AND
41239: IFFALSE 41308
// begin sort := SortBySkill ( tmp , 4 ) ;
41241: LD_ADDR_VAR 0 9
41245: PUSH
41246: LD_VAR 0 4
41250: PPUSH
41251: LD_INT 4
41253: PPUSH
41254: CALL 105761 0 2
41258: ST_TO_ADDR
// if sort then
41259: LD_VAR 0 9
41263: IFFALSE 41279
// p := sort [ 1 ] ;
41265: LD_ADDR_VAR 0 11
41269: PUSH
41270: LD_VAR 0 9
41274: PUSH
41275: LD_INT 1
41277: ARRAY
41278: ST_TO_ADDR
// if p then
41279: LD_VAR 0 11
41283: IFFALSE 41308
// result := Replace ( result , 4 , p ) ;
41285: LD_ADDR_VAR 0 2
41289: PUSH
41290: LD_VAR 0 2
41294: PPUSH
41295: LD_INT 4
41297: PPUSH
41298: LD_VAR 0 11
41302: PPUSH
41303: CALL_OW 1
41307: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41308: LD_ADDR_VAR 0 4
41312: PUSH
41313: LD_VAR 0 4
41317: PUSH
41318: LD_VAR 0 7
41322: DIFF
41323: ST_TO_ADDR
// if tmp and mech < 6 then
41324: LD_VAR 0 4
41328: PUSH
41329: LD_VAR 0 7
41333: PUSH
41334: LD_INT 6
41336: LESS
41337: AND
41338: IFFALSE 41526
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41340: LD_ADDR_VAR 0 9
41344: PUSH
41345: LD_VAR 0 4
41349: PUSH
41350: LD_VAR 0 8
41354: PUSH
41355: LD_VAR 0 7
41359: UNION
41360: DIFF
41361: PPUSH
41362: LD_INT 3
41364: PPUSH
41365: CALL 105761 0 2
41369: ST_TO_ADDR
// p := [ ] ;
41370: LD_ADDR_VAR 0 11
41374: PUSH
41375: EMPTY
41376: ST_TO_ADDR
// if sort then
41377: LD_VAR 0 9
41381: IFFALSE 41497
// for i = 1 to 6 - mech do
41383: LD_ADDR_VAR 0 3
41387: PUSH
41388: DOUBLE
41389: LD_INT 1
41391: DEC
41392: ST_TO_ADDR
41393: LD_INT 6
41395: PUSH
41396: LD_VAR 0 7
41400: MINUS
41401: PUSH
41402: FOR_TO
41403: IFFALSE 41495
// begin if i = sort then
41405: LD_VAR 0 3
41409: PUSH
41410: LD_VAR 0 9
41414: EQUAL
41415: IFFALSE 41419
// break ;
41417: GO 41495
// if GetClass ( i ) = 3 then
41419: LD_VAR 0 3
41423: PPUSH
41424: CALL_OW 257
41428: PUSH
41429: LD_INT 3
41431: EQUAL
41432: IFFALSE 41436
// continue ;
41434: GO 41402
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41436: LD_ADDR_VAR 0 11
41440: PUSH
41441: LD_VAR 0 11
41445: PPUSH
41446: LD_VAR 0 11
41450: PUSH
41451: LD_INT 1
41453: PLUS
41454: PPUSH
41455: LD_VAR 0 9
41459: PUSH
41460: LD_VAR 0 3
41464: ARRAY
41465: PPUSH
41466: CALL_OW 2
41470: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41471: LD_ADDR_VAR 0 4
41475: PUSH
41476: LD_VAR 0 4
41480: PUSH
41481: LD_VAR 0 9
41485: PUSH
41486: LD_VAR 0 3
41490: ARRAY
41491: DIFF
41492: ST_TO_ADDR
// end ;
41493: GO 41402
41495: POP
41496: POP
// if p then
41497: LD_VAR 0 11
41501: IFFALSE 41526
// result := Replace ( result , 3 , p ) ;
41503: LD_ADDR_VAR 0 2
41507: PUSH
41508: LD_VAR 0 2
41512: PPUSH
41513: LD_INT 3
41515: PPUSH
41516: LD_VAR 0 11
41520: PPUSH
41521: CALL_OW 1
41525: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41526: LD_ADDR_VAR 0 4
41530: PUSH
41531: LD_VAR 0 4
41535: PUSH
41536: LD_VAR 0 6
41540: DIFF
41541: ST_TO_ADDR
// if tmp and eng < 6 then
41542: LD_VAR 0 4
41546: PUSH
41547: LD_VAR 0 6
41551: PUSH
41552: LD_INT 6
41554: LESS
41555: AND
41556: IFFALSE 41750
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41558: LD_ADDR_VAR 0 9
41562: PUSH
41563: LD_VAR 0 4
41567: PUSH
41568: LD_VAR 0 8
41572: PUSH
41573: LD_VAR 0 7
41577: UNION
41578: PUSH
41579: LD_VAR 0 6
41583: UNION
41584: DIFF
41585: PPUSH
41586: LD_INT 2
41588: PPUSH
41589: CALL 105761 0 2
41593: ST_TO_ADDR
// p := [ ] ;
41594: LD_ADDR_VAR 0 11
41598: PUSH
41599: EMPTY
41600: ST_TO_ADDR
// if sort then
41601: LD_VAR 0 9
41605: IFFALSE 41721
// for i = 1 to 6 - eng do
41607: LD_ADDR_VAR 0 3
41611: PUSH
41612: DOUBLE
41613: LD_INT 1
41615: DEC
41616: ST_TO_ADDR
41617: LD_INT 6
41619: PUSH
41620: LD_VAR 0 6
41624: MINUS
41625: PUSH
41626: FOR_TO
41627: IFFALSE 41719
// begin if i = sort then
41629: LD_VAR 0 3
41633: PUSH
41634: LD_VAR 0 9
41638: EQUAL
41639: IFFALSE 41643
// break ;
41641: GO 41719
// if GetClass ( i ) = 2 then
41643: LD_VAR 0 3
41647: PPUSH
41648: CALL_OW 257
41652: PUSH
41653: LD_INT 2
41655: EQUAL
41656: IFFALSE 41660
// continue ;
41658: GO 41626
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41660: LD_ADDR_VAR 0 11
41664: PUSH
41665: LD_VAR 0 11
41669: PPUSH
41670: LD_VAR 0 11
41674: PUSH
41675: LD_INT 1
41677: PLUS
41678: PPUSH
41679: LD_VAR 0 9
41683: PUSH
41684: LD_VAR 0 3
41688: ARRAY
41689: PPUSH
41690: CALL_OW 2
41694: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41695: LD_ADDR_VAR 0 4
41699: PUSH
41700: LD_VAR 0 4
41704: PUSH
41705: LD_VAR 0 9
41709: PUSH
41710: LD_VAR 0 3
41714: ARRAY
41715: DIFF
41716: ST_TO_ADDR
// end ;
41717: GO 41626
41719: POP
41720: POP
// if p then
41721: LD_VAR 0 11
41725: IFFALSE 41750
// result := Replace ( result , 2 , p ) ;
41727: LD_ADDR_VAR 0 2
41731: PUSH
41732: LD_VAR 0 2
41736: PPUSH
41737: LD_INT 2
41739: PPUSH
41740: LD_VAR 0 11
41744: PPUSH
41745: CALL_OW 1
41749: ST_TO_ADDR
// end ; exit ;
41750: GO 42474
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41752: LD_EXP 128
41756: PUSH
41757: LD_EXP 127
41761: PUSH
41762: LD_VAR 0 1
41766: ARRAY
41767: ARRAY
41768: NOT
41769: PUSH
41770: LD_EXP 101
41774: PUSH
41775: LD_VAR 0 1
41779: ARRAY
41780: PPUSH
41781: LD_INT 30
41783: PUSH
41784: LD_INT 3
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PPUSH
41791: CALL_OW 72
41795: AND
41796: PUSH
41797: LD_EXP 106
41801: PUSH
41802: LD_VAR 0 1
41806: ARRAY
41807: NOT
41808: AND
41809: IFFALSE 42474
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41811: LD_ADDR_EXP 143
41815: PUSH
41816: LD_EXP 143
41820: PPUSH
41821: LD_VAR 0 1
41825: PPUSH
41826: LD_INT 6
41828: PPUSH
41829: CALL_OW 1
41833: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41834: LD_ADDR_VAR 0 2
41838: PUSH
41839: LD_INT 0
41841: PUSH
41842: LD_INT 0
41844: PUSH
41845: LD_INT 0
41847: PUSH
41848: LD_INT 0
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: LIST
41855: LIST
41856: ST_TO_ADDR
// if sci >= 1 then
41857: LD_VAR 0 8
41861: PUSH
41862: LD_INT 1
41864: GREATEREQUAL
41865: IFFALSE 41887
// tmp := tmp diff sci [ 1 ] ;
41867: LD_ADDR_VAR 0 4
41871: PUSH
41872: LD_VAR 0 4
41876: PUSH
41877: LD_VAR 0 8
41881: PUSH
41882: LD_INT 1
41884: ARRAY
41885: DIFF
41886: ST_TO_ADDR
// if tmp and not sci then
41887: LD_VAR 0 4
41891: PUSH
41892: LD_VAR 0 8
41896: NOT
41897: AND
41898: IFFALSE 41967
// begin sort := SortBySkill ( tmp , 4 ) ;
41900: LD_ADDR_VAR 0 9
41904: PUSH
41905: LD_VAR 0 4
41909: PPUSH
41910: LD_INT 4
41912: PPUSH
41913: CALL 105761 0 2
41917: ST_TO_ADDR
// if sort then
41918: LD_VAR 0 9
41922: IFFALSE 41938
// p := sort [ 1 ] ;
41924: LD_ADDR_VAR 0 11
41928: PUSH
41929: LD_VAR 0 9
41933: PUSH
41934: LD_INT 1
41936: ARRAY
41937: ST_TO_ADDR
// if p then
41938: LD_VAR 0 11
41942: IFFALSE 41967
// result := Replace ( result , 4 , p ) ;
41944: LD_ADDR_VAR 0 2
41948: PUSH
41949: LD_VAR 0 2
41953: PPUSH
41954: LD_INT 4
41956: PPUSH
41957: LD_VAR 0 11
41961: PPUSH
41962: CALL_OW 1
41966: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41967: LD_ADDR_VAR 0 4
41971: PUSH
41972: LD_VAR 0 4
41976: PUSH
41977: LD_VAR 0 7
41981: DIFF
41982: ST_TO_ADDR
// if tmp and mech < 6 then
41983: LD_VAR 0 4
41987: PUSH
41988: LD_VAR 0 7
41992: PUSH
41993: LD_INT 6
41995: LESS
41996: AND
41997: IFFALSE 42179
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41999: LD_ADDR_VAR 0 9
42003: PUSH
42004: LD_VAR 0 4
42008: PUSH
42009: LD_VAR 0 7
42013: DIFF
42014: PPUSH
42015: LD_INT 3
42017: PPUSH
42018: CALL 105761 0 2
42022: ST_TO_ADDR
// p := [ ] ;
42023: LD_ADDR_VAR 0 11
42027: PUSH
42028: EMPTY
42029: ST_TO_ADDR
// if sort then
42030: LD_VAR 0 9
42034: IFFALSE 42150
// for i = 1 to 6 - mech do
42036: LD_ADDR_VAR 0 3
42040: PUSH
42041: DOUBLE
42042: LD_INT 1
42044: DEC
42045: ST_TO_ADDR
42046: LD_INT 6
42048: PUSH
42049: LD_VAR 0 7
42053: MINUS
42054: PUSH
42055: FOR_TO
42056: IFFALSE 42148
// begin if i = sort then
42058: LD_VAR 0 3
42062: PUSH
42063: LD_VAR 0 9
42067: EQUAL
42068: IFFALSE 42072
// break ;
42070: GO 42148
// if GetClass ( i ) = 3 then
42072: LD_VAR 0 3
42076: PPUSH
42077: CALL_OW 257
42081: PUSH
42082: LD_INT 3
42084: EQUAL
42085: IFFALSE 42089
// continue ;
42087: GO 42055
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42089: LD_ADDR_VAR 0 11
42093: PUSH
42094: LD_VAR 0 11
42098: PPUSH
42099: LD_VAR 0 11
42103: PUSH
42104: LD_INT 1
42106: PLUS
42107: PPUSH
42108: LD_VAR 0 9
42112: PUSH
42113: LD_VAR 0 3
42117: ARRAY
42118: PPUSH
42119: CALL_OW 2
42123: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42124: LD_ADDR_VAR 0 4
42128: PUSH
42129: LD_VAR 0 4
42133: PUSH
42134: LD_VAR 0 9
42138: PUSH
42139: LD_VAR 0 3
42143: ARRAY
42144: DIFF
42145: ST_TO_ADDR
// end ;
42146: GO 42055
42148: POP
42149: POP
// if p then
42150: LD_VAR 0 11
42154: IFFALSE 42179
// result := Replace ( result , 3 , p ) ;
42156: LD_ADDR_VAR 0 2
42160: PUSH
42161: LD_VAR 0 2
42165: PPUSH
42166: LD_INT 3
42168: PPUSH
42169: LD_VAR 0 11
42173: PPUSH
42174: CALL_OW 1
42178: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42179: LD_ADDR_VAR 0 4
42183: PUSH
42184: LD_VAR 0 4
42188: PUSH
42189: LD_VAR 0 6
42193: DIFF
42194: ST_TO_ADDR
// if tmp and eng < 4 then
42195: LD_VAR 0 4
42199: PUSH
42200: LD_VAR 0 6
42204: PUSH
42205: LD_INT 4
42207: LESS
42208: AND
42209: IFFALSE 42399
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42211: LD_ADDR_VAR 0 9
42215: PUSH
42216: LD_VAR 0 4
42220: PUSH
42221: LD_VAR 0 7
42225: PUSH
42226: LD_VAR 0 6
42230: UNION
42231: DIFF
42232: PPUSH
42233: LD_INT 2
42235: PPUSH
42236: CALL 105761 0 2
42240: ST_TO_ADDR
// p := [ ] ;
42241: LD_ADDR_VAR 0 11
42245: PUSH
42246: EMPTY
42247: ST_TO_ADDR
// if sort then
42248: LD_VAR 0 9
42252: IFFALSE 42368
// for i = 1 to 4 - eng do
42254: LD_ADDR_VAR 0 3
42258: PUSH
42259: DOUBLE
42260: LD_INT 1
42262: DEC
42263: ST_TO_ADDR
42264: LD_INT 4
42266: PUSH
42267: LD_VAR 0 6
42271: MINUS
42272: PUSH
42273: FOR_TO
42274: IFFALSE 42366
// begin if i = sort then
42276: LD_VAR 0 3
42280: PUSH
42281: LD_VAR 0 9
42285: EQUAL
42286: IFFALSE 42290
// break ;
42288: GO 42366
// if GetClass ( i ) = 2 then
42290: LD_VAR 0 3
42294: PPUSH
42295: CALL_OW 257
42299: PUSH
42300: LD_INT 2
42302: EQUAL
42303: IFFALSE 42307
// continue ;
42305: GO 42273
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42307: LD_ADDR_VAR 0 11
42311: PUSH
42312: LD_VAR 0 11
42316: PPUSH
42317: LD_VAR 0 11
42321: PUSH
42322: LD_INT 1
42324: PLUS
42325: PPUSH
42326: LD_VAR 0 9
42330: PUSH
42331: LD_VAR 0 3
42335: ARRAY
42336: PPUSH
42337: CALL_OW 2
42341: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42342: LD_ADDR_VAR 0 4
42346: PUSH
42347: LD_VAR 0 4
42351: PUSH
42352: LD_VAR 0 9
42356: PUSH
42357: LD_VAR 0 3
42361: ARRAY
42362: DIFF
42363: ST_TO_ADDR
// end ;
42364: GO 42273
42366: POP
42367: POP
// if p then
42368: LD_VAR 0 11
42372: IFFALSE 42397
// result := Replace ( result , 2 , p ) ;
42374: LD_ADDR_VAR 0 2
42378: PUSH
42379: LD_VAR 0 2
42383: PPUSH
42384: LD_INT 2
42386: PPUSH
42387: LD_VAR 0 11
42391: PPUSH
42392: CALL_OW 1
42396: ST_TO_ADDR
// end else
42397: GO 42443
// for i = eng downto 5 do
42399: LD_ADDR_VAR 0 3
42403: PUSH
42404: DOUBLE
42405: LD_VAR 0 6
42409: INC
42410: ST_TO_ADDR
42411: LD_INT 5
42413: PUSH
42414: FOR_DOWNTO
42415: IFFALSE 42441
// tmp := tmp union eng [ i ] ;
42417: LD_ADDR_VAR 0 4
42421: PUSH
42422: LD_VAR 0 4
42426: PUSH
42427: LD_VAR 0 6
42431: PUSH
42432: LD_VAR 0 3
42436: ARRAY
42437: UNION
42438: ST_TO_ADDR
42439: GO 42414
42441: POP
42442: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42443: LD_ADDR_VAR 0 2
42447: PUSH
42448: LD_VAR 0 2
42452: PPUSH
42453: LD_INT 1
42455: PPUSH
42456: LD_VAR 0 4
42460: PUSH
42461: LD_VAR 0 5
42465: DIFF
42466: PPUSH
42467: CALL_OW 1
42471: ST_TO_ADDR
// exit ;
42472: GO 42474
// end ; end ;
42474: LD_VAR 0 2
42478: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42479: LD_INT 0
42481: PPUSH
42482: PPUSH
42483: PPUSH
// if not mc_bases then
42484: LD_EXP 101
42488: NOT
42489: IFFALSE 42493
// exit ;
42491: GO 42599
// for i = 1 to mc_bases do
42493: LD_ADDR_VAR 0 2
42497: PUSH
42498: DOUBLE
42499: LD_INT 1
42501: DEC
42502: ST_TO_ADDR
42503: LD_EXP 101
42507: PUSH
42508: FOR_TO
42509: IFFALSE 42590
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42511: LD_ADDR_VAR 0 3
42515: PUSH
42516: LD_EXP 101
42520: PUSH
42521: LD_VAR 0 2
42525: ARRAY
42526: PPUSH
42527: LD_INT 21
42529: PUSH
42530: LD_INT 3
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: LD_INT 3
42539: PUSH
42540: LD_INT 24
42542: PUSH
42543: LD_INT 1000
42545: PUSH
42546: EMPTY
42547: LIST
42548: LIST
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PPUSH
42558: CALL_OW 72
42562: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42563: LD_ADDR_EXP 102
42567: PUSH
42568: LD_EXP 102
42572: PPUSH
42573: LD_VAR 0 2
42577: PPUSH
42578: LD_VAR 0 3
42582: PPUSH
42583: CALL_OW 1
42587: ST_TO_ADDR
// end ;
42588: GO 42508
42590: POP
42591: POP
// RaiseSailEvent ( 101 ) ;
42592: LD_INT 101
42594: PPUSH
42595: CALL_OW 427
// end ;
42599: LD_VAR 0 1
42603: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42604: LD_INT 0
42606: PPUSH
42607: PPUSH
42608: PPUSH
42609: PPUSH
42610: PPUSH
42611: PPUSH
42612: PPUSH
// if not mc_bases then
42613: LD_EXP 101
42617: NOT
42618: IFFALSE 42622
// exit ;
42620: GO 43195
// for i = 1 to mc_bases do
42622: LD_ADDR_VAR 0 2
42626: PUSH
42627: DOUBLE
42628: LD_INT 1
42630: DEC
42631: ST_TO_ADDR
42632: LD_EXP 101
42636: PUSH
42637: FOR_TO
42638: IFFALSE 43186
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42640: LD_ADDR_VAR 0 5
42644: PUSH
42645: LD_EXP 101
42649: PUSH
42650: LD_VAR 0 2
42654: ARRAY
42655: PUSH
42656: LD_EXP 130
42660: PUSH
42661: LD_VAR 0 2
42665: ARRAY
42666: UNION
42667: PPUSH
42668: LD_INT 21
42670: PUSH
42671: LD_INT 1
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 1
42680: PUSH
42681: LD_INT 3
42683: PUSH
42684: LD_INT 54
42686: PUSH
42687: EMPTY
42688: LIST
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 3
42696: PUSH
42697: LD_INT 24
42699: PUSH
42700: LD_INT 800
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: LIST
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PPUSH
42720: CALL_OW 72
42724: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42725: LD_ADDR_VAR 0 6
42729: PUSH
42730: LD_EXP 101
42734: PUSH
42735: LD_VAR 0 2
42739: ARRAY
42740: PPUSH
42741: LD_INT 21
42743: PUSH
42744: LD_INT 1
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 1
42753: PUSH
42754: LD_INT 3
42756: PUSH
42757: LD_INT 54
42759: PUSH
42760: EMPTY
42761: LIST
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: PUSH
42767: LD_INT 3
42769: PUSH
42770: LD_INT 24
42772: PUSH
42773: LD_INT 250
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: LIST
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PPUSH
42793: CALL_OW 72
42797: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42798: LD_ADDR_VAR 0 7
42802: PUSH
42803: LD_VAR 0 5
42807: PUSH
42808: LD_VAR 0 6
42812: DIFF
42813: ST_TO_ADDR
// if not need_heal_1 then
42814: LD_VAR 0 6
42818: NOT
42819: IFFALSE 42852
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42821: LD_ADDR_EXP 104
42825: PUSH
42826: LD_EXP 104
42830: PPUSH
42831: LD_VAR 0 2
42835: PUSH
42836: LD_INT 1
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PPUSH
42843: EMPTY
42844: PPUSH
42845: CALL 71510 0 3
42849: ST_TO_ADDR
42850: GO 42922
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42852: LD_ADDR_EXP 104
42856: PUSH
42857: LD_EXP 104
42861: PPUSH
42862: LD_VAR 0 2
42866: PUSH
42867: LD_INT 1
42869: PUSH
42870: EMPTY
42871: LIST
42872: LIST
42873: PPUSH
42874: LD_EXP 104
42878: PUSH
42879: LD_VAR 0 2
42883: ARRAY
42884: PUSH
42885: LD_INT 1
42887: ARRAY
42888: PPUSH
42889: LD_INT 3
42891: PUSH
42892: LD_INT 24
42894: PUSH
42895: LD_INT 1000
42897: PUSH
42898: EMPTY
42899: LIST
42900: LIST
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PPUSH
42906: CALL_OW 72
42910: PUSH
42911: LD_VAR 0 6
42915: UNION
42916: PPUSH
42917: CALL 71510 0 3
42921: ST_TO_ADDR
// if not need_heal_2 then
42922: LD_VAR 0 7
42926: NOT
42927: IFFALSE 42960
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42929: LD_ADDR_EXP 104
42933: PUSH
42934: LD_EXP 104
42938: PPUSH
42939: LD_VAR 0 2
42943: PUSH
42944: LD_INT 2
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PPUSH
42951: EMPTY
42952: PPUSH
42953: CALL 71510 0 3
42957: ST_TO_ADDR
42958: GO 42992
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42960: LD_ADDR_EXP 104
42964: PUSH
42965: LD_EXP 104
42969: PPUSH
42970: LD_VAR 0 2
42974: PUSH
42975: LD_INT 2
42977: PUSH
42978: EMPTY
42979: LIST
42980: LIST
42981: PPUSH
42982: LD_VAR 0 7
42986: PPUSH
42987: CALL 71510 0 3
42991: ST_TO_ADDR
// if need_heal_2 then
42992: LD_VAR 0 7
42996: IFFALSE 43168
// for j in need_heal_2 do
42998: LD_ADDR_VAR 0 3
43002: PUSH
43003: LD_VAR 0 7
43007: PUSH
43008: FOR_IN
43009: IFFALSE 43166
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43011: LD_ADDR_VAR 0 5
43015: PUSH
43016: LD_EXP 101
43020: PUSH
43021: LD_VAR 0 2
43025: ARRAY
43026: PPUSH
43027: LD_INT 2
43029: PUSH
43030: LD_INT 30
43032: PUSH
43033: LD_INT 6
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 30
43042: PUSH
43043: LD_INT 7
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: PUSH
43050: LD_INT 30
43052: PUSH
43053: LD_INT 8
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: LD_INT 30
43062: PUSH
43063: LD_INT 0
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: LD_INT 30
43072: PUSH
43073: LD_INT 1
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: LD_INT 25
43082: PUSH
43083: LD_INT 4
43085: PUSH
43086: EMPTY
43087: LIST
43088: LIST
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: LIST
43094: LIST
43095: LIST
43096: LIST
43097: LIST
43098: PPUSH
43099: CALL_OW 72
43103: ST_TO_ADDR
// if tmp then
43104: LD_VAR 0 5
43108: IFFALSE 43164
// begin k := NearestUnitToUnit ( tmp , j ) ;
43110: LD_ADDR_VAR 0 4
43114: PUSH
43115: LD_VAR 0 5
43119: PPUSH
43120: LD_VAR 0 3
43124: PPUSH
43125: CALL_OW 74
43129: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43130: LD_VAR 0 3
43134: PPUSH
43135: LD_VAR 0 4
43139: PPUSH
43140: CALL_OW 296
43144: PUSH
43145: LD_INT 7
43147: GREATER
43148: IFFALSE 43164
// ComMoveUnit ( j , k ) ;
43150: LD_VAR 0 3
43154: PPUSH
43155: LD_VAR 0 4
43159: PPUSH
43160: CALL_OW 112
// end ; end ;
43164: GO 43008
43166: POP
43167: POP
// if not need_heal_1 and not need_heal_2 then
43168: LD_VAR 0 6
43172: NOT
43173: PUSH
43174: LD_VAR 0 7
43178: NOT
43179: AND
43180: IFFALSE 43184
// continue ;
43182: GO 42637
// end ;
43184: GO 42637
43186: POP
43187: POP
// RaiseSailEvent ( 102 ) ;
43188: LD_INT 102
43190: PPUSH
43191: CALL_OW 427
// end ;
43195: LD_VAR 0 1
43199: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43200: LD_INT 0
43202: PPUSH
43203: PPUSH
43204: PPUSH
43205: PPUSH
43206: PPUSH
43207: PPUSH
43208: PPUSH
43209: PPUSH
// if not mc_bases then
43210: LD_EXP 101
43214: NOT
43215: IFFALSE 43219
// exit ;
43217: GO 44059
// for i = 1 to mc_bases do
43219: LD_ADDR_VAR 0 2
43223: PUSH
43224: DOUBLE
43225: LD_INT 1
43227: DEC
43228: ST_TO_ADDR
43229: LD_EXP 101
43233: PUSH
43234: FOR_TO
43235: IFFALSE 44057
// begin if not mc_building_need_repair [ i ] then
43237: LD_EXP 102
43241: PUSH
43242: LD_VAR 0 2
43246: ARRAY
43247: NOT
43248: IFFALSE 43422
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43250: LD_ADDR_VAR 0 6
43254: PUSH
43255: LD_EXP 120
43259: PUSH
43260: LD_VAR 0 2
43264: ARRAY
43265: PPUSH
43266: LD_INT 3
43268: PUSH
43269: LD_INT 24
43271: PUSH
43272: LD_INT 1000
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: EMPTY
43280: LIST
43281: LIST
43282: PUSH
43283: LD_INT 2
43285: PUSH
43286: LD_INT 34
43288: PUSH
43289: LD_INT 13
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 34
43298: PUSH
43299: LD_INT 52
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: LIST
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PPUSH
43315: CALL_OW 72
43319: ST_TO_ADDR
// if cranes then
43320: LD_VAR 0 6
43324: IFFALSE 43386
// for j in cranes do
43326: LD_ADDR_VAR 0 3
43330: PUSH
43331: LD_VAR 0 6
43335: PUSH
43336: FOR_IN
43337: IFFALSE 43384
// if not IsInArea ( j , mc_parking [ i ] ) then
43339: LD_VAR 0 3
43343: PPUSH
43344: LD_EXP 125
43348: PUSH
43349: LD_VAR 0 2
43353: ARRAY
43354: PPUSH
43355: CALL_OW 308
43359: NOT
43360: IFFALSE 43382
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43362: LD_VAR 0 3
43366: PPUSH
43367: LD_EXP 125
43371: PUSH
43372: LD_VAR 0 2
43376: ARRAY
43377: PPUSH
43378: CALL_OW 113
43382: GO 43336
43384: POP
43385: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43386: LD_ADDR_EXP 103
43390: PUSH
43391: LD_EXP 103
43395: PPUSH
43396: LD_VAR 0 2
43400: PPUSH
43401: EMPTY
43402: PPUSH
43403: CALL_OW 1
43407: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43408: LD_VAR 0 2
43412: PPUSH
43413: LD_INT 101
43415: PPUSH
43416: CALL 38312 0 2
// continue ;
43420: GO 43234
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43422: LD_ADDR_EXP 107
43426: PUSH
43427: LD_EXP 107
43431: PPUSH
43432: LD_VAR 0 2
43436: PPUSH
43437: EMPTY
43438: PPUSH
43439: CALL_OW 1
43443: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43444: LD_VAR 0 2
43448: PPUSH
43449: LD_INT 103
43451: PPUSH
43452: CALL 38312 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43456: LD_ADDR_VAR 0 5
43460: PUSH
43461: LD_EXP 101
43465: PUSH
43466: LD_VAR 0 2
43470: ARRAY
43471: PUSH
43472: LD_EXP 130
43476: PUSH
43477: LD_VAR 0 2
43481: ARRAY
43482: UNION
43483: PPUSH
43484: LD_INT 2
43486: PUSH
43487: LD_INT 25
43489: PUSH
43490: LD_INT 2
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 25
43499: PUSH
43500: LD_INT 16
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: LIST
43511: PUSH
43512: EMPTY
43513: LIST
43514: PPUSH
43515: CALL_OW 72
43519: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43520: LD_ADDR_VAR 0 6
43524: PUSH
43525: LD_EXP 120
43529: PUSH
43530: LD_VAR 0 2
43534: ARRAY
43535: PPUSH
43536: LD_INT 2
43538: PUSH
43539: LD_INT 34
43541: PUSH
43542: LD_INT 13
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: LD_INT 34
43551: PUSH
43552: LD_INT 52
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: LIST
43563: PPUSH
43564: CALL_OW 72
43568: ST_TO_ADDR
// if cranes then
43569: LD_VAR 0 6
43573: IFFALSE 43709
// begin for j in cranes do
43575: LD_ADDR_VAR 0 3
43579: PUSH
43580: LD_VAR 0 6
43584: PUSH
43585: FOR_IN
43586: IFFALSE 43707
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43588: LD_VAR 0 3
43592: PPUSH
43593: CALL_OW 256
43597: PUSH
43598: LD_INT 500
43600: GREATEREQUAL
43601: PUSH
43602: LD_VAR 0 3
43606: PPUSH
43607: CALL_OW 314
43611: NOT
43612: AND
43613: IFFALSE 43647
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43615: LD_VAR 0 3
43619: PPUSH
43620: LD_EXP 102
43624: PUSH
43625: LD_VAR 0 2
43629: ARRAY
43630: PPUSH
43631: LD_VAR 0 3
43635: PPUSH
43636: CALL_OW 74
43640: PPUSH
43641: CALL_OW 130
43645: GO 43705
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43647: LD_VAR 0 3
43651: PPUSH
43652: CALL_OW 256
43656: PUSH
43657: LD_INT 500
43659: LESS
43660: PUSH
43661: LD_VAR 0 3
43665: PPUSH
43666: LD_EXP 125
43670: PUSH
43671: LD_VAR 0 2
43675: ARRAY
43676: PPUSH
43677: CALL_OW 308
43681: NOT
43682: AND
43683: IFFALSE 43705
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43685: LD_VAR 0 3
43689: PPUSH
43690: LD_EXP 125
43694: PUSH
43695: LD_VAR 0 2
43699: ARRAY
43700: PPUSH
43701: CALL_OW 113
43705: GO 43585
43707: POP
43708: POP
// end ; if not tmp then
43709: LD_VAR 0 5
43713: NOT
43714: IFFALSE 43718
// continue ;
43716: GO 43234
// for j in tmp do
43718: LD_ADDR_VAR 0 3
43722: PUSH
43723: LD_VAR 0 5
43727: PUSH
43728: FOR_IN
43729: IFFALSE 44053
// begin if mc_need_heal [ i ] then
43731: LD_EXP 104
43735: PUSH
43736: LD_VAR 0 2
43740: ARRAY
43741: IFFALSE 43789
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43743: LD_VAR 0 3
43747: PUSH
43748: LD_EXP 104
43752: PUSH
43753: LD_VAR 0 2
43757: ARRAY
43758: PUSH
43759: LD_INT 1
43761: ARRAY
43762: IN
43763: PUSH
43764: LD_VAR 0 3
43768: PUSH
43769: LD_EXP 104
43773: PUSH
43774: LD_VAR 0 2
43778: ARRAY
43779: PUSH
43780: LD_INT 2
43782: ARRAY
43783: IN
43784: OR
43785: IFFALSE 43789
// continue ;
43787: GO 43728
// if IsInUnit ( j ) then
43789: LD_VAR 0 3
43793: PPUSH
43794: CALL_OW 310
43798: IFFALSE 43809
// ComExitBuilding ( j ) ;
43800: LD_VAR 0 3
43804: PPUSH
43805: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43809: LD_VAR 0 3
43813: PUSH
43814: LD_EXP 103
43818: PUSH
43819: LD_VAR 0 2
43823: ARRAY
43824: IN
43825: NOT
43826: IFFALSE 43884
// begin SetTag ( j , 101 ) ;
43828: LD_VAR 0 3
43832: PPUSH
43833: LD_INT 101
43835: PPUSH
43836: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43840: LD_ADDR_EXP 103
43844: PUSH
43845: LD_EXP 103
43849: PPUSH
43850: LD_VAR 0 2
43854: PUSH
43855: LD_EXP 103
43859: PUSH
43860: LD_VAR 0 2
43864: ARRAY
43865: PUSH
43866: LD_INT 1
43868: PLUS
43869: PUSH
43870: EMPTY
43871: LIST
43872: LIST
43873: PPUSH
43874: LD_VAR 0 3
43878: PPUSH
43879: CALL 71510 0 3
43883: ST_TO_ADDR
// end ; wait ( 1 ) ;
43884: LD_INT 1
43886: PPUSH
43887: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
43891: LD_ADDR_VAR 0 7
43895: PUSH
43896: LD_EXP 102
43900: PUSH
43901: LD_VAR 0 2
43905: ARRAY
43906: ST_TO_ADDR
// if mc_scan [ i ] then
43907: LD_EXP 124
43911: PUSH
43912: LD_VAR 0 2
43916: ARRAY
43917: IFFALSE 43986
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
43919: LD_ADDR_VAR 0 7
43923: PUSH
43924: LD_EXP 102
43928: PUSH
43929: LD_VAR 0 2
43933: ARRAY
43934: PPUSH
43935: LD_INT 3
43937: PUSH
43938: LD_INT 2
43940: PUSH
43941: LD_INT 30
43943: PUSH
43944: LD_INT 32
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 30
43953: PUSH
43954: LD_INT 33
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 30
43963: PUSH
43964: LD_INT 31
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: LIST
43975: LIST
43976: PUSH
43977: EMPTY
43978: LIST
43979: LIST
43980: PPUSH
43981: CALL_OW 72
43985: ST_TO_ADDR
// if not to_repair_tmp then
43986: LD_VAR 0 7
43990: NOT
43991: IFFALSE 43995
// continue ;
43993: GO 43728
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
43995: LD_ADDR_VAR 0 8
43999: PUSH
44000: LD_VAR 0 7
44004: PPUSH
44005: LD_VAR 0 3
44009: PPUSH
44010: CALL_OW 74
44014: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44015: LD_VAR 0 8
44019: PPUSH
44020: LD_INT 14
44022: PPUSH
44023: CALL 74103 0 2
44027: PUSH
44028: LD_INT 4
44030: ARRAY
44031: PUSH
44032: LD_INT 5
44034: LESS
44035: IFFALSE 44051
// ComRepairBuilding ( j , to_repair ) ;
44037: LD_VAR 0 3
44041: PPUSH
44042: LD_VAR 0 8
44046: PPUSH
44047: CALL_OW 130
// end ;
44051: GO 43728
44053: POP
44054: POP
// end ;
44055: GO 43234
44057: POP
44058: POP
// end ;
44059: LD_VAR 0 1
44063: RET
// export function MC_Heal ; var i , j , tmp ; begin
44064: LD_INT 0
44066: PPUSH
44067: PPUSH
44068: PPUSH
44069: PPUSH
// if not mc_bases then
44070: LD_EXP 101
44074: NOT
44075: IFFALSE 44079
// exit ;
44077: GO 44481
// for i = 1 to mc_bases do
44079: LD_ADDR_VAR 0 2
44083: PUSH
44084: DOUBLE
44085: LD_INT 1
44087: DEC
44088: ST_TO_ADDR
44089: LD_EXP 101
44093: PUSH
44094: FOR_TO
44095: IFFALSE 44479
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44097: LD_EXP 104
44101: PUSH
44102: LD_VAR 0 2
44106: ARRAY
44107: PUSH
44108: LD_INT 1
44110: ARRAY
44111: NOT
44112: PUSH
44113: LD_EXP 104
44117: PUSH
44118: LD_VAR 0 2
44122: ARRAY
44123: PUSH
44124: LD_INT 2
44126: ARRAY
44127: NOT
44128: AND
44129: IFFALSE 44167
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44131: LD_ADDR_EXP 105
44135: PUSH
44136: LD_EXP 105
44140: PPUSH
44141: LD_VAR 0 2
44145: PPUSH
44146: EMPTY
44147: PPUSH
44148: CALL_OW 1
44152: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44153: LD_VAR 0 2
44157: PPUSH
44158: LD_INT 102
44160: PPUSH
44161: CALL 38312 0 2
// continue ;
44165: GO 44094
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44167: LD_ADDR_VAR 0 4
44171: PUSH
44172: LD_EXP 101
44176: PUSH
44177: LD_VAR 0 2
44181: ARRAY
44182: PPUSH
44183: LD_INT 25
44185: PUSH
44186: LD_INT 4
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PPUSH
44193: CALL_OW 72
44197: ST_TO_ADDR
// if not tmp then
44198: LD_VAR 0 4
44202: NOT
44203: IFFALSE 44207
// continue ;
44205: GO 44094
// if mc_taming [ i ] then
44207: LD_EXP 132
44211: PUSH
44212: LD_VAR 0 2
44216: ARRAY
44217: IFFALSE 44241
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44219: LD_ADDR_EXP 132
44223: PUSH
44224: LD_EXP 132
44228: PPUSH
44229: LD_VAR 0 2
44233: PPUSH
44234: EMPTY
44235: PPUSH
44236: CALL_OW 1
44240: ST_TO_ADDR
// for j in tmp do
44241: LD_ADDR_VAR 0 3
44245: PUSH
44246: LD_VAR 0 4
44250: PUSH
44251: FOR_IN
44252: IFFALSE 44475
// begin if IsInUnit ( j ) then
44254: LD_VAR 0 3
44258: PPUSH
44259: CALL_OW 310
44263: IFFALSE 44274
// ComExitBuilding ( j ) ;
44265: LD_VAR 0 3
44269: PPUSH
44270: CALL_OW 122
// if not j in mc_healers [ i ] then
44274: LD_VAR 0 3
44278: PUSH
44279: LD_EXP 105
44283: PUSH
44284: LD_VAR 0 2
44288: ARRAY
44289: IN
44290: NOT
44291: IFFALSE 44337
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44293: LD_ADDR_EXP 105
44297: PUSH
44298: LD_EXP 105
44302: PPUSH
44303: LD_VAR 0 2
44307: PUSH
44308: LD_EXP 105
44312: PUSH
44313: LD_VAR 0 2
44317: ARRAY
44318: PUSH
44319: LD_INT 1
44321: PLUS
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PPUSH
44327: LD_VAR 0 3
44331: PPUSH
44332: CALL 71510 0 3
44336: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44337: LD_VAR 0 3
44341: PPUSH
44342: CALL_OW 110
44346: PUSH
44347: LD_INT 102
44349: NONEQUAL
44350: IFFALSE 44364
// SetTag ( j , 102 ) ;
44352: LD_VAR 0 3
44356: PPUSH
44357: LD_INT 102
44359: PPUSH
44360: CALL_OW 109
// Wait ( 3 ) ;
44364: LD_INT 3
44366: PPUSH
44367: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44371: LD_EXP 104
44375: PUSH
44376: LD_VAR 0 2
44380: ARRAY
44381: PUSH
44382: LD_INT 1
44384: ARRAY
44385: IFFALSE 44417
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44387: LD_VAR 0 3
44391: PPUSH
44392: LD_EXP 104
44396: PUSH
44397: LD_VAR 0 2
44401: ARRAY
44402: PUSH
44403: LD_INT 1
44405: ARRAY
44406: PUSH
44407: LD_INT 1
44409: ARRAY
44410: PPUSH
44411: CALL_OW 128
44415: GO 44473
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44417: LD_VAR 0 3
44421: PPUSH
44422: CALL_OW 314
44426: NOT
44427: PUSH
44428: LD_EXP 104
44432: PUSH
44433: LD_VAR 0 2
44437: ARRAY
44438: PUSH
44439: LD_INT 2
44441: ARRAY
44442: AND
44443: IFFALSE 44473
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44445: LD_VAR 0 3
44449: PPUSH
44450: LD_EXP 104
44454: PUSH
44455: LD_VAR 0 2
44459: ARRAY
44460: PUSH
44461: LD_INT 2
44463: ARRAY
44464: PUSH
44465: LD_INT 1
44467: ARRAY
44468: PPUSH
44469: CALL_OW 128
// end ;
44473: GO 44251
44475: POP
44476: POP
// end ;
44477: GO 44094
44479: POP
44480: POP
// end ;
44481: LD_VAR 0 1
44485: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44486: LD_INT 0
44488: PPUSH
44489: PPUSH
44490: PPUSH
44491: PPUSH
44492: PPUSH
// if not mc_bases then
44493: LD_EXP 101
44497: NOT
44498: IFFALSE 44502
// exit ;
44500: GO 45645
// for i = 1 to mc_bases do
44502: LD_ADDR_VAR 0 2
44506: PUSH
44507: DOUBLE
44508: LD_INT 1
44510: DEC
44511: ST_TO_ADDR
44512: LD_EXP 101
44516: PUSH
44517: FOR_TO
44518: IFFALSE 45643
// begin if mc_scan [ i ] then
44520: LD_EXP 124
44524: PUSH
44525: LD_VAR 0 2
44529: ARRAY
44530: IFFALSE 44534
// continue ;
44532: GO 44517
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44534: LD_EXP 106
44538: PUSH
44539: LD_VAR 0 2
44543: ARRAY
44544: NOT
44545: PUSH
44546: LD_EXP 108
44550: PUSH
44551: LD_VAR 0 2
44555: ARRAY
44556: NOT
44557: AND
44558: PUSH
44559: LD_EXP 107
44563: PUSH
44564: LD_VAR 0 2
44568: ARRAY
44569: AND
44570: IFFALSE 44608
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44572: LD_ADDR_EXP 107
44576: PUSH
44577: LD_EXP 107
44581: PPUSH
44582: LD_VAR 0 2
44586: PPUSH
44587: EMPTY
44588: PPUSH
44589: CALL_OW 1
44593: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44594: LD_VAR 0 2
44598: PPUSH
44599: LD_INT 103
44601: PPUSH
44602: CALL 38312 0 2
// continue ;
44606: GO 44517
// end ; if mc_construct_list [ i ] then
44608: LD_EXP 108
44612: PUSH
44613: LD_VAR 0 2
44617: ARRAY
44618: IFFALSE 44838
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44620: LD_ADDR_VAR 0 4
44624: PUSH
44625: LD_EXP 101
44629: PUSH
44630: LD_VAR 0 2
44634: ARRAY
44635: PPUSH
44636: LD_INT 25
44638: PUSH
44639: LD_INT 2
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PPUSH
44646: CALL_OW 72
44650: PUSH
44651: LD_EXP 103
44655: PUSH
44656: LD_VAR 0 2
44660: ARRAY
44661: DIFF
44662: ST_TO_ADDR
// if not tmp then
44663: LD_VAR 0 4
44667: NOT
44668: IFFALSE 44672
// continue ;
44670: GO 44517
// for j in tmp do
44672: LD_ADDR_VAR 0 3
44676: PUSH
44677: LD_VAR 0 4
44681: PUSH
44682: FOR_IN
44683: IFFALSE 44834
// begin if not mc_builders [ i ] then
44685: LD_EXP 107
44689: PUSH
44690: LD_VAR 0 2
44694: ARRAY
44695: NOT
44696: IFFALSE 44754
// begin SetTag ( j , 103 ) ;
44698: LD_VAR 0 3
44702: PPUSH
44703: LD_INT 103
44705: PPUSH
44706: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44710: LD_ADDR_EXP 107
44714: PUSH
44715: LD_EXP 107
44719: PPUSH
44720: LD_VAR 0 2
44724: PUSH
44725: LD_EXP 107
44729: PUSH
44730: LD_VAR 0 2
44734: ARRAY
44735: PUSH
44736: LD_INT 1
44738: PLUS
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PPUSH
44744: LD_VAR 0 3
44748: PPUSH
44749: CALL 71510 0 3
44753: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44754: LD_VAR 0 3
44758: PPUSH
44759: CALL_OW 310
44763: IFFALSE 44774
// ComExitBuilding ( j ) ;
44765: LD_VAR 0 3
44769: PPUSH
44770: CALL_OW 122
// wait ( 3 ) ;
44774: LD_INT 3
44776: PPUSH
44777: CALL_OW 67
// if not mc_construct_list [ i ] then
44781: LD_EXP 108
44785: PUSH
44786: LD_VAR 0 2
44790: ARRAY
44791: NOT
44792: IFFALSE 44796
// break ;
44794: GO 44834
// if not HasTask ( j ) then
44796: LD_VAR 0 3
44800: PPUSH
44801: CALL_OW 314
44805: NOT
44806: IFFALSE 44832
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44808: LD_VAR 0 3
44812: PPUSH
44813: LD_EXP 108
44817: PUSH
44818: LD_VAR 0 2
44822: ARRAY
44823: PUSH
44824: LD_INT 1
44826: ARRAY
44827: PPUSH
44828: CALL 74361 0 2
// end ;
44832: GO 44682
44834: POP
44835: POP
// end else
44836: GO 45641
// if mc_build_list [ i ] then
44838: LD_EXP 106
44842: PUSH
44843: LD_VAR 0 2
44847: ARRAY
44848: IFFALSE 45641
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44850: LD_ADDR_VAR 0 5
44854: PUSH
44855: LD_EXP 101
44859: PUSH
44860: LD_VAR 0 2
44864: ARRAY
44865: PPUSH
44866: LD_INT 2
44868: PUSH
44869: LD_INT 30
44871: PUSH
44872: LD_INT 0
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 30
44881: PUSH
44882: LD_INT 1
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: LIST
44893: PPUSH
44894: CALL_OW 72
44898: ST_TO_ADDR
// if depot then
44899: LD_VAR 0 5
44903: IFFALSE 44921
// depot := depot [ 1 ] else
44905: LD_ADDR_VAR 0 5
44909: PUSH
44910: LD_VAR 0 5
44914: PUSH
44915: LD_INT 1
44917: ARRAY
44918: ST_TO_ADDR
44919: GO 44929
// depot := 0 ;
44921: LD_ADDR_VAR 0 5
44925: PUSH
44926: LD_INT 0
44928: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44929: LD_EXP 106
44933: PUSH
44934: LD_VAR 0 2
44938: ARRAY
44939: PUSH
44940: LD_INT 1
44942: ARRAY
44943: PUSH
44944: LD_INT 1
44946: ARRAY
44947: PPUSH
44948: CALL 74191 0 1
44952: PUSH
44953: LD_EXP 101
44957: PUSH
44958: LD_VAR 0 2
44962: ARRAY
44963: PPUSH
44964: LD_INT 2
44966: PUSH
44967: LD_INT 30
44969: PUSH
44970: LD_INT 2
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: PUSH
44977: LD_INT 30
44979: PUSH
44980: LD_INT 3
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: LIST
44991: PPUSH
44992: CALL_OW 72
44996: NOT
44997: AND
44998: IFFALSE 45103
// begin for j = 1 to mc_build_list [ i ] do
45000: LD_ADDR_VAR 0 3
45004: PUSH
45005: DOUBLE
45006: LD_INT 1
45008: DEC
45009: ST_TO_ADDR
45010: LD_EXP 106
45014: PUSH
45015: LD_VAR 0 2
45019: ARRAY
45020: PUSH
45021: FOR_TO
45022: IFFALSE 45101
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45024: LD_EXP 106
45028: PUSH
45029: LD_VAR 0 2
45033: ARRAY
45034: PUSH
45035: LD_VAR 0 3
45039: ARRAY
45040: PUSH
45041: LD_INT 1
45043: ARRAY
45044: PUSH
45045: LD_INT 2
45047: EQUAL
45048: IFFALSE 45099
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45050: LD_ADDR_EXP 106
45054: PUSH
45055: LD_EXP 106
45059: PPUSH
45060: LD_VAR 0 2
45064: PPUSH
45065: LD_EXP 106
45069: PUSH
45070: LD_VAR 0 2
45074: ARRAY
45075: PPUSH
45076: LD_VAR 0 3
45080: PPUSH
45081: LD_INT 1
45083: PPUSH
45084: LD_INT 0
45086: PPUSH
45087: CALL 70928 0 4
45091: PPUSH
45092: CALL_OW 1
45096: ST_TO_ADDR
// break ;
45097: GO 45101
// end ;
45099: GO 45021
45101: POP
45102: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45103: LD_EXP 106
45107: PUSH
45108: LD_VAR 0 2
45112: ARRAY
45113: PUSH
45114: LD_INT 1
45116: ARRAY
45117: PUSH
45118: LD_INT 1
45120: ARRAY
45121: PUSH
45122: LD_INT 0
45124: EQUAL
45125: PUSH
45126: LD_VAR 0 5
45130: PUSH
45131: LD_VAR 0 5
45135: PPUSH
45136: LD_EXP 106
45140: PUSH
45141: LD_VAR 0 2
45145: ARRAY
45146: PUSH
45147: LD_INT 1
45149: ARRAY
45150: PUSH
45151: LD_INT 1
45153: ARRAY
45154: PPUSH
45155: LD_EXP 106
45159: PUSH
45160: LD_VAR 0 2
45164: ARRAY
45165: PUSH
45166: LD_INT 1
45168: ARRAY
45169: PUSH
45170: LD_INT 2
45172: ARRAY
45173: PPUSH
45174: LD_EXP 106
45178: PUSH
45179: LD_VAR 0 2
45183: ARRAY
45184: PUSH
45185: LD_INT 1
45187: ARRAY
45188: PUSH
45189: LD_INT 3
45191: ARRAY
45192: PPUSH
45193: LD_EXP 106
45197: PUSH
45198: LD_VAR 0 2
45202: ARRAY
45203: PUSH
45204: LD_INT 1
45206: ARRAY
45207: PUSH
45208: LD_INT 4
45210: ARRAY
45211: PPUSH
45212: CALL 78925 0 5
45216: AND
45217: OR
45218: IFFALSE 45499
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45220: LD_ADDR_VAR 0 4
45224: PUSH
45225: LD_EXP 101
45229: PUSH
45230: LD_VAR 0 2
45234: ARRAY
45235: PPUSH
45236: LD_INT 25
45238: PUSH
45239: LD_INT 2
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PPUSH
45246: CALL_OW 72
45250: PUSH
45251: LD_EXP 103
45255: PUSH
45256: LD_VAR 0 2
45260: ARRAY
45261: DIFF
45262: ST_TO_ADDR
// if not tmp then
45263: LD_VAR 0 4
45267: NOT
45268: IFFALSE 45272
// continue ;
45270: GO 44517
// for j in tmp do
45272: LD_ADDR_VAR 0 3
45276: PUSH
45277: LD_VAR 0 4
45281: PUSH
45282: FOR_IN
45283: IFFALSE 45495
// begin if not mc_builders [ i ] then
45285: LD_EXP 107
45289: PUSH
45290: LD_VAR 0 2
45294: ARRAY
45295: NOT
45296: IFFALSE 45354
// begin SetTag ( j , 103 ) ;
45298: LD_VAR 0 3
45302: PPUSH
45303: LD_INT 103
45305: PPUSH
45306: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45310: LD_ADDR_EXP 107
45314: PUSH
45315: LD_EXP 107
45319: PPUSH
45320: LD_VAR 0 2
45324: PUSH
45325: LD_EXP 107
45329: PUSH
45330: LD_VAR 0 2
45334: ARRAY
45335: PUSH
45336: LD_INT 1
45338: PLUS
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PPUSH
45344: LD_VAR 0 3
45348: PPUSH
45349: CALL 71510 0 3
45353: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45354: LD_VAR 0 3
45358: PPUSH
45359: CALL_OW 310
45363: IFFALSE 45374
// ComExitBuilding ( j ) ;
45365: LD_VAR 0 3
45369: PPUSH
45370: CALL_OW 122
// wait ( 3 ) ;
45374: LD_INT 3
45376: PPUSH
45377: CALL_OW 67
// if not mc_build_list [ i ] then
45381: LD_EXP 106
45385: PUSH
45386: LD_VAR 0 2
45390: ARRAY
45391: NOT
45392: IFFALSE 45396
// break ;
45394: GO 45495
// if not HasTask ( j ) then
45396: LD_VAR 0 3
45400: PPUSH
45401: CALL_OW 314
45405: NOT
45406: IFFALSE 45493
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45408: LD_VAR 0 3
45412: PPUSH
45413: LD_EXP 106
45417: PUSH
45418: LD_VAR 0 2
45422: ARRAY
45423: PUSH
45424: LD_INT 1
45426: ARRAY
45427: PUSH
45428: LD_INT 1
45430: ARRAY
45431: PPUSH
45432: LD_EXP 106
45436: PUSH
45437: LD_VAR 0 2
45441: ARRAY
45442: PUSH
45443: LD_INT 1
45445: ARRAY
45446: PUSH
45447: LD_INT 2
45449: ARRAY
45450: PPUSH
45451: LD_EXP 106
45455: PUSH
45456: LD_VAR 0 2
45460: ARRAY
45461: PUSH
45462: LD_INT 1
45464: ARRAY
45465: PUSH
45466: LD_INT 3
45468: ARRAY
45469: PPUSH
45470: LD_EXP 106
45474: PUSH
45475: LD_VAR 0 2
45479: ARRAY
45480: PUSH
45481: LD_INT 1
45483: ARRAY
45484: PUSH
45485: LD_INT 4
45487: ARRAY
45488: PPUSH
45489: CALL_OW 145
// end ;
45493: GO 45282
45495: POP
45496: POP
// end else
45497: GO 45641
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45499: LD_EXP 101
45503: PUSH
45504: LD_VAR 0 2
45508: ARRAY
45509: PPUSH
45510: LD_EXP 106
45514: PUSH
45515: LD_VAR 0 2
45519: ARRAY
45520: PUSH
45521: LD_INT 1
45523: ARRAY
45524: PUSH
45525: LD_INT 1
45527: ARRAY
45528: PPUSH
45529: LD_EXP 106
45533: PUSH
45534: LD_VAR 0 2
45538: ARRAY
45539: PUSH
45540: LD_INT 1
45542: ARRAY
45543: PUSH
45544: LD_INT 2
45546: ARRAY
45547: PPUSH
45548: LD_EXP 106
45552: PUSH
45553: LD_VAR 0 2
45557: ARRAY
45558: PUSH
45559: LD_INT 1
45561: ARRAY
45562: PUSH
45563: LD_INT 3
45565: ARRAY
45566: PPUSH
45567: LD_EXP 106
45571: PUSH
45572: LD_VAR 0 2
45576: ARRAY
45577: PUSH
45578: LD_INT 1
45580: ARRAY
45581: PUSH
45582: LD_INT 4
45584: ARRAY
45585: PPUSH
45586: CALL 78261 0 5
45590: NOT
45591: IFFALSE 45641
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45593: LD_ADDR_EXP 106
45597: PUSH
45598: LD_EXP 106
45602: PPUSH
45603: LD_VAR 0 2
45607: PPUSH
45608: LD_EXP 106
45612: PUSH
45613: LD_VAR 0 2
45617: ARRAY
45618: PPUSH
45619: LD_INT 1
45621: PPUSH
45622: LD_INT 1
45624: NEG
45625: PPUSH
45626: LD_INT 0
45628: PPUSH
45629: CALL 70928 0 4
45633: PPUSH
45634: CALL_OW 1
45638: ST_TO_ADDR
// continue ;
45639: GO 44517
// end ; end ; end ;
45641: GO 44517
45643: POP
45644: POP
// end ;
45645: LD_VAR 0 1
45649: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45650: LD_INT 0
45652: PPUSH
45653: PPUSH
45654: PPUSH
45655: PPUSH
45656: PPUSH
45657: PPUSH
// if not mc_bases then
45658: LD_EXP 101
45662: NOT
45663: IFFALSE 45667
// exit ;
45665: GO 46094
// for i = 1 to mc_bases do
45667: LD_ADDR_VAR 0 2
45671: PUSH
45672: DOUBLE
45673: LD_INT 1
45675: DEC
45676: ST_TO_ADDR
45677: LD_EXP 101
45681: PUSH
45682: FOR_TO
45683: IFFALSE 46092
// begin tmp := mc_build_upgrade [ i ] ;
45685: LD_ADDR_VAR 0 4
45689: PUSH
45690: LD_EXP 133
45694: PUSH
45695: LD_VAR 0 2
45699: ARRAY
45700: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45701: LD_ADDR_VAR 0 6
45705: PUSH
45706: LD_EXP 134
45710: PUSH
45711: LD_VAR 0 2
45715: ARRAY
45716: PPUSH
45717: LD_INT 2
45719: PUSH
45720: LD_INT 30
45722: PUSH
45723: LD_INT 6
45725: PUSH
45726: EMPTY
45727: LIST
45728: LIST
45729: PUSH
45730: LD_INT 30
45732: PUSH
45733: LD_INT 7
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: LIST
45744: PPUSH
45745: CALL_OW 72
45749: ST_TO_ADDR
// if not tmp and not lab then
45750: LD_VAR 0 4
45754: NOT
45755: PUSH
45756: LD_VAR 0 6
45760: NOT
45761: AND
45762: IFFALSE 45766
// continue ;
45764: GO 45682
// if tmp then
45766: LD_VAR 0 4
45770: IFFALSE 45890
// for j in tmp do
45772: LD_ADDR_VAR 0 3
45776: PUSH
45777: LD_VAR 0 4
45781: PUSH
45782: FOR_IN
45783: IFFALSE 45888
// begin if UpgradeCost ( j ) then
45785: LD_VAR 0 3
45789: PPUSH
45790: CALL 77921 0 1
45794: IFFALSE 45886
// begin ComUpgrade ( j ) ;
45796: LD_VAR 0 3
45800: PPUSH
45801: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45805: LD_ADDR_EXP 133
45809: PUSH
45810: LD_EXP 133
45814: PPUSH
45815: LD_VAR 0 2
45819: PPUSH
45820: LD_EXP 133
45824: PUSH
45825: LD_VAR 0 2
45829: ARRAY
45830: PUSH
45831: LD_VAR 0 3
45835: DIFF
45836: PPUSH
45837: CALL_OW 1
45841: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45842: LD_ADDR_EXP 108
45846: PUSH
45847: LD_EXP 108
45851: PPUSH
45852: LD_VAR 0 2
45856: PUSH
45857: LD_EXP 108
45861: PUSH
45862: LD_VAR 0 2
45866: ARRAY
45867: PUSH
45868: LD_INT 1
45870: PLUS
45871: PUSH
45872: EMPTY
45873: LIST
45874: LIST
45875: PPUSH
45876: LD_VAR 0 3
45880: PPUSH
45881: CALL 71510 0 3
45885: ST_TO_ADDR
// end ; end ;
45886: GO 45782
45888: POP
45889: POP
// if not lab or not mc_lab_upgrade [ i ] then
45890: LD_VAR 0 6
45894: NOT
45895: PUSH
45896: LD_EXP 135
45900: PUSH
45901: LD_VAR 0 2
45905: ARRAY
45906: NOT
45907: OR
45908: IFFALSE 45912
// continue ;
45910: GO 45682
// for j in lab do
45912: LD_ADDR_VAR 0 3
45916: PUSH
45917: LD_VAR 0 6
45921: PUSH
45922: FOR_IN
45923: IFFALSE 46088
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45925: LD_VAR 0 3
45929: PPUSH
45930: CALL_OW 266
45934: PUSH
45935: LD_INT 6
45937: PUSH
45938: LD_INT 7
45940: PUSH
45941: EMPTY
45942: LIST
45943: LIST
45944: IN
45945: PUSH
45946: LD_VAR 0 3
45950: PPUSH
45951: CALL_OW 461
45955: PUSH
45956: LD_INT 1
45958: NONEQUAL
45959: AND
45960: IFFALSE 46086
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45962: LD_VAR 0 3
45966: PPUSH
45967: LD_EXP 135
45971: PUSH
45972: LD_VAR 0 2
45976: ARRAY
45977: PUSH
45978: LD_INT 1
45980: ARRAY
45981: PPUSH
45982: CALL 78126 0 2
45986: IFFALSE 46086
// begin ComCancel ( j ) ;
45988: LD_VAR 0 3
45992: PPUSH
45993: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45997: LD_VAR 0 3
46001: PPUSH
46002: LD_EXP 135
46006: PUSH
46007: LD_VAR 0 2
46011: ARRAY
46012: PUSH
46013: LD_INT 1
46015: ARRAY
46016: PPUSH
46017: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46021: LD_VAR 0 3
46025: PUSH
46026: LD_EXP 108
46030: PUSH
46031: LD_VAR 0 2
46035: ARRAY
46036: IN
46037: NOT
46038: IFFALSE 46084
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46040: LD_ADDR_EXP 108
46044: PUSH
46045: LD_EXP 108
46049: PPUSH
46050: LD_VAR 0 2
46054: PUSH
46055: LD_EXP 108
46059: PUSH
46060: LD_VAR 0 2
46064: ARRAY
46065: PUSH
46066: LD_INT 1
46068: PLUS
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PPUSH
46074: LD_VAR 0 3
46078: PPUSH
46079: CALL 71510 0 3
46083: ST_TO_ADDR
// break ;
46084: GO 46088
// end ; end ; end ;
46086: GO 45922
46088: POP
46089: POP
// end ;
46090: GO 45682
46092: POP
46093: POP
// end ;
46094: LD_VAR 0 1
46098: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46099: LD_INT 0
46101: PPUSH
46102: PPUSH
46103: PPUSH
46104: PPUSH
46105: PPUSH
46106: PPUSH
46107: PPUSH
46108: PPUSH
46109: PPUSH
// if not mc_bases then
46110: LD_EXP 101
46114: NOT
46115: IFFALSE 46119
// exit ;
46117: GO 46524
// for i = 1 to mc_bases do
46119: LD_ADDR_VAR 0 2
46123: PUSH
46124: DOUBLE
46125: LD_INT 1
46127: DEC
46128: ST_TO_ADDR
46129: LD_EXP 101
46133: PUSH
46134: FOR_TO
46135: IFFALSE 46522
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46137: LD_EXP 109
46141: PUSH
46142: LD_VAR 0 2
46146: ARRAY
46147: NOT
46148: PUSH
46149: LD_EXP 101
46153: PUSH
46154: LD_VAR 0 2
46158: ARRAY
46159: PPUSH
46160: LD_INT 30
46162: PUSH
46163: LD_INT 3
46165: PUSH
46166: EMPTY
46167: LIST
46168: LIST
46169: PPUSH
46170: CALL_OW 72
46174: NOT
46175: OR
46176: IFFALSE 46180
// continue ;
46178: GO 46134
// busy := false ;
46180: LD_ADDR_VAR 0 8
46184: PUSH
46185: LD_INT 0
46187: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46188: LD_ADDR_VAR 0 4
46192: PUSH
46193: LD_EXP 101
46197: PUSH
46198: LD_VAR 0 2
46202: ARRAY
46203: PPUSH
46204: LD_INT 30
46206: PUSH
46207: LD_INT 3
46209: PUSH
46210: EMPTY
46211: LIST
46212: LIST
46213: PPUSH
46214: CALL_OW 72
46218: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46219: LD_ADDR_VAR 0 6
46223: PUSH
46224: LD_EXP 109
46228: PUSH
46229: LD_VAR 0 2
46233: ARRAY
46234: PPUSH
46235: LD_INT 2
46237: PUSH
46238: LD_INT 30
46240: PUSH
46241: LD_INT 32
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: PUSH
46248: LD_INT 30
46250: PUSH
46251: LD_INT 33
46253: PUSH
46254: EMPTY
46255: LIST
46256: LIST
46257: PUSH
46258: EMPTY
46259: LIST
46260: LIST
46261: LIST
46262: PPUSH
46263: CALL_OW 72
46267: ST_TO_ADDR
// if not t then
46268: LD_VAR 0 6
46272: NOT
46273: IFFALSE 46277
// continue ;
46275: GO 46134
// for j in tmp do
46277: LD_ADDR_VAR 0 3
46281: PUSH
46282: LD_VAR 0 4
46286: PUSH
46287: FOR_IN
46288: IFFALSE 46318
// if not BuildingStatus ( j ) = bs_idle then
46290: LD_VAR 0 3
46294: PPUSH
46295: CALL_OW 461
46299: PUSH
46300: LD_INT 2
46302: EQUAL
46303: NOT
46304: IFFALSE 46316
// begin busy := true ;
46306: LD_ADDR_VAR 0 8
46310: PUSH
46311: LD_INT 1
46313: ST_TO_ADDR
// break ;
46314: GO 46318
// end ;
46316: GO 46287
46318: POP
46319: POP
// if busy then
46320: LD_VAR 0 8
46324: IFFALSE 46328
// continue ;
46326: GO 46134
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46328: LD_ADDR_VAR 0 7
46332: PUSH
46333: LD_VAR 0 6
46337: PPUSH
46338: LD_INT 35
46340: PUSH
46341: LD_INT 0
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PPUSH
46348: CALL_OW 72
46352: ST_TO_ADDR
// if tw then
46353: LD_VAR 0 7
46357: IFFALSE 46434
// begin tw := tw [ 1 ] ;
46359: LD_ADDR_VAR 0 7
46363: PUSH
46364: LD_VAR 0 7
46368: PUSH
46369: LD_INT 1
46371: ARRAY
46372: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46373: LD_ADDR_VAR 0 9
46377: PUSH
46378: LD_VAR 0 7
46382: PPUSH
46383: LD_EXP 126
46387: PUSH
46388: LD_VAR 0 2
46392: ARRAY
46393: PPUSH
46394: CALL 76480 0 2
46398: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46399: LD_EXP 140
46403: PUSH
46404: LD_VAR 0 2
46408: ARRAY
46409: IFFALSE 46432
// if not weapon in mc_allowed_tower_weapons [ i ] then
46411: LD_VAR 0 9
46415: PUSH
46416: LD_EXP 140
46420: PUSH
46421: LD_VAR 0 2
46425: ARRAY
46426: IN
46427: NOT
46428: IFFALSE 46432
// continue ;
46430: GO 46134
// end else
46432: GO 46497
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46434: LD_ADDR_VAR 0 5
46438: PUSH
46439: LD_EXP 109
46443: PUSH
46444: LD_VAR 0 2
46448: ARRAY
46449: PPUSH
46450: LD_VAR 0 4
46454: PPUSH
46455: CALL 106684 0 2
46459: ST_TO_ADDR
// if not tmp2 then
46460: LD_VAR 0 5
46464: NOT
46465: IFFALSE 46469
// continue ;
46467: GO 46134
// tw := tmp2 [ 1 ] ;
46469: LD_ADDR_VAR 0 7
46473: PUSH
46474: LD_VAR 0 5
46478: PUSH
46479: LD_INT 1
46481: ARRAY
46482: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46483: LD_ADDR_VAR 0 9
46487: PUSH
46488: LD_VAR 0 5
46492: PUSH
46493: LD_INT 2
46495: ARRAY
46496: ST_TO_ADDR
// end ; if not weapon then
46497: LD_VAR 0 9
46501: NOT
46502: IFFALSE 46506
// continue ;
46504: GO 46134
// ComPlaceWeapon ( tw , weapon ) ;
46506: LD_VAR 0 7
46510: PPUSH
46511: LD_VAR 0 9
46515: PPUSH
46516: CALL_OW 148
// end ;
46520: GO 46134
46522: POP
46523: POP
// end ;
46524: LD_VAR 0 1
46528: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46529: LD_INT 0
46531: PPUSH
46532: PPUSH
46533: PPUSH
46534: PPUSH
46535: PPUSH
46536: PPUSH
// if not mc_bases then
46537: LD_EXP 101
46541: NOT
46542: IFFALSE 46546
// exit ;
46544: GO 47322
// for i = 1 to mc_bases do
46546: LD_ADDR_VAR 0 2
46550: PUSH
46551: DOUBLE
46552: LD_INT 1
46554: DEC
46555: ST_TO_ADDR
46556: LD_EXP 101
46560: PUSH
46561: FOR_TO
46562: IFFALSE 47320
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
46564: LD_EXP 114
46568: PUSH
46569: LD_VAR 0 2
46573: ARRAY
46574: NOT
46575: PUSH
46576: LD_EXP 114
46580: PUSH
46581: LD_VAR 0 2
46585: ARRAY
46586: PUSH
46587: LD_EXP 115
46591: PUSH
46592: LD_VAR 0 2
46596: ARRAY
46597: EQUAL
46598: OR
46599: PUSH
46600: LD_EXP 124
46604: PUSH
46605: LD_VAR 0 2
46609: ARRAY
46610: OR
46611: IFFALSE 46615
// continue ;
46613: GO 46561
// if mc_miners [ i ] then
46615: LD_EXP 115
46619: PUSH
46620: LD_VAR 0 2
46624: ARRAY
46625: IFFALSE 47007
// begin for j = mc_miners [ i ] downto 1 do
46627: LD_ADDR_VAR 0 3
46631: PUSH
46632: DOUBLE
46633: LD_EXP 115
46637: PUSH
46638: LD_VAR 0 2
46642: ARRAY
46643: INC
46644: ST_TO_ADDR
46645: LD_INT 1
46647: PUSH
46648: FOR_DOWNTO
46649: IFFALSE 47005
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46651: LD_EXP 115
46655: PUSH
46656: LD_VAR 0 2
46660: ARRAY
46661: PUSH
46662: LD_VAR 0 3
46666: ARRAY
46667: PPUSH
46668: CALL_OW 301
46672: PUSH
46673: LD_EXP 115
46677: PUSH
46678: LD_VAR 0 2
46682: ARRAY
46683: PUSH
46684: LD_VAR 0 3
46688: ARRAY
46689: PPUSH
46690: CALL_OW 257
46694: PUSH
46695: LD_INT 1
46697: NONEQUAL
46698: OR
46699: IFFALSE 46762
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46701: LD_ADDR_VAR 0 5
46705: PUSH
46706: LD_EXP 115
46710: PUSH
46711: LD_VAR 0 2
46715: ARRAY
46716: PUSH
46717: LD_EXP 115
46721: PUSH
46722: LD_VAR 0 2
46726: ARRAY
46727: PUSH
46728: LD_VAR 0 3
46732: ARRAY
46733: DIFF
46734: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46735: LD_ADDR_EXP 115
46739: PUSH
46740: LD_EXP 115
46744: PPUSH
46745: LD_VAR 0 2
46749: PPUSH
46750: LD_VAR 0 5
46754: PPUSH
46755: CALL_OW 1
46759: ST_TO_ADDR
// continue ;
46760: GO 46648
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
46762: LD_EXP 115
46766: PUSH
46767: LD_VAR 0 2
46771: ARRAY
46772: PUSH
46773: LD_VAR 0 3
46777: ARRAY
46778: PPUSH
46779: CALL_OW 257
46783: PUSH
46784: LD_INT 1
46786: EQUAL
46787: PUSH
46788: LD_EXP 115
46792: PUSH
46793: LD_VAR 0 2
46797: ARRAY
46798: PUSH
46799: LD_VAR 0 3
46803: ARRAY
46804: PPUSH
46805: CALL_OW 459
46809: NOT
46810: AND
46811: PUSH
46812: LD_EXP 115
46816: PUSH
46817: LD_VAR 0 2
46821: ARRAY
46822: PUSH
46823: LD_VAR 0 3
46827: ARRAY
46828: PPUSH
46829: CALL_OW 314
46833: NOT
46834: AND
46835: IFFALSE 47003
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46837: LD_EXP 115
46841: PUSH
46842: LD_VAR 0 2
46846: ARRAY
46847: PUSH
46848: LD_VAR 0 3
46852: ARRAY
46853: PPUSH
46854: CALL_OW 310
46858: IFFALSE 46881
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46860: LD_EXP 115
46864: PUSH
46865: LD_VAR 0 2
46869: ARRAY
46870: PUSH
46871: LD_VAR 0 3
46875: ARRAY
46876: PPUSH
46877: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46881: LD_EXP 115
46885: PUSH
46886: LD_VAR 0 2
46890: ARRAY
46891: PUSH
46892: LD_VAR 0 3
46896: ARRAY
46897: PPUSH
46898: CALL_OW 314
46902: NOT
46903: IFFALSE 47003
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
46905: LD_EXP 115
46909: PUSH
46910: LD_VAR 0 2
46914: ARRAY
46915: PUSH
46916: LD_VAR 0 3
46920: ARRAY
46921: PPUSH
46922: LD_EXP 114
46926: PUSH
46927: LD_VAR 0 2
46931: ARRAY
46932: PUSH
46933: LD_VAR 0 3
46937: PUSH
46938: LD_EXP 114
46942: PUSH
46943: LD_VAR 0 2
46947: ARRAY
46948: MOD
46949: PUSH
46950: LD_INT 1
46952: PLUS
46953: ARRAY
46954: PUSH
46955: LD_INT 1
46957: ARRAY
46958: PPUSH
46959: LD_EXP 114
46963: PUSH
46964: LD_VAR 0 2
46968: ARRAY
46969: PUSH
46970: LD_VAR 0 3
46974: PUSH
46975: LD_EXP 114
46979: PUSH
46980: LD_VAR 0 2
46984: ARRAY
46985: MOD
46986: PUSH
46987: LD_INT 1
46989: PLUS
46990: ARRAY
46991: PUSH
46992: LD_INT 2
46994: ARRAY
46995: PPUSH
46996: LD_INT 0
46998: PPUSH
46999: CALL_OW 193
// end ; end ;
47003: GO 46648
47005: POP
47006: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47007: LD_ADDR_VAR 0 5
47011: PUSH
47012: LD_EXP 101
47016: PUSH
47017: LD_VAR 0 2
47021: ARRAY
47022: PPUSH
47023: LD_INT 2
47025: PUSH
47026: LD_INT 30
47028: PUSH
47029: LD_INT 4
47031: PUSH
47032: EMPTY
47033: LIST
47034: LIST
47035: PUSH
47036: LD_INT 30
47038: PUSH
47039: LD_INT 5
47041: PUSH
47042: EMPTY
47043: LIST
47044: LIST
47045: PUSH
47046: LD_INT 30
47048: PUSH
47049: LD_INT 32
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: PPUSH
47062: CALL_OW 72
47066: ST_TO_ADDR
// if not tmp then
47067: LD_VAR 0 5
47071: NOT
47072: IFFALSE 47076
// continue ;
47074: GO 46561
// list := [ ] ;
47076: LD_ADDR_VAR 0 6
47080: PUSH
47081: EMPTY
47082: ST_TO_ADDR
// for j in tmp do
47083: LD_ADDR_VAR 0 3
47087: PUSH
47088: LD_VAR 0 5
47092: PUSH
47093: FOR_IN
47094: IFFALSE 47163
// begin for k in UnitsInside ( j ) do
47096: LD_ADDR_VAR 0 4
47100: PUSH
47101: LD_VAR 0 3
47105: PPUSH
47106: CALL_OW 313
47110: PUSH
47111: FOR_IN
47112: IFFALSE 47159
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47114: LD_VAR 0 4
47118: PPUSH
47119: CALL_OW 257
47123: PUSH
47124: LD_INT 1
47126: EQUAL
47127: PUSH
47128: LD_VAR 0 4
47132: PPUSH
47133: CALL_OW 459
47137: NOT
47138: AND
47139: IFFALSE 47157
// list := list ^ k ;
47141: LD_ADDR_VAR 0 6
47145: PUSH
47146: LD_VAR 0 6
47150: PUSH
47151: LD_VAR 0 4
47155: ADD
47156: ST_TO_ADDR
47157: GO 47111
47159: POP
47160: POP
// end ;
47161: GO 47093
47163: POP
47164: POP
// list := list diff mc_miners [ i ] ;
47165: LD_ADDR_VAR 0 6
47169: PUSH
47170: LD_VAR 0 6
47174: PUSH
47175: LD_EXP 115
47179: PUSH
47180: LD_VAR 0 2
47184: ARRAY
47185: DIFF
47186: ST_TO_ADDR
// if not list then
47187: LD_VAR 0 6
47191: NOT
47192: IFFALSE 47196
// continue ;
47194: GO 46561
// k := mc_mines [ i ] - mc_miners [ i ] ;
47196: LD_ADDR_VAR 0 4
47200: PUSH
47201: LD_EXP 114
47205: PUSH
47206: LD_VAR 0 2
47210: ARRAY
47211: PUSH
47212: LD_EXP 115
47216: PUSH
47217: LD_VAR 0 2
47221: ARRAY
47222: MINUS
47223: ST_TO_ADDR
// if k > list then
47224: LD_VAR 0 4
47228: PUSH
47229: LD_VAR 0 6
47233: GREATER
47234: IFFALSE 47246
// k := list ;
47236: LD_ADDR_VAR 0 4
47240: PUSH
47241: LD_VAR 0 6
47245: ST_TO_ADDR
// for j = 1 to k do
47246: LD_ADDR_VAR 0 3
47250: PUSH
47251: DOUBLE
47252: LD_INT 1
47254: DEC
47255: ST_TO_ADDR
47256: LD_VAR 0 4
47260: PUSH
47261: FOR_TO
47262: IFFALSE 47316
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47264: LD_ADDR_EXP 115
47268: PUSH
47269: LD_EXP 115
47273: PPUSH
47274: LD_VAR 0 2
47278: PUSH
47279: LD_EXP 115
47283: PUSH
47284: LD_VAR 0 2
47288: ARRAY
47289: PUSH
47290: LD_INT 1
47292: PLUS
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PPUSH
47298: LD_VAR 0 6
47302: PUSH
47303: LD_VAR 0 3
47307: ARRAY
47308: PPUSH
47309: CALL 71510 0 3
47313: ST_TO_ADDR
47314: GO 47261
47316: POP
47317: POP
// end ;
47318: GO 46561
47320: POP
47321: POP
// end ;
47322: LD_VAR 0 1
47326: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47327: LD_INT 0
47329: PPUSH
47330: PPUSH
47331: PPUSH
47332: PPUSH
47333: PPUSH
47334: PPUSH
47335: PPUSH
47336: PPUSH
47337: PPUSH
47338: PPUSH
// if not mc_bases then
47339: LD_EXP 101
47343: NOT
47344: IFFALSE 47348
// exit ;
47346: GO 49098
// for i = 1 to mc_bases do
47348: LD_ADDR_VAR 0 2
47352: PUSH
47353: DOUBLE
47354: LD_INT 1
47356: DEC
47357: ST_TO_ADDR
47358: LD_EXP 101
47362: PUSH
47363: FOR_TO
47364: IFFALSE 49096
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47366: LD_EXP 101
47370: PUSH
47371: LD_VAR 0 2
47375: ARRAY
47376: NOT
47377: PUSH
47378: LD_EXP 108
47382: PUSH
47383: LD_VAR 0 2
47387: ARRAY
47388: OR
47389: IFFALSE 47393
// continue ;
47391: GO 47363
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47393: LD_EXP 117
47397: PUSH
47398: LD_VAR 0 2
47402: ARRAY
47403: NOT
47404: PUSH
47405: LD_EXP 118
47409: PUSH
47410: LD_VAR 0 2
47414: ARRAY
47415: AND
47416: IFFALSE 47454
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47418: LD_ADDR_EXP 118
47422: PUSH
47423: LD_EXP 118
47427: PPUSH
47428: LD_VAR 0 2
47432: PPUSH
47433: EMPTY
47434: PPUSH
47435: CALL_OW 1
47439: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47440: LD_VAR 0 2
47444: PPUSH
47445: LD_INT 107
47447: PPUSH
47448: CALL 38312 0 2
// continue ;
47452: GO 47363
// end ; target := [ ] ;
47454: LD_ADDR_VAR 0 6
47458: PUSH
47459: EMPTY
47460: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47461: LD_ADDR_VAR 0 3
47465: PUSH
47466: DOUBLE
47467: LD_EXP 117
47471: PUSH
47472: LD_VAR 0 2
47476: ARRAY
47477: INC
47478: ST_TO_ADDR
47479: LD_INT 1
47481: PUSH
47482: FOR_DOWNTO
47483: IFFALSE 47743
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47485: LD_EXP 117
47489: PUSH
47490: LD_VAR 0 2
47494: ARRAY
47495: PUSH
47496: LD_VAR 0 3
47500: ARRAY
47501: PUSH
47502: LD_INT 2
47504: ARRAY
47505: PPUSH
47506: LD_EXP 117
47510: PUSH
47511: LD_VAR 0 2
47515: ARRAY
47516: PUSH
47517: LD_VAR 0 3
47521: ARRAY
47522: PUSH
47523: LD_INT 3
47525: ARRAY
47526: PPUSH
47527: CALL_OW 488
47531: PUSH
47532: LD_EXP 117
47536: PUSH
47537: LD_VAR 0 2
47541: ARRAY
47542: PUSH
47543: LD_VAR 0 3
47547: ARRAY
47548: PUSH
47549: LD_INT 2
47551: ARRAY
47552: PPUSH
47553: LD_EXP 117
47557: PUSH
47558: LD_VAR 0 2
47562: ARRAY
47563: PUSH
47564: LD_VAR 0 3
47568: ARRAY
47569: PUSH
47570: LD_INT 3
47572: ARRAY
47573: PPUSH
47574: CALL_OW 284
47578: PUSH
47579: LD_INT 0
47581: EQUAL
47582: AND
47583: IFFALSE 47638
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47585: LD_ADDR_VAR 0 5
47589: PUSH
47590: LD_EXP 117
47594: PUSH
47595: LD_VAR 0 2
47599: ARRAY
47600: PPUSH
47601: LD_VAR 0 3
47605: PPUSH
47606: CALL_OW 3
47610: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47611: LD_ADDR_EXP 117
47615: PUSH
47616: LD_EXP 117
47620: PPUSH
47621: LD_VAR 0 2
47625: PPUSH
47626: LD_VAR 0 5
47630: PPUSH
47631: CALL_OW 1
47635: ST_TO_ADDR
// continue ;
47636: GO 47482
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47638: LD_EXP 101
47642: PUSH
47643: LD_VAR 0 2
47647: ARRAY
47648: PUSH
47649: LD_INT 1
47651: ARRAY
47652: PPUSH
47653: CALL_OW 255
47657: PPUSH
47658: LD_EXP 117
47662: PUSH
47663: LD_VAR 0 2
47667: ARRAY
47668: PUSH
47669: LD_VAR 0 3
47673: ARRAY
47674: PUSH
47675: LD_INT 2
47677: ARRAY
47678: PPUSH
47679: LD_EXP 117
47683: PUSH
47684: LD_VAR 0 2
47688: ARRAY
47689: PUSH
47690: LD_VAR 0 3
47694: ARRAY
47695: PUSH
47696: LD_INT 3
47698: ARRAY
47699: PPUSH
47700: LD_INT 30
47702: PPUSH
47703: CALL 72406 0 4
47707: PUSH
47708: LD_INT 4
47710: ARRAY
47711: PUSH
47712: LD_INT 0
47714: EQUAL
47715: IFFALSE 47741
// begin target := mc_crates [ i ] [ j ] ;
47717: LD_ADDR_VAR 0 6
47721: PUSH
47722: LD_EXP 117
47726: PUSH
47727: LD_VAR 0 2
47731: ARRAY
47732: PUSH
47733: LD_VAR 0 3
47737: ARRAY
47738: ST_TO_ADDR
// break ;
47739: GO 47743
// end ; end ;
47741: GO 47482
47743: POP
47744: POP
// if not target then
47745: LD_VAR 0 6
47749: NOT
47750: IFFALSE 47754
// continue ;
47752: GO 47363
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47754: LD_ADDR_VAR 0 7
47758: PUSH
47759: LD_EXP 120
47763: PUSH
47764: LD_VAR 0 2
47768: ARRAY
47769: PPUSH
47770: LD_INT 2
47772: PUSH
47773: LD_INT 3
47775: PUSH
47776: LD_INT 58
47778: PUSH
47779: EMPTY
47780: LIST
47781: PUSH
47782: EMPTY
47783: LIST
47784: LIST
47785: PUSH
47786: LD_INT 61
47788: PUSH
47789: EMPTY
47790: LIST
47791: PUSH
47792: LD_INT 33
47794: PUSH
47795: LD_INT 5
47797: PUSH
47798: EMPTY
47799: LIST
47800: LIST
47801: PUSH
47802: LD_INT 33
47804: PUSH
47805: LD_INT 3
47807: PUSH
47808: EMPTY
47809: LIST
47810: LIST
47811: PUSH
47812: EMPTY
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: PUSH
47819: LD_INT 2
47821: PUSH
47822: LD_INT 34
47824: PUSH
47825: LD_INT 32
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: LD_INT 34
47834: PUSH
47835: LD_INT 51
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: PUSH
47842: LD_INT 34
47844: PUSH
47845: LD_INT 12
47847: PUSH
47848: EMPTY
47849: LIST
47850: LIST
47851: PUSH
47852: EMPTY
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: PUSH
47858: EMPTY
47859: LIST
47860: LIST
47861: PPUSH
47862: CALL_OW 72
47866: ST_TO_ADDR
// if not cargo then
47867: LD_VAR 0 7
47871: NOT
47872: IFFALSE 48515
// begin if mc_crates_collector [ i ] < 5 then
47874: LD_EXP 118
47878: PUSH
47879: LD_VAR 0 2
47883: ARRAY
47884: PUSH
47885: LD_INT 5
47887: LESS
47888: IFFALSE 48254
// begin if mc_ape [ i ] then
47890: LD_EXP 130
47894: PUSH
47895: LD_VAR 0 2
47899: ARRAY
47900: IFFALSE 47947
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47902: LD_ADDR_VAR 0 5
47906: PUSH
47907: LD_EXP 130
47911: PUSH
47912: LD_VAR 0 2
47916: ARRAY
47917: PPUSH
47918: LD_INT 25
47920: PUSH
47921: LD_INT 16
47923: PUSH
47924: EMPTY
47925: LIST
47926: LIST
47927: PUSH
47928: LD_INT 24
47930: PUSH
47931: LD_INT 750
47933: PUSH
47934: EMPTY
47935: LIST
47936: LIST
47937: PUSH
47938: EMPTY
47939: LIST
47940: LIST
47941: PPUSH
47942: CALL_OW 72
47946: ST_TO_ADDR
// if not tmp then
47947: LD_VAR 0 5
47951: NOT
47952: IFFALSE 47999
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47954: LD_ADDR_VAR 0 5
47958: PUSH
47959: LD_EXP 101
47963: PUSH
47964: LD_VAR 0 2
47968: ARRAY
47969: PPUSH
47970: LD_INT 25
47972: PUSH
47973: LD_INT 2
47975: PUSH
47976: EMPTY
47977: LIST
47978: LIST
47979: PUSH
47980: LD_INT 24
47982: PUSH
47983: LD_INT 750
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: PUSH
47990: EMPTY
47991: LIST
47992: LIST
47993: PPUSH
47994: CALL_OW 72
47998: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47999: LD_EXP 130
48003: PUSH
48004: LD_VAR 0 2
48008: ARRAY
48009: PUSH
48010: LD_EXP 101
48014: PUSH
48015: LD_VAR 0 2
48019: ARRAY
48020: PPUSH
48021: LD_INT 25
48023: PUSH
48024: LD_INT 2
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: PUSH
48031: LD_INT 24
48033: PUSH
48034: LD_INT 750
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: PUSH
48041: EMPTY
48042: LIST
48043: LIST
48044: PPUSH
48045: CALL_OW 72
48049: AND
48050: PUSH
48051: LD_VAR 0 5
48055: PUSH
48056: LD_INT 5
48058: LESS
48059: AND
48060: IFFALSE 48142
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48062: LD_ADDR_VAR 0 3
48066: PUSH
48067: LD_EXP 101
48071: PUSH
48072: LD_VAR 0 2
48076: ARRAY
48077: PPUSH
48078: LD_INT 25
48080: PUSH
48081: LD_INT 2
48083: PUSH
48084: EMPTY
48085: LIST
48086: LIST
48087: PUSH
48088: LD_INT 24
48090: PUSH
48091: LD_INT 750
48093: PUSH
48094: EMPTY
48095: LIST
48096: LIST
48097: PUSH
48098: EMPTY
48099: LIST
48100: LIST
48101: PPUSH
48102: CALL_OW 72
48106: PUSH
48107: FOR_IN
48108: IFFALSE 48140
// begin tmp := tmp union j ;
48110: LD_ADDR_VAR 0 5
48114: PUSH
48115: LD_VAR 0 5
48119: PUSH
48120: LD_VAR 0 3
48124: UNION
48125: ST_TO_ADDR
// if tmp >= 5 then
48126: LD_VAR 0 5
48130: PUSH
48131: LD_INT 5
48133: GREATEREQUAL
48134: IFFALSE 48138
// break ;
48136: GO 48140
// end ;
48138: GO 48107
48140: POP
48141: POP
// end ; if not tmp then
48142: LD_VAR 0 5
48146: NOT
48147: IFFALSE 48151
// continue ;
48149: GO 47363
// for j in tmp do
48151: LD_ADDR_VAR 0 3
48155: PUSH
48156: LD_VAR 0 5
48160: PUSH
48161: FOR_IN
48162: IFFALSE 48252
// if not GetTag ( j ) then
48164: LD_VAR 0 3
48168: PPUSH
48169: CALL_OW 110
48173: NOT
48174: IFFALSE 48250
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48176: LD_ADDR_EXP 118
48180: PUSH
48181: LD_EXP 118
48185: PPUSH
48186: LD_VAR 0 2
48190: PUSH
48191: LD_EXP 118
48195: PUSH
48196: LD_VAR 0 2
48200: ARRAY
48201: PUSH
48202: LD_INT 1
48204: PLUS
48205: PUSH
48206: EMPTY
48207: LIST
48208: LIST
48209: PPUSH
48210: LD_VAR 0 3
48214: PPUSH
48215: CALL 71510 0 3
48219: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48220: LD_VAR 0 3
48224: PPUSH
48225: LD_INT 107
48227: PPUSH
48228: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48232: LD_EXP 118
48236: PUSH
48237: LD_VAR 0 2
48241: ARRAY
48242: PUSH
48243: LD_INT 5
48245: GREATEREQUAL
48246: IFFALSE 48250
// break ;
48248: GO 48252
// end ;
48250: GO 48161
48252: POP
48253: POP
// end ; if mc_crates_collector [ i ] and target then
48254: LD_EXP 118
48258: PUSH
48259: LD_VAR 0 2
48263: ARRAY
48264: PUSH
48265: LD_VAR 0 6
48269: AND
48270: IFFALSE 48513
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48272: LD_EXP 118
48276: PUSH
48277: LD_VAR 0 2
48281: ARRAY
48282: PUSH
48283: LD_VAR 0 6
48287: PUSH
48288: LD_INT 1
48290: ARRAY
48291: LESS
48292: IFFALSE 48312
// tmp := mc_crates_collector [ i ] else
48294: LD_ADDR_VAR 0 5
48298: PUSH
48299: LD_EXP 118
48303: PUSH
48304: LD_VAR 0 2
48308: ARRAY
48309: ST_TO_ADDR
48310: GO 48326
// tmp := target [ 1 ] ;
48312: LD_ADDR_VAR 0 5
48316: PUSH
48317: LD_VAR 0 6
48321: PUSH
48322: LD_INT 1
48324: ARRAY
48325: ST_TO_ADDR
// k := 0 ;
48326: LD_ADDR_VAR 0 4
48330: PUSH
48331: LD_INT 0
48333: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48334: LD_ADDR_VAR 0 3
48338: PUSH
48339: LD_EXP 118
48343: PUSH
48344: LD_VAR 0 2
48348: ARRAY
48349: PUSH
48350: FOR_IN
48351: IFFALSE 48511
// begin k := k + 1 ;
48353: LD_ADDR_VAR 0 4
48357: PUSH
48358: LD_VAR 0 4
48362: PUSH
48363: LD_INT 1
48365: PLUS
48366: ST_TO_ADDR
// if k > tmp then
48367: LD_VAR 0 4
48371: PUSH
48372: LD_VAR 0 5
48376: GREATER
48377: IFFALSE 48381
// break ;
48379: GO 48511
// if not GetClass ( j ) in [ 2 , 16 ] then
48381: LD_VAR 0 3
48385: PPUSH
48386: CALL_OW 257
48390: PUSH
48391: LD_INT 2
48393: PUSH
48394: LD_INT 16
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: IN
48401: NOT
48402: IFFALSE 48455
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48404: LD_ADDR_EXP 118
48408: PUSH
48409: LD_EXP 118
48413: PPUSH
48414: LD_VAR 0 2
48418: PPUSH
48419: LD_EXP 118
48423: PUSH
48424: LD_VAR 0 2
48428: ARRAY
48429: PUSH
48430: LD_VAR 0 3
48434: DIFF
48435: PPUSH
48436: CALL_OW 1
48440: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48441: LD_VAR 0 3
48445: PPUSH
48446: LD_INT 0
48448: PPUSH
48449: CALL_OW 109
// continue ;
48453: GO 48350
// end ; if IsInUnit ( j ) then
48455: LD_VAR 0 3
48459: PPUSH
48460: CALL_OW 310
48464: IFFALSE 48475
// ComExitBuilding ( j ) ;
48466: LD_VAR 0 3
48470: PPUSH
48471: CALL_OW 122
// wait ( 3 ) ;
48475: LD_INT 3
48477: PPUSH
48478: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48482: LD_VAR 0 3
48486: PPUSH
48487: LD_VAR 0 6
48491: PUSH
48492: LD_INT 2
48494: ARRAY
48495: PPUSH
48496: LD_VAR 0 6
48500: PUSH
48501: LD_INT 3
48503: ARRAY
48504: PPUSH
48505: CALL_OW 117
// end ;
48509: GO 48350
48511: POP
48512: POP
// end ; end else
48513: GO 49094
// begin for j in cargo do
48515: LD_ADDR_VAR 0 3
48519: PUSH
48520: LD_VAR 0 7
48524: PUSH
48525: FOR_IN
48526: IFFALSE 49092
// begin if GetTag ( j ) <> 0 then
48528: LD_VAR 0 3
48532: PPUSH
48533: CALL_OW 110
48537: PUSH
48538: LD_INT 0
48540: NONEQUAL
48541: IFFALSE 48545
// continue ;
48543: GO 48525
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48545: LD_VAR 0 3
48549: PPUSH
48550: CALL_OW 256
48554: PUSH
48555: LD_INT 1000
48557: LESS
48558: PUSH
48559: LD_VAR 0 3
48563: PPUSH
48564: LD_EXP 125
48568: PUSH
48569: LD_VAR 0 2
48573: ARRAY
48574: PPUSH
48575: CALL_OW 308
48579: NOT
48580: AND
48581: IFFALSE 48603
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48583: LD_VAR 0 3
48587: PPUSH
48588: LD_EXP 125
48592: PUSH
48593: LD_VAR 0 2
48597: ARRAY
48598: PPUSH
48599: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48603: LD_VAR 0 3
48607: PPUSH
48608: CALL_OW 256
48612: PUSH
48613: LD_INT 1000
48615: LESS
48616: PUSH
48617: LD_VAR 0 3
48621: PPUSH
48622: LD_EXP 125
48626: PUSH
48627: LD_VAR 0 2
48631: ARRAY
48632: PPUSH
48633: CALL_OW 308
48637: AND
48638: IFFALSE 48642
// continue ;
48640: GO 48525
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48642: LD_VAR 0 3
48646: PPUSH
48647: CALL_OW 262
48651: PUSH
48652: LD_INT 2
48654: EQUAL
48655: PUSH
48656: LD_VAR 0 3
48660: PPUSH
48661: CALL_OW 261
48665: PUSH
48666: LD_INT 15
48668: LESS
48669: AND
48670: IFFALSE 48674
// continue ;
48672: GO 48525
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48674: LD_VAR 0 3
48678: PPUSH
48679: CALL_OW 262
48683: PUSH
48684: LD_INT 1
48686: EQUAL
48687: PUSH
48688: LD_VAR 0 3
48692: PPUSH
48693: CALL_OW 261
48697: PUSH
48698: LD_INT 10
48700: LESS
48701: AND
48702: IFFALSE 49031
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48704: LD_ADDR_VAR 0 8
48708: PUSH
48709: LD_EXP 101
48713: PUSH
48714: LD_VAR 0 2
48718: ARRAY
48719: PPUSH
48720: LD_INT 2
48722: PUSH
48723: LD_INT 30
48725: PUSH
48726: LD_INT 0
48728: PUSH
48729: EMPTY
48730: LIST
48731: LIST
48732: PUSH
48733: LD_INT 30
48735: PUSH
48736: LD_INT 1
48738: PUSH
48739: EMPTY
48740: LIST
48741: LIST
48742: PUSH
48743: EMPTY
48744: LIST
48745: LIST
48746: LIST
48747: PPUSH
48748: CALL_OW 72
48752: ST_TO_ADDR
// if not depot then
48753: LD_VAR 0 8
48757: NOT
48758: IFFALSE 48762
// continue ;
48760: GO 48525
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48762: LD_VAR 0 3
48766: PPUSH
48767: LD_VAR 0 8
48771: PPUSH
48772: LD_VAR 0 3
48776: PPUSH
48777: CALL_OW 74
48781: PPUSH
48782: CALL_OW 296
48786: PUSH
48787: LD_INT 6
48789: LESS
48790: IFFALSE 48806
// SetFuel ( j , 100 ) else
48792: LD_VAR 0 3
48796: PPUSH
48797: LD_INT 100
48799: PPUSH
48800: CALL_OW 240
48804: GO 49031
// if GetFuel ( j ) = 0 then
48806: LD_VAR 0 3
48810: PPUSH
48811: CALL_OW 261
48815: PUSH
48816: LD_INT 0
48818: EQUAL
48819: IFFALSE 49031
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48821: LD_ADDR_EXP 120
48825: PUSH
48826: LD_EXP 120
48830: PPUSH
48831: LD_VAR 0 2
48835: PPUSH
48836: LD_EXP 120
48840: PUSH
48841: LD_VAR 0 2
48845: ARRAY
48846: PUSH
48847: LD_VAR 0 3
48851: DIFF
48852: PPUSH
48853: CALL_OW 1
48857: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48858: LD_VAR 0 3
48862: PPUSH
48863: CALL_OW 263
48867: PUSH
48868: LD_INT 1
48870: EQUAL
48871: IFFALSE 48887
// ComExitVehicle ( IsInUnit ( j ) ) ;
48873: LD_VAR 0 3
48877: PPUSH
48878: CALL_OW 310
48882: PPUSH
48883: CALL_OW 121
// if GetControl ( j ) = control_remote then
48887: LD_VAR 0 3
48891: PPUSH
48892: CALL_OW 263
48896: PUSH
48897: LD_INT 2
48899: EQUAL
48900: IFFALSE 48911
// ComUnlink ( j ) ;
48902: LD_VAR 0 3
48906: PPUSH
48907: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48911: LD_ADDR_VAR 0 9
48915: PUSH
48916: LD_VAR 0 2
48920: PPUSH
48921: LD_INT 3
48923: PPUSH
48924: CALL 58384 0 2
48928: ST_TO_ADDR
// if fac then
48929: LD_VAR 0 9
48933: IFFALSE 49029
// begin for k in fac do
48935: LD_ADDR_VAR 0 4
48939: PUSH
48940: LD_VAR 0 9
48944: PUSH
48945: FOR_IN
48946: IFFALSE 49027
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48948: LD_ADDR_VAR 0 10
48952: PUSH
48953: LD_VAR 0 9
48957: PPUSH
48958: LD_VAR 0 3
48962: PPUSH
48963: CALL_OW 265
48967: PPUSH
48968: LD_VAR 0 3
48972: PPUSH
48973: CALL_OW 262
48977: PPUSH
48978: LD_VAR 0 3
48982: PPUSH
48983: CALL_OW 263
48987: PPUSH
48988: LD_VAR 0 3
48992: PPUSH
48993: CALL_OW 264
48997: PPUSH
48998: CALL 69042 0 5
49002: ST_TO_ADDR
// if components then
49003: LD_VAR 0 10
49007: IFFALSE 49025
// begin MC_InsertProduceList ( i , components ) ;
49009: LD_VAR 0 2
49013: PPUSH
49014: LD_VAR 0 10
49018: PPUSH
49019: CALL 57929 0 2
// break ;
49023: GO 49027
// end ; end ;
49025: GO 48945
49027: POP
49028: POP
// end ; continue ;
49029: GO 48525
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49031: LD_VAR 0 3
49035: PPUSH
49036: LD_INT 1
49038: PPUSH
49039: CALL_OW 289
49043: PUSH
49044: LD_INT 100
49046: LESS
49047: PUSH
49048: LD_VAR 0 3
49052: PPUSH
49053: CALL_OW 314
49057: NOT
49058: AND
49059: IFFALSE 49088
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49061: LD_VAR 0 3
49065: PPUSH
49066: LD_VAR 0 6
49070: PUSH
49071: LD_INT 2
49073: ARRAY
49074: PPUSH
49075: LD_VAR 0 6
49079: PUSH
49080: LD_INT 3
49082: ARRAY
49083: PPUSH
49084: CALL_OW 117
// break ;
49088: GO 49092
// end ;
49090: GO 48525
49092: POP
49093: POP
// end ; end ;
49094: GO 47363
49096: POP
49097: POP
// end ;
49098: LD_VAR 0 1
49102: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49103: LD_INT 0
49105: PPUSH
49106: PPUSH
49107: PPUSH
49108: PPUSH
// if not mc_bases then
49109: LD_EXP 101
49113: NOT
49114: IFFALSE 49118
// exit ;
49116: GO 49279
// for i = 1 to mc_bases do
49118: LD_ADDR_VAR 0 2
49122: PUSH
49123: DOUBLE
49124: LD_INT 1
49126: DEC
49127: ST_TO_ADDR
49128: LD_EXP 101
49132: PUSH
49133: FOR_TO
49134: IFFALSE 49277
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49136: LD_ADDR_VAR 0 4
49140: PUSH
49141: LD_EXP 120
49145: PUSH
49146: LD_VAR 0 2
49150: ARRAY
49151: PUSH
49152: LD_EXP 123
49156: PUSH
49157: LD_VAR 0 2
49161: ARRAY
49162: UNION
49163: PPUSH
49164: LD_INT 33
49166: PUSH
49167: LD_INT 2
49169: PUSH
49170: EMPTY
49171: LIST
49172: LIST
49173: PPUSH
49174: CALL_OW 72
49178: ST_TO_ADDR
// if tmp then
49179: LD_VAR 0 4
49183: IFFALSE 49275
// for j in tmp do
49185: LD_ADDR_VAR 0 3
49189: PUSH
49190: LD_VAR 0 4
49194: PUSH
49195: FOR_IN
49196: IFFALSE 49273
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49198: LD_VAR 0 3
49202: PPUSH
49203: CALL_OW 312
49207: NOT
49208: PUSH
49209: LD_VAR 0 3
49213: PPUSH
49214: CALL_OW 256
49218: PUSH
49219: LD_INT 250
49221: GREATEREQUAL
49222: AND
49223: IFFALSE 49236
// Connect ( j ) else
49225: LD_VAR 0 3
49229: PPUSH
49230: CALL 74443 0 1
49234: GO 49271
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49236: LD_VAR 0 3
49240: PPUSH
49241: CALL_OW 256
49245: PUSH
49246: LD_INT 250
49248: LESS
49249: PUSH
49250: LD_VAR 0 3
49254: PPUSH
49255: CALL_OW 312
49259: AND
49260: IFFALSE 49271
// ComUnlink ( j ) ;
49262: LD_VAR 0 3
49266: PPUSH
49267: CALL_OW 136
49271: GO 49195
49273: POP
49274: POP
// end ;
49275: GO 49133
49277: POP
49278: POP
// end ;
49279: LD_VAR 0 1
49283: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49284: LD_INT 0
49286: PPUSH
49287: PPUSH
49288: PPUSH
49289: PPUSH
49290: PPUSH
// if not mc_bases then
49291: LD_EXP 101
49295: NOT
49296: IFFALSE 49300
// exit ;
49298: GO 49745
// for i = 1 to mc_bases do
49300: LD_ADDR_VAR 0 2
49304: PUSH
49305: DOUBLE
49306: LD_INT 1
49308: DEC
49309: ST_TO_ADDR
49310: LD_EXP 101
49314: PUSH
49315: FOR_TO
49316: IFFALSE 49743
// begin if not mc_produce [ i ] then
49318: LD_EXP 122
49322: PUSH
49323: LD_VAR 0 2
49327: ARRAY
49328: NOT
49329: IFFALSE 49333
// continue ;
49331: GO 49315
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49333: LD_ADDR_VAR 0 5
49337: PUSH
49338: LD_EXP 101
49342: PUSH
49343: LD_VAR 0 2
49347: ARRAY
49348: PPUSH
49349: LD_INT 30
49351: PUSH
49352: LD_INT 3
49354: PUSH
49355: EMPTY
49356: LIST
49357: LIST
49358: PPUSH
49359: CALL_OW 72
49363: ST_TO_ADDR
// if not fac then
49364: LD_VAR 0 5
49368: NOT
49369: IFFALSE 49373
// continue ;
49371: GO 49315
// for j in fac do
49373: LD_ADDR_VAR 0 3
49377: PUSH
49378: LD_VAR 0 5
49382: PUSH
49383: FOR_IN
49384: IFFALSE 49739
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49386: LD_VAR 0 3
49390: PPUSH
49391: CALL_OW 461
49395: PUSH
49396: LD_INT 2
49398: NONEQUAL
49399: PUSH
49400: LD_VAR 0 3
49404: PPUSH
49405: LD_INT 15
49407: PPUSH
49408: CALL 74103 0 2
49412: PUSH
49413: LD_INT 4
49415: ARRAY
49416: OR
49417: IFFALSE 49421
// continue ;
49419: GO 49383
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49421: LD_VAR 0 3
49425: PPUSH
49426: LD_EXP 122
49430: PUSH
49431: LD_VAR 0 2
49435: ARRAY
49436: PUSH
49437: LD_INT 1
49439: ARRAY
49440: PUSH
49441: LD_INT 1
49443: ARRAY
49444: PPUSH
49445: LD_EXP 122
49449: PUSH
49450: LD_VAR 0 2
49454: ARRAY
49455: PUSH
49456: LD_INT 1
49458: ARRAY
49459: PUSH
49460: LD_INT 2
49462: ARRAY
49463: PPUSH
49464: LD_EXP 122
49468: PUSH
49469: LD_VAR 0 2
49473: ARRAY
49474: PUSH
49475: LD_INT 1
49477: ARRAY
49478: PUSH
49479: LD_INT 3
49481: ARRAY
49482: PPUSH
49483: LD_EXP 122
49487: PUSH
49488: LD_VAR 0 2
49492: ARRAY
49493: PUSH
49494: LD_INT 1
49496: ARRAY
49497: PUSH
49498: LD_INT 4
49500: ARRAY
49501: PPUSH
49502: CALL_OW 448
49506: PUSH
49507: LD_VAR 0 3
49511: PPUSH
49512: LD_EXP 122
49516: PUSH
49517: LD_VAR 0 2
49521: ARRAY
49522: PUSH
49523: LD_INT 1
49525: ARRAY
49526: PUSH
49527: LD_INT 1
49529: ARRAY
49530: PUSH
49531: LD_EXP 122
49535: PUSH
49536: LD_VAR 0 2
49540: ARRAY
49541: PUSH
49542: LD_INT 1
49544: ARRAY
49545: PUSH
49546: LD_INT 2
49548: ARRAY
49549: PUSH
49550: LD_EXP 122
49554: PUSH
49555: LD_VAR 0 2
49559: ARRAY
49560: PUSH
49561: LD_INT 1
49563: ARRAY
49564: PUSH
49565: LD_INT 3
49567: ARRAY
49568: PUSH
49569: LD_EXP 122
49573: PUSH
49574: LD_VAR 0 2
49578: ARRAY
49579: PUSH
49580: LD_INT 1
49582: ARRAY
49583: PUSH
49584: LD_INT 4
49586: ARRAY
49587: PUSH
49588: EMPTY
49589: LIST
49590: LIST
49591: LIST
49592: LIST
49593: PPUSH
49594: CALL 77774 0 2
49598: AND
49599: IFFALSE 49737
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49601: LD_VAR 0 3
49605: PPUSH
49606: LD_EXP 122
49610: PUSH
49611: LD_VAR 0 2
49615: ARRAY
49616: PUSH
49617: LD_INT 1
49619: ARRAY
49620: PUSH
49621: LD_INT 1
49623: ARRAY
49624: PPUSH
49625: LD_EXP 122
49629: PUSH
49630: LD_VAR 0 2
49634: ARRAY
49635: PUSH
49636: LD_INT 1
49638: ARRAY
49639: PUSH
49640: LD_INT 2
49642: ARRAY
49643: PPUSH
49644: LD_EXP 122
49648: PUSH
49649: LD_VAR 0 2
49653: ARRAY
49654: PUSH
49655: LD_INT 1
49657: ARRAY
49658: PUSH
49659: LD_INT 3
49661: ARRAY
49662: PPUSH
49663: LD_EXP 122
49667: PUSH
49668: LD_VAR 0 2
49672: ARRAY
49673: PUSH
49674: LD_INT 1
49676: ARRAY
49677: PUSH
49678: LD_INT 4
49680: ARRAY
49681: PPUSH
49682: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49686: LD_ADDR_VAR 0 4
49690: PUSH
49691: LD_EXP 122
49695: PUSH
49696: LD_VAR 0 2
49700: ARRAY
49701: PPUSH
49702: LD_INT 1
49704: PPUSH
49705: CALL_OW 3
49709: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49710: LD_ADDR_EXP 122
49714: PUSH
49715: LD_EXP 122
49719: PPUSH
49720: LD_VAR 0 2
49724: PPUSH
49725: LD_VAR 0 4
49729: PPUSH
49730: CALL_OW 1
49734: ST_TO_ADDR
// break ;
49735: GO 49739
// end ; end ;
49737: GO 49383
49739: POP
49740: POP
// end ;
49741: GO 49315
49743: POP
49744: POP
// end ;
49745: LD_VAR 0 1
49749: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49750: LD_INT 0
49752: PPUSH
49753: PPUSH
49754: PPUSH
// if not mc_bases then
49755: LD_EXP 101
49759: NOT
49760: IFFALSE 49764
// exit ;
49762: GO 49853
// for i = 1 to mc_bases do
49764: LD_ADDR_VAR 0 2
49768: PUSH
49769: DOUBLE
49770: LD_INT 1
49772: DEC
49773: ST_TO_ADDR
49774: LD_EXP 101
49778: PUSH
49779: FOR_TO
49780: IFFALSE 49851
// begin if mc_attack [ i ] then
49782: LD_EXP 121
49786: PUSH
49787: LD_VAR 0 2
49791: ARRAY
49792: IFFALSE 49849
// begin tmp := mc_attack [ i ] [ 1 ] ;
49794: LD_ADDR_VAR 0 3
49798: PUSH
49799: LD_EXP 121
49803: PUSH
49804: LD_VAR 0 2
49808: ARRAY
49809: PUSH
49810: LD_INT 1
49812: ARRAY
49813: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49814: LD_ADDR_EXP 121
49818: PUSH
49819: LD_EXP 121
49823: PPUSH
49824: LD_VAR 0 2
49828: PPUSH
49829: EMPTY
49830: PPUSH
49831: CALL_OW 1
49835: ST_TO_ADDR
// Attack ( tmp ) ;
49836: LD_VAR 0 3
49840: PPUSH
49841: CALL 99964 0 1
// exit ;
49845: POP
49846: POP
49847: GO 49853
// end ; end ;
49849: GO 49779
49851: POP
49852: POP
// end ;
49853: LD_VAR 0 1
49857: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49858: LD_INT 0
49860: PPUSH
49861: PPUSH
49862: PPUSH
49863: PPUSH
49864: PPUSH
49865: PPUSH
49866: PPUSH
// if not mc_bases then
49867: LD_EXP 101
49871: NOT
49872: IFFALSE 49876
// exit ;
49874: GO 50458
// for i = 1 to mc_bases do
49876: LD_ADDR_VAR 0 2
49880: PUSH
49881: DOUBLE
49882: LD_INT 1
49884: DEC
49885: ST_TO_ADDR
49886: LD_EXP 101
49890: PUSH
49891: FOR_TO
49892: IFFALSE 50456
// begin if not mc_bases [ i ] then
49894: LD_EXP 101
49898: PUSH
49899: LD_VAR 0 2
49903: ARRAY
49904: NOT
49905: IFFALSE 49909
// continue ;
49907: GO 49891
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49909: LD_ADDR_VAR 0 7
49913: PUSH
49914: LD_EXP 101
49918: PUSH
49919: LD_VAR 0 2
49923: ARRAY
49924: PUSH
49925: LD_INT 1
49927: ARRAY
49928: PPUSH
49929: CALL 68346 0 1
49933: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49934: LD_ADDR_EXP 124
49938: PUSH
49939: LD_EXP 124
49943: PPUSH
49944: LD_VAR 0 2
49948: PPUSH
49949: LD_EXP 101
49953: PUSH
49954: LD_VAR 0 2
49958: ARRAY
49959: PUSH
49960: LD_INT 1
49962: ARRAY
49963: PPUSH
49964: CALL_OW 255
49968: PPUSH
49969: LD_EXP 126
49973: PUSH
49974: LD_VAR 0 2
49978: ARRAY
49979: PPUSH
49980: CALL 65900 0 2
49984: PPUSH
49985: CALL_OW 1
49989: ST_TO_ADDR
// if not mc_scan [ i ] then
49990: LD_EXP 124
49994: PUSH
49995: LD_VAR 0 2
49999: ARRAY
50000: NOT
50001: IFFALSE 50156
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50003: LD_ADDR_VAR 0 4
50007: PUSH
50008: LD_EXP 101
50012: PUSH
50013: LD_VAR 0 2
50017: ARRAY
50018: PPUSH
50019: LD_INT 2
50021: PUSH
50022: LD_INT 25
50024: PUSH
50025: LD_INT 5
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: PUSH
50032: LD_INT 25
50034: PUSH
50035: LD_INT 8
50037: PUSH
50038: EMPTY
50039: LIST
50040: LIST
50041: PUSH
50042: LD_INT 25
50044: PUSH
50045: LD_INT 9
50047: PUSH
50048: EMPTY
50049: LIST
50050: LIST
50051: PUSH
50052: EMPTY
50053: LIST
50054: LIST
50055: LIST
50056: LIST
50057: PPUSH
50058: CALL_OW 72
50062: ST_TO_ADDR
// if not tmp then
50063: LD_VAR 0 4
50067: NOT
50068: IFFALSE 50072
// continue ;
50070: GO 49891
// for j in tmp do
50072: LD_ADDR_VAR 0 3
50076: PUSH
50077: LD_VAR 0 4
50081: PUSH
50082: FOR_IN
50083: IFFALSE 50154
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50085: LD_VAR 0 3
50089: PPUSH
50090: CALL_OW 310
50094: PPUSH
50095: CALL_OW 266
50099: PUSH
50100: LD_INT 5
50102: EQUAL
50103: PUSH
50104: LD_VAR 0 3
50108: PPUSH
50109: CALL_OW 257
50113: PUSH
50114: LD_INT 1
50116: EQUAL
50117: AND
50118: PUSH
50119: LD_VAR 0 3
50123: PPUSH
50124: CALL_OW 459
50128: NOT
50129: AND
50130: PUSH
50131: LD_VAR 0 7
50135: AND
50136: IFFALSE 50152
// ComChangeProfession ( j , class ) ;
50138: LD_VAR 0 3
50142: PPUSH
50143: LD_VAR 0 7
50147: PPUSH
50148: CALL_OW 123
50152: GO 50082
50154: POP
50155: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50156: LD_EXP 124
50160: PUSH
50161: LD_VAR 0 2
50165: ARRAY
50166: PUSH
50167: LD_EXP 123
50171: PUSH
50172: LD_VAR 0 2
50176: ARRAY
50177: NOT
50178: AND
50179: PUSH
50180: LD_EXP 101
50184: PUSH
50185: LD_VAR 0 2
50189: ARRAY
50190: PPUSH
50191: LD_INT 30
50193: PUSH
50194: LD_INT 32
50196: PUSH
50197: EMPTY
50198: LIST
50199: LIST
50200: PPUSH
50201: CALL_OW 72
50205: NOT
50206: AND
50207: PUSH
50208: LD_EXP 101
50212: PUSH
50213: LD_VAR 0 2
50217: ARRAY
50218: PPUSH
50219: LD_INT 2
50221: PUSH
50222: LD_INT 30
50224: PUSH
50225: LD_INT 4
50227: PUSH
50228: EMPTY
50229: LIST
50230: LIST
50231: PUSH
50232: LD_INT 30
50234: PUSH
50235: LD_INT 5
50237: PUSH
50238: EMPTY
50239: LIST
50240: LIST
50241: PUSH
50242: EMPTY
50243: LIST
50244: LIST
50245: LIST
50246: PPUSH
50247: CALL_OW 72
50251: NOT
50252: AND
50253: IFFALSE 50385
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50255: LD_ADDR_VAR 0 4
50259: PUSH
50260: LD_EXP 101
50264: PUSH
50265: LD_VAR 0 2
50269: ARRAY
50270: PPUSH
50271: LD_INT 2
50273: PUSH
50274: LD_INT 25
50276: PUSH
50277: LD_INT 1
50279: PUSH
50280: EMPTY
50281: LIST
50282: LIST
50283: PUSH
50284: LD_INT 25
50286: PUSH
50287: LD_INT 5
50289: PUSH
50290: EMPTY
50291: LIST
50292: LIST
50293: PUSH
50294: LD_INT 25
50296: PUSH
50297: LD_INT 8
50299: PUSH
50300: EMPTY
50301: LIST
50302: LIST
50303: PUSH
50304: LD_INT 25
50306: PUSH
50307: LD_INT 9
50309: PUSH
50310: EMPTY
50311: LIST
50312: LIST
50313: PUSH
50314: EMPTY
50315: LIST
50316: LIST
50317: LIST
50318: LIST
50319: LIST
50320: PPUSH
50321: CALL_OW 72
50325: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50326: LD_ADDR_VAR 0 4
50330: PUSH
50331: LD_VAR 0 4
50335: PUSH
50336: LD_VAR 0 4
50340: PPUSH
50341: LD_INT 18
50343: PPUSH
50344: CALL 104773 0 2
50348: DIFF
50349: ST_TO_ADDR
// if tmp then
50350: LD_VAR 0 4
50354: IFFALSE 50385
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50356: LD_VAR 0 2
50360: PPUSH
50361: LD_VAR 0 4
50365: PPUSH
50366: LD_EXP 126
50370: PUSH
50371: LD_VAR 0 2
50375: ARRAY
50376: PPUSH
50377: CALL 65935 0 3
// exit ;
50381: POP
50382: POP
50383: GO 50458
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50385: LD_EXP 124
50389: PUSH
50390: LD_VAR 0 2
50394: ARRAY
50395: PUSH
50396: LD_EXP 123
50400: PUSH
50401: LD_VAR 0 2
50405: ARRAY
50406: AND
50407: IFFALSE 50454
// begin tmp := mc_defender [ i ] ;
50409: LD_ADDR_VAR 0 4
50413: PUSH
50414: LD_EXP 123
50418: PUSH
50419: LD_VAR 0 2
50423: ARRAY
50424: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50425: LD_VAR 0 2
50429: PPUSH
50430: LD_VAR 0 4
50434: PPUSH
50435: LD_EXP 124
50439: PUSH
50440: LD_VAR 0 2
50444: ARRAY
50445: PPUSH
50446: CALL 66496 0 3
// exit ;
50450: POP
50451: POP
50452: GO 50458
// end ; end ;
50454: GO 49891
50456: POP
50457: POP
// end ;
50458: LD_VAR 0 1
50462: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50463: LD_INT 0
50465: PPUSH
50466: PPUSH
50467: PPUSH
50468: PPUSH
50469: PPUSH
50470: PPUSH
50471: PPUSH
50472: PPUSH
50473: PPUSH
50474: PPUSH
50475: PPUSH
// if not mc_bases then
50476: LD_EXP 101
50480: NOT
50481: IFFALSE 50485
// exit ;
50483: GO 51572
// for i = 1 to mc_bases do
50485: LD_ADDR_VAR 0 2
50489: PUSH
50490: DOUBLE
50491: LD_INT 1
50493: DEC
50494: ST_TO_ADDR
50495: LD_EXP 101
50499: PUSH
50500: FOR_TO
50501: IFFALSE 51570
// begin tmp := mc_lab [ i ] ;
50503: LD_ADDR_VAR 0 6
50507: PUSH
50508: LD_EXP 134
50512: PUSH
50513: LD_VAR 0 2
50517: ARRAY
50518: ST_TO_ADDR
// if not tmp then
50519: LD_VAR 0 6
50523: NOT
50524: IFFALSE 50528
// continue ;
50526: GO 50500
// idle_lab := 0 ;
50528: LD_ADDR_VAR 0 11
50532: PUSH
50533: LD_INT 0
50535: ST_TO_ADDR
// for j in tmp do
50536: LD_ADDR_VAR 0 3
50540: PUSH
50541: LD_VAR 0 6
50545: PUSH
50546: FOR_IN
50547: IFFALSE 51566
// begin researching := false ;
50549: LD_ADDR_VAR 0 10
50553: PUSH
50554: LD_INT 0
50556: ST_TO_ADDR
// side := GetSide ( j ) ;
50557: LD_ADDR_VAR 0 4
50561: PUSH
50562: LD_VAR 0 3
50566: PPUSH
50567: CALL_OW 255
50571: ST_TO_ADDR
// if not mc_tech [ side ] then
50572: LD_EXP 128
50576: PUSH
50577: LD_VAR 0 4
50581: ARRAY
50582: NOT
50583: IFFALSE 50587
// continue ;
50585: GO 50546
// if BuildingStatus ( j ) = bs_idle then
50587: LD_VAR 0 3
50591: PPUSH
50592: CALL_OW 461
50596: PUSH
50597: LD_INT 2
50599: EQUAL
50600: IFFALSE 50788
// begin if idle_lab and UnitsInside ( j ) < 6 then
50602: LD_VAR 0 11
50606: PUSH
50607: LD_VAR 0 3
50611: PPUSH
50612: CALL_OW 313
50616: PUSH
50617: LD_INT 6
50619: LESS
50620: AND
50621: IFFALSE 50692
// begin tmp2 := UnitsInside ( idle_lab ) ;
50623: LD_ADDR_VAR 0 9
50627: PUSH
50628: LD_VAR 0 11
50632: PPUSH
50633: CALL_OW 313
50637: ST_TO_ADDR
// if tmp2 then
50638: LD_VAR 0 9
50642: IFFALSE 50684
// for x in tmp2 do
50644: LD_ADDR_VAR 0 7
50648: PUSH
50649: LD_VAR 0 9
50653: PUSH
50654: FOR_IN
50655: IFFALSE 50682
// begin ComExitBuilding ( x ) ;
50657: LD_VAR 0 7
50661: PPUSH
50662: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50666: LD_VAR 0 7
50670: PPUSH
50671: LD_VAR 0 3
50675: PPUSH
50676: CALL_OW 180
// end ;
50680: GO 50654
50682: POP
50683: POP
// idle_lab := 0 ;
50684: LD_ADDR_VAR 0 11
50688: PUSH
50689: LD_INT 0
50691: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50692: LD_ADDR_VAR 0 5
50696: PUSH
50697: LD_EXP 128
50701: PUSH
50702: LD_VAR 0 4
50706: ARRAY
50707: PUSH
50708: FOR_IN
50709: IFFALSE 50769
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50711: LD_VAR 0 3
50715: PPUSH
50716: LD_VAR 0 5
50720: PPUSH
50721: CALL_OW 430
50725: PUSH
50726: LD_VAR 0 4
50730: PPUSH
50731: LD_VAR 0 5
50735: PPUSH
50736: CALL 65005 0 2
50740: AND
50741: IFFALSE 50767
// begin researching := true ;
50743: LD_ADDR_VAR 0 10
50747: PUSH
50748: LD_INT 1
50750: ST_TO_ADDR
// ComResearch ( j , t ) ;
50751: LD_VAR 0 3
50755: PPUSH
50756: LD_VAR 0 5
50760: PPUSH
50761: CALL_OW 124
// break ;
50765: GO 50769
// end ;
50767: GO 50708
50769: POP
50770: POP
// if not researching then
50771: LD_VAR 0 10
50775: NOT
50776: IFFALSE 50788
// idle_lab := j ;
50778: LD_ADDR_VAR 0 11
50782: PUSH
50783: LD_VAR 0 3
50787: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50788: LD_VAR 0 3
50792: PPUSH
50793: CALL_OW 461
50797: PUSH
50798: LD_INT 10
50800: EQUAL
50801: IFFALSE 51389
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50803: LD_EXP 130
50807: PUSH
50808: LD_VAR 0 2
50812: ARRAY
50813: NOT
50814: PUSH
50815: LD_EXP 131
50819: PUSH
50820: LD_VAR 0 2
50824: ARRAY
50825: NOT
50826: AND
50827: PUSH
50828: LD_EXP 128
50832: PUSH
50833: LD_VAR 0 4
50837: ARRAY
50838: PUSH
50839: LD_INT 1
50841: GREATER
50842: AND
50843: IFFALSE 50974
// begin ComCancel ( j ) ;
50845: LD_VAR 0 3
50849: PPUSH
50850: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50854: LD_ADDR_EXP 128
50858: PUSH
50859: LD_EXP 128
50863: PPUSH
50864: LD_VAR 0 4
50868: PPUSH
50869: LD_EXP 128
50873: PUSH
50874: LD_VAR 0 4
50878: ARRAY
50879: PPUSH
50880: LD_EXP 128
50884: PUSH
50885: LD_VAR 0 4
50889: ARRAY
50890: PUSH
50891: LD_INT 1
50893: MINUS
50894: PPUSH
50895: LD_EXP 128
50899: PUSH
50900: LD_VAR 0 4
50904: ARRAY
50905: PPUSH
50906: LD_INT 0
50908: PPUSH
50909: CALL 70928 0 4
50913: PPUSH
50914: CALL_OW 1
50918: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50919: LD_ADDR_EXP 128
50923: PUSH
50924: LD_EXP 128
50928: PPUSH
50929: LD_VAR 0 4
50933: PPUSH
50934: LD_EXP 128
50938: PUSH
50939: LD_VAR 0 4
50943: ARRAY
50944: PPUSH
50945: LD_EXP 128
50949: PUSH
50950: LD_VAR 0 4
50954: ARRAY
50955: PPUSH
50956: LD_INT 1
50958: PPUSH
50959: LD_INT 0
50961: PPUSH
50962: CALL 70928 0 4
50966: PPUSH
50967: CALL_OW 1
50971: ST_TO_ADDR
// continue ;
50972: GO 50546
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50974: LD_EXP 130
50978: PUSH
50979: LD_VAR 0 2
50983: ARRAY
50984: PUSH
50985: LD_EXP 131
50989: PUSH
50990: LD_VAR 0 2
50994: ARRAY
50995: NOT
50996: AND
50997: IFFALSE 51124
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50999: LD_ADDR_EXP 131
51003: PUSH
51004: LD_EXP 131
51008: PPUSH
51009: LD_VAR 0 2
51013: PUSH
51014: LD_EXP 131
51018: PUSH
51019: LD_VAR 0 2
51023: ARRAY
51024: PUSH
51025: LD_INT 1
51027: PLUS
51028: PUSH
51029: EMPTY
51030: LIST
51031: LIST
51032: PPUSH
51033: LD_EXP 130
51037: PUSH
51038: LD_VAR 0 2
51042: ARRAY
51043: PUSH
51044: LD_INT 1
51046: ARRAY
51047: PPUSH
51048: CALL 71510 0 3
51052: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51053: LD_EXP 130
51057: PUSH
51058: LD_VAR 0 2
51062: ARRAY
51063: PUSH
51064: LD_INT 1
51066: ARRAY
51067: PPUSH
51068: LD_INT 112
51070: PPUSH
51071: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51075: LD_ADDR_VAR 0 9
51079: PUSH
51080: LD_EXP 130
51084: PUSH
51085: LD_VAR 0 2
51089: ARRAY
51090: PPUSH
51091: LD_INT 1
51093: PPUSH
51094: CALL_OW 3
51098: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51099: LD_ADDR_EXP 130
51103: PUSH
51104: LD_EXP 130
51108: PPUSH
51109: LD_VAR 0 2
51113: PPUSH
51114: LD_VAR 0 9
51118: PPUSH
51119: CALL_OW 1
51123: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51124: LD_EXP 130
51128: PUSH
51129: LD_VAR 0 2
51133: ARRAY
51134: PUSH
51135: LD_EXP 131
51139: PUSH
51140: LD_VAR 0 2
51144: ARRAY
51145: AND
51146: PUSH
51147: LD_EXP 131
51151: PUSH
51152: LD_VAR 0 2
51156: ARRAY
51157: PUSH
51158: LD_INT 1
51160: ARRAY
51161: PPUSH
51162: CALL_OW 310
51166: NOT
51167: AND
51168: PUSH
51169: LD_VAR 0 3
51173: PPUSH
51174: CALL_OW 313
51178: PUSH
51179: LD_INT 6
51181: EQUAL
51182: AND
51183: IFFALSE 51239
// begin tmp2 := UnitsInside ( j ) ;
51185: LD_ADDR_VAR 0 9
51189: PUSH
51190: LD_VAR 0 3
51194: PPUSH
51195: CALL_OW 313
51199: ST_TO_ADDR
// if tmp2 = 6 then
51200: LD_VAR 0 9
51204: PUSH
51205: LD_INT 6
51207: EQUAL
51208: IFFALSE 51239
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51210: LD_VAR 0 9
51214: PUSH
51215: LD_INT 1
51217: ARRAY
51218: PPUSH
51219: LD_INT 112
51221: PPUSH
51222: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51226: LD_VAR 0 9
51230: PUSH
51231: LD_INT 1
51233: ARRAY
51234: PPUSH
51235: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51239: LD_EXP 131
51243: PUSH
51244: LD_VAR 0 2
51248: ARRAY
51249: PUSH
51250: LD_EXP 131
51254: PUSH
51255: LD_VAR 0 2
51259: ARRAY
51260: PUSH
51261: LD_INT 1
51263: ARRAY
51264: PPUSH
51265: CALL_OW 314
51269: NOT
51270: AND
51271: PUSH
51272: LD_EXP 131
51276: PUSH
51277: LD_VAR 0 2
51281: ARRAY
51282: PUSH
51283: LD_INT 1
51285: ARRAY
51286: PPUSH
51287: CALL_OW 310
51291: NOT
51292: AND
51293: IFFALSE 51319
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51295: LD_EXP 131
51299: PUSH
51300: LD_VAR 0 2
51304: ARRAY
51305: PUSH
51306: LD_INT 1
51308: ARRAY
51309: PPUSH
51310: LD_VAR 0 3
51314: PPUSH
51315: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51319: LD_EXP 131
51323: PUSH
51324: LD_VAR 0 2
51328: ARRAY
51329: PUSH
51330: LD_INT 1
51332: ARRAY
51333: PPUSH
51334: CALL_OW 310
51338: PUSH
51339: LD_EXP 131
51343: PUSH
51344: LD_VAR 0 2
51348: ARRAY
51349: PUSH
51350: LD_INT 1
51352: ARRAY
51353: PPUSH
51354: CALL_OW 310
51358: PPUSH
51359: CALL_OW 461
51363: PUSH
51364: LD_INT 3
51366: NONEQUAL
51367: AND
51368: IFFALSE 51389
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51370: LD_EXP 131
51374: PUSH
51375: LD_VAR 0 2
51379: ARRAY
51380: PUSH
51381: LD_INT 1
51383: ARRAY
51384: PPUSH
51385: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51389: LD_VAR 0 3
51393: PPUSH
51394: CALL_OW 461
51398: PUSH
51399: LD_INT 6
51401: EQUAL
51402: PUSH
51403: LD_VAR 0 6
51407: PUSH
51408: LD_INT 1
51410: GREATER
51411: AND
51412: IFFALSE 51564
// begin sci := [ ] ;
51414: LD_ADDR_VAR 0 8
51418: PUSH
51419: EMPTY
51420: ST_TO_ADDR
// for x in ( tmp diff j ) do
51421: LD_ADDR_VAR 0 7
51425: PUSH
51426: LD_VAR 0 6
51430: PUSH
51431: LD_VAR 0 3
51435: DIFF
51436: PUSH
51437: FOR_IN
51438: IFFALSE 51490
// begin if sci = 6 then
51440: LD_VAR 0 8
51444: PUSH
51445: LD_INT 6
51447: EQUAL
51448: IFFALSE 51452
// break ;
51450: GO 51490
// if BuildingStatus ( x ) = bs_idle then
51452: LD_VAR 0 7
51456: PPUSH
51457: CALL_OW 461
51461: PUSH
51462: LD_INT 2
51464: EQUAL
51465: IFFALSE 51488
// sci := sci ^ UnitsInside ( x ) ;
51467: LD_ADDR_VAR 0 8
51471: PUSH
51472: LD_VAR 0 8
51476: PUSH
51477: LD_VAR 0 7
51481: PPUSH
51482: CALL_OW 313
51486: ADD
51487: ST_TO_ADDR
// end ;
51488: GO 51437
51490: POP
51491: POP
// if not sci then
51492: LD_VAR 0 8
51496: NOT
51497: IFFALSE 51501
// continue ;
51499: GO 50546
// for x in sci do
51501: LD_ADDR_VAR 0 7
51505: PUSH
51506: LD_VAR 0 8
51510: PUSH
51511: FOR_IN
51512: IFFALSE 51562
// if IsInUnit ( x ) and not HasTask ( x ) then
51514: LD_VAR 0 7
51518: PPUSH
51519: CALL_OW 310
51523: PUSH
51524: LD_VAR 0 7
51528: PPUSH
51529: CALL_OW 314
51533: NOT
51534: AND
51535: IFFALSE 51560
// begin ComExitBuilding ( x ) ;
51537: LD_VAR 0 7
51541: PPUSH
51542: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51546: LD_VAR 0 7
51550: PPUSH
51551: LD_VAR 0 3
51555: PPUSH
51556: CALL_OW 180
// end ;
51560: GO 51511
51562: POP
51563: POP
// end ; end ;
51564: GO 50546
51566: POP
51567: POP
// end ;
51568: GO 50500
51570: POP
51571: POP
// end ;
51572: LD_VAR 0 1
51576: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51577: LD_INT 0
51579: PPUSH
51580: PPUSH
// if not mc_bases then
51581: LD_EXP 101
51585: NOT
51586: IFFALSE 51590
// exit ;
51588: GO 51671
// for i = 1 to mc_bases do
51590: LD_ADDR_VAR 0 2
51594: PUSH
51595: DOUBLE
51596: LD_INT 1
51598: DEC
51599: ST_TO_ADDR
51600: LD_EXP 101
51604: PUSH
51605: FOR_TO
51606: IFFALSE 51669
// if mc_mines [ i ] and mc_miners [ i ] then
51608: LD_EXP 114
51612: PUSH
51613: LD_VAR 0 2
51617: ARRAY
51618: PUSH
51619: LD_EXP 115
51623: PUSH
51624: LD_VAR 0 2
51628: ARRAY
51629: AND
51630: IFFALSE 51667
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51632: LD_EXP 115
51636: PUSH
51637: LD_VAR 0 2
51641: ARRAY
51642: PUSH
51643: LD_INT 1
51645: ARRAY
51646: PPUSH
51647: CALL_OW 255
51651: PPUSH
51652: LD_EXP 114
51656: PUSH
51657: LD_VAR 0 2
51661: ARRAY
51662: PPUSH
51663: CALL 68499 0 2
51667: GO 51605
51669: POP
51670: POP
// end ;
51671: LD_VAR 0 1
51675: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51676: LD_INT 0
51678: PPUSH
51679: PPUSH
51680: PPUSH
51681: PPUSH
51682: PPUSH
51683: PPUSH
51684: PPUSH
51685: PPUSH
// if not mc_bases or not mc_parking then
51686: LD_EXP 101
51690: NOT
51691: PUSH
51692: LD_EXP 125
51696: NOT
51697: OR
51698: IFFALSE 51702
// exit ;
51700: GO 52401
// for i = 1 to mc_bases do
51702: LD_ADDR_VAR 0 2
51706: PUSH
51707: DOUBLE
51708: LD_INT 1
51710: DEC
51711: ST_TO_ADDR
51712: LD_EXP 101
51716: PUSH
51717: FOR_TO
51718: IFFALSE 52399
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51720: LD_EXP 101
51724: PUSH
51725: LD_VAR 0 2
51729: ARRAY
51730: NOT
51731: PUSH
51732: LD_EXP 125
51736: PUSH
51737: LD_VAR 0 2
51741: ARRAY
51742: NOT
51743: OR
51744: IFFALSE 51748
// continue ;
51746: GO 51717
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51748: LD_ADDR_VAR 0 5
51752: PUSH
51753: LD_EXP 101
51757: PUSH
51758: LD_VAR 0 2
51762: ARRAY
51763: PUSH
51764: LD_INT 1
51766: ARRAY
51767: PPUSH
51768: CALL_OW 255
51772: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51773: LD_ADDR_VAR 0 6
51777: PUSH
51778: LD_EXP 101
51782: PUSH
51783: LD_VAR 0 2
51787: ARRAY
51788: PPUSH
51789: LD_INT 30
51791: PUSH
51792: LD_INT 3
51794: PUSH
51795: EMPTY
51796: LIST
51797: LIST
51798: PPUSH
51799: CALL_OW 72
51803: ST_TO_ADDR
// if not fac then
51804: LD_VAR 0 6
51808: NOT
51809: IFFALSE 51860
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51811: LD_ADDR_VAR 0 6
51815: PUSH
51816: LD_EXP 101
51820: PUSH
51821: LD_VAR 0 2
51825: ARRAY
51826: PPUSH
51827: LD_INT 2
51829: PUSH
51830: LD_INT 30
51832: PUSH
51833: LD_INT 0
51835: PUSH
51836: EMPTY
51837: LIST
51838: LIST
51839: PUSH
51840: LD_INT 30
51842: PUSH
51843: LD_INT 1
51845: PUSH
51846: EMPTY
51847: LIST
51848: LIST
51849: PUSH
51850: EMPTY
51851: LIST
51852: LIST
51853: LIST
51854: PPUSH
51855: CALL_OW 72
51859: ST_TO_ADDR
// if not fac then
51860: LD_VAR 0 6
51864: NOT
51865: IFFALSE 51869
// continue ;
51867: GO 51717
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51869: LD_ADDR_VAR 0 7
51873: PUSH
51874: LD_EXP 125
51878: PUSH
51879: LD_VAR 0 2
51883: ARRAY
51884: PPUSH
51885: LD_INT 22
51887: PUSH
51888: LD_VAR 0 5
51892: PUSH
51893: EMPTY
51894: LIST
51895: LIST
51896: PUSH
51897: LD_INT 21
51899: PUSH
51900: LD_INT 2
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: PUSH
51907: LD_INT 3
51909: PUSH
51910: LD_INT 24
51912: PUSH
51913: LD_INT 1000
51915: PUSH
51916: EMPTY
51917: LIST
51918: LIST
51919: PUSH
51920: EMPTY
51921: LIST
51922: LIST
51923: PUSH
51924: EMPTY
51925: LIST
51926: LIST
51927: LIST
51928: PPUSH
51929: CALL_OW 70
51933: ST_TO_ADDR
// for j in fac do
51934: LD_ADDR_VAR 0 3
51938: PUSH
51939: LD_VAR 0 6
51943: PUSH
51944: FOR_IN
51945: IFFALSE 52026
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51947: LD_ADDR_VAR 0 7
51951: PUSH
51952: LD_VAR 0 7
51956: PUSH
51957: LD_INT 22
51959: PUSH
51960: LD_VAR 0 5
51964: PUSH
51965: EMPTY
51966: LIST
51967: LIST
51968: PUSH
51969: LD_INT 91
51971: PUSH
51972: LD_VAR 0 3
51976: PUSH
51977: LD_INT 15
51979: PUSH
51980: EMPTY
51981: LIST
51982: LIST
51983: LIST
51984: PUSH
51985: LD_INT 21
51987: PUSH
51988: LD_INT 2
51990: PUSH
51991: EMPTY
51992: LIST
51993: LIST
51994: PUSH
51995: LD_INT 3
51997: PUSH
51998: LD_INT 24
52000: PUSH
52001: LD_INT 1000
52003: PUSH
52004: EMPTY
52005: LIST
52006: LIST
52007: PUSH
52008: EMPTY
52009: LIST
52010: LIST
52011: PUSH
52012: EMPTY
52013: LIST
52014: LIST
52015: LIST
52016: LIST
52017: PPUSH
52018: CALL_OW 69
52022: UNION
52023: ST_TO_ADDR
52024: GO 51944
52026: POP
52027: POP
// if not vehs then
52028: LD_VAR 0 7
52032: NOT
52033: IFFALSE 52059
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52035: LD_ADDR_EXP 113
52039: PUSH
52040: LD_EXP 113
52044: PPUSH
52045: LD_VAR 0 2
52049: PPUSH
52050: EMPTY
52051: PPUSH
52052: CALL_OW 1
52056: ST_TO_ADDR
// continue ;
52057: GO 51717
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52059: LD_ADDR_VAR 0 8
52063: PUSH
52064: LD_EXP 101
52068: PUSH
52069: LD_VAR 0 2
52073: ARRAY
52074: PPUSH
52075: LD_INT 30
52077: PUSH
52078: LD_INT 3
52080: PUSH
52081: EMPTY
52082: LIST
52083: LIST
52084: PPUSH
52085: CALL_OW 72
52089: ST_TO_ADDR
// if tmp then
52090: LD_VAR 0 8
52094: IFFALSE 52197
// begin for j in tmp do
52096: LD_ADDR_VAR 0 3
52100: PUSH
52101: LD_VAR 0 8
52105: PUSH
52106: FOR_IN
52107: IFFALSE 52195
// for k in UnitsInside ( j ) do
52109: LD_ADDR_VAR 0 4
52113: PUSH
52114: LD_VAR 0 3
52118: PPUSH
52119: CALL_OW 313
52123: PUSH
52124: FOR_IN
52125: IFFALSE 52191
// if k then
52127: LD_VAR 0 4
52131: IFFALSE 52189
// if not k in mc_repair_vehicle [ i ] then
52133: LD_VAR 0 4
52137: PUSH
52138: LD_EXP 113
52142: PUSH
52143: LD_VAR 0 2
52147: ARRAY
52148: IN
52149: NOT
52150: IFFALSE 52189
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52152: LD_ADDR_EXP 113
52156: PUSH
52157: LD_EXP 113
52161: PPUSH
52162: LD_VAR 0 2
52166: PPUSH
52167: LD_EXP 113
52171: PUSH
52172: LD_VAR 0 2
52176: ARRAY
52177: PUSH
52178: LD_VAR 0 4
52182: UNION
52183: PPUSH
52184: CALL_OW 1
52188: ST_TO_ADDR
52189: GO 52124
52191: POP
52192: POP
52193: GO 52106
52195: POP
52196: POP
// end ; if not mc_repair_vehicle [ i ] then
52197: LD_EXP 113
52201: PUSH
52202: LD_VAR 0 2
52206: ARRAY
52207: NOT
52208: IFFALSE 52212
// continue ;
52210: GO 51717
// for j in mc_repair_vehicle [ i ] do
52212: LD_ADDR_VAR 0 3
52216: PUSH
52217: LD_EXP 113
52221: PUSH
52222: LD_VAR 0 2
52226: ARRAY
52227: PUSH
52228: FOR_IN
52229: IFFALSE 52395
// begin if GetClass ( j ) <> 3 then
52231: LD_VAR 0 3
52235: PPUSH
52236: CALL_OW 257
52240: PUSH
52241: LD_INT 3
52243: NONEQUAL
52244: IFFALSE 52285
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52246: LD_ADDR_EXP 113
52250: PUSH
52251: LD_EXP 113
52255: PPUSH
52256: LD_VAR 0 2
52260: PPUSH
52261: LD_EXP 113
52265: PUSH
52266: LD_VAR 0 2
52270: ARRAY
52271: PUSH
52272: LD_VAR 0 3
52276: DIFF
52277: PPUSH
52278: CALL_OW 1
52282: ST_TO_ADDR
// continue ;
52283: GO 52228
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52285: LD_VAR 0 3
52289: PPUSH
52290: CALL_OW 311
52294: NOT
52295: PUSH
52296: LD_VAR 0 3
52300: PUSH
52301: LD_EXP 104
52305: PUSH
52306: LD_VAR 0 2
52310: ARRAY
52311: PUSH
52312: LD_INT 1
52314: ARRAY
52315: IN
52316: NOT
52317: AND
52318: PUSH
52319: LD_VAR 0 3
52323: PUSH
52324: LD_EXP 104
52328: PUSH
52329: LD_VAR 0 2
52333: ARRAY
52334: PUSH
52335: LD_INT 2
52337: ARRAY
52338: IN
52339: NOT
52340: AND
52341: IFFALSE 52393
// begin if IsInUnit ( j ) then
52343: LD_VAR 0 3
52347: PPUSH
52348: CALL_OW 310
52352: IFFALSE 52363
// ComExitBuilding ( j ) ;
52354: LD_VAR 0 3
52358: PPUSH
52359: CALL_OW 122
// if not HasTask ( j ) then
52363: LD_VAR 0 3
52367: PPUSH
52368: CALL_OW 314
52372: NOT
52373: IFFALSE 52393
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52375: LD_VAR 0 3
52379: PPUSH
52380: LD_VAR 0 7
52384: PUSH
52385: LD_INT 1
52387: ARRAY
52388: PPUSH
52389: CALL_OW 189
// end ; end ;
52393: GO 52228
52395: POP
52396: POP
// end ;
52397: GO 51717
52399: POP
52400: POP
// end ;
52401: LD_VAR 0 1
52405: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52406: LD_INT 0
52408: PPUSH
52409: PPUSH
52410: PPUSH
52411: PPUSH
52412: PPUSH
52413: PPUSH
52414: PPUSH
52415: PPUSH
52416: PPUSH
52417: PPUSH
52418: PPUSH
// if not mc_bases then
52419: LD_EXP 101
52423: NOT
52424: IFFALSE 52428
// exit ;
52426: GO 53230
// for i = 1 to mc_bases do
52428: LD_ADDR_VAR 0 2
52432: PUSH
52433: DOUBLE
52434: LD_INT 1
52436: DEC
52437: ST_TO_ADDR
52438: LD_EXP 101
52442: PUSH
52443: FOR_TO
52444: IFFALSE 53228
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52446: LD_EXP 129
52450: PUSH
52451: LD_VAR 0 2
52455: ARRAY
52456: NOT
52457: PUSH
52458: LD_EXP 104
52462: PUSH
52463: LD_VAR 0 2
52467: ARRAY
52468: PUSH
52469: LD_INT 1
52471: ARRAY
52472: OR
52473: PUSH
52474: LD_EXP 104
52478: PUSH
52479: LD_VAR 0 2
52483: ARRAY
52484: PUSH
52485: LD_INT 2
52487: ARRAY
52488: OR
52489: PUSH
52490: LD_EXP 127
52494: PUSH
52495: LD_VAR 0 2
52499: ARRAY
52500: PPUSH
52501: LD_INT 1
52503: PPUSH
52504: CALL_OW 325
52508: NOT
52509: OR
52510: PUSH
52511: LD_EXP 124
52515: PUSH
52516: LD_VAR 0 2
52520: ARRAY
52521: OR
52522: IFFALSE 52526
// continue ;
52524: GO 52443
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52526: LD_ADDR_VAR 0 8
52530: PUSH
52531: LD_EXP 101
52535: PUSH
52536: LD_VAR 0 2
52540: ARRAY
52541: PPUSH
52542: LD_INT 25
52544: PUSH
52545: LD_INT 4
52547: PUSH
52548: EMPTY
52549: LIST
52550: LIST
52551: PUSH
52552: LD_INT 50
52554: PUSH
52555: EMPTY
52556: LIST
52557: PUSH
52558: LD_INT 3
52560: PUSH
52561: LD_INT 60
52563: PUSH
52564: EMPTY
52565: LIST
52566: PUSH
52567: EMPTY
52568: LIST
52569: LIST
52570: PUSH
52571: EMPTY
52572: LIST
52573: LIST
52574: LIST
52575: PPUSH
52576: CALL_OW 72
52580: PUSH
52581: LD_EXP 105
52585: PUSH
52586: LD_VAR 0 2
52590: ARRAY
52591: DIFF
52592: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52593: LD_ADDR_VAR 0 9
52597: PUSH
52598: LD_EXP 101
52602: PUSH
52603: LD_VAR 0 2
52607: ARRAY
52608: PPUSH
52609: LD_INT 2
52611: PUSH
52612: LD_INT 30
52614: PUSH
52615: LD_INT 0
52617: PUSH
52618: EMPTY
52619: LIST
52620: LIST
52621: PUSH
52622: LD_INT 30
52624: PUSH
52625: LD_INT 1
52627: PUSH
52628: EMPTY
52629: LIST
52630: LIST
52631: PUSH
52632: EMPTY
52633: LIST
52634: LIST
52635: LIST
52636: PPUSH
52637: CALL_OW 72
52641: ST_TO_ADDR
// if not tmp or not dep then
52642: LD_VAR 0 8
52646: NOT
52647: PUSH
52648: LD_VAR 0 9
52652: NOT
52653: OR
52654: IFFALSE 52658
// continue ;
52656: GO 52443
// side := GetSide ( tmp [ 1 ] ) ;
52658: LD_ADDR_VAR 0 11
52662: PUSH
52663: LD_VAR 0 8
52667: PUSH
52668: LD_INT 1
52670: ARRAY
52671: PPUSH
52672: CALL_OW 255
52676: ST_TO_ADDR
// dep := dep [ 1 ] ;
52677: LD_ADDR_VAR 0 9
52681: PUSH
52682: LD_VAR 0 9
52686: PUSH
52687: LD_INT 1
52689: ARRAY
52690: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52691: LD_ADDR_VAR 0 7
52695: PUSH
52696: LD_EXP 129
52700: PUSH
52701: LD_VAR 0 2
52705: ARRAY
52706: PPUSH
52707: LD_INT 22
52709: PUSH
52710: LD_INT 0
52712: PUSH
52713: EMPTY
52714: LIST
52715: LIST
52716: PUSH
52717: LD_INT 25
52719: PUSH
52720: LD_INT 12
52722: PUSH
52723: EMPTY
52724: LIST
52725: LIST
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: PPUSH
52731: CALL_OW 70
52735: PUSH
52736: LD_INT 22
52738: PUSH
52739: LD_INT 0
52741: PUSH
52742: EMPTY
52743: LIST
52744: LIST
52745: PUSH
52746: LD_INT 25
52748: PUSH
52749: LD_INT 12
52751: PUSH
52752: EMPTY
52753: LIST
52754: LIST
52755: PUSH
52756: LD_INT 91
52758: PUSH
52759: LD_VAR 0 9
52763: PUSH
52764: LD_INT 20
52766: PUSH
52767: EMPTY
52768: LIST
52769: LIST
52770: LIST
52771: PUSH
52772: EMPTY
52773: LIST
52774: LIST
52775: LIST
52776: PPUSH
52777: CALL_OW 69
52781: UNION
52782: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52783: LD_ADDR_VAR 0 10
52787: PUSH
52788: LD_EXP 129
52792: PUSH
52793: LD_VAR 0 2
52797: ARRAY
52798: PPUSH
52799: LD_INT 81
52801: PUSH
52802: LD_VAR 0 11
52806: PUSH
52807: EMPTY
52808: LIST
52809: LIST
52810: PPUSH
52811: CALL_OW 70
52815: ST_TO_ADDR
// if not apes or danger_at_area then
52816: LD_VAR 0 7
52820: NOT
52821: PUSH
52822: LD_VAR 0 10
52826: OR
52827: IFFALSE 52877
// begin if mc_taming [ i ] then
52829: LD_EXP 132
52833: PUSH
52834: LD_VAR 0 2
52838: ARRAY
52839: IFFALSE 52875
// begin MC_Reset ( i , 121 ) ;
52841: LD_VAR 0 2
52845: PPUSH
52846: LD_INT 121
52848: PPUSH
52849: CALL 38312 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52853: LD_ADDR_EXP 132
52857: PUSH
52858: LD_EXP 132
52862: PPUSH
52863: LD_VAR 0 2
52867: PPUSH
52868: EMPTY
52869: PPUSH
52870: CALL_OW 1
52874: ST_TO_ADDR
// end ; continue ;
52875: GO 52443
// end ; for j in tmp do
52877: LD_ADDR_VAR 0 3
52881: PUSH
52882: LD_VAR 0 8
52886: PUSH
52887: FOR_IN
52888: IFFALSE 53224
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52890: LD_VAR 0 3
52894: PUSH
52895: LD_EXP 132
52899: PUSH
52900: LD_VAR 0 2
52904: ARRAY
52905: IN
52906: NOT
52907: PUSH
52908: LD_EXP 132
52912: PUSH
52913: LD_VAR 0 2
52917: ARRAY
52918: PUSH
52919: LD_INT 3
52921: LESS
52922: AND
52923: IFFALSE 52981
// begin SetTag ( j , 121 ) ;
52925: LD_VAR 0 3
52929: PPUSH
52930: LD_INT 121
52932: PPUSH
52933: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52937: LD_ADDR_EXP 132
52941: PUSH
52942: LD_EXP 132
52946: PPUSH
52947: LD_VAR 0 2
52951: PUSH
52952: LD_EXP 132
52956: PUSH
52957: LD_VAR 0 2
52961: ARRAY
52962: PUSH
52963: LD_INT 1
52965: PLUS
52966: PUSH
52967: EMPTY
52968: LIST
52969: LIST
52970: PPUSH
52971: LD_VAR 0 3
52975: PPUSH
52976: CALL 71510 0 3
52980: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52981: LD_VAR 0 3
52985: PUSH
52986: LD_EXP 132
52990: PUSH
52991: LD_VAR 0 2
52995: ARRAY
52996: IN
52997: IFFALSE 53222
// begin if GetClass ( j ) <> 4 then
52999: LD_VAR 0 3
53003: PPUSH
53004: CALL_OW 257
53008: PUSH
53009: LD_INT 4
53011: NONEQUAL
53012: IFFALSE 53065
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53014: LD_ADDR_EXP 132
53018: PUSH
53019: LD_EXP 132
53023: PPUSH
53024: LD_VAR 0 2
53028: PPUSH
53029: LD_EXP 132
53033: PUSH
53034: LD_VAR 0 2
53038: ARRAY
53039: PUSH
53040: LD_VAR 0 3
53044: DIFF
53045: PPUSH
53046: CALL_OW 1
53050: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53051: LD_VAR 0 3
53055: PPUSH
53056: LD_INT 0
53058: PPUSH
53059: CALL_OW 109
// continue ;
53063: GO 52887
// end ; if IsInUnit ( j ) then
53065: LD_VAR 0 3
53069: PPUSH
53070: CALL_OW 310
53074: IFFALSE 53085
// ComExitBuilding ( j ) ;
53076: LD_VAR 0 3
53080: PPUSH
53081: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53085: LD_ADDR_VAR 0 6
53089: PUSH
53090: LD_VAR 0 7
53094: PPUSH
53095: LD_VAR 0 3
53099: PPUSH
53100: CALL_OW 74
53104: ST_TO_ADDR
// if not ape then
53105: LD_VAR 0 6
53109: NOT
53110: IFFALSE 53114
// break ;
53112: GO 53224
// x := GetX ( ape ) ;
53114: LD_ADDR_VAR 0 4
53118: PUSH
53119: LD_VAR 0 6
53123: PPUSH
53124: CALL_OW 250
53128: ST_TO_ADDR
// y := GetY ( ape ) ;
53129: LD_ADDR_VAR 0 5
53133: PUSH
53134: LD_VAR 0 6
53138: PPUSH
53139: CALL_OW 251
53143: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53144: LD_VAR 0 4
53148: PPUSH
53149: LD_VAR 0 5
53153: PPUSH
53154: CALL_OW 488
53158: NOT
53159: PUSH
53160: LD_VAR 0 11
53164: PPUSH
53165: LD_VAR 0 4
53169: PPUSH
53170: LD_VAR 0 5
53174: PPUSH
53175: LD_INT 20
53177: PPUSH
53178: CALL 72406 0 4
53182: PUSH
53183: LD_INT 4
53185: ARRAY
53186: OR
53187: IFFALSE 53191
// break ;
53189: GO 53224
// if not HasTask ( j ) then
53191: LD_VAR 0 3
53195: PPUSH
53196: CALL_OW 314
53200: NOT
53201: IFFALSE 53222
// ComTameXY ( j , x , y ) ;
53203: LD_VAR 0 3
53207: PPUSH
53208: LD_VAR 0 4
53212: PPUSH
53213: LD_VAR 0 5
53217: PPUSH
53218: CALL_OW 131
// end ; end ;
53222: GO 52887
53224: POP
53225: POP
// end ;
53226: GO 52443
53228: POP
53229: POP
// end ;
53230: LD_VAR 0 1
53234: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53235: LD_INT 0
53237: PPUSH
53238: PPUSH
53239: PPUSH
53240: PPUSH
53241: PPUSH
53242: PPUSH
53243: PPUSH
53244: PPUSH
// if not mc_bases then
53245: LD_EXP 101
53249: NOT
53250: IFFALSE 53254
// exit ;
53252: GO 53880
// for i = 1 to mc_bases do
53254: LD_ADDR_VAR 0 2
53258: PUSH
53259: DOUBLE
53260: LD_INT 1
53262: DEC
53263: ST_TO_ADDR
53264: LD_EXP 101
53268: PUSH
53269: FOR_TO
53270: IFFALSE 53878
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53272: LD_EXP 130
53276: PUSH
53277: LD_VAR 0 2
53281: ARRAY
53282: NOT
53283: PUSH
53284: LD_EXP 130
53288: PUSH
53289: LD_VAR 0 2
53293: ARRAY
53294: PPUSH
53295: LD_INT 25
53297: PUSH
53298: LD_INT 12
53300: PUSH
53301: EMPTY
53302: LIST
53303: LIST
53304: PPUSH
53305: CALL_OW 72
53309: NOT
53310: OR
53311: IFFALSE 53315
// continue ;
53313: GO 53269
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53315: LD_ADDR_VAR 0 5
53319: PUSH
53320: LD_EXP 130
53324: PUSH
53325: LD_VAR 0 2
53329: ARRAY
53330: PUSH
53331: LD_INT 1
53333: ARRAY
53334: PPUSH
53335: CALL_OW 255
53339: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53340: LD_VAR 0 5
53344: PPUSH
53345: LD_INT 2
53347: PPUSH
53348: CALL_OW 325
53352: IFFALSE 53605
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53354: LD_ADDR_VAR 0 4
53358: PUSH
53359: LD_EXP 130
53363: PUSH
53364: LD_VAR 0 2
53368: ARRAY
53369: PPUSH
53370: LD_INT 25
53372: PUSH
53373: LD_INT 16
53375: PUSH
53376: EMPTY
53377: LIST
53378: LIST
53379: PPUSH
53380: CALL_OW 72
53384: ST_TO_ADDR
// if tmp < 6 then
53385: LD_VAR 0 4
53389: PUSH
53390: LD_INT 6
53392: LESS
53393: IFFALSE 53605
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53395: LD_ADDR_VAR 0 6
53399: PUSH
53400: LD_EXP 101
53404: PUSH
53405: LD_VAR 0 2
53409: ARRAY
53410: PPUSH
53411: LD_INT 2
53413: PUSH
53414: LD_INT 30
53416: PUSH
53417: LD_INT 0
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: PUSH
53424: LD_INT 30
53426: PUSH
53427: LD_INT 1
53429: PUSH
53430: EMPTY
53431: LIST
53432: LIST
53433: PUSH
53434: EMPTY
53435: LIST
53436: LIST
53437: LIST
53438: PPUSH
53439: CALL_OW 72
53443: ST_TO_ADDR
// if depot then
53444: LD_VAR 0 6
53448: IFFALSE 53605
// begin selected := 0 ;
53450: LD_ADDR_VAR 0 7
53454: PUSH
53455: LD_INT 0
53457: ST_TO_ADDR
// for j in depot do
53458: LD_ADDR_VAR 0 3
53462: PUSH
53463: LD_VAR 0 6
53467: PUSH
53468: FOR_IN
53469: IFFALSE 53500
// begin if UnitsInside ( j ) < 6 then
53471: LD_VAR 0 3
53475: PPUSH
53476: CALL_OW 313
53480: PUSH
53481: LD_INT 6
53483: LESS
53484: IFFALSE 53498
// begin selected := j ;
53486: LD_ADDR_VAR 0 7
53490: PUSH
53491: LD_VAR 0 3
53495: ST_TO_ADDR
// break ;
53496: GO 53500
// end ; end ;
53498: GO 53468
53500: POP
53501: POP
// if selected then
53502: LD_VAR 0 7
53506: IFFALSE 53605
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53508: LD_ADDR_VAR 0 3
53512: PUSH
53513: LD_EXP 130
53517: PUSH
53518: LD_VAR 0 2
53522: ARRAY
53523: PPUSH
53524: LD_INT 25
53526: PUSH
53527: LD_INT 12
53529: PUSH
53530: EMPTY
53531: LIST
53532: LIST
53533: PPUSH
53534: CALL_OW 72
53538: PUSH
53539: FOR_IN
53540: IFFALSE 53603
// if not HasTask ( j ) then
53542: LD_VAR 0 3
53546: PPUSH
53547: CALL_OW 314
53551: NOT
53552: IFFALSE 53601
// begin if not IsInUnit ( j ) then
53554: LD_VAR 0 3
53558: PPUSH
53559: CALL_OW 310
53563: NOT
53564: IFFALSE 53580
// ComEnterUnit ( j , selected ) ;
53566: LD_VAR 0 3
53570: PPUSH
53571: LD_VAR 0 7
53575: PPUSH
53576: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53580: LD_VAR 0 3
53584: PPUSH
53585: LD_INT 16
53587: PPUSH
53588: CALL_OW 183
// AddComExitBuilding ( j ) ;
53592: LD_VAR 0 3
53596: PPUSH
53597: CALL_OW 182
// end ;
53601: GO 53539
53603: POP
53604: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53605: LD_VAR 0 5
53609: PPUSH
53610: LD_INT 11
53612: PPUSH
53613: CALL_OW 325
53617: IFFALSE 53876
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53619: LD_ADDR_VAR 0 4
53623: PUSH
53624: LD_EXP 130
53628: PUSH
53629: LD_VAR 0 2
53633: ARRAY
53634: PPUSH
53635: LD_INT 25
53637: PUSH
53638: LD_INT 16
53640: PUSH
53641: EMPTY
53642: LIST
53643: LIST
53644: PPUSH
53645: CALL_OW 72
53649: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53650: LD_VAR 0 4
53654: PUSH
53655: LD_INT 6
53657: GREATEREQUAL
53658: PUSH
53659: LD_VAR 0 5
53663: PPUSH
53664: LD_INT 2
53666: PPUSH
53667: CALL_OW 325
53671: NOT
53672: OR
53673: IFFALSE 53876
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53675: LD_ADDR_VAR 0 8
53679: PUSH
53680: LD_EXP 101
53684: PUSH
53685: LD_VAR 0 2
53689: ARRAY
53690: PPUSH
53691: LD_INT 2
53693: PUSH
53694: LD_INT 30
53696: PUSH
53697: LD_INT 4
53699: PUSH
53700: EMPTY
53701: LIST
53702: LIST
53703: PUSH
53704: LD_INT 30
53706: PUSH
53707: LD_INT 5
53709: PUSH
53710: EMPTY
53711: LIST
53712: LIST
53713: PUSH
53714: EMPTY
53715: LIST
53716: LIST
53717: LIST
53718: PPUSH
53719: CALL_OW 72
53723: ST_TO_ADDR
// if barracks then
53724: LD_VAR 0 8
53728: IFFALSE 53876
// begin selected := 0 ;
53730: LD_ADDR_VAR 0 7
53734: PUSH
53735: LD_INT 0
53737: ST_TO_ADDR
// for j in barracks do
53738: LD_ADDR_VAR 0 3
53742: PUSH
53743: LD_VAR 0 8
53747: PUSH
53748: FOR_IN
53749: IFFALSE 53780
// begin if UnitsInside ( j ) < 6 then
53751: LD_VAR 0 3
53755: PPUSH
53756: CALL_OW 313
53760: PUSH
53761: LD_INT 6
53763: LESS
53764: IFFALSE 53778
// begin selected := j ;
53766: LD_ADDR_VAR 0 7
53770: PUSH
53771: LD_VAR 0 3
53775: ST_TO_ADDR
// break ;
53776: GO 53780
// end ; end ;
53778: GO 53748
53780: POP
53781: POP
// if selected then
53782: LD_VAR 0 7
53786: IFFALSE 53876
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53788: LD_ADDR_VAR 0 3
53792: PUSH
53793: LD_EXP 130
53797: PUSH
53798: LD_VAR 0 2
53802: ARRAY
53803: PPUSH
53804: LD_INT 25
53806: PUSH
53807: LD_INT 12
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: PPUSH
53814: CALL_OW 72
53818: PUSH
53819: FOR_IN
53820: IFFALSE 53874
// if not IsInUnit ( j ) and not HasTask ( j ) then
53822: LD_VAR 0 3
53826: PPUSH
53827: CALL_OW 310
53831: NOT
53832: PUSH
53833: LD_VAR 0 3
53837: PPUSH
53838: CALL_OW 314
53842: NOT
53843: AND
53844: IFFALSE 53872
// begin ComEnterUnit ( j , selected ) ;
53846: LD_VAR 0 3
53850: PPUSH
53851: LD_VAR 0 7
53855: PPUSH
53856: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53860: LD_VAR 0 3
53864: PPUSH
53865: LD_INT 15
53867: PPUSH
53868: CALL_OW 183
// end ;
53872: GO 53819
53874: POP
53875: POP
// end ; end ; end ; end ; end ;
53876: GO 53269
53878: POP
53879: POP
// end ;
53880: LD_VAR 0 1
53884: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53885: LD_INT 0
53887: PPUSH
53888: PPUSH
53889: PPUSH
53890: PPUSH
// if not mc_bases then
53891: LD_EXP 101
53895: NOT
53896: IFFALSE 53900
// exit ;
53898: GO 54078
// for i = 1 to mc_bases do
53900: LD_ADDR_VAR 0 2
53904: PUSH
53905: DOUBLE
53906: LD_INT 1
53908: DEC
53909: ST_TO_ADDR
53910: LD_EXP 101
53914: PUSH
53915: FOR_TO
53916: IFFALSE 54076
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53918: LD_ADDR_VAR 0 4
53922: PUSH
53923: LD_EXP 101
53927: PUSH
53928: LD_VAR 0 2
53932: ARRAY
53933: PPUSH
53934: LD_INT 25
53936: PUSH
53937: LD_INT 9
53939: PUSH
53940: EMPTY
53941: LIST
53942: LIST
53943: PPUSH
53944: CALL_OW 72
53948: ST_TO_ADDR
// if not tmp then
53949: LD_VAR 0 4
53953: NOT
53954: IFFALSE 53958
// continue ;
53956: GO 53915
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53958: LD_EXP 127
53962: PUSH
53963: LD_VAR 0 2
53967: ARRAY
53968: PPUSH
53969: LD_INT 29
53971: PPUSH
53972: CALL_OW 325
53976: NOT
53977: PUSH
53978: LD_EXP 127
53982: PUSH
53983: LD_VAR 0 2
53987: ARRAY
53988: PPUSH
53989: LD_INT 28
53991: PPUSH
53992: CALL_OW 325
53996: NOT
53997: AND
53998: IFFALSE 54002
// continue ;
54000: GO 53915
// for j in tmp do
54002: LD_ADDR_VAR 0 3
54006: PUSH
54007: LD_VAR 0 4
54011: PUSH
54012: FOR_IN
54013: IFFALSE 54072
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54015: LD_VAR 0 3
54019: PUSH
54020: LD_EXP 104
54024: PUSH
54025: LD_VAR 0 2
54029: ARRAY
54030: PUSH
54031: LD_INT 1
54033: ARRAY
54034: IN
54035: NOT
54036: PUSH
54037: LD_VAR 0 3
54041: PUSH
54042: LD_EXP 104
54046: PUSH
54047: LD_VAR 0 2
54051: ARRAY
54052: PUSH
54053: LD_INT 2
54055: ARRAY
54056: IN
54057: NOT
54058: AND
54059: IFFALSE 54070
// ComSpaceTimeShoot ( j ) ;
54061: LD_VAR 0 3
54065: PPUSH
54066: CALL 65096 0 1
54070: GO 54012
54072: POP
54073: POP
// end ;
54074: GO 53915
54076: POP
54077: POP
// end ;
54078: LD_VAR 0 1
54082: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54083: LD_INT 0
54085: PPUSH
54086: PPUSH
54087: PPUSH
54088: PPUSH
54089: PPUSH
54090: PPUSH
54091: PPUSH
54092: PPUSH
54093: PPUSH
// if not mc_bases then
54094: LD_EXP 101
54098: NOT
54099: IFFALSE 54103
// exit ;
54101: GO 54725
// for i = 1 to mc_bases do
54103: LD_ADDR_VAR 0 2
54107: PUSH
54108: DOUBLE
54109: LD_INT 1
54111: DEC
54112: ST_TO_ADDR
54113: LD_EXP 101
54117: PUSH
54118: FOR_TO
54119: IFFALSE 54723
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54121: LD_EXP 136
54125: PUSH
54126: LD_VAR 0 2
54130: ARRAY
54131: NOT
54132: PUSH
54133: LD_INT 38
54135: PPUSH
54136: LD_EXP 127
54140: PUSH
54141: LD_VAR 0 2
54145: ARRAY
54146: PPUSH
54147: CALL_OW 321
54151: PUSH
54152: LD_INT 2
54154: NONEQUAL
54155: OR
54156: IFFALSE 54160
// continue ;
54158: GO 54118
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54160: LD_ADDR_VAR 0 8
54164: PUSH
54165: LD_EXP 101
54169: PUSH
54170: LD_VAR 0 2
54174: ARRAY
54175: PPUSH
54176: LD_INT 30
54178: PUSH
54179: LD_INT 34
54181: PUSH
54182: EMPTY
54183: LIST
54184: LIST
54185: PPUSH
54186: CALL_OW 72
54190: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54191: LD_ADDR_VAR 0 9
54195: PUSH
54196: LD_EXP 101
54200: PUSH
54201: LD_VAR 0 2
54205: ARRAY
54206: PPUSH
54207: LD_INT 25
54209: PUSH
54210: LD_INT 4
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: PPUSH
54217: CALL_OW 72
54221: PPUSH
54222: LD_INT 0
54224: PPUSH
54225: CALL 104773 0 2
54229: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54230: LD_VAR 0 9
54234: NOT
54235: PUSH
54236: LD_VAR 0 8
54240: NOT
54241: OR
54242: PUSH
54243: LD_EXP 101
54247: PUSH
54248: LD_VAR 0 2
54252: ARRAY
54253: PPUSH
54254: LD_INT 124
54256: PPUSH
54257: CALL 104773 0 2
54261: OR
54262: IFFALSE 54266
// continue ;
54264: GO 54118
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54266: LD_EXP 137
54270: PUSH
54271: LD_VAR 0 2
54275: ARRAY
54276: PUSH
54277: LD_EXP 136
54281: PUSH
54282: LD_VAR 0 2
54286: ARRAY
54287: LESS
54288: PUSH
54289: LD_EXP 137
54293: PUSH
54294: LD_VAR 0 2
54298: ARRAY
54299: PUSH
54300: LD_VAR 0 8
54304: LESS
54305: AND
54306: IFFALSE 54721
// begin tmp := sci [ 1 ] ;
54308: LD_ADDR_VAR 0 7
54312: PUSH
54313: LD_VAR 0 9
54317: PUSH
54318: LD_INT 1
54320: ARRAY
54321: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54322: LD_VAR 0 7
54326: PPUSH
54327: LD_INT 124
54329: PPUSH
54330: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54334: LD_ADDR_VAR 0 3
54338: PUSH
54339: DOUBLE
54340: LD_EXP 136
54344: PUSH
54345: LD_VAR 0 2
54349: ARRAY
54350: INC
54351: ST_TO_ADDR
54352: LD_EXP 136
54356: PUSH
54357: LD_VAR 0 2
54361: ARRAY
54362: PUSH
54363: FOR_DOWNTO
54364: IFFALSE 54707
// begin if IsInUnit ( tmp ) then
54366: LD_VAR 0 7
54370: PPUSH
54371: CALL_OW 310
54375: IFFALSE 54386
// ComExitBuilding ( tmp ) ;
54377: LD_VAR 0 7
54381: PPUSH
54382: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54386: LD_INT 35
54388: PPUSH
54389: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54393: LD_VAR 0 7
54397: PPUSH
54398: CALL_OW 310
54402: NOT
54403: PUSH
54404: LD_VAR 0 7
54408: PPUSH
54409: CALL_OW 314
54413: NOT
54414: AND
54415: IFFALSE 54386
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54417: LD_ADDR_VAR 0 6
54421: PUSH
54422: LD_VAR 0 7
54426: PPUSH
54427: CALL_OW 250
54431: PUSH
54432: LD_VAR 0 7
54436: PPUSH
54437: CALL_OW 251
54441: PUSH
54442: EMPTY
54443: LIST
54444: LIST
54445: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54446: LD_INT 35
54448: PPUSH
54449: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54453: LD_ADDR_VAR 0 4
54457: PUSH
54458: LD_EXP 136
54462: PUSH
54463: LD_VAR 0 2
54467: ARRAY
54468: PUSH
54469: LD_VAR 0 3
54473: ARRAY
54474: PUSH
54475: LD_INT 1
54477: ARRAY
54478: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54479: LD_ADDR_VAR 0 5
54483: PUSH
54484: LD_EXP 136
54488: PUSH
54489: LD_VAR 0 2
54493: ARRAY
54494: PUSH
54495: LD_VAR 0 3
54499: ARRAY
54500: PUSH
54501: LD_INT 2
54503: ARRAY
54504: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54505: LD_VAR 0 7
54509: PPUSH
54510: LD_INT 10
54512: PPUSH
54513: CALL 74103 0 2
54517: PUSH
54518: LD_INT 4
54520: ARRAY
54521: IFFALSE 54559
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54523: LD_VAR 0 7
54527: PPUSH
54528: LD_VAR 0 6
54532: PUSH
54533: LD_INT 1
54535: ARRAY
54536: PPUSH
54537: LD_VAR 0 6
54541: PUSH
54542: LD_INT 2
54544: ARRAY
54545: PPUSH
54546: CALL_OW 111
// wait ( 0 0$10 ) ;
54550: LD_INT 350
54552: PPUSH
54553: CALL_OW 67
// end else
54557: GO 54585
// begin ComMoveXY ( tmp , x , y ) ;
54559: LD_VAR 0 7
54563: PPUSH
54564: LD_VAR 0 4
54568: PPUSH
54569: LD_VAR 0 5
54573: PPUSH
54574: CALL_OW 111
// wait ( 0 0$3 ) ;
54578: LD_INT 105
54580: PPUSH
54581: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54585: LD_VAR 0 7
54589: PPUSH
54590: LD_VAR 0 4
54594: PPUSH
54595: LD_VAR 0 5
54599: PPUSH
54600: CALL_OW 307
54604: IFFALSE 54446
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54606: LD_VAR 0 7
54610: PPUSH
54611: LD_VAR 0 4
54615: PPUSH
54616: LD_VAR 0 5
54620: PPUSH
54621: LD_VAR 0 8
54625: PUSH
54626: LD_VAR 0 3
54630: ARRAY
54631: PPUSH
54632: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54636: LD_INT 35
54638: PPUSH
54639: CALL_OW 67
// until not HasTask ( tmp ) ;
54643: LD_VAR 0 7
54647: PPUSH
54648: CALL_OW 314
54652: NOT
54653: IFFALSE 54636
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54655: LD_ADDR_EXP 137
54659: PUSH
54660: LD_EXP 137
54664: PPUSH
54665: LD_VAR 0 2
54669: PUSH
54670: LD_EXP 137
54674: PUSH
54675: LD_VAR 0 2
54679: ARRAY
54680: PUSH
54681: LD_INT 1
54683: PLUS
54684: PUSH
54685: EMPTY
54686: LIST
54687: LIST
54688: PPUSH
54689: LD_VAR 0 8
54693: PUSH
54694: LD_VAR 0 3
54698: ARRAY
54699: PPUSH
54700: CALL 71510 0 3
54704: ST_TO_ADDR
// end ;
54705: GO 54363
54707: POP
54708: POP
// MC_Reset ( i , 124 ) ;
54709: LD_VAR 0 2
54713: PPUSH
54714: LD_INT 124
54716: PPUSH
54717: CALL 38312 0 2
// end ; end ;
54721: GO 54118
54723: POP
54724: POP
// end ;
54725: LD_VAR 0 1
54729: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54730: LD_INT 0
54732: PPUSH
54733: PPUSH
54734: PPUSH
// if not mc_bases then
54735: LD_EXP 101
54739: NOT
54740: IFFALSE 54744
// exit ;
54742: GO 55350
// for i = 1 to mc_bases do
54744: LD_ADDR_VAR 0 2
54748: PUSH
54749: DOUBLE
54750: LD_INT 1
54752: DEC
54753: ST_TO_ADDR
54754: LD_EXP 101
54758: PUSH
54759: FOR_TO
54760: IFFALSE 55348
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54762: LD_ADDR_VAR 0 3
54766: PUSH
54767: LD_EXP 101
54771: PUSH
54772: LD_VAR 0 2
54776: ARRAY
54777: PPUSH
54778: LD_INT 25
54780: PUSH
54781: LD_INT 4
54783: PUSH
54784: EMPTY
54785: LIST
54786: LIST
54787: PPUSH
54788: CALL_OW 72
54792: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54793: LD_VAR 0 3
54797: NOT
54798: PUSH
54799: LD_EXP 138
54803: PUSH
54804: LD_VAR 0 2
54808: ARRAY
54809: NOT
54810: OR
54811: PUSH
54812: LD_EXP 101
54816: PUSH
54817: LD_VAR 0 2
54821: ARRAY
54822: PPUSH
54823: LD_INT 2
54825: PUSH
54826: LD_INT 30
54828: PUSH
54829: LD_INT 0
54831: PUSH
54832: EMPTY
54833: LIST
54834: LIST
54835: PUSH
54836: LD_INT 30
54838: PUSH
54839: LD_INT 1
54841: PUSH
54842: EMPTY
54843: LIST
54844: LIST
54845: PUSH
54846: EMPTY
54847: LIST
54848: LIST
54849: LIST
54850: PPUSH
54851: CALL_OW 72
54855: NOT
54856: OR
54857: IFFALSE 54907
// begin if mc_deposits_finder [ i ] then
54859: LD_EXP 139
54863: PUSH
54864: LD_VAR 0 2
54868: ARRAY
54869: IFFALSE 54905
// begin MC_Reset ( i , 125 ) ;
54871: LD_VAR 0 2
54875: PPUSH
54876: LD_INT 125
54878: PPUSH
54879: CALL 38312 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54883: LD_ADDR_EXP 139
54887: PUSH
54888: LD_EXP 139
54892: PPUSH
54893: LD_VAR 0 2
54897: PPUSH
54898: EMPTY
54899: PPUSH
54900: CALL_OW 1
54904: ST_TO_ADDR
// end ; continue ;
54905: GO 54759
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54907: LD_EXP 138
54911: PUSH
54912: LD_VAR 0 2
54916: ARRAY
54917: PUSH
54918: LD_INT 1
54920: ARRAY
54921: PUSH
54922: LD_INT 3
54924: ARRAY
54925: PUSH
54926: LD_INT 1
54928: EQUAL
54929: PUSH
54930: LD_INT 20
54932: PPUSH
54933: LD_EXP 127
54937: PUSH
54938: LD_VAR 0 2
54942: ARRAY
54943: PPUSH
54944: CALL_OW 321
54948: PUSH
54949: LD_INT 2
54951: NONEQUAL
54952: AND
54953: IFFALSE 55003
// begin if mc_deposits_finder [ i ] then
54955: LD_EXP 139
54959: PUSH
54960: LD_VAR 0 2
54964: ARRAY
54965: IFFALSE 55001
// begin MC_Reset ( i , 125 ) ;
54967: LD_VAR 0 2
54971: PPUSH
54972: LD_INT 125
54974: PPUSH
54975: CALL 38312 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54979: LD_ADDR_EXP 139
54983: PUSH
54984: LD_EXP 139
54988: PPUSH
54989: LD_VAR 0 2
54993: PPUSH
54994: EMPTY
54995: PPUSH
54996: CALL_OW 1
55000: ST_TO_ADDR
// end ; continue ;
55001: GO 54759
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55003: LD_EXP 138
55007: PUSH
55008: LD_VAR 0 2
55012: ARRAY
55013: PUSH
55014: LD_INT 1
55016: ARRAY
55017: PUSH
55018: LD_INT 1
55020: ARRAY
55021: PPUSH
55022: LD_EXP 138
55026: PUSH
55027: LD_VAR 0 2
55031: ARRAY
55032: PUSH
55033: LD_INT 1
55035: ARRAY
55036: PUSH
55037: LD_INT 2
55039: ARRAY
55040: PPUSH
55041: LD_EXP 127
55045: PUSH
55046: LD_VAR 0 2
55050: ARRAY
55051: PPUSH
55052: CALL_OW 440
55056: IFFALSE 55099
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55058: LD_ADDR_EXP 138
55062: PUSH
55063: LD_EXP 138
55067: PPUSH
55068: LD_VAR 0 2
55072: PPUSH
55073: LD_EXP 138
55077: PUSH
55078: LD_VAR 0 2
55082: ARRAY
55083: PPUSH
55084: LD_INT 1
55086: PPUSH
55087: CALL_OW 3
55091: PPUSH
55092: CALL_OW 1
55096: ST_TO_ADDR
55097: GO 55346
// begin if not mc_deposits_finder [ i ] then
55099: LD_EXP 139
55103: PUSH
55104: LD_VAR 0 2
55108: ARRAY
55109: NOT
55110: IFFALSE 55162
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55112: LD_ADDR_EXP 139
55116: PUSH
55117: LD_EXP 139
55121: PPUSH
55122: LD_VAR 0 2
55126: PPUSH
55127: LD_VAR 0 3
55131: PUSH
55132: LD_INT 1
55134: ARRAY
55135: PUSH
55136: EMPTY
55137: LIST
55138: PPUSH
55139: CALL_OW 1
55143: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55144: LD_VAR 0 3
55148: PUSH
55149: LD_INT 1
55151: ARRAY
55152: PPUSH
55153: LD_INT 125
55155: PPUSH
55156: CALL_OW 109
// end else
55160: GO 55346
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55162: LD_EXP 139
55166: PUSH
55167: LD_VAR 0 2
55171: ARRAY
55172: PUSH
55173: LD_INT 1
55175: ARRAY
55176: PPUSH
55177: CALL_OW 310
55181: IFFALSE 55204
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55183: LD_EXP 139
55187: PUSH
55188: LD_VAR 0 2
55192: ARRAY
55193: PUSH
55194: LD_INT 1
55196: ARRAY
55197: PPUSH
55198: CALL_OW 122
55202: GO 55346
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55204: LD_EXP 139
55208: PUSH
55209: LD_VAR 0 2
55213: ARRAY
55214: PUSH
55215: LD_INT 1
55217: ARRAY
55218: PPUSH
55219: CALL_OW 314
55223: NOT
55224: PUSH
55225: LD_EXP 139
55229: PUSH
55230: LD_VAR 0 2
55234: ARRAY
55235: PUSH
55236: LD_INT 1
55238: ARRAY
55239: PPUSH
55240: LD_EXP 138
55244: PUSH
55245: LD_VAR 0 2
55249: ARRAY
55250: PUSH
55251: LD_INT 1
55253: ARRAY
55254: PUSH
55255: LD_INT 1
55257: ARRAY
55258: PPUSH
55259: LD_EXP 138
55263: PUSH
55264: LD_VAR 0 2
55268: ARRAY
55269: PUSH
55270: LD_INT 1
55272: ARRAY
55273: PUSH
55274: LD_INT 2
55276: ARRAY
55277: PPUSH
55278: CALL_OW 297
55282: PUSH
55283: LD_INT 6
55285: GREATER
55286: AND
55287: IFFALSE 55346
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55289: LD_EXP 139
55293: PUSH
55294: LD_VAR 0 2
55298: ARRAY
55299: PUSH
55300: LD_INT 1
55302: ARRAY
55303: PPUSH
55304: LD_EXP 138
55308: PUSH
55309: LD_VAR 0 2
55313: ARRAY
55314: PUSH
55315: LD_INT 1
55317: ARRAY
55318: PUSH
55319: LD_INT 1
55321: ARRAY
55322: PPUSH
55323: LD_EXP 138
55327: PUSH
55328: LD_VAR 0 2
55332: ARRAY
55333: PUSH
55334: LD_INT 1
55336: ARRAY
55337: PUSH
55338: LD_INT 2
55340: ARRAY
55341: PPUSH
55342: CALL_OW 111
// end ; end ; end ;
55346: GO 54759
55348: POP
55349: POP
// end ;
55350: LD_VAR 0 1
55354: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55355: LD_INT 0
55357: PPUSH
55358: PPUSH
55359: PPUSH
55360: PPUSH
55361: PPUSH
55362: PPUSH
55363: PPUSH
55364: PPUSH
55365: PPUSH
55366: PPUSH
55367: PPUSH
// if not mc_bases then
55368: LD_EXP 101
55372: NOT
55373: IFFALSE 55377
// exit ;
55375: GO 56317
// for i = 1 to mc_bases do
55377: LD_ADDR_VAR 0 2
55381: PUSH
55382: DOUBLE
55383: LD_INT 1
55385: DEC
55386: ST_TO_ADDR
55387: LD_EXP 101
55391: PUSH
55392: FOR_TO
55393: IFFALSE 56315
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55395: LD_EXP 101
55399: PUSH
55400: LD_VAR 0 2
55404: ARRAY
55405: NOT
55406: PUSH
55407: LD_EXP 124
55411: PUSH
55412: LD_VAR 0 2
55416: ARRAY
55417: OR
55418: IFFALSE 55422
// continue ;
55420: GO 55392
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55422: LD_ADDR_VAR 0 7
55426: PUSH
55427: LD_EXP 101
55431: PUSH
55432: LD_VAR 0 2
55436: ARRAY
55437: PUSH
55438: LD_INT 1
55440: ARRAY
55441: PPUSH
55442: CALL_OW 248
55446: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55447: LD_VAR 0 7
55451: PUSH
55452: LD_INT 3
55454: EQUAL
55455: PUSH
55456: LD_EXP 120
55460: PUSH
55461: LD_VAR 0 2
55465: ARRAY
55466: PUSH
55467: LD_EXP 123
55471: PUSH
55472: LD_VAR 0 2
55476: ARRAY
55477: UNION
55478: PPUSH
55479: LD_INT 33
55481: PUSH
55482: LD_INT 2
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: PPUSH
55489: CALL_OW 72
55493: NOT
55494: OR
55495: IFFALSE 55499
// continue ;
55497: GO 55392
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55499: LD_ADDR_VAR 0 9
55503: PUSH
55504: LD_EXP 101
55508: PUSH
55509: LD_VAR 0 2
55513: ARRAY
55514: PPUSH
55515: LD_INT 30
55517: PUSH
55518: LD_INT 36
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: PPUSH
55525: CALL_OW 72
55529: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55530: LD_ADDR_VAR 0 10
55534: PUSH
55535: LD_EXP 120
55539: PUSH
55540: LD_VAR 0 2
55544: ARRAY
55545: PPUSH
55546: LD_INT 34
55548: PUSH
55549: LD_INT 31
55551: PUSH
55552: EMPTY
55553: LIST
55554: LIST
55555: PPUSH
55556: CALL_OW 72
55560: ST_TO_ADDR
// if not cts and not mcts then
55561: LD_VAR 0 9
55565: NOT
55566: PUSH
55567: LD_VAR 0 10
55571: NOT
55572: AND
55573: IFFALSE 55577
// continue ;
55575: GO 55392
// x := cts ;
55577: LD_ADDR_VAR 0 11
55581: PUSH
55582: LD_VAR 0 9
55586: ST_TO_ADDR
// if not x then
55587: LD_VAR 0 11
55591: NOT
55592: IFFALSE 55604
// x := mcts ;
55594: LD_ADDR_VAR 0 11
55598: PUSH
55599: LD_VAR 0 10
55603: ST_TO_ADDR
// if not x then
55604: LD_VAR 0 11
55608: NOT
55609: IFFALSE 55613
// continue ;
55611: GO 55392
// if mc_remote_driver [ i ] then
55613: LD_EXP 141
55617: PUSH
55618: LD_VAR 0 2
55622: ARRAY
55623: IFFALSE 56010
// for j in mc_remote_driver [ i ] do
55625: LD_ADDR_VAR 0 3
55629: PUSH
55630: LD_EXP 141
55634: PUSH
55635: LD_VAR 0 2
55639: ARRAY
55640: PUSH
55641: FOR_IN
55642: IFFALSE 56008
// begin if GetClass ( j ) <> 3 then
55644: LD_VAR 0 3
55648: PPUSH
55649: CALL_OW 257
55653: PUSH
55654: LD_INT 3
55656: NONEQUAL
55657: IFFALSE 55710
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55659: LD_ADDR_EXP 141
55663: PUSH
55664: LD_EXP 141
55668: PPUSH
55669: LD_VAR 0 2
55673: PPUSH
55674: LD_EXP 141
55678: PUSH
55679: LD_VAR 0 2
55683: ARRAY
55684: PUSH
55685: LD_VAR 0 3
55689: DIFF
55690: PPUSH
55691: CALL_OW 1
55695: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55696: LD_VAR 0 3
55700: PPUSH
55701: LD_INT 0
55703: PPUSH
55704: CALL_OW 109
// continue ;
55708: GO 55641
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55710: LD_EXP 120
55714: PUSH
55715: LD_VAR 0 2
55719: ARRAY
55720: PPUSH
55721: LD_INT 34
55723: PUSH
55724: LD_INT 31
55726: PUSH
55727: EMPTY
55728: LIST
55729: LIST
55730: PUSH
55731: LD_INT 58
55733: PUSH
55734: EMPTY
55735: LIST
55736: PUSH
55737: EMPTY
55738: LIST
55739: LIST
55740: PPUSH
55741: CALL_OW 72
55745: PUSH
55746: LD_VAR 0 3
55750: PPUSH
55751: CALL 104861 0 1
55755: NOT
55756: AND
55757: IFFALSE 55828
// begin if IsInUnit ( j ) then
55759: LD_VAR 0 3
55763: PPUSH
55764: CALL_OW 310
55768: IFFALSE 55779
// ComExitBuilding ( j ) ;
55770: LD_VAR 0 3
55774: PPUSH
55775: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55779: LD_VAR 0 3
55783: PPUSH
55784: LD_EXP 120
55788: PUSH
55789: LD_VAR 0 2
55793: ARRAY
55794: PPUSH
55795: LD_INT 34
55797: PUSH
55798: LD_INT 31
55800: PUSH
55801: EMPTY
55802: LIST
55803: LIST
55804: PUSH
55805: LD_INT 58
55807: PUSH
55808: EMPTY
55809: LIST
55810: PUSH
55811: EMPTY
55812: LIST
55813: LIST
55814: PPUSH
55815: CALL_OW 72
55819: PUSH
55820: LD_INT 1
55822: ARRAY
55823: PPUSH
55824: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55828: LD_VAR 0 3
55832: PPUSH
55833: CALL_OW 310
55837: NOT
55838: PUSH
55839: LD_VAR 0 3
55843: PPUSH
55844: CALL_OW 310
55848: PPUSH
55849: CALL_OW 266
55853: PUSH
55854: LD_INT 36
55856: NONEQUAL
55857: PUSH
55858: LD_VAR 0 3
55862: PPUSH
55863: CALL 104861 0 1
55867: NOT
55868: AND
55869: OR
55870: IFFALSE 56006
// begin if IsInUnit ( j ) then
55872: LD_VAR 0 3
55876: PPUSH
55877: CALL_OW 310
55881: IFFALSE 55892
// ComExitBuilding ( j ) ;
55883: LD_VAR 0 3
55887: PPUSH
55888: CALL_OW 122
// ct := 0 ;
55892: LD_ADDR_VAR 0 8
55896: PUSH
55897: LD_INT 0
55899: ST_TO_ADDR
// for k in x do
55900: LD_ADDR_VAR 0 4
55904: PUSH
55905: LD_VAR 0 11
55909: PUSH
55910: FOR_IN
55911: IFFALSE 55984
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55913: LD_VAR 0 4
55917: PPUSH
55918: CALL_OW 264
55922: PUSH
55923: LD_INT 31
55925: EQUAL
55926: PUSH
55927: LD_VAR 0 4
55931: PPUSH
55932: CALL_OW 311
55936: NOT
55937: AND
55938: PUSH
55939: LD_VAR 0 4
55943: PPUSH
55944: CALL_OW 266
55948: PUSH
55949: LD_INT 36
55951: EQUAL
55952: PUSH
55953: LD_VAR 0 4
55957: PPUSH
55958: CALL_OW 313
55962: PUSH
55963: LD_INT 3
55965: LESS
55966: AND
55967: OR
55968: IFFALSE 55982
// begin ct := k ;
55970: LD_ADDR_VAR 0 8
55974: PUSH
55975: LD_VAR 0 4
55979: ST_TO_ADDR
// break ;
55980: GO 55984
// end ;
55982: GO 55910
55984: POP
55985: POP
// if ct then
55986: LD_VAR 0 8
55990: IFFALSE 56006
// ComEnterUnit ( j , ct ) ;
55992: LD_VAR 0 3
55996: PPUSH
55997: LD_VAR 0 8
56001: PPUSH
56002: CALL_OW 120
// end ; end ;
56006: GO 55641
56008: POP
56009: POP
// places := 0 ;
56010: LD_ADDR_VAR 0 5
56014: PUSH
56015: LD_INT 0
56017: ST_TO_ADDR
// for j = 1 to x do
56018: LD_ADDR_VAR 0 3
56022: PUSH
56023: DOUBLE
56024: LD_INT 1
56026: DEC
56027: ST_TO_ADDR
56028: LD_VAR 0 11
56032: PUSH
56033: FOR_TO
56034: IFFALSE 56110
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56036: LD_VAR 0 11
56040: PUSH
56041: LD_VAR 0 3
56045: ARRAY
56046: PPUSH
56047: CALL_OW 264
56051: PUSH
56052: LD_INT 31
56054: EQUAL
56055: IFFALSE 56073
// places := places + 1 else
56057: LD_ADDR_VAR 0 5
56061: PUSH
56062: LD_VAR 0 5
56066: PUSH
56067: LD_INT 1
56069: PLUS
56070: ST_TO_ADDR
56071: GO 56108
// if GetBType ( x [ j ] ) = b_control_tower then
56073: LD_VAR 0 11
56077: PUSH
56078: LD_VAR 0 3
56082: ARRAY
56083: PPUSH
56084: CALL_OW 266
56088: PUSH
56089: LD_INT 36
56091: EQUAL
56092: IFFALSE 56108
// places := places + 3 ;
56094: LD_ADDR_VAR 0 5
56098: PUSH
56099: LD_VAR 0 5
56103: PUSH
56104: LD_INT 3
56106: PLUS
56107: ST_TO_ADDR
56108: GO 56033
56110: POP
56111: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56112: LD_VAR 0 5
56116: PUSH
56117: LD_INT 0
56119: EQUAL
56120: PUSH
56121: LD_VAR 0 5
56125: PUSH
56126: LD_EXP 141
56130: PUSH
56131: LD_VAR 0 2
56135: ARRAY
56136: LESSEQUAL
56137: OR
56138: IFFALSE 56142
// continue ;
56140: GO 55392
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56142: LD_ADDR_VAR 0 6
56146: PUSH
56147: LD_EXP 101
56151: PUSH
56152: LD_VAR 0 2
56156: ARRAY
56157: PPUSH
56158: LD_INT 25
56160: PUSH
56161: LD_INT 3
56163: PUSH
56164: EMPTY
56165: LIST
56166: LIST
56167: PPUSH
56168: CALL_OW 72
56172: PUSH
56173: LD_EXP 141
56177: PUSH
56178: LD_VAR 0 2
56182: ARRAY
56183: DIFF
56184: PPUSH
56185: LD_INT 3
56187: PPUSH
56188: CALL 105761 0 2
56192: ST_TO_ADDR
// for j in tmp do
56193: LD_ADDR_VAR 0 3
56197: PUSH
56198: LD_VAR 0 6
56202: PUSH
56203: FOR_IN
56204: IFFALSE 56239
// if GetTag ( j ) > 0 then
56206: LD_VAR 0 3
56210: PPUSH
56211: CALL_OW 110
56215: PUSH
56216: LD_INT 0
56218: GREATER
56219: IFFALSE 56237
// tmp := tmp diff j ;
56221: LD_ADDR_VAR 0 6
56225: PUSH
56226: LD_VAR 0 6
56230: PUSH
56231: LD_VAR 0 3
56235: DIFF
56236: ST_TO_ADDR
56237: GO 56203
56239: POP
56240: POP
// if not tmp then
56241: LD_VAR 0 6
56245: NOT
56246: IFFALSE 56250
// continue ;
56248: GO 55392
// if places then
56250: LD_VAR 0 5
56254: IFFALSE 56313
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56256: LD_ADDR_EXP 141
56260: PUSH
56261: LD_EXP 141
56265: PPUSH
56266: LD_VAR 0 2
56270: PPUSH
56271: LD_EXP 141
56275: PUSH
56276: LD_VAR 0 2
56280: ARRAY
56281: PUSH
56282: LD_VAR 0 6
56286: PUSH
56287: LD_INT 1
56289: ARRAY
56290: UNION
56291: PPUSH
56292: CALL_OW 1
56296: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56297: LD_VAR 0 6
56301: PUSH
56302: LD_INT 1
56304: ARRAY
56305: PPUSH
56306: LD_INT 126
56308: PPUSH
56309: CALL_OW 109
// end ; end ;
56313: GO 55392
56315: POP
56316: POP
// end ;
56317: LD_VAR 0 1
56321: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56322: LD_INT 0
56324: PPUSH
56325: PPUSH
56326: PPUSH
56327: PPUSH
56328: PPUSH
56329: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56330: LD_VAR 0 1
56334: NOT
56335: PUSH
56336: LD_VAR 0 2
56340: NOT
56341: OR
56342: PUSH
56343: LD_VAR 0 3
56347: NOT
56348: OR
56349: PUSH
56350: LD_VAR 0 4
56354: PUSH
56355: LD_INT 1
56357: PUSH
56358: LD_INT 2
56360: PUSH
56361: LD_INT 3
56363: PUSH
56364: LD_INT 4
56366: PUSH
56367: LD_INT 5
56369: PUSH
56370: LD_INT 8
56372: PUSH
56373: LD_INT 9
56375: PUSH
56376: LD_INT 15
56378: PUSH
56379: LD_INT 16
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: LIST
56386: LIST
56387: LIST
56388: LIST
56389: LIST
56390: LIST
56391: LIST
56392: IN
56393: NOT
56394: OR
56395: IFFALSE 56399
// exit ;
56397: GO 57299
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56399: LD_ADDR_VAR 0 2
56403: PUSH
56404: LD_VAR 0 2
56408: PPUSH
56409: LD_INT 21
56411: PUSH
56412: LD_INT 3
56414: PUSH
56415: EMPTY
56416: LIST
56417: LIST
56418: PUSH
56419: LD_INT 24
56421: PUSH
56422: LD_INT 250
56424: PUSH
56425: EMPTY
56426: LIST
56427: LIST
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: PPUSH
56433: CALL_OW 72
56437: ST_TO_ADDR
// case class of 1 , 15 :
56438: LD_VAR 0 4
56442: PUSH
56443: LD_INT 1
56445: DOUBLE
56446: EQUAL
56447: IFTRUE 56457
56449: LD_INT 15
56451: DOUBLE
56452: EQUAL
56453: IFTRUE 56457
56455: GO 56542
56457: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56458: LD_ADDR_VAR 0 8
56462: PUSH
56463: LD_VAR 0 2
56467: PPUSH
56468: LD_INT 2
56470: PUSH
56471: LD_INT 30
56473: PUSH
56474: LD_INT 32
56476: PUSH
56477: EMPTY
56478: LIST
56479: LIST
56480: PUSH
56481: LD_INT 30
56483: PUSH
56484: LD_INT 31
56486: PUSH
56487: EMPTY
56488: LIST
56489: LIST
56490: PUSH
56491: EMPTY
56492: LIST
56493: LIST
56494: LIST
56495: PPUSH
56496: CALL_OW 72
56500: PUSH
56501: LD_VAR 0 2
56505: PPUSH
56506: LD_INT 2
56508: PUSH
56509: LD_INT 30
56511: PUSH
56512: LD_INT 4
56514: PUSH
56515: EMPTY
56516: LIST
56517: LIST
56518: PUSH
56519: LD_INT 30
56521: PUSH
56522: LD_INT 5
56524: PUSH
56525: EMPTY
56526: LIST
56527: LIST
56528: PUSH
56529: EMPTY
56530: LIST
56531: LIST
56532: LIST
56533: PPUSH
56534: CALL_OW 72
56538: ADD
56539: ST_TO_ADDR
56540: GO 56788
56542: LD_INT 2
56544: DOUBLE
56545: EQUAL
56546: IFTRUE 56556
56548: LD_INT 16
56550: DOUBLE
56551: EQUAL
56552: IFTRUE 56556
56554: GO 56602
56556: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56557: LD_ADDR_VAR 0 8
56561: PUSH
56562: LD_VAR 0 2
56566: PPUSH
56567: LD_INT 2
56569: PUSH
56570: LD_INT 30
56572: PUSH
56573: LD_INT 0
56575: PUSH
56576: EMPTY
56577: LIST
56578: LIST
56579: PUSH
56580: LD_INT 30
56582: PUSH
56583: LD_INT 1
56585: PUSH
56586: EMPTY
56587: LIST
56588: LIST
56589: PUSH
56590: EMPTY
56591: LIST
56592: LIST
56593: LIST
56594: PPUSH
56595: CALL_OW 72
56599: ST_TO_ADDR
56600: GO 56788
56602: LD_INT 3
56604: DOUBLE
56605: EQUAL
56606: IFTRUE 56610
56608: GO 56656
56610: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56611: LD_ADDR_VAR 0 8
56615: PUSH
56616: LD_VAR 0 2
56620: PPUSH
56621: LD_INT 2
56623: PUSH
56624: LD_INT 30
56626: PUSH
56627: LD_INT 2
56629: PUSH
56630: EMPTY
56631: LIST
56632: LIST
56633: PUSH
56634: LD_INT 30
56636: PUSH
56637: LD_INT 3
56639: PUSH
56640: EMPTY
56641: LIST
56642: LIST
56643: PUSH
56644: EMPTY
56645: LIST
56646: LIST
56647: LIST
56648: PPUSH
56649: CALL_OW 72
56653: ST_TO_ADDR
56654: GO 56788
56656: LD_INT 4
56658: DOUBLE
56659: EQUAL
56660: IFTRUE 56664
56662: GO 56721
56664: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56665: LD_ADDR_VAR 0 8
56669: PUSH
56670: LD_VAR 0 2
56674: PPUSH
56675: LD_INT 2
56677: PUSH
56678: LD_INT 30
56680: PUSH
56681: LD_INT 6
56683: PUSH
56684: EMPTY
56685: LIST
56686: LIST
56687: PUSH
56688: LD_INT 30
56690: PUSH
56691: LD_INT 7
56693: PUSH
56694: EMPTY
56695: LIST
56696: LIST
56697: PUSH
56698: LD_INT 30
56700: PUSH
56701: LD_INT 8
56703: PUSH
56704: EMPTY
56705: LIST
56706: LIST
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: LIST
56712: LIST
56713: PPUSH
56714: CALL_OW 72
56718: ST_TO_ADDR
56719: GO 56788
56721: LD_INT 5
56723: DOUBLE
56724: EQUAL
56725: IFTRUE 56741
56727: LD_INT 8
56729: DOUBLE
56730: EQUAL
56731: IFTRUE 56741
56733: LD_INT 9
56735: DOUBLE
56736: EQUAL
56737: IFTRUE 56741
56739: GO 56787
56741: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56742: LD_ADDR_VAR 0 8
56746: PUSH
56747: LD_VAR 0 2
56751: PPUSH
56752: LD_INT 2
56754: PUSH
56755: LD_INT 30
56757: PUSH
56758: LD_INT 4
56760: PUSH
56761: EMPTY
56762: LIST
56763: LIST
56764: PUSH
56765: LD_INT 30
56767: PUSH
56768: LD_INT 5
56770: PUSH
56771: EMPTY
56772: LIST
56773: LIST
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: LIST
56779: PPUSH
56780: CALL_OW 72
56784: ST_TO_ADDR
56785: GO 56788
56787: POP
// if not tmp then
56788: LD_VAR 0 8
56792: NOT
56793: IFFALSE 56797
// exit ;
56795: GO 57299
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56797: LD_VAR 0 4
56801: PUSH
56802: LD_INT 1
56804: PUSH
56805: LD_INT 15
56807: PUSH
56808: EMPTY
56809: LIST
56810: LIST
56811: IN
56812: PUSH
56813: LD_EXP 110
56817: PUSH
56818: LD_VAR 0 1
56822: ARRAY
56823: AND
56824: IFFALSE 56980
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56826: LD_ADDR_VAR 0 9
56830: PUSH
56831: LD_EXP 110
56835: PUSH
56836: LD_VAR 0 1
56840: ARRAY
56841: PUSH
56842: LD_INT 1
56844: ARRAY
56845: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56846: LD_VAR 0 9
56850: PUSH
56851: LD_EXP 111
56855: PUSH
56856: LD_VAR 0 1
56860: ARRAY
56861: IN
56862: NOT
56863: IFFALSE 56978
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56865: LD_ADDR_EXP 111
56869: PUSH
56870: LD_EXP 111
56874: PPUSH
56875: LD_VAR 0 1
56879: PUSH
56880: LD_EXP 111
56884: PUSH
56885: LD_VAR 0 1
56889: ARRAY
56890: PUSH
56891: LD_INT 1
56893: PLUS
56894: PUSH
56895: EMPTY
56896: LIST
56897: LIST
56898: PPUSH
56899: LD_VAR 0 9
56903: PPUSH
56904: CALL 71510 0 3
56908: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56909: LD_ADDR_EXP 110
56913: PUSH
56914: LD_EXP 110
56918: PPUSH
56919: LD_VAR 0 1
56923: PPUSH
56924: LD_EXP 110
56928: PUSH
56929: LD_VAR 0 1
56933: ARRAY
56934: PUSH
56935: LD_VAR 0 9
56939: DIFF
56940: PPUSH
56941: CALL_OW 1
56945: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56946: LD_VAR 0 3
56950: PPUSH
56951: LD_EXP 111
56955: PUSH
56956: LD_VAR 0 1
56960: ARRAY
56961: PUSH
56962: LD_EXP 111
56966: PUSH
56967: LD_VAR 0 1
56971: ARRAY
56972: ARRAY
56973: PPUSH
56974: CALL_OW 120
// end ; exit ;
56978: GO 57299
// end ; if tmp > 1 then
56980: LD_VAR 0 8
56984: PUSH
56985: LD_INT 1
56987: GREATER
56988: IFFALSE 57092
// for i = 2 to tmp do
56990: LD_ADDR_VAR 0 6
56994: PUSH
56995: DOUBLE
56996: LD_INT 2
56998: DEC
56999: ST_TO_ADDR
57000: LD_VAR 0 8
57004: PUSH
57005: FOR_TO
57006: IFFALSE 57090
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57008: LD_VAR 0 8
57012: PUSH
57013: LD_VAR 0 6
57017: ARRAY
57018: PPUSH
57019: CALL_OW 461
57023: PUSH
57024: LD_INT 6
57026: EQUAL
57027: IFFALSE 57088
// begin x := tmp [ i ] ;
57029: LD_ADDR_VAR 0 9
57033: PUSH
57034: LD_VAR 0 8
57038: PUSH
57039: LD_VAR 0 6
57043: ARRAY
57044: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57045: LD_ADDR_VAR 0 8
57049: PUSH
57050: LD_VAR 0 8
57054: PPUSH
57055: LD_VAR 0 6
57059: PPUSH
57060: CALL_OW 3
57064: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57065: LD_ADDR_VAR 0 8
57069: PUSH
57070: LD_VAR 0 8
57074: PPUSH
57075: LD_INT 1
57077: PPUSH
57078: LD_VAR 0 9
57082: PPUSH
57083: CALL_OW 2
57087: ST_TO_ADDR
// end ;
57088: GO 57005
57090: POP
57091: POP
// for i in tmp do
57092: LD_ADDR_VAR 0 6
57096: PUSH
57097: LD_VAR 0 8
57101: PUSH
57102: FOR_IN
57103: IFFALSE 57172
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57105: LD_VAR 0 6
57109: PPUSH
57110: CALL_OW 313
57114: PUSH
57115: LD_INT 6
57117: LESS
57118: PUSH
57119: LD_VAR 0 6
57123: PPUSH
57124: CALL_OW 266
57128: PUSH
57129: LD_INT 31
57131: PUSH
57132: LD_INT 32
57134: PUSH
57135: EMPTY
57136: LIST
57137: LIST
57138: IN
57139: NOT
57140: AND
57141: PUSH
57142: LD_VAR 0 6
57146: PPUSH
57147: CALL_OW 313
57151: PUSH
57152: LD_INT 0
57154: EQUAL
57155: OR
57156: IFFALSE 57170
// begin j := i ;
57158: LD_ADDR_VAR 0 7
57162: PUSH
57163: LD_VAR 0 6
57167: ST_TO_ADDR
// break ;
57168: GO 57172
// end ; end ;
57170: GO 57102
57172: POP
57173: POP
// if j then
57174: LD_VAR 0 7
57178: IFFALSE 57196
// ComEnterUnit ( unit , j ) else
57180: LD_VAR 0 3
57184: PPUSH
57185: LD_VAR 0 7
57189: PPUSH
57190: CALL_OW 120
57194: GO 57299
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57196: LD_ADDR_VAR 0 10
57200: PUSH
57201: LD_VAR 0 2
57205: PPUSH
57206: LD_INT 2
57208: PUSH
57209: LD_INT 30
57211: PUSH
57212: LD_INT 0
57214: PUSH
57215: EMPTY
57216: LIST
57217: LIST
57218: PUSH
57219: LD_INT 30
57221: PUSH
57222: LD_INT 1
57224: PUSH
57225: EMPTY
57226: LIST
57227: LIST
57228: PUSH
57229: EMPTY
57230: LIST
57231: LIST
57232: LIST
57233: PPUSH
57234: CALL_OW 72
57238: ST_TO_ADDR
// if depot then
57239: LD_VAR 0 10
57243: IFFALSE 57299
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57245: LD_ADDR_VAR 0 10
57249: PUSH
57250: LD_VAR 0 10
57254: PPUSH
57255: LD_VAR 0 3
57259: PPUSH
57260: CALL_OW 74
57264: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57265: LD_VAR 0 3
57269: PPUSH
57270: LD_VAR 0 10
57274: PPUSH
57275: CALL_OW 296
57279: PUSH
57280: LD_INT 10
57282: GREATER
57283: IFFALSE 57299
// ComStandNearbyBuilding ( unit , depot ) ;
57285: LD_VAR 0 3
57289: PPUSH
57290: LD_VAR 0 10
57294: PPUSH
57295: CALL 65713 0 2
// end ; end ; end ;
57299: LD_VAR 0 5
57303: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57304: LD_INT 0
57306: PPUSH
57307: PPUSH
57308: PPUSH
57309: PPUSH
// if not mc_bases then
57310: LD_EXP 101
57314: NOT
57315: IFFALSE 57319
// exit ;
57317: GO 57558
// for i = 1 to mc_bases do
57319: LD_ADDR_VAR 0 2
57323: PUSH
57324: DOUBLE
57325: LD_INT 1
57327: DEC
57328: ST_TO_ADDR
57329: LD_EXP 101
57333: PUSH
57334: FOR_TO
57335: IFFALSE 57556
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57337: LD_ADDR_VAR 0 4
57341: PUSH
57342: LD_EXP 101
57346: PUSH
57347: LD_VAR 0 2
57351: ARRAY
57352: PPUSH
57353: LD_INT 21
57355: PUSH
57356: LD_INT 1
57358: PUSH
57359: EMPTY
57360: LIST
57361: LIST
57362: PPUSH
57363: CALL_OW 72
57367: PUSH
57368: LD_EXP 130
57372: PUSH
57373: LD_VAR 0 2
57377: ARRAY
57378: UNION
57379: ST_TO_ADDR
// if not tmp then
57380: LD_VAR 0 4
57384: NOT
57385: IFFALSE 57389
// continue ;
57387: GO 57334
// for j in tmp do
57389: LD_ADDR_VAR 0 3
57393: PUSH
57394: LD_VAR 0 4
57398: PUSH
57399: FOR_IN
57400: IFFALSE 57552
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57402: LD_VAR 0 3
57406: PPUSH
57407: CALL_OW 110
57411: NOT
57412: PUSH
57413: LD_VAR 0 3
57417: PPUSH
57418: CALL_OW 314
57422: NOT
57423: AND
57424: PUSH
57425: LD_VAR 0 3
57429: PPUSH
57430: CALL_OW 311
57434: NOT
57435: AND
57436: PUSH
57437: LD_VAR 0 3
57441: PPUSH
57442: CALL_OW 310
57446: NOT
57447: AND
57448: PUSH
57449: LD_VAR 0 3
57453: PUSH
57454: LD_EXP 104
57458: PUSH
57459: LD_VAR 0 2
57463: ARRAY
57464: PUSH
57465: LD_INT 1
57467: ARRAY
57468: IN
57469: NOT
57470: AND
57471: PUSH
57472: LD_VAR 0 3
57476: PUSH
57477: LD_EXP 104
57481: PUSH
57482: LD_VAR 0 2
57486: ARRAY
57487: PUSH
57488: LD_INT 2
57490: ARRAY
57491: IN
57492: NOT
57493: AND
57494: PUSH
57495: LD_VAR 0 3
57499: PUSH
57500: LD_EXP 113
57504: PUSH
57505: LD_VAR 0 2
57509: ARRAY
57510: IN
57511: NOT
57512: AND
57513: IFFALSE 57550
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57515: LD_VAR 0 2
57519: PPUSH
57520: LD_EXP 101
57524: PUSH
57525: LD_VAR 0 2
57529: ARRAY
57530: PPUSH
57531: LD_VAR 0 3
57535: PPUSH
57536: LD_VAR 0 3
57540: PPUSH
57541: CALL_OW 257
57545: PPUSH
57546: CALL 56322 0 4
// end ;
57550: GO 57399
57552: POP
57553: POP
// end ;
57554: GO 57334
57556: POP
57557: POP
// end ;
57558: LD_VAR 0 1
57562: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57563: LD_INT 0
57565: PPUSH
57566: PPUSH
57567: PPUSH
57568: PPUSH
57569: PPUSH
57570: PPUSH
// if not mc_bases [ base ] then
57571: LD_EXP 101
57575: PUSH
57576: LD_VAR 0 1
57580: ARRAY
57581: NOT
57582: IFFALSE 57586
// exit ;
57584: GO 57768
// tmp := [ ] ;
57586: LD_ADDR_VAR 0 6
57590: PUSH
57591: EMPTY
57592: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57593: LD_ADDR_VAR 0 7
57597: PUSH
57598: LD_VAR 0 3
57602: PPUSH
57603: LD_INT 0
57605: PPUSH
57606: CALL_OW 517
57610: ST_TO_ADDR
// if not list then
57611: LD_VAR 0 7
57615: NOT
57616: IFFALSE 57620
// exit ;
57618: GO 57768
// for i = 1 to amount do
57620: LD_ADDR_VAR 0 5
57624: PUSH
57625: DOUBLE
57626: LD_INT 1
57628: DEC
57629: ST_TO_ADDR
57630: LD_VAR 0 2
57634: PUSH
57635: FOR_TO
57636: IFFALSE 57716
// begin x := rand ( 1 , list [ 1 ] ) ;
57638: LD_ADDR_VAR 0 8
57642: PUSH
57643: LD_INT 1
57645: PPUSH
57646: LD_VAR 0 7
57650: PUSH
57651: LD_INT 1
57653: ARRAY
57654: PPUSH
57655: CALL_OW 12
57659: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57660: LD_ADDR_VAR 0 6
57664: PUSH
57665: LD_VAR 0 6
57669: PPUSH
57670: LD_VAR 0 5
57674: PPUSH
57675: LD_VAR 0 7
57679: PUSH
57680: LD_INT 1
57682: ARRAY
57683: PUSH
57684: LD_VAR 0 8
57688: ARRAY
57689: PUSH
57690: LD_VAR 0 7
57694: PUSH
57695: LD_INT 2
57697: ARRAY
57698: PUSH
57699: LD_VAR 0 8
57703: ARRAY
57704: PUSH
57705: EMPTY
57706: LIST
57707: LIST
57708: PPUSH
57709: CALL_OW 1
57713: ST_TO_ADDR
// end ;
57714: GO 57635
57716: POP
57717: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57718: LD_ADDR_EXP 114
57722: PUSH
57723: LD_EXP 114
57727: PPUSH
57728: LD_VAR 0 1
57732: PPUSH
57733: LD_VAR 0 6
57737: PPUSH
57738: CALL_OW 1
57742: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57743: LD_ADDR_EXP 116
57747: PUSH
57748: LD_EXP 116
57752: PPUSH
57753: LD_VAR 0 1
57757: PPUSH
57758: LD_VAR 0 3
57762: PPUSH
57763: CALL_OW 1
57767: ST_TO_ADDR
// end ;
57768: LD_VAR 0 4
57772: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57773: LD_INT 0
57775: PPUSH
// if not mc_bases [ base ] then
57776: LD_EXP 101
57780: PUSH
57781: LD_VAR 0 1
57785: ARRAY
57786: NOT
57787: IFFALSE 57791
// exit ;
57789: GO 57816
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57791: LD_ADDR_EXP 106
57795: PUSH
57796: LD_EXP 106
57800: PPUSH
57801: LD_VAR 0 1
57805: PPUSH
57806: LD_VAR 0 2
57810: PPUSH
57811: CALL_OW 1
57815: ST_TO_ADDR
// end ;
57816: LD_VAR 0 3
57820: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57821: LD_INT 0
57823: PPUSH
// if not mc_bases [ base ] then
57824: LD_EXP 101
57828: PUSH
57829: LD_VAR 0 1
57833: ARRAY
57834: NOT
57835: IFFALSE 57839
// exit ;
57837: GO 57876
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57839: LD_ADDR_EXP 106
57843: PUSH
57844: LD_EXP 106
57848: PPUSH
57849: LD_VAR 0 1
57853: PPUSH
57854: LD_EXP 106
57858: PUSH
57859: LD_VAR 0 1
57863: ARRAY
57864: PUSH
57865: LD_VAR 0 2
57869: UNION
57870: PPUSH
57871: CALL_OW 1
57875: ST_TO_ADDR
// end ;
57876: LD_VAR 0 3
57880: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57881: LD_INT 0
57883: PPUSH
// if not mc_bases [ base ] then
57884: LD_EXP 101
57888: PUSH
57889: LD_VAR 0 1
57893: ARRAY
57894: NOT
57895: IFFALSE 57899
// exit ;
57897: GO 57924
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57899: LD_ADDR_EXP 122
57903: PUSH
57904: LD_EXP 122
57908: PPUSH
57909: LD_VAR 0 1
57913: PPUSH
57914: LD_VAR 0 2
57918: PPUSH
57919: CALL_OW 1
57923: ST_TO_ADDR
// end ;
57924: LD_VAR 0 3
57928: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57929: LD_INT 0
57931: PPUSH
// if not mc_bases [ base ] then
57932: LD_EXP 101
57936: PUSH
57937: LD_VAR 0 1
57941: ARRAY
57942: NOT
57943: IFFALSE 57947
// exit ;
57945: GO 57984
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57947: LD_ADDR_EXP 122
57951: PUSH
57952: LD_EXP 122
57956: PPUSH
57957: LD_VAR 0 1
57961: PPUSH
57962: LD_EXP 122
57966: PUSH
57967: LD_VAR 0 1
57971: ARRAY
57972: PUSH
57973: LD_VAR 0 2
57977: ADD
57978: PPUSH
57979: CALL_OW 1
57983: ST_TO_ADDR
// end ;
57984: LD_VAR 0 3
57988: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57989: LD_INT 0
57991: PPUSH
// if not mc_bases [ base ] then
57992: LD_EXP 101
57996: PUSH
57997: LD_VAR 0 1
58001: ARRAY
58002: NOT
58003: IFFALSE 58007
// exit ;
58005: GO 58061
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58007: LD_ADDR_EXP 123
58011: PUSH
58012: LD_EXP 123
58016: PPUSH
58017: LD_VAR 0 1
58021: PPUSH
58022: LD_VAR 0 2
58026: PPUSH
58027: CALL_OW 1
58031: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58032: LD_ADDR_EXP 112
58036: PUSH
58037: LD_EXP 112
58041: PPUSH
58042: LD_VAR 0 1
58046: PPUSH
58047: LD_VAR 0 2
58051: PUSH
58052: LD_INT 0
58054: PLUS
58055: PPUSH
58056: CALL_OW 1
58060: ST_TO_ADDR
// end ;
58061: LD_VAR 0 3
58065: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58066: LD_INT 0
58068: PPUSH
// if not mc_bases [ base ] then
58069: LD_EXP 101
58073: PUSH
58074: LD_VAR 0 1
58078: ARRAY
58079: NOT
58080: IFFALSE 58084
// exit ;
58082: GO 58109
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58084: LD_ADDR_EXP 112
58088: PUSH
58089: LD_EXP 112
58093: PPUSH
58094: LD_VAR 0 1
58098: PPUSH
58099: LD_VAR 0 2
58103: PPUSH
58104: CALL_OW 1
58108: ST_TO_ADDR
// end ;
58109: LD_VAR 0 3
58113: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58114: LD_INT 0
58116: PPUSH
58117: PPUSH
58118: PPUSH
58119: PPUSH
// if not mc_bases [ base ] then
58120: LD_EXP 101
58124: PUSH
58125: LD_VAR 0 1
58129: ARRAY
58130: NOT
58131: IFFALSE 58135
// exit ;
58133: GO 58200
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58135: LD_ADDR_EXP 121
58139: PUSH
58140: LD_EXP 121
58144: PPUSH
58145: LD_VAR 0 1
58149: PUSH
58150: LD_EXP 121
58154: PUSH
58155: LD_VAR 0 1
58159: ARRAY
58160: PUSH
58161: LD_INT 1
58163: PLUS
58164: PUSH
58165: EMPTY
58166: LIST
58167: LIST
58168: PPUSH
58169: LD_VAR 0 1
58173: PUSH
58174: LD_VAR 0 2
58178: PUSH
58179: LD_VAR 0 3
58183: PUSH
58184: LD_VAR 0 4
58188: PUSH
58189: EMPTY
58190: LIST
58191: LIST
58192: LIST
58193: LIST
58194: PPUSH
58195: CALL 71510 0 3
58199: ST_TO_ADDR
// end ;
58200: LD_VAR 0 5
58204: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58205: LD_INT 0
58207: PPUSH
// if not mc_bases [ base ] then
58208: LD_EXP 101
58212: PUSH
58213: LD_VAR 0 1
58217: ARRAY
58218: NOT
58219: IFFALSE 58223
// exit ;
58221: GO 58248
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58223: LD_ADDR_EXP 138
58227: PUSH
58228: LD_EXP 138
58232: PPUSH
58233: LD_VAR 0 1
58237: PPUSH
58238: LD_VAR 0 2
58242: PPUSH
58243: CALL_OW 1
58247: ST_TO_ADDR
// end ;
58248: LD_VAR 0 3
58252: RET
// export function MC_GetMinesField ( base ) ; begin
58253: LD_INT 0
58255: PPUSH
// result := mc_mines [ base ] ;
58256: LD_ADDR_VAR 0 2
58260: PUSH
58261: LD_EXP 114
58265: PUSH
58266: LD_VAR 0 1
58270: ARRAY
58271: ST_TO_ADDR
// end ;
58272: LD_VAR 0 2
58276: RET
// export function MC_GetProduceList ( base ) ; begin
58277: LD_INT 0
58279: PPUSH
// result := mc_produce [ base ] ;
58280: LD_ADDR_VAR 0 2
58284: PUSH
58285: LD_EXP 122
58289: PUSH
58290: LD_VAR 0 1
58294: ARRAY
58295: ST_TO_ADDR
// end ;
58296: LD_VAR 0 2
58300: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58301: LD_INT 0
58303: PPUSH
58304: PPUSH
// if not mc_bases then
58305: LD_EXP 101
58309: NOT
58310: IFFALSE 58314
// exit ;
58312: GO 58379
// if mc_bases [ base ] then
58314: LD_EXP 101
58318: PUSH
58319: LD_VAR 0 1
58323: ARRAY
58324: IFFALSE 58379
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58326: LD_ADDR_VAR 0 3
58330: PUSH
58331: LD_EXP 101
58335: PUSH
58336: LD_VAR 0 1
58340: ARRAY
58341: PPUSH
58342: LD_INT 30
58344: PUSH
58345: LD_VAR 0 2
58349: PUSH
58350: EMPTY
58351: LIST
58352: LIST
58353: PPUSH
58354: CALL_OW 72
58358: ST_TO_ADDR
// if result then
58359: LD_VAR 0 3
58363: IFFALSE 58379
// result := result [ 1 ] ;
58365: LD_ADDR_VAR 0 3
58369: PUSH
58370: LD_VAR 0 3
58374: PUSH
58375: LD_INT 1
58377: ARRAY
58378: ST_TO_ADDR
// end ; end ;
58379: LD_VAR 0 3
58383: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58384: LD_INT 0
58386: PPUSH
58387: PPUSH
// if not mc_bases then
58388: LD_EXP 101
58392: NOT
58393: IFFALSE 58397
// exit ;
58395: GO 58442
// if mc_bases [ base ] then
58397: LD_EXP 101
58401: PUSH
58402: LD_VAR 0 1
58406: ARRAY
58407: IFFALSE 58442
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58409: LD_ADDR_VAR 0 3
58413: PUSH
58414: LD_EXP 101
58418: PUSH
58419: LD_VAR 0 1
58423: ARRAY
58424: PPUSH
58425: LD_INT 30
58427: PUSH
58428: LD_VAR 0 2
58432: PUSH
58433: EMPTY
58434: LIST
58435: LIST
58436: PPUSH
58437: CALL_OW 72
58441: ST_TO_ADDR
// end ;
58442: LD_VAR 0 3
58446: RET
// export function MC_SetTame ( base , area ) ; begin
58447: LD_INT 0
58449: PPUSH
// if not mc_bases or not base then
58450: LD_EXP 101
58454: NOT
58455: PUSH
58456: LD_VAR 0 1
58460: NOT
58461: OR
58462: IFFALSE 58466
// exit ;
58464: GO 58491
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58466: LD_ADDR_EXP 129
58470: PUSH
58471: LD_EXP 129
58475: PPUSH
58476: LD_VAR 0 1
58480: PPUSH
58481: LD_VAR 0 2
58485: PPUSH
58486: CALL_OW 1
58490: ST_TO_ADDR
// end ;
58491: LD_VAR 0 3
58495: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58496: LD_INT 0
58498: PPUSH
58499: PPUSH
// if not mc_bases or not base then
58500: LD_EXP 101
58504: NOT
58505: PUSH
58506: LD_VAR 0 1
58510: NOT
58511: OR
58512: IFFALSE 58516
// exit ;
58514: GO 58618
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58516: LD_ADDR_VAR 0 4
58520: PUSH
58521: LD_EXP 101
58525: PUSH
58526: LD_VAR 0 1
58530: ARRAY
58531: PPUSH
58532: LD_INT 30
58534: PUSH
58535: LD_VAR 0 2
58539: PUSH
58540: EMPTY
58541: LIST
58542: LIST
58543: PPUSH
58544: CALL_OW 72
58548: ST_TO_ADDR
// if not tmp then
58549: LD_VAR 0 4
58553: NOT
58554: IFFALSE 58558
// exit ;
58556: GO 58618
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58558: LD_ADDR_EXP 133
58562: PUSH
58563: LD_EXP 133
58567: PPUSH
58568: LD_VAR 0 1
58572: PPUSH
58573: LD_EXP 133
58577: PUSH
58578: LD_VAR 0 1
58582: ARRAY
58583: PPUSH
58584: LD_EXP 133
58588: PUSH
58589: LD_VAR 0 1
58593: ARRAY
58594: PUSH
58595: LD_INT 1
58597: PLUS
58598: PPUSH
58599: LD_VAR 0 4
58603: PUSH
58604: LD_INT 1
58606: ARRAY
58607: PPUSH
58608: CALL_OW 2
58612: PPUSH
58613: CALL_OW 1
58617: ST_TO_ADDR
// end ;
58618: LD_VAR 0 3
58622: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58623: LD_INT 0
58625: PPUSH
58626: PPUSH
// if not mc_bases or not base or not kinds then
58627: LD_EXP 101
58631: NOT
58632: PUSH
58633: LD_VAR 0 1
58637: NOT
58638: OR
58639: PUSH
58640: LD_VAR 0 2
58644: NOT
58645: OR
58646: IFFALSE 58650
// exit ;
58648: GO 58711
// for i in kinds do
58650: LD_ADDR_VAR 0 4
58654: PUSH
58655: LD_VAR 0 2
58659: PUSH
58660: FOR_IN
58661: IFFALSE 58709
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58663: LD_ADDR_EXP 135
58667: PUSH
58668: LD_EXP 135
58672: PPUSH
58673: LD_VAR 0 1
58677: PUSH
58678: LD_EXP 135
58682: PUSH
58683: LD_VAR 0 1
58687: ARRAY
58688: PUSH
58689: LD_INT 1
58691: PLUS
58692: PUSH
58693: EMPTY
58694: LIST
58695: LIST
58696: PPUSH
58697: LD_VAR 0 4
58701: PPUSH
58702: CALL 71510 0 3
58706: ST_TO_ADDR
58707: GO 58660
58709: POP
58710: POP
// end ;
58711: LD_VAR 0 3
58715: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58716: LD_INT 0
58718: PPUSH
// if not mc_bases or not base or not areas then
58719: LD_EXP 101
58723: NOT
58724: PUSH
58725: LD_VAR 0 1
58729: NOT
58730: OR
58731: PUSH
58732: LD_VAR 0 2
58736: NOT
58737: OR
58738: IFFALSE 58742
// exit ;
58740: GO 58767
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58742: LD_ADDR_EXP 119
58746: PUSH
58747: LD_EXP 119
58751: PPUSH
58752: LD_VAR 0 1
58756: PPUSH
58757: LD_VAR 0 2
58761: PPUSH
58762: CALL_OW 1
58766: ST_TO_ADDR
// end ;
58767: LD_VAR 0 3
58771: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58772: LD_INT 0
58774: PPUSH
// if not mc_bases or not base or not teleports_exit then
58775: LD_EXP 101
58779: NOT
58780: PUSH
58781: LD_VAR 0 1
58785: NOT
58786: OR
58787: PUSH
58788: LD_VAR 0 2
58792: NOT
58793: OR
58794: IFFALSE 58798
// exit ;
58796: GO 58823
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58798: LD_ADDR_EXP 136
58802: PUSH
58803: LD_EXP 136
58807: PPUSH
58808: LD_VAR 0 1
58812: PPUSH
58813: LD_VAR 0 2
58817: PPUSH
58818: CALL_OW 1
58822: ST_TO_ADDR
// end ;
58823: LD_VAR 0 3
58827: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58828: LD_INT 0
58830: PPUSH
58831: PPUSH
58832: PPUSH
// if not mc_bases or not base or not ext_list then
58833: LD_EXP 101
58837: NOT
58838: PUSH
58839: LD_VAR 0 1
58843: NOT
58844: OR
58845: PUSH
58846: LD_VAR 0 5
58850: NOT
58851: OR
58852: IFFALSE 58856
// exit ;
58854: GO 59029
// tmp := GetFacExtXYD ( x , y , d ) ;
58856: LD_ADDR_VAR 0 8
58860: PUSH
58861: LD_VAR 0 2
58865: PPUSH
58866: LD_VAR 0 3
58870: PPUSH
58871: LD_VAR 0 4
58875: PPUSH
58876: CALL 104891 0 3
58880: ST_TO_ADDR
// if not tmp then
58881: LD_VAR 0 8
58885: NOT
58886: IFFALSE 58890
// exit ;
58888: GO 59029
// for i in tmp do
58890: LD_ADDR_VAR 0 7
58894: PUSH
58895: LD_VAR 0 8
58899: PUSH
58900: FOR_IN
58901: IFFALSE 59027
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58903: LD_ADDR_EXP 106
58907: PUSH
58908: LD_EXP 106
58912: PPUSH
58913: LD_VAR 0 1
58917: PPUSH
58918: LD_EXP 106
58922: PUSH
58923: LD_VAR 0 1
58927: ARRAY
58928: PPUSH
58929: LD_EXP 106
58933: PUSH
58934: LD_VAR 0 1
58938: ARRAY
58939: PUSH
58940: LD_INT 1
58942: PLUS
58943: PPUSH
58944: LD_VAR 0 5
58948: PUSH
58949: LD_INT 1
58951: ARRAY
58952: PUSH
58953: LD_VAR 0 7
58957: PUSH
58958: LD_INT 1
58960: ARRAY
58961: PUSH
58962: LD_VAR 0 7
58966: PUSH
58967: LD_INT 2
58969: ARRAY
58970: PUSH
58971: LD_VAR 0 7
58975: PUSH
58976: LD_INT 3
58978: ARRAY
58979: PUSH
58980: EMPTY
58981: LIST
58982: LIST
58983: LIST
58984: LIST
58985: PPUSH
58986: CALL_OW 2
58990: PPUSH
58991: CALL_OW 1
58995: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58996: LD_ADDR_VAR 0 5
59000: PUSH
59001: LD_VAR 0 5
59005: PPUSH
59006: LD_INT 1
59008: PPUSH
59009: CALL_OW 3
59013: ST_TO_ADDR
// if not ext_list then
59014: LD_VAR 0 5
59018: NOT
59019: IFFALSE 59025
// exit ;
59021: POP
59022: POP
59023: GO 59029
// end ;
59025: GO 58900
59027: POP
59028: POP
// end ;
59029: LD_VAR 0 6
59033: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59034: LD_INT 0
59036: PPUSH
// if not mc_bases or not base or not weapon_list then
59037: LD_EXP 101
59041: NOT
59042: PUSH
59043: LD_VAR 0 1
59047: NOT
59048: OR
59049: PUSH
59050: LD_VAR 0 2
59054: NOT
59055: OR
59056: IFFALSE 59060
// exit ;
59058: GO 59085
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59060: LD_ADDR_EXP 140
59064: PUSH
59065: LD_EXP 140
59069: PPUSH
59070: LD_VAR 0 1
59074: PPUSH
59075: LD_VAR 0 2
59079: PPUSH
59080: CALL_OW 1
59084: ST_TO_ADDR
// end ;
59085: LD_VAR 0 3
59089: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59090: LD_INT 0
59092: PPUSH
// if not mc_bases or not base or not tech_list then
59093: LD_EXP 101
59097: NOT
59098: PUSH
59099: LD_VAR 0 1
59103: NOT
59104: OR
59105: PUSH
59106: LD_VAR 0 2
59110: NOT
59111: OR
59112: IFFALSE 59116
// exit ;
59114: GO 59141
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59116: LD_ADDR_EXP 128
59120: PUSH
59121: LD_EXP 128
59125: PPUSH
59126: LD_VAR 0 1
59130: PPUSH
59131: LD_VAR 0 2
59135: PPUSH
59136: CALL_OW 1
59140: ST_TO_ADDR
// end ;
59141: LD_VAR 0 3
59145: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59146: LD_INT 0
59148: PPUSH
// if not mc_bases or not parking_area or not base then
59149: LD_EXP 101
59153: NOT
59154: PUSH
59155: LD_VAR 0 2
59159: NOT
59160: OR
59161: PUSH
59162: LD_VAR 0 1
59166: NOT
59167: OR
59168: IFFALSE 59172
// exit ;
59170: GO 59197
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59172: LD_ADDR_EXP 125
59176: PUSH
59177: LD_EXP 125
59181: PPUSH
59182: LD_VAR 0 1
59186: PPUSH
59187: LD_VAR 0 2
59191: PPUSH
59192: CALL_OW 1
59196: ST_TO_ADDR
// end ;
59197: LD_VAR 0 3
59201: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59202: LD_INT 0
59204: PPUSH
// if not mc_bases or not base or not scan_area then
59205: LD_EXP 101
59209: NOT
59210: PUSH
59211: LD_VAR 0 1
59215: NOT
59216: OR
59217: PUSH
59218: LD_VAR 0 2
59222: NOT
59223: OR
59224: IFFALSE 59228
// exit ;
59226: GO 59253
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59228: LD_ADDR_EXP 126
59232: PUSH
59233: LD_EXP 126
59237: PPUSH
59238: LD_VAR 0 1
59242: PPUSH
59243: LD_VAR 0 2
59247: PPUSH
59248: CALL_OW 1
59252: ST_TO_ADDR
// end ;
59253: LD_VAR 0 3
59257: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59258: LD_INT 0
59260: PPUSH
59261: PPUSH
// if not mc_bases or not base then
59262: LD_EXP 101
59266: NOT
59267: PUSH
59268: LD_VAR 0 1
59272: NOT
59273: OR
59274: IFFALSE 59278
// exit ;
59276: GO 59342
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59278: LD_ADDR_VAR 0 3
59282: PUSH
59283: LD_INT 1
59285: PUSH
59286: LD_INT 2
59288: PUSH
59289: LD_INT 3
59291: PUSH
59292: LD_INT 4
59294: PUSH
59295: LD_INT 11
59297: PUSH
59298: EMPTY
59299: LIST
59300: LIST
59301: LIST
59302: LIST
59303: LIST
59304: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59305: LD_ADDR_EXP 128
59309: PUSH
59310: LD_EXP 128
59314: PPUSH
59315: LD_VAR 0 1
59319: PPUSH
59320: LD_EXP 128
59324: PUSH
59325: LD_VAR 0 1
59329: ARRAY
59330: PUSH
59331: LD_VAR 0 3
59335: DIFF
59336: PPUSH
59337: CALL_OW 1
59341: ST_TO_ADDR
// end ;
59342: LD_VAR 0 2
59346: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59347: LD_INT 0
59349: PPUSH
// result := mc_vehicles [ base ] ;
59350: LD_ADDR_VAR 0 3
59354: PUSH
59355: LD_EXP 120
59359: PUSH
59360: LD_VAR 0 1
59364: ARRAY
59365: ST_TO_ADDR
// if onlyCombat then
59366: LD_VAR 0 2
59370: IFFALSE 59535
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59372: LD_ADDR_VAR 0 3
59376: PUSH
59377: LD_VAR 0 3
59381: PUSH
59382: LD_VAR 0 3
59386: PPUSH
59387: LD_INT 2
59389: PUSH
59390: LD_INT 34
59392: PUSH
59393: LD_INT 12
59395: PUSH
59396: EMPTY
59397: LIST
59398: LIST
59399: PUSH
59400: LD_INT 34
59402: PUSH
59403: LD_INT 51
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: PUSH
59410: LD_INT 34
59412: PUSH
59413: LD_EXP 95
59417: PUSH
59418: EMPTY
59419: LIST
59420: LIST
59421: PUSH
59422: LD_INT 34
59424: PUSH
59425: LD_INT 32
59427: PUSH
59428: EMPTY
59429: LIST
59430: LIST
59431: PUSH
59432: LD_INT 34
59434: PUSH
59435: LD_INT 13
59437: PUSH
59438: EMPTY
59439: LIST
59440: LIST
59441: PUSH
59442: LD_INT 34
59444: PUSH
59445: LD_INT 52
59447: PUSH
59448: EMPTY
59449: LIST
59450: LIST
59451: PUSH
59452: LD_INT 34
59454: PUSH
59455: LD_INT 14
59457: PUSH
59458: EMPTY
59459: LIST
59460: LIST
59461: PUSH
59462: LD_INT 34
59464: PUSH
59465: LD_INT 53
59467: PUSH
59468: EMPTY
59469: LIST
59470: LIST
59471: PUSH
59472: LD_INT 34
59474: PUSH
59475: LD_EXP 94
59479: PUSH
59480: EMPTY
59481: LIST
59482: LIST
59483: PUSH
59484: LD_INT 34
59486: PUSH
59487: LD_INT 31
59489: PUSH
59490: EMPTY
59491: LIST
59492: LIST
59493: PUSH
59494: LD_INT 34
59496: PUSH
59497: LD_INT 48
59499: PUSH
59500: EMPTY
59501: LIST
59502: LIST
59503: PUSH
59504: LD_INT 34
59506: PUSH
59507: LD_INT 8
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: PUSH
59514: EMPTY
59515: LIST
59516: LIST
59517: LIST
59518: LIST
59519: LIST
59520: LIST
59521: LIST
59522: LIST
59523: LIST
59524: LIST
59525: LIST
59526: LIST
59527: LIST
59528: PPUSH
59529: CALL_OW 72
59533: DIFF
59534: ST_TO_ADDR
// end ; end_of_file
59535: LD_VAR 0 3
59539: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59540: LD_INT 0
59542: PPUSH
59543: PPUSH
59544: PPUSH
// if not mc_bases or not skirmish then
59545: LD_EXP 101
59549: NOT
59550: PUSH
59551: LD_EXP 99
59555: NOT
59556: OR
59557: IFFALSE 59561
// exit ;
59559: GO 59726
// for i = 1 to mc_bases do
59561: LD_ADDR_VAR 0 4
59565: PUSH
59566: DOUBLE
59567: LD_INT 1
59569: DEC
59570: ST_TO_ADDR
59571: LD_EXP 101
59575: PUSH
59576: FOR_TO
59577: IFFALSE 59724
// begin if sci in mc_bases [ i ] then
59579: LD_VAR 0 2
59583: PUSH
59584: LD_EXP 101
59588: PUSH
59589: LD_VAR 0 4
59593: ARRAY
59594: IN
59595: IFFALSE 59722
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59597: LD_ADDR_EXP 130
59601: PUSH
59602: LD_EXP 130
59606: PPUSH
59607: LD_VAR 0 4
59611: PUSH
59612: LD_EXP 130
59616: PUSH
59617: LD_VAR 0 4
59621: ARRAY
59622: PUSH
59623: LD_INT 1
59625: PLUS
59626: PUSH
59627: EMPTY
59628: LIST
59629: LIST
59630: PPUSH
59631: LD_VAR 0 1
59635: PPUSH
59636: CALL 71510 0 3
59640: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59641: LD_ADDR_VAR 0 5
59645: PUSH
59646: LD_EXP 101
59650: PUSH
59651: LD_VAR 0 4
59655: ARRAY
59656: PPUSH
59657: LD_INT 2
59659: PUSH
59660: LD_INT 30
59662: PUSH
59663: LD_INT 0
59665: PUSH
59666: EMPTY
59667: LIST
59668: LIST
59669: PUSH
59670: LD_INT 30
59672: PUSH
59673: LD_INT 1
59675: PUSH
59676: EMPTY
59677: LIST
59678: LIST
59679: PUSH
59680: EMPTY
59681: LIST
59682: LIST
59683: LIST
59684: PPUSH
59685: CALL_OW 72
59689: PPUSH
59690: LD_VAR 0 1
59694: PPUSH
59695: CALL_OW 74
59699: ST_TO_ADDR
// if tmp then
59700: LD_VAR 0 5
59704: IFFALSE 59720
// ComStandNearbyBuilding ( ape , tmp ) ;
59706: LD_VAR 0 1
59710: PPUSH
59711: LD_VAR 0 5
59715: PPUSH
59716: CALL 65713 0 2
// break ;
59720: GO 59724
// end ; end ;
59722: GO 59576
59724: POP
59725: POP
// end ;
59726: LD_VAR 0 3
59730: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59731: LD_INT 0
59733: PPUSH
59734: PPUSH
59735: PPUSH
// if not mc_bases or not skirmish then
59736: LD_EXP 101
59740: NOT
59741: PUSH
59742: LD_EXP 99
59746: NOT
59747: OR
59748: IFFALSE 59752
// exit ;
59750: GO 59841
// for i = 1 to mc_bases do
59752: LD_ADDR_VAR 0 4
59756: PUSH
59757: DOUBLE
59758: LD_INT 1
59760: DEC
59761: ST_TO_ADDR
59762: LD_EXP 101
59766: PUSH
59767: FOR_TO
59768: IFFALSE 59839
// begin if building in mc_busy_turret_list [ i ] then
59770: LD_VAR 0 1
59774: PUSH
59775: LD_EXP 111
59779: PUSH
59780: LD_VAR 0 4
59784: ARRAY
59785: IN
59786: IFFALSE 59837
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59788: LD_ADDR_VAR 0 5
59792: PUSH
59793: LD_EXP 111
59797: PUSH
59798: LD_VAR 0 4
59802: ARRAY
59803: PUSH
59804: LD_VAR 0 1
59808: DIFF
59809: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59810: LD_ADDR_EXP 111
59814: PUSH
59815: LD_EXP 111
59819: PPUSH
59820: LD_VAR 0 4
59824: PPUSH
59825: LD_VAR 0 5
59829: PPUSH
59830: CALL_OW 1
59834: ST_TO_ADDR
// break ;
59835: GO 59839
// end ; end ;
59837: GO 59767
59839: POP
59840: POP
// end ;
59841: LD_VAR 0 3
59845: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59846: LD_INT 0
59848: PPUSH
59849: PPUSH
59850: PPUSH
// if not mc_bases or not skirmish then
59851: LD_EXP 101
59855: NOT
59856: PUSH
59857: LD_EXP 99
59861: NOT
59862: OR
59863: IFFALSE 59867
// exit ;
59865: GO 60066
// for i = 1 to mc_bases do
59867: LD_ADDR_VAR 0 5
59871: PUSH
59872: DOUBLE
59873: LD_INT 1
59875: DEC
59876: ST_TO_ADDR
59877: LD_EXP 101
59881: PUSH
59882: FOR_TO
59883: IFFALSE 60064
// if building in mc_bases [ i ] then
59885: LD_VAR 0 1
59889: PUSH
59890: LD_EXP 101
59894: PUSH
59895: LD_VAR 0 5
59899: ARRAY
59900: IN
59901: IFFALSE 60062
// begin tmp := mc_bases [ i ] diff building ;
59903: LD_ADDR_VAR 0 6
59907: PUSH
59908: LD_EXP 101
59912: PUSH
59913: LD_VAR 0 5
59917: ARRAY
59918: PUSH
59919: LD_VAR 0 1
59923: DIFF
59924: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59925: LD_ADDR_EXP 101
59929: PUSH
59930: LD_EXP 101
59934: PPUSH
59935: LD_VAR 0 5
59939: PPUSH
59940: LD_VAR 0 6
59944: PPUSH
59945: CALL_OW 1
59949: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59950: LD_VAR 0 1
59954: PUSH
59955: LD_EXP 109
59959: PUSH
59960: LD_VAR 0 5
59964: ARRAY
59965: IN
59966: IFFALSE 60005
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59968: LD_ADDR_EXP 109
59972: PUSH
59973: LD_EXP 109
59977: PPUSH
59978: LD_VAR 0 5
59982: PPUSH
59983: LD_EXP 109
59987: PUSH
59988: LD_VAR 0 5
59992: ARRAY
59993: PUSH
59994: LD_VAR 0 1
59998: DIFF
59999: PPUSH
60000: CALL_OW 1
60004: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60005: LD_VAR 0 1
60009: PUSH
60010: LD_EXP 110
60014: PUSH
60015: LD_VAR 0 5
60019: ARRAY
60020: IN
60021: IFFALSE 60060
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60023: LD_ADDR_EXP 110
60027: PUSH
60028: LD_EXP 110
60032: PPUSH
60033: LD_VAR 0 5
60037: PPUSH
60038: LD_EXP 110
60042: PUSH
60043: LD_VAR 0 5
60047: ARRAY
60048: PUSH
60049: LD_VAR 0 1
60053: DIFF
60054: PPUSH
60055: CALL_OW 1
60059: ST_TO_ADDR
// break ;
60060: GO 60064
// end ;
60062: GO 59882
60064: POP
60065: POP
// end ;
60066: LD_VAR 0 4
60070: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60071: LD_INT 0
60073: PPUSH
60074: PPUSH
60075: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60076: LD_EXP 101
60080: NOT
60081: PUSH
60082: LD_EXP 99
60086: NOT
60087: OR
60088: PUSH
60089: LD_VAR 0 3
60093: PUSH
60094: LD_EXP 127
60098: IN
60099: NOT
60100: OR
60101: IFFALSE 60105
// exit ;
60103: GO 60228
// for i = 1 to mc_vehicles do
60105: LD_ADDR_VAR 0 6
60109: PUSH
60110: DOUBLE
60111: LD_INT 1
60113: DEC
60114: ST_TO_ADDR
60115: LD_EXP 120
60119: PUSH
60120: FOR_TO
60121: IFFALSE 60226
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60123: LD_VAR 0 2
60127: PUSH
60128: LD_EXP 120
60132: PUSH
60133: LD_VAR 0 6
60137: ARRAY
60138: IN
60139: PUSH
60140: LD_VAR 0 1
60144: PUSH
60145: LD_EXP 120
60149: PUSH
60150: LD_VAR 0 6
60154: ARRAY
60155: IN
60156: OR
60157: IFFALSE 60224
// begin tmp := mc_vehicles [ i ] diff old ;
60159: LD_ADDR_VAR 0 7
60163: PUSH
60164: LD_EXP 120
60168: PUSH
60169: LD_VAR 0 6
60173: ARRAY
60174: PUSH
60175: LD_VAR 0 2
60179: DIFF
60180: ST_TO_ADDR
// tmp := tmp diff new ;
60181: LD_ADDR_VAR 0 7
60185: PUSH
60186: LD_VAR 0 7
60190: PUSH
60191: LD_VAR 0 1
60195: DIFF
60196: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60197: LD_ADDR_EXP 120
60201: PUSH
60202: LD_EXP 120
60206: PPUSH
60207: LD_VAR 0 6
60211: PPUSH
60212: LD_VAR 0 7
60216: PPUSH
60217: CALL_OW 1
60221: ST_TO_ADDR
// break ;
60222: GO 60226
// end ;
60224: GO 60120
60226: POP
60227: POP
// end ;
60228: LD_VAR 0 5
60232: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60233: LD_INT 0
60235: PPUSH
60236: PPUSH
60237: PPUSH
60238: PPUSH
// if not mc_bases or not skirmish then
60239: LD_EXP 101
60243: NOT
60244: PUSH
60245: LD_EXP 99
60249: NOT
60250: OR
60251: IFFALSE 60255
// exit ;
60253: GO 60632
// side := GetSide ( vehicle ) ;
60255: LD_ADDR_VAR 0 5
60259: PUSH
60260: LD_VAR 0 1
60264: PPUSH
60265: CALL_OW 255
60269: ST_TO_ADDR
// for i = 1 to mc_bases do
60270: LD_ADDR_VAR 0 4
60274: PUSH
60275: DOUBLE
60276: LD_INT 1
60278: DEC
60279: ST_TO_ADDR
60280: LD_EXP 101
60284: PUSH
60285: FOR_TO
60286: IFFALSE 60630
// begin if factory in mc_bases [ i ] then
60288: LD_VAR 0 2
60292: PUSH
60293: LD_EXP 101
60297: PUSH
60298: LD_VAR 0 4
60302: ARRAY
60303: IN
60304: IFFALSE 60628
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60306: LD_EXP 123
60310: PUSH
60311: LD_VAR 0 4
60315: ARRAY
60316: PUSH
60317: LD_EXP 112
60321: PUSH
60322: LD_VAR 0 4
60326: ARRAY
60327: LESS
60328: PUSH
60329: LD_VAR 0 1
60333: PPUSH
60334: CALL_OW 264
60338: PUSH
60339: LD_INT 31
60341: PUSH
60342: LD_INT 32
60344: PUSH
60345: LD_INT 51
60347: PUSH
60348: LD_EXP 95
60352: PUSH
60353: LD_INT 12
60355: PUSH
60356: LD_INT 30
60358: PUSH
60359: LD_EXP 94
60363: PUSH
60364: LD_INT 11
60366: PUSH
60367: LD_INT 53
60369: PUSH
60370: LD_INT 14
60372: PUSH
60373: LD_EXP 98
60377: PUSH
60378: LD_INT 29
60380: PUSH
60381: LD_EXP 96
60385: PUSH
60386: LD_INT 13
60388: PUSH
60389: LD_INT 52
60391: PUSH
60392: LD_INT 48
60394: PUSH
60395: LD_INT 8
60397: PUSH
60398: EMPTY
60399: LIST
60400: LIST
60401: LIST
60402: LIST
60403: LIST
60404: LIST
60405: LIST
60406: LIST
60407: LIST
60408: LIST
60409: LIST
60410: LIST
60411: LIST
60412: LIST
60413: LIST
60414: LIST
60415: LIST
60416: IN
60417: NOT
60418: AND
60419: IFFALSE 60467
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60421: LD_ADDR_EXP 123
60425: PUSH
60426: LD_EXP 123
60430: PPUSH
60431: LD_VAR 0 4
60435: PUSH
60436: LD_EXP 123
60440: PUSH
60441: LD_VAR 0 4
60445: ARRAY
60446: PUSH
60447: LD_INT 1
60449: PLUS
60450: PUSH
60451: EMPTY
60452: LIST
60453: LIST
60454: PPUSH
60455: LD_VAR 0 1
60459: PPUSH
60460: CALL 71510 0 3
60464: ST_TO_ADDR
60465: GO 60511
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60467: LD_ADDR_EXP 120
60471: PUSH
60472: LD_EXP 120
60476: PPUSH
60477: LD_VAR 0 4
60481: PUSH
60482: LD_EXP 120
60486: PUSH
60487: LD_VAR 0 4
60491: ARRAY
60492: PUSH
60493: LD_INT 1
60495: PLUS
60496: PUSH
60497: EMPTY
60498: LIST
60499: LIST
60500: PPUSH
60501: LD_VAR 0 1
60505: PPUSH
60506: CALL 71510 0 3
60510: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60511: LD_VAR 0 1
60515: PPUSH
60516: CALL_OW 263
60520: PUSH
60521: LD_INT 2
60523: EQUAL
60524: IFFALSE 60544
// begin repeat wait ( 0 0$1 ) ;
60526: LD_INT 35
60528: PPUSH
60529: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60533: LD_VAR 0 1
60537: PPUSH
60538: CALL_OW 312
60542: IFFALSE 60526
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60544: LD_VAR 0 1
60548: PPUSH
60549: LD_EXP 125
60553: PUSH
60554: LD_VAR 0 4
60558: ARRAY
60559: PPUSH
60560: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60564: LD_VAR 0 1
60568: PPUSH
60569: CALL_OW 263
60573: PUSH
60574: LD_INT 1
60576: NONEQUAL
60577: IFFALSE 60581
// break ;
60579: GO 60630
// repeat wait ( 0 0$1 ) ;
60581: LD_INT 35
60583: PPUSH
60584: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60588: LD_VAR 0 1
60592: PPUSH
60593: LD_EXP 125
60597: PUSH
60598: LD_VAR 0 4
60602: ARRAY
60603: PPUSH
60604: CALL_OW 308
60608: IFFALSE 60581
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60610: LD_VAR 0 1
60614: PPUSH
60615: CALL_OW 311
60619: PPUSH
60620: CALL_OW 121
// exit ;
60624: POP
60625: POP
60626: GO 60632
// end ; end ;
60628: GO 60285
60630: POP
60631: POP
// end ;
60632: LD_VAR 0 3
60636: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60637: LD_INT 0
60639: PPUSH
60640: PPUSH
60641: PPUSH
60642: PPUSH
// if not mc_bases or not skirmish then
60643: LD_EXP 101
60647: NOT
60648: PUSH
60649: LD_EXP 99
60653: NOT
60654: OR
60655: IFFALSE 60659
// exit ;
60657: GO 61012
// repeat wait ( 0 0$1 ) ;
60659: LD_INT 35
60661: PPUSH
60662: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60666: LD_VAR 0 2
60670: PPUSH
60671: LD_VAR 0 3
60675: PPUSH
60676: CALL_OW 284
60680: IFFALSE 60659
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60682: LD_VAR 0 2
60686: PPUSH
60687: LD_VAR 0 3
60691: PPUSH
60692: CALL_OW 283
60696: PUSH
60697: LD_INT 4
60699: EQUAL
60700: IFFALSE 60704
// exit ;
60702: GO 61012
// for i = 1 to mc_bases do
60704: LD_ADDR_VAR 0 7
60708: PUSH
60709: DOUBLE
60710: LD_INT 1
60712: DEC
60713: ST_TO_ADDR
60714: LD_EXP 101
60718: PUSH
60719: FOR_TO
60720: IFFALSE 61010
// begin if mc_crates_area [ i ] then
60722: LD_EXP 119
60726: PUSH
60727: LD_VAR 0 7
60731: ARRAY
60732: IFFALSE 60843
// for j in mc_crates_area [ i ] do
60734: LD_ADDR_VAR 0 8
60738: PUSH
60739: LD_EXP 119
60743: PUSH
60744: LD_VAR 0 7
60748: ARRAY
60749: PUSH
60750: FOR_IN
60751: IFFALSE 60841
// if InArea ( x , y , j ) then
60753: LD_VAR 0 2
60757: PPUSH
60758: LD_VAR 0 3
60762: PPUSH
60763: LD_VAR 0 8
60767: PPUSH
60768: CALL_OW 309
60772: IFFALSE 60839
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60774: LD_ADDR_EXP 117
60778: PUSH
60779: LD_EXP 117
60783: PPUSH
60784: LD_VAR 0 7
60788: PUSH
60789: LD_EXP 117
60793: PUSH
60794: LD_VAR 0 7
60798: ARRAY
60799: PUSH
60800: LD_INT 1
60802: PLUS
60803: PUSH
60804: EMPTY
60805: LIST
60806: LIST
60807: PPUSH
60808: LD_VAR 0 4
60812: PUSH
60813: LD_VAR 0 2
60817: PUSH
60818: LD_VAR 0 3
60822: PUSH
60823: EMPTY
60824: LIST
60825: LIST
60826: LIST
60827: PPUSH
60828: CALL 71510 0 3
60832: ST_TO_ADDR
// exit ;
60833: POP
60834: POP
60835: POP
60836: POP
60837: GO 61012
// end ;
60839: GO 60750
60841: POP
60842: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60843: LD_ADDR_VAR 0 9
60847: PUSH
60848: LD_EXP 101
60852: PUSH
60853: LD_VAR 0 7
60857: ARRAY
60858: PPUSH
60859: LD_INT 2
60861: PUSH
60862: LD_INT 30
60864: PUSH
60865: LD_INT 0
60867: PUSH
60868: EMPTY
60869: LIST
60870: LIST
60871: PUSH
60872: LD_INT 30
60874: PUSH
60875: LD_INT 1
60877: PUSH
60878: EMPTY
60879: LIST
60880: LIST
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: LIST
60886: PPUSH
60887: CALL_OW 72
60891: ST_TO_ADDR
// if not depot then
60892: LD_VAR 0 9
60896: NOT
60897: IFFALSE 60901
// continue ;
60899: GO 60719
// for j in depot do
60901: LD_ADDR_VAR 0 8
60905: PUSH
60906: LD_VAR 0 9
60910: PUSH
60911: FOR_IN
60912: IFFALSE 61006
// if GetDistUnitXY ( j , x , y ) < 30 then
60914: LD_VAR 0 8
60918: PPUSH
60919: LD_VAR 0 2
60923: PPUSH
60924: LD_VAR 0 3
60928: PPUSH
60929: CALL_OW 297
60933: PUSH
60934: LD_INT 30
60936: LESS
60937: IFFALSE 61004
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60939: LD_ADDR_EXP 117
60943: PUSH
60944: LD_EXP 117
60948: PPUSH
60949: LD_VAR 0 7
60953: PUSH
60954: LD_EXP 117
60958: PUSH
60959: LD_VAR 0 7
60963: ARRAY
60964: PUSH
60965: LD_INT 1
60967: PLUS
60968: PUSH
60969: EMPTY
60970: LIST
60971: LIST
60972: PPUSH
60973: LD_VAR 0 4
60977: PUSH
60978: LD_VAR 0 2
60982: PUSH
60983: LD_VAR 0 3
60987: PUSH
60988: EMPTY
60989: LIST
60990: LIST
60991: LIST
60992: PPUSH
60993: CALL 71510 0 3
60997: ST_TO_ADDR
// exit ;
60998: POP
60999: POP
61000: POP
61001: POP
61002: GO 61012
// end ;
61004: GO 60911
61006: POP
61007: POP
// end ;
61008: GO 60719
61010: POP
61011: POP
// end ;
61012: LD_VAR 0 6
61016: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61017: LD_INT 0
61019: PPUSH
61020: PPUSH
61021: PPUSH
61022: PPUSH
// if not mc_bases or not skirmish then
61023: LD_EXP 101
61027: NOT
61028: PUSH
61029: LD_EXP 99
61033: NOT
61034: OR
61035: IFFALSE 61039
// exit ;
61037: GO 61316
// side := GetSide ( lab ) ;
61039: LD_ADDR_VAR 0 4
61043: PUSH
61044: LD_VAR 0 2
61048: PPUSH
61049: CALL_OW 255
61053: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61054: LD_VAR 0 4
61058: PUSH
61059: LD_EXP 127
61063: IN
61064: NOT
61065: PUSH
61066: LD_EXP 128
61070: NOT
61071: OR
61072: PUSH
61073: LD_EXP 101
61077: NOT
61078: OR
61079: IFFALSE 61083
// exit ;
61081: GO 61316
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61083: LD_ADDR_EXP 128
61087: PUSH
61088: LD_EXP 128
61092: PPUSH
61093: LD_VAR 0 4
61097: PPUSH
61098: LD_EXP 128
61102: PUSH
61103: LD_VAR 0 4
61107: ARRAY
61108: PUSH
61109: LD_VAR 0 1
61113: DIFF
61114: PPUSH
61115: CALL_OW 1
61119: ST_TO_ADDR
// for i = 1 to mc_bases do
61120: LD_ADDR_VAR 0 5
61124: PUSH
61125: DOUBLE
61126: LD_INT 1
61128: DEC
61129: ST_TO_ADDR
61130: LD_EXP 101
61134: PUSH
61135: FOR_TO
61136: IFFALSE 61314
// begin if lab in mc_bases [ i ] then
61138: LD_VAR 0 2
61142: PUSH
61143: LD_EXP 101
61147: PUSH
61148: LD_VAR 0 5
61152: ARRAY
61153: IN
61154: IFFALSE 61312
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61156: LD_VAR 0 1
61160: PUSH
61161: LD_INT 11
61163: PUSH
61164: LD_INT 4
61166: PUSH
61167: LD_INT 3
61169: PUSH
61170: LD_INT 2
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: LIST
61177: LIST
61178: IN
61179: PUSH
61180: LD_EXP 131
61184: PUSH
61185: LD_VAR 0 5
61189: ARRAY
61190: AND
61191: IFFALSE 61312
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61193: LD_ADDR_VAR 0 6
61197: PUSH
61198: LD_EXP 131
61202: PUSH
61203: LD_VAR 0 5
61207: ARRAY
61208: PUSH
61209: LD_INT 1
61211: ARRAY
61212: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61213: LD_ADDR_EXP 131
61217: PUSH
61218: LD_EXP 131
61222: PPUSH
61223: LD_VAR 0 5
61227: PPUSH
61228: EMPTY
61229: PPUSH
61230: CALL_OW 1
61234: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61235: LD_VAR 0 6
61239: PPUSH
61240: LD_INT 0
61242: PPUSH
61243: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61247: LD_VAR 0 6
61251: PPUSH
61252: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61256: LD_ADDR_EXP 130
61260: PUSH
61261: LD_EXP 130
61265: PPUSH
61266: LD_VAR 0 5
61270: PPUSH
61271: LD_EXP 130
61275: PUSH
61276: LD_VAR 0 5
61280: ARRAY
61281: PPUSH
61282: LD_INT 1
61284: PPUSH
61285: LD_VAR 0 6
61289: PPUSH
61290: CALL_OW 2
61294: PPUSH
61295: CALL_OW 1
61299: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61300: LD_VAR 0 5
61304: PPUSH
61305: LD_INT 112
61307: PPUSH
61308: CALL 38312 0 2
// end ; end ; end ;
61312: GO 61135
61314: POP
61315: POP
// end ;
61316: LD_VAR 0 3
61320: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61321: LD_INT 0
61323: PPUSH
61324: PPUSH
61325: PPUSH
61326: PPUSH
61327: PPUSH
61328: PPUSH
61329: PPUSH
61330: PPUSH
// if not mc_bases or not skirmish then
61331: LD_EXP 101
61335: NOT
61336: PUSH
61337: LD_EXP 99
61341: NOT
61342: OR
61343: IFFALSE 61347
// exit ;
61345: GO 62718
// for i = 1 to mc_bases do
61347: LD_ADDR_VAR 0 3
61351: PUSH
61352: DOUBLE
61353: LD_INT 1
61355: DEC
61356: ST_TO_ADDR
61357: LD_EXP 101
61361: PUSH
61362: FOR_TO
61363: IFFALSE 62716
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61365: LD_VAR 0 1
61369: PUSH
61370: LD_EXP 101
61374: PUSH
61375: LD_VAR 0 3
61379: ARRAY
61380: IN
61381: PUSH
61382: LD_VAR 0 1
61386: PUSH
61387: LD_EXP 108
61391: PUSH
61392: LD_VAR 0 3
61396: ARRAY
61397: IN
61398: OR
61399: PUSH
61400: LD_VAR 0 1
61404: PUSH
61405: LD_EXP 123
61409: PUSH
61410: LD_VAR 0 3
61414: ARRAY
61415: IN
61416: OR
61417: PUSH
61418: LD_VAR 0 1
61422: PUSH
61423: LD_EXP 120
61427: PUSH
61428: LD_VAR 0 3
61432: ARRAY
61433: IN
61434: OR
61435: PUSH
61436: LD_VAR 0 1
61440: PUSH
61441: LD_EXP 130
61445: PUSH
61446: LD_VAR 0 3
61450: ARRAY
61451: IN
61452: OR
61453: PUSH
61454: LD_VAR 0 1
61458: PUSH
61459: LD_EXP 131
61463: PUSH
61464: LD_VAR 0 3
61468: ARRAY
61469: IN
61470: OR
61471: IFFALSE 62714
// begin if un in mc_ape [ i ] then
61473: LD_VAR 0 1
61477: PUSH
61478: LD_EXP 130
61482: PUSH
61483: LD_VAR 0 3
61487: ARRAY
61488: IN
61489: IFFALSE 61528
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61491: LD_ADDR_EXP 130
61495: PUSH
61496: LD_EXP 130
61500: PPUSH
61501: LD_VAR 0 3
61505: PPUSH
61506: LD_EXP 130
61510: PUSH
61511: LD_VAR 0 3
61515: ARRAY
61516: PUSH
61517: LD_VAR 0 1
61521: DIFF
61522: PPUSH
61523: CALL_OW 1
61527: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61528: LD_VAR 0 1
61532: PUSH
61533: LD_EXP 131
61537: PUSH
61538: LD_VAR 0 3
61542: ARRAY
61543: IN
61544: IFFALSE 61568
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61546: LD_ADDR_EXP 131
61550: PUSH
61551: LD_EXP 131
61555: PPUSH
61556: LD_VAR 0 3
61560: PPUSH
61561: EMPTY
61562: PPUSH
61563: CALL_OW 1
61567: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61568: LD_VAR 0 1
61572: PPUSH
61573: CALL_OW 247
61577: PUSH
61578: LD_INT 2
61580: EQUAL
61581: PUSH
61582: LD_VAR 0 1
61586: PPUSH
61587: CALL_OW 110
61591: PUSH
61592: LD_INT 20
61594: EQUAL
61595: PUSH
61596: LD_VAR 0 1
61600: PUSH
61601: LD_EXP 123
61605: PUSH
61606: LD_VAR 0 3
61610: ARRAY
61611: IN
61612: OR
61613: PUSH
61614: LD_VAR 0 1
61618: PPUSH
61619: CALL_OW 264
61623: PUSH
61624: LD_INT 12
61626: PUSH
61627: LD_INT 51
61629: PUSH
61630: LD_EXP 95
61634: PUSH
61635: LD_INT 32
61637: PUSH
61638: LD_INT 13
61640: PUSH
61641: LD_INT 52
61643: PUSH
61644: LD_INT 31
61646: PUSH
61647: EMPTY
61648: LIST
61649: LIST
61650: LIST
61651: LIST
61652: LIST
61653: LIST
61654: LIST
61655: IN
61656: OR
61657: AND
61658: IFFALSE 61966
// begin if un in mc_defender [ i ] then
61660: LD_VAR 0 1
61664: PUSH
61665: LD_EXP 123
61669: PUSH
61670: LD_VAR 0 3
61674: ARRAY
61675: IN
61676: IFFALSE 61715
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61678: LD_ADDR_EXP 123
61682: PUSH
61683: LD_EXP 123
61687: PPUSH
61688: LD_VAR 0 3
61692: PPUSH
61693: LD_EXP 123
61697: PUSH
61698: LD_VAR 0 3
61702: ARRAY
61703: PUSH
61704: LD_VAR 0 1
61708: DIFF
61709: PPUSH
61710: CALL_OW 1
61714: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61715: LD_ADDR_VAR 0 8
61719: PUSH
61720: LD_VAR 0 3
61724: PPUSH
61725: LD_INT 3
61727: PPUSH
61728: CALL 58384 0 2
61732: ST_TO_ADDR
// if fac then
61733: LD_VAR 0 8
61737: IFFALSE 61966
// begin for j in fac do
61739: LD_ADDR_VAR 0 4
61743: PUSH
61744: LD_VAR 0 8
61748: PUSH
61749: FOR_IN
61750: IFFALSE 61964
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61752: LD_ADDR_VAR 0 9
61756: PUSH
61757: LD_VAR 0 8
61761: PPUSH
61762: LD_VAR 0 1
61766: PPUSH
61767: CALL_OW 265
61771: PPUSH
61772: LD_VAR 0 1
61776: PPUSH
61777: CALL_OW 262
61781: PPUSH
61782: LD_VAR 0 1
61786: PPUSH
61787: CALL_OW 263
61791: PPUSH
61792: LD_VAR 0 1
61796: PPUSH
61797: CALL_OW 264
61801: PPUSH
61802: CALL 69042 0 5
61806: ST_TO_ADDR
// if components then
61807: LD_VAR 0 9
61811: IFFALSE 61962
// begin if GetWeapon ( un ) = ar_control_tower then
61813: LD_VAR 0 1
61817: PPUSH
61818: CALL_OW 264
61822: PUSH
61823: LD_INT 31
61825: EQUAL
61826: IFFALSE 61943
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61828: LD_VAR 0 1
61832: PPUSH
61833: CALL_OW 311
61837: PPUSH
61838: LD_INT 0
61840: PPUSH
61841: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61845: LD_ADDR_EXP 141
61849: PUSH
61850: LD_EXP 141
61854: PPUSH
61855: LD_VAR 0 3
61859: PPUSH
61860: LD_EXP 141
61864: PUSH
61865: LD_VAR 0 3
61869: ARRAY
61870: PUSH
61871: LD_VAR 0 1
61875: PPUSH
61876: CALL_OW 311
61880: DIFF
61881: PPUSH
61882: CALL_OW 1
61886: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61887: LD_ADDR_VAR 0 7
61891: PUSH
61892: LD_EXP 122
61896: PUSH
61897: LD_VAR 0 3
61901: ARRAY
61902: PPUSH
61903: LD_INT 1
61905: PPUSH
61906: LD_VAR 0 9
61910: PPUSH
61911: CALL_OW 2
61915: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
61916: LD_ADDR_EXP 122
61920: PUSH
61921: LD_EXP 122
61925: PPUSH
61926: LD_VAR 0 3
61930: PPUSH
61931: LD_VAR 0 7
61935: PPUSH
61936: CALL_OW 1
61940: ST_TO_ADDR
// end else
61941: GO 61960
// MC_InsertProduceList ( i , [ components ] ) ;
61943: LD_VAR 0 3
61947: PPUSH
61948: LD_VAR 0 9
61952: PUSH
61953: EMPTY
61954: LIST
61955: PPUSH
61956: CALL 57929 0 2
// break ;
61960: GO 61964
// end ; end ;
61962: GO 61749
61964: POP
61965: POP
// end ; end ; if GetType ( un ) = unit_building then
61966: LD_VAR 0 1
61970: PPUSH
61971: CALL_OW 247
61975: PUSH
61976: LD_INT 3
61978: EQUAL
61979: IFFALSE 62382
// begin btype := GetBType ( un ) ;
61981: LD_ADDR_VAR 0 5
61985: PUSH
61986: LD_VAR 0 1
61990: PPUSH
61991: CALL_OW 266
61995: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
61996: LD_VAR 0 5
62000: PUSH
62001: LD_INT 29
62003: PUSH
62004: LD_INT 30
62006: PUSH
62007: EMPTY
62008: LIST
62009: LIST
62010: IN
62011: IFFALSE 62084
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62013: LD_VAR 0 1
62017: PPUSH
62018: CALL_OW 250
62022: PPUSH
62023: LD_VAR 0 1
62027: PPUSH
62028: CALL_OW 251
62032: PPUSH
62033: LD_VAR 0 1
62037: PPUSH
62038: CALL_OW 255
62042: PPUSH
62043: CALL_OW 440
62047: NOT
62048: IFFALSE 62084
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62050: LD_VAR 0 1
62054: PPUSH
62055: CALL_OW 250
62059: PPUSH
62060: LD_VAR 0 1
62064: PPUSH
62065: CALL_OW 251
62069: PPUSH
62070: LD_VAR 0 1
62074: PPUSH
62075: CALL_OW 255
62079: PPUSH
62080: CALL_OW 441
// end ; if btype = b_warehouse then
62084: LD_VAR 0 5
62088: PUSH
62089: LD_INT 1
62091: EQUAL
62092: IFFALSE 62110
// begin btype := b_depot ;
62094: LD_ADDR_VAR 0 5
62098: PUSH
62099: LD_INT 0
62101: ST_TO_ADDR
// pos := 1 ;
62102: LD_ADDR_VAR 0 6
62106: PUSH
62107: LD_INT 1
62109: ST_TO_ADDR
// end ; if btype = b_factory then
62110: LD_VAR 0 5
62114: PUSH
62115: LD_INT 3
62117: EQUAL
62118: IFFALSE 62136
// begin btype := b_workshop ;
62120: LD_ADDR_VAR 0 5
62124: PUSH
62125: LD_INT 2
62127: ST_TO_ADDR
// pos := 1 ;
62128: LD_ADDR_VAR 0 6
62132: PUSH
62133: LD_INT 1
62135: ST_TO_ADDR
// end ; if btype = b_barracks then
62136: LD_VAR 0 5
62140: PUSH
62141: LD_INT 5
62143: EQUAL
62144: IFFALSE 62154
// btype := b_armoury ;
62146: LD_ADDR_VAR 0 5
62150: PUSH
62151: LD_INT 4
62153: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62154: LD_VAR 0 5
62158: PUSH
62159: LD_INT 7
62161: PUSH
62162: LD_INT 8
62164: PUSH
62165: EMPTY
62166: LIST
62167: LIST
62168: IN
62169: IFFALSE 62179
// btype := b_lab ;
62171: LD_ADDR_VAR 0 5
62175: PUSH
62176: LD_INT 6
62178: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62179: LD_ADDR_EXP 106
62183: PUSH
62184: LD_EXP 106
62188: PPUSH
62189: LD_VAR 0 3
62193: PUSH
62194: LD_EXP 106
62198: PUSH
62199: LD_VAR 0 3
62203: ARRAY
62204: PUSH
62205: LD_INT 1
62207: PLUS
62208: PUSH
62209: EMPTY
62210: LIST
62211: LIST
62212: PPUSH
62213: LD_VAR 0 5
62217: PUSH
62218: LD_VAR 0 1
62222: PPUSH
62223: CALL_OW 250
62227: PUSH
62228: LD_VAR 0 1
62232: PPUSH
62233: CALL_OW 251
62237: PUSH
62238: LD_VAR 0 1
62242: PPUSH
62243: CALL_OW 254
62247: PUSH
62248: EMPTY
62249: LIST
62250: LIST
62251: LIST
62252: LIST
62253: PPUSH
62254: CALL 71510 0 3
62258: ST_TO_ADDR
// if pos = 1 then
62259: LD_VAR 0 6
62263: PUSH
62264: LD_INT 1
62266: EQUAL
62267: IFFALSE 62382
// begin tmp := mc_build_list [ i ] ;
62269: LD_ADDR_VAR 0 7
62273: PUSH
62274: LD_EXP 106
62278: PUSH
62279: LD_VAR 0 3
62283: ARRAY
62284: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62285: LD_VAR 0 7
62289: PPUSH
62290: LD_INT 2
62292: PUSH
62293: LD_INT 30
62295: PUSH
62296: LD_INT 0
62298: PUSH
62299: EMPTY
62300: LIST
62301: LIST
62302: PUSH
62303: LD_INT 30
62305: PUSH
62306: LD_INT 1
62308: PUSH
62309: EMPTY
62310: LIST
62311: LIST
62312: PUSH
62313: EMPTY
62314: LIST
62315: LIST
62316: LIST
62317: PPUSH
62318: CALL_OW 72
62322: IFFALSE 62332
// pos := 2 ;
62324: LD_ADDR_VAR 0 6
62328: PUSH
62329: LD_INT 2
62331: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62332: LD_ADDR_VAR 0 7
62336: PUSH
62337: LD_VAR 0 7
62341: PPUSH
62342: LD_VAR 0 6
62346: PPUSH
62347: LD_VAR 0 7
62351: PPUSH
62352: CALL 71836 0 3
62356: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62357: LD_ADDR_EXP 106
62361: PUSH
62362: LD_EXP 106
62366: PPUSH
62367: LD_VAR 0 3
62371: PPUSH
62372: LD_VAR 0 7
62376: PPUSH
62377: CALL_OW 1
62381: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62382: LD_VAR 0 1
62386: PUSH
62387: LD_EXP 101
62391: PUSH
62392: LD_VAR 0 3
62396: ARRAY
62397: IN
62398: IFFALSE 62437
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62400: LD_ADDR_EXP 101
62404: PUSH
62405: LD_EXP 101
62409: PPUSH
62410: LD_VAR 0 3
62414: PPUSH
62415: LD_EXP 101
62419: PUSH
62420: LD_VAR 0 3
62424: ARRAY
62425: PUSH
62426: LD_VAR 0 1
62430: DIFF
62431: PPUSH
62432: CALL_OW 1
62436: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62437: LD_VAR 0 1
62441: PUSH
62442: LD_EXP 108
62446: PUSH
62447: LD_VAR 0 3
62451: ARRAY
62452: IN
62453: IFFALSE 62492
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62455: LD_ADDR_EXP 108
62459: PUSH
62460: LD_EXP 108
62464: PPUSH
62465: LD_VAR 0 3
62469: PPUSH
62470: LD_EXP 108
62474: PUSH
62475: LD_VAR 0 3
62479: ARRAY
62480: PUSH
62481: LD_VAR 0 1
62485: DIFF
62486: PPUSH
62487: CALL_OW 1
62491: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62492: LD_VAR 0 1
62496: PUSH
62497: LD_EXP 120
62501: PUSH
62502: LD_VAR 0 3
62506: ARRAY
62507: IN
62508: IFFALSE 62547
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62510: LD_ADDR_EXP 120
62514: PUSH
62515: LD_EXP 120
62519: PPUSH
62520: LD_VAR 0 3
62524: PPUSH
62525: LD_EXP 120
62529: PUSH
62530: LD_VAR 0 3
62534: ARRAY
62535: PUSH
62536: LD_VAR 0 1
62540: DIFF
62541: PPUSH
62542: CALL_OW 1
62546: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62547: LD_VAR 0 1
62551: PUSH
62552: LD_EXP 123
62556: PUSH
62557: LD_VAR 0 3
62561: ARRAY
62562: IN
62563: IFFALSE 62602
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62565: LD_ADDR_EXP 123
62569: PUSH
62570: LD_EXP 123
62574: PPUSH
62575: LD_VAR 0 3
62579: PPUSH
62580: LD_EXP 123
62584: PUSH
62585: LD_VAR 0 3
62589: ARRAY
62590: PUSH
62591: LD_VAR 0 1
62595: DIFF
62596: PPUSH
62597: CALL_OW 1
62601: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62602: LD_VAR 0 1
62606: PUSH
62607: LD_EXP 110
62611: PUSH
62612: LD_VAR 0 3
62616: ARRAY
62617: IN
62618: IFFALSE 62657
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62620: LD_ADDR_EXP 110
62624: PUSH
62625: LD_EXP 110
62629: PPUSH
62630: LD_VAR 0 3
62634: PPUSH
62635: LD_EXP 110
62639: PUSH
62640: LD_VAR 0 3
62644: ARRAY
62645: PUSH
62646: LD_VAR 0 1
62650: DIFF
62651: PPUSH
62652: CALL_OW 1
62656: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62657: LD_VAR 0 1
62661: PUSH
62662: LD_EXP 109
62666: PUSH
62667: LD_VAR 0 3
62671: ARRAY
62672: IN
62673: IFFALSE 62712
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62675: LD_ADDR_EXP 109
62679: PUSH
62680: LD_EXP 109
62684: PPUSH
62685: LD_VAR 0 3
62689: PPUSH
62690: LD_EXP 109
62694: PUSH
62695: LD_VAR 0 3
62699: ARRAY
62700: PUSH
62701: LD_VAR 0 1
62705: DIFF
62706: PPUSH
62707: CALL_OW 1
62711: ST_TO_ADDR
// end ; break ;
62712: GO 62716
// end ;
62714: GO 61362
62716: POP
62717: POP
// end ;
62718: LD_VAR 0 2
62722: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62723: LD_INT 0
62725: PPUSH
62726: PPUSH
62727: PPUSH
// if not mc_bases or not skirmish then
62728: LD_EXP 101
62732: NOT
62733: PUSH
62734: LD_EXP 99
62738: NOT
62739: OR
62740: IFFALSE 62744
// exit ;
62742: GO 62959
// for i = 1 to mc_bases do
62744: LD_ADDR_VAR 0 3
62748: PUSH
62749: DOUBLE
62750: LD_INT 1
62752: DEC
62753: ST_TO_ADDR
62754: LD_EXP 101
62758: PUSH
62759: FOR_TO
62760: IFFALSE 62957
// begin if building in mc_construct_list [ i ] then
62762: LD_VAR 0 1
62766: PUSH
62767: LD_EXP 108
62771: PUSH
62772: LD_VAR 0 3
62776: ARRAY
62777: IN
62778: IFFALSE 62955
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62780: LD_ADDR_EXP 108
62784: PUSH
62785: LD_EXP 108
62789: PPUSH
62790: LD_VAR 0 3
62794: PPUSH
62795: LD_EXP 108
62799: PUSH
62800: LD_VAR 0 3
62804: ARRAY
62805: PUSH
62806: LD_VAR 0 1
62810: DIFF
62811: PPUSH
62812: CALL_OW 1
62816: ST_TO_ADDR
// if building in mc_lab [ i ] then
62817: LD_VAR 0 1
62821: PUSH
62822: LD_EXP 134
62826: PUSH
62827: LD_VAR 0 3
62831: ARRAY
62832: IN
62833: IFFALSE 62888
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62835: LD_ADDR_EXP 135
62839: PUSH
62840: LD_EXP 135
62844: PPUSH
62845: LD_VAR 0 3
62849: PPUSH
62850: LD_EXP 135
62854: PUSH
62855: LD_VAR 0 3
62859: ARRAY
62860: PPUSH
62861: LD_INT 1
62863: PPUSH
62864: LD_EXP 135
62868: PUSH
62869: LD_VAR 0 3
62873: ARRAY
62874: PPUSH
62875: LD_INT 0
62877: PPUSH
62878: CALL 70928 0 4
62882: PPUSH
62883: CALL_OW 1
62887: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62888: LD_VAR 0 1
62892: PUSH
62893: LD_EXP 101
62897: PUSH
62898: LD_VAR 0 3
62902: ARRAY
62903: IN
62904: NOT
62905: IFFALSE 62951
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62907: LD_ADDR_EXP 101
62911: PUSH
62912: LD_EXP 101
62916: PPUSH
62917: LD_VAR 0 3
62921: PUSH
62922: LD_EXP 101
62926: PUSH
62927: LD_VAR 0 3
62931: ARRAY
62932: PUSH
62933: LD_INT 1
62935: PLUS
62936: PUSH
62937: EMPTY
62938: LIST
62939: LIST
62940: PPUSH
62941: LD_VAR 0 1
62945: PPUSH
62946: CALL 71510 0 3
62950: ST_TO_ADDR
// exit ;
62951: POP
62952: POP
62953: GO 62959
// end ; end ;
62955: GO 62759
62957: POP
62958: POP
// end ;
62959: LD_VAR 0 2
62963: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62964: LD_INT 0
62966: PPUSH
62967: PPUSH
62968: PPUSH
62969: PPUSH
62970: PPUSH
62971: PPUSH
62972: PPUSH
// if not mc_bases or not skirmish then
62973: LD_EXP 101
62977: NOT
62978: PUSH
62979: LD_EXP 99
62983: NOT
62984: OR
62985: IFFALSE 62989
// exit ;
62987: GO 63650
// for i = 1 to mc_bases do
62989: LD_ADDR_VAR 0 3
62993: PUSH
62994: DOUBLE
62995: LD_INT 1
62997: DEC
62998: ST_TO_ADDR
62999: LD_EXP 101
63003: PUSH
63004: FOR_TO
63005: IFFALSE 63648
// begin if building in mc_construct_list [ i ] then
63007: LD_VAR 0 1
63011: PUSH
63012: LD_EXP 108
63016: PUSH
63017: LD_VAR 0 3
63021: ARRAY
63022: IN
63023: IFFALSE 63646
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63025: LD_ADDR_EXP 108
63029: PUSH
63030: LD_EXP 108
63034: PPUSH
63035: LD_VAR 0 3
63039: PPUSH
63040: LD_EXP 108
63044: PUSH
63045: LD_VAR 0 3
63049: ARRAY
63050: PUSH
63051: LD_VAR 0 1
63055: DIFF
63056: PPUSH
63057: CALL_OW 1
63061: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63062: LD_ADDR_EXP 101
63066: PUSH
63067: LD_EXP 101
63071: PPUSH
63072: LD_VAR 0 3
63076: PUSH
63077: LD_EXP 101
63081: PUSH
63082: LD_VAR 0 3
63086: ARRAY
63087: PUSH
63088: LD_INT 1
63090: PLUS
63091: PUSH
63092: EMPTY
63093: LIST
63094: LIST
63095: PPUSH
63096: LD_VAR 0 1
63100: PPUSH
63101: CALL 71510 0 3
63105: ST_TO_ADDR
// btype := GetBType ( building ) ;
63106: LD_ADDR_VAR 0 5
63110: PUSH
63111: LD_VAR 0 1
63115: PPUSH
63116: CALL_OW 266
63120: ST_TO_ADDR
// side := GetSide ( building ) ;
63121: LD_ADDR_VAR 0 8
63125: PUSH
63126: LD_VAR 0 1
63130: PPUSH
63131: CALL_OW 255
63135: ST_TO_ADDR
// if btype = b_lab then
63136: LD_VAR 0 5
63140: PUSH
63141: LD_INT 6
63143: EQUAL
63144: IFFALSE 63194
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63146: LD_ADDR_EXP 134
63150: PUSH
63151: LD_EXP 134
63155: PPUSH
63156: LD_VAR 0 3
63160: PUSH
63161: LD_EXP 134
63165: PUSH
63166: LD_VAR 0 3
63170: ARRAY
63171: PUSH
63172: LD_INT 1
63174: PLUS
63175: PUSH
63176: EMPTY
63177: LIST
63178: LIST
63179: PPUSH
63180: LD_VAR 0 1
63184: PPUSH
63185: CALL 71510 0 3
63189: ST_TO_ADDR
// exit ;
63190: POP
63191: POP
63192: GO 63650
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63194: LD_VAR 0 5
63198: PUSH
63199: LD_INT 0
63201: PUSH
63202: LD_INT 2
63204: PUSH
63205: LD_INT 4
63207: PUSH
63208: EMPTY
63209: LIST
63210: LIST
63211: LIST
63212: IN
63213: IFFALSE 63337
// begin if btype = b_armoury then
63215: LD_VAR 0 5
63219: PUSH
63220: LD_INT 4
63222: EQUAL
63223: IFFALSE 63233
// btype := b_barracks ;
63225: LD_ADDR_VAR 0 5
63229: PUSH
63230: LD_INT 5
63232: ST_TO_ADDR
// if btype = b_depot then
63233: LD_VAR 0 5
63237: PUSH
63238: LD_INT 0
63240: EQUAL
63241: IFFALSE 63251
// btype := b_warehouse ;
63243: LD_ADDR_VAR 0 5
63247: PUSH
63248: LD_INT 1
63250: ST_TO_ADDR
// if btype = b_workshop then
63251: LD_VAR 0 5
63255: PUSH
63256: LD_INT 2
63258: EQUAL
63259: IFFALSE 63269
// btype := b_factory ;
63261: LD_ADDR_VAR 0 5
63265: PUSH
63266: LD_INT 3
63268: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63269: LD_VAR 0 5
63273: PPUSH
63274: LD_VAR 0 8
63278: PPUSH
63279: CALL_OW 323
63283: PUSH
63284: LD_INT 1
63286: EQUAL
63287: IFFALSE 63333
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63289: LD_ADDR_EXP 133
63293: PUSH
63294: LD_EXP 133
63298: PPUSH
63299: LD_VAR 0 3
63303: PUSH
63304: LD_EXP 133
63308: PUSH
63309: LD_VAR 0 3
63313: ARRAY
63314: PUSH
63315: LD_INT 1
63317: PLUS
63318: PUSH
63319: EMPTY
63320: LIST
63321: LIST
63322: PPUSH
63323: LD_VAR 0 1
63327: PPUSH
63328: CALL 71510 0 3
63332: ST_TO_ADDR
// exit ;
63333: POP
63334: POP
63335: GO 63650
// end ; if btype in [ b_bunker , b_turret ] then
63337: LD_VAR 0 5
63341: PUSH
63342: LD_INT 32
63344: PUSH
63345: LD_INT 33
63347: PUSH
63348: EMPTY
63349: LIST
63350: LIST
63351: IN
63352: IFFALSE 63642
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63354: LD_ADDR_EXP 109
63358: PUSH
63359: LD_EXP 109
63363: PPUSH
63364: LD_VAR 0 3
63368: PUSH
63369: LD_EXP 109
63373: PUSH
63374: LD_VAR 0 3
63378: ARRAY
63379: PUSH
63380: LD_INT 1
63382: PLUS
63383: PUSH
63384: EMPTY
63385: LIST
63386: LIST
63387: PPUSH
63388: LD_VAR 0 1
63392: PPUSH
63393: CALL 71510 0 3
63397: ST_TO_ADDR
// if btype = b_bunker then
63398: LD_VAR 0 5
63402: PUSH
63403: LD_INT 32
63405: EQUAL
63406: IFFALSE 63642
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63408: LD_ADDR_EXP 110
63412: PUSH
63413: LD_EXP 110
63417: PPUSH
63418: LD_VAR 0 3
63422: PUSH
63423: LD_EXP 110
63427: PUSH
63428: LD_VAR 0 3
63432: ARRAY
63433: PUSH
63434: LD_INT 1
63436: PLUS
63437: PUSH
63438: EMPTY
63439: LIST
63440: LIST
63441: PPUSH
63442: LD_VAR 0 1
63446: PPUSH
63447: CALL 71510 0 3
63451: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63452: LD_ADDR_VAR 0 6
63456: PUSH
63457: LD_EXP 101
63461: PUSH
63462: LD_VAR 0 3
63466: ARRAY
63467: PPUSH
63468: LD_INT 25
63470: PUSH
63471: LD_INT 1
63473: PUSH
63474: EMPTY
63475: LIST
63476: LIST
63477: PUSH
63478: LD_INT 3
63480: PUSH
63481: LD_INT 54
63483: PUSH
63484: EMPTY
63485: LIST
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: EMPTY
63492: LIST
63493: LIST
63494: PPUSH
63495: CALL_OW 72
63499: ST_TO_ADDR
// if tmp then
63500: LD_VAR 0 6
63504: IFFALSE 63510
// exit ;
63506: POP
63507: POP
63508: GO 63650
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63510: LD_ADDR_VAR 0 6
63514: PUSH
63515: LD_EXP 101
63519: PUSH
63520: LD_VAR 0 3
63524: ARRAY
63525: PPUSH
63526: LD_INT 2
63528: PUSH
63529: LD_INT 30
63531: PUSH
63532: LD_INT 4
63534: PUSH
63535: EMPTY
63536: LIST
63537: LIST
63538: PUSH
63539: LD_INT 30
63541: PUSH
63542: LD_INT 5
63544: PUSH
63545: EMPTY
63546: LIST
63547: LIST
63548: PUSH
63549: EMPTY
63550: LIST
63551: LIST
63552: LIST
63553: PPUSH
63554: CALL_OW 72
63558: ST_TO_ADDR
// if not tmp then
63559: LD_VAR 0 6
63563: NOT
63564: IFFALSE 63570
// exit ;
63566: POP
63567: POP
63568: GO 63650
// for j in tmp do
63570: LD_ADDR_VAR 0 4
63574: PUSH
63575: LD_VAR 0 6
63579: PUSH
63580: FOR_IN
63581: IFFALSE 63640
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63583: LD_ADDR_VAR 0 7
63587: PUSH
63588: LD_VAR 0 4
63592: PPUSH
63593: CALL_OW 313
63597: PPUSH
63598: LD_INT 25
63600: PUSH
63601: LD_INT 1
63603: PUSH
63604: EMPTY
63605: LIST
63606: LIST
63607: PPUSH
63608: CALL_OW 72
63612: ST_TO_ADDR
// if units then
63613: LD_VAR 0 7
63617: IFFALSE 63638
// begin ComExitBuilding ( units [ 1 ] ) ;
63619: LD_VAR 0 7
63623: PUSH
63624: LD_INT 1
63626: ARRAY
63627: PPUSH
63628: CALL_OW 122
// exit ;
63632: POP
63633: POP
63634: POP
63635: POP
63636: GO 63650
// end ; end ;
63638: GO 63580
63640: POP
63641: POP
// end ; end ; exit ;
63642: POP
63643: POP
63644: GO 63650
// end ; end ;
63646: GO 63004
63648: POP
63649: POP
// end ;
63650: LD_VAR 0 2
63654: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63655: LD_INT 0
63657: PPUSH
63658: PPUSH
63659: PPUSH
63660: PPUSH
63661: PPUSH
63662: PPUSH
63663: PPUSH
// if not mc_bases or not skirmish then
63664: LD_EXP 101
63668: NOT
63669: PUSH
63670: LD_EXP 99
63674: NOT
63675: OR
63676: IFFALSE 63680
// exit ;
63678: GO 63911
// btype := GetBType ( building ) ;
63680: LD_ADDR_VAR 0 6
63684: PUSH
63685: LD_VAR 0 1
63689: PPUSH
63690: CALL_OW 266
63694: ST_TO_ADDR
// x := GetX ( building ) ;
63695: LD_ADDR_VAR 0 7
63699: PUSH
63700: LD_VAR 0 1
63704: PPUSH
63705: CALL_OW 250
63709: ST_TO_ADDR
// y := GetY ( building ) ;
63710: LD_ADDR_VAR 0 8
63714: PUSH
63715: LD_VAR 0 1
63719: PPUSH
63720: CALL_OW 251
63724: ST_TO_ADDR
// d := GetDir ( building ) ;
63725: LD_ADDR_VAR 0 9
63729: PUSH
63730: LD_VAR 0 1
63734: PPUSH
63735: CALL_OW 254
63739: ST_TO_ADDR
// for i = 1 to mc_bases do
63740: LD_ADDR_VAR 0 4
63744: PUSH
63745: DOUBLE
63746: LD_INT 1
63748: DEC
63749: ST_TO_ADDR
63750: LD_EXP 101
63754: PUSH
63755: FOR_TO
63756: IFFALSE 63909
// begin if not mc_build_list [ i ] then
63758: LD_EXP 106
63762: PUSH
63763: LD_VAR 0 4
63767: ARRAY
63768: NOT
63769: IFFALSE 63773
// continue ;
63771: GO 63755
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63773: LD_VAR 0 6
63777: PUSH
63778: LD_VAR 0 7
63782: PUSH
63783: LD_VAR 0 8
63787: PUSH
63788: LD_VAR 0 9
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: LIST
63797: LIST
63798: PPUSH
63799: LD_EXP 106
63803: PUSH
63804: LD_VAR 0 4
63808: ARRAY
63809: PUSH
63810: LD_INT 1
63812: ARRAY
63813: PPUSH
63814: CALL 77679 0 2
63818: IFFALSE 63907
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63820: LD_ADDR_EXP 106
63824: PUSH
63825: LD_EXP 106
63829: PPUSH
63830: LD_VAR 0 4
63834: PPUSH
63835: LD_EXP 106
63839: PUSH
63840: LD_VAR 0 4
63844: ARRAY
63845: PPUSH
63846: LD_INT 1
63848: PPUSH
63849: CALL_OW 3
63853: PPUSH
63854: CALL_OW 1
63858: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63859: LD_ADDR_EXP 108
63863: PUSH
63864: LD_EXP 108
63868: PPUSH
63869: LD_VAR 0 4
63873: PUSH
63874: LD_EXP 108
63878: PUSH
63879: LD_VAR 0 4
63883: ARRAY
63884: PUSH
63885: LD_INT 1
63887: PLUS
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PPUSH
63893: LD_VAR 0 1
63897: PPUSH
63898: CALL 71510 0 3
63902: ST_TO_ADDR
// exit ;
63903: POP
63904: POP
63905: GO 63911
// end ; end ;
63907: GO 63755
63909: POP
63910: POP
// end ;
63911: LD_VAR 0 3
63915: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63916: LD_INT 0
63918: PPUSH
63919: PPUSH
63920: PPUSH
// if not mc_bases or not skirmish then
63921: LD_EXP 101
63925: NOT
63926: PUSH
63927: LD_EXP 99
63931: NOT
63932: OR
63933: IFFALSE 63937
// exit ;
63935: GO 64127
// for i = 1 to mc_bases do
63937: LD_ADDR_VAR 0 4
63941: PUSH
63942: DOUBLE
63943: LD_INT 1
63945: DEC
63946: ST_TO_ADDR
63947: LD_EXP 101
63951: PUSH
63952: FOR_TO
63953: IFFALSE 64040
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63955: LD_VAR 0 1
63959: PUSH
63960: LD_EXP 109
63964: PUSH
63965: LD_VAR 0 4
63969: ARRAY
63970: IN
63971: PUSH
63972: LD_VAR 0 1
63976: PUSH
63977: LD_EXP 110
63981: PUSH
63982: LD_VAR 0 4
63986: ARRAY
63987: IN
63988: NOT
63989: AND
63990: IFFALSE 64038
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63992: LD_ADDR_EXP 110
63996: PUSH
63997: LD_EXP 110
64001: PPUSH
64002: LD_VAR 0 4
64006: PUSH
64007: LD_EXP 110
64011: PUSH
64012: LD_VAR 0 4
64016: ARRAY
64017: PUSH
64018: LD_INT 1
64020: PLUS
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: PPUSH
64026: LD_VAR 0 1
64030: PPUSH
64031: CALL 71510 0 3
64035: ST_TO_ADDR
// break ;
64036: GO 64040
// end ; end ;
64038: GO 63952
64040: POP
64041: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64042: LD_VAR 0 1
64046: PPUSH
64047: CALL_OW 257
64051: PUSH
64052: LD_EXP 127
64056: IN
64057: PUSH
64058: LD_VAR 0 1
64062: PPUSH
64063: CALL_OW 266
64067: PUSH
64068: LD_INT 5
64070: EQUAL
64071: AND
64072: PUSH
64073: LD_VAR 0 2
64077: PPUSH
64078: CALL_OW 110
64082: PUSH
64083: LD_INT 18
64085: NONEQUAL
64086: AND
64087: IFFALSE 64127
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64089: LD_VAR 0 2
64093: PPUSH
64094: CALL_OW 257
64098: PUSH
64099: LD_INT 5
64101: PUSH
64102: LD_INT 8
64104: PUSH
64105: LD_INT 9
64107: PUSH
64108: EMPTY
64109: LIST
64110: LIST
64111: LIST
64112: IN
64113: IFFALSE 64127
// SetClass ( unit , 1 ) ;
64115: LD_VAR 0 2
64119: PPUSH
64120: LD_INT 1
64122: PPUSH
64123: CALL_OW 336
// end ;
64127: LD_VAR 0 3
64131: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64132: LD_INT 0
64134: PPUSH
64135: PPUSH
// if not mc_bases or not skirmish then
64136: LD_EXP 101
64140: NOT
64141: PUSH
64142: LD_EXP 99
64146: NOT
64147: OR
64148: IFFALSE 64152
// exit ;
64150: GO 64268
// if GetLives ( abandoned_vehicle ) > 250 then
64152: LD_VAR 0 2
64156: PPUSH
64157: CALL_OW 256
64161: PUSH
64162: LD_INT 250
64164: GREATER
64165: IFFALSE 64169
// exit ;
64167: GO 64268
// for i = 1 to mc_bases do
64169: LD_ADDR_VAR 0 6
64173: PUSH
64174: DOUBLE
64175: LD_INT 1
64177: DEC
64178: ST_TO_ADDR
64179: LD_EXP 101
64183: PUSH
64184: FOR_TO
64185: IFFALSE 64266
// begin if driver in mc_bases [ i ] then
64187: LD_VAR 0 1
64191: PUSH
64192: LD_EXP 101
64196: PUSH
64197: LD_VAR 0 6
64201: ARRAY
64202: IN
64203: IFFALSE 64264
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64205: LD_VAR 0 1
64209: PPUSH
64210: LD_EXP 101
64214: PUSH
64215: LD_VAR 0 6
64219: ARRAY
64220: PPUSH
64221: LD_INT 2
64223: PUSH
64224: LD_INT 30
64226: PUSH
64227: LD_INT 0
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: PUSH
64234: LD_INT 30
64236: PUSH
64237: LD_INT 1
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: PUSH
64244: EMPTY
64245: LIST
64246: LIST
64247: LIST
64248: PPUSH
64249: CALL_OW 72
64253: PUSH
64254: LD_INT 1
64256: ARRAY
64257: PPUSH
64258: CALL_OW 112
// break ;
64262: GO 64266
// end ; end ;
64264: GO 64184
64266: POP
64267: POP
// end ; end_of_file
64268: LD_VAR 0 5
64272: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64273: LD_INT 0
64275: PPUSH
64276: PPUSH
// if exist_mode then
64277: LD_VAR 0 2
64281: IFFALSE 64306
// unit := CreateCharacter ( prefix & ident ) else
64283: LD_ADDR_VAR 0 5
64287: PUSH
64288: LD_VAR 0 3
64292: PUSH
64293: LD_VAR 0 1
64297: STR
64298: PPUSH
64299: CALL_OW 34
64303: ST_TO_ADDR
64304: GO 64321
// unit := NewCharacter ( ident ) ;
64306: LD_ADDR_VAR 0 5
64310: PUSH
64311: LD_VAR 0 1
64315: PPUSH
64316: CALL_OW 25
64320: ST_TO_ADDR
// result := unit ;
64321: LD_ADDR_VAR 0 4
64325: PUSH
64326: LD_VAR 0 5
64330: ST_TO_ADDR
// end ;
64331: LD_VAR 0 4
64335: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64336: LD_INT 0
64338: PPUSH
64339: PPUSH
// if not side or not nation then
64340: LD_VAR 0 1
64344: NOT
64345: PUSH
64346: LD_VAR 0 2
64350: NOT
64351: OR
64352: IFFALSE 64356
// exit ;
64354: GO 65000
// case nation of nation_american :
64356: LD_VAR 0 2
64360: PUSH
64361: LD_INT 1
64363: DOUBLE
64364: EQUAL
64365: IFTRUE 64369
64367: GO 64543
64369: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64370: LD_ADDR_VAR 0 4
64374: PUSH
64375: LD_INT 35
64377: PUSH
64378: LD_INT 45
64380: PUSH
64381: LD_INT 46
64383: PUSH
64384: LD_INT 47
64386: PUSH
64387: LD_INT 1
64389: PUSH
64390: LD_INT 2
64392: PUSH
64393: LD_INT 6
64395: PUSH
64396: LD_INT 15
64398: PUSH
64399: LD_INT 16
64401: PUSH
64402: LD_INT 7
64404: PUSH
64405: LD_INT 12
64407: PUSH
64408: LD_INT 13
64410: PUSH
64411: LD_INT 10
64413: PUSH
64414: LD_INT 14
64416: PUSH
64417: LD_INT 20
64419: PUSH
64420: LD_INT 21
64422: PUSH
64423: LD_INT 22
64425: PUSH
64426: LD_INT 25
64428: PUSH
64429: LD_INT 32
64431: PUSH
64432: LD_INT 27
64434: PUSH
64435: LD_INT 36
64437: PUSH
64438: LD_INT 69
64440: PUSH
64441: LD_INT 39
64443: PUSH
64444: LD_INT 34
64446: PUSH
64447: LD_INT 40
64449: PUSH
64450: LD_INT 48
64452: PUSH
64453: LD_INT 49
64455: PUSH
64456: LD_INT 50
64458: PUSH
64459: LD_INT 51
64461: PUSH
64462: LD_INT 52
64464: PUSH
64465: LD_INT 53
64467: PUSH
64468: LD_INT 54
64470: PUSH
64471: LD_INT 55
64473: PUSH
64474: LD_INT 56
64476: PUSH
64477: LD_INT 57
64479: PUSH
64480: LD_INT 58
64482: PUSH
64483: LD_INT 59
64485: PUSH
64486: LD_INT 60
64488: PUSH
64489: LD_INT 61
64491: PUSH
64492: LD_INT 62
64494: PUSH
64495: LD_INT 80
64497: PUSH
64498: EMPTY
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: ST_TO_ADDR
64541: GO 64924
64543: LD_INT 2
64545: DOUBLE
64546: EQUAL
64547: IFTRUE 64551
64549: GO 64733
64551: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64552: LD_ADDR_VAR 0 4
64556: PUSH
64557: LD_INT 35
64559: PUSH
64560: LD_INT 45
64562: PUSH
64563: LD_INT 46
64565: PUSH
64566: LD_INT 47
64568: PUSH
64569: LD_INT 70
64571: PUSH
64572: LD_INT 1
64574: PUSH
64575: LD_INT 11
64577: PUSH
64578: LD_INT 3
64580: PUSH
64581: LD_INT 4
64583: PUSH
64584: LD_INT 5
64586: PUSH
64587: LD_INT 6
64589: PUSH
64590: LD_INT 15
64592: PUSH
64593: LD_INT 18
64595: PUSH
64596: LD_INT 7
64598: PUSH
64599: LD_INT 17
64601: PUSH
64602: LD_INT 8
64604: PUSH
64605: LD_INT 20
64607: PUSH
64608: LD_INT 21
64610: PUSH
64611: LD_INT 22
64613: PUSH
64614: LD_INT 72
64616: PUSH
64617: LD_INT 26
64619: PUSH
64620: LD_INT 69
64622: PUSH
64623: LD_INT 39
64625: PUSH
64626: LD_INT 40
64628: PUSH
64629: LD_INT 41
64631: PUSH
64632: LD_INT 42
64634: PUSH
64635: LD_INT 43
64637: PUSH
64638: LD_INT 48
64640: PUSH
64641: LD_INT 49
64643: PUSH
64644: LD_INT 50
64646: PUSH
64647: LD_INT 51
64649: PUSH
64650: LD_INT 52
64652: PUSH
64653: LD_INT 53
64655: PUSH
64656: LD_INT 54
64658: PUSH
64659: LD_INT 55
64661: PUSH
64662: LD_INT 56
64664: PUSH
64665: LD_INT 60
64667: PUSH
64668: LD_INT 61
64670: PUSH
64671: LD_INT 62
64673: PUSH
64674: LD_INT 66
64676: PUSH
64677: LD_INT 67
64679: PUSH
64680: LD_INT 68
64682: PUSH
64683: LD_INT 81
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: LIST
64720: LIST
64721: LIST
64722: LIST
64723: LIST
64724: LIST
64725: LIST
64726: LIST
64727: LIST
64728: LIST
64729: LIST
64730: ST_TO_ADDR
64731: GO 64924
64733: LD_INT 3
64735: DOUBLE
64736: EQUAL
64737: IFTRUE 64741
64739: GO 64923
64741: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64742: LD_ADDR_VAR 0 4
64746: PUSH
64747: LD_INT 46
64749: PUSH
64750: LD_INT 47
64752: PUSH
64753: LD_INT 1
64755: PUSH
64756: LD_INT 2
64758: PUSH
64759: LD_INT 11
64761: PUSH
64762: LD_INT 9
64764: PUSH
64765: LD_INT 20
64767: PUSH
64768: LD_INT 19
64770: PUSH
64771: LD_INT 21
64773: PUSH
64774: LD_INT 24
64776: PUSH
64777: LD_INT 22
64779: PUSH
64780: LD_INT 25
64782: PUSH
64783: LD_INT 28
64785: PUSH
64786: LD_INT 29
64788: PUSH
64789: LD_INT 30
64791: PUSH
64792: LD_INT 31
64794: PUSH
64795: LD_INT 37
64797: PUSH
64798: LD_INT 38
64800: PUSH
64801: LD_INT 32
64803: PUSH
64804: LD_INT 27
64806: PUSH
64807: LD_INT 33
64809: PUSH
64810: LD_INT 69
64812: PUSH
64813: LD_INT 39
64815: PUSH
64816: LD_INT 34
64818: PUSH
64819: LD_INT 40
64821: PUSH
64822: LD_INT 71
64824: PUSH
64825: LD_INT 23
64827: PUSH
64828: LD_INT 44
64830: PUSH
64831: LD_INT 48
64833: PUSH
64834: LD_INT 49
64836: PUSH
64837: LD_INT 50
64839: PUSH
64840: LD_INT 51
64842: PUSH
64843: LD_INT 52
64845: PUSH
64846: LD_INT 53
64848: PUSH
64849: LD_INT 54
64851: PUSH
64852: LD_INT 55
64854: PUSH
64855: LD_INT 56
64857: PUSH
64858: LD_INT 57
64860: PUSH
64861: LD_INT 58
64863: PUSH
64864: LD_INT 59
64866: PUSH
64867: LD_INT 63
64869: PUSH
64870: LD_INT 64
64872: PUSH
64873: LD_INT 65
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: LIST
64880: LIST
64881: LIST
64882: LIST
64883: LIST
64884: LIST
64885: LIST
64886: LIST
64887: LIST
64888: LIST
64889: LIST
64890: LIST
64891: LIST
64892: LIST
64893: LIST
64894: LIST
64895: LIST
64896: LIST
64897: LIST
64898: LIST
64899: LIST
64900: LIST
64901: LIST
64902: LIST
64903: LIST
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: ST_TO_ADDR
64921: GO 64924
64923: POP
// if state > - 1 and state < 3 then
64924: LD_VAR 0 3
64928: PUSH
64929: LD_INT 1
64931: NEG
64932: GREATER
64933: PUSH
64934: LD_VAR 0 3
64938: PUSH
64939: LD_INT 3
64941: LESS
64942: AND
64943: IFFALSE 65000
// for i in result do
64945: LD_ADDR_VAR 0 5
64949: PUSH
64950: LD_VAR 0 4
64954: PUSH
64955: FOR_IN
64956: IFFALSE 64998
// if GetTech ( i , side ) <> state then
64958: LD_VAR 0 5
64962: PPUSH
64963: LD_VAR 0 1
64967: PPUSH
64968: CALL_OW 321
64972: PUSH
64973: LD_VAR 0 3
64977: NONEQUAL
64978: IFFALSE 64996
// result := result diff i ;
64980: LD_ADDR_VAR 0 4
64984: PUSH
64985: LD_VAR 0 4
64989: PUSH
64990: LD_VAR 0 5
64994: DIFF
64995: ST_TO_ADDR
64996: GO 64955
64998: POP
64999: POP
// end ;
65000: LD_VAR 0 4
65004: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65005: LD_INT 0
65007: PPUSH
65008: PPUSH
65009: PPUSH
// result := true ;
65010: LD_ADDR_VAR 0 3
65014: PUSH
65015: LD_INT 1
65017: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65018: LD_ADDR_VAR 0 5
65022: PUSH
65023: LD_VAR 0 2
65027: PPUSH
65028: CALL_OW 480
65032: ST_TO_ADDR
// if not tmp then
65033: LD_VAR 0 5
65037: NOT
65038: IFFALSE 65042
// exit ;
65040: GO 65091
// for i in tmp do
65042: LD_ADDR_VAR 0 4
65046: PUSH
65047: LD_VAR 0 5
65051: PUSH
65052: FOR_IN
65053: IFFALSE 65089
// if GetTech ( i , side ) <> state_researched then
65055: LD_VAR 0 4
65059: PPUSH
65060: LD_VAR 0 1
65064: PPUSH
65065: CALL_OW 321
65069: PUSH
65070: LD_INT 2
65072: NONEQUAL
65073: IFFALSE 65087
// begin result := false ;
65075: LD_ADDR_VAR 0 3
65079: PUSH
65080: LD_INT 0
65082: ST_TO_ADDR
// exit ;
65083: POP
65084: POP
65085: GO 65091
// end ;
65087: GO 65052
65089: POP
65090: POP
// end ;
65091: LD_VAR 0 3
65095: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65096: LD_INT 0
65098: PPUSH
65099: PPUSH
65100: PPUSH
65101: PPUSH
65102: PPUSH
65103: PPUSH
65104: PPUSH
65105: PPUSH
65106: PPUSH
65107: PPUSH
65108: PPUSH
65109: PPUSH
65110: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65111: LD_VAR 0 1
65115: NOT
65116: PUSH
65117: LD_VAR 0 1
65121: PPUSH
65122: CALL_OW 257
65126: PUSH
65127: LD_INT 9
65129: NONEQUAL
65130: OR
65131: IFFALSE 65135
// exit ;
65133: GO 65708
// side := GetSide ( unit ) ;
65135: LD_ADDR_VAR 0 9
65139: PUSH
65140: LD_VAR 0 1
65144: PPUSH
65145: CALL_OW 255
65149: ST_TO_ADDR
// tech_space := tech_spacanom ;
65150: LD_ADDR_VAR 0 12
65154: PUSH
65155: LD_INT 29
65157: ST_TO_ADDR
// tech_time := tech_taurad ;
65158: LD_ADDR_VAR 0 13
65162: PUSH
65163: LD_INT 28
65165: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65166: LD_ADDR_VAR 0 11
65170: PUSH
65171: LD_VAR 0 1
65175: PPUSH
65176: CALL_OW 310
65180: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65181: LD_VAR 0 11
65185: PPUSH
65186: CALL_OW 247
65190: PUSH
65191: LD_INT 2
65193: EQUAL
65194: IFFALSE 65198
// exit ;
65196: GO 65708
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65198: LD_ADDR_VAR 0 8
65202: PUSH
65203: LD_INT 81
65205: PUSH
65206: LD_VAR 0 9
65210: PUSH
65211: EMPTY
65212: LIST
65213: LIST
65214: PUSH
65215: LD_INT 3
65217: PUSH
65218: LD_INT 21
65220: PUSH
65221: LD_INT 3
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: PPUSH
65236: CALL_OW 69
65240: ST_TO_ADDR
// if not tmp then
65241: LD_VAR 0 8
65245: NOT
65246: IFFALSE 65250
// exit ;
65248: GO 65708
// if in_unit then
65250: LD_VAR 0 11
65254: IFFALSE 65278
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65256: LD_ADDR_VAR 0 10
65260: PUSH
65261: LD_VAR 0 8
65265: PPUSH
65266: LD_VAR 0 11
65270: PPUSH
65271: CALL_OW 74
65275: ST_TO_ADDR
65276: GO 65298
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65278: LD_ADDR_VAR 0 10
65282: PUSH
65283: LD_VAR 0 8
65287: PPUSH
65288: LD_VAR 0 1
65292: PPUSH
65293: CALL_OW 74
65297: ST_TO_ADDR
// if not enemy then
65298: LD_VAR 0 10
65302: NOT
65303: IFFALSE 65307
// exit ;
65305: GO 65708
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65307: LD_VAR 0 11
65311: PUSH
65312: LD_VAR 0 11
65316: PPUSH
65317: LD_VAR 0 10
65321: PPUSH
65322: CALL_OW 296
65326: PUSH
65327: LD_INT 13
65329: GREATER
65330: AND
65331: PUSH
65332: LD_VAR 0 1
65336: PPUSH
65337: LD_VAR 0 10
65341: PPUSH
65342: CALL_OW 296
65346: PUSH
65347: LD_INT 12
65349: GREATER
65350: OR
65351: IFFALSE 65355
// exit ;
65353: GO 65708
// missile := [ 1 ] ;
65355: LD_ADDR_VAR 0 14
65359: PUSH
65360: LD_INT 1
65362: PUSH
65363: EMPTY
65364: LIST
65365: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65366: LD_VAR 0 9
65370: PPUSH
65371: LD_VAR 0 12
65375: PPUSH
65376: CALL_OW 325
65380: IFFALSE 65409
// missile := Insert ( missile , missile + 1 , 2 ) ;
65382: LD_ADDR_VAR 0 14
65386: PUSH
65387: LD_VAR 0 14
65391: PPUSH
65392: LD_VAR 0 14
65396: PUSH
65397: LD_INT 1
65399: PLUS
65400: PPUSH
65401: LD_INT 2
65403: PPUSH
65404: CALL_OW 2
65408: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65409: LD_VAR 0 9
65413: PPUSH
65414: LD_VAR 0 13
65418: PPUSH
65419: CALL_OW 325
65423: PUSH
65424: LD_VAR 0 10
65428: PPUSH
65429: CALL_OW 255
65433: PPUSH
65434: LD_VAR 0 13
65438: PPUSH
65439: CALL_OW 325
65443: NOT
65444: AND
65445: IFFALSE 65474
// missile := Insert ( missile , missile + 1 , 3 ) ;
65447: LD_ADDR_VAR 0 14
65451: PUSH
65452: LD_VAR 0 14
65456: PPUSH
65457: LD_VAR 0 14
65461: PUSH
65462: LD_INT 1
65464: PLUS
65465: PPUSH
65466: LD_INT 3
65468: PPUSH
65469: CALL_OW 2
65473: ST_TO_ADDR
// if missile < 2 then
65474: LD_VAR 0 14
65478: PUSH
65479: LD_INT 2
65481: LESS
65482: IFFALSE 65486
// exit ;
65484: GO 65708
// x := GetX ( enemy ) ;
65486: LD_ADDR_VAR 0 4
65490: PUSH
65491: LD_VAR 0 10
65495: PPUSH
65496: CALL_OW 250
65500: ST_TO_ADDR
// y := GetY ( enemy ) ;
65501: LD_ADDR_VAR 0 5
65505: PUSH
65506: LD_VAR 0 10
65510: PPUSH
65511: CALL_OW 251
65515: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65516: LD_ADDR_VAR 0 6
65520: PUSH
65521: LD_VAR 0 4
65525: PUSH
65526: LD_INT 1
65528: NEG
65529: PPUSH
65530: LD_INT 1
65532: PPUSH
65533: CALL_OW 12
65537: PLUS
65538: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65539: LD_ADDR_VAR 0 7
65543: PUSH
65544: LD_VAR 0 5
65548: PUSH
65549: LD_INT 1
65551: NEG
65552: PPUSH
65553: LD_INT 1
65555: PPUSH
65556: CALL_OW 12
65560: PLUS
65561: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65562: LD_VAR 0 6
65566: PPUSH
65567: LD_VAR 0 7
65571: PPUSH
65572: CALL_OW 488
65576: NOT
65577: IFFALSE 65599
// begin _x := x ;
65579: LD_ADDR_VAR 0 6
65583: PUSH
65584: LD_VAR 0 4
65588: ST_TO_ADDR
// _y := y ;
65589: LD_ADDR_VAR 0 7
65593: PUSH
65594: LD_VAR 0 5
65598: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65599: LD_ADDR_VAR 0 3
65603: PUSH
65604: LD_INT 1
65606: PPUSH
65607: LD_VAR 0 14
65611: PPUSH
65612: CALL_OW 12
65616: ST_TO_ADDR
// case i of 1 :
65617: LD_VAR 0 3
65621: PUSH
65622: LD_INT 1
65624: DOUBLE
65625: EQUAL
65626: IFTRUE 65630
65628: GO 65647
65630: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65631: LD_VAR 0 1
65635: PPUSH
65636: LD_VAR 0 10
65640: PPUSH
65641: CALL_OW 115
65645: GO 65708
65647: LD_INT 2
65649: DOUBLE
65650: EQUAL
65651: IFTRUE 65655
65653: GO 65677
65655: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65656: LD_VAR 0 1
65660: PPUSH
65661: LD_VAR 0 6
65665: PPUSH
65666: LD_VAR 0 7
65670: PPUSH
65671: CALL_OW 153
65675: GO 65708
65677: LD_INT 3
65679: DOUBLE
65680: EQUAL
65681: IFTRUE 65685
65683: GO 65707
65685: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65686: LD_VAR 0 1
65690: PPUSH
65691: LD_VAR 0 6
65695: PPUSH
65696: LD_VAR 0 7
65700: PPUSH
65701: CALL_OW 154
65705: GO 65708
65707: POP
// end ;
65708: LD_VAR 0 2
65712: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65713: LD_INT 0
65715: PPUSH
65716: PPUSH
65717: PPUSH
65718: PPUSH
65719: PPUSH
65720: PPUSH
// if not unit or not building then
65721: LD_VAR 0 1
65725: NOT
65726: PUSH
65727: LD_VAR 0 2
65731: NOT
65732: OR
65733: IFFALSE 65737
// exit ;
65735: GO 65895
// x := GetX ( building ) ;
65737: LD_ADDR_VAR 0 5
65741: PUSH
65742: LD_VAR 0 2
65746: PPUSH
65747: CALL_OW 250
65751: ST_TO_ADDR
// y := GetY ( building ) ;
65752: LD_ADDR_VAR 0 6
65756: PUSH
65757: LD_VAR 0 2
65761: PPUSH
65762: CALL_OW 251
65766: ST_TO_ADDR
// for i = 0 to 5 do
65767: LD_ADDR_VAR 0 4
65771: PUSH
65772: DOUBLE
65773: LD_INT 0
65775: DEC
65776: ST_TO_ADDR
65777: LD_INT 5
65779: PUSH
65780: FOR_TO
65781: IFFALSE 65893
// begin _x := ShiftX ( x , i , 3 ) ;
65783: LD_ADDR_VAR 0 7
65787: PUSH
65788: LD_VAR 0 5
65792: PPUSH
65793: LD_VAR 0 4
65797: PPUSH
65798: LD_INT 3
65800: PPUSH
65801: CALL_OW 272
65805: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65806: LD_ADDR_VAR 0 8
65810: PUSH
65811: LD_VAR 0 6
65815: PPUSH
65816: LD_VAR 0 4
65820: PPUSH
65821: LD_INT 3
65823: PPUSH
65824: CALL_OW 273
65828: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65829: LD_VAR 0 7
65833: PPUSH
65834: LD_VAR 0 8
65838: PPUSH
65839: CALL_OW 488
65843: NOT
65844: IFFALSE 65848
// continue ;
65846: GO 65780
// if HexInfo ( _x , _y ) = 0 then
65848: LD_VAR 0 7
65852: PPUSH
65853: LD_VAR 0 8
65857: PPUSH
65858: CALL_OW 428
65862: PUSH
65863: LD_INT 0
65865: EQUAL
65866: IFFALSE 65891
// begin ComMoveXY ( unit , _x , _y ) ;
65868: LD_VAR 0 1
65872: PPUSH
65873: LD_VAR 0 7
65877: PPUSH
65878: LD_VAR 0 8
65882: PPUSH
65883: CALL_OW 111
// exit ;
65887: POP
65888: POP
65889: GO 65895
// end ; end ;
65891: GO 65780
65893: POP
65894: POP
// end ;
65895: LD_VAR 0 3
65899: RET
// export function ScanBase ( side , base_area ) ; begin
65900: LD_INT 0
65902: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65903: LD_ADDR_VAR 0 3
65907: PUSH
65908: LD_VAR 0 2
65912: PPUSH
65913: LD_INT 81
65915: PUSH
65916: LD_VAR 0 1
65920: PUSH
65921: EMPTY
65922: LIST
65923: LIST
65924: PPUSH
65925: CALL_OW 70
65929: ST_TO_ADDR
// end ;
65930: LD_VAR 0 3
65934: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65935: LD_INT 0
65937: PPUSH
65938: PPUSH
65939: PPUSH
65940: PPUSH
65941: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65942: LD_VAR 0 1
65946: NOT
65947: PUSH
65948: LD_EXP 101
65952: PUSH
65953: LD_VAR 0 1
65957: ARRAY
65958: NOT
65959: OR
65960: PUSH
65961: LD_VAR 0 2
65965: NOT
65966: OR
65967: PUSH
65968: LD_VAR 0 3
65972: NOT
65973: OR
65974: IFFALSE 65978
// exit ;
65976: GO 66491
// side := mc_sides [ base ] ;
65978: LD_ADDR_VAR 0 6
65982: PUSH
65983: LD_EXP 127
65987: PUSH
65988: LD_VAR 0 1
65992: ARRAY
65993: ST_TO_ADDR
// if not side then
65994: LD_VAR 0 6
65998: NOT
65999: IFFALSE 66003
// exit ;
66001: GO 66491
// for i in solds do
66003: LD_ADDR_VAR 0 7
66007: PUSH
66008: LD_VAR 0 2
66012: PUSH
66013: FOR_IN
66014: IFFALSE 66075
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66016: LD_VAR 0 7
66020: PPUSH
66021: CALL_OW 310
66025: PPUSH
66026: CALL_OW 266
66030: PUSH
66031: LD_INT 32
66033: PUSH
66034: LD_INT 31
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: IN
66041: IFFALSE 66061
// solds := solds diff i else
66043: LD_ADDR_VAR 0 2
66047: PUSH
66048: LD_VAR 0 2
66052: PUSH
66053: LD_VAR 0 7
66057: DIFF
66058: ST_TO_ADDR
66059: GO 66073
// SetTag ( i , 18 ) ;
66061: LD_VAR 0 7
66065: PPUSH
66066: LD_INT 18
66068: PPUSH
66069: CALL_OW 109
66073: GO 66013
66075: POP
66076: POP
// if not solds then
66077: LD_VAR 0 2
66081: NOT
66082: IFFALSE 66086
// exit ;
66084: GO 66491
// repeat wait ( 0 0$1 ) ;
66086: LD_INT 35
66088: PPUSH
66089: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66093: LD_ADDR_VAR 0 5
66097: PUSH
66098: LD_VAR 0 6
66102: PPUSH
66103: LD_VAR 0 3
66107: PPUSH
66108: CALL 65900 0 2
66112: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66113: LD_EXP 101
66117: PUSH
66118: LD_VAR 0 1
66122: ARRAY
66123: NOT
66124: PUSH
66125: LD_EXP 101
66129: PUSH
66130: LD_VAR 0 1
66134: ARRAY
66135: PUSH
66136: EMPTY
66137: EQUAL
66138: OR
66139: IFFALSE 66176
// begin for i in solds do
66141: LD_ADDR_VAR 0 7
66145: PUSH
66146: LD_VAR 0 2
66150: PUSH
66151: FOR_IN
66152: IFFALSE 66165
// ComStop ( i ) ;
66154: LD_VAR 0 7
66158: PPUSH
66159: CALL_OW 141
66163: GO 66151
66165: POP
66166: POP
// solds := [ ] ;
66167: LD_ADDR_VAR 0 2
66171: PUSH
66172: EMPTY
66173: ST_TO_ADDR
// exit ;
66174: GO 66491
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66176: LD_VAR 0 5
66180: NOT
66181: PUSH
66182: LD_VAR 0 5
66186: PUSH
66187: LD_INT 3
66189: GREATER
66190: OR
66191: PUSH
66192: LD_EXP 123
66196: PUSH
66197: LD_VAR 0 1
66201: ARRAY
66202: OR
66203: IFFALSE 66244
// begin for i in solds do
66205: LD_ADDR_VAR 0 7
66209: PUSH
66210: LD_VAR 0 2
66214: PUSH
66215: FOR_IN
66216: IFFALSE 66240
// if HasTask ( i ) then
66218: LD_VAR 0 7
66222: PPUSH
66223: CALL_OW 314
66227: IFFALSE 66238
// ComStop ( i ) ;
66229: LD_VAR 0 7
66233: PPUSH
66234: CALL_OW 141
66238: GO 66215
66240: POP
66241: POP
// break ;
66242: GO 66479
// end ; for i in solds do
66244: LD_ADDR_VAR 0 7
66248: PUSH
66249: LD_VAR 0 2
66253: PUSH
66254: FOR_IN
66255: IFFALSE 66471
// begin if IsInUnit ( i ) then
66257: LD_VAR 0 7
66261: PPUSH
66262: CALL_OW 310
66266: IFFALSE 66277
// ComExitBuilding ( i ) ;
66268: LD_VAR 0 7
66272: PPUSH
66273: CALL_OW 122
// if GetLives ( i ) > 333 then
66277: LD_VAR 0 7
66281: PPUSH
66282: CALL_OW 256
66286: PUSH
66287: LD_INT 333
66289: GREATER
66290: IFFALSE 66318
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66292: LD_VAR 0 7
66296: PPUSH
66297: LD_VAR 0 5
66301: PPUSH
66302: LD_VAR 0 7
66306: PPUSH
66307: CALL_OW 74
66311: PPUSH
66312: CALL_OW 115
66316: GO 66469
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66318: LD_ADDR_VAR 0 8
66322: PUSH
66323: LD_EXP 101
66327: PUSH
66328: LD_VAR 0 1
66332: ARRAY
66333: PPUSH
66334: LD_INT 2
66336: PUSH
66337: LD_INT 30
66339: PUSH
66340: LD_INT 0
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 30
66349: PUSH
66350: LD_INT 1
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: LD_INT 30
66359: PUSH
66360: LD_INT 6
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: PPUSH
66373: CALL_OW 72
66377: PPUSH
66378: LD_VAR 0 7
66382: PPUSH
66383: CALL_OW 74
66387: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66388: LD_VAR 0 7
66392: PPUSH
66393: LD_VAR 0 8
66397: PPUSH
66398: CALL_OW 250
66402: PPUSH
66403: LD_INT 3
66405: PPUSH
66406: LD_INT 5
66408: PPUSH
66409: CALL_OW 272
66413: PPUSH
66414: LD_VAR 0 8
66418: PPUSH
66419: CALL_OW 251
66423: PPUSH
66424: LD_INT 3
66426: PPUSH
66427: LD_INT 5
66429: PPUSH
66430: CALL_OW 273
66434: PPUSH
66435: CALL_OW 111
// SetTag ( i , 0 ) ;
66439: LD_VAR 0 7
66443: PPUSH
66444: LD_INT 0
66446: PPUSH
66447: CALL_OW 109
// solds := solds diff i ;
66451: LD_ADDR_VAR 0 2
66455: PUSH
66456: LD_VAR 0 2
66460: PUSH
66461: LD_VAR 0 7
66465: DIFF
66466: ST_TO_ADDR
// continue ;
66467: GO 66254
// end ; end ;
66469: GO 66254
66471: POP
66472: POP
// until solds ;
66473: LD_VAR 0 2
66477: IFFALSE 66086
// MC_Reset ( base , 18 ) ;
66479: LD_VAR 0 1
66483: PPUSH
66484: LD_INT 18
66486: PPUSH
66487: CALL 38312 0 2
// end ;
66491: LD_VAR 0 4
66495: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66496: LD_INT 0
66498: PPUSH
66499: PPUSH
66500: PPUSH
66501: PPUSH
66502: PPUSH
66503: PPUSH
66504: PPUSH
66505: PPUSH
66506: PPUSH
66507: PPUSH
66508: PPUSH
66509: PPUSH
66510: PPUSH
66511: PPUSH
66512: PPUSH
66513: PPUSH
66514: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66515: LD_ADDR_VAR 0 13
66519: PUSH
66520: LD_EXP 101
66524: PUSH
66525: LD_VAR 0 1
66529: ARRAY
66530: PPUSH
66531: LD_INT 25
66533: PUSH
66534: LD_INT 3
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PPUSH
66541: CALL_OW 72
66545: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66546: LD_EXP 141
66550: PUSH
66551: LD_VAR 0 1
66555: ARRAY
66556: IFFALSE 66580
// mechs := mechs diff mc_remote_driver [ base ] ;
66558: LD_ADDR_VAR 0 13
66562: PUSH
66563: LD_VAR 0 13
66567: PUSH
66568: LD_EXP 141
66572: PUSH
66573: LD_VAR 0 1
66577: ARRAY
66578: DIFF
66579: ST_TO_ADDR
// for i in mechs do
66580: LD_ADDR_VAR 0 5
66584: PUSH
66585: LD_VAR 0 13
66589: PUSH
66590: FOR_IN
66591: IFFALSE 66626
// if GetTag ( i ) > 0 then
66593: LD_VAR 0 5
66597: PPUSH
66598: CALL_OW 110
66602: PUSH
66603: LD_INT 0
66605: GREATER
66606: IFFALSE 66624
// mechs := mechs diff i ;
66608: LD_ADDR_VAR 0 13
66612: PUSH
66613: LD_VAR 0 13
66617: PUSH
66618: LD_VAR 0 5
66622: DIFF
66623: ST_TO_ADDR
66624: GO 66590
66626: POP
66627: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66628: LD_ADDR_VAR 0 9
66632: PUSH
66633: LD_EXP 101
66637: PUSH
66638: LD_VAR 0 1
66642: ARRAY
66643: PPUSH
66644: LD_INT 2
66646: PUSH
66647: LD_INT 25
66649: PUSH
66650: LD_INT 1
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: LD_INT 25
66659: PUSH
66660: LD_INT 5
66662: PUSH
66663: EMPTY
66664: LIST
66665: LIST
66666: PUSH
66667: LD_INT 25
66669: PUSH
66670: LD_INT 8
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 25
66679: PUSH
66680: LD_INT 9
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: LIST
66691: LIST
66692: LIST
66693: PPUSH
66694: CALL_OW 72
66698: ST_TO_ADDR
// if not defenders and not solds then
66699: LD_VAR 0 2
66703: NOT
66704: PUSH
66705: LD_VAR 0 9
66709: NOT
66710: AND
66711: IFFALSE 66715
// exit ;
66713: GO 68341
// depot_under_attack := false ;
66715: LD_ADDR_VAR 0 17
66719: PUSH
66720: LD_INT 0
66722: ST_TO_ADDR
// sold_defenders := [ ] ;
66723: LD_ADDR_VAR 0 18
66727: PUSH
66728: EMPTY
66729: ST_TO_ADDR
// if mechs then
66730: LD_VAR 0 13
66734: IFFALSE 66863
// for i in defenders do
66736: LD_ADDR_VAR 0 5
66740: PUSH
66741: LD_VAR 0 2
66745: PUSH
66746: FOR_IN
66747: IFFALSE 66861
// begin SetTag ( i , 20 ) ;
66749: LD_VAR 0 5
66753: PPUSH
66754: LD_INT 20
66756: PPUSH
66757: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66761: LD_VAR 0 5
66765: PPUSH
66766: CALL_OW 263
66770: PUSH
66771: LD_INT 1
66773: EQUAL
66774: PUSH
66775: LD_VAR 0 5
66779: PPUSH
66780: CALL_OW 311
66784: NOT
66785: AND
66786: PUSH
66787: LD_VAR 0 13
66791: AND
66792: IFFALSE 66859
// begin un := mechs [ 1 ] ;
66794: LD_ADDR_VAR 0 11
66798: PUSH
66799: LD_VAR 0 13
66803: PUSH
66804: LD_INT 1
66806: ARRAY
66807: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66808: LD_VAR 0 11
66812: PPUSH
66813: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66817: LD_VAR 0 11
66821: PPUSH
66822: LD_VAR 0 5
66826: PPUSH
66827: CALL_OW 180
// SetTag ( un , 19 ) ;
66831: LD_VAR 0 11
66835: PPUSH
66836: LD_INT 19
66838: PPUSH
66839: CALL_OW 109
// mechs := mechs diff un ;
66843: LD_ADDR_VAR 0 13
66847: PUSH
66848: LD_VAR 0 13
66852: PUSH
66853: LD_VAR 0 11
66857: DIFF
66858: ST_TO_ADDR
// end ; end ;
66859: GO 66746
66861: POP
66862: POP
// if solds then
66863: LD_VAR 0 9
66867: IFFALSE 66926
// for i in solds do
66869: LD_ADDR_VAR 0 5
66873: PUSH
66874: LD_VAR 0 9
66878: PUSH
66879: FOR_IN
66880: IFFALSE 66924
// if not GetTag ( i ) then
66882: LD_VAR 0 5
66886: PPUSH
66887: CALL_OW 110
66891: NOT
66892: IFFALSE 66922
// begin defenders := defenders union i ;
66894: LD_ADDR_VAR 0 2
66898: PUSH
66899: LD_VAR 0 2
66903: PUSH
66904: LD_VAR 0 5
66908: UNION
66909: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66910: LD_VAR 0 5
66914: PPUSH
66915: LD_INT 18
66917: PPUSH
66918: CALL_OW 109
// end ;
66922: GO 66879
66924: POP
66925: POP
// repeat wait ( 0 0$1 ) ;
66926: LD_INT 35
66928: PPUSH
66929: CALL_OW 67
// enemy := mc_scan [ base ] ;
66933: LD_ADDR_VAR 0 3
66937: PUSH
66938: LD_EXP 124
66942: PUSH
66943: LD_VAR 0 1
66947: ARRAY
66948: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66949: LD_EXP 101
66953: PUSH
66954: LD_VAR 0 1
66958: ARRAY
66959: NOT
66960: PUSH
66961: LD_EXP 101
66965: PUSH
66966: LD_VAR 0 1
66970: ARRAY
66971: PUSH
66972: EMPTY
66973: EQUAL
66974: OR
66975: IFFALSE 67012
// begin for i in defenders do
66977: LD_ADDR_VAR 0 5
66981: PUSH
66982: LD_VAR 0 2
66986: PUSH
66987: FOR_IN
66988: IFFALSE 67001
// ComStop ( i ) ;
66990: LD_VAR 0 5
66994: PPUSH
66995: CALL_OW 141
66999: GO 66987
67001: POP
67002: POP
// defenders := [ ] ;
67003: LD_ADDR_VAR 0 2
67007: PUSH
67008: EMPTY
67009: ST_TO_ADDR
// exit ;
67010: GO 68341
// end ; for i in defenders do
67012: LD_ADDR_VAR 0 5
67016: PUSH
67017: LD_VAR 0 2
67021: PUSH
67022: FOR_IN
67023: IFFALSE 67841
// begin e := NearestUnitToUnit ( enemy , i ) ;
67025: LD_ADDR_VAR 0 14
67029: PUSH
67030: LD_VAR 0 3
67034: PPUSH
67035: LD_VAR 0 5
67039: PPUSH
67040: CALL_OW 74
67044: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67045: LD_ADDR_VAR 0 8
67049: PUSH
67050: LD_EXP 101
67054: PUSH
67055: LD_VAR 0 1
67059: ARRAY
67060: PPUSH
67061: LD_INT 2
67063: PUSH
67064: LD_INT 30
67066: PUSH
67067: LD_INT 0
67069: PUSH
67070: EMPTY
67071: LIST
67072: LIST
67073: PUSH
67074: LD_INT 30
67076: PUSH
67077: LD_INT 1
67079: PUSH
67080: EMPTY
67081: LIST
67082: LIST
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: LIST
67088: PPUSH
67089: CALL_OW 72
67093: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67094: LD_ADDR_VAR 0 17
67098: PUSH
67099: LD_VAR 0 8
67103: NOT
67104: PUSH
67105: LD_VAR 0 8
67109: PPUSH
67110: LD_INT 3
67112: PUSH
67113: LD_INT 24
67115: PUSH
67116: LD_INT 600
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: PPUSH
67127: CALL_OW 72
67131: OR
67132: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67133: LD_VAR 0 5
67137: PPUSH
67138: CALL_OW 247
67142: PUSH
67143: LD_INT 2
67145: DOUBLE
67146: EQUAL
67147: IFTRUE 67151
67149: GO 67547
67151: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67152: LD_VAR 0 5
67156: PPUSH
67157: CALL_OW 256
67161: PUSH
67162: LD_INT 650
67164: GREATER
67165: PUSH
67166: LD_VAR 0 5
67170: PPUSH
67171: LD_VAR 0 14
67175: PPUSH
67176: CALL_OW 296
67180: PUSH
67181: LD_INT 40
67183: LESS
67184: PUSH
67185: LD_VAR 0 14
67189: PPUSH
67190: LD_EXP 126
67194: PUSH
67195: LD_VAR 0 1
67199: ARRAY
67200: PPUSH
67201: CALL_OW 308
67205: OR
67206: AND
67207: IFFALSE 67329
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67209: LD_VAR 0 5
67213: PPUSH
67214: CALL_OW 262
67218: PUSH
67219: LD_INT 1
67221: EQUAL
67222: PUSH
67223: LD_VAR 0 5
67227: PPUSH
67228: CALL_OW 261
67232: PUSH
67233: LD_INT 30
67235: LESS
67236: AND
67237: PUSH
67238: LD_VAR 0 8
67242: AND
67243: IFFALSE 67313
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67245: LD_VAR 0 5
67249: PPUSH
67250: LD_VAR 0 8
67254: PPUSH
67255: LD_VAR 0 5
67259: PPUSH
67260: CALL_OW 74
67264: PPUSH
67265: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67269: LD_VAR 0 5
67273: PPUSH
67274: LD_VAR 0 8
67278: PPUSH
67279: LD_VAR 0 5
67283: PPUSH
67284: CALL_OW 74
67288: PPUSH
67289: CALL_OW 296
67293: PUSH
67294: LD_INT 6
67296: LESS
67297: IFFALSE 67311
// SetFuel ( i , 100 ) ;
67299: LD_VAR 0 5
67303: PPUSH
67304: LD_INT 100
67306: PPUSH
67307: CALL_OW 240
// end else
67311: GO 67327
// ComAttackUnit ( i , e ) ;
67313: LD_VAR 0 5
67317: PPUSH
67318: LD_VAR 0 14
67322: PPUSH
67323: CALL_OW 115
// end else
67327: GO 67430
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67329: LD_VAR 0 14
67333: PPUSH
67334: LD_EXP 126
67338: PUSH
67339: LD_VAR 0 1
67343: ARRAY
67344: PPUSH
67345: CALL_OW 308
67349: NOT
67350: PUSH
67351: LD_VAR 0 5
67355: PPUSH
67356: LD_VAR 0 14
67360: PPUSH
67361: CALL_OW 296
67365: PUSH
67366: LD_INT 40
67368: GREATEREQUAL
67369: AND
67370: PUSH
67371: LD_VAR 0 5
67375: PPUSH
67376: CALL_OW 256
67380: PUSH
67381: LD_INT 650
67383: LESSEQUAL
67384: OR
67385: PUSH
67386: LD_VAR 0 5
67390: PPUSH
67391: LD_EXP 125
67395: PUSH
67396: LD_VAR 0 1
67400: ARRAY
67401: PPUSH
67402: CALL_OW 308
67406: NOT
67407: AND
67408: IFFALSE 67430
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67410: LD_VAR 0 5
67414: PPUSH
67415: LD_EXP 125
67419: PUSH
67420: LD_VAR 0 1
67424: ARRAY
67425: PPUSH
67426: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67430: LD_VAR 0 5
67434: PPUSH
67435: CALL_OW 256
67439: PUSH
67440: LD_INT 998
67442: LESS
67443: PUSH
67444: LD_VAR 0 5
67448: PPUSH
67449: CALL_OW 263
67453: PUSH
67454: LD_INT 1
67456: EQUAL
67457: AND
67458: PUSH
67459: LD_VAR 0 5
67463: PPUSH
67464: CALL_OW 311
67468: AND
67469: PUSH
67470: LD_VAR 0 5
67474: PPUSH
67475: LD_EXP 125
67479: PUSH
67480: LD_VAR 0 1
67484: ARRAY
67485: PPUSH
67486: CALL_OW 308
67490: AND
67491: IFFALSE 67545
// begin mech := IsDrivenBy ( i ) ;
67493: LD_ADDR_VAR 0 10
67497: PUSH
67498: LD_VAR 0 5
67502: PPUSH
67503: CALL_OW 311
67507: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67508: LD_VAR 0 10
67512: PPUSH
67513: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67517: LD_VAR 0 10
67521: PPUSH
67522: LD_VAR 0 5
67526: PPUSH
67527: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67531: LD_VAR 0 10
67535: PPUSH
67536: LD_VAR 0 5
67540: PPUSH
67541: CALL_OW 180
// end ; end ; unit_human :
67545: GO 67812
67547: LD_INT 1
67549: DOUBLE
67550: EQUAL
67551: IFTRUE 67555
67553: GO 67811
67555: POP
// begin b := IsInUnit ( i ) ;
67556: LD_ADDR_VAR 0 19
67560: PUSH
67561: LD_VAR 0 5
67565: PPUSH
67566: CALL_OW 310
67570: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67571: LD_ADDR_VAR 0 20
67575: PUSH
67576: LD_VAR 0 19
67580: NOT
67581: PUSH
67582: LD_VAR 0 19
67586: PPUSH
67587: CALL_OW 266
67591: PUSH
67592: LD_INT 32
67594: PUSH
67595: LD_INT 31
67597: PUSH
67598: EMPTY
67599: LIST
67600: LIST
67601: IN
67602: OR
67603: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67604: LD_VAR 0 17
67608: PUSH
67609: LD_VAR 0 2
67613: PPUSH
67614: LD_INT 21
67616: PUSH
67617: LD_INT 2
67619: PUSH
67620: EMPTY
67621: LIST
67622: LIST
67623: PPUSH
67624: CALL_OW 72
67628: PUSH
67629: LD_INT 1
67631: LESSEQUAL
67632: OR
67633: PUSH
67634: LD_VAR 0 20
67638: AND
67639: PUSH
67640: LD_VAR 0 5
67644: PUSH
67645: LD_VAR 0 18
67649: IN
67650: NOT
67651: AND
67652: IFFALSE 67745
// begin if b then
67654: LD_VAR 0 19
67658: IFFALSE 67707
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67660: LD_VAR 0 19
67664: PPUSH
67665: LD_VAR 0 3
67669: PPUSH
67670: LD_VAR 0 19
67674: PPUSH
67675: CALL_OW 74
67679: PPUSH
67680: CALL_OW 296
67684: PUSH
67685: LD_INT 10
67687: LESS
67688: PUSH
67689: LD_VAR 0 19
67693: PPUSH
67694: CALL_OW 461
67698: PUSH
67699: LD_INT 7
67701: NONEQUAL
67702: AND
67703: IFFALSE 67707
// continue ;
67705: GO 67022
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67707: LD_ADDR_VAR 0 18
67711: PUSH
67712: LD_VAR 0 18
67716: PPUSH
67717: LD_VAR 0 18
67721: PUSH
67722: LD_INT 1
67724: PLUS
67725: PPUSH
67726: LD_VAR 0 5
67730: PPUSH
67731: CALL_OW 1
67735: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67736: LD_VAR 0 5
67740: PPUSH
67741: CALL_OW 122
// end ; if sold_defenders then
67745: LD_VAR 0 18
67749: IFFALSE 67809
// if i in sold_defenders then
67751: LD_VAR 0 5
67755: PUSH
67756: LD_VAR 0 18
67760: IN
67761: IFFALSE 67809
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67763: LD_VAR 0 5
67767: PPUSH
67768: CALL_OW 314
67772: NOT
67773: PUSH
67774: LD_VAR 0 5
67778: PPUSH
67779: LD_VAR 0 14
67783: PPUSH
67784: CALL_OW 296
67788: PUSH
67789: LD_INT 30
67791: LESS
67792: AND
67793: IFFALSE 67809
// ComAttackUnit ( i , e ) ;
67795: LD_VAR 0 5
67799: PPUSH
67800: LD_VAR 0 14
67804: PPUSH
67805: CALL_OW 115
// end ; end ; end ;
67809: GO 67812
67811: POP
// if IsDead ( i ) then
67812: LD_VAR 0 5
67816: PPUSH
67817: CALL_OW 301
67821: IFFALSE 67839
// defenders := defenders diff i ;
67823: LD_ADDR_VAR 0 2
67827: PUSH
67828: LD_VAR 0 2
67832: PUSH
67833: LD_VAR 0 5
67837: DIFF
67838: ST_TO_ADDR
// end ;
67839: GO 67022
67841: POP
67842: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67843: LD_VAR 0 3
67847: NOT
67848: PUSH
67849: LD_VAR 0 2
67853: NOT
67854: OR
67855: PUSH
67856: LD_EXP 101
67860: PUSH
67861: LD_VAR 0 1
67865: ARRAY
67866: NOT
67867: OR
67868: IFFALSE 66926
// MC_Reset ( base , 18 ) ;
67870: LD_VAR 0 1
67874: PPUSH
67875: LD_INT 18
67877: PPUSH
67878: CALL 38312 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67882: LD_ADDR_VAR 0 2
67886: PUSH
67887: LD_VAR 0 2
67891: PUSH
67892: LD_VAR 0 2
67896: PPUSH
67897: LD_INT 2
67899: PUSH
67900: LD_INT 25
67902: PUSH
67903: LD_INT 1
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 25
67912: PUSH
67913: LD_INT 5
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PUSH
67920: LD_INT 25
67922: PUSH
67923: LD_INT 8
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 25
67932: PUSH
67933: LD_INT 9
67935: PUSH
67936: EMPTY
67937: LIST
67938: LIST
67939: PUSH
67940: EMPTY
67941: LIST
67942: LIST
67943: LIST
67944: LIST
67945: LIST
67946: PPUSH
67947: CALL_OW 72
67951: DIFF
67952: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67953: LD_VAR 0 3
67957: NOT
67958: PUSH
67959: LD_VAR 0 2
67963: PPUSH
67964: LD_INT 21
67966: PUSH
67967: LD_INT 2
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PPUSH
67974: CALL_OW 72
67978: AND
67979: IFFALSE 68317
// begin tmp := FilterByTag ( defenders , 19 ) ;
67981: LD_ADDR_VAR 0 12
67985: PUSH
67986: LD_VAR 0 2
67990: PPUSH
67991: LD_INT 19
67993: PPUSH
67994: CALL 104773 0 2
67998: ST_TO_ADDR
// if tmp then
67999: LD_VAR 0 12
68003: IFFALSE 68073
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68005: LD_ADDR_VAR 0 12
68009: PUSH
68010: LD_VAR 0 12
68014: PPUSH
68015: LD_INT 25
68017: PUSH
68018: LD_INT 3
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PPUSH
68025: CALL_OW 72
68029: ST_TO_ADDR
// if tmp then
68030: LD_VAR 0 12
68034: IFFALSE 68073
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68036: LD_ADDR_EXP 113
68040: PUSH
68041: LD_EXP 113
68045: PPUSH
68046: LD_VAR 0 1
68050: PPUSH
68051: LD_EXP 113
68055: PUSH
68056: LD_VAR 0 1
68060: ARRAY
68061: PUSH
68062: LD_VAR 0 12
68066: UNION
68067: PPUSH
68068: CALL_OW 1
68072: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68073: LD_VAR 0 1
68077: PPUSH
68078: LD_INT 19
68080: PPUSH
68081: CALL 38312 0 2
// repeat wait ( 0 0$1 ) ;
68085: LD_INT 35
68087: PPUSH
68088: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68092: LD_EXP 101
68096: PUSH
68097: LD_VAR 0 1
68101: ARRAY
68102: NOT
68103: PUSH
68104: LD_EXP 101
68108: PUSH
68109: LD_VAR 0 1
68113: ARRAY
68114: PUSH
68115: EMPTY
68116: EQUAL
68117: OR
68118: IFFALSE 68155
// begin for i in defenders do
68120: LD_ADDR_VAR 0 5
68124: PUSH
68125: LD_VAR 0 2
68129: PUSH
68130: FOR_IN
68131: IFFALSE 68144
// ComStop ( i ) ;
68133: LD_VAR 0 5
68137: PPUSH
68138: CALL_OW 141
68142: GO 68130
68144: POP
68145: POP
// defenders := [ ] ;
68146: LD_ADDR_VAR 0 2
68150: PUSH
68151: EMPTY
68152: ST_TO_ADDR
// exit ;
68153: GO 68341
// end ; for i in defenders do
68155: LD_ADDR_VAR 0 5
68159: PUSH
68160: LD_VAR 0 2
68164: PUSH
68165: FOR_IN
68166: IFFALSE 68255
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68168: LD_VAR 0 5
68172: PPUSH
68173: LD_EXP 125
68177: PUSH
68178: LD_VAR 0 1
68182: ARRAY
68183: PPUSH
68184: CALL_OW 308
68188: NOT
68189: IFFALSE 68213
// ComMoveToArea ( i , mc_parking [ base ] ) else
68191: LD_VAR 0 5
68195: PPUSH
68196: LD_EXP 125
68200: PUSH
68201: LD_VAR 0 1
68205: ARRAY
68206: PPUSH
68207: CALL_OW 113
68211: GO 68253
// if GetControl ( i ) = control_manual then
68213: LD_VAR 0 5
68217: PPUSH
68218: CALL_OW 263
68222: PUSH
68223: LD_INT 1
68225: EQUAL
68226: IFFALSE 68253
// if IsDrivenBy ( i ) then
68228: LD_VAR 0 5
68232: PPUSH
68233: CALL_OW 311
68237: IFFALSE 68253
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68239: LD_VAR 0 5
68243: PPUSH
68244: CALL_OW 311
68248: PPUSH
68249: CALL_OW 121
// end ;
68253: GO 68165
68255: POP
68256: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68257: LD_VAR 0 2
68261: PPUSH
68262: LD_INT 95
68264: PUSH
68265: LD_EXP 125
68269: PUSH
68270: LD_VAR 0 1
68274: ARRAY
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PPUSH
68280: CALL_OW 72
68284: PUSH
68285: LD_VAR 0 2
68289: EQUAL
68290: PUSH
68291: LD_EXP 124
68295: PUSH
68296: LD_VAR 0 1
68300: ARRAY
68301: OR
68302: PUSH
68303: LD_EXP 101
68307: PUSH
68308: LD_VAR 0 1
68312: ARRAY
68313: NOT
68314: OR
68315: IFFALSE 68085
// end ; MC_Reset ( base , 19 ) ;
68317: LD_VAR 0 1
68321: PPUSH
68322: LD_INT 19
68324: PPUSH
68325: CALL 38312 0 2
// MC_Reset ( base , 20 ) ;
68329: LD_VAR 0 1
68333: PPUSH
68334: LD_INT 20
68336: PPUSH
68337: CALL 38312 0 2
// end ;
68341: LD_VAR 0 4
68345: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68346: LD_INT 0
68348: PPUSH
68349: PPUSH
68350: PPUSH
68351: PPUSH
// result := false ;
68352: LD_ADDR_VAR 0 2
68356: PUSH
68357: LD_INT 0
68359: ST_TO_ADDR
// side := GetSide ( unit ) ;
68360: LD_ADDR_VAR 0 3
68364: PUSH
68365: LD_VAR 0 1
68369: PPUSH
68370: CALL_OW 255
68374: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68375: LD_ADDR_VAR 0 4
68379: PUSH
68380: LD_VAR 0 1
68384: PPUSH
68385: CALL_OW 248
68389: ST_TO_ADDR
// case nat of 1 :
68390: LD_VAR 0 4
68394: PUSH
68395: LD_INT 1
68397: DOUBLE
68398: EQUAL
68399: IFTRUE 68403
68401: GO 68414
68403: POP
// tech := tech_lassight ; 2 :
68404: LD_ADDR_VAR 0 5
68408: PUSH
68409: LD_INT 12
68411: ST_TO_ADDR
68412: GO 68453
68414: LD_INT 2
68416: DOUBLE
68417: EQUAL
68418: IFTRUE 68422
68420: GO 68433
68422: POP
// tech := tech_mortar ; 3 :
68423: LD_ADDR_VAR 0 5
68427: PUSH
68428: LD_INT 41
68430: ST_TO_ADDR
68431: GO 68453
68433: LD_INT 3
68435: DOUBLE
68436: EQUAL
68437: IFTRUE 68441
68439: GO 68452
68441: POP
// tech := tech_bazooka ; end ;
68442: LD_ADDR_VAR 0 5
68446: PUSH
68447: LD_INT 44
68449: ST_TO_ADDR
68450: GO 68453
68452: POP
// if Researched ( side , tech ) then
68453: LD_VAR 0 3
68457: PPUSH
68458: LD_VAR 0 5
68462: PPUSH
68463: CALL_OW 325
68467: IFFALSE 68494
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68469: LD_ADDR_VAR 0 2
68473: PUSH
68474: LD_INT 5
68476: PUSH
68477: LD_INT 8
68479: PUSH
68480: LD_INT 9
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: LIST
68487: PUSH
68488: LD_VAR 0 4
68492: ARRAY
68493: ST_TO_ADDR
// end ;
68494: LD_VAR 0 2
68498: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68499: LD_INT 0
68501: PPUSH
68502: PPUSH
68503: PPUSH
// if not mines then
68504: LD_VAR 0 2
68508: NOT
68509: IFFALSE 68513
// exit ;
68511: GO 68657
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68513: LD_ADDR_VAR 0 5
68517: PUSH
68518: LD_INT 81
68520: PUSH
68521: LD_VAR 0 1
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: PUSH
68530: LD_INT 3
68532: PUSH
68533: LD_INT 21
68535: PUSH
68536: LD_INT 3
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: PUSH
68547: EMPTY
68548: LIST
68549: LIST
68550: PPUSH
68551: CALL_OW 69
68555: ST_TO_ADDR
// for i in mines do
68556: LD_ADDR_VAR 0 4
68560: PUSH
68561: LD_VAR 0 2
68565: PUSH
68566: FOR_IN
68567: IFFALSE 68655
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68569: LD_VAR 0 4
68573: PUSH
68574: LD_INT 1
68576: ARRAY
68577: PPUSH
68578: LD_VAR 0 4
68582: PUSH
68583: LD_INT 2
68585: ARRAY
68586: PPUSH
68587: CALL_OW 458
68591: NOT
68592: IFFALSE 68596
// continue ;
68594: GO 68566
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68596: LD_VAR 0 4
68600: PUSH
68601: LD_INT 1
68603: ARRAY
68604: PPUSH
68605: LD_VAR 0 4
68609: PUSH
68610: LD_INT 2
68612: ARRAY
68613: PPUSH
68614: CALL_OW 428
68618: PUSH
68619: LD_VAR 0 5
68623: IN
68624: IFFALSE 68653
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68626: LD_VAR 0 4
68630: PUSH
68631: LD_INT 1
68633: ARRAY
68634: PPUSH
68635: LD_VAR 0 4
68639: PUSH
68640: LD_INT 2
68642: ARRAY
68643: PPUSH
68644: LD_VAR 0 1
68648: PPUSH
68649: CALL_OW 456
// end ;
68653: GO 68566
68655: POP
68656: POP
// end ;
68657: LD_VAR 0 3
68661: RET
// export function Count ( array ) ; var i ; begin
68662: LD_INT 0
68664: PPUSH
68665: PPUSH
// result := 0 ;
68666: LD_ADDR_VAR 0 2
68670: PUSH
68671: LD_INT 0
68673: ST_TO_ADDR
// for i in array do
68674: LD_ADDR_VAR 0 3
68678: PUSH
68679: LD_VAR 0 1
68683: PUSH
68684: FOR_IN
68685: IFFALSE 68709
// if i then
68687: LD_VAR 0 3
68691: IFFALSE 68707
// result := result + 1 ;
68693: LD_ADDR_VAR 0 2
68697: PUSH
68698: LD_VAR 0 2
68702: PUSH
68703: LD_INT 1
68705: PLUS
68706: ST_TO_ADDR
68707: GO 68684
68709: POP
68710: POP
// end ;
68711: LD_VAR 0 2
68715: RET
// export function IsEmpty ( building ) ; begin
68716: LD_INT 0
68718: PPUSH
// if not building then
68719: LD_VAR 0 1
68723: NOT
68724: IFFALSE 68728
// exit ;
68726: GO 68771
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68728: LD_ADDR_VAR 0 2
68732: PUSH
68733: LD_VAR 0 1
68737: PUSH
68738: LD_INT 22
68740: PUSH
68741: LD_VAR 0 1
68745: PPUSH
68746: CALL_OW 255
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: LD_INT 58
68757: PUSH
68758: EMPTY
68759: LIST
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PPUSH
68765: CALL_OW 69
68769: IN
68770: ST_TO_ADDR
// end ;
68771: LD_VAR 0 2
68775: RET
// export function IsNotFull ( building ) ; begin
68776: LD_INT 0
68778: PPUSH
// if not building then
68779: LD_VAR 0 1
68783: NOT
68784: IFFALSE 68788
// exit ;
68786: GO 68807
// result := UnitsInside ( building ) < 6 ;
68788: LD_ADDR_VAR 0 2
68792: PUSH
68793: LD_VAR 0 1
68797: PPUSH
68798: CALL_OW 313
68802: PUSH
68803: LD_INT 6
68805: LESS
68806: ST_TO_ADDR
// end ;
68807: LD_VAR 0 2
68811: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68812: LD_INT 0
68814: PPUSH
68815: PPUSH
68816: PPUSH
68817: PPUSH
// tmp := [ ] ;
68818: LD_ADDR_VAR 0 3
68822: PUSH
68823: EMPTY
68824: ST_TO_ADDR
// list := [ ] ;
68825: LD_ADDR_VAR 0 5
68829: PUSH
68830: EMPTY
68831: ST_TO_ADDR
// for i = 16 to 25 do
68832: LD_ADDR_VAR 0 4
68836: PUSH
68837: DOUBLE
68838: LD_INT 16
68840: DEC
68841: ST_TO_ADDR
68842: LD_INT 25
68844: PUSH
68845: FOR_TO
68846: IFFALSE 68919
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68848: LD_ADDR_VAR 0 3
68852: PUSH
68853: LD_VAR 0 3
68857: PUSH
68858: LD_INT 22
68860: PUSH
68861: LD_VAR 0 1
68865: PPUSH
68866: CALL_OW 255
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PUSH
68875: LD_INT 91
68877: PUSH
68878: LD_VAR 0 1
68882: PUSH
68883: LD_INT 6
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 30
68893: PUSH
68894: LD_VAR 0 4
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: LIST
68907: PUSH
68908: EMPTY
68909: LIST
68910: PPUSH
68911: CALL_OW 69
68915: ADD
68916: ST_TO_ADDR
68917: GO 68845
68919: POP
68920: POP
// for i = 1 to tmp do
68921: LD_ADDR_VAR 0 4
68925: PUSH
68926: DOUBLE
68927: LD_INT 1
68929: DEC
68930: ST_TO_ADDR
68931: LD_VAR 0 3
68935: PUSH
68936: FOR_TO
68937: IFFALSE 69025
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68939: LD_ADDR_VAR 0 5
68943: PUSH
68944: LD_VAR 0 5
68948: PUSH
68949: LD_VAR 0 3
68953: PUSH
68954: LD_VAR 0 4
68958: ARRAY
68959: PPUSH
68960: CALL_OW 266
68964: PUSH
68965: LD_VAR 0 3
68969: PUSH
68970: LD_VAR 0 4
68974: ARRAY
68975: PPUSH
68976: CALL_OW 250
68980: PUSH
68981: LD_VAR 0 3
68985: PUSH
68986: LD_VAR 0 4
68990: ARRAY
68991: PPUSH
68992: CALL_OW 251
68996: PUSH
68997: LD_VAR 0 3
69001: PUSH
69002: LD_VAR 0 4
69006: ARRAY
69007: PPUSH
69008: CALL_OW 254
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: PUSH
69019: EMPTY
69020: LIST
69021: ADD
69022: ST_TO_ADDR
69023: GO 68936
69025: POP
69026: POP
// result := list ;
69027: LD_ADDR_VAR 0 2
69031: PUSH
69032: LD_VAR 0 5
69036: ST_TO_ADDR
// end ;
69037: LD_VAR 0 2
69041: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69042: LD_INT 0
69044: PPUSH
69045: PPUSH
69046: PPUSH
69047: PPUSH
69048: PPUSH
69049: PPUSH
69050: PPUSH
// if not factory then
69051: LD_VAR 0 1
69055: NOT
69056: IFFALSE 69060
// exit ;
69058: GO 69653
// if control = control_apeman then
69060: LD_VAR 0 4
69064: PUSH
69065: LD_INT 5
69067: EQUAL
69068: IFFALSE 69177
// begin tmp := UnitsInside ( factory ) ;
69070: LD_ADDR_VAR 0 8
69074: PUSH
69075: LD_VAR 0 1
69079: PPUSH
69080: CALL_OW 313
69084: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69085: LD_VAR 0 8
69089: PPUSH
69090: LD_INT 25
69092: PUSH
69093: LD_INT 12
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PPUSH
69100: CALL_OW 72
69104: NOT
69105: IFFALSE 69115
// control := control_manual ;
69107: LD_ADDR_VAR 0 4
69111: PUSH
69112: LD_INT 1
69114: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69115: LD_ADDR_VAR 0 8
69119: PUSH
69120: LD_VAR 0 1
69124: PPUSH
69125: CALL 68812 0 1
69129: ST_TO_ADDR
// if tmp then
69130: LD_VAR 0 8
69134: IFFALSE 69177
// begin for i in tmp do
69136: LD_ADDR_VAR 0 7
69140: PUSH
69141: LD_VAR 0 8
69145: PUSH
69146: FOR_IN
69147: IFFALSE 69175
// if i [ 1 ] = b_ext_radio then
69149: LD_VAR 0 7
69153: PUSH
69154: LD_INT 1
69156: ARRAY
69157: PUSH
69158: LD_INT 22
69160: EQUAL
69161: IFFALSE 69173
// begin control := control_remote ;
69163: LD_ADDR_VAR 0 4
69167: PUSH
69168: LD_INT 2
69170: ST_TO_ADDR
// break ;
69171: GO 69175
// end ;
69173: GO 69146
69175: POP
69176: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69177: LD_VAR 0 1
69181: PPUSH
69182: LD_VAR 0 2
69186: PPUSH
69187: LD_VAR 0 3
69191: PPUSH
69192: LD_VAR 0 4
69196: PPUSH
69197: LD_VAR 0 5
69201: PPUSH
69202: CALL_OW 448
69206: IFFALSE 69241
// begin result := [ chassis , engine , control , weapon ] ;
69208: LD_ADDR_VAR 0 6
69212: PUSH
69213: LD_VAR 0 2
69217: PUSH
69218: LD_VAR 0 3
69222: PUSH
69223: LD_VAR 0 4
69227: PUSH
69228: LD_VAR 0 5
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: ST_TO_ADDR
// exit ;
69239: GO 69653
// end ; _chassis := AvailableChassisList ( factory ) ;
69241: LD_ADDR_VAR 0 9
69245: PUSH
69246: LD_VAR 0 1
69250: PPUSH
69251: CALL_OW 475
69255: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69256: LD_ADDR_VAR 0 11
69260: PUSH
69261: LD_VAR 0 1
69265: PPUSH
69266: CALL_OW 476
69270: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69271: LD_ADDR_VAR 0 12
69275: PUSH
69276: LD_VAR 0 1
69280: PPUSH
69281: CALL_OW 477
69285: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69286: LD_ADDR_VAR 0 10
69290: PUSH
69291: LD_VAR 0 1
69295: PPUSH
69296: CALL_OW 478
69300: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69301: LD_VAR 0 9
69305: NOT
69306: PUSH
69307: LD_VAR 0 11
69311: NOT
69312: OR
69313: PUSH
69314: LD_VAR 0 12
69318: NOT
69319: OR
69320: PUSH
69321: LD_VAR 0 10
69325: NOT
69326: OR
69327: IFFALSE 69362
// begin result := [ chassis , engine , control , weapon ] ;
69329: LD_ADDR_VAR 0 6
69333: PUSH
69334: LD_VAR 0 2
69338: PUSH
69339: LD_VAR 0 3
69343: PUSH
69344: LD_VAR 0 4
69348: PUSH
69349: LD_VAR 0 5
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: ST_TO_ADDR
// exit ;
69360: GO 69653
// end ; if not chassis in _chassis then
69362: LD_VAR 0 2
69366: PUSH
69367: LD_VAR 0 9
69371: IN
69372: NOT
69373: IFFALSE 69399
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69375: LD_ADDR_VAR 0 2
69379: PUSH
69380: LD_VAR 0 9
69384: PUSH
69385: LD_INT 1
69387: PPUSH
69388: LD_VAR 0 9
69392: PPUSH
69393: CALL_OW 12
69397: ARRAY
69398: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69399: LD_VAR 0 2
69403: PPUSH
69404: LD_VAR 0 3
69408: PPUSH
69409: CALL 69658 0 2
69413: NOT
69414: IFFALSE 69473
// repeat engine := _engine [ 1 ] ;
69416: LD_ADDR_VAR 0 3
69420: PUSH
69421: LD_VAR 0 11
69425: PUSH
69426: LD_INT 1
69428: ARRAY
69429: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69430: LD_ADDR_VAR 0 11
69434: PUSH
69435: LD_VAR 0 11
69439: PPUSH
69440: LD_INT 1
69442: PPUSH
69443: CALL_OW 3
69447: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69448: LD_VAR 0 2
69452: PPUSH
69453: LD_VAR 0 3
69457: PPUSH
69458: CALL 69658 0 2
69462: PUSH
69463: LD_VAR 0 11
69467: PUSH
69468: EMPTY
69469: EQUAL
69470: OR
69471: IFFALSE 69416
// if not control in _control then
69473: LD_VAR 0 4
69477: PUSH
69478: LD_VAR 0 12
69482: IN
69483: NOT
69484: IFFALSE 69510
// control := _control [ rand ( 1 , _control ) ] ;
69486: LD_ADDR_VAR 0 4
69490: PUSH
69491: LD_VAR 0 12
69495: PUSH
69496: LD_INT 1
69498: PPUSH
69499: LD_VAR 0 12
69503: PPUSH
69504: CALL_OW 12
69508: ARRAY
69509: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69510: LD_VAR 0 2
69514: PPUSH
69515: LD_VAR 0 5
69519: PPUSH
69520: CALL 69878 0 2
69524: NOT
69525: IFFALSE 69584
// repeat weapon := _weapon [ 1 ] ;
69527: LD_ADDR_VAR 0 5
69531: PUSH
69532: LD_VAR 0 10
69536: PUSH
69537: LD_INT 1
69539: ARRAY
69540: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69541: LD_ADDR_VAR 0 10
69545: PUSH
69546: LD_VAR 0 10
69550: PPUSH
69551: LD_INT 1
69553: PPUSH
69554: CALL_OW 3
69558: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69559: LD_VAR 0 2
69563: PPUSH
69564: LD_VAR 0 5
69568: PPUSH
69569: CALL 69878 0 2
69573: PUSH
69574: LD_VAR 0 10
69578: PUSH
69579: EMPTY
69580: EQUAL
69581: OR
69582: IFFALSE 69527
// result := [ ] ;
69584: LD_ADDR_VAR 0 6
69588: PUSH
69589: EMPTY
69590: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69591: LD_VAR 0 1
69595: PPUSH
69596: LD_VAR 0 2
69600: PPUSH
69601: LD_VAR 0 3
69605: PPUSH
69606: LD_VAR 0 4
69610: PPUSH
69611: LD_VAR 0 5
69615: PPUSH
69616: CALL_OW 448
69620: IFFALSE 69653
// result := [ chassis , engine , control , weapon ] ;
69622: LD_ADDR_VAR 0 6
69626: PUSH
69627: LD_VAR 0 2
69631: PUSH
69632: LD_VAR 0 3
69636: PUSH
69637: LD_VAR 0 4
69641: PUSH
69642: LD_VAR 0 5
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: LIST
69651: LIST
69652: ST_TO_ADDR
// end ;
69653: LD_VAR 0 6
69657: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69658: LD_INT 0
69660: PPUSH
// if not chassis or not engine then
69661: LD_VAR 0 1
69665: NOT
69666: PUSH
69667: LD_VAR 0 2
69671: NOT
69672: OR
69673: IFFALSE 69677
// exit ;
69675: GO 69873
// case engine of engine_solar :
69677: LD_VAR 0 2
69681: PUSH
69682: LD_INT 2
69684: DOUBLE
69685: EQUAL
69686: IFTRUE 69690
69688: GO 69728
69690: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69691: LD_ADDR_VAR 0 3
69695: PUSH
69696: LD_INT 11
69698: PUSH
69699: LD_INT 12
69701: PUSH
69702: LD_INT 13
69704: PUSH
69705: LD_INT 14
69707: PUSH
69708: LD_INT 1
69710: PUSH
69711: LD_INT 2
69713: PUSH
69714: LD_INT 3
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: ST_TO_ADDR
69726: GO 69857
69728: LD_INT 1
69730: DOUBLE
69731: EQUAL
69732: IFTRUE 69736
69734: GO 69798
69736: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69737: LD_ADDR_VAR 0 3
69741: PUSH
69742: LD_INT 11
69744: PUSH
69745: LD_INT 12
69747: PUSH
69748: LD_INT 13
69750: PUSH
69751: LD_INT 14
69753: PUSH
69754: LD_INT 1
69756: PUSH
69757: LD_INT 2
69759: PUSH
69760: LD_INT 3
69762: PUSH
69763: LD_INT 4
69765: PUSH
69766: LD_INT 5
69768: PUSH
69769: LD_INT 21
69771: PUSH
69772: LD_INT 23
69774: PUSH
69775: LD_INT 22
69777: PUSH
69778: LD_INT 24
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: LIST
69788: LIST
69789: LIST
69790: LIST
69791: LIST
69792: LIST
69793: LIST
69794: LIST
69795: ST_TO_ADDR
69796: GO 69857
69798: LD_INT 3
69800: DOUBLE
69801: EQUAL
69802: IFTRUE 69806
69804: GO 69856
69806: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69807: LD_ADDR_VAR 0 3
69811: PUSH
69812: LD_INT 13
69814: PUSH
69815: LD_INT 14
69817: PUSH
69818: LD_INT 2
69820: PUSH
69821: LD_INT 3
69823: PUSH
69824: LD_INT 4
69826: PUSH
69827: LD_INT 5
69829: PUSH
69830: LD_INT 21
69832: PUSH
69833: LD_INT 22
69835: PUSH
69836: LD_INT 23
69838: PUSH
69839: LD_INT 24
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: ST_TO_ADDR
69854: GO 69857
69856: POP
// result := ( chassis in result ) ;
69857: LD_ADDR_VAR 0 3
69861: PUSH
69862: LD_VAR 0 1
69866: PUSH
69867: LD_VAR 0 3
69871: IN
69872: ST_TO_ADDR
// end ;
69873: LD_VAR 0 3
69877: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69878: LD_INT 0
69880: PPUSH
// if not chassis or not weapon then
69881: LD_VAR 0 1
69885: NOT
69886: PUSH
69887: LD_VAR 0 2
69891: NOT
69892: OR
69893: IFFALSE 69897
// exit ;
69895: GO 70923
// case weapon of us_machine_gun :
69897: LD_VAR 0 2
69901: PUSH
69902: LD_INT 2
69904: DOUBLE
69905: EQUAL
69906: IFTRUE 69910
69908: GO 69940
69910: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69911: LD_ADDR_VAR 0 3
69915: PUSH
69916: LD_INT 1
69918: PUSH
69919: LD_INT 2
69921: PUSH
69922: LD_INT 3
69924: PUSH
69925: LD_INT 4
69927: PUSH
69928: LD_INT 5
69930: PUSH
69931: EMPTY
69932: LIST
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: ST_TO_ADDR
69938: GO 70907
69940: LD_INT 3
69942: DOUBLE
69943: EQUAL
69944: IFTRUE 69948
69946: GO 69978
69948: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69949: LD_ADDR_VAR 0 3
69953: PUSH
69954: LD_INT 1
69956: PUSH
69957: LD_INT 2
69959: PUSH
69960: LD_INT 3
69962: PUSH
69963: LD_INT 4
69965: PUSH
69966: LD_INT 5
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: ST_TO_ADDR
69976: GO 70907
69978: LD_INT 11
69980: DOUBLE
69981: EQUAL
69982: IFTRUE 69986
69984: GO 70016
69986: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69987: LD_ADDR_VAR 0 3
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: LD_INT 2
69997: PUSH
69998: LD_INT 3
70000: PUSH
70001: LD_INT 4
70003: PUSH
70004: LD_INT 5
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: ST_TO_ADDR
70014: GO 70907
70016: LD_INT 4
70018: DOUBLE
70019: EQUAL
70020: IFTRUE 70024
70022: GO 70050
70024: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70025: LD_ADDR_VAR 0 3
70029: PUSH
70030: LD_INT 2
70032: PUSH
70033: LD_INT 3
70035: PUSH
70036: LD_INT 4
70038: PUSH
70039: LD_INT 5
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: ST_TO_ADDR
70048: GO 70907
70050: LD_INT 5
70052: DOUBLE
70053: EQUAL
70054: IFTRUE 70058
70056: GO 70084
70058: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70059: LD_ADDR_VAR 0 3
70063: PUSH
70064: LD_INT 2
70066: PUSH
70067: LD_INT 3
70069: PUSH
70070: LD_INT 4
70072: PUSH
70073: LD_INT 5
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: ST_TO_ADDR
70082: GO 70907
70084: LD_INT 9
70086: DOUBLE
70087: EQUAL
70088: IFTRUE 70092
70090: GO 70118
70092: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70093: LD_ADDR_VAR 0 3
70097: PUSH
70098: LD_INT 2
70100: PUSH
70101: LD_INT 3
70103: PUSH
70104: LD_INT 4
70106: PUSH
70107: LD_INT 5
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: ST_TO_ADDR
70116: GO 70907
70118: LD_INT 7
70120: DOUBLE
70121: EQUAL
70122: IFTRUE 70126
70124: GO 70152
70126: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70127: LD_ADDR_VAR 0 3
70131: PUSH
70132: LD_INT 2
70134: PUSH
70135: LD_INT 3
70137: PUSH
70138: LD_INT 4
70140: PUSH
70141: LD_INT 5
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: ST_TO_ADDR
70150: GO 70907
70152: LD_INT 12
70154: DOUBLE
70155: EQUAL
70156: IFTRUE 70160
70158: GO 70186
70160: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70161: LD_ADDR_VAR 0 3
70165: PUSH
70166: LD_INT 2
70168: PUSH
70169: LD_INT 3
70171: PUSH
70172: LD_INT 4
70174: PUSH
70175: LD_INT 5
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: ST_TO_ADDR
70184: GO 70907
70186: LD_INT 13
70188: DOUBLE
70189: EQUAL
70190: IFTRUE 70194
70192: GO 70220
70194: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70195: LD_ADDR_VAR 0 3
70199: PUSH
70200: LD_INT 2
70202: PUSH
70203: LD_INT 3
70205: PUSH
70206: LD_INT 4
70208: PUSH
70209: LD_INT 5
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: ST_TO_ADDR
70218: GO 70907
70220: LD_INT 14
70222: DOUBLE
70223: EQUAL
70224: IFTRUE 70228
70226: GO 70246
70228: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70229: LD_ADDR_VAR 0 3
70233: PUSH
70234: LD_INT 4
70236: PUSH
70237: LD_INT 5
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: ST_TO_ADDR
70244: GO 70907
70246: LD_INT 6
70248: DOUBLE
70249: EQUAL
70250: IFTRUE 70254
70252: GO 70272
70254: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70255: LD_ADDR_VAR 0 3
70259: PUSH
70260: LD_INT 4
70262: PUSH
70263: LD_INT 5
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: ST_TO_ADDR
70270: GO 70907
70272: LD_INT 10
70274: DOUBLE
70275: EQUAL
70276: IFTRUE 70280
70278: GO 70298
70280: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70281: LD_ADDR_VAR 0 3
70285: PUSH
70286: LD_INT 4
70288: PUSH
70289: LD_INT 5
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: ST_TO_ADDR
70296: GO 70907
70298: LD_INT 22
70300: DOUBLE
70301: EQUAL
70302: IFTRUE 70306
70304: GO 70332
70306: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70307: LD_ADDR_VAR 0 3
70311: PUSH
70312: LD_INT 11
70314: PUSH
70315: LD_INT 12
70317: PUSH
70318: LD_INT 13
70320: PUSH
70321: LD_INT 14
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: ST_TO_ADDR
70330: GO 70907
70332: LD_INT 23
70334: DOUBLE
70335: EQUAL
70336: IFTRUE 70340
70338: GO 70366
70340: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70341: LD_ADDR_VAR 0 3
70345: PUSH
70346: LD_INT 11
70348: PUSH
70349: LD_INT 12
70351: PUSH
70352: LD_INT 13
70354: PUSH
70355: LD_INT 14
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: LIST
70362: LIST
70363: ST_TO_ADDR
70364: GO 70907
70366: LD_INT 24
70368: DOUBLE
70369: EQUAL
70370: IFTRUE 70374
70372: GO 70400
70374: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70375: LD_ADDR_VAR 0 3
70379: PUSH
70380: LD_INT 11
70382: PUSH
70383: LD_INT 12
70385: PUSH
70386: LD_INT 13
70388: PUSH
70389: LD_INT 14
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: LIST
70396: LIST
70397: ST_TO_ADDR
70398: GO 70907
70400: LD_INT 30
70402: DOUBLE
70403: EQUAL
70404: IFTRUE 70408
70406: GO 70434
70408: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70409: LD_ADDR_VAR 0 3
70413: PUSH
70414: LD_INT 11
70416: PUSH
70417: LD_INT 12
70419: PUSH
70420: LD_INT 13
70422: PUSH
70423: LD_INT 14
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: ST_TO_ADDR
70432: GO 70907
70434: LD_INT 25
70436: DOUBLE
70437: EQUAL
70438: IFTRUE 70442
70440: GO 70460
70442: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70443: LD_ADDR_VAR 0 3
70447: PUSH
70448: LD_INT 13
70450: PUSH
70451: LD_INT 14
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: ST_TO_ADDR
70458: GO 70907
70460: LD_INT 27
70462: DOUBLE
70463: EQUAL
70464: IFTRUE 70468
70466: GO 70486
70468: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70469: LD_ADDR_VAR 0 3
70473: PUSH
70474: LD_INT 13
70476: PUSH
70477: LD_INT 14
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: ST_TO_ADDR
70484: GO 70907
70486: LD_INT 28
70488: DOUBLE
70489: EQUAL
70490: IFTRUE 70494
70492: GO 70512
70494: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70495: LD_ADDR_VAR 0 3
70499: PUSH
70500: LD_INT 13
70502: PUSH
70503: LD_INT 14
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: ST_TO_ADDR
70510: GO 70907
70512: LD_INT 29
70514: DOUBLE
70515: EQUAL
70516: IFTRUE 70520
70518: GO 70538
70520: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70521: LD_ADDR_VAR 0 3
70525: PUSH
70526: LD_INT 13
70528: PUSH
70529: LD_INT 14
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: ST_TO_ADDR
70536: GO 70907
70538: LD_INT 31
70540: DOUBLE
70541: EQUAL
70542: IFTRUE 70546
70544: GO 70564
70546: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70547: LD_ADDR_VAR 0 3
70551: PUSH
70552: LD_INT 13
70554: PUSH
70555: LD_INT 14
70557: PUSH
70558: EMPTY
70559: LIST
70560: LIST
70561: ST_TO_ADDR
70562: GO 70907
70564: LD_INT 26
70566: DOUBLE
70567: EQUAL
70568: IFTRUE 70572
70570: GO 70590
70572: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70573: LD_ADDR_VAR 0 3
70577: PUSH
70578: LD_INT 13
70580: PUSH
70581: LD_INT 14
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: ST_TO_ADDR
70588: GO 70907
70590: LD_INT 42
70592: DOUBLE
70593: EQUAL
70594: IFTRUE 70598
70596: GO 70624
70598: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70599: LD_ADDR_VAR 0 3
70603: PUSH
70604: LD_INT 21
70606: PUSH
70607: LD_INT 22
70609: PUSH
70610: LD_INT 23
70612: PUSH
70613: LD_INT 24
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: ST_TO_ADDR
70622: GO 70907
70624: LD_INT 43
70626: DOUBLE
70627: EQUAL
70628: IFTRUE 70632
70630: GO 70658
70632: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70633: LD_ADDR_VAR 0 3
70637: PUSH
70638: LD_INT 21
70640: PUSH
70641: LD_INT 22
70643: PUSH
70644: LD_INT 23
70646: PUSH
70647: LD_INT 24
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: LIST
70654: LIST
70655: ST_TO_ADDR
70656: GO 70907
70658: LD_INT 44
70660: DOUBLE
70661: EQUAL
70662: IFTRUE 70666
70664: GO 70692
70666: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70667: LD_ADDR_VAR 0 3
70671: PUSH
70672: LD_INT 21
70674: PUSH
70675: LD_INT 22
70677: PUSH
70678: LD_INT 23
70680: PUSH
70681: LD_INT 24
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: LIST
70688: LIST
70689: ST_TO_ADDR
70690: GO 70907
70692: LD_INT 45
70694: DOUBLE
70695: EQUAL
70696: IFTRUE 70700
70698: GO 70726
70700: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70701: LD_ADDR_VAR 0 3
70705: PUSH
70706: LD_INT 21
70708: PUSH
70709: LD_INT 22
70711: PUSH
70712: LD_INT 23
70714: PUSH
70715: LD_INT 24
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: ST_TO_ADDR
70724: GO 70907
70726: LD_INT 49
70728: DOUBLE
70729: EQUAL
70730: IFTRUE 70734
70732: GO 70760
70734: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70735: LD_ADDR_VAR 0 3
70739: PUSH
70740: LD_INT 21
70742: PUSH
70743: LD_INT 22
70745: PUSH
70746: LD_INT 23
70748: PUSH
70749: LD_INT 24
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: ST_TO_ADDR
70758: GO 70907
70760: LD_INT 51
70762: DOUBLE
70763: EQUAL
70764: IFTRUE 70768
70766: GO 70794
70768: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70769: LD_ADDR_VAR 0 3
70773: PUSH
70774: LD_INT 21
70776: PUSH
70777: LD_INT 22
70779: PUSH
70780: LD_INT 23
70782: PUSH
70783: LD_INT 24
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: ST_TO_ADDR
70792: GO 70907
70794: LD_INT 52
70796: DOUBLE
70797: EQUAL
70798: IFTRUE 70802
70800: GO 70828
70802: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70803: LD_ADDR_VAR 0 3
70807: PUSH
70808: LD_INT 21
70810: PUSH
70811: LD_INT 22
70813: PUSH
70814: LD_INT 23
70816: PUSH
70817: LD_INT 24
70819: PUSH
70820: EMPTY
70821: LIST
70822: LIST
70823: LIST
70824: LIST
70825: ST_TO_ADDR
70826: GO 70907
70828: LD_INT 53
70830: DOUBLE
70831: EQUAL
70832: IFTRUE 70836
70834: GO 70854
70836: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70837: LD_ADDR_VAR 0 3
70841: PUSH
70842: LD_INT 23
70844: PUSH
70845: LD_INT 24
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: ST_TO_ADDR
70852: GO 70907
70854: LD_INT 46
70856: DOUBLE
70857: EQUAL
70858: IFTRUE 70862
70860: GO 70880
70862: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70863: LD_ADDR_VAR 0 3
70867: PUSH
70868: LD_INT 23
70870: PUSH
70871: LD_INT 24
70873: PUSH
70874: EMPTY
70875: LIST
70876: LIST
70877: ST_TO_ADDR
70878: GO 70907
70880: LD_INT 47
70882: DOUBLE
70883: EQUAL
70884: IFTRUE 70888
70886: GO 70906
70888: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70889: LD_ADDR_VAR 0 3
70893: PUSH
70894: LD_INT 23
70896: PUSH
70897: LD_INT 24
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: ST_TO_ADDR
70904: GO 70907
70906: POP
// result := ( chassis in result ) ;
70907: LD_ADDR_VAR 0 3
70911: PUSH
70912: LD_VAR 0 1
70916: PUSH
70917: LD_VAR 0 3
70921: IN
70922: ST_TO_ADDR
// end ;
70923: LD_VAR 0 3
70927: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70928: LD_INT 0
70930: PPUSH
70931: PPUSH
70932: PPUSH
70933: PPUSH
70934: PPUSH
70935: PPUSH
70936: PPUSH
// result := array ;
70937: LD_ADDR_VAR 0 5
70941: PUSH
70942: LD_VAR 0 1
70946: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70947: LD_VAR 0 1
70951: NOT
70952: PUSH
70953: LD_VAR 0 2
70957: NOT
70958: OR
70959: PUSH
70960: LD_VAR 0 3
70964: NOT
70965: OR
70966: PUSH
70967: LD_VAR 0 2
70971: PUSH
70972: LD_VAR 0 1
70976: GREATER
70977: OR
70978: PUSH
70979: LD_VAR 0 3
70983: PUSH
70984: LD_VAR 0 1
70988: GREATER
70989: OR
70990: IFFALSE 70994
// exit ;
70992: GO 71290
// if direction then
70994: LD_VAR 0 4
70998: IFFALSE 71062
// begin d := 1 ;
71000: LD_ADDR_VAR 0 9
71004: PUSH
71005: LD_INT 1
71007: ST_TO_ADDR
// if i_from > i_to then
71008: LD_VAR 0 2
71012: PUSH
71013: LD_VAR 0 3
71017: GREATER
71018: IFFALSE 71044
// length := ( array - i_from ) + i_to else
71020: LD_ADDR_VAR 0 11
71024: PUSH
71025: LD_VAR 0 1
71029: PUSH
71030: LD_VAR 0 2
71034: MINUS
71035: PUSH
71036: LD_VAR 0 3
71040: PLUS
71041: ST_TO_ADDR
71042: GO 71060
// length := i_to - i_from ;
71044: LD_ADDR_VAR 0 11
71048: PUSH
71049: LD_VAR 0 3
71053: PUSH
71054: LD_VAR 0 2
71058: MINUS
71059: ST_TO_ADDR
// end else
71060: GO 71123
// begin d := - 1 ;
71062: LD_ADDR_VAR 0 9
71066: PUSH
71067: LD_INT 1
71069: NEG
71070: ST_TO_ADDR
// if i_from > i_to then
71071: LD_VAR 0 2
71075: PUSH
71076: LD_VAR 0 3
71080: GREATER
71081: IFFALSE 71101
// length := i_from - i_to else
71083: LD_ADDR_VAR 0 11
71087: PUSH
71088: LD_VAR 0 2
71092: PUSH
71093: LD_VAR 0 3
71097: MINUS
71098: ST_TO_ADDR
71099: GO 71123
// length := ( array - i_to ) + i_from ;
71101: LD_ADDR_VAR 0 11
71105: PUSH
71106: LD_VAR 0 1
71110: PUSH
71111: LD_VAR 0 3
71115: MINUS
71116: PUSH
71117: LD_VAR 0 2
71121: PLUS
71122: ST_TO_ADDR
// end ; if not length then
71123: LD_VAR 0 11
71127: NOT
71128: IFFALSE 71132
// exit ;
71130: GO 71290
// tmp := array ;
71132: LD_ADDR_VAR 0 10
71136: PUSH
71137: LD_VAR 0 1
71141: ST_TO_ADDR
// for i = 1 to length do
71142: LD_ADDR_VAR 0 6
71146: PUSH
71147: DOUBLE
71148: LD_INT 1
71150: DEC
71151: ST_TO_ADDR
71152: LD_VAR 0 11
71156: PUSH
71157: FOR_TO
71158: IFFALSE 71278
// begin for j = 1 to array do
71160: LD_ADDR_VAR 0 7
71164: PUSH
71165: DOUBLE
71166: LD_INT 1
71168: DEC
71169: ST_TO_ADDR
71170: LD_VAR 0 1
71174: PUSH
71175: FOR_TO
71176: IFFALSE 71264
// begin k := j + d ;
71178: LD_ADDR_VAR 0 8
71182: PUSH
71183: LD_VAR 0 7
71187: PUSH
71188: LD_VAR 0 9
71192: PLUS
71193: ST_TO_ADDR
// if k > array then
71194: LD_VAR 0 8
71198: PUSH
71199: LD_VAR 0 1
71203: GREATER
71204: IFFALSE 71214
// k := 1 ;
71206: LD_ADDR_VAR 0 8
71210: PUSH
71211: LD_INT 1
71213: ST_TO_ADDR
// if not k then
71214: LD_VAR 0 8
71218: NOT
71219: IFFALSE 71231
// k := array ;
71221: LD_ADDR_VAR 0 8
71225: PUSH
71226: LD_VAR 0 1
71230: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71231: LD_ADDR_VAR 0 10
71235: PUSH
71236: LD_VAR 0 10
71240: PPUSH
71241: LD_VAR 0 8
71245: PPUSH
71246: LD_VAR 0 1
71250: PUSH
71251: LD_VAR 0 7
71255: ARRAY
71256: PPUSH
71257: CALL_OW 1
71261: ST_TO_ADDR
// end ;
71262: GO 71175
71264: POP
71265: POP
// array := tmp ;
71266: LD_ADDR_VAR 0 1
71270: PUSH
71271: LD_VAR 0 10
71275: ST_TO_ADDR
// end ;
71276: GO 71157
71278: POP
71279: POP
// result := array ;
71280: LD_ADDR_VAR 0 5
71284: PUSH
71285: LD_VAR 0 1
71289: ST_TO_ADDR
// end ;
71290: LD_VAR 0 5
71294: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71295: LD_INT 0
71297: PPUSH
71298: PPUSH
// result := 0 ;
71299: LD_ADDR_VAR 0 3
71303: PUSH
71304: LD_INT 0
71306: ST_TO_ADDR
// if not array or not value in array then
71307: LD_VAR 0 1
71311: NOT
71312: PUSH
71313: LD_VAR 0 2
71317: PUSH
71318: LD_VAR 0 1
71322: IN
71323: NOT
71324: OR
71325: IFFALSE 71329
// exit ;
71327: GO 71383
// for i = 1 to array do
71329: LD_ADDR_VAR 0 4
71333: PUSH
71334: DOUBLE
71335: LD_INT 1
71337: DEC
71338: ST_TO_ADDR
71339: LD_VAR 0 1
71343: PUSH
71344: FOR_TO
71345: IFFALSE 71381
// if value = array [ i ] then
71347: LD_VAR 0 2
71351: PUSH
71352: LD_VAR 0 1
71356: PUSH
71357: LD_VAR 0 4
71361: ARRAY
71362: EQUAL
71363: IFFALSE 71379
// begin result := i ;
71365: LD_ADDR_VAR 0 3
71369: PUSH
71370: LD_VAR 0 4
71374: ST_TO_ADDR
// exit ;
71375: POP
71376: POP
71377: GO 71383
// end ;
71379: GO 71344
71381: POP
71382: POP
// end ;
71383: LD_VAR 0 3
71387: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71388: LD_INT 0
71390: PPUSH
// vc_chassis := chassis ;
71391: LD_ADDR_OWVAR 37
71395: PUSH
71396: LD_VAR 0 1
71400: ST_TO_ADDR
// vc_engine := engine ;
71401: LD_ADDR_OWVAR 39
71405: PUSH
71406: LD_VAR 0 2
71410: ST_TO_ADDR
// vc_control := control ;
71411: LD_ADDR_OWVAR 38
71415: PUSH
71416: LD_VAR 0 3
71420: ST_TO_ADDR
// vc_weapon := weapon ;
71421: LD_ADDR_OWVAR 40
71425: PUSH
71426: LD_VAR 0 4
71430: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71431: LD_ADDR_OWVAR 41
71435: PUSH
71436: LD_VAR 0 5
71440: ST_TO_ADDR
// end ;
71441: LD_VAR 0 6
71445: RET
// export function WantPlant ( unit ) ; var task ; begin
71446: LD_INT 0
71448: PPUSH
71449: PPUSH
// result := false ;
71450: LD_ADDR_VAR 0 2
71454: PUSH
71455: LD_INT 0
71457: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71458: LD_ADDR_VAR 0 3
71462: PUSH
71463: LD_VAR 0 1
71467: PPUSH
71468: CALL_OW 437
71472: ST_TO_ADDR
// if task then
71473: LD_VAR 0 3
71477: IFFALSE 71505
// if task [ 1 ] [ 1 ] = p then
71479: LD_VAR 0 3
71483: PUSH
71484: LD_INT 1
71486: ARRAY
71487: PUSH
71488: LD_INT 1
71490: ARRAY
71491: PUSH
71492: LD_STRING p
71494: EQUAL
71495: IFFALSE 71505
// result := true ;
71497: LD_ADDR_VAR 0 2
71501: PUSH
71502: LD_INT 1
71504: ST_TO_ADDR
// end ;
71505: LD_VAR 0 2
71509: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71510: LD_INT 0
71512: PPUSH
71513: PPUSH
71514: PPUSH
71515: PPUSH
// if pos < 1 then
71516: LD_VAR 0 2
71520: PUSH
71521: LD_INT 1
71523: LESS
71524: IFFALSE 71528
// exit ;
71526: GO 71831
// if pos = 1 then
71528: LD_VAR 0 2
71532: PUSH
71533: LD_INT 1
71535: EQUAL
71536: IFFALSE 71569
// result := Replace ( arr , pos [ 1 ] , value ) else
71538: LD_ADDR_VAR 0 4
71542: PUSH
71543: LD_VAR 0 1
71547: PPUSH
71548: LD_VAR 0 2
71552: PUSH
71553: LD_INT 1
71555: ARRAY
71556: PPUSH
71557: LD_VAR 0 3
71561: PPUSH
71562: CALL_OW 1
71566: ST_TO_ADDR
71567: GO 71831
// begin tmp := arr ;
71569: LD_ADDR_VAR 0 6
71573: PUSH
71574: LD_VAR 0 1
71578: ST_TO_ADDR
// s_arr := [ tmp ] ;
71579: LD_ADDR_VAR 0 7
71583: PUSH
71584: LD_VAR 0 6
71588: PUSH
71589: EMPTY
71590: LIST
71591: ST_TO_ADDR
// for i = 1 to pos - 1 do
71592: LD_ADDR_VAR 0 5
71596: PUSH
71597: DOUBLE
71598: LD_INT 1
71600: DEC
71601: ST_TO_ADDR
71602: LD_VAR 0 2
71606: PUSH
71607: LD_INT 1
71609: MINUS
71610: PUSH
71611: FOR_TO
71612: IFFALSE 71657
// begin tmp := tmp [ pos [ i ] ] ;
71614: LD_ADDR_VAR 0 6
71618: PUSH
71619: LD_VAR 0 6
71623: PUSH
71624: LD_VAR 0 2
71628: PUSH
71629: LD_VAR 0 5
71633: ARRAY
71634: ARRAY
71635: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71636: LD_ADDR_VAR 0 7
71640: PUSH
71641: LD_VAR 0 7
71645: PUSH
71646: LD_VAR 0 6
71650: PUSH
71651: EMPTY
71652: LIST
71653: ADD
71654: ST_TO_ADDR
// end ;
71655: GO 71611
71657: POP
71658: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71659: LD_ADDR_VAR 0 6
71663: PUSH
71664: LD_VAR 0 6
71668: PPUSH
71669: LD_VAR 0 2
71673: PUSH
71674: LD_VAR 0 2
71678: ARRAY
71679: PPUSH
71680: LD_VAR 0 3
71684: PPUSH
71685: CALL_OW 1
71689: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71690: LD_ADDR_VAR 0 7
71694: PUSH
71695: LD_VAR 0 7
71699: PPUSH
71700: LD_VAR 0 7
71704: PPUSH
71705: LD_VAR 0 6
71709: PPUSH
71710: CALL_OW 1
71714: ST_TO_ADDR
// for i = s_arr downto 2 do
71715: LD_ADDR_VAR 0 5
71719: PUSH
71720: DOUBLE
71721: LD_VAR 0 7
71725: INC
71726: ST_TO_ADDR
71727: LD_INT 2
71729: PUSH
71730: FOR_DOWNTO
71731: IFFALSE 71815
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71733: LD_ADDR_VAR 0 6
71737: PUSH
71738: LD_VAR 0 7
71742: PUSH
71743: LD_VAR 0 5
71747: PUSH
71748: LD_INT 1
71750: MINUS
71751: ARRAY
71752: PPUSH
71753: LD_VAR 0 2
71757: PUSH
71758: LD_VAR 0 5
71762: PUSH
71763: LD_INT 1
71765: MINUS
71766: ARRAY
71767: PPUSH
71768: LD_VAR 0 7
71772: PUSH
71773: LD_VAR 0 5
71777: ARRAY
71778: PPUSH
71779: CALL_OW 1
71783: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71784: LD_ADDR_VAR 0 7
71788: PUSH
71789: LD_VAR 0 7
71793: PPUSH
71794: LD_VAR 0 5
71798: PUSH
71799: LD_INT 1
71801: MINUS
71802: PPUSH
71803: LD_VAR 0 6
71807: PPUSH
71808: CALL_OW 1
71812: ST_TO_ADDR
// end ;
71813: GO 71730
71815: POP
71816: POP
// result := s_arr [ 1 ] ;
71817: LD_ADDR_VAR 0 4
71821: PUSH
71822: LD_VAR 0 7
71826: PUSH
71827: LD_INT 1
71829: ARRAY
71830: ST_TO_ADDR
// end ; end ;
71831: LD_VAR 0 4
71835: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71836: LD_INT 0
71838: PPUSH
71839: PPUSH
// if not list then
71840: LD_VAR 0 1
71844: NOT
71845: IFFALSE 71849
// exit ;
71847: GO 71940
// i := list [ pos1 ] ;
71849: LD_ADDR_VAR 0 5
71853: PUSH
71854: LD_VAR 0 1
71858: PUSH
71859: LD_VAR 0 2
71863: ARRAY
71864: ST_TO_ADDR
// if not i then
71865: LD_VAR 0 5
71869: NOT
71870: IFFALSE 71874
// exit ;
71872: GO 71940
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71874: LD_ADDR_VAR 0 1
71878: PUSH
71879: LD_VAR 0 1
71883: PPUSH
71884: LD_VAR 0 2
71888: PPUSH
71889: LD_VAR 0 1
71893: PUSH
71894: LD_VAR 0 3
71898: ARRAY
71899: PPUSH
71900: CALL_OW 1
71904: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71905: LD_ADDR_VAR 0 1
71909: PUSH
71910: LD_VAR 0 1
71914: PPUSH
71915: LD_VAR 0 3
71919: PPUSH
71920: LD_VAR 0 5
71924: PPUSH
71925: CALL_OW 1
71929: ST_TO_ADDR
// result := list ;
71930: LD_ADDR_VAR 0 4
71934: PUSH
71935: LD_VAR 0 1
71939: ST_TO_ADDR
// end ;
71940: LD_VAR 0 4
71944: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71945: LD_INT 0
71947: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71948: LD_ADDR_VAR 0 5
71952: PUSH
71953: LD_VAR 0 1
71957: PPUSH
71958: CALL_OW 250
71962: PPUSH
71963: LD_VAR 0 1
71967: PPUSH
71968: CALL_OW 251
71972: PPUSH
71973: LD_VAR 0 2
71977: PPUSH
71978: LD_VAR 0 3
71982: PPUSH
71983: LD_VAR 0 4
71987: PPUSH
71988: CALL 71998 0 5
71992: ST_TO_ADDR
// end ;
71993: LD_VAR 0 5
71997: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71998: LD_INT 0
72000: PPUSH
72001: PPUSH
72002: PPUSH
72003: PPUSH
// if not list then
72004: LD_VAR 0 3
72008: NOT
72009: IFFALSE 72013
// exit ;
72011: GO 72401
// result := [ ] ;
72013: LD_ADDR_VAR 0 6
72017: PUSH
72018: EMPTY
72019: ST_TO_ADDR
// for i in list do
72020: LD_ADDR_VAR 0 7
72024: PUSH
72025: LD_VAR 0 3
72029: PUSH
72030: FOR_IN
72031: IFFALSE 72233
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72033: LD_ADDR_VAR 0 9
72037: PUSH
72038: LD_VAR 0 7
72042: PPUSH
72043: LD_VAR 0 1
72047: PPUSH
72048: LD_VAR 0 2
72052: PPUSH
72053: CALL_OW 297
72057: ST_TO_ADDR
// if not result then
72058: LD_VAR 0 6
72062: NOT
72063: IFFALSE 72089
// result := [ [ i , tmp ] ] else
72065: LD_ADDR_VAR 0 6
72069: PUSH
72070: LD_VAR 0 7
72074: PUSH
72075: LD_VAR 0 9
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: EMPTY
72085: LIST
72086: ST_TO_ADDR
72087: GO 72231
// begin if result [ result ] [ 2 ] < tmp then
72089: LD_VAR 0 6
72093: PUSH
72094: LD_VAR 0 6
72098: ARRAY
72099: PUSH
72100: LD_INT 2
72102: ARRAY
72103: PUSH
72104: LD_VAR 0 9
72108: LESS
72109: IFFALSE 72151
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72111: LD_ADDR_VAR 0 6
72115: PUSH
72116: LD_VAR 0 6
72120: PPUSH
72121: LD_VAR 0 6
72125: PUSH
72126: LD_INT 1
72128: PLUS
72129: PPUSH
72130: LD_VAR 0 7
72134: PUSH
72135: LD_VAR 0 9
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: PPUSH
72144: CALL_OW 2
72148: ST_TO_ADDR
72149: GO 72231
// for j = 1 to result do
72151: LD_ADDR_VAR 0 8
72155: PUSH
72156: DOUBLE
72157: LD_INT 1
72159: DEC
72160: ST_TO_ADDR
72161: LD_VAR 0 6
72165: PUSH
72166: FOR_TO
72167: IFFALSE 72229
// begin if tmp < result [ j ] [ 2 ] then
72169: LD_VAR 0 9
72173: PUSH
72174: LD_VAR 0 6
72178: PUSH
72179: LD_VAR 0 8
72183: ARRAY
72184: PUSH
72185: LD_INT 2
72187: ARRAY
72188: LESS
72189: IFFALSE 72227
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72191: LD_ADDR_VAR 0 6
72195: PUSH
72196: LD_VAR 0 6
72200: PPUSH
72201: LD_VAR 0 8
72205: PPUSH
72206: LD_VAR 0 7
72210: PUSH
72211: LD_VAR 0 9
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PPUSH
72220: CALL_OW 2
72224: ST_TO_ADDR
// break ;
72225: GO 72229
// end ; end ;
72227: GO 72166
72229: POP
72230: POP
// end ; end ;
72231: GO 72030
72233: POP
72234: POP
// if result and not asc then
72235: LD_VAR 0 6
72239: PUSH
72240: LD_VAR 0 4
72244: NOT
72245: AND
72246: IFFALSE 72321
// begin tmp := result ;
72248: LD_ADDR_VAR 0 9
72252: PUSH
72253: LD_VAR 0 6
72257: ST_TO_ADDR
// for i = tmp downto 1 do
72258: LD_ADDR_VAR 0 7
72262: PUSH
72263: DOUBLE
72264: LD_VAR 0 9
72268: INC
72269: ST_TO_ADDR
72270: LD_INT 1
72272: PUSH
72273: FOR_DOWNTO
72274: IFFALSE 72319
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72276: LD_ADDR_VAR 0 6
72280: PUSH
72281: LD_VAR 0 6
72285: PPUSH
72286: LD_VAR 0 9
72290: PUSH
72291: LD_VAR 0 7
72295: MINUS
72296: PUSH
72297: LD_INT 1
72299: PLUS
72300: PPUSH
72301: LD_VAR 0 9
72305: PUSH
72306: LD_VAR 0 7
72310: ARRAY
72311: PPUSH
72312: CALL_OW 1
72316: ST_TO_ADDR
72317: GO 72273
72319: POP
72320: POP
// end ; tmp := [ ] ;
72321: LD_ADDR_VAR 0 9
72325: PUSH
72326: EMPTY
72327: ST_TO_ADDR
// if mode then
72328: LD_VAR 0 5
72332: IFFALSE 72401
// begin for i = 1 to result do
72334: LD_ADDR_VAR 0 7
72338: PUSH
72339: DOUBLE
72340: LD_INT 1
72342: DEC
72343: ST_TO_ADDR
72344: LD_VAR 0 6
72348: PUSH
72349: FOR_TO
72350: IFFALSE 72389
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72352: LD_ADDR_VAR 0 9
72356: PUSH
72357: LD_VAR 0 9
72361: PPUSH
72362: LD_VAR 0 7
72366: PPUSH
72367: LD_VAR 0 6
72371: PUSH
72372: LD_VAR 0 7
72376: ARRAY
72377: PUSH
72378: LD_INT 1
72380: ARRAY
72381: PPUSH
72382: CALL_OW 1
72386: ST_TO_ADDR
72387: GO 72349
72389: POP
72390: POP
// result := tmp ;
72391: LD_ADDR_VAR 0 6
72395: PUSH
72396: LD_VAR 0 9
72400: ST_TO_ADDR
// end ; end ;
72401: LD_VAR 0 6
72405: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72406: LD_INT 0
72408: PPUSH
72409: PPUSH
72410: PPUSH
72411: PPUSH
72412: PPUSH
72413: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72414: LD_ADDR_VAR 0 5
72418: PUSH
72419: LD_INT 0
72421: PUSH
72422: LD_INT 0
72424: PUSH
72425: LD_INT 0
72427: PUSH
72428: EMPTY
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: LIST
72434: LIST
72435: ST_TO_ADDR
// if not x or not y then
72436: LD_VAR 0 2
72440: NOT
72441: PUSH
72442: LD_VAR 0 3
72446: NOT
72447: OR
72448: IFFALSE 72452
// exit ;
72450: GO 74098
// if not range then
72452: LD_VAR 0 4
72456: NOT
72457: IFFALSE 72467
// range := 10 ;
72459: LD_ADDR_VAR 0 4
72463: PUSH
72464: LD_INT 10
72466: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72467: LD_ADDR_VAR 0 8
72471: PUSH
72472: LD_INT 81
72474: PUSH
72475: LD_VAR 0 1
72479: PUSH
72480: EMPTY
72481: LIST
72482: LIST
72483: PUSH
72484: LD_INT 92
72486: PUSH
72487: LD_VAR 0 2
72491: PUSH
72492: LD_VAR 0 3
72496: PUSH
72497: LD_VAR 0 4
72501: PUSH
72502: EMPTY
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: PUSH
72508: LD_INT 3
72510: PUSH
72511: LD_INT 21
72513: PUSH
72514: LD_INT 3
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: LIST
72529: PPUSH
72530: CALL_OW 69
72534: ST_TO_ADDR
// if not tmp then
72535: LD_VAR 0 8
72539: NOT
72540: IFFALSE 72544
// exit ;
72542: GO 74098
// for i in tmp do
72544: LD_ADDR_VAR 0 6
72548: PUSH
72549: LD_VAR 0 8
72553: PUSH
72554: FOR_IN
72555: IFFALSE 74073
// begin points := [ 0 , 0 , 0 ] ;
72557: LD_ADDR_VAR 0 9
72561: PUSH
72562: LD_INT 0
72564: PUSH
72565: LD_INT 0
72567: PUSH
72568: LD_INT 0
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: LIST
72575: ST_TO_ADDR
// bpoints := 1 ;
72576: LD_ADDR_VAR 0 10
72580: PUSH
72581: LD_INT 1
72583: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72584: LD_VAR 0 6
72588: PPUSH
72589: CALL_OW 247
72593: PUSH
72594: LD_INT 1
72596: DOUBLE
72597: EQUAL
72598: IFTRUE 72602
72600: GO 73180
72602: POP
// begin if GetClass ( i ) = 1 then
72603: LD_VAR 0 6
72607: PPUSH
72608: CALL_OW 257
72612: PUSH
72613: LD_INT 1
72615: EQUAL
72616: IFFALSE 72637
// points := [ 10 , 5 , 3 ] ;
72618: LD_ADDR_VAR 0 9
72622: PUSH
72623: LD_INT 10
72625: PUSH
72626: LD_INT 5
72628: PUSH
72629: LD_INT 3
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: LIST
72636: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72637: LD_VAR 0 6
72641: PPUSH
72642: CALL_OW 257
72646: PUSH
72647: LD_INT 2
72649: PUSH
72650: LD_INT 3
72652: PUSH
72653: LD_INT 4
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: LIST
72660: IN
72661: IFFALSE 72682
// points := [ 3 , 2 , 1 ] ;
72663: LD_ADDR_VAR 0 9
72667: PUSH
72668: LD_INT 3
72670: PUSH
72671: LD_INT 2
72673: PUSH
72674: LD_INT 1
72676: PUSH
72677: EMPTY
72678: LIST
72679: LIST
72680: LIST
72681: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72682: LD_VAR 0 6
72686: PPUSH
72687: CALL_OW 257
72691: PUSH
72692: LD_INT 5
72694: EQUAL
72695: IFFALSE 72716
// points := [ 130 , 5 , 2 ] ;
72697: LD_ADDR_VAR 0 9
72701: PUSH
72702: LD_INT 130
72704: PUSH
72705: LD_INT 5
72707: PUSH
72708: LD_INT 2
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: LIST
72715: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72716: LD_VAR 0 6
72720: PPUSH
72721: CALL_OW 257
72725: PUSH
72726: LD_INT 8
72728: EQUAL
72729: IFFALSE 72750
// points := [ 35 , 35 , 30 ] ;
72731: LD_ADDR_VAR 0 9
72735: PUSH
72736: LD_INT 35
72738: PUSH
72739: LD_INT 35
72741: PUSH
72742: LD_INT 30
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: LIST
72749: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72750: LD_VAR 0 6
72754: PPUSH
72755: CALL_OW 257
72759: PUSH
72760: LD_INT 9
72762: EQUAL
72763: IFFALSE 72784
// points := [ 20 , 55 , 40 ] ;
72765: LD_ADDR_VAR 0 9
72769: PUSH
72770: LD_INT 20
72772: PUSH
72773: LD_INT 55
72775: PUSH
72776: LD_INT 40
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: LIST
72783: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72784: LD_VAR 0 6
72788: PPUSH
72789: CALL_OW 257
72793: PUSH
72794: LD_INT 12
72796: PUSH
72797: LD_INT 16
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: IN
72804: IFFALSE 72825
// points := [ 5 , 3 , 2 ] ;
72806: LD_ADDR_VAR 0 9
72810: PUSH
72811: LD_INT 5
72813: PUSH
72814: LD_INT 3
72816: PUSH
72817: LD_INT 2
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: LIST
72824: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72825: LD_VAR 0 6
72829: PPUSH
72830: CALL_OW 257
72834: PUSH
72835: LD_INT 17
72837: EQUAL
72838: IFFALSE 72859
// points := [ 100 , 50 , 75 ] ;
72840: LD_ADDR_VAR 0 9
72844: PUSH
72845: LD_INT 100
72847: PUSH
72848: LD_INT 50
72850: PUSH
72851: LD_INT 75
72853: PUSH
72854: EMPTY
72855: LIST
72856: LIST
72857: LIST
72858: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72859: LD_VAR 0 6
72863: PPUSH
72864: CALL_OW 257
72868: PUSH
72869: LD_INT 15
72871: EQUAL
72872: IFFALSE 72893
// points := [ 10 , 5 , 3 ] ;
72874: LD_ADDR_VAR 0 9
72878: PUSH
72879: LD_INT 10
72881: PUSH
72882: LD_INT 5
72884: PUSH
72885: LD_INT 3
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: LIST
72892: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72893: LD_VAR 0 6
72897: PPUSH
72898: CALL_OW 257
72902: PUSH
72903: LD_INT 14
72905: EQUAL
72906: IFFALSE 72927
// points := [ 10 , 0 , 0 ] ;
72908: LD_ADDR_VAR 0 9
72912: PUSH
72913: LD_INT 10
72915: PUSH
72916: LD_INT 0
72918: PUSH
72919: LD_INT 0
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: LIST
72926: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72927: LD_VAR 0 6
72931: PPUSH
72932: CALL_OW 257
72936: PUSH
72937: LD_INT 11
72939: EQUAL
72940: IFFALSE 72961
// points := [ 30 , 10 , 5 ] ;
72942: LD_ADDR_VAR 0 9
72946: PUSH
72947: LD_INT 30
72949: PUSH
72950: LD_INT 10
72952: PUSH
72953: LD_INT 5
72955: PUSH
72956: EMPTY
72957: LIST
72958: LIST
72959: LIST
72960: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72961: LD_VAR 0 1
72965: PPUSH
72966: LD_INT 5
72968: PPUSH
72969: CALL_OW 321
72973: PUSH
72974: LD_INT 2
72976: EQUAL
72977: IFFALSE 72994
// bpoints := bpoints * 1.8 ;
72979: LD_ADDR_VAR 0 10
72983: PUSH
72984: LD_VAR 0 10
72988: PUSH
72989: LD_REAL  1.80000000000000E+0000
72992: MUL
72993: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72994: LD_VAR 0 6
72998: PPUSH
72999: CALL_OW 257
73003: PUSH
73004: LD_INT 1
73006: PUSH
73007: LD_INT 2
73009: PUSH
73010: LD_INT 3
73012: PUSH
73013: LD_INT 4
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: IN
73022: PUSH
73023: LD_VAR 0 1
73027: PPUSH
73028: LD_INT 51
73030: PPUSH
73031: CALL_OW 321
73035: PUSH
73036: LD_INT 2
73038: EQUAL
73039: AND
73040: IFFALSE 73057
// bpoints := bpoints * 1.2 ;
73042: LD_ADDR_VAR 0 10
73046: PUSH
73047: LD_VAR 0 10
73051: PUSH
73052: LD_REAL  1.20000000000000E+0000
73055: MUL
73056: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73057: LD_VAR 0 6
73061: PPUSH
73062: CALL_OW 257
73066: PUSH
73067: LD_INT 5
73069: PUSH
73070: LD_INT 7
73072: PUSH
73073: LD_INT 9
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: LIST
73080: IN
73081: PUSH
73082: LD_VAR 0 1
73086: PPUSH
73087: LD_INT 52
73089: PPUSH
73090: CALL_OW 321
73094: PUSH
73095: LD_INT 2
73097: EQUAL
73098: AND
73099: IFFALSE 73116
// bpoints := bpoints * 1.5 ;
73101: LD_ADDR_VAR 0 10
73105: PUSH
73106: LD_VAR 0 10
73110: PUSH
73111: LD_REAL  1.50000000000000E+0000
73114: MUL
73115: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73116: LD_VAR 0 1
73120: PPUSH
73121: LD_INT 66
73123: PPUSH
73124: CALL_OW 321
73128: PUSH
73129: LD_INT 2
73131: EQUAL
73132: IFFALSE 73149
// bpoints := bpoints * 1.1 ;
73134: LD_ADDR_VAR 0 10
73138: PUSH
73139: LD_VAR 0 10
73143: PUSH
73144: LD_REAL  1.10000000000000E+0000
73147: MUL
73148: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73149: LD_ADDR_VAR 0 10
73153: PUSH
73154: LD_VAR 0 10
73158: PUSH
73159: LD_VAR 0 6
73163: PPUSH
73164: LD_INT 1
73166: PPUSH
73167: CALL_OW 259
73171: PUSH
73172: LD_REAL  1.15000000000000E+0000
73175: MUL
73176: MUL
73177: ST_TO_ADDR
// end ; unit_vehicle :
73178: GO 74002
73180: LD_INT 2
73182: DOUBLE
73183: EQUAL
73184: IFTRUE 73188
73186: GO 73990
73188: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73189: LD_VAR 0 6
73193: PPUSH
73194: CALL_OW 264
73198: PUSH
73199: LD_INT 2
73201: PUSH
73202: LD_INT 42
73204: PUSH
73205: LD_INT 24
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: LIST
73212: IN
73213: IFFALSE 73234
// points := [ 25 , 5 , 3 ] ;
73215: LD_ADDR_VAR 0 9
73219: PUSH
73220: LD_INT 25
73222: PUSH
73223: LD_INT 5
73225: PUSH
73226: LD_INT 3
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: LIST
73233: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73234: LD_VAR 0 6
73238: PPUSH
73239: CALL_OW 264
73243: PUSH
73244: LD_INT 4
73246: PUSH
73247: LD_INT 43
73249: PUSH
73250: LD_INT 25
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: LIST
73257: IN
73258: IFFALSE 73279
// points := [ 40 , 15 , 5 ] ;
73260: LD_ADDR_VAR 0 9
73264: PUSH
73265: LD_INT 40
73267: PUSH
73268: LD_INT 15
73270: PUSH
73271: LD_INT 5
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: LIST
73278: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73279: LD_VAR 0 6
73283: PPUSH
73284: CALL_OW 264
73288: PUSH
73289: LD_INT 3
73291: PUSH
73292: LD_INT 23
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: IN
73299: IFFALSE 73320
// points := [ 7 , 25 , 8 ] ;
73301: LD_ADDR_VAR 0 9
73305: PUSH
73306: LD_INT 7
73308: PUSH
73309: LD_INT 25
73311: PUSH
73312: LD_INT 8
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: LIST
73319: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73320: LD_VAR 0 6
73324: PPUSH
73325: CALL_OW 264
73329: PUSH
73330: LD_INT 5
73332: PUSH
73333: LD_INT 27
73335: PUSH
73336: LD_INT 44
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: LIST
73343: IN
73344: IFFALSE 73365
// points := [ 14 , 50 , 16 ] ;
73346: LD_ADDR_VAR 0 9
73350: PUSH
73351: LD_INT 14
73353: PUSH
73354: LD_INT 50
73356: PUSH
73357: LD_INT 16
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: LIST
73364: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73365: LD_VAR 0 6
73369: PPUSH
73370: CALL_OW 264
73374: PUSH
73375: LD_INT 6
73377: PUSH
73378: LD_INT 46
73380: PUSH
73381: EMPTY
73382: LIST
73383: LIST
73384: IN
73385: IFFALSE 73406
// points := [ 32 , 120 , 70 ] ;
73387: LD_ADDR_VAR 0 9
73391: PUSH
73392: LD_INT 32
73394: PUSH
73395: LD_INT 120
73397: PUSH
73398: LD_INT 70
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: LIST
73405: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73406: LD_VAR 0 6
73410: PPUSH
73411: CALL_OW 264
73415: PUSH
73416: LD_INT 7
73418: PUSH
73419: LD_INT 28
73421: PUSH
73422: LD_INT 45
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: LIST
73429: IN
73430: IFFALSE 73451
// points := [ 35 , 20 , 45 ] ;
73432: LD_ADDR_VAR 0 9
73436: PUSH
73437: LD_INT 35
73439: PUSH
73440: LD_INT 20
73442: PUSH
73443: LD_INT 45
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: LIST
73450: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73451: LD_VAR 0 6
73455: PPUSH
73456: CALL_OW 264
73460: PUSH
73461: LD_INT 47
73463: PUSH
73464: EMPTY
73465: LIST
73466: IN
73467: IFFALSE 73488
// points := [ 67 , 45 , 75 ] ;
73469: LD_ADDR_VAR 0 9
73473: PUSH
73474: LD_INT 67
73476: PUSH
73477: LD_INT 45
73479: PUSH
73480: LD_INT 75
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: LIST
73487: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73488: LD_VAR 0 6
73492: PPUSH
73493: CALL_OW 264
73497: PUSH
73498: LD_INT 26
73500: PUSH
73501: EMPTY
73502: LIST
73503: IN
73504: IFFALSE 73525
// points := [ 120 , 30 , 80 ] ;
73506: LD_ADDR_VAR 0 9
73510: PUSH
73511: LD_INT 120
73513: PUSH
73514: LD_INT 30
73516: PUSH
73517: LD_INT 80
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: LIST
73524: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73525: LD_VAR 0 6
73529: PPUSH
73530: CALL_OW 264
73534: PUSH
73535: LD_INT 22
73537: PUSH
73538: EMPTY
73539: LIST
73540: IN
73541: IFFALSE 73562
// points := [ 40 , 1 , 1 ] ;
73543: LD_ADDR_VAR 0 9
73547: PUSH
73548: LD_INT 40
73550: PUSH
73551: LD_INT 1
73553: PUSH
73554: LD_INT 1
73556: PUSH
73557: EMPTY
73558: LIST
73559: LIST
73560: LIST
73561: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73562: LD_VAR 0 6
73566: PPUSH
73567: CALL_OW 264
73571: PUSH
73572: LD_INT 29
73574: PUSH
73575: EMPTY
73576: LIST
73577: IN
73578: IFFALSE 73599
// points := [ 70 , 200 , 400 ] ;
73580: LD_ADDR_VAR 0 9
73584: PUSH
73585: LD_INT 70
73587: PUSH
73588: LD_INT 200
73590: PUSH
73591: LD_INT 400
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: LIST
73598: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73599: LD_VAR 0 6
73603: PPUSH
73604: CALL_OW 264
73608: PUSH
73609: LD_INT 14
73611: PUSH
73612: LD_INT 53
73614: PUSH
73615: EMPTY
73616: LIST
73617: LIST
73618: IN
73619: IFFALSE 73640
// points := [ 40 , 10 , 20 ] ;
73621: LD_ADDR_VAR 0 9
73625: PUSH
73626: LD_INT 40
73628: PUSH
73629: LD_INT 10
73631: PUSH
73632: LD_INT 20
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: LIST
73639: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73640: LD_VAR 0 6
73644: PPUSH
73645: CALL_OW 264
73649: PUSH
73650: LD_INT 9
73652: PUSH
73653: EMPTY
73654: LIST
73655: IN
73656: IFFALSE 73677
// points := [ 5 , 70 , 20 ] ;
73658: LD_ADDR_VAR 0 9
73662: PUSH
73663: LD_INT 5
73665: PUSH
73666: LD_INT 70
73668: PUSH
73669: LD_INT 20
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: LIST
73676: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73677: LD_VAR 0 6
73681: PPUSH
73682: CALL_OW 264
73686: PUSH
73687: LD_INT 10
73689: PUSH
73690: EMPTY
73691: LIST
73692: IN
73693: IFFALSE 73714
// points := [ 35 , 110 , 70 ] ;
73695: LD_ADDR_VAR 0 9
73699: PUSH
73700: LD_INT 35
73702: PUSH
73703: LD_INT 110
73705: PUSH
73706: LD_INT 70
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: LIST
73713: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73714: LD_VAR 0 6
73718: PPUSH
73719: CALL_OW 265
73723: PUSH
73724: LD_INT 25
73726: EQUAL
73727: IFFALSE 73748
// points := [ 80 , 65 , 100 ] ;
73729: LD_ADDR_VAR 0 9
73733: PUSH
73734: LD_INT 80
73736: PUSH
73737: LD_INT 65
73739: PUSH
73740: LD_INT 100
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: LIST
73747: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73748: LD_VAR 0 6
73752: PPUSH
73753: CALL_OW 263
73757: PUSH
73758: LD_INT 1
73760: EQUAL
73761: IFFALSE 73796
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73763: LD_ADDR_VAR 0 10
73767: PUSH
73768: LD_VAR 0 10
73772: PUSH
73773: LD_VAR 0 6
73777: PPUSH
73778: CALL_OW 311
73782: PPUSH
73783: LD_INT 3
73785: PPUSH
73786: CALL_OW 259
73790: PUSH
73791: LD_INT 4
73793: MUL
73794: MUL
73795: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73796: LD_VAR 0 6
73800: PPUSH
73801: CALL_OW 263
73805: PUSH
73806: LD_INT 2
73808: EQUAL
73809: IFFALSE 73860
// begin j := IsControledBy ( i ) ;
73811: LD_ADDR_VAR 0 7
73815: PUSH
73816: LD_VAR 0 6
73820: PPUSH
73821: CALL_OW 312
73825: ST_TO_ADDR
// if j then
73826: LD_VAR 0 7
73830: IFFALSE 73860
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73832: LD_ADDR_VAR 0 10
73836: PUSH
73837: LD_VAR 0 10
73841: PUSH
73842: LD_VAR 0 7
73846: PPUSH
73847: LD_INT 3
73849: PPUSH
73850: CALL_OW 259
73854: PUSH
73855: LD_INT 3
73857: MUL
73858: MUL
73859: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73860: LD_VAR 0 6
73864: PPUSH
73865: CALL_OW 264
73869: PUSH
73870: LD_INT 5
73872: PUSH
73873: LD_INT 6
73875: PUSH
73876: LD_INT 46
73878: PUSH
73879: LD_INT 44
73881: PUSH
73882: LD_INT 47
73884: PUSH
73885: LD_INT 45
73887: PUSH
73888: LD_INT 28
73890: PUSH
73891: LD_INT 7
73893: PUSH
73894: LD_INT 27
73896: PUSH
73897: LD_INT 29
73899: PUSH
73900: EMPTY
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: IN
73912: PUSH
73913: LD_VAR 0 1
73917: PPUSH
73918: LD_INT 52
73920: PPUSH
73921: CALL_OW 321
73925: PUSH
73926: LD_INT 2
73928: EQUAL
73929: AND
73930: IFFALSE 73947
// bpoints := bpoints * 1.2 ;
73932: LD_ADDR_VAR 0 10
73936: PUSH
73937: LD_VAR 0 10
73941: PUSH
73942: LD_REAL  1.20000000000000E+0000
73945: MUL
73946: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73947: LD_VAR 0 6
73951: PPUSH
73952: CALL_OW 264
73956: PUSH
73957: LD_INT 6
73959: PUSH
73960: LD_INT 46
73962: PUSH
73963: LD_INT 47
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: LIST
73970: IN
73971: IFFALSE 73988
// bpoints := bpoints * 1.2 ;
73973: LD_ADDR_VAR 0 10
73977: PUSH
73978: LD_VAR 0 10
73982: PUSH
73983: LD_REAL  1.20000000000000E+0000
73986: MUL
73987: ST_TO_ADDR
// end ; unit_building :
73988: GO 74002
73990: LD_INT 3
73992: DOUBLE
73993: EQUAL
73994: IFTRUE 73998
73996: GO 74001
73998: POP
// ; end ;
73999: GO 74002
74001: POP
// for j = 1 to 3 do
74002: LD_ADDR_VAR 0 7
74006: PUSH
74007: DOUBLE
74008: LD_INT 1
74010: DEC
74011: ST_TO_ADDR
74012: LD_INT 3
74014: PUSH
74015: FOR_TO
74016: IFFALSE 74069
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74018: LD_ADDR_VAR 0 5
74022: PUSH
74023: LD_VAR 0 5
74027: PPUSH
74028: LD_VAR 0 7
74032: PPUSH
74033: LD_VAR 0 5
74037: PUSH
74038: LD_VAR 0 7
74042: ARRAY
74043: PUSH
74044: LD_VAR 0 9
74048: PUSH
74049: LD_VAR 0 7
74053: ARRAY
74054: PUSH
74055: LD_VAR 0 10
74059: MUL
74060: PLUS
74061: PPUSH
74062: CALL_OW 1
74066: ST_TO_ADDR
74067: GO 74015
74069: POP
74070: POP
// end ;
74071: GO 72554
74073: POP
74074: POP
// result := Replace ( result , 4 , tmp ) ;
74075: LD_ADDR_VAR 0 5
74079: PUSH
74080: LD_VAR 0 5
74084: PPUSH
74085: LD_INT 4
74087: PPUSH
74088: LD_VAR 0 8
74092: PPUSH
74093: CALL_OW 1
74097: ST_TO_ADDR
// end ;
74098: LD_VAR 0 5
74102: RET
// export function DangerAtRange ( unit , range ) ; begin
74103: LD_INT 0
74105: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74106: LD_ADDR_VAR 0 3
74110: PUSH
74111: LD_VAR 0 1
74115: PPUSH
74116: CALL_OW 255
74120: PPUSH
74121: LD_VAR 0 1
74125: PPUSH
74126: CALL_OW 250
74130: PPUSH
74131: LD_VAR 0 1
74135: PPUSH
74136: CALL_OW 251
74140: PPUSH
74141: LD_VAR 0 2
74145: PPUSH
74146: CALL 72406 0 4
74150: ST_TO_ADDR
// end ;
74151: LD_VAR 0 3
74155: RET
// export function DangerInArea ( side , area ) ; begin
74156: LD_INT 0
74158: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74159: LD_ADDR_VAR 0 3
74163: PUSH
74164: LD_VAR 0 2
74168: PPUSH
74169: LD_INT 81
74171: PUSH
74172: LD_VAR 0 1
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PPUSH
74181: CALL_OW 70
74185: ST_TO_ADDR
// end ;
74186: LD_VAR 0 3
74190: RET
// export function IsExtension ( b ) ; begin
74191: LD_INT 0
74193: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74194: LD_ADDR_VAR 0 2
74198: PUSH
74199: LD_VAR 0 1
74203: PUSH
74204: LD_INT 23
74206: PUSH
74207: LD_INT 20
74209: PUSH
74210: LD_INT 22
74212: PUSH
74213: LD_INT 17
74215: PUSH
74216: LD_INT 24
74218: PUSH
74219: LD_INT 21
74221: PUSH
74222: LD_INT 19
74224: PUSH
74225: LD_INT 16
74227: PUSH
74228: LD_INT 25
74230: PUSH
74231: LD_INT 18
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: LIST
74238: LIST
74239: LIST
74240: LIST
74241: LIST
74242: LIST
74243: LIST
74244: LIST
74245: IN
74246: ST_TO_ADDR
// end ;
74247: LD_VAR 0 2
74251: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74252: LD_INT 0
74254: PPUSH
74255: PPUSH
74256: PPUSH
// result := [ ] ;
74257: LD_ADDR_VAR 0 3
74261: PUSH
74262: EMPTY
74263: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74264: LD_ADDR_VAR 0 4
74268: PUSH
74269: LD_VAR 0 2
74273: PPUSH
74274: LD_INT 21
74276: PUSH
74277: LD_INT 3
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PPUSH
74284: CALL_OW 70
74288: ST_TO_ADDR
// if not tmp then
74289: LD_VAR 0 4
74293: NOT
74294: IFFALSE 74298
// exit ;
74296: GO 74356
// for i in tmp do
74298: LD_ADDR_VAR 0 5
74302: PUSH
74303: LD_VAR 0 4
74307: PUSH
74308: FOR_IN
74309: IFFALSE 74344
// if GetBase ( i ) <> base then
74311: LD_VAR 0 5
74315: PPUSH
74316: CALL_OW 274
74320: PUSH
74321: LD_VAR 0 1
74325: NONEQUAL
74326: IFFALSE 74342
// ComLinkToBase ( base , i ) ;
74328: LD_VAR 0 1
74332: PPUSH
74333: LD_VAR 0 5
74337: PPUSH
74338: CALL_OW 169
74342: GO 74308
74344: POP
74345: POP
// result := tmp ;
74346: LD_ADDR_VAR 0 3
74350: PUSH
74351: LD_VAR 0 4
74355: ST_TO_ADDR
// end ;
74356: LD_VAR 0 3
74360: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74361: LD_INT 0
74363: PPUSH
74364: PPUSH
// if BuildingStatus ( b ) = bs_build then
74365: LD_VAR 0 2
74369: PPUSH
74370: CALL_OW 461
74374: PUSH
74375: LD_INT 1
74377: EQUAL
74378: IFFALSE 74438
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74380: LD_VAR 0 1
74384: PPUSH
74385: LD_STRING h
74387: PUSH
74388: LD_VAR 0 2
74392: PPUSH
74393: CALL_OW 250
74397: PUSH
74398: LD_VAR 0 2
74402: PPUSH
74403: CALL_OW 251
74407: PUSH
74408: LD_VAR 0 2
74412: PUSH
74413: LD_INT 0
74415: PUSH
74416: LD_INT 0
74418: PUSH
74419: LD_INT 0
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: PUSH
74431: EMPTY
74432: LIST
74433: PPUSH
74434: CALL_OW 446
// end ;
74438: LD_VAR 0 3
74442: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74443: LD_INT 0
74445: PPUSH
74446: PPUSH
74447: PPUSH
74448: PPUSH
74449: PPUSH
74450: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74451: LD_VAR 0 1
74455: NOT
74456: PUSH
74457: LD_VAR 0 1
74461: PPUSH
74462: CALL_OW 263
74466: PUSH
74467: LD_INT 2
74469: EQUAL
74470: NOT
74471: OR
74472: IFFALSE 74476
// exit ;
74474: GO 74792
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74476: LD_ADDR_VAR 0 6
74480: PUSH
74481: LD_INT 22
74483: PUSH
74484: LD_VAR 0 1
74488: PPUSH
74489: CALL_OW 255
74493: PUSH
74494: EMPTY
74495: LIST
74496: LIST
74497: PUSH
74498: LD_INT 2
74500: PUSH
74501: LD_INT 30
74503: PUSH
74504: LD_INT 36
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 34
74513: PUSH
74514: LD_INT 31
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: LIST
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PPUSH
74530: CALL_OW 69
74534: ST_TO_ADDR
// if not tmp then
74535: LD_VAR 0 6
74539: NOT
74540: IFFALSE 74544
// exit ;
74542: GO 74792
// result := [ ] ;
74544: LD_ADDR_VAR 0 2
74548: PUSH
74549: EMPTY
74550: ST_TO_ADDR
// for i in tmp do
74551: LD_ADDR_VAR 0 3
74555: PUSH
74556: LD_VAR 0 6
74560: PUSH
74561: FOR_IN
74562: IFFALSE 74633
// begin t := UnitsInside ( i ) ;
74564: LD_ADDR_VAR 0 4
74568: PUSH
74569: LD_VAR 0 3
74573: PPUSH
74574: CALL_OW 313
74578: ST_TO_ADDR
// if t then
74579: LD_VAR 0 4
74583: IFFALSE 74631
// for j in t do
74585: LD_ADDR_VAR 0 7
74589: PUSH
74590: LD_VAR 0 4
74594: PUSH
74595: FOR_IN
74596: IFFALSE 74629
// result := Insert ( result , result + 1 , j ) ;
74598: LD_ADDR_VAR 0 2
74602: PUSH
74603: LD_VAR 0 2
74607: PPUSH
74608: LD_VAR 0 2
74612: PUSH
74613: LD_INT 1
74615: PLUS
74616: PPUSH
74617: LD_VAR 0 7
74621: PPUSH
74622: CALL_OW 2
74626: ST_TO_ADDR
74627: GO 74595
74629: POP
74630: POP
// end ;
74631: GO 74561
74633: POP
74634: POP
// if not result then
74635: LD_VAR 0 2
74639: NOT
74640: IFFALSE 74644
// exit ;
74642: GO 74792
// mech := result [ 1 ] ;
74644: LD_ADDR_VAR 0 5
74648: PUSH
74649: LD_VAR 0 2
74653: PUSH
74654: LD_INT 1
74656: ARRAY
74657: ST_TO_ADDR
// if result > 1 then
74658: LD_VAR 0 2
74662: PUSH
74663: LD_INT 1
74665: GREATER
74666: IFFALSE 74778
// for i = 2 to result do
74668: LD_ADDR_VAR 0 3
74672: PUSH
74673: DOUBLE
74674: LD_INT 2
74676: DEC
74677: ST_TO_ADDR
74678: LD_VAR 0 2
74682: PUSH
74683: FOR_TO
74684: IFFALSE 74776
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74686: LD_ADDR_VAR 0 4
74690: PUSH
74691: LD_VAR 0 2
74695: PUSH
74696: LD_VAR 0 3
74700: ARRAY
74701: PPUSH
74702: LD_INT 3
74704: PPUSH
74705: CALL_OW 259
74709: PUSH
74710: LD_VAR 0 2
74714: PUSH
74715: LD_VAR 0 3
74719: ARRAY
74720: PPUSH
74721: CALL_OW 432
74725: MINUS
74726: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74727: LD_VAR 0 4
74731: PUSH
74732: LD_VAR 0 5
74736: PPUSH
74737: LD_INT 3
74739: PPUSH
74740: CALL_OW 259
74744: PUSH
74745: LD_VAR 0 5
74749: PPUSH
74750: CALL_OW 432
74754: MINUS
74755: GREATEREQUAL
74756: IFFALSE 74774
// mech := result [ i ] ;
74758: LD_ADDR_VAR 0 5
74762: PUSH
74763: LD_VAR 0 2
74767: PUSH
74768: LD_VAR 0 3
74772: ARRAY
74773: ST_TO_ADDR
// end ;
74774: GO 74683
74776: POP
74777: POP
// ComLinkTo ( vehicle , mech ) ;
74778: LD_VAR 0 1
74782: PPUSH
74783: LD_VAR 0 5
74787: PPUSH
74788: CALL_OW 135
// end ;
74792: LD_VAR 0 2
74796: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74797: LD_INT 0
74799: PPUSH
74800: PPUSH
74801: PPUSH
74802: PPUSH
74803: PPUSH
74804: PPUSH
74805: PPUSH
74806: PPUSH
74807: PPUSH
74808: PPUSH
74809: PPUSH
74810: PPUSH
74811: PPUSH
// result := [ ] ;
74812: LD_ADDR_VAR 0 7
74816: PUSH
74817: EMPTY
74818: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74819: LD_VAR 0 1
74823: PPUSH
74824: CALL_OW 266
74828: PUSH
74829: LD_INT 0
74831: PUSH
74832: LD_INT 1
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: IN
74839: NOT
74840: IFFALSE 74844
// exit ;
74842: GO 76475
// if name then
74844: LD_VAR 0 3
74848: IFFALSE 74864
// SetBName ( base_dep , name ) ;
74850: LD_VAR 0 1
74854: PPUSH
74855: LD_VAR 0 3
74859: PPUSH
74860: CALL_OW 500
// base := GetBase ( base_dep ) ;
74864: LD_ADDR_VAR 0 15
74868: PUSH
74869: LD_VAR 0 1
74873: PPUSH
74874: CALL_OW 274
74878: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74879: LD_ADDR_VAR 0 16
74883: PUSH
74884: LD_VAR 0 1
74888: PPUSH
74889: CALL_OW 255
74893: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74894: LD_ADDR_VAR 0 17
74898: PUSH
74899: LD_VAR 0 1
74903: PPUSH
74904: CALL_OW 248
74908: ST_TO_ADDR
// if sources then
74909: LD_VAR 0 5
74913: IFFALSE 74960
// for i = 1 to 3 do
74915: LD_ADDR_VAR 0 8
74919: PUSH
74920: DOUBLE
74921: LD_INT 1
74923: DEC
74924: ST_TO_ADDR
74925: LD_INT 3
74927: PUSH
74928: FOR_TO
74929: IFFALSE 74958
// AddResourceType ( base , i , sources [ i ] ) ;
74931: LD_VAR 0 15
74935: PPUSH
74936: LD_VAR 0 8
74940: PPUSH
74941: LD_VAR 0 5
74945: PUSH
74946: LD_VAR 0 8
74950: ARRAY
74951: PPUSH
74952: CALL_OW 276
74956: GO 74928
74958: POP
74959: POP
// buildings := GetBaseBuildings ( base , area ) ;
74960: LD_ADDR_VAR 0 18
74964: PUSH
74965: LD_VAR 0 15
74969: PPUSH
74970: LD_VAR 0 2
74974: PPUSH
74975: CALL 74252 0 2
74979: ST_TO_ADDR
// InitHc ;
74980: CALL_OW 19
// InitUc ;
74984: CALL_OW 18
// uc_side := side ;
74988: LD_ADDR_OWVAR 20
74992: PUSH
74993: LD_VAR 0 16
74997: ST_TO_ADDR
// uc_nation := nation ;
74998: LD_ADDR_OWVAR 21
75002: PUSH
75003: LD_VAR 0 17
75007: ST_TO_ADDR
// if buildings then
75008: LD_VAR 0 18
75012: IFFALSE 76334
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75014: LD_ADDR_VAR 0 19
75018: PUSH
75019: LD_VAR 0 18
75023: PPUSH
75024: LD_INT 2
75026: PUSH
75027: LD_INT 30
75029: PUSH
75030: LD_INT 29
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 30
75039: PUSH
75040: LD_INT 30
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: LIST
75051: PPUSH
75052: CALL_OW 72
75056: ST_TO_ADDR
// if tmp then
75057: LD_VAR 0 19
75061: IFFALSE 75109
// for i in tmp do
75063: LD_ADDR_VAR 0 8
75067: PUSH
75068: LD_VAR 0 19
75072: PUSH
75073: FOR_IN
75074: IFFALSE 75107
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75076: LD_VAR 0 8
75080: PPUSH
75081: CALL_OW 250
75085: PPUSH
75086: LD_VAR 0 8
75090: PPUSH
75091: CALL_OW 251
75095: PPUSH
75096: LD_VAR 0 16
75100: PPUSH
75101: CALL_OW 441
75105: GO 75073
75107: POP
75108: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75109: LD_VAR 0 18
75113: PPUSH
75114: LD_INT 2
75116: PUSH
75117: LD_INT 30
75119: PUSH
75120: LD_INT 32
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 30
75129: PUSH
75130: LD_INT 33
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: LIST
75141: PPUSH
75142: CALL_OW 72
75146: IFFALSE 75234
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75148: LD_ADDR_VAR 0 8
75152: PUSH
75153: LD_VAR 0 18
75157: PPUSH
75158: LD_INT 2
75160: PUSH
75161: LD_INT 30
75163: PUSH
75164: LD_INT 32
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: LD_INT 30
75173: PUSH
75174: LD_INT 33
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: LIST
75185: PPUSH
75186: CALL_OW 72
75190: PUSH
75191: FOR_IN
75192: IFFALSE 75232
// begin if not GetBWeapon ( i ) then
75194: LD_VAR 0 8
75198: PPUSH
75199: CALL_OW 269
75203: NOT
75204: IFFALSE 75230
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75206: LD_VAR 0 8
75210: PPUSH
75211: LD_VAR 0 8
75215: PPUSH
75216: LD_VAR 0 2
75220: PPUSH
75221: CALL 76480 0 2
75225: PPUSH
75226: CALL_OW 431
// end ;
75230: GO 75191
75232: POP
75233: POP
// end ; for i = 1 to personel do
75234: LD_ADDR_VAR 0 8
75238: PUSH
75239: DOUBLE
75240: LD_INT 1
75242: DEC
75243: ST_TO_ADDR
75244: LD_VAR 0 6
75248: PUSH
75249: FOR_TO
75250: IFFALSE 76314
// begin if i > 4 then
75252: LD_VAR 0 8
75256: PUSH
75257: LD_INT 4
75259: GREATER
75260: IFFALSE 75264
// break ;
75262: GO 76314
// case i of 1 :
75264: LD_VAR 0 8
75268: PUSH
75269: LD_INT 1
75271: DOUBLE
75272: EQUAL
75273: IFTRUE 75277
75275: GO 75357
75277: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75278: LD_ADDR_VAR 0 12
75282: PUSH
75283: LD_VAR 0 18
75287: PPUSH
75288: LD_INT 22
75290: PUSH
75291: LD_VAR 0 16
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 58
75302: PUSH
75303: EMPTY
75304: LIST
75305: PUSH
75306: LD_INT 2
75308: PUSH
75309: LD_INT 30
75311: PUSH
75312: LD_INT 32
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: PUSH
75319: LD_INT 30
75321: PUSH
75322: LD_INT 4
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: PUSH
75329: LD_INT 30
75331: PUSH
75332: LD_INT 5
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: LIST
75343: LIST
75344: PUSH
75345: EMPTY
75346: LIST
75347: LIST
75348: LIST
75349: PPUSH
75350: CALL_OW 72
75354: ST_TO_ADDR
75355: GO 75579
75357: LD_INT 2
75359: DOUBLE
75360: EQUAL
75361: IFTRUE 75365
75363: GO 75427
75365: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75366: LD_ADDR_VAR 0 12
75370: PUSH
75371: LD_VAR 0 18
75375: PPUSH
75376: LD_INT 22
75378: PUSH
75379: LD_VAR 0 16
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 2
75390: PUSH
75391: LD_INT 30
75393: PUSH
75394: LD_INT 0
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 30
75403: PUSH
75404: LD_INT 1
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: LIST
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PPUSH
75420: CALL_OW 72
75424: ST_TO_ADDR
75425: GO 75579
75427: LD_INT 3
75429: DOUBLE
75430: EQUAL
75431: IFTRUE 75435
75433: GO 75497
75435: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75436: LD_ADDR_VAR 0 12
75440: PUSH
75441: LD_VAR 0 18
75445: PPUSH
75446: LD_INT 22
75448: PUSH
75449: LD_VAR 0 16
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: PUSH
75458: LD_INT 2
75460: PUSH
75461: LD_INT 30
75463: PUSH
75464: LD_INT 2
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 30
75473: PUSH
75474: LD_INT 3
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: LIST
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: PPUSH
75490: CALL_OW 72
75494: ST_TO_ADDR
75495: GO 75579
75497: LD_INT 4
75499: DOUBLE
75500: EQUAL
75501: IFTRUE 75505
75503: GO 75578
75505: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75506: LD_ADDR_VAR 0 12
75510: PUSH
75511: LD_VAR 0 18
75515: PPUSH
75516: LD_INT 22
75518: PUSH
75519: LD_VAR 0 16
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: LD_INT 2
75530: PUSH
75531: LD_INT 30
75533: PUSH
75534: LD_INT 6
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 30
75543: PUSH
75544: LD_INT 7
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: LD_INT 30
75553: PUSH
75554: LD_INT 8
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: LIST
75565: LIST
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PPUSH
75571: CALL_OW 72
75575: ST_TO_ADDR
75576: GO 75579
75578: POP
// if i = 1 then
75579: LD_VAR 0 8
75583: PUSH
75584: LD_INT 1
75586: EQUAL
75587: IFFALSE 75698
// begin tmp := [ ] ;
75589: LD_ADDR_VAR 0 19
75593: PUSH
75594: EMPTY
75595: ST_TO_ADDR
// for j in f do
75596: LD_ADDR_VAR 0 9
75600: PUSH
75601: LD_VAR 0 12
75605: PUSH
75606: FOR_IN
75607: IFFALSE 75680
// if GetBType ( j ) = b_bunker then
75609: LD_VAR 0 9
75613: PPUSH
75614: CALL_OW 266
75618: PUSH
75619: LD_INT 32
75621: EQUAL
75622: IFFALSE 75649
// tmp := Insert ( tmp , 1 , j ) else
75624: LD_ADDR_VAR 0 19
75628: PUSH
75629: LD_VAR 0 19
75633: PPUSH
75634: LD_INT 1
75636: PPUSH
75637: LD_VAR 0 9
75641: PPUSH
75642: CALL_OW 2
75646: ST_TO_ADDR
75647: GO 75678
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75649: LD_ADDR_VAR 0 19
75653: PUSH
75654: LD_VAR 0 19
75658: PPUSH
75659: LD_VAR 0 19
75663: PUSH
75664: LD_INT 1
75666: PLUS
75667: PPUSH
75668: LD_VAR 0 9
75672: PPUSH
75673: CALL_OW 2
75677: ST_TO_ADDR
75678: GO 75606
75680: POP
75681: POP
// if tmp then
75682: LD_VAR 0 19
75686: IFFALSE 75698
// f := tmp ;
75688: LD_ADDR_VAR 0 12
75692: PUSH
75693: LD_VAR 0 19
75697: ST_TO_ADDR
// end ; x := personel [ i ] ;
75698: LD_ADDR_VAR 0 13
75702: PUSH
75703: LD_VAR 0 6
75707: PUSH
75708: LD_VAR 0 8
75712: ARRAY
75713: ST_TO_ADDR
// if x = - 1 then
75714: LD_VAR 0 13
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: EQUAL
75723: IFFALSE 75932
// begin for j in f do
75725: LD_ADDR_VAR 0 9
75729: PUSH
75730: LD_VAR 0 12
75734: PUSH
75735: FOR_IN
75736: IFFALSE 75928
// repeat InitHc ;
75738: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75742: LD_VAR 0 9
75746: PPUSH
75747: CALL_OW 266
75751: PUSH
75752: LD_INT 5
75754: EQUAL
75755: IFFALSE 75825
// begin if UnitsInside ( j ) < 3 then
75757: LD_VAR 0 9
75761: PPUSH
75762: CALL_OW 313
75766: PUSH
75767: LD_INT 3
75769: LESS
75770: IFFALSE 75806
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75772: LD_INT 0
75774: PPUSH
75775: LD_INT 5
75777: PUSH
75778: LD_INT 8
75780: PUSH
75781: LD_INT 9
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: LIST
75788: PUSH
75789: LD_VAR 0 17
75793: ARRAY
75794: PPUSH
75795: LD_VAR 0 4
75799: PPUSH
75800: CALL_OW 380
75804: GO 75823
// PrepareHuman ( false , i , skill ) ;
75806: LD_INT 0
75808: PPUSH
75809: LD_VAR 0 8
75813: PPUSH
75814: LD_VAR 0 4
75818: PPUSH
75819: CALL_OW 380
// end else
75823: GO 75842
// PrepareHuman ( false , i , skill ) ;
75825: LD_INT 0
75827: PPUSH
75828: LD_VAR 0 8
75832: PPUSH
75833: LD_VAR 0 4
75837: PPUSH
75838: CALL_OW 380
// un := CreateHuman ;
75842: LD_ADDR_VAR 0 14
75846: PUSH
75847: CALL_OW 44
75851: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75852: LD_ADDR_VAR 0 7
75856: PUSH
75857: LD_VAR 0 7
75861: PPUSH
75862: LD_INT 1
75864: PPUSH
75865: LD_VAR 0 14
75869: PPUSH
75870: CALL_OW 2
75874: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75875: LD_VAR 0 14
75879: PPUSH
75880: LD_VAR 0 9
75884: PPUSH
75885: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75889: LD_VAR 0 9
75893: PPUSH
75894: CALL_OW 313
75898: PUSH
75899: LD_INT 6
75901: EQUAL
75902: PUSH
75903: LD_VAR 0 9
75907: PPUSH
75908: CALL_OW 266
75912: PUSH
75913: LD_INT 32
75915: PUSH
75916: LD_INT 31
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: IN
75923: OR
75924: IFFALSE 75738
75926: GO 75735
75928: POP
75929: POP
// end else
75930: GO 76312
// for j = 1 to x do
75932: LD_ADDR_VAR 0 9
75936: PUSH
75937: DOUBLE
75938: LD_INT 1
75940: DEC
75941: ST_TO_ADDR
75942: LD_VAR 0 13
75946: PUSH
75947: FOR_TO
75948: IFFALSE 76310
// begin InitHc ;
75950: CALL_OW 19
// if not f then
75954: LD_VAR 0 12
75958: NOT
75959: IFFALSE 76048
// begin PrepareHuman ( false , i , skill ) ;
75961: LD_INT 0
75963: PPUSH
75964: LD_VAR 0 8
75968: PPUSH
75969: LD_VAR 0 4
75973: PPUSH
75974: CALL_OW 380
// un := CreateHuman ;
75978: LD_ADDR_VAR 0 14
75982: PUSH
75983: CALL_OW 44
75987: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75988: LD_ADDR_VAR 0 7
75992: PUSH
75993: LD_VAR 0 7
75997: PPUSH
75998: LD_INT 1
76000: PPUSH
76001: LD_VAR 0 14
76005: PPUSH
76006: CALL_OW 2
76010: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76011: LD_VAR 0 14
76015: PPUSH
76016: LD_VAR 0 1
76020: PPUSH
76021: CALL_OW 250
76025: PPUSH
76026: LD_VAR 0 1
76030: PPUSH
76031: CALL_OW 251
76035: PPUSH
76036: LD_INT 10
76038: PPUSH
76039: LD_INT 0
76041: PPUSH
76042: CALL_OW 50
// continue ;
76046: GO 75947
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76048: LD_VAR 0 12
76052: PUSH
76053: LD_INT 1
76055: ARRAY
76056: PPUSH
76057: CALL_OW 313
76061: PUSH
76062: LD_VAR 0 12
76066: PUSH
76067: LD_INT 1
76069: ARRAY
76070: PPUSH
76071: CALL_OW 266
76075: PUSH
76076: LD_INT 32
76078: PUSH
76079: LD_INT 31
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: IN
76086: AND
76087: PUSH
76088: LD_VAR 0 12
76092: PUSH
76093: LD_INT 1
76095: ARRAY
76096: PPUSH
76097: CALL_OW 313
76101: PUSH
76102: LD_INT 6
76104: EQUAL
76105: OR
76106: IFFALSE 76126
// f := Delete ( f , 1 ) ;
76108: LD_ADDR_VAR 0 12
76112: PUSH
76113: LD_VAR 0 12
76117: PPUSH
76118: LD_INT 1
76120: PPUSH
76121: CALL_OW 3
76125: ST_TO_ADDR
// if not f then
76126: LD_VAR 0 12
76130: NOT
76131: IFFALSE 76149
// begin x := x + 2 ;
76133: LD_ADDR_VAR 0 13
76137: PUSH
76138: LD_VAR 0 13
76142: PUSH
76143: LD_INT 2
76145: PLUS
76146: ST_TO_ADDR
// continue ;
76147: GO 75947
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76149: LD_VAR 0 12
76153: PUSH
76154: LD_INT 1
76156: ARRAY
76157: PPUSH
76158: CALL_OW 266
76162: PUSH
76163: LD_INT 5
76165: EQUAL
76166: IFFALSE 76240
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76168: LD_VAR 0 12
76172: PUSH
76173: LD_INT 1
76175: ARRAY
76176: PPUSH
76177: CALL_OW 313
76181: PUSH
76182: LD_INT 3
76184: LESS
76185: IFFALSE 76221
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76187: LD_INT 0
76189: PPUSH
76190: LD_INT 5
76192: PUSH
76193: LD_INT 8
76195: PUSH
76196: LD_INT 9
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: LIST
76203: PUSH
76204: LD_VAR 0 17
76208: ARRAY
76209: PPUSH
76210: LD_VAR 0 4
76214: PPUSH
76215: CALL_OW 380
76219: GO 76238
// PrepareHuman ( false , i , skill ) ;
76221: LD_INT 0
76223: PPUSH
76224: LD_VAR 0 8
76228: PPUSH
76229: LD_VAR 0 4
76233: PPUSH
76234: CALL_OW 380
// end else
76238: GO 76257
// PrepareHuman ( false , i , skill ) ;
76240: LD_INT 0
76242: PPUSH
76243: LD_VAR 0 8
76247: PPUSH
76248: LD_VAR 0 4
76252: PPUSH
76253: CALL_OW 380
// un := CreateHuman ;
76257: LD_ADDR_VAR 0 14
76261: PUSH
76262: CALL_OW 44
76266: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76267: LD_ADDR_VAR 0 7
76271: PUSH
76272: LD_VAR 0 7
76276: PPUSH
76277: LD_INT 1
76279: PPUSH
76280: LD_VAR 0 14
76284: PPUSH
76285: CALL_OW 2
76289: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76290: LD_VAR 0 14
76294: PPUSH
76295: LD_VAR 0 12
76299: PUSH
76300: LD_INT 1
76302: ARRAY
76303: PPUSH
76304: CALL_OW 52
// end ;
76308: GO 75947
76310: POP
76311: POP
// end ;
76312: GO 75249
76314: POP
76315: POP
// result := result ^ buildings ;
76316: LD_ADDR_VAR 0 7
76320: PUSH
76321: LD_VAR 0 7
76325: PUSH
76326: LD_VAR 0 18
76330: ADD
76331: ST_TO_ADDR
// end else
76332: GO 76475
// begin for i = 1 to personel do
76334: LD_ADDR_VAR 0 8
76338: PUSH
76339: DOUBLE
76340: LD_INT 1
76342: DEC
76343: ST_TO_ADDR
76344: LD_VAR 0 6
76348: PUSH
76349: FOR_TO
76350: IFFALSE 76473
// begin if i > 4 then
76352: LD_VAR 0 8
76356: PUSH
76357: LD_INT 4
76359: GREATER
76360: IFFALSE 76364
// break ;
76362: GO 76473
// x := personel [ i ] ;
76364: LD_ADDR_VAR 0 13
76368: PUSH
76369: LD_VAR 0 6
76373: PUSH
76374: LD_VAR 0 8
76378: ARRAY
76379: ST_TO_ADDR
// if x = - 1 then
76380: LD_VAR 0 13
76384: PUSH
76385: LD_INT 1
76387: NEG
76388: EQUAL
76389: IFFALSE 76393
// continue ;
76391: GO 76349
// PrepareHuman ( false , i , skill ) ;
76393: LD_INT 0
76395: PPUSH
76396: LD_VAR 0 8
76400: PPUSH
76401: LD_VAR 0 4
76405: PPUSH
76406: CALL_OW 380
// un := CreateHuman ;
76410: LD_ADDR_VAR 0 14
76414: PUSH
76415: CALL_OW 44
76419: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76420: LD_VAR 0 14
76424: PPUSH
76425: LD_VAR 0 1
76429: PPUSH
76430: CALL_OW 250
76434: PPUSH
76435: LD_VAR 0 1
76439: PPUSH
76440: CALL_OW 251
76444: PPUSH
76445: LD_INT 10
76447: PPUSH
76448: LD_INT 0
76450: PPUSH
76451: CALL_OW 50
// result := result ^ un ;
76455: LD_ADDR_VAR 0 7
76459: PUSH
76460: LD_VAR 0 7
76464: PUSH
76465: LD_VAR 0 14
76469: ADD
76470: ST_TO_ADDR
// end ;
76471: GO 76349
76473: POP
76474: POP
// end ; end ;
76475: LD_VAR 0 7
76479: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76480: LD_INT 0
76482: PPUSH
76483: PPUSH
76484: PPUSH
76485: PPUSH
76486: PPUSH
76487: PPUSH
76488: PPUSH
76489: PPUSH
76490: PPUSH
76491: PPUSH
76492: PPUSH
76493: PPUSH
76494: PPUSH
76495: PPUSH
76496: PPUSH
76497: PPUSH
// result := false ;
76498: LD_ADDR_VAR 0 3
76502: PUSH
76503: LD_INT 0
76505: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76506: LD_VAR 0 1
76510: NOT
76511: PUSH
76512: LD_VAR 0 1
76516: PPUSH
76517: CALL_OW 266
76521: PUSH
76522: LD_INT 32
76524: PUSH
76525: LD_INT 33
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: IN
76532: NOT
76533: OR
76534: IFFALSE 76538
// exit ;
76536: GO 77674
// nat := GetNation ( tower ) ;
76538: LD_ADDR_VAR 0 12
76542: PUSH
76543: LD_VAR 0 1
76547: PPUSH
76548: CALL_OW 248
76552: ST_TO_ADDR
// side := GetSide ( tower ) ;
76553: LD_ADDR_VAR 0 16
76557: PUSH
76558: LD_VAR 0 1
76562: PPUSH
76563: CALL_OW 255
76567: ST_TO_ADDR
// x := GetX ( tower ) ;
76568: LD_ADDR_VAR 0 10
76572: PUSH
76573: LD_VAR 0 1
76577: PPUSH
76578: CALL_OW 250
76582: ST_TO_ADDR
// y := GetY ( tower ) ;
76583: LD_ADDR_VAR 0 11
76587: PUSH
76588: LD_VAR 0 1
76592: PPUSH
76593: CALL_OW 251
76597: ST_TO_ADDR
// if not x or not y then
76598: LD_VAR 0 10
76602: NOT
76603: PUSH
76604: LD_VAR 0 11
76608: NOT
76609: OR
76610: IFFALSE 76614
// exit ;
76612: GO 77674
// weapon := 0 ;
76614: LD_ADDR_VAR 0 18
76618: PUSH
76619: LD_INT 0
76621: ST_TO_ADDR
// fac_list := [ ] ;
76622: LD_ADDR_VAR 0 17
76626: PUSH
76627: EMPTY
76628: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76629: LD_ADDR_VAR 0 6
76633: PUSH
76634: LD_VAR 0 1
76638: PPUSH
76639: CALL_OW 274
76643: PPUSH
76644: LD_VAR 0 2
76648: PPUSH
76649: CALL 74252 0 2
76653: PPUSH
76654: LD_INT 30
76656: PUSH
76657: LD_INT 3
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PPUSH
76664: CALL_OW 72
76668: ST_TO_ADDR
// if not factories then
76669: LD_VAR 0 6
76673: NOT
76674: IFFALSE 76678
// exit ;
76676: GO 77674
// for i in factories do
76678: LD_ADDR_VAR 0 8
76682: PUSH
76683: LD_VAR 0 6
76687: PUSH
76688: FOR_IN
76689: IFFALSE 76714
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76691: LD_ADDR_VAR 0 17
76695: PUSH
76696: LD_VAR 0 17
76700: PUSH
76701: LD_VAR 0 8
76705: PPUSH
76706: CALL_OW 478
76710: UNION
76711: ST_TO_ADDR
76712: GO 76688
76714: POP
76715: POP
// if not fac_list then
76716: LD_VAR 0 17
76720: NOT
76721: IFFALSE 76725
// exit ;
76723: GO 77674
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76725: LD_ADDR_VAR 0 5
76729: PUSH
76730: LD_INT 4
76732: PUSH
76733: LD_INT 5
76735: PUSH
76736: LD_INT 9
76738: PUSH
76739: LD_INT 10
76741: PUSH
76742: LD_INT 6
76744: PUSH
76745: LD_INT 7
76747: PUSH
76748: LD_INT 11
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: PUSH
76760: LD_INT 27
76762: PUSH
76763: LD_INT 28
76765: PUSH
76766: LD_INT 26
76768: PUSH
76769: LD_INT 30
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: LIST
76776: LIST
76777: PUSH
76778: LD_INT 43
76780: PUSH
76781: LD_INT 44
76783: PUSH
76784: LD_INT 46
76786: PUSH
76787: LD_INT 45
76789: PUSH
76790: LD_INT 47
76792: PUSH
76793: LD_INT 49
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: LIST
76800: LIST
76801: LIST
76802: LIST
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: LIST
76808: PUSH
76809: LD_VAR 0 12
76813: ARRAY
76814: ST_TO_ADDR
// for i in list do
76815: LD_ADDR_VAR 0 8
76819: PUSH
76820: LD_VAR 0 5
76824: PUSH
76825: FOR_IN
76826: IFFALSE 76859
// if not i in fac_list then
76828: LD_VAR 0 8
76832: PUSH
76833: LD_VAR 0 17
76837: IN
76838: NOT
76839: IFFALSE 76857
// list := list diff i ;
76841: LD_ADDR_VAR 0 5
76845: PUSH
76846: LD_VAR 0 5
76850: PUSH
76851: LD_VAR 0 8
76855: DIFF
76856: ST_TO_ADDR
76857: GO 76825
76859: POP
76860: POP
// if not list then
76861: LD_VAR 0 5
76865: NOT
76866: IFFALSE 76870
// exit ;
76868: GO 77674
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76870: LD_VAR 0 12
76874: PUSH
76875: LD_INT 3
76877: EQUAL
76878: PUSH
76879: LD_INT 49
76881: PUSH
76882: LD_VAR 0 5
76886: IN
76887: AND
76888: PUSH
76889: LD_INT 31
76891: PPUSH
76892: LD_VAR 0 16
76896: PPUSH
76897: CALL_OW 321
76901: PUSH
76902: LD_INT 2
76904: EQUAL
76905: AND
76906: IFFALSE 76966
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76908: LD_INT 22
76910: PUSH
76911: LD_VAR 0 16
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 35
76922: PUSH
76923: LD_INT 49
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: LD_INT 91
76932: PUSH
76933: LD_VAR 0 1
76937: PUSH
76938: LD_INT 10
76940: PUSH
76941: EMPTY
76942: LIST
76943: LIST
76944: LIST
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: LIST
76950: PPUSH
76951: CALL_OW 69
76955: NOT
76956: IFFALSE 76966
// weapon := ru_time_lapser ;
76958: LD_ADDR_VAR 0 18
76962: PUSH
76963: LD_INT 49
76965: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76966: LD_VAR 0 12
76970: PUSH
76971: LD_INT 1
76973: PUSH
76974: LD_INT 2
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: IN
76981: PUSH
76982: LD_INT 11
76984: PUSH
76985: LD_VAR 0 5
76989: IN
76990: PUSH
76991: LD_INT 30
76993: PUSH
76994: LD_VAR 0 5
76998: IN
76999: OR
77000: AND
77001: PUSH
77002: LD_INT 6
77004: PPUSH
77005: LD_VAR 0 16
77009: PPUSH
77010: CALL_OW 321
77014: PUSH
77015: LD_INT 2
77017: EQUAL
77018: AND
77019: IFFALSE 77184
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77021: LD_INT 22
77023: PUSH
77024: LD_VAR 0 16
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: PUSH
77033: LD_INT 2
77035: PUSH
77036: LD_INT 35
77038: PUSH
77039: LD_INT 11
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 35
77048: PUSH
77049: LD_INT 30
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: LIST
77060: PUSH
77061: LD_INT 91
77063: PUSH
77064: LD_VAR 0 1
77068: PUSH
77069: LD_INT 18
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: LIST
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: LIST
77081: PPUSH
77082: CALL_OW 69
77086: NOT
77087: PUSH
77088: LD_INT 22
77090: PUSH
77091: LD_VAR 0 16
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: PUSH
77100: LD_INT 2
77102: PUSH
77103: LD_INT 30
77105: PUSH
77106: LD_INT 32
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 30
77115: PUSH
77116: LD_INT 33
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: LIST
77127: PUSH
77128: LD_INT 91
77130: PUSH
77131: LD_VAR 0 1
77135: PUSH
77136: LD_INT 12
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: LIST
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: LIST
77148: PUSH
77149: EMPTY
77150: LIST
77151: PPUSH
77152: CALL_OW 69
77156: PUSH
77157: LD_INT 2
77159: GREATER
77160: AND
77161: IFFALSE 77184
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77163: LD_ADDR_VAR 0 18
77167: PUSH
77168: LD_INT 11
77170: PUSH
77171: LD_INT 30
77173: PUSH
77174: EMPTY
77175: LIST
77176: LIST
77177: PUSH
77178: LD_VAR 0 12
77182: ARRAY
77183: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77184: LD_VAR 0 18
77188: NOT
77189: PUSH
77190: LD_INT 40
77192: PPUSH
77193: LD_VAR 0 16
77197: PPUSH
77198: CALL_OW 321
77202: PUSH
77203: LD_INT 2
77205: EQUAL
77206: AND
77207: PUSH
77208: LD_INT 7
77210: PUSH
77211: LD_VAR 0 5
77215: IN
77216: PUSH
77217: LD_INT 28
77219: PUSH
77220: LD_VAR 0 5
77224: IN
77225: OR
77226: PUSH
77227: LD_INT 45
77229: PUSH
77230: LD_VAR 0 5
77234: IN
77235: OR
77236: AND
77237: IFFALSE 77491
// begin hex := GetHexInfo ( x , y ) ;
77239: LD_ADDR_VAR 0 4
77243: PUSH
77244: LD_VAR 0 10
77248: PPUSH
77249: LD_VAR 0 11
77253: PPUSH
77254: CALL_OW 546
77258: ST_TO_ADDR
// if hex [ 1 ] then
77259: LD_VAR 0 4
77263: PUSH
77264: LD_INT 1
77266: ARRAY
77267: IFFALSE 77271
// exit ;
77269: GO 77674
// height := hex [ 2 ] ;
77271: LD_ADDR_VAR 0 15
77275: PUSH
77276: LD_VAR 0 4
77280: PUSH
77281: LD_INT 2
77283: ARRAY
77284: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77285: LD_ADDR_VAR 0 14
77289: PUSH
77290: LD_INT 0
77292: PUSH
77293: LD_INT 2
77295: PUSH
77296: LD_INT 3
77298: PUSH
77299: LD_INT 5
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: LIST
77306: LIST
77307: ST_TO_ADDR
// for i in tmp do
77308: LD_ADDR_VAR 0 8
77312: PUSH
77313: LD_VAR 0 14
77317: PUSH
77318: FOR_IN
77319: IFFALSE 77489
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77321: LD_ADDR_VAR 0 9
77325: PUSH
77326: LD_VAR 0 10
77330: PPUSH
77331: LD_VAR 0 8
77335: PPUSH
77336: LD_INT 5
77338: PPUSH
77339: CALL_OW 272
77343: PUSH
77344: LD_VAR 0 11
77348: PPUSH
77349: LD_VAR 0 8
77353: PPUSH
77354: LD_INT 5
77356: PPUSH
77357: CALL_OW 273
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77366: LD_VAR 0 9
77370: PUSH
77371: LD_INT 1
77373: ARRAY
77374: PPUSH
77375: LD_VAR 0 9
77379: PUSH
77380: LD_INT 2
77382: ARRAY
77383: PPUSH
77384: CALL_OW 488
77388: IFFALSE 77487
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77390: LD_ADDR_VAR 0 4
77394: PUSH
77395: LD_VAR 0 9
77399: PUSH
77400: LD_INT 1
77402: ARRAY
77403: PPUSH
77404: LD_VAR 0 9
77408: PUSH
77409: LD_INT 2
77411: ARRAY
77412: PPUSH
77413: CALL_OW 546
77417: ST_TO_ADDR
// if hex [ 1 ] then
77418: LD_VAR 0 4
77422: PUSH
77423: LD_INT 1
77425: ARRAY
77426: IFFALSE 77430
// continue ;
77428: GO 77318
// h := hex [ 2 ] ;
77430: LD_ADDR_VAR 0 13
77434: PUSH
77435: LD_VAR 0 4
77439: PUSH
77440: LD_INT 2
77442: ARRAY
77443: ST_TO_ADDR
// if h + 7 < height then
77444: LD_VAR 0 13
77448: PUSH
77449: LD_INT 7
77451: PLUS
77452: PUSH
77453: LD_VAR 0 15
77457: LESS
77458: IFFALSE 77487
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77460: LD_ADDR_VAR 0 18
77464: PUSH
77465: LD_INT 7
77467: PUSH
77468: LD_INT 28
77470: PUSH
77471: LD_INT 45
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: LIST
77478: PUSH
77479: LD_VAR 0 12
77483: ARRAY
77484: ST_TO_ADDR
// break ;
77485: GO 77489
// end ; end ; end ;
77487: GO 77318
77489: POP
77490: POP
// end ; if not weapon then
77491: LD_VAR 0 18
77495: NOT
77496: IFFALSE 77556
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77498: LD_ADDR_VAR 0 5
77502: PUSH
77503: LD_VAR 0 5
77507: PUSH
77508: LD_INT 11
77510: PUSH
77511: LD_INT 30
77513: PUSH
77514: LD_INT 49
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: LIST
77521: DIFF
77522: ST_TO_ADDR
// if not list then
77523: LD_VAR 0 5
77527: NOT
77528: IFFALSE 77532
// exit ;
77530: GO 77674
// weapon := list [ rand ( 1 , list ) ] ;
77532: LD_ADDR_VAR 0 18
77536: PUSH
77537: LD_VAR 0 5
77541: PUSH
77542: LD_INT 1
77544: PPUSH
77545: LD_VAR 0 5
77549: PPUSH
77550: CALL_OW 12
77554: ARRAY
77555: ST_TO_ADDR
// end ; if weapon then
77556: LD_VAR 0 18
77560: IFFALSE 77674
// begin tmp := CostOfWeapon ( weapon ) ;
77562: LD_ADDR_VAR 0 14
77566: PUSH
77567: LD_VAR 0 18
77571: PPUSH
77572: CALL_OW 451
77576: ST_TO_ADDR
// j := GetBase ( tower ) ;
77577: LD_ADDR_VAR 0 9
77581: PUSH
77582: LD_VAR 0 1
77586: PPUSH
77587: CALL_OW 274
77591: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77592: LD_VAR 0 9
77596: PPUSH
77597: LD_INT 1
77599: PPUSH
77600: CALL_OW 275
77604: PUSH
77605: LD_VAR 0 14
77609: PUSH
77610: LD_INT 1
77612: ARRAY
77613: GREATEREQUAL
77614: PUSH
77615: LD_VAR 0 9
77619: PPUSH
77620: LD_INT 2
77622: PPUSH
77623: CALL_OW 275
77627: PUSH
77628: LD_VAR 0 14
77632: PUSH
77633: LD_INT 2
77635: ARRAY
77636: GREATEREQUAL
77637: AND
77638: PUSH
77639: LD_VAR 0 9
77643: PPUSH
77644: LD_INT 3
77646: PPUSH
77647: CALL_OW 275
77651: PUSH
77652: LD_VAR 0 14
77656: PUSH
77657: LD_INT 3
77659: ARRAY
77660: GREATEREQUAL
77661: AND
77662: IFFALSE 77674
// result := weapon ;
77664: LD_ADDR_VAR 0 3
77668: PUSH
77669: LD_VAR 0 18
77673: ST_TO_ADDR
// end ; end ;
77674: LD_VAR 0 3
77678: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77679: LD_INT 0
77681: PPUSH
77682: PPUSH
// result := true ;
77683: LD_ADDR_VAR 0 3
77687: PUSH
77688: LD_INT 1
77690: ST_TO_ADDR
// if array1 = array2 then
77691: LD_VAR 0 1
77695: PUSH
77696: LD_VAR 0 2
77700: EQUAL
77701: IFFALSE 77761
// begin for i = 1 to array1 do
77703: LD_ADDR_VAR 0 4
77707: PUSH
77708: DOUBLE
77709: LD_INT 1
77711: DEC
77712: ST_TO_ADDR
77713: LD_VAR 0 1
77717: PUSH
77718: FOR_TO
77719: IFFALSE 77757
// if array1 [ i ] <> array2 [ i ] then
77721: LD_VAR 0 1
77725: PUSH
77726: LD_VAR 0 4
77730: ARRAY
77731: PUSH
77732: LD_VAR 0 2
77736: PUSH
77737: LD_VAR 0 4
77741: ARRAY
77742: NONEQUAL
77743: IFFALSE 77755
// begin result := false ;
77745: LD_ADDR_VAR 0 3
77749: PUSH
77750: LD_INT 0
77752: ST_TO_ADDR
// break ;
77753: GO 77757
// end ;
77755: GO 77718
77757: POP
77758: POP
// end else
77759: GO 77769
// result := false ;
77761: LD_ADDR_VAR 0 3
77765: PUSH
77766: LD_INT 0
77768: ST_TO_ADDR
// end ;
77769: LD_VAR 0 3
77773: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77774: LD_INT 0
77776: PPUSH
77777: PPUSH
77778: PPUSH
// pom := GetBase ( fac ) ;
77779: LD_ADDR_VAR 0 5
77783: PUSH
77784: LD_VAR 0 1
77788: PPUSH
77789: CALL_OW 274
77793: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77794: LD_ADDR_VAR 0 4
77798: PUSH
77799: LD_VAR 0 2
77803: PUSH
77804: LD_INT 1
77806: ARRAY
77807: PPUSH
77808: LD_VAR 0 2
77812: PUSH
77813: LD_INT 2
77815: ARRAY
77816: PPUSH
77817: LD_VAR 0 2
77821: PUSH
77822: LD_INT 3
77824: ARRAY
77825: PPUSH
77826: LD_VAR 0 2
77830: PUSH
77831: LD_INT 4
77833: ARRAY
77834: PPUSH
77835: CALL_OW 449
77839: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77840: LD_ADDR_VAR 0 3
77844: PUSH
77845: LD_VAR 0 5
77849: PPUSH
77850: LD_INT 1
77852: PPUSH
77853: CALL_OW 275
77857: PUSH
77858: LD_VAR 0 4
77862: PUSH
77863: LD_INT 1
77865: ARRAY
77866: GREATEREQUAL
77867: PUSH
77868: LD_VAR 0 5
77872: PPUSH
77873: LD_INT 2
77875: PPUSH
77876: CALL_OW 275
77880: PUSH
77881: LD_VAR 0 4
77885: PUSH
77886: LD_INT 2
77888: ARRAY
77889: GREATEREQUAL
77890: AND
77891: PUSH
77892: LD_VAR 0 5
77896: PPUSH
77897: LD_INT 3
77899: PPUSH
77900: CALL_OW 275
77904: PUSH
77905: LD_VAR 0 4
77909: PUSH
77910: LD_INT 3
77912: ARRAY
77913: GREATEREQUAL
77914: AND
77915: ST_TO_ADDR
// end ;
77916: LD_VAR 0 3
77920: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77921: LD_INT 0
77923: PPUSH
77924: PPUSH
77925: PPUSH
77926: PPUSH
// pom := GetBase ( building ) ;
77927: LD_ADDR_VAR 0 3
77931: PUSH
77932: LD_VAR 0 1
77936: PPUSH
77937: CALL_OW 274
77941: ST_TO_ADDR
// if not pom then
77942: LD_VAR 0 3
77946: NOT
77947: IFFALSE 77951
// exit ;
77949: GO 78121
// btype := GetBType ( building ) ;
77951: LD_ADDR_VAR 0 5
77955: PUSH
77956: LD_VAR 0 1
77960: PPUSH
77961: CALL_OW 266
77965: ST_TO_ADDR
// if btype = b_armoury then
77966: LD_VAR 0 5
77970: PUSH
77971: LD_INT 4
77973: EQUAL
77974: IFFALSE 77984
// btype := b_barracks ;
77976: LD_ADDR_VAR 0 5
77980: PUSH
77981: LD_INT 5
77983: ST_TO_ADDR
// if btype = b_depot then
77984: LD_VAR 0 5
77988: PUSH
77989: LD_INT 0
77991: EQUAL
77992: IFFALSE 78002
// btype := b_warehouse ;
77994: LD_ADDR_VAR 0 5
77998: PUSH
77999: LD_INT 1
78001: ST_TO_ADDR
// if btype = b_workshop then
78002: LD_VAR 0 5
78006: PUSH
78007: LD_INT 2
78009: EQUAL
78010: IFFALSE 78020
// btype := b_factory ;
78012: LD_ADDR_VAR 0 5
78016: PUSH
78017: LD_INT 3
78019: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78020: LD_ADDR_VAR 0 4
78024: PUSH
78025: LD_VAR 0 5
78029: PPUSH
78030: LD_VAR 0 1
78034: PPUSH
78035: CALL_OW 248
78039: PPUSH
78040: CALL_OW 450
78044: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78045: LD_ADDR_VAR 0 2
78049: PUSH
78050: LD_VAR 0 3
78054: PPUSH
78055: LD_INT 1
78057: PPUSH
78058: CALL_OW 275
78062: PUSH
78063: LD_VAR 0 4
78067: PUSH
78068: LD_INT 1
78070: ARRAY
78071: GREATEREQUAL
78072: PUSH
78073: LD_VAR 0 3
78077: PPUSH
78078: LD_INT 2
78080: PPUSH
78081: CALL_OW 275
78085: PUSH
78086: LD_VAR 0 4
78090: PUSH
78091: LD_INT 2
78093: ARRAY
78094: GREATEREQUAL
78095: AND
78096: PUSH
78097: LD_VAR 0 3
78101: PPUSH
78102: LD_INT 3
78104: PPUSH
78105: CALL_OW 275
78109: PUSH
78110: LD_VAR 0 4
78114: PUSH
78115: LD_INT 3
78117: ARRAY
78118: GREATEREQUAL
78119: AND
78120: ST_TO_ADDR
// end ;
78121: LD_VAR 0 2
78125: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78126: LD_INT 0
78128: PPUSH
78129: PPUSH
78130: PPUSH
// pom := GetBase ( building ) ;
78131: LD_ADDR_VAR 0 4
78135: PUSH
78136: LD_VAR 0 1
78140: PPUSH
78141: CALL_OW 274
78145: ST_TO_ADDR
// if not pom then
78146: LD_VAR 0 4
78150: NOT
78151: IFFALSE 78155
// exit ;
78153: GO 78256
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78155: LD_ADDR_VAR 0 5
78159: PUSH
78160: LD_VAR 0 2
78164: PPUSH
78165: LD_VAR 0 1
78169: PPUSH
78170: CALL_OW 248
78174: PPUSH
78175: CALL_OW 450
78179: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78180: LD_ADDR_VAR 0 3
78184: PUSH
78185: LD_VAR 0 4
78189: PPUSH
78190: LD_INT 1
78192: PPUSH
78193: CALL_OW 275
78197: PUSH
78198: LD_VAR 0 5
78202: PUSH
78203: LD_INT 1
78205: ARRAY
78206: GREATEREQUAL
78207: PUSH
78208: LD_VAR 0 4
78212: PPUSH
78213: LD_INT 2
78215: PPUSH
78216: CALL_OW 275
78220: PUSH
78221: LD_VAR 0 5
78225: PUSH
78226: LD_INT 2
78228: ARRAY
78229: GREATEREQUAL
78230: AND
78231: PUSH
78232: LD_VAR 0 4
78236: PPUSH
78237: LD_INT 3
78239: PPUSH
78240: CALL_OW 275
78244: PUSH
78245: LD_VAR 0 5
78249: PUSH
78250: LD_INT 3
78252: ARRAY
78253: GREATEREQUAL
78254: AND
78255: ST_TO_ADDR
// end ;
78256: LD_VAR 0 3
78260: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78261: LD_INT 0
78263: PPUSH
78264: PPUSH
78265: PPUSH
78266: PPUSH
78267: PPUSH
78268: PPUSH
78269: PPUSH
78270: PPUSH
78271: PPUSH
78272: PPUSH
// result := false ;
78273: LD_ADDR_VAR 0 6
78277: PUSH
78278: LD_INT 0
78280: ST_TO_ADDR
// if not base or not btype or not x or not y then
78281: LD_VAR 0 1
78285: NOT
78286: PUSH
78287: LD_VAR 0 2
78291: NOT
78292: OR
78293: PUSH
78294: LD_VAR 0 3
78298: NOT
78299: OR
78300: PUSH
78301: LD_VAR 0 4
78305: NOT
78306: OR
78307: IFFALSE 78311
// exit ;
78309: GO 78920
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78311: LD_ADDR_VAR 0 12
78315: PUSH
78316: LD_VAR 0 2
78320: PPUSH
78321: LD_VAR 0 3
78325: PPUSH
78326: LD_VAR 0 4
78330: PPUSH
78331: LD_VAR 0 5
78335: PPUSH
78336: LD_VAR 0 1
78340: PUSH
78341: LD_INT 1
78343: ARRAY
78344: PPUSH
78345: CALL_OW 248
78349: PPUSH
78350: LD_INT 0
78352: PPUSH
78353: CALL 79757 0 6
78357: ST_TO_ADDR
// if not hexes then
78358: LD_VAR 0 12
78362: NOT
78363: IFFALSE 78367
// exit ;
78365: GO 78920
// for i = 1 to hexes do
78367: LD_ADDR_VAR 0 7
78371: PUSH
78372: DOUBLE
78373: LD_INT 1
78375: DEC
78376: ST_TO_ADDR
78377: LD_VAR 0 12
78381: PUSH
78382: FOR_TO
78383: IFFALSE 78918
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78385: LD_ADDR_VAR 0 11
78389: PUSH
78390: LD_VAR 0 12
78394: PUSH
78395: LD_VAR 0 7
78399: ARRAY
78400: PUSH
78401: LD_INT 1
78403: ARRAY
78404: PPUSH
78405: LD_VAR 0 12
78409: PUSH
78410: LD_VAR 0 7
78414: ARRAY
78415: PUSH
78416: LD_INT 2
78418: ARRAY
78419: PPUSH
78420: CALL_OW 428
78424: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78425: LD_VAR 0 12
78429: PUSH
78430: LD_VAR 0 7
78434: ARRAY
78435: PUSH
78436: LD_INT 1
78438: ARRAY
78439: PPUSH
78440: LD_VAR 0 12
78444: PUSH
78445: LD_VAR 0 7
78449: ARRAY
78450: PUSH
78451: LD_INT 2
78453: ARRAY
78454: PPUSH
78455: CALL_OW 351
78459: PUSH
78460: LD_VAR 0 12
78464: PUSH
78465: LD_VAR 0 7
78469: ARRAY
78470: PUSH
78471: LD_INT 1
78473: ARRAY
78474: PPUSH
78475: LD_VAR 0 12
78479: PUSH
78480: LD_VAR 0 7
78484: ARRAY
78485: PUSH
78486: LD_INT 2
78488: ARRAY
78489: PPUSH
78490: CALL_OW 488
78494: NOT
78495: OR
78496: PUSH
78497: LD_VAR 0 11
78501: PPUSH
78502: CALL_OW 247
78506: PUSH
78507: LD_INT 3
78509: EQUAL
78510: OR
78511: IFFALSE 78517
// exit ;
78513: POP
78514: POP
78515: GO 78920
// if not tmp or not tmp in base then
78517: LD_VAR 0 11
78521: NOT
78522: PUSH
78523: LD_VAR 0 11
78527: PUSH
78528: LD_VAR 0 1
78532: IN
78533: NOT
78534: OR
78535: IFFALSE 78539
// continue ;
78537: GO 78382
// result := true ;
78539: LD_ADDR_VAR 0 6
78543: PUSH
78544: LD_INT 1
78546: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78547: LD_ADDR_VAR 0 15
78551: PUSH
78552: LD_VAR 0 1
78556: PPUSH
78557: LD_INT 22
78559: PUSH
78560: LD_VAR 0 11
78564: PPUSH
78565: CALL_OW 255
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 2
78576: PUSH
78577: LD_INT 30
78579: PUSH
78580: LD_INT 0
78582: PUSH
78583: EMPTY
78584: LIST
78585: LIST
78586: PUSH
78587: LD_INT 30
78589: PUSH
78590: LD_INT 1
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: LIST
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PPUSH
78606: CALL_OW 72
78610: ST_TO_ADDR
// if dep then
78611: LD_VAR 0 15
78615: IFFALSE 78751
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78617: LD_ADDR_VAR 0 14
78621: PUSH
78622: LD_VAR 0 15
78626: PUSH
78627: LD_INT 1
78629: ARRAY
78630: PPUSH
78631: CALL_OW 250
78635: PPUSH
78636: LD_VAR 0 15
78640: PUSH
78641: LD_INT 1
78643: ARRAY
78644: PPUSH
78645: CALL_OW 254
78649: PPUSH
78650: LD_INT 5
78652: PPUSH
78653: CALL_OW 272
78657: PUSH
78658: LD_VAR 0 15
78662: PUSH
78663: LD_INT 1
78665: ARRAY
78666: PPUSH
78667: CALL_OW 251
78671: PPUSH
78672: LD_VAR 0 15
78676: PUSH
78677: LD_INT 1
78679: ARRAY
78680: PPUSH
78681: CALL_OW 254
78685: PPUSH
78686: LD_INT 5
78688: PPUSH
78689: CALL_OW 273
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78698: LD_VAR 0 14
78702: PUSH
78703: LD_INT 1
78705: ARRAY
78706: PPUSH
78707: LD_VAR 0 14
78711: PUSH
78712: LD_INT 2
78714: ARRAY
78715: PPUSH
78716: CALL_OW 488
78720: IFFALSE 78751
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78722: LD_VAR 0 11
78726: PPUSH
78727: LD_VAR 0 14
78731: PUSH
78732: LD_INT 1
78734: ARRAY
78735: PPUSH
78736: LD_VAR 0 14
78740: PUSH
78741: LD_INT 2
78743: ARRAY
78744: PPUSH
78745: CALL_OW 111
// continue ;
78749: GO 78382
// end ; end ; r := GetDir ( tmp ) ;
78751: LD_ADDR_VAR 0 13
78755: PUSH
78756: LD_VAR 0 11
78760: PPUSH
78761: CALL_OW 254
78765: ST_TO_ADDR
// if r = 5 then
78766: LD_VAR 0 13
78770: PUSH
78771: LD_INT 5
78773: EQUAL
78774: IFFALSE 78784
// r := 0 ;
78776: LD_ADDR_VAR 0 13
78780: PUSH
78781: LD_INT 0
78783: ST_TO_ADDR
// for j = r to 5 do
78784: LD_ADDR_VAR 0 8
78788: PUSH
78789: DOUBLE
78790: LD_VAR 0 13
78794: DEC
78795: ST_TO_ADDR
78796: LD_INT 5
78798: PUSH
78799: FOR_TO
78800: IFFALSE 78914
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78802: LD_ADDR_VAR 0 9
78806: PUSH
78807: LD_VAR 0 11
78811: PPUSH
78812: CALL_OW 250
78816: PPUSH
78817: LD_VAR 0 8
78821: PPUSH
78822: LD_INT 2
78824: PPUSH
78825: CALL_OW 272
78829: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78830: LD_ADDR_VAR 0 10
78834: PUSH
78835: LD_VAR 0 11
78839: PPUSH
78840: CALL_OW 251
78844: PPUSH
78845: LD_VAR 0 8
78849: PPUSH
78850: LD_INT 2
78852: PPUSH
78853: CALL_OW 273
78857: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78858: LD_VAR 0 9
78862: PPUSH
78863: LD_VAR 0 10
78867: PPUSH
78868: CALL_OW 488
78872: PUSH
78873: LD_VAR 0 9
78877: PPUSH
78878: LD_VAR 0 10
78882: PPUSH
78883: CALL_OW 428
78887: NOT
78888: AND
78889: IFFALSE 78912
// begin ComMoveXY ( tmp , _x , _y ) ;
78891: LD_VAR 0 11
78895: PPUSH
78896: LD_VAR 0 9
78900: PPUSH
78901: LD_VAR 0 10
78905: PPUSH
78906: CALL_OW 111
// break ;
78910: GO 78914
// end ; end ;
78912: GO 78799
78914: POP
78915: POP
// end ;
78916: GO 78382
78918: POP
78919: POP
// end ;
78920: LD_VAR 0 6
78924: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78925: LD_INT 0
78927: PPUSH
78928: PPUSH
78929: PPUSH
78930: PPUSH
78931: PPUSH
78932: PPUSH
78933: PPUSH
78934: PPUSH
78935: PPUSH
78936: PPUSH
// result := false ;
78937: LD_ADDR_VAR 0 6
78941: PUSH
78942: LD_INT 0
78944: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78945: LD_VAR 0 1
78949: NOT
78950: PUSH
78951: LD_VAR 0 1
78955: PPUSH
78956: CALL_OW 266
78960: PUSH
78961: LD_INT 0
78963: PUSH
78964: LD_INT 1
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: IN
78971: NOT
78972: OR
78973: PUSH
78974: LD_VAR 0 2
78978: NOT
78979: OR
78980: PUSH
78981: LD_VAR 0 5
78985: PUSH
78986: LD_INT 0
78988: PUSH
78989: LD_INT 1
78991: PUSH
78992: LD_INT 2
78994: PUSH
78995: LD_INT 3
78997: PUSH
78998: LD_INT 4
79000: PUSH
79001: LD_INT 5
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: IN
79012: NOT
79013: OR
79014: PUSH
79015: LD_VAR 0 3
79019: PPUSH
79020: LD_VAR 0 4
79024: PPUSH
79025: CALL_OW 488
79029: NOT
79030: OR
79031: IFFALSE 79035
// exit ;
79033: GO 79752
// pom := GetBase ( depot ) ;
79035: LD_ADDR_VAR 0 10
79039: PUSH
79040: LD_VAR 0 1
79044: PPUSH
79045: CALL_OW 274
79049: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79050: LD_ADDR_VAR 0 11
79054: PUSH
79055: LD_VAR 0 2
79059: PPUSH
79060: LD_VAR 0 1
79064: PPUSH
79065: CALL_OW 248
79069: PPUSH
79070: CALL_OW 450
79074: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79075: LD_VAR 0 10
79079: PPUSH
79080: LD_INT 1
79082: PPUSH
79083: CALL_OW 275
79087: PUSH
79088: LD_VAR 0 11
79092: PUSH
79093: LD_INT 1
79095: ARRAY
79096: GREATEREQUAL
79097: PUSH
79098: LD_VAR 0 10
79102: PPUSH
79103: LD_INT 2
79105: PPUSH
79106: CALL_OW 275
79110: PUSH
79111: LD_VAR 0 11
79115: PUSH
79116: LD_INT 2
79118: ARRAY
79119: GREATEREQUAL
79120: AND
79121: PUSH
79122: LD_VAR 0 10
79126: PPUSH
79127: LD_INT 3
79129: PPUSH
79130: CALL_OW 275
79134: PUSH
79135: LD_VAR 0 11
79139: PUSH
79140: LD_INT 3
79142: ARRAY
79143: GREATEREQUAL
79144: AND
79145: NOT
79146: IFFALSE 79150
// exit ;
79148: GO 79752
// if GetBType ( depot ) = b_depot then
79150: LD_VAR 0 1
79154: PPUSH
79155: CALL_OW 266
79159: PUSH
79160: LD_INT 0
79162: EQUAL
79163: IFFALSE 79175
// dist := 28 else
79165: LD_ADDR_VAR 0 14
79169: PUSH
79170: LD_INT 28
79172: ST_TO_ADDR
79173: GO 79183
// dist := 36 ;
79175: LD_ADDR_VAR 0 14
79179: PUSH
79180: LD_INT 36
79182: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79183: LD_VAR 0 1
79187: PPUSH
79188: LD_VAR 0 3
79192: PPUSH
79193: LD_VAR 0 4
79197: PPUSH
79198: CALL_OW 297
79202: PUSH
79203: LD_VAR 0 14
79207: GREATER
79208: IFFALSE 79212
// exit ;
79210: GO 79752
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79212: LD_ADDR_VAR 0 12
79216: PUSH
79217: LD_VAR 0 2
79221: PPUSH
79222: LD_VAR 0 3
79226: PPUSH
79227: LD_VAR 0 4
79231: PPUSH
79232: LD_VAR 0 5
79236: PPUSH
79237: LD_VAR 0 1
79241: PPUSH
79242: CALL_OW 248
79246: PPUSH
79247: LD_INT 0
79249: PPUSH
79250: CALL 79757 0 6
79254: ST_TO_ADDR
// if not hexes then
79255: LD_VAR 0 12
79259: NOT
79260: IFFALSE 79264
// exit ;
79262: GO 79752
// hex := GetHexInfo ( x , y ) ;
79264: LD_ADDR_VAR 0 15
79268: PUSH
79269: LD_VAR 0 3
79273: PPUSH
79274: LD_VAR 0 4
79278: PPUSH
79279: CALL_OW 546
79283: ST_TO_ADDR
// if hex [ 1 ] then
79284: LD_VAR 0 15
79288: PUSH
79289: LD_INT 1
79291: ARRAY
79292: IFFALSE 79296
// exit ;
79294: GO 79752
// height := hex [ 2 ] ;
79296: LD_ADDR_VAR 0 13
79300: PUSH
79301: LD_VAR 0 15
79305: PUSH
79306: LD_INT 2
79308: ARRAY
79309: ST_TO_ADDR
// for i = 1 to hexes do
79310: LD_ADDR_VAR 0 7
79314: PUSH
79315: DOUBLE
79316: LD_INT 1
79318: DEC
79319: ST_TO_ADDR
79320: LD_VAR 0 12
79324: PUSH
79325: FOR_TO
79326: IFFALSE 79656
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79328: LD_VAR 0 12
79332: PUSH
79333: LD_VAR 0 7
79337: ARRAY
79338: PUSH
79339: LD_INT 1
79341: ARRAY
79342: PPUSH
79343: LD_VAR 0 12
79347: PUSH
79348: LD_VAR 0 7
79352: ARRAY
79353: PUSH
79354: LD_INT 2
79356: ARRAY
79357: PPUSH
79358: CALL_OW 488
79362: NOT
79363: PUSH
79364: LD_VAR 0 12
79368: PUSH
79369: LD_VAR 0 7
79373: ARRAY
79374: PUSH
79375: LD_INT 1
79377: ARRAY
79378: PPUSH
79379: LD_VAR 0 12
79383: PUSH
79384: LD_VAR 0 7
79388: ARRAY
79389: PUSH
79390: LD_INT 2
79392: ARRAY
79393: PPUSH
79394: CALL_OW 428
79398: PUSH
79399: LD_INT 0
79401: GREATER
79402: OR
79403: PUSH
79404: LD_VAR 0 12
79408: PUSH
79409: LD_VAR 0 7
79413: ARRAY
79414: PUSH
79415: LD_INT 1
79417: ARRAY
79418: PPUSH
79419: LD_VAR 0 12
79423: PUSH
79424: LD_VAR 0 7
79428: ARRAY
79429: PUSH
79430: LD_INT 2
79432: ARRAY
79433: PPUSH
79434: CALL_OW 351
79438: OR
79439: IFFALSE 79445
// exit ;
79441: POP
79442: POP
79443: GO 79752
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79445: LD_ADDR_VAR 0 8
79449: PUSH
79450: LD_VAR 0 12
79454: PUSH
79455: LD_VAR 0 7
79459: ARRAY
79460: PUSH
79461: LD_INT 1
79463: ARRAY
79464: PPUSH
79465: LD_VAR 0 12
79469: PUSH
79470: LD_VAR 0 7
79474: ARRAY
79475: PUSH
79476: LD_INT 2
79478: ARRAY
79479: PPUSH
79480: CALL_OW 546
79484: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79485: LD_VAR 0 8
79489: PUSH
79490: LD_INT 1
79492: ARRAY
79493: PUSH
79494: LD_VAR 0 8
79498: PUSH
79499: LD_INT 2
79501: ARRAY
79502: PUSH
79503: LD_VAR 0 13
79507: PUSH
79508: LD_INT 2
79510: PLUS
79511: GREATER
79512: OR
79513: PUSH
79514: LD_VAR 0 8
79518: PUSH
79519: LD_INT 2
79521: ARRAY
79522: PUSH
79523: LD_VAR 0 13
79527: PUSH
79528: LD_INT 2
79530: MINUS
79531: LESS
79532: OR
79533: PUSH
79534: LD_VAR 0 8
79538: PUSH
79539: LD_INT 3
79541: ARRAY
79542: PUSH
79543: LD_INT 0
79545: PUSH
79546: LD_INT 8
79548: PUSH
79549: LD_INT 9
79551: PUSH
79552: LD_INT 10
79554: PUSH
79555: LD_INT 11
79557: PUSH
79558: LD_INT 12
79560: PUSH
79561: LD_INT 13
79563: PUSH
79564: LD_INT 16
79566: PUSH
79567: LD_INT 17
79569: PUSH
79570: LD_INT 18
79572: PUSH
79573: LD_INT 19
79575: PUSH
79576: LD_INT 20
79578: PUSH
79579: LD_INT 21
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: LIST
79586: LIST
79587: LIST
79588: LIST
79589: LIST
79590: LIST
79591: LIST
79592: LIST
79593: LIST
79594: LIST
79595: LIST
79596: IN
79597: NOT
79598: OR
79599: PUSH
79600: LD_VAR 0 8
79604: PUSH
79605: LD_INT 5
79607: ARRAY
79608: NOT
79609: OR
79610: PUSH
79611: LD_VAR 0 8
79615: PUSH
79616: LD_INT 6
79618: ARRAY
79619: PUSH
79620: LD_INT 1
79622: PUSH
79623: LD_INT 2
79625: PUSH
79626: LD_INT 7
79628: PUSH
79629: LD_INT 9
79631: PUSH
79632: LD_INT 10
79634: PUSH
79635: LD_INT 11
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: IN
79646: NOT
79647: OR
79648: IFFALSE 79654
// exit ;
79650: POP
79651: POP
79652: GO 79752
// end ;
79654: GO 79325
79656: POP
79657: POP
// side := GetSide ( depot ) ;
79658: LD_ADDR_VAR 0 9
79662: PUSH
79663: LD_VAR 0 1
79667: PPUSH
79668: CALL_OW 255
79672: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79673: LD_VAR 0 9
79677: PPUSH
79678: LD_VAR 0 3
79682: PPUSH
79683: LD_VAR 0 4
79687: PPUSH
79688: LD_INT 20
79690: PPUSH
79691: CALL 72406 0 4
79695: PUSH
79696: LD_INT 4
79698: ARRAY
79699: IFFALSE 79703
// exit ;
79701: GO 79752
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79703: LD_VAR 0 2
79707: PUSH
79708: LD_INT 29
79710: PUSH
79711: LD_INT 30
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: IN
79718: PUSH
79719: LD_VAR 0 3
79723: PPUSH
79724: LD_VAR 0 4
79728: PPUSH
79729: LD_VAR 0 9
79733: PPUSH
79734: CALL_OW 440
79738: NOT
79739: AND
79740: IFFALSE 79744
// exit ;
79742: GO 79752
// result := true ;
79744: LD_ADDR_VAR 0 6
79748: PUSH
79749: LD_INT 1
79751: ST_TO_ADDR
// end ;
79752: LD_VAR 0 6
79756: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79757: LD_INT 0
79759: PPUSH
79760: PPUSH
79761: PPUSH
79762: PPUSH
79763: PPUSH
79764: PPUSH
79765: PPUSH
79766: PPUSH
79767: PPUSH
79768: PPUSH
79769: PPUSH
79770: PPUSH
79771: PPUSH
79772: PPUSH
79773: PPUSH
79774: PPUSH
79775: PPUSH
79776: PPUSH
79777: PPUSH
79778: PPUSH
79779: PPUSH
79780: PPUSH
79781: PPUSH
79782: PPUSH
79783: PPUSH
79784: PPUSH
79785: PPUSH
79786: PPUSH
79787: PPUSH
79788: PPUSH
79789: PPUSH
79790: PPUSH
79791: PPUSH
79792: PPUSH
79793: PPUSH
79794: PPUSH
79795: PPUSH
79796: PPUSH
79797: PPUSH
79798: PPUSH
79799: PPUSH
79800: PPUSH
79801: PPUSH
79802: PPUSH
79803: PPUSH
79804: PPUSH
79805: PPUSH
79806: PPUSH
79807: PPUSH
79808: PPUSH
79809: PPUSH
79810: PPUSH
79811: PPUSH
79812: PPUSH
79813: PPUSH
79814: PPUSH
79815: PPUSH
79816: PPUSH
// result = [ ] ;
79817: LD_ADDR_VAR 0 7
79821: PUSH
79822: EMPTY
79823: ST_TO_ADDR
// temp_list = [ ] ;
79824: LD_ADDR_VAR 0 9
79828: PUSH
79829: EMPTY
79830: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79831: LD_VAR 0 4
79835: PUSH
79836: LD_INT 0
79838: PUSH
79839: LD_INT 1
79841: PUSH
79842: LD_INT 2
79844: PUSH
79845: LD_INT 3
79847: PUSH
79848: LD_INT 4
79850: PUSH
79851: LD_INT 5
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: IN
79862: NOT
79863: PUSH
79864: LD_VAR 0 1
79868: PUSH
79869: LD_INT 0
79871: PUSH
79872: LD_INT 1
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: IN
79879: PUSH
79880: LD_VAR 0 5
79884: PUSH
79885: LD_INT 1
79887: PUSH
79888: LD_INT 2
79890: PUSH
79891: LD_INT 3
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: LIST
79898: IN
79899: NOT
79900: AND
79901: OR
79902: IFFALSE 79906
// exit ;
79904: GO 98297
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79906: LD_VAR 0 1
79910: PUSH
79911: LD_INT 6
79913: PUSH
79914: LD_INT 7
79916: PUSH
79917: LD_INT 8
79919: PUSH
79920: LD_INT 13
79922: PUSH
79923: LD_INT 12
79925: PUSH
79926: LD_INT 15
79928: PUSH
79929: LD_INT 11
79931: PUSH
79932: LD_INT 14
79934: PUSH
79935: LD_INT 10
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: IN
79949: IFFALSE 79959
// btype = b_lab ;
79951: LD_ADDR_VAR 0 1
79955: PUSH
79956: LD_INT 6
79958: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79959: LD_VAR 0 6
79963: PUSH
79964: LD_INT 0
79966: PUSH
79967: LD_INT 1
79969: PUSH
79970: LD_INT 2
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: LIST
79977: IN
79978: NOT
79979: PUSH
79980: LD_VAR 0 1
79984: PUSH
79985: LD_INT 0
79987: PUSH
79988: LD_INT 1
79990: PUSH
79991: LD_INT 2
79993: PUSH
79994: LD_INT 3
79996: PUSH
79997: LD_INT 6
79999: PUSH
80000: LD_INT 36
80002: PUSH
80003: LD_INT 4
80005: PUSH
80006: LD_INT 5
80008: PUSH
80009: LD_INT 31
80011: PUSH
80012: LD_INT 32
80014: PUSH
80015: LD_INT 33
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: LIST
80025: LIST
80026: LIST
80027: LIST
80028: LIST
80029: LIST
80030: IN
80031: NOT
80032: PUSH
80033: LD_VAR 0 6
80037: PUSH
80038: LD_INT 1
80040: EQUAL
80041: AND
80042: OR
80043: PUSH
80044: LD_VAR 0 1
80048: PUSH
80049: LD_INT 2
80051: PUSH
80052: LD_INT 3
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: IN
80059: NOT
80060: PUSH
80061: LD_VAR 0 6
80065: PUSH
80066: LD_INT 2
80068: EQUAL
80069: AND
80070: OR
80071: IFFALSE 80081
// mode = 0 ;
80073: LD_ADDR_VAR 0 6
80077: PUSH
80078: LD_INT 0
80080: ST_TO_ADDR
// case mode of 0 :
80081: LD_VAR 0 6
80085: PUSH
80086: LD_INT 0
80088: DOUBLE
80089: EQUAL
80090: IFTRUE 80094
80092: GO 91547
80094: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80095: LD_ADDR_VAR 0 11
80099: PUSH
80100: LD_INT 0
80102: PUSH
80103: LD_INT 0
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PUSH
80110: LD_INT 0
80112: PUSH
80113: LD_INT 1
80115: NEG
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 1
80123: PUSH
80124: LD_INT 0
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 1
80133: PUSH
80134: LD_INT 1
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: LD_INT 0
80143: PUSH
80144: LD_INT 1
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: PUSH
80151: LD_INT 1
80153: NEG
80154: PUSH
80155: LD_INT 0
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: LD_INT 1
80164: NEG
80165: PUSH
80166: LD_INT 1
80168: NEG
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 1
80176: NEG
80177: PUSH
80178: LD_INT 2
80180: NEG
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 0
80188: PUSH
80189: LD_INT 2
80191: NEG
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 1
80199: PUSH
80200: LD_INT 1
80202: NEG
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 1
80210: PUSH
80211: LD_INT 2
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: PUSH
80218: LD_INT 0
80220: PUSH
80221: LD_INT 2
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 1
80230: NEG
80231: PUSH
80232: LD_INT 1
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 1
80241: PUSH
80242: LD_INT 3
80244: PUSH
80245: EMPTY
80246: LIST
80247: LIST
80248: PUSH
80249: LD_INT 0
80251: PUSH
80252: LD_INT 3
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 1
80261: NEG
80262: PUSH
80263: LD_INT 2
80265: PUSH
80266: EMPTY
80267: LIST
80268: LIST
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: LIST
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80288: LD_ADDR_VAR 0 12
80292: PUSH
80293: LD_INT 0
80295: PUSH
80296: LD_INT 0
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 0
80305: PUSH
80306: LD_INT 1
80308: NEG
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 1
80316: PUSH
80317: LD_INT 0
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 1
80326: PUSH
80327: LD_INT 1
80329: PUSH
80330: EMPTY
80331: LIST
80332: LIST
80333: PUSH
80334: LD_INT 0
80336: PUSH
80337: LD_INT 1
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: LD_INT 1
80346: NEG
80347: PUSH
80348: LD_INT 0
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 1
80357: NEG
80358: PUSH
80359: LD_INT 1
80361: NEG
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 1
80369: PUSH
80370: LD_INT 1
80372: NEG
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 2
80380: PUSH
80381: LD_INT 0
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: PUSH
80388: LD_INT 2
80390: PUSH
80391: LD_INT 1
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 1
80400: NEG
80401: PUSH
80402: LD_INT 1
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: PUSH
80409: LD_INT 2
80411: NEG
80412: PUSH
80413: LD_INT 0
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 2
80422: NEG
80423: PUSH
80424: LD_INT 1
80426: NEG
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 2
80434: NEG
80435: PUSH
80436: LD_INT 1
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 3
80445: NEG
80446: PUSH
80447: LD_INT 0
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: PUSH
80454: LD_INT 3
80456: NEG
80457: PUSH
80458: LD_INT 1
80460: NEG
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: LIST
80473: LIST
80474: LIST
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: LIST
80483: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80484: LD_ADDR_VAR 0 13
80488: PUSH
80489: LD_INT 0
80491: PUSH
80492: LD_INT 0
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: LD_INT 0
80501: PUSH
80502: LD_INT 1
80504: NEG
80505: PUSH
80506: EMPTY
80507: LIST
80508: LIST
80509: PUSH
80510: LD_INT 1
80512: PUSH
80513: LD_INT 0
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 1
80522: PUSH
80523: LD_INT 1
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 0
80532: PUSH
80533: LD_INT 1
80535: PUSH
80536: EMPTY
80537: LIST
80538: LIST
80539: PUSH
80540: LD_INT 1
80542: NEG
80543: PUSH
80544: LD_INT 0
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: LD_INT 1
80553: NEG
80554: PUSH
80555: LD_INT 1
80557: NEG
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: PUSH
80563: LD_INT 1
80565: NEG
80566: PUSH
80567: LD_INT 2
80569: NEG
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: PUSH
80575: LD_INT 2
80577: PUSH
80578: LD_INT 1
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 2
80587: PUSH
80588: LD_INT 2
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: LD_INT 1
80597: PUSH
80598: LD_INT 2
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 2
80607: NEG
80608: PUSH
80609: LD_INT 1
80611: NEG
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 2
80619: NEG
80620: PUSH
80621: LD_INT 2
80623: NEG
80624: PUSH
80625: EMPTY
80626: LIST
80627: LIST
80628: PUSH
80629: LD_INT 2
80631: NEG
80632: PUSH
80633: LD_INT 3
80635: NEG
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 3
80643: NEG
80644: PUSH
80645: LD_INT 2
80647: NEG
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PUSH
80653: LD_INT 3
80655: NEG
80656: PUSH
80657: LD_INT 3
80659: NEG
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: LIST
80669: LIST
80670: LIST
80671: LIST
80672: LIST
80673: LIST
80674: LIST
80675: LIST
80676: LIST
80677: LIST
80678: LIST
80679: LIST
80680: LIST
80681: LIST
80682: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80683: LD_ADDR_VAR 0 14
80687: PUSH
80688: LD_INT 0
80690: PUSH
80691: LD_INT 0
80693: PUSH
80694: EMPTY
80695: LIST
80696: LIST
80697: PUSH
80698: LD_INT 0
80700: PUSH
80701: LD_INT 1
80703: NEG
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PUSH
80709: LD_INT 1
80711: PUSH
80712: LD_INT 0
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: PUSH
80719: LD_INT 1
80721: PUSH
80722: LD_INT 1
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 0
80731: PUSH
80732: LD_INT 1
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 1
80741: NEG
80742: PUSH
80743: LD_INT 0
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 1
80752: NEG
80753: PUSH
80754: LD_INT 1
80756: NEG
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 1
80764: NEG
80765: PUSH
80766: LD_INT 2
80768: NEG
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 0
80776: PUSH
80777: LD_INT 2
80779: NEG
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 1
80787: PUSH
80788: LD_INT 1
80790: NEG
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 1
80798: PUSH
80799: LD_INT 2
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 2
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 1
80818: NEG
80819: PUSH
80820: LD_INT 1
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: LD_INT 3
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: LD_INT 3
80844: NEG
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 1
80852: PUSH
80853: LD_INT 2
80855: NEG
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: LIST
80865: LIST
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: LIST
80871: LIST
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: LIST
80877: LIST
80878: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80879: LD_ADDR_VAR 0 15
80883: PUSH
80884: LD_INT 0
80886: PUSH
80887: LD_INT 0
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 0
80896: PUSH
80897: LD_INT 1
80899: NEG
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 1
80907: PUSH
80908: LD_INT 0
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 1
80917: PUSH
80918: LD_INT 1
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 0
80927: PUSH
80928: LD_INT 1
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 1
80937: NEG
80938: PUSH
80939: LD_INT 0
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 1
80948: NEG
80949: PUSH
80950: LD_INT 1
80952: NEG
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 1
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 2
80971: PUSH
80972: LD_INT 0
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 2
80981: PUSH
80982: LD_INT 1
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 1
80991: NEG
80992: PUSH
80993: LD_INT 1
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 2
81002: NEG
81003: PUSH
81004: LD_INT 0
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 2
81013: NEG
81014: PUSH
81015: LD_INT 1
81017: NEG
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 2
81025: PUSH
81026: LD_INT 1
81028: NEG
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: LD_INT 3
81036: PUSH
81037: LD_INT 0
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: LD_INT 3
81046: PUSH
81047: LD_INT 1
81049: PUSH
81050: EMPTY
81051: LIST
81052: LIST
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81072: LD_ADDR_VAR 0 16
81076: PUSH
81077: LD_INT 0
81079: PUSH
81080: LD_INT 0
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 0
81089: PUSH
81090: LD_INT 1
81092: NEG
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 1
81100: PUSH
81101: LD_INT 0
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: PUSH
81108: LD_INT 1
81110: PUSH
81111: LD_INT 1
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PUSH
81118: LD_INT 0
81120: PUSH
81121: LD_INT 1
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: LD_INT 1
81130: NEG
81131: PUSH
81132: LD_INT 0
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 1
81141: NEG
81142: PUSH
81143: LD_INT 1
81145: NEG
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 1
81153: NEG
81154: PUSH
81155: LD_INT 2
81157: NEG
81158: PUSH
81159: EMPTY
81160: LIST
81161: LIST
81162: PUSH
81163: LD_INT 2
81165: PUSH
81166: LD_INT 1
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 2
81175: PUSH
81176: LD_INT 2
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 1
81185: PUSH
81186: LD_INT 2
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: PUSH
81193: LD_INT 2
81195: NEG
81196: PUSH
81197: LD_INT 1
81199: NEG
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 2
81207: NEG
81208: PUSH
81209: LD_INT 2
81211: NEG
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 3
81219: PUSH
81220: LD_INT 2
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 3
81229: PUSH
81230: LD_INT 3
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 2
81239: PUSH
81240: LD_INT 3
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81265: LD_ADDR_VAR 0 17
81269: PUSH
81270: LD_INT 0
81272: PUSH
81273: LD_INT 0
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 0
81282: PUSH
81283: LD_INT 1
81285: NEG
81286: PUSH
81287: EMPTY
81288: LIST
81289: LIST
81290: PUSH
81291: LD_INT 1
81293: PUSH
81294: LD_INT 0
81296: PUSH
81297: EMPTY
81298: LIST
81299: LIST
81300: PUSH
81301: LD_INT 1
81303: PUSH
81304: LD_INT 1
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_INT 0
81313: PUSH
81314: LD_INT 1
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 1
81323: NEG
81324: PUSH
81325: LD_INT 0
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: PUSH
81332: LD_INT 1
81334: NEG
81335: PUSH
81336: LD_INT 1
81338: NEG
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 1
81346: NEG
81347: PUSH
81348: LD_INT 2
81350: NEG
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 0
81358: PUSH
81359: LD_INT 2
81361: NEG
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 1
81369: PUSH
81370: LD_INT 1
81372: NEG
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 2
81380: PUSH
81381: LD_INT 0
81383: PUSH
81384: EMPTY
81385: LIST
81386: LIST
81387: PUSH
81388: LD_INT 2
81390: PUSH
81391: LD_INT 1
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PUSH
81398: LD_INT 2
81400: PUSH
81401: LD_INT 2
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 1
81410: PUSH
81411: LD_INT 2
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 0
81420: PUSH
81421: LD_INT 2
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 1
81430: NEG
81431: PUSH
81432: LD_INT 1
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 2
81441: NEG
81442: PUSH
81443: LD_INT 0
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 2
81452: NEG
81453: PUSH
81454: LD_INT 1
81456: NEG
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 2
81464: NEG
81465: PUSH
81466: LD_INT 2
81468: NEG
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: LIST
81494: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81495: LD_ADDR_VAR 0 18
81499: PUSH
81500: LD_INT 0
81502: PUSH
81503: LD_INT 0
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: LD_INT 0
81512: PUSH
81513: LD_INT 1
81515: NEG
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 1
81523: PUSH
81524: LD_INT 0
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 1
81533: PUSH
81534: LD_INT 1
81536: PUSH
81537: EMPTY
81538: LIST
81539: LIST
81540: PUSH
81541: LD_INT 0
81543: PUSH
81544: LD_INT 1
81546: PUSH
81547: EMPTY
81548: LIST
81549: LIST
81550: PUSH
81551: LD_INT 1
81553: NEG
81554: PUSH
81555: LD_INT 0
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 1
81564: NEG
81565: PUSH
81566: LD_INT 1
81568: NEG
81569: PUSH
81570: EMPTY
81571: LIST
81572: LIST
81573: PUSH
81574: LD_INT 1
81576: NEG
81577: PUSH
81578: LD_INT 2
81580: NEG
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 0
81588: PUSH
81589: LD_INT 2
81591: NEG
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: PUSH
81597: LD_INT 1
81599: PUSH
81600: LD_INT 1
81602: NEG
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 2
81610: PUSH
81611: LD_INT 0
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 2
81620: PUSH
81621: LD_INT 1
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 2
81630: PUSH
81631: LD_INT 2
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 1
81640: PUSH
81641: LD_INT 2
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 0
81650: PUSH
81651: LD_INT 2
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 1
81660: NEG
81661: PUSH
81662: LD_INT 1
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 2
81671: NEG
81672: PUSH
81673: LD_INT 0
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PUSH
81680: LD_INT 2
81682: NEG
81683: PUSH
81684: LD_INT 1
81686: NEG
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 2
81694: NEG
81695: PUSH
81696: LD_INT 2
81698: NEG
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81725: LD_ADDR_VAR 0 19
81729: PUSH
81730: LD_INT 0
81732: PUSH
81733: LD_INT 0
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 0
81742: PUSH
81743: LD_INT 1
81745: NEG
81746: PUSH
81747: EMPTY
81748: LIST
81749: LIST
81750: PUSH
81751: LD_INT 1
81753: PUSH
81754: LD_INT 0
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 1
81763: PUSH
81764: LD_INT 1
81766: PUSH
81767: EMPTY
81768: LIST
81769: LIST
81770: PUSH
81771: LD_INT 0
81773: PUSH
81774: LD_INT 1
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 1
81783: NEG
81784: PUSH
81785: LD_INT 0
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: PUSH
81792: LD_INT 1
81794: NEG
81795: PUSH
81796: LD_INT 1
81798: NEG
81799: PUSH
81800: EMPTY
81801: LIST
81802: LIST
81803: PUSH
81804: LD_INT 1
81806: NEG
81807: PUSH
81808: LD_INT 2
81810: NEG
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 0
81818: PUSH
81819: LD_INT 2
81821: NEG
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 1
81829: PUSH
81830: LD_INT 1
81832: NEG
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 2
81840: PUSH
81841: LD_INT 0
81843: PUSH
81844: EMPTY
81845: LIST
81846: LIST
81847: PUSH
81848: LD_INT 2
81850: PUSH
81851: LD_INT 1
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 2
81860: PUSH
81861: LD_INT 2
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 1
81870: PUSH
81871: LD_INT 2
81873: PUSH
81874: EMPTY
81875: LIST
81876: LIST
81877: PUSH
81878: LD_INT 0
81880: PUSH
81881: LD_INT 2
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_INT 1
81890: NEG
81891: PUSH
81892: LD_INT 1
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 2
81901: NEG
81902: PUSH
81903: LD_INT 0
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 2
81912: NEG
81913: PUSH
81914: LD_INT 1
81916: NEG
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 2
81924: NEG
81925: PUSH
81926: LD_INT 2
81928: NEG
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: LIST
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81955: LD_ADDR_VAR 0 20
81959: PUSH
81960: LD_INT 0
81962: PUSH
81963: LD_INT 0
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 0
81972: PUSH
81973: LD_INT 1
81975: NEG
81976: PUSH
81977: EMPTY
81978: LIST
81979: LIST
81980: PUSH
81981: LD_INT 1
81983: PUSH
81984: LD_INT 0
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 1
81993: PUSH
81994: LD_INT 1
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 0
82003: PUSH
82004: LD_INT 1
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 1
82013: NEG
82014: PUSH
82015: LD_INT 0
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 1
82024: NEG
82025: PUSH
82026: LD_INT 1
82028: NEG
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: PUSH
82034: LD_INT 1
82036: NEG
82037: PUSH
82038: LD_INT 2
82040: NEG
82041: PUSH
82042: EMPTY
82043: LIST
82044: LIST
82045: PUSH
82046: LD_INT 0
82048: PUSH
82049: LD_INT 2
82051: NEG
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: PUSH
82057: LD_INT 1
82059: PUSH
82060: LD_INT 1
82062: NEG
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: LD_INT 2
82070: PUSH
82071: LD_INT 0
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 2
82080: PUSH
82081: LD_INT 1
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 2
82090: PUSH
82091: LD_INT 2
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 1
82100: PUSH
82101: LD_INT 2
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 0
82110: PUSH
82111: LD_INT 2
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 1
82120: NEG
82121: PUSH
82122: LD_INT 1
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 2
82131: NEG
82132: PUSH
82133: LD_INT 0
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 2
82142: NEG
82143: PUSH
82144: LD_INT 1
82146: NEG
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: LD_INT 2
82154: NEG
82155: PUSH
82156: LD_INT 2
82158: NEG
82159: PUSH
82160: EMPTY
82161: LIST
82162: LIST
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82185: LD_ADDR_VAR 0 21
82189: PUSH
82190: LD_INT 0
82192: PUSH
82193: LD_INT 0
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 0
82202: PUSH
82203: LD_INT 1
82205: NEG
82206: PUSH
82207: EMPTY
82208: LIST
82209: LIST
82210: PUSH
82211: LD_INT 1
82213: PUSH
82214: LD_INT 0
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 1
82223: PUSH
82224: LD_INT 1
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: PUSH
82231: LD_INT 0
82233: PUSH
82234: LD_INT 1
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 1
82243: NEG
82244: PUSH
82245: LD_INT 0
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 1
82254: NEG
82255: PUSH
82256: LD_INT 1
82258: NEG
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PUSH
82264: LD_INT 1
82266: NEG
82267: PUSH
82268: LD_INT 2
82270: NEG
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PUSH
82276: LD_INT 0
82278: PUSH
82279: LD_INT 2
82281: NEG
82282: PUSH
82283: EMPTY
82284: LIST
82285: LIST
82286: PUSH
82287: LD_INT 1
82289: PUSH
82290: LD_INT 1
82292: NEG
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 2
82300: PUSH
82301: LD_INT 0
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 2
82310: PUSH
82311: LD_INT 1
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: PUSH
82318: LD_INT 2
82320: PUSH
82321: LD_INT 2
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_INT 1
82330: PUSH
82331: LD_INT 2
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 0
82340: PUSH
82341: LD_INT 2
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 1
82350: NEG
82351: PUSH
82352: LD_INT 1
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 2
82361: NEG
82362: PUSH
82363: LD_INT 0
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 2
82372: NEG
82373: PUSH
82374: LD_INT 1
82376: NEG
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 2
82384: NEG
82385: PUSH
82386: LD_INT 2
82388: NEG
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: LIST
82405: LIST
82406: LIST
82407: LIST
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82415: LD_ADDR_VAR 0 22
82419: PUSH
82420: LD_INT 0
82422: PUSH
82423: LD_INT 0
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: LD_INT 0
82432: PUSH
82433: LD_INT 1
82435: NEG
82436: PUSH
82437: EMPTY
82438: LIST
82439: LIST
82440: PUSH
82441: LD_INT 1
82443: PUSH
82444: LD_INT 0
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: PUSH
82451: LD_INT 1
82453: PUSH
82454: LD_INT 1
82456: PUSH
82457: EMPTY
82458: LIST
82459: LIST
82460: PUSH
82461: LD_INT 0
82463: PUSH
82464: LD_INT 1
82466: PUSH
82467: EMPTY
82468: LIST
82469: LIST
82470: PUSH
82471: LD_INT 1
82473: NEG
82474: PUSH
82475: LD_INT 0
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 1
82484: NEG
82485: PUSH
82486: LD_INT 1
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 1
82496: NEG
82497: PUSH
82498: LD_INT 2
82500: NEG
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 0
82508: PUSH
82509: LD_INT 2
82511: NEG
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: PUSH
82517: LD_INT 1
82519: PUSH
82520: LD_INT 1
82522: NEG
82523: PUSH
82524: EMPTY
82525: LIST
82526: LIST
82527: PUSH
82528: LD_INT 2
82530: PUSH
82531: LD_INT 0
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: PUSH
82538: LD_INT 2
82540: PUSH
82541: LD_INT 1
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 2
82550: PUSH
82551: LD_INT 2
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 1
82560: PUSH
82561: LD_INT 2
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: PUSH
82568: LD_INT 0
82570: PUSH
82571: LD_INT 2
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 1
82580: NEG
82581: PUSH
82582: LD_INT 1
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 2
82591: NEG
82592: PUSH
82593: LD_INT 0
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 2
82602: NEG
82603: PUSH
82604: LD_INT 1
82606: NEG
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: PUSH
82612: LD_INT 2
82614: NEG
82615: PUSH
82616: LD_INT 2
82618: NEG
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82645: LD_ADDR_VAR 0 23
82649: PUSH
82650: LD_INT 0
82652: PUSH
82653: LD_INT 0
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 0
82662: PUSH
82663: LD_INT 1
82665: NEG
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 1
82673: PUSH
82674: LD_INT 0
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 1
82683: PUSH
82684: LD_INT 1
82686: PUSH
82687: EMPTY
82688: LIST
82689: LIST
82690: PUSH
82691: LD_INT 0
82693: PUSH
82694: LD_INT 1
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: PUSH
82701: LD_INT 1
82703: NEG
82704: PUSH
82705: LD_INT 0
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 1
82714: NEG
82715: PUSH
82716: LD_INT 1
82718: NEG
82719: PUSH
82720: EMPTY
82721: LIST
82722: LIST
82723: PUSH
82724: LD_INT 1
82726: NEG
82727: PUSH
82728: LD_INT 2
82730: NEG
82731: PUSH
82732: EMPTY
82733: LIST
82734: LIST
82735: PUSH
82736: LD_INT 0
82738: PUSH
82739: LD_INT 2
82741: NEG
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: PUSH
82747: LD_INT 1
82749: PUSH
82750: LD_INT 1
82752: NEG
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PUSH
82758: LD_INT 2
82760: PUSH
82761: LD_INT 0
82763: PUSH
82764: EMPTY
82765: LIST
82766: LIST
82767: PUSH
82768: LD_INT 2
82770: PUSH
82771: LD_INT 1
82773: PUSH
82774: EMPTY
82775: LIST
82776: LIST
82777: PUSH
82778: LD_INT 2
82780: PUSH
82781: LD_INT 2
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 1
82790: PUSH
82791: LD_INT 2
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 0
82800: PUSH
82801: LD_INT 2
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: LD_INT 1
82810: NEG
82811: PUSH
82812: LD_INT 1
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 2
82821: NEG
82822: PUSH
82823: LD_INT 0
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: LD_INT 2
82832: NEG
82833: PUSH
82834: LD_INT 1
82836: NEG
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 2
82844: NEG
82845: PUSH
82846: LD_INT 2
82848: NEG
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 2
82856: NEG
82857: PUSH
82858: LD_INT 3
82860: NEG
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: PUSH
82866: LD_INT 1
82868: NEG
82869: PUSH
82870: LD_INT 3
82872: NEG
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 1
82880: PUSH
82881: LD_INT 2
82883: NEG
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 2
82891: PUSH
82892: LD_INT 1
82894: NEG
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82925: LD_ADDR_VAR 0 24
82929: PUSH
82930: LD_INT 0
82932: PUSH
82933: LD_INT 0
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 0
82942: PUSH
82943: LD_INT 1
82945: NEG
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 1
82953: PUSH
82954: LD_INT 0
82956: PUSH
82957: EMPTY
82958: LIST
82959: LIST
82960: PUSH
82961: LD_INT 1
82963: PUSH
82964: LD_INT 1
82966: PUSH
82967: EMPTY
82968: LIST
82969: LIST
82970: PUSH
82971: LD_INT 0
82973: PUSH
82974: LD_INT 1
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 1
82983: NEG
82984: PUSH
82985: LD_INT 0
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PUSH
82992: LD_INT 1
82994: NEG
82995: PUSH
82996: LD_INT 1
82998: NEG
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 1
83006: NEG
83007: PUSH
83008: LD_INT 2
83010: NEG
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 0
83018: PUSH
83019: LD_INT 2
83021: NEG
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: PUSH
83027: LD_INT 1
83029: PUSH
83030: LD_INT 1
83032: NEG
83033: PUSH
83034: EMPTY
83035: LIST
83036: LIST
83037: PUSH
83038: LD_INT 2
83040: PUSH
83041: LD_INT 0
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: LD_INT 2
83050: PUSH
83051: LD_INT 1
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PUSH
83058: LD_INT 2
83060: PUSH
83061: LD_INT 2
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: LD_INT 1
83070: PUSH
83071: LD_INT 2
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: PUSH
83078: LD_INT 0
83080: PUSH
83081: LD_INT 2
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 1
83090: NEG
83091: PUSH
83092: LD_INT 1
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 2
83101: NEG
83102: PUSH
83103: LD_INT 0
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 2
83112: NEG
83113: PUSH
83114: LD_INT 1
83116: NEG
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 2
83124: NEG
83125: PUSH
83126: LD_INT 2
83128: NEG
83129: PUSH
83130: EMPTY
83131: LIST
83132: LIST
83133: PUSH
83134: LD_INT 1
83136: PUSH
83137: LD_INT 2
83139: NEG
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: PUSH
83145: LD_INT 2
83147: PUSH
83148: LD_INT 1
83150: NEG
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 3
83158: PUSH
83159: LD_INT 1
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 3
83168: PUSH
83169: LD_INT 2
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: LIST
83180: LIST
83181: LIST
83182: LIST
83183: LIST
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83201: LD_ADDR_VAR 0 25
83205: PUSH
83206: LD_INT 0
83208: PUSH
83209: LD_INT 0
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: PUSH
83216: LD_INT 0
83218: PUSH
83219: LD_INT 1
83221: NEG
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 1
83229: PUSH
83230: LD_INT 0
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 1
83239: PUSH
83240: LD_INT 1
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 0
83249: PUSH
83250: LD_INT 1
83252: PUSH
83253: EMPTY
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 1
83259: NEG
83260: PUSH
83261: LD_INT 0
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 1
83270: NEG
83271: PUSH
83272: LD_INT 1
83274: NEG
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 1
83282: NEG
83283: PUSH
83284: LD_INT 2
83286: NEG
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 0
83294: PUSH
83295: LD_INT 2
83297: NEG
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 1
83305: PUSH
83306: LD_INT 1
83308: NEG
83309: PUSH
83310: EMPTY
83311: LIST
83312: LIST
83313: PUSH
83314: LD_INT 2
83316: PUSH
83317: LD_INT 0
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: LD_INT 2
83326: PUSH
83327: LD_INT 1
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 2
83336: PUSH
83337: LD_INT 2
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 1
83346: PUSH
83347: LD_INT 2
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 0
83356: PUSH
83357: LD_INT 2
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 1
83366: NEG
83367: PUSH
83368: LD_INT 1
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 2
83377: NEG
83378: PUSH
83379: LD_INT 0
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 2
83388: NEG
83389: PUSH
83390: LD_INT 1
83392: NEG
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PUSH
83398: LD_INT 2
83400: NEG
83401: PUSH
83402: LD_INT 2
83404: NEG
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 3
83412: PUSH
83413: LD_INT 1
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 3
83422: PUSH
83423: LD_INT 2
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 2
83432: PUSH
83433: LD_INT 3
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 1
83442: PUSH
83443: LD_INT 3
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: LIST
83454: LIST
83455: LIST
83456: LIST
83457: LIST
83458: LIST
83459: LIST
83460: LIST
83461: LIST
83462: LIST
83463: LIST
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83475: LD_ADDR_VAR 0 26
83479: PUSH
83480: LD_INT 0
83482: PUSH
83483: LD_INT 0
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PUSH
83490: LD_INT 0
83492: PUSH
83493: LD_INT 1
83495: NEG
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 1
83503: PUSH
83504: LD_INT 0
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: LD_INT 1
83513: PUSH
83514: LD_INT 1
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 0
83523: PUSH
83524: LD_INT 1
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 1
83533: NEG
83534: PUSH
83535: LD_INT 0
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 1
83544: NEG
83545: PUSH
83546: LD_INT 1
83548: NEG
83549: PUSH
83550: EMPTY
83551: LIST
83552: LIST
83553: PUSH
83554: LD_INT 1
83556: NEG
83557: PUSH
83558: LD_INT 2
83560: NEG
83561: PUSH
83562: EMPTY
83563: LIST
83564: LIST
83565: PUSH
83566: LD_INT 0
83568: PUSH
83569: LD_INT 2
83571: NEG
83572: PUSH
83573: EMPTY
83574: LIST
83575: LIST
83576: PUSH
83577: LD_INT 1
83579: PUSH
83580: LD_INT 1
83582: NEG
83583: PUSH
83584: EMPTY
83585: LIST
83586: LIST
83587: PUSH
83588: LD_INT 2
83590: PUSH
83591: LD_INT 0
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: LD_INT 2
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 2
83610: PUSH
83611: LD_INT 2
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 1
83620: PUSH
83621: LD_INT 2
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 0
83630: PUSH
83631: LD_INT 2
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 1
83640: NEG
83641: PUSH
83642: LD_INT 1
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 2
83651: NEG
83652: PUSH
83653: LD_INT 0
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: PUSH
83660: LD_INT 2
83662: NEG
83663: PUSH
83664: LD_INT 1
83666: NEG
83667: PUSH
83668: EMPTY
83669: LIST
83670: LIST
83671: PUSH
83672: LD_INT 2
83674: NEG
83675: PUSH
83676: LD_INT 2
83678: NEG
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: PUSH
83684: LD_INT 2
83686: PUSH
83687: LD_INT 3
83689: PUSH
83690: EMPTY
83691: LIST
83692: LIST
83693: PUSH
83694: LD_INT 1
83696: PUSH
83697: LD_INT 3
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PUSH
83704: LD_INT 1
83706: NEG
83707: PUSH
83708: LD_INT 2
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 2
83717: NEG
83718: PUSH
83719: LD_INT 1
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: LIST
83735: LIST
83736: LIST
83737: LIST
83738: LIST
83739: LIST
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83751: LD_ADDR_VAR 0 27
83755: PUSH
83756: LD_INT 0
83758: PUSH
83759: LD_INT 0
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 0
83768: PUSH
83769: LD_INT 1
83771: NEG
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 1
83779: PUSH
83780: LD_INT 0
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 1
83789: PUSH
83790: LD_INT 1
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PUSH
83797: LD_INT 0
83799: PUSH
83800: LD_INT 1
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: PUSH
83807: LD_INT 1
83809: NEG
83810: PUSH
83811: LD_INT 0
83813: PUSH
83814: EMPTY
83815: LIST
83816: LIST
83817: PUSH
83818: LD_INT 1
83820: NEG
83821: PUSH
83822: LD_INT 1
83824: NEG
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: PUSH
83830: LD_INT 1
83832: NEG
83833: PUSH
83834: LD_INT 2
83836: NEG
83837: PUSH
83838: EMPTY
83839: LIST
83840: LIST
83841: PUSH
83842: LD_INT 0
83844: PUSH
83845: LD_INT 2
83847: NEG
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: PUSH
83853: LD_INT 1
83855: PUSH
83856: LD_INT 1
83858: NEG
83859: PUSH
83860: EMPTY
83861: LIST
83862: LIST
83863: PUSH
83864: LD_INT 2
83866: PUSH
83867: LD_INT 0
83869: PUSH
83870: EMPTY
83871: LIST
83872: LIST
83873: PUSH
83874: LD_INT 2
83876: PUSH
83877: LD_INT 1
83879: PUSH
83880: EMPTY
83881: LIST
83882: LIST
83883: PUSH
83884: LD_INT 2
83886: PUSH
83887: LD_INT 2
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: LD_INT 1
83896: PUSH
83897: LD_INT 2
83899: PUSH
83900: EMPTY
83901: LIST
83902: LIST
83903: PUSH
83904: LD_INT 0
83906: PUSH
83907: LD_INT 2
83909: PUSH
83910: EMPTY
83911: LIST
83912: LIST
83913: PUSH
83914: LD_INT 1
83916: NEG
83917: PUSH
83918: LD_INT 1
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PUSH
83925: LD_INT 2
83927: NEG
83928: PUSH
83929: LD_INT 0
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 2
83938: NEG
83939: PUSH
83940: LD_INT 1
83942: NEG
83943: PUSH
83944: EMPTY
83945: LIST
83946: LIST
83947: PUSH
83948: LD_INT 2
83950: NEG
83951: PUSH
83952: LD_INT 2
83954: NEG
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: PUSH
83960: LD_INT 1
83962: NEG
83963: PUSH
83964: LD_INT 2
83966: PUSH
83967: EMPTY
83968: LIST
83969: LIST
83970: PUSH
83971: LD_INT 2
83973: NEG
83974: PUSH
83975: LD_INT 1
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: LD_INT 3
83984: NEG
83985: PUSH
83986: LD_INT 1
83988: NEG
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 3
83996: NEG
83997: PUSH
83998: LD_INT 2
84000: NEG
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: LIST
84024: LIST
84025: LIST
84026: LIST
84027: LIST
84028: LIST
84029: LIST
84030: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84031: LD_ADDR_VAR 0 28
84035: PUSH
84036: LD_INT 0
84038: PUSH
84039: LD_INT 0
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 0
84048: PUSH
84049: LD_INT 1
84051: NEG
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 1
84059: PUSH
84060: LD_INT 0
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 1
84069: PUSH
84070: LD_INT 1
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 0
84079: PUSH
84080: LD_INT 1
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 1
84089: NEG
84090: PUSH
84091: LD_INT 0
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PUSH
84098: LD_INT 1
84100: NEG
84101: PUSH
84102: LD_INT 1
84104: NEG
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 1
84112: NEG
84113: PUSH
84114: LD_INT 2
84116: NEG
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 0
84124: PUSH
84125: LD_INT 2
84127: NEG
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 1
84135: PUSH
84136: LD_INT 1
84138: NEG
84139: PUSH
84140: EMPTY
84141: LIST
84142: LIST
84143: PUSH
84144: LD_INT 2
84146: PUSH
84147: LD_INT 0
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: PUSH
84154: LD_INT 2
84156: PUSH
84157: LD_INT 1
84159: PUSH
84160: EMPTY
84161: LIST
84162: LIST
84163: PUSH
84164: LD_INT 2
84166: PUSH
84167: LD_INT 2
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 1
84176: PUSH
84177: LD_INT 2
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PUSH
84184: LD_INT 0
84186: PUSH
84187: LD_INT 2
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 1
84196: NEG
84197: PUSH
84198: LD_INT 1
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 2
84207: NEG
84208: PUSH
84209: LD_INT 0
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 2
84218: NEG
84219: PUSH
84220: LD_INT 1
84222: NEG
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: LD_INT 2
84230: NEG
84231: PUSH
84232: LD_INT 2
84234: NEG
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 2
84242: NEG
84243: PUSH
84244: LD_INT 3
84246: NEG
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 1
84254: NEG
84255: PUSH
84256: LD_INT 3
84258: NEG
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 3
84266: NEG
84267: PUSH
84268: LD_INT 1
84270: NEG
84271: PUSH
84272: EMPTY
84273: LIST
84274: LIST
84275: PUSH
84276: LD_INT 3
84278: NEG
84279: PUSH
84280: LD_INT 2
84282: NEG
84283: PUSH
84284: EMPTY
84285: LIST
84286: LIST
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84313: LD_ADDR_VAR 0 29
84317: PUSH
84318: LD_INT 0
84320: PUSH
84321: LD_INT 0
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 0
84330: PUSH
84331: LD_INT 1
84333: NEG
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 1
84341: PUSH
84342: LD_INT 0
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 1
84351: PUSH
84352: LD_INT 1
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 0
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 1
84371: NEG
84372: PUSH
84373: LD_INT 0
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 1
84382: NEG
84383: PUSH
84384: LD_INT 1
84386: NEG
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 1
84394: NEG
84395: PUSH
84396: LD_INT 2
84398: NEG
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 0
84406: PUSH
84407: LD_INT 2
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 1
84417: PUSH
84418: LD_INT 1
84420: NEG
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 2
84428: PUSH
84429: LD_INT 0
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 2
84438: PUSH
84439: LD_INT 1
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 1
84448: PUSH
84449: LD_INT 2
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 0
84458: PUSH
84459: LD_INT 2
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 1
84468: NEG
84469: PUSH
84470: LD_INT 1
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: LD_INT 1
84483: NEG
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: LD_INT 2
84491: NEG
84492: PUSH
84493: LD_INT 2
84495: NEG
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: LD_INT 2
84503: NEG
84504: PUSH
84505: LD_INT 3
84507: NEG
84508: PUSH
84509: EMPTY
84510: LIST
84511: LIST
84512: PUSH
84513: LD_INT 2
84515: PUSH
84516: LD_INT 1
84518: NEG
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: PUSH
84524: LD_INT 3
84526: PUSH
84527: LD_INT 1
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 1
84536: PUSH
84537: LD_INT 3
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: LD_INT 1
84546: NEG
84547: PUSH
84548: LD_INT 2
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 3
84557: NEG
84558: PUSH
84559: LD_INT 2
84561: NEG
84562: PUSH
84563: EMPTY
84564: LIST
84565: LIST
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84592: LD_ADDR_VAR 0 30
84596: PUSH
84597: LD_INT 0
84599: PUSH
84600: LD_INT 0
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: PUSH
84607: LD_INT 0
84609: PUSH
84610: LD_INT 1
84612: NEG
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 1
84620: PUSH
84621: LD_INT 0
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 1
84630: PUSH
84631: LD_INT 1
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: PUSH
84638: LD_INT 0
84640: PUSH
84641: LD_INT 1
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: PUSH
84648: LD_INT 1
84650: NEG
84651: PUSH
84652: LD_INT 0
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: LD_INT 1
84661: NEG
84662: PUSH
84663: LD_INT 1
84665: NEG
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 1
84673: NEG
84674: PUSH
84675: LD_INT 2
84677: NEG
84678: PUSH
84679: EMPTY
84680: LIST
84681: LIST
84682: PUSH
84683: LD_INT 0
84685: PUSH
84686: LD_INT 2
84688: NEG
84689: PUSH
84690: EMPTY
84691: LIST
84692: LIST
84693: PUSH
84694: LD_INT 1
84696: PUSH
84697: LD_INT 1
84699: NEG
84700: PUSH
84701: EMPTY
84702: LIST
84703: LIST
84704: PUSH
84705: LD_INT 2
84707: PUSH
84708: LD_INT 0
84710: PUSH
84711: EMPTY
84712: LIST
84713: LIST
84714: PUSH
84715: LD_INT 2
84717: PUSH
84718: LD_INT 1
84720: PUSH
84721: EMPTY
84722: LIST
84723: LIST
84724: PUSH
84725: LD_INT 2
84727: PUSH
84728: LD_INT 2
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: PUSH
84735: LD_INT 1
84737: PUSH
84738: LD_INT 2
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PUSH
84745: LD_INT 1
84747: NEG
84748: PUSH
84749: LD_INT 1
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: LD_INT 2
84758: NEG
84759: PUSH
84760: LD_INT 0
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 2
84769: NEG
84770: PUSH
84771: LD_INT 1
84773: NEG
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 1
84781: NEG
84782: PUSH
84783: LD_INT 3
84785: NEG
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: PUSH
84791: LD_INT 1
84793: PUSH
84794: LD_INT 2
84796: NEG
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: PUSH
84802: LD_INT 3
84804: PUSH
84805: LD_INT 2
84807: PUSH
84808: EMPTY
84809: LIST
84810: LIST
84811: PUSH
84812: LD_INT 2
84814: PUSH
84815: LD_INT 3
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: LD_INT 2
84824: NEG
84825: PUSH
84826: LD_INT 1
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: LD_INT 3
84835: NEG
84836: PUSH
84837: LD_INT 1
84839: NEG
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84870: LD_ADDR_VAR 0 31
84874: PUSH
84875: LD_INT 0
84877: PUSH
84878: LD_INT 0
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 0
84887: PUSH
84888: LD_INT 1
84890: NEG
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 1
84898: PUSH
84899: LD_INT 0
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 1
84908: PUSH
84909: LD_INT 1
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 0
84918: PUSH
84919: LD_INT 1
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: LD_INT 0
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_INT 1
84939: NEG
84940: PUSH
84941: LD_INT 1
84943: NEG
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 1
84951: NEG
84952: PUSH
84953: LD_INT 2
84955: NEG
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 1
84963: PUSH
84964: LD_INT 1
84966: NEG
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: PUSH
84975: LD_INT 0
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 2
84984: PUSH
84985: LD_INT 1
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 2
84994: PUSH
84995: LD_INT 2
84997: PUSH
84998: EMPTY
84999: LIST
85000: LIST
85001: PUSH
85002: LD_INT 1
85004: PUSH
85005: LD_INT 2
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 0
85014: PUSH
85015: LD_INT 2
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 1
85024: NEG
85025: PUSH
85026: LD_INT 1
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 2
85035: NEG
85036: PUSH
85037: LD_INT 1
85039: NEG
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: PUSH
85045: LD_INT 2
85047: NEG
85048: PUSH
85049: LD_INT 2
85051: NEG
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 2
85059: NEG
85060: PUSH
85061: LD_INT 3
85063: NEG
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 2
85071: PUSH
85072: LD_INT 1
85074: NEG
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 3
85082: PUSH
85083: LD_INT 1
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: LD_INT 1
85092: PUSH
85093: LD_INT 3
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 1
85102: NEG
85103: PUSH
85104: LD_INT 2
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 3
85113: NEG
85114: PUSH
85115: LD_INT 2
85117: NEG
85118: PUSH
85119: EMPTY
85120: LIST
85121: LIST
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: LIST
85143: LIST
85144: LIST
85145: LIST
85146: LIST
85147: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85148: LD_ADDR_VAR 0 32
85152: PUSH
85153: LD_INT 0
85155: PUSH
85156: LD_INT 0
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PUSH
85163: LD_INT 0
85165: PUSH
85166: LD_INT 1
85168: NEG
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: LD_INT 1
85176: PUSH
85177: LD_INT 0
85179: PUSH
85180: EMPTY
85181: LIST
85182: LIST
85183: PUSH
85184: LD_INT 1
85186: PUSH
85187: LD_INT 1
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: LD_INT 0
85196: PUSH
85197: LD_INT 1
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 1
85206: NEG
85207: PUSH
85208: LD_INT 0
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: LD_INT 1
85217: NEG
85218: PUSH
85219: LD_INT 1
85221: NEG
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 1
85229: NEG
85230: PUSH
85231: LD_INT 2
85233: NEG
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 0
85241: PUSH
85242: LD_INT 2
85244: NEG
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: PUSH
85250: LD_INT 1
85252: PUSH
85253: LD_INT 1
85255: NEG
85256: PUSH
85257: EMPTY
85258: LIST
85259: LIST
85260: PUSH
85261: LD_INT 2
85263: PUSH
85264: LD_INT 1
85266: PUSH
85267: EMPTY
85268: LIST
85269: LIST
85270: PUSH
85271: LD_INT 2
85273: PUSH
85274: LD_INT 2
85276: PUSH
85277: EMPTY
85278: LIST
85279: LIST
85280: PUSH
85281: LD_INT 1
85283: PUSH
85284: LD_INT 2
85286: PUSH
85287: EMPTY
85288: LIST
85289: LIST
85290: PUSH
85291: LD_INT 0
85293: PUSH
85294: LD_INT 2
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 1
85303: NEG
85304: PUSH
85305: LD_INT 1
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PUSH
85312: LD_INT 2
85314: NEG
85315: PUSH
85316: LD_INT 0
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 2
85325: NEG
85326: PUSH
85327: LD_INT 1
85329: NEG
85330: PUSH
85331: EMPTY
85332: LIST
85333: LIST
85334: PUSH
85335: LD_INT 1
85337: NEG
85338: PUSH
85339: LD_INT 3
85341: NEG
85342: PUSH
85343: EMPTY
85344: LIST
85345: LIST
85346: PUSH
85347: LD_INT 1
85349: PUSH
85350: LD_INT 2
85352: NEG
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 3
85360: PUSH
85361: LD_INT 2
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 2
85370: PUSH
85371: LD_INT 3
85373: PUSH
85374: EMPTY
85375: LIST
85376: LIST
85377: PUSH
85378: LD_INT 2
85380: NEG
85381: PUSH
85382: LD_INT 1
85384: PUSH
85385: EMPTY
85386: LIST
85387: LIST
85388: PUSH
85389: LD_INT 3
85391: NEG
85392: PUSH
85393: LD_INT 1
85395: NEG
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: LIST
85415: LIST
85416: LIST
85417: LIST
85418: LIST
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85426: LD_ADDR_VAR 0 33
85430: PUSH
85431: LD_INT 0
85433: PUSH
85434: LD_INT 0
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 0
85443: PUSH
85444: LD_INT 1
85446: NEG
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 1
85454: PUSH
85455: LD_INT 0
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: LD_INT 1
85464: PUSH
85465: LD_INT 1
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 0
85474: PUSH
85475: LD_INT 1
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 1
85484: NEG
85485: PUSH
85486: LD_INT 0
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 1
85495: NEG
85496: PUSH
85497: LD_INT 1
85499: NEG
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PUSH
85505: LD_INT 1
85507: NEG
85508: PUSH
85509: LD_INT 2
85511: NEG
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: LD_INT 1
85519: PUSH
85520: LD_INT 1
85522: NEG
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: LD_INT 2
85530: PUSH
85531: LD_INT 0
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 2
85540: PUSH
85541: LD_INT 1
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 1
85550: PUSH
85551: LD_INT 2
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 0
85560: PUSH
85561: LD_INT 2
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: PUSH
85568: LD_INT 1
85570: NEG
85571: PUSH
85572: LD_INT 1
85574: PUSH
85575: EMPTY
85576: LIST
85577: LIST
85578: PUSH
85579: LD_INT 2
85581: NEG
85582: PUSH
85583: LD_INT 0
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 2
85592: NEG
85593: PUSH
85594: LD_INT 1
85596: NEG
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: PUSH
85602: LD_INT 2
85604: NEG
85605: PUSH
85606: LD_INT 2
85608: NEG
85609: PUSH
85610: EMPTY
85611: LIST
85612: LIST
85613: PUSH
85614: LD_INT 2
85616: NEG
85617: PUSH
85618: LD_INT 3
85620: NEG
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 2
85628: PUSH
85629: LD_INT 1
85631: NEG
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 3
85639: PUSH
85640: LD_INT 1
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 1
85649: PUSH
85650: LD_INT 3
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 1
85659: NEG
85660: PUSH
85661: LD_INT 2
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 3
85670: NEG
85671: PUSH
85672: LD_INT 2
85674: NEG
85675: PUSH
85676: EMPTY
85677: LIST
85678: LIST
85679: PUSH
85680: EMPTY
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85705: LD_ADDR_VAR 0 34
85709: PUSH
85710: LD_INT 0
85712: PUSH
85713: LD_INT 0
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: PUSH
85720: LD_INT 0
85722: PUSH
85723: LD_INT 1
85725: NEG
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 1
85733: PUSH
85734: LD_INT 0
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: PUSH
85741: LD_INT 1
85743: PUSH
85744: LD_INT 1
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 0
85753: PUSH
85754: LD_INT 1
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: PUSH
85761: LD_INT 1
85763: NEG
85764: PUSH
85765: LD_INT 0
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 1
85774: NEG
85775: PUSH
85776: LD_INT 1
85778: NEG
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: PUSH
85784: LD_INT 1
85786: NEG
85787: PUSH
85788: LD_INT 2
85790: NEG
85791: PUSH
85792: EMPTY
85793: LIST
85794: LIST
85795: PUSH
85796: LD_INT 0
85798: PUSH
85799: LD_INT 2
85801: NEG
85802: PUSH
85803: EMPTY
85804: LIST
85805: LIST
85806: PUSH
85807: LD_INT 1
85809: PUSH
85810: LD_INT 1
85812: NEG
85813: PUSH
85814: EMPTY
85815: LIST
85816: LIST
85817: PUSH
85818: LD_INT 2
85820: PUSH
85821: LD_INT 1
85823: PUSH
85824: EMPTY
85825: LIST
85826: LIST
85827: PUSH
85828: LD_INT 2
85830: PUSH
85831: LD_INT 2
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 1
85840: PUSH
85841: LD_INT 2
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: PUSH
85848: LD_INT 1
85850: NEG
85851: PUSH
85852: LD_INT 1
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 2
85861: NEG
85862: PUSH
85863: LD_INT 0
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 2
85872: NEG
85873: PUSH
85874: LD_INT 1
85876: NEG
85877: PUSH
85878: EMPTY
85879: LIST
85880: LIST
85881: PUSH
85882: LD_INT 2
85884: NEG
85885: PUSH
85886: LD_INT 2
85888: NEG
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 1
85896: NEG
85897: PUSH
85898: LD_INT 3
85900: NEG
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: LD_INT 1
85908: PUSH
85909: LD_INT 2
85911: NEG
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 3
85919: PUSH
85920: LD_INT 2
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: LD_INT 2
85929: PUSH
85930: LD_INT 3
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 2
85939: NEG
85940: PUSH
85941: LD_INT 1
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: LD_INT 3
85950: NEG
85951: PUSH
85952: LD_INT 1
85954: NEG
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85985: LD_ADDR_VAR 0 35
85989: PUSH
85990: LD_INT 0
85992: PUSH
85993: LD_INT 0
85995: PUSH
85996: EMPTY
85997: LIST
85998: LIST
85999: PUSH
86000: LD_INT 0
86002: PUSH
86003: LD_INT 1
86005: NEG
86006: PUSH
86007: EMPTY
86008: LIST
86009: LIST
86010: PUSH
86011: LD_INT 1
86013: PUSH
86014: LD_INT 0
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 1
86023: PUSH
86024: LD_INT 1
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 0
86033: PUSH
86034: LD_INT 1
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 1
86043: NEG
86044: PUSH
86045: LD_INT 0
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: LD_INT 1
86054: NEG
86055: PUSH
86056: LD_INT 1
86058: NEG
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 2
86066: PUSH
86067: LD_INT 1
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: LD_INT 2
86076: NEG
86077: PUSH
86078: LD_INT 1
86080: NEG
86081: PUSH
86082: EMPTY
86083: LIST
86084: LIST
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86097: LD_ADDR_VAR 0 36
86101: PUSH
86102: LD_INT 0
86104: PUSH
86105: LD_INT 0
86107: PUSH
86108: EMPTY
86109: LIST
86110: LIST
86111: PUSH
86112: LD_INT 0
86114: PUSH
86115: LD_INT 1
86117: NEG
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 1
86125: PUSH
86126: LD_INT 0
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 1
86135: PUSH
86136: LD_INT 1
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 0
86145: PUSH
86146: LD_INT 1
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 1
86155: NEG
86156: PUSH
86157: LD_INT 0
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: PUSH
86164: LD_INT 1
86166: NEG
86167: PUSH
86168: LD_INT 1
86170: NEG
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: PUSH
86176: LD_INT 1
86178: NEG
86179: PUSH
86180: LD_INT 2
86182: NEG
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 1
86190: PUSH
86191: LD_INT 2
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86209: LD_ADDR_VAR 0 37
86213: PUSH
86214: LD_INT 0
86216: PUSH
86217: LD_INT 0
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: LD_INT 1
86229: NEG
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: LD_INT 1
86237: PUSH
86238: LD_INT 0
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: PUSH
86248: LD_INT 1
86250: PUSH
86251: EMPTY
86252: LIST
86253: LIST
86254: PUSH
86255: LD_INT 0
86257: PUSH
86258: LD_INT 1
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: LD_INT 1
86267: NEG
86268: PUSH
86269: LD_INT 0
86271: PUSH
86272: EMPTY
86273: LIST
86274: LIST
86275: PUSH
86276: LD_INT 1
86278: NEG
86279: PUSH
86280: LD_INT 1
86282: NEG
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 1
86290: PUSH
86291: LD_INT 1
86293: NEG
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 1
86301: NEG
86302: PUSH
86303: LD_INT 1
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86321: LD_ADDR_VAR 0 38
86325: PUSH
86326: LD_INT 0
86328: PUSH
86329: LD_INT 0
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: PUSH
86336: LD_INT 0
86338: PUSH
86339: LD_INT 1
86341: NEG
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 1
86349: PUSH
86350: LD_INT 0
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: LD_INT 1
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 0
86369: PUSH
86370: LD_INT 1
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 1
86379: NEG
86380: PUSH
86381: LD_INT 0
86383: PUSH
86384: EMPTY
86385: LIST
86386: LIST
86387: PUSH
86388: LD_INT 1
86390: NEG
86391: PUSH
86392: LD_INT 1
86394: NEG
86395: PUSH
86396: EMPTY
86397: LIST
86398: LIST
86399: PUSH
86400: LD_INT 2
86402: PUSH
86403: LD_INT 1
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: LD_INT 2
86412: NEG
86413: PUSH
86414: LD_INT 1
86416: NEG
86417: PUSH
86418: EMPTY
86419: LIST
86420: LIST
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86433: LD_ADDR_VAR 0 39
86437: PUSH
86438: LD_INT 0
86440: PUSH
86441: LD_INT 0
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: PUSH
86448: LD_INT 0
86450: PUSH
86451: LD_INT 1
86453: NEG
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_INT 1
86461: PUSH
86462: LD_INT 0
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 1
86471: PUSH
86472: LD_INT 1
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: PUSH
86479: LD_INT 0
86481: PUSH
86482: LD_INT 1
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 1
86491: NEG
86492: PUSH
86493: LD_INT 0
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 1
86502: NEG
86503: PUSH
86504: LD_INT 1
86506: NEG
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: LD_INT 2
86518: NEG
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: PUSH
86524: LD_INT 1
86526: PUSH
86527: LD_INT 2
86529: PUSH
86530: EMPTY
86531: LIST
86532: LIST
86533: PUSH
86534: EMPTY
86535: LIST
86536: LIST
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86545: LD_ADDR_VAR 0 40
86549: PUSH
86550: LD_INT 0
86552: PUSH
86553: LD_INT 0
86555: PUSH
86556: EMPTY
86557: LIST
86558: LIST
86559: PUSH
86560: LD_INT 0
86562: PUSH
86563: LD_INT 1
86565: NEG
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 1
86573: PUSH
86574: LD_INT 0
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 1
86583: PUSH
86584: LD_INT 1
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: LD_INT 0
86593: PUSH
86594: LD_INT 1
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: PUSH
86601: LD_INT 1
86603: NEG
86604: PUSH
86605: LD_INT 0
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: LD_INT 1
86614: NEG
86615: PUSH
86616: LD_INT 1
86618: NEG
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 1
86626: PUSH
86627: LD_INT 1
86629: NEG
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 1
86637: NEG
86638: PUSH
86639: LD_INT 1
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: EMPTY
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86657: LD_ADDR_VAR 0 41
86661: PUSH
86662: LD_INT 0
86664: PUSH
86665: LD_INT 0
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 0
86674: PUSH
86675: LD_INT 1
86677: NEG
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: PUSH
86683: LD_INT 1
86685: PUSH
86686: LD_INT 0
86688: PUSH
86689: EMPTY
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 1
86695: PUSH
86696: LD_INT 1
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: LD_INT 0
86705: PUSH
86706: LD_INT 1
86708: PUSH
86709: EMPTY
86710: LIST
86711: LIST
86712: PUSH
86713: LD_INT 1
86715: NEG
86716: PUSH
86717: LD_INT 0
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 1
86726: NEG
86727: PUSH
86728: LD_INT 1
86730: NEG
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: PUSH
86740: LD_INT 2
86742: NEG
86743: PUSH
86744: EMPTY
86745: LIST
86746: LIST
86747: PUSH
86748: LD_INT 1
86750: PUSH
86751: LD_INT 1
86753: NEG
86754: PUSH
86755: EMPTY
86756: LIST
86757: LIST
86758: PUSH
86759: LD_INT 2
86761: PUSH
86762: LD_INT 0
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 2
86771: PUSH
86772: LD_INT 1
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 2
86781: PUSH
86782: LD_INT 2
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: PUSH
86789: LD_INT 1
86791: PUSH
86792: LD_INT 2
86794: PUSH
86795: EMPTY
86796: LIST
86797: LIST
86798: PUSH
86799: LD_INT 1
86801: NEG
86802: PUSH
86803: LD_INT 1
86805: PUSH
86806: EMPTY
86807: LIST
86808: LIST
86809: PUSH
86810: LD_INT 2
86812: NEG
86813: PUSH
86814: LD_INT 0
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 2
86823: NEG
86824: PUSH
86825: LD_INT 1
86827: NEG
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 2
86835: NEG
86836: PUSH
86837: LD_INT 2
86839: NEG
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 2
86847: NEG
86848: PUSH
86849: LD_INT 3
86851: NEG
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 2
86859: PUSH
86860: LD_INT 1
86862: NEG
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 3
86870: PUSH
86871: LD_INT 0
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 3
86880: PUSH
86881: LD_INT 1
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 3
86890: PUSH
86891: LD_INT 2
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 3
86900: PUSH
86901: LD_INT 3
86903: PUSH
86904: EMPTY
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 2
86910: PUSH
86911: LD_INT 3
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 2
86920: NEG
86921: PUSH
86922: LD_INT 1
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 3
86931: NEG
86932: PUSH
86933: LD_INT 0
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 3
86942: NEG
86943: PUSH
86944: LD_INT 1
86946: NEG
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 3
86954: NEG
86955: PUSH
86956: LD_INT 2
86958: NEG
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: PUSH
86964: LD_INT 3
86966: NEG
86967: PUSH
86968: LD_INT 3
86970: NEG
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87007: LD_ADDR_VAR 0 42
87011: PUSH
87012: LD_INT 0
87014: PUSH
87015: LD_INT 0
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: LD_INT 0
87024: PUSH
87025: LD_INT 1
87027: NEG
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 1
87035: PUSH
87036: LD_INT 0
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: LD_INT 1
87045: PUSH
87046: LD_INT 1
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: PUSH
87053: LD_INT 0
87055: PUSH
87056: LD_INT 1
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: PUSH
87063: LD_INT 1
87065: NEG
87066: PUSH
87067: LD_INT 0
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: PUSH
87074: LD_INT 1
87076: NEG
87077: PUSH
87078: LD_INT 1
87080: NEG
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: PUSH
87086: LD_INT 1
87088: NEG
87089: PUSH
87090: LD_INT 2
87092: NEG
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 0
87100: PUSH
87101: LD_INT 2
87103: NEG
87104: PUSH
87105: EMPTY
87106: LIST
87107: LIST
87108: PUSH
87109: LD_INT 1
87111: PUSH
87112: LD_INT 1
87114: NEG
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 2
87122: PUSH
87123: LD_INT 1
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 2
87132: PUSH
87133: LD_INT 2
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 1
87142: PUSH
87143: LD_INT 2
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 0
87152: PUSH
87153: LD_INT 2
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: PUSH
87160: LD_INT 1
87162: NEG
87163: PUSH
87164: LD_INT 1
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: LD_INT 2
87173: NEG
87174: PUSH
87175: LD_INT 1
87177: NEG
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: PUSH
87183: LD_INT 2
87185: NEG
87186: PUSH
87187: LD_INT 2
87189: NEG
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 2
87197: NEG
87198: PUSH
87199: LD_INT 3
87201: NEG
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 1
87209: NEG
87210: PUSH
87211: LD_INT 3
87213: NEG
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: PUSH
87219: LD_INT 0
87221: PUSH
87222: LD_INT 3
87224: NEG
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 1
87232: PUSH
87233: LD_INT 2
87235: NEG
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PUSH
87241: LD_INT 3
87243: PUSH
87244: LD_INT 2
87246: PUSH
87247: EMPTY
87248: LIST
87249: LIST
87250: PUSH
87251: LD_INT 3
87253: PUSH
87254: LD_INT 3
87256: PUSH
87257: EMPTY
87258: LIST
87259: LIST
87260: PUSH
87261: LD_INT 2
87263: PUSH
87264: LD_INT 3
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PUSH
87271: LD_INT 1
87273: PUSH
87274: LD_INT 3
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PUSH
87281: LD_INT 0
87283: PUSH
87284: LD_INT 3
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 1
87293: NEG
87294: PUSH
87295: LD_INT 2
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: LD_INT 3
87304: NEG
87305: PUSH
87306: LD_INT 2
87308: NEG
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: PUSH
87314: LD_INT 3
87316: NEG
87317: PUSH
87318: LD_INT 3
87320: NEG
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87357: LD_ADDR_VAR 0 43
87361: PUSH
87362: LD_INT 0
87364: PUSH
87365: LD_INT 0
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 0
87374: PUSH
87375: LD_INT 1
87377: NEG
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 1
87385: PUSH
87386: LD_INT 0
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 1
87395: PUSH
87396: LD_INT 1
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: LD_INT 0
87405: PUSH
87406: LD_INT 1
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 1
87415: NEG
87416: PUSH
87417: LD_INT 0
87419: PUSH
87420: EMPTY
87421: LIST
87422: LIST
87423: PUSH
87424: LD_INT 1
87426: NEG
87427: PUSH
87428: LD_INT 1
87430: NEG
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: PUSH
87436: LD_INT 1
87438: NEG
87439: PUSH
87440: LD_INT 2
87442: NEG
87443: PUSH
87444: EMPTY
87445: LIST
87446: LIST
87447: PUSH
87448: LD_INT 0
87450: PUSH
87451: LD_INT 2
87453: NEG
87454: PUSH
87455: EMPTY
87456: LIST
87457: LIST
87458: PUSH
87459: LD_INT 1
87461: PUSH
87462: LD_INT 1
87464: NEG
87465: PUSH
87466: EMPTY
87467: LIST
87468: LIST
87469: PUSH
87470: LD_INT 2
87472: PUSH
87473: LD_INT 0
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: PUSH
87480: LD_INT 2
87482: PUSH
87483: LD_INT 1
87485: PUSH
87486: EMPTY
87487: LIST
87488: LIST
87489: PUSH
87490: LD_INT 1
87492: PUSH
87493: LD_INT 2
87495: PUSH
87496: EMPTY
87497: LIST
87498: LIST
87499: PUSH
87500: LD_INT 0
87502: PUSH
87503: LD_INT 2
87505: PUSH
87506: EMPTY
87507: LIST
87508: LIST
87509: PUSH
87510: LD_INT 1
87512: NEG
87513: PUSH
87514: LD_INT 1
87516: PUSH
87517: EMPTY
87518: LIST
87519: LIST
87520: PUSH
87521: LD_INT 2
87523: NEG
87524: PUSH
87525: LD_INT 0
87527: PUSH
87528: EMPTY
87529: LIST
87530: LIST
87531: PUSH
87532: LD_INT 2
87534: NEG
87535: PUSH
87536: LD_INT 1
87538: NEG
87539: PUSH
87540: EMPTY
87541: LIST
87542: LIST
87543: PUSH
87544: LD_INT 1
87546: NEG
87547: PUSH
87548: LD_INT 3
87550: NEG
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: PUSH
87556: LD_INT 0
87558: PUSH
87559: LD_INT 3
87561: NEG
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 1
87569: PUSH
87570: LD_INT 2
87572: NEG
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: LD_INT 2
87580: PUSH
87581: LD_INT 1
87583: NEG
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: PUSH
87589: LD_INT 3
87591: PUSH
87592: LD_INT 0
87594: PUSH
87595: EMPTY
87596: LIST
87597: LIST
87598: PUSH
87599: LD_INT 3
87601: PUSH
87602: LD_INT 1
87604: PUSH
87605: EMPTY
87606: LIST
87607: LIST
87608: PUSH
87609: LD_INT 1
87611: PUSH
87612: LD_INT 3
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 0
87621: PUSH
87622: LD_INT 3
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: PUSH
87629: LD_INT 1
87631: NEG
87632: PUSH
87633: LD_INT 2
87635: PUSH
87636: EMPTY
87637: LIST
87638: LIST
87639: PUSH
87640: LD_INT 2
87642: NEG
87643: PUSH
87644: LD_INT 1
87646: PUSH
87647: EMPTY
87648: LIST
87649: LIST
87650: PUSH
87651: LD_INT 3
87653: NEG
87654: PUSH
87655: LD_INT 0
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: PUSH
87662: LD_INT 3
87664: NEG
87665: PUSH
87666: LD_INT 1
87668: NEG
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87705: LD_ADDR_VAR 0 44
87709: PUSH
87710: LD_INT 0
87712: PUSH
87713: LD_INT 0
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: PUSH
87720: LD_INT 0
87722: PUSH
87723: LD_INT 1
87725: NEG
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: PUSH
87731: LD_INT 1
87733: PUSH
87734: LD_INT 0
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: LD_INT 1
87743: PUSH
87744: LD_INT 1
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 0
87753: PUSH
87754: LD_INT 1
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 1
87763: NEG
87764: PUSH
87765: LD_INT 0
87767: PUSH
87768: EMPTY
87769: LIST
87770: LIST
87771: PUSH
87772: LD_INT 1
87774: NEG
87775: PUSH
87776: LD_INT 1
87778: NEG
87779: PUSH
87780: EMPTY
87781: LIST
87782: LIST
87783: PUSH
87784: LD_INT 1
87786: NEG
87787: PUSH
87788: LD_INT 2
87790: NEG
87791: PUSH
87792: EMPTY
87793: LIST
87794: LIST
87795: PUSH
87796: LD_INT 1
87798: PUSH
87799: LD_INT 1
87801: NEG
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: PUSH
87807: LD_INT 2
87809: PUSH
87810: LD_INT 0
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: PUSH
87817: LD_INT 2
87819: PUSH
87820: LD_INT 1
87822: PUSH
87823: EMPTY
87824: LIST
87825: LIST
87826: PUSH
87827: LD_INT 2
87829: PUSH
87830: LD_INT 2
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PUSH
87837: LD_INT 1
87839: PUSH
87840: LD_INT 2
87842: PUSH
87843: EMPTY
87844: LIST
87845: LIST
87846: PUSH
87847: LD_INT 1
87849: NEG
87850: PUSH
87851: LD_INT 1
87853: PUSH
87854: EMPTY
87855: LIST
87856: LIST
87857: PUSH
87858: LD_INT 2
87860: NEG
87861: PUSH
87862: LD_INT 0
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: PUSH
87869: LD_INT 2
87871: NEG
87872: PUSH
87873: LD_INT 1
87875: NEG
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 2
87883: NEG
87884: PUSH
87885: LD_INT 2
87887: NEG
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: PUSH
87893: LD_INT 2
87895: NEG
87896: PUSH
87897: LD_INT 3
87899: NEG
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: PUSH
87905: LD_INT 2
87907: PUSH
87908: LD_INT 1
87910: NEG
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 3
87918: PUSH
87919: LD_INT 0
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 3
87928: PUSH
87929: LD_INT 1
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 3
87938: PUSH
87939: LD_INT 2
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 3
87948: PUSH
87949: LD_INT 3
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 2
87958: PUSH
87959: LD_INT 3
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 2
87968: NEG
87969: PUSH
87970: LD_INT 1
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 3
87979: NEG
87980: PUSH
87981: LD_INT 0
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 3
87990: NEG
87991: PUSH
87992: LD_INT 1
87994: NEG
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 3
88002: NEG
88003: PUSH
88004: LD_INT 2
88006: NEG
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 3
88014: NEG
88015: PUSH
88016: LD_INT 3
88018: NEG
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: EMPTY
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88055: LD_ADDR_VAR 0 45
88059: PUSH
88060: LD_INT 0
88062: PUSH
88063: LD_INT 0
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: LD_INT 0
88072: PUSH
88073: LD_INT 1
88075: NEG
88076: PUSH
88077: EMPTY
88078: LIST
88079: LIST
88080: PUSH
88081: LD_INT 1
88083: PUSH
88084: LD_INT 0
88086: PUSH
88087: EMPTY
88088: LIST
88089: LIST
88090: PUSH
88091: LD_INT 1
88093: PUSH
88094: LD_INT 1
88096: PUSH
88097: EMPTY
88098: LIST
88099: LIST
88100: PUSH
88101: LD_INT 0
88103: PUSH
88104: LD_INT 1
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PUSH
88111: LD_INT 1
88113: NEG
88114: PUSH
88115: LD_INT 0
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: PUSH
88122: LD_INT 1
88124: NEG
88125: PUSH
88126: LD_INT 1
88128: NEG
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PUSH
88134: LD_INT 1
88136: NEG
88137: PUSH
88138: LD_INT 2
88140: NEG
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: PUSH
88146: LD_INT 0
88148: PUSH
88149: LD_INT 2
88151: NEG
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 1
88159: PUSH
88160: LD_INT 1
88162: NEG
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: LD_INT 2
88170: PUSH
88171: LD_INT 1
88173: PUSH
88174: EMPTY
88175: LIST
88176: LIST
88177: PUSH
88178: LD_INT 2
88180: PUSH
88181: LD_INT 2
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 1
88190: PUSH
88191: LD_INT 2
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: LD_INT 0
88200: PUSH
88201: LD_INT 2
88203: PUSH
88204: EMPTY
88205: LIST
88206: LIST
88207: PUSH
88208: LD_INT 1
88210: NEG
88211: PUSH
88212: LD_INT 1
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 2
88221: NEG
88222: PUSH
88223: LD_INT 1
88225: NEG
88226: PUSH
88227: EMPTY
88228: LIST
88229: LIST
88230: PUSH
88231: LD_INT 2
88233: NEG
88234: PUSH
88235: LD_INT 2
88237: NEG
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: PUSH
88243: LD_INT 2
88245: NEG
88246: PUSH
88247: LD_INT 3
88249: NEG
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PUSH
88255: LD_INT 1
88257: NEG
88258: PUSH
88259: LD_INT 3
88261: NEG
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 0
88269: PUSH
88270: LD_INT 3
88272: NEG
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 1
88280: PUSH
88281: LD_INT 2
88283: NEG
88284: PUSH
88285: EMPTY
88286: LIST
88287: LIST
88288: PUSH
88289: LD_INT 3
88291: PUSH
88292: LD_INT 2
88294: PUSH
88295: EMPTY
88296: LIST
88297: LIST
88298: PUSH
88299: LD_INT 3
88301: PUSH
88302: LD_INT 3
88304: PUSH
88305: EMPTY
88306: LIST
88307: LIST
88308: PUSH
88309: LD_INT 2
88311: PUSH
88312: LD_INT 3
88314: PUSH
88315: EMPTY
88316: LIST
88317: LIST
88318: PUSH
88319: LD_INT 1
88321: PUSH
88322: LD_INT 3
88324: PUSH
88325: EMPTY
88326: LIST
88327: LIST
88328: PUSH
88329: LD_INT 0
88331: PUSH
88332: LD_INT 3
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: LD_INT 1
88341: NEG
88342: PUSH
88343: LD_INT 2
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 3
88352: NEG
88353: PUSH
88354: LD_INT 2
88356: NEG
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 3
88364: NEG
88365: PUSH
88366: LD_INT 3
88368: NEG
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: LIST
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88405: LD_ADDR_VAR 0 46
88409: PUSH
88410: LD_INT 0
88412: PUSH
88413: LD_INT 0
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 0
88422: PUSH
88423: LD_INT 1
88425: NEG
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 1
88433: PUSH
88434: LD_INT 0
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 1
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 0
88453: PUSH
88454: LD_INT 1
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 1
88463: NEG
88464: PUSH
88465: LD_INT 0
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PUSH
88472: LD_INT 1
88474: NEG
88475: PUSH
88476: LD_INT 1
88478: NEG
88479: PUSH
88480: EMPTY
88481: LIST
88482: LIST
88483: PUSH
88484: LD_INT 1
88486: NEG
88487: PUSH
88488: LD_INT 2
88490: NEG
88491: PUSH
88492: EMPTY
88493: LIST
88494: LIST
88495: PUSH
88496: LD_INT 0
88498: PUSH
88499: LD_INT 2
88501: NEG
88502: PUSH
88503: EMPTY
88504: LIST
88505: LIST
88506: PUSH
88507: LD_INT 1
88509: PUSH
88510: LD_INT 1
88512: NEG
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PUSH
88518: LD_INT 2
88520: PUSH
88521: LD_INT 0
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 2
88530: PUSH
88531: LD_INT 1
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: PUSH
88538: LD_INT 1
88540: PUSH
88541: LD_INT 2
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 0
88550: PUSH
88551: LD_INT 2
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 1
88560: NEG
88561: PUSH
88562: LD_INT 1
88564: PUSH
88565: EMPTY
88566: LIST
88567: LIST
88568: PUSH
88569: LD_INT 2
88571: NEG
88572: PUSH
88573: LD_INT 0
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 2
88582: NEG
88583: PUSH
88584: LD_INT 1
88586: NEG
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: PUSH
88592: LD_INT 1
88594: NEG
88595: PUSH
88596: LD_INT 3
88598: NEG
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 0
88606: PUSH
88607: LD_INT 3
88609: NEG
88610: PUSH
88611: EMPTY
88612: LIST
88613: LIST
88614: PUSH
88615: LD_INT 1
88617: PUSH
88618: LD_INT 2
88620: NEG
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PUSH
88626: LD_INT 2
88628: PUSH
88629: LD_INT 1
88631: NEG
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PUSH
88637: LD_INT 3
88639: PUSH
88640: LD_INT 0
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: LD_INT 3
88649: PUSH
88650: LD_INT 1
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: PUSH
88657: LD_INT 1
88659: PUSH
88660: LD_INT 3
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: PUSH
88667: LD_INT 0
88669: PUSH
88670: LD_INT 3
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 1
88679: NEG
88680: PUSH
88681: LD_INT 2
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 2
88690: NEG
88691: PUSH
88692: LD_INT 1
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 3
88701: NEG
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 3
88712: NEG
88713: PUSH
88714: LD_INT 1
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88753: LD_ADDR_VAR 0 47
88757: PUSH
88758: LD_INT 0
88760: PUSH
88761: LD_INT 0
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: PUSH
88768: LD_INT 0
88770: PUSH
88771: LD_INT 1
88773: NEG
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: PUSH
88779: LD_INT 1
88781: PUSH
88782: LD_INT 0
88784: PUSH
88785: EMPTY
88786: LIST
88787: LIST
88788: PUSH
88789: LD_INT 1
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: EMPTY
88796: LIST
88797: LIST
88798: PUSH
88799: LD_INT 0
88801: PUSH
88802: LD_INT 1
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: PUSH
88809: LD_INT 1
88811: NEG
88812: PUSH
88813: LD_INT 0
88815: PUSH
88816: EMPTY
88817: LIST
88818: LIST
88819: PUSH
88820: LD_INT 1
88822: NEG
88823: PUSH
88824: LD_INT 1
88826: NEG
88827: PUSH
88828: EMPTY
88829: LIST
88830: LIST
88831: PUSH
88832: LD_INT 1
88834: NEG
88835: PUSH
88836: LD_INT 2
88838: NEG
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 0
88846: PUSH
88847: LD_INT 2
88849: NEG
88850: PUSH
88851: EMPTY
88852: LIST
88853: LIST
88854: PUSH
88855: LD_INT 1
88857: PUSH
88858: LD_INT 1
88860: NEG
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: PUSH
88866: LD_INT 2
88868: NEG
88869: PUSH
88870: LD_INT 1
88872: NEG
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: LD_INT 2
88880: NEG
88881: PUSH
88882: LD_INT 2
88884: NEG
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: EMPTY
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88904: LD_ADDR_VAR 0 48
88908: PUSH
88909: LD_INT 0
88911: PUSH
88912: LD_INT 0
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: LD_INT 0
88921: PUSH
88922: LD_INT 1
88924: NEG
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PUSH
88930: LD_INT 1
88932: PUSH
88933: LD_INT 0
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 1
88942: PUSH
88943: LD_INT 1
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 0
88952: PUSH
88953: LD_INT 1
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 1
88962: NEG
88963: PUSH
88964: LD_INT 0
88966: PUSH
88967: EMPTY
88968: LIST
88969: LIST
88970: PUSH
88971: LD_INT 1
88973: NEG
88974: PUSH
88975: LD_INT 1
88977: NEG
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PUSH
88983: LD_INT 1
88985: NEG
88986: PUSH
88987: LD_INT 2
88989: NEG
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 0
88997: PUSH
88998: LD_INT 2
89000: NEG
89001: PUSH
89002: EMPTY
89003: LIST
89004: LIST
89005: PUSH
89006: LD_INT 1
89008: PUSH
89009: LD_INT 1
89011: NEG
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: PUSH
89017: LD_INT 2
89019: PUSH
89020: LD_INT 0
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 2
89029: PUSH
89030: LD_INT 1
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: LIST
89041: LIST
89042: LIST
89043: LIST
89044: LIST
89045: LIST
89046: LIST
89047: LIST
89048: LIST
89049: LIST
89050: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89051: LD_ADDR_VAR 0 49
89055: PUSH
89056: LD_INT 0
89058: PUSH
89059: LD_INT 0
89061: PUSH
89062: EMPTY
89063: LIST
89064: LIST
89065: PUSH
89066: LD_INT 0
89068: PUSH
89069: LD_INT 1
89071: NEG
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 1
89079: PUSH
89080: LD_INT 0
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 1
89089: PUSH
89090: LD_INT 1
89092: PUSH
89093: EMPTY
89094: LIST
89095: LIST
89096: PUSH
89097: LD_INT 0
89099: PUSH
89100: LD_INT 1
89102: PUSH
89103: EMPTY
89104: LIST
89105: LIST
89106: PUSH
89107: LD_INT 1
89109: NEG
89110: PUSH
89111: LD_INT 0
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PUSH
89118: LD_INT 1
89120: NEG
89121: PUSH
89122: LD_INT 1
89124: NEG
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: LD_INT 1
89132: PUSH
89133: LD_INT 1
89135: NEG
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 2
89143: PUSH
89144: LD_INT 0
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: PUSH
89151: LD_INT 2
89153: PUSH
89154: LD_INT 1
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 2
89163: PUSH
89164: LD_INT 2
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 1
89173: PUSH
89174: LD_INT 2
89176: PUSH
89177: EMPTY
89178: LIST
89179: LIST
89180: PUSH
89181: EMPTY
89182: LIST
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89195: LD_ADDR_VAR 0 50
89199: PUSH
89200: LD_INT 0
89202: PUSH
89203: LD_INT 0
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: LD_INT 0
89212: PUSH
89213: LD_INT 1
89215: NEG
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: PUSH
89221: LD_INT 1
89223: PUSH
89224: LD_INT 0
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: PUSH
89231: LD_INT 1
89233: PUSH
89234: LD_INT 1
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: PUSH
89241: LD_INT 0
89243: PUSH
89244: LD_INT 1
89246: PUSH
89247: EMPTY
89248: LIST
89249: LIST
89250: PUSH
89251: LD_INT 1
89253: NEG
89254: PUSH
89255: LD_INT 0
89257: PUSH
89258: EMPTY
89259: LIST
89260: LIST
89261: PUSH
89262: LD_INT 1
89264: NEG
89265: PUSH
89266: LD_INT 1
89268: NEG
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: PUSH
89274: LD_INT 2
89276: PUSH
89277: LD_INT 1
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: PUSH
89284: LD_INT 2
89286: PUSH
89287: LD_INT 2
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: LD_INT 1
89296: PUSH
89297: LD_INT 2
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: PUSH
89304: LD_INT 0
89306: PUSH
89307: LD_INT 2
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: LD_INT 1
89316: NEG
89317: PUSH
89318: LD_INT 1
89320: PUSH
89321: EMPTY
89322: LIST
89323: LIST
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: LIST
89329: LIST
89330: LIST
89331: LIST
89332: LIST
89333: LIST
89334: LIST
89335: LIST
89336: LIST
89337: LIST
89338: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89339: LD_ADDR_VAR 0 51
89343: PUSH
89344: LD_INT 0
89346: PUSH
89347: LD_INT 0
89349: PUSH
89350: EMPTY
89351: LIST
89352: LIST
89353: PUSH
89354: LD_INT 0
89356: PUSH
89357: LD_INT 1
89359: NEG
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: LD_INT 1
89367: PUSH
89368: LD_INT 0
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 1
89377: PUSH
89378: LD_INT 1
89380: PUSH
89381: EMPTY
89382: LIST
89383: LIST
89384: PUSH
89385: LD_INT 0
89387: PUSH
89388: LD_INT 1
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: PUSH
89395: LD_INT 1
89397: NEG
89398: PUSH
89399: LD_INT 0
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 1
89408: NEG
89409: PUSH
89410: LD_INT 1
89412: NEG
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 1
89420: PUSH
89421: LD_INT 2
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 0
89430: PUSH
89431: LD_INT 2
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 1
89440: NEG
89441: PUSH
89442: LD_INT 1
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 2
89451: NEG
89452: PUSH
89453: LD_INT 0
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 2
89462: NEG
89463: PUSH
89464: LD_INT 1
89466: NEG
89467: PUSH
89468: EMPTY
89469: LIST
89470: LIST
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89486: LD_ADDR_VAR 0 52
89490: PUSH
89491: LD_INT 0
89493: PUSH
89494: LD_INT 0
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: PUSH
89501: LD_INT 0
89503: PUSH
89504: LD_INT 1
89506: NEG
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: PUSH
89512: LD_INT 1
89514: PUSH
89515: LD_INT 0
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 1
89524: PUSH
89525: LD_INT 1
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: LD_INT 0
89534: PUSH
89535: LD_INT 1
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: PUSH
89542: LD_INT 1
89544: NEG
89545: PUSH
89546: LD_INT 0
89548: PUSH
89549: EMPTY
89550: LIST
89551: LIST
89552: PUSH
89553: LD_INT 1
89555: NEG
89556: PUSH
89557: LD_INT 1
89559: NEG
89560: PUSH
89561: EMPTY
89562: LIST
89563: LIST
89564: PUSH
89565: LD_INT 1
89567: NEG
89568: PUSH
89569: LD_INT 2
89571: NEG
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: PUSH
89577: LD_INT 1
89579: NEG
89580: PUSH
89581: LD_INT 1
89583: PUSH
89584: EMPTY
89585: LIST
89586: LIST
89587: PUSH
89588: LD_INT 2
89590: NEG
89591: PUSH
89592: LD_INT 0
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 2
89601: NEG
89602: PUSH
89603: LD_INT 1
89605: NEG
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 2
89613: NEG
89614: PUSH
89615: LD_INT 2
89617: NEG
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: PUSH
89623: EMPTY
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89637: LD_ADDR_VAR 0 53
89641: PUSH
89642: LD_INT 0
89644: PUSH
89645: LD_INT 0
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 0
89654: PUSH
89655: LD_INT 1
89657: NEG
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 1
89665: PUSH
89666: LD_INT 0
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PUSH
89673: LD_INT 1
89675: PUSH
89676: LD_INT 1
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 0
89685: PUSH
89686: LD_INT 1
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: LD_INT 1
89695: NEG
89696: PUSH
89697: LD_INT 0
89699: PUSH
89700: EMPTY
89701: LIST
89702: LIST
89703: PUSH
89704: LD_INT 1
89706: NEG
89707: PUSH
89708: LD_INT 1
89710: NEG
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: PUSH
89716: LD_INT 1
89718: NEG
89719: PUSH
89720: LD_INT 2
89722: NEG
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 0
89730: PUSH
89731: LD_INT 2
89733: NEG
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 1
89741: PUSH
89742: LD_INT 1
89744: NEG
89745: PUSH
89746: EMPTY
89747: LIST
89748: LIST
89749: PUSH
89750: LD_INT 2
89752: PUSH
89753: LD_INT 0
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 2
89762: PUSH
89763: LD_INT 1
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 2
89772: PUSH
89773: LD_INT 2
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 1
89782: PUSH
89783: LD_INT 2
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 0
89792: PUSH
89793: LD_INT 2
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 1
89802: NEG
89803: PUSH
89804: LD_INT 1
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 2
89813: NEG
89814: PUSH
89815: LD_INT 0
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 2
89824: NEG
89825: PUSH
89826: LD_INT 1
89828: NEG
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: LD_INT 2
89836: NEG
89837: PUSH
89838: LD_INT 2
89840: NEG
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: EMPTY
89847: LIST
89848: LIST
89849: LIST
89850: LIST
89851: LIST
89852: LIST
89853: LIST
89854: LIST
89855: LIST
89856: LIST
89857: LIST
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89867: LD_ADDR_VAR 0 54
89871: PUSH
89872: LD_INT 0
89874: PUSH
89875: LD_INT 0
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: PUSH
89882: LD_INT 0
89884: PUSH
89885: LD_INT 1
89887: NEG
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: PUSH
89893: LD_INT 1
89895: PUSH
89896: LD_INT 0
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 1
89905: PUSH
89906: LD_INT 1
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 0
89915: PUSH
89916: LD_INT 1
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: PUSH
89923: LD_INT 1
89925: NEG
89926: PUSH
89927: LD_INT 0
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 1
89936: NEG
89937: PUSH
89938: LD_INT 1
89940: NEG
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: LD_INT 1
89948: NEG
89949: PUSH
89950: LD_INT 2
89952: NEG
89953: PUSH
89954: EMPTY
89955: LIST
89956: LIST
89957: PUSH
89958: LD_INT 0
89960: PUSH
89961: LD_INT 2
89963: NEG
89964: PUSH
89965: EMPTY
89966: LIST
89967: LIST
89968: PUSH
89969: LD_INT 1
89971: PUSH
89972: LD_INT 1
89974: NEG
89975: PUSH
89976: EMPTY
89977: LIST
89978: LIST
89979: PUSH
89980: LD_INT 2
89982: PUSH
89983: LD_INT 0
89985: PUSH
89986: EMPTY
89987: LIST
89988: LIST
89989: PUSH
89990: LD_INT 2
89992: PUSH
89993: LD_INT 1
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 2
90002: PUSH
90003: LD_INT 2
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 1
90012: PUSH
90013: LD_INT 2
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 0
90022: PUSH
90023: LD_INT 2
90025: PUSH
90026: EMPTY
90027: LIST
90028: LIST
90029: PUSH
90030: LD_INT 1
90032: NEG
90033: PUSH
90034: LD_INT 1
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 2
90043: NEG
90044: PUSH
90045: LD_INT 0
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 2
90054: NEG
90055: PUSH
90056: LD_INT 1
90058: NEG
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: LD_INT 2
90066: NEG
90067: PUSH
90068: LD_INT 2
90070: NEG
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90097: LD_ADDR_VAR 0 55
90101: PUSH
90102: LD_INT 0
90104: PUSH
90105: LD_INT 0
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 0
90114: PUSH
90115: LD_INT 1
90117: NEG
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: PUSH
90123: LD_INT 1
90125: PUSH
90126: LD_INT 0
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 1
90135: PUSH
90136: LD_INT 1
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 0
90145: PUSH
90146: LD_INT 1
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 1
90155: NEG
90156: PUSH
90157: LD_INT 0
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 1
90166: NEG
90167: PUSH
90168: LD_INT 1
90170: NEG
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: LD_INT 1
90178: NEG
90179: PUSH
90180: LD_INT 2
90182: NEG
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 0
90190: PUSH
90191: LD_INT 2
90193: NEG
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: PUSH
90199: LD_INT 1
90201: PUSH
90202: LD_INT 1
90204: NEG
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: PUSH
90210: LD_INT 2
90212: PUSH
90213: LD_INT 0
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PUSH
90220: LD_INT 2
90222: PUSH
90223: LD_INT 1
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: PUSH
90230: LD_INT 2
90232: PUSH
90233: LD_INT 2
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 1
90242: PUSH
90243: LD_INT 2
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 0
90252: PUSH
90253: LD_INT 2
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PUSH
90260: LD_INT 1
90262: NEG
90263: PUSH
90264: LD_INT 1
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: PUSH
90271: LD_INT 2
90273: NEG
90274: PUSH
90275: LD_INT 0
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: PUSH
90282: LD_INT 2
90284: NEG
90285: PUSH
90286: LD_INT 1
90288: NEG
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: LD_INT 2
90296: NEG
90297: PUSH
90298: LD_INT 2
90300: NEG
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90327: LD_ADDR_VAR 0 56
90331: PUSH
90332: LD_INT 0
90334: PUSH
90335: LD_INT 0
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: PUSH
90342: LD_INT 0
90344: PUSH
90345: LD_INT 1
90347: NEG
90348: PUSH
90349: EMPTY
90350: LIST
90351: LIST
90352: PUSH
90353: LD_INT 1
90355: PUSH
90356: LD_INT 0
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: LD_INT 1
90365: PUSH
90366: LD_INT 1
90368: PUSH
90369: EMPTY
90370: LIST
90371: LIST
90372: PUSH
90373: LD_INT 0
90375: PUSH
90376: LD_INT 1
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 1
90385: NEG
90386: PUSH
90387: LD_INT 0
90389: PUSH
90390: EMPTY
90391: LIST
90392: LIST
90393: PUSH
90394: LD_INT 1
90396: NEG
90397: PUSH
90398: LD_INT 1
90400: NEG
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: LD_INT 1
90408: NEG
90409: PUSH
90410: LD_INT 2
90412: NEG
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 0
90420: PUSH
90421: LD_INT 2
90423: NEG
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: PUSH
90429: LD_INT 1
90431: PUSH
90432: LD_INT 1
90434: NEG
90435: PUSH
90436: EMPTY
90437: LIST
90438: LIST
90439: PUSH
90440: LD_INT 2
90442: PUSH
90443: LD_INT 0
90445: PUSH
90446: EMPTY
90447: LIST
90448: LIST
90449: PUSH
90450: LD_INT 2
90452: PUSH
90453: LD_INT 1
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: PUSH
90460: LD_INT 2
90462: PUSH
90463: LD_INT 2
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 1
90472: PUSH
90473: LD_INT 2
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 0
90482: PUSH
90483: LD_INT 2
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: NEG
90493: PUSH
90494: LD_INT 1
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: LD_INT 2
90503: NEG
90504: PUSH
90505: LD_INT 0
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 2
90514: NEG
90515: PUSH
90516: LD_INT 1
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 2
90526: NEG
90527: PUSH
90528: LD_INT 2
90530: NEG
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: LIST
90540: LIST
90541: LIST
90542: LIST
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: LIST
90548: LIST
90549: LIST
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90557: LD_ADDR_VAR 0 57
90561: PUSH
90562: LD_INT 0
90564: PUSH
90565: LD_INT 0
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: PUSH
90572: LD_INT 0
90574: PUSH
90575: LD_INT 1
90577: NEG
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: LD_INT 1
90585: PUSH
90586: LD_INT 0
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: PUSH
90593: LD_INT 1
90595: PUSH
90596: LD_INT 1
90598: PUSH
90599: EMPTY
90600: LIST
90601: LIST
90602: PUSH
90603: LD_INT 0
90605: PUSH
90606: LD_INT 1
90608: PUSH
90609: EMPTY
90610: LIST
90611: LIST
90612: PUSH
90613: LD_INT 1
90615: NEG
90616: PUSH
90617: LD_INT 0
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 1
90626: NEG
90627: PUSH
90628: LD_INT 1
90630: NEG
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 1
90638: NEG
90639: PUSH
90640: LD_INT 2
90642: NEG
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PUSH
90648: LD_INT 0
90650: PUSH
90651: LD_INT 2
90653: NEG
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 1
90661: PUSH
90662: LD_INT 1
90664: NEG
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: PUSH
90670: LD_INT 2
90672: PUSH
90673: LD_INT 0
90675: PUSH
90676: EMPTY
90677: LIST
90678: LIST
90679: PUSH
90680: LD_INT 2
90682: PUSH
90683: LD_INT 1
90685: PUSH
90686: EMPTY
90687: LIST
90688: LIST
90689: PUSH
90690: LD_INT 2
90692: PUSH
90693: LD_INT 2
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 1
90702: PUSH
90703: LD_INT 2
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PUSH
90710: LD_INT 0
90712: PUSH
90713: LD_INT 2
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: NEG
90723: PUSH
90724: LD_INT 1
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 2
90733: NEG
90734: PUSH
90735: LD_INT 0
90737: PUSH
90738: EMPTY
90739: LIST
90740: LIST
90741: PUSH
90742: LD_INT 2
90744: NEG
90745: PUSH
90746: LD_INT 1
90748: NEG
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: LD_INT 2
90756: NEG
90757: PUSH
90758: LD_INT 2
90760: NEG
90761: PUSH
90762: EMPTY
90763: LIST
90764: LIST
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: LIST
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90787: LD_ADDR_VAR 0 58
90791: PUSH
90792: LD_INT 0
90794: PUSH
90795: LD_INT 0
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: LD_INT 0
90804: PUSH
90805: LD_INT 1
90807: NEG
90808: PUSH
90809: EMPTY
90810: LIST
90811: LIST
90812: PUSH
90813: LD_INT 1
90815: PUSH
90816: LD_INT 0
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 1
90825: PUSH
90826: LD_INT 1
90828: PUSH
90829: EMPTY
90830: LIST
90831: LIST
90832: PUSH
90833: LD_INT 0
90835: PUSH
90836: LD_INT 1
90838: PUSH
90839: EMPTY
90840: LIST
90841: LIST
90842: PUSH
90843: LD_INT 1
90845: NEG
90846: PUSH
90847: LD_INT 0
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: LD_INT 1
90856: NEG
90857: PUSH
90858: LD_INT 1
90860: NEG
90861: PUSH
90862: EMPTY
90863: LIST
90864: LIST
90865: PUSH
90866: LD_INT 1
90868: NEG
90869: PUSH
90870: LD_INT 2
90872: NEG
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: PUSH
90878: LD_INT 0
90880: PUSH
90881: LD_INT 2
90883: NEG
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: LD_INT 1
90891: PUSH
90892: LD_INT 1
90894: NEG
90895: PUSH
90896: EMPTY
90897: LIST
90898: LIST
90899: PUSH
90900: LD_INT 2
90902: PUSH
90903: LD_INT 0
90905: PUSH
90906: EMPTY
90907: LIST
90908: LIST
90909: PUSH
90910: LD_INT 2
90912: PUSH
90913: LD_INT 1
90915: PUSH
90916: EMPTY
90917: LIST
90918: LIST
90919: PUSH
90920: LD_INT 2
90922: PUSH
90923: LD_INT 2
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: PUSH
90930: LD_INT 1
90932: PUSH
90933: LD_INT 2
90935: PUSH
90936: EMPTY
90937: LIST
90938: LIST
90939: PUSH
90940: LD_INT 0
90942: PUSH
90943: LD_INT 2
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PUSH
90950: LD_INT 1
90952: NEG
90953: PUSH
90954: LD_INT 1
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: LD_INT 2
90963: NEG
90964: PUSH
90965: LD_INT 0
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: LD_INT 2
90974: NEG
90975: PUSH
90976: LD_INT 1
90978: NEG
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: PUSH
90984: LD_INT 2
90986: NEG
90987: PUSH
90988: LD_INT 2
90990: NEG
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91017: LD_ADDR_VAR 0 59
91021: PUSH
91022: LD_INT 0
91024: PUSH
91025: LD_INT 0
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: PUSH
91032: LD_INT 0
91034: PUSH
91035: LD_INT 1
91037: NEG
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PUSH
91043: LD_INT 1
91045: PUSH
91046: LD_INT 0
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 1
91055: PUSH
91056: LD_INT 1
91058: PUSH
91059: EMPTY
91060: LIST
91061: LIST
91062: PUSH
91063: LD_INT 0
91065: PUSH
91066: LD_INT 1
91068: PUSH
91069: EMPTY
91070: LIST
91071: LIST
91072: PUSH
91073: LD_INT 1
91075: NEG
91076: PUSH
91077: LD_INT 0
91079: PUSH
91080: EMPTY
91081: LIST
91082: LIST
91083: PUSH
91084: LD_INT 1
91086: NEG
91087: PUSH
91088: LD_INT 1
91090: NEG
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91105: LD_ADDR_VAR 0 60
91109: PUSH
91110: LD_INT 0
91112: PUSH
91113: LD_INT 0
91115: PUSH
91116: EMPTY
91117: LIST
91118: LIST
91119: PUSH
91120: LD_INT 0
91122: PUSH
91123: LD_INT 1
91125: NEG
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 1
91133: PUSH
91134: LD_INT 0
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 1
91143: PUSH
91144: LD_INT 1
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: PUSH
91151: LD_INT 0
91153: PUSH
91154: LD_INT 1
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: PUSH
91161: LD_INT 1
91163: NEG
91164: PUSH
91165: LD_INT 0
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: PUSH
91172: LD_INT 1
91174: NEG
91175: PUSH
91176: LD_INT 1
91178: NEG
91179: PUSH
91180: EMPTY
91181: LIST
91182: LIST
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91193: LD_ADDR_VAR 0 61
91197: PUSH
91198: LD_INT 0
91200: PUSH
91201: LD_INT 0
91203: PUSH
91204: EMPTY
91205: LIST
91206: LIST
91207: PUSH
91208: LD_INT 0
91210: PUSH
91211: LD_INT 1
91213: NEG
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: LD_INT 1
91221: PUSH
91222: LD_INT 0
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: PUSH
91229: LD_INT 1
91231: PUSH
91232: LD_INT 1
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 0
91241: PUSH
91242: LD_INT 1
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: PUSH
91249: LD_INT 1
91251: NEG
91252: PUSH
91253: LD_INT 0
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 1
91262: NEG
91263: PUSH
91264: LD_INT 1
91266: NEG
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91281: LD_ADDR_VAR 0 62
91285: PUSH
91286: LD_INT 0
91288: PUSH
91289: LD_INT 0
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: PUSH
91296: LD_INT 0
91298: PUSH
91299: LD_INT 1
91301: NEG
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 1
91309: PUSH
91310: LD_INT 0
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: PUSH
91317: LD_INT 1
91319: PUSH
91320: LD_INT 1
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 0
91329: PUSH
91330: LD_INT 1
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 1
91339: NEG
91340: PUSH
91341: LD_INT 0
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: LD_INT 1
91350: NEG
91351: PUSH
91352: LD_INT 1
91354: NEG
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: EMPTY
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: LIST
91368: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91369: LD_ADDR_VAR 0 63
91373: PUSH
91374: LD_INT 0
91376: PUSH
91377: LD_INT 0
91379: PUSH
91380: EMPTY
91381: LIST
91382: LIST
91383: PUSH
91384: LD_INT 0
91386: PUSH
91387: LD_INT 1
91389: NEG
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PUSH
91395: LD_INT 1
91397: PUSH
91398: LD_INT 0
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: PUSH
91405: LD_INT 1
91407: PUSH
91408: LD_INT 1
91410: PUSH
91411: EMPTY
91412: LIST
91413: LIST
91414: PUSH
91415: LD_INT 0
91417: PUSH
91418: LD_INT 1
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: PUSH
91425: LD_INT 1
91427: NEG
91428: PUSH
91429: LD_INT 0
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PUSH
91436: LD_INT 1
91438: NEG
91439: PUSH
91440: LD_INT 1
91442: NEG
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91457: LD_ADDR_VAR 0 64
91461: PUSH
91462: LD_INT 0
91464: PUSH
91465: LD_INT 0
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 0
91474: PUSH
91475: LD_INT 1
91477: NEG
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 1
91485: PUSH
91486: LD_INT 0
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 1
91495: PUSH
91496: LD_INT 1
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: PUSH
91503: LD_INT 0
91505: PUSH
91506: LD_INT 1
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 1
91515: NEG
91516: PUSH
91517: LD_INT 0
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: LD_INT 1
91526: NEG
91527: PUSH
91528: LD_INT 1
91530: NEG
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: ST_TO_ADDR
// end ; 1 :
91545: GO 97442
91547: LD_INT 1
91549: DOUBLE
91550: EQUAL
91551: IFTRUE 91555
91553: GO 94178
91555: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91556: LD_ADDR_VAR 0 11
91560: PUSH
91561: LD_INT 1
91563: NEG
91564: PUSH
91565: LD_INT 3
91567: NEG
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: PUSH
91573: LD_INT 0
91575: PUSH
91576: LD_INT 3
91578: NEG
91579: PUSH
91580: EMPTY
91581: LIST
91582: LIST
91583: PUSH
91584: LD_INT 1
91586: PUSH
91587: LD_INT 2
91589: NEG
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: LIST
91599: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91600: LD_ADDR_VAR 0 12
91604: PUSH
91605: LD_INT 2
91607: PUSH
91608: LD_INT 1
91610: NEG
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: PUSH
91616: LD_INT 3
91618: PUSH
91619: LD_INT 0
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 3
91628: PUSH
91629: LD_INT 1
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: LIST
91640: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91641: LD_ADDR_VAR 0 13
91645: PUSH
91646: LD_INT 3
91648: PUSH
91649: LD_INT 2
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: LD_INT 3
91658: PUSH
91659: LD_INT 3
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: PUSH
91666: LD_INT 2
91668: PUSH
91669: LD_INT 3
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: EMPTY
91677: LIST
91678: LIST
91679: LIST
91680: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91681: LD_ADDR_VAR 0 14
91685: PUSH
91686: LD_INT 1
91688: PUSH
91689: LD_INT 3
91691: PUSH
91692: EMPTY
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 0
91698: PUSH
91699: LD_INT 3
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: LD_INT 1
91708: NEG
91709: PUSH
91710: LD_INT 2
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: LIST
91721: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91722: LD_ADDR_VAR 0 15
91726: PUSH
91727: LD_INT 2
91729: NEG
91730: PUSH
91731: LD_INT 1
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: PUSH
91738: LD_INT 3
91740: NEG
91741: PUSH
91742: LD_INT 0
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PUSH
91749: LD_INT 3
91751: NEG
91752: PUSH
91753: LD_INT 1
91755: NEG
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: LIST
91765: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91766: LD_ADDR_VAR 0 16
91770: PUSH
91771: LD_INT 2
91773: NEG
91774: PUSH
91775: LD_INT 3
91777: NEG
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: PUSH
91783: LD_INT 3
91785: NEG
91786: PUSH
91787: LD_INT 2
91789: NEG
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 3
91797: NEG
91798: PUSH
91799: LD_INT 3
91801: NEG
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: LIST
91811: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91812: LD_ADDR_VAR 0 17
91816: PUSH
91817: LD_INT 1
91819: NEG
91820: PUSH
91821: LD_INT 3
91823: NEG
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: PUSH
91829: LD_INT 0
91831: PUSH
91832: LD_INT 3
91834: NEG
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 1
91842: PUSH
91843: LD_INT 2
91845: NEG
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: LIST
91855: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91856: LD_ADDR_VAR 0 18
91860: PUSH
91861: LD_INT 2
91863: PUSH
91864: LD_INT 1
91866: NEG
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 3
91874: PUSH
91875: LD_INT 0
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 3
91884: PUSH
91885: LD_INT 1
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: LIST
91896: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91897: LD_ADDR_VAR 0 19
91901: PUSH
91902: LD_INT 3
91904: PUSH
91905: LD_INT 2
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: PUSH
91912: LD_INT 3
91914: PUSH
91915: LD_INT 3
91917: PUSH
91918: EMPTY
91919: LIST
91920: LIST
91921: PUSH
91922: LD_INT 2
91924: PUSH
91925: LD_INT 3
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: EMPTY
91933: LIST
91934: LIST
91935: LIST
91936: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91937: LD_ADDR_VAR 0 20
91941: PUSH
91942: LD_INT 1
91944: PUSH
91945: LD_INT 3
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 0
91954: PUSH
91955: LD_INT 3
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 1
91964: NEG
91965: PUSH
91966: LD_INT 2
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: LIST
91977: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91978: LD_ADDR_VAR 0 21
91982: PUSH
91983: LD_INT 2
91985: NEG
91986: PUSH
91987: LD_INT 1
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 3
91996: NEG
91997: PUSH
91998: LD_INT 0
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: LD_INT 3
92007: NEG
92008: PUSH
92009: LD_INT 1
92011: NEG
92012: PUSH
92013: EMPTY
92014: LIST
92015: LIST
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: LIST
92021: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92022: LD_ADDR_VAR 0 22
92026: PUSH
92027: LD_INT 2
92029: NEG
92030: PUSH
92031: LD_INT 3
92033: NEG
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: PUSH
92039: LD_INT 3
92041: NEG
92042: PUSH
92043: LD_INT 2
92045: NEG
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 3
92053: NEG
92054: PUSH
92055: LD_INT 3
92057: NEG
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: LIST
92067: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92068: LD_ADDR_VAR 0 23
92072: PUSH
92073: LD_INT 0
92075: PUSH
92076: LD_INT 3
92078: NEG
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: LD_INT 1
92086: NEG
92087: PUSH
92088: LD_INT 4
92090: NEG
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 1
92098: PUSH
92099: LD_INT 3
92101: NEG
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: EMPTY
92108: LIST
92109: LIST
92110: LIST
92111: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92112: LD_ADDR_VAR 0 24
92116: PUSH
92117: LD_INT 3
92119: PUSH
92120: LD_INT 0
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 3
92129: PUSH
92130: LD_INT 1
92132: NEG
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 4
92140: PUSH
92141: LD_INT 1
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: PUSH
92148: EMPTY
92149: LIST
92150: LIST
92151: LIST
92152: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92153: LD_ADDR_VAR 0 25
92157: PUSH
92158: LD_INT 3
92160: PUSH
92161: LD_INT 3
92163: PUSH
92164: EMPTY
92165: LIST
92166: LIST
92167: PUSH
92168: LD_INT 4
92170: PUSH
92171: LD_INT 3
92173: PUSH
92174: EMPTY
92175: LIST
92176: LIST
92177: PUSH
92178: LD_INT 3
92180: PUSH
92181: LD_INT 4
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: LIST
92192: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92193: LD_ADDR_VAR 0 26
92197: PUSH
92198: LD_INT 0
92200: PUSH
92201: LD_INT 3
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: PUSH
92208: LD_INT 1
92210: PUSH
92211: LD_INT 4
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 1
92220: NEG
92221: PUSH
92222: LD_INT 3
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: LIST
92233: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92234: LD_ADDR_VAR 0 27
92238: PUSH
92239: LD_INT 3
92241: NEG
92242: PUSH
92243: LD_INT 0
92245: PUSH
92246: EMPTY
92247: LIST
92248: LIST
92249: PUSH
92250: LD_INT 3
92252: NEG
92253: PUSH
92254: LD_INT 1
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: PUSH
92261: LD_INT 4
92263: NEG
92264: PUSH
92265: LD_INT 1
92267: NEG
92268: PUSH
92269: EMPTY
92270: LIST
92271: LIST
92272: PUSH
92273: EMPTY
92274: LIST
92275: LIST
92276: LIST
92277: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92278: LD_ADDR_VAR 0 28
92282: PUSH
92283: LD_INT 3
92285: NEG
92286: PUSH
92287: LD_INT 3
92289: NEG
92290: PUSH
92291: EMPTY
92292: LIST
92293: LIST
92294: PUSH
92295: LD_INT 3
92297: NEG
92298: PUSH
92299: LD_INT 4
92301: NEG
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: LD_INT 4
92309: NEG
92310: PUSH
92311: LD_INT 3
92313: NEG
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: LIST
92323: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92324: LD_ADDR_VAR 0 29
92328: PUSH
92329: LD_INT 1
92331: NEG
92332: PUSH
92333: LD_INT 3
92335: NEG
92336: PUSH
92337: EMPTY
92338: LIST
92339: LIST
92340: PUSH
92341: LD_INT 0
92343: PUSH
92344: LD_INT 3
92346: NEG
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PUSH
92352: LD_INT 1
92354: PUSH
92355: LD_INT 2
92357: NEG
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: LD_INT 1
92365: NEG
92366: PUSH
92367: LD_INT 4
92369: NEG
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PUSH
92375: LD_INT 0
92377: PUSH
92378: LD_INT 4
92380: NEG
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: PUSH
92386: LD_INT 1
92388: PUSH
92389: LD_INT 3
92391: NEG
92392: PUSH
92393: EMPTY
92394: LIST
92395: LIST
92396: PUSH
92397: LD_INT 1
92399: NEG
92400: PUSH
92401: LD_INT 5
92403: NEG
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: PUSH
92409: LD_INT 0
92411: PUSH
92412: LD_INT 5
92414: NEG
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: PUSH
92420: LD_INT 1
92422: PUSH
92423: LD_INT 4
92425: NEG
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 1
92433: NEG
92434: PUSH
92435: LD_INT 6
92437: NEG
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: LD_INT 0
92445: PUSH
92446: LD_INT 6
92448: NEG
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 1
92456: PUSH
92457: LD_INT 5
92459: NEG
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: EMPTY
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: LIST
92477: LIST
92478: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92479: LD_ADDR_VAR 0 30
92483: PUSH
92484: LD_INT 2
92486: PUSH
92487: LD_INT 1
92489: NEG
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: PUSH
92495: LD_INT 3
92497: PUSH
92498: LD_INT 0
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: PUSH
92505: LD_INT 3
92507: PUSH
92508: LD_INT 1
92510: PUSH
92511: EMPTY
92512: LIST
92513: LIST
92514: PUSH
92515: LD_INT 3
92517: PUSH
92518: LD_INT 1
92520: NEG
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: PUSH
92526: LD_INT 4
92528: PUSH
92529: LD_INT 0
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PUSH
92536: LD_INT 4
92538: PUSH
92539: LD_INT 1
92541: PUSH
92542: EMPTY
92543: LIST
92544: LIST
92545: PUSH
92546: LD_INT 4
92548: PUSH
92549: LD_INT 1
92551: NEG
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PUSH
92557: LD_INT 5
92559: PUSH
92560: LD_INT 0
92562: PUSH
92563: EMPTY
92564: LIST
92565: LIST
92566: PUSH
92567: LD_INT 5
92569: PUSH
92570: LD_INT 1
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PUSH
92577: LD_INT 5
92579: PUSH
92580: LD_INT 1
92582: NEG
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 6
92590: PUSH
92591: LD_INT 0
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 6
92600: PUSH
92601: LD_INT 1
92603: PUSH
92604: EMPTY
92605: LIST
92606: LIST
92607: PUSH
92608: EMPTY
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: LIST
92621: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92622: LD_ADDR_VAR 0 31
92626: PUSH
92627: LD_INT 3
92629: PUSH
92630: LD_INT 2
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: PUSH
92637: LD_INT 3
92639: PUSH
92640: LD_INT 3
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: PUSH
92647: LD_INT 2
92649: PUSH
92650: LD_INT 3
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: LD_INT 4
92659: PUSH
92660: LD_INT 3
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 4
92669: PUSH
92670: LD_INT 4
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 3
92679: PUSH
92680: LD_INT 4
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 5
92689: PUSH
92690: LD_INT 4
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: LD_INT 5
92699: PUSH
92700: LD_INT 5
92702: PUSH
92703: EMPTY
92704: LIST
92705: LIST
92706: PUSH
92707: LD_INT 4
92709: PUSH
92710: LD_INT 5
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PUSH
92717: LD_INT 6
92719: PUSH
92720: LD_INT 5
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: PUSH
92727: LD_INT 6
92729: PUSH
92730: LD_INT 6
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 5
92739: PUSH
92740: LD_INT 6
92742: PUSH
92743: EMPTY
92744: LIST
92745: LIST
92746: PUSH
92747: EMPTY
92748: LIST
92749: LIST
92750: LIST
92751: LIST
92752: LIST
92753: LIST
92754: LIST
92755: LIST
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92761: LD_ADDR_VAR 0 32
92765: PUSH
92766: LD_INT 1
92768: PUSH
92769: LD_INT 3
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 0
92778: PUSH
92779: LD_INT 3
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: LD_INT 1
92788: NEG
92789: PUSH
92790: LD_INT 2
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: PUSH
92797: LD_INT 1
92799: PUSH
92800: LD_INT 4
92802: PUSH
92803: EMPTY
92804: LIST
92805: LIST
92806: PUSH
92807: LD_INT 0
92809: PUSH
92810: LD_INT 4
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: LD_INT 1
92819: NEG
92820: PUSH
92821: LD_INT 3
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 1
92830: PUSH
92831: LD_INT 5
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 0
92840: PUSH
92841: LD_INT 5
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: LD_INT 1
92850: NEG
92851: PUSH
92852: LD_INT 4
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 1
92861: PUSH
92862: LD_INT 6
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PUSH
92869: LD_INT 0
92871: PUSH
92872: LD_INT 6
92874: PUSH
92875: EMPTY
92876: LIST
92877: LIST
92878: PUSH
92879: LD_INT 1
92881: NEG
92882: PUSH
92883: LD_INT 5
92885: PUSH
92886: EMPTY
92887: LIST
92888: LIST
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92904: LD_ADDR_VAR 0 33
92908: PUSH
92909: LD_INT 2
92911: NEG
92912: PUSH
92913: LD_INT 1
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PUSH
92920: LD_INT 3
92922: NEG
92923: PUSH
92924: LD_INT 0
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 3
92933: NEG
92934: PUSH
92935: LD_INT 1
92937: NEG
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 3
92945: NEG
92946: PUSH
92947: LD_INT 1
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: PUSH
92954: LD_INT 4
92956: NEG
92957: PUSH
92958: LD_INT 0
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 4
92967: NEG
92968: PUSH
92969: LD_INT 1
92971: NEG
92972: PUSH
92973: EMPTY
92974: LIST
92975: LIST
92976: PUSH
92977: LD_INT 4
92979: NEG
92980: PUSH
92981: LD_INT 1
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 5
92990: NEG
92991: PUSH
92992: LD_INT 0
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 5
93001: NEG
93002: PUSH
93003: LD_INT 1
93005: NEG
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 5
93013: NEG
93014: PUSH
93015: LD_INT 1
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 6
93024: NEG
93025: PUSH
93026: LD_INT 0
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 6
93035: NEG
93036: PUSH
93037: LD_INT 1
93039: NEG
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93059: LD_ADDR_VAR 0 34
93063: PUSH
93064: LD_INT 2
93066: NEG
93067: PUSH
93068: LD_INT 3
93070: NEG
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 3
93078: NEG
93079: PUSH
93080: LD_INT 2
93082: NEG
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PUSH
93088: LD_INT 3
93090: NEG
93091: PUSH
93092: LD_INT 3
93094: NEG
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 3
93102: NEG
93103: PUSH
93104: LD_INT 4
93106: NEG
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: PUSH
93112: LD_INT 4
93114: NEG
93115: PUSH
93116: LD_INT 3
93118: NEG
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PUSH
93124: LD_INT 4
93126: NEG
93127: PUSH
93128: LD_INT 4
93130: NEG
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 4
93138: NEG
93139: PUSH
93140: LD_INT 5
93142: NEG
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 5
93150: NEG
93151: PUSH
93152: LD_INT 4
93154: NEG
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 5
93162: NEG
93163: PUSH
93164: LD_INT 5
93166: NEG
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PUSH
93172: LD_INT 5
93174: NEG
93175: PUSH
93176: LD_INT 6
93178: NEG
93179: PUSH
93180: EMPTY
93181: LIST
93182: LIST
93183: PUSH
93184: LD_INT 6
93186: NEG
93187: PUSH
93188: LD_INT 5
93190: NEG
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: LD_INT 6
93198: NEG
93199: PUSH
93200: LD_INT 6
93202: NEG
93203: PUSH
93204: EMPTY
93205: LIST
93206: LIST
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93222: LD_ADDR_VAR 0 41
93226: PUSH
93227: LD_INT 0
93229: PUSH
93230: LD_INT 2
93232: NEG
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 1
93240: NEG
93241: PUSH
93242: LD_INT 3
93244: NEG
93245: PUSH
93246: EMPTY
93247: LIST
93248: LIST
93249: PUSH
93250: LD_INT 1
93252: PUSH
93253: LD_INT 2
93255: NEG
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: EMPTY
93262: LIST
93263: LIST
93264: LIST
93265: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93266: LD_ADDR_VAR 0 42
93270: PUSH
93271: LD_INT 2
93273: PUSH
93274: LD_INT 0
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: LD_INT 2
93283: PUSH
93284: LD_INT 1
93286: NEG
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: LD_INT 3
93294: PUSH
93295: LD_INT 1
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: LIST
93306: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93307: LD_ADDR_VAR 0 43
93311: PUSH
93312: LD_INT 2
93314: PUSH
93315: LD_INT 2
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: LD_INT 3
93324: PUSH
93325: LD_INT 2
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: LD_INT 2
93334: PUSH
93335: LD_INT 3
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: EMPTY
93343: LIST
93344: LIST
93345: LIST
93346: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93347: LD_ADDR_VAR 0 44
93351: PUSH
93352: LD_INT 0
93354: PUSH
93355: LD_INT 2
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: PUSH
93362: LD_INT 1
93364: PUSH
93365: LD_INT 3
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: PUSH
93372: LD_INT 1
93374: NEG
93375: PUSH
93376: LD_INT 2
93378: PUSH
93379: EMPTY
93380: LIST
93381: LIST
93382: PUSH
93383: EMPTY
93384: LIST
93385: LIST
93386: LIST
93387: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93388: LD_ADDR_VAR 0 45
93392: PUSH
93393: LD_INT 2
93395: NEG
93396: PUSH
93397: LD_INT 0
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 2
93406: NEG
93407: PUSH
93408: LD_INT 1
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: PUSH
93415: LD_INT 3
93417: NEG
93418: PUSH
93419: LD_INT 1
93421: NEG
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: LIST
93431: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93432: LD_ADDR_VAR 0 46
93436: PUSH
93437: LD_INT 2
93439: NEG
93440: PUSH
93441: LD_INT 2
93443: NEG
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: LD_INT 2
93451: NEG
93452: PUSH
93453: LD_INT 3
93455: NEG
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: LD_INT 3
93463: NEG
93464: PUSH
93465: LD_INT 2
93467: NEG
93468: PUSH
93469: EMPTY
93470: LIST
93471: LIST
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: LIST
93477: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93478: LD_ADDR_VAR 0 47
93482: PUSH
93483: LD_INT 2
93485: NEG
93486: PUSH
93487: LD_INT 3
93489: NEG
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 1
93497: NEG
93498: PUSH
93499: LD_INT 3
93501: NEG
93502: PUSH
93503: EMPTY
93504: LIST
93505: LIST
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93511: LD_ADDR_VAR 0 48
93515: PUSH
93516: LD_INT 1
93518: PUSH
93519: LD_INT 2
93521: NEG
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 2
93529: PUSH
93530: LD_INT 1
93532: NEG
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93542: LD_ADDR_VAR 0 49
93546: PUSH
93547: LD_INT 3
93549: PUSH
93550: LD_INT 1
93552: PUSH
93553: EMPTY
93554: LIST
93555: LIST
93556: PUSH
93557: LD_INT 3
93559: PUSH
93560: LD_INT 2
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93571: LD_ADDR_VAR 0 50
93575: PUSH
93576: LD_INT 2
93578: PUSH
93579: LD_INT 3
93581: PUSH
93582: EMPTY
93583: LIST
93584: LIST
93585: PUSH
93586: LD_INT 1
93588: PUSH
93589: LD_INT 3
93591: PUSH
93592: EMPTY
93593: LIST
93594: LIST
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93600: LD_ADDR_VAR 0 51
93604: PUSH
93605: LD_INT 1
93607: NEG
93608: PUSH
93609: LD_INT 2
93611: PUSH
93612: EMPTY
93613: LIST
93614: LIST
93615: PUSH
93616: LD_INT 2
93618: NEG
93619: PUSH
93620: LD_INT 1
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93631: LD_ADDR_VAR 0 52
93635: PUSH
93636: LD_INT 3
93638: NEG
93639: PUSH
93640: LD_INT 1
93642: NEG
93643: PUSH
93644: EMPTY
93645: LIST
93646: LIST
93647: PUSH
93648: LD_INT 3
93650: NEG
93651: PUSH
93652: LD_INT 2
93654: NEG
93655: PUSH
93656: EMPTY
93657: LIST
93658: LIST
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93664: LD_ADDR_VAR 0 53
93668: PUSH
93669: LD_INT 1
93671: NEG
93672: PUSH
93673: LD_INT 3
93675: NEG
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: LD_INT 0
93683: PUSH
93684: LD_INT 3
93686: NEG
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: PUSH
93692: LD_INT 1
93694: PUSH
93695: LD_INT 2
93697: NEG
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: LIST
93707: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93708: LD_ADDR_VAR 0 54
93712: PUSH
93713: LD_INT 2
93715: PUSH
93716: LD_INT 1
93718: NEG
93719: PUSH
93720: EMPTY
93721: LIST
93722: LIST
93723: PUSH
93724: LD_INT 3
93726: PUSH
93727: LD_INT 0
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: LD_INT 3
93736: PUSH
93737: LD_INT 1
93739: PUSH
93740: EMPTY
93741: LIST
93742: LIST
93743: PUSH
93744: EMPTY
93745: LIST
93746: LIST
93747: LIST
93748: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93749: LD_ADDR_VAR 0 55
93753: PUSH
93754: LD_INT 3
93756: PUSH
93757: LD_INT 2
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: LD_INT 3
93766: PUSH
93767: LD_INT 3
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 2
93776: PUSH
93777: LD_INT 3
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PUSH
93784: EMPTY
93785: LIST
93786: LIST
93787: LIST
93788: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93789: LD_ADDR_VAR 0 56
93793: PUSH
93794: LD_INT 1
93796: PUSH
93797: LD_INT 3
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 0
93806: PUSH
93807: LD_INT 3
93809: PUSH
93810: EMPTY
93811: LIST
93812: LIST
93813: PUSH
93814: LD_INT 1
93816: NEG
93817: PUSH
93818: LD_INT 2
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: LIST
93829: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93830: LD_ADDR_VAR 0 57
93834: PUSH
93835: LD_INT 2
93837: NEG
93838: PUSH
93839: LD_INT 1
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 3
93848: NEG
93849: PUSH
93850: LD_INT 0
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: PUSH
93857: LD_INT 3
93859: NEG
93860: PUSH
93861: LD_INT 1
93863: NEG
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: LIST
93873: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93874: LD_ADDR_VAR 0 58
93878: PUSH
93879: LD_INT 2
93881: NEG
93882: PUSH
93883: LD_INT 3
93885: NEG
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: PUSH
93891: LD_INT 3
93893: NEG
93894: PUSH
93895: LD_INT 2
93897: NEG
93898: PUSH
93899: EMPTY
93900: LIST
93901: LIST
93902: PUSH
93903: LD_INT 3
93905: NEG
93906: PUSH
93907: LD_INT 3
93909: NEG
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: LIST
93919: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93920: LD_ADDR_VAR 0 59
93924: PUSH
93925: LD_INT 1
93927: NEG
93928: PUSH
93929: LD_INT 2
93931: NEG
93932: PUSH
93933: EMPTY
93934: LIST
93935: LIST
93936: PUSH
93937: LD_INT 0
93939: PUSH
93940: LD_INT 2
93942: NEG
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: LD_INT 1
93950: PUSH
93951: LD_INT 1
93953: NEG
93954: PUSH
93955: EMPTY
93956: LIST
93957: LIST
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: LIST
93963: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93964: LD_ADDR_VAR 0 60
93968: PUSH
93969: LD_INT 1
93971: PUSH
93972: LD_INT 1
93974: NEG
93975: PUSH
93976: EMPTY
93977: LIST
93978: LIST
93979: PUSH
93980: LD_INT 2
93982: PUSH
93983: LD_INT 0
93985: PUSH
93986: EMPTY
93987: LIST
93988: LIST
93989: PUSH
93990: LD_INT 2
93992: PUSH
93993: LD_INT 1
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: LIST
94004: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94005: LD_ADDR_VAR 0 61
94009: PUSH
94010: LD_INT 2
94012: PUSH
94013: LD_INT 1
94015: PUSH
94016: EMPTY
94017: LIST
94018: LIST
94019: PUSH
94020: LD_INT 2
94022: PUSH
94023: LD_INT 2
94025: PUSH
94026: EMPTY
94027: LIST
94028: LIST
94029: PUSH
94030: LD_INT 1
94032: PUSH
94033: LD_INT 2
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: LIST
94044: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94045: LD_ADDR_VAR 0 62
94049: PUSH
94050: LD_INT 1
94052: PUSH
94053: LD_INT 2
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: LD_INT 0
94062: PUSH
94063: LD_INT 2
94065: PUSH
94066: EMPTY
94067: LIST
94068: LIST
94069: PUSH
94070: LD_INT 1
94072: NEG
94073: PUSH
94074: LD_INT 1
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: EMPTY
94082: LIST
94083: LIST
94084: LIST
94085: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94086: LD_ADDR_VAR 0 63
94090: PUSH
94091: LD_INT 1
94093: NEG
94094: PUSH
94095: LD_INT 1
94097: PUSH
94098: EMPTY
94099: LIST
94100: LIST
94101: PUSH
94102: LD_INT 2
94104: NEG
94105: PUSH
94106: LD_INT 0
94108: PUSH
94109: EMPTY
94110: LIST
94111: LIST
94112: PUSH
94113: LD_INT 2
94115: NEG
94116: PUSH
94117: LD_INT 1
94119: NEG
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: LIST
94129: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94130: LD_ADDR_VAR 0 64
94134: PUSH
94135: LD_INT 1
94137: NEG
94138: PUSH
94139: LD_INT 2
94141: NEG
94142: PUSH
94143: EMPTY
94144: LIST
94145: LIST
94146: PUSH
94147: LD_INT 2
94149: NEG
94150: PUSH
94151: LD_INT 1
94153: NEG
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 2
94161: NEG
94162: PUSH
94163: LD_INT 2
94165: NEG
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: LIST
94175: ST_TO_ADDR
// end ; 2 :
94176: GO 97442
94178: LD_INT 2
94180: DOUBLE
94181: EQUAL
94182: IFTRUE 94186
94184: GO 97441
94186: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94187: LD_ADDR_VAR 0 29
94191: PUSH
94192: LD_INT 4
94194: PUSH
94195: LD_INT 0
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: PUSH
94202: LD_INT 4
94204: PUSH
94205: LD_INT 1
94207: NEG
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: LD_INT 5
94215: PUSH
94216: LD_INT 0
94218: PUSH
94219: EMPTY
94220: LIST
94221: LIST
94222: PUSH
94223: LD_INT 5
94225: PUSH
94226: LD_INT 1
94228: PUSH
94229: EMPTY
94230: LIST
94231: LIST
94232: PUSH
94233: LD_INT 4
94235: PUSH
94236: LD_INT 1
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 3
94245: PUSH
94246: LD_INT 0
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 3
94255: PUSH
94256: LD_INT 1
94258: NEG
94259: PUSH
94260: EMPTY
94261: LIST
94262: LIST
94263: PUSH
94264: LD_INT 3
94266: PUSH
94267: LD_INT 2
94269: NEG
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 5
94277: PUSH
94278: LD_INT 2
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 3
94287: PUSH
94288: LD_INT 3
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 3
94297: PUSH
94298: LD_INT 2
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PUSH
94305: LD_INT 4
94307: PUSH
94308: LD_INT 3
94310: PUSH
94311: EMPTY
94312: LIST
94313: LIST
94314: PUSH
94315: LD_INT 4
94317: PUSH
94318: LD_INT 4
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: LD_INT 3
94327: PUSH
94328: LD_INT 4
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 2
94337: PUSH
94338: LD_INT 3
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 2
94347: PUSH
94348: LD_INT 2
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 4
94357: PUSH
94358: LD_INT 2
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 2
94367: PUSH
94368: LD_INT 4
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: PUSH
94375: LD_INT 0
94377: PUSH
94378: LD_INT 4
94380: PUSH
94381: EMPTY
94382: LIST
94383: LIST
94384: PUSH
94385: LD_INT 0
94387: PUSH
94388: LD_INT 3
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 1
94397: PUSH
94398: LD_INT 4
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: LD_INT 1
94407: PUSH
94408: LD_INT 5
94410: PUSH
94411: EMPTY
94412: LIST
94413: LIST
94414: PUSH
94415: LD_INT 0
94417: PUSH
94418: LD_INT 5
94420: PUSH
94421: EMPTY
94422: LIST
94423: LIST
94424: PUSH
94425: LD_INT 1
94427: NEG
94428: PUSH
94429: LD_INT 4
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 1
94438: NEG
94439: PUSH
94440: LD_INT 3
94442: PUSH
94443: EMPTY
94444: LIST
94445: LIST
94446: PUSH
94447: LD_INT 2
94449: PUSH
94450: LD_INT 5
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 2
94459: NEG
94460: PUSH
94461: LD_INT 3
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: LD_INT 3
94470: NEG
94471: PUSH
94472: LD_INT 0
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: PUSH
94479: LD_INT 3
94481: NEG
94482: PUSH
94483: LD_INT 1
94485: NEG
94486: PUSH
94487: EMPTY
94488: LIST
94489: LIST
94490: PUSH
94491: LD_INT 2
94493: NEG
94494: PUSH
94495: LD_INT 0
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: PUSH
94502: LD_INT 2
94504: NEG
94505: PUSH
94506: LD_INT 1
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: PUSH
94513: LD_INT 3
94515: NEG
94516: PUSH
94517: LD_INT 1
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: PUSH
94524: LD_INT 4
94526: NEG
94527: PUSH
94528: LD_INT 0
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: PUSH
94535: LD_INT 4
94537: NEG
94538: PUSH
94539: LD_INT 1
94541: NEG
94542: PUSH
94543: EMPTY
94544: LIST
94545: LIST
94546: PUSH
94547: LD_INT 4
94549: NEG
94550: PUSH
94551: LD_INT 2
94553: NEG
94554: PUSH
94555: EMPTY
94556: LIST
94557: LIST
94558: PUSH
94559: LD_INT 2
94561: NEG
94562: PUSH
94563: LD_INT 2
94565: PUSH
94566: EMPTY
94567: LIST
94568: LIST
94569: PUSH
94570: LD_INT 4
94572: NEG
94573: PUSH
94574: LD_INT 4
94576: NEG
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 4
94584: NEG
94585: PUSH
94586: LD_INT 5
94588: NEG
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 3
94596: NEG
94597: PUSH
94598: LD_INT 4
94600: NEG
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 3
94608: NEG
94609: PUSH
94610: LD_INT 3
94612: NEG
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: PUSH
94618: LD_INT 4
94620: NEG
94621: PUSH
94622: LD_INT 3
94624: NEG
94625: PUSH
94626: EMPTY
94627: LIST
94628: LIST
94629: PUSH
94630: LD_INT 5
94632: NEG
94633: PUSH
94634: LD_INT 4
94636: NEG
94637: PUSH
94638: EMPTY
94639: LIST
94640: LIST
94641: PUSH
94642: LD_INT 5
94644: NEG
94645: PUSH
94646: LD_INT 5
94648: NEG
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: PUSH
94654: LD_INT 3
94656: NEG
94657: PUSH
94658: LD_INT 5
94660: NEG
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: PUSH
94666: LD_INT 5
94668: NEG
94669: PUSH
94670: LD_INT 3
94672: NEG
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94725: LD_ADDR_VAR 0 30
94729: PUSH
94730: LD_INT 4
94732: PUSH
94733: LD_INT 4
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 4
94742: PUSH
94743: LD_INT 3
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: PUSH
94750: LD_INT 5
94752: PUSH
94753: LD_INT 4
94755: PUSH
94756: EMPTY
94757: LIST
94758: LIST
94759: PUSH
94760: LD_INT 5
94762: PUSH
94763: LD_INT 5
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 4
94772: PUSH
94773: LD_INT 5
94775: PUSH
94776: EMPTY
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 3
94782: PUSH
94783: LD_INT 4
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 3
94792: PUSH
94793: LD_INT 3
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 5
94802: PUSH
94803: LD_INT 3
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 3
94812: PUSH
94813: LD_INT 5
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: LD_INT 0
94822: PUSH
94823: LD_INT 3
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 0
94832: PUSH
94833: LD_INT 2
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 1
94842: PUSH
94843: LD_INT 3
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 1
94852: PUSH
94853: LD_INT 4
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 0
94862: PUSH
94863: LD_INT 4
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: LD_INT 1
94872: NEG
94873: PUSH
94874: LD_INT 3
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: LD_INT 1
94883: NEG
94884: PUSH
94885: LD_INT 2
94887: PUSH
94888: EMPTY
94889: LIST
94890: LIST
94891: PUSH
94892: LD_INT 2
94894: PUSH
94895: LD_INT 4
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: PUSH
94902: LD_INT 2
94904: NEG
94905: PUSH
94906: LD_INT 2
94908: PUSH
94909: EMPTY
94910: LIST
94911: LIST
94912: PUSH
94913: LD_INT 4
94915: NEG
94916: PUSH
94917: LD_INT 0
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: LD_INT 4
94926: NEG
94927: PUSH
94928: LD_INT 1
94930: NEG
94931: PUSH
94932: EMPTY
94933: LIST
94934: LIST
94935: PUSH
94936: LD_INT 3
94938: NEG
94939: PUSH
94940: LD_INT 0
94942: PUSH
94943: EMPTY
94944: LIST
94945: LIST
94946: PUSH
94947: LD_INT 3
94949: NEG
94950: PUSH
94951: LD_INT 1
94953: PUSH
94954: EMPTY
94955: LIST
94956: LIST
94957: PUSH
94958: LD_INT 4
94960: NEG
94961: PUSH
94962: LD_INT 1
94964: PUSH
94965: EMPTY
94966: LIST
94967: LIST
94968: PUSH
94969: LD_INT 5
94971: NEG
94972: PUSH
94973: LD_INT 0
94975: PUSH
94976: EMPTY
94977: LIST
94978: LIST
94979: PUSH
94980: LD_INT 5
94982: NEG
94983: PUSH
94984: LD_INT 1
94986: NEG
94987: PUSH
94988: EMPTY
94989: LIST
94990: LIST
94991: PUSH
94992: LD_INT 5
94994: NEG
94995: PUSH
94996: LD_INT 2
94998: NEG
94999: PUSH
95000: EMPTY
95001: LIST
95002: LIST
95003: PUSH
95004: LD_INT 3
95006: NEG
95007: PUSH
95008: LD_INT 2
95010: PUSH
95011: EMPTY
95012: LIST
95013: LIST
95014: PUSH
95015: LD_INT 3
95017: NEG
95018: PUSH
95019: LD_INT 3
95021: NEG
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 3
95029: NEG
95030: PUSH
95031: LD_INT 4
95033: NEG
95034: PUSH
95035: EMPTY
95036: LIST
95037: LIST
95038: PUSH
95039: LD_INT 2
95041: NEG
95042: PUSH
95043: LD_INT 3
95045: NEG
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: PUSH
95051: LD_INT 2
95053: NEG
95054: PUSH
95055: LD_INT 2
95057: NEG
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: PUSH
95063: LD_INT 3
95065: NEG
95066: PUSH
95067: LD_INT 2
95069: NEG
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: PUSH
95075: LD_INT 4
95077: NEG
95078: PUSH
95079: LD_INT 3
95081: NEG
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PUSH
95087: LD_INT 4
95089: NEG
95090: PUSH
95091: LD_INT 4
95093: NEG
95094: PUSH
95095: EMPTY
95096: LIST
95097: LIST
95098: PUSH
95099: LD_INT 2
95101: NEG
95102: PUSH
95103: LD_INT 4
95105: NEG
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: PUSH
95111: LD_INT 4
95113: NEG
95114: PUSH
95115: LD_INT 2
95117: NEG
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: PUSH
95123: LD_INT 0
95125: PUSH
95126: LD_INT 4
95128: NEG
95129: PUSH
95130: EMPTY
95131: LIST
95132: LIST
95133: PUSH
95134: LD_INT 0
95136: PUSH
95137: LD_INT 5
95139: NEG
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: PUSH
95145: LD_INT 1
95147: PUSH
95148: LD_INT 4
95150: NEG
95151: PUSH
95152: EMPTY
95153: LIST
95154: LIST
95155: PUSH
95156: LD_INT 1
95158: PUSH
95159: LD_INT 3
95161: NEG
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: LD_INT 0
95169: PUSH
95170: LD_INT 3
95172: NEG
95173: PUSH
95174: EMPTY
95175: LIST
95176: LIST
95177: PUSH
95178: LD_INT 1
95180: NEG
95181: PUSH
95182: LD_INT 4
95184: NEG
95185: PUSH
95186: EMPTY
95187: LIST
95188: LIST
95189: PUSH
95190: LD_INT 1
95192: NEG
95193: PUSH
95194: LD_INT 5
95196: NEG
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: PUSH
95202: LD_INT 2
95204: PUSH
95205: LD_INT 3
95207: NEG
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: LD_INT 2
95215: NEG
95216: PUSH
95217: LD_INT 5
95219: NEG
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: EMPTY
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95272: LD_ADDR_VAR 0 31
95276: PUSH
95277: LD_INT 0
95279: PUSH
95280: LD_INT 4
95282: PUSH
95283: EMPTY
95284: LIST
95285: LIST
95286: PUSH
95287: LD_INT 0
95289: PUSH
95290: LD_INT 3
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: PUSH
95297: LD_INT 1
95299: PUSH
95300: LD_INT 4
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: PUSH
95307: LD_INT 1
95309: PUSH
95310: LD_INT 5
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PUSH
95317: LD_INT 0
95319: PUSH
95320: LD_INT 5
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: PUSH
95327: LD_INT 1
95329: NEG
95330: PUSH
95331: LD_INT 4
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: LD_INT 1
95340: NEG
95341: PUSH
95342: LD_INT 3
95344: PUSH
95345: EMPTY
95346: LIST
95347: LIST
95348: PUSH
95349: LD_INT 2
95351: PUSH
95352: LD_INT 5
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: LD_INT 2
95361: NEG
95362: PUSH
95363: LD_INT 3
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: PUSH
95370: LD_INT 3
95372: NEG
95373: PUSH
95374: LD_INT 0
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 3
95383: NEG
95384: PUSH
95385: LD_INT 1
95387: NEG
95388: PUSH
95389: EMPTY
95390: LIST
95391: LIST
95392: PUSH
95393: LD_INT 2
95395: NEG
95396: PUSH
95397: LD_INT 0
95399: PUSH
95400: EMPTY
95401: LIST
95402: LIST
95403: PUSH
95404: LD_INT 2
95406: NEG
95407: PUSH
95408: LD_INT 1
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: PUSH
95415: LD_INT 3
95417: NEG
95418: PUSH
95419: LD_INT 1
95421: PUSH
95422: EMPTY
95423: LIST
95424: LIST
95425: PUSH
95426: LD_INT 4
95428: NEG
95429: PUSH
95430: LD_INT 0
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: PUSH
95437: LD_INT 4
95439: NEG
95440: PUSH
95441: LD_INT 1
95443: NEG
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: LD_INT 4
95451: NEG
95452: PUSH
95453: LD_INT 2
95455: NEG
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: PUSH
95461: LD_INT 2
95463: NEG
95464: PUSH
95465: LD_INT 2
95467: PUSH
95468: EMPTY
95469: LIST
95470: LIST
95471: PUSH
95472: LD_INT 4
95474: NEG
95475: PUSH
95476: LD_INT 4
95478: NEG
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: PUSH
95484: LD_INT 4
95486: NEG
95487: PUSH
95488: LD_INT 5
95490: NEG
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 3
95498: NEG
95499: PUSH
95500: LD_INT 4
95502: NEG
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 3
95510: NEG
95511: PUSH
95512: LD_INT 3
95514: NEG
95515: PUSH
95516: EMPTY
95517: LIST
95518: LIST
95519: PUSH
95520: LD_INT 4
95522: NEG
95523: PUSH
95524: LD_INT 3
95526: NEG
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: PUSH
95532: LD_INT 5
95534: NEG
95535: PUSH
95536: LD_INT 4
95538: NEG
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: LD_INT 5
95546: NEG
95547: PUSH
95548: LD_INT 5
95550: NEG
95551: PUSH
95552: EMPTY
95553: LIST
95554: LIST
95555: PUSH
95556: LD_INT 3
95558: NEG
95559: PUSH
95560: LD_INT 5
95562: NEG
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 5
95570: NEG
95571: PUSH
95572: LD_INT 3
95574: NEG
95575: PUSH
95576: EMPTY
95577: LIST
95578: LIST
95579: PUSH
95580: LD_INT 0
95582: PUSH
95583: LD_INT 3
95585: NEG
95586: PUSH
95587: EMPTY
95588: LIST
95589: LIST
95590: PUSH
95591: LD_INT 0
95593: PUSH
95594: LD_INT 4
95596: NEG
95597: PUSH
95598: EMPTY
95599: LIST
95600: LIST
95601: PUSH
95602: LD_INT 1
95604: PUSH
95605: LD_INT 3
95607: NEG
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: PUSH
95613: LD_INT 1
95615: PUSH
95616: LD_INT 2
95618: NEG
95619: PUSH
95620: EMPTY
95621: LIST
95622: LIST
95623: PUSH
95624: LD_INT 0
95626: PUSH
95627: LD_INT 2
95629: NEG
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PUSH
95635: LD_INT 1
95637: NEG
95638: PUSH
95639: LD_INT 3
95641: NEG
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: PUSH
95647: LD_INT 1
95649: NEG
95650: PUSH
95651: LD_INT 4
95653: NEG
95654: PUSH
95655: EMPTY
95656: LIST
95657: LIST
95658: PUSH
95659: LD_INT 2
95661: PUSH
95662: LD_INT 2
95664: NEG
95665: PUSH
95666: EMPTY
95667: LIST
95668: LIST
95669: PUSH
95670: LD_INT 2
95672: NEG
95673: PUSH
95674: LD_INT 4
95676: NEG
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: PUSH
95682: LD_INT 4
95684: PUSH
95685: LD_INT 0
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: PUSH
95692: LD_INT 4
95694: PUSH
95695: LD_INT 1
95697: NEG
95698: PUSH
95699: EMPTY
95700: LIST
95701: LIST
95702: PUSH
95703: LD_INT 5
95705: PUSH
95706: LD_INT 0
95708: PUSH
95709: EMPTY
95710: LIST
95711: LIST
95712: PUSH
95713: LD_INT 5
95715: PUSH
95716: LD_INT 1
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: PUSH
95723: LD_INT 4
95725: PUSH
95726: LD_INT 1
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: PUSH
95733: LD_INT 3
95735: PUSH
95736: LD_INT 0
95738: PUSH
95739: EMPTY
95740: LIST
95741: LIST
95742: PUSH
95743: LD_INT 3
95745: PUSH
95746: LD_INT 1
95748: NEG
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: LD_INT 3
95756: PUSH
95757: LD_INT 2
95759: NEG
95760: PUSH
95761: EMPTY
95762: LIST
95763: LIST
95764: PUSH
95765: LD_INT 5
95767: PUSH
95768: LD_INT 2
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: PUSH
95775: EMPTY
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95822: LD_ADDR_VAR 0 32
95826: PUSH
95827: LD_INT 4
95829: NEG
95830: PUSH
95831: LD_INT 0
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 4
95840: NEG
95841: PUSH
95842: LD_INT 1
95844: NEG
95845: PUSH
95846: EMPTY
95847: LIST
95848: LIST
95849: PUSH
95850: LD_INT 3
95852: NEG
95853: PUSH
95854: LD_INT 0
95856: PUSH
95857: EMPTY
95858: LIST
95859: LIST
95860: PUSH
95861: LD_INT 3
95863: NEG
95864: PUSH
95865: LD_INT 1
95867: PUSH
95868: EMPTY
95869: LIST
95870: LIST
95871: PUSH
95872: LD_INT 4
95874: NEG
95875: PUSH
95876: LD_INT 1
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: PUSH
95883: LD_INT 5
95885: NEG
95886: PUSH
95887: LD_INT 0
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 5
95896: NEG
95897: PUSH
95898: LD_INT 1
95900: NEG
95901: PUSH
95902: EMPTY
95903: LIST
95904: LIST
95905: PUSH
95906: LD_INT 5
95908: NEG
95909: PUSH
95910: LD_INT 2
95912: NEG
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: PUSH
95918: LD_INT 3
95920: NEG
95921: PUSH
95922: LD_INT 2
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: PUSH
95929: LD_INT 3
95931: NEG
95932: PUSH
95933: LD_INT 3
95935: NEG
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 3
95943: NEG
95944: PUSH
95945: LD_INT 4
95947: NEG
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 2
95955: NEG
95956: PUSH
95957: LD_INT 3
95959: NEG
95960: PUSH
95961: EMPTY
95962: LIST
95963: LIST
95964: PUSH
95965: LD_INT 2
95967: NEG
95968: PUSH
95969: LD_INT 2
95971: NEG
95972: PUSH
95973: EMPTY
95974: LIST
95975: LIST
95976: PUSH
95977: LD_INT 3
95979: NEG
95980: PUSH
95981: LD_INT 2
95983: NEG
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: PUSH
95989: LD_INT 4
95991: NEG
95992: PUSH
95993: LD_INT 3
95995: NEG
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: PUSH
96001: LD_INT 4
96003: NEG
96004: PUSH
96005: LD_INT 4
96007: NEG
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PUSH
96013: LD_INT 2
96015: NEG
96016: PUSH
96017: LD_INT 4
96019: NEG
96020: PUSH
96021: EMPTY
96022: LIST
96023: LIST
96024: PUSH
96025: LD_INT 4
96027: NEG
96028: PUSH
96029: LD_INT 2
96031: NEG
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: PUSH
96037: LD_INT 0
96039: PUSH
96040: LD_INT 4
96042: NEG
96043: PUSH
96044: EMPTY
96045: LIST
96046: LIST
96047: PUSH
96048: LD_INT 0
96050: PUSH
96051: LD_INT 5
96053: NEG
96054: PUSH
96055: EMPTY
96056: LIST
96057: LIST
96058: PUSH
96059: LD_INT 1
96061: PUSH
96062: LD_INT 4
96064: NEG
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: LD_INT 1
96072: PUSH
96073: LD_INT 3
96075: NEG
96076: PUSH
96077: EMPTY
96078: LIST
96079: LIST
96080: PUSH
96081: LD_INT 0
96083: PUSH
96084: LD_INT 3
96086: NEG
96087: PUSH
96088: EMPTY
96089: LIST
96090: LIST
96091: PUSH
96092: LD_INT 1
96094: NEG
96095: PUSH
96096: LD_INT 4
96098: NEG
96099: PUSH
96100: EMPTY
96101: LIST
96102: LIST
96103: PUSH
96104: LD_INT 1
96106: NEG
96107: PUSH
96108: LD_INT 5
96110: NEG
96111: PUSH
96112: EMPTY
96113: LIST
96114: LIST
96115: PUSH
96116: LD_INT 2
96118: PUSH
96119: LD_INT 3
96121: NEG
96122: PUSH
96123: EMPTY
96124: LIST
96125: LIST
96126: PUSH
96127: LD_INT 2
96129: NEG
96130: PUSH
96131: LD_INT 5
96133: NEG
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: PUSH
96139: LD_INT 3
96141: PUSH
96142: LD_INT 0
96144: PUSH
96145: EMPTY
96146: LIST
96147: LIST
96148: PUSH
96149: LD_INT 3
96151: PUSH
96152: LD_INT 1
96154: NEG
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 4
96162: PUSH
96163: LD_INT 0
96165: PUSH
96166: EMPTY
96167: LIST
96168: LIST
96169: PUSH
96170: LD_INT 4
96172: PUSH
96173: LD_INT 1
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: PUSH
96180: LD_INT 3
96182: PUSH
96183: LD_INT 1
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: PUSH
96190: LD_INT 2
96192: PUSH
96193: LD_INT 0
96195: PUSH
96196: EMPTY
96197: LIST
96198: LIST
96199: PUSH
96200: LD_INT 2
96202: PUSH
96203: LD_INT 1
96205: NEG
96206: PUSH
96207: EMPTY
96208: LIST
96209: LIST
96210: PUSH
96211: LD_INT 2
96213: PUSH
96214: LD_INT 2
96216: NEG
96217: PUSH
96218: EMPTY
96219: LIST
96220: LIST
96221: PUSH
96222: LD_INT 4
96224: PUSH
96225: LD_INT 2
96227: PUSH
96228: EMPTY
96229: LIST
96230: LIST
96231: PUSH
96232: LD_INT 4
96234: PUSH
96235: LD_INT 4
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: LD_INT 4
96244: PUSH
96245: LD_INT 3
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: PUSH
96252: LD_INT 5
96254: PUSH
96255: LD_INT 4
96257: PUSH
96258: EMPTY
96259: LIST
96260: LIST
96261: PUSH
96262: LD_INT 5
96264: PUSH
96265: LD_INT 5
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 4
96274: PUSH
96275: LD_INT 5
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PUSH
96282: LD_INT 3
96284: PUSH
96285: LD_INT 4
96287: PUSH
96288: EMPTY
96289: LIST
96290: LIST
96291: PUSH
96292: LD_INT 3
96294: PUSH
96295: LD_INT 3
96297: PUSH
96298: EMPTY
96299: LIST
96300: LIST
96301: PUSH
96302: LD_INT 5
96304: PUSH
96305: LD_INT 3
96307: PUSH
96308: EMPTY
96309: LIST
96310: LIST
96311: PUSH
96312: LD_INT 3
96314: PUSH
96315: LD_INT 5
96317: PUSH
96318: EMPTY
96319: LIST
96320: LIST
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: LIST
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96369: LD_ADDR_VAR 0 33
96373: PUSH
96374: LD_INT 4
96376: NEG
96377: PUSH
96378: LD_INT 4
96380: NEG
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_INT 4
96388: NEG
96389: PUSH
96390: LD_INT 5
96392: NEG
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: PUSH
96398: LD_INT 3
96400: NEG
96401: PUSH
96402: LD_INT 4
96404: NEG
96405: PUSH
96406: EMPTY
96407: LIST
96408: LIST
96409: PUSH
96410: LD_INT 3
96412: NEG
96413: PUSH
96414: LD_INT 3
96416: NEG
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: PUSH
96422: LD_INT 4
96424: NEG
96425: PUSH
96426: LD_INT 3
96428: NEG
96429: PUSH
96430: EMPTY
96431: LIST
96432: LIST
96433: PUSH
96434: LD_INT 5
96436: NEG
96437: PUSH
96438: LD_INT 4
96440: NEG
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: PUSH
96446: LD_INT 5
96448: NEG
96449: PUSH
96450: LD_INT 5
96452: NEG
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: LD_INT 3
96460: NEG
96461: PUSH
96462: LD_INT 5
96464: NEG
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PUSH
96470: LD_INT 5
96472: NEG
96473: PUSH
96474: LD_INT 3
96476: NEG
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: LD_INT 0
96484: PUSH
96485: LD_INT 3
96487: NEG
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 0
96495: PUSH
96496: LD_INT 4
96498: NEG
96499: PUSH
96500: EMPTY
96501: LIST
96502: LIST
96503: PUSH
96504: LD_INT 1
96506: PUSH
96507: LD_INT 3
96509: NEG
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: LD_INT 1
96517: PUSH
96518: LD_INT 2
96520: NEG
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: PUSH
96526: LD_INT 0
96528: PUSH
96529: LD_INT 2
96531: NEG
96532: PUSH
96533: EMPTY
96534: LIST
96535: LIST
96536: PUSH
96537: LD_INT 1
96539: NEG
96540: PUSH
96541: LD_INT 3
96543: NEG
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: PUSH
96549: LD_INT 1
96551: NEG
96552: PUSH
96553: LD_INT 4
96555: NEG
96556: PUSH
96557: EMPTY
96558: LIST
96559: LIST
96560: PUSH
96561: LD_INT 2
96563: PUSH
96564: LD_INT 2
96566: NEG
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: PUSH
96572: LD_INT 2
96574: NEG
96575: PUSH
96576: LD_INT 4
96578: NEG
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: LD_INT 4
96586: PUSH
96587: LD_INT 0
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PUSH
96594: LD_INT 4
96596: PUSH
96597: LD_INT 1
96599: NEG
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: PUSH
96605: LD_INT 5
96607: PUSH
96608: LD_INT 0
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: PUSH
96615: LD_INT 5
96617: PUSH
96618: LD_INT 1
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 4
96627: PUSH
96628: LD_INT 1
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: LD_INT 3
96637: PUSH
96638: LD_INT 0
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 3
96647: PUSH
96648: LD_INT 1
96650: NEG
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: PUSH
96656: LD_INT 3
96658: PUSH
96659: LD_INT 2
96661: NEG
96662: PUSH
96663: EMPTY
96664: LIST
96665: LIST
96666: PUSH
96667: LD_INT 5
96669: PUSH
96670: LD_INT 2
96672: PUSH
96673: EMPTY
96674: LIST
96675: LIST
96676: PUSH
96677: LD_INT 3
96679: PUSH
96680: LD_INT 3
96682: PUSH
96683: EMPTY
96684: LIST
96685: LIST
96686: PUSH
96687: LD_INT 3
96689: PUSH
96690: LD_INT 2
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: PUSH
96697: LD_INT 4
96699: PUSH
96700: LD_INT 3
96702: PUSH
96703: EMPTY
96704: LIST
96705: LIST
96706: PUSH
96707: LD_INT 4
96709: PUSH
96710: LD_INT 4
96712: PUSH
96713: EMPTY
96714: LIST
96715: LIST
96716: PUSH
96717: LD_INT 3
96719: PUSH
96720: LD_INT 4
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: PUSH
96727: LD_INT 2
96729: PUSH
96730: LD_INT 3
96732: PUSH
96733: EMPTY
96734: LIST
96735: LIST
96736: PUSH
96737: LD_INT 2
96739: PUSH
96740: LD_INT 2
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: PUSH
96747: LD_INT 4
96749: PUSH
96750: LD_INT 2
96752: PUSH
96753: EMPTY
96754: LIST
96755: LIST
96756: PUSH
96757: LD_INT 2
96759: PUSH
96760: LD_INT 4
96762: PUSH
96763: EMPTY
96764: LIST
96765: LIST
96766: PUSH
96767: LD_INT 0
96769: PUSH
96770: LD_INT 4
96772: PUSH
96773: EMPTY
96774: LIST
96775: LIST
96776: PUSH
96777: LD_INT 0
96779: PUSH
96780: LD_INT 3
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PUSH
96787: LD_INT 1
96789: PUSH
96790: LD_INT 4
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 1
96799: PUSH
96800: LD_INT 5
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: PUSH
96807: LD_INT 0
96809: PUSH
96810: LD_INT 5
96812: PUSH
96813: EMPTY
96814: LIST
96815: LIST
96816: PUSH
96817: LD_INT 1
96819: NEG
96820: PUSH
96821: LD_INT 4
96823: PUSH
96824: EMPTY
96825: LIST
96826: LIST
96827: PUSH
96828: LD_INT 1
96830: NEG
96831: PUSH
96832: LD_INT 3
96834: PUSH
96835: EMPTY
96836: LIST
96837: LIST
96838: PUSH
96839: LD_INT 2
96841: PUSH
96842: LD_INT 5
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: PUSH
96849: LD_INT 2
96851: NEG
96852: PUSH
96853: LD_INT 3
96855: PUSH
96856: EMPTY
96857: LIST
96858: LIST
96859: PUSH
96860: EMPTY
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96907: LD_ADDR_VAR 0 34
96911: PUSH
96912: LD_INT 0
96914: PUSH
96915: LD_INT 4
96917: NEG
96918: PUSH
96919: EMPTY
96920: LIST
96921: LIST
96922: PUSH
96923: LD_INT 0
96925: PUSH
96926: LD_INT 5
96928: NEG
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: PUSH
96934: LD_INT 1
96936: PUSH
96937: LD_INT 4
96939: NEG
96940: PUSH
96941: EMPTY
96942: LIST
96943: LIST
96944: PUSH
96945: LD_INT 1
96947: PUSH
96948: LD_INT 3
96950: NEG
96951: PUSH
96952: EMPTY
96953: LIST
96954: LIST
96955: PUSH
96956: LD_INT 0
96958: PUSH
96959: LD_INT 3
96961: NEG
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: PUSH
96967: LD_INT 1
96969: NEG
96970: PUSH
96971: LD_INT 4
96973: NEG
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: PUSH
96979: LD_INT 1
96981: NEG
96982: PUSH
96983: LD_INT 5
96985: NEG
96986: PUSH
96987: EMPTY
96988: LIST
96989: LIST
96990: PUSH
96991: LD_INT 2
96993: PUSH
96994: LD_INT 3
96996: NEG
96997: PUSH
96998: EMPTY
96999: LIST
97000: LIST
97001: PUSH
97002: LD_INT 2
97004: NEG
97005: PUSH
97006: LD_INT 5
97008: NEG
97009: PUSH
97010: EMPTY
97011: LIST
97012: LIST
97013: PUSH
97014: LD_INT 3
97016: PUSH
97017: LD_INT 0
97019: PUSH
97020: EMPTY
97021: LIST
97022: LIST
97023: PUSH
97024: LD_INT 3
97026: PUSH
97027: LD_INT 1
97029: NEG
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: PUSH
97035: LD_INT 4
97037: PUSH
97038: LD_INT 0
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 4
97047: PUSH
97048: LD_INT 1
97050: PUSH
97051: EMPTY
97052: LIST
97053: LIST
97054: PUSH
97055: LD_INT 3
97057: PUSH
97058: LD_INT 1
97060: PUSH
97061: EMPTY
97062: LIST
97063: LIST
97064: PUSH
97065: LD_INT 2
97067: PUSH
97068: LD_INT 0
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: PUSH
97075: LD_INT 2
97077: PUSH
97078: LD_INT 1
97080: NEG
97081: PUSH
97082: EMPTY
97083: LIST
97084: LIST
97085: PUSH
97086: LD_INT 2
97088: PUSH
97089: LD_INT 2
97091: NEG
97092: PUSH
97093: EMPTY
97094: LIST
97095: LIST
97096: PUSH
97097: LD_INT 4
97099: PUSH
97100: LD_INT 2
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 4
97109: PUSH
97110: LD_INT 4
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: LD_INT 4
97119: PUSH
97120: LD_INT 3
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: PUSH
97127: LD_INT 5
97129: PUSH
97130: LD_INT 4
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: PUSH
97137: LD_INT 5
97139: PUSH
97140: LD_INT 5
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 4
97149: PUSH
97150: LD_INT 5
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: PUSH
97157: LD_INT 3
97159: PUSH
97160: LD_INT 4
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: PUSH
97167: LD_INT 3
97169: PUSH
97170: LD_INT 3
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: PUSH
97177: LD_INT 5
97179: PUSH
97180: LD_INT 3
97182: PUSH
97183: EMPTY
97184: LIST
97185: LIST
97186: PUSH
97187: LD_INT 3
97189: PUSH
97190: LD_INT 5
97192: PUSH
97193: EMPTY
97194: LIST
97195: LIST
97196: PUSH
97197: LD_INT 0
97199: PUSH
97200: LD_INT 3
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: PUSH
97207: LD_INT 0
97209: PUSH
97210: LD_INT 2
97212: PUSH
97213: EMPTY
97214: LIST
97215: LIST
97216: PUSH
97217: LD_INT 1
97219: PUSH
97220: LD_INT 3
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: PUSH
97227: LD_INT 1
97229: PUSH
97230: LD_INT 4
97232: PUSH
97233: EMPTY
97234: LIST
97235: LIST
97236: PUSH
97237: LD_INT 0
97239: PUSH
97240: LD_INT 4
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: PUSH
97247: LD_INT 1
97249: NEG
97250: PUSH
97251: LD_INT 3
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PUSH
97258: LD_INT 1
97260: NEG
97261: PUSH
97262: LD_INT 2
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: PUSH
97269: LD_INT 2
97271: PUSH
97272: LD_INT 4
97274: PUSH
97275: EMPTY
97276: LIST
97277: LIST
97278: PUSH
97279: LD_INT 2
97281: NEG
97282: PUSH
97283: LD_INT 2
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: LD_INT 4
97292: NEG
97293: PUSH
97294: LD_INT 0
97296: PUSH
97297: EMPTY
97298: LIST
97299: LIST
97300: PUSH
97301: LD_INT 4
97303: NEG
97304: PUSH
97305: LD_INT 1
97307: NEG
97308: PUSH
97309: EMPTY
97310: LIST
97311: LIST
97312: PUSH
97313: LD_INT 3
97315: NEG
97316: PUSH
97317: LD_INT 0
97319: PUSH
97320: EMPTY
97321: LIST
97322: LIST
97323: PUSH
97324: LD_INT 3
97326: NEG
97327: PUSH
97328: LD_INT 1
97330: PUSH
97331: EMPTY
97332: LIST
97333: LIST
97334: PUSH
97335: LD_INT 4
97337: NEG
97338: PUSH
97339: LD_INT 1
97341: PUSH
97342: EMPTY
97343: LIST
97344: LIST
97345: PUSH
97346: LD_INT 5
97348: NEG
97349: PUSH
97350: LD_INT 0
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_INT 5
97359: NEG
97360: PUSH
97361: LD_INT 1
97363: NEG
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: LD_INT 5
97371: NEG
97372: PUSH
97373: LD_INT 2
97375: NEG
97376: PUSH
97377: EMPTY
97378: LIST
97379: LIST
97380: PUSH
97381: LD_INT 3
97383: NEG
97384: PUSH
97385: LD_INT 2
97387: PUSH
97388: EMPTY
97389: LIST
97390: LIST
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: ST_TO_ADDR
// end ; end ;
97439: GO 97442
97441: POP
// case btype of b_depot , b_warehouse :
97442: LD_VAR 0 1
97446: PUSH
97447: LD_INT 0
97449: DOUBLE
97450: EQUAL
97451: IFTRUE 97461
97453: LD_INT 1
97455: DOUBLE
97456: EQUAL
97457: IFTRUE 97461
97459: GO 97662
97461: POP
// case nation of nation_american :
97462: LD_VAR 0 5
97466: PUSH
97467: LD_INT 1
97469: DOUBLE
97470: EQUAL
97471: IFTRUE 97475
97473: GO 97531
97475: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97476: LD_ADDR_VAR 0 9
97480: PUSH
97481: LD_VAR 0 11
97485: PUSH
97486: LD_VAR 0 12
97490: PUSH
97491: LD_VAR 0 13
97495: PUSH
97496: LD_VAR 0 14
97500: PUSH
97501: LD_VAR 0 15
97505: PUSH
97506: LD_VAR 0 16
97510: PUSH
97511: EMPTY
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: PUSH
97519: LD_VAR 0 4
97523: PUSH
97524: LD_INT 1
97526: PLUS
97527: ARRAY
97528: ST_TO_ADDR
97529: GO 97660
97531: LD_INT 2
97533: DOUBLE
97534: EQUAL
97535: IFTRUE 97539
97537: GO 97595
97539: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97540: LD_ADDR_VAR 0 9
97544: PUSH
97545: LD_VAR 0 17
97549: PUSH
97550: LD_VAR 0 18
97554: PUSH
97555: LD_VAR 0 19
97559: PUSH
97560: LD_VAR 0 20
97564: PUSH
97565: LD_VAR 0 21
97569: PUSH
97570: LD_VAR 0 22
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: LIST
97582: PUSH
97583: LD_VAR 0 4
97587: PUSH
97588: LD_INT 1
97590: PLUS
97591: ARRAY
97592: ST_TO_ADDR
97593: GO 97660
97595: LD_INT 3
97597: DOUBLE
97598: EQUAL
97599: IFTRUE 97603
97601: GO 97659
97603: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97604: LD_ADDR_VAR 0 9
97608: PUSH
97609: LD_VAR 0 23
97613: PUSH
97614: LD_VAR 0 24
97618: PUSH
97619: LD_VAR 0 25
97623: PUSH
97624: LD_VAR 0 26
97628: PUSH
97629: LD_VAR 0 27
97633: PUSH
97634: LD_VAR 0 28
97638: PUSH
97639: EMPTY
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: PUSH
97647: LD_VAR 0 4
97651: PUSH
97652: LD_INT 1
97654: PLUS
97655: ARRAY
97656: ST_TO_ADDR
97657: GO 97660
97659: POP
97660: GO 98215
97662: LD_INT 2
97664: DOUBLE
97665: EQUAL
97666: IFTRUE 97676
97668: LD_INT 3
97670: DOUBLE
97671: EQUAL
97672: IFTRUE 97676
97674: GO 97732
97676: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97677: LD_ADDR_VAR 0 9
97681: PUSH
97682: LD_VAR 0 29
97686: PUSH
97687: LD_VAR 0 30
97691: PUSH
97692: LD_VAR 0 31
97696: PUSH
97697: LD_VAR 0 32
97701: PUSH
97702: LD_VAR 0 33
97706: PUSH
97707: LD_VAR 0 34
97711: PUSH
97712: EMPTY
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: PUSH
97720: LD_VAR 0 4
97724: PUSH
97725: LD_INT 1
97727: PLUS
97728: ARRAY
97729: ST_TO_ADDR
97730: GO 98215
97732: LD_INT 16
97734: DOUBLE
97735: EQUAL
97736: IFTRUE 97794
97738: LD_INT 17
97740: DOUBLE
97741: EQUAL
97742: IFTRUE 97794
97744: LD_INT 18
97746: DOUBLE
97747: EQUAL
97748: IFTRUE 97794
97750: LD_INT 19
97752: DOUBLE
97753: EQUAL
97754: IFTRUE 97794
97756: LD_INT 22
97758: DOUBLE
97759: EQUAL
97760: IFTRUE 97794
97762: LD_INT 20
97764: DOUBLE
97765: EQUAL
97766: IFTRUE 97794
97768: LD_INT 21
97770: DOUBLE
97771: EQUAL
97772: IFTRUE 97794
97774: LD_INT 23
97776: DOUBLE
97777: EQUAL
97778: IFTRUE 97794
97780: LD_INT 24
97782: DOUBLE
97783: EQUAL
97784: IFTRUE 97794
97786: LD_INT 25
97788: DOUBLE
97789: EQUAL
97790: IFTRUE 97794
97792: GO 97850
97794: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97795: LD_ADDR_VAR 0 9
97799: PUSH
97800: LD_VAR 0 35
97804: PUSH
97805: LD_VAR 0 36
97809: PUSH
97810: LD_VAR 0 37
97814: PUSH
97815: LD_VAR 0 38
97819: PUSH
97820: LD_VAR 0 39
97824: PUSH
97825: LD_VAR 0 40
97829: PUSH
97830: EMPTY
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: PUSH
97838: LD_VAR 0 4
97842: PUSH
97843: LD_INT 1
97845: PLUS
97846: ARRAY
97847: ST_TO_ADDR
97848: GO 98215
97850: LD_INT 6
97852: DOUBLE
97853: EQUAL
97854: IFTRUE 97906
97856: LD_INT 7
97858: DOUBLE
97859: EQUAL
97860: IFTRUE 97906
97862: LD_INT 8
97864: DOUBLE
97865: EQUAL
97866: IFTRUE 97906
97868: LD_INT 13
97870: DOUBLE
97871: EQUAL
97872: IFTRUE 97906
97874: LD_INT 12
97876: DOUBLE
97877: EQUAL
97878: IFTRUE 97906
97880: LD_INT 15
97882: DOUBLE
97883: EQUAL
97884: IFTRUE 97906
97886: LD_INT 11
97888: DOUBLE
97889: EQUAL
97890: IFTRUE 97906
97892: LD_INT 14
97894: DOUBLE
97895: EQUAL
97896: IFTRUE 97906
97898: LD_INT 10
97900: DOUBLE
97901: EQUAL
97902: IFTRUE 97906
97904: GO 97962
97906: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97907: LD_ADDR_VAR 0 9
97911: PUSH
97912: LD_VAR 0 41
97916: PUSH
97917: LD_VAR 0 42
97921: PUSH
97922: LD_VAR 0 43
97926: PUSH
97927: LD_VAR 0 44
97931: PUSH
97932: LD_VAR 0 45
97936: PUSH
97937: LD_VAR 0 46
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: PUSH
97950: LD_VAR 0 4
97954: PUSH
97955: LD_INT 1
97957: PLUS
97958: ARRAY
97959: ST_TO_ADDR
97960: GO 98215
97962: LD_INT 36
97964: DOUBLE
97965: EQUAL
97966: IFTRUE 97970
97968: GO 98026
97970: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97971: LD_ADDR_VAR 0 9
97975: PUSH
97976: LD_VAR 0 47
97980: PUSH
97981: LD_VAR 0 48
97985: PUSH
97986: LD_VAR 0 49
97990: PUSH
97991: LD_VAR 0 50
97995: PUSH
97996: LD_VAR 0 51
98000: PUSH
98001: LD_VAR 0 52
98005: PUSH
98006: EMPTY
98007: LIST
98008: LIST
98009: LIST
98010: LIST
98011: LIST
98012: LIST
98013: PUSH
98014: LD_VAR 0 4
98018: PUSH
98019: LD_INT 1
98021: PLUS
98022: ARRAY
98023: ST_TO_ADDR
98024: GO 98215
98026: LD_INT 4
98028: DOUBLE
98029: EQUAL
98030: IFTRUE 98052
98032: LD_INT 5
98034: DOUBLE
98035: EQUAL
98036: IFTRUE 98052
98038: LD_INT 34
98040: DOUBLE
98041: EQUAL
98042: IFTRUE 98052
98044: LD_INT 37
98046: DOUBLE
98047: EQUAL
98048: IFTRUE 98052
98050: GO 98108
98052: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98053: LD_ADDR_VAR 0 9
98057: PUSH
98058: LD_VAR 0 53
98062: PUSH
98063: LD_VAR 0 54
98067: PUSH
98068: LD_VAR 0 55
98072: PUSH
98073: LD_VAR 0 56
98077: PUSH
98078: LD_VAR 0 57
98082: PUSH
98083: LD_VAR 0 58
98087: PUSH
98088: EMPTY
98089: LIST
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: LIST
98095: PUSH
98096: LD_VAR 0 4
98100: PUSH
98101: LD_INT 1
98103: PLUS
98104: ARRAY
98105: ST_TO_ADDR
98106: GO 98215
98108: LD_INT 31
98110: DOUBLE
98111: EQUAL
98112: IFTRUE 98158
98114: LD_INT 32
98116: DOUBLE
98117: EQUAL
98118: IFTRUE 98158
98120: LD_INT 33
98122: DOUBLE
98123: EQUAL
98124: IFTRUE 98158
98126: LD_INT 27
98128: DOUBLE
98129: EQUAL
98130: IFTRUE 98158
98132: LD_INT 26
98134: DOUBLE
98135: EQUAL
98136: IFTRUE 98158
98138: LD_INT 28
98140: DOUBLE
98141: EQUAL
98142: IFTRUE 98158
98144: LD_INT 29
98146: DOUBLE
98147: EQUAL
98148: IFTRUE 98158
98150: LD_INT 30
98152: DOUBLE
98153: EQUAL
98154: IFTRUE 98158
98156: GO 98214
98158: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98159: LD_ADDR_VAR 0 9
98163: PUSH
98164: LD_VAR 0 59
98168: PUSH
98169: LD_VAR 0 60
98173: PUSH
98174: LD_VAR 0 61
98178: PUSH
98179: LD_VAR 0 62
98183: PUSH
98184: LD_VAR 0 63
98188: PUSH
98189: LD_VAR 0 64
98193: PUSH
98194: EMPTY
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: PUSH
98202: LD_VAR 0 4
98206: PUSH
98207: LD_INT 1
98209: PLUS
98210: ARRAY
98211: ST_TO_ADDR
98212: GO 98215
98214: POP
// temp_list2 = [ ] ;
98215: LD_ADDR_VAR 0 10
98219: PUSH
98220: EMPTY
98221: ST_TO_ADDR
// for i in temp_list do
98222: LD_ADDR_VAR 0 8
98226: PUSH
98227: LD_VAR 0 9
98231: PUSH
98232: FOR_IN
98233: IFFALSE 98285
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98235: LD_ADDR_VAR 0 10
98239: PUSH
98240: LD_VAR 0 10
98244: PUSH
98245: LD_VAR 0 8
98249: PUSH
98250: LD_INT 1
98252: ARRAY
98253: PUSH
98254: LD_VAR 0 2
98258: PLUS
98259: PUSH
98260: LD_VAR 0 8
98264: PUSH
98265: LD_INT 2
98267: ARRAY
98268: PUSH
98269: LD_VAR 0 3
98273: PLUS
98274: PUSH
98275: EMPTY
98276: LIST
98277: LIST
98278: PUSH
98279: EMPTY
98280: LIST
98281: ADD
98282: ST_TO_ADDR
98283: GO 98232
98285: POP
98286: POP
// result = temp_list2 ;
98287: LD_ADDR_VAR 0 7
98291: PUSH
98292: LD_VAR 0 10
98296: ST_TO_ADDR
// end ;
98297: LD_VAR 0 7
98301: RET
// export function EnemyInRange ( unit , dist ) ; begin
98302: LD_INT 0
98304: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98305: LD_ADDR_VAR 0 3
98309: PUSH
98310: LD_VAR 0 1
98314: PPUSH
98315: CALL_OW 255
98319: PPUSH
98320: LD_VAR 0 1
98324: PPUSH
98325: CALL_OW 250
98329: PPUSH
98330: LD_VAR 0 1
98334: PPUSH
98335: CALL_OW 251
98339: PPUSH
98340: LD_VAR 0 2
98344: PPUSH
98345: CALL 72406 0 4
98349: PUSH
98350: LD_INT 4
98352: ARRAY
98353: ST_TO_ADDR
// end ;
98354: LD_VAR 0 3
98358: RET
// export function PlayerSeeMe ( unit ) ; begin
98359: LD_INT 0
98361: PPUSH
// result := See ( your_side , unit ) ;
98362: LD_ADDR_VAR 0 2
98366: PUSH
98367: LD_OWVAR 2
98371: PPUSH
98372: LD_VAR 0 1
98376: PPUSH
98377: CALL_OW 292
98381: ST_TO_ADDR
// end ;
98382: LD_VAR 0 2
98386: RET
// export function ReverseDir ( unit ) ; begin
98387: LD_INT 0
98389: PPUSH
// if not unit then
98390: LD_VAR 0 1
98394: NOT
98395: IFFALSE 98399
// exit ;
98397: GO 98422
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98399: LD_ADDR_VAR 0 2
98403: PUSH
98404: LD_VAR 0 1
98408: PPUSH
98409: CALL_OW 254
98413: PUSH
98414: LD_INT 3
98416: PLUS
98417: PUSH
98418: LD_INT 6
98420: MOD
98421: ST_TO_ADDR
// end ;
98422: LD_VAR 0 2
98426: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98427: LD_INT 0
98429: PPUSH
98430: PPUSH
98431: PPUSH
98432: PPUSH
98433: PPUSH
// if not hexes then
98434: LD_VAR 0 2
98438: NOT
98439: IFFALSE 98443
// exit ;
98441: GO 98591
// dist := 9999 ;
98443: LD_ADDR_VAR 0 5
98447: PUSH
98448: LD_INT 9999
98450: ST_TO_ADDR
// for i = 1 to hexes do
98451: LD_ADDR_VAR 0 4
98455: PUSH
98456: DOUBLE
98457: LD_INT 1
98459: DEC
98460: ST_TO_ADDR
98461: LD_VAR 0 2
98465: PUSH
98466: FOR_TO
98467: IFFALSE 98579
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98469: LD_VAR 0 1
98473: PPUSH
98474: LD_VAR 0 2
98478: PUSH
98479: LD_VAR 0 4
98483: ARRAY
98484: PUSH
98485: LD_INT 1
98487: ARRAY
98488: PPUSH
98489: LD_VAR 0 2
98493: PUSH
98494: LD_VAR 0 4
98498: ARRAY
98499: PUSH
98500: LD_INT 2
98502: ARRAY
98503: PPUSH
98504: CALL_OW 297
98508: PUSH
98509: LD_VAR 0 5
98513: LESS
98514: IFFALSE 98577
// begin hex := hexes [ i ] ;
98516: LD_ADDR_VAR 0 7
98520: PUSH
98521: LD_VAR 0 2
98525: PUSH
98526: LD_VAR 0 4
98530: ARRAY
98531: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98532: LD_ADDR_VAR 0 5
98536: PUSH
98537: LD_VAR 0 1
98541: PPUSH
98542: LD_VAR 0 2
98546: PUSH
98547: LD_VAR 0 4
98551: ARRAY
98552: PUSH
98553: LD_INT 1
98555: ARRAY
98556: PPUSH
98557: LD_VAR 0 2
98561: PUSH
98562: LD_VAR 0 4
98566: ARRAY
98567: PUSH
98568: LD_INT 2
98570: ARRAY
98571: PPUSH
98572: CALL_OW 297
98576: ST_TO_ADDR
// end ; end ;
98577: GO 98466
98579: POP
98580: POP
// result := hex ;
98581: LD_ADDR_VAR 0 3
98585: PUSH
98586: LD_VAR 0 7
98590: ST_TO_ADDR
// end ;
98591: LD_VAR 0 3
98595: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98596: LD_INT 0
98598: PPUSH
98599: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98600: LD_VAR 0 1
98604: NOT
98605: PUSH
98606: LD_VAR 0 1
98610: PUSH
98611: LD_INT 21
98613: PUSH
98614: LD_INT 2
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: PUSH
98621: LD_INT 23
98623: PUSH
98624: LD_INT 2
98626: PUSH
98627: EMPTY
98628: LIST
98629: LIST
98630: PUSH
98631: EMPTY
98632: LIST
98633: LIST
98634: PPUSH
98635: CALL_OW 69
98639: IN
98640: NOT
98641: OR
98642: IFFALSE 98646
// exit ;
98644: GO 98693
// for i = 1 to 3 do
98646: LD_ADDR_VAR 0 3
98650: PUSH
98651: DOUBLE
98652: LD_INT 1
98654: DEC
98655: ST_TO_ADDR
98656: LD_INT 3
98658: PUSH
98659: FOR_TO
98660: IFFALSE 98691
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98662: LD_VAR 0 1
98666: PPUSH
98667: CALL_OW 250
98671: PPUSH
98672: LD_VAR 0 1
98676: PPUSH
98677: CALL_OW 251
98681: PPUSH
98682: LD_INT 1
98684: PPUSH
98685: CALL_OW 453
98689: GO 98659
98691: POP
98692: POP
// end ;
98693: LD_VAR 0 2
98697: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98698: LD_INT 0
98700: PPUSH
98701: PPUSH
98702: PPUSH
98703: PPUSH
98704: PPUSH
98705: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98706: LD_VAR 0 1
98710: NOT
98711: PUSH
98712: LD_VAR 0 2
98716: NOT
98717: OR
98718: PUSH
98719: LD_VAR 0 1
98723: PPUSH
98724: CALL_OW 314
98728: OR
98729: IFFALSE 98733
// exit ;
98731: GO 99174
// x := GetX ( enemy_unit ) ;
98733: LD_ADDR_VAR 0 7
98737: PUSH
98738: LD_VAR 0 2
98742: PPUSH
98743: CALL_OW 250
98747: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98748: LD_ADDR_VAR 0 8
98752: PUSH
98753: LD_VAR 0 2
98757: PPUSH
98758: CALL_OW 251
98762: ST_TO_ADDR
// if not x or not y then
98763: LD_VAR 0 7
98767: NOT
98768: PUSH
98769: LD_VAR 0 8
98773: NOT
98774: OR
98775: IFFALSE 98779
// exit ;
98777: GO 99174
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98779: LD_ADDR_VAR 0 6
98783: PUSH
98784: LD_VAR 0 7
98788: PPUSH
98789: LD_INT 0
98791: PPUSH
98792: LD_INT 4
98794: PPUSH
98795: CALL_OW 272
98799: PUSH
98800: LD_VAR 0 8
98804: PPUSH
98805: LD_INT 0
98807: PPUSH
98808: LD_INT 4
98810: PPUSH
98811: CALL_OW 273
98815: PUSH
98816: EMPTY
98817: LIST
98818: LIST
98819: PUSH
98820: LD_VAR 0 7
98824: PPUSH
98825: LD_INT 1
98827: PPUSH
98828: LD_INT 4
98830: PPUSH
98831: CALL_OW 272
98835: PUSH
98836: LD_VAR 0 8
98840: PPUSH
98841: LD_INT 1
98843: PPUSH
98844: LD_INT 4
98846: PPUSH
98847: CALL_OW 273
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: PUSH
98856: LD_VAR 0 7
98860: PPUSH
98861: LD_INT 2
98863: PPUSH
98864: LD_INT 4
98866: PPUSH
98867: CALL_OW 272
98871: PUSH
98872: LD_VAR 0 8
98876: PPUSH
98877: LD_INT 2
98879: PPUSH
98880: LD_INT 4
98882: PPUSH
98883: CALL_OW 273
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: PUSH
98892: LD_VAR 0 7
98896: PPUSH
98897: LD_INT 3
98899: PPUSH
98900: LD_INT 4
98902: PPUSH
98903: CALL_OW 272
98907: PUSH
98908: LD_VAR 0 8
98912: PPUSH
98913: LD_INT 3
98915: PPUSH
98916: LD_INT 4
98918: PPUSH
98919: CALL_OW 273
98923: PUSH
98924: EMPTY
98925: LIST
98926: LIST
98927: PUSH
98928: LD_VAR 0 7
98932: PPUSH
98933: LD_INT 4
98935: PPUSH
98936: LD_INT 4
98938: PPUSH
98939: CALL_OW 272
98943: PUSH
98944: LD_VAR 0 8
98948: PPUSH
98949: LD_INT 4
98951: PPUSH
98952: LD_INT 4
98954: PPUSH
98955: CALL_OW 273
98959: PUSH
98960: EMPTY
98961: LIST
98962: LIST
98963: PUSH
98964: LD_VAR 0 7
98968: PPUSH
98969: LD_INT 5
98971: PPUSH
98972: LD_INT 4
98974: PPUSH
98975: CALL_OW 272
98979: PUSH
98980: LD_VAR 0 8
98984: PPUSH
98985: LD_INT 5
98987: PPUSH
98988: LD_INT 4
98990: PPUSH
98991: CALL_OW 273
98995: PUSH
98996: EMPTY
98997: LIST
98998: LIST
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: LIST
99004: LIST
99005: LIST
99006: LIST
99007: ST_TO_ADDR
// for i = tmp downto 1 do
99008: LD_ADDR_VAR 0 4
99012: PUSH
99013: DOUBLE
99014: LD_VAR 0 6
99018: INC
99019: ST_TO_ADDR
99020: LD_INT 1
99022: PUSH
99023: FOR_DOWNTO
99024: IFFALSE 99125
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99026: LD_VAR 0 6
99030: PUSH
99031: LD_VAR 0 4
99035: ARRAY
99036: PUSH
99037: LD_INT 1
99039: ARRAY
99040: PPUSH
99041: LD_VAR 0 6
99045: PUSH
99046: LD_VAR 0 4
99050: ARRAY
99051: PUSH
99052: LD_INT 2
99054: ARRAY
99055: PPUSH
99056: CALL_OW 488
99060: NOT
99061: PUSH
99062: LD_VAR 0 6
99066: PUSH
99067: LD_VAR 0 4
99071: ARRAY
99072: PUSH
99073: LD_INT 1
99075: ARRAY
99076: PPUSH
99077: LD_VAR 0 6
99081: PUSH
99082: LD_VAR 0 4
99086: ARRAY
99087: PUSH
99088: LD_INT 2
99090: ARRAY
99091: PPUSH
99092: CALL_OW 428
99096: PUSH
99097: LD_INT 0
99099: NONEQUAL
99100: OR
99101: IFFALSE 99123
// tmp := Delete ( tmp , i ) ;
99103: LD_ADDR_VAR 0 6
99107: PUSH
99108: LD_VAR 0 6
99112: PPUSH
99113: LD_VAR 0 4
99117: PPUSH
99118: CALL_OW 3
99122: ST_TO_ADDR
99123: GO 99023
99125: POP
99126: POP
// j := GetClosestHex ( unit , tmp ) ;
99127: LD_ADDR_VAR 0 5
99131: PUSH
99132: LD_VAR 0 1
99136: PPUSH
99137: LD_VAR 0 6
99141: PPUSH
99142: CALL 98427 0 2
99146: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99147: LD_VAR 0 1
99151: PPUSH
99152: LD_VAR 0 5
99156: PUSH
99157: LD_INT 1
99159: ARRAY
99160: PPUSH
99161: LD_VAR 0 5
99165: PUSH
99166: LD_INT 2
99168: ARRAY
99169: PPUSH
99170: CALL_OW 111
// end ;
99174: LD_VAR 0 3
99178: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99179: LD_INT 0
99181: PPUSH
99182: PPUSH
99183: PPUSH
// uc_side = 0 ;
99184: LD_ADDR_OWVAR 20
99188: PUSH
99189: LD_INT 0
99191: ST_TO_ADDR
// uc_nation = 0 ;
99192: LD_ADDR_OWVAR 21
99196: PUSH
99197: LD_INT 0
99199: ST_TO_ADDR
// InitHc ;
99200: CALL_OW 19
// InitVc ;
99204: CALL_OW 20
// if mastodonts then
99208: LD_VAR 0 6
99212: IFFALSE 99279
// for i = 1 to mastodonts do
99214: LD_ADDR_VAR 0 11
99218: PUSH
99219: DOUBLE
99220: LD_INT 1
99222: DEC
99223: ST_TO_ADDR
99224: LD_VAR 0 6
99228: PUSH
99229: FOR_TO
99230: IFFALSE 99277
// begin vc_chassis := 31 ;
99232: LD_ADDR_OWVAR 37
99236: PUSH
99237: LD_INT 31
99239: ST_TO_ADDR
// vc_control := control_rider ;
99240: LD_ADDR_OWVAR 38
99244: PUSH
99245: LD_INT 4
99247: ST_TO_ADDR
// animal := CreateVehicle ;
99248: LD_ADDR_VAR 0 12
99252: PUSH
99253: CALL_OW 45
99257: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99258: LD_VAR 0 12
99262: PPUSH
99263: LD_VAR 0 8
99267: PPUSH
99268: LD_INT 0
99270: PPUSH
99271: CALL 106050 0 3
// end ;
99275: GO 99229
99277: POP
99278: POP
// if horses then
99279: LD_VAR 0 5
99283: IFFALSE 99350
// for i = 1 to horses do
99285: LD_ADDR_VAR 0 11
99289: PUSH
99290: DOUBLE
99291: LD_INT 1
99293: DEC
99294: ST_TO_ADDR
99295: LD_VAR 0 5
99299: PUSH
99300: FOR_TO
99301: IFFALSE 99348
// begin hc_class := 21 ;
99303: LD_ADDR_OWVAR 28
99307: PUSH
99308: LD_INT 21
99310: ST_TO_ADDR
// hc_gallery :=  ;
99311: LD_ADDR_OWVAR 33
99315: PUSH
99316: LD_STRING 
99318: ST_TO_ADDR
// animal := CreateHuman ;
99319: LD_ADDR_VAR 0 12
99323: PUSH
99324: CALL_OW 44
99328: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99329: LD_VAR 0 12
99333: PPUSH
99334: LD_VAR 0 8
99338: PPUSH
99339: LD_INT 0
99341: PPUSH
99342: CALL 106050 0 3
// end ;
99346: GO 99300
99348: POP
99349: POP
// if birds then
99350: LD_VAR 0 1
99354: IFFALSE 99421
// for i = 1 to birds do
99356: LD_ADDR_VAR 0 11
99360: PUSH
99361: DOUBLE
99362: LD_INT 1
99364: DEC
99365: ST_TO_ADDR
99366: LD_VAR 0 1
99370: PUSH
99371: FOR_TO
99372: IFFALSE 99419
// begin hc_class = 18 ;
99374: LD_ADDR_OWVAR 28
99378: PUSH
99379: LD_INT 18
99381: ST_TO_ADDR
// hc_gallery =  ;
99382: LD_ADDR_OWVAR 33
99386: PUSH
99387: LD_STRING 
99389: ST_TO_ADDR
// animal := CreateHuman ;
99390: LD_ADDR_VAR 0 12
99394: PUSH
99395: CALL_OW 44
99399: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99400: LD_VAR 0 12
99404: PPUSH
99405: LD_VAR 0 8
99409: PPUSH
99410: LD_INT 0
99412: PPUSH
99413: CALL 106050 0 3
// end ;
99417: GO 99371
99419: POP
99420: POP
// if tigers then
99421: LD_VAR 0 2
99425: IFFALSE 99509
// for i = 1 to tigers do
99427: LD_ADDR_VAR 0 11
99431: PUSH
99432: DOUBLE
99433: LD_INT 1
99435: DEC
99436: ST_TO_ADDR
99437: LD_VAR 0 2
99441: PUSH
99442: FOR_TO
99443: IFFALSE 99507
// begin hc_class = class_tiger ;
99445: LD_ADDR_OWVAR 28
99449: PUSH
99450: LD_INT 14
99452: ST_TO_ADDR
// hc_gallery =  ;
99453: LD_ADDR_OWVAR 33
99457: PUSH
99458: LD_STRING 
99460: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99461: LD_ADDR_OWVAR 35
99465: PUSH
99466: LD_INT 7
99468: NEG
99469: PPUSH
99470: LD_INT 7
99472: PPUSH
99473: CALL_OW 12
99477: ST_TO_ADDR
// animal := CreateHuman ;
99478: LD_ADDR_VAR 0 12
99482: PUSH
99483: CALL_OW 44
99487: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99488: LD_VAR 0 12
99492: PPUSH
99493: LD_VAR 0 8
99497: PPUSH
99498: LD_INT 0
99500: PPUSH
99501: CALL 106050 0 3
// end ;
99505: GO 99442
99507: POP
99508: POP
// if apemans then
99509: LD_VAR 0 3
99513: IFFALSE 99636
// for i = 1 to apemans do
99515: LD_ADDR_VAR 0 11
99519: PUSH
99520: DOUBLE
99521: LD_INT 1
99523: DEC
99524: ST_TO_ADDR
99525: LD_VAR 0 3
99529: PUSH
99530: FOR_TO
99531: IFFALSE 99634
// begin hc_class = class_apeman ;
99533: LD_ADDR_OWVAR 28
99537: PUSH
99538: LD_INT 12
99540: ST_TO_ADDR
// hc_gallery =  ;
99541: LD_ADDR_OWVAR 33
99545: PUSH
99546: LD_STRING 
99548: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99549: LD_ADDR_OWVAR 35
99553: PUSH
99554: LD_INT 5
99556: NEG
99557: PPUSH
99558: LD_INT 5
99560: PPUSH
99561: CALL_OW 12
99565: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99566: LD_ADDR_OWVAR 31
99570: PUSH
99571: LD_INT 1
99573: PPUSH
99574: LD_INT 3
99576: PPUSH
99577: CALL_OW 12
99581: PUSH
99582: LD_INT 1
99584: PPUSH
99585: LD_INT 3
99587: PPUSH
99588: CALL_OW 12
99592: PUSH
99593: LD_INT 0
99595: PUSH
99596: LD_INT 0
99598: PUSH
99599: EMPTY
99600: LIST
99601: LIST
99602: LIST
99603: LIST
99604: ST_TO_ADDR
// animal := CreateHuman ;
99605: LD_ADDR_VAR 0 12
99609: PUSH
99610: CALL_OW 44
99614: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99615: LD_VAR 0 12
99619: PPUSH
99620: LD_VAR 0 8
99624: PPUSH
99625: LD_INT 0
99627: PPUSH
99628: CALL 106050 0 3
// end ;
99632: GO 99530
99634: POP
99635: POP
// if enchidnas then
99636: LD_VAR 0 4
99640: IFFALSE 99707
// for i = 1 to enchidnas do
99642: LD_ADDR_VAR 0 11
99646: PUSH
99647: DOUBLE
99648: LD_INT 1
99650: DEC
99651: ST_TO_ADDR
99652: LD_VAR 0 4
99656: PUSH
99657: FOR_TO
99658: IFFALSE 99705
// begin hc_class = 13 ;
99660: LD_ADDR_OWVAR 28
99664: PUSH
99665: LD_INT 13
99667: ST_TO_ADDR
// hc_gallery =  ;
99668: LD_ADDR_OWVAR 33
99672: PUSH
99673: LD_STRING 
99675: ST_TO_ADDR
// animal := CreateHuman ;
99676: LD_ADDR_VAR 0 12
99680: PUSH
99681: CALL_OW 44
99685: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99686: LD_VAR 0 12
99690: PPUSH
99691: LD_VAR 0 8
99695: PPUSH
99696: LD_INT 0
99698: PPUSH
99699: CALL 106050 0 3
// end ;
99703: GO 99657
99705: POP
99706: POP
// if fishes then
99707: LD_VAR 0 7
99711: IFFALSE 99778
// for i = 1 to fishes do
99713: LD_ADDR_VAR 0 11
99717: PUSH
99718: DOUBLE
99719: LD_INT 1
99721: DEC
99722: ST_TO_ADDR
99723: LD_VAR 0 7
99727: PUSH
99728: FOR_TO
99729: IFFALSE 99776
// begin hc_class = 20 ;
99731: LD_ADDR_OWVAR 28
99735: PUSH
99736: LD_INT 20
99738: ST_TO_ADDR
// hc_gallery =  ;
99739: LD_ADDR_OWVAR 33
99743: PUSH
99744: LD_STRING 
99746: ST_TO_ADDR
// animal := CreateHuman ;
99747: LD_ADDR_VAR 0 12
99751: PUSH
99752: CALL_OW 44
99756: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99757: LD_VAR 0 12
99761: PPUSH
99762: LD_VAR 0 9
99766: PPUSH
99767: LD_INT 0
99769: PPUSH
99770: CALL 106050 0 3
// end ;
99774: GO 99728
99776: POP
99777: POP
// end ;
99778: LD_VAR 0 10
99782: RET
// export function WantHeal ( sci , unit ) ; begin
99783: LD_INT 0
99785: PPUSH
// if GetTaskList ( sci ) > 0 then
99786: LD_VAR 0 1
99790: PPUSH
99791: CALL_OW 437
99795: PUSH
99796: LD_INT 0
99798: GREATER
99799: IFFALSE 99869
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99801: LD_VAR 0 1
99805: PPUSH
99806: CALL_OW 437
99810: PUSH
99811: LD_INT 1
99813: ARRAY
99814: PUSH
99815: LD_INT 1
99817: ARRAY
99818: PUSH
99819: LD_STRING l
99821: EQUAL
99822: PUSH
99823: LD_VAR 0 1
99827: PPUSH
99828: CALL_OW 437
99832: PUSH
99833: LD_INT 1
99835: ARRAY
99836: PUSH
99837: LD_INT 4
99839: ARRAY
99840: PUSH
99841: LD_VAR 0 2
99845: EQUAL
99846: AND
99847: IFFALSE 99859
// result := true else
99849: LD_ADDR_VAR 0 3
99853: PUSH
99854: LD_INT 1
99856: ST_TO_ADDR
99857: GO 99867
// result := false ;
99859: LD_ADDR_VAR 0 3
99863: PUSH
99864: LD_INT 0
99866: ST_TO_ADDR
// end else
99867: GO 99877
// result := false ;
99869: LD_ADDR_VAR 0 3
99873: PUSH
99874: LD_INT 0
99876: ST_TO_ADDR
// end ;
99877: LD_VAR 0 3
99881: RET
// export function HealTarget ( sci ) ; begin
99882: LD_INT 0
99884: PPUSH
// if not sci then
99885: LD_VAR 0 1
99889: NOT
99890: IFFALSE 99894
// exit ;
99892: GO 99959
// result := 0 ;
99894: LD_ADDR_VAR 0 2
99898: PUSH
99899: LD_INT 0
99901: ST_TO_ADDR
// if GetTaskList ( sci ) then
99902: LD_VAR 0 1
99906: PPUSH
99907: CALL_OW 437
99911: IFFALSE 99959
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99913: LD_VAR 0 1
99917: PPUSH
99918: CALL_OW 437
99922: PUSH
99923: LD_INT 1
99925: ARRAY
99926: PUSH
99927: LD_INT 1
99929: ARRAY
99930: PUSH
99931: LD_STRING l
99933: EQUAL
99934: IFFALSE 99959
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99936: LD_ADDR_VAR 0 2
99940: PUSH
99941: LD_VAR 0 1
99945: PPUSH
99946: CALL_OW 437
99950: PUSH
99951: LD_INT 1
99953: ARRAY
99954: PUSH
99955: LD_INT 4
99957: ARRAY
99958: ST_TO_ADDR
// end ;
99959: LD_VAR 0 2
99963: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99964: LD_INT 0
99966: PPUSH
99967: PPUSH
99968: PPUSH
99969: PPUSH
99970: PPUSH
99971: PPUSH
99972: PPUSH
99973: PPUSH
99974: PPUSH
99975: PPUSH
99976: PPUSH
99977: PPUSH
99978: PPUSH
99979: PPUSH
99980: PPUSH
99981: PPUSH
99982: PPUSH
99983: PPUSH
99984: PPUSH
99985: PPUSH
99986: PPUSH
99987: PPUSH
99988: PPUSH
99989: PPUSH
99990: PPUSH
99991: PPUSH
99992: PPUSH
99993: PPUSH
99994: PPUSH
99995: PPUSH
99996: PPUSH
99997: PPUSH
99998: PPUSH
99999: PPUSH
// if not list then
100000: LD_VAR 0 1
100004: NOT
100005: IFFALSE 100009
// exit ;
100007: GO 104661
// base := list [ 1 ] ;
100009: LD_ADDR_VAR 0 3
100013: PUSH
100014: LD_VAR 0 1
100018: PUSH
100019: LD_INT 1
100021: ARRAY
100022: ST_TO_ADDR
// group := list [ 2 ] ;
100023: LD_ADDR_VAR 0 4
100027: PUSH
100028: LD_VAR 0 1
100032: PUSH
100033: LD_INT 2
100035: ARRAY
100036: ST_TO_ADDR
// path := list [ 3 ] ;
100037: LD_ADDR_VAR 0 5
100041: PUSH
100042: LD_VAR 0 1
100046: PUSH
100047: LD_INT 3
100049: ARRAY
100050: ST_TO_ADDR
// flags := list [ 4 ] ;
100051: LD_ADDR_VAR 0 6
100055: PUSH
100056: LD_VAR 0 1
100060: PUSH
100061: LD_INT 4
100063: ARRAY
100064: ST_TO_ADDR
// mined := [ ] ;
100065: LD_ADDR_VAR 0 27
100069: PUSH
100070: EMPTY
100071: ST_TO_ADDR
// bombed := [ ] ;
100072: LD_ADDR_VAR 0 28
100076: PUSH
100077: EMPTY
100078: ST_TO_ADDR
// healers := [ ] ;
100079: LD_ADDR_VAR 0 31
100083: PUSH
100084: EMPTY
100085: ST_TO_ADDR
// to_heal := [ ] ;
100086: LD_ADDR_VAR 0 30
100090: PUSH
100091: EMPTY
100092: ST_TO_ADDR
// repairs := [ ] ;
100093: LD_ADDR_VAR 0 33
100097: PUSH
100098: EMPTY
100099: ST_TO_ADDR
// to_repair := [ ] ;
100100: LD_ADDR_VAR 0 32
100104: PUSH
100105: EMPTY
100106: ST_TO_ADDR
// if not group or not path then
100107: LD_VAR 0 4
100111: NOT
100112: PUSH
100113: LD_VAR 0 5
100117: NOT
100118: OR
100119: IFFALSE 100123
// exit ;
100121: GO 104661
// side := GetSide ( group [ 1 ] ) ;
100123: LD_ADDR_VAR 0 35
100127: PUSH
100128: LD_VAR 0 4
100132: PUSH
100133: LD_INT 1
100135: ARRAY
100136: PPUSH
100137: CALL_OW 255
100141: ST_TO_ADDR
// if flags then
100142: LD_VAR 0 6
100146: IFFALSE 100290
// begin f_ignore_area := flags [ 1 ] ;
100148: LD_ADDR_VAR 0 17
100152: PUSH
100153: LD_VAR 0 6
100157: PUSH
100158: LD_INT 1
100160: ARRAY
100161: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100162: LD_ADDR_VAR 0 18
100166: PUSH
100167: LD_VAR 0 6
100171: PUSH
100172: LD_INT 2
100174: ARRAY
100175: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100176: LD_ADDR_VAR 0 19
100180: PUSH
100181: LD_VAR 0 6
100185: PUSH
100186: LD_INT 3
100188: ARRAY
100189: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100190: LD_ADDR_VAR 0 20
100194: PUSH
100195: LD_VAR 0 6
100199: PUSH
100200: LD_INT 4
100202: ARRAY
100203: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100204: LD_ADDR_VAR 0 21
100208: PUSH
100209: LD_VAR 0 6
100213: PUSH
100214: LD_INT 5
100216: ARRAY
100217: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100218: LD_ADDR_VAR 0 22
100222: PUSH
100223: LD_VAR 0 6
100227: PUSH
100228: LD_INT 6
100230: ARRAY
100231: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100232: LD_ADDR_VAR 0 23
100236: PUSH
100237: LD_VAR 0 6
100241: PUSH
100242: LD_INT 7
100244: ARRAY
100245: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100246: LD_ADDR_VAR 0 24
100250: PUSH
100251: LD_VAR 0 6
100255: PUSH
100256: LD_INT 8
100258: ARRAY
100259: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100260: LD_ADDR_VAR 0 25
100264: PUSH
100265: LD_VAR 0 6
100269: PUSH
100270: LD_INT 9
100272: ARRAY
100273: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100274: LD_ADDR_VAR 0 26
100278: PUSH
100279: LD_VAR 0 6
100283: PUSH
100284: LD_INT 10
100286: ARRAY
100287: ST_TO_ADDR
// end else
100288: GO 100370
// begin f_ignore_area := false ;
100290: LD_ADDR_VAR 0 17
100294: PUSH
100295: LD_INT 0
100297: ST_TO_ADDR
// f_capture := false ;
100298: LD_ADDR_VAR 0 18
100302: PUSH
100303: LD_INT 0
100305: ST_TO_ADDR
// f_ignore_civ := false ;
100306: LD_ADDR_VAR 0 19
100310: PUSH
100311: LD_INT 0
100313: ST_TO_ADDR
// f_murder := false ;
100314: LD_ADDR_VAR 0 20
100318: PUSH
100319: LD_INT 0
100321: ST_TO_ADDR
// f_mines := false ;
100322: LD_ADDR_VAR 0 21
100326: PUSH
100327: LD_INT 0
100329: ST_TO_ADDR
// f_repair := false ;
100330: LD_ADDR_VAR 0 22
100334: PUSH
100335: LD_INT 0
100337: ST_TO_ADDR
// f_heal := false ;
100338: LD_ADDR_VAR 0 23
100342: PUSH
100343: LD_INT 0
100345: ST_TO_ADDR
// f_spacetime := false ;
100346: LD_ADDR_VAR 0 24
100350: PUSH
100351: LD_INT 0
100353: ST_TO_ADDR
// f_attack_depot := false ;
100354: LD_ADDR_VAR 0 25
100358: PUSH
100359: LD_INT 0
100361: ST_TO_ADDR
// f_crawl := false ;
100362: LD_ADDR_VAR 0 26
100366: PUSH
100367: LD_INT 0
100369: ST_TO_ADDR
// end ; if f_heal then
100370: LD_VAR 0 23
100374: IFFALSE 100401
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100376: LD_ADDR_VAR 0 31
100380: PUSH
100381: LD_VAR 0 4
100385: PPUSH
100386: LD_INT 25
100388: PUSH
100389: LD_INT 4
100391: PUSH
100392: EMPTY
100393: LIST
100394: LIST
100395: PPUSH
100396: CALL_OW 72
100400: ST_TO_ADDR
// if f_repair then
100401: LD_VAR 0 22
100405: IFFALSE 100432
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100407: LD_ADDR_VAR 0 33
100411: PUSH
100412: LD_VAR 0 4
100416: PPUSH
100417: LD_INT 25
100419: PUSH
100420: LD_INT 3
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: PPUSH
100427: CALL_OW 72
100431: ST_TO_ADDR
// units_path := [ ] ;
100432: LD_ADDR_VAR 0 16
100436: PUSH
100437: EMPTY
100438: ST_TO_ADDR
// for i = 1 to group do
100439: LD_ADDR_VAR 0 7
100443: PUSH
100444: DOUBLE
100445: LD_INT 1
100447: DEC
100448: ST_TO_ADDR
100449: LD_VAR 0 4
100453: PUSH
100454: FOR_TO
100455: IFFALSE 100484
// units_path := Replace ( units_path , i , path ) ;
100457: LD_ADDR_VAR 0 16
100461: PUSH
100462: LD_VAR 0 16
100466: PPUSH
100467: LD_VAR 0 7
100471: PPUSH
100472: LD_VAR 0 5
100476: PPUSH
100477: CALL_OW 1
100481: ST_TO_ADDR
100482: GO 100454
100484: POP
100485: POP
// repeat for i = group downto 1 do
100486: LD_ADDR_VAR 0 7
100490: PUSH
100491: DOUBLE
100492: LD_VAR 0 4
100496: INC
100497: ST_TO_ADDR
100498: LD_INT 1
100500: PUSH
100501: FOR_DOWNTO
100502: IFFALSE 104624
// begin wait ( 5 ) ;
100504: LD_INT 5
100506: PPUSH
100507: CALL_OW 67
// tmp := [ ] ;
100511: LD_ADDR_VAR 0 14
100515: PUSH
100516: EMPTY
100517: ST_TO_ADDR
// attacking := false ;
100518: LD_ADDR_VAR 0 29
100522: PUSH
100523: LD_INT 0
100525: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100526: LD_VAR 0 4
100530: PUSH
100531: LD_VAR 0 7
100535: ARRAY
100536: PPUSH
100537: CALL_OW 301
100541: PUSH
100542: LD_VAR 0 4
100546: PUSH
100547: LD_VAR 0 7
100551: ARRAY
100552: NOT
100553: OR
100554: IFFALSE 100663
// begin if GetType ( group [ i ] ) = unit_human then
100556: LD_VAR 0 4
100560: PUSH
100561: LD_VAR 0 7
100565: ARRAY
100566: PPUSH
100567: CALL_OW 247
100571: PUSH
100572: LD_INT 1
100574: EQUAL
100575: IFFALSE 100621
// begin to_heal := to_heal diff group [ i ] ;
100577: LD_ADDR_VAR 0 30
100581: PUSH
100582: LD_VAR 0 30
100586: PUSH
100587: LD_VAR 0 4
100591: PUSH
100592: LD_VAR 0 7
100596: ARRAY
100597: DIFF
100598: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100599: LD_ADDR_VAR 0 31
100603: PUSH
100604: LD_VAR 0 31
100608: PUSH
100609: LD_VAR 0 4
100613: PUSH
100614: LD_VAR 0 7
100618: ARRAY
100619: DIFF
100620: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100621: LD_ADDR_VAR 0 4
100625: PUSH
100626: LD_VAR 0 4
100630: PPUSH
100631: LD_VAR 0 7
100635: PPUSH
100636: CALL_OW 3
100640: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100641: LD_ADDR_VAR 0 16
100645: PUSH
100646: LD_VAR 0 16
100650: PPUSH
100651: LD_VAR 0 7
100655: PPUSH
100656: CALL_OW 3
100660: ST_TO_ADDR
// continue ;
100661: GO 100501
// end ; if f_repair then
100663: LD_VAR 0 22
100667: IFFALSE 101156
// begin if GetType ( group [ i ] ) = unit_vehicle then
100669: LD_VAR 0 4
100673: PUSH
100674: LD_VAR 0 7
100678: ARRAY
100679: PPUSH
100680: CALL_OW 247
100684: PUSH
100685: LD_INT 2
100687: EQUAL
100688: IFFALSE 100878
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100690: LD_VAR 0 4
100694: PUSH
100695: LD_VAR 0 7
100699: ARRAY
100700: PPUSH
100701: CALL_OW 256
100705: PUSH
100706: LD_INT 700
100708: LESS
100709: PUSH
100710: LD_VAR 0 4
100714: PUSH
100715: LD_VAR 0 7
100719: ARRAY
100720: PUSH
100721: LD_VAR 0 32
100725: IN
100726: NOT
100727: AND
100728: IFFALSE 100752
// to_repair := to_repair union group [ i ] ;
100730: LD_ADDR_VAR 0 32
100734: PUSH
100735: LD_VAR 0 32
100739: PUSH
100740: LD_VAR 0 4
100744: PUSH
100745: LD_VAR 0 7
100749: ARRAY
100750: UNION
100751: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100752: LD_VAR 0 4
100756: PUSH
100757: LD_VAR 0 7
100761: ARRAY
100762: PPUSH
100763: CALL_OW 256
100767: PUSH
100768: LD_INT 1000
100770: EQUAL
100771: PUSH
100772: LD_VAR 0 4
100776: PUSH
100777: LD_VAR 0 7
100781: ARRAY
100782: PUSH
100783: LD_VAR 0 32
100787: IN
100788: AND
100789: IFFALSE 100813
// to_repair := to_repair diff group [ i ] ;
100791: LD_ADDR_VAR 0 32
100795: PUSH
100796: LD_VAR 0 32
100800: PUSH
100801: LD_VAR 0 4
100805: PUSH
100806: LD_VAR 0 7
100810: ARRAY
100811: DIFF
100812: ST_TO_ADDR
// if group [ i ] in to_repair then
100813: LD_VAR 0 4
100817: PUSH
100818: LD_VAR 0 7
100822: ARRAY
100823: PUSH
100824: LD_VAR 0 32
100828: IN
100829: IFFALSE 100876
// begin if not IsInArea ( group [ i ] , f_repair ) then
100831: LD_VAR 0 4
100835: PUSH
100836: LD_VAR 0 7
100840: ARRAY
100841: PPUSH
100842: LD_VAR 0 22
100846: PPUSH
100847: CALL_OW 308
100851: NOT
100852: IFFALSE 100874
// ComMoveToArea ( group [ i ] , f_repair ) ;
100854: LD_VAR 0 4
100858: PUSH
100859: LD_VAR 0 7
100863: ARRAY
100864: PPUSH
100865: LD_VAR 0 22
100869: PPUSH
100870: CALL_OW 113
// continue ;
100874: GO 100501
// end ; end else
100876: GO 101156
// if group [ i ] in repairs then
100878: LD_VAR 0 4
100882: PUSH
100883: LD_VAR 0 7
100887: ARRAY
100888: PUSH
100889: LD_VAR 0 33
100893: IN
100894: IFFALSE 101156
// begin if IsInUnit ( group [ i ] ) then
100896: LD_VAR 0 4
100900: PUSH
100901: LD_VAR 0 7
100905: ARRAY
100906: PPUSH
100907: CALL_OW 310
100911: IFFALSE 100979
// begin z := IsInUnit ( group [ i ] ) ;
100913: LD_ADDR_VAR 0 13
100917: PUSH
100918: LD_VAR 0 4
100922: PUSH
100923: LD_VAR 0 7
100927: ARRAY
100928: PPUSH
100929: CALL_OW 310
100933: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100934: LD_VAR 0 13
100938: PUSH
100939: LD_VAR 0 32
100943: IN
100944: PUSH
100945: LD_VAR 0 13
100949: PPUSH
100950: LD_VAR 0 22
100954: PPUSH
100955: CALL_OW 308
100959: AND
100960: IFFALSE 100977
// ComExitVehicle ( group [ i ] ) ;
100962: LD_VAR 0 4
100966: PUSH
100967: LD_VAR 0 7
100971: ARRAY
100972: PPUSH
100973: CALL_OW 121
// end else
100977: GO 101156
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100979: LD_ADDR_VAR 0 13
100983: PUSH
100984: LD_VAR 0 4
100988: PPUSH
100989: LD_INT 95
100991: PUSH
100992: LD_VAR 0 22
100996: PUSH
100997: EMPTY
100998: LIST
100999: LIST
101000: PUSH
101001: LD_INT 58
101003: PUSH
101004: EMPTY
101005: LIST
101006: PUSH
101007: EMPTY
101008: LIST
101009: LIST
101010: PPUSH
101011: CALL_OW 72
101015: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101016: LD_VAR 0 4
101020: PUSH
101021: LD_VAR 0 7
101025: ARRAY
101026: PPUSH
101027: CALL_OW 314
101031: NOT
101032: IFFALSE 101154
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101034: LD_ADDR_VAR 0 10
101038: PUSH
101039: LD_VAR 0 13
101043: PPUSH
101044: LD_VAR 0 4
101048: PUSH
101049: LD_VAR 0 7
101053: ARRAY
101054: PPUSH
101055: CALL_OW 74
101059: ST_TO_ADDR
// if not x then
101060: LD_VAR 0 10
101064: NOT
101065: IFFALSE 101069
// continue ;
101067: GO 100501
// if GetLives ( x ) < 1000 then
101069: LD_VAR 0 10
101073: PPUSH
101074: CALL_OW 256
101078: PUSH
101079: LD_INT 1000
101081: LESS
101082: IFFALSE 101106
// ComRepairVehicle ( group [ i ] , x ) else
101084: LD_VAR 0 4
101088: PUSH
101089: LD_VAR 0 7
101093: ARRAY
101094: PPUSH
101095: LD_VAR 0 10
101099: PPUSH
101100: CALL_OW 129
101104: GO 101154
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101106: LD_VAR 0 23
101110: PUSH
101111: LD_VAR 0 4
101115: PUSH
101116: LD_VAR 0 7
101120: ARRAY
101121: PPUSH
101122: CALL_OW 256
101126: PUSH
101127: LD_INT 1000
101129: LESS
101130: AND
101131: NOT
101132: IFFALSE 101154
// ComEnterUnit ( group [ i ] , x ) ;
101134: LD_VAR 0 4
101138: PUSH
101139: LD_VAR 0 7
101143: ARRAY
101144: PPUSH
101145: LD_VAR 0 10
101149: PPUSH
101150: CALL_OW 120
// end ; continue ;
101154: GO 100501
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101156: LD_VAR 0 23
101160: PUSH
101161: LD_VAR 0 4
101165: PUSH
101166: LD_VAR 0 7
101170: ARRAY
101171: PPUSH
101172: CALL_OW 247
101176: PUSH
101177: LD_INT 1
101179: EQUAL
101180: AND
101181: IFFALSE 101659
// begin if group [ i ] in healers then
101183: LD_VAR 0 4
101187: PUSH
101188: LD_VAR 0 7
101192: ARRAY
101193: PUSH
101194: LD_VAR 0 31
101198: IN
101199: IFFALSE 101472
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101201: LD_VAR 0 4
101205: PUSH
101206: LD_VAR 0 7
101210: ARRAY
101211: PPUSH
101212: LD_VAR 0 23
101216: PPUSH
101217: CALL_OW 308
101221: NOT
101222: PUSH
101223: LD_VAR 0 4
101227: PUSH
101228: LD_VAR 0 7
101232: ARRAY
101233: PPUSH
101234: CALL_OW 314
101238: NOT
101239: AND
101240: IFFALSE 101264
// ComMoveToArea ( group [ i ] , f_heal ) else
101242: LD_VAR 0 4
101246: PUSH
101247: LD_VAR 0 7
101251: ARRAY
101252: PPUSH
101253: LD_VAR 0 23
101257: PPUSH
101258: CALL_OW 113
101262: GO 101470
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101264: LD_VAR 0 4
101268: PUSH
101269: LD_VAR 0 7
101273: ARRAY
101274: PPUSH
101275: CALL 99882 0 1
101279: PPUSH
101280: CALL_OW 256
101284: PUSH
101285: LD_INT 1000
101287: EQUAL
101288: IFFALSE 101307
// ComStop ( group [ i ] ) else
101290: LD_VAR 0 4
101294: PUSH
101295: LD_VAR 0 7
101299: ARRAY
101300: PPUSH
101301: CALL_OW 141
101305: GO 101470
// if not HasTask ( group [ i ] ) and to_heal then
101307: LD_VAR 0 4
101311: PUSH
101312: LD_VAR 0 7
101316: ARRAY
101317: PPUSH
101318: CALL_OW 314
101322: NOT
101323: PUSH
101324: LD_VAR 0 30
101328: AND
101329: IFFALSE 101470
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101331: LD_ADDR_VAR 0 13
101335: PUSH
101336: LD_VAR 0 30
101340: PPUSH
101341: LD_INT 3
101343: PUSH
101344: LD_INT 54
101346: PUSH
101347: EMPTY
101348: LIST
101349: PUSH
101350: EMPTY
101351: LIST
101352: LIST
101353: PPUSH
101354: CALL_OW 72
101358: PPUSH
101359: LD_VAR 0 4
101363: PUSH
101364: LD_VAR 0 7
101368: ARRAY
101369: PPUSH
101370: CALL_OW 74
101374: ST_TO_ADDR
// if z then
101375: LD_VAR 0 13
101379: IFFALSE 101470
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101381: LD_INT 91
101383: PUSH
101384: LD_VAR 0 13
101388: PUSH
101389: LD_INT 10
101391: PUSH
101392: EMPTY
101393: LIST
101394: LIST
101395: LIST
101396: PUSH
101397: LD_INT 81
101399: PUSH
101400: LD_VAR 0 13
101404: PPUSH
101405: CALL_OW 255
101409: PUSH
101410: EMPTY
101411: LIST
101412: LIST
101413: PUSH
101414: EMPTY
101415: LIST
101416: LIST
101417: PPUSH
101418: CALL_OW 69
101422: PUSH
101423: LD_INT 0
101425: EQUAL
101426: IFFALSE 101450
// ComHeal ( group [ i ] , z ) else
101428: LD_VAR 0 4
101432: PUSH
101433: LD_VAR 0 7
101437: ARRAY
101438: PPUSH
101439: LD_VAR 0 13
101443: PPUSH
101444: CALL_OW 128
101448: GO 101470
// ComMoveToArea ( group [ i ] , f_heal ) ;
101450: LD_VAR 0 4
101454: PUSH
101455: LD_VAR 0 7
101459: ARRAY
101460: PPUSH
101461: LD_VAR 0 23
101465: PPUSH
101466: CALL_OW 113
// end ; continue ;
101470: GO 100501
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101472: LD_VAR 0 4
101476: PUSH
101477: LD_VAR 0 7
101481: ARRAY
101482: PPUSH
101483: CALL_OW 256
101487: PUSH
101488: LD_INT 700
101490: LESS
101491: PUSH
101492: LD_VAR 0 4
101496: PUSH
101497: LD_VAR 0 7
101501: ARRAY
101502: PUSH
101503: LD_VAR 0 30
101507: IN
101508: NOT
101509: AND
101510: IFFALSE 101534
// to_heal := to_heal union group [ i ] ;
101512: LD_ADDR_VAR 0 30
101516: PUSH
101517: LD_VAR 0 30
101521: PUSH
101522: LD_VAR 0 4
101526: PUSH
101527: LD_VAR 0 7
101531: ARRAY
101532: UNION
101533: ST_TO_ADDR
// if group [ i ] in to_heal then
101534: LD_VAR 0 4
101538: PUSH
101539: LD_VAR 0 7
101543: ARRAY
101544: PUSH
101545: LD_VAR 0 30
101549: IN
101550: IFFALSE 101659
// begin if GetLives ( group [ i ] ) = 1000 then
101552: LD_VAR 0 4
101556: PUSH
101557: LD_VAR 0 7
101561: ARRAY
101562: PPUSH
101563: CALL_OW 256
101567: PUSH
101568: LD_INT 1000
101570: EQUAL
101571: IFFALSE 101597
// to_heal := to_heal diff group [ i ] else
101573: LD_ADDR_VAR 0 30
101577: PUSH
101578: LD_VAR 0 30
101582: PUSH
101583: LD_VAR 0 4
101587: PUSH
101588: LD_VAR 0 7
101592: ARRAY
101593: DIFF
101594: ST_TO_ADDR
101595: GO 101659
// begin if not IsInArea ( group [ i ] , to_heal ) then
101597: LD_VAR 0 4
101601: PUSH
101602: LD_VAR 0 7
101606: ARRAY
101607: PPUSH
101608: LD_VAR 0 30
101612: PPUSH
101613: CALL_OW 308
101617: NOT
101618: IFFALSE 101642
// ComMoveToArea ( group [ i ] , f_heal ) else
101620: LD_VAR 0 4
101624: PUSH
101625: LD_VAR 0 7
101629: ARRAY
101630: PPUSH
101631: LD_VAR 0 23
101635: PPUSH
101636: CALL_OW 113
101640: GO 101657
// ComHold ( group [ i ] ) ;
101642: LD_VAR 0 4
101646: PUSH
101647: LD_VAR 0 7
101651: ARRAY
101652: PPUSH
101653: CALL_OW 140
// continue ;
101657: GO 100501
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101659: LD_VAR 0 4
101663: PUSH
101664: LD_VAR 0 7
101668: ARRAY
101669: PPUSH
101670: LD_INT 10
101672: PPUSH
101673: CALL 98302 0 2
101677: NOT
101678: PUSH
101679: LD_VAR 0 16
101683: PUSH
101684: LD_VAR 0 7
101688: ARRAY
101689: PUSH
101690: EMPTY
101691: EQUAL
101692: NOT
101693: AND
101694: IFFALSE 101960
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101696: LD_VAR 0 4
101700: PUSH
101701: LD_VAR 0 7
101705: ARRAY
101706: PPUSH
101707: CALL_OW 262
101711: PUSH
101712: LD_INT 1
101714: PUSH
101715: LD_INT 2
101717: PUSH
101718: EMPTY
101719: LIST
101720: LIST
101721: IN
101722: IFFALSE 101763
// if GetFuel ( group [ i ] ) < 10 then
101724: LD_VAR 0 4
101728: PUSH
101729: LD_VAR 0 7
101733: ARRAY
101734: PPUSH
101735: CALL_OW 261
101739: PUSH
101740: LD_INT 10
101742: LESS
101743: IFFALSE 101763
// SetFuel ( group [ i ] , 12 ) ;
101745: LD_VAR 0 4
101749: PUSH
101750: LD_VAR 0 7
101754: ARRAY
101755: PPUSH
101756: LD_INT 12
101758: PPUSH
101759: CALL_OW 240
// if units_path [ i ] then
101763: LD_VAR 0 16
101767: PUSH
101768: LD_VAR 0 7
101772: ARRAY
101773: IFFALSE 101958
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101775: LD_VAR 0 4
101779: PUSH
101780: LD_VAR 0 7
101784: ARRAY
101785: PPUSH
101786: LD_VAR 0 16
101790: PUSH
101791: LD_VAR 0 7
101795: ARRAY
101796: PUSH
101797: LD_INT 1
101799: ARRAY
101800: PUSH
101801: LD_INT 1
101803: ARRAY
101804: PPUSH
101805: LD_VAR 0 16
101809: PUSH
101810: LD_VAR 0 7
101814: ARRAY
101815: PUSH
101816: LD_INT 1
101818: ARRAY
101819: PUSH
101820: LD_INT 2
101822: ARRAY
101823: PPUSH
101824: CALL_OW 297
101828: PUSH
101829: LD_INT 6
101831: GREATER
101832: IFFALSE 101907
// begin if not HasTask ( group [ i ] ) then
101834: LD_VAR 0 4
101838: PUSH
101839: LD_VAR 0 7
101843: ARRAY
101844: PPUSH
101845: CALL_OW 314
101849: NOT
101850: IFFALSE 101905
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101852: LD_VAR 0 4
101856: PUSH
101857: LD_VAR 0 7
101861: ARRAY
101862: PPUSH
101863: LD_VAR 0 16
101867: PUSH
101868: LD_VAR 0 7
101872: ARRAY
101873: PUSH
101874: LD_INT 1
101876: ARRAY
101877: PUSH
101878: LD_INT 1
101880: ARRAY
101881: PPUSH
101882: LD_VAR 0 16
101886: PUSH
101887: LD_VAR 0 7
101891: ARRAY
101892: PUSH
101893: LD_INT 1
101895: ARRAY
101896: PUSH
101897: LD_INT 2
101899: ARRAY
101900: PPUSH
101901: CALL_OW 114
// end else
101905: GO 101958
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101907: LD_ADDR_VAR 0 15
101911: PUSH
101912: LD_VAR 0 16
101916: PUSH
101917: LD_VAR 0 7
101921: ARRAY
101922: PPUSH
101923: LD_INT 1
101925: PPUSH
101926: CALL_OW 3
101930: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101931: LD_ADDR_VAR 0 16
101935: PUSH
101936: LD_VAR 0 16
101940: PPUSH
101941: LD_VAR 0 7
101945: PPUSH
101946: LD_VAR 0 15
101950: PPUSH
101951: CALL_OW 1
101955: ST_TO_ADDR
// continue ;
101956: GO 100501
// end ; end ; end else
101958: GO 104622
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101960: LD_ADDR_VAR 0 14
101964: PUSH
101965: LD_INT 81
101967: PUSH
101968: LD_VAR 0 4
101972: PUSH
101973: LD_VAR 0 7
101977: ARRAY
101978: PPUSH
101979: CALL_OW 255
101983: PUSH
101984: EMPTY
101985: LIST
101986: LIST
101987: PPUSH
101988: CALL_OW 69
101992: ST_TO_ADDR
// if not tmp then
101993: LD_VAR 0 14
101997: NOT
101998: IFFALSE 102002
// continue ;
102000: GO 100501
// if f_ignore_area then
102002: LD_VAR 0 17
102006: IFFALSE 102094
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102008: LD_ADDR_VAR 0 15
102012: PUSH
102013: LD_VAR 0 14
102017: PPUSH
102018: LD_INT 3
102020: PUSH
102021: LD_INT 92
102023: PUSH
102024: LD_VAR 0 17
102028: PUSH
102029: LD_INT 1
102031: ARRAY
102032: PUSH
102033: LD_VAR 0 17
102037: PUSH
102038: LD_INT 2
102040: ARRAY
102041: PUSH
102042: LD_VAR 0 17
102046: PUSH
102047: LD_INT 3
102049: ARRAY
102050: PUSH
102051: EMPTY
102052: LIST
102053: LIST
102054: LIST
102055: LIST
102056: PUSH
102057: EMPTY
102058: LIST
102059: LIST
102060: PPUSH
102061: CALL_OW 72
102065: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102066: LD_VAR 0 14
102070: PUSH
102071: LD_VAR 0 15
102075: DIFF
102076: IFFALSE 102094
// tmp := tmp diff tmp2 ;
102078: LD_ADDR_VAR 0 14
102082: PUSH
102083: LD_VAR 0 14
102087: PUSH
102088: LD_VAR 0 15
102092: DIFF
102093: ST_TO_ADDR
// end ; if not f_murder then
102094: LD_VAR 0 20
102098: NOT
102099: IFFALSE 102157
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102101: LD_ADDR_VAR 0 15
102105: PUSH
102106: LD_VAR 0 14
102110: PPUSH
102111: LD_INT 3
102113: PUSH
102114: LD_INT 50
102116: PUSH
102117: EMPTY
102118: LIST
102119: PUSH
102120: EMPTY
102121: LIST
102122: LIST
102123: PPUSH
102124: CALL_OW 72
102128: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102129: LD_VAR 0 14
102133: PUSH
102134: LD_VAR 0 15
102138: DIFF
102139: IFFALSE 102157
// tmp := tmp diff tmp2 ;
102141: LD_ADDR_VAR 0 14
102145: PUSH
102146: LD_VAR 0 14
102150: PUSH
102151: LD_VAR 0 15
102155: DIFF
102156: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102157: LD_ADDR_VAR 0 14
102161: PUSH
102162: LD_VAR 0 4
102166: PUSH
102167: LD_VAR 0 7
102171: ARRAY
102172: PPUSH
102173: LD_VAR 0 14
102177: PPUSH
102178: LD_INT 1
102180: PPUSH
102181: LD_INT 1
102183: PPUSH
102184: CALL 71945 0 4
102188: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102189: LD_VAR 0 4
102193: PUSH
102194: LD_VAR 0 7
102198: ARRAY
102199: PPUSH
102200: CALL_OW 257
102204: PUSH
102205: LD_INT 1
102207: EQUAL
102208: IFFALSE 102656
// begin if WantPlant ( group [ i ] ) then
102210: LD_VAR 0 4
102214: PUSH
102215: LD_VAR 0 7
102219: ARRAY
102220: PPUSH
102221: CALL 71446 0 1
102225: IFFALSE 102229
// continue ;
102227: GO 100501
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102229: LD_VAR 0 18
102233: PUSH
102234: LD_VAR 0 4
102238: PUSH
102239: LD_VAR 0 7
102243: ARRAY
102244: PPUSH
102245: CALL_OW 310
102249: NOT
102250: AND
102251: PUSH
102252: LD_VAR 0 14
102256: PUSH
102257: LD_INT 1
102259: ARRAY
102260: PUSH
102261: LD_VAR 0 14
102265: PPUSH
102266: LD_INT 21
102268: PUSH
102269: LD_INT 2
102271: PUSH
102272: EMPTY
102273: LIST
102274: LIST
102275: PUSH
102276: LD_INT 58
102278: PUSH
102279: EMPTY
102280: LIST
102281: PUSH
102282: EMPTY
102283: LIST
102284: LIST
102285: PPUSH
102286: CALL_OW 72
102290: IN
102291: AND
102292: IFFALSE 102328
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102294: LD_VAR 0 4
102298: PUSH
102299: LD_VAR 0 7
102303: ARRAY
102304: PPUSH
102305: LD_VAR 0 14
102309: PUSH
102310: LD_INT 1
102312: ARRAY
102313: PPUSH
102314: CALL_OW 120
// attacking := true ;
102318: LD_ADDR_VAR 0 29
102322: PUSH
102323: LD_INT 1
102325: ST_TO_ADDR
// continue ;
102326: GO 100501
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102328: LD_VAR 0 26
102332: PUSH
102333: LD_VAR 0 4
102337: PUSH
102338: LD_VAR 0 7
102342: ARRAY
102343: PPUSH
102344: CALL_OW 257
102348: PUSH
102349: LD_INT 1
102351: EQUAL
102352: AND
102353: PUSH
102354: LD_VAR 0 4
102358: PUSH
102359: LD_VAR 0 7
102363: ARRAY
102364: PPUSH
102365: CALL_OW 256
102369: PUSH
102370: LD_INT 800
102372: LESS
102373: AND
102374: PUSH
102375: LD_VAR 0 4
102379: PUSH
102380: LD_VAR 0 7
102384: ARRAY
102385: PPUSH
102386: CALL_OW 318
102390: NOT
102391: AND
102392: IFFALSE 102409
// ComCrawl ( group [ i ] ) ;
102394: LD_VAR 0 4
102398: PUSH
102399: LD_VAR 0 7
102403: ARRAY
102404: PPUSH
102405: CALL_OW 137
// if f_mines then
102409: LD_VAR 0 21
102413: IFFALSE 102656
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102415: LD_VAR 0 14
102419: PUSH
102420: LD_INT 1
102422: ARRAY
102423: PPUSH
102424: CALL_OW 247
102428: PUSH
102429: LD_INT 3
102431: EQUAL
102432: PUSH
102433: LD_VAR 0 14
102437: PUSH
102438: LD_INT 1
102440: ARRAY
102441: PUSH
102442: LD_VAR 0 27
102446: IN
102447: NOT
102448: AND
102449: IFFALSE 102656
// begin x := GetX ( tmp [ 1 ] ) ;
102451: LD_ADDR_VAR 0 10
102455: PUSH
102456: LD_VAR 0 14
102460: PUSH
102461: LD_INT 1
102463: ARRAY
102464: PPUSH
102465: CALL_OW 250
102469: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102470: LD_ADDR_VAR 0 11
102474: PUSH
102475: LD_VAR 0 14
102479: PUSH
102480: LD_INT 1
102482: ARRAY
102483: PPUSH
102484: CALL_OW 251
102488: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102489: LD_ADDR_VAR 0 12
102493: PUSH
102494: LD_VAR 0 4
102498: PUSH
102499: LD_VAR 0 7
102503: ARRAY
102504: PPUSH
102505: CALL 98387 0 1
102509: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102510: LD_VAR 0 4
102514: PUSH
102515: LD_VAR 0 7
102519: ARRAY
102520: PPUSH
102521: LD_VAR 0 10
102525: PPUSH
102526: LD_VAR 0 11
102530: PPUSH
102531: LD_VAR 0 14
102535: PUSH
102536: LD_INT 1
102538: ARRAY
102539: PPUSH
102540: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102544: LD_VAR 0 4
102548: PUSH
102549: LD_VAR 0 7
102553: ARRAY
102554: PPUSH
102555: LD_VAR 0 10
102559: PPUSH
102560: LD_VAR 0 12
102564: PPUSH
102565: LD_INT 7
102567: PPUSH
102568: CALL_OW 272
102572: PPUSH
102573: LD_VAR 0 11
102577: PPUSH
102578: LD_VAR 0 12
102582: PPUSH
102583: LD_INT 7
102585: PPUSH
102586: CALL_OW 273
102590: PPUSH
102591: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102595: LD_VAR 0 4
102599: PUSH
102600: LD_VAR 0 7
102604: ARRAY
102605: PPUSH
102606: LD_INT 71
102608: PPUSH
102609: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102613: LD_ADDR_VAR 0 27
102617: PUSH
102618: LD_VAR 0 27
102622: PPUSH
102623: LD_VAR 0 27
102627: PUSH
102628: LD_INT 1
102630: PLUS
102631: PPUSH
102632: LD_VAR 0 14
102636: PUSH
102637: LD_INT 1
102639: ARRAY
102640: PPUSH
102641: CALL_OW 1
102645: ST_TO_ADDR
// attacking := true ;
102646: LD_ADDR_VAR 0 29
102650: PUSH
102651: LD_INT 1
102653: ST_TO_ADDR
// continue ;
102654: GO 100501
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102656: LD_VAR 0 4
102660: PUSH
102661: LD_VAR 0 7
102665: ARRAY
102666: PPUSH
102667: CALL_OW 257
102671: PUSH
102672: LD_INT 17
102674: EQUAL
102675: PUSH
102676: LD_VAR 0 4
102680: PUSH
102681: LD_VAR 0 7
102685: ARRAY
102686: PPUSH
102687: CALL_OW 110
102691: PUSH
102692: LD_INT 71
102694: EQUAL
102695: NOT
102696: AND
102697: IFFALSE 102843
// begin attacking := false ;
102699: LD_ADDR_VAR 0 29
102703: PUSH
102704: LD_INT 0
102706: ST_TO_ADDR
// k := 5 ;
102707: LD_ADDR_VAR 0 9
102711: PUSH
102712: LD_INT 5
102714: ST_TO_ADDR
// if tmp < k then
102715: LD_VAR 0 14
102719: PUSH
102720: LD_VAR 0 9
102724: LESS
102725: IFFALSE 102737
// k := tmp ;
102727: LD_ADDR_VAR 0 9
102731: PUSH
102732: LD_VAR 0 14
102736: ST_TO_ADDR
// for j = 1 to k do
102737: LD_ADDR_VAR 0 8
102741: PUSH
102742: DOUBLE
102743: LD_INT 1
102745: DEC
102746: ST_TO_ADDR
102747: LD_VAR 0 9
102751: PUSH
102752: FOR_TO
102753: IFFALSE 102841
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102755: LD_VAR 0 14
102759: PUSH
102760: LD_VAR 0 8
102764: ARRAY
102765: PUSH
102766: LD_VAR 0 14
102770: PPUSH
102771: LD_INT 58
102773: PUSH
102774: EMPTY
102775: LIST
102776: PPUSH
102777: CALL_OW 72
102781: IN
102782: NOT
102783: IFFALSE 102839
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102785: LD_VAR 0 4
102789: PUSH
102790: LD_VAR 0 7
102794: ARRAY
102795: PPUSH
102796: LD_VAR 0 14
102800: PUSH
102801: LD_VAR 0 8
102805: ARRAY
102806: PPUSH
102807: CALL_OW 115
// attacking := true ;
102811: LD_ADDR_VAR 0 29
102815: PUSH
102816: LD_INT 1
102818: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102819: LD_VAR 0 4
102823: PUSH
102824: LD_VAR 0 7
102828: ARRAY
102829: PPUSH
102830: LD_INT 71
102832: PPUSH
102833: CALL_OW 109
// continue ;
102837: GO 102752
// end ; end ;
102839: GO 102752
102841: POP
102842: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102843: LD_VAR 0 4
102847: PUSH
102848: LD_VAR 0 7
102852: ARRAY
102853: PPUSH
102854: CALL_OW 257
102858: PUSH
102859: LD_INT 8
102861: EQUAL
102862: PUSH
102863: LD_VAR 0 4
102867: PUSH
102868: LD_VAR 0 7
102872: ARRAY
102873: PPUSH
102874: CALL_OW 264
102878: PUSH
102879: LD_INT 28
102881: PUSH
102882: LD_INT 45
102884: PUSH
102885: LD_INT 7
102887: PUSH
102888: LD_INT 47
102890: PUSH
102891: EMPTY
102892: LIST
102893: LIST
102894: LIST
102895: LIST
102896: IN
102897: OR
102898: IFFALSE 103154
// begin attacking := false ;
102900: LD_ADDR_VAR 0 29
102904: PUSH
102905: LD_INT 0
102907: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102908: LD_VAR 0 14
102912: PUSH
102913: LD_INT 1
102915: ARRAY
102916: PPUSH
102917: CALL_OW 266
102921: PUSH
102922: LD_INT 32
102924: PUSH
102925: LD_INT 31
102927: PUSH
102928: LD_INT 33
102930: PUSH
102931: LD_INT 4
102933: PUSH
102934: LD_INT 5
102936: PUSH
102937: EMPTY
102938: LIST
102939: LIST
102940: LIST
102941: LIST
102942: LIST
102943: IN
102944: IFFALSE 103130
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102946: LD_ADDR_VAR 0 9
102950: PUSH
102951: LD_VAR 0 14
102955: PUSH
102956: LD_INT 1
102958: ARRAY
102959: PPUSH
102960: CALL_OW 266
102964: PPUSH
102965: LD_VAR 0 14
102969: PUSH
102970: LD_INT 1
102972: ARRAY
102973: PPUSH
102974: CALL_OW 250
102978: PPUSH
102979: LD_VAR 0 14
102983: PUSH
102984: LD_INT 1
102986: ARRAY
102987: PPUSH
102988: CALL_OW 251
102992: PPUSH
102993: LD_VAR 0 14
102997: PUSH
102998: LD_INT 1
103000: ARRAY
103001: PPUSH
103002: CALL_OW 254
103006: PPUSH
103007: LD_VAR 0 14
103011: PUSH
103012: LD_INT 1
103014: ARRAY
103015: PPUSH
103016: CALL_OW 248
103020: PPUSH
103021: LD_INT 0
103023: PPUSH
103024: CALL 79757 0 6
103028: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103029: LD_ADDR_VAR 0 8
103033: PUSH
103034: LD_VAR 0 4
103038: PUSH
103039: LD_VAR 0 7
103043: ARRAY
103044: PPUSH
103045: LD_VAR 0 9
103049: PPUSH
103050: CALL 98427 0 2
103054: ST_TO_ADDR
// if j then
103055: LD_VAR 0 8
103059: IFFALSE 103128
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103061: LD_VAR 0 8
103065: PUSH
103066: LD_INT 1
103068: ARRAY
103069: PPUSH
103070: LD_VAR 0 8
103074: PUSH
103075: LD_INT 2
103077: ARRAY
103078: PPUSH
103079: CALL_OW 488
103083: IFFALSE 103128
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103085: LD_VAR 0 4
103089: PUSH
103090: LD_VAR 0 7
103094: ARRAY
103095: PPUSH
103096: LD_VAR 0 8
103100: PUSH
103101: LD_INT 1
103103: ARRAY
103104: PPUSH
103105: LD_VAR 0 8
103109: PUSH
103110: LD_INT 2
103112: ARRAY
103113: PPUSH
103114: CALL_OW 116
// attacking := true ;
103118: LD_ADDR_VAR 0 29
103122: PUSH
103123: LD_INT 1
103125: ST_TO_ADDR
// continue ;
103126: GO 100501
// end ; end else
103128: GO 103154
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103130: LD_VAR 0 4
103134: PUSH
103135: LD_VAR 0 7
103139: ARRAY
103140: PPUSH
103141: LD_VAR 0 14
103145: PUSH
103146: LD_INT 1
103148: ARRAY
103149: PPUSH
103150: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103154: LD_VAR 0 4
103158: PUSH
103159: LD_VAR 0 7
103163: ARRAY
103164: PPUSH
103165: CALL_OW 265
103169: PUSH
103170: LD_INT 11
103172: EQUAL
103173: IFFALSE 103451
// begin k := 10 ;
103175: LD_ADDR_VAR 0 9
103179: PUSH
103180: LD_INT 10
103182: ST_TO_ADDR
// x := 0 ;
103183: LD_ADDR_VAR 0 10
103187: PUSH
103188: LD_INT 0
103190: ST_TO_ADDR
// if tmp < k then
103191: LD_VAR 0 14
103195: PUSH
103196: LD_VAR 0 9
103200: LESS
103201: IFFALSE 103213
// k := tmp ;
103203: LD_ADDR_VAR 0 9
103207: PUSH
103208: LD_VAR 0 14
103212: ST_TO_ADDR
// for j = k downto 1 do
103213: LD_ADDR_VAR 0 8
103217: PUSH
103218: DOUBLE
103219: LD_VAR 0 9
103223: INC
103224: ST_TO_ADDR
103225: LD_INT 1
103227: PUSH
103228: FOR_DOWNTO
103229: IFFALSE 103304
// begin if GetType ( tmp [ j ] ) = unit_human then
103231: LD_VAR 0 14
103235: PUSH
103236: LD_VAR 0 8
103240: ARRAY
103241: PPUSH
103242: CALL_OW 247
103246: PUSH
103247: LD_INT 1
103249: EQUAL
103250: IFFALSE 103302
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103252: LD_VAR 0 4
103256: PUSH
103257: LD_VAR 0 7
103261: ARRAY
103262: PPUSH
103263: LD_VAR 0 14
103267: PUSH
103268: LD_VAR 0 8
103272: ARRAY
103273: PPUSH
103274: CALL 98698 0 2
// x := tmp [ j ] ;
103278: LD_ADDR_VAR 0 10
103282: PUSH
103283: LD_VAR 0 14
103287: PUSH
103288: LD_VAR 0 8
103292: ARRAY
103293: ST_TO_ADDR
// attacking := true ;
103294: LD_ADDR_VAR 0 29
103298: PUSH
103299: LD_INT 1
103301: ST_TO_ADDR
// end ; end ;
103302: GO 103228
103304: POP
103305: POP
// if not x then
103306: LD_VAR 0 10
103310: NOT
103311: IFFALSE 103451
// begin attacking := true ;
103313: LD_ADDR_VAR 0 29
103317: PUSH
103318: LD_INT 1
103320: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103321: LD_VAR 0 4
103325: PUSH
103326: LD_VAR 0 7
103330: ARRAY
103331: PPUSH
103332: CALL_OW 250
103336: PPUSH
103337: LD_VAR 0 4
103341: PUSH
103342: LD_VAR 0 7
103346: ARRAY
103347: PPUSH
103348: CALL_OW 251
103352: PPUSH
103353: CALL_OW 546
103357: PUSH
103358: LD_INT 2
103360: ARRAY
103361: PUSH
103362: LD_VAR 0 14
103366: PUSH
103367: LD_INT 1
103369: ARRAY
103370: PPUSH
103371: CALL_OW 250
103375: PPUSH
103376: LD_VAR 0 14
103380: PUSH
103381: LD_INT 1
103383: ARRAY
103384: PPUSH
103385: CALL_OW 251
103389: PPUSH
103390: CALL_OW 546
103394: PUSH
103395: LD_INT 2
103397: ARRAY
103398: EQUAL
103399: IFFALSE 103427
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103401: LD_VAR 0 4
103405: PUSH
103406: LD_VAR 0 7
103410: ARRAY
103411: PPUSH
103412: LD_VAR 0 14
103416: PUSH
103417: LD_INT 1
103419: ARRAY
103420: PPUSH
103421: CALL 98698 0 2
103425: GO 103451
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103427: LD_VAR 0 4
103431: PUSH
103432: LD_VAR 0 7
103436: ARRAY
103437: PPUSH
103438: LD_VAR 0 14
103442: PUSH
103443: LD_INT 1
103445: ARRAY
103446: PPUSH
103447: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103451: LD_VAR 0 4
103455: PUSH
103456: LD_VAR 0 7
103460: ARRAY
103461: PPUSH
103462: CALL_OW 264
103466: PUSH
103467: LD_INT 29
103469: EQUAL
103470: IFFALSE 103836
// begin if WantsToAttack ( group [ i ] ) in bombed then
103472: LD_VAR 0 4
103476: PUSH
103477: LD_VAR 0 7
103481: ARRAY
103482: PPUSH
103483: CALL_OW 319
103487: PUSH
103488: LD_VAR 0 28
103492: IN
103493: IFFALSE 103497
// continue ;
103495: GO 100501
// k := 8 ;
103497: LD_ADDR_VAR 0 9
103501: PUSH
103502: LD_INT 8
103504: ST_TO_ADDR
// x := 0 ;
103505: LD_ADDR_VAR 0 10
103509: PUSH
103510: LD_INT 0
103512: ST_TO_ADDR
// if tmp < k then
103513: LD_VAR 0 14
103517: PUSH
103518: LD_VAR 0 9
103522: LESS
103523: IFFALSE 103535
// k := tmp ;
103525: LD_ADDR_VAR 0 9
103529: PUSH
103530: LD_VAR 0 14
103534: ST_TO_ADDR
// for j = 1 to k do
103535: LD_ADDR_VAR 0 8
103539: PUSH
103540: DOUBLE
103541: LD_INT 1
103543: DEC
103544: ST_TO_ADDR
103545: LD_VAR 0 9
103549: PUSH
103550: FOR_TO
103551: IFFALSE 103683
// begin if GetType ( tmp [ j ] ) = unit_building then
103553: LD_VAR 0 14
103557: PUSH
103558: LD_VAR 0 8
103562: ARRAY
103563: PPUSH
103564: CALL_OW 247
103568: PUSH
103569: LD_INT 3
103571: EQUAL
103572: IFFALSE 103681
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103574: LD_VAR 0 14
103578: PUSH
103579: LD_VAR 0 8
103583: ARRAY
103584: PUSH
103585: LD_VAR 0 28
103589: IN
103590: NOT
103591: PUSH
103592: LD_VAR 0 14
103596: PUSH
103597: LD_VAR 0 8
103601: ARRAY
103602: PPUSH
103603: CALL_OW 313
103607: AND
103608: IFFALSE 103681
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103610: LD_VAR 0 4
103614: PUSH
103615: LD_VAR 0 7
103619: ARRAY
103620: PPUSH
103621: LD_VAR 0 14
103625: PUSH
103626: LD_VAR 0 8
103630: ARRAY
103631: PPUSH
103632: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103636: LD_ADDR_VAR 0 28
103640: PUSH
103641: LD_VAR 0 28
103645: PPUSH
103646: LD_VAR 0 28
103650: PUSH
103651: LD_INT 1
103653: PLUS
103654: PPUSH
103655: LD_VAR 0 14
103659: PUSH
103660: LD_VAR 0 8
103664: ARRAY
103665: PPUSH
103666: CALL_OW 1
103670: ST_TO_ADDR
// attacking := true ;
103671: LD_ADDR_VAR 0 29
103675: PUSH
103676: LD_INT 1
103678: ST_TO_ADDR
// break ;
103679: GO 103683
// end ; end ;
103681: GO 103550
103683: POP
103684: POP
// if not attacking and f_attack_depot then
103685: LD_VAR 0 29
103689: NOT
103690: PUSH
103691: LD_VAR 0 25
103695: AND
103696: IFFALSE 103791
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103698: LD_ADDR_VAR 0 13
103702: PUSH
103703: LD_VAR 0 14
103707: PPUSH
103708: LD_INT 2
103710: PUSH
103711: LD_INT 30
103713: PUSH
103714: LD_INT 0
103716: PUSH
103717: EMPTY
103718: LIST
103719: LIST
103720: PUSH
103721: LD_INT 30
103723: PUSH
103724: LD_INT 1
103726: PUSH
103727: EMPTY
103728: LIST
103729: LIST
103730: PUSH
103731: EMPTY
103732: LIST
103733: LIST
103734: LIST
103735: PPUSH
103736: CALL_OW 72
103740: ST_TO_ADDR
// if z then
103741: LD_VAR 0 13
103745: IFFALSE 103791
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103747: LD_VAR 0 4
103751: PUSH
103752: LD_VAR 0 7
103756: ARRAY
103757: PPUSH
103758: LD_VAR 0 13
103762: PPUSH
103763: LD_VAR 0 4
103767: PUSH
103768: LD_VAR 0 7
103772: ARRAY
103773: PPUSH
103774: CALL_OW 74
103778: PPUSH
103779: CALL_OW 115
// attacking := true ;
103783: LD_ADDR_VAR 0 29
103787: PUSH
103788: LD_INT 1
103790: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103791: LD_VAR 0 4
103795: PUSH
103796: LD_VAR 0 7
103800: ARRAY
103801: PPUSH
103802: CALL_OW 256
103806: PUSH
103807: LD_INT 500
103809: LESS
103810: IFFALSE 103836
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103812: LD_VAR 0 4
103816: PUSH
103817: LD_VAR 0 7
103821: ARRAY
103822: PPUSH
103823: LD_VAR 0 14
103827: PUSH
103828: LD_INT 1
103830: ARRAY
103831: PPUSH
103832: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103836: LD_VAR 0 4
103840: PUSH
103841: LD_VAR 0 7
103845: ARRAY
103846: PPUSH
103847: CALL_OW 264
103851: PUSH
103852: LD_INT 49
103854: EQUAL
103855: IFFALSE 103976
// begin if not HasTask ( group [ i ] ) then
103857: LD_VAR 0 4
103861: PUSH
103862: LD_VAR 0 7
103866: ARRAY
103867: PPUSH
103868: CALL_OW 314
103872: NOT
103873: IFFALSE 103976
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103875: LD_ADDR_VAR 0 9
103879: PUSH
103880: LD_INT 81
103882: PUSH
103883: LD_VAR 0 4
103887: PUSH
103888: LD_VAR 0 7
103892: ARRAY
103893: PPUSH
103894: CALL_OW 255
103898: PUSH
103899: EMPTY
103900: LIST
103901: LIST
103902: PPUSH
103903: CALL_OW 69
103907: PPUSH
103908: LD_VAR 0 4
103912: PUSH
103913: LD_VAR 0 7
103917: ARRAY
103918: PPUSH
103919: CALL_OW 74
103923: ST_TO_ADDR
// if k then
103924: LD_VAR 0 9
103928: IFFALSE 103976
// if GetDistUnits ( group [ i ] , k ) > 10 then
103930: LD_VAR 0 4
103934: PUSH
103935: LD_VAR 0 7
103939: ARRAY
103940: PPUSH
103941: LD_VAR 0 9
103945: PPUSH
103946: CALL_OW 296
103950: PUSH
103951: LD_INT 10
103953: GREATER
103954: IFFALSE 103976
// ComMoveUnit ( group [ i ] , k ) ;
103956: LD_VAR 0 4
103960: PUSH
103961: LD_VAR 0 7
103965: ARRAY
103966: PPUSH
103967: LD_VAR 0 9
103971: PPUSH
103972: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103976: LD_VAR 0 4
103980: PUSH
103981: LD_VAR 0 7
103985: ARRAY
103986: PPUSH
103987: CALL_OW 256
103991: PUSH
103992: LD_INT 250
103994: LESS
103995: PUSH
103996: LD_VAR 0 4
104000: PUSH
104001: LD_VAR 0 7
104005: ARRAY
104006: PUSH
104007: LD_INT 21
104009: PUSH
104010: LD_INT 2
104012: PUSH
104013: EMPTY
104014: LIST
104015: LIST
104016: PUSH
104017: LD_INT 23
104019: PUSH
104020: LD_INT 2
104022: PUSH
104023: EMPTY
104024: LIST
104025: LIST
104026: PUSH
104027: EMPTY
104028: LIST
104029: LIST
104030: PPUSH
104031: CALL_OW 69
104035: IN
104036: AND
104037: IFFALSE 104162
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104039: LD_ADDR_VAR 0 9
104043: PUSH
104044: LD_OWVAR 3
104048: PUSH
104049: LD_VAR 0 4
104053: PUSH
104054: LD_VAR 0 7
104058: ARRAY
104059: DIFF
104060: PPUSH
104061: LD_VAR 0 4
104065: PUSH
104066: LD_VAR 0 7
104070: ARRAY
104071: PPUSH
104072: CALL_OW 74
104076: ST_TO_ADDR
// if not k then
104077: LD_VAR 0 9
104081: NOT
104082: IFFALSE 104086
// continue ;
104084: GO 100501
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104086: LD_VAR 0 9
104090: PUSH
104091: LD_INT 81
104093: PUSH
104094: LD_VAR 0 4
104098: PUSH
104099: LD_VAR 0 7
104103: ARRAY
104104: PPUSH
104105: CALL_OW 255
104109: PUSH
104110: EMPTY
104111: LIST
104112: LIST
104113: PPUSH
104114: CALL_OW 69
104118: IN
104119: PUSH
104120: LD_VAR 0 9
104124: PPUSH
104125: LD_VAR 0 4
104129: PUSH
104130: LD_VAR 0 7
104134: ARRAY
104135: PPUSH
104136: CALL_OW 296
104140: PUSH
104141: LD_INT 5
104143: LESS
104144: AND
104145: IFFALSE 104162
// ComAutodestruct ( group [ i ] ) ;
104147: LD_VAR 0 4
104151: PUSH
104152: LD_VAR 0 7
104156: ARRAY
104157: PPUSH
104158: CALL 98596 0 1
// end ; if f_attack_depot then
104162: LD_VAR 0 25
104166: IFFALSE 104278
// begin k := 6 ;
104168: LD_ADDR_VAR 0 9
104172: PUSH
104173: LD_INT 6
104175: ST_TO_ADDR
// if tmp < k then
104176: LD_VAR 0 14
104180: PUSH
104181: LD_VAR 0 9
104185: LESS
104186: IFFALSE 104198
// k := tmp ;
104188: LD_ADDR_VAR 0 9
104192: PUSH
104193: LD_VAR 0 14
104197: ST_TO_ADDR
// for j = 1 to k do
104198: LD_ADDR_VAR 0 8
104202: PUSH
104203: DOUBLE
104204: LD_INT 1
104206: DEC
104207: ST_TO_ADDR
104208: LD_VAR 0 9
104212: PUSH
104213: FOR_TO
104214: IFFALSE 104276
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104216: LD_VAR 0 8
104220: PPUSH
104221: CALL_OW 266
104225: PUSH
104226: LD_INT 0
104228: PUSH
104229: LD_INT 1
104231: PUSH
104232: EMPTY
104233: LIST
104234: LIST
104235: IN
104236: IFFALSE 104274
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104238: LD_VAR 0 4
104242: PUSH
104243: LD_VAR 0 7
104247: ARRAY
104248: PPUSH
104249: LD_VAR 0 14
104253: PUSH
104254: LD_VAR 0 8
104258: ARRAY
104259: PPUSH
104260: CALL_OW 115
// attacking := true ;
104264: LD_ADDR_VAR 0 29
104268: PUSH
104269: LD_INT 1
104271: ST_TO_ADDR
// break ;
104272: GO 104276
// end ;
104274: GO 104213
104276: POP
104277: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104278: LD_VAR 0 4
104282: PUSH
104283: LD_VAR 0 7
104287: ARRAY
104288: PPUSH
104289: CALL_OW 302
104293: PUSH
104294: LD_VAR 0 29
104298: NOT
104299: AND
104300: IFFALSE 104622
// begin if GetTag ( group [ i ] ) = 71 then
104302: LD_VAR 0 4
104306: PUSH
104307: LD_VAR 0 7
104311: ARRAY
104312: PPUSH
104313: CALL_OW 110
104317: PUSH
104318: LD_INT 71
104320: EQUAL
104321: IFFALSE 104362
// begin if HasTask ( group [ i ] ) then
104323: LD_VAR 0 4
104327: PUSH
104328: LD_VAR 0 7
104332: ARRAY
104333: PPUSH
104334: CALL_OW 314
104338: IFFALSE 104344
// continue else
104340: GO 100501
104342: GO 104362
// SetTag ( group [ i ] , 0 ) ;
104344: LD_VAR 0 4
104348: PUSH
104349: LD_VAR 0 7
104353: ARRAY
104354: PPUSH
104355: LD_INT 0
104357: PPUSH
104358: CALL_OW 109
// end ; k := 8 ;
104362: LD_ADDR_VAR 0 9
104366: PUSH
104367: LD_INT 8
104369: ST_TO_ADDR
// x := 0 ;
104370: LD_ADDR_VAR 0 10
104374: PUSH
104375: LD_INT 0
104377: ST_TO_ADDR
// if tmp < k then
104378: LD_VAR 0 14
104382: PUSH
104383: LD_VAR 0 9
104387: LESS
104388: IFFALSE 104400
// k := tmp ;
104390: LD_ADDR_VAR 0 9
104394: PUSH
104395: LD_VAR 0 14
104399: ST_TO_ADDR
// for j = 1 to k do
104400: LD_ADDR_VAR 0 8
104404: PUSH
104405: DOUBLE
104406: LD_INT 1
104408: DEC
104409: ST_TO_ADDR
104410: LD_VAR 0 9
104414: PUSH
104415: FOR_TO
104416: IFFALSE 104514
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104418: LD_VAR 0 14
104422: PUSH
104423: LD_VAR 0 8
104427: ARRAY
104428: PPUSH
104429: CALL_OW 247
104433: PUSH
104434: LD_INT 1
104436: EQUAL
104437: PUSH
104438: LD_VAR 0 14
104442: PUSH
104443: LD_VAR 0 8
104447: ARRAY
104448: PPUSH
104449: CALL_OW 256
104453: PUSH
104454: LD_INT 250
104456: LESS
104457: PUSH
104458: LD_VAR 0 20
104462: AND
104463: PUSH
104464: LD_VAR 0 20
104468: NOT
104469: PUSH
104470: LD_VAR 0 14
104474: PUSH
104475: LD_VAR 0 8
104479: ARRAY
104480: PPUSH
104481: CALL_OW 256
104485: PUSH
104486: LD_INT 250
104488: GREATEREQUAL
104489: AND
104490: OR
104491: AND
104492: IFFALSE 104512
// begin x := tmp [ j ] ;
104494: LD_ADDR_VAR 0 10
104498: PUSH
104499: LD_VAR 0 14
104503: PUSH
104504: LD_VAR 0 8
104508: ARRAY
104509: ST_TO_ADDR
// break ;
104510: GO 104514
// end ;
104512: GO 104415
104514: POP
104515: POP
// if x then
104516: LD_VAR 0 10
104520: IFFALSE 104544
// ComAttackUnit ( group [ i ] , x ) else
104522: LD_VAR 0 4
104526: PUSH
104527: LD_VAR 0 7
104531: ARRAY
104532: PPUSH
104533: LD_VAR 0 10
104537: PPUSH
104538: CALL_OW 115
104542: GO 104568
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104544: LD_VAR 0 4
104548: PUSH
104549: LD_VAR 0 7
104553: ARRAY
104554: PPUSH
104555: LD_VAR 0 14
104559: PUSH
104560: LD_INT 1
104562: ARRAY
104563: PPUSH
104564: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104568: LD_VAR 0 4
104572: PUSH
104573: LD_VAR 0 7
104577: ARRAY
104578: PPUSH
104579: CALL_OW 314
104583: NOT
104584: IFFALSE 104622
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104586: LD_VAR 0 4
104590: PUSH
104591: LD_VAR 0 7
104595: ARRAY
104596: PPUSH
104597: LD_VAR 0 14
104601: PPUSH
104602: LD_VAR 0 4
104606: PUSH
104607: LD_VAR 0 7
104611: ARRAY
104612: PPUSH
104613: CALL_OW 74
104617: PPUSH
104618: CALL_OW 115
// end ; end ; end ;
104622: GO 100501
104624: POP
104625: POP
// wait ( 0 0$1 ) ;
104626: LD_INT 35
104628: PPUSH
104629: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104633: LD_VAR 0 4
104637: PUSH
104638: EMPTY
104639: EQUAL
104640: PUSH
104641: LD_INT 81
104643: PUSH
104644: LD_VAR 0 35
104648: PUSH
104649: EMPTY
104650: LIST
104651: LIST
104652: PPUSH
104653: CALL_OW 69
104657: NOT
104658: OR
104659: IFFALSE 100486
// end ;
104661: LD_VAR 0 2
104665: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104666: LD_INT 0
104668: PPUSH
104669: PPUSH
104670: PPUSH
104671: PPUSH
// if not base_units then
104672: LD_VAR 0 1
104676: NOT
104677: IFFALSE 104681
// exit ;
104679: GO 104768
// result := false ;
104681: LD_ADDR_VAR 0 2
104685: PUSH
104686: LD_INT 0
104688: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104689: LD_ADDR_VAR 0 5
104693: PUSH
104694: LD_VAR 0 1
104698: PPUSH
104699: LD_INT 21
104701: PUSH
104702: LD_INT 3
104704: PUSH
104705: EMPTY
104706: LIST
104707: LIST
104708: PPUSH
104709: CALL_OW 72
104713: ST_TO_ADDR
// if not tmp then
104714: LD_VAR 0 5
104718: NOT
104719: IFFALSE 104723
// exit ;
104721: GO 104768
// for i in tmp do
104723: LD_ADDR_VAR 0 3
104727: PUSH
104728: LD_VAR 0 5
104732: PUSH
104733: FOR_IN
104734: IFFALSE 104766
// begin result := EnemyInRange ( i , 22 ) ;
104736: LD_ADDR_VAR 0 2
104740: PUSH
104741: LD_VAR 0 3
104745: PPUSH
104746: LD_INT 22
104748: PPUSH
104749: CALL 98302 0 2
104753: ST_TO_ADDR
// if result then
104754: LD_VAR 0 2
104758: IFFALSE 104764
// exit ;
104760: POP
104761: POP
104762: GO 104768
// end ;
104764: GO 104733
104766: POP
104767: POP
// end ;
104768: LD_VAR 0 2
104772: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104773: LD_INT 0
104775: PPUSH
104776: PPUSH
// if not units then
104777: LD_VAR 0 1
104781: NOT
104782: IFFALSE 104786
// exit ;
104784: GO 104856
// result := [ ] ;
104786: LD_ADDR_VAR 0 3
104790: PUSH
104791: EMPTY
104792: ST_TO_ADDR
// for i in units do
104793: LD_ADDR_VAR 0 4
104797: PUSH
104798: LD_VAR 0 1
104802: PUSH
104803: FOR_IN
104804: IFFALSE 104854
// if GetTag ( i ) = tag then
104806: LD_VAR 0 4
104810: PPUSH
104811: CALL_OW 110
104815: PUSH
104816: LD_VAR 0 2
104820: EQUAL
104821: IFFALSE 104852
// result := Insert ( result , result + 1 , i ) ;
104823: LD_ADDR_VAR 0 3
104827: PUSH
104828: LD_VAR 0 3
104832: PPUSH
104833: LD_VAR 0 3
104837: PUSH
104838: LD_INT 1
104840: PLUS
104841: PPUSH
104842: LD_VAR 0 4
104846: PPUSH
104847: CALL_OW 2
104851: ST_TO_ADDR
104852: GO 104803
104854: POP
104855: POP
// end ;
104856: LD_VAR 0 3
104860: RET
// export function IsDriver ( un ) ; begin
104861: LD_INT 0
104863: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104864: LD_ADDR_VAR 0 2
104868: PUSH
104869: LD_VAR 0 1
104873: PUSH
104874: LD_INT 55
104876: PUSH
104877: EMPTY
104878: LIST
104879: PPUSH
104880: CALL_OW 69
104884: IN
104885: ST_TO_ADDR
// end ;
104886: LD_VAR 0 2
104890: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104891: LD_INT 0
104893: PPUSH
104894: PPUSH
// list := [ ] ;
104895: LD_ADDR_VAR 0 5
104899: PUSH
104900: EMPTY
104901: ST_TO_ADDR
// case d of 0 :
104902: LD_VAR 0 3
104906: PUSH
104907: LD_INT 0
104909: DOUBLE
104910: EQUAL
104911: IFTRUE 104915
104913: GO 105048
104915: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104916: LD_ADDR_VAR 0 5
104920: PUSH
104921: LD_VAR 0 1
104925: PUSH
104926: LD_INT 4
104928: MINUS
104929: PUSH
104930: LD_VAR 0 2
104934: PUSH
104935: LD_INT 4
104937: MINUS
104938: PUSH
104939: LD_INT 2
104941: PUSH
104942: EMPTY
104943: LIST
104944: LIST
104945: LIST
104946: PUSH
104947: LD_VAR 0 1
104951: PUSH
104952: LD_INT 3
104954: MINUS
104955: PUSH
104956: LD_VAR 0 2
104960: PUSH
104961: LD_INT 1
104963: PUSH
104964: EMPTY
104965: LIST
104966: LIST
104967: LIST
104968: PUSH
104969: LD_VAR 0 1
104973: PUSH
104974: LD_INT 4
104976: PLUS
104977: PUSH
104978: LD_VAR 0 2
104982: PUSH
104983: LD_INT 4
104985: PUSH
104986: EMPTY
104987: LIST
104988: LIST
104989: LIST
104990: PUSH
104991: LD_VAR 0 1
104995: PUSH
104996: LD_INT 3
104998: PLUS
104999: PUSH
105000: LD_VAR 0 2
105004: PUSH
105005: LD_INT 3
105007: PLUS
105008: PUSH
105009: LD_INT 5
105011: PUSH
105012: EMPTY
105013: LIST
105014: LIST
105015: LIST
105016: PUSH
105017: LD_VAR 0 1
105021: PUSH
105022: LD_VAR 0 2
105026: PUSH
105027: LD_INT 4
105029: PLUS
105030: PUSH
105031: LD_INT 0
105033: PUSH
105034: EMPTY
105035: LIST
105036: LIST
105037: LIST
105038: PUSH
105039: EMPTY
105040: LIST
105041: LIST
105042: LIST
105043: LIST
105044: LIST
105045: ST_TO_ADDR
// end ; 1 :
105046: GO 105746
105048: LD_INT 1
105050: DOUBLE
105051: EQUAL
105052: IFTRUE 105056
105054: GO 105189
105056: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105057: LD_ADDR_VAR 0 5
105061: PUSH
105062: LD_VAR 0 1
105066: PUSH
105067: LD_VAR 0 2
105071: PUSH
105072: LD_INT 4
105074: MINUS
105075: PUSH
105076: LD_INT 3
105078: PUSH
105079: EMPTY
105080: LIST
105081: LIST
105082: LIST
105083: PUSH
105084: LD_VAR 0 1
105088: PUSH
105089: LD_INT 3
105091: MINUS
105092: PUSH
105093: LD_VAR 0 2
105097: PUSH
105098: LD_INT 3
105100: MINUS
105101: PUSH
105102: LD_INT 2
105104: PUSH
105105: EMPTY
105106: LIST
105107: LIST
105108: LIST
105109: PUSH
105110: LD_VAR 0 1
105114: PUSH
105115: LD_INT 4
105117: MINUS
105118: PUSH
105119: LD_VAR 0 2
105123: PUSH
105124: LD_INT 1
105126: PUSH
105127: EMPTY
105128: LIST
105129: LIST
105130: LIST
105131: PUSH
105132: LD_VAR 0 1
105136: PUSH
105137: LD_VAR 0 2
105141: PUSH
105142: LD_INT 3
105144: PLUS
105145: PUSH
105146: LD_INT 0
105148: PUSH
105149: EMPTY
105150: LIST
105151: LIST
105152: LIST
105153: PUSH
105154: LD_VAR 0 1
105158: PUSH
105159: LD_INT 4
105161: PLUS
105162: PUSH
105163: LD_VAR 0 2
105167: PUSH
105168: LD_INT 4
105170: PLUS
105171: PUSH
105172: LD_INT 5
105174: PUSH
105175: EMPTY
105176: LIST
105177: LIST
105178: LIST
105179: PUSH
105180: EMPTY
105181: LIST
105182: LIST
105183: LIST
105184: LIST
105185: LIST
105186: ST_TO_ADDR
// end ; 2 :
105187: GO 105746
105189: LD_INT 2
105191: DOUBLE
105192: EQUAL
105193: IFTRUE 105197
105195: GO 105326
105197: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105198: LD_ADDR_VAR 0 5
105202: PUSH
105203: LD_VAR 0 1
105207: PUSH
105208: LD_VAR 0 2
105212: PUSH
105213: LD_INT 3
105215: MINUS
105216: PUSH
105217: LD_INT 3
105219: PUSH
105220: EMPTY
105221: LIST
105222: LIST
105223: LIST
105224: PUSH
105225: LD_VAR 0 1
105229: PUSH
105230: LD_INT 4
105232: PLUS
105233: PUSH
105234: LD_VAR 0 2
105238: PUSH
105239: LD_INT 4
105241: PUSH
105242: EMPTY
105243: LIST
105244: LIST
105245: LIST
105246: PUSH
105247: LD_VAR 0 1
105251: PUSH
105252: LD_VAR 0 2
105256: PUSH
105257: LD_INT 4
105259: PLUS
105260: PUSH
105261: LD_INT 0
105263: PUSH
105264: EMPTY
105265: LIST
105266: LIST
105267: LIST
105268: PUSH
105269: LD_VAR 0 1
105273: PUSH
105274: LD_INT 3
105276: MINUS
105277: PUSH
105278: LD_VAR 0 2
105282: PUSH
105283: LD_INT 1
105285: PUSH
105286: EMPTY
105287: LIST
105288: LIST
105289: LIST
105290: PUSH
105291: LD_VAR 0 1
105295: PUSH
105296: LD_INT 4
105298: MINUS
105299: PUSH
105300: LD_VAR 0 2
105304: PUSH
105305: LD_INT 4
105307: MINUS
105308: PUSH
105309: LD_INT 2
105311: PUSH
105312: EMPTY
105313: LIST
105314: LIST
105315: LIST
105316: PUSH
105317: EMPTY
105318: LIST
105319: LIST
105320: LIST
105321: LIST
105322: LIST
105323: ST_TO_ADDR
// end ; 3 :
105324: GO 105746
105326: LD_INT 3
105328: DOUBLE
105329: EQUAL
105330: IFTRUE 105334
105332: GO 105467
105334: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105335: LD_ADDR_VAR 0 5
105339: PUSH
105340: LD_VAR 0 1
105344: PUSH
105345: LD_INT 3
105347: PLUS
105348: PUSH
105349: LD_VAR 0 2
105353: PUSH
105354: LD_INT 4
105356: PUSH
105357: EMPTY
105358: LIST
105359: LIST
105360: LIST
105361: PUSH
105362: LD_VAR 0 1
105366: PUSH
105367: LD_INT 4
105369: PLUS
105370: PUSH
105371: LD_VAR 0 2
105375: PUSH
105376: LD_INT 4
105378: PLUS
105379: PUSH
105380: LD_INT 5
105382: PUSH
105383: EMPTY
105384: LIST
105385: LIST
105386: LIST
105387: PUSH
105388: LD_VAR 0 1
105392: PUSH
105393: LD_INT 4
105395: MINUS
105396: PUSH
105397: LD_VAR 0 2
105401: PUSH
105402: LD_INT 1
105404: PUSH
105405: EMPTY
105406: LIST
105407: LIST
105408: LIST
105409: PUSH
105410: LD_VAR 0 1
105414: PUSH
105415: LD_VAR 0 2
105419: PUSH
105420: LD_INT 4
105422: MINUS
105423: PUSH
105424: LD_INT 3
105426: PUSH
105427: EMPTY
105428: LIST
105429: LIST
105430: LIST
105431: PUSH
105432: LD_VAR 0 1
105436: PUSH
105437: LD_INT 3
105439: MINUS
105440: PUSH
105441: LD_VAR 0 2
105445: PUSH
105446: LD_INT 3
105448: MINUS
105449: PUSH
105450: LD_INT 2
105452: PUSH
105453: EMPTY
105454: LIST
105455: LIST
105456: LIST
105457: PUSH
105458: EMPTY
105459: LIST
105460: LIST
105461: LIST
105462: LIST
105463: LIST
105464: ST_TO_ADDR
// end ; 4 :
105465: GO 105746
105467: LD_INT 4
105469: DOUBLE
105470: EQUAL
105471: IFTRUE 105475
105473: GO 105608
105475: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105476: LD_ADDR_VAR 0 5
105480: PUSH
105481: LD_VAR 0 1
105485: PUSH
105486: LD_VAR 0 2
105490: PUSH
105491: LD_INT 4
105493: PLUS
105494: PUSH
105495: LD_INT 0
105497: PUSH
105498: EMPTY
105499: LIST
105500: LIST
105501: LIST
105502: PUSH
105503: LD_VAR 0 1
105507: PUSH
105508: LD_INT 3
105510: PLUS
105511: PUSH
105512: LD_VAR 0 2
105516: PUSH
105517: LD_INT 3
105519: PLUS
105520: PUSH
105521: LD_INT 5
105523: PUSH
105524: EMPTY
105525: LIST
105526: LIST
105527: LIST
105528: PUSH
105529: LD_VAR 0 1
105533: PUSH
105534: LD_INT 4
105536: PLUS
105537: PUSH
105538: LD_VAR 0 2
105542: PUSH
105543: LD_INT 4
105545: PUSH
105546: EMPTY
105547: LIST
105548: LIST
105549: LIST
105550: PUSH
105551: LD_VAR 0 1
105555: PUSH
105556: LD_VAR 0 2
105560: PUSH
105561: LD_INT 3
105563: MINUS
105564: PUSH
105565: LD_INT 3
105567: PUSH
105568: EMPTY
105569: LIST
105570: LIST
105571: LIST
105572: PUSH
105573: LD_VAR 0 1
105577: PUSH
105578: LD_INT 4
105580: MINUS
105581: PUSH
105582: LD_VAR 0 2
105586: PUSH
105587: LD_INT 4
105589: MINUS
105590: PUSH
105591: LD_INT 2
105593: PUSH
105594: EMPTY
105595: LIST
105596: LIST
105597: LIST
105598: PUSH
105599: EMPTY
105600: LIST
105601: LIST
105602: LIST
105603: LIST
105604: LIST
105605: ST_TO_ADDR
// end ; 5 :
105606: GO 105746
105608: LD_INT 5
105610: DOUBLE
105611: EQUAL
105612: IFTRUE 105616
105614: GO 105745
105616: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105617: LD_ADDR_VAR 0 5
105621: PUSH
105622: LD_VAR 0 1
105626: PUSH
105627: LD_INT 4
105629: MINUS
105630: PUSH
105631: LD_VAR 0 2
105635: PUSH
105636: LD_INT 1
105638: PUSH
105639: EMPTY
105640: LIST
105641: LIST
105642: LIST
105643: PUSH
105644: LD_VAR 0 1
105648: PUSH
105649: LD_VAR 0 2
105653: PUSH
105654: LD_INT 4
105656: MINUS
105657: PUSH
105658: LD_INT 3
105660: PUSH
105661: EMPTY
105662: LIST
105663: LIST
105664: LIST
105665: PUSH
105666: LD_VAR 0 1
105670: PUSH
105671: LD_INT 4
105673: PLUS
105674: PUSH
105675: LD_VAR 0 2
105679: PUSH
105680: LD_INT 4
105682: PLUS
105683: PUSH
105684: LD_INT 5
105686: PUSH
105687: EMPTY
105688: LIST
105689: LIST
105690: LIST
105691: PUSH
105692: LD_VAR 0 1
105696: PUSH
105697: LD_INT 3
105699: PLUS
105700: PUSH
105701: LD_VAR 0 2
105705: PUSH
105706: LD_INT 4
105708: PUSH
105709: EMPTY
105710: LIST
105711: LIST
105712: LIST
105713: PUSH
105714: LD_VAR 0 1
105718: PUSH
105719: LD_VAR 0 2
105723: PUSH
105724: LD_INT 3
105726: PLUS
105727: PUSH
105728: LD_INT 0
105730: PUSH
105731: EMPTY
105732: LIST
105733: LIST
105734: LIST
105735: PUSH
105736: EMPTY
105737: LIST
105738: LIST
105739: LIST
105740: LIST
105741: LIST
105742: ST_TO_ADDR
// end ; end ;
105743: GO 105746
105745: POP
// result := list ;
105746: LD_ADDR_VAR 0 4
105750: PUSH
105751: LD_VAR 0 5
105755: ST_TO_ADDR
// end ;
105756: LD_VAR 0 4
105760: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105761: LD_INT 0
105763: PPUSH
105764: PPUSH
105765: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105766: LD_VAR 0 1
105770: NOT
105771: PUSH
105772: LD_VAR 0 2
105776: PUSH
105777: LD_INT 1
105779: PUSH
105780: LD_INT 2
105782: PUSH
105783: LD_INT 3
105785: PUSH
105786: LD_INT 4
105788: PUSH
105789: EMPTY
105790: LIST
105791: LIST
105792: LIST
105793: LIST
105794: IN
105795: NOT
105796: OR
105797: IFFALSE 105801
// exit ;
105799: GO 105893
// tmp := [ ] ;
105801: LD_ADDR_VAR 0 5
105805: PUSH
105806: EMPTY
105807: ST_TO_ADDR
// for i in units do
105808: LD_ADDR_VAR 0 4
105812: PUSH
105813: LD_VAR 0 1
105817: PUSH
105818: FOR_IN
105819: IFFALSE 105862
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105821: LD_ADDR_VAR 0 5
105825: PUSH
105826: LD_VAR 0 5
105830: PPUSH
105831: LD_VAR 0 5
105835: PUSH
105836: LD_INT 1
105838: PLUS
105839: PPUSH
105840: LD_VAR 0 4
105844: PPUSH
105845: LD_VAR 0 2
105849: PPUSH
105850: CALL_OW 259
105854: PPUSH
105855: CALL_OW 2
105859: ST_TO_ADDR
105860: GO 105818
105862: POP
105863: POP
// if not tmp then
105864: LD_VAR 0 5
105868: NOT
105869: IFFALSE 105873
// exit ;
105871: GO 105893
// result := SortListByListDesc ( units , tmp ) ;
105873: LD_ADDR_VAR 0 3
105877: PUSH
105878: LD_VAR 0 1
105882: PPUSH
105883: LD_VAR 0 5
105887: PPUSH
105888: CALL_OW 77
105892: ST_TO_ADDR
// end ;
105893: LD_VAR 0 3
105897: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105898: LD_INT 0
105900: PPUSH
105901: PPUSH
105902: PPUSH
// x := GetX ( building ) ;
105903: LD_ADDR_VAR 0 4
105907: PUSH
105908: LD_VAR 0 2
105912: PPUSH
105913: CALL_OW 250
105917: ST_TO_ADDR
// y := GetY ( building ) ;
105918: LD_ADDR_VAR 0 5
105922: PUSH
105923: LD_VAR 0 2
105927: PPUSH
105928: CALL_OW 251
105932: ST_TO_ADDR
// if GetTaskList ( unit ) then
105933: LD_VAR 0 1
105937: PPUSH
105938: CALL_OW 437
105942: IFFALSE 106037
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105944: LD_STRING e
105946: PUSH
105947: LD_VAR 0 1
105951: PPUSH
105952: CALL_OW 437
105956: PUSH
105957: LD_INT 1
105959: ARRAY
105960: PUSH
105961: LD_INT 1
105963: ARRAY
105964: EQUAL
105965: PUSH
105966: LD_VAR 0 4
105970: PUSH
105971: LD_VAR 0 1
105975: PPUSH
105976: CALL_OW 437
105980: PUSH
105981: LD_INT 1
105983: ARRAY
105984: PUSH
105985: LD_INT 2
105987: ARRAY
105988: EQUAL
105989: AND
105990: PUSH
105991: LD_VAR 0 5
105995: PUSH
105996: LD_VAR 0 1
106000: PPUSH
106001: CALL_OW 437
106005: PUSH
106006: LD_INT 1
106008: ARRAY
106009: PUSH
106010: LD_INT 3
106012: ARRAY
106013: EQUAL
106014: AND
106015: IFFALSE 106027
// result := true else
106017: LD_ADDR_VAR 0 3
106021: PUSH
106022: LD_INT 1
106024: ST_TO_ADDR
106025: GO 106035
// result := false ;
106027: LD_ADDR_VAR 0 3
106031: PUSH
106032: LD_INT 0
106034: ST_TO_ADDR
// end else
106035: GO 106045
// result := false ;
106037: LD_ADDR_VAR 0 3
106041: PUSH
106042: LD_INT 0
106044: ST_TO_ADDR
// end ;
106045: LD_VAR 0 3
106049: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106050: LD_INT 0
106052: PPUSH
106053: PPUSH
106054: PPUSH
106055: PPUSH
// if not unit or not area then
106056: LD_VAR 0 1
106060: NOT
106061: PUSH
106062: LD_VAR 0 2
106066: NOT
106067: OR
106068: IFFALSE 106072
// exit ;
106070: GO 106236
// tmp := AreaToList ( area , i ) ;
106072: LD_ADDR_VAR 0 6
106076: PUSH
106077: LD_VAR 0 2
106081: PPUSH
106082: LD_VAR 0 5
106086: PPUSH
106087: CALL_OW 517
106091: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106092: LD_ADDR_VAR 0 5
106096: PUSH
106097: DOUBLE
106098: LD_INT 1
106100: DEC
106101: ST_TO_ADDR
106102: LD_VAR 0 6
106106: PUSH
106107: LD_INT 1
106109: ARRAY
106110: PUSH
106111: FOR_TO
106112: IFFALSE 106234
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106114: LD_ADDR_VAR 0 7
106118: PUSH
106119: LD_VAR 0 6
106123: PUSH
106124: LD_INT 1
106126: ARRAY
106127: PUSH
106128: LD_VAR 0 5
106132: ARRAY
106133: PUSH
106134: LD_VAR 0 6
106138: PUSH
106139: LD_INT 2
106141: ARRAY
106142: PUSH
106143: LD_VAR 0 5
106147: ARRAY
106148: PUSH
106149: EMPTY
106150: LIST
106151: LIST
106152: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106153: LD_VAR 0 7
106157: PUSH
106158: LD_INT 1
106160: ARRAY
106161: PPUSH
106162: LD_VAR 0 7
106166: PUSH
106167: LD_INT 2
106169: ARRAY
106170: PPUSH
106171: CALL_OW 428
106175: PUSH
106176: LD_INT 0
106178: EQUAL
106179: IFFALSE 106232
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106181: LD_VAR 0 1
106185: PPUSH
106186: LD_VAR 0 7
106190: PUSH
106191: LD_INT 1
106193: ARRAY
106194: PPUSH
106195: LD_VAR 0 7
106199: PUSH
106200: LD_INT 2
106202: ARRAY
106203: PPUSH
106204: LD_VAR 0 3
106208: PPUSH
106209: CALL_OW 48
// result := IsPlaced ( unit ) ;
106213: LD_ADDR_VAR 0 4
106217: PUSH
106218: LD_VAR 0 1
106222: PPUSH
106223: CALL_OW 305
106227: ST_TO_ADDR
// exit ;
106228: POP
106229: POP
106230: GO 106236
// end ; end ;
106232: GO 106111
106234: POP
106235: POP
// end ;
106236: LD_VAR 0 4
106240: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106241: LD_INT 0
106243: PPUSH
106244: PPUSH
106245: PPUSH
// if not side or side > 8 then
106246: LD_VAR 0 1
106250: NOT
106251: PUSH
106252: LD_VAR 0 1
106256: PUSH
106257: LD_INT 8
106259: GREATER
106260: OR
106261: IFFALSE 106265
// exit ;
106263: GO 106452
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106265: LD_ADDR_VAR 0 4
106269: PUSH
106270: LD_INT 22
106272: PUSH
106273: LD_VAR 0 1
106277: PUSH
106278: EMPTY
106279: LIST
106280: LIST
106281: PUSH
106282: LD_INT 21
106284: PUSH
106285: LD_INT 3
106287: PUSH
106288: EMPTY
106289: LIST
106290: LIST
106291: PUSH
106292: EMPTY
106293: LIST
106294: LIST
106295: PPUSH
106296: CALL_OW 69
106300: ST_TO_ADDR
// if not tmp then
106301: LD_VAR 0 4
106305: NOT
106306: IFFALSE 106310
// exit ;
106308: GO 106452
// enable_addtolog := true ;
106310: LD_ADDR_OWVAR 81
106314: PUSH
106315: LD_INT 1
106317: ST_TO_ADDR
// AddToLog ( [ ) ;
106318: LD_STRING [
106320: PPUSH
106321: CALL_OW 561
// for i in tmp do
106325: LD_ADDR_VAR 0 3
106329: PUSH
106330: LD_VAR 0 4
106334: PUSH
106335: FOR_IN
106336: IFFALSE 106443
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106338: LD_STRING [
106340: PUSH
106341: LD_VAR 0 3
106345: PPUSH
106346: CALL_OW 266
106350: STR
106351: PUSH
106352: LD_STRING , 
106354: STR
106355: PUSH
106356: LD_VAR 0 3
106360: PPUSH
106361: CALL_OW 250
106365: STR
106366: PUSH
106367: LD_STRING , 
106369: STR
106370: PUSH
106371: LD_VAR 0 3
106375: PPUSH
106376: CALL_OW 251
106380: STR
106381: PUSH
106382: LD_STRING , 
106384: STR
106385: PUSH
106386: LD_VAR 0 3
106390: PPUSH
106391: CALL_OW 254
106395: STR
106396: PUSH
106397: LD_STRING , 
106399: STR
106400: PUSH
106401: LD_VAR 0 3
106405: PPUSH
106406: LD_INT 1
106408: PPUSH
106409: CALL_OW 268
106413: STR
106414: PUSH
106415: LD_STRING , 
106417: STR
106418: PUSH
106419: LD_VAR 0 3
106423: PPUSH
106424: LD_INT 2
106426: PPUSH
106427: CALL_OW 268
106431: STR
106432: PUSH
106433: LD_STRING ],
106435: STR
106436: PPUSH
106437: CALL_OW 561
// end ;
106441: GO 106335
106443: POP
106444: POP
// AddToLog ( ]; ) ;
106445: LD_STRING ];
106447: PPUSH
106448: CALL_OW 561
// end ;
106452: LD_VAR 0 2
106456: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106457: LD_INT 0
106459: PPUSH
106460: PPUSH
106461: PPUSH
106462: PPUSH
106463: PPUSH
// if not area or not rate or not max then
106464: LD_VAR 0 1
106468: NOT
106469: PUSH
106470: LD_VAR 0 2
106474: NOT
106475: OR
106476: PUSH
106477: LD_VAR 0 4
106481: NOT
106482: OR
106483: IFFALSE 106487
// exit ;
106485: GO 106679
// while 1 do
106487: LD_INT 1
106489: IFFALSE 106679
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106491: LD_ADDR_VAR 0 9
106495: PUSH
106496: LD_VAR 0 1
106500: PPUSH
106501: LD_INT 1
106503: PPUSH
106504: CALL_OW 287
106508: PUSH
106509: LD_INT 10
106511: MUL
106512: ST_TO_ADDR
// r := rate / 10 ;
106513: LD_ADDR_VAR 0 7
106517: PUSH
106518: LD_VAR 0 2
106522: PUSH
106523: LD_INT 10
106525: DIVREAL
106526: ST_TO_ADDR
// time := 1 1$00 ;
106527: LD_ADDR_VAR 0 8
106531: PUSH
106532: LD_INT 2100
106534: ST_TO_ADDR
// if amount < min then
106535: LD_VAR 0 9
106539: PUSH
106540: LD_VAR 0 3
106544: LESS
106545: IFFALSE 106563
// r := r * 2 else
106547: LD_ADDR_VAR 0 7
106551: PUSH
106552: LD_VAR 0 7
106556: PUSH
106557: LD_INT 2
106559: MUL
106560: ST_TO_ADDR
106561: GO 106589
// if amount > max then
106563: LD_VAR 0 9
106567: PUSH
106568: LD_VAR 0 4
106572: GREATER
106573: IFFALSE 106589
// r := r / 2 ;
106575: LD_ADDR_VAR 0 7
106579: PUSH
106580: LD_VAR 0 7
106584: PUSH
106585: LD_INT 2
106587: DIVREAL
106588: ST_TO_ADDR
// time := time / r ;
106589: LD_ADDR_VAR 0 8
106593: PUSH
106594: LD_VAR 0 8
106598: PUSH
106599: LD_VAR 0 7
106603: DIVREAL
106604: ST_TO_ADDR
// if time < 0 then
106605: LD_VAR 0 8
106609: PUSH
106610: LD_INT 0
106612: LESS
106613: IFFALSE 106630
// time := time * - 1 ;
106615: LD_ADDR_VAR 0 8
106619: PUSH
106620: LD_VAR 0 8
106624: PUSH
106625: LD_INT 1
106627: NEG
106628: MUL
106629: ST_TO_ADDR
// wait ( time ) ;
106630: LD_VAR 0 8
106634: PPUSH
106635: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106639: LD_INT 35
106641: PPUSH
106642: LD_INT 875
106644: PPUSH
106645: CALL_OW 12
106649: PPUSH
106650: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106654: LD_INT 1
106656: PPUSH
106657: LD_INT 5
106659: PPUSH
106660: CALL_OW 12
106664: PPUSH
106665: LD_VAR 0 1
106669: PPUSH
106670: LD_INT 1
106672: PPUSH
106673: CALL_OW 55
// end ;
106677: GO 106487
// end ;
106679: LD_VAR 0 5
106683: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106684: LD_INT 0
106686: PPUSH
106687: PPUSH
106688: PPUSH
106689: PPUSH
106690: PPUSH
106691: PPUSH
106692: PPUSH
106693: PPUSH
// if not turrets or not factories then
106694: LD_VAR 0 1
106698: NOT
106699: PUSH
106700: LD_VAR 0 2
106704: NOT
106705: OR
106706: IFFALSE 106710
// exit ;
106708: GO 107017
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106710: LD_ADDR_VAR 0 10
106714: PUSH
106715: LD_INT 5
106717: PUSH
106718: LD_INT 6
106720: PUSH
106721: EMPTY
106722: LIST
106723: LIST
106724: PUSH
106725: LD_INT 2
106727: PUSH
106728: LD_INT 4
106730: PUSH
106731: EMPTY
106732: LIST
106733: LIST
106734: PUSH
106735: LD_INT 3
106737: PUSH
106738: LD_INT 5
106740: PUSH
106741: EMPTY
106742: LIST
106743: LIST
106744: PUSH
106745: EMPTY
106746: LIST
106747: LIST
106748: LIST
106749: PUSH
106750: LD_INT 24
106752: PUSH
106753: LD_INT 25
106755: PUSH
106756: EMPTY
106757: LIST
106758: LIST
106759: PUSH
106760: LD_INT 23
106762: PUSH
106763: LD_INT 27
106765: PUSH
106766: EMPTY
106767: LIST
106768: LIST
106769: PUSH
106770: EMPTY
106771: LIST
106772: LIST
106773: PUSH
106774: LD_INT 42
106776: PUSH
106777: LD_INT 43
106779: PUSH
106780: EMPTY
106781: LIST
106782: LIST
106783: PUSH
106784: LD_INT 44
106786: PUSH
106787: LD_INT 46
106789: PUSH
106790: EMPTY
106791: LIST
106792: LIST
106793: PUSH
106794: LD_INT 45
106796: PUSH
106797: LD_INT 47
106799: PUSH
106800: EMPTY
106801: LIST
106802: LIST
106803: PUSH
106804: EMPTY
106805: LIST
106806: LIST
106807: LIST
106808: PUSH
106809: EMPTY
106810: LIST
106811: LIST
106812: LIST
106813: ST_TO_ADDR
// result := [ ] ;
106814: LD_ADDR_VAR 0 3
106818: PUSH
106819: EMPTY
106820: ST_TO_ADDR
// for i in turrets do
106821: LD_ADDR_VAR 0 4
106825: PUSH
106826: LD_VAR 0 1
106830: PUSH
106831: FOR_IN
106832: IFFALSE 107015
// begin nat := GetNation ( i ) ;
106834: LD_ADDR_VAR 0 7
106838: PUSH
106839: LD_VAR 0 4
106843: PPUSH
106844: CALL_OW 248
106848: ST_TO_ADDR
// weapon := 0 ;
106849: LD_ADDR_VAR 0 8
106853: PUSH
106854: LD_INT 0
106856: ST_TO_ADDR
// if not nat then
106857: LD_VAR 0 7
106861: NOT
106862: IFFALSE 106866
// continue ;
106864: GO 106831
// for j in list [ nat ] do
106866: LD_ADDR_VAR 0 5
106870: PUSH
106871: LD_VAR 0 10
106875: PUSH
106876: LD_VAR 0 7
106880: ARRAY
106881: PUSH
106882: FOR_IN
106883: IFFALSE 106924
// if GetBWeapon ( i ) = j [ 1 ] then
106885: LD_VAR 0 4
106889: PPUSH
106890: CALL_OW 269
106894: PUSH
106895: LD_VAR 0 5
106899: PUSH
106900: LD_INT 1
106902: ARRAY
106903: EQUAL
106904: IFFALSE 106922
// begin weapon := j [ 2 ] ;
106906: LD_ADDR_VAR 0 8
106910: PUSH
106911: LD_VAR 0 5
106915: PUSH
106916: LD_INT 2
106918: ARRAY
106919: ST_TO_ADDR
// break ;
106920: GO 106924
// end ;
106922: GO 106882
106924: POP
106925: POP
// if not weapon then
106926: LD_VAR 0 8
106930: NOT
106931: IFFALSE 106935
// continue ;
106933: GO 106831
// for k in factories do
106935: LD_ADDR_VAR 0 6
106939: PUSH
106940: LD_VAR 0 2
106944: PUSH
106945: FOR_IN
106946: IFFALSE 107011
// begin weapons := AvailableWeaponList ( k ) ;
106948: LD_ADDR_VAR 0 9
106952: PUSH
106953: LD_VAR 0 6
106957: PPUSH
106958: CALL_OW 478
106962: ST_TO_ADDR
// if not weapons then
106963: LD_VAR 0 9
106967: NOT
106968: IFFALSE 106972
// continue ;
106970: GO 106945
// if weapon in weapons then
106972: LD_VAR 0 8
106976: PUSH
106977: LD_VAR 0 9
106981: IN
106982: IFFALSE 107009
// begin result := [ i , weapon ] ;
106984: LD_ADDR_VAR 0 3
106988: PUSH
106989: LD_VAR 0 4
106993: PUSH
106994: LD_VAR 0 8
106998: PUSH
106999: EMPTY
107000: LIST
107001: LIST
107002: ST_TO_ADDR
// exit ;
107003: POP
107004: POP
107005: POP
107006: POP
107007: GO 107017
// end ; end ;
107009: GO 106945
107011: POP
107012: POP
// end ;
107013: GO 106831
107015: POP
107016: POP
// end ;
107017: LD_VAR 0 3
107021: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107022: LD_INT 0
107024: PPUSH
// if not side or side > 8 then
107025: LD_VAR 0 3
107029: NOT
107030: PUSH
107031: LD_VAR 0 3
107035: PUSH
107036: LD_INT 8
107038: GREATER
107039: OR
107040: IFFALSE 107044
// exit ;
107042: GO 107103
// if not range then
107044: LD_VAR 0 4
107048: NOT
107049: IFFALSE 107060
// range := - 12 ;
107051: LD_ADDR_VAR 0 4
107055: PUSH
107056: LD_INT 12
107058: NEG
107059: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107060: LD_VAR 0 1
107064: PPUSH
107065: LD_VAR 0 2
107069: PPUSH
107070: LD_VAR 0 3
107074: PPUSH
107075: LD_VAR 0 4
107079: PPUSH
107080: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107084: LD_VAR 0 1
107088: PPUSH
107089: LD_VAR 0 2
107093: PPUSH
107094: LD_VAR 0 3
107098: PPUSH
107099: CALL_OW 331
// end ;
107103: LD_VAR 0 5
107107: RET
// export function Video ( mode ) ; begin
107108: LD_INT 0
107110: PPUSH
// ingame_video = mode ;
107111: LD_ADDR_OWVAR 52
107115: PUSH
107116: LD_VAR 0 1
107120: ST_TO_ADDR
// interface_hidden = mode ;
107121: LD_ADDR_OWVAR 54
107125: PUSH
107126: LD_VAR 0 1
107130: ST_TO_ADDR
// end ;
107131: LD_VAR 0 2
107135: RET
// export function Join ( array , element ) ; begin
107136: LD_INT 0
107138: PPUSH
// result := array ^ element ;
107139: LD_ADDR_VAR 0 3
107143: PUSH
107144: LD_VAR 0 1
107148: PUSH
107149: LD_VAR 0 2
107153: ADD
107154: ST_TO_ADDR
// end ;
107155: LD_VAR 0 3
107159: RET
// export function JoinUnion ( array , element ) ; begin
107160: LD_INT 0
107162: PPUSH
// result := array union element ;
107163: LD_ADDR_VAR 0 3
107167: PUSH
107168: LD_VAR 0 1
107172: PUSH
107173: LD_VAR 0 2
107177: UNION
107178: ST_TO_ADDR
// end ;
107179: LD_VAR 0 3
107183: RET
// export function GetBehemoths ( side ) ; begin
107184: LD_INT 0
107186: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107187: LD_ADDR_VAR 0 2
107191: PUSH
107192: LD_INT 22
107194: PUSH
107195: LD_VAR 0 1
107199: PUSH
107200: EMPTY
107201: LIST
107202: LIST
107203: PUSH
107204: LD_INT 31
107206: PUSH
107207: LD_INT 25
107209: PUSH
107210: EMPTY
107211: LIST
107212: LIST
107213: PUSH
107214: EMPTY
107215: LIST
107216: LIST
107217: PPUSH
107218: CALL_OW 69
107222: ST_TO_ADDR
// end ;
107223: LD_VAR 0 2
107227: RET
// export function Shuffle ( array ) ; var i , index ; begin
107228: LD_INT 0
107230: PPUSH
107231: PPUSH
107232: PPUSH
// result := [ ] ;
107233: LD_ADDR_VAR 0 2
107237: PUSH
107238: EMPTY
107239: ST_TO_ADDR
// if not array then
107240: LD_VAR 0 1
107244: NOT
107245: IFFALSE 107249
// exit ;
107247: GO 107348
// Randomize ;
107249: CALL_OW 10
// for i = array downto 1 do
107253: LD_ADDR_VAR 0 3
107257: PUSH
107258: DOUBLE
107259: LD_VAR 0 1
107263: INC
107264: ST_TO_ADDR
107265: LD_INT 1
107267: PUSH
107268: FOR_DOWNTO
107269: IFFALSE 107346
// begin index := rand ( 1 , array ) ;
107271: LD_ADDR_VAR 0 4
107275: PUSH
107276: LD_INT 1
107278: PPUSH
107279: LD_VAR 0 1
107283: PPUSH
107284: CALL_OW 12
107288: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107289: LD_ADDR_VAR 0 2
107293: PUSH
107294: LD_VAR 0 2
107298: PPUSH
107299: LD_VAR 0 2
107303: PUSH
107304: LD_INT 1
107306: PLUS
107307: PPUSH
107308: LD_VAR 0 1
107312: PUSH
107313: LD_VAR 0 4
107317: ARRAY
107318: PPUSH
107319: CALL_OW 2
107323: ST_TO_ADDR
// array := Delete ( array , index ) ;
107324: LD_ADDR_VAR 0 1
107328: PUSH
107329: LD_VAR 0 1
107333: PPUSH
107334: LD_VAR 0 4
107338: PPUSH
107339: CALL_OW 3
107343: ST_TO_ADDR
// end ;
107344: GO 107268
107346: POP
107347: POP
// end ;
107348: LD_VAR 0 2
107352: RET
// export function GetBaseMaterials ( base ) ; begin
107353: LD_INT 0
107355: PPUSH
// result := [ 0 , 0 , 0 ] ;
107356: LD_ADDR_VAR 0 2
107360: PUSH
107361: LD_INT 0
107363: PUSH
107364: LD_INT 0
107366: PUSH
107367: LD_INT 0
107369: PUSH
107370: EMPTY
107371: LIST
107372: LIST
107373: LIST
107374: ST_TO_ADDR
// if not base then
107375: LD_VAR 0 1
107379: NOT
107380: IFFALSE 107384
// exit ;
107382: GO 107433
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107384: LD_ADDR_VAR 0 2
107388: PUSH
107389: LD_VAR 0 1
107393: PPUSH
107394: LD_INT 1
107396: PPUSH
107397: CALL_OW 275
107401: PUSH
107402: LD_VAR 0 1
107406: PPUSH
107407: LD_INT 2
107409: PPUSH
107410: CALL_OW 275
107414: PUSH
107415: LD_VAR 0 1
107419: PPUSH
107420: LD_INT 3
107422: PPUSH
107423: CALL_OW 275
107427: PUSH
107428: EMPTY
107429: LIST
107430: LIST
107431: LIST
107432: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107433: LD_VAR 0 2
107437: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107438: LD_INT 0
107440: PPUSH
107441: PPUSH
107442: PPUSH
107443: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107444: LD_VAR 0 1
107448: PPUSH
107449: CALL_OW 264
107453: PUSH
107454: LD_EXP 98
107458: EQUAL
107459: IFFALSE 107531
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107461: LD_INT 68
107463: PPUSH
107464: LD_VAR 0 1
107468: PPUSH
107469: CALL_OW 255
107473: PPUSH
107474: CALL_OW 321
107478: PUSH
107479: LD_INT 2
107481: EQUAL
107482: IFFALSE 107494
// eff := 70 else
107484: LD_ADDR_VAR 0 6
107488: PUSH
107489: LD_INT 70
107491: ST_TO_ADDR
107492: GO 107502
// eff := 30 ;
107494: LD_ADDR_VAR 0 6
107498: PUSH
107499: LD_INT 30
107501: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107502: LD_VAR 0 1
107506: PPUSH
107507: CALL_OW 250
107511: PPUSH
107512: LD_VAR 0 1
107516: PPUSH
107517: CALL_OW 251
107521: PPUSH
107522: LD_VAR 0 6
107526: PPUSH
107527: CALL_OW 495
// end ; end ;
107531: LD_VAR 0 4
107535: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107536: LD_INT 0
107538: PPUSH
107539: PPUSH
107540: PPUSH
107541: PPUSH
107542: PPUSH
107543: PPUSH
// if cmd = 124 then
107544: LD_VAR 0 1
107548: PUSH
107549: LD_INT 124
107551: EQUAL
107552: IFFALSE 107758
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107554: LD_ADDR_VAR 0 5
107558: PUSH
107559: LD_INT 2
107561: PUSH
107562: LD_INT 34
107564: PUSH
107565: LD_INT 53
107567: PUSH
107568: EMPTY
107569: LIST
107570: LIST
107571: PUSH
107572: LD_INT 34
107574: PUSH
107575: LD_INT 14
107577: PUSH
107578: EMPTY
107579: LIST
107580: LIST
107581: PUSH
107582: EMPTY
107583: LIST
107584: LIST
107585: LIST
107586: PPUSH
107587: CALL_OW 69
107591: ST_TO_ADDR
// if not tmp then
107592: LD_VAR 0 5
107596: NOT
107597: IFFALSE 107601
// exit ;
107599: GO 107758
// for i in tmp do
107601: LD_ADDR_VAR 0 3
107605: PUSH
107606: LD_VAR 0 5
107610: PUSH
107611: FOR_IN
107612: IFFALSE 107756
// begin taskList := GetTaskList ( i ) ;
107614: LD_ADDR_VAR 0 6
107618: PUSH
107619: LD_VAR 0 3
107623: PPUSH
107624: CALL_OW 437
107628: ST_TO_ADDR
// if not taskList then
107629: LD_VAR 0 6
107633: NOT
107634: IFFALSE 107638
// continue ;
107636: GO 107611
// for j = 1 to taskList do
107638: LD_ADDR_VAR 0 4
107642: PUSH
107643: DOUBLE
107644: LD_INT 1
107646: DEC
107647: ST_TO_ADDR
107648: LD_VAR 0 6
107652: PUSH
107653: FOR_TO
107654: IFFALSE 107752
// if taskList [ j ] [ 1 ] = | then
107656: LD_VAR 0 6
107660: PUSH
107661: LD_VAR 0 4
107665: ARRAY
107666: PUSH
107667: LD_INT 1
107669: ARRAY
107670: PUSH
107671: LD_STRING |
107673: EQUAL
107674: IFFALSE 107750
// begin _taskList := Delete ( taskList , 1 ) ;
107676: LD_ADDR_VAR 0 7
107680: PUSH
107681: LD_VAR 0 6
107685: PPUSH
107686: LD_INT 1
107688: PPUSH
107689: CALL_OW 3
107693: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107694: LD_VAR 0 3
107698: PPUSH
107699: LD_VAR 0 7
107703: PPUSH
107704: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107708: LD_VAR 0 3
107712: PPUSH
107713: LD_VAR 0 6
107717: PUSH
107718: LD_VAR 0 4
107722: ARRAY
107723: PUSH
107724: LD_INT 2
107726: ARRAY
107727: PPUSH
107728: LD_VAR 0 6
107732: PUSH
107733: LD_VAR 0 4
107737: ARRAY
107738: PUSH
107739: LD_INT 3
107741: ARRAY
107742: PPUSH
107743: LD_INT 8
107745: PPUSH
107746: CALL 107763 0 4
// end ;
107750: GO 107653
107752: POP
107753: POP
// end ;
107754: GO 107611
107756: POP
107757: POP
// end ; end ;
107758: LD_VAR 0 2
107762: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107763: LD_INT 0
107765: PPUSH
107766: PPUSH
107767: PPUSH
107768: PPUSH
107769: PPUSH
107770: PPUSH
107771: PPUSH
107772: PPUSH
107773: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107774: LD_VAR 0 1
107778: NOT
107779: PUSH
107780: LD_VAR 0 2
107784: PPUSH
107785: LD_VAR 0 3
107789: PPUSH
107790: CALL_OW 488
107794: NOT
107795: OR
107796: PUSH
107797: LD_VAR 0 4
107801: NOT
107802: OR
107803: IFFALSE 107807
// exit ;
107805: GO 108147
// list := [ ] ;
107807: LD_ADDR_VAR 0 13
107811: PUSH
107812: EMPTY
107813: ST_TO_ADDR
// if x - r < 0 then
107814: LD_VAR 0 2
107818: PUSH
107819: LD_VAR 0 4
107823: MINUS
107824: PUSH
107825: LD_INT 0
107827: LESS
107828: IFFALSE 107840
// min_x := 0 else
107830: LD_ADDR_VAR 0 7
107834: PUSH
107835: LD_INT 0
107837: ST_TO_ADDR
107838: GO 107856
// min_x := x - r ;
107840: LD_ADDR_VAR 0 7
107844: PUSH
107845: LD_VAR 0 2
107849: PUSH
107850: LD_VAR 0 4
107854: MINUS
107855: ST_TO_ADDR
// if y - r < 0 then
107856: LD_VAR 0 3
107860: PUSH
107861: LD_VAR 0 4
107865: MINUS
107866: PUSH
107867: LD_INT 0
107869: LESS
107870: IFFALSE 107882
// min_y := 0 else
107872: LD_ADDR_VAR 0 8
107876: PUSH
107877: LD_INT 0
107879: ST_TO_ADDR
107880: GO 107898
// min_y := y - r ;
107882: LD_ADDR_VAR 0 8
107886: PUSH
107887: LD_VAR 0 3
107891: PUSH
107892: LD_VAR 0 4
107896: MINUS
107897: ST_TO_ADDR
// max_x := x + r ;
107898: LD_ADDR_VAR 0 9
107902: PUSH
107903: LD_VAR 0 2
107907: PUSH
107908: LD_VAR 0 4
107912: PLUS
107913: ST_TO_ADDR
// max_y := y + r ;
107914: LD_ADDR_VAR 0 10
107918: PUSH
107919: LD_VAR 0 3
107923: PUSH
107924: LD_VAR 0 4
107928: PLUS
107929: ST_TO_ADDR
// for _x = min_x to max_x do
107930: LD_ADDR_VAR 0 11
107934: PUSH
107935: DOUBLE
107936: LD_VAR 0 7
107940: DEC
107941: ST_TO_ADDR
107942: LD_VAR 0 9
107946: PUSH
107947: FOR_TO
107948: IFFALSE 108065
// for _y = min_y to max_y do
107950: LD_ADDR_VAR 0 12
107954: PUSH
107955: DOUBLE
107956: LD_VAR 0 8
107960: DEC
107961: ST_TO_ADDR
107962: LD_VAR 0 10
107966: PUSH
107967: FOR_TO
107968: IFFALSE 108061
// begin if not ValidHex ( _x , _y ) then
107970: LD_VAR 0 11
107974: PPUSH
107975: LD_VAR 0 12
107979: PPUSH
107980: CALL_OW 488
107984: NOT
107985: IFFALSE 107989
// continue ;
107987: GO 107967
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107989: LD_VAR 0 11
107993: PPUSH
107994: LD_VAR 0 12
107998: PPUSH
107999: CALL_OW 351
108003: PUSH
108004: LD_VAR 0 11
108008: PPUSH
108009: LD_VAR 0 12
108013: PPUSH
108014: CALL_OW 554
108018: AND
108019: IFFALSE 108059
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108021: LD_ADDR_VAR 0 13
108025: PUSH
108026: LD_VAR 0 13
108030: PPUSH
108031: LD_VAR 0 13
108035: PUSH
108036: LD_INT 1
108038: PLUS
108039: PPUSH
108040: LD_VAR 0 11
108044: PUSH
108045: LD_VAR 0 12
108049: PUSH
108050: EMPTY
108051: LIST
108052: LIST
108053: PPUSH
108054: CALL_OW 2
108058: ST_TO_ADDR
// end ;
108059: GO 107967
108061: POP
108062: POP
108063: GO 107947
108065: POP
108066: POP
// if not list then
108067: LD_VAR 0 13
108071: NOT
108072: IFFALSE 108076
// exit ;
108074: GO 108147
// for i in list do
108076: LD_ADDR_VAR 0 6
108080: PUSH
108081: LD_VAR 0 13
108085: PUSH
108086: FOR_IN
108087: IFFALSE 108145
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108089: LD_VAR 0 1
108093: PPUSH
108094: LD_STRING M
108096: PUSH
108097: LD_VAR 0 6
108101: PUSH
108102: LD_INT 1
108104: ARRAY
108105: PUSH
108106: LD_VAR 0 6
108110: PUSH
108111: LD_INT 2
108113: ARRAY
108114: PUSH
108115: LD_INT 0
108117: PUSH
108118: LD_INT 0
108120: PUSH
108121: LD_INT 0
108123: PUSH
108124: LD_INT 0
108126: PUSH
108127: EMPTY
108128: LIST
108129: LIST
108130: LIST
108131: LIST
108132: LIST
108133: LIST
108134: LIST
108135: PUSH
108136: EMPTY
108137: LIST
108138: PPUSH
108139: CALL_OW 447
108143: GO 108086
108145: POP
108146: POP
// end ;
108147: LD_VAR 0 5
108151: RET
