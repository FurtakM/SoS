// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 36586 0 0
// InitNature ;
  19: CALL 36454 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11799 0 0
// PrepareRussian ;
  40: CALL 7071 0 0
// PrepareLegion ;
  44: CALL 4242 0 0
// PreparePowell ;
  48: CALL 3044 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 15866 0 0
// MC_Start ( ) ;
  60: CALL 38758 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 123
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 124
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 61556 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 61649 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 60999 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 60814 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 61556 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 61649 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 60814 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 60999 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 61429 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 60496 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 61556 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 61649 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 128
 971: PUSH
 972: LD_EXP 128
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 60814 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 61556 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 61649 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 60706 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 61967 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61138 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 61429 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 61429 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 61761 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 60814 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 61380 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67250 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72265 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72265 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 57
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 57
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72265 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 57
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 57
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 57
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 57
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72265 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72265 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 58
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 58
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 58
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67250 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 58
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67250 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 58
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67250 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 58
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67250 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2433
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery =  ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING 
2394: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2395: LD_INT 1
2397: PPUSH
2398: LD_INT 10
2400: PPUSH
2401: CALL_OW 384
// Baker = CreateHuman ;
2405: LD_ADDR_EXP 56
2409: PUSH
2410: CALL_OW 44
2414: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2415: LD_ADDR_VAR 0 2
2419: PUSH
2420: LD_VAR 0 2
2424: PUSH
2425: LD_EXP 56
2429: ADD
2430: ST_TO_ADDR
// end else
2431: GO 2449
// tmp := tmp ^ Stevens ;
2433: LD_ADDR_VAR 0 2
2437: PUSH
2438: LD_VAR 0 2
2442: PUSH
2443: LD_EXP 42
2447: ADD
2448: ST_TO_ADDR
// if not Lisa then
2449: LD_EXP 43
2453: NOT
2454: IFFALSE 2500
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2456: LD_ADDR_EXP 43
2460: PUSH
2461: LD_STRING Lisa
2463: PPUSH
2464: LD_EXP 1
2468: NOT
2469: PPUSH
2470: LD_STRING 13f_
2472: PPUSH
2473: CALL 67250 0 3
2477: ST_TO_ADDR
// if Lisa then
2478: LD_EXP 43
2482: IFFALSE 2500
// tmp := tmp ^ Lisa ;
2484: LD_ADDR_VAR 0 2
2488: PUSH
2489: LD_VAR 0 2
2493: PUSH
2494: LD_EXP 43
2498: ADD
2499: ST_TO_ADDR
// end ; if not Donaldson then
2500: LD_EXP 44
2504: NOT
2505: IFFALSE 2551
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2507: LD_ADDR_EXP 44
2511: PUSH
2512: LD_STRING Donaldson
2514: PPUSH
2515: LD_EXP 1
2519: NOT
2520: PPUSH
2521: LD_STRING 13f_
2523: PPUSH
2524: CALL 67250 0 3
2528: ST_TO_ADDR
// if Donaldson then
2529: LD_EXP 44
2533: IFFALSE 2551
// tmp := tmp ^ Donaldson ;
2535: LD_ADDR_VAR 0 2
2539: PUSH
2540: LD_VAR 0 2
2544: PUSH
2545: LD_EXP 44
2549: ADD
2550: ST_TO_ADDR
// end ; if not Bobby then
2551: LD_EXP 45
2555: NOT
2556: IFFALSE 2602
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2558: LD_ADDR_EXP 45
2562: PUSH
2563: LD_STRING Bobby
2565: PPUSH
2566: LD_EXP 1
2570: NOT
2571: PPUSH
2572: LD_STRING 13f_
2574: PPUSH
2575: CALL 67250 0 3
2579: ST_TO_ADDR
// if Bobby then
2580: LD_EXP 45
2584: IFFALSE 2602
// tmp := tmp ^ Bobby ;
2586: LD_ADDR_VAR 0 2
2590: PUSH
2591: LD_VAR 0 2
2595: PUSH
2596: LD_EXP 45
2600: ADD
2601: ST_TO_ADDR
// end ; if not Cyrus then
2602: LD_EXP 46
2606: NOT
2607: IFFALSE 2653
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2609: LD_ADDR_EXP 46
2613: PUSH
2614: LD_STRING Cyrus
2616: PPUSH
2617: LD_EXP 1
2621: NOT
2622: PPUSH
2623: LD_STRING 13f_
2625: PPUSH
2626: CALL 67250 0 3
2630: ST_TO_ADDR
// if Cyrus then
2631: LD_EXP 46
2635: IFFALSE 2653
// tmp := tmp ^ Cyrus ;
2637: LD_ADDR_VAR 0 2
2641: PUSH
2642: LD_VAR 0 2
2646: PUSH
2647: LD_EXP 46
2651: ADD
2652: ST_TO_ADDR
// end ; if not Brown then
2653: LD_EXP 48
2657: NOT
2658: IFFALSE 2704
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2660: LD_ADDR_EXP 48
2664: PUSH
2665: LD_STRING Brown
2667: PPUSH
2668: LD_EXP 1
2672: NOT
2673: PPUSH
2674: LD_STRING 13f_
2676: PPUSH
2677: CALL 67250 0 3
2681: ST_TO_ADDR
// if Brown then
2682: LD_EXP 48
2686: IFFALSE 2704
// tmp := tmp ^ Brown ;
2688: LD_ADDR_VAR 0 2
2692: PUSH
2693: LD_VAR 0 2
2697: PUSH
2698: LD_EXP 48
2702: ADD
2703: ST_TO_ADDR
// end ; if not Gladstone then
2704: LD_EXP 49
2708: NOT
2709: IFFALSE 2755
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2711: LD_ADDR_EXP 49
2715: PUSH
2716: LD_STRING Gladstone
2718: PPUSH
2719: LD_EXP 1
2723: NOT
2724: PPUSH
2725: LD_STRING 13f_
2727: PPUSH
2728: CALL 67250 0 3
2732: ST_TO_ADDR
// if Gladstone then
2733: LD_EXP 49
2737: IFFALSE 2755
// tmp := tmp ^ Gladstone ;
2739: LD_ADDR_VAR 0 2
2743: PUSH
2744: LD_VAR 0 2
2748: PUSH
2749: LD_EXP 49
2753: ADD
2754: ST_TO_ADDR
// end ; if not Houten then
2755: LD_EXP 50
2759: NOT
2760: IFFALSE 2806
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2762: LD_ADDR_EXP 50
2766: PUSH
2767: LD_STRING Houten
2769: PPUSH
2770: LD_EXP 1
2774: NOT
2775: PPUSH
2776: LD_STRING 13f_
2778: PPUSH
2779: CALL 67250 0 3
2783: ST_TO_ADDR
// if Houten then
2784: LD_EXP 50
2788: IFFALSE 2806
// tmp := tmp ^ Houten ;
2790: LD_ADDR_VAR 0 2
2794: PUSH
2795: LD_VAR 0 2
2799: PUSH
2800: LD_EXP 50
2804: ADD
2805: ST_TO_ADDR
// end ; if not Cornel then
2806: LD_EXP 51
2810: NOT
2811: IFFALSE 2857
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2813: LD_ADDR_EXP 51
2817: PUSH
2818: LD_STRING Cornell
2820: PPUSH
2821: LD_EXP 1
2825: NOT
2826: PPUSH
2827: LD_STRING 13f_
2829: PPUSH
2830: CALL 67250 0 3
2834: ST_TO_ADDR
// if Cornel then
2835: LD_EXP 51
2839: IFFALSE 2857
// tmp := tmp ^ Cornel ;
2841: LD_ADDR_VAR 0 2
2845: PUSH
2846: LD_VAR 0 2
2850: PUSH
2851: LD_EXP 51
2855: ADD
2856: ST_TO_ADDR
// end ; if not Gary then
2857: LD_EXP 52
2861: NOT
2862: IFFALSE 2908
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2864: LD_ADDR_EXP 52
2868: PUSH
2869: LD_STRING Gary
2871: PPUSH
2872: LD_EXP 1
2876: NOT
2877: PPUSH
2878: LD_STRING 13f_
2880: PPUSH
2881: CALL 67250 0 3
2885: ST_TO_ADDR
// if Gary then
2886: LD_EXP 52
2890: IFFALSE 2908
// tmp := tmp ^ Gary ;
2892: LD_ADDR_VAR 0 2
2896: PUSH
2897: LD_VAR 0 2
2901: PUSH
2902: LD_EXP 52
2906: ADD
2907: ST_TO_ADDR
// end ; if not Frank then
2908: LD_EXP 53
2912: NOT
2913: IFFALSE 2959
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2915: LD_ADDR_EXP 53
2919: PUSH
2920: LD_STRING Frank
2922: PPUSH
2923: LD_EXP 1
2927: NOT
2928: PPUSH
2929: LD_STRING 13f_
2931: PPUSH
2932: CALL 67250 0 3
2936: ST_TO_ADDR
// if Frank then
2937: LD_EXP 53
2941: IFFALSE 2959
// tmp := tmp ^ Frank ;
2943: LD_ADDR_VAR 0 2
2947: PUSH
2948: LD_VAR 0 2
2952: PUSH
2953: LD_EXP 53
2957: ADD
2958: ST_TO_ADDR
// end ; if not Kikuchi then
2959: LD_EXP 54
2963: NOT
2964: IFFALSE 3010
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2966: LD_ADDR_EXP 54
2970: PUSH
2971: LD_STRING Kikuchi
2973: PPUSH
2974: LD_EXP 1
2978: NOT
2979: PPUSH
2980: LD_STRING 13f_
2982: PPUSH
2983: CALL 67250 0 3
2987: ST_TO_ADDR
// if Kikuchi then
2988: LD_EXP 54
2992: IFFALSE 3010
// tmp := tmp ^ Kikuchi ;
2994: LD_ADDR_VAR 0 2
2998: PUSH
2999: LD_VAR 0 2
3003: PUSH
3004: LD_EXP 54
3008: ADD
3009: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3010: LD_ADDR_VAR 0 2
3014: PUSH
3015: LD_VAR 0 2
3019: PUSH
3020: LD_STRING 13_other_survivors
3022: PPUSH
3023: CALL_OW 31
3027: UNION
3028: ST_TO_ADDR
// result := tmp ;
3029: LD_ADDR_VAR 0 1
3033: PUSH
3034: LD_VAR 0 2
3038: ST_TO_ADDR
// end ; end_of_file
3039: LD_VAR 0 1
3043: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3044: LD_INT 0
3046: PPUSH
3047: PPUSH
3048: PPUSH
3049: PPUSH
3050: PPUSH
3051: PPUSH
3052: PPUSH
3053: PPUSH
3054: PPUSH
3055: PPUSH
// uc_side := 4 ;
3056: LD_ADDR_OWVAR 20
3060: PUSH
3061: LD_INT 4
3063: ST_TO_ADDR
// uc_nation := 1 ;
3064: LD_ADDR_OWVAR 21
3068: PUSH
3069: LD_INT 1
3071: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3072: LD_INT 387
3074: PPUSH
3075: CALL_OW 274
3079: PPUSH
3080: LD_INT 1
3082: PPUSH
3083: LD_INT 3500
3085: PUSH
3086: LD_INT 3000
3088: PUSH
3089: LD_INT 2500
3091: PUSH
3092: LD_INT 2000
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: LD_OWVAR 67
3105: ARRAY
3106: PPUSH
3107: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3111: LD_INT 387
3113: PPUSH
3114: CALL_OW 274
3118: PPUSH
3119: LD_INT 2
3121: PPUSH
3122: LD_INT 400
3124: PPUSH
3125: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3129: LD_INT 387
3131: PPUSH
3132: CALL_OW 274
3136: PPUSH
3137: LD_INT 3
3139: PPUSH
3140: LD_INT 10
3142: PPUSH
3143: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3147: LD_ADDR_EXP 59
3151: PUSH
3152: LD_STRING Powell
3154: PPUSH
3155: CALL_OW 25
3159: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3160: LD_EXP 59
3164: PPUSH
3165: LD_INT 57
3167: PPUSH
3168: LD_INT 94
3170: PPUSH
3171: LD_INT 0
3173: PPUSH
3174: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3178: LD_EXP 59
3182: PPUSH
3183: LD_INT 58
3185: PPUSH
3186: LD_INT 94
3188: PPUSH
3189: CALL_OW 118
// vip := [ ] ;
3193: LD_ADDR_EXP 60
3197: PUSH
3198: EMPTY
3199: ST_TO_ADDR
// tmp := [ ] ;
3200: LD_ADDR_VAR 0 5
3204: PUSH
3205: EMPTY
3206: ST_TO_ADDR
// if JMMGirl <> 2 then
3207: LD_EXP 7
3211: PUSH
3212: LD_INT 2
3214: NONEQUAL
3215: IFFALSE 3239
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3217: LD_ADDR_EXP 43
3221: PUSH
3222: LD_STRING Lisa
3224: PPUSH
3225: LD_EXP 1
3229: NOT
3230: PPUSH
3231: LD_STRING 13s_
3233: PPUSH
3234: CALL 67250 0 3
3238: ST_TO_ADDR
// if Lisa then
3239: LD_EXP 43
3243: IFFALSE 3261
// tmp := tmp ^ Lisa ;
3245: LD_ADDR_VAR 0 5
3249: PUSH
3250: LD_VAR 0 5
3254: PUSH
3255: LD_EXP 43
3259: ADD
3260: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3261: LD_ADDR_EXP 44
3265: PUSH
3266: LD_STRING Donaldson
3268: PPUSH
3269: LD_EXP 1
3273: NOT
3274: PPUSH
3275: LD_STRING 13s_
3277: PPUSH
3278: CALL 67250 0 3
3282: ST_TO_ADDR
// if Donaldson then
3283: LD_EXP 44
3287: IFFALSE 3305
// tmp := tmp ^ Donaldson ;
3289: LD_ADDR_VAR 0 5
3293: PUSH
3294: LD_VAR 0 5
3298: PUSH
3299: LD_EXP 44
3303: ADD
3304: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3305: LD_ADDR_EXP 45
3309: PUSH
3310: LD_STRING Bobby
3312: PPUSH
3313: LD_EXP 1
3317: NOT
3318: PPUSH
3319: LD_STRING 13s_
3321: PPUSH
3322: CALL 67250 0 3
3326: ST_TO_ADDR
// if Bobby then
3327: LD_EXP 45
3331: IFFALSE 3349
// tmp := tmp ^ Bobby ;
3333: LD_ADDR_VAR 0 5
3337: PUSH
3338: LD_VAR 0 5
3342: PUSH
3343: LD_EXP 45
3347: ADD
3348: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3349: LD_ADDR_EXP 46
3353: PUSH
3354: LD_STRING Cyrus
3356: PPUSH
3357: LD_EXP 1
3361: NOT
3362: PPUSH
3363: LD_STRING 13s_
3365: PPUSH
3366: CALL 67250 0 3
3370: ST_TO_ADDR
// if Cyrus then
3371: LD_EXP 46
3375: IFFALSE 3393
// tmp := tmp ^ Cyrus ;
3377: LD_ADDR_VAR 0 5
3381: PUSH
3382: LD_VAR 0 5
3386: PUSH
3387: LD_EXP 46
3391: ADD
3392: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3393: LD_ADDR_EXP 47
3397: PUSH
3398: LD_STRING Denis
3400: PPUSH
3401: LD_EXP 1
3405: NOT
3406: PPUSH
3407: LD_STRING 13s_
3409: PPUSH
3410: CALL 67250 0 3
3414: ST_TO_ADDR
// if not Denis then
3415: LD_EXP 47
3419: NOT
3420: IFFALSE 3444
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3422: LD_ADDR_EXP 47
3426: PUSH
3427: LD_STRING Denis
3429: PPUSH
3430: LD_EXP 1
3434: NOT
3435: PPUSH
3436: LD_STRING 13f_
3438: PPUSH
3439: CALL 67250 0 3
3443: ST_TO_ADDR
// if Denis then
3444: LD_EXP 47
3448: IFFALSE 3466
// tmp := tmp ^ Denis ;
3450: LD_ADDR_VAR 0 5
3454: PUSH
3455: LD_VAR 0 5
3459: PUSH
3460: LD_EXP 47
3464: ADD
3465: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3466: LD_ADDR_EXP 48
3470: PUSH
3471: LD_STRING Brown
3473: PPUSH
3474: LD_EXP 1
3478: NOT
3479: PPUSH
3480: LD_STRING 13s_
3482: PPUSH
3483: CALL 67250 0 3
3487: ST_TO_ADDR
// if Brown then
3488: LD_EXP 48
3492: IFFALSE 3510
// tmp := tmp ^ Brown ;
3494: LD_ADDR_VAR 0 5
3498: PUSH
3499: LD_VAR 0 5
3503: PUSH
3504: LD_EXP 48
3508: ADD
3509: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3510: LD_ADDR_EXP 49
3514: PUSH
3515: LD_STRING Gladstone
3517: PPUSH
3518: LD_EXP 1
3522: NOT
3523: PPUSH
3524: LD_STRING 13s_
3526: PPUSH
3527: CALL 67250 0 3
3531: ST_TO_ADDR
// if Gladstone then
3532: LD_EXP 49
3536: IFFALSE 3554
// tmp := tmp ^ Gladstone ;
3538: LD_ADDR_VAR 0 5
3542: PUSH
3543: LD_VAR 0 5
3547: PUSH
3548: LD_EXP 49
3552: ADD
3553: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3554: LD_ADDR_EXP 50
3558: PUSH
3559: LD_STRING Houten
3561: PPUSH
3562: LD_EXP 1
3566: NOT
3567: PPUSH
3568: LD_STRING 13s_
3570: PPUSH
3571: CALL 67250 0 3
3575: ST_TO_ADDR
// if Houten then
3576: LD_EXP 50
3580: IFFALSE 3598
// tmp := tmp ^ Houten ;
3582: LD_ADDR_VAR 0 5
3586: PUSH
3587: LD_VAR 0 5
3591: PUSH
3592: LD_EXP 50
3596: ADD
3597: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3598: LD_ADDR_EXP 51
3602: PUSH
3603: LD_STRING Cornel
3605: PPUSH
3606: LD_EXP 1
3610: NOT
3611: PPUSH
3612: LD_STRING 13s_
3614: PPUSH
3615: CALL 67250 0 3
3619: ST_TO_ADDR
// if Cornel then
3620: LD_EXP 51
3624: IFFALSE 3642
// tmp := tmp ^ Cornel ;
3626: LD_ADDR_VAR 0 5
3630: PUSH
3631: LD_VAR 0 5
3635: PUSH
3636: LD_EXP 51
3640: ADD
3641: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3642: LD_ADDR_EXP 52
3646: PUSH
3647: LD_STRING Gary
3649: PPUSH
3650: LD_EXP 1
3654: NOT
3655: PPUSH
3656: LD_STRING 13s_
3658: PPUSH
3659: CALL 67250 0 3
3663: ST_TO_ADDR
// if Gary then
3664: LD_EXP 52
3668: IFFALSE 3686
// tmp := tmp ^ Gary ;
3670: LD_ADDR_VAR 0 5
3674: PUSH
3675: LD_VAR 0 5
3679: PUSH
3680: LD_EXP 52
3684: ADD
3685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3686: LD_ADDR_EXP 53
3690: PUSH
3691: LD_STRING Frank
3693: PPUSH
3694: LD_EXP 1
3698: NOT
3699: PPUSH
3700: LD_STRING 13s_
3702: PPUSH
3703: CALL 67250 0 3
3707: ST_TO_ADDR
// if Frank then
3708: LD_EXP 53
3712: IFFALSE 3730
// tmp := tmp ^ Frank ;
3714: LD_ADDR_VAR 0 5
3718: PUSH
3719: LD_VAR 0 5
3723: PUSH
3724: LD_EXP 53
3728: ADD
3729: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3730: LD_ADDR_EXP 54
3734: PUSH
3735: LD_STRING Kikuchi
3737: PPUSH
3738: LD_EXP 1
3742: NOT
3743: PPUSH
3744: LD_STRING 13s_
3746: PPUSH
3747: CALL 67250 0 3
3751: ST_TO_ADDR
// if Kikuchi then
3752: LD_EXP 54
3756: IFFALSE 3774
// tmp := tmp ^ Kikuchi ;
3758: LD_ADDR_VAR 0 5
3762: PUSH
3763: LD_VAR 0 5
3767: PUSH
3768: LD_EXP 54
3772: ADD
3773: ST_TO_ADDR
// vip := tmp ;
3774: LD_ADDR_EXP 60
3778: PUSH
3779: LD_VAR 0 5
3783: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3784: LD_ADDR_VAR 0 5
3788: PUSH
3789: LD_VAR 0 5
3793: PUSH
3794: LD_STRING 13s_others
3796: PPUSH
3797: CALL_OW 31
3801: UNION
3802: ST_TO_ADDR
// if tmp < 18 then
3803: LD_VAR 0 5
3807: PUSH
3808: LD_INT 18
3810: LESS
3811: IFFALSE 3904
// for i = 1 to 18 - tmp do
3813: LD_ADDR_VAR 0 2
3817: PUSH
3818: DOUBLE
3819: LD_INT 1
3821: DEC
3822: ST_TO_ADDR
3823: LD_INT 18
3825: PUSH
3826: LD_VAR 0 5
3830: MINUS
3831: PUSH
3832: FOR_TO
3833: IFFALSE 3902
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3835: LD_INT 1
3837: PPUSH
3838: LD_VAR 0 2
3842: PUSH
3843: LD_INT 4
3845: MOD
3846: PUSH
3847: LD_INT 1
3849: PLUS
3850: PPUSH
3851: LD_INT 4
3853: PPUSH
3854: CALL_OW 380
// un := CreateHuman ;
3858: LD_ADDR_VAR 0 10
3862: PUSH
3863: CALL_OW 44
3867: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3868: LD_ADDR_VAR 0 5
3872: PUSH
3873: LD_VAR 0 5
3877: PPUSH
3878: LD_VAR 0 10
3882: PPUSH
3883: CALL 104699 0 2
3887: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3888: LD_VAR 0 10
3892: PPUSH
3893: LD_INT 1
3895: PPUSH
3896: CALL_OW 109
// end ;
3900: GO 3832
3902: POP
3903: POP
// depot := HexInfo ( 53 , 94 ) ;
3904: LD_ADDR_VAR 0 6
3908: PUSH
3909: LD_INT 53
3911: PPUSH
3912: LD_INT 94
3914: PPUSH
3915: CALL_OW 428
3919: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
3920: LD_ADDR_VAR 0 7
3924: PUSH
3925: LD_INT 56
3927: PPUSH
3928: LD_INT 101
3930: PPUSH
3931: CALL_OW 428
3935: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
3936: LD_ADDR_VAR 0 8
3940: PUSH
3941: LD_INT 67
3943: PPUSH
3944: LD_INT 101
3946: PPUSH
3947: CALL_OW 428
3951: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
3952: LD_ADDR_VAR 0 9
3956: PUSH
3957: LD_INT 54
3959: PPUSH
3960: LD_INT 85
3962: PPUSH
3963: CALL_OW 428
3967: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
3968: LD_ADDR_VAR 0 3
3972: PUSH
3973: LD_VAR 0 8
3977: PUSH
3978: LD_VAR 0 6
3982: PUSH
3983: LD_VAR 0 9
3987: PUSH
3988: LD_VAR 0 7
3992: PUSH
3993: EMPTY
3994: LIST
3995: LIST
3996: LIST
3997: LIST
3998: ST_TO_ADDR
// for i in tmp do
3999: LD_ADDR_VAR 0 2
4003: PUSH
4004: LD_VAR 0 5
4008: PUSH
4009: FOR_IN
4010: IFFALSE 4098
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4012: LD_VAR 0 3
4016: PUSH
4017: LD_INT 1
4019: ARRAY
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: EQUAL
4029: IFFALSE 4049
// b := Delete ( b , 1 ) ;
4031: LD_ADDR_VAR 0 3
4035: PUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: LD_INT 1
4043: PPUSH
4044: CALL_OW 3
4048: ST_TO_ADDR
// if b then
4049: LD_VAR 0 3
4053: IFFALSE 4075
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4055: LD_VAR 0 2
4059: PPUSH
4060: LD_VAR 0 3
4064: PUSH
4065: LD_INT 1
4067: ARRAY
4068: PPUSH
4069: CALL_OW 52
4073: GO 4096
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4075: LD_VAR 0 2
4079: PPUSH
4080: LD_INT 61
4082: PPUSH
4083: LD_INT 89
4085: PPUSH
4086: LD_INT 8
4088: PPUSH
4089: LD_INT 0
4091: PPUSH
4092: CALL_OW 50
// end ;
4096: GO 4009
4098: POP
4099: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4100: LD_INT 2
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 1
4108: PPUSH
4109: LD_INT 12
4111: PPUSH
4112: LD_INT 100
4114: PPUSH
4115: CALL 72265 0 5
// veh := CreateVehicle ;
4119: LD_ADDR_VAR 0 4
4123: PUSH
4124: CALL_OW 45
4128: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4129: LD_VAR 0 4
4133: PPUSH
4134: LD_INT 4
4136: PPUSH
4137: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4141: LD_VAR 0 4
4145: PPUSH
4146: LD_INT 49
4148: PPUSH
4149: LD_INT 88
4151: PPUSH
4152: LD_INT 0
4154: PPUSH
4155: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4159: LD_VAR 0 4
4163: PPUSH
4164: LD_INT 1
4166: PPUSH
4167: LD_INT 100
4169: PPUSH
4170: CALL_OW 290
// uc_side := 0 ;
4174: LD_ADDR_OWVAR 20
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// uc_nation := 0 ;
4182: LD_ADDR_OWVAR 21
4186: PUSH
4187: LD_INT 0
4189: ST_TO_ADDR
// for i := 1 to 3 do
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: DOUBLE
4196: LD_INT 1
4198: DEC
4199: ST_TO_ADDR
4200: LD_INT 3
4202: PUSH
4203: FOR_TO
4204: IFFALSE 4235
// begin InitHc ;
4206: CALL_OW 19
// hc_class := class_apeman ;
4210: LD_ADDR_OWVAR 28
4214: PUSH
4215: LD_INT 12
4217: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4218: CALL_OW 44
4222: PPUSH
4223: LD_INT 13
4225: PPUSH
4226: LD_INT 0
4228: PPUSH
4229: CALL_OW 49
// end ;
4233: GO 4203
4235: POP
4236: POP
// end ; end_of_file
4237: LD_VAR 0 1
4241: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4242: LD_INT 0
4244: PPUSH
4245: PPUSH
4246: PPUSH
4247: PPUSH
4248: PPUSH
// side := 8 ;
4249: LD_ADDR_VAR 0 3
4253: PUSH
4254: LD_INT 8
4256: ST_TO_ADDR
// uc_side := side ;
4257: LD_ADDR_OWVAR 20
4261: PUSH
4262: LD_VAR 0 3
4266: ST_TO_ADDR
// uc_nation := 2 ;
4267: LD_ADDR_OWVAR 21
4271: PUSH
4272: LD_INT 2
4274: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4275: LD_ADDR_VAR 0 2
4279: PUSH
4280: LD_INT 22
4282: PUSH
4283: LD_VAR 0 3
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: LD_INT 21
4294: PUSH
4295: LD_INT 3
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PPUSH
4306: CALL_OW 69
4310: PUSH
4311: FOR_IN
4312: IFFALSE 4328
// SetBLevel ( i , 10 ) ;
4314: LD_VAR 0 2
4318: PPUSH
4319: LD_INT 10
4321: PPUSH
4322: CALL_OW 241
4326: GO 4311
4328: POP
4329: POP
// if KurtStatus then
4330: LD_EXP 3
4334: IFFALSE 4357
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4336: LD_ADDR_EXP 61
4340: PUSH
4341: LD_STRING Kurt
4343: PPUSH
4344: LD_INT 0
4346: PPUSH
4347: LD_STRING 
4349: PPUSH
4350: CALL 67250 0 3
4354: ST_TO_ADDR
4355: GO 4379
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4357: LD_ADDR_EXP 61
4361: PUSH
4362: LD_STRING AltKurt
4364: PPUSH
4365: LD_EXP 1
4369: NOT
4370: PPUSH
4371: LD_STRING 
4373: PPUSH
4374: CALL 67250 0 3
4378: ST_TO_ADDR
// if not Kurt then
4379: LD_EXP 61
4383: NOT
4384: IFFALSE 4410
// begin InitHc ;
4386: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4390: LD_INT 1
4392: PPUSH
4393: LD_INT 10
4395: PPUSH
4396: CALL_OW 381
// Kurt := CreateHuman ;
4400: LD_ADDR_EXP 61
4404: PUSH
4405: CALL_OW 44
4409: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4410: LD_EXP 61
4414: PPUSH
4415: LD_INT 324
4417: PPUSH
4418: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4422: LD_ADDR_EXP 62
4426: PUSH
4427: LD_STRING Kozlov
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: LD_STRING 
4435: PPUSH
4436: CALL 67250 0 3
4440: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4441: LD_EXP 62
4445: PPUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 8
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 23
4458: PUSH
4459: LD_INT 3
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 30
4468: PUSH
4469: LD_INT 8
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: LIST
4480: PPUSH
4481: CALL_OW 69
4485: PUSH
4486: LD_INT 1
4488: ARRAY
4489: PPUSH
4490: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4494: LD_EXP 62
4498: PPUSH
4499: LD_INT 3
4501: PPUSH
4502: LD_INT 10
4504: PPUSH
4505: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4509: LD_EXP 62
4513: PPUSH
4514: LD_INT 4
4516: PPUSH
4517: LD_INT 10
4519: PPUSH
4520: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4524: LD_ADDR_VAR 0 5
4528: PUSH
4529: LD_INT 22
4531: PUSH
4532: LD_VAR 0 3
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: LD_INT 30
4543: PUSH
4544: LD_INT 32
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 58
4553: PUSH
4554: EMPTY
4555: LIST
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: LIST
4561: PPUSH
4562: CALL_OW 69
4566: ST_TO_ADDR
// for i = 1 to 10 do
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: DOUBLE
4573: LD_INT 1
4575: DEC
4576: ST_TO_ADDR
4577: LD_INT 10
4579: PUSH
4580: FOR_TO
4581: IFFALSE 4653
// begin uc_nation := nation_nature ;
4583: LD_ADDR_OWVAR 21
4587: PUSH
4588: LD_INT 0
4590: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4591: LD_ADDR_OWVAR 28
4595: PUSH
4596: LD_INT 15
4598: ST_TO_ADDR
// hc_gallery :=  ;
4599: LD_ADDR_OWVAR 33
4603: PUSH
4604: LD_STRING 
4606: ST_TO_ADDR
// hc_name :=  ;
4607: LD_ADDR_OWVAR 26
4611: PUSH
4612: LD_STRING 
4614: ST_TO_ADDR
// un := CreateHuman ;
4615: LD_ADDR_VAR 0 4
4619: PUSH
4620: CALL_OW 44
4624: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4625: LD_VAR 0 4
4629: PPUSH
4630: LD_VAR 0 5
4634: PUSH
4635: LD_VAR 0 5
4639: PUSH
4640: LD_VAR 0 2
4644: MINUS
4645: ARRAY
4646: PPUSH
4647: CALL_OW 52
// end ;
4651: GO 4580
4653: POP
4654: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4655: LD_ADDR_VAR 0 5
4659: PUSH
4660: LD_STRING 12_kurt_squad
4662: PPUSH
4663: CALL_OW 31
4667: ST_TO_ADDR
// if tmp then
4668: LD_VAR 0 5
4672: IFFALSE 4706
// for i in tmp do
4674: LD_ADDR_VAR 0 2
4678: PUSH
4679: LD_VAR 0 5
4683: PUSH
4684: FOR_IN
4685: IFFALSE 4704
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4687: LD_VAR 0 2
4691: PPUSH
4692: LD_INT 5
4694: PPUSH
4695: LD_INT 0
4697: PPUSH
4698: CALL_OW 49
4702: GO 4684
4704: POP
4705: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4706: LD_INT 324
4708: PPUSH
4709: LD_INT 5
4711: PPUSH
4712: LD_STRING 
4714: PPUSH
4715: LD_INT 8
4717: PUSH
4718: LD_INT 9
4720: PUSH
4721: LD_INT 10
4723: PUSH
4724: LD_INT 10
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: PUSH
4733: LD_OWVAR 67
4737: ARRAY
4738: PPUSH
4739: LD_INT 3000
4741: PUSH
4742: LD_INT 500
4744: PUSH
4745: LD_INT 150
4747: PUSH
4748: EMPTY
4749: LIST
4750: LIST
4751: LIST
4752: PPUSH
4753: LD_INT 16
4755: PUSH
4756: LD_INT 6
4758: PUSH
4759: LD_INT 6
4761: PUSH
4762: LD_INT 8
4764: PUSH
4765: EMPTY
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: PPUSH
4771: CALL 75709 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4775: LD_ADDR_EXP 99
4779: PUSH
4780: LD_EXP 99
4784: PPUSH
4785: LD_INT 3
4787: PPUSH
4788: LD_INT 22
4790: PUSH
4791: LD_VAR 0 3
4795: PUSH
4796: EMPTY
4797: LIST
4798: LIST
4799: PUSH
4800: LD_INT 23
4802: PUSH
4803: LD_INT 2
4805: PUSH
4806: EMPTY
4807: LIST
4808: LIST
4809: PUSH
4810: LD_INT 3
4812: PUSH
4813: LD_INT 21
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 69
4836: PUSH
4837: LD_EXP 61
4841: DIFF
4842: PPUSH
4843: CALL_OW 1
4847: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4848: LD_INT 1
4850: PPUSH
4851: LD_INT 7
4853: PPUSH
4854: CALL_OW 383
// Friend := CreateHuman ;
4858: LD_ADDR_EXP 63
4862: PUSH
4863: CALL_OW 44
4867: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4868: LD_INT 14
4870: PPUSH
4871: LD_INT 3
4873: PPUSH
4874: LD_INT 1
4876: PPUSH
4877: LD_INT 29
4879: PPUSH
4880: LD_INT 100
4882: PPUSH
4883: CALL 72265 0 5
// powellBomb := CreateVehicle ;
4887: LD_ADDR_EXP 64
4891: PUSH
4892: CALL_OW 45
4896: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4897: LD_EXP 64
4901: PPUSH
4902: LD_INT 90
4904: PPUSH
4905: LD_INT 51
4907: PPUSH
4908: LD_INT 0
4910: PPUSH
4911: CALL_OW 48
// end ;
4915: LD_VAR 0 1
4919: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4920: LD_INT 0
4922: PPUSH
4923: PPUSH
4924: PPUSH
// if IsLive ( kozlov_fac ) then
4925: LD_INT 332
4927: PPUSH
4928: CALL_OW 300
4932: IFFALSE 4936
// exit ;
4934: GO 5503
// ComExitBuilding ( Kozlov ) ;
4936: LD_EXP 62
4940: PPUSH
4941: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4945: LD_EXP 62
4949: PPUSH
4950: CALL_OW 257
4954: PUSH
4955: LD_INT 2
4957: NONEQUAL
4958: IFFALSE 4993
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4960: LD_EXP 62
4964: PPUSH
4965: LD_INT 324
4967: PPUSH
4968: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4972: LD_EXP 62
4976: PPUSH
4977: LD_INT 2
4979: PPUSH
4980: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4984: LD_EXP 62
4988: PPUSH
4989: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4993: LD_EXP 62
4997: PPUSH
4998: LD_INT 2
5000: PPUSH
5001: LD_INT 93
5003: PPUSH
5004: LD_INT 32
5006: PPUSH
5007: LD_INT 3
5009: PPUSH
5010: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5014: LD_INT 35
5016: PPUSH
5017: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5021: LD_INT 22
5023: PUSH
5024: LD_INT 8
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 30
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 23
5043: PUSH
5044: LD_INT 3
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: LD_INT 57
5053: PUSH
5054: EMPTY
5055: LIST
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 69
5067: IFFALSE 5014
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5069: LD_ADDR_VAR 0 2
5073: PUSH
5074: LD_INT 22
5076: PUSH
5077: LD_INT 8
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 30
5086: PUSH
5087: LD_INT 3
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: PUSH
5094: LD_INT 23
5096: PUSH
5097: LD_INT 3
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 57
5106: PUSH
5107: EMPTY
5108: LIST
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: LIST
5114: LIST
5115: PPUSH
5116: CALL_OW 69
5120: PUSH
5121: LD_INT 1
5123: ARRAY
5124: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5125: LD_INT 22
5127: PUSH
5128: LD_INT 8
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 23
5137: PUSH
5138: LD_INT 3
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 30
5147: PUSH
5148: LD_INT 21
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: LIST
5159: PPUSH
5160: CALL_OW 69
5164: NOT
5165: IFFALSE 5243
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5167: LD_EXP 62
5171: PPUSH
5172: LD_INT 21
5174: PPUSH
5175: LD_INT 97
5177: PPUSH
5178: LD_INT 36
5180: PPUSH
5181: LD_INT 5
5183: PPUSH
5184: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5188: LD_INT 35
5190: PPUSH
5191: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5195: LD_INT 22
5197: PUSH
5198: LD_INT 8
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: PUSH
5205: LD_INT 23
5207: PUSH
5208: LD_INT 3
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PUSH
5215: LD_INT 30
5217: PUSH
5218: LD_INT 21
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 57
5227: PUSH
5228: EMPTY
5229: LIST
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 69
5241: IFFALSE 5188
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5243: LD_INT 22
5245: PUSH
5246: LD_INT 8
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 23
5255: PUSH
5256: LD_INT 3
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 30
5265: PUSH
5266: LD_INT 18
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PPUSH
5278: CALL_OW 69
5282: NOT
5283: IFFALSE 5361
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5285: LD_EXP 62
5289: PPUSH
5290: LD_INT 18
5292: PPUSH
5293: LD_INT 89
5295: PPUSH
5296: LD_INT 32
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5306: LD_INT 35
5308: PPUSH
5309: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5313: LD_INT 22
5315: PUSH
5316: LD_INT 8
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PUSH
5323: LD_INT 23
5325: PUSH
5326: LD_INT 3
5328: PUSH
5329: EMPTY
5330: LIST
5331: LIST
5332: PUSH
5333: LD_INT 30
5335: PUSH
5336: LD_INT 18
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 57
5345: PUSH
5346: EMPTY
5347: LIST
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: PPUSH
5355: CALL_OW 69
5359: IFFALSE 5306
// end ; lab := kozlov_lab ;
5361: LD_ADDR_VAR 0 3
5365: PUSH
5366: LD_INT 336
5368: ST_TO_ADDR
// if not lab then
5369: LD_VAR 0 3
5373: NOT
5374: IFFALSE 5378
// exit ;
5376: GO 5503
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5378: LD_EXP 62
5382: PPUSH
5383: LD_VAR 0 3
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5396: LD_EXP 62
5400: PPUSH
5401: LD_INT 4
5403: PPUSH
5404: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5408: LD_VAR 0 3
5412: PUSH
5413: LD_INT 1
5415: ARRAY
5416: PPUSH
5417: LD_INT 25
5419: PPUSH
5420: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5424: LD_INT 35
5426: PPUSH
5427: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5431: LD_INT 25
5433: PPUSH
5434: LD_INT 8
5436: PPUSH
5437: CALL_OW 321
5441: PUSH
5442: LD_INT 2
5444: EQUAL
5445: IFFALSE 5424
// ComExitBuilding ( Kozlov ) ;
5447: LD_EXP 62
5451: PPUSH
5452: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5456: LD_EXP 62
5460: PPUSH
5461: LD_VAR 0 2
5465: PPUSH
5466: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5470: LD_EXP 62
5474: PPUSH
5475: LD_INT 3
5477: PPUSH
5478: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5482: LD_VAR 0 2
5486: PPUSH
5487: LD_INT 23
5489: PPUSH
5490: LD_INT 3
5492: PPUSH
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 48
5498: PPUSH
5499: CALL_OW 125
// end ;
5503: LD_VAR 0 1
5507: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5508: LD_EXP 22
5512: NOT
5513: PUSH
5514: LD_EXP 15
5518: PUSH
5519: LD_INT 6
5521: GREATEREQUAL
5522: AND
5523: IFFALSE 5604
5525: GO 5527
5527: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5528: LD_INT 3
5530: PPUSH
5531: LD_INT 3
5533: PPUSH
5534: CALL 60999 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5538: LD_INT 3
5540: PPUSH
5541: LD_INT 14
5543: PUSH
5544: LD_INT 1
5546: PUSH
5547: LD_INT 1
5549: PUSH
5550: LD_INT 28
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: LIST
5557: LIST
5558: PUSH
5559: LD_INT 14
5561: PUSH
5562: LD_INT 1
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: LD_INT 28
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: PUSH
5577: LD_INT 14
5579: PUSH
5580: LD_INT 1
5582: PUSH
5583: LD_INT 1
5585: PUSH
5586: LD_INT 28
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: LIST
5593: LIST
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: LIST
5599: PPUSH
5600: CALL 60862 0 2
// end ;
5604: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5605: LD_EXP 22
5609: NOT
5610: PUSH
5611: LD_EXP 15
5615: PUSH
5616: LD_INT 6
5618: GREATEREQUAL
5619: AND
5620: PUSH
5621: LD_INT 3
5623: PPUSH
5624: LD_INT 1
5626: PPUSH
5627: CALL 62280 0 2
5631: NOT
5632: AND
5633: IFFALSE 6507
5635: GO 5637
5637: DISABLE
5638: LD_INT 0
5640: PPUSH
5641: PPUSH
5642: PPUSH
// begin enable ;
5643: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5644: LD_INT 22
5646: PUSH
5647: LD_INT 8
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: LD_INT 23
5656: PUSH
5657: LD_INT 2
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: PUSH
5664: LD_INT 30
5666: PUSH
5667: LD_INT 3
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: PUSH
5674: EMPTY
5675: LIST
5676: LIST
5677: LIST
5678: PPUSH
5679: CALL_OW 69
5683: NOT
5684: IFFALSE 5688
// exit ;
5686: GO 6507
// if Prob ( 40 ) then
5688: LD_INT 40
5690: PPUSH
5691: CALL_OW 13
5695: IFFALSE 5822
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5697: LD_INT 3
5699: PPUSH
5700: LD_INT 14
5702: PUSH
5703: LD_INT 1
5705: PUSH
5706: LD_INT 2
5708: PUSH
5709: LD_INT 28
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 14
5720: PUSH
5721: LD_INT 1
5723: PUSH
5724: LD_INT 2
5726: PUSH
5727: LD_INT 28
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_INT 14
5738: PUSH
5739: LD_INT 1
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 28
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: LIST
5753: PUSH
5754: LD_INT 14
5756: PUSH
5757: LD_INT 1
5759: PUSH
5760: LD_INT 2
5762: PUSH
5763: LD_INT 28
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: LIST
5771: PUSH
5772: LD_INT 14
5774: PUSH
5775: LD_INT 1
5777: PUSH
5778: LD_INT 2
5780: PUSH
5781: LD_INT 28
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: LIST
5788: LIST
5789: PUSH
5790: LD_INT 14
5792: PUSH
5793: LD_INT 1
5795: PUSH
5796: LD_INT 2
5798: PUSH
5799: LD_INT 26
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL 60862 0 2
// end else
5820: GO 6029
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5822: LD_INT 3
5824: PPUSH
5825: LD_INT 14
5827: PUSH
5828: LD_INT 1
5830: PUSH
5831: LD_INT 2
5833: PUSH
5834: LD_INT 27
5836: PUSH
5837: LD_INT 26
5839: PUSH
5840: LD_INT 26
5842: PUSH
5843: LD_INT 28
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_OWVAR 67
5856: ARRAY
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: PUSH
5864: LD_INT 14
5866: PUSH
5867: LD_INT 1
5869: PUSH
5870: LD_INT 2
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: LD_INT 26
5878: PUSH
5879: LD_INT 26
5881: PUSH
5882: LD_INT 26
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: LIST
5889: LIST
5890: PUSH
5891: LD_OWVAR 67
5895: ARRAY
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: LD_INT 26
5917: PUSH
5918: LD_INT 29
5920: PUSH
5921: LD_INT 29
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: PUSH
5930: LD_OWVAR 67
5934: ARRAY
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: PUSH
5942: LD_INT 13
5944: PUSH
5945: LD_INT 1
5947: PUSH
5948: LD_INT 2
5950: PUSH
5951: LD_INT 26
5953: PUSH
5954: LD_INT 29
5956: PUSH
5957: LD_INT 29
5959: PUSH
5960: LD_INT 29
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PUSH
5969: LD_OWVAR 67
5973: ARRAY
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: LD_INT 13
5983: PUSH
5984: LD_INT 1
5986: PUSH
5987: LD_INT 2
5989: PUSH
5990: LD_INT 29
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 14
6001: PUSH
6002: LD_INT 1
6004: PUSH
6005: LD_INT 2
6007: PUSH
6008: LD_INT 26
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: PPUSH
6025: CALL 60862 0 2
// end ; repeat wait ( 0 0$1 ) ;
6029: LD_INT 35
6031: PPUSH
6032: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 62280 0 2
6046: PUSH
6047: LD_INT 6
6049: GREATEREQUAL
6050: IFFALSE 6029
// wait ( 0 0$30 ) ;
6052: LD_INT 1050
6054: PPUSH
6055: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6059: LD_ADDR_VAR 0 2
6063: PUSH
6064: LD_INT 3
6066: PPUSH
6067: LD_INT 1
6069: PPUSH
6070: CALL 62280 0 2
6074: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6075: LD_ADDR_EXP 118
6079: PUSH
6080: LD_EXP 118
6084: PPUSH
6085: LD_INT 3
6087: PPUSH
6088: LD_EXP 118
6092: PUSH
6093: LD_INT 3
6095: ARRAY
6096: PUSH
6097: LD_VAR 0 2
6101: DIFF
6102: PPUSH
6103: CALL_OW 1
6107: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6108: LD_ADDR_VAR 0 3
6112: PUSH
6113: LD_INT 0
6115: PPUSH
6116: LD_INT 2
6118: PPUSH
6119: CALL_OW 12
6123: ST_TO_ADDR
// if target then
6124: LD_VAR 0 3
6128: IFFALSE 6265
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6130: LD_ADDR_VAR 0 2
6134: PUSH
6135: LD_VAR 0 2
6139: PPUSH
6140: LD_INT 24
6142: PUSH
6143: LD_INT 250
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PPUSH
6150: CALL_OW 72
6154: ST_TO_ADDR
// if not tmp then
6155: LD_VAR 0 2
6159: NOT
6160: IFFALSE 6164
// break ;
6162: GO 6263
// for i in tmp do
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: LD_VAR 0 2
6173: PUSH
6174: FOR_IN
6175: IFFALSE 6215
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6177: LD_VAR 0 1
6181: PPUSH
6182: LD_INT 89
6184: PPUSH
6185: LD_INT 71
6187: PPUSH
6188: CALL_OW 297
6192: PUSH
6193: LD_INT 9
6195: GREATER
6196: IFFALSE 6213
// ComMoveXY ( i , 89 , 71 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 89
6205: PPUSH
6206: LD_INT 71
6208: PPUSH
6209: CALL_OW 111
6213: GO 6174
6215: POP
6216: POP
// wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6224: LD_VAR 0 2
6228: PPUSH
6229: LD_INT 92
6231: PUSH
6232: LD_INT 89
6234: PUSH
6235: LD_INT 71
6237: PUSH
6238: LD_INT 9
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_VAR 0 2
6256: PUSH
6257: LD_INT 1
6259: MINUS
6260: GREATEREQUAL
6261: IFFALSE 6130
// end else
6263: GO 6398
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6265: LD_ADDR_VAR 0 2
6269: PUSH
6270: LD_VAR 0 2
6274: PPUSH
6275: LD_INT 24
6277: PUSH
6278: LD_INT 250
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PPUSH
6285: CALL_OW 72
6289: ST_TO_ADDR
// if not tmp then
6290: LD_VAR 0 2
6294: NOT
6295: IFFALSE 6299
// break ;
6297: GO 6398
// for i in tmp do
6299: LD_ADDR_VAR 0 1
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: FOR_IN
6310: IFFALSE 6350
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6312: LD_VAR 0 1
6316: PPUSH
6317: LD_INT 125
6319: PPUSH
6320: LD_INT 129
6322: PPUSH
6323: CALL_OW 297
6327: PUSH
6328: LD_INT 9
6330: GREATER
6331: IFFALSE 6348
// ComMoveXY ( i , 125 , 129 ) ;
6333: LD_VAR 0 1
6337: PPUSH
6338: LD_INT 125
6340: PPUSH
6341: LD_INT 129
6343: PPUSH
6344: CALL_OW 111
6348: GO 6309
6350: POP
6351: POP
// wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6359: LD_VAR 0 2
6363: PPUSH
6364: LD_INT 92
6366: PUSH
6367: LD_INT 125
6369: PUSH
6370: LD_INT 129
6372: PUSH
6373: LD_INT 9
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: PPUSH
6382: CALL_OW 72
6386: PUSH
6387: LD_VAR 0 2
6391: PUSH
6392: LD_INT 1
6394: MINUS
6395: GREATEREQUAL
6396: IFFALSE 6265
// end ; repeat wait ( 0 0$1 ) ;
6398: LD_INT 35
6400: PPUSH
6401: CALL_OW 67
// for i in tmp do
6405: LD_ADDR_VAR 0 1
6409: PUSH
6410: LD_VAR 0 2
6414: PUSH
6415: FOR_IN
6416: IFFALSE 6498
// begin if GetLives ( i ) > 251 then
6418: LD_VAR 0 1
6422: PPUSH
6423: CALL_OW 256
6427: PUSH
6428: LD_INT 251
6430: GREATER
6431: IFFALSE 6469
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6433: LD_VAR 0 1
6437: PPUSH
6438: LD_INT 81
6440: PUSH
6441: LD_INT 8
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PPUSH
6448: CALL_OW 69
6452: PPUSH
6453: LD_VAR 0 1
6457: PPUSH
6458: CALL_OW 74
6462: PPUSH
6463: CALL_OW 115
6467: GO 6496
// if IsDead ( i ) then
6469: LD_VAR 0 1
6473: PPUSH
6474: CALL_OW 301
6478: IFFALSE 6496
// tmp := tmp diff i ;
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: LD_VAR 0 2
6489: PUSH
6490: LD_VAR 0 1
6494: DIFF
6495: ST_TO_ADDR
// end ;
6496: GO 6415
6498: POP
6499: POP
// until not tmp ;
6500: LD_VAR 0 2
6504: NOT
6505: IFFALSE 6398
// end ;
6507: PPOPN 3
6509: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6510: LD_EXP 22
6514: NOT
6515: PUSH
6516: LD_EXP 15
6520: PUSH
6521: LD_INT 6
6523: GREATEREQUAL
6524: AND
6525: PUSH
6526: LD_OWVAR 67
6530: PUSH
6531: LD_INT 1
6533: GREATER
6534: AND
6535: IFFALSE 7068
6537: GO 6539
6539: DISABLE
6540: LD_INT 0
6542: PPUSH
6543: PPUSH
6544: PPUSH
// begin enable ;
6545: ENABLE
// tmp := [ ] ;
6546: LD_ADDR_VAR 0 3
6550: PUSH
6551: EMPTY
6552: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: DOUBLE
6559: LD_INT 1
6561: DEC
6562: ST_TO_ADDR
6563: LD_INT 4
6565: PUSH
6566: LD_INT 6
6568: PUSH
6569: LD_INT 7
6571: PUSH
6572: LD_INT 8
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: LIST
6579: LIST
6580: PUSH
6581: LD_OWVAR 67
6585: ARRAY
6586: PUSH
6587: FOR_TO
6588: IFFALSE 6748
// begin uc_side := 8 ;
6590: LD_ADDR_OWVAR 20
6594: PUSH
6595: LD_INT 8
6597: ST_TO_ADDR
// uc_nation := 2 ;
6598: LD_ADDR_OWVAR 21
6602: PUSH
6603: LD_INT 2
6605: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6606: LD_INT 13
6608: PUSH
6609: LD_INT 14
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: PUSH
6616: LD_INT 1
6618: PPUSH
6619: LD_INT 2
6621: PPUSH
6622: CALL_OW 12
6626: ARRAY
6627: PPUSH
6628: LD_INT 1
6630: PPUSH
6631: LD_INT 5
6633: PPUSH
6634: LD_INT 27
6636: PUSH
6637: LD_INT 28
6639: PUSH
6640: LD_INT 26
6642: PUSH
6643: LD_INT 25
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 4
6657: PPUSH
6658: CALL_OW 12
6662: ARRAY
6663: PPUSH
6664: LD_INT 88
6666: PPUSH
6667: CALL 72265 0 5
// un := CreateVehicle ;
6671: LD_ADDR_VAR 0 2
6675: PUSH
6676: CALL_OW 45
6680: ST_TO_ADDR
// tmp := tmp ^ un ;
6681: LD_ADDR_VAR 0 3
6685: PUSH
6686: LD_VAR 0 3
6690: PUSH
6691: LD_VAR 0 2
6695: ADD
6696: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6697: LD_VAR 0 2
6701: PPUSH
6702: LD_INT 3
6704: PPUSH
6705: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6709: LD_VAR 0 2
6713: PPUSH
6714: LD_INT 30
6716: PPUSH
6717: LD_INT 0
6719: PPUSH
6720: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6724: LD_VAR 0 2
6728: PPUSH
6729: LD_INT 16
6731: PPUSH
6732: LD_INT 11
6734: PPUSH
6735: CALL_OW 111
// wait ( 0 0$2 ) ;
6739: LD_INT 70
6741: PPUSH
6742: CALL_OW 67
// end ;
6746: GO 6587
6748: POP
6749: POP
// for i = 1 to Difficulty do
6750: LD_ADDR_VAR 0 1
6754: PUSH
6755: DOUBLE
6756: LD_INT 1
6758: DEC
6759: ST_TO_ADDR
6760: LD_OWVAR 67
6764: PUSH
6765: FOR_TO
6766: IFFALSE 6895
// begin uc_side := 8 ;
6768: LD_ADDR_OWVAR 20
6772: PUSH
6773: LD_INT 8
6775: ST_TO_ADDR
// uc_nation := 2 ;
6776: LD_ADDR_OWVAR 21
6780: PUSH
6781: LD_INT 2
6783: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6784: LD_INT 0
6786: PPUSH
6787: LD_INT 8
6789: PPUSH
6790: LD_INT 8
6792: PUSH
6793: LD_INT 8
6795: PUSH
6796: LD_INT 9
6798: PUSH
6799: LD_INT 10
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_OWVAR 67
6812: ARRAY
6813: PPUSH
6814: CALL_OW 380
// un := CreateHuman ;
6818: LD_ADDR_VAR 0 2
6822: PUSH
6823: CALL_OW 44
6827: ST_TO_ADDR
// tmp := tmp ^ un ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_VAR 0 3
6837: PUSH
6838: LD_VAR 0 2
6842: ADD
6843: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6844: LD_VAR 0 2
6848: PPUSH
6849: LD_INT 3
6851: PPUSH
6852: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6856: LD_VAR 0 2
6860: PPUSH
6861: LD_INT 30
6863: PPUSH
6864: LD_INT 0
6866: PPUSH
6867: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 16
6878: PPUSH
6879: LD_INT 11
6881: PPUSH
6882: CALL_OW 111
// wait ( 0 0$2 ) ;
6886: LD_INT 70
6888: PPUSH
6889: CALL_OW 67
// end ;
6893: GO 6765
6895: POP
6896: POP
// repeat wait ( 0 0$1 ) ;
6897: LD_INT 35
6899: PPUSH
6900: CALL_OW 67
// if legionDestroyed then
6904: LD_EXP 22
6908: IFFALSE 6912
// exit ;
6910: GO 7068
// for i in tmp do
6912: LD_ADDR_VAR 0 1
6916: PUSH
6917: LD_VAR 0 3
6921: PUSH
6922: FOR_IN
6923: IFFALSE 7059
// begin if GetLives ( i ) > 250 then
6925: LD_VAR 0 1
6929: PPUSH
6930: CALL_OW 256
6934: PUSH
6935: LD_INT 250
6937: GREATER
6938: IFFALSE 7030
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6940: LD_INT 81
6942: PUSH
6943: LD_INT 8
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: LD_INT 91
6952: PUSH
6953: LD_VAR 0 1
6957: PUSH
6958: LD_INT 10
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PPUSH
6970: CALL_OW 69
6974: NOT
6975: IFFALSE 6994
// ComAgressiveMove ( i , 67 , 110 ) else
6977: LD_VAR 0 1
6981: PPUSH
6982: LD_INT 67
6984: PPUSH
6985: LD_INT 110
6987: PPUSH
6988: CALL_OW 114
6992: GO 7028
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6994: LD_VAR 0 1
6998: PPUSH
6999: LD_INT 81
7001: PUSH
7002: LD_INT 8
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PPUSH
7014: LD_VAR 0 1
7018: PPUSH
7019: CALL_OW 74
7023: PPUSH
7024: CALL_OW 115
// end else
7028: GO 7057
// if IsDead ( i ) then
7030: LD_VAR 0 1
7034: PPUSH
7035: CALL_OW 301
7039: IFFALSE 7057
// tmp := tmp diff i ;
7041: LD_ADDR_VAR 0 3
7045: PUSH
7046: LD_VAR 0 3
7050: PUSH
7051: LD_VAR 0 1
7055: DIFF
7056: ST_TO_ADDR
// end ;
7057: GO 6922
7059: POP
7060: POP
// until not tmp ;
7061: LD_VAR 0 3
7065: NOT
7066: IFFALSE 6897
// end ; end_of_file
7068: PPOPN 3
7070: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7071: LD_INT 0
7073: PPUSH
7074: PPUSH
7075: PPUSH
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
7080: PPUSH
7081: PPUSH
// side := 3 ;
7082: LD_ADDR_VAR 0 6
7086: PUSH
7087: LD_INT 3
7089: ST_TO_ADDR
// uc_side := side ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_VAR 0 6
7099: ST_TO_ADDR
// uc_nation := 3 ;
7100: LD_ADDR_OWVAR 21
7104: PUSH
7105: LD_INT 3
7107: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7108: LD_ADDR_VAR 0 2
7112: PUSH
7113: LD_INT 22
7115: PUSH
7116: LD_VAR 0 6
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 21
7127: PUSH
7128: LD_INT 3
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: PUSH
7144: FOR_IN
7145: IFFALSE 7161
// SetBLevel ( i , 10 ) ;
7147: LD_VAR 0 2
7151: PPUSH
7152: LD_INT 10
7154: PPUSH
7155: CALL_OW 241
7159: GO 7144
7161: POP
7162: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7163: LD_ADDR_VAR 0 9
7167: PUSH
7168: LD_INT 22
7170: PUSH
7171: LD_VAR 0 6
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: LD_INT 30
7182: PUSH
7183: LD_INT 34
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PPUSH
7194: CALL_OW 69
7198: ST_TO_ADDR
// if teleport then
7199: LD_VAR 0 9
7203: IFFALSE 7224
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7205: LD_VAR 0 9
7209: PUSH
7210: LD_INT 1
7212: ARRAY
7213: PPUSH
7214: LD_INT 123
7216: PPUSH
7217: LD_INT 122
7219: PPUSH
7220: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7224: LD_ADDR_EXP 65
7228: PUSH
7229: LD_STRING Platonov
7231: PPUSH
7232: CALL_OW 25
7236: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7237: LD_ADDR_EXP 66
7241: PUSH
7242: LD_STRING Kovalyuk
7244: PPUSH
7245: CALL_OW 25
7249: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7250: LD_ADDR_EXP 68
7254: PUSH
7255: LD_STRING Yakotich
7257: PPUSH
7258: LD_EXP 1
7262: NOT
7263: PPUSH
7264: LD_STRING 09_
7266: PPUSH
7267: CALL 67250 0 3
7271: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7272: LD_ADDR_EXP 67
7276: PUSH
7277: LD_STRING Bystrov
7279: PPUSH
7280: CALL_OW 25
7284: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7285: LD_ADDR_EXP 69
7289: PUSH
7290: LD_STRING Gleb
7292: PPUSH
7293: CALL_OW 25
7297: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7298: LD_STRING 03_Cornel
7300: PPUSH
7301: CALL_OW 28
7305: IFFALSE 7353
// begin Bierezov := NewCharacter ( Mikhail ) ;
7307: LD_ADDR_EXP 70
7311: PUSH
7312: LD_STRING Mikhail
7314: PPUSH
7315: CALL_OW 25
7319: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7320: LD_EXP 70
7324: PPUSH
7325: LD_INT 197
7327: PPUSH
7328: LD_INT 111
7330: PPUSH
7331: LD_INT 9
7333: PPUSH
7334: LD_INT 0
7336: PPUSH
7337: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7341: LD_EXP 70
7345: PPUSH
7346: LD_INT 3
7348: PPUSH
7349: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7353: LD_EXP 65
7357: PPUSH
7358: LD_INT 126
7360: PPUSH
7361: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7365: LD_EXP 66
7369: PPUSH
7370: LD_INT 134
7372: PPUSH
7373: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7377: LD_EXP 68
7381: PPUSH
7382: LD_INT 197
7384: PPUSH
7385: LD_INT 111
7387: PPUSH
7388: LD_INT 9
7390: PPUSH
7391: LD_INT 0
7393: PPUSH
7394: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7398: LD_EXP 67
7402: PPUSH
7403: LD_INT 197
7405: PPUSH
7406: LD_INT 111
7408: PPUSH
7409: LD_INT 9
7411: PPUSH
7412: LD_INT 0
7414: PPUSH
7415: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7419: LD_EXP 69
7423: PPUSH
7424: LD_INT 197
7426: PPUSH
7427: LD_INT 111
7429: PPUSH
7430: LD_INT 9
7432: PPUSH
7433: LD_INT 0
7435: PPUSH
7436: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7440: LD_ADDR_VAR 0 5
7444: PUSH
7445: LD_INT 126
7447: PPUSH
7448: LD_INT 4
7450: PPUSH
7451: LD_STRING zhukov
7453: PPUSH
7454: LD_INT 9
7456: PUSH
7457: LD_INT 10
7459: PUSH
7460: LD_INT 10
7462: PUSH
7463: LD_INT 10
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: LIST
7471: PUSH
7472: LD_OWVAR 67
7476: ARRAY
7477: PPUSH
7478: LD_INT 90000
7480: PUSH
7481: LD_INT 1000
7483: PUSH
7484: LD_INT 300
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: LIST
7491: PPUSH
7492: LD_INT 18
7494: PUSH
7495: LD_INT 8
7497: PUSH
7498: LD_INT 13
7500: PUSH
7501: LD_INT 8
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: LIST
7508: LIST
7509: PPUSH
7510: CALL 75709 0 6
7514: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7515: LD_ADDR_VAR 0 4
7519: PUSH
7520: LD_INT 267
7522: PPUSH
7523: CALL_OW 274
7527: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7528: LD_VAR 0 4
7532: PPUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_INT 5000
7538: PPUSH
7539: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7543: LD_VAR 0 4
7547: PPUSH
7548: LD_INT 2
7550: PPUSH
7551: LD_INT 200
7553: PPUSH
7554: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7558: LD_VAR 0 4
7562: PPUSH
7563: LD_INT 3
7565: PPUSH
7566: LD_INT 200
7568: PPUSH
7569: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7573: LD_ADDR_EXP 99
7577: PUSH
7578: LD_EXP 99
7582: PPUSH
7583: LD_INT 2
7585: PPUSH
7586: LD_VAR 0 5
7590: PUSH
7591: LD_INT 22
7593: PUSH
7594: LD_VAR 0 6
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: LD_INT 21
7608: PUSH
7609: LD_INT 2
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: UNION
7629: PUSH
7630: LD_EXP 65
7634: DIFF
7635: PPUSH
7636: CALL_OW 1
7640: ST_TO_ADDR
// behemoths := [ ] ;
7641: LD_ADDR_EXP 73
7645: PUSH
7646: EMPTY
7647: ST_TO_ADDR
// behemothBuilders := [ ] ;
7648: LD_ADDR_EXP 74
7652: PUSH
7653: EMPTY
7654: ST_TO_ADDR
// if Kovalyuk then
7655: LD_EXP 66
7659: IFFALSE 7681
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7661: LD_ADDR_EXP 74
7665: PUSH
7666: LD_EXP 74
7670: PPUSH
7671: LD_EXP 66
7675: PPUSH
7676: CALL 104699 0 2
7680: ST_TO_ADDR
// j := 3 ;
7681: LD_ADDR_VAR 0 3
7685: PUSH
7686: LD_INT 3
7688: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7689: LD_ADDR_VAR 0 2
7693: PUSH
7694: LD_INT 22
7696: PUSH
7697: LD_INT 3
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 25
7706: PUSH
7707: LD_INT 3
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL_OW 69
7722: PUSH
7723: LD_EXP 66
7727: DIFF
7728: PUSH
7729: FOR_IN
7730: IFFALSE 7780
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7732: LD_ADDR_EXP 74
7736: PUSH
7737: LD_EXP 74
7741: PPUSH
7742: LD_VAR 0 2
7746: PPUSH
7747: CALL 104699 0 2
7751: ST_TO_ADDR
// j := j - 1 ;
7752: LD_ADDR_VAR 0 3
7756: PUSH
7757: LD_VAR 0 3
7761: PUSH
7762: LD_INT 1
7764: MINUS
7765: ST_TO_ADDR
// if j = 0 then
7766: LD_VAR 0 3
7770: PUSH
7771: LD_INT 0
7773: EQUAL
7774: IFFALSE 7778
// break ;
7776: GO 7780
// end ;
7778: GO 7729
7780: POP
7781: POP
// end ;
7782: LD_VAR 0 1
7786: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7787: LD_INT 0
7789: PPUSH
7790: PPUSH
7791: PPUSH
7792: PPUSH
7793: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7794: LD_ADDR_VAR 0 4
7798: PUSH
7799: LD_INT 209
7801: PUSH
7802: LD_INT 149
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PUSH
7809: LD_INT 219
7811: PUSH
7812: LD_INT 154
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: PUSH
7819: LD_INT 223
7821: PUSH
7822: LD_INT 149
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: LD_INT 232
7831: PUSH
7832: LD_INT 155
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: ST_TO_ADDR
// if not behemothBuilders then
7845: LD_EXP 74
7849: NOT
7850: IFFALSE 7854
// exit ;
7852: GO 7985
// j := 1 ;
7854: LD_ADDR_VAR 0 3
7858: PUSH
7859: LD_INT 1
7861: ST_TO_ADDR
// for i in behemothBuilders do
7862: LD_ADDR_VAR 0 2
7866: PUSH
7867: LD_EXP 74
7871: PUSH
7872: FOR_IN
7873: IFFALSE 7983
// begin if GetClass ( i ) <> class_mechanic then
7875: LD_VAR 0 2
7879: PPUSH
7880: CALL_OW 257
7884: PUSH
7885: LD_INT 3
7887: NONEQUAL
7888: IFFALSE 7902
// SetClass ( i , class_mechanic ) ;
7890: LD_VAR 0 2
7894: PPUSH
7895: LD_INT 3
7897: PPUSH
7898: CALL_OW 336
// if IsInUnit ( i ) then
7902: LD_VAR 0 2
7906: PPUSH
7907: CALL_OW 310
7911: IFFALSE 7922
// ComExitBuilding ( i ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7922: LD_VAR 0 2
7926: PPUSH
7927: LD_INT 37
7929: PPUSH
7930: LD_VAR 0 4
7934: PUSH
7935: LD_VAR 0 3
7939: ARRAY
7940: PUSH
7941: LD_INT 1
7943: ARRAY
7944: PPUSH
7945: LD_VAR 0 4
7949: PUSH
7950: LD_VAR 0 3
7954: ARRAY
7955: PUSH
7956: LD_INT 2
7958: ARRAY
7959: PPUSH
7960: LD_INT 0
7962: PPUSH
7963: CALL_OW 230
// j := j + 1 ;
7967: LD_ADDR_VAR 0 3
7971: PUSH
7972: LD_VAR 0 3
7976: PUSH
7977: LD_INT 1
7979: PLUS
7980: ST_TO_ADDR
// end ;
7981: GO 7872
7983: POP
7984: POP
// end ;
7985: LD_VAR 0 1
7989: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7990: LD_INT 24
7992: PPUSH
7993: LD_INT 30
7995: PUSH
7996: LD_INT 37
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PPUSH
8003: CALL_OW 70
8007: IFFALSE 8020
8009: GO 8011
8011: DISABLE
// behemothUnderConstruct := true ;
8012: LD_ADDR_EXP 26
8016: PUSH
8017: LD_INT 1
8019: ST_TO_ADDR
8020: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8021: LD_INT 3
8023: PPUSH
8024: CALL 104760 0 1
8028: PUSH
8029: LD_INT 22
8031: PUSH
8032: LD_INT 3
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: PUSH
8039: LD_INT 30
8041: PUSH
8042: LD_INT 37
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: PPUSH
8053: CALL_OW 69
8057: NOT
8058: AND
8059: IFFALSE 8245
8061: GO 8063
8063: DISABLE
8064: LD_INT 0
8066: PPUSH
8067: PPUSH
// begin enable ;
8068: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8069: LD_ADDR_VAR 0 2
8073: PUSH
8074: LD_INT 3
8076: PPUSH
8077: CALL 104760 0 1
8081: ST_TO_ADDR
// for i in tmp do
8082: LD_ADDR_VAR 0 1
8086: PUSH
8087: LD_VAR 0 2
8091: PUSH
8092: FOR_IN
8093: IFFALSE 8243
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8095: LD_VAR 0 1
8099: PPUSH
8100: LD_INT 9
8102: PPUSH
8103: CALL_OW 308
8107: PUSH
8108: LD_VAR 0 1
8112: PPUSH
8113: CALL_OW 110
8117: PUSH
8118: LD_INT 2
8120: EQUAL
8121: NOT
8122: AND
8123: IFFALSE 8137
// SetTag ( i , 2 ) ;
8125: LD_VAR 0 1
8129: PPUSH
8130: LD_INT 2
8132: PPUSH
8133: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8137: LD_INT 81
8139: PUSH
8140: LD_INT 3
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: PUSH
8147: LD_INT 91
8149: PUSH
8150: LD_VAR 0 1
8154: PUSH
8155: LD_INT 12
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: LIST
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: NOT
8172: PUSH
8173: LD_VAR 0 1
8177: PPUSH
8178: CALL_OW 110
8182: PUSH
8183: LD_INT 2
8185: EQUAL
8186: NOT
8187: AND
8188: IFFALSE 8207
// ComAgressiveMove ( i , 64 , 93 ) else
8190: LD_VAR 0 1
8194: PPUSH
8195: LD_INT 64
8197: PPUSH
8198: LD_INT 93
8200: PPUSH
8201: CALL_OW 114
8205: GO 8241
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8207: LD_VAR 0 1
8211: PPUSH
8212: LD_INT 81
8214: PUSH
8215: LD_INT 3
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: PPUSH
8222: CALL_OW 69
8226: PPUSH
8227: LD_VAR 0 1
8231: PPUSH
8232: CALL_OW 74
8236: PPUSH
8237: CALL_OW 115
// end ;
8241: GO 8092
8243: POP
8244: POP
// end ;
8245: PPOPN 2
8247: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8248: LD_INT 0
8250: PPUSH
8251: PPUSH
8252: PPUSH
// result := [ ] ;
8253: LD_ADDR_VAR 0 2
8257: PUSH
8258: EMPTY
8259: ST_TO_ADDR
// uc_side := 6 ;
8260: LD_ADDR_OWVAR 20
8264: PUSH
8265: LD_INT 6
8267: ST_TO_ADDR
// uc_nation := 3 ;
8268: LD_ADDR_OWVAR 21
8272: PUSH
8273: LD_INT 3
8275: ST_TO_ADDR
// case strength of 1 :
8276: LD_VAR 0 1
8280: PUSH
8281: LD_INT 1
8283: DOUBLE
8284: EQUAL
8285: IFTRUE 8289
8287: GO 8431
8289: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 4
8302: PUSH
8303: LD_INT 5
8305: PUSH
8306: LD_INT 6
8308: PUSH
8309: LD_INT 7
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: LIST
8316: LIST
8317: PUSH
8318: LD_OWVAR 67
8322: ARRAY
8323: PUSH
8324: FOR_TO
8325: IFFALSE 8427
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8327: LD_INT 22
8329: PUSH
8330: LD_INT 24
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: PUSH
8337: LD_VAR 0 3
8341: PUSH
8342: LD_INT 2
8344: MOD
8345: PUSH
8346: LD_INT 1
8348: PLUS
8349: ARRAY
8350: PPUSH
8351: LD_INT 1
8353: PUSH
8354: LD_INT 3
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 2
8366: PPUSH
8367: CALL_OW 12
8371: ARRAY
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_INT 43
8378: PUSH
8379: LD_INT 44
8381: PUSH
8382: LD_INT 45
8384: PUSH
8385: EMPTY
8386: LIST
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 1
8392: PPUSH
8393: LD_INT 3
8395: PPUSH
8396: CALL_OW 12
8400: ARRAY
8401: PPUSH
8402: LD_INT 80
8404: PPUSH
8405: CALL 72265 0 5
// result := result union CreateVehicle ;
8409: LD_ADDR_VAR 0 2
8413: PUSH
8414: LD_VAR 0 2
8418: PUSH
8419: CALL_OW 45
8423: UNION
8424: ST_TO_ADDR
// end ;
8425: GO 8324
8427: POP
8428: POP
// end ; 2 :
8429: GO 9426
8431: LD_INT 2
8433: DOUBLE
8434: EQUAL
8435: IFTRUE 8439
8437: GO 8607
8439: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8440: LD_ADDR_VAR 0 3
8444: PUSH
8445: DOUBLE
8446: LD_INT 1
8448: DEC
8449: ST_TO_ADDR
8450: LD_INT 5
8452: PUSH
8453: LD_INT 6
8455: PUSH
8456: LD_INT 7
8458: PUSH
8459: LD_INT 8
8461: PUSH
8462: EMPTY
8463: LIST
8464: LIST
8465: LIST
8466: LIST
8467: PUSH
8468: LD_OWVAR 67
8472: ARRAY
8473: PUSH
8474: FOR_TO
8475: IFFALSE 8603
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8477: LD_INT 22
8479: PUSH
8480: LD_INT 24
8482: PUSH
8483: LD_INT 24
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: LIST
8490: PUSH
8491: LD_VAR 0 3
8495: PUSH
8496: LD_INT 3
8498: MOD
8499: PUSH
8500: LD_INT 1
8502: PLUS
8503: ARRAY
8504: PPUSH
8505: LD_INT 1
8507: PUSH
8508: LD_INT 3
8510: PUSH
8511: EMPTY
8512: LIST
8513: LIST
8514: PUSH
8515: LD_INT 1
8517: PPUSH
8518: LD_INT 2
8520: PPUSH
8521: CALL_OW 12
8525: ARRAY
8526: PPUSH
8527: LD_INT 3
8529: PPUSH
8530: LD_INT 43
8532: PUSH
8533: LD_INT 44
8535: PUSH
8536: LD_INT 45
8538: PUSH
8539: LD_INT 44
8541: PUSH
8542: LD_INT 46
8544: PUSH
8545: LD_INT 46
8547: PUSH
8548: LD_INT 49
8550: PUSH
8551: LD_INT 49
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: PUSH
8564: LD_VAR 0 3
8568: PUSH
8569: LD_INT 8
8571: MOD
8572: PUSH
8573: LD_INT 1
8575: PLUS
8576: ARRAY
8577: PPUSH
8578: LD_INT 80
8580: PPUSH
8581: CALL 72265 0 5
// result := result union CreateVehicle ;
8585: LD_ADDR_VAR 0 2
8589: PUSH
8590: LD_VAR 0 2
8594: PUSH
8595: CALL_OW 45
8599: UNION
8600: ST_TO_ADDR
// end ;
8601: GO 8474
8603: POP
8604: POP
// end ; 3 :
8605: GO 9426
8607: LD_INT 3
8609: DOUBLE
8610: EQUAL
8611: IFTRUE 8615
8613: GO 8787
8615: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8616: LD_ADDR_VAR 0 3
8620: PUSH
8621: DOUBLE
8622: LD_INT 1
8624: DEC
8625: ST_TO_ADDR
8626: LD_INT 6
8628: PUSH
8629: LD_INT 7
8631: PUSH
8632: LD_INT 8
8634: PUSH
8635: LD_INT 9
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: FOR_TO
8651: IFFALSE 8783
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8653: LD_INT 22
8655: PUSH
8656: LD_INT 24
8658: PUSH
8659: LD_INT 24
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: LIST
8666: PUSH
8667: LD_VAR 0 3
8671: PUSH
8672: LD_INT 3
8674: MOD
8675: PUSH
8676: LD_INT 1
8678: PLUS
8679: ARRAY
8680: PPUSH
8681: LD_INT 1
8683: PUSH
8684: LD_INT 3
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PUSH
8691: LD_INT 1
8693: PPUSH
8694: LD_INT 2
8696: PPUSH
8697: CALL_OW 12
8701: ARRAY
8702: PPUSH
8703: LD_INT 3
8705: PPUSH
8706: LD_INT 43
8708: PUSH
8709: LD_INT 47
8711: PUSH
8712: LD_INT 45
8714: PUSH
8715: LD_INT 45
8717: PUSH
8718: LD_INT 46
8720: PUSH
8721: LD_INT 46
8723: PUSH
8724: LD_INT 49
8726: PUSH
8727: LD_INT 49
8729: PUSH
8730: LD_INT 49
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: LD_VAR 0 3
8748: PUSH
8749: LD_INT 9
8751: MOD
8752: PUSH
8753: LD_INT 1
8755: PLUS
8756: ARRAY
8757: PPUSH
8758: LD_INT 80
8760: PPUSH
8761: CALL 72265 0 5
// result := result union CreateVehicle ;
8765: LD_ADDR_VAR 0 2
8769: PUSH
8770: LD_VAR 0 2
8774: PUSH
8775: CALL_OW 45
8779: UNION
8780: ST_TO_ADDR
// end ;
8781: GO 8650
8783: POP
8784: POP
// end ; 4 :
8785: GO 9426
8787: LD_INT 4
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 9425
8795: POP
// begin uc_nation := 3 ;
8796: LD_ADDR_OWVAR 21
8800: PUSH
8801: LD_INT 3
8803: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8804: LD_ADDR_VAR 0 3
8808: PUSH
8809: DOUBLE
8810: LD_INT 1
8812: DEC
8813: ST_TO_ADDR
8814: LD_INT 6
8816: PUSH
8817: LD_INT 8
8819: PUSH
8820: LD_INT 9
8822: PUSH
8823: LD_INT 10
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: PUSH
8832: LD_OWVAR 67
8836: ARRAY
8837: PUSH
8838: FOR_TO
8839: IFFALSE 8971
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8841: LD_INT 22
8843: PUSH
8844: LD_INT 24
8846: PUSH
8847: LD_INT 24
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: LIST
8854: PUSH
8855: LD_VAR 0 3
8859: PUSH
8860: LD_INT 3
8862: MOD
8863: PUSH
8864: LD_INT 1
8866: PLUS
8867: ARRAY
8868: PPUSH
8869: LD_INT 1
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 1
8881: PPUSH
8882: LD_INT 2
8884: PPUSH
8885: CALL_OW 12
8889: ARRAY
8890: PPUSH
8891: LD_INT 3
8893: PPUSH
8894: LD_INT 45
8896: PUSH
8897: LD_INT 47
8899: PUSH
8900: LD_INT 47
8902: PUSH
8903: LD_INT 45
8905: PUSH
8906: LD_INT 46
8908: PUSH
8909: LD_INT 46
8911: PUSH
8912: LD_INT 49
8914: PUSH
8915: LD_INT 49
8917: PUSH
8918: LD_INT 49
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: PUSH
8932: LD_VAR 0 3
8936: PUSH
8937: LD_INT 9
8939: MOD
8940: PUSH
8941: LD_INT 1
8943: PLUS
8944: ARRAY
8945: PPUSH
8946: LD_INT 80
8948: PPUSH
8949: CALL 72265 0 5
// result := result union CreateVehicle ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_VAR 0 2
8962: PUSH
8963: CALL_OW 45
8967: UNION
8968: ST_TO_ADDR
// end ;
8969: GO 8838
8971: POP
8972: POP
// if not KappaStatus then
8973: LD_EXP 2
8977: NOT
8978: IFFALSE 9213
// begin uc_nation := 1 ;
8980: LD_ADDR_OWVAR 21
8984: PUSH
8985: LD_INT 1
8987: ST_TO_ADDR
// for i = 1 to 3 do
8988: LD_ADDR_VAR 0 3
8992: PUSH
8993: DOUBLE
8994: LD_INT 1
8996: DEC
8997: ST_TO_ADDR
8998: LD_INT 3
9000: PUSH
9001: FOR_TO
9002: IFFALSE 9138
// begin j := rand ( 0 , 1 ) ;
9004: LD_ADDR_VAR 0 4
9008: PUSH
9009: LD_INT 0
9011: PPUSH
9012: LD_INT 1
9014: PPUSH
9015: CALL_OW 12
9019: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9020: LD_INT 3
9022: PUSH
9023: LD_INT 5
9025: PUSH
9026: LD_INT 5
9028: PUSH
9029: LD_INT 4
9031: PUSH
9032: EMPTY
9033: LIST
9034: LIST
9035: LIST
9036: LIST
9037: PUSH
9038: LD_VAR 0 4
9042: PUSH
9043: LD_INT 1
9045: PPUSH
9046: LD_INT 3
9048: PPUSH
9049: CALL_OW 12
9053: PLUS
9054: ARRAY
9055: PPUSH
9056: LD_INT 1
9058: PUSH
9059: LD_INT 3
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: PUSH
9066: LD_INT 1
9068: PPUSH
9069: LD_INT 2
9071: PPUSH
9072: CALL_OW 12
9076: ARRAY
9077: PPUSH
9078: LD_INT 3
9080: PPUSH
9081: LD_INT 9
9083: PUSH
9084: LD_INT 7
9086: PUSH
9087: LD_INT 6
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: LIST
9094: PUSH
9095: LD_VAR 0 4
9099: PUSH
9100: LD_INT 1
9102: PPUSH
9103: LD_INT 2
9105: PPUSH
9106: CALL_OW 12
9110: PLUS
9111: ARRAY
9112: PPUSH
9113: LD_INT 85
9115: PPUSH
9116: CALL 72265 0 5
// result := result union CreateVehicle ;
9120: LD_ADDR_VAR 0 2
9124: PUSH
9125: LD_VAR 0 2
9129: PUSH
9130: CALL_OW 45
9134: UNION
9135: ST_TO_ADDR
// end ;
9136: GO 9001
9138: POP
9139: POP
// if vsevolodFirstAttack then
9140: LD_EXP 24
9144: IFFALSE 9211
// begin vsevolodFirstAttack := false ;
9146: LD_ADDR_EXP 24
9150: PUSH
9151: LD_INT 0
9153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9154: LD_INT 5
9156: PPUSH
9157: LD_INT 3
9159: PPUSH
9160: LD_INT 1
9162: PPUSH
9163: LD_INT 6
9165: PPUSH
9166: LD_INT 100
9168: PPUSH
9169: CALL 72265 0 5
// sewiVeh := CreateVehicle ;
9173: LD_ADDR_EXP 72
9177: PUSH
9178: CALL_OW 45
9182: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9183: LD_EXP 72
9187: PPUSH
9188: LD_INT 1
9190: PPUSH
9191: CALL_OW 242
// result := result union sewiVeh ;
9195: LD_ADDR_VAR 0 2
9199: PUSH
9200: LD_VAR 0 2
9204: PUSH
9205: LD_EXP 72
9209: UNION
9210: ST_TO_ADDR
// end ; end else
9211: GO 9423
// if vsevolodFirstAttack then
9213: LD_EXP 24
9217: IFFALSE 9423
// begin vsevolodFirstAttack := false ;
9219: LD_ADDR_EXP 24
9223: PUSH
9224: LD_INT 0
9226: ST_TO_ADDR
// uc_nation := 3 ;
9227: LD_ADDR_OWVAR 21
9231: PUSH
9232: LD_INT 3
9234: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9235: LD_ADDR_VAR 0 3
9239: PUSH
9240: DOUBLE
9241: LD_INT 1
9243: DEC
9244: ST_TO_ADDR
9245: LD_INT 2
9247: PUSH
9248: LD_OWVAR 67
9252: PLUS
9253: PUSH
9254: FOR_TO
9255: IFFALSE 9363
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9257: LD_INT 22
9259: PUSH
9260: LD_INT 24
9262: PUSH
9263: LD_INT 24
9265: PUSH
9266: EMPTY
9267: LIST
9268: LIST
9269: LIST
9270: PUSH
9271: LD_VAR 0 3
9275: PUSH
9276: LD_INT 3
9278: MOD
9279: PUSH
9280: LD_INT 1
9282: PLUS
9283: ARRAY
9284: PPUSH
9285: LD_INT 1
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 1
9297: PPUSH
9298: LD_INT 2
9300: PPUSH
9301: CALL_OW 12
9305: ARRAY
9306: PPUSH
9307: LD_INT 1
9309: PPUSH
9310: LD_INT 45
9312: PUSH
9313: LD_INT 47
9315: PUSH
9316: LD_INT 47
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: LIST
9323: PUSH
9324: LD_VAR 0 3
9328: PUSH
9329: LD_INT 3
9331: MOD
9332: PUSH
9333: LD_INT 1
9335: PLUS
9336: ARRAY
9337: PPUSH
9338: LD_INT 80
9340: PPUSH
9341: CALL 72265 0 5
// result := result union CreateVehicle ;
9345: LD_ADDR_VAR 0 2
9349: PUSH
9350: LD_VAR 0 2
9354: PUSH
9355: CALL_OW 45
9359: UNION
9360: ST_TO_ADDR
// end ;
9361: GO 9254
9363: POP
9364: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9365: LD_INT 24
9367: PPUSH
9368: LD_INT 3
9370: PPUSH
9371: LD_INT 1
9373: PPUSH
9374: LD_INT 47
9376: PPUSH
9377: LD_INT 100
9379: PPUSH
9380: CALL 72265 0 5
// sewiVeh := CreateVehicle ;
9384: LD_ADDR_EXP 72
9388: PUSH
9389: CALL_OW 45
9393: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9394: LD_EXP 72
9398: PPUSH
9399: LD_INT 6
9401: NEG
9402: PPUSH
9403: CALL_OW 242
// result := result union sewiVeh ;
9407: LD_ADDR_VAR 0 2
9411: PUSH
9412: LD_VAR 0 2
9416: PUSH
9417: LD_EXP 72
9421: UNION
9422: ST_TO_ADDR
// end ; end ; end ;
9423: GO 9426
9425: POP
// end ;
9426: LD_VAR 0 2
9430: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9431: LD_EXP 16
9435: IFFALSE 10106
9437: GO 9439
9439: DISABLE
9440: LD_INT 0
9442: PPUSH
9443: PPUSH
9444: PPUSH
9445: PPUSH
9446: PPUSH
9447: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9448: LD_ADDR_VAR 0 4
9452: PUSH
9453: LD_INT 11
9455: PUSH
9456: LD_INT 12
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9463: LD_ADDR_VAR 0 3
9467: PUSH
9468: LD_INT 11550
9470: PUSH
9471: LD_INT 10150
9473: PUSH
9474: LD_INT 9800
9476: PUSH
9477: LD_INT 9450
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_OWVAR 67
9490: ARRAY
9491: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9492: LD_ADDR_VAR 0 6
9496: PUSH
9497: LD_INT 70
9499: PUSH
9500: LD_INT 118
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PUSH
9507: LD_INT 78
9509: PUSH
9510: LD_INT 31
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// repeat if missionStage = 2 then
9521: LD_EXP 15
9525: PUSH
9526: LD_INT 2
9528: EQUAL
9529: IFFALSE 9540
// wait ( 1 1$30 ) else
9531: LD_INT 3150
9533: PPUSH
9534: CALL_OW 67
9538: GO 9549
// wait ( time ) ;
9540: LD_VAR 0 3
9544: PPUSH
9545: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9549: LD_EXP 15
9553: PUSH
9554: LD_INT 6
9556: EQUAL
9557: PUSH
9558: LD_OWVAR 67
9562: PUSH
9563: LD_INT 2
9565: GREATER
9566: OR
9567: IFFALSE 9595
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9569: LD_INT 51
9571: PPUSH
9572: LD_INT 6
9574: PPUSH
9575: LD_INT 2
9577: PPUSH
9578: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9582: LD_INT 57
9584: PPUSH
9585: LD_INT 6
9587: PPUSH
9588: LD_INT 2
9590: PPUSH
9591: CALL_OW 322
// end ; if missionStage = 8 then
9595: LD_EXP 15
9599: PUSH
9600: LD_INT 8
9602: EQUAL
9603: IFFALSE 9631
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9605: LD_INT 52
9607: PPUSH
9608: LD_INT 6
9610: PPUSH
9611: LD_INT 2
9613: PPUSH
9614: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9618: LD_INT 58
9620: PPUSH
9621: LD_INT 6
9623: PPUSH
9624: LD_INT 2
9626: PPUSH
9627: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9631: LD_EXP 15
9635: PUSH
9636: LD_INT 10
9638: EQUAL
9639: PUSH
9640: LD_OWVAR 67
9644: PUSH
9645: LD_INT 1
9647: GREATER
9648: AND
9649: IFFALSE 9677
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9651: LD_INT 53
9653: PPUSH
9654: LD_INT 6
9656: PPUSH
9657: LD_INT 2
9659: PPUSH
9660: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9664: LD_INT 59
9666: PPUSH
9667: LD_INT 6
9669: PPUSH
9670: LD_INT 2
9672: PPUSH
9673: CALL_OW 322
// end ; if activeAttacks then
9677: LD_EXP 16
9681: IFFALSE 10100
// begin if missionStage = 2 then
9683: LD_EXP 15
9687: PUSH
9688: LD_INT 2
9690: EQUAL
9691: IFFALSE 9701
// strength := 1 ;
9693: LD_ADDR_VAR 0 5
9697: PUSH
9698: LD_INT 1
9700: ST_TO_ADDR
// if missionStage > 2 then
9701: LD_EXP 15
9705: PUSH
9706: LD_INT 2
9708: GREATER
9709: IFFALSE 9719
// strength := 2 ;
9711: LD_ADDR_VAR 0 5
9715: PUSH
9716: LD_INT 2
9718: ST_TO_ADDR
// if missionStage > 6 then
9719: LD_EXP 15
9723: PUSH
9724: LD_INT 6
9726: GREATER
9727: IFFALSE 9737
// strength := 3 ;
9729: LD_ADDR_VAR 0 5
9733: PUSH
9734: LD_INT 3
9736: ST_TO_ADDR
// if missionStage > 10 then
9737: LD_EXP 15
9741: PUSH
9742: LD_INT 10
9744: GREATER
9745: IFFALSE 9755
// strength := 4 ;
9747: LD_ADDR_VAR 0 5
9751: PUSH
9752: LD_INT 4
9754: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: LD_VAR 0 5
9764: PPUSH
9765: CALL 8248 0 1
9769: ST_TO_ADDR
// for i in tmp do
9770: LD_ADDR_VAR 0 1
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: FOR_IN
9781: IFFALSE 9990
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9783: LD_VAR 0 1
9787: PPUSH
9788: LD_VAR 0 4
9792: PUSH
9793: LD_INT 1
9795: PPUSH
9796: LD_INT 2
9798: PPUSH
9799: CALL_OW 12
9803: ARRAY
9804: PPUSH
9805: LD_INT 0
9807: PPUSH
9808: CALL_OW 49
// if i = sewiVeh then
9812: LD_VAR 0 1
9816: PUSH
9817: LD_EXP 72
9821: EQUAL
9822: IFFALSE 9859
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9824: LD_ADDR_EXP 71
9828: PUSH
9829: LD_STRING Vsevolod
9831: PPUSH
9832: LD_INT 0
9834: PPUSH
9835: LD_STRING 
9837: PPUSH
9838: CALL 67250 0 3
9842: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9843: LD_EXP 71
9847: PPUSH
9848: LD_VAR 0 1
9852: PPUSH
9853: CALL_OW 52
// end else
9857: GO 9940
// if GetControl ( i ) = control_manual then
9859: LD_VAR 0 1
9863: PPUSH
9864: CALL_OW 263
9868: PUSH
9869: LD_INT 1
9871: EQUAL
9872: IFFALSE 9940
// begin uc_side := 6 ;
9874: LD_ADDR_OWVAR 20
9878: PUSH
9879: LD_INT 6
9881: ST_TO_ADDR
// uc_nation := 3 ;
9882: LD_ADDR_OWVAR 21
9886: PUSH
9887: LD_INT 3
9889: ST_TO_ADDR
// hc_gallery :=  ;
9890: LD_ADDR_OWVAR 33
9894: PUSH
9895: LD_STRING 
9897: ST_TO_ADDR
// hc_name :=  ;
9898: LD_ADDR_OWVAR 26
9902: PUSH
9903: LD_STRING 
9905: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9906: LD_INT 0
9908: PPUSH
9909: LD_INT 3
9911: PPUSH
9912: LD_INT 10
9914: PPUSH
9915: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9919: CALL_OW 44
9923: PPUSH
9924: LD_VAR 0 1
9928: PPUSH
9929: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9933: LD_INT 10
9935: PPUSH
9936: CALL_OW 67
// end ; if Prob ( 50 ) then
9940: LD_INT 50
9942: PPUSH
9943: CALL_OW 13
9947: IFFALSE 9966
// ComMoveXY ( i , 111 , 197 ) else
9949: LD_VAR 0 1
9953: PPUSH
9954: LD_INT 111
9956: PPUSH
9957: LD_INT 197
9959: PPUSH
9960: CALL_OW 111
9964: GO 9981
// ComMoveXY ( i , 91 , 165 ) ;
9966: LD_VAR 0 1
9970: PPUSH
9971: LD_INT 91
9973: PPUSH
9974: LD_INT 165
9976: PPUSH
9977: CALL_OW 111
// wait ( 0 0$2 ) ;
9981: LD_INT 70
9983: PPUSH
9984: CALL_OW 67
// end ;
9988: GO 9780
9990: POP
9991: POP
// repeat wait ( 0 0$1 ) ;
9992: LD_INT 35
9994: PPUSH
9995: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
9999: LD_ADDR_VAR 0 1
10003: PUSH
10004: LD_VAR 0 2
10008: PPUSH
10009: LD_INT 50
10011: PUSH
10012: EMPTY
10013: LIST
10014: PPUSH
10015: CALL_OW 72
10019: PUSH
10020: FOR_IN
10021: IFFALSE 10080
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10023: LD_VAR 0 1
10027: PPUSH
10028: LD_INT 108
10030: PUSH
10031: LD_INT 153
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: PUSH
10038: LD_INT 105
10040: PUSH
10041: LD_INT 149
10043: PUSH
10044: EMPTY
10045: LIST
10046: LIST
10047: PUSH
10048: LD_INT 85
10050: PUSH
10051: LD_INT 131
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: PUSH
10058: LD_INT 64
10060: PUSH
10061: LD_INT 105
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: PPUSH
10074: CALL 107303 0 2
10078: GO 10020
10080: POP
10081: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10082: LD_VAR 0 2
10086: PPUSH
10087: LD_INT 50
10089: PUSH
10090: EMPTY
10091: LIST
10092: PPUSH
10093: CALL_OW 72
10097: NOT
10098: IFFALSE 9992
// end ; until russianDestroyed ;
10100: LD_EXP 21
10104: IFFALSE 9521
// end ;
10106: PPOPN 6
10108: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10109: LD_EXP 21
10113: NOT
10114: PUSH
10115: LD_EXP 15
10119: PUSH
10120: LD_INT 6
10122: GREATEREQUAL
10123: AND
10124: PUSH
10125: LD_INT 2
10127: PPUSH
10128: LD_INT 1
10130: PPUSH
10131: CALL 62280 0 2
10135: NOT
10136: AND
10137: IFFALSE 11076
10139: GO 10141
10141: DISABLE
10142: LD_INT 0
10144: PPUSH
10145: PPUSH
10146: PPUSH
10147: PPUSH
// begin enable ;
10148: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10149: LD_INT 22
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: EMPTY
10156: LIST
10157: LIST
10158: PUSH
10159: LD_INT 30
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PPUSH
10173: CALL_OW 69
10177: NOT
10178: IFFALSE 10182
// exit ;
10180: GO 11076
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10182: LD_ADDR_VAR 0 4
10186: PUSH
10187: LD_INT 22
10189: PUSH
10190: LD_INT 3
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 30
10199: PUSH
10200: LD_INT 34
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PPUSH
10211: CALL_OW 69
10215: ST_TO_ADDR
// if Prob ( 40 ) then
10216: LD_INT 40
10218: PPUSH
10219: CALL_OW 13
10223: IFFALSE 10369
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10225: LD_INT 2
10227: PPUSH
10228: LD_INT 22
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: LD_INT 49
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: LD_INT 22
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: LD_INT 49
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 22
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 3
10272: PUSH
10273: LD_INT 49
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: PUSH
10282: LD_INT 24
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 3
10290: PUSH
10291: LD_INT 46
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 24
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: LD_INT 46
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: PUSH
10318: LD_INT 24
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 3
10326: PUSH
10327: LD_INT 46
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: PUSH
10336: LD_INT 24
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 3
10344: PUSH
10345: LD_INT 46
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PPUSH
10363: CALL 60862 0 2
// end else
10367: GO 10511
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10369: LD_INT 2
10371: PPUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 47
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: LD_INT 24
10464: PUSH
10465: LD_INT 3
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 46
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: PUSH
10480: LD_INT 24
10482: PUSH
10483: LD_INT 3
10485: PUSH
10486: LD_INT 3
10488: PUSH
10489: LD_INT 46
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: LIST
10506: PPUSH
10507: CALL 60862 0 2
// end ; repeat wait ( 0 0$1 ) ;
10511: LD_INT 35
10513: PPUSH
10514: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10518: LD_INT 2
10520: PPUSH
10521: LD_INT 1
10523: PPUSH
10524: CALL 62280 0 2
10528: PUSH
10529: LD_INT 7
10531: GREATEREQUAL
10532: IFFALSE 10511
// wait ( 0 0$10 ) ;
10534: LD_INT 350
10536: PPUSH
10537: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10541: LD_ADDR_VAR 0 2
10545: PUSH
10546: LD_INT 2
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL 62280 0 2
10556: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10557: LD_ADDR_EXP 118
10561: PUSH
10562: LD_EXP 118
10566: PPUSH
10567: LD_INT 2
10569: PPUSH
10570: LD_EXP 118
10574: PUSH
10575: LD_INT 2
10577: ARRAY
10578: PUSH
10579: LD_VAR 0 2
10583: DIFF
10584: PPUSH
10585: CALL_OW 1
10589: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10590: LD_ADDR_VAR 0 3
10594: PUSH
10595: LD_INT 0
10597: PPUSH
10598: LD_INT 1
10600: PPUSH
10601: CALL_OW 12
10605: ST_TO_ADDR
// if target then
10606: LD_VAR 0 3
10610: IFFALSE 10738
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10612: LD_ADDR_VAR 0 2
10616: PUSH
10617: LD_VAR 0 2
10621: PPUSH
10622: LD_INT 24
10624: PUSH
10625: LD_INT 250
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 72
10636: ST_TO_ADDR
// for i in tmp do
10637: LD_ADDR_VAR 0 1
10641: PUSH
10642: LD_VAR 0 2
10646: PUSH
10647: FOR_IN
10648: IFFALSE 10688
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10650: LD_VAR 0 1
10654: PPUSH
10655: LD_INT 139
10657: PPUSH
10658: LD_INT 89
10660: PPUSH
10661: CALL_OW 297
10665: PUSH
10666: LD_INT 9
10668: GREATER
10669: IFFALSE 10686
// ComMoveXY ( i , 139 , 89 ) ;
10671: LD_VAR 0 1
10675: PPUSH
10676: LD_INT 139
10678: PPUSH
10679: LD_INT 89
10681: PPUSH
10682: CALL_OW 111
10686: GO 10647
10688: POP
10689: POP
// wait ( 0 0$1 ) ;
10690: LD_INT 35
10692: PPUSH
10693: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10697: LD_VAR 0 2
10701: PPUSH
10702: LD_INT 92
10704: PUSH
10705: LD_INT 139
10707: PUSH
10708: LD_INT 89
10710: PUSH
10711: LD_INT 9
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 72
10724: PUSH
10725: LD_VAR 0 2
10729: PUSH
10730: LD_INT 1
10732: MINUS
10733: GREATEREQUAL
10734: IFFALSE 10612
// end else
10736: GO 10880
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10738: LD_VAR 0 2
10742: PPUSH
10743: LD_VAR 0 4
10747: PUSH
10748: LD_INT 1
10750: ARRAY
10751: PPUSH
10752: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10756: LD_ADDR_VAR 0 2
10760: PUSH
10761: LD_VAR 0 2
10765: PPUSH
10766: LD_INT 24
10768: PUSH
10769: LD_INT 250
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PPUSH
10776: CALL_OW 72
10780: ST_TO_ADDR
// for i in tmp do
10781: LD_ADDR_VAR 0 1
10785: PUSH
10786: LD_VAR 0 2
10790: PUSH
10791: FOR_IN
10792: IFFALSE 10832
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10794: LD_VAR 0 1
10798: PPUSH
10799: LD_INT 124
10801: PPUSH
10802: LD_INT 139
10804: PPUSH
10805: CALL_OW 297
10809: PUSH
10810: LD_INT 9
10812: GREATER
10813: IFFALSE 10830
// ComMoveXY ( i , 124 , 139 ) ;
10815: LD_VAR 0 1
10819: PPUSH
10820: LD_INT 124
10822: PPUSH
10823: LD_INT 139
10825: PPUSH
10826: CALL_OW 111
10830: GO 10791
10832: POP
10833: POP
// wait ( 0 0$1 ) ;
10834: LD_INT 35
10836: PPUSH
10837: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10841: LD_VAR 0 2
10845: PPUSH
10846: LD_INT 92
10848: PUSH
10849: LD_INT 124
10851: PUSH
10852: LD_INT 139
10854: PUSH
10855: LD_INT 9
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: PPUSH
10864: CALL_OW 72
10868: PUSH
10869: LD_VAR 0 2
10873: PUSH
10874: LD_INT 1
10876: MINUS
10877: GREATEREQUAL
10878: IFFALSE 10756
// end ; repeat wait ( 0 0$1 ) ;
10880: LD_INT 35
10882: PPUSH
10883: CALL_OW 67
// for i in tmp do
10887: LD_ADDR_VAR 0 1
10891: PUSH
10892: LD_VAR 0 2
10896: PUSH
10897: FOR_IN
10898: IFFALSE 11067
// begin if GetLives ( i ) > 251 then
10900: LD_VAR 0 1
10904: PPUSH
10905: CALL_OW 256
10909: PUSH
10910: LD_INT 251
10912: GREATER
10913: IFFALSE 11038
// begin if GetWeapon ( i ) = ru_time_lapser then
10915: LD_VAR 0 1
10919: PPUSH
10920: CALL_OW 264
10924: PUSH
10925: LD_INT 49
10927: EQUAL
10928: IFFALSE 10984
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10930: LD_VAR 0 1
10934: PPUSH
10935: LD_INT 2
10937: PUSH
10938: LD_INT 22
10940: PUSH
10941: LD_INT 1
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: PUSH
10948: LD_INT 22
10950: PUSH
10951: LD_INT 8
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: LIST
10962: PPUSH
10963: CALL_OW 69
10967: PPUSH
10968: LD_VAR 0 1
10972: PPUSH
10973: CALL_OW 74
10977: PPUSH
10978: CALL_OW 112
10982: GO 11036
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10984: LD_VAR 0 1
10988: PPUSH
10989: LD_INT 2
10991: PUSH
10992: LD_INT 22
10994: PUSH
10995: LD_INT 1
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: PUSH
11002: LD_INT 22
11004: PUSH
11005: LD_INT 8
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: PUSH
11012: EMPTY
11013: LIST
11014: LIST
11015: LIST
11016: PPUSH
11017: CALL_OW 69
11021: PPUSH
11022: LD_VAR 0 1
11026: PPUSH
11027: CALL_OW 74
11031: PPUSH
11032: CALL_OW 115
// end else
11036: GO 11065
// if IsDead ( i ) then
11038: LD_VAR 0 1
11042: PPUSH
11043: CALL_OW 301
11047: IFFALSE 11065
// tmp := tmp diff i ;
11049: LD_ADDR_VAR 0 2
11053: PUSH
11054: LD_VAR 0 2
11058: PUSH
11059: LD_VAR 0 1
11063: DIFF
11064: ST_TO_ADDR
// end ;
11065: GO 10897
11067: POP
11068: POP
// until not tmp ;
11069: LD_VAR 0 2
11073: NOT
11074: IFFALSE 10880
// end ;
11076: PPOPN 4
11078: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 8 and Difficulty > 1 do var i , veh , un ;
11079: LD_EXP 15
11083: PUSH
11084: LD_INT 8
11086: GREATEREQUAL
11087: PUSH
11088: LD_OWVAR 67
11092: PUSH
11093: LD_INT 1
11095: GREATER
11096: AND
11097: IFFALSE 11281
11099: GO 11101
11101: DISABLE
11102: LD_INT 0
11104: PPUSH
11105: PPUSH
11106: PPUSH
// begin ruMobile := [ ] ;
11107: LD_ADDR_EXP 75
11111: PUSH
11112: EMPTY
11113: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11114: LD_ADDR_VAR 0 1
11118: PUSH
11119: DOUBLE
11120: LD_INT 1
11122: DEC
11123: ST_TO_ADDR
11124: LD_INT 3
11126: PUSH
11127: LD_INT 4
11129: PUSH
11130: LD_INT 5
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: LIST
11137: PUSH
11138: LD_OWVAR 67
11142: PUSH
11143: LD_INT 1
11145: MINUS
11146: ARRAY
11147: PUSH
11148: FOR_TO
11149: IFFALSE 11279
// begin uc_side := 3 ;
11151: LD_ADDR_OWVAR 20
11155: PUSH
11156: LD_INT 3
11158: ST_TO_ADDR
// uc_nation := 3 ;
11159: LD_ADDR_OWVAR 21
11163: PUSH
11164: LD_INT 3
11166: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11167: LD_INT 21
11169: PPUSH
11170: LD_INT 3
11172: PPUSH
11173: LD_INT 1
11175: PPUSH
11176: LD_INT 45
11178: PPUSH
11179: LD_INT 100
11181: PPUSH
11182: CALL 72265 0 5
// veh := CreateVehicle ;
11186: LD_ADDR_VAR 0 2
11190: PUSH
11191: CALL_OW 45
11195: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11196: LD_VAR 0 2
11200: PPUSH
11201: LD_INT 3
11203: PPUSH
11204: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 29
11215: PPUSH
11216: LD_INT 0
11218: PPUSH
11219: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11223: LD_INT 0
11225: PPUSH
11226: LD_INT 10
11228: PPUSH
11229: CALL_OW 383
// un := CreateHuman ;
11233: LD_ADDR_VAR 0 3
11237: PUSH
11238: CALL_OW 44
11242: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11243: LD_VAR 0 3
11247: PPUSH
11248: LD_VAR 0 2
11252: PPUSH
11253: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11257: LD_ADDR_EXP 75
11261: PUSH
11262: LD_EXP 75
11266: PPUSH
11267: LD_VAR 0 2
11271: PPUSH
11272: CALL 104699 0 2
11276: ST_TO_ADDR
// end ;
11277: GO 11148
11279: POP
11280: POP
// end ;
11281: PPOPN 3
11283: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11284: LD_EXP 75
11288: IFFALSE 11796
11290: GO 11292
11292: DISABLE
11293: LD_INT 0
11295: PPUSH
11296: PPUSH
11297: PPUSH
// begin enable ;
11298: ENABLE
// if not ruMobile then
11299: LD_EXP 75
11303: NOT
11304: IFFALSE 11308
// exit ;
11306: GO 11796
// for i in ruMobile do
11308: LD_ADDR_VAR 0 1
11312: PUSH
11313: LD_EXP 75
11317: PUSH
11318: FOR_IN
11319: IFFALSE 11794
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11321: LD_VAR 0 1
11325: PPUSH
11326: CALL_OW 302
11330: NOT
11331: PUSH
11332: LD_VAR 0 1
11336: PPUSH
11337: CALL_OW 255
11341: PUSH
11342: LD_INT 3
11344: NONEQUAL
11345: OR
11346: IFFALSE 11366
// begin ruMobile := ruMobile diff i ;
11348: LD_ADDR_EXP 75
11352: PUSH
11353: LD_EXP 75
11357: PUSH
11358: LD_VAR 0 1
11362: DIFF
11363: ST_TO_ADDR
// continue ;
11364: GO 11318
// end ; if GetTag ( i ) = 300 then
11366: LD_VAR 0 1
11370: PPUSH
11371: CALL_OW 110
11375: PUSH
11376: LD_INT 300
11378: EQUAL
11379: IFFALSE 11429
// begin ComMoveXY ( i , 160 , 81 ) ;
11381: LD_VAR 0 1
11385: PPUSH
11386: LD_INT 160
11388: PPUSH
11389: LD_INT 81
11391: PPUSH
11392: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11396: LD_VAR 0 1
11400: PPUSH
11401: LD_INT 160
11403: PPUSH
11404: LD_INT 81
11406: PPUSH
11407: CALL_OW 297
11411: PUSH
11412: LD_INT 8
11414: LESS
11415: IFFALSE 11429
// SetTag ( i , 301 ) ;
11417: LD_VAR 0 1
11421: PPUSH
11422: LD_INT 301
11424: PPUSH
11425: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11429: LD_VAR 0 1
11433: PPUSH
11434: CALL_OW 110
11438: PUSH
11439: LD_INT 301
11441: EQUAL
11442: IFFALSE 11485
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11444: LD_VAR 0 1
11448: PPUSH
11449: LD_INT 33
11451: PPUSH
11452: CALL_OW 308
11456: NOT
11457: IFFALSE 11473
// ComMoveToArea ( i , ruMobileParkingArea ) else
11459: LD_VAR 0 1
11463: PPUSH
11464: LD_INT 33
11466: PPUSH
11467: CALL_OW 113
11471: GO 11485
// SetTag ( i , 302 ) ;
11473: LD_VAR 0 1
11477: PPUSH
11478: LD_INT 302
11480: PPUSH
11481: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11485: LD_VAR 0 1
11489: PPUSH
11490: CALL_OW 110
11494: PUSH
11495: LD_INT 302
11497: EQUAL
11498: IFFALSE 11628
// begin if GetLives ( i ) < 1000 then
11500: LD_VAR 0 1
11504: PPUSH
11505: CALL_OW 256
11509: PUSH
11510: LD_INT 1000
11512: LESS
11513: IFFALSE 11605
// begin if not IsDrivenBy ( i ) then
11515: LD_VAR 0 1
11519: PPUSH
11520: CALL_OW 311
11524: NOT
11525: IFFALSE 11529
// continue ;
11527: GO 11318
// mech := IsDrivenBy ( i ) ;
11529: LD_ADDR_VAR 0 2
11533: PUSH
11534: LD_VAR 0 1
11538: PPUSH
11539: CALL_OW 311
11543: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11544: LD_VAR 0 2
11548: PPUSH
11549: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11553: LD_VAR 0 2
11557: PPUSH
11558: LD_VAR 0 1
11562: PPUSH
11563: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11567: LD_INT 35
11569: PPUSH
11570: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11574: LD_VAR 0 1
11578: PPUSH
11579: CALL_OW 256
11583: PUSH
11584: LD_INT 1000
11586: EQUAL
11587: IFFALSE 11567
// ComEnterUnit ( mech , i ) ;
11589: LD_VAR 0 2
11593: PPUSH
11594: LD_VAR 0 1
11598: PPUSH
11599: CALL_OW 120
// end else
11603: GO 11628
// if IsDrivenBy ( i ) then
11605: LD_VAR 0 1
11609: PPUSH
11610: CALL_OW 311
11614: IFFALSE 11628
// SetTag ( i , 0 ) ;
11616: LD_VAR 0 1
11620: PPUSH
11621: LD_INT 0
11623: PPUSH
11624: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11628: LD_VAR 0 1
11632: PPUSH
11633: CALL_OW 110
11637: PUSH
11638: LD_INT 300
11640: LESS
11641: IFFALSE 11792
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11643: LD_ADDR_VAR 0 3
11647: PUSH
11648: LD_INT 4
11650: PPUSH
11651: LD_INT 81
11653: PUSH
11654: LD_INT 3
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PPUSH
11661: CALL_OW 70
11665: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11666: LD_VAR 0 1
11670: PPUSH
11671: CALL_OW 256
11675: PUSH
11676: LD_INT 650
11678: LESS
11679: IFFALSE 11704
// begin ComStop ( i ) ;
11681: LD_VAR 0 1
11685: PPUSH
11686: CALL_OW 141
// SetTag ( i , 300 ) ;
11690: LD_VAR 0 1
11694: PPUSH
11695: LD_INT 300
11697: PPUSH
11698: CALL_OW 109
// continue ;
11702: GO 11318
// end ; if enemy then
11704: LD_VAR 0 3
11708: IFFALSE 11748
// begin if not HasTask ( i ) then
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL_OW 314
11719: NOT
11720: IFFALSE 11746
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11722: LD_VAR 0 1
11726: PPUSH
11727: LD_VAR 0 3
11731: PPUSH
11732: LD_VAR 0 1
11736: PPUSH
11737: CALL_OW 74
11741: PPUSH
11742: CALL_OW 115
// end else
11746: GO 11792
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
11748: LD_VAR 0 1
11752: PPUSH
11753: LD_INT 158
11755: PUSH
11756: LD_INT 61
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: PUSH
11763: LD_INT 98
11765: PUSH
11766: LD_INT 100
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: LD_INT 78
11775: PUSH
11776: LD_INT 93
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: EMPTY
11784: LIST
11785: LIST
11786: LIST
11787: PPUSH
11788: CALL 107303 0 2
// end ; end ;
11792: GO 11318
11794: POP
11795: POP
// end ; end_of_file
11796: PPOPN 3
11798: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11799: LD_INT 0
11801: PPUSH
11802: PPUSH
11803: PPUSH
11804: PPUSH
11805: PPUSH
11806: PPUSH
// side := 7 ;
11807: LD_ADDR_VAR 0 5
11811: PUSH
11812: LD_INT 7
11814: ST_TO_ADDR
// uc_side := side ;
11815: LD_ADDR_OWVAR 20
11819: PUSH
11820: LD_VAR 0 5
11824: ST_TO_ADDR
// uc_nation := 1 ;
11825: LD_ADDR_OWVAR 21
11829: PUSH
11830: LD_INT 1
11832: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11833: LD_ADDR_VAR 0 2
11837: PUSH
11838: LD_INT 22
11840: PUSH
11841: LD_VAR 0 5
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 3
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PPUSH
11864: CALL_OW 69
11868: PUSH
11869: FOR_IN
11870: IFFALSE 11886
// SetBLevel ( i , 10 ) ;
11872: LD_VAR 0 2
11876: PPUSH
11877: LD_INT 10
11879: PPUSH
11880: CALL_OW 241
11884: GO 11869
11886: POP
11887: POP
// base := GetBase ( al_depot ) ;
11888: LD_ADDR_VAR 0 4
11892: PUSH
11893: LD_INT 2
11895: PPUSH
11896: CALL_OW 274
11900: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11901: LD_ADDR_VAR 0 6
11905: PUSH
11906: LD_INT 22
11908: PUSH
11909: LD_VAR 0 5
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_INT 30
11920: PUSH
11921: LD_INT 34
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PPUSH
11932: CALL_OW 69
11936: ST_TO_ADDR
// if teleport then
11937: LD_VAR 0 6
11941: IFFALSE 11962
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11943: LD_VAR 0 6
11947: PUSH
11948: LD_INT 1
11950: ARRAY
11951: PPUSH
11952: LD_INT 262
11954: PPUSH
11955: LD_INT 119
11957: PPUSH
11958: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11962: LD_VAR 0 4
11966: PPUSH
11967: LD_INT 1
11969: PPUSH
11970: LD_INT 19500
11972: PPUSH
11973: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11977: LD_VAR 0 4
11981: PPUSH
11982: LD_INT 2
11984: PPUSH
11985: LD_INT 200
11987: PPUSH
11988: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11992: LD_VAR 0 4
11996: PPUSH
11997: LD_INT 3
11999: PPUSH
12000: LD_INT 650
12002: PPUSH
12003: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12007: LD_ADDR_EXP 76
12011: PUSH
12012: LD_STRING Roth
12014: PPUSH
12015: CALL_OW 25
12019: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12020: LD_ADDR_EXP 77
12024: PUSH
12025: LD_STRING Simms
12027: PPUSH
12028: LD_EXP 1
12032: NOT
12033: PPUSH
12034: LD_STRING 10c_
12036: PPUSH
12037: CALL 67250 0 3
12041: ST_TO_ADDR
// if not Simms then
12042: LD_EXP 77
12046: NOT
12047: IFFALSE 12077
// begin uc_nation := 1 ;
12049: LD_ADDR_OWVAR 21
12053: PUSH
12054: LD_INT 1
12056: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12057: LD_INT 2
12059: PPUSH
12060: LD_INT 10
12062: PPUSH
12063: CALL_OW 384
// Simms := CreateHuman ;
12067: LD_ADDR_EXP 77
12071: PUSH
12072: CALL_OW 44
12076: ST_TO_ADDR
// end ; uc_nation := 3 ;
12077: LD_ADDR_OWVAR 21
12081: PUSH
12082: LD_INT 3
12084: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12085: LD_ADDR_EXP 78
12089: PUSH
12090: LD_STRING Kirilenkova
12092: PPUSH
12093: CALL_OW 25
12097: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12098: LD_ADDR_EXP 92
12102: PUSH
12103: LD_STRING Oblukov
12105: PPUSH
12106: CALL_OW 25
12110: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12111: LD_ADDR_EXP 79
12115: PUSH
12116: LD_STRING Dolgov
12118: PPUSH
12119: CALL_OW 25
12123: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12124: LD_ADDR_EXP 80
12128: PUSH
12129: LD_STRING Petrosyan
12131: PPUSH
12132: CALL_OW 25
12136: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12137: LD_ADDR_EXP 91
12141: PUSH
12142: LD_STRING Scholtze
12144: PPUSH
12145: CALL_OW 25
12149: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12150: LD_ADDR_EXP 90
12154: PUSH
12155: LD_STRING Kapitsova
12157: PPUSH
12158: CALL_OW 25
12162: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12163: LD_ADDR_EXP 81
12167: PUSH
12168: LD_STRING Petrovova
12170: PPUSH
12171: CALL_OW 25
12175: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12176: LD_ADDR_EXP 82
12180: PUSH
12181: LD_STRING Kuzmov
12183: PPUSH
12184: CALL_OW 25
12188: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12189: LD_ADDR_EXP 89
12193: PUSH
12194: LD_STRING Karamazov
12196: PPUSH
12197: CALL_OW 25
12201: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12202: LD_STRING 13_Lipshchin_1
12204: PPUSH
12205: LD_INT 0
12207: PPUSH
12208: CALL_OW 30
12212: IFFALSE 12227
// Lipshchin := NewCharacter ( Lipshchin ) ;
12214: LD_ADDR_EXP 83
12218: PUSH
12219: LD_STRING Lipshchin
12221: PPUSH
12222: CALL_OW 25
12226: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12227: LD_STRING 13_Titov_1
12229: PPUSH
12230: LD_INT 0
12232: PPUSH
12233: CALL_OW 30
12237: IFFALSE 12252
// Titov := NewCharacter ( Titov ) ;
12239: LD_ADDR_EXP 85
12243: PUSH
12244: LD_STRING Titov
12246: PPUSH
12247: CALL_OW 25
12251: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12252: LD_STRING 13_Gnyevko_1
12254: PPUSH
12255: LD_INT 0
12257: PPUSH
12258: CALL_OW 30
12262: IFFALSE 12277
// Gnyevko := NewCharacter ( Gnyevko ) ;
12264: LD_ADDR_EXP 84
12268: PUSH
12269: LD_STRING Gnyevko
12271: PPUSH
12272: CALL_OW 25
12276: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12277: LD_STRING 13_Xavier_1
12279: PPUSH
12280: LD_INT 0
12282: PPUSH
12283: CALL_OW 30
12287: IFFALSE 12302
// Xavier := NewCharacter ( Xavier2 ) ;
12289: LD_ADDR_EXP 86
12293: PUSH
12294: LD_STRING Xavier2
12296: PPUSH
12297: CALL_OW 25
12301: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12302: LD_STRING 13_Belkov_1
12304: PPUSH
12305: LD_INT 0
12307: PPUSH
12308: CALL_OW 30
12312: IFFALSE 12327
// Belkov := NewCharacter ( Belkov ) ;
12314: LD_ADDR_EXP 87
12318: PUSH
12319: LD_STRING Belkov
12321: PPUSH
12322: CALL_OW 25
12326: ST_TO_ADDR
// if not BurlakStatus then
12327: LD_EXP 9
12331: NOT
12332: IFFALSE 12347
// Burlak = NewCharacter ( Burlak ) ;
12334: LD_ADDR_EXP 88
12338: PUSH
12339: LD_STRING Burlak
12341: PPUSH
12342: CALL_OW 25
12346: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12347: LD_ADDR_VAR 0 3
12351: PUSH
12352: LD_EXP 76
12356: PUSH
12357: LD_EXP 78
12361: PUSH
12362: LD_EXP 92
12366: PUSH
12367: LD_EXP 79
12371: PUSH
12372: LD_EXP 80
12376: PUSH
12377: LD_EXP 91
12381: PUSH
12382: LD_EXP 90
12386: PUSH
12387: LD_EXP 81
12391: PUSH
12392: LD_EXP 82
12396: PUSH
12397: LD_EXP 89
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: LIST
12409: LIST
12410: LIST
12411: LIST
12412: LIST
12413: ST_TO_ADDR
// if Simms then
12414: LD_EXP 77
12418: IFFALSE 12436
// tmp := tmp ^ Simms ;
12420: LD_ADDR_VAR 0 3
12424: PUSH
12425: LD_VAR 0 3
12429: PUSH
12430: LD_EXP 77
12434: ADD
12435: ST_TO_ADDR
// if Titov then
12436: LD_EXP 85
12440: IFFALSE 12458
// tmp := tmp ^ Titov ;
12442: LD_ADDR_VAR 0 3
12446: PUSH
12447: LD_VAR 0 3
12451: PUSH
12452: LD_EXP 85
12456: ADD
12457: ST_TO_ADDR
// if Lipshchin then
12458: LD_EXP 83
12462: IFFALSE 12480
// tmp := tmp ^ Lipshchin ;
12464: LD_ADDR_VAR 0 3
12468: PUSH
12469: LD_VAR 0 3
12473: PUSH
12474: LD_EXP 83
12478: ADD
12479: ST_TO_ADDR
// if Gnyevko then
12480: LD_EXP 84
12484: IFFALSE 12502
// tmp := tmp ^ Gnyevko ;
12486: LD_ADDR_VAR 0 3
12490: PUSH
12491: LD_VAR 0 3
12495: PUSH
12496: LD_EXP 84
12500: ADD
12501: ST_TO_ADDR
// if Xavier then
12502: LD_EXP 86
12506: IFFALSE 12524
// tmp := tmp ^ Xavier ;
12508: LD_ADDR_VAR 0 3
12512: PUSH
12513: LD_VAR 0 3
12517: PUSH
12518: LD_EXP 86
12522: ADD
12523: ST_TO_ADDR
// if Belkov then
12524: LD_EXP 87
12528: IFFALSE 12546
// tmp := tmp ^ Belkov ;
12530: LD_ADDR_VAR 0 3
12534: PUSH
12535: LD_VAR 0 3
12539: PUSH
12540: LD_EXP 87
12544: ADD
12545: ST_TO_ADDR
// if Burlak then
12546: LD_EXP 88
12550: IFFALSE 12568
// tmp := tmp ^ Burlak ;
12552: LD_ADDR_VAR 0 3
12556: PUSH
12557: LD_VAR 0 3
12561: PUSH
12562: LD_EXP 88
12566: ADD
12567: ST_TO_ADDR
// for i = 1 to 11 do
12568: LD_ADDR_VAR 0 2
12572: PUSH
12573: DOUBLE
12574: LD_INT 1
12576: DEC
12577: ST_TO_ADDR
12578: LD_INT 11
12580: PUSH
12581: FOR_TO
12582: IFFALSE 12648
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12584: LD_ADDR_OWVAR 21
12588: PUSH
12589: LD_INT 1
12591: PUSH
12592: LD_INT 3
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PUSH
12599: LD_INT 1
12601: PPUSH
12602: LD_INT 2
12604: PPUSH
12605: CALL_OW 12
12609: ARRAY
12610: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
12611: LD_INT 0
12613: PPUSH
12614: LD_VAR 0 2
12618: PUSH
12619: LD_INT 2
12621: DIV
12622: PPUSH
12623: LD_INT 10
12625: PPUSH
12626: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12630: LD_ADDR_VAR 0 3
12634: PUSH
12635: LD_VAR 0 3
12639: PUSH
12640: CALL_OW 44
12644: ADD
12645: ST_TO_ADDR
// end ;
12646: GO 12581
12648: POP
12649: POP
// for i in tmp do
12650: LD_ADDR_VAR 0 2
12654: PUSH
12655: LD_VAR 0 3
12659: PUSH
12660: FOR_IN
12661: IFFALSE 12686
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12663: LD_VAR 0 2
12667: PPUSH
12668: LD_INT 260
12670: PPUSH
12671: LD_INT 235
12673: PPUSH
12674: LD_INT 8
12676: PPUSH
12677: LD_INT 0
12679: PPUSH
12680: CALL_OW 50
12684: GO 12660
12686: POP
12687: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12688: LD_ADDR_EXP 99
12692: PUSH
12693: LD_EXP 99
12697: PPUSH
12698: LD_INT 1
12700: PPUSH
12701: LD_INT 22
12703: PUSH
12704: LD_VAR 0 5
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PUSH
12713: LD_INT 3
12715: PUSH
12716: LD_INT 21
12718: PUSH
12719: LD_INT 2
12721: PUSH
12722: EMPTY
12723: LIST
12724: LIST
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PPUSH
12734: CALL_OW 69
12738: PUSH
12739: LD_EXP 76
12743: PUSH
12744: LD_EXP 77
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: DIFF
12753: PPUSH
12754: CALL_OW 1
12758: ST_TO_ADDR
// uc_side := 0 ;
12759: LD_ADDR_OWVAR 20
12763: PUSH
12764: LD_INT 0
12766: ST_TO_ADDR
// uc_nation := 0 ;
12767: LD_ADDR_OWVAR 21
12771: PUSH
12772: LD_INT 0
12774: ST_TO_ADDR
// for i = 1 to 5 do
12775: LD_ADDR_VAR 0 2
12779: PUSH
12780: DOUBLE
12781: LD_INT 1
12783: DEC
12784: ST_TO_ADDR
12785: LD_INT 5
12787: PUSH
12788: FOR_TO
12789: IFFALSE 12826
// begin InitHc ;
12791: CALL_OW 19
// hc_class := class_apeman ;
12795: LD_ADDR_OWVAR 28
12799: PUSH
12800: LD_INT 12
12802: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12803: CALL_OW 44
12807: PPUSH
12808: LD_INT 299
12810: PPUSH
12811: LD_INT 229
12813: PPUSH
12814: LD_INT 10
12816: PPUSH
12817: LD_INT 0
12819: PPUSH
12820: CALL_OW 50
// end ;
12824: GO 12788
12826: POP
12827: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12828: LD_EXP 76
12832: PPUSH
12833: LD_INT 259
12835: PPUSH
12836: LD_INT 235
12838: PPUSH
12839: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12843: LD_EXP 76
12847: PPUSH
12848: LD_INT 262
12850: PPUSH
12851: LD_INT 235
12853: PPUSH
12854: CALL_OW 178
// if Simms then
12858: LD_EXP 77
12862: IFFALSE 12893
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12864: LD_EXP 77
12868: PPUSH
12869: LD_INT 262
12871: PPUSH
12872: LD_INT 235
12874: PPUSH
12875: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12879: LD_EXP 77
12883: PPUSH
12884: LD_EXP 76
12888: PPUSH
12889: CALL_OW 179
// end ; end ;
12893: LD_VAR 0 1
12897: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12898: LD_EXP 31
12902: PUSH
12903: LD_EXP 23
12907: NOT
12908: AND
12909: IFFALSE 13137
12911: GO 12913
12913: DISABLE
12914: LD_INT 0
12916: PPUSH
12917: PPUSH
12918: PPUSH
// begin enable ;
12919: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12920: LD_ADDR_VAR 0 2
12924: PUSH
12925: LD_INT 81
12927: PUSH
12928: LD_INT 7
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PUSH
12935: LD_INT 2
12937: PUSH
12938: LD_INT 32
12940: PUSH
12941: LD_INT 3
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PUSH
12948: LD_INT 30
12950: PUSH
12951: LD_INT 30
12953: PUSH
12954: EMPTY
12955: LIST
12956: LIST
12957: PUSH
12958: LD_INT 30
12960: PUSH
12961: LD_INT 28
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: PUSH
12968: LD_INT 34
12970: PUSH
12971: LD_INT 49
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PUSH
12978: LD_INT 34
12980: PUSH
12981: LD_INT 10
12983: PUSH
12984: EMPTY
12985: LIST
12986: LIST
12987: PUSH
12988: LD_INT 34
12990: PUSH
12991: LD_INT 8
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: PPUSH
13011: CALL_OW 69
13015: ST_TO_ADDR
// if not tmp then
13016: LD_VAR 0 2
13020: NOT
13021: IFFALSE 13025
// exit ;
13023: GO 13137
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13025: LD_VAR 0 2
13029: PPUSH
13030: LD_INT 34
13032: PUSH
13033: LD_INT 8
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PPUSH
13040: CALL_OW 72
13044: IFFALSE 13077
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13046: LD_ADDR_VAR 0 3
13050: PUSH
13051: LD_VAR 0 2
13055: PPUSH
13056: LD_INT 34
13058: PUSH
13059: LD_INT 8
13061: PUSH
13062: EMPTY
13063: LIST
13064: LIST
13065: PPUSH
13066: CALL_OW 72
13070: PUSH
13071: LD_INT 1
13073: ARRAY
13074: ST_TO_ADDR
13075: GO 13101
// target := tmp [ rand ( 1 , tmp ) ] ;
13077: LD_ADDR_VAR 0 3
13081: PUSH
13082: LD_VAR 0 2
13086: PUSH
13087: LD_INT 1
13089: PPUSH
13090: LD_VAR 0 2
13094: PPUSH
13095: CALL_OW 12
13099: ARRAY
13100: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13101: LD_VAR 0 3
13105: PPUSH
13106: CALL_OW 255
13110: PUSH
13111: LD_INT 1
13113: EQUAL
13114: IFFALSE 13125
// CenterNowOnUnits ( target ) ;
13116: LD_VAR 0 3
13120: PPUSH
13121: CALL_OW 87
// SetLives ( target , 0 ) ;
13125: LD_VAR 0 3
13129: PPUSH
13130: LD_INT 0
13132: PPUSH
13133: CALL_OW 234
// end ;
13137: PPOPN 3
13139: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13140: LD_EXP 23
13144: NOT
13145: PUSH
13146: LD_EXP 31
13150: AND
13151: IFFALSE 13677
13153: GO 13155
13155: DISABLE
13156: LD_INT 0
13158: PPUSH
13159: PPUSH
13160: PPUSH
// begin uc_side := 7 ;
13161: LD_ADDR_OWVAR 20
13165: PUSH
13166: LD_INT 7
13168: ST_TO_ADDR
// uc_nation := 1 ;
13169: LD_ADDR_OWVAR 21
13173: PUSH
13174: LD_INT 1
13176: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13177: LD_ADDR_VAR 0 3
13181: PUSH
13182: LD_INT 125
13184: PUSH
13185: LD_INT 163
13187: PUSH
13188: EMPTY
13189: LIST
13190: LIST
13191: PUSH
13192: LD_INT 185
13194: PUSH
13195: LD_INT 168
13197: PUSH
13198: EMPTY
13199: LIST
13200: LIST
13201: PUSH
13202: LD_INT 111
13204: PUSH
13205: LD_INT 97
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: EMPTY
13213: LIST
13214: LIST
13215: LIST
13216: PPUSH
13217: CALL 104804 0 1
13221: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13222: LD_ADDR_EXP 93
13226: PUSH
13227: EMPTY
13228: ST_TO_ADDR
// for i = 1 to Difficulty do
13229: LD_ADDR_VAR 0 1
13233: PUSH
13234: DOUBLE
13235: LD_INT 1
13237: DEC
13238: ST_TO_ADDR
13239: LD_OWVAR 67
13243: PUSH
13244: FOR_TO
13245: IFFALSE 13403
// begin InitHc ;
13247: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13251: LD_INT 0
13253: PPUSH
13254: LD_INT 8
13256: PPUSH
13257: CALL_OW 381
// un := CreateHuman ;
13261: LD_ADDR_VAR 0 2
13265: PUSH
13266: CALL_OW 44
13270: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13271: LD_VAR 0 2
13275: PPUSH
13276: LD_INT 258
13278: PPUSH
13279: LD_INT 267
13281: PPUSH
13282: LD_INT 4
13284: PPUSH
13285: LD_INT 0
13287: PPUSH
13288: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13292: LD_ADDR_EXP 93
13296: PUSH
13297: LD_EXP 93
13301: PUSH
13302: LD_VAR 0 2
13306: UNION
13307: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13308: LD_VAR 0 2
13312: PPUSH
13313: LD_VAR 0 3
13317: PUSH
13318: LD_VAR 0 1
13322: ARRAY
13323: PUSH
13324: LD_INT 1
13326: ARRAY
13327: PPUSH
13328: LD_VAR 0 3
13332: PUSH
13333: LD_VAR 0 1
13337: ARRAY
13338: PUSH
13339: LD_INT 2
13341: ARRAY
13342: PPUSH
13343: LD_INT 4
13345: PPUSH
13346: LD_INT 1
13348: PPUSH
13349: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13353: LD_VAR 0 2
13357: PPUSH
13358: LD_VAR 0 3
13362: PUSH
13363: LD_VAR 0 1
13367: ARRAY
13368: PUSH
13369: LD_INT 1
13371: ARRAY
13372: PPUSH
13373: LD_VAR 0 3
13377: PUSH
13378: LD_VAR 0 1
13382: ARRAY
13383: PUSH
13384: LD_INT 2
13386: ARRAY
13387: PPUSH
13388: CALL_OW 171
// AddComInvisible ( un ) ;
13392: LD_VAR 0 2
13396: PPUSH
13397: CALL_OW 212
// end ;
13401: GO 13244
13403: POP
13404: POP
// repeat wait ( 0 0$20 ) ;
13405: LD_INT 700
13407: PPUSH
13408: CALL_OW 67
// for i in allianceSpecialForce do
13412: LD_ADDR_VAR 0 1
13416: PUSH
13417: LD_EXP 93
13421: PUSH
13422: FOR_IN
13423: IFFALSE 13662
// begin if IsInvisible ( i ) then
13425: LD_VAR 0 1
13429: PPUSH
13430: CALL_OW 571
13434: IFFALSE 13631
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13436: LD_ADDR_VAR 0 3
13440: PUSH
13441: LD_INT 22
13443: PUSH
13444: LD_INT 1
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: PUSH
13451: LD_INT 50
13453: PUSH
13454: EMPTY
13455: LIST
13456: PUSH
13457: LD_INT 56
13459: PUSH
13460: EMPTY
13461: LIST
13462: PUSH
13463: LD_INT 91
13465: PUSH
13466: LD_VAR 0 1
13470: PUSH
13471: LD_INT 25
13473: PUSH
13474: LD_INT 30
13476: PUSH
13477: LD_INT 35
13479: PUSH
13480: LD_INT 40
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: PUSH
13489: LD_OWVAR 67
13493: ARRAY
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: LIST
13499: PUSH
13500: LD_INT 2
13502: PUSH
13503: LD_INT 25
13505: PUSH
13506: LD_INT 1
13508: PUSH
13509: EMPTY
13510: LIST
13511: LIST
13512: PUSH
13513: LD_INT 25
13515: PUSH
13516: LD_INT 2
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PUSH
13523: LD_INT 25
13525: PUSH
13526: LD_INT 3
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: PUSH
13533: LD_INT 25
13535: PUSH
13536: LD_INT 4
13538: PUSH
13539: EMPTY
13540: LIST
13541: LIST
13542: PUSH
13543: LD_INT 25
13545: PUSH
13546: LD_INT 5
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PUSH
13553: LD_INT 25
13555: PUSH
13556: LD_INT 8
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: LIST
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: PPUSH
13579: CALL_OW 69
13583: ST_TO_ADDR
// if not tmp then
13584: LD_VAR 0 3
13588: NOT
13589: IFFALSE 13593
// continue ;
13591: GO 13422
// if Prob ( 30 * Difficulty ) then
13593: LD_INT 30
13595: PUSH
13596: LD_OWVAR 67
13600: MUL
13601: PPUSH
13602: CALL_OW 13
13606: IFFALSE 13631
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13608: LD_VAR 0 3
13612: PUSH
13613: LD_INT 1
13615: PPUSH
13616: LD_VAR 0 3
13620: PPUSH
13621: CALL_OW 12
13625: ARRAY
13626: PPUSH
13627: CALL 32641 0 1
// end ; if IsDead ( i ) then
13631: LD_VAR 0 1
13635: PPUSH
13636: CALL_OW 301
13640: IFFALSE 13660
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13642: LD_ADDR_EXP 93
13646: PUSH
13647: LD_EXP 93
13651: PUSH
13652: LD_VAR 0 1
13656: DIFF
13657: ST_TO_ADDR
// continue ;
13658: GO 13422
// end ; end ;
13660: GO 13422
13662: POP
13663: POP
// until allianceDestroyed or not allianceSpecialForce ;
13664: LD_EXP 23
13668: PUSH
13669: LD_EXP 93
13673: NOT
13674: OR
13675: IFFALSE 13405
// end ;
13677: PPOPN 3
13679: END
// every 12 12$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13680: LD_EXP 23
13684: NOT
13685: PUSH
13686: LD_EXP 31
13690: AND
13691: IFFALSE 14641
13693: GO 13695
13695: DISABLE
13696: LD_INT 0
13698: PPUSH
13699: PPUSH
13700: PPUSH
13701: PPUSH
// begin enable ;
13702: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13703: LD_INT 22
13705: PUSH
13706: LD_INT 7
13708: PUSH
13709: EMPTY
13710: LIST
13711: LIST
13712: PUSH
13713: LD_INT 30
13715: PUSH
13716: LD_INT 3
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PPUSH
13727: CALL_OW 69
13731: NOT
13732: IFFALSE 13736
// exit ;
13734: GO 14641
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13736: LD_ADDR_VAR 0 4
13740: PUSH
13741: LD_INT 22
13743: PUSH
13744: LD_INT 7
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PUSH
13751: LD_INT 30
13753: PUSH
13754: LD_INT 34
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: PUSH
13761: EMPTY
13762: LIST
13763: LIST
13764: PPUSH
13765: CALL_OW 69
13769: ST_TO_ADDR
// if Prob ( 40 ) then
13770: LD_INT 40
13772: PPUSH
13773: CALL_OW 13
13777: IFFALSE 13923
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13779: LD_INT 1
13781: PPUSH
13782: LD_INT 5
13784: PUSH
13785: LD_INT 3
13787: PUSH
13788: LD_INT 2
13790: PUSH
13791: LD_INT 6
13793: PUSH
13794: EMPTY
13795: LIST
13796: LIST
13797: LIST
13798: LIST
13799: PUSH
13800: LD_INT 5
13802: PUSH
13803: LD_INT 3
13805: PUSH
13806: LD_INT 2
13808: PUSH
13809: LD_INT 6
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: LIST
13816: LIST
13817: PUSH
13818: LD_INT 5
13820: PUSH
13821: LD_INT 3
13823: PUSH
13824: LD_INT 2
13826: PUSH
13827: LD_INT 6
13829: PUSH
13830: EMPTY
13831: LIST
13832: LIST
13833: LIST
13834: LIST
13835: PUSH
13836: LD_INT 5
13838: PUSH
13839: LD_INT 3
13841: PUSH
13842: LD_INT 2
13844: PUSH
13845: LD_INT 9
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: LIST
13852: LIST
13853: PUSH
13854: LD_INT 24
13856: PUSH
13857: LD_INT 3
13859: PUSH
13860: LD_INT 3
13862: PUSH
13863: LD_INT 45
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: PUSH
13872: LD_INT 24
13874: PUSH
13875: LD_INT 3
13877: PUSH
13878: LD_INT 3
13880: PUSH
13881: LD_INT 47
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: PUSH
13890: LD_INT 24
13892: PUSH
13893: LD_INT 3
13895: PUSH
13896: LD_INT 3
13898: PUSH
13899: LD_INT 45
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: PPUSH
13917: CALL 60862 0 2
// end else
13921: GO 14065
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13923: LD_INT 1
13925: PPUSH
13926: LD_INT 24
13928: PUSH
13929: LD_INT 3
13931: PUSH
13932: LD_INT 3
13934: PUSH
13935: LD_INT 47
13937: PUSH
13938: EMPTY
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: PUSH
13944: LD_INT 24
13946: PUSH
13947: LD_INT 3
13949: PUSH
13950: LD_INT 3
13952: PUSH
13953: LD_INT 47
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: PUSH
13962: LD_INT 5
13964: PUSH
13965: LD_INT 3
13967: PUSH
13968: LD_INT 2
13970: PUSH
13971: LD_INT 9
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: PUSH
13980: LD_INT 5
13982: PUSH
13983: LD_INT 3
13985: PUSH
13986: LD_INT 2
13988: PUSH
13989: LD_INT 9
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: PUSH
13998: LD_INT 5
14000: PUSH
14001: LD_INT 3
14003: PUSH
14004: LD_INT 2
14006: PUSH
14007: LD_INT 9
14009: PUSH
14010: EMPTY
14011: LIST
14012: LIST
14013: LIST
14014: LIST
14015: PUSH
14016: LD_INT 24
14018: PUSH
14019: LD_INT 1
14021: PUSH
14022: LD_INT 3
14024: PUSH
14025: LD_INT 45
14027: PUSH
14028: EMPTY
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: PUSH
14034: LD_INT 24
14036: PUSH
14037: LD_INT 1
14039: PUSH
14040: LD_INT 3
14042: PUSH
14043: LD_INT 45
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: LIST
14050: LIST
14051: PUSH
14052: EMPTY
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: LIST
14058: LIST
14059: LIST
14060: PPUSH
14061: CALL 60862 0 2
// end ; repeat wait ( 0 0$1 ) ;
14065: LD_INT 35
14067: PPUSH
14068: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14072: LD_INT 1
14074: PPUSH
14075: LD_INT 1
14077: PPUSH
14078: CALL 62280 0 2
14082: PUSH
14083: LD_INT 7
14085: GREATEREQUAL
14086: IFFALSE 14065
// wait ( 0 0$10 ) ;
14088: LD_INT 350
14090: PPUSH
14091: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14095: LD_ADDR_VAR 0 2
14099: PUSH
14100: LD_INT 1
14102: PPUSH
14103: LD_INT 1
14105: PPUSH
14106: CALL 62280 0 2
14110: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14111: LD_ADDR_EXP 118
14115: PUSH
14116: LD_EXP 118
14120: PPUSH
14121: LD_INT 1
14123: PPUSH
14124: LD_EXP 118
14128: PUSH
14129: LD_INT 1
14131: ARRAY
14132: PUSH
14133: LD_VAR 0 2
14137: DIFF
14138: PPUSH
14139: CALL_OW 1
14143: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14144: LD_ADDR_VAR 0 3
14148: PUSH
14149: LD_INT 0
14151: PPUSH
14152: LD_INT 1
14154: PPUSH
14155: CALL_OW 12
14159: ST_TO_ADDR
// if target then
14160: LD_VAR 0 3
14164: IFFALSE 14330
// begin for i in tmp do
14166: LD_ADDR_VAR 0 1
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: FOR_IN
14177: IFFALSE 14202
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14179: LD_VAR 0 1
14183: PPUSH
14184: LD_INT 179
14186: PPUSH
14187: LD_INT 209
14189: PPUSH
14190: LD_INT 8
14192: PPUSH
14193: LD_INT 1
14195: PPUSH
14196: CALL_OW 483
14200: GO 14176
14202: POP
14203: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14204: LD_ADDR_VAR 0 2
14208: PUSH
14209: LD_VAR 0 2
14213: PPUSH
14214: LD_INT 24
14216: PUSH
14217: LD_INT 250
14219: PUSH
14220: EMPTY
14221: LIST
14222: LIST
14223: PPUSH
14224: CALL_OW 72
14228: ST_TO_ADDR
// for i in tmp do
14229: LD_ADDR_VAR 0 1
14233: PUSH
14234: LD_VAR 0 2
14238: PUSH
14239: FOR_IN
14240: IFFALSE 14280
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14242: LD_VAR 0 1
14246: PPUSH
14247: LD_INT 179
14249: PPUSH
14250: LD_INT 209
14252: PPUSH
14253: CALL_OW 297
14257: PUSH
14258: LD_INT 9
14260: GREATER
14261: IFFALSE 14278
// ComMoveXY ( i , 179 , 209 ) ;
14263: LD_VAR 0 1
14267: PPUSH
14268: LD_INT 179
14270: PPUSH
14271: LD_INT 209
14273: PPUSH
14274: CALL_OW 111
14278: GO 14239
14280: POP
14281: POP
// wait ( 0 0$1 ) ;
14282: LD_INT 35
14284: PPUSH
14285: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14289: LD_VAR 0 2
14293: PPUSH
14294: LD_INT 92
14296: PUSH
14297: LD_INT 179
14299: PUSH
14300: LD_INT 209
14302: PUSH
14303: LD_INT 9
14305: PUSH
14306: EMPTY
14307: LIST
14308: LIST
14309: LIST
14310: LIST
14311: PPUSH
14312: CALL_OW 72
14316: PUSH
14317: LD_VAR 0 2
14321: PUSH
14322: LD_INT 1
14324: MINUS
14325: GREATEREQUAL
14326: IFFALSE 14204
// end else
14328: GO 14492
// begin for i in tmp do
14330: LD_ADDR_VAR 0 1
14334: PUSH
14335: LD_VAR 0 2
14339: PUSH
14340: FOR_IN
14341: IFFALSE 14366
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14343: LD_VAR 0 1
14347: PPUSH
14348: LD_INT 285
14350: PPUSH
14351: LD_INT 163
14353: PPUSH
14354: LD_INT 8
14356: PPUSH
14357: LD_INT 1
14359: PPUSH
14360: CALL_OW 483
14364: GO 14340
14366: POP
14367: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14368: LD_ADDR_VAR 0 2
14372: PUSH
14373: LD_VAR 0 2
14377: PPUSH
14378: LD_INT 24
14380: PUSH
14381: LD_INT 250
14383: PUSH
14384: EMPTY
14385: LIST
14386: LIST
14387: PPUSH
14388: CALL_OW 72
14392: ST_TO_ADDR
// for i in tmp do
14393: LD_ADDR_VAR 0 1
14397: PUSH
14398: LD_VAR 0 2
14402: PUSH
14403: FOR_IN
14404: IFFALSE 14444
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14406: LD_VAR 0 1
14410: PPUSH
14411: LD_INT 285
14413: PPUSH
14414: LD_INT 163
14416: PPUSH
14417: CALL_OW 297
14421: PUSH
14422: LD_INT 9
14424: GREATER
14425: IFFALSE 14442
// ComMoveXY ( i , 285 , 163 ) ;
14427: LD_VAR 0 1
14431: PPUSH
14432: LD_INT 285
14434: PPUSH
14435: LD_INT 163
14437: PPUSH
14438: CALL_OW 111
14442: GO 14403
14444: POP
14445: POP
// wait ( 0 0$1 ) ;
14446: LD_INT 35
14448: PPUSH
14449: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14453: LD_VAR 0 2
14457: PPUSH
14458: LD_INT 92
14460: PUSH
14461: LD_INT 285
14463: PUSH
14464: LD_INT 163
14466: PUSH
14467: LD_INT 9
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: PPUSH
14476: CALL_OW 72
14480: PUSH
14481: LD_VAR 0 2
14485: PUSH
14486: LD_INT 1
14488: MINUS
14489: GREATEREQUAL
14490: IFFALSE 14368
// end ; repeat wait ( 0 0$1 ) ;
14492: LD_INT 35
14494: PPUSH
14495: CALL_OW 67
// for i in tmp do
14499: LD_ADDR_VAR 0 1
14503: PUSH
14504: LD_VAR 0 2
14508: PUSH
14509: FOR_IN
14510: IFFALSE 14632
// if GetLives ( i ) > 251 then
14512: LD_VAR 0 1
14516: PPUSH
14517: CALL_OW 256
14521: PUSH
14522: LD_INT 251
14524: GREATER
14525: IFFALSE 14614
// begin if GetWeapon ( i ) = ru_time_lapser then
14527: LD_VAR 0 1
14531: PPUSH
14532: CALL_OW 264
14536: PUSH
14537: LD_INT 49
14539: EQUAL
14540: IFFALSE 14578
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14542: LD_VAR 0 1
14546: PPUSH
14547: LD_INT 81
14549: PUSH
14550: LD_INT 7
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PPUSH
14557: CALL_OW 69
14561: PPUSH
14562: LD_VAR 0 1
14566: PPUSH
14567: CALL_OW 74
14571: PPUSH
14572: CALL_OW 112
14576: GO 14612
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14578: LD_VAR 0 1
14582: PPUSH
14583: LD_INT 81
14585: PUSH
14586: LD_INT 7
14588: PUSH
14589: EMPTY
14590: LIST
14591: LIST
14592: PPUSH
14593: CALL_OW 69
14597: PPUSH
14598: LD_VAR 0 1
14602: PPUSH
14603: CALL_OW 74
14607: PPUSH
14608: CALL_OW 115
// end else
14612: GO 14630
// tmp := tmp diff i ;
14614: LD_ADDR_VAR 0 2
14618: PUSH
14619: LD_VAR 0 2
14623: PUSH
14624: LD_VAR 0 1
14628: DIFF
14629: ST_TO_ADDR
14630: GO 14509
14632: POP
14633: POP
// until not tmp ;
14634: LD_VAR 0 2
14638: NOT
14639: IFFALSE 14492
// end ; end_of_file
14641: PPOPN 4
14643: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
14644: LD_INT 0
14646: PPUSH
14647: PPUSH
14648: PPUSH
14649: PPUSH
// missionStage := 13 ;
14650: LD_ADDR_EXP 15
14654: PUSH
14655: LD_INT 13
14657: ST_TO_ADDR
// uc_side := 2 ;
14658: LD_ADDR_OWVAR 20
14662: PUSH
14663: LD_INT 2
14665: ST_TO_ADDR
// uc_nation := 2 ;
14666: LD_ADDR_OWVAR 21
14670: PUSH
14671: LD_INT 2
14673: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14674: LD_ADDR_EXP 94
14678: PUSH
14679: LD_STRING Omar
14681: PPUSH
14682: CALL_OW 25
14686: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14687: LD_EXP 94
14691: PPUSH
14692: LD_INT 4
14694: PPUSH
14695: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14699: LD_EXP 94
14703: PPUSH
14704: LD_INT 242
14706: PPUSH
14707: LD_INT 75
14709: PPUSH
14710: LD_INT 0
14712: PPUSH
14713: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14717: LD_ADDR_EXP 95
14721: PUSH
14722: LD_STRING Heike
14724: PPUSH
14725: CALL_OW 25
14729: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14730: LD_INT 14
14732: PPUSH
14733: LD_INT 3
14735: PPUSH
14736: LD_INT 1
14738: PPUSH
14739: LD_INT 27
14741: PPUSH
14742: LD_INT 100
14744: PPUSH
14745: CALL 72265 0 5
// veh := CreateVehicle ;
14749: LD_ADDR_VAR 0 3
14753: PUSH
14754: CALL_OW 45
14758: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14759: LD_VAR 0 3
14763: PPUSH
14764: LD_INT 2
14766: NEG
14767: PPUSH
14768: CALL_OW 242
// SetDir ( veh , 4 ) ;
14772: LD_VAR 0 3
14776: PPUSH
14777: LD_INT 4
14779: PPUSH
14780: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14784: LD_VAR 0 3
14788: PPUSH
14789: LD_INT 241
14791: PPUSH
14792: LD_INT 72
14794: PPUSH
14795: LD_INT 0
14797: PPUSH
14798: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14802: LD_EXP 95
14806: PPUSH
14807: LD_VAR 0 3
14811: PPUSH
14812: CALL_OW 52
// if KhatamStatus then
14816: LD_EXP 8
14820: IFFALSE 14883
// begin Khatam := NewCharacter ( Khatam ) ;
14822: LD_ADDR_EXP 96
14826: PUSH
14827: LD_STRING Khatam
14829: PPUSH
14830: CALL_OW 25
14834: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14835: LD_EXP 96
14839: PPUSH
14840: LD_INT 245
14842: PPUSH
14843: LD_INT 78
14845: PPUSH
14846: LD_INT 3
14848: PPUSH
14849: LD_INT 0
14851: PPUSH
14852: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14856: LD_EXP 96
14860: PPUSH
14861: LD_INT 4
14863: PPUSH
14864: LD_INT 10
14866: PPUSH
14867: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14871: LD_EXP 96
14875: PPUSH
14876: LD_INT 4
14878: PPUSH
14879: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
14883: LD_ADDR_VAR 0 2
14887: PUSH
14888: DOUBLE
14889: LD_INT 1
14891: DEC
14892: ST_TO_ADDR
14893: LD_INT 2
14895: PUSH
14896: LD_INT 2
14898: PUSH
14899: LD_INT 3
14901: PUSH
14902: LD_INT 3
14904: PUSH
14905: EMPTY
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: PUSH
14911: LD_OWVAR 67
14915: ARRAY
14916: PUSH
14917: FOR_TO
14918: IFFALSE 14984
// begin PrepareScientist ( false , 6 + Difficulty ) ;
14920: LD_INT 0
14922: PPUSH
14923: LD_INT 6
14925: PUSH
14926: LD_OWVAR 67
14930: PLUS
14931: PPUSH
14932: CALL_OW 384
// un := CreateHuman ;
14936: LD_ADDR_VAR 0 4
14940: PUSH
14941: CALL_OW 44
14945: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14946: LD_VAR 0 4
14950: PPUSH
14951: LD_INT 28
14953: PUSH
14954: LD_INT 29
14956: PUSH
14957: EMPTY
14958: LIST
14959: LIST
14960: PUSH
14961: LD_VAR 0 2
14965: PUSH
14966: LD_INT 2
14968: MOD
14969: PUSH
14970: LD_INT 1
14972: PLUS
14973: ARRAY
14974: PPUSH
14975: LD_INT 0
14977: PPUSH
14978: CALL_OW 49
// end ;
14982: GO 14917
14984: POP
14985: POP
// for i = 1 to 6 do
14986: LD_ADDR_VAR 0 2
14990: PUSH
14991: DOUBLE
14992: LD_INT 1
14994: DEC
14995: ST_TO_ADDR
14996: LD_INT 6
14998: PUSH
14999: FOR_TO
15000: IFFALSE 15045
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15002: LD_INT 0
15004: PPUSH
15005: LD_INT 6
15007: PUSH
15008: LD_OWVAR 67
15012: PLUS
15013: PPUSH
15014: CALL_OW 381
// un := CreateHuman ;
15018: LD_ADDR_VAR 0 4
15022: PUSH
15023: CALL_OW 44
15027: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15028: LD_VAR 0 4
15032: PPUSH
15033: LD_INT 32
15035: PPUSH
15036: LD_INT 0
15038: PPUSH
15039: CALL_OW 49
// end ;
15043: GO 14999
15045: POP
15046: POP
// for i = 1 to 3 do
15047: LD_ADDR_VAR 0 2
15051: PUSH
15052: DOUBLE
15053: LD_INT 1
15055: DEC
15056: ST_TO_ADDR
15057: LD_INT 3
15059: PUSH
15060: FOR_TO
15061: IFFALSE 15109
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15063: LD_INT 0
15065: PPUSH
15066: LD_INT 8
15068: PPUSH
15069: LD_INT 6
15071: PUSH
15072: LD_OWVAR 67
15076: PLUS
15077: PPUSH
15078: CALL_OW 380
// un := CreateHuman ;
15082: LD_ADDR_VAR 0 4
15086: PUSH
15087: CALL_OW 44
15091: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15092: LD_VAR 0 4
15096: PPUSH
15097: LD_INT 32
15099: PPUSH
15100: LD_INT 0
15102: PPUSH
15103: CALL_OW 49
// end ;
15107: GO 15060
15109: POP
15110: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15111: LD_ADDR_VAR 0 2
15115: PUSH
15116: DOUBLE
15117: LD_INT 1
15119: DEC
15120: ST_TO_ADDR
15121: LD_INT 2
15123: PUSH
15124: LD_INT 3
15126: PUSH
15127: LD_INT 4
15129: PUSH
15130: LD_INT 4
15132: PUSH
15133: EMPTY
15134: LIST
15135: LIST
15136: LIST
15137: LIST
15138: PUSH
15139: LD_OWVAR 67
15143: ARRAY
15144: PUSH
15145: FOR_TO
15146: IFFALSE 15236
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15148: LD_INT 14
15150: PPUSH
15151: LD_INT 2
15153: PPUSH
15154: LD_INT 1
15156: PPUSH
15157: LD_INT 28
15159: PPUSH
15160: LD_INT 80
15162: PPUSH
15163: CALL 72265 0 5
// veh := CreateVehicle ;
15167: LD_ADDR_VAR 0 3
15171: PUSH
15172: CALL_OW 45
15176: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15177: LD_VAR 0 3
15181: PPUSH
15182: LD_INT 3
15184: PPUSH
15185: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15189: LD_VAR 0 3
15193: PPUSH
15194: LD_INT 29
15196: PPUSH
15197: LD_INT 0
15199: PPUSH
15200: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15204: LD_INT 0
15206: PPUSH
15207: LD_INT 6
15209: PUSH
15210: LD_OWVAR 67
15214: PLUS
15215: PPUSH
15216: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15220: CALL_OW 44
15224: PPUSH
15225: LD_VAR 0 3
15229: PPUSH
15230: CALL_OW 52
// end ;
15234: GO 15145
15236: POP
15237: POP
// for i = 1 to 5 + Difficulty do
15238: LD_ADDR_VAR 0 2
15242: PUSH
15243: DOUBLE
15244: LD_INT 1
15246: DEC
15247: ST_TO_ADDR
15248: LD_INT 5
15250: PUSH
15251: LD_OWVAR 67
15255: PLUS
15256: PUSH
15257: FOR_TO
15258: IFFALSE 15385
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15260: LD_INT 14
15262: PPUSH
15263: LD_INT 1
15265: PPUSH
15266: LD_INT 3
15268: PPUSH
15269: CALL_OW 12
15273: PPUSH
15274: LD_INT 1
15276: PPUSH
15277: LD_INT 28
15279: PUSH
15280: LD_INT 26
15282: PUSH
15283: LD_INT 27
15285: PUSH
15286: LD_INT 25
15288: PUSH
15289: EMPTY
15290: LIST
15291: LIST
15292: LIST
15293: LIST
15294: PUSH
15295: LD_VAR 0 2
15299: PUSH
15300: LD_INT 4
15302: MOD
15303: PUSH
15304: LD_INT 1
15306: PLUS
15307: ARRAY
15308: PPUSH
15309: LD_INT 80
15311: PPUSH
15312: CALL 72265 0 5
// veh := CreateVehicle ;
15316: LD_ADDR_VAR 0 3
15320: PUSH
15321: CALL_OW 45
15325: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15326: LD_VAR 0 3
15330: PPUSH
15331: LD_INT 4
15333: PPUSH
15334: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15338: LD_VAR 0 3
15342: PPUSH
15343: LD_INT 28
15345: PPUSH
15346: LD_INT 0
15348: PPUSH
15349: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15353: LD_INT 0
15355: PPUSH
15356: LD_INT 6
15358: PUSH
15359: LD_OWVAR 67
15363: PLUS
15364: PPUSH
15365: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15369: CALL_OW 44
15373: PPUSH
15374: LD_VAR 0 3
15378: PPUSH
15379: CALL_OW 52
// end ;
15383: GO 15257
15385: POP
15386: POP
// for i = 1 to Difficulty do
15387: LD_ADDR_VAR 0 2
15391: PUSH
15392: DOUBLE
15393: LD_INT 1
15395: DEC
15396: ST_TO_ADDR
15397: LD_OWVAR 67
15401: PUSH
15402: FOR_TO
15403: IFFALSE 15463
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15405: LD_INT 14
15407: PPUSH
15408: LD_INT 3
15410: PPUSH
15411: LD_INT 5
15413: PPUSH
15414: LD_INT 29
15416: PPUSH
15417: LD_INT 80
15419: PPUSH
15420: CALL 72265 0 5
// veh := CreateVehicle ;
15424: LD_ADDR_VAR 0 3
15428: PUSH
15429: CALL_OW 45
15433: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15434: LD_VAR 0 3
15438: PPUSH
15439: LD_INT 4
15441: PPUSH
15442: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15446: LD_VAR 0 3
15450: PPUSH
15451: LD_INT 28
15453: PPUSH
15454: LD_INT 0
15456: PPUSH
15457: CALL_OW 49
// end ;
15461: GO 15402
15463: POP
15464: POP
// end ;
15465: LD_VAR 0 1
15469: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15470: LD_INT 22
15472: PUSH
15473: LD_INT 2
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: PPUSH
15480: CALL_OW 69
15484: IFFALSE 15863
15486: GO 15488
15488: DISABLE
15489: LD_INT 0
15491: PPUSH
15492: PPUSH
15493: PPUSH
15494: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15495: LD_ADDR_VAR 0 3
15499: PUSH
15500: LD_INT 22
15502: PUSH
15503: LD_INT 2
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 25
15512: PUSH
15513: LD_INT 4
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: PPUSH
15524: CALL_OW 69
15528: PUSH
15529: LD_EXP 96
15533: DIFF
15534: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15535: LD_ADDR_VAR 0 2
15539: PUSH
15540: LD_INT 22
15542: PUSH
15543: LD_INT 2
15545: PUSH
15546: EMPTY
15547: LIST
15548: LIST
15549: PPUSH
15550: CALL_OW 69
15554: PUSH
15555: LD_EXP 96
15559: PUSH
15560: LD_VAR 0 3
15564: UNION
15565: DIFF
15566: ST_TO_ADDR
// if Khatam then
15567: LD_EXP 96
15571: IFFALSE 15588
// ComMoveXY ( Khatam , 211 , 92 ) ;
15573: LD_EXP 96
15577: PPUSH
15578: LD_INT 211
15580: PPUSH
15581: LD_INT 92
15583: PPUSH
15584: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15588: LD_INT 197
15590: PPUSH
15591: LD_INT 80
15593: PPUSH
15594: LD_INT 2
15596: PPUSH
15597: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15601: LD_INT 213
15603: PPUSH
15604: LD_INT 90
15606: PPUSH
15607: LD_INT 2
15609: PPUSH
15610: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
15614: LD_INT 215
15616: PPUSH
15617: LD_INT 129
15619: PPUSH
15620: LD_INT 2
15622: PPUSH
15623: CALL_OW 441
// if sci then
15627: LD_VAR 0 3
15631: IFFALSE 15652
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
15633: LD_VAR 0 3
15637: PUSH
15638: LD_INT 1
15640: ARRAY
15641: PPUSH
15642: LD_INT 197
15644: PPUSH
15645: LD_INT 80
15647: PPUSH
15648: CALL_OW 158
// if sci > 1 then
15652: LD_VAR 0 3
15656: PUSH
15657: LD_INT 1
15659: GREATER
15660: IFFALSE 15681
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
15662: LD_VAR 0 3
15666: PUSH
15667: LD_INT 2
15669: ARRAY
15670: PPUSH
15671: LD_INT 213
15673: PPUSH
15674: LD_INT 90
15676: PPUSH
15677: CALL_OW 158
// if sci > 2 then
15681: LD_VAR 0 3
15685: PUSH
15686: LD_INT 2
15688: GREATER
15689: IFFALSE 15710
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
15691: LD_VAR 0 3
15695: PUSH
15696: LD_INT 3
15698: ARRAY
15699: PPUSH
15700: LD_INT 215
15702: PPUSH
15703: LD_INT 129
15705: PPUSH
15706: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
15710: LD_VAR 0 2
15714: PPUSH
15715: LD_INT 195
15717: PPUSH
15718: LD_INT 102
15720: PPUSH
15721: CALL_OW 114
// wait ( 0 0$5 ) ;
15725: LD_INT 175
15727: PPUSH
15728: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
15732: LD_INT 70
15734: PPUSH
15735: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
15739: LD_ADDR_VAR 0 4
15743: PUSH
15744: LD_INT 92
15746: PUSH
15747: LD_INT 195
15749: PUSH
15750: LD_INT 102
15752: PUSH
15753: LD_INT 36
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 22
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: ST_TO_ADDR
// for i in tmp do
15781: LD_ADDR_VAR 0 1
15785: PUSH
15786: LD_VAR 0 2
15790: PUSH
15791: FOR_IN
15792: IFFALSE 15843
// if enemy then
15794: LD_VAR 0 4
15798: IFFALSE 15826
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15800: LD_VAR 0 1
15804: PPUSH
15805: LD_VAR 0 4
15809: PPUSH
15810: LD_VAR 0 1
15814: PPUSH
15815: CALL_OW 74
15819: PPUSH
15820: CALL_OW 115
15824: GO 15841
// ComAgressiveMove ( i , 195 , 102 ) ;
15826: LD_VAR 0 1
15830: PPUSH
15831: LD_INT 195
15833: PPUSH
15834: LD_INT 102
15836: PPUSH
15837: CALL_OW 114
15841: GO 15791
15843: POP
15844: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
15845: LD_VAR 0 2
15849: PPUSH
15850: LD_INT 50
15852: PUSH
15853: EMPTY
15854: LIST
15855: PPUSH
15856: CALL_OW 72
15860: NOT
15861: IFFALSE 15732
// end ; end_of_file
15863: PPOPN 4
15865: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15866: LD_INT 0
15868: PPUSH
15869: PPUSH
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
15874: PPUSH
15875: PPUSH
15876: PPUSH
// Video ( true ) ;
15877: LD_INT 1
15879: PPUSH
15880: CALL 104671 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15884: LD_ADDR_VAR 0 5
15888: PUSH
15889: LD_INT 7
15891: PPUSH
15892: LD_INT 0
15894: PPUSH
15895: CALL_OW 517
15899: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15900: LD_ADDR_VAR 0 2
15904: PUSH
15905: DOUBLE
15906: LD_INT 1
15908: DEC
15909: ST_TO_ADDR
15910: LD_VAR 0 5
15914: PUSH
15915: LD_INT 1
15917: ARRAY
15918: PUSH
15919: FOR_TO
15920: IFFALSE 15965
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15922: LD_VAR 0 5
15926: PUSH
15927: LD_INT 1
15929: ARRAY
15930: PUSH
15931: LD_VAR 0 2
15935: ARRAY
15936: PPUSH
15937: LD_VAR 0 5
15941: PUSH
15942: LD_INT 2
15944: ARRAY
15945: PUSH
15946: LD_VAR 0 2
15950: ARRAY
15951: PPUSH
15952: LD_INT 1
15954: PPUSH
15955: LD_INT 15
15957: NEG
15958: PPUSH
15959: CALL 104585 0 4
15963: GO 15919
15965: POP
15966: POP
// CenterNowOnUnits ( Powell ) ;
15967: LD_EXP 59
15971: PPUSH
15972: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15976: LD_ADDR_VAR 0 5
15980: PUSH
15981: LD_EXP 57
15985: PUSH
15986: EMPTY
15987: LIST
15988: ST_TO_ADDR
// if GirlNewVeh then
15989: LD_EXP 58
15993: IFFALSE 16011
// tmp := tmp ^ GirlNewVeh ;
15995: LD_ADDR_VAR 0 5
15999: PUSH
16000: LD_VAR 0 5
16004: PUSH
16005: LD_EXP 58
16009: ADD
16010: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16011: LD_VAR 0 5
16015: PPUSH
16016: LD_INT 60
16018: PPUSH
16019: LD_INT 109
16021: PPUSH
16022: CALL_OW 111
// if KappaStatus then
16026: LD_EXP 2
16030: IFFALSE 16082
// begin Say ( JMM , D1nT-JMM-1 ) ;
16032: LD_EXP 40
16036: PPUSH
16037: LD_STRING D1nT-JMM-1
16039: PPUSH
16040: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16044: LD_EXP 59
16048: PPUSH
16049: LD_STRING D1T-Pow-1
16051: PPUSH
16052: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16056: LD_EXP 40
16060: PPUSH
16061: LD_STRING D1T-JMM-2
16063: PPUSH
16064: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16068: LD_EXP 59
16072: PPUSH
16073: LD_STRING D1T-Pow-2
16075: PPUSH
16076: CALL_OW 88
// end else
16080: GO 16288
// if JMMGirlStatus then
16082: LD_EXP 6
16086: IFFALSE 16231
// begin Say ( JMM , D1T-JMM-1 ) ;
16088: LD_EXP 40
16092: PPUSH
16093: LD_STRING D1T-JMM-1
16095: PPUSH
16096: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16100: LD_EXP 59
16104: PPUSH
16105: LD_STRING D1T-Pow-1
16107: PPUSH
16108: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16112: LD_EXP 40
16116: PPUSH
16117: LD_STRING D1T-JMM-3
16119: PPUSH
16120: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16124: LD_EXP 59
16128: PPUSH
16129: LD_STRING D1T-Pow-3
16131: PPUSH
16132: CALL_OW 88
// if JMMGirl then
16136: LD_EXP 7
16140: IFFALSE 16229
// begin case JMMGirl of 1 :
16142: LD_EXP 7
16146: PUSH
16147: LD_INT 1
16149: DOUBLE
16150: EQUAL
16151: IFTRUE 16155
16153: GO 16170
16155: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16156: LD_EXP 41
16160: PPUSH
16161: LD_STRING D1T-Joan-3
16163: PPUSH
16164: CALL_OW 88
16168: GO 16217
16170: LD_INT 2
16172: DOUBLE
16173: EQUAL
16174: IFTRUE 16178
16176: GO 16193
16178: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16179: LD_EXP 43
16183: PPUSH
16184: LD_STRING D1T-Lisa-3
16186: PPUSH
16187: CALL_OW 88
16191: GO 16217
16193: LD_INT 3
16195: DOUBLE
16196: EQUAL
16197: IFTRUE 16201
16199: GO 16216
16201: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16202: LD_EXP 55
16206: PPUSH
16207: LD_STRING D1T-Con-3
16209: PPUSH
16210: CALL_OW 88
16214: GO 16217
16216: POP
// Say ( Powell , D1T-Pow-4 ) ;
16217: LD_EXP 59
16221: PPUSH
16222: LD_STRING D1T-Pow-4
16224: PPUSH
16225: CALL_OW 88
// end ; end else
16229: GO 16288
// if not FastEnd then
16231: LD_EXP 11
16235: NOT
16236: IFFALSE 16264
// begin Say ( JMM , D1T-JMM-4 ) ;
16238: LD_EXP 40
16242: PPUSH
16243: LD_STRING D1T-JMM-4
16245: PPUSH
16246: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16250: LD_EXP 59
16254: PPUSH
16255: LD_STRING D1T-Pow-5
16257: PPUSH
16258: CALL_OW 88
// end else
16262: GO 16288
// begin Say ( JMM , D1nT-JMM-1 ) ;
16264: LD_EXP 40
16268: PPUSH
16269: LD_STRING D1nT-JMM-1
16271: PPUSH
16272: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16276: LD_EXP 59
16280: PPUSH
16281: LD_STRING D1nT-Pow-1
16283: PPUSH
16284: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16288: LD_INT 3
16290: PPUSH
16291: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16295: LD_EXP 57
16299: PPUSH
16300: CALL_OW 314
16304: NOT
16305: IFFALSE 16288
// ComExitVehicle ( JMM ) ;
16307: LD_EXP 40
16311: PPUSH
16312: CALL_OW 121
// repeat wait ( 3 ) ;
16316: LD_INT 3
16318: PPUSH
16319: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16323: LD_EXP 40
16327: PPUSH
16328: CALL_OW 310
16332: NOT
16333: IFFALSE 16316
// ComMoveXY ( JMM , 60 , 94 ) ;
16335: LD_EXP 40
16339: PPUSH
16340: LD_INT 60
16342: PPUSH
16343: LD_INT 94
16345: PPUSH
16346: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16350: LD_EXP 40
16354: PPUSH
16355: LD_EXP 59
16359: PPUSH
16360: CALL_OW 179
// if Joan then
16364: LD_EXP 41
16368: IFFALSE 16422
// begin ComExitVehicle ( Joan ) ;
16370: LD_EXP 41
16374: PPUSH
16375: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16379: LD_EXP 41
16383: PPUSH
16384: LD_INT 35
16386: PPUSH
16387: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16391: LD_EXP 41
16395: PPUSH
16396: LD_INT 65
16398: PPUSH
16399: LD_INT 104
16401: PPUSH
16402: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16406: LD_EXP 41
16410: PPUSH
16411: LD_EXP 40
16415: PPUSH
16416: CALL_OW 179
// end else
16420: GO 16556
// if Lisa and JMMGirl = 2 then
16422: LD_EXP 43
16426: PUSH
16427: LD_EXP 7
16431: PUSH
16432: LD_INT 2
16434: EQUAL
16435: AND
16436: IFFALSE 16490
// begin ComExitVehicle ( Lisa ) ;
16438: LD_EXP 43
16442: PPUSH
16443: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16447: LD_EXP 43
16451: PPUSH
16452: LD_INT 35
16454: PPUSH
16455: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16459: LD_EXP 43
16463: PPUSH
16464: LD_INT 65
16466: PPUSH
16467: LD_INT 104
16469: PPUSH
16470: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16474: LD_EXP 43
16478: PPUSH
16479: LD_EXP 40
16483: PPUSH
16484: CALL_OW 179
// end else
16488: GO 16556
// if Connie and JMMGirl = 3 then
16490: LD_EXP 55
16494: PUSH
16495: LD_EXP 7
16499: PUSH
16500: LD_INT 3
16502: EQUAL
16503: AND
16504: IFFALSE 16556
// begin ComExitVehicle ( Connie ) ;
16506: LD_EXP 55
16510: PPUSH
16511: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16515: LD_EXP 55
16519: PPUSH
16520: LD_INT 35
16522: PPUSH
16523: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16527: LD_EXP 55
16531: PPUSH
16532: LD_INT 65
16534: PPUSH
16535: LD_INT 104
16537: PPUSH
16538: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16542: LD_EXP 55
16546: PPUSH
16547: LD_EXP 40
16551: PPUSH
16552: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16556: LD_INT 35
16558: PPUSH
16559: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16563: LD_EXP 40
16567: PPUSH
16568: LD_EXP 59
16572: PPUSH
16573: CALL_OW 296
16577: PUSH
16578: LD_INT 8
16580: LESS
16581: IFFALSE 16556
// wait ( 0 0$0.5 ) ;
16583: LD_INT 18
16585: PPUSH
16586: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16590: LD_EXP 40
16594: PPUSH
16595: LD_STRING D1-JMM-1
16597: PPUSH
16598: CALL_OW 88
// async ;
16602: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16603: LD_EXP 59
16607: PPUSH
16608: LD_STRING D1-Pow-1
16610: PPUSH
16611: CALL_OW 88
// if not dialogue_skipped then
16615: LD_OWVAR 59
16619: NOT
16620: IFFALSE 16629
// wait ( 0 0$2 ) ;
16622: LD_INT 70
16624: PPUSH
16625: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
16629: LD_INT 170
16631: PPUSH
16632: LD_INT 99
16634: PPUSH
16635: LD_INT 1
16637: PPUSH
16638: LD_INT 6
16640: NEG
16641: PPUSH
16642: CALL 104585 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
16646: LD_INT 174
16648: PPUSH
16649: LD_INT 115
16651: PPUSH
16652: LD_INT 1
16654: PPUSH
16655: LD_INT 6
16657: NEG
16658: PPUSH
16659: CALL 104585 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
16663: LD_INT 169
16665: PPUSH
16666: LD_INT 71
16668: PPUSH
16669: LD_INT 1
16671: PPUSH
16672: LD_INT 6
16674: NEG
16675: PPUSH
16676: CALL 104585 0 4
// if not dialogue_skipped then
16680: LD_OWVAR 59
16684: NOT
16685: IFFALSE 16704
// begin CenterOnXY ( 170 , 99 ) ;
16687: LD_INT 170
16689: PPUSH
16690: LD_INT 99
16692: PPUSH
16693: CALL_OW 84
// wait ( 0 0$2.3 ) ;
16697: LD_INT 80
16699: PPUSH
16700: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
16704: LD_INT 75
16706: PPUSH
16707: LD_INT 53
16709: PPUSH
16710: LD_INT 1
16712: PPUSH
16713: LD_INT 9
16715: NEG
16716: PPUSH
16717: CALL 104585 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
16721: LD_INT 54
16723: PPUSH
16724: LD_INT 42
16726: PPUSH
16727: LD_INT 1
16729: PPUSH
16730: LD_INT 9
16732: NEG
16733: PPUSH
16734: CALL 104585 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
16738: LD_INT 62
16740: PPUSH
16741: LD_INT 51
16743: PPUSH
16744: LD_INT 1
16746: PPUSH
16747: LD_INT 9
16749: NEG
16750: PPUSH
16751: CALL 104585 0 4
// if not dialogue_skipped then
16755: LD_OWVAR 59
16759: NOT
16760: IFFALSE 16779
// begin CenterOnXY ( 75 , 53 ) ;
16762: LD_INT 75
16764: PPUSH
16765: LD_INT 53
16767: PPUSH
16768: CALL_OW 84
// wait ( 0 0$4 ) ;
16772: LD_INT 140
16774: PPUSH
16775: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
16779: LD_EXP 59
16783: PPUSH
16784: CALL_OW 87
// if not dialogue_skipped then
16788: LD_OWVAR 59
16792: NOT
16793: IFFALSE 16802
// wait ( 0 0$2 ) ;
16795: LD_INT 70
16797: PPUSH
16798: CALL_OW 67
// sync ;
16802: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16803: LD_EXP 40
16807: PPUSH
16808: LD_STRING D1-JMM-2
16810: PPUSH
16811: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16815: LD_EXP 59
16819: PPUSH
16820: LD_STRING D1-Pow-2
16822: PPUSH
16823: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16827: LD_EXP 40
16831: PPUSH
16832: LD_STRING D1-JMM-3
16834: PPUSH
16835: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16839: LD_EXP 59
16843: PPUSH
16844: LD_STRING D1-Pow-3
16846: PPUSH
16847: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16851: LD_EXP 40
16855: PPUSH
16856: LD_STRING D1-JMM-4
16858: PPUSH
16859: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16863: LD_EXP 59
16867: PPUSH
16868: LD_STRING D1-Pow-4
16870: PPUSH
16871: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16875: LD_EXP 40
16879: PPUSH
16880: LD_STRING D1-JMM-5
16882: PPUSH
16883: CALL_OW 88
// async ;
16887: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16888: LD_EXP 59
16892: PPUSH
16893: LD_STRING D1-Pow-5
16895: PPUSH
16896: CALL_OW 88
// if not dialogue_skipped then
16900: LD_OWVAR 59
16904: NOT
16905: IFFALSE 16914
// wait ( 0 0$3.6 ) ;
16907: LD_INT 126
16909: PPUSH
16910: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16914: LD_INT 134
16916: PPUSH
16917: LD_INT 210
16919: PPUSH
16920: LD_INT 1
16922: PPUSH
16923: LD_INT 11
16925: NEG
16926: PPUSH
16927: CALL 104585 0 4
// if not dialogue_skipped then
16931: LD_OWVAR 59
16935: NOT
16936: IFFALSE 16955
// begin CenterOnXY ( 134 , 210 ) ;
16938: LD_INT 134
16940: PPUSH
16941: LD_INT 210
16943: PPUSH
16944: CALL_OW 84
// wait ( 0 0$2 ) ;
16948: LD_INT 70
16950: PPUSH
16951: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16955: LD_INT 101
16957: PPUSH
16958: LD_INT 159
16960: PPUSH
16961: LD_INT 1
16963: PPUSH
16964: LD_INT 10
16966: NEG
16967: PPUSH
16968: CALL 104585 0 4
// if not dialogue_skipped then
16972: LD_OWVAR 59
16976: NOT
16977: IFFALSE 16996
// begin CenterOnXY ( 101 , 159 ) ;
16979: LD_INT 101
16981: PPUSH
16982: LD_INT 159
16984: PPUSH
16985: CALL_OW 84
// wait ( 0 0$2 ) ;
16989: LD_INT 70
16991: PPUSH
16992: CALL_OW 67
// end ; sync ;
16996: SYNC
// CenterNowOnUnits ( Powell ) ;
16997: LD_EXP 59
17001: PPUSH
17002: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17006: LD_ADDR_VAR 0 6
17010: PUSH
17011: LD_INT 1
17013: PUSH
17014: LD_INT 2
17016: PUSH
17017: LD_INT 3
17019: PUSH
17020: LD_INT 4
17022: PUSH
17023: LD_INT 5
17025: PUSH
17026: LD_INT 6
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: LIST
17033: LIST
17034: LIST
17035: LIST
17036: ST_TO_ADDR
// if not dialogue_skipped then
17037: LD_OWVAR 59
17041: NOT
17042: IFFALSE 17211
// begin game_speed := 4 ;
17044: LD_ADDR_OWVAR 65
17048: PUSH
17049: LD_INT 4
17051: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17052: LD_INT 210
17054: PPUSH
17055: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17059: LD_ADDR_VAR 0 7
17063: PUSH
17064: LD_STRING Q1
17066: PPUSH
17067: LD_VAR 0 6
17071: PPUSH
17072: CALL_OW 98
17076: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17077: LD_ADDR_VAR 0 7
17081: PUSH
17082: LD_STRING Q1
17084: PPUSH
17085: LD_VAR 0 6
17089: PPUSH
17090: CALL_OW 98
17094: ST_TO_ADDR
// options := options diff dec ;
17095: LD_ADDR_VAR 0 6
17099: PUSH
17100: LD_VAR 0 6
17104: PUSH
17105: LD_VAR 0 7
17109: DIFF
17110: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17111: LD_VAR 0 7
17115: PPUSH
17116: LD_VAR 0 6
17120: PPUSH
17121: CALL 18727 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17125: LD_VAR 0 7
17129: PUSH
17130: LD_INT 5
17132: PUSH
17133: LD_INT 6
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: IN
17140: PUSH
17141: LD_VAR 0 6
17145: PUSH
17146: LD_INT 2
17148: EQUAL
17149: OR
17150: IFFALSE 17077
// if not ( dec in [ 5 , 6 ] ) then
17152: LD_VAR 0 7
17156: PUSH
17157: LD_INT 5
17159: PUSH
17160: LD_INT 6
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: IN
17167: NOT
17168: IFFALSE 17211
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17170: LD_ADDR_VAR 0 7
17174: PUSH
17175: LD_STRING Q1a
17177: PPUSH
17178: LD_INT 1
17180: PUSH
17181: LD_INT 2
17183: PUSH
17184: EMPTY
17185: LIST
17186: LIST
17187: PPUSH
17188: CALL_OW 98
17192: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17193: LD_VAR 0 7
17197: PUSH
17198: LD_INT 4
17200: PLUS
17201: PPUSH
17202: LD_VAR 0 6
17206: PPUSH
17207: CALL 18727 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17211: LD_INT 81
17213: PPUSH
17214: LD_INT 127
17216: PPUSH
17217: CALL_OW 84
// amount := 8 ;
17221: LD_ADDR_VAR 0 8
17225: PUSH
17226: LD_INT 8
17228: ST_TO_ADDR
// macmilan_squad := [ ] ;
17229: LD_ADDR_VAR 0 9
17233: PUSH
17234: EMPTY
17235: ST_TO_ADDR
// if vip < amount then
17236: LD_EXP 60
17240: PUSH
17241: LD_VAR 0 8
17245: LESS
17246: IFFALSE 17290
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17248: LD_ADDR_VAR 0 5
17252: PUSH
17253: LD_EXP 60
17257: PUSH
17258: LD_INT 22
17260: PUSH
17261: LD_INT 4
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: PUSH
17268: LD_INT 21
17270: PUSH
17271: LD_INT 1
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: PPUSH
17282: CALL_OW 69
17286: UNION
17287: ST_TO_ADDR
17288: GO 17300
// tmp := vip ;
17290: LD_ADDR_VAR 0 5
17294: PUSH
17295: LD_EXP 60
17299: ST_TO_ADDR
// tmp := tmp diff Powell ;
17300: LD_ADDR_VAR 0 5
17304: PUSH
17305: LD_VAR 0 5
17309: PUSH
17310: LD_EXP 59
17314: DIFF
17315: ST_TO_ADDR
// if tmp < amount then
17316: LD_VAR 0 5
17320: PUSH
17321: LD_VAR 0 8
17325: LESS
17326: IFFALSE 17338
// amount := tmp ;
17328: LD_ADDR_VAR 0 8
17332: PUSH
17333: LD_VAR 0 5
17337: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17338: LD_VAR 0 5
17342: PUSH
17343: LD_INT 1
17345: ARRAY
17346: PPUSH
17347: CALL_OW 257
17351: PUSH
17352: LD_INT 2
17354: NONEQUAL
17355: IFFALSE 17453
// begin if IsInUnit ( tmp [ 1 ] ) then
17357: LD_VAR 0 5
17361: PUSH
17362: LD_INT 1
17364: ARRAY
17365: PPUSH
17366: CALL_OW 310
17370: IFFALSE 17385
// ComExitBuilding ( tmp [ 1 ] ) ;
17372: LD_VAR 0 5
17376: PUSH
17377: LD_INT 1
17379: ARRAY
17380: PPUSH
17381: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17385: LD_INT 387
17387: PPUSH
17388: CALL_OW 313
17392: PUSH
17393: LD_INT 6
17395: EQUAL
17396: IFFALSE 17421
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17398: LD_INT 387
17400: PPUSH
17401: CALL_OW 313
17405: PUSH
17406: LD_INT 1
17408: ARRAY
17409: PPUSH
17410: CALL_OW 122
// wait ( 3 ) ;
17414: LD_INT 3
17416: PPUSH
17417: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17421: LD_VAR 0 5
17425: PUSH
17426: LD_INT 1
17428: ARRAY
17429: PPUSH
17430: LD_INT 387
17432: PPUSH
17433: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17437: LD_VAR 0 5
17441: PUSH
17442: LD_INT 1
17444: ARRAY
17445: PPUSH
17446: LD_INT 2
17448: PPUSH
17449: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17453: LD_EXP 40
17457: PPUSH
17458: LD_INT 82
17460: PPUSH
17461: LD_INT 129
17463: PPUSH
17464: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17468: LD_EXP 40
17472: PPUSH
17473: LD_EXP 59
17477: PPUSH
17478: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17482: LD_INT 22
17484: PUSH
17485: LD_INT 1
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PPUSH
17492: CALL_OW 69
17496: PUSH
17497: LD_EXP 40
17501: DIFF
17502: PPUSH
17503: LD_INT 84
17505: PPUSH
17506: LD_INT 128
17508: PPUSH
17509: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17513: LD_INT 22
17515: PUSH
17516: LD_INT 1
17518: PUSH
17519: EMPTY
17520: LIST
17521: LIST
17522: PPUSH
17523: CALL_OW 69
17527: PUSH
17528: LD_EXP 40
17532: DIFF
17533: PPUSH
17534: LD_EXP 40
17538: PPUSH
17539: CALL_OW 179
// for i = 1 to amount do
17543: LD_ADDR_VAR 0 2
17547: PUSH
17548: DOUBLE
17549: LD_INT 1
17551: DEC
17552: ST_TO_ADDR
17553: LD_VAR 0 8
17557: PUSH
17558: FOR_TO
17559: IFFALSE 17727
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17561: LD_ADDR_VAR 0 9
17565: PUSH
17566: LD_VAR 0 9
17570: PUSH
17571: LD_VAR 0 5
17575: PUSH
17576: LD_VAR 0 2
17580: ARRAY
17581: ADD
17582: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17583: LD_VAR 0 5
17587: PUSH
17588: LD_VAR 0 2
17592: ARRAY
17593: PPUSH
17594: CALL_OW 310
17598: IFFALSE 17615
// AddComExitBuilding ( tmp [ i ] ) ;
17600: LD_VAR 0 5
17604: PUSH
17605: LD_VAR 0 2
17609: ARRAY
17610: PPUSH
17611: CALL_OW 182
// if i = 2 and JMMNewVeh then
17615: LD_VAR 0 2
17619: PUSH
17620: LD_INT 2
17622: EQUAL
17623: PUSH
17624: LD_EXP 57
17628: AND
17629: IFFALSE 17687
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
17631: LD_VAR 0 5
17635: PUSH
17636: LD_VAR 0 2
17640: ARRAY
17641: PPUSH
17642: LD_EXP 57
17646: PPUSH
17647: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
17651: LD_VAR 0 5
17655: PUSH
17656: LD_VAR 0 2
17660: ARRAY
17661: PPUSH
17662: LD_INT 86
17664: PPUSH
17665: LD_INT 133
17667: PPUSH
17668: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
17672: LD_VAR 0 5
17676: PUSH
17677: LD_VAR 0 2
17681: ARRAY
17682: PPUSH
17683: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
17687: LD_VAR 0 5
17691: PUSH
17692: LD_VAR 0 2
17696: ARRAY
17697: PPUSH
17698: LD_INT 8
17700: PPUSH
17701: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
17705: LD_VAR 0 5
17709: PUSH
17710: LD_VAR 0 2
17714: ARRAY
17715: PPUSH
17716: LD_EXP 40
17720: PPUSH
17721: CALL_OW 179
// end ;
17725: GO 17558
17727: POP
17728: POP
// if GirlNewVeh then
17729: LD_EXP 58
17733: IFFALSE 17747
// SetSide ( GirlNewVeh , 4 ) ;
17735: LD_EXP 58
17739: PPUSH
17740: LD_INT 4
17742: PPUSH
17743: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
17747: LD_INT 35
17749: PPUSH
17750: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
17754: LD_VAR 0 9
17758: PPUSH
17759: LD_INT 95
17761: PUSH
17762: LD_INT 9
17764: PUSH
17765: EMPTY
17766: LIST
17767: LIST
17768: PPUSH
17769: CALL_OW 72
17773: PUSH
17774: LD_INT 0
17776: EQUAL
17777: PUSH
17778: LD_EXP 40
17782: PPUSH
17783: LD_INT 9
17785: PPUSH
17786: CALL_OW 308
17790: NOT
17791: AND
17792: IFFALSE 17747
// wait ( 0 0$2 ) ;
17794: LD_INT 70
17796: PPUSH
17797: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
17801: LD_VAR 0 9
17805: PPUSH
17806: LD_INT 1
17808: PPUSH
17809: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
17813: LD_INT 21
17815: PUSH
17816: LD_INT 2
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: LD_INT 92
17825: PUSH
17826: LD_INT 83
17828: PUSH
17829: LD_INT 130
17831: PUSH
17832: LD_INT 10
17834: PUSH
17835: EMPTY
17836: LIST
17837: LIST
17838: LIST
17839: LIST
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: PPUSH
17845: CALL_OW 69
17849: PPUSH
17850: LD_INT 1
17852: PPUSH
17853: CALL_OW 235
// tick := 0 ;
17857: LD_ADDR_OWVAR 1
17861: PUSH
17862: LD_INT 0
17864: ST_TO_ADDR
// Video ( false ) ;
17865: LD_INT 0
17867: PPUSH
17868: CALL 104671 0 1
// ChangeMissionObjectives ( M1 ) ;
17872: LD_STRING M1
17874: PPUSH
17875: CALL_OW 337
// SaveForQuickRestart ;
17879: CALL_OW 22
// missionStart := true ;
17883: LD_ADDR_EXP 13
17887: PUSH
17888: LD_INT 1
17890: ST_TO_ADDR
// missionStage := 2 ;
17891: LD_ADDR_EXP 15
17895: PUSH
17896: LD_INT 2
17898: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17899: LD_INT 35
17901: PPUSH
17902: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17906: LD_ADDR_VAR 0 5
17910: PUSH
17911: LD_INT 22
17913: PUSH
17914: LD_INT 4
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: PUSH
17921: LD_INT 21
17923: PUSH
17924: LD_INT 1
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: PUSH
17931: EMPTY
17932: LIST
17933: LIST
17934: PPUSH
17935: CALL_OW 69
17939: PUSH
17940: LD_EXP 59
17944: DIFF
17945: ST_TO_ADDR
// if not tmp then
17946: LD_VAR 0 5
17950: NOT
17951: IFFALSE 17966
// tmp := [ Powell ] ;
17953: LD_ADDR_VAR 0 5
17957: PUSH
17958: LD_EXP 59
17962: PUSH
17963: EMPTY
17964: LIST
17965: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17966: LD_ADDR_VAR 0 4
17970: PUSH
17971: LD_INT 22
17973: PUSH
17974: LD_INT 4
17976: PUSH
17977: EMPTY
17978: LIST
17979: LIST
17980: PUSH
17981: LD_INT 34
17983: PUSH
17984: LD_INT 12
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PPUSH
17995: CALL_OW 69
17999: PUSH
18000: LD_INT 1
18002: ARRAY
18003: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18004: LD_VAR 0 5
18008: PUSH
18009: LD_INT 1
18011: ARRAY
18012: PPUSH
18013: CALL_OW 310
18017: IFFALSE 18032
// ComExitBuilding ( tmp [ 1 ] ) ;
18019: LD_VAR 0 5
18023: PUSH
18024: LD_INT 1
18026: ARRAY
18027: PPUSH
18028: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18032: LD_VAR 0 5
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: LD_VAR 0 4
18045: PPUSH
18046: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18050: LD_VAR 0 5
18054: PUSH
18055: LD_INT 1
18057: ARRAY
18058: PPUSH
18059: LD_INT 80
18061: PPUSH
18062: LD_INT 136
18064: PPUSH
18065: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18069: LD_VAR 0 5
18073: PUSH
18074: LD_INT 1
18076: ARRAY
18077: PPUSH
18078: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18082: LD_VAR 0 5
18086: PUSH
18087: LD_INT 1
18089: ARRAY
18090: PPUSH
18091: LD_INT 59
18093: PPUSH
18094: LD_INT 112
18096: PPUSH
18097: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18101: LD_VAR 0 5
18105: PUSH
18106: LD_INT 1
18108: ARRAY
18109: PPUSH
18110: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18114: LD_EXP 41
18118: PUSH
18119: LD_EXP 41
18123: PPUSH
18124: CALL_OW 255
18128: PUSH
18129: LD_INT 1
18131: EQUAL
18132: AND
18133: IFFALSE 18159
// begin Say ( Joan , D3W-Joan-1 ) ;
18135: LD_EXP 41
18139: PPUSH
18140: LD_STRING D3W-Joan-1
18142: PPUSH
18143: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18147: LD_EXP 40
18151: PPUSH
18152: LD_STRING D3W-JMM-1
18154: PPUSH
18155: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18159: LD_EXP 43
18163: PUSH
18164: LD_EXP 43
18168: PPUSH
18169: CALL_OW 255
18173: PUSH
18174: LD_INT 1
18176: EQUAL
18177: AND
18178: PUSH
18179: LD_EXP 43
18183: PUSH
18184: LD_EXP 60
18188: IN
18189: NOT
18190: AND
18191: IFFALSE 18217
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18193: LD_EXP 43
18197: PPUSH
18198: LD_STRING D3W-Lisa-1
18200: PPUSH
18201: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18205: LD_EXP 40
18209: PPUSH
18210: LD_STRING D3W-JMM-1
18212: PPUSH
18213: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18217: LD_EXP 55
18221: PUSH
18222: LD_EXP 55
18226: PPUSH
18227: CALL_OW 255
18231: PUSH
18232: LD_INT 1
18234: EQUAL
18235: AND
18236: IFFALSE 18262
// begin Say ( Connie , D3W-Con-1 ) ;
18238: LD_EXP 55
18242: PPUSH
18243: LD_STRING D3W-Con-1
18245: PPUSH
18246: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18250: LD_EXP 40
18254: PPUSH
18255: LD_STRING D3W-JMM-1
18257: PPUSH
18258: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
18262: LD_EXP 43
18266: PUSH
18267: LD_EXP 60
18271: IN
18272: PUSH
18273: LD_EXP 43
18277: PPUSH
18278: CALL_OW 255
18282: PUSH
18283: LD_INT 1
18285: EQUAL
18286: AND
18287: IFFALSE 18303
// Say ( Lisa , D3nW-Lisa-1 ) else
18289: LD_EXP 43
18293: PPUSH
18294: LD_STRING D3nW-Lisa-1
18296: PPUSH
18297: CALL_OW 88
18301: GO 18547
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18303: LD_EXP 46
18307: PUSH
18308: LD_EXP 60
18312: IN
18313: PUSH
18314: LD_EXP 46
18318: PPUSH
18319: CALL_OW 255
18323: PUSH
18324: LD_INT 1
18326: EQUAL
18327: AND
18328: IFFALSE 18344
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18330: LD_EXP 46
18334: PPUSH
18335: LD_STRING D3nW-Cyrus-1
18337: PPUSH
18338: CALL_OW 88
18342: GO 18547
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18344: LD_EXP 45
18348: PUSH
18349: LD_EXP 60
18353: IN
18354: PUSH
18355: LD_EXP 45
18359: PPUSH
18360: CALL_OW 255
18364: PUSH
18365: LD_INT 1
18367: EQUAL
18368: AND
18369: IFFALSE 18385
// Say ( Bobby , D3nW-Bobby-1 ) else
18371: LD_EXP 45
18375: PPUSH
18376: LD_STRING D3nW-Bobby-1
18378: PPUSH
18379: CALL_OW 88
18383: GO 18547
// if Gary in vip and GetSide ( Gary ) = 1 then
18385: LD_EXP 52
18389: PUSH
18390: LD_EXP 60
18394: IN
18395: PUSH
18396: LD_EXP 52
18400: PPUSH
18401: CALL_OW 255
18405: PUSH
18406: LD_INT 1
18408: EQUAL
18409: AND
18410: IFFALSE 18426
// Say ( Gary , D3nW-Gary-1 ) else
18412: LD_EXP 52
18416: PPUSH
18417: LD_STRING D3nW-Gary-1
18419: PPUSH
18420: CALL_OW 88
18424: GO 18547
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18426: LD_EXP 44
18430: PUSH
18431: LD_EXP 60
18435: IN
18436: PUSH
18437: LD_EXP 44
18441: PPUSH
18442: CALL_OW 255
18446: PUSH
18447: LD_INT 1
18449: EQUAL
18450: AND
18451: IFFALSE 18467
// Say ( Donaldson , D3nW-Don-1 ) else
18453: LD_EXP 44
18457: PPUSH
18458: LD_STRING D3nW-Don-1
18460: PPUSH
18461: CALL_OW 88
18465: GO 18547
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18467: LD_EXP 51
18471: PUSH
18472: LD_EXP 60
18476: IN
18477: PUSH
18478: LD_EXP 51
18482: PPUSH
18483: CALL_OW 255
18487: PUSH
18488: LD_INT 1
18490: EQUAL
18491: AND
18492: IFFALSE 18508
// Say ( Cornel , D3nW-Corn-1 ) else
18494: LD_EXP 51
18498: PPUSH
18499: LD_STRING D3nW-Corn-1
18501: PPUSH
18502: CALL_OW 88
18506: GO 18547
// if Frank in vip and GetSide ( Frank ) = 1 then
18508: LD_EXP 53
18512: PUSH
18513: LD_EXP 60
18517: IN
18518: PUSH
18519: LD_EXP 53
18523: PPUSH
18524: CALL_OW 255
18528: PUSH
18529: LD_INT 1
18531: EQUAL
18532: AND
18533: IFFALSE 18547
// Say ( Frank , D3nW-Frank-1 ) ;
18535: LD_EXP 53
18539: PPUSH
18540: LD_STRING D3nW-Frank-1
18542: PPUSH
18543: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18547: LD_EXP 60
18551: PPUSH
18552: LD_INT 22
18554: PUSH
18555: LD_INT 1
18557: PUSH
18558: EMPTY
18559: LIST
18560: LIST
18561: PPUSH
18562: CALL_OW 72
18566: IFFALSE 18592
// begin Say ( JMM , D3nW-JMM-1 ) ;
18568: LD_EXP 40
18572: PPUSH
18573: LD_STRING D3nW-JMM-1
18575: PPUSH
18576: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
18580: LD_EXP 40
18584: PPUSH
18585: LD_STRING D3nW-JMM-1a
18587: PPUSH
18588: CALL_OW 88
// end ; t := 0 0$00 ;
18592: LD_ADDR_VAR 0 3
18596: PUSH
18597: LD_INT 0
18599: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18600: LD_INT 35
18602: PPUSH
18603: CALL_OW 67
// t := t + 0 0$1 ;
18607: LD_ADDR_VAR 0 3
18611: PUSH
18612: LD_VAR 0 3
18616: PUSH
18617: LD_INT 35
18619: PLUS
18620: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
18621: LD_INT 59
18623: PPUSH
18624: LD_INT 112
18626: PPUSH
18627: CALL_OW 428
18631: PUSH
18632: LD_VAR 0 3
18636: PUSH
18637: LD_INT 2100
18639: GREATER
18640: OR
18641: IFFALSE 18600
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
18643: LD_ADDR_EXP 99
18647: PUSH
18648: LD_EXP 99
18652: PPUSH
18653: LD_INT 4
18655: PPUSH
18656: LD_INT 22
18658: PUSH
18659: LD_INT 4
18661: PUSH
18662: EMPTY
18663: LIST
18664: LIST
18665: PUSH
18666: LD_INT 23
18668: PUSH
18669: LD_INT 1
18671: PUSH
18672: EMPTY
18673: LIST
18674: LIST
18675: PUSH
18676: LD_INT 3
18678: PUSH
18679: LD_INT 21
18681: PUSH
18682: LD_INT 2
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: LIST
18697: PPUSH
18698: CALL_OW 69
18702: PUSH
18703: LD_EXP 59
18707: DIFF
18708: PPUSH
18709: CALL_OW 1
18713: ST_TO_ADDR
// activeAttacks := true ;
18714: LD_ADDR_EXP 16
18718: PUSH
18719: LD_INT 1
18721: ST_TO_ADDR
// end ;
18722: LD_VAR 0 1
18726: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
18727: LD_INT 0
18729: PPUSH
// case question of 1 :
18730: LD_VAR 0 1
18734: PUSH
18735: LD_INT 1
18737: DOUBLE
18738: EQUAL
18739: IFTRUE 18743
18741: GO 18794
18743: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
18744: LD_EXP 40
18748: PPUSH
18749: LD_STRING D2Mot-JMM-1
18751: PPUSH
18752: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
18756: LD_EXP 59
18760: PPUSH
18761: LD_STRING D2Mot-Pow-1
18763: PPUSH
18764: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
18768: LD_EXP 40
18772: PPUSH
18773: LD_STRING D2Mot-JMM-2
18775: PPUSH
18776: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
18780: LD_EXP 59
18784: PPUSH
18785: LD_STRING D2Mot-Pow-2
18787: PPUSH
18788: CALL_OW 88
// end ; 2 :
18792: GO 19145
18794: LD_INT 2
18796: DOUBLE
18797: EQUAL
18798: IFTRUE 18802
18800: GO 18878
18802: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
18803: LD_EXP 40
18807: PPUSH
18808: LD_STRING D2Rus-JMM-1
18810: PPUSH
18811: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
18815: LD_EXP 59
18819: PPUSH
18820: LD_STRING D2Rus-Pow-1
18822: PPUSH
18823: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
18827: LD_EXP 40
18831: PPUSH
18832: LD_STRING D2Rus-JMM-2
18834: PPUSH
18835: CALL_OW 88
// if not ( 3 in list_of_q ) then
18839: LD_INT 3
18841: PUSH
18842: LD_VAR 0 2
18846: IN
18847: NOT
18848: IFFALSE 18864
// Say ( Powell , D2Rus-Pow-2 ) else
18850: LD_EXP 59
18854: PPUSH
18855: LD_STRING D2Rus-Pow-2
18857: PPUSH
18858: CALL_OW 88
18862: GO 18876
// Say ( Powell , D2Rus-Pow-2a ) ;
18864: LD_EXP 59
18868: PPUSH
18869: LD_STRING D2Rus-Pow-2a
18871: PPUSH
18872: CALL_OW 88
// end ; 3 :
18876: GO 19145
18878: LD_INT 3
18880: DOUBLE
18881: EQUAL
18882: IFTRUE 18886
18884: GO 18971
18886: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18887: LD_EXP 40
18891: PPUSH
18892: LD_STRING D2Leg-JMM-1
18894: PPUSH
18895: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18899: LD_EXP 59
18903: PPUSH
18904: LD_STRING D2Leg-Pow-1
18906: PPUSH
18907: CALL_OW 88
// if 2 in list_of_q then
18911: LD_INT 2
18913: PUSH
18914: LD_VAR 0 2
18918: IN
18919: IFFALSE 18945
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18921: LD_EXP 40
18925: PPUSH
18926: LD_STRING D2Leg-JMM-2
18928: PPUSH
18929: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18933: LD_EXP 59
18937: PPUSH
18938: LD_STRING D2Leg-Pow-2
18940: PPUSH
18941: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18945: LD_EXP 40
18949: PPUSH
18950: LD_STRING D2Leg-JMM-3
18952: PPUSH
18953: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18957: LD_EXP 59
18961: PPUSH
18962: LD_STRING D2Leg-Pow-3
18964: PPUSH
18965: CALL_OW 88
// end ; 4 :
18969: GO 19145
18971: LD_INT 4
18973: DOUBLE
18974: EQUAL
18975: IFTRUE 18979
18977: GO 19054
18979: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18980: LD_EXP 40
18984: PPUSH
18985: LD_STRING D2Ar-JMM-1
18987: PPUSH
18988: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18992: LD_EXP 59
18996: PPUSH
18997: LD_STRING D2Ar-Pow-1
18999: PPUSH
19000: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19004: LD_EXP 40
19008: PPUSH
19009: LD_STRING D2Ar-JMM-2
19011: PPUSH
19012: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19016: LD_EXP 59
19020: PPUSH
19021: LD_STRING D2Ar-Pow-2
19023: PPUSH
19024: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19028: LD_EXP 40
19032: PPUSH
19033: LD_STRING D2Ar-JMM-3
19035: PPUSH
19036: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19040: LD_EXP 59
19044: PPUSH
19045: LD_STRING D2Ar-Pow-3
19047: PPUSH
19048: CALL_OW 88
// end ; 5 :
19052: GO 19145
19054: LD_INT 5
19056: DOUBLE
19057: EQUAL
19058: IFTRUE 19062
19060: GO 19077
19062: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19063: LD_EXP 40
19067: PPUSH
19068: LD_STRING D2Conf-JMM-1
19070: PPUSH
19071: CALL_OW 88
19075: GO 19145
19077: LD_INT 6
19079: DOUBLE
19080: EQUAL
19081: IFTRUE 19085
19083: GO 19144
19085: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19086: LD_EXP 40
19090: PPUSH
19091: LD_STRING D2Com-JMM-1
19093: PPUSH
19094: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19098: LD_EXP 59
19102: PPUSH
19103: LD_STRING D2Com-Pow-1
19105: PPUSH
19106: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19110: LD_EXP 40
19114: PPUSH
19115: LD_STRING D2Com-JMM-2
19117: PPUSH
19118: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19122: LD_EXP 59
19126: PPUSH
19127: LD_STRING D2Com-Pow-2
19129: PPUSH
19130: CALL_OW 88
// powellAngerQuery := true ;
19134: LD_ADDR_EXP 36
19138: PUSH
19139: LD_INT 1
19141: ST_TO_ADDR
// end ; end ;
19142: GO 19145
19144: POP
// end ;
19145: LD_VAR 0 3
19149: RET
// every 0 0$5 trigger missionStart do var tmp ;
19150: LD_EXP 13
19154: IFFALSE 19437
19156: GO 19158
19158: DISABLE
19159: LD_INT 0
19161: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19162: LD_INT 35
19164: PPUSH
19165: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19169: LD_INT 14
19171: PPUSH
19172: LD_INT 22
19174: PUSH
19175: LD_INT 1
19177: PUSH
19178: EMPTY
19179: LIST
19180: LIST
19181: PPUSH
19182: CALL_OW 70
19186: PUSH
19187: LD_EXP 15
19191: PUSH
19192: LD_INT 2
19194: PUSH
19195: LD_INT 3
19197: PUSH
19198: LD_INT 4
19200: PUSH
19201: LD_INT 5
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: LIST
19208: LIST
19209: IN
19210: AND
19211: IFFALSE 19427
// begin powellAnger := powellAnger + 1 ;
19213: LD_ADDR_EXP 17
19217: PUSH
19218: LD_EXP 17
19222: PUSH
19223: LD_INT 1
19225: PLUS
19226: ST_TO_ADDR
// Video ( true ) ;
19227: LD_INT 1
19229: PPUSH
19230: CALL 104671 0 1
// CenterNowOnUnits ( tmp ) ;
19234: LD_VAR 0 1
19238: PPUSH
19239: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19243: LD_INT 14
19245: PPUSH
19246: LD_INT 22
19248: PUSH
19249: LD_INT 1
19251: PUSH
19252: EMPTY
19253: LIST
19254: LIST
19255: PPUSH
19256: CALL_OW 70
19260: PPUSH
19261: LD_INT 86
19263: PPUSH
19264: LD_INT 133
19266: PPUSH
19267: CALL_OW 111
// async ;
19271: ASYNC
// case powellAnger of 1 :
19272: LD_EXP 17
19276: PUSH
19277: LD_INT 1
19279: DOUBLE
19280: EQUAL
19281: IFTRUE 19285
19283: GO 19300
19285: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19286: LD_EXP 59
19290: PPUSH
19291: LD_STRING DBack1-Pow-1
19293: PPUSH
19294: CALL_OW 88
19298: GO 19347
19300: LD_INT 2
19302: DOUBLE
19303: EQUAL
19304: IFTRUE 19308
19306: GO 19323
19308: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19309: LD_EXP 59
19313: PPUSH
19314: LD_STRING DBack2-Pow-1
19316: PPUSH
19317: CALL_OW 88
19321: GO 19347
19323: LD_INT 3
19325: DOUBLE
19326: EQUAL
19327: IFTRUE 19331
19329: GO 19346
19331: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19332: LD_EXP 59
19336: PPUSH
19337: LD_STRING DBack3-Pow-1
19339: PPUSH
19340: CALL_OW 88
19344: GO 19347
19346: POP
// sync ;
19347: SYNC
// repeat wait ( 0 0$1 ) ;
19348: LD_INT 35
19350: PPUSH
19351: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19355: LD_INT 14
19357: PPUSH
19358: LD_INT 22
19360: PUSH
19361: LD_INT 1
19363: PUSH
19364: EMPTY
19365: LIST
19366: LIST
19367: PPUSH
19368: CALL_OW 70
19372: PPUSH
19373: LD_INT 86
19375: PPUSH
19376: LD_INT 133
19378: PPUSH
19379: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19383: LD_INT 14
19385: PPUSH
19386: LD_INT 22
19388: PUSH
19389: LD_INT 1
19391: PUSH
19392: EMPTY
19393: LIST
19394: LIST
19395: PPUSH
19396: CALL_OW 70
19400: NOT
19401: IFFALSE 19348
// if powellAnger >= 3 then
19403: LD_EXP 17
19407: PUSH
19408: LD_INT 3
19410: GREATEREQUAL
19411: IFFALSE 19420
// YouLost ( Dismissed ) ;
19413: LD_STRING Dismissed
19415: PPUSH
19416: CALL_OW 104
// Video ( false ) ;
19420: LD_INT 0
19422: PPUSH
19423: CALL 104671 0 1
// end ; until missionStage > 5 ;
19427: LD_EXP 15
19431: PUSH
19432: LD_INT 5
19434: GREATER
19435: IFFALSE 19162
// end ;
19437: PPOPN 1
19439: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19440: LD_EXP 13
19444: PUSH
19445: LD_INT 22
19447: PUSH
19448: LD_INT 4
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PUSH
19455: LD_INT 21
19457: PUSH
19458: LD_INT 2
19460: PUSH
19461: EMPTY
19462: LIST
19463: LIST
19464: PUSH
19465: EMPTY
19466: LIST
19467: LIST
19468: PPUSH
19469: CALL_OW 69
19473: PUSH
19474: LD_INT 4
19476: GREATEREQUAL
19477: AND
19478: PUSH
19479: LD_EXP 15
19483: PUSH
19484: LD_INT 2
19486: EQUAL
19487: AND
19488: IFFALSE 21678
19490: GO 19492
19492: DISABLE
19493: LD_INT 0
19495: PPUSH
19496: PPUSH
19497: PPUSH
19498: PPUSH
19499: PPUSH
19500: PPUSH
19501: PPUSH
19502: PPUSH
19503: PPUSH
19504: PPUSH
// begin missionStage := 3 ;
19505: LD_ADDR_EXP 15
19509: PUSH
19510: LD_INT 3
19512: ST_TO_ADDR
// retreat := false ;
19513: LD_ADDR_VAR 0 4
19517: PUSH
19518: LD_INT 0
19520: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19521: LD_ADDR_VAR 0 5
19525: PUSH
19526: LD_INT 22
19528: PUSH
19529: LD_INT 4
19531: PUSH
19532: EMPTY
19533: LIST
19534: LIST
19535: PUSH
19536: LD_INT 30
19538: PUSH
19539: LD_INT 4
19541: PUSH
19542: EMPTY
19543: LIST
19544: LIST
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: PPUSH
19550: CALL_OW 69
19554: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19555: LD_ADDR_VAR 0 6
19559: PUSH
19560: LD_INT 22
19562: PUSH
19563: LD_INT 4
19565: PUSH
19566: EMPTY
19567: LIST
19568: LIST
19569: PUSH
19570: LD_INT 30
19572: PUSH
19573: LD_INT 5
19575: PUSH
19576: EMPTY
19577: LIST
19578: LIST
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: PPUSH
19584: CALL_OW 69
19588: ST_TO_ADDR
// if not bar then
19589: LD_VAR 0 6
19593: NOT
19594: IFFALSE 19647
// begin repeat wait ( 0 0$1 ) ;
19596: LD_INT 35
19598: PPUSH
19599: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
19603: LD_INT 22
19605: PUSH
19606: LD_INT 4
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: PUSH
19613: LD_INT 3
19615: PUSH
19616: LD_INT 57
19618: PUSH
19619: EMPTY
19620: LIST
19621: PUSH
19622: EMPTY
19623: LIST
19624: LIST
19625: PUSH
19626: LD_INT 30
19628: PUSH
19629: LD_INT 5
19631: PUSH
19632: EMPTY
19633: LIST
19634: LIST
19635: PUSH
19636: EMPTY
19637: LIST
19638: LIST
19639: LIST
19640: PPUSH
19641: CALL_OW 69
19645: IFFALSE 19596
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19647: LD_ADDR_VAR 0 6
19651: PUSH
19652: LD_INT 22
19654: PUSH
19655: LD_INT 4
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: PUSH
19662: LD_INT 30
19664: PUSH
19665: LD_INT 5
19667: PUSH
19668: EMPTY
19669: LIST
19670: LIST
19671: PUSH
19672: EMPTY
19673: LIST
19674: LIST
19675: PPUSH
19676: CALL_OW 69
19680: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19681: LD_INT 35
19683: PPUSH
19684: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
19688: LD_EXP 118
19692: PUSH
19693: LD_INT 4
19695: ARRAY
19696: PUSH
19697: LD_INT 4
19699: GREATEREQUAL
19700: IFFALSE 19681
// tmp := [ ] ;
19702: LD_ADDR_VAR 0 2
19706: PUSH
19707: EMPTY
19708: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
19709: LD_ADDR_VAR 0 1
19713: PUSH
19714: LD_INT 22
19716: PUSH
19717: LD_INT 4
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: PUSH
19724: LD_INT 2
19726: PUSH
19727: LD_INT 25
19729: PUSH
19730: LD_INT 1
19732: PUSH
19733: EMPTY
19734: LIST
19735: LIST
19736: PUSH
19737: LD_INT 25
19739: PUSH
19740: LD_INT 2
19742: PUSH
19743: EMPTY
19744: LIST
19745: LIST
19746: PUSH
19747: LD_INT 25
19749: PUSH
19750: LD_INT 3
19752: PUSH
19753: EMPTY
19754: LIST
19755: LIST
19756: PUSH
19757: LD_INT 25
19759: PUSH
19760: LD_INT 4
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: PUSH
19767: LD_INT 25
19769: PUSH
19770: LD_INT 5
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: PUSH
19777: EMPTY
19778: LIST
19779: LIST
19780: LIST
19781: LIST
19782: LIST
19783: LIST
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PPUSH
19789: CALL_OW 69
19793: PUSH
19794: LD_EXP 59
19798: PUSH
19799: LD_EXP 60
19803: ADD
19804: DIFF
19805: PUSH
19806: FOR_IN
19807: IFFALSE 19871
// if GetTag ( i ) = 1 then
19809: LD_VAR 0 1
19813: PPUSH
19814: CALL_OW 110
19818: PUSH
19819: LD_INT 1
19821: EQUAL
19822: IFFALSE 19846
// tmp := Join ( tmp , i ) else
19824: LD_ADDR_VAR 0 2
19828: PUSH
19829: LD_VAR 0 2
19833: PPUSH
19834: LD_VAR 0 1
19838: PPUSH
19839: CALL 104699 0 2
19843: ST_TO_ADDR
19844: GO 19869
// tmp := Insert ( tmp , 1 , i ) ;
19846: LD_ADDR_VAR 0 2
19850: PUSH
19851: LD_VAR 0 2
19855: PPUSH
19856: LD_INT 1
19858: PPUSH
19859: LD_VAR 0 1
19863: PPUSH
19864: CALL_OW 2
19868: ST_TO_ADDR
19869: GO 19806
19871: POP
19872: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
19873: LD_ADDR_VAR 0 3
19877: PUSH
19878: LD_VAR 0 2
19882: PPUSH
19883: LD_INT 26
19885: PUSH
19886: LD_INT 1
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: PPUSH
19893: CALL_OW 72
19897: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
19898: LD_ADDR_VAR 0 2
19902: PUSH
19903: LD_VAR 0 2
19907: PUSH
19908: LD_VAR 0 3
19912: DIFF
19913: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
19914: LD_ADDR_VAR 0 2
19918: PUSH
19919: LD_VAR 0 2
19923: PPUSH
19924: LD_INT 3
19926: PPUSH
19927: CALL 103208 0 2
19931: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
19932: LD_ADDR_VAR 0 3
19936: PUSH
19937: LD_VAR 0 3
19941: PPUSH
19942: LD_INT 3
19944: PPUSH
19945: CALL 103208 0 2
19949: ST_TO_ADDR
// for i := 1 to 4 do
19950: LD_ADDR_VAR 0 1
19954: PUSH
19955: DOUBLE
19956: LD_INT 1
19958: DEC
19959: ST_TO_ADDR
19960: LD_INT 4
19962: PUSH
19963: FOR_TO
19964: IFFALSE 20117
// begin if tmp2 then
19966: LD_VAR 0 3
19970: IFFALSE 20038
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19972: LD_ADDR_EXP 18
19976: PUSH
19977: LD_EXP 18
19981: PPUSH
19982: LD_INT 1
19984: PPUSH
19985: LD_EXP 18
19989: PUSH
19990: LD_INT 1
19992: ARRAY
19993: PUSH
19994: LD_VAR 0 3
19998: PUSH
19999: LD_VAR 0 3
20003: ARRAY
20004: ADD
20005: PPUSH
20006: CALL_OW 1
20010: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20011: LD_VAR 0 3
20015: PUSH
20016: LD_VAR 0 3
20020: ARRAY
20021: PPUSH
20022: LD_INT 1
20024: PPUSH
20025: CALL_OW 109
// tmp2 := [ ] ;
20029: LD_ADDR_VAR 0 3
20033: PUSH
20034: EMPTY
20035: ST_TO_ADDR
// end else
20036: GO 20115
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20038: LD_ADDR_EXP 18
20042: PUSH
20043: LD_EXP 18
20047: PPUSH
20048: LD_INT 1
20050: PPUSH
20051: LD_EXP 18
20055: PUSH
20056: LD_INT 1
20058: ARRAY
20059: PUSH
20060: LD_VAR 0 2
20064: PUSH
20065: LD_VAR 0 2
20069: ARRAY
20070: ADD
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20077: LD_VAR 0 2
20081: PUSH
20082: LD_VAR 0 2
20086: ARRAY
20087: PPUSH
20088: LD_INT 1
20090: PPUSH
20091: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20095: LD_ADDR_VAR 0 2
20099: PUSH
20100: LD_VAR 0 2
20104: PPUSH
20105: LD_VAR 0 2
20109: PPUSH
20110: CALL_OW 3
20114: ST_TO_ADDR
// end ; end ;
20115: GO 19963
20117: POP
20118: POP
// if tmp2 then
20119: LD_VAR 0 3
20123: IFFALSE 20141
// tmp := tmp union tmp2 ;
20125: LD_ADDR_VAR 0 2
20129: PUSH
20130: LD_VAR 0 2
20134: PUSH
20135: LD_VAR 0 3
20139: UNION
20140: ST_TO_ADDR
// for i := 1 to 4 do
20141: LD_ADDR_VAR 0 1
20145: PUSH
20146: DOUBLE
20147: LD_INT 1
20149: DEC
20150: ST_TO_ADDR
20151: LD_INT 4
20153: PUSH
20154: FOR_TO
20155: IFFALSE 20204
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20157: LD_ADDR_EXP 18
20161: PUSH
20162: LD_EXP 18
20166: PPUSH
20167: LD_INT 2
20169: PPUSH
20170: LD_EXP 18
20174: PUSH
20175: LD_INT 2
20177: ARRAY
20178: PUSH
20179: LD_VAR 0 2
20183: PUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_VAR 0 1
20193: MINUS
20194: ARRAY
20195: ADD
20196: PPUSH
20197: CALL_OW 1
20201: ST_TO_ADDR
20202: GO 20154
20204: POP
20205: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20206: LD_ADDR_EXP 99
20210: PUSH
20211: LD_EXP 99
20215: PPUSH
20216: LD_INT 4
20218: PPUSH
20219: LD_EXP 99
20223: PUSH
20224: LD_INT 4
20226: ARRAY
20227: PUSH
20228: LD_EXP 18
20232: PUSH
20233: LD_INT 1
20235: ARRAY
20236: DIFF
20237: PPUSH
20238: CALL_OW 1
20242: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20243: LD_VAR 0 5
20247: PUSH
20248: LD_INT 1
20250: ARRAY
20251: PPUSH
20252: CALL_OW 313
20256: IFFALSE 20311
// begin for i in UnitsInside ( arm [ 1 ] ) do
20258: LD_ADDR_VAR 0 1
20262: PUSH
20263: LD_VAR 0 5
20267: PUSH
20268: LD_INT 1
20270: ARRAY
20271: PPUSH
20272: CALL_OW 313
20276: PUSH
20277: FOR_IN
20278: IFFALSE 20309
// begin ComExitBuilding ( i ) ;
20280: LD_VAR 0 1
20284: PPUSH
20285: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20289: LD_VAR 0 1
20293: PPUSH
20294: LD_VAR 0 6
20298: PUSH
20299: LD_INT 1
20301: ARRAY
20302: PPUSH
20303: CALL_OW 180
// end ;
20307: GO 20277
20309: POP
20310: POP
// end ; wait ( 0 0$3 ) ;
20311: LD_INT 105
20313: PPUSH
20314: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20318: LD_ADDR_VAR 0 1
20322: PUSH
20323: LD_EXP 18
20327: PUSH
20328: LD_INT 1
20330: ARRAY
20331: PUSH
20332: FOR_IN
20333: IFFALSE 20440
// begin if IsInUnit ( i ) then
20335: LD_VAR 0 1
20339: PPUSH
20340: CALL_OW 310
20344: IFFALSE 20355
// ComExitBuilding ( i ) ;
20346: LD_VAR 0 1
20350: PPUSH
20351: CALL_OW 122
// if GetClass ( i ) <> 1 then
20355: LD_VAR 0 1
20359: PPUSH
20360: CALL_OW 257
20364: PUSH
20365: LD_INT 1
20367: NONEQUAL
20368: IFFALSE 20409
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20370: LD_VAR 0 1
20374: PPUSH
20375: LD_VAR 0 5
20379: PUSH
20380: LD_INT 1
20382: ARRAY
20383: PPUSH
20384: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20388: LD_VAR 0 1
20392: PPUSH
20393: LD_INT 1
20395: PPUSH
20396: CALL_OW 183
// AddComExitBuilding ( i ) ;
20400: LD_VAR 0 1
20404: PPUSH
20405: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20409: LD_VAR 0 1
20413: PPUSH
20414: LD_INT 60
20416: PPUSH
20417: LD_INT 94
20419: PPUSH
20420: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20424: LD_VAR 0 1
20428: PPUSH
20429: LD_EXP 59
20433: PPUSH
20434: CALL_OW 179
// end ;
20438: GO 20332
20440: POP
20441: POP
// wait ( 0 0$10 ) ;
20442: LD_INT 350
20444: PPUSH
20445: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20449: LD_EXP 59
20453: PPUSH
20454: LD_STRING D4-Pow-1
20456: PPUSH
20457: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20461: LD_ADDR_VAR 0 2
20465: PUSH
20466: LD_EXP 18
20470: PUSH
20471: LD_INT 1
20473: ARRAY
20474: PPUSH
20475: LD_INT 26
20477: PUSH
20478: LD_INT 1
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: PPUSH
20485: CALL_OW 72
20489: ST_TO_ADDR
// if tmp then
20490: LD_VAR 0 2
20494: IFFALSE 20512
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20496: LD_VAR 0 2
20500: PUSH
20501: LD_INT 1
20503: ARRAY
20504: PPUSH
20505: LD_STRING D4-Sol1-1
20507: PPUSH
20508: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20512: LD_EXP 59
20516: PPUSH
20517: LD_STRING D4-Pow-2
20519: PPUSH
20520: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20524: LD_ADDR_VAR 0 1
20528: PUSH
20529: DOUBLE
20530: LD_INT 1
20532: DEC
20533: ST_TO_ADDR
20534: LD_EXP 18
20538: PUSH
20539: LD_INT 1
20541: ARRAY
20542: PUSH
20543: FOR_TO
20544: IFFALSE 20637
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20546: LD_EXP 18
20550: PUSH
20551: LD_INT 1
20553: ARRAY
20554: PUSH
20555: LD_VAR 0 1
20559: ARRAY
20560: PPUSH
20561: LD_EXP 118
20565: PUSH
20566: LD_INT 4
20568: ARRAY
20569: PUSH
20570: LD_INT 1
20572: ARRAY
20573: PPUSH
20574: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
20578: LD_ADDR_EXP 118
20582: PUSH
20583: LD_EXP 118
20587: PPUSH
20588: LD_INT 4
20590: PPUSH
20591: LD_EXP 118
20595: PUSH
20596: LD_INT 4
20598: ARRAY
20599: PPUSH
20600: LD_INT 1
20602: PPUSH
20603: CALL_OW 3
20607: PPUSH
20608: CALL_OW 1
20612: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
20613: LD_INT 8
20615: PPUSH
20616: LD_EXP 18
20620: PUSH
20621: LD_INT 1
20623: ARRAY
20624: PUSH
20625: LD_VAR 0 1
20629: ARRAY
20630: PPUSH
20631: CALL_OW 471
// end ;
20635: GO 20543
20637: POP
20638: POP
// repeat wait ( 0 0$1 ) ;
20639: LD_INT 35
20641: PPUSH
20642: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
20646: LD_EXP 18
20650: PUSH
20651: LD_INT 1
20653: ARRAY
20654: PPUSH
20655: LD_INT 55
20657: PUSH
20658: EMPTY
20659: LIST
20660: PPUSH
20661: CALL_OW 72
20665: PUSH
20666: LD_INT 4
20668: GREATEREQUAL
20669: IFFALSE 20639
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
20671: LD_EXP 18
20675: PUSH
20676: LD_INT 1
20678: ARRAY
20679: PPUSH
20680: LD_INT 69
20682: PPUSH
20683: LD_INT 94
20685: PPUSH
20686: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
20690: LD_EXP 18
20694: PUSH
20695: LD_INT 1
20697: ARRAY
20698: PPUSH
20699: LD_INT 82
20701: PPUSH
20702: LD_INT 83
20704: PPUSH
20705: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
20709: LD_EXP 18
20713: PUSH
20714: LD_INT 1
20716: ARRAY
20717: PPUSH
20718: LD_INT 77
20720: PPUSH
20721: LD_INT 69
20723: PPUSH
20724: CALL_OW 174
// repeat wait ( 3 ) ;
20728: LD_INT 3
20730: PPUSH
20731: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20735: LD_ADDR_VAR 0 1
20739: PUSH
20740: LD_EXP 18
20744: PUSH
20745: LD_INT 1
20747: ARRAY
20748: PUSH
20749: FOR_IN
20750: IFFALSE 20886
// begin if GetLives ( i ) < 990 then
20752: LD_VAR 0 1
20756: PPUSH
20757: CALL_OW 256
20761: PUSH
20762: LD_INT 990
20764: LESS
20765: IFFALSE 20779
// SetLives ( i , 1000 ) ;
20767: LD_VAR 0 1
20771: PPUSH
20772: LD_INT 1000
20774: PPUSH
20775: CALL_OW 234
// if not IsInUnit ( i ) then
20779: LD_VAR 0 1
20783: PPUSH
20784: CALL_OW 310
20788: NOT
20789: IFFALSE 20884
// begin if not HasTask ( i ) then
20791: LD_VAR 0 1
20795: PPUSH
20796: CALL_OW 314
20800: NOT
20801: IFFALSE 20818
// ComMoveXY ( i , 64 , 93 ) ;
20803: LD_VAR 0 1
20807: PPUSH
20808: LD_INT 64
20810: PPUSH
20811: LD_INT 93
20813: PPUSH
20814: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
20818: LD_VAR 0 4
20822: NOT
20823: PUSH
20824: LD_VAR 0 1
20828: PPUSH
20829: CALL_OW 258
20833: PUSH
20834: LD_INT 1
20836: EQUAL
20837: AND
20838: IFFALSE 20884
// begin retreat := true ;
20840: LD_ADDR_VAR 0 4
20844: PUSH
20845: LD_INT 1
20847: ST_TO_ADDR
// SetTag ( i , 2 ) ;
20848: LD_VAR 0 1
20852: PPUSH
20853: LD_INT 2
20855: PPUSH
20856: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
20860: LD_VAR 0 1
20864: PPUSH
20865: LD_STRING D4a-Sol1-1
20867: PPUSH
20868: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
20872: LD_EXP 59
20876: PPUSH
20877: LD_STRING D4a-Pow-1
20879: PPUSH
20880: CALL_OW 88
// end ; end ; end ;
20884: GO 20749
20886: POP
20887: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
20888: LD_EXP 18
20892: PUSH
20893: LD_INT 1
20895: ARRAY
20896: PPUSH
20897: LD_INT 95
20899: PUSH
20900: LD_INT 9
20902: PUSH
20903: EMPTY
20904: LIST
20905: LIST
20906: PUSH
20907: LD_INT 3
20909: PUSH
20910: LD_INT 55
20912: PUSH
20913: EMPTY
20914: LIST
20915: PUSH
20916: EMPTY
20917: LIST
20918: LIST
20919: PUSH
20920: EMPTY
20921: LIST
20922: LIST
20923: PPUSH
20924: CALL_OW 72
20928: PUSH
20929: LD_INT 4
20931: GREATEREQUAL
20932: IFFALSE 20728
// for i in powellSquadAttack [ 1 ] do
20934: LD_ADDR_VAR 0 1
20938: PUSH
20939: LD_EXP 18
20943: PUSH
20944: LD_INT 1
20946: ARRAY
20947: PUSH
20948: FOR_IN
20949: IFFALSE 21085
// begin if GetTag ( i ) = 2 then
20951: LD_VAR 0 1
20955: PPUSH
20956: CALL_OW 110
20960: PUSH
20961: LD_INT 2
20963: EQUAL
20964: IFFALSE 21026
// begin ComMoveXY ( i , 60 , 94 ) ;
20966: LD_VAR 0 1
20970: PPUSH
20971: LD_INT 60
20973: PPUSH
20974: LD_INT 94
20976: PPUSH
20977: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20981: LD_VAR 0 1
20985: PPUSH
20986: LD_EXP 59
20990: PPUSH
20991: CALL_OW 179
// wait ( 0 0$3 ) ;
20995: LD_INT 105
20997: PPUSH
20998: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21002: LD_VAR 0 1
21006: PPUSH
21007: LD_STRING D4a-Sol1-2
21009: PPUSH
21010: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21014: LD_EXP 59
21018: PPUSH
21019: LD_STRING D4a-Pow-2
21021: PPUSH
21022: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21026: LD_VAR 0 1
21030: PPUSH
21031: LD_INT 0
21033: PPUSH
21034: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21038: LD_ADDR_EXP 99
21042: PUSH
21043: LD_EXP 99
21047: PPUSH
21048: LD_INT 4
21050: PPUSH
21051: LD_EXP 99
21055: PUSH
21056: LD_INT 4
21058: ARRAY
21059: PUSH
21060: LD_VAR 0 1
21064: UNION
21065: PPUSH
21066: CALL_OW 1
21070: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21071: LD_INT 8
21073: PPUSH
21074: LD_VAR 0 1
21078: PPUSH
21079: CALL_OW 472
// end ;
21083: GO 20948
21085: POP
21086: POP
// wait ( 2 2$00 ) ;
21087: LD_INT 4200
21089: PPUSH
21090: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21094: LD_ADDR_VAR 0 9
21098: PUSH
21099: LD_INT 22
21101: PUSH
21102: LD_INT 4
21104: PUSH
21105: EMPTY
21106: LIST
21107: LIST
21108: PUSH
21109: LD_INT 30
21111: PUSH
21112: LD_INT 32
21114: PUSH
21115: EMPTY
21116: LIST
21117: LIST
21118: PUSH
21119: LD_INT 58
21121: PUSH
21122: EMPTY
21123: LIST
21124: PUSH
21125: EMPTY
21126: LIST
21127: LIST
21128: LIST
21129: PPUSH
21130: CALL_OW 69
21134: ST_TO_ADDR
// if tmp then
21135: LD_VAR 0 2
21139: IFFALSE 21379
// begin for i := 1 to tmp do
21141: LD_ADDR_VAR 0 1
21145: PUSH
21146: DOUBLE
21147: LD_INT 1
21149: DEC
21150: ST_TO_ADDR
21151: LD_VAR 0 2
21155: PUSH
21156: FOR_TO
21157: IFFALSE 21370
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21159: LD_ADDR_EXP 99
21163: PUSH
21164: LD_EXP 99
21168: PPUSH
21169: LD_INT 4
21171: PPUSH
21172: LD_EXP 99
21176: PUSH
21177: LD_INT 4
21179: ARRAY
21180: PUSH
21181: LD_VAR 0 2
21185: PUSH
21186: LD_VAR 0 1
21190: ARRAY
21191: DIFF
21192: PPUSH
21193: CALL_OW 1
21197: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21198: LD_ADDR_VAR 0 10
21202: PUSH
21203: LD_VAR 0 2
21207: PUSH
21208: LD_VAR 0 1
21212: ARRAY
21213: PPUSH
21214: CALL_OW 310
21218: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21219: LD_VAR 0 10
21223: PUSH
21224: LD_VAR 0 10
21228: PPUSH
21229: CALL_OW 266
21233: PUSH
21234: LD_INT 32
21236: EQUAL
21237: AND
21238: IFFALSE 21242
// continue ;
21240: GO 21156
// if t then
21242: LD_VAR 0 10
21246: IFFALSE 21263
// ComExitBuilding ( tmp [ i ] ) ;
21248: LD_VAR 0 2
21252: PUSH
21253: LD_VAR 0 1
21257: ARRAY
21258: PPUSH
21259: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21263: LD_VAR 0 2
21267: PUSH
21268: LD_VAR 0 1
21272: ARRAY
21273: PPUSH
21274: LD_VAR 0 5
21278: PUSH
21279: LD_INT 1
21281: ARRAY
21282: PPUSH
21283: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21287: LD_VAR 0 2
21291: PUSH
21292: LD_VAR 0 1
21296: ARRAY
21297: PPUSH
21298: LD_INT 1
21300: PPUSH
21301: CALL_OW 183
// if emptyTowers then
21305: LD_VAR 0 9
21309: IFFALSE 21368
// begin AddComExitBuilding ( tmp [ i ] ) ;
21311: LD_VAR 0 2
21315: PUSH
21316: LD_VAR 0 1
21320: ARRAY
21321: PPUSH
21322: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21326: LD_VAR 0 2
21330: PUSH
21331: LD_VAR 0 1
21335: ARRAY
21336: PPUSH
21337: LD_VAR 0 9
21341: PUSH
21342: LD_INT 1
21344: ARRAY
21345: PPUSH
21346: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21350: LD_ADDR_VAR 0 9
21354: PUSH
21355: LD_VAR 0 9
21359: PPUSH
21360: LD_INT 1
21362: PPUSH
21363: CALL_OW 3
21367: ST_TO_ADDR
// end ; end ;
21368: GO 21156
21370: POP
21371: POP
// wait ( 0 0$30 ) ;
21372: LD_INT 1050
21374: PPUSH
21375: CALL_OW 67
// end ; uc_side := 6 ;
21379: LD_ADDR_OWVAR 20
21383: PUSH
21384: LD_INT 6
21386: ST_TO_ADDR
// uc_nation := 3 ;
21387: LD_ADDR_OWVAR 21
21391: PUSH
21392: LD_INT 3
21394: ST_TO_ADDR
// ru := [ ] ;
21395: LD_ADDR_VAR 0 7
21399: PUSH
21400: EMPTY
21401: ST_TO_ADDR
// for i = 1 to 5 do
21402: LD_ADDR_VAR 0 1
21406: PUSH
21407: DOUBLE
21408: LD_INT 1
21410: DEC
21411: ST_TO_ADDR
21412: LD_INT 5
21414: PUSH
21415: FOR_TO
21416: IFFALSE 21536
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21418: LD_INT 22
21420: PUSH
21421: LD_INT 23
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 1
21430: PPUSH
21431: LD_INT 2
21433: PPUSH
21434: CALL_OW 12
21438: ARRAY
21439: PPUSH
21440: LD_INT 1
21442: PPUSH
21443: LD_INT 3
21445: PPUSH
21446: LD_INT 43
21448: PUSH
21449: LD_INT 44
21451: PUSH
21452: EMPTY
21453: LIST
21454: LIST
21455: PUSH
21456: LD_INT 1
21458: PPUSH
21459: LD_INT 2
21461: PPUSH
21462: CALL_OW 12
21466: ARRAY
21467: PPUSH
21468: LD_INT 89
21470: PPUSH
21471: CALL 72265 0 5
// un := CreateVehicle ;
21475: LD_ADDR_VAR 0 8
21479: PUSH
21480: CALL_OW 45
21484: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21485: LD_VAR 0 8
21489: PPUSH
21490: LD_INT 4
21492: PPUSH
21493: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21497: LD_VAR 0 8
21501: PPUSH
21502: LD_INT 136
21504: PPUSH
21505: LD_INT 90
21507: PPUSH
21508: LD_INT 8
21510: PPUSH
21511: LD_INT 0
21513: PPUSH
21514: CALL_OW 50
// ru := ru ^ un ;
21518: LD_ADDR_VAR 0 7
21522: PUSH
21523: LD_VAR 0 7
21527: PUSH
21528: LD_VAR 0 8
21532: ADD
21533: ST_TO_ADDR
// end ;
21534: GO 21415
21536: POP
21537: POP
// if ru then
21538: LD_VAR 0 7
21542: IFFALSE 21559
// ComAgressiveMove ( ru , 57 , 94 ) ;
21544: LD_VAR 0 7
21548: PPUSH
21549: LD_INT 57
21551: PPUSH
21552: LD_INT 94
21554: PPUSH
21555: CALL_OW 114
// wait ( 3 3$00 ) ;
21559: LD_INT 6300
21561: PPUSH
21562: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21566: LD_INT 4
21568: PPUSH
21569: LD_INT 3
21571: PUSH
21572: LD_INT 1
21574: PUSH
21575: LD_INT 1
21577: PUSH
21578: LD_INT 5
21580: PUSH
21581: EMPTY
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: PUSH
21587: LD_INT 4
21589: PUSH
21590: LD_INT 1
21592: PUSH
21593: LD_INT 1
21595: PUSH
21596: LD_INT 6
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: PUSH
21605: LD_INT 4
21607: PUSH
21608: LD_INT 1
21610: PUSH
21611: LD_INT 1
21613: PUSH
21614: LD_INT 7
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: LIST
21621: LIST
21622: PUSH
21623: LD_INT 3
21625: PUSH
21626: LD_INT 1
21628: PUSH
21629: LD_INT 1
21631: PUSH
21632: LD_INT 7
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: LIST
21639: LIST
21640: PUSH
21641: LD_INT 3
21643: PUSH
21644: LD_INT 1
21646: PUSH
21647: LD_INT 1
21649: PUSH
21650: LD_INT 5
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: PPUSH
21666: CALL 60814 0 2
// missionStage := 4 ;
21670: LD_ADDR_EXP 15
21674: PUSH
21675: LD_INT 4
21677: ST_TO_ADDR
// end ;
21678: PPOPN 10
21680: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
21681: LD_EXP 15
21685: PUSH
21686: LD_INT 4
21688: EQUAL
21689: PUSH
21690: LD_INT 22
21692: PUSH
21693: LD_INT 4
21695: PUSH
21696: EMPTY
21697: LIST
21698: LIST
21699: PUSH
21700: LD_INT 21
21702: PUSH
21703: LD_INT 2
21705: PUSH
21706: EMPTY
21707: LIST
21708: LIST
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: PPUSH
21714: CALL_OW 69
21718: PUSH
21719: LD_INT 5
21721: GREATEREQUAL
21722: AND
21723: IFFALSE 25936
21725: GO 21727
21727: DISABLE
21728: LD_INT 0
21730: PPUSH
21731: PPUSH
21732: PPUSH
21733: PPUSH
21734: PPUSH
21735: PPUSH
21736: PPUSH
21737: PPUSH
21738: PPUSH
21739: PPUSH
21740: PPUSH
21741: PPUSH
21742: PPUSH
// begin wait ( 0 0$10 ) ;
21743: LD_INT 350
21745: PPUSH
21746: CALL_OW 67
// missionStage := 5 ;
21750: LD_ADDR_EXP 15
21754: PUSH
21755: LD_INT 5
21757: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
21758: LD_ADDR_VAR 0 10
21762: PUSH
21763: LD_INT 22
21765: PUSH
21766: LD_INT 4
21768: PUSH
21769: EMPTY
21770: LIST
21771: LIST
21772: PUSH
21773: LD_INT 2
21775: PUSH
21776: LD_INT 30
21778: PUSH
21779: LD_INT 4
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: PUSH
21786: LD_INT 30
21788: PUSH
21789: LD_INT 5
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: PUSH
21796: EMPTY
21797: LIST
21798: LIST
21799: LIST
21800: PUSH
21801: EMPTY
21802: LIST
21803: LIST
21804: PPUSH
21805: CALL_OW 69
21809: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
21810: LD_ADDR_VAR 0 6
21814: PUSH
21815: LD_INT 22
21817: PUSH
21818: LD_INT 4
21820: PUSH
21821: EMPTY
21822: LIST
21823: LIST
21824: PUSH
21825: LD_INT 21
21827: PUSH
21828: LD_INT 1
21830: PUSH
21831: EMPTY
21832: LIST
21833: LIST
21834: PUSH
21835: LD_INT 3
21837: PUSH
21838: LD_INT 25
21840: PUSH
21841: LD_INT 16
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: PUSH
21848: EMPTY
21849: LIST
21850: LIST
21851: PUSH
21852: LD_INT 3
21854: PUSH
21855: LD_INT 25
21857: PUSH
21858: LD_INT 12
21860: PUSH
21861: EMPTY
21862: LIST
21863: LIST
21864: PUSH
21865: EMPTY
21866: LIST
21867: LIST
21868: PUSH
21869: EMPTY
21870: LIST
21871: LIST
21872: LIST
21873: LIST
21874: PPUSH
21875: CALL_OW 69
21879: PUSH
21880: LD_EXP 59
21884: DIFF
21885: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
21886: LD_ADDR_VAR 0 9
21890: PUSH
21891: LD_INT 22
21893: PUSH
21894: LD_INT 4
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: PUSH
21901: LD_INT 30
21903: PUSH
21904: LD_INT 3
21906: PUSH
21907: EMPTY
21908: LIST
21909: LIST
21910: PUSH
21911: EMPTY
21912: LIST
21913: LIST
21914: PPUSH
21915: CALL_OW 69
21919: PUSH
21920: LD_INT 1
21922: ARRAY
21923: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
21924: LD_INT 350
21926: PPUSH
21927: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
21931: LD_EXP 118
21935: PUSH
21936: LD_INT 4
21938: ARRAY
21939: PUSH
21940: LD_INT 5
21942: LESS
21943: PUSH
21944: LD_VAR 0 9
21948: PPUSH
21949: CALL_OW 461
21953: PUSH
21954: LD_INT 2
21956: EQUAL
21957: AND
21958: IFFALSE 21988
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21960: LD_INT 4
21962: PPUSH
21963: LD_INT 3
21965: PUSH
21966: LD_INT 1
21968: PUSH
21969: LD_INT 1
21971: PUSH
21972: LD_INT 5
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: LIST
21979: LIST
21980: PUSH
21981: EMPTY
21982: LIST
21983: PPUSH
21984: CALL 60862 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
21988: LD_EXP 118
21992: PUSH
21993: LD_INT 4
21995: ARRAY
21996: PUSH
21997: LD_INT 5
21999: GREATEREQUAL
22000: PUSH
22001: LD_EXP 118
22005: PUSH
22006: LD_INT 4
22008: ARRAY
22009: PPUSH
22010: LD_INT 58
22012: PUSH
22013: EMPTY
22014: LIST
22015: PPUSH
22016: CALL_OW 72
22020: PUSH
22021: LD_INT 5
22023: GREATEREQUAL
22024: AND
22025: IFFALSE 21924
// powellAllowRetreat := false ;
22027: LD_ADDR_EXP 19
22031: PUSH
22032: LD_INT 0
22034: ST_TO_ADDR
// activeAttacks := false ;
22035: LD_ADDR_EXP 16
22039: PUSH
22040: LD_INT 0
22042: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22043: LD_INT 35
22045: PPUSH
22046: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22050: LD_INT 22
22052: PUSH
22053: LD_INT 6
22055: PUSH
22056: EMPTY
22057: LIST
22058: LIST
22059: PPUSH
22060: CALL_OW 69
22064: PUSH
22065: LD_INT 0
22067: EQUAL
22068: IFFALSE 22043
// tmp := mc_vehicles [ 4 ] ;
22070: LD_ADDR_VAR 0 3
22074: PUSH
22075: LD_EXP 118
22079: PUSH
22080: LD_INT 4
22082: ARRAY
22083: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22084: LD_ADDR_VAR 0 1
22088: PUSH
22089: DOUBLE
22090: LD_INT 1
22092: DEC
22093: ST_TO_ADDR
22094: LD_EXP 18
22098: PUSH
22099: FOR_TO
22100: IFFALSE 22361
// begin for j in powellSquadAttack [ i ] do
22102: LD_ADDR_VAR 0 2
22106: PUSH
22107: LD_EXP 18
22111: PUSH
22112: LD_VAR 0 1
22116: ARRAY
22117: PUSH
22118: FOR_IN
22119: IFFALSE 22357
// begin forces := forces diff j ;
22121: LD_ADDR_VAR 0 6
22125: PUSH
22126: LD_VAR 0 6
22130: PUSH
22131: LD_VAR 0 2
22135: DIFF
22136: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22137: LD_VAR 0 2
22141: PPUSH
22142: LD_INT 1
22144: PPUSH
22145: CALL_OW 109
// wait ( 0 0$2 ) ;
22149: LD_INT 70
22151: PPUSH
22152: CALL_OW 67
// if IsInUnit ( j ) then
22156: LD_VAR 0 2
22160: PPUSH
22161: CALL_OW 310
22165: IFFALSE 22176
// ComExitBuilding ( j ) ;
22167: LD_VAR 0 2
22171: PPUSH
22172: CALL_OW 122
// if GetClass ( j ) <> 1 then
22176: LD_VAR 0 2
22180: PPUSH
22181: CALL_OW 257
22185: PUSH
22186: LD_INT 1
22188: NONEQUAL
22189: IFFALSE 22269
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22191: LD_VAR 0 10
22195: PUSH
22196: LD_INT 1
22198: ARRAY
22199: PPUSH
22200: CALL_OW 313
22204: PUSH
22205: LD_INT 5
22207: GREATEREQUAL
22208: IFFALSE 22230
// AddComEnterUnit ( j , arm [ 2 ] ) else
22210: LD_VAR 0 2
22214: PPUSH
22215: LD_VAR 0 10
22219: PUSH
22220: LD_INT 2
22222: ARRAY
22223: PPUSH
22224: CALL_OW 180
22228: GO 22248
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22230: LD_VAR 0 2
22234: PPUSH
22235: LD_VAR 0 10
22239: PUSH
22240: LD_INT 1
22242: ARRAY
22243: PPUSH
22244: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22248: LD_VAR 0 2
22252: PPUSH
22253: LD_INT 1
22255: PPUSH
22256: CALL_OW 183
// AddComExitBuilding ( j ) ;
22260: LD_VAR 0 2
22264: PPUSH
22265: CALL_OW 182
// end ; if i = 2 then
22269: LD_VAR 0 1
22273: PUSH
22274: LD_INT 2
22276: EQUAL
22277: IFFALSE 22294
// AddComMoveXY ( j , 61 , 93 ) ;
22279: LD_VAR 0 2
22283: PPUSH
22284: LD_INT 61
22286: PPUSH
22287: LD_INT 93
22289: PPUSH
22290: CALL_OW 171
// if i = 1 then
22294: LD_VAR 0 1
22298: PUSH
22299: LD_INT 1
22301: EQUAL
22302: IFFALSE 22355
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22304: LD_VAR 0 2
22308: PPUSH
22309: LD_VAR 0 3
22313: PUSH
22314: LD_INT 1
22316: ARRAY
22317: PPUSH
22318: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22322: LD_ADDR_VAR 0 3
22326: PUSH
22327: LD_VAR 0 3
22331: PPUSH
22332: LD_INT 1
22334: PPUSH
22335: CALL_OW 3
22339: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22340: LD_VAR 0 2
22344: PPUSH
22345: LD_INT 69
22347: PPUSH
22348: LD_INT 94
22350: PPUSH
22351: CALL_OW 171
// end ; end ;
22355: GO 22118
22357: POP
22358: POP
// end ;
22359: GO 22099
22361: POP
22362: POP
// wait ( 0 0$30 ) ;
22363: LD_INT 1050
22365: PPUSH
22366: CALL_OW 67
// MC_Kill ( 4 ) ;
22370: LD_INT 4
22372: PPUSH
22373: CALL 36835 0 1
// tmp := UnitsInside ( fac ) ;
22377: LD_ADDR_VAR 0 3
22381: PUSH
22382: LD_VAR 0 9
22386: PPUSH
22387: CALL_OW 313
22391: ST_TO_ADDR
// if tmp then
22392: LD_VAR 0 3
22396: IFFALSE 22517
// for i in tmp do
22398: LD_ADDR_VAR 0 1
22402: PUSH
22403: LD_VAR 0 3
22407: PUSH
22408: FOR_IN
22409: IFFALSE 22515
// begin ComExitBuilding ( i ) ;
22411: LD_VAR 0 1
22415: PPUSH
22416: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22420: LD_VAR 0 10
22424: PUSH
22425: LD_INT 2
22427: ARRAY
22428: PPUSH
22429: CALL_OW 313
22433: PUSH
22434: LD_INT 6
22436: LESS
22437: IFFALSE 22459
// AddComEnterUnit ( i , arm [ 2 ] ) else
22439: LD_VAR 0 1
22443: PPUSH
22444: LD_VAR 0 10
22448: PUSH
22449: LD_INT 2
22451: ARRAY
22452: PPUSH
22453: CALL_OW 180
22457: GO 22513
// if UnitsInside ( arm [ 1 ] ) < 6 then
22459: LD_VAR 0 10
22463: PUSH
22464: LD_INT 1
22466: ARRAY
22467: PPUSH
22468: CALL_OW 313
22472: PUSH
22473: LD_INT 6
22475: LESS
22476: IFFALSE 22498
// AddComEnterUnit ( i , arm [ 1 ] ) else
22478: LD_VAR 0 1
22482: PPUSH
22483: LD_VAR 0 10
22487: PUSH
22488: LD_INT 1
22490: ARRAY
22491: PPUSH
22492: CALL_OW 180
22496: GO 22513
// AddComMoveXY ( i , 37 , 68 ) ;
22498: LD_VAR 0 1
22502: PPUSH
22503: LD_INT 37
22505: PPUSH
22506: LD_INT 68
22508: PPUSH
22509: CALL_OW 171
// end ;
22513: GO 22408
22515: POP
22516: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22517: LD_ADDR_VAR 0 11
22521: PUSH
22522: LD_VAR 0 6
22526: PPUSH
22527: LD_INT 26
22529: PUSH
22530: LD_INT 1
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PPUSH
22537: CALL_OW 72
22541: PUSH
22542: LD_EXP 60
22546: DIFF
22547: ST_TO_ADDR
// if not speaker then
22548: LD_VAR 0 11
22552: NOT
22553: IFFALSE 22580
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22555: LD_ADDR_VAR 0 11
22559: PUSH
22560: LD_VAR 0 6
22564: PPUSH
22565: LD_INT 26
22567: PUSH
22568: LD_INT 1
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: PPUSH
22575: CALL_OW 72
22579: ST_TO_ADDR
// if speaker then
22580: LD_VAR 0 11
22584: IFFALSE 22600
// speaker := speaker [ 1 ] ;
22586: LD_ADDR_VAR 0 11
22590: PUSH
22591: LD_VAR 0 11
22595: PUSH
22596: LD_INT 1
22598: ARRAY
22599: ST_TO_ADDR
// Video ( true ) ;
22600: LD_INT 1
22602: PPUSH
22603: CALL 104671 0 1
// CenterNowOnUnits ( Powell ) ;
22607: LD_EXP 59
22611: PPUSH
22612: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
22616: LD_ADDR_VAR 0 3
22620: PUSH
22621: LD_VAR 0 6
22625: PPUSH
22626: LD_INT 3
22628: PUSH
22629: LD_INT 25
22631: PUSH
22632: LD_INT 1
22634: PUSH
22635: EMPTY
22636: LIST
22637: LIST
22638: PUSH
22639: EMPTY
22640: LIST
22641: LIST
22642: PPUSH
22643: CALL_OW 72
22647: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22648: LD_ADDR_VAR 0 12
22652: PUSH
22653: LD_INT 22
22655: PUSH
22656: LD_INT 4
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 30
22665: PUSH
22666: LD_INT 32
22668: PUSH
22669: EMPTY
22670: LIST
22671: LIST
22672: PUSH
22673: LD_INT 58
22675: PUSH
22676: EMPTY
22677: LIST
22678: PUSH
22679: EMPTY
22680: LIST
22681: LIST
22682: LIST
22683: PPUSH
22684: CALL_OW 69
22688: ST_TO_ADDR
// for i := 1 to 4 do
22689: LD_ADDR_VAR 0 1
22693: PUSH
22694: DOUBLE
22695: LD_INT 1
22697: DEC
22698: ST_TO_ADDR
22699: LD_INT 4
22701: PUSH
22702: FOR_TO
22703: IFFALSE 22844
// begin if IsInUnit ( tmp [ i ] ) then
22705: LD_VAR 0 3
22709: PUSH
22710: LD_VAR 0 1
22714: ARRAY
22715: PPUSH
22716: CALL_OW 310
22720: IFFALSE 22737
// ComExitBuilding ( tmp [ i ] ) ;
22722: LD_VAR 0 3
22726: PUSH
22727: LD_VAR 0 1
22731: ARRAY
22732: PPUSH
22733: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22737: LD_VAR 0 3
22741: PUSH
22742: LD_VAR 0 1
22746: ARRAY
22747: PPUSH
22748: LD_VAR 0 10
22752: PUSH
22753: LD_INT 1
22755: ARRAY
22756: PPUSH
22757: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22761: LD_VAR 0 3
22765: PUSH
22766: LD_VAR 0 1
22770: ARRAY
22771: PPUSH
22772: LD_INT 1
22774: PPUSH
22775: CALL_OW 183
// if emp_towers then
22779: LD_VAR 0 12
22783: IFFALSE 22842
// begin AddComExitBuilding ( tmp [ i ] ) ;
22785: LD_VAR 0 3
22789: PUSH
22790: LD_VAR 0 1
22794: ARRAY
22795: PPUSH
22796: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
22800: LD_VAR 0 3
22804: PUSH
22805: LD_VAR 0 1
22809: ARRAY
22810: PPUSH
22811: LD_VAR 0 12
22815: PUSH
22816: LD_INT 1
22818: ARRAY
22819: PPUSH
22820: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
22824: LD_ADDR_VAR 0 12
22828: PUSH
22829: LD_VAR 0 12
22833: PPUSH
22834: LD_INT 1
22836: PPUSH
22837: CALL_OW 3
22841: ST_TO_ADDR
// end ; end ;
22842: GO 22702
22844: POP
22845: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
22846: LD_ADDR_VAR 0 3
22850: PUSH
22851: LD_EXP 18
22855: PUSH
22856: LD_INT 1
22858: ARRAY
22859: PUSH
22860: LD_EXP 18
22864: PUSH
22865: LD_INT 2
22867: ARRAY
22868: ADD
22869: PPUSH
22870: LD_INT 26
22872: PUSH
22873: LD_INT 1
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: PPUSH
22880: CALL_OW 72
22884: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
22885: LD_ADDR_VAR 0 1
22889: PUSH
22890: LD_EXP 18
22894: PUSH
22895: LD_INT 2
22897: ARRAY
22898: PUSH
22899: FOR_IN
22900: IFFALSE 22918
// ComTurnUnit ( i , Powell ) ;
22902: LD_VAR 0 1
22906: PPUSH
22907: LD_EXP 59
22911: PPUSH
22912: CALL_OW 119
22916: GO 22899
22918: POP
22919: POP
// Say ( Powell , D5-Pow-1 ) ;
22920: LD_EXP 59
22924: PPUSH
22925: LD_STRING D5-Pow-1
22927: PPUSH
22928: CALL_OW 88
// if tmp then
22932: LD_VAR 0 3
22936: IFFALSE 22954
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
22938: LD_VAR 0 3
22942: PUSH
22943: LD_INT 1
22945: ARRAY
22946: PPUSH
22947: LD_STRING D5-Sol2-1
22949: PPUSH
22950: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
22954: LD_EXP 59
22958: PPUSH
22959: LD_STRING D5-Pow-2
22961: PPUSH
22962: CALL_OW 88
// if tmp > 1 then
22966: LD_VAR 0 3
22970: PUSH
22971: LD_INT 1
22973: GREATER
22974: IFFALSE 22992
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
22976: LD_VAR 0 3
22980: PUSH
22981: LD_INT 2
22983: ARRAY
22984: PPUSH
22985: LD_STRING D5-Sol2-2
22987: PPUSH
22988: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
22992: LD_EXP 59
22996: PPUSH
22997: LD_STRING D5-Pow-3
22999: PPUSH
23000: CALL_OW 88
// wait ( 0 0$1 ) ;
23004: LD_INT 35
23006: PPUSH
23007: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23011: LD_ADDR_VAR 0 3
23015: PUSH
23016: LD_EXP 18
23020: PUSH
23021: LD_INT 1
23023: ARRAY
23024: PUSH
23025: LD_EXP 18
23029: PUSH
23030: LD_INT 2
23032: ARRAY
23033: UNION
23034: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23035: LD_VAR 0 3
23039: PPUSH
23040: LD_INT 80
23042: PPUSH
23043: LD_INT 67
23045: PPUSH
23046: CALL_OW 114
// wait ( 0 0$2 ) ;
23050: LD_INT 70
23052: PPUSH
23053: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23057: LD_INT 79
23059: PPUSH
23060: LD_INT 72
23062: PPUSH
23063: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23067: LD_INT 70
23069: PPUSH
23070: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23074: LD_VAR 0 3
23078: PPUSH
23079: LD_INT 3
23081: PUSH
23082: LD_INT 24
23084: PUSH
23085: LD_INT 1000
23087: PUSH
23088: EMPTY
23089: LIST
23090: LIST
23091: PUSH
23092: EMPTY
23093: LIST
23094: LIST
23095: PPUSH
23096: CALL_OW 72
23100: IFFALSE 23067
// Say ( Powell , D5a-Pow-1 ) ;
23102: LD_EXP 59
23106: PPUSH
23107: LD_STRING D5a-Pow-1
23109: PPUSH
23110: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23114: LD_EXP 59
23118: PPUSH
23119: LD_STRING D5a-Pow-1a
23121: PPUSH
23122: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23126: LD_INT 24
23128: PPUSH
23129: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23133: LD_EXP 59
23137: PPUSH
23138: LD_STRING D5a-Pow-1b
23140: PPUSH
23141: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23145: LD_INT 10
23147: PPUSH
23148: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23152: LD_EXP 59
23156: PPUSH
23157: LD_STRING D5a-Pow-1c
23159: PPUSH
23160: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23164: LD_VAR 0 3
23168: PPUSH
23169: LD_INT 68
23171: PPUSH
23172: LD_INT 63
23174: PPUSH
23175: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23179: LD_INT 18
23181: PPUSH
23182: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23186: LD_EXP 59
23190: PPUSH
23191: LD_STRING D5a-Pow-1d
23193: PPUSH
23194: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23198: LD_INT 35
23200: PPUSH
23201: CALL_OW 67
// if not HasTask ( tmp ) then
23205: LD_VAR 0 3
23209: PPUSH
23210: CALL_OW 314
23214: NOT
23215: IFFALSE 23232
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23217: LD_VAR 0 3
23221: PPUSH
23222: LD_INT 68
23224: PPUSH
23225: LD_INT 63
23227: PPUSH
23228: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23232: LD_VAR 0 3
23236: PPUSH
23237: LD_INT 24
23239: PUSH
23240: LD_INT 1
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PPUSH
23247: CALL_OW 72
23251: NOT
23252: IFFALSE 23198
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23254: LD_ADDR_VAR 0 3
23258: PUSH
23259: LD_INT 22
23261: PUSH
23262: LD_INT 4
23264: PUSH
23265: EMPTY
23266: LIST
23267: LIST
23268: PUSH
23269: LD_INT 92
23271: PUSH
23272: LD_INT 60
23274: PUSH
23275: LD_INT 93
23277: PUSH
23278: LD_INT 10
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: LIST
23285: LIST
23286: PUSH
23287: LD_INT 3
23289: PUSH
23290: LD_INT 54
23292: PUSH
23293: EMPTY
23294: LIST
23295: PUSH
23296: EMPTY
23297: LIST
23298: LIST
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: LIST
23304: PPUSH
23305: CALL_OW 69
23309: PUSH
23310: LD_EXP 59
23314: DIFF
23315: ST_TO_ADDR
// if tmp then
23316: LD_VAR 0 3
23320: IFFALSE 23354
// for i in tmp do
23322: LD_ADDR_VAR 0 1
23326: PUSH
23327: LD_VAR 0 3
23331: PUSH
23332: FOR_IN
23333: IFFALSE 23352
// ComMoveXY ( i , 36 , 67 ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: LD_INT 36
23342: PPUSH
23343: LD_INT 67
23345: PPUSH
23346: CALL_OW 111
23350: GO 23332
23352: POP
23353: POP
// wait ( 0 0$3 ) ;
23354: LD_INT 105
23356: PPUSH
23357: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23361: LD_VAR 0 11
23365: PPUSH
23366: LD_STRING D6-Sol3-1
23368: PPUSH
23369: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23373: LD_EXP 59
23377: PPUSH
23378: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23382: LD_EXP 59
23386: PPUSH
23387: LD_STRING D6-Pow-1
23389: PPUSH
23390: CALL_OW 88
// tmp := [ ] ;
23394: LD_ADDR_VAR 0 3
23398: PUSH
23399: EMPTY
23400: ST_TO_ADDR
// for i = 1 to 2 do
23401: LD_ADDR_VAR 0 1
23405: PUSH
23406: DOUBLE
23407: LD_INT 1
23409: DEC
23410: ST_TO_ADDR
23411: LD_INT 2
23413: PUSH
23414: FOR_TO
23415: IFFALSE 23529
// begin uc_side := 8 ;
23417: LD_ADDR_OWVAR 20
23421: PUSH
23422: LD_INT 8
23424: ST_TO_ADDR
// uc_nation := 2 ;
23425: LD_ADDR_OWVAR 21
23429: PUSH
23430: LD_INT 2
23432: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23433: LD_INT 14
23435: PPUSH
23436: LD_INT 3
23438: PPUSH
23439: LD_INT 2
23441: PPUSH
23442: LD_INT 29
23444: PPUSH
23445: LD_INT 100
23447: PPUSH
23448: CALL 72265 0 5
// veh := CreateVehicle ;
23452: LD_ADDR_VAR 0 13
23456: PUSH
23457: CALL_OW 45
23461: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23462: LD_VAR 0 13
23466: PPUSH
23467: LD_INT 4
23469: PPUSH
23470: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23474: LD_VAR 0 13
23478: PPUSH
23479: LD_INT 99
23481: PPUSH
23482: LD_INT 83
23484: PPUSH
23485: LD_INT 3
23487: PPUSH
23488: LD_INT 0
23490: PPUSH
23491: CALL_OW 50
// wait ( 3 ) ;
23495: LD_INT 3
23497: PPUSH
23498: CALL_OW 67
// Connect ( veh ) ;
23502: LD_VAR 0 13
23506: PPUSH
23507: CALL 75356 0 1
// tmp := tmp ^ veh ;
23511: LD_ADDR_VAR 0 3
23515: PUSH
23516: LD_VAR 0 3
23520: PUSH
23521: LD_VAR 0 13
23525: ADD
23526: ST_TO_ADDR
// end ;
23527: GO 23414
23529: POP
23530: POP
// wait ( 0 0$1 ) ;
23531: LD_INT 35
23533: PPUSH
23534: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
23538: LD_INT 99
23540: PPUSH
23541: LD_INT 83
23543: PPUSH
23544: LD_INT 1
23546: PPUSH
23547: LD_INT 10
23549: PPUSH
23550: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
23554: LD_INT 99
23556: PPUSH
23557: LD_INT 83
23559: PPUSH
23560: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
23564: LD_VAR 0 11
23568: PPUSH
23569: LD_STRING D6-Sol3-2
23571: PPUSH
23572: CALL_OW 88
// async ;
23576: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
23577: LD_EXP 59
23581: PPUSH
23582: LD_STRING D6-Pow-2
23584: PPUSH
23585: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
23589: LD_VAR 0 3
23593: PUSH
23594: LD_INT 1
23596: ARRAY
23597: PPUSH
23598: LD_VAR 0 9
23602: PPUSH
23603: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
23607: LD_VAR 0 3
23611: PUSH
23612: LD_INT 2
23614: ARRAY
23615: PPUSH
23616: LD_INT 22
23618: PUSH
23619: LD_INT 4
23621: PUSH
23622: EMPTY
23623: LIST
23624: LIST
23625: PUSH
23626: LD_INT 21
23628: PUSH
23629: LD_INT 3
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: PPUSH
23640: CALL_OW 69
23644: PPUSH
23645: LD_VAR 0 3
23649: PUSH
23650: LD_INT 2
23652: ARRAY
23653: PPUSH
23654: CALL_OW 74
23658: PPUSH
23659: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
23663: LD_EXP 59
23667: PPUSH
23668: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
23672: LD_INT 99
23674: PPUSH
23675: LD_INT 83
23677: PPUSH
23678: LD_INT 1
23680: PPUSH
23681: CALL_OW 331
// repeat wait ( 4 ) ;
23685: LD_INT 4
23687: PPUSH
23688: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
23692: LD_VAR 0 3
23696: PUSH
23697: LD_INT 1
23699: ARRAY
23700: PPUSH
23701: CALL_OW 256
23705: PUSH
23706: LD_INT 1000
23708: LESS
23709: IFFALSE 23727
// SetLives ( tmp [ 1 ] , 1000 ) ;
23711: LD_VAR 0 3
23715: PUSH
23716: LD_INT 1
23718: ARRAY
23719: PPUSH
23720: LD_INT 1000
23722: PPUSH
23723: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
23727: LD_INT 22
23729: PUSH
23730: LD_INT 4
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: PUSH
23737: LD_INT 30
23739: PUSH
23740: LD_INT 3
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: PPUSH
23751: CALL_OW 69
23755: PUSH
23756: LD_INT 0
23758: EQUAL
23759: IFFALSE 23685
// skirmish := false ;
23761: LD_ADDR_EXP 97
23765: PUSH
23766: LD_INT 0
23768: ST_TO_ADDR
// sync ;
23769: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
23770: LD_EXP 59
23774: PPUSH
23775: LD_STRING D6a-Pow-1
23777: PPUSH
23778: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
23782: LD_VAR 0 11
23786: PPUSH
23787: LD_STRING D6a-Sol3-1
23789: PPUSH
23790: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
23794: LD_EXP 59
23798: PPUSH
23799: LD_STRING D6a-Pow-2
23801: PPUSH
23802: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
23806: LD_VAR 0 11
23810: PPUSH
23811: LD_STRING D6a-Sol3-2
23813: PPUSH
23814: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
23818: LD_EXP 59
23822: PPUSH
23823: LD_STRING D6a-Pow-3
23825: PPUSH
23826: CALL_OW 88
// powellCenterCameraMode := true ;
23830: LD_ADDR_EXP 20
23834: PUSH
23835: LD_INT 1
23837: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23838: LD_ADDR_VAR 0 1
23842: PUSH
23843: LD_INT 22
23845: PUSH
23846: LD_INT 8
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PUSH
23853: LD_INT 25
23855: PUSH
23856: LD_INT 2
23858: PUSH
23859: EMPTY
23860: LIST
23861: LIST
23862: PUSH
23863: EMPTY
23864: LIST
23865: LIST
23866: PPUSH
23867: CALL_OW 69
23871: PUSH
23872: FOR_IN
23873: IFFALSE 23928
// begin SetTag ( i , 1 ) ;
23875: LD_VAR 0 1
23879: PPUSH
23880: LD_INT 1
23882: PPUSH
23883: CALL_OW 109
// ComExitBuilding ( i ) ;
23887: LD_VAR 0 1
23891: PPUSH
23892: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
23896: LD_VAR 0 1
23900: PPUSH
23901: LD_INT 35
23903: PPUSH
23904: LD_INT 6
23906: PPUSH
23907: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
23911: LD_VAR 0 1
23915: PPUSH
23916: LD_INT 53
23918: PPUSH
23919: LD_INT 4
23921: PPUSH
23922: CALL_OW 171
// end ;
23926: GO 23872
23928: POP
23929: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
23930: LD_ADDR_VAR 0 3
23934: PUSH
23935: LD_INT 22
23937: PUSH
23938: LD_INT 4
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: PUSH
23945: LD_INT 21
23947: PUSH
23948: LD_INT 2
23950: PUSH
23951: EMPTY
23952: LIST
23953: LIST
23954: PUSH
23955: LD_INT 3
23957: PUSH
23958: LD_INT 34
23960: PUSH
23961: LD_INT 12
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: PUSH
23972: EMPTY
23973: LIST
23974: LIST
23975: LIST
23976: PPUSH
23977: CALL_OW 69
23981: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
23982: LD_EXP 59
23986: PPUSH
23987: LD_VAR 0 3
23991: PPUSH
23992: LD_EXP 59
23996: PPUSH
23997: CALL_OW 74
24001: PPUSH
24002: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24006: LD_EXP 59
24010: PPUSH
24011: LD_INT 100
24013: PPUSH
24014: LD_INT 88
24016: PPUSH
24017: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24021: LD_EXP 59
24025: PPUSH
24026: LD_INT 100
24028: PPUSH
24029: LD_INT 75
24031: PPUSH
24032: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24036: LD_EXP 59
24040: PPUSH
24041: LD_INT 88
24043: PPUSH
24044: LD_INT 53
24046: PPUSH
24047: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24051: LD_INT 8
24053: PPUSH
24054: LD_EXP 59
24058: PPUSH
24059: CALL_OW 471
// repeat wait ( 3 ) ;
24063: LD_INT 3
24065: PPUSH
24066: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24070: LD_INT 22
24072: PUSH
24073: LD_INT 4
24075: PUSH
24076: EMPTY
24077: LIST
24078: LIST
24079: PUSH
24080: LD_INT 92
24082: PUSH
24083: LD_INT 100
24085: PUSH
24086: LD_INT 75
24088: PUSH
24089: LD_INT 6
24091: PUSH
24092: EMPTY
24093: LIST
24094: LIST
24095: LIST
24096: LIST
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PPUSH
24102: CALL_OW 69
24106: IFFALSE 24063
// async ;
24108: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24109: LD_EXP 59
24113: PPUSH
24114: LD_STRING D6b-Pow-1
24116: PPUSH
24117: CALL_OW 88
// repeat wait ( 3 ) ;
24121: LD_INT 3
24123: PPUSH
24124: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24128: LD_EXP 59
24132: PPUSH
24133: CALL_OW 310
24137: PPUSH
24138: CALL_OW 256
24142: PUSH
24143: LD_INT 1000
24145: LESS
24146: IFFALSE 24165
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24148: LD_EXP 59
24152: PPUSH
24153: CALL_OW 310
24157: PPUSH
24158: LD_INT 1000
24160: PPUSH
24161: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24165: LD_EXP 59
24169: PPUSH
24170: CALL_OW 256
24174: PUSH
24175: LD_INT 1000
24177: LESS
24178: IFFALSE 24192
// SetLives ( Powell , 1000 ) ;
24180: LD_EXP 59
24184: PPUSH
24185: LD_INT 1000
24187: PPUSH
24188: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24192: LD_EXP 59
24196: PPUSH
24197: LD_EXP 64
24201: PPUSH
24202: CALL_OW 296
24206: PUSH
24207: LD_INT 5
24209: LESS
24210: PUSH
24211: LD_EXP 59
24215: PPUSH
24216: CALL_OW 310
24220: PPUSH
24221: LD_EXP 64
24225: PPUSH
24226: CALL_OW 296
24230: PUSH
24231: LD_INT 5
24233: LESS
24234: OR
24235: IFFALSE 24254
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24237: LD_EXP 59
24241: PPUSH
24242: CALL_OW 310
24246: PPUSH
24247: LD_INT 100
24249: PPUSH
24250: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24254: LD_EXP 59
24258: PPUSH
24259: CALL_OW 310
24263: NOT
24264: IFFALSE 24121
// DoNotAttack ( 8 , powellBomb ) ;
24266: LD_INT 8
24268: PPUSH
24269: LD_EXP 64
24273: PPUSH
24274: CALL_OW 471
// game_speed := 4 ;
24278: LD_ADDR_OWVAR 65
24282: PUSH
24283: LD_INT 4
24285: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24286: LD_EXP 59
24290: PPUSH
24291: LD_STRING D6b-Pow-1a
24293: PPUSH
24294: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24298: LD_EXP 59
24302: PPUSH
24303: LD_EXP 64
24307: PPUSH
24308: CALL_OW 180
// sync ;
24312: SYNC
// repeat wait ( 0 0$1 ) ;
24313: LD_INT 35
24315: PPUSH
24316: CALL_OW 67
// until IsInUnit ( Powell ) ;
24320: LD_EXP 59
24324: PPUSH
24325: CALL_OW 310
24329: IFFALSE 24313
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24331: LD_INT 8
24333: PPUSH
24334: LD_EXP 59
24338: PPUSH
24339: CALL_OW 310
24343: PPUSH
24344: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24348: LD_EXP 59
24352: PPUSH
24353: LD_INT 91
24355: PPUSH
24356: LD_INT 44
24358: PPUSH
24359: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24363: LD_EXP 59
24367: PPUSH
24368: LD_INT 96
24370: PPUSH
24371: LD_INT 44
24373: PPUSH
24374: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24378: LD_EXP 59
24382: PPUSH
24383: LD_INT 96
24385: PPUSH
24386: LD_INT 41
24388: PPUSH
24389: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24393: LD_EXP 59
24397: PPUSH
24398: LD_INT 92
24400: PPUSH
24401: LD_INT 39
24403: PPUSH
24404: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24408: LD_EXP 59
24412: PPUSH
24413: LD_INT 88
24415: PPUSH
24416: LD_INT 41
24418: PPUSH
24419: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24423: LD_EXP 59
24427: PPUSH
24428: LD_INT 91
24430: PPUSH
24431: LD_INT 44
24433: PPUSH
24434: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24438: LD_EXP 59
24442: PPUSH
24443: LD_INT 96
24445: PPUSH
24446: LD_INT 44
24448: PPUSH
24449: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24453: LD_EXP 59
24457: PPUSH
24458: LD_INT 96
24460: PPUSH
24461: LD_INT 41
24463: PPUSH
24464: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24468: LD_EXP 59
24472: PPUSH
24473: LD_INT 92
24475: PPUSH
24476: LD_INT 39
24478: PPUSH
24479: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24483: LD_EXP 59
24487: PPUSH
24488: LD_INT 88
24490: PPUSH
24491: LD_INT 41
24493: PPUSH
24494: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24498: LD_EXP 59
24502: PPUSH
24503: LD_INT 91
24505: PPUSH
24506: LD_INT 44
24508: PPUSH
24509: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
24513: LD_EXP 59
24517: PPUSH
24518: LD_INT 93
24520: PPUSH
24521: LD_INT 39
24523: PPUSH
24524: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
24528: LD_EXP 59
24532: PPUSH
24533: LD_INT 93
24535: PPUSH
24536: LD_INT 36
24538: PPUSH
24539: CALL_OW 171
// wait ( 0 0$3.5 ) ;
24543: LD_INT 122
24545: PPUSH
24546: CALL_OW 67
// game_speed := 4 ;
24550: LD_ADDR_OWVAR 65
24554: PUSH
24555: LD_INT 4
24557: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
24558: LD_EXP 59
24562: PPUSH
24563: LD_STRING D6b-Pow-1b
24565: PPUSH
24566: CALL_OW 88
// tmp := [ ] ;
24570: LD_ADDR_VAR 0 3
24574: PUSH
24575: EMPTY
24576: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
24577: LD_ADDR_VAR 0 5
24581: PUSH
24582: LD_INT 78
24584: PUSH
24585: LD_INT 47
24587: PUSH
24588: EMPTY
24589: LIST
24590: LIST
24591: PUSH
24592: LD_INT 106
24594: PUSH
24595: LD_INT 53
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: PUSH
24602: EMPTY
24603: LIST
24604: LIST
24605: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
24606: LD_ADDR_VAR 0 1
24610: PUSH
24611: LD_INT 22
24613: PUSH
24614: LD_INT 8
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: PUSH
24621: LD_INT 21
24623: PUSH
24624: LD_INT 3
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: LD_INT 92
24633: PUSH
24634: LD_INT 90
24636: PUSH
24637: LD_INT 52
24639: PUSH
24640: LD_INT 12
24642: PUSH
24643: EMPTY
24644: LIST
24645: LIST
24646: LIST
24647: LIST
24648: PUSH
24649: EMPTY
24650: LIST
24651: LIST
24652: LIST
24653: PPUSH
24654: CALL_OW 69
24658: PUSH
24659: FOR_IN
24660: IFFALSE 24685
// tmp := tmp ^ UnitsInside ( i ) ;
24662: LD_ADDR_VAR 0 3
24666: PUSH
24667: LD_VAR 0 3
24671: PUSH
24672: LD_VAR 0 1
24676: PPUSH
24677: CALL_OW 313
24681: ADD
24682: ST_TO_ADDR
24683: GO 24659
24685: POP
24686: POP
// for i in tmp do
24687: LD_ADDR_VAR 0 1
24691: PUSH
24692: LD_VAR 0 3
24696: PUSH
24697: FOR_IN
24698: IFFALSE 24860
// begin dist := 9999 ;
24700: LD_ADDR_VAR 0 8
24704: PUSH
24705: LD_INT 9999
24707: ST_TO_ADDR
// _xy := [ ] ;
24708: LD_ADDR_VAR 0 7
24712: PUSH
24713: EMPTY
24714: ST_TO_ADDR
// SetTag ( i , 1 ) ;
24715: LD_VAR 0 1
24719: PPUSH
24720: LD_INT 1
24722: PPUSH
24723: CALL_OW 109
// ComExitBuilding ( i ) ;
24727: LD_VAR 0 1
24731: PPUSH
24732: CALL_OW 122
// for j in xy do
24736: LD_ADDR_VAR 0 2
24740: PUSH
24741: LD_VAR 0 5
24745: PUSH
24746: FOR_IN
24747: IFFALSE 24829
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
24749: LD_VAR 0 1
24753: PPUSH
24754: LD_VAR 0 2
24758: PUSH
24759: LD_INT 1
24761: ARRAY
24762: PPUSH
24763: LD_VAR 0 2
24767: PUSH
24768: LD_INT 2
24770: ARRAY
24771: PPUSH
24772: CALL_OW 297
24776: PUSH
24777: LD_VAR 0 8
24781: LESS
24782: IFFALSE 24827
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
24784: LD_ADDR_VAR 0 8
24788: PUSH
24789: LD_VAR 0 1
24793: PPUSH
24794: LD_VAR 0 2
24798: PUSH
24799: LD_INT 1
24801: ARRAY
24802: PPUSH
24803: LD_VAR 0 2
24807: PUSH
24808: LD_INT 2
24810: ARRAY
24811: PPUSH
24812: CALL_OW 297
24816: ST_TO_ADDR
// _xy := j ;
24817: LD_ADDR_VAR 0 7
24821: PUSH
24822: LD_VAR 0 2
24826: ST_TO_ADDR
// end ;
24827: GO 24746
24829: POP
24830: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
24831: LD_VAR 0 1
24835: PPUSH
24836: LD_VAR 0 7
24840: PUSH
24841: LD_INT 1
24843: ARRAY
24844: PPUSH
24845: LD_VAR 0 7
24849: PUSH
24850: LD_INT 2
24852: ARRAY
24853: PPUSH
24854: CALL_OW 171
// end ;
24858: GO 24697
24860: POP
24861: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
24862: LD_ADDR_VAR 0 4
24866: PUSH
24867: LD_VAR 0 3
24871: PPUSH
24872: LD_INT 26
24874: PUSH
24875: LD_INT 1
24877: PUSH
24878: EMPTY
24879: LIST
24880: LIST
24881: PUSH
24882: LD_INT 25
24884: PUSH
24885: LD_INT 1
24887: PUSH
24888: EMPTY
24889: LIST
24890: LIST
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PPUSH
24896: CALL_OW 72
24900: ST_TO_ADDR
// if tmp2 < 2 then
24901: LD_VAR 0 4
24905: PUSH
24906: LD_INT 2
24908: LESS
24909: IFFALSE 24978
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
24911: LD_ADDR_VAR 0 4
24915: PUSH
24916: LD_INT 22
24918: PUSH
24919: LD_INT 8
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PUSH
24926: LD_INT 26
24928: PUSH
24929: LD_INT 1
24931: PUSH
24932: EMPTY
24933: LIST
24934: LIST
24935: PUSH
24936: LD_INT 3
24938: PUSH
24939: LD_INT 25
24941: PUSH
24942: LD_INT 15
24944: PUSH
24945: EMPTY
24946: LIST
24947: LIST
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: LIST
24957: PPUSH
24958: CALL_OW 69
24962: PUSH
24963: LD_EXP 61
24967: PUSH
24968: LD_EXP 62
24972: PUSH
24973: EMPTY
24974: LIST
24975: LIST
24976: DIFF
24977: ST_TO_ADDR
// if tmp2 then
24978: LD_VAR 0 4
24982: IFFALSE 25000
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
24984: LD_VAR 0 4
24988: PUSH
24989: LD_INT 1
24991: ARRAY
24992: PPUSH
24993: LD_STRING D6b-ArSol1-1
24995: PPUSH
24996: CALL_OW 88
// async ;
25000: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25001: LD_EXP 59
25005: PPUSH
25006: LD_STRING D6b-Pow-2
25008: PPUSH
25009: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25013: LD_INT 18
25015: PPUSH
25016: CALL_OW 67
// if tmp2 > 1 then
25020: LD_VAR 0 4
25024: PUSH
25025: LD_INT 1
25027: GREATER
25028: IFFALSE 25046
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25030: LD_VAR 0 4
25034: PUSH
25035: LD_INT 2
25037: ARRAY
25038: PPUSH
25039: LD_STRING D6b-ArSol2-1
25041: PPUSH
25042: CALL_OW 88
// sync ;
25046: SYNC
// repeat wait ( 5 ) ;
25047: LD_INT 5
25049: PPUSH
25050: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25054: LD_INT 93
25056: PPUSH
25057: LD_INT 36
25059: PPUSH
25060: CALL_OW 428
25064: PPUSH
25065: CALL_OW 255
25069: PUSH
25070: LD_INT 4
25072: EQUAL
25073: IFFALSE 25047
// DialogueOn ;
25075: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25079: LD_INT 10
25081: PPUSH
25082: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25086: LD_EXP 59
25090: PPUSH
25091: LD_STRING D6b-Pow-2a
25093: PPUSH
25094: CALL_OW 88
// DialogueOff ;
25098: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25102: LD_EXP 59
25106: PPUSH
25107: CALL_OW 310
25111: PPUSH
25112: LD_INT 332
25114: PPUSH
25115: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25119: LD_INT 93
25121: PPUSH
25122: LD_INT 35
25124: PPUSH
25125: LD_INT 1
25127: PPUSH
25128: LD_INT 6
25130: NEG
25131: PPUSH
25132: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25136: LD_INT 35
25138: PPUSH
25139: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25143: LD_INT 332
25145: PPUSH
25146: CALL_OW 256
25150: PUSH
25151: LD_INT 1000
25153: LESS
25154: PUSH
25155: LD_INT 332
25157: PPUSH
25158: CALL_OW 300
25162: AND
25163: IFFALSE 25175
// SetLives ( kozlov_fac , 0 ) ;
25165: LD_INT 332
25167: PPUSH
25168: LD_INT 0
25170: PPUSH
25171: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25175: LD_INT 332
25177: PPUSH
25178: CALL_OW 301
25182: PUSH
25183: LD_EXP 59
25187: PPUSH
25188: CALL_OW 301
25192: OR
25193: IFFALSE 25136
// game_speed := 4 ;
25195: LD_ADDR_OWVAR 65
25199: PUSH
25200: LD_INT 4
25202: ST_TO_ADDR
// powellCenterCameraMode := false ;
25203: LD_ADDR_EXP 20
25207: PUSH
25208: LD_INT 0
25210: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25211: LD_ADDR_VAR 0 1
25215: PUSH
25216: LD_VAR 0 3
25220: PUSH
25221: LD_INT 22
25223: PUSH
25224: LD_INT 8
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: PUSH
25231: LD_INT 25
25233: PUSH
25234: LD_INT 2
25236: PUSH
25237: EMPTY
25238: LIST
25239: LIST
25240: PUSH
25241: EMPTY
25242: LIST
25243: LIST
25244: PPUSH
25245: CALL_OW 69
25249: UNION
25250: PUSH
25251: FOR_IN
25252: IFFALSE 25268
// SetTag ( i , 0 ) ;
25254: LD_VAR 0 1
25258: PPUSH
25259: LD_INT 0
25261: PPUSH
25262: CALL_OW 109
25266: GO 25251
25268: POP
25269: POP
// wait ( 0 0$3 ) ;
25270: LD_INT 105
25272: PPUSH
25273: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25277: LD_INT 93
25279: PPUSH
25280: LD_INT 35
25282: PPUSH
25283: LD_INT 1
25285: PPUSH
25286: CALL_OW 331
// DialogueOn ;
25290: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25294: LD_VAR 0 11
25298: PPUSH
25299: LD_STRING D6c-Sol3-1
25301: PPUSH
25302: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25306: LD_INT 10
25308: PPUSH
25309: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25313: LD_EXP 40
25317: PPUSH
25318: LD_STRING D6c-JMM-1
25320: PPUSH
25321: CALL_OW 88
// if Cyrus then
25325: LD_EXP 46
25329: IFFALSE 25343
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25331: LD_EXP 46
25335: PPUSH
25336: LD_STRING D6c-Cyrus-1
25338: PPUSH
25339: CALL_OW 88
// if Bobby then
25343: LD_EXP 45
25347: IFFALSE 25361
// Say ( Bobby , D6c-Bobby-1 ) ;
25349: LD_EXP 45
25353: PPUSH
25354: LD_STRING D6c-Bobby-1
25356: PPUSH
25357: CALL_OW 88
// if Cornel then
25361: LD_EXP 51
25365: IFFALSE 25379
// Say ( Cornel , D6c-Corn-1 ) ;
25367: LD_EXP 51
25371: PPUSH
25372: LD_STRING D6c-Corn-1
25374: PPUSH
25375: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25379: LD_ADDR_VAR 0 4
25383: PUSH
25384: LD_INT 2
25386: PUSH
25387: LD_INT 22
25389: PUSH
25390: LD_INT 1
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 22
25399: PUSH
25400: LD_INT 4
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: EMPTY
25408: LIST
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 26
25414: PUSH
25415: LD_INT 1
25417: PUSH
25418: EMPTY
25419: LIST
25420: LIST
25421: PUSH
25422: LD_INT 23
25424: PUSH
25425: LD_INT 1
25427: PUSH
25428: EMPTY
25429: LIST
25430: LIST
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: LIST
25436: PPUSH
25437: CALL_OW 69
25441: PUSH
25442: LD_VAR 0 11
25446: PUSH
25447: LD_EXP 40
25451: UNION
25452: PUSH
25453: LD_EXP 60
25457: UNION
25458: DIFF
25459: ST_TO_ADDR
// if tmp2 then
25460: LD_VAR 0 4
25464: IFFALSE 25482
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25466: LD_VAR 0 4
25470: PUSH
25471: LD_INT 1
25473: ARRAY
25474: PPUSH
25475: LD_STRING D6c-Sol1-1
25477: PPUSH
25478: CALL_OW 88
// if Lisa then
25482: LD_EXP 43
25486: IFFALSE 25500
// Say ( Lisa , D6c-Lisa-1 ) ;
25488: LD_EXP 43
25492: PPUSH
25493: LD_STRING D6c-Lisa-1
25495: PPUSH
25496: CALL_OW 88
// if Gary then
25500: LD_EXP 52
25504: IFFALSE 25518
// Say ( Gary , D6c-Gary-1 ) ;
25506: LD_EXP 52
25510: PPUSH
25511: LD_STRING D6c-Gary-1
25513: PPUSH
25514: CALL_OW 88
// if Donaldson then
25518: LD_EXP 44
25522: IFFALSE 25536
// Say ( Donaldson , D6c-Don-1 ) ;
25524: LD_EXP 44
25528: PPUSH
25529: LD_STRING D6c-Don-1
25531: PPUSH
25532: CALL_OW 88
// if tmp2 > 1 then
25536: LD_VAR 0 4
25540: PUSH
25541: LD_INT 1
25543: GREATER
25544: IFFALSE 25562
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
25546: LD_VAR 0 4
25550: PUSH
25551: LD_INT 2
25553: ARRAY
25554: PPUSH
25555: LD_STRING D6c-Sol2-1
25557: PPUSH
25558: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
25562: LD_VAR 0 11
25566: PPUSH
25567: LD_STRING D6c-Sol3-2
25569: PPUSH
25570: CALL_OW 88
// if IsInUnit ( JMM ) then
25574: LD_EXP 40
25578: PPUSH
25579: CALL_OW 310
25583: IFFALSE 25601
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
25585: LD_EXP 40
25589: PPUSH
25590: CALL_OW 310
25594: PPUSH
25595: CALL_OW 87
25599: GO 25610
// CenterNowOnUnits ( JMM ) ;
25601: LD_EXP 40
25605: PPUSH
25606: CALL_OW 87
// dwait ( 0 0$2 ) ;
25610: LD_INT 70
25612: PPUSH
25613: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
25617: LD_EXP 40
25621: PPUSH
25622: LD_STRING D6c-JMM-2
25624: PPUSH
25625: CALL_OW 88
// DialogueOff ;
25629: CALL_OW 7
// Video ( false ) ;
25633: LD_INT 0
25635: PPUSH
25636: CALL 104671 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
25640: LD_INT 22
25642: PUSH
25643: LD_INT 4
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PPUSH
25650: CALL_OW 69
25654: PPUSH
25655: LD_INT 1
25657: PPUSH
25658: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
25662: LD_INT 4
25664: PPUSH
25665: LD_INT 4
25667: PPUSH
25668: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
25672: LD_ADDR_VAR 0 1
25676: PUSH
25677: LD_INT 4
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 2
25685: PPUSH
25686: CALL 67313 0 3
25690: PUSH
25691: FOR_IN
25692: IFFALSE 25729
// if GetTech ( i , 1 ) <> state_researched then
25694: LD_VAR 0 1
25698: PPUSH
25699: LD_INT 1
25701: PPUSH
25702: CALL_OW 321
25706: PUSH
25707: LD_INT 2
25709: NONEQUAL
25710: IFFALSE 25727
// SetTech ( i , 1 , state_researched ) ;
25712: LD_VAR 0 1
25716: PPUSH
25717: LD_INT 1
25719: PPUSH
25720: LD_INT 2
25722: PPUSH
25723: CALL_OW 322
25727: GO 25691
25729: POP
25730: POP
// missionStage := 6 ;
25731: LD_ADDR_EXP 15
25735: PUSH
25736: LD_INT 6
25738: ST_TO_ADDR
// activeAttacks := true ;
25739: LD_ADDR_EXP 16
25743: PUSH
25744: LD_INT 1
25746: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
25747: LD_STRING M2
25749: PPUSH
25750: CALL_OW 337
// SaveForQuickRestart ;
25754: CALL_OW 22
// wait ( 0 0$40 ) ;
25758: LD_INT 1400
25760: PPUSH
25761: CALL_OW 67
// DialogueOn ;
25765: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
25769: LD_EXP 63
25773: PPUSH
25774: LD_STRING D7-Friend-1
25776: PPUSH
25777: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
25781: LD_EXP 40
25785: PPUSH
25786: LD_STRING D7-JMM-1
25788: PPUSH
25789: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
25793: LD_EXP 63
25797: PPUSH
25798: LD_STRING D7-Friend-2
25800: PPUSH
25801: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
25805: LD_EXP 40
25809: PPUSH
25810: LD_STRING D7-JMM-2
25812: PPUSH
25813: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
25817: LD_EXP 63
25821: PPUSH
25822: LD_STRING D7-Friend-3
25824: PPUSH
25825: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
25829: LD_EXP 40
25833: PPUSH
25834: LD_STRING D7-JMM-3
25836: PPUSH
25837: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
25841: LD_EXP 63
25845: PPUSH
25846: LD_STRING D7-Friend-4
25848: PPUSH
25849: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
25853: LD_EXP 40
25857: PPUSH
25858: LD_STRING D7-JMM-4
25860: PPUSH
25861: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
25865: LD_EXP 63
25869: PPUSH
25870: LD_STRING D7-Friend-5
25872: PPUSH
25873: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
25877: LD_EXP 40
25881: PPUSH
25882: LD_STRING D7-JMM-5
25884: PPUSH
25885: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
25889: LD_EXP 63
25893: PPUSH
25894: LD_STRING D7-Friend-6
25896: PPUSH
25897: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
25901: LD_EXP 40
25905: PPUSH
25906: LD_STRING D7-JMM-6
25908: PPUSH
25909: CALL_OW 88
// DialogueOff ;
25913: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
25917: LD_STRING Mlegion
25919: PPUSH
25920: CALL_OW 337
// skirmish := true ;
25924: LD_ADDR_EXP 97
25928: PUSH
25929: LD_INT 1
25931: ST_TO_ADDR
// RebuildKozlovFactory ;
25932: CALL 4920 0 0
// end ;
25936: PPOPN 13
25938: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
25939: LD_EXP 20
25943: PUSH
25944: LD_EXP 59
25948: PPUSH
25949: CALL_OW 300
25953: AND
25954: IFFALSE 25996
25956: GO 25958
25958: DISABLE
// begin enable ;
25959: ENABLE
// if IsInUnit ( Powell ) then
25960: LD_EXP 59
25964: PPUSH
25965: CALL_OW 310
25969: IFFALSE 25987
// CenterOnUnits ( IsInUnit ( Powell ) ) else
25971: LD_EXP 59
25975: PPUSH
25976: CALL_OW 310
25980: PPUSH
25981: CALL_OW 85
25985: GO 25996
// CenterOnUnits ( Powell ) ;
25987: LD_EXP 59
25991: PPUSH
25992: CALL_OW 85
// end ;
25996: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
25997: LD_INT 22
25999: PUSH
26000: LD_INT 8
26002: PUSH
26003: EMPTY
26004: LIST
26005: LIST
26006: PUSH
26007: LD_INT 34
26009: PUSH
26010: LD_INT 48
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PPUSH
26021: CALL_OW 69
26025: IFFALSE 26299
26027: GO 26029
26029: DISABLE
26030: LD_INT 0
26032: PPUSH
26033: PPUSH
// begin if missionStage < 9 then
26034: LD_EXP 15
26038: PUSH
26039: LD_INT 9
26041: LESS
26042: IFFALSE 26052
// missionStage := 9 ;
26044: LD_ADDR_EXP 15
26048: PUSH
26049: LD_INT 9
26051: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26052: LD_ADDR_VAR 0 1
26056: PUSH
26057: LD_INT 22
26059: PUSH
26060: LD_INT 8
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: LD_INT 34
26069: PUSH
26070: LD_INT 48
26072: PUSH
26073: EMPTY
26074: LIST
26075: LIST
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PPUSH
26081: CALL_OW 69
26085: PUSH
26086: LD_INT 1
26088: ARRAY
26089: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26090: LD_INT 175
26092: PPUSH
26093: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26097: LD_EXP 12
26101: PUSH
26102: LD_EXP 3
26106: PUSH
26107: LD_INT 0
26109: PUSH
26110: LD_INT 2
26112: PUSH
26113: EMPTY
26114: LIST
26115: LIST
26116: IN
26117: OR
26118: IFFALSE 26141
// target := [ 68 , 108 , 1 ] else
26120: LD_ADDR_VAR 0 2
26124: PUSH
26125: LD_INT 68
26127: PUSH
26128: LD_INT 108
26130: PUSH
26131: LD_INT 1
26133: PUSH
26134: EMPTY
26135: LIST
26136: LIST
26137: LIST
26138: ST_TO_ADDR
26139: GO 26160
// target := [ 181 , 88 , 2 ] ;
26141: LD_ADDR_VAR 0 2
26145: PUSH
26146: LD_INT 181
26148: PUSH
26149: LD_INT 88
26151: PUSH
26152: LD_INT 2
26154: PUSH
26155: EMPTY
26156: LIST
26157: LIST
26158: LIST
26159: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26160: LD_VAR 0 1
26164: PPUSH
26165: LD_VAR 0 2
26169: PUSH
26170: LD_INT 1
26172: ARRAY
26173: PPUSH
26174: LD_VAR 0 2
26178: PUSH
26179: LD_INT 2
26181: ARRAY
26182: PPUSH
26183: CALL_OW 176
// if target [ 3 ] = 1 then
26187: LD_VAR 0 2
26191: PUSH
26192: LD_INT 3
26194: ARRAY
26195: PUSH
26196: LD_INT 1
26198: EQUAL
26199: IFFALSE 26215
// SayRadio ( Kurt , D12-Kurt-1 ) else
26201: LD_EXP 61
26205: PPUSH
26206: LD_STRING D12-Kurt-1
26208: PPUSH
26209: CALL_OW 94
26213: GO 26239
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26215: LD_EXP 61
26219: PPUSH
26220: LD_STRING D12a-Kurt-1
26222: PPUSH
26223: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26227: LD_EXP 76
26231: PPUSH
26232: LD_STRING D12a-Roth-1
26234: PPUSH
26235: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26239: LD_INT 350
26241: PPUSH
26242: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26246: LD_VAR 0 1
26250: PPUSH
26251: LD_INT 22
26253: PUSH
26254: LD_INT 8
26256: PUSH
26257: EMPTY
26258: LIST
26259: LIST
26260: PUSH
26261: LD_INT 23
26263: PUSH
26264: LD_INT 2
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 30
26273: PUSH
26274: LD_INT 3
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: PUSH
26281: EMPTY
26282: LIST
26283: LIST
26284: LIST
26285: PPUSH
26286: CALL_OW 69
26290: PUSH
26291: LD_INT 1
26293: ARRAY
26294: PPUSH
26295: CALL_OW 228
// end ;
26299: PPOPN 2
26301: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26302: LD_EXP 61
26306: PPUSH
26307: CALL_OW 256
26311: PUSH
26312: LD_INT 999
26314: LESS
26315: PUSH
26316: LD_INT 22
26318: PUSH
26319: LD_INT 8
26321: PUSH
26322: EMPTY
26323: LIST
26324: LIST
26325: PUSH
26326: LD_INT 21
26328: PUSH
26329: LD_INT 1
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 23
26338: PUSH
26339: LD_INT 2
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: LIST
26350: PPUSH
26351: CALL_OW 69
26355: PUSH
26356: LD_INT 9
26358: PUSH
26359: LD_INT 8
26361: PUSH
26362: LD_INT 7
26364: PUSH
26365: LD_INT 6
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: PUSH
26374: LD_OWVAR 67
26378: ARRAY
26379: LESSEQUAL
26380: OR
26381: PUSH
26382: LD_INT 22
26384: PUSH
26385: LD_INT 8
26387: PUSH
26388: EMPTY
26389: LIST
26390: LIST
26391: PUSH
26392: LD_INT 34
26394: PUSH
26395: LD_INT 48
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: PUSH
26402: EMPTY
26403: LIST
26404: LIST
26405: PPUSH
26406: CALL_OW 69
26410: NOT
26411: AND
26412: PUSH
26413: LD_EXP 61
26417: PPUSH
26418: CALL_OW 302
26422: AND
26423: PUSH
26424: LD_INT 5
26426: PPUSH
26427: LD_INT 22
26429: PUSH
26430: LD_INT 1
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PPUSH
26437: CALL_OW 70
26441: AND
26442: IFFALSE 27186
26444: GO 26446
26446: DISABLE
26447: LD_INT 0
26449: PPUSH
26450: PPUSH
26451: PPUSH
// begin legionDestroyed := true ;
26452: LD_ADDR_EXP 22
26456: PUSH
26457: LD_INT 1
26459: ST_TO_ADDR
// DialogueOn ;
26460: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26464: LD_EXP 40
26468: PPUSH
26469: LD_STRING D13-JMM-1
26471: PPUSH
26472: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26476: LD_EXP 61
26480: PPUSH
26481: LD_STRING D13-Kurt-1
26483: PPUSH
26484: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26488: LD_EXP 40
26492: PPUSH
26493: LD_STRING D13-JMM-2
26495: PPUSH
26496: CALL_OW 88
// if FakeInfo then
26500: LD_EXP 12
26504: IFFALSE 26524
// begin Say ( Kurt , D13-Kurt-2 ) ;
26506: LD_EXP 61
26510: PPUSH
26511: LD_STRING D13-Kurt-2
26513: PPUSH
26514: CALL_OW 88
// DialogueOff ;
26518: CALL_OW 7
// exit ;
26522: GO 27186
// end ; if not KurtStatus then
26524: LD_EXP 3
26528: NOT
26529: IFFALSE 26545
// Say ( Kurt , D13-Kurt-2b ) else
26531: LD_EXP 61
26535: PPUSH
26536: LD_STRING D13-Kurt-2b
26538: PPUSH
26539: CALL_OW 88
26543: GO 26557
// Say ( Kurt , D13-Kurt-2a ) ;
26545: LD_EXP 61
26549: PPUSH
26550: LD_STRING D13-Kurt-2a
26552: PPUSH
26553: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
26557: LD_EXP 40
26561: PPUSH
26562: LD_STRING D13-JMM-3
26564: PPUSH
26565: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
26569: LD_EXP 61
26573: PPUSH
26574: LD_STRING D13-Kurt-3
26576: PPUSH
26577: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
26581: LD_EXP 40
26585: PPUSH
26586: LD_STRING D13-JMM-4
26588: PPUSH
26589: CALL_OW 88
// DialogueOff ;
26593: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
26597: LD_STRING MlegionOut
26599: PPUSH
26600: CALL_OW 337
// MC_Kill ( 3 ) ;
26604: LD_INT 3
26606: PPUSH
26607: CALL 36835 0 1
// KillUnit ( Kozlov ) ;
26611: LD_EXP 62
26615: PPUSH
26616: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
26620: LD_ADDR_VAR 0 1
26624: PUSH
26625: LD_INT 22
26627: PUSH
26628: LD_INT 8
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 23
26637: PUSH
26638: LD_INT 3
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: LD_INT 3
26647: PUSH
26648: LD_INT 21
26650: PUSH
26651: LD_INT 33
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: LIST
26666: PPUSH
26667: CALL_OW 69
26671: PUSH
26672: FOR_IN
26673: IFFALSE 26686
// KillUnit ( i ) ;
26675: LD_VAR 0 1
26679: PPUSH
26680: CALL_OW 66
26684: GO 26672
26686: POP
26687: POP
// ChangeSideFog ( 8 , 1 ) ;
26688: LD_INT 8
26690: PPUSH
26691: LD_INT 1
26693: PPUSH
26694: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
26698: LD_ADDR_VAR 0 2
26702: PUSH
26703: LD_INT 22
26705: PUSH
26706: LD_INT 8
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PUSH
26713: LD_INT 21
26715: PUSH
26716: LD_INT 1
26718: PUSH
26719: EMPTY
26720: LIST
26721: LIST
26722: PUSH
26723: EMPTY
26724: LIST
26725: LIST
26726: PPUSH
26727: CALL_OW 69
26731: PUSH
26732: LD_EXP 62
26736: PUSH
26737: LD_EXP 61
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: DIFF
26746: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
26747: LD_VAR 0 2
26751: PUSH
26752: LD_INT 6
26754: PUSH
26755: LD_INT 5
26757: PUSH
26758: LD_INT 4
26760: PUSH
26761: LD_INT 3
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: PUSH
26770: LD_OWVAR 67
26774: ARRAY
26775: GREATEREQUAL
26776: IFFALSE 26928
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
26778: LD_ADDR_VAR 0 3
26782: PUSH
26783: LD_INT 6
26785: PUSH
26786: LD_INT 5
26788: PUSH
26789: LD_INT 4
26791: PUSH
26792: LD_INT 3
26794: PUSH
26795: EMPTY
26796: LIST
26797: LIST
26798: LIST
26799: LIST
26800: PUSH
26801: LD_OWVAR 67
26805: ARRAY
26806: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
26807: LD_ADDR_VAR 0 1
26811: PUSH
26812: DOUBLE
26813: LD_VAR 0 2
26817: PUSH
26818: LD_VAR 0 3
26822: PUSH
26823: LD_INT 1
26825: PLUS
26826: MINUS
26827: INC
26828: ST_TO_ADDR
26829: LD_INT 1
26831: PUSH
26832: FOR_DOWNTO
26833: IFFALSE 26924
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
26835: LD_ADDR_EXP 38
26839: PUSH
26840: LD_EXP 38
26844: PUSH
26845: LD_VAR 0 2
26849: PUSH
26850: LD_VAR 0 1
26854: ARRAY
26855: ADD
26856: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
26857: LD_VAR 0 2
26861: PUSH
26862: LD_VAR 0 1
26866: ARRAY
26867: PPUSH
26868: CALL_OW 310
26872: IFFALSE 26889
// ComExit ( tmp [ i ] ) ;
26874: LD_VAR 0 2
26878: PUSH
26879: LD_VAR 0 1
26883: ARRAY
26884: PPUSH
26885: CALL 105097 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
26889: LD_VAR 0 2
26893: PUSH
26894: LD_VAR 0 1
26898: ARRAY
26899: PPUSH
26900: LD_INT 34
26902: PUSH
26903: LD_INT 0
26905: PPUSH
26906: LD_INT 6
26908: PPUSH
26909: CALL_OW 12
26913: PLUS
26914: PPUSH
26915: LD_INT 1
26917: PPUSH
26918: CALL_OW 171
// end ;
26922: GO 26832
26924: POP
26925: POP
// end else
26926: GO 26938
// x := tmp ;
26928: LD_ADDR_VAR 0 3
26932: PUSH
26933: LD_VAR 0 2
26937: ST_TO_ADDR
// for i := tmp downto tmp - x do
26938: LD_ADDR_VAR 0 1
26942: PUSH
26943: DOUBLE
26944: LD_VAR 0 2
26948: INC
26949: ST_TO_ADDR
26950: LD_VAR 0 2
26954: PUSH
26955: LD_VAR 0 3
26959: MINUS
26960: PUSH
26961: FOR_DOWNTO
26962: IFFALSE 27016
// begin if IsInUnit ( tmp [ i ] ) then
26964: LD_VAR 0 2
26968: PUSH
26969: LD_VAR 0 1
26973: ARRAY
26974: PPUSH
26975: CALL_OW 310
26979: IFFALSE 26996
// ComExit ( tmp [ i ] ) ;
26981: LD_VAR 0 2
26985: PUSH
26986: LD_VAR 0 1
26990: ARRAY
26991: PPUSH
26992: CALL 105097 0 1
// SetSide ( tmp [ i ] , 1 ) ;
26996: LD_VAR 0 2
27000: PUSH
27001: LD_VAR 0 1
27005: ARRAY
27006: PPUSH
27007: LD_INT 1
27009: PPUSH
27010: CALL_OW 235
// end ;
27014: GO 26961
27016: POP
27017: POP
// wait ( 0 0$0.3 ) ;
27018: LD_INT 10
27020: PPUSH
27021: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
27025: LD_ADDR_VAR 0 1
27029: PUSH
27030: LD_INT 22
27032: PUSH
27033: LD_INT 8
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PUSH
27040: LD_INT 21
27042: PUSH
27043: LD_INT 2
27045: PUSH
27046: EMPTY
27047: LIST
27048: LIST
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PPUSH
27054: CALL_OW 69
27058: PUSH
27059: FOR_IN
27060: IFFALSE 27073
// KillUnit ( i ) ;
27062: LD_VAR 0 1
27066: PPUSH
27067: CALL_OW 66
27071: GO 27059
27073: POP
27074: POP
// SetSide ( Kurt , 1 ) ;
27075: LD_EXP 61
27079: PPUSH
27080: LD_INT 1
27082: PPUSH
27083: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
27087: LD_INT 22
27089: PUSH
27090: LD_INT 8
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PUSH
27097: LD_INT 21
27099: PUSH
27100: LD_INT 3
27102: PUSH
27103: EMPTY
27104: LIST
27105: LIST
27106: PUSH
27107: EMPTY
27108: LIST
27109: LIST
27110: PPUSH
27111: CALL_OW 69
27115: PPUSH
27116: LD_INT 1
27118: PPUSH
27119: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27123: LD_INT 8
27125: PPUSH
27126: LD_INT 1
27128: PPUSH
27129: LD_INT 1
27131: PPUSH
27132: LD_INT 1
27134: PPUSH
27135: CALL_OW 80
// wait ( 1 1$20 ) ;
27139: LD_INT 2800
27141: PPUSH
27142: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27146: LD_EXP 63
27150: PPUSH
27151: LD_INT 37
27153: PPUSH
27154: LD_INT 1
27156: PPUSH
27157: LD_INT 0
27159: PPUSH
27160: CALL_OW 48
// wait ( 0 0$1 ) ;
27164: LD_INT 35
27166: PPUSH
27167: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27171: LD_EXP 63
27175: PPUSH
27176: LD_INT 60
27178: PPUSH
27179: LD_INT 95
27181: PPUSH
27182: CALL_OW 111
// end ;
27186: PPOPN 3
27188: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27189: LD_EXP 22
27193: NOT
27194: PUSH
27195: LD_INT 22
27197: PUSH
27198: LD_INT 8
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 21
27207: PUSH
27208: LD_INT 1
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: PPUSH
27219: CALL_OW 69
27223: PUSH
27224: LD_INT 0
27226: EQUAL
27227: AND
27228: IFFALSE 27248
27230: GO 27232
27232: DISABLE
// begin legionDestroyed := true ;
27233: LD_ADDR_EXP 22
27237: PUSH
27238: LD_INT 1
27240: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27241: LD_STRING MlegionOut
27243: PPUSH
27244: CALL_OW 337
// end ;
27248: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27249: LD_EXP 38
27253: IFFALSE 27328
27255: GO 27257
27257: DISABLE
27258: LD_INT 0
27260: PPUSH
// begin enable ;
27261: ENABLE
// for i in legionEscapeUnits do
27262: LD_ADDR_VAR 0 1
27266: PUSH
27267: LD_EXP 38
27271: PUSH
27272: FOR_IN
27273: IFFALSE 27326
// begin if IsInArea ( i , legionEscapeArea ) then
27275: LD_VAR 0 1
27279: PPUSH
27280: LD_INT 31
27282: PPUSH
27283: CALL_OW 308
27287: IFFALSE 27300
// RemoveUnit ( i ) else
27289: LD_VAR 0 1
27293: PPUSH
27294: CALL_OW 64
27298: GO 27324
// if not HasTask ( i ) then
27300: LD_VAR 0 1
27304: PPUSH
27305: CALL_OW 314
27309: NOT
27310: IFFALSE 27324
// ComMoveToArea ( i , legionEscapeArea ) ;
27312: LD_VAR 0 1
27316: PPUSH
27317: LD_INT 31
27319: PPUSH
27320: CALL_OW 113
// end ;
27324: GO 27272
27326: POP
27327: POP
// end ;
27328: PPOPN 1
27330: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27331: LD_INT 1
27333: PPUSH
27334: LD_EXP 63
27338: PPUSH
27339: CALL_OW 292
27343: IFFALSE 27641
27345: GO 27347
27347: DISABLE
27348: LD_INT 0
27350: PPUSH
// begin wait ( 0 0$2 ) ;
27351: LD_INT 70
27353: PPUSH
27354: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27358: LD_EXP 63
27362: PPUSH
27363: CALL_OW 87
// DialogueOn ;
27367: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27371: LD_EXP 40
27375: PPUSH
27376: LD_STRING D14-JMM-1
27378: PPUSH
27379: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27383: LD_EXP 63
27387: PPUSH
27388: LD_STRING D14-Friend-1
27390: PPUSH
27391: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27395: LD_EXP 40
27399: PPUSH
27400: LD_STRING D14-JMM-2
27402: PPUSH
27403: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27407: LD_EXP 63
27411: PPUSH
27412: LD_STRING D14-Friend-2
27414: PPUSH
27415: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27419: LD_EXP 40
27423: PPUSH
27424: LD_STRING D14-JMM-3
27426: PPUSH
27427: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27431: LD_EXP 63
27435: PPUSH
27436: LD_STRING D14-Friend-3
27438: PPUSH
27439: CALL_OW 88
// DialogueOff ;
27443: CALL_OW 7
// dec = Query ( Q14 ) ;
27447: LD_ADDR_VAR 0 1
27451: PUSH
27452: LD_STRING Q14
27454: PPUSH
27455: CALL_OW 97
27459: ST_TO_ADDR
// if dec = 1 then
27460: LD_VAR 0 1
27464: PUSH
27465: LD_INT 1
27467: EQUAL
27468: IFFALSE 27502
// begin DialogueOn ;
27470: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27474: LD_EXP 40
27478: PPUSH
27479: LD_STRING D14a-JMM-1
27481: PPUSH
27482: CALL_OW 88
// DialogueOff ;
27486: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27490: LD_EXP 63
27494: PPUSH
27495: LD_INT 1
27497: PPUSH
27498: CALL_OW 235
// end ; if dec = 2 then
27502: LD_VAR 0 1
27506: PUSH
27507: LD_INT 2
27509: EQUAL
27510: IFFALSE 27563
// begin DialogueOn ;
27512: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
27516: LD_EXP 40
27520: PPUSH
27521: LD_STRING D14b-JMM-1
27523: PPUSH
27524: CALL_OW 88
// DialogueOff ;
27528: CALL_OW 7
// wait ( 0 0$1 ) ;
27532: LD_INT 35
27534: PPUSH
27535: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
27539: LD_EXP 63
27543: PPUSH
27544: LD_INT 9
27546: PPUSH
27547: LD_INT 2
27549: PPUSH
27550: CALL_OW 111
// AddComHold ( Friend ) ;
27554: LD_EXP 63
27558: PPUSH
27559: CALL_OW 200
// end ; if dec = 3 then
27563: LD_VAR 0 1
27567: PUSH
27568: LD_INT 3
27570: EQUAL
27571: IFFALSE 27641
// begin DialogueOn ;
27573: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
27577: LD_EXP 40
27581: PPUSH
27582: LD_STRING D14c-JMM-1
27584: PPUSH
27585: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
27589: LD_EXP 63
27593: PPUSH
27594: LD_STRING D14c-Friend-1
27596: PPUSH
27597: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
27601: LD_EXP 40
27605: PPUSH
27606: LD_STRING D14c-JMM-2
27608: PPUSH
27609: CALL_OW 88
// DialogueOff ;
27613: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
27617: LD_EXP 63
27621: PPUSH
27622: LD_INT 9
27624: PPUSH
27625: LD_INT 2
27627: PPUSH
27628: CALL_OW 111
// AddComHold ( Friend ) ;
27632: LD_EXP 63
27636: PPUSH
27637: CALL_OW 200
// end ; end ;
27641: PPOPN 1
27643: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
27644: LD_INT 9
27646: PPUSH
27647: LD_INT 2
27649: PPUSH
27650: CALL_OW 428
27654: PUSH
27655: LD_EXP 63
27659: EQUAL
27660: PUSH
27661: LD_EXP 63
27665: PPUSH
27666: CALL_OW 255
27670: PUSH
27671: LD_INT 8
27673: EQUAL
27674: AND
27675: IFFALSE 27689
27677: GO 27679
27679: DISABLE
// RemoveUnit ( Friend ) ;
27680: LD_EXP 63
27684: PPUSH
27685: CALL_OW 64
27689: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
27690: LD_EXP 14
27694: PUSH
27695: LD_INT 31500
27697: GREATEREQUAL
27698: PUSH
27699: LD_EXP 7
27703: AND
27704: PUSH
27705: LD_EXP 2
27709: AND
27710: IFFALSE 28140
27712: GO 27714
27714: DISABLE
27715: LD_INT 0
27717: PPUSH
27718: PPUSH
27719: PPUSH
// begin missionStage := 7 ;
27720: LD_ADDR_EXP 15
27724: PUSH
27725: LD_INT 7
27727: ST_TO_ADDR
// uc_side = 1 ;
27728: LD_ADDR_OWVAR 20
27732: PUSH
27733: LD_INT 1
27735: ST_TO_ADDR
// uc_nation = 1 ;
27736: LD_ADDR_OWVAR 21
27740: PUSH
27741: LD_INT 1
27743: ST_TO_ADDR
// for i = 1 to 5 do
27744: LD_ADDR_VAR 0 1
27748: PUSH
27749: DOUBLE
27750: LD_INT 1
27752: DEC
27753: ST_TO_ADDR
27754: LD_INT 5
27756: PUSH
27757: FOR_TO
27758: IFFALSE 27854
// begin vc_engine = 3 ;
27760: LD_ADDR_OWVAR 39
27764: PUSH
27765: LD_INT 3
27767: ST_TO_ADDR
// vc_control = 3 ;
27768: LD_ADDR_OWVAR 38
27772: PUSH
27773: LD_INT 3
27775: ST_TO_ADDR
// vc_chassis = 3 ;
27776: LD_ADDR_OWVAR 37
27780: PUSH
27781: LD_INT 3
27783: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27784: LD_ADDR_OWVAR 40
27788: PUSH
27789: LD_INT 5
27791: PUSH
27792: LD_INT 9
27794: PUSH
27795: LD_INT 7
27797: PUSH
27798: EMPTY
27799: LIST
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 1
27805: PPUSH
27806: LD_INT 3
27808: PPUSH
27809: CALL_OW 12
27813: ARRAY
27814: ST_TO_ADDR
// veh = CreateVehicle ;
27815: LD_ADDR_VAR 0 2
27819: PUSH
27820: CALL_OW 45
27824: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
27825: LD_VAR 0 2
27829: PPUSH
27830: LD_INT 1
27832: PPUSH
27833: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
27837: LD_VAR 0 2
27841: PPUSH
27842: LD_INT 19
27844: PPUSH
27845: LD_INT 0
27847: PPUSH
27848: CALL_OW 49
// end ;
27852: GO 27757
27854: POP
27855: POP
// vc_engine = 3 ;
27856: LD_ADDR_OWVAR 39
27860: PUSH
27861: LD_INT 3
27863: ST_TO_ADDR
// vc_control = 1 ;
27864: LD_ADDR_OWVAR 38
27868: PUSH
27869: LD_INT 1
27871: ST_TO_ADDR
// vc_chassis = 3 ;
27872: LD_ADDR_OWVAR 37
27876: PUSH
27877: LD_INT 3
27879: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27880: LD_ADDR_OWVAR 40
27884: PUSH
27885: LD_INT 5
27887: PUSH
27888: LD_INT 9
27890: PUSH
27891: LD_INT 7
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 1
27901: PPUSH
27902: LD_INT 3
27904: PPUSH
27905: CALL_OW 12
27909: ARRAY
27910: ST_TO_ADDR
// vehG = CreateVehicle ;
27911: LD_ADDR_VAR 0 3
27915: PUSH
27916: CALL_OW 45
27920: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
27921: LD_VAR 0 3
27925: PPUSH
27926: LD_INT 1
27928: PPUSH
27929: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
27933: LD_VAR 0 3
27937: PPUSH
27938: LD_INT 19
27940: PPUSH
27941: LD_INT 0
27943: PPUSH
27944: CALL_OW 49
// if JMMGirl = 1 then
27948: LD_EXP 7
27952: PUSH
27953: LD_INT 1
27955: EQUAL
27956: IFFALSE 28012
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
27958: LD_ADDR_EXP 41
27962: PUSH
27963: LD_STRING Joan
27965: PPUSH
27966: LD_INT 1
27968: PPUSH
27969: LD_STRING 14_
27971: PPUSH
27972: CALL 67250 0 3
27976: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
27977: LD_EXP 41
27981: PPUSH
27982: LD_VAR 0 3
27986: PPUSH
27987: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
27991: LD_VAR 0 3
27995: PPUSH
27996: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28000: LD_EXP 41
28004: PPUSH
28005: LD_STRING D10BW-Joan-1
28007: PPUSH
28008: CALL_OW 94
// end ; if JMMGirl = 2 then
28012: LD_EXP 7
28016: PUSH
28017: LD_INT 2
28019: EQUAL
28020: IFFALSE 28076
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28022: LD_ADDR_EXP 43
28026: PUSH
28027: LD_STRING Lisa
28029: PPUSH
28030: LD_INT 1
28032: PPUSH
28033: LD_STRING 14_
28035: PPUSH
28036: CALL 67250 0 3
28040: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28041: LD_EXP 43
28045: PPUSH
28046: LD_VAR 0 3
28050: PPUSH
28051: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28055: LD_VAR 0 3
28059: PPUSH
28060: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28064: LD_EXP 43
28068: PPUSH
28069: LD_STRING D10BW-Lisa-1
28071: PPUSH
28072: CALL_OW 94
// end ; if JMMGirl = 3 then
28076: LD_EXP 7
28080: PUSH
28081: LD_INT 3
28083: EQUAL
28084: IFFALSE 28140
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28086: LD_ADDR_EXP 55
28090: PUSH
28091: LD_STRING Connie
28093: PPUSH
28094: LD_INT 1
28096: PPUSH
28097: LD_STRING 14_
28099: PPUSH
28100: CALL 67250 0 3
28104: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28105: LD_EXP 55
28109: PPUSH
28110: LD_VAR 0 3
28114: PPUSH
28115: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28119: LD_VAR 0 3
28123: PPUSH
28124: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28128: LD_EXP 55
28132: PPUSH
28133: LD_STRING D10BW-Con-1
28135: PPUSH
28136: CALL_OW 94
// end ; end ;
28140: PPOPN 3
28142: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28143: LD_EXP 14
28147: PUSH
28148: LD_INT 94500
28150: GREATEREQUAL
28151: IFFALSE 28563
28153: GO 28155
28155: DISABLE
28156: LD_INT 0
28158: PPUSH
28159: PPUSH
28160: PPUSH
// begin tmp := PrepareStevensSquad ;
28161: LD_ADDR_VAR 0 3
28165: PUSH
28166: CALL 2323 0 0
28170: ST_TO_ADDR
// if not tmp then
28171: LD_VAR 0 3
28175: NOT
28176: IFFALSE 28180
// exit ;
28178: GO 28563
// uc_side := 1 ;
28180: LD_ADDR_OWVAR 20
28184: PUSH
28185: LD_INT 1
28187: ST_TO_ADDR
// uc_nation := 1 ;
28188: LD_ADDR_OWVAR 21
28192: PUSH
28193: LD_INT 1
28195: ST_TO_ADDR
// for i in tmp do
28196: LD_ADDR_VAR 0 1
28200: PUSH
28201: LD_VAR 0 3
28205: PUSH
28206: FOR_IN
28207: IFFALSE 28304
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28209: LD_INT 3
28211: PPUSH
28212: LD_INT 3
28214: PPUSH
28215: LD_INT 1
28217: PPUSH
28218: LD_INT 5
28220: PUSH
28221: LD_INT 9
28223: PUSH
28224: LD_INT 7
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: LIST
28231: PUSH
28232: LD_INT 1
28234: PPUSH
28235: LD_INT 3
28237: PPUSH
28238: CALL_OW 12
28242: ARRAY
28243: PPUSH
28244: LD_INT 40
28246: PPUSH
28247: CALL 72265 0 5
// veh := CreateVehicle ;
28251: LD_ADDR_VAR 0 2
28255: PUSH
28256: CALL_OW 45
28260: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28261: LD_VAR 0 2
28265: PPUSH
28266: LD_INT 1
28268: PPUSH
28269: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28273: LD_VAR 0 2
28277: PPUSH
28278: LD_INT 19
28280: PPUSH
28281: LD_INT 0
28283: PPUSH
28284: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28288: LD_VAR 0 1
28292: PPUSH
28293: LD_VAR 0 2
28297: PPUSH
28298: CALL_OW 52
// end ;
28302: GO 28206
28304: POP
28305: POP
// missionStage := 8 ;
28306: LD_ADDR_EXP 15
28310: PUSH
28311: LD_INT 8
28313: ST_TO_ADDR
// DialogueOn ;
28314: CALL_OW 6
// if Stevens then
28318: LD_EXP 42
28322: IFFALSE 28436
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28324: LD_EXP 42
28328: PPUSH
28329: CALL_OW 310
28333: PPUSH
28334: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28338: LD_EXP 42
28342: PPUSH
28343: LD_STRING D8-Huck-1
28345: PPUSH
28346: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28350: LD_EXP 40
28354: PPUSH
28355: LD_STRING D8-JMM-1
28357: PPUSH
28358: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28362: LD_EXP 42
28366: PPUSH
28367: LD_STRING D8-Huck-2
28369: PPUSH
28370: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28374: LD_EXP 40
28378: PPUSH
28379: LD_STRING D8-JMM-2
28381: PPUSH
28382: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28386: LD_EXP 42
28390: PPUSH
28391: LD_STRING D8-Huck-3
28393: PPUSH
28394: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28398: LD_EXP 40
28402: PPUSH
28403: LD_STRING D8-JMM-3
28405: PPUSH
28406: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28410: LD_EXP 42
28414: PPUSH
28415: LD_STRING D8-Huck-4
28417: PPUSH
28418: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28422: LD_EXP 40
28426: PPUSH
28427: LD_STRING D8-JMM-4
28429: PPUSH
28430: CALL_OW 88
// end else
28434: GO 28546
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28436: LD_EXP 56
28440: PPUSH
28441: CALL_OW 310
28445: PPUSH
28446: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28450: LD_EXP 56
28454: PPUSH
28455: LD_STRING D8-Huck-1
28457: PPUSH
28458: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28462: LD_EXP 40
28466: PPUSH
28467: LD_STRING D8-JMM-1a
28469: PPUSH
28470: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28474: LD_EXP 56
28478: PPUSH
28479: LD_STRING D8-Huck-2
28481: PPUSH
28482: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28486: LD_EXP 40
28490: PPUSH
28491: LD_STRING D8-JMM-2
28493: PPUSH
28494: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28498: LD_EXP 56
28502: PPUSH
28503: LD_STRING D8-Huck-3
28505: PPUSH
28506: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28510: LD_EXP 40
28514: PPUSH
28515: LD_STRING D8-JMM-3
28517: PPUSH
28518: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
28522: LD_EXP 56
28526: PPUSH
28527: LD_STRING D8-Huck-4
28529: PPUSH
28530: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28534: LD_EXP 40
28538: PPUSH
28539: LD_STRING D8-JMM-4
28541: PPUSH
28542: CALL_OW 88
// end ; DialogueOff ;
28546: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
28550: LD_INT 25
28552: PPUSH
28553: LD_INT 1
28555: PPUSH
28556: LD_INT 1
28558: PPUSH
28559: CALL_OW 322
// end ;
28563: PPOPN 3
28565: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
28566: LD_INT 1
28568: PPUSH
28569: LD_EXP 72
28573: PPUSH
28574: CALL_OW 292
28578: IFFALSE 28829
28580: GO 28582
28582: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
28583: LD_EXP 72
28587: PPUSH
28588: CALL_OW 87
// DialogueOn ;
28592: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
28596: LD_EXP 40
28600: PPUSH
28601: LD_STRING D10nB-JMM-1
28603: PPUSH
28604: CALL_OW 88
// if BurlakStatus = 1 then
28608: LD_EXP 9
28612: PUSH
28613: LD_INT 1
28615: EQUAL
28616: IFFALSE 28630
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
28618: LD_EXP 71
28622: PPUSH
28623: LD_STRING D10nB-Vse-1a
28625: PPUSH
28626: CALL_OW 94
// end ; if BurlakStatus = 0 then
28630: LD_EXP 9
28634: PUSH
28635: LD_INT 0
28637: EQUAL
28638: IFFALSE 28652
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
28640: LD_EXP 71
28644: PPUSH
28645: LD_STRING D10nB-Vse-1
28647: PPUSH
28648: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
28652: LD_EXP 40
28656: PPUSH
28657: LD_STRING D10nB-JMM-2
28659: PPUSH
28660: CALL_OW 88
// if KappaStatus then
28664: LD_EXP 2
28668: IFFALSE 28682
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
28670: LD_EXP 71
28674: PPUSH
28675: LD_STRING D10nB-Vse-5a
28677: PPUSH
28678: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
28682: LD_EXP 2
28686: NOT
28687: PUSH
28688: LD_EXP 6
28692: PUSH
28693: LD_INT 0
28695: EQUAL
28696: AND
28697: IFFALSE 28825
// begin if JMMGirl = 1 then
28699: LD_EXP 7
28703: PUSH
28704: LD_INT 1
28706: EQUAL
28707: IFFALSE 28757
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
28709: LD_EXP 71
28713: PPUSH
28714: LD_STRING D10nB-Vse-2
28716: PPUSH
28717: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
28721: LD_EXP 40
28725: PPUSH
28726: LD_STRING D10nB-JMM-3
28728: PPUSH
28729: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
28733: LD_EXP 71
28737: PPUSH
28738: LD_STRING D10nB-Vse-3
28740: PPUSH
28741: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
28745: LD_EXP 40
28749: PPUSH
28750: LD_STRING D10nB-JMM-4
28752: PPUSH
28753: CALL_OW 88
// end ; if JMMGirl = 2 then
28757: LD_EXP 7
28761: PUSH
28762: LD_INT 2
28764: EQUAL
28765: IFFALSE 28791
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
28767: LD_EXP 71
28771: PPUSH
28772: LD_STRING D10nB-Vse-4
28774: PPUSH
28775: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
28779: LD_EXP 40
28783: PPUSH
28784: LD_STRING D10nB-JMM-5
28786: PPUSH
28787: CALL_OW 88
// end ; if JMMGirl = 3 then
28791: LD_EXP 7
28795: PUSH
28796: LD_INT 3
28798: EQUAL
28799: IFFALSE 28825
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
28801: LD_EXP 71
28805: PPUSH
28806: LD_STRING D10nB-Vse-5
28808: PPUSH
28809: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
28813: LD_EXP 40
28817: PPUSH
28818: LD_STRING D10nB-JMM-6
28820: PPUSH
28821: CALL_OW 88
// end ; end ; DialogueOff ;
28825: CALL_OW 7
// end ;
28829: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
28830: LD_EXP 14
28834: PUSH
28835: LD_INT 115500
28837: GREATEREQUAL
28838: IFFALSE 29214
28840: GO 28842
28842: DISABLE
28843: LD_INT 0
28845: PPUSH
// begin missionStage := 10 ;
28846: LD_ADDR_EXP 15
28850: PUSH
28851: LD_INT 10
28853: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28854: LD_ADDR_VAR 0 1
28858: PUSH
28859: LD_INT 22
28861: PUSH
28862: LD_INT 1
28864: PUSH
28865: EMPTY
28866: LIST
28867: LIST
28868: PUSH
28869: LD_INT 23
28871: PUSH
28872: LD_INT 1
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 26
28881: PUSH
28882: LD_INT 1
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 3
28891: PUSH
28892: LD_INT 25
28894: PUSH
28895: LD_INT 12
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 3
28908: PUSH
28909: LD_INT 25
28911: PUSH
28912: LD_INT 16
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: PPUSH
28930: CALL_OW 69
28934: PUSH
28935: LD_EXP 40
28939: PUSH
28940: LD_EXP 61
28944: PUSH
28945: LD_EXP 42
28949: PUSH
28950: LD_EXP 56
28954: PUSH
28955: LD_EXP 43
28959: PUSH
28960: LD_EXP 44
28964: PUSH
28965: LD_EXP 45
28969: PUSH
28970: LD_EXP 46
28974: PUSH
28975: LD_EXP 47
28979: PUSH
28980: LD_EXP 48
28984: PUSH
28985: LD_EXP 49
28989: PUSH
28990: LD_EXP 50
28994: PUSH
28995: LD_EXP 51
28999: PUSH
29000: LD_EXP 52
29004: PUSH
29005: LD_EXP 53
29009: PUSH
29010: LD_EXP 54
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: DIFF
29033: ST_TO_ADDR
// if not tmp and Brown then
29034: LD_VAR 0 1
29038: NOT
29039: PUSH
29040: LD_EXP 48
29044: AND
29045: IFFALSE 29060
// tmp := [ Brown ] ;
29047: LD_ADDR_VAR 0 1
29051: PUSH
29052: LD_EXP 48
29056: PUSH
29057: EMPTY
29058: LIST
29059: ST_TO_ADDR
// DialogueOn ;
29060: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29064: LD_VAR 0 1
29068: PUSH
29069: LD_INT 1
29071: ARRAY
29072: PPUSH
29073: LD_STRING D11-Sol1-1
29075: PPUSH
29076: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29080: LD_EXP 65
29084: PPUSH
29085: LD_STRING D11-Pla-1
29087: PPUSH
29088: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29092: LD_EXP 66
29096: PPUSH
29097: LD_STRING D11-Kov-1
29099: PPUSH
29100: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29104: LD_EXP 65
29108: PPUSH
29109: LD_STRING D11-Pla-2
29111: PPUSH
29112: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29116: LD_VAR 0 1
29120: PUSH
29121: LD_INT 1
29123: ARRAY
29124: PPUSH
29125: LD_STRING D11-Sol1-2
29127: PPUSH
29128: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29132: LD_EXP 40
29136: PPUSH
29137: LD_STRING D11-JMM-2
29139: PPUSH
29140: CALL_OW 88
// DialogueOff ;
29144: CALL_OW 7
// allowBehemothConstruct := true ;
29148: LD_ADDR_EXP 25
29152: PUSH
29153: LD_INT 1
29155: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29156: LD_STRING M4
29158: PPUSH
29159: CALL_OW 337
// BuildBehemoths ;
29163: CALL 7787 0 0
// repeat wait ( 15 15$00 ) ;
29167: LD_INT 31500
29169: PPUSH
29170: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29174: LD_EXP 27
29178: IFFALSE 29182
// break ;
29180: GO 29214
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29182: LD_INT 267
29184: PPUSH
29185: CALL_OW 274
29189: PPUSH
29190: LD_INT 1
29192: PPUSH
29193: CALL_OW 275
29197: PUSH
29198: LD_INT 1000
29200: GREATEREQUAL
29201: IFFALSE 29207
// BuildBehemoths ;
29203: CALL 7787 0 0
// until not behemothBuilders ;
29207: LD_EXP 74
29211: NOT
29212: IFFALSE 29167
// end ;
29214: PPOPN 1
29216: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29217: LD_EXP 74
29221: NOT
29222: PUSH
29223: LD_EXP 28
29227: NOT
29228: AND
29229: PUSH
29230: LD_EXP 25
29234: AND
29235: IFFALSE 29255
29237: GO 29239
29239: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29240: LD_STRING M4a
29242: PPUSH
29243: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29247: LD_ADDR_EXP 27
29251: PUSH
29252: LD_INT 1
29254: ST_TO_ADDR
// end ;
29255: END
// every 0 0$1 trigger behemothDone do
29256: LD_EXP 28
29260: IFFALSE 29272
29262: GO 29264
29264: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29265: LD_STRING M4b
29267: PPUSH
29268: CALL_OW 337
29272: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29273: LD_EXP 29
29277: NOT
29278: IFFALSE 29474
29280: GO 29282
29282: DISABLE
29283: LD_INT 0
29285: PPUSH
29286: PPUSH
// begin enable ;
29287: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29288: LD_ADDR_VAR 0 1
29292: PUSH
29293: LD_INT 3
29295: PPUSH
29296: CALL 104760 0 1
29300: ST_TO_ADDR
// if not tmp and not behemothDone then
29301: LD_VAR 0 1
29305: NOT
29306: PUSH
29307: LD_EXP 28
29311: NOT
29312: AND
29313: IFFALSE 29349
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29315: LD_ADDR_VAR 0 1
29319: PUSH
29320: LD_INT 22
29322: PUSH
29323: LD_INT 3
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 30
29332: PUSH
29333: LD_INT 37
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: PUSH
29340: EMPTY
29341: LIST
29342: LIST
29343: PPUSH
29344: CALL_OW 69
29348: ST_TO_ADDR
// if not tmp then
29349: LD_VAR 0 1
29353: NOT
29354: IFFALSE 29358
// exit ;
29356: GO 29474
// for i in tmp do
29358: LD_ADDR_VAR 0 2
29362: PUSH
29363: LD_VAR 0 1
29367: PUSH
29368: FOR_IN
29369: IFFALSE 29472
// if See ( 1 , i ) then
29371: LD_INT 1
29373: PPUSH
29374: LD_VAR 0 2
29378: PPUSH
29379: CALL_OW 292
29383: IFFALSE 29470
// begin if GetType ( i ) = unit_building then
29385: LD_VAR 0 2
29389: PPUSH
29390: CALL_OW 247
29394: PUSH
29395: LD_INT 3
29397: EQUAL
29398: IFFALSE 29436
// begin CenterNowOnUnits ( i ) ;
29400: LD_VAR 0 2
29404: PPUSH
29405: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29409: LD_EXP 40
29413: PPUSH
29414: LD_STRING D17a-JMM-1
29416: PPUSH
29417: CALL_OW 88
// seeBehemoth := true ;
29421: LD_ADDR_EXP 29
29425: PUSH
29426: LD_INT 1
29428: ST_TO_ADDR
// disable ;
29429: DISABLE
// exit ;
29430: POP
29431: POP
29432: GO 29474
// end else
29434: GO 29470
// begin CenterNowOnUnits ( i ) ;
29436: LD_VAR 0 2
29440: PPUSH
29441: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29445: LD_EXP 40
29449: PPUSH
29450: LD_STRING D17b-JMM-1
29452: PPUSH
29453: CALL_OW 88
// seeBehemoth := true ;
29457: LD_ADDR_EXP 29
29461: PUSH
29462: LD_INT 1
29464: ST_TO_ADDR
// disable ;
29465: DISABLE
// exit ;
29466: POP
29467: POP
29468: GO 29474
// end ; end ;
29470: GO 29368
29472: POP
29473: POP
// end ;
29474: PPOPN 2
29476: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
29477: LD_EXP 14
29481: PUSH
29482: LD_INT 123200
29484: GREATEREQUAL
29485: IFFALSE 30661
29487: GO 29489
29489: DISABLE
29490: LD_INT 0
29492: PPUSH
29493: PPUSH
29494: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
29495: LD_INT 2
29497: PPUSH
29498: LD_INT 23
29500: PUSH
29501: LD_INT 3
29503: PUSH
29504: LD_INT 3
29506: PUSH
29507: LD_INT 48
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: LIST
29514: LIST
29515: PUSH
29516: EMPTY
29517: LIST
29518: PPUSH
29519: CALL 60862 0 2
// repeat wait ( 0 0$1 ) ;
29523: LD_INT 35
29525: PPUSH
29526: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
29530: LD_INT 22
29532: PUSH
29533: LD_INT 3
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 34
29542: PUSH
29543: LD_INT 48
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PPUSH
29554: CALL_OW 69
29558: IFFALSE 29523
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
29560: LD_ADDR_VAR 0 1
29564: PUSH
29565: LD_INT 22
29567: PUSH
29568: LD_INT 3
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: LD_INT 34
29577: PUSH
29578: LD_INT 48
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PPUSH
29589: CALL_OW 69
29593: PUSH
29594: LD_INT 1
29596: ARRAY
29597: ST_TO_ADDR
// missionStage := 12 ;
29598: LD_ADDR_EXP 15
29602: PUSH
29603: LD_INT 12
29605: ST_TO_ADDR
// platonovHasBomb := true ;
29606: LD_ADDR_EXP 30
29610: PUSH
29611: LD_INT 1
29613: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
29614: LD_VAR 0 1
29618: PPUSH
29619: LD_INT 181
29621: PPUSH
29622: LD_INT 86
29624: PPUSH
29625: CALL_OW 171
// AddComHold ( bomb ) ;
29629: LD_VAR 0 1
29633: PPUSH
29634: CALL_OW 200
// wait ( 0 0$10 ) ;
29638: LD_INT 350
29640: PPUSH
29641: CALL_OW 67
// DialogueOn ;
29645: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
29649: LD_EXP 65
29653: PPUSH
29654: LD_STRING D15-Pla-1
29656: PPUSH
29657: CALL_OW 94
// dec = Query ( Q15a ) ;
29661: LD_ADDR_VAR 0 2
29665: PUSH
29666: LD_STRING Q15a
29668: PPUSH
29669: CALL_OW 97
29673: ST_TO_ADDR
// if dec = 1 then
29674: LD_VAR 0 2
29678: PUSH
29679: LD_INT 1
29681: EQUAL
29682: IFFALSE 29705
// begin Say ( JMM , D15a-JMM-1 ) ;
29684: LD_EXP 40
29688: PPUSH
29689: LD_STRING D15a-JMM-1
29691: PPUSH
29692: CALL_OW 88
// YouLost ( Surrender ) ;
29696: LD_STRING Surrender
29698: PPUSH
29699: CALL_OW 104
// exit ;
29703: GO 30661
// end ; if dec = 2 then
29705: LD_VAR 0 2
29709: PUSH
29710: LD_INT 2
29712: EQUAL
29713: IFFALSE 29782
// begin Say ( JMM , D15b-JMM-1 ) ;
29715: LD_EXP 40
29719: PPUSH
29720: LD_STRING D15b-JMM-1
29722: PPUSH
29723: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
29727: LD_EXP 65
29731: PPUSH
29732: LD_STRING D15b-Pla-1
29734: PPUSH
29735: CALL_OW 94
// DialogueOff ;
29739: CALL_OW 7
// wait ( 3 3$00 ) ;
29743: LD_INT 6300
29745: PPUSH
29746: CALL_OW 67
// DialogueOn ;
29750: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
29754: LD_EXP 40
29758: PPUSH
29759: LD_STRING D15d-JMM-1a
29761: PPUSH
29762: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29766: LD_EXP 65
29770: PPUSH
29771: LD_STRING D15d-Pla-1
29773: PPUSH
29774: CALL_OW 94
// DialogueOff ;
29778: CALL_OW 7
// end ; if dec = 3 then
29782: LD_VAR 0 2
29786: PUSH
29787: LD_INT 3
29789: EQUAL
29790: IFFALSE 29844
// begin Say ( JMM , D15c-JMM-1 ) ;
29792: LD_EXP 40
29796: PPUSH
29797: LD_STRING D15c-JMM-1
29799: PPUSH
29800: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
29804: LD_EXP 65
29808: PPUSH
29809: LD_STRING D15c-Pla-1
29811: PPUSH
29812: CALL_OW 94
// DialogueOff ;
29816: CALL_OW 7
// wait ( 0 0$15 ) ;
29820: LD_INT 525
29822: PPUSH
29823: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
29827: LD_VAR 0 1
29831: PPUSH
29832: LD_INT 60
29834: PPUSH
29835: LD_INT 95
29837: PPUSH
29838: CALL_OW 116
// exit ;
29842: GO 30661
// end ; if dec = 4 then
29844: LD_VAR 0 2
29848: PUSH
29849: LD_INT 4
29851: EQUAL
29852: IFFALSE 29882
// begin Say ( JMM , D15d-JMM-1 ) ;
29854: LD_EXP 40
29858: PPUSH
29859: LD_STRING D15d-JMM-1
29861: PPUSH
29862: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29866: LD_EXP 65
29870: PPUSH
29871: LD_STRING D15d-Pla-1
29873: PPUSH
29874: CALL_OW 94
// DialogueOff ;
29878: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29882: LD_EXP 63
29886: PPUSH
29887: CALL_OW 302
29891: PUSH
29892: LD_EXP 63
29896: PPUSH
29897: CALL_OW 255
29901: PUSH
29902: LD_INT 1
29904: EQUAL
29905: AND
29906: PUSH
29907: LD_INT 22
29909: PUSH
29910: LD_INT 1
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: LD_INT 34
29919: PUSH
29920: LD_INT 8
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PPUSH
29931: CALL_OW 69
29935: NOT
29936: AND
29937: IFFALSE 30562
// begin SetSide ( Friend , 8 ) ;
29939: LD_EXP 63
29943: PPUSH
29944: LD_INT 8
29946: PPUSH
29947: CALL_OW 235
// if IsInUnit ( Friend ) then
29951: LD_EXP 63
29955: PPUSH
29956: CALL_OW 310
29960: IFFALSE 29971
// ComExitBuilding ( Friend ) ;
29962: LD_EXP 63
29966: PPUSH
29967: CALL_OW 122
// if IsDriver ( Friend ) then
29971: LD_EXP 63
29975: PPUSH
29976: CALL 102308 0 1
29980: IFFALSE 29991
// ComExitVehicle ( Friend ) ;
29982: LD_EXP 63
29986: PPUSH
29987: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
29991: LD_EXP 63
29995: PPUSH
29996: LD_INT 9
29998: PPUSH
29999: LD_INT 2
30001: PPUSH
30002: CALL_OW 171
// wait ( 0 0$05 ) ;
30006: LD_INT 175
30008: PPUSH
30009: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30013: LD_EXP 63
30017: PPUSH
30018: CALL_OW 87
// DialogueOn ;
30022: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30026: LD_EXP 40
30030: PPUSH
30031: LD_STRING D16-JMM-1
30033: PPUSH
30034: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30038: LD_EXP 63
30042: PPUSH
30043: LD_STRING D16-Friend-1
30045: PPUSH
30046: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30050: LD_EXP 40
30054: PPUSH
30055: LD_STRING D16-JMM-2
30057: PPUSH
30058: CALL_OW 88
// DialogueOff ;
30062: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30066: LD_EXP 63
30070: PPUSH
30071: LD_INT 1
30073: PPUSH
30074: CALL_OW 235
// ComHold ( Friend ) ;
30078: LD_EXP 63
30082: PPUSH
30083: CALL_OW 140
// wait ( 0 0$20 ) ;
30087: LD_INT 700
30089: PPUSH
30090: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30094: LD_EXP 63
30098: PPUSH
30099: LD_INT 9
30101: PPUSH
30102: LD_INT 2
30104: PPUSH
30105: CALL_OW 297
30109: PUSH
30110: LD_INT 30
30112: LESS
30113: IFFALSE 30182
// begin SetSide ( Friend , 8 ) ;
30115: LD_EXP 63
30119: PPUSH
30120: LD_INT 8
30122: PPUSH
30123: CALL_OW 235
// if IsInUnit ( Friend ) then
30127: LD_EXP 63
30131: PPUSH
30132: CALL_OW 310
30136: IFFALSE 30147
// ComExitBuilding ( Friend ) ;
30138: LD_EXP 63
30142: PPUSH
30143: CALL_OW 122
// if IsDriver ( Friend ) then
30147: LD_EXP 63
30151: PPUSH
30152: CALL 102308 0 1
30156: IFFALSE 30167
// ComExitVehicle ( Friend ) ;
30158: LD_EXP 63
30162: PPUSH
30163: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30167: LD_EXP 63
30171: PPUSH
30172: LD_INT 9
30174: PPUSH
30175: LD_INT 2
30177: PPUSH
30178: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30182: LD_INT 1050
30184: PPUSH
30185: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30189: LD_INT 22
30191: PUSH
30192: LD_INT 1
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 34
30201: PUSH
30202: LD_INT 8
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: PPUSH
30213: CALL_OW 69
30217: NOT
30218: IFFALSE 30540
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30220: LD_ADDR_VAR 0 3
30224: PUSH
30225: LD_INT 22
30227: PUSH
30228: LD_INT 1
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 26
30237: PUSH
30238: LD_INT 1
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 3
30247: PUSH
30248: LD_INT 25
30250: PUSH
30251: LD_INT 12
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 25
30260: PUSH
30261: LD_INT 16
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: EMPTY
30269: LIST
30270: LIST
30271: LIST
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: LIST
30277: PPUSH
30278: CALL_OW 69
30282: PUSH
30283: LD_EXP 40
30287: PUSH
30288: LD_EXP 42
30292: PUSH
30293: LD_EXP 56
30297: PUSH
30298: LD_EXP 43
30302: PUSH
30303: LD_EXP 44
30307: PUSH
30308: LD_EXP 45
30312: PUSH
30313: LD_EXP 46
30317: PUSH
30318: LD_EXP 47
30322: PUSH
30323: LD_EXP 48
30327: PUSH
30328: LD_EXP 49
30332: PUSH
30333: LD_EXP 50
30337: PUSH
30338: LD_EXP 51
30342: PUSH
30343: LD_EXP 52
30347: PUSH
30348: LD_EXP 53
30352: PUSH
30353: LD_EXP 54
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: LIST
30373: LIST
30374: DIFF
30375: ST_TO_ADDR
// DialogueOn ;
30376: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30380: LD_EXP 65
30384: PPUSH
30385: LD_STRING D16a-Pla-1
30387: PPUSH
30388: CALL_OW 94
// if Stevens then
30392: LD_EXP 42
30396: IFFALSE 30412
// Say ( Stevens , D16a-Huck-1 ) else
30398: LD_EXP 42
30402: PPUSH
30403: LD_STRING D16a-Huck-1
30405: PPUSH
30406: CALL_OW 88
30410: GO 30454
// if Baker then
30412: LD_EXP 56
30416: IFFALSE 30432
// Say ( Baker , D16a-Huck-1 ) else
30418: LD_EXP 56
30422: PPUSH
30423: LD_STRING D16a-Huck-1
30425: PPUSH
30426: CALL_OW 88
30430: GO 30454
// if tmp then
30432: LD_VAR 0 3
30436: IFFALSE 30454
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30438: LD_VAR 0 3
30442: PUSH
30443: LD_INT 1
30445: ARRAY
30446: PPUSH
30447: LD_STRING D16a-Sol1-1
30449: PPUSH
30450: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30454: LD_EXP 63
30458: PPUSH
30459: CALL_OW 255
30463: PUSH
30464: LD_INT 8
30466: EQUAL
30467: IFFALSE 30483
// Say ( JMM , D16a-JMM-1 ) else
30469: LD_EXP 40
30473: PPUSH
30474: LD_STRING D16a-JMM-1
30476: PPUSH
30477: CALL_OW 88
30481: GO 30519
// begin Say ( JMM , D16a-JMM-1a ) ;
30483: LD_EXP 40
30487: PPUSH
30488: LD_STRING D16a-JMM-1a
30490: PPUSH
30491: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
30495: LD_EXP 63
30499: PPUSH
30500: LD_STRING D16a-Friend-1
30502: PPUSH
30503: CALL_OW 88
// SetSide ( Friend , 3 ) ;
30507: LD_EXP 63
30511: PPUSH
30512: LD_INT 3
30514: PPUSH
30515: CALL_OW 235
// end ; DialogueOff ;
30519: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
30523: LD_VAR 0 1
30527: PPUSH
30528: LD_INT 60
30530: PPUSH
30531: LD_INT 95
30533: PPUSH
30534: CALL_OW 116
// end else
30538: GO 30560
// begin DialogueOn ;
30540: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
30544: LD_EXP 65
30548: PPUSH
30549: LD_STRING D16c-Pla-
30551: PPUSH
30552: CALL_OW 94
// DialogueOff ;
30556: CALL_OW 7
// end ; end else
30560: GO 30661
// begin wait ( 3 3$00 ) ;
30562: LD_INT 6300
30564: PPUSH
30565: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30569: LD_INT 22
30571: PUSH
30572: LD_INT 1
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 34
30581: PUSH
30582: LD_INT 8
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PPUSH
30593: CALL_OW 69
30597: NOT
30598: IFFALSE 30641
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
30600: LD_EXP 65
30604: PPUSH
30605: LD_STRING D16b-Pla-1
30607: PPUSH
30608: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
30612: LD_EXP 40
30616: PPUSH
30617: LD_STRING D16b-JMM-
30619: PPUSH
30620: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
30624: LD_VAR 0 1
30628: PPUSH
30629: LD_INT 60
30631: PPUSH
30632: LD_INT 95
30634: PPUSH
30635: CALL_OW 116
// end else
30639: GO 30661
// begin DialogueOn ;
30641: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30645: LD_EXP 65
30649: PPUSH
30650: LD_STRING D16c-Pla-1
30652: PPUSH
30653: CALL_OW 94
// DialogueOff ;
30657: CALL_OW 7
// end ; end ; end ;
30661: PPOPN 3
30663: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
30664: LD_EXP 14
30668: PUSH
30669: LD_INT 126000
30671: GREATEREQUAL
30672: PUSH
30673: LD_EXP 23
30677: NOT
30678: AND
30679: PUSH
30680: LD_EXP 76
30684: PPUSH
30685: CALL_OW 302
30689: AND
30690: IFFALSE 31048
30692: GO 30694
30694: DISABLE
30695: LD_INT 0
30697: PPUSH
// begin missionStage = 11 ;
30698: LD_ADDR_EXP 15
30702: PUSH
30703: LD_INT 11
30705: ST_TO_ADDR
// DialogueOn ;
30706: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
30710: LD_EXP 76
30714: PPUSH
30715: LD_STRING D9-Roth-1
30717: PPUSH
30718: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
30722: LD_EXP 40
30726: PPUSH
30727: LD_STRING D9-JMM-1
30729: PPUSH
30730: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
30734: LD_EXP 76
30738: PPUSH
30739: LD_STRING D9-Roth-2
30741: PPUSH
30742: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
30746: LD_EXP 76
30750: PPUSH
30751: LD_STRING D9-Roth-2a
30753: PPUSH
30754: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
30758: LD_EXP 65
30762: PPUSH
30763: LD_STRING D9-Pla-2
30765: PPUSH
30766: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
30770: LD_EXP 76
30774: PPUSH
30775: LD_STRING D9-Roth-3
30777: PPUSH
30778: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
30782: LD_EXP 65
30786: PPUSH
30787: LD_STRING D9-Pla-3
30789: PPUSH
30790: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
30794: LD_EXP 76
30798: PPUSH
30799: LD_STRING D9-Roth-4
30801: PPUSH
30802: CALL_OW 94
// dec = Query ( Q9 ) ;
30806: LD_ADDR_VAR 0 1
30810: PUSH
30811: LD_STRING Q9
30813: PPUSH
30814: CALL_OW 97
30818: ST_TO_ADDR
// if dec = 1 then
30819: LD_VAR 0 1
30823: PUSH
30824: LD_INT 1
30826: EQUAL
30827: IFFALSE 30841
// SayRadio ( Roth , D9a-Roth-1 ) ;
30829: LD_EXP 76
30833: PPUSH
30834: LD_STRING D9a-Roth-1
30836: PPUSH
30837: CALL_OW 94
// if dec = 2 then
30841: LD_VAR 0 1
30845: PUSH
30846: LD_INT 2
30848: EQUAL
30849: IFFALSE 30875
// begin Say ( JMM , D9b-JMM-1 ) ;
30851: LD_EXP 40
30855: PPUSH
30856: LD_STRING D9b-JMM-1
30858: PPUSH
30859: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
30863: LD_EXP 76
30867: PPUSH
30868: LD_STRING D9b-Roth-1
30870: PPUSH
30871: CALL_OW 94
// end ; if dec = 3 then
30875: LD_VAR 0 1
30879: PUSH
30880: LD_INT 3
30882: EQUAL
30883: IFFALSE 30945
// begin Say ( JMM , D9c-JMM-1 ) ;
30885: LD_EXP 40
30889: PPUSH
30890: LD_STRING D9c-JMM-1
30892: PPUSH
30893: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
30897: LD_EXP 76
30901: PPUSH
30902: LD_STRING D9c-Roth-1
30904: PPUSH
30905: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
30909: LD_EXP 40
30913: PPUSH
30914: LD_STRING D9c-JMM-2
30916: PPUSH
30917: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
30921: LD_EXP 76
30925: PPUSH
30926: LD_STRING D9c-Roth-2
30928: PPUSH
30929: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
30933: LD_EXP 40
30937: PPUSH
30938: LD_STRING D9c-JMM-3
30940: PPUSH
30941: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
30945: LD_EXP 76
30949: PPUSH
30950: LD_STRING D9c-Roth-3
30952: PPUSH
30953: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
30957: LD_EXP 76
30961: PPUSH
30962: LD_STRING D9cont-Roth-1
30964: PPUSH
30965: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
30969: LD_EXP 40
30973: PPUSH
30974: LD_STRING D9cont-JMM-1
30976: PPUSH
30977: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
30981: LD_EXP 76
30985: PPUSH
30986: LD_STRING D9cont-Roth-2
30988: PPUSH
30989: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
30993: LD_EXP 40
30997: PPUSH
30998: LD_STRING D9cont-JMM-2
31000: PPUSH
31001: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31005: LD_EXP 76
31009: PPUSH
31010: LD_STRING D9cont-Roth-3
31012: PPUSH
31013: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31017: LD_EXP 40
31021: PPUSH
31022: LD_STRING D9cont-JMM-3
31024: PPUSH
31025: CALL_OW 88
// DialogueOff ;
31029: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31033: LD_STRING M3
31035: PPUSH
31036: CALL_OW 337
// allianceActive := true ;
31040: LD_ADDR_EXP 31
31044: PUSH
31045: LD_INT 1
31047: ST_TO_ADDR
// end ;
31048: PPOPN 1
31050: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31051: LD_INT 1
31053: PPUSH
31054: LD_INT 126
31056: PPUSH
31057: CALL_OW 292
31061: PUSH
31062: LD_EXP 65
31066: PPUSH
31067: CALL_OW 310
31071: AND
31072: IFFALSE 31152
31074: GO 31076
31076: DISABLE
31077: LD_INT 0
31079: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31080: LD_EXP 65
31084: PPUSH
31085: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31089: LD_ADDR_VAR 0 1
31093: PUSH
31094: LD_INT 4
31096: PPUSH
31097: LD_INT 22
31099: PUSH
31100: LD_INT 1
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PPUSH
31107: CALL_OW 70
31111: PPUSH
31112: LD_EXP 65
31116: PPUSH
31117: CALL_OW 74
31121: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31122: LD_EXP 65
31126: PPUSH
31127: LD_VAR 0 1
31131: PUSH
31132: LD_INT 1
31134: ARRAY
31135: PPUSH
31136: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
31140: LD_EXP 65
31144: PPUSH
31145: LD_STRING D18-Pla-1
31147: PPUSH
31148: CALL_OW 88
// end ;
31152: PPOPN 1
31154: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31155: LD_EXP 65
31159: PPUSH
31160: CALL_OW 301
31164: PUSH
31165: LD_EXP 68
31169: PPUSH
31170: CALL_OW 301
31174: AND
31175: PUSH
31176: LD_INT 22
31178: PUSH
31179: LD_INT 3
31181: PUSH
31182: EMPTY
31183: LIST
31184: LIST
31185: PUSH
31186: LD_INT 21
31188: PUSH
31189: LD_INT 1
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 50
31198: PUSH
31199: EMPTY
31200: LIST
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: LIST
31206: PPUSH
31207: CALL_OW 69
31211: PUSH
31212: LD_INT 7
31214: PUSH
31215: LD_INT 8
31217: PUSH
31218: LD_INT 9
31220: PUSH
31221: LD_INT 10
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: LIST
31228: LIST
31229: PUSH
31230: LD_OWVAR 67
31234: ARRAY
31235: LESS
31236: AND
31237: IFFALSE 32030
31239: GO 31241
31241: DISABLE
31242: LD_INT 0
31244: PPUSH
31245: PPUSH
31246: PPUSH
31247: PPUSH
// begin MC_Kill ( 2 ) ;
31248: LD_INT 2
31250: PPUSH
31251: CALL 36835 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31255: LD_INT 1
31257: PPUSH
31258: LD_INT 3
31260: PPUSH
31261: LD_INT 1
31263: PPUSH
31264: LD_INT 1
31266: PPUSH
31267: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31271: LD_ADDR_VAR 0 2
31275: PUSH
31276: LD_INT 22
31278: PUSH
31279: LD_INT 3
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 21
31288: PUSH
31289: LD_INT 1
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 50
31298: PUSH
31299: EMPTY
31300: LIST
31301: PUSH
31302: LD_INT 26
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: PPUSH
31318: CALL_OW 69
31322: ST_TO_ADDR
// if not tmp then
31323: LD_VAR 0 2
31327: NOT
31328: IFFALSE 31384
// begin uc_side = 3 ;
31330: LD_ADDR_OWVAR 20
31334: PUSH
31335: LD_INT 3
31337: ST_TO_ADDR
// uc_nation = 3 ;
31338: LD_ADDR_OWVAR 21
31342: PUSH
31343: LD_INT 3
31345: ST_TO_ADDR
// hc_name =  ;
31346: LD_ADDR_OWVAR 26
31350: PUSH
31351: LD_STRING 
31353: ST_TO_ADDR
// hc_gallery =  ;
31354: LD_ADDR_OWVAR 33
31358: PUSH
31359: LD_STRING 
31361: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31362: LD_INT 1
31364: PPUSH
31365: LD_INT 10
31367: PPUSH
31368: CALL_OW 381
// tmp = CreateHuman ;
31372: LD_ADDR_VAR 0 2
31376: PUSH
31377: CALL_OW 44
31381: ST_TO_ADDR
// end else
31382: GO 31398
// tmp := tmp [ 1 ] ;
31384: LD_ADDR_VAR 0 2
31388: PUSH
31389: LD_VAR 0 2
31393: PUSH
31394: LD_INT 1
31396: ARRAY
31397: ST_TO_ADDR
// DialogueOn ;
31398: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31402: LD_VAR 0 2
31406: PPUSH
31407: LD_STRING DSurrenderRussians-RSol1-1a
31409: PPUSH
31410: CALL_OW 94
// DialogueOff ;
31414: CALL_OW 7
// russianDestroyed := true ;
31418: LD_ADDR_EXP 21
31422: PUSH
31423: LD_INT 1
31425: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
31426: LD_ADDR_VAR 0 1
31430: PUSH
31431: LD_INT 22
31433: PUSH
31434: LD_INT 6
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PPUSH
31441: CALL_OW 69
31445: PUSH
31446: FOR_IN
31447: IFFALSE 31460
// KillUnit ( i ) ;
31449: LD_VAR 0 1
31453: PPUSH
31454: CALL_OW 66
31458: GO 31446
31460: POP
31461: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
31462: LD_INT 22
31464: PUSH
31465: LD_INT 3
31467: PUSH
31468: EMPTY
31469: LIST
31470: LIST
31471: PUSH
31472: LD_INT 21
31474: PUSH
31475: LD_INT 1
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PPUSH
31486: CALL_OW 69
31490: PPUSH
31491: CALL_OW 122
// wait ( 0 0$1 ) ;
31495: LD_INT 35
31497: PPUSH
31498: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
31502: LD_INT 22
31504: PUSH
31505: LD_INT 3
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: PUSH
31512: LD_INT 21
31514: PUSH
31515: LD_INT 1
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PPUSH
31526: CALL_OW 69
31530: PPUSH
31531: LD_INT 25
31533: PPUSH
31534: CALL_OW 173
// wait ( 0 0$35 ) ;
31538: LD_INT 1225
31540: PPUSH
31541: CALL_OW 67
// PrepareOmarInvasion ;
31545: CALL 14644 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
31549: LD_ADDR_VAR 0 2
31553: PUSH
31554: LD_EXP 94
31558: PPUSH
31559: CALL_OW 250
31563: PUSH
31564: LD_EXP 94
31568: PPUSH
31569: CALL_OW 251
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
31578: LD_VAR 0 2
31582: PUSH
31583: LD_INT 1
31585: ARRAY
31586: PPUSH
31587: LD_VAR 0 2
31591: PUSH
31592: LD_INT 2
31594: ARRAY
31595: PPUSH
31596: LD_INT 1
31598: PPUSH
31599: LD_INT 8
31601: NEG
31602: PPUSH
31603: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
31607: LD_EXP 94
31611: PPUSH
31612: CALL_OW 87
// DialogueOn ;
31616: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
31620: LD_EXP 40
31624: PPUSH
31625: LD_STRING D19-JMM-1
31627: PPUSH
31628: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
31632: LD_ADDR_VAR 0 3
31636: PUSH
31637: LD_INT 22
31639: PUSH
31640: LD_INT 1
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 26
31649: PUSH
31650: LD_INT 1
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 2
31659: PUSH
31660: LD_INT 25
31662: PUSH
31663: LD_INT 1
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 25
31672: PUSH
31673: LD_INT 2
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 25
31682: PUSH
31683: LD_INT 3
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 25
31692: PUSH
31693: LD_INT 4
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 25
31702: PUSH
31703: LD_INT 5
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 25
31712: PUSH
31713: LD_INT 8
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: LIST
31733: PPUSH
31734: CALL_OW 69
31738: PUSH
31739: LD_EXP 40
31743: PUSH
31744: LD_EXP 41
31748: PUSH
31749: LD_EXP 42
31753: PUSH
31754: LD_EXP 43
31758: PUSH
31759: LD_EXP 44
31763: PUSH
31764: LD_EXP 45
31768: PUSH
31769: LD_EXP 46
31773: PUSH
31774: LD_EXP 47
31778: PUSH
31779: LD_EXP 48
31783: PUSH
31784: LD_EXP 49
31788: PUSH
31789: LD_EXP 50
31793: PUSH
31794: LD_EXP 51
31798: PUSH
31799: LD_EXP 52
31803: PUSH
31804: LD_EXP 53
31808: PUSH
31809: LD_EXP 54
31813: PUSH
31814: LD_EXP 55
31818: PUSH
31819: LD_EXP 56
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: LIST
31828: LIST
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: DIFF
31843: ST_TO_ADDR
// if tmp2 then
31844: LD_VAR 0 3
31848: IFFALSE 31866
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
31850: LD_VAR 0 3
31854: PUSH
31855: LD_INT 1
31857: ARRAY
31858: PPUSH
31859: LD_STRING D19-Sol1-1
31861: PPUSH
31862: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
31866: LD_EXP 40
31870: PPUSH
31871: LD_STRING D19-JMM-2
31873: PPUSH
31874: CALL_OW 88
// DialogueOff ;
31878: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
31882: LD_VAR 0 2
31886: PUSH
31887: LD_INT 1
31889: ARRAY
31890: PPUSH
31891: LD_VAR 0 2
31895: PUSH
31896: LD_INT 2
31898: ARRAY
31899: PPUSH
31900: LD_INT 1
31902: PPUSH
31903: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
31907: LD_STRING M5
31909: PPUSH
31910: CALL_OW 337
// omarOnMotherLode := false ;
31914: LD_ADDR_VAR 0 4
31918: PUSH
31919: LD_INT 0
31921: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31922: LD_INT 35
31924: PPUSH
31925: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
31929: LD_EXP 94
31933: PPUSH
31934: LD_INT 215
31936: PPUSH
31937: LD_INT 100
31939: PPUSH
31940: CALL_OW 297
31944: PUSH
31945: LD_INT 10
31947: LESS
31948: PUSH
31949: LD_VAR 0 4
31953: NOT
31954: AND
31955: IFFALSE 31989
// begin omarOnMotherLode := true ;
31957: LD_ADDR_VAR 0 4
31961: PUSH
31962: LD_INT 1
31964: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
31965: LD_EXP 40
31969: PPUSH
31970: LD_STRING D19b-JMM-1
31972: PPUSH
31973: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
31977: LD_EXP 94
31981: PPUSH
31982: LD_STRING DOmarContam-Omar-1
31984: PPUSH
31985: CALL_OW 88
// end ; until IsDead ( Omar ) ;
31989: LD_EXP 94
31993: PPUSH
31994: CALL_OW 301
31998: IFFALSE 31922
// Say ( JMM , D19a-JMM-1 ) ;
32000: LD_EXP 40
32004: PPUSH
32005: LD_STRING D19a-JMM-1
32007: PPUSH
32008: CALL_OW 88
// if Heike then
32012: LD_EXP 95
32016: IFFALSE 32030
// Say ( Heike , D19a-Hke-1 ) ;
32018: LD_EXP 95
32022: PPUSH
32023: LD_STRING D19a-Hke-1
32025: PPUSH
32026: CALL_OW 88
// end ;
32030: PPOPN 4
32032: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
32033: LD_INT 22
32035: PUSH
32036: LD_INT 3
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PUSH
32043: LD_INT 21
32045: PUSH
32046: LD_INT 1
32048: PUSH
32049: EMPTY
32050: LIST
32051: LIST
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PPUSH
32057: CALL_OW 69
32061: PUSH
32062: LD_EXP 21
32066: AND
32067: IFFALSE 32135
32069: GO 32071
32071: DISABLE
32072: LD_INT 0
32074: PPUSH
32075: PPUSH
// begin enable ;
32076: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32077: LD_ADDR_VAR 0 2
32081: PUSH
32082: LD_INT 25
32084: PPUSH
32085: LD_INT 22
32087: PUSH
32088: LD_INT 3
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PPUSH
32095: CALL_OW 70
32099: ST_TO_ADDR
// if not tmp then
32100: LD_VAR 0 2
32104: NOT
32105: IFFALSE 32109
// exit ;
32107: GO 32135
// for i in tmp do
32109: LD_ADDR_VAR 0 1
32113: PUSH
32114: LD_VAR 0 2
32118: PUSH
32119: FOR_IN
32120: IFFALSE 32133
// RemoveUnit ( i ) ;
32122: LD_VAR 0 1
32126: PPUSH
32127: CALL_OW 64
32131: GO 32119
32133: POP
32134: POP
// end ;
32135: PPOPN 2
32137: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32138: LD_INT 22
32140: PUSH
32141: LD_INT 7
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 21
32150: PUSH
32151: LD_INT 1
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PPUSH
32162: CALL_OW 69
32166: PUSH
32167: LD_INT 6
32169: LESS
32170: IFFALSE 32638
32172: GO 32174
32174: DISABLE
32175: LD_INT 0
32177: PPUSH
32178: PPUSH
// begin MC_Kill ( 1 ) ;
32179: LD_INT 1
32181: PPUSH
32182: CALL 36835 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32186: LD_INT 7
32188: PPUSH
32189: LD_INT 1
32191: PPUSH
32192: LD_INT 1
32194: PPUSH
32195: LD_INT 1
32197: PPUSH
32198: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32202: LD_ADDR_VAR 0 1
32206: PUSH
32207: LD_INT 22
32209: PUSH
32210: LD_INT 7
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 26
32219: PUSH
32220: LD_INT 1
32222: PUSH
32223: EMPTY
32224: LIST
32225: LIST
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PPUSH
32231: CALL_OW 69
32235: PUSH
32236: LD_EXP 76
32240: DIFF
32241: ST_TO_ADDR
// if tmp then
32242: LD_VAR 0 1
32246: IFFALSE 32264
// tmp := tmp [ 1 ] else
32248: LD_ADDR_VAR 0 1
32252: PUSH
32253: LD_VAR 0 1
32257: PUSH
32258: LD_INT 1
32260: ARRAY
32261: ST_TO_ADDR
32262: GO 32300
// begin uc_side := 7 ;
32264: LD_ADDR_OWVAR 20
32268: PUSH
32269: LD_INT 7
32271: ST_TO_ADDR
// uc_nation := 1 ;
32272: LD_ADDR_OWVAR 21
32276: PUSH
32277: LD_INT 1
32279: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32280: LD_INT 1
32282: PPUSH
32283: LD_INT 8
32285: PPUSH
32286: CALL_OW 384
// tmp := CreateHuman ;
32290: LD_ADDR_VAR 0 1
32294: PUSH
32295: CALL_OW 44
32299: ST_TO_ADDR
// end ; DialogueOn ;
32300: CALL_OW 6
// if IsOK ( Roth ) then
32304: LD_EXP 76
32308: PPUSH
32309: CALL_OW 302
32313: IFFALSE 32327
// Say ( JMM , DAb-JMM-1 ) ;
32315: LD_EXP 40
32319: PPUSH
32320: LD_STRING DAb-JMM-1
32322: PPUSH
32323: CALL_OW 88
// if IsOK ( Roth ) then
32327: LD_EXP 76
32331: PPUSH
32332: CALL_OW 302
32336: IFFALSE 32360
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32338: LD_EXP 76
32342: PPUSH
32343: LD_STRING DSurrenderAlliance-Roth-1
32345: PPUSH
32346: CALL_OW 88
// RothCaptured := true ;
32350: LD_ADDR_EXP 33
32354: PUSH
32355: LD_INT 1
32357: ST_TO_ADDR
// end else
32358: GO 32372
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32360: LD_VAR 0 1
32364: PPUSH
32365: LD_STRING DSurrenderAlliance-Sci1-1
32367: PPUSH
32368: CALL_OW 88
// DialogueOff ;
32372: CALL_OW 7
// allianceDestroyed := true ;
32376: LD_ADDR_EXP 23
32380: PUSH
32381: LD_INT 1
32383: ST_TO_ADDR
// if capturedUnit = 0 then
32384: LD_EXP 34
32388: PUSH
32389: LD_INT 0
32391: EQUAL
32392: IFFALSE 32401
// SetAchievement ( ACH_ALLIANCE ) ;
32394: LD_STRING ACH_ALLIANCE
32396: PPUSH
32397: CALL_OW 543
// if trueAmericans then
32401: LD_EXP 35
32405: IFFALSE 32481
// begin if trueAmericans = 1 then
32407: LD_EXP 35
32411: PUSH
32412: LD_INT 1
32414: EQUAL
32415: IFFALSE 32431
// Say ( JMM , DAb-JMM-1a ) else
32417: LD_EXP 40
32421: PPUSH
32422: LD_STRING DAb-JMM-1a
32424: PPUSH
32425: CALL_OW 88
32429: GO 32443
// Say ( JMM , DAb-JMM-1b ) ;
32431: LD_EXP 40
32435: PPUSH
32436: LD_STRING DAb-JMM-1b
32438: PPUSH
32439: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
32443: LD_EXP 35
32447: PPUSH
32448: CALL_OW 87
// for i in trueAmericans do
32452: LD_ADDR_VAR 0 2
32456: PUSH
32457: LD_EXP 35
32461: PUSH
32462: FOR_IN
32463: IFFALSE 32479
// SetSide ( i , 1 ) ;
32465: LD_VAR 0 2
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: CALL_OW 235
32477: GO 32462
32479: POP
32480: POP
// end ; repeat wait ( 0 0$1 ) ;
32481: LD_INT 35
32483: PPUSH
32484: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
32488: LD_ADDR_VAR 0 2
32492: PUSH
32493: LD_INT 22
32495: PUSH
32496: LD_INT 7
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 21
32505: PUSH
32506: LD_INT 1
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PPUSH
32517: CALL_OW 69
32521: PUSH
32522: FOR_IN
32523: IFFALSE 32605
// begin if IsInUnit ( i ) then
32525: LD_VAR 0 2
32529: PPUSH
32530: CALL_OW 310
32534: IFFALSE 32545
// ComExitBuilding ( i ) ;
32536: LD_VAR 0 2
32540: PPUSH
32541: CALL_OW 122
// if IsDriver ( i ) then
32545: LD_VAR 0 2
32549: PPUSH
32550: CALL 102308 0 1
32554: IFFALSE 32565
// ComExitVehicle ( i ) ;
32556: LD_VAR 0 2
32560: PPUSH
32561: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
32565: LD_VAR 0 2
32569: PPUSH
32570: LD_INT 26
32572: PPUSH
32573: CALL_OW 308
32577: NOT
32578: IFFALSE 32594
// AddComMoveToArea ( i , allianceEscapeArea ) else
32580: LD_VAR 0 2
32584: PPUSH
32585: LD_INT 26
32587: PPUSH
32588: CALL_OW 173
32592: GO 32603
// RemoveUnit ( i ) ;
32594: LD_VAR 0 2
32598: PPUSH
32599: CALL_OW 64
// end ;
32603: GO 32522
32605: POP
32606: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
32607: LD_INT 22
32609: PUSH
32610: LD_INT 7
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 21
32619: PUSH
32620: LD_INT 1
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PPUSH
32631: CALL_OW 69
32635: NOT
32636: IFFALSE 32481
// end ;
32638: PPOPN 2
32640: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
32641: LD_INT 0
32643: PPUSH
32644: PPUSH
// if not unit then
32645: LD_VAR 0 1
32649: NOT
32650: IFFALSE 32654
// exit ;
32652: GO 34152
// DoNotAttack ( 7 , unit ) ;
32654: LD_INT 7
32656: PPUSH
32657: LD_VAR 0 1
32661: PPUSH
32662: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
32666: LD_VAR 0 1
32670: PPUSH
32671: LD_INT 260
32673: PPUSH
32674: LD_INT 235
32676: PPUSH
32677: LD_INT 3
32679: PPUSH
32680: LD_INT 1
32682: PPUSH
32683: CALL_OW 483
// SetSide ( unit , 4 ) ;
32687: LD_VAR 0 1
32691: PPUSH
32692: LD_INT 4
32694: PPUSH
32695: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
32699: LD_ADDR_EXP 34
32703: PUSH
32704: LD_EXP 34
32708: PUSH
32709: LD_INT 1
32711: PLUS
32712: ST_TO_ADDR
// wait ( 0 0$2 ) ;
32713: LD_INT 70
32715: PPUSH
32716: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
32720: LD_INT 260
32722: PPUSH
32723: LD_INT 235
32725: PPUSH
32726: LD_INT 1
32728: PPUSH
32729: LD_INT 8
32731: NEG
32732: PPUSH
32733: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
32737: LD_VAR 0 1
32741: PPUSH
32742: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
32746: LD_VAR 0 1
32750: PPUSH
32751: LD_EXP 76
32755: PPUSH
32756: CALL_OW 119
// DialogueOn ;
32760: CALL_OW 6
// case unit of JMM :
32764: LD_VAR 0 1
32768: PUSH
32769: LD_EXP 40
32773: DOUBLE
32774: EQUAL
32775: IFTRUE 32779
32777: GO 32794
32779: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
32780: LD_EXP 40
32784: PPUSH
32785: LD_STRING DA1-JMM-1
32787: PPUSH
32788: CALL_OW 91
32792: GO 33236
32794: LD_EXP 41
32798: DOUBLE
32799: EQUAL
32800: IFTRUE 32804
32802: GO 32819
32804: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
32805: LD_EXP 41
32809: PPUSH
32810: LD_STRING DA1-Joan-1
32812: PPUSH
32813: CALL_OW 91
32817: GO 33236
32819: LD_EXP 43
32823: DOUBLE
32824: EQUAL
32825: IFTRUE 32829
32827: GO 32844
32829: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
32830: LD_EXP 43
32834: PPUSH
32835: LD_STRING DA1-Lisa-1
32837: PPUSH
32838: CALL_OW 91
32842: GO 33236
32844: LD_EXP 44
32848: DOUBLE
32849: EQUAL
32850: IFTRUE 32854
32852: GO 32869
32854: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
32855: LD_EXP 44
32859: PPUSH
32860: LD_STRING DA1-Don-1
32862: PPUSH
32863: CALL_OW 91
32867: GO 33236
32869: LD_EXP 51
32873: DOUBLE
32874: EQUAL
32875: IFTRUE 32879
32877: GO 32894
32879: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
32880: LD_EXP 51
32884: PPUSH
32885: LD_STRING DA1-Corn-1
32887: PPUSH
32888: CALL_OW 91
32892: GO 33236
32894: LD_EXP 47
32898: DOUBLE
32899: EQUAL
32900: IFTRUE 32904
32902: GO 32919
32904: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
32905: LD_EXP 47
32909: PPUSH
32910: LD_STRING DA1-Den-1
32912: PPUSH
32913: CALL_OW 91
32917: GO 33236
32919: LD_EXP 45
32923: DOUBLE
32924: EQUAL
32925: IFTRUE 32929
32927: GO 32944
32929: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
32930: LD_EXP 45
32934: PPUSH
32935: LD_STRING DA1-Bobby-1
32937: PPUSH
32938: CALL_OW 91
32942: GO 33236
32944: LD_EXP 49
32948: DOUBLE
32949: EQUAL
32950: IFTRUE 32954
32952: GO 32969
32954: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
32955: LD_EXP 49
32959: PPUSH
32960: LD_STRING DA1-Glad-1
32962: PPUSH
32963: CALL_OW 91
32967: GO 33236
32969: LD_EXP 46
32973: DOUBLE
32974: EQUAL
32975: IFTRUE 32979
32977: GO 32994
32979: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
32980: LD_EXP 46
32984: PPUSH
32985: LD_STRING DA1-Cyrus-1
32987: PPUSH
32988: CALL_OW 91
32992: GO 33236
32994: LD_EXP 42
32998: DOUBLE
32999: EQUAL
33000: IFTRUE 33004
33002: GO 33019
33004: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
33005: LD_EXP 42
33009: PPUSH
33010: LD_STRING DA1-Huck-1
33012: PPUSH
33013: CALL_OW 91
33017: GO 33236
33019: LD_EXP 56
33023: DOUBLE
33024: EQUAL
33025: IFTRUE 33029
33027: GO 33044
33029: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
33030: LD_EXP 56
33034: PPUSH
33035: LD_STRING DA1-Huck-1
33037: PPUSH
33038: CALL_OW 91
33042: GO 33236
33044: LD_EXP 48
33048: DOUBLE
33049: EQUAL
33050: IFTRUE 33054
33052: GO 33069
33054: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33055: LD_EXP 48
33059: PPUSH
33060: LD_STRING DA1-Brown-1
33062: PPUSH
33063: CALL_OW 91
33067: GO 33236
33069: LD_EXP 52
33073: DOUBLE
33074: EQUAL
33075: IFTRUE 33079
33077: GO 33094
33079: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33080: LD_EXP 52
33084: PPUSH
33085: LD_STRING DA1-Gary-1
33087: PPUSH
33088: CALL_OW 91
33092: GO 33236
33094: LD_EXP 55
33098: DOUBLE
33099: EQUAL
33100: IFTRUE 33104
33102: GO 33119
33104: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33105: LD_EXP 55
33109: PPUSH
33110: LD_STRING DA1-Con-1
33112: PPUSH
33113: CALL_OW 91
33117: GO 33236
33119: LD_EXP 61
33123: DOUBLE
33124: EQUAL
33125: IFTRUE 33129
33127: GO 33144
33129: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33130: LD_EXP 61
33134: PPUSH
33135: LD_STRING DA1-Kurt-1
33137: PPUSH
33138: CALL_OW 91
33142: GO 33236
33144: LD_EXP 54
33148: DOUBLE
33149: EQUAL
33150: IFTRUE 33154
33152: GO 33169
33154: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33155: LD_EXP 54
33159: PPUSH
33160: LD_STRING DA1-Yam-1
33162: PPUSH
33163: CALL_OW 91
33167: GO 33236
33169: LD_EXP 53
33173: DOUBLE
33174: EQUAL
33175: IFTRUE 33179
33177: GO 33194
33179: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33180: LD_EXP 53
33184: PPUSH
33185: LD_STRING DA1-Frank-1
33187: PPUSH
33188: CALL_OW 91
33192: GO 33236
33194: POP
// begin if GetSex ( unit ) = sex_male then
33195: LD_VAR 0 1
33199: PPUSH
33200: CALL_OW 258
33204: PUSH
33205: LD_INT 1
33207: EQUAL
33208: IFFALSE 33224
// ForceSay ( unit , DA1-Sol1-1 ) else
33210: LD_VAR 0 1
33214: PPUSH
33215: LD_STRING DA1-Sol1-1
33217: PPUSH
33218: CALL_OW 91
33222: GO 33236
// ForceSay ( unit , DA1-FSol1-1 ) ;
33224: LD_VAR 0 1
33228: PPUSH
33229: LD_STRING DA1-FSol1-1
33231: PPUSH
33232: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33236: LD_EXP 76
33240: PPUSH
33241: LD_STRING DA-Roth-1
33243: PPUSH
33244: CALL_OW 88
// if capturedUnit = 1 then
33248: LD_EXP 34
33252: PUSH
33253: LD_INT 1
33255: EQUAL
33256: IFFALSE 33284
// begin Say ( Simms , DA-Sim-1 ) ;
33258: LD_EXP 77
33262: PPUSH
33263: LD_STRING DA-Sim-1
33265: PPUSH
33266: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33270: LD_EXP 76
33274: PPUSH
33275: LD_STRING DA-Roth-2
33277: PPUSH
33278: CALL_OW 88
// end else
33282: GO 33296
// Say ( Simms , DA-Sim-2 ) ;
33284: LD_EXP 77
33288: PPUSH
33289: LD_STRING DA-Sim-2
33291: PPUSH
33292: CALL_OW 88
// case unit of JMM :
33296: LD_VAR 0 1
33300: PUSH
33301: LD_EXP 40
33305: DOUBLE
33306: EQUAL
33307: IFTRUE 33311
33309: GO 33326
33311: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33312: LD_EXP 40
33316: PPUSH
33317: LD_STRING DA1-JMM-1a
33319: PPUSH
33320: CALL_OW 91
33324: GO 33833
33326: LD_EXP 41
33330: DOUBLE
33331: EQUAL
33332: IFTRUE 33336
33334: GO 33351
33336: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33337: LD_EXP 41
33341: PPUSH
33342: LD_STRING DA1-Joan-1a
33344: PPUSH
33345: CALL_OW 91
33349: GO 33833
33351: LD_EXP 43
33355: DOUBLE
33356: EQUAL
33357: IFTRUE 33361
33359: GO 33376
33361: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33362: LD_EXP 43
33366: PPUSH
33367: LD_STRING DA1-Lisa-1a
33369: PPUSH
33370: CALL_OW 91
33374: GO 33833
33376: LD_EXP 44
33380: DOUBLE
33381: EQUAL
33382: IFTRUE 33386
33384: GO 33401
33386: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33387: LD_EXP 44
33391: PPUSH
33392: LD_STRING DA1-Don-1a
33394: PPUSH
33395: CALL_OW 91
33399: GO 33833
33401: LD_EXP 51
33405: DOUBLE
33406: EQUAL
33407: IFTRUE 33411
33409: GO 33426
33411: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33412: LD_EXP 51
33416: PPUSH
33417: LD_STRING DA1-Corn-1a
33419: PPUSH
33420: CALL_OW 91
33424: GO 33833
33426: LD_EXP 47
33430: DOUBLE
33431: EQUAL
33432: IFTRUE 33436
33434: GO 33451
33436: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
33437: LD_EXP 47
33441: PPUSH
33442: LD_STRING DA1-Den-1a
33444: PPUSH
33445: CALL_OW 91
33449: GO 33833
33451: LD_EXP 45
33455: DOUBLE
33456: EQUAL
33457: IFTRUE 33461
33459: GO 33476
33461: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
33462: LD_EXP 45
33466: PPUSH
33467: LD_STRING DA1-Bobby-1a
33469: PPUSH
33470: CALL_OW 91
33474: GO 33833
33476: LD_EXP 49
33480: DOUBLE
33481: EQUAL
33482: IFTRUE 33486
33484: GO 33501
33486: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
33487: LD_EXP 49
33491: PPUSH
33492: LD_STRING DA1-Glad-1a
33494: PPUSH
33495: CALL_OW 91
33499: GO 33833
33501: LD_EXP 46
33505: DOUBLE
33506: EQUAL
33507: IFTRUE 33511
33509: GO 33526
33511: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
33512: LD_EXP 46
33516: PPUSH
33517: LD_STRING DA1-Cyrus-1a
33519: PPUSH
33520: CALL_OW 91
33524: GO 33833
33526: LD_EXP 42
33530: DOUBLE
33531: EQUAL
33532: IFTRUE 33536
33534: GO 33551
33536: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
33537: LD_EXP 42
33541: PPUSH
33542: LD_STRING DA1-Huck-1a
33544: PPUSH
33545: CALL_OW 91
33549: GO 33833
33551: LD_EXP 56
33555: DOUBLE
33556: EQUAL
33557: IFTRUE 33561
33559: GO 33576
33561: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
33562: LD_EXP 56
33566: PPUSH
33567: LD_STRING DA1-Huck-1a
33569: PPUSH
33570: CALL_OW 91
33574: GO 33833
33576: LD_EXP 48
33580: DOUBLE
33581: EQUAL
33582: IFTRUE 33586
33584: GO 33601
33586: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
33587: LD_EXP 48
33591: PPUSH
33592: LD_STRING DA1-Brown-1a
33594: PPUSH
33595: CALL_OW 91
33599: GO 33833
33601: LD_EXP 52
33605: DOUBLE
33606: EQUAL
33607: IFTRUE 33611
33609: GO 33626
33611: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
33612: LD_EXP 52
33616: PPUSH
33617: LD_STRING DA1-Gary-1a
33619: PPUSH
33620: CALL_OW 91
33624: GO 33833
33626: LD_EXP 55
33630: DOUBLE
33631: EQUAL
33632: IFTRUE 33636
33634: GO 33651
33636: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
33637: LD_EXP 55
33641: PPUSH
33642: LD_STRING DA1-Con-1a
33644: PPUSH
33645: CALL_OW 91
33649: GO 33833
33651: LD_EXP 61
33655: DOUBLE
33656: EQUAL
33657: IFTRUE 33661
33659: GO 33676
33661: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
33662: LD_EXP 61
33666: PPUSH
33667: LD_STRING DA1-Kurt-1a
33669: PPUSH
33670: CALL_OW 91
33674: GO 33833
33676: LD_EXP 54
33680: DOUBLE
33681: EQUAL
33682: IFTRUE 33686
33684: GO 33701
33686: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
33687: LD_EXP 54
33691: PPUSH
33692: LD_STRING DA1-Yam-1a
33694: PPUSH
33695: CALL_OW 91
33699: GO 33833
33701: LD_EXP 53
33705: DOUBLE
33706: EQUAL
33707: IFTRUE 33711
33709: GO 33726
33711: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
33712: LD_EXP 53
33716: PPUSH
33717: LD_STRING DA1-Frank-1a
33719: PPUSH
33720: CALL_OW 91
33724: GO 33833
33726: POP
// begin join := rand ( 0 , 1 ) ;
33727: LD_ADDR_VAR 0 3
33731: PUSH
33732: LD_INT 0
33734: PPUSH
33735: LD_INT 1
33737: PPUSH
33738: CALL_OW 12
33742: ST_TO_ADDR
// if join then
33743: LD_VAR 0 3
33747: IFFALSE 33792
// begin if GetSex ( unit ) = sex_male then
33749: LD_VAR 0 1
33753: PPUSH
33754: CALL_OW 258
33758: PUSH
33759: LD_INT 1
33761: EQUAL
33762: IFFALSE 33778
// ForceSay ( unit , DA1-Sol1-1b ) else
33764: LD_VAR 0 1
33768: PPUSH
33769: LD_STRING DA1-Sol1-1b
33771: PPUSH
33772: CALL_OW 91
33776: GO 33790
// ForceSay ( unit , DA1-FSol1-1b ) ;
33778: LD_VAR 0 1
33782: PPUSH
33783: LD_STRING DA1-FSol1-1b
33785: PPUSH
33786: CALL_OW 91
// end else
33790: GO 33833
// begin if GetSex ( unit ) = sex_male then
33792: LD_VAR 0 1
33796: PPUSH
33797: CALL_OW 258
33801: PUSH
33802: LD_INT 1
33804: EQUAL
33805: IFFALSE 33821
// ForceSay ( unit , DA1-Sol1-1a ) else
33807: LD_VAR 0 1
33811: PPUSH
33812: LD_STRING DA1-Sol1-1a
33814: PPUSH
33815: CALL_OW 91
33819: GO 33833
// ForceSay ( unit , DA1-FSol1-1a ) ;
33821: LD_VAR 0 1
33825: PPUSH
33826: LD_STRING DA1-FSol1-1a
33828: PPUSH
33829: CALL_OW 91
// end ; end ; end ; if unit = JMM then
33833: LD_VAR 0 1
33837: PUSH
33838: LD_EXP 40
33842: EQUAL
33843: IFFALSE 33854
// begin YouLost ( JMMCaptured ) ;
33845: LD_STRING JMMCaptured
33847: PPUSH
33848: CALL_OW 104
// exit ;
33852: GO 34152
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
33854: LD_VAR 0 1
33858: PUSH
33859: LD_EXP 44
33863: PUSH
33864: LD_EXP 47
33868: PUSH
33869: LD_EXP 45
33873: PUSH
33874: LD_EXP 42
33878: PUSH
33879: LD_EXP 56
33883: PUSH
33884: LD_EXP 48
33888: PUSH
33889: LD_EXP 54
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: IN
33903: PUSH
33904: LD_VAR 0 3
33908: OR
33909: IFFALSE 34008
// begin Say ( Roth , DA-Roth-3 ) ;
33911: LD_EXP 76
33915: PPUSH
33916: LD_STRING DA-Roth-3
33918: PPUSH
33919: CALL_OW 88
// SetSide ( unit , 7 ) ;
33923: LD_VAR 0 1
33927: PPUSH
33928: LD_INT 7
33930: PPUSH
33931: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
33935: LD_ADDR_EXP 99
33939: PUSH
33940: LD_EXP 99
33944: PPUSH
33945: LD_INT 1
33947: PPUSH
33948: LD_EXP 99
33952: PUSH
33953: LD_INT 1
33955: ARRAY
33956: PUSH
33957: LD_VAR 0 1
33961: ADD
33962: PPUSH
33963: CALL_OW 1
33967: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
33968: LD_INT 260
33970: PPUSH
33971: LD_INT 235
33973: PPUSH
33974: LD_INT 1
33976: PPUSH
33977: CALL_OW 331
// SetLives ( unit , 1000 ) ;
33981: LD_VAR 0 1
33985: PPUSH
33986: LD_INT 1000
33988: PPUSH
33989: CALL_OW 234
// DialogueOff ;
33993: CALL_OW 7
// ComFree ( unit ) ;
33997: LD_VAR 0 1
34001: PPUSH
34002: CALL_OW 139
// end else
34006: GO 34089
// begin Say ( Roth , DA-Roth-3a ) ;
34008: LD_EXP 76
34012: PPUSH
34013: LD_STRING DA-Roth-3a
34015: PPUSH
34016: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
34020: LD_ADDR_EXP 35
34024: PUSH
34025: LD_EXP 35
34029: PUSH
34030: LD_VAR 0 1
34034: ADD
34035: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34036: LD_INT 260
34038: PPUSH
34039: LD_INT 235
34041: PPUSH
34042: LD_INT 1
34044: PPUSH
34045: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34049: LD_VAR 0 1
34053: PPUSH
34054: LD_INT 1000
34056: PPUSH
34057: CALL_OW 234
// DialogueOff ;
34061: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34065: LD_VAR 0 1
34069: PPUSH
34070: LD_INT 272
34072: PPUSH
34073: LD_INT 254
34075: PPUSH
34076: CALL_OW 111
// AddComHold ( unit ) ;
34080: LD_VAR 0 1
34084: PPUSH
34085: CALL_OW 200
// end ; if capturedUnit = 1 then
34089: LD_EXP 34
34093: PUSH
34094: LD_INT 1
34096: EQUAL
34097: IFFALSE 34152
// begin DialogueOn ;
34099: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34103: LD_EXP 40
34107: PPUSH
34108: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34112: LD_EXP 40
34116: PPUSH
34117: LD_STRING DAa-JMM-1
34119: PPUSH
34120: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34124: LD_EXP 40
34128: PPUSH
34129: LD_STRING DAa-JMM-1a
34131: PPUSH
34132: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34136: LD_EXP 40
34140: PPUSH
34141: LD_STRING DAa-JMM-1b
34143: PPUSH
34144: CALL_OW 88
// DialogueOff ;
34148: CALL_OW 7
// end ; end ;
34152: LD_VAR 0 2
34156: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34157: LD_EXP 15
34161: PUSH
34162: LD_INT 13
34164: GREATEREQUAL
34165: PUSH
34166: LD_INT 22
34168: PUSH
34169: LD_INT 2
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 21
34178: PUSH
34179: LD_INT 1
34181: PUSH
34182: EMPTY
34183: LIST
34184: LIST
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PPUSH
34190: CALL_OW 69
34194: PUSH
34195: LD_INT 0
34197: EQUAL
34198: AND
34199: PUSH
34200: LD_INT 22
34202: PUSH
34203: LD_INT 2
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: LD_INT 33
34212: PUSH
34213: LD_INT 5
34215: PUSH
34216: EMPTY
34217: LIST
34218: LIST
34219: PUSH
34220: LD_INT 21
34222: PUSH
34223: LD_INT 2
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: PUSH
34230: LD_INT 50
34232: PUSH
34233: EMPTY
34234: LIST
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: PPUSH
34242: CALL_OW 69
34246: PUSH
34247: LD_INT 0
34249: EQUAL
34250: AND
34251: PUSH
34252: LD_EXP 21
34256: AND
34257: PUSH
34258: LD_EXP 22
34262: AND
34263: PUSH
34264: LD_EXP 23
34268: AND
34269: IFFALSE 34958
34271: GO 34273
34273: DISABLE
34274: LD_INT 0
34276: PPUSH
34277: PPUSH
34278: PPUSH
// begin m1 := false ;
34279: LD_ADDR_VAR 0 1
34283: PUSH
34284: LD_INT 0
34286: ST_TO_ADDR
// m2 := false ;
34287: LD_ADDR_VAR 0 2
34291: PUSH
34292: LD_INT 0
34294: ST_TO_ADDR
// m3 := false ;
34295: LD_ADDR_VAR 0 3
34299: PUSH
34300: LD_INT 0
34302: ST_TO_ADDR
// if not bombExploded then
34303: LD_EXP 37
34307: NOT
34308: IFFALSE 34317
// SetAchievement ( ACH_SIBROCKET ) ;
34310: LD_STRING ACH_SIBROCKET
34312: PPUSH
34313: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34317: LD_EXP 63
34321: PPUSH
34322: CALL_OW 255
34326: PUSH
34327: LD_INT 1
34329: EQUAL
34330: PUSH
34331: LD_EXP 63
34335: PPUSH
34336: CALL_OW 302
34340: AND
34341: IFFALSE 34357
// begin wait ( 3 ) ;
34343: LD_INT 3
34345: PPUSH
34346: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34350: LD_STRING ACH_OPO
34352: PPUSH
34353: CALL_OW 543
// end ; if tick <= 120 120$00 then
34357: LD_OWVAR 1
34361: PUSH
34362: LD_INT 252000
34364: LESSEQUAL
34365: IFFALSE 34381
// begin wait ( 3 ) ;
34367: LD_INT 3
34369: PPUSH
34370: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34374: LD_STRING ACH_ASPEED_15
34376: PPUSH
34377: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34381: LD_EXP 40
34385: PPUSH
34386: CALL_OW 87
// music_class := 5 ;
34390: LD_ADDR_OWVAR 72
34394: PUSH
34395: LD_INT 5
34397: ST_TO_ADDR
// music_nat := 5 ;
34398: LD_ADDR_OWVAR 71
34402: PUSH
34403: LD_INT 5
34405: ST_TO_ADDR
// DialogueOn ;
34406: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34410: LD_EXP 40
34414: PPUSH
34415: LD_STRING D20-JMM-1
34417: PPUSH
34418: CALL_OW 88
// if IsOK ( Joan ) then
34422: LD_EXP 41
34426: PPUSH
34427: CALL_OW 302
34431: IFFALSE 34445
// Say ( Joan , D20-Joan-1 ) ;
34433: LD_EXP 41
34437: PPUSH
34438: LD_STRING D20-Joan-1
34440: PPUSH
34441: CALL_OW 88
// if IsOk ( Lisa ) then
34445: LD_EXP 43
34449: PPUSH
34450: CALL_OW 302
34454: IFFALSE 34468
// Say ( Lisa , D20-Lisa-1 ) ;
34456: LD_EXP 43
34460: PPUSH
34461: LD_STRING D20-Lisa-1
34463: PPUSH
34464: CALL_OW 88
// if IsOk ( Donaldson ) then
34468: LD_EXP 44
34472: PPUSH
34473: CALL_OW 302
34477: IFFALSE 34491
// Say ( Donaldson , D20-Don-1 ) ;
34479: LD_EXP 44
34483: PPUSH
34484: LD_STRING D20-Don-1
34486: PPUSH
34487: CALL_OW 88
// if IsOK ( Cornel ) then
34491: LD_EXP 51
34495: PPUSH
34496: CALL_OW 302
34500: IFFALSE 34514
// Say ( Cornel , D20-Corn-1 ) ;
34502: LD_EXP 51
34506: PPUSH
34507: LD_STRING D20-Corn-1
34509: PPUSH
34510: CALL_OW 88
// if IsOk ( Denis ) then
34514: LD_EXP 47
34518: PPUSH
34519: CALL_OW 302
34523: IFFALSE 34537
// Say ( Denis , D20-Den-1 ) ;
34525: LD_EXP 47
34529: PPUSH
34530: LD_STRING D20-Den-1
34532: PPUSH
34533: CALL_OW 88
// if IsOk ( Bobby ) then
34537: LD_EXP 45
34541: PPUSH
34542: CALL_OW 302
34546: IFFALSE 34560
// Say ( Bobby , D20-Bobby-1 ) ;
34548: LD_EXP 45
34552: PPUSH
34553: LD_STRING D20-Bobby-1
34555: PPUSH
34556: CALL_OW 88
// if IsOk ( Gladstone ) then
34560: LD_EXP 49
34564: PPUSH
34565: CALL_OW 302
34569: IFFALSE 34583
// Say ( Gladstone , D20-Glad-1 ) ;
34571: LD_EXP 49
34575: PPUSH
34576: LD_STRING D20-Glad-1
34578: PPUSH
34579: CALL_OW 88
// if IsOk ( Cyrus ) then
34583: LD_EXP 46
34587: PPUSH
34588: CALL_OW 302
34592: IFFALSE 34606
// Say ( Cyrus , D20-Cyrus-1 ) ;
34594: LD_EXP 46
34598: PPUSH
34599: LD_STRING D20-Cyrus-1
34601: PPUSH
34602: CALL_OW 88
// if IsOk ( Stevens ) then
34606: LD_EXP 42
34610: PPUSH
34611: CALL_OW 302
34615: IFFALSE 34629
// Say ( Stevens , D20-Huck-1 ) ;
34617: LD_EXP 42
34621: PPUSH
34622: LD_STRING D20-Huck-1
34624: PPUSH
34625: CALL_OW 88
// if IsOk ( Brown ) then
34629: LD_EXP 48
34633: PPUSH
34634: CALL_OW 302
34638: IFFALSE 34652
// Say ( Brown , D20-Brown-1 ) ;
34640: LD_EXP 48
34644: PPUSH
34645: LD_STRING D20-Brown-1
34647: PPUSH
34648: CALL_OW 88
// if IsOk ( Gary ) then
34652: LD_EXP 52
34656: PPUSH
34657: CALL_OW 302
34661: IFFALSE 34675
// Say ( Gary , D20-Gary-1 ) ;
34663: LD_EXP 52
34667: PPUSH
34668: LD_STRING D20-Gary-1
34670: PPUSH
34671: CALL_OW 88
// if IsOk ( Connie ) then
34675: LD_EXP 55
34679: PPUSH
34680: CALL_OW 302
34684: IFFALSE 34698
// Say ( Connie , D20-Con-1 ) ;
34686: LD_EXP 55
34690: PPUSH
34691: LD_STRING D20-Con-1
34693: PPUSH
34694: CALL_OW 88
// if IsOk ( Kurt ) then
34698: LD_EXP 61
34702: PPUSH
34703: CALL_OW 302
34707: IFFALSE 34721
// Say ( Kurt , D20-Kurt-1 ) ;
34709: LD_EXP 61
34713: PPUSH
34714: LD_STRING D20-Kurt-1
34716: PPUSH
34717: CALL_OW 88
// if IsOk ( Kikuchi ) then
34721: LD_EXP 54
34725: PPUSH
34726: CALL_OW 302
34730: IFFALSE 34744
// Say ( Kikuchi , D20-Yam-1 ) ;
34732: LD_EXP 54
34736: PPUSH
34737: LD_STRING D20-Yam-1
34739: PPUSH
34740: CALL_OW 88
// if IsOk ( Frank ) then
34744: LD_EXP 53
34748: PPUSH
34749: CALL_OW 302
34753: IFFALSE 34767
// Say ( Frank , D20-Frank-1 ) ;
34755: LD_EXP 53
34759: PPUSH
34760: LD_STRING D20-Frank-1
34762: PPUSH
34763: CALL_OW 88
// DialogueOff ;
34767: CALL_OW 7
// if RothCaptured then
34771: LD_EXP 33
34775: IFFALSE 34797
// begin m1 := true ;
34777: LD_ADDR_VAR 0 1
34781: PUSH
34782: LD_INT 1
34784: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
34785: LD_STRING Roth
34787: PPUSH
34788: LD_INT 1
34790: PPUSH
34791: CALL_OW 101
// end else
34795: GO 34808
// AddMedal ( Roth , - 1 ) ;
34797: LD_STRING Roth
34799: PPUSH
34800: LD_INT 1
34802: NEG
34803: PPUSH
34804: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
34808: LD_EXP 25
34812: NOT
34813: PUSH
34814: LD_EXP 27
34818: OR
34819: IFFALSE 34841
// begin m2 := true ;
34821: LD_ADDR_VAR 0 2
34825: PUSH
34826: LD_INT 1
34828: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
34829: LD_STRING Project
34831: PPUSH
34832: LD_INT 1
34834: PPUSH
34835: CALL_OW 101
// end else
34839: GO 34852
// AddMedal ( Project , - 1 ) ;
34841: LD_STRING Project
34843: PPUSH
34844: LD_INT 1
34846: NEG
34847: PPUSH
34848: CALL_OW 101
// if lostCounter = 0 then
34852: LD_EXP 32
34856: PUSH
34857: LD_INT 0
34859: EQUAL
34860: IFFALSE 34882
// begin m3 := true ;
34862: LD_ADDR_VAR 0 3
34866: PUSH
34867: LD_INT 1
34869: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
34870: LD_STRING NoLosses
34872: PPUSH
34873: LD_INT 1
34875: PPUSH
34876: CALL_OW 101
// end else
34880: GO 34893
// AddMedal ( NoLosses , - 1 ) ;
34882: LD_STRING NoLosses
34884: PPUSH
34885: LD_INT 1
34887: NEG
34888: PPUSH
34889: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
34893: LD_VAR 0 1
34897: PUSH
34898: LD_VAR 0 2
34902: AND
34903: PUSH
34904: LD_VAR 0 3
34908: AND
34909: PUSH
34910: LD_OWVAR 67
34914: PUSH
34915: LD_INT 3
34917: GREATEREQUAL
34918: AND
34919: IFFALSE 34931
// SetAchievementEX ( ACH_AMER , 15 ) ;
34921: LD_STRING ACH_AMER
34923: PPUSH
34924: LD_INT 15
34926: PPUSH
34927: CALL_OW 564
// GiveMedals ( MAIN ) ;
34931: LD_STRING MAIN
34933: PPUSH
34934: CALL_OW 102
// music_class := 4 ;
34938: LD_ADDR_OWVAR 72
34942: PUSH
34943: LD_INT 4
34945: ST_TO_ADDR
// music_nat := 1 ;
34946: LD_ADDR_OWVAR 71
34950: PUSH
34951: LD_INT 1
34953: ST_TO_ADDR
// YouWin ;
34954: CALL_OW 103
// end ; end_of_file
34958: PPOPN 3
34960: END
// export function CustomEvent ( event ) ; begin
34961: LD_INT 0
34963: PPUSH
// end ;
34964: LD_VAR 0 2
34968: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
34969: LD_VAR 0 1
34973: PUSH
34974: LD_INT 1
34976: EQUAL
34977: PUSH
34978: LD_VAR 0 2
34982: PUSH
34983: LD_INT 4
34985: EQUAL
34986: AND
34987: PUSH
34988: LD_EXP 59
34992: PPUSH
34993: CALL_OW 300
34997: AND
34998: IFFALSE 35014
// begin wait ( 0 0$2 ) ;
35000: LD_INT 70
35002: PPUSH
35003: CALL_OW 67
// YouLost ( Dismissed ) ;
35007: LD_STRING Dismissed
35009: PPUSH
35010: CALL_OW 104
// end ; end ;
35014: PPOPN 2
35016: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
35017: LD_VAR 0 2
35021: PPUSH
35022: LD_VAR 0 3
35026: PPUSH
35027: LD_INT 18
35029: PPUSH
35030: CALL_OW 309
35034: IFFALSE 35043
// YouLost ( Motherlode3 ) ;
35036: LD_STRING Motherlode3
35038: PPUSH
35039: CALL_OW 104
// end ;
35043: PPOPN 3
35045: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35046: LD_EXP 27
35050: NOT
35051: IFFALSE 35061
// behemothDone := true ;
35053: LD_ADDR_EXP 28
35057: PUSH
35058: LD_INT 1
35060: ST_TO_ADDR
// end ;
35061: PPOPN 1
35063: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35064: LD_VAR 0 1
35068: PPUSH
35069: CALL_OW 255
35073: PUSH
35074: LD_INT 1
35076: EQUAL
35077: IFFALSE 35087
// bombExploded := true ;
35079: LD_ADDR_EXP 37
35083: PUSH
35084: LD_INT 1
35086: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35087: LD_VAR 0 1
35091: PPUSH
35092: CALL_OW 255
35096: PUSH
35097: LD_INT 1
35099: EQUAL
35100: PUSH
35101: LD_EXP 30
35105: AND
35106: PUSH
35107: LD_INT 22
35109: PUSH
35110: LD_INT 3
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 34
35119: PUSH
35120: LD_INT 48
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PPUSH
35131: CALL_OW 69
35135: AND
35136: PUSH
35137: LD_INT 22
35139: PUSH
35140: LD_INT 1
35142: PUSH
35143: EMPTY
35144: LIST
35145: LIST
35146: PUSH
35147: LD_INT 34
35149: PUSH
35150: LD_INT 8
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PPUSH
35161: CALL_OW 69
35165: NOT
35166: AND
35167: IFFALSE 35219
// begin wait ( 0 0$5 ) ;
35169: LD_INT 175
35171: PPUSH
35172: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35176: LD_INT 22
35178: PUSH
35179: LD_INT 3
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 34
35188: PUSH
35189: LD_INT 48
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: EMPTY
35197: LIST
35198: LIST
35199: PPUSH
35200: CALL_OW 69
35204: PUSH
35205: LD_INT 1
35207: ARRAY
35208: PPUSH
35209: LD_INT 60
35211: PPUSH
35212: LD_INT 95
35214: PPUSH
35215: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
35219: LD_VAR 0 2
35223: PPUSH
35224: LD_VAR 0 3
35228: PPUSH
35229: LD_INT 18
35231: PPUSH
35232: CALL_OW 309
35236: PUSH
35237: LD_VAR 0 2
35241: PPUSH
35242: LD_VAR 0 3
35246: PPUSH
35247: LD_INT 18
35249: PPUSH
35250: CALL 108508 0 3
35254: OR
35255: IFFALSE 35302
// begin if GetSide ( unit ) = 1 then
35257: LD_VAR 0 1
35261: PPUSH
35262: CALL_OW 255
35266: PUSH
35267: LD_INT 1
35269: EQUAL
35270: IFFALSE 35288
// begin wait ( 0 0$6 ) ;
35272: LD_INT 210
35274: PPUSH
35275: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35279: LD_STRING Motherlode2
35281: PPUSH
35282: CALL_OW 104
// end else
35286: GO 35302
// begin wait ( 0 0$6 ) ;
35288: LD_INT 210
35290: PPUSH
35291: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35295: LD_STRING Motherlode1
35297: PPUSH
35298: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35302: LD_VAR 0 1
35306: PPUSH
35307: CALL_OW 255
35311: PUSH
35312: LD_INT 3
35314: EQUAL
35315: IFFALSE 35336
// begin wait ( 0 0$5 ) ;
35317: LD_INT 175
35319: PPUSH
35320: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35324: LD_EXP 65
35328: PPUSH
35329: LD_STRING D18-Pla-1
35331: PPUSH
35332: CALL_OW 94
// end ; end ;
35336: PPOPN 3
35338: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
35339: LD_VAR 0 1
35343: PPUSH
35344: CALL 124267 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
35348: LD_VAR 0 1
35352: PUSH
35353: LD_INT 22
35355: PUSH
35356: LD_INT 1
35358: PUSH
35359: EMPTY
35360: LIST
35361: LIST
35362: PUSH
35363: LD_INT 21
35365: PUSH
35366: LD_INT 1
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PUSH
35373: LD_INT 23
35375: PUSH
35376: LD_INT 1
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: LIST
35387: PPUSH
35388: CALL_OW 69
35392: IN
35393: IFFALSE 35409
// lostCounter := lostCounter + 1 ;
35395: LD_ADDR_EXP 32
35399: PUSH
35400: LD_EXP 32
35404: PUSH
35405: LD_INT 1
35407: PLUS
35408: ST_TO_ADDR
// if un in behemothBuilders then
35409: LD_VAR 0 1
35413: PUSH
35414: LD_EXP 74
35418: IN
35419: IFFALSE 35439
// begin behemothBuilders := behemothBuilders diff un ;
35421: LD_ADDR_EXP 74
35425: PUSH
35426: LD_EXP 74
35430: PUSH
35431: LD_VAR 0 1
35435: DIFF
35436: ST_TO_ADDR
// exit ;
35437: GO 35469
// end ; if un = JMM then
35439: LD_VAR 0 1
35443: PUSH
35444: LD_EXP 40
35448: EQUAL
35449: IFFALSE 35460
// begin YouLost ( JMM ) ;
35451: LD_STRING JMM
35453: PPUSH
35454: CALL_OW 104
// exit ;
35458: GO 35469
// end ; MCE_UnitDestroyed ( un ) ;
35460: LD_VAR 0 1
35464: PPUSH
35465: CALL 64266 0 1
// end ;
35469: PPOPN 1
35471: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
35472: LD_VAR 0 1
35476: PPUSH
35477: LD_VAR 0 2
35481: PPUSH
35482: CALL 66598 0 2
// end ;
35486: PPOPN 2
35488: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
35489: LD_VAR 0 1
35493: PPUSH
35494: CALL 65666 0 1
// end ;
35498: PPOPN 1
35500: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
35501: LD_VAR 0 1
35505: PUSH
35506: LD_INT 22
35508: PUSH
35509: LD_INT 8
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: LD_INT 30
35518: PUSH
35519: LD_INT 2
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 23
35528: PUSH
35529: LD_INT 3
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: LIST
35540: PPUSH
35541: CALL_OW 69
35545: IN
35546: IFFALSE 35573
// begin ComUpgrade ( building ) ;
35548: LD_VAR 0 1
35552: PPUSH
35553: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
35557: LD_EXP 62
35561: PPUSH
35562: LD_VAR 0 1
35566: PPUSH
35567: CALL 75248 0 2
// exit ;
35571: GO 35582
// end ; MCE_BuildingComplete ( building ) ;
35573: LD_VAR 0 1
35577: PPUSH
35578: CALL 65907 0 1
// end ;
35582: PPOPN 1
35584: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
35585: LD_VAR 0 1
35589: PPUSH
35590: LD_VAR 0 2
35594: PPUSH
35595: CALL 63962 0 2
// end ;
35599: PPOPN 2
35601: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
35602: LD_VAR 0 1
35606: PPUSH
35607: LD_VAR 0 2
35611: PPUSH
35612: LD_VAR 0 3
35616: PPUSH
35617: LD_VAR 0 4
35621: PPUSH
35622: LD_VAR 0 5
35626: PPUSH
35627: CALL 63582 0 5
// end ;
35631: PPOPN 5
35633: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
35634: LD_VAR 0 1
35638: PPUSH
35639: CALL_OW 255
35643: PUSH
35644: LD_INT 1
35646: EQUAL
35647: IFFALSE 35664
// amConstructCounter := Inc ( amConstructCounter ) ;
35649: LD_ADDR_EXP 39
35653: PUSH
35654: LD_EXP 39
35658: PPUSH
35659: CALL 106060 0 1
35663: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
35664: LD_VAR 0 1
35668: PPUSH
35669: LD_VAR 0 2
35673: PPUSH
35674: CALL 124387 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
35678: LD_VAR 0 1
35682: PPUSH
35683: LD_VAR 0 2
35687: PPUSH
35688: CALL 63173 0 2
// end ;
35692: PPOPN 2
35694: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
35695: LD_VAR 0 1
35699: PPUSH
35700: LD_VAR 0 2
35704: PPUSH
35705: LD_VAR 0 3
35709: PPUSH
35710: LD_VAR 0 4
35714: PPUSH
35715: CALL 63011 0 4
// end ;
35719: PPOPN 4
35721: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
35722: LD_VAR 0 1
35726: PPUSH
35727: LD_VAR 0 2
35731: PPUSH
35732: LD_VAR 0 3
35736: PPUSH
35737: CALL 62786 0 3
// end ;
35741: PPOPN 3
35743: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
35744: LD_VAR 0 1
35748: PPUSH
35749: LD_VAR 0 2
35753: PPUSH
35754: CALL 62671 0 2
// end ;
35758: PPOPN 2
35760: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
35761: LD_VAR 0 1
35765: PPUSH
35766: LD_VAR 0 2
35770: PPUSH
35771: CALL 66893 0 2
// end ;
35775: PPOPN 2
35777: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
35778: LD_VAR 0 1
35782: PPUSH
35783: CALL_OW 255
35787: PUSH
35788: LD_INT 4
35790: EQUAL
35791: PUSH
35792: LD_VAR 0 1
35796: PUSH
35797: LD_EXP 18
35801: PUSH
35802: LD_INT 1
35804: ARRAY
35805: IN
35806: AND
35807: PUSH
35808: LD_EXP 19
35812: AND
35813: IFFALSE 35832
// begin ComMoveXY ( driver , 61 , 93 ) ;
35815: LD_VAR 0 1
35819: PPUSH
35820: LD_INT 61
35822: PPUSH
35823: LD_INT 93
35825: PPUSH
35826: CALL_OW 111
// exit ;
35830: GO 35856
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
35832: LD_VAR 0 1
35836: PPUSH
35837: LD_VAR 0 2
35841: PPUSH
35842: LD_VAR 0 3
35846: PPUSH
35847: LD_VAR 0 4
35851: PPUSH
35852: CALL 67109 0 4
// end ;
35856: PPOPN 4
35858: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
35859: LD_VAR 0 1
35863: PPUSH
35864: LD_VAR 0 2
35868: PPUSH
35869: CALL 62480 0 2
// end ;
35873: PPOPN 2
35875: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
35876: LD_VAR 0 1
35880: PPUSH
35881: CALL 124371 0 1
// end ; end_of_file
35885: PPOPN 1
35887: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
35888: LD_EXP 15
35892: PUSH
35893: LD_INT 2
35895: EQUAL
35896: IFFALSE 36399
35898: GO 35900
35900: DISABLE
35901: LD_INT 0
35903: PPUSH
35904: PPUSH
// begin time := 0 0$35 ;
35905: LD_ADDR_VAR 0 2
35909: PUSH
35910: LD_INT 1225
35912: ST_TO_ADDR
// repeat wait ( time ) ;
35913: LD_VAR 0 2
35917: PPUSH
35918: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
35922: LD_INT 1
35924: PPUSH
35925: LD_INT 5
35927: PPUSH
35928: CALL_OW 12
35932: PPUSH
35933: LD_INT 106
35935: PPUSH
35936: LD_INT 150
35938: PPUSH
35939: LD_INT 19
35941: PPUSH
35942: LD_INT 1
35944: PPUSH
35945: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
35949: LD_INT 455
35951: PPUSH
35952: LD_INT 770
35954: PPUSH
35955: CALL_OW 12
35959: PPUSH
35960: CALL_OW 67
// if Prob ( 50 ) then
35964: LD_INT 50
35966: PPUSH
35967: CALL_OW 13
35971: IFFALSE 36000
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
35973: LD_INT 1
35975: PPUSH
35976: LD_INT 5
35978: PPUSH
35979: CALL_OW 12
35983: PPUSH
35984: LD_INT 62
35986: PPUSH
35987: LD_INT 108
35989: PPUSH
35990: LD_INT 10
35992: PPUSH
35993: LD_INT 1
35995: PPUSH
35996: CALL_OW 56
// until missionStage > 4 ;
36000: LD_EXP 15
36004: PUSH
36005: LD_INT 4
36007: GREATER
36008: IFFALSE 35913
// repeat wait ( 0 0$1 ) ;
36010: LD_INT 35
36012: PPUSH
36013: CALL_OW 67
// until missionStage = 6 ;
36017: LD_EXP 15
36021: PUSH
36022: LD_INT 6
36024: EQUAL
36025: IFFALSE 36010
// time := 0 0$20 ;
36027: LD_ADDR_VAR 0 2
36031: PUSH
36032: LD_INT 700
36034: ST_TO_ADDR
// repeat wait ( time ) ;
36035: LD_VAR 0 2
36039: PPUSH
36040: CALL_OW 67
// if Prob ( 90 ) then
36044: LD_INT 90
36046: PPUSH
36047: CALL_OW 13
36051: IFFALSE 36094
// begin time := time + 0 0$2 ;
36053: LD_ADDR_VAR 0 2
36057: PUSH
36058: LD_VAR 0 2
36062: PUSH
36063: LD_INT 70
36065: PLUS
36066: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36067: LD_INT 1
36069: PPUSH
36070: LD_INT 5
36072: PPUSH
36073: CALL_OW 12
36077: PPUSH
36078: LD_INT 106
36080: PPUSH
36081: LD_INT 89
36083: PPUSH
36084: LD_INT 45
36086: PPUSH
36087: LD_INT 1
36089: PPUSH
36090: CALL_OW 56
// end ; if Prob ( 45 ) then
36094: LD_INT 45
36096: PPUSH
36097: CALL_OW 13
36101: IFFALSE 36157
// begin for i := 1 to 4 do
36103: LD_ADDR_VAR 0 1
36107: PUSH
36108: DOUBLE
36109: LD_INT 1
36111: DEC
36112: ST_TO_ADDR
36113: LD_INT 4
36115: PUSH
36116: FOR_TO
36117: IFFALSE 36155
// begin wait ( 0 0$5 ) ;
36119: LD_INT 175
36121: PPUSH
36122: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36126: LD_INT 1
36128: PPUSH
36129: LD_INT 5
36131: PPUSH
36132: CALL_OW 12
36136: PPUSH
36137: LD_INT 113
36139: PPUSH
36140: LD_INT 117
36142: PPUSH
36143: LD_INT 25
36145: PPUSH
36146: LD_INT 1
36148: PPUSH
36149: CALL_OW 56
// end ;
36153: GO 36116
36155: POP
36156: POP
// end ; if Prob ( 40 ) then
36157: LD_INT 40
36159: PPUSH
36160: CALL_OW 13
36164: IFFALSE 36210
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36166: LD_INT 385
36168: PPUSH
36169: LD_INT 945
36171: PPUSH
36172: CALL_OW 12
36176: PPUSH
36177: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36181: LD_INT 1
36183: PPUSH
36184: LD_INT 5
36186: PPUSH
36187: CALL_OW 12
36191: PPUSH
36192: LD_INT 21
36194: PPUSH
36195: LD_INT 26
36197: PPUSH
36198: LD_INT 12
36200: PPUSH
36201: LD_INT 1
36203: PPUSH
36204: CALL_OW 56
// end else
36208: GO 36246
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36210: LD_INT 700
36212: PPUSH
36213: LD_INT 1225
36215: PPUSH
36216: CALL_OW 12
36220: PPUSH
36221: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36225: LD_INT 1
36227: PPUSH
36228: LD_INT 5
36230: PPUSH
36231: CALL_OW 12
36235: PPUSH
36236: LD_INT 16
36238: PPUSH
36239: LD_INT 1
36241: PPUSH
36242: CALL_OW 55
// end ; if Prob ( 50 ) then
36246: LD_INT 50
36248: PPUSH
36249: CALL_OW 13
36253: IFFALSE 36299
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36255: LD_INT 700
36257: PPUSH
36258: LD_INT 1050
36260: PPUSH
36261: CALL_OW 12
36265: PPUSH
36266: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36270: LD_INT 1
36272: PPUSH
36273: LD_INT 5
36275: PPUSH
36276: CALL_OW 12
36280: PPUSH
36281: LD_INT 168
36283: PPUSH
36284: LD_INT 168
36286: PPUSH
36287: LD_INT 16
36289: PPUSH
36290: LD_INT 1
36292: PPUSH
36293: CALL_OW 56
// end else
36297: GO 36335
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36299: LD_INT 350
36301: PPUSH
36302: LD_INT 525
36304: PPUSH
36305: CALL_OW 12
36309: PPUSH
36310: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
36314: LD_INT 1
36316: PPUSH
36317: LD_INT 5
36319: PPUSH
36320: CALL_OW 12
36324: PPUSH
36325: LD_INT 15
36327: PPUSH
36328: LD_INT 1
36330: PPUSH
36331: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
36335: LD_INT 175
36337: PPUSH
36338: LD_INT 315
36340: PPUSH
36341: CALL_OW 12
36345: PPUSH
36346: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
36350: LD_INT 1
36352: PPUSH
36353: LD_INT 5
36355: PPUSH
36356: CALL_OW 12
36360: PPUSH
36361: LD_INT 103
36363: PPUSH
36364: LD_INT 140
36366: PPUSH
36367: LD_INT 20
36369: PPUSH
36370: LD_INT 1
36372: PPUSH
36373: CALL_OW 56
// if time > 1 1$10 then
36377: LD_VAR 0 2
36381: PUSH
36382: LD_INT 2450
36384: GREATER
36385: IFFALSE 36395
// time := 0 0$30 ;
36387: LD_ADDR_VAR 0 2
36391: PUSH
36392: LD_INT 1050
36394: ST_TO_ADDR
// until false ;
36395: LD_INT 0
36397: IFFALSE 36035
// end ; end_of_file
36399: PPOPN 2
36401: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
36402: LD_EXP 13
36406: PUSH
36407: LD_EXP 15
36411: PUSH
36412: LD_INT 6
36414: GREATEREQUAL
36415: AND
36416: IFFALSE 36453
36418: GO 36420
36420: DISABLE
// begin enable ;
36421: ENABLE
// missionTime := missionTime + 0 0$1 ;
36422: LD_ADDR_EXP 14
36426: PUSH
36427: LD_EXP 14
36431: PUSH
36432: LD_INT 35
36434: PLUS
36435: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
36436: LD_ADDR_OWVAR 47
36440: PUSH
36441: LD_STRING #Am15-1
36443: PUSH
36444: LD_EXP 14
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: ST_TO_ADDR
// end ; end_of_file
36453: END
// export function InitNature ; begin
36454: LD_INT 0
36456: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
36457: LD_INT 3
36459: PPUSH
36460: LD_INT 3
36462: PPUSH
36463: LD_INT 2
36465: PPUSH
36466: LD_INT 1
36468: PPUSH
36469: LD_INT 1
36471: PPUSH
36472: LD_INT 0
36474: PPUSH
36475: LD_INT 0
36477: PPUSH
36478: LD_INT 20
36480: PPUSH
36481: LD_INT 0
36483: PPUSH
36484: CALL 101381 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
36488: LD_INT 2
36490: PPUSH
36491: LD_INT 1
36493: PPUSH
36494: LD_INT 1
36496: PPUSH
36497: LD_INT 1
36499: PPUSH
36500: LD_INT 1
36502: PPUSH
36503: LD_INT 0
36505: PPUSH
36506: LD_INT 0
36508: PPUSH
36509: LD_INT 21
36511: PPUSH
36512: LD_INT 0
36514: PPUSH
36515: CALL 101381 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
36519: LD_INT 4
36521: PPUSH
36522: LD_INT 1
36524: PPUSH
36525: LD_INT 2
36527: PPUSH
36528: LD_INT 4
36530: PPUSH
36531: LD_INT 2
36533: PPUSH
36534: LD_INT 1
36536: PPUSH
36537: LD_INT 0
36539: PPUSH
36540: LD_INT 22
36542: PPUSH
36543: LD_INT 0
36545: PPUSH
36546: CALL 101381 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
36550: LD_INT 0
36552: PPUSH
36553: LD_INT 0
36555: PPUSH
36556: LD_INT 0
36558: PPUSH
36559: LD_INT 0
36561: PPUSH
36562: LD_INT 0
36564: PPUSH
36565: LD_INT 0
36567: PPUSH
36568: LD_INT 9
36570: PPUSH
36571: LD_INT 0
36573: PPUSH
36574: LD_INT 23
36576: PPUSH
36577: CALL 101381 0 9
// end ; end_of_file
36581: LD_VAR 0 1
36585: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
36586: LD_INT 0
36588: PPUSH
36589: PPUSH
// skirmish := false ;
36590: LD_ADDR_EXP 97
36594: PUSH
36595: LD_INT 0
36597: ST_TO_ADDR
// debug_mc := false ;
36598: LD_ADDR_EXP 98
36602: PUSH
36603: LD_INT 0
36605: ST_TO_ADDR
// mc_bases := [ ] ;
36606: LD_ADDR_EXP 99
36610: PUSH
36611: EMPTY
36612: ST_TO_ADDR
// mc_sides := [ ] ;
36613: LD_ADDR_EXP 125
36617: PUSH
36618: EMPTY
36619: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
36620: LD_ADDR_EXP 100
36624: PUSH
36625: EMPTY
36626: ST_TO_ADDR
// mc_building_repairs := [ ] ;
36627: LD_ADDR_EXP 101
36631: PUSH
36632: EMPTY
36633: ST_TO_ADDR
// mc_need_heal := [ ] ;
36634: LD_ADDR_EXP 102
36638: PUSH
36639: EMPTY
36640: ST_TO_ADDR
// mc_healers := [ ] ;
36641: LD_ADDR_EXP 103
36645: PUSH
36646: EMPTY
36647: ST_TO_ADDR
// mc_build_list := [ ] ;
36648: LD_ADDR_EXP 104
36652: PUSH
36653: EMPTY
36654: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
36655: LD_ADDR_EXP 131
36659: PUSH
36660: EMPTY
36661: ST_TO_ADDR
// mc_builders := [ ] ;
36662: LD_ADDR_EXP 105
36666: PUSH
36667: EMPTY
36668: ST_TO_ADDR
// mc_construct_list := [ ] ;
36669: LD_ADDR_EXP 106
36673: PUSH
36674: EMPTY
36675: ST_TO_ADDR
// mc_turret_list := [ ] ;
36676: LD_ADDR_EXP 107
36680: PUSH
36681: EMPTY
36682: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
36683: LD_ADDR_EXP 108
36687: PUSH
36688: EMPTY
36689: ST_TO_ADDR
// mc_miners := [ ] ;
36690: LD_ADDR_EXP 113
36694: PUSH
36695: EMPTY
36696: ST_TO_ADDR
// mc_mines := [ ] ;
36697: LD_ADDR_EXP 112
36701: PUSH
36702: EMPTY
36703: ST_TO_ADDR
// mc_minefields := [ ] ;
36704: LD_ADDR_EXP 114
36708: PUSH
36709: EMPTY
36710: ST_TO_ADDR
// mc_crates := [ ] ;
36711: LD_ADDR_EXP 115
36715: PUSH
36716: EMPTY
36717: ST_TO_ADDR
// mc_crates_collector := [ ] ;
36718: LD_ADDR_EXP 116
36722: PUSH
36723: EMPTY
36724: ST_TO_ADDR
// mc_crates_area := [ ] ;
36725: LD_ADDR_EXP 117
36729: PUSH
36730: EMPTY
36731: ST_TO_ADDR
// mc_vehicles := [ ] ;
36732: LD_ADDR_EXP 118
36736: PUSH
36737: EMPTY
36738: ST_TO_ADDR
// mc_attack := [ ] ;
36739: LD_ADDR_EXP 119
36743: PUSH
36744: EMPTY
36745: ST_TO_ADDR
// mc_produce := [ ] ;
36746: LD_ADDR_EXP 120
36750: PUSH
36751: EMPTY
36752: ST_TO_ADDR
// mc_defender := [ ] ;
36753: LD_ADDR_EXP 121
36757: PUSH
36758: EMPTY
36759: ST_TO_ADDR
// mc_parking := [ ] ;
36760: LD_ADDR_EXP 123
36764: PUSH
36765: EMPTY
36766: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
36767: LD_ADDR_EXP 109
36771: PUSH
36772: EMPTY
36773: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
36774: LD_ADDR_EXP 111
36778: PUSH
36779: EMPTY
36780: ST_TO_ADDR
// mc_scan := [ ] ;
36781: LD_ADDR_EXP 122
36785: PUSH
36786: EMPTY
36787: ST_TO_ADDR
// mc_scan_area := [ ] ;
36788: LD_ADDR_EXP 124
36792: PUSH
36793: EMPTY
36794: ST_TO_ADDR
// mc_tech := [ ] ;
36795: LD_ADDR_EXP 126
36799: PUSH
36800: EMPTY
36801: ST_TO_ADDR
// mc_class := [ ] ;
36802: LD_ADDR_EXP 140
36806: PUSH
36807: EMPTY
36808: ST_TO_ADDR
// mc_class_case_use := [ ] ;
36809: LD_ADDR_EXP 141
36813: PUSH
36814: EMPTY
36815: ST_TO_ADDR
// mc_is_defending := [ ] ;
36816: LD_ADDR_EXP 142
36820: PUSH
36821: EMPTY
36822: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
36823: LD_ADDR_EXP 133
36827: PUSH
36828: EMPTY
36829: ST_TO_ADDR
// end ;
36830: LD_VAR 0 1
36834: RET
// export function MC_Kill ( base ) ; begin
36835: LD_INT 0
36837: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
36838: LD_ADDR_EXP 99
36842: PUSH
36843: LD_EXP 99
36847: PPUSH
36848: LD_VAR 0 1
36852: PPUSH
36853: EMPTY
36854: PPUSH
36855: CALL_OW 1
36859: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36860: LD_ADDR_EXP 100
36864: PUSH
36865: LD_EXP 100
36869: PPUSH
36870: LD_VAR 0 1
36874: PPUSH
36875: EMPTY
36876: PPUSH
36877: CALL_OW 1
36881: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36882: LD_ADDR_EXP 101
36886: PUSH
36887: LD_EXP 101
36891: PPUSH
36892: LD_VAR 0 1
36896: PPUSH
36897: EMPTY
36898: PPUSH
36899: CALL_OW 1
36903: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36904: LD_ADDR_EXP 102
36908: PUSH
36909: LD_EXP 102
36913: PPUSH
36914: LD_VAR 0 1
36918: PPUSH
36919: EMPTY
36920: PPUSH
36921: CALL_OW 1
36925: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36926: LD_ADDR_EXP 103
36930: PUSH
36931: LD_EXP 103
36935: PPUSH
36936: LD_VAR 0 1
36940: PPUSH
36941: EMPTY
36942: PPUSH
36943: CALL_OW 1
36947: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36948: LD_ADDR_EXP 104
36952: PUSH
36953: LD_EXP 104
36957: PPUSH
36958: LD_VAR 0 1
36962: PPUSH
36963: EMPTY
36964: PPUSH
36965: CALL_OW 1
36969: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36970: LD_ADDR_EXP 105
36974: PUSH
36975: LD_EXP 105
36979: PPUSH
36980: LD_VAR 0 1
36984: PPUSH
36985: EMPTY
36986: PPUSH
36987: CALL_OW 1
36991: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36992: LD_ADDR_EXP 106
36996: PUSH
36997: LD_EXP 106
37001: PPUSH
37002: LD_VAR 0 1
37006: PPUSH
37007: EMPTY
37008: PPUSH
37009: CALL_OW 1
37013: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37014: LD_ADDR_EXP 107
37018: PUSH
37019: LD_EXP 107
37023: PPUSH
37024: LD_VAR 0 1
37028: PPUSH
37029: EMPTY
37030: PPUSH
37031: CALL_OW 1
37035: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37036: LD_ADDR_EXP 108
37040: PUSH
37041: LD_EXP 108
37045: PPUSH
37046: LD_VAR 0 1
37050: PPUSH
37051: EMPTY
37052: PPUSH
37053: CALL_OW 1
37057: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37058: LD_ADDR_EXP 109
37062: PUSH
37063: LD_EXP 109
37067: PPUSH
37068: LD_VAR 0 1
37072: PPUSH
37073: EMPTY
37074: PPUSH
37075: CALL_OW 1
37079: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37080: LD_ADDR_EXP 110
37084: PUSH
37085: LD_EXP 110
37089: PPUSH
37090: LD_VAR 0 1
37094: PPUSH
37095: LD_INT 0
37097: PPUSH
37098: CALL_OW 1
37102: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37103: LD_ADDR_EXP 111
37107: PUSH
37108: LD_EXP 111
37112: PPUSH
37113: LD_VAR 0 1
37117: PPUSH
37118: EMPTY
37119: PPUSH
37120: CALL_OW 1
37124: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37125: LD_ADDR_EXP 112
37129: PUSH
37130: LD_EXP 112
37134: PPUSH
37135: LD_VAR 0 1
37139: PPUSH
37140: EMPTY
37141: PPUSH
37142: CALL_OW 1
37146: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37147: LD_ADDR_EXP 113
37151: PUSH
37152: LD_EXP 113
37156: PPUSH
37157: LD_VAR 0 1
37161: PPUSH
37162: EMPTY
37163: PPUSH
37164: CALL_OW 1
37168: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37169: LD_ADDR_EXP 114
37173: PUSH
37174: LD_EXP 114
37178: PPUSH
37179: LD_VAR 0 1
37183: PPUSH
37184: EMPTY
37185: PPUSH
37186: CALL_OW 1
37190: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37191: LD_ADDR_EXP 115
37195: PUSH
37196: LD_EXP 115
37200: PPUSH
37201: LD_VAR 0 1
37205: PPUSH
37206: EMPTY
37207: PPUSH
37208: CALL_OW 1
37212: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37213: LD_ADDR_EXP 116
37217: PUSH
37218: LD_EXP 116
37222: PPUSH
37223: LD_VAR 0 1
37227: PPUSH
37228: EMPTY
37229: PPUSH
37230: CALL_OW 1
37234: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37235: LD_ADDR_EXP 117
37239: PUSH
37240: LD_EXP 117
37244: PPUSH
37245: LD_VAR 0 1
37249: PPUSH
37250: EMPTY
37251: PPUSH
37252: CALL_OW 1
37256: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37257: LD_ADDR_EXP 118
37261: PUSH
37262: LD_EXP 118
37266: PPUSH
37267: LD_VAR 0 1
37271: PPUSH
37272: EMPTY
37273: PPUSH
37274: CALL_OW 1
37278: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37279: LD_ADDR_EXP 119
37283: PUSH
37284: LD_EXP 119
37288: PPUSH
37289: LD_VAR 0 1
37293: PPUSH
37294: EMPTY
37295: PPUSH
37296: CALL_OW 1
37300: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37301: LD_ADDR_EXP 120
37305: PUSH
37306: LD_EXP 120
37310: PPUSH
37311: LD_VAR 0 1
37315: PPUSH
37316: EMPTY
37317: PPUSH
37318: CALL_OW 1
37322: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37323: LD_ADDR_EXP 121
37327: PUSH
37328: LD_EXP 121
37332: PPUSH
37333: LD_VAR 0 1
37337: PPUSH
37338: EMPTY
37339: PPUSH
37340: CALL_OW 1
37344: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37345: LD_ADDR_EXP 122
37349: PUSH
37350: LD_EXP 122
37354: PPUSH
37355: LD_VAR 0 1
37359: PPUSH
37360: EMPTY
37361: PPUSH
37362: CALL_OW 1
37366: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37367: LD_ADDR_EXP 123
37371: PUSH
37372: LD_EXP 123
37376: PPUSH
37377: LD_VAR 0 1
37381: PPUSH
37382: EMPTY
37383: PPUSH
37384: CALL_OW 1
37388: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37389: LD_ADDR_EXP 124
37393: PUSH
37394: LD_EXP 124
37398: PPUSH
37399: LD_VAR 0 1
37403: PPUSH
37404: EMPTY
37405: PPUSH
37406: CALL_OW 1
37410: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37411: LD_ADDR_EXP 126
37415: PUSH
37416: LD_EXP 126
37420: PPUSH
37421: LD_VAR 0 1
37425: PPUSH
37426: EMPTY
37427: PPUSH
37428: CALL_OW 1
37432: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37433: LD_ADDR_EXP 128
37437: PUSH
37438: LD_EXP 128
37442: PPUSH
37443: LD_VAR 0 1
37447: PPUSH
37448: EMPTY
37449: PPUSH
37450: CALL_OW 1
37454: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37455: LD_ADDR_EXP 129
37459: PUSH
37460: LD_EXP 129
37464: PPUSH
37465: LD_VAR 0 1
37469: PPUSH
37470: EMPTY
37471: PPUSH
37472: CALL_OW 1
37476: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37477: LD_ADDR_EXP 130
37481: PUSH
37482: LD_EXP 130
37486: PPUSH
37487: LD_VAR 0 1
37491: PPUSH
37492: EMPTY
37493: PPUSH
37494: CALL_OW 1
37498: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37499: LD_ADDR_EXP 131
37503: PUSH
37504: LD_EXP 131
37508: PPUSH
37509: LD_VAR 0 1
37513: PPUSH
37514: EMPTY
37515: PPUSH
37516: CALL_OW 1
37520: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37521: LD_ADDR_EXP 132
37525: PUSH
37526: LD_EXP 132
37530: PPUSH
37531: LD_VAR 0 1
37535: PPUSH
37536: EMPTY
37537: PPUSH
37538: CALL_OW 1
37542: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37543: LD_ADDR_EXP 133
37547: PUSH
37548: LD_EXP 133
37552: PPUSH
37553: LD_VAR 0 1
37557: PPUSH
37558: EMPTY
37559: PPUSH
37560: CALL_OW 1
37564: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37565: LD_ADDR_EXP 134
37569: PUSH
37570: LD_EXP 134
37574: PPUSH
37575: LD_VAR 0 1
37579: PPUSH
37580: EMPTY
37581: PPUSH
37582: CALL_OW 1
37586: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37587: LD_ADDR_EXP 135
37591: PUSH
37592: LD_EXP 135
37596: PPUSH
37597: LD_VAR 0 1
37601: PPUSH
37602: EMPTY
37603: PPUSH
37604: CALL_OW 1
37608: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37609: LD_ADDR_EXP 136
37613: PUSH
37614: LD_EXP 136
37618: PPUSH
37619: LD_VAR 0 1
37623: PPUSH
37624: EMPTY
37625: PPUSH
37626: CALL_OW 1
37630: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37631: LD_ADDR_EXP 137
37635: PUSH
37636: LD_EXP 137
37640: PPUSH
37641: LD_VAR 0 1
37645: PPUSH
37646: EMPTY
37647: PPUSH
37648: CALL_OW 1
37652: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37653: LD_ADDR_EXP 138
37657: PUSH
37658: LD_EXP 138
37662: PPUSH
37663: LD_VAR 0 1
37667: PPUSH
37668: EMPTY
37669: PPUSH
37670: CALL_OW 1
37674: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37675: LD_ADDR_EXP 139
37679: PUSH
37680: LD_EXP 139
37684: PPUSH
37685: LD_VAR 0 1
37689: PPUSH
37690: EMPTY
37691: PPUSH
37692: CALL_OW 1
37696: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37697: LD_ADDR_EXP 140
37701: PUSH
37702: LD_EXP 140
37706: PPUSH
37707: LD_VAR 0 1
37711: PPUSH
37712: EMPTY
37713: PPUSH
37714: CALL_OW 1
37718: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37719: LD_ADDR_EXP 141
37723: PUSH
37724: LD_EXP 141
37728: PPUSH
37729: LD_VAR 0 1
37733: PPUSH
37734: LD_INT 0
37736: PPUSH
37737: CALL_OW 1
37741: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37742: LD_ADDR_EXP 142
37746: PUSH
37747: LD_EXP 142
37751: PPUSH
37752: LD_VAR 0 1
37756: PPUSH
37757: LD_INT 0
37759: PPUSH
37760: CALL_OW 1
37764: ST_TO_ADDR
// end ;
37765: LD_VAR 0 2
37769: RET
// export function MC_Add ( side , units ) ; var base ; begin
37770: LD_INT 0
37772: PPUSH
37773: PPUSH
// base := mc_bases + 1 ;
37774: LD_ADDR_VAR 0 4
37778: PUSH
37779: LD_EXP 99
37783: PUSH
37784: LD_INT 1
37786: PLUS
37787: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
37788: LD_ADDR_EXP 125
37792: PUSH
37793: LD_EXP 125
37797: PPUSH
37798: LD_VAR 0 4
37802: PPUSH
37803: LD_VAR 0 1
37807: PPUSH
37808: CALL_OW 1
37812: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
37813: LD_ADDR_EXP 99
37817: PUSH
37818: LD_EXP 99
37822: PPUSH
37823: LD_VAR 0 4
37827: PPUSH
37828: LD_VAR 0 2
37832: PPUSH
37833: CALL_OW 1
37837: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37838: LD_ADDR_EXP 100
37842: PUSH
37843: LD_EXP 100
37847: PPUSH
37848: LD_VAR 0 4
37852: PPUSH
37853: EMPTY
37854: PPUSH
37855: CALL_OW 1
37859: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37860: LD_ADDR_EXP 101
37864: PUSH
37865: LD_EXP 101
37869: PPUSH
37870: LD_VAR 0 4
37874: PPUSH
37875: EMPTY
37876: PPUSH
37877: CALL_OW 1
37881: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37882: LD_ADDR_EXP 102
37886: PUSH
37887: LD_EXP 102
37891: PPUSH
37892: LD_VAR 0 4
37896: PPUSH
37897: EMPTY
37898: PPUSH
37899: CALL_OW 1
37903: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37904: LD_ADDR_EXP 103
37908: PUSH
37909: LD_EXP 103
37913: PPUSH
37914: LD_VAR 0 4
37918: PPUSH
37919: EMPTY
37920: PPUSH
37921: CALL_OW 1
37925: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37926: LD_ADDR_EXP 104
37930: PUSH
37931: LD_EXP 104
37935: PPUSH
37936: LD_VAR 0 4
37940: PPUSH
37941: EMPTY
37942: PPUSH
37943: CALL_OW 1
37947: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37948: LD_ADDR_EXP 105
37952: PUSH
37953: LD_EXP 105
37957: PPUSH
37958: LD_VAR 0 4
37962: PPUSH
37963: EMPTY
37964: PPUSH
37965: CALL_OW 1
37969: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37970: LD_ADDR_EXP 106
37974: PUSH
37975: LD_EXP 106
37979: PPUSH
37980: LD_VAR 0 4
37984: PPUSH
37985: EMPTY
37986: PPUSH
37987: CALL_OW 1
37991: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37992: LD_ADDR_EXP 107
37996: PUSH
37997: LD_EXP 107
38001: PPUSH
38002: LD_VAR 0 4
38006: PPUSH
38007: EMPTY
38008: PPUSH
38009: CALL_OW 1
38013: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38014: LD_ADDR_EXP 108
38018: PUSH
38019: LD_EXP 108
38023: PPUSH
38024: LD_VAR 0 4
38028: PPUSH
38029: EMPTY
38030: PPUSH
38031: CALL_OW 1
38035: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38036: LD_ADDR_EXP 109
38040: PUSH
38041: LD_EXP 109
38045: PPUSH
38046: LD_VAR 0 4
38050: PPUSH
38051: EMPTY
38052: PPUSH
38053: CALL_OW 1
38057: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38058: LD_ADDR_EXP 110
38062: PUSH
38063: LD_EXP 110
38067: PPUSH
38068: LD_VAR 0 4
38072: PPUSH
38073: LD_INT 0
38075: PPUSH
38076: CALL_OW 1
38080: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38081: LD_ADDR_EXP 111
38085: PUSH
38086: LD_EXP 111
38090: PPUSH
38091: LD_VAR 0 4
38095: PPUSH
38096: EMPTY
38097: PPUSH
38098: CALL_OW 1
38102: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38103: LD_ADDR_EXP 112
38107: PUSH
38108: LD_EXP 112
38112: PPUSH
38113: LD_VAR 0 4
38117: PPUSH
38118: EMPTY
38119: PPUSH
38120: CALL_OW 1
38124: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38125: LD_ADDR_EXP 113
38129: PUSH
38130: LD_EXP 113
38134: PPUSH
38135: LD_VAR 0 4
38139: PPUSH
38140: EMPTY
38141: PPUSH
38142: CALL_OW 1
38146: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38147: LD_ADDR_EXP 114
38151: PUSH
38152: LD_EXP 114
38156: PPUSH
38157: LD_VAR 0 4
38161: PPUSH
38162: EMPTY
38163: PPUSH
38164: CALL_OW 1
38168: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38169: LD_ADDR_EXP 115
38173: PUSH
38174: LD_EXP 115
38178: PPUSH
38179: LD_VAR 0 4
38183: PPUSH
38184: EMPTY
38185: PPUSH
38186: CALL_OW 1
38190: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38191: LD_ADDR_EXP 116
38195: PUSH
38196: LD_EXP 116
38200: PPUSH
38201: LD_VAR 0 4
38205: PPUSH
38206: EMPTY
38207: PPUSH
38208: CALL_OW 1
38212: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38213: LD_ADDR_EXP 117
38217: PUSH
38218: LD_EXP 117
38222: PPUSH
38223: LD_VAR 0 4
38227: PPUSH
38228: EMPTY
38229: PPUSH
38230: CALL_OW 1
38234: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38235: LD_ADDR_EXP 118
38239: PUSH
38240: LD_EXP 118
38244: PPUSH
38245: LD_VAR 0 4
38249: PPUSH
38250: EMPTY
38251: PPUSH
38252: CALL_OW 1
38256: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38257: LD_ADDR_EXP 119
38261: PUSH
38262: LD_EXP 119
38266: PPUSH
38267: LD_VAR 0 4
38271: PPUSH
38272: EMPTY
38273: PPUSH
38274: CALL_OW 1
38278: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38279: LD_ADDR_EXP 120
38283: PUSH
38284: LD_EXP 120
38288: PPUSH
38289: LD_VAR 0 4
38293: PPUSH
38294: EMPTY
38295: PPUSH
38296: CALL_OW 1
38300: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38301: LD_ADDR_EXP 121
38305: PUSH
38306: LD_EXP 121
38310: PPUSH
38311: LD_VAR 0 4
38315: PPUSH
38316: EMPTY
38317: PPUSH
38318: CALL_OW 1
38322: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38323: LD_ADDR_EXP 122
38327: PUSH
38328: LD_EXP 122
38332: PPUSH
38333: LD_VAR 0 4
38337: PPUSH
38338: EMPTY
38339: PPUSH
38340: CALL_OW 1
38344: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38345: LD_ADDR_EXP 123
38349: PUSH
38350: LD_EXP 123
38354: PPUSH
38355: LD_VAR 0 4
38359: PPUSH
38360: EMPTY
38361: PPUSH
38362: CALL_OW 1
38366: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38367: LD_ADDR_EXP 124
38371: PUSH
38372: LD_EXP 124
38376: PPUSH
38377: LD_VAR 0 4
38381: PPUSH
38382: EMPTY
38383: PPUSH
38384: CALL_OW 1
38388: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38389: LD_ADDR_EXP 126
38393: PUSH
38394: LD_EXP 126
38398: PPUSH
38399: LD_VAR 0 4
38403: PPUSH
38404: EMPTY
38405: PPUSH
38406: CALL_OW 1
38410: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38411: LD_ADDR_EXP 128
38415: PUSH
38416: LD_EXP 128
38420: PPUSH
38421: LD_VAR 0 4
38425: PPUSH
38426: EMPTY
38427: PPUSH
38428: CALL_OW 1
38432: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38433: LD_ADDR_EXP 129
38437: PUSH
38438: LD_EXP 129
38442: PPUSH
38443: LD_VAR 0 4
38447: PPUSH
38448: EMPTY
38449: PPUSH
38450: CALL_OW 1
38454: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38455: LD_ADDR_EXP 130
38459: PUSH
38460: LD_EXP 130
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: EMPTY
38471: PPUSH
38472: CALL_OW 1
38476: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38477: LD_ADDR_EXP 131
38481: PUSH
38482: LD_EXP 131
38486: PPUSH
38487: LD_VAR 0 4
38491: PPUSH
38492: EMPTY
38493: PPUSH
38494: CALL_OW 1
38498: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38499: LD_ADDR_EXP 132
38503: PUSH
38504: LD_EXP 132
38508: PPUSH
38509: LD_VAR 0 4
38513: PPUSH
38514: EMPTY
38515: PPUSH
38516: CALL_OW 1
38520: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38521: LD_ADDR_EXP 133
38525: PUSH
38526: LD_EXP 133
38530: PPUSH
38531: LD_VAR 0 4
38535: PPUSH
38536: EMPTY
38537: PPUSH
38538: CALL_OW 1
38542: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38543: LD_ADDR_EXP 134
38547: PUSH
38548: LD_EXP 134
38552: PPUSH
38553: LD_VAR 0 4
38557: PPUSH
38558: EMPTY
38559: PPUSH
38560: CALL_OW 1
38564: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38565: LD_ADDR_EXP 135
38569: PUSH
38570: LD_EXP 135
38574: PPUSH
38575: LD_VAR 0 4
38579: PPUSH
38580: EMPTY
38581: PPUSH
38582: CALL_OW 1
38586: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38587: LD_ADDR_EXP 136
38591: PUSH
38592: LD_EXP 136
38596: PPUSH
38597: LD_VAR 0 4
38601: PPUSH
38602: EMPTY
38603: PPUSH
38604: CALL_OW 1
38608: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38609: LD_ADDR_EXP 137
38613: PUSH
38614: LD_EXP 137
38618: PPUSH
38619: LD_VAR 0 4
38623: PPUSH
38624: EMPTY
38625: PPUSH
38626: CALL_OW 1
38630: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38631: LD_ADDR_EXP 138
38635: PUSH
38636: LD_EXP 138
38640: PPUSH
38641: LD_VAR 0 4
38645: PPUSH
38646: EMPTY
38647: PPUSH
38648: CALL_OW 1
38652: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38653: LD_ADDR_EXP 139
38657: PUSH
38658: LD_EXP 139
38662: PPUSH
38663: LD_VAR 0 4
38667: PPUSH
38668: EMPTY
38669: PPUSH
38670: CALL_OW 1
38674: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38675: LD_ADDR_EXP 140
38679: PUSH
38680: LD_EXP 140
38684: PPUSH
38685: LD_VAR 0 4
38689: PPUSH
38690: EMPTY
38691: PPUSH
38692: CALL_OW 1
38696: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38697: LD_ADDR_EXP 141
38701: PUSH
38702: LD_EXP 141
38706: PPUSH
38707: LD_VAR 0 4
38711: PPUSH
38712: LD_INT 0
38714: PPUSH
38715: CALL_OW 1
38719: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38720: LD_ADDR_EXP 142
38724: PUSH
38725: LD_EXP 142
38729: PPUSH
38730: LD_VAR 0 4
38734: PPUSH
38735: LD_INT 0
38737: PPUSH
38738: CALL_OW 1
38742: ST_TO_ADDR
// result := base ;
38743: LD_ADDR_VAR 0 3
38747: PUSH
38748: LD_VAR 0 4
38752: ST_TO_ADDR
// end ;
38753: LD_VAR 0 3
38757: RET
// export function MC_Start ( ) ; var i ; begin
38758: LD_INT 0
38760: PPUSH
38761: PPUSH
// for i = 1 to mc_bases do
38762: LD_ADDR_VAR 0 2
38766: PUSH
38767: DOUBLE
38768: LD_INT 1
38770: DEC
38771: ST_TO_ADDR
38772: LD_EXP 99
38776: PUSH
38777: FOR_TO
38778: IFFALSE 39878
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
38780: LD_ADDR_EXP 99
38784: PUSH
38785: LD_EXP 99
38789: PPUSH
38790: LD_VAR 0 2
38794: PPUSH
38795: LD_EXP 99
38799: PUSH
38800: LD_VAR 0 2
38804: ARRAY
38805: PUSH
38806: LD_INT 0
38808: DIFF
38809: PPUSH
38810: CALL_OW 1
38814: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
38815: LD_ADDR_EXP 100
38819: PUSH
38820: LD_EXP 100
38824: PPUSH
38825: LD_VAR 0 2
38829: PPUSH
38830: EMPTY
38831: PPUSH
38832: CALL_OW 1
38836: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
38837: LD_ADDR_EXP 101
38841: PUSH
38842: LD_EXP 101
38846: PPUSH
38847: LD_VAR 0 2
38851: PPUSH
38852: EMPTY
38853: PPUSH
38854: CALL_OW 1
38858: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
38859: LD_ADDR_EXP 102
38863: PUSH
38864: LD_EXP 102
38868: PPUSH
38869: LD_VAR 0 2
38873: PPUSH
38874: EMPTY
38875: PPUSH
38876: CALL_OW 1
38880: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
38881: LD_ADDR_EXP 103
38885: PUSH
38886: LD_EXP 103
38890: PPUSH
38891: LD_VAR 0 2
38895: PPUSH
38896: EMPTY
38897: PUSH
38898: EMPTY
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PPUSH
38904: CALL_OW 1
38908: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
38909: LD_ADDR_EXP 104
38913: PUSH
38914: LD_EXP 104
38918: PPUSH
38919: LD_VAR 0 2
38923: PPUSH
38924: EMPTY
38925: PPUSH
38926: CALL_OW 1
38930: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
38931: LD_ADDR_EXP 131
38935: PUSH
38936: LD_EXP 131
38940: PPUSH
38941: LD_VAR 0 2
38945: PPUSH
38946: EMPTY
38947: PPUSH
38948: CALL_OW 1
38952: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
38953: LD_ADDR_EXP 105
38957: PUSH
38958: LD_EXP 105
38962: PPUSH
38963: LD_VAR 0 2
38967: PPUSH
38968: EMPTY
38969: PPUSH
38970: CALL_OW 1
38974: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
38975: LD_ADDR_EXP 106
38979: PUSH
38980: LD_EXP 106
38984: PPUSH
38985: LD_VAR 0 2
38989: PPUSH
38990: EMPTY
38991: PPUSH
38992: CALL_OW 1
38996: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
38997: LD_ADDR_EXP 107
39001: PUSH
39002: LD_EXP 107
39006: PPUSH
39007: LD_VAR 0 2
39011: PPUSH
39012: LD_EXP 99
39016: PUSH
39017: LD_VAR 0 2
39021: ARRAY
39022: PPUSH
39023: LD_INT 2
39025: PUSH
39026: LD_INT 30
39028: PUSH
39029: LD_INT 32
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 30
39038: PUSH
39039: LD_INT 33
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: LIST
39050: PPUSH
39051: CALL_OW 72
39055: PPUSH
39056: CALL_OW 1
39060: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39061: LD_ADDR_EXP 108
39065: PUSH
39066: LD_EXP 108
39070: PPUSH
39071: LD_VAR 0 2
39075: PPUSH
39076: LD_EXP 99
39080: PUSH
39081: LD_VAR 0 2
39085: ARRAY
39086: PPUSH
39087: LD_INT 2
39089: PUSH
39090: LD_INT 30
39092: PUSH
39093: LD_INT 32
39095: PUSH
39096: EMPTY
39097: LIST
39098: LIST
39099: PUSH
39100: LD_INT 30
39102: PUSH
39103: LD_INT 31
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 58
39117: PUSH
39118: EMPTY
39119: LIST
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PPUSH
39125: CALL_OW 72
39129: PPUSH
39130: CALL_OW 1
39134: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39135: LD_ADDR_EXP 109
39139: PUSH
39140: LD_EXP 109
39144: PPUSH
39145: LD_VAR 0 2
39149: PPUSH
39150: EMPTY
39151: PPUSH
39152: CALL_OW 1
39156: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39157: LD_ADDR_EXP 113
39161: PUSH
39162: LD_EXP 113
39166: PPUSH
39167: LD_VAR 0 2
39171: PPUSH
39172: EMPTY
39173: PPUSH
39174: CALL_OW 1
39178: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39179: LD_ADDR_EXP 112
39183: PUSH
39184: LD_EXP 112
39188: PPUSH
39189: LD_VAR 0 2
39193: PPUSH
39194: EMPTY
39195: PPUSH
39196: CALL_OW 1
39200: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39201: LD_ADDR_EXP 114
39205: PUSH
39206: LD_EXP 114
39210: PPUSH
39211: LD_VAR 0 2
39215: PPUSH
39216: EMPTY
39217: PPUSH
39218: CALL_OW 1
39222: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39223: LD_ADDR_EXP 115
39227: PUSH
39228: LD_EXP 115
39232: PPUSH
39233: LD_VAR 0 2
39237: PPUSH
39238: EMPTY
39239: PPUSH
39240: CALL_OW 1
39244: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39245: LD_ADDR_EXP 116
39249: PUSH
39250: LD_EXP 116
39254: PPUSH
39255: LD_VAR 0 2
39259: PPUSH
39260: EMPTY
39261: PPUSH
39262: CALL_OW 1
39266: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39267: LD_ADDR_EXP 117
39271: PUSH
39272: LD_EXP 117
39276: PPUSH
39277: LD_VAR 0 2
39281: PPUSH
39282: EMPTY
39283: PPUSH
39284: CALL_OW 1
39288: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39289: LD_ADDR_EXP 118
39293: PUSH
39294: LD_EXP 118
39298: PPUSH
39299: LD_VAR 0 2
39303: PPUSH
39304: EMPTY
39305: PPUSH
39306: CALL_OW 1
39310: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39311: LD_ADDR_EXP 119
39315: PUSH
39316: LD_EXP 119
39320: PPUSH
39321: LD_VAR 0 2
39325: PPUSH
39326: EMPTY
39327: PPUSH
39328: CALL_OW 1
39332: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
39333: LD_ADDR_EXP 120
39337: PUSH
39338: LD_EXP 120
39342: PPUSH
39343: LD_VAR 0 2
39347: PPUSH
39348: EMPTY
39349: PPUSH
39350: CALL_OW 1
39354: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39355: LD_ADDR_EXP 121
39359: PUSH
39360: LD_EXP 121
39364: PPUSH
39365: LD_VAR 0 2
39369: PPUSH
39370: EMPTY
39371: PPUSH
39372: CALL_OW 1
39376: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
39377: LD_ADDR_EXP 110
39381: PUSH
39382: LD_EXP 110
39386: PPUSH
39387: LD_VAR 0 2
39391: PPUSH
39392: LD_INT 0
39394: PPUSH
39395: CALL_OW 1
39399: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
39400: LD_ADDR_EXP 123
39404: PUSH
39405: LD_EXP 123
39409: PPUSH
39410: LD_VAR 0 2
39414: PPUSH
39415: LD_INT 0
39417: PPUSH
39418: CALL_OW 1
39422: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39423: LD_ADDR_EXP 111
39427: PUSH
39428: LD_EXP 111
39432: PPUSH
39433: LD_VAR 0 2
39437: PPUSH
39438: EMPTY
39439: PPUSH
39440: CALL_OW 1
39444: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
39445: LD_ADDR_EXP 122
39449: PUSH
39450: LD_EXP 122
39454: PPUSH
39455: LD_VAR 0 2
39459: PPUSH
39460: LD_INT 0
39462: PPUSH
39463: CALL_OW 1
39467: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
39468: LD_ADDR_EXP 124
39472: PUSH
39473: LD_EXP 124
39477: PPUSH
39478: LD_VAR 0 2
39482: PPUSH
39483: EMPTY
39484: PPUSH
39485: CALL_OW 1
39489: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
39490: LD_ADDR_EXP 127
39494: PUSH
39495: LD_EXP 127
39499: PPUSH
39500: LD_VAR 0 2
39504: PPUSH
39505: LD_INT 0
39507: PPUSH
39508: CALL_OW 1
39512: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
39513: LD_ADDR_EXP 128
39517: PUSH
39518: LD_EXP 128
39522: PPUSH
39523: LD_VAR 0 2
39527: PPUSH
39528: EMPTY
39529: PPUSH
39530: CALL_OW 1
39534: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39535: LD_ADDR_EXP 129
39539: PUSH
39540: LD_EXP 129
39544: PPUSH
39545: LD_VAR 0 2
39549: PPUSH
39550: EMPTY
39551: PPUSH
39552: CALL_OW 1
39556: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39557: LD_ADDR_EXP 130
39561: PUSH
39562: LD_EXP 130
39566: PPUSH
39567: LD_VAR 0 2
39571: PPUSH
39572: EMPTY
39573: PPUSH
39574: CALL_OW 1
39578: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
39579: LD_ADDR_EXP 132
39583: PUSH
39584: LD_EXP 132
39588: PPUSH
39589: LD_VAR 0 2
39593: PPUSH
39594: LD_EXP 99
39598: PUSH
39599: LD_VAR 0 2
39603: ARRAY
39604: PPUSH
39605: LD_INT 2
39607: PUSH
39608: LD_INT 30
39610: PUSH
39611: LD_INT 6
39613: PUSH
39614: EMPTY
39615: LIST
39616: LIST
39617: PUSH
39618: LD_INT 30
39620: PUSH
39621: LD_INT 7
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PUSH
39628: LD_INT 30
39630: PUSH
39631: LD_INT 8
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: PPUSH
39644: CALL_OW 72
39648: PPUSH
39649: CALL_OW 1
39653: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
39654: LD_ADDR_EXP 133
39658: PUSH
39659: LD_EXP 133
39663: PPUSH
39664: LD_VAR 0 2
39668: PPUSH
39669: EMPTY
39670: PPUSH
39671: CALL_OW 1
39675: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
39676: LD_ADDR_EXP 134
39680: PUSH
39681: LD_EXP 134
39685: PPUSH
39686: LD_VAR 0 2
39690: PPUSH
39691: EMPTY
39692: PPUSH
39693: CALL_OW 1
39697: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
39698: LD_ADDR_EXP 135
39702: PUSH
39703: LD_EXP 135
39707: PPUSH
39708: LD_VAR 0 2
39712: PPUSH
39713: EMPTY
39714: PPUSH
39715: CALL_OW 1
39719: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
39720: LD_ADDR_EXP 136
39724: PUSH
39725: LD_EXP 136
39729: PPUSH
39730: LD_VAR 0 2
39734: PPUSH
39735: EMPTY
39736: PPUSH
39737: CALL_OW 1
39741: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39742: LD_ADDR_EXP 137
39746: PUSH
39747: LD_EXP 137
39751: PPUSH
39752: LD_VAR 0 2
39756: PPUSH
39757: EMPTY
39758: PPUSH
39759: CALL_OW 1
39763: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
39764: LD_ADDR_EXP 138
39768: PUSH
39769: LD_EXP 138
39773: PPUSH
39774: LD_VAR 0 2
39778: PPUSH
39779: EMPTY
39780: PPUSH
39781: CALL_OW 1
39785: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
39786: LD_ADDR_EXP 139
39790: PUSH
39791: LD_EXP 139
39795: PPUSH
39796: LD_VAR 0 2
39800: PPUSH
39801: EMPTY
39802: PPUSH
39803: CALL_OW 1
39807: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
39808: LD_ADDR_EXP 140
39812: PUSH
39813: LD_EXP 140
39817: PPUSH
39818: LD_VAR 0 2
39822: PPUSH
39823: EMPTY
39824: PPUSH
39825: CALL_OW 1
39829: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
39830: LD_ADDR_EXP 141
39834: PUSH
39835: LD_EXP 141
39839: PPUSH
39840: LD_VAR 0 2
39844: PPUSH
39845: LD_INT 0
39847: PPUSH
39848: CALL_OW 1
39852: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
39853: LD_ADDR_EXP 142
39857: PUSH
39858: LD_EXP 142
39862: PPUSH
39863: LD_VAR 0 2
39867: PPUSH
39868: LD_INT 0
39870: PPUSH
39871: CALL_OW 1
39875: ST_TO_ADDR
// end ;
39876: GO 38777
39878: POP
39879: POP
// MC_InitSides ( ) ;
39880: CALL 40166 0 0
// MC_InitResearch ( ) ;
39884: CALL 39905 0 0
// CustomInitMacro ( ) ;
39888: CALL 475 0 0
// skirmish := true ;
39892: LD_ADDR_EXP 97
39896: PUSH
39897: LD_INT 1
39899: ST_TO_ADDR
// end ;
39900: LD_VAR 0 1
39904: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
39905: LD_INT 0
39907: PPUSH
39908: PPUSH
39909: PPUSH
39910: PPUSH
39911: PPUSH
39912: PPUSH
// if not mc_bases then
39913: LD_EXP 99
39917: NOT
39918: IFFALSE 39922
// exit ;
39920: GO 40161
// for i = 1 to 8 do
39922: LD_ADDR_VAR 0 2
39926: PUSH
39927: DOUBLE
39928: LD_INT 1
39930: DEC
39931: ST_TO_ADDR
39932: LD_INT 8
39934: PUSH
39935: FOR_TO
39936: IFFALSE 39962
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
39938: LD_ADDR_EXP 126
39942: PUSH
39943: LD_EXP 126
39947: PPUSH
39948: LD_VAR 0 2
39952: PPUSH
39953: EMPTY
39954: PPUSH
39955: CALL_OW 1
39959: ST_TO_ADDR
39960: GO 39935
39962: POP
39963: POP
// tmp := [ ] ;
39964: LD_ADDR_VAR 0 5
39968: PUSH
39969: EMPTY
39970: ST_TO_ADDR
// for i = 1 to mc_sides do
39971: LD_ADDR_VAR 0 2
39975: PUSH
39976: DOUBLE
39977: LD_INT 1
39979: DEC
39980: ST_TO_ADDR
39981: LD_EXP 125
39985: PUSH
39986: FOR_TO
39987: IFFALSE 40045
// if not mc_sides [ i ] in tmp then
39989: LD_EXP 125
39993: PUSH
39994: LD_VAR 0 2
39998: ARRAY
39999: PUSH
40000: LD_VAR 0 5
40004: IN
40005: NOT
40006: IFFALSE 40043
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
40008: LD_ADDR_VAR 0 5
40012: PUSH
40013: LD_VAR 0 5
40017: PPUSH
40018: LD_VAR 0 5
40022: PUSH
40023: LD_INT 1
40025: PLUS
40026: PPUSH
40027: LD_EXP 125
40031: PUSH
40032: LD_VAR 0 2
40036: ARRAY
40037: PPUSH
40038: CALL_OW 2
40042: ST_TO_ADDR
40043: GO 39986
40045: POP
40046: POP
// if not tmp then
40047: LD_VAR 0 5
40051: NOT
40052: IFFALSE 40056
// exit ;
40054: GO 40161
// for j in tmp do
40056: LD_ADDR_VAR 0 3
40060: PUSH
40061: LD_VAR 0 5
40065: PUSH
40066: FOR_IN
40067: IFFALSE 40159
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40069: LD_ADDR_VAR 0 6
40073: PUSH
40074: LD_INT 22
40076: PUSH
40077: LD_VAR 0 3
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PPUSH
40086: CALL_OW 69
40090: ST_TO_ADDR
// if not un then
40091: LD_VAR 0 6
40095: NOT
40096: IFFALSE 40100
// continue ;
40098: GO 40066
// nation := GetNation ( un [ 1 ] ) ;
40100: LD_ADDR_VAR 0 4
40104: PUSH
40105: LD_VAR 0 6
40109: PUSH
40110: LD_INT 1
40112: ARRAY
40113: PPUSH
40114: CALL_OW 248
40118: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40119: LD_ADDR_EXP 126
40123: PUSH
40124: LD_EXP 126
40128: PPUSH
40129: LD_VAR 0 3
40133: PPUSH
40134: LD_VAR 0 3
40138: PPUSH
40139: LD_VAR 0 4
40143: PPUSH
40144: LD_INT 1
40146: PPUSH
40147: CALL 67313 0 3
40151: PPUSH
40152: CALL_OW 1
40156: ST_TO_ADDR
// end ;
40157: GO 40066
40159: POP
40160: POP
// end ;
40161: LD_VAR 0 1
40165: RET
// export function MC_InitSides ( ) ; var i ; begin
40166: LD_INT 0
40168: PPUSH
40169: PPUSH
// if not mc_bases then
40170: LD_EXP 99
40174: NOT
40175: IFFALSE 40179
// exit ;
40177: GO 40253
// for i = 1 to mc_bases do
40179: LD_ADDR_VAR 0 2
40183: PUSH
40184: DOUBLE
40185: LD_INT 1
40187: DEC
40188: ST_TO_ADDR
40189: LD_EXP 99
40193: PUSH
40194: FOR_TO
40195: IFFALSE 40251
// if mc_bases [ i ] then
40197: LD_EXP 99
40201: PUSH
40202: LD_VAR 0 2
40206: ARRAY
40207: IFFALSE 40249
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40209: LD_ADDR_EXP 125
40213: PUSH
40214: LD_EXP 125
40218: PPUSH
40219: LD_VAR 0 2
40223: PPUSH
40224: LD_EXP 99
40228: PUSH
40229: LD_VAR 0 2
40233: ARRAY
40234: PUSH
40235: LD_INT 1
40237: ARRAY
40238: PPUSH
40239: CALL_OW 255
40243: PPUSH
40244: CALL_OW 1
40248: ST_TO_ADDR
40249: GO 40194
40251: POP
40252: POP
// end ;
40253: LD_VAR 0 1
40257: RET
// every 0 0$03 trigger skirmish do
40258: LD_EXP 97
40262: IFFALSE 40416
40264: GO 40266
40266: DISABLE
// begin enable ;
40267: ENABLE
// MC_CheckBuildings ( ) ;
40268: CALL 44914 0 0
// MC_CheckPeopleLife ( ) ;
40272: CALL 45075 0 0
// RaiseSailEvent ( 100 ) ;
40276: LD_INT 100
40278: PPUSH
40279: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40283: LD_INT 103
40285: PPUSH
40286: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40290: LD_INT 104
40292: PPUSH
40293: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40297: LD_INT 105
40299: PPUSH
40300: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
40304: LD_INT 106
40306: PPUSH
40307: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
40311: LD_INT 107
40313: PPUSH
40314: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
40318: LD_INT 108
40320: PPUSH
40321: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
40325: LD_INT 109
40327: PPUSH
40328: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
40332: LD_INT 110
40334: PPUSH
40335: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
40339: LD_INT 111
40341: PPUSH
40342: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
40346: LD_INT 112
40348: PPUSH
40349: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
40353: LD_INT 113
40355: PPUSH
40356: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
40360: LD_INT 120
40362: PPUSH
40363: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
40367: LD_INT 121
40369: PPUSH
40370: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
40374: LD_INT 122
40376: PPUSH
40377: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
40381: LD_INT 123
40383: PPUSH
40384: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
40388: LD_INT 124
40390: PPUSH
40391: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
40395: LD_INT 125
40397: PPUSH
40398: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
40402: LD_INT 126
40404: PPUSH
40405: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
40409: LD_INT 200
40411: PPUSH
40412: CALL_OW 427
// end ;
40416: END
// on SailEvent ( event ) do begin if event < 100 then
40417: LD_VAR 0 1
40421: PUSH
40422: LD_INT 100
40424: LESS
40425: IFFALSE 40436
// CustomEvent ( event ) ;
40427: LD_VAR 0 1
40431: PPUSH
40432: CALL 34961 0 1
// if event = 100 then
40436: LD_VAR 0 1
40440: PUSH
40441: LD_INT 100
40443: EQUAL
40444: IFFALSE 40450
// MC_ClassManager ( ) ;
40446: CALL 40842 0 0
// if event = 101 then
40450: LD_VAR 0 1
40454: PUSH
40455: LD_INT 101
40457: EQUAL
40458: IFFALSE 40464
// MC_RepairBuildings ( ) ;
40460: CALL 45660 0 0
// if event = 102 then
40464: LD_VAR 0 1
40468: PUSH
40469: LD_INT 102
40471: EQUAL
40472: IFFALSE 40478
// MC_Heal ( ) ;
40474: CALL 46595 0 0
// if event = 103 then
40478: LD_VAR 0 1
40482: PUSH
40483: LD_INT 103
40485: EQUAL
40486: IFFALSE 40492
// MC_Build ( ) ;
40488: CALL 47017 0 0
// if event = 104 then
40492: LD_VAR 0 1
40496: PUSH
40497: LD_INT 104
40499: EQUAL
40500: IFFALSE 40506
// MC_TurretWeapon ( ) ;
40502: CALL 48651 0 0
// if event = 105 then
40506: LD_VAR 0 1
40510: PUSH
40511: LD_INT 105
40513: EQUAL
40514: IFFALSE 40520
// MC_BuildUpgrade ( ) ;
40516: CALL 48202 0 0
// if event = 106 then
40520: LD_VAR 0 1
40524: PUSH
40525: LD_INT 106
40527: EQUAL
40528: IFFALSE 40534
// MC_PlantMines ( ) ;
40530: CALL 49081 0 0
// if event = 107 then
40534: LD_VAR 0 1
40538: PUSH
40539: LD_INT 107
40541: EQUAL
40542: IFFALSE 40548
// MC_CollectCrates ( ) ;
40544: CALL 49872 0 0
// if event = 108 then
40548: LD_VAR 0 1
40552: PUSH
40553: LD_INT 108
40555: EQUAL
40556: IFFALSE 40562
// MC_LinkRemoteControl ( ) ;
40558: CALL 51722 0 0
// if event = 109 then
40562: LD_VAR 0 1
40566: PUSH
40567: LD_INT 109
40569: EQUAL
40570: IFFALSE 40576
// MC_ProduceVehicle ( ) ;
40572: CALL 51903 0 0
// if event = 110 then
40576: LD_VAR 0 1
40580: PUSH
40581: LD_INT 110
40583: EQUAL
40584: IFFALSE 40590
// MC_SendAttack ( ) ;
40586: CALL 52369 0 0
// if event = 111 then
40590: LD_VAR 0 1
40594: PUSH
40595: LD_INT 111
40597: EQUAL
40598: IFFALSE 40604
// MC_Defend ( ) ;
40600: CALL 52477 0 0
// if event = 112 then
40604: LD_VAR 0 1
40608: PUSH
40609: LD_INT 112
40611: EQUAL
40612: IFFALSE 40618
// MC_Research ( ) ;
40614: CALL 53357 0 0
// if event = 113 then
40618: LD_VAR 0 1
40622: PUSH
40623: LD_INT 113
40625: EQUAL
40626: IFFALSE 40632
// MC_MinesTrigger ( ) ;
40628: CALL 54471 0 0
// if event = 120 then
40632: LD_VAR 0 1
40636: PUSH
40637: LD_INT 120
40639: EQUAL
40640: IFFALSE 40646
// MC_RepairVehicle ( ) ;
40642: CALL 54570 0 0
// if event = 121 then
40646: LD_VAR 0 1
40650: PUSH
40651: LD_INT 121
40653: EQUAL
40654: IFFALSE 40660
// MC_TameApe ( ) ;
40656: CALL 55339 0 0
// if event = 122 then
40660: LD_VAR 0 1
40664: PUSH
40665: LD_INT 122
40667: EQUAL
40668: IFFALSE 40674
// MC_ChangeApeClass ( ) ;
40670: CALL 56168 0 0
// if event = 123 then
40674: LD_VAR 0 1
40678: PUSH
40679: LD_INT 123
40681: EQUAL
40682: IFFALSE 40688
// MC_Bazooka ( ) ;
40684: CALL 56818 0 0
// if event = 124 then
40688: LD_VAR 0 1
40692: PUSH
40693: LD_INT 124
40695: EQUAL
40696: IFFALSE 40702
// MC_TeleportExit ( ) ;
40698: CALL 57016 0 0
// if event = 125 then
40702: LD_VAR 0 1
40706: PUSH
40707: LD_INT 125
40709: EQUAL
40710: IFFALSE 40716
// MC_Deposits ( ) ;
40712: CALL 57663 0 0
// if event = 126 then
40716: LD_VAR 0 1
40720: PUSH
40721: LD_INT 126
40723: EQUAL
40724: IFFALSE 40730
// MC_RemoteDriver ( ) ;
40726: CALL 58288 0 0
// if event = 200 then
40730: LD_VAR 0 1
40734: PUSH
40735: LD_INT 200
40737: EQUAL
40738: IFFALSE 40744
// MC_Idle ( ) ;
40740: CALL 60237 0 0
// end ;
40744: PPOPN 1
40746: END
// export function MC_Reset ( base , tag ) ; var i ; begin
40747: LD_INT 0
40749: PPUSH
40750: PPUSH
// if not mc_bases [ base ] or not tag then
40751: LD_EXP 99
40755: PUSH
40756: LD_VAR 0 1
40760: ARRAY
40761: NOT
40762: PUSH
40763: LD_VAR 0 2
40767: NOT
40768: OR
40769: IFFALSE 40773
// exit ;
40771: GO 40837
// for i in mc_bases [ base ] union mc_ape [ base ] do
40773: LD_ADDR_VAR 0 4
40777: PUSH
40778: LD_EXP 99
40782: PUSH
40783: LD_VAR 0 1
40787: ARRAY
40788: PUSH
40789: LD_EXP 128
40793: PUSH
40794: LD_VAR 0 1
40798: ARRAY
40799: UNION
40800: PUSH
40801: FOR_IN
40802: IFFALSE 40835
// if GetTag ( i ) = tag then
40804: LD_VAR 0 4
40808: PPUSH
40809: CALL_OW 110
40813: PUSH
40814: LD_VAR 0 2
40818: EQUAL
40819: IFFALSE 40833
// SetTag ( i , 0 ) ;
40821: LD_VAR 0 4
40825: PPUSH
40826: LD_INT 0
40828: PPUSH
40829: CALL_OW 109
40833: GO 40801
40835: POP
40836: POP
// end ;
40837: LD_VAR 0 3
40841: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
40842: LD_INT 0
40844: PPUSH
40845: PPUSH
40846: PPUSH
40847: PPUSH
40848: PPUSH
40849: PPUSH
40850: PPUSH
40851: PPUSH
// if not mc_bases then
40852: LD_EXP 99
40856: NOT
40857: IFFALSE 40861
// exit ;
40859: GO 41319
// for i = 1 to mc_bases do
40861: LD_ADDR_VAR 0 2
40865: PUSH
40866: DOUBLE
40867: LD_INT 1
40869: DEC
40870: ST_TO_ADDR
40871: LD_EXP 99
40875: PUSH
40876: FOR_TO
40877: IFFALSE 41317
// begin tmp := MC_ClassCheckReq ( i ) ;
40879: LD_ADDR_VAR 0 4
40883: PUSH
40884: LD_VAR 0 2
40888: PPUSH
40889: CALL 41324 0 1
40893: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
40894: LD_ADDR_EXP 140
40898: PUSH
40899: LD_EXP 140
40903: PPUSH
40904: LD_VAR 0 2
40908: PPUSH
40909: LD_VAR 0 4
40913: PPUSH
40914: CALL_OW 1
40918: ST_TO_ADDR
// if not tmp then
40919: LD_VAR 0 4
40923: NOT
40924: IFFALSE 40928
// continue ;
40926: GO 40876
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
40928: LD_ADDR_VAR 0 6
40932: PUSH
40933: LD_EXP 99
40937: PUSH
40938: LD_VAR 0 2
40942: ARRAY
40943: PPUSH
40944: LD_INT 2
40946: PUSH
40947: LD_INT 30
40949: PUSH
40950: LD_INT 4
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 30
40959: PUSH
40960: LD_INT 5
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: LIST
40971: PPUSH
40972: CALL_OW 72
40976: PUSH
40977: LD_EXP 99
40981: PUSH
40982: LD_VAR 0 2
40986: ARRAY
40987: PPUSH
40988: LD_INT 2
40990: PUSH
40991: LD_INT 30
40993: PUSH
40994: LD_INT 0
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: LD_INT 30
41003: PUSH
41004: LD_INT 1
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: LIST
41015: PPUSH
41016: CALL_OW 72
41020: PUSH
41021: LD_EXP 99
41025: PUSH
41026: LD_VAR 0 2
41030: ARRAY
41031: PPUSH
41032: LD_INT 30
41034: PUSH
41035: LD_INT 3
41037: PUSH
41038: EMPTY
41039: LIST
41040: LIST
41041: PPUSH
41042: CALL_OW 72
41046: PUSH
41047: LD_EXP 99
41051: PUSH
41052: LD_VAR 0 2
41056: ARRAY
41057: PPUSH
41058: LD_INT 2
41060: PUSH
41061: LD_INT 30
41063: PUSH
41064: LD_INT 6
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 30
41073: PUSH
41074: LD_INT 7
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 30
41083: PUSH
41084: LD_INT 8
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: PPUSH
41097: CALL_OW 72
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: ST_TO_ADDR
// for j = 1 to 4 do
41108: LD_ADDR_VAR 0 3
41112: PUSH
41113: DOUBLE
41114: LD_INT 1
41116: DEC
41117: ST_TO_ADDR
41118: LD_INT 4
41120: PUSH
41121: FOR_TO
41122: IFFALSE 41313
// begin if not tmp [ j ] then
41124: LD_VAR 0 4
41128: PUSH
41129: LD_VAR 0 3
41133: ARRAY
41134: NOT
41135: IFFALSE 41139
// continue ;
41137: GO 41121
// for p in tmp [ j ] do
41139: LD_ADDR_VAR 0 5
41143: PUSH
41144: LD_VAR 0 4
41148: PUSH
41149: LD_VAR 0 3
41153: ARRAY
41154: PUSH
41155: FOR_IN
41156: IFFALSE 41309
// begin if not b [ j ] then
41158: LD_VAR 0 6
41162: PUSH
41163: LD_VAR 0 3
41167: ARRAY
41168: NOT
41169: IFFALSE 41173
// break ;
41171: GO 41309
// e := 0 ;
41173: LD_ADDR_VAR 0 7
41177: PUSH
41178: LD_INT 0
41180: ST_TO_ADDR
// for k in b [ j ] do
41181: LD_ADDR_VAR 0 8
41185: PUSH
41186: LD_VAR 0 6
41190: PUSH
41191: LD_VAR 0 3
41195: ARRAY
41196: PUSH
41197: FOR_IN
41198: IFFALSE 41225
// if IsNotFull ( k ) then
41200: LD_VAR 0 8
41204: PPUSH
41205: CALL 69466 0 1
41209: IFFALSE 41223
// begin e := k ;
41211: LD_ADDR_VAR 0 7
41215: PUSH
41216: LD_VAR 0 8
41220: ST_TO_ADDR
// break ;
41221: GO 41225
// end ;
41223: GO 41197
41225: POP
41226: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41227: LD_VAR 0 7
41231: PUSH
41232: LD_VAR 0 5
41236: PPUSH
41237: LD_VAR 0 7
41241: PPUSH
41242: CALL 103345 0 2
41246: NOT
41247: AND
41248: IFFALSE 41307
// begin if IsInUnit ( p ) then
41250: LD_VAR 0 5
41254: PPUSH
41255: CALL_OW 310
41259: IFFALSE 41270
// ComExitBuilding ( p ) ;
41261: LD_VAR 0 5
41265: PPUSH
41266: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41270: LD_VAR 0 5
41274: PPUSH
41275: LD_VAR 0 7
41279: PPUSH
41280: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41284: LD_VAR 0 5
41288: PPUSH
41289: LD_VAR 0 3
41293: PPUSH
41294: CALL_OW 183
// AddComExitBuilding ( p ) ;
41298: LD_VAR 0 5
41302: PPUSH
41303: CALL_OW 182
// end ; end ;
41307: GO 41155
41309: POP
41310: POP
// end ;
41311: GO 41121
41313: POP
41314: POP
// end ;
41315: GO 40876
41317: POP
41318: POP
// end ;
41319: LD_VAR 0 1
41323: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
41324: LD_INT 0
41326: PPUSH
41327: PPUSH
41328: PPUSH
41329: PPUSH
41330: PPUSH
41331: PPUSH
41332: PPUSH
41333: PPUSH
41334: PPUSH
41335: PPUSH
41336: PPUSH
41337: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41338: LD_VAR 0 1
41342: NOT
41343: PUSH
41344: LD_EXP 99
41348: PUSH
41349: LD_VAR 0 1
41353: ARRAY
41354: NOT
41355: OR
41356: PUSH
41357: LD_EXP 99
41361: PUSH
41362: LD_VAR 0 1
41366: ARRAY
41367: PPUSH
41368: LD_INT 2
41370: PUSH
41371: LD_INT 30
41373: PUSH
41374: LD_INT 0
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 30
41383: PUSH
41384: LD_INT 1
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: LIST
41395: PPUSH
41396: CALL_OW 72
41400: NOT
41401: OR
41402: IFFALSE 41406
// exit ;
41404: GO 44909
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41406: LD_ADDR_VAR 0 4
41410: PUSH
41411: LD_EXP 99
41415: PUSH
41416: LD_VAR 0 1
41420: ARRAY
41421: PPUSH
41422: LD_INT 2
41424: PUSH
41425: LD_INT 25
41427: PUSH
41428: LD_INT 1
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: PUSH
41435: LD_INT 25
41437: PUSH
41438: LD_INT 2
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: LD_INT 25
41447: PUSH
41448: LD_INT 3
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PUSH
41455: LD_INT 25
41457: PUSH
41458: LD_INT 4
41460: PUSH
41461: EMPTY
41462: LIST
41463: LIST
41464: PUSH
41465: LD_INT 25
41467: PUSH
41468: LD_INT 5
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PUSH
41475: LD_INT 25
41477: PUSH
41478: LD_INT 8
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PUSH
41485: LD_INT 25
41487: PUSH
41488: LD_INT 9
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: LIST
41502: LIST
41503: LIST
41504: PPUSH
41505: CALL_OW 72
41509: ST_TO_ADDR
// if not tmp then
41510: LD_VAR 0 4
41514: NOT
41515: IFFALSE 41519
// exit ;
41517: GO 44909
// for i in tmp do
41519: LD_ADDR_VAR 0 3
41523: PUSH
41524: LD_VAR 0 4
41528: PUSH
41529: FOR_IN
41530: IFFALSE 41561
// if GetTag ( i ) then
41532: LD_VAR 0 3
41536: PPUSH
41537: CALL_OW 110
41541: IFFALSE 41559
// tmp := tmp diff i ;
41543: LD_ADDR_VAR 0 4
41547: PUSH
41548: LD_VAR 0 4
41552: PUSH
41553: LD_VAR 0 3
41557: DIFF
41558: ST_TO_ADDR
41559: GO 41529
41561: POP
41562: POP
// if not tmp then
41563: LD_VAR 0 4
41567: NOT
41568: IFFALSE 41572
// exit ;
41570: GO 44909
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41572: LD_ADDR_VAR 0 5
41576: PUSH
41577: LD_EXP 99
41581: PUSH
41582: LD_VAR 0 1
41586: ARRAY
41587: PPUSH
41588: LD_INT 2
41590: PUSH
41591: LD_INT 25
41593: PUSH
41594: LD_INT 1
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: PUSH
41601: LD_INT 25
41603: PUSH
41604: LD_INT 5
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: LD_INT 25
41613: PUSH
41614: LD_INT 8
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 25
41623: PUSH
41624: LD_INT 9
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: LIST
41635: LIST
41636: LIST
41637: PPUSH
41638: CALL_OW 72
41642: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
41643: LD_ADDR_VAR 0 6
41647: PUSH
41648: LD_EXP 99
41652: PUSH
41653: LD_VAR 0 1
41657: ARRAY
41658: PPUSH
41659: LD_INT 25
41661: PUSH
41662: LD_INT 2
41664: PUSH
41665: EMPTY
41666: LIST
41667: LIST
41668: PPUSH
41669: CALL_OW 72
41673: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
41674: LD_ADDR_VAR 0 7
41678: PUSH
41679: LD_EXP 99
41683: PUSH
41684: LD_VAR 0 1
41688: ARRAY
41689: PPUSH
41690: LD_INT 25
41692: PUSH
41693: LD_INT 3
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: PPUSH
41700: CALL_OW 72
41704: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
41705: LD_ADDR_VAR 0 8
41709: PUSH
41710: LD_EXP 99
41714: PUSH
41715: LD_VAR 0 1
41719: ARRAY
41720: PPUSH
41721: LD_INT 25
41723: PUSH
41724: LD_INT 4
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 24
41733: PUSH
41734: LD_INT 251
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PPUSH
41745: CALL_OW 72
41749: ST_TO_ADDR
// if mc_is_defending [ base ] then
41750: LD_EXP 142
41754: PUSH
41755: LD_VAR 0 1
41759: ARRAY
41760: IFFALSE 42221
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
41762: LD_ADDR_EXP 141
41766: PUSH
41767: LD_EXP 141
41771: PPUSH
41772: LD_VAR 0 1
41776: PPUSH
41777: LD_INT 4
41779: PPUSH
41780: CALL_OW 1
41784: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41785: LD_ADDR_VAR 0 12
41789: PUSH
41790: LD_EXP 99
41794: PUSH
41795: LD_VAR 0 1
41799: ARRAY
41800: PPUSH
41801: LD_INT 2
41803: PUSH
41804: LD_INT 30
41806: PUSH
41807: LD_INT 4
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 30
41816: PUSH
41817: LD_INT 5
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: LIST
41828: PPUSH
41829: CALL_OW 72
41833: ST_TO_ADDR
// if not b then
41834: LD_VAR 0 12
41838: NOT
41839: IFFALSE 41843
// exit ;
41841: GO 44909
// p := [ ] ;
41843: LD_ADDR_VAR 0 11
41847: PUSH
41848: EMPTY
41849: ST_TO_ADDR
// if sci >= 2 then
41850: LD_VAR 0 8
41854: PUSH
41855: LD_INT 2
41857: GREATEREQUAL
41858: IFFALSE 41889
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
41860: LD_ADDR_VAR 0 8
41864: PUSH
41865: LD_VAR 0 8
41869: PUSH
41870: LD_INT 1
41872: ARRAY
41873: PUSH
41874: LD_VAR 0 8
41878: PUSH
41879: LD_INT 2
41881: ARRAY
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: ST_TO_ADDR
41887: GO 41950
// if sci = 1 then
41889: LD_VAR 0 8
41893: PUSH
41894: LD_INT 1
41896: EQUAL
41897: IFFALSE 41918
// sci := [ sci [ 1 ] ] else
41899: LD_ADDR_VAR 0 8
41903: PUSH
41904: LD_VAR 0 8
41908: PUSH
41909: LD_INT 1
41911: ARRAY
41912: PUSH
41913: EMPTY
41914: LIST
41915: ST_TO_ADDR
41916: GO 41950
// if sci = 0 then
41918: LD_VAR 0 8
41922: PUSH
41923: LD_INT 0
41925: EQUAL
41926: IFFALSE 41950
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
41928: LD_ADDR_VAR 0 11
41932: PUSH
41933: LD_VAR 0 4
41937: PPUSH
41938: LD_INT 4
41940: PPUSH
41941: CALL 103208 0 2
41945: PUSH
41946: LD_INT 1
41948: ARRAY
41949: ST_TO_ADDR
// if eng > 4 then
41950: LD_VAR 0 6
41954: PUSH
41955: LD_INT 4
41957: GREATER
41958: IFFALSE 42004
// for i = eng downto 4 do
41960: LD_ADDR_VAR 0 3
41964: PUSH
41965: DOUBLE
41966: LD_VAR 0 6
41970: INC
41971: ST_TO_ADDR
41972: LD_INT 4
41974: PUSH
41975: FOR_DOWNTO
41976: IFFALSE 42002
// eng := eng diff eng [ i ] ;
41978: LD_ADDR_VAR 0 6
41982: PUSH
41983: LD_VAR 0 6
41987: PUSH
41988: LD_VAR 0 6
41992: PUSH
41993: LD_VAR 0 3
41997: ARRAY
41998: DIFF
41999: ST_TO_ADDR
42000: GO 41975
42002: POP
42003: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
42004: LD_ADDR_VAR 0 4
42008: PUSH
42009: LD_VAR 0 4
42013: PUSH
42014: LD_VAR 0 5
42018: PUSH
42019: LD_VAR 0 6
42023: UNION
42024: PUSH
42025: LD_VAR 0 7
42029: UNION
42030: PUSH
42031: LD_VAR 0 8
42035: UNION
42036: DIFF
42037: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
42038: LD_ADDR_VAR 0 13
42042: PUSH
42043: LD_EXP 99
42047: PUSH
42048: LD_VAR 0 1
42052: ARRAY
42053: PPUSH
42054: LD_INT 2
42056: PUSH
42057: LD_INT 30
42059: PUSH
42060: LD_INT 32
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: PUSH
42067: LD_INT 30
42069: PUSH
42070: LD_INT 31
42072: PUSH
42073: EMPTY
42074: LIST
42075: LIST
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: LIST
42081: PPUSH
42082: CALL_OW 72
42086: PUSH
42087: LD_EXP 99
42091: PUSH
42092: LD_VAR 0 1
42096: ARRAY
42097: PPUSH
42098: LD_INT 2
42100: PUSH
42101: LD_INT 30
42103: PUSH
42104: LD_INT 4
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 30
42113: PUSH
42114: LD_INT 5
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: LIST
42125: PPUSH
42126: CALL_OW 72
42130: PUSH
42131: LD_INT 6
42133: MUL
42134: PLUS
42135: ST_TO_ADDR
// if bcount < tmp then
42136: LD_VAR 0 13
42140: PUSH
42141: LD_VAR 0 4
42145: LESS
42146: IFFALSE 42192
// for i = tmp downto bcount do
42148: LD_ADDR_VAR 0 3
42152: PUSH
42153: DOUBLE
42154: LD_VAR 0 4
42158: INC
42159: ST_TO_ADDR
42160: LD_VAR 0 13
42164: PUSH
42165: FOR_DOWNTO
42166: IFFALSE 42190
// tmp := Delete ( tmp , tmp ) ;
42168: LD_ADDR_VAR 0 4
42172: PUSH
42173: LD_VAR 0 4
42177: PPUSH
42178: LD_VAR 0 4
42182: PPUSH
42183: CALL_OW 3
42187: ST_TO_ADDR
42188: GO 42165
42190: POP
42191: POP
// result := [ tmp , 0 , 0 , p ] ;
42192: LD_ADDR_VAR 0 2
42196: PUSH
42197: LD_VAR 0 4
42201: PUSH
42202: LD_INT 0
42204: PUSH
42205: LD_INT 0
42207: PUSH
42208: LD_VAR 0 11
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: LIST
42217: LIST
42218: ST_TO_ADDR
// exit ;
42219: GO 44909
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42221: LD_EXP 99
42225: PUSH
42226: LD_VAR 0 1
42230: ARRAY
42231: PPUSH
42232: LD_INT 2
42234: PUSH
42235: LD_INT 30
42237: PUSH
42238: LD_INT 6
42240: PUSH
42241: EMPTY
42242: LIST
42243: LIST
42244: PUSH
42245: LD_INT 30
42247: PUSH
42248: LD_INT 7
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PUSH
42255: LD_INT 30
42257: PUSH
42258: LD_INT 8
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: LIST
42269: LIST
42270: PPUSH
42271: CALL_OW 72
42275: NOT
42276: PUSH
42277: LD_EXP 99
42281: PUSH
42282: LD_VAR 0 1
42286: ARRAY
42287: PPUSH
42288: LD_INT 30
42290: PUSH
42291: LD_INT 3
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PPUSH
42298: CALL_OW 72
42302: NOT
42303: AND
42304: IFFALSE 42376
// begin if eng = tmp then
42306: LD_VAR 0 6
42310: PUSH
42311: LD_VAR 0 4
42315: EQUAL
42316: IFFALSE 42320
// exit ;
42318: GO 44909
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
42320: LD_ADDR_EXP 141
42324: PUSH
42325: LD_EXP 141
42329: PPUSH
42330: LD_VAR 0 1
42334: PPUSH
42335: LD_INT 1
42337: PPUSH
42338: CALL_OW 1
42342: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
42343: LD_ADDR_VAR 0 2
42347: PUSH
42348: LD_INT 0
42350: PUSH
42351: LD_VAR 0 4
42355: PUSH
42356: LD_VAR 0 6
42360: DIFF
42361: PUSH
42362: LD_INT 0
42364: PUSH
42365: LD_INT 0
42367: PUSH
42368: EMPTY
42369: LIST
42370: LIST
42371: LIST
42372: LIST
42373: ST_TO_ADDR
// exit ;
42374: GO 44909
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42376: LD_EXP 126
42380: PUSH
42381: LD_EXP 125
42385: PUSH
42386: LD_VAR 0 1
42390: ARRAY
42391: ARRAY
42392: PUSH
42393: LD_EXP 99
42397: PUSH
42398: LD_VAR 0 1
42402: ARRAY
42403: PPUSH
42404: LD_INT 2
42406: PUSH
42407: LD_INT 30
42409: PUSH
42410: LD_INT 6
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: PUSH
42417: LD_INT 30
42419: PUSH
42420: LD_INT 7
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 30
42429: PUSH
42430: LD_INT 8
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: PPUSH
42443: CALL_OW 72
42447: AND
42448: PUSH
42449: LD_EXP 99
42453: PUSH
42454: LD_VAR 0 1
42458: ARRAY
42459: PPUSH
42460: LD_INT 30
42462: PUSH
42463: LD_INT 3
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PPUSH
42470: CALL_OW 72
42474: NOT
42475: AND
42476: IFFALSE 42690
// begin if sci >= 6 then
42478: LD_VAR 0 8
42482: PUSH
42483: LD_INT 6
42485: GREATEREQUAL
42486: IFFALSE 42490
// exit ;
42488: GO 44909
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
42490: LD_ADDR_EXP 141
42494: PUSH
42495: LD_EXP 141
42499: PPUSH
42500: LD_VAR 0 1
42504: PPUSH
42505: LD_INT 2
42507: PPUSH
42508: CALL_OW 1
42512: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
42513: LD_ADDR_VAR 0 9
42517: PUSH
42518: LD_VAR 0 4
42522: PUSH
42523: LD_VAR 0 8
42527: DIFF
42528: PPUSH
42529: LD_INT 4
42531: PPUSH
42532: CALL 103208 0 2
42536: ST_TO_ADDR
// p := [ ] ;
42537: LD_ADDR_VAR 0 11
42541: PUSH
42542: EMPTY
42543: ST_TO_ADDR
// if sci < 6 and sort > 6 then
42544: LD_VAR 0 8
42548: PUSH
42549: LD_INT 6
42551: LESS
42552: PUSH
42553: LD_VAR 0 9
42557: PUSH
42558: LD_INT 6
42560: GREATER
42561: AND
42562: IFFALSE 42643
// begin for i = 1 to 6 - sci do
42564: LD_ADDR_VAR 0 3
42568: PUSH
42569: DOUBLE
42570: LD_INT 1
42572: DEC
42573: ST_TO_ADDR
42574: LD_INT 6
42576: PUSH
42577: LD_VAR 0 8
42581: MINUS
42582: PUSH
42583: FOR_TO
42584: IFFALSE 42639
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
42586: LD_ADDR_VAR 0 11
42590: PUSH
42591: LD_VAR 0 11
42595: PPUSH
42596: LD_VAR 0 11
42600: PUSH
42601: LD_INT 1
42603: PLUS
42604: PPUSH
42605: LD_VAR 0 9
42609: PUSH
42610: LD_INT 1
42612: ARRAY
42613: PPUSH
42614: CALL_OW 2
42618: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
42619: LD_ADDR_VAR 0 9
42623: PUSH
42624: LD_VAR 0 9
42628: PPUSH
42629: LD_INT 1
42631: PPUSH
42632: CALL_OW 3
42636: ST_TO_ADDR
// end ;
42637: GO 42583
42639: POP
42640: POP
// end else
42641: GO 42663
// if sort then
42643: LD_VAR 0 9
42647: IFFALSE 42663
// p := sort [ 1 ] ;
42649: LD_ADDR_VAR 0 11
42653: PUSH
42654: LD_VAR 0 9
42658: PUSH
42659: LD_INT 1
42661: ARRAY
42662: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
42663: LD_ADDR_VAR 0 2
42667: PUSH
42668: LD_INT 0
42670: PUSH
42671: LD_INT 0
42673: PUSH
42674: LD_INT 0
42676: PUSH
42677: LD_VAR 0 11
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: LIST
42686: LIST
42687: ST_TO_ADDR
// exit ;
42688: GO 44909
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42690: LD_EXP 126
42694: PUSH
42695: LD_EXP 125
42699: PUSH
42700: LD_VAR 0 1
42704: ARRAY
42705: ARRAY
42706: PUSH
42707: LD_EXP 99
42711: PUSH
42712: LD_VAR 0 1
42716: ARRAY
42717: PPUSH
42718: LD_INT 2
42720: PUSH
42721: LD_INT 30
42723: PUSH
42724: LD_INT 6
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: LD_INT 30
42733: PUSH
42734: LD_INT 7
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 30
42743: PUSH
42744: LD_INT 8
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: LIST
42755: LIST
42756: PPUSH
42757: CALL_OW 72
42761: AND
42762: PUSH
42763: LD_EXP 99
42767: PUSH
42768: LD_VAR 0 1
42772: ARRAY
42773: PPUSH
42774: LD_INT 30
42776: PUSH
42777: LD_INT 3
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: PPUSH
42784: CALL_OW 72
42788: AND
42789: IFFALSE 43523
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
42791: LD_ADDR_EXP 141
42795: PUSH
42796: LD_EXP 141
42800: PPUSH
42801: LD_VAR 0 1
42805: PPUSH
42806: LD_INT 3
42808: PPUSH
42809: CALL_OW 1
42813: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42814: LD_ADDR_VAR 0 2
42818: PUSH
42819: LD_INT 0
42821: PUSH
42822: LD_INT 0
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: LD_INT 0
42830: PUSH
42831: EMPTY
42832: LIST
42833: LIST
42834: LIST
42835: LIST
42836: ST_TO_ADDR
// if not eng then
42837: LD_VAR 0 6
42841: NOT
42842: IFFALSE 42905
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
42844: LD_ADDR_VAR 0 11
42848: PUSH
42849: LD_VAR 0 4
42853: PPUSH
42854: LD_INT 2
42856: PPUSH
42857: CALL 103208 0 2
42861: PUSH
42862: LD_INT 1
42864: ARRAY
42865: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
42866: LD_ADDR_VAR 0 2
42870: PUSH
42871: LD_VAR 0 2
42875: PPUSH
42876: LD_INT 2
42878: PPUSH
42879: LD_VAR 0 11
42883: PPUSH
42884: CALL_OW 1
42888: ST_TO_ADDR
// tmp := tmp diff p ;
42889: LD_ADDR_VAR 0 4
42893: PUSH
42894: LD_VAR 0 4
42898: PUSH
42899: LD_VAR 0 11
42903: DIFF
42904: ST_TO_ADDR
// end ; if tmp and sci < 6 then
42905: LD_VAR 0 4
42909: PUSH
42910: LD_VAR 0 8
42914: PUSH
42915: LD_INT 6
42917: LESS
42918: AND
42919: IFFALSE 43107
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
42921: LD_ADDR_VAR 0 9
42925: PUSH
42926: LD_VAR 0 4
42930: PUSH
42931: LD_VAR 0 8
42935: PUSH
42936: LD_VAR 0 7
42940: UNION
42941: DIFF
42942: PPUSH
42943: LD_INT 4
42945: PPUSH
42946: CALL 103208 0 2
42950: ST_TO_ADDR
// p := [ ] ;
42951: LD_ADDR_VAR 0 11
42955: PUSH
42956: EMPTY
42957: ST_TO_ADDR
// if sort then
42958: LD_VAR 0 9
42962: IFFALSE 43078
// for i = 1 to 6 - sci do
42964: LD_ADDR_VAR 0 3
42968: PUSH
42969: DOUBLE
42970: LD_INT 1
42972: DEC
42973: ST_TO_ADDR
42974: LD_INT 6
42976: PUSH
42977: LD_VAR 0 8
42981: MINUS
42982: PUSH
42983: FOR_TO
42984: IFFALSE 43076
// begin if i = sort then
42986: LD_VAR 0 3
42990: PUSH
42991: LD_VAR 0 9
42995: EQUAL
42996: IFFALSE 43000
// break ;
42998: GO 43076
// if GetClass ( i ) = 4 then
43000: LD_VAR 0 3
43004: PPUSH
43005: CALL_OW 257
43009: PUSH
43010: LD_INT 4
43012: EQUAL
43013: IFFALSE 43017
// continue ;
43015: GO 42983
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43017: LD_ADDR_VAR 0 11
43021: PUSH
43022: LD_VAR 0 11
43026: PPUSH
43027: LD_VAR 0 11
43031: PUSH
43032: LD_INT 1
43034: PLUS
43035: PPUSH
43036: LD_VAR 0 9
43040: PUSH
43041: LD_VAR 0 3
43045: ARRAY
43046: PPUSH
43047: CALL_OW 2
43051: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43052: LD_ADDR_VAR 0 4
43056: PUSH
43057: LD_VAR 0 4
43061: PUSH
43062: LD_VAR 0 9
43066: PUSH
43067: LD_VAR 0 3
43071: ARRAY
43072: DIFF
43073: ST_TO_ADDR
// end ;
43074: GO 42983
43076: POP
43077: POP
// if p then
43078: LD_VAR 0 11
43082: IFFALSE 43107
// result := Replace ( result , 4 , p ) ;
43084: LD_ADDR_VAR 0 2
43088: PUSH
43089: LD_VAR 0 2
43093: PPUSH
43094: LD_INT 4
43096: PPUSH
43097: LD_VAR 0 11
43101: PPUSH
43102: CALL_OW 1
43106: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43107: LD_VAR 0 4
43111: PUSH
43112: LD_VAR 0 7
43116: PUSH
43117: LD_INT 6
43119: LESS
43120: AND
43121: IFFALSE 43309
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43123: LD_ADDR_VAR 0 9
43127: PUSH
43128: LD_VAR 0 4
43132: PUSH
43133: LD_VAR 0 8
43137: PUSH
43138: LD_VAR 0 7
43142: UNION
43143: DIFF
43144: PPUSH
43145: LD_INT 3
43147: PPUSH
43148: CALL 103208 0 2
43152: ST_TO_ADDR
// p := [ ] ;
43153: LD_ADDR_VAR 0 11
43157: PUSH
43158: EMPTY
43159: ST_TO_ADDR
// if sort then
43160: LD_VAR 0 9
43164: IFFALSE 43280
// for i = 1 to 6 - mech do
43166: LD_ADDR_VAR 0 3
43170: PUSH
43171: DOUBLE
43172: LD_INT 1
43174: DEC
43175: ST_TO_ADDR
43176: LD_INT 6
43178: PUSH
43179: LD_VAR 0 7
43183: MINUS
43184: PUSH
43185: FOR_TO
43186: IFFALSE 43278
// begin if i = sort then
43188: LD_VAR 0 3
43192: PUSH
43193: LD_VAR 0 9
43197: EQUAL
43198: IFFALSE 43202
// break ;
43200: GO 43278
// if GetClass ( i ) = 3 then
43202: LD_VAR 0 3
43206: PPUSH
43207: CALL_OW 257
43211: PUSH
43212: LD_INT 3
43214: EQUAL
43215: IFFALSE 43219
// continue ;
43217: GO 43185
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43219: LD_ADDR_VAR 0 11
43223: PUSH
43224: LD_VAR 0 11
43228: PPUSH
43229: LD_VAR 0 11
43233: PUSH
43234: LD_INT 1
43236: PLUS
43237: PPUSH
43238: LD_VAR 0 9
43242: PUSH
43243: LD_VAR 0 3
43247: ARRAY
43248: PPUSH
43249: CALL_OW 2
43253: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43254: LD_ADDR_VAR 0 4
43258: PUSH
43259: LD_VAR 0 4
43263: PUSH
43264: LD_VAR 0 9
43268: PUSH
43269: LD_VAR 0 3
43273: ARRAY
43274: DIFF
43275: ST_TO_ADDR
// end ;
43276: GO 43185
43278: POP
43279: POP
// if p then
43280: LD_VAR 0 11
43284: IFFALSE 43309
// result := Replace ( result , 3 , p ) ;
43286: LD_ADDR_VAR 0 2
43290: PUSH
43291: LD_VAR 0 2
43295: PPUSH
43296: LD_INT 3
43298: PPUSH
43299: LD_VAR 0 11
43303: PPUSH
43304: CALL_OW 1
43308: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
43309: LD_VAR 0 4
43313: PUSH
43314: LD_INT 6
43316: GREATER
43317: PUSH
43318: LD_VAR 0 6
43322: PUSH
43323: LD_INT 6
43325: LESS
43326: AND
43327: IFFALSE 43521
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43329: LD_ADDR_VAR 0 9
43333: PUSH
43334: LD_VAR 0 4
43338: PUSH
43339: LD_VAR 0 8
43343: PUSH
43344: LD_VAR 0 7
43348: UNION
43349: PUSH
43350: LD_VAR 0 6
43354: UNION
43355: DIFF
43356: PPUSH
43357: LD_INT 2
43359: PPUSH
43360: CALL 103208 0 2
43364: ST_TO_ADDR
// p := [ ] ;
43365: LD_ADDR_VAR 0 11
43369: PUSH
43370: EMPTY
43371: ST_TO_ADDR
// if sort then
43372: LD_VAR 0 9
43376: IFFALSE 43492
// for i = 1 to 6 - eng do
43378: LD_ADDR_VAR 0 3
43382: PUSH
43383: DOUBLE
43384: LD_INT 1
43386: DEC
43387: ST_TO_ADDR
43388: LD_INT 6
43390: PUSH
43391: LD_VAR 0 6
43395: MINUS
43396: PUSH
43397: FOR_TO
43398: IFFALSE 43490
// begin if i = sort then
43400: LD_VAR 0 3
43404: PUSH
43405: LD_VAR 0 9
43409: EQUAL
43410: IFFALSE 43414
// break ;
43412: GO 43490
// if GetClass ( i ) = 2 then
43414: LD_VAR 0 3
43418: PPUSH
43419: CALL_OW 257
43423: PUSH
43424: LD_INT 2
43426: EQUAL
43427: IFFALSE 43431
// continue ;
43429: GO 43397
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43431: LD_ADDR_VAR 0 11
43435: PUSH
43436: LD_VAR 0 11
43440: PPUSH
43441: LD_VAR 0 11
43445: PUSH
43446: LD_INT 1
43448: PLUS
43449: PPUSH
43450: LD_VAR 0 9
43454: PUSH
43455: LD_VAR 0 3
43459: ARRAY
43460: PPUSH
43461: CALL_OW 2
43465: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43466: LD_ADDR_VAR 0 4
43470: PUSH
43471: LD_VAR 0 4
43475: PUSH
43476: LD_VAR 0 9
43480: PUSH
43481: LD_VAR 0 3
43485: ARRAY
43486: DIFF
43487: ST_TO_ADDR
// end ;
43488: GO 43397
43490: POP
43491: POP
// if p then
43492: LD_VAR 0 11
43496: IFFALSE 43521
// result := Replace ( result , 2 , p ) ;
43498: LD_ADDR_VAR 0 2
43502: PUSH
43503: LD_VAR 0 2
43507: PPUSH
43508: LD_INT 2
43510: PPUSH
43511: LD_VAR 0 11
43515: PPUSH
43516: CALL_OW 1
43520: ST_TO_ADDR
// end ; exit ;
43521: GO 44909
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
43523: LD_EXP 126
43527: PUSH
43528: LD_EXP 125
43532: PUSH
43533: LD_VAR 0 1
43537: ARRAY
43538: ARRAY
43539: NOT
43540: PUSH
43541: LD_EXP 99
43545: PUSH
43546: LD_VAR 0 1
43550: ARRAY
43551: PPUSH
43552: LD_INT 30
43554: PUSH
43555: LD_INT 3
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PPUSH
43562: CALL_OW 72
43566: AND
43567: PUSH
43568: LD_EXP 104
43572: PUSH
43573: LD_VAR 0 1
43577: ARRAY
43578: AND
43579: IFFALSE 44187
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
43581: LD_ADDR_EXP 141
43585: PUSH
43586: LD_EXP 141
43590: PPUSH
43591: LD_VAR 0 1
43595: PPUSH
43596: LD_INT 5
43598: PPUSH
43599: CALL_OW 1
43603: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43604: LD_ADDR_VAR 0 2
43608: PUSH
43609: LD_INT 0
43611: PUSH
43612: LD_INT 0
43614: PUSH
43615: LD_INT 0
43617: PUSH
43618: LD_INT 0
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: LIST
43625: LIST
43626: ST_TO_ADDR
// if sci > 1 then
43627: LD_VAR 0 8
43631: PUSH
43632: LD_INT 1
43634: GREATER
43635: IFFALSE 43663
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
43637: LD_ADDR_VAR 0 4
43641: PUSH
43642: LD_VAR 0 4
43646: PUSH
43647: LD_VAR 0 8
43651: PUSH
43652: LD_VAR 0 8
43656: PUSH
43657: LD_INT 1
43659: ARRAY
43660: DIFF
43661: DIFF
43662: ST_TO_ADDR
// if tmp and not sci then
43663: LD_VAR 0 4
43667: PUSH
43668: LD_VAR 0 8
43672: NOT
43673: AND
43674: IFFALSE 43743
// begin sort := SortBySkill ( tmp , 4 ) ;
43676: LD_ADDR_VAR 0 9
43680: PUSH
43681: LD_VAR 0 4
43685: PPUSH
43686: LD_INT 4
43688: PPUSH
43689: CALL 103208 0 2
43693: ST_TO_ADDR
// if sort then
43694: LD_VAR 0 9
43698: IFFALSE 43714
// p := sort [ 1 ] ;
43700: LD_ADDR_VAR 0 11
43704: PUSH
43705: LD_VAR 0 9
43709: PUSH
43710: LD_INT 1
43712: ARRAY
43713: ST_TO_ADDR
// if p then
43714: LD_VAR 0 11
43718: IFFALSE 43743
// result := Replace ( result , 4 , p ) ;
43720: LD_ADDR_VAR 0 2
43724: PUSH
43725: LD_VAR 0 2
43729: PPUSH
43730: LD_INT 4
43732: PPUSH
43733: LD_VAR 0 11
43737: PPUSH
43738: CALL_OW 1
43742: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43743: LD_ADDR_VAR 0 4
43747: PUSH
43748: LD_VAR 0 4
43752: PUSH
43753: LD_VAR 0 7
43757: DIFF
43758: ST_TO_ADDR
// if tmp and mech < 6 then
43759: LD_VAR 0 4
43763: PUSH
43764: LD_VAR 0 7
43768: PUSH
43769: LD_INT 6
43771: LESS
43772: AND
43773: IFFALSE 43961
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43775: LD_ADDR_VAR 0 9
43779: PUSH
43780: LD_VAR 0 4
43784: PUSH
43785: LD_VAR 0 8
43789: PUSH
43790: LD_VAR 0 7
43794: UNION
43795: DIFF
43796: PPUSH
43797: LD_INT 3
43799: PPUSH
43800: CALL 103208 0 2
43804: ST_TO_ADDR
// p := [ ] ;
43805: LD_ADDR_VAR 0 11
43809: PUSH
43810: EMPTY
43811: ST_TO_ADDR
// if sort then
43812: LD_VAR 0 9
43816: IFFALSE 43932
// for i = 1 to 6 - mech do
43818: LD_ADDR_VAR 0 3
43822: PUSH
43823: DOUBLE
43824: LD_INT 1
43826: DEC
43827: ST_TO_ADDR
43828: LD_INT 6
43830: PUSH
43831: LD_VAR 0 7
43835: MINUS
43836: PUSH
43837: FOR_TO
43838: IFFALSE 43930
// begin if i = sort then
43840: LD_VAR 0 3
43844: PUSH
43845: LD_VAR 0 9
43849: EQUAL
43850: IFFALSE 43854
// break ;
43852: GO 43930
// if GetClass ( i ) = 3 then
43854: LD_VAR 0 3
43858: PPUSH
43859: CALL_OW 257
43863: PUSH
43864: LD_INT 3
43866: EQUAL
43867: IFFALSE 43871
// continue ;
43869: GO 43837
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43871: LD_ADDR_VAR 0 11
43875: PUSH
43876: LD_VAR 0 11
43880: PPUSH
43881: LD_VAR 0 11
43885: PUSH
43886: LD_INT 1
43888: PLUS
43889: PPUSH
43890: LD_VAR 0 9
43894: PUSH
43895: LD_VAR 0 3
43899: ARRAY
43900: PPUSH
43901: CALL_OW 2
43905: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43906: LD_ADDR_VAR 0 4
43910: PUSH
43911: LD_VAR 0 4
43915: PUSH
43916: LD_VAR 0 9
43920: PUSH
43921: LD_VAR 0 3
43925: ARRAY
43926: DIFF
43927: ST_TO_ADDR
// end ;
43928: GO 43837
43930: POP
43931: POP
// if p then
43932: LD_VAR 0 11
43936: IFFALSE 43961
// result := Replace ( result , 3 , p ) ;
43938: LD_ADDR_VAR 0 2
43942: PUSH
43943: LD_VAR 0 2
43947: PPUSH
43948: LD_INT 3
43950: PPUSH
43951: LD_VAR 0 11
43955: PPUSH
43956: CALL_OW 1
43960: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43961: LD_ADDR_VAR 0 4
43965: PUSH
43966: LD_VAR 0 4
43970: PUSH
43971: LD_VAR 0 6
43975: DIFF
43976: ST_TO_ADDR
// if tmp and eng < 6 then
43977: LD_VAR 0 4
43981: PUSH
43982: LD_VAR 0 6
43986: PUSH
43987: LD_INT 6
43989: LESS
43990: AND
43991: IFFALSE 44185
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43993: LD_ADDR_VAR 0 9
43997: PUSH
43998: LD_VAR 0 4
44002: PUSH
44003: LD_VAR 0 8
44007: PUSH
44008: LD_VAR 0 7
44012: UNION
44013: PUSH
44014: LD_VAR 0 6
44018: UNION
44019: DIFF
44020: PPUSH
44021: LD_INT 2
44023: PPUSH
44024: CALL 103208 0 2
44028: ST_TO_ADDR
// p := [ ] ;
44029: LD_ADDR_VAR 0 11
44033: PUSH
44034: EMPTY
44035: ST_TO_ADDR
// if sort then
44036: LD_VAR 0 9
44040: IFFALSE 44156
// for i = 1 to 6 - eng do
44042: LD_ADDR_VAR 0 3
44046: PUSH
44047: DOUBLE
44048: LD_INT 1
44050: DEC
44051: ST_TO_ADDR
44052: LD_INT 6
44054: PUSH
44055: LD_VAR 0 6
44059: MINUS
44060: PUSH
44061: FOR_TO
44062: IFFALSE 44154
// begin if i = sort then
44064: LD_VAR 0 3
44068: PUSH
44069: LD_VAR 0 9
44073: EQUAL
44074: IFFALSE 44078
// break ;
44076: GO 44154
// if GetClass ( i ) = 2 then
44078: LD_VAR 0 3
44082: PPUSH
44083: CALL_OW 257
44087: PUSH
44088: LD_INT 2
44090: EQUAL
44091: IFFALSE 44095
// continue ;
44093: GO 44061
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44095: LD_ADDR_VAR 0 11
44099: PUSH
44100: LD_VAR 0 11
44104: PPUSH
44105: LD_VAR 0 11
44109: PUSH
44110: LD_INT 1
44112: PLUS
44113: PPUSH
44114: LD_VAR 0 9
44118: PUSH
44119: LD_VAR 0 3
44123: ARRAY
44124: PPUSH
44125: CALL_OW 2
44129: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44130: LD_ADDR_VAR 0 4
44134: PUSH
44135: LD_VAR 0 4
44139: PUSH
44140: LD_VAR 0 9
44144: PUSH
44145: LD_VAR 0 3
44149: ARRAY
44150: DIFF
44151: ST_TO_ADDR
// end ;
44152: GO 44061
44154: POP
44155: POP
// if p then
44156: LD_VAR 0 11
44160: IFFALSE 44185
// result := Replace ( result , 2 , p ) ;
44162: LD_ADDR_VAR 0 2
44166: PUSH
44167: LD_VAR 0 2
44171: PPUSH
44172: LD_INT 2
44174: PPUSH
44175: LD_VAR 0 11
44179: PPUSH
44180: CALL_OW 1
44184: ST_TO_ADDR
// end ; exit ;
44185: GO 44909
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44187: LD_EXP 126
44191: PUSH
44192: LD_EXP 125
44196: PUSH
44197: LD_VAR 0 1
44201: ARRAY
44202: ARRAY
44203: NOT
44204: PUSH
44205: LD_EXP 99
44209: PUSH
44210: LD_VAR 0 1
44214: ARRAY
44215: PPUSH
44216: LD_INT 30
44218: PUSH
44219: LD_INT 3
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PPUSH
44226: CALL_OW 72
44230: AND
44231: PUSH
44232: LD_EXP 104
44236: PUSH
44237: LD_VAR 0 1
44241: ARRAY
44242: NOT
44243: AND
44244: IFFALSE 44909
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44246: LD_ADDR_EXP 141
44250: PUSH
44251: LD_EXP 141
44255: PPUSH
44256: LD_VAR 0 1
44260: PPUSH
44261: LD_INT 6
44263: PPUSH
44264: CALL_OW 1
44268: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44269: LD_ADDR_VAR 0 2
44273: PUSH
44274: LD_INT 0
44276: PUSH
44277: LD_INT 0
44279: PUSH
44280: LD_INT 0
44282: PUSH
44283: LD_INT 0
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: ST_TO_ADDR
// if sci >= 1 then
44292: LD_VAR 0 8
44296: PUSH
44297: LD_INT 1
44299: GREATEREQUAL
44300: IFFALSE 44322
// tmp := tmp diff sci [ 1 ] ;
44302: LD_ADDR_VAR 0 4
44306: PUSH
44307: LD_VAR 0 4
44311: PUSH
44312: LD_VAR 0 8
44316: PUSH
44317: LD_INT 1
44319: ARRAY
44320: DIFF
44321: ST_TO_ADDR
// if tmp and not sci then
44322: LD_VAR 0 4
44326: PUSH
44327: LD_VAR 0 8
44331: NOT
44332: AND
44333: IFFALSE 44402
// begin sort := SortBySkill ( tmp , 4 ) ;
44335: LD_ADDR_VAR 0 9
44339: PUSH
44340: LD_VAR 0 4
44344: PPUSH
44345: LD_INT 4
44347: PPUSH
44348: CALL 103208 0 2
44352: ST_TO_ADDR
// if sort then
44353: LD_VAR 0 9
44357: IFFALSE 44373
// p := sort [ 1 ] ;
44359: LD_ADDR_VAR 0 11
44363: PUSH
44364: LD_VAR 0 9
44368: PUSH
44369: LD_INT 1
44371: ARRAY
44372: ST_TO_ADDR
// if p then
44373: LD_VAR 0 11
44377: IFFALSE 44402
// result := Replace ( result , 4 , p ) ;
44379: LD_ADDR_VAR 0 2
44383: PUSH
44384: LD_VAR 0 2
44388: PPUSH
44389: LD_INT 4
44391: PPUSH
44392: LD_VAR 0 11
44396: PPUSH
44397: CALL_OW 1
44401: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44402: LD_ADDR_VAR 0 4
44406: PUSH
44407: LD_VAR 0 4
44411: PUSH
44412: LD_VAR 0 7
44416: DIFF
44417: ST_TO_ADDR
// if tmp and mech < 6 then
44418: LD_VAR 0 4
44422: PUSH
44423: LD_VAR 0 7
44427: PUSH
44428: LD_INT 6
44430: LESS
44431: AND
44432: IFFALSE 44614
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
44434: LD_ADDR_VAR 0 9
44438: PUSH
44439: LD_VAR 0 4
44443: PUSH
44444: LD_VAR 0 7
44448: DIFF
44449: PPUSH
44450: LD_INT 3
44452: PPUSH
44453: CALL 103208 0 2
44457: ST_TO_ADDR
// p := [ ] ;
44458: LD_ADDR_VAR 0 11
44462: PUSH
44463: EMPTY
44464: ST_TO_ADDR
// if sort then
44465: LD_VAR 0 9
44469: IFFALSE 44585
// for i = 1 to 6 - mech do
44471: LD_ADDR_VAR 0 3
44475: PUSH
44476: DOUBLE
44477: LD_INT 1
44479: DEC
44480: ST_TO_ADDR
44481: LD_INT 6
44483: PUSH
44484: LD_VAR 0 7
44488: MINUS
44489: PUSH
44490: FOR_TO
44491: IFFALSE 44583
// begin if i = sort then
44493: LD_VAR 0 3
44497: PUSH
44498: LD_VAR 0 9
44502: EQUAL
44503: IFFALSE 44507
// break ;
44505: GO 44583
// if GetClass ( i ) = 3 then
44507: LD_VAR 0 3
44511: PPUSH
44512: CALL_OW 257
44516: PUSH
44517: LD_INT 3
44519: EQUAL
44520: IFFALSE 44524
// continue ;
44522: GO 44490
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44524: LD_ADDR_VAR 0 11
44528: PUSH
44529: LD_VAR 0 11
44533: PPUSH
44534: LD_VAR 0 11
44538: PUSH
44539: LD_INT 1
44541: PLUS
44542: PPUSH
44543: LD_VAR 0 9
44547: PUSH
44548: LD_VAR 0 3
44552: ARRAY
44553: PPUSH
44554: CALL_OW 2
44558: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44559: LD_ADDR_VAR 0 4
44563: PUSH
44564: LD_VAR 0 4
44568: PUSH
44569: LD_VAR 0 9
44573: PUSH
44574: LD_VAR 0 3
44578: ARRAY
44579: DIFF
44580: ST_TO_ADDR
// end ;
44581: GO 44490
44583: POP
44584: POP
// if p then
44585: LD_VAR 0 11
44589: IFFALSE 44614
// result := Replace ( result , 3 , p ) ;
44591: LD_ADDR_VAR 0 2
44595: PUSH
44596: LD_VAR 0 2
44600: PPUSH
44601: LD_INT 3
44603: PPUSH
44604: LD_VAR 0 11
44608: PPUSH
44609: CALL_OW 1
44613: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44614: LD_ADDR_VAR 0 4
44618: PUSH
44619: LD_VAR 0 4
44623: PUSH
44624: LD_VAR 0 6
44628: DIFF
44629: ST_TO_ADDR
// if tmp and eng < 4 then
44630: LD_VAR 0 4
44634: PUSH
44635: LD_VAR 0 6
44639: PUSH
44640: LD_INT 4
44642: LESS
44643: AND
44644: IFFALSE 44834
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
44646: LD_ADDR_VAR 0 9
44650: PUSH
44651: LD_VAR 0 4
44655: PUSH
44656: LD_VAR 0 7
44660: PUSH
44661: LD_VAR 0 6
44665: UNION
44666: DIFF
44667: PPUSH
44668: LD_INT 2
44670: PPUSH
44671: CALL 103208 0 2
44675: ST_TO_ADDR
// p := [ ] ;
44676: LD_ADDR_VAR 0 11
44680: PUSH
44681: EMPTY
44682: ST_TO_ADDR
// if sort then
44683: LD_VAR 0 9
44687: IFFALSE 44803
// for i = 1 to 4 - eng do
44689: LD_ADDR_VAR 0 3
44693: PUSH
44694: DOUBLE
44695: LD_INT 1
44697: DEC
44698: ST_TO_ADDR
44699: LD_INT 4
44701: PUSH
44702: LD_VAR 0 6
44706: MINUS
44707: PUSH
44708: FOR_TO
44709: IFFALSE 44801
// begin if i = sort then
44711: LD_VAR 0 3
44715: PUSH
44716: LD_VAR 0 9
44720: EQUAL
44721: IFFALSE 44725
// break ;
44723: GO 44801
// if GetClass ( i ) = 2 then
44725: LD_VAR 0 3
44729: PPUSH
44730: CALL_OW 257
44734: PUSH
44735: LD_INT 2
44737: EQUAL
44738: IFFALSE 44742
// continue ;
44740: GO 44708
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44742: LD_ADDR_VAR 0 11
44746: PUSH
44747: LD_VAR 0 11
44751: PPUSH
44752: LD_VAR 0 11
44756: PUSH
44757: LD_INT 1
44759: PLUS
44760: PPUSH
44761: LD_VAR 0 9
44765: PUSH
44766: LD_VAR 0 3
44770: ARRAY
44771: PPUSH
44772: CALL_OW 2
44776: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44777: LD_ADDR_VAR 0 4
44781: PUSH
44782: LD_VAR 0 4
44786: PUSH
44787: LD_VAR 0 9
44791: PUSH
44792: LD_VAR 0 3
44796: ARRAY
44797: DIFF
44798: ST_TO_ADDR
// end ;
44799: GO 44708
44801: POP
44802: POP
// if p then
44803: LD_VAR 0 11
44807: IFFALSE 44832
// result := Replace ( result , 2 , p ) ;
44809: LD_ADDR_VAR 0 2
44813: PUSH
44814: LD_VAR 0 2
44818: PPUSH
44819: LD_INT 2
44821: PPUSH
44822: LD_VAR 0 11
44826: PPUSH
44827: CALL_OW 1
44831: ST_TO_ADDR
// end else
44832: GO 44878
// for i = eng downto 5 do
44834: LD_ADDR_VAR 0 3
44838: PUSH
44839: DOUBLE
44840: LD_VAR 0 6
44844: INC
44845: ST_TO_ADDR
44846: LD_INT 5
44848: PUSH
44849: FOR_DOWNTO
44850: IFFALSE 44876
// tmp := tmp union eng [ i ] ;
44852: LD_ADDR_VAR 0 4
44856: PUSH
44857: LD_VAR 0 4
44861: PUSH
44862: LD_VAR 0 6
44866: PUSH
44867: LD_VAR 0 3
44871: ARRAY
44872: UNION
44873: ST_TO_ADDR
44874: GO 44849
44876: POP
44877: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
44878: LD_ADDR_VAR 0 2
44882: PUSH
44883: LD_VAR 0 2
44887: PPUSH
44888: LD_INT 1
44890: PPUSH
44891: LD_VAR 0 4
44895: PUSH
44896: LD_VAR 0 5
44900: DIFF
44901: PPUSH
44902: CALL_OW 1
44906: ST_TO_ADDR
// exit ;
44907: GO 44909
// end ; end ;
44909: LD_VAR 0 2
44913: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
44914: LD_INT 0
44916: PPUSH
44917: PPUSH
44918: PPUSH
// if not mc_bases then
44919: LD_EXP 99
44923: NOT
44924: IFFALSE 44928
// exit ;
44926: GO 45070
// for i = 1 to mc_bases do
44928: LD_ADDR_VAR 0 2
44932: PUSH
44933: DOUBLE
44934: LD_INT 1
44936: DEC
44937: ST_TO_ADDR
44938: LD_EXP 99
44942: PUSH
44943: FOR_TO
44944: IFFALSE 45061
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
44946: LD_ADDR_VAR 0 3
44950: PUSH
44951: LD_EXP 99
44955: PUSH
44956: LD_VAR 0 2
44960: ARRAY
44961: PPUSH
44962: LD_INT 21
44964: PUSH
44965: LD_INT 3
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 3
44974: PUSH
44975: LD_INT 2
44977: PUSH
44978: LD_INT 30
44980: PUSH
44981: LD_INT 29
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 30
44990: PUSH
44991: LD_INT 30
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: PUSH
44998: EMPTY
44999: LIST
45000: LIST
45001: LIST
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 3
45009: PUSH
45010: LD_INT 24
45012: PUSH
45013: LD_INT 1000
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: LIST
45028: PPUSH
45029: CALL_OW 72
45033: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
45034: LD_ADDR_EXP 100
45038: PUSH
45039: LD_EXP 100
45043: PPUSH
45044: LD_VAR 0 2
45048: PPUSH
45049: LD_VAR 0 3
45053: PPUSH
45054: CALL_OW 1
45058: ST_TO_ADDR
// end ;
45059: GO 44943
45061: POP
45062: POP
// RaiseSailEvent ( 101 ) ;
45063: LD_INT 101
45065: PPUSH
45066: CALL_OW 427
// end ;
45070: LD_VAR 0 1
45074: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45075: LD_INT 0
45077: PPUSH
45078: PPUSH
45079: PPUSH
45080: PPUSH
45081: PPUSH
45082: PPUSH
45083: PPUSH
// if not mc_bases then
45084: LD_EXP 99
45088: NOT
45089: IFFALSE 45093
// exit ;
45091: GO 45655
// for i = 1 to mc_bases do
45093: LD_ADDR_VAR 0 2
45097: PUSH
45098: DOUBLE
45099: LD_INT 1
45101: DEC
45102: ST_TO_ADDR
45103: LD_EXP 99
45107: PUSH
45108: FOR_TO
45109: IFFALSE 45646
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45111: LD_ADDR_VAR 0 5
45115: PUSH
45116: LD_EXP 99
45120: PUSH
45121: LD_VAR 0 2
45125: ARRAY
45126: PUSH
45127: LD_EXP 128
45131: PUSH
45132: LD_VAR 0 2
45136: ARRAY
45137: UNION
45138: PPUSH
45139: LD_INT 21
45141: PUSH
45142: LD_INT 1
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 1
45151: PUSH
45152: LD_INT 3
45154: PUSH
45155: LD_INT 54
45157: PUSH
45158: EMPTY
45159: LIST
45160: PUSH
45161: EMPTY
45162: LIST
45163: LIST
45164: PUSH
45165: LD_INT 3
45167: PUSH
45168: LD_INT 24
45170: PUSH
45171: LD_INT 1000
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: LIST
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PPUSH
45191: CALL_OW 72
45195: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45196: LD_ADDR_VAR 0 6
45200: PUSH
45201: LD_EXP 99
45205: PUSH
45206: LD_VAR 0 2
45210: ARRAY
45211: PPUSH
45212: LD_INT 21
45214: PUSH
45215: LD_INT 1
45217: PUSH
45218: EMPTY
45219: LIST
45220: LIST
45221: PUSH
45222: LD_INT 1
45224: PUSH
45225: LD_INT 3
45227: PUSH
45228: LD_INT 54
45230: PUSH
45231: EMPTY
45232: LIST
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: LD_INT 3
45240: PUSH
45241: LD_INT 24
45243: PUSH
45244: LD_INT 250
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: PUSH
45251: EMPTY
45252: LIST
45253: LIST
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: LIST
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PPUSH
45264: CALL_OW 72
45268: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45269: LD_ADDR_VAR 0 7
45273: PUSH
45274: LD_VAR 0 5
45278: PUSH
45279: LD_VAR 0 6
45283: DIFF
45284: ST_TO_ADDR
// if not need_heal_1 then
45285: LD_VAR 0 6
45289: NOT
45290: IFFALSE 45323
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45292: LD_ADDR_EXP 102
45296: PUSH
45297: LD_EXP 102
45301: PPUSH
45302: LD_VAR 0 2
45306: PUSH
45307: LD_INT 1
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PPUSH
45314: EMPTY
45315: PPUSH
45316: CALL 72387 0 3
45320: ST_TO_ADDR
45321: GO 45393
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
45323: LD_ADDR_EXP 102
45327: PUSH
45328: LD_EXP 102
45332: PPUSH
45333: LD_VAR 0 2
45337: PUSH
45338: LD_INT 1
45340: PUSH
45341: EMPTY
45342: LIST
45343: LIST
45344: PPUSH
45345: LD_EXP 102
45349: PUSH
45350: LD_VAR 0 2
45354: ARRAY
45355: PUSH
45356: LD_INT 1
45358: ARRAY
45359: PPUSH
45360: LD_INT 3
45362: PUSH
45363: LD_INT 24
45365: PUSH
45366: LD_INT 1000
45368: PUSH
45369: EMPTY
45370: LIST
45371: LIST
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PPUSH
45377: CALL_OW 72
45381: PUSH
45382: LD_VAR 0 6
45386: UNION
45387: PPUSH
45388: CALL 72387 0 3
45392: ST_TO_ADDR
// if not need_heal_2 then
45393: LD_VAR 0 7
45397: NOT
45398: IFFALSE 45431
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
45400: LD_ADDR_EXP 102
45404: PUSH
45405: LD_EXP 102
45409: PPUSH
45410: LD_VAR 0 2
45414: PUSH
45415: LD_INT 2
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PPUSH
45422: EMPTY
45423: PPUSH
45424: CALL 72387 0 3
45428: ST_TO_ADDR
45429: GO 45463
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
45431: LD_ADDR_EXP 102
45435: PUSH
45436: LD_EXP 102
45440: PPUSH
45441: LD_VAR 0 2
45445: PUSH
45446: LD_INT 2
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: PPUSH
45453: LD_VAR 0 7
45457: PPUSH
45458: CALL 72387 0 3
45462: ST_TO_ADDR
// if need_heal_2 then
45463: LD_VAR 0 7
45467: IFFALSE 45628
// for j in need_heal_2 do
45469: LD_ADDR_VAR 0 3
45473: PUSH
45474: LD_VAR 0 7
45478: PUSH
45479: FOR_IN
45480: IFFALSE 45626
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45482: LD_ADDR_VAR 0 5
45486: PUSH
45487: LD_EXP 99
45491: PUSH
45492: LD_VAR 0 2
45496: ARRAY
45497: PPUSH
45498: LD_INT 2
45500: PUSH
45501: LD_INT 30
45503: PUSH
45504: LD_INT 6
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: PUSH
45511: LD_INT 30
45513: PUSH
45514: LD_INT 7
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 30
45523: PUSH
45524: LD_INT 8
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PUSH
45531: LD_INT 30
45533: PUSH
45534: LD_INT 0
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: PUSH
45541: LD_INT 30
45543: PUSH
45544: LD_INT 1
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: LIST
45557: LIST
45558: PPUSH
45559: CALL_OW 72
45563: ST_TO_ADDR
// if tmp then
45564: LD_VAR 0 5
45568: IFFALSE 45624
// begin k := NearestUnitToUnit ( tmp , j ) ;
45570: LD_ADDR_VAR 0 4
45574: PUSH
45575: LD_VAR 0 5
45579: PPUSH
45580: LD_VAR 0 3
45584: PPUSH
45585: CALL_OW 74
45589: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
45590: LD_VAR 0 3
45594: PPUSH
45595: LD_VAR 0 4
45599: PPUSH
45600: CALL_OW 296
45604: PUSH
45605: LD_INT 5
45607: GREATER
45608: IFFALSE 45624
// ComMoveToNearbyEntrance ( j , k ) ;
45610: LD_VAR 0 3
45614: PPUSH
45615: LD_VAR 0 4
45619: PPUSH
45620: CALL 105576 0 2
// end ; end ;
45624: GO 45479
45626: POP
45627: POP
// if not need_heal_1 and not need_heal_2 then
45628: LD_VAR 0 6
45632: NOT
45633: PUSH
45634: LD_VAR 0 7
45638: NOT
45639: AND
45640: IFFALSE 45644
// continue ;
45642: GO 45108
// end ;
45644: GO 45108
45646: POP
45647: POP
// RaiseSailEvent ( 102 ) ;
45648: LD_INT 102
45650: PPUSH
45651: CALL_OW 427
// end ;
45655: LD_VAR 0 1
45659: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
45660: LD_INT 0
45662: PPUSH
45663: PPUSH
45664: PPUSH
45665: PPUSH
45666: PPUSH
45667: PPUSH
45668: PPUSH
45669: PPUSH
// if not mc_bases then
45670: LD_EXP 99
45674: NOT
45675: IFFALSE 45679
// exit ;
45677: GO 46590
// for i = 1 to mc_bases do
45679: LD_ADDR_VAR 0 2
45683: PUSH
45684: DOUBLE
45685: LD_INT 1
45687: DEC
45688: ST_TO_ADDR
45689: LD_EXP 99
45693: PUSH
45694: FOR_TO
45695: IFFALSE 46588
// begin if not mc_building_need_repair [ i ] then
45697: LD_EXP 100
45701: PUSH
45702: LD_VAR 0 2
45706: ARRAY
45707: NOT
45708: IFFALSE 45893
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
45710: LD_ADDR_VAR 0 6
45714: PUSH
45715: LD_EXP 118
45719: PUSH
45720: LD_VAR 0 2
45724: ARRAY
45725: PPUSH
45726: LD_INT 3
45728: PUSH
45729: LD_INT 24
45731: PUSH
45732: LD_INT 1000
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PUSH
45739: EMPTY
45740: LIST
45741: LIST
45742: PUSH
45743: LD_INT 2
45745: PUSH
45746: LD_INT 34
45748: PUSH
45749: LD_INT 13
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 34
45758: PUSH
45759: LD_INT 52
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 34
45768: PUSH
45769: LD_INT 88
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: LIST
45780: LIST
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PPUSH
45786: CALL_OW 72
45790: ST_TO_ADDR
// if cranes then
45791: LD_VAR 0 6
45795: IFFALSE 45857
// for j in cranes do
45797: LD_ADDR_VAR 0 3
45801: PUSH
45802: LD_VAR 0 6
45806: PUSH
45807: FOR_IN
45808: IFFALSE 45855
// if not IsInArea ( j , mc_parking [ i ] ) then
45810: LD_VAR 0 3
45814: PPUSH
45815: LD_EXP 123
45819: PUSH
45820: LD_VAR 0 2
45824: ARRAY
45825: PPUSH
45826: CALL_OW 308
45830: NOT
45831: IFFALSE 45853
// ComMoveToArea ( j , mc_parking [ i ] ) ;
45833: LD_VAR 0 3
45837: PPUSH
45838: LD_EXP 123
45842: PUSH
45843: LD_VAR 0 2
45847: ARRAY
45848: PPUSH
45849: CALL_OW 113
45853: GO 45807
45855: POP
45856: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
45857: LD_ADDR_EXP 101
45861: PUSH
45862: LD_EXP 101
45866: PPUSH
45867: LD_VAR 0 2
45871: PPUSH
45872: EMPTY
45873: PPUSH
45874: CALL_OW 1
45878: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
45879: LD_VAR 0 2
45883: PPUSH
45884: LD_INT 101
45886: PPUSH
45887: CALL 40747 0 2
// continue ;
45891: GO 45694
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
45893: LD_ADDR_EXP 105
45897: PUSH
45898: LD_EXP 105
45902: PPUSH
45903: LD_VAR 0 2
45907: PPUSH
45908: EMPTY
45909: PPUSH
45910: CALL_OW 1
45914: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45915: LD_VAR 0 2
45919: PPUSH
45920: LD_INT 103
45922: PPUSH
45923: CALL 40747 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
45927: LD_ADDR_VAR 0 5
45931: PUSH
45932: LD_EXP 99
45936: PUSH
45937: LD_VAR 0 2
45941: ARRAY
45942: PUSH
45943: LD_EXP 128
45947: PUSH
45948: LD_VAR 0 2
45952: ARRAY
45953: UNION
45954: PPUSH
45955: LD_INT 2
45957: PUSH
45958: LD_INT 25
45960: PUSH
45961: LD_INT 2
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: PUSH
45968: LD_INT 25
45970: PUSH
45971: LD_INT 16
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: EMPTY
45979: LIST
45980: LIST
45981: LIST
45982: PUSH
45983: EMPTY
45984: LIST
45985: PPUSH
45986: CALL_OW 72
45990: ST_TO_ADDR
// if mc_need_heal [ i ] then
45991: LD_EXP 102
45995: PUSH
45996: LD_VAR 0 2
46000: ARRAY
46001: IFFALSE 46045
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
46003: LD_ADDR_VAR 0 5
46007: PUSH
46008: LD_VAR 0 5
46012: PUSH
46013: LD_EXP 102
46017: PUSH
46018: LD_VAR 0 2
46022: ARRAY
46023: PUSH
46024: LD_INT 1
46026: ARRAY
46027: PUSH
46028: LD_EXP 102
46032: PUSH
46033: LD_VAR 0 2
46037: ARRAY
46038: PUSH
46039: LD_INT 2
46041: ARRAY
46042: UNION
46043: DIFF
46044: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
46045: LD_ADDR_VAR 0 6
46049: PUSH
46050: LD_EXP 118
46054: PUSH
46055: LD_VAR 0 2
46059: ARRAY
46060: PPUSH
46061: LD_INT 2
46063: PUSH
46064: LD_INT 34
46066: PUSH
46067: LD_INT 13
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: LD_INT 34
46076: PUSH
46077: LD_INT 52
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: PUSH
46084: LD_INT 34
46086: PUSH
46087: LD_INT 88
46089: PUSH
46090: EMPTY
46091: LIST
46092: LIST
46093: PUSH
46094: EMPTY
46095: LIST
46096: LIST
46097: LIST
46098: LIST
46099: PPUSH
46100: CALL_OW 72
46104: ST_TO_ADDR
// if cranes then
46105: LD_VAR 0 6
46109: IFFALSE 46277
// begin for j in cranes do
46111: LD_ADDR_VAR 0 3
46115: PUSH
46116: LD_VAR 0 6
46120: PUSH
46121: FOR_IN
46122: IFFALSE 46275
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46124: LD_VAR 0 3
46128: PPUSH
46129: CALL_OW 256
46133: PUSH
46134: LD_INT 1000
46136: EQUAL
46137: PUSH
46138: LD_VAR 0 3
46142: PPUSH
46143: CALL_OW 314
46147: NOT
46148: AND
46149: IFFALSE 46215
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46151: LD_ADDR_VAR 0 8
46155: PUSH
46156: LD_EXP 100
46160: PUSH
46161: LD_VAR 0 2
46165: ARRAY
46166: PPUSH
46167: LD_VAR 0 3
46171: PPUSH
46172: CALL_OW 74
46176: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46177: LD_VAR 0 8
46181: PPUSH
46182: LD_INT 16
46184: PPUSH
46185: CALL 74984 0 2
46189: PUSH
46190: LD_INT 4
46192: ARRAY
46193: PUSH
46194: LD_INT 10
46196: LESS
46197: IFFALSE 46213
// ComRepairBuilding ( j , to_repair ) ;
46199: LD_VAR 0 3
46203: PPUSH
46204: LD_VAR 0 8
46208: PPUSH
46209: CALL_OW 130
// end else
46213: GO 46273
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46215: LD_VAR 0 3
46219: PPUSH
46220: CALL_OW 256
46224: PUSH
46225: LD_INT 500
46227: LESS
46228: PUSH
46229: LD_VAR 0 3
46233: PPUSH
46234: LD_EXP 123
46238: PUSH
46239: LD_VAR 0 2
46243: ARRAY
46244: PPUSH
46245: CALL_OW 308
46249: NOT
46250: AND
46251: IFFALSE 46273
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46253: LD_VAR 0 3
46257: PPUSH
46258: LD_EXP 123
46262: PUSH
46263: LD_VAR 0 2
46267: ARRAY
46268: PPUSH
46269: CALL_OW 113
// end ;
46273: GO 46121
46275: POP
46276: POP
// end ; if tmp > 3 then
46277: LD_VAR 0 5
46281: PUSH
46282: LD_INT 3
46284: GREATER
46285: IFFALSE 46305
// tmp := ShrinkArray ( tmp , 4 ) ;
46287: LD_ADDR_VAR 0 5
46291: PUSH
46292: LD_VAR 0 5
46296: PPUSH
46297: LD_INT 4
46299: PPUSH
46300: CALL 105014 0 2
46304: ST_TO_ADDR
// if not tmp then
46305: LD_VAR 0 5
46309: NOT
46310: IFFALSE 46314
// continue ;
46312: GO 45694
// for j in tmp do
46314: LD_ADDR_VAR 0 3
46318: PUSH
46319: LD_VAR 0 5
46323: PUSH
46324: FOR_IN
46325: IFFALSE 46584
// begin if IsInUnit ( j ) then
46327: LD_VAR 0 3
46331: PPUSH
46332: CALL_OW 310
46336: IFFALSE 46347
// ComExitBuilding ( j ) ;
46338: LD_VAR 0 3
46342: PPUSH
46343: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
46347: LD_VAR 0 3
46351: PUSH
46352: LD_EXP 101
46356: PUSH
46357: LD_VAR 0 2
46361: ARRAY
46362: IN
46363: NOT
46364: IFFALSE 46422
// begin SetTag ( j , 101 ) ;
46366: LD_VAR 0 3
46370: PPUSH
46371: LD_INT 101
46373: PPUSH
46374: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
46378: LD_ADDR_EXP 101
46382: PUSH
46383: LD_EXP 101
46387: PPUSH
46388: LD_VAR 0 2
46392: PUSH
46393: LD_EXP 101
46397: PUSH
46398: LD_VAR 0 2
46402: ARRAY
46403: PUSH
46404: LD_INT 1
46406: PLUS
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: PPUSH
46412: LD_VAR 0 3
46416: PPUSH
46417: CALL 72387 0 3
46421: ST_TO_ADDR
// end ; wait ( 1 ) ;
46422: LD_INT 1
46424: PPUSH
46425: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
46429: LD_ADDR_VAR 0 7
46433: PUSH
46434: LD_EXP 100
46438: PUSH
46439: LD_VAR 0 2
46443: ARRAY
46444: ST_TO_ADDR
// if mc_scan [ i ] then
46445: LD_EXP 122
46449: PUSH
46450: LD_VAR 0 2
46454: ARRAY
46455: IFFALSE 46517
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
46457: LD_ADDR_VAR 0 7
46461: PUSH
46462: LD_EXP 100
46466: PUSH
46467: LD_VAR 0 2
46471: ARRAY
46472: PPUSH
46473: LD_INT 3
46475: PUSH
46476: LD_INT 30
46478: PUSH
46479: LD_INT 32
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: LD_INT 30
46488: PUSH
46489: LD_INT 33
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 30
46498: PUSH
46499: LD_INT 31
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PUSH
46506: EMPTY
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: PPUSH
46512: CALL_OW 72
46516: ST_TO_ADDR
// if not to_repair_tmp then
46517: LD_VAR 0 7
46521: NOT
46522: IFFALSE 46526
// continue ;
46524: GO 46324
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
46526: LD_ADDR_VAR 0 8
46530: PUSH
46531: LD_VAR 0 7
46535: PPUSH
46536: LD_VAR 0 3
46540: PPUSH
46541: CALL_OW 74
46545: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
46546: LD_VAR 0 8
46550: PPUSH
46551: LD_INT 16
46553: PPUSH
46554: CALL 74984 0 2
46558: PUSH
46559: LD_INT 4
46561: ARRAY
46562: PUSH
46563: LD_INT 14
46565: LESS
46566: IFFALSE 46582
// ComRepairBuilding ( j , to_repair ) ;
46568: LD_VAR 0 3
46572: PPUSH
46573: LD_VAR 0 8
46577: PPUSH
46578: CALL_OW 130
// end ;
46582: GO 46324
46584: POP
46585: POP
// end ;
46586: GO 45694
46588: POP
46589: POP
// end ;
46590: LD_VAR 0 1
46594: RET
// export function MC_Heal ; var i , j , tmp ; begin
46595: LD_INT 0
46597: PPUSH
46598: PPUSH
46599: PPUSH
46600: PPUSH
// if not mc_bases then
46601: LD_EXP 99
46605: NOT
46606: IFFALSE 46610
// exit ;
46608: GO 47012
// for i = 1 to mc_bases do
46610: LD_ADDR_VAR 0 2
46614: PUSH
46615: DOUBLE
46616: LD_INT 1
46618: DEC
46619: ST_TO_ADDR
46620: LD_EXP 99
46624: PUSH
46625: FOR_TO
46626: IFFALSE 47010
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
46628: LD_EXP 102
46632: PUSH
46633: LD_VAR 0 2
46637: ARRAY
46638: PUSH
46639: LD_INT 1
46641: ARRAY
46642: NOT
46643: PUSH
46644: LD_EXP 102
46648: PUSH
46649: LD_VAR 0 2
46653: ARRAY
46654: PUSH
46655: LD_INT 2
46657: ARRAY
46658: NOT
46659: AND
46660: IFFALSE 46698
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
46662: LD_ADDR_EXP 103
46666: PUSH
46667: LD_EXP 103
46671: PPUSH
46672: LD_VAR 0 2
46676: PPUSH
46677: EMPTY
46678: PPUSH
46679: CALL_OW 1
46683: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
46684: LD_VAR 0 2
46688: PPUSH
46689: LD_INT 102
46691: PPUSH
46692: CALL 40747 0 2
// continue ;
46696: GO 46625
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
46698: LD_ADDR_VAR 0 4
46702: PUSH
46703: LD_EXP 99
46707: PUSH
46708: LD_VAR 0 2
46712: ARRAY
46713: PPUSH
46714: LD_INT 25
46716: PUSH
46717: LD_INT 4
46719: PUSH
46720: EMPTY
46721: LIST
46722: LIST
46723: PPUSH
46724: CALL_OW 72
46728: ST_TO_ADDR
// if not tmp then
46729: LD_VAR 0 4
46733: NOT
46734: IFFALSE 46738
// continue ;
46736: GO 46625
// if mc_taming [ i ] then
46738: LD_EXP 130
46742: PUSH
46743: LD_VAR 0 2
46747: ARRAY
46748: IFFALSE 46772
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
46750: LD_ADDR_EXP 130
46754: PUSH
46755: LD_EXP 130
46759: PPUSH
46760: LD_VAR 0 2
46764: PPUSH
46765: EMPTY
46766: PPUSH
46767: CALL_OW 1
46771: ST_TO_ADDR
// for j in tmp do
46772: LD_ADDR_VAR 0 3
46776: PUSH
46777: LD_VAR 0 4
46781: PUSH
46782: FOR_IN
46783: IFFALSE 47006
// begin if IsInUnit ( j ) then
46785: LD_VAR 0 3
46789: PPUSH
46790: CALL_OW 310
46794: IFFALSE 46805
// ComExitBuilding ( j ) ;
46796: LD_VAR 0 3
46800: PPUSH
46801: CALL_OW 122
// if not j in mc_healers [ i ] then
46805: LD_VAR 0 3
46809: PUSH
46810: LD_EXP 103
46814: PUSH
46815: LD_VAR 0 2
46819: ARRAY
46820: IN
46821: NOT
46822: IFFALSE 46868
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
46824: LD_ADDR_EXP 103
46828: PUSH
46829: LD_EXP 103
46833: PPUSH
46834: LD_VAR 0 2
46838: PUSH
46839: LD_EXP 103
46843: PUSH
46844: LD_VAR 0 2
46848: ARRAY
46849: PUSH
46850: LD_INT 1
46852: PLUS
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PPUSH
46858: LD_VAR 0 3
46862: PPUSH
46863: CALL 72387 0 3
46867: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
46868: LD_VAR 0 3
46872: PPUSH
46873: CALL_OW 110
46877: PUSH
46878: LD_INT 102
46880: NONEQUAL
46881: IFFALSE 46895
// SetTag ( j , 102 ) ;
46883: LD_VAR 0 3
46887: PPUSH
46888: LD_INT 102
46890: PPUSH
46891: CALL_OW 109
// Wait ( 3 ) ;
46895: LD_INT 3
46897: PPUSH
46898: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
46902: LD_EXP 102
46906: PUSH
46907: LD_VAR 0 2
46911: ARRAY
46912: PUSH
46913: LD_INT 1
46915: ARRAY
46916: IFFALSE 46948
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
46918: LD_VAR 0 3
46922: PPUSH
46923: LD_EXP 102
46927: PUSH
46928: LD_VAR 0 2
46932: ARRAY
46933: PUSH
46934: LD_INT 1
46936: ARRAY
46937: PUSH
46938: LD_INT 1
46940: ARRAY
46941: PPUSH
46942: CALL_OW 128
46946: GO 47004
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
46948: LD_VAR 0 3
46952: PPUSH
46953: CALL_OW 314
46957: NOT
46958: PUSH
46959: LD_EXP 102
46963: PUSH
46964: LD_VAR 0 2
46968: ARRAY
46969: PUSH
46970: LD_INT 2
46972: ARRAY
46973: AND
46974: IFFALSE 47004
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
46976: LD_VAR 0 3
46980: PPUSH
46981: LD_EXP 102
46985: PUSH
46986: LD_VAR 0 2
46990: ARRAY
46991: PUSH
46992: LD_INT 2
46994: ARRAY
46995: PUSH
46996: LD_INT 1
46998: ARRAY
46999: PPUSH
47000: CALL_OW 128
// end ;
47004: GO 46782
47006: POP
47007: POP
// end ;
47008: GO 46625
47010: POP
47011: POP
// end ;
47012: LD_VAR 0 1
47016: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
47017: LD_INT 0
47019: PPUSH
47020: PPUSH
47021: PPUSH
47022: PPUSH
47023: PPUSH
47024: PPUSH
// if not mc_bases then
47025: LD_EXP 99
47029: NOT
47030: IFFALSE 47034
// exit ;
47032: GO 48197
// for i = 1 to mc_bases do
47034: LD_ADDR_VAR 0 2
47038: PUSH
47039: DOUBLE
47040: LD_INT 1
47042: DEC
47043: ST_TO_ADDR
47044: LD_EXP 99
47048: PUSH
47049: FOR_TO
47050: IFFALSE 48195
// begin if mc_scan [ i ] then
47052: LD_EXP 122
47056: PUSH
47057: LD_VAR 0 2
47061: ARRAY
47062: IFFALSE 47066
// continue ;
47064: GO 47049
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47066: LD_EXP 104
47070: PUSH
47071: LD_VAR 0 2
47075: ARRAY
47076: NOT
47077: PUSH
47078: LD_EXP 106
47082: PUSH
47083: LD_VAR 0 2
47087: ARRAY
47088: NOT
47089: AND
47090: PUSH
47091: LD_EXP 105
47095: PUSH
47096: LD_VAR 0 2
47100: ARRAY
47101: AND
47102: IFFALSE 47140
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47104: LD_ADDR_EXP 105
47108: PUSH
47109: LD_EXP 105
47113: PPUSH
47114: LD_VAR 0 2
47118: PPUSH
47119: EMPTY
47120: PPUSH
47121: CALL_OW 1
47125: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47126: LD_VAR 0 2
47130: PPUSH
47131: LD_INT 103
47133: PPUSH
47134: CALL 40747 0 2
// continue ;
47138: GO 47049
// end ; if mc_construct_list [ i ] then
47140: LD_EXP 106
47144: PUSH
47145: LD_VAR 0 2
47149: ARRAY
47150: IFFALSE 47370
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47152: LD_ADDR_VAR 0 5
47156: PUSH
47157: LD_EXP 99
47161: PUSH
47162: LD_VAR 0 2
47166: ARRAY
47167: PPUSH
47168: LD_INT 25
47170: PUSH
47171: LD_INT 2
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PPUSH
47178: CALL_OW 72
47182: PUSH
47183: LD_EXP 101
47187: PUSH
47188: LD_VAR 0 2
47192: ARRAY
47193: DIFF
47194: ST_TO_ADDR
// if not tmp then
47195: LD_VAR 0 5
47199: NOT
47200: IFFALSE 47204
// continue ;
47202: GO 47049
// for j in tmp do
47204: LD_ADDR_VAR 0 3
47208: PUSH
47209: LD_VAR 0 5
47213: PUSH
47214: FOR_IN
47215: IFFALSE 47366
// begin if not mc_builders [ i ] then
47217: LD_EXP 105
47221: PUSH
47222: LD_VAR 0 2
47226: ARRAY
47227: NOT
47228: IFFALSE 47286
// begin SetTag ( j , 103 ) ;
47230: LD_VAR 0 3
47234: PPUSH
47235: LD_INT 103
47237: PPUSH
47238: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47242: LD_ADDR_EXP 105
47246: PUSH
47247: LD_EXP 105
47251: PPUSH
47252: LD_VAR 0 2
47256: PUSH
47257: LD_EXP 105
47261: PUSH
47262: LD_VAR 0 2
47266: ARRAY
47267: PUSH
47268: LD_INT 1
47270: PLUS
47271: PUSH
47272: EMPTY
47273: LIST
47274: LIST
47275: PPUSH
47276: LD_VAR 0 3
47280: PPUSH
47281: CALL 72387 0 3
47285: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47286: LD_VAR 0 3
47290: PPUSH
47291: CALL_OW 310
47295: IFFALSE 47306
// ComExitBuilding ( j ) ;
47297: LD_VAR 0 3
47301: PPUSH
47302: CALL_OW 122
// wait ( 3 ) ;
47306: LD_INT 3
47308: PPUSH
47309: CALL_OW 67
// if not mc_construct_list [ i ] then
47313: LD_EXP 106
47317: PUSH
47318: LD_VAR 0 2
47322: ARRAY
47323: NOT
47324: IFFALSE 47328
// break ;
47326: GO 47366
// if not HasTask ( j ) then
47328: LD_VAR 0 3
47332: PPUSH
47333: CALL_OW 314
47337: NOT
47338: IFFALSE 47364
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
47340: LD_VAR 0 3
47344: PPUSH
47345: LD_EXP 106
47349: PUSH
47350: LD_VAR 0 2
47354: ARRAY
47355: PUSH
47356: LD_INT 1
47358: ARRAY
47359: PPUSH
47360: CALL 75248 0 2
// end ;
47364: GO 47214
47366: POP
47367: POP
// end else
47368: GO 48193
// if mc_build_list [ i ] then
47370: LD_EXP 104
47374: PUSH
47375: LD_VAR 0 2
47379: ARRAY
47380: IFFALSE 48193
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
47382: LD_EXP 104
47386: PUSH
47387: LD_VAR 0 2
47391: ARRAY
47392: PUSH
47393: LD_INT 1
47395: ARRAY
47396: PUSH
47397: LD_INT 1
47399: ARRAY
47400: PPUSH
47401: CALL 75072 0 1
47405: PUSH
47406: LD_EXP 99
47410: PUSH
47411: LD_VAR 0 2
47415: ARRAY
47416: PPUSH
47417: LD_INT 2
47419: PUSH
47420: LD_INT 30
47422: PUSH
47423: LD_INT 2
47425: PUSH
47426: EMPTY
47427: LIST
47428: LIST
47429: PUSH
47430: LD_INT 30
47432: PUSH
47433: LD_INT 3
47435: PUSH
47436: EMPTY
47437: LIST
47438: LIST
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: LIST
47444: PPUSH
47445: CALL_OW 72
47449: NOT
47450: AND
47451: IFFALSE 47556
// begin for j = 1 to mc_build_list [ i ] do
47453: LD_ADDR_VAR 0 3
47457: PUSH
47458: DOUBLE
47459: LD_INT 1
47461: DEC
47462: ST_TO_ADDR
47463: LD_EXP 104
47467: PUSH
47468: LD_VAR 0 2
47472: ARRAY
47473: PUSH
47474: FOR_TO
47475: IFFALSE 47554
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
47477: LD_EXP 104
47481: PUSH
47482: LD_VAR 0 2
47486: ARRAY
47487: PUSH
47488: LD_VAR 0 3
47492: ARRAY
47493: PUSH
47494: LD_INT 1
47496: ARRAY
47497: PUSH
47498: LD_INT 2
47500: EQUAL
47501: IFFALSE 47552
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
47503: LD_ADDR_EXP 104
47507: PUSH
47508: LD_EXP 104
47512: PPUSH
47513: LD_VAR 0 2
47517: PPUSH
47518: LD_EXP 104
47522: PUSH
47523: LD_VAR 0 2
47527: ARRAY
47528: PPUSH
47529: LD_VAR 0 3
47533: PPUSH
47534: LD_INT 1
47536: PPUSH
47537: LD_INT 0
47539: PPUSH
47540: CALL 71805 0 4
47544: PPUSH
47545: CALL_OW 1
47549: ST_TO_ADDR
// break ;
47550: GO 47554
// end ;
47552: GO 47474
47554: POP
47555: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47556: LD_ADDR_VAR 0 6
47560: PUSH
47561: LD_EXP 99
47565: PUSH
47566: LD_VAR 0 2
47570: ARRAY
47571: PPUSH
47572: LD_INT 2
47574: PUSH
47575: LD_INT 30
47577: PUSH
47578: LD_INT 0
47580: PUSH
47581: EMPTY
47582: LIST
47583: LIST
47584: PUSH
47585: LD_INT 30
47587: PUSH
47588: LD_INT 1
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PUSH
47595: EMPTY
47596: LIST
47597: LIST
47598: LIST
47599: PPUSH
47600: CALL_OW 72
47604: ST_TO_ADDR
// for k := 1 to depot do
47605: LD_ADDR_VAR 0 4
47609: PUSH
47610: DOUBLE
47611: LD_INT 1
47613: DEC
47614: ST_TO_ADDR
47615: LD_VAR 0 6
47619: PUSH
47620: FOR_TO
47621: IFFALSE 48191
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
47623: LD_EXP 104
47627: PUSH
47628: LD_VAR 0 2
47632: ARRAY
47633: PUSH
47634: LD_INT 1
47636: ARRAY
47637: PUSH
47638: LD_INT 1
47640: ARRAY
47641: PUSH
47642: LD_INT 0
47644: EQUAL
47645: PUSH
47646: LD_VAR 0 6
47650: PUSH
47651: LD_VAR 0 4
47655: ARRAY
47656: PPUSH
47657: LD_EXP 104
47661: PUSH
47662: LD_VAR 0 2
47666: ARRAY
47667: PUSH
47668: LD_INT 1
47670: ARRAY
47671: PUSH
47672: LD_INT 1
47674: ARRAY
47675: PPUSH
47676: LD_EXP 104
47680: PUSH
47681: LD_VAR 0 2
47685: ARRAY
47686: PUSH
47687: LD_INT 1
47689: ARRAY
47690: PUSH
47691: LD_INT 2
47693: ARRAY
47694: PPUSH
47695: LD_EXP 104
47699: PUSH
47700: LD_VAR 0 2
47704: ARRAY
47705: PUSH
47706: LD_INT 1
47708: ARRAY
47709: PUSH
47710: LD_INT 3
47712: ARRAY
47713: PPUSH
47714: LD_EXP 104
47718: PUSH
47719: LD_VAR 0 2
47723: ARRAY
47724: PUSH
47725: LD_INT 1
47727: ARRAY
47728: PUSH
47729: LD_INT 4
47731: ARRAY
47732: PPUSH
47733: CALL 80484 0 5
47737: OR
47738: IFFALSE 48019
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47740: LD_ADDR_VAR 0 5
47744: PUSH
47745: LD_EXP 99
47749: PUSH
47750: LD_VAR 0 2
47754: ARRAY
47755: PPUSH
47756: LD_INT 25
47758: PUSH
47759: LD_INT 2
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PPUSH
47766: CALL_OW 72
47770: PUSH
47771: LD_EXP 101
47775: PUSH
47776: LD_VAR 0 2
47780: ARRAY
47781: DIFF
47782: ST_TO_ADDR
// if not tmp then
47783: LD_VAR 0 5
47787: NOT
47788: IFFALSE 47792
// continue ;
47790: GO 47620
// for j in tmp do
47792: LD_ADDR_VAR 0 3
47796: PUSH
47797: LD_VAR 0 5
47801: PUSH
47802: FOR_IN
47803: IFFALSE 48015
// begin if not mc_builders [ i ] then
47805: LD_EXP 105
47809: PUSH
47810: LD_VAR 0 2
47814: ARRAY
47815: NOT
47816: IFFALSE 47874
// begin SetTag ( j , 103 ) ;
47818: LD_VAR 0 3
47822: PPUSH
47823: LD_INT 103
47825: PPUSH
47826: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47830: LD_ADDR_EXP 105
47834: PUSH
47835: LD_EXP 105
47839: PPUSH
47840: LD_VAR 0 2
47844: PUSH
47845: LD_EXP 105
47849: PUSH
47850: LD_VAR 0 2
47854: ARRAY
47855: PUSH
47856: LD_INT 1
47858: PLUS
47859: PUSH
47860: EMPTY
47861: LIST
47862: LIST
47863: PPUSH
47864: LD_VAR 0 3
47868: PPUSH
47869: CALL 72387 0 3
47873: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47874: LD_VAR 0 3
47878: PPUSH
47879: CALL_OW 310
47883: IFFALSE 47894
// ComExitBuilding ( j ) ;
47885: LD_VAR 0 3
47889: PPUSH
47890: CALL_OW 122
// wait ( 3 ) ;
47894: LD_INT 3
47896: PPUSH
47897: CALL_OW 67
// if not mc_build_list [ i ] then
47901: LD_EXP 104
47905: PUSH
47906: LD_VAR 0 2
47910: ARRAY
47911: NOT
47912: IFFALSE 47916
// break ;
47914: GO 48015
// if not HasTask ( j ) then
47916: LD_VAR 0 3
47920: PPUSH
47921: CALL_OW 314
47925: NOT
47926: IFFALSE 48013
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
47928: LD_VAR 0 3
47932: PPUSH
47933: LD_EXP 104
47937: PUSH
47938: LD_VAR 0 2
47942: ARRAY
47943: PUSH
47944: LD_INT 1
47946: ARRAY
47947: PUSH
47948: LD_INT 1
47950: ARRAY
47951: PPUSH
47952: LD_EXP 104
47956: PUSH
47957: LD_VAR 0 2
47961: ARRAY
47962: PUSH
47963: LD_INT 1
47965: ARRAY
47966: PUSH
47967: LD_INT 2
47969: ARRAY
47970: PPUSH
47971: LD_EXP 104
47975: PUSH
47976: LD_VAR 0 2
47980: ARRAY
47981: PUSH
47982: LD_INT 1
47984: ARRAY
47985: PUSH
47986: LD_INT 3
47988: ARRAY
47989: PPUSH
47990: LD_EXP 104
47994: PUSH
47995: LD_VAR 0 2
47999: ARRAY
48000: PUSH
48001: LD_INT 1
48003: ARRAY
48004: PUSH
48005: LD_INT 4
48007: ARRAY
48008: PPUSH
48009: CALL_OW 145
// end ;
48013: GO 47802
48015: POP
48016: POP
// end else
48017: GO 48189
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
48019: LD_EXP 99
48023: PUSH
48024: LD_VAR 0 2
48028: ARRAY
48029: PPUSH
48030: LD_EXP 104
48034: PUSH
48035: LD_VAR 0 2
48039: ARRAY
48040: PUSH
48041: LD_INT 1
48043: ARRAY
48044: PUSH
48045: LD_INT 1
48047: ARRAY
48048: PPUSH
48049: LD_EXP 104
48053: PUSH
48054: LD_VAR 0 2
48058: ARRAY
48059: PUSH
48060: LD_INT 1
48062: ARRAY
48063: PUSH
48064: LD_INT 2
48066: ARRAY
48067: PPUSH
48068: LD_EXP 104
48072: PUSH
48073: LD_VAR 0 2
48077: ARRAY
48078: PUSH
48079: LD_INT 1
48081: ARRAY
48082: PUSH
48083: LD_INT 3
48085: ARRAY
48086: PPUSH
48087: LD_EXP 104
48091: PUSH
48092: LD_VAR 0 2
48096: ARRAY
48097: PUSH
48098: LD_INT 1
48100: ARRAY
48101: PUSH
48102: LD_INT 4
48104: ARRAY
48105: PPUSH
48106: LD_EXP 99
48110: PUSH
48111: LD_VAR 0 2
48115: ARRAY
48116: PPUSH
48117: LD_INT 21
48119: PUSH
48120: LD_INT 3
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: PPUSH
48127: CALL_OW 72
48131: PPUSH
48132: EMPTY
48133: PPUSH
48134: CALL 79238 0 7
48138: NOT
48139: IFFALSE 48189
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48141: LD_ADDR_EXP 104
48145: PUSH
48146: LD_EXP 104
48150: PPUSH
48151: LD_VAR 0 2
48155: PPUSH
48156: LD_EXP 104
48160: PUSH
48161: LD_VAR 0 2
48165: ARRAY
48166: PPUSH
48167: LD_INT 1
48169: PPUSH
48170: LD_INT 1
48172: NEG
48173: PPUSH
48174: LD_INT 0
48176: PPUSH
48177: CALL 71805 0 4
48181: PPUSH
48182: CALL_OW 1
48186: ST_TO_ADDR
// continue ;
48187: GO 47620
// end ; end ;
48189: GO 47620
48191: POP
48192: POP
// end ; end ;
48193: GO 47049
48195: POP
48196: POP
// end ;
48197: LD_VAR 0 1
48201: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48202: LD_INT 0
48204: PPUSH
48205: PPUSH
48206: PPUSH
48207: PPUSH
48208: PPUSH
48209: PPUSH
// if not mc_bases then
48210: LD_EXP 99
48214: NOT
48215: IFFALSE 48219
// exit ;
48217: GO 48646
// for i = 1 to mc_bases do
48219: LD_ADDR_VAR 0 2
48223: PUSH
48224: DOUBLE
48225: LD_INT 1
48227: DEC
48228: ST_TO_ADDR
48229: LD_EXP 99
48233: PUSH
48234: FOR_TO
48235: IFFALSE 48644
// begin tmp := mc_build_upgrade [ i ] ;
48237: LD_ADDR_VAR 0 4
48241: PUSH
48242: LD_EXP 131
48246: PUSH
48247: LD_VAR 0 2
48251: ARRAY
48252: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48253: LD_ADDR_VAR 0 6
48257: PUSH
48258: LD_EXP 132
48262: PUSH
48263: LD_VAR 0 2
48267: ARRAY
48268: PPUSH
48269: LD_INT 2
48271: PUSH
48272: LD_INT 30
48274: PUSH
48275: LD_INT 6
48277: PUSH
48278: EMPTY
48279: LIST
48280: LIST
48281: PUSH
48282: LD_INT 30
48284: PUSH
48285: LD_INT 7
48287: PUSH
48288: EMPTY
48289: LIST
48290: LIST
48291: PUSH
48292: EMPTY
48293: LIST
48294: LIST
48295: LIST
48296: PPUSH
48297: CALL_OW 72
48301: ST_TO_ADDR
// if not tmp and not lab then
48302: LD_VAR 0 4
48306: NOT
48307: PUSH
48308: LD_VAR 0 6
48312: NOT
48313: AND
48314: IFFALSE 48318
// continue ;
48316: GO 48234
// if tmp then
48318: LD_VAR 0 4
48322: IFFALSE 48442
// for j in tmp do
48324: LD_ADDR_VAR 0 3
48328: PUSH
48329: LD_VAR 0 4
48333: PUSH
48334: FOR_IN
48335: IFFALSE 48440
// begin if UpgradeCost ( j ) then
48337: LD_VAR 0 3
48341: PPUSH
48342: CALL 78898 0 1
48346: IFFALSE 48438
// begin ComUpgrade ( j ) ;
48348: LD_VAR 0 3
48352: PPUSH
48353: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
48357: LD_ADDR_EXP 131
48361: PUSH
48362: LD_EXP 131
48366: PPUSH
48367: LD_VAR 0 2
48371: PPUSH
48372: LD_EXP 131
48376: PUSH
48377: LD_VAR 0 2
48381: ARRAY
48382: PUSH
48383: LD_VAR 0 3
48387: DIFF
48388: PPUSH
48389: CALL_OW 1
48393: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48394: LD_ADDR_EXP 106
48398: PUSH
48399: LD_EXP 106
48403: PPUSH
48404: LD_VAR 0 2
48408: PUSH
48409: LD_EXP 106
48413: PUSH
48414: LD_VAR 0 2
48418: ARRAY
48419: PUSH
48420: LD_INT 1
48422: PLUS
48423: PUSH
48424: EMPTY
48425: LIST
48426: LIST
48427: PPUSH
48428: LD_VAR 0 3
48432: PPUSH
48433: CALL 72387 0 3
48437: ST_TO_ADDR
// end ; end ;
48438: GO 48334
48440: POP
48441: POP
// if not lab or not mc_lab_upgrade [ i ] then
48442: LD_VAR 0 6
48446: NOT
48447: PUSH
48448: LD_EXP 133
48452: PUSH
48453: LD_VAR 0 2
48457: ARRAY
48458: NOT
48459: OR
48460: IFFALSE 48464
// continue ;
48462: GO 48234
// for j in lab do
48464: LD_ADDR_VAR 0 3
48468: PUSH
48469: LD_VAR 0 6
48473: PUSH
48474: FOR_IN
48475: IFFALSE 48640
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
48477: LD_VAR 0 3
48481: PPUSH
48482: CALL_OW 266
48486: PUSH
48487: LD_INT 6
48489: PUSH
48490: LD_INT 7
48492: PUSH
48493: EMPTY
48494: LIST
48495: LIST
48496: IN
48497: PUSH
48498: LD_VAR 0 3
48502: PPUSH
48503: CALL_OW 461
48507: PUSH
48508: LD_INT 1
48510: NONEQUAL
48511: AND
48512: IFFALSE 48638
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
48514: LD_VAR 0 3
48518: PPUSH
48519: LD_EXP 133
48523: PUSH
48524: LD_VAR 0 2
48528: ARRAY
48529: PUSH
48530: LD_INT 1
48532: ARRAY
48533: PPUSH
48534: CALL 79103 0 2
48538: IFFALSE 48638
// begin ComCancel ( j ) ;
48540: LD_VAR 0 3
48544: PPUSH
48545: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
48549: LD_VAR 0 3
48553: PPUSH
48554: LD_EXP 133
48558: PUSH
48559: LD_VAR 0 2
48563: ARRAY
48564: PUSH
48565: LD_INT 1
48567: ARRAY
48568: PPUSH
48569: CALL_OW 207
// if not j in mc_construct_list [ i ] then
48573: LD_VAR 0 3
48577: PUSH
48578: LD_EXP 106
48582: PUSH
48583: LD_VAR 0 2
48587: ARRAY
48588: IN
48589: NOT
48590: IFFALSE 48636
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48592: LD_ADDR_EXP 106
48596: PUSH
48597: LD_EXP 106
48601: PPUSH
48602: LD_VAR 0 2
48606: PUSH
48607: LD_EXP 106
48611: PUSH
48612: LD_VAR 0 2
48616: ARRAY
48617: PUSH
48618: LD_INT 1
48620: PLUS
48621: PUSH
48622: EMPTY
48623: LIST
48624: LIST
48625: PPUSH
48626: LD_VAR 0 3
48630: PPUSH
48631: CALL 72387 0 3
48635: ST_TO_ADDR
// break ;
48636: GO 48640
// end ; end ; end ;
48638: GO 48474
48640: POP
48641: POP
// end ;
48642: GO 48234
48644: POP
48645: POP
// end ;
48646: LD_VAR 0 1
48650: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
48651: LD_INT 0
48653: PPUSH
48654: PPUSH
48655: PPUSH
48656: PPUSH
48657: PPUSH
48658: PPUSH
48659: PPUSH
48660: PPUSH
48661: PPUSH
// if not mc_bases then
48662: LD_EXP 99
48666: NOT
48667: IFFALSE 48671
// exit ;
48669: GO 49076
// for i = 1 to mc_bases do
48671: LD_ADDR_VAR 0 2
48675: PUSH
48676: DOUBLE
48677: LD_INT 1
48679: DEC
48680: ST_TO_ADDR
48681: LD_EXP 99
48685: PUSH
48686: FOR_TO
48687: IFFALSE 49074
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
48689: LD_EXP 107
48693: PUSH
48694: LD_VAR 0 2
48698: ARRAY
48699: NOT
48700: PUSH
48701: LD_EXP 99
48705: PUSH
48706: LD_VAR 0 2
48710: ARRAY
48711: PPUSH
48712: LD_INT 30
48714: PUSH
48715: LD_INT 3
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: PPUSH
48722: CALL_OW 72
48726: NOT
48727: OR
48728: IFFALSE 48732
// continue ;
48730: GO 48686
// busy := false ;
48732: LD_ADDR_VAR 0 8
48736: PUSH
48737: LD_INT 0
48739: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48740: LD_ADDR_VAR 0 4
48744: PUSH
48745: LD_EXP 99
48749: PUSH
48750: LD_VAR 0 2
48754: ARRAY
48755: PPUSH
48756: LD_INT 30
48758: PUSH
48759: LD_INT 3
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PPUSH
48766: CALL_OW 72
48770: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
48771: LD_ADDR_VAR 0 6
48775: PUSH
48776: LD_EXP 107
48780: PUSH
48781: LD_VAR 0 2
48785: ARRAY
48786: PPUSH
48787: LD_INT 2
48789: PUSH
48790: LD_INT 30
48792: PUSH
48793: LD_INT 32
48795: PUSH
48796: EMPTY
48797: LIST
48798: LIST
48799: PUSH
48800: LD_INT 30
48802: PUSH
48803: LD_INT 33
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: PUSH
48810: EMPTY
48811: LIST
48812: LIST
48813: LIST
48814: PPUSH
48815: CALL_OW 72
48819: ST_TO_ADDR
// if not t then
48820: LD_VAR 0 6
48824: NOT
48825: IFFALSE 48829
// continue ;
48827: GO 48686
// for j in tmp do
48829: LD_ADDR_VAR 0 3
48833: PUSH
48834: LD_VAR 0 4
48838: PUSH
48839: FOR_IN
48840: IFFALSE 48870
// if not BuildingStatus ( j ) = bs_idle then
48842: LD_VAR 0 3
48846: PPUSH
48847: CALL_OW 461
48851: PUSH
48852: LD_INT 2
48854: EQUAL
48855: NOT
48856: IFFALSE 48868
// begin busy := true ;
48858: LD_ADDR_VAR 0 8
48862: PUSH
48863: LD_INT 1
48865: ST_TO_ADDR
// break ;
48866: GO 48870
// end ;
48868: GO 48839
48870: POP
48871: POP
// if busy then
48872: LD_VAR 0 8
48876: IFFALSE 48880
// continue ;
48878: GO 48686
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
48880: LD_ADDR_VAR 0 7
48884: PUSH
48885: LD_VAR 0 6
48889: PPUSH
48890: LD_INT 35
48892: PUSH
48893: LD_INT 0
48895: PUSH
48896: EMPTY
48897: LIST
48898: LIST
48899: PPUSH
48900: CALL_OW 72
48904: ST_TO_ADDR
// if tw then
48905: LD_VAR 0 7
48909: IFFALSE 48986
// begin tw := tw [ 1 ] ;
48911: LD_ADDR_VAR 0 7
48915: PUSH
48916: LD_VAR 0 7
48920: PUSH
48921: LD_INT 1
48923: ARRAY
48924: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
48925: LD_ADDR_VAR 0 9
48929: PUSH
48930: LD_VAR 0 7
48934: PPUSH
48935: LD_EXP 124
48939: PUSH
48940: LD_VAR 0 2
48944: ARRAY
48945: PPUSH
48946: CALL 77395 0 2
48950: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
48951: LD_EXP 138
48955: PUSH
48956: LD_VAR 0 2
48960: ARRAY
48961: IFFALSE 48984
// if not weapon in mc_allowed_tower_weapons [ i ] then
48963: LD_VAR 0 9
48967: PUSH
48968: LD_EXP 138
48972: PUSH
48973: LD_VAR 0 2
48977: ARRAY
48978: IN
48979: NOT
48980: IFFALSE 48984
// continue ;
48982: GO 48686
// end else
48984: GO 49049
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
48986: LD_ADDR_VAR 0 5
48990: PUSH
48991: LD_EXP 107
48995: PUSH
48996: LD_VAR 0 2
49000: ARRAY
49001: PPUSH
49002: LD_VAR 0 4
49006: PPUSH
49007: CALL 104247 0 2
49011: ST_TO_ADDR
// if not tmp2 then
49012: LD_VAR 0 5
49016: NOT
49017: IFFALSE 49021
// continue ;
49019: GO 48686
// tw := tmp2 [ 1 ] ;
49021: LD_ADDR_VAR 0 7
49025: PUSH
49026: LD_VAR 0 5
49030: PUSH
49031: LD_INT 1
49033: ARRAY
49034: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
49035: LD_ADDR_VAR 0 9
49039: PUSH
49040: LD_VAR 0 5
49044: PUSH
49045: LD_INT 2
49047: ARRAY
49048: ST_TO_ADDR
// end ; if not weapon then
49049: LD_VAR 0 9
49053: NOT
49054: IFFALSE 49058
// continue ;
49056: GO 48686
// ComPlaceWeapon ( tw , weapon ) ;
49058: LD_VAR 0 7
49062: PPUSH
49063: LD_VAR 0 9
49067: PPUSH
49068: CALL_OW 148
// end ;
49072: GO 48686
49074: POP
49075: POP
// end ;
49076: LD_VAR 0 1
49080: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49081: LD_INT 0
49083: PPUSH
49084: PPUSH
49085: PPUSH
49086: PPUSH
49087: PPUSH
49088: PPUSH
49089: PPUSH
// if not mc_bases then
49090: LD_EXP 99
49094: NOT
49095: IFFALSE 49099
// exit ;
49097: GO 49867
// for i = 1 to mc_bases do
49099: LD_ADDR_VAR 0 2
49103: PUSH
49104: DOUBLE
49105: LD_INT 1
49107: DEC
49108: ST_TO_ADDR
49109: LD_EXP 99
49113: PUSH
49114: FOR_TO
49115: IFFALSE 49865
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49117: LD_EXP 112
49121: PUSH
49122: LD_VAR 0 2
49126: ARRAY
49127: NOT
49128: PUSH
49129: LD_EXP 112
49133: PUSH
49134: LD_VAR 0 2
49138: ARRAY
49139: PUSH
49140: LD_EXP 113
49144: PUSH
49145: LD_VAR 0 2
49149: ARRAY
49150: EQUAL
49151: OR
49152: PUSH
49153: LD_EXP 122
49157: PUSH
49158: LD_VAR 0 2
49162: ARRAY
49163: OR
49164: IFFALSE 49168
// continue ;
49166: GO 49114
// if mc_miners [ i ] then
49168: LD_EXP 113
49172: PUSH
49173: LD_VAR 0 2
49177: ARRAY
49178: IFFALSE 49552
// begin for j = mc_miners [ i ] downto 1 do
49180: LD_ADDR_VAR 0 3
49184: PUSH
49185: DOUBLE
49186: LD_EXP 113
49190: PUSH
49191: LD_VAR 0 2
49195: ARRAY
49196: INC
49197: ST_TO_ADDR
49198: LD_INT 1
49200: PUSH
49201: FOR_DOWNTO
49202: IFFALSE 49550
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49204: LD_EXP 113
49208: PUSH
49209: LD_VAR 0 2
49213: ARRAY
49214: PUSH
49215: LD_VAR 0 3
49219: ARRAY
49220: PPUSH
49221: CALL_OW 301
49225: PUSH
49226: LD_EXP 113
49230: PUSH
49231: LD_VAR 0 2
49235: ARRAY
49236: PUSH
49237: LD_VAR 0 3
49241: ARRAY
49242: PPUSH
49243: CALL_OW 257
49247: PUSH
49248: LD_INT 1
49250: NONEQUAL
49251: OR
49252: IFFALSE 49315
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49254: LD_ADDR_VAR 0 5
49258: PUSH
49259: LD_EXP 113
49263: PUSH
49264: LD_VAR 0 2
49268: ARRAY
49269: PUSH
49270: LD_EXP 113
49274: PUSH
49275: LD_VAR 0 2
49279: ARRAY
49280: PUSH
49281: LD_VAR 0 3
49285: ARRAY
49286: DIFF
49287: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49288: LD_ADDR_EXP 113
49292: PUSH
49293: LD_EXP 113
49297: PPUSH
49298: LD_VAR 0 2
49302: PPUSH
49303: LD_VAR 0 5
49307: PPUSH
49308: CALL_OW 1
49312: ST_TO_ADDR
// continue ;
49313: GO 49201
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
49315: LD_EXP 113
49319: PUSH
49320: LD_VAR 0 2
49324: ARRAY
49325: PUSH
49326: LD_VAR 0 3
49330: ARRAY
49331: PPUSH
49332: CALL_OW 257
49336: PUSH
49337: LD_INT 1
49339: EQUAL
49340: PUSH
49341: LD_EXP 113
49345: PUSH
49346: LD_VAR 0 2
49350: ARRAY
49351: PUSH
49352: LD_VAR 0 3
49356: ARRAY
49357: PPUSH
49358: CALL_OW 459
49362: NOT
49363: AND
49364: PUSH
49365: LD_EXP 113
49369: PUSH
49370: LD_VAR 0 2
49374: ARRAY
49375: PUSH
49376: LD_VAR 0 3
49380: ARRAY
49381: PPUSH
49382: CALL_OW 314
49386: NOT
49387: AND
49388: IFFALSE 49548
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
49390: LD_EXP 113
49394: PUSH
49395: LD_VAR 0 2
49399: ARRAY
49400: PUSH
49401: LD_VAR 0 3
49405: ARRAY
49406: PPUSH
49407: CALL_OW 310
49411: IFFALSE 49434
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
49413: LD_EXP 113
49417: PUSH
49418: LD_VAR 0 2
49422: ARRAY
49423: PUSH
49424: LD_VAR 0 3
49428: ARRAY
49429: PPUSH
49430: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
49434: LD_EXP 113
49438: PUSH
49439: LD_VAR 0 2
49443: ARRAY
49444: PUSH
49445: LD_VAR 0 3
49449: ARRAY
49450: PPUSH
49451: CALL_OW 314
49455: NOT
49456: IFFALSE 49548
// begin r := rand ( 1 , mc_mines [ i ] ) ;
49458: LD_ADDR_VAR 0 7
49462: PUSH
49463: LD_INT 1
49465: PPUSH
49466: LD_EXP 112
49470: PUSH
49471: LD_VAR 0 2
49475: ARRAY
49476: PPUSH
49477: CALL_OW 12
49481: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
49482: LD_EXP 113
49486: PUSH
49487: LD_VAR 0 2
49491: ARRAY
49492: PUSH
49493: LD_VAR 0 3
49497: ARRAY
49498: PPUSH
49499: LD_EXP 112
49503: PUSH
49504: LD_VAR 0 2
49508: ARRAY
49509: PUSH
49510: LD_VAR 0 7
49514: ARRAY
49515: PUSH
49516: LD_INT 1
49518: ARRAY
49519: PPUSH
49520: LD_EXP 112
49524: PUSH
49525: LD_VAR 0 2
49529: ARRAY
49530: PUSH
49531: LD_VAR 0 7
49535: ARRAY
49536: PUSH
49537: LD_INT 2
49539: ARRAY
49540: PPUSH
49541: LD_INT 0
49543: PPUSH
49544: CALL_OW 193
// end ; end ; end ;
49548: GO 49201
49550: POP
49551: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
49552: LD_ADDR_VAR 0 5
49556: PUSH
49557: LD_EXP 99
49561: PUSH
49562: LD_VAR 0 2
49566: ARRAY
49567: PPUSH
49568: LD_INT 2
49570: PUSH
49571: LD_INT 30
49573: PUSH
49574: LD_INT 4
49576: PUSH
49577: EMPTY
49578: LIST
49579: LIST
49580: PUSH
49581: LD_INT 30
49583: PUSH
49584: LD_INT 5
49586: PUSH
49587: EMPTY
49588: LIST
49589: LIST
49590: PUSH
49591: LD_INT 30
49593: PUSH
49594: LD_INT 32
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: PUSH
49601: EMPTY
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: PPUSH
49607: CALL_OW 72
49611: ST_TO_ADDR
// if not tmp then
49612: LD_VAR 0 5
49616: NOT
49617: IFFALSE 49621
// continue ;
49619: GO 49114
// list := [ ] ;
49621: LD_ADDR_VAR 0 6
49625: PUSH
49626: EMPTY
49627: ST_TO_ADDR
// for j in tmp do
49628: LD_ADDR_VAR 0 3
49632: PUSH
49633: LD_VAR 0 5
49637: PUSH
49638: FOR_IN
49639: IFFALSE 49708
// begin for k in UnitsInside ( j ) do
49641: LD_ADDR_VAR 0 4
49645: PUSH
49646: LD_VAR 0 3
49650: PPUSH
49651: CALL_OW 313
49655: PUSH
49656: FOR_IN
49657: IFFALSE 49704
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
49659: LD_VAR 0 4
49663: PPUSH
49664: CALL_OW 257
49668: PUSH
49669: LD_INT 1
49671: EQUAL
49672: PUSH
49673: LD_VAR 0 4
49677: PPUSH
49678: CALL_OW 459
49682: NOT
49683: AND
49684: IFFALSE 49702
// list := list ^ k ;
49686: LD_ADDR_VAR 0 6
49690: PUSH
49691: LD_VAR 0 6
49695: PUSH
49696: LD_VAR 0 4
49700: ADD
49701: ST_TO_ADDR
49702: GO 49656
49704: POP
49705: POP
// end ;
49706: GO 49638
49708: POP
49709: POP
// list := list diff mc_miners [ i ] ;
49710: LD_ADDR_VAR 0 6
49714: PUSH
49715: LD_VAR 0 6
49719: PUSH
49720: LD_EXP 113
49724: PUSH
49725: LD_VAR 0 2
49729: ARRAY
49730: DIFF
49731: ST_TO_ADDR
// if not list then
49732: LD_VAR 0 6
49736: NOT
49737: IFFALSE 49741
// continue ;
49739: GO 49114
// k := mc_mines [ i ] - mc_miners [ i ] ;
49741: LD_ADDR_VAR 0 4
49745: PUSH
49746: LD_EXP 112
49750: PUSH
49751: LD_VAR 0 2
49755: ARRAY
49756: PUSH
49757: LD_EXP 113
49761: PUSH
49762: LD_VAR 0 2
49766: ARRAY
49767: MINUS
49768: ST_TO_ADDR
// if k > list then
49769: LD_VAR 0 4
49773: PUSH
49774: LD_VAR 0 6
49778: GREATER
49779: IFFALSE 49791
// k := list ;
49781: LD_ADDR_VAR 0 4
49785: PUSH
49786: LD_VAR 0 6
49790: ST_TO_ADDR
// for j = 1 to k do
49791: LD_ADDR_VAR 0 3
49795: PUSH
49796: DOUBLE
49797: LD_INT 1
49799: DEC
49800: ST_TO_ADDR
49801: LD_VAR 0 4
49805: PUSH
49806: FOR_TO
49807: IFFALSE 49861
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
49809: LD_ADDR_EXP 113
49813: PUSH
49814: LD_EXP 113
49818: PPUSH
49819: LD_VAR 0 2
49823: PUSH
49824: LD_EXP 113
49828: PUSH
49829: LD_VAR 0 2
49833: ARRAY
49834: PUSH
49835: LD_INT 1
49837: PLUS
49838: PUSH
49839: EMPTY
49840: LIST
49841: LIST
49842: PPUSH
49843: LD_VAR 0 6
49847: PUSH
49848: LD_VAR 0 3
49852: ARRAY
49853: PPUSH
49854: CALL 72387 0 3
49858: ST_TO_ADDR
49859: GO 49806
49861: POP
49862: POP
// end ;
49863: GO 49114
49865: POP
49866: POP
// end ;
49867: LD_VAR 0 1
49871: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
49872: LD_INT 0
49874: PPUSH
49875: PPUSH
49876: PPUSH
49877: PPUSH
49878: PPUSH
49879: PPUSH
49880: PPUSH
49881: PPUSH
49882: PPUSH
49883: PPUSH
49884: PPUSH
// if not mc_bases then
49885: LD_EXP 99
49889: NOT
49890: IFFALSE 49894
// exit ;
49892: GO 51717
// for i = 1 to mc_bases do
49894: LD_ADDR_VAR 0 2
49898: PUSH
49899: DOUBLE
49900: LD_INT 1
49902: DEC
49903: ST_TO_ADDR
49904: LD_EXP 99
49908: PUSH
49909: FOR_TO
49910: IFFALSE 51715
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
49912: LD_EXP 99
49916: PUSH
49917: LD_VAR 0 2
49921: ARRAY
49922: NOT
49923: PUSH
49924: LD_EXP 106
49928: PUSH
49929: LD_VAR 0 2
49933: ARRAY
49934: OR
49935: IFFALSE 49939
// continue ;
49937: GO 49909
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
49939: LD_EXP 115
49943: PUSH
49944: LD_VAR 0 2
49948: ARRAY
49949: NOT
49950: PUSH
49951: LD_EXP 116
49955: PUSH
49956: LD_VAR 0 2
49960: ARRAY
49961: AND
49962: IFFALSE 50000
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
49964: LD_ADDR_EXP 116
49968: PUSH
49969: LD_EXP 116
49973: PPUSH
49974: LD_VAR 0 2
49978: PPUSH
49979: EMPTY
49980: PPUSH
49981: CALL_OW 1
49985: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
49986: LD_VAR 0 2
49990: PPUSH
49991: LD_INT 107
49993: PPUSH
49994: CALL 40747 0 2
// continue ;
49998: GO 49909
// end ; target := [ ] ;
50000: LD_ADDR_VAR 0 7
50004: PUSH
50005: EMPTY
50006: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50007: LD_ADDR_VAR 0 6
50011: PUSH
50012: LD_EXP 99
50016: PUSH
50017: LD_VAR 0 2
50021: ARRAY
50022: PUSH
50023: LD_INT 1
50025: ARRAY
50026: PPUSH
50027: CALL_OW 255
50031: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50032: LD_ADDR_VAR 0 9
50036: PUSH
50037: LD_EXP 99
50041: PUSH
50042: LD_VAR 0 2
50046: ARRAY
50047: PPUSH
50048: LD_INT 2
50050: PUSH
50051: LD_INT 30
50053: PUSH
50054: LD_INT 0
50056: PUSH
50057: EMPTY
50058: LIST
50059: LIST
50060: PUSH
50061: LD_INT 30
50063: PUSH
50064: LD_INT 1
50066: PUSH
50067: EMPTY
50068: LIST
50069: LIST
50070: PUSH
50071: EMPTY
50072: LIST
50073: LIST
50074: LIST
50075: PPUSH
50076: CALL_OW 72
50080: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50081: LD_ADDR_VAR 0 3
50085: PUSH
50086: DOUBLE
50087: LD_EXP 115
50091: PUSH
50092: LD_VAR 0 2
50096: ARRAY
50097: INC
50098: ST_TO_ADDR
50099: LD_INT 1
50101: PUSH
50102: FOR_DOWNTO
50103: IFFALSE 50348
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50105: LD_EXP 115
50109: PUSH
50110: LD_VAR 0 2
50114: ARRAY
50115: PUSH
50116: LD_VAR 0 3
50120: ARRAY
50121: PUSH
50122: LD_INT 2
50124: ARRAY
50125: PPUSH
50126: LD_EXP 115
50130: PUSH
50131: LD_VAR 0 2
50135: ARRAY
50136: PUSH
50137: LD_VAR 0 3
50141: ARRAY
50142: PUSH
50143: LD_INT 3
50145: ARRAY
50146: PPUSH
50147: CALL_OW 488
50151: PUSH
50152: LD_EXP 115
50156: PUSH
50157: LD_VAR 0 2
50161: ARRAY
50162: PUSH
50163: LD_VAR 0 3
50167: ARRAY
50168: PUSH
50169: LD_INT 2
50171: ARRAY
50172: PPUSH
50173: LD_EXP 115
50177: PUSH
50178: LD_VAR 0 2
50182: ARRAY
50183: PUSH
50184: LD_VAR 0 3
50188: ARRAY
50189: PUSH
50190: LD_INT 3
50192: ARRAY
50193: PPUSH
50194: CALL_OW 284
50198: PUSH
50199: LD_INT 0
50201: EQUAL
50202: AND
50203: IFFALSE 50258
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50205: LD_ADDR_VAR 0 5
50209: PUSH
50210: LD_EXP 115
50214: PUSH
50215: LD_VAR 0 2
50219: ARRAY
50220: PPUSH
50221: LD_VAR 0 3
50225: PPUSH
50226: CALL_OW 3
50230: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50231: LD_ADDR_EXP 115
50235: PUSH
50236: LD_EXP 115
50240: PPUSH
50241: LD_VAR 0 2
50245: PPUSH
50246: LD_VAR 0 5
50250: PPUSH
50251: CALL_OW 1
50255: ST_TO_ADDR
// continue ;
50256: GO 50102
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50258: LD_VAR 0 6
50262: PPUSH
50263: LD_EXP 115
50267: PUSH
50268: LD_VAR 0 2
50272: ARRAY
50273: PUSH
50274: LD_VAR 0 3
50278: ARRAY
50279: PUSH
50280: LD_INT 2
50282: ARRAY
50283: PPUSH
50284: LD_EXP 115
50288: PUSH
50289: LD_VAR 0 2
50293: ARRAY
50294: PUSH
50295: LD_VAR 0 3
50299: ARRAY
50300: PUSH
50301: LD_INT 3
50303: ARRAY
50304: PPUSH
50305: LD_INT 30
50307: PPUSH
50308: CALL 73283 0 4
50312: PUSH
50313: LD_INT 4
50315: ARRAY
50316: PUSH
50317: LD_INT 0
50319: EQUAL
50320: IFFALSE 50346
// begin target := mc_crates [ i ] [ j ] ;
50322: LD_ADDR_VAR 0 7
50326: PUSH
50327: LD_EXP 115
50331: PUSH
50332: LD_VAR 0 2
50336: ARRAY
50337: PUSH
50338: LD_VAR 0 3
50342: ARRAY
50343: ST_TO_ADDR
// break ;
50344: GO 50348
// end ; end ;
50346: GO 50102
50348: POP
50349: POP
// if not target then
50350: LD_VAR 0 7
50354: NOT
50355: IFFALSE 50359
// continue ;
50357: GO 49909
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
50359: LD_ADDR_VAR 0 8
50363: PUSH
50364: LD_EXP 118
50368: PUSH
50369: LD_VAR 0 2
50373: ARRAY
50374: PPUSH
50375: LD_INT 2
50377: PUSH
50378: LD_INT 3
50380: PUSH
50381: LD_INT 58
50383: PUSH
50384: EMPTY
50385: LIST
50386: PUSH
50387: EMPTY
50388: LIST
50389: LIST
50390: PUSH
50391: LD_INT 61
50393: PUSH
50394: EMPTY
50395: LIST
50396: PUSH
50397: LD_INT 33
50399: PUSH
50400: LD_INT 5
50402: PUSH
50403: EMPTY
50404: LIST
50405: LIST
50406: PUSH
50407: LD_INT 33
50409: PUSH
50410: LD_INT 3
50412: PUSH
50413: EMPTY
50414: LIST
50415: LIST
50416: PUSH
50417: EMPTY
50418: LIST
50419: LIST
50420: LIST
50421: LIST
50422: LIST
50423: PUSH
50424: LD_INT 2
50426: PUSH
50427: LD_INT 34
50429: PUSH
50430: LD_INT 32
50432: PUSH
50433: EMPTY
50434: LIST
50435: LIST
50436: PUSH
50437: LD_INT 34
50439: PUSH
50440: LD_INT 51
50442: PUSH
50443: EMPTY
50444: LIST
50445: LIST
50446: PUSH
50447: LD_INT 34
50449: PUSH
50450: LD_INT 12
50452: PUSH
50453: EMPTY
50454: LIST
50455: LIST
50456: PUSH
50457: EMPTY
50458: LIST
50459: LIST
50460: LIST
50461: LIST
50462: PUSH
50463: EMPTY
50464: LIST
50465: LIST
50466: PPUSH
50467: CALL_OW 72
50471: ST_TO_ADDR
// if not cargo then
50472: LD_VAR 0 8
50476: NOT
50477: IFFALSE 51183
// begin if mc_crates_collector [ i ] < 5 then
50479: LD_EXP 116
50483: PUSH
50484: LD_VAR 0 2
50488: ARRAY
50489: PUSH
50490: LD_INT 5
50492: LESS
50493: IFFALSE 50859
// begin if mc_ape [ i ] then
50495: LD_EXP 128
50499: PUSH
50500: LD_VAR 0 2
50504: ARRAY
50505: IFFALSE 50552
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
50507: LD_ADDR_VAR 0 5
50511: PUSH
50512: LD_EXP 128
50516: PUSH
50517: LD_VAR 0 2
50521: ARRAY
50522: PPUSH
50523: LD_INT 25
50525: PUSH
50526: LD_INT 16
50528: PUSH
50529: EMPTY
50530: LIST
50531: LIST
50532: PUSH
50533: LD_INT 24
50535: PUSH
50536: LD_INT 750
50538: PUSH
50539: EMPTY
50540: LIST
50541: LIST
50542: PUSH
50543: EMPTY
50544: LIST
50545: LIST
50546: PPUSH
50547: CALL_OW 72
50551: ST_TO_ADDR
// if not tmp then
50552: LD_VAR 0 5
50556: NOT
50557: IFFALSE 50604
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
50559: LD_ADDR_VAR 0 5
50563: PUSH
50564: LD_EXP 99
50568: PUSH
50569: LD_VAR 0 2
50573: ARRAY
50574: PPUSH
50575: LD_INT 25
50577: PUSH
50578: LD_INT 2
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PUSH
50585: LD_INT 24
50587: PUSH
50588: LD_INT 750
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: PPUSH
50599: CALL_OW 72
50603: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
50604: LD_EXP 128
50608: PUSH
50609: LD_VAR 0 2
50613: ARRAY
50614: PUSH
50615: LD_EXP 99
50619: PUSH
50620: LD_VAR 0 2
50624: ARRAY
50625: PPUSH
50626: LD_INT 25
50628: PUSH
50629: LD_INT 2
50631: PUSH
50632: EMPTY
50633: LIST
50634: LIST
50635: PUSH
50636: LD_INT 24
50638: PUSH
50639: LD_INT 750
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: PUSH
50646: EMPTY
50647: LIST
50648: LIST
50649: PPUSH
50650: CALL_OW 72
50654: AND
50655: PUSH
50656: LD_VAR 0 5
50660: PUSH
50661: LD_INT 5
50663: LESS
50664: AND
50665: IFFALSE 50747
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
50667: LD_ADDR_VAR 0 3
50671: PUSH
50672: LD_EXP 99
50676: PUSH
50677: LD_VAR 0 2
50681: ARRAY
50682: PPUSH
50683: LD_INT 25
50685: PUSH
50686: LD_INT 2
50688: PUSH
50689: EMPTY
50690: LIST
50691: LIST
50692: PUSH
50693: LD_INT 24
50695: PUSH
50696: LD_INT 750
50698: PUSH
50699: EMPTY
50700: LIST
50701: LIST
50702: PUSH
50703: EMPTY
50704: LIST
50705: LIST
50706: PPUSH
50707: CALL_OW 72
50711: PUSH
50712: FOR_IN
50713: IFFALSE 50745
// begin tmp := tmp union j ;
50715: LD_ADDR_VAR 0 5
50719: PUSH
50720: LD_VAR 0 5
50724: PUSH
50725: LD_VAR 0 3
50729: UNION
50730: ST_TO_ADDR
// if tmp >= 5 then
50731: LD_VAR 0 5
50735: PUSH
50736: LD_INT 5
50738: GREATEREQUAL
50739: IFFALSE 50743
// break ;
50741: GO 50745
// end ;
50743: GO 50712
50745: POP
50746: POP
// end ; if not tmp then
50747: LD_VAR 0 5
50751: NOT
50752: IFFALSE 50756
// continue ;
50754: GO 49909
// for j in tmp do
50756: LD_ADDR_VAR 0 3
50760: PUSH
50761: LD_VAR 0 5
50765: PUSH
50766: FOR_IN
50767: IFFALSE 50857
// if not GetTag ( j ) then
50769: LD_VAR 0 3
50773: PPUSH
50774: CALL_OW 110
50778: NOT
50779: IFFALSE 50855
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
50781: LD_ADDR_EXP 116
50785: PUSH
50786: LD_EXP 116
50790: PPUSH
50791: LD_VAR 0 2
50795: PUSH
50796: LD_EXP 116
50800: PUSH
50801: LD_VAR 0 2
50805: ARRAY
50806: PUSH
50807: LD_INT 1
50809: PLUS
50810: PUSH
50811: EMPTY
50812: LIST
50813: LIST
50814: PPUSH
50815: LD_VAR 0 3
50819: PPUSH
50820: CALL 72387 0 3
50824: ST_TO_ADDR
// SetTag ( j , 107 ) ;
50825: LD_VAR 0 3
50829: PPUSH
50830: LD_INT 107
50832: PPUSH
50833: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
50837: LD_EXP 116
50841: PUSH
50842: LD_VAR 0 2
50846: ARRAY
50847: PUSH
50848: LD_INT 5
50850: GREATEREQUAL
50851: IFFALSE 50855
// break ;
50853: GO 50857
// end ;
50855: GO 50766
50857: POP
50858: POP
// end ; if mc_crates_collector [ i ] and target then
50859: LD_EXP 116
50863: PUSH
50864: LD_VAR 0 2
50868: ARRAY
50869: PUSH
50870: LD_VAR 0 7
50874: AND
50875: IFFALSE 51181
// begin if mc_crates_collector [ i ] < target [ 1 ] then
50877: LD_EXP 116
50881: PUSH
50882: LD_VAR 0 2
50886: ARRAY
50887: PUSH
50888: LD_VAR 0 7
50892: PUSH
50893: LD_INT 1
50895: ARRAY
50896: LESS
50897: IFFALSE 50917
// tmp := mc_crates_collector [ i ] else
50899: LD_ADDR_VAR 0 5
50903: PUSH
50904: LD_EXP 116
50908: PUSH
50909: LD_VAR 0 2
50913: ARRAY
50914: ST_TO_ADDR
50915: GO 50931
// tmp := target [ 1 ] ;
50917: LD_ADDR_VAR 0 5
50921: PUSH
50922: LD_VAR 0 7
50926: PUSH
50927: LD_INT 1
50929: ARRAY
50930: ST_TO_ADDR
// k := 0 ;
50931: LD_ADDR_VAR 0 4
50935: PUSH
50936: LD_INT 0
50938: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
50939: LD_ADDR_VAR 0 3
50943: PUSH
50944: LD_EXP 116
50948: PUSH
50949: LD_VAR 0 2
50953: ARRAY
50954: PUSH
50955: FOR_IN
50956: IFFALSE 51179
// begin k := k + 1 ;
50958: LD_ADDR_VAR 0 4
50962: PUSH
50963: LD_VAR 0 4
50967: PUSH
50968: LD_INT 1
50970: PLUS
50971: ST_TO_ADDR
// if k > tmp then
50972: LD_VAR 0 4
50976: PUSH
50977: LD_VAR 0 5
50981: GREATER
50982: IFFALSE 50986
// break ;
50984: GO 51179
// if not GetClass ( j ) in [ 2 , 16 ] then
50986: LD_VAR 0 3
50990: PPUSH
50991: CALL_OW 257
50995: PUSH
50996: LD_INT 2
50998: PUSH
50999: LD_INT 16
51001: PUSH
51002: EMPTY
51003: LIST
51004: LIST
51005: IN
51006: NOT
51007: IFFALSE 51060
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
51009: LD_ADDR_EXP 116
51013: PUSH
51014: LD_EXP 116
51018: PPUSH
51019: LD_VAR 0 2
51023: PPUSH
51024: LD_EXP 116
51028: PUSH
51029: LD_VAR 0 2
51033: ARRAY
51034: PUSH
51035: LD_VAR 0 3
51039: DIFF
51040: PPUSH
51041: CALL_OW 1
51045: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51046: LD_VAR 0 3
51050: PPUSH
51051: LD_INT 0
51053: PPUSH
51054: CALL_OW 109
// continue ;
51058: GO 50955
// end ; if IsInUnit ( j ) then
51060: LD_VAR 0 3
51064: PPUSH
51065: CALL_OW 310
51069: IFFALSE 51080
// ComExitBuilding ( j ) ;
51071: LD_VAR 0 3
51075: PPUSH
51076: CALL_OW 122
// wait ( 3 ) ;
51080: LD_INT 3
51082: PPUSH
51083: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51087: LD_VAR 0 3
51091: PPUSH
51092: CALL_OW 314
51096: PUSH
51097: LD_VAR 0 6
51101: PPUSH
51102: LD_VAR 0 7
51106: PUSH
51107: LD_INT 2
51109: ARRAY
51110: PPUSH
51111: LD_VAR 0 7
51115: PUSH
51116: LD_INT 3
51118: ARRAY
51119: PPUSH
51120: LD_INT 30
51122: PPUSH
51123: CALL 73283 0 4
51127: PUSH
51128: LD_INT 4
51130: ARRAY
51131: AND
51132: IFFALSE 51150
// ComStandNearbyBuilding ( j , depot ) else
51134: LD_VAR 0 3
51138: PPUSH
51139: LD_VAR 0 9
51143: PPUSH
51144: CALL 68814 0 2
51148: GO 51177
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51150: LD_VAR 0 3
51154: PPUSH
51155: LD_VAR 0 7
51159: PUSH
51160: LD_INT 2
51162: ARRAY
51163: PPUSH
51164: LD_VAR 0 7
51168: PUSH
51169: LD_INT 3
51171: ARRAY
51172: PPUSH
51173: CALL_OW 117
// end ;
51177: GO 50955
51179: POP
51180: POP
// end ; end else
51181: GO 51713
// begin for j in cargo do
51183: LD_ADDR_VAR 0 3
51187: PUSH
51188: LD_VAR 0 8
51192: PUSH
51193: FOR_IN
51194: IFFALSE 51711
// begin if GetTag ( j ) <> 0 then
51196: LD_VAR 0 3
51200: PPUSH
51201: CALL_OW 110
51205: PUSH
51206: LD_INT 0
51208: NONEQUAL
51209: IFFALSE 51213
// continue ;
51211: GO 51193
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51213: LD_VAR 0 3
51217: PPUSH
51218: CALL_OW 256
51222: PUSH
51223: LD_INT 1000
51225: LESS
51226: PUSH
51227: LD_VAR 0 3
51231: PPUSH
51232: LD_EXP 123
51236: PUSH
51237: LD_VAR 0 2
51241: ARRAY
51242: PPUSH
51243: CALL_OW 308
51247: NOT
51248: AND
51249: IFFALSE 51271
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51251: LD_VAR 0 3
51255: PPUSH
51256: LD_EXP 123
51260: PUSH
51261: LD_VAR 0 2
51265: ARRAY
51266: PPUSH
51267: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51271: LD_VAR 0 3
51275: PPUSH
51276: CALL_OW 256
51280: PUSH
51281: LD_INT 1000
51283: LESS
51284: PUSH
51285: LD_VAR 0 3
51289: PPUSH
51290: LD_EXP 123
51294: PUSH
51295: LD_VAR 0 2
51299: ARRAY
51300: PPUSH
51301: CALL_OW 308
51305: AND
51306: IFFALSE 51310
// continue ;
51308: GO 51193
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
51310: LD_VAR 0 3
51314: PPUSH
51315: CALL_OW 262
51319: PUSH
51320: LD_INT 2
51322: EQUAL
51323: PUSH
51324: LD_VAR 0 3
51328: PPUSH
51329: CALL_OW 261
51333: PUSH
51334: LD_INT 15
51336: LESS
51337: AND
51338: IFFALSE 51342
// continue ;
51340: GO 51193
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
51342: LD_VAR 0 3
51346: PPUSH
51347: CALL_OW 262
51351: PUSH
51352: LD_INT 1
51354: EQUAL
51355: PUSH
51356: LD_VAR 0 3
51360: PPUSH
51361: CALL_OW 261
51365: PUSH
51366: LD_INT 10
51368: LESS
51369: AND
51370: IFFALSE 51650
// begin if not depot then
51372: LD_VAR 0 9
51376: NOT
51377: IFFALSE 51381
// continue ;
51379: GO 51193
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
51381: LD_VAR 0 3
51385: PPUSH
51386: LD_VAR 0 9
51390: PPUSH
51391: LD_VAR 0 3
51395: PPUSH
51396: CALL_OW 74
51400: PPUSH
51401: CALL_OW 296
51405: PUSH
51406: LD_INT 6
51408: LESS
51409: IFFALSE 51425
// SetFuel ( j , 100 ) else
51411: LD_VAR 0 3
51415: PPUSH
51416: LD_INT 100
51418: PPUSH
51419: CALL_OW 240
51423: GO 51650
// if GetFuel ( j ) = 0 then
51425: LD_VAR 0 3
51429: PPUSH
51430: CALL_OW 261
51434: PUSH
51435: LD_INT 0
51437: EQUAL
51438: IFFALSE 51650
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
51440: LD_ADDR_EXP 118
51444: PUSH
51445: LD_EXP 118
51449: PPUSH
51450: LD_VAR 0 2
51454: PPUSH
51455: LD_EXP 118
51459: PUSH
51460: LD_VAR 0 2
51464: ARRAY
51465: PUSH
51466: LD_VAR 0 3
51470: DIFF
51471: PPUSH
51472: CALL_OW 1
51476: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
51477: LD_VAR 0 3
51481: PPUSH
51482: CALL_OW 263
51486: PUSH
51487: LD_INT 1
51489: EQUAL
51490: IFFALSE 51506
// ComExitVehicle ( IsInUnit ( j ) ) ;
51492: LD_VAR 0 3
51496: PPUSH
51497: CALL_OW 310
51501: PPUSH
51502: CALL_OW 121
// if GetControl ( j ) = control_remote then
51506: LD_VAR 0 3
51510: PPUSH
51511: CALL_OW 263
51515: PUSH
51516: LD_INT 2
51518: EQUAL
51519: IFFALSE 51530
// ComUnlink ( j ) ;
51521: LD_VAR 0 3
51525: PPUSH
51526: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
51530: LD_ADDR_VAR 0 10
51534: PUSH
51535: LD_VAR 0 2
51539: PPUSH
51540: LD_INT 3
51542: PPUSH
51543: CALL 61317 0 2
51547: ST_TO_ADDR
// if fac then
51548: LD_VAR 0 10
51552: IFFALSE 51648
// begin for k in fac do
51554: LD_ADDR_VAR 0 4
51558: PUSH
51559: LD_VAR 0 10
51563: PUSH
51564: FOR_IN
51565: IFFALSE 51646
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
51567: LD_ADDR_VAR 0 11
51571: PUSH
51572: LD_VAR 0 10
51576: PPUSH
51577: LD_VAR 0 3
51581: PPUSH
51582: CALL_OW 265
51586: PPUSH
51587: LD_VAR 0 3
51591: PPUSH
51592: CALL_OW 262
51596: PPUSH
51597: LD_VAR 0 3
51601: PPUSH
51602: CALL_OW 263
51606: PPUSH
51607: LD_VAR 0 3
51611: PPUSH
51612: CALL_OW 264
51616: PPUSH
51617: CALL 69885 0 5
51621: ST_TO_ADDR
// if components then
51622: LD_VAR 0 11
51626: IFFALSE 51644
// begin MC_InsertProduceList ( i , components ) ;
51628: LD_VAR 0 2
51632: PPUSH
51633: LD_VAR 0 11
51637: PPUSH
51638: CALL 60862 0 2
// break ;
51642: GO 51646
// end ; end ;
51644: GO 51564
51646: POP
51647: POP
// end ; continue ;
51648: GO 51193
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
51650: LD_VAR 0 3
51654: PPUSH
51655: LD_INT 1
51657: PPUSH
51658: CALL_OW 289
51662: PUSH
51663: LD_INT 100
51665: LESS
51666: PUSH
51667: LD_VAR 0 3
51671: PPUSH
51672: CALL_OW 314
51676: NOT
51677: AND
51678: IFFALSE 51707
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51680: LD_VAR 0 3
51684: PPUSH
51685: LD_VAR 0 7
51689: PUSH
51690: LD_INT 2
51692: ARRAY
51693: PPUSH
51694: LD_VAR 0 7
51698: PUSH
51699: LD_INT 3
51701: ARRAY
51702: PPUSH
51703: CALL_OW 117
// break ;
51707: GO 51711
// end ;
51709: GO 51193
51711: POP
51712: POP
// end ; end ;
51713: GO 49909
51715: POP
51716: POP
// end ;
51717: LD_VAR 0 1
51721: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
51722: LD_INT 0
51724: PPUSH
51725: PPUSH
51726: PPUSH
51727: PPUSH
// if not mc_bases then
51728: LD_EXP 99
51732: NOT
51733: IFFALSE 51737
// exit ;
51735: GO 51898
// for i = 1 to mc_bases do
51737: LD_ADDR_VAR 0 2
51741: PUSH
51742: DOUBLE
51743: LD_INT 1
51745: DEC
51746: ST_TO_ADDR
51747: LD_EXP 99
51751: PUSH
51752: FOR_TO
51753: IFFALSE 51896
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
51755: LD_ADDR_VAR 0 4
51759: PUSH
51760: LD_EXP 118
51764: PUSH
51765: LD_VAR 0 2
51769: ARRAY
51770: PUSH
51771: LD_EXP 121
51775: PUSH
51776: LD_VAR 0 2
51780: ARRAY
51781: UNION
51782: PPUSH
51783: LD_INT 33
51785: PUSH
51786: LD_INT 2
51788: PUSH
51789: EMPTY
51790: LIST
51791: LIST
51792: PPUSH
51793: CALL_OW 72
51797: ST_TO_ADDR
// if tmp then
51798: LD_VAR 0 4
51802: IFFALSE 51894
// for j in tmp do
51804: LD_ADDR_VAR 0 3
51808: PUSH
51809: LD_VAR 0 4
51813: PUSH
51814: FOR_IN
51815: IFFALSE 51892
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
51817: LD_VAR 0 3
51821: PPUSH
51822: CALL_OW 312
51826: NOT
51827: PUSH
51828: LD_VAR 0 3
51832: PPUSH
51833: CALL_OW 256
51837: PUSH
51838: LD_INT 250
51840: GREATEREQUAL
51841: AND
51842: IFFALSE 51855
// Connect ( j ) else
51844: LD_VAR 0 3
51848: PPUSH
51849: CALL 75356 0 1
51853: GO 51890
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
51855: LD_VAR 0 3
51859: PPUSH
51860: CALL_OW 256
51864: PUSH
51865: LD_INT 250
51867: LESS
51868: PUSH
51869: LD_VAR 0 3
51873: PPUSH
51874: CALL_OW 312
51878: AND
51879: IFFALSE 51890
// ComUnlink ( j ) ;
51881: LD_VAR 0 3
51885: PPUSH
51886: CALL_OW 136
51890: GO 51814
51892: POP
51893: POP
// end ;
51894: GO 51752
51896: POP
51897: POP
// end ;
51898: LD_VAR 0 1
51902: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
51903: LD_INT 0
51905: PPUSH
51906: PPUSH
51907: PPUSH
51908: PPUSH
51909: PPUSH
// if not mc_bases then
51910: LD_EXP 99
51914: NOT
51915: IFFALSE 51919
// exit ;
51917: GO 52364
// for i = 1 to mc_bases do
51919: LD_ADDR_VAR 0 2
51923: PUSH
51924: DOUBLE
51925: LD_INT 1
51927: DEC
51928: ST_TO_ADDR
51929: LD_EXP 99
51933: PUSH
51934: FOR_TO
51935: IFFALSE 52362
// begin if not mc_produce [ i ] then
51937: LD_EXP 120
51941: PUSH
51942: LD_VAR 0 2
51946: ARRAY
51947: NOT
51948: IFFALSE 51952
// continue ;
51950: GO 51934
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51952: LD_ADDR_VAR 0 5
51956: PUSH
51957: LD_EXP 99
51961: PUSH
51962: LD_VAR 0 2
51966: ARRAY
51967: PPUSH
51968: LD_INT 30
51970: PUSH
51971: LD_INT 3
51973: PUSH
51974: EMPTY
51975: LIST
51976: LIST
51977: PPUSH
51978: CALL_OW 72
51982: ST_TO_ADDR
// if not fac then
51983: LD_VAR 0 5
51987: NOT
51988: IFFALSE 51992
// continue ;
51990: GO 51934
// for j in fac do
51992: LD_ADDR_VAR 0 3
51996: PUSH
51997: LD_VAR 0 5
52001: PUSH
52002: FOR_IN
52003: IFFALSE 52358
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
52005: LD_VAR 0 3
52009: PPUSH
52010: CALL_OW 461
52014: PUSH
52015: LD_INT 2
52017: NONEQUAL
52018: PUSH
52019: LD_VAR 0 3
52023: PPUSH
52024: LD_INT 15
52026: PPUSH
52027: CALL 74984 0 2
52031: PUSH
52032: LD_INT 4
52034: ARRAY
52035: OR
52036: IFFALSE 52040
// continue ;
52038: GO 52002
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
52040: LD_VAR 0 3
52044: PPUSH
52045: LD_EXP 120
52049: PUSH
52050: LD_VAR 0 2
52054: ARRAY
52055: PUSH
52056: LD_INT 1
52058: ARRAY
52059: PUSH
52060: LD_INT 1
52062: ARRAY
52063: PPUSH
52064: LD_EXP 120
52068: PUSH
52069: LD_VAR 0 2
52073: ARRAY
52074: PUSH
52075: LD_INT 1
52077: ARRAY
52078: PUSH
52079: LD_INT 2
52081: ARRAY
52082: PPUSH
52083: LD_EXP 120
52087: PUSH
52088: LD_VAR 0 2
52092: ARRAY
52093: PUSH
52094: LD_INT 1
52096: ARRAY
52097: PUSH
52098: LD_INT 3
52100: ARRAY
52101: PPUSH
52102: LD_EXP 120
52106: PUSH
52107: LD_VAR 0 2
52111: ARRAY
52112: PUSH
52113: LD_INT 1
52115: ARRAY
52116: PUSH
52117: LD_INT 4
52119: ARRAY
52120: PPUSH
52121: CALL_OW 448
52125: PUSH
52126: LD_VAR 0 3
52130: PPUSH
52131: LD_EXP 120
52135: PUSH
52136: LD_VAR 0 2
52140: ARRAY
52141: PUSH
52142: LD_INT 1
52144: ARRAY
52145: PUSH
52146: LD_INT 1
52148: ARRAY
52149: PUSH
52150: LD_EXP 120
52154: PUSH
52155: LD_VAR 0 2
52159: ARRAY
52160: PUSH
52161: LD_INT 1
52163: ARRAY
52164: PUSH
52165: LD_INT 2
52167: ARRAY
52168: PUSH
52169: LD_EXP 120
52173: PUSH
52174: LD_VAR 0 2
52178: ARRAY
52179: PUSH
52180: LD_INT 1
52182: ARRAY
52183: PUSH
52184: LD_INT 3
52186: ARRAY
52187: PUSH
52188: LD_EXP 120
52192: PUSH
52193: LD_VAR 0 2
52197: ARRAY
52198: PUSH
52199: LD_INT 1
52201: ARRAY
52202: PUSH
52203: LD_INT 4
52205: ARRAY
52206: PUSH
52207: EMPTY
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: PPUSH
52213: CALL 78751 0 2
52217: AND
52218: IFFALSE 52356
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52220: LD_VAR 0 3
52224: PPUSH
52225: LD_EXP 120
52229: PUSH
52230: LD_VAR 0 2
52234: ARRAY
52235: PUSH
52236: LD_INT 1
52238: ARRAY
52239: PUSH
52240: LD_INT 1
52242: ARRAY
52243: PPUSH
52244: LD_EXP 120
52248: PUSH
52249: LD_VAR 0 2
52253: ARRAY
52254: PUSH
52255: LD_INT 1
52257: ARRAY
52258: PUSH
52259: LD_INT 2
52261: ARRAY
52262: PPUSH
52263: LD_EXP 120
52267: PUSH
52268: LD_VAR 0 2
52272: ARRAY
52273: PUSH
52274: LD_INT 1
52276: ARRAY
52277: PUSH
52278: LD_INT 3
52280: ARRAY
52281: PPUSH
52282: LD_EXP 120
52286: PUSH
52287: LD_VAR 0 2
52291: ARRAY
52292: PUSH
52293: LD_INT 1
52295: ARRAY
52296: PUSH
52297: LD_INT 4
52299: ARRAY
52300: PPUSH
52301: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
52305: LD_ADDR_VAR 0 4
52309: PUSH
52310: LD_EXP 120
52314: PUSH
52315: LD_VAR 0 2
52319: ARRAY
52320: PPUSH
52321: LD_INT 1
52323: PPUSH
52324: CALL_OW 3
52328: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52329: LD_ADDR_EXP 120
52333: PUSH
52334: LD_EXP 120
52338: PPUSH
52339: LD_VAR 0 2
52343: PPUSH
52344: LD_VAR 0 4
52348: PPUSH
52349: CALL_OW 1
52353: ST_TO_ADDR
// break ;
52354: GO 52358
// end ; end ;
52356: GO 52002
52358: POP
52359: POP
// end ;
52360: GO 51934
52362: POP
52363: POP
// end ;
52364: LD_VAR 0 1
52368: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
52369: LD_INT 0
52371: PPUSH
52372: PPUSH
52373: PPUSH
// if not mc_bases then
52374: LD_EXP 99
52378: NOT
52379: IFFALSE 52383
// exit ;
52381: GO 52472
// for i = 1 to mc_bases do
52383: LD_ADDR_VAR 0 2
52387: PUSH
52388: DOUBLE
52389: LD_INT 1
52391: DEC
52392: ST_TO_ADDR
52393: LD_EXP 99
52397: PUSH
52398: FOR_TO
52399: IFFALSE 52470
// begin if mc_attack [ i ] then
52401: LD_EXP 119
52405: PUSH
52406: LD_VAR 0 2
52410: ARRAY
52411: IFFALSE 52468
// begin tmp := mc_attack [ i ] [ 1 ] ;
52413: LD_ADDR_VAR 0 3
52417: PUSH
52418: LD_EXP 119
52422: PUSH
52423: LD_VAR 0 2
52427: ARRAY
52428: PUSH
52429: LD_INT 1
52431: ARRAY
52432: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52433: LD_ADDR_EXP 119
52437: PUSH
52438: LD_EXP 119
52442: PPUSH
52443: LD_VAR 0 2
52447: PPUSH
52448: EMPTY
52449: PPUSH
52450: CALL_OW 1
52454: ST_TO_ADDR
// Attack ( tmp ) ;
52455: LD_VAR 0 3
52459: PPUSH
52460: CALL 128556 0 1
// exit ;
52464: POP
52465: POP
52466: GO 52472
// end ; end ;
52468: GO 52398
52470: POP
52471: POP
// end ;
52472: LD_VAR 0 1
52476: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
52477: LD_INT 0
52479: PPUSH
52480: PPUSH
52481: PPUSH
52482: PPUSH
52483: PPUSH
52484: PPUSH
52485: PPUSH
// if not mc_bases then
52486: LD_EXP 99
52490: NOT
52491: IFFALSE 52495
// exit ;
52493: GO 53352
// for i = 1 to mc_bases do
52495: LD_ADDR_VAR 0 2
52499: PUSH
52500: DOUBLE
52501: LD_INT 1
52503: DEC
52504: ST_TO_ADDR
52505: LD_EXP 99
52509: PUSH
52510: FOR_TO
52511: IFFALSE 53350
// begin if not mc_bases [ i ] then
52513: LD_EXP 99
52517: PUSH
52518: LD_VAR 0 2
52522: ARRAY
52523: NOT
52524: IFFALSE 52528
// continue ;
52526: GO 52510
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
52528: LD_ADDR_VAR 0 7
52532: PUSH
52533: LD_EXP 99
52537: PUSH
52538: LD_VAR 0 2
52542: ARRAY
52543: PUSH
52544: LD_INT 1
52546: ARRAY
52547: PPUSH
52548: CALL 69036 0 1
52552: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
52553: LD_ADDR_EXP 122
52557: PUSH
52558: LD_EXP 122
52562: PPUSH
52563: LD_VAR 0 2
52567: PPUSH
52568: LD_EXP 99
52572: PUSH
52573: LD_VAR 0 2
52577: ARRAY
52578: PUSH
52579: LD_INT 1
52581: ARRAY
52582: PPUSH
52583: CALL_OW 255
52587: PPUSH
52588: LD_EXP 124
52592: PUSH
52593: LD_VAR 0 2
52597: ARRAY
52598: PPUSH
52599: CALL 69001 0 2
52603: PPUSH
52604: CALL_OW 1
52608: ST_TO_ADDR
// if not mc_scan [ i ] then
52609: LD_EXP 122
52613: PUSH
52614: LD_VAR 0 2
52618: ARRAY
52619: NOT
52620: IFFALSE 52798
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52622: LD_ADDR_EXP 142
52626: PUSH
52627: LD_EXP 142
52631: PPUSH
52632: LD_VAR 0 2
52636: PPUSH
52637: LD_INT 0
52639: PPUSH
52640: CALL_OW 1
52644: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52645: LD_ADDR_VAR 0 4
52649: PUSH
52650: LD_EXP 99
52654: PUSH
52655: LD_VAR 0 2
52659: ARRAY
52660: PPUSH
52661: LD_INT 2
52663: PUSH
52664: LD_INT 25
52666: PUSH
52667: LD_INT 5
52669: PUSH
52670: EMPTY
52671: LIST
52672: LIST
52673: PUSH
52674: LD_INT 25
52676: PUSH
52677: LD_INT 8
52679: PUSH
52680: EMPTY
52681: LIST
52682: LIST
52683: PUSH
52684: LD_INT 25
52686: PUSH
52687: LD_INT 9
52689: PUSH
52690: EMPTY
52691: LIST
52692: LIST
52693: PUSH
52694: EMPTY
52695: LIST
52696: LIST
52697: LIST
52698: LIST
52699: PPUSH
52700: CALL_OW 72
52704: ST_TO_ADDR
// if not tmp then
52705: LD_VAR 0 4
52709: NOT
52710: IFFALSE 52714
// continue ;
52712: GO 52510
// for j in tmp do
52714: LD_ADDR_VAR 0 3
52718: PUSH
52719: LD_VAR 0 4
52723: PUSH
52724: FOR_IN
52725: IFFALSE 52796
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
52727: LD_VAR 0 3
52731: PPUSH
52732: CALL_OW 310
52736: PPUSH
52737: CALL_OW 266
52741: PUSH
52742: LD_INT 5
52744: EQUAL
52745: PUSH
52746: LD_VAR 0 3
52750: PPUSH
52751: CALL_OW 257
52755: PUSH
52756: LD_INT 1
52758: EQUAL
52759: AND
52760: PUSH
52761: LD_VAR 0 3
52765: PPUSH
52766: CALL_OW 459
52770: NOT
52771: AND
52772: PUSH
52773: LD_VAR 0 7
52777: AND
52778: IFFALSE 52794
// ComChangeProfession ( j , class ) ;
52780: LD_VAR 0 3
52784: PPUSH
52785: LD_VAR 0 7
52789: PPUSH
52790: CALL_OW 123
52794: GO 52724
52796: POP
52797: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
52798: LD_EXP 122
52802: PUSH
52803: LD_VAR 0 2
52807: ARRAY
52808: PUSH
52809: LD_EXP 142
52813: PUSH
52814: LD_VAR 0 2
52818: ARRAY
52819: NOT
52820: AND
52821: PUSH
52822: LD_EXP 121
52826: PUSH
52827: LD_VAR 0 2
52831: ARRAY
52832: NOT
52833: AND
52834: PUSH
52835: LD_EXP 99
52839: PUSH
52840: LD_VAR 0 2
52844: ARRAY
52845: PPUSH
52846: LD_INT 50
52848: PUSH
52849: EMPTY
52850: LIST
52851: PUSH
52852: LD_INT 2
52854: PUSH
52855: LD_INT 30
52857: PUSH
52858: LD_INT 32
52860: PUSH
52861: EMPTY
52862: LIST
52863: LIST
52864: PUSH
52865: LD_INT 30
52867: PUSH
52868: LD_INT 33
52870: PUSH
52871: EMPTY
52872: LIST
52873: LIST
52874: PUSH
52875: LD_INT 30
52877: PUSH
52878: LD_INT 4
52880: PUSH
52881: EMPTY
52882: LIST
52883: LIST
52884: PUSH
52885: LD_INT 30
52887: PUSH
52888: LD_INT 5
52890: PUSH
52891: EMPTY
52892: LIST
52893: LIST
52894: PUSH
52895: EMPTY
52896: LIST
52897: LIST
52898: LIST
52899: LIST
52900: LIST
52901: PUSH
52902: EMPTY
52903: LIST
52904: LIST
52905: PPUSH
52906: CALL_OW 72
52910: PUSH
52911: LD_INT 4
52913: LESS
52914: PUSH
52915: LD_EXP 99
52919: PUSH
52920: LD_VAR 0 2
52924: ARRAY
52925: PPUSH
52926: LD_INT 3
52928: PUSH
52929: LD_INT 24
52931: PUSH
52932: LD_INT 1000
52934: PUSH
52935: EMPTY
52936: LIST
52937: LIST
52938: PUSH
52939: EMPTY
52940: LIST
52941: LIST
52942: PUSH
52943: LD_INT 2
52945: PUSH
52946: LD_INT 30
52948: PUSH
52949: LD_INT 0
52951: PUSH
52952: EMPTY
52953: LIST
52954: LIST
52955: PUSH
52956: LD_INT 30
52958: PUSH
52959: LD_INT 1
52961: PUSH
52962: EMPTY
52963: LIST
52964: LIST
52965: PUSH
52966: EMPTY
52967: LIST
52968: LIST
52969: LIST
52970: PUSH
52971: EMPTY
52972: LIST
52973: LIST
52974: PPUSH
52975: CALL_OW 72
52979: OR
52980: AND
52981: IFFALSE 53232
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
52983: LD_ADDR_EXP 142
52987: PUSH
52988: LD_EXP 142
52992: PPUSH
52993: LD_VAR 0 2
52997: PPUSH
52998: LD_INT 1
53000: PPUSH
53001: CALL_OW 1
53005: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53006: LD_ADDR_VAR 0 4
53010: PUSH
53011: LD_EXP 99
53015: PUSH
53016: LD_VAR 0 2
53020: ARRAY
53021: PPUSH
53022: LD_INT 2
53024: PUSH
53025: LD_INT 25
53027: PUSH
53028: LD_INT 1
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: PUSH
53035: LD_INT 25
53037: PUSH
53038: LD_INT 5
53040: PUSH
53041: EMPTY
53042: LIST
53043: LIST
53044: PUSH
53045: LD_INT 25
53047: PUSH
53048: LD_INT 8
53050: PUSH
53051: EMPTY
53052: LIST
53053: LIST
53054: PUSH
53055: LD_INT 25
53057: PUSH
53058: LD_INT 9
53060: PUSH
53061: EMPTY
53062: LIST
53063: LIST
53064: PUSH
53065: EMPTY
53066: LIST
53067: LIST
53068: LIST
53069: LIST
53070: LIST
53071: PPUSH
53072: CALL_OW 72
53076: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53077: LD_ADDR_VAR 0 4
53081: PUSH
53082: LD_VAR 0 4
53086: PUSH
53087: LD_VAR 0 4
53091: PPUSH
53092: LD_INT 18
53094: PPUSH
53095: CALL 102273 0 2
53099: DIFF
53100: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53101: LD_VAR 0 4
53105: NOT
53106: PUSH
53107: LD_EXP 99
53111: PUSH
53112: LD_VAR 0 2
53116: ARRAY
53117: PPUSH
53118: LD_INT 2
53120: PUSH
53121: LD_INT 30
53123: PUSH
53124: LD_INT 4
53126: PUSH
53127: EMPTY
53128: LIST
53129: LIST
53130: PUSH
53131: LD_INT 30
53133: PUSH
53134: LD_INT 5
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: LIST
53145: PPUSH
53146: CALL_OW 72
53150: NOT
53151: AND
53152: IFFALSE 53214
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53154: LD_ADDR_VAR 0 4
53158: PUSH
53159: LD_EXP 99
53163: PUSH
53164: LD_VAR 0 2
53168: ARRAY
53169: PPUSH
53170: LD_INT 2
53172: PUSH
53173: LD_INT 25
53175: PUSH
53176: LD_INT 2
53178: PUSH
53179: EMPTY
53180: LIST
53181: LIST
53182: PUSH
53183: LD_INT 25
53185: PUSH
53186: LD_INT 3
53188: PUSH
53189: EMPTY
53190: LIST
53191: LIST
53192: PUSH
53193: LD_INT 25
53195: PUSH
53196: LD_INT 4
53198: PUSH
53199: EMPTY
53200: LIST
53201: LIST
53202: PUSH
53203: EMPTY
53204: LIST
53205: LIST
53206: LIST
53207: LIST
53208: PPUSH
53209: CALL_OW 72
53213: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53214: LD_VAR 0 2
53218: PPUSH
53219: LD_VAR 0 4
53223: PPUSH
53224: CALL 133265 0 2
// exit ;
53228: POP
53229: POP
53230: GO 53352
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53232: LD_EXP 122
53236: PUSH
53237: LD_VAR 0 2
53241: ARRAY
53242: PUSH
53243: LD_EXP 142
53247: PUSH
53248: LD_VAR 0 2
53252: ARRAY
53253: NOT
53254: AND
53255: PUSH
53256: LD_EXP 121
53260: PUSH
53261: LD_VAR 0 2
53265: ARRAY
53266: AND
53267: IFFALSE 53348
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53269: LD_ADDR_EXP 142
53273: PUSH
53274: LD_EXP 142
53278: PPUSH
53279: LD_VAR 0 2
53283: PPUSH
53284: LD_INT 1
53286: PPUSH
53287: CALL_OW 1
53291: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
53292: LD_ADDR_VAR 0 4
53296: PUSH
53297: LD_EXP 121
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53308: LD_ADDR_EXP 121
53312: PUSH
53313: LD_EXP 121
53317: PPUSH
53318: LD_VAR 0 2
53322: PPUSH
53323: EMPTY
53324: PPUSH
53325: CALL_OW 1
53329: ST_TO_ADDR
// Defend ( i , tmp ) ;
53330: LD_VAR 0 2
53334: PPUSH
53335: LD_VAR 0 4
53339: PPUSH
53340: CALL 133861 0 2
// exit ;
53344: POP
53345: POP
53346: GO 53352
// end ; end ;
53348: GO 52510
53350: POP
53351: POP
// end ;
53352: LD_VAR 0 1
53356: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
53357: LD_INT 0
53359: PPUSH
53360: PPUSH
53361: PPUSH
53362: PPUSH
53363: PPUSH
53364: PPUSH
53365: PPUSH
53366: PPUSH
53367: PPUSH
53368: PPUSH
53369: PPUSH
// if not mc_bases then
53370: LD_EXP 99
53374: NOT
53375: IFFALSE 53379
// exit ;
53377: GO 54466
// for i = 1 to mc_bases do
53379: LD_ADDR_VAR 0 2
53383: PUSH
53384: DOUBLE
53385: LD_INT 1
53387: DEC
53388: ST_TO_ADDR
53389: LD_EXP 99
53393: PUSH
53394: FOR_TO
53395: IFFALSE 54464
// begin tmp := mc_lab [ i ] ;
53397: LD_ADDR_VAR 0 6
53401: PUSH
53402: LD_EXP 132
53406: PUSH
53407: LD_VAR 0 2
53411: ARRAY
53412: ST_TO_ADDR
// if not tmp then
53413: LD_VAR 0 6
53417: NOT
53418: IFFALSE 53422
// continue ;
53420: GO 53394
// idle_lab := 0 ;
53422: LD_ADDR_VAR 0 11
53426: PUSH
53427: LD_INT 0
53429: ST_TO_ADDR
// for j in tmp do
53430: LD_ADDR_VAR 0 3
53434: PUSH
53435: LD_VAR 0 6
53439: PUSH
53440: FOR_IN
53441: IFFALSE 54460
// begin researching := false ;
53443: LD_ADDR_VAR 0 10
53447: PUSH
53448: LD_INT 0
53450: ST_TO_ADDR
// side := GetSide ( j ) ;
53451: LD_ADDR_VAR 0 4
53455: PUSH
53456: LD_VAR 0 3
53460: PPUSH
53461: CALL_OW 255
53465: ST_TO_ADDR
// if not mc_tech [ side ] then
53466: LD_EXP 126
53470: PUSH
53471: LD_VAR 0 4
53475: ARRAY
53476: NOT
53477: IFFALSE 53481
// continue ;
53479: GO 53440
// if BuildingStatus ( j ) = bs_idle then
53481: LD_VAR 0 3
53485: PPUSH
53486: CALL_OW 461
53490: PUSH
53491: LD_INT 2
53493: EQUAL
53494: IFFALSE 53682
// begin if idle_lab and UnitsInside ( j ) < 6 then
53496: LD_VAR 0 11
53500: PUSH
53501: LD_VAR 0 3
53505: PPUSH
53506: CALL_OW 313
53510: PUSH
53511: LD_INT 6
53513: LESS
53514: AND
53515: IFFALSE 53586
// begin tmp2 := UnitsInside ( idle_lab ) ;
53517: LD_ADDR_VAR 0 9
53521: PUSH
53522: LD_VAR 0 11
53526: PPUSH
53527: CALL_OW 313
53531: ST_TO_ADDR
// if tmp2 then
53532: LD_VAR 0 9
53536: IFFALSE 53578
// for x in tmp2 do
53538: LD_ADDR_VAR 0 7
53542: PUSH
53543: LD_VAR 0 9
53547: PUSH
53548: FOR_IN
53549: IFFALSE 53576
// begin ComExitBuilding ( x ) ;
53551: LD_VAR 0 7
53555: PPUSH
53556: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53560: LD_VAR 0 7
53564: PPUSH
53565: LD_VAR 0 3
53569: PPUSH
53570: CALL_OW 180
// end ;
53574: GO 53548
53576: POP
53577: POP
// idle_lab := 0 ;
53578: LD_ADDR_VAR 0 11
53582: PUSH
53583: LD_INT 0
53585: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
53586: LD_ADDR_VAR 0 5
53590: PUSH
53591: LD_EXP 126
53595: PUSH
53596: LD_VAR 0 4
53600: ARRAY
53601: PUSH
53602: FOR_IN
53603: IFFALSE 53663
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
53605: LD_VAR 0 3
53609: PPUSH
53610: LD_VAR 0 5
53614: PPUSH
53615: CALL_OW 430
53619: PUSH
53620: LD_VAR 0 4
53624: PPUSH
53625: LD_VAR 0 5
53629: PPUSH
53630: CALL 68106 0 2
53634: AND
53635: IFFALSE 53661
// begin researching := true ;
53637: LD_ADDR_VAR 0 10
53641: PUSH
53642: LD_INT 1
53644: ST_TO_ADDR
// ComResearch ( j , t ) ;
53645: LD_VAR 0 3
53649: PPUSH
53650: LD_VAR 0 5
53654: PPUSH
53655: CALL_OW 124
// break ;
53659: GO 53663
// end ;
53661: GO 53602
53663: POP
53664: POP
// if not researching then
53665: LD_VAR 0 10
53669: NOT
53670: IFFALSE 53682
// idle_lab := j ;
53672: LD_ADDR_VAR 0 11
53676: PUSH
53677: LD_VAR 0 3
53681: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
53682: LD_VAR 0 3
53686: PPUSH
53687: CALL_OW 461
53691: PUSH
53692: LD_INT 10
53694: EQUAL
53695: IFFALSE 54283
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
53697: LD_EXP 128
53701: PUSH
53702: LD_VAR 0 2
53706: ARRAY
53707: NOT
53708: PUSH
53709: LD_EXP 129
53713: PUSH
53714: LD_VAR 0 2
53718: ARRAY
53719: NOT
53720: AND
53721: PUSH
53722: LD_EXP 126
53726: PUSH
53727: LD_VAR 0 4
53731: ARRAY
53732: PUSH
53733: LD_INT 1
53735: GREATER
53736: AND
53737: IFFALSE 53868
// begin ComCancel ( j ) ;
53739: LD_VAR 0 3
53743: PPUSH
53744: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
53748: LD_ADDR_EXP 126
53752: PUSH
53753: LD_EXP 126
53757: PPUSH
53758: LD_VAR 0 4
53762: PPUSH
53763: LD_EXP 126
53767: PUSH
53768: LD_VAR 0 4
53772: ARRAY
53773: PPUSH
53774: LD_EXP 126
53778: PUSH
53779: LD_VAR 0 4
53783: ARRAY
53784: PUSH
53785: LD_INT 1
53787: MINUS
53788: PPUSH
53789: LD_EXP 126
53793: PUSH
53794: LD_VAR 0 4
53798: ARRAY
53799: PPUSH
53800: LD_INT 0
53802: PPUSH
53803: CALL 71805 0 4
53807: PPUSH
53808: CALL_OW 1
53812: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
53813: LD_ADDR_EXP 126
53817: PUSH
53818: LD_EXP 126
53822: PPUSH
53823: LD_VAR 0 4
53827: PPUSH
53828: LD_EXP 126
53832: PUSH
53833: LD_VAR 0 4
53837: ARRAY
53838: PPUSH
53839: LD_EXP 126
53843: PUSH
53844: LD_VAR 0 4
53848: ARRAY
53849: PPUSH
53850: LD_INT 1
53852: PPUSH
53853: LD_INT 0
53855: PPUSH
53856: CALL 71805 0 4
53860: PPUSH
53861: CALL_OW 1
53865: ST_TO_ADDR
// continue ;
53866: GO 53440
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
53868: LD_EXP 128
53872: PUSH
53873: LD_VAR 0 2
53877: ARRAY
53878: PUSH
53879: LD_EXP 129
53883: PUSH
53884: LD_VAR 0 2
53888: ARRAY
53889: NOT
53890: AND
53891: IFFALSE 54018
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
53893: LD_ADDR_EXP 129
53897: PUSH
53898: LD_EXP 129
53902: PPUSH
53903: LD_VAR 0 2
53907: PUSH
53908: LD_EXP 129
53912: PUSH
53913: LD_VAR 0 2
53917: ARRAY
53918: PUSH
53919: LD_INT 1
53921: PLUS
53922: PUSH
53923: EMPTY
53924: LIST
53925: LIST
53926: PPUSH
53927: LD_EXP 128
53931: PUSH
53932: LD_VAR 0 2
53936: ARRAY
53937: PUSH
53938: LD_INT 1
53940: ARRAY
53941: PPUSH
53942: CALL 72387 0 3
53946: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
53947: LD_EXP 128
53951: PUSH
53952: LD_VAR 0 2
53956: ARRAY
53957: PUSH
53958: LD_INT 1
53960: ARRAY
53961: PPUSH
53962: LD_INT 112
53964: PPUSH
53965: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
53969: LD_ADDR_VAR 0 9
53973: PUSH
53974: LD_EXP 128
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: PPUSH
53985: LD_INT 1
53987: PPUSH
53988: CALL_OW 3
53992: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
53993: LD_ADDR_EXP 128
53997: PUSH
53998: LD_EXP 128
54002: PPUSH
54003: LD_VAR 0 2
54007: PPUSH
54008: LD_VAR 0 9
54012: PPUSH
54013: CALL_OW 1
54017: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
54018: LD_EXP 128
54022: PUSH
54023: LD_VAR 0 2
54027: ARRAY
54028: PUSH
54029: LD_EXP 129
54033: PUSH
54034: LD_VAR 0 2
54038: ARRAY
54039: AND
54040: PUSH
54041: LD_EXP 129
54045: PUSH
54046: LD_VAR 0 2
54050: ARRAY
54051: PUSH
54052: LD_INT 1
54054: ARRAY
54055: PPUSH
54056: CALL_OW 310
54060: NOT
54061: AND
54062: PUSH
54063: LD_VAR 0 3
54067: PPUSH
54068: CALL_OW 313
54072: PUSH
54073: LD_INT 6
54075: EQUAL
54076: AND
54077: IFFALSE 54133
// begin tmp2 := UnitsInside ( j ) ;
54079: LD_ADDR_VAR 0 9
54083: PUSH
54084: LD_VAR 0 3
54088: PPUSH
54089: CALL_OW 313
54093: ST_TO_ADDR
// if tmp2 = 6 then
54094: LD_VAR 0 9
54098: PUSH
54099: LD_INT 6
54101: EQUAL
54102: IFFALSE 54133
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54104: LD_VAR 0 9
54108: PUSH
54109: LD_INT 1
54111: ARRAY
54112: PPUSH
54113: LD_INT 112
54115: PPUSH
54116: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54120: LD_VAR 0 9
54124: PUSH
54125: LD_INT 1
54127: ARRAY
54128: PPUSH
54129: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54133: LD_EXP 129
54137: PUSH
54138: LD_VAR 0 2
54142: ARRAY
54143: PUSH
54144: LD_EXP 129
54148: PUSH
54149: LD_VAR 0 2
54153: ARRAY
54154: PUSH
54155: LD_INT 1
54157: ARRAY
54158: PPUSH
54159: CALL_OW 314
54163: NOT
54164: AND
54165: PUSH
54166: LD_EXP 129
54170: PUSH
54171: LD_VAR 0 2
54175: ARRAY
54176: PUSH
54177: LD_INT 1
54179: ARRAY
54180: PPUSH
54181: CALL_OW 310
54185: NOT
54186: AND
54187: IFFALSE 54213
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54189: LD_EXP 129
54193: PUSH
54194: LD_VAR 0 2
54198: ARRAY
54199: PUSH
54200: LD_INT 1
54202: ARRAY
54203: PPUSH
54204: LD_VAR 0 3
54208: PPUSH
54209: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54213: LD_EXP 129
54217: PUSH
54218: LD_VAR 0 2
54222: ARRAY
54223: PUSH
54224: LD_INT 1
54226: ARRAY
54227: PPUSH
54228: CALL_OW 310
54232: PUSH
54233: LD_EXP 129
54237: PUSH
54238: LD_VAR 0 2
54242: ARRAY
54243: PUSH
54244: LD_INT 1
54246: ARRAY
54247: PPUSH
54248: CALL_OW 310
54252: PPUSH
54253: CALL_OW 461
54257: PUSH
54258: LD_INT 3
54260: NONEQUAL
54261: AND
54262: IFFALSE 54283
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54264: LD_EXP 129
54268: PUSH
54269: LD_VAR 0 2
54273: ARRAY
54274: PUSH
54275: LD_INT 1
54277: ARRAY
54278: PPUSH
54279: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54283: LD_VAR 0 3
54287: PPUSH
54288: CALL_OW 461
54292: PUSH
54293: LD_INT 6
54295: EQUAL
54296: PUSH
54297: LD_VAR 0 6
54301: PUSH
54302: LD_INT 1
54304: GREATER
54305: AND
54306: IFFALSE 54458
// begin sci := [ ] ;
54308: LD_ADDR_VAR 0 8
54312: PUSH
54313: EMPTY
54314: ST_TO_ADDR
// for x in ( tmp diff j ) do
54315: LD_ADDR_VAR 0 7
54319: PUSH
54320: LD_VAR 0 6
54324: PUSH
54325: LD_VAR 0 3
54329: DIFF
54330: PUSH
54331: FOR_IN
54332: IFFALSE 54384
// begin if sci = 6 then
54334: LD_VAR 0 8
54338: PUSH
54339: LD_INT 6
54341: EQUAL
54342: IFFALSE 54346
// break ;
54344: GO 54384
// if BuildingStatus ( x ) = bs_idle then
54346: LD_VAR 0 7
54350: PPUSH
54351: CALL_OW 461
54355: PUSH
54356: LD_INT 2
54358: EQUAL
54359: IFFALSE 54382
// sci := sci ^ UnitsInside ( x ) ;
54361: LD_ADDR_VAR 0 8
54365: PUSH
54366: LD_VAR 0 8
54370: PUSH
54371: LD_VAR 0 7
54375: PPUSH
54376: CALL_OW 313
54380: ADD
54381: ST_TO_ADDR
// end ;
54382: GO 54331
54384: POP
54385: POP
// if not sci then
54386: LD_VAR 0 8
54390: NOT
54391: IFFALSE 54395
// continue ;
54393: GO 53440
// for x in sci do
54395: LD_ADDR_VAR 0 7
54399: PUSH
54400: LD_VAR 0 8
54404: PUSH
54405: FOR_IN
54406: IFFALSE 54456
// if IsInUnit ( x ) and not HasTask ( x ) then
54408: LD_VAR 0 7
54412: PPUSH
54413: CALL_OW 310
54417: PUSH
54418: LD_VAR 0 7
54422: PPUSH
54423: CALL_OW 314
54427: NOT
54428: AND
54429: IFFALSE 54454
// begin ComExitBuilding ( x ) ;
54431: LD_VAR 0 7
54435: PPUSH
54436: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54440: LD_VAR 0 7
54444: PPUSH
54445: LD_VAR 0 3
54449: PPUSH
54450: CALL_OW 180
// end ;
54454: GO 54405
54456: POP
54457: POP
// end ; end ;
54458: GO 53440
54460: POP
54461: POP
// end ;
54462: GO 53394
54464: POP
54465: POP
// end ;
54466: LD_VAR 0 1
54470: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
54471: LD_INT 0
54473: PPUSH
54474: PPUSH
// if not mc_bases then
54475: LD_EXP 99
54479: NOT
54480: IFFALSE 54484
// exit ;
54482: GO 54565
// for i = 1 to mc_bases do
54484: LD_ADDR_VAR 0 2
54488: PUSH
54489: DOUBLE
54490: LD_INT 1
54492: DEC
54493: ST_TO_ADDR
54494: LD_EXP 99
54498: PUSH
54499: FOR_TO
54500: IFFALSE 54563
// if mc_mines [ i ] and mc_miners [ i ] then
54502: LD_EXP 112
54506: PUSH
54507: LD_VAR 0 2
54511: ARRAY
54512: PUSH
54513: LD_EXP 113
54517: PUSH
54518: LD_VAR 0 2
54522: ARRAY
54523: AND
54524: IFFALSE 54561
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
54526: LD_EXP 113
54530: PUSH
54531: LD_VAR 0 2
54535: ARRAY
54536: PUSH
54537: LD_INT 1
54539: ARRAY
54540: PPUSH
54541: CALL_OW 255
54545: PPUSH
54546: LD_EXP 112
54550: PUSH
54551: LD_VAR 0 2
54555: ARRAY
54556: PPUSH
54557: CALL 69189 0 2
54561: GO 54499
54563: POP
54564: POP
// end ;
54565: LD_VAR 0 1
54569: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
54570: LD_INT 0
54572: PPUSH
54573: PPUSH
54574: PPUSH
54575: PPUSH
54576: PPUSH
54577: PPUSH
54578: PPUSH
54579: PPUSH
// if not mc_bases or not mc_parking then
54580: LD_EXP 99
54584: NOT
54585: PUSH
54586: LD_EXP 123
54590: NOT
54591: OR
54592: IFFALSE 54596
// exit ;
54594: GO 55334
// for i = 1 to mc_bases do
54596: LD_ADDR_VAR 0 2
54600: PUSH
54601: DOUBLE
54602: LD_INT 1
54604: DEC
54605: ST_TO_ADDR
54606: LD_EXP 99
54610: PUSH
54611: FOR_TO
54612: IFFALSE 55332
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
54614: LD_EXP 99
54618: PUSH
54619: LD_VAR 0 2
54623: ARRAY
54624: NOT
54625: PUSH
54626: LD_EXP 123
54630: PUSH
54631: LD_VAR 0 2
54635: ARRAY
54636: NOT
54637: OR
54638: IFFALSE 54642
// continue ;
54640: GO 54611
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
54642: LD_ADDR_VAR 0 5
54646: PUSH
54647: LD_EXP 99
54651: PUSH
54652: LD_VAR 0 2
54656: ARRAY
54657: PUSH
54658: LD_INT 1
54660: ARRAY
54661: PPUSH
54662: CALL_OW 255
54666: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54667: LD_ADDR_VAR 0 6
54671: PUSH
54672: LD_EXP 99
54676: PUSH
54677: LD_VAR 0 2
54681: ARRAY
54682: PPUSH
54683: LD_INT 30
54685: PUSH
54686: LD_INT 3
54688: PUSH
54689: EMPTY
54690: LIST
54691: LIST
54692: PPUSH
54693: CALL_OW 72
54697: ST_TO_ADDR
// if not fac then
54698: LD_VAR 0 6
54702: NOT
54703: IFFALSE 54754
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54705: LD_ADDR_VAR 0 6
54709: PUSH
54710: LD_EXP 99
54714: PUSH
54715: LD_VAR 0 2
54719: ARRAY
54720: PPUSH
54721: LD_INT 2
54723: PUSH
54724: LD_INT 30
54726: PUSH
54727: LD_INT 0
54729: PUSH
54730: EMPTY
54731: LIST
54732: LIST
54733: PUSH
54734: LD_INT 30
54736: PUSH
54737: LD_INT 1
54739: PUSH
54740: EMPTY
54741: LIST
54742: LIST
54743: PUSH
54744: EMPTY
54745: LIST
54746: LIST
54747: LIST
54748: PPUSH
54749: CALL_OW 72
54753: ST_TO_ADDR
// if not fac then
54754: LD_VAR 0 6
54758: NOT
54759: IFFALSE 54763
// continue ;
54761: GO 54611
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54763: LD_ADDR_VAR 0 7
54767: PUSH
54768: LD_EXP 123
54772: PUSH
54773: LD_VAR 0 2
54777: ARRAY
54778: PPUSH
54779: LD_INT 22
54781: PUSH
54782: LD_VAR 0 5
54786: PUSH
54787: EMPTY
54788: LIST
54789: LIST
54790: PUSH
54791: LD_INT 21
54793: PUSH
54794: LD_INT 2
54796: PUSH
54797: EMPTY
54798: LIST
54799: LIST
54800: PUSH
54801: LD_INT 3
54803: PUSH
54804: LD_INT 60
54806: PUSH
54807: EMPTY
54808: LIST
54809: PUSH
54810: EMPTY
54811: LIST
54812: LIST
54813: PUSH
54814: LD_INT 3
54816: PUSH
54817: LD_INT 24
54819: PUSH
54820: LD_INT 1000
54822: PUSH
54823: EMPTY
54824: LIST
54825: LIST
54826: PUSH
54827: EMPTY
54828: LIST
54829: LIST
54830: PUSH
54831: EMPTY
54832: LIST
54833: LIST
54834: LIST
54835: LIST
54836: PPUSH
54837: CALL_OW 70
54841: ST_TO_ADDR
// for j in fac do
54842: LD_ADDR_VAR 0 3
54846: PUSH
54847: LD_VAR 0 6
54851: PUSH
54852: FOR_IN
54853: IFFALSE 54948
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54855: LD_ADDR_VAR 0 7
54859: PUSH
54860: LD_VAR 0 7
54864: PUSH
54865: LD_INT 22
54867: PUSH
54868: LD_VAR 0 5
54872: PUSH
54873: EMPTY
54874: LIST
54875: LIST
54876: PUSH
54877: LD_INT 91
54879: PUSH
54880: LD_VAR 0 3
54884: PUSH
54885: LD_INT 15
54887: PUSH
54888: EMPTY
54889: LIST
54890: LIST
54891: LIST
54892: PUSH
54893: LD_INT 21
54895: PUSH
54896: LD_INT 2
54898: PUSH
54899: EMPTY
54900: LIST
54901: LIST
54902: PUSH
54903: LD_INT 3
54905: PUSH
54906: LD_INT 60
54908: PUSH
54909: EMPTY
54910: LIST
54911: PUSH
54912: EMPTY
54913: LIST
54914: LIST
54915: PUSH
54916: LD_INT 3
54918: PUSH
54919: LD_INT 24
54921: PUSH
54922: LD_INT 1000
54924: PUSH
54925: EMPTY
54926: LIST
54927: LIST
54928: PUSH
54929: EMPTY
54930: LIST
54931: LIST
54932: PUSH
54933: EMPTY
54934: LIST
54935: LIST
54936: LIST
54937: LIST
54938: LIST
54939: PPUSH
54940: CALL_OW 69
54944: UNION
54945: ST_TO_ADDR
54946: GO 54852
54948: POP
54949: POP
// if not vehs then
54950: LD_VAR 0 7
54954: NOT
54955: IFFALSE 54981
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54957: LD_ADDR_EXP 111
54961: PUSH
54962: LD_EXP 111
54966: PPUSH
54967: LD_VAR 0 2
54971: PPUSH
54972: EMPTY
54973: PPUSH
54974: CALL_OW 1
54978: ST_TO_ADDR
// continue ;
54979: GO 54611
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54981: LD_ADDR_VAR 0 8
54985: PUSH
54986: LD_EXP 99
54990: PUSH
54991: LD_VAR 0 2
54995: ARRAY
54996: PPUSH
54997: LD_INT 30
54999: PUSH
55000: LD_INT 3
55002: PUSH
55003: EMPTY
55004: LIST
55005: LIST
55006: PPUSH
55007: CALL_OW 72
55011: ST_TO_ADDR
// if tmp then
55012: LD_VAR 0 8
55016: IFFALSE 55119
// begin for j in tmp do
55018: LD_ADDR_VAR 0 3
55022: PUSH
55023: LD_VAR 0 8
55027: PUSH
55028: FOR_IN
55029: IFFALSE 55117
// for k in UnitsInside ( j ) do
55031: LD_ADDR_VAR 0 4
55035: PUSH
55036: LD_VAR 0 3
55040: PPUSH
55041: CALL_OW 313
55045: PUSH
55046: FOR_IN
55047: IFFALSE 55113
// if k then
55049: LD_VAR 0 4
55053: IFFALSE 55111
// if not k in mc_repair_vehicle [ i ] then
55055: LD_VAR 0 4
55059: PUSH
55060: LD_EXP 111
55064: PUSH
55065: LD_VAR 0 2
55069: ARRAY
55070: IN
55071: NOT
55072: IFFALSE 55111
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55074: LD_ADDR_EXP 111
55078: PUSH
55079: LD_EXP 111
55083: PPUSH
55084: LD_VAR 0 2
55088: PPUSH
55089: LD_EXP 111
55093: PUSH
55094: LD_VAR 0 2
55098: ARRAY
55099: PUSH
55100: LD_VAR 0 4
55104: UNION
55105: PPUSH
55106: CALL_OW 1
55110: ST_TO_ADDR
55111: GO 55046
55113: POP
55114: POP
55115: GO 55028
55117: POP
55118: POP
// end ; if not mc_repair_vehicle [ i ] then
55119: LD_EXP 111
55123: PUSH
55124: LD_VAR 0 2
55128: ARRAY
55129: NOT
55130: IFFALSE 55134
// continue ;
55132: GO 54611
// for j in mc_repair_vehicle [ i ] do
55134: LD_ADDR_VAR 0 3
55138: PUSH
55139: LD_EXP 111
55143: PUSH
55144: LD_VAR 0 2
55148: ARRAY
55149: PUSH
55150: FOR_IN
55151: IFFALSE 55328
// begin if GetClass ( j ) <> 3 then
55153: LD_VAR 0 3
55157: PPUSH
55158: CALL_OW 257
55162: PUSH
55163: LD_INT 3
55165: NONEQUAL
55166: IFFALSE 55207
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55168: LD_ADDR_EXP 111
55172: PUSH
55173: LD_EXP 111
55177: PPUSH
55178: LD_VAR 0 2
55182: PPUSH
55183: LD_EXP 111
55187: PUSH
55188: LD_VAR 0 2
55192: ARRAY
55193: PUSH
55194: LD_VAR 0 3
55198: DIFF
55199: PPUSH
55200: CALL_OW 1
55204: ST_TO_ADDR
// continue ;
55205: GO 55150
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55207: LD_VAR 0 3
55211: PPUSH
55212: CALL_OW 311
55216: NOT
55217: PUSH
55218: LD_VAR 0 3
55222: PUSH
55223: LD_EXP 102
55227: PUSH
55228: LD_VAR 0 2
55232: ARRAY
55233: PUSH
55234: LD_INT 1
55236: ARRAY
55237: IN
55238: NOT
55239: AND
55240: PUSH
55241: LD_VAR 0 3
55245: PUSH
55246: LD_EXP 102
55250: PUSH
55251: LD_VAR 0 2
55255: ARRAY
55256: PUSH
55257: LD_INT 2
55259: ARRAY
55260: IN
55261: NOT
55262: AND
55263: IFFALSE 55326
// begin if IsInUnit ( j ) then
55265: LD_VAR 0 3
55269: PPUSH
55270: CALL_OW 310
55274: IFFALSE 55287
// ComExitBuilding ( j ) else
55276: LD_VAR 0 3
55280: PPUSH
55281: CALL_OW 122
55285: GO 55326
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55287: LD_VAR 0 3
55291: PPUSH
55292: LD_VAR 0 7
55296: PUSH
55297: LD_INT 1
55299: ARRAY
55300: PPUSH
55301: CALL 106764 0 2
55305: NOT
55306: IFFALSE 55326
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
55308: LD_VAR 0 3
55312: PPUSH
55313: LD_VAR 0 7
55317: PUSH
55318: LD_INT 1
55320: ARRAY
55321: PPUSH
55322: CALL_OW 129
// end ; end ;
55326: GO 55150
55328: POP
55329: POP
// end ;
55330: GO 54611
55332: POP
55333: POP
// end ;
55334: LD_VAR 0 1
55338: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
55339: LD_INT 0
55341: PPUSH
55342: PPUSH
55343: PPUSH
55344: PPUSH
55345: PPUSH
55346: PPUSH
55347: PPUSH
55348: PPUSH
55349: PPUSH
55350: PPUSH
55351: PPUSH
// if not mc_bases then
55352: LD_EXP 99
55356: NOT
55357: IFFALSE 55361
// exit ;
55359: GO 56163
// for i = 1 to mc_bases do
55361: LD_ADDR_VAR 0 2
55365: PUSH
55366: DOUBLE
55367: LD_INT 1
55369: DEC
55370: ST_TO_ADDR
55371: LD_EXP 99
55375: PUSH
55376: FOR_TO
55377: IFFALSE 56161
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
55379: LD_EXP 127
55383: PUSH
55384: LD_VAR 0 2
55388: ARRAY
55389: NOT
55390: PUSH
55391: LD_EXP 102
55395: PUSH
55396: LD_VAR 0 2
55400: ARRAY
55401: PUSH
55402: LD_INT 1
55404: ARRAY
55405: OR
55406: PUSH
55407: LD_EXP 102
55411: PUSH
55412: LD_VAR 0 2
55416: ARRAY
55417: PUSH
55418: LD_INT 2
55420: ARRAY
55421: OR
55422: PUSH
55423: LD_EXP 125
55427: PUSH
55428: LD_VAR 0 2
55432: ARRAY
55433: PPUSH
55434: LD_INT 1
55436: PPUSH
55437: CALL_OW 325
55441: NOT
55442: OR
55443: PUSH
55444: LD_EXP 122
55448: PUSH
55449: LD_VAR 0 2
55453: ARRAY
55454: OR
55455: IFFALSE 55459
// continue ;
55457: GO 55376
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
55459: LD_ADDR_VAR 0 8
55463: PUSH
55464: LD_EXP 99
55468: PUSH
55469: LD_VAR 0 2
55473: ARRAY
55474: PPUSH
55475: LD_INT 25
55477: PUSH
55478: LD_INT 4
55480: PUSH
55481: EMPTY
55482: LIST
55483: LIST
55484: PUSH
55485: LD_INT 50
55487: PUSH
55488: EMPTY
55489: LIST
55490: PUSH
55491: LD_INT 3
55493: PUSH
55494: LD_INT 60
55496: PUSH
55497: EMPTY
55498: LIST
55499: PUSH
55500: EMPTY
55501: LIST
55502: LIST
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: PPUSH
55509: CALL_OW 72
55513: PUSH
55514: LD_EXP 103
55518: PUSH
55519: LD_VAR 0 2
55523: ARRAY
55524: DIFF
55525: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55526: LD_ADDR_VAR 0 9
55530: PUSH
55531: LD_EXP 99
55535: PUSH
55536: LD_VAR 0 2
55540: ARRAY
55541: PPUSH
55542: LD_INT 2
55544: PUSH
55545: LD_INT 30
55547: PUSH
55548: LD_INT 0
55550: PUSH
55551: EMPTY
55552: LIST
55553: LIST
55554: PUSH
55555: LD_INT 30
55557: PUSH
55558: LD_INT 1
55560: PUSH
55561: EMPTY
55562: LIST
55563: LIST
55564: PUSH
55565: EMPTY
55566: LIST
55567: LIST
55568: LIST
55569: PPUSH
55570: CALL_OW 72
55574: ST_TO_ADDR
// if not tmp or not dep then
55575: LD_VAR 0 8
55579: NOT
55580: PUSH
55581: LD_VAR 0 9
55585: NOT
55586: OR
55587: IFFALSE 55591
// continue ;
55589: GO 55376
// side := GetSide ( tmp [ 1 ] ) ;
55591: LD_ADDR_VAR 0 11
55595: PUSH
55596: LD_VAR 0 8
55600: PUSH
55601: LD_INT 1
55603: ARRAY
55604: PPUSH
55605: CALL_OW 255
55609: ST_TO_ADDR
// dep := dep [ 1 ] ;
55610: LD_ADDR_VAR 0 9
55614: PUSH
55615: LD_VAR 0 9
55619: PUSH
55620: LD_INT 1
55622: ARRAY
55623: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
55624: LD_ADDR_VAR 0 7
55628: PUSH
55629: LD_EXP 127
55633: PUSH
55634: LD_VAR 0 2
55638: ARRAY
55639: PPUSH
55640: LD_INT 22
55642: PUSH
55643: LD_INT 0
55645: PUSH
55646: EMPTY
55647: LIST
55648: LIST
55649: PUSH
55650: LD_INT 25
55652: PUSH
55653: LD_INT 12
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: PUSH
55660: EMPTY
55661: LIST
55662: LIST
55663: PPUSH
55664: CALL_OW 70
55668: PUSH
55669: LD_INT 22
55671: PUSH
55672: LD_INT 0
55674: PUSH
55675: EMPTY
55676: LIST
55677: LIST
55678: PUSH
55679: LD_INT 25
55681: PUSH
55682: LD_INT 12
55684: PUSH
55685: EMPTY
55686: LIST
55687: LIST
55688: PUSH
55689: LD_INT 91
55691: PUSH
55692: LD_VAR 0 9
55696: PUSH
55697: LD_INT 20
55699: PUSH
55700: EMPTY
55701: LIST
55702: LIST
55703: LIST
55704: PUSH
55705: EMPTY
55706: LIST
55707: LIST
55708: LIST
55709: PPUSH
55710: CALL_OW 69
55714: UNION
55715: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
55716: LD_ADDR_VAR 0 10
55720: PUSH
55721: LD_EXP 127
55725: PUSH
55726: LD_VAR 0 2
55730: ARRAY
55731: PPUSH
55732: LD_INT 81
55734: PUSH
55735: LD_VAR 0 11
55739: PUSH
55740: EMPTY
55741: LIST
55742: LIST
55743: PPUSH
55744: CALL_OW 70
55748: ST_TO_ADDR
// if not apes or danger_at_area then
55749: LD_VAR 0 7
55753: NOT
55754: PUSH
55755: LD_VAR 0 10
55759: OR
55760: IFFALSE 55810
// begin if mc_taming [ i ] then
55762: LD_EXP 130
55766: PUSH
55767: LD_VAR 0 2
55771: ARRAY
55772: IFFALSE 55808
// begin MC_Reset ( i , 121 ) ;
55774: LD_VAR 0 2
55778: PPUSH
55779: LD_INT 121
55781: PPUSH
55782: CALL 40747 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55786: LD_ADDR_EXP 130
55790: PUSH
55791: LD_EXP 130
55795: PPUSH
55796: LD_VAR 0 2
55800: PPUSH
55801: EMPTY
55802: PPUSH
55803: CALL_OW 1
55807: ST_TO_ADDR
// end ; continue ;
55808: GO 55376
// end ; for j in tmp do
55810: LD_ADDR_VAR 0 3
55814: PUSH
55815: LD_VAR 0 8
55819: PUSH
55820: FOR_IN
55821: IFFALSE 56157
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
55823: LD_VAR 0 3
55827: PUSH
55828: LD_EXP 130
55832: PUSH
55833: LD_VAR 0 2
55837: ARRAY
55838: IN
55839: NOT
55840: PUSH
55841: LD_EXP 130
55845: PUSH
55846: LD_VAR 0 2
55850: ARRAY
55851: PUSH
55852: LD_INT 3
55854: LESS
55855: AND
55856: IFFALSE 55914
// begin SetTag ( j , 121 ) ;
55858: LD_VAR 0 3
55862: PPUSH
55863: LD_INT 121
55865: PPUSH
55866: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
55870: LD_ADDR_EXP 130
55874: PUSH
55875: LD_EXP 130
55879: PPUSH
55880: LD_VAR 0 2
55884: PUSH
55885: LD_EXP 130
55889: PUSH
55890: LD_VAR 0 2
55894: ARRAY
55895: PUSH
55896: LD_INT 1
55898: PLUS
55899: PUSH
55900: EMPTY
55901: LIST
55902: LIST
55903: PPUSH
55904: LD_VAR 0 3
55908: PPUSH
55909: CALL 72387 0 3
55913: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
55914: LD_VAR 0 3
55918: PUSH
55919: LD_EXP 130
55923: PUSH
55924: LD_VAR 0 2
55928: ARRAY
55929: IN
55930: IFFALSE 56155
// begin if GetClass ( j ) <> 4 then
55932: LD_VAR 0 3
55936: PPUSH
55937: CALL_OW 257
55941: PUSH
55942: LD_INT 4
55944: NONEQUAL
55945: IFFALSE 55998
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
55947: LD_ADDR_EXP 130
55951: PUSH
55952: LD_EXP 130
55956: PPUSH
55957: LD_VAR 0 2
55961: PPUSH
55962: LD_EXP 130
55966: PUSH
55967: LD_VAR 0 2
55971: ARRAY
55972: PUSH
55973: LD_VAR 0 3
55977: DIFF
55978: PPUSH
55979: CALL_OW 1
55983: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55984: LD_VAR 0 3
55988: PPUSH
55989: LD_INT 0
55991: PPUSH
55992: CALL_OW 109
// continue ;
55996: GO 55820
// end ; if IsInUnit ( j ) then
55998: LD_VAR 0 3
56002: PPUSH
56003: CALL_OW 310
56007: IFFALSE 56018
// ComExitBuilding ( j ) ;
56009: LD_VAR 0 3
56013: PPUSH
56014: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
56018: LD_ADDR_VAR 0 6
56022: PUSH
56023: LD_VAR 0 7
56027: PPUSH
56028: LD_VAR 0 3
56032: PPUSH
56033: CALL_OW 74
56037: ST_TO_ADDR
// if not ape then
56038: LD_VAR 0 6
56042: NOT
56043: IFFALSE 56047
// break ;
56045: GO 56157
// x := GetX ( ape ) ;
56047: LD_ADDR_VAR 0 4
56051: PUSH
56052: LD_VAR 0 6
56056: PPUSH
56057: CALL_OW 250
56061: ST_TO_ADDR
// y := GetY ( ape ) ;
56062: LD_ADDR_VAR 0 5
56066: PUSH
56067: LD_VAR 0 6
56071: PPUSH
56072: CALL_OW 251
56076: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56077: LD_VAR 0 4
56081: PPUSH
56082: LD_VAR 0 5
56086: PPUSH
56087: CALL_OW 488
56091: NOT
56092: PUSH
56093: LD_VAR 0 11
56097: PPUSH
56098: LD_VAR 0 4
56102: PPUSH
56103: LD_VAR 0 5
56107: PPUSH
56108: LD_INT 20
56110: PPUSH
56111: CALL 73283 0 4
56115: PUSH
56116: LD_INT 4
56118: ARRAY
56119: OR
56120: IFFALSE 56124
// break ;
56122: GO 56157
// if not HasTask ( j ) then
56124: LD_VAR 0 3
56128: PPUSH
56129: CALL_OW 314
56133: NOT
56134: IFFALSE 56155
// ComTameXY ( j , x , y ) ;
56136: LD_VAR 0 3
56140: PPUSH
56141: LD_VAR 0 4
56145: PPUSH
56146: LD_VAR 0 5
56150: PPUSH
56151: CALL_OW 131
// end ; end ;
56155: GO 55820
56157: POP
56158: POP
// end ;
56159: GO 55376
56161: POP
56162: POP
// end ;
56163: LD_VAR 0 1
56167: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56168: LD_INT 0
56170: PPUSH
56171: PPUSH
56172: PPUSH
56173: PPUSH
56174: PPUSH
56175: PPUSH
56176: PPUSH
56177: PPUSH
// if not mc_bases then
56178: LD_EXP 99
56182: NOT
56183: IFFALSE 56187
// exit ;
56185: GO 56813
// for i = 1 to mc_bases do
56187: LD_ADDR_VAR 0 2
56191: PUSH
56192: DOUBLE
56193: LD_INT 1
56195: DEC
56196: ST_TO_ADDR
56197: LD_EXP 99
56201: PUSH
56202: FOR_TO
56203: IFFALSE 56811
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56205: LD_EXP 128
56209: PUSH
56210: LD_VAR 0 2
56214: ARRAY
56215: NOT
56216: PUSH
56217: LD_EXP 128
56221: PUSH
56222: LD_VAR 0 2
56226: ARRAY
56227: PPUSH
56228: LD_INT 25
56230: PUSH
56231: LD_INT 12
56233: PUSH
56234: EMPTY
56235: LIST
56236: LIST
56237: PPUSH
56238: CALL_OW 72
56242: NOT
56243: OR
56244: IFFALSE 56248
// continue ;
56246: GO 56202
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56248: LD_ADDR_VAR 0 5
56252: PUSH
56253: LD_EXP 128
56257: PUSH
56258: LD_VAR 0 2
56262: ARRAY
56263: PUSH
56264: LD_INT 1
56266: ARRAY
56267: PPUSH
56268: CALL_OW 255
56272: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56273: LD_VAR 0 5
56277: PPUSH
56278: LD_INT 2
56280: PPUSH
56281: CALL_OW 325
56285: IFFALSE 56538
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56287: LD_ADDR_VAR 0 4
56291: PUSH
56292: LD_EXP 128
56296: PUSH
56297: LD_VAR 0 2
56301: ARRAY
56302: PPUSH
56303: LD_INT 25
56305: PUSH
56306: LD_INT 16
56308: PUSH
56309: EMPTY
56310: LIST
56311: LIST
56312: PPUSH
56313: CALL_OW 72
56317: ST_TO_ADDR
// if tmp < 6 then
56318: LD_VAR 0 4
56322: PUSH
56323: LD_INT 6
56325: LESS
56326: IFFALSE 56538
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56328: LD_ADDR_VAR 0 6
56332: PUSH
56333: LD_EXP 99
56337: PUSH
56338: LD_VAR 0 2
56342: ARRAY
56343: PPUSH
56344: LD_INT 2
56346: PUSH
56347: LD_INT 30
56349: PUSH
56350: LD_INT 0
56352: PUSH
56353: EMPTY
56354: LIST
56355: LIST
56356: PUSH
56357: LD_INT 30
56359: PUSH
56360: LD_INT 1
56362: PUSH
56363: EMPTY
56364: LIST
56365: LIST
56366: PUSH
56367: EMPTY
56368: LIST
56369: LIST
56370: LIST
56371: PPUSH
56372: CALL_OW 72
56376: ST_TO_ADDR
// if depot then
56377: LD_VAR 0 6
56381: IFFALSE 56538
// begin selected := 0 ;
56383: LD_ADDR_VAR 0 7
56387: PUSH
56388: LD_INT 0
56390: ST_TO_ADDR
// for j in depot do
56391: LD_ADDR_VAR 0 3
56395: PUSH
56396: LD_VAR 0 6
56400: PUSH
56401: FOR_IN
56402: IFFALSE 56433
// begin if UnitsInside ( j ) < 6 then
56404: LD_VAR 0 3
56408: PPUSH
56409: CALL_OW 313
56413: PUSH
56414: LD_INT 6
56416: LESS
56417: IFFALSE 56431
// begin selected := j ;
56419: LD_ADDR_VAR 0 7
56423: PUSH
56424: LD_VAR 0 3
56428: ST_TO_ADDR
// break ;
56429: GO 56433
// end ; end ;
56431: GO 56401
56433: POP
56434: POP
// if selected then
56435: LD_VAR 0 7
56439: IFFALSE 56538
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56441: LD_ADDR_VAR 0 3
56445: PUSH
56446: LD_EXP 128
56450: PUSH
56451: LD_VAR 0 2
56455: ARRAY
56456: PPUSH
56457: LD_INT 25
56459: PUSH
56460: LD_INT 12
56462: PUSH
56463: EMPTY
56464: LIST
56465: LIST
56466: PPUSH
56467: CALL_OW 72
56471: PUSH
56472: FOR_IN
56473: IFFALSE 56536
// if not HasTask ( j ) then
56475: LD_VAR 0 3
56479: PPUSH
56480: CALL_OW 314
56484: NOT
56485: IFFALSE 56534
// begin if not IsInUnit ( j ) then
56487: LD_VAR 0 3
56491: PPUSH
56492: CALL_OW 310
56496: NOT
56497: IFFALSE 56513
// ComEnterUnit ( j , selected ) ;
56499: LD_VAR 0 3
56503: PPUSH
56504: LD_VAR 0 7
56508: PPUSH
56509: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
56513: LD_VAR 0 3
56517: PPUSH
56518: LD_INT 16
56520: PPUSH
56521: CALL_OW 183
// AddComExitBuilding ( j ) ;
56525: LD_VAR 0 3
56529: PPUSH
56530: CALL_OW 182
// end ;
56534: GO 56472
56536: POP
56537: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
56538: LD_VAR 0 5
56542: PPUSH
56543: LD_INT 11
56545: PPUSH
56546: CALL_OW 325
56550: IFFALSE 56809
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56552: LD_ADDR_VAR 0 4
56556: PUSH
56557: LD_EXP 128
56561: PUSH
56562: LD_VAR 0 2
56566: ARRAY
56567: PPUSH
56568: LD_INT 25
56570: PUSH
56571: LD_INT 16
56573: PUSH
56574: EMPTY
56575: LIST
56576: LIST
56577: PPUSH
56578: CALL_OW 72
56582: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
56583: LD_VAR 0 4
56587: PUSH
56588: LD_INT 6
56590: GREATEREQUAL
56591: PUSH
56592: LD_VAR 0 5
56596: PPUSH
56597: LD_INT 2
56599: PPUSH
56600: CALL_OW 325
56604: NOT
56605: OR
56606: IFFALSE 56809
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56608: LD_ADDR_VAR 0 8
56612: PUSH
56613: LD_EXP 99
56617: PUSH
56618: LD_VAR 0 2
56622: ARRAY
56623: PPUSH
56624: LD_INT 2
56626: PUSH
56627: LD_INT 30
56629: PUSH
56630: LD_INT 4
56632: PUSH
56633: EMPTY
56634: LIST
56635: LIST
56636: PUSH
56637: LD_INT 30
56639: PUSH
56640: LD_INT 5
56642: PUSH
56643: EMPTY
56644: LIST
56645: LIST
56646: PUSH
56647: EMPTY
56648: LIST
56649: LIST
56650: LIST
56651: PPUSH
56652: CALL_OW 72
56656: ST_TO_ADDR
// if barracks then
56657: LD_VAR 0 8
56661: IFFALSE 56809
// begin selected := 0 ;
56663: LD_ADDR_VAR 0 7
56667: PUSH
56668: LD_INT 0
56670: ST_TO_ADDR
// for j in barracks do
56671: LD_ADDR_VAR 0 3
56675: PUSH
56676: LD_VAR 0 8
56680: PUSH
56681: FOR_IN
56682: IFFALSE 56713
// begin if UnitsInside ( j ) < 6 then
56684: LD_VAR 0 3
56688: PPUSH
56689: CALL_OW 313
56693: PUSH
56694: LD_INT 6
56696: LESS
56697: IFFALSE 56711
// begin selected := j ;
56699: LD_ADDR_VAR 0 7
56703: PUSH
56704: LD_VAR 0 3
56708: ST_TO_ADDR
// break ;
56709: GO 56713
// end ; end ;
56711: GO 56681
56713: POP
56714: POP
// if selected then
56715: LD_VAR 0 7
56719: IFFALSE 56809
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56721: LD_ADDR_VAR 0 3
56725: PUSH
56726: LD_EXP 128
56730: PUSH
56731: LD_VAR 0 2
56735: ARRAY
56736: PPUSH
56737: LD_INT 25
56739: PUSH
56740: LD_INT 12
56742: PUSH
56743: EMPTY
56744: LIST
56745: LIST
56746: PPUSH
56747: CALL_OW 72
56751: PUSH
56752: FOR_IN
56753: IFFALSE 56807
// if not IsInUnit ( j ) and not HasTask ( j ) then
56755: LD_VAR 0 3
56759: PPUSH
56760: CALL_OW 310
56764: NOT
56765: PUSH
56766: LD_VAR 0 3
56770: PPUSH
56771: CALL_OW 314
56775: NOT
56776: AND
56777: IFFALSE 56805
// begin ComEnterUnit ( j , selected ) ;
56779: LD_VAR 0 3
56783: PPUSH
56784: LD_VAR 0 7
56788: PPUSH
56789: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
56793: LD_VAR 0 3
56797: PPUSH
56798: LD_INT 15
56800: PPUSH
56801: CALL_OW 183
// end ;
56805: GO 56752
56807: POP
56808: POP
// end ; end ; end ; end ; end ;
56809: GO 56202
56811: POP
56812: POP
// end ;
56813: LD_VAR 0 1
56817: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
56818: LD_INT 0
56820: PPUSH
56821: PPUSH
56822: PPUSH
56823: PPUSH
// if not mc_bases then
56824: LD_EXP 99
56828: NOT
56829: IFFALSE 56833
// exit ;
56831: GO 57011
// for i = 1 to mc_bases do
56833: LD_ADDR_VAR 0 2
56837: PUSH
56838: DOUBLE
56839: LD_INT 1
56841: DEC
56842: ST_TO_ADDR
56843: LD_EXP 99
56847: PUSH
56848: FOR_TO
56849: IFFALSE 57009
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
56851: LD_ADDR_VAR 0 4
56855: PUSH
56856: LD_EXP 99
56860: PUSH
56861: LD_VAR 0 2
56865: ARRAY
56866: PPUSH
56867: LD_INT 25
56869: PUSH
56870: LD_INT 9
56872: PUSH
56873: EMPTY
56874: LIST
56875: LIST
56876: PPUSH
56877: CALL_OW 72
56881: ST_TO_ADDR
// if not tmp then
56882: LD_VAR 0 4
56886: NOT
56887: IFFALSE 56891
// continue ;
56889: GO 56848
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
56891: LD_EXP 125
56895: PUSH
56896: LD_VAR 0 2
56900: ARRAY
56901: PPUSH
56902: LD_INT 29
56904: PPUSH
56905: CALL_OW 325
56909: NOT
56910: PUSH
56911: LD_EXP 125
56915: PUSH
56916: LD_VAR 0 2
56920: ARRAY
56921: PPUSH
56922: LD_INT 28
56924: PPUSH
56925: CALL_OW 325
56929: NOT
56930: AND
56931: IFFALSE 56935
// continue ;
56933: GO 56848
// for j in tmp do
56935: LD_ADDR_VAR 0 3
56939: PUSH
56940: LD_VAR 0 4
56944: PUSH
56945: FOR_IN
56946: IFFALSE 57005
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
56948: LD_VAR 0 3
56952: PUSH
56953: LD_EXP 102
56957: PUSH
56958: LD_VAR 0 2
56962: ARRAY
56963: PUSH
56964: LD_INT 1
56966: ARRAY
56967: IN
56968: NOT
56969: PUSH
56970: LD_VAR 0 3
56974: PUSH
56975: LD_EXP 102
56979: PUSH
56980: LD_VAR 0 2
56984: ARRAY
56985: PUSH
56986: LD_INT 2
56988: ARRAY
56989: IN
56990: NOT
56991: AND
56992: IFFALSE 57003
// ComSpaceTimeShoot ( j ) ;
56994: LD_VAR 0 3
56998: PPUSH
56999: CALL 68197 0 1
57003: GO 56945
57005: POP
57006: POP
// end ;
57007: GO 56848
57009: POP
57010: POP
// end ;
57011: LD_VAR 0 1
57015: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
57016: LD_INT 0
57018: PPUSH
57019: PPUSH
57020: PPUSH
57021: PPUSH
57022: PPUSH
57023: PPUSH
57024: PPUSH
57025: PPUSH
57026: PPUSH
// if not mc_bases then
57027: LD_EXP 99
57031: NOT
57032: IFFALSE 57036
// exit ;
57034: GO 57658
// for i = 1 to mc_bases do
57036: LD_ADDR_VAR 0 2
57040: PUSH
57041: DOUBLE
57042: LD_INT 1
57044: DEC
57045: ST_TO_ADDR
57046: LD_EXP 99
57050: PUSH
57051: FOR_TO
57052: IFFALSE 57656
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
57054: LD_EXP 134
57058: PUSH
57059: LD_VAR 0 2
57063: ARRAY
57064: NOT
57065: PUSH
57066: LD_INT 38
57068: PPUSH
57069: LD_EXP 125
57073: PUSH
57074: LD_VAR 0 2
57078: ARRAY
57079: PPUSH
57080: CALL_OW 321
57084: PUSH
57085: LD_INT 2
57087: NONEQUAL
57088: OR
57089: IFFALSE 57093
// continue ;
57091: GO 57051
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57093: LD_ADDR_VAR 0 8
57097: PUSH
57098: LD_EXP 99
57102: PUSH
57103: LD_VAR 0 2
57107: ARRAY
57108: PPUSH
57109: LD_INT 30
57111: PUSH
57112: LD_INT 34
57114: PUSH
57115: EMPTY
57116: LIST
57117: LIST
57118: PPUSH
57119: CALL_OW 72
57123: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57124: LD_ADDR_VAR 0 9
57128: PUSH
57129: LD_EXP 99
57133: PUSH
57134: LD_VAR 0 2
57138: ARRAY
57139: PPUSH
57140: LD_INT 25
57142: PUSH
57143: LD_INT 4
57145: PUSH
57146: EMPTY
57147: LIST
57148: LIST
57149: PPUSH
57150: CALL_OW 72
57154: PPUSH
57155: LD_INT 0
57157: PPUSH
57158: CALL 102273 0 2
57162: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57163: LD_VAR 0 9
57167: NOT
57168: PUSH
57169: LD_VAR 0 8
57173: NOT
57174: OR
57175: PUSH
57176: LD_EXP 99
57180: PUSH
57181: LD_VAR 0 2
57185: ARRAY
57186: PPUSH
57187: LD_INT 124
57189: PPUSH
57190: CALL 102273 0 2
57194: OR
57195: IFFALSE 57199
// continue ;
57197: GO 57051
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57199: LD_EXP 135
57203: PUSH
57204: LD_VAR 0 2
57208: ARRAY
57209: PUSH
57210: LD_EXP 134
57214: PUSH
57215: LD_VAR 0 2
57219: ARRAY
57220: LESS
57221: PUSH
57222: LD_EXP 135
57226: PUSH
57227: LD_VAR 0 2
57231: ARRAY
57232: PUSH
57233: LD_VAR 0 8
57237: LESS
57238: AND
57239: IFFALSE 57654
// begin tmp := sci [ 1 ] ;
57241: LD_ADDR_VAR 0 7
57245: PUSH
57246: LD_VAR 0 9
57250: PUSH
57251: LD_INT 1
57253: ARRAY
57254: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57255: LD_VAR 0 7
57259: PPUSH
57260: LD_INT 124
57262: PPUSH
57263: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57267: LD_ADDR_VAR 0 3
57271: PUSH
57272: DOUBLE
57273: LD_EXP 134
57277: PUSH
57278: LD_VAR 0 2
57282: ARRAY
57283: INC
57284: ST_TO_ADDR
57285: LD_EXP 134
57289: PUSH
57290: LD_VAR 0 2
57294: ARRAY
57295: PUSH
57296: FOR_DOWNTO
57297: IFFALSE 57640
// begin if IsInUnit ( tmp ) then
57299: LD_VAR 0 7
57303: PPUSH
57304: CALL_OW 310
57308: IFFALSE 57319
// ComExitBuilding ( tmp ) ;
57310: LD_VAR 0 7
57314: PPUSH
57315: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
57319: LD_INT 35
57321: PPUSH
57322: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
57326: LD_VAR 0 7
57330: PPUSH
57331: CALL_OW 310
57335: NOT
57336: PUSH
57337: LD_VAR 0 7
57341: PPUSH
57342: CALL_OW 314
57346: NOT
57347: AND
57348: IFFALSE 57319
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
57350: LD_ADDR_VAR 0 6
57354: PUSH
57355: LD_VAR 0 7
57359: PPUSH
57360: CALL_OW 250
57364: PUSH
57365: LD_VAR 0 7
57369: PPUSH
57370: CALL_OW 251
57374: PUSH
57375: EMPTY
57376: LIST
57377: LIST
57378: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
57379: LD_INT 35
57381: PPUSH
57382: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
57386: LD_ADDR_VAR 0 4
57390: PUSH
57391: LD_EXP 134
57395: PUSH
57396: LD_VAR 0 2
57400: ARRAY
57401: PUSH
57402: LD_VAR 0 3
57406: ARRAY
57407: PUSH
57408: LD_INT 1
57410: ARRAY
57411: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
57412: LD_ADDR_VAR 0 5
57416: PUSH
57417: LD_EXP 134
57421: PUSH
57422: LD_VAR 0 2
57426: ARRAY
57427: PUSH
57428: LD_VAR 0 3
57432: ARRAY
57433: PUSH
57434: LD_INT 2
57436: ARRAY
57437: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
57438: LD_VAR 0 7
57442: PPUSH
57443: LD_INT 10
57445: PPUSH
57446: CALL 74984 0 2
57450: PUSH
57451: LD_INT 4
57453: ARRAY
57454: IFFALSE 57492
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
57456: LD_VAR 0 7
57460: PPUSH
57461: LD_VAR 0 6
57465: PUSH
57466: LD_INT 1
57468: ARRAY
57469: PPUSH
57470: LD_VAR 0 6
57474: PUSH
57475: LD_INT 2
57477: ARRAY
57478: PPUSH
57479: CALL_OW 111
// wait ( 0 0$10 ) ;
57483: LD_INT 350
57485: PPUSH
57486: CALL_OW 67
// end else
57490: GO 57518
// begin ComMoveXY ( tmp , x , y ) ;
57492: LD_VAR 0 7
57496: PPUSH
57497: LD_VAR 0 4
57501: PPUSH
57502: LD_VAR 0 5
57506: PPUSH
57507: CALL_OW 111
// wait ( 0 0$3 ) ;
57511: LD_INT 105
57513: PPUSH
57514: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
57518: LD_VAR 0 7
57522: PPUSH
57523: LD_VAR 0 4
57527: PPUSH
57528: LD_VAR 0 5
57532: PPUSH
57533: CALL_OW 307
57537: IFFALSE 57379
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
57539: LD_VAR 0 7
57543: PPUSH
57544: LD_VAR 0 4
57548: PPUSH
57549: LD_VAR 0 5
57553: PPUSH
57554: LD_VAR 0 8
57558: PUSH
57559: LD_VAR 0 3
57563: ARRAY
57564: PPUSH
57565: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
57569: LD_INT 35
57571: PPUSH
57572: CALL_OW 67
// until not HasTask ( tmp ) ;
57576: LD_VAR 0 7
57580: PPUSH
57581: CALL_OW 314
57585: NOT
57586: IFFALSE 57569
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
57588: LD_ADDR_EXP 135
57592: PUSH
57593: LD_EXP 135
57597: PPUSH
57598: LD_VAR 0 2
57602: PUSH
57603: LD_EXP 135
57607: PUSH
57608: LD_VAR 0 2
57612: ARRAY
57613: PUSH
57614: LD_INT 1
57616: PLUS
57617: PUSH
57618: EMPTY
57619: LIST
57620: LIST
57621: PPUSH
57622: LD_VAR 0 8
57626: PUSH
57627: LD_VAR 0 3
57631: ARRAY
57632: PPUSH
57633: CALL 72387 0 3
57637: ST_TO_ADDR
// end ;
57638: GO 57296
57640: POP
57641: POP
// MC_Reset ( i , 124 ) ;
57642: LD_VAR 0 2
57646: PPUSH
57647: LD_INT 124
57649: PPUSH
57650: CALL 40747 0 2
// end ; end ;
57654: GO 57051
57656: POP
57657: POP
// end ;
57658: LD_VAR 0 1
57662: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
57663: LD_INT 0
57665: PPUSH
57666: PPUSH
57667: PPUSH
// if not mc_bases then
57668: LD_EXP 99
57672: NOT
57673: IFFALSE 57677
// exit ;
57675: GO 58283
// for i = 1 to mc_bases do
57677: LD_ADDR_VAR 0 2
57681: PUSH
57682: DOUBLE
57683: LD_INT 1
57685: DEC
57686: ST_TO_ADDR
57687: LD_EXP 99
57691: PUSH
57692: FOR_TO
57693: IFFALSE 58281
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57695: LD_ADDR_VAR 0 3
57699: PUSH
57700: LD_EXP 99
57704: PUSH
57705: LD_VAR 0 2
57709: ARRAY
57710: PPUSH
57711: LD_INT 25
57713: PUSH
57714: LD_INT 4
57716: PUSH
57717: EMPTY
57718: LIST
57719: LIST
57720: PPUSH
57721: CALL_OW 72
57725: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57726: LD_VAR 0 3
57730: NOT
57731: PUSH
57732: LD_EXP 136
57736: PUSH
57737: LD_VAR 0 2
57741: ARRAY
57742: NOT
57743: OR
57744: PUSH
57745: LD_EXP 99
57749: PUSH
57750: LD_VAR 0 2
57754: ARRAY
57755: PPUSH
57756: LD_INT 2
57758: PUSH
57759: LD_INT 30
57761: PUSH
57762: LD_INT 0
57764: PUSH
57765: EMPTY
57766: LIST
57767: LIST
57768: PUSH
57769: LD_INT 30
57771: PUSH
57772: LD_INT 1
57774: PUSH
57775: EMPTY
57776: LIST
57777: LIST
57778: PUSH
57779: EMPTY
57780: LIST
57781: LIST
57782: LIST
57783: PPUSH
57784: CALL_OW 72
57788: NOT
57789: OR
57790: IFFALSE 57840
// begin if mc_deposits_finder [ i ] then
57792: LD_EXP 137
57796: PUSH
57797: LD_VAR 0 2
57801: ARRAY
57802: IFFALSE 57838
// begin MC_Reset ( i , 125 ) ;
57804: LD_VAR 0 2
57808: PPUSH
57809: LD_INT 125
57811: PPUSH
57812: CALL 40747 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57816: LD_ADDR_EXP 137
57820: PUSH
57821: LD_EXP 137
57825: PPUSH
57826: LD_VAR 0 2
57830: PPUSH
57831: EMPTY
57832: PPUSH
57833: CALL_OW 1
57837: ST_TO_ADDR
// end ; continue ;
57838: GO 57692
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
57840: LD_EXP 136
57844: PUSH
57845: LD_VAR 0 2
57849: ARRAY
57850: PUSH
57851: LD_INT 1
57853: ARRAY
57854: PUSH
57855: LD_INT 3
57857: ARRAY
57858: PUSH
57859: LD_INT 1
57861: EQUAL
57862: PUSH
57863: LD_INT 20
57865: PPUSH
57866: LD_EXP 125
57870: PUSH
57871: LD_VAR 0 2
57875: ARRAY
57876: PPUSH
57877: CALL_OW 321
57881: PUSH
57882: LD_INT 2
57884: NONEQUAL
57885: AND
57886: IFFALSE 57936
// begin if mc_deposits_finder [ i ] then
57888: LD_EXP 137
57892: PUSH
57893: LD_VAR 0 2
57897: ARRAY
57898: IFFALSE 57934
// begin MC_Reset ( i , 125 ) ;
57900: LD_VAR 0 2
57904: PPUSH
57905: LD_INT 125
57907: PPUSH
57908: CALL 40747 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57912: LD_ADDR_EXP 137
57916: PUSH
57917: LD_EXP 137
57921: PPUSH
57922: LD_VAR 0 2
57926: PPUSH
57927: EMPTY
57928: PPUSH
57929: CALL_OW 1
57933: ST_TO_ADDR
// end ; continue ;
57934: GO 57692
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
57936: LD_EXP 136
57940: PUSH
57941: LD_VAR 0 2
57945: ARRAY
57946: PUSH
57947: LD_INT 1
57949: ARRAY
57950: PUSH
57951: LD_INT 1
57953: ARRAY
57954: PPUSH
57955: LD_EXP 136
57959: PUSH
57960: LD_VAR 0 2
57964: ARRAY
57965: PUSH
57966: LD_INT 1
57968: ARRAY
57969: PUSH
57970: LD_INT 2
57972: ARRAY
57973: PPUSH
57974: LD_EXP 125
57978: PUSH
57979: LD_VAR 0 2
57983: ARRAY
57984: PPUSH
57985: CALL_OW 440
57989: IFFALSE 58032
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
57991: LD_ADDR_EXP 136
57995: PUSH
57996: LD_EXP 136
58000: PPUSH
58001: LD_VAR 0 2
58005: PPUSH
58006: LD_EXP 136
58010: PUSH
58011: LD_VAR 0 2
58015: ARRAY
58016: PPUSH
58017: LD_INT 1
58019: PPUSH
58020: CALL_OW 3
58024: PPUSH
58025: CALL_OW 1
58029: ST_TO_ADDR
58030: GO 58279
// begin if not mc_deposits_finder [ i ] then
58032: LD_EXP 137
58036: PUSH
58037: LD_VAR 0 2
58041: ARRAY
58042: NOT
58043: IFFALSE 58095
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
58045: LD_ADDR_EXP 137
58049: PUSH
58050: LD_EXP 137
58054: PPUSH
58055: LD_VAR 0 2
58059: PPUSH
58060: LD_VAR 0 3
58064: PUSH
58065: LD_INT 1
58067: ARRAY
58068: PUSH
58069: EMPTY
58070: LIST
58071: PPUSH
58072: CALL_OW 1
58076: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58077: LD_VAR 0 3
58081: PUSH
58082: LD_INT 1
58084: ARRAY
58085: PPUSH
58086: LD_INT 125
58088: PPUSH
58089: CALL_OW 109
// end else
58093: GO 58279
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58095: LD_EXP 137
58099: PUSH
58100: LD_VAR 0 2
58104: ARRAY
58105: PUSH
58106: LD_INT 1
58108: ARRAY
58109: PPUSH
58110: CALL_OW 310
58114: IFFALSE 58137
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58116: LD_EXP 137
58120: PUSH
58121: LD_VAR 0 2
58125: ARRAY
58126: PUSH
58127: LD_INT 1
58129: ARRAY
58130: PPUSH
58131: CALL_OW 122
58135: GO 58279
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58137: LD_EXP 137
58141: PUSH
58142: LD_VAR 0 2
58146: ARRAY
58147: PUSH
58148: LD_INT 1
58150: ARRAY
58151: PPUSH
58152: CALL_OW 314
58156: NOT
58157: PUSH
58158: LD_EXP 137
58162: PUSH
58163: LD_VAR 0 2
58167: ARRAY
58168: PUSH
58169: LD_INT 1
58171: ARRAY
58172: PPUSH
58173: LD_EXP 136
58177: PUSH
58178: LD_VAR 0 2
58182: ARRAY
58183: PUSH
58184: LD_INT 1
58186: ARRAY
58187: PUSH
58188: LD_INT 1
58190: ARRAY
58191: PPUSH
58192: LD_EXP 136
58196: PUSH
58197: LD_VAR 0 2
58201: ARRAY
58202: PUSH
58203: LD_INT 1
58205: ARRAY
58206: PUSH
58207: LD_INT 2
58209: ARRAY
58210: PPUSH
58211: CALL_OW 297
58215: PUSH
58216: LD_INT 6
58218: GREATER
58219: AND
58220: IFFALSE 58279
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58222: LD_EXP 137
58226: PUSH
58227: LD_VAR 0 2
58231: ARRAY
58232: PUSH
58233: LD_INT 1
58235: ARRAY
58236: PPUSH
58237: LD_EXP 136
58241: PUSH
58242: LD_VAR 0 2
58246: ARRAY
58247: PUSH
58248: LD_INT 1
58250: ARRAY
58251: PUSH
58252: LD_INT 1
58254: ARRAY
58255: PPUSH
58256: LD_EXP 136
58260: PUSH
58261: LD_VAR 0 2
58265: ARRAY
58266: PUSH
58267: LD_INT 1
58269: ARRAY
58270: PUSH
58271: LD_INT 2
58273: ARRAY
58274: PPUSH
58275: CALL_OW 111
// end ; end ; end ;
58279: GO 57692
58281: POP
58282: POP
// end ;
58283: LD_VAR 0 1
58287: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58288: LD_INT 0
58290: PPUSH
58291: PPUSH
58292: PPUSH
58293: PPUSH
58294: PPUSH
58295: PPUSH
58296: PPUSH
58297: PPUSH
58298: PPUSH
58299: PPUSH
58300: PPUSH
// if not mc_bases then
58301: LD_EXP 99
58305: NOT
58306: IFFALSE 58310
// exit ;
58308: GO 59250
// for i = 1 to mc_bases do
58310: LD_ADDR_VAR 0 2
58314: PUSH
58315: DOUBLE
58316: LD_INT 1
58318: DEC
58319: ST_TO_ADDR
58320: LD_EXP 99
58324: PUSH
58325: FOR_TO
58326: IFFALSE 59248
// begin if not mc_bases [ i ] or mc_scan [ i ] then
58328: LD_EXP 99
58332: PUSH
58333: LD_VAR 0 2
58337: ARRAY
58338: NOT
58339: PUSH
58340: LD_EXP 122
58344: PUSH
58345: LD_VAR 0 2
58349: ARRAY
58350: OR
58351: IFFALSE 58355
// continue ;
58353: GO 58325
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
58355: LD_ADDR_VAR 0 7
58359: PUSH
58360: LD_EXP 99
58364: PUSH
58365: LD_VAR 0 2
58369: ARRAY
58370: PUSH
58371: LD_INT 1
58373: ARRAY
58374: PPUSH
58375: CALL_OW 248
58379: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
58380: LD_VAR 0 7
58384: PUSH
58385: LD_INT 3
58387: EQUAL
58388: PUSH
58389: LD_EXP 118
58393: PUSH
58394: LD_VAR 0 2
58398: ARRAY
58399: PUSH
58400: LD_EXP 121
58404: PUSH
58405: LD_VAR 0 2
58409: ARRAY
58410: UNION
58411: PPUSH
58412: LD_INT 33
58414: PUSH
58415: LD_INT 2
58417: PUSH
58418: EMPTY
58419: LIST
58420: LIST
58421: PPUSH
58422: CALL_OW 72
58426: NOT
58427: OR
58428: IFFALSE 58432
// continue ;
58430: GO 58325
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
58432: LD_ADDR_VAR 0 9
58436: PUSH
58437: LD_EXP 99
58441: PUSH
58442: LD_VAR 0 2
58446: ARRAY
58447: PPUSH
58448: LD_INT 30
58450: PUSH
58451: LD_INT 36
58453: PUSH
58454: EMPTY
58455: LIST
58456: LIST
58457: PPUSH
58458: CALL_OW 72
58462: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
58463: LD_ADDR_VAR 0 10
58467: PUSH
58468: LD_EXP 118
58472: PUSH
58473: LD_VAR 0 2
58477: ARRAY
58478: PPUSH
58479: LD_INT 34
58481: PUSH
58482: LD_INT 31
58484: PUSH
58485: EMPTY
58486: LIST
58487: LIST
58488: PPUSH
58489: CALL_OW 72
58493: ST_TO_ADDR
// if not cts and not mcts then
58494: LD_VAR 0 9
58498: NOT
58499: PUSH
58500: LD_VAR 0 10
58504: NOT
58505: AND
58506: IFFALSE 58510
// continue ;
58508: GO 58325
// x := cts ;
58510: LD_ADDR_VAR 0 11
58514: PUSH
58515: LD_VAR 0 9
58519: ST_TO_ADDR
// if not x then
58520: LD_VAR 0 11
58524: NOT
58525: IFFALSE 58537
// x := mcts ;
58527: LD_ADDR_VAR 0 11
58531: PUSH
58532: LD_VAR 0 10
58536: ST_TO_ADDR
// if not x then
58537: LD_VAR 0 11
58541: NOT
58542: IFFALSE 58546
// continue ;
58544: GO 58325
// if mc_remote_driver [ i ] then
58546: LD_EXP 139
58550: PUSH
58551: LD_VAR 0 2
58555: ARRAY
58556: IFFALSE 58943
// for j in mc_remote_driver [ i ] do
58558: LD_ADDR_VAR 0 3
58562: PUSH
58563: LD_EXP 139
58567: PUSH
58568: LD_VAR 0 2
58572: ARRAY
58573: PUSH
58574: FOR_IN
58575: IFFALSE 58941
// begin if GetClass ( j ) <> 3 then
58577: LD_VAR 0 3
58581: PPUSH
58582: CALL_OW 257
58586: PUSH
58587: LD_INT 3
58589: NONEQUAL
58590: IFFALSE 58643
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
58592: LD_ADDR_EXP 139
58596: PUSH
58597: LD_EXP 139
58601: PPUSH
58602: LD_VAR 0 2
58606: PPUSH
58607: LD_EXP 139
58611: PUSH
58612: LD_VAR 0 2
58616: ARRAY
58617: PUSH
58618: LD_VAR 0 3
58622: DIFF
58623: PPUSH
58624: CALL_OW 1
58628: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58629: LD_VAR 0 3
58633: PPUSH
58634: LD_INT 0
58636: PPUSH
58637: CALL_OW 109
// continue ;
58641: GO 58574
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
58643: LD_EXP 118
58647: PUSH
58648: LD_VAR 0 2
58652: ARRAY
58653: PPUSH
58654: LD_INT 34
58656: PUSH
58657: LD_INT 31
58659: PUSH
58660: EMPTY
58661: LIST
58662: LIST
58663: PUSH
58664: LD_INT 58
58666: PUSH
58667: EMPTY
58668: LIST
58669: PUSH
58670: EMPTY
58671: LIST
58672: LIST
58673: PPUSH
58674: CALL_OW 72
58678: PUSH
58679: LD_VAR 0 3
58683: PPUSH
58684: CALL 102308 0 1
58688: NOT
58689: AND
58690: IFFALSE 58761
// begin if IsInUnit ( j ) then
58692: LD_VAR 0 3
58696: PPUSH
58697: CALL_OW 310
58701: IFFALSE 58712
// ComExitBuilding ( j ) ;
58703: LD_VAR 0 3
58707: PPUSH
58708: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
58712: LD_VAR 0 3
58716: PPUSH
58717: LD_EXP 118
58721: PUSH
58722: LD_VAR 0 2
58726: ARRAY
58727: PPUSH
58728: LD_INT 34
58730: PUSH
58731: LD_INT 31
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: PUSH
58738: LD_INT 58
58740: PUSH
58741: EMPTY
58742: LIST
58743: PUSH
58744: EMPTY
58745: LIST
58746: LIST
58747: PPUSH
58748: CALL_OW 72
58752: PUSH
58753: LD_INT 1
58755: ARRAY
58756: PPUSH
58757: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
58761: LD_VAR 0 3
58765: PPUSH
58766: CALL_OW 310
58770: NOT
58771: PUSH
58772: LD_VAR 0 3
58776: PPUSH
58777: CALL_OW 310
58781: PPUSH
58782: CALL_OW 266
58786: PUSH
58787: LD_INT 36
58789: NONEQUAL
58790: PUSH
58791: LD_VAR 0 3
58795: PPUSH
58796: CALL 102308 0 1
58800: NOT
58801: AND
58802: OR
58803: IFFALSE 58939
// begin if IsInUnit ( j ) then
58805: LD_VAR 0 3
58809: PPUSH
58810: CALL_OW 310
58814: IFFALSE 58825
// ComExitBuilding ( j ) ;
58816: LD_VAR 0 3
58820: PPUSH
58821: CALL_OW 122
// ct := 0 ;
58825: LD_ADDR_VAR 0 8
58829: PUSH
58830: LD_INT 0
58832: ST_TO_ADDR
// for k in x do
58833: LD_ADDR_VAR 0 4
58837: PUSH
58838: LD_VAR 0 11
58842: PUSH
58843: FOR_IN
58844: IFFALSE 58917
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
58846: LD_VAR 0 4
58850: PPUSH
58851: CALL_OW 264
58855: PUSH
58856: LD_INT 31
58858: EQUAL
58859: PUSH
58860: LD_VAR 0 4
58864: PPUSH
58865: CALL_OW 311
58869: NOT
58870: AND
58871: PUSH
58872: LD_VAR 0 4
58876: PPUSH
58877: CALL_OW 266
58881: PUSH
58882: LD_INT 36
58884: EQUAL
58885: PUSH
58886: LD_VAR 0 4
58890: PPUSH
58891: CALL_OW 313
58895: PUSH
58896: LD_INT 3
58898: LESS
58899: AND
58900: OR
58901: IFFALSE 58915
// begin ct := k ;
58903: LD_ADDR_VAR 0 8
58907: PUSH
58908: LD_VAR 0 4
58912: ST_TO_ADDR
// break ;
58913: GO 58917
// end ;
58915: GO 58843
58917: POP
58918: POP
// if ct then
58919: LD_VAR 0 8
58923: IFFALSE 58939
// ComEnterUnit ( j , ct ) ;
58925: LD_VAR 0 3
58929: PPUSH
58930: LD_VAR 0 8
58934: PPUSH
58935: CALL_OW 120
// end ; end ;
58939: GO 58574
58941: POP
58942: POP
// places := 0 ;
58943: LD_ADDR_VAR 0 5
58947: PUSH
58948: LD_INT 0
58950: ST_TO_ADDR
// for j = 1 to x do
58951: LD_ADDR_VAR 0 3
58955: PUSH
58956: DOUBLE
58957: LD_INT 1
58959: DEC
58960: ST_TO_ADDR
58961: LD_VAR 0 11
58965: PUSH
58966: FOR_TO
58967: IFFALSE 59043
// if GetWeapon ( x [ j ] ) = ar_control_tower then
58969: LD_VAR 0 11
58973: PUSH
58974: LD_VAR 0 3
58978: ARRAY
58979: PPUSH
58980: CALL_OW 264
58984: PUSH
58985: LD_INT 31
58987: EQUAL
58988: IFFALSE 59006
// places := places + 1 else
58990: LD_ADDR_VAR 0 5
58994: PUSH
58995: LD_VAR 0 5
58999: PUSH
59000: LD_INT 1
59002: PLUS
59003: ST_TO_ADDR
59004: GO 59041
// if GetBType ( x [ j ] ) = b_control_tower then
59006: LD_VAR 0 11
59010: PUSH
59011: LD_VAR 0 3
59015: ARRAY
59016: PPUSH
59017: CALL_OW 266
59021: PUSH
59022: LD_INT 36
59024: EQUAL
59025: IFFALSE 59041
// places := places + 3 ;
59027: LD_ADDR_VAR 0 5
59031: PUSH
59032: LD_VAR 0 5
59036: PUSH
59037: LD_INT 3
59039: PLUS
59040: ST_TO_ADDR
59041: GO 58966
59043: POP
59044: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
59045: LD_VAR 0 5
59049: PUSH
59050: LD_INT 0
59052: EQUAL
59053: PUSH
59054: LD_VAR 0 5
59058: PUSH
59059: LD_EXP 139
59063: PUSH
59064: LD_VAR 0 2
59068: ARRAY
59069: LESSEQUAL
59070: OR
59071: IFFALSE 59075
// continue ;
59073: GO 58325
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59075: LD_ADDR_VAR 0 6
59079: PUSH
59080: LD_EXP 99
59084: PUSH
59085: LD_VAR 0 2
59089: ARRAY
59090: PPUSH
59091: LD_INT 25
59093: PUSH
59094: LD_INT 3
59096: PUSH
59097: EMPTY
59098: LIST
59099: LIST
59100: PPUSH
59101: CALL_OW 72
59105: PUSH
59106: LD_EXP 139
59110: PUSH
59111: LD_VAR 0 2
59115: ARRAY
59116: DIFF
59117: PPUSH
59118: LD_INT 3
59120: PPUSH
59121: CALL 103208 0 2
59125: ST_TO_ADDR
// for j in tmp do
59126: LD_ADDR_VAR 0 3
59130: PUSH
59131: LD_VAR 0 6
59135: PUSH
59136: FOR_IN
59137: IFFALSE 59172
// if GetTag ( j ) > 0 then
59139: LD_VAR 0 3
59143: PPUSH
59144: CALL_OW 110
59148: PUSH
59149: LD_INT 0
59151: GREATER
59152: IFFALSE 59170
// tmp := tmp diff j ;
59154: LD_ADDR_VAR 0 6
59158: PUSH
59159: LD_VAR 0 6
59163: PUSH
59164: LD_VAR 0 3
59168: DIFF
59169: ST_TO_ADDR
59170: GO 59136
59172: POP
59173: POP
// if not tmp then
59174: LD_VAR 0 6
59178: NOT
59179: IFFALSE 59183
// continue ;
59181: GO 58325
// if places then
59183: LD_VAR 0 5
59187: IFFALSE 59246
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59189: LD_ADDR_EXP 139
59193: PUSH
59194: LD_EXP 139
59198: PPUSH
59199: LD_VAR 0 2
59203: PPUSH
59204: LD_EXP 139
59208: PUSH
59209: LD_VAR 0 2
59213: ARRAY
59214: PUSH
59215: LD_VAR 0 6
59219: PUSH
59220: LD_INT 1
59222: ARRAY
59223: UNION
59224: PPUSH
59225: CALL_OW 1
59229: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59230: LD_VAR 0 6
59234: PUSH
59235: LD_INT 1
59237: ARRAY
59238: PPUSH
59239: LD_INT 126
59241: PPUSH
59242: CALL_OW 109
// end ; end ;
59246: GO 58325
59248: POP
59249: POP
// end ;
59250: LD_VAR 0 1
59254: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59255: LD_INT 0
59257: PPUSH
59258: PPUSH
59259: PPUSH
59260: PPUSH
59261: PPUSH
59262: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59263: LD_VAR 0 1
59267: NOT
59268: PUSH
59269: LD_VAR 0 2
59273: NOT
59274: OR
59275: PUSH
59276: LD_VAR 0 3
59280: NOT
59281: OR
59282: PUSH
59283: LD_VAR 0 4
59287: PUSH
59288: LD_INT 1
59290: PUSH
59291: LD_INT 2
59293: PUSH
59294: LD_INT 3
59296: PUSH
59297: LD_INT 4
59299: PUSH
59300: LD_INT 5
59302: PUSH
59303: LD_INT 8
59305: PUSH
59306: LD_INT 9
59308: PUSH
59309: LD_INT 15
59311: PUSH
59312: LD_INT 16
59314: PUSH
59315: EMPTY
59316: LIST
59317: LIST
59318: LIST
59319: LIST
59320: LIST
59321: LIST
59322: LIST
59323: LIST
59324: LIST
59325: IN
59326: NOT
59327: OR
59328: IFFALSE 59332
// exit ;
59330: GO 60232
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
59332: LD_ADDR_VAR 0 2
59336: PUSH
59337: LD_VAR 0 2
59341: PPUSH
59342: LD_INT 21
59344: PUSH
59345: LD_INT 3
59347: PUSH
59348: EMPTY
59349: LIST
59350: LIST
59351: PUSH
59352: LD_INT 24
59354: PUSH
59355: LD_INT 250
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: PUSH
59362: EMPTY
59363: LIST
59364: LIST
59365: PPUSH
59366: CALL_OW 72
59370: ST_TO_ADDR
// case class of 1 , 15 :
59371: LD_VAR 0 4
59375: PUSH
59376: LD_INT 1
59378: DOUBLE
59379: EQUAL
59380: IFTRUE 59390
59382: LD_INT 15
59384: DOUBLE
59385: EQUAL
59386: IFTRUE 59390
59388: GO 59475
59390: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
59391: LD_ADDR_VAR 0 8
59395: PUSH
59396: LD_VAR 0 2
59400: PPUSH
59401: LD_INT 2
59403: PUSH
59404: LD_INT 30
59406: PUSH
59407: LD_INT 32
59409: PUSH
59410: EMPTY
59411: LIST
59412: LIST
59413: PUSH
59414: LD_INT 30
59416: PUSH
59417: LD_INT 31
59419: PUSH
59420: EMPTY
59421: LIST
59422: LIST
59423: PUSH
59424: EMPTY
59425: LIST
59426: LIST
59427: LIST
59428: PPUSH
59429: CALL_OW 72
59433: PUSH
59434: LD_VAR 0 2
59438: PPUSH
59439: LD_INT 2
59441: PUSH
59442: LD_INT 30
59444: PUSH
59445: LD_INT 4
59447: PUSH
59448: EMPTY
59449: LIST
59450: LIST
59451: PUSH
59452: LD_INT 30
59454: PUSH
59455: LD_INT 5
59457: PUSH
59458: EMPTY
59459: LIST
59460: LIST
59461: PUSH
59462: EMPTY
59463: LIST
59464: LIST
59465: LIST
59466: PPUSH
59467: CALL_OW 72
59471: ADD
59472: ST_TO_ADDR
59473: GO 59721
59475: LD_INT 2
59477: DOUBLE
59478: EQUAL
59479: IFTRUE 59489
59481: LD_INT 16
59483: DOUBLE
59484: EQUAL
59485: IFTRUE 59489
59487: GO 59535
59489: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
59490: LD_ADDR_VAR 0 8
59494: PUSH
59495: LD_VAR 0 2
59499: PPUSH
59500: LD_INT 2
59502: PUSH
59503: LD_INT 30
59505: PUSH
59506: LD_INT 0
59508: PUSH
59509: EMPTY
59510: LIST
59511: LIST
59512: PUSH
59513: LD_INT 30
59515: PUSH
59516: LD_INT 1
59518: PUSH
59519: EMPTY
59520: LIST
59521: LIST
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: LIST
59527: PPUSH
59528: CALL_OW 72
59532: ST_TO_ADDR
59533: GO 59721
59535: LD_INT 3
59537: DOUBLE
59538: EQUAL
59539: IFTRUE 59543
59541: GO 59589
59543: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
59544: LD_ADDR_VAR 0 8
59548: PUSH
59549: LD_VAR 0 2
59553: PPUSH
59554: LD_INT 2
59556: PUSH
59557: LD_INT 30
59559: PUSH
59560: LD_INT 2
59562: PUSH
59563: EMPTY
59564: LIST
59565: LIST
59566: PUSH
59567: LD_INT 30
59569: PUSH
59570: LD_INT 3
59572: PUSH
59573: EMPTY
59574: LIST
59575: LIST
59576: PUSH
59577: EMPTY
59578: LIST
59579: LIST
59580: LIST
59581: PPUSH
59582: CALL_OW 72
59586: ST_TO_ADDR
59587: GO 59721
59589: LD_INT 4
59591: DOUBLE
59592: EQUAL
59593: IFTRUE 59597
59595: GO 59654
59597: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
59598: LD_ADDR_VAR 0 8
59602: PUSH
59603: LD_VAR 0 2
59607: PPUSH
59608: LD_INT 2
59610: PUSH
59611: LD_INT 30
59613: PUSH
59614: LD_INT 6
59616: PUSH
59617: EMPTY
59618: LIST
59619: LIST
59620: PUSH
59621: LD_INT 30
59623: PUSH
59624: LD_INT 7
59626: PUSH
59627: EMPTY
59628: LIST
59629: LIST
59630: PUSH
59631: LD_INT 30
59633: PUSH
59634: LD_INT 8
59636: PUSH
59637: EMPTY
59638: LIST
59639: LIST
59640: PUSH
59641: EMPTY
59642: LIST
59643: LIST
59644: LIST
59645: LIST
59646: PPUSH
59647: CALL_OW 72
59651: ST_TO_ADDR
59652: GO 59721
59654: LD_INT 5
59656: DOUBLE
59657: EQUAL
59658: IFTRUE 59674
59660: LD_INT 8
59662: DOUBLE
59663: EQUAL
59664: IFTRUE 59674
59666: LD_INT 9
59668: DOUBLE
59669: EQUAL
59670: IFTRUE 59674
59672: GO 59720
59674: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
59675: LD_ADDR_VAR 0 8
59679: PUSH
59680: LD_VAR 0 2
59684: PPUSH
59685: LD_INT 2
59687: PUSH
59688: LD_INT 30
59690: PUSH
59691: LD_INT 4
59693: PUSH
59694: EMPTY
59695: LIST
59696: LIST
59697: PUSH
59698: LD_INT 30
59700: PUSH
59701: LD_INT 5
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: LIST
59712: PPUSH
59713: CALL_OW 72
59717: ST_TO_ADDR
59718: GO 59721
59720: POP
// if not tmp then
59721: LD_VAR 0 8
59725: NOT
59726: IFFALSE 59730
// exit ;
59728: GO 60232
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
59730: LD_VAR 0 4
59734: PUSH
59735: LD_INT 1
59737: PUSH
59738: LD_INT 15
59740: PUSH
59741: EMPTY
59742: LIST
59743: LIST
59744: IN
59745: PUSH
59746: LD_EXP 108
59750: PUSH
59751: LD_VAR 0 1
59755: ARRAY
59756: AND
59757: IFFALSE 59913
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
59759: LD_ADDR_VAR 0 9
59763: PUSH
59764: LD_EXP 108
59768: PUSH
59769: LD_VAR 0 1
59773: ARRAY
59774: PUSH
59775: LD_INT 1
59777: ARRAY
59778: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
59779: LD_VAR 0 9
59783: PUSH
59784: LD_EXP 109
59788: PUSH
59789: LD_VAR 0 1
59793: ARRAY
59794: IN
59795: NOT
59796: IFFALSE 59911
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
59798: LD_ADDR_EXP 109
59802: PUSH
59803: LD_EXP 109
59807: PPUSH
59808: LD_VAR 0 1
59812: PUSH
59813: LD_EXP 109
59817: PUSH
59818: LD_VAR 0 1
59822: ARRAY
59823: PUSH
59824: LD_INT 1
59826: PLUS
59827: PUSH
59828: EMPTY
59829: LIST
59830: LIST
59831: PPUSH
59832: LD_VAR 0 9
59836: PPUSH
59837: CALL 72387 0 3
59841: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
59842: LD_ADDR_EXP 108
59846: PUSH
59847: LD_EXP 108
59851: PPUSH
59852: LD_VAR 0 1
59856: PPUSH
59857: LD_EXP 108
59861: PUSH
59862: LD_VAR 0 1
59866: ARRAY
59867: PUSH
59868: LD_VAR 0 9
59872: DIFF
59873: PPUSH
59874: CALL_OW 1
59878: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
59879: LD_VAR 0 3
59883: PPUSH
59884: LD_EXP 109
59888: PUSH
59889: LD_VAR 0 1
59893: ARRAY
59894: PUSH
59895: LD_EXP 109
59899: PUSH
59900: LD_VAR 0 1
59904: ARRAY
59905: ARRAY
59906: PPUSH
59907: CALL_OW 120
// end ; exit ;
59911: GO 60232
// end ; if tmp > 1 then
59913: LD_VAR 0 8
59917: PUSH
59918: LD_INT 1
59920: GREATER
59921: IFFALSE 60025
// for i = 2 to tmp do
59923: LD_ADDR_VAR 0 6
59927: PUSH
59928: DOUBLE
59929: LD_INT 2
59931: DEC
59932: ST_TO_ADDR
59933: LD_VAR 0 8
59937: PUSH
59938: FOR_TO
59939: IFFALSE 60023
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
59941: LD_VAR 0 8
59945: PUSH
59946: LD_VAR 0 6
59950: ARRAY
59951: PPUSH
59952: CALL_OW 461
59956: PUSH
59957: LD_INT 6
59959: EQUAL
59960: IFFALSE 60021
// begin x := tmp [ i ] ;
59962: LD_ADDR_VAR 0 9
59966: PUSH
59967: LD_VAR 0 8
59971: PUSH
59972: LD_VAR 0 6
59976: ARRAY
59977: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
59978: LD_ADDR_VAR 0 8
59982: PUSH
59983: LD_VAR 0 8
59987: PPUSH
59988: LD_VAR 0 6
59992: PPUSH
59993: CALL_OW 3
59997: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
59998: LD_ADDR_VAR 0 8
60002: PUSH
60003: LD_VAR 0 8
60007: PPUSH
60008: LD_INT 1
60010: PPUSH
60011: LD_VAR 0 9
60015: PPUSH
60016: CALL_OW 2
60020: ST_TO_ADDR
// end ;
60021: GO 59938
60023: POP
60024: POP
// for i in tmp do
60025: LD_ADDR_VAR 0 6
60029: PUSH
60030: LD_VAR 0 8
60034: PUSH
60035: FOR_IN
60036: IFFALSE 60105
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
60038: LD_VAR 0 6
60042: PPUSH
60043: CALL_OW 313
60047: PUSH
60048: LD_INT 6
60050: LESS
60051: PUSH
60052: LD_VAR 0 6
60056: PPUSH
60057: CALL_OW 266
60061: PUSH
60062: LD_INT 31
60064: PUSH
60065: LD_INT 32
60067: PUSH
60068: EMPTY
60069: LIST
60070: LIST
60071: IN
60072: NOT
60073: AND
60074: PUSH
60075: LD_VAR 0 6
60079: PPUSH
60080: CALL_OW 313
60084: PUSH
60085: LD_INT 0
60087: EQUAL
60088: OR
60089: IFFALSE 60103
// begin j := i ;
60091: LD_ADDR_VAR 0 7
60095: PUSH
60096: LD_VAR 0 6
60100: ST_TO_ADDR
// break ;
60101: GO 60105
// end ; end ;
60103: GO 60035
60105: POP
60106: POP
// if j then
60107: LD_VAR 0 7
60111: IFFALSE 60129
// ComEnterUnit ( unit , j ) else
60113: LD_VAR 0 3
60117: PPUSH
60118: LD_VAR 0 7
60122: PPUSH
60123: CALL_OW 120
60127: GO 60232
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60129: LD_ADDR_VAR 0 10
60133: PUSH
60134: LD_VAR 0 2
60138: PPUSH
60139: LD_INT 2
60141: PUSH
60142: LD_INT 30
60144: PUSH
60145: LD_INT 0
60147: PUSH
60148: EMPTY
60149: LIST
60150: LIST
60151: PUSH
60152: LD_INT 30
60154: PUSH
60155: LD_INT 1
60157: PUSH
60158: EMPTY
60159: LIST
60160: LIST
60161: PUSH
60162: EMPTY
60163: LIST
60164: LIST
60165: LIST
60166: PPUSH
60167: CALL_OW 72
60171: ST_TO_ADDR
// if depot then
60172: LD_VAR 0 10
60176: IFFALSE 60232
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60178: LD_ADDR_VAR 0 10
60182: PUSH
60183: LD_VAR 0 10
60187: PPUSH
60188: LD_VAR 0 3
60192: PPUSH
60193: CALL_OW 74
60197: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60198: LD_VAR 0 3
60202: PPUSH
60203: LD_VAR 0 10
60207: PPUSH
60208: CALL_OW 296
60212: PUSH
60213: LD_INT 10
60215: GREATER
60216: IFFALSE 60232
// ComStandNearbyBuilding ( unit , depot ) ;
60218: LD_VAR 0 3
60222: PPUSH
60223: LD_VAR 0 10
60227: PPUSH
60228: CALL 68814 0 2
// end ; end ; end ;
60232: LD_VAR 0 5
60236: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60237: LD_INT 0
60239: PPUSH
60240: PPUSH
60241: PPUSH
60242: PPUSH
// if not mc_bases then
60243: LD_EXP 99
60247: NOT
60248: IFFALSE 60252
// exit ;
60250: GO 60491
// for i = 1 to mc_bases do
60252: LD_ADDR_VAR 0 2
60256: PUSH
60257: DOUBLE
60258: LD_INT 1
60260: DEC
60261: ST_TO_ADDR
60262: LD_EXP 99
60266: PUSH
60267: FOR_TO
60268: IFFALSE 60489
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60270: LD_ADDR_VAR 0 4
60274: PUSH
60275: LD_EXP 99
60279: PUSH
60280: LD_VAR 0 2
60284: ARRAY
60285: PPUSH
60286: LD_INT 21
60288: PUSH
60289: LD_INT 1
60291: PUSH
60292: EMPTY
60293: LIST
60294: LIST
60295: PPUSH
60296: CALL_OW 72
60300: PUSH
60301: LD_EXP 128
60305: PUSH
60306: LD_VAR 0 2
60310: ARRAY
60311: UNION
60312: ST_TO_ADDR
// if not tmp then
60313: LD_VAR 0 4
60317: NOT
60318: IFFALSE 60322
// continue ;
60320: GO 60267
// for j in tmp do
60322: LD_ADDR_VAR 0 3
60326: PUSH
60327: LD_VAR 0 4
60331: PUSH
60332: FOR_IN
60333: IFFALSE 60485
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
60335: LD_VAR 0 3
60339: PPUSH
60340: CALL_OW 110
60344: NOT
60345: PUSH
60346: LD_VAR 0 3
60350: PPUSH
60351: CALL_OW 314
60355: NOT
60356: AND
60357: PUSH
60358: LD_VAR 0 3
60362: PPUSH
60363: CALL_OW 311
60367: NOT
60368: AND
60369: PUSH
60370: LD_VAR 0 3
60374: PPUSH
60375: CALL_OW 310
60379: NOT
60380: AND
60381: PUSH
60382: LD_VAR 0 3
60386: PUSH
60387: LD_EXP 102
60391: PUSH
60392: LD_VAR 0 2
60396: ARRAY
60397: PUSH
60398: LD_INT 1
60400: ARRAY
60401: IN
60402: NOT
60403: AND
60404: PUSH
60405: LD_VAR 0 3
60409: PUSH
60410: LD_EXP 102
60414: PUSH
60415: LD_VAR 0 2
60419: ARRAY
60420: PUSH
60421: LD_INT 2
60423: ARRAY
60424: IN
60425: NOT
60426: AND
60427: PUSH
60428: LD_VAR 0 3
60432: PUSH
60433: LD_EXP 111
60437: PUSH
60438: LD_VAR 0 2
60442: ARRAY
60443: IN
60444: NOT
60445: AND
60446: IFFALSE 60483
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
60448: LD_VAR 0 2
60452: PPUSH
60453: LD_EXP 99
60457: PUSH
60458: LD_VAR 0 2
60462: ARRAY
60463: PPUSH
60464: LD_VAR 0 3
60468: PPUSH
60469: LD_VAR 0 3
60473: PPUSH
60474: CALL_OW 257
60478: PPUSH
60479: CALL 59255 0 4
// end ;
60483: GO 60332
60485: POP
60486: POP
// end ;
60487: GO 60267
60489: POP
60490: POP
// end ;
60491: LD_VAR 0 1
60495: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
60496: LD_INT 0
60498: PPUSH
60499: PPUSH
60500: PPUSH
60501: PPUSH
60502: PPUSH
60503: PPUSH
// if not mc_bases [ base ] then
60504: LD_EXP 99
60508: PUSH
60509: LD_VAR 0 1
60513: ARRAY
60514: NOT
60515: IFFALSE 60519
// exit ;
60517: GO 60701
// tmp := [ ] ;
60519: LD_ADDR_VAR 0 6
60523: PUSH
60524: EMPTY
60525: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
60526: LD_ADDR_VAR 0 7
60530: PUSH
60531: LD_VAR 0 3
60535: PPUSH
60536: LD_INT 0
60538: PPUSH
60539: CALL_OW 517
60543: ST_TO_ADDR
// if not list then
60544: LD_VAR 0 7
60548: NOT
60549: IFFALSE 60553
// exit ;
60551: GO 60701
// for i = 1 to amount do
60553: LD_ADDR_VAR 0 5
60557: PUSH
60558: DOUBLE
60559: LD_INT 1
60561: DEC
60562: ST_TO_ADDR
60563: LD_VAR 0 2
60567: PUSH
60568: FOR_TO
60569: IFFALSE 60649
// begin x := rand ( 1 , list [ 1 ] ) ;
60571: LD_ADDR_VAR 0 8
60575: PUSH
60576: LD_INT 1
60578: PPUSH
60579: LD_VAR 0 7
60583: PUSH
60584: LD_INT 1
60586: ARRAY
60587: PPUSH
60588: CALL_OW 12
60592: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
60593: LD_ADDR_VAR 0 6
60597: PUSH
60598: LD_VAR 0 6
60602: PPUSH
60603: LD_VAR 0 5
60607: PPUSH
60608: LD_VAR 0 7
60612: PUSH
60613: LD_INT 1
60615: ARRAY
60616: PUSH
60617: LD_VAR 0 8
60621: ARRAY
60622: PUSH
60623: LD_VAR 0 7
60627: PUSH
60628: LD_INT 2
60630: ARRAY
60631: PUSH
60632: LD_VAR 0 8
60636: ARRAY
60637: PUSH
60638: EMPTY
60639: LIST
60640: LIST
60641: PPUSH
60642: CALL_OW 1
60646: ST_TO_ADDR
// end ;
60647: GO 60568
60649: POP
60650: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
60651: LD_ADDR_EXP 112
60655: PUSH
60656: LD_EXP 112
60660: PPUSH
60661: LD_VAR 0 1
60665: PPUSH
60666: LD_VAR 0 6
60670: PPUSH
60671: CALL_OW 1
60675: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
60676: LD_ADDR_EXP 114
60680: PUSH
60681: LD_EXP 114
60685: PPUSH
60686: LD_VAR 0 1
60690: PPUSH
60691: LD_VAR 0 3
60695: PPUSH
60696: CALL_OW 1
60700: ST_TO_ADDR
// end ;
60701: LD_VAR 0 4
60705: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
60706: LD_INT 0
60708: PPUSH
// if not mc_bases [ base ] then
60709: LD_EXP 99
60713: PUSH
60714: LD_VAR 0 1
60718: ARRAY
60719: NOT
60720: IFFALSE 60724
// exit ;
60722: GO 60749
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
60724: LD_ADDR_EXP 104
60728: PUSH
60729: LD_EXP 104
60733: PPUSH
60734: LD_VAR 0 1
60738: PPUSH
60739: LD_VAR 0 2
60743: PPUSH
60744: CALL_OW 1
60748: ST_TO_ADDR
// end ;
60749: LD_VAR 0 3
60753: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
60754: LD_INT 0
60756: PPUSH
// if not mc_bases [ base ] then
60757: LD_EXP 99
60761: PUSH
60762: LD_VAR 0 1
60766: ARRAY
60767: NOT
60768: IFFALSE 60772
// exit ;
60770: GO 60809
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
60772: LD_ADDR_EXP 104
60776: PUSH
60777: LD_EXP 104
60781: PPUSH
60782: LD_VAR 0 1
60786: PPUSH
60787: LD_EXP 104
60791: PUSH
60792: LD_VAR 0 1
60796: ARRAY
60797: PUSH
60798: LD_VAR 0 2
60802: UNION
60803: PPUSH
60804: CALL_OW 1
60808: ST_TO_ADDR
// end ;
60809: LD_VAR 0 3
60813: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
60814: LD_INT 0
60816: PPUSH
// if not mc_bases [ base ] then
60817: LD_EXP 99
60821: PUSH
60822: LD_VAR 0 1
60826: ARRAY
60827: NOT
60828: IFFALSE 60832
// exit ;
60830: GO 60857
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
60832: LD_ADDR_EXP 120
60836: PUSH
60837: LD_EXP 120
60841: PPUSH
60842: LD_VAR 0 1
60846: PPUSH
60847: LD_VAR 0 2
60851: PPUSH
60852: CALL_OW 1
60856: ST_TO_ADDR
// end ;
60857: LD_VAR 0 3
60861: RET
// export function MC_InsertProduceList ( base , components ) ; begin
60862: LD_INT 0
60864: PPUSH
// if not mc_bases [ base ] then
60865: LD_EXP 99
60869: PUSH
60870: LD_VAR 0 1
60874: ARRAY
60875: NOT
60876: IFFALSE 60880
// exit ;
60878: GO 60917
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
60880: LD_ADDR_EXP 120
60884: PUSH
60885: LD_EXP 120
60889: PPUSH
60890: LD_VAR 0 1
60894: PPUSH
60895: LD_EXP 120
60899: PUSH
60900: LD_VAR 0 1
60904: ARRAY
60905: PUSH
60906: LD_VAR 0 2
60910: ADD
60911: PPUSH
60912: CALL_OW 1
60916: ST_TO_ADDR
// end ;
60917: LD_VAR 0 3
60921: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
60922: LD_INT 0
60924: PPUSH
// if not mc_bases [ base ] then
60925: LD_EXP 99
60929: PUSH
60930: LD_VAR 0 1
60934: ARRAY
60935: NOT
60936: IFFALSE 60940
// exit ;
60938: GO 60994
// mc_defender := Replace ( mc_defender , base , deflist ) ;
60940: LD_ADDR_EXP 121
60944: PUSH
60945: LD_EXP 121
60949: PPUSH
60950: LD_VAR 0 1
60954: PPUSH
60955: LD_VAR 0 2
60959: PPUSH
60960: CALL_OW 1
60964: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
60965: LD_ADDR_EXP 110
60969: PUSH
60970: LD_EXP 110
60974: PPUSH
60975: LD_VAR 0 1
60979: PPUSH
60980: LD_VAR 0 2
60984: PUSH
60985: LD_INT 0
60987: PLUS
60988: PPUSH
60989: CALL_OW 1
60993: ST_TO_ADDR
// end ;
60994: LD_VAR 0 3
60998: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
60999: LD_INT 0
61001: PPUSH
// if not mc_bases [ base ] then
61002: LD_EXP 99
61006: PUSH
61007: LD_VAR 0 1
61011: ARRAY
61012: NOT
61013: IFFALSE 61017
// exit ;
61015: GO 61042
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
61017: LD_ADDR_EXP 110
61021: PUSH
61022: LD_EXP 110
61026: PPUSH
61027: LD_VAR 0 1
61031: PPUSH
61032: LD_VAR 0 2
61036: PPUSH
61037: CALL_OW 1
61041: ST_TO_ADDR
// end ;
61042: LD_VAR 0 3
61046: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
61047: LD_INT 0
61049: PPUSH
61050: PPUSH
61051: PPUSH
61052: PPUSH
// if not mc_bases [ base ] then
61053: LD_EXP 99
61057: PUSH
61058: LD_VAR 0 1
61062: ARRAY
61063: NOT
61064: IFFALSE 61068
// exit ;
61066: GO 61133
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61068: LD_ADDR_EXP 119
61072: PUSH
61073: LD_EXP 119
61077: PPUSH
61078: LD_VAR 0 1
61082: PUSH
61083: LD_EXP 119
61087: PUSH
61088: LD_VAR 0 1
61092: ARRAY
61093: PUSH
61094: LD_INT 1
61096: PLUS
61097: PUSH
61098: EMPTY
61099: LIST
61100: LIST
61101: PPUSH
61102: LD_VAR 0 1
61106: PUSH
61107: LD_VAR 0 2
61111: PUSH
61112: LD_VAR 0 3
61116: PUSH
61117: LD_VAR 0 4
61121: PUSH
61122: EMPTY
61123: LIST
61124: LIST
61125: LIST
61126: LIST
61127: PPUSH
61128: CALL 72387 0 3
61132: ST_TO_ADDR
// end ;
61133: LD_VAR 0 5
61137: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61138: LD_INT 0
61140: PPUSH
// if not mc_bases [ base ] then
61141: LD_EXP 99
61145: PUSH
61146: LD_VAR 0 1
61150: ARRAY
61151: NOT
61152: IFFALSE 61156
// exit ;
61154: GO 61181
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61156: LD_ADDR_EXP 136
61160: PUSH
61161: LD_EXP 136
61165: PPUSH
61166: LD_VAR 0 1
61170: PPUSH
61171: LD_VAR 0 2
61175: PPUSH
61176: CALL_OW 1
61180: ST_TO_ADDR
// end ;
61181: LD_VAR 0 3
61185: RET
// export function MC_GetMinesField ( base ) ; begin
61186: LD_INT 0
61188: PPUSH
// result := mc_mines [ base ] ;
61189: LD_ADDR_VAR 0 2
61193: PUSH
61194: LD_EXP 112
61198: PUSH
61199: LD_VAR 0 1
61203: ARRAY
61204: ST_TO_ADDR
// end ;
61205: LD_VAR 0 2
61209: RET
// export function MC_GetProduceList ( base ) ; begin
61210: LD_INT 0
61212: PPUSH
// result := mc_produce [ base ] ;
61213: LD_ADDR_VAR 0 2
61217: PUSH
61218: LD_EXP 120
61222: PUSH
61223: LD_VAR 0 1
61227: ARRAY
61228: ST_TO_ADDR
// end ;
61229: LD_VAR 0 2
61233: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61234: LD_INT 0
61236: PPUSH
61237: PPUSH
// if not mc_bases then
61238: LD_EXP 99
61242: NOT
61243: IFFALSE 61247
// exit ;
61245: GO 61312
// if mc_bases [ base ] then
61247: LD_EXP 99
61251: PUSH
61252: LD_VAR 0 1
61256: ARRAY
61257: IFFALSE 61312
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61259: LD_ADDR_VAR 0 3
61263: PUSH
61264: LD_EXP 99
61268: PUSH
61269: LD_VAR 0 1
61273: ARRAY
61274: PPUSH
61275: LD_INT 30
61277: PUSH
61278: LD_VAR 0 2
61282: PUSH
61283: EMPTY
61284: LIST
61285: LIST
61286: PPUSH
61287: CALL_OW 72
61291: ST_TO_ADDR
// if result then
61292: LD_VAR 0 3
61296: IFFALSE 61312
// result := result [ 1 ] ;
61298: LD_ADDR_VAR 0 3
61302: PUSH
61303: LD_VAR 0 3
61307: PUSH
61308: LD_INT 1
61310: ARRAY
61311: ST_TO_ADDR
// end ; end ;
61312: LD_VAR 0 3
61316: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
61317: LD_INT 0
61319: PPUSH
61320: PPUSH
// if not mc_bases then
61321: LD_EXP 99
61325: NOT
61326: IFFALSE 61330
// exit ;
61328: GO 61375
// if mc_bases [ base ] then
61330: LD_EXP 99
61334: PUSH
61335: LD_VAR 0 1
61339: ARRAY
61340: IFFALSE 61375
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61342: LD_ADDR_VAR 0 3
61346: PUSH
61347: LD_EXP 99
61351: PUSH
61352: LD_VAR 0 1
61356: ARRAY
61357: PPUSH
61358: LD_INT 30
61360: PUSH
61361: LD_VAR 0 2
61365: PUSH
61366: EMPTY
61367: LIST
61368: LIST
61369: PPUSH
61370: CALL_OW 72
61374: ST_TO_ADDR
// end ;
61375: LD_VAR 0 3
61379: RET
// export function MC_SetTame ( base , area ) ; begin
61380: LD_INT 0
61382: PPUSH
// if not mc_bases or not base then
61383: LD_EXP 99
61387: NOT
61388: PUSH
61389: LD_VAR 0 1
61393: NOT
61394: OR
61395: IFFALSE 61399
// exit ;
61397: GO 61424
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
61399: LD_ADDR_EXP 127
61403: PUSH
61404: LD_EXP 127
61408: PPUSH
61409: LD_VAR 0 1
61413: PPUSH
61414: LD_VAR 0 2
61418: PPUSH
61419: CALL_OW 1
61423: ST_TO_ADDR
// end ;
61424: LD_VAR 0 3
61428: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
61429: LD_INT 0
61431: PPUSH
61432: PPUSH
// if not mc_bases or not base then
61433: LD_EXP 99
61437: NOT
61438: PUSH
61439: LD_VAR 0 1
61443: NOT
61444: OR
61445: IFFALSE 61449
// exit ;
61447: GO 61551
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61449: LD_ADDR_VAR 0 4
61453: PUSH
61454: LD_EXP 99
61458: PUSH
61459: LD_VAR 0 1
61463: ARRAY
61464: PPUSH
61465: LD_INT 30
61467: PUSH
61468: LD_VAR 0 2
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: PPUSH
61477: CALL_OW 72
61481: ST_TO_ADDR
// if not tmp then
61482: LD_VAR 0 4
61486: NOT
61487: IFFALSE 61491
// exit ;
61489: GO 61551
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
61491: LD_ADDR_EXP 131
61495: PUSH
61496: LD_EXP 131
61500: PPUSH
61501: LD_VAR 0 1
61505: PPUSH
61506: LD_EXP 131
61510: PUSH
61511: LD_VAR 0 1
61515: ARRAY
61516: PPUSH
61517: LD_EXP 131
61521: PUSH
61522: LD_VAR 0 1
61526: ARRAY
61527: PUSH
61528: LD_INT 1
61530: PLUS
61531: PPUSH
61532: LD_VAR 0 4
61536: PUSH
61537: LD_INT 1
61539: ARRAY
61540: PPUSH
61541: CALL_OW 2
61545: PPUSH
61546: CALL_OW 1
61550: ST_TO_ADDR
// end ;
61551: LD_VAR 0 3
61555: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
61556: LD_INT 0
61558: PPUSH
61559: PPUSH
// if not mc_bases or not base or not kinds then
61560: LD_EXP 99
61564: NOT
61565: PUSH
61566: LD_VAR 0 1
61570: NOT
61571: OR
61572: PUSH
61573: LD_VAR 0 2
61577: NOT
61578: OR
61579: IFFALSE 61583
// exit ;
61581: GO 61644
// for i in kinds do
61583: LD_ADDR_VAR 0 4
61587: PUSH
61588: LD_VAR 0 2
61592: PUSH
61593: FOR_IN
61594: IFFALSE 61642
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
61596: LD_ADDR_EXP 133
61600: PUSH
61601: LD_EXP 133
61605: PPUSH
61606: LD_VAR 0 1
61610: PUSH
61611: LD_EXP 133
61615: PUSH
61616: LD_VAR 0 1
61620: ARRAY
61621: PUSH
61622: LD_INT 1
61624: PLUS
61625: PUSH
61626: EMPTY
61627: LIST
61628: LIST
61629: PPUSH
61630: LD_VAR 0 4
61634: PPUSH
61635: CALL 72387 0 3
61639: ST_TO_ADDR
61640: GO 61593
61642: POP
61643: POP
// end ;
61644: LD_VAR 0 3
61648: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
61649: LD_INT 0
61651: PPUSH
// if not mc_bases or not base or not areas then
61652: LD_EXP 99
61656: NOT
61657: PUSH
61658: LD_VAR 0 1
61662: NOT
61663: OR
61664: PUSH
61665: LD_VAR 0 2
61669: NOT
61670: OR
61671: IFFALSE 61675
// exit ;
61673: GO 61700
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
61675: LD_ADDR_EXP 117
61679: PUSH
61680: LD_EXP 117
61684: PPUSH
61685: LD_VAR 0 1
61689: PPUSH
61690: LD_VAR 0 2
61694: PPUSH
61695: CALL_OW 1
61699: ST_TO_ADDR
// end ;
61700: LD_VAR 0 3
61704: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
61705: LD_INT 0
61707: PPUSH
// if not mc_bases or not base or not teleports_exit then
61708: LD_EXP 99
61712: NOT
61713: PUSH
61714: LD_VAR 0 1
61718: NOT
61719: OR
61720: PUSH
61721: LD_VAR 0 2
61725: NOT
61726: OR
61727: IFFALSE 61731
// exit ;
61729: GO 61756
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
61731: LD_ADDR_EXP 134
61735: PUSH
61736: LD_EXP 134
61740: PPUSH
61741: LD_VAR 0 1
61745: PPUSH
61746: LD_VAR 0 2
61750: PPUSH
61751: CALL_OW 1
61755: ST_TO_ADDR
// end ;
61756: LD_VAR 0 3
61760: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
61761: LD_INT 0
61763: PPUSH
61764: PPUSH
61765: PPUSH
// if not mc_bases or not base or not ext_list then
61766: LD_EXP 99
61770: NOT
61771: PUSH
61772: LD_VAR 0 1
61776: NOT
61777: OR
61778: PUSH
61779: LD_VAR 0 5
61783: NOT
61784: OR
61785: IFFALSE 61789
// exit ;
61787: GO 61962
// tmp := GetFacExtXYD ( x , y , d ) ;
61789: LD_ADDR_VAR 0 8
61793: PUSH
61794: LD_VAR 0 2
61798: PPUSH
61799: LD_VAR 0 3
61803: PPUSH
61804: LD_VAR 0 4
61808: PPUSH
61809: CALL 102338 0 3
61813: ST_TO_ADDR
// if not tmp then
61814: LD_VAR 0 8
61818: NOT
61819: IFFALSE 61823
// exit ;
61821: GO 61962
// for i in tmp do
61823: LD_ADDR_VAR 0 7
61827: PUSH
61828: LD_VAR 0 8
61832: PUSH
61833: FOR_IN
61834: IFFALSE 61960
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
61836: LD_ADDR_EXP 104
61840: PUSH
61841: LD_EXP 104
61845: PPUSH
61846: LD_VAR 0 1
61850: PPUSH
61851: LD_EXP 104
61855: PUSH
61856: LD_VAR 0 1
61860: ARRAY
61861: PPUSH
61862: LD_EXP 104
61866: PUSH
61867: LD_VAR 0 1
61871: ARRAY
61872: PUSH
61873: LD_INT 1
61875: PLUS
61876: PPUSH
61877: LD_VAR 0 5
61881: PUSH
61882: LD_INT 1
61884: ARRAY
61885: PUSH
61886: LD_VAR 0 7
61890: PUSH
61891: LD_INT 1
61893: ARRAY
61894: PUSH
61895: LD_VAR 0 7
61899: PUSH
61900: LD_INT 2
61902: ARRAY
61903: PUSH
61904: LD_VAR 0 7
61908: PUSH
61909: LD_INT 3
61911: ARRAY
61912: PUSH
61913: EMPTY
61914: LIST
61915: LIST
61916: LIST
61917: LIST
61918: PPUSH
61919: CALL_OW 2
61923: PPUSH
61924: CALL_OW 1
61928: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
61929: LD_ADDR_VAR 0 5
61933: PUSH
61934: LD_VAR 0 5
61938: PPUSH
61939: LD_INT 1
61941: PPUSH
61942: CALL_OW 3
61946: ST_TO_ADDR
// if not ext_list then
61947: LD_VAR 0 5
61951: NOT
61952: IFFALSE 61958
// exit ;
61954: POP
61955: POP
61956: GO 61962
// end ;
61958: GO 61833
61960: POP
61961: POP
// end ;
61962: LD_VAR 0 6
61966: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
61967: LD_INT 0
61969: PPUSH
// if not mc_bases or not base or not weapon_list then
61970: LD_EXP 99
61974: NOT
61975: PUSH
61976: LD_VAR 0 1
61980: NOT
61981: OR
61982: PUSH
61983: LD_VAR 0 2
61987: NOT
61988: OR
61989: IFFALSE 61993
// exit ;
61991: GO 62018
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
61993: LD_ADDR_EXP 138
61997: PUSH
61998: LD_EXP 138
62002: PPUSH
62003: LD_VAR 0 1
62007: PPUSH
62008: LD_VAR 0 2
62012: PPUSH
62013: CALL_OW 1
62017: ST_TO_ADDR
// end ;
62018: LD_VAR 0 3
62022: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
62023: LD_INT 0
62025: PPUSH
// if not mc_bases or not base or not tech_list then
62026: LD_EXP 99
62030: NOT
62031: PUSH
62032: LD_VAR 0 1
62036: NOT
62037: OR
62038: PUSH
62039: LD_VAR 0 2
62043: NOT
62044: OR
62045: IFFALSE 62049
// exit ;
62047: GO 62074
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
62049: LD_ADDR_EXP 126
62053: PUSH
62054: LD_EXP 126
62058: PPUSH
62059: LD_VAR 0 1
62063: PPUSH
62064: LD_VAR 0 2
62068: PPUSH
62069: CALL_OW 1
62073: ST_TO_ADDR
// end ;
62074: LD_VAR 0 3
62078: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62079: LD_INT 0
62081: PPUSH
// if not mc_bases or not parking_area or not base then
62082: LD_EXP 99
62086: NOT
62087: PUSH
62088: LD_VAR 0 2
62092: NOT
62093: OR
62094: PUSH
62095: LD_VAR 0 1
62099: NOT
62100: OR
62101: IFFALSE 62105
// exit ;
62103: GO 62130
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62105: LD_ADDR_EXP 123
62109: PUSH
62110: LD_EXP 123
62114: PPUSH
62115: LD_VAR 0 1
62119: PPUSH
62120: LD_VAR 0 2
62124: PPUSH
62125: CALL_OW 1
62129: ST_TO_ADDR
// end ;
62130: LD_VAR 0 3
62134: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62135: LD_INT 0
62137: PPUSH
// if not mc_bases or not base or not scan_area then
62138: LD_EXP 99
62142: NOT
62143: PUSH
62144: LD_VAR 0 1
62148: NOT
62149: OR
62150: PUSH
62151: LD_VAR 0 2
62155: NOT
62156: OR
62157: IFFALSE 62161
// exit ;
62159: GO 62186
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62161: LD_ADDR_EXP 124
62165: PUSH
62166: LD_EXP 124
62170: PPUSH
62171: LD_VAR 0 1
62175: PPUSH
62176: LD_VAR 0 2
62180: PPUSH
62181: CALL_OW 1
62185: ST_TO_ADDR
// end ;
62186: LD_VAR 0 3
62190: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62191: LD_INT 0
62193: PPUSH
62194: PPUSH
// if not mc_bases or not base then
62195: LD_EXP 99
62199: NOT
62200: PUSH
62201: LD_VAR 0 1
62205: NOT
62206: OR
62207: IFFALSE 62211
// exit ;
62209: GO 62275
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62211: LD_ADDR_VAR 0 3
62215: PUSH
62216: LD_INT 1
62218: PUSH
62219: LD_INT 2
62221: PUSH
62222: LD_INT 3
62224: PUSH
62225: LD_INT 4
62227: PUSH
62228: LD_INT 11
62230: PUSH
62231: EMPTY
62232: LIST
62233: LIST
62234: LIST
62235: LIST
62236: LIST
62237: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62238: LD_ADDR_EXP 126
62242: PUSH
62243: LD_EXP 126
62247: PPUSH
62248: LD_VAR 0 1
62252: PPUSH
62253: LD_EXP 126
62257: PUSH
62258: LD_VAR 0 1
62262: ARRAY
62263: PUSH
62264: LD_VAR 0 3
62268: DIFF
62269: PPUSH
62270: CALL_OW 1
62274: ST_TO_ADDR
// end ;
62275: LD_VAR 0 2
62279: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62280: LD_INT 0
62282: PPUSH
// result := mc_vehicles [ base ] ;
62283: LD_ADDR_VAR 0 3
62287: PUSH
62288: LD_EXP 118
62292: PUSH
62293: LD_VAR 0 1
62297: ARRAY
62298: ST_TO_ADDR
// if onlyCombat then
62299: LD_VAR 0 2
62303: IFFALSE 62475
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62305: LD_ADDR_VAR 0 3
62309: PUSH
62310: LD_VAR 0 3
62314: PUSH
62315: LD_VAR 0 3
62319: PPUSH
62320: LD_INT 2
62322: PUSH
62323: LD_INT 34
62325: PUSH
62326: LD_INT 12
62328: PUSH
62329: EMPTY
62330: LIST
62331: LIST
62332: PUSH
62333: LD_INT 34
62335: PUSH
62336: LD_INT 51
62338: PUSH
62339: EMPTY
62340: LIST
62341: LIST
62342: PUSH
62343: LD_INT 34
62345: PUSH
62346: LD_INT 89
62348: PUSH
62349: EMPTY
62350: LIST
62351: LIST
62352: PUSH
62353: LD_INT 34
62355: PUSH
62356: LD_INT 32
62358: PUSH
62359: EMPTY
62360: LIST
62361: LIST
62362: PUSH
62363: LD_INT 34
62365: PUSH
62366: LD_INT 13
62368: PUSH
62369: EMPTY
62370: LIST
62371: LIST
62372: PUSH
62373: LD_INT 34
62375: PUSH
62376: LD_INT 52
62378: PUSH
62379: EMPTY
62380: LIST
62381: LIST
62382: PUSH
62383: LD_INT 34
62385: PUSH
62386: LD_INT 88
62388: PUSH
62389: EMPTY
62390: LIST
62391: LIST
62392: PUSH
62393: LD_INT 34
62395: PUSH
62396: LD_INT 14
62398: PUSH
62399: EMPTY
62400: LIST
62401: LIST
62402: PUSH
62403: LD_INT 34
62405: PUSH
62406: LD_INT 53
62408: PUSH
62409: EMPTY
62410: LIST
62411: LIST
62412: PUSH
62413: LD_INT 34
62415: PUSH
62416: LD_INT 98
62418: PUSH
62419: EMPTY
62420: LIST
62421: LIST
62422: PUSH
62423: LD_INT 34
62425: PUSH
62426: LD_INT 31
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: PUSH
62433: LD_INT 34
62435: PUSH
62436: LD_INT 48
62438: PUSH
62439: EMPTY
62440: LIST
62441: LIST
62442: PUSH
62443: LD_INT 34
62445: PUSH
62446: LD_INT 8
62448: PUSH
62449: EMPTY
62450: LIST
62451: LIST
62452: PUSH
62453: EMPTY
62454: LIST
62455: LIST
62456: LIST
62457: LIST
62458: LIST
62459: LIST
62460: LIST
62461: LIST
62462: LIST
62463: LIST
62464: LIST
62465: LIST
62466: LIST
62467: LIST
62468: PPUSH
62469: CALL_OW 72
62473: DIFF
62474: ST_TO_ADDR
// end ; end_of_file
62475: LD_VAR 0 3
62479: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
62480: LD_INT 0
62482: PPUSH
62483: PPUSH
62484: PPUSH
// if not mc_bases or not skirmish then
62485: LD_EXP 99
62489: NOT
62490: PUSH
62491: LD_EXP 97
62495: NOT
62496: OR
62497: IFFALSE 62501
// exit ;
62499: GO 62666
// for i = 1 to mc_bases do
62501: LD_ADDR_VAR 0 4
62505: PUSH
62506: DOUBLE
62507: LD_INT 1
62509: DEC
62510: ST_TO_ADDR
62511: LD_EXP 99
62515: PUSH
62516: FOR_TO
62517: IFFALSE 62664
// begin if sci in mc_bases [ i ] then
62519: LD_VAR 0 2
62523: PUSH
62524: LD_EXP 99
62528: PUSH
62529: LD_VAR 0 4
62533: ARRAY
62534: IN
62535: IFFALSE 62662
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
62537: LD_ADDR_EXP 128
62541: PUSH
62542: LD_EXP 128
62546: PPUSH
62547: LD_VAR 0 4
62551: PUSH
62552: LD_EXP 128
62556: PUSH
62557: LD_VAR 0 4
62561: ARRAY
62562: PUSH
62563: LD_INT 1
62565: PLUS
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: PPUSH
62571: LD_VAR 0 1
62575: PPUSH
62576: CALL 72387 0 3
62580: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
62581: LD_ADDR_VAR 0 5
62585: PUSH
62586: LD_EXP 99
62590: PUSH
62591: LD_VAR 0 4
62595: ARRAY
62596: PPUSH
62597: LD_INT 2
62599: PUSH
62600: LD_INT 30
62602: PUSH
62603: LD_INT 0
62605: PUSH
62606: EMPTY
62607: LIST
62608: LIST
62609: PUSH
62610: LD_INT 30
62612: PUSH
62613: LD_INT 1
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: PUSH
62620: EMPTY
62621: LIST
62622: LIST
62623: LIST
62624: PPUSH
62625: CALL_OW 72
62629: PPUSH
62630: LD_VAR 0 1
62634: PPUSH
62635: CALL_OW 74
62639: ST_TO_ADDR
// if tmp then
62640: LD_VAR 0 5
62644: IFFALSE 62660
// ComStandNearbyBuilding ( ape , tmp ) ;
62646: LD_VAR 0 1
62650: PPUSH
62651: LD_VAR 0 5
62655: PPUSH
62656: CALL 68814 0 2
// break ;
62660: GO 62664
// end ; end ;
62662: GO 62516
62664: POP
62665: POP
// end ;
62666: LD_VAR 0 3
62670: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
62671: LD_INT 0
62673: PPUSH
62674: PPUSH
62675: PPUSH
// if not mc_bases or not skirmish then
62676: LD_EXP 99
62680: NOT
62681: PUSH
62682: LD_EXP 97
62686: NOT
62687: OR
62688: IFFALSE 62692
// exit ;
62690: GO 62781
// for i = 1 to mc_bases do
62692: LD_ADDR_VAR 0 4
62696: PUSH
62697: DOUBLE
62698: LD_INT 1
62700: DEC
62701: ST_TO_ADDR
62702: LD_EXP 99
62706: PUSH
62707: FOR_TO
62708: IFFALSE 62779
// begin if building in mc_busy_turret_list [ i ] then
62710: LD_VAR 0 1
62714: PUSH
62715: LD_EXP 109
62719: PUSH
62720: LD_VAR 0 4
62724: ARRAY
62725: IN
62726: IFFALSE 62777
// begin tmp := mc_busy_turret_list [ i ] diff building ;
62728: LD_ADDR_VAR 0 5
62732: PUSH
62733: LD_EXP 109
62737: PUSH
62738: LD_VAR 0 4
62742: ARRAY
62743: PUSH
62744: LD_VAR 0 1
62748: DIFF
62749: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
62750: LD_ADDR_EXP 109
62754: PUSH
62755: LD_EXP 109
62759: PPUSH
62760: LD_VAR 0 4
62764: PPUSH
62765: LD_VAR 0 5
62769: PPUSH
62770: CALL_OW 1
62774: ST_TO_ADDR
// break ;
62775: GO 62779
// end ; end ;
62777: GO 62707
62779: POP
62780: POP
// end ;
62781: LD_VAR 0 3
62785: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
62786: LD_INT 0
62788: PPUSH
62789: PPUSH
62790: PPUSH
// if not mc_bases or not skirmish then
62791: LD_EXP 99
62795: NOT
62796: PUSH
62797: LD_EXP 97
62801: NOT
62802: OR
62803: IFFALSE 62807
// exit ;
62805: GO 63006
// for i = 1 to mc_bases do
62807: LD_ADDR_VAR 0 5
62811: PUSH
62812: DOUBLE
62813: LD_INT 1
62815: DEC
62816: ST_TO_ADDR
62817: LD_EXP 99
62821: PUSH
62822: FOR_TO
62823: IFFALSE 63004
// if building in mc_bases [ i ] then
62825: LD_VAR 0 1
62829: PUSH
62830: LD_EXP 99
62834: PUSH
62835: LD_VAR 0 5
62839: ARRAY
62840: IN
62841: IFFALSE 63002
// begin tmp := mc_bases [ i ] diff building ;
62843: LD_ADDR_VAR 0 6
62847: PUSH
62848: LD_EXP 99
62852: PUSH
62853: LD_VAR 0 5
62857: ARRAY
62858: PUSH
62859: LD_VAR 0 1
62863: DIFF
62864: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
62865: LD_ADDR_EXP 99
62869: PUSH
62870: LD_EXP 99
62874: PPUSH
62875: LD_VAR 0 5
62879: PPUSH
62880: LD_VAR 0 6
62884: PPUSH
62885: CALL_OW 1
62889: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
62890: LD_VAR 0 1
62894: PUSH
62895: LD_EXP 107
62899: PUSH
62900: LD_VAR 0 5
62904: ARRAY
62905: IN
62906: IFFALSE 62945
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
62908: LD_ADDR_EXP 107
62912: PUSH
62913: LD_EXP 107
62917: PPUSH
62918: LD_VAR 0 5
62922: PPUSH
62923: LD_EXP 107
62927: PUSH
62928: LD_VAR 0 5
62932: ARRAY
62933: PUSH
62934: LD_VAR 0 1
62938: DIFF
62939: PPUSH
62940: CALL_OW 1
62944: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
62945: LD_VAR 0 1
62949: PUSH
62950: LD_EXP 108
62954: PUSH
62955: LD_VAR 0 5
62959: ARRAY
62960: IN
62961: IFFALSE 63000
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
62963: LD_ADDR_EXP 108
62967: PUSH
62968: LD_EXP 108
62972: PPUSH
62973: LD_VAR 0 5
62977: PPUSH
62978: LD_EXP 108
62982: PUSH
62983: LD_VAR 0 5
62987: ARRAY
62988: PUSH
62989: LD_VAR 0 1
62993: DIFF
62994: PPUSH
62995: CALL_OW 1
62999: ST_TO_ADDR
// break ;
63000: GO 63004
// end ;
63002: GO 62822
63004: POP
63005: POP
// end ;
63006: LD_VAR 0 4
63010: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
63011: LD_INT 0
63013: PPUSH
63014: PPUSH
63015: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
63016: LD_EXP 99
63020: NOT
63021: PUSH
63022: LD_EXP 97
63026: NOT
63027: OR
63028: PUSH
63029: LD_VAR 0 3
63033: PUSH
63034: LD_EXP 125
63038: IN
63039: NOT
63040: OR
63041: IFFALSE 63045
// exit ;
63043: GO 63168
// for i = 1 to mc_vehicles do
63045: LD_ADDR_VAR 0 6
63049: PUSH
63050: DOUBLE
63051: LD_INT 1
63053: DEC
63054: ST_TO_ADDR
63055: LD_EXP 118
63059: PUSH
63060: FOR_TO
63061: IFFALSE 63166
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63063: LD_VAR 0 2
63067: PUSH
63068: LD_EXP 118
63072: PUSH
63073: LD_VAR 0 6
63077: ARRAY
63078: IN
63079: PUSH
63080: LD_VAR 0 1
63084: PUSH
63085: LD_EXP 118
63089: PUSH
63090: LD_VAR 0 6
63094: ARRAY
63095: IN
63096: OR
63097: IFFALSE 63164
// begin tmp := mc_vehicles [ i ] diff old ;
63099: LD_ADDR_VAR 0 7
63103: PUSH
63104: LD_EXP 118
63108: PUSH
63109: LD_VAR 0 6
63113: ARRAY
63114: PUSH
63115: LD_VAR 0 2
63119: DIFF
63120: ST_TO_ADDR
// tmp := tmp diff new ;
63121: LD_ADDR_VAR 0 7
63125: PUSH
63126: LD_VAR 0 7
63130: PUSH
63131: LD_VAR 0 1
63135: DIFF
63136: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63137: LD_ADDR_EXP 118
63141: PUSH
63142: LD_EXP 118
63146: PPUSH
63147: LD_VAR 0 6
63151: PPUSH
63152: LD_VAR 0 7
63156: PPUSH
63157: CALL_OW 1
63161: ST_TO_ADDR
// break ;
63162: GO 63166
// end ;
63164: GO 63060
63166: POP
63167: POP
// end ;
63168: LD_VAR 0 5
63172: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63173: LD_INT 0
63175: PPUSH
63176: PPUSH
63177: PPUSH
63178: PPUSH
// if not mc_bases or not skirmish then
63179: LD_EXP 99
63183: NOT
63184: PUSH
63185: LD_EXP 97
63189: NOT
63190: OR
63191: IFFALSE 63195
// exit ;
63193: GO 63577
// side := GetSide ( vehicle ) ;
63195: LD_ADDR_VAR 0 5
63199: PUSH
63200: LD_VAR 0 1
63204: PPUSH
63205: CALL_OW 255
63209: ST_TO_ADDR
// for i = 1 to mc_bases do
63210: LD_ADDR_VAR 0 4
63214: PUSH
63215: DOUBLE
63216: LD_INT 1
63218: DEC
63219: ST_TO_ADDR
63220: LD_EXP 99
63224: PUSH
63225: FOR_TO
63226: IFFALSE 63575
// begin if factory in mc_bases [ i ] then
63228: LD_VAR 0 2
63232: PUSH
63233: LD_EXP 99
63237: PUSH
63238: LD_VAR 0 4
63242: ARRAY
63243: IN
63244: IFFALSE 63573
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63246: LD_EXP 121
63250: PUSH
63251: LD_VAR 0 4
63255: ARRAY
63256: PUSH
63257: LD_EXP 110
63261: PUSH
63262: LD_VAR 0 4
63266: ARRAY
63267: LESS
63268: PUSH
63269: LD_VAR 0 1
63273: PPUSH
63274: CALL_OW 264
63278: PUSH
63279: LD_INT 31
63281: PUSH
63282: LD_INT 32
63284: PUSH
63285: LD_INT 51
63287: PUSH
63288: LD_INT 89
63290: PUSH
63291: LD_INT 12
63293: PUSH
63294: LD_INT 30
63296: PUSH
63297: LD_INT 98
63299: PUSH
63300: LD_INT 11
63302: PUSH
63303: LD_INT 53
63305: PUSH
63306: LD_INT 14
63308: PUSH
63309: LD_INT 91
63311: PUSH
63312: LD_INT 29
63314: PUSH
63315: LD_INT 99
63317: PUSH
63318: LD_INT 13
63320: PUSH
63321: LD_INT 52
63323: PUSH
63324: LD_INT 88
63326: PUSH
63327: LD_INT 48
63329: PUSH
63330: LD_INT 8
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: LIST
63337: LIST
63338: LIST
63339: LIST
63340: LIST
63341: LIST
63342: LIST
63343: LIST
63344: LIST
63345: LIST
63346: LIST
63347: LIST
63348: LIST
63349: LIST
63350: LIST
63351: LIST
63352: IN
63353: NOT
63354: AND
63355: IFFALSE 63403
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
63357: LD_ADDR_EXP 121
63361: PUSH
63362: LD_EXP 121
63366: PPUSH
63367: LD_VAR 0 4
63371: PUSH
63372: LD_EXP 121
63376: PUSH
63377: LD_VAR 0 4
63381: ARRAY
63382: PUSH
63383: LD_INT 1
63385: PLUS
63386: PUSH
63387: EMPTY
63388: LIST
63389: LIST
63390: PPUSH
63391: LD_VAR 0 1
63395: PPUSH
63396: CALL 72387 0 3
63400: ST_TO_ADDR
63401: GO 63447
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
63403: LD_ADDR_EXP 118
63407: PUSH
63408: LD_EXP 118
63412: PPUSH
63413: LD_VAR 0 4
63417: PUSH
63418: LD_EXP 118
63422: PUSH
63423: LD_VAR 0 4
63427: ARRAY
63428: PUSH
63429: LD_INT 1
63431: PLUS
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PPUSH
63437: LD_VAR 0 1
63441: PPUSH
63442: CALL 72387 0 3
63446: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
63447: LD_VAR 0 1
63451: PPUSH
63452: CALL_OW 263
63456: PUSH
63457: LD_INT 2
63459: EQUAL
63460: IFFALSE 63489
// begin repeat wait ( 0 0$3 ) ;
63462: LD_INT 105
63464: PPUSH
63465: CALL_OW 67
// Connect ( vehicle ) ;
63469: LD_VAR 0 1
63473: PPUSH
63474: CALL 75356 0 1
// until IsControledBy ( vehicle ) ;
63478: LD_VAR 0 1
63482: PPUSH
63483: CALL_OW 312
63487: IFFALSE 63462
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
63489: LD_VAR 0 1
63493: PPUSH
63494: LD_EXP 123
63498: PUSH
63499: LD_VAR 0 4
63503: ARRAY
63504: PPUSH
63505: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
63509: LD_VAR 0 1
63513: PPUSH
63514: CALL_OW 263
63518: PUSH
63519: LD_INT 1
63521: NONEQUAL
63522: IFFALSE 63526
// break ;
63524: GO 63575
// repeat wait ( 0 0$1 ) ;
63526: LD_INT 35
63528: PPUSH
63529: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
63533: LD_VAR 0 1
63537: PPUSH
63538: LD_EXP 123
63542: PUSH
63543: LD_VAR 0 4
63547: ARRAY
63548: PPUSH
63549: CALL_OW 308
63553: IFFALSE 63526
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
63555: LD_VAR 0 1
63559: PPUSH
63560: CALL_OW 311
63564: PPUSH
63565: CALL_OW 121
// exit ;
63569: POP
63570: POP
63571: GO 63577
// end ; end ;
63573: GO 63225
63575: POP
63576: POP
// end ;
63577: LD_VAR 0 3
63581: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
63582: LD_INT 0
63584: PPUSH
63585: PPUSH
63586: PPUSH
63587: PPUSH
// if not mc_bases or not skirmish then
63588: LD_EXP 99
63592: NOT
63593: PUSH
63594: LD_EXP 97
63598: NOT
63599: OR
63600: IFFALSE 63604
// exit ;
63602: GO 63957
// repeat wait ( 0 0$1 ) ;
63604: LD_INT 35
63606: PPUSH
63607: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
63611: LD_VAR 0 2
63615: PPUSH
63616: LD_VAR 0 3
63620: PPUSH
63621: CALL_OW 284
63625: IFFALSE 63604
// if GetResourceTypeXY ( x , y ) = mat_artefact then
63627: LD_VAR 0 2
63631: PPUSH
63632: LD_VAR 0 3
63636: PPUSH
63637: CALL_OW 283
63641: PUSH
63642: LD_INT 4
63644: EQUAL
63645: IFFALSE 63649
// exit ;
63647: GO 63957
// for i = 1 to mc_bases do
63649: LD_ADDR_VAR 0 7
63653: PUSH
63654: DOUBLE
63655: LD_INT 1
63657: DEC
63658: ST_TO_ADDR
63659: LD_EXP 99
63663: PUSH
63664: FOR_TO
63665: IFFALSE 63955
// begin if mc_crates_area [ i ] then
63667: LD_EXP 117
63671: PUSH
63672: LD_VAR 0 7
63676: ARRAY
63677: IFFALSE 63788
// for j in mc_crates_area [ i ] do
63679: LD_ADDR_VAR 0 8
63683: PUSH
63684: LD_EXP 117
63688: PUSH
63689: LD_VAR 0 7
63693: ARRAY
63694: PUSH
63695: FOR_IN
63696: IFFALSE 63786
// if InArea ( x , y , j ) then
63698: LD_VAR 0 2
63702: PPUSH
63703: LD_VAR 0 3
63707: PPUSH
63708: LD_VAR 0 8
63712: PPUSH
63713: CALL_OW 309
63717: IFFALSE 63784
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63719: LD_ADDR_EXP 115
63723: PUSH
63724: LD_EXP 115
63728: PPUSH
63729: LD_VAR 0 7
63733: PUSH
63734: LD_EXP 115
63738: PUSH
63739: LD_VAR 0 7
63743: ARRAY
63744: PUSH
63745: LD_INT 1
63747: PLUS
63748: PUSH
63749: EMPTY
63750: LIST
63751: LIST
63752: PPUSH
63753: LD_VAR 0 4
63757: PUSH
63758: LD_VAR 0 2
63762: PUSH
63763: LD_VAR 0 3
63767: PUSH
63768: EMPTY
63769: LIST
63770: LIST
63771: LIST
63772: PPUSH
63773: CALL 72387 0 3
63777: ST_TO_ADDR
// exit ;
63778: POP
63779: POP
63780: POP
63781: POP
63782: GO 63957
// end ;
63784: GO 63695
63786: POP
63787: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63788: LD_ADDR_VAR 0 9
63792: PUSH
63793: LD_EXP 99
63797: PUSH
63798: LD_VAR 0 7
63802: ARRAY
63803: PPUSH
63804: LD_INT 2
63806: PUSH
63807: LD_INT 30
63809: PUSH
63810: LD_INT 0
63812: PUSH
63813: EMPTY
63814: LIST
63815: LIST
63816: PUSH
63817: LD_INT 30
63819: PUSH
63820: LD_INT 1
63822: PUSH
63823: EMPTY
63824: LIST
63825: LIST
63826: PUSH
63827: EMPTY
63828: LIST
63829: LIST
63830: LIST
63831: PPUSH
63832: CALL_OW 72
63836: ST_TO_ADDR
// if not depot then
63837: LD_VAR 0 9
63841: NOT
63842: IFFALSE 63846
// continue ;
63844: GO 63664
// for j in depot do
63846: LD_ADDR_VAR 0 8
63850: PUSH
63851: LD_VAR 0 9
63855: PUSH
63856: FOR_IN
63857: IFFALSE 63951
// if GetDistUnitXY ( j , x , y ) < 30 then
63859: LD_VAR 0 8
63863: PPUSH
63864: LD_VAR 0 2
63868: PPUSH
63869: LD_VAR 0 3
63873: PPUSH
63874: CALL_OW 297
63878: PUSH
63879: LD_INT 30
63881: LESS
63882: IFFALSE 63949
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63884: LD_ADDR_EXP 115
63888: PUSH
63889: LD_EXP 115
63893: PPUSH
63894: LD_VAR 0 7
63898: PUSH
63899: LD_EXP 115
63903: PUSH
63904: LD_VAR 0 7
63908: ARRAY
63909: PUSH
63910: LD_INT 1
63912: PLUS
63913: PUSH
63914: EMPTY
63915: LIST
63916: LIST
63917: PPUSH
63918: LD_VAR 0 4
63922: PUSH
63923: LD_VAR 0 2
63927: PUSH
63928: LD_VAR 0 3
63932: PUSH
63933: EMPTY
63934: LIST
63935: LIST
63936: LIST
63937: PPUSH
63938: CALL 72387 0 3
63942: ST_TO_ADDR
// exit ;
63943: POP
63944: POP
63945: POP
63946: POP
63947: GO 63957
// end ;
63949: GO 63856
63951: POP
63952: POP
// end ;
63953: GO 63664
63955: POP
63956: POP
// end ;
63957: LD_VAR 0 6
63961: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
63962: LD_INT 0
63964: PPUSH
63965: PPUSH
63966: PPUSH
63967: PPUSH
// if not mc_bases or not skirmish then
63968: LD_EXP 99
63972: NOT
63973: PUSH
63974: LD_EXP 97
63978: NOT
63979: OR
63980: IFFALSE 63984
// exit ;
63982: GO 64261
// side := GetSide ( lab ) ;
63984: LD_ADDR_VAR 0 4
63988: PUSH
63989: LD_VAR 0 2
63993: PPUSH
63994: CALL_OW 255
63998: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
63999: LD_VAR 0 4
64003: PUSH
64004: LD_EXP 125
64008: IN
64009: NOT
64010: PUSH
64011: LD_EXP 126
64015: NOT
64016: OR
64017: PUSH
64018: LD_EXP 99
64022: NOT
64023: OR
64024: IFFALSE 64028
// exit ;
64026: GO 64261
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
64028: LD_ADDR_EXP 126
64032: PUSH
64033: LD_EXP 126
64037: PPUSH
64038: LD_VAR 0 4
64042: PPUSH
64043: LD_EXP 126
64047: PUSH
64048: LD_VAR 0 4
64052: ARRAY
64053: PUSH
64054: LD_VAR 0 1
64058: DIFF
64059: PPUSH
64060: CALL_OW 1
64064: ST_TO_ADDR
// for i = 1 to mc_bases do
64065: LD_ADDR_VAR 0 5
64069: PUSH
64070: DOUBLE
64071: LD_INT 1
64073: DEC
64074: ST_TO_ADDR
64075: LD_EXP 99
64079: PUSH
64080: FOR_TO
64081: IFFALSE 64259
// begin if lab in mc_bases [ i ] then
64083: LD_VAR 0 2
64087: PUSH
64088: LD_EXP 99
64092: PUSH
64093: LD_VAR 0 5
64097: ARRAY
64098: IN
64099: IFFALSE 64257
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64101: LD_VAR 0 1
64105: PUSH
64106: LD_INT 11
64108: PUSH
64109: LD_INT 4
64111: PUSH
64112: LD_INT 3
64114: PUSH
64115: LD_INT 2
64117: PUSH
64118: EMPTY
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: IN
64124: PUSH
64125: LD_EXP 129
64129: PUSH
64130: LD_VAR 0 5
64134: ARRAY
64135: AND
64136: IFFALSE 64257
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64138: LD_ADDR_VAR 0 6
64142: PUSH
64143: LD_EXP 129
64147: PUSH
64148: LD_VAR 0 5
64152: ARRAY
64153: PUSH
64154: LD_INT 1
64156: ARRAY
64157: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64158: LD_ADDR_EXP 129
64162: PUSH
64163: LD_EXP 129
64167: PPUSH
64168: LD_VAR 0 5
64172: PPUSH
64173: EMPTY
64174: PPUSH
64175: CALL_OW 1
64179: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64180: LD_VAR 0 6
64184: PPUSH
64185: LD_INT 0
64187: PPUSH
64188: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64192: LD_VAR 0 6
64196: PPUSH
64197: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64201: LD_ADDR_EXP 128
64205: PUSH
64206: LD_EXP 128
64210: PPUSH
64211: LD_VAR 0 5
64215: PPUSH
64216: LD_EXP 128
64220: PUSH
64221: LD_VAR 0 5
64225: ARRAY
64226: PPUSH
64227: LD_INT 1
64229: PPUSH
64230: LD_VAR 0 6
64234: PPUSH
64235: CALL_OW 2
64239: PPUSH
64240: CALL_OW 1
64244: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64245: LD_VAR 0 5
64249: PPUSH
64250: LD_INT 112
64252: PPUSH
64253: CALL 40747 0 2
// end ; end ; end ;
64257: GO 64080
64259: POP
64260: POP
// end ;
64261: LD_VAR 0 3
64265: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64266: LD_INT 0
64268: PPUSH
64269: PPUSH
64270: PPUSH
64271: PPUSH
64272: PPUSH
64273: PPUSH
64274: PPUSH
64275: PPUSH
// if not mc_bases or not skirmish then
64276: LD_EXP 99
64280: NOT
64281: PUSH
64282: LD_EXP 97
64286: NOT
64287: OR
64288: IFFALSE 64292
// exit ;
64290: GO 65661
// for i = 1 to mc_bases do
64292: LD_ADDR_VAR 0 3
64296: PUSH
64297: DOUBLE
64298: LD_INT 1
64300: DEC
64301: ST_TO_ADDR
64302: LD_EXP 99
64306: PUSH
64307: FOR_TO
64308: IFFALSE 65659
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
64310: LD_VAR 0 1
64314: PUSH
64315: LD_EXP 99
64319: PUSH
64320: LD_VAR 0 3
64324: ARRAY
64325: IN
64326: PUSH
64327: LD_VAR 0 1
64331: PUSH
64332: LD_EXP 106
64336: PUSH
64337: LD_VAR 0 3
64341: ARRAY
64342: IN
64343: OR
64344: PUSH
64345: LD_VAR 0 1
64349: PUSH
64350: LD_EXP 121
64354: PUSH
64355: LD_VAR 0 3
64359: ARRAY
64360: IN
64361: OR
64362: PUSH
64363: LD_VAR 0 1
64367: PUSH
64368: LD_EXP 118
64372: PUSH
64373: LD_VAR 0 3
64377: ARRAY
64378: IN
64379: OR
64380: PUSH
64381: LD_VAR 0 1
64385: PUSH
64386: LD_EXP 128
64390: PUSH
64391: LD_VAR 0 3
64395: ARRAY
64396: IN
64397: OR
64398: PUSH
64399: LD_VAR 0 1
64403: PUSH
64404: LD_EXP 129
64408: PUSH
64409: LD_VAR 0 3
64413: ARRAY
64414: IN
64415: OR
64416: IFFALSE 65657
// begin if un in mc_ape [ i ] then
64418: LD_VAR 0 1
64422: PUSH
64423: LD_EXP 128
64427: PUSH
64428: LD_VAR 0 3
64432: ARRAY
64433: IN
64434: IFFALSE 64473
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
64436: LD_ADDR_EXP 128
64440: PUSH
64441: LD_EXP 128
64445: PPUSH
64446: LD_VAR 0 3
64450: PPUSH
64451: LD_EXP 128
64455: PUSH
64456: LD_VAR 0 3
64460: ARRAY
64461: PUSH
64462: LD_VAR 0 1
64466: DIFF
64467: PPUSH
64468: CALL_OW 1
64472: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
64473: LD_VAR 0 1
64477: PUSH
64478: LD_EXP 129
64482: PUSH
64483: LD_VAR 0 3
64487: ARRAY
64488: IN
64489: IFFALSE 64513
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64491: LD_ADDR_EXP 129
64495: PUSH
64496: LD_EXP 129
64500: PPUSH
64501: LD_VAR 0 3
64505: PPUSH
64506: EMPTY
64507: PPUSH
64508: CALL_OW 1
64512: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
64513: LD_VAR 0 1
64517: PPUSH
64518: CALL_OW 247
64522: PUSH
64523: LD_INT 2
64525: EQUAL
64526: PUSH
64527: LD_VAR 0 1
64531: PPUSH
64532: CALL_OW 110
64536: PUSH
64537: LD_INT 20
64539: EQUAL
64540: PUSH
64541: LD_VAR 0 1
64545: PUSH
64546: LD_EXP 121
64550: PUSH
64551: LD_VAR 0 3
64555: ARRAY
64556: IN
64557: OR
64558: PUSH
64559: LD_VAR 0 1
64563: PPUSH
64564: CALL_OW 264
64568: PUSH
64569: LD_INT 12
64571: PUSH
64572: LD_INT 51
64574: PUSH
64575: LD_INT 89
64577: PUSH
64578: LD_INT 32
64580: PUSH
64581: LD_INT 13
64583: PUSH
64584: LD_INT 52
64586: PUSH
64587: LD_INT 31
64589: PUSH
64590: EMPTY
64591: LIST
64592: LIST
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: LIST
64598: IN
64599: OR
64600: AND
64601: IFFALSE 64909
// begin if un in mc_defender [ i ] then
64603: LD_VAR 0 1
64607: PUSH
64608: LD_EXP 121
64612: PUSH
64613: LD_VAR 0 3
64617: ARRAY
64618: IN
64619: IFFALSE 64658
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64621: LD_ADDR_EXP 121
64625: PUSH
64626: LD_EXP 121
64630: PPUSH
64631: LD_VAR 0 3
64635: PPUSH
64636: LD_EXP 121
64640: PUSH
64641: LD_VAR 0 3
64645: ARRAY
64646: PUSH
64647: LD_VAR 0 1
64651: DIFF
64652: PPUSH
64653: CALL_OW 1
64657: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
64658: LD_ADDR_VAR 0 8
64662: PUSH
64663: LD_VAR 0 3
64667: PPUSH
64668: LD_INT 3
64670: PPUSH
64671: CALL 61317 0 2
64675: ST_TO_ADDR
// if fac then
64676: LD_VAR 0 8
64680: IFFALSE 64909
// begin for j in fac do
64682: LD_ADDR_VAR 0 4
64686: PUSH
64687: LD_VAR 0 8
64691: PUSH
64692: FOR_IN
64693: IFFALSE 64907
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
64695: LD_ADDR_VAR 0 9
64699: PUSH
64700: LD_VAR 0 8
64704: PPUSH
64705: LD_VAR 0 1
64709: PPUSH
64710: CALL_OW 265
64714: PPUSH
64715: LD_VAR 0 1
64719: PPUSH
64720: CALL_OW 262
64724: PPUSH
64725: LD_VAR 0 1
64729: PPUSH
64730: CALL_OW 263
64734: PPUSH
64735: LD_VAR 0 1
64739: PPUSH
64740: CALL_OW 264
64744: PPUSH
64745: CALL 69885 0 5
64749: ST_TO_ADDR
// if components then
64750: LD_VAR 0 9
64754: IFFALSE 64905
// begin if GetWeapon ( un ) = ar_control_tower then
64756: LD_VAR 0 1
64760: PPUSH
64761: CALL_OW 264
64765: PUSH
64766: LD_INT 31
64768: EQUAL
64769: IFFALSE 64886
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
64771: LD_VAR 0 1
64775: PPUSH
64776: CALL_OW 311
64780: PPUSH
64781: LD_INT 0
64783: PPUSH
64784: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
64788: LD_ADDR_EXP 139
64792: PUSH
64793: LD_EXP 139
64797: PPUSH
64798: LD_VAR 0 3
64802: PPUSH
64803: LD_EXP 139
64807: PUSH
64808: LD_VAR 0 3
64812: ARRAY
64813: PUSH
64814: LD_VAR 0 1
64818: PPUSH
64819: CALL_OW 311
64823: DIFF
64824: PPUSH
64825: CALL_OW 1
64829: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
64830: LD_ADDR_VAR 0 7
64834: PUSH
64835: LD_EXP 120
64839: PUSH
64840: LD_VAR 0 3
64844: ARRAY
64845: PPUSH
64846: LD_INT 1
64848: PPUSH
64849: LD_VAR 0 9
64853: PPUSH
64854: CALL_OW 2
64858: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
64859: LD_ADDR_EXP 120
64863: PUSH
64864: LD_EXP 120
64868: PPUSH
64869: LD_VAR 0 3
64873: PPUSH
64874: LD_VAR 0 7
64878: PPUSH
64879: CALL_OW 1
64883: ST_TO_ADDR
// end else
64884: GO 64903
// MC_InsertProduceList ( i , [ components ] ) ;
64886: LD_VAR 0 3
64890: PPUSH
64891: LD_VAR 0 9
64895: PUSH
64896: EMPTY
64897: LIST
64898: PPUSH
64899: CALL 60862 0 2
// break ;
64903: GO 64907
// end ; end ;
64905: GO 64692
64907: POP
64908: POP
// end ; end ; if GetType ( un ) = unit_building then
64909: LD_VAR 0 1
64913: PPUSH
64914: CALL_OW 247
64918: PUSH
64919: LD_INT 3
64921: EQUAL
64922: IFFALSE 65325
// begin btype := GetBType ( un ) ;
64924: LD_ADDR_VAR 0 5
64928: PUSH
64929: LD_VAR 0 1
64933: PPUSH
64934: CALL_OW 266
64938: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
64939: LD_VAR 0 5
64943: PUSH
64944: LD_INT 29
64946: PUSH
64947: LD_INT 30
64949: PUSH
64950: EMPTY
64951: LIST
64952: LIST
64953: IN
64954: IFFALSE 65027
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
64956: LD_VAR 0 1
64960: PPUSH
64961: CALL_OW 250
64965: PPUSH
64966: LD_VAR 0 1
64970: PPUSH
64971: CALL_OW 251
64975: PPUSH
64976: LD_VAR 0 1
64980: PPUSH
64981: CALL_OW 255
64985: PPUSH
64986: CALL_OW 440
64990: NOT
64991: IFFALSE 65027
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
64993: LD_VAR 0 1
64997: PPUSH
64998: CALL_OW 250
65002: PPUSH
65003: LD_VAR 0 1
65007: PPUSH
65008: CALL_OW 251
65012: PPUSH
65013: LD_VAR 0 1
65017: PPUSH
65018: CALL_OW 255
65022: PPUSH
65023: CALL_OW 441
// end ; if btype = b_warehouse then
65027: LD_VAR 0 5
65031: PUSH
65032: LD_INT 1
65034: EQUAL
65035: IFFALSE 65053
// begin btype := b_depot ;
65037: LD_ADDR_VAR 0 5
65041: PUSH
65042: LD_INT 0
65044: ST_TO_ADDR
// pos := 1 ;
65045: LD_ADDR_VAR 0 6
65049: PUSH
65050: LD_INT 1
65052: ST_TO_ADDR
// end ; if btype = b_factory then
65053: LD_VAR 0 5
65057: PUSH
65058: LD_INT 3
65060: EQUAL
65061: IFFALSE 65079
// begin btype := b_workshop ;
65063: LD_ADDR_VAR 0 5
65067: PUSH
65068: LD_INT 2
65070: ST_TO_ADDR
// pos := 1 ;
65071: LD_ADDR_VAR 0 6
65075: PUSH
65076: LD_INT 1
65078: ST_TO_ADDR
// end ; if btype = b_barracks then
65079: LD_VAR 0 5
65083: PUSH
65084: LD_INT 5
65086: EQUAL
65087: IFFALSE 65097
// btype := b_armoury ;
65089: LD_ADDR_VAR 0 5
65093: PUSH
65094: LD_INT 4
65096: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65097: LD_VAR 0 5
65101: PUSH
65102: LD_INT 7
65104: PUSH
65105: LD_INT 8
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: IN
65112: IFFALSE 65122
// btype := b_lab ;
65114: LD_ADDR_VAR 0 5
65118: PUSH
65119: LD_INT 6
65121: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65122: LD_ADDR_EXP 104
65126: PUSH
65127: LD_EXP 104
65131: PPUSH
65132: LD_VAR 0 3
65136: PUSH
65137: LD_EXP 104
65141: PUSH
65142: LD_VAR 0 3
65146: ARRAY
65147: PUSH
65148: LD_INT 1
65150: PLUS
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PPUSH
65156: LD_VAR 0 5
65160: PUSH
65161: LD_VAR 0 1
65165: PPUSH
65166: CALL_OW 250
65170: PUSH
65171: LD_VAR 0 1
65175: PPUSH
65176: CALL_OW 251
65180: PUSH
65181: LD_VAR 0 1
65185: PPUSH
65186: CALL_OW 254
65190: PUSH
65191: EMPTY
65192: LIST
65193: LIST
65194: LIST
65195: LIST
65196: PPUSH
65197: CALL 72387 0 3
65201: ST_TO_ADDR
// if pos = 1 then
65202: LD_VAR 0 6
65206: PUSH
65207: LD_INT 1
65209: EQUAL
65210: IFFALSE 65325
// begin tmp := mc_build_list [ i ] ;
65212: LD_ADDR_VAR 0 7
65216: PUSH
65217: LD_EXP 104
65221: PUSH
65222: LD_VAR 0 3
65226: ARRAY
65227: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65228: LD_VAR 0 7
65232: PPUSH
65233: LD_INT 2
65235: PUSH
65236: LD_INT 30
65238: PUSH
65239: LD_INT 0
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: PUSH
65246: LD_INT 30
65248: PUSH
65249: LD_INT 1
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: EMPTY
65257: LIST
65258: LIST
65259: LIST
65260: PPUSH
65261: CALL_OW 72
65265: IFFALSE 65275
// pos := 2 ;
65267: LD_ADDR_VAR 0 6
65271: PUSH
65272: LD_INT 2
65274: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65275: LD_ADDR_VAR 0 7
65279: PUSH
65280: LD_VAR 0 7
65284: PPUSH
65285: LD_VAR 0 6
65289: PPUSH
65290: LD_VAR 0 7
65294: PPUSH
65295: CALL 72713 0 3
65299: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
65300: LD_ADDR_EXP 104
65304: PUSH
65305: LD_EXP 104
65309: PPUSH
65310: LD_VAR 0 3
65314: PPUSH
65315: LD_VAR 0 7
65319: PPUSH
65320: CALL_OW 1
65324: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
65325: LD_VAR 0 1
65329: PUSH
65330: LD_EXP 99
65334: PUSH
65335: LD_VAR 0 3
65339: ARRAY
65340: IN
65341: IFFALSE 65380
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
65343: LD_ADDR_EXP 99
65347: PUSH
65348: LD_EXP 99
65352: PPUSH
65353: LD_VAR 0 3
65357: PPUSH
65358: LD_EXP 99
65362: PUSH
65363: LD_VAR 0 3
65367: ARRAY
65368: PUSH
65369: LD_VAR 0 1
65373: DIFF
65374: PPUSH
65375: CALL_OW 1
65379: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
65380: LD_VAR 0 1
65384: PUSH
65385: LD_EXP 106
65389: PUSH
65390: LD_VAR 0 3
65394: ARRAY
65395: IN
65396: IFFALSE 65435
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
65398: LD_ADDR_EXP 106
65402: PUSH
65403: LD_EXP 106
65407: PPUSH
65408: LD_VAR 0 3
65412: PPUSH
65413: LD_EXP 106
65417: PUSH
65418: LD_VAR 0 3
65422: ARRAY
65423: PUSH
65424: LD_VAR 0 1
65428: DIFF
65429: PPUSH
65430: CALL_OW 1
65434: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
65435: LD_VAR 0 1
65439: PUSH
65440: LD_EXP 118
65444: PUSH
65445: LD_VAR 0 3
65449: ARRAY
65450: IN
65451: IFFALSE 65490
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
65453: LD_ADDR_EXP 118
65457: PUSH
65458: LD_EXP 118
65462: PPUSH
65463: LD_VAR 0 3
65467: PPUSH
65468: LD_EXP 118
65472: PUSH
65473: LD_VAR 0 3
65477: ARRAY
65478: PUSH
65479: LD_VAR 0 1
65483: DIFF
65484: PPUSH
65485: CALL_OW 1
65489: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
65490: LD_VAR 0 1
65494: PUSH
65495: LD_EXP 121
65499: PUSH
65500: LD_VAR 0 3
65504: ARRAY
65505: IN
65506: IFFALSE 65545
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65508: LD_ADDR_EXP 121
65512: PUSH
65513: LD_EXP 121
65517: PPUSH
65518: LD_VAR 0 3
65522: PPUSH
65523: LD_EXP 121
65527: PUSH
65528: LD_VAR 0 3
65532: ARRAY
65533: PUSH
65534: LD_VAR 0 1
65538: DIFF
65539: PPUSH
65540: CALL_OW 1
65544: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
65545: LD_VAR 0 1
65549: PUSH
65550: LD_EXP 108
65554: PUSH
65555: LD_VAR 0 3
65559: ARRAY
65560: IN
65561: IFFALSE 65600
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
65563: LD_ADDR_EXP 108
65567: PUSH
65568: LD_EXP 108
65572: PPUSH
65573: LD_VAR 0 3
65577: PPUSH
65578: LD_EXP 108
65582: PUSH
65583: LD_VAR 0 3
65587: ARRAY
65588: PUSH
65589: LD_VAR 0 1
65593: DIFF
65594: PPUSH
65595: CALL_OW 1
65599: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
65600: LD_VAR 0 1
65604: PUSH
65605: LD_EXP 107
65609: PUSH
65610: LD_VAR 0 3
65614: ARRAY
65615: IN
65616: IFFALSE 65655
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
65618: LD_ADDR_EXP 107
65622: PUSH
65623: LD_EXP 107
65627: PPUSH
65628: LD_VAR 0 3
65632: PPUSH
65633: LD_EXP 107
65637: PUSH
65638: LD_VAR 0 3
65642: ARRAY
65643: PUSH
65644: LD_VAR 0 1
65648: DIFF
65649: PPUSH
65650: CALL_OW 1
65654: ST_TO_ADDR
// end ; break ;
65655: GO 65659
// end ;
65657: GO 64307
65659: POP
65660: POP
// end ;
65661: LD_VAR 0 2
65665: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
65666: LD_INT 0
65668: PPUSH
65669: PPUSH
65670: PPUSH
// if not mc_bases or not skirmish then
65671: LD_EXP 99
65675: NOT
65676: PUSH
65677: LD_EXP 97
65681: NOT
65682: OR
65683: IFFALSE 65687
// exit ;
65685: GO 65902
// for i = 1 to mc_bases do
65687: LD_ADDR_VAR 0 3
65691: PUSH
65692: DOUBLE
65693: LD_INT 1
65695: DEC
65696: ST_TO_ADDR
65697: LD_EXP 99
65701: PUSH
65702: FOR_TO
65703: IFFALSE 65900
// begin if building in mc_construct_list [ i ] then
65705: LD_VAR 0 1
65709: PUSH
65710: LD_EXP 106
65714: PUSH
65715: LD_VAR 0 3
65719: ARRAY
65720: IN
65721: IFFALSE 65898
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
65723: LD_ADDR_EXP 106
65727: PUSH
65728: LD_EXP 106
65732: PPUSH
65733: LD_VAR 0 3
65737: PPUSH
65738: LD_EXP 106
65742: PUSH
65743: LD_VAR 0 3
65747: ARRAY
65748: PUSH
65749: LD_VAR 0 1
65753: DIFF
65754: PPUSH
65755: CALL_OW 1
65759: ST_TO_ADDR
// if building in mc_lab [ i ] then
65760: LD_VAR 0 1
65764: PUSH
65765: LD_EXP 132
65769: PUSH
65770: LD_VAR 0 3
65774: ARRAY
65775: IN
65776: IFFALSE 65831
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
65778: LD_ADDR_EXP 133
65782: PUSH
65783: LD_EXP 133
65787: PPUSH
65788: LD_VAR 0 3
65792: PPUSH
65793: LD_EXP 133
65797: PUSH
65798: LD_VAR 0 3
65802: ARRAY
65803: PPUSH
65804: LD_INT 1
65806: PPUSH
65807: LD_EXP 133
65811: PUSH
65812: LD_VAR 0 3
65816: ARRAY
65817: PPUSH
65818: LD_INT 0
65820: PPUSH
65821: CALL 71805 0 4
65825: PPUSH
65826: CALL_OW 1
65830: ST_TO_ADDR
// if not building in mc_bases [ i ] then
65831: LD_VAR 0 1
65835: PUSH
65836: LD_EXP 99
65840: PUSH
65841: LD_VAR 0 3
65845: ARRAY
65846: IN
65847: NOT
65848: IFFALSE 65894
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
65850: LD_ADDR_EXP 99
65854: PUSH
65855: LD_EXP 99
65859: PPUSH
65860: LD_VAR 0 3
65864: PUSH
65865: LD_EXP 99
65869: PUSH
65870: LD_VAR 0 3
65874: ARRAY
65875: PUSH
65876: LD_INT 1
65878: PLUS
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PPUSH
65884: LD_VAR 0 1
65888: PPUSH
65889: CALL 72387 0 3
65893: ST_TO_ADDR
// exit ;
65894: POP
65895: POP
65896: GO 65902
// end ; end ;
65898: GO 65702
65900: POP
65901: POP
// end ;
65902: LD_VAR 0 2
65906: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
65907: LD_INT 0
65909: PPUSH
65910: PPUSH
65911: PPUSH
65912: PPUSH
65913: PPUSH
65914: PPUSH
65915: PPUSH
// if not mc_bases or not skirmish then
65916: LD_EXP 99
65920: NOT
65921: PUSH
65922: LD_EXP 97
65926: NOT
65927: OR
65928: IFFALSE 65932
// exit ;
65930: GO 66593
// for i = 1 to mc_bases do
65932: LD_ADDR_VAR 0 3
65936: PUSH
65937: DOUBLE
65938: LD_INT 1
65940: DEC
65941: ST_TO_ADDR
65942: LD_EXP 99
65946: PUSH
65947: FOR_TO
65948: IFFALSE 66591
// begin if building in mc_construct_list [ i ] then
65950: LD_VAR 0 1
65954: PUSH
65955: LD_EXP 106
65959: PUSH
65960: LD_VAR 0 3
65964: ARRAY
65965: IN
65966: IFFALSE 66589
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
65968: LD_ADDR_EXP 106
65972: PUSH
65973: LD_EXP 106
65977: PPUSH
65978: LD_VAR 0 3
65982: PPUSH
65983: LD_EXP 106
65987: PUSH
65988: LD_VAR 0 3
65992: ARRAY
65993: PUSH
65994: LD_VAR 0 1
65998: DIFF
65999: PPUSH
66000: CALL_OW 1
66004: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66005: LD_ADDR_EXP 99
66009: PUSH
66010: LD_EXP 99
66014: PPUSH
66015: LD_VAR 0 3
66019: PUSH
66020: LD_EXP 99
66024: PUSH
66025: LD_VAR 0 3
66029: ARRAY
66030: PUSH
66031: LD_INT 1
66033: PLUS
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PPUSH
66039: LD_VAR 0 1
66043: PPUSH
66044: CALL 72387 0 3
66048: ST_TO_ADDR
// btype := GetBType ( building ) ;
66049: LD_ADDR_VAR 0 5
66053: PUSH
66054: LD_VAR 0 1
66058: PPUSH
66059: CALL_OW 266
66063: ST_TO_ADDR
// side := GetSide ( building ) ;
66064: LD_ADDR_VAR 0 8
66068: PUSH
66069: LD_VAR 0 1
66073: PPUSH
66074: CALL_OW 255
66078: ST_TO_ADDR
// if btype = b_lab then
66079: LD_VAR 0 5
66083: PUSH
66084: LD_INT 6
66086: EQUAL
66087: IFFALSE 66137
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66089: LD_ADDR_EXP 132
66093: PUSH
66094: LD_EXP 132
66098: PPUSH
66099: LD_VAR 0 3
66103: PUSH
66104: LD_EXP 132
66108: PUSH
66109: LD_VAR 0 3
66113: ARRAY
66114: PUSH
66115: LD_INT 1
66117: PLUS
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: PPUSH
66123: LD_VAR 0 1
66127: PPUSH
66128: CALL 72387 0 3
66132: ST_TO_ADDR
// exit ;
66133: POP
66134: POP
66135: GO 66593
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66137: LD_VAR 0 5
66141: PUSH
66142: LD_INT 0
66144: PUSH
66145: LD_INT 2
66147: PUSH
66148: LD_INT 4
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: LIST
66155: IN
66156: IFFALSE 66280
// begin if btype = b_armoury then
66158: LD_VAR 0 5
66162: PUSH
66163: LD_INT 4
66165: EQUAL
66166: IFFALSE 66176
// btype := b_barracks ;
66168: LD_ADDR_VAR 0 5
66172: PUSH
66173: LD_INT 5
66175: ST_TO_ADDR
// if btype = b_depot then
66176: LD_VAR 0 5
66180: PUSH
66181: LD_INT 0
66183: EQUAL
66184: IFFALSE 66194
// btype := b_warehouse ;
66186: LD_ADDR_VAR 0 5
66190: PUSH
66191: LD_INT 1
66193: ST_TO_ADDR
// if btype = b_workshop then
66194: LD_VAR 0 5
66198: PUSH
66199: LD_INT 2
66201: EQUAL
66202: IFFALSE 66212
// btype := b_factory ;
66204: LD_ADDR_VAR 0 5
66208: PUSH
66209: LD_INT 3
66211: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66212: LD_VAR 0 5
66216: PPUSH
66217: LD_VAR 0 8
66221: PPUSH
66222: CALL_OW 323
66226: PUSH
66227: LD_INT 1
66229: EQUAL
66230: IFFALSE 66276
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66232: LD_ADDR_EXP 131
66236: PUSH
66237: LD_EXP 131
66241: PPUSH
66242: LD_VAR 0 3
66246: PUSH
66247: LD_EXP 131
66251: PUSH
66252: LD_VAR 0 3
66256: ARRAY
66257: PUSH
66258: LD_INT 1
66260: PLUS
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: PPUSH
66266: LD_VAR 0 1
66270: PPUSH
66271: CALL 72387 0 3
66275: ST_TO_ADDR
// exit ;
66276: POP
66277: POP
66278: GO 66593
// end ; if btype in [ b_bunker , b_turret ] then
66280: LD_VAR 0 5
66284: PUSH
66285: LD_INT 32
66287: PUSH
66288: LD_INT 33
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: IN
66295: IFFALSE 66585
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
66297: LD_ADDR_EXP 107
66301: PUSH
66302: LD_EXP 107
66306: PPUSH
66307: LD_VAR 0 3
66311: PUSH
66312: LD_EXP 107
66316: PUSH
66317: LD_VAR 0 3
66321: ARRAY
66322: PUSH
66323: LD_INT 1
66325: PLUS
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PPUSH
66331: LD_VAR 0 1
66335: PPUSH
66336: CALL 72387 0 3
66340: ST_TO_ADDR
// if btype = b_bunker then
66341: LD_VAR 0 5
66345: PUSH
66346: LD_INT 32
66348: EQUAL
66349: IFFALSE 66585
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66351: LD_ADDR_EXP 108
66355: PUSH
66356: LD_EXP 108
66360: PPUSH
66361: LD_VAR 0 3
66365: PUSH
66366: LD_EXP 108
66370: PUSH
66371: LD_VAR 0 3
66375: ARRAY
66376: PUSH
66377: LD_INT 1
66379: PLUS
66380: PUSH
66381: EMPTY
66382: LIST
66383: LIST
66384: PPUSH
66385: LD_VAR 0 1
66389: PPUSH
66390: CALL 72387 0 3
66394: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
66395: LD_ADDR_VAR 0 6
66399: PUSH
66400: LD_EXP 99
66404: PUSH
66405: LD_VAR 0 3
66409: ARRAY
66410: PPUSH
66411: LD_INT 25
66413: PUSH
66414: LD_INT 1
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 3
66423: PUSH
66424: LD_INT 54
66426: PUSH
66427: EMPTY
66428: LIST
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: EMPTY
66435: LIST
66436: LIST
66437: PPUSH
66438: CALL_OW 72
66442: ST_TO_ADDR
// if tmp then
66443: LD_VAR 0 6
66447: IFFALSE 66453
// exit ;
66449: POP
66450: POP
66451: GO 66593
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66453: LD_ADDR_VAR 0 6
66457: PUSH
66458: LD_EXP 99
66462: PUSH
66463: LD_VAR 0 3
66467: ARRAY
66468: PPUSH
66469: LD_INT 2
66471: PUSH
66472: LD_INT 30
66474: PUSH
66475: LD_INT 4
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: PUSH
66482: LD_INT 30
66484: PUSH
66485: LD_INT 5
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: LIST
66496: PPUSH
66497: CALL_OW 72
66501: ST_TO_ADDR
// if not tmp then
66502: LD_VAR 0 6
66506: NOT
66507: IFFALSE 66513
// exit ;
66509: POP
66510: POP
66511: GO 66593
// for j in tmp do
66513: LD_ADDR_VAR 0 4
66517: PUSH
66518: LD_VAR 0 6
66522: PUSH
66523: FOR_IN
66524: IFFALSE 66583
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
66526: LD_ADDR_VAR 0 7
66530: PUSH
66531: LD_VAR 0 4
66535: PPUSH
66536: CALL_OW 313
66540: PPUSH
66541: LD_INT 25
66543: PUSH
66544: LD_INT 1
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: PPUSH
66551: CALL_OW 72
66555: ST_TO_ADDR
// if units then
66556: LD_VAR 0 7
66560: IFFALSE 66581
// begin ComExitBuilding ( units [ 1 ] ) ;
66562: LD_VAR 0 7
66566: PUSH
66567: LD_INT 1
66569: ARRAY
66570: PPUSH
66571: CALL_OW 122
// exit ;
66575: POP
66576: POP
66577: POP
66578: POP
66579: GO 66593
// end ; end ;
66581: GO 66523
66583: POP
66584: POP
// end ; end ; exit ;
66585: POP
66586: POP
66587: GO 66593
// end ; end ;
66589: GO 65947
66591: POP
66592: POP
// end ;
66593: LD_VAR 0 2
66597: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
66598: LD_INT 0
66600: PPUSH
66601: PPUSH
66602: PPUSH
66603: PPUSH
66604: PPUSH
66605: PPUSH
66606: PPUSH
// if not mc_bases or not skirmish then
66607: LD_EXP 99
66611: NOT
66612: PUSH
66613: LD_EXP 97
66617: NOT
66618: OR
66619: IFFALSE 66623
// exit ;
66621: GO 66888
// btype := GetBType ( building ) ;
66623: LD_ADDR_VAR 0 6
66627: PUSH
66628: LD_VAR 0 1
66632: PPUSH
66633: CALL_OW 266
66637: ST_TO_ADDR
// x := GetX ( building ) ;
66638: LD_ADDR_VAR 0 7
66642: PUSH
66643: LD_VAR 0 1
66647: PPUSH
66648: CALL_OW 250
66652: ST_TO_ADDR
// y := GetY ( building ) ;
66653: LD_ADDR_VAR 0 8
66657: PUSH
66658: LD_VAR 0 1
66662: PPUSH
66663: CALL_OW 251
66667: ST_TO_ADDR
// d := GetDir ( building ) ;
66668: LD_ADDR_VAR 0 9
66672: PUSH
66673: LD_VAR 0 1
66677: PPUSH
66678: CALL_OW 254
66682: ST_TO_ADDR
// for i = 1 to mc_bases do
66683: LD_ADDR_VAR 0 4
66687: PUSH
66688: DOUBLE
66689: LD_INT 1
66691: DEC
66692: ST_TO_ADDR
66693: LD_EXP 99
66697: PUSH
66698: FOR_TO
66699: IFFALSE 66886
// begin if not mc_build_list [ i ] then
66701: LD_EXP 104
66705: PUSH
66706: LD_VAR 0 4
66710: ARRAY
66711: NOT
66712: IFFALSE 66716
// continue ;
66714: GO 66698
// for j := 1 to mc_build_list [ i ] do
66716: LD_ADDR_VAR 0 5
66720: PUSH
66721: DOUBLE
66722: LD_INT 1
66724: DEC
66725: ST_TO_ADDR
66726: LD_EXP 104
66730: PUSH
66731: LD_VAR 0 4
66735: ARRAY
66736: PUSH
66737: FOR_TO
66738: IFFALSE 66882
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
66740: LD_VAR 0 6
66744: PUSH
66745: LD_VAR 0 7
66749: PUSH
66750: LD_VAR 0 8
66754: PUSH
66755: LD_VAR 0 9
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: PPUSH
66766: LD_EXP 104
66770: PUSH
66771: LD_VAR 0 4
66775: ARRAY
66776: PUSH
66777: LD_VAR 0 5
66781: ARRAY
66782: PPUSH
66783: CALL 78567 0 2
66787: IFFALSE 66880
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
66789: LD_ADDR_EXP 104
66793: PUSH
66794: LD_EXP 104
66798: PPUSH
66799: LD_VAR 0 4
66803: PPUSH
66804: LD_EXP 104
66808: PUSH
66809: LD_VAR 0 4
66813: ARRAY
66814: PPUSH
66815: LD_VAR 0 5
66819: PPUSH
66820: CALL_OW 3
66824: PPUSH
66825: CALL_OW 1
66829: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
66830: LD_ADDR_EXP 106
66834: PUSH
66835: LD_EXP 106
66839: PPUSH
66840: LD_VAR 0 4
66844: PUSH
66845: LD_EXP 106
66849: PUSH
66850: LD_VAR 0 4
66854: ARRAY
66855: PUSH
66856: LD_INT 1
66858: PLUS
66859: PUSH
66860: EMPTY
66861: LIST
66862: LIST
66863: PPUSH
66864: LD_VAR 0 1
66868: PPUSH
66869: CALL 72387 0 3
66873: ST_TO_ADDR
// exit ;
66874: POP
66875: POP
66876: POP
66877: POP
66878: GO 66888
// end ;
66880: GO 66737
66882: POP
66883: POP
// end ;
66884: GO 66698
66886: POP
66887: POP
// end ;
66888: LD_VAR 0 3
66892: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
66893: LD_INT 0
66895: PPUSH
66896: PPUSH
66897: PPUSH
// if not mc_bases or not skirmish then
66898: LD_EXP 99
66902: NOT
66903: PUSH
66904: LD_EXP 97
66908: NOT
66909: OR
66910: IFFALSE 66914
// exit ;
66912: GO 67104
// for i = 1 to mc_bases do
66914: LD_ADDR_VAR 0 4
66918: PUSH
66919: DOUBLE
66920: LD_INT 1
66922: DEC
66923: ST_TO_ADDR
66924: LD_EXP 99
66928: PUSH
66929: FOR_TO
66930: IFFALSE 67017
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
66932: LD_VAR 0 1
66936: PUSH
66937: LD_EXP 107
66941: PUSH
66942: LD_VAR 0 4
66946: ARRAY
66947: IN
66948: PUSH
66949: LD_VAR 0 1
66953: PUSH
66954: LD_EXP 108
66958: PUSH
66959: LD_VAR 0 4
66963: ARRAY
66964: IN
66965: NOT
66966: AND
66967: IFFALSE 67015
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66969: LD_ADDR_EXP 108
66973: PUSH
66974: LD_EXP 108
66978: PPUSH
66979: LD_VAR 0 4
66983: PUSH
66984: LD_EXP 108
66988: PUSH
66989: LD_VAR 0 4
66993: ARRAY
66994: PUSH
66995: LD_INT 1
66997: PLUS
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PPUSH
67003: LD_VAR 0 1
67007: PPUSH
67008: CALL 72387 0 3
67012: ST_TO_ADDR
// break ;
67013: GO 67017
// end ; end ;
67015: GO 66929
67017: POP
67018: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
67019: LD_VAR 0 1
67023: PPUSH
67024: CALL_OW 257
67028: PUSH
67029: LD_EXP 125
67033: IN
67034: PUSH
67035: LD_VAR 0 1
67039: PPUSH
67040: CALL_OW 266
67044: PUSH
67045: LD_INT 5
67047: EQUAL
67048: AND
67049: PUSH
67050: LD_VAR 0 2
67054: PPUSH
67055: CALL_OW 110
67059: PUSH
67060: LD_INT 18
67062: NONEQUAL
67063: AND
67064: IFFALSE 67104
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67066: LD_VAR 0 2
67070: PPUSH
67071: CALL_OW 257
67075: PUSH
67076: LD_INT 5
67078: PUSH
67079: LD_INT 8
67081: PUSH
67082: LD_INT 9
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: LIST
67089: IN
67090: IFFALSE 67104
// SetClass ( unit , 1 ) ;
67092: LD_VAR 0 2
67096: PPUSH
67097: LD_INT 1
67099: PPUSH
67100: CALL_OW 336
// end ;
67104: LD_VAR 0 3
67108: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67109: LD_INT 0
67111: PPUSH
67112: PPUSH
// if not mc_bases or not skirmish then
67113: LD_EXP 99
67117: NOT
67118: PUSH
67119: LD_EXP 97
67123: NOT
67124: OR
67125: IFFALSE 67129
// exit ;
67127: GO 67245
// if GetLives ( abandoned_vehicle ) > 250 then
67129: LD_VAR 0 2
67133: PPUSH
67134: CALL_OW 256
67138: PUSH
67139: LD_INT 250
67141: GREATER
67142: IFFALSE 67146
// exit ;
67144: GO 67245
// for i = 1 to mc_bases do
67146: LD_ADDR_VAR 0 6
67150: PUSH
67151: DOUBLE
67152: LD_INT 1
67154: DEC
67155: ST_TO_ADDR
67156: LD_EXP 99
67160: PUSH
67161: FOR_TO
67162: IFFALSE 67243
// begin if driver in mc_bases [ i ] then
67164: LD_VAR 0 1
67168: PUSH
67169: LD_EXP 99
67173: PUSH
67174: LD_VAR 0 6
67178: ARRAY
67179: IN
67180: IFFALSE 67241
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67182: LD_VAR 0 1
67186: PPUSH
67187: LD_EXP 99
67191: PUSH
67192: LD_VAR 0 6
67196: ARRAY
67197: PPUSH
67198: LD_INT 2
67200: PUSH
67201: LD_INT 30
67203: PUSH
67204: LD_INT 0
67206: PUSH
67207: EMPTY
67208: LIST
67209: LIST
67210: PUSH
67211: LD_INT 30
67213: PUSH
67214: LD_INT 1
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: EMPTY
67222: LIST
67223: LIST
67224: LIST
67225: PPUSH
67226: CALL_OW 72
67230: PUSH
67231: LD_INT 1
67233: ARRAY
67234: PPUSH
67235: CALL 105576 0 2
// break ;
67239: GO 67243
// end ; end ;
67241: GO 67161
67243: POP
67244: POP
// end ; end_of_file
67245: LD_VAR 0 5
67249: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67250: LD_INT 0
67252: PPUSH
67253: PPUSH
// if exist_mode then
67254: LD_VAR 0 2
67258: IFFALSE 67283
// unit := CreateCharacter ( prefix & ident ) else
67260: LD_ADDR_VAR 0 5
67264: PUSH
67265: LD_VAR 0 3
67269: PUSH
67270: LD_VAR 0 1
67274: STR
67275: PPUSH
67276: CALL_OW 34
67280: ST_TO_ADDR
67281: GO 67298
// unit := NewCharacter ( ident ) ;
67283: LD_ADDR_VAR 0 5
67287: PUSH
67288: LD_VAR 0 1
67292: PPUSH
67293: CALL_OW 25
67297: ST_TO_ADDR
// result := unit ;
67298: LD_ADDR_VAR 0 4
67302: PUSH
67303: LD_VAR 0 5
67307: ST_TO_ADDR
// end ;
67308: LD_VAR 0 4
67312: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
67313: LD_INT 0
67315: PPUSH
67316: PPUSH
// if not side or not nation then
67317: LD_VAR 0 1
67321: NOT
67322: PUSH
67323: LD_VAR 0 2
67327: NOT
67328: OR
67329: IFFALSE 67333
// exit ;
67331: GO 68101
// case nation of nation_american :
67333: LD_VAR 0 2
67337: PUSH
67338: LD_INT 1
67340: DOUBLE
67341: EQUAL
67342: IFTRUE 67346
67344: GO 67560
67346: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
67347: LD_ADDR_VAR 0 4
67351: PUSH
67352: LD_INT 35
67354: PUSH
67355: LD_INT 45
67357: PUSH
67358: LD_INT 46
67360: PUSH
67361: LD_INT 47
67363: PUSH
67364: LD_INT 82
67366: PUSH
67367: LD_INT 83
67369: PUSH
67370: LD_INT 84
67372: PUSH
67373: LD_INT 85
67375: PUSH
67376: LD_INT 86
67378: PUSH
67379: LD_INT 1
67381: PUSH
67382: LD_INT 2
67384: PUSH
67385: LD_INT 6
67387: PUSH
67388: LD_INT 15
67390: PUSH
67391: LD_INT 16
67393: PUSH
67394: LD_INT 7
67396: PUSH
67397: LD_INT 12
67399: PUSH
67400: LD_INT 13
67402: PUSH
67403: LD_INT 10
67405: PUSH
67406: LD_INT 14
67408: PUSH
67409: LD_INT 20
67411: PUSH
67412: LD_INT 21
67414: PUSH
67415: LD_INT 22
67417: PUSH
67418: LD_INT 25
67420: PUSH
67421: LD_INT 32
67423: PUSH
67424: LD_INT 27
67426: PUSH
67427: LD_INT 36
67429: PUSH
67430: LD_INT 69
67432: PUSH
67433: LD_INT 39
67435: PUSH
67436: LD_INT 34
67438: PUSH
67439: LD_INT 40
67441: PUSH
67442: LD_INT 48
67444: PUSH
67445: LD_INT 49
67447: PUSH
67448: LD_INT 50
67450: PUSH
67451: LD_INT 51
67453: PUSH
67454: LD_INT 52
67456: PUSH
67457: LD_INT 53
67459: PUSH
67460: LD_INT 54
67462: PUSH
67463: LD_INT 55
67465: PUSH
67466: LD_INT 56
67468: PUSH
67469: LD_INT 57
67471: PUSH
67472: LD_INT 58
67474: PUSH
67475: LD_INT 59
67477: PUSH
67478: LD_INT 60
67480: PUSH
67481: LD_INT 61
67483: PUSH
67484: LD_INT 62
67486: PUSH
67487: LD_INT 80
67489: PUSH
67490: LD_INT 82
67492: PUSH
67493: LD_INT 83
67495: PUSH
67496: LD_INT 84
67498: PUSH
67499: LD_INT 85
67501: PUSH
67502: LD_INT 86
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: LIST
67512: LIST
67513: LIST
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: LIST
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: LIST
67538: LIST
67539: LIST
67540: LIST
67541: LIST
67542: LIST
67543: LIST
67544: LIST
67545: LIST
67546: LIST
67547: LIST
67548: LIST
67549: LIST
67550: LIST
67551: LIST
67552: LIST
67553: LIST
67554: LIST
67555: LIST
67556: LIST
67557: ST_TO_ADDR
67558: GO 68025
67560: LD_INT 2
67562: DOUBLE
67563: EQUAL
67564: IFTRUE 67568
67566: GO 67794
67568: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
67569: LD_ADDR_VAR 0 4
67573: PUSH
67574: LD_INT 35
67576: PUSH
67577: LD_INT 45
67579: PUSH
67580: LD_INT 46
67582: PUSH
67583: LD_INT 47
67585: PUSH
67586: LD_INT 82
67588: PUSH
67589: LD_INT 83
67591: PUSH
67592: LD_INT 84
67594: PUSH
67595: LD_INT 85
67597: PUSH
67598: LD_INT 87
67600: PUSH
67601: LD_INT 70
67603: PUSH
67604: LD_INT 1
67606: PUSH
67607: LD_INT 11
67609: PUSH
67610: LD_INT 3
67612: PUSH
67613: LD_INT 4
67615: PUSH
67616: LD_INT 5
67618: PUSH
67619: LD_INT 6
67621: PUSH
67622: LD_INT 15
67624: PUSH
67625: LD_INT 18
67627: PUSH
67628: LD_INT 7
67630: PUSH
67631: LD_INT 17
67633: PUSH
67634: LD_INT 8
67636: PUSH
67637: LD_INT 20
67639: PUSH
67640: LD_INT 21
67642: PUSH
67643: LD_INT 22
67645: PUSH
67646: LD_INT 72
67648: PUSH
67649: LD_INT 26
67651: PUSH
67652: LD_INT 69
67654: PUSH
67655: LD_INT 39
67657: PUSH
67658: LD_INT 40
67660: PUSH
67661: LD_INT 41
67663: PUSH
67664: LD_INT 42
67666: PUSH
67667: LD_INT 43
67669: PUSH
67670: LD_INT 48
67672: PUSH
67673: LD_INT 49
67675: PUSH
67676: LD_INT 50
67678: PUSH
67679: LD_INT 51
67681: PUSH
67682: LD_INT 52
67684: PUSH
67685: LD_INT 53
67687: PUSH
67688: LD_INT 54
67690: PUSH
67691: LD_INT 55
67693: PUSH
67694: LD_INT 56
67696: PUSH
67697: LD_INT 60
67699: PUSH
67700: LD_INT 61
67702: PUSH
67703: LD_INT 62
67705: PUSH
67706: LD_INT 66
67708: PUSH
67709: LD_INT 67
67711: PUSH
67712: LD_INT 68
67714: PUSH
67715: LD_INT 81
67717: PUSH
67718: LD_INT 82
67720: PUSH
67721: LD_INT 83
67723: PUSH
67724: LD_INT 84
67726: PUSH
67727: LD_INT 85
67729: PUSH
67730: LD_INT 87
67732: PUSH
67733: LD_INT 88
67735: PUSH
67736: EMPTY
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: LIST
67746: LIST
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: LIST
67779: LIST
67780: LIST
67781: LIST
67782: LIST
67783: LIST
67784: LIST
67785: LIST
67786: LIST
67787: LIST
67788: LIST
67789: LIST
67790: LIST
67791: ST_TO_ADDR
67792: GO 68025
67794: LD_INT 3
67796: DOUBLE
67797: EQUAL
67798: IFTRUE 67802
67800: GO 68024
67802: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
67803: LD_ADDR_VAR 0 4
67807: PUSH
67808: LD_INT 46
67810: PUSH
67811: LD_INT 47
67813: PUSH
67814: LD_INT 1
67816: PUSH
67817: LD_INT 2
67819: PUSH
67820: LD_INT 82
67822: PUSH
67823: LD_INT 83
67825: PUSH
67826: LD_INT 84
67828: PUSH
67829: LD_INT 85
67831: PUSH
67832: LD_INT 86
67834: PUSH
67835: LD_INT 11
67837: PUSH
67838: LD_INT 9
67840: PUSH
67841: LD_INT 20
67843: PUSH
67844: LD_INT 19
67846: PUSH
67847: LD_INT 21
67849: PUSH
67850: LD_INT 24
67852: PUSH
67853: LD_INT 22
67855: PUSH
67856: LD_INT 25
67858: PUSH
67859: LD_INT 28
67861: PUSH
67862: LD_INT 29
67864: PUSH
67865: LD_INT 30
67867: PUSH
67868: LD_INT 31
67870: PUSH
67871: LD_INT 37
67873: PUSH
67874: LD_INT 38
67876: PUSH
67877: LD_INT 32
67879: PUSH
67880: LD_INT 27
67882: PUSH
67883: LD_INT 33
67885: PUSH
67886: LD_INT 69
67888: PUSH
67889: LD_INT 39
67891: PUSH
67892: LD_INT 34
67894: PUSH
67895: LD_INT 40
67897: PUSH
67898: LD_INT 71
67900: PUSH
67901: LD_INT 23
67903: PUSH
67904: LD_INT 44
67906: PUSH
67907: LD_INT 48
67909: PUSH
67910: LD_INT 49
67912: PUSH
67913: LD_INT 50
67915: PUSH
67916: LD_INT 51
67918: PUSH
67919: LD_INT 52
67921: PUSH
67922: LD_INT 53
67924: PUSH
67925: LD_INT 54
67927: PUSH
67928: LD_INT 55
67930: PUSH
67931: LD_INT 56
67933: PUSH
67934: LD_INT 57
67936: PUSH
67937: LD_INT 58
67939: PUSH
67940: LD_INT 59
67942: PUSH
67943: LD_INT 63
67945: PUSH
67946: LD_INT 64
67948: PUSH
67949: LD_INT 65
67951: PUSH
67952: LD_INT 82
67954: PUSH
67955: LD_INT 83
67957: PUSH
67958: LD_INT 84
67960: PUSH
67961: LD_INT 85
67963: PUSH
67964: LD_INT 86
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: LIST
67978: LIST
67979: LIST
67980: LIST
67981: LIST
67982: LIST
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: LIST
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: LIST
68000: LIST
68001: LIST
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: LIST
68010: LIST
68011: LIST
68012: LIST
68013: LIST
68014: LIST
68015: LIST
68016: LIST
68017: LIST
68018: LIST
68019: LIST
68020: LIST
68021: ST_TO_ADDR
68022: GO 68025
68024: POP
// if state > - 1 and state < 3 then
68025: LD_VAR 0 3
68029: PUSH
68030: LD_INT 1
68032: NEG
68033: GREATER
68034: PUSH
68035: LD_VAR 0 3
68039: PUSH
68040: LD_INT 3
68042: LESS
68043: AND
68044: IFFALSE 68101
// for i in result do
68046: LD_ADDR_VAR 0 5
68050: PUSH
68051: LD_VAR 0 4
68055: PUSH
68056: FOR_IN
68057: IFFALSE 68099
// if GetTech ( i , side ) <> state then
68059: LD_VAR 0 5
68063: PPUSH
68064: LD_VAR 0 1
68068: PPUSH
68069: CALL_OW 321
68073: PUSH
68074: LD_VAR 0 3
68078: NONEQUAL
68079: IFFALSE 68097
// result := result diff i ;
68081: LD_ADDR_VAR 0 4
68085: PUSH
68086: LD_VAR 0 4
68090: PUSH
68091: LD_VAR 0 5
68095: DIFF
68096: ST_TO_ADDR
68097: GO 68056
68099: POP
68100: POP
// end ;
68101: LD_VAR 0 4
68105: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68106: LD_INT 0
68108: PPUSH
68109: PPUSH
68110: PPUSH
// result := true ;
68111: LD_ADDR_VAR 0 3
68115: PUSH
68116: LD_INT 1
68118: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68119: LD_ADDR_VAR 0 5
68123: PUSH
68124: LD_VAR 0 2
68128: PPUSH
68129: CALL_OW 480
68133: ST_TO_ADDR
// if not tmp then
68134: LD_VAR 0 5
68138: NOT
68139: IFFALSE 68143
// exit ;
68141: GO 68192
// for i in tmp do
68143: LD_ADDR_VAR 0 4
68147: PUSH
68148: LD_VAR 0 5
68152: PUSH
68153: FOR_IN
68154: IFFALSE 68190
// if GetTech ( i , side ) <> state_researched then
68156: LD_VAR 0 4
68160: PPUSH
68161: LD_VAR 0 1
68165: PPUSH
68166: CALL_OW 321
68170: PUSH
68171: LD_INT 2
68173: NONEQUAL
68174: IFFALSE 68188
// begin result := false ;
68176: LD_ADDR_VAR 0 3
68180: PUSH
68181: LD_INT 0
68183: ST_TO_ADDR
// exit ;
68184: POP
68185: POP
68186: GO 68192
// end ;
68188: GO 68153
68190: POP
68191: POP
// end ;
68192: LD_VAR 0 3
68196: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68197: LD_INT 0
68199: PPUSH
68200: PPUSH
68201: PPUSH
68202: PPUSH
68203: PPUSH
68204: PPUSH
68205: PPUSH
68206: PPUSH
68207: PPUSH
68208: PPUSH
68209: PPUSH
68210: PPUSH
68211: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68212: LD_VAR 0 1
68216: NOT
68217: PUSH
68218: LD_VAR 0 1
68222: PPUSH
68223: CALL_OW 257
68227: PUSH
68228: LD_INT 9
68230: NONEQUAL
68231: OR
68232: IFFALSE 68236
// exit ;
68234: GO 68809
// side := GetSide ( unit ) ;
68236: LD_ADDR_VAR 0 9
68240: PUSH
68241: LD_VAR 0 1
68245: PPUSH
68246: CALL_OW 255
68250: ST_TO_ADDR
// tech_space := tech_spacanom ;
68251: LD_ADDR_VAR 0 12
68255: PUSH
68256: LD_INT 29
68258: ST_TO_ADDR
// tech_time := tech_taurad ;
68259: LD_ADDR_VAR 0 13
68263: PUSH
68264: LD_INT 28
68266: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68267: LD_ADDR_VAR 0 11
68271: PUSH
68272: LD_VAR 0 1
68276: PPUSH
68277: CALL_OW 310
68281: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
68282: LD_VAR 0 11
68286: PPUSH
68287: CALL_OW 247
68291: PUSH
68292: LD_INT 2
68294: EQUAL
68295: IFFALSE 68299
// exit ;
68297: GO 68809
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68299: LD_ADDR_VAR 0 8
68303: PUSH
68304: LD_INT 81
68306: PUSH
68307: LD_VAR 0 9
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 3
68318: PUSH
68319: LD_INT 21
68321: PUSH
68322: LD_INT 3
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PPUSH
68337: CALL_OW 69
68341: ST_TO_ADDR
// if not tmp then
68342: LD_VAR 0 8
68346: NOT
68347: IFFALSE 68351
// exit ;
68349: GO 68809
// if in_unit then
68351: LD_VAR 0 11
68355: IFFALSE 68379
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
68357: LD_ADDR_VAR 0 10
68361: PUSH
68362: LD_VAR 0 8
68366: PPUSH
68367: LD_VAR 0 11
68371: PPUSH
68372: CALL_OW 74
68376: ST_TO_ADDR
68377: GO 68399
// enemy := NearestUnitToUnit ( tmp , unit ) ;
68379: LD_ADDR_VAR 0 10
68383: PUSH
68384: LD_VAR 0 8
68388: PPUSH
68389: LD_VAR 0 1
68393: PPUSH
68394: CALL_OW 74
68398: ST_TO_ADDR
// if not enemy then
68399: LD_VAR 0 10
68403: NOT
68404: IFFALSE 68408
// exit ;
68406: GO 68809
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
68408: LD_VAR 0 11
68412: PUSH
68413: LD_VAR 0 11
68417: PPUSH
68418: LD_VAR 0 10
68422: PPUSH
68423: CALL_OW 296
68427: PUSH
68428: LD_INT 13
68430: GREATER
68431: AND
68432: PUSH
68433: LD_VAR 0 1
68437: PPUSH
68438: LD_VAR 0 10
68442: PPUSH
68443: CALL_OW 296
68447: PUSH
68448: LD_INT 12
68450: GREATER
68451: OR
68452: IFFALSE 68456
// exit ;
68454: GO 68809
// missile := [ 1 ] ;
68456: LD_ADDR_VAR 0 14
68460: PUSH
68461: LD_INT 1
68463: PUSH
68464: EMPTY
68465: LIST
68466: ST_TO_ADDR
// if Researched ( side , tech_space ) then
68467: LD_VAR 0 9
68471: PPUSH
68472: LD_VAR 0 12
68476: PPUSH
68477: CALL_OW 325
68481: IFFALSE 68510
// missile := Replace ( missile , missile + 1 , 2 ) ;
68483: LD_ADDR_VAR 0 14
68487: PUSH
68488: LD_VAR 0 14
68492: PPUSH
68493: LD_VAR 0 14
68497: PUSH
68498: LD_INT 1
68500: PLUS
68501: PPUSH
68502: LD_INT 2
68504: PPUSH
68505: CALL_OW 1
68509: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
68510: LD_VAR 0 9
68514: PPUSH
68515: LD_VAR 0 13
68519: PPUSH
68520: CALL_OW 325
68524: PUSH
68525: LD_VAR 0 10
68529: PPUSH
68530: CALL_OW 255
68534: PPUSH
68535: LD_VAR 0 13
68539: PPUSH
68540: CALL_OW 325
68544: NOT
68545: AND
68546: IFFALSE 68575
// missile := Replace ( missile , missile + 1 , 3 ) ;
68548: LD_ADDR_VAR 0 14
68552: PUSH
68553: LD_VAR 0 14
68557: PPUSH
68558: LD_VAR 0 14
68562: PUSH
68563: LD_INT 1
68565: PLUS
68566: PPUSH
68567: LD_INT 3
68569: PPUSH
68570: CALL_OW 1
68574: ST_TO_ADDR
// if missile < 2 then
68575: LD_VAR 0 14
68579: PUSH
68580: LD_INT 2
68582: LESS
68583: IFFALSE 68587
// exit ;
68585: GO 68809
// x := GetX ( enemy ) ;
68587: LD_ADDR_VAR 0 4
68591: PUSH
68592: LD_VAR 0 10
68596: PPUSH
68597: CALL_OW 250
68601: ST_TO_ADDR
// y := GetY ( enemy ) ;
68602: LD_ADDR_VAR 0 5
68606: PUSH
68607: LD_VAR 0 10
68611: PPUSH
68612: CALL_OW 251
68616: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
68617: LD_ADDR_VAR 0 6
68621: PUSH
68622: LD_VAR 0 4
68626: PUSH
68627: LD_INT 1
68629: NEG
68630: PPUSH
68631: LD_INT 1
68633: PPUSH
68634: CALL_OW 12
68638: PLUS
68639: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
68640: LD_ADDR_VAR 0 7
68644: PUSH
68645: LD_VAR 0 5
68649: PUSH
68650: LD_INT 1
68652: NEG
68653: PPUSH
68654: LD_INT 1
68656: PPUSH
68657: CALL_OW 12
68661: PLUS
68662: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68663: LD_VAR 0 6
68667: PPUSH
68668: LD_VAR 0 7
68672: PPUSH
68673: CALL_OW 488
68677: NOT
68678: IFFALSE 68700
// begin _x := x ;
68680: LD_ADDR_VAR 0 6
68684: PUSH
68685: LD_VAR 0 4
68689: ST_TO_ADDR
// _y := y ;
68690: LD_ADDR_VAR 0 7
68694: PUSH
68695: LD_VAR 0 5
68699: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
68700: LD_ADDR_VAR 0 3
68704: PUSH
68705: LD_INT 1
68707: PPUSH
68708: LD_VAR 0 14
68712: PPUSH
68713: CALL_OW 12
68717: ST_TO_ADDR
// case i of 1 :
68718: LD_VAR 0 3
68722: PUSH
68723: LD_INT 1
68725: DOUBLE
68726: EQUAL
68727: IFTRUE 68731
68729: GO 68748
68731: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
68732: LD_VAR 0 1
68736: PPUSH
68737: LD_VAR 0 10
68741: PPUSH
68742: CALL_OW 115
68746: GO 68809
68748: LD_INT 2
68750: DOUBLE
68751: EQUAL
68752: IFTRUE 68756
68754: GO 68778
68756: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
68757: LD_VAR 0 1
68761: PPUSH
68762: LD_VAR 0 6
68766: PPUSH
68767: LD_VAR 0 7
68771: PPUSH
68772: CALL_OW 153
68776: GO 68809
68778: LD_INT 3
68780: DOUBLE
68781: EQUAL
68782: IFTRUE 68786
68784: GO 68808
68786: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
68787: LD_VAR 0 1
68791: PPUSH
68792: LD_VAR 0 6
68796: PPUSH
68797: LD_VAR 0 7
68801: PPUSH
68802: CALL_OW 154
68806: GO 68809
68808: POP
// end ;
68809: LD_VAR 0 2
68813: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
68814: LD_INT 0
68816: PPUSH
68817: PPUSH
68818: PPUSH
68819: PPUSH
68820: PPUSH
68821: PPUSH
// if not unit or not building then
68822: LD_VAR 0 1
68826: NOT
68827: PUSH
68828: LD_VAR 0 2
68832: NOT
68833: OR
68834: IFFALSE 68838
// exit ;
68836: GO 68996
// x := GetX ( building ) ;
68838: LD_ADDR_VAR 0 5
68842: PUSH
68843: LD_VAR 0 2
68847: PPUSH
68848: CALL_OW 250
68852: ST_TO_ADDR
// y := GetY ( building ) ;
68853: LD_ADDR_VAR 0 6
68857: PUSH
68858: LD_VAR 0 2
68862: PPUSH
68863: CALL_OW 251
68867: ST_TO_ADDR
// for i = 0 to 5 do
68868: LD_ADDR_VAR 0 4
68872: PUSH
68873: DOUBLE
68874: LD_INT 0
68876: DEC
68877: ST_TO_ADDR
68878: LD_INT 5
68880: PUSH
68881: FOR_TO
68882: IFFALSE 68994
// begin _x := ShiftX ( x , i , 3 ) ;
68884: LD_ADDR_VAR 0 7
68888: PUSH
68889: LD_VAR 0 5
68893: PPUSH
68894: LD_VAR 0 4
68898: PPUSH
68899: LD_INT 3
68901: PPUSH
68902: CALL_OW 272
68906: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
68907: LD_ADDR_VAR 0 8
68911: PUSH
68912: LD_VAR 0 6
68916: PPUSH
68917: LD_VAR 0 4
68921: PPUSH
68922: LD_INT 3
68924: PPUSH
68925: CALL_OW 273
68929: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68930: LD_VAR 0 7
68934: PPUSH
68935: LD_VAR 0 8
68939: PPUSH
68940: CALL_OW 488
68944: NOT
68945: IFFALSE 68949
// continue ;
68947: GO 68881
// if HexInfo ( _x , _y ) = 0 then
68949: LD_VAR 0 7
68953: PPUSH
68954: LD_VAR 0 8
68958: PPUSH
68959: CALL_OW 428
68963: PUSH
68964: LD_INT 0
68966: EQUAL
68967: IFFALSE 68992
// begin ComMoveXY ( unit , _x , _y ) ;
68969: LD_VAR 0 1
68973: PPUSH
68974: LD_VAR 0 7
68978: PPUSH
68979: LD_VAR 0 8
68983: PPUSH
68984: CALL_OW 111
// exit ;
68988: POP
68989: POP
68990: GO 68996
// end ; end ;
68992: GO 68881
68994: POP
68995: POP
// end ;
68996: LD_VAR 0 3
69000: RET
// export function ScanBase ( side , base_area ) ; begin
69001: LD_INT 0
69003: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
69004: LD_ADDR_VAR 0 3
69008: PUSH
69009: LD_VAR 0 2
69013: PPUSH
69014: LD_INT 81
69016: PUSH
69017: LD_VAR 0 1
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PPUSH
69026: CALL_OW 70
69030: ST_TO_ADDR
// end ;
69031: LD_VAR 0 3
69035: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69036: LD_INT 0
69038: PPUSH
69039: PPUSH
69040: PPUSH
69041: PPUSH
// result := false ;
69042: LD_ADDR_VAR 0 2
69046: PUSH
69047: LD_INT 0
69049: ST_TO_ADDR
// side := GetSide ( unit ) ;
69050: LD_ADDR_VAR 0 3
69054: PUSH
69055: LD_VAR 0 1
69059: PPUSH
69060: CALL_OW 255
69064: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69065: LD_ADDR_VAR 0 4
69069: PUSH
69070: LD_VAR 0 1
69074: PPUSH
69075: CALL_OW 248
69079: ST_TO_ADDR
// case nat of 1 :
69080: LD_VAR 0 4
69084: PUSH
69085: LD_INT 1
69087: DOUBLE
69088: EQUAL
69089: IFTRUE 69093
69091: GO 69104
69093: POP
// tech := tech_lassight ; 2 :
69094: LD_ADDR_VAR 0 5
69098: PUSH
69099: LD_INT 12
69101: ST_TO_ADDR
69102: GO 69143
69104: LD_INT 2
69106: DOUBLE
69107: EQUAL
69108: IFTRUE 69112
69110: GO 69123
69112: POP
// tech := tech_mortar ; 3 :
69113: LD_ADDR_VAR 0 5
69117: PUSH
69118: LD_INT 41
69120: ST_TO_ADDR
69121: GO 69143
69123: LD_INT 3
69125: DOUBLE
69126: EQUAL
69127: IFTRUE 69131
69129: GO 69142
69131: POP
// tech := tech_bazooka ; end ;
69132: LD_ADDR_VAR 0 5
69136: PUSH
69137: LD_INT 44
69139: ST_TO_ADDR
69140: GO 69143
69142: POP
// if Researched ( side , tech ) then
69143: LD_VAR 0 3
69147: PPUSH
69148: LD_VAR 0 5
69152: PPUSH
69153: CALL_OW 325
69157: IFFALSE 69184
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69159: LD_ADDR_VAR 0 2
69163: PUSH
69164: LD_INT 5
69166: PUSH
69167: LD_INT 8
69169: PUSH
69170: LD_INT 9
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: LIST
69177: PUSH
69178: LD_VAR 0 4
69182: ARRAY
69183: ST_TO_ADDR
// end ;
69184: LD_VAR 0 2
69188: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69189: LD_INT 0
69191: PPUSH
69192: PPUSH
69193: PPUSH
// if not mines then
69194: LD_VAR 0 2
69198: NOT
69199: IFFALSE 69203
// exit ;
69201: GO 69347
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69203: LD_ADDR_VAR 0 5
69207: PUSH
69208: LD_INT 81
69210: PUSH
69211: LD_VAR 0 1
69215: PUSH
69216: EMPTY
69217: LIST
69218: LIST
69219: PUSH
69220: LD_INT 3
69222: PUSH
69223: LD_INT 21
69225: PUSH
69226: LD_INT 3
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PPUSH
69241: CALL_OW 69
69245: ST_TO_ADDR
// for i in mines do
69246: LD_ADDR_VAR 0 4
69250: PUSH
69251: LD_VAR 0 2
69255: PUSH
69256: FOR_IN
69257: IFFALSE 69345
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69259: LD_VAR 0 4
69263: PUSH
69264: LD_INT 1
69266: ARRAY
69267: PPUSH
69268: LD_VAR 0 4
69272: PUSH
69273: LD_INT 2
69275: ARRAY
69276: PPUSH
69277: CALL_OW 458
69281: NOT
69282: IFFALSE 69286
// continue ;
69284: GO 69256
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69286: LD_VAR 0 4
69290: PUSH
69291: LD_INT 1
69293: ARRAY
69294: PPUSH
69295: LD_VAR 0 4
69299: PUSH
69300: LD_INT 2
69302: ARRAY
69303: PPUSH
69304: CALL_OW 428
69308: PUSH
69309: LD_VAR 0 5
69313: IN
69314: IFFALSE 69343
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69316: LD_VAR 0 4
69320: PUSH
69321: LD_INT 1
69323: ARRAY
69324: PPUSH
69325: LD_VAR 0 4
69329: PUSH
69330: LD_INT 2
69332: ARRAY
69333: PPUSH
69334: LD_VAR 0 1
69338: PPUSH
69339: CALL_OW 456
// end ;
69343: GO 69256
69345: POP
69346: POP
// end ;
69347: LD_VAR 0 3
69351: RET
// export function Count ( array ) ; var i ; begin
69352: LD_INT 0
69354: PPUSH
69355: PPUSH
// result := 0 ;
69356: LD_ADDR_VAR 0 2
69360: PUSH
69361: LD_INT 0
69363: ST_TO_ADDR
// for i in array do
69364: LD_ADDR_VAR 0 3
69368: PUSH
69369: LD_VAR 0 1
69373: PUSH
69374: FOR_IN
69375: IFFALSE 69399
// if i then
69377: LD_VAR 0 3
69381: IFFALSE 69397
// result := result + 1 ;
69383: LD_ADDR_VAR 0 2
69387: PUSH
69388: LD_VAR 0 2
69392: PUSH
69393: LD_INT 1
69395: PLUS
69396: ST_TO_ADDR
69397: GO 69374
69399: POP
69400: POP
// end ;
69401: LD_VAR 0 2
69405: RET
// export function IsEmpty ( building ) ; begin
69406: LD_INT 0
69408: PPUSH
// if not building then
69409: LD_VAR 0 1
69413: NOT
69414: IFFALSE 69418
// exit ;
69416: GO 69461
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69418: LD_ADDR_VAR 0 2
69422: PUSH
69423: LD_VAR 0 1
69427: PUSH
69428: LD_INT 22
69430: PUSH
69431: LD_VAR 0 1
69435: PPUSH
69436: CALL_OW 255
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: LD_INT 58
69447: PUSH
69448: EMPTY
69449: LIST
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: PPUSH
69455: CALL_OW 69
69459: IN
69460: ST_TO_ADDR
// end ;
69461: LD_VAR 0 2
69465: RET
// export function IsNotFull ( building ) ; var places ; begin
69466: LD_INT 0
69468: PPUSH
69469: PPUSH
// if not building then
69470: LD_VAR 0 1
69474: NOT
69475: IFFALSE 69479
// exit ;
69477: GO 69650
// result := false ;
69479: LD_ADDR_VAR 0 2
69483: PUSH
69484: LD_INT 0
69486: ST_TO_ADDR
// places := 0 ;
69487: LD_ADDR_VAR 0 3
69491: PUSH
69492: LD_INT 0
69494: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
69495: LD_VAR 0 1
69499: PPUSH
69500: CALL_OW 266
69504: PUSH
69505: LD_INT 0
69507: DOUBLE
69508: EQUAL
69509: IFTRUE 69567
69511: LD_INT 1
69513: DOUBLE
69514: EQUAL
69515: IFTRUE 69567
69517: LD_INT 6
69519: DOUBLE
69520: EQUAL
69521: IFTRUE 69567
69523: LD_INT 7
69525: DOUBLE
69526: EQUAL
69527: IFTRUE 69567
69529: LD_INT 8
69531: DOUBLE
69532: EQUAL
69533: IFTRUE 69567
69535: LD_INT 4
69537: DOUBLE
69538: EQUAL
69539: IFTRUE 69567
69541: LD_INT 5
69543: DOUBLE
69544: EQUAL
69545: IFTRUE 69567
69547: LD_INT 2
69549: DOUBLE
69550: EQUAL
69551: IFTRUE 69567
69553: LD_INT 3
69555: DOUBLE
69556: EQUAL
69557: IFTRUE 69567
69559: LD_INT 35
69561: DOUBLE
69562: EQUAL
69563: IFTRUE 69567
69565: GO 69578
69567: POP
// places := 6 ; b_bunker , b_breastwork :
69568: LD_ADDR_VAR 0 3
69572: PUSH
69573: LD_INT 6
69575: ST_TO_ADDR
69576: GO 69623
69578: LD_INT 32
69580: DOUBLE
69581: EQUAL
69582: IFTRUE 69592
69584: LD_INT 31
69586: DOUBLE
69587: EQUAL
69588: IFTRUE 69592
69590: GO 69603
69592: POP
// places := 1 ; b_control_tower :
69593: LD_ADDR_VAR 0 3
69597: PUSH
69598: LD_INT 1
69600: ST_TO_ADDR
69601: GO 69623
69603: LD_INT 36
69605: DOUBLE
69606: EQUAL
69607: IFTRUE 69611
69609: GO 69622
69611: POP
// places := 3 ; end ;
69612: LD_ADDR_VAR 0 3
69616: PUSH
69617: LD_INT 3
69619: ST_TO_ADDR
69620: GO 69623
69622: POP
// if places then
69623: LD_VAR 0 3
69627: IFFALSE 69650
// result := UnitsInside ( building ) < places ;
69629: LD_ADDR_VAR 0 2
69633: PUSH
69634: LD_VAR 0 1
69638: PPUSH
69639: CALL_OW 313
69643: PUSH
69644: LD_VAR 0 3
69648: LESS
69649: ST_TO_ADDR
// end ;
69650: LD_VAR 0 2
69654: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69655: LD_INT 0
69657: PPUSH
69658: PPUSH
69659: PPUSH
69660: PPUSH
// tmp := [ ] ;
69661: LD_ADDR_VAR 0 3
69665: PUSH
69666: EMPTY
69667: ST_TO_ADDR
// list := [ ] ;
69668: LD_ADDR_VAR 0 5
69672: PUSH
69673: EMPTY
69674: ST_TO_ADDR
// for i = 16 to 25 do
69675: LD_ADDR_VAR 0 4
69679: PUSH
69680: DOUBLE
69681: LD_INT 16
69683: DEC
69684: ST_TO_ADDR
69685: LD_INT 25
69687: PUSH
69688: FOR_TO
69689: IFFALSE 69762
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69691: LD_ADDR_VAR 0 3
69695: PUSH
69696: LD_VAR 0 3
69700: PUSH
69701: LD_INT 22
69703: PUSH
69704: LD_VAR 0 1
69708: PPUSH
69709: CALL_OW 255
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 91
69720: PUSH
69721: LD_VAR 0 1
69725: PUSH
69726: LD_INT 6
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 30
69736: PUSH
69737: LD_VAR 0 4
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: EMPTY
69747: LIST
69748: LIST
69749: LIST
69750: PUSH
69751: EMPTY
69752: LIST
69753: PPUSH
69754: CALL_OW 69
69758: ADD
69759: ST_TO_ADDR
69760: GO 69688
69762: POP
69763: POP
// for i = 1 to tmp do
69764: LD_ADDR_VAR 0 4
69768: PUSH
69769: DOUBLE
69770: LD_INT 1
69772: DEC
69773: ST_TO_ADDR
69774: LD_VAR 0 3
69778: PUSH
69779: FOR_TO
69780: IFFALSE 69868
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69782: LD_ADDR_VAR 0 5
69786: PUSH
69787: LD_VAR 0 5
69791: PUSH
69792: LD_VAR 0 3
69796: PUSH
69797: LD_VAR 0 4
69801: ARRAY
69802: PPUSH
69803: CALL_OW 266
69807: PUSH
69808: LD_VAR 0 3
69812: PUSH
69813: LD_VAR 0 4
69817: ARRAY
69818: PPUSH
69819: CALL_OW 250
69823: PUSH
69824: LD_VAR 0 3
69828: PUSH
69829: LD_VAR 0 4
69833: ARRAY
69834: PPUSH
69835: CALL_OW 251
69839: PUSH
69840: LD_VAR 0 3
69844: PUSH
69845: LD_VAR 0 4
69849: ARRAY
69850: PPUSH
69851: CALL_OW 254
69855: PUSH
69856: EMPTY
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: PUSH
69862: EMPTY
69863: LIST
69864: ADD
69865: ST_TO_ADDR
69866: GO 69779
69868: POP
69869: POP
// result := list ;
69870: LD_ADDR_VAR 0 2
69874: PUSH
69875: LD_VAR 0 5
69879: ST_TO_ADDR
// end ;
69880: LD_VAR 0 2
69884: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69885: LD_INT 0
69887: PPUSH
69888: PPUSH
69889: PPUSH
69890: PPUSH
69891: PPUSH
69892: PPUSH
69893: PPUSH
// if not factory then
69894: LD_VAR 0 1
69898: NOT
69899: IFFALSE 69903
// exit ;
69901: GO 70496
// if control = control_apeman then
69903: LD_VAR 0 4
69907: PUSH
69908: LD_INT 5
69910: EQUAL
69911: IFFALSE 70020
// begin tmp := UnitsInside ( factory ) ;
69913: LD_ADDR_VAR 0 8
69917: PUSH
69918: LD_VAR 0 1
69922: PPUSH
69923: CALL_OW 313
69927: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69928: LD_VAR 0 8
69932: PPUSH
69933: LD_INT 25
69935: PUSH
69936: LD_INT 12
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PPUSH
69943: CALL_OW 72
69947: NOT
69948: IFFALSE 69958
// control := control_manual ;
69950: LD_ADDR_VAR 0 4
69954: PUSH
69955: LD_INT 1
69957: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69958: LD_ADDR_VAR 0 8
69962: PUSH
69963: LD_VAR 0 1
69967: PPUSH
69968: CALL 69655 0 1
69972: ST_TO_ADDR
// if tmp then
69973: LD_VAR 0 8
69977: IFFALSE 70020
// begin for i in tmp do
69979: LD_ADDR_VAR 0 7
69983: PUSH
69984: LD_VAR 0 8
69988: PUSH
69989: FOR_IN
69990: IFFALSE 70018
// if i [ 1 ] = b_ext_radio then
69992: LD_VAR 0 7
69996: PUSH
69997: LD_INT 1
69999: ARRAY
70000: PUSH
70001: LD_INT 22
70003: EQUAL
70004: IFFALSE 70016
// begin control := control_remote ;
70006: LD_ADDR_VAR 0 4
70010: PUSH
70011: LD_INT 2
70013: ST_TO_ADDR
// break ;
70014: GO 70018
// end ;
70016: GO 69989
70018: POP
70019: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70020: LD_VAR 0 1
70024: PPUSH
70025: LD_VAR 0 2
70029: PPUSH
70030: LD_VAR 0 3
70034: PPUSH
70035: LD_VAR 0 4
70039: PPUSH
70040: LD_VAR 0 5
70044: PPUSH
70045: CALL_OW 448
70049: IFFALSE 70084
// begin result := [ chassis , engine , control , weapon ] ;
70051: LD_ADDR_VAR 0 6
70055: PUSH
70056: LD_VAR 0 2
70060: PUSH
70061: LD_VAR 0 3
70065: PUSH
70066: LD_VAR 0 4
70070: PUSH
70071: LD_VAR 0 5
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: ST_TO_ADDR
// exit ;
70082: GO 70496
// end ; _chassis := AvailableChassisList ( factory ) ;
70084: LD_ADDR_VAR 0 9
70088: PUSH
70089: LD_VAR 0 1
70093: PPUSH
70094: CALL_OW 475
70098: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70099: LD_ADDR_VAR 0 11
70103: PUSH
70104: LD_VAR 0 1
70108: PPUSH
70109: CALL_OW 476
70113: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70114: LD_ADDR_VAR 0 12
70118: PUSH
70119: LD_VAR 0 1
70123: PPUSH
70124: CALL_OW 477
70128: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70129: LD_ADDR_VAR 0 10
70133: PUSH
70134: LD_VAR 0 1
70138: PPUSH
70139: CALL_OW 478
70143: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70144: LD_VAR 0 9
70148: NOT
70149: PUSH
70150: LD_VAR 0 11
70154: NOT
70155: OR
70156: PUSH
70157: LD_VAR 0 12
70161: NOT
70162: OR
70163: PUSH
70164: LD_VAR 0 10
70168: NOT
70169: OR
70170: IFFALSE 70205
// begin result := [ chassis , engine , control , weapon ] ;
70172: LD_ADDR_VAR 0 6
70176: PUSH
70177: LD_VAR 0 2
70181: PUSH
70182: LD_VAR 0 3
70186: PUSH
70187: LD_VAR 0 4
70191: PUSH
70192: LD_VAR 0 5
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: ST_TO_ADDR
// exit ;
70203: GO 70496
// end ; if not chassis in _chassis then
70205: LD_VAR 0 2
70209: PUSH
70210: LD_VAR 0 9
70214: IN
70215: NOT
70216: IFFALSE 70242
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70218: LD_ADDR_VAR 0 2
70222: PUSH
70223: LD_VAR 0 9
70227: PUSH
70228: LD_INT 1
70230: PPUSH
70231: LD_VAR 0 9
70235: PPUSH
70236: CALL_OW 12
70240: ARRAY
70241: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70242: LD_VAR 0 2
70246: PPUSH
70247: LD_VAR 0 3
70251: PPUSH
70252: CALL 70501 0 2
70256: NOT
70257: IFFALSE 70316
// repeat engine := _engine [ 1 ] ;
70259: LD_ADDR_VAR 0 3
70263: PUSH
70264: LD_VAR 0 11
70268: PUSH
70269: LD_INT 1
70271: ARRAY
70272: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70273: LD_ADDR_VAR 0 11
70277: PUSH
70278: LD_VAR 0 11
70282: PPUSH
70283: LD_INT 1
70285: PPUSH
70286: CALL_OW 3
70290: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70291: LD_VAR 0 2
70295: PPUSH
70296: LD_VAR 0 3
70300: PPUSH
70301: CALL 70501 0 2
70305: PUSH
70306: LD_VAR 0 11
70310: PUSH
70311: EMPTY
70312: EQUAL
70313: OR
70314: IFFALSE 70259
// if not control in _control then
70316: LD_VAR 0 4
70320: PUSH
70321: LD_VAR 0 12
70325: IN
70326: NOT
70327: IFFALSE 70353
// control := _control [ rand ( 1 , _control ) ] ;
70329: LD_ADDR_VAR 0 4
70333: PUSH
70334: LD_VAR 0 12
70338: PUSH
70339: LD_INT 1
70341: PPUSH
70342: LD_VAR 0 12
70346: PPUSH
70347: CALL_OW 12
70351: ARRAY
70352: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70353: LD_VAR 0 2
70357: PPUSH
70358: LD_VAR 0 5
70362: PPUSH
70363: CALL 70721 0 2
70367: NOT
70368: IFFALSE 70427
// repeat weapon := _weapon [ 1 ] ;
70370: LD_ADDR_VAR 0 5
70374: PUSH
70375: LD_VAR 0 10
70379: PUSH
70380: LD_INT 1
70382: ARRAY
70383: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70384: LD_ADDR_VAR 0 10
70388: PUSH
70389: LD_VAR 0 10
70393: PPUSH
70394: LD_INT 1
70396: PPUSH
70397: CALL_OW 3
70401: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70402: LD_VAR 0 2
70406: PPUSH
70407: LD_VAR 0 5
70411: PPUSH
70412: CALL 70721 0 2
70416: PUSH
70417: LD_VAR 0 10
70421: PUSH
70422: EMPTY
70423: EQUAL
70424: OR
70425: IFFALSE 70370
// result := [ ] ;
70427: LD_ADDR_VAR 0 6
70431: PUSH
70432: EMPTY
70433: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70434: LD_VAR 0 1
70438: PPUSH
70439: LD_VAR 0 2
70443: PPUSH
70444: LD_VAR 0 3
70448: PPUSH
70449: LD_VAR 0 4
70453: PPUSH
70454: LD_VAR 0 5
70458: PPUSH
70459: CALL_OW 448
70463: IFFALSE 70496
// result := [ chassis , engine , control , weapon ] ;
70465: LD_ADDR_VAR 0 6
70469: PUSH
70470: LD_VAR 0 2
70474: PUSH
70475: LD_VAR 0 3
70479: PUSH
70480: LD_VAR 0 4
70484: PUSH
70485: LD_VAR 0 5
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: LIST
70494: LIST
70495: ST_TO_ADDR
// end ;
70496: LD_VAR 0 6
70500: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70501: LD_INT 0
70503: PPUSH
// if not chassis or not engine then
70504: LD_VAR 0 1
70508: NOT
70509: PUSH
70510: LD_VAR 0 2
70514: NOT
70515: OR
70516: IFFALSE 70520
// exit ;
70518: GO 70716
// case engine of engine_solar :
70520: LD_VAR 0 2
70524: PUSH
70525: LD_INT 2
70527: DOUBLE
70528: EQUAL
70529: IFTRUE 70533
70531: GO 70571
70533: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70534: LD_ADDR_VAR 0 3
70538: PUSH
70539: LD_INT 11
70541: PUSH
70542: LD_INT 12
70544: PUSH
70545: LD_INT 13
70547: PUSH
70548: LD_INT 14
70550: PUSH
70551: LD_INT 1
70553: PUSH
70554: LD_INT 2
70556: PUSH
70557: LD_INT 3
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: ST_TO_ADDR
70569: GO 70700
70571: LD_INT 1
70573: DOUBLE
70574: EQUAL
70575: IFTRUE 70579
70577: GO 70641
70579: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70580: LD_ADDR_VAR 0 3
70584: PUSH
70585: LD_INT 11
70587: PUSH
70588: LD_INT 12
70590: PUSH
70591: LD_INT 13
70593: PUSH
70594: LD_INT 14
70596: PUSH
70597: LD_INT 1
70599: PUSH
70600: LD_INT 2
70602: PUSH
70603: LD_INT 3
70605: PUSH
70606: LD_INT 4
70608: PUSH
70609: LD_INT 5
70611: PUSH
70612: LD_INT 21
70614: PUSH
70615: LD_INT 23
70617: PUSH
70618: LD_INT 22
70620: PUSH
70621: LD_INT 24
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: LIST
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: ST_TO_ADDR
70639: GO 70700
70641: LD_INT 3
70643: DOUBLE
70644: EQUAL
70645: IFTRUE 70649
70647: GO 70699
70649: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70650: LD_ADDR_VAR 0 3
70654: PUSH
70655: LD_INT 13
70657: PUSH
70658: LD_INT 14
70660: PUSH
70661: LD_INT 2
70663: PUSH
70664: LD_INT 3
70666: PUSH
70667: LD_INT 4
70669: PUSH
70670: LD_INT 5
70672: PUSH
70673: LD_INT 21
70675: PUSH
70676: LD_INT 22
70678: PUSH
70679: LD_INT 23
70681: PUSH
70682: LD_INT 24
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: LIST
70696: ST_TO_ADDR
70697: GO 70700
70699: POP
// result := ( chassis in result ) ;
70700: LD_ADDR_VAR 0 3
70704: PUSH
70705: LD_VAR 0 1
70709: PUSH
70710: LD_VAR 0 3
70714: IN
70715: ST_TO_ADDR
// end ;
70716: LD_VAR 0 3
70720: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70721: LD_INT 0
70723: PPUSH
// if not chassis or not weapon then
70724: LD_VAR 0 1
70728: NOT
70729: PUSH
70730: LD_VAR 0 2
70734: NOT
70735: OR
70736: IFFALSE 70740
// exit ;
70738: GO 71800
// case weapon of us_machine_gun :
70740: LD_VAR 0 2
70744: PUSH
70745: LD_INT 2
70747: DOUBLE
70748: EQUAL
70749: IFTRUE 70753
70751: GO 70783
70753: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70754: LD_ADDR_VAR 0 3
70758: PUSH
70759: LD_INT 1
70761: PUSH
70762: LD_INT 2
70764: PUSH
70765: LD_INT 3
70767: PUSH
70768: LD_INT 4
70770: PUSH
70771: LD_INT 5
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: ST_TO_ADDR
70781: GO 71784
70783: LD_INT 3
70785: DOUBLE
70786: EQUAL
70787: IFTRUE 70791
70789: GO 70821
70791: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70792: LD_ADDR_VAR 0 3
70796: PUSH
70797: LD_INT 1
70799: PUSH
70800: LD_INT 2
70802: PUSH
70803: LD_INT 3
70805: PUSH
70806: LD_INT 4
70808: PUSH
70809: LD_INT 5
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: ST_TO_ADDR
70819: GO 71784
70821: LD_INT 11
70823: DOUBLE
70824: EQUAL
70825: IFTRUE 70829
70827: GO 70859
70829: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70830: LD_ADDR_VAR 0 3
70834: PUSH
70835: LD_INT 1
70837: PUSH
70838: LD_INT 2
70840: PUSH
70841: LD_INT 3
70843: PUSH
70844: LD_INT 4
70846: PUSH
70847: LD_INT 5
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: LIST
70854: LIST
70855: LIST
70856: ST_TO_ADDR
70857: GO 71784
70859: LD_INT 4
70861: DOUBLE
70862: EQUAL
70863: IFTRUE 70867
70865: GO 70893
70867: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70868: LD_ADDR_VAR 0 3
70872: PUSH
70873: LD_INT 2
70875: PUSH
70876: LD_INT 3
70878: PUSH
70879: LD_INT 4
70881: PUSH
70882: LD_INT 5
70884: PUSH
70885: EMPTY
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: ST_TO_ADDR
70891: GO 71784
70893: LD_INT 5
70895: DOUBLE
70896: EQUAL
70897: IFTRUE 70901
70899: GO 70927
70901: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70902: LD_ADDR_VAR 0 3
70906: PUSH
70907: LD_INT 2
70909: PUSH
70910: LD_INT 3
70912: PUSH
70913: LD_INT 4
70915: PUSH
70916: LD_INT 5
70918: PUSH
70919: EMPTY
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: ST_TO_ADDR
70925: GO 71784
70927: LD_INT 9
70929: DOUBLE
70930: EQUAL
70931: IFTRUE 70935
70933: GO 70961
70935: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70936: LD_ADDR_VAR 0 3
70940: PUSH
70941: LD_INT 2
70943: PUSH
70944: LD_INT 3
70946: PUSH
70947: LD_INT 4
70949: PUSH
70950: LD_INT 5
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: LIST
70957: LIST
70958: ST_TO_ADDR
70959: GO 71784
70961: LD_INT 7
70963: DOUBLE
70964: EQUAL
70965: IFTRUE 70969
70967: GO 70995
70969: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70970: LD_ADDR_VAR 0 3
70974: PUSH
70975: LD_INT 2
70977: PUSH
70978: LD_INT 3
70980: PUSH
70981: LD_INT 4
70983: PUSH
70984: LD_INT 5
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: ST_TO_ADDR
70993: GO 71784
70995: LD_INT 12
70997: DOUBLE
70998: EQUAL
70999: IFTRUE 71003
71001: GO 71029
71003: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
71004: LD_ADDR_VAR 0 3
71008: PUSH
71009: LD_INT 2
71011: PUSH
71012: LD_INT 3
71014: PUSH
71015: LD_INT 4
71017: PUSH
71018: LD_INT 5
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: ST_TO_ADDR
71027: GO 71784
71029: LD_INT 13
71031: DOUBLE
71032: EQUAL
71033: IFTRUE 71037
71035: GO 71063
71037: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71038: LD_ADDR_VAR 0 3
71042: PUSH
71043: LD_INT 2
71045: PUSH
71046: LD_INT 3
71048: PUSH
71049: LD_INT 4
71051: PUSH
71052: LD_INT 5
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: ST_TO_ADDR
71061: GO 71784
71063: LD_INT 14
71065: DOUBLE
71066: EQUAL
71067: IFTRUE 71071
71069: GO 71089
71071: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71072: LD_ADDR_VAR 0 3
71076: PUSH
71077: LD_INT 4
71079: PUSH
71080: LD_INT 5
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: ST_TO_ADDR
71087: GO 71784
71089: LD_INT 6
71091: DOUBLE
71092: EQUAL
71093: IFTRUE 71097
71095: GO 71115
71097: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71098: LD_ADDR_VAR 0 3
71102: PUSH
71103: LD_INT 4
71105: PUSH
71106: LD_INT 5
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: ST_TO_ADDR
71113: GO 71784
71115: LD_INT 10
71117: DOUBLE
71118: EQUAL
71119: IFTRUE 71123
71121: GO 71141
71123: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71124: LD_ADDR_VAR 0 3
71128: PUSH
71129: LD_INT 4
71131: PUSH
71132: LD_INT 5
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: ST_TO_ADDR
71139: GO 71784
71141: LD_INT 22
71143: DOUBLE
71144: EQUAL
71145: IFTRUE 71149
71147: GO 71175
71149: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71150: LD_ADDR_VAR 0 3
71154: PUSH
71155: LD_INT 11
71157: PUSH
71158: LD_INT 12
71160: PUSH
71161: LD_INT 13
71163: PUSH
71164: LD_INT 14
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: LIST
71171: LIST
71172: ST_TO_ADDR
71173: GO 71784
71175: LD_INT 23
71177: DOUBLE
71178: EQUAL
71179: IFTRUE 71183
71181: GO 71209
71183: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71184: LD_ADDR_VAR 0 3
71188: PUSH
71189: LD_INT 11
71191: PUSH
71192: LD_INT 12
71194: PUSH
71195: LD_INT 13
71197: PUSH
71198: LD_INT 14
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: LIST
71205: LIST
71206: ST_TO_ADDR
71207: GO 71784
71209: LD_INT 24
71211: DOUBLE
71212: EQUAL
71213: IFTRUE 71217
71215: GO 71243
71217: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71218: LD_ADDR_VAR 0 3
71222: PUSH
71223: LD_INT 11
71225: PUSH
71226: LD_INT 12
71228: PUSH
71229: LD_INT 13
71231: PUSH
71232: LD_INT 14
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: LIST
71239: LIST
71240: ST_TO_ADDR
71241: GO 71784
71243: LD_INT 30
71245: DOUBLE
71246: EQUAL
71247: IFTRUE 71251
71249: GO 71277
71251: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71252: LD_ADDR_VAR 0 3
71256: PUSH
71257: LD_INT 11
71259: PUSH
71260: LD_INT 12
71262: PUSH
71263: LD_INT 13
71265: PUSH
71266: LD_INT 14
71268: PUSH
71269: EMPTY
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: ST_TO_ADDR
71275: GO 71784
71277: LD_INT 25
71279: DOUBLE
71280: EQUAL
71281: IFTRUE 71285
71283: GO 71303
71285: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71286: LD_ADDR_VAR 0 3
71290: PUSH
71291: LD_INT 13
71293: PUSH
71294: LD_INT 14
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: ST_TO_ADDR
71301: GO 71784
71303: LD_INT 27
71305: DOUBLE
71306: EQUAL
71307: IFTRUE 71311
71309: GO 71329
71311: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71312: LD_ADDR_VAR 0 3
71316: PUSH
71317: LD_INT 13
71319: PUSH
71320: LD_INT 14
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: ST_TO_ADDR
71327: GO 71784
71329: LD_INT 92
71331: DOUBLE
71332: EQUAL
71333: IFTRUE 71337
71335: GO 71363
71337: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71338: LD_ADDR_VAR 0 3
71342: PUSH
71343: LD_INT 11
71345: PUSH
71346: LD_INT 12
71348: PUSH
71349: LD_INT 13
71351: PUSH
71352: LD_INT 14
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: ST_TO_ADDR
71361: GO 71784
71363: LD_INT 28
71365: DOUBLE
71366: EQUAL
71367: IFTRUE 71371
71369: GO 71389
71371: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71372: LD_ADDR_VAR 0 3
71376: PUSH
71377: LD_INT 13
71379: PUSH
71380: LD_INT 14
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: ST_TO_ADDR
71387: GO 71784
71389: LD_INT 29
71391: DOUBLE
71392: EQUAL
71393: IFTRUE 71397
71395: GO 71415
71397: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71398: LD_ADDR_VAR 0 3
71402: PUSH
71403: LD_INT 13
71405: PUSH
71406: LD_INT 14
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: ST_TO_ADDR
71413: GO 71784
71415: LD_INT 31
71417: DOUBLE
71418: EQUAL
71419: IFTRUE 71423
71421: GO 71441
71423: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71424: LD_ADDR_VAR 0 3
71428: PUSH
71429: LD_INT 13
71431: PUSH
71432: LD_INT 14
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: ST_TO_ADDR
71439: GO 71784
71441: LD_INT 26
71443: DOUBLE
71444: EQUAL
71445: IFTRUE 71449
71447: GO 71467
71449: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71450: LD_ADDR_VAR 0 3
71454: PUSH
71455: LD_INT 13
71457: PUSH
71458: LD_INT 14
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: ST_TO_ADDR
71465: GO 71784
71467: LD_INT 42
71469: DOUBLE
71470: EQUAL
71471: IFTRUE 71475
71473: GO 71501
71475: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71476: LD_ADDR_VAR 0 3
71480: PUSH
71481: LD_INT 21
71483: PUSH
71484: LD_INT 22
71486: PUSH
71487: LD_INT 23
71489: PUSH
71490: LD_INT 24
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: ST_TO_ADDR
71499: GO 71784
71501: LD_INT 43
71503: DOUBLE
71504: EQUAL
71505: IFTRUE 71509
71507: GO 71535
71509: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71510: LD_ADDR_VAR 0 3
71514: PUSH
71515: LD_INT 21
71517: PUSH
71518: LD_INT 22
71520: PUSH
71521: LD_INT 23
71523: PUSH
71524: LD_INT 24
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: LIST
71531: LIST
71532: ST_TO_ADDR
71533: GO 71784
71535: LD_INT 44
71537: DOUBLE
71538: EQUAL
71539: IFTRUE 71543
71541: GO 71569
71543: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71544: LD_ADDR_VAR 0 3
71548: PUSH
71549: LD_INT 21
71551: PUSH
71552: LD_INT 22
71554: PUSH
71555: LD_INT 23
71557: PUSH
71558: LD_INT 24
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: LIST
71565: LIST
71566: ST_TO_ADDR
71567: GO 71784
71569: LD_INT 45
71571: DOUBLE
71572: EQUAL
71573: IFTRUE 71577
71575: GO 71603
71577: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71578: LD_ADDR_VAR 0 3
71582: PUSH
71583: LD_INT 21
71585: PUSH
71586: LD_INT 22
71588: PUSH
71589: LD_INT 23
71591: PUSH
71592: LD_INT 24
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: LIST
71599: LIST
71600: ST_TO_ADDR
71601: GO 71784
71603: LD_INT 49
71605: DOUBLE
71606: EQUAL
71607: IFTRUE 71611
71609: GO 71637
71611: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71612: LD_ADDR_VAR 0 3
71616: PUSH
71617: LD_INT 21
71619: PUSH
71620: LD_INT 22
71622: PUSH
71623: LD_INT 23
71625: PUSH
71626: LD_INT 24
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: ST_TO_ADDR
71635: GO 71784
71637: LD_INT 51
71639: DOUBLE
71640: EQUAL
71641: IFTRUE 71645
71643: GO 71671
71645: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71646: LD_ADDR_VAR 0 3
71650: PUSH
71651: LD_INT 21
71653: PUSH
71654: LD_INT 22
71656: PUSH
71657: LD_INT 23
71659: PUSH
71660: LD_INT 24
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: ST_TO_ADDR
71669: GO 71784
71671: LD_INT 52
71673: DOUBLE
71674: EQUAL
71675: IFTRUE 71679
71677: GO 71705
71679: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71680: LD_ADDR_VAR 0 3
71684: PUSH
71685: LD_INT 21
71687: PUSH
71688: LD_INT 22
71690: PUSH
71691: LD_INT 23
71693: PUSH
71694: LD_INT 24
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: ST_TO_ADDR
71703: GO 71784
71705: LD_INT 53
71707: DOUBLE
71708: EQUAL
71709: IFTRUE 71713
71711: GO 71731
71713: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71714: LD_ADDR_VAR 0 3
71718: PUSH
71719: LD_INT 23
71721: PUSH
71722: LD_INT 24
71724: PUSH
71725: EMPTY
71726: LIST
71727: LIST
71728: ST_TO_ADDR
71729: GO 71784
71731: LD_INT 46
71733: DOUBLE
71734: EQUAL
71735: IFTRUE 71739
71737: GO 71757
71739: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71740: LD_ADDR_VAR 0 3
71744: PUSH
71745: LD_INT 23
71747: PUSH
71748: LD_INT 24
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: ST_TO_ADDR
71755: GO 71784
71757: LD_INT 47
71759: DOUBLE
71760: EQUAL
71761: IFTRUE 71765
71763: GO 71783
71765: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71766: LD_ADDR_VAR 0 3
71770: PUSH
71771: LD_INT 23
71773: PUSH
71774: LD_INT 24
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: ST_TO_ADDR
71781: GO 71784
71783: POP
// result := ( chassis in result ) ;
71784: LD_ADDR_VAR 0 3
71788: PUSH
71789: LD_VAR 0 1
71793: PUSH
71794: LD_VAR 0 3
71798: IN
71799: ST_TO_ADDR
// end ;
71800: LD_VAR 0 3
71804: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71805: LD_INT 0
71807: PPUSH
71808: PPUSH
71809: PPUSH
71810: PPUSH
71811: PPUSH
71812: PPUSH
71813: PPUSH
// result := array ;
71814: LD_ADDR_VAR 0 5
71818: PUSH
71819: LD_VAR 0 1
71823: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71824: LD_VAR 0 1
71828: NOT
71829: PUSH
71830: LD_VAR 0 2
71834: NOT
71835: OR
71836: PUSH
71837: LD_VAR 0 3
71841: NOT
71842: OR
71843: PUSH
71844: LD_VAR 0 2
71848: PUSH
71849: LD_VAR 0 1
71853: GREATER
71854: OR
71855: PUSH
71856: LD_VAR 0 3
71860: PUSH
71861: LD_VAR 0 1
71865: GREATER
71866: OR
71867: IFFALSE 71871
// exit ;
71869: GO 72167
// if direction then
71871: LD_VAR 0 4
71875: IFFALSE 71939
// begin d := 1 ;
71877: LD_ADDR_VAR 0 9
71881: PUSH
71882: LD_INT 1
71884: ST_TO_ADDR
// if i_from > i_to then
71885: LD_VAR 0 2
71889: PUSH
71890: LD_VAR 0 3
71894: GREATER
71895: IFFALSE 71921
// length := ( array - i_from ) + i_to else
71897: LD_ADDR_VAR 0 11
71901: PUSH
71902: LD_VAR 0 1
71906: PUSH
71907: LD_VAR 0 2
71911: MINUS
71912: PUSH
71913: LD_VAR 0 3
71917: PLUS
71918: ST_TO_ADDR
71919: GO 71937
// length := i_to - i_from ;
71921: LD_ADDR_VAR 0 11
71925: PUSH
71926: LD_VAR 0 3
71930: PUSH
71931: LD_VAR 0 2
71935: MINUS
71936: ST_TO_ADDR
// end else
71937: GO 72000
// begin d := - 1 ;
71939: LD_ADDR_VAR 0 9
71943: PUSH
71944: LD_INT 1
71946: NEG
71947: ST_TO_ADDR
// if i_from > i_to then
71948: LD_VAR 0 2
71952: PUSH
71953: LD_VAR 0 3
71957: GREATER
71958: IFFALSE 71978
// length := i_from - i_to else
71960: LD_ADDR_VAR 0 11
71964: PUSH
71965: LD_VAR 0 2
71969: PUSH
71970: LD_VAR 0 3
71974: MINUS
71975: ST_TO_ADDR
71976: GO 72000
// length := ( array - i_to ) + i_from ;
71978: LD_ADDR_VAR 0 11
71982: PUSH
71983: LD_VAR 0 1
71987: PUSH
71988: LD_VAR 0 3
71992: MINUS
71993: PUSH
71994: LD_VAR 0 2
71998: PLUS
71999: ST_TO_ADDR
// end ; if not length then
72000: LD_VAR 0 11
72004: NOT
72005: IFFALSE 72009
// exit ;
72007: GO 72167
// tmp := array ;
72009: LD_ADDR_VAR 0 10
72013: PUSH
72014: LD_VAR 0 1
72018: ST_TO_ADDR
// for i = 1 to length do
72019: LD_ADDR_VAR 0 6
72023: PUSH
72024: DOUBLE
72025: LD_INT 1
72027: DEC
72028: ST_TO_ADDR
72029: LD_VAR 0 11
72033: PUSH
72034: FOR_TO
72035: IFFALSE 72155
// begin for j = 1 to array do
72037: LD_ADDR_VAR 0 7
72041: PUSH
72042: DOUBLE
72043: LD_INT 1
72045: DEC
72046: ST_TO_ADDR
72047: LD_VAR 0 1
72051: PUSH
72052: FOR_TO
72053: IFFALSE 72141
// begin k := j + d ;
72055: LD_ADDR_VAR 0 8
72059: PUSH
72060: LD_VAR 0 7
72064: PUSH
72065: LD_VAR 0 9
72069: PLUS
72070: ST_TO_ADDR
// if k > array then
72071: LD_VAR 0 8
72075: PUSH
72076: LD_VAR 0 1
72080: GREATER
72081: IFFALSE 72091
// k := 1 ;
72083: LD_ADDR_VAR 0 8
72087: PUSH
72088: LD_INT 1
72090: ST_TO_ADDR
// if not k then
72091: LD_VAR 0 8
72095: NOT
72096: IFFALSE 72108
// k := array ;
72098: LD_ADDR_VAR 0 8
72102: PUSH
72103: LD_VAR 0 1
72107: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72108: LD_ADDR_VAR 0 10
72112: PUSH
72113: LD_VAR 0 10
72117: PPUSH
72118: LD_VAR 0 8
72122: PPUSH
72123: LD_VAR 0 1
72127: PUSH
72128: LD_VAR 0 7
72132: ARRAY
72133: PPUSH
72134: CALL_OW 1
72138: ST_TO_ADDR
// end ;
72139: GO 72052
72141: POP
72142: POP
// array := tmp ;
72143: LD_ADDR_VAR 0 1
72147: PUSH
72148: LD_VAR 0 10
72152: ST_TO_ADDR
// end ;
72153: GO 72034
72155: POP
72156: POP
// result := array ;
72157: LD_ADDR_VAR 0 5
72161: PUSH
72162: LD_VAR 0 1
72166: ST_TO_ADDR
// end ;
72167: LD_VAR 0 5
72171: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72172: LD_INT 0
72174: PPUSH
72175: PPUSH
// result := 0 ;
72176: LD_ADDR_VAR 0 3
72180: PUSH
72181: LD_INT 0
72183: ST_TO_ADDR
// if not array or not value in array then
72184: LD_VAR 0 1
72188: NOT
72189: PUSH
72190: LD_VAR 0 2
72194: PUSH
72195: LD_VAR 0 1
72199: IN
72200: NOT
72201: OR
72202: IFFALSE 72206
// exit ;
72204: GO 72260
// for i = 1 to array do
72206: LD_ADDR_VAR 0 4
72210: PUSH
72211: DOUBLE
72212: LD_INT 1
72214: DEC
72215: ST_TO_ADDR
72216: LD_VAR 0 1
72220: PUSH
72221: FOR_TO
72222: IFFALSE 72258
// if value = array [ i ] then
72224: LD_VAR 0 2
72228: PUSH
72229: LD_VAR 0 1
72233: PUSH
72234: LD_VAR 0 4
72238: ARRAY
72239: EQUAL
72240: IFFALSE 72256
// begin result := i ;
72242: LD_ADDR_VAR 0 3
72246: PUSH
72247: LD_VAR 0 4
72251: ST_TO_ADDR
// exit ;
72252: POP
72253: POP
72254: GO 72260
// end ;
72256: GO 72221
72258: POP
72259: POP
// end ;
72260: LD_VAR 0 3
72264: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72265: LD_INT 0
72267: PPUSH
// vc_chassis := chassis ;
72268: LD_ADDR_OWVAR 37
72272: PUSH
72273: LD_VAR 0 1
72277: ST_TO_ADDR
// vc_engine := engine ;
72278: LD_ADDR_OWVAR 39
72282: PUSH
72283: LD_VAR 0 2
72287: ST_TO_ADDR
// vc_control := control ;
72288: LD_ADDR_OWVAR 38
72292: PUSH
72293: LD_VAR 0 3
72297: ST_TO_ADDR
// vc_weapon := weapon ;
72298: LD_ADDR_OWVAR 40
72302: PUSH
72303: LD_VAR 0 4
72307: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72308: LD_ADDR_OWVAR 41
72312: PUSH
72313: LD_VAR 0 5
72317: ST_TO_ADDR
// end ;
72318: LD_VAR 0 6
72322: RET
// export function WantPlant ( unit ) ; var task ; begin
72323: LD_INT 0
72325: PPUSH
72326: PPUSH
// result := false ;
72327: LD_ADDR_VAR 0 2
72331: PUSH
72332: LD_INT 0
72334: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72335: LD_ADDR_VAR 0 3
72339: PUSH
72340: LD_VAR 0 1
72344: PPUSH
72345: CALL_OW 437
72349: ST_TO_ADDR
// if task then
72350: LD_VAR 0 3
72354: IFFALSE 72382
// if task [ 1 ] [ 1 ] = p then
72356: LD_VAR 0 3
72360: PUSH
72361: LD_INT 1
72363: ARRAY
72364: PUSH
72365: LD_INT 1
72367: ARRAY
72368: PUSH
72369: LD_STRING p
72371: EQUAL
72372: IFFALSE 72382
// result := true ;
72374: LD_ADDR_VAR 0 2
72378: PUSH
72379: LD_INT 1
72381: ST_TO_ADDR
// end ;
72382: LD_VAR 0 2
72386: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72387: LD_INT 0
72389: PPUSH
72390: PPUSH
72391: PPUSH
72392: PPUSH
// if pos < 1 then
72393: LD_VAR 0 2
72397: PUSH
72398: LD_INT 1
72400: LESS
72401: IFFALSE 72405
// exit ;
72403: GO 72708
// if pos = 1 then
72405: LD_VAR 0 2
72409: PUSH
72410: LD_INT 1
72412: EQUAL
72413: IFFALSE 72446
// result := Replace ( arr , pos [ 1 ] , value ) else
72415: LD_ADDR_VAR 0 4
72419: PUSH
72420: LD_VAR 0 1
72424: PPUSH
72425: LD_VAR 0 2
72429: PUSH
72430: LD_INT 1
72432: ARRAY
72433: PPUSH
72434: LD_VAR 0 3
72438: PPUSH
72439: CALL_OW 1
72443: ST_TO_ADDR
72444: GO 72708
// begin tmp := arr ;
72446: LD_ADDR_VAR 0 6
72450: PUSH
72451: LD_VAR 0 1
72455: ST_TO_ADDR
// s_arr := [ tmp ] ;
72456: LD_ADDR_VAR 0 7
72460: PUSH
72461: LD_VAR 0 6
72465: PUSH
72466: EMPTY
72467: LIST
72468: ST_TO_ADDR
// for i = 1 to pos - 1 do
72469: LD_ADDR_VAR 0 5
72473: PUSH
72474: DOUBLE
72475: LD_INT 1
72477: DEC
72478: ST_TO_ADDR
72479: LD_VAR 0 2
72483: PUSH
72484: LD_INT 1
72486: MINUS
72487: PUSH
72488: FOR_TO
72489: IFFALSE 72534
// begin tmp := tmp [ pos [ i ] ] ;
72491: LD_ADDR_VAR 0 6
72495: PUSH
72496: LD_VAR 0 6
72500: PUSH
72501: LD_VAR 0 2
72505: PUSH
72506: LD_VAR 0 5
72510: ARRAY
72511: ARRAY
72512: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72513: LD_ADDR_VAR 0 7
72517: PUSH
72518: LD_VAR 0 7
72522: PUSH
72523: LD_VAR 0 6
72527: PUSH
72528: EMPTY
72529: LIST
72530: ADD
72531: ST_TO_ADDR
// end ;
72532: GO 72488
72534: POP
72535: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72536: LD_ADDR_VAR 0 6
72540: PUSH
72541: LD_VAR 0 6
72545: PPUSH
72546: LD_VAR 0 2
72550: PUSH
72551: LD_VAR 0 2
72555: ARRAY
72556: PPUSH
72557: LD_VAR 0 3
72561: PPUSH
72562: CALL_OW 1
72566: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72567: LD_ADDR_VAR 0 7
72571: PUSH
72572: LD_VAR 0 7
72576: PPUSH
72577: LD_VAR 0 7
72581: PPUSH
72582: LD_VAR 0 6
72586: PPUSH
72587: CALL_OW 1
72591: ST_TO_ADDR
// for i = s_arr downto 2 do
72592: LD_ADDR_VAR 0 5
72596: PUSH
72597: DOUBLE
72598: LD_VAR 0 7
72602: INC
72603: ST_TO_ADDR
72604: LD_INT 2
72606: PUSH
72607: FOR_DOWNTO
72608: IFFALSE 72692
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72610: LD_ADDR_VAR 0 6
72614: PUSH
72615: LD_VAR 0 7
72619: PUSH
72620: LD_VAR 0 5
72624: PUSH
72625: LD_INT 1
72627: MINUS
72628: ARRAY
72629: PPUSH
72630: LD_VAR 0 2
72634: PUSH
72635: LD_VAR 0 5
72639: PUSH
72640: LD_INT 1
72642: MINUS
72643: ARRAY
72644: PPUSH
72645: LD_VAR 0 7
72649: PUSH
72650: LD_VAR 0 5
72654: ARRAY
72655: PPUSH
72656: CALL_OW 1
72660: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72661: LD_ADDR_VAR 0 7
72665: PUSH
72666: LD_VAR 0 7
72670: PPUSH
72671: LD_VAR 0 5
72675: PUSH
72676: LD_INT 1
72678: MINUS
72679: PPUSH
72680: LD_VAR 0 6
72684: PPUSH
72685: CALL_OW 1
72689: ST_TO_ADDR
// end ;
72690: GO 72607
72692: POP
72693: POP
// result := s_arr [ 1 ] ;
72694: LD_ADDR_VAR 0 4
72698: PUSH
72699: LD_VAR 0 7
72703: PUSH
72704: LD_INT 1
72706: ARRAY
72707: ST_TO_ADDR
// end ; end ;
72708: LD_VAR 0 4
72712: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72713: LD_INT 0
72715: PPUSH
72716: PPUSH
// if not list then
72717: LD_VAR 0 1
72721: NOT
72722: IFFALSE 72726
// exit ;
72724: GO 72817
// i := list [ pos1 ] ;
72726: LD_ADDR_VAR 0 5
72730: PUSH
72731: LD_VAR 0 1
72735: PUSH
72736: LD_VAR 0 2
72740: ARRAY
72741: ST_TO_ADDR
// if not i then
72742: LD_VAR 0 5
72746: NOT
72747: IFFALSE 72751
// exit ;
72749: GO 72817
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72751: LD_ADDR_VAR 0 1
72755: PUSH
72756: LD_VAR 0 1
72760: PPUSH
72761: LD_VAR 0 2
72765: PPUSH
72766: LD_VAR 0 1
72770: PUSH
72771: LD_VAR 0 3
72775: ARRAY
72776: PPUSH
72777: CALL_OW 1
72781: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72782: LD_ADDR_VAR 0 1
72786: PUSH
72787: LD_VAR 0 1
72791: PPUSH
72792: LD_VAR 0 3
72796: PPUSH
72797: LD_VAR 0 5
72801: PPUSH
72802: CALL_OW 1
72806: ST_TO_ADDR
// result := list ;
72807: LD_ADDR_VAR 0 4
72811: PUSH
72812: LD_VAR 0 1
72816: ST_TO_ADDR
// end ;
72817: LD_VAR 0 4
72821: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72822: LD_INT 0
72824: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72825: LD_ADDR_VAR 0 5
72829: PUSH
72830: LD_VAR 0 1
72834: PPUSH
72835: CALL_OW 250
72839: PPUSH
72840: LD_VAR 0 1
72844: PPUSH
72845: CALL_OW 251
72849: PPUSH
72850: LD_VAR 0 2
72854: PPUSH
72855: LD_VAR 0 3
72859: PPUSH
72860: LD_VAR 0 4
72864: PPUSH
72865: CALL 72875 0 5
72869: ST_TO_ADDR
// end ;
72870: LD_VAR 0 5
72874: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72875: LD_INT 0
72877: PPUSH
72878: PPUSH
72879: PPUSH
72880: PPUSH
// if not list then
72881: LD_VAR 0 3
72885: NOT
72886: IFFALSE 72890
// exit ;
72888: GO 73278
// result := [ ] ;
72890: LD_ADDR_VAR 0 6
72894: PUSH
72895: EMPTY
72896: ST_TO_ADDR
// for i in list do
72897: LD_ADDR_VAR 0 7
72901: PUSH
72902: LD_VAR 0 3
72906: PUSH
72907: FOR_IN
72908: IFFALSE 73110
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72910: LD_ADDR_VAR 0 9
72914: PUSH
72915: LD_VAR 0 7
72919: PPUSH
72920: LD_VAR 0 1
72924: PPUSH
72925: LD_VAR 0 2
72929: PPUSH
72930: CALL_OW 297
72934: ST_TO_ADDR
// if not result then
72935: LD_VAR 0 6
72939: NOT
72940: IFFALSE 72966
// result := [ [ i , tmp ] ] else
72942: LD_ADDR_VAR 0 6
72946: PUSH
72947: LD_VAR 0 7
72951: PUSH
72952: LD_VAR 0 9
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: EMPTY
72962: LIST
72963: ST_TO_ADDR
72964: GO 73108
// begin if result [ result ] [ 2 ] < tmp then
72966: LD_VAR 0 6
72970: PUSH
72971: LD_VAR 0 6
72975: ARRAY
72976: PUSH
72977: LD_INT 2
72979: ARRAY
72980: PUSH
72981: LD_VAR 0 9
72985: LESS
72986: IFFALSE 73028
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72988: LD_ADDR_VAR 0 6
72992: PUSH
72993: LD_VAR 0 6
72997: PPUSH
72998: LD_VAR 0 6
73002: PUSH
73003: LD_INT 1
73005: PLUS
73006: PPUSH
73007: LD_VAR 0 7
73011: PUSH
73012: LD_VAR 0 9
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PPUSH
73021: CALL_OW 2
73025: ST_TO_ADDR
73026: GO 73108
// for j = 1 to result do
73028: LD_ADDR_VAR 0 8
73032: PUSH
73033: DOUBLE
73034: LD_INT 1
73036: DEC
73037: ST_TO_ADDR
73038: LD_VAR 0 6
73042: PUSH
73043: FOR_TO
73044: IFFALSE 73106
// begin if tmp < result [ j ] [ 2 ] then
73046: LD_VAR 0 9
73050: PUSH
73051: LD_VAR 0 6
73055: PUSH
73056: LD_VAR 0 8
73060: ARRAY
73061: PUSH
73062: LD_INT 2
73064: ARRAY
73065: LESS
73066: IFFALSE 73104
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73068: LD_ADDR_VAR 0 6
73072: PUSH
73073: LD_VAR 0 6
73077: PPUSH
73078: LD_VAR 0 8
73082: PPUSH
73083: LD_VAR 0 7
73087: PUSH
73088: LD_VAR 0 9
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: PPUSH
73097: CALL_OW 2
73101: ST_TO_ADDR
// break ;
73102: GO 73106
// end ; end ;
73104: GO 73043
73106: POP
73107: POP
// end ; end ;
73108: GO 72907
73110: POP
73111: POP
// if result and not asc then
73112: LD_VAR 0 6
73116: PUSH
73117: LD_VAR 0 4
73121: NOT
73122: AND
73123: IFFALSE 73198
// begin tmp := result ;
73125: LD_ADDR_VAR 0 9
73129: PUSH
73130: LD_VAR 0 6
73134: ST_TO_ADDR
// for i = tmp downto 1 do
73135: LD_ADDR_VAR 0 7
73139: PUSH
73140: DOUBLE
73141: LD_VAR 0 9
73145: INC
73146: ST_TO_ADDR
73147: LD_INT 1
73149: PUSH
73150: FOR_DOWNTO
73151: IFFALSE 73196
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73153: LD_ADDR_VAR 0 6
73157: PUSH
73158: LD_VAR 0 6
73162: PPUSH
73163: LD_VAR 0 9
73167: PUSH
73168: LD_VAR 0 7
73172: MINUS
73173: PUSH
73174: LD_INT 1
73176: PLUS
73177: PPUSH
73178: LD_VAR 0 9
73182: PUSH
73183: LD_VAR 0 7
73187: ARRAY
73188: PPUSH
73189: CALL_OW 1
73193: ST_TO_ADDR
73194: GO 73150
73196: POP
73197: POP
// end ; tmp := [ ] ;
73198: LD_ADDR_VAR 0 9
73202: PUSH
73203: EMPTY
73204: ST_TO_ADDR
// if mode then
73205: LD_VAR 0 5
73209: IFFALSE 73278
// begin for i = 1 to result do
73211: LD_ADDR_VAR 0 7
73215: PUSH
73216: DOUBLE
73217: LD_INT 1
73219: DEC
73220: ST_TO_ADDR
73221: LD_VAR 0 6
73225: PUSH
73226: FOR_TO
73227: IFFALSE 73266
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73229: LD_ADDR_VAR 0 9
73233: PUSH
73234: LD_VAR 0 9
73238: PPUSH
73239: LD_VAR 0 7
73243: PPUSH
73244: LD_VAR 0 6
73248: PUSH
73249: LD_VAR 0 7
73253: ARRAY
73254: PUSH
73255: LD_INT 1
73257: ARRAY
73258: PPUSH
73259: CALL_OW 1
73263: ST_TO_ADDR
73264: GO 73226
73266: POP
73267: POP
// result := tmp ;
73268: LD_ADDR_VAR 0 6
73272: PUSH
73273: LD_VAR 0 9
73277: ST_TO_ADDR
// end ; end ;
73278: LD_VAR 0 6
73282: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73283: LD_INT 0
73285: PPUSH
73286: PPUSH
73287: PPUSH
73288: PPUSH
73289: PPUSH
73290: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73291: LD_ADDR_VAR 0 5
73295: PUSH
73296: LD_INT 0
73298: PUSH
73299: LD_INT 0
73301: PUSH
73302: LD_INT 0
73304: PUSH
73305: EMPTY
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: LIST
73311: LIST
73312: ST_TO_ADDR
// if not x or not y then
73313: LD_VAR 0 2
73317: NOT
73318: PUSH
73319: LD_VAR 0 3
73323: NOT
73324: OR
73325: IFFALSE 73329
// exit ;
73327: GO 74979
// if not range then
73329: LD_VAR 0 4
73333: NOT
73334: IFFALSE 73344
// range := 10 ;
73336: LD_ADDR_VAR 0 4
73340: PUSH
73341: LD_INT 10
73343: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73344: LD_ADDR_VAR 0 8
73348: PUSH
73349: LD_INT 81
73351: PUSH
73352: LD_VAR 0 1
73356: PUSH
73357: EMPTY
73358: LIST
73359: LIST
73360: PUSH
73361: LD_INT 92
73363: PUSH
73364: LD_VAR 0 2
73368: PUSH
73369: LD_VAR 0 3
73373: PUSH
73374: LD_VAR 0 4
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: LIST
73383: LIST
73384: PUSH
73385: LD_INT 3
73387: PUSH
73388: LD_INT 21
73390: PUSH
73391: LD_INT 3
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: LIST
73406: PPUSH
73407: CALL_OW 69
73411: ST_TO_ADDR
// if not tmp then
73412: LD_VAR 0 8
73416: NOT
73417: IFFALSE 73421
// exit ;
73419: GO 74979
// for i in tmp do
73421: LD_ADDR_VAR 0 6
73425: PUSH
73426: LD_VAR 0 8
73430: PUSH
73431: FOR_IN
73432: IFFALSE 74954
// begin points := [ 0 , 0 , 0 ] ;
73434: LD_ADDR_VAR 0 9
73438: PUSH
73439: LD_INT 0
73441: PUSH
73442: LD_INT 0
73444: PUSH
73445: LD_INT 0
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: LIST
73452: ST_TO_ADDR
// bpoints := 1 ;
73453: LD_ADDR_VAR 0 10
73457: PUSH
73458: LD_INT 1
73460: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73461: LD_VAR 0 6
73465: PPUSH
73466: CALL_OW 247
73470: PUSH
73471: LD_INT 1
73473: DOUBLE
73474: EQUAL
73475: IFTRUE 73479
73477: GO 74057
73479: POP
// begin if GetClass ( i ) = 1 then
73480: LD_VAR 0 6
73484: PPUSH
73485: CALL_OW 257
73489: PUSH
73490: LD_INT 1
73492: EQUAL
73493: IFFALSE 73514
// points := [ 10 , 5 , 3 ] ;
73495: LD_ADDR_VAR 0 9
73499: PUSH
73500: LD_INT 10
73502: PUSH
73503: LD_INT 5
73505: PUSH
73506: LD_INT 3
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: LIST
73513: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73514: LD_VAR 0 6
73518: PPUSH
73519: CALL_OW 257
73523: PUSH
73524: LD_INT 2
73526: PUSH
73527: LD_INT 3
73529: PUSH
73530: LD_INT 4
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: LIST
73537: IN
73538: IFFALSE 73559
// points := [ 3 , 2 , 1 ] ;
73540: LD_ADDR_VAR 0 9
73544: PUSH
73545: LD_INT 3
73547: PUSH
73548: LD_INT 2
73550: PUSH
73551: LD_INT 1
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: LIST
73558: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73559: LD_VAR 0 6
73563: PPUSH
73564: CALL_OW 257
73568: PUSH
73569: LD_INT 5
73571: EQUAL
73572: IFFALSE 73593
// points := [ 130 , 5 , 2 ] ;
73574: LD_ADDR_VAR 0 9
73578: PUSH
73579: LD_INT 130
73581: PUSH
73582: LD_INT 5
73584: PUSH
73585: LD_INT 2
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: LIST
73592: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73593: LD_VAR 0 6
73597: PPUSH
73598: CALL_OW 257
73602: PUSH
73603: LD_INT 8
73605: EQUAL
73606: IFFALSE 73627
// points := [ 35 , 35 , 30 ] ;
73608: LD_ADDR_VAR 0 9
73612: PUSH
73613: LD_INT 35
73615: PUSH
73616: LD_INT 35
73618: PUSH
73619: LD_INT 30
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: LIST
73626: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73627: LD_VAR 0 6
73631: PPUSH
73632: CALL_OW 257
73636: PUSH
73637: LD_INT 9
73639: EQUAL
73640: IFFALSE 73661
// points := [ 20 , 55 , 40 ] ;
73642: LD_ADDR_VAR 0 9
73646: PUSH
73647: LD_INT 20
73649: PUSH
73650: LD_INT 55
73652: PUSH
73653: LD_INT 40
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: LIST
73660: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73661: LD_VAR 0 6
73665: PPUSH
73666: CALL_OW 257
73670: PUSH
73671: LD_INT 12
73673: PUSH
73674: LD_INT 16
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: IN
73681: IFFALSE 73702
// points := [ 5 , 3 , 2 ] ;
73683: LD_ADDR_VAR 0 9
73687: PUSH
73688: LD_INT 5
73690: PUSH
73691: LD_INT 3
73693: PUSH
73694: LD_INT 2
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: LIST
73701: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73702: LD_VAR 0 6
73706: PPUSH
73707: CALL_OW 257
73711: PUSH
73712: LD_INT 17
73714: EQUAL
73715: IFFALSE 73736
// points := [ 100 , 50 , 75 ] ;
73717: LD_ADDR_VAR 0 9
73721: PUSH
73722: LD_INT 100
73724: PUSH
73725: LD_INT 50
73727: PUSH
73728: LD_INT 75
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: LIST
73735: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73736: LD_VAR 0 6
73740: PPUSH
73741: CALL_OW 257
73745: PUSH
73746: LD_INT 15
73748: EQUAL
73749: IFFALSE 73770
// points := [ 10 , 5 , 3 ] ;
73751: LD_ADDR_VAR 0 9
73755: PUSH
73756: LD_INT 10
73758: PUSH
73759: LD_INT 5
73761: PUSH
73762: LD_INT 3
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: LIST
73769: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73770: LD_VAR 0 6
73774: PPUSH
73775: CALL_OW 257
73779: PUSH
73780: LD_INT 14
73782: EQUAL
73783: IFFALSE 73804
// points := [ 10 , 0 , 0 ] ;
73785: LD_ADDR_VAR 0 9
73789: PUSH
73790: LD_INT 10
73792: PUSH
73793: LD_INT 0
73795: PUSH
73796: LD_INT 0
73798: PUSH
73799: EMPTY
73800: LIST
73801: LIST
73802: LIST
73803: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73804: LD_VAR 0 6
73808: PPUSH
73809: CALL_OW 257
73813: PUSH
73814: LD_INT 11
73816: EQUAL
73817: IFFALSE 73838
// points := [ 30 , 10 , 5 ] ;
73819: LD_ADDR_VAR 0 9
73823: PUSH
73824: LD_INT 30
73826: PUSH
73827: LD_INT 10
73829: PUSH
73830: LD_INT 5
73832: PUSH
73833: EMPTY
73834: LIST
73835: LIST
73836: LIST
73837: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73838: LD_VAR 0 1
73842: PPUSH
73843: LD_INT 5
73845: PPUSH
73846: CALL_OW 321
73850: PUSH
73851: LD_INT 2
73853: EQUAL
73854: IFFALSE 73871
// bpoints := bpoints * 1.8 ;
73856: LD_ADDR_VAR 0 10
73860: PUSH
73861: LD_VAR 0 10
73865: PUSH
73866: LD_REAL  1.80000000000000E+0000
73869: MUL
73870: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73871: LD_VAR 0 6
73875: PPUSH
73876: CALL_OW 257
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: LD_INT 2
73886: PUSH
73887: LD_INT 3
73889: PUSH
73890: LD_INT 4
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: IN
73899: PUSH
73900: LD_VAR 0 1
73904: PPUSH
73905: LD_INT 51
73907: PPUSH
73908: CALL_OW 321
73912: PUSH
73913: LD_INT 2
73915: EQUAL
73916: AND
73917: IFFALSE 73934
// bpoints := bpoints * 1.2 ;
73919: LD_ADDR_VAR 0 10
73923: PUSH
73924: LD_VAR 0 10
73928: PUSH
73929: LD_REAL  1.20000000000000E+0000
73932: MUL
73933: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73934: LD_VAR 0 6
73938: PPUSH
73939: CALL_OW 257
73943: PUSH
73944: LD_INT 5
73946: PUSH
73947: LD_INT 7
73949: PUSH
73950: LD_INT 9
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: LIST
73957: IN
73958: PUSH
73959: LD_VAR 0 1
73963: PPUSH
73964: LD_INT 52
73966: PPUSH
73967: CALL_OW 321
73971: PUSH
73972: LD_INT 2
73974: EQUAL
73975: AND
73976: IFFALSE 73993
// bpoints := bpoints * 1.5 ;
73978: LD_ADDR_VAR 0 10
73982: PUSH
73983: LD_VAR 0 10
73987: PUSH
73988: LD_REAL  1.50000000000000E+0000
73991: MUL
73992: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73993: LD_VAR 0 1
73997: PPUSH
73998: LD_INT 66
74000: PPUSH
74001: CALL_OW 321
74005: PUSH
74006: LD_INT 2
74008: EQUAL
74009: IFFALSE 74026
// bpoints := bpoints * 1.1 ;
74011: LD_ADDR_VAR 0 10
74015: PUSH
74016: LD_VAR 0 10
74020: PUSH
74021: LD_REAL  1.10000000000000E+0000
74024: MUL
74025: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
74026: LD_ADDR_VAR 0 10
74030: PUSH
74031: LD_VAR 0 10
74035: PUSH
74036: LD_VAR 0 6
74040: PPUSH
74041: LD_INT 1
74043: PPUSH
74044: CALL_OW 259
74048: PUSH
74049: LD_REAL  1.15000000000000E+0000
74052: MUL
74053: MUL
74054: ST_TO_ADDR
// end ; unit_vehicle :
74055: GO 74883
74057: LD_INT 2
74059: DOUBLE
74060: EQUAL
74061: IFTRUE 74065
74063: GO 74871
74065: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74066: LD_VAR 0 6
74070: PPUSH
74071: CALL_OW 264
74075: PUSH
74076: LD_INT 2
74078: PUSH
74079: LD_INT 42
74081: PUSH
74082: LD_INT 24
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: LIST
74089: IN
74090: IFFALSE 74111
// points := [ 25 , 5 , 3 ] ;
74092: LD_ADDR_VAR 0 9
74096: PUSH
74097: LD_INT 25
74099: PUSH
74100: LD_INT 5
74102: PUSH
74103: LD_INT 3
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: LIST
74110: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74111: LD_VAR 0 6
74115: PPUSH
74116: CALL_OW 264
74120: PUSH
74121: LD_INT 4
74123: PUSH
74124: LD_INT 43
74126: PUSH
74127: LD_INT 25
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: LIST
74134: IN
74135: IFFALSE 74156
// points := [ 40 , 15 , 5 ] ;
74137: LD_ADDR_VAR 0 9
74141: PUSH
74142: LD_INT 40
74144: PUSH
74145: LD_INT 15
74147: PUSH
74148: LD_INT 5
74150: PUSH
74151: EMPTY
74152: LIST
74153: LIST
74154: LIST
74155: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74156: LD_VAR 0 6
74160: PPUSH
74161: CALL_OW 264
74165: PUSH
74166: LD_INT 3
74168: PUSH
74169: LD_INT 23
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: IN
74176: IFFALSE 74197
// points := [ 7 , 25 , 8 ] ;
74178: LD_ADDR_VAR 0 9
74182: PUSH
74183: LD_INT 7
74185: PUSH
74186: LD_INT 25
74188: PUSH
74189: LD_INT 8
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: LIST
74196: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74197: LD_VAR 0 6
74201: PPUSH
74202: CALL_OW 264
74206: PUSH
74207: LD_INT 5
74209: PUSH
74210: LD_INT 27
74212: PUSH
74213: LD_INT 44
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: LIST
74220: IN
74221: IFFALSE 74242
// points := [ 14 , 50 , 16 ] ;
74223: LD_ADDR_VAR 0 9
74227: PUSH
74228: LD_INT 14
74230: PUSH
74231: LD_INT 50
74233: PUSH
74234: LD_INT 16
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: LIST
74241: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74242: LD_VAR 0 6
74246: PPUSH
74247: CALL_OW 264
74251: PUSH
74252: LD_INT 6
74254: PUSH
74255: LD_INT 46
74257: PUSH
74258: EMPTY
74259: LIST
74260: LIST
74261: IN
74262: IFFALSE 74283
// points := [ 32 , 120 , 70 ] ;
74264: LD_ADDR_VAR 0 9
74268: PUSH
74269: LD_INT 32
74271: PUSH
74272: LD_INT 120
74274: PUSH
74275: LD_INT 70
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: LIST
74282: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74283: LD_VAR 0 6
74287: PPUSH
74288: CALL_OW 264
74292: PUSH
74293: LD_INT 7
74295: PUSH
74296: LD_INT 28
74298: PUSH
74299: LD_INT 45
74301: PUSH
74302: LD_INT 92
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: LIST
74309: LIST
74310: IN
74311: IFFALSE 74332
// points := [ 35 , 20 , 45 ] ;
74313: LD_ADDR_VAR 0 9
74317: PUSH
74318: LD_INT 35
74320: PUSH
74321: LD_INT 20
74323: PUSH
74324: LD_INT 45
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: LIST
74331: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74332: LD_VAR 0 6
74336: PPUSH
74337: CALL_OW 264
74341: PUSH
74342: LD_INT 47
74344: PUSH
74345: EMPTY
74346: LIST
74347: IN
74348: IFFALSE 74369
// points := [ 67 , 45 , 75 ] ;
74350: LD_ADDR_VAR 0 9
74354: PUSH
74355: LD_INT 67
74357: PUSH
74358: LD_INT 45
74360: PUSH
74361: LD_INT 75
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: LIST
74368: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74369: LD_VAR 0 6
74373: PPUSH
74374: CALL_OW 264
74378: PUSH
74379: LD_INT 26
74381: PUSH
74382: EMPTY
74383: LIST
74384: IN
74385: IFFALSE 74406
// points := [ 120 , 30 , 80 ] ;
74387: LD_ADDR_VAR 0 9
74391: PUSH
74392: LD_INT 120
74394: PUSH
74395: LD_INT 30
74397: PUSH
74398: LD_INT 80
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: LIST
74405: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74406: LD_VAR 0 6
74410: PPUSH
74411: CALL_OW 264
74415: PUSH
74416: LD_INT 22
74418: PUSH
74419: EMPTY
74420: LIST
74421: IN
74422: IFFALSE 74443
// points := [ 40 , 1 , 1 ] ;
74424: LD_ADDR_VAR 0 9
74428: PUSH
74429: LD_INT 40
74431: PUSH
74432: LD_INT 1
74434: PUSH
74435: LD_INT 1
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: LIST
74442: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74443: LD_VAR 0 6
74447: PPUSH
74448: CALL_OW 264
74452: PUSH
74453: LD_INT 29
74455: PUSH
74456: EMPTY
74457: LIST
74458: IN
74459: IFFALSE 74480
// points := [ 70 , 200 , 400 ] ;
74461: LD_ADDR_VAR 0 9
74465: PUSH
74466: LD_INT 70
74468: PUSH
74469: LD_INT 200
74471: PUSH
74472: LD_INT 400
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: LIST
74479: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74480: LD_VAR 0 6
74484: PPUSH
74485: CALL_OW 264
74489: PUSH
74490: LD_INT 14
74492: PUSH
74493: LD_INT 53
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: IN
74500: IFFALSE 74521
// points := [ 40 , 10 , 20 ] ;
74502: LD_ADDR_VAR 0 9
74506: PUSH
74507: LD_INT 40
74509: PUSH
74510: LD_INT 10
74512: PUSH
74513: LD_INT 20
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: LIST
74520: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74521: LD_VAR 0 6
74525: PPUSH
74526: CALL_OW 264
74530: PUSH
74531: LD_INT 9
74533: PUSH
74534: EMPTY
74535: LIST
74536: IN
74537: IFFALSE 74558
// points := [ 5 , 70 , 20 ] ;
74539: LD_ADDR_VAR 0 9
74543: PUSH
74544: LD_INT 5
74546: PUSH
74547: LD_INT 70
74549: PUSH
74550: LD_INT 20
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: LIST
74557: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74558: LD_VAR 0 6
74562: PPUSH
74563: CALL_OW 264
74567: PUSH
74568: LD_INT 10
74570: PUSH
74571: EMPTY
74572: LIST
74573: IN
74574: IFFALSE 74595
// points := [ 35 , 110 , 70 ] ;
74576: LD_ADDR_VAR 0 9
74580: PUSH
74581: LD_INT 35
74583: PUSH
74584: LD_INT 110
74586: PUSH
74587: LD_INT 70
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: LIST
74594: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74595: LD_VAR 0 6
74599: PPUSH
74600: CALL_OW 265
74604: PUSH
74605: LD_INT 25
74607: EQUAL
74608: IFFALSE 74629
// points := [ 80 , 65 , 100 ] ;
74610: LD_ADDR_VAR 0 9
74614: PUSH
74615: LD_INT 80
74617: PUSH
74618: LD_INT 65
74620: PUSH
74621: LD_INT 100
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: LIST
74628: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74629: LD_VAR 0 6
74633: PPUSH
74634: CALL_OW 263
74638: PUSH
74639: LD_INT 1
74641: EQUAL
74642: IFFALSE 74677
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74644: LD_ADDR_VAR 0 10
74648: PUSH
74649: LD_VAR 0 10
74653: PUSH
74654: LD_VAR 0 6
74658: PPUSH
74659: CALL_OW 311
74663: PPUSH
74664: LD_INT 3
74666: PPUSH
74667: CALL_OW 259
74671: PUSH
74672: LD_INT 4
74674: MUL
74675: MUL
74676: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74677: LD_VAR 0 6
74681: PPUSH
74682: CALL_OW 263
74686: PUSH
74687: LD_INT 2
74689: EQUAL
74690: IFFALSE 74741
// begin j := IsControledBy ( i ) ;
74692: LD_ADDR_VAR 0 7
74696: PUSH
74697: LD_VAR 0 6
74701: PPUSH
74702: CALL_OW 312
74706: ST_TO_ADDR
// if j then
74707: LD_VAR 0 7
74711: IFFALSE 74741
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74713: LD_ADDR_VAR 0 10
74717: PUSH
74718: LD_VAR 0 10
74722: PUSH
74723: LD_VAR 0 7
74727: PPUSH
74728: LD_INT 3
74730: PPUSH
74731: CALL_OW 259
74735: PUSH
74736: LD_INT 3
74738: MUL
74739: MUL
74740: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74741: LD_VAR 0 6
74745: PPUSH
74746: CALL_OW 264
74750: PUSH
74751: LD_INT 5
74753: PUSH
74754: LD_INT 6
74756: PUSH
74757: LD_INT 46
74759: PUSH
74760: LD_INT 44
74762: PUSH
74763: LD_INT 47
74765: PUSH
74766: LD_INT 45
74768: PUSH
74769: LD_INT 28
74771: PUSH
74772: LD_INT 7
74774: PUSH
74775: LD_INT 27
74777: PUSH
74778: LD_INT 29
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: LIST
74785: LIST
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: IN
74793: PUSH
74794: LD_VAR 0 1
74798: PPUSH
74799: LD_INT 52
74801: PPUSH
74802: CALL_OW 321
74806: PUSH
74807: LD_INT 2
74809: EQUAL
74810: AND
74811: IFFALSE 74828
// bpoints := bpoints * 1.2 ;
74813: LD_ADDR_VAR 0 10
74817: PUSH
74818: LD_VAR 0 10
74822: PUSH
74823: LD_REAL  1.20000000000000E+0000
74826: MUL
74827: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74828: LD_VAR 0 6
74832: PPUSH
74833: CALL_OW 264
74837: PUSH
74838: LD_INT 6
74840: PUSH
74841: LD_INT 46
74843: PUSH
74844: LD_INT 47
74846: PUSH
74847: EMPTY
74848: LIST
74849: LIST
74850: LIST
74851: IN
74852: IFFALSE 74869
// bpoints := bpoints * 1.2 ;
74854: LD_ADDR_VAR 0 10
74858: PUSH
74859: LD_VAR 0 10
74863: PUSH
74864: LD_REAL  1.20000000000000E+0000
74867: MUL
74868: ST_TO_ADDR
// end ; unit_building :
74869: GO 74883
74871: LD_INT 3
74873: DOUBLE
74874: EQUAL
74875: IFTRUE 74879
74877: GO 74882
74879: POP
// ; end ;
74880: GO 74883
74882: POP
// for j = 1 to 3 do
74883: LD_ADDR_VAR 0 7
74887: PUSH
74888: DOUBLE
74889: LD_INT 1
74891: DEC
74892: ST_TO_ADDR
74893: LD_INT 3
74895: PUSH
74896: FOR_TO
74897: IFFALSE 74950
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74899: LD_ADDR_VAR 0 5
74903: PUSH
74904: LD_VAR 0 5
74908: PPUSH
74909: LD_VAR 0 7
74913: PPUSH
74914: LD_VAR 0 5
74918: PUSH
74919: LD_VAR 0 7
74923: ARRAY
74924: PUSH
74925: LD_VAR 0 9
74929: PUSH
74930: LD_VAR 0 7
74934: ARRAY
74935: PUSH
74936: LD_VAR 0 10
74940: MUL
74941: PLUS
74942: PPUSH
74943: CALL_OW 1
74947: ST_TO_ADDR
74948: GO 74896
74950: POP
74951: POP
// end ;
74952: GO 73431
74954: POP
74955: POP
// result := Replace ( result , 4 , tmp ) ;
74956: LD_ADDR_VAR 0 5
74960: PUSH
74961: LD_VAR 0 5
74965: PPUSH
74966: LD_INT 4
74968: PPUSH
74969: LD_VAR 0 8
74973: PPUSH
74974: CALL_OW 1
74978: ST_TO_ADDR
// end ;
74979: LD_VAR 0 5
74983: RET
// export function DangerAtRange ( unit , range ) ; begin
74984: LD_INT 0
74986: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74987: LD_ADDR_VAR 0 3
74991: PUSH
74992: LD_VAR 0 1
74996: PPUSH
74997: CALL_OW 255
75001: PPUSH
75002: LD_VAR 0 1
75006: PPUSH
75007: CALL_OW 250
75011: PPUSH
75012: LD_VAR 0 1
75016: PPUSH
75017: CALL_OW 251
75021: PPUSH
75022: LD_VAR 0 2
75026: PPUSH
75027: CALL 73283 0 4
75031: ST_TO_ADDR
// end ;
75032: LD_VAR 0 3
75036: RET
// export function DangerInArea ( side , area ) ; begin
75037: LD_INT 0
75039: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
75040: LD_ADDR_VAR 0 3
75044: PUSH
75045: LD_VAR 0 2
75049: PPUSH
75050: LD_INT 81
75052: PUSH
75053: LD_VAR 0 1
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PPUSH
75062: CALL_OW 70
75066: ST_TO_ADDR
// end ;
75067: LD_VAR 0 3
75071: RET
// export function IsExtension ( b ) ; begin
75072: LD_INT 0
75074: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75075: LD_ADDR_VAR 0 2
75079: PUSH
75080: LD_VAR 0 1
75084: PUSH
75085: LD_INT 23
75087: PUSH
75088: LD_INT 20
75090: PUSH
75091: LD_INT 22
75093: PUSH
75094: LD_INT 17
75096: PUSH
75097: LD_INT 24
75099: PUSH
75100: LD_INT 21
75102: PUSH
75103: LD_INT 19
75105: PUSH
75106: LD_INT 16
75108: PUSH
75109: LD_INT 25
75111: PUSH
75112: LD_INT 18
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: LIST
75119: LIST
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: LIST
75125: LIST
75126: IN
75127: ST_TO_ADDR
// end ;
75128: LD_VAR 0 2
75132: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75133: LD_INT 0
75135: PPUSH
75136: PPUSH
75137: PPUSH
// result := [ ] ;
75138: LD_ADDR_VAR 0 4
75142: PUSH
75143: EMPTY
75144: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75145: LD_ADDR_VAR 0 5
75149: PUSH
75150: LD_VAR 0 2
75154: PPUSH
75155: LD_INT 21
75157: PUSH
75158: LD_INT 3
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PPUSH
75165: CALL_OW 70
75169: ST_TO_ADDR
// if not tmp then
75170: LD_VAR 0 5
75174: NOT
75175: IFFALSE 75179
// exit ;
75177: GO 75243
// if checkLink then
75179: LD_VAR 0 3
75183: IFFALSE 75233
// begin for i in tmp do
75185: LD_ADDR_VAR 0 6
75189: PUSH
75190: LD_VAR 0 5
75194: PUSH
75195: FOR_IN
75196: IFFALSE 75231
// if GetBase ( i ) <> base then
75198: LD_VAR 0 6
75202: PPUSH
75203: CALL_OW 274
75207: PUSH
75208: LD_VAR 0 1
75212: NONEQUAL
75213: IFFALSE 75229
// ComLinkToBase ( base , i ) ;
75215: LD_VAR 0 1
75219: PPUSH
75220: LD_VAR 0 6
75224: PPUSH
75225: CALL_OW 169
75229: GO 75195
75231: POP
75232: POP
// end ; result := tmp ;
75233: LD_ADDR_VAR 0 4
75237: PUSH
75238: LD_VAR 0 5
75242: ST_TO_ADDR
// end ;
75243: LD_VAR 0 4
75247: RET
// export function ComComplete ( units , b ) ; var i ; begin
75248: LD_INT 0
75250: PPUSH
75251: PPUSH
// if not units then
75252: LD_VAR 0 1
75256: NOT
75257: IFFALSE 75261
// exit ;
75259: GO 75351
// for i in units do
75261: LD_ADDR_VAR 0 4
75265: PUSH
75266: LD_VAR 0 1
75270: PUSH
75271: FOR_IN
75272: IFFALSE 75349
// if BuildingStatus ( b ) = bs_build then
75274: LD_VAR 0 2
75278: PPUSH
75279: CALL_OW 461
75283: PUSH
75284: LD_INT 1
75286: EQUAL
75287: IFFALSE 75347
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75289: LD_VAR 0 4
75293: PPUSH
75294: LD_STRING h
75296: PUSH
75297: LD_VAR 0 2
75301: PPUSH
75302: CALL_OW 250
75306: PUSH
75307: LD_VAR 0 2
75311: PPUSH
75312: CALL_OW 251
75316: PUSH
75317: LD_VAR 0 2
75321: PUSH
75322: LD_INT 0
75324: PUSH
75325: LD_INT 0
75327: PUSH
75328: LD_INT 0
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: LIST
75335: LIST
75336: LIST
75337: LIST
75338: LIST
75339: PUSH
75340: EMPTY
75341: LIST
75342: PPUSH
75343: CALL_OW 446
75347: GO 75271
75349: POP
75350: POP
// end ;
75351: LD_VAR 0 3
75355: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75356: LD_INT 0
75358: PPUSH
75359: PPUSH
75360: PPUSH
75361: PPUSH
75362: PPUSH
75363: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75364: LD_VAR 0 1
75368: NOT
75369: PUSH
75370: LD_VAR 0 1
75374: PPUSH
75375: CALL_OW 263
75379: PUSH
75380: LD_INT 2
75382: NONEQUAL
75383: OR
75384: IFFALSE 75388
// exit ;
75386: GO 75704
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75388: LD_ADDR_VAR 0 6
75392: PUSH
75393: LD_INT 22
75395: PUSH
75396: LD_VAR 0 1
75400: PPUSH
75401: CALL_OW 255
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 2
75412: PUSH
75413: LD_INT 30
75415: PUSH
75416: LD_INT 36
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 34
75425: PUSH
75426: LD_INT 31
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PUSH
75433: EMPTY
75434: LIST
75435: LIST
75436: LIST
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PPUSH
75442: CALL_OW 69
75446: ST_TO_ADDR
// if not tmp then
75447: LD_VAR 0 6
75451: NOT
75452: IFFALSE 75456
// exit ;
75454: GO 75704
// result := [ ] ;
75456: LD_ADDR_VAR 0 2
75460: PUSH
75461: EMPTY
75462: ST_TO_ADDR
// for i in tmp do
75463: LD_ADDR_VAR 0 3
75467: PUSH
75468: LD_VAR 0 6
75472: PUSH
75473: FOR_IN
75474: IFFALSE 75545
// begin t := UnitsInside ( i ) ;
75476: LD_ADDR_VAR 0 4
75480: PUSH
75481: LD_VAR 0 3
75485: PPUSH
75486: CALL_OW 313
75490: ST_TO_ADDR
// if t then
75491: LD_VAR 0 4
75495: IFFALSE 75543
// for j in t do
75497: LD_ADDR_VAR 0 7
75501: PUSH
75502: LD_VAR 0 4
75506: PUSH
75507: FOR_IN
75508: IFFALSE 75541
// result := Replace ( result , result + 1 , j ) ;
75510: LD_ADDR_VAR 0 2
75514: PUSH
75515: LD_VAR 0 2
75519: PPUSH
75520: LD_VAR 0 2
75524: PUSH
75525: LD_INT 1
75527: PLUS
75528: PPUSH
75529: LD_VAR 0 7
75533: PPUSH
75534: CALL_OW 1
75538: ST_TO_ADDR
75539: GO 75507
75541: POP
75542: POP
// end ;
75543: GO 75473
75545: POP
75546: POP
// if not result then
75547: LD_VAR 0 2
75551: NOT
75552: IFFALSE 75556
// exit ;
75554: GO 75704
// mech := result [ 1 ] ;
75556: LD_ADDR_VAR 0 5
75560: PUSH
75561: LD_VAR 0 2
75565: PUSH
75566: LD_INT 1
75568: ARRAY
75569: ST_TO_ADDR
// if result > 1 then
75570: LD_VAR 0 2
75574: PUSH
75575: LD_INT 1
75577: GREATER
75578: IFFALSE 75690
// begin for i = 2 to result do
75580: LD_ADDR_VAR 0 3
75584: PUSH
75585: DOUBLE
75586: LD_INT 2
75588: DEC
75589: ST_TO_ADDR
75590: LD_VAR 0 2
75594: PUSH
75595: FOR_TO
75596: IFFALSE 75688
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75598: LD_ADDR_VAR 0 4
75602: PUSH
75603: LD_VAR 0 2
75607: PUSH
75608: LD_VAR 0 3
75612: ARRAY
75613: PPUSH
75614: LD_INT 3
75616: PPUSH
75617: CALL_OW 259
75621: PUSH
75622: LD_VAR 0 2
75626: PUSH
75627: LD_VAR 0 3
75631: ARRAY
75632: PPUSH
75633: CALL_OW 432
75637: MINUS
75638: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75639: LD_VAR 0 4
75643: PUSH
75644: LD_VAR 0 5
75648: PPUSH
75649: LD_INT 3
75651: PPUSH
75652: CALL_OW 259
75656: PUSH
75657: LD_VAR 0 5
75661: PPUSH
75662: CALL_OW 432
75666: MINUS
75667: GREATEREQUAL
75668: IFFALSE 75686
// mech := result [ i ] ;
75670: LD_ADDR_VAR 0 5
75674: PUSH
75675: LD_VAR 0 2
75679: PUSH
75680: LD_VAR 0 3
75684: ARRAY
75685: ST_TO_ADDR
// end ;
75686: GO 75595
75688: POP
75689: POP
// end ; ComLinkTo ( vehicle , mech ) ;
75690: LD_VAR 0 1
75694: PPUSH
75695: LD_VAR 0 5
75699: PPUSH
75700: CALL_OW 135
// end ;
75704: LD_VAR 0 2
75708: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75709: LD_INT 0
75711: PPUSH
75712: PPUSH
75713: PPUSH
75714: PPUSH
75715: PPUSH
75716: PPUSH
75717: PPUSH
75718: PPUSH
75719: PPUSH
75720: PPUSH
75721: PPUSH
75722: PPUSH
75723: PPUSH
// result := [ ] ;
75724: LD_ADDR_VAR 0 7
75728: PUSH
75729: EMPTY
75730: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75731: LD_VAR 0 1
75735: PPUSH
75736: CALL_OW 266
75740: PUSH
75741: LD_INT 0
75743: PUSH
75744: LD_INT 1
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: IN
75751: NOT
75752: IFFALSE 75756
// exit ;
75754: GO 77390
// if name then
75756: LD_VAR 0 3
75760: IFFALSE 75776
// SetBName ( base_dep , name ) ;
75762: LD_VAR 0 1
75766: PPUSH
75767: LD_VAR 0 3
75771: PPUSH
75772: CALL_OW 500
// base := GetBase ( base_dep ) ;
75776: LD_ADDR_VAR 0 15
75780: PUSH
75781: LD_VAR 0 1
75785: PPUSH
75786: CALL_OW 274
75790: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75791: LD_ADDR_VAR 0 16
75795: PUSH
75796: LD_VAR 0 1
75800: PPUSH
75801: CALL_OW 255
75805: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75806: LD_ADDR_VAR 0 17
75810: PUSH
75811: LD_VAR 0 1
75815: PPUSH
75816: CALL_OW 248
75820: ST_TO_ADDR
// if sources then
75821: LD_VAR 0 5
75825: IFFALSE 75872
// for i = 1 to 3 do
75827: LD_ADDR_VAR 0 8
75831: PUSH
75832: DOUBLE
75833: LD_INT 1
75835: DEC
75836: ST_TO_ADDR
75837: LD_INT 3
75839: PUSH
75840: FOR_TO
75841: IFFALSE 75870
// AddResourceType ( base , i , sources [ i ] ) ;
75843: LD_VAR 0 15
75847: PPUSH
75848: LD_VAR 0 8
75852: PPUSH
75853: LD_VAR 0 5
75857: PUSH
75858: LD_VAR 0 8
75862: ARRAY
75863: PPUSH
75864: CALL_OW 276
75868: GO 75840
75870: POP
75871: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
75872: LD_ADDR_VAR 0 18
75876: PUSH
75877: LD_VAR 0 15
75881: PPUSH
75882: LD_VAR 0 2
75886: PPUSH
75887: LD_INT 1
75889: PPUSH
75890: CALL 75133 0 3
75894: ST_TO_ADDR
// InitHc ;
75895: CALL_OW 19
// InitUc ;
75899: CALL_OW 18
// uc_side := side ;
75903: LD_ADDR_OWVAR 20
75907: PUSH
75908: LD_VAR 0 16
75912: ST_TO_ADDR
// uc_nation := nation ;
75913: LD_ADDR_OWVAR 21
75917: PUSH
75918: LD_VAR 0 17
75922: ST_TO_ADDR
// if buildings then
75923: LD_VAR 0 18
75927: IFFALSE 77249
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75929: LD_ADDR_VAR 0 19
75933: PUSH
75934: LD_VAR 0 18
75938: PPUSH
75939: LD_INT 2
75941: PUSH
75942: LD_INT 30
75944: PUSH
75945: LD_INT 29
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 30
75954: PUSH
75955: LD_INT 30
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: LIST
75966: PPUSH
75967: CALL_OW 72
75971: ST_TO_ADDR
// if tmp then
75972: LD_VAR 0 19
75976: IFFALSE 76024
// for i in tmp do
75978: LD_ADDR_VAR 0 8
75982: PUSH
75983: LD_VAR 0 19
75987: PUSH
75988: FOR_IN
75989: IFFALSE 76022
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75991: LD_VAR 0 8
75995: PPUSH
75996: CALL_OW 250
76000: PPUSH
76001: LD_VAR 0 8
76005: PPUSH
76006: CALL_OW 251
76010: PPUSH
76011: LD_VAR 0 16
76015: PPUSH
76016: CALL_OW 441
76020: GO 75988
76022: POP
76023: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
76024: LD_VAR 0 18
76028: PPUSH
76029: LD_INT 2
76031: PUSH
76032: LD_INT 30
76034: PUSH
76035: LD_INT 32
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 30
76044: PUSH
76045: LD_INT 33
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: LIST
76056: PPUSH
76057: CALL_OW 72
76061: IFFALSE 76149
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76063: LD_ADDR_VAR 0 8
76067: PUSH
76068: LD_VAR 0 18
76072: PPUSH
76073: LD_INT 2
76075: PUSH
76076: LD_INT 30
76078: PUSH
76079: LD_INT 32
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: PUSH
76086: LD_INT 30
76088: PUSH
76089: LD_INT 33
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: PUSH
76096: EMPTY
76097: LIST
76098: LIST
76099: LIST
76100: PPUSH
76101: CALL_OW 72
76105: PUSH
76106: FOR_IN
76107: IFFALSE 76147
// begin if not GetBWeapon ( i ) then
76109: LD_VAR 0 8
76113: PPUSH
76114: CALL_OW 269
76118: NOT
76119: IFFALSE 76145
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76121: LD_VAR 0 8
76125: PPUSH
76126: LD_VAR 0 8
76130: PPUSH
76131: LD_VAR 0 2
76135: PPUSH
76136: CALL 77395 0 2
76140: PPUSH
76141: CALL_OW 431
// end ;
76145: GO 76106
76147: POP
76148: POP
// end ; for i = 1 to personel do
76149: LD_ADDR_VAR 0 8
76153: PUSH
76154: DOUBLE
76155: LD_INT 1
76157: DEC
76158: ST_TO_ADDR
76159: LD_VAR 0 6
76163: PUSH
76164: FOR_TO
76165: IFFALSE 77229
// begin if i > 4 then
76167: LD_VAR 0 8
76171: PUSH
76172: LD_INT 4
76174: GREATER
76175: IFFALSE 76179
// break ;
76177: GO 77229
// case i of 1 :
76179: LD_VAR 0 8
76183: PUSH
76184: LD_INT 1
76186: DOUBLE
76187: EQUAL
76188: IFTRUE 76192
76190: GO 76272
76192: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76193: LD_ADDR_VAR 0 12
76197: PUSH
76198: LD_VAR 0 18
76202: PPUSH
76203: LD_INT 22
76205: PUSH
76206: LD_VAR 0 16
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: LD_INT 58
76217: PUSH
76218: EMPTY
76219: LIST
76220: PUSH
76221: LD_INT 2
76223: PUSH
76224: LD_INT 30
76226: PUSH
76227: LD_INT 32
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 30
76236: PUSH
76237: LD_INT 4
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 30
76246: PUSH
76247: LD_INT 5
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: LIST
76264: PPUSH
76265: CALL_OW 72
76269: ST_TO_ADDR
76270: GO 76494
76272: LD_INT 2
76274: DOUBLE
76275: EQUAL
76276: IFTRUE 76280
76278: GO 76342
76280: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76281: LD_ADDR_VAR 0 12
76285: PUSH
76286: LD_VAR 0 18
76290: PPUSH
76291: LD_INT 22
76293: PUSH
76294: LD_VAR 0 16
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 2
76305: PUSH
76306: LD_INT 30
76308: PUSH
76309: LD_INT 0
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 30
76318: PUSH
76319: LD_INT 1
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: EMPTY
76327: LIST
76328: LIST
76329: LIST
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PPUSH
76335: CALL_OW 72
76339: ST_TO_ADDR
76340: GO 76494
76342: LD_INT 3
76344: DOUBLE
76345: EQUAL
76346: IFTRUE 76350
76348: GO 76412
76350: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76351: LD_ADDR_VAR 0 12
76355: PUSH
76356: LD_VAR 0 18
76360: PPUSH
76361: LD_INT 22
76363: PUSH
76364: LD_VAR 0 16
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 2
76375: PUSH
76376: LD_INT 30
76378: PUSH
76379: LD_INT 2
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 30
76388: PUSH
76389: LD_INT 3
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: LIST
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PPUSH
76405: CALL_OW 72
76409: ST_TO_ADDR
76410: GO 76494
76412: LD_INT 4
76414: DOUBLE
76415: EQUAL
76416: IFTRUE 76420
76418: GO 76493
76420: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76421: LD_ADDR_VAR 0 12
76425: PUSH
76426: LD_VAR 0 18
76430: PPUSH
76431: LD_INT 22
76433: PUSH
76434: LD_VAR 0 16
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 2
76445: PUSH
76446: LD_INT 30
76448: PUSH
76449: LD_INT 6
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: LD_INT 30
76458: PUSH
76459: LD_INT 7
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 30
76468: PUSH
76469: LD_INT 8
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: LIST
76480: LIST
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PPUSH
76486: CALL_OW 72
76490: ST_TO_ADDR
76491: GO 76494
76493: POP
// if i = 1 then
76494: LD_VAR 0 8
76498: PUSH
76499: LD_INT 1
76501: EQUAL
76502: IFFALSE 76613
// begin tmp := [ ] ;
76504: LD_ADDR_VAR 0 19
76508: PUSH
76509: EMPTY
76510: ST_TO_ADDR
// for j in f do
76511: LD_ADDR_VAR 0 9
76515: PUSH
76516: LD_VAR 0 12
76520: PUSH
76521: FOR_IN
76522: IFFALSE 76595
// if GetBType ( j ) = b_bunker then
76524: LD_VAR 0 9
76528: PPUSH
76529: CALL_OW 266
76533: PUSH
76534: LD_INT 32
76536: EQUAL
76537: IFFALSE 76564
// tmp := Insert ( tmp , 1 , j ) else
76539: LD_ADDR_VAR 0 19
76543: PUSH
76544: LD_VAR 0 19
76548: PPUSH
76549: LD_INT 1
76551: PPUSH
76552: LD_VAR 0 9
76556: PPUSH
76557: CALL_OW 2
76561: ST_TO_ADDR
76562: GO 76593
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76564: LD_ADDR_VAR 0 19
76568: PUSH
76569: LD_VAR 0 19
76573: PPUSH
76574: LD_VAR 0 19
76578: PUSH
76579: LD_INT 1
76581: PLUS
76582: PPUSH
76583: LD_VAR 0 9
76587: PPUSH
76588: CALL_OW 2
76592: ST_TO_ADDR
76593: GO 76521
76595: POP
76596: POP
// if tmp then
76597: LD_VAR 0 19
76601: IFFALSE 76613
// f := tmp ;
76603: LD_ADDR_VAR 0 12
76607: PUSH
76608: LD_VAR 0 19
76612: ST_TO_ADDR
// end ; x := personel [ i ] ;
76613: LD_ADDR_VAR 0 13
76617: PUSH
76618: LD_VAR 0 6
76622: PUSH
76623: LD_VAR 0 8
76627: ARRAY
76628: ST_TO_ADDR
// if x = - 1 then
76629: LD_VAR 0 13
76633: PUSH
76634: LD_INT 1
76636: NEG
76637: EQUAL
76638: IFFALSE 76847
// begin for j in f do
76640: LD_ADDR_VAR 0 9
76644: PUSH
76645: LD_VAR 0 12
76649: PUSH
76650: FOR_IN
76651: IFFALSE 76843
// repeat InitHc ;
76653: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76657: LD_VAR 0 9
76661: PPUSH
76662: CALL_OW 266
76666: PUSH
76667: LD_INT 5
76669: EQUAL
76670: IFFALSE 76740
// begin if UnitsInside ( j ) < 3 then
76672: LD_VAR 0 9
76676: PPUSH
76677: CALL_OW 313
76681: PUSH
76682: LD_INT 3
76684: LESS
76685: IFFALSE 76721
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76687: LD_INT 0
76689: PPUSH
76690: LD_INT 5
76692: PUSH
76693: LD_INT 8
76695: PUSH
76696: LD_INT 9
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: LIST
76703: PUSH
76704: LD_VAR 0 17
76708: ARRAY
76709: PPUSH
76710: LD_VAR 0 4
76714: PPUSH
76715: CALL_OW 380
76719: GO 76738
// PrepareHuman ( false , i , skill ) ;
76721: LD_INT 0
76723: PPUSH
76724: LD_VAR 0 8
76728: PPUSH
76729: LD_VAR 0 4
76733: PPUSH
76734: CALL_OW 380
// end else
76738: GO 76757
// PrepareHuman ( false , i , skill ) ;
76740: LD_INT 0
76742: PPUSH
76743: LD_VAR 0 8
76747: PPUSH
76748: LD_VAR 0 4
76752: PPUSH
76753: CALL_OW 380
// un := CreateHuman ;
76757: LD_ADDR_VAR 0 14
76761: PUSH
76762: CALL_OW 44
76766: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76767: LD_ADDR_VAR 0 7
76771: PUSH
76772: LD_VAR 0 7
76776: PPUSH
76777: LD_INT 1
76779: PPUSH
76780: LD_VAR 0 14
76784: PPUSH
76785: CALL_OW 2
76789: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76790: LD_VAR 0 14
76794: PPUSH
76795: LD_VAR 0 9
76799: PPUSH
76800: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76804: LD_VAR 0 9
76808: PPUSH
76809: CALL_OW 313
76813: PUSH
76814: LD_INT 6
76816: EQUAL
76817: PUSH
76818: LD_VAR 0 9
76822: PPUSH
76823: CALL_OW 266
76827: PUSH
76828: LD_INT 32
76830: PUSH
76831: LD_INT 31
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: IN
76838: OR
76839: IFFALSE 76653
76841: GO 76650
76843: POP
76844: POP
// end else
76845: GO 77227
// for j = 1 to x do
76847: LD_ADDR_VAR 0 9
76851: PUSH
76852: DOUBLE
76853: LD_INT 1
76855: DEC
76856: ST_TO_ADDR
76857: LD_VAR 0 13
76861: PUSH
76862: FOR_TO
76863: IFFALSE 77225
// begin InitHc ;
76865: CALL_OW 19
// if not f then
76869: LD_VAR 0 12
76873: NOT
76874: IFFALSE 76963
// begin PrepareHuman ( false , i , skill ) ;
76876: LD_INT 0
76878: PPUSH
76879: LD_VAR 0 8
76883: PPUSH
76884: LD_VAR 0 4
76888: PPUSH
76889: CALL_OW 380
// un := CreateHuman ;
76893: LD_ADDR_VAR 0 14
76897: PUSH
76898: CALL_OW 44
76902: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76903: LD_ADDR_VAR 0 7
76907: PUSH
76908: LD_VAR 0 7
76912: PPUSH
76913: LD_INT 1
76915: PPUSH
76916: LD_VAR 0 14
76920: PPUSH
76921: CALL_OW 2
76925: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76926: LD_VAR 0 14
76930: PPUSH
76931: LD_VAR 0 1
76935: PPUSH
76936: CALL_OW 250
76940: PPUSH
76941: LD_VAR 0 1
76945: PPUSH
76946: CALL_OW 251
76950: PPUSH
76951: LD_INT 10
76953: PPUSH
76954: LD_INT 0
76956: PPUSH
76957: CALL_OW 50
// continue ;
76961: GO 76862
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76963: LD_VAR 0 12
76967: PUSH
76968: LD_INT 1
76970: ARRAY
76971: PPUSH
76972: CALL_OW 313
76976: PUSH
76977: LD_VAR 0 12
76981: PUSH
76982: LD_INT 1
76984: ARRAY
76985: PPUSH
76986: CALL_OW 266
76990: PUSH
76991: LD_INT 32
76993: PUSH
76994: LD_INT 31
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: IN
77001: AND
77002: PUSH
77003: LD_VAR 0 12
77007: PUSH
77008: LD_INT 1
77010: ARRAY
77011: PPUSH
77012: CALL_OW 313
77016: PUSH
77017: LD_INT 6
77019: EQUAL
77020: OR
77021: IFFALSE 77041
// f := Delete ( f , 1 ) ;
77023: LD_ADDR_VAR 0 12
77027: PUSH
77028: LD_VAR 0 12
77032: PPUSH
77033: LD_INT 1
77035: PPUSH
77036: CALL_OW 3
77040: ST_TO_ADDR
// if not f then
77041: LD_VAR 0 12
77045: NOT
77046: IFFALSE 77064
// begin x := x + 2 ;
77048: LD_ADDR_VAR 0 13
77052: PUSH
77053: LD_VAR 0 13
77057: PUSH
77058: LD_INT 2
77060: PLUS
77061: ST_TO_ADDR
// continue ;
77062: GO 76862
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77064: LD_VAR 0 12
77068: PUSH
77069: LD_INT 1
77071: ARRAY
77072: PPUSH
77073: CALL_OW 266
77077: PUSH
77078: LD_INT 5
77080: EQUAL
77081: IFFALSE 77155
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77083: LD_VAR 0 12
77087: PUSH
77088: LD_INT 1
77090: ARRAY
77091: PPUSH
77092: CALL_OW 313
77096: PUSH
77097: LD_INT 3
77099: LESS
77100: IFFALSE 77136
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77102: LD_INT 0
77104: PPUSH
77105: LD_INT 5
77107: PUSH
77108: LD_INT 8
77110: PUSH
77111: LD_INT 9
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: LIST
77118: PUSH
77119: LD_VAR 0 17
77123: ARRAY
77124: PPUSH
77125: LD_VAR 0 4
77129: PPUSH
77130: CALL_OW 380
77134: GO 77153
// PrepareHuman ( false , i , skill ) ;
77136: LD_INT 0
77138: PPUSH
77139: LD_VAR 0 8
77143: PPUSH
77144: LD_VAR 0 4
77148: PPUSH
77149: CALL_OW 380
// end else
77153: GO 77172
// PrepareHuman ( false , i , skill ) ;
77155: LD_INT 0
77157: PPUSH
77158: LD_VAR 0 8
77162: PPUSH
77163: LD_VAR 0 4
77167: PPUSH
77168: CALL_OW 380
// un := CreateHuman ;
77172: LD_ADDR_VAR 0 14
77176: PUSH
77177: CALL_OW 44
77181: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77182: LD_ADDR_VAR 0 7
77186: PUSH
77187: LD_VAR 0 7
77191: PPUSH
77192: LD_INT 1
77194: PPUSH
77195: LD_VAR 0 14
77199: PPUSH
77200: CALL_OW 2
77204: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77205: LD_VAR 0 14
77209: PPUSH
77210: LD_VAR 0 12
77214: PUSH
77215: LD_INT 1
77217: ARRAY
77218: PPUSH
77219: CALL_OW 52
// end ;
77223: GO 76862
77225: POP
77226: POP
// end ;
77227: GO 76164
77229: POP
77230: POP
// result := result ^ buildings ;
77231: LD_ADDR_VAR 0 7
77235: PUSH
77236: LD_VAR 0 7
77240: PUSH
77241: LD_VAR 0 18
77245: ADD
77246: ST_TO_ADDR
// end else
77247: GO 77390
// begin for i = 1 to personel do
77249: LD_ADDR_VAR 0 8
77253: PUSH
77254: DOUBLE
77255: LD_INT 1
77257: DEC
77258: ST_TO_ADDR
77259: LD_VAR 0 6
77263: PUSH
77264: FOR_TO
77265: IFFALSE 77388
// begin if i > 4 then
77267: LD_VAR 0 8
77271: PUSH
77272: LD_INT 4
77274: GREATER
77275: IFFALSE 77279
// break ;
77277: GO 77388
// x := personel [ i ] ;
77279: LD_ADDR_VAR 0 13
77283: PUSH
77284: LD_VAR 0 6
77288: PUSH
77289: LD_VAR 0 8
77293: ARRAY
77294: ST_TO_ADDR
// if x = - 1 then
77295: LD_VAR 0 13
77299: PUSH
77300: LD_INT 1
77302: NEG
77303: EQUAL
77304: IFFALSE 77308
// continue ;
77306: GO 77264
// PrepareHuman ( false , i , skill ) ;
77308: LD_INT 0
77310: PPUSH
77311: LD_VAR 0 8
77315: PPUSH
77316: LD_VAR 0 4
77320: PPUSH
77321: CALL_OW 380
// un := CreateHuman ;
77325: LD_ADDR_VAR 0 14
77329: PUSH
77330: CALL_OW 44
77334: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77335: LD_VAR 0 14
77339: PPUSH
77340: LD_VAR 0 1
77344: PPUSH
77345: CALL_OW 250
77349: PPUSH
77350: LD_VAR 0 1
77354: PPUSH
77355: CALL_OW 251
77359: PPUSH
77360: LD_INT 10
77362: PPUSH
77363: LD_INT 0
77365: PPUSH
77366: CALL_OW 50
// result := result ^ un ;
77370: LD_ADDR_VAR 0 7
77374: PUSH
77375: LD_VAR 0 7
77379: PUSH
77380: LD_VAR 0 14
77384: ADD
77385: ST_TO_ADDR
// end ;
77386: GO 77264
77388: POP
77389: POP
// end ; end ;
77390: LD_VAR 0 7
77394: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77395: LD_INT 0
77397: PPUSH
77398: PPUSH
77399: PPUSH
77400: PPUSH
77401: PPUSH
77402: PPUSH
77403: PPUSH
77404: PPUSH
77405: PPUSH
77406: PPUSH
77407: PPUSH
77408: PPUSH
77409: PPUSH
77410: PPUSH
77411: PPUSH
77412: PPUSH
// result := false ;
77413: LD_ADDR_VAR 0 3
77417: PUSH
77418: LD_INT 0
77420: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77421: LD_VAR 0 1
77425: NOT
77426: PUSH
77427: LD_VAR 0 1
77431: PPUSH
77432: CALL_OW 266
77436: PUSH
77437: LD_INT 32
77439: PUSH
77440: LD_INT 33
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: IN
77447: NOT
77448: OR
77449: IFFALSE 77453
// exit ;
77451: GO 78562
// nat := GetNation ( tower ) ;
77453: LD_ADDR_VAR 0 12
77457: PUSH
77458: LD_VAR 0 1
77462: PPUSH
77463: CALL_OW 248
77467: ST_TO_ADDR
// side := GetSide ( tower ) ;
77468: LD_ADDR_VAR 0 16
77472: PUSH
77473: LD_VAR 0 1
77477: PPUSH
77478: CALL_OW 255
77482: ST_TO_ADDR
// x := GetX ( tower ) ;
77483: LD_ADDR_VAR 0 10
77487: PUSH
77488: LD_VAR 0 1
77492: PPUSH
77493: CALL_OW 250
77497: ST_TO_ADDR
// y := GetY ( tower ) ;
77498: LD_ADDR_VAR 0 11
77502: PUSH
77503: LD_VAR 0 1
77507: PPUSH
77508: CALL_OW 251
77512: ST_TO_ADDR
// if not x or not y then
77513: LD_VAR 0 10
77517: NOT
77518: PUSH
77519: LD_VAR 0 11
77523: NOT
77524: OR
77525: IFFALSE 77529
// exit ;
77527: GO 78562
// weapon := 0 ;
77529: LD_ADDR_VAR 0 18
77533: PUSH
77534: LD_INT 0
77536: ST_TO_ADDR
// fac_list := [ ] ;
77537: LD_ADDR_VAR 0 17
77541: PUSH
77542: EMPTY
77543: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
77544: LD_ADDR_VAR 0 6
77548: PUSH
77549: LD_VAR 0 1
77553: PPUSH
77554: CALL_OW 274
77558: PPUSH
77559: LD_VAR 0 2
77563: PPUSH
77564: LD_INT 0
77566: PPUSH
77567: CALL 75133 0 3
77571: PPUSH
77572: LD_INT 30
77574: PUSH
77575: LD_INT 3
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PPUSH
77582: CALL_OW 72
77586: ST_TO_ADDR
// if not factories then
77587: LD_VAR 0 6
77591: NOT
77592: IFFALSE 77596
// exit ;
77594: GO 78562
// for i in factories do
77596: LD_ADDR_VAR 0 8
77600: PUSH
77601: LD_VAR 0 6
77605: PUSH
77606: FOR_IN
77607: IFFALSE 77632
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77609: LD_ADDR_VAR 0 17
77613: PUSH
77614: LD_VAR 0 17
77618: PUSH
77619: LD_VAR 0 8
77623: PPUSH
77624: CALL_OW 478
77628: UNION
77629: ST_TO_ADDR
77630: GO 77606
77632: POP
77633: POP
// if not fac_list then
77634: LD_VAR 0 17
77638: NOT
77639: IFFALSE 77643
// exit ;
77641: GO 78562
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77643: LD_ADDR_VAR 0 5
77647: PUSH
77648: LD_INT 4
77650: PUSH
77651: LD_INT 5
77653: PUSH
77654: LD_INT 9
77656: PUSH
77657: LD_INT 10
77659: PUSH
77660: LD_INT 6
77662: PUSH
77663: LD_INT 7
77665: PUSH
77666: LD_INT 11
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: PUSH
77678: LD_INT 27
77680: PUSH
77681: LD_INT 28
77683: PUSH
77684: LD_INT 26
77686: PUSH
77687: LD_INT 30
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 43
77698: PUSH
77699: LD_INT 44
77701: PUSH
77702: LD_INT 46
77704: PUSH
77705: LD_INT 45
77707: PUSH
77708: LD_INT 47
77710: PUSH
77711: LD_INT 49
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: LIST
77726: PUSH
77727: LD_VAR 0 12
77731: ARRAY
77732: ST_TO_ADDR
// list := list isect fac_list ;
77733: LD_ADDR_VAR 0 5
77737: PUSH
77738: LD_VAR 0 5
77742: PUSH
77743: LD_VAR 0 17
77747: ISECT
77748: ST_TO_ADDR
// if not list then
77749: LD_VAR 0 5
77753: NOT
77754: IFFALSE 77758
// exit ;
77756: GO 78562
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77758: LD_VAR 0 12
77762: PUSH
77763: LD_INT 3
77765: EQUAL
77766: PUSH
77767: LD_INT 49
77769: PUSH
77770: LD_VAR 0 5
77774: IN
77775: AND
77776: PUSH
77777: LD_INT 31
77779: PPUSH
77780: LD_VAR 0 16
77784: PPUSH
77785: CALL_OW 321
77789: PUSH
77790: LD_INT 2
77792: EQUAL
77793: AND
77794: IFFALSE 77854
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77796: LD_INT 22
77798: PUSH
77799: LD_VAR 0 16
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 35
77810: PUSH
77811: LD_INT 49
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: PUSH
77818: LD_INT 91
77820: PUSH
77821: LD_VAR 0 1
77825: PUSH
77826: LD_INT 10
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: LIST
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: LIST
77838: PPUSH
77839: CALL_OW 69
77843: NOT
77844: IFFALSE 77854
// weapon := ru_time_lapser ;
77846: LD_ADDR_VAR 0 18
77850: PUSH
77851: LD_INT 49
77853: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77854: LD_VAR 0 12
77858: PUSH
77859: LD_INT 1
77861: PUSH
77862: LD_INT 2
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: IN
77869: PUSH
77870: LD_INT 11
77872: PUSH
77873: LD_VAR 0 5
77877: IN
77878: PUSH
77879: LD_INT 30
77881: PUSH
77882: LD_VAR 0 5
77886: IN
77887: OR
77888: AND
77889: PUSH
77890: LD_INT 6
77892: PPUSH
77893: LD_VAR 0 16
77897: PPUSH
77898: CALL_OW 321
77902: PUSH
77903: LD_INT 2
77905: EQUAL
77906: AND
77907: IFFALSE 78072
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77909: LD_INT 22
77911: PUSH
77912: LD_VAR 0 16
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 2
77923: PUSH
77924: LD_INT 35
77926: PUSH
77927: LD_INT 11
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: PUSH
77934: LD_INT 35
77936: PUSH
77937: LD_INT 30
77939: PUSH
77940: EMPTY
77941: LIST
77942: LIST
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: LIST
77948: PUSH
77949: LD_INT 91
77951: PUSH
77952: LD_VAR 0 1
77956: PUSH
77957: LD_INT 18
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: LIST
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: LIST
77969: PPUSH
77970: CALL_OW 69
77974: NOT
77975: PUSH
77976: LD_INT 22
77978: PUSH
77979: LD_VAR 0 16
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 2
77990: PUSH
77991: LD_INT 30
77993: PUSH
77994: LD_INT 32
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 30
78003: PUSH
78004: LD_INT 33
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 91
78018: PUSH
78019: LD_VAR 0 1
78023: PUSH
78024: LD_INT 12
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: LIST
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: LIST
78036: PUSH
78037: EMPTY
78038: LIST
78039: PPUSH
78040: CALL_OW 69
78044: PUSH
78045: LD_INT 2
78047: GREATER
78048: AND
78049: IFFALSE 78072
// weapon := [ us_radar , ar_radar ] [ nat ] ;
78051: LD_ADDR_VAR 0 18
78055: PUSH
78056: LD_INT 11
78058: PUSH
78059: LD_INT 30
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_VAR 0 12
78070: ARRAY
78071: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78072: LD_VAR 0 18
78076: NOT
78077: PUSH
78078: LD_INT 40
78080: PPUSH
78081: LD_VAR 0 16
78085: PPUSH
78086: CALL_OW 321
78090: PUSH
78091: LD_INT 2
78093: EQUAL
78094: AND
78095: PUSH
78096: LD_INT 7
78098: PUSH
78099: LD_VAR 0 5
78103: IN
78104: PUSH
78105: LD_INT 28
78107: PUSH
78108: LD_VAR 0 5
78112: IN
78113: OR
78114: PUSH
78115: LD_INT 45
78117: PUSH
78118: LD_VAR 0 5
78122: IN
78123: OR
78124: AND
78125: IFFALSE 78379
// begin hex := GetHexInfo ( x , y ) ;
78127: LD_ADDR_VAR 0 4
78131: PUSH
78132: LD_VAR 0 10
78136: PPUSH
78137: LD_VAR 0 11
78141: PPUSH
78142: CALL_OW 546
78146: ST_TO_ADDR
// if hex [ 1 ] then
78147: LD_VAR 0 4
78151: PUSH
78152: LD_INT 1
78154: ARRAY
78155: IFFALSE 78159
// exit ;
78157: GO 78562
// height := hex [ 2 ] ;
78159: LD_ADDR_VAR 0 15
78163: PUSH
78164: LD_VAR 0 4
78168: PUSH
78169: LD_INT 2
78171: ARRAY
78172: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78173: LD_ADDR_VAR 0 14
78177: PUSH
78178: LD_INT 0
78180: PUSH
78181: LD_INT 2
78183: PUSH
78184: LD_INT 3
78186: PUSH
78187: LD_INT 5
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: LIST
78194: LIST
78195: ST_TO_ADDR
// for i in tmp do
78196: LD_ADDR_VAR 0 8
78200: PUSH
78201: LD_VAR 0 14
78205: PUSH
78206: FOR_IN
78207: IFFALSE 78377
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78209: LD_ADDR_VAR 0 9
78213: PUSH
78214: LD_VAR 0 10
78218: PPUSH
78219: LD_VAR 0 8
78223: PPUSH
78224: LD_INT 5
78226: PPUSH
78227: CALL_OW 272
78231: PUSH
78232: LD_VAR 0 11
78236: PPUSH
78237: LD_VAR 0 8
78241: PPUSH
78242: LD_INT 5
78244: PPUSH
78245: CALL_OW 273
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78254: LD_VAR 0 9
78258: PUSH
78259: LD_INT 1
78261: ARRAY
78262: PPUSH
78263: LD_VAR 0 9
78267: PUSH
78268: LD_INT 2
78270: ARRAY
78271: PPUSH
78272: CALL_OW 488
78276: IFFALSE 78375
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78278: LD_ADDR_VAR 0 4
78282: PUSH
78283: LD_VAR 0 9
78287: PUSH
78288: LD_INT 1
78290: ARRAY
78291: PPUSH
78292: LD_VAR 0 9
78296: PUSH
78297: LD_INT 2
78299: ARRAY
78300: PPUSH
78301: CALL_OW 546
78305: ST_TO_ADDR
// if hex [ 1 ] then
78306: LD_VAR 0 4
78310: PUSH
78311: LD_INT 1
78313: ARRAY
78314: IFFALSE 78318
// continue ;
78316: GO 78206
// h := hex [ 2 ] ;
78318: LD_ADDR_VAR 0 13
78322: PUSH
78323: LD_VAR 0 4
78327: PUSH
78328: LD_INT 2
78330: ARRAY
78331: ST_TO_ADDR
// if h + 7 < height then
78332: LD_VAR 0 13
78336: PUSH
78337: LD_INT 7
78339: PLUS
78340: PUSH
78341: LD_VAR 0 15
78345: LESS
78346: IFFALSE 78375
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78348: LD_ADDR_VAR 0 18
78352: PUSH
78353: LD_INT 7
78355: PUSH
78356: LD_INT 28
78358: PUSH
78359: LD_INT 45
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: LIST
78366: PUSH
78367: LD_VAR 0 12
78371: ARRAY
78372: ST_TO_ADDR
// break ;
78373: GO 78377
// end ; end ; end ;
78375: GO 78206
78377: POP
78378: POP
// end ; if not weapon then
78379: LD_VAR 0 18
78383: NOT
78384: IFFALSE 78444
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78386: LD_ADDR_VAR 0 5
78390: PUSH
78391: LD_VAR 0 5
78395: PUSH
78396: LD_INT 11
78398: PUSH
78399: LD_INT 30
78401: PUSH
78402: LD_INT 49
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: LIST
78409: DIFF
78410: ST_TO_ADDR
// if not list then
78411: LD_VAR 0 5
78415: NOT
78416: IFFALSE 78420
// exit ;
78418: GO 78562
// weapon := list [ rand ( 1 , list ) ] ;
78420: LD_ADDR_VAR 0 18
78424: PUSH
78425: LD_VAR 0 5
78429: PUSH
78430: LD_INT 1
78432: PPUSH
78433: LD_VAR 0 5
78437: PPUSH
78438: CALL_OW 12
78442: ARRAY
78443: ST_TO_ADDR
// end ; if weapon then
78444: LD_VAR 0 18
78448: IFFALSE 78562
// begin tmp := CostOfWeapon ( weapon ) ;
78450: LD_ADDR_VAR 0 14
78454: PUSH
78455: LD_VAR 0 18
78459: PPUSH
78460: CALL_OW 451
78464: ST_TO_ADDR
// j := GetBase ( tower ) ;
78465: LD_ADDR_VAR 0 9
78469: PUSH
78470: LD_VAR 0 1
78474: PPUSH
78475: CALL_OW 274
78479: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78480: LD_VAR 0 9
78484: PPUSH
78485: LD_INT 1
78487: PPUSH
78488: CALL_OW 275
78492: PUSH
78493: LD_VAR 0 14
78497: PUSH
78498: LD_INT 1
78500: ARRAY
78501: GREATEREQUAL
78502: PUSH
78503: LD_VAR 0 9
78507: PPUSH
78508: LD_INT 2
78510: PPUSH
78511: CALL_OW 275
78515: PUSH
78516: LD_VAR 0 14
78520: PUSH
78521: LD_INT 2
78523: ARRAY
78524: GREATEREQUAL
78525: AND
78526: PUSH
78527: LD_VAR 0 9
78531: PPUSH
78532: LD_INT 3
78534: PPUSH
78535: CALL_OW 275
78539: PUSH
78540: LD_VAR 0 14
78544: PUSH
78545: LD_INT 3
78547: ARRAY
78548: GREATEREQUAL
78549: AND
78550: IFFALSE 78562
// result := weapon ;
78552: LD_ADDR_VAR 0 3
78556: PUSH
78557: LD_VAR 0 18
78561: ST_TO_ADDR
// end ; end ;
78562: LD_VAR 0 3
78566: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78567: LD_INT 0
78569: PPUSH
78570: PPUSH
// result := true ;
78571: LD_ADDR_VAR 0 3
78575: PUSH
78576: LD_INT 1
78578: ST_TO_ADDR
// if array1 = array2 then
78579: LD_VAR 0 1
78583: PUSH
78584: LD_VAR 0 2
78588: EQUAL
78589: IFFALSE 78649
// begin for i = 1 to array1 do
78591: LD_ADDR_VAR 0 4
78595: PUSH
78596: DOUBLE
78597: LD_INT 1
78599: DEC
78600: ST_TO_ADDR
78601: LD_VAR 0 1
78605: PUSH
78606: FOR_TO
78607: IFFALSE 78645
// if array1 [ i ] <> array2 [ i ] then
78609: LD_VAR 0 1
78613: PUSH
78614: LD_VAR 0 4
78618: ARRAY
78619: PUSH
78620: LD_VAR 0 2
78624: PUSH
78625: LD_VAR 0 4
78629: ARRAY
78630: NONEQUAL
78631: IFFALSE 78643
// begin result := false ;
78633: LD_ADDR_VAR 0 3
78637: PUSH
78638: LD_INT 0
78640: ST_TO_ADDR
// break ;
78641: GO 78645
// end ;
78643: GO 78606
78645: POP
78646: POP
// end else
78647: GO 78657
// result := false ;
78649: LD_ADDR_VAR 0 3
78653: PUSH
78654: LD_INT 0
78656: ST_TO_ADDR
// end ;
78657: LD_VAR 0 3
78661: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
78662: LD_INT 0
78664: PPUSH
78665: PPUSH
// if not array1 or not array2 then
78666: LD_VAR 0 1
78670: NOT
78671: PUSH
78672: LD_VAR 0 2
78676: NOT
78677: OR
78678: IFFALSE 78682
// exit ;
78680: GO 78746
// result := true ;
78682: LD_ADDR_VAR 0 3
78686: PUSH
78687: LD_INT 1
78689: ST_TO_ADDR
// for i = 1 to array1 do
78690: LD_ADDR_VAR 0 4
78694: PUSH
78695: DOUBLE
78696: LD_INT 1
78698: DEC
78699: ST_TO_ADDR
78700: LD_VAR 0 1
78704: PUSH
78705: FOR_TO
78706: IFFALSE 78744
// if array1 [ i ] <> array2 [ i ] then
78708: LD_VAR 0 1
78712: PUSH
78713: LD_VAR 0 4
78717: ARRAY
78718: PUSH
78719: LD_VAR 0 2
78723: PUSH
78724: LD_VAR 0 4
78728: ARRAY
78729: NONEQUAL
78730: IFFALSE 78742
// begin result := false ;
78732: LD_ADDR_VAR 0 3
78736: PUSH
78737: LD_INT 0
78739: ST_TO_ADDR
// break ;
78740: GO 78744
// end ;
78742: GO 78705
78744: POP
78745: POP
// end ;
78746: LD_VAR 0 3
78750: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78751: LD_INT 0
78753: PPUSH
78754: PPUSH
78755: PPUSH
// pom := GetBase ( fac ) ;
78756: LD_ADDR_VAR 0 5
78760: PUSH
78761: LD_VAR 0 1
78765: PPUSH
78766: CALL_OW 274
78770: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78771: LD_ADDR_VAR 0 4
78775: PUSH
78776: LD_VAR 0 2
78780: PUSH
78781: LD_INT 1
78783: ARRAY
78784: PPUSH
78785: LD_VAR 0 2
78789: PUSH
78790: LD_INT 2
78792: ARRAY
78793: PPUSH
78794: LD_VAR 0 2
78798: PUSH
78799: LD_INT 3
78801: ARRAY
78802: PPUSH
78803: LD_VAR 0 2
78807: PUSH
78808: LD_INT 4
78810: ARRAY
78811: PPUSH
78812: CALL_OW 449
78816: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78817: LD_ADDR_VAR 0 3
78821: PUSH
78822: LD_VAR 0 5
78826: PPUSH
78827: LD_INT 1
78829: PPUSH
78830: CALL_OW 275
78834: PUSH
78835: LD_VAR 0 4
78839: PUSH
78840: LD_INT 1
78842: ARRAY
78843: GREATEREQUAL
78844: PUSH
78845: LD_VAR 0 5
78849: PPUSH
78850: LD_INT 2
78852: PPUSH
78853: CALL_OW 275
78857: PUSH
78858: LD_VAR 0 4
78862: PUSH
78863: LD_INT 2
78865: ARRAY
78866: GREATEREQUAL
78867: AND
78868: PUSH
78869: LD_VAR 0 5
78873: PPUSH
78874: LD_INT 3
78876: PPUSH
78877: CALL_OW 275
78881: PUSH
78882: LD_VAR 0 4
78886: PUSH
78887: LD_INT 3
78889: ARRAY
78890: GREATEREQUAL
78891: AND
78892: ST_TO_ADDR
// end ;
78893: LD_VAR 0 3
78897: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78898: LD_INT 0
78900: PPUSH
78901: PPUSH
78902: PPUSH
78903: PPUSH
// pom := GetBase ( building ) ;
78904: LD_ADDR_VAR 0 3
78908: PUSH
78909: LD_VAR 0 1
78913: PPUSH
78914: CALL_OW 274
78918: ST_TO_ADDR
// if not pom then
78919: LD_VAR 0 3
78923: NOT
78924: IFFALSE 78928
// exit ;
78926: GO 79098
// btype := GetBType ( building ) ;
78928: LD_ADDR_VAR 0 5
78932: PUSH
78933: LD_VAR 0 1
78937: PPUSH
78938: CALL_OW 266
78942: ST_TO_ADDR
// if btype = b_armoury then
78943: LD_VAR 0 5
78947: PUSH
78948: LD_INT 4
78950: EQUAL
78951: IFFALSE 78961
// btype := b_barracks ;
78953: LD_ADDR_VAR 0 5
78957: PUSH
78958: LD_INT 5
78960: ST_TO_ADDR
// if btype = b_depot then
78961: LD_VAR 0 5
78965: PUSH
78966: LD_INT 0
78968: EQUAL
78969: IFFALSE 78979
// btype := b_warehouse ;
78971: LD_ADDR_VAR 0 5
78975: PUSH
78976: LD_INT 1
78978: ST_TO_ADDR
// if btype = b_workshop then
78979: LD_VAR 0 5
78983: PUSH
78984: LD_INT 2
78986: EQUAL
78987: IFFALSE 78997
// btype := b_factory ;
78989: LD_ADDR_VAR 0 5
78993: PUSH
78994: LD_INT 3
78996: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78997: LD_ADDR_VAR 0 4
79001: PUSH
79002: LD_VAR 0 5
79006: PPUSH
79007: LD_VAR 0 1
79011: PPUSH
79012: CALL_OW 248
79016: PPUSH
79017: CALL_OW 450
79021: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79022: LD_ADDR_VAR 0 2
79026: PUSH
79027: LD_VAR 0 3
79031: PPUSH
79032: LD_INT 1
79034: PPUSH
79035: CALL_OW 275
79039: PUSH
79040: LD_VAR 0 4
79044: PUSH
79045: LD_INT 1
79047: ARRAY
79048: GREATEREQUAL
79049: PUSH
79050: LD_VAR 0 3
79054: PPUSH
79055: LD_INT 2
79057: PPUSH
79058: CALL_OW 275
79062: PUSH
79063: LD_VAR 0 4
79067: PUSH
79068: LD_INT 2
79070: ARRAY
79071: GREATEREQUAL
79072: AND
79073: PUSH
79074: LD_VAR 0 3
79078: PPUSH
79079: LD_INT 3
79081: PPUSH
79082: CALL_OW 275
79086: PUSH
79087: LD_VAR 0 4
79091: PUSH
79092: LD_INT 3
79094: ARRAY
79095: GREATEREQUAL
79096: AND
79097: ST_TO_ADDR
// end ;
79098: LD_VAR 0 2
79102: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79103: LD_INT 0
79105: PPUSH
79106: PPUSH
79107: PPUSH
// pom := GetBase ( building ) ;
79108: LD_ADDR_VAR 0 4
79112: PUSH
79113: LD_VAR 0 1
79117: PPUSH
79118: CALL_OW 274
79122: ST_TO_ADDR
// if not pom then
79123: LD_VAR 0 4
79127: NOT
79128: IFFALSE 79132
// exit ;
79130: GO 79233
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79132: LD_ADDR_VAR 0 5
79136: PUSH
79137: LD_VAR 0 2
79141: PPUSH
79142: LD_VAR 0 1
79146: PPUSH
79147: CALL_OW 248
79151: PPUSH
79152: CALL_OW 450
79156: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79157: LD_ADDR_VAR 0 3
79161: PUSH
79162: LD_VAR 0 4
79166: PPUSH
79167: LD_INT 1
79169: PPUSH
79170: CALL_OW 275
79174: PUSH
79175: LD_VAR 0 5
79179: PUSH
79180: LD_INT 1
79182: ARRAY
79183: GREATEREQUAL
79184: PUSH
79185: LD_VAR 0 4
79189: PPUSH
79190: LD_INT 2
79192: PPUSH
79193: CALL_OW 275
79197: PUSH
79198: LD_VAR 0 5
79202: PUSH
79203: LD_INT 2
79205: ARRAY
79206: GREATEREQUAL
79207: AND
79208: PUSH
79209: LD_VAR 0 4
79213: PPUSH
79214: LD_INT 3
79216: PPUSH
79217: CALL_OW 275
79221: PUSH
79222: LD_VAR 0 5
79226: PUSH
79227: LD_INT 3
79229: ARRAY
79230: GREATEREQUAL
79231: AND
79232: ST_TO_ADDR
// end ;
79233: LD_VAR 0 3
79237: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79238: LD_INT 0
79240: PPUSH
79241: PPUSH
79242: PPUSH
79243: PPUSH
79244: PPUSH
79245: PPUSH
79246: PPUSH
79247: PPUSH
79248: PPUSH
79249: PPUSH
79250: PPUSH
// result := false ;
79251: LD_ADDR_VAR 0 8
79255: PUSH
79256: LD_INT 0
79258: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79259: LD_VAR 0 5
79263: NOT
79264: PUSH
79265: LD_VAR 0 1
79269: NOT
79270: OR
79271: PUSH
79272: LD_VAR 0 2
79276: NOT
79277: OR
79278: PUSH
79279: LD_VAR 0 3
79283: NOT
79284: OR
79285: IFFALSE 79289
// exit ;
79287: GO 80103
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79289: LD_ADDR_VAR 0 14
79293: PUSH
79294: LD_VAR 0 1
79298: PPUSH
79299: LD_VAR 0 2
79303: PPUSH
79304: LD_VAR 0 3
79308: PPUSH
79309: LD_VAR 0 4
79313: PPUSH
79314: LD_VAR 0 5
79318: PUSH
79319: LD_INT 1
79321: ARRAY
79322: PPUSH
79323: CALL_OW 248
79327: PPUSH
79328: LD_INT 0
79330: PPUSH
79331: CALL 81336 0 6
79335: ST_TO_ADDR
// if not hexes then
79336: LD_VAR 0 14
79340: NOT
79341: IFFALSE 79345
// exit ;
79343: GO 80103
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79345: LD_ADDR_VAR 0 17
79349: PUSH
79350: LD_VAR 0 5
79354: PPUSH
79355: LD_INT 22
79357: PUSH
79358: LD_VAR 0 13
79362: PPUSH
79363: CALL_OW 255
79367: PUSH
79368: EMPTY
79369: LIST
79370: LIST
79371: PUSH
79372: LD_INT 2
79374: PUSH
79375: LD_INT 30
79377: PUSH
79378: LD_INT 0
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 30
79387: PUSH
79388: LD_INT 1
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: LIST
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PPUSH
79404: CALL_OW 72
79408: ST_TO_ADDR
// for i = 1 to hexes do
79409: LD_ADDR_VAR 0 9
79413: PUSH
79414: DOUBLE
79415: LD_INT 1
79417: DEC
79418: ST_TO_ADDR
79419: LD_VAR 0 14
79423: PUSH
79424: FOR_TO
79425: IFFALSE 80101
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79427: LD_ADDR_VAR 0 13
79431: PUSH
79432: LD_VAR 0 14
79436: PUSH
79437: LD_VAR 0 9
79441: ARRAY
79442: PUSH
79443: LD_INT 1
79445: ARRAY
79446: PPUSH
79447: LD_VAR 0 14
79451: PUSH
79452: LD_VAR 0 9
79456: ARRAY
79457: PUSH
79458: LD_INT 2
79460: ARRAY
79461: PPUSH
79462: CALL_OW 428
79466: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79467: LD_VAR 0 14
79471: PUSH
79472: LD_VAR 0 9
79476: ARRAY
79477: PUSH
79478: LD_INT 1
79480: ARRAY
79481: PPUSH
79482: LD_VAR 0 14
79486: PUSH
79487: LD_VAR 0 9
79491: ARRAY
79492: PUSH
79493: LD_INT 2
79495: ARRAY
79496: PPUSH
79497: CALL_OW 351
79501: PUSH
79502: LD_VAR 0 14
79506: PUSH
79507: LD_VAR 0 9
79511: ARRAY
79512: PUSH
79513: LD_INT 1
79515: ARRAY
79516: PPUSH
79517: LD_VAR 0 14
79521: PUSH
79522: LD_VAR 0 9
79526: ARRAY
79527: PUSH
79528: LD_INT 2
79530: ARRAY
79531: PPUSH
79532: CALL_OW 488
79536: NOT
79537: OR
79538: PUSH
79539: LD_VAR 0 13
79543: PPUSH
79544: CALL_OW 247
79548: PUSH
79549: LD_INT 3
79551: EQUAL
79552: OR
79553: IFFALSE 79559
// exit ;
79555: POP
79556: POP
79557: GO 80103
// if not tmp then
79559: LD_VAR 0 13
79563: NOT
79564: IFFALSE 79568
// continue ;
79566: GO 79424
// result := true ;
79568: LD_ADDR_VAR 0 8
79572: PUSH
79573: LD_INT 1
79575: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
79576: LD_VAR 0 6
79580: PUSH
79581: LD_VAR 0 13
79585: PPUSH
79586: CALL_OW 247
79590: PUSH
79591: LD_INT 2
79593: EQUAL
79594: AND
79595: PUSH
79596: LD_VAR 0 13
79600: PPUSH
79601: CALL_OW 263
79605: PUSH
79606: LD_INT 1
79608: EQUAL
79609: AND
79610: IFFALSE 79774
// begin if IsDrivenBy ( tmp ) then
79612: LD_VAR 0 13
79616: PPUSH
79617: CALL_OW 311
79621: IFFALSE 79625
// continue ;
79623: GO 79424
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
79625: LD_VAR 0 6
79629: PPUSH
79630: LD_INT 3
79632: PUSH
79633: LD_INT 60
79635: PUSH
79636: EMPTY
79637: LIST
79638: PUSH
79639: EMPTY
79640: LIST
79641: LIST
79642: PUSH
79643: LD_INT 3
79645: PUSH
79646: LD_INT 55
79648: PUSH
79649: EMPTY
79650: LIST
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PPUSH
79660: CALL_OW 72
79664: IFFALSE 79772
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
79666: LD_ADDR_VAR 0 18
79670: PUSH
79671: LD_VAR 0 6
79675: PPUSH
79676: LD_INT 3
79678: PUSH
79679: LD_INT 60
79681: PUSH
79682: EMPTY
79683: LIST
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 3
79691: PUSH
79692: LD_INT 55
79694: PUSH
79695: EMPTY
79696: LIST
79697: PUSH
79698: EMPTY
79699: LIST
79700: LIST
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PPUSH
79706: CALL_OW 72
79710: PUSH
79711: LD_INT 1
79713: ARRAY
79714: ST_TO_ADDR
// if IsInUnit ( driver ) then
79715: LD_VAR 0 18
79719: PPUSH
79720: CALL_OW 310
79724: IFFALSE 79735
// ComExit ( driver ) ;
79726: LD_VAR 0 18
79730: PPUSH
79731: CALL 105097 0 1
// AddComEnterUnit ( driver , tmp ) ;
79735: LD_VAR 0 18
79739: PPUSH
79740: LD_VAR 0 13
79744: PPUSH
79745: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
79749: LD_VAR 0 18
79753: PPUSH
79754: LD_VAR 0 7
79758: PPUSH
79759: CALL_OW 173
// AddComExitVehicle ( driver ) ;
79763: LD_VAR 0 18
79767: PPUSH
79768: CALL_OW 181
// end ; continue ;
79772: GO 79424
// end ; if not cleaners or not tmp in cleaners then
79774: LD_VAR 0 6
79778: NOT
79779: PUSH
79780: LD_VAR 0 13
79784: PUSH
79785: LD_VAR 0 6
79789: IN
79790: NOT
79791: OR
79792: IFFALSE 80099
// begin if dep then
79794: LD_VAR 0 17
79798: IFFALSE 79934
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79800: LD_ADDR_VAR 0 16
79804: PUSH
79805: LD_VAR 0 17
79809: PUSH
79810: LD_INT 1
79812: ARRAY
79813: PPUSH
79814: CALL_OW 250
79818: PPUSH
79819: LD_VAR 0 17
79823: PUSH
79824: LD_INT 1
79826: ARRAY
79827: PPUSH
79828: CALL_OW 254
79832: PPUSH
79833: LD_INT 5
79835: PPUSH
79836: CALL_OW 272
79840: PUSH
79841: LD_VAR 0 17
79845: PUSH
79846: LD_INT 1
79848: ARRAY
79849: PPUSH
79850: CALL_OW 251
79854: PPUSH
79855: LD_VAR 0 17
79859: PUSH
79860: LD_INT 1
79862: ARRAY
79863: PPUSH
79864: CALL_OW 254
79868: PPUSH
79869: LD_INT 5
79871: PPUSH
79872: CALL_OW 273
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79881: LD_VAR 0 16
79885: PUSH
79886: LD_INT 1
79888: ARRAY
79889: PPUSH
79890: LD_VAR 0 16
79894: PUSH
79895: LD_INT 2
79897: ARRAY
79898: PPUSH
79899: CALL_OW 488
79903: IFFALSE 79934
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79905: LD_VAR 0 13
79909: PPUSH
79910: LD_VAR 0 16
79914: PUSH
79915: LD_INT 1
79917: ARRAY
79918: PPUSH
79919: LD_VAR 0 16
79923: PUSH
79924: LD_INT 2
79926: ARRAY
79927: PPUSH
79928: CALL_OW 111
// continue ;
79932: GO 79424
// end ; end ; r := GetDir ( tmp ) ;
79934: LD_ADDR_VAR 0 15
79938: PUSH
79939: LD_VAR 0 13
79943: PPUSH
79944: CALL_OW 254
79948: ST_TO_ADDR
// if r = 5 then
79949: LD_VAR 0 15
79953: PUSH
79954: LD_INT 5
79956: EQUAL
79957: IFFALSE 79967
// r := 0 ;
79959: LD_ADDR_VAR 0 15
79963: PUSH
79964: LD_INT 0
79966: ST_TO_ADDR
// for j = r to 5 do
79967: LD_ADDR_VAR 0 10
79971: PUSH
79972: DOUBLE
79973: LD_VAR 0 15
79977: DEC
79978: ST_TO_ADDR
79979: LD_INT 5
79981: PUSH
79982: FOR_TO
79983: IFFALSE 80097
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79985: LD_ADDR_VAR 0 11
79989: PUSH
79990: LD_VAR 0 13
79994: PPUSH
79995: CALL_OW 250
79999: PPUSH
80000: LD_VAR 0 10
80004: PPUSH
80005: LD_INT 2
80007: PPUSH
80008: CALL_OW 272
80012: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
80013: LD_ADDR_VAR 0 12
80017: PUSH
80018: LD_VAR 0 13
80022: PPUSH
80023: CALL_OW 251
80027: PPUSH
80028: LD_VAR 0 10
80032: PPUSH
80033: LD_INT 2
80035: PPUSH
80036: CALL_OW 273
80040: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
80041: LD_VAR 0 11
80045: PPUSH
80046: LD_VAR 0 12
80050: PPUSH
80051: CALL_OW 488
80055: PUSH
80056: LD_VAR 0 11
80060: PPUSH
80061: LD_VAR 0 12
80065: PPUSH
80066: CALL_OW 428
80070: NOT
80071: AND
80072: IFFALSE 80095
// begin ComMoveXY ( tmp , _x , _y ) ;
80074: LD_VAR 0 13
80078: PPUSH
80079: LD_VAR 0 11
80083: PPUSH
80084: LD_VAR 0 12
80088: PPUSH
80089: CALL_OW 111
// break ;
80093: GO 80097
// end ; end ;
80095: GO 79982
80097: POP
80098: POP
// end ; end ;
80099: GO 79424
80101: POP
80102: POP
// end ;
80103: LD_VAR 0 8
80107: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80108: LD_INT 0
80110: PPUSH
// result := true ;
80111: LD_ADDR_VAR 0 3
80115: PUSH
80116: LD_INT 1
80118: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80119: LD_VAR 0 2
80123: PUSH
80124: LD_INT 24
80126: DOUBLE
80127: EQUAL
80128: IFTRUE 80138
80130: LD_INT 33
80132: DOUBLE
80133: EQUAL
80134: IFTRUE 80138
80136: GO 80163
80138: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80139: LD_ADDR_VAR 0 3
80143: PUSH
80144: LD_INT 32
80146: PPUSH
80147: LD_VAR 0 1
80151: PPUSH
80152: CALL_OW 321
80156: PUSH
80157: LD_INT 2
80159: EQUAL
80160: ST_TO_ADDR
80161: GO 80479
80163: LD_INT 20
80165: DOUBLE
80166: EQUAL
80167: IFTRUE 80171
80169: GO 80196
80171: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80172: LD_ADDR_VAR 0 3
80176: PUSH
80177: LD_INT 6
80179: PPUSH
80180: LD_VAR 0 1
80184: PPUSH
80185: CALL_OW 321
80189: PUSH
80190: LD_INT 2
80192: EQUAL
80193: ST_TO_ADDR
80194: GO 80479
80196: LD_INT 22
80198: DOUBLE
80199: EQUAL
80200: IFTRUE 80210
80202: LD_INT 36
80204: DOUBLE
80205: EQUAL
80206: IFTRUE 80210
80208: GO 80235
80210: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80211: LD_ADDR_VAR 0 3
80215: PUSH
80216: LD_INT 15
80218: PPUSH
80219: LD_VAR 0 1
80223: PPUSH
80224: CALL_OW 321
80228: PUSH
80229: LD_INT 2
80231: EQUAL
80232: ST_TO_ADDR
80233: GO 80479
80235: LD_INT 30
80237: DOUBLE
80238: EQUAL
80239: IFTRUE 80243
80241: GO 80268
80243: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80244: LD_ADDR_VAR 0 3
80248: PUSH
80249: LD_INT 20
80251: PPUSH
80252: LD_VAR 0 1
80256: PPUSH
80257: CALL_OW 321
80261: PUSH
80262: LD_INT 2
80264: EQUAL
80265: ST_TO_ADDR
80266: GO 80479
80268: LD_INT 28
80270: DOUBLE
80271: EQUAL
80272: IFTRUE 80282
80274: LD_INT 21
80276: DOUBLE
80277: EQUAL
80278: IFTRUE 80282
80280: GO 80307
80282: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80283: LD_ADDR_VAR 0 3
80287: PUSH
80288: LD_INT 21
80290: PPUSH
80291: LD_VAR 0 1
80295: PPUSH
80296: CALL_OW 321
80300: PUSH
80301: LD_INT 2
80303: EQUAL
80304: ST_TO_ADDR
80305: GO 80479
80307: LD_INT 16
80309: DOUBLE
80310: EQUAL
80311: IFTRUE 80315
80313: GO 80340
80315: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80316: LD_ADDR_VAR 0 3
80320: PUSH
80321: LD_INT 84
80323: PPUSH
80324: LD_VAR 0 1
80328: PPUSH
80329: CALL_OW 321
80333: PUSH
80334: LD_INT 2
80336: EQUAL
80337: ST_TO_ADDR
80338: GO 80479
80340: LD_INT 19
80342: DOUBLE
80343: EQUAL
80344: IFTRUE 80354
80346: LD_INT 23
80348: DOUBLE
80349: EQUAL
80350: IFTRUE 80354
80352: GO 80379
80354: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80355: LD_ADDR_VAR 0 3
80359: PUSH
80360: LD_INT 83
80362: PPUSH
80363: LD_VAR 0 1
80367: PPUSH
80368: CALL_OW 321
80372: PUSH
80373: LD_INT 2
80375: EQUAL
80376: ST_TO_ADDR
80377: GO 80479
80379: LD_INT 17
80381: DOUBLE
80382: EQUAL
80383: IFTRUE 80387
80385: GO 80412
80387: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80388: LD_ADDR_VAR 0 3
80392: PUSH
80393: LD_INT 39
80395: PPUSH
80396: LD_VAR 0 1
80400: PPUSH
80401: CALL_OW 321
80405: PUSH
80406: LD_INT 2
80408: EQUAL
80409: ST_TO_ADDR
80410: GO 80479
80412: LD_INT 18
80414: DOUBLE
80415: EQUAL
80416: IFTRUE 80420
80418: GO 80445
80420: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80421: LD_ADDR_VAR 0 3
80425: PUSH
80426: LD_INT 40
80428: PPUSH
80429: LD_VAR 0 1
80433: PPUSH
80434: CALL_OW 321
80438: PUSH
80439: LD_INT 2
80441: EQUAL
80442: ST_TO_ADDR
80443: GO 80479
80445: LD_INT 27
80447: DOUBLE
80448: EQUAL
80449: IFTRUE 80453
80451: GO 80478
80453: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
80454: LD_ADDR_VAR 0 3
80458: PUSH
80459: LD_INT 35
80461: PPUSH
80462: LD_VAR 0 1
80466: PPUSH
80467: CALL_OW 321
80471: PUSH
80472: LD_INT 2
80474: EQUAL
80475: ST_TO_ADDR
80476: GO 80479
80478: POP
// end ;
80479: LD_VAR 0 3
80483: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
80484: LD_INT 0
80486: PPUSH
80487: PPUSH
80488: PPUSH
80489: PPUSH
80490: PPUSH
80491: PPUSH
80492: PPUSH
80493: PPUSH
80494: PPUSH
80495: PPUSH
80496: PPUSH
// result := false ;
80497: LD_ADDR_VAR 0 6
80501: PUSH
80502: LD_INT 0
80504: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
80505: LD_VAR 0 1
80509: NOT
80510: PUSH
80511: LD_VAR 0 1
80515: PPUSH
80516: CALL_OW 266
80520: PUSH
80521: LD_INT 0
80523: PUSH
80524: LD_INT 1
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: IN
80531: NOT
80532: OR
80533: PUSH
80534: LD_VAR 0 2
80538: NOT
80539: OR
80540: PUSH
80541: LD_VAR 0 5
80545: PUSH
80546: LD_INT 0
80548: PUSH
80549: LD_INT 1
80551: PUSH
80552: LD_INT 2
80554: PUSH
80555: LD_INT 3
80557: PUSH
80558: LD_INT 4
80560: PUSH
80561: LD_INT 5
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: IN
80572: NOT
80573: OR
80574: PUSH
80575: LD_VAR 0 3
80579: PPUSH
80580: LD_VAR 0 4
80584: PPUSH
80585: CALL_OW 488
80589: NOT
80590: OR
80591: IFFALSE 80595
// exit ;
80593: GO 81331
// side := GetSide ( depot ) ;
80595: LD_ADDR_VAR 0 9
80599: PUSH
80600: LD_VAR 0 1
80604: PPUSH
80605: CALL_OW 255
80609: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
80610: LD_VAR 0 9
80614: PPUSH
80615: LD_VAR 0 2
80619: PPUSH
80620: CALL 80108 0 2
80624: NOT
80625: IFFALSE 80629
// exit ;
80627: GO 81331
// pom := GetBase ( depot ) ;
80629: LD_ADDR_VAR 0 10
80633: PUSH
80634: LD_VAR 0 1
80638: PPUSH
80639: CALL_OW 274
80643: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
80644: LD_ADDR_VAR 0 11
80648: PUSH
80649: LD_VAR 0 2
80653: PPUSH
80654: LD_VAR 0 1
80658: PPUSH
80659: CALL_OW 248
80663: PPUSH
80664: CALL_OW 450
80668: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
80669: LD_VAR 0 10
80673: PPUSH
80674: LD_INT 1
80676: PPUSH
80677: CALL_OW 275
80681: PUSH
80682: LD_VAR 0 11
80686: PUSH
80687: LD_INT 1
80689: ARRAY
80690: GREATEREQUAL
80691: PUSH
80692: LD_VAR 0 10
80696: PPUSH
80697: LD_INT 2
80699: PPUSH
80700: CALL_OW 275
80704: PUSH
80705: LD_VAR 0 11
80709: PUSH
80710: LD_INT 2
80712: ARRAY
80713: GREATEREQUAL
80714: AND
80715: PUSH
80716: LD_VAR 0 10
80720: PPUSH
80721: LD_INT 3
80723: PPUSH
80724: CALL_OW 275
80728: PUSH
80729: LD_VAR 0 11
80733: PUSH
80734: LD_INT 3
80736: ARRAY
80737: GREATEREQUAL
80738: AND
80739: NOT
80740: IFFALSE 80744
// exit ;
80742: GO 81331
// if GetBType ( depot ) = b_depot then
80744: LD_VAR 0 1
80748: PPUSH
80749: CALL_OW 266
80753: PUSH
80754: LD_INT 0
80756: EQUAL
80757: IFFALSE 80769
// dist := 28 else
80759: LD_ADDR_VAR 0 14
80763: PUSH
80764: LD_INT 28
80766: ST_TO_ADDR
80767: GO 80777
// dist := 36 ;
80769: LD_ADDR_VAR 0 14
80773: PUSH
80774: LD_INT 36
80776: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
80777: LD_VAR 0 1
80781: PPUSH
80782: LD_VAR 0 3
80786: PPUSH
80787: LD_VAR 0 4
80791: PPUSH
80792: CALL_OW 297
80796: PUSH
80797: LD_VAR 0 14
80801: GREATER
80802: IFFALSE 80806
// exit ;
80804: GO 81331
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
80806: LD_ADDR_VAR 0 12
80810: PUSH
80811: LD_VAR 0 2
80815: PPUSH
80816: LD_VAR 0 3
80820: PPUSH
80821: LD_VAR 0 4
80825: PPUSH
80826: LD_VAR 0 5
80830: PPUSH
80831: LD_VAR 0 1
80835: PPUSH
80836: CALL_OW 248
80840: PPUSH
80841: LD_INT 0
80843: PPUSH
80844: CALL 81336 0 6
80848: ST_TO_ADDR
// if not hexes then
80849: LD_VAR 0 12
80853: NOT
80854: IFFALSE 80858
// exit ;
80856: GO 81331
// hex := GetHexInfo ( x , y ) ;
80858: LD_ADDR_VAR 0 15
80862: PUSH
80863: LD_VAR 0 3
80867: PPUSH
80868: LD_VAR 0 4
80872: PPUSH
80873: CALL_OW 546
80877: ST_TO_ADDR
// if hex [ 1 ] then
80878: LD_VAR 0 15
80882: PUSH
80883: LD_INT 1
80885: ARRAY
80886: IFFALSE 80890
// exit ;
80888: GO 81331
// height := hex [ 2 ] ;
80890: LD_ADDR_VAR 0 13
80894: PUSH
80895: LD_VAR 0 15
80899: PUSH
80900: LD_INT 2
80902: ARRAY
80903: ST_TO_ADDR
// for i = 1 to hexes do
80904: LD_ADDR_VAR 0 7
80908: PUSH
80909: DOUBLE
80910: LD_INT 1
80912: DEC
80913: ST_TO_ADDR
80914: LD_VAR 0 12
80918: PUSH
80919: FOR_TO
80920: IFFALSE 81250
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
80922: LD_VAR 0 12
80926: PUSH
80927: LD_VAR 0 7
80931: ARRAY
80932: PUSH
80933: LD_INT 1
80935: ARRAY
80936: PPUSH
80937: LD_VAR 0 12
80941: PUSH
80942: LD_VAR 0 7
80946: ARRAY
80947: PUSH
80948: LD_INT 2
80950: ARRAY
80951: PPUSH
80952: CALL_OW 488
80956: NOT
80957: PUSH
80958: LD_VAR 0 12
80962: PUSH
80963: LD_VAR 0 7
80967: ARRAY
80968: PUSH
80969: LD_INT 1
80971: ARRAY
80972: PPUSH
80973: LD_VAR 0 12
80977: PUSH
80978: LD_VAR 0 7
80982: ARRAY
80983: PUSH
80984: LD_INT 2
80986: ARRAY
80987: PPUSH
80988: CALL_OW 428
80992: PUSH
80993: LD_INT 0
80995: GREATER
80996: OR
80997: PUSH
80998: LD_VAR 0 12
81002: PUSH
81003: LD_VAR 0 7
81007: ARRAY
81008: PUSH
81009: LD_INT 1
81011: ARRAY
81012: PPUSH
81013: LD_VAR 0 12
81017: PUSH
81018: LD_VAR 0 7
81022: ARRAY
81023: PUSH
81024: LD_INT 2
81026: ARRAY
81027: PPUSH
81028: CALL_OW 351
81032: OR
81033: IFFALSE 81039
// exit ;
81035: POP
81036: POP
81037: GO 81331
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81039: LD_ADDR_VAR 0 8
81043: PUSH
81044: LD_VAR 0 12
81048: PUSH
81049: LD_VAR 0 7
81053: ARRAY
81054: PUSH
81055: LD_INT 1
81057: ARRAY
81058: PPUSH
81059: LD_VAR 0 12
81063: PUSH
81064: LD_VAR 0 7
81068: ARRAY
81069: PUSH
81070: LD_INT 2
81072: ARRAY
81073: PPUSH
81074: CALL_OW 546
81078: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81079: LD_VAR 0 8
81083: PUSH
81084: LD_INT 1
81086: ARRAY
81087: PUSH
81088: LD_VAR 0 8
81092: PUSH
81093: LD_INT 2
81095: ARRAY
81096: PUSH
81097: LD_VAR 0 13
81101: PUSH
81102: LD_INT 2
81104: PLUS
81105: GREATER
81106: OR
81107: PUSH
81108: LD_VAR 0 8
81112: PUSH
81113: LD_INT 2
81115: ARRAY
81116: PUSH
81117: LD_VAR 0 13
81121: PUSH
81122: LD_INT 2
81124: MINUS
81125: LESS
81126: OR
81127: PUSH
81128: LD_VAR 0 8
81132: PUSH
81133: LD_INT 3
81135: ARRAY
81136: PUSH
81137: LD_INT 0
81139: PUSH
81140: LD_INT 8
81142: PUSH
81143: LD_INT 9
81145: PUSH
81146: LD_INT 10
81148: PUSH
81149: LD_INT 11
81151: PUSH
81152: LD_INT 12
81154: PUSH
81155: LD_INT 13
81157: PUSH
81158: LD_INT 16
81160: PUSH
81161: LD_INT 17
81163: PUSH
81164: LD_INT 18
81166: PUSH
81167: LD_INT 19
81169: PUSH
81170: LD_INT 20
81172: PUSH
81173: LD_INT 21
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: IN
81191: NOT
81192: OR
81193: PUSH
81194: LD_VAR 0 8
81198: PUSH
81199: LD_INT 5
81201: ARRAY
81202: NOT
81203: OR
81204: PUSH
81205: LD_VAR 0 8
81209: PUSH
81210: LD_INT 6
81212: ARRAY
81213: PUSH
81214: LD_INT 1
81216: PUSH
81217: LD_INT 2
81219: PUSH
81220: LD_INT 7
81222: PUSH
81223: LD_INT 9
81225: PUSH
81226: LD_INT 10
81228: PUSH
81229: LD_INT 11
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: LIST
81238: LIST
81239: IN
81240: NOT
81241: OR
81242: IFFALSE 81248
// exit ;
81244: POP
81245: POP
81246: GO 81331
// end ;
81248: GO 80919
81250: POP
81251: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81252: LD_VAR 0 9
81256: PPUSH
81257: LD_VAR 0 3
81261: PPUSH
81262: LD_VAR 0 4
81266: PPUSH
81267: LD_INT 20
81269: PPUSH
81270: CALL 73283 0 4
81274: PUSH
81275: LD_INT 4
81277: ARRAY
81278: IFFALSE 81282
// exit ;
81280: GO 81331
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81282: LD_VAR 0 2
81286: PUSH
81287: LD_INT 29
81289: PUSH
81290: LD_INT 30
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: IN
81297: PUSH
81298: LD_VAR 0 3
81302: PPUSH
81303: LD_VAR 0 4
81307: PPUSH
81308: LD_VAR 0 9
81312: PPUSH
81313: CALL_OW 440
81317: NOT
81318: AND
81319: IFFALSE 81323
// exit ;
81321: GO 81331
// result := true ;
81323: LD_ADDR_VAR 0 6
81327: PUSH
81328: LD_INT 1
81330: ST_TO_ADDR
// end ;
81331: LD_VAR 0 6
81335: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81336: LD_INT 0
81338: PPUSH
81339: PPUSH
81340: PPUSH
81341: PPUSH
81342: PPUSH
81343: PPUSH
81344: PPUSH
81345: PPUSH
81346: PPUSH
81347: PPUSH
81348: PPUSH
81349: PPUSH
81350: PPUSH
81351: PPUSH
81352: PPUSH
81353: PPUSH
81354: PPUSH
81355: PPUSH
81356: PPUSH
81357: PPUSH
81358: PPUSH
81359: PPUSH
81360: PPUSH
81361: PPUSH
81362: PPUSH
81363: PPUSH
81364: PPUSH
81365: PPUSH
81366: PPUSH
81367: PPUSH
81368: PPUSH
81369: PPUSH
81370: PPUSH
81371: PPUSH
81372: PPUSH
81373: PPUSH
81374: PPUSH
81375: PPUSH
81376: PPUSH
81377: PPUSH
81378: PPUSH
81379: PPUSH
81380: PPUSH
81381: PPUSH
81382: PPUSH
81383: PPUSH
81384: PPUSH
81385: PPUSH
81386: PPUSH
81387: PPUSH
81388: PPUSH
81389: PPUSH
81390: PPUSH
81391: PPUSH
81392: PPUSH
81393: PPUSH
81394: PPUSH
81395: PPUSH
// result = [ ] ;
81396: LD_ADDR_VAR 0 7
81400: PUSH
81401: EMPTY
81402: ST_TO_ADDR
// temp_list = [ ] ;
81403: LD_ADDR_VAR 0 9
81407: PUSH
81408: EMPTY
81409: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81410: LD_VAR 0 4
81414: PUSH
81415: LD_INT 0
81417: PUSH
81418: LD_INT 1
81420: PUSH
81421: LD_INT 2
81423: PUSH
81424: LD_INT 3
81426: PUSH
81427: LD_INT 4
81429: PUSH
81430: LD_INT 5
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: IN
81441: NOT
81442: PUSH
81443: LD_VAR 0 1
81447: PUSH
81448: LD_INT 0
81450: PUSH
81451: LD_INT 1
81453: PUSH
81454: EMPTY
81455: LIST
81456: LIST
81457: IN
81458: PUSH
81459: LD_VAR 0 5
81463: PUSH
81464: LD_INT 1
81466: PUSH
81467: LD_INT 2
81469: PUSH
81470: LD_INT 3
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: LIST
81477: IN
81478: NOT
81479: AND
81480: OR
81481: IFFALSE 81485
// exit ;
81483: GO 99876
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
81485: LD_VAR 0 1
81489: PUSH
81490: LD_INT 6
81492: PUSH
81493: LD_INT 7
81495: PUSH
81496: LD_INT 8
81498: PUSH
81499: LD_INT 13
81501: PUSH
81502: LD_INT 12
81504: PUSH
81505: LD_INT 15
81507: PUSH
81508: LD_INT 11
81510: PUSH
81511: LD_INT 14
81513: PUSH
81514: LD_INT 10
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: IN
81528: IFFALSE 81538
// btype = b_lab ;
81530: LD_ADDR_VAR 0 1
81534: PUSH
81535: LD_INT 6
81537: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
81538: LD_VAR 0 6
81542: PUSH
81543: LD_INT 0
81545: PUSH
81546: LD_INT 1
81548: PUSH
81549: LD_INT 2
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: LIST
81556: IN
81557: NOT
81558: PUSH
81559: LD_VAR 0 1
81563: PUSH
81564: LD_INT 0
81566: PUSH
81567: LD_INT 1
81569: PUSH
81570: LD_INT 2
81572: PUSH
81573: LD_INT 3
81575: PUSH
81576: LD_INT 6
81578: PUSH
81579: LD_INT 36
81581: PUSH
81582: LD_INT 4
81584: PUSH
81585: LD_INT 5
81587: PUSH
81588: LD_INT 31
81590: PUSH
81591: LD_INT 32
81593: PUSH
81594: LD_INT 33
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: IN
81610: NOT
81611: PUSH
81612: LD_VAR 0 6
81616: PUSH
81617: LD_INT 1
81619: EQUAL
81620: AND
81621: OR
81622: PUSH
81623: LD_VAR 0 1
81627: PUSH
81628: LD_INT 2
81630: PUSH
81631: LD_INT 3
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: IN
81638: NOT
81639: PUSH
81640: LD_VAR 0 6
81644: PUSH
81645: LD_INT 2
81647: EQUAL
81648: AND
81649: OR
81650: IFFALSE 81660
// mode = 0 ;
81652: LD_ADDR_VAR 0 6
81656: PUSH
81657: LD_INT 0
81659: ST_TO_ADDR
// case mode of 0 :
81660: LD_VAR 0 6
81664: PUSH
81665: LD_INT 0
81667: DOUBLE
81668: EQUAL
81669: IFTRUE 81673
81671: GO 93126
81673: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81674: LD_ADDR_VAR 0 11
81678: PUSH
81679: LD_INT 0
81681: PUSH
81682: LD_INT 0
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 0
81691: PUSH
81692: LD_INT 1
81694: NEG
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: PUSH
81700: LD_INT 1
81702: PUSH
81703: LD_INT 0
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 1
81712: PUSH
81713: LD_INT 1
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: LD_INT 0
81722: PUSH
81723: LD_INT 1
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 1
81732: NEG
81733: PUSH
81734: LD_INT 0
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: PUSH
81741: LD_INT 1
81743: NEG
81744: PUSH
81745: LD_INT 1
81747: NEG
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 1
81755: NEG
81756: PUSH
81757: LD_INT 2
81759: NEG
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 0
81767: PUSH
81768: LD_INT 2
81770: NEG
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 1
81778: PUSH
81779: LD_INT 1
81781: NEG
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 1
81789: PUSH
81790: LD_INT 2
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 0
81799: PUSH
81800: LD_INT 2
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 1
81809: NEG
81810: PUSH
81811: LD_INT 1
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 1
81820: PUSH
81821: LD_INT 3
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 0
81830: PUSH
81831: LD_INT 3
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 1
81840: NEG
81841: PUSH
81842: LD_INT 2
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: LIST
81853: LIST
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: LIST
81861: LIST
81862: LIST
81863: LIST
81864: LIST
81865: LIST
81866: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81867: LD_ADDR_VAR 0 12
81871: PUSH
81872: LD_INT 0
81874: PUSH
81875: LD_INT 0
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 0
81884: PUSH
81885: LD_INT 1
81887: NEG
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_INT 1
81895: PUSH
81896: LD_INT 0
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 1
81905: PUSH
81906: LD_INT 1
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 0
81915: PUSH
81916: LD_INT 1
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 1
81925: NEG
81926: PUSH
81927: LD_INT 0
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 1
81936: NEG
81937: PUSH
81938: LD_INT 1
81940: NEG
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 1
81948: PUSH
81949: LD_INT 1
81951: NEG
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 2
81959: PUSH
81960: LD_INT 0
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: LD_INT 2
81969: PUSH
81970: LD_INT 1
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 1
81979: NEG
81980: PUSH
81981: LD_INT 1
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 2
81990: NEG
81991: PUSH
81992: LD_INT 0
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 2
82001: NEG
82002: PUSH
82003: LD_INT 1
82005: NEG
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 2
82013: NEG
82014: PUSH
82015: LD_INT 1
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 3
82024: NEG
82025: PUSH
82026: LD_INT 0
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 3
82035: NEG
82036: PUSH
82037: LD_INT 1
82039: NEG
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: LIST
82052: LIST
82053: LIST
82054: LIST
82055: LIST
82056: LIST
82057: LIST
82058: LIST
82059: LIST
82060: LIST
82061: LIST
82062: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82063: LD_ADDR_VAR 0 13
82067: PUSH
82068: LD_INT 0
82070: PUSH
82071: LD_INT 0
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 0
82080: PUSH
82081: LD_INT 1
82083: NEG
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PUSH
82089: LD_INT 1
82091: PUSH
82092: LD_INT 0
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 1
82101: PUSH
82102: LD_INT 1
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 0
82111: PUSH
82112: LD_INT 1
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 1
82121: NEG
82122: PUSH
82123: LD_INT 0
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 1
82132: NEG
82133: PUSH
82134: LD_INT 1
82136: NEG
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 1
82144: NEG
82145: PUSH
82146: LD_INT 2
82148: NEG
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 2
82156: PUSH
82157: LD_INT 1
82159: PUSH
82160: EMPTY
82161: LIST
82162: LIST
82163: PUSH
82164: LD_INT 2
82166: PUSH
82167: LD_INT 2
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 1
82176: PUSH
82177: LD_INT 2
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: PUSH
82184: LD_INT 2
82186: NEG
82187: PUSH
82188: LD_INT 1
82190: NEG
82191: PUSH
82192: EMPTY
82193: LIST
82194: LIST
82195: PUSH
82196: LD_INT 2
82198: NEG
82199: PUSH
82200: LD_INT 2
82202: NEG
82203: PUSH
82204: EMPTY
82205: LIST
82206: LIST
82207: PUSH
82208: LD_INT 2
82210: NEG
82211: PUSH
82212: LD_INT 3
82214: NEG
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 3
82222: NEG
82223: PUSH
82224: LD_INT 2
82226: NEG
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 3
82234: NEG
82235: PUSH
82236: LD_INT 3
82238: NEG
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82262: LD_ADDR_VAR 0 14
82266: PUSH
82267: LD_INT 0
82269: PUSH
82270: LD_INT 0
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 0
82279: PUSH
82280: LD_INT 1
82282: NEG
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 1
82290: PUSH
82291: LD_INT 0
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 1
82300: PUSH
82301: LD_INT 1
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 0
82310: PUSH
82311: LD_INT 1
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: PUSH
82318: LD_INT 1
82320: NEG
82321: PUSH
82322: LD_INT 0
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 1
82331: NEG
82332: PUSH
82333: LD_INT 1
82335: NEG
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 1
82343: NEG
82344: PUSH
82345: LD_INT 2
82347: NEG
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 0
82355: PUSH
82356: LD_INT 2
82358: NEG
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 1
82366: PUSH
82367: LD_INT 1
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 1
82377: PUSH
82378: LD_INT 2
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: LD_INT 0
82387: PUSH
82388: LD_INT 2
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 1
82397: NEG
82398: PUSH
82399: LD_INT 1
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 1
82408: NEG
82409: PUSH
82410: LD_INT 3
82412: NEG
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: LD_INT 0
82420: PUSH
82421: LD_INT 3
82423: NEG
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 1
82431: PUSH
82432: LD_INT 2
82434: NEG
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: LIST
82444: LIST
82445: LIST
82446: LIST
82447: LIST
82448: LIST
82449: LIST
82450: LIST
82451: LIST
82452: LIST
82453: LIST
82454: LIST
82455: LIST
82456: LIST
82457: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82458: LD_ADDR_VAR 0 15
82462: PUSH
82463: LD_INT 0
82465: PUSH
82466: LD_INT 0
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: PUSH
82473: LD_INT 0
82475: PUSH
82476: LD_INT 1
82478: NEG
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 1
82486: PUSH
82487: LD_INT 0
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 1
82496: PUSH
82497: LD_INT 1
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 0
82506: PUSH
82507: LD_INT 1
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 1
82516: NEG
82517: PUSH
82518: LD_INT 0
82520: PUSH
82521: EMPTY
82522: LIST
82523: LIST
82524: PUSH
82525: LD_INT 1
82527: NEG
82528: PUSH
82529: LD_INT 1
82531: NEG
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: PUSH
82537: LD_INT 1
82539: PUSH
82540: LD_INT 1
82542: NEG
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 2
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 2
82560: PUSH
82561: LD_INT 1
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: PUSH
82568: LD_INT 1
82570: NEG
82571: PUSH
82572: LD_INT 1
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: PUSH
82579: LD_INT 2
82581: NEG
82582: PUSH
82583: LD_INT 0
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 2
82592: NEG
82593: PUSH
82594: LD_INT 1
82596: NEG
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 2
82604: PUSH
82605: LD_INT 1
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 3
82615: PUSH
82616: LD_INT 0
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 3
82625: PUSH
82626: LD_INT 1
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82651: LD_ADDR_VAR 0 16
82655: PUSH
82656: LD_INT 0
82658: PUSH
82659: LD_INT 0
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_INT 0
82668: PUSH
82669: LD_INT 1
82671: NEG
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: PUSH
82677: LD_INT 1
82679: PUSH
82680: LD_INT 0
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 1
82689: PUSH
82690: LD_INT 1
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: LD_INT 0
82699: PUSH
82700: LD_INT 1
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 1
82709: NEG
82710: PUSH
82711: LD_INT 0
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 1
82720: NEG
82721: PUSH
82722: LD_INT 1
82724: NEG
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 1
82732: NEG
82733: PUSH
82734: LD_INT 2
82736: NEG
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 2
82744: PUSH
82745: LD_INT 1
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 2
82754: PUSH
82755: LD_INT 2
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 1
82764: PUSH
82765: LD_INT 2
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 2
82774: NEG
82775: PUSH
82776: LD_INT 1
82778: NEG
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 2
82786: NEG
82787: PUSH
82788: LD_INT 2
82790: NEG
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 3
82798: PUSH
82799: LD_INT 2
82801: PUSH
82802: EMPTY
82803: LIST
82804: LIST
82805: PUSH
82806: LD_INT 3
82808: PUSH
82809: LD_INT 3
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 2
82818: PUSH
82819: LD_INT 3
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82844: LD_ADDR_VAR 0 17
82848: PUSH
82849: LD_INT 0
82851: PUSH
82852: LD_INT 0
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 0
82861: PUSH
82862: LD_INT 1
82864: NEG
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 1
82872: PUSH
82873: LD_INT 0
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 1
82882: PUSH
82883: LD_INT 1
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 0
82892: PUSH
82893: LD_INT 1
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 1
82902: NEG
82903: PUSH
82904: LD_INT 0
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 1
82913: NEG
82914: PUSH
82915: LD_INT 1
82917: NEG
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 1
82925: NEG
82926: PUSH
82927: LD_INT 2
82929: NEG
82930: PUSH
82931: EMPTY
82932: LIST
82933: LIST
82934: PUSH
82935: LD_INT 0
82937: PUSH
82938: LD_INT 2
82940: NEG
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 1
82948: PUSH
82949: LD_INT 1
82951: NEG
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 2
82959: PUSH
82960: LD_INT 0
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 2
82969: PUSH
82970: LD_INT 1
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PUSH
82977: LD_INT 2
82979: PUSH
82980: LD_INT 2
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 1
82989: PUSH
82990: LD_INT 2
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 0
82999: PUSH
83000: LD_INT 2
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 1
83009: NEG
83010: PUSH
83011: LD_INT 1
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 2
83020: NEG
83021: PUSH
83022: LD_INT 0
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 2
83031: NEG
83032: PUSH
83033: LD_INT 1
83035: NEG
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 2
83043: NEG
83044: PUSH
83045: LD_INT 2
83047: NEG
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83074: LD_ADDR_VAR 0 18
83078: PUSH
83079: LD_INT 0
83081: PUSH
83082: LD_INT 0
83084: PUSH
83085: EMPTY
83086: LIST
83087: LIST
83088: PUSH
83089: LD_INT 0
83091: PUSH
83092: LD_INT 1
83094: NEG
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 1
83102: PUSH
83103: LD_INT 0
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 1
83112: PUSH
83113: LD_INT 1
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: PUSH
83120: LD_INT 0
83122: PUSH
83123: LD_INT 1
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 1
83132: NEG
83133: PUSH
83134: LD_INT 0
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 1
83143: NEG
83144: PUSH
83145: LD_INT 1
83147: NEG
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: PUSH
83153: LD_INT 1
83155: NEG
83156: PUSH
83157: LD_INT 2
83159: NEG
83160: PUSH
83161: EMPTY
83162: LIST
83163: LIST
83164: PUSH
83165: LD_INT 0
83167: PUSH
83168: LD_INT 2
83170: NEG
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: LD_INT 1
83178: PUSH
83179: LD_INT 1
83181: NEG
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 2
83189: PUSH
83190: LD_INT 0
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 2
83199: PUSH
83200: LD_INT 1
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 2
83209: PUSH
83210: LD_INT 2
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 1
83219: PUSH
83220: LD_INT 2
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 0
83229: PUSH
83230: LD_INT 2
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 1
83239: NEG
83240: PUSH
83241: LD_INT 1
83243: PUSH
83244: EMPTY
83245: LIST
83246: LIST
83247: PUSH
83248: LD_INT 2
83250: NEG
83251: PUSH
83252: LD_INT 0
83254: PUSH
83255: EMPTY
83256: LIST
83257: LIST
83258: PUSH
83259: LD_INT 2
83261: NEG
83262: PUSH
83263: LD_INT 1
83265: NEG
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PUSH
83271: LD_INT 2
83273: NEG
83274: PUSH
83275: LD_INT 2
83277: NEG
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83304: LD_ADDR_VAR 0 19
83308: PUSH
83309: LD_INT 0
83311: PUSH
83312: LD_INT 0
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 0
83321: PUSH
83322: LD_INT 1
83324: NEG
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: PUSH
83330: LD_INT 1
83332: PUSH
83333: LD_INT 0
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 1
83342: PUSH
83343: LD_INT 1
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: PUSH
83350: LD_INT 0
83352: PUSH
83353: LD_INT 1
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 1
83362: NEG
83363: PUSH
83364: LD_INT 0
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 1
83373: NEG
83374: PUSH
83375: LD_INT 1
83377: NEG
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 1
83385: NEG
83386: PUSH
83387: LD_INT 2
83389: NEG
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 0
83397: PUSH
83398: LD_INT 2
83400: NEG
83401: PUSH
83402: EMPTY
83403: LIST
83404: LIST
83405: PUSH
83406: LD_INT 1
83408: PUSH
83409: LD_INT 1
83411: NEG
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: PUSH
83417: LD_INT 2
83419: PUSH
83420: LD_INT 0
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 2
83429: PUSH
83430: LD_INT 1
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: PUSH
83437: LD_INT 2
83439: PUSH
83440: LD_INT 2
83442: PUSH
83443: EMPTY
83444: LIST
83445: LIST
83446: PUSH
83447: LD_INT 1
83449: PUSH
83450: LD_INT 2
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PUSH
83457: LD_INT 0
83459: PUSH
83460: LD_INT 2
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 1
83469: NEG
83470: PUSH
83471: LD_INT 1
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: LD_INT 2
83480: NEG
83481: PUSH
83482: LD_INT 0
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 2
83491: NEG
83492: PUSH
83493: LD_INT 1
83495: NEG
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 2
83503: NEG
83504: PUSH
83505: LD_INT 2
83507: NEG
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: LIST
83517: LIST
83518: LIST
83519: LIST
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83534: LD_ADDR_VAR 0 20
83538: PUSH
83539: LD_INT 0
83541: PUSH
83542: LD_INT 0
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 0
83551: PUSH
83552: LD_INT 1
83554: NEG
83555: PUSH
83556: EMPTY
83557: LIST
83558: LIST
83559: PUSH
83560: LD_INT 1
83562: PUSH
83563: LD_INT 0
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 1
83572: PUSH
83573: LD_INT 1
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 0
83582: PUSH
83583: LD_INT 1
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 1
83592: NEG
83593: PUSH
83594: LD_INT 0
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 1
83603: NEG
83604: PUSH
83605: LD_INT 1
83607: NEG
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 1
83615: NEG
83616: PUSH
83617: LD_INT 2
83619: NEG
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: PUSH
83625: LD_INT 0
83627: PUSH
83628: LD_INT 2
83630: NEG
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 1
83638: PUSH
83639: LD_INT 1
83641: NEG
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PUSH
83647: LD_INT 2
83649: PUSH
83650: LD_INT 0
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 2
83659: PUSH
83660: LD_INT 1
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: PUSH
83667: LD_INT 2
83669: PUSH
83670: LD_INT 2
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 1
83679: PUSH
83680: LD_INT 2
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 0
83689: PUSH
83690: LD_INT 2
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 1
83699: NEG
83700: PUSH
83701: LD_INT 1
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 2
83710: NEG
83711: PUSH
83712: LD_INT 0
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 2
83721: NEG
83722: PUSH
83723: LD_INT 1
83725: NEG
83726: PUSH
83727: EMPTY
83728: LIST
83729: LIST
83730: PUSH
83731: LD_INT 2
83733: NEG
83734: PUSH
83735: LD_INT 2
83737: NEG
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83764: LD_ADDR_VAR 0 21
83768: PUSH
83769: LD_INT 0
83771: PUSH
83772: LD_INT 0
83774: PUSH
83775: EMPTY
83776: LIST
83777: LIST
83778: PUSH
83779: LD_INT 0
83781: PUSH
83782: LD_INT 1
83784: NEG
83785: PUSH
83786: EMPTY
83787: LIST
83788: LIST
83789: PUSH
83790: LD_INT 1
83792: PUSH
83793: LD_INT 0
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: LD_INT 1
83802: PUSH
83803: LD_INT 1
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 0
83812: PUSH
83813: LD_INT 1
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: PUSH
83820: LD_INT 1
83822: NEG
83823: PUSH
83824: LD_INT 0
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: PUSH
83831: LD_INT 1
83833: NEG
83834: PUSH
83835: LD_INT 1
83837: NEG
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 1
83845: NEG
83846: PUSH
83847: LD_INT 2
83849: NEG
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 0
83857: PUSH
83858: LD_INT 2
83860: NEG
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 1
83868: PUSH
83869: LD_INT 1
83871: NEG
83872: PUSH
83873: EMPTY
83874: LIST
83875: LIST
83876: PUSH
83877: LD_INT 2
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: PUSH
83887: LD_INT 2
83889: PUSH
83890: LD_INT 1
83892: PUSH
83893: EMPTY
83894: LIST
83895: LIST
83896: PUSH
83897: LD_INT 2
83899: PUSH
83900: LD_INT 2
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: PUSH
83907: LD_INT 1
83909: PUSH
83910: LD_INT 2
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: PUSH
83917: LD_INT 0
83919: PUSH
83920: LD_INT 2
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: PUSH
83927: LD_INT 1
83929: NEG
83930: PUSH
83931: LD_INT 1
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PUSH
83938: LD_INT 2
83940: NEG
83941: PUSH
83942: LD_INT 0
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: LD_INT 2
83951: NEG
83952: PUSH
83953: LD_INT 1
83955: NEG
83956: PUSH
83957: EMPTY
83958: LIST
83959: LIST
83960: PUSH
83961: LD_INT 2
83963: NEG
83964: PUSH
83965: LD_INT 2
83967: NEG
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: EMPTY
83974: LIST
83975: LIST
83976: LIST
83977: LIST
83978: LIST
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83994: LD_ADDR_VAR 0 22
83998: PUSH
83999: LD_INT 0
84001: PUSH
84002: LD_INT 0
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 0
84011: PUSH
84012: LD_INT 1
84014: NEG
84015: PUSH
84016: EMPTY
84017: LIST
84018: LIST
84019: PUSH
84020: LD_INT 1
84022: PUSH
84023: LD_INT 0
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: PUSH
84030: LD_INT 1
84032: PUSH
84033: LD_INT 1
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 0
84042: PUSH
84043: LD_INT 1
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: PUSH
84050: LD_INT 1
84052: NEG
84053: PUSH
84054: LD_INT 0
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: PUSH
84061: LD_INT 1
84063: NEG
84064: PUSH
84065: LD_INT 1
84067: NEG
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: PUSH
84073: LD_INT 1
84075: NEG
84076: PUSH
84077: LD_INT 2
84079: NEG
84080: PUSH
84081: EMPTY
84082: LIST
84083: LIST
84084: PUSH
84085: LD_INT 0
84087: PUSH
84088: LD_INT 2
84090: NEG
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 1
84098: PUSH
84099: LD_INT 1
84101: NEG
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 2
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 2
84119: PUSH
84120: LD_INT 1
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 2
84129: PUSH
84130: LD_INT 2
84132: PUSH
84133: EMPTY
84134: LIST
84135: LIST
84136: PUSH
84137: LD_INT 1
84139: PUSH
84140: LD_INT 2
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: PUSH
84147: LD_INT 0
84149: PUSH
84150: LD_INT 2
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 1
84159: NEG
84160: PUSH
84161: LD_INT 1
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: PUSH
84168: LD_INT 2
84170: NEG
84171: PUSH
84172: LD_INT 0
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 2
84181: NEG
84182: PUSH
84183: LD_INT 1
84185: NEG
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 2
84193: NEG
84194: PUSH
84195: LD_INT 2
84197: NEG
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PUSH
84203: EMPTY
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84224: LD_ADDR_VAR 0 23
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: LD_INT 0
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 0
84241: PUSH
84242: LD_INT 1
84244: NEG
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: LD_INT 0
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 1
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 0
84272: PUSH
84273: LD_INT 1
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: PUSH
84280: LD_INT 1
84282: NEG
84283: PUSH
84284: LD_INT 0
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 1
84293: NEG
84294: PUSH
84295: LD_INT 1
84297: NEG
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 1
84305: NEG
84306: PUSH
84307: LD_INT 2
84309: NEG
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 0
84317: PUSH
84318: LD_INT 2
84320: NEG
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: LD_INT 1
84328: PUSH
84329: LD_INT 1
84331: NEG
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 2
84339: PUSH
84340: LD_INT 0
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 2
84349: PUSH
84350: LD_INT 1
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: LD_INT 2
84359: PUSH
84360: LD_INT 2
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PUSH
84367: LD_INT 1
84369: PUSH
84370: LD_INT 2
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: PUSH
84377: LD_INT 0
84379: PUSH
84380: LD_INT 2
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 1
84389: NEG
84390: PUSH
84391: LD_INT 1
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_INT 2
84400: NEG
84401: PUSH
84402: LD_INT 0
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 2
84411: NEG
84412: PUSH
84413: LD_INT 1
84415: NEG
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: PUSH
84421: LD_INT 2
84423: NEG
84424: PUSH
84425: LD_INT 2
84427: NEG
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: PUSH
84433: LD_INT 2
84435: NEG
84436: PUSH
84437: LD_INT 3
84439: NEG
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 1
84447: NEG
84448: PUSH
84449: LD_INT 3
84451: NEG
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 1
84459: PUSH
84460: LD_INT 2
84462: NEG
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 2
84470: PUSH
84471: LD_INT 1
84473: NEG
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
84504: LD_ADDR_VAR 0 24
84508: PUSH
84509: LD_INT 0
84511: PUSH
84512: LD_INT 0
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: PUSH
84519: LD_INT 0
84521: PUSH
84522: LD_INT 1
84524: NEG
84525: PUSH
84526: EMPTY
84527: LIST
84528: LIST
84529: PUSH
84530: LD_INT 1
84532: PUSH
84533: LD_INT 0
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 1
84542: PUSH
84543: LD_INT 1
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 0
84552: PUSH
84553: LD_INT 1
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: PUSH
84560: LD_INT 1
84562: NEG
84563: PUSH
84564: LD_INT 0
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 1
84573: NEG
84574: PUSH
84575: LD_INT 1
84577: NEG
84578: PUSH
84579: EMPTY
84580: LIST
84581: LIST
84582: PUSH
84583: LD_INT 1
84585: NEG
84586: PUSH
84587: LD_INT 2
84589: NEG
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 0
84597: PUSH
84598: LD_INT 2
84600: NEG
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 1
84608: PUSH
84609: LD_INT 1
84611: NEG
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 2
84619: PUSH
84620: LD_INT 0
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: LD_INT 2
84629: PUSH
84630: LD_INT 1
84632: PUSH
84633: EMPTY
84634: LIST
84635: LIST
84636: PUSH
84637: LD_INT 2
84639: PUSH
84640: LD_INT 2
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 1
84649: PUSH
84650: LD_INT 2
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 0
84659: PUSH
84660: LD_INT 2
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: PUSH
84667: LD_INT 1
84669: NEG
84670: PUSH
84671: LD_INT 1
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: PUSH
84678: LD_INT 2
84680: NEG
84681: PUSH
84682: LD_INT 0
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 2
84691: NEG
84692: PUSH
84693: LD_INT 1
84695: NEG
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 2
84703: NEG
84704: PUSH
84705: LD_INT 2
84707: NEG
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: PUSH
84713: LD_INT 1
84715: PUSH
84716: LD_INT 2
84718: NEG
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: PUSH
84724: LD_INT 2
84726: PUSH
84727: LD_INT 1
84729: NEG
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: PUSH
84735: LD_INT 3
84737: PUSH
84738: LD_INT 1
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PUSH
84745: LD_INT 3
84747: PUSH
84748: LD_INT 2
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: EMPTY
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
84780: LD_ADDR_VAR 0 25
84784: PUSH
84785: LD_INT 0
84787: PUSH
84788: LD_INT 0
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PUSH
84795: LD_INT 0
84797: PUSH
84798: LD_INT 1
84800: NEG
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 1
84808: PUSH
84809: LD_INT 0
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: LD_INT 1
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 0
84828: PUSH
84829: LD_INT 1
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 1
84838: NEG
84839: PUSH
84840: LD_INT 0
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: PUSH
84847: LD_INT 1
84849: NEG
84850: PUSH
84851: LD_INT 1
84853: NEG
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PUSH
84859: LD_INT 1
84861: NEG
84862: PUSH
84863: LD_INT 2
84865: NEG
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: PUSH
84871: LD_INT 0
84873: PUSH
84874: LD_INT 2
84876: NEG
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PUSH
84882: LD_INT 1
84884: PUSH
84885: LD_INT 1
84887: NEG
84888: PUSH
84889: EMPTY
84890: LIST
84891: LIST
84892: PUSH
84893: LD_INT 2
84895: PUSH
84896: LD_INT 0
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: PUSH
84903: LD_INT 2
84905: PUSH
84906: LD_INT 1
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: PUSH
84913: LD_INT 2
84915: PUSH
84916: LD_INT 2
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: PUSH
84923: LD_INT 1
84925: PUSH
84926: LD_INT 2
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: PUSH
84933: LD_INT 0
84935: PUSH
84936: LD_INT 2
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: PUSH
84943: LD_INT 1
84945: NEG
84946: PUSH
84947: LD_INT 1
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 2
84956: NEG
84957: PUSH
84958: LD_INT 0
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 2
84967: NEG
84968: PUSH
84969: LD_INT 1
84971: NEG
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 2
84979: NEG
84980: PUSH
84981: LD_INT 2
84983: NEG
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: PUSH
84989: LD_INT 3
84991: PUSH
84992: LD_INT 1
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 3
85001: PUSH
85002: LD_INT 2
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 2
85011: PUSH
85012: LD_INT 3
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 1
85021: PUSH
85022: LD_INT 3
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85054: LD_ADDR_VAR 0 26
85058: PUSH
85059: LD_INT 0
85061: PUSH
85062: LD_INT 0
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 0
85071: PUSH
85072: LD_INT 1
85074: NEG
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 1
85082: PUSH
85083: LD_INT 0
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: LD_INT 1
85092: PUSH
85093: LD_INT 1
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 0
85102: PUSH
85103: LD_INT 1
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: PUSH
85110: LD_INT 1
85112: NEG
85113: PUSH
85114: LD_INT 0
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: PUSH
85121: LD_INT 1
85123: NEG
85124: PUSH
85125: LD_INT 1
85127: NEG
85128: PUSH
85129: EMPTY
85130: LIST
85131: LIST
85132: PUSH
85133: LD_INT 1
85135: NEG
85136: PUSH
85137: LD_INT 2
85139: NEG
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 0
85147: PUSH
85148: LD_INT 2
85150: NEG
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 1
85158: PUSH
85159: LD_INT 1
85161: NEG
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 2
85169: PUSH
85170: LD_INT 0
85172: PUSH
85173: EMPTY
85174: LIST
85175: LIST
85176: PUSH
85177: LD_INT 2
85179: PUSH
85180: LD_INT 1
85182: PUSH
85183: EMPTY
85184: LIST
85185: LIST
85186: PUSH
85187: LD_INT 2
85189: PUSH
85190: LD_INT 2
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PUSH
85197: LD_INT 1
85199: PUSH
85200: LD_INT 2
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: PUSH
85207: LD_INT 0
85209: PUSH
85210: LD_INT 2
85212: PUSH
85213: EMPTY
85214: LIST
85215: LIST
85216: PUSH
85217: LD_INT 1
85219: NEG
85220: PUSH
85221: LD_INT 1
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_INT 2
85230: NEG
85231: PUSH
85232: LD_INT 0
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 2
85241: NEG
85242: PUSH
85243: LD_INT 1
85245: NEG
85246: PUSH
85247: EMPTY
85248: LIST
85249: LIST
85250: PUSH
85251: LD_INT 2
85253: NEG
85254: PUSH
85255: LD_INT 2
85257: NEG
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 2
85265: PUSH
85266: LD_INT 3
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 1
85275: PUSH
85276: LD_INT 3
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: LD_INT 1
85285: NEG
85286: PUSH
85287: LD_INT 2
85289: PUSH
85290: EMPTY
85291: LIST
85292: LIST
85293: PUSH
85294: LD_INT 2
85296: NEG
85297: PUSH
85298: LD_INT 1
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85330: LD_ADDR_VAR 0 27
85334: PUSH
85335: LD_INT 0
85337: PUSH
85338: LD_INT 0
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: PUSH
85345: LD_INT 0
85347: PUSH
85348: LD_INT 1
85350: NEG
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: PUSH
85356: LD_INT 1
85358: PUSH
85359: LD_INT 0
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: LD_INT 1
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 0
85378: PUSH
85379: LD_INT 1
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 1
85388: NEG
85389: PUSH
85390: LD_INT 0
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: LD_INT 1
85399: NEG
85400: PUSH
85401: LD_INT 1
85403: NEG
85404: PUSH
85405: EMPTY
85406: LIST
85407: LIST
85408: PUSH
85409: LD_INT 1
85411: NEG
85412: PUSH
85413: LD_INT 2
85415: NEG
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PUSH
85421: LD_INT 0
85423: PUSH
85424: LD_INT 2
85426: NEG
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 1
85434: PUSH
85435: LD_INT 1
85437: NEG
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 2
85445: PUSH
85446: LD_INT 0
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 2
85455: PUSH
85456: LD_INT 1
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 2
85465: PUSH
85466: LD_INT 2
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 1
85475: PUSH
85476: LD_INT 2
85478: PUSH
85479: EMPTY
85480: LIST
85481: LIST
85482: PUSH
85483: LD_INT 0
85485: PUSH
85486: LD_INT 2
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 1
85495: NEG
85496: PUSH
85497: LD_INT 1
85499: PUSH
85500: EMPTY
85501: LIST
85502: LIST
85503: PUSH
85504: LD_INT 2
85506: NEG
85507: PUSH
85508: LD_INT 0
85510: PUSH
85511: EMPTY
85512: LIST
85513: LIST
85514: PUSH
85515: LD_INT 2
85517: NEG
85518: PUSH
85519: LD_INT 1
85521: NEG
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PUSH
85527: LD_INT 2
85529: NEG
85530: PUSH
85531: LD_INT 2
85533: NEG
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: PUSH
85539: LD_INT 1
85541: NEG
85542: PUSH
85543: LD_INT 2
85545: PUSH
85546: EMPTY
85547: LIST
85548: LIST
85549: PUSH
85550: LD_INT 2
85552: NEG
85553: PUSH
85554: LD_INT 1
85556: PUSH
85557: EMPTY
85558: LIST
85559: LIST
85560: PUSH
85561: LD_INT 3
85563: NEG
85564: PUSH
85565: LD_INT 1
85567: NEG
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: LD_INT 3
85575: NEG
85576: PUSH
85577: LD_INT 2
85579: NEG
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85610: LD_ADDR_VAR 0 28
85614: PUSH
85615: LD_INT 0
85617: PUSH
85618: LD_INT 0
85620: PUSH
85621: EMPTY
85622: LIST
85623: LIST
85624: PUSH
85625: LD_INT 0
85627: PUSH
85628: LD_INT 1
85630: NEG
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: PUSH
85636: LD_INT 1
85638: PUSH
85639: LD_INT 0
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 1
85648: PUSH
85649: LD_INT 1
85651: PUSH
85652: EMPTY
85653: LIST
85654: LIST
85655: PUSH
85656: LD_INT 0
85658: PUSH
85659: LD_INT 1
85661: PUSH
85662: EMPTY
85663: LIST
85664: LIST
85665: PUSH
85666: LD_INT 1
85668: NEG
85669: PUSH
85670: LD_INT 0
85672: PUSH
85673: EMPTY
85674: LIST
85675: LIST
85676: PUSH
85677: LD_INT 1
85679: NEG
85680: PUSH
85681: LD_INT 1
85683: NEG
85684: PUSH
85685: EMPTY
85686: LIST
85687: LIST
85688: PUSH
85689: LD_INT 1
85691: NEG
85692: PUSH
85693: LD_INT 2
85695: NEG
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PUSH
85701: LD_INT 0
85703: PUSH
85704: LD_INT 2
85706: NEG
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 1
85714: PUSH
85715: LD_INT 1
85717: NEG
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: PUSH
85723: LD_INT 2
85725: PUSH
85726: LD_INT 0
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: LD_INT 2
85735: PUSH
85736: LD_INT 1
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: LD_INT 2
85745: PUSH
85746: LD_INT 2
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: LD_INT 1
85755: PUSH
85756: LD_INT 2
85758: PUSH
85759: EMPTY
85760: LIST
85761: LIST
85762: PUSH
85763: LD_INT 0
85765: PUSH
85766: LD_INT 2
85768: PUSH
85769: EMPTY
85770: LIST
85771: LIST
85772: PUSH
85773: LD_INT 1
85775: NEG
85776: PUSH
85777: LD_INT 1
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: PUSH
85784: LD_INT 2
85786: NEG
85787: PUSH
85788: LD_INT 0
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: PUSH
85795: LD_INT 2
85797: NEG
85798: PUSH
85799: LD_INT 1
85801: NEG
85802: PUSH
85803: EMPTY
85804: LIST
85805: LIST
85806: PUSH
85807: LD_INT 2
85809: NEG
85810: PUSH
85811: LD_INT 2
85813: NEG
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: PUSH
85819: LD_INT 2
85821: NEG
85822: PUSH
85823: LD_INT 3
85825: NEG
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 1
85833: NEG
85834: PUSH
85835: LD_INT 3
85837: NEG
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: PUSH
85843: LD_INT 3
85845: NEG
85846: PUSH
85847: LD_INT 1
85849: NEG
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: PUSH
85855: LD_INT 3
85857: NEG
85858: PUSH
85859: LD_INT 2
85861: NEG
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85892: LD_ADDR_VAR 0 29
85896: PUSH
85897: LD_INT 0
85899: PUSH
85900: LD_INT 0
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 0
85909: PUSH
85910: LD_INT 1
85912: NEG
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 1
85920: PUSH
85921: LD_INT 0
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 1
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: LD_INT 0
85940: PUSH
85941: LD_INT 1
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: LD_INT 1
85950: NEG
85951: PUSH
85952: LD_INT 0
85954: PUSH
85955: EMPTY
85956: LIST
85957: LIST
85958: PUSH
85959: LD_INT 1
85961: NEG
85962: PUSH
85963: LD_INT 1
85965: NEG
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 1
85973: NEG
85974: PUSH
85975: LD_INT 2
85977: NEG
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: PUSH
85983: LD_INT 0
85985: PUSH
85986: LD_INT 2
85988: NEG
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 1
85996: PUSH
85997: LD_INT 1
85999: NEG
86000: PUSH
86001: EMPTY
86002: LIST
86003: LIST
86004: PUSH
86005: LD_INT 2
86007: PUSH
86008: LD_INT 0
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 2
86017: PUSH
86018: LD_INT 1
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 1
86027: PUSH
86028: LD_INT 2
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: LD_INT 0
86037: PUSH
86038: LD_INT 2
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: LD_INT 1
86047: NEG
86048: PUSH
86049: LD_INT 1
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 2
86058: NEG
86059: PUSH
86060: LD_INT 1
86062: NEG
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 2
86070: NEG
86071: PUSH
86072: LD_INT 2
86074: NEG
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PUSH
86080: LD_INT 2
86082: NEG
86083: PUSH
86084: LD_INT 3
86086: NEG
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 2
86094: PUSH
86095: LD_INT 1
86097: NEG
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 3
86105: PUSH
86106: LD_INT 1
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: PUSH
86116: LD_INT 3
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 1
86125: NEG
86126: PUSH
86127: LD_INT 2
86129: PUSH
86130: EMPTY
86131: LIST
86132: LIST
86133: PUSH
86134: LD_INT 3
86136: NEG
86137: PUSH
86138: LD_INT 2
86140: NEG
86141: PUSH
86142: EMPTY
86143: LIST
86144: LIST
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86171: LD_ADDR_VAR 0 30
86175: PUSH
86176: LD_INT 0
86178: PUSH
86179: LD_INT 0
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 0
86188: PUSH
86189: LD_INT 1
86191: NEG
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 1
86199: PUSH
86200: LD_INT 0
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: LD_INT 1
86209: PUSH
86210: LD_INT 1
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 0
86219: PUSH
86220: LD_INT 1
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: PUSH
86227: LD_INT 1
86229: NEG
86230: PUSH
86231: LD_INT 0
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: PUSH
86238: LD_INT 1
86240: NEG
86241: PUSH
86242: LD_INT 1
86244: NEG
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 1
86252: NEG
86253: PUSH
86254: LD_INT 2
86256: NEG
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: PUSH
86262: LD_INT 0
86264: PUSH
86265: LD_INT 2
86267: NEG
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 1
86275: PUSH
86276: LD_INT 1
86278: NEG
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: PUSH
86284: LD_INT 2
86286: PUSH
86287: LD_INT 0
86289: PUSH
86290: EMPTY
86291: LIST
86292: LIST
86293: PUSH
86294: LD_INT 2
86296: PUSH
86297: LD_INT 1
86299: PUSH
86300: EMPTY
86301: LIST
86302: LIST
86303: PUSH
86304: LD_INT 2
86306: PUSH
86307: LD_INT 2
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: PUSH
86314: LD_INT 1
86316: PUSH
86317: LD_INT 2
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 1
86326: NEG
86327: PUSH
86328: LD_INT 1
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: LD_INT 2
86337: NEG
86338: PUSH
86339: LD_INT 0
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: PUSH
86346: LD_INT 2
86348: NEG
86349: PUSH
86350: LD_INT 1
86352: NEG
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 1
86360: NEG
86361: PUSH
86362: LD_INT 3
86364: NEG
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 1
86372: PUSH
86373: LD_INT 2
86375: NEG
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: PUSH
86381: LD_INT 3
86383: PUSH
86384: LD_INT 2
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 2
86393: PUSH
86394: LD_INT 3
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: LD_INT 2
86403: NEG
86404: PUSH
86405: LD_INT 1
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: PUSH
86412: LD_INT 3
86414: NEG
86415: PUSH
86416: LD_INT 1
86418: NEG
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86449: LD_ADDR_VAR 0 31
86453: PUSH
86454: LD_INT 0
86456: PUSH
86457: LD_INT 0
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 0
86466: PUSH
86467: LD_INT 1
86469: NEG
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: LD_INT 1
86477: PUSH
86478: LD_INT 0
86480: PUSH
86481: EMPTY
86482: LIST
86483: LIST
86484: PUSH
86485: LD_INT 1
86487: PUSH
86488: LD_INT 1
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: PUSH
86495: LD_INT 0
86497: PUSH
86498: LD_INT 1
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: PUSH
86505: LD_INT 1
86507: NEG
86508: PUSH
86509: LD_INT 0
86511: PUSH
86512: EMPTY
86513: LIST
86514: LIST
86515: PUSH
86516: LD_INT 1
86518: NEG
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 1
86530: NEG
86531: PUSH
86532: LD_INT 2
86534: NEG
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 1
86542: PUSH
86543: LD_INT 1
86545: NEG
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: PUSH
86551: LD_INT 2
86553: PUSH
86554: LD_INT 0
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 2
86563: PUSH
86564: LD_INT 1
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 2
86573: PUSH
86574: LD_INT 2
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 1
86583: PUSH
86584: LD_INT 2
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: LD_INT 0
86593: PUSH
86594: LD_INT 2
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: PUSH
86601: LD_INT 1
86603: NEG
86604: PUSH
86605: LD_INT 1
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: LD_INT 2
86614: NEG
86615: PUSH
86616: LD_INT 1
86618: NEG
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 2
86626: NEG
86627: PUSH
86628: LD_INT 2
86630: NEG
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 2
86638: NEG
86639: PUSH
86640: LD_INT 3
86642: NEG
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: PUSH
86648: LD_INT 2
86650: PUSH
86651: LD_INT 1
86653: NEG
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 3
86661: PUSH
86662: LD_INT 1
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: PUSH
86669: LD_INT 1
86671: PUSH
86672: LD_INT 3
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: PUSH
86679: LD_INT 1
86681: NEG
86682: PUSH
86683: LD_INT 2
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 3
86692: NEG
86693: PUSH
86694: LD_INT 2
86696: NEG
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: EMPTY
86703: LIST
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86727: LD_ADDR_VAR 0 32
86731: PUSH
86732: LD_INT 0
86734: PUSH
86735: LD_INT 0
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: PUSH
86742: LD_INT 0
86744: PUSH
86745: LD_INT 1
86747: NEG
86748: PUSH
86749: EMPTY
86750: LIST
86751: LIST
86752: PUSH
86753: LD_INT 1
86755: PUSH
86756: LD_INT 0
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 1
86765: PUSH
86766: LD_INT 1
86768: PUSH
86769: EMPTY
86770: LIST
86771: LIST
86772: PUSH
86773: LD_INT 0
86775: PUSH
86776: LD_INT 1
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PUSH
86783: LD_INT 1
86785: NEG
86786: PUSH
86787: LD_INT 0
86789: PUSH
86790: EMPTY
86791: LIST
86792: LIST
86793: PUSH
86794: LD_INT 1
86796: NEG
86797: PUSH
86798: LD_INT 1
86800: NEG
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PUSH
86806: LD_INT 1
86808: NEG
86809: PUSH
86810: LD_INT 2
86812: NEG
86813: PUSH
86814: EMPTY
86815: LIST
86816: LIST
86817: PUSH
86818: LD_INT 0
86820: PUSH
86821: LD_INT 2
86823: NEG
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: PUSH
86829: LD_INT 1
86831: PUSH
86832: LD_INT 1
86834: NEG
86835: PUSH
86836: EMPTY
86837: LIST
86838: LIST
86839: PUSH
86840: LD_INT 2
86842: PUSH
86843: LD_INT 1
86845: PUSH
86846: EMPTY
86847: LIST
86848: LIST
86849: PUSH
86850: LD_INT 2
86852: PUSH
86853: LD_INT 2
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: PUSH
86860: LD_INT 1
86862: PUSH
86863: LD_INT 2
86865: PUSH
86866: EMPTY
86867: LIST
86868: LIST
86869: PUSH
86870: LD_INT 0
86872: PUSH
86873: LD_INT 2
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: PUSH
86880: LD_INT 1
86882: NEG
86883: PUSH
86884: LD_INT 1
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 2
86893: NEG
86894: PUSH
86895: LD_INT 0
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 2
86904: NEG
86905: PUSH
86906: LD_INT 1
86908: NEG
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 1
86916: NEG
86917: PUSH
86918: LD_INT 3
86920: NEG
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 1
86928: PUSH
86929: LD_INT 2
86931: NEG
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: PUSH
86937: LD_INT 3
86939: PUSH
86940: LD_INT 2
86942: PUSH
86943: EMPTY
86944: LIST
86945: LIST
86946: PUSH
86947: LD_INT 2
86949: PUSH
86950: LD_INT 3
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 2
86959: NEG
86960: PUSH
86961: LD_INT 1
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 3
86970: NEG
86971: PUSH
86972: LD_INT 1
86974: NEG
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87005: LD_ADDR_VAR 0 33
87009: PUSH
87010: LD_INT 0
87012: PUSH
87013: LD_INT 0
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: PUSH
87020: LD_INT 0
87022: PUSH
87023: LD_INT 1
87025: NEG
87026: PUSH
87027: EMPTY
87028: LIST
87029: LIST
87030: PUSH
87031: LD_INT 1
87033: PUSH
87034: LD_INT 0
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: PUSH
87041: LD_INT 1
87043: PUSH
87044: LD_INT 1
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: LD_INT 0
87053: PUSH
87054: LD_INT 1
87056: PUSH
87057: EMPTY
87058: LIST
87059: LIST
87060: PUSH
87061: LD_INT 1
87063: NEG
87064: PUSH
87065: LD_INT 0
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: PUSH
87072: LD_INT 1
87074: NEG
87075: PUSH
87076: LD_INT 1
87078: NEG
87079: PUSH
87080: EMPTY
87081: LIST
87082: LIST
87083: PUSH
87084: LD_INT 1
87086: NEG
87087: PUSH
87088: LD_INT 2
87090: NEG
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 1
87098: PUSH
87099: LD_INT 1
87101: NEG
87102: PUSH
87103: EMPTY
87104: LIST
87105: LIST
87106: PUSH
87107: LD_INT 2
87109: PUSH
87110: LD_INT 0
87112: PUSH
87113: EMPTY
87114: LIST
87115: LIST
87116: PUSH
87117: LD_INT 2
87119: PUSH
87120: LD_INT 1
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: PUSH
87127: LD_INT 1
87129: PUSH
87130: LD_INT 2
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: PUSH
87137: LD_INT 0
87139: PUSH
87140: LD_INT 2
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 1
87149: NEG
87150: PUSH
87151: LD_INT 1
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 2
87160: NEG
87161: PUSH
87162: LD_INT 0
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: LD_INT 2
87171: NEG
87172: PUSH
87173: LD_INT 1
87175: NEG
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 2
87183: NEG
87184: PUSH
87185: LD_INT 2
87187: NEG
87188: PUSH
87189: EMPTY
87190: LIST
87191: LIST
87192: PUSH
87193: LD_INT 2
87195: NEG
87196: PUSH
87197: LD_INT 3
87199: NEG
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 2
87207: PUSH
87208: LD_INT 1
87210: NEG
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: PUSH
87216: LD_INT 3
87218: PUSH
87219: LD_INT 1
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PUSH
87226: LD_INT 1
87228: PUSH
87229: LD_INT 3
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: PUSH
87236: LD_INT 1
87238: NEG
87239: PUSH
87240: LD_INT 2
87242: PUSH
87243: EMPTY
87244: LIST
87245: LIST
87246: PUSH
87247: LD_INT 3
87249: NEG
87250: PUSH
87251: LD_INT 2
87253: NEG
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: PUSH
87259: EMPTY
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87284: LD_ADDR_VAR 0 34
87288: PUSH
87289: LD_INT 0
87291: PUSH
87292: LD_INT 0
87294: PUSH
87295: EMPTY
87296: LIST
87297: LIST
87298: PUSH
87299: LD_INT 0
87301: PUSH
87302: LD_INT 1
87304: NEG
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PUSH
87310: LD_INT 1
87312: PUSH
87313: LD_INT 0
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 1
87322: PUSH
87323: LD_INT 1
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: PUSH
87330: LD_INT 0
87332: PUSH
87333: LD_INT 1
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: LD_INT 1
87342: NEG
87343: PUSH
87344: LD_INT 0
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: PUSH
87351: LD_INT 1
87353: NEG
87354: PUSH
87355: LD_INT 1
87357: NEG
87358: PUSH
87359: EMPTY
87360: LIST
87361: LIST
87362: PUSH
87363: LD_INT 1
87365: NEG
87366: PUSH
87367: LD_INT 2
87369: NEG
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: PUSH
87375: LD_INT 0
87377: PUSH
87378: LD_INT 2
87380: NEG
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 1
87388: PUSH
87389: LD_INT 1
87391: NEG
87392: PUSH
87393: EMPTY
87394: LIST
87395: LIST
87396: PUSH
87397: LD_INT 2
87399: PUSH
87400: LD_INT 1
87402: PUSH
87403: EMPTY
87404: LIST
87405: LIST
87406: PUSH
87407: LD_INT 2
87409: PUSH
87410: LD_INT 2
87412: PUSH
87413: EMPTY
87414: LIST
87415: LIST
87416: PUSH
87417: LD_INT 1
87419: PUSH
87420: LD_INT 2
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 1
87429: NEG
87430: PUSH
87431: LD_INT 1
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 2
87440: NEG
87441: PUSH
87442: LD_INT 0
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 2
87451: NEG
87452: PUSH
87453: LD_INT 1
87455: NEG
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 2
87463: NEG
87464: PUSH
87465: LD_INT 2
87467: NEG
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PUSH
87473: LD_INT 1
87475: NEG
87476: PUSH
87477: LD_INT 3
87479: NEG
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 1
87487: PUSH
87488: LD_INT 2
87490: NEG
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 3
87498: PUSH
87499: LD_INT 2
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 2
87508: PUSH
87509: LD_INT 3
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 2
87518: NEG
87519: PUSH
87520: LD_INT 1
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: PUSH
87527: LD_INT 3
87529: NEG
87530: PUSH
87531: LD_INT 1
87533: NEG
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87564: LD_ADDR_VAR 0 35
87568: PUSH
87569: LD_INT 0
87571: PUSH
87572: LD_INT 0
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 0
87581: PUSH
87582: LD_INT 1
87584: NEG
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 1
87592: PUSH
87593: LD_INT 0
87595: PUSH
87596: EMPTY
87597: LIST
87598: LIST
87599: PUSH
87600: LD_INT 1
87602: PUSH
87603: LD_INT 1
87605: PUSH
87606: EMPTY
87607: LIST
87608: LIST
87609: PUSH
87610: LD_INT 0
87612: PUSH
87613: LD_INT 1
87615: PUSH
87616: EMPTY
87617: LIST
87618: LIST
87619: PUSH
87620: LD_INT 1
87622: NEG
87623: PUSH
87624: LD_INT 0
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 1
87633: NEG
87634: PUSH
87635: LD_INT 1
87637: NEG
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 2
87645: PUSH
87646: LD_INT 1
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: LD_INT 2
87655: NEG
87656: PUSH
87657: LD_INT 1
87659: NEG
87660: PUSH
87661: EMPTY
87662: LIST
87663: LIST
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87676: LD_ADDR_VAR 0 36
87680: PUSH
87681: LD_INT 0
87683: PUSH
87684: LD_INT 0
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 0
87693: PUSH
87694: LD_INT 1
87696: NEG
87697: PUSH
87698: EMPTY
87699: LIST
87700: LIST
87701: PUSH
87702: LD_INT 1
87704: PUSH
87705: LD_INT 0
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: LD_INT 1
87714: PUSH
87715: LD_INT 1
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 0
87724: PUSH
87725: LD_INT 1
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: PUSH
87732: LD_INT 1
87734: NEG
87735: PUSH
87736: LD_INT 0
87738: PUSH
87739: EMPTY
87740: LIST
87741: LIST
87742: PUSH
87743: LD_INT 1
87745: NEG
87746: PUSH
87747: LD_INT 1
87749: NEG
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: PUSH
87755: LD_INT 1
87757: NEG
87758: PUSH
87759: LD_INT 2
87761: NEG
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 1
87769: PUSH
87770: LD_INT 2
87772: PUSH
87773: EMPTY
87774: LIST
87775: LIST
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87788: LD_ADDR_VAR 0 37
87792: PUSH
87793: LD_INT 0
87795: PUSH
87796: LD_INT 0
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: PUSH
87803: LD_INT 0
87805: PUSH
87806: LD_INT 1
87808: NEG
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 1
87816: PUSH
87817: LD_INT 0
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: LD_INT 1
87826: PUSH
87827: LD_INT 1
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 0
87836: PUSH
87837: LD_INT 1
87839: PUSH
87840: EMPTY
87841: LIST
87842: LIST
87843: PUSH
87844: LD_INT 1
87846: NEG
87847: PUSH
87848: LD_INT 0
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 1
87857: NEG
87858: PUSH
87859: LD_INT 1
87861: NEG
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 1
87869: PUSH
87870: LD_INT 1
87872: NEG
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: LD_INT 1
87880: NEG
87881: PUSH
87882: LD_INT 1
87884: PUSH
87885: EMPTY
87886: LIST
87887: LIST
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87900: LD_ADDR_VAR 0 38
87904: PUSH
87905: LD_INT 0
87907: PUSH
87908: LD_INT 0
87910: PUSH
87911: EMPTY
87912: LIST
87913: LIST
87914: PUSH
87915: LD_INT 0
87917: PUSH
87918: LD_INT 1
87920: NEG
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 1
87928: PUSH
87929: LD_INT 0
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 1
87938: PUSH
87939: LD_INT 1
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 0
87948: PUSH
87949: LD_INT 1
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 1
87958: NEG
87959: PUSH
87960: LD_INT 0
87962: PUSH
87963: EMPTY
87964: LIST
87965: LIST
87966: PUSH
87967: LD_INT 1
87969: NEG
87970: PUSH
87971: LD_INT 1
87973: NEG
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_INT 2
87981: PUSH
87982: LD_INT 1
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 2
87991: NEG
87992: PUSH
87993: LD_INT 1
87995: NEG
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88012: LD_ADDR_VAR 0 39
88016: PUSH
88017: LD_INT 0
88019: PUSH
88020: LD_INT 0
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 0
88029: PUSH
88030: LD_INT 1
88032: NEG
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: PUSH
88038: LD_INT 1
88040: PUSH
88041: LD_INT 0
88043: PUSH
88044: EMPTY
88045: LIST
88046: LIST
88047: PUSH
88048: LD_INT 1
88050: PUSH
88051: LD_INT 1
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: PUSH
88058: LD_INT 0
88060: PUSH
88061: LD_INT 1
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: PUSH
88068: LD_INT 1
88070: NEG
88071: PUSH
88072: LD_INT 0
88074: PUSH
88075: EMPTY
88076: LIST
88077: LIST
88078: PUSH
88079: LD_INT 1
88081: NEG
88082: PUSH
88083: LD_INT 1
88085: NEG
88086: PUSH
88087: EMPTY
88088: LIST
88089: LIST
88090: PUSH
88091: LD_INT 1
88093: NEG
88094: PUSH
88095: LD_INT 2
88097: NEG
88098: PUSH
88099: EMPTY
88100: LIST
88101: LIST
88102: PUSH
88103: LD_INT 1
88105: PUSH
88106: LD_INT 2
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88124: LD_ADDR_VAR 0 40
88128: PUSH
88129: LD_INT 0
88131: PUSH
88132: LD_INT 0
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 0
88141: PUSH
88142: LD_INT 1
88144: NEG
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 1
88152: PUSH
88153: LD_INT 0
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 1
88162: PUSH
88163: LD_INT 1
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: PUSH
88170: LD_INT 0
88172: PUSH
88173: LD_INT 1
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: LD_INT 1
88182: NEG
88183: PUSH
88184: LD_INT 0
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 1
88193: NEG
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 1
88205: PUSH
88206: LD_INT 1
88208: NEG
88209: PUSH
88210: EMPTY
88211: LIST
88212: LIST
88213: PUSH
88214: LD_INT 1
88216: NEG
88217: PUSH
88218: LD_INT 1
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88236: LD_ADDR_VAR 0 41
88240: PUSH
88241: LD_INT 0
88243: PUSH
88244: LD_INT 0
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 0
88253: PUSH
88254: LD_INT 1
88256: NEG
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: PUSH
88262: LD_INT 1
88264: PUSH
88265: LD_INT 0
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 1
88274: PUSH
88275: LD_INT 1
88277: PUSH
88278: EMPTY
88279: LIST
88280: LIST
88281: PUSH
88282: LD_INT 0
88284: PUSH
88285: LD_INT 1
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 1
88294: NEG
88295: PUSH
88296: LD_INT 0
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 1
88305: NEG
88306: PUSH
88307: LD_INT 1
88309: NEG
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 1
88317: NEG
88318: PUSH
88319: LD_INT 2
88321: NEG
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: LD_INT 1
88329: PUSH
88330: LD_INT 1
88332: NEG
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: PUSH
88338: LD_INT 2
88340: PUSH
88341: LD_INT 0
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: PUSH
88348: LD_INT 2
88350: PUSH
88351: LD_INT 1
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: LD_INT 2
88360: PUSH
88361: LD_INT 2
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: PUSH
88368: LD_INT 1
88370: PUSH
88371: LD_INT 2
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: PUSH
88378: LD_INT 1
88380: NEG
88381: PUSH
88382: LD_INT 1
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PUSH
88389: LD_INT 2
88391: NEG
88392: PUSH
88393: LD_INT 0
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: PUSH
88400: LD_INT 2
88402: NEG
88403: PUSH
88404: LD_INT 1
88406: NEG
88407: PUSH
88408: EMPTY
88409: LIST
88410: LIST
88411: PUSH
88412: LD_INT 2
88414: NEG
88415: PUSH
88416: LD_INT 2
88418: NEG
88419: PUSH
88420: EMPTY
88421: LIST
88422: LIST
88423: PUSH
88424: LD_INT 2
88426: NEG
88427: PUSH
88428: LD_INT 3
88430: NEG
88431: PUSH
88432: EMPTY
88433: LIST
88434: LIST
88435: PUSH
88436: LD_INT 2
88438: PUSH
88439: LD_INT 1
88441: NEG
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: PUSH
88447: LD_INT 3
88449: PUSH
88450: LD_INT 0
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: LD_INT 3
88459: PUSH
88460: LD_INT 1
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: PUSH
88467: LD_INT 3
88469: PUSH
88470: LD_INT 2
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: PUSH
88477: LD_INT 3
88479: PUSH
88480: LD_INT 3
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: PUSH
88487: LD_INT 2
88489: PUSH
88490: LD_INT 3
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 2
88499: NEG
88500: PUSH
88501: LD_INT 1
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 3
88510: NEG
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: LD_INT 3
88521: NEG
88522: PUSH
88523: LD_INT 1
88525: NEG
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: PUSH
88531: LD_INT 3
88533: NEG
88534: PUSH
88535: LD_INT 2
88537: NEG
88538: PUSH
88539: EMPTY
88540: LIST
88541: LIST
88542: PUSH
88543: LD_INT 3
88545: NEG
88546: PUSH
88547: LD_INT 3
88549: NEG
88550: PUSH
88551: EMPTY
88552: LIST
88553: LIST
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88586: LD_ADDR_VAR 0 42
88590: PUSH
88591: LD_INT 0
88593: PUSH
88594: LD_INT 0
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PUSH
88601: LD_INT 0
88603: PUSH
88604: LD_INT 1
88606: NEG
88607: PUSH
88608: EMPTY
88609: LIST
88610: LIST
88611: PUSH
88612: LD_INT 1
88614: PUSH
88615: LD_INT 0
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: PUSH
88622: LD_INT 1
88624: PUSH
88625: LD_INT 1
88627: PUSH
88628: EMPTY
88629: LIST
88630: LIST
88631: PUSH
88632: LD_INT 0
88634: PUSH
88635: LD_INT 1
88637: PUSH
88638: EMPTY
88639: LIST
88640: LIST
88641: PUSH
88642: LD_INT 1
88644: NEG
88645: PUSH
88646: LD_INT 0
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: PUSH
88653: LD_INT 1
88655: NEG
88656: PUSH
88657: LD_INT 1
88659: NEG
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PUSH
88665: LD_INT 1
88667: NEG
88668: PUSH
88669: LD_INT 2
88671: NEG
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 0
88679: PUSH
88680: LD_INT 2
88682: NEG
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 1
88690: PUSH
88691: LD_INT 1
88693: NEG
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 2
88701: PUSH
88702: LD_INT 1
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: LD_INT 2
88711: PUSH
88712: LD_INT 2
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: PUSH
88719: LD_INT 1
88721: PUSH
88722: LD_INT 2
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 0
88731: PUSH
88732: LD_INT 2
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 1
88741: NEG
88742: PUSH
88743: LD_INT 1
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: LD_INT 2
88752: NEG
88753: PUSH
88754: LD_INT 1
88756: NEG
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 2
88764: NEG
88765: PUSH
88766: LD_INT 2
88768: NEG
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 2
88776: NEG
88777: PUSH
88778: LD_INT 3
88780: NEG
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 1
88788: NEG
88789: PUSH
88790: LD_INT 3
88792: NEG
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 0
88800: PUSH
88801: LD_INT 3
88803: NEG
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: PUSH
88809: LD_INT 1
88811: PUSH
88812: LD_INT 2
88814: NEG
88815: PUSH
88816: EMPTY
88817: LIST
88818: LIST
88819: PUSH
88820: LD_INT 3
88822: PUSH
88823: LD_INT 2
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: PUSH
88830: LD_INT 3
88832: PUSH
88833: LD_INT 3
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 2
88842: PUSH
88843: LD_INT 3
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: LD_INT 1
88852: PUSH
88853: LD_INT 3
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: LD_INT 3
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 1
88872: NEG
88873: PUSH
88874: LD_INT 2
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 3
88883: NEG
88884: PUSH
88885: LD_INT 2
88887: NEG
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 3
88895: NEG
88896: PUSH
88897: LD_INT 3
88899: NEG
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: LIST
88932: LIST
88933: LIST
88934: LIST
88935: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88936: LD_ADDR_VAR 0 43
88940: PUSH
88941: LD_INT 0
88943: PUSH
88944: LD_INT 0
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: PUSH
88951: LD_INT 0
88953: PUSH
88954: LD_INT 1
88956: NEG
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: PUSH
88962: LD_INT 1
88964: PUSH
88965: LD_INT 0
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: PUSH
88972: LD_INT 1
88974: PUSH
88975: LD_INT 1
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: PUSH
88982: LD_INT 0
88984: PUSH
88985: LD_INT 1
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: PUSH
88992: LD_INT 1
88994: NEG
88995: PUSH
88996: LD_INT 0
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: PUSH
89003: LD_INT 1
89005: NEG
89006: PUSH
89007: LD_INT 1
89009: NEG
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 1
89017: NEG
89018: PUSH
89019: LD_INT 2
89021: NEG
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 0
89029: PUSH
89030: LD_INT 2
89032: NEG
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 1
89040: PUSH
89041: LD_INT 1
89043: NEG
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 2
89051: PUSH
89052: LD_INT 0
89054: PUSH
89055: EMPTY
89056: LIST
89057: LIST
89058: PUSH
89059: LD_INT 2
89061: PUSH
89062: LD_INT 1
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: LD_INT 2
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: PUSH
89079: LD_INT 0
89081: PUSH
89082: LD_INT 2
89084: PUSH
89085: EMPTY
89086: LIST
89087: LIST
89088: PUSH
89089: LD_INT 1
89091: NEG
89092: PUSH
89093: LD_INT 1
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 2
89102: NEG
89103: PUSH
89104: LD_INT 0
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 2
89113: NEG
89114: PUSH
89115: LD_INT 1
89117: NEG
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 1
89125: NEG
89126: PUSH
89127: LD_INT 3
89129: NEG
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: PUSH
89135: LD_INT 0
89137: PUSH
89138: LD_INT 3
89140: NEG
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 1
89148: PUSH
89149: LD_INT 2
89151: NEG
89152: PUSH
89153: EMPTY
89154: LIST
89155: LIST
89156: PUSH
89157: LD_INT 2
89159: PUSH
89160: LD_INT 1
89162: NEG
89163: PUSH
89164: EMPTY
89165: LIST
89166: LIST
89167: PUSH
89168: LD_INT 3
89170: PUSH
89171: LD_INT 0
89173: PUSH
89174: EMPTY
89175: LIST
89176: LIST
89177: PUSH
89178: LD_INT 3
89180: PUSH
89181: LD_INT 1
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: PUSH
89188: LD_INT 1
89190: PUSH
89191: LD_INT 3
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PUSH
89198: LD_INT 0
89200: PUSH
89201: LD_INT 3
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: PUSH
89208: LD_INT 1
89210: NEG
89211: PUSH
89212: LD_INT 2
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: PUSH
89219: LD_INT 2
89221: NEG
89222: PUSH
89223: LD_INT 1
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 3
89232: NEG
89233: PUSH
89234: LD_INT 0
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: PUSH
89241: LD_INT 3
89243: NEG
89244: PUSH
89245: LD_INT 1
89247: NEG
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: EMPTY
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: LIST
89268: LIST
89269: LIST
89270: LIST
89271: LIST
89272: LIST
89273: LIST
89274: LIST
89275: LIST
89276: LIST
89277: LIST
89278: LIST
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89284: LD_ADDR_VAR 0 44
89288: PUSH
89289: LD_INT 0
89291: PUSH
89292: LD_INT 0
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 0
89301: PUSH
89302: LD_INT 1
89304: NEG
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 1
89312: PUSH
89313: LD_INT 0
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 1
89322: PUSH
89323: LD_INT 1
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 0
89332: PUSH
89333: LD_INT 1
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 1
89342: NEG
89343: PUSH
89344: LD_INT 0
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: PUSH
89351: LD_INT 1
89353: NEG
89354: PUSH
89355: LD_INT 1
89357: NEG
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 1
89365: NEG
89366: PUSH
89367: LD_INT 2
89369: NEG
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 1
89377: PUSH
89378: LD_INT 1
89380: NEG
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: LD_INT 2
89388: PUSH
89389: LD_INT 0
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: LD_INT 2
89398: PUSH
89399: LD_INT 1
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 2
89408: PUSH
89409: LD_INT 2
89411: PUSH
89412: EMPTY
89413: LIST
89414: LIST
89415: PUSH
89416: LD_INT 1
89418: PUSH
89419: LD_INT 2
89421: PUSH
89422: EMPTY
89423: LIST
89424: LIST
89425: PUSH
89426: LD_INT 1
89428: NEG
89429: PUSH
89430: LD_INT 1
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: LD_INT 2
89439: NEG
89440: PUSH
89441: LD_INT 0
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 2
89450: NEG
89451: PUSH
89452: LD_INT 1
89454: NEG
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 2
89462: NEG
89463: PUSH
89464: LD_INT 2
89466: NEG
89467: PUSH
89468: EMPTY
89469: LIST
89470: LIST
89471: PUSH
89472: LD_INT 2
89474: NEG
89475: PUSH
89476: LD_INT 3
89478: NEG
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: LD_INT 2
89486: PUSH
89487: LD_INT 1
89489: NEG
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: PUSH
89495: LD_INT 3
89497: PUSH
89498: LD_INT 0
89500: PUSH
89501: EMPTY
89502: LIST
89503: LIST
89504: PUSH
89505: LD_INT 3
89507: PUSH
89508: LD_INT 1
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PUSH
89515: LD_INT 3
89517: PUSH
89518: LD_INT 2
89520: PUSH
89521: EMPTY
89522: LIST
89523: LIST
89524: PUSH
89525: LD_INT 3
89527: PUSH
89528: LD_INT 3
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: PUSH
89535: LD_INT 2
89537: PUSH
89538: LD_INT 3
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: PUSH
89545: LD_INT 2
89547: NEG
89548: PUSH
89549: LD_INT 1
89551: PUSH
89552: EMPTY
89553: LIST
89554: LIST
89555: PUSH
89556: LD_INT 3
89558: NEG
89559: PUSH
89560: LD_INT 0
89562: PUSH
89563: EMPTY
89564: LIST
89565: LIST
89566: PUSH
89567: LD_INT 3
89569: NEG
89570: PUSH
89571: LD_INT 1
89573: NEG
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 3
89581: NEG
89582: PUSH
89583: LD_INT 2
89585: NEG
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 3
89593: NEG
89594: PUSH
89595: LD_INT 3
89597: NEG
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: EMPTY
89604: LIST
89605: LIST
89606: LIST
89607: LIST
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89634: LD_ADDR_VAR 0 45
89638: PUSH
89639: LD_INT 0
89641: PUSH
89642: LD_INT 0
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: LD_INT 0
89651: PUSH
89652: LD_INT 1
89654: NEG
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: PUSH
89660: LD_INT 1
89662: PUSH
89663: LD_INT 0
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 1
89672: PUSH
89673: LD_INT 1
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PUSH
89680: LD_INT 0
89682: PUSH
89683: LD_INT 1
89685: PUSH
89686: EMPTY
89687: LIST
89688: LIST
89689: PUSH
89690: LD_INT 1
89692: NEG
89693: PUSH
89694: LD_INT 0
89696: PUSH
89697: EMPTY
89698: LIST
89699: LIST
89700: PUSH
89701: LD_INT 1
89703: NEG
89704: PUSH
89705: LD_INT 1
89707: NEG
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: PUSH
89713: LD_INT 1
89715: NEG
89716: PUSH
89717: LD_INT 2
89719: NEG
89720: PUSH
89721: EMPTY
89722: LIST
89723: LIST
89724: PUSH
89725: LD_INT 0
89727: PUSH
89728: LD_INT 2
89730: NEG
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: PUSH
89736: LD_INT 1
89738: PUSH
89739: LD_INT 1
89741: NEG
89742: PUSH
89743: EMPTY
89744: LIST
89745: LIST
89746: PUSH
89747: LD_INT 2
89749: PUSH
89750: LD_INT 1
89752: PUSH
89753: EMPTY
89754: LIST
89755: LIST
89756: PUSH
89757: LD_INT 2
89759: PUSH
89760: LD_INT 2
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 1
89769: PUSH
89770: LD_INT 2
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 0
89779: PUSH
89780: LD_INT 2
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: PUSH
89787: LD_INT 1
89789: NEG
89790: PUSH
89791: LD_INT 1
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: PUSH
89798: LD_INT 2
89800: NEG
89801: PUSH
89802: LD_INT 1
89804: NEG
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 2
89812: NEG
89813: PUSH
89814: LD_INT 2
89816: NEG
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 2
89824: NEG
89825: PUSH
89826: LD_INT 3
89828: NEG
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: LD_INT 1
89836: NEG
89837: PUSH
89838: LD_INT 3
89840: NEG
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: LD_INT 0
89848: PUSH
89849: LD_INT 3
89851: NEG
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 1
89859: PUSH
89860: LD_INT 2
89862: NEG
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 3
89870: PUSH
89871: LD_INT 2
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: PUSH
89878: LD_INT 3
89880: PUSH
89881: LD_INT 3
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 2
89890: PUSH
89891: LD_INT 3
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: PUSH
89898: LD_INT 1
89900: PUSH
89901: LD_INT 3
89903: PUSH
89904: EMPTY
89905: LIST
89906: LIST
89907: PUSH
89908: LD_INT 0
89910: PUSH
89911: LD_INT 3
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: PUSH
89918: LD_INT 1
89920: NEG
89921: PUSH
89922: LD_INT 2
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 3
89931: NEG
89932: PUSH
89933: LD_INT 2
89935: NEG
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: PUSH
89941: LD_INT 3
89943: NEG
89944: PUSH
89945: LD_INT 3
89947: NEG
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89984: LD_ADDR_VAR 0 46
89988: PUSH
89989: LD_INT 0
89991: PUSH
89992: LD_INT 0
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: LD_INT 0
90001: PUSH
90002: LD_INT 1
90004: NEG
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 1
90012: PUSH
90013: LD_INT 0
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 1
90022: PUSH
90023: LD_INT 1
90025: PUSH
90026: EMPTY
90027: LIST
90028: LIST
90029: PUSH
90030: LD_INT 0
90032: PUSH
90033: LD_INT 1
90035: PUSH
90036: EMPTY
90037: LIST
90038: LIST
90039: PUSH
90040: LD_INT 1
90042: NEG
90043: PUSH
90044: LD_INT 0
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 1
90053: NEG
90054: PUSH
90055: LD_INT 1
90057: NEG
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: PUSH
90063: LD_INT 1
90065: NEG
90066: PUSH
90067: LD_INT 2
90069: NEG
90070: PUSH
90071: EMPTY
90072: LIST
90073: LIST
90074: PUSH
90075: LD_INT 0
90077: PUSH
90078: LD_INT 2
90080: NEG
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: PUSH
90086: LD_INT 1
90088: PUSH
90089: LD_INT 1
90091: NEG
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: PUSH
90097: LD_INT 2
90099: PUSH
90100: LD_INT 0
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: LD_INT 2
90109: PUSH
90110: LD_INT 1
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 1
90119: PUSH
90120: LD_INT 2
90122: PUSH
90123: EMPTY
90124: LIST
90125: LIST
90126: PUSH
90127: LD_INT 0
90129: PUSH
90130: LD_INT 2
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: PUSH
90137: LD_INT 1
90139: NEG
90140: PUSH
90141: LD_INT 1
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 2
90150: NEG
90151: PUSH
90152: LD_INT 0
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PUSH
90159: LD_INT 2
90161: NEG
90162: PUSH
90163: LD_INT 1
90165: NEG
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PUSH
90171: LD_INT 1
90173: NEG
90174: PUSH
90175: LD_INT 3
90177: NEG
90178: PUSH
90179: EMPTY
90180: LIST
90181: LIST
90182: PUSH
90183: LD_INT 0
90185: PUSH
90186: LD_INT 3
90188: NEG
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 1
90196: PUSH
90197: LD_INT 2
90199: NEG
90200: PUSH
90201: EMPTY
90202: LIST
90203: LIST
90204: PUSH
90205: LD_INT 2
90207: PUSH
90208: LD_INT 1
90210: NEG
90211: PUSH
90212: EMPTY
90213: LIST
90214: LIST
90215: PUSH
90216: LD_INT 3
90218: PUSH
90219: LD_INT 0
90221: PUSH
90222: EMPTY
90223: LIST
90224: LIST
90225: PUSH
90226: LD_INT 3
90228: PUSH
90229: LD_INT 1
90231: PUSH
90232: EMPTY
90233: LIST
90234: LIST
90235: PUSH
90236: LD_INT 1
90238: PUSH
90239: LD_INT 3
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 0
90248: PUSH
90249: LD_INT 3
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 1
90258: NEG
90259: PUSH
90260: LD_INT 2
90262: PUSH
90263: EMPTY
90264: LIST
90265: LIST
90266: PUSH
90267: LD_INT 2
90269: NEG
90270: PUSH
90271: LD_INT 1
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: LD_INT 3
90280: NEG
90281: PUSH
90282: LD_INT 0
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 3
90291: NEG
90292: PUSH
90293: LD_INT 1
90295: NEG
90296: PUSH
90297: EMPTY
90298: LIST
90299: LIST
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90332: LD_ADDR_VAR 0 47
90336: PUSH
90337: LD_INT 0
90339: PUSH
90340: LD_INT 0
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: LD_INT 0
90349: PUSH
90350: LD_INT 1
90352: NEG
90353: PUSH
90354: EMPTY
90355: LIST
90356: LIST
90357: PUSH
90358: LD_INT 1
90360: PUSH
90361: LD_INT 0
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 1
90370: PUSH
90371: LD_INT 1
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: LD_INT 0
90380: PUSH
90381: LD_INT 1
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 1
90390: NEG
90391: PUSH
90392: LD_INT 0
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 1
90401: NEG
90402: PUSH
90403: LD_INT 1
90405: NEG
90406: PUSH
90407: EMPTY
90408: LIST
90409: LIST
90410: PUSH
90411: LD_INT 1
90413: NEG
90414: PUSH
90415: LD_INT 2
90417: NEG
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: LD_INT 0
90425: PUSH
90426: LD_INT 2
90428: NEG
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 1
90436: PUSH
90437: LD_INT 1
90439: NEG
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 2
90447: NEG
90448: PUSH
90449: LD_INT 1
90451: NEG
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: LD_INT 2
90459: NEG
90460: PUSH
90461: LD_INT 2
90463: NEG
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90483: LD_ADDR_VAR 0 48
90487: PUSH
90488: LD_INT 0
90490: PUSH
90491: LD_INT 0
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 0
90500: PUSH
90501: LD_INT 1
90503: NEG
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 1
90511: PUSH
90512: LD_INT 0
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 1
90521: PUSH
90522: LD_INT 1
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 0
90531: PUSH
90532: LD_INT 1
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 1
90541: NEG
90542: PUSH
90543: LD_INT 0
90545: PUSH
90546: EMPTY
90547: LIST
90548: LIST
90549: PUSH
90550: LD_INT 1
90552: NEG
90553: PUSH
90554: LD_INT 1
90556: NEG
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: PUSH
90562: LD_INT 1
90564: NEG
90565: PUSH
90566: LD_INT 2
90568: NEG
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: PUSH
90574: LD_INT 0
90576: PUSH
90577: LD_INT 2
90579: NEG
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: LD_INT 1
90587: PUSH
90588: LD_INT 1
90590: NEG
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 2
90598: PUSH
90599: LD_INT 0
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: PUSH
90606: LD_INT 2
90608: PUSH
90609: LD_INT 1
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: EMPTY
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90630: LD_ADDR_VAR 0 49
90634: PUSH
90635: LD_INT 0
90637: PUSH
90638: LD_INT 0
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: PUSH
90645: LD_INT 0
90647: PUSH
90648: LD_INT 1
90650: NEG
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: PUSH
90656: LD_INT 1
90658: PUSH
90659: LD_INT 0
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: PUSH
90666: LD_INT 1
90668: PUSH
90669: LD_INT 1
90671: PUSH
90672: EMPTY
90673: LIST
90674: LIST
90675: PUSH
90676: LD_INT 0
90678: PUSH
90679: LD_INT 1
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 1
90688: NEG
90689: PUSH
90690: LD_INT 0
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: LD_INT 1
90703: NEG
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 1
90711: PUSH
90712: LD_INT 1
90714: NEG
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 2
90722: PUSH
90723: LD_INT 0
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: PUSH
90730: LD_INT 2
90732: PUSH
90733: LD_INT 1
90735: PUSH
90736: EMPTY
90737: LIST
90738: LIST
90739: PUSH
90740: LD_INT 2
90742: PUSH
90743: LD_INT 2
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 1
90752: PUSH
90753: LD_INT 2
90755: PUSH
90756: EMPTY
90757: LIST
90758: LIST
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90774: LD_ADDR_VAR 0 50
90778: PUSH
90779: LD_INT 0
90781: PUSH
90782: LD_INT 0
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 0
90791: PUSH
90792: LD_INT 1
90794: NEG
90795: PUSH
90796: EMPTY
90797: LIST
90798: LIST
90799: PUSH
90800: LD_INT 1
90802: PUSH
90803: LD_INT 0
90805: PUSH
90806: EMPTY
90807: LIST
90808: LIST
90809: PUSH
90810: LD_INT 1
90812: PUSH
90813: LD_INT 1
90815: PUSH
90816: EMPTY
90817: LIST
90818: LIST
90819: PUSH
90820: LD_INT 0
90822: PUSH
90823: LD_INT 1
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 1
90832: NEG
90833: PUSH
90834: LD_INT 0
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: PUSH
90841: LD_INT 1
90843: NEG
90844: PUSH
90845: LD_INT 1
90847: NEG
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 2
90855: PUSH
90856: LD_INT 1
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: PUSH
90863: LD_INT 2
90865: PUSH
90866: LD_INT 2
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: PUSH
90873: LD_INT 1
90875: PUSH
90876: LD_INT 2
90878: PUSH
90879: EMPTY
90880: LIST
90881: LIST
90882: PUSH
90883: LD_INT 0
90885: PUSH
90886: LD_INT 2
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: LD_INT 1
90895: NEG
90896: PUSH
90897: LD_INT 1
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: LIST
90916: LIST
90917: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90918: LD_ADDR_VAR 0 51
90922: PUSH
90923: LD_INT 0
90925: PUSH
90926: LD_INT 0
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 0
90935: PUSH
90936: LD_INT 1
90938: NEG
90939: PUSH
90940: EMPTY
90941: LIST
90942: LIST
90943: PUSH
90944: LD_INT 1
90946: PUSH
90947: LD_INT 0
90949: PUSH
90950: EMPTY
90951: LIST
90952: LIST
90953: PUSH
90954: LD_INT 1
90956: PUSH
90957: LD_INT 1
90959: PUSH
90960: EMPTY
90961: LIST
90962: LIST
90963: PUSH
90964: LD_INT 0
90966: PUSH
90967: LD_INT 1
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 1
90976: NEG
90977: PUSH
90978: LD_INT 0
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 1
90987: NEG
90988: PUSH
90989: LD_INT 1
90991: NEG
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 1
90999: PUSH
91000: LD_INT 2
91002: PUSH
91003: EMPTY
91004: LIST
91005: LIST
91006: PUSH
91007: LD_INT 0
91009: PUSH
91010: LD_INT 2
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: LD_INT 1
91019: NEG
91020: PUSH
91021: LD_INT 1
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PUSH
91028: LD_INT 2
91030: NEG
91031: PUSH
91032: LD_INT 0
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: LD_INT 2
91041: NEG
91042: PUSH
91043: LD_INT 1
91045: NEG
91046: PUSH
91047: EMPTY
91048: LIST
91049: LIST
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91065: LD_ADDR_VAR 0 52
91069: PUSH
91070: LD_INT 0
91072: PUSH
91073: LD_INT 0
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: PUSH
91080: LD_INT 0
91082: PUSH
91083: LD_INT 1
91085: NEG
91086: PUSH
91087: EMPTY
91088: LIST
91089: LIST
91090: PUSH
91091: LD_INT 1
91093: PUSH
91094: LD_INT 0
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 1
91103: PUSH
91104: LD_INT 1
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 0
91113: PUSH
91114: LD_INT 1
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 1
91123: NEG
91124: PUSH
91125: LD_INT 0
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 1
91134: NEG
91135: PUSH
91136: LD_INT 1
91138: NEG
91139: PUSH
91140: EMPTY
91141: LIST
91142: LIST
91143: PUSH
91144: LD_INT 1
91146: NEG
91147: PUSH
91148: LD_INT 2
91150: NEG
91151: PUSH
91152: EMPTY
91153: LIST
91154: LIST
91155: PUSH
91156: LD_INT 1
91158: NEG
91159: PUSH
91160: LD_INT 1
91162: PUSH
91163: EMPTY
91164: LIST
91165: LIST
91166: PUSH
91167: LD_INT 2
91169: NEG
91170: PUSH
91171: LD_INT 0
91173: PUSH
91174: EMPTY
91175: LIST
91176: LIST
91177: PUSH
91178: LD_INT 2
91180: NEG
91181: PUSH
91182: LD_INT 1
91184: NEG
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 2
91192: NEG
91193: PUSH
91194: LD_INT 2
91196: NEG
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91216: LD_ADDR_VAR 0 53
91220: PUSH
91221: LD_INT 0
91223: PUSH
91224: LD_INT 0
91226: PUSH
91227: EMPTY
91228: LIST
91229: LIST
91230: PUSH
91231: LD_INT 0
91233: PUSH
91234: LD_INT 1
91236: NEG
91237: PUSH
91238: EMPTY
91239: LIST
91240: LIST
91241: PUSH
91242: LD_INT 1
91244: PUSH
91245: LD_INT 0
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: PUSH
91252: LD_INT 1
91254: PUSH
91255: LD_INT 1
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PUSH
91262: LD_INT 0
91264: PUSH
91265: LD_INT 1
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 1
91274: NEG
91275: PUSH
91276: LD_INT 0
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: LD_INT 1
91285: NEG
91286: PUSH
91287: LD_INT 1
91289: NEG
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 1
91297: NEG
91298: PUSH
91299: LD_INT 2
91301: NEG
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 0
91309: PUSH
91310: LD_INT 2
91312: NEG
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: PUSH
91318: LD_INT 1
91320: PUSH
91321: LD_INT 1
91323: NEG
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 2
91331: PUSH
91332: LD_INT 0
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: PUSH
91339: LD_INT 2
91341: PUSH
91342: LD_INT 1
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 2
91351: PUSH
91352: LD_INT 2
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: PUSH
91359: LD_INT 1
91361: PUSH
91362: LD_INT 2
91364: PUSH
91365: EMPTY
91366: LIST
91367: LIST
91368: PUSH
91369: LD_INT 0
91371: PUSH
91372: LD_INT 2
91374: PUSH
91375: EMPTY
91376: LIST
91377: LIST
91378: PUSH
91379: LD_INT 1
91381: NEG
91382: PUSH
91383: LD_INT 1
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: LD_INT 2
91392: NEG
91393: PUSH
91394: LD_INT 0
91396: PUSH
91397: EMPTY
91398: LIST
91399: LIST
91400: PUSH
91401: LD_INT 2
91403: NEG
91404: PUSH
91405: LD_INT 1
91407: NEG
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: PUSH
91413: LD_INT 2
91415: NEG
91416: PUSH
91417: LD_INT 2
91419: NEG
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91446: LD_ADDR_VAR 0 54
91450: PUSH
91451: LD_INT 0
91453: PUSH
91454: LD_INT 0
91456: PUSH
91457: EMPTY
91458: LIST
91459: LIST
91460: PUSH
91461: LD_INT 0
91463: PUSH
91464: LD_INT 1
91466: NEG
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 1
91474: PUSH
91475: LD_INT 0
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: LD_INT 1
91484: PUSH
91485: LD_INT 1
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: PUSH
91492: LD_INT 0
91494: PUSH
91495: LD_INT 1
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PUSH
91502: LD_INT 1
91504: NEG
91505: PUSH
91506: LD_INT 0
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 1
91515: NEG
91516: PUSH
91517: LD_INT 1
91519: NEG
91520: PUSH
91521: EMPTY
91522: LIST
91523: LIST
91524: PUSH
91525: LD_INT 1
91527: NEG
91528: PUSH
91529: LD_INT 2
91531: NEG
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PUSH
91537: LD_INT 0
91539: PUSH
91540: LD_INT 2
91542: NEG
91543: PUSH
91544: EMPTY
91545: LIST
91546: LIST
91547: PUSH
91548: LD_INT 1
91550: PUSH
91551: LD_INT 1
91553: NEG
91554: PUSH
91555: EMPTY
91556: LIST
91557: LIST
91558: PUSH
91559: LD_INT 2
91561: PUSH
91562: LD_INT 0
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: LD_INT 2
91571: PUSH
91572: LD_INT 1
91574: PUSH
91575: EMPTY
91576: LIST
91577: LIST
91578: PUSH
91579: LD_INT 2
91581: PUSH
91582: LD_INT 2
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: LD_INT 1
91591: PUSH
91592: LD_INT 2
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: PUSH
91599: LD_INT 0
91601: PUSH
91602: LD_INT 2
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: PUSH
91609: LD_INT 1
91611: NEG
91612: PUSH
91613: LD_INT 1
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: PUSH
91620: LD_INT 2
91622: NEG
91623: PUSH
91624: LD_INT 0
91626: PUSH
91627: EMPTY
91628: LIST
91629: LIST
91630: PUSH
91631: LD_INT 2
91633: NEG
91634: PUSH
91635: LD_INT 1
91637: NEG
91638: PUSH
91639: EMPTY
91640: LIST
91641: LIST
91642: PUSH
91643: LD_INT 2
91645: NEG
91646: PUSH
91647: LD_INT 2
91649: NEG
91650: PUSH
91651: EMPTY
91652: LIST
91653: LIST
91654: PUSH
91655: EMPTY
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: LIST
91661: LIST
91662: LIST
91663: LIST
91664: LIST
91665: LIST
91666: LIST
91667: LIST
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91676: LD_ADDR_VAR 0 55
91680: PUSH
91681: LD_INT 0
91683: PUSH
91684: LD_INT 0
91686: PUSH
91687: EMPTY
91688: LIST
91689: LIST
91690: PUSH
91691: LD_INT 0
91693: PUSH
91694: LD_INT 1
91696: NEG
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: PUSH
91702: LD_INT 1
91704: PUSH
91705: LD_INT 0
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 1
91714: PUSH
91715: LD_INT 1
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 0
91724: PUSH
91725: LD_INT 1
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 1
91734: NEG
91735: PUSH
91736: LD_INT 0
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: PUSH
91743: LD_INT 1
91745: NEG
91746: PUSH
91747: LD_INT 1
91749: NEG
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: PUSH
91755: LD_INT 1
91757: NEG
91758: PUSH
91759: LD_INT 2
91761: NEG
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: PUSH
91767: LD_INT 0
91769: PUSH
91770: LD_INT 2
91772: NEG
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 1
91780: PUSH
91781: LD_INT 1
91783: NEG
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 2
91791: PUSH
91792: LD_INT 0
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 2
91801: PUSH
91802: LD_INT 1
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: LD_INT 2
91811: PUSH
91812: LD_INT 2
91814: PUSH
91815: EMPTY
91816: LIST
91817: LIST
91818: PUSH
91819: LD_INT 1
91821: PUSH
91822: LD_INT 2
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: PUSH
91829: LD_INT 0
91831: PUSH
91832: LD_INT 2
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: PUSH
91839: LD_INT 1
91841: NEG
91842: PUSH
91843: LD_INT 1
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: LD_INT 2
91852: NEG
91853: PUSH
91854: LD_INT 0
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: PUSH
91861: LD_INT 2
91863: NEG
91864: PUSH
91865: LD_INT 1
91867: NEG
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 2
91875: NEG
91876: PUSH
91877: LD_INT 2
91879: NEG
91880: PUSH
91881: EMPTY
91882: LIST
91883: LIST
91884: PUSH
91885: EMPTY
91886: LIST
91887: LIST
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: LIST
91902: LIST
91903: LIST
91904: LIST
91905: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91906: LD_ADDR_VAR 0 56
91910: PUSH
91911: LD_INT 0
91913: PUSH
91914: LD_INT 0
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 0
91923: PUSH
91924: LD_INT 1
91926: NEG
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 1
91934: PUSH
91935: LD_INT 0
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: LD_INT 1
91944: PUSH
91945: LD_INT 1
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 0
91954: PUSH
91955: LD_INT 1
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 1
91964: NEG
91965: PUSH
91966: LD_INT 0
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 1
91975: NEG
91976: PUSH
91977: LD_INT 1
91979: NEG
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: PUSH
91985: LD_INT 1
91987: NEG
91988: PUSH
91989: LD_INT 2
91991: NEG
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: PUSH
91997: LD_INT 0
91999: PUSH
92000: LD_INT 2
92002: NEG
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: LD_INT 1
92010: PUSH
92011: LD_INT 1
92013: NEG
92014: PUSH
92015: EMPTY
92016: LIST
92017: LIST
92018: PUSH
92019: LD_INT 2
92021: PUSH
92022: LD_INT 0
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PUSH
92029: LD_INT 2
92031: PUSH
92032: LD_INT 1
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: PUSH
92039: LD_INT 2
92041: PUSH
92042: LD_INT 2
92044: PUSH
92045: EMPTY
92046: LIST
92047: LIST
92048: PUSH
92049: LD_INT 1
92051: PUSH
92052: LD_INT 2
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: PUSH
92059: LD_INT 0
92061: PUSH
92062: LD_INT 2
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: PUSH
92069: LD_INT 1
92071: NEG
92072: PUSH
92073: LD_INT 1
92075: PUSH
92076: EMPTY
92077: LIST
92078: LIST
92079: PUSH
92080: LD_INT 2
92082: NEG
92083: PUSH
92084: LD_INT 0
92086: PUSH
92087: EMPTY
92088: LIST
92089: LIST
92090: PUSH
92091: LD_INT 2
92093: NEG
92094: PUSH
92095: LD_INT 1
92097: NEG
92098: PUSH
92099: EMPTY
92100: LIST
92101: LIST
92102: PUSH
92103: LD_INT 2
92105: NEG
92106: PUSH
92107: LD_INT 2
92109: NEG
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: LIST
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92136: LD_ADDR_VAR 0 57
92140: PUSH
92141: LD_INT 0
92143: PUSH
92144: LD_INT 0
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: PUSH
92151: LD_INT 0
92153: PUSH
92154: LD_INT 1
92156: NEG
92157: PUSH
92158: EMPTY
92159: LIST
92160: LIST
92161: PUSH
92162: LD_INT 1
92164: PUSH
92165: LD_INT 0
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PUSH
92172: LD_INT 1
92174: PUSH
92175: LD_INT 1
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: PUSH
92182: LD_INT 0
92184: PUSH
92185: LD_INT 1
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 1
92194: NEG
92195: PUSH
92196: LD_INT 0
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: LD_INT 1
92205: NEG
92206: PUSH
92207: LD_INT 1
92209: NEG
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 1
92217: NEG
92218: PUSH
92219: LD_INT 2
92221: NEG
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: PUSH
92227: LD_INT 0
92229: PUSH
92230: LD_INT 2
92232: NEG
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PUSH
92238: LD_INT 1
92240: PUSH
92241: LD_INT 1
92243: NEG
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: PUSH
92249: LD_INT 2
92251: PUSH
92252: LD_INT 0
92254: PUSH
92255: EMPTY
92256: LIST
92257: LIST
92258: PUSH
92259: LD_INT 2
92261: PUSH
92262: LD_INT 1
92264: PUSH
92265: EMPTY
92266: LIST
92267: LIST
92268: PUSH
92269: LD_INT 2
92271: PUSH
92272: LD_INT 2
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: PUSH
92279: LD_INT 1
92281: PUSH
92282: LD_INT 2
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: PUSH
92289: LD_INT 0
92291: PUSH
92292: LD_INT 2
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 1
92301: NEG
92302: PUSH
92303: LD_INT 1
92305: PUSH
92306: EMPTY
92307: LIST
92308: LIST
92309: PUSH
92310: LD_INT 2
92312: NEG
92313: PUSH
92314: LD_INT 0
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: PUSH
92321: LD_INT 2
92323: NEG
92324: PUSH
92325: LD_INT 1
92327: NEG
92328: PUSH
92329: EMPTY
92330: LIST
92331: LIST
92332: PUSH
92333: LD_INT 2
92335: NEG
92336: PUSH
92337: LD_INT 2
92339: NEG
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: EMPTY
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92366: LD_ADDR_VAR 0 58
92370: PUSH
92371: LD_INT 0
92373: PUSH
92374: LD_INT 0
92376: PUSH
92377: EMPTY
92378: LIST
92379: LIST
92380: PUSH
92381: LD_INT 0
92383: PUSH
92384: LD_INT 1
92386: NEG
92387: PUSH
92388: EMPTY
92389: LIST
92390: LIST
92391: PUSH
92392: LD_INT 1
92394: PUSH
92395: LD_INT 0
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: PUSH
92402: LD_INT 1
92404: PUSH
92405: LD_INT 1
92407: PUSH
92408: EMPTY
92409: LIST
92410: LIST
92411: PUSH
92412: LD_INT 0
92414: PUSH
92415: LD_INT 1
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 1
92424: NEG
92425: PUSH
92426: LD_INT 0
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: PUSH
92433: LD_INT 1
92435: NEG
92436: PUSH
92437: LD_INT 1
92439: NEG
92440: PUSH
92441: EMPTY
92442: LIST
92443: LIST
92444: PUSH
92445: LD_INT 1
92447: NEG
92448: PUSH
92449: LD_INT 2
92451: NEG
92452: PUSH
92453: EMPTY
92454: LIST
92455: LIST
92456: PUSH
92457: LD_INT 0
92459: PUSH
92460: LD_INT 2
92462: NEG
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: PUSH
92468: LD_INT 1
92470: PUSH
92471: LD_INT 1
92473: NEG
92474: PUSH
92475: EMPTY
92476: LIST
92477: LIST
92478: PUSH
92479: LD_INT 2
92481: PUSH
92482: LD_INT 0
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 2
92491: PUSH
92492: LD_INT 1
92494: PUSH
92495: EMPTY
92496: LIST
92497: LIST
92498: PUSH
92499: LD_INT 2
92501: PUSH
92502: LD_INT 2
92504: PUSH
92505: EMPTY
92506: LIST
92507: LIST
92508: PUSH
92509: LD_INT 1
92511: PUSH
92512: LD_INT 2
92514: PUSH
92515: EMPTY
92516: LIST
92517: LIST
92518: PUSH
92519: LD_INT 0
92521: PUSH
92522: LD_INT 2
92524: PUSH
92525: EMPTY
92526: LIST
92527: LIST
92528: PUSH
92529: LD_INT 1
92531: NEG
92532: PUSH
92533: LD_INT 1
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: PUSH
92540: LD_INT 2
92542: NEG
92543: PUSH
92544: LD_INT 0
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: PUSH
92551: LD_INT 2
92553: NEG
92554: PUSH
92555: LD_INT 1
92557: NEG
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 2
92565: NEG
92566: PUSH
92567: LD_INT 2
92569: NEG
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: EMPTY
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: LIST
92594: LIST
92595: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92596: LD_ADDR_VAR 0 59
92600: PUSH
92601: LD_INT 0
92603: PUSH
92604: LD_INT 0
92606: PUSH
92607: EMPTY
92608: LIST
92609: LIST
92610: PUSH
92611: LD_INT 0
92613: PUSH
92614: LD_INT 1
92616: NEG
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 1
92624: PUSH
92625: LD_INT 0
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 1
92634: PUSH
92635: LD_INT 1
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 0
92644: PUSH
92645: LD_INT 1
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 1
92654: NEG
92655: PUSH
92656: LD_INT 0
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: PUSH
92663: LD_INT 1
92665: NEG
92666: PUSH
92667: LD_INT 1
92669: NEG
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: EMPTY
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92684: LD_ADDR_VAR 0 60
92688: PUSH
92689: LD_INT 0
92691: PUSH
92692: LD_INT 0
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: LD_INT 0
92701: PUSH
92702: LD_INT 1
92704: NEG
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 1
92712: PUSH
92713: LD_INT 0
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 1
92722: PUSH
92723: LD_INT 1
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: PUSH
92730: LD_INT 0
92732: PUSH
92733: LD_INT 1
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: PUSH
92740: LD_INT 1
92742: NEG
92743: PUSH
92744: LD_INT 0
92746: PUSH
92747: EMPTY
92748: LIST
92749: LIST
92750: PUSH
92751: LD_INT 1
92753: NEG
92754: PUSH
92755: LD_INT 1
92757: NEG
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: EMPTY
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: LIST
92770: LIST
92771: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92772: LD_ADDR_VAR 0 61
92776: PUSH
92777: LD_INT 0
92779: PUSH
92780: LD_INT 0
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 0
92789: PUSH
92790: LD_INT 1
92792: NEG
92793: PUSH
92794: EMPTY
92795: LIST
92796: LIST
92797: PUSH
92798: LD_INT 1
92800: PUSH
92801: LD_INT 0
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: PUSH
92808: LD_INT 1
92810: PUSH
92811: LD_INT 1
92813: PUSH
92814: EMPTY
92815: LIST
92816: LIST
92817: PUSH
92818: LD_INT 0
92820: PUSH
92821: LD_INT 1
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 1
92830: NEG
92831: PUSH
92832: LD_INT 0
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: LD_INT 1
92841: NEG
92842: PUSH
92843: LD_INT 1
92845: NEG
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92860: LD_ADDR_VAR 0 62
92864: PUSH
92865: LD_INT 0
92867: PUSH
92868: LD_INT 0
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 0
92877: PUSH
92878: LD_INT 1
92880: NEG
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_INT 1
92888: PUSH
92889: LD_INT 0
92891: PUSH
92892: EMPTY
92893: LIST
92894: LIST
92895: PUSH
92896: LD_INT 1
92898: PUSH
92899: LD_INT 1
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 0
92908: PUSH
92909: LD_INT 1
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: PUSH
92916: LD_INT 1
92918: NEG
92919: PUSH
92920: LD_INT 0
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: LD_INT 1
92929: NEG
92930: PUSH
92931: LD_INT 1
92933: NEG
92934: PUSH
92935: EMPTY
92936: LIST
92937: LIST
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92948: LD_ADDR_VAR 0 63
92952: PUSH
92953: LD_INT 0
92955: PUSH
92956: LD_INT 0
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 0
92965: PUSH
92966: LD_INT 1
92968: NEG
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: PUSH
92974: LD_INT 1
92976: PUSH
92977: LD_INT 0
92979: PUSH
92980: EMPTY
92981: LIST
92982: LIST
92983: PUSH
92984: LD_INT 1
92986: PUSH
92987: LD_INT 1
92989: PUSH
92990: EMPTY
92991: LIST
92992: LIST
92993: PUSH
92994: LD_INT 0
92996: PUSH
92997: LD_INT 1
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: PUSH
93004: LD_INT 1
93006: NEG
93007: PUSH
93008: LD_INT 0
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 1
93017: NEG
93018: PUSH
93019: LD_INT 1
93021: NEG
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93036: LD_ADDR_VAR 0 64
93040: PUSH
93041: LD_INT 0
93043: PUSH
93044: LD_INT 0
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: PUSH
93051: LD_INT 0
93053: PUSH
93054: LD_INT 1
93056: NEG
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: PUSH
93062: LD_INT 1
93064: PUSH
93065: LD_INT 0
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 1
93074: PUSH
93075: LD_INT 1
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 0
93084: PUSH
93085: LD_INT 1
93087: PUSH
93088: EMPTY
93089: LIST
93090: LIST
93091: PUSH
93092: LD_INT 1
93094: NEG
93095: PUSH
93096: LD_INT 0
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PUSH
93103: LD_INT 1
93105: NEG
93106: PUSH
93107: LD_INT 1
93109: NEG
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: ST_TO_ADDR
// end ; 1 :
93124: GO 99021
93126: LD_INT 1
93128: DOUBLE
93129: EQUAL
93130: IFTRUE 93134
93132: GO 95757
93134: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93135: LD_ADDR_VAR 0 11
93139: PUSH
93140: LD_INT 1
93142: NEG
93143: PUSH
93144: LD_INT 3
93146: NEG
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: PUSH
93152: LD_INT 0
93154: PUSH
93155: LD_INT 3
93157: NEG
93158: PUSH
93159: EMPTY
93160: LIST
93161: LIST
93162: PUSH
93163: LD_INT 1
93165: PUSH
93166: LD_INT 2
93168: NEG
93169: PUSH
93170: EMPTY
93171: LIST
93172: LIST
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: LIST
93178: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93179: LD_ADDR_VAR 0 12
93183: PUSH
93184: LD_INT 2
93186: PUSH
93187: LD_INT 1
93189: NEG
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: PUSH
93195: LD_INT 3
93197: PUSH
93198: LD_INT 0
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PUSH
93205: LD_INT 3
93207: PUSH
93208: LD_INT 1
93210: PUSH
93211: EMPTY
93212: LIST
93213: LIST
93214: PUSH
93215: EMPTY
93216: LIST
93217: LIST
93218: LIST
93219: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93220: LD_ADDR_VAR 0 13
93224: PUSH
93225: LD_INT 3
93227: PUSH
93228: LD_INT 2
93230: PUSH
93231: EMPTY
93232: LIST
93233: LIST
93234: PUSH
93235: LD_INT 3
93237: PUSH
93238: LD_INT 3
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: LD_INT 2
93247: PUSH
93248: LD_INT 3
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: LIST
93259: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93260: LD_ADDR_VAR 0 14
93264: PUSH
93265: LD_INT 1
93267: PUSH
93268: LD_INT 3
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: PUSH
93275: LD_INT 0
93277: PUSH
93278: LD_INT 3
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: LD_INT 1
93287: NEG
93288: PUSH
93289: LD_INT 2
93291: PUSH
93292: EMPTY
93293: LIST
93294: LIST
93295: PUSH
93296: EMPTY
93297: LIST
93298: LIST
93299: LIST
93300: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93301: LD_ADDR_VAR 0 15
93305: PUSH
93306: LD_INT 2
93308: NEG
93309: PUSH
93310: LD_INT 1
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PUSH
93317: LD_INT 3
93319: NEG
93320: PUSH
93321: LD_INT 0
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 3
93330: NEG
93331: PUSH
93332: LD_INT 1
93334: NEG
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: EMPTY
93341: LIST
93342: LIST
93343: LIST
93344: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93345: LD_ADDR_VAR 0 16
93349: PUSH
93350: LD_INT 2
93352: NEG
93353: PUSH
93354: LD_INT 3
93356: NEG
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: PUSH
93362: LD_INT 3
93364: NEG
93365: PUSH
93366: LD_INT 2
93368: NEG
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 3
93376: NEG
93377: PUSH
93378: LD_INT 3
93380: NEG
93381: PUSH
93382: EMPTY
93383: LIST
93384: LIST
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: LIST
93390: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93391: LD_ADDR_VAR 0 17
93395: PUSH
93396: LD_INT 1
93398: NEG
93399: PUSH
93400: LD_INT 3
93402: NEG
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: PUSH
93408: LD_INT 0
93410: PUSH
93411: LD_INT 3
93413: NEG
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: PUSH
93419: LD_INT 1
93421: PUSH
93422: LD_INT 2
93424: NEG
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: EMPTY
93431: LIST
93432: LIST
93433: LIST
93434: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93435: LD_ADDR_VAR 0 18
93439: PUSH
93440: LD_INT 2
93442: PUSH
93443: LD_INT 1
93445: NEG
93446: PUSH
93447: EMPTY
93448: LIST
93449: LIST
93450: PUSH
93451: LD_INT 3
93453: PUSH
93454: LD_INT 0
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: LD_INT 3
93463: PUSH
93464: LD_INT 1
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: LIST
93475: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93476: LD_ADDR_VAR 0 19
93480: PUSH
93481: LD_INT 3
93483: PUSH
93484: LD_INT 2
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 3
93493: PUSH
93494: LD_INT 3
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: PUSH
93501: LD_INT 2
93503: PUSH
93504: LD_INT 3
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: LIST
93515: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93516: LD_ADDR_VAR 0 20
93520: PUSH
93521: LD_INT 1
93523: PUSH
93524: LD_INT 3
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 0
93533: PUSH
93534: LD_INT 3
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: LD_INT 1
93543: NEG
93544: PUSH
93545: LD_INT 2
93547: PUSH
93548: EMPTY
93549: LIST
93550: LIST
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: LIST
93556: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93557: LD_ADDR_VAR 0 21
93561: PUSH
93562: LD_INT 2
93564: NEG
93565: PUSH
93566: LD_INT 1
93568: PUSH
93569: EMPTY
93570: LIST
93571: LIST
93572: PUSH
93573: LD_INT 3
93575: NEG
93576: PUSH
93577: LD_INT 0
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: PUSH
93584: LD_INT 3
93586: NEG
93587: PUSH
93588: LD_INT 1
93590: NEG
93591: PUSH
93592: EMPTY
93593: LIST
93594: LIST
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: LIST
93600: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93601: LD_ADDR_VAR 0 22
93605: PUSH
93606: LD_INT 2
93608: NEG
93609: PUSH
93610: LD_INT 3
93612: NEG
93613: PUSH
93614: EMPTY
93615: LIST
93616: LIST
93617: PUSH
93618: LD_INT 3
93620: NEG
93621: PUSH
93622: LD_INT 2
93624: NEG
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: PUSH
93630: LD_INT 3
93632: NEG
93633: PUSH
93634: LD_INT 3
93636: NEG
93637: PUSH
93638: EMPTY
93639: LIST
93640: LIST
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: LIST
93646: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
93647: LD_ADDR_VAR 0 23
93651: PUSH
93652: LD_INT 0
93654: PUSH
93655: LD_INT 3
93657: NEG
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 1
93665: NEG
93666: PUSH
93667: LD_INT 4
93669: NEG
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: LD_INT 1
93677: PUSH
93678: LD_INT 3
93680: NEG
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PUSH
93686: EMPTY
93687: LIST
93688: LIST
93689: LIST
93690: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
93691: LD_ADDR_VAR 0 24
93695: PUSH
93696: LD_INT 3
93698: PUSH
93699: LD_INT 0
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 3
93708: PUSH
93709: LD_INT 1
93711: NEG
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: LD_INT 4
93719: PUSH
93720: LD_INT 1
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: LIST
93731: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
93732: LD_ADDR_VAR 0 25
93736: PUSH
93737: LD_INT 3
93739: PUSH
93740: LD_INT 3
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 4
93749: PUSH
93750: LD_INT 3
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: LD_INT 3
93759: PUSH
93760: LD_INT 4
93762: PUSH
93763: EMPTY
93764: LIST
93765: LIST
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: LIST
93771: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
93772: LD_ADDR_VAR 0 26
93776: PUSH
93777: LD_INT 0
93779: PUSH
93780: LD_INT 3
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 1
93789: PUSH
93790: LD_INT 4
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: LD_INT 1
93799: NEG
93800: PUSH
93801: LD_INT 3
93803: PUSH
93804: EMPTY
93805: LIST
93806: LIST
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: LIST
93812: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
93813: LD_ADDR_VAR 0 27
93817: PUSH
93818: LD_INT 3
93820: NEG
93821: PUSH
93822: LD_INT 0
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: LD_INT 3
93831: NEG
93832: PUSH
93833: LD_INT 1
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: PUSH
93840: LD_INT 4
93842: NEG
93843: PUSH
93844: LD_INT 1
93846: NEG
93847: PUSH
93848: EMPTY
93849: LIST
93850: LIST
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: LIST
93856: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
93857: LD_ADDR_VAR 0 28
93861: PUSH
93862: LD_INT 3
93864: NEG
93865: PUSH
93866: LD_INT 3
93868: NEG
93869: PUSH
93870: EMPTY
93871: LIST
93872: LIST
93873: PUSH
93874: LD_INT 3
93876: NEG
93877: PUSH
93878: LD_INT 4
93880: NEG
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: PUSH
93886: LD_INT 4
93888: NEG
93889: PUSH
93890: LD_INT 3
93892: NEG
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: LIST
93902: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
93903: LD_ADDR_VAR 0 29
93907: PUSH
93908: LD_INT 1
93910: NEG
93911: PUSH
93912: LD_INT 3
93914: NEG
93915: PUSH
93916: EMPTY
93917: LIST
93918: LIST
93919: PUSH
93920: LD_INT 0
93922: PUSH
93923: LD_INT 3
93925: NEG
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: PUSH
93931: LD_INT 1
93933: PUSH
93934: LD_INT 2
93936: NEG
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: LD_INT 1
93944: NEG
93945: PUSH
93946: LD_INT 4
93948: NEG
93949: PUSH
93950: EMPTY
93951: LIST
93952: LIST
93953: PUSH
93954: LD_INT 0
93956: PUSH
93957: LD_INT 4
93959: NEG
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: PUSH
93965: LD_INT 1
93967: PUSH
93968: LD_INT 3
93970: NEG
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: PUSH
93976: LD_INT 1
93978: NEG
93979: PUSH
93980: LD_INT 5
93982: NEG
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PUSH
93988: LD_INT 0
93990: PUSH
93991: LD_INT 5
93993: NEG
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 1
94001: PUSH
94002: LD_INT 4
94004: NEG
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: LD_INT 1
94012: NEG
94013: PUSH
94014: LD_INT 6
94016: NEG
94017: PUSH
94018: EMPTY
94019: LIST
94020: LIST
94021: PUSH
94022: LD_INT 0
94024: PUSH
94025: LD_INT 6
94027: NEG
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 1
94035: PUSH
94036: LD_INT 5
94038: NEG
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94058: LD_ADDR_VAR 0 30
94062: PUSH
94063: LD_INT 2
94065: PUSH
94066: LD_INT 1
94068: NEG
94069: PUSH
94070: EMPTY
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 3
94076: PUSH
94077: LD_INT 0
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 3
94086: PUSH
94087: LD_INT 1
94089: PUSH
94090: EMPTY
94091: LIST
94092: LIST
94093: PUSH
94094: LD_INT 3
94096: PUSH
94097: LD_INT 1
94099: NEG
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: PUSH
94105: LD_INT 4
94107: PUSH
94108: LD_INT 0
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 4
94117: PUSH
94118: LD_INT 1
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: LD_INT 4
94127: PUSH
94128: LD_INT 1
94130: NEG
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 5
94138: PUSH
94139: LD_INT 0
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: LD_INT 5
94148: PUSH
94149: LD_INT 1
94151: PUSH
94152: EMPTY
94153: LIST
94154: LIST
94155: PUSH
94156: LD_INT 5
94158: PUSH
94159: LD_INT 1
94161: NEG
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: PUSH
94167: LD_INT 6
94169: PUSH
94170: LD_INT 0
94172: PUSH
94173: EMPTY
94174: LIST
94175: LIST
94176: PUSH
94177: LD_INT 6
94179: PUSH
94180: LD_INT 1
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: LIST
94191: LIST
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94201: LD_ADDR_VAR 0 31
94205: PUSH
94206: LD_INT 3
94208: PUSH
94209: LD_INT 2
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: PUSH
94216: LD_INT 3
94218: PUSH
94219: LD_INT 3
94221: PUSH
94222: EMPTY
94223: LIST
94224: LIST
94225: PUSH
94226: LD_INT 2
94228: PUSH
94229: LD_INT 3
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: PUSH
94236: LD_INT 4
94238: PUSH
94239: LD_INT 3
94241: PUSH
94242: EMPTY
94243: LIST
94244: LIST
94245: PUSH
94246: LD_INT 4
94248: PUSH
94249: LD_INT 4
94251: PUSH
94252: EMPTY
94253: LIST
94254: LIST
94255: PUSH
94256: LD_INT 3
94258: PUSH
94259: LD_INT 4
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 5
94268: PUSH
94269: LD_INT 4
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: LD_INT 5
94278: PUSH
94279: LD_INT 5
94281: PUSH
94282: EMPTY
94283: LIST
94284: LIST
94285: PUSH
94286: LD_INT 4
94288: PUSH
94289: LD_INT 5
94291: PUSH
94292: EMPTY
94293: LIST
94294: LIST
94295: PUSH
94296: LD_INT 6
94298: PUSH
94299: LD_INT 5
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 6
94308: PUSH
94309: LD_INT 6
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PUSH
94316: LD_INT 5
94318: PUSH
94319: LD_INT 6
94321: PUSH
94322: EMPTY
94323: LIST
94324: LIST
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94340: LD_ADDR_VAR 0 32
94344: PUSH
94345: LD_INT 1
94347: PUSH
94348: LD_INT 3
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 0
94357: PUSH
94358: LD_INT 3
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 1
94367: NEG
94368: PUSH
94369: LD_INT 2
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 1
94378: PUSH
94379: LD_INT 4
94381: PUSH
94382: EMPTY
94383: LIST
94384: LIST
94385: PUSH
94386: LD_INT 0
94388: PUSH
94389: LD_INT 4
94391: PUSH
94392: EMPTY
94393: LIST
94394: LIST
94395: PUSH
94396: LD_INT 1
94398: NEG
94399: PUSH
94400: LD_INT 3
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 1
94409: PUSH
94410: LD_INT 5
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PUSH
94417: LD_INT 0
94419: PUSH
94420: LD_INT 5
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: PUSH
94427: LD_INT 1
94429: NEG
94430: PUSH
94431: LD_INT 4
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PUSH
94438: LD_INT 1
94440: PUSH
94441: LD_INT 6
94443: PUSH
94444: EMPTY
94445: LIST
94446: LIST
94447: PUSH
94448: LD_INT 0
94450: PUSH
94451: LD_INT 6
94453: PUSH
94454: EMPTY
94455: LIST
94456: LIST
94457: PUSH
94458: LD_INT 1
94460: NEG
94461: PUSH
94462: LD_INT 5
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
94483: LD_ADDR_VAR 0 33
94487: PUSH
94488: LD_INT 2
94490: NEG
94491: PUSH
94492: LD_INT 1
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 3
94501: NEG
94502: PUSH
94503: LD_INT 0
94505: PUSH
94506: EMPTY
94507: LIST
94508: LIST
94509: PUSH
94510: LD_INT 3
94512: NEG
94513: PUSH
94514: LD_INT 1
94516: NEG
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: PUSH
94522: LD_INT 3
94524: NEG
94525: PUSH
94526: LD_INT 1
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: PUSH
94533: LD_INT 4
94535: NEG
94536: PUSH
94537: LD_INT 0
94539: PUSH
94540: EMPTY
94541: LIST
94542: LIST
94543: PUSH
94544: LD_INT 4
94546: NEG
94547: PUSH
94548: LD_INT 1
94550: NEG
94551: PUSH
94552: EMPTY
94553: LIST
94554: LIST
94555: PUSH
94556: LD_INT 4
94558: NEG
94559: PUSH
94560: LD_INT 1
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: PUSH
94567: LD_INT 5
94569: NEG
94570: PUSH
94571: LD_INT 0
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: LD_INT 5
94580: NEG
94581: PUSH
94582: LD_INT 1
94584: NEG
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: PUSH
94590: LD_INT 5
94592: NEG
94593: PUSH
94594: LD_INT 1
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: LD_INT 6
94603: NEG
94604: PUSH
94605: LD_INT 0
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 6
94614: NEG
94615: PUSH
94616: LD_INT 1
94618: NEG
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: LIST
94637: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
94638: LD_ADDR_VAR 0 34
94642: PUSH
94643: LD_INT 2
94645: NEG
94646: PUSH
94647: LD_INT 3
94649: NEG
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 3
94657: NEG
94658: PUSH
94659: LD_INT 2
94661: NEG
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 3
94669: NEG
94670: PUSH
94671: LD_INT 3
94673: NEG
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: PUSH
94679: LD_INT 3
94681: NEG
94682: PUSH
94683: LD_INT 4
94685: NEG
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 4
94693: NEG
94694: PUSH
94695: LD_INT 3
94697: NEG
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: LD_INT 4
94705: NEG
94706: PUSH
94707: LD_INT 4
94709: NEG
94710: PUSH
94711: EMPTY
94712: LIST
94713: LIST
94714: PUSH
94715: LD_INT 4
94717: NEG
94718: PUSH
94719: LD_INT 5
94721: NEG
94722: PUSH
94723: EMPTY
94724: LIST
94725: LIST
94726: PUSH
94727: LD_INT 5
94729: NEG
94730: PUSH
94731: LD_INT 4
94733: NEG
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: PUSH
94739: LD_INT 5
94741: NEG
94742: PUSH
94743: LD_INT 5
94745: NEG
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: PUSH
94751: LD_INT 5
94753: NEG
94754: PUSH
94755: LD_INT 6
94757: NEG
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 6
94765: NEG
94766: PUSH
94767: LD_INT 5
94769: NEG
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PUSH
94775: LD_INT 6
94777: NEG
94778: PUSH
94779: LD_INT 6
94781: NEG
94782: PUSH
94783: EMPTY
94784: LIST
94785: LIST
94786: PUSH
94787: EMPTY
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
94801: LD_ADDR_VAR 0 41
94805: PUSH
94806: LD_INT 0
94808: PUSH
94809: LD_INT 2
94811: NEG
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: PUSH
94817: LD_INT 1
94819: NEG
94820: PUSH
94821: LD_INT 3
94823: NEG
94824: PUSH
94825: EMPTY
94826: LIST
94827: LIST
94828: PUSH
94829: LD_INT 1
94831: PUSH
94832: LD_INT 2
94834: NEG
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: LIST
94844: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
94845: LD_ADDR_VAR 0 42
94849: PUSH
94850: LD_INT 2
94852: PUSH
94853: LD_INT 0
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 2
94862: PUSH
94863: LD_INT 1
94865: NEG
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PUSH
94871: LD_INT 3
94873: PUSH
94874: LD_INT 1
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: LIST
94885: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
94886: LD_ADDR_VAR 0 43
94890: PUSH
94891: LD_INT 2
94893: PUSH
94894: LD_INT 2
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: PUSH
94901: LD_INT 3
94903: PUSH
94904: LD_INT 2
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: PUSH
94911: LD_INT 2
94913: PUSH
94914: LD_INT 3
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: LIST
94925: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
94926: LD_ADDR_VAR 0 44
94930: PUSH
94931: LD_INT 0
94933: PUSH
94934: LD_INT 2
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: PUSH
94941: LD_INT 1
94943: PUSH
94944: LD_INT 3
94946: PUSH
94947: EMPTY
94948: LIST
94949: LIST
94950: PUSH
94951: LD_INT 1
94953: NEG
94954: PUSH
94955: LD_INT 2
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: LIST
94966: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
94967: LD_ADDR_VAR 0 45
94971: PUSH
94972: LD_INT 2
94974: NEG
94975: PUSH
94976: LD_INT 0
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: PUSH
94983: LD_INT 2
94985: NEG
94986: PUSH
94987: LD_INT 1
94989: PUSH
94990: EMPTY
94991: LIST
94992: LIST
94993: PUSH
94994: LD_INT 3
94996: NEG
94997: PUSH
94998: LD_INT 1
95000: NEG
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: LIST
95010: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
95011: LD_ADDR_VAR 0 46
95015: PUSH
95016: LD_INT 2
95018: NEG
95019: PUSH
95020: LD_INT 2
95022: NEG
95023: PUSH
95024: EMPTY
95025: LIST
95026: LIST
95027: PUSH
95028: LD_INT 2
95030: NEG
95031: PUSH
95032: LD_INT 3
95034: NEG
95035: PUSH
95036: EMPTY
95037: LIST
95038: LIST
95039: PUSH
95040: LD_INT 3
95042: NEG
95043: PUSH
95044: LD_INT 2
95046: NEG
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: LIST
95056: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95057: LD_ADDR_VAR 0 47
95061: PUSH
95062: LD_INT 2
95064: NEG
95065: PUSH
95066: LD_INT 3
95068: NEG
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 1
95076: NEG
95077: PUSH
95078: LD_INT 3
95080: NEG
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: EMPTY
95087: LIST
95088: LIST
95089: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95090: LD_ADDR_VAR 0 48
95094: PUSH
95095: LD_INT 1
95097: PUSH
95098: LD_INT 2
95100: NEG
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PUSH
95106: LD_INT 2
95108: PUSH
95109: LD_INT 1
95111: NEG
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: EMPTY
95118: LIST
95119: LIST
95120: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95121: LD_ADDR_VAR 0 49
95125: PUSH
95126: LD_INT 3
95128: PUSH
95129: LD_INT 1
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 3
95138: PUSH
95139: LD_INT 2
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95150: LD_ADDR_VAR 0 50
95154: PUSH
95155: LD_INT 2
95157: PUSH
95158: LD_INT 3
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 1
95167: PUSH
95168: LD_INT 3
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95179: LD_ADDR_VAR 0 51
95183: PUSH
95184: LD_INT 1
95186: NEG
95187: PUSH
95188: LD_INT 2
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: PUSH
95195: LD_INT 2
95197: NEG
95198: PUSH
95199: LD_INT 1
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95210: LD_ADDR_VAR 0 52
95214: PUSH
95215: LD_INT 3
95217: NEG
95218: PUSH
95219: LD_INT 1
95221: NEG
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 3
95229: NEG
95230: PUSH
95231: LD_INT 2
95233: NEG
95234: PUSH
95235: EMPTY
95236: LIST
95237: LIST
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95243: LD_ADDR_VAR 0 53
95247: PUSH
95248: LD_INT 1
95250: NEG
95251: PUSH
95252: LD_INT 3
95254: NEG
95255: PUSH
95256: EMPTY
95257: LIST
95258: LIST
95259: PUSH
95260: LD_INT 0
95262: PUSH
95263: LD_INT 3
95265: NEG
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: PUSH
95271: LD_INT 1
95273: PUSH
95274: LD_INT 2
95276: NEG
95277: PUSH
95278: EMPTY
95279: LIST
95280: LIST
95281: PUSH
95282: EMPTY
95283: LIST
95284: LIST
95285: LIST
95286: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95287: LD_ADDR_VAR 0 54
95291: PUSH
95292: LD_INT 2
95294: PUSH
95295: LD_INT 1
95297: NEG
95298: PUSH
95299: EMPTY
95300: LIST
95301: LIST
95302: PUSH
95303: LD_INT 3
95305: PUSH
95306: LD_INT 0
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 3
95315: PUSH
95316: LD_INT 1
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: LIST
95327: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95328: LD_ADDR_VAR 0 55
95332: PUSH
95333: LD_INT 3
95335: PUSH
95336: LD_INT 2
95338: PUSH
95339: EMPTY
95340: LIST
95341: LIST
95342: PUSH
95343: LD_INT 3
95345: PUSH
95346: LD_INT 3
95348: PUSH
95349: EMPTY
95350: LIST
95351: LIST
95352: PUSH
95353: LD_INT 2
95355: PUSH
95356: LD_INT 3
95358: PUSH
95359: EMPTY
95360: LIST
95361: LIST
95362: PUSH
95363: EMPTY
95364: LIST
95365: LIST
95366: LIST
95367: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95368: LD_ADDR_VAR 0 56
95372: PUSH
95373: LD_INT 1
95375: PUSH
95376: LD_INT 3
95378: PUSH
95379: EMPTY
95380: LIST
95381: LIST
95382: PUSH
95383: LD_INT 0
95385: PUSH
95386: LD_INT 3
95388: PUSH
95389: EMPTY
95390: LIST
95391: LIST
95392: PUSH
95393: LD_INT 1
95395: NEG
95396: PUSH
95397: LD_INT 2
95399: PUSH
95400: EMPTY
95401: LIST
95402: LIST
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: LIST
95408: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95409: LD_ADDR_VAR 0 57
95413: PUSH
95414: LD_INT 2
95416: NEG
95417: PUSH
95418: LD_INT 1
95420: PUSH
95421: EMPTY
95422: LIST
95423: LIST
95424: PUSH
95425: LD_INT 3
95427: NEG
95428: PUSH
95429: LD_INT 0
95431: PUSH
95432: EMPTY
95433: LIST
95434: LIST
95435: PUSH
95436: LD_INT 3
95438: NEG
95439: PUSH
95440: LD_INT 1
95442: NEG
95443: PUSH
95444: EMPTY
95445: LIST
95446: LIST
95447: PUSH
95448: EMPTY
95449: LIST
95450: LIST
95451: LIST
95452: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95453: LD_ADDR_VAR 0 58
95457: PUSH
95458: LD_INT 2
95460: NEG
95461: PUSH
95462: LD_INT 3
95464: NEG
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PUSH
95470: LD_INT 3
95472: NEG
95473: PUSH
95474: LD_INT 2
95476: NEG
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: PUSH
95482: LD_INT 3
95484: NEG
95485: PUSH
95486: LD_INT 3
95488: NEG
95489: PUSH
95490: EMPTY
95491: LIST
95492: LIST
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: LIST
95498: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
95499: LD_ADDR_VAR 0 59
95503: PUSH
95504: LD_INT 1
95506: NEG
95507: PUSH
95508: LD_INT 2
95510: NEG
95511: PUSH
95512: EMPTY
95513: LIST
95514: LIST
95515: PUSH
95516: LD_INT 0
95518: PUSH
95519: LD_INT 2
95521: NEG
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: PUSH
95527: LD_INT 1
95529: PUSH
95530: LD_INT 1
95532: NEG
95533: PUSH
95534: EMPTY
95535: LIST
95536: LIST
95537: PUSH
95538: EMPTY
95539: LIST
95540: LIST
95541: LIST
95542: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
95543: LD_ADDR_VAR 0 60
95547: PUSH
95548: LD_INT 1
95550: PUSH
95551: LD_INT 1
95553: NEG
95554: PUSH
95555: EMPTY
95556: LIST
95557: LIST
95558: PUSH
95559: LD_INT 2
95561: PUSH
95562: LD_INT 0
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: PUSH
95569: LD_INT 2
95571: PUSH
95572: LD_INT 1
95574: PUSH
95575: EMPTY
95576: LIST
95577: LIST
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: LIST
95583: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
95584: LD_ADDR_VAR 0 61
95588: PUSH
95589: LD_INT 2
95591: PUSH
95592: LD_INT 1
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: PUSH
95599: LD_INT 2
95601: PUSH
95602: LD_INT 2
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: PUSH
95609: LD_INT 1
95611: PUSH
95612: LD_INT 2
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: LIST
95623: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
95624: LD_ADDR_VAR 0 62
95628: PUSH
95629: LD_INT 1
95631: PUSH
95632: LD_INT 2
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 0
95641: PUSH
95642: LD_INT 2
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: LD_INT 1
95651: NEG
95652: PUSH
95653: LD_INT 1
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: LIST
95664: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95665: LD_ADDR_VAR 0 63
95669: PUSH
95670: LD_INT 1
95672: NEG
95673: PUSH
95674: LD_INT 1
95676: PUSH
95677: EMPTY
95678: LIST
95679: LIST
95680: PUSH
95681: LD_INT 2
95683: NEG
95684: PUSH
95685: LD_INT 0
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: PUSH
95692: LD_INT 2
95694: NEG
95695: PUSH
95696: LD_INT 1
95698: NEG
95699: PUSH
95700: EMPTY
95701: LIST
95702: LIST
95703: PUSH
95704: EMPTY
95705: LIST
95706: LIST
95707: LIST
95708: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95709: LD_ADDR_VAR 0 64
95713: PUSH
95714: LD_INT 1
95716: NEG
95717: PUSH
95718: LD_INT 2
95720: NEG
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 2
95728: NEG
95729: PUSH
95730: LD_INT 1
95732: NEG
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: PUSH
95738: LD_INT 2
95740: NEG
95741: PUSH
95742: LD_INT 2
95744: NEG
95745: PUSH
95746: EMPTY
95747: LIST
95748: LIST
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: LIST
95754: ST_TO_ADDR
// end ; 2 :
95755: GO 99021
95757: LD_INT 2
95759: DOUBLE
95760: EQUAL
95761: IFTRUE 95765
95763: GO 99020
95765: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
95766: LD_ADDR_VAR 0 29
95770: PUSH
95771: LD_INT 4
95773: PUSH
95774: LD_INT 0
95776: PUSH
95777: EMPTY
95778: LIST
95779: LIST
95780: PUSH
95781: LD_INT 4
95783: PUSH
95784: LD_INT 1
95786: NEG
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 5
95794: PUSH
95795: LD_INT 0
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 5
95804: PUSH
95805: LD_INT 1
95807: PUSH
95808: EMPTY
95809: LIST
95810: LIST
95811: PUSH
95812: LD_INT 4
95814: PUSH
95815: LD_INT 1
95817: PUSH
95818: EMPTY
95819: LIST
95820: LIST
95821: PUSH
95822: LD_INT 3
95824: PUSH
95825: LD_INT 0
95827: PUSH
95828: EMPTY
95829: LIST
95830: LIST
95831: PUSH
95832: LD_INT 3
95834: PUSH
95835: LD_INT 1
95837: NEG
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: PUSH
95843: LD_INT 3
95845: PUSH
95846: LD_INT 2
95848: NEG
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 5
95856: PUSH
95857: LD_INT 2
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: LD_INT 3
95866: PUSH
95867: LD_INT 3
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: PUSH
95874: LD_INT 3
95876: PUSH
95877: LD_INT 2
95879: PUSH
95880: EMPTY
95881: LIST
95882: LIST
95883: PUSH
95884: LD_INT 4
95886: PUSH
95887: LD_INT 3
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 4
95896: PUSH
95897: LD_INT 4
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PUSH
95904: LD_INT 3
95906: PUSH
95907: LD_INT 4
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: PUSH
95914: LD_INT 2
95916: PUSH
95917: LD_INT 3
95919: PUSH
95920: EMPTY
95921: LIST
95922: LIST
95923: PUSH
95924: LD_INT 2
95926: PUSH
95927: LD_INT 2
95929: PUSH
95930: EMPTY
95931: LIST
95932: LIST
95933: PUSH
95934: LD_INT 4
95936: PUSH
95937: LD_INT 2
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: PUSH
95944: LD_INT 2
95946: PUSH
95947: LD_INT 4
95949: PUSH
95950: EMPTY
95951: LIST
95952: LIST
95953: PUSH
95954: LD_INT 0
95956: PUSH
95957: LD_INT 4
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 0
95966: PUSH
95967: LD_INT 3
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: PUSH
95974: LD_INT 1
95976: PUSH
95977: LD_INT 4
95979: PUSH
95980: EMPTY
95981: LIST
95982: LIST
95983: PUSH
95984: LD_INT 1
95986: PUSH
95987: LD_INT 5
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PUSH
95994: LD_INT 0
95996: PUSH
95997: LD_INT 5
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PUSH
96004: LD_INT 1
96006: NEG
96007: PUSH
96008: LD_INT 4
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: PUSH
96015: LD_INT 1
96017: NEG
96018: PUSH
96019: LD_INT 3
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: PUSH
96026: LD_INT 2
96028: PUSH
96029: LD_INT 5
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: LD_INT 2
96038: NEG
96039: PUSH
96040: LD_INT 3
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: PUSH
96047: LD_INT 3
96049: NEG
96050: PUSH
96051: LD_INT 0
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 3
96060: NEG
96061: PUSH
96062: LD_INT 1
96064: NEG
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: LD_INT 2
96072: NEG
96073: PUSH
96074: LD_INT 0
96076: PUSH
96077: EMPTY
96078: LIST
96079: LIST
96080: PUSH
96081: LD_INT 2
96083: NEG
96084: PUSH
96085: LD_INT 1
96087: PUSH
96088: EMPTY
96089: LIST
96090: LIST
96091: PUSH
96092: LD_INT 3
96094: NEG
96095: PUSH
96096: LD_INT 1
96098: PUSH
96099: EMPTY
96100: LIST
96101: LIST
96102: PUSH
96103: LD_INT 4
96105: NEG
96106: PUSH
96107: LD_INT 0
96109: PUSH
96110: EMPTY
96111: LIST
96112: LIST
96113: PUSH
96114: LD_INT 4
96116: NEG
96117: PUSH
96118: LD_INT 1
96120: NEG
96121: PUSH
96122: EMPTY
96123: LIST
96124: LIST
96125: PUSH
96126: LD_INT 4
96128: NEG
96129: PUSH
96130: LD_INT 2
96132: NEG
96133: PUSH
96134: EMPTY
96135: LIST
96136: LIST
96137: PUSH
96138: LD_INT 2
96140: NEG
96141: PUSH
96142: LD_INT 2
96144: PUSH
96145: EMPTY
96146: LIST
96147: LIST
96148: PUSH
96149: LD_INT 4
96151: NEG
96152: PUSH
96153: LD_INT 4
96155: NEG
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PUSH
96161: LD_INT 4
96163: NEG
96164: PUSH
96165: LD_INT 5
96167: NEG
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 3
96175: NEG
96176: PUSH
96177: LD_INT 4
96179: NEG
96180: PUSH
96181: EMPTY
96182: LIST
96183: LIST
96184: PUSH
96185: LD_INT 3
96187: NEG
96188: PUSH
96189: LD_INT 3
96191: NEG
96192: PUSH
96193: EMPTY
96194: LIST
96195: LIST
96196: PUSH
96197: LD_INT 4
96199: NEG
96200: PUSH
96201: LD_INT 3
96203: NEG
96204: PUSH
96205: EMPTY
96206: LIST
96207: LIST
96208: PUSH
96209: LD_INT 5
96211: NEG
96212: PUSH
96213: LD_INT 4
96215: NEG
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PUSH
96221: LD_INT 5
96223: NEG
96224: PUSH
96225: LD_INT 5
96227: NEG
96228: PUSH
96229: EMPTY
96230: LIST
96231: LIST
96232: PUSH
96233: LD_INT 3
96235: NEG
96236: PUSH
96237: LD_INT 5
96239: NEG
96240: PUSH
96241: EMPTY
96242: LIST
96243: LIST
96244: PUSH
96245: LD_INT 5
96247: NEG
96248: PUSH
96249: LD_INT 3
96251: NEG
96252: PUSH
96253: EMPTY
96254: LIST
96255: LIST
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96304: LD_ADDR_VAR 0 30
96308: PUSH
96309: LD_INT 4
96311: PUSH
96312: LD_INT 4
96314: PUSH
96315: EMPTY
96316: LIST
96317: LIST
96318: PUSH
96319: LD_INT 4
96321: PUSH
96322: LD_INT 3
96324: PUSH
96325: EMPTY
96326: LIST
96327: LIST
96328: PUSH
96329: LD_INT 5
96331: PUSH
96332: LD_INT 4
96334: PUSH
96335: EMPTY
96336: LIST
96337: LIST
96338: PUSH
96339: LD_INT 5
96341: PUSH
96342: LD_INT 5
96344: PUSH
96345: EMPTY
96346: LIST
96347: LIST
96348: PUSH
96349: LD_INT 4
96351: PUSH
96352: LD_INT 5
96354: PUSH
96355: EMPTY
96356: LIST
96357: LIST
96358: PUSH
96359: LD_INT 3
96361: PUSH
96362: LD_INT 4
96364: PUSH
96365: EMPTY
96366: LIST
96367: LIST
96368: PUSH
96369: LD_INT 3
96371: PUSH
96372: LD_INT 3
96374: PUSH
96375: EMPTY
96376: LIST
96377: LIST
96378: PUSH
96379: LD_INT 5
96381: PUSH
96382: LD_INT 3
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: PUSH
96389: LD_INT 3
96391: PUSH
96392: LD_INT 5
96394: PUSH
96395: EMPTY
96396: LIST
96397: LIST
96398: PUSH
96399: LD_INT 0
96401: PUSH
96402: LD_INT 3
96404: PUSH
96405: EMPTY
96406: LIST
96407: LIST
96408: PUSH
96409: LD_INT 0
96411: PUSH
96412: LD_INT 2
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: PUSH
96419: LD_INT 1
96421: PUSH
96422: LD_INT 3
96424: PUSH
96425: EMPTY
96426: LIST
96427: LIST
96428: PUSH
96429: LD_INT 1
96431: PUSH
96432: LD_INT 4
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: PUSH
96439: LD_INT 0
96441: PUSH
96442: LD_INT 4
96444: PUSH
96445: EMPTY
96446: LIST
96447: LIST
96448: PUSH
96449: LD_INT 1
96451: NEG
96452: PUSH
96453: LD_INT 3
96455: PUSH
96456: EMPTY
96457: LIST
96458: LIST
96459: PUSH
96460: LD_INT 1
96462: NEG
96463: PUSH
96464: LD_INT 2
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 2
96473: PUSH
96474: LD_INT 4
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: PUSH
96481: LD_INT 2
96483: NEG
96484: PUSH
96485: LD_INT 2
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: PUSH
96492: LD_INT 4
96494: NEG
96495: PUSH
96496: LD_INT 0
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PUSH
96503: LD_INT 4
96505: NEG
96506: PUSH
96507: LD_INT 1
96509: NEG
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: LD_INT 3
96517: NEG
96518: PUSH
96519: LD_INT 0
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: PUSH
96526: LD_INT 3
96528: NEG
96529: PUSH
96530: LD_INT 1
96532: PUSH
96533: EMPTY
96534: LIST
96535: LIST
96536: PUSH
96537: LD_INT 4
96539: NEG
96540: PUSH
96541: LD_INT 1
96543: PUSH
96544: EMPTY
96545: LIST
96546: LIST
96547: PUSH
96548: LD_INT 5
96550: NEG
96551: PUSH
96552: LD_INT 0
96554: PUSH
96555: EMPTY
96556: LIST
96557: LIST
96558: PUSH
96559: LD_INT 5
96561: NEG
96562: PUSH
96563: LD_INT 1
96565: NEG
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: PUSH
96571: LD_INT 5
96573: NEG
96574: PUSH
96575: LD_INT 2
96577: NEG
96578: PUSH
96579: EMPTY
96580: LIST
96581: LIST
96582: PUSH
96583: LD_INT 3
96585: NEG
96586: PUSH
96587: LD_INT 2
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PUSH
96594: LD_INT 3
96596: NEG
96597: PUSH
96598: LD_INT 3
96600: NEG
96601: PUSH
96602: EMPTY
96603: LIST
96604: LIST
96605: PUSH
96606: LD_INT 3
96608: NEG
96609: PUSH
96610: LD_INT 4
96612: NEG
96613: PUSH
96614: EMPTY
96615: LIST
96616: LIST
96617: PUSH
96618: LD_INT 2
96620: NEG
96621: PUSH
96622: LD_INT 3
96624: NEG
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: LD_INT 2
96632: NEG
96633: PUSH
96634: LD_INT 2
96636: NEG
96637: PUSH
96638: EMPTY
96639: LIST
96640: LIST
96641: PUSH
96642: LD_INT 3
96644: NEG
96645: PUSH
96646: LD_INT 2
96648: NEG
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: PUSH
96654: LD_INT 4
96656: NEG
96657: PUSH
96658: LD_INT 3
96660: NEG
96661: PUSH
96662: EMPTY
96663: LIST
96664: LIST
96665: PUSH
96666: LD_INT 4
96668: NEG
96669: PUSH
96670: LD_INT 4
96672: NEG
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: PUSH
96678: LD_INT 2
96680: NEG
96681: PUSH
96682: LD_INT 4
96684: NEG
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PUSH
96690: LD_INT 4
96692: NEG
96693: PUSH
96694: LD_INT 2
96696: NEG
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PUSH
96702: LD_INT 0
96704: PUSH
96705: LD_INT 4
96707: NEG
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: LD_INT 0
96715: PUSH
96716: LD_INT 5
96718: NEG
96719: PUSH
96720: EMPTY
96721: LIST
96722: LIST
96723: PUSH
96724: LD_INT 1
96726: PUSH
96727: LD_INT 4
96729: NEG
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: LD_INT 1
96737: PUSH
96738: LD_INT 3
96740: NEG
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 0
96748: PUSH
96749: LD_INT 3
96751: NEG
96752: PUSH
96753: EMPTY
96754: LIST
96755: LIST
96756: PUSH
96757: LD_INT 1
96759: NEG
96760: PUSH
96761: LD_INT 4
96763: NEG
96764: PUSH
96765: EMPTY
96766: LIST
96767: LIST
96768: PUSH
96769: LD_INT 1
96771: NEG
96772: PUSH
96773: LD_INT 5
96775: NEG
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: LD_INT 2
96783: PUSH
96784: LD_INT 3
96786: NEG
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PUSH
96792: LD_INT 2
96794: NEG
96795: PUSH
96796: LD_INT 5
96798: NEG
96799: PUSH
96800: EMPTY
96801: LIST
96802: LIST
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
96851: LD_ADDR_VAR 0 31
96855: PUSH
96856: LD_INT 0
96858: PUSH
96859: LD_INT 4
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 0
96868: PUSH
96869: LD_INT 3
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PUSH
96876: LD_INT 1
96878: PUSH
96879: LD_INT 4
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 1
96888: PUSH
96889: LD_INT 5
96891: PUSH
96892: EMPTY
96893: LIST
96894: LIST
96895: PUSH
96896: LD_INT 0
96898: PUSH
96899: LD_INT 5
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: LD_INT 1
96908: NEG
96909: PUSH
96910: LD_INT 4
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: PUSH
96917: LD_INT 1
96919: NEG
96920: PUSH
96921: LD_INT 3
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 2
96930: PUSH
96931: LD_INT 5
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 2
96940: NEG
96941: PUSH
96942: LD_INT 3
96944: PUSH
96945: EMPTY
96946: LIST
96947: LIST
96948: PUSH
96949: LD_INT 3
96951: NEG
96952: PUSH
96953: LD_INT 0
96955: PUSH
96956: EMPTY
96957: LIST
96958: LIST
96959: PUSH
96960: LD_INT 3
96962: NEG
96963: PUSH
96964: LD_INT 1
96966: NEG
96967: PUSH
96968: EMPTY
96969: LIST
96970: LIST
96971: PUSH
96972: LD_INT 2
96974: NEG
96975: PUSH
96976: LD_INT 0
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: LD_INT 2
96985: NEG
96986: PUSH
96987: LD_INT 1
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PUSH
96994: LD_INT 3
96996: NEG
96997: PUSH
96998: LD_INT 1
97000: PUSH
97001: EMPTY
97002: LIST
97003: LIST
97004: PUSH
97005: LD_INT 4
97007: NEG
97008: PUSH
97009: LD_INT 0
97011: PUSH
97012: EMPTY
97013: LIST
97014: LIST
97015: PUSH
97016: LD_INT 4
97018: NEG
97019: PUSH
97020: LD_INT 1
97022: NEG
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: PUSH
97028: LD_INT 4
97030: NEG
97031: PUSH
97032: LD_INT 2
97034: NEG
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: PUSH
97040: LD_INT 2
97042: NEG
97043: PUSH
97044: LD_INT 2
97046: PUSH
97047: EMPTY
97048: LIST
97049: LIST
97050: PUSH
97051: LD_INT 4
97053: NEG
97054: PUSH
97055: LD_INT 4
97057: NEG
97058: PUSH
97059: EMPTY
97060: LIST
97061: LIST
97062: PUSH
97063: LD_INT 4
97065: NEG
97066: PUSH
97067: LD_INT 5
97069: NEG
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: PUSH
97075: LD_INT 3
97077: NEG
97078: PUSH
97079: LD_INT 4
97081: NEG
97082: PUSH
97083: EMPTY
97084: LIST
97085: LIST
97086: PUSH
97087: LD_INT 3
97089: NEG
97090: PUSH
97091: LD_INT 3
97093: NEG
97094: PUSH
97095: EMPTY
97096: LIST
97097: LIST
97098: PUSH
97099: LD_INT 4
97101: NEG
97102: PUSH
97103: LD_INT 3
97105: NEG
97106: PUSH
97107: EMPTY
97108: LIST
97109: LIST
97110: PUSH
97111: LD_INT 5
97113: NEG
97114: PUSH
97115: LD_INT 4
97117: NEG
97118: PUSH
97119: EMPTY
97120: LIST
97121: LIST
97122: PUSH
97123: LD_INT 5
97125: NEG
97126: PUSH
97127: LD_INT 5
97129: NEG
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PUSH
97135: LD_INT 3
97137: NEG
97138: PUSH
97139: LD_INT 5
97141: NEG
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 5
97149: NEG
97150: PUSH
97151: LD_INT 3
97153: NEG
97154: PUSH
97155: EMPTY
97156: LIST
97157: LIST
97158: PUSH
97159: LD_INT 0
97161: PUSH
97162: LD_INT 3
97164: NEG
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: PUSH
97170: LD_INT 0
97172: PUSH
97173: LD_INT 4
97175: NEG
97176: PUSH
97177: EMPTY
97178: LIST
97179: LIST
97180: PUSH
97181: LD_INT 1
97183: PUSH
97184: LD_INT 3
97186: NEG
97187: PUSH
97188: EMPTY
97189: LIST
97190: LIST
97191: PUSH
97192: LD_INT 1
97194: PUSH
97195: LD_INT 2
97197: NEG
97198: PUSH
97199: EMPTY
97200: LIST
97201: LIST
97202: PUSH
97203: LD_INT 0
97205: PUSH
97206: LD_INT 2
97208: NEG
97209: PUSH
97210: EMPTY
97211: LIST
97212: LIST
97213: PUSH
97214: LD_INT 1
97216: NEG
97217: PUSH
97218: LD_INT 3
97220: NEG
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: PUSH
97226: LD_INT 1
97228: NEG
97229: PUSH
97230: LD_INT 4
97232: NEG
97233: PUSH
97234: EMPTY
97235: LIST
97236: LIST
97237: PUSH
97238: LD_INT 2
97240: PUSH
97241: LD_INT 2
97243: NEG
97244: PUSH
97245: EMPTY
97246: LIST
97247: LIST
97248: PUSH
97249: LD_INT 2
97251: NEG
97252: PUSH
97253: LD_INT 4
97255: NEG
97256: PUSH
97257: EMPTY
97258: LIST
97259: LIST
97260: PUSH
97261: LD_INT 4
97263: PUSH
97264: LD_INT 0
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: PUSH
97271: LD_INT 4
97273: PUSH
97274: LD_INT 1
97276: NEG
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: PUSH
97282: LD_INT 5
97284: PUSH
97285: LD_INT 0
97287: PUSH
97288: EMPTY
97289: LIST
97290: LIST
97291: PUSH
97292: LD_INT 5
97294: PUSH
97295: LD_INT 1
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: PUSH
97302: LD_INT 4
97304: PUSH
97305: LD_INT 1
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: PUSH
97312: LD_INT 3
97314: PUSH
97315: LD_INT 0
97317: PUSH
97318: EMPTY
97319: LIST
97320: LIST
97321: PUSH
97322: LD_INT 3
97324: PUSH
97325: LD_INT 1
97327: NEG
97328: PUSH
97329: EMPTY
97330: LIST
97331: LIST
97332: PUSH
97333: LD_INT 3
97335: PUSH
97336: LD_INT 2
97338: NEG
97339: PUSH
97340: EMPTY
97341: LIST
97342: LIST
97343: PUSH
97344: LD_INT 5
97346: PUSH
97347: LD_INT 2
97349: PUSH
97350: EMPTY
97351: LIST
97352: LIST
97353: PUSH
97354: EMPTY
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: LIST
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97401: LD_ADDR_VAR 0 32
97405: PUSH
97406: LD_INT 4
97408: NEG
97409: PUSH
97410: LD_INT 0
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 4
97419: NEG
97420: PUSH
97421: LD_INT 1
97423: NEG
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: PUSH
97429: LD_INT 3
97431: NEG
97432: PUSH
97433: LD_INT 0
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_INT 3
97442: NEG
97443: PUSH
97444: LD_INT 1
97446: PUSH
97447: EMPTY
97448: LIST
97449: LIST
97450: PUSH
97451: LD_INT 4
97453: NEG
97454: PUSH
97455: LD_INT 1
97457: PUSH
97458: EMPTY
97459: LIST
97460: LIST
97461: PUSH
97462: LD_INT 5
97464: NEG
97465: PUSH
97466: LD_INT 0
97468: PUSH
97469: EMPTY
97470: LIST
97471: LIST
97472: PUSH
97473: LD_INT 5
97475: NEG
97476: PUSH
97477: LD_INT 1
97479: NEG
97480: PUSH
97481: EMPTY
97482: LIST
97483: LIST
97484: PUSH
97485: LD_INT 5
97487: NEG
97488: PUSH
97489: LD_INT 2
97491: NEG
97492: PUSH
97493: EMPTY
97494: LIST
97495: LIST
97496: PUSH
97497: LD_INT 3
97499: NEG
97500: PUSH
97501: LD_INT 2
97503: PUSH
97504: EMPTY
97505: LIST
97506: LIST
97507: PUSH
97508: LD_INT 3
97510: NEG
97511: PUSH
97512: LD_INT 3
97514: NEG
97515: PUSH
97516: EMPTY
97517: LIST
97518: LIST
97519: PUSH
97520: LD_INT 3
97522: NEG
97523: PUSH
97524: LD_INT 4
97526: NEG
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: PUSH
97532: LD_INT 2
97534: NEG
97535: PUSH
97536: LD_INT 3
97538: NEG
97539: PUSH
97540: EMPTY
97541: LIST
97542: LIST
97543: PUSH
97544: LD_INT 2
97546: NEG
97547: PUSH
97548: LD_INT 2
97550: NEG
97551: PUSH
97552: EMPTY
97553: LIST
97554: LIST
97555: PUSH
97556: LD_INT 3
97558: NEG
97559: PUSH
97560: LD_INT 2
97562: NEG
97563: PUSH
97564: EMPTY
97565: LIST
97566: LIST
97567: PUSH
97568: LD_INT 4
97570: NEG
97571: PUSH
97572: LD_INT 3
97574: NEG
97575: PUSH
97576: EMPTY
97577: LIST
97578: LIST
97579: PUSH
97580: LD_INT 4
97582: NEG
97583: PUSH
97584: LD_INT 4
97586: NEG
97587: PUSH
97588: EMPTY
97589: LIST
97590: LIST
97591: PUSH
97592: LD_INT 2
97594: NEG
97595: PUSH
97596: LD_INT 4
97598: NEG
97599: PUSH
97600: EMPTY
97601: LIST
97602: LIST
97603: PUSH
97604: LD_INT 4
97606: NEG
97607: PUSH
97608: LD_INT 2
97610: NEG
97611: PUSH
97612: EMPTY
97613: LIST
97614: LIST
97615: PUSH
97616: LD_INT 0
97618: PUSH
97619: LD_INT 4
97621: NEG
97622: PUSH
97623: EMPTY
97624: LIST
97625: LIST
97626: PUSH
97627: LD_INT 0
97629: PUSH
97630: LD_INT 5
97632: NEG
97633: PUSH
97634: EMPTY
97635: LIST
97636: LIST
97637: PUSH
97638: LD_INT 1
97640: PUSH
97641: LD_INT 4
97643: NEG
97644: PUSH
97645: EMPTY
97646: LIST
97647: LIST
97648: PUSH
97649: LD_INT 1
97651: PUSH
97652: LD_INT 3
97654: NEG
97655: PUSH
97656: EMPTY
97657: LIST
97658: LIST
97659: PUSH
97660: LD_INT 0
97662: PUSH
97663: LD_INT 3
97665: NEG
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: PUSH
97671: LD_INT 1
97673: NEG
97674: PUSH
97675: LD_INT 4
97677: NEG
97678: PUSH
97679: EMPTY
97680: LIST
97681: LIST
97682: PUSH
97683: LD_INT 1
97685: NEG
97686: PUSH
97687: LD_INT 5
97689: NEG
97690: PUSH
97691: EMPTY
97692: LIST
97693: LIST
97694: PUSH
97695: LD_INT 2
97697: PUSH
97698: LD_INT 3
97700: NEG
97701: PUSH
97702: EMPTY
97703: LIST
97704: LIST
97705: PUSH
97706: LD_INT 2
97708: NEG
97709: PUSH
97710: LD_INT 5
97712: NEG
97713: PUSH
97714: EMPTY
97715: LIST
97716: LIST
97717: PUSH
97718: LD_INT 3
97720: PUSH
97721: LD_INT 0
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: PUSH
97728: LD_INT 3
97730: PUSH
97731: LD_INT 1
97733: NEG
97734: PUSH
97735: EMPTY
97736: LIST
97737: LIST
97738: PUSH
97739: LD_INT 4
97741: PUSH
97742: LD_INT 0
97744: PUSH
97745: EMPTY
97746: LIST
97747: LIST
97748: PUSH
97749: LD_INT 4
97751: PUSH
97752: LD_INT 1
97754: PUSH
97755: EMPTY
97756: LIST
97757: LIST
97758: PUSH
97759: LD_INT 3
97761: PUSH
97762: LD_INT 1
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: PUSH
97769: LD_INT 2
97771: PUSH
97772: LD_INT 0
97774: PUSH
97775: EMPTY
97776: LIST
97777: LIST
97778: PUSH
97779: LD_INT 2
97781: PUSH
97782: LD_INT 1
97784: NEG
97785: PUSH
97786: EMPTY
97787: LIST
97788: LIST
97789: PUSH
97790: LD_INT 2
97792: PUSH
97793: LD_INT 2
97795: NEG
97796: PUSH
97797: EMPTY
97798: LIST
97799: LIST
97800: PUSH
97801: LD_INT 4
97803: PUSH
97804: LD_INT 2
97806: PUSH
97807: EMPTY
97808: LIST
97809: LIST
97810: PUSH
97811: LD_INT 4
97813: PUSH
97814: LD_INT 4
97816: PUSH
97817: EMPTY
97818: LIST
97819: LIST
97820: PUSH
97821: LD_INT 4
97823: PUSH
97824: LD_INT 3
97826: PUSH
97827: EMPTY
97828: LIST
97829: LIST
97830: PUSH
97831: LD_INT 5
97833: PUSH
97834: LD_INT 4
97836: PUSH
97837: EMPTY
97838: LIST
97839: LIST
97840: PUSH
97841: LD_INT 5
97843: PUSH
97844: LD_INT 5
97846: PUSH
97847: EMPTY
97848: LIST
97849: LIST
97850: PUSH
97851: LD_INT 4
97853: PUSH
97854: LD_INT 5
97856: PUSH
97857: EMPTY
97858: LIST
97859: LIST
97860: PUSH
97861: LD_INT 3
97863: PUSH
97864: LD_INT 4
97866: PUSH
97867: EMPTY
97868: LIST
97869: LIST
97870: PUSH
97871: LD_INT 3
97873: PUSH
97874: LD_INT 3
97876: PUSH
97877: EMPTY
97878: LIST
97879: LIST
97880: PUSH
97881: LD_INT 5
97883: PUSH
97884: LD_INT 3
97886: PUSH
97887: EMPTY
97888: LIST
97889: LIST
97890: PUSH
97891: LD_INT 3
97893: PUSH
97894: LD_INT 5
97896: PUSH
97897: EMPTY
97898: LIST
97899: LIST
97900: PUSH
97901: EMPTY
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
97948: LD_ADDR_VAR 0 33
97952: PUSH
97953: LD_INT 4
97955: NEG
97956: PUSH
97957: LD_INT 4
97959: NEG
97960: PUSH
97961: EMPTY
97962: LIST
97963: LIST
97964: PUSH
97965: LD_INT 4
97967: NEG
97968: PUSH
97969: LD_INT 5
97971: NEG
97972: PUSH
97973: EMPTY
97974: LIST
97975: LIST
97976: PUSH
97977: LD_INT 3
97979: NEG
97980: PUSH
97981: LD_INT 4
97983: NEG
97984: PUSH
97985: EMPTY
97986: LIST
97987: LIST
97988: PUSH
97989: LD_INT 3
97991: NEG
97992: PUSH
97993: LD_INT 3
97995: NEG
97996: PUSH
97997: EMPTY
97998: LIST
97999: LIST
98000: PUSH
98001: LD_INT 4
98003: NEG
98004: PUSH
98005: LD_INT 3
98007: NEG
98008: PUSH
98009: EMPTY
98010: LIST
98011: LIST
98012: PUSH
98013: LD_INT 5
98015: NEG
98016: PUSH
98017: LD_INT 4
98019: NEG
98020: PUSH
98021: EMPTY
98022: LIST
98023: LIST
98024: PUSH
98025: LD_INT 5
98027: NEG
98028: PUSH
98029: LD_INT 5
98031: NEG
98032: PUSH
98033: EMPTY
98034: LIST
98035: LIST
98036: PUSH
98037: LD_INT 3
98039: NEG
98040: PUSH
98041: LD_INT 5
98043: NEG
98044: PUSH
98045: EMPTY
98046: LIST
98047: LIST
98048: PUSH
98049: LD_INT 5
98051: NEG
98052: PUSH
98053: LD_INT 3
98055: NEG
98056: PUSH
98057: EMPTY
98058: LIST
98059: LIST
98060: PUSH
98061: LD_INT 0
98063: PUSH
98064: LD_INT 3
98066: NEG
98067: PUSH
98068: EMPTY
98069: LIST
98070: LIST
98071: PUSH
98072: LD_INT 0
98074: PUSH
98075: LD_INT 4
98077: NEG
98078: PUSH
98079: EMPTY
98080: LIST
98081: LIST
98082: PUSH
98083: LD_INT 1
98085: PUSH
98086: LD_INT 3
98088: NEG
98089: PUSH
98090: EMPTY
98091: LIST
98092: LIST
98093: PUSH
98094: LD_INT 1
98096: PUSH
98097: LD_INT 2
98099: NEG
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: PUSH
98105: LD_INT 0
98107: PUSH
98108: LD_INT 2
98110: NEG
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: PUSH
98116: LD_INT 1
98118: NEG
98119: PUSH
98120: LD_INT 3
98122: NEG
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 1
98130: NEG
98131: PUSH
98132: LD_INT 4
98134: NEG
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PUSH
98140: LD_INT 2
98142: PUSH
98143: LD_INT 2
98145: NEG
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: PUSH
98151: LD_INT 2
98153: NEG
98154: PUSH
98155: LD_INT 4
98157: NEG
98158: PUSH
98159: EMPTY
98160: LIST
98161: LIST
98162: PUSH
98163: LD_INT 4
98165: PUSH
98166: LD_INT 0
98168: PUSH
98169: EMPTY
98170: LIST
98171: LIST
98172: PUSH
98173: LD_INT 4
98175: PUSH
98176: LD_INT 1
98178: NEG
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: PUSH
98184: LD_INT 5
98186: PUSH
98187: LD_INT 0
98189: PUSH
98190: EMPTY
98191: LIST
98192: LIST
98193: PUSH
98194: LD_INT 5
98196: PUSH
98197: LD_INT 1
98199: PUSH
98200: EMPTY
98201: LIST
98202: LIST
98203: PUSH
98204: LD_INT 4
98206: PUSH
98207: LD_INT 1
98209: PUSH
98210: EMPTY
98211: LIST
98212: LIST
98213: PUSH
98214: LD_INT 3
98216: PUSH
98217: LD_INT 0
98219: PUSH
98220: EMPTY
98221: LIST
98222: LIST
98223: PUSH
98224: LD_INT 3
98226: PUSH
98227: LD_INT 1
98229: NEG
98230: PUSH
98231: EMPTY
98232: LIST
98233: LIST
98234: PUSH
98235: LD_INT 3
98237: PUSH
98238: LD_INT 2
98240: NEG
98241: PUSH
98242: EMPTY
98243: LIST
98244: LIST
98245: PUSH
98246: LD_INT 5
98248: PUSH
98249: LD_INT 2
98251: PUSH
98252: EMPTY
98253: LIST
98254: LIST
98255: PUSH
98256: LD_INT 3
98258: PUSH
98259: LD_INT 3
98261: PUSH
98262: EMPTY
98263: LIST
98264: LIST
98265: PUSH
98266: LD_INT 3
98268: PUSH
98269: LD_INT 2
98271: PUSH
98272: EMPTY
98273: LIST
98274: LIST
98275: PUSH
98276: LD_INT 4
98278: PUSH
98279: LD_INT 3
98281: PUSH
98282: EMPTY
98283: LIST
98284: LIST
98285: PUSH
98286: LD_INT 4
98288: PUSH
98289: LD_INT 4
98291: PUSH
98292: EMPTY
98293: LIST
98294: LIST
98295: PUSH
98296: LD_INT 3
98298: PUSH
98299: LD_INT 4
98301: PUSH
98302: EMPTY
98303: LIST
98304: LIST
98305: PUSH
98306: LD_INT 2
98308: PUSH
98309: LD_INT 3
98311: PUSH
98312: EMPTY
98313: LIST
98314: LIST
98315: PUSH
98316: LD_INT 2
98318: PUSH
98319: LD_INT 2
98321: PUSH
98322: EMPTY
98323: LIST
98324: LIST
98325: PUSH
98326: LD_INT 4
98328: PUSH
98329: LD_INT 2
98331: PUSH
98332: EMPTY
98333: LIST
98334: LIST
98335: PUSH
98336: LD_INT 2
98338: PUSH
98339: LD_INT 4
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: PUSH
98346: LD_INT 0
98348: PUSH
98349: LD_INT 4
98351: PUSH
98352: EMPTY
98353: LIST
98354: LIST
98355: PUSH
98356: LD_INT 0
98358: PUSH
98359: LD_INT 3
98361: PUSH
98362: EMPTY
98363: LIST
98364: LIST
98365: PUSH
98366: LD_INT 1
98368: PUSH
98369: LD_INT 4
98371: PUSH
98372: EMPTY
98373: LIST
98374: LIST
98375: PUSH
98376: LD_INT 1
98378: PUSH
98379: LD_INT 5
98381: PUSH
98382: EMPTY
98383: LIST
98384: LIST
98385: PUSH
98386: LD_INT 0
98388: PUSH
98389: LD_INT 5
98391: PUSH
98392: EMPTY
98393: LIST
98394: LIST
98395: PUSH
98396: LD_INT 1
98398: NEG
98399: PUSH
98400: LD_INT 4
98402: PUSH
98403: EMPTY
98404: LIST
98405: LIST
98406: PUSH
98407: LD_INT 1
98409: NEG
98410: PUSH
98411: LD_INT 3
98413: PUSH
98414: EMPTY
98415: LIST
98416: LIST
98417: PUSH
98418: LD_INT 2
98420: PUSH
98421: LD_INT 5
98423: PUSH
98424: EMPTY
98425: LIST
98426: LIST
98427: PUSH
98428: LD_INT 2
98430: NEG
98431: PUSH
98432: LD_INT 3
98434: PUSH
98435: EMPTY
98436: LIST
98437: LIST
98438: PUSH
98439: EMPTY
98440: LIST
98441: LIST
98442: LIST
98443: LIST
98444: LIST
98445: LIST
98446: LIST
98447: LIST
98448: LIST
98449: LIST
98450: LIST
98451: LIST
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: LIST
98459: LIST
98460: LIST
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: LIST
98469: LIST
98470: LIST
98471: LIST
98472: LIST
98473: LIST
98474: LIST
98475: LIST
98476: LIST
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
98486: LD_ADDR_VAR 0 34
98490: PUSH
98491: LD_INT 0
98493: PUSH
98494: LD_INT 4
98496: NEG
98497: PUSH
98498: EMPTY
98499: LIST
98500: LIST
98501: PUSH
98502: LD_INT 0
98504: PUSH
98505: LD_INT 5
98507: NEG
98508: PUSH
98509: EMPTY
98510: LIST
98511: LIST
98512: PUSH
98513: LD_INT 1
98515: PUSH
98516: LD_INT 4
98518: NEG
98519: PUSH
98520: EMPTY
98521: LIST
98522: LIST
98523: PUSH
98524: LD_INT 1
98526: PUSH
98527: LD_INT 3
98529: NEG
98530: PUSH
98531: EMPTY
98532: LIST
98533: LIST
98534: PUSH
98535: LD_INT 0
98537: PUSH
98538: LD_INT 3
98540: NEG
98541: PUSH
98542: EMPTY
98543: LIST
98544: LIST
98545: PUSH
98546: LD_INT 1
98548: NEG
98549: PUSH
98550: LD_INT 4
98552: NEG
98553: PUSH
98554: EMPTY
98555: LIST
98556: LIST
98557: PUSH
98558: LD_INT 1
98560: NEG
98561: PUSH
98562: LD_INT 5
98564: NEG
98565: PUSH
98566: EMPTY
98567: LIST
98568: LIST
98569: PUSH
98570: LD_INT 2
98572: PUSH
98573: LD_INT 3
98575: NEG
98576: PUSH
98577: EMPTY
98578: LIST
98579: LIST
98580: PUSH
98581: LD_INT 2
98583: NEG
98584: PUSH
98585: LD_INT 5
98587: NEG
98588: PUSH
98589: EMPTY
98590: LIST
98591: LIST
98592: PUSH
98593: LD_INT 3
98595: PUSH
98596: LD_INT 0
98598: PUSH
98599: EMPTY
98600: LIST
98601: LIST
98602: PUSH
98603: LD_INT 3
98605: PUSH
98606: LD_INT 1
98608: NEG
98609: PUSH
98610: EMPTY
98611: LIST
98612: LIST
98613: PUSH
98614: LD_INT 4
98616: PUSH
98617: LD_INT 0
98619: PUSH
98620: EMPTY
98621: LIST
98622: LIST
98623: PUSH
98624: LD_INT 4
98626: PUSH
98627: LD_INT 1
98629: PUSH
98630: EMPTY
98631: LIST
98632: LIST
98633: PUSH
98634: LD_INT 3
98636: PUSH
98637: LD_INT 1
98639: PUSH
98640: EMPTY
98641: LIST
98642: LIST
98643: PUSH
98644: LD_INT 2
98646: PUSH
98647: LD_INT 0
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: PUSH
98654: LD_INT 2
98656: PUSH
98657: LD_INT 1
98659: NEG
98660: PUSH
98661: EMPTY
98662: LIST
98663: LIST
98664: PUSH
98665: LD_INT 2
98667: PUSH
98668: LD_INT 2
98670: NEG
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: PUSH
98676: LD_INT 4
98678: PUSH
98679: LD_INT 2
98681: PUSH
98682: EMPTY
98683: LIST
98684: LIST
98685: PUSH
98686: LD_INT 4
98688: PUSH
98689: LD_INT 4
98691: PUSH
98692: EMPTY
98693: LIST
98694: LIST
98695: PUSH
98696: LD_INT 4
98698: PUSH
98699: LD_INT 3
98701: PUSH
98702: EMPTY
98703: LIST
98704: LIST
98705: PUSH
98706: LD_INT 5
98708: PUSH
98709: LD_INT 4
98711: PUSH
98712: EMPTY
98713: LIST
98714: LIST
98715: PUSH
98716: LD_INT 5
98718: PUSH
98719: LD_INT 5
98721: PUSH
98722: EMPTY
98723: LIST
98724: LIST
98725: PUSH
98726: LD_INT 4
98728: PUSH
98729: LD_INT 5
98731: PUSH
98732: EMPTY
98733: LIST
98734: LIST
98735: PUSH
98736: LD_INT 3
98738: PUSH
98739: LD_INT 4
98741: PUSH
98742: EMPTY
98743: LIST
98744: LIST
98745: PUSH
98746: LD_INT 3
98748: PUSH
98749: LD_INT 3
98751: PUSH
98752: EMPTY
98753: LIST
98754: LIST
98755: PUSH
98756: LD_INT 5
98758: PUSH
98759: LD_INT 3
98761: PUSH
98762: EMPTY
98763: LIST
98764: LIST
98765: PUSH
98766: LD_INT 3
98768: PUSH
98769: LD_INT 5
98771: PUSH
98772: EMPTY
98773: LIST
98774: LIST
98775: PUSH
98776: LD_INT 0
98778: PUSH
98779: LD_INT 3
98781: PUSH
98782: EMPTY
98783: LIST
98784: LIST
98785: PUSH
98786: LD_INT 0
98788: PUSH
98789: LD_INT 2
98791: PUSH
98792: EMPTY
98793: LIST
98794: LIST
98795: PUSH
98796: LD_INT 1
98798: PUSH
98799: LD_INT 3
98801: PUSH
98802: EMPTY
98803: LIST
98804: LIST
98805: PUSH
98806: LD_INT 1
98808: PUSH
98809: LD_INT 4
98811: PUSH
98812: EMPTY
98813: LIST
98814: LIST
98815: PUSH
98816: LD_INT 0
98818: PUSH
98819: LD_INT 4
98821: PUSH
98822: EMPTY
98823: LIST
98824: LIST
98825: PUSH
98826: LD_INT 1
98828: NEG
98829: PUSH
98830: LD_INT 3
98832: PUSH
98833: EMPTY
98834: LIST
98835: LIST
98836: PUSH
98837: LD_INT 1
98839: NEG
98840: PUSH
98841: LD_INT 2
98843: PUSH
98844: EMPTY
98845: LIST
98846: LIST
98847: PUSH
98848: LD_INT 2
98850: PUSH
98851: LD_INT 4
98853: PUSH
98854: EMPTY
98855: LIST
98856: LIST
98857: PUSH
98858: LD_INT 2
98860: NEG
98861: PUSH
98862: LD_INT 2
98864: PUSH
98865: EMPTY
98866: LIST
98867: LIST
98868: PUSH
98869: LD_INT 4
98871: NEG
98872: PUSH
98873: LD_INT 0
98875: PUSH
98876: EMPTY
98877: LIST
98878: LIST
98879: PUSH
98880: LD_INT 4
98882: NEG
98883: PUSH
98884: LD_INT 1
98886: NEG
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: PUSH
98892: LD_INT 3
98894: NEG
98895: PUSH
98896: LD_INT 0
98898: PUSH
98899: EMPTY
98900: LIST
98901: LIST
98902: PUSH
98903: LD_INT 3
98905: NEG
98906: PUSH
98907: LD_INT 1
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PUSH
98914: LD_INT 4
98916: NEG
98917: PUSH
98918: LD_INT 1
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PUSH
98925: LD_INT 5
98927: NEG
98928: PUSH
98929: LD_INT 0
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: PUSH
98936: LD_INT 5
98938: NEG
98939: PUSH
98940: LD_INT 1
98942: NEG
98943: PUSH
98944: EMPTY
98945: LIST
98946: LIST
98947: PUSH
98948: LD_INT 5
98950: NEG
98951: PUSH
98952: LD_INT 2
98954: NEG
98955: PUSH
98956: EMPTY
98957: LIST
98958: LIST
98959: PUSH
98960: LD_INT 3
98962: NEG
98963: PUSH
98964: LD_INT 2
98966: PUSH
98967: EMPTY
98968: LIST
98969: LIST
98970: PUSH
98971: EMPTY
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: LIST
98991: LIST
98992: LIST
98993: LIST
98994: LIST
98995: LIST
98996: LIST
98997: LIST
98998: LIST
98999: LIST
99000: LIST
99001: LIST
99002: LIST
99003: LIST
99004: LIST
99005: LIST
99006: LIST
99007: LIST
99008: LIST
99009: LIST
99010: LIST
99011: LIST
99012: LIST
99013: LIST
99014: LIST
99015: LIST
99016: LIST
99017: ST_TO_ADDR
// end ; end ;
99018: GO 99021
99020: POP
// case btype of b_depot , b_warehouse :
99021: LD_VAR 0 1
99025: PUSH
99026: LD_INT 0
99028: DOUBLE
99029: EQUAL
99030: IFTRUE 99040
99032: LD_INT 1
99034: DOUBLE
99035: EQUAL
99036: IFTRUE 99040
99038: GO 99241
99040: POP
// case nation of nation_american :
99041: LD_VAR 0 5
99045: PUSH
99046: LD_INT 1
99048: DOUBLE
99049: EQUAL
99050: IFTRUE 99054
99052: GO 99110
99054: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99055: LD_ADDR_VAR 0 9
99059: PUSH
99060: LD_VAR 0 11
99064: PUSH
99065: LD_VAR 0 12
99069: PUSH
99070: LD_VAR 0 13
99074: PUSH
99075: LD_VAR 0 14
99079: PUSH
99080: LD_VAR 0 15
99084: PUSH
99085: LD_VAR 0 16
99089: PUSH
99090: EMPTY
99091: LIST
99092: LIST
99093: LIST
99094: LIST
99095: LIST
99096: LIST
99097: PUSH
99098: LD_VAR 0 4
99102: PUSH
99103: LD_INT 1
99105: PLUS
99106: ARRAY
99107: ST_TO_ADDR
99108: GO 99239
99110: LD_INT 2
99112: DOUBLE
99113: EQUAL
99114: IFTRUE 99118
99116: GO 99174
99118: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99119: LD_ADDR_VAR 0 9
99123: PUSH
99124: LD_VAR 0 17
99128: PUSH
99129: LD_VAR 0 18
99133: PUSH
99134: LD_VAR 0 19
99138: PUSH
99139: LD_VAR 0 20
99143: PUSH
99144: LD_VAR 0 21
99148: PUSH
99149: LD_VAR 0 22
99153: PUSH
99154: EMPTY
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: PUSH
99162: LD_VAR 0 4
99166: PUSH
99167: LD_INT 1
99169: PLUS
99170: ARRAY
99171: ST_TO_ADDR
99172: GO 99239
99174: LD_INT 3
99176: DOUBLE
99177: EQUAL
99178: IFTRUE 99182
99180: GO 99238
99182: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99183: LD_ADDR_VAR 0 9
99187: PUSH
99188: LD_VAR 0 23
99192: PUSH
99193: LD_VAR 0 24
99197: PUSH
99198: LD_VAR 0 25
99202: PUSH
99203: LD_VAR 0 26
99207: PUSH
99208: LD_VAR 0 27
99212: PUSH
99213: LD_VAR 0 28
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: LIST
99222: LIST
99223: LIST
99224: LIST
99225: PUSH
99226: LD_VAR 0 4
99230: PUSH
99231: LD_INT 1
99233: PLUS
99234: ARRAY
99235: ST_TO_ADDR
99236: GO 99239
99238: POP
99239: GO 99794
99241: LD_INT 2
99243: DOUBLE
99244: EQUAL
99245: IFTRUE 99255
99247: LD_INT 3
99249: DOUBLE
99250: EQUAL
99251: IFTRUE 99255
99253: GO 99311
99255: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99256: LD_ADDR_VAR 0 9
99260: PUSH
99261: LD_VAR 0 29
99265: PUSH
99266: LD_VAR 0 30
99270: PUSH
99271: LD_VAR 0 31
99275: PUSH
99276: LD_VAR 0 32
99280: PUSH
99281: LD_VAR 0 33
99285: PUSH
99286: LD_VAR 0 34
99290: PUSH
99291: EMPTY
99292: LIST
99293: LIST
99294: LIST
99295: LIST
99296: LIST
99297: LIST
99298: PUSH
99299: LD_VAR 0 4
99303: PUSH
99304: LD_INT 1
99306: PLUS
99307: ARRAY
99308: ST_TO_ADDR
99309: GO 99794
99311: LD_INT 16
99313: DOUBLE
99314: EQUAL
99315: IFTRUE 99373
99317: LD_INT 17
99319: DOUBLE
99320: EQUAL
99321: IFTRUE 99373
99323: LD_INT 18
99325: DOUBLE
99326: EQUAL
99327: IFTRUE 99373
99329: LD_INT 19
99331: DOUBLE
99332: EQUAL
99333: IFTRUE 99373
99335: LD_INT 22
99337: DOUBLE
99338: EQUAL
99339: IFTRUE 99373
99341: LD_INT 20
99343: DOUBLE
99344: EQUAL
99345: IFTRUE 99373
99347: LD_INT 21
99349: DOUBLE
99350: EQUAL
99351: IFTRUE 99373
99353: LD_INT 23
99355: DOUBLE
99356: EQUAL
99357: IFTRUE 99373
99359: LD_INT 24
99361: DOUBLE
99362: EQUAL
99363: IFTRUE 99373
99365: LD_INT 25
99367: DOUBLE
99368: EQUAL
99369: IFTRUE 99373
99371: GO 99429
99373: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99374: LD_ADDR_VAR 0 9
99378: PUSH
99379: LD_VAR 0 35
99383: PUSH
99384: LD_VAR 0 36
99388: PUSH
99389: LD_VAR 0 37
99393: PUSH
99394: LD_VAR 0 38
99398: PUSH
99399: LD_VAR 0 39
99403: PUSH
99404: LD_VAR 0 40
99408: PUSH
99409: EMPTY
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: PUSH
99417: LD_VAR 0 4
99421: PUSH
99422: LD_INT 1
99424: PLUS
99425: ARRAY
99426: ST_TO_ADDR
99427: GO 99794
99429: LD_INT 6
99431: DOUBLE
99432: EQUAL
99433: IFTRUE 99485
99435: LD_INT 7
99437: DOUBLE
99438: EQUAL
99439: IFTRUE 99485
99441: LD_INT 8
99443: DOUBLE
99444: EQUAL
99445: IFTRUE 99485
99447: LD_INT 13
99449: DOUBLE
99450: EQUAL
99451: IFTRUE 99485
99453: LD_INT 12
99455: DOUBLE
99456: EQUAL
99457: IFTRUE 99485
99459: LD_INT 15
99461: DOUBLE
99462: EQUAL
99463: IFTRUE 99485
99465: LD_INT 11
99467: DOUBLE
99468: EQUAL
99469: IFTRUE 99485
99471: LD_INT 14
99473: DOUBLE
99474: EQUAL
99475: IFTRUE 99485
99477: LD_INT 10
99479: DOUBLE
99480: EQUAL
99481: IFTRUE 99485
99483: GO 99541
99485: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
99486: LD_ADDR_VAR 0 9
99490: PUSH
99491: LD_VAR 0 41
99495: PUSH
99496: LD_VAR 0 42
99500: PUSH
99501: LD_VAR 0 43
99505: PUSH
99506: LD_VAR 0 44
99510: PUSH
99511: LD_VAR 0 45
99515: PUSH
99516: LD_VAR 0 46
99520: PUSH
99521: EMPTY
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: PUSH
99529: LD_VAR 0 4
99533: PUSH
99534: LD_INT 1
99536: PLUS
99537: ARRAY
99538: ST_TO_ADDR
99539: GO 99794
99541: LD_INT 36
99543: DOUBLE
99544: EQUAL
99545: IFTRUE 99549
99547: GO 99605
99549: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
99550: LD_ADDR_VAR 0 9
99554: PUSH
99555: LD_VAR 0 47
99559: PUSH
99560: LD_VAR 0 48
99564: PUSH
99565: LD_VAR 0 49
99569: PUSH
99570: LD_VAR 0 50
99574: PUSH
99575: LD_VAR 0 51
99579: PUSH
99580: LD_VAR 0 52
99584: PUSH
99585: EMPTY
99586: LIST
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: PUSH
99593: LD_VAR 0 4
99597: PUSH
99598: LD_INT 1
99600: PLUS
99601: ARRAY
99602: ST_TO_ADDR
99603: GO 99794
99605: LD_INT 4
99607: DOUBLE
99608: EQUAL
99609: IFTRUE 99631
99611: LD_INT 5
99613: DOUBLE
99614: EQUAL
99615: IFTRUE 99631
99617: LD_INT 34
99619: DOUBLE
99620: EQUAL
99621: IFTRUE 99631
99623: LD_INT 37
99625: DOUBLE
99626: EQUAL
99627: IFTRUE 99631
99629: GO 99687
99631: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
99632: LD_ADDR_VAR 0 9
99636: PUSH
99637: LD_VAR 0 53
99641: PUSH
99642: LD_VAR 0 54
99646: PUSH
99647: LD_VAR 0 55
99651: PUSH
99652: LD_VAR 0 56
99656: PUSH
99657: LD_VAR 0 57
99661: PUSH
99662: LD_VAR 0 58
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: PUSH
99675: LD_VAR 0 4
99679: PUSH
99680: LD_INT 1
99682: PLUS
99683: ARRAY
99684: ST_TO_ADDR
99685: GO 99794
99687: LD_INT 31
99689: DOUBLE
99690: EQUAL
99691: IFTRUE 99737
99693: LD_INT 32
99695: DOUBLE
99696: EQUAL
99697: IFTRUE 99737
99699: LD_INT 33
99701: DOUBLE
99702: EQUAL
99703: IFTRUE 99737
99705: LD_INT 27
99707: DOUBLE
99708: EQUAL
99709: IFTRUE 99737
99711: LD_INT 26
99713: DOUBLE
99714: EQUAL
99715: IFTRUE 99737
99717: LD_INT 28
99719: DOUBLE
99720: EQUAL
99721: IFTRUE 99737
99723: LD_INT 29
99725: DOUBLE
99726: EQUAL
99727: IFTRUE 99737
99729: LD_INT 30
99731: DOUBLE
99732: EQUAL
99733: IFTRUE 99737
99735: GO 99793
99737: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
99738: LD_ADDR_VAR 0 9
99742: PUSH
99743: LD_VAR 0 59
99747: PUSH
99748: LD_VAR 0 60
99752: PUSH
99753: LD_VAR 0 61
99757: PUSH
99758: LD_VAR 0 62
99762: PUSH
99763: LD_VAR 0 63
99767: PUSH
99768: LD_VAR 0 64
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: LIST
99777: LIST
99778: LIST
99779: LIST
99780: PUSH
99781: LD_VAR 0 4
99785: PUSH
99786: LD_INT 1
99788: PLUS
99789: ARRAY
99790: ST_TO_ADDR
99791: GO 99794
99793: POP
// temp_list2 = [ ] ;
99794: LD_ADDR_VAR 0 10
99798: PUSH
99799: EMPTY
99800: ST_TO_ADDR
// for i in temp_list do
99801: LD_ADDR_VAR 0 8
99805: PUSH
99806: LD_VAR 0 9
99810: PUSH
99811: FOR_IN
99812: IFFALSE 99864
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
99814: LD_ADDR_VAR 0 10
99818: PUSH
99819: LD_VAR 0 10
99823: PUSH
99824: LD_VAR 0 8
99828: PUSH
99829: LD_INT 1
99831: ARRAY
99832: PUSH
99833: LD_VAR 0 2
99837: PLUS
99838: PUSH
99839: LD_VAR 0 8
99843: PUSH
99844: LD_INT 2
99846: ARRAY
99847: PUSH
99848: LD_VAR 0 3
99852: PLUS
99853: PUSH
99854: EMPTY
99855: LIST
99856: LIST
99857: PUSH
99858: EMPTY
99859: LIST
99860: ADD
99861: ST_TO_ADDR
99862: GO 99811
99864: POP
99865: POP
// result = temp_list2 ;
99866: LD_ADDR_VAR 0 7
99870: PUSH
99871: LD_VAR 0 10
99875: ST_TO_ADDR
// end ;
99876: LD_VAR 0 7
99880: RET
// export function EnemyInRange ( unit , dist ) ; begin
99881: LD_INT 0
99883: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
99884: LD_ADDR_VAR 0 3
99888: PUSH
99889: LD_VAR 0 1
99893: PPUSH
99894: CALL_OW 255
99898: PPUSH
99899: LD_VAR 0 1
99903: PPUSH
99904: CALL_OW 250
99908: PPUSH
99909: LD_VAR 0 1
99913: PPUSH
99914: CALL_OW 251
99918: PPUSH
99919: LD_VAR 0 2
99923: PPUSH
99924: CALL 73283 0 4
99928: PUSH
99929: LD_INT 4
99931: ARRAY
99932: ST_TO_ADDR
// end ;
99933: LD_VAR 0 3
99937: RET
// export function PlayerSeeMe ( unit ) ; begin
99938: LD_INT 0
99940: PPUSH
// result := See ( your_side , unit ) ;
99941: LD_ADDR_VAR 0 2
99945: PUSH
99946: LD_OWVAR 2
99950: PPUSH
99951: LD_VAR 0 1
99955: PPUSH
99956: CALL_OW 292
99960: ST_TO_ADDR
// end ;
99961: LD_VAR 0 2
99965: RET
// export function ReverseDir ( unit ) ; begin
99966: LD_INT 0
99968: PPUSH
// if not unit then
99969: LD_VAR 0 1
99973: NOT
99974: IFFALSE 99978
// exit ;
99976: GO 100001
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
99978: LD_ADDR_VAR 0 2
99982: PUSH
99983: LD_VAR 0 1
99987: PPUSH
99988: CALL_OW 254
99992: PUSH
99993: LD_INT 3
99995: PLUS
99996: PUSH
99997: LD_INT 6
99999: MOD
100000: ST_TO_ADDR
// end ;
100001: LD_VAR 0 2
100005: RET
// export function ReverseArray ( array ) ; var i ; begin
100006: LD_INT 0
100008: PPUSH
100009: PPUSH
// if not array then
100010: LD_VAR 0 1
100014: NOT
100015: IFFALSE 100019
// exit ;
100017: GO 100074
// result := [ ] ;
100019: LD_ADDR_VAR 0 2
100023: PUSH
100024: EMPTY
100025: ST_TO_ADDR
// for i := array downto 1 do
100026: LD_ADDR_VAR 0 3
100030: PUSH
100031: DOUBLE
100032: LD_VAR 0 1
100036: INC
100037: ST_TO_ADDR
100038: LD_INT 1
100040: PUSH
100041: FOR_DOWNTO
100042: IFFALSE 100072
// result := Join ( result , array [ i ] ) ;
100044: LD_ADDR_VAR 0 2
100048: PUSH
100049: LD_VAR 0 2
100053: PPUSH
100054: LD_VAR 0 1
100058: PUSH
100059: LD_VAR 0 3
100063: ARRAY
100064: PPUSH
100065: CALL 104699 0 2
100069: ST_TO_ADDR
100070: GO 100041
100072: POP
100073: POP
// end ;
100074: LD_VAR 0 2
100078: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100079: LD_INT 0
100081: PPUSH
100082: PPUSH
100083: PPUSH
100084: PPUSH
100085: PPUSH
100086: PPUSH
// if not unit or not hexes then
100087: LD_VAR 0 1
100091: NOT
100092: PUSH
100093: LD_VAR 0 2
100097: NOT
100098: OR
100099: IFFALSE 100103
// exit ;
100101: GO 100226
// dist := 9999 ;
100103: LD_ADDR_VAR 0 5
100107: PUSH
100108: LD_INT 9999
100110: ST_TO_ADDR
// for i = 1 to hexes do
100111: LD_ADDR_VAR 0 4
100115: PUSH
100116: DOUBLE
100117: LD_INT 1
100119: DEC
100120: ST_TO_ADDR
100121: LD_VAR 0 2
100125: PUSH
100126: FOR_TO
100127: IFFALSE 100214
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100129: LD_ADDR_VAR 0 6
100133: PUSH
100134: LD_VAR 0 1
100138: PPUSH
100139: LD_VAR 0 2
100143: PUSH
100144: LD_VAR 0 4
100148: ARRAY
100149: PUSH
100150: LD_INT 1
100152: ARRAY
100153: PPUSH
100154: LD_VAR 0 2
100158: PUSH
100159: LD_VAR 0 4
100163: ARRAY
100164: PUSH
100165: LD_INT 2
100167: ARRAY
100168: PPUSH
100169: CALL_OW 297
100173: ST_TO_ADDR
// if tdist < dist then
100174: LD_VAR 0 6
100178: PUSH
100179: LD_VAR 0 5
100183: LESS
100184: IFFALSE 100212
// begin hex := hexes [ i ] ;
100186: LD_ADDR_VAR 0 8
100190: PUSH
100191: LD_VAR 0 2
100195: PUSH
100196: LD_VAR 0 4
100200: ARRAY
100201: ST_TO_ADDR
// dist := tdist ;
100202: LD_ADDR_VAR 0 5
100206: PUSH
100207: LD_VAR 0 6
100211: ST_TO_ADDR
// end ; end ;
100212: GO 100126
100214: POP
100215: POP
// result := hex ;
100216: LD_ADDR_VAR 0 3
100220: PUSH
100221: LD_VAR 0 8
100225: ST_TO_ADDR
// end ;
100226: LD_VAR 0 3
100230: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100231: LD_INT 0
100233: PPUSH
100234: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100235: LD_VAR 0 1
100239: NOT
100240: PUSH
100241: LD_VAR 0 1
100245: PUSH
100246: LD_INT 21
100248: PUSH
100249: LD_INT 2
100251: PUSH
100252: EMPTY
100253: LIST
100254: LIST
100255: PUSH
100256: LD_INT 23
100258: PUSH
100259: LD_INT 2
100261: PUSH
100262: EMPTY
100263: LIST
100264: LIST
100265: PUSH
100266: EMPTY
100267: LIST
100268: LIST
100269: PPUSH
100270: CALL_OW 69
100274: IN
100275: NOT
100276: OR
100277: IFFALSE 100281
// exit ;
100279: GO 100328
// for i = 1 to 3 do
100281: LD_ADDR_VAR 0 3
100285: PUSH
100286: DOUBLE
100287: LD_INT 1
100289: DEC
100290: ST_TO_ADDR
100291: LD_INT 3
100293: PUSH
100294: FOR_TO
100295: IFFALSE 100326
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100297: LD_VAR 0 1
100301: PPUSH
100302: CALL_OW 250
100306: PPUSH
100307: LD_VAR 0 1
100311: PPUSH
100312: CALL_OW 251
100316: PPUSH
100317: LD_INT 1
100319: PPUSH
100320: CALL_OW 453
100324: GO 100294
100326: POP
100327: POP
// end ;
100328: LD_VAR 0 2
100332: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100333: LD_INT 0
100335: PPUSH
100336: PPUSH
100337: PPUSH
100338: PPUSH
100339: PPUSH
100340: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100341: LD_VAR 0 1
100345: NOT
100346: PUSH
100347: LD_VAR 0 2
100351: NOT
100352: OR
100353: PUSH
100354: LD_VAR 0 1
100358: PPUSH
100359: CALL_OW 314
100363: OR
100364: IFFALSE 100368
// exit ;
100366: GO 100809
// x := GetX ( enemy_unit ) ;
100368: LD_ADDR_VAR 0 7
100372: PUSH
100373: LD_VAR 0 2
100377: PPUSH
100378: CALL_OW 250
100382: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100383: LD_ADDR_VAR 0 8
100387: PUSH
100388: LD_VAR 0 2
100392: PPUSH
100393: CALL_OW 251
100397: ST_TO_ADDR
// if not x or not y then
100398: LD_VAR 0 7
100402: NOT
100403: PUSH
100404: LD_VAR 0 8
100408: NOT
100409: OR
100410: IFFALSE 100414
// exit ;
100412: GO 100809
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100414: LD_ADDR_VAR 0 6
100418: PUSH
100419: LD_VAR 0 7
100423: PPUSH
100424: LD_INT 0
100426: PPUSH
100427: LD_INT 4
100429: PPUSH
100430: CALL_OW 272
100434: PUSH
100435: LD_VAR 0 8
100439: PPUSH
100440: LD_INT 0
100442: PPUSH
100443: LD_INT 4
100445: PPUSH
100446: CALL_OW 273
100450: PUSH
100451: EMPTY
100452: LIST
100453: LIST
100454: PUSH
100455: LD_VAR 0 7
100459: PPUSH
100460: LD_INT 1
100462: PPUSH
100463: LD_INT 4
100465: PPUSH
100466: CALL_OW 272
100470: PUSH
100471: LD_VAR 0 8
100475: PPUSH
100476: LD_INT 1
100478: PPUSH
100479: LD_INT 4
100481: PPUSH
100482: CALL_OW 273
100486: PUSH
100487: EMPTY
100488: LIST
100489: LIST
100490: PUSH
100491: LD_VAR 0 7
100495: PPUSH
100496: LD_INT 2
100498: PPUSH
100499: LD_INT 4
100501: PPUSH
100502: CALL_OW 272
100506: PUSH
100507: LD_VAR 0 8
100511: PPUSH
100512: LD_INT 2
100514: PPUSH
100515: LD_INT 4
100517: PPUSH
100518: CALL_OW 273
100522: PUSH
100523: EMPTY
100524: LIST
100525: LIST
100526: PUSH
100527: LD_VAR 0 7
100531: PPUSH
100532: LD_INT 3
100534: PPUSH
100535: LD_INT 4
100537: PPUSH
100538: CALL_OW 272
100542: PUSH
100543: LD_VAR 0 8
100547: PPUSH
100548: LD_INT 3
100550: PPUSH
100551: LD_INT 4
100553: PPUSH
100554: CALL_OW 273
100558: PUSH
100559: EMPTY
100560: LIST
100561: LIST
100562: PUSH
100563: LD_VAR 0 7
100567: PPUSH
100568: LD_INT 4
100570: PPUSH
100571: LD_INT 4
100573: PPUSH
100574: CALL_OW 272
100578: PUSH
100579: LD_VAR 0 8
100583: PPUSH
100584: LD_INT 4
100586: PPUSH
100587: LD_INT 4
100589: PPUSH
100590: CALL_OW 273
100594: PUSH
100595: EMPTY
100596: LIST
100597: LIST
100598: PUSH
100599: LD_VAR 0 7
100603: PPUSH
100604: LD_INT 5
100606: PPUSH
100607: LD_INT 4
100609: PPUSH
100610: CALL_OW 272
100614: PUSH
100615: LD_VAR 0 8
100619: PPUSH
100620: LD_INT 5
100622: PPUSH
100623: LD_INT 4
100625: PPUSH
100626: CALL_OW 273
100630: PUSH
100631: EMPTY
100632: LIST
100633: LIST
100634: PUSH
100635: EMPTY
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: ST_TO_ADDR
// for i = tmp downto 1 do
100643: LD_ADDR_VAR 0 4
100647: PUSH
100648: DOUBLE
100649: LD_VAR 0 6
100653: INC
100654: ST_TO_ADDR
100655: LD_INT 1
100657: PUSH
100658: FOR_DOWNTO
100659: IFFALSE 100760
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
100661: LD_VAR 0 6
100665: PUSH
100666: LD_VAR 0 4
100670: ARRAY
100671: PUSH
100672: LD_INT 1
100674: ARRAY
100675: PPUSH
100676: LD_VAR 0 6
100680: PUSH
100681: LD_VAR 0 4
100685: ARRAY
100686: PUSH
100687: LD_INT 2
100689: ARRAY
100690: PPUSH
100691: CALL_OW 488
100695: NOT
100696: PUSH
100697: LD_VAR 0 6
100701: PUSH
100702: LD_VAR 0 4
100706: ARRAY
100707: PUSH
100708: LD_INT 1
100710: ARRAY
100711: PPUSH
100712: LD_VAR 0 6
100716: PUSH
100717: LD_VAR 0 4
100721: ARRAY
100722: PUSH
100723: LD_INT 2
100725: ARRAY
100726: PPUSH
100727: CALL_OW 428
100731: PUSH
100732: LD_INT 0
100734: NONEQUAL
100735: OR
100736: IFFALSE 100758
// tmp := Delete ( tmp , i ) ;
100738: LD_ADDR_VAR 0 6
100742: PUSH
100743: LD_VAR 0 6
100747: PPUSH
100748: LD_VAR 0 4
100752: PPUSH
100753: CALL_OW 3
100757: ST_TO_ADDR
100758: GO 100658
100760: POP
100761: POP
// j := GetClosestHex ( unit , tmp ) ;
100762: LD_ADDR_VAR 0 5
100766: PUSH
100767: LD_VAR 0 1
100771: PPUSH
100772: LD_VAR 0 6
100776: PPUSH
100777: CALL 100079 0 2
100781: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
100782: LD_VAR 0 1
100786: PPUSH
100787: LD_VAR 0 5
100791: PUSH
100792: LD_INT 1
100794: ARRAY
100795: PPUSH
100796: LD_VAR 0 5
100800: PUSH
100801: LD_INT 2
100803: ARRAY
100804: PPUSH
100805: CALL_OW 111
// end ;
100809: LD_VAR 0 3
100813: RET
// export function PrepareApemanSoldier ( ) ; begin
100814: LD_INT 0
100816: PPUSH
// uc_nation := 0 ;
100817: LD_ADDR_OWVAR 21
100821: PUSH
100822: LD_INT 0
100824: ST_TO_ADDR
// hc_sex := sex_male ;
100825: LD_ADDR_OWVAR 27
100829: PUSH
100830: LD_INT 1
100832: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
100833: LD_ADDR_OWVAR 28
100837: PUSH
100838: LD_INT 15
100840: ST_TO_ADDR
// hc_gallery :=  ;
100841: LD_ADDR_OWVAR 33
100845: PUSH
100846: LD_STRING 
100848: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
100849: LD_ADDR_OWVAR 31
100853: PUSH
100854: LD_INT 0
100856: PPUSH
100857: LD_INT 3
100859: PPUSH
100860: CALL_OW 12
100864: PUSH
100865: LD_INT 0
100867: PPUSH
100868: LD_INT 3
100870: PPUSH
100871: CALL_OW 12
100875: PUSH
100876: LD_INT 0
100878: PUSH
100879: LD_INT 0
100881: PUSH
100882: EMPTY
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: ST_TO_ADDR
// end ;
100888: LD_VAR 0 1
100892: RET
// export function PrepareApemanEngineer ( ) ; begin
100893: LD_INT 0
100895: PPUSH
// uc_nation := 0 ;
100896: LD_ADDR_OWVAR 21
100900: PUSH
100901: LD_INT 0
100903: ST_TO_ADDR
// hc_sex := sex_male ;
100904: LD_ADDR_OWVAR 27
100908: PUSH
100909: LD_INT 1
100911: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
100912: LD_ADDR_OWVAR 28
100916: PUSH
100917: LD_INT 16
100919: ST_TO_ADDR
// hc_gallery :=  ;
100920: LD_ADDR_OWVAR 33
100924: PUSH
100925: LD_STRING 
100927: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
100928: LD_ADDR_OWVAR 31
100932: PUSH
100933: LD_INT 0
100935: PPUSH
100936: LD_INT 3
100938: PPUSH
100939: CALL_OW 12
100943: PUSH
100944: LD_INT 0
100946: PPUSH
100947: LD_INT 3
100949: PPUSH
100950: CALL_OW 12
100954: PUSH
100955: LD_INT 0
100957: PUSH
100958: LD_INT 0
100960: PUSH
100961: EMPTY
100962: LIST
100963: LIST
100964: LIST
100965: LIST
100966: ST_TO_ADDR
// end ;
100967: LD_VAR 0 1
100971: RET
// export function PrepareApeman ( agressivity ) ; begin
100972: LD_INT 0
100974: PPUSH
// uc_side := 0 ;
100975: LD_ADDR_OWVAR 20
100979: PUSH
100980: LD_INT 0
100982: ST_TO_ADDR
// uc_nation := 0 ;
100983: LD_ADDR_OWVAR 21
100987: PUSH
100988: LD_INT 0
100990: ST_TO_ADDR
// hc_sex := sex_male ;
100991: LD_ADDR_OWVAR 27
100995: PUSH
100996: LD_INT 1
100998: ST_TO_ADDR
// hc_class := class_apeman ;
100999: LD_ADDR_OWVAR 28
101003: PUSH
101004: LD_INT 12
101006: ST_TO_ADDR
// hc_gallery :=  ;
101007: LD_ADDR_OWVAR 33
101011: PUSH
101012: LD_STRING 
101014: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101015: LD_ADDR_OWVAR 35
101019: PUSH
101020: LD_VAR 0 1
101024: NEG
101025: PPUSH
101026: LD_VAR 0 1
101030: PPUSH
101031: CALL_OW 12
101035: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101036: LD_ADDR_OWVAR 31
101040: PUSH
101041: LD_INT 0
101043: PPUSH
101044: LD_INT 3
101046: PPUSH
101047: CALL_OW 12
101051: PUSH
101052: LD_INT 0
101054: PPUSH
101055: LD_INT 3
101057: PPUSH
101058: CALL_OW 12
101062: PUSH
101063: LD_INT 0
101065: PUSH
101066: LD_INT 0
101068: PUSH
101069: EMPTY
101070: LIST
101071: LIST
101072: LIST
101073: LIST
101074: ST_TO_ADDR
// end ;
101075: LD_VAR 0 2
101079: RET
// export function PrepareTiger ( agressivity ) ; begin
101080: LD_INT 0
101082: PPUSH
// uc_side := 0 ;
101083: LD_ADDR_OWVAR 20
101087: PUSH
101088: LD_INT 0
101090: ST_TO_ADDR
// uc_nation := 0 ;
101091: LD_ADDR_OWVAR 21
101095: PUSH
101096: LD_INT 0
101098: ST_TO_ADDR
// hc_class := class_tiger ;
101099: LD_ADDR_OWVAR 28
101103: PUSH
101104: LD_INT 14
101106: ST_TO_ADDR
// hc_gallery :=  ;
101107: LD_ADDR_OWVAR 33
101111: PUSH
101112: LD_STRING 
101114: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101115: LD_ADDR_OWVAR 35
101119: PUSH
101120: LD_VAR 0 1
101124: NEG
101125: PPUSH
101126: LD_VAR 0 1
101130: PPUSH
101131: CALL_OW 12
101135: ST_TO_ADDR
// end ;
101136: LD_VAR 0 2
101140: RET
// export function PrepareEnchidna ( ) ; begin
101141: LD_INT 0
101143: PPUSH
// uc_side := 0 ;
101144: LD_ADDR_OWVAR 20
101148: PUSH
101149: LD_INT 0
101151: ST_TO_ADDR
// uc_nation := 0 ;
101152: LD_ADDR_OWVAR 21
101156: PUSH
101157: LD_INT 0
101159: ST_TO_ADDR
// hc_class := class_baggie ;
101160: LD_ADDR_OWVAR 28
101164: PUSH
101165: LD_INT 13
101167: ST_TO_ADDR
// hc_gallery :=  ;
101168: LD_ADDR_OWVAR 33
101172: PUSH
101173: LD_STRING 
101175: ST_TO_ADDR
// end ;
101176: LD_VAR 0 1
101180: RET
// export function PrepareFrog ( ) ; begin
101181: LD_INT 0
101183: PPUSH
// uc_side := 0 ;
101184: LD_ADDR_OWVAR 20
101188: PUSH
101189: LD_INT 0
101191: ST_TO_ADDR
// uc_nation := 0 ;
101192: LD_ADDR_OWVAR 21
101196: PUSH
101197: LD_INT 0
101199: ST_TO_ADDR
// hc_class := class_frog ;
101200: LD_ADDR_OWVAR 28
101204: PUSH
101205: LD_INT 19
101207: ST_TO_ADDR
// hc_gallery :=  ;
101208: LD_ADDR_OWVAR 33
101212: PUSH
101213: LD_STRING 
101215: ST_TO_ADDR
// end ;
101216: LD_VAR 0 1
101220: RET
// export function PrepareFish ( ) ; begin
101221: LD_INT 0
101223: PPUSH
// uc_side := 0 ;
101224: LD_ADDR_OWVAR 20
101228: PUSH
101229: LD_INT 0
101231: ST_TO_ADDR
// uc_nation := 0 ;
101232: LD_ADDR_OWVAR 21
101236: PUSH
101237: LD_INT 0
101239: ST_TO_ADDR
// hc_class := class_fish ;
101240: LD_ADDR_OWVAR 28
101244: PUSH
101245: LD_INT 20
101247: ST_TO_ADDR
// hc_gallery :=  ;
101248: LD_ADDR_OWVAR 33
101252: PUSH
101253: LD_STRING 
101255: ST_TO_ADDR
// end ;
101256: LD_VAR 0 1
101260: RET
// export function PrepareBird ( ) ; begin
101261: LD_INT 0
101263: PPUSH
// uc_side := 0 ;
101264: LD_ADDR_OWVAR 20
101268: PUSH
101269: LD_INT 0
101271: ST_TO_ADDR
// uc_nation := 0 ;
101272: LD_ADDR_OWVAR 21
101276: PUSH
101277: LD_INT 0
101279: ST_TO_ADDR
// hc_class := class_phororhacos ;
101280: LD_ADDR_OWVAR 28
101284: PUSH
101285: LD_INT 18
101287: ST_TO_ADDR
// hc_gallery :=  ;
101288: LD_ADDR_OWVAR 33
101292: PUSH
101293: LD_STRING 
101295: ST_TO_ADDR
// end ;
101296: LD_VAR 0 1
101300: RET
// export function PrepareHorse ( ) ; begin
101301: LD_INT 0
101303: PPUSH
// uc_side := 0 ;
101304: LD_ADDR_OWVAR 20
101308: PUSH
101309: LD_INT 0
101311: ST_TO_ADDR
// uc_nation := 0 ;
101312: LD_ADDR_OWVAR 21
101316: PUSH
101317: LD_INT 0
101319: ST_TO_ADDR
// hc_class := class_horse ;
101320: LD_ADDR_OWVAR 28
101324: PUSH
101325: LD_INT 21
101327: ST_TO_ADDR
// hc_gallery :=  ;
101328: LD_ADDR_OWVAR 33
101332: PUSH
101333: LD_STRING 
101335: ST_TO_ADDR
// end ;
101336: LD_VAR 0 1
101340: RET
// export function PrepareMastodont ( ) ; begin
101341: LD_INT 0
101343: PPUSH
// uc_side := 0 ;
101344: LD_ADDR_OWVAR 20
101348: PUSH
101349: LD_INT 0
101351: ST_TO_ADDR
// uc_nation := 0 ;
101352: LD_ADDR_OWVAR 21
101356: PUSH
101357: LD_INT 0
101359: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101360: LD_ADDR_OWVAR 37
101364: PUSH
101365: LD_INT 31
101367: ST_TO_ADDR
// vc_control := control_rider ;
101368: LD_ADDR_OWVAR 38
101372: PUSH
101373: LD_INT 4
101375: ST_TO_ADDR
// end ;
101376: LD_VAR 0 1
101380: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101381: LD_INT 0
101383: PPUSH
101384: PPUSH
101385: PPUSH
// uc_side = 0 ;
101386: LD_ADDR_OWVAR 20
101390: PUSH
101391: LD_INT 0
101393: ST_TO_ADDR
// uc_nation = 0 ;
101394: LD_ADDR_OWVAR 21
101398: PUSH
101399: LD_INT 0
101401: ST_TO_ADDR
// InitHc_All ( ) ;
101402: CALL_OW 584
// InitVc ;
101406: CALL_OW 20
// if mastodonts then
101410: LD_VAR 0 6
101414: IFFALSE 101481
// for i = 1 to mastodonts do
101416: LD_ADDR_VAR 0 11
101420: PUSH
101421: DOUBLE
101422: LD_INT 1
101424: DEC
101425: ST_TO_ADDR
101426: LD_VAR 0 6
101430: PUSH
101431: FOR_TO
101432: IFFALSE 101479
// begin vc_chassis := 31 ;
101434: LD_ADDR_OWVAR 37
101438: PUSH
101439: LD_INT 31
101441: ST_TO_ADDR
// vc_control := control_rider ;
101442: LD_ADDR_OWVAR 38
101446: PUSH
101447: LD_INT 4
101449: ST_TO_ADDR
// animal := CreateVehicle ;
101450: LD_ADDR_VAR 0 12
101454: PUSH
101455: CALL_OW 45
101459: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101460: LD_VAR 0 12
101464: PPUSH
101465: LD_VAR 0 8
101469: PPUSH
101470: LD_INT 0
101472: PPUSH
101473: CALL 103616 0 3
// end ;
101477: GO 101431
101479: POP
101480: POP
// if horses then
101481: LD_VAR 0 5
101485: IFFALSE 101552
// for i = 1 to horses do
101487: LD_ADDR_VAR 0 11
101491: PUSH
101492: DOUBLE
101493: LD_INT 1
101495: DEC
101496: ST_TO_ADDR
101497: LD_VAR 0 5
101501: PUSH
101502: FOR_TO
101503: IFFALSE 101550
// begin hc_class := 21 ;
101505: LD_ADDR_OWVAR 28
101509: PUSH
101510: LD_INT 21
101512: ST_TO_ADDR
// hc_gallery :=  ;
101513: LD_ADDR_OWVAR 33
101517: PUSH
101518: LD_STRING 
101520: ST_TO_ADDR
// animal := CreateHuman ;
101521: LD_ADDR_VAR 0 12
101525: PUSH
101526: CALL_OW 44
101530: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101531: LD_VAR 0 12
101535: PPUSH
101536: LD_VAR 0 8
101540: PPUSH
101541: LD_INT 0
101543: PPUSH
101544: CALL 103616 0 3
// end ;
101548: GO 101502
101550: POP
101551: POP
// if birds then
101552: LD_VAR 0 1
101556: IFFALSE 101623
// for i = 1 to birds do
101558: LD_ADDR_VAR 0 11
101562: PUSH
101563: DOUBLE
101564: LD_INT 1
101566: DEC
101567: ST_TO_ADDR
101568: LD_VAR 0 1
101572: PUSH
101573: FOR_TO
101574: IFFALSE 101621
// begin hc_class = 18 ;
101576: LD_ADDR_OWVAR 28
101580: PUSH
101581: LD_INT 18
101583: ST_TO_ADDR
// hc_gallery =  ;
101584: LD_ADDR_OWVAR 33
101588: PUSH
101589: LD_STRING 
101591: ST_TO_ADDR
// animal := CreateHuman ;
101592: LD_ADDR_VAR 0 12
101596: PUSH
101597: CALL_OW 44
101601: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101602: LD_VAR 0 12
101606: PPUSH
101607: LD_VAR 0 8
101611: PPUSH
101612: LD_INT 0
101614: PPUSH
101615: CALL 103616 0 3
// end ;
101619: GO 101573
101621: POP
101622: POP
// if tigers then
101623: LD_VAR 0 2
101627: IFFALSE 101711
// for i = 1 to tigers do
101629: LD_ADDR_VAR 0 11
101633: PUSH
101634: DOUBLE
101635: LD_INT 1
101637: DEC
101638: ST_TO_ADDR
101639: LD_VAR 0 2
101643: PUSH
101644: FOR_TO
101645: IFFALSE 101709
// begin hc_class = class_tiger ;
101647: LD_ADDR_OWVAR 28
101651: PUSH
101652: LD_INT 14
101654: ST_TO_ADDR
// hc_gallery =  ;
101655: LD_ADDR_OWVAR 33
101659: PUSH
101660: LD_STRING 
101662: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
101663: LD_ADDR_OWVAR 35
101667: PUSH
101668: LD_INT 7
101670: NEG
101671: PPUSH
101672: LD_INT 7
101674: PPUSH
101675: CALL_OW 12
101679: ST_TO_ADDR
// animal := CreateHuman ;
101680: LD_ADDR_VAR 0 12
101684: PUSH
101685: CALL_OW 44
101689: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101690: LD_VAR 0 12
101694: PPUSH
101695: LD_VAR 0 8
101699: PPUSH
101700: LD_INT 0
101702: PPUSH
101703: CALL 103616 0 3
// end ;
101707: GO 101644
101709: POP
101710: POP
// if apemans then
101711: LD_VAR 0 3
101715: IFFALSE 101838
// for i = 1 to apemans do
101717: LD_ADDR_VAR 0 11
101721: PUSH
101722: DOUBLE
101723: LD_INT 1
101725: DEC
101726: ST_TO_ADDR
101727: LD_VAR 0 3
101731: PUSH
101732: FOR_TO
101733: IFFALSE 101836
// begin hc_class = class_apeman ;
101735: LD_ADDR_OWVAR 28
101739: PUSH
101740: LD_INT 12
101742: ST_TO_ADDR
// hc_gallery =  ;
101743: LD_ADDR_OWVAR 33
101747: PUSH
101748: LD_STRING 
101750: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
101751: LD_ADDR_OWVAR 35
101755: PUSH
101756: LD_INT 2
101758: NEG
101759: PPUSH
101760: LD_INT 2
101762: PPUSH
101763: CALL_OW 12
101767: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
101768: LD_ADDR_OWVAR 31
101772: PUSH
101773: LD_INT 1
101775: PPUSH
101776: LD_INT 3
101778: PPUSH
101779: CALL_OW 12
101783: PUSH
101784: LD_INT 1
101786: PPUSH
101787: LD_INT 3
101789: PPUSH
101790: CALL_OW 12
101794: PUSH
101795: LD_INT 0
101797: PUSH
101798: LD_INT 0
101800: PUSH
101801: EMPTY
101802: LIST
101803: LIST
101804: LIST
101805: LIST
101806: ST_TO_ADDR
// animal := CreateHuman ;
101807: LD_ADDR_VAR 0 12
101811: PUSH
101812: CALL_OW 44
101816: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101817: LD_VAR 0 12
101821: PPUSH
101822: LD_VAR 0 8
101826: PPUSH
101827: LD_INT 0
101829: PPUSH
101830: CALL 103616 0 3
// end ;
101834: GO 101732
101836: POP
101837: POP
// if enchidnas then
101838: LD_VAR 0 4
101842: IFFALSE 101909
// for i = 1 to enchidnas do
101844: LD_ADDR_VAR 0 11
101848: PUSH
101849: DOUBLE
101850: LD_INT 1
101852: DEC
101853: ST_TO_ADDR
101854: LD_VAR 0 4
101858: PUSH
101859: FOR_TO
101860: IFFALSE 101907
// begin hc_class = 13 ;
101862: LD_ADDR_OWVAR 28
101866: PUSH
101867: LD_INT 13
101869: ST_TO_ADDR
// hc_gallery =  ;
101870: LD_ADDR_OWVAR 33
101874: PUSH
101875: LD_STRING 
101877: ST_TO_ADDR
// animal := CreateHuman ;
101878: LD_ADDR_VAR 0 12
101882: PUSH
101883: CALL_OW 44
101887: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101888: LD_VAR 0 12
101892: PPUSH
101893: LD_VAR 0 8
101897: PPUSH
101898: LD_INT 0
101900: PPUSH
101901: CALL 103616 0 3
// end ;
101905: GO 101859
101907: POP
101908: POP
// if fishes then
101909: LD_VAR 0 7
101913: IFFALSE 101980
// for i = 1 to fishes do
101915: LD_ADDR_VAR 0 11
101919: PUSH
101920: DOUBLE
101921: LD_INT 1
101923: DEC
101924: ST_TO_ADDR
101925: LD_VAR 0 7
101929: PUSH
101930: FOR_TO
101931: IFFALSE 101978
// begin hc_class = 20 ;
101933: LD_ADDR_OWVAR 28
101937: PUSH
101938: LD_INT 20
101940: ST_TO_ADDR
// hc_gallery =  ;
101941: LD_ADDR_OWVAR 33
101945: PUSH
101946: LD_STRING 
101948: ST_TO_ADDR
// animal := CreateHuman ;
101949: LD_ADDR_VAR 0 12
101953: PUSH
101954: CALL_OW 44
101958: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
101959: LD_VAR 0 12
101963: PPUSH
101964: LD_VAR 0 9
101968: PPUSH
101969: LD_INT 0
101971: PPUSH
101972: CALL 103616 0 3
// end ;
101976: GO 101930
101978: POP
101979: POP
// end ;
101980: LD_VAR 0 10
101984: RET
// export function WantHeal ( sci , unit ) ; begin
101985: LD_INT 0
101987: PPUSH
// if GetTaskList ( sci ) > 0 then
101988: LD_VAR 0 1
101992: PPUSH
101993: CALL_OW 437
101997: PUSH
101998: LD_INT 0
102000: GREATER
102001: IFFALSE 102071
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
102003: LD_VAR 0 1
102007: PPUSH
102008: CALL_OW 437
102012: PUSH
102013: LD_INT 1
102015: ARRAY
102016: PUSH
102017: LD_INT 1
102019: ARRAY
102020: PUSH
102021: LD_STRING l
102023: EQUAL
102024: PUSH
102025: LD_VAR 0 1
102029: PPUSH
102030: CALL_OW 437
102034: PUSH
102035: LD_INT 1
102037: ARRAY
102038: PUSH
102039: LD_INT 4
102041: ARRAY
102042: PUSH
102043: LD_VAR 0 2
102047: EQUAL
102048: AND
102049: IFFALSE 102061
// result := true else
102051: LD_ADDR_VAR 0 3
102055: PUSH
102056: LD_INT 1
102058: ST_TO_ADDR
102059: GO 102069
// result := false ;
102061: LD_ADDR_VAR 0 3
102065: PUSH
102066: LD_INT 0
102068: ST_TO_ADDR
// end else
102069: GO 102079
// result := false ;
102071: LD_ADDR_VAR 0 3
102075: PUSH
102076: LD_INT 0
102078: ST_TO_ADDR
// end ;
102079: LD_VAR 0 3
102083: RET
// export function HealTarget ( sci ) ; begin
102084: LD_INT 0
102086: PPUSH
// if not sci then
102087: LD_VAR 0 1
102091: NOT
102092: IFFALSE 102096
// exit ;
102094: GO 102161
// result := 0 ;
102096: LD_ADDR_VAR 0 2
102100: PUSH
102101: LD_INT 0
102103: ST_TO_ADDR
// if GetTaskList ( sci ) then
102104: LD_VAR 0 1
102108: PPUSH
102109: CALL_OW 437
102113: IFFALSE 102161
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102115: LD_VAR 0 1
102119: PPUSH
102120: CALL_OW 437
102124: PUSH
102125: LD_INT 1
102127: ARRAY
102128: PUSH
102129: LD_INT 1
102131: ARRAY
102132: PUSH
102133: LD_STRING l
102135: EQUAL
102136: IFFALSE 102161
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102138: LD_ADDR_VAR 0 2
102142: PUSH
102143: LD_VAR 0 1
102147: PPUSH
102148: CALL_OW 437
102152: PUSH
102153: LD_INT 1
102155: ARRAY
102156: PUSH
102157: LD_INT 4
102159: ARRAY
102160: ST_TO_ADDR
// end ;
102161: LD_VAR 0 2
102165: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102166: LD_INT 0
102168: PPUSH
102169: PPUSH
102170: PPUSH
102171: PPUSH
// if not base_units then
102172: LD_VAR 0 1
102176: NOT
102177: IFFALSE 102181
// exit ;
102179: GO 102268
// result := false ;
102181: LD_ADDR_VAR 0 2
102185: PUSH
102186: LD_INT 0
102188: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102189: LD_ADDR_VAR 0 5
102193: PUSH
102194: LD_VAR 0 1
102198: PPUSH
102199: LD_INT 21
102201: PUSH
102202: LD_INT 3
102204: PUSH
102205: EMPTY
102206: LIST
102207: LIST
102208: PPUSH
102209: CALL_OW 72
102213: ST_TO_ADDR
// if not tmp then
102214: LD_VAR 0 5
102218: NOT
102219: IFFALSE 102223
// exit ;
102221: GO 102268
// for i in tmp do
102223: LD_ADDR_VAR 0 3
102227: PUSH
102228: LD_VAR 0 5
102232: PUSH
102233: FOR_IN
102234: IFFALSE 102266
// begin result := EnemyInRange ( i , 22 ) ;
102236: LD_ADDR_VAR 0 2
102240: PUSH
102241: LD_VAR 0 3
102245: PPUSH
102246: LD_INT 22
102248: PPUSH
102249: CALL 99881 0 2
102253: ST_TO_ADDR
// if result then
102254: LD_VAR 0 2
102258: IFFALSE 102264
// exit ;
102260: POP
102261: POP
102262: GO 102268
// end ;
102264: GO 102233
102266: POP
102267: POP
// end ;
102268: LD_VAR 0 2
102272: RET
// export function FilterByTag ( units , tag ) ; begin
102273: LD_INT 0
102275: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102276: LD_ADDR_VAR 0 3
102280: PUSH
102281: LD_VAR 0 1
102285: PPUSH
102286: LD_INT 120
102288: PUSH
102289: LD_VAR 0 2
102293: PUSH
102294: EMPTY
102295: LIST
102296: LIST
102297: PPUSH
102298: CALL_OW 72
102302: ST_TO_ADDR
// end ;
102303: LD_VAR 0 3
102307: RET
// export function IsDriver ( un ) ; begin
102308: LD_INT 0
102310: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102311: LD_ADDR_VAR 0 2
102315: PUSH
102316: LD_VAR 0 1
102320: PUSH
102321: LD_INT 55
102323: PUSH
102324: EMPTY
102325: LIST
102326: PPUSH
102327: CALL_OW 69
102331: IN
102332: ST_TO_ADDR
// end ;
102333: LD_VAR 0 2
102337: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102338: LD_INT 0
102340: PPUSH
102341: PPUSH
// list := [ ] ;
102342: LD_ADDR_VAR 0 5
102346: PUSH
102347: EMPTY
102348: ST_TO_ADDR
// case d of 0 :
102349: LD_VAR 0 3
102353: PUSH
102354: LD_INT 0
102356: DOUBLE
102357: EQUAL
102358: IFTRUE 102362
102360: GO 102495
102362: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102363: LD_ADDR_VAR 0 5
102367: PUSH
102368: LD_VAR 0 1
102372: PUSH
102373: LD_INT 4
102375: MINUS
102376: PUSH
102377: LD_VAR 0 2
102381: PUSH
102382: LD_INT 4
102384: MINUS
102385: PUSH
102386: LD_INT 2
102388: PUSH
102389: EMPTY
102390: LIST
102391: LIST
102392: LIST
102393: PUSH
102394: LD_VAR 0 1
102398: PUSH
102399: LD_INT 3
102401: MINUS
102402: PUSH
102403: LD_VAR 0 2
102407: PUSH
102408: LD_INT 1
102410: PUSH
102411: EMPTY
102412: LIST
102413: LIST
102414: LIST
102415: PUSH
102416: LD_VAR 0 1
102420: PUSH
102421: LD_INT 4
102423: PLUS
102424: PUSH
102425: LD_VAR 0 2
102429: PUSH
102430: LD_INT 4
102432: PUSH
102433: EMPTY
102434: LIST
102435: LIST
102436: LIST
102437: PUSH
102438: LD_VAR 0 1
102442: PUSH
102443: LD_INT 3
102445: PLUS
102446: PUSH
102447: LD_VAR 0 2
102451: PUSH
102452: LD_INT 3
102454: PLUS
102455: PUSH
102456: LD_INT 5
102458: PUSH
102459: EMPTY
102460: LIST
102461: LIST
102462: LIST
102463: PUSH
102464: LD_VAR 0 1
102468: PUSH
102469: LD_VAR 0 2
102473: PUSH
102474: LD_INT 4
102476: PLUS
102477: PUSH
102478: LD_INT 0
102480: PUSH
102481: EMPTY
102482: LIST
102483: LIST
102484: LIST
102485: PUSH
102486: EMPTY
102487: LIST
102488: LIST
102489: LIST
102490: LIST
102491: LIST
102492: ST_TO_ADDR
// end ; 1 :
102493: GO 103193
102495: LD_INT 1
102497: DOUBLE
102498: EQUAL
102499: IFTRUE 102503
102501: GO 102636
102503: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102504: LD_ADDR_VAR 0 5
102508: PUSH
102509: LD_VAR 0 1
102513: PUSH
102514: LD_VAR 0 2
102518: PUSH
102519: LD_INT 4
102521: MINUS
102522: PUSH
102523: LD_INT 3
102525: PUSH
102526: EMPTY
102527: LIST
102528: LIST
102529: LIST
102530: PUSH
102531: LD_VAR 0 1
102535: PUSH
102536: LD_INT 3
102538: MINUS
102539: PUSH
102540: LD_VAR 0 2
102544: PUSH
102545: LD_INT 3
102547: MINUS
102548: PUSH
102549: LD_INT 2
102551: PUSH
102552: EMPTY
102553: LIST
102554: LIST
102555: LIST
102556: PUSH
102557: LD_VAR 0 1
102561: PUSH
102562: LD_INT 4
102564: MINUS
102565: PUSH
102566: LD_VAR 0 2
102570: PUSH
102571: LD_INT 1
102573: PUSH
102574: EMPTY
102575: LIST
102576: LIST
102577: LIST
102578: PUSH
102579: LD_VAR 0 1
102583: PUSH
102584: LD_VAR 0 2
102588: PUSH
102589: LD_INT 3
102591: PLUS
102592: PUSH
102593: LD_INT 0
102595: PUSH
102596: EMPTY
102597: LIST
102598: LIST
102599: LIST
102600: PUSH
102601: LD_VAR 0 1
102605: PUSH
102606: LD_INT 4
102608: PLUS
102609: PUSH
102610: LD_VAR 0 2
102614: PUSH
102615: LD_INT 4
102617: PLUS
102618: PUSH
102619: LD_INT 5
102621: PUSH
102622: EMPTY
102623: LIST
102624: LIST
102625: LIST
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: LIST
102631: LIST
102632: LIST
102633: ST_TO_ADDR
// end ; 2 :
102634: GO 103193
102636: LD_INT 2
102638: DOUBLE
102639: EQUAL
102640: IFTRUE 102644
102642: GO 102773
102644: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102645: LD_ADDR_VAR 0 5
102649: PUSH
102650: LD_VAR 0 1
102654: PUSH
102655: LD_VAR 0 2
102659: PUSH
102660: LD_INT 3
102662: MINUS
102663: PUSH
102664: LD_INT 3
102666: PUSH
102667: EMPTY
102668: LIST
102669: LIST
102670: LIST
102671: PUSH
102672: LD_VAR 0 1
102676: PUSH
102677: LD_INT 4
102679: PLUS
102680: PUSH
102681: LD_VAR 0 2
102685: PUSH
102686: LD_INT 4
102688: PUSH
102689: EMPTY
102690: LIST
102691: LIST
102692: LIST
102693: PUSH
102694: LD_VAR 0 1
102698: PUSH
102699: LD_VAR 0 2
102703: PUSH
102704: LD_INT 4
102706: PLUS
102707: PUSH
102708: LD_INT 0
102710: PUSH
102711: EMPTY
102712: LIST
102713: LIST
102714: LIST
102715: PUSH
102716: LD_VAR 0 1
102720: PUSH
102721: LD_INT 3
102723: MINUS
102724: PUSH
102725: LD_VAR 0 2
102729: PUSH
102730: LD_INT 1
102732: PUSH
102733: EMPTY
102734: LIST
102735: LIST
102736: LIST
102737: PUSH
102738: LD_VAR 0 1
102742: PUSH
102743: LD_INT 4
102745: MINUS
102746: PUSH
102747: LD_VAR 0 2
102751: PUSH
102752: LD_INT 4
102754: MINUS
102755: PUSH
102756: LD_INT 2
102758: PUSH
102759: EMPTY
102760: LIST
102761: LIST
102762: LIST
102763: PUSH
102764: EMPTY
102765: LIST
102766: LIST
102767: LIST
102768: LIST
102769: LIST
102770: ST_TO_ADDR
// end ; 3 :
102771: GO 103193
102773: LD_INT 3
102775: DOUBLE
102776: EQUAL
102777: IFTRUE 102781
102779: GO 102914
102781: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
102782: LD_ADDR_VAR 0 5
102786: PUSH
102787: LD_VAR 0 1
102791: PUSH
102792: LD_INT 3
102794: PLUS
102795: PUSH
102796: LD_VAR 0 2
102800: PUSH
102801: LD_INT 4
102803: PUSH
102804: EMPTY
102805: LIST
102806: LIST
102807: LIST
102808: PUSH
102809: LD_VAR 0 1
102813: PUSH
102814: LD_INT 4
102816: PLUS
102817: PUSH
102818: LD_VAR 0 2
102822: PUSH
102823: LD_INT 4
102825: PLUS
102826: PUSH
102827: LD_INT 5
102829: PUSH
102830: EMPTY
102831: LIST
102832: LIST
102833: LIST
102834: PUSH
102835: LD_VAR 0 1
102839: PUSH
102840: LD_INT 4
102842: MINUS
102843: PUSH
102844: LD_VAR 0 2
102848: PUSH
102849: LD_INT 1
102851: PUSH
102852: EMPTY
102853: LIST
102854: LIST
102855: LIST
102856: PUSH
102857: LD_VAR 0 1
102861: PUSH
102862: LD_VAR 0 2
102866: PUSH
102867: LD_INT 4
102869: MINUS
102870: PUSH
102871: LD_INT 3
102873: PUSH
102874: EMPTY
102875: LIST
102876: LIST
102877: LIST
102878: PUSH
102879: LD_VAR 0 1
102883: PUSH
102884: LD_INT 3
102886: MINUS
102887: PUSH
102888: LD_VAR 0 2
102892: PUSH
102893: LD_INT 3
102895: MINUS
102896: PUSH
102897: LD_INT 2
102899: PUSH
102900: EMPTY
102901: LIST
102902: LIST
102903: LIST
102904: PUSH
102905: EMPTY
102906: LIST
102907: LIST
102908: LIST
102909: LIST
102910: LIST
102911: ST_TO_ADDR
// end ; 4 :
102912: GO 103193
102914: LD_INT 4
102916: DOUBLE
102917: EQUAL
102918: IFTRUE 102922
102920: GO 103055
102922: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
102923: LD_ADDR_VAR 0 5
102927: PUSH
102928: LD_VAR 0 1
102932: PUSH
102933: LD_VAR 0 2
102937: PUSH
102938: LD_INT 4
102940: PLUS
102941: PUSH
102942: LD_INT 0
102944: PUSH
102945: EMPTY
102946: LIST
102947: LIST
102948: LIST
102949: PUSH
102950: LD_VAR 0 1
102954: PUSH
102955: LD_INT 3
102957: PLUS
102958: PUSH
102959: LD_VAR 0 2
102963: PUSH
102964: LD_INT 3
102966: PLUS
102967: PUSH
102968: LD_INT 5
102970: PUSH
102971: EMPTY
102972: LIST
102973: LIST
102974: LIST
102975: PUSH
102976: LD_VAR 0 1
102980: PUSH
102981: LD_INT 4
102983: PLUS
102984: PUSH
102985: LD_VAR 0 2
102989: PUSH
102990: LD_INT 4
102992: PUSH
102993: EMPTY
102994: LIST
102995: LIST
102996: LIST
102997: PUSH
102998: LD_VAR 0 1
103002: PUSH
103003: LD_VAR 0 2
103007: PUSH
103008: LD_INT 3
103010: MINUS
103011: PUSH
103012: LD_INT 3
103014: PUSH
103015: EMPTY
103016: LIST
103017: LIST
103018: LIST
103019: PUSH
103020: LD_VAR 0 1
103024: PUSH
103025: LD_INT 4
103027: MINUS
103028: PUSH
103029: LD_VAR 0 2
103033: PUSH
103034: LD_INT 4
103036: MINUS
103037: PUSH
103038: LD_INT 2
103040: PUSH
103041: EMPTY
103042: LIST
103043: LIST
103044: LIST
103045: PUSH
103046: EMPTY
103047: LIST
103048: LIST
103049: LIST
103050: LIST
103051: LIST
103052: ST_TO_ADDR
// end ; 5 :
103053: GO 103193
103055: LD_INT 5
103057: DOUBLE
103058: EQUAL
103059: IFTRUE 103063
103061: GO 103192
103063: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103064: LD_ADDR_VAR 0 5
103068: PUSH
103069: LD_VAR 0 1
103073: PUSH
103074: LD_INT 4
103076: MINUS
103077: PUSH
103078: LD_VAR 0 2
103082: PUSH
103083: LD_INT 1
103085: PUSH
103086: EMPTY
103087: LIST
103088: LIST
103089: LIST
103090: PUSH
103091: LD_VAR 0 1
103095: PUSH
103096: LD_VAR 0 2
103100: PUSH
103101: LD_INT 4
103103: MINUS
103104: PUSH
103105: LD_INT 3
103107: PUSH
103108: EMPTY
103109: LIST
103110: LIST
103111: LIST
103112: PUSH
103113: LD_VAR 0 1
103117: PUSH
103118: LD_INT 4
103120: PLUS
103121: PUSH
103122: LD_VAR 0 2
103126: PUSH
103127: LD_INT 4
103129: PLUS
103130: PUSH
103131: LD_INT 5
103133: PUSH
103134: EMPTY
103135: LIST
103136: LIST
103137: LIST
103138: PUSH
103139: LD_VAR 0 1
103143: PUSH
103144: LD_INT 3
103146: PLUS
103147: PUSH
103148: LD_VAR 0 2
103152: PUSH
103153: LD_INT 4
103155: PUSH
103156: EMPTY
103157: LIST
103158: LIST
103159: LIST
103160: PUSH
103161: LD_VAR 0 1
103165: PUSH
103166: LD_VAR 0 2
103170: PUSH
103171: LD_INT 3
103173: PLUS
103174: PUSH
103175: LD_INT 0
103177: PUSH
103178: EMPTY
103179: LIST
103180: LIST
103181: LIST
103182: PUSH
103183: EMPTY
103184: LIST
103185: LIST
103186: LIST
103187: LIST
103188: LIST
103189: ST_TO_ADDR
// end ; end ;
103190: GO 103193
103192: POP
// result := list ;
103193: LD_ADDR_VAR 0 4
103197: PUSH
103198: LD_VAR 0 5
103202: ST_TO_ADDR
// end ;
103203: LD_VAR 0 4
103207: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103208: LD_INT 0
103210: PPUSH
103211: PPUSH
103212: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103213: LD_VAR 0 1
103217: NOT
103218: PUSH
103219: LD_VAR 0 2
103223: PUSH
103224: LD_INT 1
103226: PUSH
103227: LD_INT 2
103229: PUSH
103230: LD_INT 3
103232: PUSH
103233: LD_INT 4
103235: PUSH
103236: EMPTY
103237: LIST
103238: LIST
103239: LIST
103240: LIST
103241: IN
103242: NOT
103243: OR
103244: IFFALSE 103248
// exit ;
103246: GO 103340
// tmp := [ ] ;
103248: LD_ADDR_VAR 0 5
103252: PUSH
103253: EMPTY
103254: ST_TO_ADDR
// for i in units do
103255: LD_ADDR_VAR 0 4
103259: PUSH
103260: LD_VAR 0 1
103264: PUSH
103265: FOR_IN
103266: IFFALSE 103309
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103268: LD_ADDR_VAR 0 5
103272: PUSH
103273: LD_VAR 0 5
103277: PPUSH
103278: LD_VAR 0 5
103282: PUSH
103283: LD_INT 1
103285: PLUS
103286: PPUSH
103287: LD_VAR 0 4
103291: PPUSH
103292: LD_VAR 0 2
103296: PPUSH
103297: CALL_OW 259
103301: PPUSH
103302: CALL_OW 2
103306: ST_TO_ADDR
103307: GO 103265
103309: POP
103310: POP
// if not tmp then
103311: LD_VAR 0 5
103315: NOT
103316: IFFALSE 103320
// exit ;
103318: GO 103340
// result := SortListByListDesc ( units , tmp ) ;
103320: LD_ADDR_VAR 0 3
103324: PUSH
103325: LD_VAR 0 1
103329: PPUSH
103330: LD_VAR 0 5
103334: PPUSH
103335: CALL_OW 77
103339: ST_TO_ADDR
// end ;
103340: LD_VAR 0 3
103344: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103345: LD_INT 0
103347: PPUSH
103348: PPUSH
103349: PPUSH
// result := false ;
103350: LD_ADDR_VAR 0 3
103354: PUSH
103355: LD_INT 0
103357: ST_TO_ADDR
// x := GetX ( building ) ;
103358: LD_ADDR_VAR 0 4
103362: PUSH
103363: LD_VAR 0 2
103367: PPUSH
103368: CALL_OW 250
103372: ST_TO_ADDR
// y := GetY ( building ) ;
103373: LD_ADDR_VAR 0 5
103377: PUSH
103378: LD_VAR 0 2
103382: PPUSH
103383: CALL_OW 251
103387: ST_TO_ADDR
// if not building or not x or not y then
103388: LD_VAR 0 2
103392: NOT
103393: PUSH
103394: LD_VAR 0 4
103398: NOT
103399: OR
103400: PUSH
103401: LD_VAR 0 5
103405: NOT
103406: OR
103407: IFFALSE 103411
// exit ;
103409: GO 103503
// if GetTaskList ( unit ) then
103411: LD_VAR 0 1
103415: PPUSH
103416: CALL_OW 437
103420: IFFALSE 103503
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103422: LD_STRING e
103424: PUSH
103425: LD_VAR 0 1
103429: PPUSH
103430: CALL_OW 437
103434: PUSH
103435: LD_INT 1
103437: ARRAY
103438: PUSH
103439: LD_INT 1
103441: ARRAY
103442: EQUAL
103443: PUSH
103444: LD_VAR 0 4
103448: PUSH
103449: LD_VAR 0 1
103453: PPUSH
103454: CALL_OW 437
103458: PUSH
103459: LD_INT 1
103461: ARRAY
103462: PUSH
103463: LD_INT 2
103465: ARRAY
103466: EQUAL
103467: AND
103468: PUSH
103469: LD_VAR 0 5
103473: PUSH
103474: LD_VAR 0 1
103478: PPUSH
103479: CALL_OW 437
103483: PUSH
103484: LD_INT 1
103486: ARRAY
103487: PUSH
103488: LD_INT 3
103490: ARRAY
103491: EQUAL
103492: AND
103493: IFFALSE 103503
// result := true end ;
103495: LD_ADDR_VAR 0 3
103499: PUSH
103500: LD_INT 1
103502: ST_TO_ADDR
// end ;
103503: LD_VAR 0 3
103507: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
103508: LD_INT 0
103510: PPUSH
// result := false ;
103511: LD_ADDR_VAR 0 4
103515: PUSH
103516: LD_INT 0
103518: ST_TO_ADDR
// if GetTaskList ( unit ) then
103519: LD_VAR 0 1
103523: PPUSH
103524: CALL_OW 437
103528: IFFALSE 103611
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103530: LD_STRING M
103532: PUSH
103533: LD_VAR 0 1
103537: PPUSH
103538: CALL_OW 437
103542: PUSH
103543: LD_INT 1
103545: ARRAY
103546: PUSH
103547: LD_INT 1
103549: ARRAY
103550: EQUAL
103551: PUSH
103552: LD_VAR 0 2
103556: PUSH
103557: LD_VAR 0 1
103561: PPUSH
103562: CALL_OW 437
103566: PUSH
103567: LD_INT 1
103569: ARRAY
103570: PUSH
103571: LD_INT 2
103573: ARRAY
103574: EQUAL
103575: AND
103576: PUSH
103577: LD_VAR 0 3
103581: PUSH
103582: LD_VAR 0 1
103586: PPUSH
103587: CALL_OW 437
103591: PUSH
103592: LD_INT 1
103594: ARRAY
103595: PUSH
103596: LD_INT 3
103598: ARRAY
103599: EQUAL
103600: AND
103601: IFFALSE 103611
// result := true ;
103603: LD_ADDR_VAR 0 4
103607: PUSH
103608: LD_INT 1
103610: ST_TO_ADDR
// end ; end ;
103611: LD_VAR 0 4
103615: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103616: LD_INT 0
103618: PPUSH
103619: PPUSH
103620: PPUSH
103621: PPUSH
// if not unit or not area then
103622: LD_VAR 0 1
103626: NOT
103627: PUSH
103628: LD_VAR 0 2
103632: NOT
103633: OR
103634: IFFALSE 103638
// exit ;
103636: GO 103802
// tmp := AreaToList ( area , i ) ;
103638: LD_ADDR_VAR 0 6
103642: PUSH
103643: LD_VAR 0 2
103647: PPUSH
103648: LD_VAR 0 5
103652: PPUSH
103653: CALL_OW 517
103657: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
103658: LD_ADDR_VAR 0 5
103662: PUSH
103663: DOUBLE
103664: LD_INT 1
103666: DEC
103667: ST_TO_ADDR
103668: LD_VAR 0 6
103672: PUSH
103673: LD_INT 1
103675: ARRAY
103676: PUSH
103677: FOR_TO
103678: IFFALSE 103800
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
103680: LD_ADDR_VAR 0 7
103684: PUSH
103685: LD_VAR 0 6
103689: PUSH
103690: LD_INT 1
103692: ARRAY
103693: PUSH
103694: LD_VAR 0 5
103698: ARRAY
103699: PUSH
103700: LD_VAR 0 6
103704: PUSH
103705: LD_INT 2
103707: ARRAY
103708: PUSH
103709: LD_VAR 0 5
103713: ARRAY
103714: PUSH
103715: EMPTY
103716: LIST
103717: LIST
103718: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
103719: LD_VAR 0 7
103723: PUSH
103724: LD_INT 1
103726: ARRAY
103727: PPUSH
103728: LD_VAR 0 7
103732: PUSH
103733: LD_INT 2
103735: ARRAY
103736: PPUSH
103737: CALL_OW 428
103741: PUSH
103742: LD_INT 0
103744: EQUAL
103745: IFFALSE 103798
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
103747: LD_VAR 0 1
103751: PPUSH
103752: LD_VAR 0 7
103756: PUSH
103757: LD_INT 1
103759: ARRAY
103760: PPUSH
103761: LD_VAR 0 7
103765: PUSH
103766: LD_INT 2
103768: ARRAY
103769: PPUSH
103770: LD_VAR 0 3
103774: PPUSH
103775: CALL_OW 48
// result := IsPlaced ( unit ) ;
103779: LD_ADDR_VAR 0 4
103783: PUSH
103784: LD_VAR 0 1
103788: PPUSH
103789: CALL_OW 305
103793: ST_TO_ADDR
// exit ;
103794: POP
103795: POP
103796: GO 103802
// end ; end ;
103798: GO 103677
103800: POP
103801: POP
// end ;
103802: LD_VAR 0 4
103806: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
103807: LD_INT 0
103809: PPUSH
103810: PPUSH
103811: PPUSH
// if not side or side > 8 then
103812: LD_VAR 0 1
103816: NOT
103817: PUSH
103818: LD_VAR 0 1
103822: PUSH
103823: LD_INT 8
103825: GREATER
103826: OR
103827: IFFALSE 103831
// exit ;
103829: GO 104018
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
103831: LD_ADDR_VAR 0 4
103835: PUSH
103836: LD_INT 22
103838: PUSH
103839: LD_VAR 0 1
103843: PUSH
103844: EMPTY
103845: LIST
103846: LIST
103847: PUSH
103848: LD_INT 21
103850: PUSH
103851: LD_INT 3
103853: PUSH
103854: EMPTY
103855: LIST
103856: LIST
103857: PUSH
103858: EMPTY
103859: LIST
103860: LIST
103861: PPUSH
103862: CALL_OW 69
103866: ST_TO_ADDR
// if not tmp then
103867: LD_VAR 0 4
103871: NOT
103872: IFFALSE 103876
// exit ;
103874: GO 104018
// enable_addtolog := true ;
103876: LD_ADDR_OWVAR 81
103880: PUSH
103881: LD_INT 1
103883: ST_TO_ADDR
// AddToLog ( [ ) ;
103884: LD_STRING [
103886: PPUSH
103887: CALL_OW 561
// for i in tmp do
103891: LD_ADDR_VAR 0 3
103895: PUSH
103896: LD_VAR 0 4
103900: PUSH
103901: FOR_IN
103902: IFFALSE 104009
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
103904: LD_STRING [
103906: PUSH
103907: LD_VAR 0 3
103911: PPUSH
103912: CALL_OW 266
103916: STR
103917: PUSH
103918: LD_STRING , 
103920: STR
103921: PUSH
103922: LD_VAR 0 3
103926: PPUSH
103927: CALL_OW 250
103931: STR
103932: PUSH
103933: LD_STRING , 
103935: STR
103936: PUSH
103937: LD_VAR 0 3
103941: PPUSH
103942: CALL_OW 251
103946: STR
103947: PUSH
103948: LD_STRING , 
103950: STR
103951: PUSH
103952: LD_VAR 0 3
103956: PPUSH
103957: CALL_OW 254
103961: STR
103962: PUSH
103963: LD_STRING , 
103965: STR
103966: PUSH
103967: LD_VAR 0 3
103971: PPUSH
103972: LD_INT 1
103974: PPUSH
103975: CALL_OW 268
103979: STR
103980: PUSH
103981: LD_STRING , 
103983: STR
103984: PUSH
103985: LD_VAR 0 3
103989: PPUSH
103990: LD_INT 2
103992: PPUSH
103993: CALL_OW 268
103997: STR
103998: PUSH
103999: LD_STRING ],
104001: STR
104002: PPUSH
104003: CALL_OW 561
// end ;
104007: GO 103901
104009: POP
104010: POP
// AddToLog ( ]; ) ;
104011: LD_STRING ];
104013: PPUSH
104014: CALL_OW 561
// end ;
104018: LD_VAR 0 2
104022: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104023: LD_INT 0
104025: PPUSH
104026: PPUSH
104027: PPUSH
104028: PPUSH
104029: PPUSH
// if not area or not rate or not max then
104030: LD_VAR 0 1
104034: NOT
104035: PUSH
104036: LD_VAR 0 2
104040: NOT
104041: OR
104042: PUSH
104043: LD_VAR 0 4
104047: NOT
104048: OR
104049: IFFALSE 104053
// exit ;
104051: GO 104242
// while 1 do
104053: LD_INT 1
104055: IFFALSE 104242
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104057: LD_ADDR_VAR 0 9
104061: PUSH
104062: LD_VAR 0 1
104066: PPUSH
104067: LD_INT 1
104069: PPUSH
104070: CALL_OW 287
104074: PUSH
104075: LD_INT 10
104077: MUL
104078: ST_TO_ADDR
// r := rate / 10 ;
104079: LD_ADDR_VAR 0 7
104083: PUSH
104084: LD_VAR 0 2
104088: PUSH
104089: LD_INT 10
104091: DIVREAL
104092: ST_TO_ADDR
// time := 1 1$00 ;
104093: LD_ADDR_VAR 0 8
104097: PUSH
104098: LD_INT 2100
104100: ST_TO_ADDR
// if amount < min then
104101: LD_VAR 0 9
104105: PUSH
104106: LD_VAR 0 3
104110: LESS
104111: IFFALSE 104129
// r := r * 2 else
104113: LD_ADDR_VAR 0 7
104117: PUSH
104118: LD_VAR 0 7
104122: PUSH
104123: LD_INT 2
104125: MUL
104126: ST_TO_ADDR
104127: GO 104155
// if amount > max then
104129: LD_VAR 0 9
104133: PUSH
104134: LD_VAR 0 4
104138: GREATER
104139: IFFALSE 104155
// r := r / 2 ;
104141: LD_ADDR_VAR 0 7
104145: PUSH
104146: LD_VAR 0 7
104150: PUSH
104151: LD_INT 2
104153: DIVREAL
104154: ST_TO_ADDR
// time := time / r ;
104155: LD_ADDR_VAR 0 8
104159: PUSH
104160: LD_VAR 0 8
104164: PUSH
104165: LD_VAR 0 7
104169: DIVREAL
104170: ST_TO_ADDR
// if time < 0 then
104171: LD_VAR 0 8
104175: PUSH
104176: LD_INT 0
104178: LESS
104179: IFFALSE 104196
// time := time * - 1 ;
104181: LD_ADDR_VAR 0 8
104185: PUSH
104186: LD_VAR 0 8
104190: PUSH
104191: LD_INT 1
104193: NEG
104194: MUL
104195: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104196: LD_VAR 0 8
104200: PUSH
104201: LD_INT 35
104203: PPUSH
104204: LD_INT 875
104206: PPUSH
104207: CALL_OW 12
104211: PLUS
104212: PPUSH
104213: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104217: LD_INT 1
104219: PPUSH
104220: LD_INT 5
104222: PPUSH
104223: CALL_OW 12
104227: PPUSH
104228: LD_VAR 0 1
104232: PPUSH
104233: LD_INT 1
104235: PPUSH
104236: CALL_OW 55
// end ;
104240: GO 104053
// end ;
104242: LD_VAR 0 5
104246: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104247: LD_INT 0
104249: PPUSH
104250: PPUSH
104251: PPUSH
104252: PPUSH
104253: PPUSH
104254: PPUSH
104255: PPUSH
104256: PPUSH
// if not turrets or not factories then
104257: LD_VAR 0 1
104261: NOT
104262: PUSH
104263: LD_VAR 0 2
104267: NOT
104268: OR
104269: IFFALSE 104273
// exit ;
104271: GO 104580
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104273: LD_ADDR_VAR 0 10
104277: PUSH
104278: LD_INT 5
104280: PUSH
104281: LD_INT 6
104283: PUSH
104284: EMPTY
104285: LIST
104286: LIST
104287: PUSH
104288: LD_INT 2
104290: PUSH
104291: LD_INT 4
104293: PUSH
104294: EMPTY
104295: LIST
104296: LIST
104297: PUSH
104298: LD_INT 3
104300: PUSH
104301: LD_INT 5
104303: PUSH
104304: EMPTY
104305: LIST
104306: LIST
104307: PUSH
104308: EMPTY
104309: LIST
104310: LIST
104311: LIST
104312: PUSH
104313: LD_INT 24
104315: PUSH
104316: LD_INT 25
104318: PUSH
104319: EMPTY
104320: LIST
104321: LIST
104322: PUSH
104323: LD_INT 23
104325: PUSH
104326: LD_INT 27
104328: PUSH
104329: EMPTY
104330: LIST
104331: LIST
104332: PUSH
104333: EMPTY
104334: LIST
104335: LIST
104336: PUSH
104337: LD_INT 42
104339: PUSH
104340: LD_INT 43
104342: PUSH
104343: EMPTY
104344: LIST
104345: LIST
104346: PUSH
104347: LD_INT 44
104349: PUSH
104350: LD_INT 46
104352: PUSH
104353: EMPTY
104354: LIST
104355: LIST
104356: PUSH
104357: LD_INT 45
104359: PUSH
104360: LD_INT 47
104362: PUSH
104363: EMPTY
104364: LIST
104365: LIST
104366: PUSH
104367: EMPTY
104368: LIST
104369: LIST
104370: LIST
104371: PUSH
104372: EMPTY
104373: LIST
104374: LIST
104375: LIST
104376: ST_TO_ADDR
// result := [ ] ;
104377: LD_ADDR_VAR 0 3
104381: PUSH
104382: EMPTY
104383: ST_TO_ADDR
// for i in turrets do
104384: LD_ADDR_VAR 0 4
104388: PUSH
104389: LD_VAR 0 1
104393: PUSH
104394: FOR_IN
104395: IFFALSE 104578
// begin nat := GetNation ( i ) ;
104397: LD_ADDR_VAR 0 7
104401: PUSH
104402: LD_VAR 0 4
104406: PPUSH
104407: CALL_OW 248
104411: ST_TO_ADDR
// weapon := 0 ;
104412: LD_ADDR_VAR 0 8
104416: PUSH
104417: LD_INT 0
104419: ST_TO_ADDR
// if not nat then
104420: LD_VAR 0 7
104424: NOT
104425: IFFALSE 104429
// continue ;
104427: GO 104394
// for j in list [ nat ] do
104429: LD_ADDR_VAR 0 5
104433: PUSH
104434: LD_VAR 0 10
104438: PUSH
104439: LD_VAR 0 7
104443: ARRAY
104444: PUSH
104445: FOR_IN
104446: IFFALSE 104487
// if GetBWeapon ( i ) = j [ 1 ] then
104448: LD_VAR 0 4
104452: PPUSH
104453: CALL_OW 269
104457: PUSH
104458: LD_VAR 0 5
104462: PUSH
104463: LD_INT 1
104465: ARRAY
104466: EQUAL
104467: IFFALSE 104485
// begin weapon := j [ 2 ] ;
104469: LD_ADDR_VAR 0 8
104473: PUSH
104474: LD_VAR 0 5
104478: PUSH
104479: LD_INT 2
104481: ARRAY
104482: ST_TO_ADDR
// break ;
104483: GO 104487
// end ;
104485: GO 104445
104487: POP
104488: POP
// if not weapon then
104489: LD_VAR 0 8
104493: NOT
104494: IFFALSE 104498
// continue ;
104496: GO 104394
// for k in factories do
104498: LD_ADDR_VAR 0 6
104502: PUSH
104503: LD_VAR 0 2
104507: PUSH
104508: FOR_IN
104509: IFFALSE 104574
// begin weapons := AvailableWeaponList ( k ) ;
104511: LD_ADDR_VAR 0 9
104515: PUSH
104516: LD_VAR 0 6
104520: PPUSH
104521: CALL_OW 478
104525: ST_TO_ADDR
// if not weapons then
104526: LD_VAR 0 9
104530: NOT
104531: IFFALSE 104535
// continue ;
104533: GO 104508
// if weapon in weapons then
104535: LD_VAR 0 8
104539: PUSH
104540: LD_VAR 0 9
104544: IN
104545: IFFALSE 104572
// begin result := [ i , weapon ] ;
104547: LD_ADDR_VAR 0 3
104551: PUSH
104552: LD_VAR 0 4
104556: PUSH
104557: LD_VAR 0 8
104561: PUSH
104562: EMPTY
104563: LIST
104564: LIST
104565: ST_TO_ADDR
// exit ;
104566: POP
104567: POP
104568: POP
104569: POP
104570: GO 104580
// end ; end ;
104572: GO 104508
104574: POP
104575: POP
// end ;
104576: GO 104394
104578: POP
104579: POP
// end ;
104580: LD_VAR 0 3
104584: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104585: LD_INT 0
104587: PPUSH
// if not side or side > 8 then
104588: LD_VAR 0 3
104592: NOT
104593: PUSH
104594: LD_VAR 0 3
104598: PUSH
104599: LD_INT 8
104601: GREATER
104602: OR
104603: IFFALSE 104607
// exit ;
104605: GO 104666
// if not range then
104607: LD_VAR 0 4
104611: NOT
104612: IFFALSE 104623
// range := - 12 ;
104614: LD_ADDR_VAR 0 4
104618: PUSH
104619: LD_INT 12
104621: NEG
104622: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104623: LD_VAR 0 1
104627: PPUSH
104628: LD_VAR 0 2
104632: PPUSH
104633: LD_VAR 0 3
104637: PPUSH
104638: LD_VAR 0 4
104642: PPUSH
104643: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104647: LD_VAR 0 1
104651: PPUSH
104652: LD_VAR 0 2
104656: PPUSH
104657: LD_VAR 0 3
104661: PPUSH
104662: CALL_OW 331
// end ;
104666: LD_VAR 0 5
104670: RET
// export function Video ( mode ) ; begin
104671: LD_INT 0
104673: PPUSH
// ingame_video = mode ;
104674: LD_ADDR_OWVAR 52
104678: PUSH
104679: LD_VAR 0 1
104683: ST_TO_ADDR
// interface_hidden = mode ;
104684: LD_ADDR_OWVAR 54
104688: PUSH
104689: LD_VAR 0 1
104693: ST_TO_ADDR
// end ;
104694: LD_VAR 0 2
104698: RET
// export function Join ( array , element ) ; begin
104699: LD_INT 0
104701: PPUSH
// result := Replace ( array , array + 1 , element ) ;
104702: LD_ADDR_VAR 0 3
104706: PUSH
104707: LD_VAR 0 1
104711: PPUSH
104712: LD_VAR 0 1
104716: PUSH
104717: LD_INT 1
104719: PLUS
104720: PPUSH
104721: LD_VAR 0 2
104725: PPUSH
104726: CALL_OW 1
104730: ST_TO_ADDR
// end ;
104731: LD_VAR 0 3
104735: RET
// export function JoinUnion ( array , element ) ; begin
104736: LD_INT 0
104738: PPUSH
// result := array union element ;
104739: LD_ADDR_VAR 0 3
104743: PUSH
104744: LD_VAR 0 1
104748: PUSH
104749: LD_VAR 0 2
104753: UNION
104754: ST_TO_ADDR
// end ;
104755: LD_VAR 0 3
104759: RET
// export function GetBehemoths ( side ) ; begin
104760: LD_INT 0
104762: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
104763: LD_ADDR_VAR 0 2
104767: PUSH
104768: LD_INT 22
104770: PUSH
104771: LD_VAR 0 1
104775: PUSH
104776: EMPTY
104777: LIST
104778: LIST
104779: PUSH
104780: LD_INT 31
104782: PUSH
104783: LD_INT 25
104785: PUSH
104786: EMPTY
104787: LIST
104788: LIST
104789: PUSH
104790: EMPTY
104791: LIST
104792: LIST
104793: PPUSH
104794: CALL_OW 69
104798: ST_TO_ADDR
// end ;
104799: LD_VAR 0 2
104803: RET
// export function Shuffle ( array ) ; var i , index ; begin
104804: LD_INT 0
104806: PPUSH
104807: PPUSH
104808: PPUSH
// result := [ ] ;
104809: LD_ADDR_VAR 0 2
104813: PUSH
104814: EMPTY
104815: ST_TO_ADDR
// if not array then
104816: LD_VAR 0 1
104820: NOT
104821: IFFALSE 104825
// exit ;
104823: GO 104924
// Randomize ;
104825: CALL_OW 10
// for i = array downto 1 do
104829: LD_ADDR_VAR 0 3
104833: PUSH
104834: DOUBLE
104835: LD_VAR 0 1
104839: INC
104840: ST_TO_ADDR
104841: LD_INT 1
104843: PUSH
104844: FOR_DOWNTO
104845: IFFALSE 104922
// begin index := rand ( 1 , array ) ;
104847: LD_ADDR_VAR 0 4
104851: PUSH
104852: LD_INT 1
104854: PPUSH
104855: LD_VAR 0 1
104859: PPUSH
104860: CALL_OW 12
104864: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
104865: LD_ADDR_VAR 0 2
104869: PUSH
104870: LD_VAR 0 2
104874: PPUSH
104875: LD_VAR 0 2
104879: PUSH
104880: LD_INT 1
104882: PLUS
104883: PPUSH
104884: LD_VAR 0 1
104888: PUSH
104889: LD_VAR 0 4
104893: ARRAY
104894: PPUSH
104895: CALL_OW 2
104899: ST_TO_ADDR
// array := Delete ( array , index ) ;
104900: LD_ADDR_VAR 0 1
104904: PUSH
104905: LD_VAR 0 1
104909: PPUSH
104910: LD_VAR 0 4
104914: PPUSH
104915: CALL_OW 3
104919: ST_TO_ADDR
// end ;
104920: GO 104844
104922: POP
104923: POP
// end ;
104924: LD_VAR 0 2
104928: RET
// export function GetBaseMaterials ( base ) ; begin
104929: LD_INT 0
104931: PPUSH
// result := [ 0 , 0 , 0 ] ;
104932: LD_ADDR_VAR 0 2
104936: PUSH
104937: LD_INT 0
104939: PUSH
104940: LD_INT 0
104942: PUSH
104943: LD_INT 0
104945: PUSH
104946: EMPTY
104947: LIST
104948: LIST
104949: LIST
104950: ST_TO_ADDR
// if not base then
104951: LD_VAR 0 1
104955: NOT
104956: IFFALSE 104960
// exit ;
104958: GO 105009
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
104960: LD_ADDR_VAR 0 2
104964: PUSH
104965: LD_VAR 0 1
104969: PPUSH
104970: LD_INT 1
104972: PPUSH
104973: CALL_OW 275
104977: PUSH
104978: LD_VAR 0 1
104982: PPUSH
104983: LD_INT 2
104985: PPUSH
104986: CALL_OW 275
104990: PUSH
104991: LD_VAR 0 1
104995: PPUSH
104996: LD_INT 3
104998: PPUSH
104999: CALL_OW 275
105003: PUSH
105004: EMPTY
105005: LIST
105006: LIST
105007: LIST
105008: ST_TO_ADDR
// end ;
105009: LD_VAR 0 2
105013: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
105014: LD_INT 0
105016: PPUSH
105017: PPUSH
// result := array ;
105018: LD_ADDR_VAR 0 3
105022: PUSH
105023: LD_VAR 0 1
105027: ST_TO_ADDR
// if size >= result then
105028: LD_VAR 0 2
105032: PUSH
105033: LD_VAR 0 3
105037: GREATEREQUAL
105038: IFFALSE 105042
// exit ;
105040: GO 105092
// if size then
105042: LD_VAR 0 2
105046: IFFALSE 105092
// for i := array downto size do
105048: LD_ADDR_VAR 0 4
105052: PUSH
105053: DOUBLE
105054: LD_VAR 0 1
105058: INC
105059: ST_TO_ADDR
105060: LD_VAR 0 2
105064: PUSH
105065: FOR_DOWNTO
105066: IFFALSE 105090
// result := Delete ( result , result ) ;
105068: LD_ADDR_VAR 0 3
105072: PUSH
105073: LD_VAR 0 3
105077: PPUSH
105078: LD_VAR 0 3
105082: PPUSH
105083: CALL_OW 3
105087: ST_TO_ADDR
105088: GO 105065
105090: POP
105091: POP
// end ;
105092: LD_VAR 0 3
105096: RET
// export function ComExit ( unit ) ; var tmp ; begin
105097: LD_INT 0
105099: PPUSH
105100: PPUSH
// if not IsInUnit ( unit ) then
105101: LD_VAR 0 1
105105: PPUSH
105106: CALL_OW 310
105110: NOT
105111: IFFALSE 105115
// exit ;
105113: GO 105175
// tmp := IsInUnit ( unit ) ;
105115: LD_ADDR_VAR 0 3
105119: PUSH
105120: LD_VAR 0 1
105124: PPUSH
105125: CALL_OW 310
105129: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105130: LD_VAR 0 3
105134: PPUSH
105135: CALL_OW 247
105139: PUSH
105140: LD_INT 2
105142: EQUAL
105143: IFFALSE 105156
// ComExitVehicle ( unit ) else
105145: LD_VAR 0 1
105149: PPUSH
105150: CALL_OW 121
105154: GO 105165
// ComExitBuilding ( unit ) ;
105156: LD_VAR 0 1
105160: PPUSH
105161: CALL_OW 122
// result := tmp ;
105165: LD_ADDR_VAR 0 2
105169: PUSH
105170: LD_VAR 0 3
105174: ST_TO_ADDR
// end ;
105175: LD_VAR 0 2
105179: RET
// export function ComExitAll ( units ) ; var i ; begin
105180: LD_INT 0
105182: PPUSH
105183: PPUSH
// if not units then
105184: LD_VAR 0 1
105188: NOT
105189: IFFALSE 105193
// exit ;
105191: GO 105219
// for i in units do
105193: LD_ADDR_VAR 0 3
105197: PUSH
105198: LD_VAR 0 1
105202: PUSH
105203: FOR_IN
105204: IFFALSE 105217
// ComExit ( i ) ;
105206: LD_VAR 0 3
105210: PPUSH
105211: CALL 105097 0 1
105215: GO 105203
105217: POP
105218: POP
// end ;
105219: LD_VAR 0 2
105223: RET
// export function ResetHc ; begin
105224: LD_INT 0
105226: PPUSH
// InitHc ;
105227: CALL_OW 19
// hc_importance := 0 ;
105231: LD_ADDR_OWVAR 32
105235: PUSH
105236: LD_INT 0
105238: ST_TO_ADDR
// end ;
105239: LD_VAR 0 1
105243: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105244: LD_INT 0
105246: PPUSH
105247: PPUSH
105248: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105249: LD_ADDR_VAR 0 6
105253: PUSH
105254: LD_VAR 0 1
105258: PUSH
105259: LD_VAR 0 3
105263: PLUS
105264: PUSH
105265: LD_INT 2
105267: DIV
105268: ST_TO_ADDR
// if _x < 0 then
105269: LD_VAR 0 6
105273: PUSH
105274: LD_INT 0
105276: LESS
105277: IFFALSE 105294
// _x := _x * - 1 ;
105279: LD_ADDR_VAR 0 6
105283: PUSH
105284: LD_VAR 0 6
105288: PUSH
105289: LD_INT 1
105291: NEG
105292: MUL
105293: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105294: LD_ADDR_VAR 0 7
105298: PUSH
105299: LD_VAR 0 2
105303: PUSH
105304: LD_VAR 0 4
105308: PLUS
105309: PUSH
105310: LD_INT 2
105312: DIV
105313: ST_TO_ADDR
// if _y < 0 then
105314: LD_VAR 0 7
105318: PUSH
105319: LD_INT 0
105321: LESS
105322: IFFALSE 105339
// _y := _y * - 1 ;
105324: LD_ADDR_VAR 0 7
105328: PUSH
105329: LD_VAR 0 7
105333: PUSH
105334: LD_INT 1
105336: NEG
105337: MUL
105338: ST_TO_ADDR
// result := [ _x , _y ] ;
105339: LD_ADDR_VAR 0 5
105343: PUSH
105344: LD_VAR 0 6
105348: PUSH
105349: LD_VAR 0 7
105353: PUSH
105354: EMPTY
105355: LIST
105356: LIST
105357: ST_TO_ADDR
// end ;
105358: LD_VAR 0 5
105362: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105363: LD_INT 0
105365: PPUSH
105366: PPUSH
105367: PPUSH
105368: PPUSH
// task := GetTaskList ( unit ) ;
105369: LD_ADDR_VAR 0 7
105373: PUSH
105374: LD_VAR 0 1
105378: PPUSH
105379: CALL_OW 437
105383: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105384: LD_VAR 0 7
105388: NOT
105389: PUSH
105390: LD_VAR 0 1
105394: PPUSH
105395: LD_VAR 0 2
105399: PPUSH
105400: CALL_OW 308
105404: NOT
105405: AND
105406: IFFALSE 105410
// exit ;
105408: GO 105528
// if IsInArea ( unit , area ) then
105410: LD_VAR 0 1
105414: PPUSH
105415: LD_VAR 0 2
105419: PPUSH
105420: CALL_OW 308
105424: IFFALSE 105442
// begin ComMoveToArea ( unit , goAway ) ;
105426: LD_VAR 0 1
105430: PPUSH
105431: LD_VAR 0 3
105435: PPUSH
105436: CALL_OW 113
// exit ;
105440: GO 105528
// end ; if task [ 1 ] [ 1 ] <> M then
105442: LD_VAR 0 7
105446: PUSH
105447: LD_INT 1
105449: ARRAY
105450: PUSH
105451: LD_INT 1
105453: ARRAY
105454: PUSH
105455: LD_STRING M
105457: NONEQUAL
105458: IFFALSE 105462
// exit ;
105460: GO 105528
// x := task [ 1 ] [ 2 ] ;
105462: LD_ADDR_VAR 0 5
105466: PUSH
105467: LD_VAR 0 7
105471: PUSH
105472: LD_INT 1
105474: ARRAY
105475: PUSH
105476: LD_INT 2
105478: ARRAY
105479: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
105480: LD_ADDR_VAR 0 6
105484: PUSH
105485: LD_VAR 0 7
105489: PUSH
105490: LD_INT 1
105492: ARRAY
105493: PUSH
105494: LD_INT 3
105496: ARRAY
105497: ST_TO_ADDR
// if InArea ( x , y , area ) then
105498: LD_VAR 0 5
105502: PPUSH
105503: LD_VAR 0 6
105507: PPUSH
105508: LD_VAR 0 2
105512: PPUSH
105513: CALL_OW 309
105517: IFFALSE 105528
// ComStop ( unit ) ;
105519: LD_VAR 0 1
105523: PPUSH
105524: CALL_OW 141
// end ;
105528: LD_VAR 0 4
105532: RET
// export function Abs ( value ) ; begin
105533: LD_INT 0
105535: PPUSH
// result := value ;
105536: LD_ADDR_VAR 0 2
105540: PUSH
105541: LD_VAR 0 1
105545: ST_TO_ADDR
// if value < 0 then
105546: LD_VAR 0 1
105550: PUSH
105551: LD_INT 0
105553: LESS
105554: IFFALSE 105571
// result := value * - 1 ;
105556: LD_ADDR_VAR 0 2
105560: PUSH
105561: LD_VAR 0 1
105565: PUSH
105566: LD_INT 1
105568: NEG
105569: MUL
105570: ST_TO_ADDR
// end ;
105571: LD_VAR 0 2
105575: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
105576: LD_INT 0
105578: PPUSH
105579: PPUSH
105580: PPUSH
105581: PPUSH
105582: PPUSH
105583: PPUSH
105584: PPUSH
105585: PPUSH
// if not unit or not building then
105586: LD_VAR 0 1
105590: NOT
105591: PUSH
105592: LD_VAR 0 2
105596: NOT
105597: OR
105598: IFFALSE 105602
// exit ;
105600: GO 105828
// x := GetX ( building ) ;
105602: LD_ADDR_VAR 0 4
105606: PUSH
105607: LD_VAR 0 2
105611: PPUSH
105612: CALL_OW 250
105616: ST_TO_ADDR
// y := GetY ( building ) ;
105617: LD_ADDR_VAR 0 6
105621: PUSH
105622: LD_VAR 0 2
105626: PPUSH
105627: CALL_OW 251
105631: ST_TO_ADDR
// d := GetDir ( building ) ;
105632: LD_ADDR_VAR 0 8
105636: PUSH
105637: LD_VAR 0 2
105641: PPUSH
105642: CALL_OW 254
105646: ST_TO_ADDR
// r := 4 ;
105647: LD_ADDR_VAR 0 9
105651: PUSH
105652: LD_INT 4
105654: ST_TO_ADDR
// for i := 1 to 5 do
105655: LD_ADDR_VAR 0 10
105659: PUSH
105660: DOUBLE
105661: LD_INT 1
105663: DEC
105664: ST_TO_ADDR
105665: LD_INT 5
105667: PUSH
105668: FOR_TO
105669: IFFALSE 105826
// begin _x := ShiftX ( x , d , r + i ) ;
105671: LD_ADDR_VAR 0 5
105675: PUSH
105676: LD_VAR 0 4
105680: PPUSH
105681: LD_VAR 0 8
105685: PPUSH
105686: LD_VAR 0 9
105690: PUSH
105691: LD_VAR 0 10
105695: PLUS
105696: PPUSH
105697: CALL_OW 272
105701: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
105702: LD_ADDR_VAR 0 7
105706: PUSH
105707: LD_VAR 0 6
105711: PPUSH
105712: LD_VAR 0 8
105716: PPUSH
105717: LD_VAR 0 9
105721: PUSH
105722: LD_VAR 0 10
105726: PLUS
105727: PPUSH
105728: CALL_OW 273
105732: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
105733: LD_VAR 0 5
105737: PPUSH
105738: LD_VAR 0 7
105742: PPUSH
105743: CALL_OW 488
105747: PUSH
105748: LD_VAR 0 5
105752: PPUSH
105753: LD_VAR 0 7
105757: PPUSH
105758: CALL_OW 428
105762: PPUSH
105763: CALL_OW 247
105767: PUSH
105768: LD_INT 3
105770: PUSH
105771: LD_INT 2
105773: PUSH
105774: EMPTY
105775: LIST
105776: LIST
105777: IN
105778: NOT
105779: AND
105780: IFFALSE 105824
// begin ComMoveXY ( unit , _x , _y ) ;
105782: LD_VAR 0 1
105786: PPUSH
105787: LD_VAR 0 5
105791: PPUSH
105792: LD_VAR 0 7
105796: PPUSH
105797: CALL_OW 111
// result := [ _x , _y ] ;
105801: LD_ADDR_VAR 0 3
105805: PUSH
105806: LD_VAR 0 5
105810: PUSH
105811: LD_VAR 0 7
105815: PUSH
105816: EMPTY
105817: LIST
105818: LIST
105819: ST_TO_ADDR
// exit ;
105820: POP
105821: POP
105822: GO 105828
// end ; end ;
105824: GO 105668
105826: POP
105827: POP
// end ;
105828: LD_VAR 0 3
105832: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
105833: LD_INT 0
105835: PPUSH
105836: PPUSH
105837: PPUSH
// result := 0 ;
105838: LD_ADDR_VAR 0 3
105842: PUSH
105843: LD_INT 0
105845: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
105846: LD_VAR 0 1
105850: PUSH
105851: LD_INT 0
105853: LESS
105854: PUSH
105855: LD_VAR 0 1
105859: PUSH
105860: LD_INT 8
105862: GREATER
105863: OR
105864: PUSH
105865: LD_VAR 0 2
105869: PUSH
105870: LD_INT 0
105872: LESS
105873: OR
105874: PUSH
105875: LD_VAR 0 2
105879: PUSH
105880: LD_INT 8
105882: GREATER
105883: OR
105884: IFFALSE 105888
// exit ;
105886: GO 105963
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
105888: LD_ADDR_VAR 0 4
105892: PUSH
105893: LD_INT 22
105895: PUSH
105896: LD_VAR 0 2
105900: PUSH
105901: EMPTY
105902: LIST
105903: LIST
105904: PPUSH
105905: CALL_OW 69
105909: PUSH
105910: FOR_IN
105911: IFFALSE 105961
// begin un := UnitShoot ( i ) ;
105913: LD_ADDR_VAR 0 5
105917: PUSH
105918: LD_VAR 0 4
105922: PPUSH
105923: CALL_OW 504
105927: ST_TO_ADDR
// if GetSide ( un ) = side1 then
105928: LD_VAR 0 5
105932: PPUSH
105933: CALL_OW 255
105937: PUSH
105938: LD_VAR 0 1
105942: EQUAL
105943: IFFALSE 105959
// begin result := un ;
105945: LD_ADDR_VAR 0 3
105949: PUSH
105950: LD_VAR 0 5
105954: ST_TO_ADDR
// exit ;
105955: POP
105956: POP
105957: GO 105963
// end ; end ;
105959: GO 105910
105961: POP
105962: POP
// end ;
105963: LD_VAR 0 3
105967: RET
// export function GetCargoBay ( units ) ; begin
105968: LD_INT 0
105970: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
105971: LD_ADDR_VAR 0 2
105975: PUSH
105976: LD_VAR 0 1
105980: PPUSH
105981: LD_INT 2
105983: PUSH
105984: LD_INT 34
105986: PUSH
105987: LD_INT 12
105989: PUSH
105990: EMPTY
105991: LIST
105992: LIST
105993: PUSH
105994: LD_INT 34
105996: PUSH
105997: LD_INT 51
105999: PUSH
106000: EMPTY
106001: LIST
106002: LIST
106003: PUSH
106004: LD_INT 34
106006: PUSH
106007: LD_INT 32
106009: PUSH
106010: EMPTY
106011: LIST
106012: LIST
106013: PUSH
106014: LD_INT 34
106016: PUSH
106017: LD_INT 89
106019: PUSH
106020: EMPTY
106021: LIST
106022: LIST
106023: PUSH
106024: EMPTY
106025: LIST
106026: LIST
106027: LIST
106028: LIST
106029: LIST
106030: PPUSH
106031: CALL_OW 72
106035: ST_TO_ADDR
// end ;
106036: LD_VAR 0 2
106040: RET
// export function Negate ( value ) ; begin
106041: LD_INT 0
106043: PPUSH
// result := not value ;
106044: LD_ADDR_VAR 0 2
106048: PUSH
106049: LD_VAR 0 1
106053: NOT
106054: ST_TO_ADDR
// end ;
106055: LD_VAR 0 2
106059: RET
// export function Inc ( value ) ; begin
106060: LD_INT 0
106062: PPUSH
// result := value + 1 ;
106063: LD_ADDR_VAR 0 2
106067: PUSH
106068: LD_VAR 0 1
106072: PUSH
106073: LD_INT 1
106075: PLUS
106076: ST_TO_ADDR
// end ;
106077: LD_VAR 0 2
106081: RET
// export function Dec ( value ) ; begin
106082: LD_INT 0
106084: PPUSH
// result := value - 1 ;
106085: LD_ADDR_VAR 0 2
106089: PUSH
106090: LD_VAR 0 1
106094: PUSH
106095: LD_INT 1
106097: MINUS
106098: ST_TO_ADDR
// end ;
106099: LD_VAR 0 2
106103: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106104: LD_INT 0
106106: PPUSH
106107: PPUSH
106108: PPUSH
106109: PPUSH
106110: PPUSH
106111: PPUSH
106112: PPUSH
106113: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106114: LD_VAR 0 1
106118: PPUSH
106119: LD_VAR 0 2
106123: PPUSH
106124: CALL_OW 488
106128: NOT
106129: PUSH
106130: LD_VAR 0 3
106134: PPUSH
106135: LD_VAR 0 4
106139: PPUSH
106140: CALL_OW 488
106144: NOT
106145: OR
106146: IFFALSE 106159
// begin result := - 1 ;
106148: LD_ADDR_VAR 0 5
106152: PUSH
106153: LD_INT 1
106155: NEG
106156: ST_TO_ADDR
// exit ;
106157: GO 106394
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106159: LD_ADDR_VAR 0 12
106163: PUSH
106164: LD_VAR 0 1
106168: PPUSH
106169: LD_VAR 0 2
106173: PPUSH
106174: LD_VAR 0 3
106178: PPUSH
106179: LD_VAR 0 4
106183: PPUSH
106184: CALL 105244 0 4
106188: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106189: LD_ADDR_VAR 0 11
106193: PUSH
106194: LD_VAR 0 1
106198: PPUSH
106199: LD_VAR 0 2
106203: PPUSH
106204: LD_VAR 0 12
106208: PUSH
106209: LD_INT 1
106211: ARRAY
106212: PPUSH
106213: LD_VAR 0 12
106217: PUSH
106218: LD_INT 2
106220: ARRAY
106221: PPUSH
106222: CALL_OW 298
106226: ST_TO_ADDR
// distance := 9999 ;
106227: LD_ADDR_VAR 0 10
106231: PUSH
106232: LD_INT 9999
106234: ST_TO_ADDR
// for i := 0 to 5 do
106235: LD_ADDR_VAR 0 6
106239: PUSH
106240: DOUBLE
106241: LD_INT 0
106243: DEC
106244: ST_TO_ADDR
106245: LD_INT 5
106247: PUSH
106248: FOR_TO
106249: IFFALSE 106392
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106251: LD_ADDR_VAR 0 7
106255: PUSH
106256: LD_VAR 0 1
106260: PPUSH
106261: LD_VAR 0 6
106265: PPUSH
106266: LD_VAR 0 11
106270: PPUSH
106271: CALL_OW 272
106275: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106276: LD_ADDR_VAR 0 8
106280: PUSH
106281: LD_VAR 0 2
106285: PPUSH
106286: LD_VAR 0 6
106290: PPUSH
106291: LD_VAR 0 11
106295: PPUSH
106296: CALL_OW 273
106300: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106301: LD_VAR 0 7
106305: PPUSH
106306: LD_VAR 0 8
106310: PPUSH
106311: CALL_OW 488
106315: NOT
106316: IFFALSE 106320
// continue ;
106318: GO 106248
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106320: LD_ADDR_VAR 0 9
106324: PUSH
106325: LD_VAR 0 12
106329: PUSH
106330: LD_INT 1
106332: ARRAY
106333: PPUSH
106334: LD_VAR 0 12
106338: PUSH
106339: LD_INT 2
106341: ARRAY
106342: PPUSH
106343: LD_VAR 0 7
106347: PPUSH
106348: LD_VAR 0 8
106352: PPUSH
106353: CALL_OW 298
106357: ST_TO_ADDR
// if tmp < distance then
106358: LD_VAR 0 9
106362: PUSH
106363: LD_VAR 0 10
106367: LESS
106368: IFFALSE 106390
// begin result := i ;
106370: LD_ADDR_VAR 0 5
106374: PUSH
106375: LD_VAR 0 6
106379: ST_TO_ADDR
// distance := tmp ;
106380: LD_ADDR_VAR 0 10
106384: PUSH
106385: LD_VAR 0 9
106389: ST_TO_ADDR
// end ; end ;
106390: GO 106248
106392: POP
106393: POP
// end ;
106394: LD_VAR 0 5
106398: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106399: LD_INT 0
106401: PPUSH
106402: PPUSH
// if not driver or not IsInUnit ( driver ) then
106403: LD_VAR 0 1
106407: NOT
106408: PUSH
106409: LD_VAR 0 1
106413: PPUSH
106414: CALL_OW 310
106418: NOT
106419: OR
106420: IFFALSE 106424
// exit ;
106422: GO 106514
// vehicle := IsInUnit ( driver ) ;
106424: LD_ADDR_VAR 0 3
106428: PUSH
106429: LD_VAR 0 1
106433: PPUSH
106434: CALL_OW 310
106438: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106439: LD_VAR 0 1
106443: PPUSH
106444: LD_STRING \
106446: PUSH
106447: LD_INT 0
106449: PUSH
106450: LD_INT 0
106452: PUSH
106453: LD_INT 0
106455: PUSH
106456: LD_INT 0
106458: PUSH
106459: LD_INT 0
106461: PUSH
106462: LD_INT 0
106464: PUSH
106465: EMPTY
106466: LIST
106467: LIST
106468: LIST
106469: LIST
106470: LIST
106471: LIST
106472: LIST
106473: PUSH
106474: LD_STRING E
106476: PUSH
106477: LD_INT 0
106479: PUSH
106480: LD_INT 0
106482: PUSH
106483: LD_VAR 0 3
106487: PUSH
106488: LD_INT 0
106490: PUSH
106491: LD_INT 0
106493: PUSH
106494: LD_INT 0
106496: PUSH
106497: EMPTY
106498: LIST
106499: LIST
106500: LIST
106501: LIST
106502: LIST
106503: LIST
106504: LIST
106505: PUSH
106506: EMPTY
106507: LIST
106508: LIST
106509: PPUSH
106510: CALL_OW 446
// end ;
106514: LD_VAR 0 2
106518: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106519: LD_INT 0
106521: PPUSH
106522: PPUSH
// if not driver or not IsInUnit ( driver ) then
106523: LD_VAR 0 1
106527: NOT
106528: PUSH
106529: LD_VAR 0 1
106533: PPUSH
106534: CALL_OW 310
106538: NOT
106539: OR
106540: IFFALSE 106544
// exit ;
106542: GO 106634
// vehicle := IsInUnit ( driver ) ;
106544: LD_ADDR_VAR 0 3
106548: PUSH
106549: LD_VAR 0 1
106553: PPUSH
106554: CALL_OW 310
106558: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106559: LD_VAR 0 1
106563: PPUSH
106564: LD_STRING \
106566: PUSH
106567: LD_INT 0
106569: PUSH
106570: LD_INT 0
106572: PUSH
106573: LD_INT 0
106575: PUSH
106576: LD_INT 0
106578: PUSH
106579: LD_INT 0
106581: PUSH
106582: LD_INT 0
106584: PUSH
106585: EMPTY
106586: LIST
106587: LIST
106588: LIST
106589: LIST
106590: LIST
106591: LIST
106592: LIST
106593: PUSH
106594: LD_STRING E
106596: PUSH
106597: LD_INT 0
106599: PUSH
106600: LD_INT 0
106602: PUSH
106603: LD_VAR 0 3
106607: PUSH
106608: LD_INT 0
106610: PUSH
106611: LD_INT 0
106613: PUSH
106614: LD_INT 0
106616: PUSH
106617: EMPTY
106618: LIST
106619: LIST
106620: LIST
106621: LIST
106622: LIST
106623: LIST
106624: LIST
106625: PUSH
106626: EMPTY
106627: LIST
106628: LIST
106629: PPUSH
106630: CALL_OW 447
// end ;
106634: LD_VAR 0 2
106638: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
106639: LD_INT 0
106641: PPUSH
106642: PPUSH
106643: PPUSH
// tmp := [ ] ;
106644: LD_ADDR_VAR 0 5
106648: PUSH
106649: EMPTY
106650: ST_TO_ADDR
// for i in units do
106651: LD_ADDR_VAR 0 4
106655: PUSH
106656: LD_VAR 0 1
106660: PUSH
106661: FOR_IN
106662: IFFALSE 106700
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
106664: LD_ADDR_VAR 0 5
106668: PUSH
106669: LD_VAR 0 5
106673: PPUSH
106674: LD_VAR 0 5
106678: PUSH
106679: LD_INT 1
106681: PLUS
106682: PPUSH
106683: LD_VAR 0 4
106687: PPUSH
106688: CALL_OW 256
106692: PPUSH
106693: CALL_OW 2
106697: ST_TO_ADDR
106698: GO 106661
106700: POP
106701: POP
// if not tmp then
106702: LD_VAR 0 5
106706: NOT
106707: IFFALSE 106711
// exit ;
106709: GO 106759
// if asc then
106711: LD_VAR 0 2
106715: IFFALSE 106739
// result := SortListByListAsc ( units , tmp ) else
106717: LD_ADDR_VAR 0 3
106721: PUSH
106722: LD_VAR 0 1
106726: PPUSH
106727: LD_VAR 0 5
106731: PPUSH
106732: CALL_OW 76
106736: ST_TO_ADDR
106737: GO 106759
// result := SortListByListDesc ( units , tmp ) ;
106739: LD_ADDR_VAR 0 3
106743: PUSH
106744: LD_VAR 0 1
106748: PPUSH
106749: LD_VAR 0 5
106753: PPUSH
106754: CALL_OW 77
106758: ST_TO_ADDR
// end ;
106759: LD_VAR 0 3
106763: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
106764: LD_INT 0
106766: PPUSH
106767: PPUSH
// task := GetTaskList ( mech ) ;
106768: LD_ADDR_VAR 0 4
106772: PUSH
106773: LD_VAR 0 1
106777: PPUSH
106778: CALL_OW 437
106782: ST_TO_ADDR
// if not task then
106783: LD_VAR 0 4
106787: NOT
106788: IFFALSE 106792
// exit ;
106790: GO 106834
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
106792: LD_ADDR_VAR 0 3
106796: PUSH
106797: LD_VAR 0 4
106801: PUSH
106802: LD_INT 1
106804: ARRAY
106805: PUSH
106806: LD_INT 1
106808: ARRAY
106809: PUSH
106810: LD_STRING r
106812: EQUAL
106813: PUSH
106814: LD_VAR 0 4
106818: PUSH
106819: LD_INT 1
106821: ARRAY
106822: PUSH
106823: LD_INT 4
106825: ARRAY
106826: PUSH
106827: LD_VAR 0 2
106831: EQUAL
106832: AND
106833: ST_TO_ADDR
// end ;
106834: LD_VAR 0 3
106838: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
106839: LD_INT 0
106841: PPUSH
// SetDir ( unit , d ) ;
106842: LD_VAR 0 1
106846: PPUSH
106847: LD_VAR 0 4
106851: PPUSH
106852: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
106856: LD_VAR 0 1
106860: PPUSH
106861: LD_VAR 0 2
106865: PPUSH
106866: LD_VAR 0 3
106870: PPUSH
106871: LD_VAR 0 5
106875: PPUSH
106876: CALL_OW 48
// end ;
106880: LD_VAR 0 6
106884: RET
// export function ToNaturalNumber ( number ) ; begin
106885: LD_INT 0
106887: PPUSH
// result := number div 1 ;
106888: LD_ADDR_VAR 0 2
106892: PUSH
106893: LD_VAR 0 1
106897: PUSH
106898: LD_INT 1
106900: DIV
106901: ST_TO_ADDR
// if number < 0 then
106902: LD_VAR 0 1
106906: PUSH
106907: LD_INT 0
106909: LESS
106910: IFFALSE 106920
// result := 0 ;
106912: LD_ADDR_VAR 0 2
106916: PUSH
106917: LD_INT 0
106919: ST_TO_ADDR
// end ;
106920: LD_VAR 0 2
106924: RET
// export function SortByClass ( units , class ) ; var un ; begin
106925: LD_INT 0
106927: PPUSH
106928: PPUSH
// if not units or not class then
106929: LD_VAR 0 1
106933: NOT
106934: PUSH
106935: LD_VAR 0 2
106939: NOT
106940: OR
106941: IFFALSE 106945
// exit ;
106943: GO 107040
// result := [ ] ;
106945: LD_ADDR_VAR 0 3
106949: PUSH
106950: EMPTY
106951: ST_TO_ADDR
// for un in units do
106952: LD_ADDR_VAR 0 4
106956: PUSH
106957: LD_VAR 0 1
106961: PUSH
106962: FOR_IN
106963: IFFALSE 107038
// if GetClass ( un ) = class then
106965: LD_VAR 0 4
106969: PPUSH
106970: CALL_OW 257
106974: PUSH
106975: LD_VAR 0 2
106979: EQUAL
106980: IFFALSE 107007
// result := Insert ( result , 1 , un ) else
106982: LD_ADDR_VAR 0 3
106986: PUSH
106987: LD_VAR 0 3
106991: PPUSH
106992: LD_INT 1
106994: PPUSH
106995: LD_VAR 0 4
106999: PPUSH
107000: CALL_OW 2
107004: ST_TO_ADDR
107005: GO 107036
// result := Replace ( result , result + 1 , un ) ;
107007: LD_ADDR_VAR 0 3
107011: PUSH
107012: LD_VAR 0 3
107016: PPUSH
107017: LD_VAR 0 3
107021: PUSH
107022: LD_INT 1
107024: PLUS
107025: PPUSH
107026: LD_VAR 0 4
107030: PPUSH
107031: CALL_OW 1
107035: ST_TO_ADDR
107036: GO 106962
107038: POP
107039: POP
// end ;
107040: LD_VAR 0 3
107044: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
107045: LD_INT 0
107047: PPUSH
107048: PPUSH
107049: PPUSH
107050: PPUSH
107051: PPUSH
107052: PPUSH
107053: PPUSH
// result := [ ] ;
107054: LD_ADDR_VAR 0 4
107058: PUSH
107059: EMPTY
107060: ST_TO_ADDR
// if x - r < 0 then
107061: LD_VAR 0 1
107065: PUSH
107066: LD_VAR 0 3
107070: MINUS
107071: PUSH
107072: LD_INT 0
107074: LESS
107075: IFFALSE 107087
// min_x := 0 else
107077: LD_ADDR_VAR 0 8
107081: PUSH
107082: LD_INT 0
107084: ST_TO_ADDR
107085: GO 107103
// min_x := x - r ;
107087: LD_ADDR_VAR 0 8
107091: PUSH
107092: LD_VAR 0 1
107096: PUSH
107097: LD_VAR 0 3
107101: MINUS
107102: ST_TO_ADDR
// if y - r < 0 then
107103: LD_VAR 0 2
107107: PUSH
107108: LD_VAR 0 3
107112: MINUS
107113: PUSH
107114: LD_INT 0
107116: LESS
107117: IFFALSE 107129
// min_y := 0 else
107119: LD_ADDR_VAR 0 7
107123: PUSH
107124: LD_INT 0
107126: ST_TO_ADDR
107127: GO 107145
// min_y := y - r ;
107129: LD_ADDR_VAR 0 7
107133: PUSH
107134: LD_VAR 0 2
107138: PUSH
107139: LD_VAR 0 3
107143: MINUS
107144: ST_TO_ADDR
// max_x := x + r ;
107145: LD_ADDR_VAR 0 9
107149: PUSH
107150: LD_VAR 0 1
107154: PUSH
107155: LD_VAR 0 3
107159: PLUS
107160: ST_TO_ADDR
// max_y := y + r ;
107161: LD_ADDR_VAR 0 10
107165: PUSH
107166: LD_VAR 0 2
107170: PUSH
107171: LD_VAR 0 3
107175: PLUS
107176: ST_TO_ADDR
// for _x = min_x to max_x do
107177: LD_ADDR_VAR 0 5
107181: PUSH
107182: DOUBLE
107183: LD_VAR 0 8
107187: DEC
107188: ST_TO_ADDR
107189: LD_VAR 0 9
107193: PUSH
107194: FOR_TO
107195: IFFALSE 107296
// for _y = min_y to max_y do
107197: LD_ADDR_VAR 0 6
107201: PUSH
107202: DOUBLE
107203: LD_VAR 0 7
107207: DEC
107208: ST_TO_ADDR
107209: LD_VAR 0 10
107213: PUSH
107214: FOR_TO
107215: IFFALSE 107292
// begin if not ValidHex ( _x , _y ) then
107217: LD_VAR 0 5
107221: PPUSH
107222: LD_VAR 0 6
107226: PPUSH
107227: CALL_OW 488
107231: NOT
107232: IFFALSE 107236
// continue ;
107234: GO 107214
// if GetResourceTypeXY ( _x , _y ) then
107236: LD_VAR 0 5
107240: PPUSH
107241: LD_VAR 0 6
107245: PPUSH
107246: CALL_OW 283
107250: IFFALSE 107290
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107252: LD_ADDR_VAR 0 4
107256: PUSH
107257: LD_VAR 0 4
107261: PPUSH
107262: LD_VAR 0 4
107266: PUSH
107267: LD_INT 1
107269: PLUS
107270: PPUSH
107271: LD_VAR 0 5
107275: PUSH
107276: LD_VAR 0 6
107280: PUSH
107281: EMPTY
107282: LIST
107283: LIST
107284: PPUSH
107285: CALL_OW 1
107289: ST_TO_ADDR
// end ;
107290: GO 107214
107292: POP
107293: POP
107294: GO 107194
107296: POP
107297: POP
// end ;
107298: LD_VAR 0 4
107302: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107303: LD_INT 0
107305: PPUSH
107306: PPUSH
107307: PPUSH
107308: PPUSH
107309: PPUSH
107310: PPUSH
107311: PPUSH
107312: PPUSH
// if not units then
107313: LD_VAR 0 1
107317: NOT
107318: IFFALSE 107322
// exit ;
107320: GO 107846
// result := UnitFilter ( units , [ f_ok ] ) ;
107322: LD_ADDR_VAR 0 3
107326: PUSH
107327: LD_VAR 0 1
107331: PPUSH
107332: LD_INT 50
107334: PUSH
107335: EMPTY
107336: LIST
107337: PPUSH
107338: CALL_OW 72
107342: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107343: LD_ADDR_VAR 0 8
107347: PUSH
107348: LD_VAR 0 1
107352: PUSH
107353: LD_INT 1
107355: ARRAY
107356: PPUSH
107357: CALL_OW 255
107361: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107362: LD_ADDR_VAR 0 10
107366: PUSH
107367: LD_INT 29
107369: PUSH
107370: LD_INT 91
107372: PUSH
107373: LD_INT 49
107375: PUSH
107376: EMPTY
107377: LIST
107378: LIST
107379: LIST
107380: ST_TO_ADDR
// if not result then
107381: LD_VAR 0 3
107385: NOT
107386: IFFALSE 107390
// exit ;
107388: GO 107846
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107390: LD_ADDR_VAR 0 5
107394: PUSH
107395: LD_INT 81
107397: PUSH
107398: LD_VAR 0 8
107402: PUSH
107403: EMPTY
107404: LIST
107405: LIST
107406: PPUSH
107407: CALL_OW 69
107411: ST_TO_ADDR
// for i in result do
107412: LD_ADDR_VAR 0 4
107416: PUSH
107417: LD_VAR 0 3
107421: PUSH
107422: FOR_IN
107423: IFFALSE 107844
// begin tag := GetTag ( i ) + 1 ;
107425: LD_ADDR_VAR 0 9
107429: PUSH
107430: LD_VAR 0 4
107434: PPUSH
107435: CALL_OW 110
107439: PUSH
107440: LD_INT 1
107442: PLUS
107443: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
107444: LD_ADDR_VAR 0 7
107448: PUSH
107449: LD_VAR 0 4
107453: PPUSH
107454: CALL_OW 250
107458: PPUSH
107459: LD_VAR 0 4
107463: PPUSH
107464: CALL_OW 251
107468: PPUSH
107469: LD_INT 6
107471: PPUSH
107472: CALL 107045 0 3
107476: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
107477: LD_VAR 0 4
107481: PPUSH
107482: CALL_OW 247
107486: PUSH
107487: LD_INT 2
107489: EQUAL
107490: PUSH
107491: LD_VAR 0 7
107495: AND
107496: PUSH
107497: LD_VAR 0 4
107501: PPUSH
107502: CALL_OW 264
107506: PUSH
107507: LD_VAR 0 10
107511: IN
107512: NOT
107513: AND
107514: IFFALSE 107553
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
107516: LD_VAR 0 4
107520: PPUSH
107521: LD_VAR 0 7
107525: PUSH
107526: LD_INT 1
107528: ARRAY
107529: PUSH
107530: LD_INT 1
107532: ARRAY
107533: PPUSH
107534: LD_VAR 0 7
107538: PUSH
107539: LD_INT 1
107541: ARRAY
107542: PUSH
107543: LD_INT 2
107545: ARRAY
107546: PPUSH
107547: CALL_OW 116
107551: GO 107842
// if path > tag then
107553: LD_VAR 0 2
107557: PUSH
107558: LD_VAR 0 9
107562: GREATER
107563: IFFALSE 107771
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
107565: LD_ADDR_VAR 0 6
107569: PUSH
107570: LD_VAR 0 5
107574: PPUSH
107575: LD_INT 91
107577: PUSH
107578: LD_VAR 0 4
107582: PUSH
107583: LD_INT 8
107585: PUSH
107586: EMPTY
107587: LIST
107588: LIST
107589: LIST
107590: PPUSH
107591: CALL_OW 72
107595: ST_TO_ADDR
// if nearEnemy then
107596: LD_VAR 0 6
107600: IFFALSE 107669
// begin if GetWeapon ( i ) = ru_time_lapser then
107602: LD_VAR 0 4
107606: PPUSH
107607: CALL_OW 264
107611: PUSH
107612: LD_INT 49
107614: EQUAL
107615: IFFALSE 107643
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
107617: LD_VAR 0 4
107621: PPUSH
107622: LD_VAR 0 6
107626: PPUSH
107627: LD_VAR 0 4
107631: PPUSH
107632: CALL_OW 74
107636: PPUSH
107637: CALL_OW 112
107641: GO 107667
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
107643: LD_VAR 0 4
107647: PPUSH
107648: LD_VAR 0 6
107652: PPUSH
107653: LD_VAR 0 4
107657: PPUSH
107658: CALL_OW 74
107662: PPUSH
107663: CALL_OW 115
// end else
107667: GO 107769
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
107669: LD_VAR 0 4
107673: PPUSH
107674: LD_VAR 0 2
107678: PUSH
107679: LD_VAR 0 9
107683: ARRAY
107684: PUSH
107685: LD_INT 1
107687: ARRAY
107688: PPUSH
107689: LD_VAR 0 2
107693: PUSH
107694: LD_VAR 0 9
107698: ARRAY
107699: PUSH
107700: LD_INT 2
107702: ARRAY
107703: PPUSH
107704: CALL_OW 297
107708: PUSH
107709: LD_INT 6
107711: GREATER
107712: IFFALSE 107755
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
107714: LD_VAR 0 4
107718: PPUSH
107719: LD_VAR 0 2
107723: PUSH
107724: LD_VAR 0 9
107728: ARRAY
107729: PUSH
107730: LD_INT 1
107732: ARRAY
107733: PPUSH
107734: LD_VAR 0 2
107738: PUSH
107739: LD_VAR 0 9
107743: ARRAY
107744: PUSH
107745: LD_INT 2
107747: ARRAY
107748: PPUSH
107749: CALL_OW 114
107753: GO 107769
// SetTag ( i , tag ) ;
107755: LD_VAR 0 4
107759: PPUSH
107760: LD_VAR 0 9
107764: PPUSH
107765: CALL_OW 109
// end else
107769: GO 107842
// if enemy then
107771: LD_VAR 0 5
107775: IFFALSE 107842
// begin if GetWeapon ( i ) = ru_time_lapser then
107777: LD_VAR 0 4
107781: PPUSH
107782: CALL_OW 264
107786: PUSH
107787: LD_INT 49
107789: EQUAL
107790: IFFALSE 107818
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
107792: LD_VAR 0 4
107796: PPUSH
107797: LD_VAR 0 5
107801: PPUSH
107802: LD_VAR 0 4
107806: PPUSH
107807: CALL_OW 74
107811: PPUSH
107812: CALL_OW 112
107816: GO 107842
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
107818: LD_VAR 0 4
107822: PPUSH
107823: LD_VAR 0 5
107827: PPUSH
107828: LD_VAR 0 4
107832: PPUSH
107833: CALL_OW 74
107837: PPUSH
107838: CALL_OW 115
// end ; end ;
107842: GO 107422
107844: POP
107845: POP
// end ;
107846: LD_VAR 0 3
107850: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
107851: LD_INT 0
107853: PPUSH
107854: PPUSH
107855: PPUSH
// if not unit or IsInUnit ( unit ) then
107856: LD_VAR 0 1
107860: NOT
107861: PUSH
107862: LD_VAR 0 1
107866: PPUSH
107867: CALL_OW 310
107871: OR
107872: IFFALSE 107876
// exit ;
107874: GO 107967
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
107876: LD_ADDR_VAR 0 4
107880: PUSH
107881: LD_VAR 0 1
107885: PPUSH
107886: CALL_OW 250
107890: PPUSH
107891: LD_VAR 0 2
107895: PPUSH
107896: LD_INT 1
107898: PPUSH
107899: CALL_OW 272
107903: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
107904: LD_ADDR_VAR 0 5
107908: PUSH
107909: LD_VAR 0 1
107913: PPUSH
107914: CALL_OW 251
107918: PPUSH
107919: LD_VAR 0 2
107923: PPUSH
107924: LD_INT 1
107926: PPUSH
107927: CALL_OW 273
107931: ST_TO_ADDR
// if ValidHex ( x , y ) then
107932: LD_VAR 0 4
107936: PPUSH
107937: LD_VAR 0 5
107941: PPUSH
107942: CALL_OW 488
107946: IFFALSE 107967
// ComTurnXY ( unit , x , y ) ;
107948: LD_VAR 0 1
107952: PPUSH
107953: LD_VAR 0 4
107957: PPUSH
107958: LD_VAR 0 5
107962: PPUSH
107963: CALL_OW 118
// end ;
107967: LD_VAR 0 3
107971: RET
// export function SeeUnits ( side , units ) ; var i ; begin
107972: LD_INT 0
107974: PPUSH
107975: PPUSH
// result := false ;
107976: LD_ADDR_VAR 0 3
107980: PUSH
107981: LD_INT 0
107983: ST_TO_ADDR
// if not units then
107984: LD_VAR 0 2
107988: NOT
107989: IFFALSE 107993
// exit ;
107991: GO 108038
// for i in units do
107993: LD_ADDR_VAR 0 4
107997: PUSH
107998: LD_VAR 0 2
108002: PUSH
108003: FOR_IN
108004: IFFALSE 108036
// if See ( side , i ) then
108006: LD_VAR 0 1
108010: PPUSH
108011: LD_VAR 0 4
108015: PPUSH
108016: CALL_OW 292
108020: IFFALSE 108034
// begin result := true ;
108022: LD_ADDR_VAR 0 3
108026: PUSH
108027: LD_INT 1
108029: ST_TO_ADDR
// exit ;
108030: POP
108031: POP
108032: GO 108038
// end ;
108034: GO 108003
108036: POP
108037: POP
// end ;
108038: LD_VAR 0 3
108042: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
108043: LD_INT 0
108045: PPUSH
108046: PPUSH
108047: PPUSH
108048: PPUSH
// if not unit or not points then
108049: LD_VAR 0 1
108053: NOT
108054: PUSH
108055: LD_VAR 0 2
108059: NOT
108060: OR
108061: IFFALSE 108065
// exit ;
108063: GO 108155
// dist := 99999 ;
108065: LD_ADDR_VAR 0 5
108069: PUSH
108070: LD_INT 99999
108072: ST_TO_ADDR
// for i in points do
108073: LD_ADDR_VAR 0 4
108077: PUSH
108078: LD_VAR 0 2
108082: PUSH
108083: FOR_IN
108084: IFFALSE 108153
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108086: LD_ADDR_VAR 0 6
108090: PUSH
108091: LD_VAR 0 1
108095: PPUSH
108096: LD_VAR 0 4
108100: PUSH
108101: LD_INT 1
108103: ARRAY
108104: PPUSH
108105: LD_VAR 0 4
108109: PUSH
108110: LD_INT 2
108112: ARRAY
108113: PPUSH
108114: CALL_OW 297
108118: ST_TO_ADDR
// if tmpDist < dist then
108119: LD_VAR 0 6
108123: PUSH
108124: LD_VAR 0 5
108128: LESS
108129: IFFALSE 108151
// begin result := i ;
108131: LD_ADDR_VAR 0 3
108135: PUSH
108136: LD_VAR 0 4
108140: ST_TO_ADDR
// dist := tmpDist ;
108141: LD_ADDR_VAR 0 5
108145: PUSH
108146: LD_VAR 0 6
108150: ST_TO_ADDR
// end ; end ;
108151: GO 108083
108153: POP
108154: POP
// end ;
108155: LD_VAR 0 3
108159: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108160: LD_INT 0
108162: PPUSH
// uc_side := side ;
108163: LD_ADDR_OWVAR 20
108167: PUSH
108168: LD_VAR 0 1
108172: ST_TO_ADDR
// uc_nation := 3 ;
108173: LD_ADDR_OWVAR 21
108177: PUSH
108178: LD_INT 3
108180: ST_TO_ADDR
// vc_chassis := 25 ;
108181: LD_ADDR_OWVAR 37
108185: PUSH
108186: LD_INT 25
108188: ST_TO_ADDR
// vc_engine := engine_siberite ;
108189: LD_ADDR_OWVAR 39
108193: PUSH
108194: LD_INT 3
108196: ST_TO_ADDR
// vc_control := control_computer ;
108197: LD_ADDR_OWVAR 38
108201: PUSH
108202: LD_INT 3
108204: ST_TO_ADDR
// vc_weapon := 59 ;
108205: LD_ADDR_OWVAR 40
108209: PUSH
108210: LD_INT 59
108212: ST_TO_ADDR
// result := CreateVehicle ;
108213: LD_ADDR_VAR 0 5
108217: PUSH
108218: CALL_OW 45
108222: ST_TO_ADDR
// SetDir ( result , d ) ;
108223: LD_VAR 0 5
108227: PPUSH
108228: LD_VAR 0 4
108232: PPUSH
108233: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108237: LD_VAR 0 5
108241: PPUSH
108242: LD_VAR 0 2
108246: PPUSH
108247: LD_VAR 0 3
108251: PPUSH
108252: LD_INT 0
108254: PPUSH
108255: CALL_OW 48
// end ;
108259: LD_VAR 0 5
108263: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108264: LD_INT 0
108266: PPUSH
108267: PPUSH
108268: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108269: LD_ADDR_VAR 0 2
108273: PUSH
108274: LD_INT 0
108276: PUSH
108277: LD_INT 0
108279: PUSH
108280: LD_INT 0
108282: PUSH
108283: LD_INT 0
108285: PUSH
108286: EMPTY
108287: LIST
108288: LIST
108289: LIST
108290: LIST
108291: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108292: LD_VAR 0 1
108296: NOT
108297: PUSH
108298: LD_VAR 0 1
108302: PPUSH
108303: CALL_OW 264
108307: PUSH
108308: LD_INT 12
108310: PUSH
108311: LD_INT 51
108313: PUSH
108314: LD_INT 32
108316: PUSH
108317: LD_INT 89
108319: PUSH
108320: EMPTY
108321: LIST
108322: LIST
108323: LIST
108324: LIST
108325: IN
108326: NOT
108327: OR
108328: IFFALSE 108332
// exit ;
108330: GO 108430
// for i := 1 to 3 do
108332: LD_ADDR_VAR 0 3
108336: PUSH
108337: DOUBLE
108338: LD_INT 1
108340: DEC
108341: ST_TO_ADDR
108342: LD_INT 3
108344: PUSH
108345: FOR_TO
108346: IFFALSE 108428
// begin tmp := GetCargo ( cargo , i ) ;
108348: LD_ADDR_VAR 0 4
108352: PUSH
108353: LD_VAR 0 1
108357: PPUSH
108358: LD_VAR 0 3
108362: PPUSH
108363: CALL_OW 289
108367: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108368: LD_ADDR_VAR 0 2
108372: PUSH
108373: LD_VAR 0 2
108377: PPUSH
108378: LD_VAR 0 3
108382: PPUSH
108383: LD_VAR 0 4
108387: PPUSH
108388: CALL_OW 1
108392: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108393: LD_ADDR_VAR 0 2
108397: PUSH
108398: LD_VAR 0 2
108402: PPUSH
108403: LD_INT 4
108405: PPUSH
108406: LD_VAR 0 2
108410: PUSH
108411: LD_INT 4
108413: ARRAY
108414: PUSH
108415: LD_VAR 0 4
108419: PLUS
108420: PPUSH
108421: CALL_OW 1
108425: ST_TO_ADDR
// end ;
108426: GO 108345
108428: POP
108429: POP
// end ;
108430: LD_VAR 0 2
108434: RET
// export function Length ( array ) ; begin
108435: LD_INT 0
108437: PPUSH
// result := array + 0 ;
108438: LD_ADDR_VAR 0 2
108442: PUSH
108443: LD_VAR 0 1
108447: PUSH
108448: LD_INT 0
108450: PLUS
108451: ST_TO_ADDR
// end ;
108452: LD_VAR 0 2
108456: RET
// export function PrepareArray ( array ) ; begin
108457: LD_INT 0
108459: PPUSH
// result := array diff 0 ;
108460: LD_ADDR_VAR 0 2
108464: PUSH
108465: LD_VAR 0 1
108469: PUSH
108470: LD_INT 0
108472: DIFF
108473: ST_TO_ADDR
// if not result [ 1 ] then
108474: LD_VAR 0 2
108478: PUSH
108479: LD_INT 1
108481: ARRAY
108482: NOT
108483: IFFALSE 108503
// result := Delete ( result , 1 ) ;
108485: LD_ADDR_VAR 0 2
108489: PUSH
108490: LD_VAR 0 2
108494: PPUSH
108495: LD_INT 1
108497: PPUSH
108498: CALL_OW 3
108502: ST_TO_ADDR
// end ;
108503: LD_VAR 0 2
108507: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
108508: LD_INT 0
108510: PPUSH
108511: PPUSH
108512: PPUSH
108513: PPUSH
// sibRocketRange := 25 ;
108514: LD_ADDR_VAR 0 6
108518: PUSH
108519: LD_INT 25
108521: ST_TO_ADDR
// result := false ;
108522: LD_ADDR_VAR 0 4
108526: PUSH
108527: LD_INT 0
108529: ST_TO_ADDR
// for i := 0 to 5 do
108530: LD_ADDR_VAR 0 5
108534: PUSH
108535: DOUBLE
108536: LD_INT 0
108538: DEC
108539: ST_TO_ADDR
108540: LD_INT 5
108542: PUSH
108543: FOR_TO
108544: IFFALSE 108611
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
108546: LD_VAR 0 1
108550: PPUSH
108551: LD_VAR 0 5
108555: PPUSH
108556: LD_VAR 0 6
108560: PPUSH
108561: CALL_OW 272
108565: PPUSH
108566: LD_VAR 0 2
108570: PPUSH
108571: LD_VAR 0 5
108575: PPUSH
108576: LD_VAR 0 6
108580: PPUSH
108581: CALL_OW 273
108585: PPUSH
108586: LD_VAR 0 3
108590: PPUSH
108591: CALL_OW 309
108595: IFFALSE 108609
// begin result := true ;
108597: LD_ADDR_VAR 0 4
108601: PUSH
108602: LD_INT 1
108604: ST_TO_ADDR
// exit ;
108605: POP
108606: POP
108607: GO 108613
// end ;
108609: GO 108543
108611: POP
108612: POP
// end ; end_of_file end_of_file
108613: LD_VAR 0 4
108617: RET
// every 0 0$1 do
108618: GO 108620
108620: DISABLE
// begin enable ;
108621: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
108622: LD_STRING updateTimer(
108624: PUSH
108625: LD_OWVAR 1
108629: STR
108630: PUSH
108631: LD_STRING );
108633: STR
108634: PPUSH
108635: CALL_OW 559
// end ;
108639: END
// export function SOS_MapStart ( ) ; begin
108640: LD_INT 0
108642: PPUSH
// if streamModeActive then
108643: LD_EXP 143
108647: IFFALSE 108656
// DefineStreamItems ( true ) ;
108649: LD_INT 1
108651: PPUSH
108652: CALL 110310 0 1
// UpdateFactoryWaypoints ( ) ;
108656: CALL 123171 0 0
// UpdateWarehouseGatheringPoints ( ) ;
108660: CALL 123428 0 0
// end ;
108664: LD_VAR 0 1
108668: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108669: LD_INT 0
108671: PPUSH
// if p2 = 100 then
108672: LD_VAR 0 2
108676: PUSH
108677: LD_INT 100
108679: EQUAL
108680: IFFALSE 109683
// begin if not StreamModeActive then
108682: LD_EXP 143
108686: NOT
108687: IFFALSE 108697
// StreamModeActive := true ;
108689: LD_ADDR_EXP 143
108693: PUSH
108694: LD_INT 1
108696: ST_TO_ADDR
// if p3 = 0 then
108697: LD_VAR 0 3
108701: PUSH
108702: LD_INT 0
108704: EQUAL
108705: IFFALSE 108711
// InitStreamMode ;
108707: CALL 109846 0 0
// if p3 = 1 then
108711: LD_VAR 0 3
108715: PUSH
108716: LD_INT 1
108718: EQUAL
108719: IFFALSE 108729
// sRocket := true ;
108721: LD_ADDR_EXP 148
108725: PUSH
108726: LD_INT 1
108728: ST_TO_ADDR
// if p3 = 2 then
108729: LD_VAR 0 3
108733: PUSH
108734: LD_INT 2
108736: EQUAL
108737: IFFALSE 108747
// sSpeed := true ;
108739: LD_ADDR_EXP 147
108743: PUSH
108744: LD_INT 1
108746: ST_TO_ADDR
// if p3 = 3 then
108747: LD_VAR 0 3
108751: PUSH
108752: LD_INT 3
108754: EQUAL
108755: IFFALSE 108765
// sEngine := true ;
108757: LD_ADDR_EXP 149
108761: PUSH
108762: LD_INT 1
108764: ST_TO_ADDR
// if p3 = 4 then
108765: LD_VAR 0 3
108769: PUSH
108770: LD_INT 4
108772: EQUAL
108773: IFFALSE 108783
// sSpec := true ;
108775: LD_ADDR_EXP 146
108779: PUSH
108780: LD_INT 1
108782: ST_TO_ADDR
// if p3 = 5 then
108783: LD_VAR 0 3
108787: PUSH
108788: LD_INT 5
108790: EQUAL
108791: IFFALSE 108801
// sLevel := true ;
108793: LD_ADDR_EXP 150
108797: PUSH
108798: LD_INT 1
108800: ST_TO_ADDR
// if p3 = 6 then
108801: LD_VAR 0 3
108805: PUSH
108806: LD_INT 6
108808: EQUAL
108809: IFFALSE 108819
// sArmoury := true ;
108811: LD_ADDR_EXP 151
108815: PUSH
108816: LD_INT 1
108818: ST_TO_ADDR
// if p3 = 7 then
108819: LD_VAR 0 3
108823: PUSH
108824: LD_INT 7
108826: EQUAL
108827: IFFALSE 108837
// sRadar := true ;
108829: LD_ADDR_EXP 152
108833: PUSH
108834: LD_INT 1
108836: ST_TO_ADDR
// if p3 = 8 then
108837: LD_VAR 0 3
108841: PUSH
108842: LD_INT 8
108844: EQUAL
108845: IFFALSE 108855
// sBunker := true ;
108847: LD_ADDR_EXP 153
108851: PUSH
108852: LD_INT 1
108854: ST_TO_ADDR
// if p3 = 9 then
108855: LD_VAR 0 3
108859: PUSH
108860: LD_INT 9
108862: EQUAL
108863: IFFALSE 108873
// sHack := true ;
108865: LD_ADDR_EXP 154
108869: PUSH
108870: LD_INT 1
108872: ST_TO_ADDR
// if p3 = 10 then
108873: LD_VAR 0 3
108877: PUSH
108878: LD_INT 10
108880: EQUAL
108881: IFFALSE 108891
// sFire := true ;
108883: LD_ADDR_EXP 155
108887: PUSH
108888: LD_INT 1
108890: ST_TO_ADDR
// if p3 = 11 then
108891: LD_VAR 0 3
108895: PUSH
108896: LD_INT 11
108898: EQUAL
108899: IFFALSE 108909
// sRefresh := true ;
108901: LD_ADDR_EXP 156
108905: PUSH
108906: LD_INT 1
108908: ST_TO_ADDR
// if p3 = 12 then
108909: LD_VAR 0 3
108913: PUSH
108914: LD_INT 12
108916: EQUAL
108917: IFFALSE 108927
// sExp := true ;
108919: LD_ADDR_EXP 157
108923: PUSH
108924: LD_INT 1
108926: ST_TO_ADDR
// if p3 = 13 then
108927: LD_VAR 0 3
108931: PUSH
108932: LD_INT 13
108934: EQUAL
108935: IFFALSE 108945
// sDepot := true ;
108937: LD_ADDR_EXP 158
108941: PUSH
108942: LD_INT 1
108944: ST_TO_ADDR
// if p3 = 14 then
108945: LD_VAR 0 3
108949: PUSH
108950: LD_INT 14
108952: EQUAL
108953: IFFALSE 108963
// sFlag := true ;
108955: LD_ADDR_EXP 159
108959: PUSH
108960: LD_INT 1
108962: ST_TO_ADDR
// if p3 = 15 then
108963: LD_VAR 0 3
108967: PUSH
108968: LD_INT 15
108970: EQUAL
108971: IFFALSE 108981
// sKamikadze := true ;
108973: LD_ADDR_EXP 167
108977: PUSH
108978: LD_INT 1
108980: ST_TO_ADDR
// if p3 = 16 then
108981: LD_VAR 0 3
108985: PUSH
108986: LD_INT 16
108988: EQUAL
108989: IFFALSE 108999
// sTroll := true ;
108991: LD_ADDR_EXP 168
108995: PUSH
108996: LD_INT 1
108998: ST_TO_ADDR
// if p3 = 17 then
108999: LD_VAR 0 3
109003: PUSH
109004: LD_INT 17
109006: EQUAL
109007: IFFALSE 109017
// sSlow := true ;
109009: LD_ADDR_EXP 169
109013: PUSH
109014: LD_INT 1
109016: ST_TO_ADDR
// if p3 = 18 then
109017: LD_VAR 0 3
109021: PUSH
109022: LD_INT 18
109024: EQUAL
109025: IFFALSE 109035
// sLack := true ;
109027: LD_ADDR_EXP 170
109031: PUSH
109032: LD_INT 1
109034: ST_TO_ADDR
// if p3 = 19 then
109035: LD_VAR 0 3
109039: PUSH
109040: LD_INT 19
109042: EQUAL
109043: IFFALSE 109053
// sTank := true ;
109045: LD_ADDR_EXP 172
109049: PUSH
109050: LD_INT 1
109052: ST_TO_ADDR
// if p3 = 20 then
109053: LD_VAR 0 3
109057: PUSH
109058: LD_INT 20
109060: EQUAL
109061: IFFALSE 109071
// sRemote := true ;
109063: LD_ADDR_EXP 173
109067: PUSH
109068: LD_INT 1
109070: ST_TO_ADDR
// if p3 = 21 then
109071: LD_VAR 0 3
109075: PUSH
109076: LD_INT 21
109078: EQUAL
109079: IFFALSE 109089
// sPowell := true ;
109081: LD_ADDR_EXP 174
109085: PUSH
109086: LD_INT 1
109088: ST_TO_ADDR
// if p3 = 22 then
109089: LD_VAR 0 3
109093: PUSH
109094: LD_INT 22
109096: EQUAL
109097: IFFALSE 109107
// sTeleport := true ;
109099: LD_ADDR_EXP 177
109103: PUSH
109104: LD_INT 1
109106: ST_TO_ADDR
// if p3 = 23 then
109107: LD_VAR 0 3
109111: PUSH
109112: LD_INT 23
109114: EQUAL
109115: IFFALSE 109125
// sOilTower := true ;
109117: LD_ADDR_EXP 179
109121: PUSH
109122: LD_INT 1
109124: ST_TO_ADDR
// if p3 = 24 then
109125: LD_VAR 0 3
109129: PUSH
109130: LD_INT 24
109132: EQUAL
109133: IFFALSE 109143
// sShovel := true ;
109135: LD_ADDR_EXP 180
109139: PUSH
109140: LD_INT 1
109142: ST_TO_ADDR
// if p3 = 25 then
109143: LD_VAR 0 3
109147: PUSH
109148: LD_INT 25
109150: EQUAL
109151: IFFALSE 109161
// sSheik := true ;
109153: LD_ADDR_EXP 181
109157: PUSH
109158: LD_INT 1
109160: ST_TO_ADDR
// if p3 = 26 then
109161: LD_VAR 0 3
109165: PUSH
109166: LD_INT 26
109168: EQUAL
109169: IFFALSE 109179
// sEarthquake := true ;
109171: LD_ADDR_EXP 183
109175: PUSH
109176: LD_INT 1
109178: ST_TO_ADDR
// if p3 = 27 then
109179: LD_VAR 0 3
109183: PUSH
109184: LD_INT 27
109186: EQUAL
109187: IFFALSE 109197
// sAI := true ;
109189: LD_ADDR_EXP 184
109193: PUSH
109194: LD_INT 1
109196: ST_TO_ADDR
// if p3 = 28 then
109197: LD_VAR 0 3
109201: PUSH
109202: LD_INT 28
109204: EQUAL
109205: IFFALSE 109215
// sCargo := true ;
109207: LD_ADDR_EXP 187
109211: PUSH
109212: LD_INT 1
109214: ST_TO_ADDR
// if p3 = 29 then
109215: LD_VAR 0 3
109219: PUSH
109220: LD_INT 29
109222: EQUAL
109223: IFFALSE 109233
// sDLaser := true ;
109225: LD_ADDR_EXP 188
109229: PUSH
109230: LD_INT 1
109232: ST_TO_ADDR
// if p3 = 30 then
109233: LD_VAR 0 3
109237: PUSH
109238: LD_INT 30
109240: EQUAL
109241: IFFALSE 109251
// sExchange := true ;
109243: LD_ADDR_EXP 189
109247: PUSH
109248: LD_INT 1
109250: ST_TO_ADDR
// if p3 = 31 then
109251: LD_VAR 0 3
109255: PUSH
109256: LD_INT 31
109258: EQUAL
109259: IFFALSE 109269
// sFac := true ;
109261: LD_ADDR_EXP 190
109265: PUSH
109266: LD_INT 1
109268: ST_TO_ADDR
// if p3 = 32 then
109269: LD_VAR 0 3
109273: PUSH
109274: LD_INT 32
109276: EQUAL
109277: IFFALSE 109287
// sPower := true ;
109279: LD_ADDR_EXP 191
109283: PUSH
109284: LD_INT 1
109286: ST_TO_ADDR
// if p3 = 33 then
109287: LD_VAR 0 3
109291: PUSH
109292: LD_INT 33
109294: EQUAL
109295: IFFALSE 109305
// sRandom := true ;
109297: LD_ADDR_EXP 192
109301: PUSH
109302: LD_INT 1
109304: ST_TO_ADDR
// if p3 = 34 then
109305: LD_VAR 0 3
109309: PUSH
109310: LD_INT 34
109312: EQUAL
109313: IFFALSE 109323
// sShield := true ;
109315: LD_ADDR_EXP 193
109319: PUSH
109320: LD_INT 1
109322: ST_TO_ADDR
// if p3 = 35 then
109323: LD_VAR 0 3
109327: PUSH
109328: LD_INT 35
109330: EQUAL
109331: IFFALSE 109341
// sTime := true ;
109333: LD_ADDR_EXP 194
109337: PUSH
109338: LD_INT 1
109340: ST_TO_ADDR
// if p3 = 36 then
109341: LD_VAR 0 3
109345: PUSH
109346: LD_INT 36
109348: EQUAL
109349: IFFALSE 109359
// sTools := true ;
109351: LD_ADDR_EXP 195
109355: PUSH
109356: LD_INT 1
109358: ST_TO_ADDR
// if p3 = 101 then
109359: LD_VAR 0 3
109363: PUSH
109364: LD_INT 101
109366: EQUAL
109367: IFFALSE 109377
// sSold := true ;
109369: LD_ADDR_EXP 160
109373: PUSH
109374: LD_INT 1
109376: ST_TO_ADDR
// if p3 = 102 then
109377: LD_VAR 0 3
109381: PUSH
109382: LD_INT 102
109384: EQUAL
109385: IFFALSE 109395
// sDiff := true ;
109387: LD_ADDR_EXP 161
109391: PUSH
109392: LD_INT 1
109394: ST_TO_ADDR
// if p3 = 103 then
109395: LD_VAR 0 3
109399: PUSH
109400: LD_INT 103
109402: EQUAL
109403: IFFALSE 109413
// sFog := true ;
109405: LD_ADDR_EXP 164
109409: PUSH
109410: LD_INT 1
109412: ST_TO_ADDR
// if p3 = 104 then
109413: LD_VAR 0 3
109417: PUSH
109418: LD_INT 104
109420: EQUAL
109421: IFFALSE 109431
// sReset := true ;
109423: LD_ADDR_EXP 165
109427: PUSH
109428: LD_INT 1
109430: ST_TO_ADDR
// if p3 = 105 then
109431: LD_VAR 0 3
109435: PUSH
109436: LD_INT 105
109438: EQUAL
109439: IFFALSE 109449
// sSun := true ;
109441: LD_ADDR_EXP 166
109445: PUSH
109446: LD_INT 1
109448: ST_TO_ADDR
// if p3 = 106 then
109449: LD_VAR 0 3
109453: PUSH
109454: LD_INT 106
109456: EQUAL
109457: IFFALSE 109467
// sTiger := true ;
109459: LD_ADDR_EXP 162
109463: PUSH
109464: LD_INT 1
109466: ST_TO_ADDR
// if p3 = 107 then
109467: LD_VAR 0 3
109471: PUSH
109472: LD_INT 107
109474: EQUAL
109475: IFFALSE 109485
// sBomb := true ;
109477: LD_ADDR_EXP 163
109481: PUSH
109482: LD_INT 1
109484: ST_TO_ADDR
// if p3 = 108 then
109485: LD_VAR 0 3
109489: PUSH
109490: LD_INT 108
109492: EQUAL
109493: IFFALSE 109503
// sWound := true ;
109495: LD_ADDR_EXP 171
109499: PUSH
109500: LD_INT 1
109502: ST_TO_ADDR
// if p3 = 109 then
109503: LD_VAR 0 3
109507: PUSH
109508: LD_INT 109
109510: EQUAL
109511: IFFALSE 109521
// sBetray := true ;
109513: LD_ADDR_EXP 175
109517: PUSH
109518: LD_INT 1
109520: ST_TO_ADDR
// if p3 = 110 then
109521: LD_VAR 0 3
109525: PUSH
109526: LD_INT 110
109528: EQUAL
109529: IFFALSE 109539
// sContamin := true ;
109531: LD_ADDR_EXP 176
109535: PUSH
109536: LD_INT 1
109538: ST_TO_ADDR
// if p3 = 111 then
109539: LD_VAR 0 3
109543: PUSH
109544: LD_INT 111
109546: EQUAL
109547: IFFALSE 109557
// sOil := true ;
109549: LD_ADDR_EXP 178
109553: PUSH
109554: LD_INT 1
109556: ST_TO_ADDR
// if p3 = 112 then
109557: LD_VAR 0 3
109561: PUSH
109562: LD_INT 112
109564: EQUAL
109565: IFFALSE 109575
// sStu := true ;
109567: LD_ADDR_EXP 182
109571: PUSH
109572: LD_INT 1
109574: ST_TO_ADDR
// if p3 = 113 then
109575: LD_VAR 0 3
109579: PUSH
109580: LD_INT 113
109582: EQUAL
109583: IFFALSE 109593
// sBazooka := true ;
109585: LD_ADDR_EXP 185
109589: PUSH
109590: LD_INT 1
109592: ST_TO_ADDR
// if p3 = 114 then
109593: LD_VAR 0 3
109597: PUSH
109598: LD_INT 114
109600: EQUAL
109601: IFFALSE 109611
// sMortar := true ;
109603: LD_ADDR_EXP 186
109607: PUSH
109608: LD_INT 1
109610: ST_TO_ADDR
// if p3 = 115 then
109611: LD_VAR 0 3
109615: PUSH
109616: LD_INT 115
109618: EQUAL
109619: IFFALSE 109629
// sRanger := true ;
109621: LD_ADDR_EXP 196
109625: PUSH
109626: LD_INT 1
109628: ST_TO_ADDR
// if p3 = 116 then
109629: LD_VAR 0 3
109633: PUSH
109634: LD_INT 116
109636: EQUAL
109637: IFFALSE 109647
// sComputer := true ;
109639: LD_ADDR_EXP 197
109643: PUSH
109644: LD_INT 1
109646: ST_TO_ADDR
// if p3 = 117 then
109647: LD_VAR 0 3
109651: PUSH
109652: LD_INT 117
109654: EQUAL
109655: IFFALSE 109665
// s30 := true ;
109657: LD_ADDR_EXP 198
109661: PUSH
109662: LD_INT 1
109664: ST_TO_ADDR
// if p3 = 118 then
109665: LD_VAR 0 3
109669: PUSH
109670: LD_INT 118
109672: EQUAL
109673: IFFALSE 109683
// s60 := true ;
109675: LD_ADDR_EXP 199
109679: PUSH
109680: LD_INT 1
109682: ST_TO_ADDR
// end ; if p2 = 101 then
109683: LD_VAR 0 2
109687: PUSH
109688: LD_INT 101
109690: EQUAL
109691: IFFALSE 109819
// begin case p3 of 1 :
109693: LD_VAR 0 3
109697: PUSH
109698: LD_INT 1
109700: DOUBLE
109701: EQUAL
109702: IFTRUE 109706
109704: GO 109713
109706: POP
// hHackUnlimitedResources ; 2 :
109707: CALL 121917 0 0
109711: GO 109819
109713: LD_INT 2
109715: DOUBLE
109716: EQUAL
109717: IFTRUE 109721
109719: GO 109728
109721: POP
// hHackSetLevel10 ; 3 :
109722: CALL 122050 0 0
109726: GO 109819
109728: LD_INT 3
109730: DOUBLE
109731: EQUAL
109732: IFTRUE 109736
109734: GO 109743
109736: POP
// hHackSetLevel10YourUnits ; 4 :
109737: CALL 122135 0 0
109741: GO 109819
109743: LD_INT 4
109745: DOUBLE
109746: EQUAL
109747: IFTRUE 109751
109749: GO 109758
109751: POP
// hHackInvincible ; 5 :
109752: CALL 122583 0 0
109756: GO 109819
109758: LD_INT 5
109760: DOUBLE
109761: EQUAL
109762: IFTRUE 109766
109764: GO 109773
109766: POP
// hHackInvisible ; 6 :
109767: CALL 122694 0 0
109771: GO 109819
109773: LD_INT 6
109775: DOUBLE
109776: EQUAL
109777: IFTRUE 109781
109779: GO 109788
109781: POP
// hHackChangeYourSide ; 7 :
109782: CALL 122751 0 0
109786: GO 109819
109788: LD_INT 7
109790: DOUBLE
109791: EQUAL
109792: IFTRUE 109796
109794: GO 109803
109796: POP
// hHackChangeUnitSide ; 8 :
109797: CALL 122793 0 0
109801: GO 109819
109803: LD_INT 8
109805: DOUBLE
109806: EQUAL
109807: IFTRUE 109811
109809: GO 109818
109811: POP
// hHackFog ; end ;
109812: CALL 122894 0 0
109816: GO 109819
109818: POP
// end ; end ;
109819: LD_VAR 0 7
109823: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
109824: GO 109826
109826: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
109827: LD_STRING initStreamRollete();
109829: PPUSH
109830: CALL_OW 559
// InitStreamMode ;
109834: CALL 109846 0 0
// DefineStreamItems ( false ) ;
109838: LD_INT 0
109840: PPUSH
109841: CALL 110310 0 1
// end ;
109845: END
// function InitStreamMode ; begin
109846: LD_INT 0
109848: PPUSH
// streamModeActive := false ;
109849: LD_ADDR_EXP 143
109853: PUSH
109854: LD_INT 0
109856: ST_TO_ADDR
// normalCounter := 36 ;
109857: LD_ADDR_EXP 144
109861: PUSH
109862: LD_INT 36
109864: ST_TO_ADDR
// hardcoreCounter := 18 ;
109865: LD_ADDR_EXP 145
109869: PUSH
109870: LD_INT 18
109872: ST_TO_ADDR
// sRocket := false ;
109873: LD_ADDR_EXP 148
109877: PUSH
109878: LD_INT 0
109880: ST_TO_ADDR
// sSpeed := false ;
109881: LD_ADDR_EXP 147
109885: PUSH
109886: LD_INT 0
109888: ST_TO_ADDR
// sEngine := false ;
109889: LD_ADDR_EXP 149
109893: PUSH
109894: LD_INT 0
109896: ST_TO_ADDR
// sSpec := false ;
109897: LD_ADDR_EXP 146
109901: PUSH
109902: LD_INT 0
109904: ST_TO_ADDR
// sLevel := false ;
109905: LD_ADDR_EXP 150
109909: PUSH
109910: LD_INT 0
109912: ST_TO_ADDR
// sArmoury := false ;
109913: LD_ADDR_EXP 151
109917: PUSH
109918: LD_INT 0
109920: ST_TO_ADDR
// sRadar := false ;
109921: LD_ADDR_EXP 152
109925: PUSH
109926: LD_INT 0
109928: ST_TO_ADDR
// sBunker := false ;
109929: LD_ADDR_EXP 153
109933: PUSH
109934: LD_INT 0
109936: ST_TO_ADDR
// sHack := false ;
109937: LD_ADDR_EXP 154
109941: PUSH
109942: LD_INT 0
109944: ST_TO_ADDR
// sFire := false ;
109945: LD_ADDR_EXP 155
109949: PUSH
109950: LD_INT 0
109952: ST_TO_ADDR
// sRefresh := false ;
109953: LD_ADDR_EXP 156
109957: PUSH
109958: LD_INT 0
109960: ST_TO_ADDR
// sExp := false ;
109961: LD_ADDR_EXP 157
109965: PUSH
109966: LD_INT 0
109968: ST_TO_ADDR
// sDepot := false ;
109969: LD_ADDR_EXP 158
109973: PUSH
109974: LD_INT 0
109976: ST_TO_ADDR
// sFlag := false ;
109977: LD_ADDR_EXP 159
109981: PUSH
109982: LD_INT 0
109984: ST_TO_ADDR
// sKamikadze := false ;
109985: LD_ADDR_EXP 167
109989: PUSH
109990: LD_INT 0
109992: ST_TO_ADDR
// sTroll := false ;
109993: LD_ADDR_EXP 168
109997: PUSH
109998: LD_INT 0
110000: ST_TO_ADDR
// sSlow := false ;
110001: LD_ADDR_EXP 169
110005: PUSH
110006: LD_INT 0
110008: ST_TO_ADDR
// sLack := false ;
110009: LD_ADDR_EXP 170
110013: PUSH
110014: LD_INT 0
110016: ST_TO_ADDR
// sTank := false ;
110017: LD_ADDR_EXP 172
110021: PUSH
110022: LD_INT 0
110024: ST_TO_ADDR
// sRemote := false ;
110025: LD_ADDR_EXP 173
110029: PUSH
110030: LD_INT 0
110032: ST_TO_ADDR
// sPowell := false ;
110033: LD_ADDR_EXP 174
110037: PUSH
110038: LD_INT 0
110040: ST_TO_ADDR
// sTeleport := false ;
110041: LD_ADDR_EXP 177
110045: PUSH
110046: LD_INT 0
110048: ST_TO_ADDR
// sOilTower := false ;
110049: LD_ADDR_EXP 179
110053: PUSH
110054: LD_INT 0
110056: ST_TO_ADDR
// sShovel := false ;
110057: LD_ADDR_EXP 180
110061: PUSH
110062: LD_INT 0
110064: ST_TO_ADDR
// sSheik := false ;
110065: LD_ADDR_EXP 181
110069: PUSH
110070: LD_INT 0
110072: ST_TO_ADDR
// sEarthquake := false ;
110073: LD_ADDR_EXP 183
110077: PUSH
110078: LD_INT 0
110080: ST_TO_ADDR
// sAI := false ;
110081: LD_ADDR_EXP 184
110085: PUSH
110086: LD_INT 0
110088: ST_TO_ADDR
// sCargo := false ;
110089: LD_ADDR_EXP 187
110093: PUSH
110094: LD_INT 0
110096: ST_TO_ADDR
// sDLaser := false ;
110097: LD_ADDR_EXP 188
110101: PUSH
110102: LD_INT 0
110104: ST_TO_ADDR
// sExchange := false ;
110105: LD_ADDR_EXP 189
110109: PUSH
110110: LD_INT 0
110112: ST_TO_ADDR
// sFac := false ;
110113: LD_ADDR_EXP 190
110117: PUSH
110118: LD_INT 0
110120: ST_TO_ADDR
// sPower := false ;
110121: LD_ADDR_EXP 191
110125: PUSH
110126: LD_INT 0
110128: ST_TO_ADDR
// sRandom := false ;
110129: LD_ADDR_EXP 192
110133: PUSH
110134: LD_INT 0
110136: ST_TO_ADDR
// sShield := false ;
110137: LD_ADDR_EXP 193
110141: PUSH
110142: LD_INT 0
110144: ST_TO_ADDR
// sTime := false ;
110145: LD_ADDR_EXP 194
110149: PUSH
110150: LD_INT 0
110152: ST_TO_ADDR
// sTools := false ;
110153: LD_ADDR_EXP 195
110157: PUSH
110158: LD_INT 0
110160: ST_TO_ADDR
// sSold := false ;
110161: LD_ADDR_EXP 160
110165: PUSH
110166: LD_INT 0
110168: ST_TO_ADDR
// sDiff := false ;
110169: LD_ADDR_EXP 161
110173: PUSH
110174: LD_INT 0
110176: ST_TO_ADDR
// sFog := false ;
110177: LD_ADDR_EXP 164
110181: PUSH
110182: LD_INT 0
110184: ST_TO_ADDR
// sReset := false ;
110185: LD_ADDR_EXP 165
110189: PUSH
110190: LD_INT 0
110192: ST_TO_ADDR
// sSun := false ;
110193: LD_ADDR_EXP 166
110197: PUSH
110198: LD_INT 0
110200: ST_TO_ADDR
// sTiger := false ;
110201: LD_ADDR_EXP 162
110205: PUSH
110206: LD_INT 0
110208: ST_TO_ADDR
// sBomb := false ;
110209: LD_ADDR_EXP 163
110213: PUSH
110214: LD_INT 0
110216: ST_TO_ADDR
// sWound := false ;
110217: LD_ADDR_EXP 171
110221: PUSH
110222: LD_INT 0
110224: ST_TO_ADDR
// sBetray := false ;
110225: LD_ADDR_EXP 175
110229: PUSH
110230: LD_INT 0
110232: ST_TO_ADDR
// sContamin := false ;
110233: LD_ADDR_EXP 176
110237: PUSH
110238: LD_INT 0
110240: ST_TO_ADDR
// sOil := false ;
110241: LD_ADDR_EXP 178
110245: PUSH
110246: LD_INT 0
110248: ST_TO_ADDR
// sStu := false ;
110249: LD_ADDR_EXP 182
110253: PUSH
110254: LD_INT 0
110256: ST_TO_ADDR
// sBazooka := false ;
110257: LD_ADDR_EXP 185
110261: PUSH
110262: LD_INT 0
110264: ST_TO_ADDR
// sMortar := false ;
110265: LD_ADDR_EXP 186
110269: PUSH
110270: LD_INT 0
110272: ST_TO_ADDR
// sRanger := false ;
110273: LD_ADDR_EXP 196
110277: PUSH
110278: LD_INT 0
110280: ST_TO_ADDR
// sComputer := false ;
110281: LD_ADDR_EXP 197
110285: PUSH
110286: LD_INT 0
110288: ST_TO_ADDR
// s30 := false ;
110289: LD_ADDR_EXP 198
110293: PUSH
110294: LD_INT 0
110296: ST_TO_ADDR
// s60 := false ;
110297: LD_ADDR_EXP 199
110301: PUSH
110302: LD_INT 0
110304: ST_TO_ADDR
// end ;
110305: LD_VAR 0 1
110309: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
110310: LD_INT 0
110312: PPUSH
110313: PPUSH
110314: PPUSH
110315: PPUSH
110316: PPUSH
110317: PPUSH
110318: PPUSH
// result := [ ] ;
110319: LD_ADDR_VAR 0 2
110323: PUSH
110324: EMPTY
110325: ST_TO_ADDR
// if campaign_id = 1 then
110326: LD_OWVAR 69
110330: PUSH
110331: LD_INT 1
110333: EQUAL
110334: IFFALSE 113500
// begin case mission_number of 1 :
110336: LD_OWVAR 70
110340: PUSH
110341: LD_INT 1
110343: DOUBLE
110344: EQUAL
110345: IFTRUE 110349
110347: GO 110425
110349: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
110350: LD_ADDR_VAR 0 2
110354: PUSH
110355: LD_INT 2
110357: PUSH
110358: LD_INT 4
110360: PUSH
110361: LD_INT 11
110363: PUSH
110364: LD_INT 12
110366: PUSH
110367: LD_INT 15
110369: PUSH
110370: LD_INT 16
110372: PUSH
110373: LD_INT 22
110375: PUSH
110376: LD_INT 23
110378: PUSH
110379: LD_INT 26
110381: PUSH
110382: EMPTY
110383: LIST
110384: LIST
110385: LIST
110386: LIST
110387: LIST
110388: LIST
110389: LIST
110390: LIST
110391: LIST
110392: PUSH
110393: LD_INT 101
110395: PUSH
110396: LD_INT 102
110398: PUSH
110399: LD_INT 106
110401: PUSH
110402: LD_INT 116
110404: PUSH
110405: LD_INT 117
110407: PUSH
110408: LD_INT 118
110410: PUSH
110411: EMPTY
110412: LIST
110413: LIST
110414: LIST
110415: LIST
110416: LIST
110417: LIST
110418: PUSH
110419: EMPTY
110420: LIST
110421: LIST
110422: ST_TO_ADDR
110423: GO 113498
110425: LD_INT 2
110427: DOUBLE
110428: EQUAL
110429: IFTRUE 110433
110431: GO 110517
110433: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
110434: LD_ADDR_VAR 0 2
110438: PUSH
110439: LD_INT 2
110441: PUSH
110442: LD_INT 4
110444: PUSH
110445: LD_INT 11
110447: PUSH
110448: LD_INT 12
110450: PUSH
110451: LD_INT 15
110453: PUSH
110454: LD_INT 16
110456: PUSH
110457: LD_INT 22
110459: PUSH
110460: LD_INT 23
110462: PUSH
110463: LD_INT 26
110465: PUSH
110466: EMPTY
110467: LIST
110468: LIST
110469: LIST
110470: LIST
110471: LIST
110472: LIST
110473: LIST
110474: LIST
110475: LIST
110476: PUSH
110477: LD_INT 101
110479: PUSH
110480: LD_INT 102
110482: PUSH
110483: LD_INT 105
110485: PUSH
110486: LD_INT 106
110488: PUSH
110489: LD_INT 108
110491: PUSH
110492: LD_INT 116
110494: PUSH
110495: LD_INT 117
110497: PUSH
110498: LD_INT 118
110500: PUSH
110501: EMPTY
110502: LIST
110503: LIST
110504: LIST
110505: LIST
110506: LIST
110507: LIST
110508: LIST
110509: LIST
110510: PUSH
110511: EMPTY
110512: LIST
110513: LIST
110514: ST_TO_ADDR
110515: GO 113498
110517: LD_INT 3
110519: DOUBLE
110520: EQUAL
110521: IFTRUE 110525
110523: GO 110613
110525: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
110526: LD_ADDR_VAR 0 2
110530: PUSH
110531: LD_INT 2
110533: PUSH
110534: LD_INT 4
110536: PUSH
110537: LD_INT 5
110539: PUSH
110540: LD_INT 11
110542: PUSH
110543: LD_INT 12
110545: PUSH
110546: LD_INT 15
110548: PUSH
110549: LD_INT 16
110551: PUSH
110552: LD_INT 22
110554: PUSH
110555: LD_INT 26
110557: PUSH
110558: LD_INT 36
110560: PUSH
110561: EMPTY
110562: LIST
110563: LIST
110564: LIST
110565: LIST
110566: LIST
110567: LIST
110568: LIST
110569: LIST
110570: LIST
110571: LIST
110572: PUSH
110573: LD_INT 101
110575: PUSH
110576: LD_INT 102
110578: PUSH
110579: LD_INT 105
110581: PUSH
110582: LD_INT 106
110584: PUSH
110585: LD_INT 108
110587: PUSH
110588: LD_INT 116
110590: PUSH
110591: LD_INT 117
110593: PUSH
110594: LD_INT 118
110596: PUSH
110597: EMPTY
110598: LIST
110599: LIST
110600: LIST
110601: LIST
110602: LIST
110603: LIST
110604: LIST
110605: LIST
110606: PUSH
110607: EMPTY
110608: LIST
110609: LIST
110610: ST_TO_ADDR
110611: GO 113498
110613: LD_INT 4
110615: DOUBLE
110616: EQUAL
110617: IFTRUE 110621
110619: GO 110717
110621: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
110622: LD_ADDR_VAR 0 2
110626: PUSH
110627: LD_INT 2
110629: PUSH
110630: LD_INT 4
110632: PUSH
110633: LD_INT 5
110635: PUSH
110636: LD_INT 8
110638: PUSH
110639: LD_INT 11
110641: PUSH
110642: LD_INT 12
110644: PUSH
110645: LD_INT 15
110647: PUSH
110648: LD_INT 16
110650: PUSH
110651: LD_INT 22
110653: PUSH
110654: LD_INT 23
110656: PUSH
110657: LD_INT 26
110659: PUSH
110660: LD_INT 36
110662: PUSH
110663: EMPTY
110664: LIST
110665: LIST
110666: LIST
110667: LIST
110668: LIST
110669: LIST
110670: LIST
110671: LIST
110672: LIST
110673: LIST
110674: LIST
110675: LIST
110676: PUSH
110677: LD_INT 101
110679: PUSH
110680: LD_INT 102
110682: PUSH
110683: LD_INT 105
110685: PUSH
110686: LD_INT 106
110688: PUSH
110689: LD_INT 108
110691: PUSH
110692: LD_INT 116
110694: PUSH
110695: LD_INT 117
110697: PUSH
110698: LD_INT 118
110700: PUSH
110701: EMPTY
110702: LIST
110703: LIST
110704: LIST
110705: LIST
110706: LIST
110707: LIST
110708: LIST
110709: LIST
110710: PUSH
110711: EMPTY
110712: LIST
110713: LIST
110714: ST_TO_ADDR
110715: GO 113498
110717: LD_INT 5
110719: DOUBLE
110720: EQUAL
110721: IFTRUE 110725
110723: GO 110837
110725: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
110726: LD_ADDR_VAR 0 2
110730: PUSH
110731: LD_INT 2
110733: PUSH
110734: LD_INT 4
110736: PUSH
110737: LD_INT 5
110739: PUSH
110740: LD_INT 6
110742: PUSH
110743: LD_INT 8
110745: PUSH
110746: LD_INT 11
110748: PUSH
110749: LD_INT 12
110751: PUSH
110752: LD_INT 15
110754: PUSH
110755: LD_INT 16
110757: PUSH
110758: LD_INT 22
110760: PUSH
110761: LD_INT 23
110763: PUSH
110764: LD_INT 25
110766: PUSH
110767: LD_INT 26
110769: PUSH
110770: LD_INT 36
110772: PUSH
110773: EMPTY
110774: LIST
110775: LIST
110776: LIST
110777: LIST
110778: LIST
110779: LIST
110780: LIST
110781: LIST
110782: LIST
110783: LIST
110784: LIST
110785: LIST
110786: LIST
110787: LIST
110788: PUSH
110789: LD_INT 101
110791: PUSH
110792: LD_INT 102
110794: PUSH
110795: LD_INT 105
110797: PUSH
110798: LD_INT 106
110800: PUSH
110801: LD_INT 108
110803: PUSH
110804: LD_INT 109
110806: PUSH
110807: LD_INT 112
110809: PUSH
110810: LD_INT 116
110812: PUSH
110813: LD_INT 117
110815: PUSH
110816: LD_INT 118
110818: PUSH
110819: EMPTY
110820: LIST
110821: LIST
110822: LIST
110823: LIST
110824: LIST
110825: LIST
110826: LIST
110827: LIST
110828: LIST
110829: LIST
110830: PUSH
110831: EMPTY
110832: LIST
110833: LIST
110834: ST_TO_ADDR
110835: GO 113498
110837: LD_INT 6
110839: DOUBLE
110840: EQUAL
110841: IFTRUE 110845
110843: GO 110977
110845: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
110846: LD_ADDR_VAR 0 2
110850: PUSH
110851: LD_INT 2
110853: PUSH
110854: LD_INT 4
110856: PUSH
110857: LD_INT 5
110859: PUSH
110860: LD_INT 6
110862: PUSH
110863: LD_INT 8
110865: PUSH
110866: LD_INT 11
110868: PUSH
110869: LD_INT 12
110871: PUSH
110872: LD_INT 15
110874: PUSH
110875: LD_INT 16
110877: PUSH
110878: LD_INT 20
110880: PUSH
110881: LD_INT 21
110883: PUSH
110884: LD_INT 22
110886: PUSH
110887: LD_INT 23
110889: PUSH
110890: LD_INT 25
110892: PUSH
110893: LD_INT 26
110895: PUSH
110896: LD_INT 30
110898: PUSH
110899: LD_INT 31
110901: PUSH
110902: LD_INT 32
110904: PUSH
110905: LD_INT 36
110907: PUSH
110908: EMPTY
110909: LIST
110910: LIST
110911: LIST
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: LIST
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: LIST
110923: LIST
110924: LIST
110925: LIST
110926: LIST
110927: LIST
110928: PUSH
110929: LD_INT 101
110931: PUSH
110932: LD_INT 102
110934: PUSH
110935: LD_INT 105
110937: PUSH
110938: LD_INT 106
110940: PUSH
110941: LD_INT 108
110943: PUSH
110944: LD_INT 109
110946: PUSH
110947: LD_INT 112
110949: PUSH
110950: LD_INT 116
110952: PUSH
110953: LD_INT 117
110955: PUSH
110956: LD_INT 118
110958: PUSH
110959: EMPTY
110960: LIST
110961: LIST
110962: LIST
110963: LIST
110964: LIST
110965: LIST
110966: LIST
110967: LIST
110968: LIST
110969: LIST
110970: PUSH
110971: EMPTY
110972: LIST
110973: LIST
110974: ST_TO_ADDR
110975: GO 113498
110977: LD_INT 7
110979: DOUBLE
110980: EQUAL
110981: IFTRUE 110985
110983: GO 111097
110985: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
110986: LD_ADDR_VAR 0 2
110990: PUSH
110991: LD_INT 2
110993: PUSH
110994: LD_INT 4
110996: PUSH
110997: LD_INT 5
110999: PUSH
111000: LD_INT 7
111002: PUSH
111003: LD_INT 11
111005: PUSH
111006: LD_INT 12
111008: PUSH
111009: LD_INT 15
111011: PUSH
111012: LD_INT 16
111014: PUSH
111015: LD_INT 20
111017: PUSH
111018: LD_INT 21
111020: PUSH
111021: LD_INT 22
111023: PUSH
111024: LD_INT 23
111026: PUSH
111027: LD_INT 25
111029: PUSH
111030: LD_INT 26
111032: PUSH
111033: EMPTY
111034: LIST
111035: LIST
111036: LIST
111037: LIST
111038: LIST
111039: LIST
111040: LIST
111041: LIST
111042: LIST
111043: LIST
111044: LIST
111045: LIST
111046: LIST
111047: LIST
111048: PUSH
111049: LD_INT 101
111051: PUSH
111052: LD_INT 102
111054: PUSH
111055: LD_INT 103
111057: PUSH
111058: LD_INT 105
111060: PUSH
111061: LD_INT 106
111063: PUSH
111064: LD_INT 108
111066: PUSH
111067: LD_INT 112
111069: PUSH
111070: LD_INT 116
111072: PUSH
111073: LD_INT 117
111075: PUSH
111076: LD_INT 118
111078: PUSH
111079: EMPTY
111080: LIST
111081: LIST
111082: LIST
111083: LIST
111084: LIST
111085: LIST
111086: LIST
111087: LIST
111088: LIST
111089: LIST
111090: PUSH
111091: EMPTY
111092: LIST
111093: LIST
111094: ST_TO_ADDR
111095: GO 113498
111097: LD_INT 8
111099: DOUBLE
111100: EQUAL
111101: IFTRUE 111105
111103: GO 111245
111105: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
111106: LD_ADDR_VAR 0 2
111110: PUSH
111111: LD_INT 2
111113: PUSH
111114: LD_INT 4
111116: PUSH
111117: LD_INT 5
111119: PUSH
111120: LD_INT 6
111122: PUSH
111123: LD_INT 7
111125: PUSH
111126: LD_INT 8
111128: PUSH
111129: LD_INT 11
111131: PUSH
111132: LD_INT 12
111134: PUSH
111135: LD_INT 15
111137: PUSH
111138: LD_INT 16
111140: PUSH
111141: LD_INT 20
111143: PUSH
111144: LD_INT 21
111146: PUSH
111147: LD_INT 22
111149: PUSH
111150: LD_INT 23
111152: PUSH
111153: LD_INT 25
111155: PUSH
111156: LD_INT 26
111158: PUSH
111159: LD_INT 30
111161: PUSH
111162: LD_INT 31
111164: PUSH
111165: LD_INT 32
111167: PUSH
111168: LD_INT 36
111170: PUSH
111171: EMPTY
111172: LIST
111173: LIST
111174: LIST
111175: LIST
111176: LIST
111177: LIST
111178: LIST
111179: LIST
111180: LIST
111181: LIST
111182: LIST
111183: LIST
111184: LIST
111185: LIST
111186: LIST
111187: LIST
111188: LIST
111189: LIST
111190: LIST
111191: LIST
111192: PUSH
111193: LD_INT 101
111195: PUSH
111196: LD_INT 102
111198: PUSH
111199: LD_INT 103
111201: PUSH
111202: LD_INT 105
111204: PUSH
111205: LD_INT 106
111207: PUSH
111208: LD_INT 108
111210: PUSH
111211: LD_INT 109
111213: PUSH
111214: LD_INT 112
111216: PUSH
111217: LD_INT 116
111219: PUSH
111220: LD_INT 117
111222: PUSH
111223: LD_INT 118
111225: PUSH
111226: EMPTY
111227: LIST
111228: LIST
111229: LIST
111230: LIST
111231: LIST
111232: LIST
111233: LIST
111234: LIST
111235: LIST
111236: LIST
111237: LIST
111238: PUSH
111239: EMPTY
111240: LIST
111241: LIST
111242: ST_TO_ADDR
111243: GO 113498
111245: LD_INT 9
111247: DOUBLE
111248: EQUAL
111249: IFTRUE 111253
111251: GO 111401
111253: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
111254: LD_ADDR_VAR 0 2
111258: PUSH
111259: LD_INT 2
111261: PUSH
111262: LD_INT 4
111264: PUSH
111265: LD_INT 5
111267: PUSH
111268: LD_INT 6
111270: PUSH
111271: LD_INT 7
111273: PUSH
111274: LD_INT 8
111276: PUSH
111277: LD_INT 11
111279: PUSH
111280: LD_INT 12
111282: PUSH
111283: LD_INT 15
111285: PUSH
111286: LD_INT 16
111288: PUSH
111289: LD_INT 20
111291: PUSH
111292: LD_INT 21
111294: PUSH
111295: LD_INT 22
111297: PUSH
111298: LD_INT 23
111300: PUSH
111301: LD_INT 25
111303: PUSH
111304: LD_INT 26
111306: PUSH
111307: LD_INT 28
111309: PUSH
111310: LD_INT 30
111312: PUSH
111313: LD_INT 31
111315: PUSH
111316: LD_INT 32
111318: PUSH
111319: LD_INT 36
111321: PUSH
111322: EMPTY
111323: LIST
111324: LIST
111325: LIST
111326: LIST
111327: LIST
111328: LIST
111329: LIST
111330: LIST
111331: LIST
111332: LIST
111333: LIST
111334: LIST
111335: LIST
111336: LIST
111337: LIST
111338: LIST
111339: LIST
111340: LIST
111341: LIST
111342: LIST
111343: LIST
111344: PUSH
111345: LD_INT 101
111347: PUSH
111348: LD_INT 102
111350: PUSH
111351: LD_INT 103
111353: PUSH
111354: LD_INT 105
111356: PUSH
111357: LD_INT 106
111359: PUSH
111360: LD_INT 108
111362: PUSH
111363: LD_INT 109
111365: PUSH
111366: LD_INT 112
111368: PUSH
111369: LD_INT 114
111371: PUSH
111372: LD_INT 116
111374: PUSH
111375: LD_INT 117
111377: PUSH
111378: LD_INT 118
111380: PUSH
111381: EMPTY
111382: LIST
111383: LIST
111384: LIST
111385: LIST
111386: LIST
111387: LIST
111388: LIST
111389: LIST
111390: LIST
111391: LIST
111392: LIST
111393: LIST
111394: PUSH
111395: EMPTY
111396: LIST
111397: LIST
111398: ST_TO_ADDR
111399: GO 113498
111401: LD_INT 10
111403: DOUBLE
111404: EQUAL
111405: IFTRUE 111409
111407: GO 111605
111409: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
111410: LD_ADDR_VAR 0 2
111414: PUSH
111415: LD_INT 2
111417: PUSH
111418: LD_INT 4
111420: PUSH
111421: LD_INT 5
111423: PUSH
111424: LD_INT 6
111426: PUSH
111427: LD_INT 7
111429: PUSH
111430: LD_INT 8
111432: PUSH
111433: LD_INT 9
111435: PUSH
111436: LD_INT 10
111438: PUSH
111439: LD_INT 11
111441: PUSH
111442: LD_INT 12
111444: PUSH
111445: LD_INT 13
111447: PUSH
111448: LD_INT 14
111450: PUSH
111451: LD_INT 15
111453: PUSH
111454: LD_INT 16
111456: PUSH
111457: LD_INT 17
111459: PUSH
111460: LD_INT 18
111462: PUSH
111463: LD_INT 19
111465: PUSH
111466: LD_INT 20
111468: PUSH
111469: LD_INT 21
111471: PUSH
111472: LD_INT 22
111474: PUSH
111475: LD_INT 23
111477: PUSH
111478: LD_INT 24
111480: PUSH
111481: LD_INT 25
111483: PUSH
111484: LD_INT 26
111486: PUSH
111487: LD_INT 28
111489: PUSH
111490: LD_INT 30
111492: PUSH
111493: LD_INT 31
111495: PUSH
111496: LD_INT 32
111498: PUSH
111499: LD_INT 36
111501: PUSH
111502: EMPTY
111503: LIST
111504: LIST
111505: LIST
111506: LIST
111507: LIST
111508: LIST
111509: LIST
111510: LIST
111511: LIST
111512: LIST
111513: LIST
111514: LIST
111515: LIST
111516: LIST
111517: LIST
111518: LIST
111519: LIST
111520: LIST
111521: LIST
111522: LIST
111523: LIST
111524: LIST
111525: LIST
111526: LIST
111527: LIST
111528: LIST
111529: LIST
111530: LIST
111531: LIST
111532: PUSH
111533: LD_INT 101
111535: PUSH
111536: LD_INT 102
111538: PUSH
111539: LD_INT 103
111541: PUSH
111542: LD_INT 104
111544: PUSH
111545: LD_INT 105
111547: PUSH
111548: LD_INT 106
111550: PUSH
111551: LD_INT 107
111553: PUSH
111554: LD_INT 108
111556: PUSH
111557: LD_INT 109
111559: PUSH
111560: LD_INT 110
111562: PUSH
111563: LD_INT 111
111565: PUSH
111566: LD_INT 112
111568: PUSH
111569: LD_INT 114
111571: PUSH
111572: LD_INT 116
111574: PUSH
111575: LD_INT 117
111577: PUSH
111578: LD_INT 118
111580: PUSH
111581: EMPTY
111582: LIST
111583: LIST
111584: LIST
111585: LIST
111586: LIST
111587: LIST
111588: LIST
111589: LIST
111590: LIST
111591: LIST
111592: LIST
111593: LIST
111594: LIST
111595: LIST
111596: LIST
111597: LIST
111598: PUSH
111599: EMPTY
111600: LIST
111601: LIST
111602: ST_TO_ADDR
111603: GO 113498
111605: LD_INT 11
111607: DOUBLE
111608: EQUAL
111609: IFTRUE 111613
111611: GO 111817
111613: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
111614: LD_ADDR_VAR 0 2
111618: PUSH
111619: LD_INT 2
111621: PUSH
111622: LD_INT 3
111624: PUSH
111625: LD_INT 4
111627: PUSH
111628: LD_INT 5
111630: PUSH
111631: LD_INT 6
111633: PUSH
111634: LD_INT 7
111636: PUSH
111637: LD_INT 8
111639: PUSH
111640: LD_INT 9
111642: PUSH
111643: LD_INT 10
111645: PUSH
111646: LD_INT 11
111648: PUSH
111649: LD_INT 12
111651: PUSH
111652: LD_INT 13
111654: PUSH
111655: LD_INT 14
111657: PUSH
111658: LD_INT 15
111660: PUSH
111661: LD_INT 16
111663: PUSH
111664: LD_INT 17
111666: PUSH
111667: LD_INT 18
111669: PUSH
111670: LD_INT 19
111672: PUSH
111673: LD_INT 20
111675: PUSH
111676: LD_INT 21
111678: PUSH
111679: LD_INT 22
111681: PUSH
111682: LD_INT 23
111684: PUSH
111685: LD_INT 24
111687: PUSH
111688: LD_INT 25
111690: PUSH
111691: LD_INT 26
111693: PUSH
111694: LD_INT 28
111696: PUSH
111697: LD_INT 30
111699: PUSH
111700: LD_INT 31
111702: PUSH
111703: LD_INT 32
111705: PUSH
111706: LD_INT 34
111708: PUSH
111709: LD_INT 36
111711: PUSH
111712: EMPTY
111713: LIST
111714: LIST
111715: LIST
111716: LIST
111717: LIST
111718: LIST
111719: LIST
111720: LIST
111721: LIST
111722: LIST
111723: LIST
111724: LIST
111725: LIST
111726: LIST
111727: LIST
111728: LIST
111729: LIST
111730: LIST
111731: LIST
111732: LIST
111733: LIST
111734: LIST
111735: LIST
111736: LIST
111737: LIST
111738: LIST
111739: LIST
111740: LIST
111741: LIST
111742: LIST
111743: LIST
111744: PUSH
111745: LD_INT 101
111747: PUSH
111748: LD_INT 102
111750: PUSH
111751: LD_INT 103
111753: PUSH
111754: LD_INT 104
111756: PUSH
111757: LD_INT 105
111759: PUSH
111760: LD_INT 106
111762: PUSH
111763: LD_INT 107
111765: PUSH
111766: LD_INT 108
111768: PUSH
111769: LD_INT 109
111771: PUSH
111772: LD_INT 110
111774: PUSH
111775: LD_INT 111
111777: PUSH
111778: LD_INT 112
111780: PUSH
111781: LD_INT 114
111783: PUSH
111784: LD_INT 116
111786: PUSH
111787: LD_INT 117
111789: PUSH
111790: LD_INT 118
111792: PUSH
111793: EMPTY
111794: LIST
111795: LIST
111796: LIST
111797: LIST
111798: LIST
111799: LIST
111800: LIST
111801: LIST
111802: LIST
111803: LIST
111804: LIST
111805: LIST
111806: LIST
111807: LIST
111808: LIST
111809: LIST
111810: PUSH
111811: EMPTY
111812: LIST
111813: LIST
111814: ST_TO_ADDR
111815: GO 113498
111817: LD_INT 12
111819: DOUBLE
111820: EQUAL
111821: IFTRUE 111825
111823: GO 112045
111825: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
111826: LD_ADDR_VAR 0 2
111830: PUSH
111831: LD_INT 1
111833: PUSH
111834: LD_INT 2
111836: PUSH
111837: LD_INT 3
111839: PUSH
111840: LD_INT 4
111842: PUSH
111843: LD_INT 5
111845: PUSH
111846: LD_INT 6
111848: PUSH
111849: LD_INT 7
111851: PUSH
111852: LD_INT 8
111854: PUSH
111855: LD_INT 9
111857: PUSH
111858: LD_INT 10
111860: PUSH
111861: LD_INT 11
111863: PUSH
111864: LD_INT 12
111866: PUSH
111867: LD_INT 13
111869: PUSH
111870: LD_INT 14
111872: PUSH
111873: LD_INT 15
111875: PUSH
111876: LD_INT 16
111878: PUSH
111879: LD_INT 17
111881: PUSH
111882: LD_INT 18
111884: PUSH
111885: LD_INT 19
111887: PUSH
111888: LD_INT 20
111890: PUSH
111891: LD_INT 21
111893: PUSH
111894: LD_INT 22
111896: PUSH
111897: LD_INT 23
111899: PUSH
111900: LD_INT 24
111902: PUSH
111903: LD_INT 25
111905: PUSH
111906: LD_INT 26
111908: PUSH
111909: LD_INT 27
111911: PUSH
111912: LD_INT 28
111914: PUSH
111915: LD_INT 30
111917: PUSH
111918: LD_INT 31
111920: PUSH
111921: LD_INT 32
111923: PUSH
111924: LD_INT 33
111926: PUSH
111927: LD_INT 34
111929: PUSH
111930: LD_INT 36
111932: PUSH
111933: EMPTY
111934: LIST
111935: LIST
111936: LIST
111937: LIST
111938: LIST
111939: LIST
111940: LIST
111941: LIST
111942: LIST
111943: LIST
111944: LIST
111945: LIST
111946: LIST
111947: LIST
111948: LIST
111949: LIST
111950: LIST
111951: LIST
111952: LIST
111953: LIST
111954: LIST
111955: LIST
111956: LIST
111957: LIST
111958: LIST
111959: LIST
111960: LIST
111961: LIST
111962: LIST
111963: LIST
111964: LIST
111965: LIST
111966: LIST
111967: LIST
111968: PUSH
111969: LD_INT 101
111971: PUSH
111972: LD_INT 102
111974: PUSH
111975: LD_INT 103
111977: PUSH
111978: LD_INT 104
111980: PUSH
111981: LD_INT 105
111983: PUSH
111984: LD_INT 106
111986: PUSH
111987: LD_INT 107
111989: PUSH
111990: LD_INT 108
111992: PUSH
111993: LD_INT 109
111995: PUSH
111996: LD_INT 110
111998: PUSH
111999: LD_INT 111
112001: PUSH
112002: LD_INT 112
112004: PUSH
112005: LD_INT 113
112007: PUSH
112008: LD_INT 114
112010: PUSH
112011: LD_INT 116
112013: PUSH
112014: LD_INT 117
112016: PUSH
112017: LD_INT 118
112019: PUSH
112020: EMPTY
112021: LIST
112022: LIST
112023: LIST
112024: LIST
112025: LIST
112026: LIST
112027: LIST
112028: LIST
112029: LIST
112030: LIST
112031: LIST
112032: LIST
112033: LIST
112034: LIST
112035: LIST
112036: LIST
112037: LIST
112038: PUSH
112039: EMPTY
112040: LIST
112041: LIST
112042: ST_TO_ADDR
112043: GO 113498
112045: LD_INT 13
112047: DOUBLE
112048: EQUAL
112049: IFTRUE 112053
112051: GO 112261
112053: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
112054: LD_ADDR_VAR 0 2
112058: PUSH
112059: LD_INT 1
112061: PUSH
112062: LD_INT 2
112064: PUSH
112065: LD_INT 3
112067: PUSH
112068: LD_INT 4
112070: PUSH
112071: LD_INT 5
112073: PUSH
112074: LD_INT 8
112076: PUSH
112077: LD_INT 9
112079: PUSH
112080: LD_INT 10
112082: PUSH
112083: LD_INT 11
112085: PUSH
112086: LD_INT 12
112088: PUSH
112089: LD_INT 14
112091: PUSH
112092: LD_INT 15
112094: PUSH
112095: LD_INT 16
112097: PUSH
112098: LD_INT 17
112100: PUSH
112101: LD_INT 18
112103: PUSH
112104: LD_INT 19
112106: PUSH
112107: LD_INT 20
112109: PUSH
112110: LD_INT 21
112112: PUSH
112113: LD_INT 22
112115: PUSH
112116: LD_INT 23
112118: PUSH
112119: LD_INT 24
112121: PUSH
112122: LD_INT 25
112124: PUSH
112125: LD_INT 26
112127: PUSH
112128: LD_INT 27
112130: PUSH
112131: LD_INT 28
112133: PUSH
112134: LD_INT 30
112136: PUSH
112137: LD_INT 31
112139: PUSH
112140: LD_INT 32
112142: PUSH
112143: LD_INT 33
112145: PUSH
112146: LD_INT 34
112148: PUSH
112149: LD_INT 36
112151: PUSH
112152: EMPTY
112153: LIST
112154: LIST
112155: LIST
112156: LIST
112157: LIST
112158: LIST
112159: LIST
112160: LIST
112161: LIST
112162: LIST
112163: LIST
112164: LIST
112165: LIST
112166: LIST
112167: LIST
112168: LIST
112169: LIST
112170: LIST
112171: LIST
112172: LIST
112173: LIST
112174: LIST
112175: LIST
112176: LIST
112177: LIST
112178: LIST
112179: LIST
112180: LIST
112181: LIST
112182: LIST
112183: LIST
112184: PUSH
112185: LD_INT 101
112187: PUSH
112188: LD_INT 102
112190: PUSH
112191: LD_INT 103
112193: PUSH
112194: LD_INT 104
112196: PUSH
112197: LD_INT 105
112199: PUSH
112200: LD_INT 106
112202: PUSH
112203: LD_INT 107
112205: PUSH
112206: LD_INT 108
112208: PUSH
112209: LD_INT 109
112211: PUSH
112212: LD_INT 110
112214: PUSH
112215: LD_INT 111
112217: PUSH
112218: LD_INT 112
112220: PUSH
112221: LD_INT 113
112223: PUSH
112224: LD_INT 114
112226: PUSH
112227: LD_INT 116
112229: PUSH
112230: LD_INT 117
112232: PUSH
112233: LD_INT 118
112235: PUSH
112236: EMPTY
112237: LIST
112238: LIST
112239: LIST
112240: LIST
112241: LIST
112242: LIST
112243: LIST
112244: LIST
112245: LIST
112246: LIST
112247: LIST
112248: LIST
112249: LIST
112250: LIST
112251: LIST
112252: LIST
112253: LIST
112254: PUSH
112255: EMPTY
112256: LIST
112257: LIST
112258: ST_TO_ADDR
112259: GO 113498
112261: LD_INT 14
112263: DOUBLE
112264: EQUAL
112265: IFTRUE 112269
112267: GO 112493
112269: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
112270: LD_ADDR_VAR 0 2
112274: PUSH
112275: LD_INT 1
112277: PUSH
112278: LD_INT 2
112280: PUSH
112281: LD_INT 3
112283: PUSH
112284: LD_INT 4
112286: PUSH
112287: LD_INT 5
112289: PUSH
112290: LD_INT 6
112292: PUSH
112293: LD_INT 7
112295: PUSH
112296: LD_INT 8
112298: PUSH
112299: LD_INT 9
112301: PUSH
112302: LD_INT 10
112304: PUSH
112305: LD_INT 11
112307: PUSH
112308: LD_INT 12
112310: PUSH
112311: LD_INT 13
112313: PUSH
112314: LD_INT 14
112316: PUSH
112317: LD_INT 15
112319: PUSH
112320: LD_INT 16
112322: PUSH
112323: LD_INT 17
112325: PUSH
112326: LD_INT 18
112328: PUSH
112329: LD_INT 19
112331: PUSH
112332: LD_INT 20
112334: PUSH
112335: LD_INT 21
112337: PUSH
112338: LD_INT 22
112340: PUSH
112341: LD_INT 23
112343: PUSH
112344: LD_INT 24
112346: PUSH
112347: LD_INT 25
112349: PUSH
112350: LD_INT 26
112352: PUSH
112353: LD_INT 27
112355: PUSH
112356: LD_INT 28
112358: PUSH
112359: LD_INT 29
112361: PUSH
112362: LD_INT 30
112364: PUSH
112365: LD_INT 31
112367: PUSH
112368: LD_INT 32
112370: PUSH
112371: LD_INT 33
112373: PUSH
112374: LD_INT 34
112376: PUSH
112377: LD_INT 36
112379: PUSH
112380: EMPTY
112381: LIST
112382: LIST
112383: LIST
112384: LIST
112385: LIST
112386: LIST
112387: LIST
112388: LIST
112389: LIST
112390: LIST
112391: LIST
112392: LIST
112393: LIST
112394: LIST
112395: LIST
112396: LIST
112397: LIST
112398: LIST
112399: LIST
112400: LIST
112401: LIST
112402: LIST
112403: LIST
112404: LIST
112405: LIST
112406: LIST
112407: LIST
112408: LIST
112409: LIST
112410: LIST
112411: LIST
112412: LIST
112413: LIST
112414: LIST
112415: LIST
112416: PUSH
112417: LD_INT 101
112419: PUSH
112420: LD_INT 102
112422: PUSH
112423: LD_INT 103
112425: PUSH
112426: LD_INT 104
112428: PUSH
112429: LD_INT 105
112431: PUSH
112432: LD_INT 106
112434: PUSH
112435: LD_INT 107
112437: PUSH
112438: LD_INT 108
112440: PUSH
112441: LD_INT 109
112443: PUSH
112444: LD_INT 110
112446: PUSH
112447: LD_INT 111
112449: PUSH
112450: LD_INT 112
112452: PUSH
112453: LD_INT 113
112455: PUSH
112456: LD_INT 114
112458: PUSH
112459: LD_INT 116
112461: PUSH
112462: LD_INT 117
112464: PUSH
112465: LD_INT 118
112467: PUSH
112468: EMPTY
112469: LIST
112470: LIST
112471: LIST
112472: LIST
112473: LIST
112474: LIST
112475: LIST
112476: LIST
112477: LIST
112478: LIST
112479: LIST
112480: LIST
112481: LIST
112482: LIST
112483: LIST
112484: LIST
112485: LIST
112486: PUSH
112487: EMPTY
112488: LIST
112489: LIST
112490: ST_TO_ADDR
112491: GO 113498
112493: LD_INT 15
112495: DOUBLE
112496: EQUAL
112497: IFTRUE 112501
112499: GO 112725
112501: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
112502: LD_ADDR_VAR 0 2
112506: PUSH
112507: LD_INT 1
112509: PUSH
112510: LD_INT 2
112512: PUSH
112513: LD_INT 3
112515: PUSH
112516: LD_INT 4
112518: PUSH
112519: LD_INT 5
112521: PUSH
112522: LD_INT 6
112524: PUSH
112525: LD_INT 7
112527: PUSH
112528: LD_INT 8
112530: PUSH
112531: LD_INT 9
112533: PUSH
112534: LD_INT 10
112536: PUSH
112537: LD_INT 11
112539: PUSH
112540: LD_INT 12
112542: PUSH
112543: LD_INT 13
112545: PUSH
112546: LD_INT 14
112548: PUSH
112549: LD_INT 15
112551: PUSH
112552: LD_INT 16
112554: PUSH
112555: LD_INT 17
112557: PUSH
112558: LD_INT 18
112560: PUSH
112561: LD_INT 19
112563: PUSH
112564: LD_INT 20
112566: PUSH
112567: LD_INT 21
112569: PUSH
112570: LD_INT 22
112572: PUSH
112573: LD_INT 23
112575: PUSH
112576: LD_INT 24
112578: PUSH
112579: LD_INT 25
112581: PUSH
112582: LD_INT 26
112584: PUSH
112585: LD_INT 27
112587: PUSH
112588: LD_INT 28
112590: PUSH
112591: LD_INT 29
112593: PUSH
112594: LD_INT 30
112596: PUSH
112597: LD_INT 31
112599: PUSH
112600: LD_INT 32
112602: PUSH
112603: LD_INT 33
112605: PUSH
112606: LD_INT 34
112608: PUSH
112609: LD_INT 36
112611: PUSH
112612: EMPTY
112613: LIST
112614: LIST
112615: LIST
112616: LIST
112617: LIST
112618: LIST
112619: LIST
112620: LIST
112621: LIST
112622: LIST
112623: LIST
112624: LIST
112625: LIST
112626: LIST
112627: LIST
112628: LIST
112629: LIST
112630: LIST
112631: LIST
112632: LIST
112633: LIST
112634: LIST
112635: LIST
112636: LIST
112637: LIST
112638: LIST
112639: LIST
112640: LIST
112641: LIST
112642: LIST
112643: LIST
112644: LIST
112645: LIST
112646: LIST
112647: LIST
112648: PUSH
112649: LD_INT 101
112651: PUSH
112652: LD_INT 102
112654: PUSH
112655: LD_INT 103
112657: PUSH
112658: LD_INT 104
112660: PUSH
112661: LD_INT 105
112663: PUSH
112664: LD_INT 106
112666: PUSH
112667: LD_INT 107
112669: PUSH
112670: LD_INT 108
112672: PUSH
112673: LD_INT 109
112675: PUSH
112676: LD_INT 110
112678: PUSH
112679: LD_INT 111
112681: PUSH
112682: LD_INT 112
112684: PUSH
112685: LD_INT 113
112687: PUSH
112688: LD_INT 114
112690: PUSH
112691: LD_INT 116
112693: PUSH
112694: LD_INT 117
112696: PUSH
112697: LD_INT 118
112699: PUSH
112700: EMPTY
112701: LIST
112702: LIST
112703: LIST
112704: LIST
112705: LIST
112706: LIST
112707: LIST
112708: LIST
112709: LIST
112710: LIST
112711: LIST
112712: LIST
112713: LIST
112714: LIST
112715: LIST
112716: LIST
112717: LIST
112718: PUSH
112719: EMPTY
112720: LIST
112721: LIST
112722: ST_TO_ADDR
112723: GO 113498
112725: LD_INT 16
112727: DOUBLE
112728: EQUAL
112729: IFTRUE 112733
112731: GO 112869
112733: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
112734: LD_ADDR_VAR 0 2
112738: PUSH
112739: LD_INT 2
112741: PUSH
112742: LD_INT 4
112744: PUSH
112745: LD_INT 5
112747: PUSH
112748: LD_INT 7
112750: PUSH
112751: LD_INT 11
112753: PUSH
112754: LD_INT 12
112756: PUSH
112757: LD_INT 15
112759: PUSH
112760: LD_INT 16
112762: PUSH
112763: LD_INT 20
112765: PUSH
112766: LD_INT 21
112768: PUSH
112769: LD_INT 22
112771: PUSH
112772: LD_INT 23
112774: PUSH
112775: LD_INT 25
112777: PUSH
112778: LD_INT 26
112780: PUSH
112781: LD_INT 30
112783: PUSH
112784: LD_INT 31
112786: PUSH
112787: LD_INT 32
112789: PUSH
112790: LD_INT 33
112792: PUSH
112793: LD_INT 34
112795: PUSH
112796: EMPTY
112797: LIST
112798: LIST
112799: LIST
112800: LIST
112801: LIST
112802: LIST
112803: LIST
112804: LIST
112805: LIST
112806: LIST
112807: LIST
112808: LIST
112809: LIST
112810: LIST
112811: LIST
112812: LIST
112813: LIST
112814: LIST
112815: LIST
112816: PUSH
112817: LD_INT 101
112819: PUSH
112820: LD_INT 102
112822: PUSH
112823: LD_INT 103
112825: PUSH
112826: LD_INT 106
112828: PUSH
112829: LD_INT 108
112831: PUSH
112832: LD_INT 112
112834: PUSH
112835: LD_INT 113
112837: PUSH
112838: LD_INT 114
112840: PUSH
112841: LD_INT 116
112843: PUSH
112844: LD_INT 117
112846: PUSH
112847: LD_INT 118
112849: PUSH
112850: EMPTY
112851: LIST
112852: LIST
112853: LIST
112854: LIST
112855: LIST
112856: LIST
112857: LIST
112858: LIST
112859: LIST
112860: LIST
112861: LIST
112862: PUSH
112863: EMPTY
112864: LIST
112865: LIST
112866: ST_TO_ADDR
112867: GO 113498
112869: LD_INT 17
112871: DOUBLE
112872: EQUAL
112873: IFTRUE 112877
112875: GO 113101
112877: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
112878: LD_ADDR_VAR 0 2
112882: PUSH
112883: LD_INT 1
112885: PUSH
112886: LD_INT 2
112888: PUSH
112889: LD_INT 3
112891: PUSH
112892: LD_INT 4
112894: PUSH
112895: LD_INT 5
112897: PUSH
112898: LD_INT 6
112900: PUSH
112901: LD_INT 7
112903: PUSH
112904: LD_INT 8
112906: PUSH
112907: LD_INT 9
112909: PUSH
112910: LD_INT 10
112912: PUSH
112913: LD_INT 11
112915: PUSH
112916: LD_INT 12
112918: PUSH
112919: LD_INT 13
112921: PUSH
112922: LD_INT 14
112924: PUSH
112925: LD_INT 15
112927: PUSH
112928: LD_INT 16
112930: PUSH
112931: LD_INT 17
112933: PUSH
112934: LD_INT 18
112936: PUSH
112937: LD_INT 19
112939: PUSH
112940: LD_INT 20
112942: PUSH
112943: LD_INT 21
112945: PUSH
112946: LD_INT 22
112948: PUSH
112949: LD_INT 23
112951: PUSH
112952: LD_INT 24
112954: PUSH
112955: LD_INT 25
112957: PUSH
112958: LD_INT 26
112960: PUSH
112961: LD_INT 27
112963: PUSH
112964: LD_INT 28
112966: PUSH
112967: LD_INT 29
112969: PUSH
112970: LD_INT 30
112972: PUSH
112973: LD_INT 31
112975: PUSH
112976: LD_INT 32
112978: PUSH
112979: LD_INT 33
112981: PUSH
112982: LD_INT 34
112984: PUSH
112985: LD_INT 36
112987: PUSH
112988: EMPTY
112989: LIST
112990: LIST
112991: LIST
112992: LIST
112993: LIST
112994: LIST
112995: LIST
112996: LIST
112997: LIST
112998: LIST
112999: LIST
113000: LIST
113001: LIST
113002: LIST
113003: LIST
113004: LIST
113005: LIST
113006: LIST
113007: LIST
113008: LIST
113009: LIST
113010: LIST
113011: LIST
113012: LIST
113013: LIST
113014: LIST
113015: LIST
113016: LIST
113017: LIST
113018: LIST
113019: LIST
113020: LIST
113021: LIST
113022: LIST
113023: LIST
113024: PUSH
113025: LD_INT 101
113027: PUSH
113028: LD_INT 102
113030: PUSH
113031: LD_INT 103
113033: PUSH
113034: LD_INT 104
113036: PUSH
113037: LD_INT 105
113039: PUSH
113040: LD_INT 106
113042: PUSH
113043: LD_INT 107
113045: PUSH
113046: LD_INT 108
113048: PUSH
113049: LD_INT 109
113051: PUSH
113052: LD_INT 110
113054: PUSH
113055: LD_INT 111
113057: PUSH
113058: LD_INT 112
113060: PUSH
113061: LD_INT 113
113063: PUSH
113064: LD_INT 114
113066: PUSH
113067: LD_INT 116
113069: PUSH
113070: LD_INT 117
113072: PUSH
113073: LD_INT 118
113075: PUSH
113076: EMPTY
113077: LIST
113078: LIST
113079: LIST
113080: LIST
113081: LIST
113082: LIST
113083: LIST
113084: LIST
113085: LIST
113086: LIST
113087: LIST
113088: LIST
113089: LIST
113090: LIST
113091: LIST
113092: LIST
113093: LIST
113094: PUSH
113095: EMPTY
113096: LIST
113097: LIST
113098: ST_TO_ADDR
113099: GO 113498
113101: LD_INT 18
113103: DOUBLE
113104: EQUAL
113105: IFTRUE 113109
113107: GO 113257
113109: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
113110: LD_ADDR_VAR 0 2
113114: PUSH
113115: LD_INT 2
113117: PUSH
113118: LD_INT 4
113120: PUSH
113121: LD_INT 5
113123: PUSH
113124: LD_INT 7
113126: PUSH
113127: LD_INT 11
113129: PUSH
113130: LD_INT 12
113132: PUSH
113133: LD_INT 15
113135: PUSH
113136: LD_INT 16
113138: PUSH
113139: LD_INT 20
113141: PUSH
113142: LD_INT 21
113144: PUSH
113145: LD_INT 22
113147: PUSH
113148: LD_INT 23
113150: PUSH
113151: LD_INT 25
113153: PUSH
113154: LD_INT 26
113156: PUSH
113157: LD_INT 30
113159: PUSH
113160: LD_INT 31
113162: PUSH
113163: LD_INT 32
113165: PUSH
113166: LD_INT 33
113168: PUSH
113169: LD_INT 34
113171: PUSH
113172: LD_INT 35
113174: PUSH
113175: LD_INT 36
113177: PUSH
113178: EMPTY
113179: LIST
113180: LIST
113181: LIST
113182: LIST
113183: LIST
113184: LIST
113185: LIST
113186: LIST
113187: LIST
113188: LIST
113189: LIST
113190: LIST
113191: LIST
113192: LIST
113193: LIST
113194: LIST
113195: LIST
113196: LIST
113197: LIST
113198: LIST
113199: LIST
113200: PUSH
113201: LD_INT 101
113203: PUSH
113204: LD_INT 102
113206: PUSH
113207: LD_INT 103
113209: PUSH
113210: LD_INT 106
113212: PUSH
113213: LD_INT 108
113215: PUSH
113216: LD_INT 112
113218: PUSH
113219: LD_INT 113
113221: PUSH
113222: LD_INT 114
113224: PUSH
113225: LD_INT 115
113227: PUSH
113228: LD_INT 116
113230: PUSH
113231: LD_INT 117
113233: PUSH
113234: LD_INT 118
113236: PUSH
113237: EMPTY
113238: LIST
113239: LIST
113240: LIST
113241: LIST
113242: LIST
113243: LIST
113244: LIST
113245: LIST
113246: LIST
113247: LIST
113248: LIST
113249: LIST
113250: PUSH
113251: EMPTY
113252: LIST
113253: LIST
113254: ST_TO_ADDR
113255: GO 113498
113257: LD_INT 19
113259: DOUBLE
113260: EQUAL
113261: IFTRUE 113265
113263: GO 113497
113265: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
113266: LD_ADDR_VAR 0 2
113270: PUSH
113271: LD_INT 1
113273: PUSH
113274: LD_INT 2
113276: PUSH
113277: LD_INT 3
113279: PUSH
113280: LD_INT 4
113282: PUSH
113283: LD_INT 5
113285: PUSH
113286: LD_INT 6
113288: PUSH
113289: LD_INT 7
113291: PUSH
113292: LD_INT 8
113294: PUSH
113295: LD_INT 9
113297: PUSH
113298: LD_INT 10
113300: PUSH
113301: LD_INT 11
113303: PUSH
113304: LD_INT 12
113306: PUSH
113307: LD_INT 13
113309: PUSH
113310: LD_INT 14
113312: PUSH
113313: LD_INT 15
113315: PUSH
113316: LD_INT 16
113318: PUSH
113319: LD_INT 17
113321: PUSH
113322: LD_INT 18
113324: PUSH
113325: LD_INT 19
113327: PUSH
113328: LD_INT 20
113330: PUSH
113331: LD_INT 21
113333: PUSH
113334: LD_INT 22
113336: PUSH
113337: LD_INT 23
113339: PUSH
113340: LD_INT 24
113342: PUSH
113343: LD_INT 25
113345: PUSH
113346: LD_INT 26
113348: PUSH
113349: LD_INT 27
113351: PUSH
113352: LD_INT 28
113354: PUSH
113355: LD_INT 29
113357: PUSH
113358: LD_INT 30
113360: PUSH
113361: LD_INT 31
113363: PUSH
113364: LD_INT 32
113366: PUSH
113367: LD_INT 33
113369: PUSH
113370: LD_INT 34
113372: PUSH
113373: LD_INT 35
113375: PUSH
113376: LD_INT 36
113378: PUSH
113379: EMPTY
113380: LIST
113381: LIST
113382: LIST
113383: LIST
113384: LIST
113385: LIST
113386: LIST
113387: LIST
113388: LIST
113389: LIST
113390: LIST
113391: LIST
113392: LIST
113393: LIST
113394: LIST
113395: LIST
113396: LIST
113397: LIST
113398: LIST
113399: LIST
113400: LIST
113401: LIST
113402: LIST
113403: LIST
113404: LIST
113405: LIST
113406: LIST
113407: LIST
113408: LIST
113409: LIST
113410: LIST
113411: LIST
113412: LIST
113413: LIST
113414: LIST
113415: LIST
113416: PUSH
113417: LD_INT 101
113419: PUSH
113420: LD_INT 102
113422: PUSH
113423: LD_INT 103
113425: PUSH
113426: LD_INT 104
113428: PUSH
113429: LD_INT 105
113431: PUSH
113432: LD_INT 106
113434: PUSH
113435: LD_INT 107
113437: PUSH
113438: LD_INT 108
113440: PUSH
113441: LD_INT 109
113443: PUSH
113444: LD_INT 110
113446: PUSH
113447: LD_INT 111
113449: PUSH
113450: LD_INT 112
113452: PUSH
113453: LD_INT 113
113455: PUSH
113456: LD_INT 114
113458: PUSH
113459: LD_INT 115
113461: PUSH
113462: LD_INT 116
113464: PUSH
113465: LD_INT 117
113467: PUSH
113468: LD_INT 118
113470: PUSH
113471: EMPTY
113472: LIST
113473: LIST
113474: LIST
113475: LIST
113476: LIST
113477: LIST
113478: LIST
113479: LIST
113480: LIST
113481: LIST
113482: LIST
113483: LIST
113484: LIST
113485: LIST
113486: LIST
113487: LIST
113488: LIST
113489: LIST
113490: PUSH
113491: EMPTY
113492: LIST
113493: LIST
113494: ST_TO_ADDR
113495: GO 113498
113497: POP
// end else
113498: GO 113729
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
113500: LD_ADDR_VAR 0 2
113504: PUSH
113505: LD_INT 1
113507: PUSH
113508: LD_INT 2
113510: PUSH
113511: LD_INT 3
113513: PUSH
113514: LD_INT 4
113516: PUSH
113517: LD_INT 5
113519: PUSH
113520: LD_INT 6
113522: PUSH
113523: LD_INT 7
113525: PUSH
113526: LD_INT 8
113528: PUSH
113529: LD_INT 9
113531: PUSH
113532: LD_INT 10
113534: PUSH
113535: LD_INT 11
113537: PUSH
113538: LD_INT 12
113540: PUSH
113541: LD_INT 13
113543: PUSH
113544: LD_INT 14
113546: PUSH
113547: LD_INT 15
113549: PUSH
113550: LD_INT 16
113552: PUSH
113553: LD_INT 17
113555: PUSH
113556: LD_INT 18
113558: PUSH
113559: LD_INT 19
113561: PUSH
113562: LD_INT 20
113564: PUSH
113565: LD_INT 21
113567: PUSH
113568: LD_INT 22
113570: PUSH
113571: LD_INT 23
113573: PUSH
113574: LD_INT 24
113576: PUSH
113577: LD_INT 25
113579: PUSH
113580: LD_INT 26
113582: PUSH
113583: LD_INT 27
113585: PUSH
113586: LD_INT 28
113588: PUSH
113589: LD_INT 29
113591: PUSH
113592: LD_INT 30
113594: PUSH
113595: LD_INT 31
113597: PUSH
113598: LD_INT 32
113600: PUSH
113601: LD_INT 33
113603: PUSH
113604: LD_INT 34
113606: PUSH
113607: LD_INT 35
113609: PUSH
113610: LD_INT 36
113612: PUSH
113613: EMPTY
113614: LIST
113615: LIST
113616: LIST
113617: LIST
113618: LIST
113619: LIST
113620: LIST
113621: LIST
113622: LIST
113623: LIST
113624: LIST
113625: LIST
113626: LIST
113627: LIST
113628: LIST
113629: LIST
113630: LIST
113631: LIST
113632: LIST
113633: LIST
113634: LIST
113635: LIST
113636: LIST
113637: LIST
113638: LIST
113639: LIST
113640: LIST
113641: LIST
113642: LIST
113643: LIST
113644: LIST
113645: LIST
113646: LIST
113647: LIST
113648: LIST
113649: LIST
113650: PUSH
113651: LD_INT 101
113653: PUSH
113654: LD_INT 102
113656: PUSH
113657: LD_INT 103
113659: PUSH
113660: LD_INT 104
113662: PUSH
113663: LD_INT 105
113665: PUSH
113666: LD_INT 106
113668: PUSH
113669: LD_INT 107
113671: PUSH
113672: LD_INT 108
113674: PUSH
113675: LD_INT 109
113677: PUSH
113678: LD_INT 110
113680: PUSH
113681: LD_INT 111
113683: PUSH
113684: LD_INT 112
113686: PUSH
113687: LD_INT 113
113689: PUSH
113690: LD_INT 114
113692: PUSH
113693: LD_INT 115
113695: PUSH
113696: LD_INT 116
113698: PUSH
113699: LD_INT 117
113701: PUSH
113702: LD_INT 118
113704: PUSH
113705: EMPTY
113706: LIST
113707: LIST
113708: LIST
113709: LIST
113710: LIST
113711: LIST
113712: LIST
113713: LIST
113714: LIST
113715: LIST
113716: LIST
113717: LIST
113718: LIST
113719: LIST
113720: LIST
113721: LIST
113722: LIST
113723: LIST
113724: PUSH
113725: EMPTY
113726: LIST
113727: LIST
113728: ST_TO_ADDR
// if result then
113729: LD_VAR 0 2
113733: IFFALSE 114519
// begin normal :=  ;
113735: LD_ADDR_VAR 0 5
113739: PUSH
113740: LD_STRING 
113742: ST_TO_ADDR
// hardcore :=  ;
113743: LD_ADDR_VAR 0 6
113747: PUSH
113748: LD_STRING 
113750: ST_TO_ADDR
// active :=  ;
113751: LD_ADDR_VAR 0 7
113755: PUSH
113756: LD_STRING 
113758: ST_TO_ADDR
// for i = 1 to normalCounter do
113759: LD_ADDR_VAR 0 8
113763: PUSH
113764: DOUBLE
113765: LD_INT 1
113767: DEC
113768: ST_TO_ADDR
113769: LD_EXP 144
113773: PUSH
113774: FOR_TO
113775: IFFALSE 113876
// begin tmp := 0 ;
113777: LD_ADDR_VAR 0 3
113781: PUSH
113782: LD_STRING 0
113784: ST_TO_ADDR
// if result [ 1 ] then
113785: LD_VAR 0 2
113789: PUSH
113790: LD_INT 1
113792: ARRAY
113793: IFFALSE 113858
// if result [ 1 ] [ 1 ] = i then
113795: LD_VAR 0 2
113799: PUSH
113800: LD_INT 1
113802: ARRAY
113803: PUSH
113804: LD_INT 1
113806: ARRAY
113807: PUSH
113808: LD_VAR 0 8
113812: EQUAL
113813: IFFALSE 113858
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
113815: LD_ADDR_VAR 0 2
113819: PUSH
113820: LD_VAR 0 2
113824: PPUSH
113825: LD_INT 1
113827: PPUSH
113828: LD_VAR 0 2
113832: PUSH
113833: LD_INT 1
113835: ARRAY
113836: PPUSH
113837: LD_INT 1
113839: PPUSH
113840: CALL_OW 3
113844: PPUSH
113845: CALL_OW 1
113849: ST_TO_ADDR
// tmp := 1 ;
113850: LD_ADDR_VAR 0 3
113854: PUSH
113855: LD_STRING 1
113857: ST_TO_ADDR
// end ; normal := normal & tmp ;
113858: LD_ADDR_VAR 0 5
113862: PUSH
113863: LD_VAR 0 5
113867: PUSH
113868: LD_VAR 0 3
113872: STR
113873: ST_TO_ADDR
// end ;
113874: GO 113774
113876: POP
113877: POP
// for i = 1 to hardcoreCounter do
113878: LD_ADDR_VAR 0 8
113882: PUSH
113883: DOUBLE
113884: LD_INT 1
113886: DEC
113887: ST_TO_ADDR
113888: LD_EXP 145
113892: PUSH
113893: FOR_TO
113894: IFFALSE 113999
// begin tmp := 0 ;
113896: LD_ADDR_VAR 0 3
113900: PUSH
113901: LD_STRING 0
113903: ST_TO_ADDR
// if result [ 2 ] then
113904: LD_VAR 0 2
113908: PUSH
113909: LD_INT 2
113911: ARRAY
113912: IFFALSE 113981
// if result [ 2 ] [ 1 ] = 100 + i then
113914: LD_VAR 0 2
113918: PUSH
113919: LD_INT 2
113921: ARRAY
113922: PUSH
113923: LD_INT 1
113925: ARRAY
113926: PUSH
113927: LD_INT 100
113929: PUSH
113930: LD_VAR 0 8
113934: PLUS
113935: EQUAL
113936: IFFALSE 113981
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
113938: LD_ADDR_VAR 0 2
113942: PUSH
113943: LD_VAR 0 2
113947: PPUSH
113948: LD_INT 2
113950: PPUSH
113951: LD_VAR 0 2
113955: PUSH
113956: LD_INT 2
113958: ARRAY
113959: PPUSH
113960: LD_INT 1
113962: PPUSH
113963: CALL_OW 3
113967: PPUSH
113968: CALL_OW 1
113972: ST_TO_ADDR
// tmp := 1 ;
113973: LD_ADDR_VAR 0 3
113977: PUSH
113978: LD_STRING 1
113980: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
113981: LD_ADDR_VAR 0 6
113985: PUSH
113986: LD_VAR 0 6
113990: PUSH
113991: LD_VAR 0 3
113995: STR
113996: ST_TO_ADDR
// end ;
113997: GO 113893
113999: POP
114000: POP
// if isGameLoad then
114001: LD_VAR 0 1
114005: IFFALSE 114480
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
114007: LD_ADDR_VAR 0 4
114011: PUSH
114012: LD_EXP 148
114016: PUSH
114017: LD_EXP 147
114021: PUSH
114022: LD_EXP 149
114026: PUSH
114027: LD_EXP 146
114031: PUSH
114032: LD_EXP 150
114036: PUSH
114037: LD_EXP 151
114041: PUSH
114042: LD_EXP 152
114046: PUSH
114047: LD_EXP 153
114051: PUSH
114052: LD_EXP 154
114056: PUSH
114057: LD_EXP 155
114061: PUSH
114062: LD_EXP 156
114066: PUSH
114067: LD_EXP 157
114071: PUSH
114072: LD_EXP 158
114076: PUSH
114077: LD_EXP 159
114081: PUSH
114082: LD_EXP 167
114086: PUSH
114087: LD_EXP 168
114091: PUSH
114092: LD_EXP 169
114096: PUSH
114097: LD_EXP 170
114101: PUSH
114102: LD_EXP 172
114106: PUSH
114107: LD_EXP 173
114111: PUSH
114112: LD_EXP 174
114116: PUSH
114117: LD_EXP 177
114121: PUSH
114122: LD_EXP 179
114126: PUSH
114127: LD_EXP 180
114131: PUSH
114132: LD_EXP 181
114136: PUSH
114137: LD_EXP 183
114141: PUSH
114142: LD_EXP 184
114146: PUSH
114147: LD_EXP 187
114151: PUSH
114152: LD_EXP 188
114156: PUSH
114157: LD_EXP 189
114161: PUSH
114162: LD_EXP 190
114166: PUSH
114167: LD_EXP 191
114171: PUSH
114172: LD_EXP 192
114176: PUSH
114177: LD_EXP 193
114181: PUSH
114182: LD_EXP 194
114186: PUSH
114187: LD_EXP 195
114191: PUSH
114192: LD_EXP 160
114196: PUSH
114197: LD_EXP 161
114201: PUSH
114202: LD_EXP 164
114206: PUSH
114207: LD_EXP 165
114211: PUSH
114212: LD_EXP 166
114216: PUSH
114217: LD_EXP 162
114221: PUSH
114222: LD_EXP 163
114226: PUSH
114227: LD_EXP 171
114231: PUSH
114232: LD_EXP 175
114236: PUSH
114237: LD_EXP 176
114241: PUSH
114242: LD_EXP 178
114246: PUSH
114247: LD_EXP 182
114251: PUSH
114252: LD_EXP 185
114256: PUSH
114257: LD_EXP 186
114261: PUSH
114262: LD_EXP 196
114266: PUSH
114267: LD_EXP 197
114271: PUSH
114272: LD_EXP 198
114276: PUSH
114277: LD_EXP 199
114281: PUSH
114282: EMPTY
114283: LIST
114284: LIST
114285: LIST
114286: LIST
114287: LIST
114288: LIST
114289: LIST
114290: LIST
114291: LIST
114292: LIST
114293: LIST
114294: LIST
114295: LIST
114296: LIST
114297: LIST
114298: LIST
114299: LIST
114300: LIST
114301: LIST
114302: LIST
114303: LIST
114304: LIST
114305: LIST
114306: LIST
114307: LIST
114308: LIST
114309: LIST
114310: LIST
114311: LIST
114312: LIST
114313: LIST
114314: LIST
114315: LIST
114316: LIST
114317: LIST
114318: LIST
114319: LIST
114320: LIST
114321: LIST
114322: LIST
114323: LIST
114324: LIST
114325: LIST
114326: LIST
114327: LIST
114328: LIST
114329: LIST
114330: LIST
114331: LIST
114332: LIST
114333: LIST
114334: LIST
114335: LIST
114336: LIST
114337: ST_TO_ADDR
// tmp :=  ;
114338: LD_ADDR_VAR 0 3
114342: PUSH
114343: LD_STRING 
114345: ST_TO_ADDR
// for i = 1 to normalCounter do
114346: LD_ADDR_VAR 0 8
114350: PUSH
114351: DOUBLE
114352: LD_INT 1
114354: DEC
114355: ST_TO_ADDR
114356: LD_EXP 144
114360: PUSH
114361: FOR_TO
114362: IFFALSE 114398
// begin if flags [ i ] then
114364: LD_VAR 0 4
114368: PUSH
114369: LD_VAR 0 8
114373: ARRAY
114374: IFFALSE 114396
// tmp := tmp & i & ; ;
114376: LD_ADDR_VAR 0 3
114380: PUSH
114381: LD_VAR 0 3
114385: PUSH
114386: LD_VAR 0 8
114390: STR
114391: PUSH
114392: LD_STRING ;
114394: STR
114395: ST_TO_ADDR
// end ;
114396: GO 114361
114398: POP
114399: POP
// for i = 1 to hardcoreCounter do
114400: LD_ADDR_VAR 0 8
114404: PUSH
114405: DOUBLE
114406: LD_INT 1
114408: DEC
114409: ST_TO_ADDR
114410: LD_EXP 145
114414: PUSH
114415: FOR_TO
114416: IFFALSE 114462
// begin if flags [ normalCounter + i ] then
114418: LD_VAR 0 4
114422: PUSH
114423: LD_EXP 144
114427: PUSH
114428: LD_VAR 0 8
114432: PLUS
114433: ARRAY
114434: IFFALSE 114460
// tmp := tmp & ( 100 + i ) & ; ;
114436: LD_ADDR_VAR 0 3
114440: PUSH
114441: LD_VAR 0 3
114445: PUSH
114446: LD_INT 100
114448: PUSH
114449: LD_VAR 0 8
114453: PLUS
114454: STR
114455: PUSH
114456: LD_STRING ;
114458: STR
114459: ST_TO_ADDR
// end ;
114460: GO 114415
114462: POP
114463: POP
// if tmp then
114464: LD_VAR 0 3
114468: IFFALSE 114480
// active := tmp ;
114470: LD_ADDR_VAR 0 7
114474: PUSH
114475: LD_VAR 0 3
114479: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
114480: LD_STRING getStreamItemsFromMission("
114482: PUSH
114483: LD_VAR 0 5
114487: STR
114488: PUSH
114489: LD_STRING ","
114491: STR
114492: PUSH
114493: LD_VAR 0 6
114497: STR
114498: PUSH
114499: LD_STRING ","
114501: STR
114502: PUSH
114503: LD_VAR 0 7
114507: STR
114508: PUSH
114509: LD_STRING ")
114511: STR
114512: PPUSH
114513: CALL_OW 559
// end else
114517: GO 114526
// ToLua ( getStreamItemsFromMission("","","") ) ;
114519: LD_STRING getStreamItemsFromMission("","","")
114521: PPUSH
114522: CALL_OW 559
// end ;
114526: LD_VAR 0 2
114530: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
114531: LD_EXP 143
114535: PUSH
114536: LD_EXP 148
114540: AND
114541: IFFALSE 114665
114543: GO 114545
114545: DISABLE
114546: LD_INT 0
114548: PPUSH
114549: PPUSH
// begin enable ;
114550: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
114551: LD_ADDR_VAR 0 2
114555: PUSH
114556: LD_INT 22
114558: PUSH
114559: LD_OWVAR 2
114563: PUSH
114564: EMPTY
114565: LIST
114566: LIST
114567: PUSH
114568: LD_INT 2
114570: PUSH
114571: LD_INT 34
114573: PUSH
114574: LD_INT 7
114576: PUSH
114577: EMPTY
114578: LIST
114579: LIST
114580: PUSH
114581: LD_INT 34
114583: PUSH
114584: LD_INT 45
114586: PUSH
114587: EMPTY
114588: LIST
114589: LIST
114590: PUSH
114591: LD_INT 34
114593: PUSH
114594: LD_INT 28
114596: PUSH
114597: EMPTY
114598: LIST
114599: LIST
114600: PUSH
114601: LD_INT 34
114603: PUSH
114604: LD_INT 47
114606: PUSH
114607: EMPTY
114608: LIST
114609: LIST
114610: PUSH
114611: EMPTY
114612: LIST
114613: LIST
114614: LIST
114615: LIST
114616: LIST
114617: PUSH
114618: EMPTY
114619: LIST
114620: LIST
114621: PPUSH
114622: CALL_OW 69
114626: ST_TO_ADDR
// if not tmp then
114627: LD_VAR 0 2
114631: NOT
114632: IFFALSE 114636
// exit ;
114634: GO 114665
// for i in tmp do
114636: LD_ADDR_VAR 0 1
114640: PUSH
114641: LD_VAR 0 2
114645: PUSH
114646: FOR_IN
114647: IFFALSE 114663
// begin SetLives ( i , 0 ) ;
114649: LD_VAR 0 1
114653: PPUSH
114654: LD_INT 0
114656: PPUSH
114657: CALL_OW 234
// end ;
114661: GO 114646
114663: POP
114664: POP
// end ;
114665: PPOPN 2
114667: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
114668: LD_EXP 143
114672: PUSH
114673: LD_EXP 149
114677: AND
114678: IFFALSE 114762
114680: GO 114682
114682: DISABLE
114683: LD_INT 0
114685: PPUSH
114686: PPUSH
// begin enable ;
114687: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
114688: LD_ADDR_VAR 0 2
114692: PUSH
114693: LD_INT 22
114695: PUSH
114696: LD_OWVAR 2
114700: PUSH
114701: EMPTY
114702: LIST
114703: LIST
114704: PUSH
114705: LD_INT 32
114707: PUSH
114708: LD_INT 3
114710: PUSH
114711: EMPTY
114712: LIST
114713: LIST
114714: PUSH
114715: EMPTY
114716: LIST
114717: LIST
114718: PPUSH
114719: CALL_OW 69
114723: ST_TO_ADDR
// if not tmp then
114724: LD_VAR 0 2
114728: NOT
114729: IFFALSE 114733
// exit ;
114731: GO 114762
// for i in tmp do
114733: LD_ADDR_VAR 0 1
114737: PUSH
114738: LD_VAR 0 2
114742: PUSH
114743: FOR_IN
114744: IFFALSE 114760
// begin SetLives ( i , 0 ) ;
114746: LD_VAR 0 1
114750: PPUSH
114751: LD_INT 0
114753: PPUSH
114754: CALL_OW 234
// end ;
114758: GO 114743
114760: POP
114761: POP
// end ;
114762: PPOPN 2
114764: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
114765: LD_EXP 143
114769: PUSH
114770: LD_EXP 146
114774: AND
114775: IFFALSE 114868
114777: GO 114779
114779: DISABLE
114780: LD_INT 0
114782: PPUSH
// begin enable ;
114783: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
114784: LD_ADDR_VAR 0 1
114788: PUSH
114789: LD_INT 22
114791: PUSH
114792: LD_OWVAR 2
114796: PUSH
114797: EMPTY
114798: LIST
114799: LIST
114800: PUSH
114801: LD_INT 2
114803: PUSH
114804: LD_INT 25
114806: PUSH
114807: LD_INT 5
114809: PUSH
114810: EMPTY
114811: LIST
114812: LIST
114813: PUSH
114814: LD_INT 25
114816: PUSH
114817: LD_INT 9
114819: PUSH
114820: EMPTY
114821: LIST
114822: LIST
114823: PUSH
114824: LD_INT 25
114826: PUSH
114827: LD_INT 8
114829: PUSH
114830: EMPTY
114831: LIST
114832: LIST
114833: PUSH
114834: EMPTY
114835: LIST
114836: LIST
114837: LIST
114838: LIST
114839: PUSH
114840: EMPTY
114841: LIST
114842: LIST
114843: PPUSH
114844: CALL_OW 69
114848: PUSH
114849: FOR_IN
114850: IFFALSE 114866
// begin SetClass ( i , 1 ) ;
114852: LD_VAR 0 1
114856: PPUSH
114857: LD_INT 1
114859: PPUSH
114860: CALL_OW 336
// end ;
114864: GO 114849
114866: POP
114867: POP
// end ;
114868: PPOPN 1
114870: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
114871: LD_EXP 143
114875: PUSH
114876: LD_EXP 147
114880: AND
114881: PUSH
114882: LD_OWVAR 65
114886: PUSH
114887: LD_INT 7
114889: LESS
114890: AND
114891: IFFALSE 114905
114893: GO 114895
114895: DISABLE
// begin enable ;
114896: ENABLE
// game_speed := 7 ;
114897: LD_ADDR_OWVAR 65
114901: PUSH
114902: LD_INT 7
114904: ST_TO_ADDR
// end ;
114905: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
114906: LD_EXP 143
114910: PUSH
114911: LD_EXP 150
114915: AND
114916: IFFALSE 115118
114918: GO 114920
114920: DISABLE
114921: LD_INT 0
114923: PPUSH
114924: PPUSH
114925: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
114926: LD_ADDR_VAR 0 3
114930: PUSH
114931: LD_INT 81
114933: PUSH
114934: LD_OWVAR 2
114938: PUSH
114939: EMPTY
114940: LIST
114941: LIST
114942: PUSH
114943: LD_INT 21
114945: PUSH
114946: LD_INT 1
114948: PUSH
114949: EMPTY
114950: LIST
114951: LIST
114952: PUSH
114953: EMPTY
114954: LIST
114955: LIST
114956: PPUSH
114957: CALL_OW 69
114961: ST_TO_ADDR
// if not tmp then
114962: LD_VAR 0 3
114966: NOT
114967: IFFALSE 114971
// exit ;
114969: GO 115118
// if tmp > 5 then
114971: LD_VAR 0 3
114975: PUSH
114976: LD_INT 5
114978: GREATER
114979: IFFALSE 114991
// k := 5 else
114981: LD_ADDR_VAR 0 2
114985: PUSH
114986: LD_INT 5
114988: ST_TO_ADDR
114989: GO 115001
// k := tmp ;
114991: LD_ADDR_VAR 0 2
114995: PUSH
114996: LD_VAR 0 3
115000: ST_TO_ADDR
// for i := 1 to k do
115001: LD_ADDR_VAR 0 1
115005: PUSH
115006: DOUBLE
115007: LD_INT 1
115009: DEC
115010: ST_TO_ADDR
115011: LD_VAR 0 2
115015: PUSH
115016: FOR_TO
115017: IFFALSE 115116
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
115019: LD_VAR 0 3
115023: PUSH
115024: LD_VAR 0 1
115028: ARRAY
115029: PPUSH
115030: LD_VAR 0 1
115034: PUSH
115035: LD_INT 4
115037: MOD
115038: PUSH
115039: LD_INT 1
115041: PLUS
115042: PPUSH
115043: CALL_OW 259
115047: PUSH
115048: LD_INT 10
115050: LESS
115051: IFFALSE 115114
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
115053: LD_VAR 0 3
115057: PUSH
115058: LD_VAR 0 1
115062: ARRAY
115063: PPUSH
115064: LD_VAR 0 1
115068: PUSH
115069: LD_INT 4
115071: MOD
115072: PUSH
115073: LD_INT 1
115075: PLUS
115076: PPUSH
115077: LD_VAR 0 3
115081: PUSH
115082: LD_VAR 0 1
115086: ARRAY
115087: PPUSH
115088: LD_VAR 0 1
115092: PUSH
115093: LD_INT 4
115095: MOD
115096: PUSH
115097: LD_INT 1
115099: PLUS
115100: PPUSH
115101: CALL_OW 259
115105: PUSH
115106: LD_INT 1
115108: PLUS
115109: PPUSH
115110: CALL_OW 237
115114: GO 115016
115116: POP
115117: POP
// end ;
115118: PPOPN 3
115120: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
115121: LD_EXP 143
115125: PUSH
115126: LD_EXP 151
115130: AND
115131: IFFALSE 115151
115133: GO 115135
115135: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
115136: LD_INT 4
115138: PPUSH
115139: LD_OWVAR 2
115143: PPUSH
115144: LD_INT 0
115146: PPUSH
115147: CALL_OW 324
115151: END
// every 0 0$1 trigger StreamModeActive and sShovel do
115152: LD_EXP 143
115156: PUSH
115157: LD_EXP 180
115161: AND
115162: IFFALSE 115182
115164: GO 115166
115166: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
115167: LD_INT 19
115169: PPUSH
115170: LD_OWVAR 2
115174: PPUSH
115175: LD_INT 0
115177: PPUSH
115178: CALL_OW 324
115182: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
115183: LD_EXP 143
115187: PUSH
115188: LD_EXP 152
115192: AND
115193: IFFALSE 115295
115195: GO 115197
115197: DISABLE
115198: LD_INT 0
115200: PPUSH
115201: PPUSH
// begin enable ;
115202: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
115203: LD_ADDR_VAR 0 2
115207: PUSH
115208: LD_INT 22
115210: PUSH
115211: LD_OWVAR 2
115215: PUSH
115216: EMPTY
115217: LIST
115218: LIST
115219: PUSH
115220: LD_INT 2
115222: PUSH
115223: LD_INT 34
115225: PUSH
115226: LD_INT 11
115228: PUSH
115229: EMPTY
115230: LIST
115231: LIST
115232: PUSH
115233: LD_INT 34
115235: PUSH
115236: LD_INT 30
115238: PUSH
115239: EMPTY
115240: LIST
115241: LIST
115242: PUSH
115243: EMPTY
115244: LIST
115245: LIST
115246: LIST
115247: PUSH
115248: EMPTY
115249: LIST
115250: LIST
115251: PPUSH
115252: CALL_OW 69
115256: ST_TO_ADDR
// if not tmp then
115257: LD_VAR 0 2
115261: NOT
115262: IFFALSE 115266
// exit ;
115264: GO 115295
// for i in tmp do
115266: LD_ADDR_VAR 0 1
115270: PUSH
115271: LD_VAR 0 2
115275: PUSH
115276: FOR_IN
115277: IFFALSE 115293
// begin SetLives ( i , 0 ) ;
115279: LD_VAR 0 1
115283: PPUSH
115284: LD_INT 0
115286: PPUSH
115287: CALL_OW 234
// end ;
115291: GO 115276
115293: POP
115294: POP
// end ;
115295: PPOPN 2
115297: END
// every 0 0$1 trigger StreamModeActive and sBunker do
115298: LD_EXP 143
115302: PUSH
115303: LD_EXP 153
115307: AND
115308: IFFALSE 115328
115310: GO 115312
115312: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
115313: LD_INT 32
115315: PPUSH
115316: LD_OWVAR 2
115320: PPUSH
115321: LD_INT 0
115323: PPUSH
115324: CALL_OW 324
115328: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
115329: LD_EXP 143
115333: PUSH
115334: LD_EXP 154
115338: AND
115339: IFFALSE 115520
115341: GO 115343
115343: DISABLE
115344: LD_INT 0
115346: PPUSH
115347: PPUSH
115348: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
115349: LD_ADDR_VAR 0 2
115353: PUSH
115354: LD_INT 22
115356: PUSH
115357: LD_OWVAR 2
115361: PUSH
115362: EMPTY
115363: LIST
115364: LIST
115365: PUSH
115366: LD_INT 33
115368: PUSH
115369: LD_INT 3
115371: PUSH
115372: EMPTY
115373: LIST
115374: LIST
115375: PUSH
115376: EMPTY
115377: LIST
115378: LIST
115379: PPUSH
115380: CALL_OW 69
115384: ST_TO_ADDR
// if not tmp then
115385: LD_VAR 0 2
115389: NOT
115390: IFFALSE 115394
// exit ;
115392: GO 115520
// side := 0 ;
115394: LD_ADDR_VAR 0 3
115398: PUSH
115399: LD_INT 0
115401: ST_TO_ADDR
// for i := 1 to 8 do
115402: LD_ADDR_VAR 0 1
115406: PUSH
115407: DOUBLE
115408: LD_INT 1
115410: DEC
115411: ST_TO_ADDR
115412: LD_INT 8
115414: PUSH
115415: FOR_TO
115416: IFFALSE 115464
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
115418: LD_OWVAR 2
115422: PUSH
115423: LD_VAR 0 1
115427: NONEQUAL
115428: PUSH
115429: LD_OWVAR 2
115433: PPUSH
115434: LD_VAR 0 1
115438: PPUSH
115439: CALL_OW 81
115443: PUSH
115444: LD_INT 2
115446: EQUAL
115447: AND
115448: IFFALSE 115462
// begin side := i ;
115450: LD_ADDR_VAR 0 3
115454: PUSH
115455: LD_VAR 0 1
115459: ST_TO_ADDR
// break ;
115460: GO 115464
// end ;
115462: GO 115415
115464: POP
115465: POP
// if not side then
115466: LD_VAR 0 3
115470: NOT
115471: IFFALSE 115475
// exit ;
115473: GO 115520
// for i := 1 to tmp do
115475: LD_ADDR_VAR 0 1
115479: PUSH
115480: DOUBLE
115481: LD_INT 1
115483: DEC
115484: ST_TO_ADDR
115485: LD_VAR 0 2
115489: PUSH
115490: FOR_TO
115491: IFFALSE 115518
// if Prob ( 60 ) then
115493: LD_INT 60
115495: PPUSH
115496: CALL_OW 13
115500: IFFALSE 115516
// SetSide ( i , side ) ;
115502: LD_VAR 0 1
115506: PPUSH
115507: LD_VAR 0 3
115511: PPUSH
115512: CALL_OW 235
115516: GO 115490
115518: POP
115519: POP
// end ;
115520: PPOPN 3
115522: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
115523: LD_EXP 143
115527: PUSH
115528: LD_EXP 156
115532: AND
115533: IFFALSE 115652
115535: GO 115537
115537: DISABLE
115538: LD_INT 0
115540: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
115541: LD_ADDR_VAR 0 1
115545: PUSH
115546: LD_INT 22
115548: PUSH
115549: LD_OWVAR 2
115553: PUSH
115554: EMPTY
115555: LIST
115556: LIST
115557: PUSH
115558: LD_INT 21
115560: PUSH
115561: LD_INT 1
115563: PUSH
115564: EMPTY
115565: LIST
115566: LIST
115567: PUSH
115568: LD_INT 3
115570: PUSH
115571: LD_INT 23
115573: PUSH
115574: LD_INT 0
115576: PUSH
115577: EMPTY
115578: LIST
115579: LIST
115580: PUSH
115581: EMPTY
115582: LIST
115583: LIST
115584: PUSH
115585: EMPTY
115586: LIST
115587: LIST
115588: LIST
115589: PPUSH
115590: CALL_OW 69
115594: PUSH
115595: FOR_IN
115596: IFFALSE 115650
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
115598: LD_VAR 0 1
115602: PPUSH
115603: CALL_OW 257
115607: PUSH
115608: LD_INT 1
115610: PUSH
115611: LD_INT 2
115613: PUSH
115614: LD_INT 3
115616: PUSH
115617: LD_INT 4
115619: PUSH
115620: EMPTY
115621: LIST
115622: LIST
115623: LIST
115624: LIST
115625: IN
115626: IFFALSE 115648
// SetClass ( un , rand ( 1 , 4 ) ) ;
115628: LD_VAR 0 1
115632: PPUSH
115633: LD_INT 1
115635: PPUSH
115636: LD_INT 4
115638: PPUSH
115639: CALL_OW 12
115643: PPUSH
115644: CALL_OW 336
115648: GO 115595
115650: POP
115651: POP
// end ;
115652: PPOPN 1
115654: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
115655: LD_EXP 143
115659: PUSH
115660: LD_EXP 155
115664: AND
115665: IFFALSE 115744
115667: GO 115669
115669: DISABLE
115670: LD_INT 0
115672: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115673: LD_ADDR_VAR 0 1
115677: PUSH
115678: LD_INT 22
115680: PUSH
115681: LD_OWVAR 2
115685: PUSH
115686: EMPTY
115687: LIST
115688: LIST
115689: PUSH
115690: LD_INT 21
115692: PUSH
115693: LD_INT 3
115695: PUSH
115696: EMPTY
115697: LIST
115698: LIST
115699: PUSH
115700: EMPTY
115701: LIST
115702: LIST
115703: PPUSH
115704: CALL_OW 69
115708: ST_TO_ADDR
// if not tmp then
115709: LD_VAR 0 1
115713: NOT
115714: IFFALSE 115718
// exit ;
115716: GO 115744
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
115718: LD_VAR 0 1
115722: PUSH
115723: LD_INT 1
115725: PPUSH
115726: LD_VAR 0 1
115730: PPUSH
115731: CALL_OW 12
115735: ARRAY
115736: PPUSH
115737: LD_INT 100
115739: PPUSH
115740: CALL_OW 234
// end ;
115744: PPOPN 1
115746: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
115747: LD_EXP 143
115751: PUSH
115752: LD_EXP 157
115756: AND
115757: IFFALSE 115855
115759: GO 115761
115761: DISABLE
115762: LD_INT 0
115764: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
115765: LD_ADDR_VAR 0 1
115769: PUSH
115770: LD_INT 22
115772: PUSH
115773: LD_OWVAR 2
115777: PUSH
115778: EMPTY
115779: LIST
115780: LIST
115781: PUSH
115782: LD_INT 21
115784: PUSH
115785: LD_INT 1
115787: PUSH
115788: EMPTY
115789: LIST
115790: LIST
115791: PUSH
115792: EMPTY
115793: LIST
115794: LIST
115795: PPUSH
115796: CALL_OW 69
115800: ST_TO_ADDR
// if not tmp then
115801: LD_VAR 0 1
115805: NOT
115806: IFFALSE 115810
// exit ;
115808: GO 115855
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
115810: LD_VAR 0 1
115814: PUSH
115815: LD_INT 1
115817: PPUSH
115818: LD_VAR 0 1
115822: PPUSH
115823: CALL_OW 12
115827: ARRAY
115828: PPUSH
115829: LD_INT 1
115831: PPUSH
115832: LD_INT 4
115834: PPUSH
115835: CALL_OW 12
115839: PPUSH
115840: LD_INT 3000
115842: PPUSH
115843: LD_INT 9000
115845: PPUSH
115846: CALL_OW 12
115850: PPUSH
115851: CALL_OW 492
// end ;
115855: PPOPN 1
115857: END
// every 0 0$1 trigger StreamModeActive and sDepot do
115858: LD_EXP 143
115862: PUSH
115863: LD_EXP 158
115867: AND
115868: IFFALSE 115888
115870: GO 115872
115872: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
115873: LD_INT 1
115875: PPUSH
115876: LD_OWVAR 2
115880: PPUSH
115881: LD_INT 0
115883: PPUSH
115884: CALL_OW 324
115888: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
115889: LD_EXP 143
115893: PUSH
115894: LD_EXP 159
115898: AND
115899: IFFALSE 115982
115901: GO 115903
115903: DISABLE
115904: LD_INT 0
115906: PPUSH
115907: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115908: LD_ADDR_VAR 0 2
115912: PUSH
115913: LD_INT 22
115915: PUSH
115916: LD_OWVAR 2
115920: PUSH
115921: EMPTY
115922: LIST
115923: LIST
115924: PUSH
115925: LD_INT 21
115927: PUSH
115928: LD_INT 3
115930: PUSH
115931: EMPTY
115932: LIST
115933: LIST
115934: PUSH
115935: EMPTY
115936: LIST
115937: LIST
115938: PPUSH
115939: CALL_OW 69
115943: ST_TO_ADDR
// if not tmp then
115944: LD_VAR 0 2
115948: NOT
115949: IFFALSE 115953
// exit ;
115951: GO 115982
// for i in tmp do
115953: LD_ADDR_VAR 0 1
115957: PUSH
115958: LD_VAR 0 2
115962: PUSH
115963: FOR_IN
115964: IFFALSE 115980
// SetBLevel ( i , 10 ) ;
115966: LD_VAR 0 1
115970: PPUSH
115971: LD_INT 10
115973: PPUSH
115974: CALL_OW 241
115978: GO 115963
115980: POP
115981: POP
// end ;
115982: PPOPN 2
115984: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
115985: LD_EXP 143
115989: PUSH
115990: LD_EXP 160
115994: AND
115995: IFFALSE 116106
115997: GO 115999
115999: DISABLE
116000: LD_INT 0
116002: PPUSH
116003: PPUSH
116004: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116005: LD_ADDR_VAR 0 3
116009: PUSH
116010: LD_INT 22
116012: PUSH
116013: LD_OWVAR 2
116017: PUSH
116018: EMPTY
116019: LIST
116020: LIST
116021: PUSH
116022: LD_INT 25
116024: PUSH
116025: LD_INT 1
116027: PUSH
116028: EMPTY
116029: LIST
116030: LIST
116031: PUSH
116032: EMPTY
116033: LIST
116034: LIST
116035: PPUSH
116036: CALL_OW 69
116040: ST_TO_ADDR
// if not tmp then
116041: LD_VAR 0 3
116045: NOT
116046: IFFALSE 116050
// exit ;
116048: GO 116106
// un := tmp [ rand ( 1 , tmp ) ] ;
116050: LD_ADDR_VAR 0 2
116054: PUSH
116055: LD_VAR 0 3
116059: PUSH
116060: LD_INT 1
116062: PPUSH
116063: LD_VAR 0 3
116067: PPUSH
116068: CALL_OW 12
116072: ARRAY
116073: ST_TO_ADDR
// if Crawls ( un ) then
116074: LD_VAR 0 2
116078: PPUSH
116079: CALL_OW 318
116083: IFFALSE 116094
// ComWalk ( un ) ;
116085: LD_VAR 0 2
116089: PPUSH
116090: CALL_OW 138
// SetClass ( un , class_sniper ) ;
116094: LD_VAR 0 2
116098: PPUSH
116099: LD_INT 5
116101: PPUSH
116102: CALL_OW 336
// end ;
116106: PPOPN 3
116108: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
116109: LD_EXP 143
116113: PUSH
116114: LD_EXP 161
116118: AND
116119: PUSH
116120: LD_OWVAR 67
116124: PUSH
116125: LD_INT 4
116127: LESS
116128: AND
116129: IFFALSE 116148
116131: GO 116133
116133: DISABLE
// begin Difficulty := Difficulty + 1 ;
116134: LD_ADDR_OWVAR 67
116138: PUSH
116139: LD_OWVAR 67
116143: PUSH
116144: LD_INT 1
116146: PLUS
116147: ST_TO_ADDR
// end ;
116148: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
116149: LD_EXP 143
116153: PUSH
116154: LD_EXP 162
116158: AND
116159: IFFALSE 116262
116161: GO 116163
116163: DISABLE
116164: LD_INT 0
116166: PPUSH
// begin for i := 1 to 5 do
116167: LD_ADDR_VAR 0 1
116171: PUSH
116172: DOUBLE
116173: LD_INT 1
116175: DEC
116176: ST_TO_ADDR
116177: LD_INT 5
116179: PUSH
116180: FOR_TO
116181: IFFALSE 116260
// begin uc_nation := nation_nature ;
116183: LD_ADDR_OWVAR 21
116187: PUSH
116188: LD_INT 0
116190: ST_TO_ADDR
// uc_side := 0 ;
116191: LD_ADDR_OWVAR 20
116195: PUSH
116196: LD_INT 0
116198: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116199: LD_ADDR_OWVAR 29
116203: PUSH
116204: LD_INT 12
116206: PUSH
116207: LD_INT 12
116209: PUSH
116210: EMPTY
116211: LIST
116212: LIST
116213: ST_TO_ADDR
// hc_agressivity := 20 ;
116214: LD_ADDR_OWVAR 35
116218: PUSH
116219: LD_INT 20
116221: ST_TO_ADDR
// hc_class := class_tiger ;
116222: LD_ADDR_OWVAR 28
116226: PUSH
116227: LD_INT 14
116229: ST_TO_ADDR
// hc_gallery :=  ;
116230: LD_ADDR_OWVAR 33
116234: PUSH
116235: LD_STRING 
116237: ST_TO_ADDR
// hc_name :=  ;
116238: LD_ADDR_OWVAR 26
116242: PUSH
116243: LD_STRING 
116245: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
116246: CALL_OW 44
116250: PPUSH
116251: LD_INT 0
116253: PPUSH
116254: CALL_OW 51
// end ;
116258: GO 116180
116260: POP
116261: POP
// end ;
116262: PPOPN 1
116264: END
// every 0 0$1 trigger StreamModeActive and sBomb do
116265: LD_EXP 143
116269: PUSH
116270: LD_EXP 163
116274: AND
116275: IFFALSE 116284
116277: GO 116279
116279: DISABLE
// StreamSibBomb ;
116280: CALL 116285 0 0
116284: END
// export function StreamSibBomb ; var i , x , y ; begin
116285: LD_INT 0
116287: PPUSH
116288: PPUSH
116289: PPUSH
116290: PPUSH
// result := false ;
116291: LD_ADDR_VAR 0 1
116295: PUSH
116296: LD_INT 0
116298: ST_TO_ADDR
// for i := 1 to 16 do
116299: LD_ADDR_VAR 0 2
116303: PUSH
116304: DOUBLE
116305: LD_INT 1
116307: DEC
116308: ST_TO_ADDR
116309: LD_INT 16
116311: PUSH
116312: FOR_TO
116313: IFFALSE 116512
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116315: LD_ADDR_VAR 0 3
116319: PUSH
116320: LD_INT 10
116322: PUSH
116323: LD_INT 20
116325: PUSH
116326: LD_INT 30
116328: PUSH
116329: LD_INT 40
116331: PUSH
116332: LD_INT 50
116334: PUSH
116335: LD_INT 60
116337: PUSH
116338: LD_INT 70
116340: PUSH
116341: LD_INT 80
116343: PUSH
116344: LD_INT 90
116346: PUSH
116347: LD_INT 100
116349: PUSH
116350: LD_INT 110
116352: PUSH
116353: LD_INT 120
116355: PUSH
116356: LD_INT 130
116358: PUSH
116359: LD_INT 140
116361: PUSH
116362: LD_INT 150
116364: PUSH
116365: EMPTY
116366: LIST
116367: LIST
116368: LIST
116369: LIST
116370: LIST
116371: LIST
116372: LIST
116373: LIST
116374: LIST
116375: LIST
116376: LIST
116377: LIST
116378: LIST
116379: LIST
116380: LIST
116381: PUSH
116382: LD_INT 1
116384: PPUSH
116385: LD_INT 15
116387: PPUSH
116388: CALL_OW 12
116392: ARRAY
116393: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116394: LD_ADDR_VAR 0 4
116398: PUSH
116399: LD_INT 10
116401: PUSH
116402: LD_INT 20
116404: PUSH
116405: LD_INT 30
116407: PUSH
116408: LD_INT 40
116410: PUSH
116411: LD_INT 50
116413: PUSH
116414: LD_INT 60
116416: PUSH
116417: LD_INT 70
116419: PUSH
116420: LD_INT 80
116422: PUSH
116423: LD_INT 90
116425: PUSH
116426: LD_INT 100
116428: PUSH
116429: LD_INT 110
116431: PUSH
116432: LD_INT 120
116434: PUSH
116435: LD_INT 130
116437: PUSH
116438: LD_INT 140
116440: PUSH
116441: LD_INT 150
116443: PUSH
116444: EMPTY
116445: LIST
116446: LIST
116447: LIST
116448: LIST
116449: LIST
116450: LIST
116451: LIST
116452: LIST
116453: LIST
116454: LIST
116455: LIST
116456: LIST
116457: LIST
116458: LIST
116459: LIST
116460: PUSH
116461: LD_INT 1
116463: PPUSH
116464: LD_INT 15
116466: PPUSH
116467: CALL_OW 12
116471: ARRAY
116472: ST_TO_ADDR
// if ValidHex ( x , y ) then
116473: LD_VAR 0 3
116477: PPUSH
116478: LD_VAR 0 4
116482: PPUSH
116483: CALL_OW 488
116487: IFFALSE 116510
// begin result := [ x , y ] ;
116489: LD_ADDR_VAR 0 1
116493: PUSH
116494: LD_VAR 0 3
116498: PUSH
116499: LD_VAR 0 4
116503: PUSH
116504: EMPTY
116505: LIST
116506: LIST
116507: ST_TO_ADDR
// break ;
116508: GO 116512
// end ; end ;
116510: GO 116312
116512: POP
116513: POP
// if result then
116514: LD_VAR 0 1
116518: IFFALSE 116578
// begin ToLua ( playSibBomb() ) ;
116520: LD_STRING playSibBomb()
116522: PPUSH
116523: CALL_OW 559
// wait ( 0 0$14 ) ;
116527: LD_INT 490
116529: PPUSH
116530: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
116534: LD_VAR 0 1
116538: PUSH
116539: LD_INT 1
116541: ARRAY
116542: PPUSH
116543: LD_VAR 0 1
116547: PUSH
116548: LD_INT 2
116550: ARRAY
116551: PPUSH
116552: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
116556: LD_VAR 0 1
116560: PUSH
116561: LD_INT 1
116563: ARRAY
116564: PPUSH
116565: LD_VAR 0 1
116569: PUSH
116570: LD_INT 2
116572: ARRAY
116573: PPUSH
116574: CALL_OW 429
// end ; end ;
116578: LD_VAR 0 1
116582: RET
// every 0 0$1 trigger StreamModeActive and sReset do
116583: LD_EXP 143
116587: PUSH
116588: LD_EXP 165
116592: AND
116593: IFFALSE 116605
116595: GO 116597
116597: DISABLE
// YouLost (  ) ;
116598: LD_STRING 
116600: PPUSH
116601: CALL_OW 104
116605: END
// every 0 0$1 trigger StreamModeActive and sFog do
116606: LD_EXP 143
116610: PUSH
116611: LD_EXP 164
116615: AND
116616: IFFALSE 116630
116618: GO 116620
116620: DISABLE
// FogOff ( your_side ) ;
116621: LD_OWVAR 2
116625: PPUSH
116626: CALL_OW 344
116630: END
// every 0 0$1 trigger StreamModeActive and sSun do
116631: LD_EXP 143
116635: PUSH
116636: LD_EXP 166
116640: AND
116641: IFFALSE 116669
116643: GO 116645
116645: DISABLE
// begin solar_recharge_percent := 0 ;
116646: LD_ADDR_OWVAR 79
116650: PUSH
116651: LD_INT 0
116653: ST_TO_ADDR
// wait ( 5 5$00 ) ;
116654: LD_INT 10500
116656: PPUSH
116657: CALL_OW 67
// solar_recharge_percent := 100 ;
116661: LD_ADDR_OWVAR 79
116665: PUSH
116666: LD_INT 100
116668: ST_TO_ADDR
// end ;
116669: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
116670: LD_EXP 143
116674: PUSH
116675: LD_EXP 167
116679: AND
116680: IFFALSE 116919
116682: GO 116684
116684: DISABLE
116685: LD_INT 0
116687: PPUSH
116688: PPUSH
116689: PPUSH
// begin tmp := [ ] ;
116690: LD_ADDR_VAR 0 3
116694: PUSH
116695: EMPTY
116696: ST_TO_ADDR
// for i := 1 to 6 do
116697: LD_ADDR_VAR 0 1
116701: PUSH
116702: DOUBLE
116703: LD_INT 1
116705: DEC
116706: ST_TO_ADDR
116707: LD_INT 6
116709: PUSH
116710: FOR_TO
116711: IFFALSE 116816
// begin uc_nation := nation_nature ;
116713: LD_ADDR_OWVAR 21
116717: PUSH
116718: LD_INT 0
116720: ST_TO_ADDR
// uc_side := 0 ;
116721: LD_ADDR_OWVAR 20
116725: PUSH
116726: LD_INT 0
116728: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116729: LD_ADDR_OWVAR 29
116733: PUSH
116734: LD_INT 12
116736: PUSH
116737: LD_INT 12
116739: PUSH
116740: EMPTY
116741: LIST
116742: LIST
116743: ST_TO_ADDR
// hc_agressivity := 20 ;
116744: LD_ADDR_OWVAR 35
116748: PUSH
116749: LD_INT 20
116751: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
116752: LD_ADDR_OWVAR 28
116756: PUSH
116757: LD_INT 17
116759: ST_TO_ADDR
// hc_gallery :=  ;
116760: LD_ADDR_OWVAR 33
116764: PUSH
116765: LD_STRING 
116767: ST_TO_ADDR
// hc_name :=  ;
116768: LD_ADDR_OWVAR 26
116772: PUSH
116773: LD_STRING 
116775: ST_TO_ADDR
// un := CreateHuman ;
116776: LD_ADDR_VAR 0 2
116780: PUSH
116781: CALL_OW 44
116785: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
116786: LD_VAR 0 2
116790: PPUSH
116791: LD_INT 1
116793: PPUSH
116794: CALL_OW 51
// tmp := tmp ^ un ;
116798: LD_ADDR_VAR 0 3
116802: PUSH
116803: LD_VAR 0 3
116807: PUSH
116808: LD_VAR 0 2
116812: ADD
116813: ST_TO_ADDR
// end ;
116814: GO 116710
116816: POP
116817: POP
// repeat wait ( 0 0$1 ) ;
116818: LD_INT 35
116820: PPUSH
116821: CALL_OW 67
// for un in tmp do
116825: LD_ADDR_VAR 0 2
116829: PUSH
116830: LD_VAR 0 3
116834: PUSH
116835: FOR_IN
116836: IFFALSE 116910
// begin if IsDead ( un ) then
116838: LD_VAR 0 2
116842: PPUSH
116843: CALL_OW 301
116847: IFFALSE 116867
// begin tmp := tmp diff un ;
116849: LD_ADDR_VAR 0 3
116853: PUSH
116854: LD_VAR 0 3
116858: PUSH
116859: LD_VAR 0 2
116863: DIFF
116864: ST_TO_ADDR
// continue ;
116865: GO 116835
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
116867: LD_VAR 0 2
116871: PPUSH
116872: LD_INT 3
116874: PUSH
116875: LD_INT 22
116877: PUSH
116878: LD_INT 0
116880: PUSH
116881: EMPTY
116882: LIST
116883: LIST
116884: PUSH
116885: EMPTY
116886: LIST
116887: LIST
116888: PPUSH
116889: CALL_OW 69
116893: PPUSH
116894: LD_VAR 0 2
116898: PPUSH
116899: CALL_OW 74
116903: PPUSH
116904: CALL_OW 115
// end ;
116908: GO 116835
116910: POP
116911: POP
// until not tmp ;
116912: LD_VAR 0 3
116916: NOT
116917: IFFALSE 116818
// end ;
116919: PPOPN 3
116921: END
// every 0 0$1 trigger StreamModeActive and sTroll do
116922: LD_EXP 143
116926: PUSH
116927: LD_EXP 168
116931: AND
116932: IFFALSE 116986
116934: GO 116936
116936: DISABLE
// begin ToLua ( displayTroll(); ) ;
116937: LD_STRING displayTroll();
116939: PPUSH
116940: CALL_OW 559
// wait ( 3 3$00 ) ;
116944: LD_INT 6300
116946: PPUSH
116947: CALL_OW 67
// ToLua ( hideTroll(); ) ;
116951: LD_STRING hideTroll();
116953: PPUSH
116954: CALL_OW 559
// wait ( 1 1$00 ) ;
116958: LD_INT 2100
116960: PPUSH
116961: CALL_OW 67
// ToLua ( displayTroll(); ) ;
116965: LD_STRING displayTroll();
116967: PPUSH
116968: CALL_OW 559
// wait ( 1 1$00 ) ;
116972: LD_INT 2100
116974: PPUSH
116975: CALL_OW 67
// ToLua ( hideTroll(); ) ;
116979: LD_STRING hideTroll();
116981: PPUSH
116982: CALL_OW 559
// end ;
116986: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
116987: LD_EXP 143
116991: PUSH
116992: LD_EXP 169
116996: AND
116997: IFFALSE 117060
116999: GO 117001
117001: DISABLE
117002: LD_INT 0
117004: PPUSH
// begin p := 0 ;
117005: LD_ADDR_VAR 0 1
117009: PUSH
117010: LD_INT 0
117012: ST_TO_ADDR
// repeat game_speed := 1 ;
117013: LD_ADDR_OWVAR 65
117017: PUSH
117018: LD_INT 1
117020: ST_TO_ADDR
// wait ( 0 0$1 ) ;
117021: LD_INT 35
117023: PPUSH
117024: CALL_OW 67
// p := p + 1 ;
117028: LD_ADDR_VAR 0 1
117032: PUSH
117033: LD_VAR 0 1
117037: PUSH
117038: LD_INT 1
117040: PLUS
117041: ST_TO_ADDR
// until p >= 60 ;
117042: LD_VAR 0 1
117046: PUSH
117047: LD_INT 60
117049: GREATEREQUAL
117050: IFFALSE 117013
// game_speed := 4 ;
117052: LD_ADDR_OWVAR 65
117056: PUSH
117057: LD_INT 4
117059: ST_TO_ADDR
// end ;
117060: PPOPN 1
117062: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
117063: LD_EXP 143
117067: PUSH
117068: LD_EXP 170
117072: AND
117073: IFFALSE 117219
117075: GO 117077
117077: DISABLE
117078: LD_INT 0
117080: PPUSH
117081: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117082: LD_ADDR_VAR 0 1
117086: PUSH
117087: LD_INT 22
117089: PUSH
117090: LD_OWVAR 2
117094: PUSH
117095: EMPTY
117096: LIST
117097: LIST
117098: PUSH
117099: LD_INT 2
117101: PUSH
117102: LD_INT 30
117104: PUSH
117105: LD_INT 0
117107: PUSH
117108: EMPTY
117109: LIST
117110: LIST
117111: PUSH
117112: LD_INT 30
117114: PUSH
117115: LD_INT 1
117117: PUSH
117118: EMPTY
117119: LIST
117120: LIST
117121: PUSH
117122: EMPTY
117123: LIST
117124: LIST
117125: LIST
117126: PUSH
117127: EMPTY
117128: LIST
117129: LIST
117130: PPUSH
117131: CALL_OW 69
117135: ST_TO_ADDR
// if not depot then
117136: LD_VAR 0 1
117140: NOT
117141: IFFALSE 117145
// exit ;
117143: GO 117219
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
117145: LD_ADDR_VAR 0 2
117149: PUSH
117150: LD_VAR 0 1
117154: PUSH
117155: LD_INT 1
117157: PPUSH
117158: LD_VAR 0 1
117162: PPUSH
117163: CALL_OW 12
117167: ARRAY
117168: PPUSH
117169: CALL_OW 274
117173: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
117174: LD_VAR 0 2
117178: PPUSH
117179: LD_INT 1
117181: PPUSH
117182: LD_INT 0
117184: PPUSH
117185: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
117189: LD_VAR 0 2
117193: PPUSH
117194: LD_INT 2
117196: PPUSH
117197: LD_INT 0
117199: PPUSH
117200: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
117204: LD_VAR 0 2
117208: PPUSH
117209: LD_INT 3
117211: PPUSH
117212: LD_INT 0
117214: PPUSH
117215: CALL_OW 277
// end ;
117219: PPOPN 2
117221: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
117222: LD_EXP 143
117226: PUSH
117227: LD_EXP 171
117231: AND
117232: IFFALSE 117329
117234: GO 117236
117236: DISABLE
117237: LD_INT 0
117239: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117240: LD_ADDR_VAR 0 1
117244: PUSH
117245: LD_INT 22
117247: PUSH
117248: LD_OWVAR 2
117252: PUSH
117253: EMPTY
117254: LIST
117255: LIST
117256: PUSH
117257: LD_INT 21
117259: PUSH
117260: LD_INT 1
117262: PUSH
117263: EMPTY
117264: LIST
117265: LIST
117266: PUSH
117267: LD_INT 3
117269: PUSH
117270: LD_INT 23
117272: PUSH
117273: LD_INT 0
117275: PUSH
117276: EMPTY
117277: LIST
117278: LIST
117279: PUSH
117280: EMPTY
117281: LIST
117282: LIST
117283: PUSH
117284: EMPTY
117285: LIST
117286: LIST
117287: LIST
117288: PPUSH
117289: CALL_OW 69
117293: ST_TO_ADDR
// if not tmp then
117294: LD_VAR 0 1
117298: NOT
117299: IFFALSE 117303
// exit ;
117301: GO 117329
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
117303: LD_VAR 0 1
117307: PUSH
117308: LD_INT 1
117310: PPUSH
117311: LD_VAR 0 1
117315: PPUSH
117316: CALL_OW 12
117320: ARRAY
117321: PPUSH
117322: LD_INT 200
117324: PPUSH
117325: CALL_OW 234
// end ;
117329: PPOPN 1
117331: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
117332: LD_EXP 143
117336: PUSH
117337: LD_EXP 172
117341: AND
117342: IFFALSE 117421
117344: GO 117346
117346: DISABLE
117347: LD_INT 0
117349: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
117350: LD_ADDR_VAR 0 1
117354: PUSH
117355: LD_INT 22
117357: PUSH
117358: LD_OWVAR 2
117362: PUSH
117363: EMPTY
117364: LIST
117365: LIST
117366: PUSH
117367: LD_INT 21
117369: PUSH
117370: LD_INT 2
117372: PUSH
117373: EMPTY
117374: LIST
117375: LIST
117376: PUSH
117377: EMPTY
117378: LIST
117379: LIST
117380: PPUSH
117381: CALL_OW 69
117385: ST_TO_ADDR
// if not tmp then
117386: LD_VAR 0 1
117390: NOT
117391: IFFALSE 117395
// exit ;
117393: GO 117421
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
117395: LD_VAR 0 1
117399: PUSH
117400: LD_INT 1
117402: PPUSH
117403: LD_VAR 0 1
117407: PPUSH
117408: CALL_OW 12
117412: ARRAY
117413: PPUSH
117414: LD_INT 60
117416: PPUSH
117417: CALL_OW 234
// end ;
117421: PPOPN 1
117423: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
117424: LD_EXP 143
117428: PUSH
117429: LD_EXP 173
117433: AND
117434: IFFALSE 117533
117436: GO 117438
117438: DISABLE
117439: LD_INT 0
117441: PPUSH
117442: PPUSH
// begin enable ;
117443: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
117444: LD_ADDR_VAR 0 1
117448: PUSH
117449: LD_INT 22
117451: PUSH
117452: LD_OWVAR 2
117456: PUSH
117457: EMPTY
117458: LIST
117459: LIST
117460: PUSH
117461: LD_INT 61
117463: PUSH
117464: EMPTY
117465: LIST
117466: PUSH
117467: LD_INT 33
117469: PUSH
117470: LD_INT 2
117472: PUSH
117473: EMPTY
117474: LIST
117475: LIST
117476: PUSH
117477: EMPTY
117478: LIST
117479: LIST
117480: LIST
117481: PPUSH
117482: CALL_OW 69
117486: ST_TO_ADDR
// if not tmp then
117487: LD_VAR 0 1
117491: NOT
117492: IFFALSE 117496
// exit ;
117494: GO 117533
// for i in tmp do
117496: LD_ADDR_VAR 0 2
117500: PUSH
117501: LD_VAR 0 1
117505: PUSH
117506: FOR_IN
117507: IFFALSE 117531
// if IsControledBy ( i ) then
117509: LD_VAR 0 2
117513: PPUSH
117514: CALL_OW 312
117518: IFFALSE 117529
// ComUnlink ( i ) ;
117520: LD_VAR 0 2
117524: PPUSH
117525: CALL_OW 136
117529: GO 117506
117531: POP
117532: POP
// end ;
117533: PPOPN 2
117535: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
117536: LD_EXP 143
117540: PUSH
117541: LD_EXP 174
117545: AND
117546: IFFALSE 117686
117548: GO 117550
117550: DISABLE
117551: LD_INT 0
117553: PPUSH
117554: PPUSH
// begin ToLua ( displayPowell(); ) ;
117555: LD_STRING displayPowell();
117557: PPUSH
117558: CALL_OW 559
// uc_side := 0 ;
117562: LD_ADDR_OWVAR 20
117566: PUSH
117567: LD_INT 0
117569: ST_TO_ADDR
// uc_nation := 2 ;
117570: LD_ADDR_OWVAR 21
117574: PUSH
117575: LD_INT 2
117577: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
117578: LD_ADDR_OWVAR 37
117582: PUSH
117583: LD_INT 14
117585: ST_TO_ADDR
// vc_engine := engine_siberite ;
117586: LD_ADDR_OWVAR 39
117590: PUSH
117591: LD_INT 3
117593: ST_TO_ADDR
// vc_control := control_apeman ;
117594: LD_ADDR_OWVAR 38
117598: PUSH
117599: LD_INT 5
117601: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
117602: LD_ADDR_OWVAR 40
117606: PUSH
117607: LD_INT 29
117609: ST_TO_ADDR
// un := CreateVehicle ;
117610: LD_ADDR_VAR 0 2
117614: PUSH
117615: CALL_OW 45
117619: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117620: LD_VAR 0 2
117624: PPUSH
117625: LD_INT 1
117627: PPUSH
117628: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
117632: LD_INT 35
117634: PPUSH
117635: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
117639: LD_VAR 0 2
117643: PPUSH
117644: LD_INT 22
117646: PUSH
117647: LD_OWVAR 2
117651: PUSH
117652: EMPTY
117653: LIST
117654: LIST
117655: PPUSH
117656: CALL_OW 69
117660: PPUSH
117661: LD_VAR 0 2
117665: PPUSH
117666: CALL_OW 74
117670: PPUSH
117671: CALL_OW 115
// until IsDead ( un ) ;
117675: LD_VAR 0 2
117679: PPUSH
117680: CALL_OW 301
117684: IFFALSE 117632
// end ;
117686: PPOPN 2
117688: END
// every 0 0$1 trigger StreamModeActive and sStu do
117689: LD_EXP 143
117693: PUSH
117694: LD_EXP 182
117698: AND
117699: IFFALSE 117715
117701: GO 117703
117703: DISABLE
// begin ToLua ( displayStucuk(); ) ;
117704: LD_STRING displayStucuk();
117706: PPUSH
117707: CALL_OW 559
// ResetFog ;
117711: CALL_OW 335
// end ;
117715: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
117716: LD_EXP 143
117720: PUSH
117721: LD_EXP 175
117725: AND
117726: IFFALSE 117867
117728: GO 117730
117730: DISABLE
117731: LD_INT 0
117733: PPUSH
117734: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117735: LD_ADDR_VAR 0 2
117739: PUSH
117740: LD_INT 22
117742: PUSH
117743: LD_OWVAR 2
117747: PUSH
117748: EMPTY
117749: LIST
117750: LIST
117751: PUSH
117752: LD_INT 21
117754: PUSH
117755: LD_INT 1
117757: PUSH
117758: EMPTY
117759: LIST
117760: LIST
117761: PUSH
117762: EMPTY
117763: LIST
117764: LIST
117765: PPUSH
117766: CALL_OW 69
117770: ST_TO_ADDR
// if not tmp then
117771: LD_VAR 0 2
117775: NOT
117776: IFFALSE 117780
// exit ;
117778: GO 117867
// un := tmp [ rand ( 1 , tmp ) ] ;
117780: LD_ADDR_VAR 0 1
117784: PUSH
117785: LD_VAR 0 2
117789: PUSH
117790: LD_INT 1
117792: PPUSH
117793: LD_VAR 0 2
117797: PPUSH
117798: CALL_OW 12
117802: ARRAY
117803: ST_TO_ADDR
// SetSide ( un , 0 ) ;
117804: LD_VAR 0 1
117808: PPUSH
117809: LD_INT 0
117811: PPUSH
117812: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
117816: LD_VAR 0 1
117820: PPUSH
117821: LD_OWVAR 3
117825: PUSH
117826: LD_VAR 0 1
117830: DIFF
117831: PPUSH
117832: LD_VAR 0 1
117836: PPUSH
117837: CALL_OW 74
117841: PPUSH
117842: CALL_OW 115
// wait ( 0 0$20 ) ;
117846: LD_INT 700
117848: PPUSH
117849: CALL_OW 67
// SetSide ( un , your_side ) ;
117853: LD_VAR 0 1
117857: PPUSH
117858: LD_OWVAR 2
117862: PPUSH
117863: CALL_OW 235
// end ;
117867: PPOPN 2
117869: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
117870: LD_EXP 143
117874: PUSH
117875: LD_EXP 176
117879: AND
117880: IFFALSE 117986
117882: GO 117884
117884: DISABLE
117885: LD_INT 0
117887: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117888: LD_ADDR_VAR 0 1
117892: PUSH
117893: LD_INT 22
117895: PUSH
117896: LD_OWVAR 2
117900: PUSH
117901: EMPTY
117902: LIST
117903: LIST
117904: PUSH
117905: LD_INT 2
117907: PUSH
117908: LD_INT 30
117910: PUSH
117911: LD_INT 0
117913: PUSH
117914: EMPTY
117915: LIST
117916: LIST
117917: PUSH
117918: LD_INT 30
117920: PUSH
117921: LD_INT 1
117923: PUSH
117924: EMPTY
117925: LIST
117926: LIST
117927: PUSH
117928: EMPTY
117929: LIST
117930: LIST
117931: LIST
117932: PUSH
117933: EMPTY
117934: LIST
117935: LIST
117936: PPUSH
117937: CALL_OW 69
117941: ST_TO_ADDR
// if not depot then
117942: LD_VAR 0 1
117946: NOT
117947: IFFALSE 117951
// exit ;
117949: GO 117986
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
117951: LD_VAR 0 1
117955: PUSH
117956: LD_INT 1
117958: ARRAY
117959: PPUSH
117960: CALL_OW 250
117964: PPUSH
117965: LD_VAR 0 1
117969: PUSH
117970: LD_INT 1
117972: ARRAY
117973: PPUSH
117974: CALL_OW 251
117978: PPUSH
117979: LD_INT 70
117981: PPUSH
117982: CALL_OW 495
// end ;
117986: PPOPN 1
117988: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
117989: LD_EXP 143
117993: PUSH
117994: LD_EXP 177
117998: AND
117999: IFFALSE 118210
118001: GO 118003
118003: DISABLE
118004: LD_INT 0
118006: PPUSH
118007: PPUSH
118008: PPUSH
118009: PPUSH
118010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118011: LD_ADDR_VAR 0 5
118015: PUSH
118016: LD_INT 22
118018: PUSH
118019: LD_OWVAR 2
118023: PUSH
118024: EMPTY
118025: LIST
118026: LIST
118027: PUSH
118028: LD_INT 21
118030: PUSH
118031: LD_INT 1
118033: PUSH
118034: EMPTY
118035: LIST
118036: LIST
118037: PUSH
118038: EMPTY
118039: LIST
118040: LIST
118041: PPUSH
118042: CALL_OW 69
118046: ST_TO_ADDR
// if not tmp then
118047: LD_VAR 0 5
118051: NOT
118052: IFFALSE 118056
// exit ;
118054: GO 118210
// for i in tmp do
118056: LD_ADDR_VAR 0 1
118060: PUSH
118061: LD_VAR 0 5
118065: PUSH
118066: FOR_IN
118067: IFFALSE 118208
// begin d := rand ( 0 , 5 ) ;
118069: LD_ADDR_VAR 0 4
118073: PUSH
118074: LD_INT 0
118076: PPUSH
118077: LD_INT 5
118079: PPUSH
118080: CALL_OW 12
118084: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
118085: LD_ADDR_VAR 0 2
118089: PUSH
118090: LD_VAR 0 1
118094: PPUSH
118095: CALL_OW 250
118099: PPUSH
118100: LD_VAR 0 4
118104: PPUSH
118105: LD_INT 3
118107: PPUSH
118108: LD_INT 12
118110: PPUSH
118111: CALL_OW 12
118115: PPUSH
118116: CALL_OW 272
118120: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
118121: LD_ADDR_VAR 0 3
118125: PUSH
118126: LD_VAR 0 1
118130: PPUSH
118131: CALL_OW 251
118135: PPUSH
118136: LD_VAR 0 4
118140: PPUSH
118141: LD_INT 3
118143: PPUSH
118144: LD_INT 12
118146: PPUSH
118147: CALL_OW 12
118151: PPUSH
118152: CALL_OW 273
118156: ST_TO_ADDR
// if ValidHex ( x , y ) then
118157: LD_VAR 0 2
118161: PPUSH
118162: LD_VAR 0 3
118166: PPUSH
118167: CALL_OW 488
118171: IFFALSE 118206
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
118173: LD_VAR 0 1
118177: PPUSH
118178: LD_VAR 0 2
118182: PPUSH
118183: LD_VAR 0 3
118187: PPUSH
118188: LD_INT 3
118190: PPUSH
118191: LD_INT 6
118193: PPUSH
118194: CALL_OW 12
118198: PPUSH
118199: LD_INT 1
118201: PPUSH
118202: CALL_OW 483
// end ;
118206: GO 118066
118208: POP
118209: POP
// end ;
118210: PPOPN 5
118212: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
118213: LD_EXP 143
118217: PUSH
118218: LD_EXP 178
118222: AND
118223: IFFALSE 118317
118225: GO 118227
118227: DISABLE
118228: LD_INT 0
118230: PPUSH
118231: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
118232: LD_ADDR_VAR 0 2
118236: PUSH
118237: LD_INT 22
118239: PUSH
118240: LD_OWVAR 2
118244: PUSH
118245: EMPTY
118246: LIST
118247: LIST
118248: PUSH
118249: LD_INT 32
118251: PUSH
118252: LD_INT 1
118254: PUSH
118255: EMPTY
118256: LIST
118257: LIST
118258: PUSH
118259: LD_INT 21
118261: PUSH
118262: LD_INT 2
118264: PUSH
118265: EMPTY
118266: LIST
118267: LIST
118268: PUSH
118269: EMPTY
118270: LIST
118271: LIST
118272: LIST
118273: PPUSH
118274: CALL_OW 69
118278: ST_TO_ADDR
// if not tmp then
118279: LD_VAR 0 2
118283: NOT
118284: IFFALSE 118288
// exit ;
118286: GO 118317
// for i in tmp do
118288: LD_ADDR_VAR 0 1
118292: PUSH
118293: LD_VAR 0 2
118297: PUSH
118298: FOR_IN
118299: IFFALSE 118315
// SetFuel ( i , 0 ) ;
118301: LD_VAR 0 1
118305: PPUSH
118306: LD_INT 0
118308: PPUSH
118309: CALL_OW 240
118313: GO 118298
118315: POP
118316: POP
// end ;
118317: PPOPN 2
118319: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
118320: LD_EXP 143
118324: PUSH
118325: LD_EXP 179
118329: AND
118330: IFFALSE 118396
118332: GO 118334
118334: DISABLE
118335: LD_INT 0
118337: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118338: LD_ADDR_VAR 0 1
118342: PUSH
118343: LD_INT 22
118345: PUSH
118346: LD_OWVAR 2
118350: PUSH
118351: EMPTY
118352: LIST
118353: LIST
118354: PUSH
118355: LD_INT 30
118357: PUSH
118358: LD_INT 29
118360: PUSH
118361: EMPTY
118362: LIST
118363: LIST
118364: PUSH
118365: EMPTY
118366: LIST
118367: LIST
118368: PPUSH
118369: CALL_OW 69
118373: ST_TO_ADDR
// if not tmp then
118374: LD_VAR 0 1
118378: NOT
118379: IFFALSE 118383
// exit ;
118381: GO 118396
// DestroyUnit ( tmp [ 1 ] ) ;
118383: LD_VAR 0 1
118387: PUSH
118388: LD_INT 1
118390: ARRAY
118391: PPUSH
118392: CALL_OW 65
// end ;
118396: PPOPN 1
118398: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
118399: LD_EXP 143
118403: PUSH
118404: LD_EXP 181
118408: AND
118409: IFFALSE 118538
118411: GO 118413
118413: DISABLE
118414: LD_INT 0
118416: PPUSH
// begin uc_side := 0 ;
118417: LD_ADDR_OWVAR 20
118421: PUSH
118422: LD_INT 0
118424: ST_TO_ADDR
// uc_nation := nation_arabian ;
118425: LD_ADDR_OWVAR 21
118429: PUSH
118430: LD_INT 2
118432: ST_TO_ADDR
// hc_gallery :=  ;
118433: LD_ADDR_OWVAR 33
118437: PUSH
118438: LD_STRING 
118440: ST_TO_ADDR
// hc_name :=  ;
118441: LD_ADDR_OWVAR 26
118445: PUSH
118446: LD_STRING 
118448: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
118449: LD_INT 1
118451: PPUSH
118452: LD_INT 11
118454: PPUSH
118455: LD_INT 10
118457: PPUSH
118458: CALL_OW 380
// un := CreateHuman ;
118462: LD_ADDR_VAR 0 1
118466: PUSH
118467: CALL_OW 44
118471: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118472: LD_VAR 0 1
118476: PPUSH
118477: LD_INT 1
118479: PPUSH
118480: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118484: LD_INT 35
118486: PPUSH
118487: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118491: LD_VAR 0 1
118495: PPUSH
118496: LD_INT 22
118498: PUSH
118499: LD_OWVAR 2
118503: PUSH
118504: EMPTY
118505: LIST
118506: LIST
118507: PPUSH
118508: CALL_OW 69
118512: PPUSH
118513: LD_VAR 0 1
118517: PPUSH
118518: CALL_OW 74
118522: PPUSH
118523: CALL_OW 115
// until IsDead ( un ) ;
118527: LD_VAR 0 1
118531: PPUSH
118532: CALL_OW 301
118536: IFFALSE 118484
// end ;
118538: PPOPN 1
118540: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
118541: LD_EXP 143
118545: PUSH
118546: LD_EXP 183
118550: AND
118551: IFFALSE 118563
118553: GO 118555
118555: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
118556: LD_STRING earthquake(getX(game), 0, 32)
118558: PPUSH
118559: CALL_OW 559
118563: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
118564: LD_EXP 143
118568: PUSH
118569: LD_EXP 184
118573: AND
118574: IFFALSE 118665
118576: GO 118578
118578: DISABLE
118579: LD_INT 0
118581: PPUSH
// begin enable ;
118582: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
118583: LD_ADDR_VAR 0 1
118587: PUSH
118588: LD_INT 22
118590: PUSH
118591: LD_OWVAR 2
118595: PUSH
118596: EMPTY
118597: LIST
118598: LIST
118599: PUSH
118600: LD_INT 21
118602: PUSH
118603: LD_INT 2
118605: PUSH
118606: EMPTY
118607: LIST
118608: LIST
118609: PUSH
118610: LD_INT 33
118612: PUSH
118613: LD_INT 3
118615: PUSH
118616: EMPTY
118617: LIST
118618: LIST
118619: PUSH
118620: EMPTY
118621: LIST
118622: LIST
118623: LIST
118624: PPUSH
118625: CALL_OW 69
118629: ST_TO_ADDR
// if not tmp then
118630: LD_VAR 0 1
118634: NOT
118635: IFFALSE 118639
// exit ;
118637: GO 118665
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118639: LD_VAR 0 1
118643: PUSH
118644: LD_INT 1
118646: PPUSH
118647: LD_VAR 0 1
118651: PPUSH
118652: CALL_OW 12
118656: ARRAY
118657: PPUSH
118658: LD_INT 1
118660: PPUSH
118661: CALL_OW 234
// end ;
118665: PPOPN 1
118667: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
118668: LD_EXP 143
118672: PUSH
118673: LD_EXP 185
118677: AND
118678: IFFALSE 118819
118680: GO 118682
118682: DISABLE
118683: LD_INT 0
118685: PPUSH
118686: PPUSH
118687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118688: LD_ADDR_VAR 0 3
118692: PUSH
118693: LD_INT 22
118695: PUSH
118696: LD_OWVAR 2
118700: PUSH
118701: EMPTY
118702: LIST
118703: LIST
118704: PUSH
118705: LD_INT 25
118707: PUSH
118708: LD_INT 1
118710: PUSH
118711: EMPTY
118712: LIST
118713: LIST
118714: PUSH
118715: EMPTY
118716: LIST
118717: LIST
118718: PPUSH
118719: CALL_OW 69
118723: ST_TO_ADDR
// if not tmp then
118724: LD_VAR 0 3
118728: NOT
118729: IFFALSE 118733
// exit ;
118731: GO 118819
// un := tmp [ rand ( 1 , tmp ) ] ;
118733: LD_ADDR_VAR 0 2
118737: PUSH
118738: LD_VAR 0 3
118742: PUSH
118743: LD_INT 1
118745: PPUSH
118746: LD_VAR 0 3
118750: PPUSH
118751: CALL_OW 12
118755: ARRAY
118756: ST_TO_ADDR
// if Crawls ( un ) then
118757: LD_VAR 0 2
118761: PPUSH
118762: CALL_OW 318
118766: IFFALSE 118777
// ComWalk ( un ) ;
118768: LD_VAR 0 2
118772: PPUSH
118773: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
118777: LD_VAR 0 2
118781: PPUSH
118782: LD_INT 9
118784: PPUSH
118785: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
118789: LD_INT 28
118791: PPUSH
118792: LD_OWVAR 2
118796: PPUSH
118797: LD_INT 2
118799: PPUSH
118800: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
118804: LD_INT 29
118806: PPUSH
118807: LD_OWVAR 2
118811: PPUSH
118812: LD_INT 2
118814: PPUSH
118815: CALL_OW 322
// end ;
118819: PPOPN 3
118821: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
118822: LD_EXP 143
118826: PUSH
118827: LD_EXP 186
118831: AND
118832: IFFALSE 118943
118834: GO 118836
118836: DISABLE
118837: LD_INT 0
118839: PPUSH
118840: PPUSH
118841: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118842: LD_ADDR_VAR 0 3
118846: PUSH
118847: LD_INT 22
118849: PUSH
118850: LD_OWVAR 2
118854: PUSH
118855: EMPTY
118856: LIST
118857: LIST
118858: PUSH
118859: LD_INT 25
118861: PUSH
118862: LD_INT 1
118864: PUSH
118865: EMPTY
118866: LIST
118867: LIST
118868: PUSH
118869: EMPTY
118870: LIST
118871: LIST
118872: PPUSH
118873: CALL_OW 69
118877: ST_TO_ADDR
// if not tmp then
118878: LD_VAR 0 3
118882: NOT
118883: IFFALSE 118887
// exit ;
118885: GO 118943
// un := tmp [ rand ( 1 , tmp ) ] ;
118887: LD_ADDR_VAR 0 2
118891: PUSH
118892: LD_VAR 0 3
118896: PUSH
118897: LD_INT 1
118899: PPUSH
118900: LD_VAR 0 3
118904: PPUSH
118905: CALL_OW 12
118909: ARRAY
118910: ST_TO_ADDR
// if Crawls ( un ) then
118911: LD_VAR 0 2
118915: PPUSH
118916: CALL_OW 318
118920: IFFALSE 118931
// ComWalk ( un ) ;
118922: LD_VAR 0 2
118926: PPUSH
118927: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118931: LD_VAR 0 2
118935: PPUSH
118936: LD_INT 8
118938: PPUSH
118939: CALL_OW 336
// end ;
118943: PPOPN 3
118945: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
118946: LD_EXP 143
118950: PUSH
118951: LD_EXP 187
118955: AND
118956: IFFALSE 119100
118958: GO 118960
118960: DISABLE
118961: LD_INT 0
118963: PPUSH
118964: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
118965: LD_ADDR_VAR 0 2
118969: PUSH
118970: LD_INT 22
118972: PUSH
118973: LD_OWVAR 2
118977: PUSH
118978: EMPTY
118979: LIST
118980: LIST
118981: PUSH
118982: LD_INT 21
118984: PUSH
118985: LD_INT 2
118987: PUSH
118988: EMPTY
118989: LIST
118990: LIST
118991: PUSH
118992: LD_INT 2
118994: PUSH
118995: LD_INT 34
118997: PUSH
118998: LD_INT 12
119000: PUSH
119001: EMPTY
119002: LIST
119003: LIST
119004: PUSH
119005: LD_INT 34
119007: PUSH
119008: LD_INT 51
119010: PUSH
119011: EMPTY
119012: LIST
119013: LIST
119014: PUSH
119015: LD_INT 34
119017: PUSH
119018: LD_INT 32
119020: PUSH
119021: EMPTY
119022: LIST
119023: LIST
119024: PUSH
119025: EMPTY
119026: LIST
119027: LIST
119028: LIST
119029: LIST
119030: PUSH
119031: EMPTY
119032: LIST
119033: LIST
119034: LIST
119035: PPUSH
119036: CALL_OW 69
119040: ST_TO_ADDR
// if not tmp then
119041: LD_VAR 0 2
119045: NOT
119046: IFFALSE 119050
// exit ;
119048: GO 119100
// for i in tmp do
119050: LD_ADDR_VAR 0 1
119054: PUSH
119055: LD_VAR 0 2
119059: PUSH
119060: FOR_IN
119061: IFFALSE 119098
// if GetCargo ( i , mat_artifact ) = 0 then
119063: LD_VAR 0 1
119067: PPUSH
119068: LD_INT 4
119070: PPUSH
119071: CALL_OW 289
119075: PUSH
119076: LD_INT 0
119078: EQUAL
119079: IFFALSE 119096
// SetCargo ( i , mat_siberit , 100 ) ;
119081: LD_VAR 0 1
119085: PPUSH
119086: LD_INT 3
119088: PPUSH
119089: LD_INT 100
119091: PPUSH
119092: CALL_OW 290
119096: GO 119060
119098: POP
119099: POP
// end ;
119100: PPOPN 2
119102: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
119103: LD_EXP 143
119107: PUSH
119108: LD_EXP 188
119112: AND
119113: IFFALSE 119296
119115: GO 119117
119117: DISABLE
119118: LD_INT 0
119120: PPUSH
119121: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119122: LD_ADDR_VAR 0 2
119126: PUSH
119127: LD_INT 22
119129: PUSH
119130: LD_OWVAR 2
119134: PUSH
119135: EMPTY
119136: LIST
119137: LIST
119138: PPUSH
119139: CALL_OW 69
119143: ST_TO_ADDR
// if not tmp then
119144: LD_VAR 0 2
119148: NOT
119149: IFFALSE 119153
// exit ;
119151: GO 119296
// for i := 1 to 2 do
119153: LD_ADDR_VAR 0 1
119157: PUSH
119158: DOUBLE
119159: LD_INT 1
119161: DEC
119162: ST_TO_ADDR
119163: LD_INT 2
119165: PUSH
119166: FOR_TO
119167: IFFALSE 119294
// begin uc_side := your_side ;
119169: LD_ADDR_OWVAR 20
119173: PUSH
119174: LD_OWVAR 2
119178: ST_TO_ADDR
// uc_nation := nation_american ;
119179: LD_ADDR_OWVAR 21
119183: PUSH
119184: LD_INT 1
119186: ST_TO_ADDR
// vc_chassis := us_morphling ;
119187: LD_ADDR_OWVAR 37
119191: PUSH
119192: LD_INT 5
119194: ST_TO_ADDR
// vc_engine := engine_siberite ;
119195: LD_ADDR_OWVAR 39
119199: PUSH
119200: LD_INT 3
119202: ST_TO_ADDR
// vc_control := control_computer ;
119203: LD_ADDR_OWVAR 38
119207: PUSH
119208: LD_INT 3
119210: ST_TO_ADDR
// vc_weapon := us_double_laser ;
119211: LD_ADDR_OWVAR 40
119215: PUSH
119216: LD_INT 10
119218: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
119219: LD_VAR 0 2
119223: PUSH
119224: LD_INT 1
119226: ARRAY
119227: PPUSH
119228: CALL_OW 310
119232: NOT
119233: IFFALSE 119280
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
119235: CALL_OW 45
119239: PPUSH
119240: LD_VAR 0 2
119244: PUSH
119245: LD_INT 1
119247: ARRAY
119248: PPUSH
119249: CALL_OW 250
119253: PPUSH
119254: LD_VAR 0 2
119258: PUSH
119259: LD_INT 1
119261: ARRAY
119262: PPUSH
119263: CALL_OW 251
119267: PPUSH
119268: LD_INT 12
119270: PPUSH
119271: LD_INT 1
119273: PPUSH
119274: CALL_OW 50
119278: GO 119292
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
119280: CALL_OW 45
119284: PPUSH
119285: LD_INT 1
119287: PPUSH
119288: CALL_OW 51
// end ;
119292: GO 119166
119294: POP
119295: POP
// end ;
119296: PPOPN 2
119298: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
119299: LD_EXP 143
119303: PUSH
119304: LD_EXP 189
119308: AND
119309: IFFALSE 119531
119311: GO 119313
119313: DISABLE
119314: LD_INT 0
119316: PPUSH
119317: PPUSH
119318: PPUSH
119319: PPUSH
119320: PPUSH
119321: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119322: LD_ADDR_VAR 0 6
119326: PUSH
119327: LD_INT 22
119329: PUSH
119330: LD_OWVAR 2
119334: PUSH
119335: EMPTY
119336: LIST
119337: LIST
119338: PUSH
119339: LD_INT 21
119341: PUSH
119342: LD_INT 1
119344: PUSH
119345: EMPTY
119346: LIST
119347: LIST
119348: PUSH
119349: LD_INT 3
119351: PUSH
119352: LD_INT 23
119354: PUSH
119355: LD_INT 0
119357: PUSH
119358: EMPTY
119359: LIST
119360: LIST
119361: PUSH
119362: EMPTY
119363: LIST
119364: LIST
119365: PUSH
119366: EMPTY
119367: LIST
119368: LIST
119369: LIST
119370: PPUSH
119371: CALL_OW 69
119375: ST_TO_ADDR
// if not tmp then
119376: LD_VAR 0 6
119380: NOT
119381: IFFALSE 119385
// exit ;
119383: GO 119531
// s1 := rand ( 1 , 4 ) ;
119385: LD_ADDR_VAR 0 2
119389: PUSH
119390: LD_INT 1
119392: PPUSH
119393: LD_INT 4
119395: PPUSH
119396: CALL_OW 12
119400: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
119401: LD_ADDR_VAR 0 4
119405: PUSH
119406: LD_VAR 0 6
119410: PUSH
119411: LD_INT 1
119413: ARRAY
119414: PPUSH
119415: LD_VAR 0 2
119419: PPUSH
119420: CALL_OW 259
119424: ST_TO_ADDR
// if s1 = 1 then
119425: LD_VAR 0 2
119429: PUSH
119430: LD_INT 1
119432: EQUAL
119433: IFFALSE 119453
// s2 := rand ( 2 , 4 ) else
119435: LD_ADDR_VAR 0 3
119439: PUSH
119440: LD_INT 2
119442: PPUSH
119443: LD_INT 4
119445: PPUSH
119446: CALL_OW 12
119450: ST_TO_ADDR
119451: GO 119461
// s2 := 1 ;
119453: LD_ADDR_VAR 0 3
119457: PUSH
119458: LD_INT 1
119460: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
119461: LD_ADDR_VAR 0 5
119465: PUSH
119466: LD_VAR 0 6
119470: PUSH
119471: LD_INT 1
119473: ARRAY
119474: PPUSH
119475: LD_VAR 0 3
119479: PPUSH
119480: CALL_OW 259
119484: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
119485: LD_VAR 0 6
119489: PUSH
119490: LD_INT 1
119492: ARRAY
119493: PPUSH
119494: LD_VAR 0 2
119498: PPUSH
119499: LD_VAR 0 5
119503: PPUSH
119504: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
119508: LD_VAR 0 6
119512: PUSH
119513: LD_INT 1
119515: ARRAY
119516: PPUSH
119517: LD_VAR 0 3
119521: PPUSH
119522: LD_VAR 0 4
119526: PPUSH
119527: CALL_OW 237
// end ;
119531: PPOPN 6
119533: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
119534: LD_EXP 143
119538: PUSH
119539: LD_EXP 190
119543: AND
119544: IFFALSE 119623
119546: GO 119548
119548: DISABLE
119549: LD_INT 0
119551: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
119552: LD_ADDR_VAR 0 1
119556: PUSH
119557: LD_INT 22
119559: PUSH
119560: LD_OWVAR 2
119564: PUSH
119565: EMPTY
119566: LIST
119567: LIST
119568: PUSH
119569: LD_INT 30
119571: PUSH
119572: LD_INT 3
119574: PUSH
119575: EMPTY
119576: LIST
119577: LIST
119578: PUSH
119579: EMPTY
119580: LIST
119581: LIST
119582: PPUSH
119583: CALL_OW 69
119587: ST_TO_ADDR
// if not tmp then
119588: LD_VAR 0 1
119592: NOT
119593: IFFALSE 119597
// exit ;
119595: GO 119623
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119597: LD_VAR 0 1
119601: PUSH
119602: LD_INT 1
119604: PPUSH
119605: LD_VAR 0 1
119609: PPUSH
119610: CALL_OW 12
119614: ARRAY
119615: PPUSH
119616: LD_INT 1
119618: PPUSH
119619: CALL_OW 234
// end ;
119623: PPOPN 1
119625: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
119626: LD_EXP 143
119630: PUSH
119631: LD_EXP 191
119635: AND
119636: IFFALSE 119748
119638: GO 119640
119640: DISABLE
119641: LD_INT 0
119643: PPUSH
119644: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
119645: LD_ADDR_VAR 0 2
119649: PUSH
119650: LD_INT 22
119652: PUSH
119653: LD_OWVAR 2
119657: PUSH
119658: EMPTY
119659: LIST
119660: LIST
119661: PUSH
119662: LD_INT 2
119664: PUSH
119665: LD_INT 30
119667: PUSH
119668: LD_INT 27
119670: PUSH
119671: EMPTY
119672: LIST
119673: LIST
119674: PUSH
119675: LD_INT 30
119677: PUSH
119678: LD_INT 26
119680: PUSH
119681: EMPTY
119682: LIST
119683: LIST
119684: PUSH
119685: LD_INT 30
119687: PUSH
119688: LD_INT 28
119690: PUSH
119691: EMPTY
119692: LIST
119693: LIST
119694: PUSH
119695: EMPTY
119696: LIST
119697: LIST
119698: LIST
119699: LIST
119700: PUSH
119701: EMPTY
119702: LIST
119703: LIST
119704: PPUSH
119705: CALL_OW 69
119709: ST_TO_ADDR
// if not tmp then
119710: LD_VAR 0 2
119714: NOT
119715: IFFALSE 119719
// exit ;
119717: GO 119748
// for i in tmp do
119719: LD_ADDR_VAR 0 1
119723: PUSH
119724: LD_VAR 0 2
119728: PUSH
119729: FOR_IN
119730: IFFALSE 119746
// SetLives ( i , 1 ) ;
119732: LD_VAR 0 1
119736: PPUSH
119737: LD_INT 1
119739: PPUSH
119740: CALL_OW 234
119744: GO 119729
119746: POP
119747: POP
// end ;
119748: PPOPN 2
119750: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
119751: LD_EXP 143
119755: PUSH
119756: LD_EXP 192
119760: AND
119761: IFFALSE 120048
119763: GO 119765
119765: DISABLE
119766: LD_INT 0
119768: PPUSH
119769: PPUSH
119770: PPUSH
// begin i := rand ( 1 , 7 ) ;
119771: LD_ADDR_VAR 0 1
119775: PUSH
119776: LD_INT 1
119778: PPUSH
119779: LD_INT 7
119781: PPUSH
119782: CALL_OW 12
119786: ST_TO_ADDR
// case i of 1 :
119787: LD_VAR 0 1
119791: PUSH
119792: LD_INT 1
119794: DOUBLE
119795: EQUAL
119796: IFTRUE 119800
119798: GO 119810
119800: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
119801: LD_STRING earthquake(getX(game), 0, 32)
119803: PPUSH
119804: CALL_OW 559
119808: GO 120048
119810: LD_INT 2
119812: DOUBLE
119813: EQUAL
119814: IFTRUE 119818
119816: GO 119832
119818: POP
// begin ToLua ( displayStucuk(); ) ;
119819: LD_STRING displayStucuk();
119821: PPUSH
119822: CALL_OW 559
// ResetFog ;
119826: CALL_OW 335
// end ; 3 :
119830: GO 120048
119832: LD_INT 3
119834: DOUBLE
119835: EQUAL
119836: IFTRUE 119840
119838: GO 119944
119840: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119841: LD_ADDR_VAR 0 2
119845: PUSH
119846: LD_INT 22
119848: PUSH
119849: LD_OWVAR 2
119853: PUSH
119854: EMPTY
119855: LIST
119856: LIST
119857: PUSH
119858: LD_INT 25
119860: PUSH
119861: LD_INT 1
119863: PUSH
119864: EMPTY
119865: LIST
119866: LIST
119867: PUSH
119868: EMPTY
119869: LIST
119870: LIST
119871: PPUSH
119872: CALL_OW 69
119876: ST_TO_ADDR
// if not tmp then
119877: LD_VAR 0 2
119881: NOT
119882: IFFALSE 119886
// exit ;
119884: GO 120048
// un := tmp [ rand ( 1 , tmp ) ] ;
119886: LD_ADDR_VAR 0 3
119890: PUSH
119891: LD_VAR 0 2
119895: PUSH
119896: LD_INT 1
119898: PPUSH
119899: LD_VAR 0 2
119903: PPUSH
119904: CALL_OW 12
119908: ARRAY
119909: ST_TO_ADDR
// if Crawls ( un ) then
119910: LD_VAR 0 3
119914: PPUSH
119915: CALL_OW 318
119919: IFFALSE 119930
// ComWalk ( un ) ;
119921: LD_VAR 0 3
119925: PPUSH
119926: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119930: LD_VAR 0 3
119934: PPUSH
119935: LD_INT 8
119937: PPUSH
119938: CALL_OW 336
// end ; 4 :
119942: GO 120048
119944: LD_INT 4
119946: DOUBLE
119947: EQUAL
119948: IFTRUE 119952
119950: GO 120026
119952: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
119953: LD_ADDR_VAR 0 2
119957: PUSH
119958: LD_INT 22
119960: PUSH
119961: LD_OWVAR 2
119965: PUSH
119966: EMPTY
119967: LIST
119968: LIST
119969: PUSH
119970: LD_INT 30
119972: PUSH
119973: LD_INT 29
119975: PUSH
119976: EMPTY
119977: LIST
119978: LIST
119979: PUSH
119980: EMPTY
119981: LIST
119982: LIST
119983: PPUSH
119984: CALL_OW 69
119988: ST_TO_ADDR
// if not tmp then
119989: LD_VAR 0 2
119993: NOT
119994: IFFALSE 119998
// exit ;
119996: GO 120048
// CenterNowOnUnits ( tmp [ 1 ] ) ;
119998: LD_VAR 0 2
120002: PUSH
120003: LD_INT 1
120005: ARRAY
120006: PPUSH
120007: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
120011: LD_VAR 0 2
120015: PUSH
120016: LD_INT 1
120018: ARRAY
120019: PPUSH
120020: CALL_OW 65
// end ; 5 .. 7 :
120024: GO 120048
120026: LD_INT 5
120028: DOUBLE
120029: GREATEREQUAL
120030: IFFALSE 120038
120032: LD_INT 7
120034: DOUBLE
120035: LESSEQUAL
120036: IFTRUE 120040
120038: GO 120047
120040: POP
// StreamSibBomb ; end ;
120041: CALL 116285 0 0
120045: GO 120048
120047: POP
// end ;
120048: PPOPN 3
120050: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
120051: LD_EXP 143
120055: PUSH
120056: LD_EXP 193
120060: AND
120061: IFFALSE 120217
120063: GO 120065
120065: DISABLE
120066: LD_INT 0
120068: PPUSH
120069: PPUSH
120070: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
120071: LD_ADDR_VAR 0 2
120075: PUSH
120076: LD_INT 81
120078: PUSH
120079: LD_OWVAR 2
120083: PUSH
120084: EMPTY
120085: LIST
120086: LIST
120087: PUSH
120088: LD_INT 2
120090: PUSH
120091: LD_INT 21
120093: PUSH
120094: LD_INT 1
120096: PUSH
120097: EMPTY
120098: LIST
120099: LIST
120100: PUSH
120101: LD_INT 21
120103: PUSH
120104: LD_INT 2
120106: PUSH
120107: EMPTY
120108: LIST
120109: LIST
120110: PUSH
120111: EMPTY
120112: LIST
120113: LIST
120114: LIST
120115: PUSH
120116: EMPTY
120117: LIST
120118: LIST
120119: PPUSH
120120: CALL_OW 69
120124: ST_TO_ADDR
// if not tmp then
120125: LD_VAR 0 2
120129: NOT
120130: IFFALSE 120134
// exit ;
120132: GO 120217
// p := 0 ;
120134: LD_ADDR_VAR 0 3
120138: PUSH
120139: LD_INT 0
120141: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120142: LD_INT 35
120144: PPUSH
120145: CALL_OW 67
// p := p + 1 ;
120149: LD_ADDR_VAR 0 3
120153: PUSH
120154: LD_VAR 0 3
120158: PUSH
120159: LD_INT 1
120161: PLUS
120162: ST_TO_ADDR
// for i in tmp do
120163: LD_ADDR_VAR 0 1
120167: PUSH
120168: LD_VAR 0 2
120172: PUSH
120173: FOR_IN
120174: IFFALSE 120205
// if GetLives ( i ) < 1000 then
120176: LD_VAR 0 1
120180: PPUSH
120181: CALL_OW 256
120185: PUSH
120186: LD_INT 1000
120188: LESS
120189: IFFALSE 120203
// SetLives ( i , 1000 ) ;
120191: LD_VAR 0 1
120195: PPUSH
120196: LD_INT 1000
120198: PPUSH
120199: CALL_OW 234
120203: GO 120173
120205: POP
120206: POP
// until p > 20 ;
120207: LD_VAR 0 3
120211: PUSH
120212: LD_INT 20
120214: GREATER
120215: IFFALSE 120142
// end ;
120217: PPOPN 3
120219: END
// every 0 0$1 trigger StreamModeActive and sTime do
120220: LD_EXP 143
120224: PUSH
120225: LD_EXP 194
120229: AND
120230: IFFALSE 120265
120232: GO 120234
120234: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
120235: LD_INT 28
120237: PPUSH
120238: LD_OWVAR 2
120242: PPUSH
120243: LD_INT 2
120245: PPUSH
120246: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
120250: LD_INT 30
120252: PPUSH
120253: LD_OWVAR 2
120257: PPUSH
120258: LD_INT 2
120260: PPUSH
120261: CALL_OW 322
// end ;
120265: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
120266: LD_EXP 143
120270: PUSH
120271: LD_EXP 195
120275: AND
120276: IFFALSE 120397
120278: GO 120280
120280: DISABLE
120281: LD_INT 0
120283: PPUSH
120284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120285: LD_ADDR_VAR 0 2
120289: PUSH
120290: LD_INT 22
120292: PUSH
120293: LD_OWVAR 2
120297: PUSH
120298: EMPTY
120299: LIST
120300: LIST
120301: PUSH
120302: LD_INT 21
120304: PUSH
120305: LD_INT 1
120307: PUSH
120308: EMPTY
120309: LIST
120310: LIST
120311: PUSH
120312: LD_INT 3
120314: PUSH
120315: LD_INT 23
120317: PUSH
120318: LD_INT 0
120320: PUSH
120321: EMPTY
120322: LIST
120323: LIST
120324: PUSH
120325: EMPTY
120326: LIST
120327: LIST
120328: PUSH
120329: EMPTY
120330: LIST
120331: LIST
120332: LIST
120333: PPUSH
120334: CALL_OW 69
120338: ST_TO_ADDR
// if not tmp then
120339: LD_VAR 0 2
120343: NOT
120344: IFFALSE 120348
// exit ;
120346: GO 120397
// for i in tmp do
120348: LD_ADDR_VAR 0 1
120352: PUSH
120353: LD_VAR 0 2
120357: PUSH
120358: FOR_IN
120359: IFFALSE 120395
// begin if Crawls ( i ) then
120361: LD_VAR 0 1
120365: PPUSH
120366: CALL_OW 318
120370: IFFALSE 120381
// ComWalk ( i ) ;
120372: LD_VAR 0 1
120376: PPUSH
120377: CALL_OW 138
// SetClass ( i , 2 ) ;
120381: LD_VAR 0 1
120385: PPUSH
120386: LD_INT 2
120388: PPUSH
120389: CALL_OW 336
// end ;
120393: GO 120358
120395: POP
120396: POP
// end ;
120397: PPOPN 2
120399: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
120400: LD_EXP 143
120404: PUSH
120405: LD_EXP 196
120409: AND
120410: IFFALSE 120698
120412: GO 120414
120414: DISABLE
120415: LD_INT 0
120417: PPUSH
120418: PPUSH
120419: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
120420: LD_OWVAR 2
120424: PPUSH
120425: LD_INT 9
120427: PPUSH
120428: LD_INT 1
120430: PPUSH
120431: LD_INT 1
120433: PPUSH
120434: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
120438: LD_INT 9
120440: PPUSH
120441: LD_OWVAR 2
120445: PPUSH
120446: CALL_OW 343
// uc_side := 9 ;
120450: LD_ADDR_OWVAR 20
120454: PUSH
120455: LD_INT 9
120457: ST_TO_ADDR
// uc_nation := 2 ;
120458: LD_ADDR_OWVAR 21
120462: PUSH
120463: LD_INT 2
120465: ST_TO_ADDR
// hc_name := Dark Warrior ;
120466: LD_ADDR_OWVAR 26
120470: PUSH
120471: LD_STRING Dark Warrior
120473: ST_TO_ADDR
// hc_gallery :=  ;
120474: LD_ADDR_OWVAR 33
120478: PUSH
120479: LD_STRING 
120481: ST_TO_ADDR
// hc_noskilllimit := true ;
120482: LD_ADDR_OWVAR 76
120486: PUSH
120487: LD_INT 1
120489: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
120490: LD_ADDR_OWVAR 31
120494: PUSH
120495: LD_INT 30
120497: PUSH
120498: LD_INT 30
120500: PUSH
120501: LD_INT 30
120503: PUSH
120504: LD_INT 30
120506: PUSH
120507: EMPTY
120508: LIST
120509: LIST
120510: LIST
120511: LIST
120512: ST_TO_ADDR
// un := CreateHuman ;
120513: LD_ADDR_VAR 0 3
120517: PUSH
120518: CALL_OW 44
120522: ST_TO_ADDR
// hc_noskilllimit := false ;
120523: LD_ADDR_OWVAR 76
120527: PUSH
120528: LD_INT 0
120530: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120531: LD_VAR 0 3
120535: PPUSH
120536: LD_INT 1
120538: PPUSH
120539: CALL_OW 51
// ToLua ( playRanger() ) ;
120543: LD_STRING playRanger()
120545: PPUSH
120546: CALL_OW 559
// p := 0 ;
120550: LD_ADDR_VAR 0 2
120554: PUSH
120555: LD_INT 0
120557: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120558: LD_INT 35
120560: PPUSH
120561: CALL_OW 67
// p := p + 1 ;
120565: LD_ADDR_VAR 0 2
120569: PUSH
120570: LD_VAR 0 2
120574: PUSH
120575: LD_INT 1
120577: PLUS
120578: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
120579: LD_VAR 0 3
120583: PPUSH
120584: CALL_OW 256
120588: PUSH
120589: LD_INT 1000
120591: LESS
120592: IFFALSE 120606
// SetLives ( un , 1000 ) ;
120594: LD_VAR 0 3
120598: PPUSH
120599: LD_INT 1000
120601: PPUSH
120602: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
120606: LD_VAR 0 3
120610: PPUSH
120611: LD_INT 81
120613: PUSH
120614: LD_OWVAR 2
120618: PUSH
120619: EMPTY
120620: LIST
120621: LIST
120622: PUSH
120623: LD_INT 91
120625: PUSH
120626: LD_VAR 0 3
120630: PUSH
120631: LD_INT 30
120633: PUSH
120634: EMPTY
120635: LIST
120636: LIST
120637: LIST
120638: PUSH
120639: EMPTY
120640: LIST
120641: LIST
120642: PPUSH
120643: CALL_OW 69
120647: PPUSH
120648: LD_VAR 0 3
120652: PPUSH
120653: CALL_OW 74
120657: PPUSH
120658: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
120662: LD_VAR 0 2
120666: PUSH
120667: LD_INT 80
120669: GREATER
120670: PUSH
120671: LD_VAR 0 3
120675: PPUSH
120676: CALL_OW 301
120680: OR
120681: IFFALSE 120558
// if un then
120683: LD_VAR 0 3
120687: IFFALSE 120698
// RemoveUnit ( un ) ;
120689: LD_VAR 0 3
120693: PPUSH
120694: CALL_OW 64
// end ;
120698: PPOPN 3
120700: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
120701: LD_EXP 197
120705: IFFALSE 120821
120707: GO 120709
120709: DISABLE
120710: LD_INT 0
120712: PPUSH
120713: PPUSH
120714: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
120715: LD_ADDR_VAR 0 2
120719: PUSH
120720: LD_INT 81
120722: PUSH
120723: LD_OWVAR 2
120727: PUSH
120728: EMPTY
120729: LIST
120730: LIST
120731: PUSH
120732: LD_INT 21
120734: PUSH
120735: LD_INT 1
120737: PUSH
120738: EMPTY
120739: LIST
120740: LIST
120741: PUSH
120742: EMPTY
120743: LIST
120744: LIST
120745: PPUSH
120746: CALL_OW 69
120750: ST_TO_ADDR
// ToLua ( playComputer() ) ;
120751: LD_STRING playComputer()
120753: PPUSH
120754: CALL_OW 559
// if not tmp then
120758: LD_VAR 0 2
120762: NOT
120763: IFFALSE 120767
// exit ;
120765: GO 120821
// for i in tmp do
120767: LD_ADDR_VAR 0 1
120771: PUSH
120772: LD_VAR 0 2
120776: PUSH
120777: FOR_IN
120778: IFFALSE 120819
// for j := 1 to 4 do
120780: LD_ADDR_VAR 0 3
120784: PUSH
120785: DOUBLE
120786: LD_INT 1
120788: DEC
120789: ST_TO_ADDR
120790: LD_INT 4
120792: PUSH
120793: FOR_TO
120794: IFFALSE 120815
// SetSkill ( i , j , 10 ) ;
120796: LD_VAR 0 1
120800: PPUSH
120801: LD_VAR 0 3
120805: PPUSH
120806: LD_INT 10
120808: PPUSH
120809: CALL_OW 237
120813: GO 120793
120815: POP
120816: POP
120817: GO 120777
120819: POP
120820: POP
// end ;
120821: PPOPN 3
120823: END
// every 0 0$1 trigger s30 do var i , tmp ;
120824: LD_EXP 198
120828: IFFALSE 120897
120830: GO 120832
120832: DISABLE
120833: LD_INT 0
120835: PPUSH
120836: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120837: LD_ADDR_VAR 0 2
120841: PUSH
120842: LD_INT 22
120844: PUSH
120845: LD_OWVAR 2
120849: PUSH
120850: EMPTY
120851: LIST
120852: LIST
120853: PPUSH
120854: CALL_OW 69
120858: ST_TO_ADDR
// if not tmp then
120859: LD_VAR 0 2
120863: NOT
120864: IFFALSE 120868
// exit ;
120866: GO 120897
// for i in tmp do
120868: LD_ADDR_VAR 0 1
120872: PUSH
120873: LD_VAR 0 2
120877: PUSH
120878: FOR_IN
120879: IFFALSE 120895
// SetLives ( i , 300 ) ;
120881: LD_VAR 0 1
120885: PPUSH
120886: LD_INT 300
120888: PPUSH
120889: CALL_OW 234
120893: GO 120878
120895: POP
120896: POP
// end ;
120897: PPOPN 2
120899: END
// every 0 0$1 trigger s60 do var i , tmp ;
120900: LD_EXP 199
120904: IFFALSE 120973
120906: GO 120908
120908: DISABLE
120909: LD_INT 0
120911: PPUSH
120912: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120913: LD_ADDR_VAR 0 2
120917: PUSH
120918: LD_INT 22
120920: PUSH
120921: LD_OWVAR 2
120925: PUSH
120926: EMPTY
120927: LIST
120928: LIST
120929: PPUSH
120930: CALL_OW 69
120934: ST_TO_ADDR
// if not tmp then
120935: LD_VAR 0 2
120939: NOT
120940: IFFALSE 120944
// exit ;
120942: GO 120973
// for i in tmp do
120944: LD_ADDR_VAR 0 1
120948: PUSH
120949: LD_VAR 0 2
120953: PUSH
120954: FOR_IN
120955: IFFALSE 120971
// SetLives ( i , 600 ) ;
120957: LD_VAR 0 1
120961: PPUSH
120962: LD_INT 600
120964: PPUSH
120965: CALL_OW 234
120969: GO 120954
120971: POP
120972: POP
// end ;
120973: PPOPN 2
120975: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
120976: LD_INT 0
120978: PPUSH
// case cmd of 301 :
120979: LD_VAR 0 1
120983: PUSH
120984: LD_INT 301
120986: DOUBLE
120987: EQUAL
120988: IFTRUE 120992
120990: GO 121024
120992: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
120993: LD_VAR 0 6
120997: PPUSH
120998: LD_VAR 0 7
121002: PPUSH
121003: LD_VAR 0 8
121007: PPUSH
121008: LD_VAR 0 4
121012: PPUSH
121013: LD_VAR 0 5
121017: PPUSH
121018: CALL 122225 0 5
121022: GO 121145
121024: LD_INT 302
121026: DOUBLE
121027: EQUAL
121028: IFTRUE 121032
121030: GO 121069
121032: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
121033: LD_VAR 0 6
121037: PPUSH
121038: LD_VAR 0 7
121042: PPUSH
121043: LD_VAR 0 8
121047: PPUSH
121048: LD_VAR 0 9
121052: PPUSH
121053: LD_VAR 0 4
121057: PPUSH
121058: LD_VAR 0 5
121062: PPUSH
121063: CALL 122316 0 6
121067: GO 121145
121069: LD_INT 303
121071: DOUBLE
121072: EQUAL
121073: IFTRUE 121077
121075: GO 121114
121077: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
121078: LD_VAR 0 6
121082: PPUSH
121083: LD_VAR 0 7
121087: PPUSH
121088: LD_VAR 0 8
121092: PPUSH
121093: LD_VAR 0 9
121097: PPUSH
121098: LD_VAR 0 4
121102: PPUSH
121103: LD_VAR 0 5
121107: PPUSH
121108: CALL 121150 0 6
121112: GO 121145
121114: LD_INT 304
121116: DOUBLE
121117: EQUAL
121118: IFTRUE 121122
121120: GO 121144
121122: POP
// hHackTeleport ( unit , x , y ) ; end ;
121123: LD_VAR 0 2
121127: PPUSH
121128: LD_VAR 0 4
121132: PPUSH
121133: LD_VAR 0 5
121137: PPUSH
121138: CALL 122909 0 3
121142: GO 121145
121144: POP
// end ;
121145: LD_VAR 0 12
121149: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
121150: LD_INT 0
121152: PPUSH
121153: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
121154: LD_VAR 0 1
121158: PUSH
121159: LD_INT 1
121161: LESS
121162: PUSH
121163: LD_VAR 0 1
121167: PUSH
121168: LD_INT 3
121170: GREATER
121171: OR
121172: PUSH
121173: LD_VAR 0 5
121177: PPUSH
121178: LD_VAR 0 6
121182: PPUSH
121183: CALL_OW 428
121187: OR
121188: IFFALSE 121192
// exit ;
121190: GO 121912
// uc_side := your_side ;
121192: LD_ADDR_OWVAR 20
121196: PUSH
121197: LD_OWVAR 2
121201: ST_TO_ADDR
// uc_nation := nation ;
121202: LD_ADDR_OWVAR 21
121206: PUSH
121207: LD_VAR 0 1
121211: ST_TO_ADDR
// bc_level = 1 ;
121212: LD_ADDR_OWVAR 43
121216: PUSH
121217: LD_INT 1
121219: ST_TO_ADDR
// case btype of 1 :
121220: LD_VAR 0 2
121224: PUSH
121225: LD_INT 1
121227: DOUBLE
121228: EQUAL
121229: IFTRUE 121233
121231: GO 121244
121233: POP
// bc_type := b_depot ; 2 :
121234: LD_ADDR_OWVAR 42
121238: PUSH
121239: LD_INT 0
121241: ST_TO_ADDR
121242: GO 121856
121244: LD_INT 2
121246: DOUBLE
121247: EQUAL
121248: IFTRUE 121252
121250: GO 121263
121252: POP
// bc_type := b_warehouse ; 3 :
121253: LD_ADDR_OWVAR 42
121257: PUSH
121258: LD_INT 1
121260: ST_TO_ADDR
121261: GO 121856
121263: LD_INT 3
121265: DOUBLE
121266: EQUAL
121267: IFTRUE 121271
121269: GO 121282
121271: POP
// bc_type := b_lab ; 4 .. 9 :
121272: LD_ADDR_OWVAR 42
121276: PUSH
121277: LD_INT 6
121279: ST_TO_ADDR
121280: GO 121856
121282: LD_INT 4
121284: DOUBLE
121285: GREATEREQUAL
121286: IFFALSE 121294
121288: LD_INT 9
121290: DOUBLE
121291: LESSEQUAL
121292: IFTRUE 121296
121294: GO 121348
121296: POP
// begin bc_type := b_lab_half ;
121297: LD_ADDR_OWVAR 42
121301: PUSH
121302: LD_INT 7
121304: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
121305: LD_ADDR_OWVAR 44
121309: PUSH
121310: LD_INT 10
121312: PUSH
121313: LD_INT 11
121315: PUSH
121316: LD_INT 12
121318: PUSH
121319: LD_INT 15
121321: PUSH
121322: LD_INT 14
121324: PUSH
121325: LD_INT 13
121327: PUSH
121328: EMPTY
121329: LIST
121330: LIST
121331: LIST
121332: LIST
121333: LIST
121334: LIST
121335: PUSH
121336: LD_VAR 0 2
121340: PUSH
121341: LD_INT 3
121343: MINUS
121344: ARRAY
121345: ST_TO_ADDR
// end ; 10 .. 13 :
121346: GO 121856
121348: LD_INT 10
121350: DOUBLE
121351: GREATEREQUAL
121352: IFFALSE 121360
121354: LD_INT 13
121356: DOUBLE
121357: LESSEQUAL
121358: IFTRUE 121362
121360: GO 121439
121362: POP
// begin bc_type := b_lab_full ;
121363: LD_ADDR_OWVAR 42
121367: PUSH
121368: LD_INT 8
121370: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
121371: LD_ADDR_OWVAR 44
121375: PUSH
121376: LD_INT 10
121378: PUSH
121379: LD_INT 12
121381: PUSH
121382: LD_INT 14
121384: PUSH
121385: LD_INT 13
121387: PUSH
121388: EMPTY
121389: LIST
121390: LIST
121391: LIST
121392: LIST
121393: PUSH
121394: LD_VAR 0 2
121398: PUSH
121399: LD_INT 9
121401: MINUS
121402: ARRAY
121403: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
121404: LD_ADDR_OWVAR 45
121408: PUSH
121409: LD_INT 11
121411: PUSH
121412: LD_INT 15
121414: PUSH
121415: LD_INT 12
121417: PUSH
121418: LD_INT 15
121420: PUSH
121421: EMPTY
121422: LIST
121423: LIST
121424: LIST
121425: LIST
121426: PUSH
121427: LD_VAR 0 2
121431: PUSH
121432: LD_INT 9
121434: MINUS
121435: ARRAY
121436: ST_TO_ADDR
// end ; 14 :
121437: GO 121856
121439: LD_INT 14
121441: DOUBLE
121442: EQUAL
121443: IFTRUE 121447
121445: GO 121458
121447: POP
// bc_type := b_workshop ; 15 :
121448: LD_ADDR_OWVAR 42
121452: PUSH
121453: LD_INT 2
121455: ST_TO_ADDR
121456: GO 121856
121458: LD_INT 15
121460: DOUBLE
121461: EQUAL
121462: IFTRUE 121466
121464: GO 121477
121466: POP
// bc_type := b_factory ; 16 :
121467: LD_ADDR_OWVAR 42
121471: PUSH
121472: LD_INT 3
121474: ST_TO_ADDR
121475: GO 121856
121477: LD_INT 16
121479: DOUBLE
121480: EQUAL
121481: IFTRUE 121485
121483: GO 121496
121485: POP
// bc_type := b_ext_gun ; 17 :
121486: LD_ADDR_OWVAR 42
121490: PUSH
121491: LD_INT 17
121493: ST_TO_ADDR
121494: GO 121856
121496: LD_INT 17
121498: DOUBLE
121499: EQUAL
121500: IFTRUE 121504
121502: GO 121532
121504: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
121505: LD_ADDR_OWVAR 42
121509: PUSH
121510: LD_INT 19
121512: PUSH
121513: LD_INT 23
121515: PUSH
121516: LD_INT 19
121518: PUSH
121519: EMPTY
121520: LIST
121521: LIST
121522: LIST
121523: PUSH
121524: LD_VAR 0 1
121528: ARRAY
121529: ST_TO_ADDR
121530: GO 121856
121532: LD_INT 18
121534: DOUBLE
121535: EQUAL
121536: IFTRUE 121540
121538: GO 121551
121540: POP
// bc_type := b_ext_radar ; 19 :
121541: LD_ADDR_OWVAR 42
121545: PUSH
121546: LD_INT 20
121548: ST_TO_ADDR
121549: GO 121856
121551: LD_INT 19
121553: DOUBLE
121554: EQUAL
121555: IFTRUE 121559
121557: GO 121570
121559: POP
// bc_type := b_ext_radio ; 20 :
121560: LD_ADDR_OWVAR 42
121564: PUSH
121565: LD_INT 22
121567: ST_TO_ADDR
121568: GO 121856
121570: LD_INT 20
121572: DOUBLE
121573: EQUAL
121574: IFTRUE 121578
121576: GO 121589
121578: POP
// bc_type := b_ext_siberium ; 21 :
121579: LD_ADDR_OWVAR 42
121583: PUSH
121584: LD_INT 21
121586: ST_TO_ADDR
121587: GO 121856
121589: LD_INT 21
121591: DOUBLE
121592: EQUAL
121593: IFTRUE 121597
121595: GO 121608
121597: POP
// bc_type := b_ext_computer ; 22 :
121598: LD_ADDR_OWVAR 42
121602: PUSH
121603: LD_INT 24
121605: ST_TO_ADDR
121606: GO 121856
121608: LD_INT 22
121610: DOUBLE
121611: EQUAL
121612: IFTRUE 121616
121614: GO 121627
121616: POP
// bc_type := b_ext_track ; 23 :
121617: LD_ADDR_OWVAR 42
121621: PUSH
121622: LD_INT 16
121624: ST_TO_ADDR
121625: GO 121856
121627: LD_INT 23
121629: DOUBLE
121630: EQUAL
121631: IFTRUE 121635
121633: GO 121646
121635: POP
// bc_type := b_ext_laser ; 24 :
121636: LD_ADDR_OWVAR 42
121640: PUSH
121641: LD_INT 25
121643: ST_TO_ADDR
121644: GO 121856
121646: LD_INT 24
121648: DOUBLE
121649: EQUAL
121650: IFTRUE 121654
121652: GO 121665
121654: POP
// bc_type := b_control_tower ; 25 :
121655: LD_ADDR_OWVAR 42
121659: PUSH
121660: LD_INT 36
121662: ST_TO_ADDR
121663: GO 121856
121665: LD_INT 25
121667: DOUBLE
121668: EQUAL
121669: IFTRUE 121673
121671: GO 121684
121673: POP
// bc_type := b_breastwork ; 26 :
121674: LD_ADDR_OWVAR 42
121678: PUSH
121679: LD_INT 31
121681: ST_TO_ADDR
121682: GO 121856
121684: LD_INT 26
121686: DOUBLE
121687: EQUAL
121688: IFTRUE 121692
121690: GO 121703
121692: POP
// bc_type := b_bunker ; 27 :
121693: LD_ADDR_OWVAR 42
121697: PUSH
121698: LD_INT 32
121700: ST_TO_ADDR
121701: GO 121856
121703: LD_INT 27
121705: DOUBLE
121706: EQUAL
121707: IFTRUE 121711
121709: GO 121722
121711: POP
// bc_type := b_turret ; 28 :
121712: LD_ADDR_OWVAR 42
121716: PUSH
121717: LD_INT 33
121719: ST_TO_ADDR
121720: GO 121856
121722: LD_INT 28
121724: DOUBLE
121725: EQUAL
121726: IFTRUE 121730
121728: GO 121741
121730: POP
// bc_type := b_armoury ; 29 :
121731: LD_ADDR_OWVAR 42
121735: PUSH
121736: LD_INT 4
121738: ST_TO_ADDR
121739: GO 121856
121741: LD_INT 29
121743: DOUBLE
121744: EQUAL
121745: IFTRUE 121749
121747: GO 121760
121749: POP
// bc_type := b_barracks ; 30 :
121750: LD_ADDR_OWVAR 42
121754: PUSH
121755: LD_INT 5
121757: ST_TO_ADDR
121758: GO 121856
121760: LD_INT 30
121762: DOUBLE
121763: EQUAL
121764: IFTRUE 121768
121766: GO 121779
121768: POP
// bc_type := b_solar_power ; 31 :
121769: LD_ADDR_OWVAR 42
121773: PUSH
121774: LD_INT 27
121776: ST_TO_ADDR
121777: GO 121856
121779: LD_INT 31
121781: DOUBLE
121782: EQUAL
121783: IFTRUE 121787
121785: GO 121798
121787: POP
// bc_type := b_oil_power ; 32 :
121788: LD_ADDR_OWVAR 42
121792: PUSH
121793: LD_INT 26
121795: ST_TO_ADDR
121796: GO 121856
121798: LD_INT 32
121800: DOUBLE
121801: EQUAL
121802: IFTRUE 121806
121804: GO 121817
121806: POP
// bc_type := b_siberite_power ; 33 :
121807: LD_ADDR_OWVAR 42
121811: PUSH
121812: LD_INT 28
121814: ST_TO_ADDR
121815: GO 121856
121817: LD_INT 33
121819: DOUBLE
121820: EQUAL
121821: IFTRUE 121825
121823: GO 121836
121825: POP
// bc_type := b_oil_mine ; 34 :
121826: LD_ADDR_OWVAR 42
121830: PUSH
121831: LD_INT 29
121833: ST_TO_ADDR
121834: GO 121856
121836: LD_INT 34
121838: DOUBLE
121839: EQUAL
121840: IFTRUE 121844
121842: GO 121855
121844: POP
// bc_type := b_siberite_mine ; end ;
121845: LD_ADDR_OWVAR 42
121849: PUSH
121850: LD_INT 30
121852: ST_TO_ADDR
121853: GO 121856
121855: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
121856: LD_ADDR_VAR 0 8
121860: PUSH
121861: LD_VAR 0 5
121865: PPUSH
121866: LD_VAR 0 6
121870: PPUSH
121871: LD_VAR 0 3
121875: PPUSH
121876: CALL_OW 47
121880: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
121881: LD_OWVAR 42
121885: PUSH
121886: LD_INT 32
121888: PUSH
121889: LD_INT 33
121891: PUSH
121892: EMPTY
121893: LIST
121894: LIST
121895: IN
121896: IFFALSE 121912
// PlaceWeaponTurret ( b , weapon ) ;
121898: LD_VAR 0 8
121902: PPUSH
121903: LD_VAR 0 4
121907: PPUSH
121908: CALL_OW 431
// end ;
121912: LD_VAR 0 7
121916: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
121917: LD_INT 0
121919: PPUSH
121920: PPUSH
121921: PPUSH
121922: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121923: LD_ADDR_VAR 0 4
121927: PUSH
121928: LD_INT 22
121930: PUSH
121931: LD_OWVAR 2
121935: PUSH
121936: EMPTY
121937: LIST
121938: LIST
121939: PUSH
121940: LD_INT 2
121942: PUSH
121943: LD_INT 30
121945: PUSH
121946: LD_INT 0
121948: PUSH
121949: EMPTY
121950: LIST
121951: LIST
121952: PUSH
121953: LD_INT 30
121955: PUSH
121956: LD_INT 1
121958: PUSH
121959: EMPTY
121960: LIST
121961: LIST
121962: PUSH
121963: EMPTY
121964: LIST
121965: LIST
121966: LIST
121967: PUSH
121968: EMPTY
121969: LIST
121970: LIST
121971: PPUSH
121972: CALL_OW 69
121976: ST_TO_ADDR
// if not tmp then
121977: LD_VAR 0 4
121981: NOT
121982: IFFALSE 121986
// exit ;
121984: GO 122045
// for i in tmp do
121986: LD_ADDR_VAR 0 2
121990: PUSH
121991: LD_VAR 0 4
121995: PUSH
121996: FOR_IN
121997: IFFALSE 122043
// for j = 1 to 3 do
121999: LD_ADDR_VAR 0 3
122003: PUSH
122004: DOUBLE
122005: LD_INT 1
122007: DEC
122008: ST_TO_ADDR
122009: LD_INT 3
122011: PUSH
122012: FOR_TO
122013: IFFALSE 122039
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
122015: LD_VAR 0 2
122019: PPUSH
122020: CALL_OW 274
122024: PPUSH
122025: LD_VAR 0 3
122029: PPUSH
122030: LD_INT 99999
122032: PPUSH
122033: CALL_OW 277
122037: GO 122012
122039: POP
122040: POP
122041: GO 121996
122043: POP
122044: POP
// end ;
122045: LD_VAR 0 1
122049: RET
// export function hHackSetLevel10 ; var i , j ; begin
122050: LD_INT 0
122052: PPUSH
122053: PPUSH
122054: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122055: LD_ADDR_VAR 0 2
122059: PUSH
122060: LD_INT 21
122062: PUSH
122063: LD_INT 1
122065: PUSH
122066: EMPTY
122067: LIST
122068: LIST
122069: PPUSH
122070: CALL_OW 69
122074: PUSH
122075: FOR_IN
122076: IFFALSE 122128
// if IsSelected ( i ) then
122078: LD_VAR 0 2
122082: PPUSH
122083: CALL_OW 306
122087: IFFALSE 122126
// begin for j := 1 to 4 do
122089: LD_ADDR_VAR 0 3
122093: PUSH
122094: DOUBLE
122095: LD_INT 1
122097: DEC
122098: ST_TO_ADDR
122099: LD_INT 4
122101: PUSH
122102: FOR_TO
122103: IFFALSE 122124
// SetSkill ( i , j , 10 ) ;
122105: LD_VAR 0 2
122109: PPUSH
122110: LD_VAR 0 3
122114: PPUSH
122115: LD_INT 10
122117: PPUSH
122118: CALL_OW 237
122122: GO 122102
122124: POP
122125: POP
// end ;
122126: GO 122075
122128: POP
122129: POP
// end ;
122130: LD_VAR 0 1
122134: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
122135: LD_INT 0
122137: PPUSH
122138: PPUSH
122139: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
122140: LD_ADDR_VAR 0 2
122144: PUSH
122145: LD_INT 22
122147: PUSH
122148: LD_OWVAR 2
122152: PUSH
122153: EMPTY
122154: LIST
122155: LIST
122156: PUSH
122157: LD_INT 21
122159: PUSH
122160: LD_INT 1
122162: PUSH
122163: EMPTY
122164: LIST
122165: LIST
122166: PUSH
122167: EMPTY
122168: LIST
122169: LIST
122170: PPUSH
122171: CALL_OW 69
122175: PUSH
122176: FOR_IN
122177: IFFALSE 122218
// begin for j := 1 to 4 do
122179: LD_ADDR_VAR 0 3
122183: PUSH
122184: DOUBLE
122185: LD_INT 1
122187: DEC
122188: ST_TO_ADDR
122189: LD_INT 4
122191: PUSH
122192: FOR_TO
122193: IFFALSE 122214
// SetSkill ( i , j , 10 ) ;
122195: LD_VAR 0 2
122199: PPUSH
122200: LD_VAR 0 3
122204: PPUSH
122205: LD_INT 10
122207: PPUSH
122208: CALL_OW 237
122212: GO 122192
122214: POP
122215: POP
// end ;
122216: GO 122176
122218: POP
122219: POP
// end ;
122220: LD_VAR 0 1
122224: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
122225: LD_INT 0
122227: PPUSH
// uc_side := your_side ;
122228: LD_ADDR_OWVAR 20
122232: PUSH
122233: LD_OWVAR 2
122237: ST_TO_ADDR
// uc_nation := nation ;
122238: LD_ADDR_OWVAR 21
122242: PUSH
122243: LD_VAR 0 1
122247: ST_TO_ADDR
// InitHc ;
122248: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
122252: LD_INT 0
122254: PPUSH
122255: LD_VAR 0 2
122259: PPUSH
122260: LD_VAR 0 3
122264: PPUSH
122265: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
122269: LD_VAR 0 4
122273: PPUSH
122274: LD_VAR 0 5
122278: PPUSH
122279: CALL_OW 428
122283: PUSH
122284: LD_INT 0
122286: EQUAL
122287: IFFALSE 122311
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
122289: CALL_OW 44
122293: PPUSH
122294: LD_VAR 0 4
122298: PPUSH
122299: LD_VAR 0 5
122303: PPUSH
122304: LD_INT 1
122306: PPUSH
122307: CALL_OW 48
// end ;
122311: LD_VAR 0 6
122315: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
122316: LD_INT 0
122318: PPUSH
122319: PPUSH
// uc_side := your_side ;
122320: LD_ADDR_OWVAR 20
122324: PUSH
122325: LD_OWVAR 2
122329: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
122330: LD_VAR 0 1
122334: PUSH
122335: LD_INT 1
122337: PUSH
122338: LD_INT 2
122340: PUSH
122341: LD_INT 3
122343: PUSH
122344: LD_INT 4
122346: PUSH
122347: LD_INT 5
122349: PUSH
122350: EMPTY
122351: LIST
122352: LIST
122353: LIST
122354: LIST
122355: LIST
122356: IN
122357: IFFALSE 122369
// uc_nation := nation_american else
122359: LD_ADDR_OWVAR 21
122363: PUSH
122364: LD_INT 1
122366: ST_TO_ADDR
122367: GO 122412
// if chassis in [ 11 , 12 , 13 , 14 ] then
122369: LD_VAR 0 1
122373: PUSH
122374: LD_INT 11
122376: PUSH
122377: LD_INT 12
122379: PUSH
122380: LD_INT 13
122382: PUSH
122383: LD_INT 14
122385: PUSH
122386: EMPTY
122387: LIST
122388: LIST
122389: LIST
122390: LIST
122391: IN
122392: IFFALSE 122404
// uc_nation := nation_arabian else
122394: LD_ADDR_OWVAR 21
122398: PUSH
122399: LD_INT 2
122401: ST_TO_ADDR
122402: GO 122412
// uc_nation := nation_russian ;
122404: LD_ADDR_OWVAR 21
122408: PUSH
122409: LD_INT 3
122411: ST_TO_ADDR
// vc_chassis := chassis ;
122412: LD_ADDR_OWVAR 37
122416: PUSH
122417: LD_VAR 0 1
122421: ST_TO_ADDR
// vc_engine := engine ;
122422: LD_ADDR_OWVAR 39
122426: PUSH
122427: LD_VAR 0 2
122431: ST_TO_ADDR
// vc_control := control ;
122432: LD_ADDR_OWVAR 38
122436: PUSH
122437: LD_VAR 0 3
122441: ST_TO_ADDR
// vc_weapon := weapon ;
122442: LD_ADDR_OWVAR 40
122446: PUSH
122447: LD_VAR 0 4
122451: ST_TO_ADDR
// un := CreateVehicle ;
122452: LD_ADDR_VAR 0 8
122456: PUSH
122457: CALL_OW 45
122461: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
122462: LD_VAR 0 8
122466: PPUSH
122467: LD_INT 0
122469: PPUSH
122470: LD_INT 5
122472: PPUSH
122473: CALL_OW 12
122477: PPUSH
122478: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
122482: LD_VAR 0 8
122486: PPUSH
122487: LD_VAR 0 5
122491: PPUSH
122492: LD_VAR 0 6
122496: PPUSH
122497: LD_INT 1
122499: PPUSH
122500: CALL_OW 48
// end ;
122504: LD_VAR 0 7
122508: RET
// export hInvincible ; every 1 do
122509: GO 122511
122511: DISABLE
// hInvincible := [ ] ;
122512: LD_ADDR_EXP 200
122516: PUSH
122517: EMPTY
122518: ST_TO_ADDR
122519: END
// every 10 do var i ;
122520: GO 122522
122522: DISABLE
122523: LD_INT 0
122525: PPUSH
// begin enable ;
122526: ENABLE
// if not hInvincible then
122527: LD_EXP 200
122531: NOT
122532: IFFALSE 122536
// exit ;
122534: GO 122580
// for i in hInvincible do
122536: LD_ADDR_VAR 0 1
122540: PUSH
122541: LD_EXP 200
122545: PUSH
122546: FOR_IN
122547: IFFALSE 122578
// if GetLives ( i ) < 1000 then
122549: LD_VAR 0 1
122553: PPUSH
122554: CALL_OW 256
122558: PUSH
122559: LD_INT 1000
122561: LESS
122562: IFFALSE 122576
// SetLives ( i , 1000 ) ;
122564: LD_VAR 0 1
122568: PPUSH
122569: LD_INT 1000
122571: PPUSH
122572: CALL_OW 234
122576: GO 122546
122578: POP
122579: POP
// end ;
122580: PPOPN 1
122582: END
// export function hHackInvincible ; var i ; begin
122583: LD_INT 0
122585: PPUSH
122586: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
122587: LD_ADDR_VAR 0 2
122591: PUSH
122592: LD_INT 2
122594: PUSH
122595: LD_INT 21
122597: PUSH
122598: LD_INT 1
122600: PUSH
122601: EMPTY
122602: LIST
122603: LIST
122604: PUSH
122605: LD_INT 21
122607: PUSH
122608: LD_INT 2
122610: PUSH
122611: EMPTY
122612: LIST
122613: LIST
122614: PUSH
122615: EMPTY
122616: LIST
122617: LIST
122618: LIST
122619: PPUSH
122620: CALL_OW 69
122624: PUSH
122625: FOR_IN
122626: IFFALSE 122687
// if IsSelected ( i ) then
122628: LD_VAR 0 2
122632: PPUSH
122633: CALL_OW 306
122637: IFFALSE 122685
// begin if i in hInvincible then
122639: LD_VAR 0 2
122643: PUSH
122644: LD_EXP 200
122648: IN
122649: IFFALSE 122669
// hInvincible := hInvincible diff i else
122651: LD_ADDR_EXP 200
122655: PUSH
122656: LD_EXP 200
122660: PUSH
122661: LD_VAR 0 2
122665: DIFF
122666: ST_TO_ADDR
122667: GO 122685
// hInvincible := hInvincible union i ;
122669: LD_ADDR_EXP 200
122673: PUSH
122674: LD_EXP 200
122678: PUSH
122679: LD_VAR 0 2
122683: UNION
122684: ST_TO_ADDR
// end ;
122685: GO 122625
122687: POP
122688: POP
// end ;
122689: LD_VAR 0 1
122693: RET
// export function hHackInvisible ; var i , j ; begin
122694: LD_INT 0
122696: PPUSH
122697: PPUSH
122698: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122699: LD_ADDR_VAR 0 2
122703: PUSH
122704: LD_INT 21
122706: PUSH
122707: LD_INT 1
122709: PUSH
122710: EMPTY
122711: LIST
122712: LIST
122713: PPUSH
122714: CALL_OW 69
122718: PUSH
122719: FOR_IN
122720: IFFALSE 122744
// if IsSelected ( i ) then
122722: LD_VAR 0 2
122726: PPUSH
122727: CALL_OW 306
122731: IFFALSE 122742
// ComForceInvisible ( i ) ;
122733: LD_VAR 0 2
122737: PPUSH
122738: CALL_OW 496
122742: GO 122719
122744: POP
122745: POP
// end ;
122746: LD_VAR 0 1
122750: RET
// export function hHackChangeYourSide ; begin
122751: LD_INT 0
122753: PPUSH
// if your_side = 8 then
122754: LD_OWVAR 2
122758: PUSH
122759: LD_INT 8
122761: EQUAL
122762: IFFALSE 122774
// your_side := 0 else
122764: LD_ADDR_OWVAR 2
122768: PUSH
122769: LD_INT 0
122771: ST_TO_ADDR
122772: GO 122788
// your_side := your_side + 1 ;
122774: LD_ADDR_OWVAR 2
122778: PUSH
122779: LD_OWVAR 2
122783: PUSH
122784: LD_INT 1
122786: PLUS
122787: ST_TO_ADDR
// end ;
122788: LD_VAR 0 1
122792: RET
// export function hHackChangeUnitSide ; var i , j ; begin
122793: LD_INT 0
122795: PPUSH
122796: PPUSH
122797: PPUSH
// for i in all_units do
122798: LD_ADDR_VAR 0 2
122802: PUSH
122803: LD_OWVAR 3
122807: PUSH
122808: FOR_IN
122809: IFFALSE 122887
// if IsSelected ( i ) then
122811: LD_VAR 0 2
122815: PPUSH
122816: CALL_OW 306
122820: IFFALSE 122885
// begin j := GetSide ( i ) ;
122822: LD_ADDR_VAR 0 3
122826: PUSH
122827: LD_VAR 0 2
122831: PPUSH
122832: CALL_OW 255
122836: ST_TO_ADDR
// if j = 8 then
122837: LD_VAR 0 3
122841: PUSH
122842: LD_INT 8
122844: EQUAL
122845: IFFALSE 122857
// j := 0 else
122847: LD_ADDR_VAR 0 3
122851: PUSH
122852: LD_INT 0
122854: ST_TO_ADDR
122855: GO 122871
// j := j + 1 ;
122857: LD_ADDR_VAR 0 3
122861: PUSH
122862: LD_VAR 0 3
122866: PUSH
122867: LD_INT 1
122869: PLUS
122870: ST_TO_ADDR
// SetSide ( i , j ) ;
122871: LD_VAR 0 2
122875: PPUSH
122876: LD_VAR 0 3
122880: PPUSH
122881: CALL_OW 235
// end ;
122885: GO 122808
122887: POP
122888: POP
// end ;
122889: LD_VAR 0 1
122893: RET
// export function hHackFog ; begin
122894: LD_INT 0
122896: PPUSH
// FogOff ( true ) ;
122897: LD_INT 1
122899: PPUSH
122900: CALL_OW 344
// end ;
122904: LD_VAR 0 1
122908: RET
// export function hHackTeleport ( unit , x , y ) ; begin
122909: LD_INT 0
122911: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
122912: LD_VAR 0 1
122916: PPUSH
122917: LD_VAR 0 2
122921: PPUSH
122922: LD_VAR 0 3
122926: PPUSH
122927: LD_INT 1
122929: PPUSH
122930: LD_INT 1
122932: PPUSH
122933: CALL_OW 483
// CenterOnXY ( x , y ) ;
122937: LD_VAR 0 2
122941: PPUSH
122942: LD_VAR 0 3
122946: PPUSH
122947: CALL_OW 84
// end ;
122951: LD_VAR 0 4
122955: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
122956: LD_INT 0
122958: PPUSH
122959: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
122960: LD_VAR 0 1
122964: NOT
122965: PUSH
122966: LD_VAR 0 2
122970: PPUSH
122971: LD_VAR 0 3
122975: PPUSH
122976: CALL_OW 488
122980: NOT
122981: OR
122982: PUSH
122983: LD_VAR 0 1
122987: PPUSH
122988: CALL_OW 266
122992: PUSH
122993: LD_INT 3
122995: NONEQUAL
122996: PUSH
122997: LD_VAR 0 1
123001: PPUSH
123002: CALL_OW 247
123006: PUSH
123007: LD_INT 1
123009: EQUAL
123010: NOT
123011: AND
123012: OR
123013: IFFALSE 123017
// exit ;
123015: GO 123166
// if GetType ( factory ) = unit_human then
123017: LD_VAR 0 1
123021: PPUSH
123022: CALL_OW 247
123026: PUSH
123027: LD_INT 1
123029: EQUAL
123030: IFFALSE 123047
// factory := IsInUnit ( factory ) ;
123032: LD_ADDR_VAR 0 1
123036: PUSH
123037: LD_VAR 0 1
123041: PPUSH
123042: CALL_OW 310
123046: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
123047: LD_VAR 0 1
123051: PPUSH
123052: CALL_OW 266
123056: PUSH
123057: LD_INT 3
123059: NONEQUAL
123060: IFFALSE 123064
// exit ;
123062: GO 123166
// if HexInfo ( x , y ) = factory then
123064: LD_VAR 0 2
123068: PPUSH
123069: LD_VAR 0 3
123073: PPUSH
123074: CALL_OW 428
123078: PUSH
123079: LD_VAR 0 1
123083: EQUAL
123084: IFFALSE 123111
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
123086: LD_ADDR_EXP 201
123090: PUSH
123091: LD_EXP 201
123095: PPUSH
123096: LD_VAR 0 1
123100: PPUSH
123101: LD_INT 0
123103: PPUSH
123104: CALL_OW 1
123108: ST_TO_ADDR
123109: GO 123162
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
123111: LD_ADDR_EXP 201
123115: PUSH
123116: LD_EXP 201
123120: PPUSH
123121: LD_VAR 0 1
123125: PPUSH
123126: LD_VAR 0 1
123130: PPUSH
123131: CALL_OW 255
123135: PUSH
123136: LD_VAR 0 1
123140: PUSH
123141: LD_VAR 0 2
123145: PUSH
123146: LD_VAR 0 3
123150: PUSH
123151: EMPTY
123152: LIST
123153: LIST
123154: LIST
123155: LIST
123156: PPUSH
123157: CALL_OW 1
123161: ST_TO_ADDR
// UpdateFactoryWaypoints ;
123162: CALL 123171 0 0
// end ;
123166: LD_VAR 0 4
123170: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
123171: LD_INT 0
123173: PPUSH
123174: PPUSH
123175: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
123176: LD_STRING resetFactoryWaypoint();
123178: PPUSH
123179: CALL_OW 559
// if factoryWaypoints then
123183: LD_EXP 201
123187: IFFALSE 123313
// begin list := PrepareArray ( factoryWaypoints ) ;
123189: LD_ADDR_VAR 0 3
123193: PUSH
123194: LD_EXP 201
123198: PPUSH
123199: CALL 108457 0 1
123203: ST_TO_ADDR
// for i := 1 to list do
123204: LD_ADDR_VAR 0 2
123208: PUSH
123209: DOUBLE
123210: LD_INT 1
123212: DEC
123213: ST_TO_ADDR
123214: LD_VAR 0 3
123218: PUSH
123219: FOR_TO
123220: IFFALSE 123311
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123222: LD_STRING setFactoryWaypointXY(
123224: PUSH
123225: LD_VAR 0 3
123229: PUSH
123230: LD_VAR 0 2
123234: ARRAY
123235: PUSH
123236: LD_INT 1
123238: ARRAY
123239: STR
123240: PUSH
123241: LD_STRING ,
123243: STR
123244: PUSH
123245: LD_VAR 0 3
123249: PUSH
123250: LD_VAR 0 2
123254: ARRAY
123255: PUSH
123256: LD_INT 2
123258: ARRAY
123259: STR
123260: PUSH
123261: LD_STRING ,
123263: STR
123264: PUSH
123265: LD_VAR 0 3
123269: PUSH
123270: LD_VAR 0 2
123274: ARRAY
123275: PUSH
123276: LD_INT 3
123278: ARRAY
123279: STR
123280: PUSH
123281: LD_STRING ,
123283: STR
123284: PUSH
123285: LD_VAR 0 3
123289: PUSH
123290: LD_VAR 0 2
123294: ARRAY
123295: PUSH
123296: LD_INT 4
123298: ARRAY
123299: STR
123300: PUSH
123301: LD_STRING )
123303: STR
123304: PPUSH
123305: CALL_OW 559
123309: GO 123219
123311: POP
123312: POP
// end ; end ;
123313: LD_VAR 0 1
123317: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
123318: LD_INT 0
123320: PPUSH
// if HexInfo ( x , y ) = warehouse then
123321: LD_VAR 0 2
123325: PPUSH
123326: LD_VAR 0 3
123330: PPUSH
123331: CALL_OW 428
123335: PUSH
123336: LD_VAR 0 1
123340: EQUAL
123341: IFFALSE 123368
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
123343: LD_ADDR_EXP 202
123347: PUSH
123348: LD_EXP 202
123352: PPUSH
123353: LD_VAR 0 1
123357: PPUSH
123358: LD_INT 0
123360: PPUSH
123361: CALL_OW 1
123365: ST_TO_ADDR
123366: GO 123419
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
123368: LD_ADDR_EXP 202
123372: PUSH
123373: LD_EXP 202
123377: PPUSH
123378: LD_VAR 0 1
123382: PPUSH
123383: LD_VAR 0 1
123387: PPUSH
123388: CALL_OW 255
123392: PUSH
123393: LD_VAR 0 1
123397: PUSH
123398: LD_VAR 0 2
123402: PUSH
123403: LD_VAR 0 3
123407: PUSH
123408: EMPTY
123409: LIST
123410: LIST
123411: LIST
123412: LIST
123413: PPUSH
123414: CALL_OW 1
123418: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
123419: CALL 123428 0 0
// end ;
123423: LD_VAR 0 4
123427: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
123428: LD_INT 0
123430: PPUSH
123431: PPUSH
123432: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
123433: LD_STRING resetWarehouseGatheringPoints();
123435: PPUSH
123436: CALL_OW 559
// if warehouseGatheringPoints then
123440: LD_EXP 202
123444: IFFALSE 123570
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
123446: LD_ADDR_VAR 0 3
123450: PUSH
123451: LD_EXP 202
123455: PPUSH
123456: CALL 108457 0 1
123460: ST_TO_ADDR
// for i := 1 to list do
123461: LD_ADDR_VAR 0 2
123465: PUSH
123466: DOUBLE
123467: LD_INT 1
123469: DEC
123470: ST_TO_ADDR
123471: LD_VAR 0 3
123475: PUSH
123476: FOR_TO
123477: IFFALSE 123568
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123479: LD_STRING setWarehouseGatheringPointXY(
123481: PUSH
123482: LD_VAR 0 3
123486: PUSH
123487: LD_VAR 0 2
123491: ARRAY
123492: PUSH
123493: LD_INT 1
123495: ARRAY
123496: STR
123497: PUSH
123498: LD_STRING ,
123500: STR
123501: PUSH
123502: LD_VAR 0 3
123506: PUSH
123507: LD_VAR 0 2
123511: ARRAY
123512: PUSH
123513: LD_INT 2
123515: ARRAY
123516: STR
123517: PUSH
123518: LD_STRING ,
123520: STR
123521: PUSH
123522: LD_VAR 0 3
123526: PUSH
123527: LD_VAR 0 2
123531: ARRAY
123532: PUSH
123533: LD_INT 3
123535: ARRAY
123536: STR
123537: PUSH
123538: LD_STRING ,
123540: STR
123541: PUSH
123542: LD_VAR 0 3
123546: PUSH
123547: LD_VAR 0 2
123551: ARRAY
123552: PUSH
123553: LD_INT 4
123555: ARRAY
123556: STR
123557: PUSH
123558: LD_STRING )
123560: STR
123561: PPUSH
123562: CALL_OW 559
123566: GO 123476
123568: POP
123569: POP
// end ; end ;
123570: LD_VAR 0 1
123574: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
123575: LD_EXP 202
123579: IFFALSE 124264
123581: GO 123583
123583: DISABLE
123584: LD_INT 0
123586: PPUSH
123587: PPUSH
123588: PPUSH
123589: PPUSH
123590: PPUSH
123591: PPUSH
123592: PPUSH
123593: PPUSH
123594: PPUSH
// begin enable ;
123595: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
123596: LD_ADDR_VAR 0 3
123600: PUSH
123601: LD_EXP 202
123605: PPUSH
123606: CALL 108457 0 1
123610: ST_TO_ADDR
// if not list then
123611: LD_VAR 0 3
123615: NOT
123616: IFFALSE 123620
// exit ;
123618: GO 124264
// for i := 1 to list do
123620: LD_ADDR_VAR 0 1
123624: PUSH
123625: DOUBLE
123626: LD_INT 1
123628: DEC
123629: ST_TO_ADDR
123630: LD_VAR 0 3
123634: PUSH
123635: FOR_TO
123636: IFFALSE 124262
// begin depot := list [ i ] [ 2 ] ;
123638: LD_ADDR_VAR 0 8
123642: PUSH
123643: LD_VAR 0 3
123647: PUSH
123648: LD_VAR 0 1
123652: ARRAY
123653: PUSH
123654: LD_INT 2
123656: ARRAY
123657: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
123658: LD_ADDR_VAR 0 5
123662: PUSH
123663: LD_VAR 0 3
123667: PUSH
123668: LD_VAR 0 1
123672: ARRAY
123673: PUSH
123674: LD_INT 1
123676: ARRAY
123677: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
123678: LD_VAR 0 8
123682: PPUSH
123683: CALL_OW 301
123687: PUSH
123688: LD_VAR 0 5
123692: PUSH
123693: LD_VAR 0 8
123697: PPUSH
123698: CALL_OW 255
123702: NONEQUAL
123703: OR
123704: IFFALSE 123733
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
123706: LD_ADDR_EXP 202
123710: PUSH
123711: LD_EXP 202
123715: PPUSH
123716: LD_VAR 0 8
123720: PPUSH
123721: LD_INT 0
123723: PPUSH
123724: CALL_OW 1
123728: ST_TO_ADDR
// exit ;
123729: POP
123730: POP
123731: GO 124264
// end ; x := list [ i ] [ 3 ] ;
123733: LD_ADDR_VAR 0 6
123737: PUSH
123738: LD_VAR 0 3
123742: PUSH
123743: LD_VAR 0 1
123747: ARRAY
123748: PUSH
123749: LD_INT 3
123751: ARRAY
123752: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
123753: LD_ADDR_VAR 0 7
123757: PUSH
123758: LD_VAR 0 3
123762: PUSH
123763: LD_VAR 0 1
123767: ARRAY
123768: PUSH
123769: LD_INT 4
123771: ARRAY
123772: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
123773: LD_ADDR_VAR 0 9
123777: PUSH
123778: LD_VAR 0 6
123782: PPUSH
123783: LD_VAR 0 7
123787: PPUSH
123788: LD_INT 16
123790: PPUSH
123791: CALL 107045 0 3
123795: ST_TO_ADDR
// if not cratesNearbyPoint then
123796: LD_VAR 0 9
123800: NOT
123801: IFFALSE 123807
// exit ;
123803: POP
123804: POP
123805: GO 124264
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
123807: LD_ADDR_VAR 0 4
123811: PUSH
123812: LD_INT 22
123814: PUSH
123815: LD_VAR 0 5
123819: PUSH
123820: EMPTY
123821: LIST
123822: LIST
123823: PUSH
123824: LD_INT 3
123826: PUSH
123827: LD_INT 60
123829: PUSH
123830: EMPTY
123831: LIST
123832: PUSH
123833: EMPTY
123834: LIST
123835: LIST
123836: PUSH
123837: LD_INT 91
123839: PUSH
123840: LD_VAR 0 8
123844: PUSH
123845: LD_INT 6
123847: PUSH
123848: EMPTY
123849: LIST
123850: LIST
123851: LIST
123852: PUSH
123853: LD_INT 2
123855: PUSH
123856: LD_INT 25
123858: PUSH
123859: LD_INT 2
123861: PUSH
123862: EMPTY
123863: LIST
123864: LIST
123865: PUSH
123866: LD_INT 25
123868: PUSH
123869: LD_INT 16
123871: PUSH
123872: EMPTY
123873: LIST
123874: LIST
123875: PUSH
123876: EMPTY
123877: LIST
123878: LIST
123879: LIST
123880: PUSH
123881: EMPTY
123882: LIST
123883: LIST
123884: LIST
123885: LIST
123886: PPUSH
123887: CALL_OW 69
123891: PUSH
123892: LD_VAR 0 8
123896: PPUSH
123897: CALL_OW 313
123901: PPUSH
123902: LD_INT 3
123904: PUSH
123905: LD_INT 60
123907: PUSH
123908: EMPTY
123909: LIST
123910: PUSH
123911: EMPTY
123912: LIST
123913: LIST
123914: PUSH
123915: LD_INT 2
123917: PUSH
123918: LD_INT 25
123920: PUSH
123921: LD_INT 2
123923: PUSH
123924: EMPTY
123925: LIST
123926: LIST
123927: PUSH
123928: LD_INT 25
123930: PUSH
123931: LD_INT 16
123933: PUSH
123934: EMPTY
123935: LIST
123936: LIST
123937: PUSH
123938: EMPTY
123939: LIST
123940: LIST
123941: LIST
123942: PUSH
123943: EMPTY
123944: LIST
123945: LIST
123946: PPUSH
123947: CALL_OW 72
123951: UNION
123952: ST_TO_ADDR
// if tmp then
123953: LD_VAR 0 4
123957: IFFALSE 124037
// begin tmp := ShrinkArray ( tmp , 3 ) ;
123959: LD_ADDR_VAR 0 4
123963: PUSH
123964: LD_VAR 0 4
123968: PPUSH
123969: LD_INT 3
123971: PPUSH
123972: CALL 105014 0 2
123976: ST_TO_ADDR
// for j in tmp do
123977: LD_ADDR_VAR 0 2
123981: PUSH
123982: LD_VAR 0 4
123986: PUSH
123987: FOR_IN
123988: IFFALSE 124031
// begin if IsInUnit ( j ) then
123990: LD_VAR 0 2
123994: PPUSH
123995: CALL_OW 310
123999: IFFALSE 124010
// ComExit ( j ) ;
124001: LD_VAR 0 2
124005: PPUSH
124006: CALL 105097 0 1
// AddComCollect ( j , x , y ) ;
124010: LD_VAR 0 2
124014: PPUSH
124015: LD_VAR 0 6
124019: PPUSH
124020: LD_VAR 0 7
124024: PPUSH
124025: CALL_OW 177
// end ;
124029: GO 123987
124031: POP
124032: POP
// exit ;
124033: POP
124034: POP
124035: GO 124264
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
124037: LD_ADDR_VAR 0 4
124041: PUSH
124042: LD_INT 22
124044: PUSH
124045: LD_VAR 0 5
124049: PUSH
124050: EMPTY
124051: LIST
124052: LIST
124053: PUSH
124054: LD_INT 91
124056: PUSH
124057: LD_VAR 0 8
124061: PUSH
124062: LD_INT 8
124064: PUSH
124065: EMPTY
124066: LIST
124067: LIST
124068: LIST
124069: PUSH
124070: LD_INT 2
124072: PUSH
124073: LD_INT 34
124075: PUSH
124076: LD_INT 12
124078: PUSH
124079: EMPTY
124080: LIST
124081: LIST
124082: PUSH
124083: LD_INT 34
124085: PUSH
124086: LD_INT 51
124088: PUSH
124089: EMPTY
124090: LIST
124091: LIST
124092: PUSH
124093: LD_INT 34
124095: PUSH
124096: LD_INT 32
124098: PUSH
124099: EMPTY
124100: LIST
124101: LIST
124102: PUSH
124103: LD_INT 34
124105: PUSH
124106: LD_INT 89
124108: PUSH
124109: EMPTY
124110: LIST
124111: LIST
124112: PUSH
124113: EMPTY
124114: LIST
124115: LIST
124116: LIST
124117: LIST
124118: LIST
124119: PUSH
124120: EMPTY
124121: LIST
124122: LIST
124123: LIST
124124: PPUSH
124125: CALL_OW 69
124129: ST_TO_ADDR
// if tmp then
124130: LD_VAR 0 4
124134: IFFALSE 124260
// begin for j in tmp do
124136: LD_ADDR_VAR 0 2
124140: PUSH
124141: LD_VAR 0 4
124145: PUSH
124146: FOR_IN
124147: IFFALSE 124258
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
124149: LD_VAR 0 2
124153: PPUSH
124154: CALL_OW 262
124158: PUSH
124159: LD_INT 3
124161: EQUAL
124162: PUSH
124163: LD_VAR 0 2
124167: PPUSH
124168: CALL_OW 261
124172: PUSH
124173: LD_INT 20
124175: GREATER
124176: OR
124177: PUSH
124178: LD_VAR 0 2
124182: PPUSH
124183: CALL_OW 314
124187: NOT
124188: AND
124189: PUSH
124190: LD_VAR 0 2
124194: PPUSH
124195: CALL_OW 263
124199: PUSH
124200: LD_INT 1
124202: NONEQUAL
124203: PUSH
124204: LD_VAR 0 2
124208: PPUSH
124209: CALL_OW 311
124213: OR
124214: AND
124215: IFFALSE 124256
// begin ComCollect ( j , x , y ) ;
124217: LD_VAR 0 2
124221: PPUSH
124222: LD_VAR 0 6
124226: PPUSH
124227: LD_VAR 0 7
124231: PPUSH
124232: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
124236: LD_VAR 0 2
124240: PPUSH
124241: LD_VAR 0 8
124245: PPUSH
124246: CALL_OW 172
// exit ;
124250: POP
124251: POP
124252: POP
124253: POP
124254: GO 124264
// end ;
124256: GO 124146
124258: POP
124259: POP
// end ; end ;
124260: GO 123635
124262: POP
124263: POP
// end ; end_of_file
124264: PPOPN 9
124266: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
124267: LD_INT 0
124269: PPUSH
124270: PPUSH
124271: PPUSH
124272: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
124273: LD_VAR 0 1
124277: PPUSH
124278: CALL_OW 264
124282: PUSH
124283: LD_INT 91
124285: EQUAL
124286: IFFALSE 124358
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
124288: LD_INT 68
124290: PPUSH
124291: LD_VAR 0 1
124295: PPUSH
124296: CALL_OW 255
124300: PPUSH
124301: CALL_OW 321
124305: PUSH
124306: LD_INT 2
124308: EQUAL
124309: IFFALSE 124321
// eff := 70 else
124311: LD_ADDR_VAR 0 4
124315: PUSH
124316: LD_INT 70
124318: ST_TO_ADDR
124319: GO 124329
// eff := 30 ;
124321: LD_ADDR_VAR 0 4
124325: PUSH
124326: LD_INT 30
124328: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
124329: LD_VAR 0 1
124333: PPUSH
124334: CALL_OW 250
124338: PPUSH
124339: LD_VAR 0 1
124343: PPUSH
124344: CALL_OW 251
124348: PPUSH
124349: LD_VAR 0 4
124353: PPUSH
124354: CALL_OW 495
// end ; end ;
124358: LD_VAR 0 2
124362: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
124363: LD_INT 0
124365: PPUSH
// end ;
124366: LD_VAR 0 4
124370: RET
// export function SOS_Command ( cmd ) ; begin
124371: LD_INT 0
124373: PPUSH
// end ;
124374: LD_VAR 0 2
124378: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
124379: LD_INT 0
124381: PPUSH
// end ;
124382: LD_VAR 0 6
124386: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
124387: LD_INT 0
124389: PPUSH
124390: PPUSH
// if not vehicle or not factory then
124391: LD_VAR 0 1
124395: NOT
124396: PUSH
124397: LD_VAR 0 2
124401: NOT
124402: OR
124403: IFFALSE 124407
// exit ;
124405: GO 124638
// if factoryWaypoints >= factory then
124407: LD_EXP 201
124411: PUSH
124412: LD_VAR 0 2
124416: GREATEREQUAL
124417: IFFALSE 124638
// if factoryWaypoints [ factory ] then
124419: LD_EXP 201
124423: PUSH
124424: LD_VAR 0 2
124428: ARRAY
124429: IFFALSE 124638
// begin if GetControl ( vehicle ) = control_manual then
124431: LD_VAR 0 1
124435: PPUSH
124436: CALL_OW 263
124440: PUSH
124441: LD_INT 1
124443: EQUAL
124444: IFFALSE 124525
// begin driver := IsDrivenBy ( vehicle ) ;
124446: LD_ADDR_VAR 0 4
124450: PUSH
124451: LD_VAR 0 1
124455: PPUSH
124456: CALL_OW 311
124460: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124461: LD_VAR 0 4
124465: PPUSH
124466: LD_EXP 201
124470: PUSH
124471: LD_VAR 0 2
124475: ARRAY
124476: PUSH
124477: LD_INT 3
124479: ARRAY
124480: PPUSH
124481: LD_EXP 201
124485: PUSH
124486: LD_VAR 0 2
124490: ARRAY
124491: PUSH
124492: LD_INT 4
124494: ARRAY
124495: PPUSH
124496: CALL_OW 171
// AddComExitVehicle ( driver ) ;
124500: LD_VAR 0 4
124504: PPUSH
124505: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
124509: LD_VAR 0 4
124513: PPUSH
124514: LD_VAR 0 2
124518: PPUSH
124519: CALL_OW 180
// end else
124523: GO 124638
// if GetControl ( vehicle ) = control_remote then
124525: LD_VAR 0 1
124529: PPUSH
124530: CALL_OW 263
124534: PUSH
124535: LD_INT 2
124537: EQUAL
124538: IFFALSE 124599
// begin wait ( 0 0$2 ) ;
124540: LD_INT 70
124542: PPUSH
124543: CALL_OW 67
// if Connect ( vehicle ) then
124547: LD_VAR 0 1
124551: PPUSH
124552: CALL 75356 0 1
124556: IFFALSE 124597
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124558: LD_VAR 0 1
124562: PPUSH
124563: LD_EXP 201
124567: PUSH
124568: LD_VAR 0 2
124572: ARRAY
124573: PUSH
124574: LD_INT 3
124576: ARRAY
124577: PPUSH
124578: LD_EXP 201
124582: PUSH
124583: LD_VAR 0 2
124587: ARRAY
124588: PUSH
124589: LD_INT 4
124591: ARRAY
124592: PPUSH
124593: CALL_OW 171
// end else
124597: GO 124638
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124599: LD_VAR 0 1
124603: PPUSH
124604: LD_EXP 201
124608: PUSH
124609: LD_VAR 0 2
124613: ARRAY
124614: PUSH
124615: LD_INT 3
124617: ARRAY
124618: PPUSH
124619: LD_EXP 201
124623: PUSH
124624: LD_VAR 0 2
124628: ARRAY
124629: PUSH
124630: LD_INT 4
124632: ARRAY
124633: PPUSH
124634: CALL_OW 171
// end ; end ;
124638: LD_VAR 0 3
124642: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
124643: LD_INT 0
124645: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
124646: LD_VAR 0 1
124650: PUSH
124651: LD_INT 250
124653: EQUAL
124654: PUSH
124655: LD_VAR 0 2
124659: PPUSH
124660: CALL_OW 264
124664: PUSH
124665: LD_INT 81
124667: EQUAL
124668: AND
124669: IFFALSE 124690
// MinerPlaceMine ( unit , x , y ) ;
124671: LD_VAR 0 2
124675: PPUSH
124676: LD_VAR 0 4
124680: PPUSH
124681: LD_VAR 0 5
124685: PPUSH
124686: CALL 127075 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
124690: LD_VAR 0 1
124694: PUSH
124695: LD_INT 251
124697: EQUAL
124698: PUSH
124699: LD_VAR 0 2
124703: PPUSH
124704: CALL_OW 264
124708: PUSH
124709: LD_INT 81
124711: EQUAL
124712: AND
124713: IFFALSE 124734
// MinerDetonateMine ( unit , x , y ) ;
124715: LD_VAR 0 2
124719: PPUSH
124720: LD_VAR 0 4
124724: PPUSH
124725: LD_VAR 0 5
124729: PPUSH
124730: CALL 127350 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
124734: LD_VAR 0 1
124738: PUSH
124739: LD_INT 252
124741: EQUAL
124742: PUSH
124743: LD_VAR 0 2
124747: PPUSH
124748: CALL_OW 264
124752: PUSH
124753: LD_INT 81
124755: EQUAL
124756: AND
124757: IFFALSE 124778
// MinerCreateMinefield ( unit , x , y ) ;
124759: LD_VAR 0 2
124763: PPUSH
124764: LD_VAR 0 4
124768: PPUSH
124769: LD_VAR 0 5
124773: PPUSH
124774: CALL 127767 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
124778: LD_VAR 0 1
124782: PUSH
124783: LD_INT 253
124785: EQUAL
124786: PUSH
124787: LD_VAR 0 2
124791: PPUSH
124792: CALL_OW 257
124796: PUSH
124797: LD_INT 5
124799: EQUAL
124800: AND
124801: IFFALSE 124822
// ComBinocular ( unit , x , y ) ;
124803: LD_VAR 0 2
124807: PPUSH
124808: LD_VAR 0 4
124812: PPUSH
124813: LD_VAR 0 5
124817: PPUSH
124818: CALL 128136 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
124822: LD_VAR 0 1
124826: PUSH
124827: LD_INT 254
124829: EQUAL
124830: PUSH
124831: LD_VAR 0 2
124835: PPUSH
124836: CALL_OW 264
124840: PUSH
124841: LD_INT 99
124843: EQUAL
124844: AND
124845: PUSH
124846: LD_VAR 0 3
124850: PPUSH
124851: CALL_OW 263
124855: PUSH
124856: LD_INT 3
124858: EQUAL
124859: AND
124860: IFFALSE 124876
// HackDestroyVehicle ( unit , selectedUnit ) ;
124862: LD_VAR 0 2
124866: PPUSH
124867: LD_VAR 0 3
124871: PPUSH
124872: CALL 126439 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
124876: LD_VAR 0 1
124880: PUSH
124881: LD_INT 255
124883: EQUAL
124884: PUSH
124885: LD_VAR 0 2
124889: PPUSH
124890: CALL_OW 264
124894: PUSH
124895: LD_INT 14
124897: PUSH
124898: LD_INT 53
124900: PUSH
124901: EMPTY
124902: LIST
124903: LIST
124904: IN
124905: AND
124906: PUSH
124907: LD_VAR 0 4
124911: PPUSH
124912: LD_VAR 0 5
124916: PPUSH
124917: CALL_OW 488
124921: AND
124922: IFFALSE 124946
// CutTreeXYR ( unit , x , y , 12 ) ;
124924: LD_VAR 0 2
124928: PPUSH
124929: LD_VAR 0 4
124933: PPUSH
124934: LD_VAR 0 5
124938: PPUSH
124939: LD_INT 12
124941: PPUSH
124942: CALL 125009 0 4
// if cmd = 256 then
124946: LD_VAR 0 1
124950: PUSH
124951: LD_INT 256
124953: EQUAL
124954: IFFALSE 124975
// SetFactoryWaypoint ( unit , x , y ) ;
124956: LD_VAR 0 2
124960: PPUSH
124961: LD_VAR 0 4
124965: PPUSH
124966: LD_VAR 0 5
124970: PPUSH
124971: CALL 122956 0 3
// if cmd = 257 then
124975: LD_VAR 0 1
124979: PUSH
124980: LD_INT 257
124982: EQUAL
124983: IFFALSE 125004
// SetWarehouseGatheringPoint ( unit , x , y ) ;
124985: LD_VAR 0 2
124989: PPUSH
124990: LD_VAR 0 4
124994: PPUSH
124995: LD_VAR 0 5
124999: PPUSH
125000: CALL 123318 0 3
// end ;
125004: LD_VAR 0 6
125008: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
125009: LD_INT 0
125011: PPUSH
125012: PPUSH
125013: PPUSH
125014: PPUSH
125015: PPUSH
125016: PPUSH
125017: PPUSH
125018: PPUSH
125019: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
125020: LD_VAR 0 1
125024: NOT
125025: PUSH
125026: LD_VAR 0 2
125030: PPUSH
125031: LD_VAR 0 3
125035: PPUSH
125036: CALL_OW 488
125040: NOT
125041: OR
125042: PUSH
125043: LD_VAR 0 4
125047: NOT
125048: OR
125049: IFFALSE 125053
// exit ;
125051: GO 125393
// list := [ ] ;
125053: LD_ADDR_VAR 0 13
125057: PUSH
125058: EMPTY
125059: ST_TO_ADDR
// if x - r < 0 then
125060: LD_VAR 0 2
125064: PUSH
125065: LD_VAR 0 4
125069: MINUS
125070: PUSH
125071: LD_INT 0
125073: LESS
125074: IFFALSE 125086
// min_x := 0 else
125076: LD_ADDR_VAR 0 7
125080: PUSH
125081: LD_INT 0
125083: ST_TO_ADDR
125084: GO 125102
// min_x := x - r ;
125086: LD_ADDR_VAR 0 7
125090: PUSH
125091: LD_VAR 0 2
125095: PUSH
125096: LD_VAR 0 4
125100: MINUS
125101: ST_TO_ADDR
// if y - r < 0 then
125102: LD_VAR 0 3
125106: PUSH
125107: LD_VAR 0 4
125111: MINUS
125112: PUSH
125113: LD_INT 0
125115: LESS
125116: IFFALSE 125128
// min_y := 0 else
125118: LD_ADDR_VAR 0 8
125122: PUSH
125123: LD_INT 0
125125: ST_TO_ADDR
125126: GO 125144
// min_y := y - r ;
125128: LD_ADDR_VAR 0 8
125132: PUSH
125133: LD_VAR 0 3
125137: PUSH
125138: LD_VAR 0 4
125142: MINUS
125143: ST_TO_ADDR
// max_x := x + r ;
125144: LD_ADDR_VAR 0 9
125148: PUSH
125149: LD_VAR 0 2
125153: PUSH
125154: LD_VAR 0 4
125158: PLUS
125159: ST_TO_ADDR
// max_y := y + r ;
125160: LD_ADDR_VAR 0 10
125164: PUSH
125165: LD_VAR 0 3
125169: PUSH
125170: LD_VAR 0 4
125174: PLUS
125175: ST_TO_ADDR
// for _x = min_x to max_x do
125176: LD_ADDR_VAR 0 11
125180: PUSH
125181: DOUBLE
125182: LD_VAR 0 7
125186: DEC
125187: ST_TO_ADDR
125188: LD_VAR 0 9
125192: PUSH
125193: FOR_TO
125194: IFFALSE 125311
// for _y = min_y to max_y do
125196: LD_ADDR_VAR 0 12
125200: PUSH
125201: DOUBLE
125202: LD_VAR 0 8
125206: DEC
125207: ST_TO_ADDR
125208: LD_VAR 0 10
125212: PUSH
125213: FOR_TO
125214: IFFALSE 125307
// begin if not ValidHex ( _x , _y ) then
125216: LD_VAR 0 11
125220: PPUSH
125221: LD_VAR 0 12
125225: PPUSH
125226: CALL_OW 488
125230: NOT
125231: IFFALSE 125235
// continue ;
125233: GO 125213
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
125235: LD_VAR 0 11
125239: PPUSH
125240: LD_VAR 0 12
125244: PPUSH
125245: CALL_OW 351
125249: PUSH
125250: LD_VAR 0 11
125254: PPUSH
125255: LD_VAR 0 12
125259: PPUSH
125260: CALL_OW 554
125264: AND
125265: IFFALSE 125305
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
125267: LD_ADDR_VAR 0 13
125271: PUSH
125272: LD_VAR 0 13
125276: PPUSH
125277: LD_VAR 0 13
125281: PUSH
125282: LD_INT 1
125284: PLUS
125285: PPUSH
125286: LD_VAR 0 11
125290: PUSH
125291: LD_VAR 0 12
125295: PUSH
125296: EMPTY
125297: LIST
125298: LIST
125299: PPUSH
125300: CALL_OW 2
125304: ST_TO_ADDR
// end ;
125305: GO 125213
125307: POP
125308: POP
125309: GO 125193
125311: POP
125312: POP
// if not list then
125313: LD_VAR 0 13
125317: NOT
125318: IFFALSE 125322
// exit ;
125320: GO 125393
// for i in list do
125322: LD_ADDR_VAR 0 6
125326: PUSH
125327: LD_VAR 0 13
125331: PUSH
125332: FOR_IN
125333: IFFALSE 125391
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
125335: LD_VAR 0 1
125339: PPUSH
125340: LD_STRING M
125342: PUSH
125343: LD_VAR 0 6
125347: PUSH
125348: LD_INT 1
125350: ARRAY
125351: PUSH
125352: LD_VAR 0 6
125356: PUSH
125357: LD_INT 2
125359: ARRAY
125360: PUSH
125361: LD_INT 0
125363: PUSH
125364: LD_INT 0
125366: PUSH
125367: LD_INT 0
125369: PUSH
125370: LD_INT 0
125372: PUSH
125373: EMPTY
125374: LIST
125375: LIST
125376: LIST
125377: LIST
125378: LIST
125379: LIST
125380: LIST
125381: PUSH
125382: EMPTY
125383: LIST
125384: PPUSH
125385: CALL_OW 447
125389: GO 125332
125391: POP
125392: POP
// end ;
125393: LD_VAR 0 5
125397: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
125398: LD_EXP 204
125402: NOT
125403: IFFALSE 125453
125405: GO 125407
125407: DISABLE
// begin initHack := true ;
125408: LD_ADDR_EXP 204
125412: PUSH
125413: LD_INT 1
125415: ST_TO_ADDR
// hackTanks := [ ] ;
125416: LD_ADDR_EXP 205
125420: PUSH
125421: EMPTY
125422: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
125423: LD_ADDR_EXP 206
125427: PUSH
125428: EMPTY
125429: ST_TO_ADDR
// hackLimit := 3 ;
125430: LD_ADDR_EXP 207
125434: PUSH
125435: LD_INT 3
125437: ST_TO_ADDR
// hackDist := 12 ;
125438: LD_ADDR_EXP 208
125442: PUSH
125443: LD_INT 12
125445: ST_TO_ADDR
// hackCounter := [ ] ;
125446: LD_ADDR_EXP 209
125450: PUSH
125451: EMPTY
125452: ST_TO_ADDR
// end ;
125453: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
125454: LD_EXP 204
125458: PUSH
125459: LD_INT 34
125461: PUSH
125462: LD_INT 99
125464: PUSH
125465: EMPTY
125466: LIST
125467: LIST
125468: PPUSH
125469: CALL_OW 69
125473: AND
125474: IFFALSE 125727
125476: GO 125478
125478: DISABLE
125479: LD_INT 0
125481: PPUSH
125482: PPUSH
// begin enable ;
125483: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
125484: LD_ADDR_VAR 0 1
125488: PUSH
125489: LD_INT 34
125491: PUSH
125492: LD_INT 99
125494: PUSH
125495: EMPTY
125496: LIST
125497: LIST
125498: PPUSH
125499: CALL_OW 69
125503: PUSH
125504: FOR_IN
125505: IFFALSE 125725
// begin if not i in hackTanks then
125507: LD_VAR 0 1
125511: PUSH
125512: LD_EXP 205
125516: IN
125517: NOT
125518: IFFALSE 125601
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
125520: LD_ADDR_EXP 205
125524: PUSH
125525: LD_EXP 205
125529: PPUSH
125530: LD_EXP 205
125534: PUSH
125535: LD_INT 1
125537: PLUS
125538: PPUSH
125539: LD_VAR 0 1
125543: PPUSH
125544: CALL_OW 1
125548: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
125549: LD_ADDR_EXP 206
125553: PUSH
125554: LD_EXP 206
125558: PPUSH
125559: LD_EXP 206
125563: PUSH
125564: LD_INT 1
125566: PLUS
125567: PPUSH
125568: EMPTY
125569: PPUSH
125570: CALL_OW 1
125574: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
125575: LD_ADDR_EXP 209
125579: PUSH
125580: LD_EXP 209
125584: PPUSH
125585: LD_EXP 209
125589: PUSH
125590: LD_INT 1
125592: PLUS
125593: PPUSH
125594: EMPTY
125595: PPUSH
125596: CALL_OW 1
125600: ST_TO_ADDR
// end ; if not IsOk ( i ) then
125601: LD_VAR 0 1
125605: PPUSH
125606: CALL_OW 302
125610: NOT
125611: IFFALSE 125624
// begin HackUnlinkAll ( i ) ;
125613: LD_VAR 0 1
125617: PPUSH
125618: CALL 125730 0 1
// continue ;
125622: GO 125504
// end ; HackCheckCapturedStatus ( i ) ;
125624: LD_VAR 0 1
125628: PPUSH
125629: CALL 126173 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
125633: LD_ADDR_VAR 0 2
125637: PUSH
125638: LD_INT 81
125640: PUSH
125641: LD_VAR 0 1
125645: PPUSH
125646: CALL_OW 255
125650: PUSH
125651: EMPTY
125652: LIST
125653: LIST
125654: PUSH
125655: LD_INT 33
125657: PUSH
125658: LD_INT 3
125660: PUSH
125661: EMPTY
125662: LIST
125663: LIST
125664: PUSH
125665: LD_INT 91
125667: PUSH
125668: LD_VAR 0 1
125672: PUSH
125673: LD_EXP 208
125677: PUSH
125678: EMPTY
125679: LIST
125680: LIST
125681: LIST
125682: PUSH
125683: LD_INT 50
125685: PUSH
125686: EMPTY
125687: LIST
125688: PUSH
125689: EMPTY
125690: LIST
125691: LIST
125692: LIST
125693: LIST
125694: PPUSH
125695: CALL_OW 69
125699: ST_TO_ADDR
// if not tmp then
125700: LD_VAR 0 2
125704: NOT
125705: IFFALSE 125709
// continue ;
125707: GO 125504
// HackLink ( i , tmp ) ;
125709: LD_VAR 0 1
125713: PPUSH
125714: LD_VAR 0 2
125718: PPUSH
125719: CALL 125866 0 2
// end ;
125723: GO 125504
125725: POP
125726: POP
// end ;
125727: PPOPN 2
125729: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
125730: LD_INT 0
125732: PPUSH
125733: PPUSH
125734: PPUSH
// if not hack in hackTanks then
125735: LD_VAR 0 1
125739: PUSH
125740: LD_EXP 205
125744: IN
125745: NOT
125746: IFFALSE 125750
// exit ;
125748: GO 125861
// index := GetElementIndex ( hackTanks , hack ) ;
125750: LD_ADDR_VAR 0 4
125754: PUSH
125755: LD_EXP 205
125759: PPUSH
125760: LD_VAR 0 1
125764: PPUSH
125765: CALL 72172 0 2
125769: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
125770: LD_EXP 206
125774: PUSH
125775: LD_VAR 0 4
125779: ARRAY
125780: IFFALSE 125861
// begin for i in hackTanksCaptured [ index ] do
125782: LD_ADDR_VAR 0 3
125786: PUSH
125787: LD_EXP 206
125791: PUSH
125792: LD_VAR 0 4
125796: ARRAY
125797: PUSH
125798: FOR_IN
125799: IFFALSE 125825
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
125801: LD_VAR 0 3
125805: PUSH
125806: LD_INT 1
125808: ARRAY
125809: PPUSH
125810: LD_VAR 0 3
125814: PUSH
125815: LD_INT 2
125817: ARRAY
125818: PPUSH
125819: CALL_OW 235
125823: GO 125798
125825: POP
125826: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
125827: LD_ADDR_EXP 206
125831: PUSH
125832: LD_EXP 206
125836: PPUSH
125837: LD_VAR 0 4
125841: PPUSH
125842: EMPTY
125843: PPUSH
125844: CALL_OW 1
125848: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
125849: LD_VAR 0 1
125853: PPUSH
125854: LD_INT 0
125856: PPUSH
125857: CALL_OW 505
// end ; end ;
125861: LD_VAR 0 2
125865: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
125866: LD_INT 0
125868: PPUSH
125869: PPUSH
125870: PPUSH
// if not hack in hackTanks or not vehicles then
125871: LD_VAR 0 1
125875: PUSH
125876: LD_EXP 205
125880: IN
125881: NOT
125882: PUSH
125883: LD_VAR 0 2
125887: NOT
125888: OR
125889: IFFALSE 125893
// exit ;
125891: GO 126168
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
125893: LD_ADDR_VAR 0 2
125897: PUSH
125898: LD_VAR 0 1
125902: PPUSH
125903: LD_VAR 0 2
125907: PPUSH
125908: LD_INT 1
125910: PPUSH
125911: LD_INT 1
125913: PPUSH
125914: CALL 72822 0 4
125918: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
125919: LD_ADDR_VAR 0 5
125923: PUSH
125924: LD_EXP 205
125928: PPUSH
125929: LD_VAR 0 1
125933: PPUSH
125934: CALL 72172 0 2
125938: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
125939: LD_EXP 206
125943: PUSH
125944: LD_VAR 0 5
125948: ARRAY
125949: PUSH
125950: LD_EXP 207
125954: LESS
125955: IFFALSE 126144
// begin for i := 1 to vehicles do
125957: LD_ADDR_VAR 0 4
125961: PUSH
125962: DOUBLE
125963: LD_INT 1
125965: DEC
125966: ST_TO_ADDR
125967: LD_VAR 0 2
125971: PUSH
125972: FOR_TO
125973: IFFALSE 126142
// begin if hackTanksCaptured [ index ] = hackLimit then
125975: LD_EXP 206
125979: PUSH
125980: LD_VAR 0 5
125984: ARRAY
125985: PUSH
125986: LD_EXP 207
125990: EQUAL
125991: IFFALSE 125995
// break ;
125993: GO 126142
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
125995: LD_ADDR_EXP 209
125999: PUSH
126000: LD_EXP 209
126004: PPUSH
126005: LD_VAR 0 5
126009: PPUSH
126010: LD_EXP 209
126014: PUSH
126015: LD_VAR 0 5
126019: ARRAY
126020: PUSH
126021: LD_INT 1
126023: PLUS
126024: PPUSH
126025: CALL_OW 1
126029: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
126030: LD_ADDR_EXP 206
126034: PUSH
126035: LD_EXP 206
126039: PPUSH
126040: LD_VAR 0 5
126044: PUSH
126045: LD_EXP 206
126049: PUSH
126050: LD_VAR 0 5
126054: ARRAY
126055: PUSH
126056: LD_INT 1
126058: PLUS
126059: PUSH
126060: EMPTY
126061: LIST
126062: LIST
126063: PPUSH
126064: LD_VAR 0 2
126068: PUSH
126069: LD_VAR 0 4
126073: ARRAY
126074: PUSH
126075: LD_VAR 0 2
126079: PUSH
126080: LD_VAR 0 4
126084: ARRAY
126085: PPUSH
126086: CALL_OW 255
126090: PUSH
126091: EMPTY
126092: LIST
126093: LIST
126094: PPUSH
126095: CALL 72387 0 3
126099: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
126100: LD_VAR 0 2
126104: PUSH
126105: LD_VAR 0 4
126109: ARRAY
126110: PPUSH
126111: LD_VAR 0 1
126115: PPUSH
126116: CALL_OW 255
126120: PPUSH
126121: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
126125: LD_VAR 0 2
126129: PUSH
126130: LD_VAR 0 4
126134: ARRAY
126135: PPUSH
126136: CALL_OW 141
// end ;
126140: GO 125972
126142: POP
126143: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126144: LD_VAR 0 1
126148: PPUSH
126149: LD_EXP 206
126153: PUSH
126154: LD_VAR 0 5
126158: ARRAY
126159: PUSH
126160: LD_INT 0
126162: PLUS
126163: PPUSH
126164: CALL_OW 505
// end ;
126168: LD_VAR 0 3
126172: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
126173: LD_INT 0
126175: PPUSH
126176: PPUSH
126177: PPUSH
126178: PPUSH
// if not hack in hackTanks then
126179: LD_VAR 0 1
126183: PUSH
126184: LD_EXP 205
126188: IN
126189: NOT
126190: IFFALSE 126194
// exit ;
126192: GO 126434
// index := GetElementIndex ( hackTanks , hack ) ;
126194: LD_ADDR_VAR 0 4
126198: PUSH
126199: LD_EXP 205
126203: PPUSH
126204: LD_VAR 0 1
126208: PPUSH
126209: CALL 72172 0 2
126213: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
126214: LD_ADDR_VAR 0 3
126218: PUSH
126219: DOUBLE
126220: LD_EXP 206
126224: PUSH
126225: LD_VAR 0 4
126229: ARRAY
126230: INC
126231: ST_TO_ADDR
126232: LD_INT 1
126234: PUSH
126235: FOR_DOWNTO
126236: IFFALSE 126408
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
126238: LD_ADDR_VAR 0 5
126242: PUSH
126243: LD_EXP 206
126247: PUSH
126248: LD_VAR 0 4
126252: ARRAY
126253: PUSH
126254: LD_VAR 0 3
126258: ARRAY
126259: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
126260: LD_VAR 0 5
126264: PUSH
126265: LD_INT 1
126267: ARRAY
126268: PPUSH
126269: CALL_OW 302
126273: NOT
126274: PUSH
126275: LD_VAR 0 5
126279: PUSH
126280: LD_INT 1
126282: ARRAY
126283: PPUSH
126284: CALL_OW 255
126288: PUSH
126289: LD_VAR 0 1
126293: PPUSH
126294: CALL_OW 255
126298: NONEQUAL
126299: OR
126300: IFFALSE 126406
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
126302: LD_VAR 0 5
126306: PUSH
126307: LD_INT 1
126309: ARRAY
126310: PPUSH
126311: CALL_OW 305
126315: PUSH
126316: LD_VAR 0 5
126320: PUSH
126321: LD_INT 1
126323: ARRAY
126324: PPUSH
126325: CALL_OW 255
126329: PUSH
126330: LD_VAR 0 1
126334: PPUSH
126335: CALL_OW 255
126339: EQUAL
126340: AND
126341: IFFALSE 126365
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
126343: LD_VAR 0 5
126347: PUSH
126348: LD_INT 1
126350: ARRAY
126351: PPUSH
126352: LD_VAR 0 5
126356: PUSH
126357: LD_INT 2
126359: ARRAY
126360: PPUSH
126361: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
126365: LD_ADDR_EXP 206
126369: PUSH
126370: LD_EXP 206
126374: PPUSH
126375: LD_VAR 0 4
126379: PPUSH
126380: LD_EXP 206
126384: PUSH
126385: LD_VAR 0 4
126389: ARRAY
126390: PPUSH
126391: LD_VAR 0 3
126395: PPUSH
126396: CALL_OW 3
126400: PPUSH
126401: CALL_OW 1
126405: ST_TO_ADDR
// end ; end ;
126406: GO 126235
126408: POP
126409: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126410: LD_VAR 0 1
126414: PPUSH
126415: LD_EXP 206
126419: PUSH
126420: LD_VAR 0 4
126424: ARRAY
126425: PUSH
126426: LD_INT 0
126428: PLUS
126429: PPUSH
126430: CALL_OW 505
// end ;
126434: LD_VAR 0 2
126438: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
126439: LD_INT 0
126441: PPUSH
126442: PPUSH
126443: PPUSH
126444: PPUSH
// if not hack in hackTanks then
126445: LD_VAR 0 1
126449: PUSH
126450: LD_EXP 205
126454: IN
126455: NOT
126456: IFFALSE 126460
// exit ;
126458: GO 126545
// index := GetElementIndex ( hackTanks , hack ) ;
126460: LD_ADDR_VAR 0 5
126464: PUSH
126465: LD_EXP 205
126469: PPUSH
126470: LD_VAR 0 1
126474: PPUSH
126475: CALL 72172 0 2
126479: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
126480: LD_ADDR_VAR 0 4
126484: PUSH
126485: DOUBLE
126486: LD_INT 1
126488: DEC
126489: ST_TO_ADDR
126490: LD_EXP 206
126494: PUSH
126495: LD_VAR 0 5
126499: ARRAY
126500: PUSH
126501: FOR_TO
126502: IFFALSE 126543
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
126504: LD_EXP 206
126508: PUSH
126509: LD_VAR 0 5
126513: ARRAY
126514: PUSH
126515: LD_VAR 0 4
126519: ARRAY
126520: PUSH
126521: LD_INT 1
126523: ARRAY
126524: PUSH
126525: LD_VAR 0 2
126529: EQUAL
126530: IFFALSE 126541
// KillUnit ( vehicle ) ;
126532: LD_VAR 0 2
126536: PPUSH
126537: CALL_OW 66
126541: GO 126501
126543: POP
126544: POP
// end ;
126545: LD_VAR 0 3
126549: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
126550: LD_EXP 210
126554: NOT
126555: IFFALSE 126590
126557: GO 126559
126559: DISABLE
// begin initMiner := true ;
126560: LD_ADDR_EXP 210
126564: PUSH
126565: LD_INT 1
126567: ST_TO_ADDR
// minersList := [ ] ;
126568: LD_ADDR_EXP 211
126572: PUSH
126573: EMPTY
126574: ST_TO_ADDR
// minerMinesList := [ ] ;
126575: LD_ADDR_EXP 212
126579: PUSH
126580: EMPTY
126581: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
126582: LD_ADDR_EXP 213
126586: PUSH
126587: LD_INT 5
126589: ST_TO_ADDR
// end ;
126590: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
126591: LD_EXP 210
126595: PUSH
126596: LD_INT 34
126598: PUSH
126599: LD_INT 81
126601: PUSH
126602: EMPTY
126603: LIST
126604: LIST
126605: PPUSH
126606: CALL_OW 69
126610: AND
126611: IFFALSE 127072
126613: GO 126615
126615: DISABLE
126616: LD_INT 0
126618: PPUSH
126619: PPUSH
126620: PPUSH
126621: PPUSH
// begin enable ;
126622: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
126623: LD_ADDR_VAR 0 1
126627: PUSH
126628: LD_INT 34
126630: PUSH
126631: LD_INT 81
126633: PUSH
126634: EMPTY
126635: LIST
126636: LIST
126637: PPUSH
126638: CALL_OW 69
126642: PUSH
126643: FOR_IN
126644: IFFALSE 126716
// begin if not i in minersList then
126646: LD_VAR 0 1
126650: PUSH
126651: LD_EXP 211
126655: IN
126656: NOT
126657: IFFALSE 126714
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
126659: LD_ADDR_EXP 211
126663: PUSH
126664: LD_EXP 211
126668: PPUSH
126669: LD_EXP 211
126673: PUSH
126674: LD_INT 1
126676: PLUS
126677: PPUSH
126678: LD_VAR 0 1
126682: PPUSH
126683: CALL_OW 1
126687: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
126688: LD_ADDR_EXP 212
126692: PUSH
126693: LD_EXP 212
126697: PPUSH
126698: LD_EXP 212
126702: PUSH
126703: LD_INT 1
126705: PLUS
126706: PPUSH
126707: EMPTY
126708: PPUSH
126709: CALL_OW 1
126713: ST_TO_ADDR
// end end ;
126714: GO 126643
126716: POP
126717: POP
// for i := minerMinesList downto 1 do
126718: LD_ADDR_VAR 0 1
126722: PUSH
126723: DOUBLE
126724: LD_EXP 212
126728: INC
126729: ST_TO_ADDR
126730: LD_INT 1
126732: PUSH
126733: FOR_DOWNTO
126734: IFFALSE 127070
// begin if IsLive ( minersList [ i ] ) then
126736: LD_EXP 211
126740: PUSH
126741: LD_VAR 0 1
126745: ARRAY
126746: PPUSH
126747: CALL_OW 300
126751: IFFALSE 126779
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
126753: LD_EXP 211
126757: PUSH
126758: LD_VAR 0 1
126762: ARRAY
126763: PPUSH
126764: LD_EXP 212
126768: PUSH
126769: LD_VAR 0 1
126773: ARRAY
126774: PPUSH
126775: CALL_OW 505
// if not minerMinesList [ i ] then
126779: LD_EXP 212
126783: PUSH
126784: LD_VAR 0 1
126788: ARRAY
126789: NOT
126790: IFFALSE 126794
// continue ;
126792: GO 126733
// for j := minerMinesList [ i ] downto 1 do
126794: LD_ADDR_VAR 0 2
126798: PUSH
126799: DOUBLE
126800: LD_EXP 212
126804: PUSH
126805: LD_VAR 0 1
126809: ARRAY
126810: INC
126811: ST_TO_ADDR
126812: LD_INT 1
126814: PUSH
126815: FOR_DOWNTO
126816: IFFALSE 127066
// begin side := GetSide ( minersList [ i ] ) ;
126818: LD_ADDR_VAR 0 3
126822: PUSH
126823: LD_EXP 211
126827: PUSH
126828: LD_VAR 0 1
126832: ARRAY
126833: PPUSH
126834: CALL_OW 255
126838: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
126839: LD_ADDR_VAR 0 4
126843: PUSH
126844: LD_EXP 212
126848: PUSH
126849: LD_VAR 0 1
126853: ARRAY
126854: PUSH
126855: LD_VAR 0 2
126859: ARRAY
126860: PUSH
126861: LD_INT 1
126863: ARRAY
126864: PPUSH
126865: LD_EXP 212
126869: PUSH
126870: LD_VAR 0 1
126874: ARRAY
126875: PUSH
126876: LD_VAR 0 2
126880: ARRAY
126881: PUSH
126882: LD_INT 2
126884: ARRAY
126885: PPUSH
126886: CALL_OW 428
126890: ST_TO_ADDR
// if not tmp then
126891: LD_VAR 0 4
126895: NOT
126896: IFFALSE 126900
// continue ;
126898: GO 126815
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
126900: LD_VAR 0 4
126904: PUSH
126905: LD_INT 81
126907: PUSH
126908: LD_VAR 0 3
126912: PUSH
126913: EMPTY
126914: LIST
126915: LIST
126916: PPUSH
126917: CALL_OW 69
126921: IN
126922: PUSH
126923: LD_EXP 212
126927: PUSH
126928: LD_VAR 0 1
126932: ARRAY
126933: PUSH
126934: LD_VAR 0 2
126938: ARRAY
126939: PUSH
126940: LD_INT 1
126942: ARRAY
126943: PPUSH
126944: LD_EXP 212
126948: PUSH
126949: LD_VAR 0 1
126953: ARRAY
126954: PUSH
126955: LD_VAR 0 2
126959: ARRAY
126960: PUSH
126961: LD_INT 2
126963: ARRAY
126964: PPUSH
126965: CALL_OW 458
126969: AND
126970: IFFALSE 127064
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
126972: LD_EXP 212
126976: PUSH
126977: LD_VAR 0 1
126981: ARRAY
126982: PUSH
126983: LD_VAR 0 2
126987: ARRAY
126988: PUSH
126989: LD_INT 1
126991: ARRAY
126992: PPUSH
126993: LD_EXP 212
126997: PUSH
126998: LD_VAR 0 1
127002: ARRAY
127003: PUSH
127004: LD_VAR 0 2
127008: ARRAY
127009: PUSH
127010: LD_INT 2
127012: ARRAY
127013: PPUSH
127014: LD_VAR 0 3
127018: PPUSH
127019: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
127023: LD_ADDR_EXP 212
127027: PUSH
127028: LD_EXP 212
127032: PPUSH
127033: LD_VAR 0 1
127037: PPUSH
127038: LD_EXP 212
127042: PUSH
127043: LD_VAR 0 1
127047: ARRAY
127048: PPUSH
127049: LD_VAR 0 2
127053: PPUSH
127054: CALL_OW 3
127058: PPUSH
127059: CALL_OW 1
127063: ST_TO_ADDR
// end ; end ;
127064: GO 126815
127066: POP
127067: POP
// end ;
127068: GO 126733
127070: POP
127071: POP
// end ;
127072: PPOPN 4
127074: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
127075: LD_INT 0
127077: PPUSH
127078: PPUSH
// result := false ;
127079: LD_ADDR_VAR 0 4
127083: PUSH
127084: LD_INT 0
127086: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
127087: LD_VAR 0 1
127091: PPUSH
127092: CALL_OW 264
127096: PUSH
127097: LD_INT 81
127099: EQUAL
127100: NOT
127101: IFFALSE 127105
// exit ;
127103: GO 127345
// index := GetElementIndex ( minersList , unit ) ;
127105: LD_ADDR_VAR 0 5
127109: PUSH
127110: LD_EXP 211
127114: PPUSH
127115: LD_VAR 0 1
127119: PPUSH
127120: CALL 72172 0 2
127124: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
127125: LD_EXP 212
127129: PUSH
127130: LD_VAR 0 5
127134: ARRAY
127135: PUSH
127136: LD_EXP 213
127140: GREATEREQUAL
127141: IFFALSE 127145
// exit ;
127143: GO 127345
// ComMoveXY ( unit , x , y ) ;
127145: LD_VAR 0 1
127149: PPUSH
127150: LD_VAR 0 2
127154: PPUSH
127155: LD_VAR 0 3
127159: PPUSH
127160: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
127164: LD_INT 35
127166: PPUSH
127167: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
127171: LD_VAR 0 1
127175: PPUSH
127176: LD_VAR 0 2
127180: PPUSH
127181: LD_VAR 0 3
127185: PPUSH
127186: CALL 103508 0 3
127190: NOT
127191: PUSH
127192: LD_VAR 0 1
127196: PPUSH
127197: CALL_OW 314
127201: AND
127202: IFFALSE 127206
// exit ;
127204: GO 127345
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
127206: LD_VAR 0 2
127210: PPUSH
127211: LD_VAR 0 3
127215: PPUSH
127216: CALL_OW 428
127220: PUSH
127221: LD_VAR 0 1
127225: EQUAL
127226: PUSH
127227: LD_VAR 0 1
127231: PPUSH
127232: CALL_OW 314
127236: NOT
127237: AND
127238: IFFALSE 127164
// PlaySoundXY ( x , y , PlantMine ) ;
127240: LD_VAR 0 2
127244: PPUSH
127245: LD_VAR 0 3
127249: PPUSH
127250: LD_STRING PlantMine
127252: PPUSH
127253: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
127257: LD_VAR 0 2
127261: PPUSH
127262: LD_VAR 0 3
127266: PPUSH
127267: LD_VAR 0 1
127271: PPUSH
127272: CALL_OW 255
127276: PPUSH
127277: LD_INT 0
127279: PPUSH
127280: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
127284: LD_ADDR_EXP 212
127288: PUSH
127289: LD_EXP 212
127293: PPUSH
127294: LD_VAR 0 5
127298: PUSH
127299: LD_EXP 212
127303: PUSH
127304: LD_VAR 0 5
127308: ARRAY
127309: PUSH
127310: LD_INT 1
127312: PLUS
127313: PUSH
127314: EMPTY
127315: LIST
127316: LIST
127317: PPUSH
127318: LD_VAR 0 2
127322: PUSH
127323: LD_VAR 0 3
127327: PUSH
127328: EMPTY
127329: LIST
127330: LIST
127331: PPUSH
127332: CALL 72387 0 3
127336: ST_TO_ADDR
// result := true ;
127337: LD_ADDR_VAR 0 4
127341: PUSH
127342: LD_INT 1
127344: ST_TO_ADDR
// end ;
127345: LD_VAR 0 4
127349: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
127350: LD_INT 0
127352: PPUSH
127353: PPUSH
127354: PPUSH
// if not unit in minersList then
127355: LD_VAR 0 1
127359: PUSH
127360: LD_EXP 211
127364: IN
127365: NOT
127366: IFFALSE 127370
// exit ;
127368: GO 127762
// index := GetElementIndex ( minersList , unit ) ;
127370: LD_ADDR_VAR 0 6
127374: PUSH
127375: LD_EXP 211
127379: PPUSH
127380: LD_VAR 0 1
127384: PPUSH
127385: CALL 72172 0 2
127389: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
127390: LD_ADDR_VAR 0 5
127394: PUSH
127395: DOUBLE
127396: LD_EXP 212
127400: PUSH
127401: LD_VAR 0 6
127405: ARRAY
127406: INC
127407: ST_TO_ADDR
127408: LD_INT 1
127410: PUSH
127411: FOR_DOWNTO
127412: IFFALSE 127573
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
127414: LD_EXP 212
127418: PUSH
127419: LD_VAR 0 6
127423: ARRAY
127424: PUSH
127425: LD_VAR 0 5
127429: ARRAY
127430: PUSH
127431: LD_INT 1
127433: ARRAY
127434: PUSH
127435: LD_VAR 0 2
127439: EQUAL
127440: PUSH
127441: LD_EXP 212
127445: PUSH
127446: LD_VAR 0 6
127450: ARRAY
127451: PUSH
127452: LD_VAR 0 5
127456: ARRAY
127457: PUSH
127458: LD_INT 2
127460: ARRAY
127461: PUSH
127462: LD_VAR 0 3
127466: EQUAL
127467: AND
127468: IFFALSE 127571
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127470: LD_EXP 212
127474: PUSH
127475: LD_VAR 0 6
127479: ARRAY
127480: PUSH
127481: LD_VAR 0 5
127485: ARRAY
127486: PUSH
127487: LD_INT 1
127489: ARRAY
127490: PPUSH
127491: LD_EXP 212
127495: PUSH
127496: LD_VAR 0 6
127500: ARRAY
127501: PUSH
127502: LD_VAR 0 5
127506: ARRAY
127507: PUSH
127508: LD_INT 2
127510: ARRAY
127511: PPUSH
127512: LD_VAR 0 1
127516: PPUSH
127517: CALL_OW 255
127521: PPUSH
127522: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127526: LD_ADDR_EXP 212
127530: PUSH
127531: LD_EXP 212
127535: PPUSH
127536: LD_VAR 0 6
127540: PPUSH
127541: LD_EXP 212
127545: PUSH
127546: LD_VAR 0 6
127550: ARRAY
127551: PPUSH
127552: LD_VAR 0 5
127556: PPUSH
127557: CALL_OW 3
127561: PPUSH
127562: CALL_OW 1
127566: ST_TO_ADDR
// exit ;
127567: POP
127568: POP
127569: GO 127762
// end ; end ;
127571: GO 127411
127573: POP
127574: POP
// for i := minerMinesList [ index ] downto 1 do
127575: LD_ADDR_VAR 0 5
127579: PUSH
127580: DOUBLE
127581: LD_EXP 212
127585: PUSH
127586: LD_VAR 0 6
127590: ARRAY
127591: INC
127592: ST_TO_ADDR
127593: LD_INT 1
127595: PUSH
127596: FOR_DOWNTO
127597: IFFALSE 127760
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
127599: LD_EXP 212
127603: PUSH
127604: LD_VAR 0 6
127608: ARRAY
127609: PUSH
127610: LD_VAR 0 5
127614: ARRAY
127615: PUSH
127616: LD_INT 1
127618: ARRAY
127619: PPUSH
127620: LD_EXP 212
127624: PUSH
127625: LD_VAR 0 6
127629: ARRAY
127630: PUSH
127631: LD_VAR 0 5
127635: ARRAY
127636: PUSH
127637: LD_INT 2
127639: ARRAY
127640: PPUSH
127641: LD_VAR 0 2
127645: PPUSH
127646: LD_VAR 0 3
127650: PPUSH
127651: CALL_OW 298
127655: PUSH
127656: LD_INT 6
127658: LESS
127659: IFFALSE 127758
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127661: LD_EXP 212
127665: PUSH
127666: LD_VAR 0 6
127670: ARRAY
127671: PUSH
127672: LD_VAR 0 5
127676: ARRAY
127677: PUSH
127678: LD_INT 1
127680: ARRAY
127681: PPUSH
127682: LD_EXP 212
127686: PUSH
127687: LD_VAR 0 6
127691: ARRAY
127692: PUSH
127693: LD_VAR 0 5
127697: ARRAY
127698: PUSH
127699: LD_INT 2
127701: ARRAY
127702: PPUSH
127703: LD_VAR 0 1
127707: PPUSH
127708: CALL_OW 255
127712: PPUSH
127713: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127717: LD_ADDR_EXP 212
127721: PUSH
127722: LD_EXP 212
127726: PPUSH
127727: LD_VAR 0 6
127731: PPUSH
127732: LD_EXP 212
127736: PUSH
127737: LD_VAR 0 6
127741: ARRAY
127742: PPUSH
127743: LD_VAR 0 5
127747: PPUSH
127748: CALL_OW 3
127752: PPUSH
127753: CALL_OW 1
127757: ST_TO_ADDR
// end ; end ;
127758: GO 127596
127760: POP
127761: POP
// end ;
127762: LD_VAR 0 4
127766: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
127767: LD_INT 0
127769: PPUSH
127770: PPUSH
127771: PPUSH
127772: PPUSH
127773: PPUSH
127774: PPUSH
127775: PPUSH
127776: PPUSH
127777: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
127778: LD_VAR 0 1
127782: PPUSH
127783: CALL_OW 264
127787: PUSH
127788: LD_INT 81
127790: EQUAL
127791: NOT
127792: PUSH
127793: LD_VAR 0 1
127797: PUSH
127798: LD_EXP 211
127802: IN
127803: NOT
127804: OR
127805: IFFALSE 127809
// exit ;
127807: GO 128131
// index := GetElementIndex ( minersList , unit ) ;
127809: LD_ADDR_VAR 0 6
127813: PUSH
127814: LD_EXP 211
127818: PPUSH
127819: LD_VAR 0 1
127823: PPUSH
127824: CALL 72172 0 2
127828: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
127829: LD_ADDR_VAR 0 8
127833: PUSH
127834: LD_EXP 213
127838: PUSH
127839: LD_EXP 212
127843: PUSH
127844: LD_VAR 0 6
127848: ARRAY
127849: MINUS
127850: ST_TO_ADDR
// if not minesFreeAmount then
127851: LD_VAR 0 8
127855: NOT
127856: IFFALSE 127860
// exit ;
127858: GO 128131
// tmp := [ ] ;
127860: LD_ADDR_VAR 0 7
127864: PUSH
127865: EMPTY
127866: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
127867: LD_ADDR_VAR 0 5
127871: PUSH
127872: DOUBLE
127873: LD_INT 1
127875: DEC
127876: ST_TO_ADDR
127877: LD_VAR 0 8
127881: PUSH
127882: FOR_TO
127883: IFFALSE 128078
// begin _d := rand ( 0 , 5 ) ;
127885: LD_ADDR_VAR 0 11
127889: PUSH
127890: LD_INT 0
127892: PPUSH
127893: LD_INT 5
127895: PPUSH
127896: CALL_OW 12
127900: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
127901: LD_ADDR_VAR 0 12
127905: PUSH
127906: LD_INT 2
127908: PPUSH
127909: LD_INT 6
127911: PPUSH
127912: CALL_OW 12
127916: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
127917: LD_ADDR_VAR 0 9
127921: PUSH
127922: LD_VAR 0 2
127926: PPUSH
127927: LD_VAR 0 11
127931: PPUSH
127932: LD_VAR 0 12
127936: PPUSH
127937: CALL_OW 272
127941: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
127942: LD_ADDR_VAR 0 10
127946: PUSH
127947: LD_VAR 0 3
127951: PPUSH
127952: LD_VAR 0 11
127956: PPUSH
127957: LD_VAR 0 12
127961: PPUSH
127962: CALL_OW 273
127966: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
127967: LD_VAR 0 9
127971: PPUSH
127972: LD_VAR 0 10
127976: PPUSH
127977: CALL_OW 488
127981: PUSH
127982: LD_VAR 0 9
127986: PUSH
127987: LD_VAR 0 10
127991: PUSH
127992: EMPTY
127993: LIST
127994: LIST
127995: PUSH
127996: LD_VAR 0 7
128000: IN
128001: NOT
128002: AND
128003: PUSH
128004: LD_VAR 0 9
128008: PPUSH
128009: LD_VAR 0 10
128013: PPUSH
128014: CALL_OW 458
128018: NOT
128019: AND
128020: IFFALSE 128062
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
128022: LD_ADDR_VAR 0 7
128026: PUSH
128027: LD_VAR 0 7
128031: PPUSH
128032: LD_VAR 0 7
128036: PUSH
128037: LD_INT 1
128039: PLUS
128040: PPUSH
128041: LD_VAR 0 9
128045: PUSH
128046: LD_VAR 0 10
128050: PUSH
128051: EMPTY
128052: LIST
128053: LIST
128054: PPUSH
128055: CALL_OW 1
128059: ST_TO_ADDR
128060: GO 128076
// i := i - 1 ;
128062: LD_ADDR_VAR 0 5
128066: PUSH
128067: LD_VAR 0 5
128071: PUSH
128072: LD_INT 1
128074: MINUS
128075: ST_TO_ADDR
// end ;
128076: GO 127882
128078: POP
128079: POP
// for i in tmp do
128080: LD_ADDR_VAR 0 5
128084: PUSH
128085: LD_VAR 0 7
128089: PUSH
128090: FOR_IN
128091: IFFALSE 128129
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
128093: LD_VAR 0 1
128097: PPUSH
128098: LD_VAR 0 5
128102: PUSH
128103: LD_INT 1
128105: ARRAY
128106: PPUSH
128107: LD_VAR 0 5
128111: PUSH
128112: LD_INT 2
128114: ARRAY
128115: PPUSH
128116: CALL 127075 0 3
128120: NOT
128121: IFFALSE 128127
// exit ;
128123: POP
128124: POP
128125: GO 128131
128127: GO 128090
128129: POP
128130: POP
// end ;
128131: LD_VAR 0 4
128135: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
128136: LD_INT 0
128138: PPUSH
128139: PPUSH
128140: PPUSH
128141: PPUSH
128142: PPUSH
128143: PPUSH
128144: PPUSH
// if not GetClass ( unit ) = class_sniper then
128145: LD_VAR 0 1
128149: PPUSH
128150: CALL_OW 257
128154: PUSH
128155: LD_INT 5
128157: EQUAL
128158: NOT
128159: IFFALSE 128163
// exit ;
128161: GO 128551
// dist := 8 ;
128163: LD_ADDR_VAR 0 5
128167: PUSH
128168: LD_INT 8
128170: ST_TO_ADDR
// viewRange := 12 ;
128171: LD_ADDR_VAR 0 7
128175: PUSH
128176: LD_INT 12
128178: ST_TO_ADDR
// side := GetSide ( unit ) ;
128179: LD_ADDR_VAR 0 6
128183: PUSH
128184: LD_VAR 0 1
128188: PPUSH
128189: CALL_OW 255
128193: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
128194: LD_INT 61
128196: PPUSH
128197: LD_VAR 0 6
128201: PPUSH
128202: CALL_OW 321
128206: PUSH
128207: LD_INT 2
128209: EQUAL
128210: IFFALSE 128220
// viewRange := 16 ;
128212: LD_ADDR_VAR 0 7
128216: PUSH
128217: LD_INT 16
128219: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
128220: LD_VAR 0 1
128224: PPUSH
128225: LD_VAR 0 2
128229: PPUSH
128230: LD_VAR 0 3
128234: PPUSH
128235: CALL_OW 297
128239: PUSH
128240: LD_VAR 0 5
128244: GREATER
128245: IFFALSE 128324
// begin ComMoveXY ( unit , x , y ) ;
128247: LD_VAR 0 1
128251: PPUSH
128252: LD_VAR 0 2
128256: PPUSH
128257: LD_VAR 0 3
128261: PPUSH
128262: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128266: LD_INT 35
128268: PPUSH
128269: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
128273: LD_VAR 0 1
128277: PPUSH
128278: LD_VAR 0 2
128282: PPUSH
128283: LD_VAR 0 3
128287: PPUSH
128288: CALL 103508 0 3
128292: NOT
128293: IFFALSE 128297
// exit ;
128295: GO 128551
// until GetDistUnitXY ( unit , x , y ) < dist ;
128297: LD_VAR 0 1
128301: PPUSH
128302: LD_VAR 0 2
128306: PPUSH
128307: LD_VAR 0 3
128311: PPUSH
128312: CALL_OW 297
128316: PUSH
128317: LD_VAR 0 5
128321: LESS
128322: IFFALSE 128266
// end ; ComTurnXY ( unit , x , y ) ;
128324: LD_VAR 0 1
128328: PPUSH
128329: LD_VAR 0 2
128333: PPUSH
128334: LD_VAR 0 3
128338: PPUSH
128339: CALL_OW 118
// wait ( 5 ) ;
128343: LD_INT 5
128345: PPUSH
128346: CALL_OW 67
// _d := GetDir ( unit ) ;
128350: LD_ADDR_VAR 0 10
128354: PUSH
128355: LD_VAR 0 1
128359: PPUSH
128360: CALL_OW 254
128364: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
128365: LD_ADDR_VAR 0 8
128369: PUSH
128370: LD_VAR 0 1
128374: PPUSH
128375: CALL_OW 250
128379: PPUSH
128380: LD_VAR 0 10
128384: PPUSH
128385: LD_VAR 0 5
128389: PPUSH
128390: CALL_OW 272
128394: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
128395: LD_ADDR_VAR 0 9
128399: PUSH
128400: LD_VAR 0 1
128404: PPUSH
128405: CALL_OW 251
128409: PPUSH
128410: LD_VAR 0 10
128414: PPUSH
128415: LD_VAR 0 5
128419: PPUSH
128420: CALL_OW 273
128424: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
128425: LD_VAR 0 8
128429: PPUSH
128430: LD_VAR 0 9
128434: PPUSH
128435: CALL_OW 488
128439: NOT
128440: IFFALSE 128444
// exit ;
128442: GO 128551
// ComAnimCustom ( unit , 1 ) ;
128444: LD_VAR 0 1
128448: PPUSH
128449: LD_INT 1
128451: PPUSH
128452: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
128456: LD_VAR 0 8
128460: PPUSH
128461: LD_VAR 0 9
128465: PPUSH
128466: LD_VAR 0 6
128470: PPUSH
128471: LD_VAR 0 7
128475: PPUSH
128476: CALL_OW 330
// repeat wait ( 1 ) ;
128480: LD_INT 1
128482: PPUSH
128483: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
128487: LD_VAR 0 1
128491: PPUSH
128492: CALL_OW 316
128496: PUSH
128497: LD_VAR 0 1
128501: PPUSH
128502: CALL_OW 314
128506: OR
128507: PUSH
128508: LD_VAR 0 1
128512: PPUSH
128513: CALL_OW 302
128517: NOT
128518: OR
128519: PUSH
128520: LD_VAR 0 1
128524: PPUSH
128525: CALL_OW 301
128529: OR
128530: IFFALSE 128480
// RemoveSeeing ( _x , _y , side ) ;
128532: LD_VAR 0 8
128536: PPUSH
128537: LD_VAR 0 9
128541: PPUSH
128542: LD_VAR 0 6
128546: PPUSH
128547: CALL_OW 331
// end ; end_of_file
128551: LD_VAR 0 4
128555: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
128556: LD_INT 0
128558: PPUSH
128559: PPUSH
128560: PPUSH
128561: PPUSH
128562: PPUSH
128563: PPUSH
128564: PPUSH
128565: PPUSH
128566: PPUSH
128567: PPUSH
128568: PPUSH
128569: PPUSH
128570: PPUSH
128571: PPUSH
128572: PPUSH
128573: PPUSH
128574: PPUSH
128575: PPUSH
128576: PPUSH
128577: PPUSH
128578: PPUSH
128579: PPUSH
128580: PPUSH
128581: PPUSH
128582: PPUSH
128583: PPUSH
128584: PPUSH
128585: PPUSH
128586: PPUSH
128587: PPUSH
128588: PPUSH
128589: PPUSH
128590: PPUSH
128591: PPUSH
// if not list then
128592: LD_VAR 0 1
128596: NOT
128597: IFFALSE 128601
// exit ;
128599: GO 133260
// base := list [ 1 ] ;
128601: LD_ADDR_VAR 0 3
128605: PUSH
128606: LD_VAR 0 1
128610: PUSH
128611: LD_INT 1
128613: ARRAY
128614: ST_TO_ADDR
// group := list [ 2 ] ;
128615: LD_ADDR_VAR 0 4
128619: PUSH
128620: LD_VAR 0 1
128624: PUSH
128625: LD_INT 2
128627: ARRAY
128628: ST_TO_ADDR
// path := list [ 3 ] ;
128629: LD_ADDR_VAR 0 5
128633: PUSH
128634: LD_VAR 0 1
128638: PUSH
128639: LD_INT 3
128641: ARRAY
128642: ST_TO_ADDR
// flags := list [ 4 ] ;
128643: LD_ADDR_VAR 0 6
128647: PUSH
128648: LD_VAR 0 1
128652: PUSH
128653: LD_INT 4
128655: ARRAY
128656: ST_TO_ADDR
// mined := [ ] ;
128657: LD_ADDR_VAR 0 27
128661: PUSH
128662: EMPTY
128663: ST_TO_ADDR
// bombed := [ ] ;
128664: LD_ADDR_VAR 0 28
128668: PUSH
128669: EMPTY
128670: ST_TO_ADDR
// healers := [ ] ;
128671: LD_ADDR_VAR 0 31
128675: PUSH
128676: EMPTY
128677: ST_TO_ADDR
// to_heal := [ ] ;
128678: LD_ADDR_VAR 0 30
128682: PUSH
128683: EMPTY
128684: ST_TO_ADDR
// repairs := [ ] ;
128685: LD_ADDR_VAR 0 33
128689: PUSH
128690: EMPTY
128691: ST_TO_ADDR
// to_repair := [ ] ;
128692: LD_ADDR_VAR 0 32
128696: PUSH
128697: EMPTY
128698: ST_TO_ADDR
// if not group or not path then
128699: LD_VAR 0 4
128703: NOT
128704: PUSH
128705: LD_VAR 0 5
128709: NOT
128710: OR
128711: IFFALSE 128715
// exit ;
128713: GO 133260
// side := GetSide ( group [ 1 ] ) ;
128715: LD_ADDR_VAR 0 35
128719: PUSH
128720: LD_VAR 0 4
128724: PUSH
128725: LD_INT 1
128727: ARRAY
128728: PPUSH
128729: CALL_OW 255
128733: ST_TO_ADDR
// if flags then
128734: LD_VAR 0 6
128738: IFFALSE 128882
// begin f_ignore_area := flags [ 1 ] ;
128740: LD_ADDR_VAR 0 17
128744: PUSH
128745: LD_VAR 0 6
128749: PUSH
128750: LD_INT 1
128752: ARRAY
128753: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
128754: LD_ADDR_VAR 0 18
128758: PUSH
128759: LD_VAR 0 6
128763: PUSH
128764: LD_INT 2
128766: ARRAY
128767: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
128768: LD_ADDR_VAR 0 19
128772: PUSH
128773: LD_VAR 0 6
128777: PUSH
128778: LD_INT 3
128780: ARRAY
128781: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
128782: LD_ADDR_VAR 0 20
128786: PUSH
128787: LD_VAR 0 6
128791: PUSH
128792: LD_INT 4
128794: ARRAY
128795: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
128796: LD_ADDR_VAR 0 21
128800: PUSH
128801: LD_VAR 0 6
128805: PUSH
128806: LD_INT 5
128808: ARRAY
128809: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
128810: LD_ADDR_VAR 0 22
128814: PUSH
128815: LD_VAR 0 6
128819: PUSH
128820: LD_INT 6
128822: ARRAY
128823: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
128824: LD_ADDR_VAR 0 23
128828: PUSH
128829: LD_VAR 0 6
128833: PUSH
128834: LD_INT 7
128836: ARRAY
128837: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
128838: LD_ADDR_VAR 0 24
128842: PUSH
128843: LD_VAR 0 6
128847: PUSH
128848: LD_INT 8
128850: ARRAY
128851: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
128852: LD_ADDR_VAR 0 25
128856: PUSH
128857: LD_VAR 0 6
128861: PUSH
128862: LD_INT 9
128864: ARRAY
128865: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
128866: LD_ADDR_VAR 0 26
128870: PUSH
128871: LD_VAR 0 6
128875: PUSH
128876: LD_INT 10
128878: ARRAY
128879: ST_TO_ADDR
// end else
128880: GO 128962
// begin f_ignore_area := false ;
128882: LD_ADDR_VAR 0 17
128886: PUSH
128887: LD_INT 0
128889: ST_TO_ADDR
// f_capture := false ;
128890: LD_ADDR_VAR 0 18
128894: PUSH
128895: LD_INT 0
128897: ST_TO_ADDR
// f_ignore_civ := false ;
128898: LD_ADDR_VAR 0 19
128902: PUSH
128903: LD_INT 0
128905: ST_TO_ADDR
// f_murder := false ;
128906: LD_ADDR_VAR 0 20
128910: PUSH
128911: LD_INT 0
128913: ST_TO_ADDR
// f_mines := false ;
128914: LD_ADDR_VAR 0 21
128918: PUSH
128919: LD_INT 0
128921: ST_TO_ADDR
// f_repair := false ;
128922: LD_ADDR_VAR 0 22
128926: PUSH
128927: LD_INT 0
128929: ST_TO_ADDR
// f_heal := false ;
128930: LD_ADDR_VAR 0 23
128934: PUSH
128935: LD_INT 0
128937: ST_TO_ADDR
// f_spacetime := false ;
128938: LD_ADDR_VAR 0 24
128942: PUSH
128943: LD_INT 0
128945: ST_TO_ADDR
// f_attack_depot := false ;
128946: LD_ADDR_VAR 0 25
128950: PUSH
128951: LD_INT 0
128953: ST_TO_ADDR
// f_crawl := false ;
128954: LD_ADDR_VAR 0 26
128958: PUSH
128959: LD_INT 0
128961: ST_TO_ADDR
// end ; if f_heal then
128962: LD_VAR 0 23
128966: IFFALSE 128993
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
128968: LD_ADDR_VAR 0 31
128972: PUSH
128973: LD_VAR 0 4
128977: PPUSH
128978: LD_INT 25
128980: PUSH
128981: LD_INT 4
128983: PUSH
128984: EMPTY
128985: LIST
128986: LIST
128987: PPUSH
128988: CALL_OW 72
128992: ST_TO_ADDR
// if f_repair then
128993: LD_VAR 0 22
128997: IFFALSE 129024
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
128999: LD_ADDR_VAR 0 33
129003: PUSH
129004: LD_VAR 0 4
129008: PPUSH
129009: LD_INT 25
129011: PUSH
129012: LD_INT 3
129014: PUSH
129015: EMPTY
129016: LIST
129017: LIST
129018: PPUSH
129019: CALL_OW 72
129023: ST_TO_ADDR
// units_path := [ ] ;
129024: LD_ADDR_VAR 0 16
129028: PUSH
129029: EMPTY
129030: ST_TO_ADDR
// for i = 1 to group do
129031: LD_ADDR_VAR 0 7
129035: PUSH
129036: DOUBLE
129037: LD_INT 1
129039: DEC
129040: ST_TO_ADDR
129041: LD_VAR 0 4
129045: PUSH
129046: FOR_TO
129047: IFFALSE 129076
// units_path := Replace ( units_path , i , path ) ;
129049: LD_ADDR_VAR 0 16
129053: PUSH
129054: LD_VAR 0 16
129058: PPUSH
129059: LD_VAR 0 7
129063: PPUSH
129064: LD_VAR 0 5
129068: PPUSH
129069: CALL_OW 1
129073: ST_TO_ADDR
129074: GO 129046
129076: POP
129077: POP
// repeat for i = group downto 1 do
129078: LD_ADDR_VAR 0 7
129082: PUSH
129083: DOUBLE
129084: LD_VAR 0 4
129088: INC
129089: ST_TO_ADDR
129090: LD_INT 1
129092: PUSH
129093: FOR_DOWNTO
129094: IFFALSE 133216
// begin wait ( 5 ) ;
129096: LD_INT 5
129098: PPUSH
129099: CALL_OW 67
// tmp := [ ] ;
129103: LD_ADDR_VAR 0 14
129107: PUSH
129108: EMPTY
129109: ST_TO_ADDR
// attacking := false ;
129110: LD_ADDR_VAR 0 29
129114: PUSH
129115: LD_INT 0
129117: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
129118: LD_VAR 0 4
129122: PUSH
129123: LD_VAR 0 7
129127: ARRAY
129128: PPUSH
129129: CALL_OW 301
129133: PUSH
129134: LD_VAR 0 4
129138: PUSH
129139: LD_VAR 0 7
129143: ARRAY
129144: NOT
129145: OR
129146: IFFALSE 129255
// begin if GetType ( group [ i ] ) = unit_human then
129148: LD_VAR 0 4
129152: PUSH
129153: LD_VAR 0 7
129157: ARRAY
129158: PPUSH
129159: CALL_OW 247
129163: PUSH
129164: LD_INT 1
129166: EQUAL
129167: IFFALSE 129213
// begin to_heal := to_heal diff group [ i ] ;
129169: LD_ADDR_VAR 0 30
129173: PUSH
129174: LD_VAR 0 30
129178: PUSH
129179: LD_VAR 0 4
129183: PUSH
129184: LD_VAR 0 7
129188: ARRAY
129189: DIFF
129190: ST_TO_ADDR
// healers := healers diff group [ i ] ;
129191: LD_ADDR_VAR 0 31
129195: PUSH
129196: LD_VAR 0 31
129200: PUSH
129201: LD_VAR 0 4
129205: PUSH
129206: LD_VAR 0 7
129210: ARRAY
129211: DIFF
129212: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
129213: LD_ADDR_VAR 0 4
129217: PUSH
129218: LD_VAR 0 4
129222: PPUSH
129223: LD_VAR 0 7
129227: PPUSH
129228: CALL_OW 3
129232: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
129233: LD_ADDR_VAR 0 16
129237: PUSH
129238: LD_VAR 0 16
129242: PPUSH
129243: LD_VAR 0 7
129247: PPUSH
129248: CALL_OW 3
129252: ST_TO_ADDR
// continue ;
129253: GO 129093
// end ; if f_repair then
129255: LD_VAR 0 22
129259: IFFALSE 129748
// begin if GetType ( group [ i ] ) = unit_vehicle then
129261: LD_VAR 0 4
129265: PUSH
129266: LD_VAR 0 7
129270: ARRAY
129271: PPUSH
129272: CALL_OW 247
129276: PUSH
129277: LD_INT 2
129279: EQUAL
129280: IFFALSE 129470
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
129282: LD_VAR 0 4
129286: PUSH
129287: LD_VAR 0 7
129291: ARRAY
129292: PPUSH
129293: CALL_OW 256
129297: PUSH
129298: LD_INT 700
129300: LESS
129301: PUSH
129302: LD_VAR 0 4
129306: PUSH
129307: LD_VAR 0 7
129311: ARRAY
129312: PUSH
129313: LD_VAR 0 32
129317: IN
129318: NOT
129319: AND
129320: IFFALSE 129344
// to_repair := to_repair union group [ i ] ;
129322: LD_ADDR_VAR 0 32
129326: PUSH
129327: LD_VAR 0 32
129331: PUSH
129332: LD_VAR 0 4
129336: PUSH
129337: LD_VAR 0 7
129341: ARRAY
129342: UNION
129343: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
129344: LD_VAR 0 4
129348: PUSH
129349: LD_VAR 0 7
129353: ARRAY
129354: PPUSH
129355: CALL_OW 256
129359: PUSH
129360: LD_INT 1000
129362: EQUAL
129363: PUSH
129364: LD_VAR 0 4
129368: PUSH
129369: LD_VAR 0 7
129373: ARRAY
129374: PUSH
129375: LD_VAR 0 32
129379: IN
129380: AND
129381: IFFALSE 129405
// to_repair := to_repair diff group [ i ] ;
129383: LD_ADDR_VAR 0 32
129387: PUSH
129388: LD_VAR 0 32
129392: PUSH
129393: LD_VAR 0 4
129397: PUSH
129398: LD_VAR 0 7
129402: ARRAY
129403: DIFF
129404: ST_TO_ADDR
// if group [ i ] in to_repair then
129405: LD_VAR 0 4
129409: PUSH
129410: LD_VAR 0 7
129414: ARRAY
129415: PUSH
129416: LD_VAR 0 32
129420: IN
129421: IFFALSE 129468
// begin if not IsInArea ( group [ i ] , f_repair ) then
129423: LD_VAR 0 4
129427: PUSH
129428: LD_VAR 0 7
129432: ARRAY
129433: PPUSH
129434: LD_VAR 0 22
129438: PPUSH
129439: CALL_OW 308
129443: NOT
129444: IFFALSE 129466
// ComMoveToArea ( group [ i ] , f_repair ) ;
129446: LD_VAR 0 4
129450: PUSH
129451: LD_VAR 0 7
129455: ARRAY
129456: PPUSH
129457: LD_VAR 0 22
129461: PPUSH
129462: CALL_OW 113
// continue ;
129466: GO 129093
// end ; end else
129468: GO 129748
// if group [ i ] in repairs then
129470: LD_VAR 0 4
129474: PUSH
129475: LD_VAR 0 7
129479: ARRAY
129480: PUSH
129481: LD_VAR 0 33
129485: IN
129486: IFFALSE 129748
// begin if IsInUnit ( group [ i ] ) then
129488: LD_VAR 0 4
129492: PUSH
129493: LD_VAR 0 7
129497: ARRAY
129498: PPUSH
129499: CALL_OW 310
129503: IFFALSE 129571
// begin z := IsInUnit ( group [ i ] ) ;
129505: LD_ADDR_VAR 0 13
129509: PUSH
129510: LD_VAR 0 4
129514: PUSH
129515: LD_VAR 0 7
129519: ARRAY
129520: PPUSH
129521: CALL_OW 310
129525: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
129526: LD_VAR 0 13
129530: PUSH
129531: LD_VAR 0 32
129535: IN
129536: PUSH
129537: LD_VAR 0 13
129541: PPUSH
129542: LD_VAR 0 22
129546: PPUSH
129547: CALL_OW 308
129551: AND
129552: IFFALSE 129569
// ComExitVehicle ( group [ i ] ) ;
129554: LD_VAR 0 4
129558: PUSH
129559: LD_VAR 0 7
129563: ARRAY
129564: PPUSH
129565: CALL_OW 121
// end else
129569: GO 129748
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
129571: LD_ADDR_VAR 0 13
129575: PUSH
129576: LD_VAR 0 4
129580: PPUSH
129581: LD_INT 95
129583: PUSH
129584: LD_VAR 0 22
129588: PUSH
129589: EMPTY
129590: LIST
129591: LIST
129592: PUSH
129593: LD_INT 58
129595: PUSH
129596: EMPTY
129597: LIST
129598: PUSH
129599: EMPTY
129600: LIST
129601: LIST
129602: PPUSH
129603: CALL_OW 72
129607: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
129608: LD_VAR 0 4
129612: PUSH
129613: LD_VAR 0 7
129617: ARRAY
129618: PPUSH
129619: CALL_OW 314
129623: NOT
129624: IFFALSE 129746
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
129626: LD_ADDR_VAR 0 10
129630: PUSH
129631: LD_VAR 0 13
129635: PPUSH
129636: LD_VAR 0 4
129640: PUSH
129641: LD_VAR 0 7
129645: ARRAY
129646: PPUSH
129647: CALL_OW 74
129651: ST_TO_ADDR
// if not x then
129652: LD_VAR 0 10
129656: NOT
129657: IFFALSE 129661
// continue ;
129659: GO 129093
// if GetLives ( x ) < 1000 then
129661: LD_VAR 0 10
129665: PPUSH
129666: CALL_OW 256
129670: PUSH
129671: LD_INT 1000
129673: LESS
129674: IFFALSE 129698
// ComRepairVehicle ( group [ i ] , x ) else
129676: LD_VAR 0 4
129680: PUSH
129681: LD_VAR 0 7
129685: ARRAY
129686: PPUSH
129687: LD_VAR 0 10
129691: PPUSH
129692: CALL_OW 129
129696: GO 129746
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
129698: LD_VAR 0 23
129702: PUSH
129703: LD_VAR 0 4
129707: PUSH
129708: LD_VAR 0 7
129712: ARRAY
129713: PPUSH
129714: CALL_OW 256
129718: PUSH
129719: LD_INT 1000
129721: LESS
129722: AND
129723: NOT
129724: IFFALSE 129746
// ComEnterUnit ( group [ i ] , x ) ;
129726: LD_VAR 0 4
129730: PUSH
129731: LD_VAR 0 7
129735: ARRAY
129736: PPUSH
129737: LD_VAR 0 10
129741: PPUSH
129742: CALL_OW 120
// end ; continue ;
129746: GO 129093
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
129748: LD_VAR 0 23
129752: PUSH
129753: LD_VAR 0 4
129757: PUSH
129758: LD_VAR 0 7
129762: ARRAY
129763: PPUSH
129764: CALL_OW 247
129768: PUSH
129769: LD_INT 1
129771: EQUAL
129772: AND
129773: IFFALSE 130251
// begin if group [ i ] in healers then
129775: LD_VAR 0 4
129779: PUSH
129780: LD_VAR 0 7
129784: ARRAY
129785: PUSH
129786: LD_VAR 0 31
129790: IN
129791: IFFALSE 130064
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
129793: LD_VAR 0 4
129797: PUSH
129798: LD_VAR 0 7
129802: ARRAY
129803: PPUSH
129804: LD_VAR 0 23
129808: PPUSH
129809: CALL_OW 308
129813: NOT
129814: PUSH
129815: LD_VAR 0 4
129819: PUSH
129820: LD_VAR 0 7
129824: ARRAY
129825: PPUSH
129826: CALL_OW 314
129830: NOT
129831: AND
129832: IFFALSE 129856
// ComMoveToArea ( group [ i ] , f_heal ) else
129834: LD_VAR 0 4
129838: PUSH
129839: LD_VAR 0 7
129843: ARRAY
129844: PPUSH
129845: LD_VAR 0 23
129849: PPUSH
129850: CALL_OW 113
129854: GO 130062
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
129856: LD_VAR 0 4
129860: PUSH
129861: LD_VAR 0 7
129865: ARRAY
129866: PPUSH
129867: CALL 102084 0 1
129871: PPUSH
129872: CALL_OW 256
129876: PUSH
129877: LD_INT 1000
129879: EQUAL
129880: IFFALSE 129899
// ComStop ( group [ i ] ) else
129882: LD_VAR 0 4
129886: PUSH
129887: LD_VAR 0 7
129891: ARRAY
129892: PPUSH
129893: CALL_OW 141
129897: GO 130062
// if not HasTask ( group [ i ] ) and to_heal then
129899: LD_VAR 0 4
129903: PUSH
129904: LD_VAR 0 7
129908: ARRAY
129909: PPUSH
129910: CALL_OW 314
129914: NOT
129915: PUSH
129916: LD_VAR 0 30
129920: AND
129921: IFFALSE 130062
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
129923: LD_ADDR_VAR 0 13
129927: PUSH
129928: LD_VAR 0 30
129932: PPUSH
129933: LD_INT 3
129935: PUSH
129936: LD_INT 54
129938: PUSH
129939: EMPTY
129940: LIST
129941: PUSH
129942: EMPTY
129943: LIST
129944: LIST
129945: PPUSH
129946: CALL_OW 72
129950: PPUSH
129951: LD_VAR 0 4
129955: PUSH
129956: LD_VAR 0 7
129960: ARRAY
129961: PPUSH
129962: CALL_OW 74
129966: ST_TO_ADDR
// if z then
129967: LD_VAR 0 13
129971: IFFALSE 130062
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
129973: LD_INT 91
129975: PUSH
129976: LD_VAR 0 13
129980: PUSH
129981: LD_INT 10
129983: PUSH
129984: EMPTY
129985: LIST
129986: LIST
129987: LIST
129988: PUSH
129989: LD_INT 81
129991: PUSH
129992: LD_VAR 0 13
129996: PPUSH
129997: CALL_OW 255
130001: PUSH
130002: EMPTY
130003: LIST
130004: LIST
130005: PUSH
130006: EMPTY
130007: LIST
130008: LIST
130009: PPUSH
130010: CALL_OW 69
130014: PUSH
130015: LD_INT 0
130017: EQUAL
130018: IFFALSE 130042
// ComHeal ( group [ i ] , z ) else
130020: LD_VAR 0 4
130024: PUSH
130025: LD_VAR 0 7
130029: ARRAY
130030: PPUSH
130031: LD_VAR 0 13
130035: PPUSH
130036: CALL_OW 128
130040: GO 130062
// ComMoveToArea ( group [ i ] , f_heal ) ;
130042: LD_VAR 0 4
130046: PUSH
130047: LD_VAR 0 7
130051: ARRAY
130052: PPUSH
130053: LD_VAR 0 23
130057: PPUSH
130058: CALL_OW 113
// end ; continue ;
130062: GO 129093
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
130064: LD_VAR 0 4
130068: PUSH
130069: LD_VAR 0 7
130073: ARRAY
130074: PPUSH
130075: CALL_OW 256
130079: PUSH
130080: LD_INT 700
130082: LESS
130083: PUSH
130084: LD_VAR 0 4
130088: PUSH
130089: LD_VAR 0 7
130093: ARRAY
130094: PUSH
130095: LD_VAR 0 30
130099: IN
130100: NOT
130101: AND
130102: IFFALSE 130126
// to_heal := to_heal union group [ i ] ;
130104: LD_ADDR_VAR 0 30
130108: PUSH
130109: LD_VAR 0 30
130113: PUSH
130114: LD_VAR 0 4
130118: PUSH
130119: LD_VAR 0 7
130123: ARRAY
130124: UNION
130125: ST_TO_ADDR
// if group [ i ] in to_heal then
130126: LD_VAR 0 4
130130: PUSH
130131: LD_VAR 0 7
130135: ARRAY
130136: PUSH
130137: LD_VAR 0 30
130141: IN
130142: IFFALSE 130251
// begin if GetLives ( group [ i ] ) = 1000 then
130144: LD_VAR 0 4
130148: PUSH
130149: LD_VAR 0 7
130153: ARRAY
130154: PPUSH
130155: CALL_OW 256
130159: PUSH
130160: LD_INT 1000
130162: EQUAL
130163: IFFALSE 130189
// to_heal := to_heal diff group [ i ] else
130165: LD_ADDR_VAR 0 30
130169: PUSH
130170: LD_VAR 0 30
130174: PUSH
130175: LD_VAR 0 4
130179: PUSH
130180: LD_VAR 0 7
130184: ARRAY
130185: DIFF
130186: ST_TO_ADDR
130187: GO 130251
// begin if not IsInArea ( group [ i ] , to_heal ) then
130189: LD_VAR 0 4
130193: PUSH
130194: LD_VAR 0 7
130198: ARRAY
130199: PPUSH
130200: LD_VAR 0 30
130204: PPUSH
130205: CALL_OW 308
130209: NOT
130210: IFFALSE 130234
// ComMoveToArea ( group [ i ] , f_heal ) else
130212: LD_VAR 0 4
130216: PUSH
130217: LD_VAR 0 7
130221: ARRAY
130222: PPUSH
130223: LD_VAR 0 23
130227: PPUSH
130228: CALL_OW 113
130232: GO 130249
// ComHold ( group [ i ] ) ;
130234: LD_VAR 0 4
130238: PUSH
130239: LD_VAR 0 7
130243: ARRAY
130244: PPUSH
130245: CALL_OW 140
// continue ;
130249: GO 129093
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
130251: LD_VAR 0 4
130255: PUSH
130256: LD_VAR 0 7
130260: ARRAY
130261: PPUSH
130262: LD_INT 10
130264: PPUSH
130265: CALL 99881 0 2
130269: NOT
130270: PUSH
130271: LD_VAR 0 16
130275: PUSH
130276: LD_VAR 0 7
130280: ARRAY
130281: PUSH
130282: EMPTY
130283: EQUAL
130284: NOT
130285: AND
130286: IFFALSE 130552
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
130288: LD_VAR 0 4
130292: PUSH
130293: LD_VAR 0 7
130297: ARRAY
130298: PPUSH
130299: CALL_OW 262
130303: PUSH
130304: LD_INT 1
130306: PUSH
130307: LD_INT 2
130309: PUSH
130310: EMPTY
130311: LIST
130312: LIST
130313: IN
130314: IFFALSE 130355
// if GetFuel ( group [ i ] ) < 10 then
130316: LD_VAR 0 4
130320: PUSH
130321: LD_VAR 0 7
130325: ARRAY
130326: PPUSH
130327: CALL_OW 261
130331: PUSH
130332: LD_INT 10
130334: LESS
130335: IFFALSE 130355
// SetFuel ( group [ i ] , 12 ) ;
130337: LD_VAR 0 4
130341: PUSH
130342: LD_VAR 0 7
130346: ARRAY
130347: PPUSH
130348: LD_INT 12
130350: PPUSH
130351: CALL_OW 240
// if units_path [ i ] then
130355: LD_VAR 0 16
130359: PUSH
130360: LD_VAR 0 7
130364: ARRAY
130365: IFFALSE 130550
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
130367: LD_VAR 0 4
130371: PUSH
130372: LD_VAR 0 7
130376: ARRAY
130377: PPUSH
130378: LD_VAR 0 16
130382: PUSH
130383: LD_VAR 0 7
130387: ARRAY
130388: PUSH
130389: LD_INT 1
130391: ARRAY
130392: PUSH
130393: LD_INT 1
130395: ARRAY
130396: PPUSH
130397: LD_VAR 0 16
130401: PUSH
130402: LD_VAR 0 7
130406: ARRAY
130407: PUSH
130408: LD_INT 1
130410: ARRAY
130411: PUSH
130412: LD_INT 2
130414: ARRAY
130415: PPUSH
130416: CALL_OW 297
130420: PUSH
130421: LD_INT 6
130423: GREATER
130424: IFFALSE 130499
// begin if not HasTask ( group [ i ] ) then
130426: LD_VAR 0 4
130430: PUSH
130431: LD_VAR 0 7
130435: ARRAY
130436: PPUSH
130437: CALL_OW 314
130441: NOT
130442: IFFALSE 130497
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
130444: LD_VAR 0 4
130448: PUSH
130449: LD_VAR 0 7
130453: ARRAY
130454: PPUSH
130455: LD_VAR 0 16
130459: PUSH
130460: LD_VAR 0 7
130464: ARRAY
130465: PUSH
130466: LD_INT 1
130468: ARRAY
130469: PUSH
130470: LD_INT 1
130472: ARRAY
130473: PPUSH
130474: LD_VAR 0 16
130478: PUSH
130479: LD_VAR 0 7
130483: ARRAY
130484: PUSH
130485: LD_INT 1
130487: ARRAY
130488: PUSH
130489: LD_INT 2
130491: ARRAY
130492: PPUSH
130493: CALL_OW 114
// end else
130497: GO 130550
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
130499: LD_ADDR_VAR 0 15
130503: PUSH
130504: LD_VAR 0 16
130508: PUSH
130509: LD_VAR 0 7
130513: ARRAY
130514: PPUSH
130515: LD_INT 1
130517: PPUSH
130518: CALL_OW 3
130522: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
130523: LD_ADDR_VAR 0 16
130527: PUSH
130528: LD_VAR 0 16
130532: PPUSH
130533: LD_VAR 0 7
130537: PPUSH
130538: LD_VAR 0 15
130542: PPUSH
130543: CALL_OW 1
130547: ST_TO_ADDR
// continue ;
130548: GO 129093
// end ; end ; end else
130550: GO 133214
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
130552: LD_ADDR_VAR 0 14
130556: PUSH
130557: LD_INT 81
130559: PUSH
130560: LD_VAR 0 4
130564: PUSH
130565: LD_VAR 0 7
130569: ARRAY
130570: PPUSH
130571: CALL_OW 255
130575: PUSH
130576: EMPTY
130577: LIST
130578: LIST
130579: PPUSH
130580: CALL_OW 69
130584: ST_TO_ADDR
// if not tmp then
130585: LD_VAR 0 14
130589: NOT
130590: IFFALSE 130594
// continue ;
130592: GO 129093
// if f_ignore_area then
130594: LD_VAR 0 17
130598: IFFALSE 130686
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
130600: LD_ADDR_VAR 0 15
130604: PUSH
130605: LD_VAR 0 14
130609: PPUSH
130610: LD_INT 3
130612: PUSH
130613: LD_INT 92
130615: PUSH
130616: LD_VAR 0 17
130620: PUSH
130621: LD_INT 1
130623: ARRAY
130624: PUSH
130625: LD_VAR 0 17
130629: PUSH
130630: LD_INT 2
130632: ARRAY
130633: PUSH
130634: LD_VAR 0 17
130638: PUSH
130639: LD_INT 3
130641: ARRAY
130642: PUSH
130643: EMPTY
130644: LIST
130645: LIST
130646: LIST
130647: LIST
130648: PUSH
130649: EMPTY
130650: LIST
130651: LIST
130652: PPUSH
130653: CALL_OW 72
130657: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130658: LD_VAR 0 14
130662: PUSH
130663: LD_VAR 0 15
130667: DIFF
130668: IFFALSE 130686
// tmp := tmp diff tmp2 ;
130670: LD_ADDR_VAR 0 14
130674: PUSH
130675: LD_VAR 0 14
130679: PUSH
130680: LD_VAR 0 15
130684: DIFF
130685: ST_TO_ADDR
// end ; if not f_murder then
130686: LD_VAR 0 20
130690: NOT
130691: IFFALSE 130749
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
130693: LD_ADDR_VAR 0 15
130697: PUSH
130698: LD_VAR 0 14
130702: PPUSH
130703: LD_INT 3
130705: PUSH
130706: LD_INT 50
130708: PUSH
130709: EMPTY
130710: LIST
130711: PUSH
130712: EMPTY
130713: LIST
130714: LIST
130715: PPUSH
130716: CALL_OW 72
130720: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130721: LD_VAR 0 14
130725: PUSH
130726: LD_VAR 0 15
130730: DIFF
130731: IFFALSE 130749
// tmp := tmp diff tmp2 ;
130733: LD_ADDR_VAR 0 14
130737: PUSH
130738: LD_VAR 0 14
130742: PUSH
130743: LD_VAR 0 15
130747: DIFF
130748: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
130749: LD_ADDR_VAR 0 14
130753: PUSH
130754: LD_VAR 0 4
130758: PUSH
130759: LD_VAR 0 7
130763: ARRAY
130764: PPUSH
130765: LD_VAR 0 14
130769: PPUSH
130770: LD_INT 1
130772: PPUSH
130773: LD_INT 1
130775: PPUSH
130776: CALL 72822 0 4
130780: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
130781: LD_VAR 0 4
130785: PUSH
130786: LD_VAR 0 7
130790: ARRAY
130791: PPUSH
130792: CALL_OW 257
130796: PUSH
130797: LD_INT 1
130799: EQUAL
130800: IFFALSE 131248
// begin if WantPlant ( group [ i ] ) then
130802: LD_VAR 0 4
130806: PUSH
130807: LD_VAR 0 7
130811: ARRAY
130812: PPUSH
130813: CALL 72323 0 1
130817: IFFALSE 130821
// continue ;
130819: GO 129093
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
130821: LD_VAR 0 18
130825: PUSH
130826: LD_VAR 0 4
130830: PUSH
130831: LD_VAR 0 7
130835: ARRAY
130836: PPUSH
130837: CALL_OW 310
130841: NOT
130842: AND
130843: PUSH
130844: LD_VAR 0 14
130848: PUSH
130849: LD_INT 1
130851: ARRAY
130852: PUSH
130853: LD_VAR 0 14
130857: PPUSH
130858: LD_INT 21
130860: PUSH
130861: LD_INT 2
130863: PUSH
130864: EMPTY
130865: LIST
130866: LIST
130867: PUSH
130868: LD_INT 58
130870: PUSH
130871: EMPTY
130872: LIST
130873: PUSH
130874: EMPTY
130875: LIST
130876: LIST
130877: PPUSH
130878: CALL_OW 72
130882: IN
130883: AND
130884: IFFALSE 130920
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
130886: LD_VAR 0 4
130890: PUSH
130891: LD_VAR 0 7
130895: ARRAY
130896: PPUSH
130897: LD_VAR 0 14
130901: PUSH
130902: LD_INT 1
130904: ARRAY
130905: PPUSH
130906: CALL_OW 120
// attacking := true ;
130910: LD_ADDR_VAR 0 29
130914: PUSH
130915: LD_INT 1
130917: ST_TO_ADDR
// continue ;
130918: GO 129093
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
130920: LD_VAR 0 26
130924: PUSH
130925: LD_VAR 0 4
130929: PUSH
130930: LD_VAR 0 7
130934: ARRAY
130935: PPUSH
130936: CALL_OW 257
130940: PUSH
130941: LD_INT 1
130943: EQUAL
130944: AND
130945: PUSH
130946: LD_VAR 0 4
130950: PUSH
130951: LD_VAR 0 7
130955: ARRAY
130956: PPUSH
130957: CALL_OW 256
130961: PUSH
130962: LD_INT 800
130964: LESS
130965: AND
130966: PUSH
130967: LD_VAR 0 4
130971: PUSH
130972: LD_VAR 0 7
130976: ARRAY
130977: PPUSH
130978: CALL_OW 318
130982: NOT
130983: AND
130984: IFFALSE 131001
// ComCrawl ( group [ i ] ) ;
130986: LD_VAR 0 4
130990: PUSH
130991: LD_VAR 0 7
130995: ARRAY
130996: PPUSH
130997: CALL_OW 137
// if f_mines then
131001: LD_VAR 0 21
131005: IFFALSE 131248
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
131007: LD_VAR 0 14
131011: PUSH
131012: LD_INT 1
131014: ARRAY
131015: PPUSH
131016: CALL_OW 247
131020: PUSH
131021: LD_INT 3
131023: EQUAL
131024: PUSH
131025: LD_VAR 0 14
131029: PUSH
131030: LD_INT 1
131032: ARRAY
131033: PUSH
131034: LD_VAR 0 27
131038: IN
131039: NOT
131040: AND
131041: IFFALSE 131248
// begin x := GetX ( tmp [ 1 ] ) ;
131043: LD_ADDR_VAR 0 10
131047: PUSH
131048: LD_VAR 0 14
131052: PUSH
131053: LD_INT 1
131055: ARRAY
131056: PPUSH
131057: CALL_OW 250
131061: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
131062: LD_ADDR_VAR 0 11
131066: PUSH
131067: LD_VAR 0 14
131071: PUSH
131072: LD_INT 1
131074: ARRAY
131075: PPUSH
131076: CALL_OW 251
131080: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
131081: LD_ADDR_VAR 0 12
131085: PUSH
131086: LD_VAR 0 4
131090: PUSH
131091: LD_VAR 0 7
131095: ARRAY
131096: PPUSH
131097: CALL 99966 0 1
131101: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
131102: LD_VAR 0 4
131106: PUSH
131107: LD_VAR 0 7
131111: ARRAY
131112: PPUSH
131113: LD_VAR 0 10
131117: PPUSH
131118: LD_VAR 0 11
131122: PPUSH
131123: LD_VAR 0 14
131127: PUSH
131128: LD_INT 1
131130: ARRAY
131131: PPUSH
131132: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
131136: LD_VAR 0 4
131140: PUSH
131141: LD_VAR 0 7
131145: ARRAY
131146: PPUSH
131147: LD_VAR 0 10
131151: PPUSH
131152: LD_VAR 0 12
131156: PPUSH
131157: LD_INT 7
131159: PPUSH
131160: CALL_OW 272
131164: PPUSH
131165: LD_VAR 0 11
131169: PPUSH
131170: LD_VAR 0 12
131174: PPUSH
131175: LD_INT 7
131177: PPUSH
131178: CALL_OW 273
131182: PPUSH
131183: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
131187: LD_VAR 0 4
131191: PUSH
131192: LD_VAR 0 7
131196: ARRAY
131197: PPUSH
131198: LD_INT 71
131200: PPUSH
131201: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
131205: LD_ADDR_VAR 0 27
131209: PUSH
131210: LD_VAR 0 27
131214: PPUSH
131215: LD_VAR 0 27
131219: PUSH
131220: LD_INT 1
131222: PLUS
131223: PPUSH
131224: LD_VAR 0 14
131228: PUSH
131229: LD_INT 1
131231: ARRAY
131232: PPUSH
131233: CALL_OW 1
131237: ST_TO_ADDR
// attacking := true ;
131238: LD_ADDR_VAR 0 29
131242: PUSH
131243: LD_INT 1
131245: ST_TO_ADDR
// continue ;
131246: GO 129093
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
131248: LD_VAR 0 4
131252: PUSH
131253: LD_VAR 0 7
131257: ARRAY
131258: PPUSH
131259: CALL_OW 257
131263: PUSH
131264: LD_INT 17
131266: EQUAL
131267: PUSH
131268: LD_VAR 0 4
131272: PUSH
131273: LD_VAR 0 7
131277: ARRAY
131278: PPUSH
131279: CALL_OW 110
131283: PUSH
131284: LD_INT 71
131286: EQUAL
131287: NOT
131288: AND
131289: IFFALSE 131435
// begin attacking := false ;
131291: LD_ADDR_VAR 0 29
131295: PUSH
131296: LD_INT 0
131298: ST_TO_ADDR
// k := 5 ;
131299: LD_ADDR_VAR 0 9
131303: PUSH
131304: LD_INT 5
131306: ST_TO_ADDR
// if tmp < k then
131307: LD_VAR 0 14
131311: PUSH
131312: LD_VAR 0 9
131316: LESS
131317: IFFALSE 131329
// k := tmp ;
131319: LD_ADDR_VAR 0 9
131323: PUSH
131324: LD_VAR 0 14
131328: ST_TO_ADDR
// for j = 1 to k do
131329: LD_ADDR_VAR 0 8
131333: PUSH
131334: DOUBLE
131335: LD_INT 1
131337: DEC
131338: ST_TO_ADDR
131339: LD_VAR 0 9
131343: PUSH
131344: FOR_TO
131345: IFFALSE 131433
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
131347: LD_VAR 0 14
131351: PUSH
131352: LD_VAR 0 8
131356: ARRAY
131357: PUSH
131358: LD_VAR 0 14
131362: PPUSH
131363: LD_INT 58
131365: PUSH
131366: EMPTY
131367: LIST
131368: PPUSH
131369: CALL_OW 72
131373: IN
131374: NOT
131375: IFFALSE 131431
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131377: LD_VAR 0 4
131381: PUSH
131382: LD_VAR 0 7
131386: ARRAY
131387: PPUSH
131388: LD_VAR 0 14
131392: PUSH
131393: LD_VAR 0 8
131397: ARRAY
131398: PPUSH
131399: CALL_OW 115
// attacking := true ;
131403: LD_ADDR_VAR 0 29
131407: PUSH
131408: LD_INT 1
131410: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
131411: LD_VAR 0 4
131415: PUSH
131416: LD_VAR 0 7
131420: ARRAY
131421: PPUSH
131422: LD_INT 71
131424: PPUSH
131425: CALL_OW 109
// continue ;
131429: GO 131344
// end ; end ;
131431: GO 131344
131433: POP
131434: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
131435: LD_VAR 0 4
131439: PUSH
131440: LD_VAR 0 7
131444: ARRAY
131445: PPUSH
131446: CALL_OW 257
131450: PUSH
131451: LD_INT 8
131453: EQUAL
131454: PUSH
131455: LD_VAR 0 4
131459: PUSH
131460: LD_VAR 0 7
131464: ARRAY
131465: PPUSH
131466: CALL_OW 264
131470: PUSH
131471: LD_INT 28
131473: PUSH
131474: LD_INT 45
131476: PUSH
131477: LD_INT 7
131479: PUSH
131480: LD_INT 47
131482: PUSH
131483: EMPTY
131484: LIST
131485: LIST
131486: LIST
131487: LIST
131488: IN
131489: OR
131490: IFFALSE 131746
// begin attacking := false ;
131492: LD_ADDR_VAR 0 29
131496: PUSH
131497: LD_INT 0
131499: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
131500: LD_VAR 0 14
131504: PUSH
131505: LD_INT 1
131507: ARRAY
131508: PPUSH
131509: CALL_OW 266
131513: PUSH
131514: LD_INT 32
131516: PUSH
131517: LD_INT 31
131519: PUSH
131520: LD_INT 33
131522: PUSH
131523: LD_INT 4
131525: PUSH
131526: LD_INT 5
131528: PUSH
131529: EMPTY
131530: LIST
131531: LIST
131532: LIST
131533: LIST
131534: LIST
131535: IN
131536: IFFALSE 131722
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
131538: LD_ADDR_VAR 0 9
131542: PUSH
131543: LD_VAR 0 14
131547: PUSH
131548: LD_INT 1
131550: ARRAY
131551: PPUSH
131552: CALL_OW 266
131556: PPUSH
131557: LD_VAR 0 14
131561: PUSH
131562: LD_INT 1
131564: ARRAY
131565: PPUSH
131566: CALL_OW 250
131570: PPUSH
131571: LD_VAR 0 14
131575: PUSH
131576: LD_INT 1
131578: ARRAY
131579: PPUSH
131580: CALL_OW 251
131584: PPUSH
131585: LD_VAR 0 14
131589: PUSH
131590: LD_INT 1
131592: ARRAY
131593: PPUSH
131594: CALL_OW 254
131598: PPUSH
131599: LD_VAR 0 14
131603: PUSH
131604: LD_INT 1
131606: ARRAY
131607: PPUSH
131608: CALL_OW 248
131612: PPUSH
131613: LD_INT 0
131615: PPUSH
131616: CALL 81336 0 6
131620: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
131621: LD_ADDR_VAR 0 8
131625: PUSH
131626: LD_VAR 0 4
131630: PUSH
131631: LD_VAR 0 7
131635: ARRAY
131636: PPUSH
131637: LD_VAR 0 9
131641: PPUSH
131642: CALL 100079 0 2
131646: ST_TO_ADDR
// if j then
131647: LD_VAR 0 8
131651: IFFALSE 131720
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
131653: LD_VAR 0 8
131657: PUSH
131658: LD_INT 1
131660: ARRAY
131661: PPUSH
131662: LD_VAR 0 8
131666: PUSH
131667: LD_INT 2
131669: ARRAY
131670: PPUSH
131671: CALL_OW 488
131675: IFFALSE 131720
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
131677: LD_VAR 0 4
131681: PUSH
131682: LD_VAR 0 7
131686: ARRAY
131687: PPUSH
131688: LD_VAR 0 8
131692: PUSH
131693: LD_INT 1
131695: ARRAY
131696: PPUSH
131697: LD_VAR 0 8
131701: PUSH
131702: LD_INT 2
131704: ARRAY
131705: PPUSH
131706: CALL_OW 116
// attacking := true ;
131710: LD_ADDR_VAR 0 29
131714: PUSH
131715: LD_INT 1
131717: ST_TO_ADDR
// continue ;
131718: GO 129093
// end ; end else
131720: GO 131746
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131722: LD_VAR 0 4
131726: PUSH
131727: LD_VAR 0 7
131731: ARRAY
131732: PPUSH
131733: LD_VAR 0 14
131737: PUSH
131738: LD_INT 1
131740: ARRAY
131741: PPUSH
131742: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
131746: LD_VAR 0 4
131750: PUSH
131751: LD_VAR 0 7
131755: ARRAY
131756: PPUSH
131757: CALL_OW 265
131761: PUSH
131762: LD_INT 11
131764: EQUAL
131765: IFFALSE 132043
// begin k := 10 ;
131767: LD_ADDR_VAR 0 9
131771: PUSH
131772: LD_INT 10
131774: ST_TO_ADDR
// x := 0 ;
131775: LD_ADDR_VAR 0 10
131779: PUSH
131780: LD_INT 0
131782: ST_TO_ADDR
// if tmp < k then
131783: LD_VAR 0 14
131787: PUSH
131788: LD_VAR 0 9
131792: LESS
131793: IFFALSE 131805
// k := tmp ;
131795: LD_ADDR_VAR 0 9
131799: PUSH
131800: LD_VAR 0 14
131804: ST_TO_ADDR
// for j = k downto 1 do
131805: LD_ADDR_VAR 0 8
131809: PUSH
131810: DOUBLE
131811: LD_VAR 0 9
131815: INC
131816: ST_TO_ADDR
131817: LD_INT 1
131819: PUSH
131820: FOR_DOWNTO
131821: IFFALSE 131896
// begin if GetType ( tmp [ j ] ) = unit_human then
131823: LD_VAR 0 14
131827: PUSH
131828: LD_VAR 0 8
131832: ARRAY
131833: PPUSH
131834: CALL_OW 247
131838: PUSH
131839: LD_INT 1
131841: EQUAL
131842: IFFALSE 131894
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
131844: LD_VAR 0 4
131848: PUSH
131849: LD_VAR 0 7
131853: ARRAY
131854: PPUSH
131855: LD_VAR 0 14
131859: PUSH
131860: LD_VAR 0 8
131864: ARRAY
131865: PPUSH
131866: CALL 100333 0 2
// x := tmp [ j ] ;
131870: LD_ADDR_VAR 0 10
131874: PUSH
131875: LD_VAR 0 14
131879: PUSH
131880: LD_VAR 0 8
131884: ARRAY
131885: ST_TO_ADDR
// attacking := true ;
131886: LD_ADDR_VAR 0 29
131890: PUSH
131891: LD_INT 1
131893: ST_TO_ADDR
// end ; end ;
131894: GO 131820
131896: POP
131897: POP
// if not x then
131898: LD_VAR 0 10
131902: NOT
131903: IFFALSE 132043
// begin attacking := true ;
131905: LD_ADDR_VAR 0 29
131909: PUSH
131910: LD_INT 1
131912: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
131913: LD_VAR 0 4
131917: PUSH
131918: LD_VAR 0 7
131922: ARRAY
131923: PPUSH
131924: CALL_OW 250
131928: PPUSH
131929: LD_VAR 0 4
131933: PUSH
131934: LD_VAR 0 7
131938: ARRAY
131939: PPUSH
131940: CALL_OW 251
131944: PPUSH
131945: CALL_OW 546
131949: PUSH
131950: LD_INT 2
131952: ARRAY
131953: PUSH
131954: LD_VAR 0 14
131958: PUSH
131959: LD_INT 1
131961: ARRAY
131962: PPUSH
131963: CALL_OW 250
131967: PPUSH
131968: LD_VAR 0 14
131972: PUSH
131973: LD_INT 1
131975: ARRAY
131976: PPUSH
131977: CALL_OW 251
131981: PPUSH
131982: CALL_OW 546
131986: PUSH
131987: LD_INT 2
131989: ARRAY
131990: EQUAL
131991: IFFALSE 132019
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
131993: LD_VAR 0 4
131997: PUSH
131998: LD_VAR 0 7
132002: ARRAY
132003: PPUSH
132004: LD_VAR 0 14
132008: PUSH
132009: LD_INT 1
132011: ARRAY
132012: PPUSH
132013: CALL 100333 0 2
132017: GO 132043
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132019: LD_VAR 0 4
132023: PUSH
132024: LD_VAR 0 7
132028: ARRAY
132029: PPUSH
132030: LD_VAR 0 14
132034: PUSH
132035: LD_INT 1
132037: ARRAY
132038: PPUSH
132039: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
132043: LD_VAR 0 4
132047: PUSH
132048: LD_VAR 0 7
132052: ARRAY
132053: PPUSH
132054: CALL_OW 264
132058: PUSH
132059: LD_INT 29
132061: EQUAL
132062: IFFALSE 132428
// begin if WantsToAttack ( group [ i ] ) in bombed then
132064: LD_VAR 0 4
132068: PUSH
132069: LD_VAR 0 7
132073: ARRAY
132074: PPUSH
132075: CALL_OW 319
132079: PUSH
132080: LD_VAR 0 28
132084: IN
132085: IFFALSE 132089
// continue ;
132087: GO 129093
// k := 8 ;
132089: LD_ADDR_VAR 0 9
132093: PUSH
132094: LD_INT 8
132096: ST_TO_ADDR
// x := 0 ;
132097: LD_ADDR_VAR 0 10
132101: PUSH
132102: LD_INT 0
132104: ST_TO_ADDR
// if tmp < k then
132105: LD_VAR 0 14
132109: PUSH
132110: LD_VAR 0 9
132114: LESS
132115: IFFALSE 132127
// k := tmp ;
132117: LD_ADDR_VAR 0 9
132121: PUSH
132122: LD_VAR 0 14
132126: ST_TO_ADDR
// for j = 1 to k do
132127: LD_ADDR_VAR 0 8
132131: PUSH
132132: DOUBLE
132133: LD_INT 1
132135: DEC
132136: ST_TO_ADDR
132137: LD_VAR 0 9
132141: PUSH
132142: FOR_TO
132143: IFFALSE 132275
// begin if GetType ( tmp [ j ] ) = unit_building then
132145: LD_VAR 0 14
132149: PUSH
132150: LD_VAR 0 8
132154: ARRAY
132155: PPUSH
132156: CALL_OW 247
132160: PUSH
132161: LD_INT 3
132163: EQUAL
132164: IFFALSE 132273
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
132166: LD_VAR 0 14
132170: PUSH
132171: LD_VAR 0 8
132175: ARRAY
132176: PUSH
132177: LD_VAR 0 28
132181: IN
132182: NOT
132183: PUSH
132184: LD_VAR 0 14
132188: PUSH
132189: LD_VAR 0 8
132193: ARRAY
132194: PPUSH
132195: CALL_OW 313
132199: AND
132200: IFFALSE 132273
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132202: LD_VAR 0 4
132206: PUSH
132207: LD_VAR 0 7
132211: ARRAY
132212: PPUSH
132213: LD_VAR 0 14
132217: PUSH
132218: LD_VAR 0 8
132222: ARRAY
132223: PPUSH
132224: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
132228: LD_ADDR_VAR 0 28
132232: PUSH
132233: LD_VAR 0 28
132237: PPUSH
132238: LD_VAR 0 28
132242: PUSH
132243: LD_INT 1
132245: PLUS
132246: PPUSH
132247: LD_VAR 0 14
132251: PUSH
132252: LD_VAR 0 8
132256: ARRAY
132257: PPUSH
132258: CALL_OW 1
132262: ST_TO_ADDR
// attacking := true ;
132263: LD_ADDR_VAR 0 29
132267: PUSH
132268: LD_INT 1
132270: ST_TO_ADDR
// break ;
132271: GO 132275
// end ; end ;
132273: GO 132142
132275: POP
132276: POP
// if not attacking and f_attack_depot then
132277: LD_VAR 0 29
132281: NOT
132282: PUSH
132283: LD_VAR 0 25
132287: AND
132288: IFFALSE 132383
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132290: LD_ADDR_VAR 0 13
132294: PUSH
132295: LD_VAR 0 14
132299: PPUSH
132300: LD_INT 2
132302: PUSH
132303: LD_INT 30
132305: PUSH
132306: LD_INT 0
132308: PUSH
132309: EMPTY
132310: LIST
132311: LIST
132312: PUSH
132313: LD_INT 30
132315: PUSH
132316: LD_INT 1
132318: PUSH
132319: EMPTY
132320: LIST
132321: LIST
132322: PUSH
132323: EMPTY
132324: LIST
132325: LIST
132326: LIST
132327: PPUSH
132328: CALL_OW 72
132332: ST_TO_ADDR
// if z then
132333: LD_VAR 0 13
132337: IFFALSE 132383
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
132339: LD_VAR 0 4
132343: PUSH
132344: LD_VAR 0 7
132348: ARRAY
132349: PPUSH
132350: LD_VAR 0 13
132354: PPUSH
132355: LD_VAR 0 4
132359: PUSH
132360: LD_VAR 0 7
132364: ARRAY
132365: PPUSH
132366: CALL_OW 74
132370: PPUSH
132371: CALL_OW 115
// attacking := true ;
132375: LD_ADDR_VAR 0 29
132379: PUSH
132380: LD_INT 1
132382: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
132383: LD_VAR 0 4
132387: PUSH
132388: LD_VAR 0 7
132392: ARRAY
132393: PPUSH
132394: CALL_OW 256
132398: PUSH
132399: LD_INT 500
132401: LESS
132402: IFFALSE 132428
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132404: LD_VAR 0 4
132408: PUSH
132409: LD_VAR 0 7
132413: ARRAY
132414: PPUSH
132415: LD_VAR 0 14
132419: PUSH
132420: LD_INT 1
132422: ARRAY
132423: PPUSH
132424: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
132428: LD_VAR 0 4
132432: PUSH
132433: LD_VAR 0 7
132437: ARRAY
132438: PPUSH
132439: CALL_OW 264
132443: PUSH
132444: LD_INT 49
132446: EQUAL
132447: IFFALSE 132568
// begin if not HasTask ( group [ i ] ) then
132449: LD_VAR 0 4
132453: PUSH
132454: LD_VAR 0 7
132458: ARRAY
132459: PPUSH
132460: CALL_OW 314
132464: NOT
132465: IFFALSE 132568
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
132467: LD_ADDR_VAR 0 9
132471: PUSH
132472: LD_INT 81
132474: PUSH
132475: LD_VAR 0 4
132479: PUSH
132480: LD_VAR 0 7
132484: ARRAY
132485: PPUSH
132486: CALL_OW 255
132490: PUSH
132491: EMPTY
132492: LIST
132493: LIST
132494: PPUSH
132495: CALL_OW 69
132499: PPUSH
132500: LD_VAR 0 4
132504: PUSH
132505: LD_VAR 0 7
132509: ARRAY
132510: PPUSH
132511: CALL_OW 74
132515: ST_TO_ADDR
// if k then
132516: LD_VAR 0 9
132520: IFFALSE 132568
// if GetDistUnits ( group [ i ] , k ) > 10 then
132522: LD_VAR 0 4
132526: PUSH
132527: LD_VAR 0 7
132531: ARRAY
132532: PPUSH
132533: LD_VAR 0 9
132537: PPUSH
132538: CALL_OW 296
132542: PUSH
132543: LD_INT 10
132545: GREATER
132546: IFFALSE 132568
// ComMoveUnit ( group [ i ] , k ) ;
132548: LD_VAR 0 4
132552: PUSH
132553: LD_VAR 0 7
132557: ARRAY
132558: PPUSH
132559: LD_VAR 0 9
132563: PPUSH
132564: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
132568: LD_VAR 0 4
132572: PUSH
132573: LD_VAR 0 7
132577: ARRAY
132578: PPUSH
132579: CALL_OW 256
132583: PUSH
132584: LD_INT 250
132586: LESS
132587: PUSH
132588: LD_VAR 0 4
132592: PUSH
132593: LD_VAR 0 7
132597: ARRAY
132598: PUSH
132599: LD_INT 21
132601: PUSH
132602: LD_INT 2
132604: PUSH
132605: EMPTY
132606: LIST
132607: LIST
132608: PUSH
132609: LD_INT 23
132611: PUSH
132612: LD_INT 2
132614: PUSH
132615: EMPTY
132616: LIST
132617: LIST
132618: PUSH
132619: EMPTY
132620: LIST
132621: LIST
132622: PPUSH
132623: CALL_OW 69
132627: IN
132628: AND
132629: IFFALSE 132754
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
132631: LD_ADDR_VAR 0 9
132635: PUSH
132636: LD_OWVAR 3
132640: PUSH
132641: LD_VAR 0 4
132645: PUSH
132646: LD_VAR 0 7
132650: ARRAY
132651: DIFF
132652: PPUSH
132653: LD_VAR 0 4
132657: PUSH
132658: LD_VAR 0 7
132662: ARRAY
132663: PPUSH
132664: CALL_OW 74
132668: ST_TO_ADDR
// if not k then
132669: LD_VAR 0 9
132673: NOT
132674: IFFALSE 132678
// continue ;
132676: GO 129093
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
132678: LD_VAR 0 9
132682: PUSH
132683: LD_INT 81
132685: PUSH
132686: LD_VAR 0 4
132690: PUSH
132691: LD_VAR 0 7
132695: ARRAY
132696: PPUSH
132697: CALL_OW 255
132701: PUSH
132702: EMPTY
132703: LIST
132704: LIST
132705: PPUSH
132706: CALL_OW 69
132710: IN
132711: PUSH
132712: LD_VAR 0 9
132716: PPUSH
132717: LD_VAR 0 4
132721: PUSH
132722: LD_VAR 0 7
132726: ARRAY
132727: PPUSH
132728: CALL_OW 296
132732: PUSH
132733: LD_INT 5
132735: LESS
132736: AND
132737: IFFALSE 132754
// ComAutodestruct ( group [ i ] ) ;
132739: LD_VAR 0 4
132743: PUSH
132744: LD_VAR 0 7
132748: ARRAY
132749: PPUSH
132750: CALL 100231 0 1
// end ; if f_attack_depot then
132754: LD_VAR 0 25
132758: IFFALSE 132870
// begin k := 6 ;
132760: LD_ADDR_VAR 0 9
132764: PUSH
132765: LD_INT 6
132767: ST_TO_ADDR
// if tmp < k then
132768: LD_VAR 0 14
132772: PUSH
132773: LD_VAR 0 9
132777: LESS
132778: IFFALSE 132790
// k := tmp ;
132780: LD_ADDR_VAR 0 9
132784: PUSH
132785: LD_VAR 0 14
132789: ST_TO_ADDR
// for j = 1 to k do
132790: LD_ADDR_VAR 0 8
132794: PUSH
132795: DOUBLE
132796: LD_INT 1
132798: DEC
132799: ST_TO_ADDR
132800: LD_VAR 0 9
132804: PUSH
132805: FOR_TO
132806: IFFALSE 132868
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
132808: LD_VAR 0 8
132812: PPUSH
132813: CALL_OW 266
132817: PUSH
132818: LD_INT 0
132820: PUSH
132821: LD_INT 1
132823: PUSH
132824: EMPTY
132825: LIST
132826: LIST
132827: IN
132828: IFFALSE 132866
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132830: LD_VAR 0 4
132834: PUSH
132835: LD_VAR 0 7
132839: ARRAY
132840: PPUSH
132841: LD_VAR 0 14
132845: PUSH
132846: LD_VAR 0 8
132850: ARRAY
132851: PPUSH
132852: CALL_OW 115
// attacking := true ;
132856: LD_ADDR_VAR 0 29
132860: PUSH
132861: LD_INT 1
132863: ST_TO_ADDR
// break ;
132864: GO 132868
// end ;
132866: GO 132805
132868: POP
132869: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
132870: LD_VAR 0 4
132874: PUSH
132875: LD_VAR 0 7
132879: ARRAY
132880: PPUSH
132881: CALL_OW 302
132885: PUSH
132886: LD_VAR 0 29
132890: NOT
132891: AND
132892: IFFALSE 133214
// begin if GetTag ( group [ i ] ) = 71 then
132894: LD_VAR 0 4
132898: PUSH
132899: LD_VAR 0 7
132903: ARRAY
132904: PPUSH
132905: CALL_OW 110
132909: PUSH
132910: LD_INT 71
132912: EQUAL
132913: IFFALSE 132954
// begin if HasTask ( group [ i ] ) then
132915: LD_VAR 0 4
132919: PUSH
132920: LD_VAR 0 7
132924: ARRAY
132925: PPUSH
132926: CALL_OW 314
132930: IFFALSE 132936
// continue else
132932: GO 129093
132934: GO 132954
// SetTag ( group [ i ] , 0 ) ;
132936: LD_VAR 0 4
132940: PUSH
132941: LD_VAR 0 7
132945: ARRAY
132946: PPUSH
132947: LD_INT 0
132949: PPUSH
132950: CALL_OW 109
// end ; k := 8 ;
132954: LD_ADDR_VAR 0 9
132958: PUSH
132959: LD_INT 8
132961: ST_TO_ADDR
// x := 0 ;
132962: LD_ADDR_VAR 0 10
132966: PUSH
132967: LD_INT 0
132969: ST_TO_ADDR
// if tmp < k then
132970: LD_VAR 0 14
132974: PUSH
132975: LD_VAR 0 9
132979: LESS
132980: IFFALSE 132992
// k := tmp ;
132982: LD_ADDR_VAR 0 9
132986: PUSH
132987: LD_VAR 0 14
132991: ST_TO_ADDR
// for j = 1 to k do
132992: LD_ADDR_VAR 0 8
132996: PUSH
132997: DOUBLE
132998: LD_INT 1
133000: DEC
133001: ST_TO_ADDR
133002: LD_VAR 0 9
133006: PUSH
133007: FOR_TO
133008: IFFALSE 133106
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
133010: LD_VAR 0 14
133014: PUSH
133015: LD_VAR 0 8
133019: ARRAY
133020: PPUSH
133021: CALL_OW 247
133025: PUSH
133026: LD_INT 1
133028: EQUAL
133029: PUSH
133030: LD_VAR 0 14
133034: PUSH
133035: LD_VAR 0 8
133039: ARRAY
133040: PPUSH
133041: CALL_OW 256
133045: PUSH
133046: LD_INT 250
133048: LESS
133049: PUSH
133050: LD_VAR 0 20
133054: AND
133055: PUSH
133056: LD_VAR 0 20
133060: NOT
133061: PUSH
133062: LD_VAR 0 14
133066: PUSH
133067: LD_VAR 0 8
133071: ARRAY
133072: PPUSH
133073: CALL_OW 256
133077: PUSH
133078: LD_INT 250
133080: GREATEREQUAL
133081: AND
133082: OR
133083: AND
133084: IFFALSE 133104
// begin x := tmp [ j ] ;
133086: LD_ADDR_VAR 0 10
133090: PUSH
133091: LD_VAR 0 14
133095: PUSH
133096: LD_VAR 0 8
133100: ARRAY
133101: ST_TO_ADDR
// break ;
133102: GO 133106
// end ;
133104: GO 133007
133106: POP
133107: POP
// if x then
133108: LD_VAR 0 10
133112: IFFALSE 133136
// ComAttackUnit ( group [ i ] , x ) else
133114: LD_VAR 0 4
133118: PUSH
133119: LD_VAR 0 7
133123: ARRAY
133124: PPUSH
133125: LD_VAR 0 10
133129: PPUSH
133130: CALL_OW 115
133134: GO 133160
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133136: LD_VAR 0 4
133140: PUSH
133141: LD_VAR 0 7
133145: ARRAY
133146: PPUSH
133147: LD_VAR 0 14
133151: PUSH
133152: LD_INT 1
133154: ARRAY
133155: PPUSH
133156: CALL_OW 115
// if not HasTask ( group [ i ] ) then
133160: LD_VAR 0 4
133164: PUSH
133165: LD_VAR 0 7
133169: ARRAY
133170: PPUSH
133171: CALL_OW 314
133175: NOT
133176: IFFALSE 133214
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
133178: LD_VAR 0 4
133182: PUSH
133183: LD_VAR 0 7
133187: ARRAY
133188: PPUSH
133189: LD_VAR 0 14
133193: PPUSH
133194: LD_VAR 0 4
133198: PUSH
133199: LD_VAR 0 7
133203: ARRAY
133204: PPUSH
133205: CALL_OW 74
133209: PPUSH
133210: CALL_OW 115
// end ; end ; end ;
133214: GO 129093
133216: POP
133217: POP
// wait ( 0 0$2 ) ;
133218: LD_INT 70
133220: PPUSH
133221: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
133225: LD_VAR 0 4
133229: NOT
133230: PUSH
133231: LD_VAR 0 4
133235: PUSH
133236: EMPTY
133237: EQUAL
133238: OR
133239: PUSH
133240: LD_INT 81
133242: PUSH
133243: LD_VAR 0 35
133247: PUSH
133248: EMPTY
133249: LIST
133250: LIST
133251: PPUSH
133252: CALL_OW 69
133256: NOT
133257: OR
133258: IFFALSE 129078
// end ;
133260: LD_VAR 0 2
133264: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
133265: LD_INT 0
133267: PPUSH
133268: PPUSH
133269: PPUSH
133270: PPUSH
133271: PPUSH
133272: PPUSH
// if not base or not mc_bases [ base ] or not solds then
133273: LD_VAR 0 1
133277: NOT
133278: PUSH
133279: LD_EXP 99
133283: PUSH
133284: LD_VAR 0 1
133288: ARRAY
133289: NOT
133290: OR
133291: PUSH
133292: LD_VAR 0 2
133296: NOT
133297: OR
133298: IFFALSE 133302
// exit ;
133300: GO 133856
// side := mc_sides [ base ] ;
133302: LD_ADDR_VAR 0 6
133306: PUSH
133307: LD_EXP 125
133311: PUSH
133312: LD_VAR 0 1
133316: ARRAY
133317: ST_TO_ADDR
// if not side then
133318: LD_VAR 0 6
133322: NOT
133323: IFFALSE 133327
// exit ;
133325: GO 133856
// for i in solds do
133327: LD_ADDR_VAR 0 7
133331: PUSH
133332: LD_VAR 0 2
133336: PUSH
133337: FOR_IN
133338: IFFALSE 133399
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
133340: LD_VAR 0 7
133344: PPUSH
133345: CALL_OW 310
133349: PPUSH
133350: CALL_OW 266
133354: PUSH
133355: LD_INT 32
133357: PUSH
133358: LD_INT 31
133360: PUSH
133361: EMPTY
133362: LIST
133363: LIST
133364: IN
133365: IFFALSE 133385
// solds := solds diff i else
133367: LD_ADDR_VAR 0 2
133371: PUSH
133372: LD_VAR 0 2
133376: PUSH
133377: LD_VAR 0 7
133381: DIFF
133382: ST_TO_ADDR
133383: GO 133397
// SetTag ( i , 18 ) ;
133385: LD_VAR 0 7
133389: PPUSH
133390: LD_INT 18
133392: PPUSH
133393: CALL_OW 109
133397: GO 133337
133399: POP
133400: POP
// if not solds then
133401: LD_VAR 0 2
133405: NOT
133406: IFFALSE 133410
// exit ;
133408: GO 133856
// repeat wait ( 0 0$2 ) ;
133410: LD_INT 70
133412: PPUSH
133413: CALL_OW 67
// enemy := mc_scan [ base ] ;
133417: LD_ADDR_VAR 0 4
133421: PUSH
133422: LD_EXP 122
133426: PUSH
133427: LD_VAR 0 1
133431: ARRAY
133432: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133433: LD_EXP 99
133437: PUSH
133438: LD_VAR 0 1
133442: ARRAY
133443: NOT
133444: PUSH
133445: LD_EXP 99
133449: PUSH
133450: LD_VAR 0 1
133454: ARRAY
133455: PUSH
133456: EMPTY
133457: EQUAL
133458: OR
133459: IFFALSE 133496
// begin for i in solds do
133461: LD_ADDR_VAR 0 7
133465: PUSH
133466: LD_VAR 0 2
133470: PUSH
133471: FOR_IN
133472: IFFALSE 133485
// ComStop ( i ) ;
133474: LD_VAR 0 7
133478: PPUSH
133479: CALL_OW 141
133483: GO 133471
133485: POP
133486: POP
// solds := [ ] ;
133487: LD_ADDR_VAR 0 2
133491: PUSH
133492: EMPTY
133493: ST_TO_ADDR
// exit ;
133494: GO 133856
// end ; for i in solds do
133496: LD_ADDR_VAR 0 7
133500: PUSH
133501: LD_VAR 0 2
133505: PUSH
133506: FOR_IN
133507: IFFALSE 133828
// begin if IsInUnit ( i ) then
133509: LD_VAR 0 7
133513: PPUSH
133514: CALL_OW 310
133518: IFFALSE 133529
// ComExitBuilding ( i ) ;
133520: LD_VAR 0 7
133524: PPUSH
133525: CALL_OW 122
// if GetLives ( i ) > 500 then
133529: LD_VAR 0 7
133533: PPUSH
133534: CALL_OW 256
133538: PUSH
133539: LD_INT 500
133541: GREATER
133542: IFFALSE 133595
// begin e := NearestUnitToUnit ( enemy , i ) ;
133544: LD_ADDR_VAR 0 5
133548: PUSH
133549: LD_VAR 0 4
133553: PPUSH
133554: LD_VAR 0 7
133558: PPUSH
133559: CALL_OW 74
133563: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
133564: LD_VAR 0 7
133568: PPUSH
133569: LD_VAR 0 5
133573: PPUSH
133574: CALL_OW 250
133578: PPUSH
133579: LD_VAR 0 5
133583: PPUSH
133584: CALL_OW 251
133588: PPUSH
133589: CALL_OW 114
// end else
133593: GO 133826
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
133595: LD_VAR 0 7
133599: PPUSH
133600: LD_EXP 99
133604: PUSH
133605: LD_VAR 0 1
133609: ARRAY
133610: PPUSH
133611: LD_INT 2
133613: PUSH
133614: LD_INT 30
133616: PUSH
133617: LD_INT 0
133619: PUSH
133620: EMPTY
133621: LIST
133622: LIST
133623: PUSH
133624: LD_INT 30
133626: PUSH
133627: LD_INT 1
133629: PUSH
133630: EMPTY
133631: LIST
133632: LIST
133633: PUSH
133634: LD_INT 30
133636: PUSH
133637: LD_INT 6
133639: PUSH
133640: EMPTY
133641: LIST
133642: LIST
133643: PUSH
133644: EMPTY
133645: LIST
133646: LIST
133647: LIST
133648: LIST
133649: PPUSH
133650: CALL_OW 72
133654: PPUSH
133655: LD_VAR 0 7
133659: PPUSH
133660: CALL_OW 74
133664: PPUSH
133665: CALL_OW 296
133669: PUSH
133670: LD_INT 10
133672: GREATER
133673: IFFALSE 133826
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
133675: LD_ADDR_VAR 0 8
133679: PUSH
133680: LD_EXP 99
133684: PUSH
133685: LD_VAR 0 1
133689: ARRAY
133690: PPUSH
133691: LD_INT 2
133693: PUSH
133694: LD_INT 30
133696: PUSH
133697: LD_INT 0
133699: PUSH
133700: EMPTY
133701: LIST
133702: LIST
133703: PUSH
133704: LD_INT 30
133706: PUSH
133707: LD_INT 1
133709: PUSH
133710: EMPTY
133711: LIST
133712: LIST
133713: PUSH
133714: LD_INT 30
133716: PUSH
133717: LD_INT 6
133719: PUSH
133720: EMPTY
133721: LIST
133722: LIST
133723: PUSH
133724: EMPTY
133725: LIST
133726: LIST
133727: LIST
133728: LIST
133729: PPUSH
133730: CALL_OW 72
133734: PPUSH
133735: LD_VAR 0 7
133739: PPUSH
133740: CALL_OW 74
133744: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
133745: LD_VAR 0 7
133749: PPUSH
133750: LD_VAR 0 8
133754: PPUSH
133755: CALL_OW 250
133759: PPUSH
133760: LD_INT 3
133762: PPUSH
133763: LD_INT 5
133765: PPUSH
133766: CALL_OW 272
133770: PPUSH
133771: LD_VAR 0 8
133775: PPUSH
133776: CALL_OW 251
133780: PPUSH
133781: LD_INT 3
133783: PPUSH
133784: LD_INT 5
133786: PPUSH
133787: CALL_OW 273
133791: PPUSH
133792: CALL_OW 111
// SetTag ( i , 0 ) ;
133796: LD_VAR 0 7
133800: PPUSH
133801: LD_INT 0
133803: PPUSH
133804: CALL_OW 109
// solds := solds diff i ;
133808: LD_ADDR_VAR 0 2
133812: PUSH
133813: LD_VAR 0 2
133817: PUSH
133818: LD_VAR 0 7
133822: DIFF
133823: ST_TO_ADDR
// continue ;
133824: GO 133506
// end ; end ;
133826: GO 133506
133828: POP
133829: POP
// until not solds or not enemy ;
133830: LD_VAR 0 2
133834: NOT
133835: PUSH
133836: LD_VAR 0 4
133840: NOT
133841: OR
133842: IFFALSE 133410
// MC_Reset ( base , 18 ) ;
133844: LD_VAR 0 1
133848: PPUSH
133849: LD_INT 18
133851: PPUSH
133852: CALL 40747 0 2
// end ;
133856: LD_VAR 0 3
133860: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
133861: LD_INT 0
133863: PPUSH
133864: PPUSH
133865: PPUSH
133866: PPUSH
133867: PPUSH
133868: PPUSH
133869: PPUSH
133870: PPUSH
133871: PPUSH
133872: PPUSH
133873: PPUSH
133874: PPUSH
133875: PPUSH
133876: PPUSH
133877: PPUSH
133878: PPUSH
133879: PPUSH
133880: PPUSH
133881: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
133882: LD_ADDR_VAR 0 12
133886: PUSH
133887: LD_EXP 99
133891: PUSH
133892: LD_VAR 0 1
133896: ARRAY
133897: PPUSH
133898: LD_INT 25
133900: PUSH
133901: LD_INT 3
133903: PUSH
133904: EMPTY
133905: LIST
133906: LIST
133907: PPUSH
133908: CALL_OW 72
133912: ST_TO_ADDR
// if mc_remote_driver [ base ] then
133913: LD_EXP 139
133917: PUSH
133918: LD_VAR 0 1
133922: ARRAY
133923: IFFALSE 133947
// mechs := mechs diff mc_remote_driver [ base ] ;
133925: LD_ADDR_VAR 0 12
133929: PUSH
133930: LD_VAR 0 12
133934: PUSH
133935: LD_EXP 139
133939: PUSH
133940: LD_VAR 0 1
133944: ARRAY
133945: DIFF
133946: ST_TO_ADDR
// for i in mechs do
133947: LD_ADDR_VAR 0 4
133951: PUSH
133952: LD_VAR 0 12
133956: PUSH
133957: FOR_IN
133958: IFFALSE 133993
// if GetTag ( i ) > 0 then
133960: LD_VAR 0 4
133964: PPUSH
133965: CALL_OW 110
133969: PUSH
133970: LD_INT 0
133972: GREATER
133973: IFFALSE 133991
// mechs := mechs diff i ;
133975: LD_ADDR_VAR 0 12
133979: PUSH
133980: LD_VAR 0 12
133984: PUSH
133985: LD_VAR 0 4
133989: DIFF
133990: ST_TO_ADDR
133991: GO 133957
133993: POP
133994: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
133995: LD_ADDR_VAR 0 8
133999: PUSH
134000: LD_EXP 99
134004: PUSH
134005: LD_VAR 0 1
134009: ARRAY
134010: PPUSH
134011: LD_INT 2
134013: PUSH
134014: LD_INT 25
134016: PUSH
134017: LD_INT 1
134019: PUSH
134020: EMPTY
134021: LIST
134022: LIST
134023: PUSH
134024: LD_INT 25
134026: PUSH
134027: LD_INT 5
134029: PUSH
134030: EMPTY
134031: LIST
134032: LIST
134033: PUSH
134034: LD_INT 25
134036: PUSH
134037: LD_INT 8
134039: PUSH
134040: EMPTY
134041: LIST
134042: LIST
134043: PUSH
134044: LD_INT 25
134046: PUSH
134047: LD_INT 9
134049: PUSH
134050: EMPTY
134051: LIST
134052: LIST
134053: PUSH
134054: EMPTY
134055: LIST
134056: LIST
134057: LIST
134058: LIST
134059: LIST
134060: PPUSH
134061: CALL_OW 72
134065: ST_TO_ADDR
// if not defenders and not solds then
134066: LD_VAR 0 2
134070: NOT
134071: PUSH
134072: LD_VAR 0 8
134076: NOT
134077: AND
134078: IFFALSE 134082
// exit ;
134080: GO 135852
// depot_under_attack := false ;
134082: LD_ADDR_VAR 0 16
134086: PUSH
134087: LD_INT 0
134089: ST_TO_ADDR
// sold_defenders := [ ] ;
134090: LD_ADDR_VAR 0 17
134094: PUSH
134095: EMPTY
134096: ST_TO_ADDR
// if mechs then
134097: LD_VAR 0 12
134101: IFFALSE 134254
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
134103: LD_ADDR_VAR 0 4
134107: PUSH
134108: LD_VAR 0 2
134112: PPUSH
134113: LD_INT 21
134115: PUSH
134116: LD_INT 2
134118: PUSH
134119: EMPTY
134120: LIST
134121: LIST
134122: PPUSH
134123: CALL_OW 72
134127: PUSH
134128: FOR_IN
134129: IFFALSE 134252
// begin if GetTag ( i ) <> 20 then
134131: LD_VAR 0 4
134135: PPUSH
134136: CALL_OW 110
134140: PUSH
134141: LD_INT 20
134143: NONEQUAL
134144: IFFALSE 134158
// SetTag ( i , 20 ) ;
134146: LD_VAR 0 4
134150: PPUSH
134151: LD_INT 20
134153: PPUSH
134154: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
134158: LD_VAR 0 4
134162: PPUSH
134163: CALL_OW 263
134167: PUSH
134168: LD_INT 1
134170: EQUAL
134171: PUSH
134172: LD_VAR 0 4
134176: PPUSH
134177: CALL_OW 311
134181: NOT
134182: AND
134183: IFFALSE 134250
// begin un := mechs [ 1 ] ;
134185: LD_ADDR_VAR 0 10
134189: PUSH
134190: LD_VAR 0 12
134194: PUSH
134195: LD_INT 1
134197: ARRAY
134198: ST_TO_ADDR
// ComExit ( un ) ;
134199: LD_VAR 0 10
134203: PPUSH
134204: CALL 105097 0 1
// AddComEnterUnit ( un , i ) ;
134208: LD_VAR 0 10
134212: PPUSH
134213: LD_VAR 0 4
134217: PPUSH
134218: CALL_OW 180
// SetTag ( un , 19 ) ;
134222: LD_VAR 0 10
134226: PPUSH
134227: LD_INT 19
134229: PPUSH
134230: CALL_OW 109
// mechs := mechs diff un ;
134234: LD_ADDR_VAR 0 12
134238: PUSH
134239: LD_VAR 0 12
134243: PUSH
134244: LD_VAR 0 10
134248: DIFF
134249: ST_TO_ADDR
// end ; end ;
134250: GO 134128
134252: POP
134253: POP
// if solds then
134254: LD_VAR 0 8
134258: IFFALSE 134317
// for i in solds do
134260: LD_ADDR_VAR 0 4
134264: PUSH
134265: LD_VAR 0 8
134269: PUSH
134270: FOR_IN
134271: IFFALSE 134315
// if not GetTag ( i ) then
134273: LD_VAR 0 4
134277: PPUSH
134278: CALL_OW 110
134282: NOT
134283: IFFALSE 134313
// begin defenders := defenders union i ;
134285: LD_ADDR_VAR 0 2
134289: PUSH
134290: LD_VAR 0 2
134294: PUSH
134295: LD_VAR 0 4
134299: UNION
134300: ST_TO_ADDR
// SetTag ( i , 18 ) ;
134301: LD_VAR 0 4
134305: PPUSH
134306: LD_INT 18
134308: PPUSH
134309: CALL_OW 109
// end ;
134313: GO 134270
134315: POP
134316: POP
// repeat wait ( 0 0$2 ) ;
134317: LD_INT 70
134319: PPUSH
134320: CALL_OW 67
// enemy := mc_scan [ base ] ;
134324: LD_ADDR_VAR 0 21
134328: PUSH
134329: LD_EXP 122
134333: PUSH
134334: LD_VAR 0 1
134338: ARRAY
134339: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134340: LD_EXP 99
134344: PUSH
134345: LD_VAR 0 1
134349: ARRAY
134350: NOT
134351: PUSH
134352: LD_EXP 99
134356: PUSH
134357: LD_VAR 0 1
134361: ARRAY
134362: PUSH
134363: EMPTY
134364: EQUAL
134365: OR
134366: IFFALSE 134403
// begin for i in defenders do
134368: LD_ADDR_VAR 0 4
134372: PUSH
134373: LD_VAR 0 2
134377: PUSH
134378: FOR_IN
134379: IFFALSE 134392
// ComStop ( i ) ;
134381: LD_VAR 0 4
134385: PPUSH
134386: CALL_OW 141
134390: GO 134378
134392: POP
134393: POP
// defenders := [ ] ;
134394: LD_ADDR_VAR 0 2
134398: PUSH
134399: EMPTY
134400: ST_TO_ADDR
// exit ;
134401: GO 135852
// end ; for i in defenders do
134403: LD_ADDR_VAR 0 4
134407: PUSH
134408: LD_VAR 0 2
134412: PUSH
134413: FOR_IN
134414: IFFALSE 135312
// begin e := NearestUnitToUnit ( enemy , i ) ;
134416: LD_ADDR_VAR 0 13
134420: PUSH
134421: LD_VAR 0 21
134425: PPUSH
134426: LD_VAR 0 4
134430: PPUSH
134431: CALL_OW 74
134435: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134436: LD_ADDR_VAR 0 7
134440: PUSH
134441: LD_EXP 99
134445: PUSH
134446: LD_VAR 0 1
134450: ARRAY
134451: PPUSH
134452: LD_INT 2
134454: PUSH
134455: LD_INT 30
134457: PUSH
134458: LD_INT 0
134460: PUSH
134461: EMPTY
134462: LIST
134463: LIST
134464: PUSH
134465: LD_INT 30
134467: PUSH
134468: LD_INT 1
134470: PUSH
134471: EMPTY
134472: LIST
134473: LIST
134474: PUSH
134475: EMPTY
134476: LIST
134477: LIST
134478: LIST
134479: PPUSH
134480: CALL_OW 72
134484: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
134485: LD_ADDR_VAR 0 16
134489: PUSH
134490: LD_VAR 0 7
134494: NOT
134495: PUSH
134496: LD_VAR 0 7
134500: PPUSH
134501: LD_INT 3
134503: PUSH
134504: LD_INT 24
134506: PUSH
134507: LD_INT 600
134509: PUSH
134510: EMPTY
134511: LIST
134512: LIST
134513: PUSH
134514: EMPTY
134515: LIST
134516: LIST
134517: PPUSH
134518: CALL_OW 72
134522: OR
134523: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
134524: LD_VAR 0 4
134528: PPUSH
134529: CALL_OW 247
134533: PUSH
134534: LD_INT 2
134536: DOUBLE
134537: EQUAL
134538: IFTRUE 134542
134540: GO 134938
134542: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
134543: LD_VAR 0 4
134547: PPUSH
134548: CALL_OW 256
134552: PUSH
134553: LD_INT 1000
134555: EQUAL
134556: PUSH
134557: LD_VAR 0 4
134561: PPUSH
134562: LD_VAR 0 13
134566: PPUSH
134567: CALL_OW 296
134571: PUSH
134572: LD_INT 40
134574: LESS
134575: PUSH
134576: LD_VAR 0 13
134580: PPUSH
134581: LD_EXP 124
134585: PUSH
134586: LD_VAR 0 1
134590: ARRAY
134591: PPUSH
134592: CALL_OW 308
134596: OR
134597: AND
134598: IFFALSE 134720
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
134600: LD_VAR 0 4
134604: PPUSH
134605: CALL_OW 262
134609: PUSH
134610: LD_INT 1
134612: EQUAL
134613: PUSH
134614: LD_VAR 0 4
134618: PPUSH
134619: CALL_OW 261
134623: PUSH
134624: LD_INT 30
134626: LESS
134627: AND
134628: PUSH
134629: LD_VAR 0 7
134633: AND
134634: IFFALSE 134704
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
134636: LD_VAR 0 4
134640: PPUSH
134641: LD_VAR 0 7
134645: PPUSH
134646: LD_VAR 0 4
134650: PPUSH
134651: CALL_OW 74
134655: PPUSH
134656: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
134660: LD_VAR 0 4
134664: PPUSH
134665: LD_VAR 0 7
134669: PPUSH
134670: LD_VAR 0 4
134674: PPUSH
134675: CALL_OW 74
134679: PPUSH
134680: CALL_OW 296
134684: PUSH
134685: LD_INT 6
134687: LESS
134688: IFFALSE 134702
// SetFuel ( i , 100 ) ;
134690: LD_VAR 0 4
134694: PPUSH
134695: LD_INT 100
134697: PPUSH
134698: CALL_OW 240
// end else
134702: GO 134718
// ComAttackUnit ( i , e ) ;
134704: LD_VAR 0 4
134708: PPUSH
134709: LD_VAR 0 13
134713: PPUSH
134714: CALL_OW 115
// end else
134718: GO 134821
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
134720: LD_VAR 0 13
134724: PPUSH
134725: LD_EXP 124
134729: PUSH
134730: LD_VAR 0 1
134734: ARRAY
134735: PPUSH
134736: CALL_OW 308
134740: NOT
134741: PUSH
134742: LD_VAR 0 4
134746: PPUSH
134747: LD_VAR 0 13
134751: PPUSH
134752: CALL_OW 296
134756: PUSH
134757: LD_INT 40
134759: GREATEREQUAL
134760: AND
134761: PUSH
134762: LD_VAR 0 4
134766: PPUSH
134767: CALL_OW 256
134771: PUSH
134772: LD_INT 650
134774: LESSEQUAL
134775: OR
134776: PUSH
134777: LD_VAR 0 4
134781: PPUSH
134782: LD_EXP 123
134786: PUSH
134787: LD_VAR 0 1
134791: ARRAY
134792: PPUSH
134793: CALL_OW 308
134797: NOT
134798: AND
134799: IFFALSE 134821
// ComMoveToArea ( i , mc_parking [ base ] ) ;
134801: LD_VAR 0 4
134805: PPUSH
134806: LD_EXP 123
134810: PUSH
134811: LD_VAR 0 1
134815: ARRAY
134816: PPUSH
134817: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
134821: LD_VAR 0 4
134825: PPUSH
134826: CALL_OW 256
134830: PUSH
134831: LD_INT 1000
134833: LESS
134834: PUSH
134835: LD_VAR 0 4
134839: PPUSH
134840: CALL_OW 263
134844: PUSH
134845: LD_INT 1
134847: EQUAL
134848: AND
134849: PUSH
134850: LD_VAR 0 4
134854: PPUSH
134855: CALL_OW 311
134859: AND
134860: PUSH
134861: LD_VAR 0 4
134865: PPUSH
134866: LD_EXP 123
134870: PUSH
134871: LD_VAR 0 1
134875: ARRAY
134876: PPUSH
134877: CALL_OW 308
134881: AND
134882: IFFALSE 134936
// begin mech := IsDrivenBy ( i ) ;
134884: LD_ADDR_VAR 0 9
134888: PUSH
134889: LD_VAR 0 4
134893: PPUSH
134894: CALL_OW 311
134898: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
134899: LD_VAR 0 9
134903: PPUSH
134904: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
134908: LD_VAR 0 9
134912: PPUSH
134913: LD_VAR 0 4
134917: PPUSH
134918: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
134922: LD_VAR 0 9
134926: PPUSH
134927: LD_VAR 0 4
134931: PPUSH
134932: CALL_OW 180
// end ; end ; unit_human :
134936: GO 135283
134938: LD_INT 1
134940: DOUBLE
134941: EQUAL
134942: IFTRUE 134946
134944: GO 135282
134946: POP
// begin b := IsInUnit ( i ) ;
134947: LD_ADDR_VAR 0 18
134951: PUSH
134952: LD_VAR 0 4
134956: PPUSH
134957: CALL_OW 310
134961: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
134962: LD_ADDR_VAR 0 19
134966: PUSH
134967: LD_VAR 0 18
134971: NOT
134972: PUSH
134973: LD_VAR 0 18
134977: PPUSH
134978: CALL_OW 266
134982: PUSH
134983: LD_INT 32
134985: PUSH
134986: LD_INT 31
134988: PUSH
134989: EMPTY
134990: LIST
134991: LIST
134992: IN
134993: OR
134994: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
134995: LD_VAR 0 18
134999: PPUSH
135000: CALL_OW 266
135004: PUSH
135005: LD_INT 5
135007: EQUAL
135008: PUSH
135009: LD_VAR 0 4
135013: PPUSH
135014: CALL_OW 257
135018: PUSH
135019: LD_INT 1
135021: PUSH
135022: LD_INT 2
135024: PUSH
135025: LD_INT 3
135027: PUSH
135028: LD_INT 4
135030: PUSH
135031: EMPTY
135032: LIST
135033: LIST
135034: LIST
135035: LIST
135036: IN
135037: AND
135038: IFFALSE 135075
// begin class := AllowSpecClass ( i ) ;
135040: LD_ADDR_VAR 0 20
135044: PUSH
135045: LD_VAR 0 4
135049: PPUSH
135050: CALL 69036 0 1
135054: ST_TO_ADDR
// if class then
135055: LD_VAR 0 20
135059: IFFALSE 135075
// ComChangeProfession ( i , class ) ;
135061: LD_VAR 0 4
135065: PPUSH
135066: LD_VAR 0 20
135070: PPUSH
135071: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
135075: LD_VAR 0 16
135079: PUSH
135080: LD_VAR 0 2
135084: PPUSH
135085: LD_INT 21
135087: PUSH
135088: LD_INT 2
135090: PUSH
135091: EMPTY
135092: LIST
135093: LIST
135094: PPUSH
135095: CALL_OW 72
135099: PUSH
135100: LD_INT 1
135102: LESSEQUAL
135103: OR
135104: PUSH
135105: LD_VAR 0 19
135109: AND
135110: PUSH
135111: LD_VAR 0 4
135115: PUSH
135116: LD_VAR 0 17
135120: IN
135121: NOT
135122: AND
135123: IFFALSE 135216
// begin if b then
135125: LD_VAR 0 18
135129: IFFALSE 135178
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
135131: LD_VAR 0 18
135135: PPUSH
135136: LD_VAR 0 21
135140: PPUSH
135141: LD_VAR 0 18
135145: PPUSH
135146: CALL_OW 74
135150: PPUSH
135151: CALL_OW 296
135155: PUSH
135156: LD_INT 10
135158: LESS
135159: PUSH
135160: LD_VAR 0 18
135164: PPUSH
135165: CALL_OW 461
135169: PUSH
135170: LD_INT 7
135172: NONEQUAL
135173: AND
135174: IFFALSE 135178
// continue ;
135176: GO 134413
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
135178: LD_ADDR_VAR 0 17
135182: PUSH
135183: LD_VAR 0 17
135187: PPUSH
135188: LD_VAR 0 17
135192: PUSH
135193: LD_INT 1
135195: PLUS
135196: PPUSH
135197: LD_VAR 0 4
135201: PPUSH
135202: CALL_OW 1
135206: ST_TO_ADDR
// ComExitBuilding ( i ) ;
135207: LD_VAR 0 4
135211: PPUSH
135212: CALL_OW 122
// end ; if sold_defenders then
135216: LD_VAR 0 17
135220: IFFALSE 135280
// if i in sold_defenders then
135222: LD_VAR 0 4
135226: PUSH
135227: LD_VAR 0 17
135231: IN
135232: IFFALSE 135280
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
135234: LD_VAR 0 4
135238: PPUSH
135239: CALL_OW 314
135243: NOT
135244: PUSH
135245: LD_VAR 0 4
135249: PPUSH
135250: LD_VAR 0 13
135254: PPUSH
135255: CALL_OW 296
135259: PUSH
135260: LD_INT 30
135262: LESS
135263: AND
135264: IFFALSE 135280
// ComAttackUnit ( i , e ) ;
135266: LD_VAR 0 4
135270: PPUSH
135271: LD_VAR 0 13
135275: PPUSH
135276: CALL_OW 115
// end ; end ; end ;
135280: GO 135283
135282: POP
// if IsDead ( i ) then
135283: LD_VAR 0 4
135287: PPUSH
135288: CALL_OW 301
135292: IFFALSE 135310
// defenders := defenders diff i ;
135294: LD_ADDR_VAR 0 2
135298: PUSH
135299: LD_VAR 0 2
135303: PUSH
135304: LD_VAR 0 4
135308: DIFF
135309: ST_TO_ADDR
// end ;
135310: GO 134413
135312: POP
135313: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
135314: LD_VAR 0 21
135318: NOT
135319: PUSH
135320: LD_VAR 0 2
135324: NOT
135325: OR
135326: PUSH
135327: LD_EXP 99
135331: PUSH
135332: LD_VAR 0 1
135336: ARRAY
135337: NOT
135338: OR
135339: IFFALSE 134317
// MC_Reset ( base , 18 ) ;
135341: LD_VAR 0 1
135345: PPUSH
135346: LD_INT 18
135348: PPUSH
135349: CALL 40747 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135353: LD_ADDR_VAR 0 2
135357: PUSH
135358: LD_VAR 0 2
135362: PUSH
135363: LD_VAR 0 2
135367: PPUSH
135368: LD_INT 2
135370: PUSH
135371: LD_INT 25
135373: PUSH
135374: LD_INT 1
135376: PUSH
135377: EMPTY
135378: LIST
135379: LIST
135380: PUSH
135381: LD_INT 25
135383: PUSH
135384: LD_INT 5
135386: PUSH
135387: EMPTY
135388: LIST
135389: LIST
135390: PUSH
135391: LD_INT 25
135393: PUSH
135394: LD_INT 8
135396: PUSH
135397: EMPTY
135398: LIST
135399: LIST
135400: PUSH
135401: LD_INT 25
135403: PUSH
135404: LD_INT 9
135406: PUSH
135407: EMPTY
135408: LIST
135409: LIST
135410: PUSH
135411: EMPTY
135412: LIST
135413: LIST
135414: LIST
135415: LIST
135416: LIST
135417: PPUSH
135418: CALL_OW 72
135422: DIFF
135423: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
135424: LD_VAR 0 21
135428: NOT
135429: PUSH
135430: LD_VAR 0 2
135434: PPUSH
135435: LD_INT 21
135437: PUSH
135438: LD_INT 2
135440: PUSH
135441: EMPTY
135442: LIST
135443: LIST
135444: PPUSH
135445: CALL_OW 72
135449: AND
135450: IFFALSE 135788
// begin tmp := FilterByTag ( defenders , 19 ) ;
135452: LD_ADDR_VAR 0 11
135456: PUSH
135457: LD_VAR 0 2
135461: PPUSH
135462: LD_INT 19
135464: PPUSH
135465: CALL 102273 0 2
135469: ST_TO_ADDR
// if tmp then
135470: LD_VAR 0 11
135474: IFFALSE 135544
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
135476: LD_ADDR_VAR 0 11
135480: PUSH
135481: LD_VAR 0 11
135485: PPUSH
135486: LD_INT 25
135488: PUSH
135489: LD_INT 3
135491: PUSH
135492: EMPTY
135493: LIST
135494: LIST
135495: PPUSH
135496: CALL_OW 72
135500: ST_TO_ADDR
// if tmp then
135501: LD_VAR 0 11
135505: IFFALSE 135544
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
135507: LD_ADDR_EXP 111
135511: PUSH
135512: LD_EXP 111
135516: PPUSH
135517: LD_VAR 0 1
135521: PPUSH
135522: LD_EXP 111
135526: PUSH
135527: LD_VAR 0 1
135531: ARRAY
135532: PUSH
135533: LD_VAR 0 11
135537: UNION
135538: PPUSH
135539: CALL_OW 1
135543: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
135544: LD_VAR 0 1
135548: PPUSH
135549: LD_INT 19
135551: PPUSH
135552: CALL 40747 0 2
// repeat wait ( 0 0$1 ) ;
135556: LD_INT 35
135558: PPUSH
135559: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135563: LD_EXP 99
135567: PUSH
135568: LD_VAR 0 1
135572: ARRAY
135573: NOT
135574: PUSH
135575: LD_EXP 99
135579: PUSH
135580: LD_VAR 0 1
135584: ARRAY
135585: PUSH
135586: EMPTY
135587: EQUAL
135588: OR
135589: IFFALSE 135626
// begin for i in defenders do
135591: LD_ADDR_VAR 0 4
135595: PUSH
135596: LD_VAR 0 2
135600: PUSH
135601: FOR_IN
135602: IFFALSE 135615
// ComStop ( i ) ;
135604: LD_VAR 0 4
135608: PPUSH
135609: CALL_OW 141
135613: GO 135601
135615: POP
135616: POP
// defenders := [ ] ;
135617: LD_ADDR_VAR 0 2
135621: PUSH
135622: EMPTY
135623: ST_TO_ADDR
// exit ;
135624: GO 135852
// end ; for i in defenders do
135626: LD_ADDR_VAR 0 4
135630: PUSH
135631: LD_VAR 0 2
135635: PUSH
135636: FOR_IN
135637: IFFALSE 135726
// begin if not IsInArea ( i , mc_parking [ base ] ) then
135639: LD_VAR 0 4
135643: PPUSH
135644: LD_EXP 123
135648: PUSH
135649: LD_VAR 0 1
135653: ARRAY
135654: PPUSH
135655: CALL_OW 308
135659: NOT
135660: IFFALSE 135684
// ComMoveToArea ( i , mc_parking [ base ] ) else
135662: LD_VAR 0 4
135666: PPUSH
135667: LD_EXP 123
135671: PUSH
135672: LD_VAR 0 1
135676: ARRAY
135677: PPUSH
135678: CALL_OW 113
135682: GO 135724
// if GetControl ( i ) = control_manual then
135684: LD_VAR 0 4
135688: PPUSH
135689: CALL_OW 263
135693: PUSH
135694: LD_INT 1
135696: EQUAL
135697: IFFALSE 135724
// if IsDrivenBy ( i ) then
135699: LD_VAR 0 4
135703: PPUSH
135704: CALL_OW 311
135708: IFFALSE 135724
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
135710: LD_VAR 0 4
135714: PPUSH
135715: CALL_OW 311
135719: PPUSH
135720: CALL_OW 121
// end ;
135724: GO 135636
135726: POP
135727: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
135728: LD_VAR 0 2
135732: PPUSH
135733: LD_INT 95
135735: PUSH
135736: LD_EXP 123
135740: PUSH
135741: LD_VAR 0 1
135745: ARRAY
135746: PUSH
135747: EMPTY
135748: LIST
135749: LIST
135750: PPUSH
135751: CALL_OW 72
135755: PUSH
135756: LD_VAR 0 2
135760: EQUAL
135761: PUSH
135762: LD_EXP 122
135766: PUSH
135767: LD_VAR 0 1
135771: ARRAY
135772: OR
135773: PUSH
135774: LD_EXP 99
135778: PUSH
135779: LD_VAR 0 1
135783: ARRAY
135784: NOT
135785: OR
135786: IFFALSE 135556
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
135788: LD_ADDR_EXP 121
135792: PUSH
135793: LD_EXP 121
135797: PPUSH
135798: LD_VAR 0 1
135802: PPUSH
135803: LD_VAR 0 2
135807: PPUSH
135808: LD_INT 21
135810: PUSH
135811: LD_INT 2
135813: PUSH
135814: EMPTY
135815: LIST
135816: LIST
135817: PPUSH
135818: CALL_OW 72
135822: PPUSH
135823: CALL_OW 1
135827: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
135828: LD_VAR 0 1
135832: PPUSH
135833: LD_INT 19
135835: PPUSH
135836: CALL 40747 0 2
// MC_Reset ( base , 20 ) ;
135840: LD_VAR 0 1
135844: PPUSH
135845: LD_INT 20
135847: PPUSH
135848: CALL 40747 0 2
// end ; end_of_file
135852: LD_VAR 0 3
135856: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
135857: LD_VAR 0 1
135861: PUSH
135862: LD_INT 200
135864: DOUBLE
135865: GREATEREQUAL
135866: IFFALSE 135874
135868: LD_INT 299
135870: DOUBLE
135871: LESSEQUAL
135872: IFTRUE 135876
135874: GO 135908
135876: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
135877: LD_VAR 0 1
135881: PPUSH
135882: LD_VAR 0 2
135886: PPUSH
135887: LD_VAR 0 3
135891: PPUSH
135892: LD_VAR 0 4
135896: PPUSH
135897: LD_VAR 0 5
135901: PPUSH
135902: CALL 124643 0 5
135906: GO 135985
135908: LD_INT 300
135910: DOUBLE
135911: GREATEREQUAL
135912: IFFALSE 135920
135914: LD_INT 399
135916: DOUBLE
135917: LESSEQUAL
135918: IFTRUE 135922
135920: GO 135984
135922: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
135923: LD_VAR 0 1
135927: PPUSH
135928: LD_VAR 0 2
135932: PPUSH
135933: LD_VAR 0 3
135937: PPUSH
135938: LD_VAR 0 4
135942: PPUSH
135943: LD_VAR 0 5
135947: PPUSH
135948: LD_VAR 0 6
135952: PPUSH
135953: LD_VAR 0 7
135957: PPUSH
135958: LD_VAR 0 8
135962: PPUSH
135963: LD_VAR 0 9
135967: PPUSH
135968: LD_VAR 0 10
135972: PPUSH
135973: LD_VAR 0 11
135977: PPUSH
135978: CALL 120976 0 11
135982: GO 135985
135984: POP
// end ;
135985: PPOPN 11
135987: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
135988: LD_VAR 0 1
135992: PPUSH
135993: LD_VAR 0 2
135997: PPUSH
135998: LD_VAR 0 3
136002: PPUSH
136003: LD_VAR 0 4
136007: PPUSH
136008: LD_VAR 0 5
136012: PPUSH
136013: CALL 124379 0 5
// end ; end_of_file
136017: PPOPN 5
136019: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
136020: LD_VAR 0 1
136024: PPUSH
136025: LD_VAR 0 2
136029: PPUSH
136030: LD_VAR 0 3
136034: PPUSH
136035: LD_VAR 0 4
136039: PPUSH
136040: LD_VAR 0 5
136044: PPUSH
136045: LD_VAR 0 6
136049: PPUSH
136050: CALL 108669 0 6
// end ;
136054: PPOPN 6
136056: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
136057: LD_INT 0
136059: PPUSH
// begin if not units then
136060: LD_VAR 0 1
136064: NOT
136065: IFFALSE 136069
// exit ;
136067: GO 136069
// end ;
136069: PPOPN 7
136071: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
136072: CALL 108640 0 0
// end ;
136076: PPOPN 1
136078: END
